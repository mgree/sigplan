{"article_publication_date": "06-05-2010", "fulltext": "\n Breadcrumbs: Ef.cient Context Sensitivity for Dynamic Bug Detection Analyses * Michael D. Bond Graham \nZ. Baker Samuel Z. Guyer University of Texas at Austin MIT Lincoln Laboratory Tufts University mikebond@cs.utexas.edu \nTufts University sguyer@cs.tufts.edu gzbaker@ll.mit.edu Abstract Calling context the set of active methods \non the stack is criti\u00adcal for understanding the dynamic behavior of large programs. Dy\u00adnamic program \nanalysis tools, however, are almost exclusively con\u00adtext insensitive because of the prohibitive cost \nof representing call\u00ading contexts at run time. Deployable dynamic analyses, in particu\u00adlar, have been \nlimited to reporting only static program locations. This paper presents Breadcrumbs, an ef.cient technique \nfor recording and reporting dynamic calling contexts. It builds on an existing technique for computing \na compact (one word) encoding of each calling context that client analyses can use in place of a program \nlocation. The key feature of our system is a search algo\u00adrithm that can reconstruct a calling context \nfrom its encoding using only a static call graph and a small amount of dynamic information collected \nat cold (infrequently executed) callsites. Breadcrumbs re\u00adquires no of.ine training or program modi.cations, \nand handles all language features, including dynamic class loading. We use Breadcrumbs to add context \nsensitivity to two dynamic analyses: a data-race detector and an analysis for diagnosing null pointer \nexceptions. On average, it adds 10% to 20% runtime over\u00adhead, depending on a tunable parameter that controls \nhow much dy\u00adnamic information is collected. Collecting less information lowers the overhead, but can \nresult in a search space explosion. In some cases this causes reconstruction to fail, but in most cases \nBread\u00adcrumbs produces non-trivial calling contexts that have the potential to signi.cantly improve both \nthe precision of the analyses and the quality of the bug reports. Categories and Subject Descriptors \nD.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation Reliability, Statistical Meth\u00adods General \nTerms Reliability, Performance, Experimentation Keywords Context sensitivity, dynamic analysis, bug detection \n* This material is based on work supported by the National Science Foun\u00addation under grants CCF-0916810 \nand SHF-0910818, by IBM, by the Lin\u00adcoln Scholars Program at MIT Lincoln Laboratory, and by the Department \nof the Air Force under contract FA8721-05-C-0002. Opinions, interpreta\u00adtions, conclusions, and recommendations \nare those of the authors and are not necessarily endorsed by the United States Government. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 10, June 5 \n10, 2010, Toronto, Ontario, Canada. Copyright c &#38;#169; 2010 ACM 978-1-4503-0019-3/10/06 ...$10.00 \n1. Introduction A stack trace is one of the most useful pieces of information to have when debugging \na program failure. A stack trace captures the full dynamic calling context of the code that failed, not \njust its static program location. This level of detail is crucial for debugging object-oriented programs, \nwhich have many small methods and a high degree of reuse. Producing a stack trace at the point of failure \nis straightforward: with the program halted, a debugging tool can inspect the program s stack directly \nand emit a sequence of methods or call sites for the programmer to inspect. The cost of computing or \nstoring the stack trace is largely unimportant. Recently, more sophisticated dynamic debugging techniques \nhave focused on identifying the root causes of bugs, not just the immediate circumstances of failures. \nDuring normal execution they record extra information that might be useful in explaining a failure, if \none occurs. Dynamic race detection tools, for example, record in\u00adformation about all memory accesses; \nwhen a race is detected they report both the access that triggered the detector and the earlier access \nwith which it con.icts. Ideally, such a bug report would in\u00adclude multiple stack traces: one for the \npoint of failure, and one for each event leading up to it. For these bug detectors the na\u00a8ive ap\u00adproach \nof walking the stack and recording an explicit calling con\u00adtext at every event for example, every memory \naccess is simply too expensive. As a result, most tools are limited to recording just static program \nlocations (e.g., method and bytecode index), which can be quickly obtained and compactly stored. This \npaper presents Breadcrumbs, an ef.cient runtime mech\u00adanism for recording and reporting dynamic calling \ncontexts. Our work builds on an existing mechanism called probabilistic calling context: during execution \nour system computes a probabilistically unique ID (called a PCC value) for each calling context [Bond \nand McKinley 2007]. A dynamic debugging tool can be made context sensitive by using the PCC value to \ntag program events or anal\u00adysis information wherever it would have used a simple program location. The \nmain limitation of the original PCC work is that it provides no way to retrieve information about the \ncalling context that a PCC value represents. As a result, calling contexts can be distinguished, but \nnot identi.ed and reported to the programmer. Breadcrumbs collects a small amount of additional information \nat run time that allows it to decode a PCC value back into its original sequence of calls. Decoding occurs \nof.ine (for example, when a bug report is needed) because it involves a potentially expensive search \nof the PCC value space. The online component, however, consists of lightweight instrumentation, which \nkeeps the overhead during correct execution low enough for use in debugging and analysis tools for deployed \nsoftware. In addition, unlike recent related techniques, our system does not require any ahead-of-time \ntraining, data collection, or program analysis.  The key problem we solve is collecting enough extra \ninforma\u00adtion at run time to allow accurate decoding of PCC values without incurring a large overhead. \nSince PCC values are computed top\u00addown during execution (that is, the PCC value in a method is com\u00adputed \nas a function of the PCC value in its caller and a callsite ID), the decoding algorithm is naturally \na bottom-up search: starting at the most recent method, it inverts the computation at each callsite, \nmoving from callees to callers until it reaches main. Even though decoding occurs of.ine, a blind search \nof the PCC space is much too expensive and results in many false matches because many stat\u00adically possible \ncontexts map to the same PCC value. To constrain the search, Breadcrumbs collects two additional kinds \nof informa\u00adtion at run time: (1) a static call graph, which constrains which potential callers it must \nconsider, and (2) the set of PCC values observed at a callsite. Since method calls are extremely frequent, \nhowever, we can only build these sets for code that is relatively cold (executed infrequently). This \nthreshold is a tunable parame\u00adter that trades online performance for reconstruction accuracy. In a sense, \nBreadcrumbs computes a probabilistic calling context tree online for the cold code, and then searches \nthe PCC space of.ine, constrained by the static call graph where available, to .ll in the gaps for the \nhot code. We implement Breadcrumbs in Jikes RVM, a high-performance Java-in-Java virtual machine [Alpern \net al. 1999], and integrate it with two real dynamic debugging tools: (1) a dynamic race detector based \non the FastTrack algorithm [Flanagan and Freund 2009] and (2) origin tracking, an analysis for diagnosing \nnull pointer excep\u00adtions [Bond et al. 2007]. Our system is able to reconstruct almost all calling contexts \nfor the bugs reported with overheads of 10% to 20% on average (depending on the hotness threshold). With \nBread\u00adcrumbs, origin tracking reports a full stack trace for both the ex\u00adception and the origin of the \nnull value. The race detector reports the full calling context of most con.icting memory accesses, and \nseparates buggy from non-buggy uses of common code. For one program, however, reconstruction fails with \nall but the highest hot callsite thresholds because the contexts involve long chains of hot callsites \nwith multiple statically possible callers. The resulting bug reports provide much more information than \ncontext-insensitive static program location, although we have not qualitatively eval\u00aduated the usefulness \nof the reported contexts. The rest of this paper is organized as follows. First, we dis\u00adcuss the bene.ts \nof context sensitivity for dynamic analysis, and the class of dynamic analysis tools that can bene.t \nfrom this tech\u00adnique. Section 3 presents the Breadcrumbs decoding algorithm and associated runtime support. \nIn Section 4 we evaluate Breadcrumbs by making two dynamic bug detectors context sensitive. 2. Motivation \nDynamic analysis has emerged as an important technique for under\u00adstanding program behavior and, in particular, \ndetecting program\u00adming errors. Catching bugs at run time has a number of advan\u00adtages over other techniques, \nsuch as static analysis and testing. It works on all inputs, easily handles language features such as \ndy\u00adnamic class loading and bytecode rewriting, and, in many cases, produces no false positives. In addition, \nit is effective for catching dif.cult-to-reproduce errors, such as race conditions. Monitoring programs \nat run time, however, imposes signi.cant constraints on the analysis algorithm, both in terms of time \nand space. Deployable dynamic analyses, in particular, cannot signif\u00adicantly degrade program performance. \nAs a result, most dynamic bug detectors are context insensitive: they analyze and report bugs strictly \nin terms of static program locations. For modern object-oriented programs, however, static program locations \nare often insuf.cient to explain program behavior. These programs exhibit complex patterns of code reuse \nand delegation that make it hard to understand how execution arrived at a par\u00adticular point. In addition, \nthese programs consist of many layers of software, assembled using components and application frame\u00adworks. \nContext sensitivity is critical for understanding the circum\u00adstances of an error. The goal of Breadcrumbs \nis to provide an ef.cient and general mechanism for making deployable dynamic bug detectors context sensitive. \nIn this section we discuss the bene.ts and challenges of context sensitivity in a dynamic setting, and \nwe describe the class of applications that will bene.t from our approach. 2.1 Why context sensitivity? \nContext sensitivity is crucial for understanding the behavior of large object-oriented programs [Inoue \nand Nakatani 2009; Lhot\u00b4ak and Hendren 2008]. Unlike static analysis, however, prior work on dynamic \nanalysis has largely avoided context sensitivity because no ef.cient technique was known. Dynamic analysis \ntools, such as bug detectors, however, stand to bene.t considerably from context sensitivity, which improves \nboth the precision of the analysis and the quality of the bug reports. Context sensitivity improves precision \nby separating buggy from non-buggy uses of the same code. Modern software is as\u00adsembled from class libraries, \napplication frameworks, and other reusable components. Failures in common code might occur in some contexts \nof use and not in others. In our race detection exper\u00adiments, for example, we discovered that one static \nprogram location is actually involved in several dynamically distinct races. Context sensitivity improves \nbug reporting by providing more information about the circumstances of relevant program events. State-of-the-art \nmemory leak detectors, for example, tag each ob\u00adject with its allocation site [Chilimbi and Hauswirth \n2004]. If a leak is detected, the allocation site is used to identify the objects involved. With factory \nmethods, however, objects of a particular class are all generated at a single allocation site. Using \nonly static program locations, this information is essentially useless for de\u00adbugging. Tagging objects \nwith the full calling context of their al\u00adlocation solves the problem by revealing the context in which \nthe factory method was called. In addition, when the origin of a bug and the point of failure are far \napart in the program, it is not always obvious how they are connected. With the full calling context \nfor both, it is much easier to see how control .ows from one to the other. The main challenge, for both \nstatic and dynamic analyses, is the shear number of calling contexts. In theory, this number is expo\u00adnential \nin the size of the program. In practice, even relatively small programs can have millions of calling \ncontexts. In the presence of recursion, the number of possible calling contexts is unbounded.  2.2 Target \nclientele Breadcrumbs makes a tradeoff between cost and precision that is targeted at deployable bug \ndetectors. These clients represent a broad class of dynamic analyses with the following properties: 1. \nCorrect execution must be fast: our goal is to provide context sensitivity in a deployed or .eld-testing \nenvironment. 2. Tracked events are numerous: the client analysis records many context-sensitive events \nonline, not knowing which ones might later be relevant for error reporting. 3. Reconstruction of calling \ncontext information can occur of.ine: while correct execution is fast, reconstructing calling contexts \nfor use in bug reports can be expensive because it involves exploring a potentially large search space. \n  4. Imprecision is acceptable: our system trades precision for per\u00adformance and may fail to reconstruct \na calling context from its encoding or even report an incorrect calling context. Correct execution must \nbe fast. Deployable bug detectors have become increasingly important for languages like Java, which in\u00adclude \nmany features that hamper other methods of error detection. Unlike static analysis, dynamic analysis \noperates on the concrete program rather than an abstract approximation, often catching all the real errors \nthat occur in an execution, without false positives. Dynamic analysis also works naturally in the presence \nof dynamic class loading and bytecode rewriting. Deployable bug detectors also catch dif.cult-to-reproduce \nerrors, such as race conditions, which are often missed during routine testing. To be deployable, however, \na bug detector must avoid slowing the program signi.\u00adcantly. Breadcrumbs keeps time and space overheads \nlow and in\u00adcludes a tunable parameter (see Section 3) that controls the amount of overhead versus the \naccuracy of decoding. Events are numerous. Providing context sensitivity in a de\u00adployed setting is particularly \nchallenging when events that need calling context information occur very frequently. The dynamic analysis \nclients presented in Section 4, for example, record every memory access (for race detection), and every \nnull pointer assign\u00adment (for origin tracking). The context-insensitive versions of these analyses record \nthe static program location of each event, which is cheap to compute and store. To make them context \nsensitive, they need to record the calling context of each event. Using an explicit representation, such \nas a stack trace or a dynamic calling context tree (Section 5), would be much too expensive, as the next \ntwo paragraphs explain. Creating an explicit stack trace is relatively slow and occupies space proportional \nto the depth of the calling context (e.g., as an array of callsites) [Nethercote and Seward 2007; Seward \nand Nethercote 2005]. For infrequent events, however, this cost is easily hidden; for example, a dynamic \nanalysis that records the calling context at each new thread start can afford to simply walk the stack \nevery time. For frequent events, however, both the time and space costs are much too high for use in \ndeployed software [Bond and McKinley 2007; Bond et al. 2009]. An alternative is to build a dynamic calling \ncontext tree (CCT) in which each node represents a unique calling context [Ammons et al. 1997; Spivey \n2004]. Per event recorded, the time and space costs are very low: a calling context is identi.ed by a \npointer into the tree. Building and maintaining the CCT, however, requires every method call to check \nthe set of children contexts and create a new node if necessary. In addition, the tree can become very \nlarge: the eclipse benchmark, for example, executes 35,000 static callsites resulting in 10 million unique \ncalling contexts (see Table 1 in Section 4). Reconstruction occurs of.ine. In order to control overhead \ndur\u00ading correct execution, our system collects only a limited amount of information for use in decoding \nPCC values. As a result, re\u00adconstruction is more dif.cult and often too expensive to perform online. \nThe information we collect is essentially pieces of the dy\u00adnamic CCT, constructed only for cold code. \nIn order to decode an arbitrary PCC value, Breadcrumbs must .ll in the missing gaps for the hot code, \nwhich involves searching the space of PCC values. This search space can be large, especially for long \nsequences of hot method calls. Therefore, our technique is most suitable for er\u00adror reporting and logging, \nwhere the cost of reconstruction is paid of.ine. Imprecision is acceptable. A second consequence of collecting \nlimited information is that Breadcrumbs cannot always success\u00adfully decode a PCC value. Due to the large \nsearch space, Bread\u00adcrumbs reconstructs calling contexts using an iterative deepening algorithm with \na .xed time budget (.ve seconds in our experi\u00adments). In some cases, Breadcrumbs fails to reconstruct \nthe correct calling context within the allotted time. In addition, because many statically possible contexts \nmap to the same PCC value, Bread\u00adcrumbs may report an incorrect calling context. Eliminating both of \nthese kinds of failure cases is an ongoing part of our research. 3. Breadcrumbs algorithm Breadcrumbs \nbuilds on probabilistic calling context (PCC) [Bond and McKinley 2007], an online technique for computing \na proba\u00adbilistically unique ID (called a PCC value) for each dynamic call\u00ading context. While PCC computes \nan ef.cient and compact encod\u00ading of calling contexts, it provides no way to decode a PCC value for use \nin bug reporting. This section describes our calling context reconstruction algorithm and the additional \nruntime support needed to make this decoding possible. Figure 1 contains Java code that will serve as \na running example in the discussion below. This program contains a bug: it throws a null pointer exception \nat the call to println() on line 27 (suppose that calling println(null) results in a null pointer exception). \nIn Section 4 we describe how origin tracking is used to identify the origin of the null (a call to clearMsg()), \nand how we use Breadcrumbs to augment origin tracking so that it can report the full calling context \nof the origin, which identi.es the speci.c call to clearMsg() that causes the bug. Figure 2 shows the \ncall graph for the example, with callsites labeled according to the line number of the call in the code \n(e.g., c@23 refers to the callsite on line 23.) 3.1 The PCC decoding problem Each PCC value is essentially \na hash of the sequence of callsites that compose a calling context. PCC values are computed contin\u00aduously \nduring execution, so that dynamic analyses can obtain a representation of the current calling context \nat any time. At every method call, a PCC value for the new context is computed as a func\u00adtion of the \nPCC value in the caller, plus an identi.er representing the callsite. Speci.cally, given a PCC value \np for the current calling context, and a callsite ID c, it computes the new calling context in the callee \nas: f(p, c) = (3p + c) mod 232 The initial PCC value representing the top-most context (the main method) \nis zero; c0 represents a callsite in main and cn represents the most recent call. Computing PCC values \nduring execution pro\u00adceeds as follows: p0 =0 {the main calling context}p1 = f(p0,c0) {context in callee \ninvoked at c0 in main}... pi = f(pi-1,ci-1) ... pn = f(pn-1,cn-1) In Figure 2, for example, the PCC value \nfor the calling context main().B.virtualMethod().clearMsg().setMsg would be computed as f(f(f(0,c@24),c@13),c@6). \nDynamic analysis tools can label analysis information with this PCC value to indicate it was collected \nin this speci.c calling context of setMsg(). The PCC value decoding problem can be described abstractly \nas follows: given a PCC value pn, .nd a sequence of callsite IDs c0, c1, ..., cn-1 such that pn = f(f(...f \n(0,c0)..., cn-2),cn-1) \n\t\t\t", "proc_id": "1806596", "abstract": "<p>Calling context--the set of active methods on the stack--is critical for understanding the dynamic behavior of large programs. Dynamic program analysis tools, however, are almost exclusively context insensitive because of the prohibitive cost of representing calling contexts at run time. Deployable dynamic analyses, in particular, have been limited to reporting only static program locations.</p> <p>This paper presents Breadcrumbs, an efficient technique for recording and reporting dynamic calling contexts. It builds on an existing technique for computing a compact (one word) encoding of each calling context that client analyses can use in place of a program location. The key feature of our system is a search algorithm that can reconstruct a calling context from its encoding using only a static call graph and a small amount of dynamic information collected at cold (infrequently executed) callsites. Breadcrumbs requires no offline training or program modifications, and handles all language features, including dynamic class loading.</p> <p>We use Breadcrumbs to add context sensitivity to two dynamic analyses: a data-race detector and an analysis for diagnosing null pointer exceptions. On average, it adds 10% to 20% runtime overhead, depending on a tunable parameter that controls how much dynamic information is collected. Collecting less information lowers the overhead, but can result in a search space explosion. In some cases this causes reconstruction to fail, but in most cases Breadcrumbs &gt;produces non-trivial calling contexts that have the potential to significantly improve both the precision of the analyses and the quality of the bug reports.</p>", "authors": [{"name": "Michael D. Bond", "author_profile_id": "81100148693", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P2184487", "email_address": "", "orcid_id": ""}, {"name": "Graham Z. Baker", "author_profile_id": "81464647733", "affiliation": "MIT Lincoln Laboratory, Lexington, MA, USA", "person_id": "P2184488", "email_address": "", "orcid_id": ""}, {"name": "Samuel Z. Guyer", "author_profile_id": "81332502517", "affiliation": "Tufts University, Medford, MA, USA", "person_id": "P2184489", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1806596.1806599", "year": "2010", "article_id": "1806599", "conference": "PLDI", "title": "Breadcrumbs: efficient context sensitivity for dynamic bug detection analyses", "url": "http://dl.acm.org/citation.cfm?id=1806599"}