{"article_publication_date": "06-05-2010", "fulltext": "\n Type-preserving Compilation for End-to-end Veri.cation of Security Enforcement Juan Chen Ravi Chugh \nNikhil Swamy Microsoft Research University of California, San Diego Microsoft Research juanchen@microsoft.com \nrchugh@cs.ucsd.edu nswamy@microsoft.com Abstract A number of programming languages use rich type systems \nto ver\u00adify security properties of code. Some of these languages are meant for source programming, but \nprograms written in these languages are compiled without explicit security proofs, limiting their utility \nin settings where proofs are necessary, e.g., proof-carrying autho\u00adrization. Others languages do include \nexplicit proofs, but these are generally lambda calculi not intended for source programming, that must \nbe further compiled to an executable form. A language suit\u00adable for source programming backed by a compiler \nthat enables end-to-end veri.cation is missing. In this paper, we present a type-preserving compiler \nthat trans\u00adlates programs written in FINE, a source-level functional language with dependent re.nements \nand af.ne types, to DCIL, a new exten\u00adsion of the .NET Common Intermediate Language. FINE is type checked \nusing an external SMT solver to reduce the proof bur\u00adden on source programmers. We extract explicit LCF-style \nproof terms from the solver and carry these proof terms in the compila\u00adtion to DCIL, thereby removing \nthe solver from the trusted com\u00adputing base. Explicit proofs enable DCIL to be used in a number of important \nscenarios, including the veri.cation of mobile code, proof-carrying authorization, and evidence-based \nauditing. We re\u00adport on our experience using FINE to build reference monitors for several applications, \nranging from a plugin-based email client to a conference management server. Categories and Subject Descriptors \nD.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory General Terms Security, Veri.cation, Languages, \nTheory Keywords Security type systems, dependent types, bytecode lan\u00adguages, functional programming, \nauthorization, information .ow, mobile code security, compilers 1. Introduction On today s internet, \nusers concerned about their security and pri\u00advacy would be well advised to be wary of the code they download \nand run on their computers. However, for the lack of an alternative, users routinely download complex \nprograms (often as JavaScript in browsers, but also Flash, Java, and .NET plugins, applications for mobile \nphones, etc.) from unknown parties and allow these pro\u00adgrams free access to their sensitive data. With \nthe advent of cloud Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 10, June 5 10, 2010, Toronto, Ontario, Canada. Copyright c . 2010 ACM 978-1-4503-0019-3/10/06. \n.. $10.00 services, using the technologies currently at our disposal, users may also have no choice but \nto implicitly trust that service providers protect their data and computations properly. As a step towards \nimproving this state of affairs, we want users to be able to specify rich policies to control their security \nand pri\u00advacy, and to receive formal proofs that the code they download, or the cloud services they rely \nupon, always respect these policies. But, the policies used in practice are complex, and properly enforc\u00ading \nthem, let alone producing proofs, is known to be hard. In response to this challenge, researchers have \nproposed several programming languages with rich type systems tailored towards proving security properties \nof code. However, a language with the ingredients to enable programmers to state and enforce complex \nreal-world security policies policies that mix aspects of authenti\u00adcation with stateful authorization \nand information .ow controls combined with a compiler that produces proofs that these policies are properly \nenforced does not yet exist. For example, a number of prior languages, including Fa\u00adble (Swamy et al. \n2008), Aura (Jia et al. 2008), and PCML5 (Avijit et al. 2010) use dependent types to specify and enforce \nmany kinds of policies, including (stateless) authorization and information .ow controls. While type \nchecking ensures that programs written in these languages are secure, programmers are required to construct \nproof terms to convince the type checker to accept their programs. The additional burden of programming \nwith proofs causes the au\u00adthors of at least Fable and Aura to position their systems as interme\u00addiate \nlanguages, rather than for source programming. Furthermore, all these languages are based on lambda calculi \nthat must be com\u00adpiled further to be executable on commodity systems. In an effort to make source programming \neasier, languages like F7(Bengtsonetal.2008)and FINE (Swamyetal.2010)relyonthe\u00adorem provers to automatically \ndischarge proof obligations during type checking. These languages have been shown to be effective in \nverifying implementations of cryptographic protocols (F7) as well as checking that programs correctly \nenforce stateful authorization and information .ow policies (FINE). However, to date, compilers for F7 \nand FINE do not produce veri.able security proofs, mak\u00ading them unsuitable for scenarios where proofs \nare needed, e.g., in mobile code settings where users would like to verify binaries; when security proofs \nneed to be communicated between agents (as in proof-carrying authorization (Appel and Felten 1999)); \nor, when service providers need to construct audit trails for accountability (as in evidence-based audit \n(Vaughan et al. 2008)). This paper presents a compiler that aims to .ll this gap. Our compiler translates \nFINE programs to DCIL, an extension of the .NET Common Intermediate Language (CIL) (ECMA 2006), and affords \nsource programmers the bene.t of a reduced proof burden by automatically discharging proof obligations \nusing the Z3 SMT solver (de Moura and Bjorner 2008). By extracting typeable proof terms from Z3, we also \ngain the bene.ts of compiling programs with explicit proofs. Additionally, by preserving types to the \nbyte\u00adcode level, we remove both the solver and much of our compiler from the trusted computing base (TCB), \nrelying only on the DCIL type checker for bytecode veri.cation and on the .NET virtual ma\u00adchine to faithfully \nexecute the program. As such, we view our work as a stepping stone to future work that reduces the TCB \nfurther by, say, compiling DCIL to a typed assembly language (Morrisett et al. 1999). Meanwhile, our \napproach makes it possible to run FINE pro\u00adgrams on stock .NET virtual machines; to interoperate with \nother more mainstream .NET languages; and to bene.t from the libraries and tool support that come with \nthe .NET platform.  1.1 Contributions Theory. This paper makes three theoretical contributions. First, \nwe formalize DCIL, an object-oriented bytecode language with depen\u00addent and af.ne types and prove it \nsound. Our extensions are de\u00adsigned to be small and compatible with the existing standard for CIL. Second, \nwe formalize a translation from FINE to DCIL and prove that our translation preserves types. A .nal theoretical \ncontri\u00adbution is a source-to-source transformation of FINE programs, also proved to preserve types. We \ndub this transformation dere.nement and explain its signi.cance shortly. A compiler implementation. We \nhave implemented a compiler that translates FINE programs to executable CIL assemblies, veri\u00ad.able using \na type checker for DCIL. While this compiler remains under active development, an initial release is \navailable on the web. A key component of our compiler is a module that translates proofs produced by \nZ3 into typeable proof terms in FINE. Type\u00adchecking proof terms produced by SMT solvers is an area of \nactive research we are aware of one project (B\u00a8ohme 2009), concurrent with ours, that aims to reconstruct \nand check proofs for Z3. Mobile-code security. Our prior work (Swamy et al. 2010) shows how FINE can \nbe used to build secure reference monitors for server programs. In this paper, we show how FINE can be \nused in a mobile-code setting. Our main example shows how to use FINE to implement a reference monitor \nfor a model of a plugin-based of.ce utilities client we call this model application LOOKOUT. Subject \nto a user s security policy, plugins can read emails in a user s inbox, make appointments in a calendar, \nsend email responses, store data in a cookie store and selectively share this data with other plugins. \nWe give examples of several kinds of security policies applied to plugins, including those that track \ninformation .ows combined with role-and history-based authorization. Plugins for LOOKOUT can be shipped \nas DCIL assemblies and veri.ed against a security policy before being installed by a user. Experimental \nevaluation. We report on experiments using our compiler on about 12,000 lines of code, of which nearly \n2,000 lines are from application programs or their reference monitors, and the rest a library of veri.ed \nlemmas that simplify proof term construction. Despite further opportunities for optimization, the type \nchecker of DCIL is already quite fast it takes less than seven seconds to typecheck a 50MB assembly. \nHowever, compiling with proofs does impose an overhead .NET assemblies that carry proof terms extracted \nfrom Z3 can, in some cases, be as much as 50 times larger than those without proofs. This is perhaps \nindicative of a bias in the SMT solving community to optimize for speed rather than for conciseness of \nproofs. Indeed, Z3 is among the few solvers that produce proof certi.cates at all. Our experiments include \nresults from a simple custom .rst-order logic prover which, while not nearly as full-featured as Z3, \nis optimized to produce small proofs. When using this solver, we .nd that the overhead in code size due \nto proofs can be reduced to a factor of 2, i.e., a 25x improvement over Z3. This suggests that while \nthe move towards certifying SMT solvers is a step in the right direction, there is much room for improvement \nin the size of proofs produced by these solvers.  1.2 Overview Before we begin with the main content, \nwe present a brief and informal overview of programming in FINE, and the main ideas behind the type-preserving \ncompilation of FINE to DCIL. Programming in FINE (\u00a72). FINE is a functional programming lan\u00adguage with \na type system based on dependent re.nement types. FINE also includes af.ne (use at most once) types to \nmodel state. While FINE can be used for general-purpose programming, we in\u00adtend, primarily, for FINE \nto be used in the implementation of the se\u00adcurity critical components of an application, e.g., a reference \nmoni\u00adtor. Programmers can give types that include security constraints to the sensitive resources in \na program, and code that exposes an in\u00adterface to these resources to the rest of the application can \nbe type checked to ensure that it interposes the correct security checks. For example, when enforcing \nan access control policy on .les, a programmer may give the fread system call the following type: p:prin \n. cred p .{f:.le | CanRead p f}. string. This is the type of a dependent function whose .rst parameter \nof type prin stands for the name of a principal in the system. As is usual with dependent types, the \nparameter can be given a formal name (here, p) which is bound to the right of the arrow. The next argument \nhas the type cred p this is a type indexed by a value (p) and stands for a cre\u00addential authenticating \nthe principal p. The third parameter is given a re.ned type {f:.le | CanRead p f}, the type of all .les \nf for which the proposition CanRead p f is true, i.e., those .les that p is authorized to read. A security \npolicy in FINE is de.ned using assumptions that grant privileges to some principals but not others. For \nexam\u00adple, the assumption assume CanRead Alice (File /a.txt ) grants the read privilege on a speci.c \n.le to the principal Alice. A reference monitor that provides mediated .le access to an application is \ntype checked against the declared type of fread and the policy assump\u00adtions. When this code attempts \nto give a .le v:.le a re.ned type {f:.le | CanRead p f}, the FINE type checker veri.es (using an ex\u00adternal \nsolver) that the re.nement formula CanRead p v is deducible from the policy assumptions and from information \nabout v avail\u00adable from the program context. Thus, the type checker ensures that every call to fread \nis mediated by the appropriate security checks. Dere.ning FINE programs (\u00a73). The .rst phase of our com\u00adpilation \nchain is a source-to-source transformation called dere\u00ad.nement, in which values with re.ned types are \nassociated with proof terms witnessing the deducibility of re.nement formu\u00adlas. For example, after dere.nement, \nthe type of fread becomes p:prin . cred p . f:.le . proof (CanRead p f) . string. Our proof terms are \nin the style of LCF (Milner 1979), i.e., these are built using the constructors of an abstract data type \nproof t, where the constructors form a small trusted kernel that axiomatizes the infer\u00adence rules of \na .rst-order logic. Our compiler automatically con\u00adstructs these proof terms by inspecting a natural-deduction \nstyle proof trace emitted by Z3. Translating FINE to DCIL (\u00a74). DCIL is an object-oriented byte\u00adcode \nlanguage, designed to be a small extension to the type system of a side-effect-free fragment of CIL, \nwhere the additional type in\u00adformation used by DCIL is represented using the standard metadata facilities \nof .NET. The essence of DCIL lies in the way depen\u00addent function types are represented. Dependent functions \nin DCIL are instances of an abstract class DepArrow<a ::* , \u00df ::a . *>. This is a class with two parameters. \nThe .rst parameter, a , is a type parameter of kind * (the kind for normal types) and is represented \nusing standard CIL generics. The second parame\u00adter \u00df uses a DCIL-speci.c feature classes in DCIL can \nbe pa\u00adrameterized by type-level functions and we use these to capture the functional dependences characteristic \nof dependent types. In this case, the second parameter of DepArrow is a function that constructs a *-kinded \ntype from an a -typed value. Turning to our example, the dere.ned type of fread is translated (in part) \nto DepArrow<Prin, \\p:Prin.DepArrow<Cred<p>, ...>>. Here, Prin is a class standing for the translation \nof the prin type in FINE; \\p:Prin.DepArrow<Cred<p>, ...> is a type-level function from Prin-typed values \nto the DepArrow type. The Cred<p> type in the body of the function is a class parameterized by a value, \nanother feature of DCIL, which we use to represent source-level value\u00adindexed types like cred p. The \ntranslation of proof terms is no dif\u00adferent from the translation of other program expressions. But, by \nincluding proof terms in the translation, the DCIL type checker is able to verify programs without the \nassistance of an external solver.  The extended version of this paper. We include in an extended version \nof this paper (Swamy et al. 2009) complete formalizations of the static and dynamic semantics of DCIL, \nthe translation from FINE to DCIL, the dere.nement translation, and proofs of the the\u00adorems in this paper. \nOne important aspect of our full formalization is the special attention we pay to translating FINE s \nmodule system to DCIL, using CIL s access quali.er mechanisms. We prove that an information hiding property \nprovided by FINE is preserved in the translation to DCIL we make no further mention of this result in \nthis paper. We also include a detailed description of some additional featuresofthe LOOKOUT example inparticular,atreatmentofin\u00adformation \n.ow tracking in plugin code. The extended paper, a pre\u00adliminary release of our compiler, and several \nexample programs are available on the web at http://research.microsoft.com/fine.  2. FINE for mobile-code \nsecurity We begin by illustrating how FINE can be used to construct se\u00adcure reference monitors and mobile \ncode modules. We present fragments from LOOKOUT, a model, plugin-based of.ce utilities client. The reference \nmonitor for LOOKOUT mediates access to re\u00adsources such as emails in a user s inbox, and is con.gured \nby a user-provided security policy that de.nes various access privileges. Our type-preserving compiler \nprovides a number of bene.ts. First, by type checking the DCIL modules that represent LOOKOUT s reference \nmonitor, an end-user receives assurance that it properly enforces her policy. Additionally, a user can \ndownload third-party plugins (as DCIL assemblies) that extend the core functionality of LOOKOUT. These \nplugins can be veri.ed against the user s security policy before installation. Finally, LOOKOUT provides \nfacilities to allow plugins to de.ne policies to selectively share their data with other plugins the \ntypes provide assurance to plugin developers that a plugin s private data is properly protected. This \nsection also aims to provide an introduction to program\u00adming in FINE. For a gentler and more thorough \npresentation of FINE, we refer the reader to our prior work (Swamy et al. 2010). 2.1 A reference monitor \nfor LOOKOUT Security objectives. LOOKOUT provides constructs for a user to specify a stateful role-and \nhistory-based authorization policy. A user can organize her contacts into roles, granting privileges \nto some principals but not others. The stateful aspects allow a user to change role memberships dynamically. \nAdditionally, the refer\u00adence monitor also records events like the sending of emails. A user can de.ne \na history-based policy over these events to, for exam\u00adple, ensure that plugins never spam a user s contacts \nby responding to emails repeatedly. Our implementation augments the fragment shown here with a number \nof additional features, including selec\u00adtively sharing cookies between plugins using a plugin-provided \nac\u00adcess control policy, and information .ow tracking through plugin and reference monitor code. We discuss \nthese elements in \u00a75. Figure 1 shows a fragment of the API exposed by the LOOKOUT reference monitor to \nplugins. FINE uses a syntax based loosely on F# (Syme et al. 2007) we point out differences along the \nway. 1 module LookoutRM 2 type prin (* the type of principals *) 3 private type cred :: prin . * (* \ncred p is a credential authenticating p *) 4 private type email = {sender:prin; contents:string} 5 val \nmk email: prin . string . email 6 val sender: e:email .{p:prin | p=e.sender} 7 type evname = MsgIn:evname \n| MsgOut:evname | ... 8 type event :: evname . * . * = Event : e:evname . a . event e a 9 (* A vocabulary \nfor an authorization policy *) 10 type action = ReadEmail: email . action 11 | ReplyTo: email . action \n12 | SetCookie: prin . string . action 13 | ReadCookie: prin . string . action 14 type perm = Permit: \nprin . action . perm 15 type role = User:role | Friend:role | Plugin:role | ... 16 type att = Role: prin \n. role . att 17 | HasRepliedTo: prin . email . att 18 type st = list att 19 (* An af.nely typed revokable \nsignature of the program state *) 20 private type StateIs :: st . A = Sign : s:st . StateIs s 21 (* Propositions \nto de.ne authorization constraints *) 22 type In :: att . st . * (* list membership *) 23 type Derivable \n:: perm . st . * (* dynamically derived perms *) 24 (* Useful type abbreviations *) 25 type ok<p:prin, \na:action> = {s:st | Derivable (Permit p a) s} 26 type plus<s:st, a:att> = {x:st | In a x &#38;&#38; forall \n(b:att).In b s . In b x} 27 (* An API for plugins *) 28 val readEmail: p:prin . cred p . e:email . 29 \ns:ok<p, ReadEmail e> . 30 StateIs s . (string * StateIs s) 31 val replyTo: p:prin . cred p . e:email \n. s:ok<p, ReplyTo e> . 32 StateIs s . (s :plus<s,HasRepliedTo p e> * StateIs s ) 33 val setCookie: p:prin \n. cred p . name:string . value:string . 34 s:ok<p, SetCookie p name> . StateIs s . StateIs s 35 val getCookie: \np:prin . cred p . owner:prin . name:string . 36 s:ok<p, ReadCookie owner name> . StateIs s . 37 (option \nstring * StateIs s) Figure 1. A fragment of a reference monitor for LOOKOUT The types given to this API \nspecify authorization constraints; for example, looking ahead to the readEmail function on line 28, we \nsee an argument s:ok<p, ReadEmail e> which represents a constraint that the principal p have the ReadEmail \npermission on the email e. In Section 2.2, we show how a user can con.gure the behavior of this reference \nmonitor by specifying a policy to grant privileges to certain principals and not others. Section 2.2 \nalso shows code for a plugin. In the rest of this section, we proceed through Figure 1 sequentially, \ndescribing each element in detail. Line 2 shows the type of principals prin its representation is irrelevant \nto the example. We could, for example, use strings standing for user names, or public keys. Line 3 shows \na type constructor cred that we use to represent authentication credentials. The constructor cred is \ngiven the kind prin . * . (Kind ascriptions are written using double colons, while type ascriptions use \nsingle colons.) The kind of cred indicates that it constructs a type of kind *, from a value of type \nprin; in other words, cred is a dependent type constructor. As with principals, the concrete representation \nof credentials is irrelevant. However, to ensure that credentials cannot be forged, we tag the cred type \nwith the private quali.er ensuring that values of type cred p cannot be constructed directly by code \nnot trusted by the LookoutRM module. (In practice, rather than including prin and cred in the de.nition \nof LookoutRM, we use a library (trusted by LookoutRM) that implements various principal representations \nand authentication schemes.) Line 4 shows the type email. Our intention is to allow the user to de.ne \npolicies to protect access to the contents of an email. By declaring email private, FINE s module system \nensures that untrusted clients of LookoutRM cannot directly project .elds from the email record. However, \nunlike for the cred p type, we do not aim to ensure the authenticity of emails. So, at line 5 LookoutRM \nexposes a function mk email to allow clients to construct an email. At line 6, we provide an accessor \nto examine the sender .eld of an email without restriction access control will apply only to the contents \n.eld. The type of sender shows it to be a dependent function, where the formal parameter named e is in \nscope to the right of the arrow. The return type of sender uses a re.nement type to specify that the \nvalue p returned is in fact the sender .eld of the formal parameter e. In general, re.nement types in \nFINE have the form {x:t | f}, where x is the formal name of a value of type t , and x is bound in f, \na type that represents a .rst-order formula (with equality) (\u00a73).  Thedesignof LOOKOUT isbasedonamodelthatallowsplugins \nto subscribe to various events, e.g., email arrival, message compo\u00adsition, etc. Lines 7-8 show the type \nof event names evname and the type event n t, consisting of an event name n and some payload of type \nt generated when the event is triggered. In FINE, each con\u00adstructor of a variant can construct a different \ntype. Thus, unlike F#, the constructors of a variant are decorated with their complete type. At lines \n10-18 we de.ne various types that form a vocabulary for a security policy. Permissions (the type perm) \nare of the form Permit p a, which means that the principal p has the privilege to perform action a. Actions \n(type action) include reading from emails and replying to emails, as well as getting and setting cookies. \nCookies are identi.ed by a pair of the principal p that owns the cookie, and the cookie s key represented \nas a string. The type st shown at line 18 forms the basis of the state\u00adful authorization policy implemented \nby LOOKOUT. We re-use a model for stateful authorization which we have previously pro\u00adposed (Swamy et \nal. 2010), which in turn was based on a model by Dougherty et al. (2006). In this model, authorization \npolicies are speci.ed as inference rules that derive permissions from a set of basic authorization attributes, \nwhere the attributes can change over time. For example, the attributes may include assertions about a \nprincipal s role membership, and the policy may include infer\u00adence rules that grant permissions to principals \nin certain roles. The type att (lines 16-17) de.nes the attributes used in our scenario. The currently \nactive role memberships of a principal are of the form Role p r. The attribute HasRepliedTo p e is used \nto record a message-reply event. In practice, several other relations (e.g., event subscriptions) are \nmaintained in the state st of attributes. Line 20 uses af.ne types in FINE, a key feature that allows \nstate changes to be modeled. Types in FINE are classi.ed into two kinds: *, the kind of normal types, \nand A, the kind of af.ne types. Values with af.ne types may be used at most once. The notation StateIs \n:: st . A indicates that StateIs constructs an af.ne type from an st value. A value v:StateIs s is a \nsignature from the reference monitor attesting that s:st holds the current authorization attributes. \nNext, at lines 22-23, we show two propositions with which to state authorization constraints in types. \n(Unlike Coq (Bertot and Cast\u00b4 eran 2004) or Aura (Jia et al. 2008), FINE s kind system does not distinguish \ntypes and propositions.) The proposition In (line 22) is the standard list membership proposition, specialized \nto the st type. The proposition Derivable p s states that the permission p is derivable from the authorization \nattributes in s. Lines 25-26 show convenient abbreviations that use these propositions to de.ne re.ned \ntypes. The type ok<p,a> is a re.nement of st to those values in which p has the permission to perform \nthe action a. The type plus<s, a> is a st that extends s with the attribute a. Finally, we show a few \nfunctions exposed by LookoutRM to its clients. All the functions require the caller p to authenticate \nitself by passing in a credential cred p. To read an email e using the readEmail function, the caller \np must show that it holds the ReadEmail e privilege in the current authorization state s. The return \n 1 module UserPolicy 2 open LookoutRM 3 assume U1: forall (p:prin)(e:email)(s:st). 4 In (Role p Plugin) \ns &#38;&#38; In (Role e.sender Friend) s . 5 Derivable (Permit p (ReadEmail e)) s 6 assume U2: forall \n(p:prin)(e:email)(s:st). 7 In (Role p Plugin) s &#38;&#38; not (In (HasRepliedTo p e) s) . 8 Derivable \n(Permit p (ReplyTo e)) s 9 assume U3: forall (p:prin)(n:name)(s:st).In (Role p Plugin) s . 10 Derivable \n(Permit p (SetCookie p n)) s &#38;&#38; 11 Derivable (Permit p (ReadCookie p n)) s 12 (* A plugin module \n*) 13 module ApptMakerPlugin 14 open LookoutRM 15 val detectAppt: prin . string . option ({key:string; \nvalue:string}) 16 val me:prin 17 type pst<p:prin> =(s:{x:st | In (Role p Plugin) x}* StateIs s) 18 val \nhdlMsg: cred me . event MsgIn email . pst<me> . pst<me> 19 let hdlMsg c (Event e email)(s, tok)= 20 let \nc1 = contains s (Role (sender email) Friend) in 21 let c2 = contains s (HasRepliedTo me email) in 22 \nif c1 &#38;&#38; not c2 then 23 let (contents, tok)= read email me c email s tok in 24 match detectAppt \n(sender email) contents with 25 | None . (s, tok) (* no appointment extracted; do nothing *) 26 | Some \n{key=k; value=v}. 27 let tok = setCookie me c k v s tok in 28 replyTo me c email ( Con.rm appt:  v) \ns tok 29 else (s,tok) (* can t read email, or already sent noti.cation *) Figure 2. A user s policy and \nfragment of plugin code value of readEmail is a pair containing the contents of the email as a string, \nand a signature asserting that authorization state is unchanged. The type of replyTo is similar, except \nits return value is given a dependent pair type, (x:t * t ), where x names the value in the .rst component \nof the pair and is bound in the type t . The dependent pair in replyTo shows an updated state of the \nprogram s which extends s with an event HasRepliedTo p e, and a signature attesting that s is the new \nauthorization state. We use the af.nity of StateIs s to model state updates. Since the caller of replyTo \nhas used a v:StateIs s value by passing it as an argument to replyTo, the types ensure that the caller \ncan no longer use v to claim that the old state s is valid. The setCookie function allows a plugin with \nappropriate privilege to write a cookie. The getCookie function allows a plugin p to retrieve a cookie \nowned by another plugin owner only if p holds the appropriate privilege if a cookie by that name does \nnot exist, getCookie returns None, the empty constructor of the option type.  2.2 A LOOKOUT user s policy \nand a plugin Figure 2 shows a module UserPolicy that con.gures the behavior of the LookoutRM reference \nmonitor with several formulas that represent user-provided policy assumptions. The policy shown here \nis particularly simple we discuss the policy used with our real implementation in \u00a75. Assumption U1 allows \na plugin to only read emails from friends. U2 allows a plugin to reply to an email e only if a reply \nhas not already been sent. U3 allows plugins to set and get only the cookies it owns. The rest of Figure \n2 shows fragments from a plugin program. At a high-level, this plugin responds to incoming messages (MsgIn \nevents), scans the contents of these messages for text that appears to be an appointment, and maintains \na calendar of appointments for the user in the cookie store. The plugin also sends a response notifying \nthe message sender that an appointment has been created. The custom logic of the plugin is represented \nby the function detectAppt, whose implementation is not shown. The plugin de.nes a distinguished principal \nme (representing the plugin itself) at line 16. In hdlMsg at lines 20-21, we use the function contains: \ns:st. a:att.{b:bool | b=true . In a s} (a stan\u00addard tail-recursive list membership test implemented in \nFINE, but not shown here) to check if it has the privilege to read the email and reply. If the check \nsucceeds, hdlMsg reads the contents of the email. If it detects an appointment, it sets a cookie in the \nstore for the appointment and sends a reply con.rming the appointment.  2.3 Discussion In subsequent \nsections, we present a translation that compiles FINE programs in a proof-carrying style to DCIL. Before \nwe proceed to the formalism, we discuss several bene.ts (and limitations) in the design of LOOKOUT and \nof our compiler. Loosely coupled policy and code. LOOKOUT s design enables a good separation of security \npolicy from code. Users declare a policy using high-level logical rules; these rules are then connected \nto the code using types. For example, the ReadEmail privilege granted by U1 in Figure 2 also appears \nin the type of readEmail at line 28 of Figure 1. But, the conditions under which such privileges are \ngranted are declared only in the policy, not in the code different users may de.ne different conditions \nunder which the ReadEmail privilege is granted. In practice, rather than requiring a user to write down \nthe UserPolicy module directly, we expect that it can be generated from some high-level speci.cation \nor interface in which to declare security preferences. One limitation, however, is that although the \npolicy appeals to dynamically changing attributes, policy assumptions are required at compile time to \ntype check the program. In the future, we plan to explore designs in which the reference monitor is con.gured \nby a purely dynamic policy. Compiling to DCIL enables .NET interoperability. Rather than expecting plugin \nauthors to program entirely in FINE, our compiler generates code that can easily call, and be called \nfrom, other .NET languages. For example, in the ApptMakerPlugin of Figure 2, the detectAppt function \nwhich handles the plugin s custom logic, could be implemented in any .NET programming language. Our compiler \nproduces code that tries, where possible, to mimic F# s object representations, which makes it convenient \nto interoperate with F#, but we have also used C# and ASP.NET. However, interoperating with other .NET \nlanguages does re\u00adquire some care. For one, allowing C# programs to directly call a FINE function that \nexpects an argument with a value-indexed type (e.g., cred p) is unsound, since the standard .NET bytecode \nveri.er does not check that the argument actually has a type with the re\u00adquired index. Similar issues \narise with exposing af.ne types to the rest of .NET. To defend against this, we take care to ensure that \nthe values exposed to other .NET languages do not have FINE-speci.c types. However, our compiler does \nnot yet check this automatically. Calling other .NET languages from FINE also requires some care. The \nLOOKOUT application, as shown, only aims to enforce an authorization policy. When enhancing LOOKOUT with, \nsay, infor\u00admation .ow controls, one must be careful if calls to external func\u00adtions are permitted. For \nexample, an implementation of detectAppt in F# can easily leak the contents of an email, both via implicit \nor explicit .ows. Since proper enforcement of a noninterference\u00adlike property (Sabelfeld and Myers 2003) \nrequires tracking .ows throughout an application, if a policy includes information .ow constraints, then \nmost (if not all) of the application must be written in FINE and type checked for security. Ef.cient \nclient-side veri.cation. By compiling plugins to DCIL, clients can verify the security of plugins before \ninstallation. As our experimental results (\u00a75) show, although carrying explicit proofs in DCIL increases \ncode size signi.cantly, type-checking DCIL as\u00adsemblies is fast we view fast checking times as a key enabler \nfor mobile code veri.cation. As discussed in the Introduction, proof terms can also be useful at runtime \nin support of applications like values v ::= x | Dtv | .x:t.e | .a::..e expressions e ::= v | v1 v2 | \nvt | let x = e1in e2 | let (x, y)= e1in e2 | match v with Dtx . e1 else e2 types t, f ::= a | x:t1 . \nt2 | (x:t1 * t2) |.a::..t | T | t1 t2 | tv | !t |{x:t | f}kinds . ::= * | A | . . . | t . . signature \nS ::= T ::. | D:t | S, S. |\u00b7 . type env. G ::= a::. | x:t | v = v . | G, G. |\u00b7 Figure 3. Core syntax \nof FINE proof-carrying authorization. However, in the case of LOOKOUT, proof terms have little utility \nbeyond veri.cation. In support of such scenarios, we plan to implement an erasure pass for DCIL that \ncan erase computationally irrelevant proof terms after veri.cation.  3. Dere.ning FINE In this section, \nwe present a core syntax for FINE and describe (us\u00ading several examples) the key aspects of dere.nement, \nan initial source-to-source translation implemented by our compiler. Dere\u00ad.nement provides a way to associate \nexplicit proofs of re.nement formulas with the values that inhabit re.ned types. The main sub\u00adtlety in \ndere.nement is formulating it in a manner consistent with FINE s subtyping relation on re.nement types. \nWe also discuss the\u00adorems that establish that dere.nement is sound and complete. 3.1 Core syntax of FINE \nWe begin by presenting a core syntax for FINE, shown in Figure 3. We adopt an A-normal presentation (Flanagan \net al. 1993) of FINE. This helps to simplify the translation, and is convenient for giving names to expressions \nthat index types. FINE values v are variables, full applications of n-ary data constructors D, and value \nand type abstractions. The expression forms include application, type appli\u00adcation, two forms of let-bindings \n(the second is used to unpack de\u00adpendent pairs), and a pattern matching construct. The types t in\u00adclude \ntype variables, dependent functions, dependent pairs, quanti\u00ad.ed types, type constructors and their applications \nto types or val\u00adues, types with af.ne quali.ers !t, and re.nement types. Types are classi.ed according \nto their kind ., where * is the kind of unre\u00adstricted types, and A is the kind of af.ne types. An important \nas\u00adpect of FINE s kinding system is that dependent type constructors, types with kind t . ., are only \nwell-formed when the type t has kind * indexing types with af.ne values is prohibited. We have argued \n(Swamy et al. 2010) that that this restriction is key to discharging proofs obligations using off-the-shelf \nclassical provers, rather than requiring linear logic provers we .nd that this restric\u00adtion also simpli.es \nthe construction of proof terms. Programs are translated in the presence of a signature S that assigns \nkinds and types to all type and data constructors; and a typing environment G, which, in addition to \nvariable bindings, contains equality assump\u00ad . tions v = v . that record the results of pattern matching \ntests.  3.2 Representing re.nement formulas and proofs Formulas that appear in re.nements and in assumptions \nare rep\u00adresented using the type language we generally use the meta\u00advariable f for types that stand for \nformulas or proofs of formulas. The logical connectives in formulas are represented using type con\u00adstructors, \ne.g., And::* . * . *, Or::* . * . *, Not::* . *, and quanti.ed formulas are represented using the binding \nconstructs provided by dependent types. A universally quanti.ed formula .(x:t ).P x, is represented as \na dependent function x:t . Px, where P ::t . *; existential quanti.cation .(x:t ).P x is repre\u00adsented \nusing a dependent pair (x:t * Px).  barebox bare. t'. (x:t' S;G f t'S;G f t1 '1 :: .S;G f t1 '1 * f) \n:: . . t' :: . bb bare S;G,x:t' f f'S;G,x:t'f t2 '. t2':: .' S;G,x:t1',y:f f t2 '. t2':: .' . f' :: \n* 1 (D1) (D2) (D3) boxbarebare . x:t'. t'. x:t'. y:f . t' S;G f{x:t | f} 'S;G f x:t1 . t2 :: *' . (x:t' \n* proof f') :: . 'S;G f x:t1 . t2 :: * 12 12 Figure 4. Selected rules from the dere.nement of FINE types: \nS;G f t'. b t' :: K, where b ::= bare | box We use an LCF-style (Milner 1979) proof system. Values of \nan abstract datatype (ADT) proof::* . * represent proofs of formulas. The constructors of this ADT represent \ninference rules that axiomatize a classical .rst-order logic with equality. User\u00adprovided assumptions \nare treated as additional data constructors of the proof type we give an example in Section 3.4. We show \na few rules from the proof kernel below. T: proof True Destruct false: proof False . proof a And elim \n1: proof (And a\u00df ) . proof a I. elim 1: proof (I. a\u00df ) . proof (Imp a\u00df ) Modus ponens: proof a . proof \n(Imp a\u00df ) . proof \u00df Bind pf: proof a . (a . proof \u00df ) . proof \u00df The design of FINE s proof kernel is \nin.uenced by the features and limitations of the type system of our target language. In designing DCIL, \nwe aimed to produce a minimal extension of CIL, without re\u00adquiring any changes to existing CIL features. \nOne of the limitations of CIL is that parametric polymorphism is only permitted on types of kind * with \nno support for quanti.cation over types with higher kinds, e.g., * . *. This prevents us from using a \nhigher-order logic to represent proof terms in FINE. This restriction manifests itself primarily in our \ntreatment of equality. In addition to the core inference rules, we generate proof axioms for a .rst-order \ntreatment of equality for each type de.ned in the program. For example, for the att type de.ned in Figure \n1, we automatically generate a type Eq att corresponding to equality for att values, and substitution \naxioms relating Eq att to other propositions in the program. Some of these auto-generated types and axioms \nare shown below. type Eq bool:: bool . bool . * Re. bool: b:bool . proof (Eq boolbb) type Eq att:: att \n. att . * Re. att: a:att . proof (Eq attaa) Mono In 1: a:att. b:att. proof (Eq attab). s:st. proof (In \na s). proof (In b s) Finally, although not shown here, FINE has support for arbitrary recursion, so we \ndo not claim that our proof system is logically consistent. However, the soundness of FINE and DCIL s \nmodule systems guarantee that proof terms are constructed using only the data constructors from our proof \nsystem and the user-supplied axioms, and that if a proof term has a normal form, then that normal form \nhas the desired type. We view recovering logical consistency in the presence of recursion as an orthogonal \nissue, addressed either by tracking non-termination as an effect; by separating types from propositions \nand excluding recursion in the propositional fragment (as in Aura); or, by adopting a more permissive \napproach such as Operational Type Theory (Stump et al. 2008).  3.3 The dere.nement translation The dere.nement \ntranslation associates explicit proofs of formulas f[v/x] with values v given re.ned types {x:t | f}. \nThe standard approach to this problem is to translate re.nement types {x:t | f}to dependent pairs (x:t \n* proof f) for example, Coq (Bertot and Cast\u00b4 eran 2004) adopts exactly this strategy to represent re.nement \ntypes (sometimes called subset types, in Coq terminology). However, the standard approach faces a dif.culty \nin our context, because the FINE type system (unlike Coq s) comes equipped with a subtyping relation, \naccording to which {x:t | f} <: t . Since the representation of a (x:t * proof f) value clearly differs \nfrom the representation of a t value, a na\u00a8ive translation is incompatible with FINE s subtyping relation. \nAltering FINE s subtyping relation is not an option since it is key to the usability of FINE as a source \nprogramming language. Treating {x:t | f} as a subtype of t allows programmers to simply use re.nement \nformulas to state invariants of their objects, but to otherwise use these values normally, without needing \nto insert tedious operations to pack and unpack dependent pairs of values and their proofs. The novelty \nof dere.nement, then, lies in the way it selectively introduces dependent pairs in a manner that allows \nus to accommodate FINE s subtyping relation. Figure 4 shows a few key rules from our dere.nement judgment. \n'. t ' context with a signature S and environment G (wherein all types have already been dere.ned), a \nsource type t is dere.ned to t' of kind .. The superscript b is one of two constants: bare or box . In \nthe latter case, this indicates that the type t was translated to a dependent pair of the form (x:t ' \n* proof f) values of this type are boxed with a proof of the formula f. The rule (D1) shows a re.nement \ntype translated to a pair. The rule is simpli.ed by assuming that re.nement types are not nested. It \nis always possible to normalize types to this form, e.g., {x:{x:t | f1}| f2} can be normalized to {x:t \n| f1 . f2}. In (D2), we show the translation of a function type, where the argument type t1 is translated \nto the (unboxed) type t1'. The interesting case is the translation of functions that receive arguments \nwith re.ned types, shown in rule (D3). Here, the argument is .rst translated to a boxed type, but, in \nthe conclusion, we use a curried representation of a dependent pair. The effect of this formulation is \nthat re.nement types that appear in negative position are translated in a curried style, while those \nthat appear in positive position are translated to dependent pairs. This serves two purposes. First, \nin the body of a function with this type, the argument x can be used at the type t ' without needing \nany coercions. More importantly, the name x of type t ' is bound in the return type t2, where it may, \nfor example, index another type. Failing to curry the dependent pair would re\u00adquiring the coercing occurrences \nof x in t2 to project out the .rst component of the dependent pair. Since FINE and DCIL only sup\u00adport \nvalue indexed types, inserting such coercions at the type level is not feasible. The dere.nement of expressions \nhas a similar form: S; G; X f This judgment is written S;G f t b :: ., and reads that in a b ' e'. e: \nt , where the context X records the set of af.ne assump\u00adtions usable by e. We omit this judgment due \nto space constraints. Instead we illustrate its behavior on a (simpli.ed) fragment of the example program \nfrom \u00a72. The top of Figure 5 shows the dere.ne\u00adment of types in a context note the distinction between \nthe trans\u00adlation of re.nements in positive and negative contexts in the type of contains and readFoo \nrespectively. We use me, s, tok and p as free variables bound in the context throughout the rest of this \nsection. The source program on the left gives the boolean b a re.ned type. We type the then-branch of \nthe conditional with the assumption that . b = true. At the right we show the dere.ned program. Values \nthat are given boxed types, like b , are unboxed immediately to bind  1. let f = contains s in let b \n= f (Role me Plugin) in 1. let f = contains s in let b = f (Role me Plugin) in 1.1. let (b, pf1) = b \nin (*values packed with proofs are unpacked immediately *) 2. if b then let g = readFoo s in 2. if b \nthen let h = readFoo s in 2.1. let g = h (v:proof (Derivable p s)) in (*v uses pf1, and assumption b=true \n*) 3. g tok else tok 3. g tok else tok me:prin, s:st, tok:StateIs s, p:perm me:prin, s:st, tok:StateIs \ns, p:perm contains : s:st . a:att . {b:bool | b=true . In a s} contains : s:st . a:att . (b:bool * proof(I. \n(Eq Bool b true) (In a s)))) readFoo : s:{x:st | Derivable p x} . StateIs s . StateIs s readFoo : s:st. \nproof (Derivable p s) . StateIs s . StateIs s Figure 5. A source program (left) and its dere.ned version \nan auto-generated proof term v is shown with its type ascribed. both the underlying value and the proof \nin the context. The call to the function h:proof(Derivable p s) . StateIs s . StateIs s requires a proof \nterm as an argument. The auto-generated proof term is shown as the value v, shown enclosed in a box in \nthe .gure. To discharge proofs, our compiler constructs a .rst-order theory for Z3 by collecting user-provided \naxioms, variable bindings and match assumptions from the type environment G, e.g., bindings for normal \nvariable like b, proof terms like pf1, and, in the then\u00ad . branch of the conditional, the assumption \nb = true. We then assert the negation of the goal, (e.g, not (Derivable p s)) in this theory. When successful, \nZ3 determines that the theory is unsatis.able and produces a proof. We translate this proof into a FINE \nvalue of type proof(Derivable p s) using the constructors of our proof kernel.  3.4 Generating proof \nterms Consider typing the program of Figure 5 in the presence of the user-provided assumption: assume \nU: forall(s :st). In (Role me Plugin) s . Derivable p s . Note that p:perm is bound in the context. This \nassumption is translated to the data constructor U shown below. At the call to readFoo, we are required \nto construct a term with type proof(Derivable p s). We show such a term below (omitting type instantiations \nfor clarity): U: proof (s :st . proof (Imp (In (Role me Plugin) s ) (Derivable p s ))) Bind pf U .f:(s \n:st . proof (Imp (In (Role me Plugin) s ) (Derivable p s )))). Modus ponens (Modus ponens ((Re. bool \nb):proof(Eq bool b true)) (I. elim 1 pf1)) (fs) The proof proceeds by applying the monadic bind operator \non the assumption U; then applying the quanti.ed assumption in U to s, the state variable in question; \nand eliminating the impli\u00adcation proof (Imp (In (Role me Plugin) s)(Derivable p s)) using the Modus ponens \nrule. To obtain a proof of In (Role me Plugin) s, we make use of the proof term pf1 that is introduced \nin the context at line 1.1 on the right side of Figure 5. Recall that pf1 has type proof (I. (Eq bool \nb true)(In (Role me Plugin) s)). We convert this to an implication proof (Imp (Eq bool b true)(In (Role \nme Plugin) s)) by applying I. elim 1 to pf1. Finally, we eliminate this implication us\u00ading an application \nof Modus ponens, where we construct a proof of (Eq bool b true) using the term (Re. bool b):proof(Eq \nbool b true). Notice, however, that the type of Re. bool b is proof(Eq boolbb). To check the type ascription, \nwe rely on a match assumption in the . context, b = true, introduced in the then-branch of the if-statement \non line 2. Given this assumption, our type checker equates the type proof(Eq boolbb) with proof(Eq bool \nb true), as required by the context, and completing the proof. Note that the match assump\u00adtions that \ninduce type equivalences require special treatment in the translation to DCIL we discuss this in \u00a74.4. \nOur implementation uses Z3 to synthesize proof terms similar to (but often considerably larger than) \nthe one shown above. Our ap\u00adproach to translating Z3 proofs is syntax-directed most Z3 proof steps are \nprocessed locally and just once. The exceptions to this rule are proof steps that deal with equisatis.able \nformulas, using princi\u00adples such as skolemization. As with equality, a general treatment of these formulas \nrequires a use of higher-order logic. Nevertheless, for the few cases in our benchmarks that require \nequisatis.ability, we are able to provide a suitable .rst-order treatment to extract ty\u00adpeable proof \nterms. In the future, we plan to explore adding limited forms of higher-order quanti.cation to DCIL, \nwhile still being faith\u00adful to the restrictions imposed by CIL generics. We anticipate such a feature \nsimplifying the construction of proof terms signi.cantly. We conclude this section by presenting Theorem \n1 which estab\u00adlish the soundness and completeness of dere.nement. In the state\u00adment below, S;G f e : \nt and S;G f t :: . are the typing and kinding judgments for FINE (with re.nement types) as de.ned in \nour prior work (Swamy et al. 2010). Informally, our theorem states that for well-formed environments, \nany source term e well-typed at t, is translated (in a translated environment) to a term e ' well\u00adtyped \nat type t ' , where t ' is the translation of t . A similar result holds for the dere.nement of types. \nThe proof of the theorem pro\u00adceeds by mutual induction over the structure of the type-and term\u00addere.nement \njudgments. Theorem 1 (Dere.nement preserves types). For any well-formed context S; G; X, there exists \na context S ' ;G ' ; X that is the dere.ne\u00adment of S; G; X; such that, for any source expression e well-typed \nat type t , there exists an expression e ' and type t ' that is the dere\u00ad.nement of e and t , where e \n' can be given the type t ' . Similarly, for any type t1 well-kinded at kind ., there exists a type t1 \n' that is the dere.nement of t1, where t1 ' can be given the kind .. That is, .S, G, X, e, t. wf(S; G; \nX) . S; G; X f e : t . b '' '' .S ' , G ' ,e ,t ,b. S;G '. S ' ;G ' . S ' ;G ' ; X f e'. e : t . b ' \n'' S ' ;G ' f t'. t :: . ' . S ' ;G ' ; X f e : t .S, G, X, t1, .. wf(S; G; X) . S; G; X f t1 :: . . \n.S '' b ' , G ' ,t 1,b. S;G '. S ' ;G ' . S ' ;G ' f t'. t :: . . S ' ;G ' f t ' :: .  4. Translating \nFINE to DCIL This section presents DCIL, an extension of a functional fragment of CIL. We use CIL generics \nto translate many basic FINE con\u00adstructs (Kennedy and Syme 2004). DCIL extends CIL with af.ne types, \ntype-level functions, and classes parameterized by values. We discuss how to represent all our extensions \nin standards\u00adcompliant .NET assemblies. Code consumers can choose to use a type checker for DCIL for \nsecurity checking, but otherwise can run DCIL programs on stock .NET virtual machines. 4.1 Syntax Figure \n6 shows the syntax of DCIL. We re-use metavariables from FINE for syntactic categories in DCIL the context \nwill make the distinction clear. We write . for a .nite-length sequence of . items, and .n for an n-length \nsequence. Modules in FINE are translated to a combination of assemblies, modules, and inner classes in \nDCIL, where we use visibility quali.ers to model information-hiding in DCIL this is discussed in our \ntechnical report.  module abs. class data class constraints mod. td dd vc ::= ::= ::= ::= {td, dd in \ne}T (a::., x:t )::.{fd, md}D(a::., x:t ):T (t , v){vc, fd, md}x . = v .d. decl. fd ::= f :t meth. decl. \nvalue expr. type kind md v e t . ::= ::= ::= ||::= ::= t m(a::.)(x:t ){e}x | D(t, v) v | v.f | v.m(t)(v) \nx isinst D(t , v) then et else ef let x = e1 in e2 a | T (t, v) | !t | \\x:t1.t2 | t v * | A | t . . \nFigure 6. Syntax of DCIL DCIL distinguishes two types of classes. All (non-primitive) types in FINE are \ntranslated to abstract classes T . FINE values v:t are translated to instances of data classes D, where \nD extends T , the class corresponding to t. Classes can be parameterized by a list of type parameters \na::. and also by a list of value parameters x:t. Both kinds of classes include .eld and method declarations, \nalthough bodies of method declarations in T -classes are empty. Data classes include value constraints \nvc, which are analogous to FINE s pattern matching assumptions we discuss these shortly. Like FINE, the \nsyntax of expressions in DCIL is presented in A\u00adnormal form. Expressions include values v (variables \nor instances of data classes D), .eld projections, method calls, and a runtime type-test construct, (v \nisinst D(t, v) then et else ef ). Let-bindings are syntactic sugar for initialization of (immutable) \nlocal variables in CIL. Both let-bindings and type-tests are macro instructions in DCIL each corresponds \nto several CIL instructions. Types in\u00adclude type variables and fully instantiated abstract classes T \n(t, v). Af.nely quali.ed types are written !t, as in FINE. DCIL includes a restricted form of type-level \nfunctions (written \\x:t1.t2) to rep\u00adresent dependent types. Type-level function application is denoted \ntv. Kinds include * and A as in FINE, and t . ., the kind of type-level functions.  4.2 Overview of \nDCIL DCIL contains three main innovations. First, in addition to *-kinded type parameters, classes can \ninclude af.ne types, type-functions, and values as parameters. Importantly, DCIL does not include type \nparameters of kind * . . or A . ., a fundamental restriction of .NET generics which we aim to preserve. \nA violation of this prop\u00aderty likely requires sweeping changes to CIL, contrary to our aim of accommodating \naf.ne and dependent typing using only the existing metadata facilities provided by .NET. In our approach, \nvalue pa\u00adrameters are represented using standard .eld declarations and type functions are encoded using \ncustom attributes, but, ignoring these attributes still yields a valid .NET assembly. Our second main \ncontribution is a formalization of af.ne typ\u00ading for DCIL. The mixture of af.ne and dependent typing \nis sub\u00adtle and can require tracking af.ne assumptions in types as well as terms. Our formulation is streamlined \nby a crucial design element of DCIL the separation of classes that represent source-level types (abstract \nclasses T (t, v)) from data classes (D(t, v)). This separa\u00adtion makes sure that af.ne values never appear \nin types, much as in the source language, greatly simplifying the metatheory of DCIL. Af.ne types can \nbe represented in CIL using .NET type modi.ers these are opaque to the .NET runtime, and only need to \nbe inter\u00adpreted by a DCIL-aware bytecode veri.er. Finally, we retain separate compilation of DCIL classes \nby aug\u00admenting the declaration of data classes with value constraints. For an intuitive sense of why \nseparate compilation of DCIL classes poses a dif.culty, consider the following source program fragment: \nmatch b with true . .y:int. ((Re. bool b):proof (Eq bool b true)) When typing this program in FINE, we \ncan convert the type of Re. bool b from proof(Eq boolbb) to proof(Eq bool b true), since the sub-term \nRe. bool b appears in a context where b=true. How\u00adever, when translated to DCIL, the lambda-expression \nis closure converted, and then translated to some data class D with a sin\u00adgle value parameter b. To type \ncheck D, we need to ensure that it is only constructed in a context where its value parameter b can be \nproved equal to true. Value constraints in DCIL serve just this purpose they record constraints about \na class s value parameters so that the class can be checked independently of other classes; at every \nconstruction site of a class, we check that its value constraints are satis.ed.  4.3 Static semantics \nof DCIL Figure 7 shows several rules from the key judgments in the static semantics of DCIL. Derivations \nuse a context S that collect decla\u00adrations of both D-and T -classes; G, a local typing environment; and \nX a context containing usable af.ne assumptions. The (WF-dd) rule de.nes well-formedness of a data class \ndec\u00adlaration. We include it here primarily to point out the scoping rules for the type and value parameters \nof a class declaration. In the .rst premise, we check that the kind .i assigned to each type parame\u00adter \nai is well-formed. We permit functional dependences among the kinds: in the .rst premise of (WF-dd) we \ncheck each .i in a context extended with the pre.x of previous type parameters a1::.1,...,ai-1::.i-1. \nFor example, DepArrow(a1::*, a2::a1 . *) is a valid class declaration in DCIL, where the .rst type param\u00adeter \na1 appears in the kind of the second parameter. (DepArrow is used to represent dependent functions from \nFINE cf. \u00a74.4.) Simi\u00adlarly, we allow dependences among the value parameters xi:ti (the second premise \nof (WF-dd)). The remaining premises check that ' the super-class T (t ,v '), each of the value constraints, \n.eld decla\u00adrations, and method declarations are all well-formed. An important aspect of the last premise \nof (WF-dd) is that each method declara\u00adtion is checked with its own set of af.ne assumptions Xi (disjoint \nfrom others) drawn from the value parameters of the class. Note also that, in the last premise of (WF-dd), \nthe method dec\u00adlarations are checked with the class s value constraints vc in the context the key to \nenable separate type checking of DCIL classes. For this rule to be sound, we need to check that the constraints \nhold true at every construction site of the class. This check is handled by (T-New). In the .rst premise \nof (T-New), we lookup the constructed class s declaration in the signature S. In the second premise, \nwe check that the value constraints vc are valid for the actual argu\u00adments v used to construct the class. \nThe third premise of (T-New) checks the type arguments t against their expected kinds .. Since the scoping \nrules allow dependences among the type arguments, when checking the ith argument, we substitute the pre.x \nof argu\u00adments for the bound type variables in the expected kind .i we write [t/ai-1] for the substitution \n[t1/a1 ...ti-1/ai-1]. The last premise of (T-New) is similar, but must account for dependences among \nthe value parameters. The (y isinst D(t, x) then et else ef ) form is DCIL s equiva\u00adlent of FINE s match \nconstruct, where the data class D(t, x) plays the role of a pattern. This instruction is a macro that \nexpands to multiple CIL instructions, where in the then-branch we include pro\u00adjections of each of the \n.elds corresponding to the value parameters of y, the expression being scrutinized. DCIL provides no \nother way to project the value parameters of a data class. When checking this expression (T-Inst), we \nsplit the af.ne assumptions X, X ' between the value y being scrutinized and the branches. We check the \npat\u00adtern and the true-branch in a context G ' that includes bindings for  . S; G; X f e : t, S f. wf \n... where S ::= D:dd, S | T :td, S |\u00b7, G ::= x:t, G | a::., G | x = v, G |\u00b7 and X ::= \u00b7| x, X |\u00b7 .i.S,a::.i-1 \nf .i wf S; a::., x:ti-1 f ti :: . ' G= a::., x:t S; G; X f y : t1 G ' =G,x:t i '' ' S; G f T (t ,v ') \nwf .i.S; G f vci wf S; G ' ; x f D(t, x) : t unify(t1,t )= vc 11 . '' .i.S; G, vc f fdi wf x = X .i.S; \nG, vc; Xi f mdi wf S; G ' , vc,y = D(t, x); X f et : t S; G; X f ef : t (WF-dd) (T-Inst) ' S f D(a::., \nx:t) : T (t ' ,v '){vc, fd, md} wf S; G; X, X f y isinst D(t, x) then et else ef : t S(D)= D(a::., x:t \n'):t{vc,...} S; G f vc[v/x] S; G; X f v : T (t ' ,v ') S(T (t ' ,v '))= t2 m(a::.)(x:t1) ' .i.S; G f \nti :: .i[t/ai-1] .j.S; G,Xj f vj : t [t/a][v/xj-1] S;G f t :: . S; G; X ' f v ' : t1[t/a] j (T-New) \n(T-App) ' S; G; X1 ...Xm f D(t, v) : t[t/a][v/x] G; X, X f v.m(t)(v ' ): t2[t/a][v ' /x] S; G f t :: \n. Kinding of types S(T )= T (a::., x::t ' )::. ' .i.S; G f ti :: .i[t/ai-1]S; G f t1 :: * S; G f t :: \nt1 . . ' .j.S; G; \u00b7f vj : t [t/a][v/xj-1] S; G,x:t1 f t2 :: . S; G; \u00b7f v : t1 j (TK-Fun) (TK-App) (TK-T) \nS; G f\\x:t1.t2 :: t1 . . S; G f tv :: . S; G f T (t, v) :: . ' S; G f t ~' and S; G f v ~' Equivalence \nof types and values = t = v .i.S; G f t1,i = t2,i .j.S; G f v1,j = v2,j ~~. v1 = v2 . G (TE-Beta) (TE-Re.ne) \n(VE-Re.ne) ~~ S; G f (\\x:t.t ' ) v = t ' [v/x] S;G f T (t1,v1)~S; G f v1 = v2 = T (t2,v2) Figure 7. \nStatic semantics of DCIL (selected rules) the pattern-bound variables. As a result of y matching the \npattern, we can deduce a number of equalities. These equalities, vc, are computed (in the fourth premise) \nby unifying the type t1 of y with the type of the pattern t1' . For example, if t1 is Cred(Alice) and \nt ' 1 . is Cred(x), the value constraints vc include x = Alice. The true\u00adbranch, et, can use these equalities, \nin addition to an assumption . that y matches the pattern, i.e., y = D(t, x). Finally, we show (T-App), \nthe rule for method calls, which cap\u00adtures both type and term application in FINE. In the .rst premise, \nwe type the receiver object v. Note that v s type is always an ab\u00adstract class T , even though v is a \nconstructed using a data class D. The second premise looks up the method declaration; the third checks \nthe type argument; and the last premise checks the value argument. In the conclusion, as is standard \nwith dependent typing, we substitute the actual v ' for the formal x in the return type. In the kinding \njudgment, (TK-Fun) de.nes the well-formedness of type-level functions. The .rst premise ensures that \ntype-level functions can only receive non-af.ne values as arguments. This restriction, together with \nthe separation of data classes D from type classes T , ensures that we do not have to track usages of \naf.ne assumptions at the type level. Application of type-level functions is handled by (TK-App), where \nthe second premise shows the value v typed without any af.ne assumptions X. Finally, (TK-T) shows the \nkinding rule for abstract classes. As with (T-New), the dependences among the type and value parameters \nrequire that we apply pre.x substitutions to the expected kinds and types. Also, as in (TK-App), the \nlast premise of (TK-T) makes no use of af.ne assumptions. The bottom part of Figure 7 shows selected \nrules from DCIL s type equivalence judgment. The complete relation is the re.exive, symmetric, transitive \nclosure of the rules shown. The typing judg\u00adment is free to appeal to this relation to convert types \nof expres\u00adsions at any point in a derivation this makes our presentation of the typing judgment for DCIL \nnon-syntax-directed. To be syntax directed, our implementation relies on annotations inserted by the \nFINE type checker to determine where in a derivation type equiv\u00adalence is needed. The rule (TE-Beta) \nequates types related by \u00df\u00adreduction of type-level function applications. Type-level functions are essentially \ndrawn from the simply-typed lambda calculus and, as such, are strongly normalizing. Thus, despite allowing \ncomputa\u00adtion in types, DCIL type checking remains decidable. (TE-Re.ne) lifts the equivalence relation \ninto the type and value parameters of a class. Finally, (VE-Re.ne) equates value parameters v1 and v2 \n. when v1 = v2 is in the context. Theorem 2 below establishes that DCIL is sound. The dynamic semantics \nof DCIL is formulated (like FINE) to account for af.ne typing. The small-step reduction relation for \nDCIL is written S f (M, e) ' (M ' ,e ' ). Values with af.ne types are held in a mu\u00adtable store M, where \nreads and writes to the store are destruc\u00adtive. Following a methodology adopted in our prior work (Swamy \net al. 2010), Theorem 2, in addition to showing that well-typed pro\u00adgrams never get stuck, guarantees \nthat DCIL programs never de\u00adstruct af.ne values more than once. Theorem 2 (Soundness of DCIL). For all \nwell-formed signatures S; environments G; non-values e; and stores M typeable with S; G, the following \nstatements are true: 1) If S; G; dom(M) f e : t then there exists M ' ,e ' such that S f M, e ' M ' ,e \n' . '' '' 2) If S; G; X f e : t and S f M, e ' M ,e for some M ,e , and X . dom(M); then, there exists \nG ' ,X ' such that '' ' S; G ' ; X f e : t and M is typeable with S; G ' . Furthermore, for .X =(dom(M) \n. dom(M ' )) \\ (dom(M) n dom(M ' )) if dom(M ' ) . dom(M) then X ' = X . .X ; otherwise X ' = X \\ .X \n.  4.4 Translation of FINE to DCIL Thissectionillustratesourtranslationfrom FINE to DCIL usingsev\u00aderal \nexamples. The main subtleties arise in two parts of the trans\u00adlation. First, dependent functions are \ntranslated to instances of an abstract class DepArrow, overriding a single method App containing the \ntranslation of the function body. This idea is based on a scheme proposed by Kennedy and Syme (2004), \nwho translate a polymor\u00adphic (non-dependent) lambda calculus to an object-oriented lan\u00adguagelike CIL.Theprimarynoveltyofourtranslationliesintheex\u00adtension \nof this translation to capture the functional dependences in\u00adtroduced by dependent types in FINE. We \nfurther extend this mech\u00adanism to account for af.ne types. The second novelty of our trans\u00adlation relates \nto the computation of value constraints in data class declarations. These constraints are computed with \nthe assistance of the source-level type checker and, as mentioned previously, enable separate compilation \nof DCIL classes.  Translation of type constructors. Type constructors are translated to declarations \nof abstract classes T . The type and value parameters of a type constructor are carried over directly. \nFor example, the type of proofs, proof::* . * , is represented in DCIL as an abstract class with a single \ntype parameter: proof<a ::*>::* . Dependent type constructors like Eq att:: att . att . * are translated \nto abstract classes with value parameters: Eq att<x:att, y:att>::* . Translation of data constructors. \nData constructors in FINE are translated to declarations of data classes D that extend the abstract class \ncorresponding to the type constructed by D. For example, the And elim 1: proof<And a\u00df> . proof<a > data \nconstructor is translated to the class, And elim 1<a ::* , \u00df ::* , x:proof<And<a ,\u00df >>> : proof<a > The \nvalue parameter of And elim 1 corresponds to a .eld that holds a proof<And<a ,\u00df >> value, but notice \nthat this value parameter does not appear in the type proof<a > constructed by And elim 1. This is in \ncontrast to the data constructors of dependent types. For example, the re.exivity axiom Re. eq att: a:att \n. proof (Eq attaa) is translated to a data class Re. eq att<a:att>:proof<Eq att<a,a>>. The value parameter \nof Re. eq att corresponds both to a single .eld declaration in the body of the class and additionally \nappears as an index in the type proof<Eq att<a,a>> that it constructs. Translation of function types. \nDependent function types in FINE are translated to instances of the abstract class shown below: DepArrow(a1::*, \na2::a1 . *) :: *{ (a2 x) App(x:a1){} } Class DepArrow takes two type parameters: a1 for the argument \ntype and a2 for a type function the return type of App is the result of applying a2 to the argument x. \nSource-level types such as p:prin . cred p are translated to instances of DepArrow; in this case, PCredP:DepArrow(prin, \n\\x:prin.cred(x)). The App method of PCredP is of the form ((\\x:prin.cred(x)) p) App(p:prin) (by instan\u00adtiating \ntypes in the declaration of DepArrow). By the rule (TE-Beta) in the type equivalence relation, the return \ntype of this method is cred<p>, analogous to the type returned by the source-level func\u00adtion. Each function \ntype in FINE is translated to a distinct class (like PCredP) in DCIL and overrides the App method suitably. \nA closure conversion step collects the free variables of a function and adds these as additional type \nand value parameters to the class. We also include the abstract classes shown below to represent non-dependent \nfunctions, and functions that take af.ne arguments or produce af.ne results. Notice that the second type \nparameter of Arrow AA is not a type-function, since the type system ensures that af.ne values can never \nappear within types. Arrow(a1::*, a2::*) :: *{ (a2) App(x:a1){} } Arrow AA(a1::A,a2::A) :: *{ (a2) App(x:a1){} \n} DepArrow A(a1::*, a2::a1 . A) :: *{ (a2 x) App(x:a1){} } Translation of dependent pairs. Dependent \npairs are translated similarly to dependent functions. The abstract class DepPair A be\u00adlow corresponds \nto the type of a dependent pair where the sec\u00adond component is af.ne as with functions, we include variants \nof DepPair A for pairs of other kinds. DepPair A(a1::*, a2::a1 . A) :: A{} Classes that represent pairs \nare just data containers with no meth\u00adods at all. In contrast to functions, distinct dependent pair types \nin FINE can be translated to the same class in DCIL. We include data classes of the form shown below: \nDA(a1::*, a2::a1 . A,x:a1,y : a2 x) : DepPair(a1,a2) The data class DA can be instantiated appropriately \nto represent speci.c source values. For example, the source value (s, tok) of type (s:st * StateIs s) \nis translated to a new DA value using the constructor application DA(st, \\s:st.StateIs(s), s, tok) and \nis given the type DepPair A(st, \\s:st.StateIs(s)).Asmentionedbefore, DCIL provides no way to project \nvalue parameters the only way to de\u00adstruct a DepPair A class is by using the isinst construct. Using \nvalue constraints. To illustrate the use of value constraints, consider, once again, the source term: \nmatch b with true . .y:int. ((Re. bool b):proof(Eq bool b true)) The lambda expression is translated \nto a class D<b:bool>, a sub\u00adclass of Arrow<int, proof<Eq bool<b, true>>>, where closure conversion adds \nthe free variable b as a value parameter of D. The body of the lambda-term is translated to the body \nof the over\u00adriden App method of D, where, to give the sub-term Re. bool<b> the type proof<Eq bool<b,true>>, \nthe DCIL checker needs an as\u00ad . sumption b = true. The translation from FINE to DCIL records this assumption \n(provided by the match on b) as a value constraint in the declaration of D. The match statement is itself \ntranslated to an isinst statement in DCIL, and in its then-branch, where the D-class . is constructed, \nwe check that the constraint b = true holds.  4.5 Type-preserving translation Theorem 3 below states \nthat the translation preserves types I \u00b7I denotes the translation of environments, and the judgments \nthat use -stand for translation of types and terms. Theorem 3 (Type-preserving translation). Suppose, \nfor a well\u00adformed source environment S; G; X, and for a source expression esrc well-typed at type tsrc \n(i.e., S; G; X f esrc : tsrc) we have '' that esrc is dere.ned (for some b) to esrc at type tsrc (i.e., \nS; G; X f b '' esrc '. esrc : tsrc). Then, there exists a target expression etgt and class declarations \nS, such that esrc ' is translated to etgt and S (i.e., ISI; IGIf esrc ' -etgt;S); and there exists a \ntarget type ttgt such '' that type tsrc is translated to ttgt (i.e., ISI, S; IGIf tsrc -ttgt). Furthermore, \netgt is well-typed at type ttgt, i.e., ISI, S; IGIf etgt : ttgt.  5. Implementation This section describes \nthe implementation of our prototype com\u00adpiler and our experience using it on several small programs. \nOur compiler is implemented in approximately 20,000 lines of F# code, extending the parser and the binary \nwriting libraries of the F# compiler. Our application programs are, for the most part, refer\u00adence monitors \nsecurity-critical kernels of applications that are ex\u00adpected to be compact. These programs enforce many \nkinds of poli\u00adcies, including those based on security automata, information .ow controls, and role-and \nhistory-based authorization. Our measure\u00adments show that, currently, the cost of carrying proofs can \nincrease the size of binaries by more than an order of magnitude. However, despite their large size, \ntype checking DCIL assemblies is fast. We also report on an experiment with our largest benchmark, where, \nthrough the use of a custom solver, we were able to reduce code size by more than a factor of 25. In \nsummary, our results indicate that end-to-end veri.cation is possible for programs that use common security \npolicies, and, with improvements in certifying solvers, the overhead of carrying proofs can be made practical. \n 5.1 Application programs Figure 8 shows the results of our compiler on six example pro\u00adgrams. The columns \nfrom left to right are the name of the program; the number of lines of source code (LOC); the time (in \nseconds) for parsing and type checking source programs without extracting proofs (SC); the time to extract \nproofs and to dere.ne (DR); the time for translating to DCIL (Trans); the time to type check target programs \n(TC); the size in bytes of .NET assemblies that do not  Name LOC SC DR Trans TC NoPf Pf AuthAC 34 0.36 \n0.56 0.25 0.08 20K 30K Automaton 121 1.53 0.76 0.41 0.09 20K 40K iFlow 127 2.90 16.9 17.8 0.42 30K 840K \nHealthWeb 318 2.82 47.4 65.7 1.14 80K 2.1M Lookout 519 4.99 54.3 37.8 0.71 120K 1.8M ConfRM 647 10.1 \n68.5 81.2 1.47 110K 3.3M Total 1766 22.7 188.42 203.26 3.91 380K 8.3M ProofLib 9943 20.4 55.84 577.8 \n6.73 51.3M 51.3M Conf(Z3) 177 6.83 55.4 62.9 1.25 45K 2.4M Conf(SS) 177 6.83 37.8 0.39 0.11 45K 83K \nFigure 8. Compilation times and binary sizes on benchmarks include proof terms (NoPf); and the size of \nassemblies that do in\u00adclude proofs (Pf). Our experiments were performed on a 3.2 GHz Pentium Core Duo \nrunning Windows Vista. Standalone benchmarks. Our simplest benchmark is AuthAC, which implements a password-based \nauthentication mechanism combined with a group-based access control policy. Proving the correctness of \nAuthAC requires constructing a single proof term showing that a principal making a request for a resource \nis a mem\u00adber of the appropriate group. Automaton is more interesting it enforces a protocol on .le system \nresources speci.ed as a secu\u00adrity automaton. It uses re.nement formulas to reason about the equivalence \nof .le handle aliases, and combines this with af.ne and dependent typing to model the current state of \na .le. iFlow implements a canonical lattice-based information .ow policy, with dynamic security labels \n(Zheng and Myers 2004). Types in iFlow are re.ned using a proposition CanFlow l m, where l and m are \nse\u00adcurity labels. We use runtime tests of dynamic labels together with user-de.ned assumptions that de.nes \nthe label lattice in order to discharge proofs of the CanFlow proposition. HealthWeb is a reference monitor \nfor an application that manages a database of electronic medical records. It enforces a stateful au\u00adthorization \npolicy, where the authorization state records attributes like role activations, current relationships \nbetween doctors and pa\u00adtients, and patient consent directives. Patient records are classi.ed by subject \nwhich, together with the authorization state, controls the privilege to read, write, delete, annotate, \nor search for records. The reference monitor serves requests from a web-based front-end writ\u00adten in ASP.NET \nand C#, and provides a secure interface to a SQL Server database with an object-relational mapping implemented \nus\u00ading F#. As a server-side program, we anticipate that the proof terms produced for the veri.cation \nof HealthWeb could be logged at run\u00adtime to construct audit trails of authorization decisions; however, \nwe have yet to implement such an auditing facility. ConfRM is a reference monitor based on Continue, \na widely used conference management tool (Krishnamurthi 2003). This applica\u00adtion was previously implemented \nand described in detail in our prior work Swamy et al. (2010) and is currently our largest bench\u00admark. \nIt enforces a stateful authorization policy that is divided into 9 temporal phases and manages 12 different \nkinds of privileges. Lookout is a larger version of the example described in \u00a72. Two additional features \nof Lookout are of particular interest. First, in ad\u00addition to the stateful authorization policy shown \nin \u00a72, we provide facilities to track information .ows through plugin code. For ex\u00adample, rather than \nreturn a string, the readEmail function from Fig\u00adure 1 returns a value of the abstract type labeled string \n(Email e) the label Email e records the provenance of the string, namely, that it originated from the \nemail e. User policies can refer to these la\u00adbels to specify information .ow controls. For example, one \nof our example user policies prevents plugins from replying to an email with content derived from other, \nmore sensitive, emails. Second, we provide a way for plugins to selectively share in\u00adformation with each \nother via the cookie store. Rather simply asserting (using Permit p a) that a principal p holds the privi\u00adlege \nto perform an action a, our implementation uses a policy in which a privilege is granted by one principal \nto another, e.g, Permits p q a records a permission granted by p to q to perform the action a. We use \nthis decentralized model of permissions to build secure plugin mashups. When placing a cookie in the \nstore, a plugin can register an function closure that mediates ac\u00adcess to that cookie. When the reference \nmonitor returns a cookie to the principal p, we check that the returned value has the type {c:cookie \n| Derivable (Permits owner p (ReadCookie c.name)) s}), in\u00addicating that the cookie s owner authorizes \np to read the cookie. ProofLib is an auto-generated library of commonly used (veri.ed) lemmas that assist \nwith translation of Z3 proof terms. Z3 proofs often use rewriting steps that may, for example, rearrange \nthe order of clauses in a formula. Or, a proof may use a number of variants of a rule to eliminate double \nnegation. Rather than reconstruct proofs of these steps each time, proof terms simply use lemmas exported \nby the ProofLib module.  5.2 Compilation times and producing smaller proofs In general, our measurements \nshow that type checking DCIL pro\u00adgrams is fast. For example, typechecking the 51MB ProofLib takes less \nthan 7 seconds. However, the last two columns of Figure 8 show that the increase in code size due to \nproof terms can be quite substantial 21x on average, as much as 53x in some cases (Conf(Z3)). Clearly, \nthis is much larger than we would like. Large proofs contribute to the bulk of the total compilation \ntime for our application programs, both in dere.nement which must synthe\u00adsize these proofs, and in the \ntranslation from FINE to DCIL. When actively developing code, we often use a source-checking only mode \nfor quicker feedback (the SC column). This mode typechecks source programs and uses Z3 to decide re.nement \nformulas, but does not extract proofs. The overhead due to proofs can be much lower with appropri\u00adate \nsupport from an external solver. The last two rows of Figure 8 are Conf(Z3) and Conf(SS). These are identical \nprograms represent\u00ading the main event loop of ConfRM, where much of the veri.ca\u00adtion burden lies. The \nConf(Z3) row shows measurements for this program compiled with all proofs produced by Z3. The Conf(SS) \nline shows compilation results for this benchmark where all proofs were generated using a simple, uni.cation-based \n.rst-order solver that we wrote for this purpose. Our measurements show that our simple solver can produce \nproofs that are 25 times smaller than Z3 proofs. However, our simple solver is not nearly as full-featured \nas Z3 and can only produce proofs by repeated application of and\u00adintroduction and elimination, quanti.er \ninstantiation, and modus ponens. Getting all of Conf s proof obligations to fall into this frag\u00adment \nrequired some careful rewriting so, our simple solver is in no way a substitute for Z3. A closer examination \nof Z3 s proofs for Conf(Z3) suggests a few reasons why its proofs are so big. First, proofs contain a \nnumber of steps that pertain to manipulating the structure of quanti.ed formulas. A .rst-order solver \nthat used a more direct treatment of quanti.cation is likely to produce more compact proofs. Second, \nSMT solvers have for long been optimized for speed rather than proof size. For example, a number of proof \nsteps reported by Z3 involve rewriting formulas into speci.c normal forms since these are conducive to \nfaster proof search. However, each of these rewrite steps has to be translated in to a proof term. Finally, \nproofs occasionally contain truly redundant steps, e.g., proofs of formulas that have already been assumed. \nOur proof extraction modules attempt to detect and discard such steps. However, there remain several \nopportunities to post-process Z3 proofs to produce smaller proof terms we plan to investigate this in \nfuture work.   6. Related work This section discusses related work not already covered elsewhere in \nthis paper. Our approach of compiling FINE to DCIL is an in\u00adstance of proof-carrying code (PCC) (Necula \n1997) and typed as\u00adsembly language (TAL) (Morrisett et al. 1999). Traditionally, both TAL and PCC have \nbeen applied to prove the memory safety of assembly language programs, rather than for security veri.cation \nof bytecode. More recently, Yu and Islam (2006) have proposed a typed assembly language for con.dentiality \nand prove that it enforces a noninterference property. Also related is Barthe et al. (2007) type system \nfor noninterference for Java bytecode. Barthe et al. provide a formally certi.ed implementation of their \nbytecode veri.er by extracting an implementation from Coq. Their bytecode language also includes features \nlike exceptions, which are omitted from DCIL. However, both these systems focus solely on checking the \nenforcement of information .ow policies. In contrast, DCIL pro\u00advides general support for dependent and \naf.ne types at the bytecode level, rather than building in special support for information .ow policies. \nOur prior work Swamy et al. (2010) shows that both in\u00adformation .ow policies and policies like stateful \nauthorization can be enforced in FINE. Our type preservation result extends this re\u00adsult to DCIL. Additionally, \nboth Barthe et al. and Yu and Islam s systems only enforce information .ow policies with static security \nlabels. Dependent types in DCIL allow us to enforce information .ow policies with dynamic labels (Zheng \nand Myers 2004), and we put this to good use in our implementation of Lookout. Dependently typed object-oriented \nprogramming languages have been studied previously. For example, the X10 programming language (Nystrom \net al. 2008) and the HOOP calculus (Flana\u00adgan et al. 2006), use dependent types to state invariants on \nobject\u00adoriented programs. However, both of these are source languages, whereas DCIL is a bytecode language. \nX10 and HOOP also have imperative features; DCIL is functional, but uses af.ne types to model mutable \nstate. Re.nement typing in FINE is closely related to similar con\u00adstructs in F7 (Bengtson et al. 2008). \nOur work was designed, in part, to be directly applicable to F7, which like FINE, is also based on F#. \nIn the future, we plan to investigate using our tools to certify the compilation of F7 programs that \nhave been veri.ed to correctly im\u00adplement a number of cryptographic authentication protocols. Like F7, \nthe Sage language (Flanagan 2006) also uses a trusted exter\u00adnal solver to discharge proofs of re.nement \nformulas, but auto\u00admatically insert runtime checks when the prover fails to discharge a proof obligation. \nFailed runtime checks can cause subtle leaks of information, and so automatic insertion of runtime checks \nis not yet a feature of our compiler, where security is the primary concern. Concurrent with our work, \nB\u00a8 ohme (2009) has implemented a tool to verify Z3 proofs in Isabelle/HOL. As discussed in \u00a73.2, proof \nterms in FINE cannot make use of higher-order logic, due to constraints imposed by the type system of \nCIL. Relying only on .rst-order constructors for proofs complicates our proof extraction libraries, and \nalso requires a larger proof kernel to represent spe\u00adcialized axioms about equality at each type. 7. \nConclusions This paper has presented a type-preserving compiler that translates FINE, a source-level \nprogramming language for enforcing rich se\u00adcurity policies, to DCIL, a new extension of the bytecode \nlanguage for the .NET virtual machine. We have used our compiler to con\u00adstruct and verify the security-critical \nmodules of a number of ap\u00adplications. Although veri.cation for DCIL is already relatively fast, we anticipate \nfurther improvements to come as proofs produced by solvers become more compact. As such, our work makes \nit possible for developers to use a high-level language to program security\u00adcritical code, and for end-users \nto receive formal proofs that the code they rely on is secure. Acknowledgments. We thank Trishul Chilimbi, \nJeremy Condit, and several anonymous reviewers for their helpful comments on an earlier version of the \npaper; Shriram Krishnamurthi for providing us with Continue s policy; Nikolaj Bj\u00f8rner and Leonardo de \nMoura for help with Z3; and Karthik Bhargavan, Johannes Borgstroem, C\u00b4 edric Fournet, and Andy Gordon \nfor numerous discussions about this work.  References A. W. Appel and E. W. Felten. Proof-carrying authentication. \nIn CCS. ACM, 1999. K. Avijit, A. Datta, and R. Harper. Distributed programming with dis\u00adtributed authorization. \nIn TLDI. ACM, 2010. G. Barthe, D. Pichardie, and T. Rezk. A certi.ed lightweight non\u00adinterference Java \nbytecode veri.er. In ESOP. Springer, 2007. J. Bengtson, K. Bhargavan, C. Fournet, A. D. Gordon, and S. \nMaffeis. Re.nement types for secure implementations. In CSF. IEEE, 2008. Y. Bertot and P. Cast\u00b4Coq Art: \nInteractive Theorem Proving and eran. Program Development. Springer Verlag, 2004. S. B\u00a8ohme. Proof reconstruction \nfor Z3 in Isabelle/HOL. In SMT Workshop. Springer, 2009. L. de Moura and N. Bjorner. Z3: An ef.cient \nSMT solver. In TACAS. Springer, 2008. D. J. Dougherty, K. Fisler, and S. Krishnamurthi. Specifying and \nreasoning about dynamic access-control policies. In LNCS. Springer, 2006. ECMA. Standard ECMA-335: Common \nlanguage infrastructure, 2006. C. Flanagan. Hybrid type checking. In POPL. ACM, 2006. C. Flanagan, A. \nSabry, B. F. Duba, and M. Felleisen. The essence of compiling with continuations. In PLDI. ACM, 1993. \nC. Flanagan, S. N. Freund, and A. Tomb. Hybrid types, invariants, and re.nements for imperative objects. \nIn FOOL/WOOD 06, 2006. L. Jia, J. Vaughan, K. Mazurak, J. Zhao, L. Zarko, J. Schorr, and S. Zdancewic. \nAura: A programming language for authorization and audit. In ICFP. ACM, 2008. A. Kennedy and D. Syme. \nTransposing F to C#: Expressivity of polymor\u00adphism in an object-oriented language. Concurrency and Computation: \nPractice and Experience, 16(7), 2004. S. Krishnamurthi. The Continue server. In PADL. Springer, 2003. \nR. Milner. LCF: A way of doing proofs with a machine. In MFCS, 1979. G. Morrisett, D. Walker, K. Crary, \nand N. Glew. From System F to typed assembly language. ACM TOPLAS, 21(3), 1999. G. C. Necula. Proof-carrying \ncode. In POPL 97. ACM, 1997. N. Nystrom, V. Saraswat, J. Palsberg, and C. Grothoff. Constrained types \nfor object-oriented languages. In OOPSLA 08. ACM, 2008. A. Sabelfeld and A. C. Myers. Language-based \ninformation-.ow security. JSAC, 21(1):5 19, Jan. 2003. A. Stump, M. Deters, A. Petcher, T. Schiller, \nand T. Simpson. Veri.ed programming in Guru. In PLPV. ACM, 2008. N. Swamy, B. J. Corcoran, and M. Hicks. \nFable: A language for enforcing user-de.ned security policies. In S&#38;P. IEEE, 2008. N. Swamy, J. Chen, \nand R. Chugh. End-to-end veri.cation of security enforcement is .ne. Technical Report MSR-TR-2009-98, \nMSR, 2009. N. Swamy, J. Chen, and R. Chugh. Enforcing stateful authorization and information .ow policies \nin Fine. In ESOP. Springer, 2010. D. Syme, A. Granicz, and A. Cisternino. Expert F#. Apress, 2007. J. \nA. Vaughan, L. Jia, K. Mazurak, and S. Zdancewic. Evidence-based audit. In CSF. IEEE, 2008. D. Yu and \nN. Islam. A typed assembly language for con.dentiality. In ESOP. Springer, 2006. L. Zheng and A. C. Myers. \nDynamic security labels and noninterference. In FAST 04. Springer, 2004.   \n\t\t\t", "proc_id": "1806596", "abstract": "<p>A number of programming languages use rich type systems to verify security properties of code. Some of these languages are meant for source programming, but programs written in these languages are compiled without explicit security proofs, limiting their utility in settings where proofs are necessary, e.g., proof-carrying authorization. Others languages do include explicit proofs, but these are generally lambda calculi not intended for source programming, that must be further compiled to an executable form. A language suitable for source programming backed by a compiler that enables end-to-end verification is missing.</p> <p>In this paper, we present a type-preserving compiler that translates programs written in FINE, a source-level functional language with dependent refinements and affine types, to DCIL, a new extension of the .NET Common Intermediate Language. FINE is type checked using an external SMT solver to reduce the proof burden on source programmers. We extract explicit LCF-style proof terms from the solver and carry these proof terms in the compilation to DCIL, thereby removing the solver from the trusted computing base. Explicit proofs enable DCIL to be used in a number of important scenarios, including the verification of mobile code, proof-carrying authorization, and evidence-based auditing. We report on our experience using FINE to build reference monitors for several applications, ranging from a plugin-based email client to a conference management server.</p>", "authors": [{"name": "Juan Chen", "author_profile_id": "81100119052", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2184608", "email_address": "", "orcid_id": ""}, {"name": "Ravi Chugh", "author_profile_id": "81435596644", "affiliation": "University of California, San Diego, La Jolla, CA, USA", "person_id": "P2184609", "email_address": "", "orcid_id": ""}, {"name": "Nikhil Swamy", "author_profile_id": "81342513197", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2184610", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1806596.1806643", "year": "2010", "article_id": "1806643", "conference": "PLDI", "title": "Type-preserving compilation of end-to-end verification of security enforcement", "url": "http://dl.acm.org/citation.cfm?id=1806643"}