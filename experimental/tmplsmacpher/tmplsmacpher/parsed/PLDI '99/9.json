{"article_publication_date": "05-01-1999", "fulltext": "\n  2.3 GC-unsafe instructions There are certain instructions at which we cannot allow GC to occur, even \nthough we still have complete root set information. These instructions involve write barriers. In an \nefficient implementation of a generational or incremental garbage collector[7][9], the GC needs to be \nnotified whenever an object in an older generation points to an object in a younger generation. In our \nimplementation, we first store the pointer, and then pass the two objects to the write barrier routine. \nIf GC happens between the store and the write barrier call, the GC s state is likely to become corrupted \nsometime in the future, causing it to collect live objects. One possible solution is to generate a write \nbarrier both before and after the store, but of course at a cost of double the runtime overhead. There \nare several other ways to deal with this problem without imposing this additional overhead (but beyond \nthe scope of this paper), but all have one thing in common: the GC map must be able to identify such \nGC-unsafe instructions. An additional issue is the handling of interior pointers. At GC time, a register \nmight point not to the base of a live object, but to some location in the interior of the object. The \ncompiler could generate interior pointers for loop optimizations, or for spill code. These interior pointers \ncould be live across call sites and backward branches. The compiler must add information to the GC map \ndescribing the uses of interior pointers, and possibly how to recover the base pointer from the interior \npointer. Our GC implementation does not currently support interior pointers, so our compiler avoids generating \nsuch code. 2.4 Compression statistics To demonstrate the results of our compression, we use a collection \nof programs from the SPECjvm98[11] benchmark suite. We look at statistics gathered over the execution \nof each individual benchmark, as well as the weighted average over all of the individual benchmarks. \nIn addition, to factor out the effect of the system class libraries that all benchmarks share, we constructed \na test harness, called AllSpec , which simply executes each benchmark in sequence, within a single execution \nof the JVM. All benchmarks are compiled to native iA32 instructions. In our measurements for this paper, \nwe have used unmodified programs from SPECjvm98 with their full problem sizes. However, we did not fully \nfollow the official run rules defined by the SPEC committee, so no conclusions about performance should \nbe drawn from our experiments. The running times are presented in the Appendix. All experiments were \nperformed on a PC with two 450MHz Intel\u00ae Pentium\u00ae II XeonTM processors. The table below shows the overall \nresults of the compression for all of the tests. Code size and GC map size are reported in bytes. We \nevaluate the compression in terms of the ratio of the GC map size to the code size. As the table shows, \nour ratio is usually around 20-30%.  Index for basic blocks. Due to the nature of the encoding, decoding \nrequires processing the GC map sequentially from the beginning, instruction by instruction, until the \ntarget instruction is reached. Depending on how often the GC map is accessed, this processing can become \nquite expensive. One solution for speeding up access is to embed an index into the map, allowing direct \naccess to the start of any given basic block. The overhead for this index is shown as the top segment \nof the bar graph. (The table above reflects measurements without the use of the index.). An additional \nsolution for higher performance, which can be used either with or without the index, is to implement \na small cache that maps instruction addresses to root sets. This cache takes advantage of the tendency \nfor deeper stack frames to remain unchanged from one collection to the next. Our implementation allows \nus to experiment with all configurations, and we find that when a cache is used, the additional performance \nfrom using the index is usually negligible. . Instruction length (using disasm). The iA32 architecture \nhas instructions with widely varying lengths, depending on the instructions and addressing modes used. \nWe have to record the length of each instruction (or macro-instruction) in the GC map. Our statistics \nshow that 91-96% of the instructions are encoded as single instructions, rather than  macro-instructions. \nThus, since the native code is readily changes. As described below, we use Huffman encoding to available \nat run time, we can use a disassembler, or some other instruction decoder, to determine the actual instruction \nlengths. Therefore, for each instruction record in the GC map, we use one bit to indicate whether it \nis a single instruction (and then use the decoder to recover the actual instruction length), and if it \nis a macro-instruction, we then encode its actual length. Even with this compact encoding, the instruction \nlength field still consumes around 10% of the GC map. . Penalty for not using disasm. If we do not use \nthe disassembler trick described above, this portion, plus the Instruction length portion, are required \nfor decoding the instruction lengths. As the graph shows, the instruction length then becomes the largest \ncomponent of the GC map. This size also reflects Huffman encoding based on the statistic that over 90% \nof the instructions or macro\u00adinstructions are between l-7 bytes in length. . Instruction effect. Each \ninstruction can have an effect on the state of the registers, the state of the stack locations, and/or \nthe state of the stack pointer. When the live range of a reference pointed to by a register begins or \nends, the register state changes. Similarly, when the live range of a stack location containing a reference \nbegins or ends, the stack location state changes. When an argument is pushed or popped, or a method is \ncalled, or the stack frame is constructed/destroyed in the prolog/epilog, the stack pointer compress \nthis information. What kind of stack change. When an instruction changes the stack pointer, it is because \nof a push, pop, or call instruction, or from creating or destroying the stack frame in the prolog or \nepilog. The distribution of these occurrences is described in the discussion of Figure 4. . Which register(s) \nchanged. If an instruction starts or ends the live range of a physical register containing a reference, \nwe record the register or registers changed by the instruction. . Number of instruction records. For \neach basic block, we must record the number of macro-instruction records contained within that basic \nblock. (There are a few other pieces of information that must be recorded for each basic block, all of \nwhich happen to require slightly fewer bits than the number of instruction records.) To better illustrate \nthe GC map components, we provide a few examples, using iA32 assembly code: Assume which is a stack \nlocation, holds a reference, and that this instruction is the last use of the stack location. This instruction \naffects the register state, since now contains a reference (this instruction starts live range). In \naddition, the stack location s live range ends. There is no stack pointer can change, the state of a \nstack location can change, and the stack change in this instruction. pointer can change. At least one \nof the three must occur, but all three cannot occur in a single instruction. Figure 2 shows the Assume \n contains a non-reference. Its live range may end in this instruction, but we do not record it in the \nGC map because it is not a reference. In this case, only the stack pointer changes in this instruction, \nand we record it as a push of a non-reference. Assume [esp+8] holds a reference, and that this is its \nlast use. This instruction does not affect the register state. It does affect the stack pointer (push \nof a reference), and it affects a stack location because the live range of [esp+8] ends. This is the \nkind of code typically generated for a bytecode. Assume it is a  of a reference, and that it is the \nlast use of which holds the base pointer for the In this case, there is no effect on the stack pointer \nor the stack locations, but there is a change to the register state. In particular, the live range of \n begins and the live range of ends. This is one of the rare cases where more than one register s state \nchanges in a single instruction. The top two bars of the graph in Figure 1 show the overhead required \nto provide fast access to the GC map. This fast access comes at a price-increasing the GC map size by \nmay be unnecessary when we use the simple caching mechanism described above. Note that the table listing \nthe compressed GC map sizes reflects the GC maps without this additional overhead, so the numbers in \nthe table are the best numbers we can report. The largest single component of the GC map is the instruction \neffect. In any given iA32 instruction, the register liveness state frequency of each combination. Based \non these frequencies, we construct a Huffman encoding, rather than always using three bits per instruction. \nFigure 3 shows the distribution of register liveness changes. Over 95% of the time, an instruction affects \nthe live range of only a single register containing a reference. Interestingly, the majority of the single-register \nchanges involve the register, primarily because the calling conventions specify that when a method returns \na reference, it is returned in the register. Figure 4 shows the distribution of stack pointer changes. \nAbout 95% of the instructions that affect the stack pointer are evenly distributed between pushing a \nreference, pushing a non-reference, and a method call. (A method call simply indicates that the instruction \nhas the effect of resetting the stack pointer to its default location.) The other possibilities are a \npop instruction (generally found only in the epilog of a method), and an arbitrary stack pointer adjustment, \nsuch as setting up or destroying a stack frame in the prolog or epilog. We need to record the stack pointer \nchanges for two reasons. First, when stack locations contain live references, we identify the locations \nwith respect to an offset from a canonical stack pointer value, so we must be sure the stack pointer \nvalue is correct before reporting live stack locations. Second, when we unwind to the calling stack frame, \nwe must keep the stack pointer consistent with the JVM s stack unwinding conventions. 123   \n\t\t\t", "proc_id": "301618", "abstract": "A high-performance implementation of a Java Virtual Machine<sup>1</sup> requires a compiler to translate Java bytecodes into native instructions, as well as an advanced garbage collector (e.g., copying or generational). When the Java heap is exhausted and the garbage collector executes, the compiler must report to the garbage collector all live object references contained in physical registers and stack locations. Typical compilers only allow certain instructions (e.g., call instructions and backward branches) to be <i>GC-safe</i>; if GC happens at some other instruction, the compiler may need to advance execution to the next GC-safe point. Until now, no one has ever attempted to make <i>every</i> compiler-generated instruction GC-safe, due to the perception that recording this information would require too much space. This kind of support could improve the GC performance in multithreaded applications. We show how to use simple compression techniques to reduce the size of the GC map to about 20% of the generated code size, a result that is competitive with the best previously published results. In addition, we extend the work of Agesen, Detlefs, and Moss, regarding the so-called \"JSR Problem\" (the single exception to Java's type safety property), in a way that eliminates the need for extra runtime overhead in the generated code.", "authors": [{"name": "James M. Stichnoth", "author_profile_id": "81100435976", "affiliation": "Inktomi Corporation, 1900 S., Norfolk St., Suite 310, San Mateo, CA and Intel Corporation, 2200 Mission College Blvd, Santa Clara, CA", "person_id": "P133606", "email_address": "", "orcid_id": ""}, {"name": "Guei-Yuan Lueh", "author_profile_id": "81331498383", "affiliation": "Intel Corporation, 2200 Mission College Blvd, Santa Clara, CA", "person_id": "PP33032555", "email_address": "", "orcid_id": ""}, {"name": "Micha&#322; Cierniak", "author_profile_id": "81100326251", "affiliation": "Intel Corporation, 2200 Mission College Blvd, Santa Clara, CA", "person_id": "P196161", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/301618.301652", "year": "1999", "article_id": "301652", "conference": "PLDI", "title": "Support for garbage collection at every instruction in a Java compiler", "url": "http://dl.acm.org/citation.cfm?id=301652"}