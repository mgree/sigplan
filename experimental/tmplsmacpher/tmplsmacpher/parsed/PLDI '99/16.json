{"article_publication_date": "05-01-1999", "fulltext": "\n     be equal. Note that the top-level qualifier attached to the constructors of the l-types of \na and b can be distinct from each other. For example, although a must be a non-const we do not require \nthat b be non-const. On the other hand, we treat typedefs as macro\u00adexpansions, e.g., in c and d do not \nshare any qualifiers. One of the complications of analyzing real programs is that real programs use libraries, \nthe code for which is of\u00adten either unavailable or written in another language. For any undefined functions, \nwe make the most conservative as\u00adsumption possible: We treat any parameters not declared const as non-const. \nIn general library functions are anno\u00adtated with as many consts as possible, and so lack of const does \nmean can t-be-const. C contains many different ways to defeat the type sys\u00adtem, of which the most obvious \nis casting. For explicit casts we choose to lose any association between the value being cast and the \nresulting type. For implicit casts we retain as much information as possible. Another way to defeat the \ntype system is to use variable\u00adlength argument lists, or call a function with the wrong num\u00adber of arguments. \nBoth cases happen in practice; we simply ignore extra arguments. 4.3 Polymorphic Inference Recall that \nwe allow standard let-style polymorphism, in which polymorphic expressions are explicitly marked. Since \na C program is made up of a set of possibly mutually\u00adrecursive functions, we need to syntactically analyze \nthe pro\u00adgram to find the let blocks. The FDG exactly captures the implicit structure of func\u00adtion definitions. \nThere is an edge from f to g if g must be type checked before f, and the strongly-connected compo\u00adnents \nof the FDG are the sets of mutually-recursive func\u00adtions. To apply the polymorphic inference to a C program, \nwe first construct the FDG. Then we traverse the strongly\u00adconnected components of the FDG in reverse \ndepth-first or\u00adder (the traversal can be computed in time linear in the size of the graph [CLR90]). We \nanalyze each set of mutually recursive functions monomorphically and then we apply the rule for quantification. \nAfter we reach the root node of the FDG, we analyze any global variable definitions. More work is required \nafter type inference to measure the results. We want to know how many formal parameters can be polymorphic, \ni.e., either const or non-const. However, in general a C function may refer to global variables, so a \nC function s polymorphic type is not closed. The types of global variables are closed once we have an\u00adalyzed \nthe whole program. A straightforward post-analysis pass combines this information with the types inferred \ndur\u00ading the FDG traversal to compute the results.  We would prefer to use polymorphic recursion rather \nthan let-style polymorphism to avoid working with the FDG, but BANE [AFFS98], the toolkit used to conduct \nour exper\u00adiments, did not support polymorphic recursion when this work began. Because the qualifier lattice \nis finite and qual\u00adifiers do not change the type structure, the computation of polymorphic recursive \ntypes is decidable and in fact should be very efficient. We have recently learned that Jakob Rehof has \nwritten a polymorphic recursive type inference system for C++ [Reh99]. 4.4 Experiments We perform const \ninference using the rules for const out\u00adlined in Section 2.4: Table 1 lists the set of benchmarks we \nused to test our analysis. We purposely selected programs that show a significant effort to use const, \nrather than those that use it in only a few places. Several of these programs are actually collections \nof programs that share a common code base. We analyzed each set of programs at once. This occasionally \nrequired renaming certain functions that were defined in several files to be distinct. For each benchmark, \nwe measured the number of inter\u00adesting (see below) inferred by the monomorphic and the polymorphic version \nof our analysis. For any given type, there are three possible results that our analysis can infer: It \ncan decide that the  1. must be const, 2. must not be const, or 3. could be either.  If the analysis \ninferred that something not marked as const must in fact be const, this would indicate a type error. \nSince all of our benchmarks are correct C programs, all of the possible additional detected must be \nfrom (3). The total number of possible is the sum of (1) and (3). Note that the number of possible does \nnot depend on the source-level const annotations, since removing a const merely shifts the annotation \non a from (1) to (3).   \n\t\t\t", "proc_id": "301618", "abstract": "We describe a framework for adding type qualifiers to a language. Type qualifiers encode a simple but highly useful form of subtyping. Our framework extends standard type rules to model the flow of qualifiers through a program, where each qualifier or set of qualifiers comes with additional rules that capture its semantics. Our framework allows types to be polymorphic in the type qualifiers. We present a const-inference system for C as an example application of the framework. We show that for a set of real C programs, many more consts can be used than are actually present in the original code.", "authors": [{"name": "Jeffrey S. Foster", "author_profile_id": "81338488852", "affiliation": "EECS Department, University of California, Berkeley, Berkeley, CA", "person_id": "PP39068596", "email_address": "", "orcid_id": ""}, {"name": "Manuel F&#228;hndrich", "author_profile_id": "81100288438", "affiliation": "EECS Department, University of California, Berkeley, Berkeley, CA", "person_id": "P187043", "email_address": "", "orcid_id": ""}, {"name": "Alexander Aiken", "author_profile_id": "81100399954", "affiliation": "EECS Department, University of California, Berkeley, Berkeley, CA", "person_id": "P13911", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/301618.301665", "year": "1999", "article_id": "301665", "conference": "PLDI", "title": "A theory of type qualifiers", "url": "http://dl.acm.org/citation.cfm?id=301665"}