{"article_publication_date": "05-01-1999", "fulltext": "\n       their relative space requirements. In all but three cases, the points-to set sizes for the \ntwo portable algorithms Col\u00adlapse on Cast and Common Initial Sequence are within 18% of the sizes for \nthe non-portable Offsets algorithm. In their respective worst cases, Collapse on Cast has 2.6 times as \nmany points-to edges (less-177) and Common Initial Sequence has 35% more points-to edges than Off\u00adsets \n. On the other hand, for the portable algo\u00adrithms have 33% fewer points-to edges than the Offsets algorithm. \nThis is due to the Offsets algorithm introduc\u00ading nodes to represent offsets within structures that do \nnot correspond to real fields. Overall, then, we conclude that the penalty for portability in terms of \nspace is not too large. 6 Related Work The most closely related work involves algorithms that dis\u00adtinguish \nfields of structures and handle casting. This in\u00adcludes the work of Steensgaard [Ste96a], Ryder et al. \n[Ryd98], and Wilson and Lam [WL95]. Of these, only Steensgaard provides a portable algorithm; the others \nrely on platform\u00adspecific information. The Common Initial Sequence ap\u00adproach uses the same basic idea \nas Steensgaard s algorithm. However, Steensgaard s version differs from the Common Initial Sequence algorithm \nin that his algorithm not only distinguishes fields of structures and handles casting, but also keeps \nthe running time of the algorithm as close to linear as possible by using other approximations similar \nto those used in his original work on flow-insensitive pointer analysis [Ste96b]. (However, the approximations \nthat ensure fast running time can also lead to much less precise results than those provided by the Common \nInitial Sequence al\u00adgorithm.) The Offsets approach is similar to the one used by Ry\u00adder et al. in the \nalias-analysis algorithms that they imple\u00admented as part of their work on the modification side-effects \nproblem [SRLZ98]. Essentially, everything is encoded in a base-offset manner; casting that overlaps fields \ncauses more approximate information to be kept about aliases, while casting that matches up fields preserves \nalias accuracy. The Offsets approach is also similar to the approach used by Wilson and Lam in [WL95]; \nhowever, they maintain a stride for each object in addition to its offset. This is important when pointer \narithmetic is performed on a pointer to an array that is inside a structure. In that case, although the \npointer may be moved off of the end of the array, it cannot point to an arbitrary field of the enclosing \nstructure; since pointer arithmetic adds (or subtracts) a value equal to the size of an array element, \nthe pointer can only point to fields at offsets that are some multiple of that size away from the ends \nof the array. In addition, there have been algorithms that distinguish fields of structures, but do not \nhandle casting. This includes the work of Choi et al. [CBC93], Burke et al. [BCCH94], An\u00addersen [And94], \nEmami et al. [EGH94], and Tonella [Ton97]. We cannot categorize the work of Ruf [Ruf95]. While it appears \nthat fields of structures are distinguished, this aspect of the analysis is only mentioned briefly, and \nit is not possible to tell whether casting is handled.  \n\t\t\t", "proc_id": "301618", "abstract": "Type casting allows a program to access an object as if it had a type different from its declared type. This complicates the design of a pointer-analysis algorithm that treats structure fields as separate objects; therefore, some previous pointer-analysis algorithms \"collapse\" a structure into a single variable. The disadvantage of this approach is that it can lead to very imprecise points-to information. Other algorithms treat each field as a separate object based on its offset and size. While this approach leads to more precise results, the results are not portable because the memory layout of structures is implementation dependent.This paper first describes the complications introduced by type casting, then presents a tunable pointer-analysis framework for handling structures in the presence of casting. Different instances of this framework produce algorithms with different levels of precision, portability, and efficiency. Experimental results from running our implementations of four instances of this framework show that (i) it is important to distinguish fields of structures in pointer analysis, but (ii) making conservative approximations when casting is involved usually does not cost much in terms of time, space, or the precision of the results.", "authors": [{"name": "Suan Hsi Yong", "author_profile_id": "81100064789", "affiliation": "Computer Sciences Department, University of Wisconsin-Madison, 1210 West Dayton Street, Madison, WI", "person_id": "PP39081553", "email_address": "", "orcid_id": ""}, {"name": "Susan Horwitz", "author_profile_id": "81100357689", "affiliation": "Computer Sciences Department, University of Wisconsin-Madison, 1210 West Dayton Street, Madison, WI", "person_id": "PP39039239", "email_address": "", "orcid_id": ""}, {"name": "Thomas Reps", "author_profile_id": "81100117392", "affiliation": "Computer Sciences Department, University of Wisconsin-Madison, 1210 West Dayton Street, Madison, WI", "person_id": "PP40023877", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/301618.301647", "year": "1999", "article_id": "301647", "conference": "PLDI", "title": "Pointer analysis for programs with structures and casting", "url": "http://dl.acm.org/citation.cfm?id=301647"}