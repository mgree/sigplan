{"article_publication_date": "05-01-1999", "fulltext": "\n    Figure 5. Binary tree microbenchmark. 4.2 Tree Microbenchmark extra space in tree nodes to handle \ninsertion gracefully, and hence This microbencbmark measures the performance of ccmorph on a large binary \nsearch tree, which we call a transparent C-tree. We compare its performance against an in-core B-tree, \nalso colored to reduce cache conflicts, and against random and depth-first clus\u00adtered binary trees. The \nmicrobenchmark does not perform inser\u00adtions or deletions. The tree contained 2,097,151 keys and consumes \n40 MB of memory (forty times the L2 cache s size). Since the Ll cache block size is 16 bytes and its \ncapacity is 16K bytes, it provides practically no clustering or reuse, and hence its miss rate was very \nclose to one. We measured the average search time for a randomly selected element, while varying the \nnumber of repeated searches to 1 million. Figure 5 shows that both B-trees and transparent C-trees outperform \nrandomly clustered binary trees by up to a factor of 4-5, and depth-first clustered binary trees by up \nto a factor of 2.5-3. Moreover, transparent C-trees outperform B\u00adtrees by a factor of 1.5. The reason \nfor this is that B-trees reserve do not manage cache space as efficiently as transparent C-trees. However, \nwe expect B-trees to perform better than transparent C\u00adtrees when trees change due to insertions and \ndeletions.  4.3 Macrobenchmarks We also studied the impact of cache-conscious data placement on two \nreal-world applications. RADIANCE is a tool for modeling the distribution of visible radiation in an \nilluminated space [49]. Its input is a three-dimensional geometric model of the space. Using radiosity \nequations and ray tracing, it produces a map of spectral radiance values in a color image. RADIANCE s \nprimary data structure is an octree, which represents the scene to be modeled. This structure is highly \noptimized. The program uses implicit knowledge of the structure s layout to eliminate pointers, much \nlike an implicit heap, and it lays out this structure in depth-first order (consequently, it did not \nmake sense to use ccmalloc in  software and hardware prefetching forperimeter. The ccmalloc\u00adnew-block \nallocation policy requires 12% and 30% more memory than closest and first-fit allocation policies, for \ntreeadd and perime\u00adter respectively (primarily due to leaf nodes being allocated in new cache blocks). \nHealth s primary data structure is linked lists, to which elements are repeatedly added and removed. \nThe cache-conscious version periodically invoked ccmorph to reorganize the lists (no attempt was made \nto determine the optimal interval between invocations). Despite this overhead, significantly outperformed \nboth software and hardware prefetching. Not surprisingly, the ccmal\u00ad blocks to add new list elements, \noutperformed the other allocators, at a cost of 7% additional memory. Mst s primary data structure is \na hash table that uses chaining for collisions. It constructs this structure at program start-up and \nit does not change during program execution. As for health, the impact since the lists were short. However, \nwith short lists and no locality between lists, incorrect placement incurs a high penalty. prefetching \nschemes for all benchmarks, resulting in speedups of 28-138% over the base case, and 3-138% over prefetching. \nWith strategy alone produced speedups of 20-194% over prefetching. In with the other allocations schemes, \nwith low memory overhead (with the exception of perimeter). To confirm that this perfor\u00ad implementation, \nwe ran a control experiment where we replaced 4.5 Discussion Table 3 summarizes the trade-offs among \nthe cache-conscious data gram performance. In addition, the techniques in this paper focus on single \ndata structures. Real programs, of course, use multiple data structures, though often references to one \nstructure predomi\u00adnates. Our techniques can be applied to each structure in turn to improve its performance. \nFuture work will consider interactions among different structures. Our cache-conscious structure layout \ntechniques place contempo\u00adraneously accessed elements in the same cache block. While this will always \nimprove uniprocessor cache performance, for multi\u00adprocessor systems, it depends on whether the data items \nare accessed by same processor or by different processors. In the latter case, co-locating the data elements \ncould exacerbate false-sharing. 5. ANALYTIC FRAMEWORK Although the cache-conscious data placement techniques \ncan improve a structure s spatial and temporal locality, their descrip\u00adtion is ad hoc. The framework \npresented in this section addresses this difficulty by quantifying their performance advantage. The framework \npermits a priori estimation of the benefits of these tech\u00adniques. Its intended use is not to estimate \nthe cache performance of a data structure, but rather to compare the relative performance of a structure \nwith its cache-conscious counterpart. In addition, it pro- Table 3: Summary of cache-conscious data placement \ntechniques. 7    \n\t\t\t", "proc_id": "301618", "abstract": "Hardware trends have produced an increasing disparity between processor speeds and memory access times. While a variety of techniques for tolerating or reducing memory latency have been proposed, these are rarely successful for pointer-manipulating programs.This paper explores a complementary approach that attacks the source (poor reference locality) of the problem rather than its manifestation (memory latency). It demonstrates that careful data organization and layout provides an essential mechanism to improve the cache locality of pointer-manipulating programs and consequently, their performance. It explores two placement techniques---<i>clustering</i> and <i>coloring</i>---that improve cache performance by increasing a pointer structure's spatial and temporal locality, and by reducing cache-conflicts.To reduce the cost of applying these techniques, this paper discusses two strategies---<i>cache-conscious reorganization</i> and <i>cache-conscious allocation</i>---and describes two semi-automatic tools---ccmorph and ccmalloc---that use these strategies to produce cache-conscious pointer structure layouts. ccmorph is a transparent tree reorganizer that utilizes topology information to cluster and color the structure. ccmalloc is a cache-conscious heap allocator that attempts to co-locate contemporaneously accessed data elements in the same physical cache block. Our evaluations, with microbenchmarks, several small benchmarks, and a couple of large real-world applications, demonstrate that the cache-conscious structure layouts produced by ccmorph and ccmalloc offer large performance benefits---in most cases, significantly outperforming state-of-the-art prefetching.", "authors": [{"name": "Trishul M. Chilimbi", "author_profile_id": "81100578606", "affiliation": "Computer Sciences Department, University of Wisconsin, 1210 West Dayton St., Madison, WI", "person_id": "P285175", "email_address": "", "orcid_id": ""}, {"name": "Mark D. Hill", "author_profile_id": "81100455115", "affiliation": "Computer Sciences Department, University of Wisconsin, 1210 West Dayton St., Madison, WI", "person_id": "PP40027462", "email_address": "", "orcid_id": ""}, {"name": "James R. Larus", "author_profile_id": "81100277326", "affiliation": "Microsoft Research, One Microsoft Way, Redmond, WA", "person_id": "P132790", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/301618.301633", "year": "1999", "article_id": "301633", "conference": "PLDI", "title": "Cache-conscious structure layout", "url": "http://dl.acm.org/citation.cfm?id=301633"}