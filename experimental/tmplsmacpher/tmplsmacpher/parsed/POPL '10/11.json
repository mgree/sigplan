{"article_publication_date": "01-17-2010", "fulltext": "\n Low-Level Liquid Types Patrick Rondon Ming Kawaguchi Ranjit Jhala UCSD UCSD UCSD prondon@cs.ucsd.edu \nmwookawa@cs.ucsd.edu jhala@cs.ucsd.edu Abstract We present Low-Level Liquid Types, a re.nement type \nsystem for C based on Liquid Types. Low-Level Liquid Types combine re\u00ad.nement types with three key elements \nto automate veri.cation of critical safety properties of low-level programs: First, by associat\u00ading re.nement \ntypes with individual heap locations and precisely tracking the locations referenced by pointers, our \nsystem is able to reason about complex invariants of in-memory data structures and sophisticated uses \nof pointer arithmetic. Second, by adding con\u00adstructs which allow strong updates to the types of heap \nlocations, even in the presence of aliasing, our system is able to verify prop\u00aderties of in-memory data \nstructures in spite of temporary invariant violations. By using this strong update mechanism, our system \nis able to verify the correct initialization of newly-allocated regions of memory. Third, by using the \nabstract interpretation framework of Liquid Types, we are able to use re.nement type inference to automatically \nverify important safety properties without imposing an onerous annotation burden. We have implemented \nour approach in CSOLVE, a tool for Low-Level Liquid Type inference for C pro\u00adgrams. We demonstrate through \nseveral examples that CSOLVE is able to precisely infer complex invariants required to verify impor\u00adtant \nsafety properties, like the absence of array bounds violations and null-dereferences, with a minimal \nannotation overhead. Categories and Subject Descriptors F.3.1 [Logics and Meanings of Programs]: Specifying \nand Verifying and Reasoning about Pro\u00adgrams; D.2.4 [Software Engineering]: Software/Program Veri.ca\u00adtion \nGeneral Terms Languages, Reliability, Veri.cation Keywords Liquid Types, Type Inference, Dependent Types, \nC 1. Introduction Static veri.cation is a crucial last line of defense at the lowest lev\u00adels of the software \nstack, as at those levels we cannot fall back on dynamic mechanisms to protect against bugs, crashes, \nor mali\u00adcious attacks. Recent years have seen signi.cant progress on au\u00adtomatic static veri.cation tools \nfor systems software. These tools employ abstract interpretation [5, 18] or software model check\u00ad ing \n[3, 17, 7, 33] to infer path-sensitive invariants over program Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 10, January 17 23, 2010, Madrid, Spain. \nCopyright c &#38;#169; 2010 ACM 978-1-60558-479-9/10/01... $10.00. variables like status .ags and counters \nand thereby verify control\u00adsensitive safety properties. Unfortunately, these approaches have been proven \ninsuf.cient for verifying data-sensitive properties of values stored in lists, trees, etc., as this requires \nthe precise infer\u00adence of invariants of data values stored within unbounded collec\u00adtions of heap-allocated \ncells. In previous work we introduced Liquid Types [29], a re.nement type system for ML that marries \nthe ability of ML types to infer coarse invariants for polymorphic data structures (and higher-order \nfunctions) with the ability of predicate abstraction and SMT solvers to infer path-sensitive invariants \nof individual variables. We demon\u00adstrated that this symbiotic combination enables the highly auto\u00admated \nveri.cation of complex data-sensitive properties of high\u00adlevel, functional programs [20]. Unfortunately, \nthe very nature of low-level, imperative code, typically written in C, makes the trans\u00adlation of type-based \nmechanisms to the setting of systems software veri.cation extremely challenging. Lack of Types First, \ndue to the presence of casts and pointer arithmetic, low-level systems code is essentially untyped. C \ns type system is designed only to allow the compiler to determine the number of bytes that should be \nread or written by each instruction, and hence, unlike the type systems of higher-level languages, C \ns types provide no invariants about data values. Mutation Second, mutation makes the very notion of type \nre.ne\u00adment problematic. The key idea in re.nement types is to adorn the basic underlying types with re.nement \npredicates over program variables. For example, in an ML program, the re.nement type {. :int | x = .} \ndescribes an integer that is greater than the pro\u00adgram variable x. However, this type is meaningless \nif the value of x can change over time. Unbounded Collections Third, even if we could meaningfully track \nmutation, we cannot always uniquely identify the object be\u00ading mutated. In particular, the presence of \nunbounded collections means that we must represent many elements of a collection by a single type. This \nmakes it impossible to strongly update the type of an element in the collection, creating a major loss \nof precision in the presence of the temporary invariant violations common in low-level programs. We introduce \nLow-Level Liquid Types (LTLL), a static re.ne\u00adment type system for C that enables the precise veri.cation \nand inference of data-sensitive properties of low-level software. LTLL tackles the above challenges via \na three-tiered design. First, LTLL isfoundedonanewBasictypesystemthatclassi.es values and heaps. A value \nis either a datum of a given size , e.g., a 4\u00adbyte integer or a 1-byte character, or a reference corresponding \nto a pair of a heap location and an offset within the location. Intuitively, an offset corresponds to \na .eld (resp. cell) of the structure (resp. array) resident at the location. A heap is a map from locations \nto a sequence of offset-value bindings that de.ne the contents of the given location. By precisely tracking \narithmetic on offsets, Basic types provide coarse invariants about the basic shapes of data values. \n Second, each Basic type is re.ned with a predicate that captures precise properties of the values de.ned \nby the type. LTLL makes a clear separation between immutable state, which is tracked using a traditional \ntype environment, and mutable state, which is tracked in a .ow-sensitive heap. We ensure soundness by \nrestricting the re.nements to pure predicates that refer only to immutable values. Of course, in C all \nentities are mutable. We recover precision for stack-allocated variables by .rst carrying out an SSA \nrenaming, which creates different (immutable) versions for the variables at different program points. \nThird, we recover precision for heap-allocated locations by us\u00ading the Basic type information to strongly \nupdate the types of the heap s contents on writes through pointers. Since such strong up\u00addates are unsound \nwhen several physical heap locations are repre\u00adsented by a single type, LTLL distinguishes between abstract \nloca\u00adtions which summarize a collection of physical memory locations and concrete locations which describe \nexactly one physical mem\u00adory location. LTLL enables strong updates by enforcing the require\u00adment that \nall pointer reads and writes are to concrete locations, and by employing two mechanisms, inspired by \nversion control sys\u00adtems, to account for aliasing: unfold, which checks out a con\u00adcrete reference to \na particular location from the set described by an abstract location, and its dual, fold, which commits \nthe changes made to the particular location back into the abstract location af\u00adter ensuring that the \nparticular location satis.es the invariants of the abstract location. Together, the automatically-inserted \nfold and unfold annotations ensure that the invariants for an abstract loca\u00adtion soundly apply to all \nthe elements that correspond to that loca\u00adtion, while simultaneously allowing strong updates. This is \ncrucial, as strong updates are essential for both establishing and tolerating temporary violations of \nthe invariants that are ubiquitous in low\u00adlevel code. Finally, LTLL uses the abstract interpretation \nframework of Liq\u00aduid Types to permit automatic inference of the re.nements. The typing rules directly \ncorrespond to an algorithm that generates a system of subtyping constraints over templates containing \nvariables that stand for the unknown re.nements. These constraints reduce to a system of logical implication \nconstraints that are solved via pred\u00adicate abstraction in order to yield the re.nement types, and hence \nprecise invariants, for different program elements. To demonstrate the utility of LTLL, we have implemented \nit in CSOLVE, a prototype static veri.er for C. CSOLVE takes as input a C program and a set of logical \npredicates and returns as output the inferred dependent types of local variables and heap contents along \nwith a report of any type errors that occurred. Through a set of challenging case studies, we show how \nthe combination of types and predicate abstraction enables the precise, path-sensitive veri\u00ad.cation and \ninference of control-sensitive properties of individual variables and data-sensitive properties of aggregate \nstructures. 2. Overview We start with a high-level overview of Low-Level Liquid Types, and then, via \na sequence of examples, we illustrate how they enable the precise static veri.cation and inference of \nprogram invariants in the presence of challenging low-level programming constructs, in\u00adcluding pointer \narithmetic, memory allocation, temporary invariant violations, aliasing and data structures. Basic Types \nOur system is based on a new Basic type system for C where every program variable is either a basic data \nvalue of some size, e.g., a 4-byte integer denoted by int, or a reference comprising a location and an \nindex within the location denoted by ref(e, i), where e is the location and i the index within the location. \nAn index is either a natural number n, which is a singleton offset used to model pointers to speci.c \n.elds of a structure, or of the form n +m, which is a sequence of offsets {n + lm}8 used to model l=0 \npointers into an array of items of size m that starts at offset n. Thus, ref(e, 4) is a (possibly null) \npointer that refers to a location e at (.eld) offset 4, while ref(e, 0+4) is a (possibly null) pointer \nthat refers to a location within an array of 4-byte integers. Basic Heaps To ensure the soundness of \ntypes in the presence of mutation, our representation of program state is partitioned into an environment, \nwhich is a standard sequence of type bindings for immutable variables, and a heap, which is a mapping \nfrom locations e to a set of index-type pairs that describe the contents of the location, called a block. \nFor example, the heap e1 . 0:int, 4: int e2 . 0+1 :char has two locations. The .rst, e1, contains a structure \nwith two integer .elds (at offsets 0 and 4 respectively). The second, e2, contains an array of one-byte \ncharacters (denoted char). Re.nement Types and Heaps In our system, program invari\u00adants are captured \nvia re.nement types [25, 14, 4, 29] denoted by {. :t | e} where t is the Basic type being re.ned, . is \na special value variable that denotes the value being described, and e is the re.nement predicate, a \nBoolean-valued expression containing the value variable. Intuitively, the re.nement type describes the \nset of values c of the Basic type t such that the predicate e[c/.] evaluates to true. Thus, {. :int | \n0 = .} describes the set of non-negative integers, and {. :ref(e, 0) | . =0} describes the set of non-null \nreferences to a location e at offset 0.A re.nement heap is a heap where each location is mapped to a \nsequence of offset-re.nement\u00adtype pairs. For example, e1 . 0: {. :int | 0 = .} is a heap with a location \ne1 which contains a non-negative integer at offset 0. Liquid Types A logical quali.er is a Boolean-valued \nexpression over the program variables, the value variable ., and a placeholder variable *. We say that \na quali.er q matches the quali.er q' if replacing some subset of the free variables in q with * yields \nq'. For example, the quali.er . = x + y matches the quali.er . = * + *. We write Q* for the set of all \nquali.ers not containing * that match some quali.er in Q. In the rest of this section, let Qbe the set \n{0 = ., . = * + *, . = BS(.), BS(.)= BS(*), BE(.)= BS(.)+ *} The terms BS(\u00b7) and BE(\u00b7) are uninterpreted \nfunction applications denoting the start and end addresses of memory blocks; we will explain these shortly. \nA liquid type over Q (abbreviated to just liquid type) is a re.nement type where the re.nement predicates \nare conjunctions of quali.ers from Q*. Our system enables inference by requiring that the certain entities, \ne.g., loop-modi.ed variables, functions and blocks in aggregate structures, have liquid types. 2.1 Local \nInvariants We begin by showing how our system uses local re.nements for individual program variables \nto verify the safety of the pointer dereferences in the make string function shown in Figure 1. The function \ntakes an integer parameter n, allocates a new block of memory of size n, iterates over the block using \nstr to initialize it, and returns a reference, res, to the block. Basic Types First, we describe the \nBasic types computed for each variable. The function calls malloc to create a new heap location e1 and \nreturns a pointer to the location with offset 0. Thus, res gets the Basic type ref(e1 , 0). str is initialized \nwith res but is updated inside the loop with an increment of 1. Hence, it gets assigned the , 0+1 Basic \ntype ref(e1 ). The loop index i gets the Basic type int.  char *make_string(int n) { char *res; char \n*str; 1: if (n < 0) return NULL; 2: res = (char *)malloc(n*sizeof(char)); 3: str = res; 4: for(int i \n= 0; i < n; i++) { 5: *str++ = \\0 ; } 6: return res; } Figure 1. Example: make string typedef struct \n{ int len; char *str; } string; string *new_string(int n, char c){ string *s; char *str; 0: if (n < \n0) return NULL; 1: s = (string *)malloc(sizeof(string)); 2: s->len = n; 3: str = make_string(n); 4: \ns->str = str; 5: init_string(s,c); return s; } void init_string(string *s, char c){ for (int i = 0; \ni < s->len; i++) { s->str[i] = c; } } Figure 2. Example: new string typedef struct _slist { struct _slist \n*next; string *s; } slist; slist *new_strings(int n) { string *s; slist *sl, *t; 1: sl = NULL; 2: for \n(int i = 1; i < n; i++) { 3: s = (string *)malloc(sizeof(string)); 4: s->len = i; 5: s->str = make_string(i); \n6: t = (slist *)malloc(sizeof(slist)); 7: t->s=s 8: t->next = sl; 9: sl=t; } return sl; } Figure 3. Example: \nnew strings Pointer Allocation and Arithmetic To specify when it is safe to dereference a pointer, we \nre.ne the output type of malloc so that it contains information about the size of the allocated block. \nIn particular, in our system malloc returns a value of type {. : ref(e, 0) | BLen(., n)} where n is the \nsize argument passed to malloc and BLen is the following block length predicate: . BLen(., n)= BS(.)= \n. . BE(.)= . + n The re.nement states that the return value is equal to the start of the location it \npoints to (BS(.)), and that the end of the allocated region (BE(.)) is n bytes from the beginning. We \nadopt a logical model of memory where allocated blocks are considered to be in.nitely far apart. We re.ect \nthis in our type system by re.ning the output types of pointer arithmetic operations to stipulate that \nwhen a pointer x is incremented by a value i the result has re.nement . PAdd(., x, i)= . = x + i.BS(.)= \nBS(x).BE(.)= BE(x) which states that the result is an appropriately offset pointer into the same block. \nFinally, to specify the safety of pointer dereferences, we stipulate that whenever a pointer x is dereferenced \nfor reading or writing, it has the bounds-safe type {. : ref(e, 0+1) | BS(.) = . . .< BE(.)} Safety Veri.cation \nTo verify that the pointer dereference on line 5 is safe, we must verify that str has the bounds-safe \ntype; this will require determining that str = res + i. This is challenging for a type system, as both \nstr and i are mutated by the loop. Our system addresses this problem by using SSA renaming to compute \ndifferent types for the different versions of mutated variables. In the sequel, let xj be the SSA name \nof x at line j. Thus, from the malloc at line 2 our system deduces that res2 has type {. :ref(e 1 , 0) \n| BLen(., n)} (1) i.e., that res is a pointer to the start of a new location e 1 whose size is n bytes. \nThis same type is assigned to str3 . Next, our system uses the quali.ers Q and an SMT solver to infer \nthat at line 5i5 and str5 have the respective types {. :int | 0 = .< n} {. :ref(e 1 , 0+1) | PAdd(., \nres2 , i5 )} Notice that these types are loop invariants. They hold the .rst time around the loop as \ninitially i is 0 and str is equal to res. The types are inductive invariants, as each loop iteration \nincrements i and res. Thus, our system uses an SMT solver to combine the above facts with (1) and deduce \nthat at line 5 BS(str5 ) = str5 . str5 < BE(str5 ), i.e., that str5 has the bounds-safe type and hence \nthe pointer dereferences at line 5 of make string are safe. Function Types Finally, note that make string \nreturns the pointer res (i.e., res2 ) on line 6. Thus, using the type from (1) and the fact that the \nlocation e 1 was freshly generated via malloc , our system concludes that make string has the type: .e \n1 .(n :int)/emp . 1 1+1 {. :ref(e, 0) | BLen(., n)}/e . 0:char (2) That is, the function takes an integer \nn and an empty heap (i.e., does not touch any pre-existing heap cells) and returns a pointer to the start \nof a new char array of size n.  2.2 Heap-block Invariants Next, we show how our system uses re.nements \nto verify safety properties of blocks of data residing in the heap. Consider the new string function \nshown in Figure 2. This function takes a parameter, n, and produces a string structure encoding a string \nof length n. The string structure has two .elds: len, the length of the string, and str, a pointer to \nthe contents of the string. The programmer intends that the .elds obey the following two invariants: \n(I1) the len .eld is non-negative, and (I2) the str .eld points to a char array of size len. Note that \nthese invariants do not hold at all points during the lifetime of the structure; instead, the programmer \nestablishes them on lines 1-4, and then calls the procedure init string that .lls in the string with \nthe supplied character c. Next, we show how our system precisely tracks updates to the structure, tolerating \nthe early stages in which the invariant does not hold, in order to verify the safety of the pointer dereferences \nwithin init string. First, the malloc in line 1 creates a new location on the heap, e 2 , and gives s \nthe type ref(e 2 , 0), stating that it points into this location at offset 0. Initially, this location \ncontains an 8-byte block (the size of the string structure), and so at line 2 the heap is  e 2 . uninitialized \n8-byte block In line 2, we assign n to the len .eld of s, which creates a new binding in the heap for \ne 2 at the offset corresponding to the .eld len, namely 0, since len is the .rst element of the structure. \nThus, at line 3 the heap is e 2 .0:{. : int | . = n}, uninitialized 4-byte block Next, in line 3, the \ncall to make string creates a new location and assigns to str a pointer to the new location, with the \ntype shown in 2 (and 1). Thus, at line 4 the heap contains two locations e 1 .0+1 : char e 2 .0:{. : \nint | . = n}, uninitialized 4-byte block In line 4, the value of str is assigned to s->str, which creates \na binding at the corresponding offset in e 2 , namely 4, as the .rst .eld, len, was an int which is 4 \nbytes long. Thus, at line 5 the heap is e 1 .0+1 : char e 2 .0:{. : int | . = n}, 4:{. : ref(e 1 , 0) \n| . = str} Finally, at line 5 we have the call to init string. At the callsite, our system uses the quali.ers \nin Q, and the type of str to infer that the previously shown heap binding for e 2 is subsumed by e 2 \n.0:{. : int | . = n}, 4:{. : ref(e 1 , 0) | BLen(., n)} As the value at offset 0 equals n, the above \nblock is subsumed by e 2 .0:{. : int | . = n}, 4:{. : ref(e 1 , 0) | BLen(., @0)} where n is replaced \nby @0, a name that denotes the value within the same block at offset 0. Finally, our system uses the \ntest at line 0 to deduce that n is non-negative at the callsite, so init string is called with the heap \nh de.ned as h = .e 2 . 0:{. : int | 0 = .}, 4:{. : ref(e 1 , 0) | BLen(., @0)}, e 1 . 0+1 :char Note \nthat, as the len .eld of a string structure is located at off\u00adset 0 and its str .eld is located at offset \n4, the bindings for e 2 capture exactly the structure invariants I1, I2 intended by the pro\u00adgrammer. \nMoreover, even though the invariants don t hold every\u00adwhere, our system is able to use strong updates \nto establish them at function call boundaries. Thus, our system infers that the function init string \nhas the type 12 2 .e ,e .(s : ref(e, 0))/h . void/h and, via reasoning analogous to that for make string, \nour system veri.es the safety of array accesses in init string.  2.3 Data Structure Invariants In new \nstring, s pointed to exactly one heap location, e 1 , throughout the execution of the function. Thus, \nwe could soundly perform strong updates to the block describing the contents of e 1 ; this allowed us \nto determine that the strings built by new string satis.ed the desired invariants. Unfortunately, we \ncannot soundly use strong updates when dealing with collections of locations. Consider the function new \nstrings shown in Figure 3. This function takes an integer parameter, n, and creates a list of strings \nof lengths from 1 to n, all of which satisfy the invariants I1, I2. This is accomplished by looping from \n1 to n, allocating memory for a new string and assigning the pointer to this memory to s (line 3), initializing \nit as in new string (lines 4,5), and inserting s into a list of strings (lines 6,7,8). Note that s points \nto many different concrete locations over the course of executing the function; this is in contrast to \nthe previous functions, in which pointers only pointed to a single concrete loca\u00adtion while the function \nwas executed. We formalize this distinction by saying that s points to an abstract location e . That \nis, in our sys\u00adtem, s has the Basic type ref(e, 0), which states that it refers to the offset 0 within \n(one of) many possible locations. Observe that it is not sound to perform strong updates to an abstract \nlocation s type. To see why, suppose that we had strongly updated e as we did when analyzing new string. \nThen we would assign e a block type as follows: e . 0:{. : int | . = i},... There are two problems with \nthis type. First, every string has a different length, and yet we only assign a single length for all \nstrings. Second, at the end of the function, i has the value n, while none of the strings in the list \nhas length n! Thus, while we need strong updates to establish the desired invariants for each string, \nwe clearly cannot soundly perform strong updates on the types of abstract locations. We solve this problem \nwith the following crucial observation. Suppose that the code uses a pointer s to access a collection \nof locations e . As long as we do not modify s or use other pointers to e , only one particular concrete \nlocation from the set represented by e can be modi.ed at a time. Thus, when a pointer to e is .rst used, \nwe can unfold the abstract location into a fresh concrete location, ej , which inherits e s invariant. \nAs long as e is only accessed by a pointer to ej , we can soundly perform strong updates on ej s type. \nHowever, as soon as another pointer to e is used, the possibility of aliasing means we can no longer \nrely on ej s type to be accurate. Thus, before we access an abstract location via another pointer of \ntype e , we fold the concrete location ej back into the collection by verifying that ej satis.es e s \ninvariants and removing it from the heap. The other pointer then gets its own unfolded copy of the location, \nand can strongly update it, until it gets folded back into the collection, and so on. Our system automatically \nplaces folds and unfolds in the code in a manner that ensures that: (1) every heap access occurs via \na reference to a concrete location, (2) every abstract location has at most one corresponding concrete \nlocation in the heap at any point in time. In this way, our system can soundly establish invariants about \nunbounded data structures in spite of temporary invariant violation even in the presence of aliasing. \nWe now illustrate the above mechanism using the code in Fig\u00adure 3. We will say that, within the body \nof the loop, s points to some concrete location, ej , which is an instance of e . We will use strong \nupdates, as in the previous examples, to verify that ej has the desired invariants, i.e., that ej . 0:{. \n: int | 0 = .}, 4:{. : ref(e2, 0) | BLen(., @0)}. Finally, at the end of the loop i.e., before we access \nanother pointer into e in the next iteration we fold the concrete location ej into the collection by \nensuring that it satis.es e s invariants, i.e., by stipulating that at the end of of the loop, the block \nej is a subtype of the block e . In this manner, our system performs strong updates locally and infers \nusing Q that at the end of the new strings, the heap is of the form e .0:ref(e, 0), 4: ref(e 1 , 0) e2 \ne1 .0:{. : int | 0 = .}, 4:{. : ref( , 0) | BLen(., @0)} e2 .0+1 :char  a ::= Pure Expressions |(w)n \ninteger constant | ref(r, n) reference constant | x variable | @i block offset | a1 + a2 integer arithmetic \n| a1 +p a2 pointer arithmetic | a1 ~ a2 pointer comparison | assert(a) assertion | F (a...) unint. application \ne ::= Expressions | a pure expression | if a then e1 else e2 if-then-else | let x = e1 in e2 binding \n| letu x =[unfold e] a in e location unfold | [fold e] location fold |*a pointer read |*a1 := a2 pointer \nwrite | malloc(e, a) allocation | [e...] f(a...) function call f ::= Functions | fun(x...){e} : S de.nition \n p ::= Programs | letf f = f in p function binding | f() main call Figure 4. NanoC syntax Thus, our \nsystem infers that the function returns a list (e ) of pointers to string structures (e 1) each of which \nsatisfy invariants I1 and I2. Plan This concludes a high-level overview of LTLL. Next we formalize our \ncore language (Section 3) and static type system and state the type soundness theorem (Section 4). Next, \nwe describe our experimental evaluation via a set of challenging case studies (Section 5), We then survey \nthe diverse lines of research to which LTLL is related (Section 6) before concluding (Section 7). 3. \nLanguage In this section, we present the syntax and types of NanoC, a simple C-like language with integers \nand pointers. 3.1 Syntax The syntax of NanoC is shown in Figure 4. We give an overview of the language \ns features below. Pure Expressions We distinguish the pure expressions of NanoC, which do not access \nthe heap, from its potentially impure expres\u00adsions. The pure expressions of NanoC, denoted by a, include \nin\u00adteger constants, variables, integer and pointer arithmetic, integer and pointer comparisons, and assertions, \nwhich allow the static checking of arbitrary predicates. NanoC uses the C convention that nonzero values \nrepresent truth and all other values represent falsehood. Thus, the generic arithmetic operator, denoted \nby +, in\u00adcludes comparisons and boolean operations. Uninterpreted appli\u00adcations and block offsets do \nnot appear in programs; they are used solely in the re.nements discussed in Section 3.2. Similarly, refer\u00ad \nence constants pointing to run-time heap locations r do not appear in source programs, but are the result \nof evaluating reference-typed expressions. Note that pure expressions are guaranteed to evaluate to a \nvalue. e ::= Locations  | e abstract location | ej concrete location i ::= Indices | n singleton | n \n+m lower-bounded sequence t ::= Basic Types |(n)i integer | ref(e, i) reference T ::= Re.ned Types |{. \n:t | a} re.ned Basic type b ::= Blocks | i : T ... block h ::= Heaps | emp empty heap | h * e . b location \nbinding S ::= Function Schemas | (x : T ...)/h . T/h function type |.e.S location quanti.cation Figure \n5. NanoC types Expressions The impure expressions of NanoC, denoted by e, include the pure expressions, \nas well as if-then-else expressions, let bindings, reads from and writes to memory, memory allocation, \nlocation folding and unfolding, and function calls. Note that all bindings are to immutable variables \n all mutation is factored into the heap. Next, we examine location unfolding and function calls in more \ndetail. Location Fold and Unfold Our goal is to verify invariants which hold on in-memory data structures. \nThese invariants are represented as types attached to abstract heap locations, each of which may rep\u00adresent \nseveral concrete (actual, run-time) heap locations. Verifying properties of the data at these abstract \nlocations in the presence of temporary invariant violation would seem to require performing strong updates \non the types of abstract locations. Unfortunately, this would be unsound, since a single abstract location \ncan repre\u00adsent several concrete locations. However, at run-time a reference will only point to a single \nconcrete location at a time. Thus, operations on abstract locations through a single reference will only \naffect a single concrete loca\u00adtion. Intuitively, if we can get access to this concrete location, we can \nsoundly perform strong updates on it. Our intuition follows a version control metaphor. Before using \na pointer, we can check out a copy of its abstract location, giving a concrete location for the pointer \nwhich has the same type as the ab\u00adstract location a working copy . As long as the abstract location \nis accessed only through this pointer to the working copy, it will be sound to perform strong updates \non the type of the new concrete location. Finally, if it becomes necessary to use another pointer to \nthe same abstract location, we check in the concrete location by checking that it satis.es the same invariant \nas the corresponding abstract location. The concrete location is then discarded so that no further modi.cation \ncan be made to the working copy. The check out operation is implemented via the letu x = [unfold e] a \nin e construct, where a is a reference to abstract location e . The expression creates a new concrete \nlocation corre\u00adsponding to e ; a reference to this new location is bound to x in e. The check in operation \nis implemented via the [fold e] expres\u00adsion, which veri.es that the concrete location corresponding to \ne satis.es the same invariant as e . These procedures and the distinc\u00adtion between abstract and concrete \nlocations are discussed in more detail in the context of their static typing rules in Section 4.1.  \nFunction Calls Since functions take reference parameters, they can operate on arbitrary memory locations. \nThus, we allow function types to be quanti.ed over the locations they operate on and aug\u00adment the function \ncall expression with syntax for instantiating the quanti.ed locations: the expression [e...] f (x...) \ncalls function f with parameters x..., instantiating the location variables in the type schema of f with \nlocations e.... Programs A NanoC program, denoted by p, is a sequence of func\u00adtion de.nitions followed \nby a call to one of the previously-de.ned functions. The program is evaluated by evaluating the function \ncall.  3.2 Types The types of NanoC are shown in Figure 5. NanoC has a system of re.ned base types, \nT , dependent heaps, h, and dependent function schemas, S. Locations and References The NanoC locations, \ne, denote areas of the heap. We use e to denote an abstract location; abstract locations cannot be read \nfrom or written to. We use ej to denote a concrete location; only concrete locations can be read from \nor written to. Every concrete location ej (resp. eji ) corresponds to some abstract location e (resp. \ne i), and we require for soundness that there is at most one concrete location corresponding to a particular \nabstract location at any given program point. We call references to abstract locations abstract references \nand references to concrete locations concrete references. Indices The integer and reference types of \nNanoC make use of indices, i, which are a shorthand notation for single integers and arithmetic sequences. \nThe index n represents the singleton off\u00adset set {n}; the index n +m represents the sequence of offsets \n{n + lm}8 . We write i+ to refer to an index which represents l=0 a sequence. Basic Types The base types, \nt, of NanoC include integer and reference types. We use (n)i to denote the type of n-byte integers x \nsuch that x . i. We use ref(e, i) to denote the type of references to location e at an offset x . i within \nthat location. Re.ned Types A re.ned type, T , has the form {. :t | a}, where t is a Basic type and a \nis a pure expression called a re.nement predicate. Note that we can directly embed re.nement predicates \nas quanti.er free formulas in the (decidable) theory of equality, linear arithmetic and uninterpreted \nfunctions (EUFA). Intuitively, the type {. :t | a} denotes values v of Basic type t such that a[v/.] \nevaluates to true. We use the following type abbreviations: int abbreviates (W )-8+1 , where W is the \nlength in bytes of a word, char abbreviates (1)-8+1 , and void abbreviates (0)0. When it is unambiguous \nfrom the context, we use t to abbreviate the type {. :t | true}. Similarly, when the Basic type t is \nclear from the context, we use {a} to abbreviate {. : t | a}. Blocks A block, b, represents the contents \nof a heap location. The types of the block s contents at various offsets are given by bindings i : T \nwhich state that the values at the offset(s) i have the type T . Within a block, no two index bindings \nmay overlap. Heaps A heap type, h, represents the contents of the run-time heap, giving a block type \nto each location in the heap. The contents of heap location e are given by a binding to a block b, written \ne . b. We can form the concatenation of two heaps h1 and h2 as h1 * h2; the resulting heap contains all \nbindings present in either h1 or h2. Our heaps enjoy the following properties: (1) no location may be \nbound twice in a heap, (2) every abstract location in the heap has at most one corresponding concrete \nlocation in the heap, and (3) every concrete location in the heap has exactly one corresponding abstract \nlocation in the heap. We say that a run-time heap satis.es a heap type if every value in the heap has \nthe type speci.ed by the corresponding heap type binding. Function Schemas We combine re.ned base types \nand heap types to form dependent function types and schemas S. A dependent function type consists of \nan input and output portion. The input portion of a dependent function is a pair (xi :Ti ...)/h of a \ndepen\u00addent tuple giving the parameter types and the input heap, i.e., the heap contents required to call \nthe function. The output portion of a dependent function is a pair T/h, called a world, containing the \nreturn type of the function and the output heap, i.e., the heap con\u00adtents after the function returns. \nThe types in the output world of a dependent function type may refer to variables bound in the input \ntuple. Since functions can take reference parameters, they may operate on arbitrary heap locations. Thus, \nwe allow function schemas to be formed by quantifying a function type over the heap locations it contains. \n4. Type System In this section, we present the typing rules of NanoC, outline a proof of their soundness, \nand give an overview of how our system enables inference. 4.1 Typing Rules We begin with a description \nof NanoC s type environments, rules for type well-formedness, and subtyping. We then discuss several \nof the most interesting typing rules. Environments Our typing rules make use of two types of environ\u00adments: \nlocal environments and global environments. A local envi\u00adronment, G, is a sequence of type bindings x \n:T and guard predi\u00adcates e. The former are standard; guard predicates capture the re\u00adsults of conditional \nguards under which an expression is evaluated. A global environment, F, is a sequence of bindings f : \nS mapping functions to their type schemas. We assume that suitable renaming has been performed so that \nno name is bound twice in an environment. An environment is well-formed if each bound type is well-formed \nin the pre.x of the environment that precedes the binding. G ::= E | x : T ;G | a;G (Local Environment) \nF ::= E | f :S;F (Global Environment) Well-Formedness Judgments The judgments of Figure 6 ensure that \ntypes, heaps, and worlds are well-formed in local environments G and heaps h. Intuitively, a type is \nwell-formed in a local environ\u00adment G if its re.nement predicate a is a Boolean formula in G, written \nG f e. Additionally, we require that reference types point to heap locations present in h and integer \ntypes have non-negative size. A block is well-formed if no two index bindings overlap and each type is \nwell-formed with respect to the local environment and preceding indices. We distinguish between concrete \nblocks, bound to concrete heap locations, which must have (pure) re.nements over immutable variables \nbound in the environment, and abstract blocks, bound to abstract heap locations, which have re.nements \nwhich may additionally use offset names (e.g., @0) to refer to val\u00adues at other offsets within the block. \nWe disallow offset names in the re.nements for concrete blocks for two reasons. First, they are unnecessary, \nas we can use names bound in the environment to pre\u00adcisely describe a particular location. Second, they \nare problematic, as the values at the offsets can be changed by strong updates, thus invalidating the \nre.nements. To ensure that no elements overlap, the block well-formedness rules make use of an auxiliary \nfunction, Ind(i, T ), which produces the set of offsets occupied by a value of type T located at offsets \nx . i. For example, Ind(0, (4)0) pro\u00adduces the set {0, 1, 2, 3}, i.e., the set of offsets occupied by \na 4-byte integer located at offset 0.  A heap is well-formed if each block is well-formed, no location \nis bound twice, each abstract location has at most one correspond\u00ading concrete location, and each concrete \nlocation has a correspond\u00ading abstract location. Note that we check blocks bound to abstract locations \nusing abstract block well-formedness and blocks bound to concrete locations using concrete block well-formedness. \nA schema is well-formed if all parameters are well-formed with respect to the previous parameters and \nthe input heap, the input heap is well-formed with respect to the parameters, and the output world is \nalso well-formed with respect to the parameters. Subtyping Judgments The subtyping judgments of NanoC \nare shown in Figure 8. The rules use set-theoretic inclusion checks be\u00adtween arithmetic sequences represented \nby indices and logical im\u00adplication checks over the re.nement predicates. To ensure decid\u00adability, we \nembed the implication checks into a decidable logic of Equality, Linear Arithmetic and Uninterpreted \nFunctions (EUFA). We write [ a] for the embedding of a pure expression a into EUFA. We lift the embedding \nto environments as follows: . [ x : {. :t | a};G]] = [ a[x/.]]] . [[G]] . [ a;G]] = [ a] . [[G]] . [ \nE] = true Most of the rules in Figure 8 are straightforward. Rule [<:-NULLPTR] is used to coerce the \ninteger value 0 into an arbi\u00adtrary pointer type, allowing the use of null pointers. Rule [<:-ABSTRACT] \nallows a concrete pointer to be treated as abstract. Covariant Heap Subtyping Our use of the covariant \nheap sub\u00adtyping rule [<:-HEAP] may seem unsound at .rst blush. Typical type systems are .ow-insensitive. \nIn such systems, a reference has a single type over the entire scope in which it is de.ned, and hence, \nusing covariant subsumption to unsafely upcast reference types can cause unsoundness. In our setting, \ncovariant subtyping is sound as we treat the heap in a .ow-sensitive manner. We assign different types \nto the current heap before evaluating an expression and the resulting heap after the expression has been \nevaluated. This allows a heap location to be updated to re.ect a change in the type of the stored value, \navoiding the aforementioned unsoundness. Pure Typing Judgments The typing judgments for pure expres\u00adsions \nare shown in Figure 7. The rules are quite standard [25, 14, 29, 4]. Note that the re.nement predicates \nfor these expressions precisely track the value of the expression. The only non-trivial rule is [T-PTR-ARITH] \nwhich handles pointer arithmetic. The re\u00ad.nement for the result uses the re.nement PAdd(., a1,a2) (Sec\u00adtion \n2) which states that the value obtained by adding an offset a2 to a base pointer a1 yields an appropriately \noffset pointer into the same block. Recall that BS(.) (resp. BE(.)) denotes the address where the block \nreferred to by . begins (resp. ends). The rules [T-ARITH], [T-PTR-ARITH], and [T-PTR-COMP] use the index \noperators + and ~, which are binary operations on in\u00addices which approximate arithmetic operations and \nthe comparison operator, respectively. Typing Judgments The typing judgments for expressions and pro\u00adgrams \nare shown in Figures 9 and 10. The program typing rules are straightforward. The expression typing judgment \nG,h f e : T/h ' states that, in local environment G, if the heap initially satis.es h, then evaluating \ne produces a value of type T and a heap satisfying Type Well-Formedness G,h f T 0 = n G;. : (n)i f a \n[WF-INT] G,h f{. : (n)i | a} e . Dom(h) G;. : ref(e, i) f a [WF-REF] G,h f{. : ref(e, i) | a} Abstract \nBlock Well-Formedness G,h fA b G,h f T Ind(n, T ) n Dom(b)= \u00d8 x fresh G;x :T,h fA b[x/@n] [WF-FIELD] \nG,h fA n:T,b G,h f T Ind(n +m,T ) n Dom(b)= \u00d8 G,h fA b [WF-ARRAY] G,h fA n +m : T,b Concrete Block Well-Formedness \nG,h fC b G,h f T Ind(i, T ) n Dom(b)= \u00d8 G,h fC b [WF-CONCBLOCK] G,h fC i :T,b Heap Well-Formedness G \nf h [WF-EMPTY] G f emp e . Dom(h) ek ./Dom(h) G f h G,h * ej . b fC b [WF-CONCRETE] G f h * ej . b \ne/. Dom(h)G f h G,h * e . b fA b [WF-ABSTRACT] G f h * e . b World Well-Formedness G f T/h G,h f T G \nf h [WF-WORLD] G f T/h Schema Well-Formedness f S x1 :T1 ... f h for each xi,x1 : T1 ...xi-1 :Ti-1,h \nf Ti x1 : T1 ... f T ' /h ' [WF-SCHEMA] f.e....(x1 :T1 ...)/h . T ' /h ' Figure 6. Well-Formedness h \n'. The majority of the rules are straightforward; the most interest\u00ading rules are those that deal with \nmemory access. Both typing judgments are parametrized by a function . map\u00adping run-time heap locations \nr to corresponding locations e in the static heap typing, used in [T-REF]. This function is a technical \ndevice used in the soundness proof, and is always \u00d8 when type\u00adchecking source code entered by the user, \nwhich cannot contain reference constants.  4.2 Type Checking Memory Operations Next, we discuss the \nrules for memory allocation, heap operations, function calls, and location unfolding. The key idea that \nenables our system to verify and infer invariants about in-memory data struc\u00adtures in the presence of \ntemporary invariant violation is our distinc\u00ad  Pure Typing G f. a : T G f. a : T1 G f T1 <: T2 G f T2 \n[T-PURESUB] G f. a : T2 0 = w [T-INT] G f. (w)n : {. :(w)n | . = (w)n} .(r)= e [T-REF] G f. ref(r, n): \n{. :ref(e, n) | . = ref(r, n)} G(x)= {. : t | a} [T-VAR] G f. x : {. :t | . = x} G f. a1 : (n)i1 G f. \na2 : (n)i2 [T-ARITH] G f. a1 + a2 : {. : (n)+(i1,i2) | . = a1 + a2} G f. a1 : ref(e, i1)G f. a2 : (n)i2 \n Subtyping G f T1 <: T2 i1 . i2 Valid([[G]] . [ a1] . [ a2]]) [<:-INT] G f{. :(n)i1 | a1} <: {. : (n)i2 \n| a2} i1 . i2 Valid([[G]] . [ a1] . [ a2]]) [<:-REF] G f{. :ref(e, i1) | a1} <: {. :ref(e, i2) | a2} \n[<:-ABSTRACT] G f{. :ref(ej ,i) | a} <: {. : ref( e, i) | a} [<:-NULLPTR] G f{. : (W )0 | a} <: {. : \nref( e, i) | a} Block Subtyping G f b1 <: b2 [<:-BLOCK-EMPTY] G f emp <: emp G f T1 <: T2  [T-PTR-ARITH] \nx fresh G;x :T1 f b1[x/@n] <: b2[x/@n] G f. a1 +p a2 : {. : ref(e, +(i1,i2)) | PAdd(., a1,a2)} G f. a1 \n: ref(e, i1)G f. a2 : ref(e, i2) [T-PTR-COMP] G f. a1 ~ a2 : {. :(W )~(i1,i2) | . = a1 ~ a2} G f. a : \n{. : int | . =0} [T-ASSERT] G f. assert(a): void Figure 7. Pure Typing Rules tion between concrete locations \nand abstract locations. Thus, to better understand the rules for memory operations, we begin with a more \nthorough description of abstract and concrete locations. Concrete Locations are names that refer to exactly \none physical memory location. For example, a single item in a linked list has one physical location and \nthus can be identi.ed with a concrete location. The block bound to a concrete location describes the \ncurrent state of the contents of exactly one physical location. Abstract Locations are names that refer \nto zero or more concrete locations. For example, all items in a linked list may share the same abstract \nlocation, although each item is at a different concrete location. The block bound to an abstract location \nis an invariant that applies to all elements which share that abstract location. Since we wish to verify \ndata structure invariants in spite of temporary invariant violation, we will allow memory to be accessed \nonly through concrete locations. This will enable our type system to perform strong updates to the types \nof concrete locations, providing robustness with respect to temporary invariant violation. Because we \nwish to verify properties of unbounded collections, which are represented using abstract locations, we \nneed a strategy to handle pointers to abstract locations. Strategy for Collections We employ a two-pronged \nstrategy for handling pointers to abstract locations, and thereby collections. First, as long as only \na single pointer to an abstract location is used, we can be assured that only one corresponding concrete \nlocation is being accessed. We will use our location unfold operation to obtain a concrete location corresponding \nto a pointer s referent. As long as the abstract location is only accessed through this unfolded pointer, \nwe can safely perform strong updates on the new concrete location. Second, if we must use another pointer \nto access the ab\u00adstract location, we can no longer be assured that a single concrete location will be \nupdated. When this happens, we will use the lo\u00adcation fold operation to ensure that the contents of the \nconcrete location created earlier meet the abstract location s invariant, dis\u00adallow further use of the \nunfolded pointer (without another unfold), and allow the new pointer to be soundly unfolded. [<:-FIELD] \nG f n : T1,b1 <: n : T2,b2 G f T1 <: T2 G f b1 <: b2 [<:-ARRAY] +m +m G f n : T1,b1 <: n : T2,b2 Heap \nSubtyping G f h1 <: h2 G f b1 <: b2 G f h1 <: h2 [<:-HEAP] G f h1 * e . b1 <: h2 * e . b2 World Subtyping \nG f T1/h1 <: T2/h2 G f T1 <: T2 G f h1 <: h2 [<:-WORLD] G f T1/h1 <: T2/h2 Figure 8. Subtyping In the \nfollowing, we describe the typing rules for the key op\u00aderations of location unfolding and folding and \ndemonstrate how they allow us to soundly perform strong updates. We then describe the remaining heap-accessing \noperations: memory allocation, heap read and write, and function calls. Unfolding The expression letu \nx =[unfold e] a in e, which acquires a concrete pointer to the location e that a points to, is typed \nby rule [T-UNFOLD]. The rule .rst typechecks a in G to determine where it points. The block b bound to \nthis location is located in the initial heap, h, to .nd the invariant satis.ed by the abstract location. \nWith some modi.cation, this same block is bound to a new concrete location, ej , to ensure that this \nconcrete location initially satis.es the same invariants as the abstract location did. The modi.cation \nconsists of a sequence of substitutions. The block b may contain types which reference previous elements \nby their indices (i.e., may contain types containing names like @i). Such types only have meaning in \nthe context of the block where the indices are bound; if the type is extracted from the block by typ\u00ading \na read operation, for example it will be meaningless, since the indices are not bound to types in the \nenvironment. To give these types meaning outside of the block, we create fresh variable names xi for \neach non-sequence index i and extend the environment with appropriately-substituted bindings for these \nnames. Each concrete location has a sel..ed re.nement stating that the value at each index i is equal \nto the corresponding name xi. Note that sequence indices are not bound to sel..ed types, because a sequence \nindex binding represents multiple data values.  Finally, a pointer to ej is bound to x in the body e. \nWell\u00adformedness checks ensure that no other concrete location corre\u00adsponding to e exists and that the \nnew bindings do not escape the scope of the body. Note that the pointer being unfolded must be non-null. \nBecause null pointers are treated as references to arbitrary, possibly unin\u00adhabited, abstract locations \nwith arbitrary invariants, allowing a null pointer to be unfolded would allow the introduction of arbitrary \npredicates into the environment, leading to unsoundness. By allow\u00ading only non-null pointers to be unfolded, \nwe ensure that we only unfold pointers to concrete locations which had previously been allocated, initialized, \nand folded. Such pointers are guaranteed to genuinely satisfy the invariants of their abstract locations \nand so there is no risk of unsoundness in unfolding them. Folding The expression [fold e], which releases \nthe concrete location currently assigned to e , is typed by rule [T-FOLD]. The rule uses subtyping to \ncheck that the concrete location ej satis.es the invariant speci.ed by its corresponding abstract location \ne and removes concrete location ej from the output heap, preventing further use of pointers to ej . Memory \nAllocation The expression malloc(e, x) is typed by rule [T-MALLOC], which creates a new concrete location \ncorrespond\u00ading to newly-allocated memory. The new concrete location corre\u00adsponds to abstract location \ne , which is mapped to block b, giving the desired invariant for the new concrete location. This invariant \nis not yet established for the concrete location, which represents freshly-allocated memory; thus, the \nconcrete location is mapped to bT, which is b with all re.nements set to true, and it is up to the caller \nto establish the invariant. The expression returns a reference to the beginning of the concrete location \n(index 0); the re.nement on this reference states that the reference is a safe pointer to the start of \na block of size x, where safe is de.ned as . Safe(.)= . =0 . BS(.) = .< BE(.) The uniqueness of concrete \nlocation bindings within the heap is en\u00adsured using heap well-formedness; i.e., if there is an active \nconcrete location corresponding to the abstract location being allocated, it must be folded up before \nmalloc is invoked. Initial Heap The input heap of the program s main function gives the type of the heap \nat the start of execution. Since at the begin\u00adning of execution no locations have been allocated and \nno invari\u00adants established, this initial heap cannot contain concrete locations. It may, however, contain \nabstract locations, since they need not describe the contents of any concrete locations. Rule [T-MAIN], \nwhich typechecks the call to the main function, ensures the initial heap contains only abstract locations. \nPointer Read The expression *x is typed by rule [T-READ]. This rule ensures that the pointer is valid; \nif so, the type of the read is given by the type bound in the heap at the reference s location, index \npair. The heap is left unaltered. Pointer Write The expression *x1 := x2 is typed by rules [T-WRITE-FIELD]and \n[T-WRITE-ARRAY].Ifthereferenceidenti.es exactly one location within a block i.e., it has a singleton \nindex n the rule [T-WRITE-FIELD] can be used to return a new, strongly-updated heap where the type of \nthe referent has been updated to the type of the value being assigned. Otherwise, a strong update is \nunsound; the rule [T-WRITE-ARRAY] is used to ensure that the new value has the same type as the previous \nvalue. Note that we could use fold/unfold to allow strong writes to arrays, but we eschew this for simplicity. \nBoth rules ensure that the dereferenced pointer is valid. Function Call The expression [e...] f(y...) \nis typed by rule [T-CALL], which is inspired by the modular footprint -based frame rule from separation \nlogic. This rule splits the initial heap into two portions: hm, the portion of the heap which is modi.ed \nby the function, and hu, the portion of the heap which is left unmodi.ed by the function. To ensure soundness, \nwe check that hm and hu are individually well-formed; this prevents placing a concrete loca\u00adtion in hu \nand its corresponding abstract location in hm, allowing the function to unsoundly unfold an already-unfolded \nlocation. The rule also generates a substitution mapping formal (location) param\u00adeters to actual (location) \nparameters. This substitution is used to check that the actual parameters and heap are subtypes of the \nfor\u00admal parameters and heap. The result of the call is the return type and the function s output heap, \nboth with the actual (location) pa\u00adrameters substituted for the formals. The resultant output heap is \njoined with the unmodi.ed portion of the input heap to obtain the caller s heap after the function returns. \n 4.3 Type Soundness We ensure the soundness of our type system by proving the stan\u00addard progress and \npreservation theorems. Due to space restrictions, we can only present a high-level view of the soundness \ntheorems; detailed proofs, as well as our standard call-by-value small-step se\u00admantics, can be found \nin [28]. We relate run-time heaps and heap types using a heap satisfac\u00adtion relation h |=. h *. Intuitively, \nthis relation says that the run\u00adtime block assigned to r in run-time heap h has the block type assigned \nto .(r) in the heap type h * . Our transition relation takes an expression e, a run-time heap h, a heap \ntype h1, and a mapping from run-time heap locations to static heap type locations .1 and returns a new \ntuple of the same form representing the state of the program and typing of the heap after evaluating \ne. The transition relation is parametrized over a global environment F mapping functions to their de.nitions. \nWe denote the single step transition relation by .F and use . * to F denote its re.exive, transitive \nclosure. PROPOSITION 1. (Preservation) If (e, h, .1,h1) .F (e ' ,h ' ,.2,h2), F, \u00d8,h1 f.1 e : T * /h \n* , h |=.1 h1 then F, \u00d8,h2 f.2 e ' : T * /h * , h ' |=.2 h2. PROPOSITION 2. (Progress) If F, \u00d8,h1 f.1 \ne : T * /h * h |=.1 h1 e is not a value then (e, h, .1,h1) .F (e ' ,h ' ,.2,h2) for some e ' ,h ' ,.2, \nand h2. (We elide well-formedness statements in the above for clarity and brevity; the details appear \nin the technical report [28].) Type soundness implies the following safety properties: (1) all memory \naccesses occur on non-null pointers that are within the bounds of their allocated memory regions, and \n(2) no assertion failures occur at runtime.  4.4 Type Inference Next, we give a brief overview of type \ninference in NanoC. Type inference occurs in three phases: the .rst infers Basic types for the program; \nthe second inserts location fold and unfold operations where necessary; and the third infers re.nement \ntypes using liquid type inference. Basic Type Inference In previous work [29, 20], we based our type \ninference techniques on the rich type information provided by ML s type system. Because C programs are \nessentially untyped,  Expression Typing F, G,h f. e : T/h ' G f. a : T [T-PURE] F, G,h f. a : T/h F, \nG,h f. e : T1/h1 G f T1/h1 <: T2/h2 G f T2/h2 [T-SUB] F, G,h f. e : T2/h2 G f. a : (n)i F, G;a =0,h f. \ne1 : h ' T/ F, G;a =0,h f. e2 : h ' T/ [T-IF] F, G,h f. if a then e1 else e2 : h ' T/ F, G,h f. e1 : \nT1/h1 F, G;x:T1,h1 f. e2 : T 2/h 2 G f. T 2/ h2 [T-LET] F, G,h f. let x = e1 in e2 : T 2/h 2 G f. a \n: {. :ref(ej ,i) | Safe(.)}h = h1 * ej . ...,i:T,... [T-READ] F, G,h f. *a : T/h G f. a1 : {. :ref(ej \n,n) | Safe(.)} G f. a2 : t h = h1 * ej . ...,n:{. : t | a},... h ' = h1 * ej . ...,n : {. :t | . = a2},... \n [T-WRITE-FIELD] F, G,h f. *a1 := a2 : void/h ' G f. a1 : {. : ref(ej ,n +m) | Safe(.)} G f. a2 : T h \n= h1 * ej . ...,n +m : T,... [T-WRITE-ARRAY] F, G,h f. *a1 := a2 : void/h G f. a : {. : ref( e, iy) \n| . =0} h = h0 * e . i : Ti ...,i+ : T + ... . =[xi/@i...] G1 = G;xi :.Ti ... xi fresh ej fresh h1 = \nh * ej . i : {. = xi} ...,i+ :.T + ... F, G1;x: {. :ref(ej ,iy) | . = a},h1 f. e : T 2/h 2 G1 f h1 G \nf T 2/h 2 [T-UNFOLD] F, G,h f. letu x =[unfold e] a in e : T 2/h 2 h = h0 * e . b1 * ej . b2 G f b2 \n<: b1 [T-FOLD] F, G,h f. [fold e]: void/h0 * e . b1 ej fresh h = h0 * e . b G f h * ej . bT G f. a : \n{. : int | .> 0} T = {. :ref(ej , 0) | Safe(.) . BLen(., n)} [T-MALLOC] F, G,h f. malloc(e, a): T/h \n* ej . bT G f hm G f hu F(f)= \u00b7, .ef . . ..xj :Tj . . ./hf .T ' /hf ' . =[aj . . ./xj ...][e . . ./ef \n...]G f hu * .h f ' for each j, G f. aj : .Tj G f hm <: .hf [T-CALL] F, G,hu * hm f. [e...] f(aj ...): \n.T ' /hu * .h f ' Figure 9. Expression Typing Rules we .rst use a type inference pass to assign rich \nBasic types to local variables and expressions and to discover the types of the heap s contents. Program \nTyping F f p : T/h f S S = .e . . ..xj :T j . . ./h .T ' /h ' F;f : Tj ..., T ' / ' * h0 S, xj : h f\u00d8 \ne : h xj : T j ... f T ' /h ' xj :T j ... f h0 F;f :S f p : T/h [T-FUN] F f letf f = fun(xj ...){e} \n: S in p : T/h h0 abstract F(f) = ()/h0.T/h [T-MAIN] F f f() : T/h Figure 10. Program Typing We .rst \nuse the declared C types of all functions in the pro\u00adgram to generate corresponding Basic type schemas. \nThis process is largely automatic and rarely requires annotations to be added. The generated function \nschemas are then used to infer Basic types for local variables, expressions, and heap contents as follows: \nFirst, local variables and expressions are assigned types where the as-yet\u00adunknown indices and locations \nare represented by variables. A sys\u00adtem of subtyping and heap location inclusion constraints over these \ntypes is generated from the source program in a syntax-directed manner. Next, these constraints are simpli.ed \nto a set of location equality (aliasing), index inclusion, and heap location inclusion constraints over \nthe unknowns. Finally, the simpli.ed constraints are solved using a .xed point algorithm to obtain solutions \nfor the heap contents and the unknown index and location variables, giv\u00ading the types of the local variables, \nexpressions, and heap contents in the body of the function. Location Fold and Unfold Inference Next, \nour system automati\u00adcally inserts location fold and unfold expressions in order to ensure that every \ndereference is on a concrete pointer and that only one concrete location is unfolded at a time, as required \nby our typing rules. To do this, our system visits each block in the CFG of each function. Our system \ntraverses the statements in the block in order, maintaining a list of which concrete location, if any, \nis unfolded for each abstract location. At the beginning of the block, there are no unfolded concrete \nlocations; the sole exception is the entry block of a function, which may take a pointer to an unfolded \nlocation. At each dereference, our system checks if the dereferenced pointer points to the currently-unfolded \nconcrete location for its abstract location. If not, our system inserts a fold to fold up the old concrete \nlocation, if any, and inserts an unfold operation on the dereferenced pointer, creating a new active \nconcrete location which is assigned to this pointer. At the end of the block, all locations are folded. \nLiquid Type Inference Finally, we use liquid type inference to in\u00adfer re.nement types and thus automatically \ndiscover data structure invariants. This step is similar to previous work [29, 20]; we give a brief outline \nhere. As before, we observe that our type check\u00ading rules encode an algorithm for type inference and \nso we per\u00adform type inference by attempting to produce a type derivation. At various points in the derivation, \nwe encounter types (resp. heaps, schemas) which cannot be synthesized directly from the form of the expression \nand the current environment but must be inferred. We insist that these types (resp. heaps, schemas) be \nliquid, denoted T (resp. h , S ), i.e., their re.nements must be liquid re.nements consisting of a conjunction \nof logical quali.ers. Whenever we en\u00adcounter a type which must be inferred, we create a new template \ntype, which is the Basic type inferred earlier where a fresh variable is used to represent the as-yet-unknown \nliquid re.nement. We gen\u00aderate subtyping constraints over the template types using the sub\u00adtyping premises \nin our type rules; the subtyping rules are used to reduce these constraints to simple implication constraints \nbetween re.nement expressions and unknown re.nement variables. These constraints are solved via abstract \ninterpretation to yield a liquid re.nement for each re.nement variable. Replacing each variable with \nits solution yields a re.nement typing for the program.  5. Evaluation We implemented our type system \nin CSOLVE, a prototype static veri.er for C programs. CSOLVE takes as input a C source .le and a set \nof logical quali.ers, which CSOLVE uses to perform liquid type inference. CSOLVE outputs the inferred \nliquid types of functions, local variables, and heap locations and reports any re.nement type errors \nthat occur. We applied CSOLVE to several challenging benchmarks, drawn from [19], [21], [26], and the \nexample of Section 2, which illustrate common low-level coding idioms. The results are shown in Fig\u00adure \n11. In each case, CSOLVE was able to precisely reason about complex invariants of in-heap data structures \nand memory access patterns to statically verify memory safety by proving the absence of null pointer \ndereferences and array bounds violations. (In the case of ft, we show only array bounds safety; see Section \n5.1.) We explain several of the benchmarks below. String Lists Using CSOLVE, we veri.ed the safety of \na program implementing a C idiom for linked list manipulation which is par\u00adticularly common in operating \nsystem code [9] and which requires precise reasoning about pointer arithmetic. Recall the example of \nSection 2, which contained functions for creating and initializing strings and for creating lists of \nstrings. We add to that example the function string succ, shown below, which takes a pointer to the str \n.eld of a stringlist and returns the next string in the list. (Explicit null checks checks have been \nomitted for brevity) This function is used in init succ, which creates a list of several strings and \ninitializes the second one using init string. CSOLVE precisely tracks pointer arithmetic to verify init \nsucc, by proving that that the input to init string has the type from Section 2. slist *string_succ(string \n**s) { 1:slist *parent = (slist **)s -1; 2:return parent->next->s; } void init_succ() { slist *sl; string \n*succ; sl = new_strings(3); succ = string_succ(&#38;sl1->s); init_string(succ, \\0 ); } The string succ \nfunction expects an argument s of type ref(e 1 , 4) in a heap of the form e 1 .0:ref(e 1 , 0), 4: ref(e \n2 , 0) 3 e2 .0:{. : int | 0 = .}, 4:{. : ref(e , 0) | BLen(., @0)} e3 .0+1 : char From Section 2, we \nknow that the return type of new strings pro\u00advides a pointer of this type, assigned to sl, in the appropriate \nheap. Thus, we begin in string succ with the assignment to parent on line 1. Since s is cast to a stringlist*, \nwhich is 4 bytes long, and decremented, the type of the pointer assigned to parent is ref(e 1 , 0). Continuing \non line 2, the type of parent->next is the same, since the next pointer points to a structure of the \nsame type. Finally, the type of parent->next->s is given by the type at off\u00adset 4 of e 1, since s is \nthe second item in the stringlist struc\u00ad 2 ture. Thus, string succ returns a pointer of type ref(e , \n0) a pointer to a string in a heap of the form shown above. This Program Lines Quali.ers Assumes Time \n(s) stringlist 72 102 strcpy 77 304 adpcm 198 13 042 pmap 250 3 034 mst 309 1 016 power 620 7 2111 ft \n652 2 6310 ks 742 9 7721 Total 2,920 39 15 1,240 Figure 11. Results. Lines is the number of source lines \nwithout comments. Quali.ers is the number of logical quali.ers used. Assumes is the number of manual \nassumptions inserted. Time (s) is the time in seconds CSOLVE requires to verify safety. pointer is passed \nto init string; as the pointer and heap meet the required invariants, CSOLVE veri.es safety. Thus, CSOLVE \npre\u00adcisely reasons about pointers and in-heap data structures and auto\u00admatically veri.es this example \nusing the quali.ers Q from Sec\u00adtion 2. Audio Compression Using CSOLVE, we veri.ed the memory safety of \nroutines for ADPCM audio encoding and decoding. The encoder, outlined below, takes as input an audio \nstream consisting of an array of 16-bit samples and outputs a compressed stream us\u00ading 4 bits to represent \neach sample. The encoder relies on complex loop invariants to ensure memory safety. void encoder (int \nnsamples, short *in0, char *out0){ short *in = in0; char *out = out0; int bufferempty = 1; char buffer; \nfor (int len = nsamples; 0 < len; len--){ Read *in++; if (!bufferempty) { //Write to buffer elided *out++ \n= buffer; } else { //Write to buffer elided } bufferempty = !bufferempty; } if (!bufferempty) *out++ \n= buffer; } The encoder takes three parameters: nsamples, the total num\u00adber of samples in the input; \nin0, a pointer to the start of the input buffer, an array of 16-bit short values; and out0, a pointer \nto the output buffer, an array of 8-bit char values. The number of ele\u00adments in the input buffer is twice \nthe number of elements in the out\u00adput buffer. The pointer in, initially set to in0, is used to read data \nfrom the input buffer; the pointer out, initially set to out0, is used to write data to the output buffer. \nThe for loop iterates through each element of the input buffer. At each iteration, the loop reads 16 \nbits (a single short value) from the input buffer and advances in. Each iteration also computes a new \n4-bit value for the output; however, since out is a char pointer, the encoder must write 8 bits at a \ntime. Thus, the encoder buffers output into a local char value and only writes to out every other iteration. \nThe .ag bufferempty indicates whether to write to and advance out. The .nal if writes to the output in \ncase there is a value in the buffer which has not been written, i.e., if there are an odd number of samples \nin the input. CSOLVE veri.es the safety of dereferences of in and out, by inferring that in and out have \nthe respective types {. = in0 + nsamples - len} {2 * (. - out0)= nsamples - len - (1 - bufferempty)} \n which encode the crucial loop-invariants that relate the values of the respective pointers with the \nnumber of iterations and the .ag. By inferring similar invariants CSOLVE veri.es the decoding routine. \nVirtual Memory Using CSOLVE, we veri.ed the array safety of pmap, a 317-line program implementing a virtual \nmemory subsys\u00adtem of the JOS OS kernel [19] that comprises functions for al\u00ad locating and freeing virtual \naddress spaces, allocating and freeing a physical page backing a virtual page, and mapping two virtual \npages onto the same physical page. To ensure the safety of array accesses in pmap we must pre\u00adcisely \nreason about the values contained in the collection of envi\u00adronment structures that represents virtual \naddress spaces. Each en\u00advironment includes a mapping from virtual pages to physical pages, env pgdir, \nrepresented as an array of .xed length. Each index of env pgdir is mapped to either the physical page \nallocated to the virtual page or -1 if no physical page has been allocated. Environ\u00adments are joined \ntogether in doubly-linked fashion to form a list of virtual address spaces. The physical address space \nis described by an array of size N, pages. Operations like allocating and freeing physical pages use \nentries from an env pgdir .eld to index into pages. Thus, to prove array safety, we must verify that \nthe items in every env pgdir in every environment are valid indices into pages. For\u00admally, we must verify \nthat every pointer to an environment points to a heap location e whose description is e . 0:ref(e, 0);4: \nref(e, 0); 8+4 :{. : int | .<N} where the pointers at offsets 0 and 4 are pointers to the next and previous \nenvironments, respectively, and the integers at indices in 8+4 are the entries in env pgdir. Note that \nwe cannot prove that every entry in env pgdir is non-negative, as -1 is used to indicate an unused virtual \npage. However, every item in env pgdir is veri.ed to be non-negative before use as an index into pages. \nUsing CSOLVE, we were able to verify that the above heap typing holds and thus determine that every array \naccess in pmap is within bounds. This is challenging because the majority of array accesses are indirect, \nusing an entry in an env pgdir .eld to index into an array of physical page data. This requires precise \nreasoning about the values of all elements contained in an in-heap data structure. Further, array offsets \nare frequently checked for validity in a different function from the one in which they are used to access \nan array, requiring .ow-sensitive reasoning about values across function boundaries. Nevertheless, CSOLVE \nis able to verify the safety of all array accesses in pmap. 5.1 Limitations In the following we discuss \nsome limitations of our current system. Flow-Sensitive Invariants Our system allows .ow-sensitive strong \nupdates to the type of a single member of an in-memory data structure. However, the type of the whole \ndata structure is .ow\u00adinvariant: each individual element must reestablish the data struc\u00adture s type \nbefore the next member of the structure is accessed. For example, suppose that a list contains cells \neach of which has a data .eld with the value 0, and suppose that an loop iterates over the list and sets \neach data .eld to 1. Our system can only verify that at all points in time, each cell has the value 0 \nor 1. In particular, our system cannot determine that before (resp. after) the iteration, the data .elds \nhave the value 0 (resp. 1). We plan to extend our system with this kind of .ow-sensitivity in future \nwork. Structural Subtyping Some C programs take advantage of struc\u00adtural subtyping: a function expects \na pointer to a data structure and is called with pointers to subtypes of that structure which may contain \nadditional .elds that are not accessed by the function. Be\u00adcause the callee may modify some .elds of \nthe structure, it is not sound to keep the re.nements on the untouched .elds as they were before the \ncall, since they may depend on the modi.ed .elds. On the other hand, eliminating these re.nements could \nlead to unnec\u00adessary losses in precision when .elds are read but not written. How to manage the combination \nof mutability, dependent re.nements, and structural subtyping is left to future work. Inserting Folds \nand Unfolds The heuristic for inserting locationfold and unfold operations outlined in Section 4.4 is \nsometimes tooconservative, particularly in its requirement that locations be foldedbefore the entry and \nexit of a block. Consider the following code: if (x->next != NULL) { assert(x->next != NULL); } Because \nx s location will be folded between the condition and the assert, the fact that x->next is non-null will \nbe lost. This limita\u00adtion prevents us from verifying the absence of null pointer derefer\u00adences in the \nft benchmark. In future work, we aim to replace this heuristic with a more robust algorithm like that \nof [2]. 6. Related Work Static Dependent Types were .rst applied to formal veri.cation in the context \nof mechanized proof assistants.In the late nineties there were projects that de.ned programming languages \nwith re\u00adstricted forms of dependent types. DML [32] showed how decid\u00ad able checking could be achieved \nthrough the use of indexed-types and using a decidable logic for the indices. DML is a high-level language, \nand moreover, requires the user to provide manual an\u00adnotations describing the types of recursive procedures \nand induc\u00adtive datatypes. ATS [35] combines linear types with stateful views and explicit programmer-provided \nproof terms to specify and ver\u00adify safety properties of an imperative language. In contrast to the above, \nwe have previously demonstrated [29, 20] that for high-level languages the abstract interpretation enabled \nby Liquid Types can drastically reduce the annotations and automate veri.cation. Our work brings those \nbene.ts to the low-level, imperative setting. Dynamic Dependent Types offer an alternative to static \nveri.\u00adcation where the hardest checks are deferred to run-time. Prior work [25, 14] explores dynamic \nand hybrid re.nement types for higher-order functional languages. The DEPUTY system [10] im\u00ad plements \nhybrid dependent types for C. The DEPUTY type system was designed to track the information required to \nplace appropriate run-time checks (assert statements) in the program. Thus, unlike LTLL, which is designed \nfor static veri.cation, the DEPUTY type system is .ow-and path-insensitive, and oblivious to aliasing, \nheap updatesanddatastructures.Further,unlike LTLL,the DEPUTY type system only supports a form of local \ntype inference; users must write dependent type annotations for procedures. Once DEPUTY has placed the \nassert statements in the code, a precise static veri\u00ad.er like CSOLVE can discharge the checks at compile \ntime. Location-Sensitive Types encode pointer relationships within the type system and use the tracked \ninformation to determine the points where strong updates are possible. LTLL locations are inspired by \nthe way in which locations are used to enable strong updates in [30], a system that was designed to type \nthe machine code gener\u00ad ated from a high-level language. Consequently, this system makes the assumption \nthat all locations on the heap are concrete, which is not valid in the setting of low-level systems code. \nOur technique of using unfold and fold to allow temporary strong updates within an aliased collection \nis closely related to the notions of restrict [16, 2], focus [12], and thawing and freezing [1]. Restrict \ncombines fold and unfold into a single lexically scoped operation, but this criti\u00adcally relies upon the \nexistence of a high-level new operation that creates fully initialized locations. In contrast, LTLL requires \na fold to add fresh locations returned by malloc to collections after they have been initialized. In \nthis sense, the fold operation is a spe\u00adcial case of the adopt [12] or freeze [1] operation that can \nbe au\u00ad tomatically inserted into low-level code without any programmer annotation. Finally, none of the \nabove systems address the issue of pointer arithmetic; our approach of using blocks composed of .xed \nand periodic offsets is similar to that adopted by [31] in the context of data.ow-based alias analysis. \nNote that while tracking pointer arithmetic precisely is not essential to establish memory safety [11], \nit is essential to ensure the stronger invariants over .elds that are inferred and veri.ed by LTLL. \n Floyd-Hoare Logic based veri.cation techniques encode the entire machine state as monolithic logical \npredicates. These approaches are extremely expressive and precise, since arbitrarily complex speci.cations \nfor collections can be encoded using universally quanti.ed logical formulas. For the same reason, they \ncan require signi.cant manual intervention. Veri.cation proceeds by compos\u00ading the user-provided loop-invariants, \npre-and post-conditions with the code to compute veri.cation conditions. When possible, these conditions \nare discharged automatically [15, 9]. However, due to the brittleness of automatic quanti.ed reasoning, \none must some\u00adtimes resort to interactive theorem proving [23, 34, 13]. LTLL uses the underlying type \nsystem as a robust algorithm for quanti.er gen\u00aderalization and instantiation, re.nement predicates to \nachieve pre\u00adcision, and abstract interpretation to automate inference. Abstract Interpretation based \napproaches to static veri.cation fall into two categories. The .rst category includes extremely precise \ntechniques for analyzing control-sensitive properties of individual variables [5, 3, 17, 7, 33, 18] which \ntypically handle the heap very imprecisely. The second category includes extremely precise shape analyses \nthat can characterize the heap using abstract domains tailored to the data-structures being analyzed \n[22, 27, 6, 8, 24]. In contrast, LTLL is an automatic technique that uses a combination of low-level \ntypes and predicate abstraction to compute invariants for data stored inside collections without using \ninformation about the shape of the underlying structure. In future work we would like to investigate \nways to improve the precision of LTLL by enriching it with shape (or reachability) information, which \nwould allow us to determine when a location has been removed from a collection. 7. Conclusion In this \npaper, we broadened the scope of Liquid Types from the ver\u00adi.cation of pure functional programs in a \nhigh-level language to the veri.cation of impure imperative programs in a low-level language. We did \nthis by carefully combining several powerful constructs: precise models of typed heaps with concrete \nand abstract locations, a fold and unfold mechanism for coping with temporary invari\u00adant violation, and \nLiquid Types for inferring precise data struc\u00adture invariants. We demonstrated that this combination \nenables the largely-automatic veri.cation of memory safety properties through several realistic examples \nrequiring precise reasoning about invari\u00adants of in-memory data structures. Acknowledgments The authors \nwish to thank Domagoj Babic, Andrew Gordon, Ross Tate, and the anonymous reviewers for their detailed \nand insightful feedback. References [1] Amal Ahmed, Matthew Fluet, and Greg Morrisett. L3: A linear language \nwith locations. Fundam. Inf., 77(4):397 449, 2007. [2] Alex Aiken, Jeffrey S. Foster, John Kodumal, and \nTachio Terauchi. Checking and inferring local non-aliasing. In PLDI, pages 129 140, New York, NY, USA, \n2003. ACM. [3] T. Ball and S.K. Rajamani. The SLAM project: debugging system software via static analysis. \nIn POPL. ACM, 2002. [4] J. Bengtson, K. Bhargavan, C. Fournet, A. D. Gordon, and S. Maffeis. Re.nement \ntypes for secure implementations. In CSF, 2008. [5] B. Blanchet, P. Cousot, R. Cousot, J. Feret, L. Mauborgne, \nA. Mine, D. Monniaux, and X. Rival. A static analyzer for large safety-critical software. In PLDI, pages \n196 207. ACM, 2003. [6] C. Calcagno, D. Distefano, P. W. O Hearn, and H. Yang. Composi\u00adtional shape analysis \nby means of bi-abduction. In POPL, 2009. [7] S. Chaki, J. Ouaknine, K. Yorav, and E.M. Clarke. Automated \ncompositional abstraction re.nement for concurrent C programs: A two-level approach. In SoftMC, 2003. \n[8] B. E. Chang and X. Rival. Relational inductive shape analysis. In POPL, pages 247 260, 2008. [9] \nJ. Condit, B. Hackett, S. Lahiri, and S. Qadeer. Unifying type checking and property checking for low-level \ncode. In POPL, 2009. [10] J. Condit, M. Harren, Z. Anderson, D. Gay, and G. C. Necula. Dependent types \nfor low-level programming. In ESOP, 2007. [11] J. Condit, M. Harren, S. McPeak, G. Necula, and W. Weimer. \nCcured in the real world. In PLDI, pages 232 244, 2003. [12] M. Fahndrich and R. DeLine. Adoption and \nfocus: Practical linear types for imperative programming. In PLDI. ACM, 2002. [13] J-C. Filli atre and \nC. March\u00b4e. The why/krakatoa/caduceus platform for deductive program veri.cation. In CAV, 2007. [14] \nC. Flanagan. Hybrid type checking. In POPL. ACM, 2006. [15] C. Flanagan, K.R.M. Leino, M. Lillibridge, \nG. Nelson, J. B. Saxe, and R. Stata. Extended static checking for Java. In PLDI, 2002. [16] J.S. Foster, \nT. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. In PLDI, pages 1 12. ACM, 2002. [17] T.A. Henzinger, \nR. Jhala, R. Majumdar, and K.L. McMillan. Abstractions from proofs. In POPL 04. ACM, 2004. [18] H. Jain, \nF. Ivancic, A. Gupta, I. Shlyakhter, and C. Wang. Using statically computed invariants inside the predicate \nabstraction and re.nement loop. In CAV, pages 137 151, 2006. [19] JOS. Jos: An operating system kernel. \nhttp://pdos.csail.mit.edu/6.828/2005/overview.html. [20] M. Kawaguchi, P. Rondon, and R. Jhala. Type-based \ndata structure veri.cation. In PLDI, pages 304 315, 2009. [21] C. Lee, M. Potkonjak, and W. H. Mangione-Smith. \nMediabench: A tool for evaluating and synthesizing multimedia and communicatons systems. In MICRO, 1997. \n[22] T. Lev-Ami and S. Sagiv. TVLA: A system for implementing static analyses. In SAS, LNCS 1824, pages \n280 301. Springer, 2000. [23] A. Nanevski, G. Morrisett, A. Shinnar, P. Govereau, and L. Birkedal. Ynot: \nReasoning with the awkward squad. In ICFP, 2008. [24] H. H. Nguyen, C. David, S. Qin, and W-N. Chin. \nAutomated veri.cation of shape and size properties via separation logic. In VMCAI, 2007. [25] X. Ou, \nG. Tan, Y. Mandelbaum, and D. Walker. Dynamic typing with dependent types. In IFIP TCS, pages 437 450, \n2004. [26] The GNU Project. GNU coreutils. http://www.gnu.org/. [27] Z. Rakamaric, J. D. Bingham, and \nA. J. Hu. An inference-rule-based decision procedure for veri.cation of heap-manipulating programs with \nmutable data and cyclic data structures. In VMCAI, 2007. [28] P. Rondon, M. Kawaguchi, and R. Jhala. \nLow-level liquid types: Technical report. http://pho.ucsd.edu/liquid. [29] P. Rondon, M. Kawaguchi, and \nR. Jhala. Liquid types. In PLDI, 2008. [30] D. Walker and J.G. Morrisett. Alias types for recursive data \nstructures. In Types in Compilation 2000, pages 177 206. Springer-Verlag, 2000. [31] R. P. Wilson and \nM. S. Lam. Ef.cient context-sensitive pointer analysis for c programs. In PLDI, 1995. [32] H. Xi and \nF. Pfenning. Dependent types in practical programming. In POPL, pages 214 227, 1999. [33] Y. Xie and \nA. Aiken. Scalable error detection using boolean satis.ability. In POPL, pages 351 363, 2005. [34] K. \nZee, V. Kuncak, and M. C. Rinard. Full functional veri.cation of linked data structures. In PLDI, pages \n349 361, 2008. [35] D. Zhu and H. Xi. Safe programming with pointers through stateful views. In PADL, \npages 83 97. Springer, 2005.    \n\t\t\t", "proc_id": "1706299", "abstract": "<p>We present <i>Low-Level Liquid Types </i>, a refinement type system for C based on <i>Liquid Types </i>. Low-Level Liquid Types combine refinement types with three key elements to automate verification of critical safety properties of low-level programs: First, by associating refinement types with individual heap locations and precisely tracking the locations referenced by pointers, our system is able to reason about complex invariants of in-memory data structures and sophisticated uses of pointer arithmetic. Second, by adding constructs which allow strong updates to the types of heap locations, even in the presence of aliasing, our system is able to verify properties of in-memory data structures in spite of temporary invariant violations. By using this strong update mechanism, our system is able to verify the correct initialization of newly-allocated regions of memory. Third, by using the abstract interpretation framework of Liquid Types, we are able to use refinement type inference to automatically verify important safety properties without imposing an onerous annotation burden. We have implemented our approach in CSOLVE, a tool for Low-Level Liquid Type inference for C programs. We demonstrate through several examples that CSOLVE is able to precisely infer complex invariants required to verify important safety properties, like the absence of array bounds violations and null-dereferences, with a minimal annotation overhead.</p>", "authors": [{"name": "Patrick Maxim Rondon", "author_profile_id": "81435603774", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1911053", "email_address": "", "orcid_id": ""}, {"name": "Ming Kawaguchi", "author_profile_id": "81435598242", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1911054", "email_address": "", "orcid_id": ""}, {"name": "Ranjit Jhala", "author_profile_id": "81100198278", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1911055", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706316", "year": "2010", "article_id": "1706316", "conference": "POPL", "title": "Low-level liquid types", "url": "http://dl.acm.org/citation.cfm?id=1706316"}