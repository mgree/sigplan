{"article_publication_date": "01-17-2010", "fulltext": "\n Program Analysis via Satis.ability Modulo Path Programs WilliamR.Harris SriramSankaranarayanan FranjoIvan.ci\u00b4c \nAartiGupta UniversityofWisconsin,Madison,WI. UniversityofColorado,Boulder,CO. NECLaboratoriesAmerica,Princeton. \nwrharris@cs.wisc.edu srirams@colorado.edu {ivancic,agupta}@nec-labs.com Abstract Path-sensitivityisoftenacrucialrequirementforverifyingsafetypropertiesofprograms.Asitisinfeasibletoenumerateandana\u00adlyzeeachpathindividually,analysescompromisebysoundlymerg\u00adinginformationaboutexecutionsalongmultiplepaths.However,thisfrequentlyresultsinalossofprecision.WepresentaprogramanalysistechniquethatwecallSatis.ability \nModulo Path Programs (SMPP),basedonapath-baseddecompositionofaprogram.ItisinspiredbyinsightsthathavedriventhedevelopmentofmodernSMT(Satis.abilityModuloTheory)solvers.SMPPsymbolicallyenumeratespathprogramsusingaSATformulaovercontroledgesintheprogram.Eachenumeratedpathprogramisveri.edusinganoracle,suchasabstractinterpretationorsymbolicexecution,toei\u00adther.ndaproofofcorrectnessorreportapotentialviolation.Ifaproofisfound,thenSMPPextractsasuf.cientsetofcontroledgesandcorrespondinginterferenceedges,asaformofproof-basedlearning.BlockingclausesderivedfromtheseedgesareaddedbacktotheSATformulatoavoidenumerationofotherpathprogramsguaranteedtobecorrect,therebyimprovingperformanceandscal\u00adability.WehaveappliedSMPPintheF-Softprogramveri.cationframework,toverifypropertiesofreal-worldCprogramsthatre\u00adquirepath-sensitivereasoning.Ourresultsindicatethatthepreci\u00adsionfromanalyzingindividualpathprograms,combinedwiththeiref.cientenumerationbySMPP,canprovepropertiesaswellasin\u00addicatepotentialviolationsinthelarge. \nCategories and Subject Descriptors D.2.4( Software / P rogram Veri.cation):Assertioncheckers,F.3.1(SpecifyingandVerifyingandRrams)Ations,F.3.2(emanticsof \neasoningaboutPogr:sserSProgrammingLanguages):Programanalysis.General Terms Languages, Verification Keywords \n Program Analysis, Abstract Interpretation, Path Pro\u00ad grams,SymbolicExecution,SATis.abilitySolvers,SMTsolvers. \n 1. Introduction Path-sensitivityisoftenacrucialrequirementforverifyingsafetypropertiesofprograms.Asitisinfeasibletoenumerateandanalyzeeachpathindividually,analysescomisebysoundlymerging \nomprinformationaboutexecutionsalongmultiplepaths.However,thisresultsinalossofprecision,whichmayleadtheanalysistodeter\u00adminefalselythataviolationispossible.WepresenttheSatis.a\u00adbility \nModulo Path Programs (SMPP)approachtoprogramanal- Permissiontomakedigitalorhardcopiesofallorpartofthisworkforpersonalorclassroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributedforpro.torcommercialadvantageandthatcopiesbearthisnoticeandthefullcitationonthe.rstpage.Tocopyotherwise,torepublish,topostonserversortoredistributetolists,requirespriorspeci.cpermissionand/orafee. \nPOPL 10,January17 23,2010,Madrid,Spain.Copyrightc &#38;#169; 2010ACM978-1-60558-479-9/10/01...$10.00 \nysisforpropertyveri.cation.Ourapproachdecomposestheveri\u00ad.cationofagivenprogramtoveri.cationofitscomponentpath \nprograms [4].Apathprogramrepresentsasetofprogramexecu\u00adtions,allofwhichtraversethesamesetofedgesinacontrol.owgraph,butmayvaryinthenumberofiterationsofloops/recurrencesencountered.EachpathprograminagivenControlFlowGraph(CFG)isassociatedwithasimplepathintheMSCC(MaximalStronglyConnectedComponent)decompositionoftheCFG,ob\u00adtainedbycompactingloopsandrecurrencesintheprogramintocomponents[9].Whereasthenumberofcontrolpathsintheorigi\u00adnalCFGmaybein.nite(duetoloopsandrecurrences),theMSCCdecompositionisacyclicwith.nitelymaycontrolpaths.Never\u00adtheless,thisnumbercanbeprohibitivelylargeforreal-worldpro\u00adgrams.Inourexperiments,wehaveobservedmillions \nofpathpro\u00adgramsevenformoderate-sizedCFGswithabout500controledges.Thusanexplicitenumerationofpathprogramsisnotfeasible. \nWethereforeproposea SAT-based symbolic encoding ofthesetofcontrolpathsassociatedwithpathprograms.StartingfromaSATformulathatrepresentsallunexploredcontrolpathsintheMSCCgraphthatcanreachanerrorlocation,weenumerateacon\u00adtrolpathanduseanoracle \ntoverifythecorrespondingpathpro\u00adgram.Eachenumeratedpathprogramcanbeanalyzedusing prooftechniques suchasabstractinterpretation[11,12],or \nfalsi.ca\u00adtiontechniques suchasboundedmodel-checkingthatsearchforconcreteerrortracesofviolations[5].Weassume(w.l.o.g.)thataveri.cationoraclepresentsFloyd-Hoarestyleproofsintheformofinductiveinvariants,orconcretewitnessesuponviolation. \nWepresentaproof-based learning techniquethatavoidsenu\u00admeratingalargesetof related pathprogramsbyreusingtheproofofasinglepathprogram.Theproof-basedlearningtechniqueex\u00adtractsasetofsuf.cient \nedges fromagivenpathprogramandanassociatedsetofinterference edges.Ourtechniqueguaranteesthatanyotherpathprogramthatalsotraversesthesamesetofsuf.\u00adcientedgesandnoneoftheinterferenceedgesisalsocorrect.Asaresult,ourapproachextendsthecore \nreasons fortheproofofagivenpathprogramtoapplytoalargenumberofcloselyrelatedpathprograms.Thesuf.cientandinterferenceedgesareencodedasblocking \nclauses andaddedbacktoourSATformula.WecontinuetoenumeratesolutionstothisSATformulauntilnomoresolutionscanbefound.Usingproof-basedlearningsigni.cantlyreducesthetotalnumberofpathprogramsenumeratedinSMPP,inthemostdramaticcasefrommillions \ntohundreds. OurSATencodingcanbeviewedasacontrol-.owabstrac\u00adtionwithre.nementperformedbyproof-basedlearningofsuf.\u00adcient/interferenceedgesintheCFG.Wedonotencodeordirectlyabstractdatavalues.Reasoningoverdataisperformedbytheveri\u00ad.cationoracles.Notealsothatourenumerationoperatesoverpathprogramsandnotprogramtraces. \nWepresentaninstantiationofourapproachthatutilizestheab\u00adstractinterpretationframeworkastheoracleofchoicetoprovepropertiesoverpathprograms.Theinductiveinvariantsobtainedthroughabstractinterpretationareusedtoextractsetsofsuf.cientedges.Wealsopresenttheuseofover-approximatesymbolicexe\u00adcutionasanotheroraclethatisef.cientoverpathprogramswithoutloopsorwhereinthepropertytobeprovedisindependentoftheloops.Itispossibletouseotherknowntechniquesasoracles,suchaslazyabstractionwithinterpolants[26]orpredicateabstractionre.nement[2,3,17]. \n WeimplementedtheSMPPtechniqueintheF-Softprogramveri.cationframework[21].TheimplementationusesasymbolicexecutionenginebasedonYices[16],andabstractinterpretationenginesusingasuccessionofnumericaldomains \nintervals[10],octagons[27],symbolicintervals[30]andpolyhedra[13].Weeval\u00aduatedourimplementationbyusingittoverifyarrayover.owandstringlibraryusagepropertiesforCprograms.Weusedpubliclyavailablebenchmarks \nsmallerprogramsinZitseretal.[34],andlargeropensourceprogramssuchasopenssh,thttpd andxvidcore.OurevaluationshowsthatSMPPcanderiveproofsofpropertiesthatarebeyondthereachofpath-insensitivestaticanalysis(alreadyimplementedinF-Soft),anditalsoidenti.esnumerouspotentialviolations.IncomparisontotheBLASTtool(usingpredicateab\u00adstractionwithinterpolant-basedre.nement[3]),SMPPcanproveamajorityofthepropertiesprovedbyBLASTandidentifyaddi\u00adtionalviolationsintheseprograms,withinafractionofthetimetakenbyBLAST. \nAnalogy with SMT Solvers: Toprovesafetyproperties,SMPPintegratesprogramanalysisoraclesthatprovepropertiesaboutindividualpathprogramswithaSATsolver,whichisusedtoenumerateoveraBooleanabstractionofthecontrol-.owoftheprogram.ThisissimilarinspirittoSatis.ability \nModulo Theory (SMT)solvers[15,16,29].Tocheckthesatis.abilityofagivenformula,anSMTsolverintegratestheorysolvers(thatcheckthesatis.abilityofconjunctiveformulasoveratheory)withaSATsolverthatenumeratesoveraBooleanabstractionoftheentireformula. \nTosolveaparticularconjunctiveformula,anSMTprocedureemploystheorysolversasoracles.Similarly,SMPPusesveri.ca\u00adtiontechniquesoverpathprogramsasoracles.Infact,wemayusedifferentoraclesfordifferentpathprograms,basedonobservedcharacteristics(e.g.whetherornotabackwardslicew.r.ttheprop\u00adertycontainsloops).Furthermore,thecharacteristicsoftheoraclesaffectthecharacteristicsofouroverallscheme(soundness,com\u00adpleteness,performance,etc.). \nTheory-basedlearninginSMTsolversaddscon.ict clauses backtotheSATsolvertore.netheBooleanabstraction.Analo\u00adgously,SMPPutilizesproof-basedreasoningtoderivesuf.cientedgesandinterferenceedges.TheseareaddedasblockingclausestoaSATformulatoblockotherenumerationsbytheSATsolver.ByrelyingonaBooleanformulaabstraction,wecanapplySAT\u00adbaseddecisionheuristicsandblockingclausesthatcandrivethesymbolicsearchovercontrolpathsinaproperty-drivenmanner.Thisispotentiallyadvantageouscomparedtoanapriori \n.xedsearchorderontheCFGsuchasdepth-.rstsearch(asintypicalsymbolicexecutionbasedapproaches)orbreadth-.rstsearch(asintypicalBMC-basedapproaches). \nThemaincontributionsofthispaperare:(a)SMPP:Anap\u00adproachforsymbolicenumerationofpathprograms,usingaSATsolverandproof-generatingoraclesforverifyingpathprograms. \n(b)Proof-basedlearningtechniquestoidentifyandre-useasetofsuf.cientedgesthatserveasproofsofcorrectness.(c)Acon\u00adcreteinstantiationoftheSMPPapproach,whereweuseabstractinterpretationoverdifferentabstractdomainsandsymbolicexecu\u00adtionasoracles.(d)Anexperimentalevaluationoftheimplementa\u00adtion,whichshowsthatSMPPcanprovemorepropertiesthanpath\u00adinsensitivestaticanalysisandimproveperformanceoverpredicateabstractionre.nement.Inparticular,SMPPavoidsthecostofan \nAlgorithm 1:Satis.abilityModuloPathPrograms. Input:.: ProgramCFG,.: (nf ,.) assertiontobeveri.ed.Result:Alarms \n: Setofpossiblepathprogramsviolatingproperty. begin 1 .D := MSCCDecomposition(.) DD 2 .. := SatEncodePaths(.D,n0 \n,nf ) 3 while ( IsSatis.able(..) ) do 4 p := SolveAndObtainPathProgram(..) 5 . := AnalyzePathProgram(p, \n.) /* Oracle */ 6 if (.(n) |= .) then /* Proof obtained */ 7 (Sp,Ip):= ExtractSu.cientSet(p, .) else \n/* violation obtained */ 8 (Sp,Ip):= PathSlice(p, n, .) 9 Alarms := Alarms .{Sp }10 .. := .. . BlockingClause(Sp,Ip) \n11  end expensivedataabstraction-re.nementprocessanddivergencesonloops,whilefullyutilizingadvancesinSAT/SMTsolvers. \n 1.1 SMPP Approach At a Glance Algorithm1presentsthemainstepsoftheSMPPalgorithm.Wenowstepthroughitwithanexample.Fig.1presentsasimpleimperativeprogramfragmentthatcomputesabufferlengthbLen \nbasedonaninputpointerp,itslengthpLen,andanextra.agmode.TheCFGrepresentationisalsogiven(alsoCf.Example2.1).ThegoalistoprovetheunreachabilityoftheCFGnodelabeled15 \ncorrespondingtotheprogramassertionatline15.Fig.2depictsthemajorstepsintheapplicationofSMPPtotheprogram,describedasfollows. \nExtract an unexplored path program: SMPP.rstconstructstheMSCCdecomposition.D oftheprogramandencodesthesetofallpathsin.D \n(Algo.1lines1 2).Itthenchoosesanunexploredpathfromthisset(line4),fromwhichitconstructspathprogram(A),illustratedasthepathprogramhighlightedinFig.2(A).Con\u00adsideringjustthenodesandedgesthatlieonthispathprogram,theunreachabilityof15 \ncanbeprovedbyaConstants-domainanalysis(Algo.1lines5 6). Extract a set of suf.cient edges: Theproofofunreachabilityofnode15 \nforpathprogram(A)involvestheinvariant p =0 thatisvalidatnode13 alongthepathprogram(A)(theinvariantdoes \nnot,infact,holdfortheprogramasawhole).SMPPappliesatechnique(detailedinSec.3.2)thatpinpointsthekey reason \nfortheinvari\u00adant.Sucha reason takestheformofasetofsuf.cient (control\u00ad.ow) edges.Thesetofsuf.cientedges(denotedS1)correspondingtotheproofinthe.rstpathprogramisshowninFig.2(B). \nAnypathprogramfrom1 to15 thattraversesalloftheedgesinsetS1 willsatisfytheproperty.Notethatthisincludespathsthattraversetheloopsintheprogramarbitrarilymanytimesaswell.Computingsuf.cientsetsthereforeallowsustoextendourproofalongasinglepathprogramtomultiplepathprograms.ThisstepcorrespondstoAlgo.1line7. \nExtract another path program: SMPPnowseeksapathprogramthatvisitsedgesE suchthatS1 . E.ThesearchforsuchapathprogramisperformedusingaSATsolver(Algo.1lines10,3),andyieldsthesecondpathprogram,asshowninFig.2(C).Now,theanalysismustdirectlyreasonabouttheloopinthispathprogram \n  L = 1 0:proc. foo(int*p,intpLen,intmode) bLen = 0 1:int o,L :=1,bLen :=0; pLen = 1 2:if (pLen < 1)return; \n3:if (p ==NULL) 4:pLen :=-1; 5:end-if pLen 6:if (mode) 7:o :=1; else 8:o :=0; 9:end-if 10:while(L = pLen \n) L > pLen 11:if (o > 0) 12:bLen :=L -o; 13:L :=2*L; p . =0&#38; 14:end-while bLen > pLen 15:ASSERT \n(!p || bLen = pLen);  Figure 1. AsimpleimperativeprogramanditsCFGrepresentation. pLen p  (A)(B)(C)(D) \nFigure 2. PathprogramsenumeratedonrunningexamplebySMPP.A: Initialpathprogram;B: Suf.cientedgesfor(A);C: \nSecondpathprogram;andD: Suf.cient(shaded)andinterference(zigzag)edgesfor(C). toproveunreachabilityofnode15.ItcandosoautomaticallybySMPPthenextractsasetofsuf.cientedgesS2 \nfortheinvariantusingtheoctagon domain analyzer [27]toestablishtheinvariant(detailedinSec.3.2),showninFig.2(D).ItalsoperformsanbLen \n= pLen atnode14 (Algo.1lines5 6).ThisinvariantprovesinterferenceanalysisforS2 overtheentireprogram,todiscovercorrectnessofthispathprogram.TheloopinvariantbLen \n= pLen thattheassignmenttopLen onedge4 . 6 maycausesomepathscomputedatnode10 suf.cestoprovethepropertyatnode15.NotethattraversealledgesinS2 \nnottopreservetheproperty.Thisedgethatthisinvariantisindependentofthevariableo.thusformstheinterference \nset forsuf.cientsetS2,denotedasI2 = {4 . 6} (Cf.Sec.3.4).Anypathprogramthattraverses alltheedgesinS2 \nbutnottheinterferenceedge4 . 6 satis.estheproperty. Termination: SMPPhasnowcomputedsuf.cient-interferencepairsofsets(S1, \n\u00d8) and(S2,I2) ,extractedfromthetwopathprogramsconsidered.Every pathprogramiscoveredbythesesets,i.e,eachprogrampathmusteithertraverseeveryedgeinS1 \n,ortraverseeveryedgeinS2 whiletraversingnoedgeinI2.Recallthattheedgesthatarepartoftheloop10 . 10 arepartofanMSCCandthusnotconsideredinenumeratingpathprograms.Asaresult,byexamining2 \noutofthe4 possiblepathprograms,SMPPhasestablishedtheproperty.ThiscomputationoccursoverAlgo.1lines10,3,11. \nSymbolic Encoding: Fig.2consistsofasmallprogramwithafewpathprograms.Inpractice,wehaveobservedCFGswithasfewas500 \nedgesthatexhibitmillions ofpathprograms.Therefore,reasoningaboutsetsofpathprogamsexplicitlyisnotfeasible. \nWeovercomethisdif.cultybymeansofasymbolicencodingofcontrolpathsassociatedwithpathprograms.Theanalysisusesasuccinctpropositional(Boolean)encodingthatsupportsthefol\u00adlowingoperationsef.ciently: \n1. Encodeall ofthecontrolpathsbetweentwonodes(intheMSCCgraph)asaBooleanformula.SuchanencodingislinearinthesizeoftheCFG.Sec.3.1detailsthisencoding. \n 2. GivenasetP ofunexploredcontrolpaths,representedasaBooleanformula.P ,andasuf.cient-interferencepairofedgesets(S, \nI),subtractallofthepathsfromP thattraversealltheedgesinS andnoneoftheedgesinI.Subtractionisperformedbyaddingblocking \nclauses totheformula.P . 3. Determinethattherearenocontrolpathslefttoexamine,orproduceanunexploredpath.Thisisequivalenttocheckingthesatis.abilityoftheupdatedBooleanSATformula.P \n.  SATsolvershavemadeimpressiveadvancesinthepastdecade,enablingthemtosupporttheseoperationsforformulaswithhun\u00addredsofthousandsofvariablesandclauses.Inthisrespect,ourencodingisempiricallyshowntobequiteamenabletoexistingsolverssuchasZChaff[28],evenforlargeprograms. \n  2. Preliminaries We.rstpresentourapproachonsingle-procedureprogramswith\u00adoutfunctioncalls.Weassumethatallvariablesareoftypeinteger.Thehandlingoffunctioncalls(includingrecursion),non-integertypes(especiallypointers)andotherfeaturespresentinaprogram\u00adminglanguagesuchasCisdiscussedinSec.4.Control-.owgraphs(CFG)areusedtorepresentimperativeprograms. \nControl-Flow Graph ACFG.= (N, E, V, ., n0,nf , T) isatuplewhereN isasetofnodes,E . N \u00d7 N isasetofedges,n0 \n. N isaninitiallocation,nf . N isa.nallocation,andV isasetofprogramvariables.Eachedgee . E islabeledbyatransition \nrelation .e(V, V '),a.rst-orderassertionovercurrent\u00adstate variablesV andnext-state variablesdenotedbyV \n'.The.rst-orderassertionT speci.estheinitialvaluesoftheprogramvariables. AnexecutionoftheCFGstartsattheinitiallocationwithinitial \nvaluestotheprogramvariablesthatsatisfyT,andterminateswhenitreachesthe.nallocation.Aprogram assertion \n(n, .) forn . N andassertion. overtheprogramvariables,requiresthat. holdwhenevercontrolreachesthenoden. \nExample 2.1. Fig. 1 shows a CFG of a program over integer\u00advalued and pointer variables (note that for \nthis example, we are only interested in the integer value of the pointer itself). The nodes in the CFG \nare numbered according to the corresponding labels in the program. We wish to prove the unreachability \nof node 15 which corresponds to the failureof the assertion in the corresponding line of the program. \nHowever, a path-insensitiveanalysis is unable to prove the property. The join operation at line 5 may \nlose the relation between p and pLen. 2.1 Path Programs GivenagraphG : (N, E),astrongly connected component \n(SCC)consistsofasubsetofnodesC . N suchthatforeachn1,n2 . C,thereexistsapathfromn1 ton2 andvice-versa.AstronglyconnectedcomponentC \nismaximal(MSCC)iffnostrictsupersetofC isastronglyconnectedcomponent.TheMSCC\u00addecompositionofagraphG isadirected,acyclicgraphGD \nwhosenodesN = {n d 1 ,...,n d } correspondtoeachoftheMSCCsC1, m...,Cm ofG andwhoseedgesconnectn d andnjd \nifandonlyif i somenodeinCi connectstosomenodeinCj byanedgeinE.TheMSCCdecompositionofagraphcanbecomputedinlineartime[9].TheCFGinFig.1containsanon-trivialMSCCconsistingofthenodes{10, \n11, 12, 13}. Def. 2.1 (PathProgram[4]).Let .D be the MSCC decomposition of a CFG ..A pathprogramp : n0 \nd . n d is a simple path in .D from the initial node n0 d to a node n d. The path program p naturally \ncorresponds to a subset of nodes and edges in ., obtained as the union of the MSCCs traversed by p and \nthe edges that connect them. 2.2 Inductive Invariants LetS denotetheuniverseofconcreteprogramstatesandG \nbeadomainofassertionsovertheprogramvariablesorderedbythelogicalimplication|=.Eachassertion. . G representsasetofstates[[.]] \n. 2S .Anexampleofanassertionlanguageusedinpracticeislineararithmeticformulaeovertheintegervariablesofaprogram. \nInductive Map ForasetN ofnodesinacontrol-.owgraph,a.ow-sensitive map. : N . G mapseachnodetoasetofprogramstates,representedasaformula.Suchamapisinductive \niffthefollowingconditionshold: Initiation:T |= .(n0) Consecution: foreachedgee : ni . nj , .(ni) . .e(V, \nV ') |= .(nj )[V . V '] Inordertoestablishaproperty(n, .) foragivenprogram,weseekaninductivemap. suchthat.(n) \n|= ..  2.3 Abstract Interpretation AbstractInterpretationisapowerfulandgeneralframeworkforsystematicallycomputinginductivemapsforagivenprogram.Aninductivemapisa.xedpointofamonotoneoperatorinasuitableabstract \ndomain.Anabstractdomainisalattice(G, |=) thatusuallydenotesanassertionlanguageusedtorepresentsetsofstates.Theabstractionfunctiona \n:2S . G andconcretizationfunction. :G . 2S linkelementsoftheabstractlatticetoconcretesetsofstates.TheyareassumedtoformaGalois \nConnection [12]. TocomputeaninductivemapforthesetN ofcontrol-.ownodes,withinitialnoden0,westartfromaninitialmap.0 \n: N . G anditeratetoproduceasequenceofmaps.1,.2 ,...,wherein 8 j < T,nb = n0, 0T,n = n0, i+1 F .(n): \n.(nb): (.i(na), ., else : post na.nb na . nb) Theiterationterminateswhen.n . N. .i+1(n) |= .i(n).Conver\u00adgenceisguaranteedifthedomainL \nsatis.estheascending chain condition.Failingthis,widening andnarrowing operatorscanbeusedtoguaranteeconvergence.If. \nisthe.xedpointobtaineduponconvergence,then. . . isaninductiveinvariantmap.  Abstractdomainssuchastheinterval \ndomain [10],octagon do\u00admain [27],symbolic intervals [30]andpolyhedra [13]canbeusedtocomputeusefulinvariantsovertheprogramvariablesinordertoprovepropertiesofinterest.Together,thesedomainsrepresentvari\u00adouslevelsoftrade-offbetweenthestrengthoftheinvariantsagainstthecomplexityoftheanalysis. \n  3. Path Program Enumeration Let.= (N, E, V, ., n0,nf , T) beacontrol.owgraphwithMSCCdecomposition.D \n: (ND,ED).Let.: (n, .) beaprop\u00adertyunderveri.cation.Wepresentaprocedureforsymbolicallyenumeratingallcontrolpathsfromn0 \ntonf ,verifying. alongeachassociatedpathprogram. ConsiderAlgorithm1,whichshowstheoverallveri.cationalgorithm.Themajorstepsofthealgorithmare(a)encodingthesetof(unexplored)controlpathsasaBooleanformula.. \n(line2), (b)iteratingoverthesolutionsof.. (line3),(c)analyzingeachpathprogramassociatedwiththecurrentsolution(line5),(d)extractingsuf.cientsets,ifcorrect(line7),otherwisehandlingviolations(line8).Therestofthissectionpresentsthekeystepsindetail1. \n3.1 SAT Encoding Pathprogramsarerepresentedbysimple paths intheMSCCgraph.D oftheCFG..WenowpresentaBooleanSAT-basedencodingofallcontrolpathsin.D.Thisencodingcorrespondstoanimple\u00admentationofSatEncodePaths \nandSolveAndObtainPathPrograms usedinAlgo.1. Foreachedgee in.D,thepropositionalvariablepe indicatesife \nbelongstothepathprogram.Letout(m) denotetheoutgoingedgesinED foranodem . ND andin(m) denotetheincomingedges.Letsrc(e) \nandtgt(e) denotethesourceandtargetnodesofanedgee . ED,respectively.ForasetEs . ED,theformulaexactlyOne(Es) \ndenotesthatexactlyoneedgefromEs occursin WV apath:exactlyOne(Es): pe . =f pe .\u00acpf . e.Es e,f.Es,ec Theformula.. \nistheconjunctionofallBooleanconstraintsgiveninTable1.Theconstraintsshowninthetableenforcethatanypathprogramhas(a)avisittotheinitialnoden0,(b)avisittothe.nalnodenf \n,(c)exactlyoneincomingedgetoeachnoden visited(withtheexceptionofn0),and(d)exactlyoneoutgoingedgefromanoden \nthatisvisited(withtheexceptionofnf ). Theorem 3.1. The Boolean formula .. encodes all paths between n0 \nand nf in the MSCC decomposition .D of ..  3.2 Extracting Suf.cient Sets WenowdescribeAnalyzePathPrograms \nandExtractSu.cientSet asusedinAlgo.1.Let. betheoriginalCFG,n0 betheinitialnodeand(nf ,.) bethepropertywewishtoestablish.Givenapathpro- \nDD gramp : n0 nf ,SMPPanalyzesp usingaproof-generatingoracle.Ifthepropertyholdsoverp,weextractasetofsuf.cientedges.Otherwise,failuretoprovethepropertyindicatesapotentialviolation \ndetailsofhandlingviolationsareprovidedinSec.3.6.Wenowpresenttheextractionofsuf.cientedgesfromproofs. \nLet.p : (Np,Ep) representthesubsetoftheoriginalCFGinducedbythepathprogramp.Theproof-generatingoracleyieldsaproofofsafetyintheformofaninductiveinvariantmap(.xed\u00adpoint). \n: Np . G overGp.Themap. mapseachnoden . Np toaninvariant.(n),validoverallexecutionsalongp.If.(n) |= ., \n1Proofsofkeyresultsareprovidedintheextendedversionofthispaperavailablefromtheauthorsuponrequest. thennoneoftheexecutionsleadingfromn0 \ntonf alongthenodesandedgesinp leadtoaviolation. Weextractsuf.cientedgeswhichformthe corereason be\u00adhindourproofasfollows:(A)we.rstpruneawayunnecessary \ninvariants fromthemap. usingthenotionofaminimalsupport\u00adingset.Removingsuchinvariantsisessentialtoobtainacompactsetofsuf.cientedges.(B)Wethencomputeaninductivemap. \n' thatsupportsthisset.(C)From. ' ,wedirectlyextractasuf.cientsetofedges. Example 3.1 (UnnecessaryInvariants).Consider \nthe second path program p2 showninFig.2(C): 1 . 3 . 6 . 8 .{10, 11, 12, 13} * . 14 . 15 . A polyhedral \ndomain abstract interpreter computes the follow\u00ading invariant: 23 p =0 . pLen = 1 . .(14) : 4 2 \u00b7 bLen \n= L . bLen = pLen . 5 . mode =0 . o =1 This invariant establishes the required unreachability of node \n15 for the path program p2. Nevertheless, the entire invariant is notrequired for the proof. The sole \ninvariant bLen = pLen (underlined above) suf.ces. The remaining invariants are extraneous. Inprinciple,wecanuseothertechniquesthat(attemptto)gen\u00aderateminimalsetsofinvariantsrequiredtoproveagivenprop\u00aderty[6,18,19].Thesetechniquescangeneratestronginvariantsforsmallbutcomplexloops.However,theyarecurrentlyunsuitableforgeneratingsimpleglobalinvariantsforlargepathprograms.Weprovideagenericschemedescribedbelowutilizinga.xedpoint,whereinthe.xedpointcanbecomputedinanyway(includingpredicateabstractionoverpathprograms). \nNote. Removingunnecessaryconjunctsjustatthepropertynodedoesnotsuf.ce.Theremovalofconjunctsfrom.(13) intheexampleabovenowpermitsustoremoveconjunctsfromitspredecessornodeinvariant.(12),inturnspreadingthroughtheentireCFG. \nGeneralizing Invariants Todescribehowtogeneralizeaninvariantmap,we.rstdescribethecomputationofminimal \nsupport sets,akeyprimitive.LetQ : {q1,...,qm} andq beassertionsoverprogramvariablesinasuit\u00adablelogicaltheory,suchthatq1 \n. q2 . ... . qm |= q. Def. 3.1 (MinimalSupportSet).A subset Q ' . Q supportsthe VV inference qi |= q \niff qj .Q' qj |= q.A supportsetQ ' is qi.Q minimaliff no proper subset of Q ' can support the inference. \nFor.1 |= .2,letMinSupport(.1,.2) denotethesetofmini\u00admalsupportingconjunctsin.1 thatimply.2.AnimplementationofMinSupport \n(throughunsatis.able cores)isavailableinexistingsolversformanyusefultheoriessuchaslineararithmetic. Example \n3.2. The assertions q1 : i = j, q2 : j = k +1, q3 : i = k +1, q4 : k = 1 together imply the assertion \nq : i = 2 in the theory of linear arithmetic over integers. Note that the subset {q1,q2,q4} by itself \n(and no proper subset thereof) suf.ces to establish q and is thus a minimal support set. The minimal \nsupport set is not unique. The set {q3,q4} also forms a minimal support set. WeassumethattheabstractdomainG \nisa Moore-closeddomain. Speci.cally,eachinvariant. isa.niteconjunctionofasetofatomicpredicatesthatarenegationclosed:. \n: q1 . q2 \u00b7\u00b7\u00b7.qm.In\u00adductiveinvariantsthatconsistofonlyconjunctiveassertionssuf.ce,ingeneral,toproveanygivenproperty.Proofsinvolvingdisjunc\u00adtionsofconjunctionscanbetransformedintopurelyconjunctiveproofsonasuitableelaboration \noftheoriginalprogram[31].  Table 1. Booleanencodingofthesetofallpathprograms(i.e,pathsthroughtheMSCCDAG). \nFact Encoding n0 shouldbevisitednf shouldbevisitedSourceofeachedgehasexactlyonepredecessor(exceptforn0)Targetofedgehasexactlyonesuccessor(exceptfornf \n) exactlyOne(out(n0)) exactlyOne(in(nf )) V e.ED, src(e)c=n0 [pe . exactlyOne(in(src(e)))] V e.ED, tgt(e)c=nf \n[pe . exactlyOne(out(tgt(e)))] Let. bea.xed-pointmapthatestablishesaproperty(nf ,.),including pLen, \nbLen, p, and L. The result of the repair iteration i.e.,.(nf ) |= ..Since. isa.xed-point,foreveryedgee \n: n1 . for the invariant bLen = pLen at node 14 leads to the map \u00b5 n2 . Ep,thefollowingconsecutionconditionholds: \npartially depicted as: .(n1) . .e(V, V ' ) |= .(n2)[V . V ' ] . Ouroverallstrategytogeneralize. istoconstructa.nitesequenceofmaps\u00b50,...,\u00b5N \n,whereintheinitialmapisde.nedas: ( 0MinSupport(.(nf ),.) m = nf \u00b5(m)= . true m = nf Theinitialmap\u00b50 : \nNp . L mapsthenodenf tothemini\u00admalsupportsetthatenables.(nf ) toprovetherequiredproperty(nf ,.) andmapsallothernodestotrue.Theiterativeprocess\u00b50 \n...,\u00b5N willconvergeontoa.nalmap\u00b5N thatestablishestheproperty(nf ,.),containsnoredundantinvariants,andgeneralizes.. \nTheintermediatemaps\u00b5i fori<N neednotbeinductive.Forinstance,themap\u00b50 couldfailtheconsecutionpropertyfortheincomingedgestothenodenf \n.Themaps\u00b5i ,i . [0,N] havethefollowingproperties: (a) \u00b5N isinductiveandprovestheproperty(nf ,.). (b) \nForeach\u00b5i,andforeachnodem,theassertion\u00b5i(m) consists  ofasubsetofconjunctsfrom.(m).Asaresult.(m) |= \n\u00b5i (m). (c)Eachsuccessivemapincorporatesatleastasmanyconjuncts from. astheprevious,i.e,. i< j,m . Np.\u00b5j \n(m) |= \u00b5i (m). Weproposeaprocesscalledlocal repair toderivethemap\u00b5i+1 from\u00b5i . Local Repair: Weaddressthefailureof\u00b5i \nfori<N tobeaninductiveinvariantbymeansoflocal repair.Toperformthelo\u00adcalrepairof\u00b5i,westrengthen\u00b5i(a) forsomenodea \ntoaddressthefailureofconsecutionalonganedgee : a . b:\u00b5i(a) . \u00b5i\u00b5i .a.b(V, V ' ) |=(b).However,.(a) . \n.e(V, V ' ) |=(b) 2.LetQa beaminimalsubsetofconjunctsfrom.(a) thatsup\u00adportsthisimplication.Thelocal repair \nof\u00b5i(a) w.r.ta . b is \u00b5i+1 (a)= MinSupport(.(a), pre(\u00b5i(b),e : a . b).Theappli\u00adcationofMinSupport removesredundantconjunctsfromtheasser\u00adtion.i(a).Thus\u00b5i+1(a) \nminimallysupportsconsecutionacrosstheedgea . b.Strengthening\u00b5i(a) forsomenodea mayin\u00advalidatetheconsecutionconditionforsomeofitsincomingedges.Anewrepairiterationisthenrequiredtoaddressthisfailure.Thisprocessconvergeswhen\u00b5i \nisinductive,thusneedingnofurtheriteration. Theorem 3.2. The process of repeated local repair terminates \nin .nitely many steps yielding a .xed-point map \u00b5,s.t. .(b) |= \u00b5(b) for all b . Np . Example 3.3. Consider \nagain the path p from Ex.3.1. Abstract interpretation computes an invariant relating program variables, \n2. .(a) . .e(V, V ' ) |= .(b) |= \u00b5i(b) n 3 10 11 13&#38;14 \u00b5(n) bLen =0 bLen = pLen L = pLen bLen = pLen \npLen = 1 bLen = pLen L =1 Theresult\u00b5 oftherepairiterationisusedtoextractasetofsuf.cient edges,Sp . Ep \nthataresuf.cientfortheproofof.. x := e Def. 3.2 (Suf.cientEdges).An assignment e : a ----. b is a supportingedge \nw.r.t \u00b5 if \u00b5(b) contains an invariant assertion q(e) involving the variable x 3. A condition e : a --. \nb is a supporting edge if \u00b5(a) |= q(e) and \u00b5(b) |= q(e). Asuf.cient set for\u00b5 isthesetofallsuchedges.Thede.nitionofsuf.cientedgesimmediatelyimpliesamethodofderivingsuchasetofedgesfromamap\u00b5. \nExample 3.4. Continuing Ex.3.3, the suf.cient edges correspond\u00ading to the proof over p consist of the \nassignments 1 . 3, 12 . 13 and 13 . 10 along with conditions 10 . 11, 10 . 14 and 14 . 15.  3.3 Over-Approximate \nSymbolic Execution Inmanycases,thepathprogrammaynotcontainloops,ortheloopspresentdonotaffectthepropertyofinterest.Insuchcases,weproposetousesymbolicexecutionalongthepathprogramasanoracle.ThepowerofsymbolicexecutionliesintheabilityoffastSMTsolverstoreasonaboutthefeasibilityoflargeformulaeintheoriessuchaslineararithmeticorbit-vectors,andincaseofinfeasibilitytoquicklyextractminimalunsatis.ablecores.Notethatstandardsymbolicexecutioningeneralcannotreasonaboutallpathsthroughaprogramloop.Therefore,weuseanover\u00adapproximate \nsymbolic execution (describedbelow).Ifitsucceedsinprovingtheproperty,wedirectlyobtainasuf.cientset.Ifitfails,thenweresorttoamoregeneralprooftechniquelikeabstractinterpretation. \nAnover-approximatesymbolicexecutionofthepathprogramp constructsaformula.p inasuitablelogicaltheory.Thisformulaisderivedbycomposingthetransitionrelationsalongtheedgesinthepathprogramp.Assignmentsbelongingtoloopsaretreatedasassigninganon-deterministicvalue,andconditionspresentinloopsaretreatedasnondeterministicchoices.Finally,fortheproperty(n, \n.),weassert\u00ac. asaconditionencounteredatthenoden. Theorem 3.3. If the over-approximate symbolic execution \nof a path program p yields an unsatis.able formula .p, then any exe\u00adcution of the path program p satis.es \n(n, .). Example 3.5. Symbolic execution of the .rst path program p1 : 1 . 3 . 4 . 6 . 7 .{10, 11, 12, \n13} * . 14 . 15, shown in Fig. 2(A) (originally from Ex.2.1) yields the following formula 3Alternatively,theconsecutionpost(\u00b5(a),e) \n|= \u00b5(b) shouldcease toholdiftheassignmentismadenon-deterministic.  obtained by composing the transition \nrelations of the individual edges: 23 .1,3 :(bLen0 =0 . pLen1 = 1 . pLen1 = pLen0) . .3,4 :(p0 =0) . \n.4,6 :(pLen1 = -1) . 67 67 .6,7 :(mode0 =0) . .7,10 :(i0 =0) . 4 5 .10,14 :(L > pLen1). .14,15 :(p0 . \n =0 . bLen1 > pLen1) The subscripts on the variables occurring in the transitions are derived from an \nSSA-form of the program . or using a use-def chain analysis. Note that .. is infeasible, proving that \nthe path . satis.es .. Let. : .1 .\u00b7\u00b7\u00b7 . .m beaninfeasibleformulaobtainedfromapathprogramp.Furthermore,letR \n= {.i1 ,...,.ik } beanunsatis.able core fortheformula. andS = {ei1 ,...,eik } bethesubsetofedgesthatyieldthetransitionsinthesetR.ThesetS \nformsasuf.cientsetfortheinfeasibilityofp. Example 3.6. Returning to Ex.3.5, the unsatis.able core consists \nof the transition relation .3,4 along with .14,15. This yields the suf.cient set S = {3 . 4, 14 . 15}. \n 3.4 Interference Analysis Thusfar,wehavefocusedontheanalysisofasinglepathpro\u00adgram.Interferenceanalysisextendsthelearningduetosuf.cientedgesextractedfromagivenpathprogram,toconsiderotherpathprograms.Thus,interferenceanalysisoperatesontheentireCFG. \nForapathprogramp,thesuf.cientsetSp . Ep representsedgesrelevanttotheproofofthepropertyalongp.UsingSp,weseektocharacterizethesetofpathprogramsinthe \noriginal CFG thatarealsoguaranteedtosatisfytheproperty. andareprovenbythesamesuf.cientset.Todoso,wealsoneedtoreasonaboutpotentiallyinterfering \nassignments intheCFG.ThiscorrespondstothecomponentofExtractSupportSet fromAlgo.1thatyieldsIp. Example \n3.7. In Ex.3.4, the process of local repair over the path program p2 in Fig. 2(C) yields a suf.cient \nset S2 : {1 . 3, 10 . 14, 10 . 11, 12 . 13, 13 . 10, 14 . 15} . The path p1 shown in Fig. 2(A) traverses \nall of the edges in the set S2, yet the proof of the property obtained along the suf.cient set S2 does \nnot apply for this path. The reason is that the assignment pLen := -1 along the edge 4 . 6 invalidates \nthe value of the variable pLen that is initially de.ned in 1 . 3. Therefore the proof in Ex.3.4 does \nnot apply to this path. This assignment disrupts the critical use-defchain between edges 1 . 3 where \nthe variable pLen is de.ned and 10 . 11, where it is used. Our approach is to identify a set of interference \nedges that can invalidate the use-def chains in the suf.cient set. Def. 3.3 (InterferingEdge).An assignment \nedge e . Ep assign\u00ading variable x is an interferenceedgefor a suf.cient set Sp . Ep iff there exist edges \ne1,e2 . Sp wherein e1 de.nes x, e2 uses x, and a path of the form e1 ee2 exists in the original CFG. \nReturningtoEx.3.7,weverifythattheedge4 . 6 interfereswiththedef-usechaine1 :1 . 3 andtheconditione2 :10 \n. 11.Givenapathprogramp andthesuf.cientedgesSp,asetofinterferingedgesIp canbecomputedusingause-defchaincomputationandacontrolreachabilityanalysisontheoriginalCFG.Inprinciple,a.nersemanticcriterionforinterferencecanbeformulatedthatcheckswhetheraninterferingedgepreservestheinvariantsrelatedtothesuf.cientset. \nHowever,inourimplementation,thesyntacticcriterionpre\u00adsentedhereisusedduetoitssimplicity. Theorem 3.4. \nIf a property .: (n, .) holds on a path program p then it holds on any path program . : n0 n visiting \nalltheedgesin Sp and noneoftheedgesin Ip. 3.5 Blocking Clauses WeapplytheoraclesdescribedinSecs.3.3and3.2,insequence,toapathprogramp \ninanattempttoobtainasuf.cientsetSp.Iftheoracleobtainsaproof,thentheinterferenceanalysisdescribedinSec.3.4yieldsasuf.cient-interferencepair(Sp,Ip) \nconsistingofthesuf.cientedgesandtheircorrespondinginterferenceedges.WenowdescribeBlockingClause fromAlgo.1thatappliesthesesetstoruleoutotherpathswiththesameproofsofcorrectness. \nIngeneral,propositionsinourBooleanencodingdescribepathprogramedges.However,oursuf.cientorinterferenceedgesetsmaycontainedgesinsideloops(asinEx.3.7).Followingourin\u00adterpretationofpathprograms,apathprogramthatvisitstherep\u00adresentativenoden \nofanMSCCalsotraversesalltheedgesinsidetheMSCC.Therefore,forthesakeofconvenience,weintroducea W propositionalformula.e \n: pe = ' pe ' foreveryedge e ' :n .n.ED e occurringinsideanMSCCrepresentedbynoden.Notethatpe canbeusedasapropositionthatmodelsavisittotherepresentativenoden \nwiththeadditionofaBooleanformula.e above,relatingpe totheotherpropositionsinourencoding. WW TheformulaBlockPaths(Sp,Ip): \n\u00acpe . pf , e.Sp f.Ip encodespathsthateither(a)donotvisiteverynodeofSp,or (b)visitsomenodeofIp.Addingthisformulaasablocking \nclause to.. avoidsrevisitingthesamesetofsuf.cientedges.Thisprovidesproof-basedlearningtoavoidtheenumerationofrelatedpathprograms. \n 3.6 Handling Violations WenowdescribehowtohandleviolationsasdepictedinAlgo.1lines8 9.Onecouldhalttheenumerationuponencounteringaviolation,butitmaybedesirabletocontinuethesearchforerrorsthatstemfromadifferentcause.Tothisend,SMPPobtainsapath \nslice foraviolationalongthelinesofJhalaandMajumdar[24].Asaresultofpathslicing,theanalysisobtainsasetSp \n. Ep ofedgesthatcausetheerrorasetIp ofedgesthatmayinterferewiththeuse-defchainsinSp.Ourtreatmentofthepair(Sp,Ip) \nobtainedfromapotentialviolationisidenticaltothatobtainedfromaproofthroughrepairiteration. Theorem 3.5 \n(JhalaandMajumdar[24]).Let Sp,Ip be as com\u00adputed by the path slicing technique. For any path . that visits \nall the nodes in Sp and none of the nodes in Ip, the path . violates the property (n, .) iff p does. \n 3.7 Expanding Loops Apathprogram,correspondingtoacontrolpathintheMSCCdecomposition,treatsloopsmonolithically.Agivenloopisentirelypartofapathprogramwhereinarbitrarilymanyiterationsareconsidered,oralternativelynoiterationsareconsidered.Inthecasewhentheentireprogramconsistsofasinglewhileloop(asisthecasewithcontrolprograms),ourtechniqueisequivalenttorunningtheoracleovertheentireprogram.Thisimprecisioncanberemediedbyunwindingandunrollingagivenloop,sothatourtechniquescanreasonaboutspeci.cpathsintheloop.Furthermore,ourchoiceofanMSCCdecompositionwasintendedtocreateanacyclicgraphrelatedtotheCFG.OurapproachcanbegeneralizedtouseotherschemesforcreatinganacyclicgraphsuchthatthepathsinthisgrapharerelatedtofragmentsintheoriginalCFG. \n  4. Implementation WehaveimplementedourapproachasapartoftheF-Softpro\u00adgramveri.cationplatformforCprograms[21,22].F-SoftchecksCprogramsforbufferover.ows,stringAPIusage,NULLpointerdereferences,user-de.nedtype-stateproperties,memoryleaksandsoon.Foradetaileddescriptionofourmodelingofstructures,pointersandarrays,see[22]. \nF-Soft Framework TheF-Softfront-end.attens structureanduniontypesintosimpletypes,constructsamemorymodelbyprovidingmagicnumberad\u00addressestostoragelocations,andinstrumentstheprogramforprop\u00adertiesbeingchecked.Pointeraliasingandarithmeticarehandledbymodelingtheireffectsoverintegervariablesbasedona.ow\u00adinsensitivepoints-toanalysis. \nExample 4.1. Fig. 3 illustrates the construction of a memory model in F-Soft based on the results of \na points-to analysis. Our model replaces each local variable p in a function f by a variable f : p with \nglobal scope. If f canbe calledinarecursive context then such a variable is treated as a summaryvariable. \nCorresponding to each pointer variable p, we introduce an in\u00adstrumentation variable star(p) to track \nthe contents of its store. The value of star(p) is non-deterministic if p does not point to a valid lo\u00adcation. \nThe expression *p is replaced by its representative star(p). An assignment to the L-value*p is rewritten \ninto an assignment to all the variables x that p can potentially point to. Such an assign\u00adment to x is \nguarded by a condition p == &#38;x that enforces the points-to relationship. Further details and rationale \nare provided elsewhere [21, 22]. TheinitialCFGoftheprogramissimpli.edconsiderablythroughprogramslicingandconstantfolding.Wethenperformaseriesof.owandcontextsensitiveanalysessuchasconstantfolding,intervalanalysis,andvariousnumericaldomainanaly\u00adses.F-Softimplementsmanyabstractdomainsinapartiallypath\u00adsensitiveabstractinterpretationframework[1,30].Theanalysisusesthesedomainsincombinationorinsuccessiontoattempttoproveaproperty,eachrunoftheanalysisreusingtheinvariantsobtainedbythepreviousruns.F-softre-slicestheprogrammodelbasedonthepropertiesprovedbystaticanalysis,reducingitfur\u00adther.Attheendofstaticanalysis,the.nalCFGwithitsunprovenpropertiesisprovidedasaninputtotheSMPPimplementation. \nSMPP Implementation OurimplementationfollowsthedescriptioninAlgorithm1withmodi.cationstoaccommodatefunctioncalls.Thetreatmentoffunctioncallsandreturnsensuresthattheenumeratedpathpro\u00adgramsproperlymatchcallsandreturns;anddifferentpathsinsideafunctioncanbetraversedbyapathprogramuponmultiplevis\u00aditsunderdifferentcallingcontexts.Thisisachievedbycontext \nnumbering thefunctioncallsintheCFG.ThecontextnumberingschemedescribedbyWhaleyandLamisused[32].EachCFGedgee \nthenyieldsmultiplepropositionsp(e, c) basedonthedifferentcallingcontextsc thattheedgemaybevisitedin.Theencodingforincomingedgesatcallsitesandoutgoingedgesatreturnsensurethatenumeratedcallingblockcontextwithareturntotheappropri\u00adatecallsite.Therestoftheencodingremainsunchanged \nRecursivecallsarecurrentlyunwounduptoaspeci.eddepthandthenreplacedbyacalltoafunctionthatreturnsanon\u00addeterministicvalueandhasnon-deterministicside-effectsonvari\u00adablespassedbyreference.Inpractice,thisseemstohaveaminimalimpactonthecheckingofruntimeerrors. \nTheenumeratedpathprogramsare.rstanalyzedusingover\u00adapproximatesymbolicexecutionandthen(ifneeded)bytheab- \nTable 2. LegendforabbreviationsusedinTable3. Abbrv.Remark Blk NumberofblocksatstartofSMPP. Prp Numberofproperties(asserts). \nPrf NumberofProofs. PP tot Numberofpathprogramstotal(estimated). PP enum NumberofpathprogramsenumeratedbySMPP. \nPP Proofs Numberofpathprogramsprovedcorrect. SE SymbolicExecution AI AbstractInterpretation RI RepairIteration \nstractinterpreterandalocalrepairiteration.Currently,thesup\u00adportsetandunsatis.able-corecomputationareperformedusingtheSMTsolverYices[16].Afailuretoproveapropertyiscurrentlyreportedasapotential \nviolation.Inthefuture,weplantointegrateourtechniquewithamodelcheckeroraconcolic execution engineoverpathprogramstoconcretizethesepotentialviolations. \n 5. Experimental Evaluation Weconductedexperimentstoaddressthefollowing:(a)howef\u00ad.cientlySMPPcanverifycommonsafetypropertiesthatrequirepath-sensitivereasoning,(b)theeffectivenessofproof-basedlearn\u00adingforprovingmanyprogram-pathssafewiththeanalysisofafew,and(c)thepowerandef.ciencyofSMPPagainstanotherpath\u00adsensitiveanalysis,predicateabstraction. \nFig.4presentsourexperimentalsetupusingtheF-Softframe\u00adwork.TheexperimentsconsistofprocessingthegivenCpro\u00adgramthroughourfront-endwhichincludespath-insensitive,.ow\u00adandcontext-sensitiveabstractinterpretationthroughnumericaldo\u00admainssuchasconstants,intervals,andoctagons.Propertiesprovedusingtheseanalysesareremoved \nfromtheCFG,followedbyre\u00adslicingandsimpli.cation.ThusallpropertiesonwhichSMPPistestedrequiresomedegreeofpath-sensitivereasoningtovalidate. \nTable3presentsourexperimentalresultsontheZitseretal.benchmarks[34].Theseprogramsconsistofimportantbufferover\u00ad.owbugsfoundincommonlyusedprogramssuchaswu-ftpd,bind,nslookup \nandsoon,alongwiththe.xesmadetothem.Note,however,thatF-Softautomaticallyinstrumentsmanymoreproperties,ascomparedtothesinglelineofcodethatismarkedinthesebenchmarks.TheabbreviationsusedinTable3areexpandedinTable2.Table3reportsthesizeofeachprogramatthestartofSMPP,numberofproperties,thenumberofproofs(peroracle),andthetimetaken(total,percentageforstagesoftheanalysis).Eachpropertythatisnotaproofisreportedasapotentialwitnessalongwithaslicedpathprogram.Forsomethesepotentialwitnesses,thesymbolicexecutionreportedapathprogramslicethatdidnotin\u00adcludealoop,indicatingaconcretewitness.Theresultsdemon\u00adstratethatSMPPcanproveasigni.cantnumberofpath-sensitivepropertiesandidentifypotentialwitnessesef.ciently.Notethatsymbolicexecutionissuccessfulinprovingamajorityofthepathsef.ciently,andthatabstractinterpretationiskeyforasigni.cantportionofpropertiesthatinvolveloops. \nInTable3,theCol.Path Programs (Tot) presentsanestimateofthetotalnumberofpathprograms,estimatedusingSAT(inmanycases,theestimatortimedoutafteranhour)whilePath \nPrograms (Enum) presentsthenumberactuallyenumeratedbySMPP.Thedifferencedemonstratestheeffectivenessofproof-basedlearning. \nTable4comparestheperformanceofSMPPagainstBlastv2.5[3].Tofocusontheanalyses(ratherthanondifferencesinprogrammodeling),weprintedtheCFGonwhichSMPPisappliedasaCprogram,usinggotostatementstoenforcecontrol.ow.Thevariablesinthisprogramareallintegers(generatedaftertheF-Soft \n Points-ToGraph  Figure 3. Asimpli.edillustrationofF-Soft smemorymodelingforaprogramwithpointers. \nTable 3. ExperimentalEvaluationontheZitseretal.BenchmarksonCFGobtainedafterinitialstaticanalysis.Thepathcountertimeoutwassetto1hr.Table2explainstheabbreviationsusedhere. \nNameLOCOrig.SENDMAILs2-ok1151s2-bad1132s4-ok776s4-bad713s5-ok837s5-bad810s6-ok317s6-bad315s7-ok1824s7-bad1816 \nBlk(tot)74472126328417918212112113571347 Prp(tot)60581230141788174170 Prf20216151316335994 Path-ProgramsTotalEnum>1.2M204>1.2M259121230301421728888>.5M415>.6M412 \nPPProofsTotSEAI%%131802019586146010015010011000110003010030100224928271928 Times(seconds)TotSEAIRIsec%%%136.7676521139.171077310.98295130.2919600.540000.5400013.18098014.910980132.42548013524530 \n  BINDb1-okb1-badb2-okb2-badWU-FTPDf1-okf1-badf2-okf2-bad 21772117270626886285621208936 670662957955144178119114 \n55548080132198 10911114954 >.4M>.4M>.4M>.4M18848156372175 21418128528928711714 16813521622014521310 969597977192100100 \n453329800 179.6171.79282.23230.1411.8125.140.250.19 992333236872 8586695988912016 00008400  Figure 4. \nExperimentalsetup:Front-endincludespath-insensitiveanalyses,followedbySMPP. front-endprocessofinstrumentation,memorymodeling,simpli.-targetingasingleproperty,recomputingtheSATencodingsandcations,slicingandstaticpropertyproofs).Blasthadtobeinvokedthesuf.cientsetsfromscratch.ThecomparisoninTable4showsmultipletimesonthesameprogram,eachinstancetargetingadif-thatwhileBlastcanprovemorepropertiesthanSMPPinsomeferentproperty.Thiswasneededtoavoidthedefaultaggregationofcases,ourcoarsercontrol-basedabstractioncanbemuchfasterandpropertiesinBlastwhichfailedwitherrorsinmanyinstances.For.ndsmoreviolationsinmanycases.Amajorityofthefailuresbyfaircomparison,weranSMPPmultipletimeswitheachinstanceBlastresultedfromanexplosioninthenumberofpredicateson \nvoidallocM (int**ptr,intn){ 1:ASSERT(ptr); 2:if(*ptr ==NULL) 3:*ptr =malloc(n *sizeof(int)); 4:ASSERT(*ptr); \n} voidmain(){ 6:inta [100],*b =0; 7:if(rand()) 8:b =&#38;a; 9:allocM(&#38;b,100);11:ASSERT(LEN(b)==100);global \nintalloc@3;voidallocM (int**ptr,intn){ 1:ASSERT(ptr); 2:if(star(ptr) ==0){ 3:*ptr =malloc(n *sizeof(int));3-0:star(ptr) \n=alloc@3;3-1:LEN(star(ptr)) =n;3-2:if(ptr ==&#38;main : b ){ 3-4: main : b =alloc@3; 3-5: LEN(main : \nb) =n; 3-6: }all oc@3 +=n; } 4:ASSERT(*ptr);  Table 4. ComparisonofSMPPwithBLAST.Prp:numberofprop\u00aderties(asserts),Wit:numberofconcretewitnesses,andFail: \nBlastfailures.NotethatSMPPisrunmultipletimes(onceforeachprop\u00aderty)forfairercomparison.  Name Prp SMPP \n BLAST PrfTimePrfWitFail  Time s2-ok 60 20 2m10s 0 25 2h7m s2-bad 58 21 2m25s 0 23 1h50m s4-ok 12 \n6 0m11s 11 1 0 0h1.3m s4-bad 30 15 0m31s 17 1 12 2h8m s5-ok 14 13 0m00.5s 6 0 8 0h55m s5-bad 16 0m00.5s \n9 0 8 1h32m s6-ok 3 0m14s 4 0 4 0h17m s6-bad 3 0m15s 4 0 4 0h17m s7-ok 59 28m 135 1 38 17h22m s7-bad \n94 27m 134 1 35 15h55m   loops(termed Gremlins ).Ourabstractinterpretationfollowedbyaproof-basedlearningseemstobeadequateformanysuchcases. \nAnalysis of Larger Benchmarks. Table5summarizesourexper\u00adimentalresultsonlargercasestudies.Theexperimentalsetupre\u00admainsthesameasinFig.4.Programsourcesweredownloadedfromtheinternetand.rstanalyzedusingourtoolSpecTackle[22],whichinferslikelypreconditionsandpost-conditionscorrespond\u00adingtopointerandarrayaccessesinthefunctions4.F-Soft(withSMPP)istheninvokedforeachfunctionintheprogram.Thepre\u00adconditionsfortheentryfunctionsareassumed,whereastheprecon\u00additionsforcalledfunctionsareasserted.InordertocontroltheCFGsize,callstofunctionsnotreachablefromtheentryfunctionwithinacontextofdepth4 \nwerereplacedbynon-deterministicchoice.Table5showstheresults.TheSMPPapproachisinvokedonlyinthosecaseswherethereareunresolvedpropertiesfromtheini\u00adtialpath-insensitiveanalyses.Thisaccountsforroughly40% \nofthefunctions,onaverage.ThetotaltimetakenbytheSMPPapproachisofthesameorderasthattakenbytheinitialmodelconstructionandstaticanalysisphases.Inalmostallcases,theoverallanalysis(initial+SMPP)terminateswithinthegiventimelimitof45 \nmin\u00adutes.NotethatSMPPdetectsasigni.cantnumberofextraproofs,overandabovesophisticated.ow-andcontext-sensitivepolyhedralabstractinterpretationtechniques.WedidnotrunBlastontheselargercasestudies,asitwouldhaverequiredsigni.cantmanualeffortininstrumentingtheCFGsgeneratedbyourfront-end. \n 6. Related Work Abstraction Re.nement .Ourtechnique.tsbroadlyintotheab\u00adstractionre.nementparadigm.TheBooleanformulaerepresentingallunexploredcontrolpathsisacoarsecontrol-.owabstraction.Thisabstractionissuccessivelyre.nedbyeliminatingthepathpro\u00adgramsprovedcorrect. \nThemaindifferencesfromtypicalabstractionre.nementap\u00adproachesare:(a)Ourabstractionisbasedsolelyoncontrollo\u00adcations.Thisisaveryinexpensiveabstractiontocompute,defer\u00adringtheheavierworktoanoracleforcheckingcorrectnessofapathprogramcorrespondingtotheenumeratedcontrolpath.Otherapproachestypicallyuseanexplicitrepresentationofthecontrol.owwithdatapredicates,e.g.Booleanprograms[2,3].Suchab\u00adstractionsaremoreexpensivetocomputethanourabstractions.(b)Ratherthanare.nementloopoverfalseerrortraces(counterexam\u00adples)[2,8],ourre.nementloopoperatesoverpathprogramsasso\u00adciatedwiththeenumeratedcontrolpaths.(c)Ourapproachavoids \n4Thesebenchmarksalongwiththeinferredpreconditionsareavailableuponrequest. divergences onloopsintheprogram.ThisisbecauseweenumerateoveranacyclicMSCC-basedgraphderivedfromtheCFG,whereineachcontrolpathcorrespondstoapathprogramthatcanpoten\u00adtiallycapturein.nitelymanycontrolpathsontheoriginalCFG.Itiswellknownthateffectivehandlingofloopsisastumblingblockformanyabstractionre.nementtechniques.Abstractinterpretationtechniquesusingwideninghavebeenwell-optimizedtoprovecom\u00admontypesofrun-timeproperties,eveninthepresenceofloops.(d)Thedecompositionoftheoverallprogramintomultiplepathpro\u00adgramsallows.exibilityinchoosingasuitableoracleforindividualsub-problems.Inourimplementation,weusesymbolicexecutiontohandlepathprogramswithoutloops,andabstractinterpretationtohandlepathprogramswithloops.Otheroracles,suchaspredi\u00adcateabstractionre.nement,canalsobeused. \nOurworkiscloselyrelatedtorecentworkbyHeizmannetal[20].Theyproposeanabstractionre.nementschemefortrace \nabstractions.Anover-approximationofthesetofpossibletracesissuccessivelyre.nedbymeansofaninterpolant automaton \nthatrecognizesasetofinfeasibletraces.TheinterpolantautomataarealsoderivedfromprooftechniquesthatcangenerateFloyd-Hoarestyleinductiveinvariants.Themaindifferencesinclude:(a)ourtechniqueoperatesonpathprogramsasopposedtoerrortraces; \n(b)weemployasymbolicencodingusingSATtokeeptrackofunexploredpathprograms,asopposedtoanexplicitrepresentation. \nLazyabstractionwithinterpolantsbyMcMillan[26]providesalazyschemetore.neanabstractmodelondemand,byutilizinginterpolantsderivedfromrefutingpathsintheprogram.Thisworkalsoavoidsthecostofanexpensiveabstraction.However,there.nementisdrivenbyerrortraces,thecontrol.owishandledexplicitly,anddetailsofproof-basedlearningaredifferentfromourtechnique. \nThenotionsofpathprogramsinourworkaredirectlyinspiredbytheworkofBeyeretal.[4].Thatworkalsoemployspathpro\u00adgramsandinvariantstoavoidloopdivergences.Incontrast,(a)weuseBoolean \nformulae abstractingjustthecontrol.ow,asop\u00adposedtopredicate abstraction (Booleanprograms),and(b)were\u00ad.nethroughblocking \nclauses ratherthanusinginvariants as pred\u00adicates.Usingblockingclausesforre.nementispotentiallymorescalablethanusinginvariantsaspredicates.First,invariantgener\u00adationtechniquestypicallygeneratealargesetofinvariants,ama\u00adjorityofwhichareredundant.Beyeretal.[4]donotattempttominimizethesetofinvariants.Ourworkprovidesthisreductionbymeansofthelocal \nrepair iteration discussedinSection3.Sec\u00adond,eachpredicateaddedcanpotentiallydoublethecomplexityofmodelcheckinganabstraction,whereasourcon.ictclausesaresmallandseemtohaveverylittleimpactonthesizeoftheBooleanformulaabstraction.Anotherapproachistouseabstractinterpreta\u00adtiontoderiveusefulprograminvariantsasapre-processingstep,toavoidexpensivere.nementiterationsoverloops[23]. \nBounded model checking of programs. Ef.cientSAT-basedtech\u00adniqueshavebeenusedforboundedmodelchecking(BMC)[5]ofprogramsintoolssuchasCBMC[7],F-Soft[21],andforscalablesummary-basedanalysisinSaturn[33].Thesetechniquesautomat\u00adicallyutilizeSAT-basedcon.ictanalysisandlearningforpruningthesearchspace.However,theysufferinthepresenceofloops,whichrequiredeepunwindingsthatresultinlargeSATproblems.Furthermore,BMCtypicallyhandlesallpathsuptosomeboundedlengthasasinglemonolithicproblem.Incontrast,weencodeonlythecontrolpathsasaSATformula,whichismuchsmallerthanatypicalBMCformulathatencodesunwindingsofaprogram. \nAbstract interpretation and path-sensitive analysis. Otherap\u00adproachestopathsensitiveanalysisincludeESP \n[14],trace parti\u00adtioning [25],elaborations [31],amongstmanyothers.Thesetech\u00adniquesemployheuristicstocontrolthetrade-offbetweenperform\u00ad \n Table 5. ResultsonLargerOpen-SourceCase-Studies Name KLOC #Fun #Prec Front-End SMPP Blk Time Prp Prf \n#Fun Blk #PP Prf. Time avg sec tot tot tot timeout avg tot tot tot,sec thttpd-2.25b 14.7 172 1901 263 \n5162 12161 11069 68 1 199 1622 512 1393 ssh-server-4.1 30.1 313 2047 190 7755 42773 41182 127 5 120 1681 \n564 1197 xvidcore 63.9 350 6127 520 13259 17219 12020 190 6 331 5220 2090 15728 ingajoinoperationoralogicaldisjunctionatthemergepointsintheCFG.However,thejoinvs.disjunctionchoiceisinferred \ninourSMPPschemebythedisjunction-baseddecompositionovercontrolpaths.  7. Conclusion WehavepresentedtheSatis.abilityModuloPathPrograms(SMPP)approachtoprogramanalysis,whichliftstothearchitectureofSMTsolverstopath-sensitiveprogramanalysis.Wehavedemon\u00adstratedittobeeffectiveinanalyzingreal-worldprograms. \n References [1]Gogul Balakrishnan,SriramSankaranarayanan,FranjoIvancic,OuWei,andAartiGupta.SLR:Path-sensitiveanalysisthroughinfeasible-pathdetectionandsyntacticlanguagere.nement.InSAS,volume5079ofLNCS,pages238 \n254,2008. [2]ThomasBallandSriramK.Rajamani. Theslamtoolkit.InCAV,volume2102ofLNCS,pages260 264,2001. \n[3]DirkBeyer,ThomasA.Henzinger,RanjitJhala,andRupakMajumdar.Thesoftwaremodelcheckerblast.STTT,9(5-6):505 \n525,2007. [4]DirkBeyer,ThomasA.Henzinger,RupakMajumdar,andAndreyRybalchenko.Pathinvariants.InPLDI,pages300 \n309.ACM,2007. [5]ArminBiere,AlessandroCimatti,EdmundClarke,andYunshanZhu.SymbolicmodelcheckingwithoutBDDs.InTACAS,volume1579ofLNCS,pages193 \n207,1999. [6]AaronR.BradleyandZoharManna. Property-directedincrementalinvariantgeneration.Formal Asp. \nComput.,20(4-5):379 405,2008. [7]EdmundClarke, DanielKroening,andFlavioLerda.AtoolforcheckingANSI-Cprograms.InTACAS,volume2988ofLNCS,2004. \n[8]EdmundM.Clarke,OrnaGrumberg,SomeshJha,YuanLu,andHel\u00admutVeith.Counterexample-guidedabstractionre.nement.InCAV \n00,pages154 169.Springer,2000. [9]ThomanH.Cormen,CharlesE. Leiserson,andRonaldL.Rivest.Introduction to \nAlgorithms.MITPress,1992. [10]P.CousotandR.Cousot.Staticdeterminationofdynamicpropertiesofprograms.InProc. \nISOP 76,pages106 130.Dunod,Paris,France,1976. [11]P.CousotandR. Cousot.ComparingtheGaloisconnectionandwidening/narrowingapproachestoAbstractinterpretation,invitedpa\u00adper.InPLILP \n92,volume631ofLNCS,pages269 295.Springer,1992. [12]PatrickCousotandRadhiaCousot. AbstractInterpretation:Auni\u00ad.edlatticemodelforstaticanalysisofprogramsbyconstructionorapproximationof.xpoints.InPOPL \n77,pages238 252,1977. [13]PatrickCousotandNicholasHalbwachs. Automaticdiscoveryoflinearrestraintsamongthevariablesofaprogram.InPOPL \n78,pages84 97,January1978. [14]ManuvirDas,SorinLerner,andMarkSeigle. Esp:Path-sensitiveprogramveri.cationinpolynomialtime.InPLDI,pages57 \n68,2002. [15]LeonardoMendonc\u00b8adeMouraandNikolajBj\u00f8rner.Z3:Anef.cientSMTsolver.InTACAS,volume4963ofLNCS,pages337 \n340.Springer,2008. [16]BrunoDutertreandLeonardoMendonc\u00b8adeMoura.Afastlinear\u00adarithmeticsolverfordpll(t).InCAV,volume4144ofLNCS,pages81 \n94.Springer,2006. [17]SussaneGrafandHasanSaidi.ConstructionofabstractstategraphswithPVS.InCAV 97,volume1254ofLNCS,pages72 \n83,1997. [18]SumitGulwani,SaurabhSrivastava,andRamarathnamVenkatesan.Programanalysisasconstraintsolving.InPLDI,pages281 \n292,2008. [19]AshutoshGuptaandAndreyRybalchenko. InvGen:Anef.cientinvariantgenerator.InCAV,volume5643ofLNCS,pages634 \n640,2009. [20]MatthiasHeizmann,JochenHoenicke,andAndreasPodelski.Re.ne\u00admentoftraceabstraction.InStatic \nAnalysis Symposium (SAS 09),volume5673ofLNCS,pages69 85.Springer,2009. [21]FranjoIvancic,ZijiangYang,MalayK. \nGanai,AartiGupta,IlyaShlyakhter,andPranavAshar.F-soft:Softwareveri.cationplatform.InCAV,volume3576ofLNCS,pages301 \n306.Springer,2005. [22]FranjoIvan.ci\u00b4c,SriramSankaranarayanan,IlyaShlyakhter,andAartiGupta.Bufferover.owanalysisusingenvironmentre.nement.Draft(2009),AvailableUponRequest. \n[23]HimanshuJain,FranjoIvan.ci\u00b4c,AartiGupta,IlyaShlyakhter,andChaoWang.Usingstaticallycomputedinvariantsinsidethepredicateabstractionandre.nementloop.InCAV \n06,pages137 151,2006. [24]RanjitJhalaandRupakMajumdar. Pathslicing.InPLDI,pages38 47,2005. [25]LaurentMauborgneandXavierRival. \nTracepartitioninginabstractinterpretationbasedstaticanalyzers.InESOP 05,volume3444ofLNCS,pages5 20,2005. \n[26]KennethL.McMillan.Lazyabstractionwithinterpolants.InCAV 06,volume4144ofLNCS,pages123 136,2006. [27]AntoineMin\u00b4e.Anewnumericalabstractdomainbasedondifference\u00adboundmatrices.InPADO \nII,volume2053ofLNCS,pages155 172.Springer,May2001. [28]MatthewW.Moskewicz,ConorF.Madigan,YingZhao,LintaoZhang,andSharadMalik.Chaff:Engineeringanef.cientsatsolver.InDAC,pages530 \n535.ACM,2001. [29]RobertNieuwenhuis,AlbertOliveras,andCesareTinelli. SolvingSATandSATmodulotheories:Fromanabstractdavis \nputnam logemann lovelandproceduretoDPLL(T).J. ACM,53(6):937 977,2006. [30]SriramSankaranarayanan,FranjoIvan.ci\u00b4c,andAartiGupta.Programanalysisusingsymbolicranges.InSAS,volume4634ofLNCS,pages366 \n383,2007. [31]SriramSankaranarayanan,FranjoIvancic,IlyaShlyakhter,andAartiGupta.Staticanalysisindisjunctivenumericaldomains.InSAS,volume4134ofLNCS,pages3 \n17.Springer,2006. [32]JohnWhaleyandMonicaS.Lam. Cloning-basedcontext-sensitivepointeranalysisusingbinarydecisiondiagrams.InPLDI \n04.ACMPress,June2004. [33]YichenXieandAlexAiken. Saturn:Ascalableframeworkforerrordetectionusingbooleansatis.ability.ACM \nTrans. Program. Lang. Syst.,29(3),2007. [34]MishaZitser,RichardLippmann,andTimLeek.Testingstaticanaly\u00adsistoolsusingexploitablebufferover.owsfromopensourcecode.InProc. \nSIGSoft/FSE 04,pages97 106.ACM,2004.  \n\t\t\t", "proc_id": "1706299", "abstract": "<p>Path-sensitivity is often a crucial requirement for verifying safety properties of programs. As it is infeasible to enumerate and analyze each path individually, analyses compromise by soundly merging information about executions along multiple paths. However, this frequently results in a loss of precision. We present a program analysis technique that we call <i>Satisfiability Modulo Path Programs </i> (SMPP), based on a path-based decomposition of a program. It is inspired by insights that have driven the development of modern SMT(Satisfiability Modulo Theory) solvers. SMPP symbolically enumerates path programs using a SAT formula over control edges in the program. Each enumerated path program is verified using an oracle, such as abstract interpretation or symbolic execution, to either find a proof of correctness or report a potential violation. If a proof is found, then SMPP extracts a sufficient set of control edges and corresponding interference edges, as a form of proof-based learning. Blocking clauses derived from these edges are added back to the SAT formula to avoid enumeration of other path programs guaranteed to be correct, thereby improving performance and scalability. We have applied SMPP in the F-Soft program verification framework, to verify properties of real-world C programs that require path-sensitive reasoning. Our results indicate that the precision from analyzing individual path programs, combined with their efficient enumeration by SMPP, can prove properties as well as indicate potential violations in the large.</p>", "authors": [{"name": "William R. Harris", "author_profile_id": "81100116515", "affiliation": "University of Wisconsin, Madison, WI, USA", "person_id": "P1911042", "email_address": "", "orcid_id": ""}, {"name": "Sriram Sankaranarayanan", "author_profile_id": "81100300829", "affiliation": "University of Colorado, Boulder, CO, USA", "person_id": "P1911043", "email_address": "", "orcid_id": ""}, {"name": "Franjo Ivan&#269;i&#263;", "author_profile_id": "81339506649", "affiliation": "NEC Laboratories America, Princeton, NJ, USA", "person_id": "P1911044", "email_address": "", "orcid_id": ""}, {"name": "Aarti Gupta", "author_profile_id": "81350588778", "affiliation": "NEC Laboratories America, Princeton, NJ, USA", "person_id": "P1911045", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706309", "year": "2010", "article_id": "1706309", "conference": "POPL", "title": "Program analysis via satisfiability modulo path programs", "url": "http://dl.acm.org/citation.cfm?id=1706309"}