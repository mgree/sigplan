{"article_publication_date": "01-17-2010", "fulltext": "\n Monads in Action Andrzej Filinski DIKU, University of Copenhagen andrzej@diku.dk Abstract In functional \nprogramming, monadic characterizations of computa\u00adtional effects are normally understood denotationally: \ntheydescribe how an effectful program can be systematically expanded or trans\u00adlated into a larger, pure \nprogram, which can then be evaluated ac\u00adcording to an effect-free semantics. Anyeffect-speci.c operations \nexpressible in the monad are also given purely functional de.ni\u00adtions,but these de.nitions areonly directlyexecutableinthe \ncon\u00adtext of an already translated program. This approach thus takes an inherently Church-style view of \neffects: the nominal meaning of every effectful term in the program depends crucially on its type. We \npresent herea complementary, operational viewof monadic effects, in which an effect de.nition directly \ninduces an imper\u00adative behavior of the new operations expressible in the monad. This behavior is formalized \nas additional operational rules for only the new constructs; it does not require any structural changes \nto the evaluation judgment. Speci.cally, we give a small-step opera\u00adtional semantics of a prototypical \nfunctional language supporting programmer-de.nable, layered effects, and show how this seman\u00adtics naturally \nsupports reasoningbyfamiliar syntactic techniques, such as showing soundness of a Curry-style effect-type \nsystem by the progress+preservation method. Categories and Subject Descriptors F.3.2[Logics and Meanings \nof Programs]:Semantics of Programming Languages Operational semantics; F.3.3[Logics and Meanings of Programs]: \nStudies of Program Constructs Control primitives,Type structure GeneralTerms Languages, Theory Keywords \nMonads, Computational Effects, Modular Semantics 1. Introduction Since their introduction by Moggi [12] \nand popularization by Wadler [20], monads havebecome an important tool for structuring pure functional \nprograms. Conceptually imperative computations, using featuressuchasexceptionsor mutablestate,canbe uniformly \nexpressed by splitting the program into a main program written in monadic style , and a prelude of effect \nde.nitions, each given by a monad and some associated operations. Conceptually, the effect de.nitions \nare then inlined into the main program,givinga purely functional program that canbeeval\u00aduated using a \nstandard, pure semantics. This approach takes an in- Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 10, January 17 23, 2010, Madrid, Spain. Copyright c &#38;#169; \n2010ACM 978-1-60558-479-9/10/01... $10.00 herently Church-style view of effects: the meaning of a term \nde\u00adpends fundamentally on its monadic type, since thattype (possibly reconstructed using overloading \nresolution or similar) is used to guide the expansion. In ML-like languages, one can of course use such \nan approach as well,butit seems less natural. Rather,programmers tendto think ofa .xed collectionof computationaleffects \nas beingbuilt into the language,but possibly being usedin restrictedways. Thatis, rather than building \nup new behaviors, effect-type systems aim to clas\u00adsify patterns of existing behavior, such as whether \na subterm may raiseaparticularexception,or accesspartofthe store.In particular, the view is Curry-style: \ntypes form a (necessarily conservative) ap\u00adproximation of the intrinsic operational behavior of untyped \nterms. Monadic re.ection [4] attempts to bridge these two views: from atranslational speci.cationofacollectionofeffectsin \ntermsoflay\u00adered monads, it constructs an ef.cient imperative implementation based on native effects in \nthe language, namely low-level primi\u00adtives for control and state manipulation. That is, the program can \nbe thought of and analyzed in terms of its de.nitional expansion intoa pure one,but the actualexecution \nhappensby an embedding intoa languagewitha.xed collectionofeffectsand associatedop\u00aderational semantics. \nFor example, consider the prototypical effect of exceptions. Given a type exn of exception names, even \nin the absence of dedicated syntax, we can make available the essential exception\u00adbehaviors in the form \nof two procedures: ex raise : exn . a exEE try : (1 . a) . (exn . a) . aE .{ , ex} (Ignore for the moment \nthe annotations on the arrows.) Operationally, raise e signals the exception e, while try th evaluates \nthe protected thunk t with handler h: if t () returns a normal, a-typed result a, that a will also be \nthe result of the try; but if evaluation of the thunk causes an exceptione to be signaled, thenevaluation \nof t () is abandoned, he isevaluated instead, and its result (possibly another raised exception) becomes \nthe .nal result of the try. The effect annotations summarize this behavior. An annotated E arrow type \nt . t' represents a function from t to t' with poten\u00adtial E-effects. Here indicatesa pure computation, \ni.e., with at most divergence as an effect, while ex indicates a computation that may raise exceptions \nin addition to diverging. Unannotated function ar\u00adrows represent manifestly total functions, with no \neffects at all. In the example, raise evidently has ex-effects, whereas the type of try says that, even \nthough the protected expression may signal excep\u00adtions, the whole try-expression will not, unless theyare \nsignaledby the handler. Howcan we formalize this intuitivedescription of the semantics of exceptions? \nIn the monadic approach, we model a computation with exception-effects using a monad type Ta, de.ned \nby Ta = 1 . (a + exn)  That is, an ex-computation of a value of type a is a -computation returning either \na or exn. The associated term components can be de.ned as follows: unit : a . Ta unit = .a..(). ' inl \na bind : Ta . (a . T\u00df) . T\u00df bind = .t..f..().let s = t () in case s of inl a.f a () inr e. 'inr e (We \nwrite ' M to emphasize the normally implicit coercion of a trivial computation M into a potentially effectful \none.) Amonadic re.ection is then a pair of functions witnessing the isomorphism between the original \nopaque, imperative view of exceptions, and the above transparent, declarative one: ex re.ectex : Ta . \n(1 . a) ex reifyex : (1 . a) . Ta (Wewritere.ect asatotal function returningathunk,to emphasize the symmetry \nwith reify.) Using those, we can de.ne the actual exception operations as follows: raise = .e. re.ectex(.(). \n' inr e) () try = .t..h. let s =(reifyex t) () in case s of inl a. ' a inr e. h e That is, raise e constructs \na transparent representation of a raised exception, and re.ects it as an ex-computation, while try rei.es \nthe protected ex-computation into a sum-returning pure one, runs it, and splits into cases on the result. \nFor example, ifexn = string, we can then write a program like try (.().3+ raise \"foo\") (.e. if e = \"foo\" \nthen 4 else 5) or, with explicit computation-sequencing: try (.().let r = raise \"foo\" in ' (3 + r)) (.e.if \ne = \"foo\" then ' 4 else ' 5) Tocomputethemeaningofsuchaprogram accordingtothe de.ned semantics of exceptions, \nwe can expand the de.nitions of raise/try from above, monad-translate the entire program (i.e.. transform \nrelevant lets into binds and '-s into units), and .nally replace re.ect and reify by identity functions. \nThen the resulting program wouldbewell typed,andevaluateto 4, using only -computations. Note, however, \nthat the monad translation needs the type infor\u00admation: the let and ' in the .rst line of the main program \nshould be transformed, but the ones in unit, bind, and raise should not, because they only sequence -computations. \nEven more subtly, whether the ' in try should be transformed or not depends on which type instance we \nare using try at: in the sample program, the han\u00addler h itself was pure, so the result from try should \nnot be tagged; but if we had replaced the ' 5 with raise e (i.e., taking E = ex in the type of try), \nthe successful result a from try would need to be explicitly tagged as non-exceptional. Monadic re.ection \nand rei.cation are thus easy to understand from theChurch perspective: as partof the conceptualexpansion \nof the effectful program into a pure, monadic-style one, theyactu\u00adally disappear entirely; their function \nis merely to mark the bound\u00adaries between parts of the program being translated using different monads. \nAnatural question arises,however: couldwe insteadgivethe re\u00ad.ection operators a direct, effectful operational \nsemantics, so that the raise and try de.ned in terms of them would behave in the ex\u00adpectedway? More generally \ncan we derive sucha semantics purely mechanically, using only the de.nitions of the monad components, \nfor an arbitrary monadic effect? And .nally, can we assign mean\u00adings even to terms without effect-annotations, \nrather than requiring a potentially complex type inference/reconstruction phase before execution? In \nthe following, we answer these questions af.rmatively.We show how a simple, small-step operational semantics \nof a proto\u00adtypical functional language (conceptually situated somewhere in the middle between Haskell \nand ML on the purity spectrum) can be incrementally extended with programmer-de.ned monadic ef\u00adfects, \nin the form of additional reduction rules for the new op\u00aderations,but not requiring modi.cations orextensionsofexist\u00ading \nones. Moreover, for severalfamiliarexamples, those automati\u00adcally constructed rules correspondvery directlytoa \nFelleisen-style evaluation-context semantics of the effectful operations. Finally, the construction can \nbe carried out entirely in Curry style: all syntactically correct programs are assigned inherent oper\u00adational \nmeanings, independentofanytype information.However,a descriptivetype system can subsequently be imposed \non them, with soundness (absence of stuck states) shown by the usual syntactic methods.We considera particular \nsuch type system here, though more advanced ones are certainly possible either allowing more programs \nto be typed, or giving more informative types to already typable ones. 2. Metalanguage Though our account \ncould be given in the context of an ML-like CBV language, the development runs signi.cantly smoother \nin the slightly more abstract setting of a computational metalanguage with explicit sequencing of computations \nusing let and value\u00adinclusion, as illustrated in the Introduction. It is hoped that this presentation \nstyle will also provide a neutral ground, familiar to both ML programmers (who can think of it as merely \na systematic convention of naming the results of all subexpressions, akin to A\u00adnormal forms), and to \nHaskell programmers (who can think of it as a variant of do-notation, although with an unusual operational \nsemantics). The metalanguage is essentially the MultiMonadic Metalan\u00adguage (M3L) of [5], with a slightly \nrestricted term syntax, better suitedfor operational interpretations.The languageisstrati.edinto a term \nlevel, in which all the computations are expressed, and a program level, used to also express effect \nde.nitions. In this sec\u00adtion, we introduce the syntax and typing of both levels; in the next one, we \nwill look at the operational semantics. Throughout the pa\u00adper, we will use the convention that shaded \nconstructs, judgments, and rules represent the extensions speci.cally needed to work with programmer-de.ned \neffects and monadic re.ection, while the un\u00adshaded ones are essentially independent of how effects are \nadded to the metalanguage. 2.1 Effects The fundamental concept of the metalanguage is that of an effect \ne, representing a collection of possible computational behaviors. The simplest effect is that of potential \nnontermination, written . However, it is often more appropriate to think of as simply the underlying \ncomputationalfabric of the language. In other words, possible divergence of programs is merely the price \nwe must pay for allowing general recursive computations, rather than something weexplicitly set outto \nencompass. (Explicit partialityofafunction is often better represented using some variant of the exception \nmonad.) All effects in the language will be built on top of , to  Syntax e ::= | e t ::= a | 1 | t1 \n\u00d7 t2 | t1 + t0 | \u00b5a.t | s s ::= (e)t | t . s |T| s1 &#38; s2 S ::= \u00b7| S,e ~ a.s, e -e fS e = e ' Subeffecting \n'' ''' fS e = e fS e = e (SE-REFL) (SE-TRANS) fS e = e fS e = e ' (e -e) . S (SE-BOT) (SE-DEF) = e fS \ne = efS Effect basing fS e s fS e s (EB-EFF) (EB-FUN) fS e (e)t fS e t . s fS e s1 fS e s2 (EB-UNIT) \n(EB-PROD) fS e T fS e s1 &#38; s2 fS e = e ' fS e ' s (EB-SUB) fS e s Effect signature f S f S fS e s \n(D-EMPTY) (D-EFF) f\u00b7 f S,e ~ a.s, e -e Figure 1. Effects and types allowa simple treatmentof especially \ntype-level recursion. Indeed, we can think of as representing the effect of performing anynon\u00adtrivial \ncomputations at all, even ones that could relatively easily be seen to be terminating. Wecouldhaveparameterizedthe \nlanguagebyalarger collection of base effects,but tokeep the operational semantics concise, we requireall \nothereffectstobeexplicitly de.nedatthe programlevel. Since the language for expressing effects includes \nthe syntactic counterparts of the main domain-theoretic primitives (though not powerdomains), most conventional \nmonadic effects can be indeed de.ned in this way. An effect is thus either the single primitive effect \n, or a de.ned effect e. The second fundamental notion is that of subeffecting. Infor\u00admally,an effect \ne isasubeffectof e ',writtene = e ',if all behaviors modeled by e are also valid behaviors of e '. In \ngeneral, this covers qualitative notions of behavior inclusion (such as exceptions be\u00adinga subeffectofexceptions-and-state),but \nalso quantitative ones, such as the exact set of exceptions that a computation may signal. Subeffecting \nis naturally re.exiveand transitive, with as the least element. (Denotationally, a subeffecting e = e \n' corresponds to a monad morphism between the monads representing e and e ',but we will not pursue the \ncategory-theoretic rami.cations here.) For our purposes, the only source of proper subeffecting will \nbe when a new effect e is explicitly de.ned as an immediate supereffect of some existing e, written e \n-e. The effect structure is summarized in Figure 1.  2.2 Types Although the proposed operational semantics \nwill not depend on type information, we present the language here together withasim\u00adple type system, \nsince most of the terms can be better understood in such a setting. In the syntax of types, we distinguish \nbetween general, or value, types t , and a subclass of computation types s. Only terms of computation \ntype will be given an operational interpretation; value types represent inert data. (When appropriate, \nsuspended computa\u00adtions can also be treated as data, though.) The grammar of types is also given in Figure \n1. Again, since most conventional base types can be built up from the general constructs, there are no \ntype constants.Forexample, we will later de.ne the natural numbers as nat = \u00b5a.1+ a. (Throughout the \npaper, we use a sans-serif font for notational abbreviations.) The general types include products, sums, \nand recursion, as well as computation types. The latter include function, product, and effect types. \nTo avoid confusion between the two notion of products, we use &#38; and T for the computation variant \n(inspired by the linear-logic notation, though with no formal connection implied). The effect type (e)t \nclassi.es computations producing t-typed results, with potential e-behaviors. Note that the codomain \nof a function type must always be computational (though possibly itself another function space). Thus, \nnat . nat .( )nat isa well\u00adformed type (isomorphic to nat \u00d7 nat .( )nat),but nat . nat is not. This is \na slight relaxation of Moggi s metalanguage, in which function codomains can only be effect-types directly. \nThe extension is mainly for syntactic convenience: as suggested above, it allows curried notation for \nfunctions that would otherwise have to be written in uncurried style. The intuition behind general computation-types \nis that they classify parameterized effectful computations. In the case of effect\u00adtypes, there is no \nparametrization; function-typed computations are parameterized by the argument value, and product-typed \ncomputa\u00adtions are parameterized by whether their .rst or second argument is needed. (In particular, s \n&#38; s is thus isomorphic to (1 + 1) . s.) Formalizing this intuition, we say that a computation type \ns is based on an effect e, written fS e s, when s can be seen as a parameterized e-computation. We refer \nto computations of type (e)t as simple e-computations; others (including (e ')t when e<e ')are calledgeneralized. \n(Denotationally, when fS e s, s can be interpreted as an algebra for the monad representing effect e \n[11, VI.2]. In a domain-theoretic setting, computation types denote pointed cpos, i.e., algebras for \nthe lifting monad that models .) We .nally de.ne the notion of an effect signatureS, containing declarations \nof all effects introduced in a program, each with their immediate subeffect, and a conceptual realization \nas an already well-formed computation type (i.e., only the type-constructor part ofthe formal monad de.ningtheeffect).Forexample,theeffectof \nexceptions might be declared as ex ~ a.( )(a + nat), saying that a computation with exception-effects \ncan be understood as a pure computation returning eithertheexpected result,oran error code.If anotion \nof state-effectsst had been declared earlier in the signature, we could also have declared exceptions \nas ex ~(st)(a + nat), signifying that this notion of an ex-computation may also perform state access, \nin addition to potentially raising an exception. For an immediate-subeffect declaratione -e in a signature \nto be valid, the computation-type realizing e must be based (possibly indirectly) on e;this is checked \nby rule D-EFF.  2.3 Terms Letuslooknowatthelevelof terms.We consider.rstthegeneric parts, and then the \nre.ection/rei.cation operators speci.cally. 2.3.1 Generic fragment The syntax and typing rules are given \nin Figure 2. We generally use N for terms of computation type, and M for unrestricted ones, but there \nis no formal distinction between value-and computation\u00adtermsinthe syntax.(In particular,variables can \ndenote either kind.) The rules of the operational semantics will specify exactly when a  Syntax M, \nN ::= x | val M | glet x . N1.N2 | .x.N | NM | () | (N1,N2)| prji N | () | (M1,M2) | split(M, x1.x2.N) \n| inji M | case(M, x1.N1,x2.N2) | roll M | unroll (M, x.N) | .x x.N | [N]e | glet x . \u00b5 e(N1).N2 P ::= \nrun N | lete.ect e > e be (a.se,Nu,Nb) in P Typing environment fS G G ::= \u00b7| G,x: t (where fS t) Term \ntyping G fS M : t (x: t ) . GG fS M : t G fS N1 : (e)t G,x: t fS N2 : s fS es (TV-VAR) (TC-VAL) (TC-GLET) \nG fS x : t G fS val M : (e)t G fS glet x . N1.N2 : s G,x: t fS N : s G fS N : t . s G fS M : t (TC-LAM) \n(TC-APP) G fS .x.N : t . s G fS NM : s G fS N1 : s1 G fS N2 : s2 G fS N : s1 &#38; s2 (TC-UNIT) (TC-PAIR) \n(TC-PRJ) G fS () : T G fS (N1,N2) : s1 &#38; s2 G fS prji N : si G fS M1 : t1 G fS M2 : t2 G fS M : t1 \n\u00d7 t2 G,x1: t1,x2: t2 fS N : s (TV-UNIT) (TV-PAIR) (TC-SPLIT) G fS ():1 G fS (M1,M2): t1 \u00d7 t2 G fS split(M, \nx1.x2.N): s G fS M : ti G fS M : t1 + t2 G,x: t1 fS N1 : s G,x: t2 fS N2 : s (TV-INJ) (TC-CASE) G fS \ninji M : t1 + t2 G fS case(M, x.N1, x.N2): s G fS M : t [\u00b5a.t /a]G fS roll M : \u00b5a.t G,x: t [\u00b5a.t /a] \nfS N : s G,x: s fS N : s (TV-ROLL) (TC-UNROLL) (TC-REC) G fS roll M : \u00b5a.t G fS unroll (M, x.N): s G \nfS .x x.N : s G fS N : (e)t (e ~ a.se) . SG fS N1 : se[t/a]G,x: t fS N2 : s fS es (e ~ a.se) . S e (TC-REIF) \ne(TC-GLET-REFL) G fS [N]: se[t/a]G fS glet x . \u00b5 (N1).N2 : s Program typing fS P : \u00b7fS N : (  )nat (PT-RUN) \n fS run N fS ese \u00b7fS Nu : a1 . se[a1/a] \u00b7fS Nb : se[a1/a] . (a1 . se[a2/a]) . se[a2/a] fS,e~a.se,e-e \nP (PT-LETEFF) fS lete.ect e > e be (a.se,Nu,Nb) in P Figure 2. Term and program syntax and typing term \nof computation type should be evaluated, and when it should be treated as a passive datum. The term syntax \nis largely conventional, corresponding to the usual introduction and elimination principles for the available \ntype constructors. We note that all elimination has to happen in the context of a computation, i.e., \nthe type of the result in split, case, or unroll must be computational, and thus ultimately based on \n. This restriction signi.cantly simpli.es the reduction semantics, while not presenting any major problems \nin elaborating common object languages into the metalanguage.With that proviso, all the unshaded typing \nrules except TC-VAL and TC-GLET should be self-explanatory. The rule for val is also straightforward: \nval M represents an effect-free computation, that merely returns M;it corresponds to the ' M notation \nof the Introduction, or return M in Haskell. Glet represents computation sequencing; informally, glet \nx . N1.N2 .rst evaluates N1 (performing its effects), and then evaluates N2 with x bound to the result \nof N1. The rule TC-GLET is a gen\u00aderalization of the usual monadic let-typing rule (or Haskell s do\u00adnotation), \nhowever: as usual, N1 must have an effect-type (e)t ,but the body N2 can be of anycomputation-type based \non e, not neces\u00adsarily exactly of the form (e)t '. This includes function spaces into e-computations, \nand notably also computations with supereffects (immediate or otherwise) of e. In particular, the idiom \nglet x . N. val x can lift a term N : (e)t to the type (e ' )t, when e = e '. (Later we shall introducea \nsubtyping system,allowingusto write N directly, without such an explicit effect-inclusion.) Note that, \nwhen N2 is a non-trivially parameterized computation, then so is glet x . N1.N2;thatis, the computation \ninN1 is not performed until the entire computation has been supplied with the parameter value. Summarizing, \nthe language de.ned so far is thus essentially FPC [7], with explicit sequencing of -effects. As previously \nmen\u00adtioned, we can de.ne natural numbers with the usual operations: nat = \u00b5a.1+ a z = roll inj1 () s \nM = roll inj2 M ncase(M, Nz, x.Ns) = unroll (M, m.case(m, .Nz, x.Ns)) plus = .x f..n..m.ncase(n, val \nm, n ' .glet r . fn ' m. val (s r)) (The function plus could also have been coded tail recursively, but \nthe above variant is more representative of the sequentialized style.) We can derive the following typing \nrules for the above abbreviations:  G fS M : nat G fS z : nat G fS s M : nat G fS M : nat G fS Nz : \ns G,x: nat fS Ns : s G fS ncase(M, Nz, x.Ns): s G fS plus : nat . nat .(e)nat (We write derived rules \nwith dashed lines.) The type of plus can be derived for any e, not only . Again, it does not mean that \nplus is intended to be partial, only that it involves non-trivial computation. With general\u00b5-types, we \ncan de.ne other inductive types such as lists,but also datatypes with embedded computations, such as \nin.nite streams or search trees, oreven properly re.exiveones such as \u00b5a.nat +(a .( )a).  2.3.2 Monadic \nre.ection The last two term constructs enable actual programming with de\u00ad.ned computational effects. \nThe .rst, monadic rei.cation [N]e , represents an unsealing of an effect e in terms of its declared com\u00adputational \nrealization. Continuing the exception example from be\u00adfore, a term N : (ex)bool is an opaque boolean-returning \ncom\u00adputation, which can only be sequenced before or after another ex\u00adcomputation using glet. But its \nrei.cation, [N]ex : ( )(bool+nat) can be explicitly evaluated, assuming it terminates, to a sum-typed \nvalue, which can then be the subject of a case. In particular, the rei.cationcanbeusedtohaltthe propagationofaraisedexception: \nby reifying a computation, we get to exercise non-standard control over its behavior.We could,of course,work \nwith the rei.ed repre\u00adsentationallthe time,but thisislikelytobe both lessef.cientand more verbose. The \nother operation, lending its name to the whole pair, is monadic re.ection. It seals an explicit computation \nin the realiza\u00adtiontypeintoan opaque computationinthe de.nedeffect-type.For technical convenience in \nthe operational semantics later, we have integrated it as a variant of the glet construct,but it can \nbe under\u00adstood independently. In particular, we can introduce an isolated re.ect as an abbreviation, \n\u00b5 e(N) = glet x . \u00b5 e(N). val x witha derived typing ruleexactly oppositetoTC-REIF: G fS N : se[t/a](e \n~ a.se) . S G fS \u00b5 e(N ): (e)t Re.ection provides the only means for introducing non-trivial behaviors \nof an effect-type; otherwise, only pure computations (in\u00adcluding divergence) would be expressible. In \nthe exception exam\u00adple, re.ection can be used to create an (ex)bool-computation from theexplicit error-returning \ncomputation val inj2 (sz): ( )(bool+ nat). As long as the generic rules for glet properly propagate such \nan exceptional result until it is rei.ed again, rei.cation and re.ec\u00adtion together allow us to de.nea \nconventional exceptionfacility, assketchedinthe Introduction.Wewill returntothisexamplein Section 4.1, \nas well as other examples of de.ned effects.  2.4 Subtyping The type system as presented so far requires \neffects in types to matchupexactly:ifaterm withagiveneffectis needed somewhere (e.g., asafunction argument), \nwe cannot simply supplyaterm with a lesser effect. Instead, we must explicitly include an effect into \nits supereffect, using the glet val idiom from above. However, since the operational semantics of effects \ndoes not use the type information, the extra glet and val play no material role at runtime, other than \nadding anextra reduction step.To free fS t = t ' Subtyping fS e = e ' fS t = t ' (STV-REFL) (STC-EFF) \nfS t = t fS (e)t =(e ' )t ' fS t ' = t fS s = s ' (STC-FUN) fS t . s = t ' . s ' '' fS s1 = s1 fS s2 \n= s2 (STC-UNIT) (STC-PROD) fS T=T fS s1 &#38; s2 = s1 ' &#38; s2 ' Additional rule for G fS M : t : \nG fS M : t fS t = t ' (T-SUB) G fS M : t ' Figure 3. Subtyping the producer (human or automated) of metalanguage \ncode from inserting such eta-like redexes explicitly, just in order to make the program typecheck, weextend \nthe type system withasimple notion of inclusive subtyping, as detailed in Figure 3. We de.ne notions \nof subtyping for general and computation types(whereonlythe latteris non-trivial),aswellasasubsumption \nrule allowing a term with a given type to be used directly where a supertype is needed. Note that for \ntwo types to be related by subtyping, they must have exactly the same shape, differing only in the effects \noccurring inside (\u00b7)s. Although the subtyping relation does not include a transitivity rule, such a rule \nis evidently admissible: ' ''' LEMMA 2.1 (Transitivityof subtyping). If t = t and t = t then t = t '' \nProof. Easy induction on the total size of the twoderivations (since theymustbe swappedin the ruleSTC-FUN), \nultimately relying on transitivity of the subeffect relation fS e = e ' .  2.5 Programs The grammar \nand typing of programs are shown in the last part of Figure 2. The level of programs contains the actual \nde.nitions of anyeffectsusedina computation.Werefertothe de.nitionsasthe program s prelude, and the .nal \neffectful computation as its body. Since general effects will not be uniformly observable, we require \nthe program body run N to not have anytop-level behaviors other than potential divergence. All behaviors \nintroduced by re.ection thus have to be eliminated by rei.cation, before the .nal program result can \nbe observed. The type system straightforwardly enforces this requirement. Also, to allow .nal results \nto be observed atomi\u00adcally, we require the result (if any) to contain no embedded compu\u00adtations, noteven \nwith only -behavior; for concreteness, we specify that it must be exactly of type ( )nat. The leteffect \nconstruct introduces a new effect in terms of its monadic speci.cation. That is, in addition to the realization \nof the effect asa computation type based onasimpler one (and ultimately just on ), we must supply a unit \nfunction, expressing how values are turned into computations with val, and a bind function for sequencing \ncomputations in the effect with let. Note that we need only de.ne sequencing of simple computations; \nthe framework will induce the appropriate behavior for the generalized instances of glet. At the time \nan effect is de.ned, we must also declare which effect it is to be considered an immediate supereffect \nof, for the purpose of creating the effect signature. The unit and bind functions must be typable with \nthe given top-level polymorphic type schemas; this ensures that they can be soundly instantiated at arbitrary \ntypes during execution.  Tobe precise, we callthe triple of type constructor and unit/bind terms a syntactic \nmonad.We expect them to obeythe monad laws and layering condition (see [5]),but of course cannot check \nthose in the type system.For the purpose of the operational semantics, it doesn t actually matter whether \nthe laws hold;but the programs may behave in very counterintuitive, and hard-to-predict, ways if theydo \nnot. In principle, the de.nitions of the unit and bind functions may use rei.cation and re.ection for \npreviously de.ned effects. In prac\u00adtice, it seems that this generality is rarely useful, and it might \nbe reasonable to require Nu and Nb to be typable in an empty effect\u00adsignature. Effects with subeffecting \nevidently form a tree, with at the root. This is more general than what was considered for layered monadic \nre.ection in earlier work [4], where effects were required tobe linearly ordered,but weexpect the continuation/state-based \nimplementation methodology to generalize relatively straightfor\u00adwardly to this more general setting. \n3. Operational semantics Wenowconsiderhowtoassignanexecutable semanticstopro\u00adgrams in the language. Like \nfor typing, we start with the straight\u00adforward constructs in the base language. 3.1 Generic fragment \nThe semantics is expressed in conventional small-step style, and is shown in Figure 4. The effect-free \nfragment is inspired by Levy s Call-By-Push-Value formalism [10], though without a syntactic distinction \nbetween values and computations; instead, whether computations are performed or treated as data depends \non where they occur. The judgment for term reduction, fF N . N ' , spec\u00adi.es when a closed term reduces \nto another; it is parameterized by an effect-de.nition environment F, which keeps track of the unit/bind \nfunctions of all de.ned effects, and will only come into play in the next section. The unshaded rulesfall \ninto two classes. TheRC-rules enu\u00admerate the contexts in which reductions are permitted, while RR\u00adaxioms \nrepresent proper reductions. Note that computations elimi\u00adnating value-type terms involve only proper \nreductions. This is be\u00adcause a closed term of type t1 \u00d7 t2 must necessarily already be a syntactic pair \n(M1,M2);a sum-typed term must be an inji M; and a \u00b5-typed one must be of the shape roll M, so there are \nno context-reduction variants of split, case, or unroll. For the computation types, the context rules \nspecify CBN eval\u00aduation in the case where a function argument is of a computa\u00adtion type (and hence potentially \neffectful). CBV evaluation can be forced either at the call site, writing glet x . N2.N1 (val x) instead \nof N1 N2; or as part of the function de.nition, e.g., .t.glet x . t. \u00b7\u00b7\u00b7. If the function s domain type \nis a proper value type,theargumentwill alreadyhavebeenevaluatedbythetimethe function is called. We note \nthat the semantics speci.es a PCF-style CBN variant: thereisnowaytoforceevaluationofafunction-typedterm, \nwithout actually applying the function. In particular, for O= .x x.x, there is no observable difference \nbetween O: t . s and .x.O: t . s: both are functions that diverge when applied to anything. The rule \nRR-GLET-VAL handles the case where the .rst part of a sequential composition has no effects. Note that \nno unit/bind functions are involved here: de.ning a potential effect does not imposeanyoverheadonthepartsofthe \nprogramthathappennotto useit,evenif theirtypeallowsthemto;forexample,a successfully returning function \nof declared type nat .(ex)bool goes through exactly the same steps as one of type nat .( )bool.  3.2 \nMonadic re.ection Consider now the rules involving re.ection and rei.cation, exem\u00adpli.ed by the particular \ncase of exceptions. Note .rst that the inte\u00adrior of a rei.cation is also a reduction context (rule RC-REIF): \nto reduce a term [N]ex of type ( )(bool + nat), we reduce its body N : (ex)bool, for as long as this \nis possible. N may reduce for\u00adever, in which case so will [N]ex. Or N may eventually reduce to val M, \nwhere M is either true or false),in which caseRR-REIF-VALwill return the transparent representation of \na trivial computa\u00adtion, as speci.ed by the Nu for exceptions, i.e., val inj1 M. The rule RR-REIF-GLET-REFL \ncovers the case when the body of a rei.cation is a glet whose binder is a re.ection. In this case, N1 \nis a transparent representation of the e-computation that is just about to happen, and thus we can directly \nuse the bind function of the monad to sequence N1 before the still-to-be-rei.ed N2. Note that, in a well-typed \nprogram, the body N2 will be exactly of type (e)t ', rather than a general e-computation, thus requiring \nonly a non-generalized bind function. The roleofRP-GLETisto propagate an activere.ection to meet a matching \nre.ection.Itdoessobyusingthe general .atteningrule for monadic glets, glet y . (glet x . N1.N2).N3 . \nglet x . N1. glet y . N2.N3 to rotate a re.ect in position N1 to the head of the term. While this reduction \nis meaning-preserving even when N1 is not a re.ection, usingitonlywhentrulyneeded,keepsthe reduction \nrelationdeter\u00administic. The three other RP-rules propagate re.ections out of the other kinds of evaluation \ncontexts: RP-APP and RP-PRJ do so from applications and projections respectively. (Again, in a denotational \nsemantics of the metalanguage [5], these are valid equivalences even with an arbitrary term in place \nof \u00b5 e(N1), essentially because application and projections are morphisms of the monad algebras interpreting \nthe computation types in question.) Finally, RP-REIF propagates e-re.ections destined for some matching \nrei.cation outofa rei.cation-context fora proper super\u00adeffect e '.Forexample, assuming ex = a.(st)(a+nat) \nwhere st isa state-effect, ifa st-re.ect (essentiallya read/write-request; see Sec\u00adtion 4.2) meets an \nex-rei.cation (typically an exception handler), the re.ect should propagate through the rei.cation,but \nremember it when resuming the computation with the result of the re.ection. The condition fF e<e ' in \nthe RP-REIFY rule is a bit subtle. Note .rst that it uses a separate operational judgment to check at \nruntime that e is a proper ancestor of e ' in the effect tree. But in a well-typed program, the typing \nrules actually ensure that fS e = e ', so it would in principle suf.ce to merely check that e e ' , = \nto prevent an overlap with RR-REIF-GLET-REFL. (Such a check for inequality would allow us to omit the \nimmediate-subeffect assumptions in F entirely.) The only role of the stronger condition is thus to make \nsome terms get stuck, that would otherwise have kept on reducing, at least for a while. Wekeeptheexplicitcheckto \nemphasizethat,inthe absenceof static type checking (or checking with only an effect-oblivious type system), \nencounteringan re.ectionfromapartoftheeffecttreenot below the rei.cation-effectis considereda runtime \ntype error that shouldbe caught and reported,evenif the computationis not stuck hardat this stage.(We \nwill returnto this issuein Section 4.3.) The reduction rules for programs are straightforward: The rule \nPRC-LETEFF merely makes the monad de.nition available to its body by extending F, while PRR-LETEFF-VAL \nsays that, once a program body has terminated, the effect declaration around it can be removed.  Effect \nde.nitions F ::= \u00b7| F,e =(Nu,Nb),e -e Effect layering fF e = e ' , fF e = e ' (e ' -e) . F fF e<e \n(RLT-DECL) (RLE-EQ) (RLE-LESS) fF e<e fF e = e fF e = e fF N . N ' Term reduction ' fF N1 . N1 (RC-GLET) \n(RR-GLET-VAL) fF glet x . N1.N2 . glet x . N1' .N2 fF glet x . val M. N . N[M/x] (RP-GLET) fF glet y \n. (glet x . \u00b5 e(N1).N2).N3 . glet x . \u00b5 e(N1). glet y . N2.N3 fF N . N ' (RC-APP) (RR-APP-LAM) fF NM \n. N ' M fF (.x.N) M . N[M/x] e e(RP-APP) fF (glet x . \u00b5 (N1).N2) M . glet x . \u00b5 (N1).N2 M fF N . N ' \n(RC-PRJ) (RR-PRJ-PAIR) fF prji N . prji N ' fF prji (N1,N2). Ni e e(RP-PRJ) fF prji (glet x . \u00b5 (N1).N2) \n. glet x . \u00b5 (N1). prji N2 fF N . N ' (e =(Nu,Nb)) . F e ' e (RC-REIF) e (RR-REIF-VAL) fF [N]. [N ]fF \n[val M]. Nu M (e =(Nu,Nb)) . F ee e(RR-REIF-GLET-REFL) fF [glet x . \u00b5 (N1).N2]. Nb N1 (.x.[N2]) fF e<e \n' (RP-REIF) e, e, fF [glet x . \u00b5 e(N1).N2]. glet x . \u00b5 e(N1). [N2] (RR-SPLIT-PAIR) (RR-CASE-INJ) fF \nsplit((M1,M2),x1.x2.N) . N[M1/x1,M2/x2] fF case(inji M, x1.N1,x2.N2) . Ni[M/xi] (RR-UNROLL-ROLL) (RR-FIX) \nfF unroll (roll M, x.N) . N[M/x] fF .x x.N . N[(.x x.N)/x] fF P . P ' Program reduction fF N . N ' (PRC-RUN) \n fF run N . run N ' ' fF,e=(Nu,Nb),e-e P . P (PRC-LETEFF) fF lete.ect e > e be (a.se,Nu,Nb) in P . \nlete.ect e > e be (a.se,Nu,Nb) in P ' (PRR-LETEFF-VAL) fF lete.ect e > e be (a.se,Nu,Nb) in run val \nM . run val M Figure 4. Reduction rules (explicit formulation) 3.3 Properties of the reduction system \nProof. Straightforward induction on derivations, using that canon\u00adical terms as de.ned aboveare irreducible, \nand that strict subeffect- We canshowa numberof desirable resultsofthe reduction system. ing fF e<e is \nirre.exive (thus preventing an overlap between All of these have been fully formalized and veri.ed using \nthe ' RR-REIF-GLET-REFL andRP-REIF). Twelf proof assistant [16]. (The formalization is available from \nhttp://www.diku.dk/~andrzej/papers/.) We can also show soundness of the type system, using the well-established \nmethod of progress and preservation lemmas [17, DEFINITION 3.1. A closed, computation-typed term is \nsaid to be canonical if it is of one of the forms val M, .x.N, (), (N1,N2), 21]. We .rst de.ne the judgment \nf F:S , expressing that a or glet x . \u00b5 e(N1).N2.Acomplete program is .nished when of set of monad de.nitions \nin the operational semantics matches the the form run val M. corresponding declarations in the type system: \n(DT-EMPTY) THEOREM 3.2 (Determinacy). Termandprogramsreduce uniquely: f\u00b7 : \u00b7 ' '' ''' 1. If fF N . N \nand fF N . N then N = N f F:S fS Nu : a1 . se[a1/a] fS Nb : \u00b7\u00b7\u00b7 ' '' ''' 2. If fF P . P and fF P . P \nthen P = P (DT-EFF) f (F,e =(Nu,Nb),e -e) : (S,e ~ a.se,e -e)  A closed term (or program) is said to \nbe stuck ifitis not canonical(or .nished),but cannotbe further reducedbyanyrule. The progresstheorem \nsays that well-typed terms and programs are never stuck: THEOREM 3.3 (Progress). Suppose f F:S. Then \n1. If \u00b7fS N : s, then either N is canonical or there exists an N ' suchthat fF N . N ' . 2. If fS P \n, then either P is .nished or there exists a P ' suchthat fF P . P ' .  Proof. Part 1 follows by induction \non the typing derivation. The reasoning is somewhat complicated by subtyping: we need canonical-forms \nlemmas to the effect that, even in the presence of subtyping, an irreducible term of functional type \nis indeed a lambda-abstraction, etc. Otherwise, the proof is uneventful. We note that the typing rule \nTC-GLET-REFL ensures that one of the reduction rulesRR-REIF-GLET-REFL orRP-REIFY will apply. Part2follows \nfrom part1bya simple induction on the deriva\u00adtion of fS P . We can also show that typabilityis preservedby \nreduction: THEOREM 3.4 (Preservation). Suppose f F:S. Then 1. If \u00b7fS N : s and fF N . N ' then \u00b7fS N \n' : s 2. If fS P and fF P . P ' then fS P ' .  (The theorem also holds for the system without subtyping,i.e., \nif the typing of N does not need T-SUB, then neither does N '.) Proof. Part1isbyinductiononthederivationofthe \nreductionrela\u00adtion, withan inner induction on the typing relation. (The other way aroundisalso possible,andinvolvesexactlythe \nsameargumentsin a different order.) Again most cases are straightforward; the only complications arise \nfrom subtyping: for each canonical-form typ\u00adingrule(TC-LAM,TC-VAL,etc.),weneedaninversion lemmato the \neffect that if the conclusion of the rule is derivable (possibly using subsumption), then so are the \npremises. For program-typing preservation we note thatPR-LETEFF-VAL preserves typability, because an \nM of type nat cannot contain any occurrences of the effect e. Preservation and progress together give \nus: COROLLARY 3.5 (Type soundness). Any well-typed complete pro\u00adgram either runs forever, or eventually \nreduces to a (unique) num\u00adber.  3.4 Acontextformulation The reduction system in Figure4is convenient \nfor formal reason\u00ading,but often does not quite re.ect the operational intuition behind theeffects.We \nthus introduce an alternative presentation, whichby collapsing certain sequences of reduction steps, \ncaptures the con\u00adnection between syntactically distant effect-invoking and effect\u00addelimiting operations \nin a single rule. The reformulated system is shown in Figure 5. The main change is that we have introduced \nan explicit syntactic class of evaluation contexts E (usingcurly bracesfor holesand .lling, purelytoavoid \nyet anotheroverloadingofsquarebrackets);thisallowsustomerge all the individualRR-X and RP-X rules into \na few more general ones. Note also that the central new reduction ruleCR-REIF-CTX-REFLis formulatedonlyin \ntermsofthe isolated-re.ection operator from Section 2.3.2. As suggestedbythe notation, each reductionby. \ncorresponds to one or more reduction steps in the original system: ' +' LEMMA 3.6. If fF N . N then fF \nN . N Proof. For all of theCR-X rules without premises, we use the analogous RR-X rule in the original \nformulation. The newCR\u00adREIF-VALalso correspondstoRR-REIF-VAL,andthe general con\u00adtext ruleCR-CTX correspondsto \nnested usesoftheRC-X rules according to the structure of E. For CR-REIF-CTX-REFL, we use a straightforward \ninduction on the derivation of fF e<E to show .rst that e* e fF E{\u00b5 (N)}. glet x . \u00b5 (N ).E{val x} (In \nthe base case, where E = {}, the two sides are already equal by de.nition.) From this, the result follows \nimmediately using the RC-REIF andRR-REIF-GLET-REFL rules. 4. Examples In this section we consider a number \nof familiar examples of monadic effects, to see how they.t into the framework. 4.1 Exceptions Let us \nreturn to the exception example from the Introduction, now in a more formal setting. Let exn be some \narbitrarily de.ned type of exception names (e.g., simply exn = nat).We then construct metalanguage de.nitions \nfor the syntactic monad components: Tex(e, t) =(e)(t + exn) unitex = .a. val inj1 a bindex = .t..f.glet \ns . t. case(s,a.f a,x.val inj2 x) Note that this is really de.ning a monad transformer, not just a single \nmonad, because the base effect e can be chosen arbitrarily. Fixing this base effect to some e0, possibly \njust , we can then introduce the effect ex as follows: lete.ect ex > e0 be (a.Tex(e0,a), unitex , bindex) \nin ... The effect de.nition sets up the infrastructure for working with exceptions. The next step is \nto de.ne the effect operations them\u00adselves: ex raise M = \u00b5 (val inj2 M) try N1 with N2 = glet s . [N1]ex \n. case(s, a.val a, x.N2 x) (The M in raise is a value, not a computation; to determine the exception \nname itselfasthe resultofacomputation,wewouldwrite glet n . N. raise n.) Again, raise constructs the \nmonadic representation of a raised exception as the trivial computation of a right-tagged exception name, \nand re.ects it. Conversely, try rei.es the opaque representa\u00adtion of the protected expression, evaluates \nit (thus performing any e0-effects it might have), and inspects the result: if it is left-tagged, the \nvalue is just returned, and N2 is ignored; otherwise, we apply the handler function N2 to the exception \nname. For these abbreviations,the systemof Figure2letsusderivethe following sound typing rules: G fS \nM : exn G fS raise M : (ex)t G fS N1 : (ex)t G fS N2 : exn .(e)t fS e0 = e G fS try N1 with N2 : (e)t \nThe underlying value type t of the protected expression and the handler must be the same (possibly achieved \nthrough subsump\u00adtion),but theymay have different effects. In particular, if the han\u00addler only has e0-effects, \nso will the whole try-expression. Looking at the dynamic semantics, we see that try {} with N2 is an \nevaluation context, so we have the derived rule: ' fF N1 . N1 fF try N1 with N2 . try N1 ' with N2  \n Evaluation contexts E ::= {} | glet x . E. N | EM | prji E | [E]e e-evaluation contexts fF e<E fF e<E \nfF e<E (E-HOLE) (E-GLET) (E-APP) fF e< {} fF e< glet x . E. N fF e<EM fF e<E fF e<E fF e<e (E-PRJ) e \n(E-REIF) fF e< prji E fF e< [E] Contextual reduction fF N . N ' (CR-GLET-VAL) (CR-APP-LAM) fF glet x \n. val M. N . N[M/x] fF (.x.N) M . N[M/x] (CR-PRJ-PAIR) (CR-SPLIT-PAIR) fF prji (N1,N2). Ni fF split((M1,M2),x1.x2.N) \n. N[M1/x1,M2/x2] (CR-CASE-INJ) (CR-UNROLL-ROLL) fF case(inji M, x1.N1,x2.N2) . Ni[M/xi] fF unroll (roll \nM, x.N) . N[M/x] (CR-FIX) fF .x x.N . N[(.x x.N)/x] (e =(Nu,Nb)) . F(e =(Nu,Nb)) . F fF e<E e (CR-REIF-VAL) \nee e(CR-REIF-CTX-REFL) fF [val M]. Nu M fF [E{\u00b5 (N)}]. Nb N (.x. [E{val x}]) fF N . N ' (CR-CTX) fF \nE{N}. E{N ' } Figure 5. Reduction rules (context formulation) Further, try val M with N2 = glet s . [val \nM]ex . case(s, a.val a, x.N2 x) . glet s . unitex M. case(s, a.val a, x.N2 x) . glet s . val inj1 M. \ncase(s, a.val a, x.N2 x) . case(inj1 M, a.val a, x.N2 x) . val M  That is, we have a derived rule: \n+ fF try val M with N2 . val M Now, suppose fF ex <E, so that in particular E does not itself include \nan inner try as part of the evaluation context. Then, try E{raise M} with N2 M)}]ex = glet s . [E{\u00b5 ex(val \ninj2 . case(s, a.val a, x.N2 x) . glet s . bindex (val inj2 M)(.r. [E{val r}]ex). case(s, a.val a, x.N2 \nx) 2 . glet s . (glet s . val inj2 M. case(s, a.(.r. [E{val r}]ex) a, x.val inj2 x)). case(s, a.val \na, x.N2 x) . glet s . case(inj2 M, a.(.r. [E{val r}]ex) a, x.val inj2 x). case(s, a.val a, x.N2 x) \n. glet s . val inj2 M. case(s, a.val a, x.N2 x) . case(inj2 M, a.val a, x.N2 x) . N2 M  Here E represents \nthe local evaluation context of the raise. Note that it gets discarded already by the bind that occurs \nas part of the semantics of rei.cation, not by the de.nition of try. Indeed, with the chosen de.nition \nof the monad, there is no way to express an exception-handling construct that can access the local context \nof the raise (for example to resume it). This is exactly what we would expect from the realization type: \nif the rei.ed meaning of a computation is just a right-tagged exception name, there is no context available \nto be inspected or resumed. In summary, fF ex <E + fF try E{raise M} with N2 . N2 M Note that raise M \nonly reduces meaningfully in the context of a try. And infact the typing rules enforce this: the top-level \neffect must be , so in a well-typed program, there can be no unguarded exception-computations. Although \nwe do not typically expose the general re.ect and reify operations for exceptions directly to the programmer, \nit is instructive to consider one particular instance: what if we apply ex \u00b5 (\u00b7) to the transparent representation \nof an effect-free computa\u00adtion returning M, i.e., val inj1 M?We calculate: exM)}]ex [E{\u00b5 (val inj1 . \nbindex (val inj1 M)(.x. [E{val x}]ex) 2 . glet s . val inj1 M. case(s, a.(.x.[E{val x}]ex) a, e.val inj2 \ne) . case(inj1 M, a.(.x. [E{val x}]ex) a, e.val inj2 e)  2 . [E{val M}]ex ]ex Thatis,inanyevaluation \ncontext anchoredby [ \u00b7, an occurrence ex of \u00b5 (unitex M) behaves same as just val M. This is no accident, \nof course; it follows from the fact that the exception monad sat\u00adis.es the monad laws (speci.cally, bind \n(unit M)N = NM . In other words, though the operational semantics is well de.ned for effects determined \nby anypair of terms Nu and Nb of the right types, we must require them to satisfy the monad laws as at \nleast observational equivalences, if we want an agreement between the translational and the operational \nviews of the effect.  4.2 State In the exception monad, the local context at the point of re.ection \nplayed no role.For most monadic effects, though, that context is meant to be resumed with the result \nof the effectful operation. The prime example of such an effect is state.  Consider the components of \nthe state monad: Let state be some type and take Tst(e, t ) = state .(e)(t \u00d7 state) unitst = .a..s.val \n(a, s) bindst = .t..f..s.glet (a, s ' ) . ts.f as ' We writeglet (x, y) . N. N ' as a straightforward \nabbrevia\u00adtion for glet p . N. split(p, x.y.N ' ), where p . FV (N ' ). Again, we introduce the effect, \nlete.ect st > e0 be (a.Tst(e0,a), unitst , bindst) in ... with companion abbreviations: withst M do N \n= glet (a, s) . [N]st M. val a getst = \u00b5 st(.s. val (s, s)) setst M = \u00b5 st(.s. val ((),M)) (s .FV (M)) \nWe derive the following type rules for the constructs: G fS M : state G fS N : (st)t withst M do N : \n(e0)t G fS M : state G fS getst : (st)state G fS setst M : (st)1 Operationally,we see that withst M do \n{} is anevaluation context, so we obtain the following derived reduction rule: fF N . N ' fF withst M \ndo N . withst M do N ' We also have, withst M1 do val M2 = glet (a, s) . [val M2]st M1. val a . glet \n(a, s) . unitst (val M2) M1. val a . glet (a, s) . val (M2,M1). val a . val M2  2 2 which we summarize \nas: + fF withst M1 do val M2 . val M2 Consider now what happens when getst occurs dynamically within \na withst. Again, let fF st <E, so that E does not contain an inner withst;then, withst M do E{getst} \nstst = glet (a, s) . [E{\u00b5 (.s. val (s, s))}]M. val a . glet (a, s) . bindst (.s.val (s, s)) (.x.[E{val \nx}]st) M. val a 3' . glet (a, s) . (glet (a, s ) . (.s. val (s, s)) M. (.x. [E{val x}]st) as ' ). val \na . glet (a, s) . (glet (a, s ' ) . val (M, M). st' (.x. [E{val x}]) as ). val a 2st . glet (a, s) \n. (.x.[E{val x}]) M M. val a st . glet (a, s) . [E{val M}]M. val a = withst M do E{val M} That is, the \ncall to getst gets replacedby thevalue representing the current state,but theevaluation context remains \nunchanged. Completely analogously, for setst we calculate: withst M do E{setst M ' }= glet (a, s) . [E{\u00b5 \nst(.s. val ((),M ' ))}]st M. val a ' st . glet (a, s) . bindst (.s. val ((),M )) (.x. [E{val x}]) M. \nval a 3'' . glet (a, s) . (glet (a, s ) . (.s. val ((),M )) M. st' (.x. [E{val x}]) as ). val a . glet \n(a, s) . (glet (a, s ' ) . val ((),M ' ). (.x. [E{val x}]st) as ' ). val a 2st' . glet (a, s) . (.x. \n[E{val x}]) () M. val a st ' . glet (a, s) . [E{val ()}]M. val a = withst M ' do E{val ()} Here, the \ncall to setst M ' gets replaced by simply val (),but the surrounding context gets modi.ed to now report \nthe state as M ' for anyfuture calls to getst, very much like in a specialized theory for state [3]. \nSummarizing, we can complete our derivedreduction rules with fF st <E + fF withst M do E{getst}. withst \nM do E{val M} fF st <E +' fF withst M do E{setst M ' }. withst M do E{val ()}  4.3 Exceptions and state \nIfwewanttowrite programswithbothexceptionsandstate,wecan simply use the above two effect-de.nitions together; \nin particular, the derived reduction rules remain valid. We must still make a choice, however, about \nhow to order the effects. We specify an ML-like semantics, with state persisting across raised exceptions, \nas follows: lete.ect st > be (a.Tst( ,a), unitst , bindst) in lete.ect ex > st be (a.Tex(st,a), unitex \n, bindex) in ... In this ordering, the program will typically contain a single, out\u00adermost withst, representing \nthe global state, and serving as an an\u00adchor for all st-re.ections. Such re.ections propagate freely through \ntry-terms(ex-rei.cations),aswewouldexpect.However,inatype\u00adcorrect program, anyraised exceptions must \nbe caught before they can reach the withst, if only by a catch-all handler that reports a top-level uncaught \nexception. Expanding the effect de.nitions, we see that the constructor associated with exceptions-and-state \ncom\u00adputations is given by Ta = state .( )((a + exn) \u00d7 state). Had we instead introduced the effects in \nthe opposite order, with st layered above ex,wewouldgeta transactional semantics, where the current state \nis lost when an exception is signaled. That is, the combined type constructor modeling computations would \nbecome Ta = state .( )((a \u00d7 state)+ exn). In this variant, raised exceptions can freely propagate out \nof withst, but the se\u00admantics no longer prescribes a behavior for when a state access occurs directly \nwithin a try. It may be tempting to relax the condition e<e ' in RP-REIF to e = e ', allowing all re.ections \nto commute with other rei.ca\u00adtions. This often happens to give a sensible operational behavior. However, \nthe price we pay for such an anarchic combination of individually speci.ed monadic effects is that we \ncan no longer ex\u00adplain the combination of exceptions and state translationally using either of the two \nabove versions of T, and so we lose the equiv\u00adalence principle between opaque and transparent representations, \nmaking sound reasoning about the system signi.cantly harder (cf. [13]).  4.4 Continuations Asa.nalexample, \nlet us consider .rst-class continuations. Let ans be a suitable type of .nal answers. The monad components \ncan then be taken as Tct(e, a) = (a .(e)ans) .(e)ans unitct = .a..k.k a bindct = .t..f..k.t (.a.f ak) \nFor any base effect e0, we then introduce the effect of ans\u00adcontinuations with e0-effects: lete.ect ct \n> e0 be (a.Tct(e0,a), unitct , bindct) in ... In the scope of this declaration, we can introduce abbreviations \ncont(t) = t .(e0)ans #N = [N]ct (.r.val r) ctct letcc k.N = \u00b5 (.k. [N]k) throw M to K = \u00b5 ct(.k ' .K \nM) (k,.FV (K).FV (M)) Note that, erasing the reify/re.ect operations, the above is exactly how we could \nde.ne prompts, letcc, and throw in a continuation\u00adpassing translation. Their derivable typing rules are: \nG fS N : (ct)ans G fS #N : (e0)ans G,k: cont(t ) fS N : (ct)t G fS K : cont(t )G fS M : t G fS letcc \nk.N : (ct)t G fS throw M to K : (ct)t ' We immediately see that body of a prompt is an evaluation context, \nand easily derive the usual cleanup rule: + fF #val M . val M We also have: #E{throw M to K} ctct = [E{\u00b5 \n(.k ' .K M)}](.r.val r) ct . bindct (.k.K M)(.x. [E{val x}])(.r.val r) 3ct . (.k ' .K M )(.a.(.x.[E{val \nx}]) a (.r.val r)) . KM  That is, a throw replaces the entire current evaluation context (including \nthe anchoring prompt) with the one obtained from K. Conversely, for letcc we get: #E{letcc k.N} ctctct \n= [E{\u00b5 (.k.[N]k)}](.r. val r) ct ct . bindct (.k. [N]k)(.x.[E{val x}])(.r. val r) 3ct ct . (.k ' . [N]k)(.a. \n(.x. [E{val x}]) a (.r.val r)) ~ct ct . (.k. [N]k)(.a.[E{val a}](.r. val r)) ct =(.k. [N]k)(.a.#E{val \na}) . [N [(.a. #E{val a})/k]]ct (.a.#E{val a}) In the transition marked with a ~, we have cheated slightly, \nby eagerly contractingatrivial beta-redex, whichin realitywouldonly happen once the continuation was \nactually applied. Even so, the reducedtermisevidentlynolongerinthe fragmentspannedbyour specialized continuation \nprimitives, because it uses rei.cation with a non-empty continuation. We can certainly continue reducing \nit ct further using the general rules for \u00b5 ct() and [], so the semantics remains correct. However, in \nthis particular case, we could instead have de.ned the abbreviation letcc slightly more verbosely: ctct \nletcc k.N = \u00b5 (.k. [glet x . N.k x](.r.val r)) (x=k) This is denotationally equivalent to the original \none (in the sense that their monadic translations are \u00df.-equivalent in the base language),buthasashapethatis \nclosedunder reduction.Weget + #E{letcc k.N}. #glet x . N[((.x. #E{val x}))/k]. #E{val x} Incidentally, \nusing another denotationally valid equation, #glet x . N ' . #E{val x} = #E{N ' } the result of the reduction \nis equivalent to #E{N[(.x.#E{val x})/k]} which one would probably have written as the intended reduct \nof #E{letcc k.N}, if de.ning the operational semantics directly. 5. Related work The metalanguage used \nto host the monadic re.ection operators was .rst introduced in a purely denotational setting for relating \nmonadic semantics [5], although its roots go back to at least [4]. The single-effect fragment is very \nclose to Levy s Call-By-Push-Value metalanguage [10], at least with respect to the operational and denotational \nsemantics (the syntaxes are less similar). How-ever,CBPV primarily usesthe notionof computationtypestofaith\u00adfully \nencode PCF-or Algol-like call-by-name semantics, whereas our focus is on incremental de.nition of effects. \nIn particular, the syntax and semantics of CBPV include nothing like the generic monadic re.ection operators; \ninstead, the semantics of a language with any.xed notion of effects is de.ned in terms of a customized \nreduction relation, with specialized rules for the effect-operations. There has been a fair amount of \nwork on generic operational semantics for effects and related constructs. Some, like ours, is based on \nassigning operational interpretations to denotational or categorical constructions. In particular,there \nis long line of research by Plotkin and Power (e.g., [18]) on relating the operational and categorical \nformulations of so-called algebraic effect operations roughly, the re.ect-like ones in our terminology. \nThis work has re\u00adcentlybeenextendedtoalso accountfor someeffect-delimitingop\u00aderations i.e., reify-likeones \n such asexception handlers [19],but itdoesnotyetcoverthefull rangeof monadiceffectsfamiliarfrom functional \nprogramming. On the other hand, it seems well suited for modeling several important effects that are \nnot even conceptu\u00adally de.nable within the language, such as true nondeterminism, as interpreted using \na powerdomain. Other investigations start directly with an operational view, and propose systems apparently \ngeneral enough to model most effects of common interest. This includes in particular Mosses s Modular \nSOS [14], based on labelled transition systems. Another interest\u00ading approachis Pfenning sdestination-passing \nstyle [15]. Bothgive severalexamplesofhow commoneffects canbe represented,butit seems hard to delimit \nthe exact spectrum of computations express\u00adible in those frameworks, or to relate the encodings to the \notherwise very successful denotational/monadic models of the same effects. There is also a successful \ntradition of modeling a variety of computational effects in primarily functional languages, in terms \nof evaluation-context manipulation [3], either by custom reduction rules for particular effect-operations, \nor by exposing the context\u00admanipulating power to the programmer through suf.ciently pow\u00aderful general \ncontrol operators (e.g., [8, 9]).For several individual effects, the resulting operational rules end \nup quite similar to our monad-based ones,but a signi.cant conceptual difference is that our model is \nultimately based on a hierarchical composition of ef\u00adfects, whereas most continuation-based ones take \na more liberal, .at approach, imposing no particular ordering on the components being combined, as outlined \nin Section 4.3.  Aparticularly intriguing example of such a .at composition of effects is the early \nwork by Cartwright and Felleisen on extensi\u00adble denotational semantics [1]. Though the pattern of splitting \nthe semantics of effect-like language features into handlers and re\u00adquests isvery similarto ours, their \npresentationis ultimately about a domain-theoretic presentation of an operational idea whereas we give \nan operational account of language constructs originally motivated by a denotational/categorical semantics. \nWhile notionsofeffects based directlyon continuationsoreval\u00aduation contexts are evidently at least as \nexpressive as the one proposed here (indeed, the representation of layered monads in terms of delimited \ncontinuations [4] uses a particularly restricted continuation-manipulating operator), this expressivity \ncomes at a price: thereisin generalno simplewayof characterizingtheextent to which a term does not exploit \nthe full power of context manip\u00adulation, and therefore can be reasoned about in ways that are un\u00adsoundfor \ntermswith unrestrictedeffects.We proposethe monadic\u00adre.ection abstraction as precisely such a characterization. \n6. Conclusions and future work Though monadic effects are usually thought of in denotational terms, and \nin an inherently typed, Church-style setting, our results show that, somewhat surprisingly, they can \nalso be given a purely Curry-style semantics. That is, the generic operations for invoking and delimitingeffectshave \nan intrinsic operational meaning,given by an simple, effect-independent notion of reduction, and de.ned \nby a small, .xed collection of rules. Yet, in concrete examples, these.xedrulescloselyagreewithhowonewould \nde.netheeffect by hand . It is hoped that the results, and natural extensions of them, can be used to \nstrengthen the interplay of operational and denotational techniques for reasoning about programs with \neffects. The framework presented here allows us to understand a monadiceffectintwocomplementaryways: \neitherwe.xthe mean\u00adings of the effectful operations to be their monad-based de.nitions, and translate \nthe program around them to .t those meanings; or we .x the semantics of programs, and transform the monad-based \nde.nitions of the operations into specialized operational rules that can be merged directly into the \n.xed evaluation judgment.Work certainly remainstobedonein formally relatingthetwoviews,but already the \nresults and examples presented here should illustrate the viability and utility of the basic principle. \nFurther topics to explore include practical effect-type inference for the system, as well as extensions \nwith various notions of poly\u00admorphism.In particular, one might consider .ner notionsof subef\u00adfecting, \nsuch as letting the exception monad be parametrized by anexplicit setofexception names,tokeep precise \ntrackof which exceptions are raised or handled where. Another useful addition would be a notion of typed \ndynamic allocation as a primitive base effect, to allow sound modeling of dynamically created ref-cells \nof arbitrary types. The operational semantics, being type-free, should not need any signi.cant changes \nor extensions, but the transla\u00adtional/denotational account would need a re.nement to possible\u00adworld or \nfunctor-category semantics. Finally, it is a little disconcerting that, though the operational semantics \nitself is reduction-based, its ultimate justi.cation is still denotational,inthatthe monadlaws(and theirextensionsto \nmonad morphisms, algebras, etc.) all talk about equality, not reduction. This dependence may not be easy \nto eliminate: for more interesting monads, involving type-level recursion (such as streams or search \ntrees), the easiest way to prove the monad laws is apparently by domain-theoretic methods, such as rigid \ninduction [6], which ulti\u00admately reduce to reasoning about minimal invariants. Ultimately, however, such \nprinciples could probably also be ported to an oper\u00adational setting [2], making the whole treatment self-contained. \nReferences [1] Robert Cartwright and Matthias Felleisen. Extensible denotational language speci.cations. \nIn Masami Hagiya and John C. Mitchell, editors, Symposium on Theoretical Aspects of Computer Software, \nvolume 789 of Lecture Notes in Computer Science, pages 244 272, Sendai, Japan, April 1994. [2] Karl Crary \nand Robert Harper. Syntactic logical relations for polymor\u00adphic and recursive types. Electronic Notes \nin Theoretical Computer Science, 172, 2007. [3] Matthias Felleisen and Robert Hieb. The revised report \non the syn\u00adtactic theories of sequential control and state. Theoretical Computer Science, 103(2):235 \n271, September 1992. [4] Andrzej Filinski. Representing layered monads. In Proceedings of the 26thACM \nSIGPLAN-SIGACT Symposium on Principles of Program\u00adming Languages, pages 175 188, San Antonio,Texas, January \n1999. [5] Andrzej Filinski. On the relations between monadic semantics. Theo\u00adretical Computer Science, \n375(1-3):41 75, 2007. [6] Andrzej Filinski and Kristian St\u00f8vring. Inductive reasoning about ef\u00adfectful \ndata types. In ICFP 07: Proceedings of the 2007ACM SIG-PLAN International Conference on Functional Programming, \npages 97 110.ACM Press, October 2007. [7] Marcelo Fiore and Gordon D. Plotkin. An axiomatisation of compu\u00adtationally \nadequate domain theoretic models of FPC. In Proceedings of the Ninth Symposium on Logic in Computer Science, \npages 92 102, Paris, France, 1994. [8] CarlA. Gunter, DidierR\u00b4emy,andJonG. Riecke.Ageneralizationof exceptions \nand control in ML-like languages. In Functional Program\u00adming and Computer Architecture, pages 12 23, \n1995. [9] OlegKiselyov,Chung chieh Shan, and Amr Sabry. Delimited dynamic binding. In ICFP 06: Proceedings \nof the 11th International Confer\u00adence on Functional Programming, pages 26 37, 2006. [10] Paul Blain Levy. \nCall-by-push-value: Decomposing call-by-value and call-by-name. Higher-Order and Symbolic Computation, \n19(4):377 414, 2006. [11] Saunders Mac Lane. Categories for the Working Mathematician, volume5of GraduateTextsin \nMathematics. Springer-Verlag, 1971. [12] Eugenio Moggi. Computational lambda-calculus and monads. In \nProceedings of theFourth Annual Symposium on Logic in Computer Science, pages 14 23,Paci.c Grove, California, \nJune 1989. IEEE. [13] Luc Moreau. Asyntactic theory of dynamic binding. Higher-Order and Symbolic Computation, \n11(3):233 279, 1998. [14] Peter D. Mosses. Modular structural operational semantics. Journal of Logic \nand Algebraic Programming, 60-61:195 228, 2004. [15] Frank Pfenning. Substructural operational semantics \nand linear destination-passing style (abstract). In Proceedings of the 2nd Asian Symposium on Programming \nLanguages and Systems (APLAS 04), volume 3302 of Lecture Notes in Computer Science, page 196, 2004. [16] \nFrank Pfenning and Carsten Sch\u00a8urmann. System description:Twelf ameta-logical framework for deductivesystems. \nIn16th International Conference onAutomated Deduction, volume 1632 of Lecture Notes in Computer Science, \npages 202 206, 1999. [17] Benjamin Pierce. Types and Programming Languages. MIT Press, 2002. [18] Gordon \nD. Plotkin and John Power. Algebraic operations and generic effects. Applied Categorical Structures, \n11(1):69 94, 2003. [19] Gordon D. Plotkin and Matija Pretnar. Handlers of algebraic effects. In 18th \nEuropean Symposium on Programming, volume 5502 of Lecture Notes in Computer Science, pages 80 94, March \n2009. [20] PhilipWadler. Comprehending monads. In Proceedings of the 1990 ACM Conference on Lisp and \nFunctional Programming, pages 61 78, Nice, France, June 1990. [21] Andrew K. Wright and Matthias Felleisen. \nA syntactic approach to type soundness. Information and Computation, 115(1):38 94, 1994.   \n\t\t\t", "proc_id": "1706299", "abstract": "<p>In functional programming, monadic characterizations of computational effects are normally understood denotationally: they describe how an effectful program can be systematically expanded or translated into a larger, pure program, which can then be evaluated according to an effect-free semantics. Any effect-specific operations expressible in the monad are also given purely functional definitions, but these definitions are only directly executable in the context of an already translated program. This approach thus takes an inherently Church-style view of effects: the nominal meaning of every effectful term in the program depends crucially on its type.</p> <p>We present here a complementary, operational view of monadic effects, in which an effect definition directly induces an imperative behavior of the new operations expressible in the monad. This behavior is formalized as additional operational rules for only the new constructs; it does not require any structural changes to the evaluation judgment. Specifically, we give a small-step operational semantics of a prototypical functional language supporting programmer-definable, layered effects, and show how this semantics naturally supports reasoning by familiar syntactic techniques, such as showing soundness of a Curry-style effect-type system by the progress+preservation method.</p>", "authors": [{"name": "Andrzej Filinski", "author_profile_id": "81100252096", "affiliation": "University of Copenhagen, Copenhagen, Denmark", "person_id": "P1911151", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706354", "year": "2010", "article_id": "1706354", "conference": "POPL", "title": "Monads in action", "url": "http://dl.acm.org/citation.cfm?id=1706354"}