{"article_publication_date": "01-17-2010", "fulltext": "\n Paralocks Role-Based Information Flow Control and Beyond Niklas Broberg Department of Computer Science \nand Engineering, University of Gothenburg and Chalmers University of Technology, Sweden d00nibro@chalmers.se \n Abstract This paper presents Paralocks, a language for building expressive but statically veri.able \n.ne-grained information .ow policies. Par\u00adalocks combine the expressive power of Flow Locks (Broberg \n&#38; Sands, ESOP 06) with the ability to express policies involving run\u00adtime principles, roles (in the \nstyle of role-based access control), and relations (such as acts-for in discretionary access control). \nWe illustrate the Paralocks policy language by giving a simple en\u00adcoding of Myers and Liskov s Decentralized \nLabel Model (DLM). Furthermore and unlike the DLM we provide an information .ow semantics for full \nParalock policies. Lastly we illustrate how Paralocks can be statically veri.ed by providing a simple \nprogram\u00adming language incorporating Paralock policy speci.cations, and a static type system which soundly \nenforces information .ow secu\u00adrity according to the Paralock semantics. Categories and Subject Descriptors \nD.3 [PROGRAMMING LAN-GUAGES]; F.3.1 [LOGICS AND MEANINGS OF PROGRAMS]: Specifying and Verifying and Reasoning \nabout Programs General Terms Security, Languages, Veri.cation 1. Introduction Issues of software security \ncan be crudely categorized into three broad domains: Access control deals with security at the end points \nof a system, to verify that an entity is allowed to access the system, and to what extent.  Information \n.ow control deals with security inside asystem, between the end points, to ensure that data in the system \nis han\u00addled in a way that agrees with the security policy of the system. This is the domain that is most \ninteresting from a programming language point of view, since it deals with security during exe\u00adcution. \n Encryption deals with security outside a system, to ensure that data can be protected even outside \nthe trusted system environ\u00adment.  The problems involved in research on encryption are quite dif\u00adferent \nfrom the other two domains, but unsurprisingly there are Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. POPL 10, January 17 23, 2010, Madrid, Spain. Copyright \nc &#38;#169; 2010 ACM 978-1-60558-479-9/10/01. . . $10.00 David Sands Department of Computer Science \nand Engineering, Chalmers University of Technology, Sweden dave@chalmers.se many similarities between \nproblems that arise in the access con\u00adtrol and information .ow control domains. In particular, problems \nregarding policy speci.cation and modelling of principal actors are quite similar, much due to the fact \nthat these issues are not purely technical, but rather relate to the interface between the system and \nits users (implementor, admins). Thus, many ideas relevant in one domain are equally applicable to the \nother, at least on a high level. In the access control domain there exists plenty of research regarding \npolicy speci.cation mechanisms. Such mechanisms have traditionally been categorized into two separate \ngroups: Mandatory (or static) access control (MAC), where an outside administrator assigns static privileges \nto principals, and Discretionary access control (DAC), where principals themselves can grant and revoke \nprivileges to and from other principals. A later addition to the family of models is Role-based access \ncontrol (RBAC) [SCFY96], which has become very popular and has seen wide-spread adoption both commercially \nand academically. On the information .ow control side, there has been far less focus on policy speci.cation. \nWe surmise that this has a very natural cause. In access control, which deals with the interfaces to \na system, policy speci.cation is the one core issue and a prerequisite for any further aspects of security. \nInformation .ow control on the other hand is more naturally focused towards issues of semantic security \nwith respect to a policy, and most research in the domain has been devoted in that direction. Papers \non information .ow control issues typically fall into one of two categories where the policy mechanism \nused is concerned. In the .rst category we .nd those that use a simple model built around a lattice of \nprincipals or sets of principals, going back to Denning s early ground-breaking work. The other category \nis the research that builds on the Decentralised Label Model (DLM), which is today something of a .agship \nof information .ow control through its implementation in JIF. These two categories can somewhat crudely \nbe said to correspond to the MAC (static Denning-style lattice) and DAC (decentralised and discretionary) \nmodels. Interestingly and perhaps surprisingly there has been almost no work on marrying a fundamentally \nrole-based model to information .ow control (the exceptions being [SHTZ06, BWW08] which are discussed \nfurther in Section 8), despite the massive attention RBAC has received in the access control domain, \nboth commercially and academically. The use of roles in an information-.ow setting is discussed in Section \n2. In this paper we present Paralocks (Section 3), a language for building expressive but statically \nveri.able .ne-grained informa\u00adtion .ow policies. Paralocks is based on the simple and expressive idea \nof Flow Locks [BS06] extended with the ability to express policies modelling roles (in the style of RBAC) \nand run-time prin\u00adcipals. The extension (parameterised locks) turns out to provide much more than just \nthe ability to model roles: we show (Section 4) how relations such as delegation in discretionary access \ncontrol can be represented by policies, and use this to give a sound and complete encoding of the Decentralised \nLabel Model [ML97].  Unlike the Decentralised Label Model we also provide an infor\u00admation .ow semantics \nfor Paralocks (Section 5). This de.nes what it means for a program (whose state components are labelled \nwith policies) to be secure. As an illustration of how paralocks can be integrated into a programming \nlanguage we give (Section 6) an example of a small programming language with a paralock type system for \nwhich we show that well-typed programs satisfy the semantic information .ow condition. Finally (Section \n7) we outline a logically natural extension to the paralocks policy language to include recursively speci.ed \nlocks (DATALOG rules). Our aim with this work is really two-fold. On the one hand we present the policy \nspeci.cation language Paralocks. We show how Paralocks naturally models roles, but also actors, groups \nand gen\u00aderal relationships in a simple and structured way. On the other hand, we also present Paralocks \nas a very general framework for infor\u00admation .ow control. This aspect lets us use Paralocks to reason \nabout and give meaning to other mechanisms both current and fu\u00adture. Paralocks thus serves as a platform \nthat can greatly simplify further research into various aspects of information .ow control, such as specialised \npolicy speci.cation languages, and the relation\u00adship between information .ow control and programming \nlanguage design.  2. Roles and Information Flow Roles are a natural concept in an organisational structure \nand are just as naturally tied to information .ow controls as to access control. Consider a department \nconsisting of managers, personnel and sales. These roles form a hierarchy as illustrated in the Hasse \ndiagram below: Manager /\\ Personnel Sales In role-based access control each role represents a set of \nusers (later we will use the neutral term actors) endowed with a set of permis\u00adsions. The hierarchy illustrated \nin the .gure (roles + hierarchies are referred to as RBAC1 in the RBAC96 model [FSG+01]) represents the \nintention that the permissions granted to higher roles subsume those granted to lower roles. Let us suppose \nthat we take an information .ow perspective on roles and we assume data is labelled with a role, representing \nthe permission to gain information about that data. Then role\u00adbased information .ow control would simply \nbe the constraint that information may only .ow upwards in the hierarchy. This is simply the Denning \nlattice-based model [Den76] with a relaxation on the requirements that the hierarchy forms a complete \nlattice. In this setting the assignment of users to roles is of little direct concern from an information \n.ow perspective, since users do not possess their own data, and are de.ned purely by the roles to which \nthey are assigned. Inputs and outputs of the system would then be bound to roles, and some external mechanism \nwould mediate the connection between roles and users. However, if we admit the possibility of personal \ndata then the information .ow perspective becomes considerably richer. For ex\u00adample, if we had I/O channels \ndirectly to users then we would have an information .ow problem with a dynamic policy: information .ows \nto and from a given actor would depend on her current role. Consider another scenario involving personal \ndata: an auction site managing sealed-bid auctions for an apriori unspeci.ed num\u00adber of users. In such \na scenario the roles of seller and bidder, re\u00adspectively, immediately spring to mind. Other constraints \non the auction in.uence the intended information .ows: the seller can set a reserve price which is initially \nonly visible to the seller;  bidders provide sealed bids and can see their own bid but cannot see each \nothers bids;  bidders learn of the winning bid, but only at the end of the auction;  if the reserve \nprice is not met then there is no winning bid;  sellers cannot also be bidders for the same item.  \nIn summary, to verify that code managing such auctions is well behaved raises a number of general challenges \nfrom an information .ow perspective: 1. We need to model dynamic actors actors whose concrete identity \nis not known or may not exist until runtime. 2. The data associated with a role (e.g. the bids) belongs \nto the actor and not the role (because bidders should not be able to see all bids -only their own bid). \n 3. Permissions associated with roles are assigned dynamically (in this example, the ability to read \na winning bid is only granted after the auction is complete). 4. Declassi.cation is required: the winning \nbid (or its absence) provides partial information about the secret reserve price of the seller. 5. We \nmust be able to impose role constraints (a la RBAC2) to ensure that the seller cannot become a bidder \non the same item.  In the next section we develop a policy language which is aimed at meeting these \nchallenges. The policy language is built on top of .ow locks, a versatile policy language for dynamically \nchanging information-.ow policies. The extension in question is motivated by the addition of roles. As \nwe will show in the subsequent section (4), the extension turns out to provide considerably more than \njust the ability to represent roles.  3. Flow Locks and Roles Flow locks are a simple security policy \nspeci.cation mechanism. Flow locks themselves are policy neutral they do not presup\u00adpose any particular \nlabels, information .ow levels, or .xed hierar\u00adchy. The core idea is to logically specify the conditions \nunder which a given actor in the system may gain information about some data. We use the phrase gain \ninformation rather than access at this point to stress that this is an information .ow notion rather \nthan an access control one. The conditions are speci.ed using so called locks, which are boolean variables \nthat may be manipulated by the execution of the program. A policy is then a set of logical clauses of \nthe form S . a (so called Horn clauses), where each clause spec\u00adi.es the conditions (S) under which data \nlabelled with that policy may .ow to actor a. S is a set of locks, which we interpret as a conjunction, \ni.e., for a to have access to the data then all locks in S must be true. The set of clauses is itself \ninterpreted as a conjunction, so for an actor to have access it is enough that one clause allows it (a \nconjunction of implications is equivalent to a disjunction of the premises). Consider a simpli.ed form \nof the auction example in which we have two known buyers B1 and B2 and a single seller S and where the \nbidders may see each other s bids once they have placed their own. We associate two locks, bid1 and bid2 \nwith the placing of bids by B1 and B2 respectively; bidi will be assumed to become true once Bi has placed \nhis bid. Then the policy for B1 s bid is  {S; B1; bid2 . B2} . This says that the B1 s bid may .ow to \nS and B1 unconditionally, and may .ow to B2 only when B2 has placed a bid (as modelled by lock bid2). \nUsing the terminology of .ow locks, when a condition repre\u00adsented by a lock becomes true, we say that \nthe lock is opened.Sim\u00adilarly when is becomes false we say that it is closed. Consider a further example \nfrom [BS09] represented in Figure 1 which depicts three Denning-style information-.ow lattices. Figure \n1. Example Dynamic Policy In the leftmost lattice Alice is the top element. While Alice is boss all information \nmay .ow to her. If she is demoted, how\u00adever, then the information .ow lattice changes to the central \n.gure. From there either Bob or Alice can be promoted to be the boss. Let us consider how to encode this \nintended scenario with .ow locks. To represent this dynamic .ow policy we begin, not surprisingly, by \nassuming three actors: Alice, Bob,and Joe. To model the transi\u00adtions between policies we use two locks: \npromoteA and promoteB. The events of promotion and demotion are modelled by the respec\u00adtive opening and \nclosing of these locks. When promoteA is open then Alice is boss. Closing promoteA (respectively, promoteB)cor\u00adresponds \nto demoting Alice (resp. Bob). To complete the picture we need to describe the corresponding policies \nfor the data to be associated with Alice, Bob, and Joe. Joe is the simplest case, and his data has policy \n{Joe; Alice; Bob} i.e. it is readable by everyone at all times. Alice s data has pol\u00adicy {Alice; promoteB \n. Bob} and Bob has the symmetric policy {Bob; promoteA . Alice}. For Bob this means that his data is \nreadable by Alice only when Alice has been promoted. Note that if both locks are open then we have a \nsituation not modelled in the .gure: Alice and Bob become equivalent from an information .ow perspective. \nIf we want to rule this out we cannot do so using the policy on data, instead we must enforce this via \nan invariant prop\u00aderty of the locks themselves. The reason for keeping the guards as simple boolean .ags \nrather than arbitrary logical expressions is that this makes it possible to mechanically check that programs \nconform to a .ow lock policy using a type system. Ensuring that locks are open at appropriate times is \nan application-speci.c problem that can be seperately veri.ed using a general purpose theorem prover, \nfor example. To track information .ow in a program, data labelled with some policy p1 is allowed to .ow \nto a location with a different policy p2, assuming that p2 is more restrictive than p1.This ordering \nof policies, which we write p1 . p2, corresponds naturally to logical entailment when viewing policies \nas Horn clauses. In fact, it is easy to show that policies form a lattice, where the join and meet of \ntwo policies correspond to logical disjunction and conjunction respectively, and the partial ordering \nis logical implication as noted. But whether a .ow is permitted obviously also depends on the current \nlock state, to allow for e.g. declassi.cation. To this end we express the comparison of policies in a \nspeci.c context by specialising a policy p to a particular set of locks S that are known to be open. \nFormally this is de.ned for .ow locks as p(S) = {. \\ S . x | . . x . p} and we allow data labelled with \npolicy p1 to .ow to a location with policy p2 provided that p1(S) . p2,where S is the lock state in effect \nat the time of the .ow. 3.1 Modelling roles A naive approach to supporting roles with Flow locks could \nbe to simply let the actors be the roles, and not have conventional actors at all. This would work with \nno changes to the current policy language, however as our examples in the previous section have shown, \nwe often need to reason about both roles (or groups) and individual actors. Thus we need a different \napproach to roles that retains the notion of an actor. Looking at what it means for some data to be accessible \nto a role R, the natural interpretation is that an actor may gain information about that data if the \nactor is a member of R. How do we express this as a .ow lock policy? We need a lock that captures the \ncondition that a is a member of role R , which we henceforth write R(a). But clearly the policy we want \nis not just for some speci.c actor a, but rather any actor x for which R(x) holds. Logically we could \neasily write this as .x. R(x)=. x.A role thus has a natural representation as a lock family, parametrised \nby actors. To achieve this we propose two separate though synergistic extensions to the basic formulation \nof .ow locks from [BS06]: Parameterised Locks Locks which are parameterised over actors represent role \nmemership. For example the role Seller is rep\u00adresented as parameterised lock family, so if a is an actor \nthen Seller(a) is a lock which models a being a member of the seller role. Data labelled with the policy \n{Seller(a) . a} is permit\u00adtedto.ow to a providing that a is a seller. Actor Polymorphism To make parameterised \nlocks practically useful we also need to be able to quantify over all actors, so that we could instead \nwrite the policy as {.x. Seller(x) . x} meaning that data labelled with this policy may .ow to any seller. \nWith this interpretation of roles, and these extensions to the policy speci.cation language, we can easily \nformulate the policies from the examples in the previous section using .ow locks. Let us then return \nto the challenges offered by those examples: 1. Actors whose concrete identity is not known until run-time \ncan be handled by policies with actor polymorphism. As a simple example, the policy {.x. x} is the most \nliberal policy, permitting its data to .ow to any actor at all times. This does not require us to know \nthe identity of all actors at policy creation time (as would be required using the original basic .ow \nlocks mechanism). 2. Fine grained policies at the level of individual actors combine easily with roles. \nFor example, suppose we wish to generalise the scenario in Figure 1 to an organisation of 1000 employees \n or a situation with an unknown number. Here we must combine a role (the boss) with the requirement that \nnon-bosses cannot obtain information from each other (with the exception of Joe). The data of Joe would \nhave policy .x. x it can .ow to anyone. The data for any other individual a would have the policy {a; \n.x. Boss(x) . x}, which means that data labelled with this policy can .ow to a and anyone who is a boss \n(at the time of the .ow). 3. Permissions associated with roles are assigned dynamically by using standard \n(non-parameterised) locks. For example, the   largest bid might be stored in a variable with policy \n{.x. {AuctionClosed , Bidder(x)}. x} where the vanilla lock AuctionClosed represents the property that \nthe auction is complete and the reserve has been met. So in effect AuctionClosed represents the condition \nunder which the Bidder role is assigned the permission to learn about the winning bid. 4. Declassi.cation \nis inherited from the standard .ow locks model. For example, the reserve price is available to the seller, \nbut is declassi.ed to bidders providing there is a winning bid: {Seller; .x. {AuctionClosed , Bidder(x)}. \nx} 5. Role constraints here the requirement that e.g. there is a single seller, and that seller and \nbuyer cannot be the same actor can be established by runtime invariants for .ow locks. These can either \nbe veri.ed statically or enforced dynamically using a runtime representation of locks. In Section 7 we \ndescribe an extension which permits certain constraints on roles to be speci.ed as part of the policy. \n 3.2 The Paralocks Policy Language Now it is appropriate to summarise the policy language of this paper, \nand de.ne its lattice structure. In summary, the policy language generalises .ow locks policies with \nactor-parametrised locks, hence the name: Paralocks. The ordering on policies is based on a straightforward \nand natural logical interpretation of policies. DEFINITION 3.1 (Paralock Policies). Policies are built \nfrom actor identi.ers, ranged over by a, b, etc. and parameterised locks, ranged over by s, s' etc. Each \nparameterised lock has a .xed arity, arity(s) = 0.  A lock is a term s(a1,...,an),where arity(s)= n.Let \nS, S' range over sets of locks.  A clause c is a term of the form .a1,...,an. S . a.  A policy p is \na set of clauses written { c1; ... ; cn}.  We have already adopted a number of syntactic abbreviations \nin earlier examples: we write just s instead of s() in the case that arity(s)=0. Similarly we drop the \nquanti.er on clauses when there are no quanti.ed variables. When the lock set S in a clause is empty, \nas in .a1,...,an. \u00d8 . a we write .a1,...,an.a.We will routinely write ba to denote some sequence a1,...,an.Such \na sequence will be treated as a set {a1,...,an} when the context permits us to do so without ambiguity. \nPolicies have a natural reading as conjunctions of de.nite .rst\u00adorder Horn clauses. Each clause .a1,...,an. \n{ s1(bb1); ... ; sm(bbm)}. a can be read as the Horn clause .a1,...,an. (s1(bb1) . \u00b7\u00b7\u00b7 . sm(bbm)) . Flow(a) \nwhere Flow is a single unary predicate disjoint from the parame\u00adterised locks, representing the may .ow \nto property. Using this logical interpretation we obtain a natural lattice structure on policies, where \nthe policy ordering ( ) on individ\u00adual clauses is just logical entailment. Speci.cally, we de.ne pq whenever \np, viewed as a .rst order formula, entails q. We will write p |= q to denote this logical interpretation. \nFollowing this natural interpretation we have the following def\u00adinition: DEFINITION 3.2 (Policy ordering). \nPolicy p1 is less restrictive than policy p2, written p1 p2,if .c2 . p2. .c1 . p1.c1 c2, where the ordering \non clauses is de.ned to be the least partial order (re.exive and transitive relation) satisfying the \nfollowing: if c1 and c2 are equal up to (i) capture-free renaming of .\u00adbound actors (ii) reordering \nof quanti.ed actors and (iii) dele\u00adtion of .-bound actors not occurring in the body of the clause, then \nc1 c2;  .a1,...,an. S1 . b ..a1,...,an. S2 . b if S1 . S2.  .a0,a1,...,an. S . a ..a1,...,an. ((S . \na)[a0 := b]), where [a0 := b] denotes the unconstrained substitution of b for a0.  We do not present \na formal proof that this corresponds to the logical interpretation (in fact we did not spot the connection \ndirectly), but we note that clauses are equivalent to so-called conjunctive queries [CM77], and a policy \nthus a union of conjunctive queries. The ordering on clauses de.ned above can be seen as a construction \nof a containment mapping [Ull90]. The fact that .c2 . p2. .c1 . p1.c1 c2 is necessary and suf.cient to \ncheck logical entailment of unions of conjunctive queries was established in [SY80]. At any point during \nprogram execution, the permitted .ows will depend on the locks which are open at that point. To determine \nwhether pq in the context of some open locks S, we check the logical implication S . p |= q. In the type \nsystem given in Section 6 we implement this check via the specialisation of policy p to a lock state \nS, written p(S); we then check that p(S) q. The meet operation on policies is simple to de.ne as it corre\u00adsponds \nexactly to conjunction of (sets of) Horn clauses. In our lan\u00adguage, that means taking the union of the \nclauses of two policies, i.e. p1 n p2 = p1 . p2. The join operation however is more tricky. Logically \nit corre\u00adsponds to a best approximation of disjunction of Horn clauses, since in general (sets of) Horn \nclauses are not closed under dis\u00adjunction. I.e. p U q is the least policy such that p . q |= p U q.We \ncan de.ne the join directly as follows: DEFINITION 3.3 (LUB). In the following it is convenient to parti\u00adtion \nactor variables in to .-bound variables ranged over by x, by, and free actor variables (i.e. actor constants) \nranged over by a and b. We write S . b to denote the policy .by are the y. S . b where b.-bound variables \nof S . b.  Let p and q be policies. We will assume, without loss of general\u00adity, that all .-bound variables \nappearing in the head of any clause are named x, and that any other .-bound variables in any clause from \np are distinct from the .-bound variables of q. Then we de.ne p U q = {Sp . Sq . x | Sp . x . p;Sq . \nx . q} .{Sp . Sq . a | Sp . a . p;Sq . a . q} .{Sp . (Sq [x := a]) . a | Sp . a . p;Sq . x . q} .{(Sp[x \n:= a]) . Sq . a | Sp . x . p;Sq . a . q} It can be shown that the set of paralock policies (quotiented \nby the equivalence relation generated from ) form a complete lattice. We will not go into the proof here, \nbut simply note the least (most liberal) policy . = {.x. x} and the greatest (most restrictive) policy \nT = {}, which will be needed later. The reader may have noticed that the policy language de.ned here \ncan contain locks parameterised over more than a single actor. This gives us more expressive power than \njust roles. In the next section we motivate and illustrate this generalisation.  4. From Roles to Relations: \nEncoding the Decentralized Label Model Using actor-indexed lock families we have shown how we can model \nroles along-side speci.c actors in a natural logical setting, and how the two can co-exist in the same \nprogram. In this section we will show how, using a natural generalisation, we can model policies where \ninformation .ow can depend on relations between actors. Such relations are useful in the description \nof a decentralised discretionary security model.  The core components of a decentralised discretionary \nmodel is the concept of ownership,and an acts-for relationship (some\u00adtimes referred to as delegation \nor a speaks-for relation [LABW91]), where an actor a who acts for b enjoys the same rights as b.In particular \nif actor a owns some data then b has full access to that data if b acts for a. The condition under which \nb may access the data is thus that b acts for a . Logically this is easily mod\u00adelled with a binary relationship \nbetween actors, which in the .ow locks setting would naturally correspond to a lock family with two parameters. \nThe policy mentioned here could then be written as {a; .x. ActsFor (a, x) . x}. Going from one to two \nparameters, or indeed to n-ary lock fam\u00adilies, is a straight-forward generalisation. There are no additional \ntechnical dif.culties involved, and we already have the mechan\u00adics for quanti.cation in place. (We have \nno immediate examples of lock families with more than two parameters, but see no reason to exclude them.) \nTypically, acts-for relationships are modelled with two other properties, namely re.exivity and transitivity. \nEach actor acts for himself. If a acts for b and b acts for c, then models typically as\u00adsume implicitly \nthat a acts for c as well. With Paralocks, proper\u00adties like transitivity and re.exivity are not built \nin. Locks are just boolean variables with no additional prede.ned semantics attached to them. If we want \na transitive property for a particular relation like ActsFor , we must handle this explicitly. A naive \nattempt could be to try to handle this on the policy level, e.g. by specifying the policy as {a; .x. \nActsFor (a, x) . x; .x, y. ActsFor (a, x), ActsFor (x, y) . y} This is not a viable approach since the \nabove policy only works for one step of transitivity; for full transitivity we would need to explicitly \nlist the transitive closure, and this would be at best cumbersome, and impossible if we could not statically \nenumerate all actors. There are two routes to deal with this issue. The .rst is to extend the expressive \npower of the policy language to enable such global invariants to be expressed as part of the policy. \nThis is explored in Section 7. For now we take a simpler route, and view transitivity not as a property \nof a policy, but rather an intended invariant on the set of locks open at any given time. This invariant \ncan easily be maintained at runtime by suitably encapsulating lock manipulation operations. So if we \nensure that any program using a policy involving delegation maintains the transitivity property of ActsFor \n,then it is enough for the policy to be stated (as before) as simply {a; .x. ActsFor (a, x) . x}. 4.1 \nEncoding the Decentralized Label Model To show the .exibility of our model, we show how it can be used \nto encode the Decentralized Label Model (DLM) of Myers and Liskov [ML97] 1. The core component of the \nDLM is the label. Data is decorated with labels that govern how that data may be used. A label L speci.es \nthe owners of some data, written owners(L), and for each owner the set of readers allowedbythat owner, \nreaders(L, o).The intuition behind the owners is that data, at its origins, has a single 1 In the earlier \n.ow locks work [BS06] we sketched a possible DLM encod\u00ading, but the encoding there required all principals \nto be known statically, so that all relations between principles could be hard wired into the policy. \nowner who speci.es its readers. The label on a piece of data re.ects the various potential origins of \nthe information in that data. The decentralisation relates to the readers. Each owner can independently \nspecify who they consider trusted to view the data. The effective readers of some data are those for \nwhom all the owners have agreed may read it, i.e. the intersection of the separate reader sets for all \nowners. A label for some data may look like {o1 : r1,r2 ; o2 : r2,r3} where o1 and o2 are owners and \nr1,r2 and r3 are readers. Such data might be obtained by combining data from o1 and o2 in some way. The \neffective readers in this example is just r2. A label L2 is said to be more restrictive than label L1, \nwritten L1 DLM L2, if it has at least the same owners, and each of those owners list fewer potential \nreaders. Formally it is de.ned [ML97] as L1 DLM L2 = owners(L1) . owners(L2) . .o . owners(L1). readers(L1,o) \n. readers(L2,o) Data may be relabeled in two ways, through an assignment: Data with label L1 can always \nbe assigned to a storage location (a container) with label L2 if L2 is more restrictive than L1,i.e. \nL1 L2.  Data can be declassi.ed by adding more readers for a given owner. In the DLM this can be done \nfreely providing that the current process runs on behalf of the owner in question.  Apart from labels, \nthere is one other important component to the DLM, namely the principal hierarchy and its associated \nacts\u00adfor relationship. The DLM lets principals represent both individual users and other notions like \nroles and groups, and membership for a user in a role can thus be modelled by letting the user act for \nthat role. The acts-for relationship is transitive and re.exive. This has two effects on the security \nof a program. First, if a acts for b and b is listed as a reader in a label, then a is also implicitly \na reader. Second, if a piece of code runs on behalf of a,then it also implicitly runs on behalf of b, \nso code running on behalf of a may conduct declassi.cations in b s name. To encode the DLM using Paralocks, \nwe need to represent a number of things explicitly that are implicit in the DLM. The .rst of these is \nthe acts-for relationship, which we ve already discussed how to model earlier in this section. If the \nprincipal hierarchy states that b acts for a, then we expect the ActsFor (a, b) lock to be open. We can \naccount for changes to the hierarchy during execution by opening or closing the appropriate locks. We \nexpect a concrete semantics to maintain the invariants for transitivity and re.exivity for the ActsFor \nrelationship as previously discussed. Second, to account for declassi.cation being possible only when \nthe process runs with the authority of the owner of the declas\u00adsi.ed data, we need a lock family RunsFor \n(a). We expect the ap\u00adpropriate locks to be open for those actors for whom the code runs. Further, we \nalso expect the invariant that whenever ActsFor (a, b) and RunsFor (b) is open then RunsFor (a) is also \nopen, again making the implicit relationship explicit. Third, since Paralocks take the perspective of \nthe reader, as op\u00adposed to the owner as in in DLM, the policy needs to be explicit about the potential \nfuture readers to whom the data may be de\u00adclassi.ed. With respect to a given owner, we can freely add \nnew readers as long as the code executes with that owner s authority. We can thus model the label {o \n:},i.e.data owned by o with no added readers, with the policy {.x. RunsFor (o) . x}  The intuition here \nis that in code running with o s authority, this data may be declassi.ed to any actor x. 2 Adding a reader \nto the above policy, we get {o : r}, which we would represent as {.y. ActsFor (r, y) . y; .x. RunsFor \n(o) . x} The .rst clause here corresponds to the reader r. By re.exivity we will always have ActsFor \n(r, r) open, and hence r, and anyone else who acts for r, will be able to read data labelled with this \npolicy. To handle the general case of the encoding we need to deal with the case of a potential reader \n(a reader who is a reader for one but not all owners). For these readers we need to consider the owners \nwho do not permit r to read the data. DEFINITION 4.1 (Label Encoding). Suppose that r is a (potential \nor effective) reader for some label L, and O is a subset of owners for L. We say that the pair (O, r) \nis a con.ict pair for label L if O = {o | o . owners(L),r . readers(L, o)} . Intuitively, O are the owners \nwho have not permitted r to read data labelled L. Now we can de.ne the general encoding of Labels as \npolicies [[\u00b7]] : Label . Policy by [[L]] = {.x. {RunsFor (o) | o . owners(L)}. x} .{.y. RunsFor (o1),..., \nRunsFor (on), ActsFor (r, y) . y | ({o1,...,on} ,r) is a con.ict pair for L} The .rst clause in the de.nition \nof [[L]] says that data can be declassi.ed to anyone providing it is in a context which runs with the \nauthority of all owners. Otherwise a potential reader r (or anyone who acts for r) may read providing \nit does so in a context which runs with the authority of those owners who did not grant explicit access \nto r. As an example, consider the encoding of the empty label: [[{}]] = {.x. {} . x}.{} = {.x. x} The \nempty label has no owners, so implicitly anyone can read data with that label as expressed explicitly \nin the .ow locks encoding. When combining labels from different data sources, the DLM simply performs \nthe union of the respective owner policies, leaving the effective reader set implicit as the intersection \nof all readers. In our encoding the difference between effective and potential readers is rendered more \nexplicit. Consider combining the two policies representing {o1 : r1,r2} and {o2 : r2,r3}, which are [[{o1 \n: r1,r2}]] = {.x. RunsFor (o1) . x; .y. ActsFor (r1,y) . y; .y. ActsFor (r2,y) . y} [[{o2 : r2,r3}]] \n= {.x. RunsFor (o2) . x .y. ActsFor (r2,y) . y; .y. ActsFor (r3,y) . y} 2 Note that in a programming \nlanguage enforcing a DLM (such as JFlow/Jif [Mye99, MZZ+06]) one might want to additionally constrain \nthat declassi\u00ad.cation occurs at explicitly declared places in the code. This is easily mod\u00adelled using \nregular .ow locks by associating a Declassify lock with the por\u00adtion of code which is designated as a \ndeclassi.cation. This, however, is not part of the DLM model. we get [[{o1 : r1,r2}UDLM {o2 : r2,r3}]] \n=[[{o1 : r1,r2 ; o2 : r2,r3}]] ={.x. RunsFor (o1), RunsFor (o2) . x; .y. ActsFor (r2,y) . y; .y. RunsFor \n(o2), ActsFor (r1,y) . y; .y. RunsFor (o1), ActsFor (r3,y) . y} =[[{o1 : r1,r2}]] U[[{o2 : r2,r3}]] Finally \nwe can show that the lattice of labels in the DLM is a sublattice of the Paralocks policy lattice: THEOREM \n4.1. L1 DLM L2 if and only if [[L1]] [[L2]]. Further, [[L1 UDLM L2]] = [[L1]] U[[L2]], and similarly \nfor n. The proof of these properties is given in the extended version of the paper. The relationship \nbetween and DLM amounts to saying that the encoding is sound and complete with respect to the DLM rule \nfor relabelling data. What we have given here is an encoding of the DLM policy speci.cation language \nonly. One might expect to see a deeper com\u00adparison, in which we also compare the impact of the two on \nthe security of programs, i.e. the formal semantic security de.nitions. The problem is that the DLM, \nor more accurately its implementa\u00adtion in JIF, does not have a formal semantic security model. There \nexist models for subsets or restricted scenarios for DLM, but it has never been covered in full. But \nwith our encoding here, we are ac\u00adtually able to do just that, to provide a semantic security model for \nprograms that use the DLM for their information .ow control. Our full semantic model will be presented \nin the next section.  5. Paralock Security In previous work [BS09] we have developed a simple and accu\u00adrate \ncontext-sensitive security model for .ow locks based on un\u00adderstanding when an attacker s knowledge about \ninitial data values is permitted to increase, developed as a generalisation of the simple gradual release \nde.nition [AS07]. The semantic model developed in this section is an extension of the simple .ow locks \nmodel from [BS09]. The difference is that we must handle both runtime actor allocation and runtime querying \nof the lock state, both of which may be sources of information .ow. 5.1 Computation Model We assume \nan imperative computation model a labelled transition system involving commands and states, but the \nde.nition is otherwise not speci.c to a particular programming language. We . assume transitions of the \nform (c, S) -.(c ' ,S ') where c is a program and S is the program state. We assume that the semantics \nsignals any .ow of information, i.e. changes to the state, using labels l,where l is either a distinguished \nsilent output t (when there is no state update), or a value u corresponding to the value of the updated \npart of the state. So for example a simple assignment x := 42 would generate a 42 . transition. We further \nassume that the state includes at least the following three components: A memory, i.e. a mapping from \nlocations to the values they contain. We denote the memory of state S by Mem(S),and range over memories \nusing variables M, N.  A lock state, which is the set of all locks currently open. We denote the lock \nstate of state S by LS(S), and use S, . to range over lock states.  An actor mapping, keeping track \nof the concrete run-time rep\u00adresentation of actors that the actor variables in the program rep\u00ad   resent. \nWe denote the actor mapping part of state S by Act(S) use . to range over actor mappings. Just as with \nprogram variables, actors have concrete representations at runtime, which differ from their representations \nin the program code. This is so we can handle e.g. dynamic creation of actors in a loop, where the same \nactor variable name is reused for a new actor each time around the loop. We call the runtime representations \nconcrete actors, as opposed to the abstract actors (actor identi.ers) found in the program code and policies. \nAs a consequence, since locks can take actors as arguments, at runtime locks will be parametrised by \nconcrete actor representa\u00adtions. We refer to a lock with concrete actor parameters as a con\u00adcrete lock. \nThe lock state component of the state consists of the set of concrete locks currently open. For both \nactors and lock sets we adopt the convention to use bold face identi.ers when denoting concrete entities. \nFor instance, S would represent a set of abstract locks in e.g. a policy stated in the program, while \nS ranges over sets of concrete locks. For actors, . ranges over sets of abstract actors, while (with \na slight abuse of our convention) . will denote an actor mapping, and hence .(a) denotes the concrete \nactor corresponding to abstract actor a.We will also apply actor mappings to sets of abstract actors \nand to abstract locks and lock sets; the effect in each case is to replace each abstract actor with the \ncorresponding concrete one. One other important thing to realise is that since actors and locks have \nruntime representations, and can be manipulated and queried at runtime, they are subject to the same \npossibilities for information .ows as the memory. This means that to ensure that all information .ows \nare properly speci.ed and tracked, locks and actors must have policies too, to govern how they may be \nused in a program. For a given state component t we write pol(t) to denote the policy of t.  5.2 Validating \n.ows To ensure correct information .ow in a program, all .ows must be validated at each possible level \nthat data can .ow to. This is not speci.c to our setting, but a very general statement regarding information \n.ow control. Each of these levels can be thought of as a potential attacker. For each such attacker, \nwe must ensure that the attacker does not learn more than intended about the initial data. The way to \ndo this is, for each possible attacker, to split the state into a high and a low portion the low portion \nbeing the part directly visible to the attacker. The security goal is to ensure that the attacker, by \nobserving the low part, does not learn more than intended about the high part of the state. For standard \nnoninterfer\u00adence the goal is that the attacker learns nothing. For gradual release [AS07] the goal is \nto ensure that nothing is learned for the observa\u00adtions that are not labelled as declassi.cations. Since \n.ow locks permit .ne-grained .ows where data can be effectively declassifed to an actor in a series of \nsteps, each remov\u00ading one condition (i.e. lock) that needs to be ful.lled, our levels need to account \nfor both actors and lock sets. We thus de.ne an attacker A to be an actor paired with a set of locks \nwhich we de\u00adnote the capability of that attacker. The intuition is that an attacker A =(a, S) may see \nany data guarded from actor a by at most S. Formally, A . Actors \u00d7P(Locks) We write Cap(A) for the capability \nof A. Note in particular that attackers observe concrete things at runtime, so they represent concrete \nactors with concrete capability sets. To formulate security in a knowledge evolution style, follow\u00ading \n[AS07, BS09], we .rst need a number of auxiliary de.nitions. A trace is a sequence of labels denoting \nchanges to the state. An A-observable trace is a trace where we mask out changes to pieces of the state \nthat the attacker A cannot see. We say that an attacker (a, S) can see some part of the state with policy \np iff p .{S . a}. A transition is visible to A if A can see the portion u of the state involved in the \nchange. We write (c, S) -.A (c ' ,S ' ) u when (c, S) -.(c ' ,S ' ) and the transition is visible to \nA,and =u '' (c, S) =.A (c ,S ) when there exists a sequence blof labelled transitions between the respective \ncon.gurations, where the projection of bl to the non\u00adsilent A-visible transitions is equal to bu. We \nsometimes omit result con.gurations if we only care about the output of a program, as in =u (c, S) =.A \n. Note that the series of execution steps generating a trace need not be maximal, so the set of all A-observable \ntraces of a given program-state pair for a given attacker A is pre.x closed. An A-low state is a projection \nof a state to exactly those parts visible to attacker A. Two states are A-equivalent, written S ~A T \n, if their A-low projections are equal. With these de.nitions in hand, we can de.ne the notion of attacker \nknowledge as follows: DEFINITION 5.1 (Attacker knowledge). The knowledge an at\u00adtacker has of the starting \nmemory after observing trace bu of pro\u00adgram c with a starting state who s A-low projection is L is n \n=u o kA(bu, c, L)= S | S ~A L, (c, S)=.A i.e., the set of all possible starting states that might lead \nto that trace. Note that knowledge grows (uncertainty decreases) during execu\u00adtion, so we always have \nthat kA(buu, c, L) . kA(bu, c, L).  5.3 Security To validate that all information .ows in a program \nare secure according to the stated policies, each output must be examined in the context it takes place, \nwhich in our .ow locks setting means the lock state in effect at the time of the output. Consider for \nexample the simple program x := y,where pol (x)= {a} and pol (y)= {s . a}. Clearly this program is insecure \nin isolation, since the policy on x is less restrictive than that on y, but it would be secure providing \nthat s was already open. To help with our de.nition, we .rst de.ne the notion of an A-observable run \nof a program to be a non-empty A-observable trace of the program, paired with the lockstate in which \nthe last output of that trace takes place. We formally de.ne the set of all A-observable runs that could \narise from a given program c starting in a state whose A-low projection is L,as DEFINITION 5.2 (A-observable \nrun). no ' =u '' u RunA(c, L)= (buu, LS(S )) | S ~A L, (c, S) =.A (c ,S ) -.A Now, for a given attacker, \nrepresenting a particular split of the state into high and low portions, who observes an output, the \nrequirement is that this output may not signify a data .ow from high to low portions of the state, unless \nthe lock state permits such .ows. Note that a single attacker is a very course-grained representation \nof security, as it is only able to distinguish between high and low , but no nuances. As a consequence, \nany lockstate that would allow some .ow from high to low will do. The split of high and low depends on \nthe capability of the attacker, so for an attacker A we have that some lockstate S allows .ows from high \nto low as long as S . Cap(A).If S . Cap(A) then the only .ows that are allowed fall completely inside \nthe parts of the state that A considers low. The .ne granularity is obtained by quantifying over all \npossible such attackers, since for any bad .ow there must exist an attacker for which the .ow is from \nhigh to low , but without a permissive enough lockstate.  Our formal de.nition of top-level security \nfor a program, de\u00adnoted PLS(c), can then be de.ned in terms of runs as follows: DEFINITION 5.3 (Paralock \nsecurity). A program is said to be par\u00adalock secure, written PLS(c), if for all attackers A, for all \nA\u00adlow states L, for all runs (buu, .) . RunA(c, L) we have that if . . Cap(A) then kA(buu, c, L)= kA(bu, \nc, L) Informally, if the lock state at the time of the update would not allow any .ows from high to low \nportions of the state, then no knowledge may be gained about the initial state. In practice we also need \na generalised de.nition which accounts for subprograms that are secure in the context they appear, where \ncontext here means the actors which exist and the locks which are open. For space reasons we omit this \ngeneralisation here, but note that it is needed in the proof for the type system presented in the next \nsection. The generalisation can be found in the appendix. The above de.nition of security is termination \nsensitive a pro\u00adgram is insecure if high data can in.uence termination behaviour. We get a weaker but \nmore easily veri.ed termination insensitive version following the formulation from [AHSS08] as follows: \nDEFINITION 5.4 (Termination-insensitive security). A program c is said to be termination insensitive \nsecure, written PLSTI(c), if for all attackers A, for all A-low states L, for all pairs of ' , . ' ) \nruns which differ only at the last output (buu, .), (buu . RunA(c, L) we have that if . . Cap(A) then \nkA(buu, c, L)= kA(buu ' ,c,L) Here we do allow some knowledge to be gained by observing the next output, \nbut only by the fact that there is an output in the .rst place.  6. Enforcement: An Example Paralocks \nType System In this section we give an example of how Paralocks can be com\u00adbined with a concrete programming \nlanguage, and present a type system which guarantees that well-typed programs are (termination insensitive) \nparalock secure. The underlying language we present is as simple as possible while still using the full \nexpressive power of Paralocks, to focus on the interesting parts of the interaction. Expressions: e ::= \nn | x[ba] | e . e Commands: c ::= x[ba]:= e | if e then c else c | while (e) c | skip | c1; c2 | open \ns(ba) | close s(ba) | newactor a in c | when s(ba) do c else c | forall s(ba) do c  Internal Commands: \nc ::= for s(ba) in S do c Figure 2. Example language syntax The language, found in Figure 2, is at its \ncore a sequential im\u00adperative language, with assignments, conditionals and loops. Data sinks and sources \nare kept abstract and are uniformly represented as references, with each reference having an attached \npolicy. For simplicity the only basic type is the integers. The internal com\u00admand (for) is not part of \nthe surface syntax and only arises in the operational semantics. and can carry information, so the runtime \nuse of locks will also be governed by policies. The when command is a conditional which queries the the \nstate of a particular lock. New actors can be introduced dynamically using the newactor a command, which \ngenerates a fresh concrete actor and brings a new actor variable a into scope for the enclosed subcomputation. \nNote that this could for instance be placed inside a loop, so the same variable name introduced by the \nsame newactor command can represent many different concrete actors during execution. In order to keep \nthe language and in particular the type system simple, actors are not .rst class entities. To regain \nsome of the lost expressive power from this choice, we reuse lock families as a sort of storage for actors. \nA lock family can be viewed as a named collection of actors , and to access the contents of such a collection \nwe introduce the forall command, which loops over all open locks in some family, bringing the relevant \nactors into scope in the loop body for each iteration. We assume that the order in which locks are looped \nover is deterministic. The creation and use of actors may also be a conduit for infor\u00admation .ow at runtime, \nso like references and locks we could re\u00adquire actor variables to have policies too. For simplicity though, \nwe assume that all actors introduced by newactor commands are pub\u00adlic, i.e. with a policy {.x. x}. Actor \nvariables bound by a forall command will carry information about the lock family used in the loop, so \nwe assume they inherit the policy of that lock. Regarding policies, it is important to note that the \nruntime poli\u00adcies on runtime entities will talk about concrete actors and locks, while in the program \ncode the policies will mention abstract enti\u00adties. We have no explicit declaration of references in the \nlanguage, instead we assume that they are globally available. But since actor variables are not globally \nde.ned, this has the effect that policies on references (and locks) cannot contain free actors, as that \ncould lead to name capture problems. In many settings this would be too restrictive, since it would preclude \nactor-speci.c data. To enable actor-speci.c data while avoiding all the extra ma\u00adchinery that would have \nbeen needed to track scoping and name\u00adcapture problems for policies, we instead make this explicit at \nthe top level by having actor-parametrised families of references. For full .exibility we allow any number \nof parameters on a family of references, just as with locks. Locks are also globally available, and may \nhave actor parame\u00adters. However, for simplicity we do not allow the policies on lock families to mention \nthe actor parameters, and thus may not con\u00adtain any free actor variables. In other words, for a family \nof ref\u00aderences we could have different actors having access to each in\u00addividual reference, e.g. pol (x[a]) \n= {a}, whereas for families of locks we only allow a single policy for the entire family, e.g. pol (s)= \n{.x. s(x) . x}. With all this in place, there is no need for any control that actors in policies refer \nto the proper runtime actors, since they cannot appear free in policies. To illustrate these language \nfeatures consider a simple sealed\u00adbid auction scenario. For example, if we wanted a bid variable for \neach bidder in a sealed-bid auction, we could model that with a family of references bid[a], parametrised \nby actors. Policies on such families can then use the actor parameter, so we could have pol (bid[a]) \n= {a; .x. AuctionClosed . x} where the policy on the individual references in the bid family depends \non the actor in question. As an example, the code repre\u00adsenting the registration of a new bidder might \nbe written: To manipulate locks we introduce the commands open s(ba) and 1 close s(ba). These are the \nonly commands in the language that can 2 change the lock state component of the state. Unlike in the \nbasic 3 .ow locks language, locks here will have runtime representations  where we assume that getBid \nis an input channel from the actor in question, represented as a reference. The policy on the reference \nbid[b] would be {b; .x. {Bidder(x), AuctionClosed}. x}, stat\u00ading that all bidders can gain information \nabout this bid once the auction is completed. The code fragment for concluding the auction and publishing \nthe winning bid (the .rst of the largest bids) could then be written 1 2 3 4 5 6 7 8 To be able to \ncompute the maximum bid before the auction is marked as closed (as in this example) we would give maxBid \nthe policy {.x. {Bidder(x), AuctionClosed}. x}. We use a separate lock family to denote the winning actor, \nand by (line 5) closing all previous winners and then opening the lock for the new winner, we are assured \nthat we only ever have (at most) one winner. We could then loop over all actors a for whom the Winner(a) \nlock is open, to do speci.c things relating to the winner. Again we stress that while some of the language \ndesign choices here are unorthodox, this is just a consequence of keeping the lan\u00adguage and type system \nrelatively small. In a more realistic pro\u00adgramming language incorporating Paralocks, there are a number \nof other language design considerations. Supporting .rst-class dy\u00adnamic actors would be a more natural \nroute in a richer language, and this would be naturally supported in the type system using sin\u00adgleton \ntypes. From the expressiveness viewpoint support for poli\u00adcies not known until runtime (cf. DLM runtime \nlabels [ZM07]) could well prove useful, but would require more language features to enable static checking. \nHowever, the issues involved there are largely problems of enforcement. While interesting in their own \nright, they are orthogonal to the core issues of this work, namely the Paralocks policy speci.cation \nlanguage and its associated de.\u00adnition of security. 6.1 Operational Semantics The operational semantics \nof our example language can be found in Figure 3. Transitions occur between con.gurations of the form \n(c, S),where c is the command and S is the program state. This state is a triplet of an actor mapping \n(Act(S)), a lock state (LS(S)) and a memory (Mem(S)). For simplicity we lift up\u00addates on individual components \nto the full state, so for instance we write e.g. S[x .. v] to update the value of a variable in the memory, \nor S . s to add an open lock to the lock state. Since the three components have disjoint domains there \nshould be no risk for confusion. Apart from the labels on transitions, there should be no surprises in \nthe rules for the ordinary imperative constructs. Regarding open and close, the only thing of note is \nthat we need to map actor variables in locks to their concrete representations before updating the lock \nstate. The when command is very similar to the standard if, the only difference being that when queries \nthe lock state instead of the memory. The newactor command generates a fresh concrete actor repre\u00adsentation \nand binds it to the variable name given. Since we assume all actors bound this way are public, we don \nt need to care about the particulars of the generation scheme. Syntactically the variable is scoped, \nbut in the semantics we don t bother to remove it once (e1,S). v1 (e2,S). v2 (n, S). n (e1 . e2,S). v1 \n. v2 (x[ba],S). Mem(S)[x[ba]] open s(=a) (open s(ba),S) ------.(skip,S .{s(ba)}) open s(=a) (close s(ba),S) \n------.(skip,S \\{s(ba)}) (e, S). v x[=a](v) (x[ba]:= e, S) ----.(skip,S[x[ba] .. v]) 9 > > > > > > > \n> > > = ba = Act(S)(ba) > > > > > > > > > > ; (e, S). vv .{true, false} t (if e then ctrue else cfalse \n,S) -.(cv,S) t (while (e) c, S) -.(if e then (c; while (e) c) else skip,S) (c1,S)-1' ,S .(c ' ) (skip; \nc2,S) (c1; c2,S)-1' ; c2,S ' ) .(c a(a) (newactor a in c, S) ---.(c, S[a .. a]) t -.(c2,S) (a fresh) \n( t(c1,S) s(Act(ba)) . LS(S) (when s(ba) do c1 else c2,S) -. (c2,S) otherwise S = {ba | s(ba) . LS(S)} \nt (forall s(ba) do c, S) -.(for s(ba) in S do c, S) =a(=a) (for s(ba) in {ba}. S do c, S) ---.(c; for \ns(ba) in S do c, S ' ) ba = a1,...,an S ' = S[a1 .. a1,...,an .. an] t (for s(ba) in \u00d8 do c, S) -.(skip,S) \nFigure 3. Operational Semantics we leave the scope, instead we rely on the type system to ensure that \nthere can be no accidental capture. Finally, the most complex command semantically is the forall, which \nloops over all locks in some particular family. Its execution is done in two steps. First, the set of \nlocks in the family that are open is (deterministically) calculated, and second that set is looped over, \none lock at a time. For this we need to extend the language with an internal command for s(a1,...,an) \nin S do c, to handle the actual looping. The transition rule for forall is then simple: gather all open \nlocks in the relevant lock family and go to the next step, the for. In the for we bind the relevant actors \nto the provided variables and then proceed to execute the body. Just like with the newactor rule, we \ndon t care where the scope of the variables ends syntacti\u00adcally, relying on the type system to handle \nthe scoping details. The transition arrows are labeled with outputs that signal all direct information \n.ows that take place during execution, which in this simple language means all changes to the program \nstate. These are purely for the sake of reasoning about security and otherwise have no effect on the \ncomputation. The commands that have an effect on the state are assignments for the memory and open and \nclose for the lock state. For the actor mapping, the newactor command can introduce a single new actor \nin scope, while the forall loop, via the auxiliary internal for construct, can bind a number of names \nin one transition step. All other base rules have no effect on the state, and thus yield the silent output \nt .  6.2 Type System To enforce security we use the type system in Figure 4. Since we only have integers \nas the base type for values, we don t need to track base types at all, so our type system only handles \nthe security component. For expressions, the typing judgement is simply . f e : r, where r is a paralock \npolicy which we call the read effect of the expression, as it intuitively speci.es who may read data \nfrom references with this policy. In effect it will be the least upper bound of the policies on references \nused to compute the expression e. There should be no surprises in how this read effect is computed, though \nnote that the rule for references handles both parametrised and unparametrised references, as we allow \nthe vector of actors to be of length 0. The typing judgement for commands is a bit more involved, but \nthe various components should come as no surprise. The judgement is .; S f c r w, S ' where c is the \ncommand to type and w is a policy we call the write effect of the command. Intuitively this policy speci.es \nwho would be able to notice that the command was executed, by observing its effects on the state. It \nis thus the greatest lower bound of all policies on references, locks and actor variables whose values \nare affected by the command. The purpose of this policy is to track indirect .ows, similar to the use \nof a program counter in many other systems. This can be seen in the rules for the commands that affect \ncontrol .ow, namely if, while, when and forall. All these rules compare the policy of the branching expression \nor lock with the write effect of the body of the command. The write effect is straightforward to compute \nfor most rules. For assignments, open and close it is simply the policy of the af\u00adfected location or \nlock. The newactor command introduces actor variables with the policy ., which is thus its write effect, \nas . is clearly at least as liberal as any write effect of the body. The most interesting rule in this \nregard is that of the forall command. We cannot in general know exactly which actors will be referenced \nin the loop iterations, so we assume it may be any of them, meaning that actors introduced by the forall \nthat appear in the write ef\u00adfect of the body must be universally quanti.ed. However, since the forall \nalso binds actors to the relevant variables, and these vari\u00adables inherit the policy of the lock, the \nwrite effect of the whole command will be exactly the policy of the lock, since we require that to be \nmore liberal than any write effect of the body. . is the set of actors in scope, for both commands and \nexpres\u00adsions, and the newactor and forall commands introduce new actors into this scope as expected. \nWe use it only to ensure that any mention of actor variables as arguments to references and locks are \ndone in a correct way, and that no variable names clash. S is the set of locks assumed to be open when \nthe command starts executing, and S ' is a lower bound on the locks that will be open afterwards. The \none place where S is actually used is in the assignment rule. In this rule we must determine whether \nthe policy of the expression is compatible with the policy of the vari\u00adable relative to the current lock \nstate. The idea is the same as with .ow locks but the details are more complex. For example, sup\u00adposewehaveapolicy \np = {a, .x. Actsfor (a, x) . x}. Intuitively this says that a may always read the data, and that for \nany ac\u00adtor x,ifthe lock Actsfor (a, x) ( .ow from a to x is permitted ) then x may also read. If we specialise \nthis policy to a lock state S= {Actsfor(a, b)} then the policy in force at that state p(S) is {a, .x. \nActsfor (a, x) . x, b}. I.e. in that state, b is also uncon\u00additionally permitted to see the data. Specialisation \nis most easily understood in logical terms: p(S) is just the most liberal policy which is entailed by \nthe conjunction of p and S. In the de.nitions that follow we distinguish .-bound actor vari\u00adables syntactically, \nusing metavariable x. DEFINITION 6.1 (Matching). Let . be a substitution from bound actor variables to \nfree actor varibles. We say that S matches S ' with . if and only if the set of bound actors in S is \nequal to the domain of ., and S. = S ' . For example, {Actsfor (a, x)} matches {Actsfor (a, b)} with \nx ::= b. DEFINITION 6.2 (Specialisation). For a policy p and a lock state S, we de.ne the normalisation \nof p at S, written p(S),as [ p(S) = {c \u00b7 S} , where c.p def (.bx. . . b) \u00b7 S= {.bx. .2. . b. | . = .1 \n. .2;S1 . S; .1 matches S1 with . } Note that p(S) always contains S (to see this take .1 and S1 to be \nthe empty set in the auxilliary de.nition above) i.e. p(S) p normalising a policy always yields a more \nliberal policy. Computing the outgoing lock state is straightforward in most cases, but a few rules are \nslightly complex. Actors introduced by newactor and forall are scoped, and when their respective scopes \nend we need to forget about any locks mentioning those actors, to avoid name clashes with potential future \nscopes reusing the same actor variable. Most interesting perhaps is the rule for close, which has to \naccount for potential aliasing issues between actor variables. Hence it is maximally pessimistic, and \nassumes that not only the lock that is explicitly mentioned will be closed, but also any other lock in \nthe same family where the actor arguments may point to the same concrete actors at runtime. Two variables \nintroduced by newactor commands can never be aliases of each other as they must represent fresh concrete \nactors. A variable introduced by a forall could alias any other variable though. We assume an implicit \npredicate alias where alias(a)= true if a in the current scope is introduced by a forall construct, otherwise \nfalse.The result clearly depends on the context in which the function is called. We then de.ne a simple \nmay-alias relation as def a . b = alias(a) . alias(b) . a = b. We extend this relation to equal-length \nvectors of actors in a point\u00adwise manner. Using this may-alias relation, the rule for close is suitably \npessimistic about what abstract locks may actually be closed at runtime.  6.3 Security We show that \nwell typed programs are paralock secure. The proof can be found in the accompanying online appendix. \nHere we just note the main technical stepping stones the .rst of which is the standard property that \nreduction preserves typability: LEMMA 6.1 (Preservation). Let us say that state S is compatible with \nS if LS(S) . Act(S)(S). Similarly we say that state S is compatible with an actor set . if dom(Act(S)) \n. .. Now suppose that .; S f c r w, . and (c, S) -.(c ' ,S ' ). Then if . and S are compatible with S \nthen . ' ;S ' f c ' r w ' , . ' for some . ' and S ' compatible with S ' , ww ' and . . . ' .  ba . \n. .a . ba. pol (a) pol(x[ba]) . f e1 : r1 . f e2 : r2 . f n : . . f x[ba]: pol(x[ba]) . f e1 . e2 : r1 \nU r2 ba . . ba . . .; S f open s(ba) r pol (s), S .{s(ba)} .; S f close s(ba) r pol (s), S \\{s(bb) | \nba bb}. f e : rr(S) pol (x[ba]) ba . . .; S f skip r T, S .;S f x[ba]:= e r pol (x[ba]), S . f e : r \n.; S f ci r wi, Si rw1 n w2 . f e : r .; S n S ' f c r w, S ' rw .; S f if e then c1 else c2 r w1 n w2, \nS1 n S2 .; S f while (e) c r w, S ' n S .; S f c1 r w1, S1 .; S1 f c2 r w2, S2 .; S f c1; c2 r w1 n w2, \nS2 .; S .{s(ba)}f c1 r w1, S1 .; S f c2 r w2, S2 pol(s) w1 n w2 .a . ba. pol(a) pol (s) .; S f when \ns(ba) do c1 else c2 r w1 n w2, S1 n S2 . . ba;S n S ' f c r w, S ' pol(s) ..ba.w ba n .= \u00d8 .; S f forall \ns(ba) do c r pol (s), S ' n S \\{s(bb) | ba nbb = \u00d8} . .{a};S f c r w, S ' .; S f c r w, S ' (Top level \njudgement) .; S f c .; S f newactor a in c r ., S ' \\{s(bb) | a . bb} Figure 4. Flow Lock Type System \nThe second basic property is the global ( big step ) property of the effect components of the typing \nderivation. Stated informally (to convey the intuition without all the technicalities), they say that \nwhenever .; S f c r w, . then If data labelled w is not visible to attacker A then any compu\u00adtation \nof c in any start state compatible with S will not produce any A-visible output (and hence will not modify \nthe parts of the state with policy w or stronger).  A terminating computation of c in a state with at \nleast locks S open will result in at least locks . being open.  Finally we have proven the main theorem \nof this section, namely that a well-typed program is guaranteed to be secure by our se\u00admantics for Paralocks. \nSince the type system as stated is ter\u00admination insensitive, for instance it allows high loops to pre\u00adcede \nlow writes , we formally have that well-typed programs are termination-insensitive paralock secure: THEOREM \n6.1. If \u00d8; \u00d8 f c then c is termination-insensitive par\u00adalock secure (PLSTI(c)). This in turn is a corollary \nof a theorem involving a generalisation of the PLSTI property. Again, the details are available in the \nappendix.   7. Recursive Paralocks In Section 4 we presented an encoding of the DLM. One aspect of \na DLM policy was the treatment of the ActsFor relation; implicitly we required that whenever we open \na lock ActsFor (a, b) then we must also open all transitive consequences. It is intended that this invariant \nis implemented explicitly by encapsulating the open op\u00aderation appropriately within a program which uses \na DLM policy. In this section we explore an extension to the policy language which allows us to specify \nsuch properties explicitly, avoiding the need to encode them explicitly in the program. The extension \nis a natural logical one: allow relations between locks and .ows to be speci.ed recursively as part of \na global policy component. In this section we brie.y explore the implications of this exten\u00adsion to the \nquestions of policy (c.f. \u00a73.2), expressiveness (c.f. \u00a74), semantics (c.f. \u00a75), and enforcement (c.f. \n\u00a76). 7.1 Policy Policies will now consist of two parts. Firstly we have policies on memory objects just \nas before: collections of clauses which have an actor variable (bound of free) as their head. For the \npurposes of this section it will be useful to write a clause .a1,...,an. S . a as .a1,...,an. S . Flow(a), \nthus making the may .ow to \u00adpredicate explicit. The extension we make is to add a global policy G which \nis also a set of clauses. These clauses differ in that their heads may be locks and thus they may be \nrecursive. For example, in a DLM encoding we would include the following two clauses in the global policy: \n.y. ActsFor (y, y); .x, y, z. ActsFor (x, y), ActsFor (y, z) . ActsFor (x, z) This style of policy speci.cation \nis already familiar in a security context: it amounts to the use of DATALOG programs as policy speci.cations, \nand has been used in numerous logics for access control policies e.g., [Jim01, DeT02, LMW02]. We permit \none further useful feature: global policies, in addition to using locks, may also use the distinguished \nFlow predicate in their speci.cation (see Section 7.2 for examples). Policy comparison To compare policies \np and q we must now take into account the global policy. We write p G q to mean that policy q is more \nrestrictive than policy p in the context of global policy G. We can de.ne this relation by giving a straightforward \ninterpretation in .rst-order logic. As before we can interpret each clause in p, q and G as .rst-order \nHorn clauses, and sets of clauses are interpreted as logical conjunction. Then we de.ne def p G q = G \n. p |= q To see that this does the right thing , consider some lock state S. Suppose that S . G . q |= \nFlow(a) i.e. that in some concrete lock state the policy q permits information to .ow to a. Then it \ncan be readily seen that p G q ensures that S . G . p |= Flow(a) i.e., p allows any .ow that q does. \n  7.2 Expressiveness Here we consider a couple of simple examples using recursive paralocks. Denning \nLattices, Reloaded The .ow locks encoding of standard Denning-style information .ow lattices involves \nidentifying secu\u00adrity levels with actors, and representing a security level j by the (lock-free) policy \n{Flow(k) | j = k}. Recursive Paralocks pro\u00advide several alternative ways to specify this. One example \nis to represent the policy for data of level k as just {Flow(k)}.The global policy then must de.ne the \ncovering relation of the lattice (represented as a binary lock .), together with the rule .x, y. Flow(x),x \n. y . Flow(y). So, for example, the three point lattice L = M = H would be represented by the global \npolicy {L . M; M . H; .x, y. Flow(x),x . y . Flow(y)} . The Complete DLM In the case of the DLM encoding \nwe already mentioned the ability to express re.exivity and transitivity for the ActsFor hierarchy. Similarly \nthe invariant on the RunsFor lock can then be speci.ed as .x, y. ActsFor (x, y), RunsFor (x) . RunsFor \n(y) We can also move part of each policy into the global part by applying the ActsFor hierarchy to Flow \npredicates: .x, y. ActsFor (x, y), Flow(x) . Flow(y) which says that whenever .ow to x is permitted then \n.ow to y is also permitted providing y acts for x. With this rule we no longer need to be explicit about \nthe ActsFor relationship in the data policy itself, so for example we can encode a label {o1 : r1; o2 \n: r1,r2}more succinctly as {.x. RunsFor (o1), RunsFor (o2) . x; r1; RunsFor (o1) . r2} As an interesting \nside note, the original version of the DLM ([ML97]) was considered incomplete; a follow-up paper ([ML98]) \nidenti.ed a complete policy ordering. Speci.cally the new for\u00admulation made the policy ordering more \nliberal by weakening it to allow two new -monotone operations on policies: An owner o1 may to be replaced \nin a label with an owner o2 that acts for o1,  If a reader r1 is listed by some owner, and r2 acts for \nr1,then we can also add r2 as a reader for that owner.  Our original encoding is faithful to the original \nDLM, and cannot not handle these components, speci.cally because the policy order\u00ading was ignorant of \nthe transitive nature of the ActsFor relation\u00adship and its relation to the RunsFor property. With the \nextension presented here, policy ordering becomes complete and thus cor\u00adresponds to the revised version \nof the DLM [ML98]. 7.3 Semantics The de.nition of security needs only minor modi.cations to handle recursive \nparalocks. There are just two places where the de.nition needs to be modi.ed: Generalise to G in the \nde.nition of the parts of a state that the attacker can see.  In the de.nition of security, generalise \nthe comparison between lock state . and attacker capability Cap(A) to take into ac\u00adcount the global policy \nG by replacing the condition  . . Cap(A) (logically: Cap(A) |= .) by G . Cap(A) |= .. 7.4 Enforcement \nHere we consider the impact that recursive paralocks have on the integration with the language and type \nsystem of Section 6. The global policy is essentially DATALOG3.DATALOG and modest extensions thereof, \nhas proved to be a popular basis for e.g. access control logics because, among other things, a query \n(the access control mechanism itself) can be answered in polynomial time. This is also useful in the \npresent context. At runtime we need to enumerate all actors in a given role (the forall-construct in \nour example language), and check whether a particular lock is open (the when construct). It is necessary \nthat these can be answered precisely and ef.ciently, and this is possible because they are datalog queries. \nHowever, type checking is another matter. We do not need to an\u00adswer datalog queries within the type system, \nwe need to implement policy comparison ( G ). In all other regards we conjecture that the type system \ngiven in Section 6 is sound for recursive paralocks providing we generalise the policy ordering and \nleast-upper-bound operation accordingly. In the case of assignment x := e, for example, where x has policy \nq,and e has policy r, and we know that at least locks S are open, then we need to determine whether S \n. G . r |= q.This problem (and the similar problem of determining whether r G q) is the problem of containment \nof a non-recursive datalog program q in a recursive one S . G . r. This containment problem is known \nto be decidable, although EXPTIME-complete (see e.g. [CV97]). Whether this complexity is a problem in \npractice remains to be seen. Similarly we need a generalised form of least upper bound oper\u00adation where \np UG q denotes the least policy r such that p . G |= r and q . G |= r. This kind of operation i.e., \n.nding a DATALOG program which gives a best approximation to the disjunction of two DATALOG programs \n does not to our knowledge seem well stud\u00adied in the DATALOG literature. However, we note that using \np U q just as before (thus ignoring G) would provide a safe upper bound operation which would be adequate \nfor use in the type system.  8. Related Work Considering related work, there are two main dimensions \nalong which our work can be compared: policy and semantics. Policy As mentioned, the Paralocks policy \nlanguage is built on our earlier work on Flow Locks, and .ow locks themselves are a special case of paralocks. \nAs such paralocks can also encode integrity policies and a variety of declassi.cation policies. We refer \nthe reader to [BS06] for more examples. The Paralocks model is policy neutral it provides the means \nto construct information .ow policies but does not prescribe any particular kind of policy. In this regard \nour goals are related to the recent security policy programming language Fable [SCH08]. Fable allows \nprogrammers to specify a custom label language for data, and constraints (via dependent types) on how \nprogramming operations may use labelled data. Static typing ensures that there is no way to bypass the \npolicy. The Fable approach is very .ex\u00adible and general, but as a result it provides no general extensional \nsemantic security condition one must construct these on a case\u00adby-case basis. Paralocks is not intended \nto be as general purpose as 3 Certain policies that we have used are not safe in the DATALOG sense (see \ne.g. [CGT89]) For example .x. Runsfor(o) . Flow(x) is unsafe because x does not appear in the body of \nthe clause, and so it generates in.nitely many instances. However, at any point during run time, the \ndo\u00admains of actors is .nite and known. Hence the rule can be thought of as a shorthand for .x. Actor(x), \nRunsfor (o) . Flow (x).  Fable (for example it does not aim to be able to encode security au\u00adtomata) \nbut focuses on the higher level concept of information .ow. As a result we can give a single information-.ow \nsemantics to all Paralock policies. It may be possible, however, to use Fable s .ne\u00adgrained data manipulation \npolicies as an implementation platform for a Paralocks type system, although the only information .ow \nen\u00adcoding described so far in Fable [SCH08] is a standard information .ow lattice policy. Paralocks deal \nwith dynamic policies in the sense that permit\u00adted information .ows change over time. We assume that \nlocks are opened and closed at appropriate points in a given program in or\u00adder to communicate the intended \nchanges. We could say that the program synchronises with the policy via lock operations. An alter\u00adnative \napproach is to assume that the trigger for policy change lies outside the program itself. To some extent \nthis is what is done with the acts-for hierarchy in Jif (DLM) programs and we can take the same perspective \nusing runtime lock checking instead of open\u00ading locks from within the program. This works well if all \npolicy changes make the policy more liberal, but asynchronous changes corresponding to the closing of \nlocks are potentially problematic [HTHZ05]. This is related to the problem tackled in the RX pol\u00adicy \nlanguage [SHTZ06]. This work (and the more recent re.ne\u00adment [BWW08]) is the only other language-based \nsecurity work of which we are aware which uses roles in an information-.ow set\u00adting. The main thrust \nof their approach is to specify and manage information .ows which are caused by policy changes. Role \nman\u00adagement ideas are used to control policy updates. In common with this approach, our semantics also \ntracks information .ows caused by role management something which was not necessary in the earlier .ow \nlocks work due lack of run-time locks. We believe that many features of their meta-policies can be directly \nencoded using paralocks, but we have yet to investigate such examples. One important feature of Paralocks \nthat was not supported by .ow locks is the notion of a run-time actor. Inthis regardthe work of Tse and \nZdancewic s extension of the DLM with run-time principles [TZ04] is closely related, and our inclusion \nof a run-time lock test was motivated by that work. We note some further similarities to work on RBAC \nmodels. Paralocks permit .ner granularity than standard RBAC, with the use of user-speci.c policies. \nThis level of control appears similar to that provided by role templates [GI97]. Our ability to model \nac\u00adcesses which are triggered by arbitrary state conditions (modelled via locks) has similarities to \nenvironment roles [CLS+01]. Related to this, the role activation rules of the OASIS model have a super.\u00adcial \nsimilarity with paralock policies (see e.g. [BEM03]) although these rules would be more like lock invariant \nspeci.cations in our model. The extension to recursive paralocks described in Section 7 brings the work \nmuch closer to the logic-based access control work (e.g. [Jim01, DeT02, LMW02]). One line of work by \nDougherty et al [DFK06] deals speci.cally with the issues that arise in situations where changes in the \nenvironment entail dynamic changes to access control policy. This is analogous to our problem of reasoning \nabout policies in the presence of a program which has side-effects on the policy. Semantics Semantic \nmodels for complex information .ow poli\u00adcies are problematic. In some cases e.g. in the DLM there is \nsimply no information .ow model. In others (e.g., [TZ04]) the se\u00admantic models are simply noninterference \nin the absence of pol\u00adicy change. For semantic models of declassi.cation and other dy\u00adnamic information \n.ow policies which attempt to do more than this (e.g. the noninterference between policy updates approach \nin [SHTZ06, BWW08]), we have argued [BS09] that many seman\u00adtic models suffer from .ow insensitivity. \nFlow insensitivity here means that the semantic conditions are not really fully semantic, since they \n.ag insecurity simply because they do not have an suf\u00ad.ciently accurate model of the context of a given \ninsecure look\u00ading subcomputation. In contrast, the semantic model here is based on a revised and much \nimproved .ow locks semantics developed in [BS09] which in turn builds on the knowledge-style semantics \nfrom gradual release [AS07] which avoids this pitfall. Paralocks do not provide direct control of one \nof the dimen\u00adsions of declassi.cation [SS05] namely the speci.cation of what information .ows from a \ngiven data source. For example we might specify that A can read only some part of data (e.g. a checksum) \nrather than all of it. Although certain simple what policies are easily encoded in the Paralocks model \n(e.g. in the checksum exam\u00adple by ensuring that the checksum is declassi.ed to variable read\u00adable by \nA), this is clearly not the main focus of the Paralocks ap\u00adproach. Semantically this kind of policy falls \nwithin the PER model [SS01] and a more constructive perspective on this kind of model is provided by \nthe abstract noninterference framework [GM04]. Recent work by Banerjee et al. [BNR08] present a language \nfor expressive declassi.cation policies which broadly lie in this class. Policies are intended to be \nveri.ed by a mixture of static typing and static veri.cation. In common with our work, Banerjee et al \nalso adopt the gradual release style of information .ow semantics.  9. Conclusions and Future Work As \nwe noted initially, our aim with this work is really two-fold. On the one hand we present the policy \nspeci.cation language Par\u00adalocks, and show its usefulness for handling a variety of informa\u00adtion .ow \nchallenges. On the other hand, Paralocks is also a very general framework that is capable of expressing \nand encoding a wide variety of information .ow policy mechanisms, and impor\u00adtantly give such mechanisms \na concrete information .ow seman\u00adtics. It is our hope and belief that Paralocks can thus serve as a platform \nthat can simplify further research into policy mechanisms, both future and present, and help give a better \nunderstanding of the relationship between various mechanisms. A different area of future research is \nto look closer into the interplay between Paralocks and concrete programming language constructs, with \na particular focus on type systems guaranteeing Paralock security. The example language we gave in section \n6 is very simplistic in many ways, and there are many interesting challenges in adding features like \n.rst-class actors (which would be needed, among other things, to avoid our ad-hoc introduction of actor-indexed \ndata) or policies not known until runtime (c.f.runtime labels [ZM07]). A third potential direction for \nfuture research is to fully exploit the connection to logic-based access control languages. Here we can \nbene.t from various well-behaved extensions to DATALOG such as the addition of strati.ed negation and \nconstraints on data; see e.g., [BFG07] for an elegant authorization language combining such extensions. \nBut the potential here is not just the transferral of technical results. The connection offers new opportunities \nto transfer policy concepts from access control to an information .ow context. Appendix An extended version \nof this article (available from the authors) contains proofs of the main technical results stated in \nthe paper. Acknowledgements Thanks to the ProSec group at Chalmers, to Reiner H\u00a8ahnle and Mike Hicks \nfor useful comments and sugges\u00adtions. The POPL referees provided outstanding feedback, including independently \nsuggesting the extension outlined in Section 7. This work was partly funded by the Swedish research agencies \nVR &#38; SSF.   References [AHSS08] A. Askarov, S. Hunt, A. Sabelfeld, and D. Sands. Termination insensitive \nnoninterference leaks more than just a bit. In Proc. European Symp. on Research in Computer Security, \n2008. [AS07] A. Askarov and A. Sabelfeld. Gradual release: Unifying de\u00adclassi.cation, encryption and \nkey release policies. In Proc. IEEE Symp. on Security and Privacy, pages 207 221, May 2007. [BEM03] A. \nBelokosztolszki, DM Eyers, and K. Moody. Policy contexts: Controlling information .ow in parameterised \nRBAC. In IEEE 4th International Workshop on Policies for Distributed Systems and Networks, 2003. Proceedings. \nPOLICY 2003, pages 99 110, 2003. [BFG07] Moritz Y. Becker, C\u00b4edric Fournet, and Andrew D. Gordon. De\u00adsign \nand semantics of a decentralized authorization language. In Proc. IEEE Computer Security Foundations \nSymposium, pages 3 15. IEEE Computer Society, 2007. [BNR08] A. Banerjee, D. Naumann, and S. Rosenberg. \nExpressive declassi.cation policies and modular static enforcement. In Proc. IEEE Symp. on Security and \nPrivacy, pages 339 353. IEEE Computer Society, 2008. [BS06] N. Broberg and D. Sands. Flow locks: Towards \na core calculus for dynamic .ow policies. In Programming Languages and Systems. 15th European Symposium \non Programming, ESOP 2006, volume 3924 of LNCS. Springer Verlag, 2006. [BS09] Niklas Broberg and David \nSands. Flow-sensitive semantics for dynamic information .ow policies. In ACM SIGPLAN Fourth Workshop \non Programming Languages and Analysis for Security (PLAS 2009), Dublin, June 15 2009. ACM. [BWW08] Sruthi \nBandhakavi, William Winsborough, and Marianne Winslett. A trust management approach for .exible policy \nmanagement in security-typed languages. In Proc. IEEE Com\u00adputer Security Foundations Symposium, pages \n33 47, 2008. [CGT89] S. Ceri, G. Gottlob, and L. Tanca. What you always wanted to know about Datalog(and \nnever dared to ask). IEEE Trans\u00adactions on Knowledge and Data Engineering, 1(1):146 166, 1989. [CLS+01] \nMichael J. Covington, Wende Long, Srividhya Srinivasan, Anind K. Dev, Mustaque Ahamad, and Gregory D. \nAbowd. Securing context-aware applications using environment roles. In SACMAT 01: Proceedings of the \nsixth ACM symposium on Access control models and technologies, pages 10 20. ACM, 2001. [CM77] A. K. Chandra \nand P. M. Merlin. Optimal implementation of conjunctive queries in relational databases. In STOC, pages \n77 90, 1977. [CV97] Surajit Chaudhuri and Moshe Y. Vardi. On the equivalence of recursive and nonrecursive \ndatalog programs. Journal of Computer and System Sciences, 54(1):61 78, 1997. [Den76] D. E. Denning. \nA lattice model of secure information .ow. Comm. of the ACM, 19(5):236 243, May 1976. [DeT02] John DeTreville. \nBinder, a logic-based security language. In IEEE Symposium on Security and Privacy, pages 105 113, 2002. \n[DFK06] Daniel J. Dougherty, Kathi Fisler, and Shriram Krishnamurthi. Specifying and reasoning about \ndynamic access-control poli\u00adcies. In Automated Reasoning, Third International Joint Con\u00adference, IJCAR \n2006, volume 4130 of Lecture Notes in Com\u00adputer Science, pages 632 646. Springer, 2006. [FSG+01] David \nF. Ferraiolo, Ravi Sandhu, Serban Gavrila, D. Richard Kuhn, and Ramaswamy Chandramouli. Proposed nist \nstandard for role-based access control. ACM Trans. Inf. Syst. Secur., 4(3):224 274, 2001. [GI97] Luigi \nGiuri and Pietro Iglio. Role templates for content-based access control. In RBAC 97: Proceedings of the \nsecond ACM workshop on Role-based access control, pages 153 159. ACM, 1997. [GM04] R. Giacobazzi and \nI. Mastroeni. Abstract non-interference: Parameterizing non-interference by abstract interpretation. \nIn Proc. ACM Symp. on Principles of Programming Languages, pages 186 197, January 2004. [HTHZ05] M. Hicks, \nS. Tse, B. Hicks, and S. Zdancewic. Dynamic updat\u00ading of information-.ow policies. In Workshop on Foundations \nof Computer Security, pages 7 18, June 2005. [Jim01] T. Jim. SD3: A trust management system with certi.ed \neval\u00aduation. In IEEE Symposium on Security and Privacy, pages 106 115, 2001. [LABW91] Butler Lampson, \nMart\u00b4in Abadi, Michael Burrows, and Edward Wobber. Authentication in distributed systems: theory and \npractice. In SOSP 91: Proceedings of the thirteenth ACM symposium on Operating systems principles, pages \n165 182. ACM, 1991. [LMW02] N. Li, J.C. Mitchell, and W.H. Winsborough. Design of a role\u00adbased trust-management \nframework. In IEEE Symposium on Security and Privacy, pages 114 130, 2002. [ML97] A. C. Myers and B. \nLiskov. A decentralized model for infor\u00admation .ow control. In Proc. ACM Symp. on Operating System Principles, \npages 129 142, October 1997. [ML98] A. C. Myers and B. Liskov. Complete, safe information .ow with decentralized \nlabels. In Proc. IEEE Symp. on Security and Privacy, pages 186 197, May 1998. [Mye99] A. C. Myers. JFlow: \nPractical mostly-static information .ow control. In Proc. ACM Symp. on Principles of Programming Languages, \npages 228 241, January 1999. [MZZ+06] A. C. Myers, L. Zheng, S. Zdancewic, S. Chong, and N. Nys\u00adtrom. \nJif: Java information .ow. Software release. Located at http://www.cs.cornell.edu/jif, July 2001 2006. \n[SCFY96] R.S. Sandhu, E.J. Coyne, H.L. Feinstein, and C.E. Youman. Role-based access control models. \nComputer, 29(2):38 47, Feb 1996. [SCH08] N. Swamy, B.J. Corcoran, and M. Hicks. Fable: A language for \nenforcing user-de.ned security policies. In Proc. IEEE Symp. on Security and Privacy, pages 369 383, \n2008. [SHTZ06] N. Swamy, M. Hicks, S. Tse, and S. Zdancewic. Managing policy updates in security-typed \nlanguages. In Proc. IEEE Computer Security Foundations Workshop, 2006. [SS01] A. Sabelfeld and D. Sands. \nA per model of secure information .ow in sequential programs. Higher Order and Symbolic Computation, \n14(1):59 91, March 2001. [SS05] A. Sabelfeld and D. Sands. Dimensions and principles of de\u00adclassi.cation. \nIn Proc. IEEE Computer Security Foundations Workshop, pages 255 269, June 2005. [SY80] Y. Sagiv and M. \nYannakakis. Equivalences among relational expressions with the union and difference operators. Journal \nof the ACM, 27, 1980. [TZ04] S. Tse and S. Zdancewic. Run-time principals in information\u00ad.ow type systems. \nIn Proc. IEEE Symp. on Security and Privacy, pages 179 193, 2004. [Ull90] Jeffrey D. Ullman. Principles \nof Database and Knowledge-Base Systems: Volume II: The New Technologies. W. H. Free\u00adman &#38; Co., New \nYork, NY, USA, 1990. [ZM07] L. Zheng and A. C. Myers. Dynamic security labels and static information \n.ow control. International Journal of Information Security, 6, 2007.  \n\t\t\t", "proc_id": "1706299", "abstract": "<p>This paper presents Paralocks, a language for building expressive but statically verifiable fine-grained information flow policies. Paralocks combine the expressive power of Flow Locks (Broberg &#38; Sands, ESOP'06) with the ability to express policies involving run-time principles, roles (in the style of role-based access control), and relations (such as \"acts-for\" in discretionary access control). We illustrate the Paralocks policy language by giving a simple encoding of Myers and Liskov's Decentralized Label Model (DLM). Furthermore - and unlike the DLM - we provide an information flow semantics for full Paralock policies. Lastly we illustrate how Paralocks can be statically verified by providing a simple programming language incorporating Paralock policy specifications, and a static type system which soundly enforces information flow security according to the Paralock semantics.</p>", "authors": [{"name": "Niklas Broberg", "author_profile_id": "81100020443", "affiliation": "Gothenburg University and Chalmers University of Technology, Gothenburg, Sweden", "person_id": "P1911137", "email_address": "", "orcid_id": ""}, {"name": "David Sands", "author_profile_id": "81100313762", "affiliation": "Chalmers University of Technology, Gothenburg, Sweden", "person_id": "P1911138", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706349", "year": "2010", "article_id": "1706349", "conference": "POPL", "title": "Paralocks: role-based information flow control and beyond", "url": "http://dl.acm.org/citation.cfm?id=1706349"}