{"article_publication_date": "01-17-2010", "fulltext": "\n Compositional May-Must Program Analysis: Unleashing the Power of Alternation Patrice Godefroid Aditya \nV. Nori Sriram K. Rajamani Microsoft Research Redmond Microsoft Research India Microsoft Research India \npg@microsoft.com adityan@microsoft.com sriram@microsoft.com Sai Deep Tetali * UC Los Angeles saideep@cs.ucla.edu \n Abstract Program analysis tools typically compute two types of informa\u00adtion: (1) may information that \nis true of all program executions and is used to prove the absence of bugs in the program, and (2) must \ninformation that is true of some program executions and is used to prove the existence of bugs in the \nprogram. In this paper, we pro\u00adpose a new algorithm, dubbed SMASH, which computes both may and must information \ncompositionally. At each procedure bound\u00adary, may and must information is represented and stored as may \nand must summaries, respectively. Those summaries are computed in a demand-driven manner and possibly \nusing summaries of the oppo\u00adsitetype. Wehaveimplemented SMASH usingpredicateabstraction (as in SLAM) \nfor the may part and using dynamic test generation (as in DART) for the must part. Results of experiments \nwith 69 Microsoft Windows 7 device drivers show that SMASH can sig\u00adni.cantly outperform may-only, must-only \nand non-compositional may-must algorithms. Indeed, our empirical results indicate that most complex code \nfragments in large programs are actually often either easy to prove irrelevant to the speci.c property \nof interest using may analysis or easy to traverse using directed testing. The .ne-grained coupling and \nalternation of may (universal) and must (existential) summaries allows SMASH to easily navigate through \nthese code fragments while traditional may-only, must-only or non\u00adcompositional may-must algorithms are \nstuck in their speci.c anal\u00adyses. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program \nVeri.cation; D.2.5 [Software Engineer\u00ading]: Testing and Debugging; F.3.1 [Logics and Meanings of Pro\u00adgrams]: \nSpecifying and Verifying and Reasoning about Programs General Terms Veri.cation * This author performed \nthe work reported here as a research software developer at Microsoft Research India. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 10, January 17 23, \n2010, Madrid, Spain. Copyright c &#38;#169; 2010 ACM 978-1-60558-479-9/10/01. . . $10.00 Keywords Abstraction \nre.nement; Directed testing; Software model checking 1. Introduction The use of static analysis and dynamic \nanalysis to .nd bugs and prove properties of programs has received a lot of attention in the past decade. \nTools that came out of research in this area [4, 7, 11, 16, 18, 23] are now routinely used for ensuring \nquality control in industrial-strength software development projects. Program analysis tools typically \ncompute two types of informa\u00adtion. May information captures facts that are true about all execu\u00adtions \nof the program. For example, static whole-program may-alias analysis is used to bound all possible pointer \naliases that can occur during a program execution. For ef.ciency and scalability reasons, the may information \ncomputed is typically over-approximate. Thus, if a may-alias analysis says that pointer p may alias pointer \nq, it is possible that no execution exists where p and q actually alias. Be\u00adcause it is over-approximate, \nmay information can be used to prove properties of programs. For example, consider the following code \nsnippet that is a part of some larger program: 1:*p= 4; 2:*q= 5; 3: assert(*p == 4); If the may-alias \nset of pointer p does not include pointer q, then we know for sure that p and q never alias, and we can \nuse this information to prove that the assertion in line 3 always holds. Dually, must information captures \nfacts that are guaranteed to hold on particular executions of the program. For example, dy\u00adnamic must-alias \nanalysis can detect aliases that occur during spe\u00adci.c executions of the program. For large programs, \nthe must in\u00adformation computed is typically under-approximate, since it is in\u00adfeasible to cover all executions. \nThus, in the previous example, if a must-alias analysis determines that p and q must alias in some exe\u00adcution, \nthen we can use this information to prove that the assertion assert(*p == 4) can be violated. In this \npaper, we focus on the problem of checking whether a sequential program P satis.es an assertion ., called \nthe property checking problem. May and must analyses offer complementary approaches to solve this problem. \nA may analysis can be used to prove that all executions of the program satisfy assertion ., while a must \nanalysis can be used to prove the existence of some program execution that violates the assertion .. \n Compositional approaches to property checking involve decom\u00adposing the whole-program analysis into several \nsub-analyses of individual components (such as program blocks or procedures), summarizing the results \nof these sub-analyses, and memoizing (caching) those summaries for possible later re-use in other calling \ncontexts. Summarizing at procedure boundaries is indispensable for scalability. A may summary of a procedure \nP is of the form may (.1 =.P .2), where .1 and .2 are predicates over program may states. The may summary \n(.1 =.P .2) means that, if we invoke procedure P from any state satisfying .1, the set of all possible \nstates of the program on termination of P is over-approximated by the set of states .2. This implies \nthat no states satisfying \u00ac.2 are reachable from states satisfying .1 by executing P . Dually, a must \nmust summary of a procedure P is of the form (.1 =. P .2), which means that, if we invoke procedure P \nfrom any state satisfying .1, the set of all possible states of the program on termination of P is under-approximated \nby the set of states .2. This implies that any state satisfying .2 is guaranteed to be reachable from \nsome state satisfying .1 by executing P . Intuitively, a may summary of a procedure represents a property \nthat is guaranteed to be true about all executions of the procedure, and a must summary of a procedure \nrepresents witness executions of the procedure that are guaranteed to exist. May summaries pro\u00advide obvious \nbene.ts to improving the ef.ciency of may analy\u00adsis: when a compositional may analysis requires a sub-query \nfor a procedure P , a previously-computed may summary for P can po\u00adtentially be re-used to answer that \nquery without re-analyzing the procedure. Similarly, must summaries can also considerably speed\u00adup must \nanalysis: when a compositional must analysis requires a sub-query for a procedure P , an existing must \nsummary for P can potentially be re-used to answer that query. In this paper, we present a new algorithm, \nnamed SMASH, that performs both may analysis and must analysis simultaneously, and uses both may summaries \nand must summaries to improve the ef\u00adfectiveness as well as the ef.ciency of the analysis. The key novel \nfeature of SMASH is its inherent use of alternation: both may anal\u00adysis and must analysis in SMASH use \nboth may summaries and must summaries. Surprisingly, this feature of the algorithm enables SMASH to often \nsigni.cantly outperform compositional may-only, compositional must-only and non-compositional may-must \nalgo\u00adrithms, and hence to handle larger as well as complex programs. From our experiments, we observed \nthat the gain in ef.ciency is due to alternation in may-must reasoning in SMASH and can be ex\u00adplained \nas follows: most complex code fragments in large programs are actually often either easy to prove irrelevant \nto the speci.c property of interest using may analysis or easy to traverse using directed testing. Those \nfragments that are easy to prove irrelevant can often cause a must analysis to needlessly explore a large \nnum\u00adber of paths searching for a path that violates the property, whereas a may analysis can inexpensively \nconclude that no such path ex\u00adists. Dually, those fragments that are easy to traverse using directed \ntesting often cause may analyses to needlessly re.ne program may\u00adabstractions and get stuck while trying \nto discover complex loop in\u00advariants. This .ned-grained coupling and alternation of may (uni\u00adversal) \nand must (existential) summaries allow SMASH to easily navigate through these code fragments while traditional \nmay-only, must-only or non-compositional may-must algorithms are stuck in their speci.c analyses. We \nsupport the above intuition with signi.cant empirical evi\u00addence from checking 85 properties on 69 Windows \n7 drivers. With a non-compositional may-must analysis, all these checks take 117 hours (these include \n61 checks timing out after 30 minutes). With SMASH, the same checks take only 44 hours, with only 9 time-outs. \nTo drill down into the gains, we also implemented compositional may-only and compositional must-only \nalgorithms, and compare them with SMASH in detail. Our data clearly indicates and quan\u00adti.es the gains \ndue to the interplay between may summaries and must summaries in SMASH. Though the main goal of this \npaper is to describe the design, implementation and evaluation of SMASH, we have another aux\u00adiliary goal \nof placing SMASH in the context of the large and di\u00adverse amount of existing work in this area. Over \nthe past 10 years, there have been a variety of analysis techniques proposed to per\u00adform may analysis, \nsuch as SLAM [4], BLAST [24] and ESP [11], and a variety of analysis techniques to perform must analysis, \nsuch as DART [16], EXE [8] and SMART [14], and some combinations of the two, such as SYNERGY [19] and \nDASH [5]. Even if the reader is unfamiliar with this prior work, this paper includes a de\u00adtailed overview \nof the entire landscape of such analyses, and places SMASH in the context of alltheseanalyses in averyprecise \nmanner. We consider this uni.ed framework another valuable contribution of this paper, given the breadth \nand depth of these tools. The remainder of the paper is organized as follows. Section 2 motivates and \nexplains the SMASH algorithm using examples. Sec\u00adtion 3 reviews may-must analysis for single-procedure \nprograms. Section 4 presents the SMASH algorithm formally as a set of declar\u00adative rules. Section 5 describes \nour implementation of SMASH and empirical results from running SMASH on several examples. Sec\u00adtion 6 \nsurveys related work. 2. Overview We illustrate using examples the bene.t of may summaries, must summaries, \nand the interplay between may and must summaries in the SMASH algorithm. The input to SMASH is a sequential \nprogram P and an asser\u00adtion in P . The goal of SMASH is either to prove that the asser\u00adtion holds for \nall executions of P , or to .nd an execution of P that violates the assertion. The veri.cation question \ndo all pro\u00adgram executions satisfy the assertion? is reduced to a dual reach\u00adability question, or query, \ncan some program execution lead to an assertion violation? . SMASH performs a modular interprocedural \nanalysis and incrementally decomposes this reachability query into several sub-queries that are generated \nin a demand-driven manner. Each sub-query is of the form of (.1 =.? f .2), where .1 and .2 are state \npredicates representing respectively a precondition (call\u00ading context) and postcondition (return context) \nfor a procedure f (or block) in P . The answer to such a query is yes if there exists an execution of \nf starting in some state s1 . .1 and terminat\u00ading in some state s2 . .2, no if such an execution does \nnot exist, and unknown ( maybe ) if the algorithm is unable to deci\u00adsively conclude either way (the last \noption is needed since program veri.cation is undecidable in general). SMASH uses may and must summaries \nto answer queries. may A may summary (.1 =.f .2) implies that, for any state x . .1, for any state y \nsuch that the execution of f starting in state x terminates in state y, we have y . .2. For technical \nconve\u00adnience (explained in Section 3.1), SMASH maintains negated may summaries, called not-may summaries, \nwhere the postcondition is \u00acmay complemented. Thus, a not-may summary (.1 =. f .2) implies that for \nany state x . .1, there does not exist a state y . .2 such that the execution of f starting in state \nx terminates in state y. \u00acmay Clearly, a not-may summary (.1 =. f .2) can be used to give a no answer \nto a query (.1 =.? f .2) for f provided that .1 . .1 and .2 . .2. must A must summary (.1 =. f .2) implies \nthat, for every state y . .2, there exists a state x . .1 such that the execution of f starting in state \nx . .1 terminates in state y . .2 (this is also called must- in the literature [2]). Thus, a must summary \n void main(int i1,i2,i3) int g(int i) {{ 0: int x1,x2,x3; 11: if (i > 0) 1: x1 = g(i1); 12: return i; \n2: x2 = g(i2); 13: else 3: x3 = g(i3); 14: return -i; 4: if ((x1 < 0)||(x2 < 0)||(x3 < 0)) } 5: assert(false); \n} Figure 1. Example to illustrate bene.ts of not-may summaries. void main(int i1,i2,i3) int f(int i) \n{{ 0: int x1,x2,x3; 11: if (i > 0) 1: x1 = f(i1); 12: return i; 2: x2 = f(i2); else 3: x3 = f(i3); 13: \nreturn h(i); 4: if (x1 > 0) // h(i) is a complex function 5: if (x2 > 0) // such as a hash function 6: \nif(x3>0) } 7: assert(false); } Figure 2. Example to illustrate bene.ts of must summaries. must (.1 =. \nf .2) can be used to give a yes answer to a query (.1 =? .f .2) provided that .1 . .1 and .2 n .2= {}. \nSMASH computes not-may summaries on abstract state sets, called regions, using predicate abstraction \nand automatic parti\u00adtion re.nement (as in SLAM [4]), and it computes must sum\u00admaries using symbolic execution \nalong whole-program paths (as in DART [16]). SMASH starts with an empty set of summaries for each function. \nAs the SMASH algorithm proceeds, it progressively re.nes the not-may summaries and must summaries of \neach func\u00adtion on demand, in order to prove that the assertion is never vio\u00adlated, or to .nd an execution \nthat violates the assertion. The exact algorithm is described using declarative rules in Section 4. Here, \nwe illustrate SMASH using small examples. Example 1. Consider the example in Figure 1. The inputs of \nthis program are the arguments passed to the function main. Since function g always returns non-negative \nvalues, the assertion at line 5 of function main can never be reached. This can be proved using a not-may \nsummary for the function g. Given the assertion in line 5 of function main as a goal, SMASH .rst tries \nto .nd an execution along the path 1, 2,3,4,5. After some analysis, SMASH generates the query (true =.? \ng (retval < 0)). Since all paths in g result in a return value greater than or equal to 0, this \u00acmay \nresult is encoded as a not-may summary (true =. g (retval < 0)). Once this not-may summary is computed, \nit can be used at all the call-sites of g in function main (at lines 1,2 and 3) to show that the assertion \nfailure in line 5 can never be reached. Example 2. Consider the example program in Figure 2. Function \nf has two branches, one of which (the else branch) is hard to analyze since it invokes a complicated \nor even unknown hash function h. As before, SMASH .rst tries to .nd an execution along the path 1, 2,3,4, \n5,6,7. From the conditions in lines 4, 5 and 6, it incrementally collects the constraints x1 > 0, x2 \n> 0, and x3 > 0, and generates a query (true =.? f (retval > 0)) for function f where retval denotes \nthe return value of that function. SMASH now searches for an execution path in f that satis.es the postcondition \n(retval > 0) and computes the must summary must ((i> 0) =. f (retval > 0)) by exploring only the if branch \nof the conditional at line 11 and avoiding the exploration of the complex function h in the else branch. \nOnce this must summary is computed for f, a symbolic execution along the path 1, 2, void main(int j) \nint foo(int i,j) {{ 1:inti=0; 11:if(j>0) 2: x = foo(i,j); 12: return bar(i)+1; 3: if (x == 1) 13: else \n4: assert(false); 14: return i+1; }} Figure 3. Example of must summary bene.ting from not-may summary. \nvoid main(int i,j) int foo(int i,j) {{ 0: int x; 10: int r,y; 1:if(i>2&#38;&#38;j>2){ 11:y=bar(i); 2: \nx = foo(i,j); 12: if (y > 10) 3: if(x<0) 13: r=g(j); 4: assert(false); 14: else } 15: r=y; } 16: return \nr; } int g(int j) { 20: if (j > 0) 21: return j; 22: else 23: return -j; }  Figure 4. Example of not-may \nsummary bene.ting from must summary. 3, 4, 5, 6, 7 can reuse this summary (as in SMART [1, 14]) at the \ncall sites at lines 1,2 and 3 without descending into f any further. Next, SMASH generates a test input \nfor main satisfying the constraints i1 > 0 . i2 > 0 . i3 > 0 to prove that the assertion violation in \nline 7 can be reached. Next, we illustrate the interplay between not-may summaries and must summaries \nin Example 3 and Example 4. Example 3. Consider the example in Figure 3. In this example, suppose bar \nis a complex function with nested function calls and a large number of paths, but one which already has \na not-may \u00acmay summary ((i =0) =. bar (retval = 0)). We show how this not-may summary can help with \ncomputing a must summary of foo. During the analysis of main, SMASH tries to generate an ex\u00adecution that \ngoes along the path 1,2,3,4 in function main. This results in the query ((i = 0)=.? foo (retval = 1)). \nThis query results in SMASH searching through paths in foo for an execution satisfying the query. However, \ndue to the not-may summary ((i = \u00acmay 0) =. bar (retval = 0)), SMASH is immediately able to conclude \nthat none of the paths through bar can result in the desired post\u00adcondition (retval = 1) for foo given \nthat i=0. Thus, it explores only the else branch of the if statement in line 11 and generates must the \nmust summary ((i =0 . j = 0) =. foo (retval = 1)). Note that while computing such a must summary, the \nSMASH algorithm uses the not-may summary of bar to conclude that no path through bar would result in \nthe desired post condition, hence avoiding a wasteful search through the large number of paths in bar. \nOnce the must must summary for ((i =0 . j = 0) =. foo (retval = 1)) is computed, SMASH uses it to analyze \nmain and establish that any test case j = 0 violates the assertion in line 4. Example 4. Consider the \nexample in Figure 4. In this example, sup\u00adpose bar is a complex function (with loops etc.) whose set \nof possi\u00adble return values is hard to characterize precisely (perhaps because the integers returned are \nprime numbers). Assume that a prior anal\u00ad must ysis of bar results in the must summaries ((i> 5) =. \nbar (20 < must retval < 25)) and ((i = 5) =. bar (0 < retval < 5)), ob\u00adtained by symbolically executing \nspeci.c paths (tests) in bar, as \u00acmay well as the not-may summary ((true)=. bar (retval < 0)). We now \nshow how SMASH uses these must and not-may summaries for bar in order to compute a not-may summary for \nfoo proving that the assertion in line 4 of main can never be reached. SMASH .rsttriesto .ndanexecution \nalongthepath 0,1,2,3,4 tial or universal) are built up from lower-level summaries of the same type. The \nrole played by lower-level summaries of one type when computing higher-level summaries of the other type \nis only to prove the non-existence of lower-level summaries of that other type, since any query cannot \nsimultaneously have both a match\u00ading must-summary and a matching not-may summary. For instance, lower-level \nexistential summaries help prove the non-existence of matching not-may lower-level summaries, hence avoiding \nunnec\u00adessary not-may analyses, and vice versa. With this in mind, using must- (backward) or must (forward) \nsummaries does not make in main. In order to do this, it generates a query ((i> 2 . j> .foo 0)) which \nleads to an analysis of foo. much difference, as both summaries imply the non-existence of a While analyzing \nfoo, SMASH uses the available must-summaries ? 2) (retval < = matching not-may summary. In this paper, \nwe use must- sum\u00ad must must ((i> 5) =. bar (20 < retval < 25)) and ((i =5) =. bar (0 < maries for technical \nconvenience. These considerations are formal\u00adretval < 5)) in order to prove that lines 13 and 15, respectively, \nare ized and discussed in detail in Section 4. reachable (and therefore prevent a possibly expensive \nand hopeless not-may proof that one of those two branches is not feasible). 3. Single-Procedure Programs \nand May-Must Next, SMASH generates a query ((j While analyzing the body of g with precondition j> 2, \nSMASH > 2)=.g ? (retval < 0)). Analysis  concludes that the return value retval of g is always greater \nthan 0, A program P has a .nite set of variables VP . Each of these vari\u00ad \u00acmay thus generating the not-may \nsummary ((j> 2) =. g (retval < ables take values from an in.nite domain D (such as integers or 0)). Subsequently, \nwhile analyzing the path 10,11,12,14,15,16, pointers). Informally, a program is speci.ed by its variables \nand its .bar ? control .ow graph, which may contain cycles representing program SMASH generates the \nquery ((i> 2) (retval < 0)) and (retval < = loops. Each edge of the control .ow graph maps to a statement. \nIni\u00ad \u00acmay =. bar tially, we consider only two types of statements: assignments and assume statements. \nLater we will add procedure calls and returns, when we consider multi-procedure programs. uses the not-may \nsummary ((true) 0)) to answer this query. This results in the not-may summary ((i> \u00acmay 2 . j> 2) =. \nfoo (retval < 0)) for foo. Using this not-may summary for foo, SMASH is able to prove that the assertion \nin line Formally, a sequential program P is de.ned as a 6-tuple 4 of main cannot be reached. While it \nis intuitive that building not-may summaries improves (VP ,NP ,EP ,n 0 P ,n x P ,.P ) where 1. VP is \na .nite set of variables that the program manipulates (each variable takes values from an in.nite domain \nD),  2. NP is a .nite set of nodes (or program locations),  may analysis, and must summaries improve \nmust-analysis, our empirical results (see Section 5) revealed that using both not-may and must summaries \ntogether scaled better than just using may summaries or must summaries individually. We discovered the \n 3. EP . NP \u00d7 NP is a .nite set of edges, power of alternation in the process of understanding these \nempirical 4. n 0 P . NP is a distinguished entry node, 5. nP x . NP is a distinguished exit node, \n6. .P : EP . Stmts, maps each edge to a statement in the  results. In Example 3, a not-may summary of \nbar was used to compute a must-summary of foo. In Example 4, a must-summary of bar was used to avoid \na may-analysis over the return value of bar while still being able to build a not-may analysis of foo. \nEven program, We consider two types of statements: (1) assignment statements are of the form x := e \nwhere x is a variable and e is a side-effect though these examples are simple, they illustrate common \npatterns exhibited in large programs (see Section 5): some parts of large programs are more amenable \nto may analysis while other parts are more amenable to must analysis. In particular, for functions with \nmany paths due to nested calls, conditionals and loops, but simple postconditions established in a post-dominator \nof all paths (such as the last statement before return), not-may summaries can be easy to compute. Such \nnot-may summaries can be used to avoid an expensive search of (possibly in.nitely many) explicit paths \nduring must analysis, as we saw in Example 3. On the other hand, if a function has complex loops with \ncomplex loop invariants, a may analysis tends not to converge, while a must analysis of the same code \ncan easily identify be a few feasible paths that traverse entirely the function and generate usable must \nsummaries for those paths. Such must summaries can be used to avoid an expensive search for proofs in \nthese parts of the code, as illustrated in Example 4. The tight integration between may and must summaries \nallows SMASH to alternate between both in a .exible and unprecedented manner. Further, our empirical \nresults (see Figure 12 in Section 5) even quantify the amount of interaction between may analysis and \nmust-analysis for our data set. On an average (1) to generate a proof, 68% of summaries used were not-may \nsummaries and 32% of the summaries used were must summaries, and (2) to identify a bug, 64% of summaries \nused were must summaries and 36% of the summaries used were not-may summaries. free expression over \nvariables and constants, and (2) assume (or conditional) statements are of the form assume(e), where \ne is a side-effect free expression. A con.guration of a program P is a pair (n, s) where n . NP and s \nis a state, de.ned below. A state of a program P is a valuation to the program variables VP . The set \nof all states of P is denoted by SP . An assignment statement is a function SP . SP since it maps every \nstate s to a state obtained by executing the assignment. An assume statement assume(e) is a partial function \nover SP . If e evaluates to true in a state s, then the function maps s to itself. Otherwise, it is unde.ned \nover s. Thus, every edge e . EP can be thought of as a relation Ge . SP \u00d7 SP . So far, Ge is actually \na partial function, but it is convenient to think of it as a relation and the generality will help when \nwe consider multi-procedure programs. Note that though each statement of the program is deterministic \n(i.e, Ge is a partial function), the program P has control nondeter\u00adminism, since nodes in NP can have \nmultiple outgoing edges in EP . The initial con.gurations of a program P are given by the set {(n 0 \n0 P ,s)| s . SP }. That is, the node nP is the entry node of the program, and the state s is any possible \nstate where variables can Note that must summaries are existential while not-may sum-take any values. \nFrom any con.guration (n, s), the program can maries are universal. Higher-level summaries of one type \n(existen-execute a step by taking any outgoing edge of e = (n, n') out of ? (. 1 =.P . 2) 0 [ INIT-OMEGA \n] O 0 .1 }.On := {} := .n . NP \\{n nP P e = (n1,n2). EP . . Post(Ge, On1 ) [ MUST-POST ] On2 := On2 . \n. (. 1 .? P .2) Ox n . 2 = = {} n P [ BUGFOUND ] (. 1 =.? P . 2) = yes Figure 6. Must analysis. n and \ntransitioning to a state obtained by computing the image of the relation Ge with respect to the state \ns. That is, if there exists s ' such that Ge(s, s ' ), then the program can transition to the con.g\u00aduration \n(n ' ,s ' ). Starting from an initial con.guration, a program can execute several steps producing several \ncon.gurations. A veri.cation question for program P is formalized as a reach\u00adability query of the form \n(.1 =.? P .2), where .1 represents a set of initial states at entry node nP 0 , and .2 represents a set \nof states at the exit node nP x . The reachability query evaluates to yes (mean\u00ading the program is incorrect) \nif there exists an execution which starts at a con.guration (nP 0 ,s1) with s1 . .1 and ends at a con\u00ad.guration \n(nP x ,s2) with s2 . .2, it evaluates to no if such an execution provably does not exist, or it evaluates \nto unknown oth\u00aderwise. Indeed, the veri.cation question is undecidable in general, particularly if the \ndomain D of values taken by variables is in.\u00adnite. Even if D is .nite, the number of con.gurations is \nexponen\u00adtial in the number of variables VP making an exact answer to this question computationally dif.cult \nto ascertain. Thus, in practice, approximate methods are used to answer the veri.cation question. Note \nthat speci.cations in the style of Hoare triples such as {.1} P {.2}, where we want all executions starting \nfrom states in .1 to end in states from .2, can be expressed in our notation ? as the query (.1 =.P \u00ac.2). \nAssertions in the form used in the example programs from Section 2 can also be expressed in this form \nby adding a special boolean variable error which is set to false initially and set to true if an assertion \nfails, enabling us to state an equivalent speci.cation (SP =.? P error). We recall the formal de.nitions \nof the preimage Pre and post\u00adcondition Post operators that will be used later. Suppose Ge . SP \u00d7 SP , \nand . . SP . The precondition of . with respect to Ge (denoted Pre(Ge,.)) is the set of all predecessors \nof states in . given by def '' Pre(Ge,.)= {s . SP |.s ...Ge(s, s )} In a dual way, the postcondition \nof . with respect to Ge (denoted Post(Ge,.)) is given by def '' Post(Ge,.)= {s . SP |.s ...Ge(s ,s)} \n 3.1 May Analysis A may analysis of a program is used to prove that the program never reaches an error \nnode during any execution. Formally, a may analysis of a program P associates every node n in NP with \na .nite partition .n of SP , and every edge e = (n1,n2). EP with a set of edges .e . .n1 \u00d7 .n2 , such \nthat, for any region p1 in .n1 , and any region p2 in .n2 , if .s1 . p1..s2 . p2.Ge(s1,s2) then (p1,p2). \n.e. By construction, the edges .e over-approximate the transition relation of the program, and are called \nmay edges or transitions. A partition .n for a node n is de.ned as a set of regions. Associated with \nevery program edge e = (n1,n2), initially there is a may edge from every region of the partition .n1 \nto every region of the partition .n2 . As the algorithm proceeds, partitions get re.ned and may edges \nget deleted. Instead of deleting edges, we .nd it notationally convenient to maintain the complement \nof may edges, called Ne edges below. The set of Ne edges grows monotonically as the algorithm proceeds. \n In response to a query (. 1 =?.P . 2), if there is no path through the edges .e from every region .1 \nassociated program s entry node n 0 P such that .1 n . 1 = {} to every region . 2 associated with the \nexit node nP x such that .2 n. 2 = {}, then the may analysis proves that none of the states in . 2 can \nbe reached at the exit node of P by starting the program with states from . 1. Figure 5 gives a set of \ndeclarative rules to perform a may analysis which automatically re.nes partitions in a demand-driven \nmanner. In response to a query (. 1 =?.P . 2), the rule INIT-PI-NE initializes the exit node nP x with \na partition consisting of two regions . 2 and SP \\ . 2. All other nodes are initialized to have a single \npartition with all possible states SP . The current set of rules performs backward may analysis, using \nthe Pre operator. Thus, to allow maximum .exibility, we do not partition the initial node with the precondition \n. 1 from the query. The precondition . 1 is used in the last rule VERIFIED described below. The rule \nalso initializes an empty relation Ne associated with each program edge e. Relation Ne is the complement \nof .e and is used to keep track of may edges that we know for sure do not exist. Abstractpartitionre.nementisperformedusingtherule \nNOTMAY-PRE. The rule NOTMAY-PRE chooses two nodes n1 and n2, a re\u00adgion .1 in the partition .n1 of n1, \nand a region .2 in the partition .n2 of n2, and then splits .1 using the precondition . of .2 with respect \nto the transition relation on the edge e = (n1,n2). We de\u00adnote splitting the region .1 in partition .n1 \ninto two sub-regions .1 n . and .1 n\u00ac. by .n1 := (.n1 \\{.1}) .{.1 n ., .1 n\u00ac.}. After the split, we know \nby construction and the de.nition of Pre that any state in the new region .1 n\u00ac . cannot possibly lead \nto a state in region .2, and we record this in relation Ne accordingly. Note that a superset of the precondition \ncan be used as valid ap\u00adproximations to do splits. Such approximations are necessary in practice whenever \nPre cannot be computed precisely. A dual rule NOTMAY-POST for splitting regions using the op\u00aderator Post \nin the forward direction exists but is omitted here. The IMPL-RIGHT rule allows Ne edges of the form \n(.1,.2) to be maintained as the post-regions .2 get re.ned. The rules IMPL-LEFT rule allows Ne edges \nof the form (.1,.2) to be maintained as the pre-regions .1 get re.ned. The VERIFIED rule says that as \nsoon as all paths from the entry node regions that intersect with the precondition of the query . 1 to \nthe exit node region that intersects with the postcondition of the query . 2 have at least one step where \nthe may analysis shows that the edge does not exist, then we have veri.ed that the answer to the query \n(. 1 =.? P . 2) is no and hence that the program is correct. It is easy to show that, at every re.nement \nstep, the transition system de.ned over the partitioned regions simulates the program P. Thus, the incremental \ninference of relation Ne made by the may analysis is always guaranteed to be sound with respect to P. \nHowever, there is no guarantee that, if the program is correct, the re.nement process will ever converge \nto such an answer. For .nite\u00adstate programs, the process is guaranteed to terminate. The partition splits \nspeci.ed in the rules of Figure 5 are nonde\u00adterministic. Speci.c abstraction-re.nement tools such as \nSLAM [4] can be viewed as instantiating this framework by re.ning regions only along abstract counterexamples \nthat lead from the starting node to the error node. ? (. 1 =.P . 2) [ INIT-PI-NE ] x .x := {. 2, SP \n\\ . 2}.n . NP \\{n}..n := {SP }.e . EP .Ne := {} nP P .1 . .n1 .2 . .n2 e = (n1,n2). EP . . Pre(Ge,.2) \n[ NOTMAY-PRE ] .n1 := (.n1 \\{.1}) .{.1 n ., .1 n\u00ac.} Ne := Ne .{(.1 n\u00ac ., .2)} (.1,.2) . Ne .1 . . .1 \n(.1,.2) . Ne .2 . . .2 [ IMPL-LEFT ][ IMPL-RIGHT ] Ne := Ne .{(.1. ,.2)} Ne := Ne .{(.1,.2. )} ? (. \n1 =.P . 2) 0 x .n0,...,nk...0,...,.k.n0 = n . nk = n . .0 . .n0 . .1 . .n1 \u00b7\u00b7\u00b7 .k . .nk . .0 n . 1 = \n{} . .k n . 2 = {} PP ..0 = i = k - 1.e = (ni,ni+1). EP . (.i,.i+1) . Ne [ VERIFIED ] ? (. 1 =.P . \n2) = no Figure 5. May analysis. .1 . .n1 .2 . .n2 e = (n1,n2). EP On1 n .1 = {} On2 n .2 = {} . . Post(Ge, \nOn1 n .1) .2 n . = {} [ MUST-POST ] On2 := On2 . . .1 . .n1 .2 . .n2 e = (n1,n2). EP On1 n .1 = {} \nOn2 n .2 = {} \u00df . Pre(Ge,.2) \u00df n On1 = {} [ NOTMAY-PRE ] .n1 := (.n1 \\{.1}) .{.1 n \u00df, .1 n\u00ac\u00df} Ne := \nNe .{(.1 n\u00ac\u00df, .2)} Figure 7. May-Must analysis. Rules INIT-PI-NE, IMPL-LEFT, IMPL-RIGHT and VERIFIED \nare assumed to be included from Figure 5, and rules INIT-OMEGA and BUGFOUND are assumed to be included \nfrom Figure 6. 3.2 Must Analysis A must analysis of a program is used to prove that the program reaches \na given set of states during some execution. While a may analysis over-approximates reachability information \nin order to prove the absence of errors, a must analysis under-approximates reachability information \nin order to prove the existence of execu\u00adtion paths leading to an error. A must analysis based on succes\u00adsive \npartition re.nements can be de.ned by dualizing the rules pre\u00adsented in the previous section. However, \nsplitting must partitions is no longer guaranteed to preserve previously-computed must transi\u00adtions and \nother techniques (such as hyper-must transitions or carte\u00adsian abstraction) are needed to restore the \nmonotonicity of must\u00adpartition re.nement [15]. In this paper, we consider a speci.c type of must abstractions \nwhich avoid the issues above. Speci.cally, a must analysis of a program P associates every node n in \nNP with a set On of states that are all guaranteed to be reachable from the initial state of the program. \nThe set On of states associated with a node n increases monotonically during the must analysis and is \nnever partitioned. Figure 6 gives a set of declarative rules to perform a must analysis using sets On. \nIn response to a query (. 1 =?.P . 2), we initialize O0 with n P . 1 and for all other nodes n we initialize \nOn to be the empty set (rule INIT-OMEGA). The rule MUST-POST speci.es how to perform a forward must\u00adanalysis \nusing the postcondition operator Post: the postcondition . of On1 with respect to the transition relation \nassociated with an edge e from node n1 to node n2 can be safely added to On2 . If the postcondition Post \ncannot be computed precisely, any subset is a valid approximation. This formalization includes as a speci.c \ncase DART [16], where complex constraints are simpli.ed by substitut\u00ading symbolic expressions with concrete \nvalues observed dynami\u00adcally during testing. A rule MUST-PRE for backward must-analysis using the pre\u00adcondition \noperator Pre can be written as the dual of rule MUST-POST, but is omitted here. During the analysis of \na query (. 1 =?.P . 2), if Onx ever P intersects with . 2, then we can conclude that the answer to the \nquery is yes (rule BUGFOUND). 3.3 May-Must Analysis May and must analysis have complementary properties \n the for\u00admer is used for veri.cation and the latter for bug .nding. Figure 7 shows a set of rules that \ncombine may and must rules in order to perform both a may and a must analysis simultaneously. The rules \nINIT-PI-NE, IMPL-LEFT, IMPL-RIGHT and VERIFIED are included as is from Figure 5, and rules INIT-OMEGA \nand BUG-FOUND are included as is from Figure 6, so we do not repeat them here. The interesting rules \nare MUST-POST and NOTMAY-PRE. Sup\u00adpose edge e = (n1,n2) is such that .1 . .n1 and .2 . .n2 . Furthermore, \nsuppose that .1 n On1 = {}, and .2 n On2 = {}. This means that we know that the partition .1 . .n1 is \nindeed reachable (since it intersects with the region On1 ), and we do not know if .2 . .n2 is reachable \n(since it does not intersect with the region On2 ). If we can compute a subset of the postcondi\u00adtion \n. . Post(Ge,.1 n On1 ) such that . intersects with .2, then we simply augment On2 with ., as speci.ed \nin the rule MUST-POST. Dually, if we can compute a superset of the precondition \u00df . Pre(Ge,.2) such that \n\u00df does not intersect with On1 , then we split the region .1 . .n1 using \u00df and we know that region .2 \nis not reachable from region .1 n\u00ac\u00df, as speci.ed in the rule NOTMAY-PRE. Note that any interpolant (see \n[27]) between the sets Pre(Ge,.2) and On1 satis.es the conditions to be used as \u00df, and can be used to \nsplit the region .1. These rules can be instantiated to obtain the SYNERGY [19] and DASH [5] algorithms. \nThese algorithms have the speci.c property that, whenever one can compute precisely Post, equivalently \nPre, then either rule MUST-POST or rule NOTMAY-PRE must be en\u00adabled, and a single call to a theorem prover \nto compute Post/Pre is then suf.cient to re.ne either the current must or may (respec\u00adtively) program \nabstraction. 4. Multi-Procedure Programs and Compositional May-Must Analysis In programs with multiple \nprocedures, compositional analyses, which analyze one procedure at a time and build summaries for each \nprocedure for possible re-use in other calling contexts, are de\u00adsired for scalability. We describe how \nto do compositional analysis with may abstractions, must abstractions and by combining may\u00admust abstractions. \nFirst, we extend our program notation to allow programs with multiple procedures. A multi-procedure program \nP is a set of single-procedure pro\u00ad grams {P0, P1,..., Pn}. Each of the single-procedure programs follows \nthe notation described earlier, with the following modi\u00ad to split a region . . .n1 along the lines of \nthe NOTMAY-PRE rule. Recall that if ( \u00ac=may . 2) is a not-may summary, then there is .1 . Pi no transition \nfrom any state in . 1 to any state in . 2. Thus, for any subset . of . 1 there exists no transition from \nany state in . to any state in .2 . . 2. This justi.es the Ne edge {(.1 n ., .2)} in the consequent of \nthe rule. The rule MAY-CALL generates a query in the context of a called procedure. For notational convenience, \nwe assume that the partitions .n for each node n and the edges Ne are computed afresh for each invocation \nof a query. (Note that intraprocedural inference steps could themselves be summarized and re-used across \nmultiple query invocations.) The rule CREATE-NOTMAYSUMMARY is used to generate a not-may summary from \nNe edges. If all paths from every region .0 in .n0 (which overlaps with the query states . 1) to every \nP i region .k in .n x Pi (which overlaps with the query states . 2) pass .cations. There are global \nvariables common to all procedures, and local variables private to each procedure (more precisely, pri\u00advate \nto each invocation of a procedure). Thus, for any single\u00adprocedure program Pi (also called procedure \nPi), we have that Pi = (VPi ,NPi ,EPi ,n 0 ,n x ,.Pi ) where VPi is the disjoint Pi Pi union of global \nvariables V G and local variables VPL i . Parameters and return values can be simulated using global \nvariables, so we do not explicitly model these. Without loss of generality, we assume each procedure \nhas a single entry node nP0 i and a single exit node nPx i . For any two distinct procedures Pi and Pj \n, we assume that NPi and NPj are disjoint. Thus a node unambiguously identi.es which procedure it is \nin. We use SPi to denote the set of all possi\u00adble valuations to VPi . In addition to the assignment and \nassume statements, we add a new statement call p where p is the name of the procedure being called. Procedure \nP0 is the main procedure where the program starts executing. As before, all global variables initialize \nnonde\u00adterministically to any value in the initial con.guration. Whenever a procedure is entered, its \nlocal variables are initialized nondeter\u00administically. Unlike local variables, global variables get initialized \nonly once at the beginning of execution, and can be used for com\u00admunication between procedures. We use \nthe query notation to specify veri.cation questions for multi-procedure programs as well. In particular, \nfor multi\u00adprocedure programs, we assume that the query is asked in terms ? of the main procedure P0, \nand is of the form (.1 =.P0 .2). Our compositional analyses solve the veri.cation question by formu\u00adlating \nvarious sub-queries to procedures that are called from P0, and then sub-queries to procedures called \nby those procedures and so on. Each sub-query is de.ned in the context of a particular pro\u00adcedure, and \nis solved by analyzing the code of that procedure in combination with summaries for other called procedures. \nWe have presented the rules in Section 3 in such a way that they can easily be extended to work with \nsummaries. In particular, the through at least one Ne edge, we can conclude that there are no paths from \nstates in .0 to states in .k. Thus, we can add a not-may summary between these two sets of states after \nquantifying out the local variables that are irrelevant to the calling contexts. The rule MERGE-MAYSUMMARY \nallows not-may summaries to be merged. The correctness of this rule follows from the de.ni\u00adtion of not-may \nsummaries. If there are no paths from states in .1 to states in ., and there are no paths from states \nin .2 to states in ., we can conclude that there are no paths from states in .1 ..2 to states in .. Merged \nsummaries can contribute to larger sets . used to split regions in the NOTMAY-PRE-USESUMMARY rule. 4.2 \nCompositional Must Analysis The rules in Figure 9 along with the intraprocedural rules described in Figure \n6 de.ne compositional must analysis. The set of must-summaries for each procedure Pi is denoted must \n by =. Pi . This set is initialized to the empty set in the rule INIT-NOTMAYSUM, and it monotonically \nincreases as the analysis proceeds. The rule MUST-POST-USESUMMARY is very similar to the rule MUST-POST \nin the intraprocedural must analysis. The only differ\u00adence here is that the node n1 is a call node, representing \na call to another procedure Pj . If a suitable must summary (.1,.2) exists, the rule uses the must summary \nto compute an underapproximation to the postcondition. The rule MUST-CALL creates a new sub-query for \na called procedure Pj , which can result in new summaries created for Pj . As in the compositional may \nanalysis case, we assume again for notational simplicity that the sets On for each node n are computed \nafresh for each query. The rule CREATE-MUSTSUMMARY creates must summaries in the context of the current \nquery for the procedure. Suppose (. 1 =.? Pi . 2) is the current query for the procedure Pi. Suppose \n. = .VPL i .Onx represents the global state reached at the exit point P edges Ne from Figure 5 can be \nused to build not-may summaries, and the sets On from Figure 6 can be used to build must summaries. Given \na set S . SPi , we use .VPL i .S to denote the set of global states obtained by considering only the \nvalues of global variables i of the procedure Pi by using must analysis. Further suppose that . intersects \nwith the post-state of the query .2. Then, we add the must summary {( .1,.)} since every state in . can \nbe obtained by executing the procedure starting at some state in .1. of each state in S. 4.1 Compositional \nMay Analysis Figure 8 gives the rules for compositional may analysis. The rules for intraprocedural may \nanalysis from Figure 5 are assumed to be included and are not repeated. The rules maintain a set \u00ac=may \nof not-may summaries for . Pi each procedure Pi. The rule INIT-NOTMAYSUM initializes the set of not-may \nsummaries of all procedures to empty sets. The rule NOTMAY-PRE-USESUMMARY uses an existing not-may summary \n Finally the rule MERGE-MUSTSUMMARY allows merging must summaries. The correctness of this rule follows \nfrom the de.nition of must summaries. If every state in .1 can be reached from some state in ., and every \nstate in .2 can be reached from some state in ., it follows that every state in .1 ..2 can be reached \nfrom some state in .. These sets of rules can be instantiated to obtain a variant of the SMART algorithm \n[14], a compositional version of the DART al\u00adgorithm. Indeed, our rules compute summaries for speci.c \ncalling contexts (see . in rule MUST-CALL) and record those in the pre\u00ad procedure Pi .P [ INIT-NOTMAYSUM \n] \u00acmay =. Pi := {} .1 . .n1 .2 . .n2 e = (n1,n2). EPi is a call to procedure Pj \u00acmay ( =. . .1,. 2) \n.. Pj .2 . . 2 .1 [ NOTMAY-PRE-USESUMMARY ] .n1 := (.n1 \\{.1}) .{.1 n ., .1 n\u00ac.} Ne := Ne .{(.1 n ., \n.2)} .1 . .n1 .2 . .n2 e = (n1,n2). EPi is a call to procedure Pj [ MAY-CALL ] ? (.1 =.Pj .2) ? (. \n1 =.Pi . 2) 0 x .n0,...,nk...0,...,.k.n0 = n . nk = n . .0 . .n0 . .1 . .n1 \u00b7\u00b7\u00b7 .k . .nk . .0 n . 1 \n= {} . .k n . 2 = {} Pi Pi ..0 = i = k - 1.e = (ni,ni+1). EP . (.i,.i+1) . Ne .1 = {. . . 0 | . n . \n1 = {}} .2 = {. . .nx | . n . 2 = {}} n Pi Pi [ CREATE-NOTMAYSUMMARY ] \u00acmay \u00acmay =. Pi := =. Pi . (.V \nL ..1, .V L ..2) Pi Pi \u00acmay \u00acmay (.1,.) . =. Pi (.2,.) . =. Pi [ MERGE-MAYSUMMARY ] \u00acmay \u00acmay =. Pi \n:= =. Pi .{(.1 . .2,.)} Figure 8. Compositional May analysis. Rules from Figure 5 are assumed to be included, \nbut not shown. procedure Pi .P [ INIT-MUSTSUMMARY ] must =. Pi := {} e = (n1,n2). EPi is a call to \nprocedure Pj must (.1,.2) . =. Pj On1 . .1 . . .2 [ MUST-POST-USESUMMARY ] On2 := On2 . . e = (n1,n2). \nEPi is a call to procedure Pj [ MUST-CALL ] ? (On1 =.Pj SP ) ? (. 1 =. 2) . = .V L .Ox . n . 2 = {} \n[ CREATE-MUSTSUMMARY ] .Pi PinPi must must =. Pi := . Pi .{( =.1,.)} must must (., .1) . =. Pi (., .2) \n. =. Pi [ MERGE-MUSTSUMMARY ] must must =. Pi := =. Pi .{(., .1 . .2)} Figure 9. Compositional Must \nanalysis. Rules from Figure 6 are assumed to be included, but not shown. conditions of summaries. In \ncontrast, preconditions of summaries in SMART are expressed exclusively in terms of the procedure s in\u00adput \nvariables and calling contexts themselves are not recorded. The summaries of SMART can therefore be more \ngeneral (hence more re-usable), while our summaries record must-reachability informa\u00adtion more precisely, \nwhich in turns simpli.es the formalization and the combination with not-may summaries, as is discussed \nnext.  4.3 SMASH: Compositional May-Must Analysis The rules for compositional may-must analysis combine \nthe may rules and the must rules in the same way as in the single proce\u00addure case. The set of rules is \nshown in Figure 10. All rules from compositional may analysis (Figure 8), compositional must analy\u00adsis \n(Figure 9), and intraprocedural may-must analysis (Figure 7) are included but not shown, except the rules \nMAY-CALL and MUST-CALL which are replaced by the new rule MAYMUST-CALL, and except the rules MUST-POST-USESUMMARY \nand NOTMAY-PRE-USESUMMARY which are modi.ed as shown in Figure 10. The succinctness of these rules hides \nhow not-may summaries and must summaries interact, so we explain this in more detail. Each query made \nto SMASH can be answered with either a not-may summary or a must summary, but not both. Whenever SMASH \nana\u00adlyzes a procedure Pi and encounters an edge e in Pi calling another procedure Pj , SMASH can either \nuse an existing must summary for procedure Pj (using the rule MUST-POST-USESUMMARY), or an existing not-may \nsummary for Pj (using the rule NOTMAY-PRE-USESUMMARY), or initiate a fresh query to Pj (using the rule \nMAY-MUST-CALL). Note that when the rule MAY-MUST-CALL generates a query for the called procedure Pj , \nwe do not know if the query will result in creating not-may summaries or must summaries. If the body \nof Pj calls another procedure Pk, an\u00adother query can be potentially generated for that procedure as well. \nEventually, some of the calls could be handled using must sum\u00admaries (using the rule MUST-POST-USESUMMARY), \nand some of the calls using not-may summaries (using the rule NOTMAY-PRE-USESUMMARY). Thus, not-may summaries \ncan be used to create must summaries and vice versa, as illustrated in Section 2 with Ex\u00adamples 3 and \n4. The rule MUST-POST-USESUMMARY is similar to the rule MUST-POST in Figure 7. The main difference is \nthat the edge e is a call to another procedure Pj . Assuming a suitable must summary exists, the rule \nuses the must summary as the transition relation of the procedure call in order to perform the equivalent \nof a Post computation. Suppose edge e = (n1,n2) is such that .1 . .n1 .1 . .n1 .2 . .n2 .1 n On1 = {} \n.2 n On2 = {} e = (n1,n2). EPi is a call to procedure Pj must ( .1,. 2) . =. Pj On1 . . 1 . . . 2 .2 \nn . = {} [ MUST-POST-USESUMMARY ] On2 := On2 . . .1 . .n1 .2 . .n2 .1 n On1 = {} .2 n On2 = {} e = (n1,n2). \nEPi is a call to procedure Pj \u00acmay ( =. Pj . . = {} .1,. 2) . .2 . . 2 .1 \u00ac. n On1 [ NOTMAY-PRE-USESUMMARY \n] .n1 := (.n1 \\{.1}) .{.1 n ., .1 n\u00ac.} Ne := Ne .{(.1 n ., .2)} .1 . .n1 .2 . .n2 .1 n On1 = {} .2 n \nOn2 = {} e = (n1,n2). EPi is a call to procedure Pj .1 =(.1 n On1 ) .2 = .2 [ MAY-MUST-CALL ] ? (.1 \n=.Pj .2) Figure 10. SMASH: Compositional May-Must analysis. All rules from compositional may analysis \n(Figure 8), compositional must analysis (Figure 9), and intraprocedural may-must analysis (Figure 7) \nare included but not shown, except the rules MAY-CALL and MUST-CALL which are replaced by the new rule \nMAYMUST-CALL, and except the rules MUST-POST-USESUMMARY and NOTMAY-PRE-USESUMMARY which are modi.ed as \nshown above. and .2 . .n2 . Furthermore, suppose that .1 n On1 = {}, .2 n On2 = {}, and ( .1,. 2) is \na must-summary for Pj , with On1 . . 1. Since ( .1,. 2) is a must-summary, we know that all the states \nin . 2 are reachable by executions of Pj from states in . 1. Since On1 . . 1, this implies that any subset \n. . . 2 can be reached from the set of sates On1 by executing the procedure Pj . Thus, we can add . to \nthe set of states On2 , which are the set of states that are guaranteed to be reachable at node n2 during \nthis execution of procedure Pj . Similarly, the rule NOTMAY-PRE-USESUMMARY is like the rule NOTMAY-PRE \nin Figure 7. The main difference is again that the edge e is a call to another procedure Pj . Assuming \na suitable not-may summary exists, the rule uses the not-may summary as the transition relation of the \nprocedure call to perform the equivalent of a Pre computation. Suppose e, .1 and .2 satisfy the same \nassumptions as above, and there is a not-may summary ( .1,. 2) with .2 . . 2. Since ( .1,. 2) is a not-may \nsummary, we know that there are no executions of the procedure Pj starting at any subset . . . 1 resulting \nin states in . 2. Thus, we can partition the region .1 . .n1 with the guarantee that there are no transitions \nfrom .1 n. to .2, and hence we can add (.1 n., .2) to Ne. We can use interpolants (as discussed in Section \n3.3) to choose possible values for .. Given e, .1,.2, On1 , we can show that both rules MUST-POST-SUMMARY \nand NOTMAY-PRE-USESUMMARY can never be simultaneously enabled since, by construction, it is not possible \nto both have a must summary ( .1,. 2) and a not-may summary (.1,.2) for a procedure such that .1 . . \n1 and .2 . . 2. Recursion. To avoid clutter, the rules for our compositional algo\u00adrithms (Figures 8, \n9 and 10) have been written for non-recursive programs. To handle recursive programs, we need to keep \ntrack for each function which queries are in progress, and also constrain the ? order in which rules \nare applied. When a query (. 1 =.P . 2) is made, in addition to checking whether existing not-may or \nmust summaries can be used to answer the queries (using rules MUST-POST-SUMMARY and NOTMAY-PRE-USESUMMARY), \nwe need to also check if this query can be answered by another in-progress query (.1 =.? P .2), and start \ncomputations for the current query only if no such in-progress query exists. Such a check would guar\u00adantee \ntermination of the SMASH algorithm for recursive programs where data types are over a .nite domain and \nno dynamic alloca\u00adtion is allowed (for instance, as in boolean programs [3]). However, if data types \nare unbounded or if dynamic allocation is allowed, checking a query is undecidable and SMASH is not guaranteed \nto terminate. Soundness. To establish soundness, we assert the following .ve invariants over the data \nstructures of the SMASH algorithm: I1. For every node n . NPi , .n is a partition of SPi . I2. For every \nnode n . NPi and every state s . On, s is reachable by some program execution at node n starting from \ninitial state of the program. I3. For every (.1,.2) . Ne, and any s1 . .1, it is not possible to execute \nthe statement at edge e starting from state s1 and reach a state s2 . .2. \u00acmay I4. For every (.1,.2) \n. =. Pi , for any state s1 . .1, it is not possible to execute procedure Pi starting at state s1 and \nreach a state s2 . .2 after completing the execution of Pi. must I5. For every (.1,.2) . =. Pi , for \nany state s2 . .2, there exists a state s1 . .1 such that executing the procedure Pi starting at state \ns1 leads to the state s2. The correctness of these invariants is established by induction over each of \nthe rules of the SMASH algorithm. As an example, we show the induction step for the rule NOTMAY-PRE-USESUMMARY \nfrom Figure 10. We need to establish that the re.nement to .n1 respects invariant I1, and the new edge \nadded to Ne respects the invariant I3. Due to the induction hypothesis, we can assume that .n1 before \nexecution of the rule is a partition. For any .1 . .n1 , and any value of ., since .n1 is a partition, \nwe have that (.n1 \\{.1}) . {.1 n ., .1 n\u00ac.} is a partition, hence preserving invariant I1. Next, consider \nthe edge (.1 n ., .2) that is added to Ne. Due \u00acmay to the antecedent of the rule, since ( .1,. 2) . \n=. Pj , due to induction hypothesis I4 we know that no state in . 1 can reach any state in . 2 by executing \nprocedure Pj . Since . . . 1, we have that .1 n . . . 1. Consequently, we have that no state in .1 n \n. can reach any state in .2 . . 2 by executing Pj , and it follows that the updated Ne satis.es the invariant \nI3. The soundness of all the other rules is proved in a similar way. 5. Evaluation In this section, we \ndescribe our implementation of SMASH and present results of experiments with several Microsoft Windows \n7 device drivers. 5.1 Implementation Our tool SMASH is a deterministic implementation of the declara\u00adtive \nrules of Figure 10, developed in the F# programming language and using the Z3 theorem prover [12] . Recall \nthat every reachabil\u00adTable 1. SMASH vs. DASH on 69 drivers (342000 LOC) and 85 properties. Statistics \nDASH (Figure 7) SMASH (Figure 10) Average Not-May Summaries/driver 0 39 Average Must Summaries/driver \n0 12 Number of proofs 2176 2228 Number of bugs 64 64 Time-outs 61 9 Time (hours) 117 44 ity query (.1 \n=.? Pi .2) for a procedure Pi can be answered exclu\u00adsively by either a must summary or a not-may summary. \nTherefore, the SMASH implementation makes the rules given in Figure 10 de\u00adterministic as shown below: \nmust 1. If some previously computed must summary (. 1 =. Pi . 2)is applicable, return yes . \u00acmay 2. If \nsome previously computed not-may summary (. 1 =. Pi . 2)is applicable, return no . 3. Otherwise, analyze \nthe procedure Pi using the rule MAY-MUST-CALL. The result of this analysis could be itself ei\u00adther a \nyes (computation of a must summary for Pi given by the rule CREATE-MUSTSUMMARY) or a no (computa\u00adtion \nof a not-may summary for Pi given by the rule CREATE-MAYSUMMARY).  SMASH s intraprocedural analysis \nimplements the DASH algo\u00adrithm [5] which is an instance of the may-must analysis shown in Figure 7. We \nhave implemented SMASH using the YOGI frame\u00adwork [29] which handles C programs with primitive data types, \nstructs, pointers, function pointers and procedures. Pointer arith\u00admetic is not handled *(p+i) is treated \nas *p, similar to SLAM [4] and BLAST [24]. All predicates used to build may and must pro\u00adgram abstractions \nare propositional logic formulas de.ned over lin\u00adear arithmetic and uninterpreted functions stored in \nZ3 s internal representation. With these assumptions, the logic is decidable and therefore every satis.ability/validity \nquery to the theorem prover results in either a yes or no answer.  5.2 Experiments We evaluated SMASH \non 69 Microsoft Windows 7 device drivers and 85 properties. We performed our experiments using a system \nwith a 2.66 GHz Intel Xeon quad core processor with 4GB RAM running Microsoft Windows Server 2003. Overall \ncomparison. A comparison of SMASH with DASH [5] (this is the non-compositional may-must analysis described \nin Fig\u00adure 7) on all 69 device drivers and 85 properties is shown in Ta\u00adble 1. The total number of lines \nof code analyzed is 342000 lines of code. The total number of checks (we will refer to every veri.cation \nquestion involving a driver and a property1 as a check) performed by both analyses is 2301 (the rest \ncorrespond to checks where the property is not applicable to the driver). The average number of not-may \nsummaries per driver used by SMASH is 39 and the aver\u00adage number of must summaries per driver equals \n12. With a time\u00adout limit of 30 minutes, there are 61 checks where DASH times out while SMASH times out \nonly on 9 checks. The total time taken for the analysis by DASH is 117 hours while SMASH takes only 44 \nhours, including time-outs. It is worth emphasizing that our non\u00ad 1 Properties are typestate properties \nfor device drivers as described in http: //msdn.microsoft.com/en-us/library/aa469136.aspx.  Figure 11. \nComparison of SMASH with COMPOSITIONAL-MAY-DASH, COMPOSITIONAL-MUST-DASH and DASH on 303 checks. compositional \nanalysis baseline DASH is already an improvement over SLAM [4] (see [5]). Detailed comparison on 16 drivers. \nTo understand the effective\u00adness of SMASH, we drill down into empirical data for 16 drivers (arbitrarily \npicked from the 69 drivers) in Table 2. Every row of this table shows a driver along with its number \nof lines of code and the number of properties checked. We compare SMASH against DASH, DASH with compositional \nmay analysis (rules of Figures 7 and 8, denoted by COMPOSITIONAL-MAY-DASH), and DASH with compositional \nmust analysis (rules of Figures 7 and 9, denoted by COMPOSITIONAL-MUST-DASH). The total time taken by \neach analysis is reported in minutes. We also report the average number of not-may/must summaries used \nby each analysis for each driver. It is clear from Table 2 that SMASH outperforms COMPOSITIONAL-MAY-DASH, \nCOMPOSITIONAL-MUST-DASH and DASH on all 16 drivers. This is further elucidated in Figure 11 where each \npoint (x, y) in the graph denotes the fact that there are y checks that take an average time of x minutes.Asindicatedbythecurvefor \nSMASH, a large number of checks take a relatively short amount of time with SMASH. In contrast, with \nDASH, a large number of checks take a large amount of time. The curves for COMPOSITIONAL-MAY-DASH and \nCOMPOSITIONAL-MUST-DASH are better than DASH, but are outperformed by SMASH. This data indicates that \nin addition to gains obtained by COMPOSITIONAL-MAY-DASH and COMPOSITIONAL-MUST-DASH analyses, extra gains \nare obtained in SMASH duetotheinterplaybetweenmayanalysisandmustanal\u00adysis. There are a number of checks \nwhere DASH, COMPOSITIONAL-MAY-DASH and COMPOSITIONAL-MUST-DASH time out while SMASH does not. These correspond \nto patterns like those out\u00adlined in Figures 3 and 4, which illustrate how the intricate inter\u00adplay between \nnot-may summaries and must summaries can prevent SMASH from getting stuck . However, SMASH does timeout \non 1 check for the driver 1394diag and the reason for this (as well as all the 9 time-outs in Table 1) \nis that it is unable to discover the right invariant to prove the property. Table 2 also shows that the \ntotal number of summaries used by SMASH is less than the total number of summaries used by COMPOSITIONAL-MAY-DASH \nand COMPOSITIONAL-MUST-DASH put together. Since the number of summaries is related to the number of queries \n(every distinct query that cannot be answered us\u00ad Program Lines Properties DASH (Figure 7) COMPOSITIONAL-MAY-DASH \n(Figure 7 + Figure 8) COMPOSITIONAL-MUST-DASH (Figure 7 + Figure 9) SMASH (Figure 10) (LOC) Summaries \nTime-outs Time Summaries Time-outs Time Summaries Time-outs Time Summaries Time-outs Time (min) (min) \n(min) Not-May Must (min) parport 33987 8 0 0 45 0 0 14 6 0 44 0 6 0 14 serial1 32385 18 0 11 420 64 7 \n310 8 7 278 64 7 0 59 serial2 31861 17 0 11 414 83 4 204 11 7 283 21 11 0 39 sys1 12124 19 0 9 340 7 \n9 340 12 3 144 2 13 0 19 sys2 8593 13 0 5 206 0 5 205 10 0 9 0 9 0 6 flpydisk 6747 37 0 0 59 317 0 47 \n32 0 43 240 32 0 43 pscr2 5799 21 0 6 264 57 2 124 21 0 27 47 17 0 24 pscr1 5480 25 0 3 154 57 2 133 \n16 0 57 40 22 0 26 modem 3432 15 0 5 208 35 0 55 1 4 178 45 1 0 15 1394vdev 2746 15 0 2 129 140 2 126 \n8 1 101 10 7 0 26 1394diag 2745 19 0 3 158 23 3 156 7 2 131 10 9 1 115 featured2 2512 21 0 3 202 54 2 \n158 32 0 52 2 28 0 20 featured2a 2465 16 0 3 167 30 3 156 20 0 49 2 24 0 14 func fail 2131 24 0 4 184 \n34 4 186 21 2 120 5 19 0 19 featured1 1880 16 0 3 149 36 3 146 17 1 79 3 19 0 8 featured1a 1838 19 0 \n5 217 30 2 130 25 3 145 2 25 0 27 Table 2. Empirical evaluation of SMASH on 16 device drivers. Figure \n12. Average summary population for SMASH. ing an existing summary results in a new summary), this data \npoints to reduced number of queries in SMASH, indicating that a combi\u00adnation of may and must analyses \ncan drastically reduce the number of queries in the analysis. Interplay between not-may and must summaries. \nFinally, to quantify the interplay between not-may and must summaries in SMASH, we examine the average \nsummary population for top-level queries/checks (those that result in proofs or bugs) for all the 16 \ndrivers in Table 2. This data is presented in Figure 12 the .rst column in this .gure represents the \naverage number of not-may summaries and must summaries used to answer queries that re\u00adsulted in a no \nanswer (a proof/not-may answer), while the sec\u00adond column represents the average number of not-may summaries \nand must summaries used to answer queries that resulted in a yes (a bug/must answer). On an average, \nto generate a proof, 68% of summaries used were not-may summaries and 32% of the sum\u00admaries used were \nmust summaries. On an average, to identify a bug, 64% of summaries used were must summaries and 36% of \nthe sum\u00admaries used were not-may summaries. Indeed, it is this .ne-grained coupling and alternation of \nnot-may and must summary applica\u00adtions that allows SMASH to easily navigate through code fragments that \nare typically hard to analyze using COMPOSITIONAL-MAY-DASH, COMPOSITIONAL-MUST-DASH and DASH. The experiments \nreported here were performed in an experi\u00admental setup similar to the one used in [5]: (1) environment \nmod\u00adels/code are used to simulate the effects of the operating system visible to the device drivers considered, \nand (2) concrete execu\u00adtions of the drivers (and of the environment code) are simulated by an interpreter. \nNote that assumption (1) is an inherent limita\u00adtion to all may static program analysis: the impact of \nthe exter\u00adnal environment must be modeled abstractly somehow. In contrast, testing-based approaches [16] \ncan simply run the actual environ\u00adment code (assuming it is available) as a blackbox, although this typically \nmakes the analysis incomplete, i.e., the analysis may miss bugs. Because of assumption (2), the level \nof precision when com\u00adputing preconditions Pre and postconditions Post in the rules of Figure 7 is always \nthe same, and one of the two rules MUST-POST or NOTMAY-PRE is always guaranteed to be applicable. 6. \nRelated Work As mentioned earlier, the SMASH algorithm generalizes and ex\u00adtends several existing algorithms.2 \nSLAM [4] performs a composi\u00adtional may analysis using predicate abstraction and partition re.ne\u00adment, \nbut does not perform a must analysis. SMART [14] performs a compositional must analysis, extending the \nnon-compositional must analysis of DART [16], but does not perform a may analy\u00adsis. SYNERGY [19] combines \nSLAM and DART for intraprocedu\u00adral analysis only. DASH [5] performs an interprocedural may-must analysis, \nextending the intraprocedural SYNERGY algorithm [19], but is non-compositional, i.e., it does not memoize \n(cache) interme\u00addiate results in the form of reusable summaries. Also, the formal\u00adization of the DASH \nalgorithm in [5] does not account for impreci\u00adsion in symbolic execution and constraint solving while \ncomputing preconditions Pre or postconditions Post. To the best of our knowledge, SMASH is the .rst 3-valued \ncom\u00adpositional may-must analysis algorithm. Its key novel feature is its .ned-grained coupling between \nmay and must summaries, which allows using either type of summaries in a .exible and demand\u00addriven manner. \nAs shown in the experiments of the previous sec\u00adtion, this alternation is the key feature that allows \nSMASH to out\u00adperform previous algorithms. Several other algorithms and tools combine static and dy\u00adnamic \nprogram analyses for property checking and test generation, e.g., [6, 10, 28, 32]. Most of these looser \ncombinations perform a static analysis before a dynamic analysis, while some [6] al\u00adlow for some feedback \nto .ow between both. But none support 2The name SMASH is a combination of the names SMART and DASH. \n.ne-grained alternation between the may/static and must/dynamic parts, and most are not compositional. \nCompositional may program analysis has been amply discussed in the literature [25], and has recently \nbeen extended to the must case [1, 14]. Our work combines both compositional may and com\u00adpositional must \nanalyses in a tight uni.ed framework and shows how to leverage their complementarity. Three-valued may-must \nprogram analysis using predicate ab\u00adstraction has been proposed before [15, 21]. However, this earlier \nwork used the same abstract states (sets of predicates) to de.ne both may and must abstractions, and \nwas not compositional ( [22] does handle recursive programs but only a restricted class of prop\u00aderties). \nIn contrast, SMASH is compositional and uses two different abstract domains for its may and must analyses \n(as in SYNERGY and DASH): may abstract states are de.ned using predicate abstrac\u00adtion and are iteratively \nre.ned by adding new predicates to split ab\u00adstract regions; while must abstract states are de.ned using \nsymbolic execution along program paths executed with concrete tests and are incrementally computed with \nmore tests but without re.ning must abstract states. Program analysis using three-valued shape graphs \nas abstract states has also been proposed for shape analysis [30]. There, ab\u00adstract states are richer \nthree-valued structures, while transitions be\u00adtween those states are traditional two-valued may transitions. \nIn the context of veri.cation-condition-generation-style pro\u00adgram veri.cation, [13] discusses how to \nover-approximate and under-approximate recursive logic formulas representing whole programs and generated \nby a static program analysis for a .xed set of predicates. In contrast, our approach builds up a logical \npro\u00adgram representation incrementally, by re.ning simultaneously dual may over-approximate and must under-approximate \ncompositional program abstractions de.ned by varying sets of predicates. More\u00adover, unlike [13], we do \nnot suffer from false positives since our must analysis is grounded in concrete executions through program \ntesting. In this work, we focus on checking safety properties, which can be reduced to evaluating reachability \nqueries, and arguably repre\u00adsent most properties one wants to check in practice. It is well known that \nmay-must abstractions can also be used to check more expres\u00adsive properties, such as liveness and termination \nproperties, as well as properties represented by \u00b5-calculus formulas with arbitrary al\u00adternation of universal \nand existential path quanti.ers [15]. How\u00adever, in order to check liveness properties with .nite-state \nabstrac\u00adtions, more elaborate abstraction techniques, such as the generation of fairness constraints, \nare in general necessary [26, 31]. We assume in this paper that all concrete program executions terminate. \nIn practice, this assumption can easily be checked for speci.c executions at run-time using timers. In \nother words, we as\u00adsume and check for termination using the must part of our program analysis, but we \ndo not attempt to prove that all program executions always terminate using the may part [9], nor do we \ntry to .nd some non-terminating execution [20]. It would be interesting to combine techniques for proving \ntermination [9] and non-termination [20] with compositional may-must program analysis. SMASH .ts in the \ncategory of property-guided algorithms and tools: each experiment reported in the previous section is \naimed at either proving or disproving that a program (device driver) satis.es a speci.c property (assertion) \nof interest. In contrast, the approach taken in [8, 16, 18] is aimed at exercising as many program paths \nas possible while checking many properties simultaneously along each of those paths [17]. 7. Conclusions \nWe have presented a uni.ed framework for compositional may\u00admust program analysis and a speci.c algorithm, \nSMASH, instan\u00adtiating this framework. We have implemented SMASH using predi\u00adcate abstraction for the \nmay part and using dynamic test generation for the must part. Results of experiments with 69 Microsoft \nWin\u00addows 7 device drivers show that SMASH can signi.cantly outper\u00adform may-only, must-only and non-compositional \nmay-must algo\u00adrithms. The key technical novelty of SMASH is the tight integration of may and must analyses \nusing interchangeable not-may/must summaries. Although the general idea of combining compositional may \nand must analyses is natural, the outcome of the experimental evaluation was surprising as SMASH performed \nmuch better than adding compositionality separately to may and must analyses. This led us to uncover \nthe previously-unnoticed power of alternation of may and must summaries in the context of compositional \nprogram analysis. We have also been able to quantify the amount of interplay that happens between may \nand must summaries in our benchmarks. SMASH is implemented in YOGI [29] which is one of the tools in \nthe Static Driver Veri.er (SDV) toolkit for analyzing Windows device drivers and will eventually be shipped \nwith Windows. Acknowledgments We thank William Harris, Tony Hoare, Akash Lal, Andrew Santosa, Robert \nSimmons and the anonymous reviewers for their insightful comments on earlier drafts of this paper. References \n[1] S. Anand, P. Godefroid, and N. Tillmann. Demand-driven composi\u00adtional symbolic execution. In TACAS \n08: Tools and Algorithms for the Construction and Analysis of Systems, pages 367 381, 2008. [2] T. Ball, \nO. Kupferman, and G. Yorsh. Abstraction for falsi.cation. In CAV 05: Computer-Aided Veri.cation, 2005. \n[3] T. Ball and S. K. Rajamani. Bebop: A symbolic model checker for boolean programs. In SPIN 00: International \nSPIN Workshop, pages 113 130, 2000. [4] T. Ball and S. K. Rajamani. Automatically validating temporal \nsafety properties of interfaces. In SPIN 01: SPIN workshop on Model checking of Software, pages 103 122, \n2001. [5] N. E. Beckman, A. V. Nori, S. K. Rajamani, and R. J. Simmons. Proofs from tests. In ISSTA 08: \nInternational Symposium on Software Testing and Analysis, pages 3 14, 2008. [6] D. Beyer, T. A. Henzinger, \nand G. Theoduloz. Program analysis with dynamic precision adjustment. In ASE 08: Automated Software Engineering, \n2008. [7] W.R. Bush, J.D. Pincus, and D.J. Sielaff. A static analyzer for .nding dynamic programming \nerrors. Software Practice and Experience, 30(7):775 802, 2000. [8] C. Cadar, V. Ganesh, P. M. Pawlowski, \nD. L. Dill, and D. R. Engler. EXE: Automatically generating inputs of death. In CCS 06: Com\u00adputer and \nCommunications Security Conference, 2006. [9] B. Cook, A. Podelski, and A. Rybalchenko. Termination proofs \nfor systems code. In PLDI 06: Programming Language Design and Implementation, 2006. [10] C. Csallner \nand Y. Smaragdakis. Check n Crash: Combining static checking and testing. In ICSE 05: International Conference \non Software Engineering, 2005. [11] M. Das, S. Lerner, and M. Seigle. ESP: Path-sensitive program veri.cation \nin polynomial time. In PLDI 02: Programming Language Design and Implementation, pages 57 69, 2002. [12] \nL. de Moura and N. Bjorner. Z3: An Ef.cient SMT Solver. In TACAS 08: Tools and Algorithms for the Construction \nand Analysis of Systems, 2008. [13] I. Dillig, T. Dillig, and A. Aiken. Sound, complete and scalable \npath\u00adsensitive analysis. In PLDI 08: Programming Language Design and Implementation, pages 270 280, 2008. \n [14] P. Godefroid. Compositional dynamic test generation. In POPL 07: Principles of Programming Languages, \npages 47 54, 2007. [15] P. Godefroid, M. Huth, and R. Jagadeesan. Abstraction-based model checking using \nmodal transition systems. In CONCUR 01: Interna\u00adtional Conference on Concurrency Theory, pages 426 440, \n2001. [16] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed Automated Random Testing. In PLDI 05: \nProgramming Language Design and Implementation, pages 213 223, 2005. [17] P. Godefroid, M.Y. Levin, and \nD. Molnar. Active property checking. In EMSOFT 08: Annual Conference on Embedded Software, pages 207 \n216, 2008. [18] P. Godefroid, M.Y. Levin, and D. Molnar. Automated whitebox fuzz testing. In NDSS 08: \nNetwork and Distributed Systems Security, pages 151 166, 2008. [19] B. S. Gulavani, T. A. Henzinger, \nY. Kannan, A. V. Nori, and S. K. Rajamani. SYNERGY: A new algorithm for property checking. In FSE 06: \nFoundations of Software Engineering, pages 117 127, 2006. [20] A. K. Gupta, T. A. Henzinger, R. Majumdar, \nA. Rybalchenko, and R-G. Xu. Proving non-termination. In POPL 08: Principles of Programming Languages, \npages 147 158, 2008. [21] A. Gur.nkel, O. Wei, and M. Chechik. Yasm: A software model checker for veri.cation \nand refutation. In CAV 06: Computer-Aided Veri.cation, pages 170 174, 2006. [22] A. Gur.nkel, O. Wei, \nand M. Chechik. Model checking recursive programs with exact predicate abstraction. In ATVA 08: Automated \nTechnology for Veri.cation and Analysis, pages 95 110, 2008. [23] S. Hallem, B. Chelf, Y. Xie, and D. \nEngler. A system and language for building system-speci.c static analyses. In PLDI 02: Programming Language \nDesign and Implementation, pages 69 82, 2002. [24] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. \nLazy abstrac\u00adtion. In POPL 02: Principles of Programming Languages, pages 58 70, 2002. [25] S. Horwitz, \nT. Reps, and M. Sagiv. Demand interprocedural data.ow analysis. In FSE 95: Foundations of Software Engineering, \npages 104 115, 1995. [26] Y. Kesten and A. Pnueli. Veri.cation by augmented .nitary abstrac\u00adtion. Information \nand Computation, 163(1), 2000. [27] K. L. McMillan. Interpolation and SAT-based model checking. In CAV \n03: Computer-Aid Veri.cation, pages 1 13, 2003. [28] G. C. Necula, S. McPeak, and W. Weimer. CCured: \nType-safe retro.tting of legacy code. In POPL 02: Principles of Programming Languages, pages 128 139, \n2002. [29] A. V. Nori, S. K Rajamani, S. Tetali, and A. V. Thakur. The Yogi Project: Software property \nchecking via static analysis and testing. In TACAS 09: Tools and Algorithms for the Construction and \nAnalysis of Systems, pages 178 181, 2009. [30] M. Sagiv, T. Reps, and R. Wilhelm. Parametric shape analysis \nvia 3\u00advalued logic. In POPL 99: Principles of Programming Languages, pages 105 118, 1999. [31] T. Uribe. \nAbstraction-based Deductive-Algorithmic Veri.cation of Reactive Systems. PhD thesis, Stanford University, \n1999. [32] W. Visser, C. Pasareanu, and S. Khurshid. Test input generation with java path.nder. In ISSTA \n04: International Symposium on Software Testing and Analysis, 2004.   \n\t\t\t", "proc_id": "1706299", "abstract": "<p>Program analysis tools typically compute two types of information: (1) <i>may </i> information that is true of <i>all </i> program executions and is used to prove the absence of bugs in the program, and (2) <i>must </i> information that is true of <i>some </i> program executions and is used to prove the existence of bugs in the program. In this paper, we propose a new algorithm, dubbed SMASH, which computes both may and must information <i>compositionally </i>. At each procedure boundary, may and must information is represented and stored as may and must summaries, respectively. Those summaries are computed in a demand driven manner and possibly using summaries of the opposite type. We have implemented SMASH using predicate abstraction (as in SLAM) for the may part and using dynamic test generation (as in DART) for the must part. Results of experiments with 69 Microsoft Windows 7 device drivers show that SMASH can significantly outperform may-only, must-only and non-compositional may-must algorithms. Indeed, our empirical results indicate that most complex code fragments in large programs are actually often either easy to prove irrelevant to the specific property of interest using may analysis <i>or </i> easy to traverse using directed testing. The fine-grained coupling and <i>alternation </i> of may (universal) and must (existential) summaries allows SMASH to easily navigate through these code fragments while traditional may-only, must-only or non-compositional may-must algorithms are stuck in their specific analyses.</p>", "authors": [{"name": "Patrice Godefroid", "author_profile_id": "81100504535", "affiliation": "Microsoft Research, Redmond, USA", "person_id": "P1911035", "email_address": "", "orcid_id": ""}, {"name": "Aditya V. Nori", "author_profile_id": "81320493380", "affiliation": "Microsoft Research, Bangalore, India", "person_id": "P1911036", "email_address": "", "orcid_id": ""}, {"name": "Sriram K. Rajamani", "author_profile_id": "81100468626", "affiliation": "Microsoft Research, Bangalore, India", "person_id": "P1911037", "email_address": "", "orcid_id": ""}, {"name": "Sai Deep Tetali", "author_profile_id": "81453646997", "affiliation": "University of California, Los Angeles, Los Angeles, USA", "person_id": "P1911038", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706307", "year": "2010", "article_id": "1706307", "conference": "POPL", "title": "Compositional may-must program analysis: unleashing the power of alternation", "url": "http://dl.acm.org/citation.cfm?id=1706307"}