{"article_publication_date": "01-17-2010", "fulltext": "\n Modular Session Types for Distributed Object-Oriented Programming Simon J. Gay Vasco T. Vasconcelos \nAnt\u00b4onio Ravara * Department of Computing Science Department of Informatics CITI and Department of Informatics, \nUniversity of Glasgow, UK University of Lisbon, Portugal FCT, New University of Lisbon, Portugal simon@dcs.gla.ac.uk \nvv@di.fc.ul.pt aravara@fct.unl.pt Nils Gesbert Department of Computing Science University of Glasgow, \nUK nils@dcs.gla.ac.uk Abstract Session types allow communication protocols to be speci.ed type\u00adtheoretically \nso that protocol implementations can be veri.ed by static type-checking. We extend previous work on session \ntypes for distributed object-oriented languages in three ways. (1) We at\u00adtach a session type to a class \nde.nition, to specify the possible se\u00adquences of method calls. (2) We allow a session type (protocol) \nimplementation to be modularized, i.e. partitioned into separately\u00adcallable methods. (3) We treat session-typed \ncommunication chan\u00adnels as objects, integrating their session types with the session types of classes. \nThe result is an elegant uni.cation of communication channels and their session types, distributed object-oriented \npro\u00adgramming, and a form of typestates supporting non-uniform ob\u00adjects, i.e. objects that dynamically \nchange the set of available meth\u00adods. We de.ne syntax, operational semantics, a sound type sys\u00adtem, and \na correct and complete type checking algorithm for a small distributed class-based object-oriented language. \nStatic typ\u00ading guarantees that both sequences of messages on channels, and sequences of method calls \non objects, conform to type-theoretic speci.cations, thus ensuring type-safety. The language includes \nex\u00adpected features of session types, such as delegation, and expected features of object-oriented programming, \nsuch as encapsulation of local state. We also describe a prototype implementation as an ex\u00adtension of \nJava. * Work developed while the author was at SQIG, Instituto de Telecomunicac\u00b8oes, and Department of \nMathematics, IST, Technical Uni\u00ad versity of Lisbon. Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 10, January 17 23, 2010, Madrid, Spain. Copyright &#38;#169; \n2010 ACM 978-1-60558-479-9/10/01. . . $10.00 c Alexandre Z. Caldeira Department of Informatics University \nof Lisbon, Portugal zua@di.fc.ul.pt Categories and Subject Descriptors D.3.3 [Language Constructs and \nFeatures]: Classes and objects; D.3.2 [Language Classi.ca\u00adtions]: Object-oriented languages; D.3.1 [Formal \nDe.nitions and Theory]; F.3.2 [Semantics of Programming Languages]: Oper\u00adational semantics; F.3.3 [Studies \nof Program Constructs]: Type structure; D.1.5 [Object-oriented Programming] General Terms Languages, \nTheory, Veri.cation Keywords Session types, object-oriented calculus, non-uniform method availability, \ntypestates 1. Introduction Session types [29, 49] allow communication protocols to be speci\u00ad.ed type-theoretically \nso that protocol implementations can be ver\u00adi.ed by static type-checking. A session type describes a \ncommu\u00adnication channel, and de.nes the permitted sequences and types of messages. For example, the session \ntype S = ! [Int] . ?[Bool] .end speci.es that an integer must be sent and then a boolean must be received, \nand there is no further communication. More generally, branching and repetition can be speci.ed. Session \ntypes were originally formulated for languages closely based on process calculus. Since then, the idea \nhas been applied to functional languages [25, 26, 39, 44, 51], component-based object systems [50], object-oriented \nlanguages [10, 17 19, 31, 38], operating system services [22] and more general service-oriented systems \n[11]. Session types have also been generalized from two\u00adparty to multi-party systems [8, 30], although \nin the present paper we will only consider the two-party case. We propose a new approach to combining \nsession-typed com\u00admunication channels and distributed object-oriented programming, which extends previous \nwork and allows increased programming .exibility. The key idea is to allow a channel (e.g., of type S \nabove) to be stored in a .eld of an object, and for separate methods to im\u00adplement parts of the session. \nFor example, method m can send the integer and method n can receive the boolean. Because the session \ntype of the channel requires that the send occurs .rst, it follows that m must be called before n. We \nneed therefore to work with non-uniform objects, in which the availability of methods depends on the \nstate of the object. In order to develop a static type system for object-oriented programming with session-typed \nchannels, we use a form of typestates (a type safe state abstraction, according to [14, 21]) that we \nhave previously introduced under the name of dynamic interfaces [52]. In this type system, the availability \nof a class s methods (i.e., the possible sequences of method calls) is speci.ed in a style that itself \nresembles a form of session type, giv\u00ading a pleasing commonality of notation at both the channel and \nclass levels. The result of this combination of ideas is a language that al\u00adlows a very natural integration \nof programming with session-based channels and with non-uniform objects. In particular, the imple\u00admentation \nof a session can be modularized by dividing it into separate methods that can be called in turn. In contrast, \nprevious work on object-oriented session types, although allowing a ses\u00adsion to be delegated to another \nmethod, does not allow separation into separately-callable blocks of code. Thus, our approach leads to \na more .exible programming style than the other approaches mentioned above. Our formal language provides \nchannels as disci\u00adplined streams, because session types are a high-level abstraction for structuring \ncommunication, and integrates this communication\u00adbased construct, without further restrictions, with \nthe high-level object-oriented abstractions for structuring computation. We have formalized a core distributed \nclass-based object\u00adoriented language with a static type system that combines session\u00adtyped channels and \na form of typestates. We have proved that static typing guarantees two runtime safety properties: .rst, \nthat the se\u00adquence of method calls on every non-uniform object follows the speci.cation of its class \ns session type; second, as a consequence (because channel operations are implemented as method calls) \nthat the sequence of messages on every channel follows the speci.ca\u00adtion of its session type. We have \nalso formalized a typechecking algorithm and proved its correctness, and implemented a prototype language \nas an extension of Java. There is a substantial literature of related work, which we dis\u00adcuss in detail \nin Section 8. Very brie.y, the contributions of our paper are the following. In contrast to other work \non session types for object-oriented languages, we do not require a channel to be created and com\u00adpletely \nused (or delegated) within a single method. Several methods can operate on the same channel, thus allowing \neffec\u00adtive encapsulation of channels in objects, while retaining the usual object-oriented development \npractice. This is made pos\u00adsible by our integration of channels and non-uniform objects. This contribution \nwas the main motivation for our work.  In contrast to other typestate systems, we use a global speci.ca\u00adtion \nof method availability, inspired by session types, made part of a class de.nition. While typestates are \nintensional, directly related to the object s state, we de.ne these states with types, making use of \nstandard type-theoretic tools to ensure client\u00adconformance.  The remainder of the paper is structured \nas follows. In Section 2 we illustrate our system by introducing an example. In Section 3 we formalize \na core sequential language; in Section 4 we extend it to a distributed language and in Section 5 we state \nthe key properties of the type system. In Section 6 we present a typechecking algorithm and state results \nabout its correctness. Section 7 describes our prototype implementation. Section 8 contains a more extensive \ndiscussion of related work; Section 9 outlines future work and concludes. 2. Example: Buyer/Seller To \nillustrate the features of the formal language and of the type system, we incrementally present an example. \n The Buyer/Seller Protocol. Our example is based on an e\u00adcommerce protocol between a buyer and a seller. \nThe two parties interact on a point-to-point communication channel, each owning one endpoint. The buyer \ns protocol is speci.ed by the session type B = .{reqQuote : ! [Product] . ?[Price] . ?[Quote] . B, accQuote \n: ! [Quote] . ! [Payment] . B, quit : end} The buyer has a choice between reqQuote, accQuote and quit. \nIf she chooses reqQuote she must send information about the desired product, and then receive the price \nand a reference number for the quote. After this, the session type is again B, and the buyer can choose \nanother option. When she wants to buy a product, the buyer can select accQuote and then send a quote \nreference followed by payment information. It is therefore only possible to buy an item after a quote \nhas been obtained, although this is not speci.ed explicitly as part of the type. Selecting quit at any \ntime, instead of accQuote or reqQuote, terminates the protocol. The seller s protocol is speci.ed by \nthe dual session type S =&#38;{reqQuote : ?[Product] . ! [Price] . ! [Quote] . S, accQuote : ?[Quote] \n. ?[Payment] . S, quit : end} in which send (!) and receive (?) are exchanged, and the choice constructor \n(.) is replaced by the branch constructor (&#38;). This means that the seller must be ready to respond \nto all of the three choices that the buyer can make. We express the relationship of duality between S \nand B by S = B, or equivalently B = S as the duality operation is self-inverse. The goal of a static \ntype system with session types is to be able to verify, by type-checking, that the implementations of \nthe buyer and the seller follow the speci.ed protocol. An API for the Buyer. We work within a model of \ndistributed computing in which there are a number of sites, each executing an independent program. Services \nare accessed via typed access points n, analogous to URLs. The type (S) describes an access point for \na service whose type (protocol) is S. A point-to-point bidirectional communication channel is created \nby the interaction of operations n.request() and n.accept() executed at separate sites. If n has type \n(S) then n.accept() yields one endpoint of the channel, with type S, and n.request() yields the other \nendpoint, with type S. Given a channel c, synchronous communication occurs through the interaction of \nc.send and c.receive operations. An access point such as n must be announced at the top level at every \nsite that uses it, and all such occurrences must share the same type. For simplicity, we do not allow \naccess points to be created dynamically. It is very natural to implement an API for buyers, by de.ning \nthe class BuyerAPI in Figure 1. A program that needs to act as a buyer for example, driven by a GUI \napplication can create an instance of class BuyerAPI and call methods on it, instead of working directly \nwith the primitive operations request, send and receive. This approach has several advantages. The class \nabstracts from the details of the protocol, for example the exact order of messages. It also hides the \nQuote information by storing it in a data structure indexed by Product. As we will see, it can form the \nbasis for an inheritance hierarchy of classes that offer more services, although we do not formalize \ninheritance in the present paper. The code in Figure 1 consists of four declarations. Lines 1 and 3 de.ne \nenumerated types Option and Result. Lines 5 8 de.ne the session type S of the channel protocol; we have \nchosen the seller s viewpoint. Lines 10 43 de.ne the class BuyerAPI. Because the .eld c will store a \nchannel of type S the class BuyerAPI is non-uniform. We specify the availability of methods by the ses\u00adsion \ndeclaration in lines 11 17. We refer to this as a class ses\u00adsion type to distinguish it from channel \nsession types such as S. 1 enum Option { reqQuote , accQuote , quit } 2 3 enum Result {ok , error } \n4 5 typedef S= 6 &#38;{Option.reqQuote:?[Product].![ Price ].![Quote].S 7 Option . accQuote :?[ Quote \n].?[ Payment ].S, 8 Option . quit : end} 9 10 class BuyerAPI { 11 session Init 12 where Init = { init \n: Shop } 13 Shop = { price : Shop , 14 buy : ( Result.ok: Pay, 15 Result . error : Shop ) , 16 stop : \nend } 17 Pay = { pay : Shop } 18 19 c; qs; // fields , initially null:Null 20 21 void init( ( S ) u) \n{ 22 c =u. request (); 23 qs = new QuoteStore(); qs.init(); 24 } 25 Price price(Product p) { 26 c. send \n(Option . reqQuote ); 27 c. send (p); 28 Price pr = c. receive (); 29 Quote q=c. receive (); 30 qs .add(p,q); \n31 return pr ; 32 } 33 Result buy(Product p) { 34 Quote q = qs.get(p); 35 if (q == null ) 36 return Result \n. error ; 37 else { 38 c. send (Option . accQuote ); 39 c. send (q); 40 return Result .ok; 41 } 42 void \npay(Payment p) { c. send (p); } 43 void stop () { c. send (Option . quit ); } 44 } Figure 1. An API \nfor the buyer. An object of class BuyerAPI has abstract states Init , Shop, Pay and end. The type constructor \n{...} speci.es the available methods and the abstract states that result when they are called. The type \nof an instance of class BuyerAPI is BuyerAPI[Init ], BuyerAPI[Shop], BuyerAPI[Pay] or BuyerAPI[end]. \nThe state end is a standard ab\u00adbreviation for a state without available methods. Our approach to specifying \nmethod availability is similar to other systems of types\u00adtates for object-oriented languages [16, 21], \nexcept that we collect the whole speci.cation into the class session type instead of anno\u00adtating the \nmethod de.nitions with pre-and post-conditions. In our system, annotations are required only for recursive \nmethods; we discuss this point at the end of Section 3. Another distinctive feature of our language is \nthat the abstract state after a method call may depend on the return value of the method, if it is of \nan enumerated type. This is illustrated on lines 14 15, where (...) is a variant type indexed by values \nof type Result. A caller of buy must switch on the result in order to discover the state and hence the \navailable methods; this is enforced by the type system. In this example, method buy returns error if \na price has not yet been obtained for the speci.ed product. It is not possible to 1 // sellerURL is \nof type ( S ) 2 // with S defined in Figure 1 3 b= new BuyerAPI (); 4 b. init(sellerURL ); 5 // Wait \nuntil price is right 6 while (b. price(myProduct) > 100) {} ; 7 8 switch (b . buy(myProduct )) { 9 case \nerror : 10 print( Something went wrong ); break ; 11 case ok: b.pay(myPayment); break ; 12 }13 b. stop \n(); Figure 2. A buyer code fragment. use the session type to specify that price must be called before \nbuy, because the product description is arbitrary data. Method init has a parameter u whose type (S) \nindicates that it represents an access point for a service of type S. The use of the notation (...) for \nboth variant types and access point types should not cause confusion as they occur in different contexts. \nWhen init is called, the actual parameter will be a speci.c access point that has been announced as such \nwith type (S). The method uses u.request() to create a channel. It also creates and initializes a QuoteStore \nobject, which we assume allows construction of a mapping between products and quotes, in a similar way \nto a Java HashMap. Although our language does not include constructors as a special category, the session \ntype of BuyerAPI speci.es that init must be called .rst, so we can regard it as the initialization part \nof a constructor. Likewise, we assume that after the call to QuoteStore. init (), the object stored in \nqs is in some state Q in which all other QuoteStore methods are available. Methods price , buy and pay \nimplement parts of the buyer s protocol. De.ning these operations as separate methods is the key innovation \nof our approach. This is what we mean by modularity of sessions. Other work on object-oriented session \ntypes does not allow this. There is a consistency requirement between the channel session type S, the \nclass session type Init , and the de.nitions of the meth\u00adods. Consistency is checked by the type system \ndescribed in Sec\u00adtion 3 and by the type-checking algorithm described in Section 6. If we take a sequence \nof method calls allowed by the class session type, and look at the channel operations in the methods \nto obtain a sequence of channel operations, then this must be allowed by the channel session type S. \nIn order to support modular type-checking we require only the session type of a class, not the types \nof its .elds. For example, in order to type-check classes that are clients of BuyerAPI, we do not need \nto know that BuyerAPI contains a channel with a session type; the class session type of BuyerAPI contains \nall of the necessary information about the allowed sequences of method calls. It is therefore possible \nto associate session types with library classes containing native methods whose source code cannot be \navailable. Type safety with non-uniform objects requires tight control of aliasing. When the type of \nan object changes, by calling a method on it or by analysing an enumeration constant returned from a \nmethod call, there must be a unique reference to it. Since we are mainly interested in exploring the \nkey idea of modularizing session implementations by integrating session-typed channels and non\u00aduniform \nobjects, we have adopted a simple approach to ownership control: a linear type system. We expect to be \nable to ease this restrictive system by using an off-the-shelf solution to aliasing control, such as \none of the approaches discussed in Section 8. 1 access ( S ) sellerURL ; // S defined in Figure 1 1 \nenum NewResult restricts Result {ok} 22 3 class Seller { 3 class NewBuyerAPI extends BuyerAPI { 4 session \n{ main : end } 4 @Override 55 NewResult buy(Product p) { 6 void main () { 6 if (!qs.contains(p)) price(p); \n7 while ( true ) 7 c. send (Option . acceptQuote ); 8 spawn SellerThread . run(sellerURL . accept ()); \n8 c. send (qs . get(p)); 9 }} 9 return NewResult . ok ; 10 10 }} 11 class SellerThread { 12 session \n{ run : end } Figure 4. An extended buyer API features a self call to a 13 public method. 14 void run(S \nx) { 15 switch (x. receive ()) { 16 case reqQuote: reqQuote(x); 17 case accQuote: accQuote(x); be called \nby any client of class SellerThread. Notice also that the 18 case quit : break three mutually recursive \nmethods in SellerThread each implement 19 }} a part of session type S. 20 void reqQuote(?[Product].![Price].![Quote].S \nx) We assume an external mechanism for checking that access 21 { Product p = x. receive (); points are \nannounced consistently at all sites. This could be a 22 x. send (...); // Calculate price 23 x. send \n(...); // Quote reference trusted central repository of typed services, or Hu s [31] system 24 run (x) \nof run-time type-checks when request and accept interact. 25 } The code in this example differs from \nthe formal language de\u00ad26 void accQuote(?[Quote].?[Payment].S x) { .ned in Sections 3 and 4 in two ways. \nFirst, the methods run, 27 Quote q=x. receive ( ) ; reqQuote and accQuote, being mutually recursive, \nshould be an\u00ad 28 Price py = x. receive (); notated with their effect on the types of the .elds of SellerThread. \n29 ... // Process payment Because SellerThread has no .elds, the annotations would be vac\u00ad 30 run (x) \nuous and so we have omitted them. Second, the parameter types of 31 }} reqQuote and accQuote should have \nthe form Chan[S ], where Chan is a special class name representing channels and S is a class ses-Figure \n3. A multi-threaded seller, featuring two private methods sion type derived from the channel session \ntype S. We have used and mutual recursion. the channel session type in the example code in order to make \nit more readable. Interacting with the Buyer API. Figure 2 shows a code fragment Inheritance and Subtyping. \nFor simplicity, the formal language that creates and uses an instance of class BuyerAPI. We assume de.ned \nin the present paper does not include inheritance; however, that the typed access point sellerURL corresponds \nto the published it does include a subtyping relation on session types, which pro\u00adaccess point of a particular \nseller that observes protocol S. In the vides a foundation for inheritance and is also used in other \nways. It remaining code, myProduct and myPayment represent, respectively, is straightforward to add inheritance, \nalong the following lines. A the name of a particular product and the details of a method of class C \ninherits from (extends) a class D in the usual way: C may payment. de.ne additional .elds and methods, \nand may override methods Figure 3 contains a schematic de.nition of a seller. The seller of D. By considering \nthe standard principle of safe substitutability, should run independently at some location, so class \nSeller de.nes a namely that an object of class C should be safely usable wherever main method and the \nclass session type speci.es that main is called an object of class D is expected, we can work out the \nappropriate once. The statement spawn SellerThread.run(sellerURL .accept()) subtyping relationship between \nthe session types of C and D. In a is repeatedly executed by the body of main. The semantics of this \ngiven state, C must make at least as many methods available as D; statement is as follows. The expression \nsellerURL .accept() creates if a given method returns an enumeration, corresponding to a vari\u00ada channel \nby interacting with a matching sellerURL.request() at an-ant session type, then the set of values in \nC must be a subset of the other site (it blocks until there is a matching sellerURL .request()), set \nin D. When a method of D is overridden by a method of C, we and evaluates to the endpoint c + so that \nwe have the statement allow contravariant changes in the parameter types and covariant spawn SellerThread.run(c+). \nAccording to our very simple concur-changes in the result type. Subtyping between session types is de\u00adrency \nmechanism, this creates a new heap containing an instance .ned in Section 3, but without subtyping on \nvariant types, which is of SellerThread on which run(c+) is called, forming an indepen-not needed in \nthe present paper. dently executing expression. As will be explained in Section 4, for To support covariant \nchanges in the result type, we can add the simplicity our formal language has no concept of separate \nthreads restricts declaration for enumerated types. An example is shown within a single location; we \ntherefore have to think of spawn as cre-in Figure 4, where class NewBuyerAPI overrides method buy in \nsuch ating a new location. The run method uses mutual recursion to im-a way that, if the quote to the \nproduct is not in the quote store, the plement a loop that repeatedly receives and processes requests, \nun-method issues a price request .rst. Notice that method price is both til quit is selected. The effect \nis that main accepts a connection and public (appears in the session type for the class) and the recipient \nimmediately delegates the new channel endpoint to a new thread. of a self-call (unlike method SellerThread \n.reqQuote, which is not It would also be possible for main to execute part of the protocol public). Our \nlanguage distinguishes these two usages of the same before delegating the channel. method, by advancing \nthe session type of the class in the .rst case Notice that the methods reqQuote and accQuote of the class \nbut not in the second. Of course the self-call of price may change SellerThread are not in the session \ntype. Although our language the types of the .elds of NewBuyerAPI, but this is included in the does not \ninclude method quali.ers, the two methods can be re-effect of buy. Inheritance, in the sequential setting, \nis described in garded as private since the type system ensures that they cannot more detail in [52]. \n Class/Enum dec Types Method dec Values Paths D T M v r ::= ::= ::= ::= ::= class C {S; Mf; M } | enum \nE {Ml} Null | C[S] | E link r T m(T x) {e} null | l this Expressions Class session types e S ::= v | \nx | r.f.m(e) | e; e | new C() | switch (e) {l : el}l.E | r.f | r.f = e ::= {mi : Si}i.I | (l : Sl)l.E \n| X | \u00b5X.S Figure 5. Top level syntax. Types T ::= ... | C[F ] Field types F ::= {Ti fi}i.I |(l : Fl)l.E \n|. Values v ::= ... | o Paths r ::= o | r.f Expressions e ::= ... | return e from r Object records R \n::= C[{fi = vi}i.I ] Heaps h ::= e | h :: o = R States s ::= (h; e) Contexts E ::= [] |E; e | r.m(E) \n| return E from r | switch (E) {l : el}l.E | r.f = E Identi.er this is an instance of object identi.er \no. Figure 6. Extended syntax for the type system and semantics. 3. A Core Sequential Language We now \npresent a formal syntax, operational semantics, and type system for a core sequential language. The main \nsimpli.cation is that all objects are treated as non-uniform and handled linearly by the type system. \nIncorporating standard (non-uniform) objects is straightforward, but it complicates and obscures the \nformal de.\u00adnitions. Our prototype implementation (Section 7) includes them. Also, all methods have exactly \none parameter. In terms of expres\u00adsivity this is not signi.cant, as multiple parameters can be passed \nwithin an object, and a dummy parameter can be added if necessary. Anyway, it is easy to generalize the \nde.nitions, at the expense of slightly more complex notation. The calls request(), accept() and receive \n() should be regarded as abbreviations for request( null ) etc. Finally, the examples use void methods, \nwhich are not in the formal language but can easily be added. Syntax. We separate the syntax into the \nprogrammer s language (Figure 5) and the extensions required by the type system and op\u00aderational semantics \n(Figure 6). Identi.ers C, E, m, f and l are taken from disjoint countable sets representing names of \nclasses, enumerations, methods, .elds and labels respectively. Class, enu\u00admerated set and method declarations \nhave been illustrated by the examples. A class declaration does not declare types for .elds be\u00adcause \nthey can vary at run-time. When an object is created, its .elds are initialised to null. There are some \nrestrictions on the syntax of expressions. The programmer can only refer to .elds of the current object, \nthis; in other terms, all .elds are private. Method call is only available on a .eld speci.cation, not \nan arbitrary expression. The examples in Section 2 omit this as the pre.x to all .eld accesses, but they \ncan easily be inserted by the compiler. Types are separated into object types and non-object types. The \ntype of an object is C[S], where C is a class name and S is a class session type. The type C[S] is the \nview of an object from outside: the session type S shows which methods can be called, but the .elds are \nnot visible. The type Null has the single value null. The type E link r describes a label from the enumerated \nset E whose value will be used to resolve a variant type associated with object path r. For simplicity, \nthe core language does not allow other uses of labels, hence E is not by itself a type. Session types \nhave been discussed in relation to the example. We refer to {mi : Si}i.I as a branch type and to (l : \nSl)l.E as a variant type. Session type end abbreviates the empty branch type {}. In contrast to variant \ntypes in functional languages, val\u00adues are not tagged; instead the tag is stored in a value of type E \nlink r, where r refers to the variantly typed object. The core language does not include named session \ntypes, or typedef or the session and where clauses from the examples; we just work with recursive session \ntype expressions of the form \u00b5X.S, which are required to be contractive, i.e. containing no subexpression \nof the form \u00b5X1.\u00b7\u00b7\u00b7 \u00b5Xn.X1. We adopt the equi-recursive approach [43, Chapter 21] and regard \u00b5X.S and \nS{(\u00b5X.S)/X } as equivalent, us\u00ading them interchangeably in any mathematical context. It is worth noting \nthat the type system, which we will describe later, enforces the following restrictions: nested variants \nare not permitted and in a class declaration, the initial session type is always a branch. They re.ect \nthe fact that variant types are tied to the result of a method call. Figure 6 de.nes additional syntax \nneeded for the formal system, not available to the programmer. Identi.er o is taken from a set of object \nidenti.ers which includes this, the only identi.er allowed in the programmer s language. There is an \nalternative form of object type, C[F ], which has a .eld typing instead of a session type. It represents \nthe view of an object from within its own class and is used when typing method de.nitions. A .eld typing \nF can either be a record type associating one type to each .eld of the object or a variant .eld typing \n(l : Fl)l.E , indexed by the values of an enumerated set E, similar to a variant session type. Type . \nrepresents the uninhabited .eld typing which no object can have and can appear in variant types along \nwith records, representing an impossible case. Object records, heaps and states are used to de.ne the \nopera\u00adtional semantics. A heap h ties object identi.ers o to object records R. The identi.ers are values, \nwhich may occur in expressions. The operation h :: o = R represents adding a record for identi.er o to \nthe heap h and we consider it to be associative and commutative, that is, h is essentially an unordered \nset of bindings. Paths r, that occur in expressions to indicate where an object is, are extended to allow \na toplevel object identi.er followed by an arbitrary number of .eld speci.cations and serve to represent \na location in the heap. In the toplevel syntax, the only known location is this, the current object. \nWe use the following notation with respect to records, heaps and paths: DEFINITION 1 (Heap locations). \nIf R = C[{fi = vi}i.I ], we de.ne R.fi = vi (for all i) and R.class = C. For any value v and any j . \nI, we also de.ne R{fj . v} == viI}i.I ] where viI= vi for i j and C[{fi = I v = v. j  M o fresh C..elds \n= f (R-NEW) -. (h; new C()) -. (h :: o = C[fM= null]; o) h(r).f = v (R-ACCESS) (h; r.f) -. (h{r.f . null}; \nv) (R-ASSIGN) (h; r.f = v) -. (h{r.f . v}; null) m( x) {e}. h(r.f).class (h; r.f.m(v)) -. (h; return \ne{r.f/this}{v/x} from r.f) (R-CALL) (R-RETURN) (h; return v from r) -. (h; v) l0 . E (R-SWITCH) (h; switch \n(l0) {l : el}l.E ) -. (h; el0 ) (R-SEQ) (h; v; e) -. (h; e) (h; e) -. (hI; e I) (R-CONTEXT) (h; E[e]) \n-. (hI; E[e I]) Figure 7. Reduction rules for states. If h =(hI :: o = R), we de.ne h(o)= R, and for \nany .eld f of R, h{o.f . v} =(hI :: o = R{f . v}).  If r = r I.f and h(r I).f = o, then we also de.ne \nh(r)= h(o) and h{r.f I . v} = h{o.fI . v}.  In any other case, these operations are not de.ned. Note \nin particular that h(r) is not de.ned if r is a path that exists in h but does not point to an object \nidenti.er.  Finally, the return expression is used to represent an ongoing method call; a state consists \nof a heap and an expression; E are evaluation contexts in the style of Wright and Felleisen [53]. Programs. \nA program consists of a collection of class and enum declarations D. The semantic and typing rules we \nwill present next are implicitly parameterized by the set of these declarations. It is assumed that the \nwhole set is available at any point and that any class, enum or label is declared only once. We consider \nthat enum declarations de.ne sets of labels, and use the notation l . E accordingly. As opposed to labels, \nwe do not require the sets of method or .eld names to be disjoint from one class to another. We will \nuse the following notation: if class C {S; fM; MM} is one of the declarations, C.session means S and \nC..elds means fM, and M if Tm(T I x) {e}. M then C.m is e. Operational Semantics. Figure 7 de.nes an \noperational seman\u00adtics on states (h; e) consisting of a heap and an expression. All rules have the implicit \npremise that the expressions appearing in them must be de.ned, for example r.f only reduces if h(r) is \nan object record containing a .eld named f. An example of reduction, together with typing, will be presented \nat the end of the section in Figure 10. R-NEW creates a new object in the heap, with null .elds. R-ACCESS \nextracts the value of a .eld from an object in the heap. Linear control of objects requires that the \n.eld be nulli.ed. R-ASSIGN updates the value of a .eld. The value of the assignment, as an expression, \nis null; linearity means that it cannot be v as in Java. R-CALL wraps the method body, with the full \npath to the object instance substituted for this and the actual parameter substituted for the formal \none, in a return expression that is used for type preservation. R-RETURN then unwraps the resulting value. \nR-SWITCH is standard. R-SEQ discards the result of the .rst part of a sequential composition. R-CONTEXT \nis the usual rule for reduction in contexts. S<: SI .i . ITi <: Ti I C[S] <: C[SI] C[{Ti fi}i.I ] <: \nC[{Ti I fi}i.I ] (S-SESS,S-FIELD) Figure 8. De.nition of subtyping. Subtyping. The source of subtyping \nin our language is the sub\u00adsession relation, coinductively de.ned as follows: DEFINITION 2 (Sub-session). \n<: is the largest relation on class session types such that: If {mi : Si}i.I <: SI then SI = {mj : Sj \nI }j.J with J . I and .j . J, Sj <: Sj I .  If (l : Sl)l.E <: SI then SI = (l : Sl I)l.E with .l. Sl \n<: SlI .  Like the de.nition of subtyping for channel session types [24], the type that allows a choice \nto be made (the branch type here, the . type in [24]) has contravariant subtyping in the set of choices. \nFurther details, including the proof that subtyping is re.exive and transitive and an algorithm for checking \nsubtyping, can be adapted from [24]. Figure 8 de.nes subtyping between types of our language. There is \nno subtyping between classes; the sub-session relation induces subtyping between session-typed objects \n(S-SESS), and for .eld-typed objects, subtyping on the .elds propagates to the records (S-FIELD). Type \nSystem. The type system for the toplevel language is de.ned by the rules in Figure 9 and by De.nition \n4 below. They use typing environments of the form G= y1 : T1,...,yn : Tn where we use y to stand for \neither object identi.ers o or variables x. As for heaps, we consider environments an unordered set of \nbindings; in other words, the comma is associative and commutative. Similarly to heaps also, we use the \nfollowing notation to access arbitrary paths in an environment: DEFINITION 3 (Locations in environments). \n If G=GI ,y : T then we de.ne G(y)= T and G{y . T I} = GI ,y : T I  Inductively, if r = r I.fj , and \nif G(r I)= C[{Ti fi}i.I ] and j . I, then we de.ne G(r)= Tj and G{r . T I} =G{r I . C[{Ti I fi}i.I ]} \nwhere Ti I = Ti for i = j and T I = T I j .  In any other case, in particular if G(r I) is of the form \nC[S], these operations are not de.ned.  We also write G <:GI if for every y in dom(GI) we have y . \ndom(G) and G(y) <:GI(y). We say a type is simple if it is either a base (non-object) type or an object \nwith a branch session type. The typing judgement for expressions is G ce : T< GI. Here G and GI are the \ninitial and .nal type environments when typing e. GI may differ from G either because identi.ers disappear \n(due to linearity) or because their types change (if they are non-uniform objects). These judgements \nare constructed by rules T-LINVAR to T-SUBENV; we comment on them later but .rst explain how a session \ntype can be checked against a class. We use the following coinductive de.nition to relate the views of \nan object from inside (.elds) and from outside (session): DEFINITION 4. For any class C, we de.ne the \nrelation F f C : S between .eld typings F and session types S as the largest relation such that F f C \n: S implies either F = . or: If S = {mi : Si}i.I , then for all i in I there is a de.nition Ti mi(Ti \nI xi) {ei} in the declaration of class C such that we  T = C[] G ce : T< GI GI(r.f) is simple (T-LINVAR) \nG,x : C[S] cx : C[S] < G (T-VAR) (T-ASSIGN)G,x : T cx : T< G,x : T G c r.f = e : Null < GI{r.f . T } \nG ce : T I < GI GI(r)= C[{mi : Si}i.I ] j . I Tmj (T I x) {}. C (T-CALL) (T-NULL) G c null : Null < G \nG c r.mj (e): T {r/this} < GI{r . C[Sj ]} G(r)= C[Fl0 ] l0 . E no Fl contains a variant(T-NEW) G c new \nC() : C[C.session] < G (T-INJF) G cl0 : E link r< G{r . C[(l : Fl)l.E ]} GII I G(r.f)= TT is simple \nG ce : T< GII ce : T I < GI T = E link r (T-ACCESS) (T-SEQ) I G c r.f : T< G{r.f . Null} G ce; e : T \nI < GI G ce : E link r< GII GII(r)= C[(l : Sl)l.E ] .l . E, GII{r . C[Sl]} cel : T< GI (T-SWITCH) G \nc switch (e) {l : el}l.E : T< GI - . G ce : T< GI T<: T I G ce : T< GI GI <:GII Null fMf C : S (T-SUB) \n(T-SUBENV) (T-CLASS) G ce : T I < GI G ce : T< GII f class C {S; fM; MM} Figure 9. Typing rules for the \ntoplevel language o : C[CI[{mi : Si}i.I ] f,T g] c o.g = o.f.mj (); switch (o.g) {l : el}l.E . (R-CALL) \no : C[CI[F ] f,T g] c o.g = return e{o.f/this} from o.f; switch (o.g) {l : el}l.E . * o : C[CI[Fl0 ] \nf,T g] c o.g = return l0 from o.f; switch (o.g) {l : el}l.E . (R-RETURN) o : C[CI[Sl0 ] f,T g] c o.g \n= l0; switch (o.g) {l : el}l.E . (R-ASSIGN, R-SEQ)  o : C[CI[(l : Sl)l.E ] f, (E link o.f) g] c switch \n(o.g) {l : el}l.E . (R-ACCESS) o : C[CI[Sl0 ] f, Null g] c switch (l0) {l : el}l.E . (R-SWITCH) o : \nC[CI[Sl0 ] f, Null g] cel0  Figure 10. Example of the interplay between method call, switch and link \ntypes (heaps and rightmost typing environment omitted). have xi : Ti I , this : C[F ] cei : Ti < this \n: C[Fi] with Fi such that Fi f C : Si and if Fi = (l : )l.E then Ti = E link this. If S = (l : Sl)l.E \n, then F = (l : Fl)l.E and for any l in E we have Fl f C : Sl. The relation F f C : S represents the \nfact that an object with internal type C[F ] can be safely viewed from outside as having type C[S]. First \nnote that . can only be used as a component of a variant .eld typing and represents a case that never \noccurs, hence its particular status in the de.nition: any session type at all is compatible with it, \nbecause it is internally known that the label will never have the corresponding value. The second point \naccounts for correspondence between variant types. The main point is the .rst: if the object has internal \ntype C[F ] and its session type allows a certain method to be called, then it means that the method body \nis typable with an initial type of C[F ] for this and the declared type for the parameter. Furthermore, \nthe type of the expression must match the declared return type and the .nal type of this must be compatible \nwith the subsequent session type. In the particular case where the .nal type is a variant, the returned \nvalue must be the tag of that variant, hence have the corresponding link type. We now comment on the \nrules of Figure 9. The last rule T-CLASS requires consistency between the declared session type of a \nclass and the initial null .eld typing. The others are for ex\u00adpressions. T-VAR and T-LINVAR are used \nto access a method s parameter, removing it from the environment if it has an object type (linear). For \nsimplicity, this is the only way to use a param\u00adeter, in particular we do not allow calling methods directly \non them: to call a method on a parameter, it must .rst be assigned to a .eld. T-ACCESS types .eld access, \nnullifying the .eld because its value has moved into the expression part of the judgement. T-ASSIGN types \n.eld update; the type of the .eld changes, and the type of the expression is Null, again because of linearity. \nIn both rules, the restriction to simple types (either a base, non-object, type or an object with a branch \nsession type) is to avoid invalidating link types. T-NEW types a new object, giving it the initial session \ntype from the class declaration. T-SEQ accounts for the effects of the .rst expression on the environment \nand checks that a label is not discarded, which would leave the associated variant unus\u00adable. T-CALL \nrequires an environment in which method r.mj is available. The type of the parameter is checked as usual, \nand the .nal environment GI is updated to contain the new session type of the object sitting at location \nr. The substitution occurring in the type of the call expression is only relevant when the return type \nof the method is of the form E link this, meaning that the type of the object after the call is a variant \nsession whose tag is the value returned. In that case, the type becomes E link r to indicate that the \nresult really describes the state of the object at r. T-INJF constructs a variant type. More precisely, \nit is used to give a variant .eld typing to an object from within; the literal label which constitutes \nthe expression is the tag of the variant type, thus the variant case corresponding to that particular \nlabel is the actual type of the object and the others are arbitrary. Note that when typing method bodies, \nr is always this, as there cannot be anything else in the environment which has a type of the form C[F \n]. It is also the only rule for typing labels, as they are only used in association with variants. T-SWITCH \ntypes a switch expression; the type of the argument must be a link to a location with a variant session \ntype. All branches must have the same .nal environment GI, so that it is a consistent .nal environment \nfor the switch expression. An interesting partic\u00adular case is if T is of the form EI link this: then \nthe different ex\u00adpressions may return different labels and modify the .elds types in different ways, \nand T-INJF allows those cases to be uni.ed into a single variant type. T-SUB is a standard subsumption \nrule, and T-SUBENV allows subsumption in the .nal environment. The main use of the latter rule is to \nenable the branches of a switch to be given the same .nal environments. Example of reduction and typing. \nFigure 10 illustrates the opera\u00adtional semantics and the way in which the environment used to type an \nexpression changes as the expression reduces (see Theorem 1, Section 5). The initial expression is o.g \n= o.f.mj (); switch (o.g) {case l : el}l.E where for simplicity we have ignored the parameter of mj . \nThe initial typing environment is o : C[CI[{mi : Si}i.I ] f,T g] where Sj = (l : Sl)l.E . The body of \nmethod mj is e with the typing this : CI[F ] ce : E link this < this : CI[(l : Fl)l.E ] and we suppose \nthat mj returns l0 . E. According to De.nition 4 and the typing of the declaration of class CI we have \nFl0 f CI : Sl0 and F f CI : {mi : Si}i.I . The .gure shows the environment in which each expression is \ntyped; the environment changes as reduction proceeds, for several reasons explained below. The typing \nof an expression is G ce : T< GI but we only show G because GI does not change and T is not the interesting \npart of this example. We also omit the heap, showing the typing of expressions instead of states. Calling \no.f.mj () changes the type of .eld f to CI[F ] because we are now inside the object. As e reduces to \nl0 the type of f may change, .nally becoming CI[Fl0 ] so that it has the component of the variant .eld \ntyping (l : Fl)l.E corresponding to l0. The reduction by R-RETURN changes the type of f to CI[Sl0 ] because \nwe are now outside the object again, but the type is still the component of a variant typing corresponding \nto l0. The assignment changes the type of f again, to CI[(l : Sl)l.E ], which is CI[Sj ], the type we \nwere expecting after the method call. At this point the information about which component of the variant \ntyping we have is stored in o.g. The type of the expression o.f.mj () is E link o.f, which appears as \nthe type of o.g after the assignment is executed. Extracting the value of o.g, in order to switch on \nit, nulli.es o.g and so the type E link o.f disappears from the environment and becomes the type of the \nsubexpression o.g, at the same time resolving the variant type of f according to the particular enumerated \nvalue l0. Extension: self-calls and recursive methods. The rules in Fig\u00adure 11 extend the language to \ninclude method calls on this and re\u00adcursive methods. Recursive calls are also self-calls. To simplify \nthe formal system, self-calls have their own syntax, which is not nec\u00adessary in the implementation. Self-calls \ndo not check or advance the session type. A method that is only self-called does not appear in the session \ntype. A method that is self-called and called from outside appears in the session type, and calls from \noutside do check and advance the session type. The reason why it is safe to not check the session type \nfor self-calls is that the effect of the self-call on the .eld typing is included in the effect of the \nmethod that calls it. All of the necessary checking of session types is done because of the original \noutside call that eventually leads to the self-call. Because they are not in the session type, self-called \nmethods must be explicitly annotated with their initial (req) and .nal (ens) .eld typings. The annotations \nare used to type self-calls and method de.nitions. If a method is in the session type then its body is \nchecked by the .rst hypothesis of T-CLASS, but the annotations (if present) are ignored except when they \nare needed to check recursive calls. If a method has an annotation then its body is checked by the second \nhypothesis of T-CLASS. If both conditions apply then the body is checked twice. The implementation can \noptimize this. Syntax (top-level) : M ::= ... | req F ens F for Tm(Tx) {e} e ::= ... | r#m(e) Reduction \nrule : m( x) {e}. h(r).class (R-SELFCALL) (h; r#m(v)) -. (h; e{r/this}{v/x}) Typing rule (expressions) \n: G ce : T I < GI GI(r)= C[F ] req F ens F I for Tm(T I x) {e}. C (T-SELFCALL) G cr#m(e): T< GI{r . C[F \nI]} Typing rule (annotated method de.nitions) : T-ANNOTMETH : F I fC req F ens F I for Tm(T I x) {e} \nx : T I , this : C[F ] ce : T< this : C[F I]= () Replacement for T-CLASS : - . M Null fMf C : S .m . \nM. (m has req/ens .fC m) f class C {S; fM; MM} Figure 11. Rules for recursive methods and other self-calls \nDeclarations D ::= ... | access (S) n Values v ::= ... | c + | c - | n Expressions e ::= ... | spawn \nC.m(e) Contexts E ::= ... | spawn C.m(E) Types T ::= ... |(S)Message types B ::= Null |(S)| Chan[S] Channel \nsession types S ::= ?[B] . S | &#38; {l :Sl} l.E | ! [B] . S | .{l :Sl} l.E | X | \u00b5X.S States s ::= ... \n| s I s | (.c) s Figure 12. Additional syntax for channels and states An annotated method cannot produce \na variant .eld typing or have a link type, because T-SWITCH can only analyze a variant session type. \nExtension: while loops. The language can easily be extended to include while loops. The reduction rule \nde.nes while recursively in terms of switch, and the typing rule is derived straightforwardly from T-SWITCH. \n4. A Core Distributed Language We now de.ne a distributed language based on the idea of a con.g\u00aduration, \nwhich is a parallel collection of threads (heap-expression pairs) representing separate locations. States, \nwhich represented a single thread in Figure 6, are extended in Figure 12 to represent such a parallel \ncon.guration. The expressions in different loca\u00adtions can communicate via synchronous messages on point-to-point \nchannels. The new syntax and reduction rules are de.ned in Fig\u00adures 12 and 13; they have already been \nillustrated by the examples in Section 2. The primitive operations send and receive are treated Structural \ncongruence: E-COMM, E-ASSOC, E-SCOPE s1 I s2 = s2 I s1 s1 I (s2 I s3) = (s1 I s2) I s3 s1 I (.c)s2 = \n(.c)(s1 I s2) if c + ,c - not free in s1 Additional reduction rules and typing rules for expressions: \nI h(r).f = nhI(r I).fI = nc fresh s -. s (R-INIT) `\u00b4 (R-PAR) II I+-II -. s I I s (h; E[r.f.accept()]) \nI (hI; EI[r .fI .request()]) -. (.c)(h; E[c ]) I (hI; EI[c ]) s I s p Ip I II II = s III h(r).f = chI(r \n).fI = cs = ss I -. ss (R-COM) (R-STR) III (h; E[r.f.send(v)]) I (hI; EI[r I.fI .receive()]) -. (h; E[null]) \nI (hI; EI[v]) s -. s M o fresh C..elds = fm( x) {e}. Cs -. s I (R-SPAWN) (R-NEWCHAN) M(.c) s -. (.c) \ns I (h; E[spawn C.m(v)]) -. (h; E[null]) I (o = C[fM= null]; e{o/this}{v/x}) G ce : B< GI C.session \n= {mi : }i.I j . Imj (Bx) {}. C n.protocol =S (T-SPAWN) (T-NAME) G c spawn C.mj (e): Null < GI G cn : \n(S) < G G(r.f)= (S) G(r.f)= (S) (T-ACCEPT) (T-REQUEST) G c r.f.accept() : Chan[[S]] < GG c r.f.request() \n: Chan[[] < G S] Figure 13. Reduction and typing rules for concurrency and channels Given a channel \nsession type S, de.ne a class session type [S]: [X] = X [\u00b5X.S] = \u00b5X. [S] [?[T ] . S] = {receiveT : [S]} \n[! [T ] . S] = {sendT : [S]}[&#38; {l :Sl}] = {receiveE : (l : [Sl])l.E} l.E[.{l :Sl}] = {sendl : [Sl]}l.E \nl.E and method signatures: T receiveT () Null sendT (Tx) (E link this) receiveE () Null sendl() Figure \n14. Translation of a channel session type into a class ses\u00adsion type. as method names m. A channel has \ntwo endpoints, c + and c -, on which send and receive can be called; each endpoint has a session type \nS. We write S for the dual of S, obtained by exchanging &#38;/. and ?/!. The two endpoints of a channel \nhave dual types, just as p in previous work [24]. In (.c)s, .c binds c + and c -. We write cfor an unspeci.ed \nendpoint and cp for its partner. The other new value is n, which ranges over access points (service names) \nthat can be used to initialize channels by interaction between request() and accept(). These access points \nare announced in a way similar to class and enum declarations, and we use the notation n.protocol to \nmean the protocol (session type) S associated to access point n, similarly to C.session. Access points \nmust be announced with the same type in all locations; we assume some mechanism to enforce or check this \nrestriction. The type of an access point is (S), and the new channel endpoints will have types S and \nS. The de.nitions at the level of con.gurations are similar to previous work on ses\u00adsion types for functional \nlanguages [25, 51]. As well as R-INIT, the crucial rule is R-COM for synchronous communication. In the \ndef\u00adinition of channel session types, messages have non-object types. In the core language this means \nthat messages can only be channel endpoints, access points or null, but we could easily add non-object \nbase types. The reason for not allowing objects as messages is to avoid the complication of de.ning the \ntransfer of an object and all of its subobjects from one heap to another. It is not a fundamental restriction. \n As explained in Section 2, spawn C.m(e) creates a new com\u00adponent of the con.guration, with a new local \nheap containing an instance of class C on which m(e) is called. Figure 14 de.nes a class session type \nfor each channel session type S. A channel with type S is treated as an object with type Chan[[S]] where \nChan is a distinguished class name. Environ\u00adments G are extended to allow channel endpoints cp in addition \nto object identi.ers and variables. The operations send and receive are typed as method calls, and the \nchannel remains available for further communication. Figure 14 de.nes different sendT and receiveT methods \nfor each type T , but the implementation omits the T and uses the session type and/or the parameter type \nto disambiguate. Rule R-COM ignores the subscript. Also, R-COM treats sendl as send(l); the message must \nbe a literal label. Access points do not behave like objects; new typing rules are needed for them (Figure \n13, bottom line). T-NAME types an access point as a literal value, and T-ACCEPT and T-REQUEST are used \nto type channel creation. 5. Properties of the Type System In order to state a type preservation theorem, \nwe .rst need to extend the type system to states. This is done in Figure 15. First of all there are a \nfew more rules for expressions: T-REF allows typing an object identi.er and T-CHAN a literal channel \nendpoint. T-INJS complements T-INJF by allowing a literal label to be the tag of a variant session type \nas well as of a variant .eld typing (at top level, variant session types can only come from method calls). \nT-RETURN serves to type a return expression, representing an ongoing method call in the object at r. \nThe expression e is typed in an environment where this object s .elds are accessible, but the return \nhas the effect of closing the object by reverting its type to the outside view of a session. The technical \nsubstitution in GI(r) only applies to the link types which may be contained in F ; it is due to the fact \nthat F f C : S (De.nition 4) uses judgements in an environment where the object is this. The next four \nrules de.ne a relation T; G f h between a channel environment T, a typing environment G and a heap h. \nT is similar to a regular typing environment but only contains types for channel endpoints; thus in the \npurely sequential setting it is always empty. T is simple p G(r)= C[Sl0 ] l0 . E All Sl are branches \n(T-REF) (T-CHAN) G,c: T ccp : T< G (T-INJS) G,o : T co : T< GG cl0 : E link r< G{r . C[(l : Sl)l.E ]} \nG ce : T< GI If T = E link r I then r I = r GI(r)= C[F {r/this}] F f C : S (T-RETURN) (T-HEMPTY) T; T \nf e G c return e from r : T< GI{r . C[S]} ( Gi-1 cvi : Ti < Gi if Ti is simple, or T; G0 f h .i .{1 \n...n}, C..elds =(fi)1 i n Gi-1 =Gi,vi : Ti if it is not (T-HADD) T; (Gn,o : C[{Ti fi}1 i n]){ link o.fi.q.}f \nh :: o = C[{fi = vi}1 i n] ./ link vi.q T; G,o : C[F ] f hF {this/o}f C : S T; G f h G ce : T< GI (T-HIDE) \n(T-STATE) T; G,o : C[S] f h T; G c (h; e): T< GI + - I T; G c (h; e): T< GI T f s TI f s T,c : Chan[[S]],c \n: Chan[[S]] f s (T-THREAD) (T-PAR) I (T-NEWCHAN) T f (h; e) T+TI f s I s T f (.c) s Figure 15. Additional \ntyping rules for the proofs The rules are technical, but essentially they enforce restrictions on the \ncontents of G: a channel endpoint can only appear in it if it is also in T with the same type (T-HEMPTY). \nAn object can only appear in it if it is in the heap and either has a .eld typing consistent with its \n.eld values (T-HADD) or has a session type consistent with this .eld typing (T-HIDE). T-HADD also takes \ncare of removing from the top level environment whatever goes into the .elds of the objects; this includes \nchannel endpoints, thus G can end up containing fewer channel endpoints than T even though the starting \npoint of the derivation is always T-HEMPTY. Finally, T-STATE de.nes that a typing judgement holds for \na given single\u00adthreaded program state if it holds for the corresponding expression and the initial typing \nenvironment is compatible with the heap and the channel environment. The remaining rules are for distributed \ncon.gurations and we comment on them later. By standard techniques [53] adapted to typing judgements \nwith initial and .nal environments [26] we can prove the expected re\u00adsults about an individual thread. \nAssume that we are working rela\u00adtive to a set of well-typed declarations. THEOREM 1 (Type Preservation). \nIf T; G c (h; e): T< GI and (h; e) -. (hI; e I) then there exists GII such that T; GII c(hI; e I): T< \nGI . THEOREM 2 (No Stuck States). If \u00d8;Gc(h; e): T<GI then either e is a value or there exists hI and \ne I such that (h; e) -. (hI; e I). Notice that in Theorem 2 the channel environment must be empty. Otherwise, \nthe thread might be waiting for a communication and thus unable to reduce by itself. We also have conformance \nof sequences of method calls to session types. DEFINITION 5 (Call Traces). A call trace on an object \no is a se\u00adquence m1a1m2a2 ... where each mi is a method name and each ai is either an enumeration label \nor nothing. Following the operational semantics, it is possible to de.ne a call trace for every object, \nexcluding self-calls. A session type de.nes a set of call traces, which is simply the set of paths through \nthe session type regarded as a labelled directed graph. We state the result informally to avoid presenting \na sequence of very technical de.nitions. THEOREM 3 (Conformance). When executing a typed program, the \ncall trace of every object is one of the traces of the initial session PROOF (Sketch): Similar to the \nproof of Theorem 1, with a stronger invariant. Rule T-CALL shows that every method call conforms to the \ncurrent session type of the target object. The most interesting case is a reduction by R-RETURN when \nthe value is a label l: the call trace is extended by l and the session type of the object advances to \nthe corresponding option which will eventually be selected by a switch on l. D Distributed setting. The \nthree last rules of Figure 15 describe how distributed con.gurations are typed. T-THREAD extracts the \nchannel environment from the typing of a single thread. T-PAR merges two environments (+ represents disjoint \nunion; it is not de.ned if the domains overlap). T-NEWCHAN checks for duality. We use f s as an abbreviation \nfor \u00d8f s; this represents well\u00adtypedness of a closed con.guration. We have the following result: THEOREM \n4. If f s and s -. s I then f s I . PROOF (Sketch): In order to do an inductive proof we need to state \na similar result for con.gurations with free channels. It relies on the concept of a balanced channel \nenvironment, similarly to previous work on session types in p-calculus [24], which is roughly de.ned \nas follows: T is balanced if whenever T(c +)= Chan[[S]] and T(c -)= Chan[[SI]] then SI =S. We argue that \nif s is typed in a balanced environment and communication takes place on channel c, then the endpoints \nhave dual session types and the communication advances both of them, so they remain dual and the resulting \nenvironment, which types s I , is also balanced. Reduction internal to a thread does not affect T as \nstated in Theorem 1, R-SPAWN does not affect channels either, and R-INIT introduces a bound channel whose \nendpoints types are dual because access points have the same type in all locations. D In the distributed \nlanguage, call traces can also be de.ned for channel endpoints. Because of the translation from channel \nsession types to class session types, these call traces correspond to the se\u00adquence and type of messages. \nWe therefore have, stated informally: COROLLARY 1 (to Theorem 3). When executing a typed con.gu\u00adration, \nthe sequence of communication operations on every channel endpoint conforms to its session type. Furthermore, \nwe have the following safety result: THEOREM 5 (No Communication Errors). Suppose that we have I III \n s = (.Mc)(s I (h; E[r.f.m(v)]) I (hI; E[r .fI .m (v )])) with h(r).f = c + and hI(r I).fI = c - . If \nf s, then there exists s II such that s -. s II . Note that by setting s I to something which cannot \nreduce (e.g. type of its class. (e; null)) we obtain more precisely that the particular reduction which \nconsists of R-COM applied to the two rightmost components is always possible. This means in particular \nthat if m is send then m I is receive and conversely. This theorem complements Theorem 2 in the case \nof communication: if the reducible part of the expression in a thread is a method call on a channel endpoint, \nwhich was not allowed in Theorem 2, then it is still able to reduce provided another thread calls a method \non the other endpoint. 6. Typechecking Algorithm Figure 16 de.nes a typechecking algorithm for the language. \nAl\u00adgorithm A is used to check the relation F f C : S; it uses inter\u00adnally, for recursive calls, a set \n. of assumptions which is needed because of the coinductive de.nition of this relation. If typing suc\u00adceeds, \nthen this set is returned, else nothing is returned. The actual contents of the set returned are not \nrelevant at the top level. The algorithm for checking subtyping is not described here but is similar \nto the one de.ned for channel session types in [24]. We write sup(S, SI) for the least upper bound of \nS and SI with respect to subtyping, and extend it to sup(C[S],C[SI]), requiring the same C in both types. \nIt is de.ned by taking the intersection of sets of methods and the least upper bound of their continuations. \nDetails of a similar de.nition (greatest lower bound of channel session types) can be found in [36]. \nA program is typechecked by checking, for every class C, M that AC (C.session, Null C..elds, \u00d8) returns \nsomething. This cor\u00adresponds to checking T-CLASS. Algorithm A uses algorithm B to check method de.nitions. \nThe de.nition of B follows the typing rules (Figure 9) except for one point: T-INJF means that the rules \nare not syntax-directed. To compensate, clause l produces a par\u00adtial variant .eld typing with an incomplete \nset of labels, and clause switch uses the l operator to combine partial variants and check for consistency. \nThen the operation comp(F ) used in algorithm A transforms a partial variant into a true variant by adding \n. in the missing cases. The various where and if clauses should be interpreted as conditions for the \nfunctions to be de.ned; cases in which the functions are unde.ned should be interpreted as typing errors. \nThe typechecking algorithm is modular in the sense that to check class C we only need to know the session \ntypes of other classes, not their method de.nitions. THEOREM 6. Algorithm A always terminates, either \nwith an error (and then the function A is unde.ned) or with a result. PROOF: Similar to proofs about \nalgorithms for coinductively\u00adde.ned subtyping relations [43]. D THEOREM 7. AC (S, F, \u00d8) is de.ned if \nand only if F f C : S. PROOF (Sketch): If direction: we prove by induction on the num\u00adber of recursive \ncalls the more general result that if .0 is such that (F, S) . .0 implies F f C : S and if F0 f C : S0 \nholds, then AC (S0,F0, .0) is de.ned. Only if direction: if AC (S0,F0, \u00d8) is de.ned, we look at its evaluation \nand de.ne the following relation: F R S iff AC gets called with parameters F and S at some point. We \nthen prove that R satis.es the hypotheses of De.nition 4, hence is included in the largest such relation, \nand conclude by noticing that we have F0 R S0. D 7. Implementation We have used the Polyglot [41] system \nto implement the ideas of this paper as a prototype extension to Java 1.4, which we call Bica. This includes \ntype-checking method calls against the class session AC (S, ., .) = . AC (S, F, .) = . if (F, S) . . \nAC (\u00b5X.S, F, .) = AC (S{\u00b5X.S/X }, F, . .{(F, \u00b5X.S)}) AC ({mi : Si}1 in, F, .0)=.n where for i =1 to n, \n.i = AC (Si, comp(Fi), .i-1) where Ti mi(Ui xi) {ei}. C and (Ti I,Fi, )= BC (ei, F, xi : Ui) and Ti \nI <: Ti and if comp(Fi)= (l : ...)l.E then Ui = E link this AC ((l : Sl)l.E , (l : Fl)l.E , .0)=.n where \nE.labels = {l1 ...ln} and for i =1 to n, .i = AC (Sli ,Fli , .i-1) BC (null, F, G) = (Null, F, G) BC \n(n, F, G) = ((n.protocol), F, G) BC (x, F, x : T )=(T, F, G) where G= \u00d8 if T is linear or x : T otherwise \nBC (this.f, F, G) = (T, F {f . Null}, G) where T = F (f ) and T is simple BC (l, F, G) = (E link this, \n(l : F ), G) where l . E BC (new CI(), F, G) = (CI[CI .session], F, G) BC (this.f = e, F, G) = (Null,F \nI{f . T }, GI) where (T, F I , GI)= BC (e, F, G) and F (f) is simple BC (this.f.mj (e), F, G) = (T {f/this},F \nI{f . CI[Sj ]}, GI) where (UI,F I , GI)= BC (e, F, G) and F I (f )= CI[{mi : Si}i.I ] and j . I and Tmj \n(Ux) {}. CI and UI <: U U BC (switch (e) {l : el}l.E , F, G) = (T, Fl I , GII) l.E where (E link f, \nF I , GI)= BC (e, F, G) and F I(f)= CI[(l : Sl)l.E ] and .l . E, (T, F l I , Gl)= BC (el,F I{r . CI[Sl]}, \nGI) and T GII = l.E Gl  BC (e; e I, F, G) = BC (e I,F I , GI) where ( ,F I , GI)= BC (e, F, G) BC (this.f.accept(), \nF, G) = (Chan[[S]], F, G) where F (f)= (S) BC (this.f.request(), F, G) = (Chan[[S]], F, G) where F (f)= \n(S) BC (spawn CI .mj (e), F, G) = (Null,F I , GI) where (BI,F I , GI)= BC (e, F, G) and CI .session \n= {mi : Si}i.I and j . I and Tmj (Bx) {}. CI and BI <: B Combining partial variants {Ti fi}i.I l{Ti \nI fi}i.I = {sup(Ti,T i I) fi}i.I (l : Fl)l.I l(l : Fl I)l.J = (l : Fl II)l.I.J where F II = Fl l F I \nif l . I n J, Fl if l . J, F I if l . I ll l comp(F )= F if F is not a partial variant comp((l : Fl)l.I \n)= (l : Fl)l.E if I . E, where Fl = . for l . I Figure 16. Typechecking algorithm.  types of non-uniform \nobjects, and inheritance as outlined in Sec\u00adtion 2, but not yet generating class session types from channel \nses\u00adsion types. Bica supports shared as well as linear objects, standard as well as session-related conditionals, \nswitch, while-loops, and re\u00adturn values. Bica is implemented on top of the JL5 Polyglot exten\u00adsion in \norder to cater to enumerated types as well as to allow Java 5 features to be added later. The semantics \nof Bica is standard Java. It is available from http://gloss.di.fc.ul.pt/bica/. We have begun to experiment \nwith de.ning session types for iterators and collections from the Java 1.4.2 java.util package. For iterators \nthis is a straightforward process. Other cases are not so easy; API documentation is not always explicit \nabout the proto\u00adcol for sequences of calls. It will be necessary to experiment with naturally-occurring \nclient code in order to determine the most suit\u00adable session types. Further results about Bica and annotation \nof APIs will be reported in future publications. 8. Related Work Previous work on session types for object-oriented \nlanguages. Several recent papers by Dezani-Ciancaglini, Yoshida et al. [10, 17 19, 31, 38] have combined \nsession types, as speci.cations of protocols on communication channels, with the object-oriented paradigm. \nA characteristic of all of these works is that a channel is always created and used within a single method \ncall. It is possible for a method to delegate a channel by passing it to another method, but it is not \npossible to modularize session implementations as we do, by storing a channel in a .eld of an object \nand allowing several methods to use it. We are also able to interleave sessions on different channels. \nThe most recent work in this line [10] uni.es sessions and methods, and continues the idea that a session \nis a complete entity. Mostrous and Yoshida [38] add sessions to Abadi and Cardelli s object calculus. \nNon-uniform concurrent objects / active objects. Another re\u00adlated line of research was started by Nierstrasz \n[40], aimed at de\u00adscribing the behaviour of non-uniform active objects in concurrent systems, whose behaviour \n(including the set of available methods) may change dynamically. He de.ned subtyping for active objects, \nbut did not formally de.ne a language semantics or a type sys\u00adtem. The topic has been continued, in the \ncontext of process cal\u00adculi, by several authors [9, 45 47]. Caires [9] is the most relevant work; it \nuses an approach based on spatial logic to give very .ne\u00adgrained control of resources, and Milit ao [37] \nhas implemented a Java prototype based on this idea. Damiani et al. [14] de.ne a con\u00adcurrent Java-like \nlanguage incorporating inheritance and subtyping and equipped with a type-and-effect system, in which \nmethod avail\u00adability is made dependent on the state of objects. The distinctive feature of our approach \nto non-uniform objects, in comparison with all of the above work, is that we allow an object s abstract \nstate to depend on the result of a method call. This gives a very nice integration with the branching \nstructure of channel session types, and with subtyping. Typestates. Based on the fact that method availability \ndepends on an object s internal state (the situation identi.ed by Nierstrasz, as mentioned above), Strom \nand Yemini propose typestates [48]. The concept consists of identifying the possible states of an object \nand de.ning pre-and post-conditions that specify in which state an object should be so that a given method \nwould be available, and in which state the method execution would leave the object. Vault [15, 20] follows \nthe typestates approach. It uses linear types to control aliasing, and uses the adoption and focus mech\u00adanism \n[20] to re-introduce aliasing in limited situations. Fugue [16, 21] extends similar ideas to an object-oriented \nlanguage, and uses explicit pre-and post-conditions. Bierhoff and Aldrich [5] also work on a typestates \napproach in an object-oriented language, de.ning a sound modular automated static protocol checking setting. \nThey de.ne a state and method re.nement relation achieving a behavioural subtyping relation. The work \nis extended with access permissions, that combines typestate with aliasing information about objects \n[4], and with concurrency, via the atomic bloc synchronization primitive used in transactional memory \nsystems [3]. Like us, they allow the typestate to depend on the result of a method call. Plural is a \nprototype tool that embodies their approach, providing automated static analysis in a concurrent object-oriented \nlanguage [6]. To evaluate their approach they annotated and veri.ed several standard Java APIs [7]. Finally, \nSing# [22] is an extension of C# which has been used to implement Singularity, an operating system based \non message\u00adpassing. It incorporates session types to specify protocols for com\u00admunication channels, and \nintroduces typestate-like contracts The published paper [22] does not discuss the relationship between \nchannel contracts and non-uniform objects or typestates, and does not de.ne a formal language. A technical \npoint is that Sing# uses a single construct switch receive to combine receiving an enumer\u00adation value \nand doing a case-analysis, whereas our system allows a switch on an enumeration value to be separated \nfrom the method call that produces it. Session types and typestates are related approaches, but there \nare stylistic and technical differences. With respect to the former, session types are like labelled \ntransition systems or .nite-state au\u00adtomata, capturing the behaviour of an object. When developing an \napplication, one may start from session types and then implement the classes. Typestates take each transition \nof a session type and attach it to a method as pre-and post-conditions. With respect to technical differences, \nthe main ones are: (a) session types unify types and typestates in a single class type as a global behavioural \nspeci.cation; (b) our subtyping relation is structural, while the typestates re.nement relation is nominal; \n(c) Plural uses a soft\u00adware transactional model as concurrency control mechanism (thus, shared memory), \nwhich is lighter and easier than locks, but one has to mark atomic blocks in the code, whereas our communication\u00adcentric \nmodel (using channels) is simpler and allows us to use the same type abstraction (session types) instead \nof a new program\u00adming construct; moreover, channel-based communication also al\u00adlows us to specify the \nclient-server communication protocol as the channel session type, and to implement it modularly, in several \nmethods which may even be in different classes; (d) typestates ap\u00adproaches allow .exible aliasing control, \nwhereas our approach uses only linear objects (to add better alias/access control is simple and an orthogonal \nissue). Static veri.cation of protocols. Cyclone [27] and CQual [23] are systems based on the C programming \nlanguage that allow protocols to be statically enforced by a compiler. Cyclone adds many bene.ts to C, \nbut its support for protocols is limited to enforcing locking of resources. Between acquiring and releasing \na lock, there are no restrictions on how a thread may use a resource. In contrast, our system uses types \nboth to enforce locking of objects (via linearity) and to enforce the correct sequence of method calls. \nCQual expects users to annotate programs with type quali.ers; its type system, simpler and less expressive \nthan the above, provides for type inference. Unique ownership of objects. In order to demonstrate the \nkey idea of modularizing session implementations by integrating session\u00adtyped channels and non-uniform \nobjects, we have taken the sim\u00adplest possible approach to ownership control: strict linearity of non-uniform \nobjects. This idea goes back at least to the work of Baker [2] and has been applied many times. However, \nlinearity causes problems of its own: linear objects cannot be stored in shared data structures, and \nthis tends to restrict expressivity. There is a large literature on less extreme techniques for static \ncontrol of aliasing: Hogg s Islands [28], Almeida s balloon types [1], Clarke et al. s ownership types \n[13], F\u00a8ahndrich and DeLine s adoption and focus [20], Ostlund et al. s Joe3 [42] among others. In future \nwork \u00a8we intend to use an off-the-shelf technique for more sophisticated alias analysis. The property \nwe need is that when changing the type of an object (by calling a method on it or by performing a switch \nor a while on an enumeration constant returned from a method call) there must be a unique reference to \nit. Resource usage analysis. Igarashi and Kobayashi [32] de.ne a general resource usage analysis problem \nfor an extended .\u00adcalculus, including a type inference system, that statically checks the order of resource \nusage. Although quite expressive, their system only analyzes the sequence of method calls and does not \nconsider branching on method results as we do. Analysis of concurrent systems using pi-calculus. Some \nwork on static analysis of concurrent systems expressed in pi-calculus is also relevant, in the sense \nthat it addresses the question (among others) of whether attempted uses of a resource are consistent \nwith its state. Kobayashi et al. have developed a generic framework [33] including a veri.cation tool \n[34] in which to de.ne type systems for analyzing various behavioural properties including sequences \nof resource uses [35]. In some of this work, types are themselves abstract processes, and therefore in \nsome situations resemble our session types. Chaki et al. [12] use CCS to describe properties of pi\u00adcalculus \nprograms, and verify the validity of temporal formulae via a combination of type-checking and model-checking \ntechniques, thereby going beyond static analysis. All of this pi-calculus-based work follows the approach \nof mod\u00adelling systems in a relatively low-level language which is then ana\u00adlyzed. In contrast, we work \ndirectly with the high-level abstractions of session types and objects. 9. Conclusions We have extended \nexisting work on session types for object\u00adoriented languages by allowing the implementation of a session \nto be divided between several methods which can be called in\u00addependently. This supports a modular approach \nwhich is absent from previous work. Technically, it is achieved by integrating ses\u00adsion types for communication \nchannels and a static type system for non-uniform objects. A session-typed channel is one kind of non-uniform \nobject, but objects whose .elds are non-uniform are also, in general, non-uniform. Typing guarantees \nthat the sequence of messages on every channel, and the sequence of method calls on every non-uniform \nobject, satisfy speci.cations expressed as session types. We have formalized the syntax, operational \nsemantics and static type system of a core distributed class-based object-oriented lan\u00adguage incorporating \nthese ideas. Soundness of the type system is expressed by type preservation, conformance and correct \ncommu\u00adnication theorems. The type system includes a form of typestates and uses simple linear type theory \nto guarantee unique ownership of non-uniform objects. Somewhat unusually, it allows the state of an object \nafter a method call to depend on the result of the call, if this is of an enumerated type. We have illustrated \nour ideas with an example based on e\u00adcommerce, and described a prototype implementation. By incorpo\u00adrating \nfurther standard ideas from the related literature, it should be straightforward to extend the implementation \nto a larger and more practical language. In the future we intend to work on the following topics. (1) \nMore .exible control of aliasing. The mechanism for controlling aliasing should be orthogonal to the \ntheory of how operations affect uniquely-referenced objects. We intend to adapt existing work to relax \nour strictly linear control and obtain a more .exible language. (2) Java-style interfaces. If class \nC implements interface I then we should have session(C) <: session(I), interpreting the interface as \na speci.cation of minimum method availability. (3) Speci.cations involving several objects. Multi-party \nsession types [8, 30] specify protocols with more than two participants. It would be interesting to adapt \nthat theory into a type system for more complex patterns of object usage. Acknowledgments Gay was partially \nsupported by the UK EPSRC (EP/E065708/1 Engineering Foundations of Web Services and EP/F037368/1). He \nthanks the University of Glasgow for the sabbatical leave during which part of this research was done. \nGay and Ravara were partially supported by the Security and Quantum Information Group at In\u00adstituto de \nTelecomunicac\u00b8oes, Portugal. Caldeira, Ravara, and Vas\u00ad concelos were partially supported by the EU IST \nproactive initia\u00adtive FET-Global Computing (project Sensoria, IST 2005 16004). Vasconcelos was partially \nsupported by the Large-Scale Infor\u00admatics Systems Laboratory, Portugal. Ravara was partially sup\u00adported \nthe Portuguese Fundac\u00b8ao para a Ci encia e a Tecnologia FCT (SFRH/BSAB/757/2007), and by the UK EPSRC \n(EP/F037368/1 Behavioural Types for Object-Oriented Languages ). Gesbert was supported by the UK EPSRC \n(EP/E065708/1). We thank Jonathan Aldrich and Lu\u00b4is Caires for helpful discussions. References [1] P. \nS. Almeida. Balloon types: Controlling sharing of state in data types. ECOOP, Springer LNCS, 1241:32 \n59, 1997. [2] H. G. Baker. Use-once variables and linear objects storage management, re.ection and \nmulti-threading. ACM SIGPLAN Notices, 30(1):45 52, 1995. [3] N. E. Beckman, K. Bierhoff, and J. Aldrich. \nVerifying correct usage of atomic blocks and typestate. In OOPSLA 08, pages 227 244. ACM Press, 2008. \nISBN 978-1-60558-215-3. doi: http://doi.acm.org/10. 1145/1449764.1449783. [4] K. Bierhoff and J. Aldrich. \nModular typestate checking of aliased ob\u00adjects. In OOPSLA 07, pages 301 320. ACM Press, 2007. ISBN 978\u00ad1-59593-786-5. \ndoi: http://doi.acm.org/10.1145/1297027.1297050. [5] K. Bierhoff and J. Aldrich. Lightweight object speci.cation \nwith typestates. In 13th ACM SIGSOFT Symposium on Foundations of Software Engineering (FSE 05), pages \n217 226. ACM Press, 2005. [6] K. Bierhoff and J. Aldrich. PLURAL: checking protocol compliance under \naliasing. In ICSE Companion 08, pages 971 972. ACM Press, 2008. ISBN 978-1-60558-079-1. doi: http://doi.acm.org/10.1145/ \n1370175.1370213. [7] K. Bierhoff, N. E. Beckman, and J. Aldrich. Practical API protocol checking with \naccess permissions. In ECOOP 09, pages 195 219, 2009. [8] E. Bonelli and A. Compagnoni. Multipoint session \ntypes for a dis\u00adtributed calculus. TGC, Springer LNCS, 4912:240 256, 2007. [9] L. Caires. Spatial-behavioral \ntypes for concurrency and resource control in distributed systems. Theoret. Comp. Sci., 402(2 3):120 \n141, 2008. [10] S. Capecchi, M. Coppo, M. Dezani-Ciancaglini, S. Drossopoulou, and E. Giachino. Amalgamating \nsessions and methods in object-oriented languages with generics. Theoret. Comp. Sci., 410:142 167, 2009. \n [11] M. Carbone, K. Honda, and N. Yoshida. Structured global program\u00adming for communication behaviour. \nESOP, Springer LNCS, 4421:2 17, 2007. [12] S. Chaki, S. K. Rajamani, and J. Rehof. Types as models: model \nchecking message-passing programs. POPL, ACM SIGPLAN Notices, 37(1):45 57, 2002. [13] D. G. Clarke, \nJ. M. Potter, and J. Noble. Ownership types for .exible alias protection. OOPSLA, ACM SIGPLAN Not., 33(10):48 \n64, 1998. [14] F. Damiani, E. Giachino, P. Giannini, and S. Drossopoulou. A type safe state abstraction \nfor coordination in Java-like languages. Acta Informatica, 45(7 8):479 536, 2008. ISSN 0001-5903. URL \nhttp: //pubs.doc.ic.ac.uk/stateAbstrCoordJava/. [15] R. DeLine and M. F\u00a8ahndrich. Enforcing high-level \nprotocols in low\u00adlevel software. PLDI, ACM SIGPLAN Notices, 36(5):59 69, 2001. [16] R. DeLine and M. \nF\u00a8ahndrich. The Fugue protocol checker: is your software Baroque? Technical Report MSR-TR-2004-07, Microsoft \nResearch, 2004. [17] M. Dezani-Ciancaglini, N. Yoshida, A. Ahern, and S. Drossopolou. A distributed object-oriented \nlanguage with session types. TGC, Springer LNCS, 3705:299 318, 2005. [18] M. Dezani-Ciancaglini, D. Mostrous, \nN. Yoshida, and S. Drossopolou. Session types for object-oriented languages. ECOOP, Springer LNCS, 4067:328 \n352, 2006. [19] M. Dezani-Ciancaglini, S. Drossopoulou, E. Giachino, and N. Yoshida. Bounded session \ntypes for object-oriented languages. FMCO, Springer LNCS, 4709:207 245, 2007. [20] M. F\u00a8ahndrich and \nR. DeLine. Adoption and focus: practical linear types for imperative programming. PLDI, ACM SIGPLAN Notices, \n37 (5):13 24, 2002. [21] M. F\u00a8ahndrich and R. DeLine. Typestates for objects. ESOP, Springer LNCS, 3086:465 \n490, 2004. [22] M. F\u00a8ahndrich, M. Aiken, C. Hawblitzel, O. Hodson, G. Hunt, J. R. Larus, and S. Levi. \nLanguage support for fast and reliable message\u00adbased communication in Singularity OS. In EuroSys. ACM, \n2006. [23] J. S. Foster, T. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. PLDI, ACM SIGPLAN \nNotices, 37(5):1 12, 2002. [24] S. J. Gay and M. J. Hole. Subtyping for session types in the pi calculus. \nActa Informatica, 42(2/3):191 225, 2005. [25] S. J. Gay and V. T. Vasconcelos. Linear type theory for \nasynchronous session types. Journal of Functional Pro\u00adgramming, 2009. URL http://www.dcs.gla.ac.uk/~simon/ \npublications/Lin-Async.pdf. To appear. [26] S. J. Gay, A. Ravara, and V. T. Vasconcelos. Session types \nfor inter\u00adprocess communication. Technical Report TR-2003-133, Comp. Sci., Univ. Glasgow, 2003. [27] \nD. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and J. Ch\u00adeney. Region-based memory management \nin Cyclone. PLDI, ACM SIGPLAN Notices, 37(5):282 293, 2002. [28] J. Hogg. Islands: aliasing protection \nin object-oriented languages. OOPSLA, ACM SIGPLAN Notices, 26(11):271 285, 1991. [29] K. Honda, V. Vasconcelos, \nand M. Kubo. Language primitives and type discipline for structured communication-based programming. \nESOP, Springer LNCS, 1381:122 138, 1998. [30] K. Honda, N. Yoshida, and M. Carbone. Multiparty asynchronous \nsession types. POPL, ACM SIGPLAN Notices, 43(1):273 284, 2008. [31] R. Hu, N. Yoshida, and K. Honda. \nSession-based distributed program\u00adming in Java. ECOOP, Springer LNCS, 5142:516 541, 2008. [32] A. Igarashi \nand N. Kobayashi. Resource usage analysis. ACM Trans. on Programming Languages and Systems, 27(2):264 \n313, 2005. [33] A. Igarashi and N. Kobayashi. A generic type system for the pi\u00adcalculus. Theoretical \nComputer Science, 311(1-3):121 163, 2004. [34] N. Kobayashi. Type-based information .ow analysis for \nthe pi\u00adcalculus. Acta Informatica, 42(4 5):291 347, 2005. [35] N. Kobayashi, K. Suenaga, and L. Wischik. \nResource usage analysis for the p-calculus. Logical Methods in Comp. Sci., 2(3:4):1 42, 2006. [36] L. \nG. Mezzina. Typing Services. PhD thesis, IMT Institute for Advanced Studies, Lucca, Italy, 2009. [37] \nF. Milit ao. Design and implementation of a behaviorally typed pro\u00adgramming system for web services. \nMaster s thesis, New University of Lisbon, 2008. [38] D. Mostrous and N. Yoshida. A session object calculus \nfor structured communication-based programming. Submitted, 2008. [39] M. Neubauer and P. Thiemann. An \nimplementation of session types. PADL, Springer LNCS, 3057:56 70, 2004. [40] O. Nierstrasz. Regular types \nfor active objects. In Object-Oriented Software Composition, pages 99 121. Prentice Hall, 1995. [41] \nN. Nystrom, M. R. Clarkson, and A. C. Myers. Polyglot: an extensible compiler framework for Java. Compiler \nConstruction, Springer LNCS, 2622:138 152, 2003. \u00a8 [42] J. Ostlund, T. Wrigstad, D. Clarke, and B. \u00b0Ownership, \nAkerblom. uniqueness and immutability. In IWACO (ECOOP workshop), 2007. [43] B. C. Pierce. Types and \nProgramming Languages. MIT Press, 2002. [44] R. Pucella and J. A. Tov. Haskell session types with (almost) \nno class. In Proceedings, 1st ACM SIGPLAN symposium on Haskell, pages 25 36. ACM, 2008. [45] F. Puntigam. \nState inference for dynamically changing interfaces. Computer Languages, 27:163 202, 2002. [46] F. Puntigam \nand C. Peter. Types for active objects with static deadlock prevention. Fundamenta Informatic\u00e6, 49:1 \n27, 2001. [47] A. Ravara and V. T. Vasconcelos. Typing non-uniform concurrent objects. CONCUR, Springer \nLNCS, 1877:474 488, 2000. [48] R. E. Strom and S. Yemini. Typestate: A programming language concept for \nenhancing software reliability. IEEE Trans. Softw. Eng., 12(1):157 171, 1986. ISSN 0098-5589. [49] K. \nTakeuchi, K. Honda, and M. Kubo. An interaction-based language and its typing system. PARLE, Springer \nLNCS, 817:398 413, 1994. [50] A. Vallecillo, V. T. Vasconcelos, and A. Ravara. Typing the behavior of \nsoftware components using session types. Fundamenta Informatic\u00e6, 73(4):583 598, 2006. [51] V. T. Vasconcelos, \nS. J. Gay, and A. Ravara. Typecheck\u00ading a multithreaded functional language with session types. Theoret. \nComp. Sci., 368(1 2):64 87, 2006. URL http: //www.di.fc.ul.pt/~vv/papers/vasconcelos.gay.ravara: tychecking-session-types.pdf. \n[52] V. T. Vasconcelos, S. J. Gay, A. Ravara, N. Gesbert, and A. Z. Caldeira. Dynamic interfaces. FOOL, \n2009. [53] A. K. Wright and M. Felleisen. A syntactic approach to type sound\u00adness. Information and Computation, \n115(1):38 94, 1994. \n\t\t\t", "proc_id": "1706299", "abstract": "<p>Session types allow communication protocols to be specified type-theoretically so that protocol implementations can be verified by static type-checking. We extend previous work on session types for distributed object-oriented languages in three ways. (1) We attach a session type to a class definition, to specify the possible sequences of method calls. (2) We allow a session type (protocol) implementation to be <i>modularized </i>, i.e. partitioned into separately-callable methods. (3) We treat session-typed communication channels as objects, integrating their session types with the session types of classes. The result is an elegant unification of communication channels and their session types, distributed object-oriented programming, and a form of typestates supporting non-uniform objects, i.e. objects that dynamically change the set of available methods. We define syntax, operational semantics, a sound type system, and a correct and complete type checking algorithm for a small distributed class-based object-oriented language. Static typing guarantees that both sequences of messages on channels, and sequences of method calls on objects, conform to type-theoretic specifications, thus ensuring type-safety. The language includes expected features of session types, such as delegation, and expected features of object-oriented programming, such as encapsulation of local state. We also describe a prototype implementation as an extension of Java.</p>", "authors": [{"name": "Simon J. Gay", "author_profile_id": "81100039420", "affiliation": "University of Glasgow, Glasgow, United Kingdom", "person_id": "P1911097", "email_address": "", "orcid_id": ""}, {"name": "Vasco T. Vasconcelos", "author_profile_id": "81100239215", "affiliation": "University of Lisbon, Lisboa, Portugal", "person_id": "P1911098", "email_address": "", "orcid_id": ""}, {"name": "Ant&#243;nio Ravara", "author_profile_id": "81100498692", "affiliation": "University of Lisbon, Lisboa, Portugal", "person_id": "P1911099", "email_address": "", "orcid_id": ""}, {"name": "Nils Gesbert", "author_profile_id": "81436593623", "affiliation": "University of Glasgow, Glasgow, United Kingdom", "person_id": "P1911100", "email_address": "", "orcid_id": ""}, {"name": "Alexandre Z. Caldeira", "author_profile_id": "81453654288", "affiliation": "University of Lisbon, Lisboa, Portugal", "person_id": "P1911101", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706335", "year": "2010", "article_id": "1706335", "conference": "POPL", "title": "Modular session types for distributed object-oriented programming", "url": "http://dl.acm.org/citation.cfm?id=1706335"}