{"article_publication_date": "01-17-2010", "fulltext": "\n Automatic Numeric Abstractionsfor Heap-Manipulating Programs * Stephen Magill Ming-Hsien Tsai Carnegie \nMellon University NationalTaiwan smagill@cmu.edu University mhtsai208@gmail.com Abstract We present a \nlogic for relating heap-manipulating programs to nu\u00admeric abstractions. These numeric abstractions are \nexpressed as simple imperative programs over integer variables and have the property that termination \nand safety of the numeric program en\u00adsures termination and safety of the original, heap-manipulating \npro\u00adgram.Wehave implemented an automatedversionof this abstrac\u00adtion process and present experimental \nresults for programs involv\u00ading a variety of data structures. Categories and Subject Descriptors F.3.1[Logics \nand Meanings of Programs]: Logicsof Programs, MechanicalVeri.cation General Terms Languages, Reliability, \nTheory,Veri.cation Keywords shape analysis, separation logic, termination, program veri.cation, abstraction \n1. Introduction Current static analysis tools can checka widevarietyof both safety and liveness properties \nfor programs involving integer variables. Tools such asBLAST[20],SLAM[1],ARMC[29],ASTREE[15], \u00b4 SPEED \n[18] and TERMINATOR [14] all focus on this class of pro\u00adgrams.Some of these have support for pointers,but \nthe heap rea\u00adsoningis generallykeptas simpleas possibleforthegiven problem domain. Amajor challenge is \nintegrating these methods with very pre\u00adcise methods for heap analysis. Such combinations generally in\u00advolve \na large increase in complexity, both in terms of the veri.ca\u00adtionproblemandthe implementation.Inthispaper,weofferasolu\u00adtiontothisproblemintheformofalogicfor \nrelating programsthat allows a heap program to be related to a numeric program in a way thatis usefulfor \nautomatedveri.cation.The numeric programsim\u00adulatesthe original program, ensuringthat safetyandliveness \nresults * This work was partially supported by the iCAST project sponsored by the National Science Council \n(NSC), Taiwan, under the grants No. NSC96-3114-P-001-002-Y and No. NSC97-2745-P-001-001. The second and \nfourth authors were also partially supportedbyNSC grants No. NSC97\u00ad2221-E-002-074-MY3 and No. NSC98-2219-E-011-001. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n10, January 17 23, 2010, Madrid, Spain. Copyright c &#38;#169; 2010ACM978-1-60558-479-9/10/01...$10.00 \nPeter Lee Yih-Kuen Tsay Carnegie Mellon University NationalTaiwan University Peter.Lee@cs.cmu.edu tsay@im.ntu.edu.tw \nobtained by analyzing the numeric program also hold of the orig\u00adinal, heap-manipulating program. Also, \ninvariants of the numeric program can be translated into invariants of the heap program. Fi\u00adnally,the \nsimulation result also implies that bounds onvariables are preserved, which, when combined with some \nadditional instrumen\u00adtation, allows us to use the numeric program to calculate bounds on execution time \nand memory usage. The numeric program may include additional variables, called instrumentation variables, \nwhich are not present in the input pro\u00adgram. These variables track numeric properties of heap-based data \nstructures, such as the height of a tree, the maximal element in a list of integers, or the length of \na path between two points in a data structure. Generatingaproof thattwoprograms are relatedinvolves following \na separation logic approach to reasoning about the heap\u00admanipulating program and using the invariants \nthus discovered to generate appropriate commands and branches on the instrumenta\u00adtion variables. These \ncommands and branches record the connec\u00adtion between operations and conditions on pointer variables and \ncorresponding operations and conditions involving the instrumen\u00adtation variables. Our proof system speci.es \nthe conditions under which certain program transformations are sound for safety and liveness and per\u00admitsagreatdealof \nreasoningpower,allowingthe productionofnu\u00admeric abstractions for programs using complicated data structures \nthat cannot currentlybe handledby automated tools.Forthe class of programs and data structures to which \nautomated shape analyses such as [16] and [23] are applicable, we have produced an imple\u00admentation that \ncan automatically generate numeric abstractions. The implementation we obtain involves only small modi.ca\u00adtions \nto an existing shape analysis algorithm. Thus, when viewed froma static analysispointofview,this paperprovidesa \ntechnique for combining shape analyses based on separation logic with arbi\u00adtrary numerical analyses that \nrequires no re-implementation of the numericalanalysisandonlysmall modi.cationstotheshapeanal\u00adysis. Our \nimplementationisbuilt on theTHOR [24] shape analysis toolandwe demonstratethe practicalityof our approachbyproving \nsafetyand terminationofa numberofCprogramsusingavariety of numeric static analysis tools. 2. RelatedWork \nIn [22] we presented a static analysis algorithm for performing a similar translation for programs involving \nonly linked lists. The translation was used for safety reasoning and, while technically sound for termination, \nit was unusable in this context, as the nu\u00admeric programs it generated were too imprecise to allow us \nto obtain termination results for any examples. However, the biggest shortcomingisthat soundnesswasonlyshownforthespeci.canal\u00adysis \ndescribed in the paper. In contrast, the logic presented here pro\u00advidesageneral characterizationofthe \nterms under whichanumeric abstraction is sound, in much the same way that Hoare logic pro\u00advides a general \nspeci.cation of when program invariants are satis\u00ad.ed (although Hoare logic is relatively complete, whereas \nwe have not investigated completeness properties of the system presented here). This provides a general \ngoal for static analysis work such as[22]:ideallywewouldbeableto generatea numeric abstraction foranyprogramthatcanbe \nrelated byhand toanumeric program by the logic presented in this paper. In addition to de.ning this tar\u00adget, \nthe implementation developed for this paper also advances the state of the art in terms of achieving \nthis goal by providing support for automatic generation of numeric abstractions for programs us\u00ading user-de.ned \ninductive data structures and customized notions of data structure size, both of which were missing in \n[22].  In [13], an early implementation of this work is used to obtain upper bounds on allocated memory \nto enable the synthesis of hard\u00adware fromCprograms that use dynamic data structures.A means of obtaining \nnumeric abstractions forCcode that yields correct up\u00adper boundsisacrucial componentof thatwork,butis \nnot described in the paper. This is the .rst presentation of these ideas. The concept of relating two \nprograms at different levels of ab\u00adstraction is used heavily in the area of program re.nement [32]. The \nuse of this concept to automatically generate a more abstract ver\u00adsion of a program has been very successfully \napplied in predicate abstraction [1]. The goal of our work is similar,but we generate numeric programs \nover unbounded integers, which have an in.nite state space, whereas predicate abstractions are .nite-state. \nAnother approach to relating programs, based on a relational versionof Hoare logic,isgivenby Bentonin[2]andYanggivesa \nsimilar relationalversionof SeparationLogicin[33].Thegoalisto relatetwo programs when their total correctness \nproperties are the same. In our work, since we are only concerned with obtaining an over-approximation \nof the original program, the numeric program may diverge in cases where the original program terminates. \nWe also are able to get by with a logic where the annotations represent sets of states rather than relations. \nIndeed, the main goal of our work is to of.oad the relational reasoning to separate analysis tools. Our \ninstrumentation variables are similar in usage to auxiliary variables in Hoare logic [27]. Both auxiliary \nvariables and instru\u00admentation variables are not permitted to affect the values of the original variables \nnor the control .ow of the original program. The work here presents a more thorough treatment of the \nconcept of auxiliary variable, more clearly specifying how auxiliary variables may affect execution and \nhow auxiliary variables relate to existen\u00adtially quanti.ed variables. The standard rule for proof by \nauxiliary variables can be viewed as an instance of Corollary 2. Our treatmentofexistential quanti.ersis \nalsoakeydifference between this work and other work in logics for relating programs. Because we state \nsoundness in terms of simulation, we are able to use the INST-EXISTS rule, which is explained in Section \n5, Figure 11 to insert and update variables representing values that are quan\u00adti.ed in the original program. \nWe thus obtain information about how these values change without resorting to relational invariants. \nTermination proving for heap-manipulating programs has been describedin[21]and[30].Bothofthese approaches \nutilizeadiffer\u00adent shape analysis framework and [21] does not involvethe produc\u00adtion of numeric abstractions, \ninstead incorporating a rank-.nding algorithm directly in the analysis. The work in [30] does involve \nthe productionof numeric abstractions,but theyare produced from counter-example traces generated by the \ntermination analysis and used to communicate with the heap analysis, which is run only on\u00addemand. By \ncontrast, we convert an entire program to a numeric abstraction before doing anytermination analysis, \nwhich permits a looser coupling between the termination tool and the shape analy\u00adsis tool. In [7], Brotherston \net al. give a method of showing termi\u00adnation of programs using separation logic, based on the notion \nof cyclicproofs.However,theydonotgiveastatic analysiscapableof automatically generating these proofs. \nIt is also not clear that such an approach can handle cases where more complicated termination arguments, \nsuch as lexicographic orderings, are needed. In [4] a method is presented for using a separation logic \nshape analysis to prove termination. However, that work is tied to a speci.c rather weak abstract domain \nfor tracking size changes. The approach de\u00adscribed here is able to obtain much more precise information \nby tracking the actual change in data structure size rather than only the presence and direction of change. \nThe shape analysis portion of our implementation is not new and has much in common with other recent \nwork on shape analy\u00adsis with separation logic [3, 12, 17]. There has also been previous work on extending \nshape analysis with support for tracking integer properties.Changetal.haveextendedtheir approachto supportnu\u00admeric \ninvariants of data structures [11]. Calcagno et al. handle the case where arithmetic is allowed in the \ndomain of the heap [10]. For approaches based on TVLA, there is the work of Beyer et al. [5]. Rugina \ndevelops an analysis targeting balance properties of tree-shaped data structures [31]. Nguyen et al. \npresent a veri.\u00adcation condition-based procedure that can handle shape plus size properties when loop \ninvariants and pre-and post-conditions are provided [26]. However, none of these use the method described \nhereof generating numeric programs as anintermediate stepin the veri.cation process. The closestworkto \noursisthatofBoujjanietal.[6]whichgives a bi-simulation between programs manipulating singly-linked lists \nand counter automata and Habermehl et al. [19] which provides a termination result for trees by relating \ntree-manipulating programs to tree automata. By focusing on speci.c data structures, these papersareabletoobtainveryprecise \nresults.Inourwork,weobtain a simulation resultrather than bi-simulation,but the result holdsof arbitrary \ninductively-de.ned data structures. 3. Examples Consider the program in Figure 1. This C-style code performs \na left-to-right, depth-.rst traversal of the tree at root. It does this by maintaining a stack of nodes \nto be processed. The stack is implemented using a linked-list with nodes of type TreeList and initially \ncontainsasinglenodewithapointertotherootofthe tree. On each iteration, the top element of the stack is \nremoved and its children are added. Empty trees are discarded and when the entire stack is empty, execution \nterminates. There are a number of properties one might want to prove about this code. First, we might \nlike to show that it terminates. We might also be interested in obtaining a bound on the amount of memory \nallocated by the procedure. Both these questions are really questions about numeric properties of the \ncode. In the case of termination, we want to demonstrate that some rank function decreases during each \niteration. For a bound on the number of memory cells used, we can imagine adding a variable mem usage \nto the program, which is initially zero and increments each time memory is allocated and decrements each \ntime memory is freed. Wemightbe interestedin obtainingaboundonmem usage in terms of the size of the input \ntree. In this example, answering either of these questions requires some reasoning about the shape and \nsize properties of heap\u00adallocated data structures. What we show in this paper, and demon\u00adstrate in our \nexperiments, is that the shape reasoning can be sepa\u00adrated from the numeric reasoning by constructing \na numeric pro\u00adgram that explicitly tracks changes in data structure sizes. Anumeric program for this \nexample is given in Figure 2. This program can be constructed from the original using the rules in Sec\u00adtion5and \nan equivalent, though larger program canbe constructed  struct Tree { Tree left; Tree right; } struct \nTreeList { Tree tree; TreeList next; }; TreeList push(Tree r, TreeList next) { TreeList t; t = malloc(); \nt->tree = r; t->next = next; return t; } void traverse(Tree root) { TreeList stack, tail; stack = push(root,0); \nwhile(stack != 0) { tail = stack->next; if(stack->tree == 0) { // remove empty trees free(stack); stack \n= tail; } else { // process non-empty trees tail = push(stack->tree->right,tail); tail = push(stack->tree->left,tail); \nfree(stack); stack = tail; } } } Figure 1. Adepth-.rst traversal of a tree rooted atroot. automatically \nby the analysis implementation discussed in Section 7. In each case, the variables in the numeric program \ncorrespond to size properties of the data structures involved. Informally, tsize root is the number of \nnodes in the tree at root, slen is the length of the list representing the stack, and ssize is the number \nof nodes in the trees linked to by nodes in the stack, as depicted in Figure 3. ssize and slen are the \nmain integervariables presentin the program.A numberof temporary variables are then used to perform updates \nto these. These updates are sometimes non-deterministic.Forexample,in the main loop, we examine the .rst \nelement of the stack and, if it links to a non\u00adempty tree, we replace it with two nodes, each of which \nlinks to one of that tree s children. Thus, in the numeric program we must represent how removing an \nelement from the stack changes the values slen and ssize. In the case of slen, the length simply decreasesby \none.For ssize, however, the effect of removing an element is not deterministic. The most we can conclude \nis that ssize can be broken into tsize, the size of the tree linked to by the element we just removed, \nand ssize tail, the size of the remaining portion of the stack. This is accomplished by the non-deterministic \nassignments on line5 coupled with the assume statementsat lines6and7.Asimilar situation occursonline13, \nwhen we record the relationship between tsize and the sizes of the left and right children(tsize l and \ntsize r, respectively). While assume statements are not part of standard C, they are acceptedby manyveri.cation \ntools,allowingustopassthecodein Figure2directlytoARMC orTERMINATOR in orderto checkter\u00ad void traverse(int \ntsize_root) { 1: assume(tsize_root >= 0); 2: slen=1; 3: ssize = tsize_root; 4: while(slen > 0) { 5: tsize \n= ?; ssize_tail = ?; 6: assume(tsize >= 0 &#38;&#38; ssize_tail >= 0); 7: assume(ssize == tsize + ssize_tail); \n8: if(tsize == 0) // remove empty trees 9: slen--; 10 else { // process non-empty trees 11: tsize_l = \n?; tsize_r = ?; 12: assume(tsize_l >= 0 &#38;&#38; tsize_r >= 0); 13: assume(tsize == tsize_l + tsize_r \n+ 1); 14: ssize = tsize_l + tsize_r + ssize_tail; 15: slen++; } } } Figure 2. Anumeric abstraction of \nthe program in Figure 1. slen =4 nil nil Figure 3. An example showing slen and ssize used in the pro\u00adgram \nin Figure 2. slen is the number of nodes in the stack and ssize is the sum of the values in the bold \ncircles. The shaded area contains the nodes that contribute to ssize and nodes in this area are labeled \nwith the size of the subtree rooted at that node. Empty trees (denoted by nil ) have size 0. mination. \nIn this case, the termination argument involves a lexico\u00adgraphic order on ssize and slen. By producing \nnumeric abstrac\u00adtions such as that given in Figure 2, we allow ourselves and our program analysis tool \nto concentrate on the shape analysis prob\u00adlem, while leaving details of lexicographic rankings or disjunctive \nwell-foundedness [28] to other tools. We can also ask bounds analysis tools as described in [18] and \n[13] for a bound on the length of the stack. In this case, the stack can grow as long as tsize root +1 \nif the tree is maximally unbalanced. The theory presented in Section 5, coupled with an inductive description \nof a balanced tree, also allows us to obtain a numeric programthat demonstratestheexpectedlogarithmicbound \non stack length for balanced trees. Alternate Abstractions It is often the case that there are different \nnotions of data structure size. The measures used in Figure2 are fairly natural, in that the number of \nallocated heap cells is the sum of slen and ssize. If we abandon this correspondence, we can obtain the \nsimpler numeric abstraction given in Figure 4. In this case we have only one main size variable, ssize, \nwhich tracks the  void traverse(int tsize_root) { 1: assume(tsize_root > 0); 2: ssize = tsize_root; \n3: while(ssize > 0) { 4: tsize = ?; ssize_tail = ?; 5: assume(tsize > 0 &#38;&#38; ssize_tail >= 0); \n6: assume(ssize == tsize + ssize_tail); 7: if(tsize == 1) // remove empty trees 8: ssize = ssize_tail; \n9: else { // process non-empty trees 10: tsize_l = ?; tsize_r = ?; 11: assume(tsize_l > 0 &#38;&#38; \ntsize_r > 0); 12: assume(tsize == tsize_l + tsize_r + 1); 13: ssize = tsize_l + tsize_r + ssize_tail; \n} } } Figure 4. Anumeric abstractionof the programin Figure1witha different notion of ssize and tsize. \nnil nil Figure 5. An illustration of the notion of ssize used in the pro\u00adgram in Figure 4. The shaded \narea contains the nodes contributing to ssize. Empty trees (denoted by nil ) have size 1. Non-empty nodes \nare labeled with the size of the subtree rooted at that node. ssize isthesumofthevaluesinthebold circles,plus1forthe.rst \nelementin the stack, as nil has size1using this notionof size. sum of the sizes of the subtrees reachable \nthrough the stack. How\u00adever,wealterthe notionoftreesizesuchthatempty treeshavesize equal to one, as depicted \nin Figure 5. This simpli.es the termina\u00adtion argument, as there is now only a single count, ssize, which \ndecreases during every iteration. However, we lose the ability to talk about the length of the stack \nwhen computing bounds and we lose the close connection between our counts and the number of allocated \nheap cells. The technique described in this paper has the .exibility to allow either approach to numeric \nabstraction, and the implementation is not tied to any.xed notion of size. Instead, we allow the user \nto specify the de.nition of size they have in mind when running the tool. The numeric abstraction corresponding \nto the inputCprogramis then automatically generated for thatnotion of size. 4. Preliminaries In this \nsection, we de.ne our programming language, which is based onC and thus includesexplicit memory allocation \nand de\u00adallocation as well as unstructured .ow of control. 4.1 Program Syntax Figure 6 gives the syntax \nof programs. A program P isa listof labeled continuations,whichcanalsobeviewedasamappingfrom Variables \nx t . Varst Fields . Fieldst ft Labels l . L Integers n . Z i iiiiii Integer Expns e ::= x i | n | e1 \n+ e2 | e1 - e2 | e1 \u00d7 e2 Address Expns e a ::= x a | nil b aa Boolean Expns e ::= true | false |\u00ace b \n| e1 = e2 | i i bbbb e1 = e2 | e1 . e2 | e1 . e 2 tt ai Commands c ::= x := e | x := ?a | x := ?i | t \naat x1 := x2.ft | x .f t := e | x a := alloc(f1,...,fn) | free x a Continuations k ::= c;k | halt | abort \n| goto l | branch e1b . k1,...,e n b . kn end Programs P ::= l0 : k0; ... ; ln : kn Figure 6. Syntax \nof programs labels to continuations (and we will often use function syntax for P , writing P (l) for \nthe continuation labeled with l in program P ). We take the .rst location l0 to be the initial location, \nat which execution starts.Acontinuationisa branching structure consisting of conditional branches and \ncommands that update the state. At the leaves of each branching continuation, we have either a goto or \nan indication that execution should halt or abort. Commands include the standard commands forvariable \nassignment, heap lookup, heap mutation, memory allocation, and deallocation. The commands range over \nvariables drawn from the in.nite set Vars and .eld names drawn from the in.nite set Fields. We will write \nk . subterms(P ) if k is a sub-term of some continuation in the range of P .A program P is considered \nwell\u00adformed iff {l | goto l . subterms(P )}. dom(P ), where dom(P ) is the domain of P (set of labels \npre.xing continuations in P ).This ensuresthatalljumpsareto locations de.nedby P .We also write fv(P \n), fv(c), fv(e) to denote the set of free variables of the program P , command c, or expression e. Variables \nand expressions are typed, with the types drawn from the set {a, i, b} (representing addresses, integers, \nand Booleans, respectively). We assume that the set Vars contains two in.nite, disjoint subsetsVarsa \nandVarsi such thatVars = Varsa .Varsi.We do not include variables of type b in our syntax or states.We \nwrite x a to denotean elementofVarsa and x i foran elementofVarsi.We use t to stand for either a or i. \nOften, types can be inferred from the contextand,insuch cases,wewillomitthem.Wetakea similar approachtotypingofrecord \n.elds.WeassumethesetFieldscanbe partitioned into two disjoint subsets Fieldsa and Fieldsi and write fa \nfor elements of Fieldsa and f i for elements of Fieldsi.  4.2 Program Semantics The semantics is given \nin terms of transitions between states. Each non-error state includesa store paired witha heap.Formally,astore \nis a mapping from variables to their values. We require that this mapping respect types and indicate \nthis by using the notation .t to denote the function space.Afunction f is inVars .t Values iff f . Vars \n. Values andvariablesinVarsi are mapped to integers while variables inVarsa are mapped to addresses. \ndef Values= Z. Addr s . Stores def = Vars.t Values The heap is a .nite partial function from non-null \naddresses to records, which are .nite partial functions from .elds to values of the appropriate type. \nThe set Addr is assumed to be in.nite. We  SEMANTICS OF COMMANDS t [xt := et ] (s, h)= {(s[x. [et ] \ns],h)} ' [xa := ?a] (s, h)= {(s',h) | s= s[xa . v] . v . Addr} ' [xi := ?i] (s, h)= {(s',h) | s= s[xi \n. v] . v . Z} t a t aa [x1 := x2.ft ] (s, h)= {(s[x1 . (h(s(x2))) ft ],h)} if s(x2) . dom(h) a . ft . \ndom(h(s(x2))) {error} otherwise t [xa.ft := e] (s, h)= {(s, h[v.ft . ([et ] s)])} if s(xa) . dom(h) \nwhere v = s(xa) . ft . dom(h(s(xa))) {error} otherwise t1 [xa := alloc(f1 ,...,fntn )] (s, h)= t1 tn \n {(s',h') | h' -{v} = h and dom(h'(v)) = {f,...,fn } 1 ' and s= s[xa . v] and v . Addr and v . dom(h) \nand h'(v)(fti ) . Zif ti =i i ti and h'(v)(f) . Addr if ti =a} i a [free x] (s, h)= {(s, h -{s(xa)})} \nif s(x) . dom(h) .{nil}{error} otherwise Figure 7. Semantics of commands. dom(g) indicates the domain \nof function g. The notation g[x . v] indicates the function that is the same as g, except that x is mapped \nto v. The notation h[v1.f . v2] indicates the heap that is the same as h except the record at v1 maps \n.eld f to v2.We write h - X to indicate the function obtained by restricting the domain of h to dom(h) \n- X. will use the meta-variable s to represent an element of Stores and h to represent an element of \nHeaps. As with stores, the functions that serveas the denotation of records must respect types. Unlikestores, \ntheyneed not be de.ned on all elements of the domain (different heap cells may contain different sets \nof .elds). Records def Fields finValues = .t fin h . Heaps def =(Addr -{nil}) . Records We write [e t \n] for the meaning of an expression of type t . This is a function of type Stores . (Z . Addr . Bool) \nwhere Bool = {true, false}. The de.nition of [e t is standard and ia] omitted. As expected, [e ] . Zand \n[e ] . Addr, etc. The semanticsof commandsisgivenin Figure7.The command x := e is a standard assignment \nstatement, x := ?a and x := ?i are non-deterministic assignments, x1 := x2.f reads a value from a heap \ncell, and x.f := e writes a value into a heap cell. The command x := alloc(f1,...,fn) allocates a new \nuninitialized heap cell with .elds f1,...,fn. The command free x disposes of the heap cell at x. Figure8givesthe \ntransition semanticsof continuations. There are three types of states: intermediate states, .nal states, \nand goto states. Intermediate states have the form (k, (s, h)) where k is the current continuation and \n(s, h) is the current stack and heap. Final states are either error, which indicates that an error has \noccurred, or have the form .nal(s, h), which indicates that the program has terminated in the state (s, \nh). Goto states have the form goto(l, (s, h)) and indicate that execution should continue from label \nl in state (s, h). Note that at branch points, a non-determinstic choice is made among all branches whose \ncondition is satis.ed. There are no exe\u00adcution steps possible froma branch whose conditions are allfalse. \nThis makes a single-condition branch equivalent to an assume statement, and we will write assume(e);k \nas short-hand for branch e . k end. Since our source programs are written in C, we will have the property \nthat all branches in the original program are total (that is, the disjunction of the branch conditions \nis equiv\u00adalent to true). This ensures that all non-.nal states in the original program can transition. \nSEMANTICS OF CONTINUATIONS (s',h') . [c] (s, h) error . [c] (s, h) ((c;k), (s, h)) . (k, (s',h'))((c;k), \n(s, h)) . error [ei] s = true (branch ...,ei . ki,... end, (s, h)) . (ki, (s, h)) (goto l, (s, h)) . \ngoto(l, (s, h)) (halt, (s, h)) . .nal(s, h) (abort, (s, h)) . error Figure 8. Semantics of continuations. \n(k, (s, h)) . . (k, (s, h))-P-. goto(l, (s, h)) -P-(P (l), (s, h)) Figure 9. Transition relation for \nprogramP . The variables . rep\u00adresents an arbitrary execution state. Figure9givesthe semanticsof programs.The \nprogram transi\u00adtions whenever the current continuation can transition. If a state of the form goto(l, \n(s, h)) is reached, then execution proceeds with the continuation at l.  4.3 Separation Logic Our method \nfor producing numeric programs willinvolve reason\u00ading about separation logic formulae. The syntax for \nformulae is given in Figure 10. The syntax of expressions is the same as in Figure6and is not repeated \nhere. D is a set of identi.ers that are used to refer to inductively-de.ned predicates.We discuss induc\u00adtive \npredicate de.nitions in Section 4.4. The semanticsof formulaeisalsogiveninFigure10.Thespatial formula \nemp describes an empty heap. The formula x . [f1 : e1, ..., fn : en] describes a singleton heap where \nx points to a record whose f1 .eld contains e1 and so on. A heap satis.es  SYNTAX Inductive Predicates \nd .D Records . ::= E | ft : et ,. Spatial Predicates . ::= emp | x . [.] | d(ee) Separation LogicFormulae \nQ ::= eb | . | Q * Q | Q . Q |Q . Q |.x. Q SEMANTICS bb (s, h) |= e. [e] s = true (s, h) |= emp . dom(h)= \n{}(s, h) |= x . [.] . h = {(s(x),R)} where R = {(fi, [ei] s) | fi : ei . .}(s, h) |= Q1 . Q2 . (s, h) \n|= Q1 and (s, h) |= Q2 (s, h) |= Q1 . Q2 . (s, h) |= Q1 or (s, h) |= Q2 (s, h) |= Q1 * Q2 . h = h1 l \nh2 and (s, h1) |= Q1 and (s, h2) |= Q2 (s, h) |= .x. Q . there exists v . Values such that (s[x . v],h) \n|= Q Figure 10. Syntax and semantics of formulae. The relation h = h1 l h2 holds iff dom(h1) n dom(h2)= \n\u00d8 and h = h1 . h2. The notation fi : ei . . indicates that . = ...,fi : ei,... Q1 * Q2 if it is a disjoint \nunion of heaps h1 and h2 (denoted by h1 l h2)such thath1 satis.es Q1 and h2 satis.es Q2. The formula \nd(ee), where ee is a list of expressions, describes an instance of the inductivepredicate d.Weleavemore \ndetails of inductivepredicates (including their semantics) to Section 4.4.  4.4 De.ning InductivePointer \nStructures Unbounded pointer structures in our system are described induc\u00adtively using de.nitionsof the \nfollowing form.We usevector nota\u00adtion (e.g. ev)to denote a list of variables and refer to eachQi,j as \na case of predicate di. d1(ve1) = Q1,1 . ... . Q1,m1 \u00b7\u00b7\u00b7 dn(ven) = Qn,1 . ... . Qn,mn We require that \nall variables invei are distinct and that if d .D ap\u00adpears in any Qi,j then d .{d1,...,dn}. Also, fv(Qi,j \n) . vei. This speci.es a set of mutually inductive predicates. We write unrolln(Q) for the bounded expansion \nof formula Q. This is de\u00ad.ned such that unrolln(Q) is Q with each instance of di(ee) re\u00adplaced by (unroll(n-1)(Qi,1[ee/evi])) \n. ... . (unroll(n-1)(Qi,mi [ee/evi])) where Q[ee/evi] is the simultaneous substitution of each element \nof ee for the corresponding element of vei. The semantics of a formula Q containing inductive predicates \nis then de.ned such that (s, h) |= Q iffthere exists an n such that (s, h) |= unrolln(Q). As an example, \nconsider the following de.nition of a doubly\u00adlinked list segment with length n starting at heap cell \n.rst and ending at last. dll(n,prev, .rst, last, next) = emp . n =0 . .rst = next . last = prev . (.z. \n(.rst . [prev : prev, next : z])* dll(n - 1, .rst, z, last, next)) . n> 0 This states that there are \ntwo possible cases for a segment of length n. Either n =0, in which case the list is empty, or n> 0, \nin which case there is a cell at the head of the list and a tail of length n - 1. 5. Instrumented Programs \nand Numeric Abstractions The translation from heap-manipulating programs to numeric pro\u00adgrams proceeds \nvia an intermediate form that we call instrumented programs. These have the same structure as the original \nprogram and include the original program commands, as well as new com\u00admands that update a class of instrumentation \nvariables. These in\u00adstrumentation variables track changes to the values of numeric counts, such as the \nsize of a data structure, during execution of the program. The new commands are added to the instrumented \nprogram as a proof of memory safety is constructed and make use of the intermediate results of this safety \nanalysis. Once the instru\u00admented program has been constructed, the numeric abstraction is extracted from \nit by a simple syntax-directed translation. The end result is that the numeric program simulates the \noriginal program and thus is a sound abstraction for both safety and liveness prop\u00aderties. In this section, \nwe discuss the theory of instrumented pro\u00adgrams.In Section7 we describehowwe can automatethe genera\u00adtion \nof instrumented programs and thus numeric abstractions. 5.1 Instrumented Programs Figures11and12givethe \nrulesfor producingan instrumentedver\u00adsion Pbof an original program P . The instrumented program may include \ncommands that reference variables that are not present in the original program.We refer to suchvariables \nas instrumentation variables and theyplay a role similar to that of auxiliary variables in program logics \nfor concurrency[27]. Figure 12 de.nes a judgment G f Pb.V P which states that under invariants G, Pbis \nan instrumented version of P with instru\u00admentation variables in V . The invariant function G is a mapping \nfrom labels to separation logic formulae that speci.es the invari\u00adants associated with program labels. \nThe notation {Q} c {Q ' }speci.esapartial correctnesstripleand indicatesthatif (s, h) |= Q and ((s ' \n,h ' ) . [c] (s, h)) then (s ' ,h ' ) |= Q '.Types are omitted to avoid cluttering the rules,but instrumented \nprograms and continu\u00adations must satisfy the typing rulesgivenin Figure6. Notethatthe propertyofbeingavalid \ninstrumentationis de.ned with respect to program invariants G and, in the case of continua\u00adtions, with \nrespect to a precondition Q. If we view the construc\u00adtion of a proof in the system given in Figure 11 \nas proceeding in a bottom-up manner,then instrumentation proceeds in lock-step with the derivation of \na partial correctness proof of the program. The rules COMMAND and BRANCH tell us how to update the precon\u00addition \nto re.ect the results of executing an existing command, and rulesINST-ASSIGN,INST-ASSUME,INST-DISJ andINST-EXISTS \ntell us which newcommands may be added. The invariants in G and those produced during the proving of \nthe continuations that make up the program ensure that the instrumentation commands are con\u00adsistent with \nthe semantics of the program and provide a link be\u00adtween the original program and the numeric program \nthat weeven\u00adtually produce. More details on this connection can be found in the statement of soundness \nin Section 6. Akeydifference between this approach to command insertion and the auxiliaryvariable approach \nlies with theEXISTS rule. This rule tells us that if we insert an assignment x := ?, then we can remove \nan existential quanti.er on x. This may seem odd, since {.x. Q} x := ? {Q} is not a valid partial correctness \ntriple. However, inserting such a command and reasoning from the unquanti.ed formula is sound because \nour soundness result is based on simulation.To maintain soundness, we must show that if the original \nprogram can take a step, then there exists a step in the instrumented program thattakesustoa related \nstate.Thefact that the semantics of x := ? includes all possible updates to x allows us to .nd such a \nstate. More details are given in Section 6.  COMMAND GOTO HALT ABORT G(l)= Q {Q} c {Q ' } G f{Q ' } \nbk V k G f{Q} halt V halt G f{Q} abort V abort G f{Q} goto l V goto l G f{Q} (c;bk) V c;k BRANCH .i. \n(G f{Q . ei} kbiV ki) FALSE G f{Q} branch ...,ei . kbi,... end V branch ...,ei . ki,... end G f{false} \nhalt V k INST-ASSIGN INST-DISJ {Q} x := e {Q ' } G f{Q ' } bk V k G f{Q1} bk1 V k G f{Q2} bk2 V k x . \nV G f{Q} (x := e;bk) V k G f{Q1 . Q2} branch true . kb1, true . bk2 end V k INST-ASSUME INST-EXISTS STRENGTHENING \nb '' Q . e G f{Q} kbV k G f{Q} bk V kQ . Q G f{Q } bk V k x . V b . b G f{Q} branch ek end V k G f {.x. \nQ} (x := ?;kb) V k G f{Q} bk V k Figure 11. Rules for establishing that G f{Q} bk V k, read under precondition \nQ, with label invariants G, the continuation kbis an instrumented version of k with instrumentation variables \nV . dom(Pb)= dom(P ) fv(P ) n V = \u00d8 .l . dom(P ). (G f{G(l)} Pb(l) V P (l)) G f PbV P Figure 12. Rule \nfor proving that Pbis an instrumented version of P . numabsV (bk)= bk if kb.{abort, halt, goto l}numabsV \n(c;bk)= c;(numabsV (bk)) if c is x := e or x := ? and fv(x, e) . V numabsV (c;bk)= x := ?;(numabsV (bk)) \nif c is x := e and x . V and fv(e) .. V or c is x := y.f and x . V numabsV (c;bk)= numabsV (bk) otherwise \nnumabsV (branch e1 . kb1,...,en . kcn end)= branch numexpV (e1) . numabsV (kb1),..., numexpV (en) . numabsV \n(kcn) end where numexpV (e)= e if fv(e) . V true otherwise Figure13. De.nition of the function numabsV \n(bk),which converts an instrumented program to a numeric abstraction with free vari\u00adables contained in \nV .  5.2 Numeric Programs Numeric programs are the projection of the instrumented program ontoasubsetoftheinteger-valuedvariables.InFigure13we \nde.ne a function numabsV (bk) that,given an instrumented program bk and a set of variables V , produces \nthe numeric abstraction of bk over variables in V (which must all be of integer type). Because they involve \nonly integer-valued variables, numeric abstractions can be analyzed by a tool without support for the \nheap and, as shown in Section6,aproofofsafetyor terminationfromthe non-heap-aware tool guarantees safety \nor termination of the original program.  5.3 Common ReasoningPatterns We now demonstrate how the rules \nin Figure 11 may be used to insert code that expresses various facts about the behavior of numeric properties \nof data structures. Deterministic Size Changes Suppose we have the following def\u00adinition of singly-linked \nlist segments. ls(n,.rst, tail) = emp . n =0 . .rst = tail . (.z. (.rst . [next :z]) * ls(n - 1, z, tail)) \n. n> 0 and execute the code given below. 1: branch x . = nil . x := x.next; goto 1, x = nil . halt end \nAn invariant of this code at label 1 is .n1,n2,x ' . ls(n1,x ' ,x) * ls(n2, x, nil). In order to track \nhow the sizes of the segments are changing, we can generate an instrumented program for the code above. \nLet G(1) = .x ' . ls(n1,x ' ,x) * ls(n2, x, nil). Then the code below is an instrumented version of the \ncode above with instrumentationvariables n1,n2 (the assignments to n1 and n2 are added with theINST-ASSIGN \nrule). 1: branch x . = nil . x := x.next; n1 := n1 +1; n2 := n2 - 1; goto 1, x = nil . halt end Note \nthat theexistential quanti.cationis droppedin theinvariant used for the instrumented program. This is \npossible because we are now updating n1 and n2 in the body of the loop.Viewed another way, it is by committing \nto an invariant in which n1 and n2 are unquanti.ed that we are forced to write the appropriate updates \nto n1 and n2 in the body (if we update n1 or n2 incorrectly, we will not be able to reestablish G(1) \nfollowing execution of the code). Non-deterministic Size Changes Suppose we have the following de.nition \nof a binary tree. tree(h, r) = (h =0 . r = nil) . (h> 0 ..h1,h2. (h1 <h) . (h2 <h) . .lc, rc. r . [left \n: lc, right : rc] * tree(h1, lc) * tree(h2, rc))  If we now consider codefor descending through the \ntree, we can obtain update commands similar to those obtained for the linked list example above. However, \nsince h here is a bound on the height ofthetree,andtheheightofasubtreeisnotadeterministic function of \nthe height of the containing tree, we generate non-deterministic update commands. The code for performing \nthe descent is given below. We have marked with {Q} a location of interest during creation of the instrumented \nprogram. 1: branch r . = nil .{Q}branch true . r := r.left; goto 1, true . r := r.right; goto 1 end r \n= nil . halt end Let G(1) = true * (tree(h, r)) (where true is used to capture the part of the heap no \nlonger below r in the tree) and let Q ' be the formula (h> 0 . (h1 <h) . (h2 <h) ..lc, rc. r . [left \n: lc, right : rc] * tree(h1, lc) * tree(h2, rc)). Then setting Q = .h1,h2.Q ' gives us a valid instance \nof the BRANCH rule (we would also need to generate a corresponding precondition for halt). Applying the \nEXISTS rule then lets us insert the command h1 := ? and begin working from the state .h2.Q '.We then \ndo the same for h2, obtaining h2 := ? and Q '. Finally, we can use the INST-ASSUME rule to insert assume(h1 \n<h . h2 <h).1 Putting this all together with an update command for h (added via theINST-ASSIGN rule), \nwe get the instrumented programgiven below. 1: branch r . = nil . h1 := ?; h2 := ?; assume(h1 <h . h2 \n<h); branch true . r := r.left; h = h1; goto 1, true . r := r.right; h = h2; goto 1 end r = nil . halt \nend Non-deterministic assignment and assume statements are not generally present in standard C source \ncode, but they are imple\u00admented in most program analysis tools (for example, BLAST [20] has the BLAST \nNONDET construct).We can use thesefacilities to format the numeric code we generate for particular tools. \nBranch Condition Translation Letus returntothelinked-listex\u00adample from above. The instrumented code that \nwe generated sum\u00admarized how n1 and n2 were changing during each iteration. This is suf.cient, for example, \nto prove that the quantity n1 + n2 is in\u00advariant at location 1. However, we did not add any commands \nto indicate how n1 and n2 in.uence the truth of the branch condi\u00adtions. Thus, when we extract the numeric \nprogram, we will get the following, which we cannot prove terminates. 1: branch true . x := x.next; n1 \n:= n1 +1; n2 := n2 - 1; goto 1, true . halt end To obtain a more precise numeric abstraction, we need \nto replace the branch on x = nil with a branch involving n1 and n2. To accomplish this, we can use the \nI NST-ASSUME rule to insert an assumption on n2.1 The .nal instrumented program then becomes. 1: branch \nx . = nil . assume(n2 > 0); x := x.next; n1 := n1 +1; n2 := n2 - 1; goto 1, x = nil . assume(n2 = 0); \nhalt end 1Recall that assume(eb);k is an abbreviation for branch eb . k end. In this case, we have an \nexact translation of the branch condition into an assume statement involving instrumentation variables. \nIn general, however, this approach let us records assumptions that over-approximate the original program \nbranch. Inserting Branches In addition to adding assumptions after ex\u00adisting branch cases, we can also \ninsert branches at arbitrary points in the instrumented program. If we can show that our precondi\u00adtion \nQ implies (Q1 . e1) . (Q2 . e2) then we can use INST-DISJ and INST-ASSUME to insert a branch of the form \nbranch true . (assume(e1);bk1), true . (assume(e2);bk2) end. By our seman\u00ad tics, this is equivalent to \nbranch e1 . bk1,e2 . bk2 end (ignoring repeated states). Using this equivalence, we can codify the previous \ninstrumentation pattern as the following derived rule. INST-BRANCH Q . (Q1 . e1) . (Q2 . e2) G f{Q1 . \ne1} kb1 V k G f{Q2 . e2} kb2 V k G f{Q} branch e1 . kb1,e2 . kb2 end V k As branches with multiple cases \ncan be encoded using binary branches, we can also derive an n-ary version of this rule. Since Q . (Q \n. e) . (Q .\u00ace) is always derivable, we can use thistoinsertarbitrarycasesplitsintothe instrumentedprogram.We \ncan also use it to insert splits based on which case of an inductive de.nition holds. For example, suppose \nwe have the precondition ls(n, x, y) and a branch on whether x = y or x . = y. If n =0 then we know x \n= y. If n> 0 we cannot conclude anything about x and y astheycould stillbeequalifthelistiscyclic.We canmake \nthis relationship between n =0 and x = y apparent by .rst case splitting on n using the derived rule \nabove and then using FALSE to prune the branch where n =0 and x .= y.We obtain the program below, where \nwe have written {false} to highlight the location of the inconsistent case. branch n2 > 0 . branch x \n. = y . ..., x = y . ... end, n2 =0 . branch x . = y .{false} halt, x = y . ... end end 6. Soundness \nIn this section, we prove the main soundness result, which is that the numeric program simulates the \noriginal program.We then state several consequences of this theorem as it relates to particular classesof \nprogram properties.We usethe notation s = s ' mod V to indicate that .x. x .. V . s(x)= s ' (x). De.nition \n1. Let R1 V,G be the least relation on execution states satisfying the following. (k, (s, h)) RV,G k, \n(biff s = sb (bs, h)) mod V 1 `\u00b4 and .Q. G f{Q} kbV k `\u00b4 . (b= Q s, h) |goto(l, (s, h)) RV,1G s, h)) \niff s = bmod V goto(l, (bs and (b s, h) |= G(l) RV,G .nal(s, h) 1 .nal(biff s s, h) s = bmod V V,G error \nRerror 1 Theorem 1. Suppose G f PbV P and choose any l0 such that l0 . dom(P ). Let (s0,h0) |= G(l0). \nThen we have that b P with initial state (Pb(l0), (s0,h0)) stuttering simulates P with initial state \n(P (l0), (s0,h0)) and RV,G is the simulation relation  1 that witnesses this. Proof. We use the framework \nof well-founded simulations from [25] for the proof.We .rst show that initial states are related.We have \ns0 = s0 mod V and (s0,h0) |= G(l0). Since we have G f PbV P and there is only one rule for establishing \nthis, we have G f{G(l0)} Pb(l0) V P (l0) from the premises of that rule (see Figure 12). This completes \nthe proof that (P (l0), (s0,h0)) RV,G(Pb(l0), (bs0,h0)). 1 V,G For non-initial states, suppose.R1 .band \n. -P-. '.We will show that one of the following holds. ' RV,G ' 1. .b-Pb-.b' and . 1 b. 2. .b-Pb-.b' \nand .RV,1G.b'  There are additional well-foundedness conditions associated with condition2which we address \nwhen we discuss those cases. The only states that can transition are intermediate states and goto states.Weaddress \ngoto states .rst. Suppose . = goto(l, (s, h)). 1 ., we have bs, h)) and s Then, since .RV,Gb. = goto(l, \n(b= sbmod V and (b|G(l). Our program semantics gives us s, h)= . -P-(P (l), (s, h)) and b. -bP (l), (b \nP-( bs, h)). Since we have G f PbV P and there is only one rule for establishing this, we have G f{G(l)} \nPb(l) V P (l) from the premises of that rule. These are all the conditions required to establish that \nthe target states are related. We now consider the intermediate states. Let. = (k, (s, h)). Since .R1 \nV,Gb. k, (bk, b . we then have b= (bs, h)) for some bs and that there exists a Q satisfying the following \ns = sbmod V (1) (bs, h) |= Q (2) G f{Q} bk V k (3) The proof for these cases will proceed by induction \non the derivation of G f{Q} bk V k. The HALT and ABORT cases are straightforward. For GOTO we have . \n' = goto(l, (s, h)) and .b' = goto(l, (b s, h)).To show that these states are related, we must show (b \ns, h) |= G(l), which we have as a premise of the rule. ForCOMMAND we have k =(c;k ' ) and bk =(c;kb' \n). By virtue ofthefactthatthe same commandisbeingexecuted,andthat s = sbmod V and c does not contain \nvariables in V , we have that the heaps in the post-states are the same and the stacks are equal mod \nV . That (bs ' ,h) |= Q ' follows from our premise {Q} c {Q ' }.For BRANCH we have from . -P-. ' that \n[ei] s = true for some ei. b\u00d8, we have (b Since s = s mod V and fv(ei) n V = s, h) |= ei which implies \nthat Pbcan match the step. The FALSE case holds vacuously, since our assumption (2) be\u00adcomes (b= false,which \ncannot hold.For STRENGTHENING,we s, h) |have that Q . Q ' so (b= s, h) |= Q ', allowing s, h) |Q implies \n(bus to apply the inductivehypothesis to G f{Q ' } bk V k and thus obtain the result. We now turn to \nthe cases in category 2, where .b-Pb-.b' V,G and .R.b'. These are INST-ASSIGN, INST-DISJ, INST-ASSUME, \n1 and INST-EXISTS. In addition to our usual proof obligations, in these cases we must also show that \nsome well-founded measure decreases following the transition. If we take the size of b. ' to be the size \nof the term representing the current continuation, then this will be an appropriate measure. We begin \nwith INST-ASSUME. We must .rst show that bk = branch e b . kb' end allows .bto transition. This follows \nfrom the premise Q . e b, which implies(b= e b and thus [e b] b s, h) |s = true, which is the required \ncondition to establish (branch e b . bk ' k ' k ' end, (bP-(b, (b1 (b, (s, hb)) is then s, h))-bs, h)). \nThat .RV,G straightforward. For the other cases, it is easy to see that a transition.b-Pb-.b' ' exists. \nLet .b' = (bk ' , (sb,h)) (as it will have this form in all remaining cases).For INST-ASSIGN,wehaveasapremise{Q} \nx := e {Q ' }, which implies (sb' ,h) |= Q '. From (1) and the side condition x . V we have s = sb' mod \nV . Our second premise then provides the last condition required to establish .R1 V,Gb. ' . ForINST-DISJ,wemustshowthatoneofthe \nbranchesallowsthe post-state to be related to .. Since sband h are unchangedbybranch execution,weneedonlyshowthat \nthereisaQ satisfying conditions (2) and (3). We have from .RV,G.bthat (s, hb) |= . Q2, 1 Q1 which implies \n(b= or (b= we s, h) |Q1 s, h) |Q2. In either case have G f{Qi} bkiV k and .b-Pb-(bki, (s, hb)), which \nimplies V,G. ' .R1 b. The .nal case is INST-EXISTS. In this case, we must show that k ' k '' there is \nsome sbsuch that ((x := ?;bs, h)) . (bs ), (b, (b,h)) and (bs ' ,h) |s, h) |= .x. Q from our assumptions. \n= Q.We have that (bThis implies that (sb' ,h) |= Q for some sb' that is the same as sbexcept at x. The \nsemantics of x := ? ensures that (sb' ,h) is in the set [x := ?] (b s, h) and thus we have our result. \nSince the numeric program does not involve heap access com\u00admands, its semantics can be given entirely \nin terms of commands effectonthe stack.The interpretationof commandsisthenasgiven in Figure7but with \nh, which is invariant for non-heap commands, omitted. Intermediate states of the original program and \ninstru\u00admented program are then tuples (k, (s, h)) while concrete states of the numeric program have the \nform (k, s). De.nition 2. Let s = V ' sbhold iff .x . V ' .s(x)= sb(x). Let RV2' be the least relation \non states satisfying the following (k, (s, h)) R2 V ' (k ' ,s ' ) iff s = V ' s ' RV ' ' goto(l, (s, \nh)) 2 goto(l, s ' ) iff s = V ' s RV ' '' .nal(s, h) 2 .nal(s ) iff s = V ' s RV ' error error 2 Theorem \n2. Suppose P ' = numabsV ' (Pb) and choose any l0 b such that l0 . dom(Pb). Let (sb0,h0) |= G(l0). Then \nwe have ' ' b that P with initial state (P (l0),sb0) simulates P with initial state (Pb(l0), (sb0, bh0)) \nand RV2' is the simulation relation that witnesses this. Proof. The proof proceeds by induction on the \nstructure of Pb. There is a case for each branch of the de.nition of numabsV ' (bk). We need only consider \ncommands c that modify variables in V ' . We have thats1 = V ' s1 ' and must show that after executing \nc we have s2 = V ' s2 ' where s2 and s2 ' are the stores in the post-states. For c =(x := y.f) we have \na numeric command of x := ?, the semantics of which includes all possible writes into x. For c =(x := \ne) we have either x := ? or x := e as the numeric command.We have x := e only when fv(e) . V ', in which \ncase s1 = V ' s1 ' implies [e] s1 = [e] s1' , which ensures that the same value is written into x in \neach case. For branches, the reasoning is similar in that the branch condi\u00adtion is either true, which \nis an over-approximation of anybranch, or the condition is e with fv(e) . V ' which implies that the \ncon\u00addition evaluates to the same value in both the instrumented and nu\u00admeric states. The condition that \nlabels in the goto states are the same follows from thefact that goto statements are carriedoverto the \nnumeric program unchanged.  Corollary 1. If G f PbV P and P ' = numabsV ' (Pb) and P ' terminates, then \nP terminates when started from any state (P (l0), (s, h)) suchthat (s, h) |= G(l0). Proof. This follows \ndirectly from the simulation results above. Transitivity of simulation gives us that P ' simulates P \nwith pre\u00adcondition G(l0), which implies that if P ' contains only .nite traces then P must contain only \n.nite traces. The following corollary relates safety properties of the numeric program to safety properties \nof the original program by relating the program invariants. We use the notation G f P to mean that G \nspeci.es invariants of P . That is, dom(G) = dom(P ) and for all l . dom(P ) and for all s, h, if (s, \nh) |= G(l) and *' ' (P (l), (s, h))-Pgoto(l ' , (s ,h ' )) then (s ,h ' ) |= G(l ' ). We - will also \nwrite .V. (G . G ' ) to denote the function G '' with the `\u00b4 same domain as G but withG '' (l)= .V. (G(l) \n. G ' (l) . Corollary 2. If G f PbV P and P ' = numabsV ' (Pb) and G ' f P ' and fv(G ' ) . V ', then \n.V. (G . G ' ) f P . Proof. This follows from the details of the simulation relations involved. Let Pbbe \nthe instrumented program connecting P and P '. The simulation relation tells us that if a state goto(l, \n(s, h)) is reachable in a trace of P starting from some (P (l0), (s0,h0))such that (s0,h0) |= .V. G(l0), \nthen the state is RV,G-related to 1 a state goto(l, (s, hb)) in a trace of Pbwhich is then R2 V ' -related \nto a state goto(l, s ' ) in a trace of P '. That goto(l, s ' ) is reachable '' ' G ' in P and G ' f P \nimplies that s |=(l). The conditions of the relation R2 V ' and fv(G ' ) . V ' then gives us that (b= \ns, h) |G ' (l) since s ' and sbagree on the values of the variables in V ' . Finally, the R1 V,G relation \ntells us that (b s, h) |= G(l) which implies (s, hb) |= G(l) . G ' (l). That s = sbmod V then implies \nthat (s, h) |= .V. G(l) . G ' (l). In fact, the simulation relations involved ensure that if G f ' PbV \nP and P = numabsV ' (Pb) then each trace of P starting from (P (l0), (s, h)) with (s, h) |= G(l0) is \nstuttering equivalent to a trace of P ', where the equivalence identi.es states that agree on V ' - V \n. The theory of stuttering equivalence developed in [8] then gives us that P ' is a sound abstraction \nof these traces of P for all LTL-X propertiesovervariablesin V ' -V . In our implementation, V ' is chosen \nsuch that this difference includes integer variables of interest from the original program, such as variables \nwhose values we would like to bound, or for which we want to compute invariants. 7. Instrumentation Analysis \nWe will now describe how we have automated the production of instrumented programs and thus numeric abstractions. \nAs partial correctness invariants describing the heap are a required part of the proof that one program \nis an instrumentation of another, a shape analysis will be at the center of our approach and we will \nonly be able to automatically produce instrumentations of programs for which the shape analysis succeeds. \nThe shape analysis we use is of the form described in [16] and [23]. It has been implemented as an extensionof \ntheTHOR [24] shape analysis tool. Using the terminology of [16], shape analyses of this type gen\u00aderally \nhave four primary operations: 1) rearrangement, 2) abstrac\u00adtion, 3) symbolic execution, 4) entailment. \nIn order to produce nu\u00admeric abstractions, we need to make slight changes to steps 1, 2, and 4. We also \nneed a method of translating branches involving pointervariables into branchesover instrumentationvariables.We \nnow describe how to modify each of the shape analysis steps in or\u00adder to obtain an instrumentation. The \nmodi.cations are such that they do not interfere with the accuracyor convergence properties of the underlying \nshape analysis. Rearrangement In this phase, inductively-de.ned predicates are expanded with the goal \nof exposing some speci.c heap formula (oftena formula stating thata certain heap cellexists).We will \nuse the notation Q(ex) to denote a formula with free variables ex and then Q(e ) to denote the simultaneous \nsubstitution of e for ex. Given an expansion rule of the form `\u00b4 d(ex) . Q1(ex) . ... . Qn(ex) and a \nformula Q * d(e ) containing an instance of d, the analysis proceeds by reasoning from each case Q * \nQi(e ). In order to obtain an instrumentation in such a case, we require that the implication have the \nform below, where the underlined variables represent instrumentation variables. The expressions e ' i \nrecord the relation between the instrumentation variables ev, which occur as parameters to the predicate \nd and the new instrumentation variables zei, which appear in the Qi. d(ev; we) .(e1 ..ze1.e ' 1 . Q ' \n1) . ... . (en ..zen.e ' . Q ' ) nn As a concrete example, consider our list predicate, which can be \nwritten in the following form (where ze1 is empty and e1 ' = true in the .rst case). ls(n;.rst, tail) \n. n =0 . true . (emp . .rst = tail) . (n> 0) ..n ' . (n ' = n - 1) . (.z. (.rst . [next :z]) * ls(n ' \n; z, tail)) We can either provide such implications directly or, as is the case with our tool, generate \nthem from user-provided inductive de.ni\u00adtions. We can represent this reasoning by cases in the instrumented \nprogram by inserting an n-way non-deterministic branch (which can be encoded as nested binary branches \nand justi.ed with INST-DISJ).We now have the precondition Q * Qi(e ) in each case and, based on the restrictedsyntax \nabove, we know that Qi(e ) has the form ei ..zei.ei ' . Qi' . Continuing our insertion of instrumen\u00adtation \ncommands, we can use INST-ASSUME to insert assume(ei) then INST-EXISTS to insert zei := ?.We now have \na precondition of the form Q * (ei . ei ' . Q ' i) and can use INST-ASSUME again to insert assume(e ' \ni). Putting this together and simplifying the resulting program, we get the following, where bki is the \nresult of instrumenting the current continuation k starting from the precondition Q * (ei . e ' i . Qi' \n). branch ...,ei . zei ' := ?;assume(ei' );bki,... end Symbolic Execution During symbolic execution, \nwe are given the precondition Q of some command c and must compute the postcondition. This step is generally \nspeci.ed assuming that rear\u00adrangement has already revealed anyheap cells necessaryto process c. That \nis, if c is x.next = nil then Q has the form Q * (x . [next : e]). This step is unchanged, as original \nprogram commands are simply copied into the instrumentation, a process justi.ed by the COMMAND rule. \nAbstraction Abstraction corresponds to applying an implication whose right-hand side contains a single \ninstance of an inductive de.nition(therecanbeother abstractionrulesaswell,buttheseare the kind we will \nwant to instrument). Again, we require that the implication in question have the following speci.c form, \nwhere e relates ez to ev. Q(ez) ..ev. e . d(ev;we)  As a concrete example, consider the following abstraction \nrule for lists. (x . [next : y]) * ls(n ' ; y, z) . .n.n > 0 . (n = n ' + 1) . ls(n; x, z) Abstractionrulesforallthedata \nstructures consideredinourexper\u00adiments can be written in this form. Supposewehavesuchan abstractionruleandaprecondition \nQ0 to which it is applicable. That is, Q0 = Q0 ' *Q(e ) for some e . Then bySTRENGTHENING followedby \nINST-EXISTS andINST-ASSUME,we obtain the following instrumentation commands ev := ?;assume(e) and can \nproceed to reason from the precondition Q ' 0 *(d(ev; we).e). In our list example, for the precondition \n(x . [next : y]) * ls(n ' ; y, z) we would obtain the commands n := ?; assume(n> 0 . n = n ' + 1). Entailment \nIn order to determine whether the shape analysis pro\u00adcess has converged, we need to check whether the \ncurrent precon\u00addition entails an invariant that we haveseen before. This occurs, for example, when we \nprocessagoto l command.Inthis case,wewant to check whether the current formula implies another formula \nthat is already known to be in G(l). In our implementation, when this holds, the spatial portion of the \nformulas will always be syntacti\u00adcally equal up to renaming of existentially quanti.ed variables and \ninstrumentation variables. Thus, we have some .ex. Q1 and some previously discovered formula .ey. Q2 \nsuch that Q1 = s(Q2), where s is a substitution whose domain consists of ey and the in\u00adstrumentation \nvariables in Q2. Let si be the portion of s that af\u00adfects instrumentation variables. Then, for all x \n. dom(si) we add the command x := si(xb). The commands are justi.ed using the INST-ASSIGN rule. To again \nreturn to our list example, if we have ls(n2; x, nil) and are processing goto l and have previously discovered \nthat ls(n; x, nil) is an invariant at l, then we can establish this invariant from the current state \nby executing the instrumentation command n := n2. The post-condition of this command is ls(n; x, nil), \nallowing us to show that we have properly instrumented goto l using the GOTO rule. Branch Condition Translation \nBranches in the original program that only involve integer-valued variables can be carried over un\u00adchanged \nto the numeric program. However, branches that involve pointervariableswillbe abstractedbythe numabsV \n(k) function. In manycases, we can obtain good approximations of these branches in termsof instrumentationvariables.Forexample,given \nthe state ls(n; x, nil) and the condition x = nil, we can prove that this con\u00addition is equivalent to \nn =0. In the general case, given a state Q and a continuation branch ...,e . k, . . . end we want to \n.nd some e ' involving only integer variables such that Q . e . e '. We can then use the INST-ASSUME \nrule to add an assume(e ' ) command to the branch case, obtaining branch ...,e . assume(e ' );k, . . \n. end This assume(e ' ) command will then become part of the numeric program we produce. The search for \nsuch an e ' isfairly undirected, however, as the right-hand side of the implication is entirely unknown. \nIn our tool, we havefound it is easier to instead consider the equivalent formula Q .\u00ace ' .\u00ace.We canthen \nsearch for an assumption ea such that Q . ea .\u00ace. This similar to the process of abduction described \nin [9], except that we are searching for a pure, rather than spatial, assumption. This ensures that we \nhave something known on both the left and right sides of the implication, which helps to structure the \nproof search. Our translated branch condition is then \u00acea. Consider the example of ls(a; x, y) * ls(b; \ny, x) and the condi\u00adtion x . = y.This describesastateinwhichwehaveacycliclistthat x and y bothpoint into.Wewouldaskourproverto.ndan \nea such that (ls(a; x, y) * ls(b; y, x)) . ea . x = y. The discovered ea is (a = 0).(b = 0).Wethen negate \nthis to obtain (a .. = 0).(b = 0), which is an over-approximation of x . = y in the given state. In practice, \nwe .nd ea byexpanding inductive predicates on the left and recording in which cases a proof of Q .\u00ace \nsucceeds and in which itfails. The condition returned is then the condition that rules out all thefailure \ncases. 8. Experimental Results We have implemented the techniques described here in the tool THOR [24].Table1summarizes \ntheexperimental resultsofverify\u00ading safety and termination of programs that manipulate different in\u00adductivedata \nstructures.For each program, we useTHORto produce a numeric abstractionofthe original program.ThenweuseBLAST \nandARMC toverify safety andARMC-LIVE to check termina\u00adtionofthe numericabstraction.The resultsofBLAST,ARMC,and \nARMC-LIVE are all consistent with the expected results and thus we only list the timing information. \nIn these results, safety refers to memory safety of the pro\u00adgram. We can use the numeric abstraction \nproduced by THOR to show memory safetyin cases where memory safetyinvolves track\u00ading arithmetic information.Forexample, \nthe copy zip example in\u00advolves copying a list and then combining it with the original list to produce \na list of pairs. The code for combining the lists assumes that theyhave equal length and will producea \nmemoryfaultif not. Veri.cation for this example then begins by adding assert state\u00adments at each memory \naccess checking that the variable to be ac\u00adcessedis non-nil.Forexample, we might translate y := x.next; \nk to the continuation branch x = nil . abort,x .nil . y := = x.next; k end. We then run THOR on this \ncode to produce a nu\u00admeric abstraction. Some of the abort statements will have been shown to be unreachable \nby the shape analysis, but others will remain and be present in the numeric abstraction. This numeric \nprogram is then fed to a separate safety tool, such as BLAST or ARMC, which can prove that the remainingabort \nstatements are all unreachable. This implies that theyare also unreachable in the original program and \nthus the original program is memory safe. As can be seen in the lift and dfs examples, the analysis time \nfor the numeric program is sometimes quite large. This is due to the number of branches and instrumentation \nvariables that are inserted by our current implementation. Manyof these are redundant, and simplifying \nthe resulting numeric programs, either by changes to the algorithm or post-processing steps will be important \nin order to allow such an approach to scale. 9. Conclusion Wehave presenteda formal system for producing \nnumeric abstrac\u00adtions of heap-manipulating programs. The numeric abstractions de\u00adscribe how integer properties \nof data structures change during pro\u00adgram execution and can be used to reason effectively about safety, \ntermination, andvariable boundsof the original program.Infact, the numeric abstractionisa sound abstraction \nfor allLTL-X prop\u00aderties speci.edin termsof integervariables sharedbythe original program and numeric \nabstraction. We have implemented this abstraction technique as part of a shape analysis tool based on \nseparation logic that includes support for user-de.ned inductive predicates.We applied the implementa\u00adtion \nto a collection of test programs and used a variety of existing numeric analysis tools to investigate \nsafety and termination prop\u00adTable 1. The experimental results. Time is in seconds. TNA rep\u00adresents the \ntime of producing numeric abstraction. TBLAST, TARMC, and TARMC-LIVE representthetimeofverifyingthe numeric \nabstrac\u00adtionbyBLAST,ARMC, andARMC-LIVE respectively.  Program Expected Result TNA TBLAST TARMC TARMC-LIVE \nDoubly Linked Lists reverse bad unsafe 0.076 0.151 0.037 0.044 copy zip safe /terminates 4.862 0.238 \n7.674 31.683 iter sum safe /terminates 1.204 0.342 8.036 9.589 Circular Doubly-Linked Lists traverse \nsafe /terminates 1.526 0.046 0.908 1.383 delete safe /terminates 2.245 0.068 11.138 20.204 meet safe \n/diverges 0.760 0.126 1.734 0.180 Circular Linked Lists sum safe /terminates 0.827 0.065 1.621 2.582 \nadd after safe /terminates 1.072 0.061 4.846 12.342 add after loop safe /diverges 0.997 0.065 1.945 3.364 \nSkip Lists create safe /terminates 9.651 0.122 10.546 34.960 lift unsafe 10.464 0.356 5.814 971.090 .nd \nloop safe /diverges 4.431 0.106 36.860 45.709 Binary Search Trees insert safe /terminates 1.550 0.046 \n0.458 0.895 mem safe /terminates 0.573 0.042 0.387 2.690 Binary Trees dfs safe /terminates 0.780 0.042 \n0.444 3503.065 erties of these programs. The results demonstrate that generating numeric abstractions \nis a .exible and effective means of extend\u00ading the precision of shape analysis tools based on separation \nlogic. Such an approach allows reasoning about complex numeric safety and termination properties without \ncomplicating the shape analysis tool or the abstract domain on which it is based. References [1] T. Ball, \nR. Majumdar, T. Millstein, and S. Rajamani. Automatic predicate abstractionofCprograms. In PLDI, pages \n203 213.ACM Press, 2001. [2] N. Benton. Simple relational correctness proofs for static analyses and \nprogram transformations. In POPL, pages 14 25.ACM Press, 2004. [3] J. Berdine, C. Calcagno, B. Cook, \nD. Distefano, P. W. O Hearn, T.Wies, and H.Yang. Shape analysis for composite data structures. In CAV, \nLNCS 4590, pages 178 192. Springer, 2007. [4] J. Berdine, B. Cook, D. Distefano, P. W. O hearn, and Q. \nMary. Automatic termination proofs for programs with shape-shifting heaps. In CAV, pages 386 400. Springer, \n2006. [5] D. Beyer,T. A. Henzinger, and G. Th\u00b4Lazy shape analysis. eoduloz. In CAV, LNCS 4144, pages \n532 546. Springer, 2006. [6] A. Bouajjani, M. Bozga, P. Habermehl, R. Iosif, P. Moro, and T. Vojnar. \nPrograms with lists are counter automata. In CAV, LNCS 4144, pages 517 531. Springer, 2006.  [7] J. \nBrotherston, R. Bornat, and C. Calcagno. Cyclic proofs of program termination in separation logic. In \nPOPL, pages 101 112. ACM Press, 2008. [8] M. C. Browne, E. M. Clarke, and O. Gr\u00a8umberg. Characterizing \n.nite kripke structures in propositional temporal logic. Theoretical Computer Science, 59(1-2):115 131, \n1988. [9]C. Calcagno,D. Distefano,P. O Hearn,andH.Yang. Compositional shape analysis by means of bi-abduction. \nIn POPL, pages 289 300, NewYork,NY, USA, 2009.ACM. [10] C. Calcagno, D. Distefano,P.W. O Hearn, and H.Yang. \nBeyond reachability: Shape abstraction in the presence of pointer arithmetic. In SAS, LNCS 4134, pages \n182 203, 2006. [11] B.-Y. E. Chang and X. Rival. Relational inductive shape analysis. In POPL, pages \n247 260,NewYork,NY, USA, 2008.ACM. [12] B.-Y. E. Chang, X. Rival, and G. C. Necula. Shape analysis with \nstructural invariant checkers. In SAS, LNCS 4634, pages 384 401. Springer, 2007. [13] B. Cook, A. Gupta, \nS. Magill, A. Rybalchenko, J. Simsa, S. Singh, andV.Vafeiadis. Finding heap-bounds for hardware synthesis. \nIn FMCAD 09, 2009. [14] B. Cook, A. Podelski, and A. Rybalchenko. Termination proofs for systems code. \nIn PLDI,pages 415 426, NewYork, NY, USA, 2006. ACM. [15] P. Cousot, R. Cousot, J. Feret, L. Mauborgne, \nA. Min\u00b4e, D. Monniaux, and X. Rival. The ASTRE \u00b4Eanalyzer. InESOP, pages 21 30, 2005. [16] D. Distefano,P.W. \nO Hearn, and H.Yang. Alocal shape analysis based on separation logic. In TACAS, LNCS 3920, pages 287 \n302. Springer, 2006. [17]D. DistefanoandM.J.Parkinson. jStar:towards practicalveri.cation forjava. In \nOOPSLA, pages 213 226.ACM, 2008. [18] S. Gulwani, K. K. Mehra, andT. Chilimbi. SPEED: precise and ef.cient \nstatic estimation of program computational complexity. In POPL, pages 127 139,NewYork,NY, USA, 2009.ACM. \n[19] P. Habermehl, R. Iosif, A. Rogalewicz, and T. Vojnar. Proving termination of tree manipulating programs. \nIn ATVA, LNCS 4762, pages 145 161. Springer, 2007. [20] T. A. Henzinger, R. Jhala, R. Majumdar, and G. \nSutre. Lazy abstraction. In POPL, pages 58 70.ACM Press, 2002. [21] A. Loginov,T.W. Reps, andM. Sagiv. \nAutomatedveri.cationof the Deutsch-Schorr-Waite tree-traversal algorithm. In SAS, LNCS 4134, pages 261 \n279. Springer, 2006. [22] S. Magill, J. Berdine, E. M. Clarke, and B. Cook. Arithmetic strengthening \nfor shape analysis. In SAS,LNCS 4634, pages 419 436. Springer, 2007. [23] S. Magill, A. Nanevski, and \nE. M. Clarke. Inferring invariants in separation logic for imperative list-processing programs. In SPACE, \n2006. [24] S. Magill, M.-H. Tsai,P. Lee, andY.-K. Tsay. THOR:A tool for reasoning about shape and arithmetic. \nIn CAV, LNCS 5123, pages 428 432. Springer, 2008. [25] P. Manolios. Mechanical Veri.cation of Reactive \nSystems. PhD thesis,UniversityofTexasat Austin, 2001. [26] H. H. Nguyen, C. David, S. Qin, and W.-N. \nChin. Automated veri.cation of shape and size properties via separation logic. In VMCAI, pages 251 266, \n2007. [27] S. S. Owicki and D. Gries. An axiomatic proof technique for parallel programs I. Acta Informatica, \n6:319 340, 1976. [28] A. Podelski and A. Rybalchenko. Transition invariants. In LICS, pages 32 41. IEEE \nComputer Society, 2004. [29] A. Podelski and A. Rybalchenko. ARMC: the logical choice for software model \nchecking with abstraction re.nement. In PADL, LNCS 4354, pages 245 259. Springer, 2007. [30] A. Podelski, \nA. Rybalchenko, andT.Wies. Heap assumptions on demand. In CAV2008, LNCS 5123, pages 314 327. Springer-Verlag, \n2008. [31] R. Rugina. Quantitative shape analysis. In SAS, pages 228 245, 2004. [32]N.Wirth. Programdevelopmentby \nstepwise re.nement. Communi\u00adcationsof theACM, 14(4):221 227, 1971. [33] H.Yang. Relational separation \nlogic. Theoretical Computer Science, 375(1-3):308 334, 2007.   \n\t\t\t", "proc_id": "1706299", "abstract": "<p>We present a logic for relating heap-manipulating programs to numeric abstractions. These numeric abstractions are expressed as simple imperative programs over integer variables and have the property that termination and safety of the numeric program ensures termination and safety of the original, heap-manipulating program. We have implemented an automated version of this abstraction process and present experimental results for programs involving a variety of data structures.</p>", "authors": [{"name": "Stephen Magill", "author_profile_id": "81384619914", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1911073", "email_address": "", "orcid_id": ""}, {"name": "Ming-Hsien Tsai", "author_profile_id": "81418596392", "affiliation": "National Taiwan University, Taipei, Taiwan Roc", "person_id": "P1911074", "email_address": "", "orcid_id": ""}, {"name": "Peter Lee", "author_profile_id": "81100384353", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1911075", "email_address": "", "orcid_id": ""}, {"name": "Yih-Kuen Tsay", "author_profile_id": "81100486603", "affiliation": "National Taiwan University, Taipei, Taiwan Roc", "person_id": "P1911076", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706326", "year": "2010", "article_id": "1706326", "conference": "POPL", "title": "Automatic numeric abstractions for heap-manipulating programs", "url": "http://dl.acm.org/citation.cfm?id=1706326"}