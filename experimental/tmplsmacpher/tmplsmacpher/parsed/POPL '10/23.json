{"article_publication_date": "01-17-2010", "fulltext": "\n Dependent Types and Program Equivalence Limin Jia Jianzhou Zhao Vilhelm Sj\u00f6berg Stephanie Weirich Computer \nand Information Sciences Department, University of Pennsylvania {liminjia,jianzhou,vilhelm,sweirich}@cis.upenn.edu \nAbstract The de.nition of type equivalence is one of the most impor\u00adtant design issues for any typed \nlanguage. In dependently\u00adtyped languages, because terms appear in types, this de.ni\u00adtion must rely on \na de.nition of term equivalence. In that case, decidability of type checking requires decidability for \nthe term equivalence relation. Almost all dependently-typed languages require this rela\u00adtion to be decidable. \nSome, such as Coq, Epigram or Agda, do so by employing analyses to force all programs to terminate. Conversely, \nothers, such as DML, ATS, Omega, or Haskell, allow nonterminating computation, but do not allow those \nterms to appear in types. Instead, they identify a terminating index language and use singleton types \nto connect indices to computation. In both cases, decidable type checking comes at a cost, in terms of \ncomplexity and expressiveness. Conversely, the bene.ts to be gained by decidable type checking are modest. \nTermination analyses allow depen\u00addently typed programs to verify total correctness proper\u00adties. However, \ndecidable type checking is not a prerequi\u00adsite for type safety. Furthermore, decidability does not imply \ntractability. A decidable approximation of program equiva\u00adlence may not be useful in practice. Therefore, \nwe take a different approach: instead of a .xed notion for term equivalence, we parameterize our type \nsys\u00adtem with an abstract relation that is not necessarily decid\u00adable. We then design a novel set of typing \nrules that re\u00adquire only weak properties of this abstract relation in the proof of the preservation and \nprogress lemmas. This design provides .exibility: we compare valid instantiations of term equivalence \nwhich range from beta-equivalence, to contex\u00adtual equivalence, to some exotic equivalences. Categories \nand Subject Descriptors D.3.1 [Programming Languages]: Formal De.nitions and Theory General Terms Design, \nLanguages, Theory Keywords Dependent types, Program equivalence Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 10, January 17 23, 2010, Madrid, Spain. \nCopyright c &#38;#169; 2010 ACM 978-1-60558-479-9/10/01. . . $10.00 1. Introduction Dependent type systems \npromise the smooth integration of lightweight invariant checking with full program veri.ca\u00adtion. In languages \nwith dependent types, the types of a pro\u00adgram may express rich, statically-checkable properties about \nits behavior. Central in the design of a dependently-typed language is the notion of type equivalence. \nBecause types include pro\u00adgrams, type checking requires a de.nition of term equiva\u00adlence. Therefore, \ndecidable type checking requires that the term equivalence relation be decidable. Previous work has almost \nuniformly insisted on decidable type checking, and hence decidable term equivalence. Some languages, \nsuch as Coq [Coq Development Team 2009], Epi\u00adgram [McBride and McKinna 2004] or Agda [Norell 2007], do \nso by employing analysis that force all programs to ter\u00adminate. This strong requirement has the bene.t \nthat type checking implies total correctness. If a function has type t . Sy:t '. Py then one can be assured \nthat it will terminate and produce a value satisfying property P . Other languages, such as Dependent \nML [Xi and Pfenning 1999], ATS [Xi 2004], Omega [Sheard 2006] and Haskell (with GADTs [Peyton Jones et \nal. 2006]), allow diverging compu\u00adtation and sacri.ce total correctness. They retain decidable type checking \nby not allowing terms to appear in types. In\u00adstead, they identify a terminating index language (such \nas the type language in the case of Haskell) and use singleton types to connect indices to computation. \nIn each of these cases, decidable type checking comes at a cost, in terms of both complexity and expressiveness. \nRequir\u00ading all programs to terminate severely limits the generality of a programming language. Furthermore, \nthe complexity of the termination analysis can make it dif.cult for program\u00admers to understand why their \ncode does not type check. In phase-sensitive languages, singleton types lead to code du\u00adplication, as \nprograms must often be written twice, once in the computation language and again in the index language. \nMore troublesome, there is no restriction that the semantics of the index language match that of the \ncomputation lan\u00adguage: only their .rst-order values are required to agree. At the same time, the bene.ts \nto be gained by decidable type checking are modest. Although termination analyses provide stronger correctness \nguarantees, they do not need to be integrated into the type system. Partial correctness guar\u00adantees that \nare implied by type safety could be extended to total correctness where necessary by an external termination \nanalysis. Furthermore, decidability does not imply practical\u00adity. Why rule out undecidable speci.cations \na priori, when they could behave well in practice? Therefore, we design a full-spectrum, dependently-typed \n= language . ~, pronounced lambda-eek , that does not pre\u00adsuppose decidable program equivalence. This \nlanguage is both simple and expressive: not only does it include general recursive function de.nitions \nand dependent products, but it also supports indexed datatypes with elimination forms to both terms (case \nexpressions) and types (large eliminations).  Dependent type systems with undecidable type checking \nare compatible with type safety [Cardelli 1986], and have been explored before [Augustsson 1998]. We \nextend this line of work by making key design decisions that permit a simple proof of type saftey. Our \nstraightforward proof of type safety is based on standard preservation and progress lemmas and has been \nformalized in the Coq proof assistant. = An important aspect of . ~is that it is actually a family of \nlanguages because its type system is parameterized by an ab\u00adstract relation that speci.es program equivalence. \nThis three\u00adplace relation, written isEq (. , e1 , e2 ), asserts when terms e1 and e2 are equivalent in \nsome context . of assumptions about the equivalence of terms. This speci.cation of program equivalence \nis isolated from typing, and the type safety proof depends on properties of program equivalence that \nmake no reference to the type system. This separation simpli.es the type safety proof. For generality, \nwe would like weak requirements for isEq. In particular, we would like to admit call-by-value re\u00ad = specting \nequivalences, since the operational semantics of . ~is call-by-value. Surprisingly, we revised our design \nseveral times before we found one that would admit such relations. Although it is impossible to claim \nthat we have the weak\u00adest possible set of requirements, our design permits many different equivalence \nrelations: from standard \u00df-equivalence, to contextual equivalence, to some exotic equivalences. The .nest \nequivalence makes our system admit no more terms than the simply-typed lambda calculus. More surprisingly, \nequivalences based on call-by-name evaluation are also valid, as well as some exotic equivalences that \nidentify cer\u00adtain terminating and nonterminating expressions. We also have Coq proofs that show that \nall of these equivalences sat\u00adisfy the required properties. We also found that the requirements of the \npreservation proof force all valid instantiations of isEq to be undecidable. However, preservation is \nnot a necessary requirement for type safety. Any language that type checks strictly fewer pro\u00adgrams than \na type-safe language is itself type safe. Therefore, any decidable approximation of a particular notion \nof program equivalence also de.nes a type-safe language. Consequently, = . ~can be used as a template \nfor languages with both decid\u00adable and undecidable de.nitions of program equivalence. The organization \nof this paper is as follows. In Section 2 = we introduce the syntax and operational semantics of .~.We \nthen describe its type system, parameterized by the predi\u00adcate isEq in Section 3. Working through a standard \nproof of preservation and progress leads to requirements on isEq we describe those properties in Section \n4. In Section 5 we give several de.nitions of isEq that satisfy our requirements. Variations of our type \nsystem lead to stronger requirements on isEq, which we discuss in Section 6. We discuss exten\u00adsions to \nthis system and other issues in Section 7. Finally, in Sections 8 and 9 we discuss related work and conclude. \nThe Coq development1 for this paper is available online at http://www.seas.upenn.edu/~plclub/ lambda-eek/lambda-eek.tgz. \n1 Because we are dealing with potentially undecidable relations, our developments use Coq s classical \nlogic library. Terms e, u ::= x | unit | fun f (x)= e | e1 e2 |( e1 , e2 )| e. 1 | e. 2 i | Ce | case \ne of { Ci xi . ei }Values v ::= unit | fun f (x)= e |( v1 , v2 )| Cv Figure 1. Syntax ( fun f (x)= e1 \n) v2 -. e1{v2/x}{fun f (x)= e1/f } ( v1 , v2 ). 1 -. v1 ( v1 , v2 ). 2 -. v2 i.1..n Cj . Ci i.1..n case \nCj v of { Ci xi . ei }-. ej {v/xj } Figure 2. Operational semantics (excerpt)  2. A call-by-value language \n= Figure 1 presents the syntax of terms and values of . ~. Im\u00adportantly, terms do not contain typing \nannotations in order to isolate the speci.cation of isEq from the type system of = . ~. A worry is that \nisEq might distinguish between terms with syntactically different but semantically equivalent type annotations. \nTo trivially rule this out, terms do not contain = types, and . ~uses a Curry-style type system. The \nterm language includes only standard features of pro\u00adgramming languages: variables, unit, (recursive) \nfunctions, applications, binary products, projections, data constructors and case analysis. We use the \nmetavariables e and u to de\u00adnote terms and v to denote values. In a recursive function fun f (x)= e, \nthe variables f and x are bound in the body e. If f does not appear in the body of the function, then \nwe write it as .x.e. In a case expression case e of { Ci xi . eii }, the variables xi are bound within \neach of the branches ei. We use the notation e{e ' /x} for the capture-avoiding substitution of e ' for \nx in e. For simplicity, every data constructor must be of arity one and must always be applied to its \nargument. This limitation does not affect expressiveness nullary and multiargument data constructors \ncan be encoded. Throughout the paper, we assume a standard Peano encoding of natural numbers, with, for \nexample, 0 represented as Czero unit and 1 represented by Csucc (Czero unit). The boolean values true \nand false can be similarly encoded. The key rules for the small-step, call-by-value operational semantics \nappear in Figure 2. This semantics is completely standard. Importantly, applications of recursive functions \nonly step when their arguments are values.  3. A parameterized type system = We now de.ne the type system \nfor . ~. Figure 3 de.nes the necessary additions to the syntax. The judgment forms of the type system \nare summarized in Figure 4. The rules of the type system itself appear in Figures 5, 6 and 7. = The types \nof . ~are divided into proper types of kind * that classify terms directly; and indexed types of kind \n(x:t ) .* that must .rst be applied to a single term (of type t). Proper types include Unit, the type \nof the unit term, function types (x:t) . t ' and product types Sx:t. t '.Inthe latter two types, the \nvariable x is bound in t '. The result type of a function may depend on the argument value, and the type \nof the second component of a product may depend on the .rst component.  Kinds . ::= *| (x:t ) .* Types \nt, s ::= Unit | (x:t) . t ' | Sx:t. t ' | T i | t e | case e ( Tu ) of { Ci xi . ti } Signatures .:: \n= \u00b7| ., C :(x:t) . Te | ., T :(x :t) .* ~' Contexts G :: = \u00b7| G, x : t | G , e = e ~' Eq ctxs .:: = \n\u00b7| . , e = e Pure terms w ::= x | unit | fun f (x)= e |( w1 , w2 )| w. 1 | w. 2 | Cw Figure 3. Types \nand contexts Data constructors are typed by datatype constants, T , which are indexed types. The kinds \nof datatype constants and the types of data constructors are recorded by a signature .. We assume that \nthere is one .xed, well-formed signature .0 for an entire program, so we leave it implicit. We also assume \nthat all data constructors and datatype constants are in the domain of .0. For simplicity, we require \nthat all datatype constants be of kind (x:t ) .*. Standard data types use the uninfor\u00admative index unit. \nFor example, the notation Nat abbrevi\u00adates the type TNat unit, where the constant TNat has kind (x:Unit) \n.*. We use a similar de.nition for the type Bool. Often, however, the index is informative. For example, \nsuppose the constant TList is indexed by its length, a natural number. The data constructor Cnil creates \na list of type TList 0. When type checking a case analysis where the scrutinee has type TList x, the \ntype checker can assume that x is equal to 0 in the Cnil branch. The type language also includes a strong \nelimination form: case analysis of terms to produce types. In a type pat\u00adtern match, case e ( Tu ) of \n{ Ci xi . tii }, a .nite number of types ti are indexed by a term e that is expected to be of type Tu. \n(We discuss the need for this annotation in Sec\u00adtion 3.3.) This mechanism provides the technique of Uni\u00adverses \nin dependently-typed languages. For example, in a context containing the assumption x : Bool, the term \ncase x of { true . 1; false . false } can be assigned the type case x ( Bool ) of { true . Nat ; false \n. Bool } The type system is de.ned in terms of a number of as\u00adsumption lists. Besides signatures ., there \nare contexts G and equivalence contexts .. Contexts are ordered lists of variable type assumptions and \nterm equivalence assumptions. The domain of a context is the set of variables for which there are type \nassumptions. Equivalence contexts . contain term equivalence assumptions only. We denote context concate\u00adnation \nwith G , G ' when the domain of G and G ' are disjoint (likewise . , . '). We use G* to produce the equivalence \ncon\u00adtext containing the equivalence assumptions in G. Some places in the speci.cation of the type system \nrequire the de.nition of pure terms. We use the metavariable w to range over a simple set of terms that \nare known to terminate. 3.1 Parameterized equivalence: isEq = As mentioned above, the type system of \n. ~is parameterized by the predicate isEq (. , e , e ' ). This predicate holds when the terms e and e \n' are equivalent under the set of equivalence assumptions in .. Formation Judgments Equivalence Judgments \nf . Signature f . = . ' Equivalence Context f G Context f G = G ' Context G f . Kinds . f t = t ' Types \nG f t : . Types . f . = . ' Kinds G f e : t Terms Figure 4. Type system judgment forms We use isEq to \nde.ne an auxiliary relation used for type checking. The predicate incon (.) determines if there exists \na contradiction in the equivalence assumptions of ..An equivalence context . is inconsistent when isEq \nequates two pure terms headed by different constructors. DEFINITION 3.1 (Inconsistency). De.ne incon \n(.) if there exist terms Ci wi and Cj wj such that isEq (. , Ci wi , Cj wj ) and Ci = Cj . Most dependently \ntyped languages use \u00df-equivalence or \u00df.-equivalence to decide term equivalence. In our language, we leave \nisEq abstract. However, to ensure that our sys\u00adtem enjoys standard properties (such as preservation and \nprogress) isEq must itself satisfy a number of properties, as we describe in Section 4. The equivalence \nassumptions in . are equations between arbitrary terms. These terms do not need to be well-typed or even \nhave the same type (though our rules only add such assumptions to the equivalence context). Furthermore, \nthese equations do not need to be consistent, though when they are not, all terms are typeable with all \ntypes.  3.2 Typing = The type system of . ~is de.ned by two main categories of judgments (see Figure \n4). One set determines when syntac\u00adtic elements are well-formed. The other set determines when they are \nequivalent. The formation rules refer to the equiv\u00adalence rules, but the equivalence rules are independent. \nWe start our discussion with the formation rules, and return to the equivalence rules in Section 3.3. \nThe formation rules appear in Figures 5 and 6. Most rules are straightforward; we focus on the term typing \nrules. One signi.cant departure from standard rules is that we use equivalence assumptions instead of \nsubstitution. For exam\u00adple, a standard rule for application substitutes the operand e2 for the variable \nin the result type: G f e1 :(x:t1) . t2 G f e2 : t1 E_APP G f e1 e2 : t2{e2/x} = However, in . ~, instead \nof substituting the operand e2 in the result type, rule E_APP checks if t2 is equal to some t under an \nequivalence context that extends G* with the ~ equation x = e2. Furthermore, to ensure that x is not \nfree in t , the rule checks that t is well-formed under the context G. Similarly, the typing rules for \ndependent pairs, projections and constructors also extend the context with equivalence assumptions rather \nthan use explicit substitution. We use equivalence assumptions instead of substitution because substituting \ne into a type leads to stronger require\u00adments on the substitution property of isEq. Intuitively, re\u00adquiring \nthat isEq be closed under substituting an arbitrary e limits our term equivalence relations to those \nbased on call\u00adby-name evaluation. However, our system is call-by-value, leading to an undesirable mismatch. \nWe discuss this issue further in Section 6.1.  f G f G x . dom(G) G f t : * C_E C_TERM f\u00b7 f G, x : t \nf GG f e1 : t G f e2 : t C_EQ ~ f G , e1 = e2 G f . f GG, x : t f . K_TYPE K_PI G f* G f (x:t ) . . G \nf t : . f G f G T : . . .0 T_UNIT T_CST G f Unit : * G f T : . G, x : t1 f t2 : * G, x : t1 f t2 : * \n T_PI T_SIGMA G f (x :t1) . t2 : * G f Sx:t1.t2 : * G f t :(x:t1) . .1 G f e : t1 G * ~ , x = e f .1 \n= . G f . T_APP G f t e : . i.1..n G f . G f e : Tu CtrOf(T )= Ci i.1..n Ci :(xi :si ) . Tui . .0 i.1..n \n ~~ G, xi : si , u = ui , e = Ci xi f ti : . T_CASE i.1..n G f case e ( Tu ) of { Ci xi . ti } : . f \nG incon (G * ) T_INCON G f t : . G f t : . G * f . = . ' G f . ' T_KCONV G f t : . ' Figure 5. Context, \nkind, and type formation rules The typing rule for pattern-match E_CASE also uses equivalence assumptions, \nbut for a different purpose. This i.1..n rule .rst uses the premise CtrOf(T )= Ci to check that the branch \nis exhaustive. During execution, if the ith branch is taken, the scrutinee must match the pattern Ci \nxi , and the index u of the scrutinee s type must match with the index ui in the signature. Therefore, \nthis rule checks each branch un\u00adder a context that extends G with equivalence assumptions ~ that the \nindices are the same (u = ui) and that the scrutinee ~ is equal to the pattern (e = Ci xi ). = The fact \nthat .~uses equivalence assumptions instead of substitution to represent the information gained via case \n= analysis is powerful. In particular, . ~can take advantage of ~ information such as fx = true in a \nway that languages such as Coq and Agda cannot. For example, suppose we have a datatype T indexed by \nbooleans with constructors C1 : T true and C2 : T false. Then, in the following context f : Nat . Bool,x \n: Nat,h : T ( fx ) . Bool there are instantiations of isEq such that the following term typechecks case \nfx of {true . hC1; false . false} To typecheck hC1, the type checker must show the equiv\u00adalence of T \n( fx ) and T true in the .rst branch, when the G f e : t f G x : t . G f G E_VAR E_UNIT G f x : t G f \nunit : Unit G, x : t1, f :(x:t1) . t2 f e : t2 E_FIX G f fun f (x)= e :(x:t1) . t2 G f e1 :(x:t1) . t2 \nG f e2 : t1 G * , x ~= t G f t : * = e2 f t2 E_APP G f e1 e2 : t G f e1 : t1 G f e2 : t2 ' G * , x ~f \nt ' G, x : t1 : * = e12 = t2 f t2 E_SIGMA G f( e1 , e2 ) :Sx:t1.t2 G f e :Sx:t1.t2 E_PROJ1 G f e. 1: \nt1 G f e :Sx:t1.t2 G f t : * G * ~ , x = e. 1 f t2 = t E_PROJ2 G f e. 2: t C :(x:s) . Tu . .0 G f e : \ns G * ~ , x = e f Tu = t G f t : * E_CTR G f Ce : t i.1..n G f e : Tu CtrOf(T )= Ci i.1..n G f t : * \nCi :(xi :ti ) . Tui . .0 i.1..n ~~ G, xi : ti , u = ui , e = Ci xi f ei : t E_CASE i.1..n G f case e \nof { Ci xi . ei } : t f G incon (G * ) E_INCON G f e : t G f e : t G * f t G f e = t ' : t ' G f t ' \n: * E_TCONV Figure 6. Term formation rules (typing) ~ equation fx = true is available. Systems based \non uni.ca\u00adtion cannot make this information available via substitution, so they require the result of \nfx to be named.2 Note that in rule E_CASE, the order in which the equiva\u00adlence assumptions are added \nto the context is important for maintaining the well-formedness of the context. The type of e is Tu, \nand the type of Ci xi is Tui . For the extended context ~ to be well-formed, we need to insert the assumption \nu = ui ~~ before e = Ci xi , so that u = ui is available for checking that e and Ci xi have the same \ntype. The equivalence assumptions in G could become incon\u00adsistent, for example, while checking a false \nbranch in a case expression where the scrutinee is true. In that case, the as\u00ad ~ sumption true = false \nis added to the context. However, this branch is inaccessible at runtime, so there is no need to type \ncheck it. Therefore, rule E_INCON assigns an arbitrary type t to e when the equivalence assumptions in \nG are con\u00adtradictory. 2 The Agda version of this example typechecks due to some ad hoc machinery, but \nsmall variations do not.  . f . = . ' . f t = t ' KQ_REFL . f*=* . f t = t ' . f . = . ' KQ_PI . f \n(x:t) . . = (x:t ') . .' incon (.) TQ_INCON . f t = t ' TQ_UREFL . f Unit = Unit T : . . .0 TQ_TREFL \n. f T = T . f t1 = t1 ' . f t2 = t2 ' TQ_PI . f (x:t1) . t2 = (x:t1' ) . t2 ' . f t1 = t1 ' . f t2 = \nt2 ' TQ_SIGMA . f Sx:t1.t2 = Sx:t1' .t2 ' . f t = t ' isEq (. , e , e ' ) TQ_APP . f t e = t ' e ' isEq \n(. , e , e ' ) isEq (. , u , u ' ) i.1..n Ci :(xi :si ) . Tui . .0 i.1..n ~~' . , u = ui , e = Ci xi \nf ti = ti TQ_CASE i.1..n . f case e ( Tu ) of { Ci xi . ti }= i.1..n ' case e ' ( Tu ' ) of { Ci xi . \nt } i i.1..n isEq (. , e , Cj w ) Cj . Ci Cj :(xj :sj ) . Tuj . .0 ~ isEq ((. , w = xj ) , u , uj ) ~~ \n. , w = xj , e = Cj xj f tj = t TQ_RED1 i.1..n . f case e ( Tu ) of { Ci xi . ti }= t i.1..n isEq (. \n, e , Cj w ) Cj . Ci Cj :(xj :sj ) . Tuj . .0 ~ isEq ((. , w = xj ) , u , uj ) ~~ . , w = xj , e = Cj \nxj f t = tj TQ_RED2 i.1..n . f t = case e ( Tu ) of { Ci xi . ti } Figure 7. Kind and type equivalence \nThe last typing rule is a conversion rule. If e can be as\u00adsigned type t , then E_TCONV allows e to be \ngiven any well\u00adkinded type that is equivalent to t.  3.3 Equivalence Several typing rules require determining \nwhen two types are equivalent. A couple of type formation rules require kind equivalence. We present \nthese two equivalence judgments = for . ~in Figure 7. These judgments do not check well\u00adformedness. Instead, \nthe formation rules only use the equiv\u00adalence judgments on well-formed constructs. For instance, in rule \nE_TCONV, both t and t ' must be well-kinded. This de\u00adsign allows the properties of equivalence to be \nproven inde\u00adpendently of those for formation. Most of the rules are straightforward. Below, we focus \non the type equivalence rules. The type equivalence judgment has the form . f t1 = t2, where . is the \nequivalence context under which t1 and t2 are considered. The .rst rule, TQ_INCON, states that when . \nis incon\u00adsistent, any two types are equivalent. The next few rules are congruence rules stating that \ntwo types are equivalent if the corresponding sub-terms are equivalent. Rule TQ_APP uses isEq to check \nthe equivalence of the two embedded terms. The congruence rule for case types TQ_CASE checks that the \ncorresponding branches are equivalent with added assump\u00adtions that the actual index is equal to the stated \nindex of the constructor and that the scrutinee is equal to pattern for that branch. This rule must check \nnot only the equivalence of the scrutinees, but also that the indices in the scrutinees types are equal. \nBecause our equivalence rules do not depend on well-formedness rules, the only way to .nd out the type \nof the scrutinee is to annotate the case type with (Tu). The last two rules consider the situation when \na case type could reduce to one of its branches. The rule TQ_RED2 is symmetric to TQ_RED1. The .rst premise \nof TQ_RED1 checks if the scrutinee e is equal to some pure term Cj w, where Cj heads one of the patterns. \nThe rule also checks that the index u in e s type is equal to uj , which is the index of Cj xj s type. \nIf the jth branch tj is equivalent to a type t (which does not contain xj ), then we can conclude that \nthe case type is equivalent to t. Like E_CASE, TQ_RED1 extends . with the equation ~ w = xj . Additionally, \nwhen checking if tj is equal to t , both ~~ w = xj and e = Cj xj are in the context. Although the latter \nassumption is semantically redundant, not including this as\u00adsumption leads to stronger requirements for \nisEq. Another design choice is why we require a pure term Cj w in the .rst premise, instead of Cj v or \nCj e. We address this decision in Section 6.1. Our type equivalence rules are de.ned to be easily in\u00advertible. \nFor example, by examining the rules, we can con\u00adclude that there does not exist a derivation for . f \nTe = (x:t1) . t2 when . is consistent, an important property for the progress and preservation lemmas. \n 4. Properties of the type system = The type system of . ~depends on the relation isEq~(. , e1 , e2 \n). Consequently, the type safety property = of . depends on properties of this relation. In this Section, \nwe investigate the properties shown in Figure 8 that we use in the proof of the progress and preservation \nlemmas. Al\u00adthough these proofs are straightforward, we include details here to motivate each of the properties \nlisted in Figure 8. Note that these properties are independent of the type system. We make no requirements \nthat the arguments to isEq have the same type, or even have a type, or that the as\u00adsumptions in the equivalence \ncontext are well-formed in any way. Thus our parameterization is simple and well-de.ned. 4.1 Basic lemmas \nWe start with four basic properties (weakening, substitution, cut, and context conversion) that should \nhold for every judg\u00adment. Because our judgments include isEq as a hypothesis, these properties are also \nrequired for isEq (see the .rst four properties in Figure 8).  PROPERTY 4.1 (IsEq Weakening). If isEq \n((. , . '' ) , e1 , e2 ), , . '' ) , e1 , e2 ). then isEq ((. , . ' PROPERTY 4.2 (IsEq Substitution). \nIf isEq (. , e1 , e2 ), then isEq (.{w/x} , e1{w/x} , e2{w/x} ). PROPERTY 4.3 (IsEq Cut). If isEq ((. \n, u1 ~u2 , . ' =) , e1 , e2 ), and isEq (. , u1 , u2 ), then isEq ((. , . ' ) , e1 , e2 ). PROPERTY 4.4 \n(IsEq Context Conversion). If isEq (. , e1 , e2 ), and f . = . ', then isEq (. ' , e1 , e2 ). PROPERTY \n4.5 (IsEq Re.exivity). isEq (. , e , e ). PROPERTY 4.6 (IsEq Symmetry). If isEq (. , e1 , e2 ), then \n isEq (. , e2 , e1 ). PROPERTY 4.7 (IsEq Transitivity). If isEq (. , e1 , e2 ), and isEq (. , e2 , e3 \n), then isEq (. , e1 , e3 ). PROPERTY 4.8 (IsEq Injectivity). If isEq (. , Cw1 , Cw2 ), then isEq (. \n, w1 , w2 ). PROPERTY 4.9 (IsEq Beta). If e -. e ', then isEq ( \u00b7 , e , e ' ). PROPERTY 4.10 (IsEq Empty). \nIf Ci = Cj , then \u00acisEq ( \u00b7 , Ci wi , Cj wj ). Figure 8. The isEq Properties Weakening states that if \na judgment holds under context G (or .), then it also holds under a larger context. LEMMA 4.1 (Weakening). \n1. If .1 , .3 f J , then .1 , .2 , .3 f J . 2. If G1 , G3 f J , and f G1 , G2 , G3, then G1 , G2 , G3 \nf J .  The Substitution Lemma states that equivalence judg\u00adments are closed under the substitution of \npure terms and that the formation judgments are closed under the substitu\u00adtion of values. LEMMA 4.2 (Substitution). \n1. If . f J then .{w/x}f J {w/x}. 2. If G, x : t1 , G ' f J and G f v : t1 then G , G ' {v/x}f J {v/x}. \n Because our language has a call-by-value semantics, we do not need substitution to be true for arbitrary \nterms, only pure terms and values respectively. As a result, isEq need only be closed over the substitution \nof pure terms. Property 4.2 is a particularly weak requirement, as we discuss in Section 6. The Cut Lemma \nremoves redundant equivalence assump\u00adtions from the context. LEMMA 4.3 (Cut). ~'' 1. If . , e = e , . \n' f J and isEq (. , e , e ) then . , . ' f J . ~'' ) 2. If G , e = e , G ' f J and isEq (G * , e , e \nthen G , G ' f J . Finally, both the equivalence judgments and the forma\u00adtion judgments are closed under \nequivalent contexts. To state this lemma, we .rst de.ne when both sorts of contexts are equivalent. Although \nthese de.nitions are asymmetric (they always use their left argument to compare each pair) the de\u00ad.ned \nrelations are symmetric because of IsEq Context Con\u00adversion (Prop 4.4). DEFINITION 4.1 (.-Equivalence). \nf\u00b7=\u00b7 f . = . ' isEq (. , e1 , e1 ' ) isEq (. , e2 , e2 ' ) ~= . '' ~' f . , e1 = e2 , e1 = e2 DEFINITION \n4.2 (Context equivalence). CQ_EMPTY f\u00b7=\u00b7 f G = G ' G * ' f t = t CQ_TERM f G, x : t = G' , x : t ' f \nG = G ' isEq (G * , e1 , e1 ' ) isEq (G * , e2 , e2 ' ) ~'' CQ_EQ f (G , e1 = e2 ) = (G ' , e1 ~e2 ) \n= We then show that all formation judgments are stable under context equivalence, and that all equivalence \njudgments are stable under .-equivalence. LEMMA 4.4 (Context Conversion). 1. If . f J and f . = . ' then \n. ' f J . 2. If G f J and f G = G ' and f G ' then G ' f J .   4.2 Properties of type equivalence \nThe type equivalence rules shown in Figure 7 do not con\u00adtain rules for re.exivity, symmetry, or transitivity, \npermitting simple inversion. Instead, we prove the following lemmas about the equivalence judgments to \nshow that these rules are admissible. Again, to show these properties, they also must be true of isEq \n(see Properties 4.5-4.7 in Figure 8). LEMMA 4.5 (Re.). . f t = t. LEMMA 4.6 (Symm). If . f t = t ' then \n. f t ' = t . LEMMA 4.7 (Transitivity). If . f t = t ' and . f t ' = t '' then . f t = t '' . The proofs \nof re.exivity and symmetry are straightfor\u00adward, but transitivity is less so, so we show one case of \nthe proof below. This proof requires one more property of isEq that data constructors are injective for \npure terms (Prop. 4.8). To show transitivity, we must .rst generalize the statement of the lemma so that \nthe contexts of the two type equivalence derivations are not the same, but are equivalent. LEMMA 4.8 \n(Transitivity ). If . f t = t ' and . ' f t ' = '' '' t and f . = . ' then . f t = t . The proof is by \na double induction on the structure of the pair of assumed judgments; call the .rst one D and the second \none E. Consider the case where the last rule used in D is TQ_RED2 and the last rule of E is TQ_RED1. \nThen, these derivations are of the form: i.1..n Cj . Ci Cj :(xj :sj ) . Tuj . .0 ~ isEq (. , e , Cj w \n) isEq ((. , w = xj ) , u , uj ) ~~ . , w = xj , e = Cj xj f s = tj i.1..n . f s = case e ( Tu ) of { \nCi xi . ti } and i.1..n Cm . Ci Cm :(xm :sm ) . Tum . .0 '' ~ isEq (. ' , e , Cm w ) isEq ((. ' , w = \nxm ) , u , um ) . '' ~~= s ' , w = xm , e = Cm xm f tm i.1..n . ' f case e ( Tu ) of { Ci xi . ti }= \ns '  We need to show that . f s = s '. To use the induc\u00adtion hypothesis, we need to know that both E \nand D reduce using the same branch. In other words, j = m. We know that isEq (. , e , Cj w ) and isEq \n(. ' , e , Cm w ' ).Bythe Symmetry, Transitivity, and Context Conversion Properties of isEq, we conclude \nthat isEq (. , Cj w , Cm w ' ). To con\u00adtinue the proof, we must conclude either that Cj = Cm or that \n. is inconsistent, hence our de.nition of incon (.). Now suppose that j = m. To apply the induction hypoth\u00adesis, \nwe must show f (. , w ~~Cj xj ) = (. ' , w ~~ We have f . = . ' by assumption, so for these two con\u00adtexts \nto be equivalent, we need only show isEq (. , w , w ' ). We also have isEq (. , Cj w , Cj w ' ), so the \nInjectivity Prop\u00aderty (4.8) of isEq suf.ces. = xj , e = ' = xj , e = Cj xj ) ~ By applying the induction \nhypothesis, we have . , w = ~ xj , e = Cj xj f s = s '. By substituting w for xj ,we ~~s ' conclude that \n. , w = w , e = Cj w f s = (because xj is not free in ., e, s and s '). To conclude . f s = s ' , ~~ \nwe need only remove w = w and e = Cj w from the context. We already know these facts via re.exivity and \nassumption, so we use the Cut Lemma (4.3), .nishing the case. In this proof we must substitute a pure \nterm w into the judgment, not a value v. For that reason, our Substitution Lemma (4.2) on equivalence \nmust hold for pure terms.  4.3 Type safety We prove type safety for our language via standard progress \nand preservation Lemmas [Wright and Felleisen 1994]. LEMMA 4.9 (Preservation). If G f e : t and e -. \ne ', then G f e ' : t. The proof is by induction on the reduction relation. In some of the cases, the \ntyping of e ' depends on a subterm in e ' that takes a step. Those cases make yet another requirement \non isEq, the IsEq Beta Property (4.9). We use the case when e = e1 e2 and e2 -. e2 ' as an example. By \nassumption we know that G f e1 :(x:t1) . t2 G f e2 : t1 G * ~ , x = e2 f t2 = t G f t : * E_APP G f e1 \ne2 : t By the induction hypothesis, we know G f e2 ' : t1.We ~' need to show that G * , x = e2 f t2 = \nt . Because Prop\u00aderty 4.9 requires isEq to identify e2 and e2' , we know that the ~~' context G * , x \n= e2 is equivalent to the context G * , x = e2. Therefore, by using context conversion (Lemma 4.4), we \ncan ~' conclude G * , x = e2 f t2 = t. To show progress, we must .rst prove a canonical forms lemma. \nLEMMA 4.10 (Canonical Forms). Suppose \u00acincon (G * ). 1. If G f v : Unit then v is unit. 2. If G f v \n:(x:t1) . t2 then v is fun f (x)= e. 3. If G f v :Sx:t1.t2 then v is ( v1 , v2 ). 4. If G f v : Te \nthen v is Cv ' and C :(x:s) . Tu . .0.  To prove the above, we show that the type system does not equate \ntypes with different top level forms when the assumptions in the equivalence context are consistent. \nDEFINITION 4.3 (Value types). A type t is a value type if it is of the top level form Unit, Sx:s1.s2, \n(x:s1) . s2,or Te. LEMMA 4.11 (Value Type Consistency). If \u00acincon (.) and . f t1 = t2, where t1 and t2 \nare value types, then t1 and t2 have the same top-level structure. LEMMA 4.12 (Progress). If \u00b7f e : t \n, then .e ' . e -. e ' or e is a value. In the proof of this lemma we need \u00acincon ( \u00b7 ),sothe Canonical \nForms Lemma is available. Because incon (.) is de.ned in terms of isEq, we have one last requirement \non isEq (Prop 4.10). The empty context must be consistent, i.e. if Ci = Cj then \u00acisEq ( \u00b7 , Ci wi , Cj \nwj ). A straightforward application of preservation and = progress gives us the .nal result: Well-typed \n.~programs do not get stuck. THEOREM 4.1 (Type Safety). If \u00b7f e : t , then either there exists a v such \nthat e -. * v or e diverges.  5. Instantiations Having identi.ed a set of properties of isEq that are \nstrong enough to prove type safety, we now examine de.nitions of term equivalence that satisfy those \nproperties. It is not hard to see that any instantiation is undecidable: let isEqX be some instantiation \nand consider the predicate f(e)= isEqX(\u00b7, e, C1 unit). The properties require f to be nontrivial (since \nf(C1 unit) but \u00acf(C2 unit)) and respect \u00df-convertibility, so by a lambda calculus variant of Rice s theorem \n([Barendregt 1981] p.144) f is undecidable. However, we could have a decidable predicate that does not \nsatisfy the isEq properties but still allows type safety to = hold for .~. Suppose we have an instantiation \nisEqX, and consider a predicate isEqX ' which is dominated by isEqX, that is if isEqX ' returns true \nthen so does isEqX. Then any program that typechecks using isEqX ' will also typecheck using isEqX, and \ntype safety for isEqX tells us that the program will never reach a stuck state. What we are seeing here \nis the distinction between type safety and preservation/progress. Any predicate that is dominated by \none that satis.es the properties is suf.ciently weak to ensure type safety, so it is safe to use it in \na pro\u00adgramming language implementation. Such a predicate will not necessarily be strong enough to typecheck \nall the inter\u00admediate states of a computation. 5.1 Beta-equivalence Many dependently-typed languages \nuse \u00df-equivalence as the underlying equivalence of the type system. In this sec\u00adtion, we show that \u00df-equivalence \nis indeed a valid instantia\u00adtion that satis.es the properties in Figure 8. Call-by-value evaluation Some \ndependently typed lan\u00adguages test term equivalence by reducing both inputs to a normal form and then \ncomparing, so one expects this algo\u00adrithm to be a valid instantiation. Indeed it is, although we must \nadjust the de.nition slightly: because of nontermina\u00adtion we cannot reduce to normal form, so instead \nwe say that two terms are isEq if they reduce to some common term (not necessarily normal). As a result, \nthe predicate is only semide\u00adcidable because we do not know how long to evaluate. Thus we de.ne our .rst \ninstantiation, called isEq-.. DEFINITION 5.1. De.ne isEq-.(., e, e ' ) when there exists u such that \ne -. * u and e ' -. * u. LEMMA 5.1. isEq-. satis.es the isEq properties.  Note that isEq-. is the .nest \nequivalence satisfying the properties. Because we require that isEq be an equivalence relation which \nincludes -., any valid instantiation must identify at least as many terms as isEq-.. LEMMA 5.2. Let isEqX \nbe a predicate which satis.es the isEq properties. Then isEq-.(.,e,e ' ) implies isEqX(.,e,e ' ). Generalized \nreduction relations The veri.cation that isEq-. satis.es the properties does not use many speci.c facts \nabout -.. Therefore, we can state a more general result about an arbitrary reduction relation .. DEFINITION \n5.2. If . is a binary relation between expressions, then de.ne isEq.(.,e1,e2) when there exists a u such \nthat e1 u and e2 u. .* .* LEMMA 5.3. For a given relation on expressions .,if -...,  e . e ' implies \ne{w/x} . e ' {w/x},  ' ''' Ce0 . e implies that e = Ce0 and e0 . e0, and  .* is con.uent, then isEq. \nsatis.es the isEq properties.  The added generality of the above lemma shows that type safety is insensitive \nto the evaluation order used by the type checker. In particular, we can use a parallel reduction relation \nfor ., where terms are nondeterministically reduced throughout, including underneath function de.nitions \nand inside case branches. In fact, there are many valid variants of parallel reduction, based on differences \nin the \u00df rules. We identify three variants of parallel reduction below. e =. e ' Require values in active \npositions e =.w e ' Require pure terms in active positions e =.n e ' Allow arbitrary reductions Surprisingly, \nall three of these relations are sound, includ\u00ading the last variant which permits \u00df-reductions for arbitrary \nexpressions. This relation allows the type checker to iden\u00adtify ( .x.y )O and y where O is a diverging \nterm a rather strange fact since these terms are not contextually equivalent under call-by-value evaluation. \nHowever, note that deterministic call-by-name evaluation -.n, which never evaluates the argument of an \napplication, is not a valid instantiation. This relation does not contain call\u00adby-value evaluation, so \nisEq-.n does not satisfy the Beta property (4.9). Nevertheless, isEq-.n is strictly dominated by isEq=.n \n, which is a valid instantiation. This means that even though our language is CBV, it is safe to use \nCBN evaluation in the type checker. Expressivity The isEq. instantiations formally satisfy the properties \nand highlight the similarities between our system and other dependently-typed languages, but they are \nof min\u00adimal use: our type system relies on introducing equations into the context, but isEq. does not \neven look at them! This is only possible because the properties do not force isEq to make use of the \ncontext; in particular we do not require the following property: PROPERTY 5.1 (Assumption). ~ If e1 = \ne2 . . then isEq (. , e1 , e2 ). This property is not necessary for type safety, so we do not require \nit. However, it is interesting when we consider the expressivity of our type system. In fact, the equivalence \nas\u00adsumptions provide all the dependent features of our type system: if the isEq instantiation ignores \nthem, we can type no more terms than in the simply typed lambda calculus. DEFINITION 5.3. De.ne a type \nerasure function (\u00b7)o, mapping types t to simple types, as follows: (Unit)o = Unit ((x:t1) . t2)o =(t1)o \n. (t2)o (T)o = T (Sx:t1.t2)o =(t1)o \u00d7 (t2)o (t e)o =(t)o (case e ( Tu )(of { Ci xi . tii })o (ti )o if \nisEq ( \u00b7 , e , Ci w ) = Unit otherwise We write Go to denote the pointwise lifting of the erase operation \napplied to G with all of its equivalence assumptions removed. LEMMA 5.4 (Erasure). Suppose that isEq \n(. , e1 , e2 ) implies isEq ( \u00b7 , e1 , e2 ). Then G f e : t implies Go fST LC e : t o , where fST LC \nis the type system for the simply-typed lambda calculus with unit, products and datatypes.  5.2 Beta-equivalence \nwith assumptions To extend isEq-. to a relation satisfying the Assumption Property we can give a direct \ninductive de.nition and in\u00adclude enough rules to satisfy the properties: DEFINITION 5.4 (isEqFiat). De.ne \nthe relation isEqFiat (. , e1 , e2 ) as the least relation satisfying the following rules: ~ e1 = e2 \n. . e1 -. e2 isEqFiat (. , e1 , e2 ) isEqFiat (. , e1 , e2 ) isEqFiat (. , Cw1 , Cw2 ) isEqFiat (. , \nw1 , w2 ) isEqFiat (. , e1 , e2 ) isEqFiat (. , e , e ) isEqFiat (. , e2 , e1 ) isEqFiat (. , e1 , e2 \n) isEqFiat (. , e2 , e3 ) isEqFiat (. , e1 , e3 ) LEMMA 5.5. isEqFiat satis.es the isEq properties. Properties \n4.5 4.9 hold for isEqFiat by its de.nition. The properties about substitution and context operations \nare proved by easy inductions on isEqFiat (. , e , e ' ). Finally we get the Empty property for free \nsince when . is empty isEqFiat coincides with isEq-.. Just like isEq-., we can vary the evaluation relation \nused in the second rule any relation that works for isEq. also works for isEqFiat. We use the notation \nisEqFiat. for alternate versions of this relation. Like isEq-., isEqFiat-. is semidecidable. However, \nits de.nition does not suggest a particular algorithm to search for derivations.  5.3 Contextual equivalence \nwith assumptions In the previous subsections we showed that various \u00df\u00adequivalences are valid instantiations. \nOur ultimate goal, however, is to .nd the strongest equivalence we can; then an implementation can use \nanything weaker than it and be as\u00adsured of type safety. The natural instantiation to aim for then is \ncontextual equivalence. If we can show that contextual equivalence satis.es the properties, then an implementation \nwill be free to use any known technique in its equivalence\u00adchecking algorithm.  Therefore we must state \nwhat it means for two terms to be contextually equivalent in the presence of equivalence assumptions. \nWe take as our starting point the notion of CIU\u00adequivalence, which is one of many equivalent de.nitions \nof contextual equivalence [Mason and Talcott 1991]. It says that two terms are equivalent if all Closed \nInstantiations (substitutions of values for free variables) of them have the same termination behavior \nwhen Used (placed in a closed evaluation context). The one subtlety here is what evaluation relation \nwe should consider the termination behavior for. Recall that the type-equivalence rule for case will \nreduce with an open scru\u00adtinee Cw, while the operational semantics will only reduce when the scrutinee \nis a closed value Cv. The isEq pred\u00adicate is part of typechecking, so it is the former behavior that \nis relevant; for instance we must not identify the stuck terms C1 (( .x.x ). 1) and C2 (( .x.x ). 1) \neven though they are contextually equivalent under CBV reduction. Therefore, we de.ne a CBW variant of \nthe evaluation relation, which we write -.w. This relation is exactly the same as -. except that it replaces \nall vs with terminal ws. For example, the \u00df rule reads: w2 -.w ( fun f (x)= e1 ) w2 -.w e1{w2/x}{fun \nf (x)= e1/f } In the de.nition of contextual equivalence, we use the -.w relation and let the substitutions \nrange over ws. Note that this subtlety is only for stuck terms. For well\u00adtyped terms, it does not matter \nwhether we use -. or -.w, the same terms will be equated. Therefore, we are justi.ed in considering this \na CBV contextual equivalence. DEFINITION 5.5. De.ne e . if there exists u such that e -. * w u and not \nu -.w u ' for any u ' . Now de.ne evaluation contexts in the standard manner. DEFINITION 5.6 (Evaluation \ncontexts). E ::= D | E e | v E |( E, e )|( v ,E )| E. 1 i | E. 2 | C E | case E of { Ci xi . ei } DEFINITION \n5.7 (CBV Contextual Equivalence). De.ne isEqC ( e1 , e2 ) iff .E, .d such that d maps variables to ws, \nif E [ de1 ] and E [ de2 ] are closed then E [ de1 ] . iff E [ de2 ] .. As one might expect, isEqC satis.es \nthe isEq properties. However, it does not make any use of the equivalence con\u00adtext. The key idea to generalize \nthe de.nition is to restrict what substitutions should be considered, i.e. if the context contains the \nequivalence e1 ~e2, we should only consider = substitutions that make e1 and e2 equal. We thus introduce \na new judgment . f d (pronounced d respects . ) as follows. DEFINITION 5.8 (Equivalence respecting substitution). \n. f d isEqC ( de1 ,de2 ) ~ \u00b7f d .,e1 = e2 f d We de.ne two expressions to be equivalent under an equivalence \ncontext . if they have the same behavior for all substitutions that respect the context. DEFINITION 5.9 \n(CBV Contextual Equiv. with Assumptions). De.ne isEqCA (. , e1 , e2 ) iff .E, .d such that d maps vari\u00adables \nto ws, if E [ de1 ] and E [ de2 ] are closed and . f d then E [ de1 ] . iff E [ de2 ] .. Exotic Instantiations \nExotic Instantiations isEqCA ( x .O , x , O' ) isEqFiat.n ( x . y , (.z.x) O, y ) isEqFiat. ( x . y \n, x , y ) isEqC ( . , O, O' ) isEq.n ( . , (.x.x) O ,O ) isEq. ( . , (.x.x) 1 , 1 ) Figure 9. Inclusions \nbetween the instantiations Note that under this de.nition, if O is some nonterminat\u00ad ~ ing expression \nthen the equivalence context x =O is incon\u00adsistent. No d can reconcile x and O,so isEqCA will equate \nall terms compared under this context. Yet this behavior is appropriate for a call-by-value language. \nWe can use it to give arbitrary types to expressions such as ( .x.3)O or C O or ( O , false ). 2, but \nall of these expressions will diverge. LEMMA 5.6. The relation isEqCA satis.es the isEq properties. It \nis straightforward to show that isEqCA is an equiva\u00adlence relation. It also satis.es the Beta Property \nbecause -.w includes -.. The proofs for the rest of the properties rely on two techniques: the proofs \nof the Weakening, Cut, Substitu\u00adtion and Context Conversion properties follow from proofs of the analogous \nproperties for . f d; the proofs of the Injectivity and Empty properties follow from carefully con\u00adstructed \nevaluation contexts. Finally, we prove the following lemma to show that isEqCA does make use of the assumptions \nin the . context. ~ LEMMA 5.7. If e1 = e2 . ., then isEqCA (. , e1 , e2 ).  5.4 Exotic Instantiations \nThe relation isEqCA is a strong instantiation, strictly coarser than isEqFiat. But it is not the limit \nwe have already seen that isEq=.n can safely identify terms that are not contextu\u00adally equivalent. In \nfact, the isEq properties place very weak restrictions on what terms may be identi.ed, the only nega\u00adtive \nstatements are Empty and Injectivity, and they only ap\u00adply when both terms are of the form Cw. Therefore, \ngiven a valid isEq instantiation, we can cre\u00adate another coarser one by merging two of its equivalence \nclasses, as long as the two classes do not contain pure terms headed by different constructors. For instance, \ncontextual equivalence considers all diverging terms to be equal and certainly no diverging expression \nis a constructor value, so we can create a coarser instantiation by also saying that any nonterminating \nterm is equal to the integer constant 3 (and all additional equivalences forced by transitivity). Of \ncourse, we could also make it equal to 4 but we had better not do both, since then transitivity would \nmake 3 and 4 equal. This example shows that while there is a weakest valid instantiation, isEq-., there \nis no strongest one. Figure 9 summarizes the ordering of the various instantiations we have discussed \nas a Hasse diagram.  6. Variations Different versions of our typing rules lead to different re\u00adquirements \nfor isEq, which in turn affects what instantia\u00adtions of isEq are valid. In this section, we present variations \n= to . ~ s type system, show how they lead to stronger proper\u00adties for isEq, and discuss how that affects \ninstantiations.  6.1 Values, pure terms or terms A few rules have .exibility about whether some component \nmust be a value, a pure term, or an unrestricted term. Al\u00adthough the last is the most permissive, we \nhave chosen in some cases to restrict to pure terms to weaken the substitu\u00adtion requirement for isEq. \nFor example, consider the type equivalence rule TQ_RED1 in Figure 7. The .rst precondition requires the \nscrutinee to be equal to a constructor applied to a pure term. Possible alternatives allow the argument \nto the constructor to be an arbitrary expression, or require it to be a value. If we had used an arbitrary \nexpression, then the proof of transitivity in Section 4.2 would require the stronger proper\u00adties shown \nbelow: PROPERTY 6.1 (Impure Substitution). If isEq (. , e1 , e2 ), then isEq (.{e/x} , e1{e/x} , e2{e/x} \n). PROPERTY 6.2 (Impure Empty). If Ci = Cj , then \u00acisEq ( \u00b7 , Ci ei , Cj ej ). Unfortunately, instantiations \nof isEq that are based on CBW-evaluation, such as isEqBeta=.w or isEqCA do not satisfy these properties \nbecause they are not closed un\u00adder substitution of arbitrary terms. For example, if O is a diverging \nterm, then ( .x.z ) y is equivalent to z under isEqBeta=.w and isEqCA, but ( .x.z )O is not. Further, \nalthough isEqBeta=.w trivially satis.es Impure Empty, isEqCA does not; all contexts identify Ci O and \nCj O ' . Alternatively, if we require the scrutinee to be equivalent to some constructor value,i.e. Cj \nv, then we would limit the expressiveness of the type system. For example, the case type case C1 y (Tu) \nof{C1 x1 . Nat | C2 x2 . Bool } cannot be shown equivalent to Nat. = Finally, the syntactic categorization \nof pure terms in . ~can be viewed as a very weak and conservative termination analysis. However, unlike \nCoq or Agda, a complex termi\u00adnation analysis only slightly increases the expressiveness of = . ~ s term \nlanguage, and only in terms of type convertibil\u00ad = ity. For instance, if . ~were to use Coq s termination \nchecker in the above example where y is replaced by (factorial n), the type would still be equivalent \nto Nat. 6.2 Substitution versus equivalence assumptions As we discussed in Section 3.2, some of our \ntyping rules diverge from standard practice in that, instead of substitu\u00adtion, they add equivalence assumptions \nto the context. We have designed our rules in this manner for two reasons. One reason is that we can \nmake the E_CASE rule more expres\u00adsive by using equations. A second reason is that stating rules with \nsubstitution requires a stronger substitution property for isEq. With the the alternate E_APP rule in \nSection 3.2, isEq would need to be closed under the substitution of re\u00adlated expressions inside related \nexpressions. PROPERTY 6.3 (Equivalent substitution). If isEq (. , e1 , e2 ), and isEq (. , e , e ' ), \nthen isEq (.{e/x} , e1{e/x} , e2{e ' /x} ). The reason for this property is the need to show a stronger \nsubstitution property for type equivalence . f t{e2/x}=t{e2' /x} in the case of the preservation lemma \nwhen e is an application e1 e2 and e2 -. e2' . Our previous proof required a weaker lemma that substituted \nthe same pure term throughout the judgment. We could modify the de.nitions of isEqFiat to satisfy the \nEquivalent Substitution Property. However, Property 6.3 im\u00adplies Impure Substitution Property (Property \n6.1); therefore, neither isEq-. nor isEqCA satis.es it. These two examples show two different axes: whether \nCBW-respecting relations are allowed and whether the equivalence must be stronger than re.exivity for \nbinders, e.g. is .x.e equivalent to .x.e ' when e reduces to e '. It is possi\u00adble to design the type \nsystem that interpolates between these two requirements, requiring a pure equivalent substitution property, \nby maintaining the invariant that only ws are ever substituted in terms. Then isEq=.w satis.es the pure \nequiv\u00adalent substitution, but isEq-. does not since it does not re\u00adduce under the binder. However, we \nprefer the simplicity of the current system.  7. Extensions = We have simpli.ed the design of . ~in \na few ways so that we can focus on its novel features. Here, we discuss exten\u00adsions that would make it \nmore practical as a programming language. = Polymorphism For simplicity, . ~is not polymorphic. Adding \nHaskell-style higher-order polymorphism [Jones 1995] would require straightforward changes to the language. \nAnother simple extension is .rst class\u00adpolymorphism, as in Curry-style System F [Girard 1972]. (Note \nthat type checking for Curry-style System F is also un\u00addecidable [Wells 1999].) In both cases, type abstraction \nand application would be implicit as we do not wish to include types in the syntax of terms. Adding abstractions \nto the type language, such as in F., would require more signi.cant changes. In particular, our de.nition \nof type equivalence would have to be extended to include \u00df-equivalence for these abstractions. A kind-directed \nspeci.cation, which retains the easy inversions of our current de.nition of type equivalence seems possible, \nbut we leave this extension to future work. Church-style type system For reasons discussed in Sec\u00ad = \ntion 2, .~does not include typing annotations in expres\u00adsions. As a result, the type system can assign \nmultiple non\u00adequivalent types to the same expressions. Given the dif.culty of complete type inference \nfor dependently-typed languages, a practical source language would include annotations to guide type \ninference and eliminate ambiguity. = An extension to . ~with type annotations would take the form of \nan external language that elaborates to and is de.ned = by . ~typing derivations. This external language \nwould be free to use any type inference technology available for elab\u00ad = oration. As long as elaboration \nproduces valid . ~typing derivations, this external language is type safe. In particu\u00adlar, ideas from \nthe design of ICC* [Barras and Bernardo 2008] seem relevant. Type-directed term equivalence Our design \ndecision that the properties of isEq should not refer to the type system means that isEq cannot receive \nany typing information from the type checker, such as type annotations embedded in the terms, or the \ntypes of the two terms, or a typing context. Therefore, certain type-directed equivalence algorithms \n[Co\u00adquand 1991, Stone and Harper 2000], which use type infor\u00admation to provide stronger extensionality \nproperties, cannot be used for isEq. However, in a call-by-value language with nontermination, .-equivalences \nare restricted: .x.ex is not equivalent to e because e could diverge. Instead, this equiv\u00adalence only \nholds for pure terms. Therefore, it is not clear how to extend type-directed equivalences to this setting. \n Termination analysis ~Because we do not enforce termi\u00ad = nation, every type in . is inhabited. Therefore \ninterpret\u00ading types as logical formulas gives an inconsistent logic diverging terms are bogus proofs. \nNevertheless, in a CBV language, type safety alone im\u00adplies useful properties. For example, if a program \nhas type Sx:Nat. lessThan x 5 then type safety tells us that if the program terminates the result will \nbe less than 5, because a bogus proof in the second component of the pair would cause the program to \ndiverge. Thus the type serves as a partial correctness assertion, although not in the standard sense. \nHowever, this style of reasoning only works for proper\u00adties that can be witnessed by a .rst-order data \ntype. If the type contains an implication, e.g. Sx:Nat. ( lessThan 23 . lessThan x 5), we cannot conclude \nmuch since the proof may be a function that diverges when applied. Adding a termination analysis (as \na separate analysis) would remove these limitations. Furthermore, a termination analysis would provide \na sig\u00adni.cant source of program optimizations. In a dependently\u00adtyped program, many terms are the encodings \nof proofs that are needed for the program to type check, but otherwise do not affect the actual result \nof computation. Some lan\u00adguages [Coq Development Team 2009, Barras and Bernardo 2008, Mishra-Linger and \nSheard 2008] distinguish between computational and proof terms, allowing the latter to be erased prior \nto execution. This erasure leads to signi.cant gains in performance. However, such optimization must \nnot change the termi\u00adnation behavior of the program. In a call-by-value language, computationally irrelevant \ncode can be erased only if it ter\u00adminates. For example, even if x is not free in e2, let x = e1 in e2 \nis only equivalent to e2 if e1 is known to terminate. An in.nite loop that prevents the program state \nfrom reach\u00ading a stuck computation should not be removed.  8. Related work The past decade has seen \nmuch research in the design of dependently-typed programming languages, including Cayenne [Augustsson \n1998], Epigram [McBride and McK\u00adinna 2004], Omega [Sheard 2006], PIE [Vytiniotis and Weirich 2007], DML \n[Xi and Pfenning 1999], ATS [Xi 2004], DML re\u00adformulated [Licata and Harper 2005], GURU [Stump et al. \n2009], ConCoqtion [Fogarty et al. 2007], Delphin [Poswol\u00adsky and Sch\u00fcrmann 2008], and Ynot [Nanevski \net al. 2008]. A number of proof assistants, such as Agda [Norell 2007] and Coq [Coq Development Team \n2009], have also suc\u00adcessfully been used as dependently-typed languages [Leroy 2006, Oury and Swierstra \n2008]. We do not attempt to survey this vast .eld here. Instead, we only describe aspects of the most \nrelated systems. = Parameterized equivalence Like, .~, Dependent ML (DML) [Xi and Pfenning 1999] is a \nfamily of dependently\u00adtyped languages. Types in DML depend not on terms, but on elements of some index \nlanguage L, a parameter to the system. This constraint language must include booleans and . a binary \nfunction = s which must return a boolean for ev\u00adery sort of the language. The constraint relation f; \nPP|= P , which states when proposition P about L is derivable from assumptions, is likewise a parameter \nto the system. This re\u00adlation must satisfy a number of regularity rules, somewhat analogous to the isEq \nproperties in Figure 8. Xi points out that this constraint relation may be undecidable, but discour\u00adages \nundecidable instances of it. However, because DML is phase-sensitive, the index lan\u00adguage L is not the \ncomputation language, and is not compu\u00adtationally relevant. Therefore, there is no analogue of Prop\u00aderty \nIsEqBeta for the constraint relation as the index language is never evaluated. To program in DML, singleton \ntypes must be used to make a connection between the index language and computations, leading to redundancy. \nOu et al. [2004] also axiomatize an equivalence judgment on terms in the context of a dependent type \nsystem that include general recursion and mutable reference. To ensure decidability of type checking, \nthey restrict the terms in types to only pure terms prede.ned constants and applications involving pure \nterms. Therefore, their types may not depend on user-de.ned functions and their axioms do not include \nProperty IsEq Beta. Pattern matching with dependent types Languages that support dependently-typed pattern \nmatching, such as Epi\u00adgram, Coq and Agda, typically specify the rules for pattern matching using some \nvariant of uni.cation to represent the static information gained during case analysis. Of these languages, \nAgda s speci.cation of pattern match\u00ading is the most sophisticated [Norell 2007]. Agda uses uni.\u00adcation \nto match the index of the scrutinee s type and the in\u00addex of the pattern s type. The uni.cation algorithm \nwill sim\u00adply give up when the uni.cation is hard; for instance, uni\u00adfying a function application with \na term. As a result, Agda s type checking algorithm is not substitutive; uni.cation be\u00adtween a variable \ny and an arbitrary term always succeeds, however after substituting fx for y, the uni.cation algo\u00adrithm \nmight fail. In our system, instead of solving a uni.\u00adcation problem, we add the assumption that the indices \nare = equivalent in the context. Consequently, . ~is substitutive. There are some languages that use \nequivalence assump\u00adtions to specify dependently-typed case analysis. A notable example is Altenkirch \nand Oury s core dependently-typed = language .S [Altenkirch and Oury 2008]. Like .~, type = checking \nin .S is undecidable. However, .S differs from . ~in that its type system uses \u00df-equivalence as the term \nequiv\u00adalence relation. Likewise, some speci.cations of generalized algebraic datatypes (GADTs, aka guarded \nrecursive datatypes) use equivalence assumptions [Xi et al. 2003, Pottier and R\u00e9gis-Gianas 2006]. GADTs \nadd index equivalences (but not scruti\u00adnee/pattern equivalences) to the context when type checking pattern \nmatching. In these settings, the index language is re\u00adstricted so that there is an effective algorithm \nfor using these assumptions during type checking. As a result of this restric\u00adtion, this speci.cation \nis no more expressive than one that uses uni.cation. Nontermination in types Few dependently typed lan\u00adguages \nallow general recursive functions to appear in types. Cayenne and .S do, but as far as we know no results, \nsuch as type safety, have been proven about them. Cardelli s Type:Type language [Cardelli 1986] allows \nnon\u00adtermination and has a type safety proof based on denota\u00adtional semantics. However, the proof does \nnot handle case\u00adexpressions and dependent elimination. The type system bakes in \u00df.-equivalence as the \nterm equivalence relation.  9. Conclusion In this paper, we have explored the trade-off between de\u00adcidable \ntype checking and the complexity of the design of = . ~, an expressive, dependently-typed language. Because \nwe have not insisted in the former, we are able to give a simple = speci.cation to . ~, despite its advanced \nfeatures, that per\u00admits straightforward, modular proof of type safety. We view this simplicity as a contribution \nof our approach. The second contribution of our work is the uniformity of semantics. Although many different \ninstantiations of isEq are valid, we have worked hard to ensure that isEqCA is one of them. Therefore, \nthe same semantics can be used to reason about the program both statically and dynamically. The .nal \ncontribution of our design is its generality.We = can view .~with isEqCA as an ideal goal for the design \nof a dependently-typed language, much as System F is an ideal model of a polymorphic functional language. \nOf course, we = can never implement a complete type checker for . ~with isEqCA; the problem is undecidable. \nWe can however, spec\u00adify and implement complete type checkers for decidable sub\u00adlanguages, as any equivalence \ndominated by isEqCA de\u00ad.nes a type safe language.  Acknowledgments Thanks to IFIP WG 2.11, IFIP WG 2.8, \nand Penn PLClub for discussion. Assistance in typesetting and formalizing this work was provided by OTT \n[Sewell et al. 2007], LNgen [Ay\u00addemir and Weirich 2009], and Coq [Coq Development Team 2009]. This project \nwas supported by NSF awards 0702545, 0715936, 0910786 and DARPA CSSG Phase II.  References Thorsten \nAltenkirch and Nicolas Oury. PiSigma: A core language for dependently typed programming. Draft, 2008. \nLennart Augustsson. Cayenne a language with dependent types. In Proc. 3rd ACM Symp. on Principles of \nProgramming Languages (ICFP), pages 239 250, 1998. Brian Aydemir and Stephanie Weirich. LNgen: Tool support \nfor lo\u00adcally nameless representations. Submitted for publication, Octo\u00adber 2009. H. P. Barendregt. The \nlambda calculus : Its syntax and semantics. North-Holland Pub. Co., 1981. Bruno Barras and Bruno Bernardo. \nThe Implicit Calculus of Con\u00adstructions as a programming language with dependent types. In Proc. of the \n11th International Conf. on Foundations of Software Science and Computational Structures (FoSSaCS), pages \n365 379, 2008. Luca Cardelli. A polymorphic lambda-calculus with type:type. Tech\u00adnical Report SRC Research \nReport 10, Digital Equipment Corpo\u00adration Systems Research Center, May 1986. The Coq Development Team. \nThe Coq Proof Assistant Reference Manual (Version 8.2), 2009. URL http://coq.inria.fr. Thierry Coquand. \nAn algorithm for testing conversion in Type Theory. In G\u00e9rard Huet and Gordon Plotkin, editors, Logical \nFrameworks, pages 255 277, 1991. Seth Fogarty, Emir Pasalic, Jeremy Siek, and Walid Taha. Concoqtion: \nindexed types now! In ACM SIGPLAN 2007 Workshop on Partial Evaluation and Program Manipulation (PEPM), \npages 112 121, 2007. Jean-Yves Girard. Interpr\u00e9tation fonctionelle et \u00e9limination des coupures de l arithm\u00e9tique \nd ordre sup\u00e9rieur. PhD thesis, Universit\u00e9 Paris VII, 1972. Mark P. Jones. A system of Constructor Classes: \nOverloading and implicit higher-order polymorphism. J. Funct. Program., 5(1):1 35, 1995. Xavier Leroy. \nFormal certi.cation of a compiler back-end or: pro\u00adgramming a compiler with a proof assistant. In Proc. \n33rd ACM Symp. on Principles of Programming Languages (POPL), pages 42 54, 2006. Daniel R. Licata and \nRobert Harper. A formulation of Dependent ML with explicit equality proofs. Technical Report CMU-CS-05\u00ad178, \nCarnegie Mellon University Dept. of Computer Science, 2005. Ian A. Mason and Carolyn L. Talcott. Equivalence \nin Functional Languages with Effects. J. Funct. Program., 1(3):287 327, 1991. C McBride and J McKinna. \nThe view from the left. J. Funct. Program., 14(1):69 111, 2004. Nathan Mishra-Linger and Tim Sheard. \nErasure and polymorphism in Pure Type Systems. In Proc. of the 11th International Conf. on Foundations \nof Software Science and Computational Structures (FoS-SaCS), pages 350 364, 2008. Aleksandar Nanevski, \nGreg Morrisett, Avraham Shinnar, Paul Gov\u00adereau, and Lars Birkedal. Ynot: dependent types for imperative \nprograms. In Proc. 13th ACM Symp. on Principles of Programming Languages (ICFP), pages 229 240, 2008. \nUlf Norell. Towards a practical programming language based on depen\u00addent type theory. PhD thesis, Chalmers \nUniversity, 2007. Xinming Ou, Gang Tan, Yitzhak Mandelbaum, and David Walker. Dynamic typing with dependent \ntypes. In IFIP International Con\u00adference on Theoretical Computer Science, pages 437 450, 2004. Nicolas \nOury and Wouter Swierstra. The power of Pi. In Proc. 13th ACM Symp. on Principles of Programming Languages \n(ICFP), pages 39 50, 2008. Simon L. Peyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, and Geoffrey \nWashburn. Simple uni.cation-based type inference for GADTs. In Proc. 11th ACM Symp. on Principles of \nProgramming Languages (ICFP), pages 50 61, 2006. Adam Poswolsky and Carsten Sch\u00fcrmann. Practical programming \nwith higher-order encodings and dependent types. In Proc. of the 17th European Symp. on Programming (ESOP), \npages 93 107, 2008. Fran\u00e7ois Pottier and Yann R\u00e9gis-Gianas. Strati.ed type inference for generalized \nalgebraic data types. In Proc. 33rd ACM Symp. on Principles of Programming Languages (POPL), pages 232 \n244, 2006. Peter Sewell, Francesco Zappa Nardelli, Scott Owens, Gilles Peskine, Thomas Ridge, Susmit \nSarkar, and Rok Strni a. Ott: Effective Tool Support for the Working Semanticist. In Proc. 12th ACM Symp. \non Principles of Programming Languages (ICFP), pages 1 12, 2007. T. Sheard. Type-level computation using \nnarrowing in Oomega. In The 1st workshop on Programming Languages meets Program Veri.ca\u00adtion (PLPV), \npages 105 128, 2006. Chris Stone and Robert Harper. Deciding type equivalence in a lan\u00adguage with singleton \nkinds. In Proc. 27th ACM Symp. on Principles of Programming Languages (POPL), pages 214 227, 2000. Aaron \nStump, Morgan Deters, Adam Petcher, Todd Schiller, and Timothy Simpson. Veri.ed programming in Guru. \nIn Proc. of the 3rd workshop on Programming Languages meets Program Veri.cation (PLPV), pages 49 58, \n2009. Dimitrios Vytiniotis and Stephanie Weirich. Dependent types: Easy as PIE. In 8th Symp. on Trends \nin Functional Programming, 2007. Joe B. Wells. Typability and type checking in System F are equivalent \nand undecidable. Annals of Pure and Applied Logic, 98(1 3):111 156, 1999. Andrew K. Wright and Matthias \nFelleisen. A Syntactic Approach to Type Soundness. Information and Computation, 115:38 94, 1994. Hongwei \nXi. Applied type system. In Proceedings of TYPES 2003, Lecture Notes in Computer Science, pages 394 408. \n2004. Hongwei Xi and Frank Pfenning. Dependent types in practical pro\u00adgramming. In Proc. 26th ACM Symp. \non Principles of Programming Languages (POPL), pages 214 227, 1999. Hongwei Xi, Chiyan Chen, and Gang \nChen. Guarded recursive datatype constructors. In Proc. 30th ACM Symp. on Principles of Programming Languages \n(POPL), pages 224 235, 2003.  \n\t\t\t", "proc_id": "1706299", "abstract": "<p>The definition of type equivalence is one of the most important design issues for any typed language. In dependently typed languages, because terms appear in types, this definition must rely on a definition of term equivalence. In that case, decidability of type checking requires decidability for the term equivalence relation.</p> <p>Almost all dependently-typed languages require this relation to be decidable. Some, such as Coq, Epigram or Agda, do so by employing analyses to force all programs to terminate. Conversely, others, such as DML, ATS, &#937;mega, or Haskell, allow nonterminating computation, but do not allow those terms to appear in types. Instead, they identify a terminating index language and use singleton types to connect indices to computation. In both cases, decidable type checking comes at a cost, in terms of complexity and expressiveness.</p> <p>Conversely, the benefits to be gained by decidable type checking are modest. Termination analyses allow dependently typed programs to verify total correctness properties. However, decidable type checking is not a prerequisite for type safety. Furthermore, decidability does not imply tractability. A decidable approximation of program equivalence may not be useful in practice.</p> <p>Therefore, we take a different approach: instead of a fixed notion for term equivalence, we parameterize our type system with an abstract relation that is not necessarily decidable. We then design a novel set of typing rules that require only weak properties of this abstract relation in the proof of the preservation and progress lemmas. This design provides flexibility: we compare valid instantiations of term equivalence which range from beta-equivalence, to contextual equivalence, to some exotic equivalences.</p>", "authors": [{"name": "Limin Jia", "author_profile_id": "81323491757", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1911092", "email_address": "", "orcid_id": ""}, {"name": "Jianzhou Zhao", "author_profile_id": "81435599390", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1911093", "email_address": "", "orcid_id": ""}, {"name": "Vilhelm Sj&#246;berg", "author_profile_id": "81447602937", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1911094", "email_address": "", "orcid_id": ""}, {"name": "Stephanie Weirich", "author_profile_id": "81100093135", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1911095", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706333", "year": "2010", "article_id": "1706333", "conference": "POPL", "title": "Dependent types and program equivalence", "url": "http://dl.acm.org/citation.cfm?id=1706333"}