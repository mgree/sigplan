{"article_publication_date": "01-17-2010", "fulltext": "\n Decision Procedures for Algebraic Data Types with Abstractions Philippe Suter Mirco Dotta Viktor Kuncak \n* School of Computer and Communication Sciences (I&#38;C) -Ecole Polytechnique F\u00b4erale de Lausanne (EPFL), \nSwitzerland \u00b4 ed\u00b4 {.rstname.lastname}@ep..ch Abstract We describe a family of decision procedures that \nextend the de\u00adcision procedure for quanti.er-free constraints on recursive alge\u00adbraic data types (term \nalgebras) to support recursive abstraction functions. Our abstraction functions are catamorphisms (term \nal\u00adgebra homomorphisms) mapping algebraic data type values into values in other decidable theories (e.g. \nsets, multisets, lists, inte\u00adgers, booleans). Each instance of our decision procedure family is sound; \nwe identify a widely applicable many-to-one condition on abstraction functions that implies the completeness. \nComplete in\u00adstances of our decision procedure include the following correctness statements: 1) a functional \ndata structure implementation satis.es a recursively speci.ed invariant, 2) such data structure conforms \nto a contract given in terms of sets, multisets, lists, sizes, or heights, 3) a transformation of a formula \n(or lambda term) abstract syntax tree changes the set of free variables in the speci.ed way. Categories \nand Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; F.3.1 [Logics and \nMeaning of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams General Terms Algorithms, \nLanguages, Veri.cation 1. Introduction Decision procedures for proving veri.cation conditions have seen \ngreat practical success in recent years. Systems using such decision procedures incorporated into SMT \nprovers [16, 6, 4] were used to verify tens of thousands of lines of imperative code [14, 3] and prove \ncomplex correctness conditions of imperative data structures [67, 50]. While much recent work on automation \nwas invested into imperative languages, it is interesting (50 years after [44]) to con\u00ad sider the reach \nof such decision procedures when applied to func\u00adtional programming languages, which were designed with \nthe ease of reasoning as one of the explicit goals. Researchers have explored the uses of advanced type \nsystems to check expressive properties [19, 66], and have recently also applied satis.ability modulo \nthe\u00adory solvers to localized type system constraints [29, 59]. Among * This research is supported in \npart by the Swiss National Science Founda\u00adtion Grant Precise and Scalable Analyses for Reliable Software \n. Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n10, January 17 23, 2010, Madrid, Spain. Copyright c &#38;#169; 2010 ACM 978-1-60558-479-9/10/01. . . \n$10.00 the recognized bene.ts of theorem provers is ef.cient support for propositional operators and \narithmetic. Our paper revives another direction where theorem provers can play a prominent role: com\u00adplete \nreasoning about certain families of functions operating on al\u00adgebraic data types. We embrace a functional \nlanguage both as the implementation language and as the speci.cation language. In fact, our properties \nare expressed as executable assertions. Among the immediate ben\u00ade.ts is that the developer need not learn \na new notation for prop\u00aderties. Moreover, the developers can debug the properties and the code using \npopular testing approaches such as Quickcheck [13] and bounded-exhaustive testing [10, 23]. In using \nthe programming lan\u00ad guage as the speci.cation language, our work is in line with soft typing approaches \nthat originated in untyped functional languages [12], although we use ML-like type system as a starting \npoint, fo\u00ad cusing on properties that go beyond the ML types. Purely functional implementations of data \nstructures [52] present a well-de.ned and interesting benchmark for automated reasoning about functional \nprograms. Data structures come with well-understood speci.cations: they typically implement ordered or \nunordered collections of objects, or maps between objects. To express the desired properties of data \nstructures, we often need a rich set of data types to write speci.cations. In particular, it is de\u00adsirable \nto have in the language not only algebraic data types, but also .nite sets and multisets. These data \ntypes can be used to con\u00adcisely specify the observable behavior of data structures with the desired level \nof under-speci.cation [32, 39, 70, 18]. For example, if neither the order nor the repetitions of elements \nin the tree matter, an appropriate abstract value is a set. An abstract description of an add operation \nthat inserts into a data structure is then a(add(e, t)) = {e}. a(t) (1) Here a denotes an abstraction \nfunction mapping a tree into the set of elements stored in the tree. Other variants of the speci.cation \ncan use multisets or lists instead of sets. An important design choice is how to specify such mappings \na between the concrete and abstract data structure values. A popular approach [14, 67] does not explicitly \nde.ne a mapping a but in\u00adstead introduces a fresh ghost variable to represent the values a(t). It then \nuses invariants to relate the ghost variable to the concrete value of the data structure. Because developers \nexplicitly specify values of ghost variables, such technique yields simple veri.cation conditions. However, \nthis technique can impose additional annota\u00adtion overhead for the tree example above it would require \nsupply\u00ading a set as an additional argument to each algebraic data type con\u00adstructor. To eliminate this \noverhead and to decouple the speci.ca\u00adtion from the implementation, we use recursively de.ned abstrac\u00adtion \nfunctions that compute the abstract value for each concrete data structure. As a result, our veri.cation \nconditions contain user\u00adde.ned function de.nitions that manipulate rich data types, along with equations \nand disequations involving such functions. Our goal is to develop decision procedures that can reason \nabout interesting fragments of such a language.  We present decision procedures for reasoning about \nalgebraic data types with user-de.ned abstraction functions expressed as a fold, or catamorphisms [46], \nover algebraic data types. These deci\u00ad sion procedures subsume approaches for reasoning about algebraic \ndata types [53] and add the ability to express constraints on the ab\u00ad stract view of the data structure. \nWhen using sets as the abstract view, our decision procedure can naturally be combined with deci\u00adsion \nprocedures for reasoning about sets of elements in the presence of cardinality bounds [36, 33]. It also \npresents a new example of a theory that .ts in the recently described approach for combining decision \nprocedures that share sets of elements [65]. Our decision procedures are not limited to using sets as \nan abstract view of data structures. The most important condition for applicability is that the notion \nof a collection has a decidable theory in which the fold can be expressed. This includes in particular \narrays [11], multisets with cardinality bounds [55, 56], and even option types over integer elements. \nEach abstract value provides different possibilities for de.ning the fold function. We believe that we \nhave identi.ed an interesting region in the space of automated reasoning approaches, because the technique \nturned out to be applicable more widely than we had expected. We intended to use the technique to verify \nthe abstraction of values of functional data structures using sets. It turned out that the approach works \nnot only for sets but also for lists and multisets, and even for abstractions that encode the truth-values \nof data structure in\u00advariants. Beyond data structures used to implement sets and maps, we have found \nthat computing bound variables, a common opera\u00adtion on the representations of lambda terms and formulas, \nis also amenable to our approach. We thus expect that our decision pro\u00adcedure can help increase the automation \nof reasoning about opera\u00adtional semantics and type systems of programming languages. Contribution. This \npaper presents a family of decision proce\u00addures for the quanti.er-free theory of algebraic data types \nwith dif\u00adferent fold functions (sections 4 and 5). We establish the soundness of the decision procedures, \nand provide suf.cient conditions on the fold function that guarantee the completeness of the decision \nproce\u00addure (Section 5). The intuition behind the completeness condition is to require the inverse image \nof the fold to have suf.ciently large cardinality for suf.ciently large abstract values (Section 5.3). \nWe list several examples of interest that satisfy this condition. 2. Example Figure 1 shows Scala [51] \ncode for a partial implementation of a set of integers using a binary search tree. The class hierarchy \nsealed abstract class Tree private case class Leaf() extends Tree private case class Node(left:Tree, \nvalue:E, right:Tree) extends Tree describes an algebraic data type Tree with the alternatives Node and \nLeaf. The use of the private keyword implies that the alterna\u00adtives are not visible outside of the module \nBSTSet. The keyword sealed means that the hierarchy cannot be extended outside of the module. The module \nBSTSet provides its clients with functions to create empty sets and to insert elements into existing \nsets. Because the client has no information on the type Tree, they use the abstrac\u00adtion function content \nto view these trees as sets. The abstraction function is declared like any other function and is executable, \nbut we assume that it obeys a syntactic restriction to make it a tree fold, as described in the next \nsection. Functions empty and add are annotated with postconditions on which the client can rely, without \nknowing anything about their object BSTSet {type E = Int type C = Set[E] sealed abstract class Tree private \ncase class Leaf() extends Tree private case class Node(left: Tree, value: E, right: Tree) extends Tree \n// abstraction function def content(t: Tree): C = t match { case Leaf() . Set.empty case Node(l,e,r) \n. content(l) ++ Set(e) ++ content(r) } // returns an empty set def empty: Tree = { Leaf() } ensuring \n(res . content(res) == Set.empty) // adds an element to a set def add(e: E, t: Tree): Tree = (t match \n{ case Leaf() . Node(Leaf(), e, Leaf()) case t @ Node(l,v,r) . if (e < v) Node(add(e, l), v, r) else \nif (e == v) t else Node(l, v, add(e, r)) }) ensuring (res . content(res) == content(t) ++ Set(e)) // \nuser-de.ned equality on abstract data type (congruence) def equals(t1 : Tree, t2 : Tree) : Boolean = \n(content(t1) == content(t2)) } Figure 1. A part of a binary search tree implementation of a set concrete \nimplementation. These postconditions do not give any in\u00adformation about the inner structure of binary \nsearch trees such in\u00adformation would be useless to a user who has no access to the inter\u00adnal structure. \nInstead, the postconditions express properties on their result in terms of the abstraction function. \nThe advantages of such an abstraction mechanism are well-known. By separating the spec\u00adi.cation (functions \nsignatures and contracts) from the implementa\u00adtion, developers obtain better opportunities for code reuse, \nmanual proofs become simpler [24], and automated analysis of clients be\u00ad comes more tractable [32]. The \nparametrized type Set[E], accessed through the type alias C and used in the abstraction function and \nthe speci.cations, refers to the Scala library class for immutable sets. The operator ++ com\u00adputes a \nset consisting of the union of two sets, and the constructor Set(e) constructs the singleton set {e} \n(containing containing the element e). We assume the implementation of the container library to be correct, \nand map the container operations (e.g. ++) to the cor\u00adresponding ones in the mathematical theory of .nite \nsets (e.g. .) when we reason about the programs. The advantages of using an abstraction function in speci.ca\u00adtions \nare numerous, but they also require veri.cation systems that can reason about these user-de.ned functions \nthese functions ap\u00adpear in contracts and therefore in veri.cation conditions. For exam\u00adple, consider \nthe function add in Figure 1 and apply the standard technique to replace recursive function call with \nthe function con\u00adtract. The result is a set of veri.cation conditions including (among others) the condition: \n.t1,t2,t3,t4 : Tree,e1,e2 : Int = Node(t2,e1,t3) . t1 (2) content(t4) = content(t2) .{e2}. content(Node(t4,e1,t3)) \n= content(t1) .{e2} \n\t\t\t", "proc_id": "1706299", "abstract": "<p>We describe a family of decision procedures that extend the decision procedure for quantifier-free constraints on recursive algebraic data types (term algebras) to support recursive abstraction functions. Our abstraction functions are catamorphisms (term algebra homomorphisms) mapping algebraic data type values into values in other decidable theories (e.g. sets, multisets, lists, integers, booleans). Each instance of our decision procedure family is sound; we identify a widely applicable many-to-one condition on abstraction functions that implies the completeness. Complete instances of our decision procedure include the following correctness statements: 1) a functional data structure implementation satisfies a recursively specified invariant, 2) such data structure conforms to a contract given in terms of sets, multisets, lists, sizes, or heights, 3) a transformation of a formula (or lambda term) abstract syntax tree changes the set of free variables in the specified way.</p>", "authors": [{"name": "Philippe Suter", "author_profile_id": "81453631112", "affiliation": "Ecole Polytechnique F&#233;d&#233;rale de Lausanne, Lausanne, Switzerland", "person_id": "P1911070", "email_address": "", "orcid_id": ""}, {"name": "Mirco Dotta", "author_profile_id": "81453662089", "affiliation": "Ecole Polytechnique F&#233;d&#233;rale de Lausanne, Lausanne, Switzerland", "person_id": "P1911071", "email_address": "", "orcid_id": ""}, {"name": "Viktor Kuncak", "author_profile_id": "81100277693", "affiliation": "Ecole Polytechnique F&#233;d&#233;rale de Lausanne, Lausanne, Switzerland", "person_id": "P1911072", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706325", "year": "2010", "article_id": "1706325", "conference": "POPL", "title": "Decision procedures for algebraic data types with abstractions", "url": "http://dl.acm.org/citation.cfm?id=1706325"}