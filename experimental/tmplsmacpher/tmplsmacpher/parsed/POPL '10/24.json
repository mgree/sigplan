{"article_publication_date": "01-17-2010", "fulltext": "\n Pure Subtype Systems DeLesley S. Hutchins MZA Associates Corporation dhutchins@mza.com Abstract This \npaper introduces a new approach to type theory called pure subtype systems. Pure subtype systems differ \nfrom traditional ap\u00adproaches to type theory (such as pure type systems) because the theory is based on \nsubtyping, rather than typing. Proper types and typing are completely absent from the theory; the subtype \nrelation is de.ned directly over objects. The traditional typing relation is shown to be a special case \nof subtyping, so the loss of types comes without any loss of generality. Pure subtype systems provide \na uniform framework which seamlessly integrates subtyping with dependent and singleton types. The framework \nwas designed as a theoretical foundation for several problems of practical interest, including mixin \nmodules, virtual classes, and feature-oriented programming. The cost of using pure subtype systems is \nthe complexity of the meta-theory. We formulate the subtype relation as an abstract reduction system, \nand show that the theory is sound if the under\u00adlying reductions commute. We are able to show that the \nreductions commute locally, but have thus far been unable to show that they commute globally. Although \nthe proof is incomplete, it is close enough to rule out obvious counter-examples. We present it as an \nopen problem in type theory. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal \nDe.nitions and Theory Semantics; F.3.2 [Log\u00adics and Meanings of Programs]: Semantics of Programming Lan\u00adguages \nGeneral Terms Languages, Theory Keywords subtyping, dependent types, singleton types, transitiv\u00adity elimination, \nabstract reduction systems 1. Introduction Type theory has traditionally drawn a sharp distinction between \nobjects, such as the number 3, and proper types, such as Int. Objects can be used in computations, such \nas 3+5 -. 8, whereas proper types cannot; Int +5 is not a valid expression. Types, on the other hand, \ncan be used to quantify over terms, whereas objects cannot; the function .x :3.x is not a valid expression \neither. Because traditional type theory distinguishes between types and objects, it must also distinguish \nbetween typing and subtyping. Typing is relationship between objects and types, e.g. 3: Int, whereas \nsubtyping is a relationship between types, e.g. Int = Top. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 10, January 17 23, 2010, Madrid, Spain. \nCopyright c &#38;#169; 2010 ACM 978-1-60558-479-9/10/01. . . $10.00 This paper introduces a new approach \nto type theory that we call pure subtype systems which eliminates these distinctions. Pure subtype systems \ndiffer from traditional type theory in the following three ways: 1. Pure subtype systems do not distinguish \nbetween types and objects. Every term can behave as either a type or an object depending on context. \n 2. There is no typing relation. Typing is shown to be a special case of subtyping. 3. The subtype relation \nis de.ned over all terms, not just types.  In a pure subtype system, objects can act as types. The number \n3 is interpreted as a singleton type it denotes the set of all terms that are equal to 3. Likewise, \nthe type Int can be used in computations: Int +5 -. Int. Performing a computation with types is very \nsimilar to abstract interpretation. A type denotes a set of possible values, so the computation returns \na set of possible results i.e. another type. By eliminating the distinction between types and objects, \nwe also eliminate the distinction between typing and subtyping. If objects are treated as singleton types, \nthen the subtype relation can be extended to cover objects as well as types. Once this has been done, \ntyping becomes super.uous, and can be eliminated from the theory. An alternative title for this paper \nthat we considered is: Sub-typing, a sub-stitute for typing. 1.1 Terminology Before going on, it is important \nto clarify some terminology. The terms of a language include everything de.ned by the formal syn\u00adtax \nof the language. Most type theories divide terms into two or three sorts, which are syntactically distinct. \nThe two main sorts are objects and types; many theories also de.ne kinds. The word object here refers \nto the objects of the theory, not to objects in the sense of object-oriented programming. The word term \nrefers to any valid piece of syntax. Some authors in the literature use the word term to denote objects, \nas distinct from types; our use of the word term includes both objects and types.  1.2 History and Motivation \nPure subtype systems were invented as part of a broader effort to develop a type theory for .rst-class, \nextensible, recursive modules [18] [19]. This work is described in the author s PhD thesis [19], which \ngives a theory of mixin modules and virtual classes based on pure subtype systems. Modules present several \nchallenges that are dif.cult to address with more traditional approaches. First, we wished to combine \nsubtyping with dependent types, a combination that is tricky to work with [3]. Second, we found ourselves \nde.ning the subtype relation over objects as well as types. Our theory of modules required dependent \ntypes because we de.ned modules as records (i.e. objects) which could contain type members. If m.T denotes \nthe type member T within the module m, then m.T is a dependent type a type expression which depends \nupon the object m.  We used subtyping to handle module extension, which is similar to object-oriented \ninheritance. In an OO language, inheritance is intuitively related to subtyping because inheritance is \na relationship between classes, and classes are types. However, module extension is a relationship between \nmodules, and modules in our theory were objects, not types. Thus, we extended the subtype relation to \ninclude objects. Interestingly enough, Dreyer has come to a similar conclusion in his most recent work; \nMixML uni.es signatures (i.e. types) and structures (i.e. modules) [14]. After working with the module \nsystem for a while, we realized that we had uncovered a new way of doing type theory in general, which \nwas independent of the particular application to modules. This paper presents the basic ideas of pure \nsubtype systems within in the form of functions from types to objects, and System F. adds higher-order \ntypes, which are functions such as List that map from types to types. System F. is considerably more \ncomplex than its predecessor, System F, because once functions have been added to the level of types, \nit is possible to construct and evaluate expressions at the level of types. In order to prove that such \nexpressions are valid, type expressions are assigned kinds, in exactly the same way that object expressions \nare assigned types. In System F. as it is usually presented [26], objects, types, and kinds are all syntactically \ndistinct. System F. de.nes no less than six different pieces of syntax for .-abstractions and their proper \ntypes and kinds. In the following table, t and u range over objects, T,U range over types, and K1,K2 \nrange over kinds; x is an object variable, while X is a type variable: the context of the familiar .-calculus. \nWe have based our presenta\u00adtion on Barendregt s successful theory of pure type systems [4].  1.3 Summary \nof key results In this paper, we compare and contrast pure subtype systems (PSSs) with traditional approaches \nto type theory (Section 2), and we give some examples which illustrate how PSSs can be used (Section \n3). We demonstrate that subtyping completely subsumes typing by embedding a pure type system in a PSS \n(Section 4), and we show that PSSs are type-safe if a property known as transitivity Barendregt s theory \nof pure type systems (PTSs) demonstrates description abstraction proper type or kind ordinary functions \n.x : T. u T . U polymorphic objects .X : K. u .X : K.U type operators .X : K1. U K1 . K2 that this duplication \nof syntax is unnecessary. PTSs exploit the fact that the reduction and inference rules are identical \nfor both object expressions and type expressions, so there is no need to distinguish syntactically between \nthe two. PTSs have a single syntax for .\u00adelimination holds (Section 5). Subtyping is inherently harder \nto work with than typing, be\u00ad cause subtyping is transitive, whereas typing is not. (Transitivity states \nthat if a = b, and b = c, then a = c). The presence of a transitivity rule makes it hard to prove an \ninversion or generation lemma, which is a key part of most type safety proofs [26]. Stan\u00addard practice \nis to prove a property called transitivity elimination, abstractions, and a single syntax for proper \ntypes and kinds. Ob\u00ad jects, types, and kinds are all terms, and the typing relation is de\u00ad .ned uniformly \nover terms. In the following (much simpler) table for PTSs, s, t, u are terms, and x is a term variable: \n which shows that transitivity, in its general form, can be removed 2.2 A uniform syntax for functions \nwith subtyping? as an axiom of the system [26] [27] [10] [11]. System F. extends System F. with support \nfor subtyping, and the .Inothertheoriesofhigher-ordersubtyping,suchasSystemF= transitivity elimination \nis one of the most dif.cult results to prove = , subtyping judgement must be de.ned over all of the \nvarious pieces of syntax. It is tempting to try and reduce this complexity by using (Section 8). Existing \nproofs rely on the fact that the language of types is strongly normalizing (i.e. the evaluation of every \ntype ex\u00ad pression is guaranteed to terminate). Pure subtype systems, like .thesametrickthatBarendregtusedforPTSs,butinSystemF=.abstractioninSystemF= \nthere is a problem. The following table lists the three forms of , : pure type systems, do not guarantee \nstrong normalization, so ex\u00adisting proof techniques are not applicable. Since a proof based on strong \nnormalization is not possible, we have pursued a proof technique based on con.uence instead (Sec\u00adtion \n6). We formulate the subtyping judgement as an abstract reduc\u00adtion system, and show that transitivity \nfollows from commutativity of the underlying reductions. We are able to show that the reduc\u00ad ordinary \nfunctions .x : T. u T . U polymorphic objects .X = T. u .X = T.U type operators .X = T. U .X = T.K Notice \nthat these three forms of abstraction quantify over a variable in two different ways, using two different \nrelations: typing tions commute locally, but we have not been able to show that they (e.g. x : T ) and \nsubtyping (e.g. X = T ).commute globally. A similar problem exists in System F. between typing and kind-Our \npartial proof is close enough to a full proof that the ing. In order to unify the three forms of abstraction, \nPTSs combine obvious counter-examples can be ruled out. However, the ultimate typing and kinding into \na single relation which is de.ned over all soundness of our technique remains an open question. Our hope \nis terms. If we are to unify the three forms of abstraction in System that by presenting this work as \nan open problem (Section 7), we can involve the larger research community in the quest for its solution. \n2. From System F. to Pure Subtype Systems = .F= bine typing and subtyping into a single relation which \nis de.ned over all terms. This observation is the key insight that underlies pure subtype systems. , \nalong the same lines as PTSs, then we must necessarily com\u00ad .typesystems(orPSSs)generalizeSystemF= We \nintroduce pure subtype systems by way of an analogy. Pure sub-2.3 Unifying subtyping and kinding , the \ntheory of higher- The idea of using a single relation for both typing and subtyping order subtyping, \nin much the same way that pure type systems (or sounds radical, but it actually has a precedent in the \nliterature. The PTSs) generalize System F., the theory of higher-order types. is de.ned as: .languageofkindsinSystemF= \n= 2.1 Higher-order types and PTSs K ::= *| .X = T. K In System F. , every kind is associated with a Top-type, \nthe Barendregt s .-cube classi.es type theories into a hierarchy. The simply-typed .-calculus includes \nonly one form of abstraction: supertype of all types which have that particular kind. The Top\u00adfunctions \nfrom objects to objects. System F adds polymorphism type of a kind K, written top(K), is: top(*)= Top \ntop(.X = T. K)= .X = T. top(K) Thus, every abstraction of the form .X : K. u, in System F., can be replaced \nwith an abstraction of the form .X = top(K).u, in System F. =, without loss of generality. In other words, \nsubtyping completely subsumes kinding. What we shall show in this paper is that by extending the subtype \nrelation to cover all terms, subtyping can also subsume typing. Every abstraction of the form .x : T. \nu can be replaced with an abstraction of the form .x = t. u for some t. Instead of pure type systems, \nwhich are based upon typing, we obtain the theory of pure subtype systems, which are based entirely upon \nsubtyping.  2.4 Unifying abstractions and proper types Barendregt s pure type systems still maintain \na distinction between functions, written .x : t. u, and proper types, written .x : t. u. Functions differ \nfrom .-types in that functions are eliminated via \u00df-reduction (i.e. (.x : t. u)(s) -. [x . s]u), whereas \n.-types are eliminated by the following typing rule: G f f : (.x : t. u)G f s : t G f f(s):[x . s]u As \nit turns out, the distinction between functions and .-types is yet another needless duplication of syntax. \nRecent work by Kamareddine [21] has shown that .-types are, in fact, unnecessary. She presents an alternative \nsystem in which the type of a function is simply another function, subject to the following constraint: \nif f is a function, and f : F , then f(a): F (a) for any valid argument a. In Kamareddine s system, the \nrule for eliminating .-types is subsumed by ordinary \u00df-reduction. As it turns out, a very similar simpli.cation \narises in pure subtype systems. In section 2.3, we saw that the top-type of a kind .X = T. K is a function: \n.X = T. top(K). The act of replacing kinded quanti.cation (i.e. X : K) with bounded quanti.cation (i.e. \nX = top(K)) has a consequence: it also eliminates all .-types, replacing them with .-abstractions. In \npure subtype systems, the six pieces of syntax found in System F. for functions and proper types are \nall uni.ed into a = single piece of syntax: .x = t. u.  2.5 Deconstructing the typing judgement In most \ntraditional type theories, including pure type systems, the type of a term provides three distinct pieces \nof information: 1. The type of a term describes the shape of the value that will be produced when the \nterm is evaluated. 2. Terms which can be assigned types are said to be well-typed. The evaluation of \na well-typed term will not generate type errors at run-time. 3. The type or kind of a term describes \nthe level or universe in which the term resides.  In pure subtype systems, these three pieces of information \nare split into separate judgements which are largely orthogonal: 1. Subtyping compares the shape of terms. \n 2. The evaluation of a well-formed term will not generate type errors. 3. An (optional) universe judgement \ndetermines the universe in which the term resides.  Subtyping and typing have a signi.cant amount of \noverlap be\u00adcause they are both judgements about shape. For example, the judgement t : U . S means that \nwhen t is evaluated, the re\u00adsult will be a function that accepts arguments of type U. Similarly, T = \n(.X = U. S) means that when the type expression T is eval\u00aduated, it will produce a function which accepts \narguments that are subtypes of U. However, typing also provides a piece of information that sub\u00adtyping \ndoes not a guarantee that evaluating the term will not pro\u00adduce any type errors. Subtyping can be used \nas a substitute for typing with regard to shape, but not with regard to program cor\u00adrectness. Pure subtype \nsystems rely on a well-formedness judge\u00adment to ensure program correctness. The usual approach to prov\u00ading \ntype safety well-typed terms don t go wrong becomes well-formed terms don t go wrong. The third piece \nof information, universes, is optional. Tradi\u00adtional type theories usually include at least two universes: \nthe uni\u00adverse of objects, and the universe of types. When Barendregt for\u00admulated pure type systems, he \nshowed that the basic theory is the same for any universe structure; the universe structure is a param\u00adeter \nof the theory. The same principle holds for pure subtype sys\u00adtems. For the sake of simplicity, this paper \ndescribes a theory with only a single universe, but we will brie.y show that it is possible to add other \nuniverse structures as well. 3. System .< Figure 1 introduces System .<. System .< is the simplest pure \nsubtype system that we could devise; it is a typed .-calculus with a single universe. Functions are written: \n.x = t. u. Both the type bound t and the function body u are ordinary terms. Functions use bounded quanti.cation \nrather than typing; the above function can be applied to any term that is a subtype of t. Top is a universal \nsupertype; every well-formed term t is a subtype of Top. This interpretation of Top differs from System \nF. =, Top is only a supertype of the proper types =. In System F. (the types of objects), it is not a \nsupertype of type operators. As will be discussed in Section 4.2, our interpretation of Top makes System \n.< fully impredicative, which has important consequences for decidability. Unlike pure type systems, \nthe dependent type .x : t. u is not a part of the syntax; this type is subsumed by ordinary functions. \nThe arrow type t . u is not present either, for the same reason. We treat t . u as syntactic sugar for \nan ordinary function .x = t. u, where x is chosen fresh and does not appear in u. 3.1 Subtyping Figure \n1 gives the declarative formulation of subtyping, (as distinct from algorithmic subtyping, which we will \nintroduce later), so the rules are named (DS-Name). Our naming scheme for rules dis\u00adtinguishes between \ncongruence rules like (DS-APP), which com\u00adpare terms of similar shape (i.e. functions with functions, \nor ap\u00adplications with applications), and reduction rules like (DS-EAPP), which compare terms of different \nshape. In order to make the presentation as compact as possible, we use < as a metavariable that ranges \nover both the subtype relation (=), and the type equivalence relation (=). This particular presentation \nstyle is the reason why we call the calculus System .<. Each rule that is given in terms of < thus de.nes \ntwo different rules. For example, the rule for application (DS-APP) actually denotes the following: '' \nG f t < t, u = u means G f t(u) < t'(u') '' '' G f t = t, u = uG f t = t, u = u and G f t(u) = t'(u')G \nf t(u) = t'(u')  Syntax: x, y, z Variable s, t, u ::= Terms G ::= Type Contexts x variable \u00d8 empty \ncontext Top universal supertype G, x = t variable .x = t. u function t(u) application < ::= Type relations \n= subtype v, w ::= Values = type equivalence Top universal supertype .x = t. u function Reduction: t \n-. t ' t -. t ' (E-CONG) C[t] -. C[t '] (.x = t. u)(s) -. [x . s]u (E-APP) Context well-formedness: \u00d8 \nwf G wf x . dom(G) G f t wf G,x = t wf Well-formedness: G wf x . dom(G) G f x wf G wf G f Top wf G,x \n= t f u wf G f .x = t. u wf G f t =wf .x = s. Top G f u =wf s G f t(u) wf G wf (W-GAM1) (W-GAM2) G f \nt wf (W-VAR) (W-TOP) (W-FUN) (W-APP) Well-subtyping: G f t wf,u wf G f t < u G f t <wf u Subtyping: \nG f s < t, t < u, t wf G f s < u G f u = t G f t = u G f t = u G f t = u G f x = x G f Top = Top G f \nt = t ' G,x = t f u < u ' G f .x = t. u < .x = t ' .u ' G f t < t ' ,u = u ' G f t(u) < t ' (u ' ) G \nf (.x = t. u)(s) = [x . s]u G f t = Top x = t . G G f x = t G f t <wf u (W-SUB) G f t < u (DS-TRANS) \n(DS-SYM) (DS-EQ) (DS-VAR) (DS-TOP) (DS-FUN) (DS-APP) (DS-EAPP) (DS-ETOP) (DS-EVAR) Notation:  C is a \ncontext with a hole: C ::= [] | C(t) | t(C) | .x = C. t | .x = t. C.  C[t] denotes the context C with \nthe term t substituted for the hole [] in the context.  [x . t]u denotes the capture-avoiding substitution \nof the term t for the variable x within u.  fv(t) denotes the set of free variables in the term t. \n dom(G) denotes the set of variables de.ned in G.  x = t . G is true if the type context G contains \nx = t.  Note that < is a meta-variable which ranges over = and =.  For compactness, we adopt the following \nconvention:  A pair of judgements G f J1 and G f J2 which are both made within the same type context \nG are written as G f J1,J2. Figure 1. System .< syntax, operational semantics, and declarative subtyping \n 3.2 Point-wise subtyping The subtyping judgement for System .< has been lifted almost ver\u00adbatim from \nSystem F. =. In fact, System .< is essentially a fragment of System F. =, a fragment that only contains \ntype operators. Simpler theories of subtyping, such as System F=, only de\u00ad.ne the subtype relation over \nproper types (i.e. arrow or .-types), which are the types of objects. Each proper type denotes a set \nof ob\u00adjects. The subtype relation between proper types thus corresponds to the subset relation between \nsets; a type T is a subtype of U if and only if every object of type T is also an object of type U. System \nF. = extends the subtype relation to include type oper\u00adators (a.k.a. higher-order types). However, type \noperators do not denote sets of objects; they denote functions over types. Thus, the idea that subtypes \nare subsets is no longer suf.cient. The primary insight behind System F. = is that it is possible to \nde.ne a meaning\u00adful subtype relation directly over functions. System F. uses a pointwise subtyping rule: \ngiven two type = operators F and G, F = G if and only if F (A) = G(A) for any valid argument A. Notice \nthe similarity between this de.nition of pointwise subtyping, and the de.nition of pointwise typing found \nin Kamareddine s theory, which was described in Section 2.4. System .< uses the same point-wise subtyping \nrule found in System F. =. However, every term in System .< can be interpreted as a type, so every function \ncan be interpreted as a type operator. 3.3 Contravariance Subtyping in System .< differs from that in \nSystem F. in one = respect: the argument type of a function is invariant rather than contravariant in \nsubtypes. That is to say, (.x = t. u) = (.x = t ' .u) only if t = t '. Although contravariance is a potentially \nuseful extension, it also results in several well-known pathologies [25]. The practical applications \nof System .< that we have explored thus far (i.e. modules) do not require contravariance, so we have \nnot included it in the theory. A further discussion of this issue can be found in [19]. 3.4 Well-formedness \nThe subtype relation is de.ned only over terms that are well\u00adformed. For clarity of presentation, however, \nwe have chosen to de.ne the = relation syntactically, omitting the well-formedness checks. The complete \nsubtype relation is written as t =wf u, (pronounced t is a well-subtype of u ). Any derivation of t =wf \nu only compares well-formed subterms of t and u. The well-formedness judgement makes the following type \nchecks: It ensures that the program is well-scoped: every variable x must be de.ned within the typing \ncontext.  In a function application t(u), it ensures that t is a function, and that u is a subtype of \nthe argument type of that function.  3.5 Example: 3 = Nat To illustrate how System .< works, we show \nhow Nat, the type of natural numbers, and the number 3, can both be encoded in the standard way using \nChurch numerals [26]. We further show that 3 is a subtype of Nat. Nat = .x = Top. (x . x) . x . x = .x \n= Top. .f = (.y = x. x). .a = x. x 3= .x = Top. .f = (.y = x. x). .a = x. f(f (f(a))) Recall that the \nstandard arrow-type t . u is syntax sugar for .y = t. u. To show that 3 = Nat, we show that: G,f = (.y \n= x. x),a = x f f(f(f(a))) = x, as follows: G,f = (.y = x. x),a = x f f(f(f(a))) = (.y = x. x)(f(f(a))) \nby DS-EVAR = x by DS-EAPP The encoding shown above is not speci.c to System .<. It would be perfectly \nvalid in System F. = as well, if 3 and Nat were encoded at the level of types, rather than the level \nof objects. 3.5.1 Singleton types and abstract interpretation Although System .< does not formally distinguish \nbetween types and objects, there is still a semantic difference between the two. The number 3 is a singleton \ntype; it has no subtypes other than itself. (A subtype of 3 could only be constructed by .nding a subtype \nof f, and that s not possible because f is a variable which does not appear in the bounds of other variables.) \nThe number 3 can be interpreted as either a type or an object. As an object, the number 3 can be used \nin computations, such as being added or multiplied by other numbers. When used as a type (e.g. .x = 3.x \n+ x), it is the type of all natural numbers that are equal to 3. Similarly, Nat can be interpreted as \neither a type or an object. As a type, it is the type of natural numbers. As an object, it can be used \nin computations just like any other number. Using the standard Church encodings for addition and multiplication, \nwe get: Nat + n = Nat for any n Nat * n = Nat for any n The evaluation of such expressions is somewhat \nsimilar to ab\u00adstract interpretation. When an abstract type like Nat is used as an object, it represents \nan unknown value. It is possible to perform computations with such values, but the result will also be \nunknown i.e. a type.  3.6 Adding Universes The number 3 is a subtype of Nat because they both have \na similar shape. They are both functions, and they both accept the same number and the same type of arguments. \nThis de.nition is suf.cient to build a static type system. However, in practical programming, we may \nalso wish to ensure that a given computation will return an actual number, like 0 or 5, rather than a \ntype, like Nat. Subtyping does not make this distinction, but it easy to add a universe judgement which \ndoes. There are many ways in which a universe judgement can be constructed, with varying degrees of sophistication; \nwhat follows is one of the simplest ways. Terms are divided into two universes: 0 is the universe of \nobjects, and 1 is the universe of types. In order to distinguish between these universes, the syntax \nof System .< must be extended so that variables are tagged with their universe. Object variables are \nwritten as x 0 or y 0, while type variables are written as x 1 or y 1: J, K ::= 0 | 1 s, t, u ::= x K \n| Top | .xK = t. u | t(u) Once variables have been tagged with their universe, the judge\u00adment t .U(K) \ndetermines whether a term t is an object or a type: x K .U(K) Top .U(1) .xJ = t. u .U(K) if u .U(K) t(u) \n.U(K) if t .U(K) Note that a function is in universe K if its body is in K, regard\u00adless of what universe \nits argument is in. This simple model allows a function in any universe to quantify over any other universe, \nand thus supports both parametric polymorphism (objects that depend on types) and dependent types (types \nthat depend on objects).  The well-formedness rule for function application must also be modi.ed to \nensure that function arguments are in the correct universe: G f t =wf (.xK = s. Top),u =wf su .U(K) G \nf t(u) wf It is easy to see that universes are preserved under \u00df-reduction, because a variable in universe \nK is replaced with a term in universe K. Moreover, by extending our de.nitions of 3 and Nat with universe \ntags, it also clear that 3 is an object (i.e. 3 .U(0)), and Nat is a type: Nat=.x1 = Top. .f0 = (x 1 \n. x 1). .a0 = x 1 .x 1 3=.x1 = Top. .f0 = (x 1 . x 1). .a0 = x 1.f0(f0(f0(a 0))) We present universes \nas a curiosity. The universe judgement shown here is completely orthogonal to subtyping, so the presence \nor absence of universes does not affect any of the results that we present in this paper. The subtype \nrelation is still de.ned over all terms in all universes. In particular, subtyping can cross universe \nboundaries: objects are still subtypes of types. In the interest of simplicity, the rest of this paper \nwill be devoted to the version of System .< with only a single universe. 4. Embedding of a Pure Type \nSystem To show that pure subtype systems are comparable in expressive power to pure type systems, we \nshow that System .* can be em\u00adbedded in System .<. System .* is a PTS described by Barendregt [4], which \nsupports polymorphism, type operators, and dependent types. It has a single sort *, and the typing relation \n* : *. The em\u00adbedding is as follows: (x) = x (*) = Top (.x : t. u) = .x =(t). (u) (.x : t. u) = .x =(t). \n(u) (t(u)) = (t)((u)) (\u00d8) = \u00d8 (G,x : t) = (G),x =(t) Lemma 4.1 (Substitution is preserved under translation) \n([x . t]u) =[x .(t)](u) Proof: By straightforward induction on u. D Theorem 4.2 (Reduction is preserved \nunder translation) If t -. u then (t) -. (u). Proof: By induction on the derivation of t -. u, using \nlemma 4.1 for the base case. D Theorem 4.3 (Typing is preserved under translation) If G f t : u then \n(G)f(t)=wf (u). Proof: By induction on the derivation of t : u. Full details can be found in the author \ns PhD thesis [19]. D 4.1 Caveat: Pure Type Systems and Universes The calculus of constructions can be \nembedded in System .< using a similar technique, as can all the other members of Barendregt s .-cube. \nThe embedding shown above thus demonstrates that sub\u00adtyping is expressive. However, our embedding does \nnot enforce the restrictions that differentiate the various members of the .-cube. Every PTS comes equipped \nwith a universe structure (i.e. the sorts) and a set of rules that restricts the ways in which functions \nin one universe can quantify over other universes. It is easy enough to add universes to a pure subtype \nsystem, but it is not so easy to en\u00adforce universe restrictions. Pure subtype systems have an additional \nsymmetry because they unify .-abstractions and .-types, and that symmetry means that anything which is \nallowed in one universe must be allowed in the others. For example, the simply-typed .-calculus has two \nuniverses, objects and types, but it only permits functions that map from objects to objects. However, \nin a pure subtype system the arrow\u00adtypes become functions, e.g. Int . Int becomes .x = Int. Int. There \nis thus no way to permit functions from objects to objects without also permitting functions from objects \nto types. There is no simply-typed version of a pure subtype system.  4.2 Impredicativity and Girard \ns Paradox Although System .* is both elegant and expressive, it also has a well-known .aw. It admits \nGirard s paradox, and is thus not strongly normalizing [4]. Its embedding thus demonstrates that System \n.< is not strongly normalizing either. Theorem 4.4 (System .< is not strongly normalizing.) Proof: According \nto Girard s paradox, there exists a well-typed term in System .* that has no normal form, and thus has \nan in.nite reduction sequence [4]. According to theorem 4.3, the translation of this term is well-formed \nin System .<, and by theorem 4.2, the translation also has an in.nite reduction sequence. D A skeptic \nmight argue that Girard s paradox in System .* stems from the circular * : * rule, which confuses the \nuniverse of types and the universe of objects, and since System .< confuses the two universes much more \nthoroughly, it is not surprising that it suffers from the same problem. However, this argument is not \ncorrect. As Barendregt explains, Girard s paradox can also be found in System .U, another pure type system \nwhich has no such circularity [4]. The cause of Girard s paradox is impredicativity. A .-type is impredicative \nif the type variable quanti.es over the .-type itself. Such types can be used to build functions that \ncan be applied to themselves, which are the basis for non-terminating expressions. It is possible for \na type theory to be both impredicative and strongly normalizing; Girard s System F [16] and Luo s extended \ncalculus of constructions (ECC) [23] are two well-known exam\u00adples. However, great care is required. Both \nof these systems place tight controls on impredicativity; System F controls it by being relatively simple, \nwhile ECC uses a sophisticated universe struc\u00adture that restricts impredicativity to the universe of \npropositions; all other universes are predicative. System .< suffers from Girard s paradox because it \nplaces no constraints on impredicativity. All terms belong to a single universe, and Top is both a member \nof the universe, and a type that ranges over all elements of the universe. We believe, but have not yet \nproven, that strong normalization could be restored to pure subtype systems by either removing Top, which \nis the source of the impredicativity, or by using a more sophisticated universe judgement with stronger \nrestrictions. In the meantime, however, we shall explore the meta-theory of pure subtype systems under \nthe assumption that strong normalization does not hold, just as Barendregt does when developing the meta\u00adtheory \nfor pure type systems. 5. Type Safety This section shows that System .< is type-safe so long as subtyp\u00ading \nhas the transitivity elimination property. Transitivity elimina\u00adtion is the subject of the Section 6. \n Our proof of type safety is an adaptation of the standard tech\u00adnique of progress and preservation [31]. \nIn a traditional type sys\u00adtem, progress states that well-typed terms don t get stuck ; i.e. if t : T \n, then t must either be a value, or there exists a t ' such that t -. t '. Preservation states that reducing \na term will not change its type; if t : T and t -. t ', then t ' : T . In System .< we prove a similar \nresult for subtyping and well\u00adformedness. We show that well-formed terms don t get stuck , and well-formedness \nis preserved under reduction. The following proof is only a sketch; the complete proof can be found in \n[19]. Note that we use a, b, c in addition to s, t, u as meta-variables for terms. Conjecture 5.1 (Transitivity \nelimination) If G f v =wf w, then there exists a proof of G f v = w that ends in either (DS-FUN) or (DS-ETOP). \nLemma 5.2 (Inversion of subtyping declarative version) If G f (.x = t. u) =wf (.x = t ' .u ' ) then \nG f t = t ' . Proof: By conjecture 5.1 (transitivity elimination). D Lemma 5.3 (Reduction implies equivalence) \nIf t -. t ', then G f t = t ' . Proof: By induction on the derivation of t -. t '. The base case is by \nrule (DS-EAPP). D Lemma 5.4 (Substitution) If G,x = t, G ' f u <wf s and G f t ' =wf t '' ' then G, [x \n. t ]G ' f [x . t ]u <wf [x . t ]s. Proof: By induction on the derivation of u <wf s. Every derivation \nof the form x wf is replaced with t ' wf, and every derivation of the form x = t is replaced with t ' \n= t. D Theorem 5.5 (Progress) If \u00d8f t wf then either t = v for some v (i.e. t is a value), or there exists \na t ' such that t -. t ' . Proof: By induction on the derivation of t wf. The proof is by straightforward \nanalysis of cases; see [19] for details. D Theorem 5.6 (Preservation) If G f t =wf u and t -. t ' then \nG f t ' =wf u. Proof: By induction on the derivation of t wf. The proof has two parts. For the .rst part \nof the proof, we show that if t = u, and t -. t ', then t ' = u. By lemma 5.3 (reduction implies equivalence) \nt = t '. It follows that t ' = u using rule (DS-TRANS). For the second part of the proof, we show that \nt wf and t -. t ' implies t ' wf. The proof is by induction on the derivation of t wf, and the most interesting \ncase is as follows: Case t =(.x = a. b)(c) -. [x . c]b. The two premises of t wf are (.x = a. b) =wf \n(.x = a ' . Top), and c =wf a '. We have a = a ' by lemma 5.2 (inversion of subtyping), which gives us \nc =wf a by rule (DS-TRANS). We then have [x . c]b wf by lemma 5.4 (substitution). D 6. Transitivity Elimination \nThe de.nition of subtyping given in Figure 1 is known as declar\u00adative subtyping. The declarative de.nition \nis easy to read, and it is also easy to prove certain lemmas, such as substitution and narrow\u00ading. However, \nthe declarative de.nition is problematic because it includes a transitivity rule: G f s = t, t = u, t \nwf (DS-TRANS) G f s = u Transitivity is troublesome for two reasons. The .rst problem is that declarative \nsubtyping is not an algorithm, because it is not syntax-directed; there is a term t in the premises that \nis absent in the conclusion. There is therefore a practical need to .nd a different formulation of subtyping \nthat can be implemented within a compiler. The second, more serious problem is that the presence of a \ntran\u00adsitivity rule prevents us from completing the proof of type safety. The type safety proof given \nearlier has the following step: given a well-formed redex (.x = a. b)(c), we must show that [x . c]b \nis well-formed. This seems like a straightforward application of the substitution lemma, but the substitution \nlemma requires that c = a. We do not actually have a proof that c = a; instead, well\u00adformedness tells \nus that: (1) (.x = a. b) = (.x = a ' . Top) and (2) c = a ' If the derivation of (1) ends in rule (DS-FUN), \nthen we have a = a ', and consequently c = a, so the substitution lemma applies. However, if the derivation \nof (1) ends in rule (DS-TRANS), then there is no immediate relationship between a and a '. If a and a \n' are unrelated, then the substitution lemma cannot be applied, and the proof of type safety cannot be \ncompleted. The standard technique for resolving this problem is to refor\u00admulate the subtype relation \ninto an algorithmic form that does not include a transitivity rule, a process called transitivity elimination \n[26] [27] [10] [11]. In essence, transitivity elimination is a proof that subtyping is sound. After all, \nif the subtyping rules allowed us to derive that (.x = a. b) = (.x = a ' . Top), where a = a ', then \nthere would clearly be an error in the theory. The remainder of this section provides a partial proof \nof tran\u00adsitivity elimination. Although the proof is incomplete, our proof technique is novel, and we \nbelieve it offers insight into the funda\u00admental problem. 6.1 Subtyping as an abstract reduction system \nThe problems caused by the transitivity rule are not restricted to subtyping. They arise in any system \nwhich has a non-trivial notion of type equivalence, including all higher-order type theories. Equiv\u00adalence \nis a relation which is re.exive, symmetric, and transitive. The standard technique for dealing with equivalence \nis to formu\u00adlate the equivalence rules as an abstract reduction system (ARS) [26]. In an ARS, t = u if \nand only if there exists an s such that t -- u. -s - ARSs do not have a symmetry or transitivity rule, \nso transitivity elimination is an immediate property of the system. Moreover, if the reduction system \nis con.uent, then transitivity is admissible, which means that it can be derived from .rst principles. \nWe adopt this same technique for algorithmic subtyping in Sys\u00adtem .<. Unlike equivalence, subtyping is \nan inequality rather than an equality, and that affects the way in which we de.ne the relation. The algorithmic \nformulation of subtyping for System .< is presented in Figure 2. Most of the rules in the declarative \nsys\u00adtem, including (DS-VAR), (DS-TOP), (DS-APP) and (DS-FUN), involve comparisons between terms which \nhave the same shape. These rules become congruence rules in the reduction system. That leaves three remaining \nrules to consider: (DS-EAPP), (DS-EVAR), and (DS-ETOP). We reformulate these three rules = as reduction \nrules. An equivalence reduction, written t -. t ', de\u00ad  Prevalidity: Subtype reduction: G fAt = -. \nt ' G prevalid G prevalid x = t . G = G fAx -. t (SRS-PROM) \u00d8 prevalid x . dom (P-CTX1) (G) G prevalid \nG fA= t -. Top (SRS-TOP) G prevalid fv(t) . dom(G) (P-CTX2) =' t -. t fGA Equivalence reduction: G \nf-. [x . s]u A G,x = t prevalid s = * (.x = t. u)(s) fGA t Subtyping: fGA G ft < u A (SRE-APP) = G prevalid \n(AS-REFL) fGA G prevalid t < t (SRE-TOPAPP) = -. Top Congruence rules: fGA Top(t) < -. t ' ,t ' < u \nt (AS-LEFT) A <' G ft -. t t < u = -. u ' ,t < u ' fGA G f Transitive Subtyping: A AfG fGAfGA fGA u \n E= ::= [] | E=(t) | t(E=) | .x = E=.t (AS-RIGHT) t < u E= ::= [] | E=(t) G ft < * u A < ' fGA E<[t] \nt -. t <(SR-CONG) -. E<[t '] s < u (AST-SUB) A fGA u < G,x = t f-. u ' s <* s <* t, t <* fGA uu (SR-FUN) \nfGA A (AST-TRANS) < G f-. .x = t. u ' s <* u .x = t. u = ' t -. t = (SR-EQ) t -. t ' fGA Figure 2. \nSystem .< algorithmic subtyping . notes a rewrite step which produces a term t ' that is equivalent to \nt. \u00df-reduction (SRE-APP) falls into this category. Subtype reduc\u00ad = tion, written t -. t ', denotes a \nrewrite step which produces a term t ' that is a supertype of t. Variable promotion (SRS-PROM) and Top-promotion \n(SRS-TOP) fall into this category. = An equivalence reduction step t -. t ' can be applied any\u00ad iff \n f=fGGtuAA AA = where in a term. A subtype reduction step t -. t ' can only be applied in positive (i.e. \ncovariant) positions within a term. Positive positions are limited to function bodies and the left-hand \nside of applications. We express this requirement by means of two evalu\u00adation contexts: E= may have a \nhole in any position, whereas E= may only have a hole in positive positions. Neither evaluation con\u00adtext \ncan step inside a .-abstraction. Unlike ordinary reduction, both subtype and equivalence reduction must \nbe done within a context G that assigns bounding types to variables. Rule (SR-FUN) is used to reduce \nterms inside . abstractions. Within this framework, we de.ne type equivalence and subtyp\u00ad < ing as follows, \nwhere --denotes the re.exive and transitive clo\u00ad <== sure of -., and u .- t means the same thing as t \n-. u. == G ft = u iff G f -- u for some s. --s t --s t The de.nition of type equivalence is standard. \nTwo terms t and u are equivalent if they both reduce to a common term. The de.nition of subtyping is \nsimilar. The only difference is that for subtyping, the reduction sequence for t may promote variables \nto supertypes, or subterms to Top as necessary. Within this framework, basic meta-theoretic properties \nof sub\u00adtyping follow directly from standard properties of the correspond\u00ad == ing reductions. In particular, \nif -. and -. commute, then subtyp\u00ad == ing is transitive. If -. and -. were strongly normalizing (which \nthey are not), then the subtype judgement would be decidable.  6.2 Resolving circularities In the declarative \nde.nition of subtyping, the subtype relation is de.ned only over well-formed terms. This introduces a \ncircularity between subtyping and well-formedness that is dif.cult to unravel. The algorithmic de.nition \nof subtyping breaks this circularity by de.ning the subtype relation over all terms, not just well-formed \nones, and that necessitates a few changes to the system. The .rst change is there is a new reduction \nrule: (SRE-TOPAPP). Since algorithmic subtyping is de.ned over ill-formed terms, we must supply an interpretation \nfor ill-formed applications. == The need for this rule is explained in section 6.6.1. -- u for some \ns.  The second change is that rule (SRE-APP) has a premise that does not exist in the declarative system. \nThe redex (.x = t. u)(s) can only be eliminated if s is a subtype of t. This premise will always be satis.ed \nif the redex is well-formed. However, since redexes may not be well-formed, the algorithmic system performs \na dynamic type check before eliminating the redex. It is important to notice that the premise of (SRE-APP) \nis de.ned with = *, the transitive closure of subtyping, rather than =, which is ordinary subtyping. \nThere are two reasons for this decision. Both reasons are related to the fact that, in the proofs that \n== follow, we shall attempt to show that -. and -. commute. The .rst reason is that the reduction rules \nconstitute a condi\u00adtional rewrite system [5], because rule (SRE-APP) has a premise, or condition. If \nthe condition were specifed as s = t, then it would be a join condition, and Bergstra and Klop have shown \nthat join conditions cause commutativity to fail [5]. By de.ning the condi\u00adtion with = *, we avoid this \npitfall. The second reason is related. The diagrams of commutativity make use of two key lemmas: substitution \nand narrowing, in order to show that the premise of (SRE-APP) is satis.ed on both sides of the diagram. \nBoth of these lemmas require transitivity. Transitiv\u00adity follows from commutativity, but that would be \na circular proof. This potential circularity is eliminated by using = *, which is tran\u00adsitive by de.nition. \n 6.3 Con.uence and Commutativity We shall now attempt to prove that transitivity is admissible in the \nalgorithmic system. This property is the same as transitivity elim\u00adination in the declarative system; \nwe must show that any subtype derivation which makes use of transitivity can be rewritten as one that \nthat does not. In a simple ARS, transitivity follows from con.uence. However, algorithmic subtyping is \nnot simple, because there are two kinds of == reduction: -., and -.. Moreover, the two kinds of reduction \nare == not orthogonal; -. implies -. by (SR-EQ). The exact property that we require is thus more speci.c \nthan ordinary con.uence. == The -. relation by itself is trivially con.uent, because (t -. Top) can be \nused as the completing edges of any diagram. The two non-trivial properties that we are interested in \nare shown below. = Theorem 6.1 ( -. is con.uent) == If G fA t0 --t1,t0 --t2, then there exists a t3, \nsuch that == G fA t1 --t3,t2 --t3. == Conjecture 6.2 ( -. commutes with -.) == If G fA t0 --t1,t0 --t2 \nthen there exists a t3, such that == G fA t2 --t3,t1 --t3. These properties are illustrated by the following \ndiagrams: == - \u00bb - \u00bb - \u00bb - \u00bb t2 t3 t2 t3  = == = -\u00bb\u00bb-\u00bb--\u00bb t0 t1 t0 t1 == The solid lines of a con.uence \ndiagram are the spanning edges, and represent the premises, while the dotted lines are the complet\u00ading \nedges, and represent the conclusion. Lemma 6.3 (Commutativity implies transitivity) == If -. commutes \nwith -., then transitivity is admissible. Proof: Assume we have G fA s < t and G fA t < u. If == -. commutes \nwith -., then we can construct a derivation of G fA s < u, according to the following diagram: =-\u00bb -\u00bb \n- \u00bb u \u00b7 = -\u00bb \u00b7  = = -\u00bb -\u00bb t \u00b7 =  = s D 6.4 Con.uence: a brief digression Con.uence (or commutativity) \nis a fundamental property of any abstract reduction system. However, the idea of con.uence en\u00adcompasses \nthree properties of interest: -\u00bb -\u00bb-\u00bb -\u00bb - \u00bb \u00b7\u00b7\u00b7\u00b7 \u00b7\u00b7  -\u00bb-\u00bb -\u00bb-\u00bb \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 diamond global local property \ncon.uence con.uence It is seldom possible to prove global con.uence directly, be\u00adcause the spanning edges \nof the diagram have an arbitrary number of reductions. Instead, most proofs start with either the diamond \nproperty or local con.uence, which have only a single reduction on the spanning edges, and can thus be \nproven by simple analysis of all possible cases. The diamond property implies gobal con.uence because \nany global con.uence diagram can be .lled in, or tiled with single\u00adstep diagrams. Local con.uence can \nalso be used to tile a dia\u00adgram, but in the case of local con.uence, the tiling process is not guaranteed \nto terminate, because local con.uence tiles may have multiple reductions on their completing edges. There \nare several ways to prove global con.uence from local con.uence, of which Van Oostrom s technique of \ndecreasing dia\u00adgrams is perhaps the most general [30] [22]. The decreasing dia\u00adgrams technique states \nthat a reduction system is globally con.u\u00adent if it is locally con.uent, and if the elementary diagrams \nof local con.uence have the following form: <\u00df <a,<\u00df - \u00bb -\u00bb-\u00bb \u00b7 \u00bb-\u00b7 a -\u00bb \u00b7\u00b7  <a,<\u00df \u00b7  \u00df \u00df \u00b7   <a \n- \u00bb \u00b7\u00b7 a The technique assigns indices (i.e. a, \u00df) to reductions. The indices are drawn from a set with \na well-founded order. Each of the additional reductions on the completing edges have a smaller index \nthan the reductions on the spanning edges, and this fact is used to show that the tiling process terminates. \n=  6.5 Proof that -. is con.uent Our proof is an adaptation of Takahashi s proof of con.uence for the \nuntyped .-calculus [29] [6], which shows that simultaneous reduction has the diamond property. Full details \ncan be found in [19].  ==  6.6 Commutativity of -. and -. The last step in the proof of transitivity \nelimination is to show that == -. and -. commute. Unfortunately, it is here that our proof == technique \nbreaks down. We can show that -. and -. commute locally, but we have thus far been unable to show that \nthey commute globally. In fact, the actual property we prove is not even local commutativity per se, \nbut something quite similar: == Lemma 6.4 ( -. and -. commute locally) == If G f-. t2, then there exists \na t3, A 6.6.2 Commutativity by decreasing diagrams Although the property described by Lemma 6.4 is not \ntechnically local commutativity, it can be used to tile global commutativity diagrams in much the same \nway, because the = * relation is de.ned in terms of reduction. Moreover, the property is compatible with \nVan Oostrom s technique of decreasing diagrams, which we show as follows. Assume we have assigned indices \nto reductions, as required by Van Oostrom s technique. The proof of commutativity then pro\u00adceeds by induction. \nFor the base case, we show that commutativity holds for reduction sequences of index zero. We then show \nthat if commutativity holds for reduction sequences of index at most n, then it holds for sequences of \nindex at most n +1. t0 -. t1,t0 (=) = such that G f-. A In case (2) above, if the reductions in c = * \na have indices which (=) == where -.is the re.exive closure of -.. ,and fGt3A t1 = * t2 t3, are strictly \nsmaller than the spanning edges of the diagram, then we can use commutativity as an induction hypothesis. \nApplying lemma == 6.3 (transitivity elimination) to c = * a, yields c --d -- a, which gives us a diagram \nof true local con.uence: This property is illustrated by the following diagram. Note that the completing \nedge of the diagram on the right-hand side is not a subtype reduction (which would prove commutativity) \nbut a transi\u00adtive subtyping judgement, which we represent by drawing a dotted line instead of an arrow. \n=(=) - \u00bb t3 t2 = *= = t0 \u00bb t1 - 6.6.1 Case analysis A full analysis of all cases can be found in [19]. \nThe two main cases of interest are shown below. - \u00bb Top(c) = Top (1) = = - \u00bb (.x = a. b)(c) = [x . c]b \n- \u00bb (.x = a. C=[a])(c) = [x . c]C=[a] (2) = * = - \u00bb (.x = a. C=[x])(c) = [x . c]C=[c] Case (1) illustrates \nwhy (SRE-TOPAPP) is necessary. The term Top(c) is not well-formed, but we must handle it because algorith\u00admic \nsubtyping is de.ned over all terms, not just well-formed terms. Case (2) is important because it is the \nonly case which requires = * as the completing edge; every other case has a single subtype = reduction \non the completing edge. Were it not for case (2), -. and = -. would have the diamond property, and would \nthus commute globally. In case (2), one edge of the diagram promotes a variable x to its bounding type \na. (The notation C=[x] represents a term in which x appears in a covariant position.) The other edge \ncontracts the redex, replacing x with c. The premise of (SRE-APP) tells us that c = * a, and the congruence \nrules for reduction allow us to derive C=[c] = * C=[a] on the completing edge. However, notice what has \nhappened: a simple promotion = C=[x] -. C=[a] on the left-hand side becomes a full subtyping judgement \nC=[c] = * C=[a] on the right-hand side. (.x = a. C=[a])(c) = -\u00bb C=[a] = -\u00bb -\u00bb C=[d] = = (.x = a. C=[x])(c) \n= -\u00bb C=[c] Van Oostrom s decreasing diagrams technique guarantees that indices never increase during \nthe tiling process. The indices of = the additional reductions on the completing edges (i.e. C=[c] -\u00ad \n= C=[d] -- C=[a]) are therefore no greater than the indices of c = * a, which are strictly smaller than \nthe spanning edges. The above diagram of local con.uence is thus a decreasing diagram, and the rest of \nVan Oostrom s technique can be applied as usual. To summarize, we can obtain a proof of global commutativity \nfrom Lemma 6.4 by showing three things: Assign indices to reductions in some way.  Show that all cases \nother than case (2) are decreasing diagrams.  Show that in case (2), the indices of the reductions in \nc = * a (the right completing edge) are strictly less than the indices of the spanning edges, in which \nevent case (2) is also a decreasing diagram.  6.6.3 Almost, but not quite Since c = * a is a premise \nof the reduction on the bottom edge, there is an obvious de.nition of index that has the property we \nwant. The indices of c = * a are strictly smaller than the index of the bottom edge if we de.ne the index \nof a reduction to be the depth of its derivation tree. Unfortunately, this de.nition of index does not \nwork, because = the diagrams used in the proof of Theorem 6.1 (con.uence of -.) == do not preserve depth. \nSince -. implies -., those diagrams are cases that we must consider. = For example, consider the reduction \n(.x = a. b)(c) -. (.x = a. b)(c ' ). Contracting the left redex requires c = * a as a premise, = while \ncontracting the right requires c ' = * a. The reduction c -. c ' essentially becomes incorporated into \nthe subtyping judgement used on the right, and that alters its depth.  6.7 Discussion of the proof \nThe proof of transitivity elimination for System .< has two parts: === (1) con.uence of -., and (2) commutativity \nof -. and -.. When each part is considered separately, there is a proof tech\u00ad = nique that naturally \napplies. Con.uence of -. is by induction on the number of simultaneous reductions (i.e. the diamond property). \nCommutativity is by induction on the index (or depth) of reduc\u00adtions, using the technique of decreasing \ndiagrams.  Unfortunately, we are unable to combine these two induction = principles into a single proof. \nThe diagrams for -. do not preserve = depth, and the diagrams for -. do not preserve the number of simultaneous \nreductions. A complete proof of commutativity thus requires a stronger induction principle. Strong normalization \nwould provide such a principle, but System .< suffers from Girard s paradox, and is not strongly normalizing. \nIn the absense of a suitable induction principle, it makes sense to look for counter-examples to commutativity. \nA counter-example would produce an in.nite tiling by generating a sequence of sub\u00adtype derivations that \nnever decrease in size. Constructing such a counter-example in System .< itself would be extremely dif.cult, \nbecause an in.nite tiling implies an in.nite reduction sequence [22]. The only known in.nite reduction \nsequences arise from Gi\u00adrard s paradox, and involve terms that are so large as to defy easy analysis \n[17]. Practical applications of pure subtype systems (e.g. .rst-class recursive modules) introduce .xpoints \nto the language, which make the construction of non-terminating expressions much easier. Nev\u00adertheless, \neven with .xpoints, we have been unable to construct a counter-example. The partial proof of commutativity \ngiven here is close enough to a full proof that all of the obvious possibilities can be eliminated. Since \neach half of the proof has a valid induction principle when considered on its own, any counter-example \nwould have to exploit some subtle interaction between the two halves. 7. An open problem One bene.t of \nformulating the subtype relation as an abstract re\u00adduction system is that there there is an extensive \nliterature on ARSs which could potentially be applied. Unfortunately, subtype reduc\u00adtion in System .< \nhas a number of features that make it dif.cult to study. To simplify matters, we have devised the following \nrewrite system, which demonstrates con.uence behavior that is very simi\u00adlar to subtype reduction in System \n.<, but is formulated as a con\u00adventional ARS. Terminals: A Non-terminals: C, D Let = be the symmetric \nand transitive closure of -.. A -. C(A) D(x, y) -. x if x = y D(x, y) -. y if x = y The above system \nis a conventional, .rst-order conditional rewrite system, without variables, contexts, or other complications. \nMuch like subtype reduction, it gives rise to the following diagram of local con.uence: -\u00bb -\u00bb b \u00b7 - \u00bb \nD(a, b) a The condition on D(a, b) -. a tells us that a = b. Given an appropriate induction hypothesis, \nwe could transform a = b into a transitivity-free form, giving us a --\u00b7 -- b, which are the completing \nedges of the diagram. Notice that we complete the diagram by using the condition on one of the rewrite \nrules, in exactly the same way as in Section 6.6.2. We conjecture that if a proof of con.uence can be \nderived for the above rewrite system, then that proof can be adapted to == show that -. and -. commute \nin System .<. Moreover, if a counter-example to con.uence can be derived for the above rewrite system, \nthen that counter-example can also be adapted to disprove commutativity, and consequently type safety, \nfor System .<. 8. History and Related Work Transitivity elimination for systems with higher-order subtyping \nis known to be a hard problem. The .rst version of System F. =, developed by Steffen and Pierce [27], \nhas an unusual restriction. In their version, polymorphic functions use bounded quanti.cation; they are \nwritten as .X = T. u, where T is a type, and u is an object. Type operators, however, still use kinding; \nthey are written as .X : K. U, rather than .X = T. U. This decision breaks the symmetry of the language, \nand decreases its expressiveness. The reason Steffen and Pierce made the restriction is because it simpli.es \nthe meta-theory. As they write in a footnote: The more general form of this property... would be much \nmore dif.cult to prove [27]. Compagnoni makes the same decision in her work [10], and Chen does the same \nthing when adding subtyping to the calculus of constructions [8] [9]. Zwanenburg s theory of subtyping \nfor Pure Type Systems [32] is one of the closest theories in the literature to System .<. Zwa\u00adnenburg \ns theory includes both bounded quanti.cation and kinded quanti.cation. Although this seems like an unnecessary \nduplication of syntax, there is a subtle reason for including both forms. Zwa\u00adnenburg only allows higher-order \nsubtyping (i.e. point-wise subtyp\u00ading) on the kinded operators; operators with bounded quanti.cation \nonly have trivial subtypes. Both Steffen and Pierce s restriction, and Zwanenburg s restric\u00adtion prevent \nbounded quanti.cation from being combined with higher-order subtyping. If this combination is prohibited, \nthen con\u00ad.uence diagram (2) in Section 6.6.1 does not arise, because x can\u00adnot be promoted to a. As discussed \npreviously, this particular case == is what causes the diamond property of -. and -. to fail. If the \n= diamond property did not fail, then we would have a proof that -. = and -. commute, that transitivity \nis admissible, and that System .< is sound. To our knowledge, the only type theory in the literature \nwhich successfully combines higher order subtyping and bounded quan\u00adti.cation is the version of System \nF. = presented by Compagnoni and Goguen [11]. They use a proof technique called typed opera\u00adtional semantics \n, in which every judgment comes equipped with a proof that the terms in question have normal forms. This \ntechnique can only be applied to languages that are strongly normalizing. The proof techniques introduced \nin this paper demonstrate why strong normalization is useful. In our proof, we are able to show that \nsubtype reductions commute locally, but we have been unable to show that subtype reductions commutate \nglobally. According to Newman s lemma, however, any system which is both locally con\u00ad.uent (or locally \ncommutive) and strongly normalizing is globally con.uent (or commutative) [6]. By formulating the subtype \nrelation as an abstract reduction system, we have a developed a general framework in which the results \nof other theories can be compared. Every other theory of subtyping in the literature has a restriction \nthat, if applied to System .<, would cause our proof technique to succeed as well. 8.1 Power types Much \nof the theory of higher-order subtyping, and subtyping with dependent types, was inspired by Cardelli \ns early work on power types [7]. The approach take by Cardelli is almost completely dual to the one that \nwe have pursued here. Rather than treating typing as a special case of subtyping, power types allow subtyping \nto be treated as a special case of typing. Nevertheless, the overall effect is very similar to pure subtype \nsystems, both in terms of expressive power, and in the complexity (and intractability) of the meta-theory. \n Cardelli gives the theory of power types, but not the meta\u00adtheory. Aspinall has since examined the \nmeta-theory in more detail, but was unable to prove type safety [2]. Aspinall notes that the fundamental \nproblem is that it is hard to prove a generation (a.k.a. inversion) lemma for power types, the same problem \nthat we have in System .<.  8.2 Singleton types Aspinall has also studied the combination of subtyping \nwith sin\u00adgleton types [1]. From our point of view, the most interesting thing about subtyping with singletons \nis that it highlights yet another symmetry between typing and subtyping. If {t} denotes the type of all \nterms which are equal to t, then {t}= T if and only if t : T . Aspinall explicitly notes that because \nof this symmetry, any typ\u00ading judgement can be formulated as a subtype judgement, and vice versa [1]. \n9. Conclusion It is tempting to conclude that the meta-theoretic dif.culties which plague System .< stem \nfrom the fact that it uni.es types and ob\u00adjects. However, that conclusion would be incorrect. The problems \nfound in System .< can be found in any type system which has the following three elements: 1. Type operators \nwith bounded quanti.cation. 2. Higher order (i.e. point-wise) subtyping. 3. A language of types which \nis not strongly normalizing.  Moreover, there are solid practical reasons for wishing to com\u00ad bine these \nthree elements together. For example, System F . = is widely used to model inheritance in object-oriented \nprogramming languages [12], and bounded quanti.cation is now standard in lan\u00ad guages like Java and C#. \nGeneral-purpose OO languages have .x\u00ad points. Adding .xpoints by themselves to the level of objects in \nSystem F . = does not create any problems, because types are com\u00ad pletely separate from objects. However, \nif one were to add both .x\u00ad points and dependent types, then the existing proof of type safety [7] Luca \nCardelli. Structural subtyping and the notion of power type. Proceedings of POPL, 1988. [8] Gang Chen. \nSubtyping calculus of constructions (extended abstract). Proceedings of the International Symposium on \nMathematical Foun\u00addations of Computer Science, 1997. [9] Gang Chen. Dependent type system with subtyping: \nType level tran\u00adsitivity elimination. Journal of Computer Science and Technology, 14(1), 1999. [10] Adriana \nCompagnoni. Higher-Order Subtyping with Intersection Types. PhD thesis, University of Nijmegen, 1995. \n[11] Adriana Compagnoni and Healfdene Goguen. Typed operational se\u00admantics for higher order subtyping. \nInformation and Computation, 184(2):242 297, 2003. [12] Adriana Compagnoni and Benjamin Pierce. Higher-order \nintersection types and multiple inheritance. Mathematical Structures in Computer Science, 6(5):469 501, \n1996. [13] Derek Dreyer, Robert Harper, and Karl Crary. Toward a practical type theory for recursive \nmodules. Technical Report CMU-CS-01-112, 2001. [14] Derek Dreyer and Andreas Rossberg. Mixin up the ml \nmodule system. Proceedings of the International Conference on Functional Programming (ICFP), 2008. [15] \nErik Ernst, Klaus Ostermann, and William Cook. A virtual class calculus. Proceedings of POPL, 2006. [16] \nJean-Yves Girard, Yves Lafont, and Paul Taylor. Proofs and Types. Cambridge Tracts in Theoretical Computer \nScience, 1989. [17] Douglas Howe. The computational behavior of girard s paradox. Proceedings of the \nSymposium on Logic in Computer Science, 1987. [18] DeLesley Hutchins. Eliminating distinctions of class: \nUsing proto\u00ad types to model virtual classes. Proceedings of OOPSLA, 2006. [19] DeLesley Hutchins. Pure \nSubtype Systems: A Type Theory for Exten\u00ad sible Software. PhD thesis, University of Edinburgh, 2009. \n[20] Atsushi Igarashi and Benjamin Pierce. Foundations for virtual types. Proceedings of ECOOP, 1999. \n[21] Fairouz Kamareddine. Typed .-calculi with one binder. Journal of Functional Programming, 15(5), \n2005. for System F . = would break down, because dependent types are not strongly normalizing in the \npresence of .xpoints. [22] Jan Willem Klop, Vincent van Oostrom, and Roel de Vrijer. A geometric proof \nof con.uence by decreasing diagrams. Journal of Logic and Computation, 10(3), 2000. This is an important \nresult, because a number of researchers [23] Zhaohui Luo. Computation and reasoning: a type theory for \ncomputer are interested in adding dependent types and singleton types to science. Oxford University Press, \nInc., New York, NY, USA, 1994. both object-oriented and functional languages. In OO languages, dependent \ntypes are used for virtual types [20] [24], and virtual clases [15]. In functional languges, they are \nused for modules [13] [28]. We predict that future research will either face the same meta\u00adtheoretic \ndif.culties that plague System .<, or be forced to make certain compromises in the type theory, as previous \nwork in this area has done. References [1] David Aspinall. Subtyping with singleton types. Eighth International \nWorkshop on Computer Science Logic, 1994. [2] David Aspinall. Subtyping with power types. In Proceedings \nof Computer Science Logic, pages 156 157, 2000. [3] David Aspinall and Adriana Compagnoni. Subtyping \ndependent types. Proceedings of 11th Annual Symposium on Logic in Computer Sci\u00adence, 1996. [4] Henk Barendregt. \nLambda calculi with types. Handbook of Logic in Computer Science, volume II, 1992. [5] Jan Bergstra and \nJan Klop. Conditional rewrite ruels: Con.uence and termination. Journal of Computer and System Sciences, \n1986. [6] Marc Bezem, Jan Willem Klop, and editors Roel de Vrijer. Term Rewriting Systems. Number 55. \nCambridge Tracts in Theoretical Computer Science, 2003. [24] Martin Odersky, Vincent Cremet, Christine \nRockl, and Matthias Zenger. A nominal theory of objects with dependent types. Proceed\u00adings of ECOOP, \n2003. [25] Benjamin Pierce. Bounded quanti.cation is undecidable. Information and Computation, pages \n131 165, 1994. [26] Benjamin Pierce. Types and Programming Languages. MIT Press, 2002. [27] Martin Steffen \nand Benjamin Pierce. Higher-order subtyping. Univer\u00adsity of Edinburgh Technical Report ECS-LFCS-94-280, \n1994. [28] Christopher Stone. Singleton Kinds and Singleton Types. PhD thesis, Carnegie Mellon University, \n2000. [29] Masako Takahashi. Parallel reductions in .-calculus. Informationa and Computation, 118(1):120 \n127, 1995. [30] Vincent van Oostrom. Con.uence by decreasing diagrams. Theoreti\u00adcal Computer Science, \n126(1), 1994. [31] Andrew Wright and Matthias Felleisen. A syntactic approach to type soundness. Information \nand Computation, 2004. [32] Jan Zwanenburg. Pure type systems with subtyping. International Conference \non Typed Lambda Calculi and Applications, 1999.     \n\t\t\t", "proc_id": "1706299", "abstract": "<p>This paper introduces a new approach to type theory called <i>pure subtype systems </i>. Pure subtype systems differ from traditional approaches to type theory (such as pure type systems) because the theory is based on subtyping, rather than typing. Proper types and typing are completely absent from the theory; the subtype relation is defined directly over objects. The traditional typing relation is shown to be a special case of subtyping, so the loss of types comes without any loss of generality.</p> <p>Pure subtype systems provide a uniform framework which seamlessly integrates subtyping with dependent and singleton types. The framework was designed as a theoretical foundation for several problems of practical interest, including mixin modules, virtual classes, and feature-oriented programming.</p> <p>The cost of using pure subtype systems is the complexity of the meta-theory. We formulate the subtype relation as an abstract reduction system, and show that the theory is sound if the underlying reductions commute. We are able to show that the reductions commute locally, but have thus far been unable to show that they commute globally. Although the proof is incomplete, it is ``close enough'' to rule out obvious counter-examples. We present it as an open problem in type theory.</p>", "authors": [{"name": "DeLesley S. Hutchins", "author_profile_id": "81100209382", "affiliation": "MZA Associates Corporation, Albuquerque, NM, USA", "person_id": "P1911096", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706334", "year": "2010", "article_id": "1706334", "conference": "POPL", "title": "Pure subtype systems", "url": "http://dl.acm.org/citation.cfm?id=1706334"}