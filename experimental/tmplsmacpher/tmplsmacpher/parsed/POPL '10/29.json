{"article_publication_date": "01-17-2010", "fulltext": "\n Contracts Made Manifest Michael Greenberg Benjamin C. Pierce Stephanie Weirich University of Pennsylvania \nUniversity of Pennsylvania University of Pennsylvania Philadelphia, PA Philadelphia, PA Philadelphia, \nPA Abstract Since Findler and Felleisen [2002] introduced higher-order con\u00adtracts, many variants have \nbeen proposed. Broadly, these fall into two groups: some follow Findler and Felleisen in using latent \ncon\u00adtracts, purely dynamic checks that are transparent to the type sys\u00adtem; others use manifest contracts, \nwhere re.nement types record the most recent check that has been applied to each value. These two approaches \nare commonly assumed to be equivalent different ways of implementing the same idea, one retaining a simple \ntype system, and the other providing more static information. Our goal is to formalize and clarify this \nfolklore understanding. Our work extends that of Gronski and Flanagan [2007], who de.ned a latent calculus \n.C and a manifest calculus .H, gave a translation f from .C to .H, and proved that, if a .C term reduces \nto a constant, then so does its f-image. We enrich their account with a translation . from .H to .C and \nprove an analogous theorem. We then generalize the whole framework to dependent con\u00adtracts, whose predicates \ncan mention free variables. This extension is both pragmatically crucial, supporting a much more interesting \nrange of contracts, and theoretically challenging. We de.ne depen\u00addent versions of .H and two dialects \n( lax and picky ) of .C, establish type soundness a substantial result in itself, for .H and extend f \nand . accordingly. Surprisingly, the intuition that the latent and manifest systems are equivalent now \nbreaks down: the extended translations preserve behavior in one direction but, in the other, sometimes \nyield terms that blame more. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal \nDe.nitions and Theory Semantics ; D.2.4 [Software Engineering]: Software/Program Veri.cation Programming \nby contract General Terms Languages, Theory Keywords Contract, re.nement type, dynamic checking, blame, \nprecondition, postcondition, translation 1. Introduction The idea of contracts arbitrary program predicates \nacting as dy\u00adnamic pre-and post-conditions was popularized by Eiffel [Meyer 1992]. More recently, Findler \nand Felleisen [2002] introduced a .\u00adcalculus with higher-order contracts. This calculus includes terms \nlike .{x:Int | pos x}.l,l. 1, in which a boolean predicate, pos, is Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 10, January 17 23, 2010, Madrid, Spain. \nCopyright c . 2010 ACM 978-1-60558-479-9/10/01. . . $10.00 applied to a run-time value, 1. This term \nevaluates to 1, since pos 1 returns true. On the other hand, the term .{x:Int | pos x}.l,l. 0 evaluates \nto blame, written .l, signaling that a contract with label l has been violated. The other label on the \ncontract, l., comes into play with function contracts, c1 .. c2. For example, the term .{x:Int | nonzero \nx} .. {x:Int | pos x}.l,l. (.x:Int. pred x) wraps the function .x:Int. pred x in a pair of checks: when\u00adever \nthe wrapped function is called, the argument is checked to see whether it is nonzero; if not, the blame \nterm .l. is produced, signal\u00ading that the context of the contracted term violated the expectations of \nthe contract. If the argument check succeeds, then the function is run and its result is checked against \nthe contract pos x, raising .l if this fails (e.g., if the wrapped function is applied to 1). Findler \nand Felleisen s work sparked a resurgence of interest in contracts, and in the intervening years a bewildering \nvariety of related systems have been studied. Broadly, these come in two different sorts. In systems \nwith latent contracts, types and contracts are orthogonal features. Examples of this style include Findler \nand Felleisen s original system, Hinze et al. [2006], Blume and McAllester [2006], Chitil and Huch [2007], \nGuha et al. [2007], and Tobin-Hochstadt and Felleisen [2008]. By contrast, manifest contracts are integrated \ninto the type system, which tracks, for each value, the most recently checked contract. Hybrid types \n[Flanagan 2006] are a well-known example in this style; others include the work of Ou et al. [2004], \nWadler and Findler [2009], and Gronski et al. [2006]. The key feature of manifest systems is that descriptions \nlike {x:Int | nonzero x} are incorporated into the type system as re.nement types. Values of re.nement \ntype are introduced via casts like .{x:Int | true}.{x:Int | nonzero x}.l n, which has static type {x:Int \n| nonzero x} and checks, dynamically, that n really is nonzero, raising .l otherwise. Similarly, .{x:Int \n| nonzero x}. {x:Int | pos x}.l n casts an integer that is statically known to be nonzero to one that \nis statically known to be positive. The manifest analogue of function contracts is casts between function \ntypes. For example, consider: f = .I . I . P . P.l (.x:I . pred x), where I = {x:Int | true} and P = \n{x:Int | pos x}. The sequence of events when f is applied to some argument n (of type P) is similar to \nwhat we saw before: .rst, n is cast from P to I (it happens that in this case the cast cannot fail, since \nthe target predicate is just true, but if it did, it would raise .l); then the function body is evaluated; \nand .nally its result is cast from I to P, raising .l if this fails. One point to note here is that casts \nhave just one label, while contract checks in the latent system have two. This difference is not fundamental, \nbut rather a question of the pragmatics of assigning responsibility: both latent and manifest systems \ncan be given more or less rich algebras of blame. Informally, a function contract check .c1 .. c2.l,l. \nf divides responsibility for f s behavior between its body and its environment: the programmer is saying \nIf f is ever applied to an argument that doesn t pass c1, I refuse responsibility (.l.), whereas if f \ns result for good arguments doesn t satisfy c2,I accept responsibility (.l). In a manifest system, the \nprogrammer who writes .R1 . R2 . S1 . S2.l f is saying Although all I know statically about f is that \nits results satisfy R2 when it is applied to arguments satisfying R1, I assert that it s OK to use it \non arguments satisfying S1 [because I believe that S1 implies R1] and that its results will always satisfy \nS2 [because R2 implies S2]. In the latter case, the programmer is taking responsibility for both assertions \n(so .l makes sense in both cases), while the additional responsibility for checking that arguments satisfy \nS1 will be discharged elsewhere (by another cast, with a different label).  While contract checks in \nlatent systems seem intuitively to be much the same thing as typecasts in manifest systems, the formal \ncorrespondence is not immediate. This has led to some confusion in the community about the nature of \ncontracts. Indeed, as we will see, matters become yet murkier in richer languages with features such \nas dependency. Gronski and Flanagan [2007] initiated a formal investigation of the connection between \nthe latent and manifest worlds. They de.ned a core calculus, .C, capturing the essence of latent contracts \nin a simply typed lambda-calculus, and an analogous manifest calculus .H. To compare these systems, they \nintroduced a type\u00adpreserving translation f from .C to .H. What makes f interesting is that it is intuitively \na homomorphism: contracts over base types are mapped to casts at base type, and function contracts are \nmapped to function casts. The main result is that f preserves behavior, in the sense that if a term t \nin .C evaluates to a .nal result k, then so does its translation f(t). Our work extends theirs in two \ndirections. First, we strengthen their main result by introducing a new homomorphic translation . from \n.H to .C and proving a similar correspondence theorem for .. (We also give a new, more detailed, proof \nof the correspondence theorem for f.) This shows that the manifest and latent approaches are effectively \nequivalent in the nondependent case. Second, and more signi.cantly, we extend the whole story to allow \ndependent function contracts in .C and dependent arrow types in .H. Dependency is extremely handy in \ncontracts, as it allows for precise speci.cations of how the results of functions depend on their arguments. \nFor example, here is a contract that we might use with an implementation of vector concatenation: z1:Vec \n.. z2:Vec .. {z3:Vec | vlen z3 = vlen z1 + vlen z2} Adding dependent contracts to .C is easy: the dependency \nis all in the contracts and the types stay simple. We have just one signif\u00adicant design choice: should \ndomain contracts be rechecked when the bound variable appears the codomain contract? This leads to two \ndialects of .C, one which does recheck (picky .C) and one which does not (lax .C). The choice is not \nclear dependent con\u00adtract systems have typically used the lax rule, while the picky one is arguably more \ncorrect so we consider both. In .H, on the other hand, dependency signi.cantly complicates the metatheory, \nrequir\u00ading the addition of a denotational semantics for types and kinds to break a potential circularity \nin the de.nitions, plus an intricate sequence of technical lemmas involving parallel reduction to es\u00adtablish \ntype soundness. (Although Gronski and Flanagan worked only with nondependent .C and .H, Knowles and Flanagan \n[2009] showed soundness for a variant of dependent .H in which order of evaluation is nondeterministic \nand failed casts get stuck instead of raising blame. See Section 7.) Surprisingly, the tight correspondence \nbetween .C and .H breaks down in the dependent case: the natural generalization of the translations does \nnot preserve blame exactly. Indeed, we can Exact translations .f lax .C .H picky .C f. Inexact translations, \nmore blame in target language Figure 1. The axis of blame place .H between the two variants of .C on \nan axis of blame (Figure 1), where behavior is preserved exactly when moving left on the axis (from picky \n.C to .H to lax .C), but translated terms can blame more than their pre-images when moving right.1 The \ndiscrepancy arises in the case of abusive contracts, such as f :(N .. I ) .. {z:Int | f 0=0}, where I \n= {x:Int | true} and N = {x:Int | nonzero x}. This rather strange contract has the form f :c1 .. c2, \nwhere c2 uses f in a way that violates c1! In particular, if we apply it (in lax .C) to .f :Int . Int. \n0 and then apply the result to .x:Int. x and 5, the .nal result will be 5, since .x:Int. x does satisfy \nthe contract {x:Int | nonzero x} .. {y:Int | true} and 5 satis.es the contract {z :Int | (.x:Int. x)0 \n= 0}. However, the translation of f into .H inserts an extra check, wrapping the occurrence of f in the \ncodomain contract with a cast from N . I to I . I , which fails when the wrapped function is applied \nto 0. We discuss this phenomenon in greater detail in Section 4. In summary, our main contributions are \n(a) the translation . and a symmetric version of Gronski and Flanagan s behavioral correspondence theorem, \n(b) the basic metatheory of (CBV, blame\u00adsensitive) dependent .H, (c) dependent versions of f and . and \ntheir properties with regard to .H and both dialects of .C, and (d) a weaker behavioral correspondence \nin the dependent case. A long version of the paper with de.nitions and proofs in full can be found at \nhttp://www.cis.upenn.edu/~mgree/papers/ contracts_tr.pdf. 2. The nondependent languages We begin in this \nsection by de.ning the nondependent versions of .C and .H and continue in Section 3 with the translations \nbetween them. The dependent languages, dependent translations, and their properties are developed in \nSections 4, 5, and 6. Throughout the paper, rules pre.xed with an E or a F are operational rules for \n.C and .H, respectively. An initial T is used for .C typing rules; typing rules beginning with an S belong \nto .H. The language .C The language .C is the simply typed lambda calculus straightfor\u00adwardly augmented \nwith contracts. The most interesting feature is the contract term .c.l,l. , which, when applied to a \nterm t, dy\u00adnamically ensures that t and its surrounding context satisfy c. If t doesn t satisfy c, then \nthe positive label l will be blamed and the whole term will reduce to . l; on the other hand, if the \ncontext doesn t treat .c.l,l. t as c demands, then the negative label l. will be blamed and the term \nwill reduce to . l.. Contracts come in two forms: base contracts {x:B | t} over a base type B and higher\u00ad \n1 There might, in principle, be some other way of de.ning f and . that (a) preserves types, (b) maps \nbase contracts to re.nement-type casts and function contracts to arrow-type casts (and vice versa), and \n(c) induces an exact behavioral equivalence. After considering a number of alternatives, we conjecture \nthat no such f and . exist.  B ::= Bool | ... k ::= true | false | ... Figure 2. Base types and constants \nfor .C and .H Types and contracts T ::= B | T1 . T2 c ::= {x:B | t}| c1 .. c2 Terms, values, results, \nand evaluation contexts t ::= x | k | .x:T1. t2 | t1 t2 | . l |.c.l,l. | .{x:B | t1}, t2, k.l v ::= k \n| .x:T1. t2 |.c.l,l. |.c1 .. c2.l,l. v r ::= v |. l E ::= [] t | v [] | .{x:B | t}, [] , k.l Figure 3. \nSyntax for .C E CONST kv -.c [ k]](v) E BETA (.x:T1. t2) v -.c t2{x := v} E CCHECK .{x:B | t}.l,l. k \n-.c .{x:B | t}, t{x := k}, k.l E OK .{x:B | t}, true, k.l -.c k E FAIL .{x:B | t}, false, k.l -.c . l \n. ,l . (.c1 .. c2.l,l. v) v -.c .c2.l,l. (v (.c1.l. v )) E CDECOMP t1 -.c t2 E COMPAT E [t1] -.c E [t2] \nE BLAME E [. l] -.c . l Figure 4. Operational semantics for .C order contracts c1 .. c2, which check \nthe arguments and results of functions. The syntax of .C appears in Figure 3, with some common def\u00adinitions \n(shared with .H) in Figure 2. Besides the contract term .c.l,l. , .C includes .rst-order constants k, \nblame, and active checks .{x:B | t1}, t2, k.l . Active checks do not appear in source pro\u00adgrams; they \nare a technical artifact of the small-step operational semantics, as we explain below. Also, note that \nwe only allow con\u00adtracts over base types B: we have function contracts, like {x:Int |pos x} .. {x:Int \n| nonzero x}, but not contracts over functions, like {f:Bool . Bool | f true = f false}. We discuss this \nfurther in Section 8. Values v include abstractions, contracts, function contracts ap\u00adplied to values, \nand constants; a result r is either a value or . l for some l. We de.ne constants using three constructions: \nthe set KB , which contains constants of base type B; the type-assignment function tyc, which maps constants \nto .rst-order types of the form B1 . B2 . ... . Bn (and which is assumed to agree with KB ); and the \ndenotation function [ -] which maps constants to functions x:T . G G . t : T T VAR G . x : T T CONST \nG . k : tyc(k) G, x:T1 . t2 : T2 T LAM G . .x:T1. t2 : T1 . T2 G . t1 : T1 . T2 G . t2 : T1  T APP \nG . t1 t2 : T2 .c c : T T CONTRACT G ..c.l,l. : T . T T BLAME G .. l : T \u00d8. k : B \u00d8. t2 : Bool .c {x:B \n| t1} : B . t2 . t1{x := k}  T CHECKING \u00d8 . .{x:B | t1}, t2, k.l : B .c c : T x:B . t : Bool T BASEC \n.c {x:B | t} : B .c c1 : T1 .c c2 : T2 T FUNC .c c1 .. c2 : T1 . T2 . t2 . t1 t1 -.c * true implies \nt2 -.c * true T IMP . t1 . t2 Figure 5. Typing rules for .C from constants to constants (or blame, to \nallow for partiality). De\u00adnotations must agree with tyc. We assume that Bool is among the base types, \nwith KBool = {true, false}. The operational semantics is given in Figure 4. It includes six rules for \nbasic (small-step, call-by-value) reductions, plus two rules that involve evaluation contexts E (Figure \n3). The evaluation con\u00adtexts implement left-to-right evaluation for function application. If . l appears \nin the active position of an evaluation context, it is prop\u00adagated to the top level. As usual, values \n(and results) do not step. The .rst two basic rules are standard, implementing primitive reductions and \n\u00df-reductions for abstractions. In these rules, argu\u00adments must be values v. Since constants are .rst-order, \nwe know that when E CONST applies to a well-typed application, the argu\u00adment is not just a value, but \na constant. The rules E CCHECK, E OK, E FAIL and E CDECOMP, de\u00adscribe the semantics of contracts. In \nE CCHECK, base-type con\u00adtracts applied to constants step to an active check. Active checks include the \noriginal contract, the current state of the check, the con\u00adstant being checked, and a label to blame \nif necessary. If the check evaluates to true, then E OK returns the initial constant. If false, the check \nhas failed and a contract has been violated, so E FAIL steps the term to . l. Higher-order contracts \non a value v wait to be applied to an additional argument. When that argument has also been reduced to \na value v ., E CDECOMP decomposes the function cast: the argument value is checked with the argument \npart of the contract (switching positive and negative blame, since the context  Types S ::= {x:B | s1}| \nS1 . S2 Terms, values, results, and evaluation contexts s ::= x | k | .x:S1. s2 | s1 s2 | . l |.S1 . \nS2.l | .{x:B | s1}, s2, k.l w ::= k | .x:S1. s2 |.S1 . S2.l | .S11 . S12 . S21 . S22.l w q ::= w |. l \nF ::= [] s | w [] | .{x:B | s}, [] , k.l Figure 6. Syntax for .H is responsible for the argument), and \nthe result of the application is checked with the result contract. The typing rules for .C (Figure 5) \nare mostly standard. We give types to constants using the type-assignment function tyc. Blame expressions \nhave all types. Contracts are checked for well\u00adformedness using the judgment .c c : T , comprising the \nrules T BASEC, which requires that the checking term in a base contract return a boolean value when supplied \nwith a term of the right type, and T FUNC. Note that the predicate t in a contract {x:B | t} can contain \nat most x free, since we are considering only nondependent contracts for now. Contract application, like \nfunction application, is checked using T APP. The T CHECKING rule only applies in the empty context (ac\u00adtive \nchecks are only created at the top level during evaluation). The rule ensures that the contract {x:B \n| t1} has the right base type for the constant k, that the check expression t2 has a boolean type, and \nthat the check is actually checking the right contract. The latter condition is formalized by the T IMP \nrule: . t2 . t1{x := k} as\u00adserts that if t2 evaluates to true, then the original check t1{x := k}must \nalso evaluate to true. This requirement is needed for two rea\u00adsons: .rst, nonsensical terms like .{x:Int \n| pos x}, true, 0.l should not be well typed; and second, we use this property in showing that the translations \nare type preserving (see Section 5). This rule ob\u00adviously makes typechecking for the full internal language \nwith checks undecidable, but excluding checks recovers decidability. The language .H Our second core \ncalculus, nondependent .H, extends the simply typed lambda-calculus with re.nement types and cast expressions. \nThe syntax appears in Figure 6. Unlike .C, which separates con\u00adtracts from types, .H combines them into \nre.ned base types {x:B |s1} and function types S1 . S2. As for .C, we do not allow re\u00ad.nement types over \nfunctions, nor do we allow re.nements of re\u00ad.nements. Unre.ned base types B are not valid types; they \nmust be wrapped in a trivial re.nement, as the raw type {x:B | true}. The terms of the language are mostly \nstandard, including variables, the same .rst-order constants as .C, blame, abstractions, and appli\u00adcations. \nThe cast expression .S1 . S2.l dynamically checks that a term of type S1 can be given type S2. Like .C, \nactive checks are used to give a small-step semantics to cast expressions. The values of .H include constants, \nabstractions, casts, and function casts applied to values. Results are either values or blame. We give \nmeaning to constants as we did in .C, reusing [ -] . Type assignment is via tyh, which we assume produces \nwell-formed types. To keep the languages in sync, we require that tyh and tyc agree on type skeletons \n: if tyc(k)= B1 . B2, then tyh(k)= {x:B1 | s1}.{x:B2 | s2}. The small-step, call-by-value semantics in \nFigure 7 comprises six basic rules and two rules involving evaluation contexts F . Each rule corresponds \nclosely to its counterpart in .C. F CONST kw -.h [ k]](w) F BETA (.x:S1. s2) w2 -.h s2{x := w2} .{x:B \n| s1}.{x:B | s2}.l k -.h .{x:B | s2}, s2{x := k}, k.l F CCHECK F OK .{x:B | s}, true, k.l -.h k .{x:B \n| s}, false, k.l -.h . l F FAIL (.S11 . S12 . S21 . S22.l w) w . -.h F CDECOMP .S12 . S22.l (w (.S21 \n. S11.l w .)) s1 -.h s2 F COMPAT F [s1] -.h F [s2] F BLAME F [. l] -.h . l Figure 7. Operational semantics \nfor .H Notice how the decomposition rules compare. In .C, the term (.c1 .. c2.l,l. v) v decomposes into \ntwo contract checks: c1 checks the argument v . and c2 checks the result of the application. In .H the \nterm (.S11 . S12 . S21 . S22.l w) w . decomposes into two casts, but the behavior is a bit more subtle. \nThe contravari\u00adant check .S21 . S11.l w . makes w . a suitable input for w, while .S12 . S22.l checks \nthe result from w applied to (the cast) w . . Suppose S21 = {x:Int | pos x} and S11 = {x:B | nonzero \nx}. Then the check on the argument ensures that nonzero x -. * h true not, as one might expect, that \npos w . -. * true. While h it is easy to read off from a .C contract exactly which checks will occur \nat runtime, a .H cast must be dissected carefully to see ex\u00adactly which checks will take place. On the \nother hand, which label will be blamed is clearer with casts. The typing rules for .H (Figure 8) are \nalso similar to those of .C. Just as the .C rule T CONTRACT checks to make sure that the contract has \nthe right form, the .H rule S CAST ensures that the two types in a cast are well-formed and have the \nsame simple-type skeleton, de.ned as .-. : S . T (pronounced erase S ): .{x:B | s}. = B .S1 . S2. = .S1...S2. \nWe de.ne a similar operator, .-. : S . S (pronounced raw S), which trivializes all re.nements: .{x:B \n| s}. = {x:B | true}.S1 . S2. = .S1...S2. These operations apply to .C contracts and types in the natural \nway. Type well-formedness is similar to contract well-formedness in .C, though the SWF RAW case needs \nto be added to get things off the ground. The active check rule S CHECKING plays a role analogous to \nthe T CHECKING rule in .C, using the operational S IMP rule to guarantee that we only have sensible terms \nin the predicate position. An important difference is that .H has subtyping. The S SUB rule allows an \nexpression to be promoted to any well-formed su\u00adpertype. Re.nement types are supertypes if, for all constants \nof  . . s : S x:S . . S VAR . . x : S S CONST . . k : tyh(k) . S1 ., x:S1 . s2 : S2 S LAM . . .x:S1. \ns2 : S1 . S2 . . s1 : S1 . S2 . . s2 : S1 S APP . . s1 s2 : S2 . S1 . S2 .S1. = .S2. S CAST . ..S1 \n. S2.l : S1 . S2 . S S BLAME . .. l : S . . s : S1 . S2 . S1 <: S2 S SUB . . s : S2 \u00d8. k : {x:B | true} \n\u00d8. s2 : {x:Bool | true}.{x:B | s1}. s2 . s1{x := k} \u00d8 . .{x:B | s1}, s2, k.l : {x:B | s1} S CHECKING \n. S1 <: S2 .k .KB . . s1{x := k}. s2{x := k} SSUB REFINE .{x:B | s1} <: {x:B | s2} . S21 <: S11 . S12 \n<: S22 SSUB FUN . S11 . S12 <: S21 . S22 . s1 . s2 s1 -. * true implies s2 -. * truehh S IMP . s1 . \ns2 . S . {x:B | true} SWF RAW x:{x:B | true} . s : {x:Bool | true}. {x:B | s} SWF REFINE . S1 . S2 . \nS1 . S2 SWF FUN Figure 8. Typing rules for .H the base type, their condition evaluates to true whenever \nthe sub\u00adtype s condition evaluates to true. For function types, we use the standard contravariant subtyping \nrule. We do not consider source programs with subtyping, since this makes type checking undecid\u00adable2; \nsubtyping is just a technical device for ensuring type preser\u00ad 2 Flanagan [2006] and Knowles and Flanagan \n[2009] discuss trade-offs between static and dynamic checking that allow for decidable type systems and \nsubtyping. vation. Consider the following reduction: .{x:Int | true}.{x:Int | pos x}.l 1 -. * 1 h The \nsource term is well-typed at {x:Int | pos x}. Since it evaluates to 1, we would like to have . . 1: {x:Int \n| pos x}. To have type preservation in general, though, tyh(1) must be a subtype of {x:Int | s} whenever \ns{x := 1} -. * true. That is, constants of h base type must have most-speci.c types. One way to satisfy \nthis requirement is to set tyh(k)= {x:B | x = k} for k .KB ; then if s{x := k} -. * true, we have . tyh(k) \n<: {x:B | s}. h Standard progress and preservation theorems hold for .H. We can also obtain a semantic \ntype soundness theorem as a restriction of the one for dependent .H (Theorem 4.2). 3. The nondependent \ntranslations The latent and manifest calculi differ in a few respects. Obviously, .C uses contract application \nand .H uses casts. Second, .C con\u00adtracts have two labels positive and negative where .H contracts have \na single label. Finally, .H has a much richer type system than .C. Our . from .H to .C and Gronski and \nFlanagan s f from .C to .H must account for these differences. The interesting parts of the translations \ndeal with contracts and casts. Everything else is translated homomorphically, though the type annotation \non lambdas must be chosen carefully. For ., translating from .H s rich types to .C s simple types is \neasy: we just erase the types to their simple skeletons. The interesting case is translating the cast \n.S1 . S2.l to a contract by translating the pair of types together, ..(S1, S2).l,l . So . translates \n.H terms to .C terms and pairs of .H types to .C contracts: .({x:B | s1}, {x:B | s2})= {x:B | .(s2)}.(S11 \n. S12, S21 . S22)= .(S21, S11) .. .(S12, S22) We use the single label on the cast in both the positive \nand nega\u00adtive positions of the resulting contract. When we translate a pair of re.nement types, we produce \na contract that will check the predi\u00adcate of the target type (like F CCHECK); when translating a pair \nof function types, we translate the domain contravariantly (like F CDECOMP). For example, .{x:Int | nonzero \nx}..Int...Int..{y:Int | pos y}.l translates to .{x:Int | nonzero x} .. {y:Int | pos y}.l,l . Translating \nfrom .C to .H, we are moving from a simple type system to a rich one. The translation f (essentially \nthe same as Gronski and Flanagan s) generates terms in .H with raw types .H types with trivial re.nements, \ncorresponding to .C s simple types. Whereas the dif.culty with . is ensuring that the checks match up, \nthe dif.culty with f is ensuring that the terms in .C and .H will blame the same labels. We deal with \nthis problem by translating a single contract with two blame labels into two separate casts. Intuitively, \nthe cast carrying the negative blame label will run all of the checks in negative positions in the contract, \nwhile the cast with the positive blame label will run the positive checks. We let f(.c.l,l. )= .x:.c.. \n.f(c) ..c..l. (..c.. f(c).l x), where the translation of contracts to re.ned types is: f({x:B | t})= \n{x:B | f(t)}f(c1 .. c2)= f(c1) . f(c2) The operation of casting into and out of raw types is a kind of \nbulletproo.ng. Bulletproo.ng maintains the raw-type invariant: the positive cast takes x out of .c. and \nthe negative cast returns it there. For example, .{x:Int | nonzero x} .. {y:Int | pos y}.l,l.  translates \nto the .H term .f:.Int . Int.. .{x:Int | nonzero x}.{y:Int | pos y}..Int . Int..l. (..Int . Int..{x:Int \n| nonzero x}.{y:Int | pos y}.l f ). The domain of the negative cast checks that f s argument is nonzero \nwith ..Int..{x:Int | nonzero x}.l. . The domain of the positive cast does nothing, since .{x:Int | nonzero \nx}..Int..l has no effect. Similarly, the codomain of the negative cast does nothing while the codomain \nof the positive cast checks that the result is positive. Separating the checks allows .H to keep track \nof blame labels, mimicking .C. This embodies the idea of contracts as pairs of projections [Findler 2006]. \nNote that bulletproo.ng is overkill at base type: for example, .{x:Int | nonzero x}.l,l. translates to \n.x:.Int.. .{x:Int | nonzero x}..Int..l. (..Int..{x:Int | nonzero x}.l x). Only the positive cast does \nanything the negative cast into .Int. always succeeds. This asymmetry is consistent with .C, where base-type \ncontracts also ignore the negative label. Both f and . preserve behavior in a strong sense: if G . t \n: B, then either t and f(t) both evaluate to the same constant k or they both raise . l for the same \nl; and conversely for .. (Proofs are given in the long version of the paper.) Interestingly, we need \nto set up this behavioral correspondence before we can prove that the translations preserve well-typedness, \nbecause of the T CHECKING and S CHECKING rules. 4. The dependent languages We now extend .C to dependent \nfunction contracts and .H to de\u00adpendent functions. The changes are summarized in Figure 9 (for .C) and \nFigures 10 and 11 (for .H). Very little needs to be changed in .C, since contracts and types barely interact; \nthe changes to E CDECOMP and T FUNC are the important ones. Adding depen\u00addency to .H is more involved. \nIn particular, adding contexts to the subtyping judgment entails adding contexts to S IMP. To avoid a \ndangerous circularity, we de.ne closing substitutions in terms of a separate type semantics. Additionally, \nthe new F CDECOMP rule has a slightly tricky (but necessary) asymmetry, explained below. Dependent .C \nDependent .C has been studied since Findler and Felleisen [2002]; it received a very thorough treatment \n(with an untyped host lan\u00adguage) in Blume and McAllester [2006], was ported to Haskell by Hinze et al. \n[2006] and Chitil and Huch [2007], and was used as a speci.cation language in Xu et al. [2009]. Type \nsoundness is not particularly dif.cult, since types and contracts are kept separate. Our formulation \nfollows Findler and Felleisen [2002], with a few technical changes to make the proofs for f easier. The \nnew T REFINEC, T FUNC, and E CDECOMP rules in Fig\u00adure 9 suf.ce to add dependency to .C. To help us work \nwith the translations, we also make some small changes to the bindings in contexts, tracking the labels \non a contract check throughout the contract well-formedness judgment. Note that T FUNC adds l. ,l x:c1 \nto the context when checking the codomain of a func\u00adtion contract, swapping blame labels. We add a new \nvariable rule, l,l. T VARC, that treats x:c as if it were its skeleton, x:.c.. While unnecessary for \n.C, this new binding form helps f preserve types. (See Section 6.1). Two different variants of the E \nCDECOMP rule can be found in the literature: we call them lax and picky. The original rule in Findler \nand Felleisen [2002] is lax (like most other contract Contracts and contexts c ::= {x:B | t}| x:c1 .. \nc2 l,l. G ::= \u00d8| G, x:T | G, x:c Operational Semantics . ,l (.x:c1 .. c2.l,l. v) v -.c .c2{x := v .}.l,l. \n(v (.c1.l. v .)) E CDECOMPLAX E CDECOMPPICKY (.x:c1 .. c2.l,l. v) v . -.c ,l ,l . .c2{x := .c1.l. v .}.l,l. \n(v (.c1.l. v )) Typing rules l,l. x:T . G x:c . G T VART T VARC G . x : T G . x : .c. G .l,l. c c : T \n T CONTRACT G ..c.l,l. : T . T G, x:B . t : Bool  T REFINEC G .lc,l. {x:B | t} : B G .l. ,ll. ,l .l,l. \nc c1 : T1 G, x:c1 c c2 : T2 T FUNC G .l,l. c x:c1 .. c2 : T1 . T2 Figure 9. Changes for dependent .C \ncalculi): it does not recheck c1 when substituting v . into c2. Hinze ,l . et al. [2006] choose instead \nto be picky, substituting .c1.l. v into c2 because it makes their conjunction contract idempotent. We \ncan show (straightforwardly) that both enjoy standard progress and preservation properties. Below, we \nconsider translations to and from both dialects of .C: picky .C using only E CDECOMPPICKY in Sections \n5.1 and 6.2, and lax .C using only E CDECOMPLAX in Sections 5.2 and 6.1. Dependent .H Now we come to \nthe challenging part: dependent .H and its proof of type soundness.3 These results require the most complex \nmetathe\u00adory in the paper, because we need some strong properties about call-by-value evaluation. (The \nbene.t of a CBV semantics is a bet\u00adter treatment of blame. By contrast, Knowles and Flanagan [2009] cannot \ntreat failed casts as exceptions because that would destroy con.uence. They treat them as stuck terms.) \nThe needed extensions are detailed in Figures 10 and 11.4 3 The proof of type soundness for this system \nis signi.cantly different from the soundness proof in Knowles and Flanagan [2009], where the operational \nsemantics of .H is full, nondeterministic \u00df-reduction. At .rst glance, it might seem that our theorems \nfollow directly from the results for Knowles and Flanagan s language, since CBV is a restriction of full \n\u00df\u00adreduction. However, the reduction relation is used in the type system (in rule S IMP), so the type \nsystems for the two languages are not the same. For example, suppose the term bad contains a cast that \nfails. In our system {y:B | true} is not a subtype of {y:B | (.x:S. true) bad} because the contract evaluates \nto blame. However, the subtyping does hold in the Knowles and Flanagan system because the predicate reduces \nto true. 4 The semantics in these .gures is the same as that of Knowles and Flanagan [2009] except for \nthe evaluation relation, the treatment of blame, and a change to the type semantics that we discuss below. \n Types Denotations of types and kinds S ::= {x:B | s}| x:S1 . S2 . (.k .KB . s * -.h s . [ {x:B | s0}] \n.. .l s Operational semantics (.x:S11 . S12 . x:S21 . S22.l w) w . -.h .S12{x := .S21 . S11.l w .}. S22{x \n:= w .}.l (w (.S21 . S11.l w .)) Typing rules . . s1 :(x:S1 . S2). . s2 : S1 . . s1 s2 : S2{x := s2} \n., x:{x:B | true}. s : {x:Bool | true} . .{x:B | s} . . S1 ., x:S1 . S2 . . x:S1 . S2 ., x:{x:B | true}. \ns1 . s2 . .{x:B | s1} <: {x:B | s2} . . S21 <: S11 ., x:S21 . S12 <: S22 . . x:S11 . S12 <: x:S21 . \nS22 F CDECOMP S APP SWF REFINE SWF FUN SSUB REFINE SSUB FUN * .{}-.k:=sx0h* -.h s . [ x:S1 . S2] .. .q \n. [ S1] . sq . [ S2{x := q}] {x:B | s}. [ .] .. .k .KB . s{x := k}. [ {x:Bool | true}] x:S1 . S2 . \n[ .] .. S1 . [ .] ..q . [ S1] . S2{x := q}. [ .] Semantic judgments .s s.t. . |= s : . |= S1 <: S2 .. \n[ s(S1)]] . [ s(S2)]] . |= s : S .. s(s) . [ s(S)]] . |= S .. s(S) . [ .] k true) Figure 11. Type and \nkind semantics for dependent .H The .nal change generalizes S IMP to open terms. We must close these \nterms before we can compare their behavior, using closing substitutions s and reading . |= s as s satis.es \n. . Care is needed here to prevent the typing rules from becoming circular: the typing rule S SUB references \nthe subtyping judgment, the subtyping rule SSUB REFINE references the implication judg\u00adment, and the \nsingle implication rule S IMP has . |= s in a neg\u00adative position. To avoid circularity, . |= s must not \nrefer back to the other judgments. We can achieve this by building the syntactic rules on top of a ** \n.-. -.ss() s()ss12h denotational semantics for .H s types.5 The idea is that the seman\u00ad . . s1 . s2 tics \nof a type is a set of closed terms that is de.ned independently of S IMP the syntactic typing relation, \nbut that turns out to contain all closed h implies .s. (. |= true) true Closing substitutions well-typed \nterms of that type. Thus, in the de.nition of . |= s, s . [ S] .{x := s}|= s we quantify over a somewhat \nlarger set than strictly necessary not SCS EXT s{x := s} \u00d8|= \u00d8 SCS EMPTY just the syntactically well-typed \nterms of appropriate type (which x:S, . |= are all the ones that will ever appear in programs), but all \nsemanti- Figure 10. Changes for dependent .H First, we enrich the type system with dependent function \ntypes, x:S1 . S2, where x may appear in S2. A new application rule, S APP, substitutes the argument into \nthe result type of the applica\u00adtion. We generalize SWF REFINE to allow re.nement-type predi\u00adcates that \nuse variables from the enclosing context. SWF FUN adds the bound variable to the context when checking \nthe codomain of function types. In SSUB FUN, subtyping for dependent function types remains contravariant, \nbut we also add the argument variable to the context with the smaller type. We need to be careful when \nimplementing higher-order depen\u00ad dent casts in the rule F CDECOMP. As the cast decomposes, the variables \nin the codomain types of such a cast must be replaced. However, this substitution is asymmetric; on one \nside, we cast the argument and on the other we do not. This behavior is required for type soundness. \nFor suppose we have . . x:S11 . S12 and . . x:S21 . S22 with equal skeletons, and values . . w : (x:S11 \n. S12) and . . w . : S21. Then . . (.x:S11 . S12 . x:S21 . S22.l w) w . : S22{x := w .}. When we decom\u00adpose \nthe cast, we must make some substitution into S12 and S22, but which? It is clear that we must substitute \nw . into S22, since the original application has type S22{x := w .}. Decomposing the cast will produce \nthe inner application . . w (.S21 . S11.l w .): *** -. -. -.h h h cally well-typed ones. The type semantics \nappears in Figure 11. It is de.ned by in\u00adduction on type skeletons. For re.nement types, terms must either \ngo to blame or produce a constant that satis.es (all instances of) the given predicate. For function \ntypes, well-typed arguments must go to well-typed results. By construction, these sets include only terminating \nterms that do not get stuck. 4.1 Lemma [Strong normalization]: If s . [ S] , then there exists a q such \nthat s q i.e., either s w or s .l. The main things we want to know about the type semantics is semantic \ntype soundness: if \u00d8. s : S, then s . [ S] . However, to prove this, we must generalize it. In the bottom \nof Figure 11, we de.ne three semantic judgements that correspond to each of the three typing judgments. \n(Note that the third one requires the de.nition of a kind semantics that picks out well\u00ad behaved types \nthose whose embedded terms belong to the type semantics.) We then show that the typing judgments imply \ntheir semantic counterparts. 5 Knowles and Flanagan [2009] also introduce a type semantics, but it differs \nfrom ours in two ways. First, because they cannot treat blame as an exception (because their semantics \nis nondeterministic) they must restrict the terms in the semantics to be those that only get stuck at \nfailed casts. They S12{x := .S21 . S11.l w .}. In order to apply the codomain cast, we must substitute \n.S21 . S11.l w . into S12. This calculation de\u00ad do so by requiring the terms to be well-typed in the \nsimply typed lambda calculus after all casts have been erased. Secondly, their type semantics does not \nrequire strong normalization. However, it is not clear whether their termines the form of F CDECOMP. \nlanguage actually admits nontermination they include a .x constant, but their semantic type soundness \nproof appears to break down in that case.  Result correspondence Contract / type correspondence k k \n: B .. k .KB {x:B | t}~l,l. {x:B | s} : B .. v w : T1 . T2 .. .t ~ s : T1. vt ~ ws : T2 .k .KB . t{x \n:= k}~ s{x := k} : Bool .l .l : T x:c1 .. c2 ~l,l. x:S1 . S2 : T1 . T2 .. Term correspondence c1 ~l. \n,l S1 : T1 . .t ~ s : T1. t ~ s : T .. t -. * c r . s -. * q . r q : T ,lh c2{x := .c1.l. t}~l,l. S2{x \n:= ..S1.. S1.l. s} : T2 Figure 12. A blame-exact result/term correspondence Dual closing substitutions \n8 >>>>< >>>>: .x:T . G.d1(x) ~ d2(x): T .x:c l,l. . G.d1(x)= .d1(c).l,l. t  4.2 Theorem [Semantic type \nsoundness]: 1. If . . S1 <: S2 then . |= S1 <: S2. : S then . |= s G |= d .. d2(x)= ..c.. d2(S).l s 2. \nIf . . s : S. s.t. S = f(G .lc,l. c : .c.) 3. If . . S then . |= S. . t ~ s : .c. The .rst part follows \nby induction on the subtyping judgment. However, we run into some complications with the second and third \nparts (which must be proven together). The crux of the dif.culty lies with the S APP rule. Suppose the \napplication s1 s2 was well typed and s1 . [ x:S1 . S2] and s2 . [ S1] . According to S APP, the application \ns type is S2{x := s2}. By the type semantics de.ned in Figure 11, if s1 . [ x:S1 . S2] , then s1 q . \n[ S2{x := q}] for any q . [ S1] . Sadly, s2 isn t necessarily a result! We do know, however, that s2 \n. [ S1] , so s2 -. * q2 h by strong normalization (Lemma 4.1). We need to ask, then, how the type semantics \nof S2{x := s2} and S2{x := q2} relate. We can show that the two type semantics are in fact equal using \na parallel reduction technique. We de.ne a parallel reduction relation . on terms and types that allows \nredices in different parts of a term (or type) to be reduced in the same step, and we prove that types \nthat parallel-reduce to each other like S2{x := s2} and S2{x := q2} have the same semantics (see the \nlong version for details). The de.nition of parallel reduction is standard, though we need to be careful \nto make it respect our call-by-value reduction order: the \u00df-redex (.x:S1. s1) s2 should not be contracted \nunless s2 is a value, since doing so can change the order of effects. (Other redices within s1 and s2 \ncan safely reduce.) The proof requires a longish sequence of technical lemmas that essentially show that \n. commutes with -. * . Since the proofs require fussy symbol h manipulation, we ve done these proofs \nin Coq. Our development is available at http://www.cis.upenn.edu/~mgree/papers/ lambdah_parred.tgz. An \nalternative strategy would be to use . in the typing rules and -.h in the operational semantics. This \nwould simplify some of our metatheory, but it would complicate the speci.cation of the language. Using \n-.h in the typing rules gives a clearer intuition and keeps the core system small. Theorem 4.2 gives \nus type soundness, and it combines with Lemma 4.1 for an even stronger result: well-typed programs always \nevaluate to values of appropriate (semantic) type. 5. Exact translations Translations moving left on \nthe axis of blame from picky .C to .H, and from .H to lax .C are exact. That is, we can show a tight \nbehavioral correspondence between terms and their translations (see Figure 12). We read t ~ s : T as \nt corresponds with s at type T . Terms corresponding at B both go to k .KB or to .l. 5.1 Translating \npicky .C to .H: dependent f The full de.nition of f is in Figure 14. One point to note is that, in the \ndependent case, we need to translate derivations of well\u00adformedness and well-typing of .C contexts, terms, \nand contracts Figure 13. Blame-exact correspondence for f from picky .C into .H contexts, terms, and \ntypes. We translate derivations to en\u00adsure type preservation, translating T VART and T VARC deriva\u00adtions \ndifferently: we leave variables of simple type alone, but we cast variables bound to contracts. To see \nwhy we need this distinction, consider the function contract f :(x:{x:Int | pos x} ..{y:Int | true}) \n.. {z:Int |f 0=0}. Note that this contract is well-formed in .C, but that the codomain abuses the bound \nvariable. A naive translation will not be well-typed in .H: f 0 will not be typeable when f has type \nx :{x:Int | pos x}..Int., since f only accepts positive arguments. The problem is that SWF FUN can add \na (possibly re.ned) type to the context when checking the codomain, so we need to restore the variables \nhave raw types invariant. By tracking which variables were bound by contracts in .C, we can be sure to \ncast them to raw types when they re referenced. We therefore translate the contract above to f :S .{z:Int \n| (.S ..Int . Int..l. f )0 = 0}, where S = x:{x:Int | pos x}..Int.. This l,l. (partially) motivates the \nx:c binding form in dependent .C. Constants translate to themselves. One technical point: to main\u00adtain \nthe raw type invariant, we need .H s higher-order constants to have typings that can be seen as raw by \nthe subtyping relation, i.e., . . tyh(k) <: .tyc(k).. This slightly restricts the types we might assign \nto our constants, e.g., we cannot say tyh(sqrt)= x:{x:Float | x = 0}.{y:Float | (y * y)= x}, since it \nis not the case that . . tyh(sqrt) <: .Float . Float.. Since its domain cannot be re.ned, [ sqrt] must \nbe de.ned for all k .KFloat, e.g., [ sqrt]](-1) must be de.ned. We ve already required that deno\u00adtations \nbe total over their simple types in .C, and .H uses the same denotation function [ -] , so this requirement \ndoes not seem too se\u00advere. We could instead translate k to .tyh(k) ..tyh(k)..l0 k; however, in this case \nthe nondependent fragments of the languages would no longer correspond exactly. We extend the term correspondence \nof Figure 12 to contracts and types, lifting the correspondences to open terms using dual l,l. closing \nsubstitutions. For a binding x:c . G, we use f to insert the negative cast (labelled with l.) and closing \nsubstitutions (in Figure 13) to insert the positive cast (labelled with l). Do not be confused by the \nlabel used for function contract correspondence this de.nition does, in fact, match up with closing substitutions. \nl,l. A binding x:c . G must have come from the domain of an application of T FUNC, so the labels on the \nbinding are already swapped when f or G |= d sees them. In the de.nition of function contract correspondence, \nwe swap manually whence the l. on the  Terms Contexts f(G1, x:T , G2 . x : T) = x f(. \u00d8) = \u00d8 f(G1, x:c \nl,l. , G2 . x : .c.) = .f(G1 .l,l. c c : .c.) . .c..l. x f(. G, x:T ) = f(. G), x:.T . f(G . k : T) = \nk f(. G, x:c l,l. ) = f(. G), x:f(G .l,l. c c : .c.) f(G . .x:T1. t2 : T1 . T2) = .x:.T1.. f(G, x:T1 \n. t2 : T2) f(G . t1 t2 : T2) = f(G . t1 : T1 . T2) f(G . t2 : T1) f(G . .l : T) = .l f(\u00d8 . .c, t, k.l \n: B) = .f(\u00d8 .l,l. c c : B), f(\u00d8 . t : Bool), k.l f(G . .c.l,l. : T) = .x:.c.. .f(G .l. ,l c c : T ) . \n.c..l. (..c. . f(G .l,l. c c : T ).l x) where x is fresh Types f(G .l,l. c {x:B | t} : B) f(G .l,l. c \nx:c1 .. c2 : T1 . T2) = = {x:B | f(G, x:B . t : Bool)} x:f(G .l. ,l c c1 : T1) . f(G, x:c1 l. ,l .l,l. \nc c2 : T2) Figure 14. The translation f from dependent .C to dependent .H  Term translation Contract \n/ type correspondence .(x)= x .(k)= k .(.l)= .l .(.S1 . S2.l )= ..l (S1, S2).l,l .(.x:S. s)= .x:.S...(s) \n.(s1 s2)= .(s1) .(s2) .(.{x:B | s1}, s2, k.l )= .{x:B | .(s1)},.(s2), k.l Type-to-contract translation \n.l ({x:B | s1}, {x:B | s2})= {x:B | .(s2)} .l (x:S11 . S12, x:S21 . S22)= x:.l (S21, S11) .. .l (S12{x \n:= .S21 . S11.l x}, S22) Figure 15. . mapping dependent .H to dependent .C inserted cast. It helps to \nthink of polarity in terms of position rather than the presence or absence of a prime.  5.1 Theorem \n[Behavioral correspondence]: If . G, then: 1. If f(G . t : T )= s then G . t ~ s : T . 2. If f(G .lc,l. \nc : T )= S then G . c ~l,l. S : T .  We can now prove that f preserves types, using Theorem 5.1 to show \nthat f preserves the implication judgment. 5.2 Theorem [Type preservation]: If f(. G) = ., then: 1. . \n.. 2. If f(G . t : T )= s then . . s : .T .. 3. If f(G .lc,l. c : T )= S then . . S.  5.2 Translating \n.H to lax .C: dependent . In this section, we formally de.ne . for the dependent versions of lax .C and \n.H. We sketch proofs that . is type preserving and induces behavioral correspondence. The full de.nition \nof . is in Figure 15. Most terms are translated homomorphically. In abstractions, the annotation is translated \nby erasing the re.ned .H type to its skeleton. As we mentioned in Section 3, the trickiest part is the \ntranslation of casts between function types: when generating the codomain contract from a cast between \ntwo function types, we perform the same asymmetric substitution as F CDECOMP. Since . inserts new casts, \nwe need to pick a blame label: .(.S1 . S2.l ) passes l as an index to .l (S1, S2). We reuse the term \ncorrespondence t ~ s : T (Figure 12) and de.ne a new contract/cast correspondence c ~ S1 .l S2 : T (Figure \n16), relating contracts and pairs of .H types. This corre\u00adspondence uses the term correspondence in the \nbase type case and {x:B | t}~{x:B | s1}.l {x:B | s2} : B .. .k .KB . t{x := k}~ s2{x := k} : Bool x:c1 \n.. c2 ~ x:S11 . S12 .l S21 . S22 : T1 . T2 .. c1 ~ S21 .l S11 : T1 . .t ~ s : T1. c2{x := t}~ S12{x := \n.S21 . S11.l s}.l S22{x := s} : T2 Figure 16. Blame-exact correspondence for . into lax .C follows the \npattern of F CDECOMP in the function case. Since it in\u00adserts a cast in the function case, we index the \nrelation with a label, just like .. We de.ne closing substitutions ignoring the contracts in the context; \nwe lift the relation to open terms in the standard way. We .rst show that s and .(s) behaviorally correspond, \nand then we can prove that . is type preserving, using the behavioral correspondence to show that . preserves \nimplication. 5.3 Theorem [Behavioral correspondence]: 1. If . . s : S then .... .(s) ~ s : .S.. 2. \nIf . . S1 and . . S2, where .S1. = .S2. = .S., then .... .l (S1, S2) ~ S1 .l S2 : .S. (for all l).  \n 5.4 Theorem [Type preservation for .]: 1. If . . s : S then .... .(s): .S.. 2. If . . S1, . . S2, \nwhere .S1. = .S2. = T, then ....lc,l. .l (S1, S2): T .  6. Inexact translations The same translations \nf and . can be used to move right on the axis of blame (Figure 1). However, in this direction the images \nof these translations blame strictly more than their pre-images. 6.1 Translating lax .C to .H Things \nget more interesting when we consider the translation f from lax .C to dependent .H. We can prove that \nit preserves types (for terms without active checks), but we can only show a weaker behavioral correspondence: \nsometimes lax .C terms terminate with values when their f-images go to blame. This weaker property is \na consequence of bulletproo.ng, the asymmetrically substituting F CDECOMP rule, and the extra casts inserted \nfor type preservation (i.e., for T VARC derivations). We can show the behavioral correspondence using \na blame\u00adinexact logical relation, de.ned in Figure 17. The behavioral corre\u00ad  Value correspondence k \n. k : B .. k .KB v . w : T1 . T2 .. .t ~. s : T1. vt ~. ws : T2 Term correspondence t ~. s : T .. s -. \n* .l . (t -. * v . s -. * w . v . w : T ) h ch Contract / type correspondence {x:B | t}~. {x:B | s} \n: B .. .k .KB . t{x := k}~. s{x := k} : Bool x:c1 .. c2 ~. x:S1 . S2 : T1 . T2 .. c1 ~. S1 : T1 . .t \n~. s : T1. c2{x := t}~. S2{x := s} : T2 Dual closing substitutions G |=. d .. .x . dom(G).d1(x) ~. d2(x): \n.G(x). Figure 17. Blame-inexact correspondence for f from lax .C spondence here, though weaker than before, \nis still pretty strong: if t ~. s : B (read t blames no more than s at type B ), then ei\u00adther s -. * \n.l or t and s both go to k .KB . This correspondence h differs slightly in construction from the earlier \nexact one we de\u00ad.ne . as a relation on values, while is a relation on results. Doing so simpli.es our \ninexact treatment of blame. We again use the term correspondence to relate contracts and .H types. We \nthen lift the correspondences to open terms (Figure 17). Closing substi\u00adtutions map variables to corresponding \nterms of appropriate type. l,l. Note that closing substitutions ignore the contract part of x:c bindings, \ntreating them as if they were x:.c.. Since .H terms can go to blame more often than corresponding lax \n.C terms, we can add extra casts to .H terms. We formalize this in the following lemma, which captures \nthe asymmetric treat\u00adment of blame by the ~. relation. We use it to show that the cast substituted in \nthe codomain by F CDECOMP does not affect behav\u00adioral correspondence. Note that the statement of the \nlemma requires that the types of the cast correspond to some contracts at the same type T , but we never \nuse the contracts in the proof they witness the well-formedness of the .H types. 6.1 Lemma [Extra casts]: \nIf t ~. s : T and c1 ~. S1 : T and c2 ~. S2 : T , then t ~. .S1 . S2.l s : T.  6.2 Theorem [Behavioral \ncorrespondence]: If . G, then: 1. If f(G . t : T )= s then G . t ~. s : T . 2. If f(G .lc,l. c : T )= \nS then G . c ~. S : T.  We can also show type preservation for terms not containing active checks. (We \ndon t know that translated active checks are well typed, because Theorem 6.2 isn t strong enough to preserve \nthe implication judgment. We only expect these checks to occur at runtime, so this is good enough: f \npreserves the types of source programs.) 6.3 Theorem [Type preservation]: For programs without active \nchecks, if f(. G) = ., then: 1. . .. 2. . . f(G . t : T ): .T .. 3. . . f(G .lc,l. c : T ).  To see \nthat the f in Figure 14 does not give us exact blame, let us look at two examples; in both cases, a lax \n.C term goes to a value Contract / type correspondence {x:B | t}~. {x:B | s1}.{x:B | s2} : B .. .k .KB \n. t{x := k}~. s2{x := k} : Bool x:c1 .. c2 ~. x:S11 . S12 . x:S21 . S22 : T1 . T2 .. c1 ~. S21 . S11 \n: T1 . .l..t ~. s : T1.  c2{x := t}~. S12{x := .S21 . S11.l s}. S22{x := s} : T2 Dual closing substitutions \nG |= d .. .x . dom(G).d1(x) ~. d2(x): .G(x). Figure 18. Blame-inexact correspondence for . into picky \n.C while its translation goes to blame. In the .rst example, blame is raised in .H due to bulletproo.ng. \nIn the second, blame is raised due to the extra cast from the translation of T VARC. For the .rst, let \nc = f:(x:{x:Int | true} .. {y:Int | nonzero y}) .. {z :Int | f 0=0}S1 = x:{x:Int | true}.{y:Int | nonzero \ny}S = f(\u00d8.lc,l c :(Int . Int) . Int) = f :S1 .{z :Int | (.S1 ..S1..l f )0 = 0}. We .nd .c.l,l (.f.0) \n(.x.0) -. c * 0 but (.x :.c.. .S . .S..l (..S.. S.l x)) (.f.0) (.x.0) -. * .l. For the second, h let \nc . = f:(x:{x :Int | nonzero x} .. {y:Int | true}) .. {z:Int | f 0=0}S1 . = x:{x:Int | nonzero x}.{y:Int \n| true} S.. = f(\u00d8.c l,l c :(Int . Int) . Int) = f :S1 . .{z:Int | (.S1 . ..S1...l f )0 = 0}. ..l,l ... \n.S. We .nd .c (.f.0) (.x.0) -. c * 0 but (.x:.c . .c ...l (..S...c ...l x)) (.f.0) (.x.0) -. h * .l. \n 6.2 Translating .H to picky .C Terms in .H and their .-images in lax .C correspond exactly, as shown \nSection 5.2. When we change the operational semantics of .C to be picky, however, .(s) blames (strictly) \nmore often than s. Nevertheless, we can show an inexact correspondence, as we did for f and lax .C in \nSection 6.1. We use a logical relation ~. similar to ~., used for f into lax .C (Figure 17), though we \nreverse the asymmetry, allowing picky .C to blame more than .H. The proof follows the same general pattern: \nwe .rst show that it is safe to add extra contract checks, then the correspondence for well-typed terms. \nWe can also show type preservation for source programs (excluding active checks). 6.4 Lemma [Extra contracts]: \nIf t ~. s : T and c ~. S1 . S2 : T then .c.l,l. t ~. s : T .  6.5 Theorem [Behavioral correspondence]: \n1. If . . s : S then .... .(s) ~. s : .S.. 2. If . . S1 and . . S2, where .S1. = .S2. = .S., then .... \n.l (S1, S2) ~. S1 . S2 : .S..  6.6 Theorem [Type preservation for .]: For programs without active checks, \nif . ., then: 1. If . . s : S then .... .(s): .S.. 2. If . . S1, . . S2, where .S1. = .S2. = T , then \n....lc,l. .l (S1, S2): T .   Here is an example where a .H term reduces to a value while its .-image \nin picky .C term reduces to blame: S1 = f :S11 . S12 = f :(x:.Int..{y:Int | nonzero y}) ..Int. S2 = f \n:S21 . S22 = f :(x:.Int...Int.) .{z:Int | f 0=0} c =(S1, S2) .l = f :.l (S21, S11) .. .l (S12{f := .S21 \n. S11.l f }, S22) = f:(x:{x:Int | true} .. {y:Int | nonzero y}) .. {z:Int | f 0=0} Let w =(.f :(x:{x:Int \n| true}.{y:Int | nonzero y}). 0) and w . =(.x:{x:Int | true}. 0). On the one hand (.S1 . S2.l . w) w \n-. * h 0, while (.c.l,l .f :Int. 0) .x:Int. 0 -. * c .l. This means we cannot hope to use . as an exact \ncorrespondence between .H and picky .C. (Removing the extra cast . inserts into S12 doesn t affect our \nexample, since . ignores S12 here.) 6.3 Restricted calculi While f from lax .C and . to picky .C don \nt induce exact behav\u00adioral correspondences in the dependent case, some useful restric\u00adtions of the languages \nare equivalent. Gronski and Flanagan [2007] have already shown that f induces an exact correspondence \non the nondependent restriction. Since the lax/picky distinction requires dependency, exact equivalence \nin the nondependent case is a restriction of the results of Section 5. Moreover, the .rst-order dependent \nrestrictions of .C and .H also correspond exactly. The intuition here is that rechecking a .rst-order \ncontract in a new context can t change the result of checking .rst-order contracts can t be abusive. \nWe can show this for f using our existing parallel reduction for .H. We can show it for ., as well, using \na similar parallel reduction for .C. For this second proof we assume (but do not prove) that evaluation \nand reduction in .C commute as they do in .H. 7. Related work Conferences in recent years have seen a \nprofusion of papers on higher-order contracts and related features. This is all to the good, but for \nnewcomers to the area it can be a bit overwhelming, es\u00adpecially given the great variety of technical \napproaches. To help reduce the level of confusion, in Figure 19 we summarize the im\u00adportant points of \ncomparison between a number of systems that are closely related to ours. The largest difference is between \nlatent and manifest treat\u00adments of contracts i.e., whether contract checking (under what\u00adever name) is \na completely dynamic matter or whether it leaves a trace that the type system can track. Another major \ndistinction (labeled dep in the .gure) is the presence of dependent contracts or, in manifest systems, \ndependent function types. Latent systems with dependent contracts also vary in whether their semantics \nis lax or picky. Next, most contract calculi use a standard call-by-value order of evaluation ( eval \norder in the .gure). Notable exceptions include those of Hinze et al. [2006], which is embedded in Haskell, \nFlana\u00adgan [2006], which uses a variant of call-by-name, and Knowles and Flanagan [2009], which uses full \n\u00df-reduction (more on this below). Another point of variation ( blame in the .gure) is how con\u00adtract violations \nor cast failures are reported by raising an excep\u00adtion or by getting stuck. We also return to this below. \nThe next two rows in the table ( checking and typing ) con\u00adcern more technical points in the papers most \nclosely related to ours. In both Gronski and Flanagan [2007] and Flanagan [2006], the operational semantics \nchecks casts all in one go : s2{x := k} -. * true h .{x:B | s1}.{x:B | s2}.l k -.h k Such rules are formally \nawkward, and in any case they violate the spirit of a small-step semantics. Also, the formal de.nitions \nof .H in both Gronski and Flanagan [2007] and Flanagan [2006] involve a circularity between the typing, \nsubtyping, and implication rela\u00adtions. Knowles and Flanagan [2009] improve the technical presen\u00adtation \nof .H in both respects. In particular, they avoid circularity (as we do) by introducing a denotational \ninterpretation of types and maintain small-step evaluation by using a new syntactic form of partially \nevaluated casts (like most of the other systems). The main contributions of the present paper are (1) \nthe depen\u00addent translations f and . and their properties, and (2) the formula\u00adtion and metatheory of \ndependent .H. (Dependent .C is not a con\u00adtribution on its own: many similar systems have been studied, \nand in any case its properties are simple.) The nondependent part of our f translation essentially coincides \nwith the one studied by Gronski and Flanagan [2007], and our behavioral correspondence theorem is essentially \nthe same as theirs. Our . translation completes their story for the nondependent case, establishing a \ntight connection be\u00adtween the systems. The full dependent forms of f and . studied here are novel, as \nis the observation that the correspondence be\u00adtween the latent and manifest worlds is more problematic \nin this setting. Our formulation of .H is most comparable to that of Knowles and Flanagan [2009], but \nthere are some signi.cant differences. First, our cast-checking constructs are equipped with labels, \nand failed casts go to explicit blame i.e., they raise labeled exceptions. In the .H of Knowles and Flanagan \n(though not the earlier one of Gronski and Flanagan), failed casts are simply stuck terms their progress \ntheorem says If a well-typed term cannot step, then either it is a value or it contains a stuck cast. \nSecond, their operational se\u00admantics uses full, non-deterministic \u00df-reduction, rather than speci\u00adfying \na particular order of reduction, as we have done. This signi.\u00adcantly simpli.es parts of the metatheory \nby allowing them to avoid introducing parallel reduction. We prefer standard call-by-value re\u00adduction \nbecause we consider blame as an exception a computa\u00adtional effect and we want to be able to reason about \nwhich blame will be raised by expressions involving many casts. The system studied by Ou et al. [2004] \nis also close in spirit to our .H. The main difference is that, because their system in\u00adcludes general \nrecursion, they restrict the terms that can appear in contracts to just applications involving prede.ned \nconstants: only pure terms can be substituted into types, and these do not in\u00adclude lambda-abstractions. \nOur system (like all of the others in Figure 19 see the row labeled any con ) allows arbitrary user\u00adde.ned \nboolean functions to be used as contracts. Our description of .C is ultimately based on .CON [Findler \nand Felleisen 2002], though our presentation is slightly different in its use of checks. Hinze et al. \n[2006] adapted Findler and Felleisen\u00adstyle contracts to a location-passing implementation in Haskell, \nusing a picky dependent function contract rule. Our .H type semantics in Section 4 is effectively a semantics \nof contracts. Blume and McAllester [2006] offers a semantics of contracts that is slightly different \nour semantics includes blame at every type, while theirs explicitly excludes it. Xu et al. [2009] is \nalso similar, though their contracts have no dynamic semantics at all: they are simply speci.cations. \nWe have discussed only a small sample of the many papers on contracts and related ideas. We refer the \nreader to Knowles and Flanagan [2009] for a more comprehensive survey. Another useful  latent systems \nmanifest systems FF02 HJL06 GF07 .C BM06 our .C GF07 .H F06 KF09 WF09 OTMW04 our .H (1) (2) (3) (4) (3) \n(5) (6) (7) (8) dep (9) . lax . picky \u00d7 (10) . either \u00d7 . . \u00d7 . . eval order CBV lazy CBV CBV CBV CBV \nCBN(11) full \u00df CBV CBV CBV blame (12) .l .l .l .l or . .l .l stuck stuck .l . .l checking (13) if if \n. active active . . active active if active typing (14) . . . n/a . \u00d7 \u00d7 . . . . any con (15) . . . . \n. . . . . \u00d7 . (1) Findler and Felleisen [2002]. (2) Hinze et al. [2006]. (3) Gronski and Flanagan [2007]. \n(4) Blume and McAllester [2006]. (5) Flanagan [2006]. (6) Knowles and Flanagan [2009]. (7) Wadler and \nFindler [2009]. (8) Ou et al. [2004]. (9) Does the system include dependent contracts or function types \n(.) or not (\u00d7) and, for latent systems, is the semantics lax or picky? (10) An unusual form of dependency, \nwhere negative blame in the codomain results in nontermination. (11) A nondeterministic variant of CBN. \n(12) Do failed contracts raise labeled blame (.l), raise blame without a label (.), get stuck, or sometimes \nraise blame and sometimes diverge (.)? (13) Is contract or cast checking performed using an active check \nsyntactic form (active), an if construct with a re.ned typing rule (if), or inlined by making the operational \nsemantics refer to its own re.exive and transitive closure (.)? (14) Is the typing relation well de.ned \n(i.e., for dependently typed systems, is it based on a type semantics or, as in WF09, a tagging scheme), \nor is the de.nition circular? (15) Are arbitrary user-de.ned boolean functions allowed as contracts or \nre.nements (.), or only built-in ones (\u00d7)? Figure 19. Comparison of related systems resource is Wadler \nand Findler [2007] (technically superceded by Wadler and Findler [2009], but with a longer related work \nsection), which surveys work combining contracts with type Dynamic and related features. There are also \nmany other systems that employ various kinds of precise types, but in a completely static manner. One \nnotable example is the work of Xu et al. [2009], which uses user-de.ned boolean predicates to classify \nvalues (justifying their use of the term contracts ) but checks statically that these predicates hold. \nSage [Gronski et al. 2006] and Knowles and Flanagan [2009] both support mixed static and dynamic checking \nof contracts, us\u00ading, e.g., a theorem prover. We have not addressed this aspect of their work, since \nwe have chosen to work directly with the core calculus .H, which for them was the target of an elaboration \nfunc\u00adtion. 8. Future work Our calculi are strongly normalizing; extending our results to sys\u00adtems that \nallow recursion is a natural next step. The changes seem nontrivial: with nontermination, inexact correspondences \nmust al\u00adlow not only more blame, but also more nontermination each ex\u00adtra check is another opportunity \nfor divergence. Most studies of contracts, including ours, only allow re.ne\u00adments of base types; however, \nBlume and McAllester [2006] and Xu et al. [2009] also allow re.nements of functions. This extension seems \nneeded if contracts are to be combined with polymorphism, since in this setting we may want to re.ne \ntype variables, which may later be substituted with types involving functions. We conjec\u00adture that dependent \n.H with function re.nements is sound, but it is not clear how the translations will need to be modi.ed. \nAcknowledgments Sewell and Zappa Nardelli s OTT tool was invaluable for orga\u00adnizing our de.nitions. We \nused Aydemir and Weirich s LNGen tool for the Coq development of parallel reduction. Brian Aydemir, Jo \nao Belo, Chris Casinghino, Nate Foster, and the POPL review\u00aders gave us helpful comments. Our work has \nbeen supported by the National Science Foundation under grants 0702545 A Practical Dependently-Typed \nFunctional Programming Language, 0910786 TRELLYS, 0534592, Linguistic Foundations for XML View Update \nand 0915671, Contracts for Precise Types. References Matthias Blume and David A. McAllester. Sound and \ncomplete models of contracts. Journal of Functional Programming, 16(4-5):375 414, 2006. Olaf Chitil and \nFrank Huch. Monadic, prompt lazy assertions in haskell. In APLAS, pages 38 53, 2007. Robert Bruce Findler. \nContracts as pairs of projections. In Symposium on Logic Programming, pages 226 241, 2006. Robert Bruce \nFindler and Matthias Felleisen. Contracts for higher-order functions. In International Conference on \nFunctional Programming (ICFP), pages 48 59, 2002. Cormac Flanagan. Hybrid type checking. In POPL, pages \n245 256, 2006. Jessica Gronski and Cormac Flanagan. Unifying hybrid types and contracts. In Trends in \nFunctional Programming (TFP), 2007. Jessica Gronski, Kenneth Knowles, Aaron Tomb, Stephen N. Freund, \nand Cormac Flanagan. Sage: Hybrid checking for .exible speci.cations. In Scheme and Functional Programming \nWorkshop, pages 93 104, 2006. Arjun Guha, Jacob Matthews, Robert Bruce Findler, and Shriram Krishna\u00admurthi. \nRelationally-parametric polymorphic contracts. In DLS, pages 29 40, 2007. Ralf Hinze, Johan Jeuring, \nand Andres L\u00a8oh. Typed contracts for functional programming. In Functional and Logic Programming (FLOPS), \npages 208 225, 2006. Kenneth Knowles and Cormac Flanagan. Hybrid type checking. To appear in TOPLAS., \n2009. Bertrand Meyer. Eiffel: the language. Prentice-Hall, Inc., 1992. ISBN 0-13-247925-7. Xinming Ou, \nGang Tan, Yitzhak Mandelbaum, and David Walker. Dynamic typing with dependent types. In IFIP TCS, pages \n437 450, 2004. Sam Tobin-Hochstadt and Matthias Felleisen. The design and implementa\u00adtion of typed scheme. \nIn Principles of Programming Languages (POPL), pages 395 406, 2008. Philip Wadler and Robert Bruce Findler. \nWell-typed programs can t be blamed. In Workshop on Scheme and Functional Programming, 2007. Philip Wadler \nand Robert Bruce Findler. Well-typed programs can t be blamed. In European Symposium on Programming (ESOP), \npages 1 16, 2009. Dana N. Xu, Simon Peyton Jones, and Koen Claessen. Static contract checking for haskell. \nIn Principles of Programming Languages (POPL), pages 41 52, 2009.    \n\t\t\t", "proc_id": "1706299", "abstract": "<p>Since Findler and Felleisen introduced <i>higher-order contracts </i>, many variants have been proposed. Broadly, these fall into two groups: some follow Findler and Felleisen in using <i>latent </i> contracts, purely dynamic checks that are transparent to the type system; others use <i>manifest </i> contracts, where <i>refinement </i> types record the most recent check that has been applied to each value. These two approaches are commonly assumed to be equivalent---different ways of implementing the same idea, one retaining a simple type system, and the other providing more static information. Our goal is to formalize and clarify this folklore understanding.</p> <p>Our work extends that of Gronski and Flanagan, who defined a latent calculus &#955; <sub>C </sub> and a manifest calculus &#955; <sub>H </sub>, gave a translation &#966; from &#955; <sub>C </sub> to &#955; <sub>H </sub>, and proved that, if a &#955; <sub>C </sub> term reduces to a constant, then so does its &#966;-image. We enrich their account with a translation &#936; from &#955; <sub>H </sub> to &#955; <sub>C </sub> and prove an analogous theorem.</p> <p>We then generalize the whole framework to <i>dependent contracts </i>, whose predicates can mention free variables. This extension is both pragmatically crucial, supporting a much more interesting range of contracts, and theoretically challenging. We define dependent versions of &#955; <sub>H </sub> and two dialects (\"lax\" and \"picky\") of &#955; <sub>C </sub>, establish type soundness---a substantial result in itself, for &#955; <sub>H </sub>---and extend &#966; and &#936; accordingly. Surprisingly, the intuition that the latent and manifest systems are equivalent now breaks down: the extended translations preserve behavior in one direction but, in the other, sometimes yield terms that blame more.</p>", "authors": [{"name": "Michael Greenberg", "author_profile_id": "81406593888", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1911117", "email_address": "", "orcid_id": ""}, {"name": "Benjamin C. Pierce", "author_profile_id": "81100303310", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1911118", "email_address": "", "orcid_id": ""}, {"name": "Stephanie Weirich", "author_profile_id": "81100093135", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1911119", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706341", "year": "2010", "article_id": "1706341", "conference": "POPL", "title": "Contracts made manifest", "url": "http://dl.acm.org/citation.cfm?id=1706341"}