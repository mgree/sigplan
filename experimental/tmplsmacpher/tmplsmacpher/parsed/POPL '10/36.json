{"article_publication_date": "01-17-2010", "fulltext": "\n Modular Veri.cation of Security Protocol Code by Typing Karthikeyan Bhargavan C\u00b4Andrew D. Gordon edric \nFournet Microsoft Research Abstract We propose a method for verifying the security of protocol imple\u00admentations. \nOur method is based on declaring and enforcing in\u00advariants on the usage of cryptography. We develop cryptographic \nlibraries that embed a logic model of their cryptographic structures and that specify preconditions and \npostconditions on their functions so as to maintain their invariants. We present a theory to justify \nthe soundness of modular code veri.cation via our method. We implement the method for protocols coded \nin F# and veri.ed using F7, our SMT-based typechecker for re.nement types, that is, types carrying formulas \nto record invariants. As illustrated by a series of programming examples, our method can .exibly deal \nwith a range of different cryptographic constructions and protocols. We evaluate the method on a series \nof larger case studies of protocol code, previously checked using whole-program analyses based on ProVerif, \na leading veri.er for cryptographic protocols. Our results indicate that compositional veri.cation by \ntypecheck\u00ading with re.nement types is more scalable than the best domain\u00adspeci.c analysis currently available \nfor cryptographic code. Categories and Subject Descriptors F.3.1 [Specifying and Verify\u00ading and Reasoning \nabout Programs]: Speci.cation techniques. General Terms Security, Design, Languages 1. Introduction Verifying \nthe Code of Cryptographic Protocols The problem of vulnerabilities in security protocol code is remarkably \nresistant to the success of formal methods. Consider, for example, the vulnera\u00adbility in the public-key \nprotocol of Needham and Schroeder (1978), .rst discovered by Lowe (1996) in his seminal paper on model\u00adchecking \nsecurity protocols. This is the staple example of count\u00adless talks and papers on tools for analyzing \nsecurity protocols. It is hence well known in the formal methods research community, and many tools can \nnow discover it. In spite of these talks, papers, and tools, Cervesato et al. (2008) discovered that \nthe IETF issued a public-key variant of Kerberos, shipped by multiple vendors, con\u00adtaining essentially \nthe same vulnerability. What to do? Our position is that formal tools are more likely to .nd such problems \nif they run directly on security protocol code. Most current tools require a model described in some \nformalism, such as a process algebra or a modal logic, but designers of new or revised protocols are \nresistant to writing such models. They are more concerned with functional properties like interoperability \nand Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n10, January 17 23, 2010, Madrid, Spain. Copyright c &#38;#169; 2010 ACM 978-1-60558-479-9/10/01. . . \n$10.00 so typically the .rst (and only) formal descriptions of protocol behaviour are the implementation \ncode itself. Another reason to analyze code rather than models arises from gaps between the two: even \nif a model is veri.ed, the corresponding code may deviate, and contain vulnerabilities absent from the \nmodel. Several recent projects tackle the problem of verifying security protocol code. The pioneers are \nGoubault-Larrecq and Parrennes (2005) who use a tool to analyze C code (written in their group) for the \nNeedham-Schroeder public key protocol. Another early tool is FS2PV (Bhargavan et al. 2006b), which compiles \nimplementation code in F# into the applied pi calculus, for analysis with ProVerif (Blanchet 2001), a \nstate-of-the-art domain-speci.c prover. In terms oflinesofcodeanalyzed,thecombinationof FS2PV andProVerifis \nprobably by now the leading tool chain for security protocol code. Several substantial case studies have \nyielded F# reference imple\u00admentations that interoperate with existing implementations and are veri.ed \nwith FS2PV and ProVerif; these case studies include WS-Security (Bhargavan et al. 2006a), CardSpace (Bhargavan \net al. 2008b), and TLS (Bhargavan et al. 2008a). Towards Modular Veri.cation It is challenging to verify \nsecurity properties by compositional analysis. In particular, for systems in\u00advolving cryptographic communication \nprotocols, realistic attacker models tend to break modularity and abstraction: the attacker may interact \nat different layers in the protocol stack, for instance by injecting low-level network messages and controlling \nhigh-level actions at the application layer. Moreover, the attacker may com\u00adpromise parts of the system, \nfor instance gaining access to some cryptographic keys, and we are especially interested in the security \nproperties that still hold in such situations. Accordingly, all pro\u00adtocol veri.cation tools to date rely \non high-complexity algorithms that operate on a complete description of the protocol. The .gure above \npresents the structure of our CardSpace imple\u00admentation (our main case study), with one box for each \nF# module. Intuitively, the security properties for these modules are largely in\u00addependent. Still, the \nearlier veri.cation using FS2PV ignores this programming structure and passes a single, giant, untyped \npi pro\u00adcess to ProVerif. On the one hand, ProVerif scales surprisingly well: it often succeeds on input \n.les orders of magnitude longer than the examples in its test suite. On the other, its whole-program \nanaly\u00adsis has long run times on large case studies such as CardSpace and TLS. Analysis may take hours, \nor diverge, and small changes in input .les have unpredictable effects on run time.  In this paper, \nwe aim for a modular and scalable technique that avoids whole-program analysis. We develop a new methodology, \nbased on logical invariants for the cryptographic structures arising in security protocols. We show how \nto implement this methodology by typechecking with re.nement types, and make several improve\u00adments to \nthe existing typechecker F7 (Bengtson et al. 2008). By proposing a new pattern of using F7 we intend \nthat this paper may vindicate the promise of our initial work on re.nement types for secure implementations, \nand establish that F7 supports scalable and .exible veri.cation. It is .exible because we can formalize \nas wide a range of cryptographic operations as in FS2PV, for example. It is scalable because the time \nconsuming part of analysis, automated theorem proving, is done compositionally by repeatedly calling \nan external solver on relatively small logical problems. Our Method: Invariants for Cryptographic Structures \nAs in the standard method originated by Dolev and Yao (1983), we model cryptographic structures as elements \nof a symbolic algebra. As in other logical approaches (for example, Paulson 1998, Cohen 2000, and Blanchet \n2001), we rely on event predicates to record progress through a protocol and on a public predicate to \nindicate whether cryptographic structures are known to the adversary. For example, a byte array x is \nknown to the adversary only if the predicate Pub(x) holds. For an example of an event predicate, consider \nthe simple protocol where a and b share a key kab, and a authenticates each message sent to b by sending \nalso its hash keyed with kab. Then the event predicate Send(a, b,x) holds only if a has started the protocol \nwith the intention of sending message x to b. The .rst key idea of our approach is to rely systematically \non predicates to de.ne invariants on cryptographic structures. For ex\u00adample, byte array x exists in a \nprotocol run (whether or not it is public) only if the predicate Bytes(x) holds. For another example, \na key kab is shared between principals a and b for the purpose of run\u00adning our example protocol only \nif the predicate KeyAB(kab,a,b) holds. Our de.nitions support deduction of useful properties of these \ninvariants. For instance, in the simple case when all prin\u00adcipals are uncompromised and comply with the \nprotocol, our ex\u00adample predicates have the property that Bytes(hash kab x) and KeyAB(kab,a,b) imply that \nSend(a,b,x). This property captures the intuition that, if we can exhibit a byte array x that has been \nhashed with the key kab, which is known only to the protocol-compliant principals a and b, then it can \nonly have been hashed by a, during a run of the protocol in which a intends to send x to b. The second \nkey idea is to rely on pre-and post-conditions on cryptographic algorithms to ensure that the actual \ncode of a security protocol maintains these invariants. In our example, the precondition on applying \nthe hash function to argument kab and x is the formula KeyAB(kab,a, b).Send(a, b,x), and as a postcondition, \nwe obtain Bytes(hash kab x). As a consequence of the implication stated above, we obtain Send(a, b,x) \nas a postcondition of hash veri.cation with a key satisfying KeyAB(kab,a, b). We develop our invariants \nas a collection of predicates de.ned by axioms in .rst-order logic. The axioms form inductive de.ni\u00adtions \nof our predicates; during automated code veri.cation we rely on the axioms as well as additional formulas \nproved to hold in all reachable states. Our theory is inspired by prior work on proving secrecy and authentication \nby using domain-speci.c type systems (Abadi 1999; Gordon and Jeffrey 2003a). Intuitively, the essence \nof these type systems is a collection of inductive de.nitions that de.ne invariants preserved by computation. \nOur work can be understood, in part, as an extraction of this essence as direct inductive de.nitions \nof predicates, largely independent of the host language. Scalable Veri.cation by Typechecking with F7 \nWe implement and evaluate our method for F#, a dialect of ML. We rely on the F7 typechecker, which veri.es \nF# programs against types enhanced with logical re.nements. A re.nement type is a base type qual\u00adi.ed \nwith a logical formula; the formula can express invariants, preconditions, and postconditions. F7 relies \non type annotations, including re.nements, provided in speci.c interface .les. While checking code, F7 \ngenerates many logical problems which it solves by submitting to Z3, an external theorem prover for .rst-order \nlogic (de Moura and Bj\u00f8rner 2008). Finally, F7 erases all re.ne\u00adments and yields ordinary F# modules \nand interfaces. Our original paper on F7 (Bengtson et al. 2008) reported the underlying type theory, \nand a treatment of cryptography based on re.nements types, public and tainted kinds (Gordon and Jeffrey \n2003b), and seals (Morris 1973). It proposed re.nement types as a means for checking security properties \nin general; one example showed how to enforce access control by typing, others concerned a limited repertoire \nof cryptographic operations. The cryptographic library described in this paper is far more expressive. \nWe adopt F7 as a basis for implementing our method; re.ne\u00adment types are an excellent way to blend typechecking \nwith veri.\u00adcation. Still, although effective, both the theory of kinds and the use of seals necessarily \ndepend on details of the host programming lan\u00adguage. (Kinds are predicates on the syntax of types, and \nseals are . -abstractions, only available in certain languages.) Therefore, we implement our new method, \nbased on invariants for cryptographic structures, using F7 without seals and without the theory of kinds. \nAnother reason to choose F# is to enable a direct compari\u00adson with FS2PV and ProVerif, using previously-mentioned \nrefer\u00adence implementations for WS-Security and CardSpace. We develop our new method for cryptographic \nlibraries that extend those al\u00adready supported by FS2PV. Thus, we illustrate the .exibility of our method, \nand we can experimentally measure its performance versus ProVerif. Still, our method relies on user-supplied \nprogram invariants (within re.nement types), while ProVerif can infer in\u00advariants. The previous F7 theory \nbased on kinds and seals relied on a different cryptographic library, which did not allow a comparison \nwith FS2PV code. To the best of our knowledge, the reference im\u00adplementations checked with FS2PV and \nProVerif are currently the most sizeable body of veri.ed code for security protocols. So im\u00adplementing \nour method for F# and the same libraries as used with FS2PV allows for a direct comparison against what \nis probably the state of the art. Summary of Contributions (1) A new modular method for verifying the \ncode of security pro\u00adtocols, based on invariants for cryptographic structures. (2) An implementation \nfor the F# language by embedding invari\u00adants as re.nement types, veri.ed by the F7 typechecker. (3) \nA collection of well-typed re.ned modules for cryptographic primitives and constructions, more expressive \nthan in previous work with F7. (4) Experimental evidence that typechecking is faster and succeeds on \nmore protocol code than whole-program analysis with the leading automatic prover ProVerif.  Contents \nSection 2 reviews F7. Section 3 illustrates our method on an RPC protocol. Section 4 provides a theory \nto justify proofs of security by typechecking. Section 5 gives examples of crypo\u00adgraphic libraries. Section \n6 outlines more substantial case studies. Section 7 evaluates the performance of our implementation. \nSec\u00adtion 8 discusses related work.  A website http://research.microsoft.com/f7 hosts a technical report \nwith details, proofs, and examples omitted from this version of the paper, as well as our typechecker \nwith libraries and sample code for all examples. 2. RCF, the Formal Foundation for F7 (Review) We begin \nwith a review of the syntax and semantics of RCF (Bengt\u00adson et al. 2008), our core language for F#. RCF \nconsists of the standard Fixpoint Calculus (Gunter 1992; Plotkin 1985) augmented with local names and \nmessage-passing concurrency (as in the pi calculus) and with re.nement types. Formally, we slightly simplify \nthe original calculus by omitting the use of public and tainted kinds. We state some syntactic conventions. \nOur phrases of syntax may contain three kinds of identi.er: type variables a, value variables x, and \nnames a. We identify phrases of syntax up to consistent renam\u00ading of bound identi.ers. We write .{f/.} \nfor the capture-avoiding substitution of the phrase f for each free occurrence of identi.er . in the \nphrase .. We say a phrase is closed to mean that it has no free type or value variables (although it \nmay contain free names). Expressions and types of RCF contain formulas C to specify intended properties. \nSpeci.cation formulas are written in .rst-order logic with equality, with atomic formulas, p(M1,...,Mn), \nbuilt from a .xed set of predicate symbols p applied to RCF values. Syntax of FOL/F Formulas: C ::= p(M1,...,Mn) \n| (M = M') | (M = M') | False | True | C .C'| C .C'| C . C'|\u00acC | C . C'|.x.C |.x.C We recall standard \nde.nitions for (untyped) .rst-order logic with equality (see Paulson 2008 for example). An interpretation \nI is a pair (D,I) where D is a set, the domain, and I is an operation that maps function symbols to functions \non D and predicate sym\u00adbols to relations on D.A valuation V is a function from variables into D. An interpretation \nI satis.es a closed formula C, written |= I C when, for all valuations V , we have |= I ,VC, which is \nde\u00ad.ned by structural induction on C, following Tarski. We are only concerned with RCF-interpretations, \nthat is, in\u00adterpretations (D,I) where D is the set of closed phrases of RCF and I maps each function \nsymbol f of arity n to the function M1,..., Mn . f (M1,...,Mn), and maps the equality predicate to syntactic \nequality. (The only function symbols in our formulas are the syntactic constructors of RCF. In an RCF-interpretation \n(D,I) we .x the meaning of function symbols and equality, but allow the meaning of predicates to vary.) \nCore Syntax of the Values and Expressions of RCF: a,b,c name h ::= inl | inr | fold value constructor \nM, N ::= value variable () unit fun x . A function (scope of x is A) (M, N) pair hM construction A,B \n::= expression M value MN application M = N syntactic equality let x = A in B let (scope of x is B) let \n(x,y)= M in A pair split (scope of x, y is A) match M with hx . A else B constructor match (scope of \nx is A) (.a)A restriction (scope of a is A) A r B fork: parallel composition a!M transmission of M on \nchannel a a? receive message off channel assume C assumption of formula C assert C assertion of formula \nC Much of RCF is standard functional notation. Expressions are in the style of A-normal form; let-expressions \nare for sequencing and not for polymorphism. In the style of the pi calculus, RCF includes restriction \n(name generation), fork, and message transmission and reception for communication and concurrency. Names \nrange over countable, pairwise-distinct constants, used to represent channels, fresh values, and keys, \nfor instance. An expression context X is an expression with a hole . We write X[A] for the outcome of \n.lling the hole with expression or expression context A, where variables free in A may be bound by binders \nin X. (We use expression contexts to represent modules.) The expressions assume and assert have no observable \neffect at run-time, and are used only to specify logic-based safety properties. Execution of assume C \nlimits attention to logical interpretations in which C holds. Assumptions are used to state inductive \nde.nitions or to record events, for example. Execution of assert C indicates an error unless C holds \nin interpretations satisfying the previously executed assumptions. The type system of RCF is based on \nFPC, but with dependent function and pair types, plus re.nement types x : T {C}. The values of this type \nare the values M of type T such that C{M/x} holds. Core Syntax of Types of RCF: T,U,V ::= type unit unit \ntype x : T . U dependent function type (scope of x is U) x : T * U dependent pair type (scope of x is \nU) T +U disjoint sum type rec a.T iso-recursive type (scope of a is T ) a type variable (abstract or \niso-recursive)  x : T {C} re.nement type (scope of x is C)  As detailed by Bengtson et al. (2008), \nRCF supports standard encodings of a wide range of F# programming constructs, including let-polymorphism \n(eliminated by code duplication), mutable refer\u00adences (channels), and algebraic types (recursive sums \nof product types); it is closely related to the internal language of the F7 type\u00adchecker. Our code examples \nrely on these encodings. In addition, code written in RCF has access to a few pre-de.ned trusted libraries, \ndepicted at the bottom of the .gure on the .rst page. The library module Data de.nes standard datatypes \nsuch as strings, bytestrings, lists, options, and provides functions for manipulating and converting \nbetween values of these types; Crypto provides primitive cryptographic operations; Db provides functions \nfor storing and retrieving values from a global, shared, secure database; Xml provides functions and \ndatatypes for manipulating XML documents; Net provides functions for establishing TCP connections and \nexchanging messages over them. We write Lib for the composition of Data, Net, and Crypto, and LibX for \nthe composition of Lib, Db, and Xml. These libraries are trusted in the sense that their concrete implementations \nare not veri.ed. Instead, we de.ne idealized symbolic implementations, in the style of Dolev and Yao \n(1983), for each of these .ve modules and show that they meet their typed RCF interfaces. Each judgment \nof the RCF type system is given relative to an environment, E, which is a sequence \u00b51,..., \u00b5n, where \neach \u00b5i may be a subtype assumption a <: a', an abstract type a, or an entry for a name a t T or a variable \nx : T . The two main judgments are subtyping, E f T <: U, and type assignment, E f A : T . The full rules \nfor these judgments and the rest of RCF are in the companion technical report. F7 relies on various type \ninference algorithms, and calls out to Z3 to handle the logical goals that arise when checking re.nements. \nF7 adds the formula C to the current logical environment when processing assume C, and conversely checks \nthat formula C is provable when processing assert C.  3. Invariants for Authenticated RPCs (Example) \nWe consider a protocol intended to authenticate remote procedure calls (RPC) over a TCP connection. We \n.rst informally discuss the security of this protocol and identify a series of underlying assumptions. \nWe then explain how to formalize these assumptions, and how to verify an implementation of the protocol. \nInformal Description We have a population of principals, ranged over by a and b. The security goals of \nour RPC protocol are that (1) whenever a principal b accepts a request message s from a, principal a \nhas indeed sent the message to b and, conversely, (2) whenever a accepts a response message t from b, \nprincipal b has indeed sent the message in response to a matching request from a. To this end, the protocol \nuses message authentication codes (MACs) computed as keyed hashes, such that each symmetric MAC key kab \nis associated with (and known to) the pair of princi\u00adpals a and b. Our protocol may be informally described \nas follows. An Authenticated RPC Protocol: 1. a . b : utf8 s | (hmacsha1 kab (request s)) 2. b . a : \nutf8 t | (hmacsha1 kab (response s t))  In this protocol narration, each line indicates the communication \nof data from one principal to another. This data is built using .ve functions: utf8 marshals the strings \ns and t into byte arrays (the message payloads); request and response build message digests (the authenticated \nvalues); hmacsha1 computes keyed hashes of these values (the MACs); and | concatenates the message parts. \nWe consider systems in which there are multiple concurrent RPCs between any principals a and b of the \npopulation. The adver\u00adsary controls the network. Some keys may also become compro\u00admised, that is, fall \nunder the control of the adversary. Intuitively, the security of the protocol depends on the following \nassumptions: (1) The function hmacsha1 is cryptographically secure, so that MACs cannot be forged without \nknowing their key. (2) The principals a and b are not compromised otherwise the adversary may just use \nkab to form MACs. (3) The functions request and response are injective and their ranges are disjoint \notherwise, an adversary may for instance  ' replace the .rst message payload with utf8 s' for some s \n= s ' such that request s ' = request s and thus get s accepted instead of s, or use a request MAC to \nfake a response message. (4) The key kab is a genuine MAC key shared between a and b, used exclusively \nfor building and checking MACs for requests from a to b and responses from b to a otherwise, for instance, \nif b also uses kab for authenticating requests from b to a, it would accept its own re.ected messages \nas valid requests from a. These assumptions can be precisely expressed (and veri.ed) as program invariants \nof the protocol implementation. Moreover, the abstract speci.cation of hmacsha1, request, and response \ngiven above should suf.ce to establish the protocol invariant, irrespective of their implementation details. \nAdding Events and Assertions We use event predicates to record the main steps of each run of the protocol, \nto record the association between keys and principals, and to record principal compromise. To mark an \nevent in code, we assume a corresponding logical fact: Request(a,b,s) before a sends message 1;  Response(a,b,s,t) \nbefore b sends message 2;  KeyAB(k,a,b) before issuing a key k associated with a and b;  Bad(a) before \nleaking any key associated with a.  We state each intended security goal in terms of these events, by \nasserting that a logical formula always holds at a given location in our code, in any system con.guration, \nand despite the presence of an active adversary. In our protocol, we assert: RecvRequest(a,b,s) after \nb accepts message 1;  RecvResponse(a,b,s,t) after a accepts message 2;  where the predicates RecvRequest \nand RecvResponse are de.ned by the two formulas: .a,b,s. RecvRequest(a,b,s) .(Request(a,b,s) .Bad(a) \n.Bad(b)) .a,b,s,t. RecvResponse(a,b,s,t) . (Request(a,b,s) .Response(a,b,s,t)) .Bad(a) .Bad(b) The disjunctions \nabove account for the potential compromise of ei\u00adther of the two principals with access to the MAC key; \nthe disjunc\u00adtions would not appear with a simpler (weaker) attacker model. Implementing the RPC Protocol \nWe give below an implementa\u00adtion for the two roles of our protocol, coded in F#. Except for proto\u00adcol \nnarrations, all the code displayed in this paper is extracted from F7 interfaces and F# implementations \nthat have been typechecked. Code for the Authenticated RPC Protocol: let mkKeyAB a b = let k = hmac keygen() \nin assume (KeyAB(k,a,b)); k let request s = concat (utf8(str \"Request\")) (utf8 s) let response s t = \nconcat (utf8(str \"Response\")) (concat (utf8 s)(utf8 t)) let client (a:str) (b:str) (k:keyab) (s:str) \n= assume (Request(a,b,s)); let c = Net.connect p in let mac = hmacsha1 k (request s) in Net.send c (concat \n(utf8 s) mac); let (pload ,mac ) = iconcat (Net.recv c) in let t = iutf8 pload in hmacsha1Verify k (response \ns t) mac ; assert(RecvResponse(a,b,s,t)) let server(a:str) (b:str) (k:keyab) : unit = let c = Net.listen \np in let (pload,mac)= iconcat (Net.recv c) in let s = iutf8 pload in hmacsha1Verify k (request s) mac; \nassert(RecvRequest(a,b,s)); let t = service s in assume (Response(a,b,s,t)); let mac = hmacsha1 k (response \ns t) in Net.send c (concat (utf8 t) mac ) (We omit the de.nition of the application-level service func\u00adtion.) \nCompared to the protocol narration, the code details message processing, and in particular the series \nof checks performed when receiving messages. For example, upon receiving a request, server extracts s \nfrom its encoded payload by calling iutf8, and then ver\u00adi.es that the received MAC matches the MAC recomputed \nfrom k and s. The code uses concat and iconcat to concatenate and split byte arrays. (Crucially for this \nprotocol, concat embeds the length of the .rst array, and iconcat splits arrays at this length. Otherwise, \nfor instance, response is not injective and the protocol is insecure.) In our example, the code assumes \nevents that mark the genera\u00adtion of a key for our protocol and the intents to send a request from a to \nb or a response from b to a. The code asserts two properties, after receiving a request or a response, \nand accepting it as genuine. We test that our code is functionally correct by linking it to a concrete \ncryptographic library and performing an RPC between a and b. The messages exchanged over TCP are: Connecting \nto localhost:8080 Sending {BgAyICsgMj9mhJa7iDAcW3Rrk...} (28 bytes) Listening at ::1:8080 Received Request \n2 + 2? Sending {AQA0NccjcuL/WOaYS0GGtOtPm...} (23 bytes) Received Response 4  Modelling the Opponent \nWe model an opponent as an arbitrary program with access to a given public interface that re.ects all \nits (potential) capabilities. Thus, our opponent has access to the network (modelling an active adversary), \nto the cryptographic li\u00adbrary (modelling access to the MAC algorithms), and to a protocol\u00adspeci.c setup \nfunction that creates new instances of the protocol for a given pair of principals. This function returns \nfour capabilities: to run the client with some payload, to run the server, to corrupt the client, and \nto corrupt the server (that is, here, to get their key). We detail the code for setup below: it allocates \na key, specializes our client and server functions, and leaks that key upon request after assuming an \nevent that records the compromise of either a or b. Protocol-Speci.c Implementation for the Opponent \nInterface: let setup (a:str) (b:str) = let k = mkKeyAB a b in (fun s .client a b k s), (fun .serverab \nk), (fun .assume (Bad(a)); k), (fun .assume (Bad(b)); k) Formally, the opponent ranges over arbitrary \nF# code well\u00adtyped against an interface that includes (at least) the declarations below. Let an opponent \nO be an expression containing no assume or assert. Our opponent interfaces declare functions that operate \non types of the form x:T { Pub(x)}; intuitively, these types re.ect the global invariant that the opponent \nmay obtain and construct at most the cryptographic values tracked as public in our logic model. Hence, \nbytespub is de.ned as x: bytes {Pub(x)}. The types strpub and keypub of public strings and public keys \nare de.ned similarly. In our method, we explicitly give an inductive de.nition of Pub, and the typechecker \nensures that, whenever an expression is given a public type (for instance when sending bytes on a public \nnetwork), the fact that the value will indeed be public logically follows from that inductive de.nition. \nOpponent Interface (excerpts): val send: conn .bytespub .unit val recv: conn .bytespub val hmacsha1 : \nkeypub .bytespub .bytespub val hmacsha1Verify : keypub .bytespub .bytespub .unit val setup: strpub .strpub \n. (strpub .unit) * (unit .unit) * (unit .keypub) * (unit .keypub) As explained next, we write more re.ned \ninterfaces for type\u00adchecking our code: each value declaration will be given a re.ned type that is a subtype \nof the one listed in the opponent interface. We are now ready to formally state our target security theorem \nfor this protocol. We say that an expression is semantically safe when every executed assertion logically \nfollows from previously\u00adexecuted assumptions. Let IL be the opponent interface for our li\u00adbrary. Let \nIR be the opponent interface for our protocol (the setup function displayed above). Let X be the expression \ncontext repre\u00adsenting the composition of the library with the protocol implemen\u00adtation. (We give a precise \nde.nition of X in Section 4.) THEOREM 1 For any opponent O, if IL, IR f O : unit, then X[O] is semantically \nsafe. Re.nement-Typed Interface for MACs Our example theorem relies on typechecking our library and protocol \ncode against their opponent interfaces. For the library, this is done once for all, using an intermediate, \nmore re.ned interface that operates on values that are not necessarily public. This interface and its \nlogical model are explained in the companion technical report, so here we only outline their declarations \nand formulas as regards MACs. So the main task for verifying the RPC protocol is to typecheck it. We \n.rst outline the re.ned interface for MACs, then explain how to de.ne and enforce a logical model for \nthe RPC protocol. Re.nement Types for MACs (from the Crypto library): private val hmac keygen: unit .k:key{MKey(k)} \nval hmacsha1: k:key . b:bytes{ (MKey(k) .MACSays(k,b)) .(Pub(k) .Pub(b)) } . h:bytes{ IsMAC(h,k,b) .(Pub(b) \n.Pub(h)) }val hmacsha1Verify: k:key{MKey(k) .Pub(k)} .b:bytes .h:bytes .unit{IsMAC(h,k,b)} (C1. By expanding \nthe de.nition of IsMAC) .h,k,b. IsMAC(h,k,b) .Bytes(h) .MACSays(k,b) .Pub(k) (C2. MAC keys are public \niff they may be used with any logical payload) .k. MKey(k) .(Pub(k) ..m. MACSays(k,m)) This interface \nde.nes functions for creating keys, computing MACs, and verifying them. (The private modi.er indicates \nthat a value is not included in the opponent interface.) It is designed for .exibility; simpler, more \nrestrictive interfaces may be obtained by subtyping, for instance, when key compromise need not be considered. \nIts logical model is built from the following predicates: MKey(k) records that k has been produced by \nhmac keygen; the adversary can produce other public keys from public values.  MACSays(k,b) is de.ned \nby the protocol that relies on k, as its precondition for computing a MAC and its postcondition after \nverifying a MAC.  IsMAC(h,k,b) holds when veri.cation that h is a MAC for b under k succeeds; it implies \neither MACSays(k,b) or Pub(k).  The precondition of hmacsha1 is a disjunction that covers two cases \nfor the key: either it is a correctly-generated key, or the key is public. The latter case is necessary \nto type MAC compu\u00adtations using a key received from the opponent, and to show that hmacsha1 has the type \ndeclared in the opponent interface. (In type systems without formulas, such disjunctions in logical re.nements \ncould instead be expressed using union types.) The postcondition Pub(b).Pub(h) states that the MACs produced \nby the protocol are public (hence can be sent) provided the plaintext is public. Crypto\u00adgraphically, \nthis re.ects that MACs provide payload authentication but not secrecy. The precondition of hmacsha1Verify \nsimilarly covers the two cases for the key. A call hmacsha1Verify k b h raises an exception in case the \nsupplied hash h does not in fact match the MAC of b with the key k. (At present, F7 does not support \nexception handling, and treats an exception as terminating execution.) Otherwise, its post\u00adcondition \nalso leads to a disjunction (corollary C1), so the protocol that veri.es a MAC must also know that Pub(k).MACSays(k,b), \nfor example because k is not public, to deduce that MACSays(k,b). The library also assumes de.nitions \nand theorems relating these predicates, and in particular the inductive de.nition of Pub. For convenience, \nthe display above includes two properties for MACs that are corollaries of these de.nitions: C1 just \ninlines the de.ni\u00adtion of IsMAC; C2 expresses a secrecy invariant for MAC keys: a key k is public if \nand only if its associated logical payload holds for any value. Hence, as a prerequisite for releasing \na key k as a pub\u00adlic value, a protocol must ensure that all potential consequences of MAC veri.cation \nwith key k hold. Depending on how the protocol de.nes MACSays, this may be established by assuming some \ncom\u00adpromise at the protocol level (predicate Bad(a) in our protocol). Logical Invariants for the RPC \nProtocol To verify a protocol, we state some of its intended logical properties (both de.ning its speci.c \nusage of cryptography and stating theorems about it), we typecheck the protocol code under those assumptions, \nand, if need be, we prove protocol-speci.c theorems, as illustrated below.  We .rst introduce two auxiliary \npredicates for the payload for\u00admats: Requested and Responded are the (typechecked) postcondi\u00adtions of \nthe functions request and response; we omit their de.\u00adnition. Typechecking involves the automatic veri.cation \nthat our formatting functions are injective and have disjoint ranges, as ex\u00adplained in informal assumption \n(3). Veri.cation is triggered by as\u00adserting the formulas below, so that Z3 proves them. Properties of \nthe Formatting Functions request and response: (request and response have disjoint ranges) .v,v ,s,s \n,t . (Requested(v,s) .Responded(v ,s ,t )) .(v =v ) (request is injective) .v,v ,s,s . (Requested(v,s) \n.Requested(v ,s ) .v = v ) .(s = s ) (response is injective) .v,v ,s,s ,t,t . (Responded(v,s,t) .Responded(v \n,s ,t ) .v = v ) .(s = s .t = t ) For typechecking the rest of the protocol, we can instead as\u00adsume these \nformulas; this con.rms that the security of our protocol depends only on these properties, rather than \na speci.c format. In addition, typechecking involves the following three assumptions: Formulas Assumed \nfor Typechecking the RPC protocol: (KeyAB MACSays) .a,b,k,m. KeyAB(k,a,b) .( MACSays(k,m) . ((.s. Requested(m,s) \n.Request(a,b,s)) . (.s,t. Responded(m,s,t) .Response(a,b,s,t)) . (Bad(a) .Bad(b)))) (KeyAB Injective) \n.k,a,b,a ,b . KeyAB(k,a,b) .KeyAB(k,a ,b ) .(a=a ) .(b=b ) (KeyAB Pub Bad) .a,b,k. KeyAB(k,a,b) .Pub(k) \n.Bad(a) .Bad(b) The formula (KeyAB MACSays) is a de.nition for the library predicate MACSays. It states \nthe intended usage of keys in this protocol by relating MACSays to the protocol-speci.c predicates Request, \nRequested, Respond, Responded, and Bad. The de.nition has four cases: the MAC is for an authentic request \ns formatted by function request, the MAC is for an authentic response to a prior request formatted by \nfunction response, or the sender is compro\u00admised, or the receiver is compromised. The formula (KeyAB \nInjective) is a theorem stating that each key is used by a single pair of principals. Our informal invariant \non key usage (assumption (4)) directly follows, since KeyAB(k,a,b) is a precondition of both client and \nserver. The proof is by induc\u00adtion on any run of a program that assumes KeyAB only in the body of mkKeyAB. \nIt follows from a more general property of our li\u00adbrary: hmac kgen returns a key built from a fresh name, \nhence this key is different from any value previously recorded in any event. Whenever a new event KeyAB(k,a,b) \nis assumed, and for any event KeyAB(k ,a ,b ) previously assumed, we have k = k' , so any new instance \nof (KeyAB Injective) holds. Conversely, we would not be able to prove the theorem if mkKeyAB also (erroneously) \nassumed KeyAB(k,b,a), for instance, as that might enable re.ection attacks. The formula (KeyAB Pub Bad) \nis a secrecy theorem for the MAC keys allocated by the protocol, stating that those keys remain secret \nuntil one of the two recorded owners is compromised. This theorem validates our key-compromise model. \nIts proof goes as follows. Relying on the postcondition of the call to hmac keygen within mkKeyAB, we \nalways have MKey(k) when KeyAB(k,a,b) is assumed, hence we establish the lemma .a,b,k. KeyAB(k,a,b). \nMKey(k). By corollary C2, KeyAB(k,a,b) and Pub(k) thus imply that .m. MACSays(k,m). By inspecting (KeyAB \nMACSays), it suf.ces to show that there always exists at least one value M such that we have neither \nRequested(M,s) nor Responded(M,s,t), for any s, t. This trivially follows from the de.nitions of these \ntwo predicates; not every bytestring is a well-formatted request or response. Re.nement Types for the \nRPC Protocol Using F7, we check that our protocol code (with the Net and Crypto library interfaces, and \nthe assumed formulas above) is a well-typed implementation of the interface below. Typed Interface for \nthe RPC Protocol: type payload = strpub val request: s:payload .m:bytespub{Requested(m,s)}val response: \ns:payload .t:payload .m:bytespub{Responded(m,s,t)}val service: payload .payload type (;a:str,b:str)keyab \n= k:key { MKey(k) .KeyAB(k,a,b) }val mkKeyAB: a:str .b:str .k: (;a,b)keyab val client: a:str .b:str .k: \n(;a,b)keyab .payload .unit val server: a:str .b:str .k: (;a,b)keyab .unit This interface is similar but \nmore precise than the one in F#. The type payload is a re.nement of string (str) that also states that \nthe payload is a public value, so that in particular it may be sent in the clear. The value-dependent \ntype keyab is a re.nement of key that also states that the key is a MAC key for messages from a to b. \nWe brie.y comment on the (fully automated) usage of our logical rules during typechecking. To type the \ncalls to hmacsha1, the precondition follows from the re.nement in the type of k from either the .rst \nor the second disjunct of (KeyAB MACSays).  To type the calls to send, we rely on the postcondition \nof hmacsha1 to show that the computed MAC is public.  To type the leaked key k as keypub within setup, \nwe need to show Pub(k). This follows from MKey(k) (from the re.nement in the type of k), corollary C2, \nand the de.nition of MACSays, using the just-assumed formula Bad(a) or Bad(b) to satisfy either the third \nor the fourth disjunct of (KeyAB MACSays).  To type the RecvRequest protocol assertion, we must prove \nthe formula Request(a,b,s).Bad(a).Bad(b) in a context where we have KeyAB(k,a,b), Requested(v,s), and \nIsMAC(h,k,v). By corollary C1, we have MACSays(k,v).Pub(k). By corollary C2, we have MKey(k).Pub(k)..v. \nMACSays(k,v), so we obtain MACSays(k,v) in both cases of the disjunction. By de.nition of (KeyAB MACSays), \nthis yields  (Requested(v,s) ..s.(Requested(v,s) .Request(a,b,s))) . (Requested(v,s) ..s,t.(Responded(v,s,t) \n.Response(a,b,s,t))) . Bad(a) .Bad(b) which implies Request(a,b,s).Bad(a).Bad(b) by using the properties \nof our formatting functions. 4. Semantic Safety by Modular Typing This section develops the theory underpinning \nour veri.cation tech\u00adnique. First, we introduce semantic safety, which allows us to make inductive de.nitions \nof predicates in RCF. Second, we formalize F7 modules within RCF, and in particular introduce re.ned \nmod\u00adules, which are modules packaged with inductive de.nitions of predicates and associated theorems. \nSyntactic Safety by Typing (Review) We recall the operational semantics and notion of syntactic safety \nfor RCF, together with one of the main theorems of Bengtson et al. (2008). The semantics of expressions \nis de.ned by a small-step reduction relation, written A . A', which is de.ned up to structural rearrangements, \nwritten A = A'. We represent all reachable run-time program states using expressions in special forms, \nnamed structures, ranged over by S.A structure is a parallel composition of active subexpressions running \nin parallel, within the same scope for all restricted names. (We say a subexpression is active to mean \nthat it occurs in evaluation context, that is, nested within restriction, fork, or let-expressions.) \n In particular, from a given structure, one can extract a .nite set of active assumptions and assertions. \n(This extraction is de.ned for the whole structure, up to injective renamings on the restricted names.) \n A C-structure is a structure whose active assumptions are ex\u00adactly {assume C1,...,assume Cn} with C \n= C1 .\u00b7\u00b7\u00b7.Cn.  A C-structure is syntactically statically safe if every RCF\u00adinterpretation to satisfy \nC also satis.es each active assertion.  An expression A is syntactically safe if and only if, for all \nexpressions A' and structures S, if A .* A' and A' = S, then S is syntactically statically safe.  THEOREM \n2 (Bengtson et al. 2008) If \u00d8f A : T , then A is syntactically safe. Inductive De.nitions and Semantic \nSafety by Typing A key technique in this paper is to consider in RCF predicates given by inductive rules, \nsuch as the predicates Bytes and Pub mentioned in the previous section. We intend to de.ne these predicates \nin RCF by assuming Horn clauses corresponding to the inductive rules. Formally, we introduce a standard \nnotion of logic program, which is guaranteed by the Tarski-Knaster .xpoint theorem to have a least interpretation. \n A Horn clause is a closed formula .x1,...,xk.(C1 .\u00b7\u00b7\u00b7.Cn . C) where C1, ..., Cn range over atomic formulas \nand equations and C ranges over atomic formulas.  A logic program, P, is a .nite conjunction of Horn \nclauses.  If P is a logic program, let IP be the least RCF-interpretation to satisfy P (which exists \nuniquely, by Tarski-Knaster).  Syntactic safety asks assertions to hold in all interpretations that \nsatisfy the assumptions. Instead, if we move to considering assumptions as inductive de.nitions, we want \na weaker notion, which we name semantic safety, that asks assertions to hold only in the least interpretation \nthat satis.es the assumptions. Considering only the least interpretation allows us to prove safety by \nexploiting theorems proved by induction and case analysis on the inductive de.nitions. An expression \nis factual if and only if each of its assumptions (active or not) is a logic program.  A C-structure \nis semantically statically safe if the least RCF\u00adinterpretation to satisfy C also satis.es each asserted \nformula.  An expression A is semantically safe if and only if, for all expressions A' and structures \nS, if A .* A' and A' = S, then S is semantically statically safe.  Semantic safety may not be well-de.ned \nif least interpretations do not exist. A suf.cient condition for semantic safety of expres\u00adsion A to \nbe well-de.ned is when A is factual, for then the active as\u00adsumptions in each reachable structure form \na logic program. Given this condition, syntactic safety implies semantic safety, but not the converse, \nsince semantic safety may rely on properties of the least interpretations. In the following, we call \nsuch a property a theorem of A , and state a new result for proving semantic safety for A. Let C be a \ntheorem of A if and only if A is factual and, for all P, IP satis.es C for all P-structures reachable \nfrom A. THEOREM 3 Consider closed expression A and formula C where: (1) the expression assume C r A is \nsyntactically safe; and (2) C is a theorem of A. Then A is semantically safe. A Simple Formalization \nof Modules We formalize F7 modules (including whole programs) and interfaces as RCF expression con\u00adtexts \nand environments. A module X is an expression context of the form let x1 = A1 in ...let xn = An in where \nn = 0 and the bound variables xi are distinct. We let bv(X)= {x1,...,xn}. We treat the concrete syntax \nfor composing F# modules as syntactic sugar, writing X1 X2 for the module X1[X2[ ]].  An interface I \nis a typing environment \u00b51,..., \u00b5n where each \u00b5i is either an abstract type ai or a variable typing xi \n: Ti.  We lift subtyping to interfaces by the following axioms and rules, plus re.exivity and transitivity, \nand well-formedness con\u00additions (so that I <: I' always implies I f< and I'f<).  I0,(I1{T /a}) <: I0, \na,I1 I0 f T <: U I0, \u00b5,I1 <: I0, I1 I0, x : T, I1 <: I0,x : U,I1 A module X implements I in E, written \nE f X r I, when E f X[(x1,...,xn)] : (x1: T1 * ... * xn : Tn) and (xi : Ti)i=1..n <: I. Re.ned Modules \nWe use an expression context assume P r Y to formalize the idea of a module Y packaged with a (closed) \nlogic program P to make inductive de.nitions of predicates. We call such contexts re.ned modules. We \nwant to exploit theorems following from P when typechecking Y . To do so, we introduce the notion of \na contextual theorem, a theorem that holds in any expression containing assume P r Y as a component. \n The support of a logic program is the set of predicate symbols occurring in the head of any clause. \nThe support of an expres\u00adsion or expression context is the support of its assumptions. (Intuitively, \nthe support is the set of predicates being de.ned.) Logic programs, expressions, or expression contexts \nare inde\u00adpendent when their supports are disjoint.  Let C be a contextual theorem of expression context \nassume P r Y if and only if C is a theorem of assume P r Z[Y [A]] whenever Z and A are factual and independent \nof assume P r Y .  When the following lemma applies, we can prove contextual theorems from the inductive \nde.nitions P of assume P rY , without explicit consideration of the operational semantics. LEMMA 1 (Contextual). \nLet C be a formula and P a logic pro\u00adgram such that, for all Q independent from P, the least RCF\u00adinterpretation \nto satisfy P . Q also satis.es C. If Y is an expres\u00adsion context independent from P, then C is a contextual \ntheorem of assume P r Y. Let a re.ned module be a triple M =(E, X,I) such that there are closed formulas \nMdef and Mthm, and a module Y where: (1) X is factual and X = assume Mdef r Y ; (2) E,Mdef ,Mthm f Y \nr I; (3) Mthm is a contextual theorem of X. (When we write a formula such as Mdef as an environment entry, \nwe mean it as a shorthand for : {Mdef} where the type {Mdef} = : unit{Mdef}, where each occurrence of \nstands for a fresh variable. This type is only populated when Mdef holds, so the effect of the entry \nis simply to add Mdef as a logical assumption.) Our example relies on Lib, the composition of the library \nmod\u00adules Data, Net, and Crypto, which together form a re.ned mod\u00adule. Let Lib be the F# code of the library, \nthat is, the composi\u00adtion Data Net Crypto of the code of the libraries. Let IL 7 be the F7 interface, \nwhich includes, for example, the functions labelled  Re.nement Types for MACs in Section 3. The inductive \nde.\u00adnitions Libdef include formulas de.ning the Pub and Bytes predi\u00adcates, while Libthm includes the \ncorollaries C1 and C2 in Section 3. LEMMA 2 Lib =(\u00d8, assume Libdef r Lib,IL 7) is a re.ned module. As \nanother example, our RPC protocol consists of a re.ned module of the form: RPC =(IL 7 , assume RPCdef \nr RPC, (IL,IR)). Let RPC be the F# code for the protocol. The inductive de.ni\u00adtions RPCdef include the \nright to left form of (KeyAB MACSays) from Section 3. The theorems RPCthm include (KeyAB Injective), \n(KeyAB Pub Bad), and the left to right form of (KeyAB MACSays) from Section 3. The exported interface \n(IL,IR) is made available to the opponent. Let IL be the library s opponent interface, which is excerpted \nin Section 3. Let IR be the protocol-speci.c opponent interface from Section 3. As mentioned in that \nsection, the mod\u00adule below imports IL 7 and exports its members at the more abstract interface IL, by \nintroducing abstract types such as bytespub with representation type x: bytes {Pub(x)}. LEMMA 3 RPC is \na re.ned module. Composition of Re.ned Modules We say M1 =(E1,X1,I1) composes with M2 =(E2,X2,I2) iff \nI1 <: E2 and X1 and X2 are independent.  For any triples M1 =(E1,assume Mdef r Y1,I1) and M2 =  1 (E2,assume \nMdef r Y2, I2) their composition M1;M2 is the 2 . Mdef triple (E1,assume (Mdef ) r Y1[Y2],I2). 12 LEMMA \n4 (Composition). If re.ned module M1 composes with re.ned module M2 then M1;M2 is a re.ned module. For \nexample, the triple Lib;RPC is: (\u00d8,assume (Libdef . RPCdef) r L[Y ],(IL, IR)). By Lemma 4 (Composition), \nLib; RPC is a re.ned module. Safety and Robust Safety by Typing for Modules A re.ned module (\u00d8,X,\u00d8) \nis semantically safe if and only if, the expression X[()] is semantically safe.  An I-opponent is an \nopponent O such that I f O : unit.  A re.ned module (\u00d8,X,I) is robustly safe if and only if, the expression \nX[O] is semantically safe for every I-opponent O.  THEOREM 4 (Safety). Every re.ned module (\u00d8,X,\u00d8) is \nsemantically safe. THEOREM 5 (Robust Safety). Every re.ned module (\u00d8,X,I) is robustly safe. We can now \nprove Theorem 1. We have that Lib; RPC = (\u00d8,X,(IL,IR)) where X = assume (Libdef . RPCdef) r Lib[RPC] \nis a re.ned module. By Theorem 5 (Robust Safety), (\u00d8, X,(IL,IR)) is robustly safe, which is to say that \nX[O] is semantically safe for every opponent O with IL,IR f O : unit. 5. Library Modules for Cryptographic \nProtocols In this section, we describe intermediate re.ned modules, built on top of the Crypto module, \nthat implement derived mechanisms and composite patterns commonly used in cryptographic protocol implementations. \nWe refer to the companion paper for a more complete description, and for a detailed presentation of the \nCrypto module. (Section 3 also presents its interface for MACs.) Both modules are fully veri.ed, and \ndemonstrate the .exibility of our approach. Relying on these libraries, their logical de.nitions, and \ntheir theorems, we build (and verify) a series of modular protocols, leading to Windows CardSpace. Key \nManagement The Principals library generalizes the treat\u00adment of keys and principals illustrated in the \nexample protocol of Section 3. (To facilitate the comparison, we illustrate mostly the treatment of MAC \nkeys.) Instead of a .xed population of princi\u00adpals and keys, the library maintains a database of keys \nshared be\u00adtween an extensible set of principals. Pragmatically, this function\u00adality may be implemented \nusing some existing public-key infras\u00adtucture, or an in-memory database recording the outcome of prior \nkey-exchange protocols. Formally, our implementation of Princi\u00adpals relies on Db, a channel-based abstraction \nfor databases.The main purpose of the library is to systematically link cryptographic keys to application-level \nprincipals, while keeping track of their potential compromise. Principal identi.ers are represented by \na type prin de.ned as a public string. Each principal may have a number of MAC keys, encryption keys, \nand public/private key pairs. The library maintains a database that may be used by multiple protocols \nto store and retrieve keys. Keys are grouped by usage (set by the protocol that generates the key) to \ndistinguish between the intended usage of each key, and associated with one (for public/private keypairs) \nor two principals. For instance, a MAC key mk managed by the library for some usage \"RPC\" shared between \nprincipals a and b is given the type (mk:key){MACKey(\"RPC\",a,b,mk)} (where key is the type of keys in \nCrypto). For managed MAC keys, Principals provides functions: private val mkMACKey: u:usage .a:prin .b:prin \n. mk:key{MACKey(u,a,b,mk)}val genMACKey: u:usage .a:prin .b:prin .unit private val getMACKey: u:usage \n.a:prin .b:prin . mk:key{MACKey(u,a,b,mk)} The function mkMACKey generates and returns a fresh MAC; genMACKey \ncalls mkMACKey then stores the key in the database; getMACKey retrieves a key from the database. Of these \nthree func\u00adtions, only genMACKey is available in the opponent interface. Managed keys can be used for \nstandard cryptographic opera\u00adtions. To this end, Principals links key-level predicates used in Crypto \n(de.ned by Principals) to principal-level predicates (to be de.ned by the protocol): Send(u,a,b,s) means \nthat the princi\u00adpal a intends to MAC s before sending it to b; Encrypt(u,a,b,s) records that s may be \nencrypted towards b using symmetric encryp\u00adtion; SendFrom and EncryptTo similarly record intended asymmet\u00adric \nsignatures and asymmetric encryption with a managed key. The Principals library also provides functions \nfor compromising keys. Compromise is dealt with at the level of principals: Bad(a) indi\u00adcates that principal \na has been compromised, and thus that all the keys it could access may have been leaked. For MACs, for \ninstance, the library interface assumes the formulas below. MAC Key Usage: (MACKey MACSays Send) .u,a,b,mk,m. \nMACKey(u,a,b,mk) .Send(u,a,b,m) .MACSays(mk,m) (MACKey MACSays Bad) .u,a,b,mk,m. MACKey(u,a,b,mk) .(Bad(a) \n.Bad(b)) .MACSays(mk,m) (Inv MACKey MACSays) .u,a,b,mk,m. MACKey(u,a,b,mk) .MACSays(mk,m) . (Send(u,a,b,m) \n.Bad(a) .Bad(b)) (MACKey Secrecy) .u,a,b,mk. MACKey(u,a,b,mk) .Pub(mk) . (Bad(a) .Bad(b) ..v. Send(u,a,b,v)) \nThe two .rst clauses are de.nitions, enabling hmacsha1 to be called with a managed MAC key once the protocol \nhas assumed an adequate de.nition of Send, with a more liberal precondition in case of compromise. The \nthird and fourth clauses are theorems: MAC veri.cation with a managed key yields a principal-level guar\u00adantee; \nand a MAC key shared between two principals remains se\u00adcret until one of them gets compromised.  Our \nmodel of key compromise is among the most general mod\u00adels for protocol veri.cation. It supports three \nkinds of keys: those generated by the attacker, those generated by the principals library and kept secret, \nand those generated by the principals library and leaked to the attacker. It allows cryptographic operations \nto be per\u00adformed with all three categories of keys. Moreover, all keys may be encrypted, MACed, or signed \nunder other keys. For instance, if a key is used to encrypt some collection of other keys (as tracked \nby Send), our logical model rightfully demands, as a precondition for compromising any principal with \naccess to that key, that the condi\u00adtions for leaking each of these encrypted keys be also recursively \nsatis.ed. Although this leads to complex re.nement types and as\u00adsumptions, most of this complexity is \nfactored out in the library and can be used with a low overhead. Recall that LibX is the composition \nof Lib, Db, and Xml. LEMMA 5 LibX;Principals is a re.ned module. Authenticated Encryption The Crypto \nmodule provides plain (unauthenticated) symmetric encryption: Re.nement Types for Encryption (from the \nCrypto library): private val aes keygen: unit .k:key{SKey(k)} val aes encrypt: (* AES CBC *) k:key . \nb:bytes{(SKey(k) .CanSymEncrypt(k,b)) .(Pub(k) .Pub(b))} . e:bytes{IsEncryption(e,k,b)}val aes decrypt: \n(* AES CBC *) k:key{SKey(k) .Pub(k)} .e:bytes . b:bytes{(.p. IsEncryption(e,k,p) .b = p) .(Pub(k) .Pub(b))} \nThe function aes keygen generates symmetric keys, logically tracked by SKey; aes encrypt can be called \nin two ways: either with a good key k generated by aes keygen and a plaintext b such that CanSymEncrypt(k,b) \nholds, or with any public k and b (known to or provided by the attacker); it returns encrypted bytes \ne, tracked by IsEncryption; aes decrypt takes a key k and bytes e and extracts a plaintext b. Since encryption \nis unauthenticated, decryption may succeed even if e is not a valid encryption, returning some unspec\u00adi.ed \n(garbage) bytes, so the .rst postcondition of aes decrypt just says that, if the caller knows that e \nis an encryption of some (pos\u00adsibly unknown) plaintext p under e, then decryption does returns p. (The \nsecond postcondition enables re-encryptions.) The Patterns module shows how to derive authenticated en\u00adcryption, \nfor each of the three standard composition methods for encryption and MACs (see, e.g., Bellare and Namprempre \n2008). Encrypt-then-MAC (as in IPSEC in tunnel mode): a . b: e | hmacsha1 km ab t ab e where e = aes \nke MAC-then-Encrypt (as in SSL/TLS): a . b: aes ke ab (t | hmacsha1 km ab t) MAC-and-Encrypt (as in SSH): \na . b: aes ke ab t | hmacsha1 km ab t Depending on the method, the message is .rst encrypted, then the \nencryption is MACed, or the message is .rst MACed and then both the message and the MAC are encrypted, \nor the message is .rst MACed but the MAC is left unencrypted. For each method, the goal is to securely \ncommunicate plaintexts t from a to b relying on pre-established shared keys, but the underlying cryptographic \nassumptions slightly differ. Cryptographers prefer the .rst method, as it prevents chosen-ciphertext \nattacks and does not require se\u00adcrecy assumptions on the MAC function. We implemented and ver\u00adi.ed all \nthree (using a secrecy-preserving MAC in the third case, as expected). We focus on encrypt-then-MAC, \nsince this was not implementable in our previous work with F7. Authenticated Encryption API: val authenc \nkeygen: unit .(ek:key * mk:key){AuthEncKeyPair(ek,mk)}val encrypt then mac: ek:key .mk:key . b:bytes{(AuthEncKeyPair(ek,mk) \n.CanSymEncrypt(ek,b)) . (Pub(ek) .Pub(mk) .Pub(b))} . e:bytes{IsAuthEncryption(e,ek,mk,b)} val verify \nthen decrypt: ek:key . mk:key{(AuthEncKeyPair(ek,mk) .(Pub(ek) .Pub(mk)))} . e:bytes . b:bytes{(CanSymEncrypt(ek,b) \n.Pub(ek)) .(Pub(ek) .Pub(b))} The function AuthEncKeyPair links pairs of keys for the method; encryption \nreturns a concatenation of an encryption and a MAC, tracked by IsAuthEncryption. verify then decrypt \nhas a stronger postcondition than aes decrypt; its result must have been encrypted using encrypt then \nmac, thereby excluding garbage. To verify these functions and obtain both integrity and con.dentiality \nfor b, for each key pair, we link MACSays(mk,b) and CanSymEncrypt(ek,e) to get both integrity and con.dentiality \nfor b: Authenticated Encryption Key Usage: (AuthEncKeyPair MACSays) .mk,ek,c,p. AuthEncKeyPair(ek,mk) \n.IsEncryption(c,ek,p) . CanSymEncrypt(ek,p) .MACSays(mk,c) The correctness of verify then decrypt relies \non theorems stat\u00ading that this is the only use of these keys, and linking their potential compromise. \nHybrid encryption Hybrid encryption is the standard method of implementing public-key encryption for \nlarge plaintexts: generate a fresh symmetric key; use it to encrypt the plaintext; then encrypt the key \nusing the public key of the intended receiver. Hybrid Encryption: a . b: rsa oaep pkb kab | aes kab t \nThis hybrid encryption combines authenticated asymmetric en\u00adcryption (RSA-OAEP) with unauthenticated \nsymmetric encryption, and provides unauthenticated asymmetric encryption (analogous to RSA without OAEP). \nThe library has three functions for it: Hybrid Encryption API: val hybrid keygen: unit .(pk:key * sk:key) \n{HyPubKey(pk) .HyPrivKey(sk) .PubPrivKeyPair(pk,sk)} val hybridEncrypt: k:key .b:bytes {(HyPubKey(k) \n.CanHyEncrypt(k,b)) .(Pub(k).Pub(b)) } . e:bytes{IsHyEncryption(e,k,b)} val hybridDecrypt: sk:key . e:bytes{HyPrivKey(sk).(Pub(sk).Pub(e))} \n. b:bytes{(.pk,x.(PubPrivKeyPair(pk,sk) .IsHyEncryption(e,pk,x)) .x = b) .(Pub(sk) .Pub(b))} Their code \nis straightforward, but their veri.cation is chal\u00adlenging (since it must rely on the assumption that \nthe symmetric key is used for a single hybrid encryption). Predicates HyPubKey, HyPrivKey, and HySymKey \ntrack the three kinds of keys used in the code. The protocol-de.ned precondition of hybridEncrypt is \nlinked to the underlying CanSymEncrypt and CanAsymEncrypt crypto\u00adgraphic predicates as follows: Hybrid \nEncryption Key Usage: (HyPubKey CanAsymEncrypt) .pk,kb. HyPubKey(pk) .HySymKey(SymKey(kb),pk) . CanAsymEncrypt(pk,kb) \n(HySymKey CanSymEncrypt) .pk,k,b. HySymKey(k,pk) .CanHyEncrypt(pk,b) .CanSymEncrypt(k,b)  To typecheck \nhybridDecrypt, we establish theorems stating that hybrid encryption keys are used only as above, and \nlinking the com\u00adpromise of the inner symmetric encryption key to that of the outer private key. After \nhiding auxiliary predicates, hybrid encryption has exactly the same interface as plain RSA in Crypto, \nshowing that the derivation does not entail any loss of .exibility. Derived Keys and Endorsing Signatures \nThe library also pro\u00advides support for deriving separate keys from a secret seed, and for endorsing signatures \n(that is, composing MACs and asymmetric signatures). LEMMA 6 LibX;Patterns is a re.ned module. Example: \nThe Otway-Rees Protocol Using the Principals and Patterns libraries, we can build up several protocol \nimplementa\u00adtions and establish their security with minimal effort. We outline our implementation of the \nOtway-Rees protocol, a well-known aca\u00addemic protocol for establishing a fresh short-term key between \ntwo principals a and b. Otway-Rees Protocol: 1. a . b: id | a | b | aenc ka (na | id | a | b) 2. b . \ns: id | a | b | aenc ka (na | id | a | b) | aenc kb (nb | id | a | b) 3. s . b: id | aenc ka (na | kab) \n| aenc kb (nb | kab) 4. b . a: id | aenc ka (na | kab)  Here, aenck x stands for the authenticated \nencryption of x under the key pair k, implemented using the Encrypt-Then-MAC mechanism. Using Principals \nwe create a population of principals, ranged over by p, together with a server s. The server shares a \nset of long-term key pairs with principals. Each long-term key pair kp is associated with and known to \nprincipal p and to s. The main authentication goal is that a, b, and s agree on all the main parameters \nof the protocol: the principals involved a, b, s, the session identi.er id, and the established key kab. \nThe main secrecy goal is that kab must be known only to a, b, and s. These goals are established mainly \nby typing the code against the Principals and Patterns interfaces. The only theorems proved by hand state \nthe freshness of nonces and keys generated in the protocol. LEMMA 7 LibX;Patterns;Principals;OtwayRees \nis a re.ned module. Example: Secure Conversations Next, we build a protocol for authenticated conversations \nbetween two principals. To illustrate compositionality, the key k is established by the Otway-Rees pro\u00adtocol, \nthen used for authenticated encryption, as described above. Session Sequence Integrity (initially i = \n1): i . a . b: id | aenc k (i | mi) i + 1. b . a: id | aenc k (i + 1 | mi+1) After key establishment, \nthe conversation protocol loops be\u00adtween request and response messages, incrementing a sequence number \nat each step. The authentication goal is that a and b must agree on the full sequence of messages (mi)i=1 \nsent and received (possibly excluding the last message in transit). Veri.cation of such unbounded protocols \nis typically beyond the reach of automated veri.cation tools, since it requires a form of induction. \nNonethe\u00adless, we are able to implement and verify this protocol by typing, relying on recursive predicates \nthat record the entire history of the session, and show that the local histories at both a and b are \nconsis\u00adtent. LEMMA 8 LibX;Patterns;Principals;OtwayRees;Sessions is a re.ned module. 6. Case Study: Windows \nCardSpace We describe our main case study, verifying an implementation of the federated identity\u00admanagement \nprotocol Windows CardSpace. The protocol con\u00adsists of three roles, a client C, a web server (named relying \nparty) RP, and an identity provider IP. To ac\u00adcess RP, C .rst obtains an identity token from IP, and \nthen uses this token to authenticate its messages to RP. Hence, the protocol uses two message exchanges, \nbetween C and IP then between C and RP. Structurally, CardSpace is similar to many other server-based \niden\u00adti.cation protocols, such as Kerberos, Passport, and SAML. A dis\u00adtinguishing feature is that it \nis built using the standard mechanisms of web services security. Our code is written in F# and was developed \nfor an earlier veri.cation case study (Bhargavan et al. 2008b) using ProVerif. Its modular structure \nis shown in the .gure on the .rst page. In addition to the trusted libraries LibX and the protocol libraries \nPrincipals and Patterns, the implementation consists of library modules implementing various web services \nsecurity speci.cations and modules implementing the CardSpace protocol. (We added type annotations, but \ndid not need to change any code for the XML protocol stack.) Flexible Message Formats: XML Digital Signatures \nIn stan\u00addardized protocols such as CardSpace, most of the programming effort is in correctly implementing \nthe message formats for inter\u00adoperability. Protocols built on web service security must also deal with \nthe inherently .exible nature of the XML message format. An XML signature is far more than a few bytes \ncontaining a MAC or signature value; it carries XML metadata indicating how those bytes were computed \n(in two stages) and how to use the signature. For the .rst stage, it embeds a list of references to the \nXML elements it is authenticating, a cryptographic hash of each of these elements, and the names of algorithms \nused to canonicalize and hash those elements; for the second stage, it embeds a signature computed on \nthose hashes, its algorithm, and a reference to its signing key. For example, a typical signature of \nn elements t1, ..., tn using an RSA signing key ska takes the form: <Signature> si= <SignedInfo> ... \n<Reference uri=\"#1\"> <Transforms> <Transform Algorithm=C14n /> </> <DigestMethod Algorithm=SHA1 /> <DigestValue> \nbase64 (sha1 (utf8 (c14n t1))) </> </Reference> ... <Reference uri=\"#n\"> ... </Reference> </SignedInfo> \n<SignatureValue> base64 (rsa sign ska (utf8 (c14n si)))</> <KeyInfo>... a sX.509 Certi.cate ...</> </Signature> \nTo process such a signature, the veri.er retrieves the elements, veri.cation key, and the algorithms, \nand reconstructs the signature value. The signature may include any number of target elements, so the \nveri.er may have to check a signature of unbounded length. This is beyond most cryptographic veri.cation \ntechniques: earlier analyses of XML signature protocols limit the maximum number of signed elements, \nessentially treating lists as tuples (Bhargavan et al. 2006a; Kleiner and Roscoe 2005). With explicit \ntype an\u00adnotations, however, we capture the full .exibility of XML signa\u00adtures. We use a recursive predicate \nIsReferenceList to represent the list of <Reference> elements, and use it to de.ne a predicate IsSignedInfo \nthat re.ects the schema of the <SignedInfo> ele\u00adment. We enforce the invariant that all messages signed \nwith XML signature keys have the structure de.ned in IsSignedInfo.  Protocols and Libraries F# Program \nF7 Typechecking FS2PV Veri.cation Modules Implementation Interface Checking Time Queries Verifying Time \nTrusted Libraries (Symbolic) 5 926 lines* 1167 lines 29s (Not Veri.ed Separately) RPC Protocol (Section \n3) 5+1 + 91 lines + 103 lines 10s 4 6.65s Principals (Section 5) 1 207 lines 253 lines 9s (Not Veri.ed \nSeparately) Cryptographic Patterns (Section 5) 1 250 lines 260 lines 17.1s (Not Veri.ed Separately) Otway-Rees \n(Section 5) 2+1 + 234 lines + 255 lines 1m 29.9s 10 8m 2.2s Otway-Rees (No MACs) 2+1 + 265 lines - (Type \nIncorrect) 10 2m 19.2s Secure Conversations 2+1+1 + 123 lines + 111 lines 29.64s (Cannot Be Veri.ed) \nWeb Services Security Library 7 1702 lines 475 lines 48.81s (Not Veri.ed Separately) X.509-based Client \nAuth (Section 6) 7+1 + 88 lines + 22 lines + 10.8s 2 20.2s Password-X.509 Mutual Auth 7+1 + 129 lines \n+ 44 lines + 12.0s 15 44m X.509-based Mutual Auth (Section 6) Windows CardSpace (Section 6) 7+1 7+1+1 \n+ 111 lines + 1429 lines + 53 lines + 309 lines + 10.9s + 6m 3s 18 6 51m 66m 21s* Using similar predicates, \nwe verify modules implementing each of the needed web services security speci.cations. We write LibWS \nfor our web services security library composed of LibX, Principals, Patterns, SOAP, WS-Addressing, XML-Signature, \nXML-Encryption, WS-Security, and WS-Trust. LEMMA 9 LibWS is a re.ned module. Composing Cryptographic \nPatterns: Secure XML Request/Re\u00adsponse Each message exchange in CardSpace implements a se\u00adcure request/response \nprotocol built on top of the web services se\u00adcurity library. Unlike the RPC protocol of Section 3, this \nprotocol guarantees both authentication and con.dentiality, and uses many of the composite cryptographic \npatterns introduced in Section 5. XML .exibility also has a cost: the messages we verify are large (up \nto 15k) and complex (up to 17 cryptographic operations). We describe an instance of the protocol using \nasymmetric keys. Assume principal a has a private key ska, b has a public key pkb, and both a and b have \nexchanged their public keys using X.509 certi.cates. The protocol below uses four cryptographic patterns \nimplemented for XML: derived keys, hybrid encryption, sign-then\u00adencrypt, and endorsing signatures. Secure \nXML Request/Response (X.509 Mutual Authentication): a: Generate kab, n1, n2 a: Derive k1 = psha1 kab \nn1, k2 = psha1 kab n2  1. a . b: rsa pkb kab | n1 | n2 | XML-Encrypt k2 S1 (where S1 = XML-Sign k1 [m1]) \n| XML-Encrypt k2 S2 (where S2 = XML-Sign ska [S1]) | XML-Encrypt k2 m1 b: Generate n3, n4 b: Derive \nk3 = psha1 kab n3, k4 = psha1 kab n4  2. b . a: n3 | n4 | XML-Encrypt k4 S3 (where S3 = XML-Sign k3 \nm2) | XML-Encrypt k4 m2 Before sending the request (message 1), a generates a fresh keyseed kab and two \nnonces n1 and n2. It uses kab and the nonces to derive a MAC key k1 and an encryption key k2. It signs \nthe message m1 with k1 to obtain the XML signature S1, and then signs S1 with ska to obtain the endorsing \nXML signature S2. Finally, it separately encrypts S1, S2, and m1 with the encryption key k2. The response \n(message 2) is simpler; b derives two keys k3 and k4 and uses them to sign and then encrypt the response \nmessage m2. The security goals are mutual authentication of a and b, plus authentication and secrecy \nof m1 and m2. These goals are veri.ed by typechecking the protocol code against the web services security \nlibrary LibWS (including Patterns). LEMMA 10 LibWS; SecureRPC is a re.ned module. Composing Protocols: \nCardSpace We assemble CardSpace by composing two XML request/response exchanges. To avoid repeat\u00ading \nthe message formats, we abstractly represent each request mes\u00adsage by Requesti k1 k2 [m1;...;mn], where \nk1 and k2 are the keys of the sender and recipient (ska and pkb in the XML request/re\u00adsponse protocol \nabove), and [m1; ... ; mn] is the list of message el\u00adements protected by the protocol (m1 above). The \ncorresponding responses are represented by Responsei [m1; ... ; mn]. CardSpace Protocol (using X.509 \nMutual Authentication): 1. C . IP: Request1 skC pkIP [TokenRequest(RP, pkRP)] IP: Issue token t = Token(id,C,RP,kt) \n 2. IP . C: Response1 [t;XML-Encrypt pkRP t] 3. C . RP: Request2 kt pkRP [t; m1] 4. RP . C: Response2 \n[m2]  In the .rst exchange, the client C requests a token from identity provider IP for use at RP. The \nIP responds with a signed token t (in the syntax of SAML), containing C s identity information id, and \na key kt that C may use at RP to prove its possession of t. The IP also encrypts t for RP and sends it \nto C; C forwards this token in its subsequent request to RP, and uses the key kt to authenticate the \nrequest (m1). The RP decrypts the token t and checks IP s signature on it to convince itself of C s identity, \nbefore responding with m2. The security goal of the protocol is the authentication of C s identity id \nat RP, and the secrecy and authentication of m1 and m2. LEMMA 11 LibWS;SecureRPC;CardSpace is a re.ned \nmodule. 7. Performance Evaluation The table above summarizes our veri.cation results for the proto\u00adcols \nand libraries described in this paper. Each row lists the number of modules and lines of code in the \nF# protocol implementation, the number of lines in the F7 typed interface, and the time for ver\u00adi.cation \nby typechecking. The F7 interface extends the F# module interface with security assumptions, theorems, \nand goals, as well as type annotations needed for veri.cation. For comparison, the ta\u00adble also lists, \nwhere applicable, the results of verifying the proto\u00adcol implementation through the FS2PV/ProVerif tool \nchain: it lists the number of queries (security goals) proved and their veri.cation time. All experiments \nwere performed on an Intel Xeon workstation with two processors at 2.83 GHz, with 32GB memory, and running \nWindows Server 2008. (Most of these ProVerif results have been published in earlier work.) The .rst part \nof the table corresponds to the RPC protocol of Section 3. The .rst row is for the trusted libraries \nLib; the * indicates that we verify their idealized symbolic implementation, not their concrete code. \nThe second row is for the RPC protocol; since the libraries are veri.ed once and for all, this row shows \nonly the incremental lines of code and type checking for verifying RPC. In contrast, ProVerif veri.es \nboth Lib and RPC together. For small examples such as this, we .nd that the domain-speci.c analysis of \nProVerif is faster than F7.  The second part corresponds to the libraries and protocols of Section 5. \nThe .rst and second rows are for Principals and Pat\u00adterns. The third row corresponds to the Otway-Rees \nprotocol. We .nd that the incremental typechecking time of Otway-Rees is only 1m 29.9s, whereas ProVerif \ntakes 8m 2.2s to verify the protocol. Even adding veri.cation times for the libraries, we .nd that type\u00adchecking \nwith F7 is much faster than ProVerif. Our typed cryp\u00adtography is more realistic than typical ProVerif \nmodels; for in\u00adstance it tells the difference between authenticated and unauthen\u00adticated encryption: \nwith unauthenticated encryption, typechecking fails to verify Otway-Rees (fourth row) but ProVerif still \nsucceeds. (Weaker assumptions can sometimes be coded in ProVerif but are not provided by default.) The \nprotocol in the .fth row implements the unbounded secure conversations protocol. The typechecker eas\u00adily \nveri.es this recursive code, but ProVerif cannot, and fails to terminate. For recursive code, typechecking \nlet the programmer provide hand-written (recursive) invariants; fully automated model checkers and theorem \nprovers (like ProVerif) lack this facility. The third part corresponds to protocols of Section 6, arranged \nin increasing complexity leading up to the CardSpace protocol. The .rst row presents veri.cation results \nfor the web services se\u00adcurity libraries LibWS. We then present veri.cation results for a single-message \nclient authentication protocol, two secure re\u00adquest/response protocols, and the CardSpace protocol. We \n.nd that the incremental typechecking time scales almost linearly with the size of the protocol code. \nIn contrast, the ProVerif veri.cation time increases exponentially with the protocol complexity (for \neach ex\u00adtra layer of encryption or signature, or each extra message). For instance, ProVerif takes less \nthan a minute to analyze the client authentication protocol but up to an hour to verify mutual authen\u00adtication \nprotocols. The jump in analysis time is primarily because ProVerif has to account for all possible dependencies \nbetween the two messages, such as whether the adversary may use the second message of a session to compromise \nthe .rst message of another session. The increase in veri.cation complexity makes it infeasi\u00adble to verify \nthe whole CardSpace protocol using ProVerif. Indeed, in the last row of the table, the * indicates that \nthe ProVerif ver\u00adi.cation only applies when the number of clients and servers are limited to at most \ntwo each (one honest and one compromised prin\u00adcipal for each role) and when the full XML message formats \nin the web services security libraries are abstractly represented as tuples. Even with these restrictions, \nProVerif takes 66m 21s to verify the protocol implementation. In contrast, typechecking incrementally \nveri.es CardSpace in a few minutes. We conclude that typechecking scales far better than whole\u00adprogram \nanalyses for security protocols. As a trade-off, the pro\u00adgrammer must declare their usage of cryptography \nby providing annotations in the typed interface of each protocol. 8. Related Work FS2CV (Bhargavan et \nal. 2008a) is the .rst tool to verify properties in the computational model of implementation code of \nsecurity protocols. FS2CV generates inputs to CryptoVerif (Blanchet 2006) from the implementation code \nin F#. It has been applied to an F# implementation of TLS. ASPIER (Chaki and Datta 2009) has been applied \nto verify code of the central loop of OpenSSL. It performs no interproce\u00addural analysis and relies on \nunveri.ed user-supplied abstractions of all functions called from the central loop. ASPIER is based on \nsoftware model-checking techniques, and proves properties of OpenSSL assuming bounded numbers of active \nsessions The RCF system of re.nement types is similar to that of recent systems such as SAGE (Flanagan \n2006) and Dsolve (Rondon et al. 2008), although neither of these systems allows full .rst-order formulas \nas re.nements. Still, we expect with a little adaptation tools such as these could support our method. \nAcknowledgements Franc\u00b8ois Dupressoir, Nataliya Guts, and C.at.alin Hrit\u00b8cu suggested improvements to \nthe paper. References M. Abadi. Secrecy by typing in security protocols. JACM, 46(5):749 786, 1999. \nM. Bellare and C. Namprempre. Authenticated encryption: Relations among notions and analysis of the generic \ncomposition paradigm. J. Cryptology, 21(4), 2008. J. Bengtson, K. Bhargavan, C. Fournet, A. D. Gordon, \nand S. Maffeis. Re.nement types for secure implementations. Technical Report MSR TR 2008 118, Microsoft \nResearch, 2008. See also CSF 08. K. Bhargavan, C. Fournet, and A. D. Gordon. Veri.ed reference implemen\u00adtations \nof WS-Security protocols. In WS-FM 06, LNCS 4184, 2006a. K. Bhargavan, C. Fournet, A. D. Gordon, and \nS. Tse. Veri.ed interoperable implementations of security protocols. In CSFW 06, 2006b. K. Bhargavan, \nC. Fournet, R. Corin, and E. Zalinescu. Cryptographically veri.ed implementations for TLS. In ACM CCS, \npages 459 468, 2008a. K. Bhargavan, C. Fournet, A. D. Gordon, and N. Swamy. Veri.ed imple\u00admentations \nof the Information Card federated identity-management pro\u00adtocol. In ASIACCS 08, pages 123 135, 2008b. \nB. Blanchet. An ef.cient cryptographic protocol veri.er based on Prolog rules. In CSFW 01, pages 82 96, \n2001. B. Blanchet. A computationally sound mechanized prover for security protocols. In IEEE Symposium \non Security and Privacy, 2006. I. Cervesato, A. D. Jaggard, A. Scedrov, J.-K. Tsay, and C. Walstad. Break\u00ading \nand .xing public-key Kerberos. Information and Computation, 206 (2-4):402 424, 2008. S. Chaki and A. \nDatta. ASPIER: An automated framework for verifying security protocol implementations. In CSF 09, 2009. \nE. Cohen. TAPS: A .rst-order veri.er for cryptographic protocols. In 13th IEEE Computer Security Foundations \nWorkshop, pages 144 158, 2000. L. de Moura and N. Bj\u00f8rner. Z3: An ef.cient SMT solver. In TACAS 08, pages \n337 340. Springer, 2008. LNCS 4963. D. Dolev and A. Yao. On the security of public key protocols. IEEE \nTransactions on Information Theory, IT 29(2):198 208, 1983. C. Flanagan. Hybrid type checking. In ACM \nPOPL 06, pages 245 256, 2006. A. D. Gordon and A. S. A. Jeffrey. Authenticity by typing for security \nprotocols. J. Computer Security, 11(4):451 521, 2003a. A. D. Gordon and A. S. A. Jeffrey. Types and effects \nfor asymmetric cryptographic protocols. J. Computer Security, 12(3/4):435 484, 2003b. J. Goubault-Larrecq \nand F. Parrennes. Cryptographic protocol analysis on real C code. In VMCAI 05, pages 363 379, 2005. C. \nGunter. Semantics of programming languages. MIT Press, 1992. E. Kleiner and A. W. Roscoe. On the relationship \nbetween web services security and traditional protocols. In MFPS XXI, 2005. G. Lowe. Breaking and .xing \nthe Needham-Schroeder public-key protocol using FDR. In TACAS, pages 147 166, 1996. LNCS 1055. J. H. \nMorris, Jr. Protection in programming languages. Commun. ACM, 16 (1):15 21, 1973. R. Needham and M. Schroeder. \nUsing encryption for authentication in large networks of computers. Commun. ACM, 21(12):993 999, 1978. \nL. Paulson. The inductive approach to verifying cryptographic protocols. J. Computer Security, 6:85 128, \n1998. L. C. Paulson. Logic and proof. Cambridge University lecture notes, 2008. G. D. Plotkin. Denotational \nsemantics with partial functions. Unpublished lecture notes, CSLI, Stanford University, July 1985. P. \nRondon, M. Kawaguchi, and R. Jhala. Liquid types. In ACM PLDI 08, pages 159 169, 2008.  \n\t\t\t", "proc_id": "1706299", "abstract": "<p>We propose a method for verifying the security of protocol implementations. Our method is based on declaring and enforcing invariants on the usage of cryptography. We develop cryptographic libraries that embed a logic model of their cryptographic structures and that specify preconditions and postconditions on their functions so as to maintain their invariants. We present a theory to justify the soundness of modular code verification via our method.</p> <p>We implement the method for protocols coded in F# and verified using F7, our SMT-based typechecker for refinement types, that is, types carrying formulas to record invariants. As illustrated by a series of programming examples, our method can flexibly deal with a range of different cryptographic constructions and protocols.</p> <p>We evaluate the method on a series of larger case studies of protocol code, previously checked using whole-program analyses based on ProVerif, a leading verifier for cryptographic protocols. Our results indicate that compositional verification by typechecking with refinement types is more scalable than the best domain-specific analysis currently available for cryptographic code.</p>", "authors": [{"name": "Karthikeyan Bhargavan", "author_profile_id": "81100070918", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P1911139", "email_address": "", "orcid_id": ""}, {"name": "C&#233;dric Fournet", "author_profile_id": "81100547450", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P1911140", "email_address": "", "orcid_id": ""}, {"name": "Andrew D. Gordon", "author_profile_id": "81100037731", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P1911141", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706350", "year": "2010", "article_id": "1706350", "conference": "POPL", "title": "Modular verification of security protocol code by typing", "url": "http://dl.acm.org/citation.cfm?id=1706350"}