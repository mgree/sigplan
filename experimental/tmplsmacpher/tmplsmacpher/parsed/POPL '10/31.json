{"article_publication_date": "01-17-2010", "fulltext": "\n Integrating Typed and Untyped Code in a Scripting Language \u00a8 Tobias Wrigstad Francesco Zappa Nardelli* \nSylvain Lebresne Johan Ostlund JanVitek PURDUE UNIVERSITY * INRIA Abstract Manylarge software systems \noriginate from untyped scripting lan\u00adguage code. While good for initial development, the lack of static \ntype annotations can impact code-quality and performance in the long run. We present an approach for \nintegrating untyped code and typed code in the same system to allow an initial prototype to smoothlyevolveintoanef.cientandrobust \nprogram.Weintroduce like types, a novel intermediate point between dynamic and static typing. Occurrences \nof like types variables are checked statically within their scopebut,astheymaybe boundto dynamicvalues, \ntheir usage is checked dynamically. Thus like types provide some of the bene.ts of static typing without \ndecreasing the expressive\u00adnessof the language.We providea formal accountof like typesin a core object \ncalculusandevaluate their applicabilityinthe context of a new scripting language. Categories and Subject \nDescriptors DSoftware[D.3 Programming Languages]: D.3.1Formal De.nitions and Theory General Terms Theory \nKeywords Compilers, Object-orientation, Semantics,Types 1. Introduction Scripting languagesfacilitate \nthe rapid development of fully func\u00adtional prototypes thanks to powerful features that are often inher\u00adently \nhard to type. Scripting languages pride themselves on opti\u00admizing programmer time ratherthan machine \ntime, whichis espe\u00adcially desirable in the early stages of program development before requirements stabilize \nor are properly understood. A lax view of what constitutes a valid program allows execution of incomplete \nprograms, a requirement of test-driven development. The absence of types also obviates the need for early \ncommitment to particular data structures and supports rapid evolution of systems. However, as programs \nstabilize and mature e.g. a temporary data migra\u00adtion script .nds itself juggling with the pension bene.ts \nof a small country [31] the once liberating lackof types becomesaproblem. Untyped code, or more precisely \ndynamically typed code, is hard to navigate, especially for maintenance programmers not involved inthe \noriginal implementation.Theeffectsofrefactoring,bug.xes and enhancements are hard to trace. Moreover \nperformance is often notonparwith more static languages.A commonwayof dealing with this situation is \nto rewrite the untyped program in a statically typed language such as C# or C++. Apart from being costly \nand Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n10, January 17 23, 2009, Madrid, Spain. Copyright c . 2009ACM 978-1-60558-479-9/10/01... $10.00 farfrom \nguaranteedto succeed[35],a completerewriteislikelyto slow down future development as it is a snapshot \nof the dynamic system at one particular point in time. Not surprisingly, the idea of being able to gradually \nevolve a prototype into a full-.edged pro\u00adgram within the same language has been a long standing challenge \nin the dynamic language community [3, 8, 22, 28, 32, 33]. Anearly attemptat bridgingthegap betweendynamicand \nstatic typing is the soft typing proposedbyCartwright andFagan [12] and subsequently applied to a variety \nof languages [2, 9, 17, 23, 24]. Soft typing tries to transparently superimpose a type system on unannotated \nprograms, inferring types for variables and functions. When an operation cannot be typed, a dynamic check \nis emitted and, possibly, awarning for the programmer.Acompiler equipped with a soft type checker would \nnever reject a program, thus pre\u00adserving expressivity of the dynamically typed language. The main bene.t \nof soft typing is the promise of more ef.cient program exe\u00adcution and warnings for potentially dangerous \nconstructs. Its draw\u00adback is the lack of guarantees that a given piece of code is free of errors.Itisthusnot \npossiblefor programmerstotakekeypiecesof their system and make them safe, orfast. Furthermore, no guid\u00adance \nis given on how to refactor code that is not typable. Incremental typing schemes have been explored by \nBracha and Griswold in Strongtalk [8] which inspired pluggable types [7], in various gradualtype systems[3,19,26,29,30],and \nrecentlyTyped Scheme [32, 33]. In these works, dynamically typed programs can be incrementally annotated \nwith static type information and un\u00adtyped values are allowed to cross the boundary between static and \ndynamic code. Run-time type checks are inserted at appropriate points to ensure that values conform to \nthe annotations on the vari\u00adables they are bound to. The strength of incremental approaches is that programmers \ncan decide which parts of their program to an\u00adnotate and will get understandable error messages when \ncode does nottype check.Thedrawbackisthatanyoperation,evenonethatis fully annotated,mayfailduetoa non-conformingvalue \npassedin from an untyped context. This has a direct consequence on perfor\u00admance as type information can \nnot be used for optimization. Even worse, program performance may decrease substantially when type annotations \nare added to an untyped program. While our goal is related to this previous work, namely to explore practical \ntechniques for evolving scripts to programs, we come from a different perspective which impacts some \nof our design decisions. Unlike most of the previous work which had its root in dynamically typed languages \n(Smalltalk, Scheme, Ruby and JavaScript) and tried to provide static checking, we would like to provide \nthe .exibility of dynamic languages to static languages. At the language level, we are willing to forgo \nsome of the most dynamic features of languages, such are run-time modi.cation of object interfaces, in \nlanguages like JavaScript or Ruby. At the implementation level, the addition of opcodes to support dynamic \nlanguages in Java virtual machines makes it possible to envision mixing typed and untyped code without \nsacri.cing performance. The research question is thus how to integrate these different styles of programming \nwithin the same language. In particular, it would notbe acceptablefor staticallytypedcodeto eitherexperience \nrun\u00adtimefailuresorbe compiledina lessef.cientto support dynamic values. Conversely, the expressiveness \nof dynamic parts of the system shouldnotbe restrictedbythe mere presenceof statictypes in unrelated parts \nof the system.  We use, as a vehicle for our experiments, a new object-oriented scripting language called \nThorn [6] which runs on a JVM and ought to support the integration of statically and dynamically typed \ncode. The statically typed part of Thorn sportsaconventional nom\u00adinal type system with multiple subtyping \nakin to that of Java. Thorn has also a fully dynamic part, where every object is of type dyn and all \noperations performed on dyn objects are checked at run\u00adtime.Weintroduceanovel intermediate point, dubbeda \nliketype, between dynamic and compile-time checked static types.For each type C, there is a type like \nC. Uses of variables of type like C are checked statically and must respect C s interface. However, at \nrun-time, any value can .ow into a like C variable and their con\u00adformance to C is checked dynamically. \nLike types allow the same degree of incrementality as previous proposals for gradual typing, butwehave \nchosena design whichfavorsef.ciency.In contrastto inference-based systems, like types allow static checking \nof opera\u00adtions against an explicit, programmer-declared, protocol. Notably, this allows catching spelling \nerrors and argument type errors which are simple and frequent mistakes. Furthermore theymake it possi\u00adble \nto provide IDE support such as code completion. To summarize, this paper makes the following contributions: \n Atype system that incorporates dynamic types, concrete types and like types to provide a way to integrate \nuntyped and typed code. The separation of concrete and like types makes it possi\u00adble to optimize concretely \ntyped code, and retain .exibility in the rest of the program.  Aformalization of the type system in \nan imperative class-based object-oriented language; a proof of the standard theorems for typed subsets \nof the code; a formalization of a wrapper-less compilation scheme, and a proof of its adequacy.  An \nimplementation in the Thorn compiler that supports the type system and performs optimizations for concretely \ntyped code.  A report on an application of like types to evolve an untyped script into a partially typed \nprogram.  A technical report extended with proofs is available at http:// moscova.inria.fr/~zappa/projects/liketypes. \n2. Background and Motivating Example This section introduces closely related work dealing with the inte\u00adgration \nof dynamically typed and statically typed code through a series of examples written in Thorn [6]. The \nTyping of a Point. In a language that supports rapid pro\u00adtotyping, it is sometimes convenient to start \ndevelopment without committingtoa particular representationfor data.Declaringatwo\u00addimensional Point class \nwith two mutable .elds x and y and three methods(getX, getY, and move)can be done with every variable \nand method declaration having the (implicit) type dyn. Run-time checks are then emitted to ensure that \nmethods are present before attempting to invoke them. class Point(var x, var y) { def getX() = x; def \ngetY() = y; def move(pt) { x:=pt.getX(); y:=pt.getY() } } Asa.rststeptoward assurance,the programmermay \nchoosetoan\u00adnotate the coordinates with concrete types, say Int for integer,but leave the move method \nunchanged allowing it to accept anyobject that understands getX() and getY(). The bene.t of such a refac\u00adtoring \nis that a compiler could emit ef.cient code for operations on the integer .elds. As the argument to move \nis untyped, casts may be needed to ensure that values returned by the getter methods are of the right \ntype. class Point(var x: Int, var y: Int) { def getX(): Int = x; def getY(): Int = y; def move(pt){ x:= \n(Int)pt.getX(); y:= (Int)pt.getY()} } Of course, this modi.cation is disruptive to clients of the class: \nall places where Point is constructed must be changed to ensure that arguments have the proper static \ntype. In the long run, the pro\u00adgrammermaywant more assuranceforinvocationsof move(),e.g., by annotating \nthe argument of the method as pt:Point. This has the bene.t that the casts in the method s body become \nsuper.uous. This has the drawback that all client code must (again) be revisited to add static type annotations \non arguments and decreases .exibil\u00adity of the code, as clients may call move passing an Origin object. \nclass Origin { def getX(): Int = 0; def getY(): Int = 0; } While not a subclass of point, and thus failing \nto type check, Origin has the interface required by the method. This is not un\u00adusual in dynamically typed \nprograms.Part of the last issue could be somewhatmitigatedbythe adoptionof structural subtyping[10]. \nThiswouldliftthe requirementthatargumentof move beadeclared subtype Point andwould acceptanytypewiththesame \nsignature. Unfortunately, this is not enough here, as Origin is not a struc\u00adtural subtype either. The \nsolution to this particular example is to invent a more general type, such as getXgetY which has exactly \nthe interface required by move. class getXgetY { def getX(): Int; def getY(): Int; } This solution does \nnot generalize as, if it was applied systemati\u00adcally, it would give rise to many special purpose types \nwith little meaning to the programmer. A combination of structural and in\u00adtersection types are often \nthe reasonable choice when starting with an existing untyped language such as Ruby, JavaScript or Scheme \n(see forexample [17, 33])but theyadd programmerburden, asa programmer mustexplicitly provide type declarations, \nand are brit\u00adtleinthe presenceof small changestothe code.For these reasons, Typed Scheme is moving from \nstructural to nominal typing.1 Soft Typing. Asoft typing system in the tradition of Cartwright andFagan \n[12]would infera type such as getXgetY above with\u00adout programmer intervention. Thus obviating the need \nto litter the code withoverly speci.c types,but soft typingis inherently brittle as something as trivial \nas a spelling mistake in a method name will generate a constraint that will never be satis.ed and only \ncaught when the method is actually used by client code. Also, inferred types can easily get unwieldy \nand hard to understand for a human programmer. Furthermore, the absence of type declarations means programmers \nwill not have much help from their IDE. In terms of performance, run-time checks are eliminated when \nthe compiler can show that an operation is safe. This makes the performance 1Matthias Felleisen, presentation \nat the STOP 09 (Script to Program Evo\u00adlution) workshop.  model opaque as a small change in the code \ncan have a large im\u00adpact on performance simply because it prevents the compiler from optimizing an operation \nin a hotspot. The work on soft typing can be traced to early work by Cartwright [11] and directly in.uenced \nresearch on soft Scheme [36] and Lagorio et al. s Just [2, 23] bring\u00ading soft typing to Java. Gradual \ntyping. The gradual typing approach of Siek andTaha allows for typed and untyped values to commingle \nfreely [26]. Whenanuntypedvalueis coerced,orcast,toatypedvalue,a wrap\u00adper is inserted to verify that \nall further interactions through that particular reference behave according to the target type s contract. \nAt the simplest a wrapper is a cast .T . R. saying, intuitively, that the value was of type R and must \nbehave as a value of type T . The number of wrappers is variable and can, in pathological cases, be substantial \n[19]. In practice, anyprogram that has more than a single wrapper for any value is likely to be visibly \nslower. In the presence of aliasing and side-effects the wrappers typically can not be dischargedonthespotandhavetobekeptaslongasthevalue \nis live. The impact of this design choice is that anyoperation on a value mayfailif thatvalueisa dynamic \ntype which does not abide bythe contract imposedbyits wrapper. Wrapperhavetobe manip\u00adulated at run-time \nand compiler optimizations are inhibited as the compiler has to emit code that assumes the presence of \nwrappers everywhere.Someofthese problemsmaybeavoidedwith program analysis,butthereis currentlyno publishedworkthat \ndemonstrates this.To provide improved debugging support researchers have in\u00advestigated the notion ofblame \ncontrol in the context of gradual typ\u00ading, [14, 29, 32, 34]. The underlying notion is that concretely \ntyped parts of a program should not be blamed for run-time type errors. As an example, let T be a type \nwith a method m and x be a vari\u00adable of type T. Now, if some object o, that does not understand m, is \nstored in T,blame tracking will not blame the callx.m() which is correct as x has type T for throwing \na message not understood exception at run-time. Rather, it will identify the place in the code where \no was cast to T. Fine-grained blame control requires that a reference remembers each cast it .ows through, \nperhaps modulo optimizations on redundant casts. Storing such information in ref\u00aderencesandnotin objectsiskeyto \nachieve traceability,but incurs additional run-time overhead on top of the run-time type checks. Evaluating \nthe performance impact of blame tracking and its prac\u00adtical impact on the ability to debug gradually \ntyped programs has not yet been investigated.We use the term gradual typing to refer toafamilyof approaches \nthat includeshybrid typing [15] and that have their roots in a contract-based approach of [14, 18]. 3. \nA Type System for Program Evolution In this paper we propose a type system for a class-based object\u00adoriented \nprogramming language with three kinds of types. Dynamic types, denoted by the type dyn, represent values \nthat are manipu\u00adlated with no static checks. Dynamic types offer programmers max\u00adimal .exibility as anyoperation \nis allowed, as long as the target ob\u00adject implements the requested method. However, dyn gives little \naidto.ndbugs,to capturedesign intents,ortoprove properties.At the other extreme, we depart from previous \nwork on gradual typ\u00ading,by offering concrete types. Concrete types behave exactly how programmers steepedin \nstatically typed languageswouldexpect.A variable of concrete type C is guaranteed to refer to an instance \nof C or one of its subtypes. Concrete types drastically restrict the values that can be bound to a variable \nas theydo not support the notion of wrapped values found in other gradual type systems. Concrete types \nare intended tofacilitate optimizations such as unboxing and inlining as the compiler can rely on the \nstatic type information to emit ef.cient code. Finally, as an intermediate step between the two, we propose \nlike types. Like types combine static and dynamic checkingina novelway.For any concrete type C, there \nis a cor\u00adresponding like type, written like C, with an identical interface. Whenever a programmer uses \na variable typed like C, all manipu\u00adlations of that variable are checked statically against C s interface, \nwhile, at run-time, all uses of the value bound to the variable are checked dynamically. Figure1shows \nthe relations between types (dyn will be implicit in the code snippets). Full arrows indicate traditional \nsubtype relations (so, for instance if B is a subtype of A, then like B is a subtype of like A), dotted \nlines indicate implicit dyn casts, and .nally, dashed lines show situations where like casts are needed. \nIn this paper, we have chosen a nominal type system, thus sub\u00adtype relation between concrete types must \nbe explicitly declared by extends clauses. While we believe that our approach applies equally well to \nstructural types, our choice is motivated by prag\u00admatic reasons. Using class declarations to generate \neponymous typesisa compactandfamiliar(to most programmers)wayto con\u00adstruct a type hierarchy. Moreover, \ntechniques for generating ef.\u00adcient .eld access and method dispatch code sequences for nominal languagesare \nwell known and supportedby most virtual machines. The .rstkeyproperty of like type annotations is that \nthey are local. This is both a strength and a limitation. It is a strength because it enables purely \nlocal type checking. Returning to our example, like types allow us to type the parameter to move thus: \ndef move(p: like Point) { x := p.getX(); y := p.getY(); p.hog(); # !Raises a compile time error! } Declaring \nthe variable p to be like a Point, makes the compiler checkall operationsonthatvariableagainstthe interfaceof \nPoint. Thus, the call to hog would be statically rejected since there is no such method in Point. The \nannotation provides the static informa\u00adtion necessary to enable IDE support commonly found in statically \ntyped languages (but not in dynamic ones). The secondkeyproperty is that like types do not restrict .exi\u00adbility \nof the code. Declaring a variable to be like C is a promise on how that variable is used and not to what \nvalue that variable canbe bound to.For the client code,a like typed parameteris sim\u00adilar to a dyn. The \nquestion of when to test conformance between a variable s type and the value it refers to is subtle. \nOne of our goalswasto ensurethatthe additionofliketype annotationswould not break working code. In particular, \nadding type annotations to a library class should not cause all of its clients to break. So in\u00adstead \nof checking at invocation time, each use of a like typed vari\u00adable is preceded by a check that the target \nobject has the requested method.Ifthecheckfails,arun-timeexceptionisthrown. Consider Figure 1. Type \nRelations.C and D are unrelated by inheritance.  the Coordinate class, which is similar to Point,but \nlacks a move method: class Coordinate(var x: Int, var y: Int) { def getX(): Int = x; def getY(): Int \n= y; } In our running example, if move expects a like Point, then call\u00ading move with a Coordinate works \nexactly as in an untyped lan\u00adguage. Even if Coordinate does not implement the entire Point protocol, \nit implements the relevant parts, the methods needed for move to run successfully. If it lacked a getY \nmethod, passing a Coordinate to move would compile .ne,but resultin anexcep\u00adtion at run-time. More interestingly, \nmove can also accept an un\u00adtyped de.nition of Coordinate: class Coord(x,y) { def getX() = x; def getY() \n= y; } Here,the run-time returnvalueof getX and getY are tested against Int: invoking move with the argument \nCoord(1,2) would suc\u00adceed, Coord(\"a\",\"b\") would raise an exception. Observe that if Point used like Int, \nchecking the return type would not be nec\u00adessary as assigning to a like type always succeeds. Interfacing \ntyped and untyped code. Consideracall p1.move(p2) with different declared types for variables p1, p2 \nand pt (the type of the parameter in the move method). Depending on the static type information available \non the receiver, different static checks are enabled, and different run-time checks are needed to preserve \ntype-safety.Wego through thesein detailin Figure2. p1 p2 pt Result  dyn OK  like Point OK dyn Point \nPoint Point like Point like Point like Point dyn like Point Point dyn like Point Point Point Point Point \nPoint Point Point Point OK ERR OK * OK ERR OK * OK Figure 2. Con.gurations of declared types. The column \nlabeled Result indicate if there will be a compile-time error. Note that the calculus is slightly more \nstrict and requires explicit casts in cases labeled * . Assume that the parameter pt in move has type \ndyn, then all con\u00ad.gurations of receiver and argument are allowed and will compile successfully. In case \nthe parameter has the type like Point,again, all con.gurations are statically valid. The last case to \nconsider is when pt has the concrete type Point. In that case, there are sev\u00aderal subcases that need \nto be looked at. If the receiver p1 is un\u00adtyped,then,asexpected,no static checks are possible.At run-time, \nwe must consequently check that p1 understands the move method and if so, that p2 s run-time type satis.es \nthe type on the parameter in the move method. Since, pt is Point, a subtype test will be per\u00adformed at \nrun-time. If the receiver p1 is a concrete type, the type of the argument p2 will be statically checked: \nif it is dyn, a compile\u00adtime error will be reported; if it is like Point, the compiler will accept the \ncall and emit a run-time subtype test; if p2 is a Point a straightforward typed invocation sequence can \nbe emitted. Finally, the case where the receiver is declared like Point is similar to the previous case, \nwith the exception that a run-time test is emitted to check for the presence of a move method in p1. \nIf move had some concrete return type C, invoking it on a like typed receiver, would then check that \nthe value returned from the method was indeed a (subtype of) C. If this cannot be determined statically, \nfor instance if the actual method does not return a con\u00adcretetype,thenatypetestis performedonthevalue \nreturned.Calls with untyped receivers never need to type-check return values, as client code has no expectations \nthat must be met. The concretely typed case follows from regular static checking. Revisiting a previous \nexample, consider a variant of move with a call to getY guarded by an if and assume that p is bound at \nrun-time to an object that does not have a getY. def move(p: like Point) { x := p.getX(); if (unlikely) \ny := p.getY(); } As the system only checks uses of p, the error triggers if the condition is true. Some \nsituations, which are hard to type in systems that perform eager subtype tests, e.g., at the start of \nthe method call, work smoothly thanks to this lazy checking. As a result like types are not structural,but \nsemi-structural since theyonly require the methods called to be present. Code evolution. Like types provide \nan intermediate step between dynamic and concrete types. In some cases the programmer might want to replacelike \nC annotations with concrete C annotations,but this is not always straightforward. The reason is the shift \nin notion of subtype from(avarianton) structuralto nominal.Fortunately, studies of the use of dynamic \nfeatures in practice in dynamically typed programs [4, 20] suggest that many dynamic programs are really \nnot that polymorphic. When this is the case, the transition is as simple as removing the like keyword. \nChanging a piece of code that is largely like typed to use concrete types imposes an additional level \nof strictness on the code. Subsequently, stores from like typed (or dyn)variables into concretely typed \nvariables must be guarded by type checks. The Thorn compiler inserts these checks automatically where \nneeded and prints a warning to avoid suppressing actual compile-time errors. Notably, when accessing \na concretely typed .eldor callinga method with concrete return type onaliketypedreceiver,the resultingvaluewillbe \nconcretelytyped. Subsequent operations on the returned value will enjoy the same strict type checking \nas all concrete values and can be compiled more ef.ciently than operations on like typed receivers. In \nsome cases, one can imagine going from typed code to un\u00adtyped, for example to facilitate interaction \nwith some larger un\u00adtyped program, or to increase the .exibility in the code. Simply adding a like keyword \nin the relevant places, e.g., in front of typesinthe interface,oronkey variables, immediatelyallowsfor \na higher degree of .exibility without losing the local checking and stillkeeping the design intentin \nthe code. Compile-Time Optimizations In Thorn, all method calls go thro\u00adugh a dispatching function. With \nlike types, three different dis\u00adpatching functions are used to perform the necessary run-time checks \ndescribed above. Every user written method call is com\u00adpiled down to one of those dispatching functions \ndepending on the type informationavailableatthe call-site. The dispatching function used for untyped \ncalls performs run-time type checks and unboxes boxed primitives. The like typed dispatching function \nchecks that the intended method is actually present in the receiver and has com\u00adpatible types. The concretely \ntyped dispatching function performs asimpleandfastlookup,knowingthatthemethodis present.Addi\u00adtionally, \nif the static type of the argument is a like type when some concrete typeisexpected, the Thorn compiler \nwill insertarun-time type test and issue a warning. Like types allow interaction with an untyped object \nthrough a typed interface and guarantees that operations that succeed satisfy the typing constraints \nspeci.ed in the interface. Consider the fol\u00adlowing code snippet that declares two cells one for untyped \ncon\u00adtent and one for integers:  class Cell(var x) { def get() = x; def set(x ) { x:= x } } class IntCell(var \ni: Int) { def get(): Int = i; def set(j:Int) { i:= j } } box = Cell(32); y = box.get(); ibox: like IntCell \n= box; z: Int = ibox.get(); ibox.set(z+10); If ibox.get() succeeds, we statically know its return type \nto be an Int since the cell is accessed through a like typed interface. Subsequent operations on z enjoystatic \ntype checking and can be optimized, contrarily to uses of y.For example, the + operation on the last \nline can be compiled into machine instructions or equiva\u00adlent, rather thanahigh-level method call on \nan integer object. Alter\u00adnatively, the programmer might explicitly cast y to Int. However, typing the \ncell like IntBox type checks all interactions with the cell statically and gives static type information \nabout what is put into and taken from it: this requires a single annotation at a decla\u00adration rather \nthan casts spread all over the code. Relating Like Types to Previous Work Like types add local checking \nto code without restricting its use from untyped code. In contrast to gradual typing [3, 19, 26, 29, \n30] and pluggable types [7], it introduces an intermediate step on the untyped concretely typed spectrum \nand uses nominal rather than structural subtyp\u00ading. Furthermore, it only requires operations to be present \nwhen actually used. As a result, operations on concrete types can be ef.ciently implemented and like \ntypes used where .exibility is de\u00adsired. Typed Scheme [32, 33] uses contracts on a module level, rather \nthat simple type annotations, and does not work with ob\u00adject structures. Soft typing [12] infers constraints \nfrom code, rather than lets programmers expressly encode design intent in the form of type annotations. \nAdding soft typing to Java [2, 23]faces simi\u00adlar although fewer problems. An important difference between \nlike types and gradual typing systems like Ob? [26], is that code com\u00ad <: pletely annotated withlike \ntypes cango wrongduetoa run-time type error. On the other hand, a code completely annotated with concrete \ntypes will not go wrong. Aperhaps unusual design decision is the lack of blame control. Ifa methodfails, \ne.g.,duetoa missing methodinanargumentob\u00adject, we cannot point to the place in the program that subsequently \nlead to this problem. In this respect, the blame tracking support offered by like types is not much better \nthan what is offered by a run-time typecast error. This is a design decision. Nothing pre\u00advents adding \nblame control to like types in accordance with pre\u00advious work (e.g., [1, 27]). The rationale for our \ndesign is to avoid performance penalties.Keeping like types blame-free allows fora wrapper-less implementation. \nAs part of the aborted ECMAScript4standard, Cormac Flana\u00adgan proposeda type system closely relatedto \nthe one we presentin this paper [16]. The Objective-C language has liketypes for objects and no concrete \nobject types. Classes can be either dyn (called id) or like typed, and the compiler warns rather than \nrejects programs due to other language features that can make non-local changes to classes. 4. A Formalization \nof Like Types To investigate the meta-theory of like types we de.ne mini-Thorn, an imperative variant \nof FJ [21] extended with dyn and like types. Mini-Thorn isa languagetailoredtostudythe interaction between \nuntyped and typed code. Compared to FJ, it lacks subexpressions but allows assignment, because aliasing, \nand understanding what happens when objects are accessed through different views, is es\u00adsential to our \nstudy. Mini-Thorn also lacks some features of the Thorn type system (like multiple inheritance or method \noverload\u00adingonarity). Extendingthe formalizationwouldnotbedif.cultbut would take us away from the purpose \nof this section. The Thorn compiler checks source code without these restrictions. Types. We denote class \nnames by C , D, the dynamic type by dyn, and like types by like C where C is a class name. t ::= types \n| C class name | like C like class C | dyn dynamic The distinguishedclass name Object is also the top \nof the subtype hierarchy. The function concr (t) tests if the type t is concrete, and returns true if \nt isa class name andfalse otherwise. Programs. Aprogram consists of a collection of class de.nitions \nplusa statementtobeexecuted.Aclass de.nition class C extends D { fds ; mds } introduces a class named \nC with superclass D. The new class has .elds fds and methods mds;a .eld is de.ned by a type annotation \nand a .eld name tf , while a method is de.ned by its name m, its signature, and its body: tm (t1 x1 .. \ntk xk ) { s ; return x } . Statements include object creation, .eld read, .eld update, method call, and \ncast. Fields are private to objects, and can be accessed only froman object s scope.Withanabuseof notation,wewill \nconsider listsof statements, ratherthan trees.Weomit null-pointers:theonly run-time errors we are interested \nin this formalization are due to dynamic type-checks that fail. As a consequence, .elds must be initialized \nat object creation. s ::= statements | skip skip | s1 ; s2 sequence | this . f = x .eld update | x = \nthis . f .eld read | x = y . m (y1 .. yn ) method call | x = new C (y1 .. yn ) object creation | x = \ny copy | x =(t) y cast Static semantics. Figure3 de.nes the static semantics of mini-Thorn. Methodinvocationonan \nobject accessed throughavariable which has a dynamic type, e.g. x = y . m (y1 .. yn ) where G . y : dyn, \nis trivially well-typed: all type-checks are postponed to run\u00adtime. On the contrary, as in FJ, if the \nvariable y has a concrete type, e.g. G . y : C , then method invocation can be statically type checked; \nthe run-time guarantees that the objects actually accessed through y are instances of the class C (or \nof subclasses of C)and no run-time checks are needed.Type-checking method invocation boils down to ensuring \nthat the method exists, that the actual arguments matches the types expected by the method, and that \nthe type of the result matches the type of the return variable. Observe that type-checking of values \nis performed only if the expected typeis concrete, asin thehypothesis concr (ti ) . G . yi <: ti ;since \nanyvalue can be stored in a like or dynamic typed variable, no static type-checking is required. Like \ntypes behave as contracts between variables and contexts: if a variable has a like type, e.g. G . y : \nlike C , then a well-typed context uses it only as avariable pointing to an instance of the classC. Operations \non such  The subtyping relation<: is the re.exive and transitive relation closed under the rules below. \nclass C extends D { fds ; mds }C <: D C <: Object C1 <: C2 like C1 <: like C2 C <: like C Method lookup \nfunctions are inherited from FJ. C = Object mtype (m, C ) = . class C extends D { fds ; mds }t m (t1 \nx1 .. tk xk ) { s ; return x } . mds mtype (m, C ) = t1 .. tk . t class C extends D { fds ; mds }m /. \nmds mtype (m, C ) = mtype (m, D) class C extends D { fds ; mds } class C extends D { fds ; mds } tm \n(t1 x1 .. tk xk ) { s ; return x }. mds m ./mds mbody (m, C )= x1 .. xk . s ; return x mbody (m, C )= \nmbody (m, D) The typing judgment for statements, denoted G . s, relies on the environment G to record \nthe typesof the localvariables accessedby s. We writeG . x <: t as a shorthand for G(x)= t. and t <: \nt. [TYPE NEW][TYPE CAST] [T VAR] G (x) = t G . x :t [TYPE SEQUENCE] G . s1 G . s2 G . s1 ; s2 G (x) \n= C .elds (C ) = t1 f1 .. tk fk .i . concr (ti ) . G . yi <: ti G . x = new C (y1 .. yk ) [TYPE COPY] \nG . x : t G . y <: t G . x = y G . y :t2 G . x : t1 t <: t1 G . x = (t) y G . y : C [TYPE CALL] . G . \ny : like C [TYPE FIELD][TYPE ASSIGN] mtype (m, C )= t1 .. tk . t G . this : C G . this :C G . y1 : \nt 1 .. G . yk : t k [TYPE CALL DYN] .elds (C )= t1 f1 .. tk fk .elds (C )= t1 f1 .. tk fk .i . concr \n(ti ) . t i <: ti G . y : dyn G . x : t G . x : t i G . x : t G . y1 :t1 .. G . yk :tk concr (t) . ti \n<: tG . x = this . fi G . this . fi = x G . x = y . m (y1 .. yk )G . x = y . m (y1 .. yk ) Typing of \nmethods and classes is inherited from FJ. concr (ti ) . ti <: ti concr (t) . t <: t G . x :dyn 1 .. \nf n n x1 :t1, .., xk :tk , this:C . sx1 : t1, .., xk : tk , this:C . x : t0 .eldnames (D)= f class C \nextends D { fds ; mds } 1 .. fif mtype (m, D)= t1 .. tk . t0 then (t1 = t1 .. tk = tk ) . t0 = t0 C . \nt0 m (t1 x1 .. tk xk ) { s ; return x }. class C extends D { C1 f1 .. Ck fk ; md1 .. mdn } .f . f1 .. \nfk . f ./f C . md1 .. C . mdn Figure 3. The type system variables are then statically checked as if \ntheir type was concrete. However in this case the run-time does not guarantee that the object accessed \nare instances of the class C, and the conformance of the value actually accessed will be checked individually \nat each method invocation. These intuitions suggest that, even if it adds the overhead of redundant conformance \nchecks, it is always safe to consider a variable of type C as a variable of type like C , as allowedbythe \nsubtyping rule C <: like C . Similarly, it is easy to see that the like constructor is covariant. Since \n.elds are private to each object, the operations to read or update them are always made in a context \nwhere the type of this is known with great precision, and the type constraints can be checked statically. \nThe other rules are unsurprising. Dynamic semantics. At run-time objects live in the heap and are referenced \nvia pointers p. Different variables can have different views of the same object; for instance, the variables \nx:C , y:like D and z:dyn might be aliases and refer to the same object stored at location p. The dynamic \nsemanticskeeps trackofavariable s view of an object using wrapped pointers (also called stack-values \nand denoted by sv). So the stack-value of z is (dyn) p while that of y is (like D) p. No wrapper is needed \nfor x,whose stack-value is just the pointer p. The dynamic semantics is then de.ned as a small-step opera\u00adtional \nsemanticsover con.gurations.Acon.guration consistsofa heap H of locations p mapped to objects C (f1 = \nsv1 ; .. ; fn = svn ) and of a stack S of activation records . F1 | s1 . ... . Fn | sn . where each activation \nrecord consists of an environment Fi that maps variables to stack-values, and a statement si to be executed. \nComputation, de.ned in Figure 4, progresses by executing the statement in the stack-frame on the top \nof the stack. We write H(p).fi .. sv to denote the object stored at H(p) where the .eld fi has been updated \nwith the stack-value sv. An invariant relates the type of variables and wrappers of stack\u00advalues:  Auxiliary \nfunctions to extract the run-time type of a pointer and of a stack-value, or to compute wrappers. H(p)=C \n(...) H(p)=C (...) ptype (H , p)= C svtype (H , p)= C svtype (H , (like D) p)= like D svtype (H , (dyn) \np)= dyn [ C ] = [ like C ] =(like C )[ dyn ] =(dyn) w2c () = w2c ((like C ))= (like C ) w2c ((dyn))= \n(dyn) Dynamic semantics. [RED NEW] p fresh for H .elds (C )= t1 f1 .. tn fn F(y1)= w1 p1 .. F(yn )= \nwn pn sv1 =[ t1 ] p1 .. svn =[ tn ] pn H |. F | x = new C (y1 .. yn ); s . S -. H [p ..C (f1 = sv1 ; \n.. ; fn = svn )] |. F [x .. p] | s . S [RED COPY][RED RETURN] H |. F | x = y ; s . S -. H |. F [x ..F(y)] \n| s . SH |. F0 | return x .. F1 | s1 . S -. H |. F1 [ret ..F0(x)] | s1 . S [RED CAST CLASS][RED CAST \nOTHER] F(y)= wp ptype (H , p)= DD <: CF(y)= wp t = like C . t = dyn H |. F | x =(C ) y ; s . S -. H |. \nF [x .. p] | s . SH |. F | x =(t) y ; s . S -. H |. F [x ..(t) p] | s . S [RED FIELD][RED ASSIGN] F(this)= \npF(this)= pF(x)= w . p . H(p)=C (f1 = w1 p1 ; .. ; fn = wn pn ) H(p)=C (f1 = sv1 ; .. ; fn = svn ) F(x)= \nw p .elds (C )= t1 f1 .. tn fn sv =[ ti ] p H |. F | x = this . fi ; s . S -. H |. F [x ..w . pi ] | \ns . SH |. F | this . fi = x ; s . S -. H [p ..(H (p) . fi ..sv)] |. F | s . S [RED CALL] F(y)= p ptype \n(H , p)= C mbody (m, C )= x1 .. xn . s0 ; return x0 mtype (m, C )= t1 .. tn . tF(y1)= w1 p1 .. F(yn )= \nwn pn sv1 =[ t1 ] p1 .. svn =[ tn ] pn F(x)= w p cast = w2c (w ) H |. F | x = y . m (y1 .. yn ); s . \nS -. H |. [] [x1 ..sv1 .. xn ..svn ][this .. p] | s0 ; return x0 .. F | x = cast ret ; s . S [RED CALL \nLIKE] F(y)=(like C ) p ptype (H , p)= D mbody (m, D)= x1 .. xn . s0 ; return x0 mtype (m, C )= t1 .. \ntn . t mtype (m, D)= t1 .. tn . t.i . ti <: ti . ti = dyn (concr (t) . concr (t.)) . t. <: tF(y1)= w1 \np1 .. F(yn )= wn pn sv1 =[ t1 ] p1 .. svn =[ tn ] pn F(x)= w p cast = w2c (w .) H |. F | x = y . m (y1 \n.. yn ); s . S -. H |. [] [x1 ..sv1 .. xn ..svn ][this .. p] | s0 ; return x0 .. F | x = cast (t) ret \n; s . S [RED CALL DYN] F(y)=(dyn) p ptype (H , p)= C mbody (m, C )= x1 .. xn . s0 ; return x0 mtype (m, \nC )= t1 .. tn . tF(y1)= w1 p1 .. F(yn )= wn pn .i . concr (ti ) . svtype (H , wi pi ) <: ti sv1 =[ t1 \n] p1 .. svn =[ tn ] pn H |. F | x = y . m (y1 .. yn ); s . S -. H |. [] [x1 ..sv1 .. xn ..svn ][this \n.. p] | s0 ; return x0 .. F | x =(dyn) ret ; s . S Figure 4. Dynamic semantics 1. if a variable x has \na concrete type C, then its stack-value will always be an unwrapped pointer p and the pointer will always \npoint in the heap to a valid object of type (or subtype of) C; 2. if a variable x has type like C , \nthen its stack-value will always be a (like C ) p wrapped pointer; no guarantee about the type of the \nobject pointed to by p in the heap; 3. ifavariable x has type dyn,then its stack-value will always be \na (dyn) p wrapped pointer; no guarantee about the type of the object pointed to by p in the heap.  To \npreserve this invariant across reductions, operations on objects must perform different checks according \nto their view (that is, the wrapper stored in the stack-value) of the object. Suppose thatastack-value \nwp mustbe storedinalocalvariable x (or in an object .eld). Let t be the static type of x. If t is some \nconcrete type C,then the static semantics and the run-time invariant guarantee thatthe typeofthestack-value \nwp is compatible with C: this implies that the wrapper w is empty and p points to an object of type D \nfor D<: C. In this case, the link x .. p can be safely stored in the stack, and the invariant is preserved. \nIf t is like C (resp. dyn), thenany pointer canbe usedtobuildavalid stack\u00advalue forx,provided thatitis \nwrapped properlyina(like C ) (resp. (dyn))wrapper.The appropriate wrapperisbuiltbythe function [ t] when \nthe type t is known, or, in some cases, copied from the old stack-value of x. For instance, whena new \nobjectis created, (rule([RED NEW]), its .elds are initialized with stack-values that arebuiltby wrapping \n(if needed) the actualarguments according to the .eld types. Field update goes along similar lines. Field \nread illustrates a subtlety: when executing x = this . f the static type of x is not easily accessible.However, \nsincethevariable x is in the scope, its current stack-valuealready re.ectstheviewthatthevariablehasofobjects. \nIn particular, if the static type of x was like C (resp. dyn), then its current stack-value contains \na (like C ) (resp. (dyn))wrapper. The semanticssimplyupdatesthepointer,bundlingitwiththeolder wrapper(a \ncastisbuilt froma wrapperby the function w2c). Since .elds are private to each object, the type of the \nenclosing object is known precisely (thevariable this always hasaconcrete type), and no extra care is \nrequired to check the type constraints.  Invoking a method (say x = y . m (y1 .. yn )), requires more \ncare, as different checks and actions must be performed according to view that the variable y has of \nthe object. The .rst condition of the three rulesfor methodinvocation testsexactly this:ifthe object \nis accessed via a like or dyn wrapper, or not. Ifitis accessed directly (rule[RED CALL]),thatisifF(y)= \np, then the run-time invariant guarantees that the object on which the method is called is an instance \nof the class statically checked. The static semantics guarantees that the method m exists. Let t1 .. \ntn . t be the type of the method; if some ti isaconcrete type, then the static semantics also guarantees \nthat the actual argument yi is an instance of ti, and no run-rime type checks are needed. If ti is like \nor dyn, then the actual arguments are wrapped with [ ti ] , and, again, no run-time checks are performed. \nThe run-time allocates a new stack-frame to evaluate the body of the method in an environment where the \nactual arguments are bound to the method parameters and this points to the object itself. The return \nvalue is passed to the previous stack-frame via theret distinguished variable.Ifthe returnvaluemustbe \nstoredinavariablethathaslike ordyntype,thena cast (computedfromtheprevious stack-valueof the returnvariable) \naround ret ensures that the newstack-value will be properly wrapped. Observe that this rule boils down \nto standard FJ method invocation if the type of the method m does not involve like or dyn types. If the \nobject is accessed via a (dyn) wrapper, that is if F(y)= (dyn) p, (rule [RED CALL DYN]), then the run-time \nmust verify thatthe methodexists (contrarilytotheprevious case,the condition mbody(m, D)= ... might fail), \nand that the actual arguments are compatible with the types expected by the method, via the condition \nsvtype (H , wi pi ) <: ti (this check is performed only if ti isaconcrete type, otherwise the arguments \nare simply wrapped according to ti). Also,the returned pointerisbundledina (dyn) wrapper via a cast, \nsince there are no static guarantees about the use that the context makes of the returned pointer. If \nthe object is accessed through a (like C ) wrapper, that is if F(y)=(like C ) p, (rule([RED CALL LIKE]), \nthen the arguments of the method call have been statically type-checked against the type of the method \nm in class C (). The run-time must then check that a method of name m exists in the object actually accessed \n(which can be an instance of some class D not related to C), and that its type is compatible with the \ntype of m in C (via the condition .i.ti <: ti. ). This strict type matching is not required when ti . \nis of type dyn, as the argument will be wrapped with (dyn) anyway. The return value must be wrapped (via \ncasts) not only to the type ofthe returnvariable,butalsotothe returntype t of the method m in class C. \nMini-Thorn s dynamic semantics does not rely on chains of wrappers and every reference to an object goes \nthrough at most one wrapper. Upcast of class types is always allowed: when the cast is evaluated no new \nwrappers are added, and the previous one (if any) is discarded (rule [RED CAST CLASS]). Acast to a con\u00adcrete \ntype that is not a super-type of the type of the object fails. Casting to a like type as like C (resp. \nto dyn)always succeeds (rule[RED CAST OTHER]);the run-timeforgetstheprevious wrap\u00adper (if any) and insert \na (like C ) (resp. a dyn)wrapper. The rule for copy of a variable is straightforward, while the return \nx instruction simply deallocates the current stack-frame and stores the stack-value of x in the distinguished \nret variable of the previous stack-frame. 4.1 Meta-theory A con.guration is well-typed if it satis.es \nthe run-time invariant informally described above. The invariant relates the static type of each variable \nto the stack-value and heap object it can refer to, and we show that well-typed con.gurations are closed \nunder reductions. The environment S associates class names C to pointers p, and it records the concrete \ntypes of the objects in the heap. We then de.ne a type relation for stack-values: S(p)= D S(p)= E D <: \ntD <: C S(p)= C S . p : t S . (like D) p : like C S . (dyn) p :dyn Thekeypropertyofthis relationisthat \neitherit re.ectsthe wrapper of the stack-value (imposing no conditions on the actual object accessed), \nor, if no wrappers are present, the concrete type of the object actually accessed.Aheap H is then well-typed \nin S if: S . Hp ./dom(H ) S(p)= C .elds (C )= t1 f1 .. tn fn S . w1 p1 :t1 .. S . wn pn :tn S . H [p \n..C (f1 = w1 p1 ; .. ; fn = wn pn )] and the de.nitions of well-typed stack and well-typed con.guration \n(denoted S; G . H | S)follow accordingly: G(x)= t S . wp : t S; G . F x ./dom(F )G . s S; G . F S; G \n. H | S S; G . F [x ..wp] S;G . H |. F | s . S (we omit the trivial rules for empty heap and stack). \nTHEOREM 1 (Preservation). If S; G . H | S and H | S -. H . | S., then there exist S. and G. such that \nS, S. ;G, G. . H . | S. . Givena well-typed program,itis easyto see that the initial con.g\u00adurationofthe \nprogramis well-typed.This guaranteesthatvariables with a concrete type C will only point to unwrapped \nobjects which are instances of class C:itis safeto optimize accessesto suchvari\u00adables at compile time. \nWe can also show that no type-related run-time errors can arise from operations onvariables whichhavea \nconcrete type.We say that a con.guration H |. F | s . S is stuckif s is non-empty and no reduction rule \napplies; stuck con.gurations capture the state just before a run-time error. THEOREM 2 (Progress). If \na well-typed con.guration S; G . H |. F | s . S is stuck, that is H |. F | s . S .-., then the state\u00adment \ns is of the form x = y . m (y1 .. yn ); s . and G(y) is dyn or like C for some C, or s is of the form \nx =(C ) y ; s . and F(y)= wp with ptype(H, p) <.: C .  4.2 Compilation Run-time wrappers re.ect the \nstatic view that a variable has of an object. The run-time invariant guarantees that all the stack-values \nassociated to a given variable will have the same wrapper, and that this wrapper depends only on the \nstatic type of the variable. The  [RED CALL TARGET] F(y) = p ptype (H , p) = C mbody (m, C ) = x1 .. \nxn . s0 ; return x0 F(y1) = p1 .. F(yn ) = pn H |. F | x = y @ m (y1 .. yn ); s . S -. H |. [] [x1 .. \np1 .. xn .. pn ][this .. p] | s0 ; return x0 .. F | x = ret ; s . S [RED CALL LIKE TARGET] F(y)= p ptype \n(H , p)= D mbody (m, D)= x1 .. xn . s0 ; return x0 mtype (m, C )= t1 .. tn . t mtype (m, D)= t1 .. t. \nt.i . ti <: t. t= dyn n ii (concr (t) . concr (t.)) . t. <: tF(y1)= p1 .. F(yn )= pn H |. F | x = y @(likeC \n) m (y1 .. yn ); s . S -. H |. [] [x1 .. p1 .. xn .. pn ][this .. p] | s0 ; return x0 .. F | x = ret \n; s . S [RED CALL DYN TARGET] F(y)= p ptype (H , p)= C mbody (m, C )= x1 .. xn . s0 ; return x0 mtype \n(m, C )= t1 .. tn . tF(y1)= p1 .. F(yn )= pn .i . concr (ti ) . ptype (H , pi )= D . D <: ti H |. F | \nx = y @(dyn) m (y1 .. yn ); s . S -. H |. [] [x1 .. p1 .. xn .. pn ][this .. p] | s0 ; return x0 .. F \n| x = ret ; s . S Figure 5. Dynamic semantics of method dispatch in the compiled language d = [ G(y)] \n [ G, x = y . m (y1 .. yn )] = x = y @ dm (y1 .. yn ) [ G, F [x1 ..w1 p1 .. xn ..wn pn ]] = [ G, F ] \n[x1 .. p1 .. xn .. pn ] [ G, H | S ] = [ G, H ] | [ G, S ] [ G, H [p ..C (f1 = w1 p1 ; .. ; fn = wn pn \n)]] = [ G, H ] [p ..C (f1 = p1 ; .. ; fn = pn )] [ G, . F1 | s1 . .. . Fn | sn . ] = . [ G, F1 ] | [ \nG, s1 ] . .. . [ G, Fn ] | [ G, sn ] . Figure 6. Compilation of method invocation and of con.gurations \ndynamic semantics relied on wrappers to determine the correct re\u00adduction rule for method invocation: \nsince the wrapper information can be derived from the static types, it is possible to determine for each \nmethod invocation the right behavior statically. We can then de.ne the three different dispatchers for \nmethod invocation, identi.edbyadispatchlabel,denotedd,which is either empty, or (like C ), or (dyn). \nWith an abuse of notation, we use the same syntax for wrappers and dispatch labels, and rely on the function \n[ t] described above to compute the appropriate dispatch label for a given type. These dispatchers implement \nthe three reduction rules for method invocation.Amethod invocation can then be compiled down to the invocation \nof the right dispatcher for the given static type, and wrappers can be erased from stack\u00advalues altogether. \nConsider the target language de.nedby the grammar below: s ::= statements | skip skip | s1 ; s2 sequence \n| this . f = x .eld update | x = this . f .eld read | x = y @ dm (y1 .. yn ) method dispatch | x = new \nC (y1 .. yn ) object creation | x = y copy | x =(t) y cast In the semantics of the target language, \nstack-values are always unwrapped pointers: the stack simply associates variables to point\u00aders. The reduction \nrules for method dispatch are reported in Fig\u00adure 5; the reduction rules for the other constructs are \ninherited from the source language simplyby erasing all the wrappers. The compile function, denoted [ \n-] , transforms well-typed source statements into target statements, and more generally well\u00adtyped sourcecon.gurations \ninto target con.gurations. The compile function, described in Figure 6, is the identity on statements \nex\u00adceptfor methodinvocation. Methodinvocationis compiledintothe invocation of the appropriate dispatch \nfunction, according to the static type of the variable pointing to the object. Compilation of con.gurations \ncompiles all the statements in all the stack-frames, and discards all the wrappers. We can show a simulation \nresult between the behavior of well\u00adtyped source con.gurations and the behavior of compiled con.gu\u00adrations. \nTHEOREM 3 (Compilation). Let S; G . H | S be a well-typed source con.guration : 1. if H | S -. H . | \nS., then [ G, H | S ] -. [ G, H . | S. ] ; 2. conversely, if [ G, H | S ] -. H .. | S.., then there \nexists a well-typed source con.guration S. ;G. . H . | S. such that H | S -. H . | S. and [ G. , H . \n| S. ] = H .. | S.. .  The Thorn implementation isbuilt upon this wrapper-less compi\u00adlation strategy. \nGenerics. Like types extends nicely to a language that features bounded parametric polymorphism. Following \nFGJ, let X range over type variables and let concrete types CN ::= C.T 1..T n., non-variable types N \n::= CN | like CN | dyn and types T ::= N | X. Thekeydesigndecisionisto restrict boundsin class de.ni\u00adtions \nto concrete types: class C . X1 . CN1 .. Xk . CNk . . N { fds ; mds } where . abbreviates extends. If \nthe programmer speci.es a bound different from Object, like in List.X. Foo., then the parameter can only \nbe instantiated by concrete types and the usual FGJ type guarantees are recovered. If the type Object \nis instead speci.ed asa bound, as in List.X.Object.,then the parameter can be instantiated with any type, \nincluding dyn or like C : This guarantees ease of reuse of the List class.  5. Experience with Program \nEvolution We report on ourexperience using the proposed type system.We implemented support for like types \nin our Thorn compiler which runsontopofastandardJVM. Methodcallsgothrougha dispatch\u00ading function that \nis used toimplement dispatch in the presence of multiple inheritance which the JVM does not support. \nWhat dis\u00adpatch function to route a call through is determined by the type information available at the \ncall-site. The concretely typed func\u00adtion simply handles lookup as it assumes that the run-time types \nof arguments are correct. The untyped function additionally performs run-time type checks for arguments \nto anyconcretely typed param-eters.Acall toa method m on a like typed receiver x goes trough a dispatching \nfunction that checks that x has an m with the cor\u00adrect types before proceeding.Asaconsequenceof this \ndesign, calls withvaryingdegreeof typing are handled differently.Type checks are performednotatthe call-sitebutaspartofthe \ndispatchingfunc\u00adtion in the receiver object. Consequently, adding type information to some class does \nnot require recompilation of client code to take advantage of the type checking. Run-time type checks \nwill be car\u00adried out as part of the untyped dispatching function, and just like in e.g., Java, changing \nconcrete types in the interface can break client code that was compiled assuming other types in the interface. \n5.1 Types In Libraries Thorn s libraries constitute a .rst interesting test case. To doc\u00adument design \nintents, the initial library implementation included comments that described the expected type of the \nfunctions. From these comments, we refactored libraries to use a mixture of like types and concrete types. \nThe choice of appropriate type annota\u00adtions for the interfaces of a class calls for a compromise between \n.exibility vs. safety and performance. Most of Thorn s libraries have liketyped interfaces for maximal \n.exibility. Most return types are either like typed or dynamically typed. This is unsurprising since \nlike types primarily provide local guarantees. Return values that were locally created generally have \na known (concrete) type. When addingtypesto untypedcode,we foundthatitiskeythat the effects of adding \nthe types do not propagate toofar. As an example, consider the following two classes, declared in separate \n.les: class A{ def p(x) = println(x); } class B { a = A(); def q(s) { a.p(s) } } At a later date, the \nclass A is replaced with a typed one, obtaining: class A{ def p(x: String) = println(x); } Despite the \ntype annotation, the signatures of the untyped and like typed dispatching functions in A are unchanged. \nThe .rst addition\u00adally performs a type test on the x argument to make sure it is a String. Thus, old \nbytecode generated from the untyped code in B will still work with A without recompilation. Notably, \nconcretely typed and like typed code will call a dispatching function that does not need to test run-time \ntypes of arguments. Thorn supports a notion of pure classes that create immutable objects. A pure class \nis a functional immutable data type and many of the standard library data types are pure, Int, Float, \nString etc. The increase the .exibility, we could, although we have not implemented this, allow value \nclasses to be automatically augmented with a parallel, like typed version, e.g.,: class Int: Value { \ndef +(x: Int): Int = ... } can be compiled into class Int: Value { def +(x: Int): Int = ... def +(x: \nlike Int): like Int = ... } where the second method overloads the .rst to allow + etc. to be called on \nany argument. Thisfacilitates interaction between typed and untyped code, and is safe since pure classes \ndo not modify state. Notably, x+\"foo\" when x: Int is still rejected statically. Followingthispractisewouldallowsusto \nannotatemostbasicdata types in the standard library with concrete types for speed while enjoying the \n.exibility of like types.  5.2 Refactoring an Untyped Program Weporteda dynamic programtoThorn along \nwith its libraries and gradually added type annotations to it. The application we chose was Pwyky [25] \na simple wiki of about 1,000 lines of Python. Pwykyrelies on a generic parser module that was also ported \n(an\u00adother 1,000 lines). This allowed us to investigate the interaction between library and user code \nannotations. The application is rep\u00adresentative of scripting language code and relies on patterns that \nare inherentlyhardtotype,suchasusingthe samevariableforval\u00aduesof differenttypes depending on some run-time \ntest. The ported program, Thyky, is about the same size as the initial Python pro\u00adgram, including libraries \n(2,000 LOC). Once we had an untyped version of Thykyrunning, we set out to gradually add type annota\u00adtions \nto it.To illustrate this process, consider the function upos in the ParserBase class. The function upos \nis called when moving from a position i in the parsed string to some position j to update the .elds lineno \nand offset of the ParserBase: class ParserBase(var lineno, var offset, var rawdata) { def upos(i, j) \n{ if (i >= j) return j; nlines = count(rawdata.slice(i, j), \"\\n\"); if (nlines != 0) { lineno := lineno \n+ nlines; offset := j; } else offset := offset + j-i; return j; } } As a .rst step, we added like type \nannotations in a naive and straightforward way. The result was the following: class ParserBase(var lineno: \nlike Int, var offset: like Int, var rawdata: like String) { def upos(i: like Int, j: like Int): like \nInt { if (i >= j) return j; nlines: Int = count(rawdata.slice(i, j), \"\\n\"); ... # identical } Even if \nthe types are simple data types, there is a rationale behind the choice of like types. ParserBase was \nthe .rst class we annotated. This class is extended by the class HTMLParser and in turn by the class \nWikify which at that time were still untyped: concrete types would have caused a number of implicit type \ntests to be inserted and a large number of warnings, since methods in ParserBase were called with untyped \narguments. With the like type annotations, the type checker is now able to verify that code in ParserBase \nrespects the declared types for lineno, offset and rawdata. The variable nlines is concretely typed: \nthe count function returns an Int and, since nlines is internal to upos,there isnoextraneedfor.exibility \nhere.We addedliketype annotations to HTMLParser and all the code in Thyky in the samefashion. At this \npoint we had an untyped and a like-type annotated version of Figure 7. Performance comparison between \nTyped Thorn, dy\u00adnamic Thorn, Python 2.5.1, Ruby 1.8.6 normalized on the Python timings.Typed Thorn notably \nruns the benchmarks between 2x and 4x the speed of Python.  each .le; it was possible to compile and \nlink the annotated version ofone.leagainstthe untypedversionofthe other,andalltheeight possible combinations \nworked as expected. Following the annotations above, we attempted to harden the type annotations of classes \nsuch as ParserBase by turning the like-type annotations into concrete types. This often amounted to removing \nthe like keywords from .eld declarations, while wekept the like type annotations for the arguments of \nfunction upos to allowcalls to upos from untyped contexts without forcing run-time type tests and to \nretain the .exibility of dynamic typing. This meant that we had to rewrite the assignment to the, now \nconcretely typed, offset .eld to make a type test on j, written as follows in Thorn: offset := (Int) \nj orelse Int(j); # cast or covert to int This line of code tries to cast j to an Int and if failing, \ntries to create a new integer value from j. (The orelse keyword executes its RHS if the LHS throws an \nexception.) Ourexercise revealedabugin the original Python program that had survived the port to Thorn. \nIn the code below, the variable s always containsastringat run-time,butwasusedinthefollowing test in \nPython: if (s < 10): area = s[0:pos+10] else: area = s[pos-10:pos+10] The test (comparison on strings \nand integers) is nonsensical, but neverthelessvalid Python code,andalways returnsfalse.As soon as we \nadded a type annotation to s, our type-checker caught the problem.  5.3 Optimizing Thorn To demonstrate \nthe value of concrete types, we present timing data from running three simple benchmarks ported from \n[13]. The origi\u00adnalcodewasported straightfromPythonandthusdidnothaveany type annotations (reported as \ndynamic Thorn). We subsequently added type annotations to parameters to the critical functions. Run\u00adning \nthe programs side by side, we observed signi.cant speed ups in the typedversion.Togive some perspective \nto these numbers, we present our timed runs in relation to theC implementation of Python (2.5.1) and \nalso include the C implementation of Ruby (1.8.6), two relatively similar class-based object-oriented \nscripting languages. The data is presented in Figure 7. It should be noted that all the library code \nused by our Thorn programsis untyped.Typed version of the libraries are currently being written and should \nfur\u00adther improve performance. As shown in Figure 7, Typed Thorn runs the benchmarks between 2x and 4x \nfaster than Python and about3xand6xfasterthan dynamic Thorn. The Ruby implemen\u00adtationistheslowestbyfarandis \noutperformedbyafactor7xto 12x byTyped Thorn. Dissecting Spectral-Norm. As demonstrated in Figure 7, adding \ntype annotations to programs in Thorn can cause signi.cant speed\u00adups. Let us look at the spectral-norm \nbenchmark [13] in additional detail. We naively translated the existing Python implementation into Thorn. \nInspecting the code, we found the following frequently executed function: def a(i, j) = 1.0 / (((i + \nj) * (i + j + 1) >> 1) + i + 1); With boxed Thorn primitives this line of code creates 8 new in\u00adstances \nof Int or Float causingthe methodtoexecuteslowly.The compiled Thorn code for this function is 87 byte \ncode instructions of which 8 are invokeinterface. Adding concrete type anno\u00adtations to the method s arguments \nbrought the number of objects created down to 1, the (untyped) return value: def a(i: Int, j: Int) = \n... Moreover, the produced bytecode for the calculation is equivalent to that of Java 18 instructions. \nThis speed-up should not come as a surprise. After all, we have added concrete type annotations to allowthe \ncompiler to generate the optimized code for 32-bit integer values.Butwenotethatwitha traditionalgradualtyping \nsystem,it would not be possible to achieve this due to the need to account for wrappers (or structural \nsubtyping). Now, let s examine what would happen if we typed the arguments with like types: def a(i: \nlike Int, j: like Int) =  1.0 / (((i+j) * (i+j + 1) >> 1) + i+1); As the methods + and >> in class Int \nare annotated to accept like Int and return Int (a reasonable choice with respect to interaction with \nmixed-typed code), the highlighted additions above would be method calls, and the rest optimized into \noperations on primitive values. Notably, no unboxing of primitive values and no new cre\u00adation of boxed \ninteger objects are needed. Clearly, the like typed approach produces more ef.cient bytecode than the \nuntyped. 6. Conclusions We presented a type system designed to allow the gradual integra\u00adtionofvaluesofdynamicandstatictypesinthesame \nprogramming language. Our design departs from the majority of previous work which takesanexisting dynamic \nlanguage asastarting point and in\u00adsists that the type system be somehow backwards compatible with legacyuntyped \ncode. In our view, the drawback of those works is that the static type system is necessarily weak andfails \nto rule out run-time errors or permit compiler optimizations. Our proposal puts the dynamic and static \nparts of a program on equal footing. While dynamically typed code is unconstrained, we guarantee that \nstati\u00adcally typed code does notexperience run-time type errors.By sepa\u00adrating (semi)-structural like \ntypes from concrete types, we are able to treat the latter morestrictly and asaconsequence apply compiler \noptimizations to the generated code. Like types interact very well with untyped code, in particular, \nadding like type annotation will never causeworkingcodetofailduetotype errors. Choosing nominal subtyping \nfor the statically typed part of our design is in line with all modern object-oriented languages. But \nour decision of reusing type names without requiring structural subtypingforliketypesis more controversial.Wearguethatitisin \nline with the design philosophyof scripting languages: namely to minimize programmer effort. Liketypes \ndo not require the scripting language programmer to declare new types while a program is being migrated \nfrom untyped to typed, instead theylet them reuse existing types even if these types are only an approximation \nof the right ones.Assuch,aprogramwithliketype annotationsalready requires more .nger typing (the pejorative \nterm for inserting type information usedbythe scripting community) than completely untyped code. But \nthe additional effort is small and optional as it is always possible to interact with a like typed library \nwithout writingasingle type annotation and the library willstill enjoysome safety and speed-up. Like \ntypes are good for documentation and traceability. Although theyimpose weaker constraints on behavior \nthan in a language such as Java, like typed code will be forced to evolve as the referenced types evolve. \nA consequence of the de.nition of like types is that exactly what subset of the operations of a type \nis used within a method is not visible on the outside. From a dynamic typing perspective, this is positive \nas it decreases coupling and makes code more modular. This is similar to the Smalltalk pattern of encoding \ntype information in variable names  [5] and essentiallythe same reasoning thatis usedby programmers \nin object-oriented scripting languages such as Ruby and Python, except that like types give machine-checked \nhints to go on. The proposed type system is being co-designed with a new pro\u00adgramming language called \nThorn. The advantage of co-designing the type system with the language is that we can focus onkeyis\u00adsues \nwithout having to .ght corners cases of the language de.ni\u00adtion as would have been the case if we had \npicked Java or C# as a starting point. Some simpli.cations that we haveallowed ourselves included ruling \nout method overloading on parameter types (typi\u00adcally supported in statically typed languages) as well \nas addition of .elds and methods (typically supported in dynamically typed lan\u00adguages). Nevertheless \nwe believe that one could add like types and dyn to other static languages and obtain much of the same \nbene.ts we have outlined in this paper. Acknowledgments. We thank the entireThorn team: Brian Burg, Gregor \nRichards, Bard Bloom, Nate Nystrom, and John Field. This workwas partially supportedbyONR grant N140910754 \nand ANR grant ANR-06-SETI-010-02. References [1] Amal Ahmed, Robert Bruce Findler, Jacob Matthews, and \nPhilip Wadler. Blame for all. InScript to Program Evolution (STOP), 2009. [2] Davide Ancona, Giovanni \nLagorio, and Elena Zucca. Type inference for polymorphic methods in Java-likelanguages. In Italian Conference \non Theoretical Computer Science (ICTCS), 2007. [3] Christopher Anderson and Sophia Drossopoulou. BabyJ: \nFrom object based to class based programming via types. Electronic Notes in Theoretical Computer Science, \n82(7), 2003. [4] John Aycock. Aggressive type inference. In International Python Conference, 2000. [5] \nKent Beck. Smalltalk: Best Practice Patterns. Prentice-Hall, 1997. \u00a8Richards, Rok Strnisa, JanVitek, \nandTobias Wrigstad. Thorn robust,. concurrent,extensible scripting on the JVM. In Conference on Object-Oriented \nProgramming, Systems, Languages and Applications (OOP-SLA), 2009. [6] Bard Bloom, John Field, Nathaniel \nNystrom, Johan Ostlund, Gregor [7] Gilad Bracha. Pluggable type systems. OOPSLA04, Workshop on Revival \nof Dynamic Languages, 2004. [8] Gilad Bracha and David Griswold. Strongtalk: Typechecking Smalltalk in \na production environment. In Conference on Object-Oriented Programming, Systems, Languages and Applications \n(OOP-SLA), 1993. [9] Patrick Camphuijsen, Jurriaan Hage, and Stefan Holdermans. Soft typing PHP. Technical \nreport, Utrecht University, 2009. [10] Luca Cardelli. Structural Subtyping and the Notion of Power Type. \nIn Symposium on Principles of Programming Languages (POPL), 1988. [11] Robert Cartwright. User-de.neddatatypesasanaidtoverifyingLISP \nprograms. In International Colloquium onAutomata, Languages and Programming (ICALP), pages 228 256, 1976. \n[12] Robert Cartwright and MikeFagan. Soft Typing. In Conference on Programming language design and implementation \n(PLDI), 1991. [13] The Computer Language Benchmarks Game. http://shootout. alioth.debian.org/. [14] Robert \nBruce Findler and Matthias Felleisen. Contracts for higher\u00adorder functions. In International Conference \non Functional Program\u00adming (ICFP), 2002. [15] Cormac Flanagan. Hybrid type checking. In Symposium on \nPrinciples of Programming Languages (POPL), 2006. [16] Cormac Flanagan. ValleyScript: It s like static \ntyping. Technical report, UC Santa Cruz, 2007. [17] Michael Furr, Jong hoon An, JeffreyFoster, and Michael \nHicks. Static type inference for ruby. In Symposium in Applied Computing (SAC), 2009. [18] Kathryn E. \nGray, Robert Bruce Findler, and Matthew Flatt. Fine\u00adgrained interoperability through mirrors and contracts. \nIn Conference on Object-Oriented Programming, Systems, Languages and Applica\u00adtions (OOPSLA), pages 231 \n245, 2005. [19] David Herman, AaronTomb, and Cormac Flanagan. Space-ef.cient gradual typing. In Trends \nin Functional Programming (TFP), 2007. [20] Alex Holkner and James Harland. Evaluating the dynamic behaviour \nof Python applications. In Australasian Computer Science Conference (ACSC), 2009. [21] Atsushi Igarashi, \nBenjamin C. Pierce, and Philip Wadler. Feather\u00adweight Java: a minimal core calculus for Java and GJ. \nACMTransac\u00adtions on Programming Languages and Systems, 23(3), 2001. [22] Adobe Systems Inc. ActionScript \n3.0 Language and Components Reference, 2008. [23] Giovanni Lagorio and Elena Zucca. Just: Safe unknown \ntypes in Java\u00adlike languages. Journalof ObjectTechnology, 6(2), 2007. [24] Sven-Olof Nystr\u00a8om. A soft-typing \nsystem for Erlang. In Erlang Workshop, 2003. [25] SeanB.Palmer. Pwyky(A Python Wiki). [26] Jeremy Siek \nandWalidTaha. Gradual typing for objects. In European Conference on Object Oriented Programming (ECOOP), \n2007. [27] Jeremy Siek and PhilipWadler. Threesomes, with and without blame. In Script to Program Evolution \n(STOP), 2009. [28] Jeremy G. Siek. Gradual Typing for Functional Languages. In Scheme and FunctionalProgrammingWorkshop, \n2006. [29] JeremyG.Siek, Ronald Garcia,andWalidTaha. Exploringthedesign space of higher-order casts. \nIn European Symposium on Programming (ESOP), 2009. [30] Jeremy G. Siek and Manish Vachharajani. Gradual \ntyping with uni.cation-based inference. In Symposium on Dynamic languages (DLS), 2008. [31] Ed Stephenson. \nPerl Runs Sweden sPension System. O Reilly Media, 2001. [32] SamTobin-Hochstadt and Matthias Felleisen. \nInterlanguage migra\u00adtion: From scripts to programs. In Symposium on Dynamic languages (DLS), 2006. [33] \nSamTobin-Hochstadt and Matthias Felleisen. The design and imple\u00admentationofTyped Scheme.In Symposium \non Principles of Program\u00adming Languages (POPL), 2008. [34] PhilipWadler and Robert Bruce Findler. Well-typed \nprograms can t be blamed. In European Symposium on Programming (ESOP), 2009. [35] UlfWiger.Four-fold \nincreasein productivityandquality.In Workshop onFormal Designof Safety Critical Embedded Systems, 2001. \n[36] AndrewK.WrightandRobert Cartwright.Apracticalsofttypesystem for Scheme. In Conference on LISP and \nFunctional programming, pages 250 262, 1994.   \n\t\t\t", "proc_id": "1706299", "abstract": "<p>Many large software systems originate from untyped scripting language code. While good for initial development, the lack of static type annotations can impact code-quality and performance in the long run. We present an approach for integrating untyped code and typed code in the same system to allow an initial prototype to smoothly evolve into an efficient and robust program. We introduce <i>like types </i>, a novel intermediate point between dynamic and static typing. Occurrences of like types variables are checked statically within their scope but, as they may be bound to dynamic values, their usage is checked dynamically. Thus like types provide some of the benefits of static typing without decreasing the expressiveness of the language. We provide a formal account of like types in a core object calculus and evaluate their applicability in the context of a new scripting language.</p>", "authors": [{"name": "Tobias Wrigstad", "author_profile_id": "81323497904", "affiliation": "Stockholm University, Kista, Sweden", "person_id": "P1911122", "email_address": "", "orcid_id": ""}, {"name": "Francesco Zappa Nardelli", "author_profile_id": "81100512653", "affiliation": "INRIA, Le Chesnay, France", "person_id": "P1911123", "email_address": "", "orcid_id": ""}, {"name": "Sylvain Lebresne", "author_profile_id": "81438593830", "affiliation": "Purdue University, West Lafayette, USA", "person_id": "P1911124", "email_address": "", "orcid_id": ""}, {"name": "Johan &#214;stlund", "author_profile_id": "81388600832", "affiliation": "Purdue University, West Lafayette, USA", "person_id": "P1911125", "email_address": "", "orcid_id": ""}, {"name": "Jan Vitek", "author_profile_id": "81100018102", "affiliation": "Purdue University, West Lafayette, USA", "person_id": "P1911126", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706343", "year": "2010", "article_id": "1706343", "conference": "POPL", "title": "Integrating typed and untyped code in a scripting language", "url": "http://dl.acm.org/citation.cfm?id=1706343"}