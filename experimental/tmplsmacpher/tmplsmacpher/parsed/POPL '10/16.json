{"article_publication_date": "01-17-2010", "fulltext": "\n A Relational Modal Logic for Higher-Order Stateful ADTs Derek Dreyer Georg Neis MPI-SWS MPI-SWS dreyer@mpi-sws.org \nneis@mpi-sws.org Abstract The method of logical relations is a classic technique for proving the equivalence \nof higher-order programs that implement the same observable behavior but employ different internal data \nrepresenta\u00adtions. Although it was originally studied for pure, strongly normal\u00adizing languages like System \nF, it has been extended over the past two decades to reason about increasingly realistic languages. In \nparticular, Appel and McAllester s idea of step-indexing has been used recently to develop syntactic \nKripke logical relations for ML\u00adlike languages that mix functional and imperative forms of data ab\u00adstraction. \nHowever, while step-indexed models are powerful tools, reasoning with them directly is quite painful, \nas one is forced to en\u00adgage in tedious step-index arithmetic to derive even simple results. In this paper, \nwe propose a logic LADR for equational reasoning about higher-order programs in the presence of existential \ntype ab\u00adstraction, general recursive types, and higher-order mutable state. LADR exhibits a novel synthesis \nof features from Plotkin-Abadi logic, G\u00a8odel-L\u00a8ob logic, S4 modal logic, and relational separation logic. \nOur model of LADR is based on Ahmed, Dreyer, and Ross\u00adberg s state-of-the-art step-indexed Kripke logical \nrelation, which was designed to facilitate proofs of representation independence for state-dependent \nADTs. LADR enables one to express such proofs at a much higher level, without counting steps or reasoning \nabout the subtle, step-strati.ed construction of possible worlds. Categories and Subject Descriptors \nD.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory; D.3.3 [Programming Languages]: Language \nConstructs and Features Abstract data types; F.3.1 [Logics and Meanings of Programs]: Specifying and \nVerifying and Reasoning about Programs General Terms Languages, Theory, Veri.cation Keywords Abstract \ndata types, step-indexed logical relations, modal logic, separation logic, Plotkin-Abadi logic, local \nstate 1. Introduction The method of logical relations is a classic technique for proving the equivalence \nof higher-order programs that implement the same observable behavior but employ different internal data \nrepresenta\u00adtions. The basic idea is to lift the notion of observable equivalence at base type to one \nat higher type by de.ning a notion of logi\u00adcal equivalence inductively on the type structure of the language. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n10, January 17 23, 2010, Madrid, Spain. Copyright c &#38;#169; 2010 ACM 978-1-60558-479-9/10/01. . . \n$10.00 Andreas Rossberg Lars Birkedal MPI-SWS ITU-Copenhagen rossberg@mpi-sws.org birkedal@itu.dk The \nCurry-Howard isomorphism dictates which logical connective to use in assigning a relational operation \nto each type constructor. Since Reynolds seminal paper on relational parametricity [37], which presented \nlogical relations for reasoning about the pure, strongly normalizing System F, there has been a lot of \nwork on gen\u00aderalizing and extending the method to handle increasingly realistic languages [30, 31, 23, \n8, 1, 10]. In particular, Ahmed, Dreyer, and Rossberg (hereafter, ADR) have recently developed a powerful \nlog\u00adical relation for an ML-like language with universal and existential types, general recursive types, \nand higher-order mutable state [2]. The ADR logical relation is notable in two ways. First, it is a Kripke \nlogical relation, which means that the relation is parame\u00adterized by possible worlds. These in turn allow \nfor the encoding of invariants on local state, that is, mutable state that is accessible to the terms \nbeing logically related but not publicly accessible to the rest of the program . For instance, two functions \nmight be dis\u00adtinguishable in an arbitrary program context, but equivalent under the assumption that (i.e., \nin a possible world that demands that) a particular local reference cell always stores, say, an even \nnumber. Compared to previous Kripke logical relations for reasoning about state, the most interesting \nand novel aspect of ADR s possible worlds is that they allow one to establish not only invariants, but \nalso properties about local state that evolve over time. ADR achieve this by instrumenting possible worlds \nwith populations, which may be used to effectively encode an abstract trace of the program. As we will \nreview in Section 3, populations are very useful when proving representation independence for generative \nor state\u00addependent ADTs, i.e., ADTs whose inhabitants grow over time in correspondence with changes to \nsome local state. A second key aspect of the ADR logical relation is its use of Appel and McAllester \ns step-indexing technique [3]. Step-indexing is useful as a way of modeling language features like recursive \ntypes and higher-order state, whose relational interpretations are not inductive on the structure of \ntypes. The idea is to index the logical relation by a second induction metric, namely a natural number \nrepresenting (roughly) the number of steps of computation for which the terms in question are indistinguishable. \n(Thus, if two terms are related for an arbitrary step-index , we know they are really indistinguishable.) \nIn addition to stratifying the logical relation, step-indexing is also helpful in stratifying possible \nworlds, which in the presence of higher-order state may be self-referential. For the purpose of constructing \nlogical relations for recursive types and higher-order state, step-indexing is not the only technique \navailable. A variety of denotational techniques minimal invari\u00adance [32], FM-cpos [8], ultrametric spaces \n[10] have been and are being developed for this purpose as well. But the promise of step\u00adindexing is \nthat it is readily applicable in a variety of settings e.g., both in ML-like languages and low-level \ncode [4] and, moreover, that it is conceptually and mathematically elementary. Unfortunately, step-indexed \nmodels are so elementary that they can be quite painful to use directly. Unlike the abovementioned de\u00adnotational \nmodels, which involve some heavy mathematical con\u00adstructions but in the end produce fairly clean equational \nreason\u00ading principles, step-indexed logical relations force their users to engage in tedious step-index \narithmetic to derive even simple re\u00adsults. The crux of the problem is that you get what you pay for: \nstep-indexed models are fairly straightforward to construct because one doesn t have to prove anything \nabout limits of chains of .nite approximations of a relation the model consists only of the .nite approximations \nbut, as a result, the user of the model has to rea\u00adson directly about the .nite approximations as well. \n For instance, one might hope to prove that two functions f1 and f2 are logically equivalent by showing \nthat they map logically equivalent arguments to logically equivalent results. However, in a step-indexed \nlogical relation, this proof principle does not hold. Why? First, it is dif.cult to prove anything about \nlogical equiv\u00adalence directly because step-indexed logical relations are (for var\u00adious technical reasons \n[1]) typically asymmetric, i.e., they de.ne approximation relations between terms. One can of course \nde.ne logical equivalence to mean mutual approximation, but unfortu\u00adnately that notion of equivalence \ndoes not enjoy the extensionality proof principle described above. In particular, showing that f1 and \nf2 map mutually-approximate arguments to mutually-approximate results does not imply that f1 and f2 are \nthemselves mutually\u00adapproximate. Indeed, to show the latter, one must demonstrate that if v1 approximates \nv2, then f1v1 approximates f2v2, and if v2 ap\u00adproximates v1, then f2v2 approximates f1v1. Thus, one must \nef\u00adfectively divide the proof of f1 and f2 s equivalence into two, often very similar, proofs one for \neach direction of approximation. Second, when showing that f1 and f2 are logically related (for either \ndirection of approximation), it does not suf.ce to show that f1 and f2 map arguments that are logically \nrelated for all steps to results that are logically related for all steps. One must show the stronger \ncondition that, for any n . N, if v1 and v2 are logically related for n steps, then f1(v1) and f2(v2) \nare logically related for n steps as well. The step-strati.ed possible worlds that arise in a model like \nADR only make matters worse by requiring additional quanti.cation over future worlds throughout the proof. \nHopefully, this example suggests the pressing need to develop more abstract, high-level, step-free, equational \nproof principles for step-indexed Kripke logical relations. 1.1 Existing Work on Reasoning About Step-Indexed \nModels Aside from the asymmetry of step-indexed binary relations, most of the issues discussed above \nalso arise in unary step-indexed models. To address them in that setting, Appel, Melli`es, Richards, \nand Vouillon [4] have proposed the use of a modal logic with an ap\u00adproximation modality C (pronounced \nlater ) [25]. Essentially, one can view step-indices as a form of possible worlds, with smaller indices \nrepresenting future worlds. Proposition P holds in world k if it holds (intuitively) for k steps of computation, \nand CP holds in world k if P holds, one step later , in world k - 1. This in\u00adterpretation validates the \nLob rule \u00a8derived from G\u00a8odel-L\u00a8ob logic, (CP . P ) . P , which provides a clean induction principle \nover step indices. In subsequent work, Hobor, Appel, et al. [18, 15] extend the C logic with other modalities, \nas well as the separat\u00ading conjunction P * Q from separation logic [38], which they use for proving the \nsemantic soundness of Concurrent Cminor in Coq. They describe multimodal separation logic as transforming \ntheir step-indexed proof effort from infeasible to feasible . More recently, Appel et al. s approximation \nmodality C has been used to reason about relational step-indexed models. Benton and Tabareau [9] prove \ncorrectness of a compiler for a simply-typed functional language, using a step-indexed model that interprets \nsource-language types in terms of relations on low-level programs. Their proof exploits both the C operator \nand separating conjunction [44] in order to modularize the relational constructions. Dreyer, Ahmed, and \nBirkedal [16] propose LSLR, a logic for reasoning abstractly about Ahmed s step-indexed logical relations \nfor pure call-by-value System F with recursive types [1]. The basic idea of LSLR is to incorporate the \napproximation modality C into a variant of Plotkin and Abadi s relational logic for parametric polymorphism \n[33]. Plotkin-Abadi logic provides a clean way of encoding logical relations for second-order polymorphism \nin terms of quanti.cation over second-order relation variables (which are primitive in the logic). Extending \nit with the C modality enables a simple well-founded mechanism for recursively de.ned relations \u00b5r.R, \nwith which one can then de.ne a logical relation for general recursive types quite elegantly. Furthermore, \nDreyer et al. derive a set of proof principles for direct equational reasoning by treating the direction \nof the step-indexed logical approximation relation as a hidden parameter of the LSLR judgment.  1.2 \nA Logic for Step-Indexed Kripke Logical Relations In this paper, we develop LADR, a modal logic for reasoning \nabout (a slight variant of) the ADR logical relation. Using LADR, we can express ADR-style contextual \nequivalence proofs at a much higher level of abstraction, avoiding low-level details about steps and \npossible worlds. LADR extends LSLR with a variety of features, most notably: (1) an abstract, logical \ncharacterization of ADR s possible worlds and populations, (2) the 0 modality from S4 modal logic, and \n(3) a simple fragment of relational separation logic [44]. In the remainder of this section, we motivate \nthese extensions. Local Reasoning About Islands Kripke logical relations in the tradition of Pitts and \nStark [31], of which ADR is one, employ pos\u00adsible worlds that are essentially sets of islands relational \nproper\u00adties concerning disjoint pieces of the heap. When we prove two terms related under a particular \nworld, we typically only know about some small (often singleton) set of islands that exist in that world, \nwhich in turn concern some piece(s) of local state that the terms have references to. However, due to \nthe quanti.cations over future worlds that arise in the proof of logical relatedness, the world in question \nmay contain arbitrary other islands. Fortunately, we can safely ignore those other islands in the proof \nbecause they are guaranteed to only place restrictions on other separate pieces of the heap that our \nterms do not directly touch or care about but, when working directly with the model, we still have to \nmindlessly push the other islands around. In LADR, to avoid such tedium, we instrument our judgments \nwith a context describing what islands must exist in the current world, without placing any restrictions \non what other islands may exist. This allows us to avoid reasoning explicitly about possible worlds. \nRather, it enables us to reason locally about only the islands we care about, yet be assured that our \nresults hold in the presence of arbitrary invariants concerning other pieces of the heap. Modeling Populations \nAs mentioned above, one of the key ad\u00advances of ADR is that islands contain populations, which may grow \nin future worlds. These populations may then be used to de.ne rela\u00adtional interpretations of abstract \ntypes that are dynamic, in the sense that they absorb more and more inhabitants over the execution of \nthe program. In order to support the encoding of such dynamic re\u00adlations in LADR, we equip each island \nin the island context with a population variable p. This p is a primitive dynamic relation repre\u00adsenting \nthe island s ever-growing population, which may be used as a basic building block in the de.nition of \nother dynamic relations. Population variables are suf.cient to account for LADR s lack of explicit worlds, \nsince the population of an island is the central as\u00adpect of the island that is dynamic, i.e., changes \nin future worlds. (The heap property of an island changes as well, but the way it changes is completely \ndetermined by how the population changes.)  Term &#38; Type Environments G ::= \u00b7| G,a | G,x:t Heap Environments \nS ::= \u00b7| S,l:t Base Types tb ::= unit | int | bool Types t ::= a | tb | t1 \u00d7 t2 | t1 + t2 | t1 . t2 | \n.a. t |.a. t | \u00b5a. t | ref t Expressions e ::= x | () | l | n | e1 = e2 | e1 = e2 | e1 + e2 | ... |true \n| false | if e then e1 else e2 |(e1,e2)| fst e | snd e |inl e | inr e | case e of inl x1 . e1 | inr x2 \n. e2 |.x : t. e | e1 e2 | .a. e | et |pack t1,e as .a. t | unpack e1 as a, x in e2 |roll e | unroll e \n| ref e | !e | e1 := e2 | e1 == e2 Values v ::= () | l | n | true | false |(v1,v2)| inl v | inr v | .x \n: t. e | .a. e | pack t1,v as .a. t | roll v Figure 1. Syntax of F\u00b5! Monotonicity and the 0 Modality \nA key notion in Kripke models is world extension, aka the accessibility relation between worlds. In ADR, \nthere are three ways in which a future world W2 can extend a starting world W1: time extension, width \nextension, and depth extension. Time extension means that W2 s step-index may be smaller than W1 s. Width \nextension means that W2 may contain more islands than W1. Depth extension means that the population of \nan island in W2 may be larger than the population of the same island (if it exists) in W1. When reasoning \nabout logical relations, it seems that all the propositions we are interested in are monotone with respect \nto time and width extension, so we build those forms of monotonicity into our model of LADR. However, \nsome propositions of interest are not monotone with respect to depth extension. In particular, in order \nto reason about extending the population of an island, we need to have a way of characterizing precisely \nwhat is in the population currently, even though the population may grow to contain more elements in \nfuture worlds. Thus, we do not build depth monotonicity into our model, but rather represent it explicitly \nusing the necessity operator 0 from S4 modal logic. That is, if a proposition P holds in world W , it \nmust hold in all future worlds that extend W by time and width, but not depth. If 0P holds in world W \n, then it must hold in all future worlds of W , period. Encoding Heap Relations in Relational Separation \nLogic Ul\u00adtimately, the main goal of islands is to encode relations between the heaps of the two programs \nbeing logically related. In LADR, we express these heap relations using an intuitionistic fragment of \nYang s relational separation logic [44]. Separation logic was de\u00adveloped by Reynolds, O Hearn, and others \nas a way of generaliz\u00ading Hoare logic to account for local reasoning about shared muta\u00adble data structures \n[38]. Yang s relational version, which is closely related to Benton s relational Hoare logic [7], allows \nfor Hoare\u00adstyle reasoning about the equivalence of two pointer programs us\u00ading Hoare quadruples. For \nour purposes, when proving that two terms are logically related, relational separation logic is useful \nas a way of reasoning cleanly about their execution in related heaps. Furthermore, the separating conjunction \n* is useful for joining the heap relations of multiple islands together into a single relation. 2. The \nProgramming Language The programming language we will be reasoning about is F\u00b5! , whose syntax is given \nin Figure 1. F\u00b5! is a completely standard polymorphic .-calculus, extended with primitive support for \nproduct, sum, existential, recursive, and ML-style reference types. Equality testing for base types tb \nis written e1 = e2, whereas pointer equality is written e1 ==e2. F\u00b5! has a standard left-to-right call-by-value \noperational semantics (not shown here), speci.ed in the style of Felleisen and Hieb, with E denoting \nan evaluation context. It is easy to de.ne a notion of e1 ctx contextual equivalence for F\u00b5!, written \nG; S f e2 : t , which asserts that e1 and e2 co-terminate when placed in any closing F\u00b5! context of the \nappropriate type. For space reasons, we refer the reader to the online appendix for further details [17]. \n3. Key Features of the ADR Logical Relation In this section, we review the key features of the ADR logical \nrelation, and brie.y sketch how we support them in LADR. 3.1 The Method of Populations Consider the \ntwin abstraction example (from ADR), in which we want to prove the programs e1 and e2 contextually equivalent: \nt = .a, \u00df. (unit . a) \u00d7 (unit . \u00df) \u00d7 (a \u00d7 \u00df . bool) C = let x = ref 0 in pack int, int, \\..++x,. .++x, \n.y.[ ]) as t e1 = C[fst y = snd y] e2 = C[false] Both e1 and e2 implement an ADT for a simple symbol \ngenerator. Internally, they both represent symbols as integers, and create new symbols via a local integer \npointer x. The .rst two functions they export generate symbols of abstract type a and \u00df, respectively. \nThe two functions are implemented in the same way, by bumping up the counter (++x is short for (x := \nx+1; !x)) and returning the current value as a fresh symbol. The third function tests whether a symbol \nof type a and a symbol of type \u00df are equal. In e1 s implementation, there is an integer equality test, \nbut e2 s implementation always returns false. Intuitively, the reason e1 and e2 are equivalent is that, \nwhenever a new symbol is generated, it either becomes a value of type a or of type \u00df, but not both. Thus, \nan equality test between values of type a and \u00df must always fail. However, formalizing this intuition \nis tricky: when proving the implementations equivalent, what are the right relational interpretations \nto choose for a and \u00df? Since we don t know ahead of time which integers will become a s and which will \nbecome \u00df s, how can we characterize up front what it means to inhabit a vs. \u00df? The ADR logical relation \nsolves this problem by introducing populations into its model of possible worlds. The basic idea is as \nfollows: When we allocate a fresh piece of local state, we get to extend the current world with a new \nisland governing how that state is maintained. In ADR, the island may contain a population (formalized \nas a value relation), which can grow in future worlds and be used to track some knowledge about the history \nof the local state. The island also contains a law, specifying (1) what populations are legally valid, \nand (2) what relational properties the local state must satisfy depending on what the population is. \nFor the twin abstraction example, the island governing the local counter x would include an (initially \nempty) population tracking (1) how many symbols have been generated so far and (2) which of those symbols \nare a s vs. \u00df s. Formally, this can be encoded as the relational map of some total function from {1,...,n} \nto {1, 2}(for some n). The law of the island would demand that, whenever the size of the population relation \nis n, the island s heap relation asserts that x points to n in both programs. Finally, we can now de.ne \nrelational interpretations for a and \u00df that are dependent on the population of the island governing x. \n Speci.cally, we can say that v1 and v2 are related at a under world W if there exists a positive integer \nn such that v1 = v2 = n and (n, 1) is a member of the population of the island governing x in W . Similarly, \nthey are related at \u00df if (n, 2) is in the population. Note that, by this de.nition, there is no way v1 \nand v2 can be related both at a and \u00df (in the same world W ), which is what we needed to establish in \norder to prove the equivalence of e1 and e2. Note also that the interpretations of a and \u00df are examples \nof what we described in the Introduction as dynamic relations, i.e., they grow in future worlds in accordance \nwith changes to some local state. In LADR, to express relations (like those for a and \u00df) that de\u00adpend \non the current population of an island, we employ population variables. As described in the Introduction, \nwe attach a population variable p to every island bound in the island context of our logical judgment. \nTerms e1 and e2 are related by p in world W iff (e1,e2) is in the population of the island corresponding \nto p in W . Re\u00adturning to the twin abstraction example, assuming p is the variable corresponding to the \nisland governing the counter x, we can de.ne the relation for a in LADR as (x1,x2).x1 = x2 . (x1, 1) \n. p, and the relation for \u00df as (x1,x2).x1 = x2 . (x1, 2) . p. Thus, we avoid ever talking explicitly \nabout the world W .  3.2 Step-Strati.ed Worlds for Higher-Order State When are two values v1 and v2 \nlogically related at the type ref t? Intuitively, the answer is: when they are memory locations l1 and \nl2 whose contents are currently logically related at type t and, more\u00adover, will continue to be related \nat type t in the future. This strong condition on l1 and l2 s contents is necessary in order to ensure \nthat dereferencing and assignment preserve logical relatedness. The condition is also easy to express \nusing an island. In particular, ADR de.ne l1 and l2 to be logically related at ref t in world W if W \ncon\u00adtains an island with a heap invariant ensuring that the contents of those locations are logically \nrelated at type t. Now, in order for a heap invariant to specify that the contents of l1 and l2 are logically \nrelated at type t, it must also specify the world in which that relation is considered. (If our language \nonly supported .rst-order state, and t were restricted to be a base type like int, the world would be \nirrelevant, but in the presence of higher-order state, the world matters.) Ideally, we would choose it \nto be whatever is the current world. However, since the cur\u00adrent world changes all the time (as the world \nis extended), ADR instead parameterize heap relations over the world in which they are considered. Then, \nwhen checking whether two heaps satisfy the demands of a world W , the heap relation in each island of \nW is instantiated to the current world (namely, W ). Unfortunately, it s not quite that simple . It is \neasy to see by a simple cardinality argument that we cannot construct worlds that contain heap relations \nparameterized by worlds. This is where step-indexing comes in. ADR stratify worlds by a step-index, so \nthat the heap relations in k-indexed worlds are parameterized by (k - 1)-indexed worlds. This is suf.cient \nfor encoding the logical relation at type ref t (as described above) because it takes a step of computation \nto observe the contents of l1 and l2, and so we only need to know their contents are logically related \none step later . In LADR, much of this technical detail is kept hidden away from the user of the logic \nand buried in the model. The heap rela\u00adtions that appear in LADR islands are not explicitly parameterized \nover worlds because the logic does not talk about worlds explic\u00aditly at all. To express logically the \nrestriction that an island heap relation H can only talk about logical relatedness of heap contents one \nstep later , we require syntactically that H be what we call delayed. This means essentially that any \nworld-dependent proposi\u00adtions contained within H (such as logical relatedness at an arbitrary higher \ntype t) must appear under the later modality (C). Absolute Relation Variables a, b . AbsRelVar Normal \nRelation Variables p, q, r, s . RelVar Variable Contexts X ::= \u00b7|X ,a |X ,x Relation Contexts R ::= \u00b7|R,a \n|R,p Island Contexts L ::= \u00b7|L,p . a.(B, H) Hypothesis Contexts P ::= \u00b7|P,P Joint Contexts C ::= X ; \nR; L; P Absolute Relations A, B ::= e1 = e2 | e1 .0 e2 | e1 .1 e2 | e1 . * e2 |T|.| A . B | A . B | A \n. B | .X .A | .X .A |.R.A | .R.A | e . A | a | x.A | Val | Consttb | Loc Normal Relations P, Q, ::= A \n| P . Q | P . Q | P . Q | .X .P | .X .P | R, S .R.P | .R.P |. a.(B, H) | IP | OP | e . R | r | x.P | \n\u00b5r.R |.R | Termi | H . J Heap Relations H, J ::= e1 '.i e2 | H * J | H . J | .X .H | OP Figure 2. Syntax \nof LADR def Vali = x. x . Termi . x . Val def R : VRel = O(.x1,x2. (x1,x2) . R . x1 . Val1 . x2 . Val2) \ndef R : Type = R : VRel . O(.x1,x2. (x1,x2) . R . O(x1,x2) . R)  def (x1 . R1,x2 . R2).P =(x1,x2).x1 \n. R1 . x2 . R2 . P def (X ; R; L; P )= X ; R; L; P defdef *E = OT (OP )= OP defdef *H, H = H * (*H) P \n= T (if P= OP ') def <(X ; R; L; P )= X ; R; L; <P V def E = T def VV <(IP )= P def P, P = P . ( P ) \ndef <P = P (if P= IP ') Figure 3. Auxiliary Notation for the Logic 4. LADR: Syntax The syntax of our \nlogic LADR is given in Figure 2. LADR is a relational second-order intuitionistic modal logic, supporting \nrelations of arbitrary arity. Propositions are just nullary relations. While P , Q, R, and S may denote \nany kind of relation, we will typically use P and Q to represent propositions, and R and S to represent \nbinary relations. Absolute relations A and B are a useful syntactic subcategory of relations; such relations \nare abso\u00adlute in the sense that their meaning essentially does not depend on the world in which they \nare considered. We say essentially because we consider everything to be true in a trivial world (i.e., \nworld with step index 0). Thus, an absolute proposition A is true in any non-trivial world iff A is true \nin all non-trivial worlds. Most of the atomic relations in LADR are absolute. e1 = e2 denotes syntactic \nequality. e1 r * e2 says that e1 reduces to e2 in an arbitrary number of pure (non-heap-dependent) reduction \nsteps. e1 r0 e2 says that e1 r * e2 without making any unroll-roll reductions. e1 r1 e2 says that e1 \nr * e2, making exactly one unroll-roll reduction. These latter two propositions are borrowed from LSLR \n[16]; the distinction they make between unroll-roll and other reductions is useful because our logical \nrelation for terms (de.ned below in Section 5) is closed under \u00df-reduction and other forms of pure reduction, \nbut not under unroll-roll reduction. A term e is in Val if e is a value, in Consttb if e is a constant \nof base type tb, and in Loc if e is a memory location l. The predicate Termi describes terms whose free \nlocations are bound in the heap  def = V[a]. def = V[tb]. def V[t ' \u00d7 t '']. = ' '']. def + t = ' '']. \nV[t def . t =V[t def V[.a. t]. = def V[.a. t]. = def V[\u00b5a. t]. = def V[ref t]. = def = E[t]. .(a) (x1 \n. Consttb ,x2 . Consttb ).x1 = x2  '''''' ''' ''' '' '''' (x1 . Val1,x2 . Val2). .x1,x 1 ,x 2,x 2 .x1 \n= (x1,x ). x2 = (x2,x ). (x1,x ) .V[t ']. . (x1 ,x 1222 ''' ''' (x1 . Val1,x2 . Val2). (.x1,x 2.x1 = \ninl x . x2 = inl x . (x1,x ) .V[t '].) . 1 22 '''' '' '' '''' ''].) (.x1 ,x 2 .x1 = inr x . x2 = inr \nx . (x1 ,x ) .V[t 1 22 (x1 . Val1,x2 . Val2). O(.y1,y2. (y1,y2) .V[t ']. . (x1 y1,x2 y2) .E[t ''].) (x1 \n. Val1,x2 . Val2). O(.a1,a2. .r. r : Type . (x1 a1,x2 a2) .E[t]., aw.r) (x1 . Val1,x2 . Val2). .a1,a2,a \n' ,a ' 2. .y1,y2. .r. r : Type . 1x1 = pack a1,y1 as a ' . x2 = pack a2,y2 as a ' . (y1,y2) .V[t]., aw.r \n12 \u00b5r. (x1 . Val1,x2 . Val2). .y1,y2.x1 = roll y1 . x2 = roll y2 . I(y1,y2) .V[t]., aw.r (x1 . Val1,x2 \n. Val2). . a.(a ={(x1,x2)}, .y1,y2.x1 '.1 y1 * x2 '.2 y2 * OI(y1,y2) .V[t].) .V[t]. ) .V[t '']. Figure \n4. Syntactic Logical Relation for F\u00b5! for program i (where i ranges over {1, 2} with 1 representing the \nprogram on the left and 2 representing the program on the right of the logical relation). As new locations \ncan get allocated during the execution of the programs (and thus in future worlds), Termi is not an absolute \nrelation. We write Vali to denote Termi n Val. Truth, falsehood, conjunction, disjunction, and implication \nare all standard. The .rst-order .X .P and .X .P quantify over vari\u00adable contexts X , which bind type \nvariables a, \u00df and term variables x, y (which may or may not be values). The second-order .R.P and .R.P \nquantify over relation contexts R, which bind normal and absolute relation variables (p, q, r, s and \na, b, respectively). In the sequel, we use = and . to denote relational equivalence and inclusion, de.ned \nlogically in the obvious way. We also use set notation (e.g., {}, ., n) as shorthand for the corresponding \nLADR relations and relational operations, all de.ned logically in the obvious way. The proposition . \na.(B, H) asserts that in the current world there is an island with population law B and heap law H, where \nthe absolute relation variable a is bound in both B and H. Given a population (represented by a), the \npopulation law says whether a is a valid population for the island (i.e., A is valid if B[A/a] is true). \nNote that this law is absolute and does not change in future worlds. The heap law speci.es the heap relation \nof the island as a function of the current population a. For the . proposition to be well-formed, the \nheap law H must be delayed, a notion which we discuss in conjunction with heap relations below. Closely \nrelated to the . proposition is the notion of an island context L. We use island contexts to keep track \nof the islands in the world that we know and care about. In addition to specifying the law for each island, \nL associates with each island a population variable p, as we discussed in Section 3.1. The modality CP \nsays that P holds one step later (but not necessarily now), a notion we make formal in Section 6. The \nmodality 0P says that P holds now and in all future worlds. x.P denotes the relation {(x) |P }, and e \n. R holds if e belongs to the relation R. (Here, and throughout, we write foo to denote a sequence of \nzero or more foo s, separated by commas.) The recursive relation \u00b5r.R is useful in de.ning the logical \nrela\u00adtion for recursive types. To be semantically well-founded, we insist that R must be contractive \nin r, meaning that it may only mention r under a C modality. Thus, the apparently circular meaning of \n\u00b5r.R is really inductive in the step-indices that stratify worlds. The relation .R denotes the lifting \nof a binary value relation R to a term relation. Roughly, (e1,e2) ..R if e1 and e2, when evaluated under \nany heaps h1 and h2 (respectively) that satisfy the demands of the current world, either both terminate \nor both diverge. In the case that they terminate, there must exist some future world such that the resulting \nheaps satisfy that future world and the resulting values are related by R in that future world. This \nintuitive description of .R leaves out the details of how step-indices play into the picture, which will \nbecome clear when we present the model in Section 6. Last among the propositions is H = J, which denotes \nheap re\u00adlation entailment. The heap relations denoted by H and J express relations between the heaps \nof the two programs we are reasoning about. Instead of incorporating explicit heap objects into LADR \nand reasoning about them directly, we rely on primitives of intu\u00aditionistic separation logic to express \nour heap relations. Thus, the entailment H = J has the usual separation logic interpretation i.e., any \npair of heaps that satisfy H must also satisfy J. The points-to relation e'.i e ' relates two heaps h1 \nand h2 if e is a location in the domain of heap hi, e ' is in Vali, and hi(e)= e ' . This relation is \nintuitionistic in that it makes no restrictions on heap h\u00aci (where \u00aci =3 - i), and does not require that \ne be the only location in the domain of hi. The separating conjunction H1 * H2 relates h1 and h2 if h1 \nand h2 can be split into disjoint pieces such that H1 relates one piece and H2 relates the other. Disjunction \nand existential quanti.cation are standard. Finally, we come to 0P , which embeds the proposition language \nof our logic in the heap relation language. 0P is like a pure assertion in traditional separation logic \nin that it ignores the heaps entirely. It is explicitly 0 d to ensure that all heap relations are (by \nconstruction) monotone w.r.t. all forms of world extension. This requirement, carried over from ADR, \nensures that when we grow the population on one island of a world a form of depth extension (see the \nIntroduction) we do not violate heap properties on other islands. For general heap relations, there is \nno restriction on subformulas of the form 0P . However, for the heap relations appearing in island heap \nlaws (either in a . proposition or an island context L), we insist that P be delayed. Semantically, this \nmeans that the meaning of P only depends on what the world looks like one step later . As a syntactic \napproximation of this semantic criterion, we de.ne P to be delayed if all non-absolute constructs in \nit (with the exception of Termi) appear under a C modality. When we give our model of LADR, the delayed \nrestriction will enable us to interpret an island heap law by a semantic heap relation that is indexed \nby worlds of a lower step-index. This is critical for the step-strati.ed construction of worlds, as we \nexplained in Section 3.2. The full de.nition of syntactic well-formedness for all relations and contexts \nof LADR is formalized in the online appendix [17].  def HeapAtom= {(W, h1,h2) | W . Worldn . h1,h2 \n. Heap} n def ' HeapRel= {. . HeapAtom|.(W, h1,h2) . .. .W ; W. (W ' ,h1,h2) . .} nn def Islandn = \n{(CP, PL, HL) | CP . PL .P(Termk) . HL .P(Termk) . HeapRel} n def .n Worldn = {(k, d, .1,.2, I) | k<n \n. d . {., .} . .1,.2 . Loc .I. IslandName . Islandk} def '' SemRelk = {. . World .P(Termk) |.W, W . \nWorld.W . W . .(W ' ) . .(W )} def '' W . W = W ' .k = W.k . W ' .d = W.d . W ' ..1 . W..1 . W ' ..2 \n. W..2 . W.I. lW.IhW '.k def '' W ; W = W ' .k = W.k . W ' .d = W.d . W ' ..1 . W..1 . W ' ..2 . W..2 \n. W.I; lW.IhW '.k def I ' ;I = .. . dom(I). I ' (.).CP .I(.).CP .I ' (.).PL = I(.).PL .I ' (.).HL = I(.).HL \ndef def lIhk = ...lI(.)hk IW =(W.k - 1, W.d, W..1, W..2, lW.IhW.k-1) def def l(CP, PL, HL)h=(CP, PL, \nlHLhk) <W =(W.k +1, W.d, W..1, W..2, W.I) k def lHLhk = .CP.lHL(CP)hk def pop(.)= .W. W.I(.).CP defl.hk \n= {(W, h1,h2) . . | W.k < k} def h1,h2 : W = . h1 .. h2 . dom(h1) . W..1 . dom(h2) . W..2 ..h ' ,h ' \n.h ' . h1 . h ' . h2 . h ' ,h ' 121 2 12 :dom(W.I) W def h1,h2 :. W = W.k > 0 ..h1,...,hn,h1,...,hn.h1 \n= h1 \u00b7\u00b7\u00b7 hn . h2 = h1 \u00b7 \u00b7\u00b7 hn . 112211 22 . = {.1,...,.n}..k .{1,...,n}. (IW, hk,hk) . W.I(.k).HL(W.I(.k).CP) \n12 def W . (h1; e1) (h2; e2):. = FL(e1) . W..1 . FL(e2) . W..2 . '' (W.d = ...j < W.k. .h ' 1,e 1. \n(h1; e1) .j (h ' ; e ) . 11 '' ' '''' .h ' 2,e ,W ' .W .k = W.k - j . W ; W . (h2; e2). (h ' ; e ) . \n.W (e1,e ) . h ' ,h ' : W ' ) . 222212 '' (W.d = ...j < W.k. .h ' 2,e 2. (h2; e2) .j (h ' ; e ) . 22 \n'' ' '''' .h ' 1,e ,W ' .W .k = W.k - j . W ; W . (h1; e1). (h ' 1; e ) . .W (e1,e ) . h ' ,h ' 2 : W \n' ) 1121 Figure 5. Worlds 5. LADR: A Logical Relation for F\u00b5! Following Plotkin and Abadi [33], we do \nnot bake in logical re\u00adlations for F\u00b5! as primitive notions in LADR, for they are already expressible \ndirectly in terms of existing constructs. Figure 4 de.nes a logical relation for F\u00b5! syntactically in \nterms of LADR relations. V[t]. de.nes the logical relation on values of type t , where . maps the free \nvariables of t to their interpretations as LADR relations. E[t]. de.nes the logical relation for terms, \nwhich is just the lifting (via the primitive . operation) of the one for values. The de.nition is inductive \non the structure of t. For the most part, the de.nition is straightforward, interpret\u00ading each type using \nthe appropriate logical connective according to the Curry-Howard correspondence. A key property of V[t]. \nis that it is monotone w.r.t. all forms of world extension (formally, that V[t ]. : Type as de.ned in \nFigure 3, under the assumption that .a . dom(.)..(a) : Type). Thus, in the cases of func\u00adtion and universal \ntypes, the relations are explicitly 0 d to ensure monotonicity, and in the cases of universal and existential \ntypes, we require the universally or existentially quanti.ed relation variable r to satisfy r : Type. \nRecursive types are interpreted, quite naturally, as recursive relations. Moreover, by using the recursive \nrelation primitive, we can de.ne V[\u00b5a.t]. inductively on the type. Due to the syntactic restriction that \nthe body of a recursive relation be contractive in the recursive relation variable r, we de.ne roll v1 \nand roll v2 to be logically related (at \u00b5a.t ) if v1 and v2 are related (at t [\u00b5a.t/a]) later. This is \ntypical of a step-indexed model. Intuitively, it makes sense because it takes one unroll-roll reduction \nstep to reduce the equivalence of roll v1 and roll v2 to the equivalence of v1 and v2, so if the latter \nare related for n steps, the former should be related for n +1 steps. Reference types are interpreted \nin essentially the way we de\u00adscribed in Section 3.2. Namely, two locations are related at ref t if there \nexists an island in the world whose heap law asserts that their contents are related at type t one step \nlater. (Note: the 0 in front of the C is only there because C(y1,y2) .V[t]. is a normal propo\u00adsition, \nwhich must therefore be explicitly 0 d in order to appear inside the heap law.) The population law a \n={(x1,x2)} asserts that the population relation is .xed and equals the singleton rela\u00adtion relating the \ntwo locations. While this is not a very interesting use of populations, we .nd it useful as a way of \ndistinguishing the island for one location from another (see the proof of compatibility for == in the \nonline appendix [17]). 6. LADR: Model Our model for LADR is based closely on the ADR model. We interpret \nnormal LADR relations into semantic relations, which are simply relations on closed terms (possibly with \nfree locations) indexed by possible worlds. (Absolute relations may be interpreted straightforwardly \nas ordinary relations with no world index, and we give such an interpretation in the online appendix \n[17].) 6.1 Worlds Possible worlds are de.ned in Figure 5, along with some auxiliary notation. A world \nis a 5-tuple (k, d, .1,.2, I) consisting of a step level k, a direction parameter d, sets of valid locations \n.1 and .2 (for the left and right terms, respectively), and an island map I. The direction parameter \nd, ranging over {., .}, describes which direction of logical approximation we are proving (i.e., that \nthe term on the left approximates the one on the right or vice versa). By building the direction in as \na parameter of the world, we ensure that proofs of logical relatedness establish logical equivalence. \nAn island map associates island names with islands of the form (CP, PL, HL), where CP is the current \npopulation of the island, PL is the population law, and HL is the heap law. Formally, the current population \nis just a term relation (of arbitrary arity), PL is a set of such populations, and HL is a function from \npopulations to heap relations. Heap relations, in turn are indexed by worlds, but  Unlike in ADR, worlds \nas we have de.ned them here do not make disjointness of islands manifest. Instead of explicitly includ\u00ading \nin each island the set of locations owned by the island, as the ADR model does, our worlds just record \nthe global sets of lo\u00adcations in .1 and .2. However, heap separation is enforced in the de.nition of \nheap satisfaction: a pair of heaps satisfy a world, writ\u00adten h1,h2 : W , if they contain sub-heaps that \ncan be split up into pairs of disjoint parts, each of which is related by the heap relation of one particular \nisland. Two con.gurations are related in a given world W , written W f (h1; e1) (h2; e2):., if the termination \nof one in j < W.k serious steps implies the termination of the other, with the re\u00adsulting heaps and values \nrelated by the semantic relation . in some (W.k - j)-level future world of W . Which con.guration s termi\u00adnation \nimplies the other s is determined by the direction param\u00adeter d. By serious steps, we mean either unroll-roll \nreductions or impure steps that inspect or modify the heap. Also, note that (h1; e1) .j (h1' ; e1' ) \nimplies that e1 ' cannot reduce further, but not necessarily that e1 ' is a value it could be a stuck \nterm.  6.2 Interpretation of Relations Figure 6 shows the interpretation of LADR relations. As a relation \nR may have free relation variables R, its interpretation [R] is parameterized by a relational interpretation \nd, which maps the variables in R to semantic relations of the appropriate kind. Following LSLR, we de.ne \n[R]dW by a two-level induction, .rst on the step level W.k, and second on the size of R (where, crucially, \nCP is considered to have constant size). At step level 0, all propositions are trivially true because \nTime s up! Otherwise, in terms of ensuring that the induction metric is obeyed, the only interesting \ncases are for CP and \u00b5r.R. The C modality is interpreted by going down one step , i.e., moving to the \nworld one step later (abbreviated CW , as de.ned in Figure 5). Thus, even though CP has constant size \nand thus P is potentially larger, the world in which we interpret P has a lower step-index, so the induction \nmetric gets smaller. A recursive relation \u00b5r.R is de.ned to be equivalent to its expansion R[\u00b5r.R/r]; \nassuming (as we do) that \u00b5r.R is well-formed, that means R must be contractive in r, and thus the expansion \nis actually smaller in size than \u00b5r.R. As explained in the Introduction, all propositions are required \nto be monotone with respect to time and width extension (written ., which is de.ned in Figure 5). This \nproperty is stipulated formally in the de.nition of semantic relations (see SemRelk, also de.ned in Figure \n5). Consequently, the interpretations of both implication (.) and entailment (=) quantify over worlds \nW ' that extend the current world W in time and/or width. In contrast, the truth of 0 d propositions \nmust be preserved under arbitrary world extension (written ;). The interpretation of .R relates e1 and \ne2 if, for any heaps h1 and h2 satisfying the current world W , (h1; e1) and (h2; e2) are related con.gurations \nunder W . Besides .R, the other interesting world-dependent proposition is . a.(B, H). It holds if the \nworld contains an island named . that correctly models the singleton island context p . a.(B, H). (For \nmore details on the model of island contexts, see below.) Heap relations H are interpreted in mostly \nthe standard separa\u00adtion logic way, except that we require values occurring in a refer\u00adence assignment \ne1 '.i e2 to be well-formed in the current world, i.e., contain only locations from the respective heap \nW..i. Last but not least, Figure 6 gives the semantic interpretation of island contexts L. We say that \nthe islands . in world W correctly model island context L (written [L]dW .) if there is a bijection between \n. and L such that the semantic population and heap laws of each island in . faithfully model the syntactic \npopulation and heap laws of the corresponding entry in L. [P ]dW e [P ]dW e T dW[ . dW [P . Q] dW [P \n. Q dW [P . Q dW .X .P dW .X .P dW .R.P dW[ .R.P dW [. a.(B, H)] dW dW [IP dW [e . R] dW [a]dW e [r dW \ne [OP [x.P dW e [\u00b5r.R] dW e [.R]dW (e1,e2) [Termi]dW e J]dW e [H [P1,...,Pn]dW [H]dW (h1,h2) def = def \n= def = def = def = def = def = def = def = def = def = def = def = def = def = def = def = def = def \n= def = def = def = [H]dW (h1,h2) '.i e2]dW (h1,h2) [e1 [H1 * H2]dW (h1,h2) [H1 . H2 dW (h1,h2) [.X .H \ndW (h1,h2) [OP ] dW (h1,h2) [L]dW . T if W.k =0. Otherwise: T . [P ]dW . [Q]dW [P ]dW . [Q]dW ' '' .W \n. W. [P ]dW . [Q]dW .. .X . .P dW .. . [ X ] . [ .P ] dW .d ' .R .P (d, d ' )W .d ' [ P ] (d, d ' )W \n. [ R] . ... [p . a.(B, H)]d ' W {.}where p . dom(d) . d ' = d, pw.pop(.) '' .W ; W. [P ]dW Pd(IW )[ \nR] dW e d(a)e d(r)We P [e/x]]dW[ R[\u00b5r.R/r]]dW e '' .W . W. .h1,h2 : W. ' W (h1; e1) (h2; e2): [R]d FL(e) \n. W..i ' .W . W. .h1,h2. [H]dW ' (h1,h2) . [J]dW ' (h1,h2) V n i=1 [Pi]dW def = def = def = def = def \n= def = T if W.k =0. Otherwise: [e1 . Vali]dW . [e2 . Vali]dW . hi(e1)= e2 .h1 ,h2 ,h1 ,h22 . .i. 112 \nhi = h1 h2 . [Hi]dW (hi ,hi ) ii 12[H1]dW (h1,h2) . [H2]dW (h1,h2) .. . [X ] . [.H]dW (h1,h2) [OP ]dW \ndef [L]dW . = T if W.k =0. Otherwise: def dW . = . = \u00d8 [\u00b7 def [L,p . a.(B, H)] dW . = .. . .. d(p) = \npop(.) . [L]dW (. -{.}) . W.I(.).PL = {CP || B| (d, aw.CP)}. ' .CP . W.I(.).PL. .W ; IW. ' (W ,h1,h2) \n. W.I(.).HL(CP) .. ' [H](d, aw.CP)(<W )(h1,h2) Figure 6. Model (Part 1): Relations and Islands at one \nstep level lower than the world containing them thus, the construction of worlds can be strati.ed by \nthe step level n. When S we write W , we draw it from n.N Worldn, and similarly for the other metavariables. \nNote also that we require heap relations to be monotone by construction, for the reasons explained in \nSection 4. For convenience, we use dot notation (e.g., W.I(.).HL) to project components out of worlds \nin the obvious way.  There are two particularly interesting points here. First, note that, for each \nisland described by L, we only require its heap law H to match the corresponding heap law of W when attention \nis restricted to the relatedness of heaps at strictly future worlds of W (i.e., at worlds W ' ; CW ). \nIntuitively, this makes sense because (1) given the step-strati.ed construction of worlds, the actual \nheap law of W can only possibly contain heap atoms (W ' ,h1,h2), where W ' .k <W.k, and (2) since W is \nour starting world, we can safely ignore worlds that are not future worlds of it. (Putting these observations \ntogether, W ' .k < W.k .W ' ; W is equivalent to W ' ; CW .) Moreover, restricting attention to strictly \nfuture worlds seems to be critical in proving the soundness of some of the proof rules that we present \nin Section 7, such as the .-INTRO rule. Second, note the mysterious appearance of <W ' in the model\u00ading \nof the heap law H in [L]. The < operator is de.ned formally in Figure 5, and we pronounce it as earlier \nbecause it lifts the world W ' up one level instead of pushing it down one level (as C does). What is \ngoing on here? Basically, as we explained in Section 3.2, the issue is that we model the syntactic heap \nlaw H which is pre\u00adsumed to hold true at the current step level, i.e., W.k using a semantic heap law \n(W.I(.).HL) that is indexed by worlds with step levels strictly less than W.k. This results in an unavoidable \noff-by-one error, for which the < operator then serves as a patch. To understand how our use of < works, \nconsider the follow\u00ading situation, variations of which arise in proving the soundness of several key \nLADR proof rules (such as .-IMPURE and ISL-UPD, described in Section 7). Suppose the current world under \ncon\u00adsideration is W , and suppose we are given the assumption that heaps h1 and h2 satisfy the heap law \nof some island . in W (i.e., h1,h2 :{.} W ). Suppose further that the corresponding island in the island \ncontext L has syntactic heap law H. Given these assumptions, we expect it to be the case that [H]dW (h1,h2) \nfor some appropriate d i.e., that h1 and h2 sat\u00adisfy H under world W and we rely on this fact at various \npoints, but it is something we need to show. Our assumption h1,h2 :{.} W tells us that (CW, h1,h2) . \nW.I(.).HL(W.I(.).CP), i.e., that h1 and h2 satisfy W s actual heap law under world CW . According to \nthe model of [L] (instantiating W ' with CW ), we therefore know that h1 and h2 satisfy H under world \n< CW , and from this we must derive that they satisfy H under W . If H were an arbitrary heap relation, \n[H]dW and [H]d(< CW ) would not necessarily coincide. However, since H came from the island context L, \nwe know that it must be delayed (cf. Section 4), which ensures that its meaning [H]dW can only depend \non what W looks like at one lower step level, i.e., on what CW looks like. Thus, since CW = C< CW , the \nproof is complete. Note that it is not the case that [H]dW coincides with [H]d(CW ) more things are related \nat CW because its step level is lower than W s so the use of < here is critical in in.ating CW to the \nsame step level as W .  6.3 Judgments The LADR inference rules concern three judgments. They all use \na context C of the form (X ; R; L; P), where X binds type and term variables, R binds relation variables, \nL associates (but does not bind) population variables with their related island de.nitions, and P speci.es \na set of hypotheses. As with worlds, we use dot notation to project out the component contexts of a C. \nThe interpretation of contexts is shown in Figure 7. A combined context (X ; R; L; P) is interpreted \nby all tuples (., d, W, .1,.2), where: (1) . and d are closing instantiations for X and R, (2) the names \nof W s islands can be split into two sets, .1 and .2, such that .1 corresponds to the islands speci.ed \nin L, and (3) the hypotheses in P hold under d and W . Note that the interpretation of island contexts \nenforces that d will map each population variable in L to pop(.), the population relation for some island \n. in .1. def X = {. | dom(.)= X. FV(rng(.)) = \u00d8} def {d | dom(d)= R..a .R. da .P(Termarity(a)) .= [ R] \n .r .R. dr . SemRelarity(r)}def [X ; R; L; P] = {(., d, W, .1,.2) | . . [X ] . d . [R] . [.L]dW .1 . \n[.P]dW . dom(W.I)= .1 .2}def C P = .(., d, W, .1,.2) . [C] . [.P ]dW def C{H} e1 e2 {R} = .(., d, W, \n.1,.2) . [C] . W.k > 0 ..h1,h2,h1 ,h2 ,h1 ,h22. 11 hi . dom(hi) . W..i . hi = hi 1 h2 . i [.H]dW (h1 \n,h1) . h2 ,h2 1212 :.2 W . W (h1; .e1) (h2; .e2): [.R]d C ' def ' C{H} e w-.i e {H ' } = C ' = x, x \n. Vali ..(., d, W, .1,.2) . [C] . .h1,h2. [.H]dW (h1,h2) . W.k > 0 ..l/. dom(hi) . W..i. l .h 1, h2.h \n\u00aci = h\u00aci . (hi; .e) w-.1 (h i; .e ' [l/x]) . [.H ' [l/x]]d(W [.i := W..i {l}])(h 1,h2) Figure 7. Model \n(Part 2): Contexts and Judgments The main judgment of LADR is of the form Cf P , which states that P \nis true for any interpretation of C. If one is only reasoning about pure terms, one never needs to leave \nthis judgment. Equivalence of impure terms can be derived by going through the separation judgment Cf{H} \ne1 e2 {R}. Essentially, it states that, for any heaps h1 and h2 satisfying the precondition H, the con.gurations \n(h1; e1) and (h2; e2) are related in the current world, producing values related by R. But it is actually \na bit more complicated than that, as the judgment also bakes in a framing con\u00addition. The condition says \nthat h1 and h2 can be split into disjoint pieces, such that the .rst piece satis.es H, and the second \npiece satis.es the heap laws of the islands .2. This rather subtle framing condition is necessary in \norder to ensure that all the action that takes place in the separation judgment only affects the piece \nof the heap governed by the laws in C.L, which in turn is important in proving sound the critical ISL-UPD \nrule (Section 7). C ' The auxiliary small-step judgment Cf{H} e -.i e ' {H ' }states that under precondition \nH, e reduces to e ' in one serious step (cf. Section 6.1), implying postcondition H '. If the step is \nan allocation, then C ' introduces a new variable x (which is a bound variable of the judgment) that \nstands for the resulting fresh location in e ' and H '; otherwise C ' is empty. The i speci.es which \nprogram is being executed, the one on the left (i =1) or the one on the right (i =2). For the other program \n(\u00aci =3 - i), the heap is guaranteed not to change. Note that, in the model of the judgment, we quantify \nover all possible choices of a fresh location, and then extend the world W with that location. 7. LADR: \nProof Rules Figures 8 and 9 present the most important proof rules of LADR. Soundness proofs for all \nthese rules are given in the appendix [17]. We omit introduction and elimination rules for the standard \nlogical connectives here in the interest of space. We also omit standard axioms about atomic propositions \n(like Val, Consttb , e1 r k e2, etc.), which can be proven easily in the model. Throughout, we make the \nimplicit assumption that the terms appearing in rules are in Term1 or Term2, as appropriate, under the \ngiven context C. These assumptions can be built into the rules straightforwardly, at the expense of cluttering \nthe presentation.  C e1 = e2 CJ [e1/x] CJ C P C,P J REPLACE WEAKEN CUT CJ [e2/x] C, X , R, PJ CJ C,IP \nPC P C P< C P C P I-MONO I-WEAKEN L\u00a8 L-WEAKEN OB C, L P C IP C IP C P C I(P . Q) C I(P . Q) C I(P . \nQ) C I.X .P C I.R.P C I.X .P C I.R.P C IP . IQ C IP . IQ C IP . IQ C .X .IP C .R.IP C .X .IP C .R.IP \nC P C e . Termi C IOP C A C OP O-INTRO O-INTRO-ABS O-INTRO-TERM O-ELIM IO-SWAP C OP C OA C O(e . Termi) \nC P C OIP C e . x.P C e . \u00b5r.R ELEM ELEM-\u00b5 C P [e/x] C e . R[\u00b5r.R/r] p . a.(B, H) .C.LC e . pp . a.(B, \nH) .C.LC A = pp . a.(B, H) .C.L POP-MONO POP-LAW POP-SNAP C O(e . p) C B[A/a] C.a.a = p p . a.(B ' ,H \n' ) .C.L C.a.B = B ' C. a.(B, H) C, p, p . a.(B, H) P ' C O(.a.B . (H * H ' )) .p ' . a.(B ' ,H ' ) \n.C.L: C, .a.B = B ' , O(.a.B . (H * H )) P .-INTRO .-ELIM C. a.(B, H) C P ' C H OP C, OPH H C OP ' C \nH OP C HH * OP C OP * HH C e1 '.i e2 O(e1 . Loc . e1 . Vali . e2 . Vali) '' '''' C (e1,e ) ..R C (e1,e \n) ..R< C (e1,e ) ..R 222 *'*' ' 0 ' 01 ' 1 ' C e1 e C e2 e C ee1 C ee2 C e1 e C e2 e 1212 12 .-EXPAND \n.-REDUCE .-UNROLL C (e1,e2) ..R C (e1,e2) ..R C (e1,e2) ..R C (e1,e2) . R C R : VRel C (e1,e2) ..S C,x1,x2, \n(x1,x2) . S (E1[x1],E2[x2]) ..R .-RETURN .-BIND C (e1,e2) ..R C (E1[e1],E2[e2]) ..R C.L = p . a.(B, H) \nC, a, p = a {*H} e1 e2 {R} .-IMPURE C (e1,e2) ..R Figure 8. Key Inference Rules of LADR (Part 1): Structural \nRules and Main Judgment The .rst three rules are standard laws for replacement of equal terms, weakening, \nand cut. We write J to range over all three judg\u00adments introduced in Section 6.3. Note that the general \nweakening rule does not allow the addition of islands. Weakening of the island context is allowed for \nthe main judgment (rule L-WEAKEN), be\u00adcause we always allow the world to contain additional islands not \nmentioned in C.L. Yet weakening does not hold in the separation judgment, where the island laws also \nrepresent implicit postcondi\u00adtions, which induce proof obligations in rule ISL-UPD (see below). The rules \nC-MONO to L\u00a8 OB are taken directly out of LSLR. Rule C-MONO says that, due to time monotonicity, any \nproposi\u00adtion true now is still true later. Rule C-WEAKEN allows proving a proposition true one step later \nby proving it in a context where all later assumptions have been moved to the present (notation < C, \nde.ned in Figure 3). This rule is actually derivable from C-MONO and the law of distributivity of C over \n. (given in the next line). Like in LSLR, the L \u00a8 OB rule provides a simple induction princi\u00adple over \nstep levels: if, under the assumption that P is true later, we can prove P now, then by induction P is \ntrue now. See Section 9.3 for an example of its use. The next couple of rules allow introduction of the \n0-modality for different kinds of monotone propositions. According to the 0-INTRO rule, P is monotone \nif we can prove it without any po\u00adtentially non-monotone assumption ( C removes all but 0 d as\u00adsumptions \nfrom the context, cf. Figure 3). Absolute propositions are always monotone, and so is well-formedness \nof terms (rules 0-INTRO-ABS and 0-INTRO-TERM). Conversely, a 0 d proposi\u00adtion is of course true in the \ncurrent world (0-ELIM). Finally, rule C0-SWAP asserts that the two modalities commute. The rules ELEM \nand ELEM-\u00b5 de.ne inhabitation of relations. A recursive relation is equivalent to its expansion. The \nnext rules deal with populations. Because populations are required to grow monotonically in the model, \nmembership in one is a monotone property (rule POP-MONO see Section 9.2 for a good example of its use). \nFurthermore, if A represents the current population of an island, then the island s population law B \nholds for it (rule POP-LAW). Rule POP-SNAP allows us to take an absolute snapshot a of the current population \nof an island (intuitively, we can do this because the population of an island remains constant under \ntime and width extension of its surrounding world). An island proposition . a.(B, H) can only be introduced \nif an island with population and heap laws equivalent to B and H exists in the context (rule .-INTRO). \nConversely, eliminating an island proposition (rule .-ELIM) requires a case distinction: either (1) it \ntalks about an island p that we do not know yet, in which case we just add p to the island context, or \n(2) it refers to one of the islands in L, in which case said island must have population and heap laws \nequivalent to B and H. The next four rules in Figure 8 are but a small sample of the many rules for heap \nrelation entailments H = J. Many more rules appear in the appendix [17], and most of those are completely \nstan\u00addard rules from intuitionistic separation logic. The rules we show here are interesting in that \nthey involve the atomic propositions of the form 0P . The .rst rule says that any 0P that we can prove \nin the main judgment may serve as the conclusion of an entailment. The second rule says that if 0P is \ntrue, it is true of the empty heap. The third rule enables 0P to be shifted between the context and the \nantecedent of the entailment. The fourth rule establishes that when e1 points to e2, they must both be \nvalues, and e1 must be a location.  C{H} e1 e2 {R} VV C B[A/a] C.L = p . a.(B, H) C p . A C B[A/a] \n' C ' C ' C ' C, p, p . a.(B, H ),p = A {H} e1 e2 {R} = C,p = AH *H[A/a](e1,e2) ..R ISL-NEW ISL-UPD \nC{H} e1 e2 {R} C{H} e1 e2 {R} '' *'*' ''' 0 ' 0 C{H} e e {R}C e1 e C e2 e C{H} e e {R}C ee1 C ee2 \n12 12 1212 EXPAND REDUCE C{H} e1 e2 {R} C{H} e1 e2 {R} C1C2 '' '' C{H} e1 w-.1 e {H ' }C, C1 {H ' } \ne e2 {R} C{H} e2 w-.2 e {H ' }C, C2 {H ' } e1 e {R} 11 22 STEP-L STEP-R C{H} e1 e2 {R} C{H} e1 e2 \n{R} C1C2 '' '' '''' C{H1} e1 w-.1 e {H }C {H2} e2 w-.2 e {H } < C, C1, C2 {H * H } e e {R} 11221212 \nSTEP-LR C{H1 * H2} e1 e2 {R} ' C HH C{H ' } e1 e2 {R}C OP C{H * OP } e1 e2 {R} SEP-ENTAIL SEP-CUT \nC{H} e1 e2 {R} C{H} e1 e2 {R} C, OP {H} e1 e2 {R} C{H1} e1 e2 {R}C {H2} e1 e2 {R}C, X{H} e1 e2 \n{R}O-SHIFT SEP-. SEP-. C{H * OP } e1 e2 {R} C{H1 . H2} e1 e2 {R} C {.X .H} e1 e2 {R} C {H} e C ' w-.i \ne ' {H ' } C C e 1 e ' {H} e w-.i e ' {H} UNROLL C C e . Vali C A . Vali C ' = x, x . Vali {H} E[ref \ne] C ' w-.i E[x] {H * x '.i e * O(x /. A)} ALLOC C C H e1 '.i e2 {H} E[!e1] w-.i E[e2] {H} DEREF C C \ne2 . Vali {H * e1 '.i e ' 2} E[e1 := e2] w-.i E[()] {H * e1 '.i e2} ASSIGN Figure 9. Key Inference Rules \nof LADR (Part 2): Separation and Small-Step Judgments The remaining rules of the main judgment deal with \nrelatedness of terms. The .rst three (.-EXPAND, .-REDUCE, and .-UNROLL) consider closure of relatedness \nunder pure conversion, and are again straight out of LSLR. As they are essentially pure versions of the \nseparation judgment rules EXPAND, REDUCE, and STEP-LR, we refer the reader to the discussion of those \nrules below. Rules .-RETURN and .-BIND can be regarded as monadic rules for reasoning about computations \nin a sequentialized manner. The former represents the base case: if two values are related by R, then \nthey are also related by .R. The latter is useful when we have terms in evaluation position (e1 and e2 \nin the rule) that are not syntactically reducible to values, but that we know belong to .S for some S. \nThe rule allows us to invent variables to represent their values, and to assume the variables are related \nby S in a future world. See Sections 8 and 9.2 for examples where .-BIND is key. In order to reason about \nterms involving impure reduction steps, rule .-IMPURE enablesusto switchto theseparationjudgment.The \nheap laws from all islands in the island context are converted (via separating conjunction) into a precondition, \nunder which we pro\u00adceed to prove the terms related. Since the heap laws may mention the current population, \nwe also pick fresh absolute a s to represent the current populations of all the islands and instantiate \nthe heap laws with those a s. This leads us to the separation judgment, de.ned in Figure 9. Rule ISL-NEW \nallows us to extend the world (widthwise) with a new island. It requires us to pick an initial population \nA and prove that it obeys the population law. Two terms can then be proven related under the assumption \nthat the new island exists and that A is its (current) population. Rule ISL-UPD allows us to prove a \nseparation judgment by switching back to the main judgment, at which point we have the opportunity to \nadvance to a future world by extending the popu\u00adlation on any island. For each island, the respective \nnew popula\u00adtion A must be shown to be a superset of the current one, and it must obey the corresponding \npopulation law. The world is then up\u00addated with the new populations, by removing all assumptions about \nthe previous world from the context (courtesy of the C notation), and adding the knowledge about the \nnew populations. In this new world, the heap laws of all known islands (joined again by a sepa\u00adrating \nconjunction) must be entailed by the precondition H. The main purpose of the separation judgment is to \nenable us to prove the equivalence of terms by symbolically stepping through their evaluations. Rules \nEXPAND, STEP-L, and STEP-R describe closure of the separation judgment under expansion. REDUCE de\u00adscribes \nclosure under reduction, as long as the reduction takes zero serious steps. Rule STEP-LR is another rule \nfor closure under ex\u00adpansion, but since both sides expand with a serious step, we can drop the C s from \nany CP assumptions in the context. See Sections 8 and 9.3 for examples of how this is critically useful. \nAll three STEP rules use the auxiliary stepping judgment to per\u00adform the actual step and update the heap \nassertion H accordingly. The only slightly unusual rule of this judgment is ALLOC: it pro\u00advides a means \nof picking a set A of well-formed values with re\u00adspect to which the variable x (representing the new \nlocation) is assumed to be fresh in the postcondition. This is reminiscent of Aydemir et al. s co.nite \nquanti.cation style of reasoning about fresh identi.ers in mechanized metatheory [5], for although A \nis not necessarily .nite, its absoluteness suf.ces to show it contains .nitely many locations. The freshness \npostcondition is useful, e.g., when reasoning about equality of locations. See the name generator example \nin Section 4.1 of our online appendix [17] for details. The remaining rules of the separation judgment \nare straightfor\u00adward: SEP-ENTAIL is one half of the rule of consequence. (We have not needed the other \nhalf, but it would be easy to prove.) With rule SEP-CUT, derivable monotone propositions can be cut into \nthe heap precondition, and with rule 0-SHIFT they can be shifted back. The two remaining rules are standard \nseparation logic rules.  8. LADR: Soundness of the Logical Relation We now present our main results \nconcerning soundness of the logical relation with respect to contextual equivalence. The .rst step is \nto de.ne a logical equivalence judgment: De.nition 8.1 (Logical Equivalence Judgment) Given G; S f e1 \n: t and G; S f e2 : t , with G= a, x : t and S= l : s, de.ne def G; S f e1 log e2 : t = X ; R; L; Pf \n(.1e1,.2e2) .E[t]. where .i = a.ai,x.xi X = a1,a2,x1,x2 R = r, p . = a . r L = p . a.(a ={(l, l)}, .y1,y2.l'.1 \ny1 * l'.2 y2 * 0C(y1,y2) .V[s]) P = r : Type, (x1,x2) .V[t]., l . Val1,l . Val2 The basic building blocks \nof the soundness proof are the com\u00adpatibility lemmas [30], which state that the logical relation is closed \nunder each of the language s constructs. Together, they yield the fundamental property of the logical \nrelation and the fact that the logical relation is a congruence wrt. language contexts C. In contrast \nto ADR, our proofs for compatibility lemmas are much shorter, because we can express them, at a much \nhigher level of ab\u00adstraction, in terms of the proof rules we have given in Section 7. As an example, \nwe show the compatibility lemma for dereferencing, which was multiple pages long in ADR. See the online \nappendix for the proofs of the other state-related compatibility lemmas [17]. Lemma 8.2 (Compatibility: \nDereference) If G; S f e1 log e2 : ref t , then G; S f !e1 log !e2 : t . Proof: Unfolding the de.nition \nof log , this boils down to de\u00adriving C0 f (e1,e2) .E[ref t ]. . (!e1, !e2) .E[t]. for some C0 in which \ne1 . Term1 and e2 . Term2. Using rule L-WEAKEN, we may assume that C0.L = \u00d8. Starting with rule .-BIND, \nwe need to show C1 f (!x1, !x2) .E[t ]., where C1 = C0,x1,x2, (x1,x2) .V[ref t ].. The latter tells us \nthat . a.(B, H), where H = .y1,y2.x1 '.1 y1 * x2 '.2 y2 * 0C(y1,y2) .V[t ].. With the help of rule .-ELIM \nand the fact that our L is empty, we can extend C1 to C2 = C1, p, p . a.(B, H) and then use rule .-IMPURE \nto enter the separation judgment. Here we are required to show {H} !x1 !x2 {V[t ].}. We .rst extend \nC2 with y1,y2,C0(y1,y2) .V[t ]. (using rules SEP-., 0-SHIFT, and C0-SWAP). By combining rules DEREF and \nSTEP-LR, the proof goal reduces to {H} y1 y2 {V[t ].}, but under a context where C is removed from the \nassumption concerning the relatedness of y1 and y2. We now switch back to the regular judgment using \nrule ISL-UPD, without actually updating any island. Consequently, we need to show (y1,y2) . .V[t ]., \nwhich follows from the assump\u00adtion in the context and rules .-RETURN and 0-ELIM. Theorem 8.3 (Fundamental \nProperty) If G; S f e : t , then G; S f e log e : t . Theorem 8.4 (Congruence) If G; S f e1 log e2 : \nt and f C : (G; S; t) . (G ' ;S ' ; t ' ), then f C[e1] log ' G ' ;S ' C[e2]: t . Given the Congruence \nTheorem, the only missing piece in the soundness proof is adequacy of the logical relation [30], i.e., \nthe fact that if two closed terms are logically related, then they co\u00adterminate under any (well-formed) \nheap. For this lemma we need to reason directly in the model, and the proof follows the one in ADR; details \nare in the online appendix [17]. Lemma 8.5 (Adequacy) If \u00b7;S f e1 log e2 : t and f h :S, then (h; e1). \niff (h; e2) .. Theorem 8.6 (Soundness w.r.t. Contextual Equivalence) If G; S f e1 log e2 : t , then G; \nS f e1 ctx e2 : t. 9. Examples In this section, we demonstrate how to use LADR to prove some interesting \ncontextual equivalences. We can use LADR to prove all the examples in ADR, save for one which we discuss \nin Section 10. 9.1 Twin Abstraction Recall the twin abstraction example from Section 3.1: t = .a, \u00df. \n(unit . a) \u00d7 (unit . \u00df) \u00d7 (a \u00d7 \u00df . bool) C = let x = ref 0 in pack int, int, \\..++x,. .++x, .y.[ ]) as \nt e1 = C[fst y = snd y] e2 = C[false] To prove e1 and e2 equivalent, we want to show f (e1,e2) .E[t ], \nor, by .-IMPURE, f{0T} e1 e2 {V[t ]}. By rules STEP-LR, ALLOC and EXPAND, we need to show '' {x1 '.1 \n0 * x2 '.2 0} e1[x1/x] e2[x2/x] {V[t]} where e1 ' and e2 ' are the bodies of the respective let expressions \nand we omit the pure heap assertions produced by ALLOC. Using rule ISL-NEW we introduce an island p . \na.(B, H), whose population is a .nite mapping of the symbols generated so far (which will be the same \non both sides) to the respective abstract type they inhabit, i.e., 1 for a and 2 for \u00df: B = .n. funmap(a, \nn, 2) H = .n. x1 '.1 n * x2 '.2 n * 0maxdom(a, n) The population law B states that the population a is \nthe relational map of a function from {1,...,n} to {1, 2}, for some n. The heap law H then veri.es that \nthe states of x1 and x2 always are in sync with the maximum n in the domain of a. (The absolute predicates, \nfunmap and maxdom, are easy to de.ne in LADR.) Given A = \u00d8 for the initial population, it is easy to \nverify that B[A/a] holds. Both e1' [x1/x] and e2' [x2/x] are values, so we want to apply rule ISL-UPD \nimmediately to get back into the pure judgment, i.e., prove (e1' [x1/x],e2' [x2/x]) .V[t ] under the \nisland context p . a.(B, H). We instantiate that rule with A = \u00d8 as before, and so the only new thing \nto prove is x1 '.1 0 * x2 '.2 0 = H[\u00d8/a], which involves the straightforward proof of 0maxdom(\u00d8, 0). \nNow, we unroll the de.nition of V[t ] = V[.a..\u00df. ] and pick Ra =(x1 . Constint,x2 . Constint).x1 = x2 \n. (x1, 1) . p R\u00df =(x1 . Constint,x2 . Constint).x1 = x2 . (x1, 2) . p We need to prove Ra : Type and \nR\u00df : Type. Both proper\u00adties follow straightforwardly from rule POP-MONO. Now let . = a.Ra,\u00df.R\u00df . By de.nition \nof V[ \u00d7 ] ., we have to show: 1. Cf (..++x1,. .++x2) .V unit . a]. 2. Cf (..++x1,. .++x2) .V[ unit . \n\u00df]. 3. Cf (.y.fst y = snd y, .y.false) .V[a \u00d7 \u00df . bool].  where C = x1,x2; p; p. a.(B, H); 0(x1 . Val1),0(x2 \n. Val2).  For (1), we unroll the de.nition of V[ . ] ., and apply the introduction rules for 0, . and \n., producing the goal ((..++x1) y1, (..++x2) y2) . .V[a]. = Ra with (y1,y2) .V[unit]. in the assumptions. \nBy .-EXPAND and .-IMPURE we get the name a = p for the current population. By .-INTRO, we have to show: \n{x1 '.1 n * x2 '.2 n * 0maxdom(a, n)} ++x1 ++x2 {Ra} We can step through both computations simultaneously \nusing rule STEP-LR, record n +1 r 0 n ' in the context (for a freshly bound variable n '), and reach: \n'' '' {x1 '.1 n * x2 '.2 n * 0maxdom(a, n)} n n {Ra} Now that the new symbols have been generated, we \nupdate the island with the new population A = a .{(n ' , 1)}, using rule ISL-UPD. To do so, we .rst have \nto show p . A, which is easy given p = a. Then we have to show that the population law still holds, i.e., \n.n '' . funmap(A, n '' , 2). This is easy to derive by picking n '' = n ' and using the assumption maxdom(a, \nn). Likewise, we have to prove that the .nal heap assertion entails the heap law H[A/a] under the assumption \np = A. Choosing n ' for the existential variable, this reduces to showing maxdom(A, n ' ), which is easy. \nThe .nal step in this part is to show (n ' , 1) ..Ra. Unfolding the de.nition, this follows directly \nfrom rule .-RETURN, given that the updated population p = A = a .{(n ' , 1)}. For part (2) we proceed \nanalogously, the only difference being that we choose A = a .{(n ' , 2)} for the new population. Part \n(3) is relatively straightforward now. We start as before, yielding the goal ((.y.fst y = snd y) y1, \n(.y.false) y2) . .V[bool] where (y1,y2) . We can unfold the de.nition V[a \u00d7 \u00df].. of V[a \u00d7 \u00df]. and eliminate \nthe top-level existential bindings, ''' ''' thus producing the assumptions y1=\\y1,y 1 ), y2=\\y2,y 2 ) \nand ' ' '''' ' ' '''' (y1,y 2) . Ra, (y1 ,y 2 ) . R\u00df for some fresh y1,y 2,y 1 ,y 2 . Given this, y1 \ncan be replaced by the pair \\y1' ,y 1 '' ), and by .-EXPAND we are left to prove (y1 ' = y1 '' , false) \n. .V[bool]. At this point, the proof essentially boils down to the absolute proposition ' ' '' ''' .a,y \n,y '' .B . (y, 1) . a . (y, 2) . a . y = y which is straightforward to prove given the de.nition of B. \nWe can then conclude that y1 ' = y1 '' reduces to false, and we are done.  9.2 Irreversible State Change \nConsider Pitts and Stark s awkward example [31], two equivalent functions of type (unit . unit) . int: \ne1 = let x = ref 0 in .f.(x := 1; f \\);!x) e2 = .f.(f \\); 1) In e1, the local reference x can be in only \ntwo states: either 0, before the function f has been called for the .rst time, or 1 after that event. \nHowever, once it has changed to 1, it will never change back, not even through reentrant calls inside \nthe callback f. In the proof we can represent the two states by an island p with B = a .{1} H =(0a =\u00d8* \nx'.1 0) . (0a ={1}* x'.1 1) Note that we encode the state 0 by the empty set, because popula\u00adtions can \nonly grow monotonically. The proof .rst proceeds somewhat similarly to the previous one, until we reach \nthe point of showing the function bodies equivalent: {H} (x := 1; f1 \\);!x) (f2 \\); 1) {V[int]} where \n(f1,f2) .V[unit . unit]. Here, we apply rule SEP-.. In either case, we step forward the computations \nuntil the calls to f1 and f2 both cases will now have the heap assertion x'.1 1. Atthispoint,weapply \nISL-UPD toupdatethepopulationto {1} and get back into the pure judgment. We can now prove 0(1 . p) using \nrule POP-MONO, and cut that into the context. Then, we use .-BIND to bind the results of the calls to \nvariables y1, y2, and proceed with proving ((y1;!x), (y2; 1)) .E[int]. We apply .-IMPURE to return into \nthe separation judgment and .nish the proof by again applying SEP-.. In the .rst subcase, the new hypotheses \na =\u00d8 and a = p will yield a contradiction with 0(1 . p), which remained as an assumption in the context \nby virtue of its being 0 d. The other subcase tells !x r 1 right away.  9.3 Landin s Knot We want to \nprove that Landin s knot the construction of a .xed\u00adpoint using backpatching works. That is, we want \nto prove the equivalence of the following two expressions of type t1 . t2: e1 = let z = ref (.x..) in \n(z := (.x.let f =!z in e); !z) e2 = .x f(x).e where .x is a standard call-by-value .xed-point operator, \nwhich can be de.ned in our language as follows: .x f(x).e = .x.(unroll v) vx where v = roll .f ' .(.f..x.e)(.x.(unroll \nf ' ) f ' x) We need to show f (e1,e2) .E[t1 . t2]. Let F be the function that z ends up being assigned. \nThere are three interesting points in the proof: 1. To record the fact that z will contain F forever \nafter the assign\u00adment, we introduce an island with the heap law H = z'.1 F (the populations are not relevant \nfor this proof). 2. After that, we invoke the L \u00a8 OB rule to prove that F and e2 (the results of evaluating \ne1 and e2) are related in V[t1 . t2] under the inductive assumption C(F, e2) .V[t1 . t2]. 3. Further \ninto the proof, we reach a point where we have to show  {z'.1 F } (let f =!z in e[y1/x]) e2(y2) {V[t2]} \nfor some (y1,y2) .V[t1]. At this point, both computations are ready to make a serious step, so we can \napply rule STEP-LR, using DEREF on the left and UNROLL on the right, to reduce the goal to proving {z'.1 \nF } e[F/f][y1/x] e[e2/f][y2/x] {V[t2]} under a < d context, i.e., where the C-operator has been removed \nfrom the L \u00a8 OB-inductive assumption relating F and e2. Finally, we can apply the rules ISL-UPD and .-REDUCE \n(back\u00adwards) to \u00df-expand the two terms to (.f..x.e)(F )(y1) and (.f..x.e)(e2)(y2). The result then follows \nfrom the Fundamen\u00adtal Property (which says that .f..x.e is related to itself), together with the relatedness \nof (F, e2) and (y1,y2). 10. Conclusion and Related Work In this paper, we have presented a relational \nmodal logic, LADR, for reasoning about program equivalence in a language with higher types, type abstraction, \nrecursive types, and (local) higher-order state. To our knowledge, this is the .rst logic for reasoning \nsyntac\u00adtically about contextual equivalence of programs in such a rich lan\u00adguage. The model of the logic \nis based closely on the step-indexed Kripke logical relation developed recently by Ahmed, Dreyer, and \nRossberg [2], but by using the high-level proof rules of the logic, we can abstract away many of the \nmessy details of the ADR model.  Comparison to ADR Before relating LADR to ADR in detail, let us begin \nby noting that there is a huge amount of prior work on using logical relations to reason about contextual \nequivalence in higher-order languages with some subset of recursive types, exis\u00adtential types, and local \nstate (e.g., [37, 30, 31, 23, 8, 1, 10]). There has also been signi.cant work on using bisimulations \nfor the same purpose (e.g., [43, 21, 41, 39, 22]). We refer the reader to [2] for detailed comparisons \nbetween the ADR model and previous ap\u00adproaches. More recently, Sumii has developed an environmental bisimulation \nmethod that handles all the examples in ADR and more [42], although some of them involve tricky proofs \nthat reason explicitly about induction on program contexts. We are very in\u00adterested in exploring the \nconnection between step-indexed Kripke logical relations and environmental bisimulations, and hope that \nthe present work may serve as a stepping stone to a uni.ed, logical understanding of both methods. It \nis dif.cult to precisely compare the expressiveness of LADR with the original ADR model, or indeed to \nprecisely compare the expressiveness of any two methods developed in this area (includ\u00ading all the aforementioned \nlogical relations and bisimulation tech\u00adniques). It is usually impossible to pinpoint exactly what class \nof equivalences can be proven in any model/logic, partly because it depends on what one means by can \nbe proven . For instance, many of the bisimulation techniques are touted as being complete with respect \nto contextual equivalence, but completeness per se gives no indication of whether a technique is effective \nat proving anything. (After all, contextual equivalence is complete with respect to itself!) For this \nreason, the literature tends to be very example-driven, with each paper attempting to handle all or most \nof the previously pro\u00adposed examples, as well as some new class of examples. The ADR paper, to which \nsome of the present authors con\u00adtributed, presented a whole range of new and interesting examples (concerning \nstateful ADTs), precisely in order to better suggest what the ADR model was capable (and incapable) of. \nBut ADR, being state-of-the-art, is also capable of handling the other stan\u00addard examples from the literature, \nsuch as the Meyer-Sieber exam\u00adples [24]. For the present paper, our aim was for LADR to handle all the \nexamples from the ADR paper (that ADR can handle) with the exception of one (described below), and for \nthe LADR proofs to be much shorter and cleaner (which they are). Moreover, like ADR, LADR also handles \nthe other well-known examples from the liter\u00adature (e.g., those in [24, 31]). The one example that the \nADR paper shows how to prove, but that LADR (we believe) cannot, is the callback with lock example, based \non the reentrant callback example of Banerjee and Naumann [6]. The ADR proof for that example is, one \nmight say, rather hacky it messes with the steps in order to fake a very poor man s temporal logic. It \nis therefore not expressible in our logic, which treats step-indices in a more abstract way. As the authors \nof ADR note, the proof was included in the paper primarily because it was surprising that the model was \ncapable of handling the example at all. However, the proof is quite inelegant, and rather than develop \na method for expressing the ADR proof for callback with lock more abstractly, we are actively working \non developing an altogether different, cleaner proof for it. Our model of LADR is very similar to the \nADR model. The primary characteristics of the ADR model (namely, the treatment of populations and the \nuse of step-indexing to stratify the worlds) are essentially identical in both models. The differences \nbetween the models are minor ones aimed at simplifying unnecessary or overcomplicated aspects of the \nADR model. For example, the ADR model enforced separation of islands in worlds by attaching to each island \na store typing that explicitly listed the set of memory locations governed by that island. We instead \nde.ne the heap-world satisfaction relation (h1,h2 : W in Figure 5) separation-logic-style, i.e., there \nmust be some way of splitting up the heaps so that each disjoint pair of heaps satis.es a corresponding \nisland. We adopted this approach here because it seems to simplify the model and permits ownership transfer \nof locations between islands (although we are not yet sure how to exploit this feature). Another difference \nis that the ADR model was constructed from syntactically well-typed terms, whereas our present model \ndoes not make that restriction. We diverged from ADR on this point as an experiment, in order to see \nif the syntactic typing restriction in ADR was really necessary or was just cluttering up proofs. The \nshort answer is that, for the purpose of the ADR proofs, it is not necessary. That said, we know of some \nother examples where syntactic typing is a useful assumption (e.g., so that one can make use of syntactic \nproperties like canonical forms ). In any case, it seems straightforward to de.ne a variant of LADR that \nis restricted to well-typed terms, if so desired. Other Related Work Honsell, Mason, Smith, and Talcott \n[20] and Yoshida, Honda, and Berger [45] have proposed logics for reason\u00ading about higher-order programs \nwith local state, the former equa\u00adtional and the latter Hoare-style. Neither deals with type abstraction \nor the kinds of reasoning afforded by ADR s populations. Separation logic, a highly in.uential variant \nof Hoare logic for reasoning about programs with pointers, was originally developed by Reynolds, O Hearn, \nand others for low-level languages (see the survey in [38]). However, in recent years, variants of separation \nlogic have also been developed for modular veri.cation of OO languages [14, 28], as well as for languages \nwith higher types and/or higher-order state [11, 36, 26]. All of these approaches, however, essentially \nonly handle strong memory updates, not ML\u00adstyle reference types, which enjoy stronger invariants. A key \nidea in separation logic is the frame rule, which al\u00adlows one to use separating conjunction to frame-in \nadditional re\u00adsources to the pre-and post-conditions of Hoare triples. O Hearn, Yang, and Reynolds [27] \nshowed how to extend the original (.rst\u00adorder) frame rule to second-order, and subsequently Birkedal, \nTorp-Smith, and Yang [11] discovered how to prove higher-order frame rules sound by means of a possible-world \nsemantics for speci.ca\u00adtions. Their approach is to effectively bake the frame rule into the interpretation \nof Hoare triples. In LADR, the model of our sepa\u00adration judgment involves a similar baking-in of the \nframe rule. Birkedal and Yang [12] devised a relational model of separation logic, for a language with \nhigher types but .at store. Their model was explicitly intended as a .rst step towards a logic for stateful \nADTs. However, they only developed the model, not a correspond\u00ading logic for syntactic reasoning. They \nproposed, however, that a logic for syntactic reasoning might employ ideas from Yang s ear\u00adlier work \non relational separation logic [44], as we have done here. Concurrently with our work, Hobor, Dockins, \nand Appel [19] have investigated a more abstract description of step-indexed mod\u00adels by means of certain \nsection-retraction pairs. Their squash and unsquash functions seem to be at least super.cially similar \nto our C and < operations on worlds, respectively, so it would be interesting to see if their approach \ncan be usefully applied to give a simpler account of the (L)ADR models. We believe there are some non\u00adtrivial \nchallenges because propositions in the (L)ADR models are required to be monotone with respect to time \nand width extension; on the face of it, Hobor et al. s setup does not accommodate such monotonicity requirements \ndirectly. Also concurrently with our work, Pilkiewicz and Pottier [29] propose a way to reason about \nmonotonic state changes in an expressive capability type system. The basic capability type system (borrowed \nfrom Chargu\u00b4 eraud and Pottier [13]) incorporates strong references, whose types can be updated via assignment; \ncapabilities are used to restrict sharing of such strong references for the purpose of ensuring soundness. \nThe idea of Pilkiewicz and Pottier is that it is sound for multiple clients to share references if the \nstate evolves in a monotonic way and clients only rely on such monotonic state changes. Monotonic state \nchanges are described using so-called fates and laws, which are related to our use of populations and \nlaws. Using this idea of monotonic state change, and by applying a generalized version of Pottier s anti-frame \nrule for hiding local state [34, 35], Pilkiewicz and Pottier are able to give types that express the \nbehavior of the example programs considered in ADR. Pilkiewicz and Pottier s type system cannot, however, \nbe used to prove contextual equivalence of programs, and it has not yet been proven sound. Recently, \nSchwinghammer et al. have proven the anti-frame rule sound in a separation-logic setting [40], and there \nis hope that this result can be extended to a soundness proof of Pilkiewicz and Pottier s system, but \nthere are also some technical dif.culties ahead (e.g., modeling the generalized anti-frame rule).  We \nview logical relations and separation logic as largely com\u00adplementary tools, and the design of LADR is \n(we think) particularly interesting because it shows how both approaches can cooperate ef\u00adfectively within \none logic. Admittedly, our use of separation logic is fairly limited, but this is deliberate on our part \n(as a way of simpli\u00adfying matters at .rst). We are keen to explore ways of generalizing LADR to support \nricher forms of separation logic reasoning, and to explore further the connection with higher-order separation \nlogic. Acknowledgments The .rst author would like to thank Amal Ahmed for helpful conversations early \nin the development of this work. References [1] A. Ahmed. Step-indexed syntactic logical relations for \nrecursive and quanti.ed types. In ESOP, 2006. [2] A. Ahmed, D. Dreyer, and A. Rossberg. State-dependent \nrepresenta\u00adtion independence. In POPL, 2009. [3] A. Appel and D. McAllester. An indexed model of recursive \ntypes for foundational proof-carrying code. TOPLAS, 23(5):657 683, 2001. [4] A. Appel, P.-A. Melli`es, \nC. Richards, and J. Vouillon. A very modal model of a modern, major, general type system. In POPL, 2007. \n[5] B. Aydemir, A. Chargu\u00b4 eraud, B. C. Pierce, R. Pollack, and S. Weirich. Engineering formal metatheory. \nIn POPL, 2008. [6] A. Banerjee and D. A. Naumann. State based ownership, reentrance, and encapsulation. \nIn ECOOP, 2005. [7] N. Benton. Simple relational correctness proofs for static analyses and program transformations. \nIn POPL, 2004. [8] N. Benton and B. Leperchey. Relational reasoning in a nominal semantics for storage. \nIn TLCA, 2005. [9] N. Benton and N. Tabareau. Compiling functional types to relational speci.cations \nfor low level imperative code. In TLDI, 2009. [10] L. Birkedal, K. St\u00f8vring, and J. Thamsborg. Realizability \nsemantics of parametric polymorphism, general references, and recursive types. In FOSSACS, 2009. [11] \nL. Birkedal, N. Torp-Smith, and H. Yang. Semantics of separation\u00adlogic typing and higher-order frame \nrules. LMCS, 2(5:1), 2006. [12] L. Birkedal and H. Yang. Relational parametricity and separation logic. \nLMCS, 4(2:6), 2008. [13] A. Chargu\u00b4 eraud and F. Pottier. Functional translation of a calculus of capabilities. \nIn ICFP, 2008. [14] W.-N. Chin, C. David, H. H. Nguyen, and S. Qin. Enhancing modular OO veri.cation \nwith separation logic. In POPL, 2008. [15] R. Dockins, A. W. Appel, and A. Hobor. Multimodal separation \nlogic for reasoning about operational semantics. In MFPS, 2008. [16] D. Dreyer, A. Ahmed, and L. Birkedal. \nLogical step-indexed logical relations. In LICS, 2009. [17] D. Dreyer, G. Neis, A. Rossberg, and L. Birkedal. \nA relational modal logic for higher-order stateful ADTs (Technical appendix), 2009. URL: http://www.mpi-sws.org/~dreyer/papers/ladr/. \n[18] A. Hobor, A. Appel, and F. Zappa Nardelli. Oracle semantics for concurrent separation logic. In \nESOP, 2008. [19] A. Hobor, R. Dockins, and A. Appel. A theory of indirection via approximation. In POPL, \n2010. [20] F. Honsell, I. A. Mason, S. Smith, and C. Talcott. A variable typed logic of effects. Inf. \nComput., 119(1):55 90, 1995. [21] V. Koutavas and M. Wand. Small bisimulations for reasoning about higher-order \nimperative programs. In POPL, 2006. [22] S. B. Lassen and P. B. Levy. Typed normal form bisimulation \nfor parametric polymorphism. In LICS, 2008. [23] P.-A. Melli`Recursive polymorphic types and es and J. \nVouillon. parametricity in an operational framework. In LICS, 2005. [24] A. R. Meyer and K. Sieber. \nTowards fully abstract semantics for local variables. In POPL, 1988. [25] H. Nakano. A modality for recursion. \nIn LICS, 2000. [26] A. Nanevski, A. Ahmed, G. Morrisett, and L. Birkedal. Abstract predicates and mutable \nADTs in Hoare Type Theory. In ESOP, 2007. [27] P. W. O Hearn, H. Yang, and J. C. Reynolds. Separation \nand informa\u00adtion hiding. In POPL, 2004. [28] M. Parkinson and G. Bierman. Separation logic, abstraction \nand inheritance. In POPL, 2008. [29] A. Pilkiewicz and F. Pottier. The essence of monotonic state. Submit\u00adted \nfor publication, 2009. [30] A. Pitts. Typed operational reasoning. In B. C. Pierce, editor, Ad\u00advanced \nTopics in Types and Programming Languages, chapter 7. MIT Press, 2005. [31] A. Pitts and I. Stark. Operational \nreasoning for functions with local state. In HOOTS, 1998. [32] A. M. Pitts. Relational properties of \ndomains. Inf. Comput., 127:66 90, 1996. [33] G. Plotkin and M. Abadi. A logic for parametric polymorphism. \nIn TLCA, 1993. [34] F. Pottier. Hiding local state in direct style: a higher-order anti-frame rule. In \nLICS, 2008. [35] F. Pottier. Generalizing the higher-order frame and anti-frame rules. Unpublished, 2009. \n[36] B. Reus and J. Schwinghammer. Separation logic for higher-order store. In CSL, 2006. [37] J. C. \nReynolds. Types, abstraction, and parametric polymorphism. Information Processing, 1983. [38] J. C. Reynolds. \nSeparation logic: A logic for shared mutable data structures. In LICS, 2002. [39] D. Sangiorgi, N. Kobayashi, \nand E. Sumii. Environmental bisimula\u00adtions for higher-order languages. In LICS, 2007. [40] J. Schwinghammer, \nH. Yang, L. Birkedal, F. Pottier, and B. Reus. A semantic foundation for hidden state. Submitted for \npublication, 2009. [41] K. St\u00f8vring and S. Lassen. A complete, co-inductive syntactic theory of sequential \ncontrol and state. In POPL, 2007. [42] E. Sumii. A complete characterization of observational equivalence \nin polymorphic lambda-calculus with general references. In CSL, 2009. [43] E. Sumii and B. Pierce. A \nbisimulation for type abstraction and recursion. JACM, 54(5):1 43, 2007. [44] H. Yang. Relational separation \nlogic. TCS, 375(1 3):308 334, 2007. [45] N. Yoshida, K. Honda, and M. Berger. Logical reasoning for higher\u00adorder \nfunctions with local state. LMCS, 4(4:2), 2008.    \n\t\t\t", "proc_id": "1706299", "abstract": "<p>The method of logical relations is a classic technique for proving the equivalence of higher-order programs that implement the same observable behavior but employ different internal data representations. Although it was originally studied for pure, strongly normalizing languages like System F, it has been extended over the past two decades to reason about increasingly realistic languages. In particular, Appel and McAllester's idea of step-indexing has been used recently to develop syntactic Kripke logical relations for ML-like languages that mix functional and imperative forms of data abstraction. However, while step-indexed models are powerful tools, reasoning with them directly is quite painful, as one is forced to engage in tedious step-index arithmetic to derive even simple results.</p> <p>In this paper, we propose a logic LADR for equational reasoning about higher-order programs in the presence of existential type abstraction, general recursive types, and higher-order mutable state. LADR exhibits a novel synthesis of features from Plotkin-Abadi logic, G&#246;del-L&#246;b logic, S4 modal logic, and relational separation logic. Our model of LADR is based on Ahmed, Dreyer, and Rossberg's state-of-the-art step-indexed Kripke logical relation, which was designed to facilitate proofs of representation independence for \"state-dependent\" ADTs. LADR enables one to express such proofs at a much higher level, without counting steps or reasoning about the subtle, step-stratified construction of possible worlds.</p>", "authors": [{"name": "Derek Dreyer", "author_profile_id": "81100381796", "affiliation": "MPI-SWS, Saarbr&#252;cken, Germany", "person_id": "P1911065", "email_address": "", "orcid_id": ""}, {"name": "Georg Neis", "author_profile_id": "81442619526", "affiliation": "MPI-SWS, Saarbr&#252;cken, Germany", "person_id": "P1911066", "email_address": "", "orcid_id": ""}, {"name": "Andreas Rossberg", "author_profile_id": "81100550426", "affiliation": "MPI-SWS, Saarbr&#252;cken, Germany", "person_id": "P1911067", "email_address": "", "orcid_id": ""}, {"name": "Lars Birkedal", "author_profile_id": "81100622053", "affiliation": "IT University of Copenhagen, Copenhagen, Denmark", "person_id": "P1911068", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706323", "year": "2010", "article_id": "1706323", "conference": "POPL", "title": "A relational modal logic for higher-order stateful ADTs", "url": "http://dl.acm.org/citation.cfm?id=1706323"}