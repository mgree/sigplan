{"article_publication_date": "01-17-2010", "fulltext": "\n Higher-Order Multi-Parameter Tree Transducers and Recursion Schemes for Program Veri.cation Naoki Kobayashi \nNaoshi Tabuchi Hiroshi Unno Tohoku University Tohoku University Tohoku University koba@ecei.tohoku.ac.jp \ntabee@kb.ecei.tohoku.ac.jp uhiro@kb.ecei.tohoku.ac.jp Abstract We introduce higher-order, multi-parameter, \ntree transducers (HMTTs, for short), which are kinds of higher-order tree trans\u00adducers that take input \ntrees and output a (possibly in.nite) tree. We study the problem of checking whether the tree generated \nby a given HMTT conforms to a given output speci.cation, provided that the input trees conform to input \nspeci.cations (where both in\u00adput/output speci.cations are regular tree languages). HMTTs sub\u00adsume higher-order \nrecursion schemes and ordinary tree transduc\u00aders, so that their veri.cation has a number of potential \napplications to veri.cation of functional programs using recursive data struc\u00adtures, including resource \nusage veri.cation, string analysis, and ex\u00adact type-checking of XML-processing programs. We propose a \nsound but incomplete veri.cation algorithm for the HMTT veri.cation problem: the algorithm reduces the \nveri.ca\u00adtion problem to a model-checking problem for higher-order recur\u00adsion schemes extended with .nite \ndata domains, and then uses (an extension of) Kobayashi s algorithm for model-checking recursion schemes. \nWhile the algorithm is incomplete (indeed, as we show in the paper, the veri.cation problem is undecidable \nin general), it is sound and complete for a subclass of HMTTs called linearHMTTs. We have applied our \nHMTT veri.cation algorithm to various pro\u00adgram veri.cation problems and obtained promising results. Categories \nand Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; F.3.1 [Logics and \nMeaning ofPrograms]: Specifying and Verifying and Reasoning about Pro\u00adgrams General Terms Languages, \nVeri.cation 1. Introduction Kobayashi [20] has recently proposed a veri.cation method for higher-order \nfunctional programs based on Ong s decidability re\u00adsult on model-checking recursion schemes [32]. A higher-order \nre\u00adcursion scheme (recursion scheme, for short) is a grammar for gen\u00aderating a (possibly in.nite) tree. \nIt is an extension of regular tree grammars, where non-terminal symbols can take trees and higher\u00adorder \nfunctions on trees as parameters. For example, the follow\u00ading grammar G0 is an order-1 recursion scheme, \nwhere the non- Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. POPL 10, January 17 23, 2010, Madrid, Spain. Copyright c &#38;#169; 2010 ACM 978-1-60558-479-9/10/01. \n. . $10.00 a ca ba  c ... ... ... Figure 1. The tree generated by G0. terminal F takes a tree as an \nargument. S . F c Fx . a x (F (b x)) Here, each non-terminal has exactly one rewrite rule. By in.nitary \nrewriting of the start symbol S: S -. F c -. ac (F (bc)) -. \u00b7\u00b7\u00b7 , we obtain the in.nite tree shown in \nFigure 1. Ong [32] has shown that modal mu-calculus model-checking of recursion schemes ( Given a recursion \nscheme G and a modal mu-calculus formula ., does the tree generated by G satisfy .? ) is n-EXPTIME-complete \n(where n is the order of the recursion scheme G). The idea of Kobayashi s veri.cation method [20] is \nto translate a functional program into a recursion scheme that generates a tree whose paths represent \nall the possible event sequences of the program, so that temporal properties of the functional program \ncan be veri.ed by model-checking the recursion scheme. For example, consider the following program that \naccesses a .le (where * denotes a random boolean value): let x = open_in \"foo\" in let rec f() = if * \nthen close(x) else read(x); f() in f() It can be translated into the following recursion scheme G1: \nS . F e Fk . br (c k)(r (Fk)) Here, r, c, br and e denote a read operation, a close opera\u00adtion, a non-deterministic \nbranch, and program termination respec\u00adtively. The recursion scheme generates the tree shown in Figure \n2, which represents all the possible event (i.e. read, write, branch, and termination) sequences of the \nprogram. Kobayashi [20] ap\u00adplied the veri.cation method to resource usage veri.cation [14] (the problem \nof checking whether a program accesses resources such as .les in a valid manner), and showed that it \nis sound and complete for the simply-typed .-calculus extended with recur\u00adsion, resource creation/access \nprimitives, and booleans. The com\u00adpleteness follows intuitively because recursion schemes are es\u00adsentially \nterms of the simply-typed .-calculus with recursion and  br cr e br cr e ...  Figure 2. The tree generated \nby G1. tree constructors, so that they are already almost as expressive as the source language (of the \nsimply-typed .-calculus with re\u00adsources), and no information is lost by the translation. Although the \nmodel-checking of recursion schemes has extremely high worst\u00adcase time complexity (n-EXPTIME-complete \nfor the full modal mu-calculus), Kobayashi [18] constructed a model-checker for re\u00adcursion schemes, and \nshowed that it works well for realistic inputs. Thus, the veri.cation method based on recursion schemes \nseems to be one of the promising methods for higher-order program veri.\u00adcation. The main limitation of \nrecursion schemes from a program\u00adming language point of view is that there are tree constructors but \nnot destructors. Because of this limitation, one cannot naturally model programs operating over in.nite \ndata domains such as inte\u00adgers, lists, and trees.1 For example, consider the following function merge: \nlet rec merge x y= case xof []=> copy y | a::x => merge_a x y | b::y => merge_b x y and merge_a x y = \ncase y of [] => a::(copy x) | a::y => a::a::(merge x y ) | b::y => a::(merge_b y x) and merge_b x y = \ncase y of [] => b::(copy x) | a::y => b::(merge_a y x) | b::y => b::b::(merge x y ) and copy x = case \nxof []=> [] | a::x => a::(copy x ) | b::y => b::(copy y ) The function merge merges two lists consisting \nof a and b.It recursively destructs x and y, which cannot be expressed by a recursion scheme. Functions \noperating over recursive data struc\u00adtures are ubiquitous in functional programming, so that not be\u00ading \nable to handle them is a great limitation for the approach of model-checking functional programs by modeling \nthem as recur\u00adsion schemes. To relax the limitation above, we introduce an extension of re\u00adcursion schemes \ncalled higher-order, multi-parameter tree trans\u00adducers (HMTTs, for short). As in other (top-down) tree \ntransduc\u00aders [7, 8], we classify trees into input and output trees: only con\u00adstructors can be applied \nto output trees, and only destructors can be applied to input trees. Unlike in ordinary tree transducers, \nhowever, each function symbol (non-terminal) can take multiple input trees as arguments (as in the function \nmerge above). Furthermore, as in recursion schemes (and high-level tree transducers [8]), higher\u00ad 1 It \nis possible to encode trees as functions instead of using primitive tree constructors. The tree operations \nrealized in this way is however limited, as recursion schemes must be simply-typed. order functions can \nbe used. The function merge above is expressed as the following HMTT T2: Merge x y-> case(x,Copy y, x \n.Merge_a x y, x .Merge_b x y). Merge_a x y -> case(y, a(Copy x), y .a(a(Merge x y )), y .a(Merge_b y \nx)). ... Here, strings are expressed as linear trees (consisting of only termi\u00adnal symbols of arity 1 \nor 0). case(e, xe1.e1,...,xen.en) matches a tree e with a pattern ai t, and reduces to [et/xei]ei. HMTTs \nsub\u00ad e sume both higher-order recursion schemes and various kinds of tree transducers (such as macro \ntree transducers and high-level tree transducers [7, 8]). For HMTTs, we consider the following veri.cation \nproblem (T , M1,..., Mk, M): Given an HMTT T that takes k (possibly in.nite) input trees, and B\u00a8uchi \ntree automata with a trivial accep\u00adtance condition (where all the states are .nal) M1,..., Mk, M, does \nT always output a (possibly in.nite) tree accepted by M, given trees accepted by M1,..., Mk as inputs? \nFor example, let M be a tree automaton that accepts linear trees labeled by elements * b * . * b. of \nae + a + a (where a, b and e are terminal symbols of arity 1, 1,and 0 respectively). Then, the veri.cation \nproblem (T , M, M, M) is the problem of deciding whether T produces a * . * linear tree labeled by an \nelement of ab * e+a +ab. (thus, a tree like b(a(e)) is excluded), given two input trees labeled by elements \n* . * b * b. of ae + a + a . In the present paper, we give a sound but incomplete algo\u00adrithm for the \nHMTT veri.cation problem. The algorithm consists of two phases. First, we transform the HMTT veri.cation \nprob\u00adlem into a model-checking problem for recursion schemes extended with constructors and destructors \nfor .nite data domains (such as booleans). We then solve the model-checking problem for the re\u00adcursion \nscheme by using an extension of Kobayashi s model check\u00ading algorithm for recursion schemes [18]. The \nidea of the .rst phase is to approximate an input tree by an automaton state. For example, recall the \nHMTT T2 (corresponding to the merge function). The automaton M has two states q0 and q1, with transition \nd(q0,a)= q0,d(q0,b)= q1,d(q0,e)= E, d(q1,b)= q1,d(q1,e)= E. Thus, the output of T2 applied to linear \ntrees in L(M) is approximated by the following recursion scheme with .nite data domains {q0,q1}: S -> \nMerge q0 q0. Merge x y-> case(x, br3 (Copy y) (Merge_a q0 y) (Merge_b q1 y), br (Copy y) (Merge_b q1 \ny)). Merge_a x y -> case(y, br3 (a(Copy x)) (a(a(Merge x q0))) (a(Merge_b q1 x)) br (a(Copy x)) (a(Merge_b \nq1 x))). ... Here, the non-terminal Merge now takes elements of {q0,q1} as arguments instead of trees, \nand the case state\u00adment case(e, e0,e1) reduces to e0 if the value of e0 is q0, and reduces to e1 otherwise. \nThe three branches of br3 (Copy y) (Merge_a q0 y) (Merge_b q1 y) for the case x = q0 simulates the cases \nwhere the input tree x is of the form e, at1,and bt2 respectively. The tree generated by the recursion \nscheme (with .nite data domains) constructed in this manner contains all the possible outputs of the \nHMTT (for valid inputs). Thus, if the recursion scheme generates only valid trees, so does the HMTT. \n As mentioned above, our veri.cation algorithm is sound but incomplete: it does not accept an invalid \nHMTT, but may reject a valid HMTT. As we show in the paper, the HMTT veri.cation problem is undecidable \nin general, so that we cannot hope to .nd a complete algorithm. We show, however, that the proposed algo\u00adrithm \nis complete for a subclass of HMTTs called linear HMTTs (with certain additional assumptions). Intuitively, \nan HMTT is lin\u00adear if it traverses each input tree at most once. (For example, the merge function above \nis linear since it traverses x and y just once.) Note that, even for the decidable class of linear HMTTs, \nour veri\u00ad.cation problem subsumes the model checking problem for recur\u00adsion schemes (where properties \nare restricted to those described by B\u00a8uchi tree automata with a trivial acceptance condition). Lin\u00adear \nHMTTs also subsume (deterministic and total) high-level tree transducers [8] in the sense that any high-level \ntree transducer can be transformed into a linear HMTT by using a standard program transformation technique \n(see [23]). There are many potential applications of our HMTT veri.ca\u00adtion method. As HMTTs subsume recursion \nschemes and high\u00adlevel tree transducers, immediate applications include (i) the re\u00adsource usage veri.cation \nconsidered by Kobayashi [20], and (ii) exact type-checking of XML-processing programs [25, 27, 28, 34]. \nFor (i), while Kobayashi [18, 20] considered closed programs, we can now deal with programs that take \nrecursive data structures as arguments. For (ii), unlike previous approaches to using macro or high-level \ntree transducers, we can verify programs that take multi\u00adple XML documents as inputs. Furthermore, thanks \nto the ef.cient model-checking algorithm for recursion schemes, our HMTT ver\u00adi.cation algorithm is reasonably \nfast even for higher-order cases; on the other hand, previous approaches based on transducers do not \nseem to scale well for higher-order cases [34]. Other applica\u00adtions include: (iii) string analysis [3, \n29], and (iv) veri.cation of programs that use other recursive data types (e.g. the list-ness of the \noutput of the function .atten converting nested lists into .at lists). For (iii), the goal is to check \nthat a program always generates a valid string as output. Web applications often generate HTML .les, \nand it is important to check that there is no cross-site script\u00ading vulnerabilities and also that the \noutput conforms to the HTML format [29]. Previous approaches [3, 29] use a kind of control .ow analysis \nto approximate the output string as a regular or context\u00adfree language, and then compare it with the \noutput speci.cation. By using HMTT, we can more precisely approximate the output string (and indeed, \nno approximation is required in certain cases). The rest of this paper is structured as follows. Section \n2 intro\u00adduces HMTTs and de.nes their veri.cation problems. Section 3 in\u00adtroduces higher-order recursion \nschemes extended with .nite data domains. Section 4 gives a transformation of HMTT veri.cation problems \ninto model-checking problems for recursion schemes with .nite data domains. Section 5 extends Kobayashi \ns type-based method for model-checking recursion schemes [18, 20], to deal with .nite data domains. Section \n6 discusses the complexity of our HMTT veri.cation algorithm. Section 7 discusses applications of our \nveri.cation method, and Section 8 reports preliminary experi\u00adments. Section 9 discusses related work, \nand Section 10 concludes the paper. A longer version of this paper [23], containing proofs and more details \non the experiments, is available from http: //www.kb.ecei.tohoku.ac.jp/~koba/papers/hmtt.pdf. 2. Higher-Order, \nMulti-Parameter Tree Transducer This section de.nes higher-order, multi-parameter tree transducers (HMTTs) \nand their veri.cation problems. From a programming language point of view, an HMTT is a term of the simply-typed \n.\u00adcalculus extended with recursion and tree constructors/destructors. Trees are classi.ed into inputtrees, \nwhich can only be destructed, and outputtrees, which can only be constructed. DEFINITION 2.1 (sorts). \nThesetof sortsisgivenby: . ::= i | o | .1 . .2 The sort i describes input trees, while o describes output \ntrees. The sort .1 . .2 describes a function that takes an element of sort .1 and returns an element \nof sort .2 DEFINITION 2.2. A higher-order, multi-parameter tree transducer (HMTT for short) T is a quadruple \n(S, N , R,S),where: S is a ranked alphabet. i.e. a map from a .nite set {a1,...,aN } of symbols called \nterminals to non-negative integers.  N is a map from a .nite set of symbols called non-terminals to \nsorts.  R is a set of rewriting rules of the form Fx1 \u00b7\u00b7\u00b7 xn . t, where F . dom(N ) is a non-terminal \nand t is a term. Here, the set of terms is de.ned by:  t ::= a | x | F | t1 t2 | case(x, ye1.t1,...,yeN \n.tN ), where yei abbreviates a sequence of variables, whose length must coincide with the arity of ai. \nS is a non-terminal called the start symbol. N (S) must be of the form i .\u00b7\u00b7\u00b7 . i . o. Furthermore, each \nrule Fx1 \u00b7\u00b7\u00b7 xn . t must be well-sorted, i.e. f Fx1 \u00b7\u00b7\u00b7 xm . t must be derivable by using the following \nsort assignment rules: Kf F : N (F ) Kf a : o . \u00b7\u00b7\u00b7 . o . o | {z } S(a) K,x : . f x : . Kf t1 : .1 . \n.2 Kf t2 : .1 Kf t1t2 : .2 Kf x : i K,yei : ei f ti : o Kf case(x, ye1.t1,..., yeN .tN ): o N (F )= \n.1 . \u00b7\u00b7\u00b7 . .m . o x1 : .1,...,xm : .m f t : o f Fx1 \u00b7\u00b7\u00b7 xm . t Note that in the sort assignment rule \nfor case-expressions, x must be of sort i; thus, pattern matching on trees are only allowed on input \ntrees (of sort i). REMARK 2.1. Each terminal symbol is used as a constructor for input trees (of sort \ni) as well as for output trees (of sort o). In the sort assignment rule above, however, only the sort \no . \u00b7\u00b7\u00b7 . o . o is assigned, as input trees cannot be constructed by an HMTT. In an environment . introduced \nbelow, a terminal of arity k has sort i .\u00b7\u00b7\u00b7 . i . i. D | {z } k A S-labeled ranked tree, written T , \nis a mapping from {1,...,A} * (where A is the largest arity of symbols in S)to  dom(S), such that (i) \ndom(T ) is closed under the pre.x operation, and (ii) if T (x)= a,then {i | xi . dom(T )} = {1,..., S(a)}. \nThe set of evaluation contexts is de.ned by: E ::= [] | at1 \u00b7\u00b7\u00b7 tj-1 [] tj+1 \u00b7\u00b7\u00b7 tS(a) Let . be a mapping \nfrom a .nite set of variables (of sort i)to a set of pairs consisting of a S-labeled ranked tree and \na non-negative integer. (The second element of such a pair, called uses, will later be used for de.ning \nthe linearity condition.) Let T =(S, N , R,S). ' The reduction relation (t, .) -.T (t,.') is de.ned by: \nFx1 \u00b7\u00b7\u00b7 xm . t .R (E[Ft1 \u00b7\u00b7\u00b7 tm],.) -.T (E[[t1/x1,...,tm/xm]t],.) e.' e .(x)=(ai T,j)= .{x . (ai T,j \n+1), e' . ( e0)} yT, e(ye' are fresh) (E[case(x, ye1.t1,...,yeN .tN )],.) -.T (E[[ye'/yei]ti],.') Here, \n[et/xe]t' denotes the term obtained from t' by simultaneously replacing xewith et. In the rule above, \nTedenotes a sequence of (possibly in.nite) trees, and ai Tedenotes a tree whose root is labeled by ai \nand children are Te. Suppose that t is a term of type i .\u00b7\u00b7\u00b7 . i . o. We write | {z } k [[T ,t,I1,...,Ik]] \nfor the tree obtained by in.nitary rewriting of (tx1 \u00b7\u00b7\u00b7 xk, {x1 . (I1, 0),...,xk . (Ik, 0)}). More precisely, \nit is de.ned as follows. Given a term t, we write t. for the .nite tree inductively de.ned by (i) (as1 \n\u00b7\u00b7\u00b7 sn). = a(s1 .) \u00b7\u00b7\u00b7 (sn .) (where n = 0), and (ii) t. = . if t is of the from Fs1 \u00b7\u00b7\u00b7 sn or case(x, \ney.tn). For example, (ac (F (bc))). ac .. y.t1,..., e= We de.ne [[T ,t,I1,...,Ik]] as the (possibly in.nite) \n(S .{. . F '. 0})-labeled tree '{t| (tx1 \u00b7\u00b7\u00b7 xk, {x1 . (I1, 0),...,xk . FF (Ik, 0)}) -. * (t,.')},where \nTi is de.ned by ( Ti)(p)= T F ii (Ti(p)) for every p .{1,...,A} * (where A is the largest i arity), with \n.U a = a for every a . dom(S). EXAMPLE 2.1. Consider the HMTT T =(S, N , R, Rev) where: S= {a1 . 1, a2 \n. 1, a3 . 0} N = {Rev . i . o, RevSub . i . o . o} R = {Revx . RevSubx a3, RevSubxy . case(x, x'.RevSubx' \n(a1 y),x'.RevSubx' (a2 y),y)} T computes the reverse of (the tree representation of) a string over {a1, \na2}.If u1,...,un .{a1, a2},then [[T , Rev,u1(u2 \u00b7\u00b7\u00b7 (un-1(una3)) \u00b7\u00b7\u00b7 ))]] is: un(un-1(\u00b7\u00b7\u00b7 (u2(u1a3)) \n\u00b7\u00b7\u00b7 )). Here, the terminal symbol a3 is used to denote the end of a string. For example, (Rev x, {x . \n(a1(a2a3), 0)}) is reduced as follows: (Rev x, . = {x . (a1(a2a3), 0)}) -.T (RevSubx a3,.) -.T (case(x, \n'''' x.RevSubx(a1a3),x.RevSubx(a2a3), a3)),.) -.T (RevSubx'' (a1a3),{x .(a1(a2a3),1),x'' .(a2a3,0)}) \n-. *T (a2(a1a3),.') D EXAMPLE 2.2. Recall the merge function in Section 1. It is ex\u00adpressed as the following \nHMTT T =(S, N , R, Merge). S= {a . 1, b . 1, e . 0} R = {Merge xy . '''' case(x,x.Mergea xy,x.Mergeb \nxy, Copy y) Mergea xy . case(y, '''' y.a(a(Merge xy)),y.a(Mergeb yx), a(Copy x)), Mergeb xy . case(y, \n '''' y.b(Mergea yx),y.b(b(Merge xy)), b(Copy x)), Copy x . case(x, x'.a(Copy x'),x'.b(Copy x'), e), \n} D We introduce an important subclass of HMTTs. DEFINITION 2.3 (linear HMTT). An HMTT T =(S, N , R,S) \nis linear if, for all S-labeled ranked trees I1,...,Ik (where k is the arity of S) and for all . and \nt, (Sx1 \u00b7\u00b7\u00b7 xk, {x1 . (I1, 0),...,xk . (Ik, 0)}) -. * (t, .) and .(y)=(I,j) im- T ply j = 1,for every \ny . dom(.). Note that the linearity is a semantic condition. It is possible to construct a sound (but \nincomplete) type system for guaranteeing the linearity of HMTTs, but the semantic condition is suf.cient \n(and actually more convenient) for our purpose. For order-1 case, the linearity condition is almost the \nsame as the syntactic condition of linearity (or, 1-bounded copying) introduced by Maneth et al. [27]. \nFor higher-order cases, one can de.ne a linear type system for (conservatively) guaranteeing the linearity \ncondition. REMARK 2.2. The reader may think that the linearity condition is too restrictive. Actually, \nhowever, the class of tree transformations expressed by linear HMTTs is at least as large as those expressed \nby variations of deterministic macro/high-level tree transducers stud\u00adied in the literature. That follows \nfrom the following facts. First, to our knowledge, all the variations of macro tree transducers (in\u00adcluding \npebble tree transducers [28] and stay macro tree transduc\u00aders [27]) studied in the literature can be \nexpressed by compositions of macro tree transducers (see [6] for the case of pebble tree trans\u00adducers). \nSecondly, by the result of Engelfriet [8], any composition of deterministic, total macro tree transducers \ncan be expressed by a single deterministic high-level tree transducer. Third, as discussed in Appendix \nA, any deterministic high-level tree transducer can be translated to a linear HMTT by using the tupling \ntransforma\u00adtion [13]. We use a variant of tree automaton called a trivial automaton[2, 20] for describing \nproperties on (possibly in.nite) input and output trees of HMTT. DEFINITION 2.4 (trivial automaton). \nA B\u00a8uchi automaton with a trivialacceptance condition (a trivial automaton, for short) M is a quadruple: \n(S,Q, .,q0) where S is a ranked alphabet, Q is a set of states, ., called a transition function, is a \n.nite subset of Q \u00d7 dom(S) \u00d7 Q * such that if (q, a, q1 \u00b7\u00b7\u00b7 qk) . .,then k = arity(a).A dom(S)\u00adlabeled \ntree T is accepted by M if there is a Q-labeled tree R such that (i) dom(T )= dom(R); (ii) For every \nx . dom(R), (R(x),T (x),R(x1) \u00b7\u00b7\u00b7 R(xm)) . . where m = arity(T (x)). R is called a run tree of M over \nT . A trivial automaton is deter\u00administic if the set {s | (q, a, s) . .} is empty or a singleton set \nfor every q . Q and a . dom(S). (Assuming that . does not occur in the alphabet of M)we write M. for \nthe trivial automaton obtained from M by adding the special symbol . (of arity 0) to the alphabet, and \nreplacing the transition relation . with . .{(q, .,E)|q . Q}.  EXAMPLE 2.3. Consider a trivial automaton \nM = (S, {q0,q1}, .,q0) where S= {a1 . 2,a2 . 1,a3 . 0}.= {(q0,a1,q0q0), (q0,a2,q1q1), (q0,a2,q1), (q1,a2,q1), \n(q0,a3,E), (q1,a3,E)} M accepts S-ranked trees whose paths are labeled by elements of ** * .. a1a2a3 \n+ a1a2 + a1 . D We now de.ne the HMTT veri.cation problem, which is the main subject of the rest of this \npaper. DEFINITION 2.5 (HMTT veri.cation problem). Let T be an HMTT with N (S)= k.We write |=(T , M1,..., \nMk, M) if [[T ,S,I1,...,Ik]] .L(M.) holds for every I1 . L(M1),...,Ik .L(Mk).An HMTT veri.cation problem \n(T , M1,..., Mk, M) is the problem of deciding whether |=(T , M1,..., Mk, M) holds. The problem of model-checking \nhigher-order recursion schemes [32] (where properties are restricted to those described by trivial automata) \nis a special case of the HMTT veri.cation prob\u00adlem (where k =0). REMARK 2.3. Note that the above de.nition \nallows . to occur in [[T ,S,I1,...,Ik]]. Given .nite trees as input, an HMTT may produce . when it does \nnot terminate. Thus, the above problem is slightly different from the problem of exact type checking \nof tree transducers studied in the literature. They usually check that, given an input tree in L(M1), \na transducer does terminate and produces a tree in L(M), while our de.nition allows the case where the \nprogram does not terminate. This difference is analogous to partial vs total correctness in program veri.cation. \nWe consider only partial correctness, leaving the termination veri.cation as a separate problem. 3. Recursion \nSchemes with Finite Data Domains In this section, we introduce an extension of higher-order recursion \nschemes with .nite data domains (RSFD, for short), and de.ne a model-checking problem for RSFD, into \nwhich the HMTT veri.\u00adcation problem in the previous section will be transformed. DEFINITION 3.1 (sorts \nfor RSFD). The set of (RSFD) sorts is given by: . ::= d | o | .1 . .2 DEFINITION 3.2. Ahigher-orderrecursionschemewith.nitedata \ndomain(RSFDforshort) G isaquintuple(S, N ,D, R,S),where: S is a ranked alphabet. N isamapfroma .nite \nsetofsymbolscalled non-terminals to sorts. D is a .nite set {d1,...,dl}.  R is a set of rewriting rules \nof the form Fx1 \u00b7\u00b7\u00b7 xn . t, where F . dom(N ) is a non-terminal andt is a term. Here, the setoftermsis \nde.nedby:  t ::= a | di | x | F | t1t2 | case(t, t1,...,tl) Thesortassignmentrulesfortermsarethe sameasthoseofHMTT, \nexceptthefollowing rules. Kf d : d Kf t : d Kf ti : o (for each i) Kf case(t, t1,...,tl): o S isa non-terminal \ncalledthestart symbol, with N (S)= o. The rewriting relation t -.G t ' is de.ned by: Fx1 \u00b7\u00b7\u00b7 xm . t .R \nE[Ft1 \u00b7\u00b7\u00b7 tm] -.G E[[t1/x1,...,tm/xm]t] E[case(di,t1,...,tl)] -.G E[ti] Here, E denotes an evaluation \ncontext, whose syntax is given by: E ::= [] | at1 \u00b7\u00b7\u00b7 tj-1 [] tj+1 \u00b7\u00b7\u00b7 tS(a) The value tree of G, written \nby [[G]],is the (S .{. . 1})\u00adlabelled ranked tree obtained by in.nitary rewriting of S,i.e. F {t '. | \nS -. *' }. G t EXAMPLE 3.1. Consider the following RSFD G =({a . 1, b . 1}, N , {d1,d2}, R,S),where: \nN = {S : o,F : d . o}R = {S . Fd1, Fx . case(x, a(Fd2), b(Fd1))} The value tree [[G]] is the in.nite \ntree a(b(a(b(\u00b7\u00b7\u00b7 )))). DEFINITION 3.3 (RSFD model checking problem). Let G be an RSFD and M be a trivial \nautomaton. The RSFD model check\u00ading problem (G, M) is the problem of deciding whether [[G]] . L(M.) holds.We \nwrite |=(G, M) if [[G]] .L(M.) holds. The RSFD model checking problem is decidable: as sketched in [20], \nany recursion scheme with .nite data domains can be encoded into an ordinary recursion scheme, and the \nmodel checking prob\u00adlem for ordinary recursion schemes is decidable. Instead, it is also possible to \nencode an element di of a .nite base type {d1,...,dk}into a function of sort o . \u00b7\u00b7\u00b7 . o . o: .x1. \u00b7\u00b7\u00b7 \n..xk.xi. Then, | {z } k case(x, t1,...,tk) can be encoded into xt1 \u00b7\u00b7\u00b7 tk. In Section 5, we given an \nalternative, direct proof of the decidability, which re\u00adduces the RSFD model checking problem into a \ntype checking problem. REMARK 3.1. Unliketheoriginalde.nitionofthe modelchecking problemforrecursionschemes \n[32],wehereallow [[G]] togenerate a tree containing . foratechnicalconvenience.Theproblem of checking \n[[G]] .L(M) is also decidable. 4. From HMTT Veri.cation to RSFD Model-Checking This section reduces the \nHMTT veri.cation problem to the model\u00adchecking problem for RSFD. The reduction is sound but incom\u00adplete \nin general: For any HMTT veri.cation problem P1,if the cor\u00adresponding model checking problem P2 for RSFD \nhas a positive answer, then so does P1, but not vice versa. For linear HMTTs, however, the reduction \nis sound and complete. As mentioned in Section 1, the idea of the transformation is to use the state \nof a trivial automaton as an abstraction of an input tree (of sort i). Let (T , M1,..., Mk, M) be an \nHMTT veri.ca\u00adtion problem. One can construct a trivial automaton M1,...,k = (SI ,QI , .I ,q1) such that \nL(M1,...,k,qi)= L(Mi). Here, L(M1,...,k,qi) is the set of trees accepted by (SI ,QI , .I ,qi). Let QI \nbe {q1,...,ql}. We also assume that for every q . QI , L(M1,...,k,q) \u00d8, i.e. there is no garbage state \n(from which no = tree can be accepted). For an HMTT veri.cation problem (T , M1,..., Mk, M) where T =(S, \nN , R,S) and M =(S,Q, .,q0), we write  br br br brbr a3 br . br a1 br a2  . . . a2. a2  a3 a3 . \n. . . a2a1 a3a3 Figure 3. The tree generated by G of Example 4.1 (T , M1,..., Mk, M)# for the pair (G, \nM ' ), where: G =(S .{br . 2}, N # .{S ' . o},QI , R ' ,S ' ) R ' = {S ' . Sq1 \u00b7\u00b7\u00b7 qk}.{Fxe. t# | Fxe. \nt .R} M ' =(S .{br . 2},Q, . ' ,q0) . ' =. .{(q, br,qq) | q . Q}. Here, N # just replaces each occurrence \nof sort i in N with d.The translation t# of a term t is de.ned by: # # ### F # # '' a = ax = x = F (t1 \nt2)= t1 t2 case(x, ye1.t1,..., yeN .tN )= case(x, u 1,...,u l) where u ' i = br ([qe1,1/ye1]t1#) \u00b7\u00b7\u00b7 \n([qe1,ki,1 /ye1]t1#) ## \u00b7\u00b7\u00b7 ([qeN,1/yeN ]tN ) \u00b7\u00b7\u00b7 ([qeN,ki,N /yeN ]tN ) .(qi,aj)= {qej,1,...,qej,ki,j \n}(Here .(q, a) denotes {qe| (q, a, qe) . .}) In the de.nition above, br t1 \u00b7\u00b7\u00b7 tn is an abbreviated form \nof: br t1 (br t2 (br \u00b7\u00b7\u00b7 (br tn-1 tn) \u00b7\u00b7\u00b7 )) Note that case analysis on an input tree x is replaced by \ncase analysis on the corresponding automaton state x. For each case qi . Q of x, the case expression \nreduces to a term of the form br t1 \u00b7\u00b7\u00b7 tm,where t1,...,tm are reducts for all the possible trees abstracted \nby qi. EXAMPLE 4.1. Recall Example 2.1. Let M1 and M be trivial automata (S,Q, .1,q1) and (S,Q, .,q1) \nwhere: S= {a1 . 1,a2 . 1,a3 . 0} Q = {q1,q2} .1 = {(q1,a1,q1), (q1,a2,q2), (q2,a2,q2), (q1,a3,E), (q2,a3,E)} \n.= {(q1,a2,q1), (q1,a1,q2), (q2,a1,q2), (q1,a3,E), (q2,a3,E)} Then, (T , M1, M2)# =(G, M ' ) where G \n=(S .{br}, N , {q1,q2}, R,S ' ) R = {S ' . Sq1,Sx . RevSubx a3, RevSubxy . case(x, t1,t2)}t1 = br (RevSubq1 \n(a1 y)) (br (RevSubq2 (a2 y)) y) t2 = br (RevSubq2 (a2 y)) y M ' =(S .{br . 2}, {q1,q2}, .,q1) .=. .{(q1, \nbr,q1q1), (q2, br,q2q2)} Note that input trees have been replaced by states of M1, and case analyses \non an input tree have been replaced by case analyses on the corresponding state of M1.The value tree \nof G is illustrated in Figure 3. D We now discuss the correctness of the transformation. The fol\u00adlowing \ntheorem guarantees that (the .rst element of) the output of the transformation is indeed a recursion \nscheme. THEOREM 4.1 (well-formedness of the recursion scheme). Let (T , M1,..., Mk, M) be an HMTT veri.cation \nproblem. If (T , M1,..., Mk, M)# =(G, M ' ),then G is a recursion scheme. Proof It suf.ces to show that \neach rule of G is well-sorted. We de.ne a translation of sorts of HMTT into those of RSFD by: # ## i= \ndo# = o (.1 . .2)= .1# . .2 The translation (\u00b7)# is pointwise extended to sort environments. We can show \nby induction on the derivation that Kf t : . implies K# f t# : .#. Thus, any well-sorted rule of T is \ntransformed into a well-sorted rule of G. D The following theorem guarantees the soundness of our trans\u00adformation. \nTHEOREM 4.2 (soundness). Let (T , M1,..., Mk, M) be an HMTT veri.cationproblem.If |=(T , M1,..., Mk, \nM)#,then |=(T , M1,..., Mk, M). Proof Sketch Let (G, M ' ) be (T , M1,..., Mk, M)#.We .rst note that \nby the de.nitions of [[G]] and [[T ,S,I1,...,Ik]],we have: (I) [[G]] .L(M'.) if, and only if, u . .L(M'.) \nfor every u such that S ' -. * G u, and (II) [[T ,S,I1,...,Ik]] .L(M.) if, and only if, t. .L(M.) for \nevery t such that ...((Sx1 \u00b7\u00b7\u00b7 xk,.0) -. *T (t, .)),where .0 = {x1 . (I1, 0),...,xk . (Ik, 0)}. We de.ne \nthe relation u r u ' on RSFD terms of sort o induc\u00adtively by: (i) br u1 \u00b7\u00b7\u00b7 un r u ' i if ui r ui' , \n(ii) au1 \u00b7\u00b7\u00b7 un r '' ' au1 \u00b7\u00b7\u00b7 un if ui r ui for each i .{1,...,n}, (iii)Fuer Fue, and (iv) case(u, u1,...,ul) \nr case(u, u1,...,ul). Intuitively, an RSFD term u represents a set of terms (where br denotes a union), \nand u r u ' means that u ' is an element of the set rep\u00adresented by u. Suppose that |=(G, M ' ) and (Sx1 \n\u00b7\u00b7\u00b7 xk,.0) -. * (t, .) T with Ii .L(Mi) for each i .{1,...,k}. It suf.ces to show that t. .L(M.). One \ncan prove that (Sx1 \u00b7\u00b7\u00b7 xk,.0) -.T* (t, .) '.'. ' G implies S ' -. * u r u and t= u for some u and u \n(which intuitively means that G is a correct abstraction of T ). By the assumption |=(G, M ' ),we have \nu . .L(M'.).Bythe ' construction of M ',we have u . .L(M.) (note that u '. does not contain br), which \nimplies t. .L(M.) as required. See [23] for more details. D As shown by the following example, the converse \nof the above theorem does not hold in general. EXAMPLE 4.2. Consider an HMTT T =(S, N , R,S) where: S= \n{a1 . 0,a2 . 0,a3 . 2} N = {S . i . o} R = {Sx . case(x, a3 a1 (Cx),a2, \u00b7\u00b7\u00b7 ), Cx . case(x, a1,a2, \u00b7\u00b7\u00b7 \n)} We have omitted the case for a3 since it does not mat\u00adter. Let M1 be the trivial automaton (S, {q0}, \n.1,q0) where .1 = {(q0,a1,E), (q0,a2,E)}. Note that L(M1) accepts {a1,a2}.Let M be another trivial automaton \n(S, {q0,q1}, .,q0), where .= {(q0,a2,E), (q0,a3,q1q1), (q1,a1,E)}, which ac\u00adcepts {a3 a1 a1,a2}. Obviously, \n|=(T , M1, M) holds. However,  (T , M1,..., Mk, M)# is (G, M ' ) where: G =(S, N , {q0}, R,S ' ) R = \n{S ' . Sq0,Sx . case(x, br (a3 a1 (Cq0)) a2), Cx . case(x, br a1 a2)} M ' =(S, {q0,q1}, . ' ,q0) . ' \n= {(q0, br,q0q0), (q1, br,q1q1)}. . [[G]] = br (a3 a1 (br a1 a2)) a2 is not accepted by M ' . The reason \nwhy the transformation above does not preserve the validity is that both of the input trees a1 and a2 \nare abstracted to q0, and independent choices between a1 and a2 are made in the two case analyses on \nx of the recursion scheme (once in the rule for S, and the other time in the rule for C). D If we restrict \nourselves to linear HMTTs and make certain additional assumptions, then our transformation is complete. \nTHEOREM 4.3 (completeness for linear HMTT). Let (T , M1,..., Mk, M) be anHMTTveri.cationproblem. Sup\u00adposealsothat \noneofthefollowing conditions holds. 1. M =(S,Q, .,q0) isdeterministic. 2. If (T , M1,..., Mk, M)# =(G, \nM ' ), the symbols br only occuratthetop-level of [[G]],i.e.ineverypathof [[G]] from the root, br does \nnot occurafterotherterminal symbolsoccur.  If T is linear and |=(T , M1,..., Mk, M), then |=(T , M1,..., \nMk, M)# . Proof Sketch Suppose that |=(T , M1,..., Mk, M) and S ' -. * u. It suf.ces to show u . .L(M'.) \n(recall the .rst G paragraph of the proof sketch of Theorem 4.2). By the assumption that T is linear, \none can prove that S ' -. * G u r u ' implies (Sx1 \u00b7\u00b7\u00b7 xk, {x1 . (I1, 0),...,xk . (Ik, 0)}) -. * (t, \n.) and u '. = t. for some t, .,and I1,...,Ik T such that Ii .L(Mi) for every i .{1,...,k}. (This intuitively \nmeans that G is an abstraction of T that is precise enough to cap\u00adture only the reductions possible in \nT .) For such t,we have t. . L(M.) by the assumption |=(T , M1,..., Mk, M). By the con\u00ad '. '. struction \nof M ' and the fact u = t.,we have u .L(M'.). '. '' Thus, we have u .L(M'.) for every u such that u r \nu . We therefore have u . .L(M'.) if one of the two conditions in the statement of the theorem holds. \nSee [23] for more details. D REMARK 4.1. If neither of the two conditions in Theorem 4.3 holds, the last \nstep of the above proof does not go through. In that case, the completeness does not hold indeed. Consider \nthe HMTT T =(S, N , R,S) where: S= {a1 . 1,a2 . 0,a3 . 0} N = {S . i . o} R = {Sx . case(x, x ' .a1(Sx \n' ),a2,a3)} It just generates a copy of a given input tree. Let us consider (non-deterministic) automata \nM1 =(S, {q1,q2}, .1,q1) and M =(S, {q1,q2}, .,q1) where .1 = {(q1,a1,q2), (q2,a2,E), (q2,a3,E)} .= {(q1,a1,q2), \n(q1,a1,q3), (q2,a2,E), (q3,a3,E)}. Since both automata accept {a1 a2,a1 a3}, |=(T , M1, M) holds. Our \ntransformation algorithm generates the recursion scheme G = (S .{br . 2}, N , {q1,q2}, R,S ' ) and the \nautomaton M ' = (S .{br . 2},Q, . .{(q1, br,q1,q1), (q2, br,q2,q2)},q1) where R consists of: S ' . Sq1 \nSx . case(x, a1(Sq2), br a2 a3) It generates a .nite tree a1(br a2 a3). The tree is NOT accepted by M \n': note that no state can be assigned to the subtree br a2 a3. The second condition of Theorem 4.3 can \nbe guaranteed by applying the CPS transformation, which ensures that an output tree is returned only \nafter all the non-deterministic branches have been made. For example, the HMTT can be transformed into \nthe following equivalent HMTT (where only the rewriting rules are shown). Sx . S1 xI Ix . x Ckxy . k(x(y)) \nS1 xk . case(x, x ' .S1 x ' (Cka1),ka2,ka3) It generates the tree br (a1 a2)(a1 a3), which is accepted \nby M ' . The HMTT veri.cation problem is undecidable in general, since we can encode Post correspondence \nproblem. THEOREM 4.4. TheHMTTveri.cationproblemis undecidable. Proof Let A be {a1, ..., an} and consider \na Post correspondence problem (u1,v1), ..., (um,vm) .A * \u00d7A * Without loss of generality, we may assume \nthat m = n, since if m<n, we can add dummy pairs (E, E) as (uk,vk) for m<k = n. The Post correspondence \nproblem is the problem of deciding whether there exists a sequence i1 \u00b7\u00b7\u00b7 ie such that ui1 ui2 \u00b7\u00b7\u00b7 ui\u00a3 \n= vi1 vi2 \u00b7\u00b7\u00b7 vi\u00a3 . We shall construct an HMTT that takes a candidate of such a sequence, and checks \nwhether the candidate satis.es the condition above. Let T be an HMTT (S, N , R,S) where: S= {a1 . 1,...,an \n. 1, e . 0, yes . 0, no . 0} N = {S . i . o} .{Subu,v . i . i . o | u, v are suf.xes of ui and vj for \nsome i and j} .{IsNullu . i . o | u is a suf.x of ui for some i} R = {Sx . Sube,e xx} .{Sube,s xy . \n''' ' case(x,x .Subu1,s x y,...,x .Subun,s x y, IsNulls y) | s .{a1,...,an} * }.{Subs,E xy . '' ' case(y,y \n.Subs,v1 xy ,...,x.Subs,vn xy , IsNulls x) | s .{a1,...,an}+} '' .{Subau',av', xy . Subu',v', xy | a \n.A,u ,v .A * }.{Subau',bv', xy . no | a, b .A,u ' ,v ' .A * ,a = b}.{IsNullE x . case(x, x ' .no, \u00b7\u00b7\u00b7 \n,x ' .no, yes)}.{IsNulls x . no | s .A+} Here, we assume that yes and no do not occur in input trees, \nand omit cases for yes and no in case expressions. The above HMTT takes as input (the tree representation \nof) a sequence ai1 ai2 \u00b7\u00b7\u00b7 ai\u00a3 .A *, and checks whether the strings ui1 ui2 \u00b7\u00b7\u00b7 ui\u00a3 and vi1 vi2 \u00b7\u00b7\u00b7 vi\u00a3 \nare the same, by comparing their elements one by one. In Subu,v, xy, x and y are bound to suf.xes of \nai1 ai2 \u00b7\u00b7\u00b7 ai\u00a3 , and it is checked whether uui\u00a3+1-|x| \u00b7\u00b7\u00b7 ui\u00a3 and vvi\u00a3+1-|y| \u00b7\u00b7\u00b7 vi\u00a3 are the same. Thus, \nthe HMTT outputs yes if the sequence is a solution for the Post correspondence problem and no otherwise. \nLet M1 and M2 be trivial automata: M1 =(S, {q0}, .1,q0) .1 = {(q0,ai,q0) | ai .A}.{(q0,b, E)} M2 =(S, \n{q0}, .2,q0) .2 = {(q0, no,E)} Then, |=(T , M1, M2) if and only if the Post correspondence problem {(u1,v1),..., \n(un,vn)} has no solution. Since Post cor\u00adrespondence problem is undecidable, the HMTT veri.cation prob\u00adlem \nis also undecidable. D  5. Type System for Model-Checking Recursion Schemes with Finite Data Domains \nThis section gives a type system for recursion schemes with .nite data domains (which is parameterized \nby a trivial automaton M), such that an RSFD G is well-typed in the type system if, and only if, |=(G, \nM) holds. Thus, the RSFD model checking problem is reduced to a type checking problem, which can be solved \nby extending Kobayashi s type inference algorithms [18, 20]. Let M be a trivial automaton (S,Q, .,q0),and \nD be a .nite set {d1,...,dk}. The set of types is given by: t ::= di | qj | V n ti . t i=1 Intuitively, \ndi . D is a singleton type, describing the value di. The type qj . Q describes trees accepted from qj \n(i.e. elements of V L(M,qj )). The type n . t describes functions that take i=1 tn an element having \ntypes t1,...,tn and return an element of type t . A type judgment for terms (where a non-terminal is \ntreated as a variable) is of the form G fM t : t ,where G, called a type environment, is a .nite set \nof bindings of the form x : t . G may contain more than one bindings for each variable. The typing rules \nare given by: G,x : t fM x : t G fM di : di (q, a, q1 \u00b7\u00b7\u00b7 qn) . . G fM a : q1 . \u00b7\u00b7\u00b7 . qn . q V G fM \nt0 : n ti . t i=1 G fM t1 : ti (for each i =1,...,n) G fM t0t1 : t G fM t : di G fM ti : q (for some \ni) G fM case(t, t1,...,tk): q G,x : t1,...,x : tn fM t : tx not occur in G V n G fM .x.t : i=1 ti . \nt Let G be a recursion scheme with .nite domains (S, N ,D, R,S). We write fM G :G if G fR(F ): t holds \nfor every F : t . G. A recursion scheme G is well-typed, written fM G, just if there exists G such that \n(i) fM G :G, (ii)S : q0 . G, and (iii) for each F : t . G, t :: N (F ) holds (i.e. the sorts declared \nin N are respected). Here, the relation t :: ., which means that t is a type of sort ., is de.ned by: \n(i) q :: o, (ii) Vk q :: d, and (iii) i=1 ti . t :: . ' . . if t :: . and ti :: . ' for each i .{1,...,k}. \nThe following theorem is an extension of the result of Kobayashi [20]. The proof is almost the same as \nthat of the sound\u00adness and completeness of the type system for recursion schemes (without .nite data \ndomains) [20], hence is omitted. THEOREM 5.1. Let M be a trivial automaton, and G be a recur\u00adsion schemewith.nite \ndomains,If [[G]] is well-de.ned,thenfM G ifand onlyif|=(G, M). COROLLARY 5.2. The RSFD model-checking \nproblem is decid\u00adable. 6. Complexity of the Veri.cation Algorithm We brie.y discuss the complexity of \nour HMTT veri.cation algo\u00adrithm, which consists of two phases: transformation into a recur\u00adsion scheme \n(with .nite data domains) and model checking of the recursion scheme. Let (T , M1,..., Mk, M) be an HMTT \nveri.cation prob\u00adlem. We may assume that Mi =(S,Q0, .0,qi) for each i (i.e. M1,..., Mk differ only in \ntheir initial states). Let |T | be the size of the rewriting rules of T . We also assume that the rewriting \nrules of T are normalized, so that each body of a rewriting rule contains at most one case-expression. \nLet (T , M1,..., Mk, M)# be (G, M ' ).The size |G| of the rewrit\u00ading rules of G is O(|Q0|AS+1|T |) where \nAS is the largest arity of terminal symbols: note that only the sizes of case expressions may increase, \nand for each body of a case expression, at most |{(q, qe) | (q, a, qe) . .}| (which are bounded by |Q|A+1) \ncopies are created. As for the time complexity of model-checking G, we can ap\u00adply the same argument as \n[20, 22] to obtain an upper-bound O(|G|exp((A(|Q0| + |Q ' |))1+E)) for arbitrary E> 0 for n = 2, n where \nn is the order of the recursion scheme G and |Q ' | is the num\u00adber of states of M ',and A is the largest \narity of symbols in G. Here, (x)=2expn(x) expn(x) is de.ned by: exp0(x)= x and expn+1. Thus, the time \ncomplexity of our HMTT veri.cation algorithm is O(|T |exp((A(|Q0| + |Q|))1+E)) for n = 2,where |Q| is \nn the number of states of M. If the largest arity and the number of automaton states are .xed, it is \nlinear in the size of HMTT. (Note, however, that the constant factor is huge.) Theorem 4.3 implies that \nif the HMTT is linear and the automa\u00adton M is deterministic, then the HMTT veri.cation problem is de\u00adcidable. \nFor this decidable fragment, the veri.cation problem itself is (n - 1)-EXPTIME complete for n = 2 (in \nthe combined size of a recursion scheme and an automaton), as described below. First, from a deterministic \ntrivial automaton M, one can construct a dis\u00adjunctive alternating parity tree automaton (disjunctive \nAPT) [21] that accepts the complement of L(M) and the size of the disjunc\u00adtive APT is linear in that \nof M. Thus, the model checking problem for the class of deterministic trivial automaton can be reduced \nto that for the class of disjunctive APT [21], which gives the upper\u00adbound of (n - 1)-EXPTIME. Secondly, \nit follows from the result of [21] (more precisely, from the (n - 1)-EXPTIME hardness of the reachability \nproblem) that the problem of model-checking re\u00adcursion schemes for the class of deterministic trivial \nautomata is (n - 1)-EXPTIME hard. For n =1, by a similar argument, if we assume that the largest arity \nof terminals and non-terminals is .xed, the HMTT veri.cation problem is polynomial-time.2 7. Applications \nThis section discusses applications of our HMTT veri.cation framework. 7.1 Resource Usage Veri.cation \nAs mentioned in Section 1, the goal of resource usage veri.ca\u00adtion [14] is to check whether a given program \naccesses each re\u00adsource in a valid manner. In our previous work [20], we considered 2 This result is \nsimilar to, but should not be confused with the result of [27], which shows that the exact type checking \nof linear MTT is polynomial time under a similar assumption about arities and the assumption that the \nspeci.cation is given by a deterministic bottom-up tree automaton. The class of languages of .nite trees \naccepted by deterministic trivial automata is strictly less expressive than the class of those accepted \nby deterministic bottom-up tree automata. Thus, our result is weaker in this sense. On the other hand, \nwe allow multiple input trees as arguments of non-terminals.  resource usage veri.cation of a closed \nprogram. Our HMTT veri.\u00adcation framework allows us to perform resource usage veri.cation of an open program, \nwhich is a function that takes some parameters as input. For example, consider the following program: \nlet rec accfile cmds = match cmds with [] -> close(fp) | r::cmds -> read(fp); accfile cmds fp | w::cmds \n-> write(fp); accfile cmds fp It takes a list of commands consisting of r and w, and accesses the resource \nx according to the list of commands, and then closes it. We can covert the above program into the following \nHMTT T (only the rewriting rules are shown): AccFile cmds = case cmds of e => close | r(cmds ) => read(AccFile \ncmds ) | w(cmds ) => write(AccFile cmds ). For the sake of readability, throughout this section, we use \nordinary pattern matching constructs, which can be easily translated into case expressions of HMTT. We \nalso write = instead of ->.To verify that if the list of commands only consists of r, then the .le pointer \nfp is only read and then closed, it suf.ces to consider the HMTT veri.cation problem (T , M1, M),where \nM1 accepts the language consisting of linear trees labeled by elements of r * (e)+ r . and M accepts \nthe language consisting of linear trees labeled by elements of read * (close)+ read. .  7.2 Veri.cation \nof XML-Processing Programs Another application domain of our HMTT veri.cation algorithm is exact type \nchecking of XML-processing programs [25, 27, 28, 34]. We assume below that XML documents (which are unranked \ntrees) are represented as binary trees in the standard manner: the left and right children of a node \nin the binary tree representation stand for the leftmost child and the leftmost sibling respectively. \nAn obvious advantage of our approach over previous work based on macro/high-level tree transducers is \nthat we can handle programs that take multiple XML documents. Let S= {addr . 2, doc . 1, e, pc . 0} and \nM =(S, {q0,q1,q2}, .,q0) where .= {(q0, doc,q1), (q1, addr,q2q1), (q2, pc,E), (q1, e,E)}. M accepts (the \nbinary tree representation of) trees of the form doc(addr(pc) * ), i.e. documents containing a sequence \nof address data addr(pc) (the terminal e represents the end of a sequence). Consider the following HMTT: \nMergeAddr x y = case x of doc x1 => doc(MergeAddr x1 y) | addr x1 x2 => addr (M x1) (MergeAddr x2 y) \n|e=>M y|pc=>pc. Mx =case xof doc x1=> Mx1 | addr x1 x2 => addr (M x1) (M x2) | e=> e| pc => pc. It takes \ntwo documents of the form doc(addr(pc) * ) as input, and merges them into one document. One can verify \nthat, given two valid documents (of type doc(addr(pc) * )), T produces another valid document, by checking \nthat |=(T , M, M, M) holds. For another example, consider the following HMTT T ,which removes all the \nb nodes occurring as descendants of a nodes. RemoveB x= Fx G. Fx g= case xof doc y=> doc (F yg) |a xy \n=>a (g x)(F yg) |b xy =>b (F xg) (Fy g) |pc => pc| e=> e. Gx =case x ofdoc y =>doc (G y) | bx y=> (Gy) \n|axy=>a (Gx)(G y) |pc =>pc| e=> e. The non-terminal F represents a higher-order function, which takes \natree x and a function g, and applies g to the child of each a node. Let M1 be an automaton that accepts \nbinary tree representation of trees of the form doc(t * ) (where doc does not occur in t), and M be an \nautomaton that accepts only trees in which b does not occur below a (in the corresponding unranked representation). \nThen, it can be veri.ed that |=(T , M1, M) holds.  7.3 String Analysis Our HMTT veri.cation algorithm \nis also applicable to string anal\u00adysis, whose goal is to statically check that, given valid strings as \ninput, a program generates a valid string. String analyses have been extensively studied in the context \nof Web applications, to guarantee the well-formedness of output HTMLs [29] or detect security vulnerabilities \nsuch as SQL-injection or cross-site script\u00ading [12, 15, 38]. They are also applicable to other application \ndo\u00admains such as static resolution of dynamically speci.ed resource names [24, 33]. A (regular) string \nanalysis problem can be encoded to an HMTT veri.cation problem by representing strings as linear trees. \nFor example, the function replace that takes three strings sa,sb and x and returns the string obtained \nby replacing each occurrence of a and b in x with sa and sb respectively, can be represented as the following \nHMTT: Replace sa sb x = Conv sa (C1 sb x). C1sb x u=Conv sb(Repl xu). Replxuv= casexof a(y) => u(Repl \ny u v) | b(y) => v(Repl y u v) | e=> e. Conv xk =case x ofa(y) =>Conv y (C2 ka) | b(y) => Conv y (C2 \nk b) |e=>k I. C2k yz =k(Concat y z). Concat x yz =x(y z). Ix =x. Here, Conv and Concat are generic functions \nto express a string\u00adprocessing program as an HMTT. Conv converts an input string to a function of type \no . o, which is used as an internal representa\u00adtion of strings. For example, a string ab (represented \nas a(be))is converted to a function .x.a(b x). By using the internal representa\u00adtion, string concatenation \nis expressed as Concat as de.ned above. Let A and B be regular word languages. Then one can verify that \n* b * e . A * B * T : A . B . ae (i.e. given elements of A and B, * b * and an element of of ae, T produces \nan element of A * B * e). The function Replace sa sb is equivalent to the word homo\u00admorphism h(a)= sa,h(b)= \nsb. We can also encode an arbitrary non-deterministic .nite state transducer (FST) by linear HMTT. Homomorphisms \nand FSTs sub\u00adsume a large class of practical sanitization; For example, let S= {a . 1,b . 1,r . 1,e . \n0} and suppose r stands for a dan\u00adgerous meta-character (such as tag-markers < and > of XHTML). Then, \nreplace s. x, replacement of r by s., represents the saniti\u00adzation of r. One can verify the image (replace \na b s.)(A * ) does not contain an occurrence of r as long as s. does not. Sanitization of sequences (such \nas the <script> tag of XHTML) can also be veri.ed by encoding FSTs. Interestingly, we can allow arbitrary \nuse of string homomor\u00adphisms in a string-processing program (even inside recursion), by choosing an appropriate \ninternal representation of strings. Con\u00adsider strings over {a, b} *. Then, we can use a function of type \nstr =(o . o) . (o . o) . o . o as the internal rep\u00adresentation of a string. Intuitively, the .rst two \nparameters of type o . o represent the homomorphism images of a and b respec\u00adtively, while the last parameter \nis the suf.x of a string. (Thus, it is similar to the Church encoding of natural numbers.)  We can de.ne \nprimitive functions on strings as follows. Axaxbz =xa z. Bxaxbz =xb z. Empty xa xb z= z. Concat s1s2 \nxa xbz =s1 xa xb(s2 xa xbz). I2Str x = case x of e => Empty | a(y) => Concat A (I2Str y) | b(y) => Concat \nB (I2Str y). Str2O s =s ab e. Hom sa sbs xaxb z= s(sa xa xb) (sb xaxb) z. A, B,and Empty are internal \nrepresentations of a, b, and an empty string respectively. The non-terminal Concat represents the con\u00adcatenation \nof (internal representations of) two strings. I2Str and Str2O convert an input string to the internal \nrepresentation, and the internal representation to an output string, respectively. The non\u00adterminal Hom \nrepresents a generic homomorphic function, such that Hom sa sb is a string homomorphism that replaces \na and b with sa and sb respectively. Consider the following HMTT: HomRep n s = F n (Hom (Concat B B) \nA) (I2Str s). Fnhs= casenofzero=>(Str2Os) | succ(m) => F m h (h s). It takes a natural number n and a \nstring s as an argument, and ap\u00adplies the homomorphism {a . bb, b . a} n times. We can verify, * (b * \nfor example, that if n is even and s is an element of a (e)),then so is the output.  7.4 Veri.cation \nof Programs Manipulating Other Algebraic Data Structures Our veri.cation framework is also applicable \nto functional pro\u00adgrams manipulating other algebraic data structures. The following HMTT takes two natural \nnumbers as input and returns the multiplication. Mult x y=case xof zero => zero | succ(z) => Add y (Mult \nz y). Add xy =case x ofzero =>y | succ(z) => succ(Add z y). By using our algorithm, we can verify that, \ngiven an even number and an odd number, the HMTT returns an even number. The following HMTT takes nested \nlists (of elements a and b)as inputs, and returns a .at list. Flatten x = F x nil. Fx z= casexofnil=>z \n| consx1x2=>Fx1(Fx2z) |a =>cons a z |b =>cons b z. We can verify that, given an arbitrary nested list, \nthe HMTT returns a .at list. 8. Preliminary Experiments To evaluate the effectiveness of our veri.cation \nframework, we have extended the implementation of TRECS [18, 19], a model checker for recursion schemes, \nto handle recursion schemes with .nite data domains. The transformation from HMTT to recursion schemes \nwith .\u00adnite data domains has not been implemented yet, so that we have manually translated HMTTs in the \nexperiments below. For the ex\u00adperiments on XML processing programs, automata have been au\u00adtomatically \ngenerated from DTD-like de.nitions. Table 1 shows the result of preliminary experiments. The exper\u00adiments \nwere conducted on a machine with Intel(R) Xeon(R) CPU 3GHz and 2GB memory. The columns O , R , S show \nthe order, the number of rules, and the size of HMTTs respectively. Here, the order of an HMTT is the \nlargest order of the sorts of non\u00adterminals. The order of a sort is de.ned by: order(i)= order(o)=0 order(.1 \n. .2)= max(order(.1)+1, order (.2)) The size of an HMTT is measured by the number of symbols oc\u00adcurring \nin the righthand side of the rewriting rules. The column L shows whether the HMTT is linear (L) or not \n(NL). The column Q shows the sum of the numbers of the states of automata for the input speci.cation \n(M1,...,k) and the output speci.cation (M). All the automata used for the experiments are deterministic. \nThe column Y/N shows whether the HMTT was veri.ed (Y) or re\u00adjected (N) (note that because of the incompleteness \nfor non-linear HMTTs, a valid HMTT veri.cation problem may be rejected). The column T shows the running \ntime of TRECS (thus, excluding the time for transformation from HMTT to RSFD, which is currently manual), \nmeasured in milli-seconds. The programs in the .rst group (from Rev to Flatten)have been taken from the \nexamples already shown in the paper; the name of each program indicates the start symbol of the corresponding \nexample in the paper. All of them have been correctly veri.ed in a few milliseconds, except that it took \n29 milliseconds for HomRep (the last example in Section 7.3). REMARK 8.1. Note that Mult is non-linear, \nbut it is veri.ed cor\u00adrectly. If the property of Mult were Given an even number x and a number y, Mult \nxy returns an even number , then our veri.er would report a false alarm. To avoid the false alarm, we \nneed to either swap the arguments x and y, or transform Mult into a linear HMTT. D The programs in the \nsecond group have been taken from Tozawa s experiments [34] (which are the only experimental re\u00adsults \non exact type checking of high-level tree transducers in the literature, to our knowledge) and rewritten \nin HMTTs. The pro\u00adgram app fo takes a document of the following DTD: type Input = doc[Preface, (Div|P|Note)*] \ntype Preface = preface[Header, P*] type Header = header[] typeP =p[] type Div = div[(Div|P|Note)*] type \nNote = note[P*] Then, it inserts an appendix node to the end of the document, and moves preface and \nnote nodes in the original document to the appendix. The program appx fo works almost the same as appendix \nexcept that it transforms the document into an XHTML document. The program gapid takes a document of \nthe DTD of appendix extended with a nodes, as well as another tree as ar\u00adguments. It checks whether the \nchildren of each node are empty, and if so, replaces the empty children with a hole. The program then \ninserts a given tree to the holes. The programs xml rep1 and xml rep2 are the same, and differ only in \ntheir output spec\u00adi.cations. They take a document of the same type as gapid and a tree with a hole, and \nthen replace each div node of the docu\u00adment with a tree obtained from the input tree with a hole by insert\u00ading \nthe child of div node to the hole. The output speci.cation of xml rep2 is not satis.ed, so the model \nchecker (correctly) rejected it with a counterexample. All the programs in the second group  Programs \nO R S L Q Y/N T Rev 1 2 14 L 4 Y 1 Merge 1 5 47 L 3 Y 1 AccFile 1 2 9 L 4 Y 1 MergeAddr 1 3 26 L 6 Y \n1 RemoveB 2 4 36 L 7 Y 1 Replace 2 8 45 L 4 Y 1 HomRep 4 10 53 L 4 Y 29 Mult 1 3 18 NL 4 Y 1 Flatten \n1 3 17 L 4 Y 1 app fo 1 6 171 NL 21 Y 5 appx fo 1 5 174 NL 19 Y 6 gapid 3 10 94 L 30 Y 87 xml rep1 3 \n8 84 L 23 Y 3 xml rep2 3 8 84 L 23 N 1 XhtmlS id 1 1 113 L 24 Y 11 XhtmlS div 1 1 110 L 24 N 2 XhtmlS \nm 1 1 110 L 24 Y 18 XhtmlS div 1 2 161 L 24 N 2 XhtmlS a 1 2 161 L 24 Y 17 XhtmlM id 1 1 168 L 64 Y \n395 XhtmlM div 1 1 165 L 64 N 4 XhtmlM m 1 1 165 L 64 Y 138 XhtmlM div 1 2 232 L 64 N 5 XhtmlM a 1 2 \n232 L 64 Y 291 XhtmlF id 1 1 398 L 100 Y 13,889 Table 1. Experimental Results have been correctly veri.ed \n(or rejected) in less than 100 millisec\u00adonds. Tozawa [34] reported that it took from 600 milliseconds \nto 2.2 seconds for his system to check programs of the same function\u00adality.3 The programs in the third \ngroup are those manipulating XHTML documents. We have used two subsets of XHTML speci\u00ad.cation (indicated \nby XhtmlS and XhtmlM in the table), and the full XHTML speci.cation (indicated by XhtmlF in the table). \nThe sub\u00adset XhtmlS consists of the tags <div>, <p>, <a>, <img/>, <br/> and <h1> to <h6>, which are most \ncommonly used. XhtmlM addi\u00adtionally has the tags <table> <ol>,<ul>,<li>,<dl>,<dt>, <dd>, and <form>. \nWe have tested .ve operations: * id just outputs a copy of a given input document, * div removes all \nthe nodes la\u00adbeled by div (hence the output is an invalid document), and *m removes all the meta nodes \nin the header. The program * div re\u00admoves only the tags div, instead of removing all the nodes under \ndiv,and *a removes the tags a. For the subsets of XHTML (XhtmlS and XhtmlM), all the ex\u00adamples have been \nveri.ed or rejected correctly in less than a sec\u00adond. For the full XHTML, it took more than 10 seconds \neven for the identity function. This indicates that there is a problem in the scalability of our veri.cation \ntechnique to large input/output speci\u00ad.cations. For MTTs, Frisch and Hosoya [10] report that they could \nverify MTTs on the full XHTML in about a second. 9. Related Work From the viewpoint of program veri.cation, \nthere are at least three threads of related work: model checking of higher-order recursion schemes, exact \ntype-checking for macro/high-level tree transduc\u00aders, and string analysis. 3 This is according to Tozawa \ns slides presented at the conference;the pa\u00adper [34] does not report experimental results.   Model \nchecking of recursion schemes have been extensively studied [1, 2, 11, 16, 17, 32]. Higher-order grammars \n(where non\u00adterminals can generate functions rather than words or trees) re\u00adlated to higher-order recursion \nschemes have been introduced in early 70 s [35, 37], and actively studied in 80 s. [4]. Knapik et al. \n[17] studied the model checking problem for recursion schemes in the present form, and showed that the \nmodal mu-calculus model checking of safe recursion schemes is decidable. Ong [32] extended the decidability \nresult to arbitrary recursion schemes (without the safety condition). Kobayashi [20] showed that the \nresource usage veri.cation of functional programs [14] (which subsumes other standard veri.cation problems \nsuch as reachability and control .ow analysis) can be reduced to model-checking problems for recur\u00adsion \nschemes. Kobayashi [18] then constructed a model-checker for recursion schemes, demonstrating that the \nprogram veri.cation method based on recursion schemes may be feasible in practice, despite the extremely \nhigh worst-case time complexity. The present work is built on these results, and extend them to deal \nwith higher\u00adorder, multi-parameter tree transducers (while recursion schemes are just tree generators, \ninstead of tree transformers). The exten\u00adsion signi.cantly widens application domains of the veri.cation \nframework, as discussed in the present paper. In the context of exact type-checking of XML processing \npro\u00adgrams, a lot of variations of macro/high-level tree transducers have been studied [25, 27, 28, 34]. \nA nice feature of those tree trans\u00adducers is that the class of regular tree languages is closed un\u00adder \nthe inverse of transducers, and that the inverse image is in\u00addeed computable. Thus, given a transducer \nveri.cation problem T (L1) . ? L2 (where L1 and L2 are regular languages), one can ? reduce it to the \ninclusion problem L1 .T -1(L2) between the regular languages T -1(L2) and L1. This inverse inference \nap\u00adproach is applicable to composition of transducers, and also to the higher-order case (called high-level \ntransducers [8, 34]). On the other hand, our approach can be considered a forward inference ap\u00adproach. \nGiven an input language and an HMTT, our transformation essentially approximates (or precisely models, \nin the case of lin\u00adear HMTTs) the output language by using a recursion scheme. We then check that the \nlanguage represented by the recursion scheme conforms to the output speci.cation.4 Maneth et al. [27] \ntake a for\u00adward inference approach for exact type checking of linear macro tree transducers, and uses \na context-free tree grammar to approxi\u00admate the output language. Our approach may be considered a gen\u00aderalization \nof that approach to higher-order, multi-parameter trans\u00adducers. Advantages of our approach using HMTTs \nare: (i) HMTTs can take multiple input trees, and there is no such restriction that the .rst argument \nmust be an input tree, and (ii) our veri.cation method seems more ef.cient than the previous approach \nbased on the inverse inference for higher-order transducers [34]. For (ii), the inverse inference approach \nsuffers from extremely high time com\u00adplexity for the higher-order transducers [34] or compositions of \nmultiple transducers. On the other hand, limitations of our veri.\u00adcation method are: (i) we have to impose \nthe linearity restriction to ensure completeness, and (ii) the method is not directly appli\u00adcable to \ncomposition of HMTTs (unless speci.cation of interme\u00ad 4 Interestingly, many of the previous papers on \ninverse type inference (e.g. [26]) argue that forward type inference does not work because the image \nof the transformation is not a regular language. For the purpose of checking types, however, it is actually \nunnecessary to compute the image L as a regular language; it is suf.cient that L . R is decidable for \nany regular language R. Combined with the tupling transformation discussed in [23], we can exactly express \nthe image of a high-level tree transducer as a recur\u00adsion scheme, and since the model checking problem \nfor recursion schemes is decidable, the forward inference approach actually works for high-level transducers \n(which subsume most of the other transducers in the literature)!  diate trees are given). As discussed \nin Remark 2.2, however, linear HMTTs are already at least as expressive as compositions of (deter\u00administic) \nmacro/high-level tree transducers studied in the literature. Furthermore, for (ii), one can sometimes \nuse fusion (or deforesta\u00adtion) transformation [36] to compose multiple HMTTs into a single HMTT, and \nthen apply our veri.cation method. As already mentioned, our method can also be applied to string analysis, \nby representing strings as linear trees. Previous ap\u00adproaches to string analysis [3, 29] extract a context-free \ngrammar from a .ow graph or SSA form of a program, and then matches it with an output speci.cation. In \nsuch approaches, information about the output string is approximated at join points of the .ow graph, \nespecially at function calls. Our approach instead models a pro\u00adgram as an HMTT, which naturally models \nhigher-order functions and is more expressive than context free grammars (indeed, order-1 recursion schemes \nare already as expressive as context-free gram\u00admars). Thus, our veri.cation technique would be more precise \nfor analyzing higher-order programs. Another interesting advantage of our approach is that string homomorphisms \ncan be expressed and freely used inside recursion (recall Section 7.3). On the other hand, the previous \napproaches [3, 29] return very conservative approxi\u00admations when string homomorphisms are used in a loop. \nRe.nement types [5, 9] have been used for veri.cation of pro\u00adgrams manipulating algebraic data structures \n(the application do\u00admain discussed in Section 7.4). To our knowledge, most of the pre\u00advious studies on \nre.nement types rely on explicit type annotations (except perhaps the .rst work on re.nement types [9], \nwhich uses a naive .xedpoint algorithm for type inference and does not seem to scale for higher-order \nfunctions). A limitation of our approach is that data structures must be strictly classi.ed into sorts \ni and o. One way to overcome the limitation is to use predicate abstraction for intermediate data structures, \nas suggested in [20]. Another way would be to introduce an explicit coercion operation from trees of \nsort o to sort i, and force a programmer to annotate each coer\u00adcion with a re.nement type speci.cation. \nThen, re.nement type checking of such a program can be reduced to multiple HMTT ver\u00adi.cation problems. \nFor example, let us consider a type checking problem of the following insertion sort: let rec insert \nx y = ... let rec isort x = case x of nil => nil *** abc | cons x1 x2 => insert x1 (coerceo.i (isort \nx2)) Here, suppose that we want to verify that isort takes a sequence consisting of a, b, c and returns \na sequence of the form a * b * c * . The coercion converts the result of isort x2 to an input tree. Thanks \nto the annotation, we should be able to split the above veri.cation problem into the veri.cation problems \nof the following two HMTTs (Isort1 and Isort2): Isort1 xz =case x ofnil => nil | cons x1 x2 => Insert \nx1 z. Isort2 x z = case x of cons x1 x2 => Isort1 x2 z. Isort1 is obtained from the original isort function \nby replacing the *** abc part (coerceo.i (isortx2)) with z. Isort2 corresponds to the part isort x2. \nThen, it suf.ces to check that Isort1 and Isort2 both conform to the speci.cation (a + b + c) * . a * \nb * c * . a * c *. The formalization of this idea is left for future work. b * Intersection type systems \nequivalent to model-checking have been studied by Naik and Palsberg [30, 31]. They considered in\u00adtersection \nan imperative language and did not treat higher-order programs. 10. Conclusion We have introduced a new \nclass of tree transducers called higher\u00adorder multi-parameter tree transducers, and proposed a veri.ca\u00adtion \nalgorithm for them. Compared with our previous veri.cation framework based on recursion schemes [20], \nour new approach sig\u00adni.cantly increases application domains. The result of preliminary experiments is \npromising, although there is still a problem in scala\u00adbility (especially with respect to the size of \nspeci.cations). It is left for future work to investigate whether it is a fundamental limitation of our \nveri.cation framework, or it is just a limitation of the current implementation of the underlying model \nchecker TRECS. References [1] K. Aehlig. A .nite semantics of simply-typed lambda terms for in.nite runs \nof automata. Logical Methods in Computer Science, 3(3), 2007. [2] K. Aehlig, J. G. de Miranda, and C.-H. \nL. Ong. The monadic second order theory of trees given by arbitrary level-two recursion schemes is decidable. \nIn TLCA 2005, volume 3461 of Lecture Notes in Computer Science, pages 39 54. Springer-Verlag, 2005. [3] \nA. S. Christensen, A. M\u00f8ller, and M. I. Schwartzbach. Precise analy\u00adsis of string expressions. In StaticAnalysis, \n10thInternational Sympo\u00adsium,SAS2003, volume 2694 of LectureNotes in Computer Science, pages 1 18. Springer-Verlag, \n2003. [4] W. Dam. The io-and oi-hierarchies. Theoretical Computer Science, 20:95 207, 1982. [5] R. Davies. \nPractical re.nement-type checking. PhD thesis, Pittsburgh, PA, USA, 2005. [6] J. Engelfriet and S. Maneth. \nA comparison of pebble tree transducers with macro tree transducers. ActaInf., 39(9):613 698, 2003. [7] \nJ. Engelfriet and H. Vogler. Macro tree transducers. J. Comput.Syst. Sci., 31(1):71 146, 1985. [8] J. \nEngelfriet and H. Vogler. High level tree transducers and iterated pushdown tree transducers. ActaInf., \n26(1/2):131 192, 1988. [9] T. Freeman and F. Pfenning. Re.nement types for ML. In Proceedings ofACMSIGPLANConference \nonProgramming Language Design and Implementation, pages 268 277. ACM Press, 1991. [10] A. Frisch and \nH. Hosoya. Towards practical typechecking for macro tree transducers. In Database Programming Languages, \n11th Inter\u00adnational Symposium(DBPL2007), volume 4797 of LectureNotes in Computer Science, pages 246 260. \nSpringer-Verlag, 2007. [11] M. Hague, A. Murawski, C.-H. L. Ong, and O. Serre. Collapsible pushdown automata \nand recursion schemes. In Proceedings of 23rd AnnualIEEESymposiumonLogicin Computer Science, pages 452 \n461. IEEE Computer Society, 2008. [12] W. G. J. Halfond and A. Orso. Amnesia: analysis and monitoring \nfor neutralizing sql-injection attacks. In ASE 05: Proceedings of the 20thIEEE/ACMinternationalConference \nonAutomated software engineering, pages 174 183, New York, NY, USA, 2005. ACM. [13] Z. Hu, H. Iwasaki, \nM. Takeichi, and A. Takano. Tupling calculation eliminates multiple data traversals. In Proceedings of \nInternational Conference onFunctionalProgramming, pages 164 175, 1997. [14] A. Igarashi and N. Kobayashi. \nResource usage analysis. ACMTrans\u00adactions on Programming Languages and Systems, 27(2):264 313, 2005. \n[15] N. Jovanovic, C. Kruegel, and E. Kirda. Precise alias analysis for static detection of web application \nvulnerabilities. In PLAS 06:Proceedings of the 2006 workshop on Programming languages and analysis for \nsecurity, pages 27 36, New York, NY, USA, 2006. ACM. [16] T. Knapik, D. Niwinski, and P. Urzyczyn. Deciding \nmonadic theories of hyperalgebraic trees. In TLCA 2001, volume 2044 of LectureNotes in Computer Science, \npages 253 267. Springer-Verlag, 2001. [17] T. Knapik, D. Niwinski, and P. Urzyczyn. Higher-order pushdown \ntrees are easy. In FoSSaCS 2002, volume 2303 of Lecture Notes in Computer Science, pages 205 222. Springer-Verlag, \n2002.  [18] N. Kobayashi. Model-checking higher-order functions. In Proceed\u00adingsofPPDP2009. ACM Press, \n2009. [19] N. Kobayashi. TRECS. http://www.kb.ecei.tohoku.ac.jp/ ~koba/trecs/, 2009. [20] N. Kobayashi. \nTypes and higher-order recursion schemes for ver\u00adi.cation of higher-order programs. In Proceedings of \nACM SIG\u00adPLAN/SIGACTSymposiumonPrinciplesofProgramming Languages, pages 416 428, 2009. [21] N. Kobayashi \nand C.-H. L. Ong. Complexity of model checking recur\u00adsion schemes for fragments of the modal mu-calculus. \nIn Proceedings of ICALP2009, volume 5556 of LectureNotes in Computer Science. Springer-Verlag, 2009. \n[22] N. Kobayashi and C.-H. L. Ong. A type system equivalent to the modal mu-calculus model checking \nof higher-order recursion schemes. In Proceedings ofLICS 2009, pages 179 188. IEEE Computer Society Press, \n2009. [23] N. Kobayashi, N. Tabuchi, and H. Unno. Higher-order multi\u00adparameter tree transducers and recursion \nschemes for program veri\u00ad.cation. A longer version, available from http://www.kb.ecei. tohoku.ac.jp/~koba/papers/hmtt.pdf, \n2009. [24] M. Koganeyama, N. Tabuchi, and T. Tateishi. Reducing unneces\u00adsary conservativeness in access \nrights analysis with string analysis. In APSEC 07:Proceedings of the 14thAsia-Paci.c SoftwareEngineer\u00adingConference, \npages 438 445, Washington, DC, USA, 2007. IEEE Computer Society. [25] S. Maneth, A. Berlea, T. Perst, \nand H. Seidl. XML type checking with macro tree transducers. In Proceedings of the Twenty-fourth ACM \nSIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems(PODS 2005), pages 283 294, 2005. [26] \nS. Maneth and K. Nakano. XML type checking for macro tree trans\u00adducers with holes. In Programming LanguageTechnologiesforXML \n(PLAN-X), 2008. [27] S. Maneth, T. Perst, and H. Seidl. Exact XML type checking in polynomial time. In \nICDT 2007, volume 4353 of Lecture Notes in Computer Science, pages 254 268. Springer-Verlag, 2007. [28] \nT. Milo, D. Suciu, and V. Vianu. Typechecking for XML transformers. J. Comput.Syst. Sci., 66(1):66 97, \n2003. [29] Y. Minamide. Static approximation of dynamically generated web pages. In Proceedings of the \n14thinternational conference onWorld WideWeb(WWW 2005), pages 432 441. ACM Press, 2005. [30] M. Naik. \nA type system equivalent to a model checker. Master Thesis, Purdue University. [31] M. Naik and J. Palsberg. \nA type system equivalent to a model checker. In ESOP 2005, volume 3444 of LectureNotes in Computer Science, \npages 374 388. Springer-Verlag, 2005. [32] C.-H. L. Ong. On model-checking trees generated by higher-order \nrecursion schemes. In LICS 2006, pages 81 90. IEEE Computer Society Press, 2006. [33] J. Sawin and A. \nRountev. Improving static resolution of dynamic class loading in java using dynamically gathered environment \ninformation. Automated SoftwareEngg., 16(2):357 381, 2009. [34] A. Tozawa. XML type checking using high-level \ntree transducer. In Functional and LogicProgramming,8th International Symposium (FLOPS2006), volume 3945 \nof LectureNotes in Computer Science, pages 81 96. Springer-Verlag, 2006. [35] R. Turner. An in.nite hierarchy \nof term languages -an approach to mathematical complexity. In Proceedings ofICALP, pages 593 608, 1972. \n[36] P. Wadler. Deforestation: Transforming programs to eliminate trees. Theoretical Computer Science, \n73(2):231 248, 1990. [37] M. Wand. An algebraic formulation of the chomsky hierarchy. In CategoryTheoryAppliedto \nComputation and Control, volume 25 of LectureNotes in Computer Science, pages 209 213. Springer-Verlag, \n1974. [38] G. Wassermann and Z. Su. Static detection of cross-site scripting vulnerabilities. In ICSE \n08: Proceedings of the 30th international conference on Software engineering, pages 171 180, New York, \nNY, USA, 2008. ACM. Acknowledgments We would like thank Akihiko Tozawa and Yasuhiko Minamde for discussions \nand information about their work. We would also like to thank Luke Ong and anonymous reviewers for useful \ncomments. A. High-Level Tree Transducers and Linear HMTTs This section shows that high-level tree transducers \n[8] (which sub\u00adsume macro tree transducers) can be transformed into a linear HMTT. In essence, a (deterministic) \nhigh-level tree transducer is a higher-order function on trees (of sort o) de.ned by induction on input \ntrees (of sort i). Let us .x the input alphabet SI = {a1 . k1,...,an . kn}. A high-level tree transducer \n(N , SI , SO, R,F1) is a restriction of HMTT, where the rewriting rules are only of the form: F1 xye1 \n. case(x, xe1.t1,1,...,xen.t1,n) \u00b7\u00b7\u00b7 Fm xyem . case(x, xe1.tm,1,...,xen.tm,n) Here, x has sort i and \nit may not occur in t1,1,...,t1,n,...,tm,1,...,tm,n. The sort of each non-terminal must be of the form \ni . .1 . \u00b7\u00b7\u00b7 . .l . o,where i does not occur in .1,...,.l. F1 has sort i . o (so, ye1 is the empty sequence). \nFurthermore, input trees are restricted to .nite ones. In the original de.nition of higher-level tree \ntransducers, there is a further restriction that .1 . \u00b7\u00b7\u00b7 . .l . o must be derived types [8]; We do not \nimpose that restriction. By using the tupling transformation [13], we can transform the above HTT into \nthe following linear HMTT: Sx . Gx Proj Proj y1 \u00b7\u00b7\u00b7 ym . y1 Gxk . case(x, xe1.H1 xe1 k,..., xen.Hn xen \nk) Hi xei k . Gxi,1 (.y1,1,...,y1,m. Gxi,2 (.y2,1,...,y2,m. \u00b7\u00b7\u00b7 Gxi,ki (.yki,1,...,yki,m. k [y1,1/F1 \nx1,1,...,yki,m/Fm xki,m]t1,i \u00b7\u00b7\u00b7 [y1,1/F1 x1,1,...,yki,m/Fm xki,m]tm,i) \u00b7\u00b7\u00b7 )) (i =1,...,n) Here, we \nhave .-abstractions for clarity; they can be removed by lambda-lifting. The term [y1,1/F1 x1,1,...,yki,m/Fm \nxki,m]t1,i denotes the term obtained by replacing Fj x1,j in t1,i with y1,j . (Note that by the restriction \non the sorts of Fj , x1,j may occur only as the .rst argument of Fj .) In the above rules, Gxk com\u00adputes \na sequence of values of F1 x,..., Fm x and applies k to them (so, Gxk is intuitively the same as k (F1 \nx) \u00b7\u00b7\u00b7 (Fm x)). To compute Gxk, it .rst performs a case analysis on x.If e e x is ai ti, Hi is called. \nHi ti k .rst computes the values of F1,...,Fm for t1,1,...,ti,ki . It then computes F1 x,...,Fm x (i.e., \nt1,i,...,tm,i), and passes it to k. The HMTT obtained by the above transformation is linear, and outputs \nthe same tree as the original HTT, given a .nite tree as in\u00adput. (That is not always the case if an input \ntree is in.nite, since the evaluation order has been changed by the tupling transformation.)  \n\t\t\t", "proc_id": "1706299", "abstract": "<p>We introduce higher-order, multi-parameter, tree transducers (HMTTs, for short), which are kinds of higher-order tree transducers that take input trees and output a (possibly infinite) tree. We study the problem of checking whether the tree generated by a given HMTT conforms to a given output specification, provided that the input trees conform to input specifications (where both input/output specifications are regular tree languages). HMTTs subsume higher-order recursion schemes and ordinary tree transducers, so that their verification has a number of potential applications to verification of functional programs using recursive data structures, including resource usage verification, string analysis, and exact type-checking of XML-processing programs.</p> <p>We propose a sound but incomplete verification algorithm for the HMTT verification problem: the algorithm reduces the verification problem to a model-checking problem for higher-order recursion schemes extended with finite data domains, and then uses (an extension of)Kobayashi's algorithm for model-checking recursion schemes. While the algorithm is incomplete (indeed, as we show in the paper, the verification problem is undecidable in general), it is sound and complete for a subclass of HMTTs called <i>linear HMTTs </i>. We have applied our HMTT verification algorithm to various program verification problems and obtained promising results.</p>", "authors": [{"name": "Naoki Kobayashi", "author_profile_id": "81100603931", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P1911152", "email_address": "", "orcid_id": ""}, {"name": "Naoshi Tabuchi", "author_profile_id": "81361594569", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P1911153", "email_address": "", "orcid_id": ""}, {"name": "Hiroshi Unno", "author_profile_id": "81100097133", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P1911154", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706355", "year": "2010", "article_id": "1706355", "conference": "POPL", "title": "Higher-order multi-parameter tree transducers and recursion schemes for program verification", "url": "http://dl.acm.org/citation.cfm?id=1706355"}