{"article_publication_date": "01-17-2010", "fulltext": "\n Nominal System T AndrewM. Pitts * UniversityofCambridgeComputerLaboratory,Cambridge,UK Andrew.Pitts@cl.cam.ac.uk \nAbstract This paperintroducesanewrecursionprincipleforinductive data modulo ..-equivalenceofbound names.It \nmakesuseofOdersky\u00adstylelocal names whenrecursing over bound names. Itisformu\u00adlatedinanextensionofG\u00a8odel \nsSystemT with namesthat canbe testedforequality, explicitly swappedinexpressionsand restricted to a lexical \nscope. The new recursion principle is motivated by the nominal sets notion of ..-structural recursion \n, whose use of names and associated freshness side-conditions in recursive de.\u00adnitionsformalizes common \npracticewithbinders.The new Nom\u00adinal System T presented here provides a calculus of total func\u00adtions \nthat is shown to adequately represent ..-structural recursion whileavoidingtheneedtoverifyfreshnessside-conditionsin \nde.\u00adnitions andcomputations.Adequacyisprovedviaa normalization\u00adby-evaluationargumentthatmakes useof a \nnewsemanticsoflocal namesinGabbay-Pittsnominal sets. Categories and Subject Descriptors D.3.1[Programming \nLan\u00adguages]: FormalDe.nitions andTheory Syntax; D.3.3[Pro\u00adgramming Languages]: Language Constructs and \nFeatures Re\u00adcursion; F.4.1 [Mathematical Logic and Formal Languages]: MathematicalLogic Lambda calculusand \nrelated systems General Terms Languages,Theory,Veri.cation Keywords binders, alpha-equivalence, recursion,types \n1. Introduction When developing mathematical semantics for programming lan\u00adguages,itis commonplacetoignoreconcrete \nsyntax andwork at thelevelof abstract syntaxtrees.Indeed,if thelanguageinvolves binding constructs(asmostdo), \none usually raisesthelevelof abstraction even further by implicitly quotienting abstract syntax trees \nby an appropriate notion of ..-equivalence.Working modulo ..-equivalenceaffectshow one de.nesfunctionsbystructuralre\u00adcursion \nand provesproperties ofthemby structuralinduction the fundamental tools of programming language semantics. \nFor ex\u00adample,theparametersof a recursivelyde.nedfunction canhave their bound names changed as necessary, \nbut one is obliged to provethatthevalueofthede.nedfunctionisindependentof such changes.Such proofsof \nwell-de.nedness upto ..-equivalence are * Research supportedbyUKEPSRCgrantEP/D000459/1 Permissiontomake \ndigitalorhard copiesofallorpart of thisworkforpersonalor classroom useisgranted withoutfeeprovidedthatcopies \nare not made or distributed forpro.torcommercialadvantageandthatcopiesbearthis noticeandthefullcitation \nonthe.rst page.Tocopyotherwise,torepublish,topost onserversortoredistribute tolists,requirespriorspeci.cpermission \nand/orafee. POPL 10, January17 23, 2010,Madrid,Spain. Copyright c . 2010ACM978-1-60558-479-9/10/01... \n$10.00 often omitted as obvious.Thispaperpresents a calculus of(to\u00adtal, higher-order) functions with \nstructural recursion modulo ..\u00adequivalence for which such proofs of well-de.nedness really are obvious,indeed \nareentirely automatic,being subsumedbyacom\u00adpletely conventionaland decidabletype system.Thisis achieved \nwithout giving up on the practically convenient nominal treat\u00admentof bindingin which bound namesare.rst-class \ncitizensthat canbetestedforequality,passedtofunctionsasargumentsandre\u00adturned as results.Wecallthe calculuspresentedinthispaperNomi\u00adnal \nSystem T sinceittakesG\u00a8odel sSystemTforprimitiverecursive functionsofhighertype[13](formulated asatyped..-calculus, \nfol\u00adlowingTait[34]) and generalizesfrom numberstoinductive data modulo ..-equivalenceofbound names.Tobringouttheideas \nun\u00adderlying our approach without too much syntactic clutter, we use thefamiliarandsimpleexampleof suchdata,thetermsoftheun\u00adtyped..-calculus[2] \n. . {.. ::= .. | .... | ..... ..} (1) where .. rangesoveranin.nite set .. ofvariables and whereterms \nare identi.ed upto the usual notion of ..-equivalence(=..)for ..\u00adbound variables. When making a structurally \nrecursive de.nition of a function .. :. . .. in termsoffunctions ..1 : .. . .., ..2 :. . . . .. . .. \n. .. and ..3 : .. . . . .. . .., one cantake advantageofthe identi.cation of terms upto =.. byrestrictingthe \napplicability of the recursion equationfor ..-binders: . .... = ..1 .. . .. (.... ' )= ..2 .... ' (....)(.... \n' ) (2) . ../. .. . .. (..... ..)= ..3 .... (....). Thus in the third clause we restrict the recursion \nequation to ap\u00adply only for bound variables .. that avoid some .nite set .. of variables typically the \nones that are involved in the de.nition of the functions ..1,..2,..3. For example, the function .. (-)= \n(-)[.. ' /.. ' ]:. . . for capture-avoiding substitution of .. ' . . for .. ' . .. isgivenbytaking ..1 \n.. . if .. = .. ' then .. ' else .., ..2 .... ' .... ' . .... ' , ..3 .... .. . ..... .. and .. tobethe.nite \nset con\u00adsisting of .. ' andthe freevariablesof .. ' . Of course,for(2) tospecify awell-de.nedfunctionon \n..\u00adequivalence classes, the function ..3 ingeneralhasto satisfyacon\u00addition ensuring independence of the \nde.niens in the third clause from choice of the bound variable .. used to represent the ..\u00adabstraction \n..... .. in thede.niendum.Whatkindofconditionshould we impose on ..3 to ensure this? The notion of ..-structural \nre\u00adcursion gives an answer to this question in terms of the nominal sets[11,25].Webrie.y recallwhatisinvolved; \nseePitts[26]for thefull story. Themainideaistotake accountof name-permutations,which meansfortheexamplewe \nareusing,.nite permutations .. of the set ...A nominal set is a set .. equipped with an action of such \npermutations (written .., .. . .. \u00b7 ..)forwhich every .. . .. is .nitely supported.This means thatgiven \n..,thereisa.nite subset .. . .. suchthat for any .., .. ' . .. - ..,the permutation (.... ' ) that swaps \n.. and .. ' leaves .. invariant: (.... ' ) \u00b7 .. = ...Complementary to.nite supportisthe notionoffreshness:wesay \n.. is fresh for .. and write .. # .. if .. is supportedbysome.nite set not containing ...For example, \npermutations act on elements of .. byapplication and this makes .. into a nominal set with the relation \noffreshness being not equal .Moregenerally, . equipped with the obvious permutation action is a nominal \nset and freshness is the not a free variable of relation. The fun begins at higher types. Given nominal \nsets .. and .. , the nominal set .. -fs .. consists not of all functions .. from .. to .. , but just \nthe ones that are .nitely supportedwithrespecttotheusual permutationactiononfunctions; that .. is supportedby \n.nite.. . .. amounts to requiringfor any .., .. ' . .. - .. and .. . .. that .. ((.... ' ) \u00b7 ..)=(.... \n' ) \u00b7 (....).Using theseconcepts Pitts[26,Remark4.4]proves:  ..-Structural Recursion Principle for \n.. Given .nitely sup\u00adported functions ..1 . .. -fs .., ..2 . . -fs . -fs .. -fs .. -fs .. and ..3 . .. \n-fs . -fs .. -fs .., supported by .. . .. say, suppose ..3 satis.es the following freshness condition \nfor binders :1 ... . .. - ...... . ..... . ... .. # ..3 .... ... (FCB) Then there is a unique function \n.. . . -fs .. satisfying the scheme (2), necessarily also .nitely supported by ... For the example of \ncapture-avoiding substitution mentioned above,(FCB) holds because ..3 .... .. = ..... .. and .. # ..... \n.. since for any ..-term .. . ., .. is notfreein..... ... TheNominal packageofUrban andBerghofer[35]fortheIs\u00adabelleproof \nassistantimplements ..-structuralrecursion(and more) within Isabelle/HOL. Growing experience with Nominal \nIsabelle suggests that, despite the need to prove lemmas about freshness, thisisaconvenientformalizationwithinhigher-orderlogicofstruc\u00adturalrecursioninthe \npresence of binders.However,thosefreshness side-conditions meanthat ..-structuralrecursionisnotaconvenient \nbasisfor a calculus,as opposedtoalogic,of recursivefunctions modulo .. .We willshowhowtomodifyitsothatgiven \n..1,..2,..3, thereisalwaysa well-de.ned .. withgood computationalproper\u00adties withoutthe needto prove(FCB). \nFreshML[31,33]achievesthiswithinthecontextof animpure functionalprogramming language; freshness conditions \nget auto\u00admatically satis.edby dynamically allocatingfresh names atrun\u00adtime.Stateful operationalsemanticsdo \nnotgiveriseto equational calculi with goodlogicalproperties.Indeed,evensuchanappar\u00adentlysimple computational \neffect as dynamic allocation of names is knowntointeractin complicatedwayswithhigher-orderfunc\u00adtions[27];forexample,functionexpressions \ncanfailto behaveex\u00adtensionally[28,Example1.2].Insteadoftryingtotame dynamic allocationinthiscontext[30], \nhereweproposetoavoiditalto\u00adgetherby using(atypedversionof) the purefunctionaltheory of local names ofOdersky[21].Wegivethisa \ndenotationalseman\u00adticsusing nominal sets,whichinturn suggestsadding anexplicit name-swapping operationtoOdersky \ns calculus.Odersky stheory oflocal namesmay seemtoosimple: comparedwiththe ..-calculus ofPittsandStark[27]thereisnoscopeextrusionoflocal \nnames fromfunctionarguments andnosharingoflocal names between components of a tuple. Nevertheless, with \nthe addition of name\u00adswappingitallowsustoformulatea new calculusofhigherorder recursivefunctions over \n. that we prove adequatelyrepresents ..\u00adstructural recursion. Contributions of this paper. Wegiveanew(and \nsimple)seman\u00adticsforOdersky-stylelocal namesbased uponthenotionofaname\u00adrestriction operator in the Gabbay \nand Pitts [11] model of names 1(FCB) is equivalent to the apparently weaker condition that there is some \n../. .. satisfying ... . ..... . ... .. # ..3 .......    and binding (De.nition 1). This model suggests \nan extension of G\u00a8odel ssystemTwithlocal namesthat canbetestedforequality and explicitly swappedinexpressions.The \nresulting Nominal Sys\u00adtem T contains aground type Trm whose terms represent ..-terms modulo ..-equivalenceofbound \nnames;italso containsarecursion combinatorthatmakesuseoflocal nameswhenrecursingoverdata representing \n..-abstractions(see (..L) inFig.3).Weconsider gen\u00aderalizationstootherdatawithbinders besides ..-termsinSect.7; \nthegeneralizationrelies uponthenew observationfor nominal sets that concretionof atom-abstractions canbe \nmadeatotalfunction inthepresenceof name-restriction (Theorem22). Weidentifyanotionof..-long ..-normalformforthewell-typed \nexpressionsofNominalSystemTandprovethatevery well-typed expressionisconvertibletosuchanormalform,uniqueuptoasim\u00adplestructural \ncongruence(Theorem 10).The proof ofthisis viaa versionofthe normalizationbyevaluation technique encompass\u00adingstructuralcongruenceofnormalforms \n(De.nition 15).Armed with this normalization property, we show that functions de.ned bythe ..-StructuralRecursionPrinciple \nfor . described above, can befaithfully represented inNominalSystemT(Theorem21).In this way we achieve \nthe aim of producing an expressive calculus of higher-order recursive total functions that avoids the \nneed for freshness conditionswhen de.ningand computing.Indeed,Nom\u00adinalSystemThasacompletely conventionaltype \nsystem andall freshness conditions associated with..-equivalence are elevatedto the meta-level. 2. Syntax \nand Semantics ThetypesandexpressionsofNominalSystemTaregiveninFig1. Thepartbelowthedottedlinesiswhatisbeing \nadded toG\u00a8odel s SystemT.Therearetwonew groundtypes: Atm classi.es names of object-level variables, and \nTrm classi.es terms of the object\u00adlanguage,whichwetaketobethe untyped..-calculus.Expressions may involve \ntwo different kinds of identi.er: variables .. . .., standingforunknownexpressions,and atomic names .. \n. ..,stand\u00adingfor unknownobject-levelvariables.Bothkindsofidenti.ermay be bound:thebindingformsarefunctionabstraction \n..... (-),name restriction ..... (-) and object-level ..-abstraction L... (-).Asdis\u00adcussedintheIntroduction,followingtheusualinformal \npractice ex\u00adpressions are implicitly identi.ed up to ..-equivalence of these bound identi.ers. To simplify \nthe presentation of the syntax we use Church\u00adstyle explicitly-typed variables.2 Thus we assume the countably \nin.nite set .. is partitionedintodisjoint, countably in.nite subsets ..(.. ) as .. ranges over types; \nthe elements of ..(.. ) are the vari\u00adables of type .. .Figure2givesthe inductive de.nitionof the set \nExp(.. ) of well-typedexpressions for eachtype .. . Typ.Asbe\u00adfore,thetyping rulesbelowthedottedlinearewhatisbeing \nadded toG\u00a8odel sSystemT.There shouldbenosurprisesforthereaderin the new rules: name restriction and name-swapping \ndo not change thetypeoftheexpression actedupon;wehavemade name-equality takeapolymorphic booleantypeinorder \nnottointroduceasepa\u00adrategroundtypeforbooleans;andtheargumentsforTrm-recursion, trec,havetypes asdiscussedintheIntroduction. \nTheintendedmodelofNominalSystemTisinterms ofnom\u00adinal sets [11,25],thede.nition of which was recalledinthe \nIn\u00adtroduction. In other words, expressions denote mathematical ob\u00adjectsthatare.nitelysupportedwithrespecttothe \nactionofpermu\u00adtations of atomic names. Finite permutations can be decomposed into compositions of transpositions; \nand name-swapping expres\u00adsions (..1 ..2)* .. denotethe actionof suchtranspositions.Whatdo expressions \noftheform ..... .. denote?To answerthis questionwe 2 Curry-style , withvariablesassignedtypesby environments,is \npossible andwouldbedesirable fordependently-typed extensionsof thesystem.  .. . Typ ::= .. -> .. functiontype \n| .. groundtype .. ::= Nat type of numbers ..................................................... | Atm \ntype of names | Trm type of object-level..-terms modulo ..-equivalence .. . Exp ::= .. variable(.. . \n..) | 0 zero | S .. successor | nrec .... .. Nat recursion | ..... .. function abstraction | .... function \napplication ................................................... | .. atomic name(.. . ..) | ..... .. \nname restriction | (.. = ..).. name equality | (....)* .. name swapping | V .. object-level variable \n| A .... application term | L... .. ..-abstractionterm | trec .... .... Trm recursion Some de.nedexpressions(where.. \n. .. and .., .. ' . ..(.. )): new . ..... .. true.. . ..... .... ' ... false.. . ..... .... ' ... ' L(.., \n.. ' ) . L... (....)* .. ' where .. is notfreein.. or .. ' Figure 1. Types.. and expressions .. .. . \n..(.. ) .. . Exp(Nat) .. . Exp(.. ) 0 . Exp(Nat) S .. . Exp(Nat) ..1 . Exp(.. ) ..2 . Exp(Nat -> .. -> \n.. ) .. . Exp(Nat) nrec ..1 ..2 .. . Exp(.. ) .. . Exp(.. ' -> .. ) ' '' .. . ..(.. ) .. . Exp(.. ) .. \n. Exp(.. ) ..... .. . Exp(.. -> .. ' ) .... ' . Exp(.. ) ............................................................ \n .. . .. .. . .. .. . Exp(.. ) .. . Exp(Atm) ..... .. . Exp(.. ) ..1,..2 . Exp(Atm) ..1,..2 . Exp(Atm) \n.. . Typ .. . Exp(.. ) (..1 = ..2).. . Exp(.. -> .. -> .. ) (..1 ..2)* .. . Exp(.. ) .. . .. .. . Exp(Atm) \n.., .. ' . Exp(Trm) .. . Exp(Trm) V .. . Exp(Trm) A .... ' . Exp(Trm) L... .. . Exp(Trm) ..1 . Exp(Atm \n-> .. ) ..2 . Exp(Trm -> Trm -> .. -> .. -> .. ) ..3 . Exp(Atm -> Trm -> .. -> .. ) .. . Exp(Trm) trec \n..1 ..2 ..3 .. . Exp(.. ) Figure 2. Well-typed expressions.. . Exp(.. )[.. . Typ] consider nominal sets \n.. equipped with thefollowing extrastruc\u00adture. De.nition 1 (name-restriction operations). A name-restriction \noperation on a nominal set .. is function .. \u00d7 .. . .., written (.., ..) . (....)..,that satis.es(3) \n(6). . .. \u00b7 (....).. =(....(..))(.. \u00b7 ..) (3) .. #(....).. (4) .. # .. . (....).. = .. (5) (....)(.... \n' ).. =(.... ' )(....)... (6) Property(3) saysthefunctionpreservestheactionofpermutations ...Ingeneralthis \npropertyis called equivariance (andimpliesthat thefunctionissupportedbythe emptysetofatoms). Inthepresenceof(3),property(4)isthe \nnominal setswayof modellingthe ..-equivalencethatwehavebuiltintothesyntax of the term-former ..... (-).For \nif .. ' #(.., ..), then by a standard argument, equivariance implies .. ' #(....)... Hence neither .. \n' , nor .. by(4), areinthe support of (....)... Therefore (....).. = (.... ' ) \u00b7 (....).. =(.... ' )((.... \n' ) \u00b7 ..),by equivariance again.Thus (....).. isinvariant underrenaming.. with a fresh atomic name .. \n' . Theothertwoproperties(5) and(6) correspondto basic struc\u00adtural properties of a notion of name restriction. \nStructural con\u00adgruencefor name-restriction.rst arosein connectionwith there\u00adduction semantics ofthe..-calculus[18],whereitinvolves \nscope extrusion propertiesinadditionto(4) (6).Morerecently, Gacek et al.[12,Sect.2.3] callproperty(5) \nstrengthening and(6) ex\u00adchange and use thesestructuralpropertiesinconnection with lo\u00adcally scoped eigenvariablesand \ngenericjudgementsininductive proofs. We can get a name-restriction operation for a nominal set of ..-termsby \nadjoining a constant New to thegrammarin(1) .[New] . {.. ::= .. | .... | ..... .. | New} (7) andde.ning \n(....).. tobe ..[New/..].The groundtype Trm standsfor this nominal-set-with-restriction-operation, .[New]. \nThe ground type Atm stands for a substructure of this, namely ..[New ] . .. .{New };and the ground type \nNat stands for the usual set of naturalnumbers N = {0, 1, 2,...} with trivialpermutationaction (.. \u00b7 \n.. = ..)and trivial name-restrictionoperation((....).. = ..). Forhighertypeswemakeuseofthefollowing newresultabout \nnominal sets. Theorem 2 (name-restriction on functions). Suppose that .. and .. are nominal sets and \nthat .. is equipped with a name-restriction operation ..... Then there is a name-restriction operation \n.. on the nominal set .. -fs .. of .nitely supported functions satisfying .. # .. . ((....).. ).. =(......)(....) \n(8) for all .. . .., .. . .. and .. . .. -fs ... Proof. Given .. . .. and .. . .. -fs ..,wede.ne (....).. \n. .. -fs .. by mapping each .. . .. to '' ' ((....).. ) .. . (...... )(((.... ) \u00b7 .. ) ..) where .. #(.., \n.., ..).(9) Itis not hardto seethattheright-handsideisindependent ofthe choice of .. ';thatthe resultingfunction(....).. \nis .nitelysupported (by .. -{..},if .. supports .. ); and that (.., ..) . (....).. satis.es (3) (6) and(8). \nIn view ofthistheorem,if weinterpretthe groundtypes Nat, Atm and Trm as N, ..[New] and .[New] respectively, \nandinterpret function types using exponentiation (-) -fs (-) in ..om,then every typeofNominalSystemT \ndenotesa nominal setequipped with a restriction operation. These restriction operations are used  (..... \n..) .. ' ..[.. ' /..](..) .. .....(....) if .. # .. (..) when .. . nrec ..1 ..2: .. 0 ..1 (..0) .. \n(S ..) ..2 .. (....)(..S) ........................................................... ..... .. .. if \n.. # .. (..#) ..... .... ' ... .... ' ........ (....) when .., .. ' . .. .{new}: (.. = .. ' ).. true.. \nif .. = .. ' (=..) (.. = .. ' false.. if .. /(=.. ) ).. = .. ' when K = 0, S, V, A: ..... K ... K \n..... ... (..K) (..1 ..2)* (K ...) K ((..1 ..2)* ...)(..K) ..... L.. ' ... L.. ' ...... .. if .. /= \n.. ' (..L) (..1 ..2)* L... .. L... (..1 ..2)* .. if .. #(..1,..2)(..L) ..... ..... .. ..... ..... .. \n(....) (..1 ..2)* ..... .. ..... (..1 ..2)* (..[(..1 ..2)* ../..]) if .. #(..1,..2)(....) (..1 ..2)* \n.. (..1 = ..)Atm ..2 ((..2 = ..)Atm ..1 ..)(....) (..1 ..2)* new new (..new) when .. . trec ..1 ..2 \n..3: .. (V ..) ..1 .. (..V) .. (A .... ' ) ..2 .... ' (....)(.... ' )(..A) .. (L... ..) ..... ..3 \n.... (....) if .. #(..1,..2,..3)(..L) isthe congruencegenerated bythese conversions Figure 3. Conversion \n. Exp(.. ) \u00d7 Exp(.. )[.. . Typ] to interpretname-restrictionexpressions ..... .. of eachtype.Finally, \nNat-recursion expressions nrec ..1 ..2 .. and Trm-recursion expres\u00adsions trec ..1 ..2 ..3 .. areinterpreted \nusingprimitive recursionfor numbersand ..-structuralrecursion[26]for ..-terms(extendedwith a constant \nNew)respectively.We leavethe formaldetailsof this denotational semantics ofNominalSystemTtothefull version \nof this paperand pass onto computationalissues. 3. Conversion Figure 3 gives the notion of expression \nequality that we use for Nominal System T: conversion, .. .. ' [.. . Typ,.., .. ' . Exp(.. )]. Rather \nthan giving a notion of rewriting between ex\u00adpressions andproving canonicity(interesting thoughthatmight \nbe), weprefertogodirectlytoanotionofequalityandprovede\u00adcidability via a normalizationfunction(giveninSect.5).For \none thing, our conversion relation contains reductions, expansions and a structural conversion (....) \nthat has no preferred orientation; so considering conversion rather than reduction seems to make more \nsense. Figure 3 uses the notation ..[.. ' /..] for the capture\u00adavoiding substitution of .. ' for all \nfree occurrences of .. in ...It also uses the notation .. # .. (respectively, .. # ..)to indicate that \n.. is not a free variable (respectively, .. is not a free atomic name) of ...(This coincides with the \nfreshness relation when we regard Exp(.. ) as a nominal set in Sect. 5.) Finally, the .gure also uses \nsome notation in connection with sequences of expres\u00adsions: if ... = ..1......,then ........ . (..... \n..1)..(..... ....) and (.... ' )* ... . ((.... ' )* ..1)..((.... ' )* ....). The conversions be\u00adlowthe \ndottedlineinFig.3 arewhatisbeing addedtoG\u00a8odel s SystemT.Althoughwe omittheproofinthisextendedabstract,it \nis not hardto show: Theorem 3 (soundness). Conversion is sound for equality in the nominal sets model \nsketched in the previous section. Afterthefact,andratherpleasingly,theconversionsinFig.3for ..... (-) \nturn outto agreewiththefunctionaltheoryoflocal names given byOdersky[21]; conversion (....) corresponds \nto his .... reduction, and (..K) tohis .... reduction.The structural conversions (..#) and (....) arenot \nexplicit in Odersky ssystem,but arevalid upto contextual equivalence.However,NominalSystemTtakesa rather \nmore logical viewof name-equality:inOdersky ssystem ..... .. is notavalue(canonicalform)and ..... .. \n== ..... .. is a stuck expression that does not reduce; whereas here ..... .. is a normal form(denotingthe \nconstant New in our nominal sets model)and (..... .. = ..... ..).. is convertible to true.. by the conversion \n(=..). Note that in general .....(.. = .. ' ).. / ((..... ..) = (..... .. ' )).. ;for example,if .. / \n= .. ',then using (=.. ) and (..#) wehave '' ' ......... .(.. = .. ).. ......... . false.. false.. \n(10) whereas, using (..#) and (=..),wehave ((......... ' ...) = (......... ' ... ' )).. (new = new).. \n true.. (11) anditisacorollaryofTheorem3that true.. / false.. .Notealso that although (.......).. ' \n..... (.... ' ) if .. # .. ' (12) is provable from the conversions (..), (..) and (....) in Fig. 3, in \ngeneral .. (..... .. ' ) / ..... (.... ' ).EvidentlyOdersky sisa different notionof local name fromthe \nmore common one(inScheme, ML, Haskell, ...) based on dynamic allocation of globally fresh names.It hasbetterlogicalproperties(forexample,it \ndoes not disturbfunctionextensionality)andisinasense moregeneralthan dynamic allocation, because the \nlatter can be encoded in it via a continuationmonad; cf.ShinwellandPitts[32]. The conversionsinFig.3for \n(..1 ..2)* (-) correspond to the de.ningproperties, at eachtype,of the permutation actioninthe nominal \nsets model.In particular,therather complicatedlooking conversion (....) just re.ectstheusualde.nitionof \ntheactionof permutationsonfunctions(see Pitts[26,Sect.3.2],forexample). The last three conversions in \nFigure 3, (..V) (..L),give the new recursion modulo .. scheme which in Sect. 6 is shown to adequately \nrepresent the ..-structural recursion of Pitts [26]. We give someexamplesofits use. Example 4 (substitution, \nnon-capturing and capturing). Con\u00adsider sub . ..... .......... trec ..1 ..2 ..3 .. . Exp(Atm -> Trm -> \nTrm -> Trm), where ..1 . .... ' . (.. = .. ' )Trm .. (V .. ' ), ..2 . ..... .... ' .......... ' . A .... \n' , ..3 . ..... ..... ..... L(.., ..) and where L(.., ..) . L... (....)* .. is an instance of the def\u00adinition \ngiven at the bottom of Fig. 1. It is a non-binding bi\u00adnary operation for object-level ..-abstraction(theanalogue \nofthe atom-abstraction operation .., .. ' . <..>.. ' in FreshML [33]). If .., .. ' . Exp(Trm), then we \nclaim that sub .. ' .. ' .. represents the capture-avoiding substitution of(the ..-term represented by) \n.. ' for V .. ' in (the ..-term represented by) ...For example, L... V .. ' repre\u00adsents the ..-term ..... \n.. ' ;so, assuming .. and .. ' aredistinct atomic names, sub .. ' (V ..)(L... V .. ' ) shouldrepresent \n(..... .. ' )[../.. ' ],that is, .... '' ... where .. '' =/...Indeed, one can usethe conversion equa\u00adtionsinFig.3tocalculatethat \n sub .. ' (V ..)(L... V .. ' ) ' ''' '' ' = sub .. (V ..)(L.. . V .. ) where .. /= .., .. ' ''' trec \n..1[.. /.., V ../..] ..2 ..3 (L.. . V .. ) ''''' ' ' .... ...3 .. (V .. )(trec ..1[.. /.., V ../..] ..2 \n..3 (V .. )) '' '' .... . L(.. , V ..) '' ''' ''''' ''' ' '' . .... . L.. .(.. .. )* (V ..) where .. \n/= ..,.. ,.. '' ''' .... . L.. .V .. L.. ''' . V .. bearinginmind thatweidentify expressions upto ..-equivalence \nof bound atomic names. Doing so has the consequence that the object-level capture-avoidance property \nof sub isdelegatedtothe properties of meta-level ..-equivalence. This is an idea familiar fromhigher-orderabstract \nsyntax[23],exceptthathereweare bakingin tothemeta-languagejust object-level ..-equivalence ratherthan \nobject-level ......-equivalence(in ordertokeep hold of avery simpleyetexpressive recursionprinciple).Theclaimthat \nsub correctly represents capture-avoiding substitution is substan\u00adtiatedinSect.6.Itisworth noting thatwe \ncanalso representthe kind of capturing substitution that may occur when a ..-term con\u00adtexthas itshole.lled.Holesarerepresentedby \nvariables ..;and hole-.lling by substitution of expressions for variables, ..[.. ' /..]. For example \nthe context .....[-] can be represented by the open expression L(.., ..)= L.. ' . (.. ' ..)* ...Filling \nthe hole in .....[-] with .. gives ..... ..;and correspondingly, the substituted expression L(.., ..)[V \n../ ..] is indeedconvertible to L... V .. (cf. Lemma19(ii)). Example 5 (length of a ..-term). Consider \nthe function |-| : . . N satisfying |..| =1, |.... ' | = |..| + |.. ' | and |..... ..| = |..| +1. What \ncouldbesimpler?And yetformalrecursionschemes for..\u00adtermshavefoundittricky:seeGordon andMelham[14,Sect.3.3] \nandNorrish [20,Sect.3].Wecan representthisfunctioninNominal SystemTmore orlessdirectlyby len . ..... \ntrec ..1 ..2 ..3 .. . Exp(Trm -> Nat), where ..1 . ..... S0 ..2 . ...., .. ' ,..,.. ' . plus .... ' ..3 \n. ...., .., ... S .. and where plus . ...., ... nrec .. (.... ' ,.. ' . S .. ' ) .. is the usual primitive \nrecursivede.nitionofaddition.Forexample |..... ..| =2 and len (L... V ..) trec ..1 ..2 ..3 (L... V ..) \n..... ..3 .. (V ..)(trec ..1 ..2 ..3 (V ..)) ..... S(..1 ..) ..... S(S0) S(S0) wherethelast stepisthe \nstrengthening conversion (..#). Example 6 (computing with bound variables). The nominal treatmentofbindersallowsustocomputewithbound \nnames.What if we try to do something with them that would break object\u00adlevel ..-equivalence? such as \ntrying to compute a list of bound variablesin a ..-term: bv (V ..) nil bv (A .... ' ) append (bv ..)(bv \n.. ' ) bv (L... ..) ..... cons .. (bv ..) where we encode lists of atomic names as certain expressions \nof type Trm and nil , cons and append are suitable encodings of nil, cons andappend operationsforsuchlists.Clearly \nwe can get the above conversions by de.ning bv . ..... trec ..1 ..2 ..3 .. for suitable choices of expression \n..1, ..2 and ..3.However, all that bv computes is a list of new s whose length is the number of occurrences \nof bound variables in the ..-term. For example bv (L...L.. ' . V ..) cons new (cons new nil ). Compare \nthis with the Fresh Objective Caml function listBvars of Shinwell and Pitts[31,p.15]. Remark 7 (new versus \n..... (-)). Canthe binder..... (-) beelimi\u00adnatedinfavour of aconstant new?Inthe ..-calculus[27], new \ncom\u00adputes a dynamically allocated fresh name and the corresponding local name binder ..... .. can be \nde.ned as (..... ..) new.This does not workforNominalSystemT;for example, ..... (.. = new).. false.. \nwhereas (..... (.. = new).. ) new true.. . On the other hand in the nominal sets model that was sketched \nin Section 2, name-restrictionfor thetypesofNominalSystemTisultimately de.nedintermsofa constant New.Soitmaybe \npossible,ifincon\u00advenient,toreformulatethe systemwith aconstant new rather than abinder ..... (-). Remark \n8 (incompleteness). We remarked above (Theorem 3) that conversionisasound axiomatizationofpropertiesof \nequality inthe nominal sets modelofNominalSystemT.Itis notacom\u00adplete axiomatization for the usual recursion-theoretic \nreasons. In factthede.nitionofconversionwaschosentobeas weakaspossi\u00adblesubjecttothecriteriathatitbedecidable,have \nrelatively simple normalforms(seeSect.4) and adequately represent ..-structural recursionwhenrestrictedtoclosedexpressions \n(seeSect.6).Even if we restrict to the .nite part of the system, there are non\u00adconvertibleexpressions \nthat areidenti.edin themodel.Forexam\u00adple, ..... (....)* .. denotestheidentityfunctioninthe model,butis \nnotconvertible to..... ...Itwouldcertainlybe interestingto investi\u00adgate stronger,butstill sound anddecidable, \nnotionsof conversion. 4. Normal Forms Figure 4 gives a notion of ..-long ..-normal form for Nominal System \nT. We call elements .. of the subset Nf (.. ) . Exp(.. ) normal forms oftype .. ;and elements .. ofthe \nsubset Neu(.. ) . Exp(.. ) neutral forms of type .. . Note that in the .gure, .. . {Nat, Atm, Trm} is \na ground type; so, as usual for simply typed ..-calculus, only neutral forms of ground type are normal \nforms. In addition, note that name-restriction ..... (-) only occurs in the normalform new (recallthat \nnew is ..... .. byde.nition) andapplied to neutralforms of ground type;similarly, name-swappingis only \nappliedto neutralforms ofgroundtype. If .. . Neu(..) and .. does not occur free in ..,then .. and ..... \n.. aredifferent elements of Nf (..) even though .. ..... .. by (..#).Similarly, ......... ' ... and \n.... ' ...... .. aredifferent elements of Nf (..) (solong as.. /= .. ')even though ......... ' ... .... \n' ...... .. by (....).However,theseareessentiallytheonlyinstances where conversion between normalforms \ndoes not coincidewithsyntactic identity (modulo ..-equivalence,of course). Moreprecisely,itisa consequenceoftheNormalizationTheorem \nbelowthatconversion restricted to normal forms coincides with the following simple notion of structural \ncongruence. De.nition 9 (structural congruence). The relations ofstructural congruence .. = .. ' [.. \n. Typ,.., .. ' . Nf (.. )] .. = .. ' [.. . Typ,.., .. ' . Neu(.. )] comprisethecongruenceonnormaland \nneutralforms generatedby ..... .. = .. if .. # .. (13) ......... ' ... = .... ' ...... .. (14) for all \n.. . Neu(..) and .. .{Nat, Atm, Trm}. .  .. . Nf (Nat) 0 . Nf (Nat) S .. . Nf (Nat) .. . ..(.. ) .. \n. Nf (.. ' ) .. . Neu(..) .. . ..(.. ) ..... .. . Nf (.. -> .. ' ) .. . Nf (..) .. . Neu(.. ) ..1 . Nf \n(.. ) ..2 . Nf (Nat -> .. -> .. ) .. . Neu(.. -> .. ' ) .. . Neu(Nat) .. . Nf (.. ) nrec ..1 ..2 .. . \nNeu(.. ) .... . Neu(.. ' ) ............................................................ .. . .. .. . \nNf (Atm) .. . Nf (Atm) new . Nf (Atm) V .. . Nf (Trm) .., .. ' . Nf (Trm) .. . .. .. . Nf (Trm) A .... \n' . Nf (Trm) L... .. . Nf (Trm) .. . Neu(Atm) .. . Nf (Atm) (.. = ..).. , (.. = ..).. . Neu(.. -> .. \n-> .. ) .. . .. .. . Neu(..) .., .. ' . Nf (Atm) .. . Neu(..) ..... .. . Neu(..) (.... ' )* .. . Neu(..) \n..1 . Nf (Atm -> .. ) ..2 . Nf (Trm -> Trm -> .. -> .. -> .. ) ..3 . Nf (Atm -> Trm -> .. -> .. ) .. \n. Neu(Trm) trec ..1 ..2 ..3 .. . Neu(.. ) (N.B. .. ranges overthe groundtypes Nat, Atm and Trm.) Figure \n4. Normal forms .. and neutral forms .. Properties(13) and(14) correspondtothesecondtwode.ning properties,(5)and(6)respectively,ofthesemantic \nnotionofname\u00adrestrictionthatweintroducedintheprevious section.(We noted therethatthe.rsttwode.ningproperties(3) \nand(4) correspondto ..-equivalence.) Theorem 10 (normalization theorem). Each typeable expression is \nconvertible to a normal form, which is unique up to structural congruence. More precisely, for each .. \n. Typ there is a function nf.. : Exp(.. ) . Nf (.. ) satisfying: ... . Exp(.. )... nf.. .. (15) ... \n. Exp(.. ).... . Nf (.. )... .. . nf.. .. = .. (16) and hence also '' ' ..., .. . Exp(.. )... .. . \nnf.. .. = nf.. .. . (17) Theproof ofthetheoremis sketchedinthenext section.Itis acorollary oftheproofthatthe \nnormalizationfunctions nf.. are computable.Sincestructural congruence = isevidentlyadecidable relation, \nit follows that conversion isdecidabletoo. 5. Normalization by Evaluation WeproveTheorem10usingaversionof \nnormalizationby evalu\u00adation (NbE).SinceitsintroductionbyBergerandSchwichtenberg [4],NbEhas been appliedtoa \nnumberof applied ..-calculi, both typedand untyped,including onesencompassingG\u00a8odel sSystemT [3,8].In \neach casethetermsofthe calculusareevaluatedina suit\u00adable modelthat characteristicallymixessyntax(variables,atleast) \nwith semantics (extensional functions, usually). Suitable model means one forwhicharei.cationfunction(an \ninverseofevalua\u00ad ... : [.. ] . Nf (.. ): .. . .. ... ... ->.. ' .. . ..... ... ' (.. (... ..)) where \n.. . ..(.. ) and .. # .. ... : Neu(.. ) . [.. ]: .. . ..  ... ... ->.. ' .. . .... . [.. ]. ... ' (.. \n(... ..)) Figure 5. Rei.cation ... and re.ection ... tion ) canbe de.nedfromthe modelbacktotheterms;composing \nrei.cationwithevaluationyields thenormalizationfunction.The rei.cationfunctionusuallyinvolvestheneedto \n.ndsyntacticvari\u00adablesthat are freshwithrespecttosemanticobjects .Asexplained byPitts[26,Sect.6],thetheoryof \nnominal setsprovidesaconve\u00adnientwayofmaking senseofthiskindoffreshnessanditistheway we adopt here.However,thisuseof \nnominal setsinNbEisorthog\u00adonaltothe usewemadeoftheminSection2toprovideastandard model of Nominal System \nT; and it should also be stressed that thereareotherwaysofdealing withthekind offreshness required byrei.cation, \norindeedofavoidingitin somecircumstances:see Abel etal.[1,Sect.1]. The model in which we evaluate the \nexpressions of Nominal SystemT uses nominal sets based onpermutations notjust of atomic names .. . .., \nbut also of variables .. . ..(.. ) (for each type .. . Typ). In other words we use the many-atom-sorted \nversionof nominal setsdescribedbyPitts[26,Sect.3] with.nite permutations of .. . .. that map atomic names \nto atomic names and variables to variables, preserving their types. Letting such permutations act onexpressionsintheobviousway, \neach Exp(.. ) is a nominal set withthe support of .. . Exp(.. ) beingthe .nite set of free atomic names \nand free variables of ... Thus .. # .. (respectively .. # ..)holdsifand onlyif.. (respectively ..)does \nnot occur freein ...The permutation action .., .. . .. \u00b7 .. preservesthe property ofbeing normalorneutral,sothat \nNf (.. ) and Neu(.. ) are nominal subsets of Exp(.. ). Using the nominal sets Nf (..) of normal forms \nat ground types .. and taking .nitely supported functions(.. -fs .. )athighertypes weget: De.nition 11 \n(interpretation of types). For each type .. . Typ we de.ne a nominal set [.. ] as follows: [..] . Nf \n(..)(.. = Nat, Atm, Trm) [.. -> .. ' ] . [.. ]-fs [.. ' ]. . Figure5de.nesequivariantfunctionsofrei.cation \n... : [.. ] . Nf (.. ) and re.ection ... : Neu(.. ) . [.. ] simultaneouslyby re\u00adcursion on the structure \nof types .. . Typ.As mentioned above, wetake advantageofthe nominal sets notionoffreshness(#) in the \nclause for ... ->.. ' :since .. is .nitely supported we can al\u00adways .nd an .. . ..(.. ) satisfying .. \n# .. and the normal form ..... ... ' (.. (... ..)) isindependentofwhichonewe use.Apartfrom this useofnominal \nsets,the de.nitionsof[.. ],... and ... arequite standard,thatis,theydo not depend uponthenewfeaturesthatwe \nhave addedtothesimply typed ..-calculus. Itis when we cometo thede.nitionof evaluation, [..]..,whosepropertiesare \nspeci.edin Fig.6,thatthesenewfeatureshavetobetakeninto account.The .gure makes use of some auxiliary \nfunctions, de.ned in Fig. 7, whichinturnmake use of ... and ... .(Thiswaswhywe gavethe de.nitionofrei.cationand \nre.ectionbeforede.ning evaluation.) Evaluation takesplaceinthepresenceof environmentsofthefol\u00adlowing \nkind.  [..].. = ..(..) [..... ..].. = .... . [.. ]. [..](..[.. ...]) (....).. . [.. ] [.. . Typ,.. . \n..,.. . [.. ]]: [.... ' ].. = [..].. ([.. ' ]..) (....)(K ...) . K (....)... where K = 0, S, V, A [K \n...].. = K([...]..) for K = 0, S, V, A [L... ..].. = L... ([..]..) if .. # .. [..].. = .. [..... ..].. \n=(....)([..]..) if .. # .. [(.. = .. ' ).. ].. = eq.. ([..].., [..]..) [(..1 ..2)* ..].. =([..1].. [..2]..). \n[..].. [nrec ..1 ..2 ..].. = nrec.. ([..1].., [..2].., [..]..) [trec ..1 ..2 ..3 ..].. = trec.. ([..1].., \n[..2].., [..3].., [..]..) Figure 6. Evaluation [..].. . [.. ] [.. . Exp(.. ),.. . Env] De.nition 12 (environments). \nThe nominal set Env . (.. . Typ) -fs ..(.. ) -fs [.. ] of environments consists of all .nitely supported \nfunctions mapping, for each type .. . Typ, variables .. . ..(.. ) to elements ..(..) . [.. ].The initial \nenvironment ..0 . Env is given by: ..0 .. . ... .. [.. . Typ,.. . ..(.. )] (18) (relying uponthefactthat..(.. \n) . Neu(.. )). If .. . Env, .. . ..(.. ) and .. . [.. ],then ..[.. ...] denotesthe updated environment \nmapping .. to .. and otherwise actinglike ... . Thefactthatenvironmentsare.nitelysupportedobjectsisused \nin Fig. 6 in the clauses for ..-abstraction terms L... .. and name\u00adrestriction expressions ..... ...Indeed,Fig.6 \nconstitutes ade.nition of [..].. by ..-structural recursion[26] over expressions ..,for all environments \n.. simultaneously; and this requires the following freshness conditions on binders to be veri.ed: .. \n# .... . [.. ]. [..](..[.. ...]) (19) .. # L... ([..]..) (20) .. #(....)([..]..). (21) The .rst follows \nfrom standard properties of the environmental semantics of ..-abstraction: seethediscussionfollowing \nequation (101) inPitts [26]; property(20) is trivial, since .. is never free in L... .. for any .. . \nNf (Trm);and property(21) can be proved byinduction onthetypeof ...Further applications of ..-structural \nrecursion are needed in the de.nitions of (....)(-), (..1 ..2).- and trec(..1,..2,..3, -) inFig. 7. Thefollowinglemma \nshowsthatfor normalforms,rei.cation providesaleftinverse forevaluationintheinitialenvironment(18), modulo \nstructural congruence; it is proved by induction on the (height of the) derivations of.. . Nf (.. ) and \n.. . Neu(.. ) from the rulesinFig. 4. Lemma 13. (i) ... . Nf (.. ). ... ([..]..0) = ... (ii) ... . Neu(.. \n). [..]..0 = ... ... De.nition 14 (normalization function). For each .. . Typ we de.ne nf.. : Exp(.. \n) . Nf (.. ) to map .. . Exp(.. ) to nf.. .. . ... ([..]..0) where ..0 . Env is the initialenvironmentgiven \nin (18). . Toprove that nf.. hasthe desiredproperties(15) and(16)we continue to follow the standard pattern \nof a NbE proof and in\u00adtroducea suitablelogicalrelationbetween semanticsand syntax. However, thepresence \nofstructural congruence = in Theorem10 '' ' (....)(L.. ...) . L.. . (....).. if .. =/.. { ' new if .. \n= .. ' (....).. . .. ' if .. =/.. ' (....)new . new (....).. . ..... .. '' ' ((....).. ) .. . (.... )(((.... \n) \u00b7 .. ) ..) where .. #(.., .., ..) eq.. (.., .. ' ) . [.. -> .. -> .. ] [.. . Typ,.., .. ' . [Atm]]: \n{ ' ...., .. ' . [.. ]... if .. = .. ' . .. .{new}eq.. (.., .. ) . ...., .. ' . [.. ]... ' if .. /. .. \n.{new}= .. ' eq.. (.., ..) . ... ->.. ->.. (.. = ..).. eq.. (.., ..) . ... ->.. ->.. (.. = ..).. (..1 \n..2). .. . [.. ] [.. . Typ,..1,..2 . [Atm],.. . [.. ]]: (..1 ..2). (K ...) . K (..1 ..2). ... where K \n= 0, S, V, A (..1 ..2). L... .. . L... (..1 ..2). .. if .. #(..1,..2) (..1 ..2). .. . eq(..1,..)Atm ..2 \n(eq(..2,..)Atm ..1 ..) (..1 ..2). new . new (..1 ..2). .. . (..1 ..2)* .. (..1 ..2). .. . .... . [.. \n]. (..1 ..2). (.. ((..1 ..2). ..)) nrec.. (.., .., ..) . [.. ] [.. . Typ,.. . [.. ],.. . [Nat -> .. -> \n.. ],.. . [Nat]] isde.nedbyprimitive recursionand adirectde.nitiononneutral forms: nrec.. (.., .., 0)= \n.. nrec.. (.., .., S ..)= .... (nrec.. (.., .., ..)) nrec.. (.., .., ..)= (nrec(... .. ) ..) ... ..)(.Nat->.. \n->.. trec.. (..1,..2,..3,..) . [.. ] [.. . Typ,..1 . [Atm -> .. ],..2 . [Trm -> Trm -> .. -> .. -> .. \n],..3 . [Atm -> Trm -> .. -> .. ],.. . [Trm]] is de.ned by..-structural recursion and adirectde.nition \non neu\u00adtral forms: trec.. ( ...1 .. .., V ..)= '' ' trec.. ( ...,..)) (trec.. ( .)) .., A .... )= ..2 \n.... (trec.. ( ...,.. trec.. ( .= .., ..))) if .. #(...).., L... ..)) (....)(..3 .... (trec.. ( ..., \n..)= trec.. ( .... (trec(.Atm->Trm ..1)(.Trm->Trm->.. ->.. ->.. ..2) ..3) ..) (.Atm->Trm->.. ->.. Figure \n7. Auxiliary functions usedin Fig.6  complicates matters. We could have dealt with it by quotienting \noutinthemodeland using Nf (..)/= at ground types and .nitely supportedfunctionsoverthose nominal setsathighertypes.How\u00adever,with \naneyetoformalizationsoftheproofof normalization in system such as Coq[coq.inria.fr]orAgda[wiki.portal. \nchalmers.se/agda], we prefer the more intensional model we have given. As a result we use thefollowing \nternarylogical rela\u00adtion, ratherthanabinaryone. De.nition 15 (logical relation). The nominal subsets \nR.. . [.. ] \u00d7 [.. ] \u00d7 Exp(.. ) are de.ned by recursion on the structure of .. . Typ: (..1,..2,..) .R.. \n. ..1 = ..2 .. (..1,..2,..) .R.. ' ->.. . .(..1,..2,.. ' ) .R.. ' . (..1 ..1,..2 ..2,.. .. ' ) .R.. \n. . Lemma 16. (i) .(..1,..2,..) .R.. . ... ..1 =... ..2 ... (ii) ...1,..2 . Neu(.. ),.. . Exp(.. )...1 \n= ..2 .. . ..2,..) .R.. . (... ..1, ... Proof. Bothpropertiesare provedsimultaneouslybyinductionon the \nstructure of .. ,usingtheeasilyveri.edfactthatif (..1,..2,..) . R.. and .. .. ',then (..1,..2,.. ' ) \n.R.. . Althoughwedo notgivethedetailsinthisextendedabstract, one canprovethefollowingpropertiesof R. \n\u00b7 Fundamental property forthelogicalrelation: R is respected byallthe syntactical constructionsofNominalSystemT. \n \u00b7 ([..]..0, [.. ' ]..0,.. ' ) .R.. holds for each pair of convertible expressions .. and .. ' in Fig.3(.. \nbeingthetype of .. and .. '). \u00b7 {(..1,..2) | (..1,..2,..) .R.. } is apartial equivalence relation on \n[.. ] (for each .. . Exp(.. )).  From theseproperties itfollows that: ' ''' ..., .. . Exp(.. )... .. \n. ([..]..0, [.. ]..0,.. ) .R.. . (22) Thisallowsus tocompletetheproof ofthenormalizationtheorem: Proof \nof Theorem 10. If .. . Exp(.. ),thenby(22) andre.exivity of ,wehave ([..]..0, [..]..0,..) .R.. ;and hencebyLemma16(i), \nnf.. .. . ... ([..]..0) ..,whichis property(15).If .. .. . Nf (.. ),thenby(22) againwe have ([..]..0, \n[..]..0,..) .R.. and hence by Lemmas 13(i) and 16(i), nf.. .. . ... ([..]..0) = ([..]..0) = .., whichis \nproperty(16). ... It shouldbeevident fromthe de.nitions inFigs 5 7 that nf.. is computable.AprototypeimplementationusingFreshObjective \nCaml [31] is available from the author s web pages. The facili\u00adtiesthatlanguage providesforcomputing \nwithbinders allowsthe implementation tostickquiteclosely tothede.nitionsinthe.g\u00adures, except that the \ndependently typed family [.. ] [.. . Typ] hastobeimplementedbyasingle,re.exive datatype.Alanguage with \ndependenttypes, such asAgda[wiki.portal.chalmers. se/agda]orCoq[coq.inria.fr], would allow an even closer \n.t werethoselanguagestohavethe nominal featuresofFresh Objective Caml, or better, of Nominal System T \nitself. As it is, for Agda or Coq implementations, the de.nitions in the .gures wouldhavetobeadaptedto \ndealwithourinformaltreatmentof ..\u00adconversioninthesyntax ofNominalSystemT,forexampleby us\u00adingwell-scopeddeBruijnindexes.It \nwouldbenicetohave nom\u00adinal versions ofthesedependentlytypedsystemsthat providethe kindoffacilities forcomputing \nwithname-abstractionand name\u00adrestrictionthatweareconsideringhereandwhichwouldmake pos\u00adsibleamoreorlessdirect \nencodingofthede.nitionsinFigs 5 7. 6. Representational Adequacy In this section we will show that functions \nde.ned by the ..\u00adstructural recursion principle for . described in the Introduction canbefaithfully representedinNominalSystemT.Todo \nso,we restrict attention to closed expressions, by which we mean ones with no free variables. De.nition \n17 (closed expressions and normal forms). For each .. . Typ,let Cexp(.. ) denote the subset of Exp(.. \n) consisting of well-typed expressions of type .. that have no free variables; and let Cnf (.. ) denote \nthe subset of normal forms with no free variables. . Closed expressions may stillhave freeatomicnames,thelat\u00adterbeing \nnormalformsrepresentingobject-levelfreevariables.For example, if .. /.. ' . = are distinct atomic names, \nthen L... V .. ' Cnf (Trm) is a closed normal form representing the open ..-term ..... .. ' . ..Moregenerally,every \nopen ..-termisfaithfully repre\u00adsented in Cnf (Trm).Toseethis,notethatitfollows fromthe rules of formationinFig.4 \nandDe.nition9 that neutral formsalways containatleast onefreevariable;andhence: \u00b7 Cnf (Trm) is inbijectionwith \ntheset .[New] de.ned in (7), that is, the ..-terms(modulo ..-equivalence, of course) over a constant \nNew;Cnf (..) is inbijectionwith .. .{New};and Cnf (Nat) is inbijection with N. \u00b7 Structural congruence \natgroundtypes(Nat, Atm, Trm)is the identity relation.  Sowe getasimpleformof representationaladequacy \n[22]result forthe objectlanguage. (de.nedin(1))withinNominalSystem T:the map +-+ :. . Cnf (Trm) satisfying \n. +..+ = V .. . +.... '+ = A +..++.. '+ (23) . +..... ..+ = L... +..+ (well-de.nedby..-structuralrecursionfor \n.!)gives a bijection be\u00adtween . and the subset of Cnf (Trm) of closed normal forms not in\u00advolving new \n(and hence notinvolvinganyuseof name-restriction). Thefactthattherepresentation(23)is sotrivialis good;the \ncod\u00adinggap betweenobject-and meta-languageisverysmall wejust have to takecarewiththeextranormalformnew \nwhen manipulat\u00adingthe object-languagefromwithinNominalSystemT. Turning next to the representation in \nNominal System T of functions on.,.rstnotethat normalizationpreservestheproperty ofbeing closed.Foritiseasytosee \nfromtheformofitsde.nition thatthenormalizationfunctionisequivariant; thatis,ifwepermute theatomicnames \nandvariablesof anexpression,theatomicnames andvariablesofits normalformare correspondinglypermuted: nf.. \n(.. \u00b7 ..)= .. \u00b7 (nf.. ..). (24) Solikeallequivariantfunctions,nf.. : Exp(.. ) . Nf (.. ) hasthe propertythatthe \nsupport of nf.. .. is containedinthe supportof ... Thus we have: Lemma 18. For each well-typed expression \n.. . Exp(.. ),the free variables and free atomic names of its normal form nf.. .. are contained in those \nof ... In particular nf.. restricts to an equivariant function nf.. : Cexp(.. ) . Cnf (.. ). Lemma 19. \n(i) If .. is a ground type, .. . Cexp(..) and .., .. ' . ..,then (.... ' )* .. (.... ' ) \u00b7 .., the result \nof swapping .. and .. ' in ... (ii) If .. . Cexp(Trm) and .. . ..,then L... .. L(.., ..), as de.ned \nat the bottom of Fig. 1. De.nition 20 (representable functions). Given .. . Typ,let .. denote the quotient \nnominal set Cexp(.. )/= of closed normal forms of type .. modulo structural congruence. (We write[..] \nfor the equivalence class of.. . Cnf (.. ).)Supposethatthefunctions ..1 . .. -fs .., ..2 . . -fs . -fs \n.. -fs .. -fs .. and ..3 . .. -fs . -fs .. -fs .. aresupportedby the.nite subset .. . ... We saythat \n(..1,..2,..3) is representable bythe closed expressions ..1 . Cexp(Atm -> .. ), ..2 . Cexp(Trm -> Trm \n-> .. -> .. -> .. ) and ..3 . Cexp(Atm -> Trm -> .. -> .. ) if the free atomic names of (..1,..2,..3) \narein .. and  ..1 .. =[nf.. (..1 ..)] (25) '' ' ..2 .... [..][.. ]=[nf.. (..2 +..++.. '+ .... )] (26) \n../. .. . ..3 .... [..]=[nf.. (..3 .. +..+ ..)] (27) for all .. . .., .., .. ' . . and .., .. ' . Cnf \n(Trm).(The right-hand sidesofthese equations arein .. becauseofLemma 18.) . Recallingthe freshness conditiononbinders \n(FCB) fromthe Introduction, we have: Theorem 21 (representation of ..-structural recursion). Let (..1,..2,..3) \nbe as in the above de.nition and suppose ..3 satis\u00ad.es (FCB). Let .. . . -fs .. be the function de.ned \nfrom these functions by ..-structural recursion, that is, the unique function satisfying (2).If (..1,..2,..3) \nis representable by (..1,..2,..3),then .. is represented by .. . ..... trec ..1 ..2 ..3 .. . Cexp(Trm \n-> .. ) (28) in the sense that for all .. . . .... =[nf.. (.. +..+)]. (29) Proof. By the uniqueness part \nof ..-structural recursion, toprove (29) it suf.ces to show that .... . .. [nf.. (.. +..+)] satis.es \nthe recursionscheme(2)that de.nes .. .For.rstclausein (2)wehave ..(V ..) trec ..1 ..2 ..3(V ..) ..1 \n.. by(28), (..) and (..V);hence by(23),(17) and(25), [nf.. (.. +..+)] = [nf.. (.. (V ..))] = [nf.. (..1 \n..)] = ..1(..) asrequired.Theargumentforthesecond clausein(2)issimilar. For the third clause, if../. \n.. then for any .. . . .. # ..3 .... [nf.. (.. +..+)] by(FCB) =[nf.. (..3 .. +..+ (nf.. (.. +..+)))] \nby(27) =[nf.. (..3 .. +..+(.. +..+))] by(15) and(17). Structurallycongruent normalformshave equalsetsoffreeatomic \nnames; andhencethesupport of anequivalenceclass [..] . .. is thesameasthe support of anyofitsrepresentatives \n...Therefore wehave .. # nf.. (..3 .. +..+(.. +..+)) andsoby (..#) nf.. (..3 .. +..+(.. +..+)) ..... \nnf.. (..3 .. +..+(.. +..+)). (30) Therefore .. (L... +..+) trec ..1 ..2 ..3 (L... +..+) by(28) and (..) \n..... ..3 .. +..+ (trec ..1 ..2 ..3 +..+) by (..L), since .. #(..1,..2,..3) ..... ..3 .. +..+(.. +..+) \nby(28) and (..) ..... nf.. (..3 .. +..+(.. +..+)) by(15) nf.. (..3 .. +..+(.. +..+)) by(30). Henceby(16) \nandfromabovewehave [nf.. (.. (L... +..+))] = [nf.. (..3 .. +..+(.. +..+))] = ..3 .... [nf.. (.. +..+)] \nas required. Example 2, continued. Let us use Theorem 21 to prove that the expression sub de.ned in Example \n4 does indeed represent capture-avoiding substitution on ..-terms,inthe sensethat sub .. ' +.. '++..+ \n +..[.. ' /.. ' ]+ (31) holdsfor all .. ' . .. and .., .. ' . ..Fixing .. ' and .. ',inthetheorem take \n.. = Trm andthefunctions (..1,..2,..3) tobe ..1 .. . if .. = .. ' then [+.. '+] else [+..+] ..2 ..1 ..2 \n[..1][..2] . [A ..1 ..2] ..3 ....1 [..1] . [L... ..1]. Theyaresupportedbythe.nite set .. consisting of \n.. ' andthe free atomic names of .. ';and ..3 satis.es(FCB).Let .. by thefunction de.nedfromthemby ..-structural \nrecursion.An easyproofby ..\u00adstructuralinduction[26] showsthatforall .. . . .... =[+..[.. ' /.. ' ]+]. \n(32) Itis not hardto seethat (..1,..2,..3) is representable(inthesense ofDe.nition20)by(..1[.. ' /.., \n+.. '+/..],..2,..3),where ..1, ..2 and ..3 areasinExample4(usingLemma 19(ii)toverify(27)forthispar\u00adticular \n..3). Sobyde.nitionof sub andbythe theoremwe have .... =[nfTrm (sub .. ' +.. '++..+)].Combiningthis with(32) \nyields [+..[.. ' /.. ' ]+]=[nfTrm (sub .. ' +.. '++..+)];and sobytheNormaliza\u00adtionTheorem 10 we doindeed \nhave(31). ~ Example 3, continued. The bijection +-+ : N = Cnf (Nat) between natural numbers .. andclosed \nnormalformsoftype Nat isgivenby } +0+ = 0 (33) +.. +1+ = S +..+. As in the previous example, one can \napply Theorem 21 to the de.nitionsinExample5toshowthat len +..+ +|..|+ (34) holdsfor all .. . ..Thusthe \nexpression len doesindeed correctly representthelengthfunction |-| on ..-terms. 7. Atom-Abstraction Types \nPitts[26]develops the ..-structural recursionprinciplefora wide classoflanguagesinvolvingbinding operations,namelythosethat \ncan be speci.ed via a nominal signature [36, De.nition 2.1]. In thispapersofar,for sakeofsimplicity wehave \nrestrictedattention to a single such language, the untyped ..-calculus, ..To extend Theorem 21 to the \nfull range of nominal data types , one .rst needstoextendNominalSystemT withsyntaxforproducttypes and \natom-abstraction types. The latter correspond to the atom\u00adabstraction construction on nominal sets ofGabbay \nandPitts [11, Sect. 5]. This sends a nominal set .. to the quotient nominal set [..].. . (.. \u00d7 ..)/~,where \n~ captures the essence of ..\u00adequivalence: (.., ..) ~ (.. ' ,.. ' ) . (.... '' ) \u00b7 .. =(.. ' .. '' ) \u00b7 \n.. ' for some(indeed, any).. '' such that .. '' #(.., .., .. ' ,.. ' ).We write the equivalence class \nof(.., ..) in [..].. as ....... Eversincetheintroductionofthisconstructithas beenknown that the elements \nof [..].. have a dual nature. On one hand they are abstractions-as-pairs ,withtheidentityoftheatomicname \n.. in thepair (.., ..) anonymizedviapermutationswhenwe passto the equivalence class .......Onthe otherhandthey \nalsorepresent abstractions-as-partial-functions , since [..].. isisomorphictothe nominal setofthosepartialfunctions \n.. from .. to .. whose domain of de.nition is {.. | .. # ..}.Thisbijection ismediatedby the partialoperation \nof concretion;if .. # .. . [..]..,thereisa unique element .. @ .. . .. satisfying .. = ....(.. @ ..) \nand called the  \u00b7 Anew type-former [Atm].. for atom-abstractiontypes. \u00b7 Newforms ofexpression..... \n.. and .. @ .. ',where ..... (-) is a binder(like L... (-))andthetyping rules are:  .. . .. .. . Exp([Atm].. \n) .. . Exp(.. ) .. ' . Exp(Atm) ..... .. . Exp([Atm].. ) .. @ .. ' . Exp(.. ) \u00b7 New conversions: (..... \n..) @ .. ' ..... (.... ' )* .. if .. # .. ' (....) .. ..... (.. @ ..) if .. # .. (....) ..... .... \n' ... .... ' ...... .. if .. /= .. ' (....) (..1 ..2)* ..... .. ..... (..1 ..2)* .. if .. #(..1,..2)(....) \n \u00b7 New normaland neutralforms: .. . .. .. . Neu([Atm].. ) .. . Nf (.. ) .. . Nf (Atm) ..... .. . Nf ([Atm].. \n) .. @ .. . Neu(.. ) Figure 8. Extension with atom-abstraction concretion of .. at ..: . ' . . .. if \n.. = .. ' (... ...) @ .. . (.. ' ..) \u00b7 .. if .. /= .. ' and .. # .. (35) . .unde.ned otherwise. The \nunde.nednessinthethirdclauseisforcedbythenecessityof makingtheright-handsideindependent ofthechoice ofrepresenta\u00adtive \n(.. ' ,..) forthe equivalenceclass... ' ....Thefactthat concretion isapartialoperationcreatesthesameproblem \nas doesthefreshness conditiononbinders (FCB)for ..-structural recursion; calculating with concretionsinvolves \nprovingfreshness conditions(.. # ..). Wehave seenthat name-restrictionoperations(De.nition1)pro\u00advideasimplesolutionforthe \nFCBproblem .Theyalsoprovide oneforthe concretionproblem , asthefollowingresultshows. Theorem 22 (atom-abstractions \nas total functions). If .. is a nominal set equipped with a name-restriction operation ....,then there \nis a name-restriction operation .. on the nominal set [..].. of atom-abstractions satisfying ' '' .. \n/. (....)(... .((......)..) (36) = .. ...)= ... for all .., .. ' . .. and .. . ... In this case there \nare equivariant functions preserving name restriction .... [..].. . (.. -fs ..) . [..].. whose composition \nis the identity on [..]... Furthermore, the partial operation of concretion extends to a total function \n(-) @ (-): [..].. \u00d7 .. . .. that corresponds to function application under the inclusion .. :[..].. . \n(.. -fs ..). Theproof ofthisresult,whichweomitinthisextendedabstract, shows that the extended concretionfunction \n(-) @ (-):[..].. \u00d7 .. . .. satis.es { ' .. if .. = .. ' (... ...) @ .. = (37) (.... ' )((.. ' ..) \u00b7 ..) \nif .. /= .. ' . This suggestsextendingNominalSystemTasinFig.8.Thenew form of ..-conversion for atom-abstraction, \n(....), is particularly pleasing,sinceitcombinesin one equationall themainplayers: atom-abstraction..... \n(-),concretion(-)@..,locallyscopednames ..... (-), and explicit swapping (..1 ..2)* (-). We leave to \nfuture work investigating whether Theorem 10 can beextended toencompass these features(plusappropriate \nones for product types .. \u00d7 .. '). To extend Theorem 21 to the full generalityofPitts[26] onewouldthenconsider \nground types equipped with a nominal signature of constructors and a suitable recursion combinator. For \nexample, Trm would have constructors V : Atm -> Trm, A : Trm \u00d7 Trm -> Trm and L : [Atm]Trm -> Trm (with \nL(..... ..) replacingthe L... .. construct).Thisisprobablybest doneaspartofaninvestigationofMartin-L\u00a8of \ns constructivetype theory extended with atom-abstraction/concretion, locally scoped atoms, atom-equality \ntests andexplicit swapping. 8. Context SNTT. The simple nominaltypetheory (SNTT) ofCheney[6] isthework \nmost closely relatedtothe resultspresentedinthispa\u00adper.Themotivationbehind both worksisthesame:toproducea \ncalculuscombiningsimpletypetheory3 with someofthedistinc\u00adtivefeaturesofthenominalsets modelof namesandbinders,par\u00adticularlyatom-abstraction/concretionandthe \ngoodrecursiveprop\u00aderties of the associated nominal data types. Moreover, both aim toavoidthe needforfreshnessside-conditionswhile \nde.ning and computinginthe calculus.AlthoughSNTTachievesmostofthese aims,itisattheexpenseof a non-trivialtypesystemandalackof \nexpressiveness.We consider each pointinturn. As far as the type system goes, SNTT uses bunched contexts \ncontaining information about object-level freshness. So the aim of avoiding freshness conditions is only \npartially met: terms are onlymeaningfulincontext and concretionisstillpartial, its well\u00adde.nedness mediated \nby freshness conditions in the context. By contrast, Nominal System T has a completely conventional type \nsystem and allfreshness conditions associated with ..-equivalence have beenelevatedtothemeta-level(in \nmuchthesameway as for systemsbased onhigher-orderabstract syntax[23]). As far as expressiveness goes, \nSNTT lacks name-restriction ..... .. andname-swapping (..1 ..2)* ...Cheney[6,Sect.4]discusses the limitations \ncaused by lack of a ..... (-) construct.(See also Fig. 5 of that paper.)Name-restriction is an important \nfeature of the informal meta-theory of programming languages and logics, onethat demandsaformalization \nandof courseweclaimtobe providingapleasant one here.Thefactthatexplicitname-swapping (and more generallyname-permutation)isalsoveryimportantfor \nmeta-theory is gradually gaining currency. One might think that name-swapping only occurs in the dynamics \nof nominal meta\u00adlanguagesand notin thesemantic speci.cations writteninthose meta-language. However, note \nthat with explicit name-swapping we can usea meta-levelbinderlike L... (-) to express the binary operation \nL(-, -) taking an expression .. that computes an object\u00adlevelvariable and an expression .. ' that computesapieceofobject\u00adlevelsyntaxandcombiningthemtocomputeanobject-levelbinder: \nL(.., .. ' )= L... (....)* .. ' (where .. isany atomicnamenot freein either .. or .. ').Example4provided \nanexampleofthis operationin use.If weextend NominalSystemT asinSect.7,we can de.ne thegeneralformofthisnon-binding \noperationforatom-abstraction oftype ([Atm].. -) whosedenotation which is a characteristic feature ofFreshML \n[33]4: <..>.. ' . ..... (....)* .. ' where .. #(.., .. ' ). (38) For example, using this we can form \nthe expression ..... ..... ..... ..(<..>..) @ .. (39) ' ' > [Atm].. ) -> [Atm](.. -> .. inthe nominal \nsets modelisthe shocking [16,Sect.2.5]isomor\u00ad 3initially,and dependenttype theoryinthelongrun 4Bewarned, \nCheney[6] uses the notation ....(-) forthe binding operation that is denoted here by ..... (-).  phism \n~ [..].. -fs [..].. ' =[..](.. -fs .. ' ) (40) notedbyGabbay[10,Corollary9.6.9].Thisis notexpressiblein \nSNTT:see Cheney[6,Fig.5]. Nevertheless,SNTTisaveryinteresting systemwhose meta\u00adtheory is even simpler \nthan the one presented here. It would be interestingtoinvestigate translatingitintoNominalSystemT(ex\u00adtendedasinSect.7);perhapsthetranslationofitsbunchedcontexts \nmightprovideuseful conditionsinaconditional-equational calcu\u00adlusmoreexpressivethanthesimpleequational \nnotionofconversion we have givenhere. Westbrooketal.[37] usesomeof theideas behindSNTT to design anextensionof \nthe calculusofinductive constructions,the type theory underlying Coq. This is certainly the right direction \nin which to go. However, we believe that the use of Odersky\u00adstyle locally-scoped names will play just \nas important role for expressivity in nominal versions of dependently typed systems asitdoeshereforthesimplytypedNominalSystemT. \nFocusing on binding and computation. It hasbecomevery com\u00admon to use typed ..-calculus as a uniform method \nof representing syntaxinvolvingbinding[23].Theprosandconsofthis method compared with nominal techniques \nhave been vigorously de\u00adbated[5,7].Incomparing systemsthatemploy them, one should bear in mind the purpose \nfor which they are designed: is it rep\u00adresentationplusproof(classical or constructive), orrepresentation \nplus computation(functionalorlogical), or both?Heretheprimary focus is on functional computation with \nrepresentations and the analysesofPoswolsky andSch\u00a8urmann[29]andLicataetal.[16] arepertinent: most previous \nuses oftyped ..-calculus representa\u00adtionsidentify functions-as-data with functions-as-computation (Miller[17]isanearlyexception) \nandthisleads tocomplications such asmodalities[24]whentrying todevelop recursionandin\u00adduction for higher-order \nabstract syntax. These authors advocate separating the two notions of function, leading to forms of lo\u00adcally \nscopedsymbolsin[15,16,29,37]similartothe notionof atom-abstraction(..-binding) considered in the extended \nsystem ofSect.7.Thisshould notbe confusedwith the notionof name\u00adrestriction(..-binding).5 For one thing \nthe latter does not change thetypeofexpressions,whereastheformer does.The nominal sets modelmakesthedifferencebetweenthetwonotionsclear.Inciden\u00adtally,Theorem22provides \nan interestingsemanticalinsight: in the presenceof name-restriction,it seemsthatitisconsistenttoregard \ntypesof functions-as-data assubtypesoftypesof functions-as\u00adcomputation . Harper hascoinedtheterm pronominal \nfortheuseoflocally scoped symbols as pronouns referring to a designated binding site , contrastingitwiththe \nnominal approachto symbolsas nouns withindependent existence.Leaving aside theimportantfact that, unlikein[16, \n29], here we have a boolean-valued equality test on names,isNominalSystemTnominal or pronominal?The answer \nis not so clear. We are used to the idea of free variables in ..\u00adcalculusbeingimplicitly..-bound;inotherwordstheir \ndesignated bindingsite isanimplicittop-level.InNominalSystemTwecan de.nitelythinkoffreeatomicnamesashavinganimplicittop-level \ndesignatedbindingsite aswell;butthey are ..-bound rather than ..-bound.What makesthis possibleisthefactthatin \nour system, likeOdersky s, ..-bindingcommuteswith ..-abstractionandtupling (see the (....) and (..K) \nconversionsinFig. 3). Acharacteristic of usingtyped ..-calculus to represent binding isthat onegets substitutionand \n..-equality for free in addition to renaming and ..-equality.Thisisoften seen[24] asastrength of theapproach,butI \nam not so sure.There arevery manydifferent 5Unfortunately .. is usedtoindicate abstraction ratherthan \nrestrictionin [29, 37]. formsof substitution; and manyformsof name-bindingthathave nothingtodo withsubstitutionwhatsoever.Theapproachhereisto \nstriveforthesimplest possiblesystemproviding anexpressive and familiarformofrecursion modulorenaming; \none that makesiteasy forthe usertodealwiththemanydifferentkindsofobject-language substitution on a case-by-case \nbasis. So compared with [15, 29], here somethingsarenot automatic.Similarly, LicataandHarper [15]incorporatetypesclassifyingclosed \nobject-levelexpressions, whereasI wouldprefertolet theuser makeinductive de.nitions of suchtypesinthe \nyet-to-be-explored dependently-typedversion ofNominalSystemT.Ontheotherhandthe useoflocally-scoped symbolsofanydatatype,ratherthanjustat \nnametypeslike Atm as here,seems aninterestingfeatureof[16,17,29]. Nominal versus presheaf representations. \nThe nominal sets modelof namesandbindinghasclose connectionswiththeuseof certain presheaf categoriestomodelbinding \n[9]. Indeedthe cate\u00adgory ..om of nominal sets andequivariantfunctionsisasheaf sub\u00adcategory of the presheaf \ncategory ..et.. offunctorstothe category of setsfromthe category .. of.nitesetsandinjectivefunctions.The \nuseof name-restrictionoperationsonnominal sets(De.nition1) brings the connection even closer. Let Res \ndenote the category whoseobjectsare nominal sets .. equippedwitha name-restriction operation and whose \nmorphisms .. : .. . .. ' are equivariantfunc\u00adtionsthat preserve name-restriction(.. ((....)..)=(....)(....)). \nSta\u00adton[privatecommunication] has observedtheremarkablefactthat Res is equivalent to the presheaf category \n..et.... ,where .... is the category of .nite sets and injective partial functions. 9. Conclusion Apartfromthetechnical \ncontributionsofthis paper,themainmes\u00adsagesIwanttoconveyarethat name-restriction is just as important \nas name-abstraction when computing withbinders;andthat name\u00adrestriction need not involve a computational \neffect.The secondis thesamepoint as madebyOdersky[21].Thenewresults about nominal sets(Theorems2and22)leadtoaverysimplesemantics \nforthisformoflocal name. Thisinturnsuggestscombiningthe characteristic feature of nominal sets name-permutations \nwith Odersky-style name-restriction. It might seem that the commuta\u00adtionofthisformoflocal scopingwithfunctionabstractionandtu\u00adpling \nmakeittoosimpletobe useful I certainly thought sofor manyyears and have vigorouslypursued applications \nof the more common, generativekindoflocal name.However,aswehaveseen, thecombinationof thissimpleand pure \nformoflocallyscoped namewith name-swappingisvery expressive.Thispaper hasused their combination to develop \na new form of structural recursion modulo ..-equivalencefortotalfunctions whichhas allthe expres\u00adsive \nconvenience of ..-structural recursion without the computa\u00adtionallyinconvenientfreshness conditions onbinders.Continuing \nwithtotalfunctions,the nextobviousstepistotrytoextendNomi\u00adnalSystemT withdependenttypes.Historicallyspeaking,G\u00a8odel \ns SystemTwasastepping-stone onthewayto MartinL\u00a8of s much more expressivetreatment of recursion andinduction[19].G\u00a8odel \ns SystemTisthesimplytypedkernelofMartinL\u00a8of s constructive typetheory.It wouldbeinteresting toinvestigatewhethertheap\u00adproachintroduced \nhereextendstoa nominal Martin-L\u00a8oftypethe\u00adory withOdersky-stylelocal namesand name-swapping.Themo\u00adtivationisthe \nsearch foralogical framework [22] that admitsfa\u00admiliarformsof nominal speci.cationandformalizestheinfor\u00admalusesof \nrecursionandinduction modulo .. that are common inthepracticeofprogramminglanguage semantics. Acknowledgments \nIamverygratefulfor stimulatingconversations ontheideas under\u00adlyingthispaperwithJamesCheney, JohanGlimming,BobHarper, \nPaul BlainLevy, andSamStaton. Andreas Abel andPeter Dybjer gave me good advice about normalization-by-evaluation. \n References [1] A. Abel, T. Coquand, and M. Pagano. A modular type-checking algorithmfor type theory \nwithsingleton typesand proof irrelevance. InP.-L. Curien, editor, Typed Lambda Calculi and Applications, \n9th International Conference, TLCA 2009, Brasilia, Brazil, July 1-3, 2009, Proceedings, volume 5608 of \nLecture Notes in Computer Science, pages 5 19. Springer-Verlag, 2009. [2]H.P.Barendregt. The Lambda Calculus: \nIts Syntax and Semantics. North-Holland, revised edition, 1984. [3] U. Berger, M. Eberl, and H. Schwichtenberg. \nTerm rewriting for normalizationby evaluation. Information and Computation, 183:19 42, 2003. [4] U. Berger \nand H. Schwichtenberg. An inverse of the evaluation functional for typed ..-calculus. In 6th Annual Symposium \non Logic in Computer Science,pages 203 211. IEEEComputer SocietyPress, Washington, 1991. [5]J. Cheney. \nNominallogicand abstractsyntax. ACM SIGACT News, Logic Column, 36(4):47 69, Dec. 2005. [6] J. Cheney. \nA simple nominal type theory. In Proceedings of the International Workshop on Logical Frameworks and \nMetalanguages: Theory and Practice (LFMTP 2008), volume 228 of Electronic Notes in Theoretical Computer \nScience, pages 37 52. Elsevier B. V., Jan. 2009. [7] K. Crary and R. Harper. Higher-order abstract syntax: \nSetting the record straight. ACM SIGACT News, Logic Column, 37(3):93 96, Sept. 2006. [8] P.Dybjer andA.Filinski.Normalization \nandpartialevaluation. In G. Barthe,P.Dybjer,andJ. Saraiva, editors, Applied Semantics, Ad\u00advanced Lectures, \nvolume 2395 of Lecture Notes in Computer Science, Tutorial, pages 137 192. Springer-Verlag, 2002. ISBN \n3-540-44044\u00ad 5. InternationalSummerSchool,APPSEM2000, Caminha,Portugal, September 9 15, 2000. [9] M.P.Fiore,G.D.Plotkin,andD.Turi. \nAbstractsyntax andvariable binding. In 14th Annual Symposium on Logic in Computer Science, pages 193 \n202.IEEEComputerSocietyPress,Washington, 1999. [10] M.J. Gabbay. A Theory of Inductive De.nitions with \n..-Equivalence: Semantics, Implementation, Programming Language. PhD thesis, University of Cambridge, \n2000. [11]M.J.GabbayandA.M.Pitts.Anewapproachto abstractsyntaxwith variable binding. Formal Aspects of \nComputing, 13:341 363, 2002. [12]A.Gacek,D.Miller, andG.Nadathur. Combining genericjudgments with recursive \nde.nitions. In 23rd IEEE Symposium on Logic in Computer Science (LICS 2008),pages 33 44. IEEEComputer \nSociety Press,June 2008. \u00a8 Standpunktes. Dialectica, 12:280 287, 1958. [13] K.G\u00a8odel. Uber eine bisher \nnochnicht ben\u00a8utzeErweiterung des.niten [14] A. D. Gordon andT.Melham. Five axioms of alpha-conversion. \nIn Theorem Proving in Higher Order Logics, 9th International Confer\u00adence, volume 1125 of Lecture Notes \nin Computer Science,pages 173 191. Springer-Verlag, 1996. [15] D.R.LicataandR. Harper.Auniverseofbindingandcomputation.In \nProceedings of the 14th ACM SIGPLAN International Conference on Functional Programming (ICFP 2009),pages \n123 134.ACMPress, 2009. [16] D. R. Licata, N. Zeilberger, and R. Harper. Focusing on binding and computation. \nIn Proceedings of the Twenty-Third Annual IEEE Symposium on Logic in Computer Science, LICS 2008, 24-27 \nJune 2008, Pittsburgh, PA, USA,pages 241 252. IEEEComputer Society, 2008. [17]D.A. Miller. AnextensiontoMLtohandle \nboundvariablesindata structures,inthe proceedingsofthelogical frameworksbraworkshop. Technical Report \nMS-CIS-90-59, University of Pennsylvania, May 1990. [18] R. Milner. Functions as processes. Mathematical \nStructures in Com\u00adputer Science, 2(02):119 141,June 1992. [19] B. Nordstr\u00a8om,K.Petersson, andJ.M.Smith. \nProgramming in Martin\u00adL\u00a8of s Type Theory.OxfordUniversity Press, 1990. [20]M.Norrish. Recursivefunctionde.nitionfor \ntypeswith binders. In Theorem Proving in Higher Order Logics, 17th International Confer\u00adence, volume \n3223 of Lecture Notes in Computer Science,pages 241 256. Springer-Verlag, 2004. [21] M. Odersky.Afunctionaltheoryoflocal \nnames.In Conference Record of the 21st Annual ACM Symposium on Principles of Programming Languages,pages \n48 59.ACMPress, 1994. [22]F. Pfenning. Logical frameworks. InA. Robinson andA.Voronkov, editors, Handbook \nof Automated Reasoning, chapter 17, pages 1063 1147.Elsevier Scienceand MITPress, 2001. [23] F. Pfenning \nand C. Elliott. Higher-order abstract syntax. In Proc. ACM-SIGPLAN Conference on Programming Language \nDesign and Implementation,pages 199 208.ACMPress, 1988. [24] B. Pientka.Atype-theoreticfoundationfor \nprogramming with higher\u00adorder abstract syntax and .rst-class substitutions. In 35th Annual ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages (POPL 08),pages 371 382.ACMPress, 2008. [25]A.M.Pitts.Nominal \nlogic,a.rstorder theoryof namesand binding. Information and Computation, 186:165 193, 2003. [26]A.M.Pitts. \nAlpha-structuralrecursionand induction. Journal of the ACM, 53:459 506, 2006. [27] A. M. Pitts and I. \nD. B. Stark. Observable properties of higher orderfunctions that dynamically createlocal names, or:What \nsnew? In Mathematical Foundations of Computer Science, Proc. 18th Int. Symp., Gda\u00b4nsk, 1993, volume 711 \nof Lecture Notes in Computer Science,pages 122 141. Springer-Verlag, Berlin, 1993. [28]A.M.Pitts andI.D.B.Stark.Operationalreasoningforfunctionswith \nlocal state. InA.D.Gordon andA.M.Pitts, editors, Higher Order Operational Techniques in Semantics, Publications \nof the Newton Institute,pages 227 273. CambridgeUniversityPress, 1998. [29]A.PoswolskyandC.Sch\u00a8urmann. \nPractical programmingwithhigher\u00adorder encodings and dependent types. In European Symposium on Programming \n(ESOP 2008), volume 4960 of Lecture Notes in Com\u00adputer Science,pages 93 107. Springer-Verlag, 2008. [30]F.Pottier.Static \nname controlforFreshML.InTwenty-Second Annual IEEE Symposium on Logic In Computer Science (LICS 07), \npages 356 365,Wroclaw, Poland,July 2007.IEEEComputer SocietyPress. [31]M.R.Shinwell andA.M.Pitts. FreshObjectiveCamlusermanual. \nTechnical ReportUCAM-CL-TR-621,UniversityofCambridgeCom\u00adputerLaboratory, Feb. 2005. [32]M.R.Shinwell \nandA.M.Pitts.Onamonadicsemanticsforfreshness. Theoretical Computer Science, 342:28 55, 2005. [33]M. R.Shinwell,A.M.Pitts,andM.J.Gabbay. \nFreshML:Program\u00adming with binders made simple. In Eighth ACM SIGPLAN Inter\u00adnational Conference on Functional \nProgramming (ICFP 2003), Up\u00adpsala, Sweden, pages 263 274.ACMPress, Aug. 2003. [34]W.W.Tait. Intensionalinterpretationoffunctionalsof.nite \ntype,I. Journal of Symbolic Logic, 32(2):198 212, 1967. [35] C. Urban and S. Berghofer. A recursion combinator \nfor nominal datatypes implemented in Isabelle/HOL. In 3rd International Joint Conference on Automated \nReasoning (IJCAR 2006), Seattle, USA, volume 4130 of Lecture Notes in Computer Science,pages 498 512. \nSpringer-Verlag, 2006. [36] C.Urban,A.M.Pitts,andM.J.Gabbay.Nominal uni.cation. Theo\u00adretical Computer \nScience, 323:473 497, 2004. [37] E. Westbrook, A. Stump, and E. Austin. The calculus of nominal inductive \nconstructions: an intensional approach to encoding name\u00adbindings. In Proceedings of the Fourth International \nWorkshop on Logical Frameworks and Meta-languages: Theory and Practice (LFMTP 2009), Montreal, Canada, \nACM International Conference ProceedingSeries, pages 74 83.ACMPress,Aug. 2009.  \n\t\t\t", "proc_id": "1706299", "abstract": "<p>This paper introduces a new recursion principle for inductive data modulo &#945;-equivalence of bound names. It makes use of Odersky-style local names when recursing over bound names. It is formulated in an extension of G&#246;del's System T with names that can be tested for equality, explicitly swapped in expressions and restricted to a lexical scope. The new recursion principle is motivated by the nominal sets notion of \"&#945;-structural recursion\", whose use of names and associated freshness side-conditions in recursive definitions formalizes common practice with binders. The new <i>Nominal System T </i> presented here provides a calculus of total functions that is shown to adequately represent &#945;-structural recursion while avoiding the need to verify freshness side-conditions in definitions and computations. Adequacy is proved via a normalization-by-evaluation argument that makes use of a new semantics of local names in Gabbay-Pitts nominal sets.</p>", "authors": [{"name": "Andrew M. Pitts", "author_profile_id": "81100104445", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P1911061", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1706299.1706321", "year": "2010", "article_id": "1706321", "conference": "POPL", "title": "Nominal system T", "url": "http://dl.acm.org/citation.cfm?id=1706321"}