{"article_publication_date": "05-01-1991", "fulltext": "\n ktefinement 1 ypes tor ML Tim Freeman tsf@cs.cmu.edu School of Computer Science Carnegie Mellon University \nPittsburgh, Pennsylvania 15213-3890 Abstract T$ e describe a refinement of ML s type system allow\u00ading \nthe specification of recursively defined subtypes of user-defined datatypes. The resulting system of \nrejirze\u00ad meni f,ypes preserves desirable properties of ML such as decidability of type inference, while \nat the same time allowing more errors to be detected at compile-time. The type system combines abstract \ninterpretation with ideas from the intersection type discipline, but remains closely tied to ML in that \nrefinement types are given only to programs which are already well-typed in ML. 1 Introduction Standard \nML [MTH90] is a practical programming lan\u00adguage with higher-order functions, polymorphic types, and a \nwell-developed module system. It is a statically typed language, which allows the compiler to detect \nmany kinds of errors at compile time, thus leading to more reliable programs. Type inference is decidable \nand every well-typed expression has a principal type, which means that the programmer is free to omit \ntype decla\u00adrations (almost) anywhere in a program. In this paper we summarize the design of a system \nof subtypes for ML which preserves the desirable prop\u00aderties listed above, while at the same time providing \nfor specification and inference of significantly more pre\u00adcise type information. We call the resulting \ntypes re\u00adfinement types, as they can be thought of as refining user-defined data types of ML. In particular, \nwe do not extend the language of programs for ML (only the language of types) and, furthermore, we provide \nrefined type information only for programs which are already Permission to copy without fee all or part \nof this material is granted provided that the copies are not made or distributed for direct commercial \nedvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying ia by permission of the Association for Computing Machinery. To copy otherwise, \nor to republish, requires a fee and/or specific permission. @ 1991 ACM o-~9791-428-7/91 /ooo5/026~ooo$l \n.50 Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Deeign and Implementation. Toronto, \nOntario, Canada, June 26-28, 1991. Frank Pfenning fp@cs.cmu.edu School of Computer Science Carnegie \nMellon University Pittsburgh, Pennsylvania 15213-3890 well-typed in ML. In this preliminary report we \nonly deal with an extension of Mini-ML [CDDK86], but we believe that the ideas described here can be \nfurther ex\u00ad tended to the full Standard ML language. To see the opportunity to improve ML s type system, \n consider the following function which returns the last cons cell in a list: datatype cr list = nil I \ncons of a * a list fun lastcons (last as cons (hd, nil) ) = last I lastcons (cons (hd, tl) ) = lastcons \ntl We know that this function will be undefined when called on an empty list, so we would like to obtain \na type error at compile-time when last cons is called with an argument of nil. Using refinement types \nthis can be achieved, thus preventing runtime errors which could be caught at compile-time. Similarly, \nwe would like to be able to write code such as case lastcons y of cons(x, nil) => print x without getting \na compiler warning. However, the ML type system does not distinguish singleton lists from lists in general, \nso when compiling this case statement ML compilers. will issue a warning because it does not handle all \npossible forms of lists. Here, refinement types allow us to eliminate unreachable cases. Attempting to \ntake such refined type information into account at compile time can very quickly lead to un\u00ad decidable \nproblems. The key idea which allows us to circumvent undecidability is that subtype distinctions (such \nas singleton lists as a subtype of arbitrary lists) must be made explicitly by the programmer in the \nform of recursive type declarations. In the example above, vie can declare the refinement type of singleton \nlists as datatype Q list = nil \\ cons of a * a list rectype a singleton = cons (a, nil) This rectype \ndeclaration instructs the type checker to distinguish singleton lists from other lists. The datatype \nconstructor names cons and nil in the right-hand side of the rect ype declaration stand for subtypes \nwhich one can think of as subsets. At any type cr the type expression nil can be interpreted as the set \n{nil} and cons (x, y) stands for {1 I1= cons(z, y)Az cX Ay c Y}. We can think of the refinement type \ninference al\u00adgorithm as performing abstract interpretation over a programmer-specified finite lattice \nof refinements of each ML type. Finiteness is important, since it is nec\u00adessary for the decidability \nof refinement type inference in our system. Since type inference can only know that a list has one element \nif its tail is nil, it also needs to create a type for the empty list; suppose the name of this type \nis ?nil. With this notation our abstract interpretation works over the following lattice: a list a singleton \nV ~ ?nil /\\ a singleton a ?nil \\/ -L To perform the abstract interpretation, the type sys\u00adtem needs \nto know the behavior of datatype construc\u00adtors on these abstract domains. This can be expressed through \nrefinement types given to each constructor. For example, cons applied to anything of type a and nil will \nreturn a singleton list: cons : (a * a ?nil) --+ 0 singleton The constructor cons also has other types, \nsuch as: cons : (a* a singleton) -+ a list cons : (a* a list) ~ CYlist In our refinement type system, \nwe express the principal type for cons by using the intersection operator A to combine all these types, \nresulting in: cons : (a* a ?nil) + a singleton A (CY* cr singleton) -+ @ list A (CY*a list) + a list \n This type for cons can be generated automatically from the rectype declaration for singleton above. \nWe borrow the operator A from the intersection type discipline [RDR88], though we use it in a very restricted \nway here (we can only intersect types which are refine\u00adments of the same ML type). Type inference for \ninter\u00adsection types, however, is in general undecidable. Thus, for them to be useful in a programming \nlanguage, some explicit type annotations are required, as, for exam\u00adple, in Forsythe [Rey88]. Here we \navoid explicit typing, while still retaining decidability, by allowing only the in\u00adtersection of types \nwhich are subtypes of a common ML type. It is also this restriction which makes the combi\u00adnation of polymorphism \nand intersection types simple and direct (see [Pie89] for an investigation in a more general context). \nAs we will see later, we also require a form of union types so we can assign more accurate types to case \nstatements. The inspiration for this and for the subtyp\u00ading rules for function types (sketched in Section \n4) are due to Benjamin Pierce [Pie90]. In many examples, subtypes which could be specified explicitly \nas refinement types are implicit in current ML programs. For example, when we consider bitstrings to \nrepresent natural numbers, we have in mind a stan\u00addard form of representation without leading zeros, \nand we would like to guarantee that functions such as ad\u00addition and multiplication return standard forms \nwhen given standard forms. As another example, consider the representation of terms in a ~-calculus. \nSome natural manipulations of these terms will only work on terms in head normal form a property which \ncan easily be described via a refinement type. Thus, using refinement types, the programmer is en\u00adcouraged \nto make explicit the distinctions which cur\u00adrently must remain implicit or informal in code com\u00adments \n(such as standard form or head normal form in the examples above). Moreover, type errors can be de\u00adscribed \nin a meaningful way if the type checker deals with the same quantities that the programmer under\u00adstands. \nThus, refinement types can increase the benefits of compile-time type checking and inference as already \npresent in ML, without forcing the programmer to take advantage of them (any legal ML program continues \nto be legal if no refinements are specified). Finally, the fact that we tightly control the lattices \nmaking up the abstract domains makes type inference more practical and efficient. Two examples of subtypes \nwhich cannot be speci\u00adfied as refinement types in our system are lists with\u00adout repeated elements (to \nefficiently represent sets), and closed terms in a A-calculus. Intuitively, this is because these sets \ncannot be described by regular expressions. In fact, our rect ype declarations (with the proper re\u00adstrictions, \nsee Section 3) have a close connection to reg\u00adular expressions since our declarations specify so-called \nregular tree sets for which many well-understood algo\u00adrithms exist [G S84]. Regular tree sets have also \nshown themselves to be useful in the context of typed logic programming [Mis84, YFS91]. One interesting \naspect of our proposal is that it generative (as, for example, in Quest [Car89] in func\u00adtional programming \nor in typed HiLog [YFS91] in logic programming). Our conclusion is that generative types should be the \nprincipal notion, but that non-generative recursively defined subtypes can make a type system sig\u00adnificantly \nmore powerful and useful. merges two views which are traditionally considered as opposites: should recursive \ntypes be generative (as the ML datatype construct), or should they be non\u00ad The remainder of the paper \nis organized as follows. In Section 2 we introduce the syntax of our language, following the presentation \nof Mini-ML [cDDK86]. In Section 3 we show how recursive refinement type decla\u00adrations can be used to \ngenerate finite lattices defining the domain of abstract interpretation for type inference, These lattices \nof values induce subtype relationships on the function types, as we describe in Section 4. Poly\u00admorphism \nin ML requires a similar polymorphism for refinement types which we discuss in Section 5. We then present \nthe type inference algorithm in form of some inference rules in Section 6. Finally, in Section 7 we discuss \nsome aspects of implementation and future work.  2 The Language In this section we define our extension \nto the language of types as present in ML and give some examples. The next three sections will then discuss \nthe refinement type system and the problems of type checking and inference in more detail. While we hope \nto eventually be able to extend all of Standard ML by rectype declarations, we confine our\u00adselves in \nthis paper to the functional portion of Standard ML. Moreover, for the purpose of this presentation we \nignore product types and multi-arity type constructors. They can be added to the language in a straightforward \nway and, moreover, are not crucial in this context since functions with multiple arguments can be curried. \nIn order to keep the examples in this paper intuitive and close to ML, we generally follow ML syntax. \nIn order to give a manageable description of type inference in Sec\u00adtion 6 we restrict ourselves there \nto a much simpler ex\u00adpression language which can be thought of as the result of desugaring the ML syntax \nused in the examples. 2.1 Rectype Declarations The grammar for rectype declarations is: rectype ::= rectype \nrectypedecl rectypedecl ::= < mltyvar > reftyname = recursively < and rectypedecl > recursively :;= (recwsivety \n/ recursively) I mlty --+ recursively I constructor recursivetyseq I mltyvar I < mltyvar > refiyname \nIn this grammar (and other ones appearing in this pa\u00adper), optional items are enclosed in < > , and the \ndif\u00adferent productions for each nonterminal are separated by 1 . Note that the first occurrence of I \nin this grammar is part of the object language. The suffix seq added to a syntactic class name means \neither a nonempty, parenthesized list of elements of that syn\u00adtactic class, or empty. The syntactic classes \nused by the above grammar that are not defined there are constructor Constructors, such as cons. mlty \nML types, such as a list or int. mltyname Datatype constructors, such as list or bool. mltyvar ML type \nvariables, such as a. Each rectype declaration must be consistent with the ML datatype it refines. For \nexample, with the usual definition of lists, we could not accept rectype a bad = nil(nil) because nil \ndoes not take arguments. To limit interactions of refinements types with poly\u00admorphism, we also require \nthat when defining a recur\u00adsive type, any uses of it within its own definition must have the same type \nvariable argument that it has on the left hand side of the declaration.  2.2 Refinement Types General \nrefinement types can be built up from the usual ML types and from recursive types by the ML type con\u00adstructor \n~{--+ , and the new operations of intersection A and union V . Intuitively, an expression has type u \nA T if it has both type c and type ~. Similarly, an ex\u00adpression has type CTVr if it has type CTor type \nr, though we may not be able to predict at compile time which one (such union types arise, for example, \nfrom the different branches of an if expression). Refinement types will be inferred and printed by type \ninference, or can be used by the programmer to annotate expressions, and, in an ex\u00adtension beyond the \nscope of this paper, they can appear in signatures. The grammar for refinement types is: refly ::= refly \nA refty I refly V refty+rej%ylll < refty > mltyname 1 < refty > reftyname ] reftyvar :: mltyvar The syntactic \nclasses used in this grammar that are not defined there are reflyvar Refinement type variables, written \nas TCY, T~, etC. reftyname Refinements of datatypes, like singleton. Every refinement type variable is \nbounded by an ML type variable and thus ranges only over the refinements of an ML type. This is necessary \nto prevent undesirable interactions between polymorphism and subtypes (see Section 5 for further discussion). \nIn contexts where the bound is obvious, we omit it. Refinement type names are either declared explicitly \n(via rectype) or implicitly (as ?nil was in the example in the intro dtiction). See Section 3 for a discussion. \n 2.3 An Example As a simple example consider the representation of nat\u00adural numbers in binary, as in \nthe ordinary ML datatype declaration datatype bitstr = e I z of bitstr I o of bitstr Here the constructor \ne makes an empty bitstring, z ap\u00adpends a zero as the least significant digit, and o appends a one as \nthe least significant digit. When we write functions to manipulate bitstrings, we would like to guarantee \nat compile time that a bitstring does not have a zero in the most significant place. We call this standard \nform (st d). The declaration of this refinement type requites that we also introduce the type of positive \nnatural numbers in standard form (st dpos): rectype std = e I stdpos and stdpos = o(e) I z(stdpos) I \no(stdpos) For example, the bitstring z (e) represents zero, but is not in standard form. The bitstring \nz ( o ( e ) ) represents two, and is iti standard form. Using this rectype declaration, our type checking \nal\u00ad gorithm can check that funaddem=m Iaddne=n i add (z n) (z m) = z(add n m) I add (o n) (z m) = o(add \nn m) i add (z n) (o m) = o(add n m) I add (o n) (o m) = z(add (add (o e) n) m) maps standard form bitstrings \nto standard form bit\u00adstrings. More generally, it can infer that add has this somewhat unwieldy type: \nf e +ye +?e A ?e -stdpos 4 stdpos A ye *std *std A ?e -+ bitstr --+ bitstr A stdpos --+ ?e -+ stdpos \nA stdpos -+ stdpos 4 stdpos A stdpos ---+ std -stdpos A stdpos * bitstr d bitstr A std 4std A + ye std \n+ stdpos ~ stdpos A std -+std + std A std -+ bitstr -bitstx A bitstr --+ ?e --i bitstr A bitstr + stdpos \n--+ bitstr A bitstr * std --+ bitstr A bitstr -i bitstr --+ bitstr In this type we use ?e to represent \nthe type containing just the empty bitstring. This type has one conjunct for each nonempty refinement \ntype we can assign to the arguments of add.  3 From Rectype Declarations to Datatype Lattices A datatype \ndeclaration in ML introduces datatype con\u00adstructors and declares their type. For the purpose of this \nexposition, we also assume that it implicitly de\u00adfines a new constant CASE_ datatype which can be used \nto simultaneously discriminate and destruct elements of the datatype (see example below), A recursive \ntype declaration for a given datatype introduces at least one refinement type name, but many other refinement \ntypes can be formed by intersection, union, function type for\u00admation, etc. Many of these refinement types \nwill be equivalent, For example, a A IT k always equivalent to a, and, in the example above, ?e V stdpos \nis the same as std. A type checking or inference algorithm needs to under\u00adstand these equivalences, and \nwe will introduce the nec\u00adessary structure in two steps. In this section we show how a rectype declaration \ninduces a lattice of subtypes of a given ML datatype with the operations of A and V, understood as meet \nand join. In the following section we show how this information can be lifted to refinement types including \nthe function type constructor -+. Our rectype declarations are essentially regular tree grammars and \nthey almost define regular tree sets as discussed in Thee Automata by G6cseg and Steinby [GS84]. The \nonly change is that we have functions in our trees, but since we require our rectype declarations to \nhave an ML type on the left-hand side of any ---+, this extension turns out to be benign. We do not know \nof any useful examples which would be ruled out by this re\u00adstriction. Algorithms for dealing with such \ndeclarations in Subtyping Recursive Types by Amadio and Cardelli [AC90] do not appear to apply directly \nto our situation. Let us return to the declaration of bitstrings in stan\u00addard form discussed above. datatype \nbitstr = e I z of bitstr I o of bitstr rectype std = e I stdpos and stdpos = o(e) I z(stdpos) I o(stdpos) \n Because weneed to assign arefinement type to each con\u00adstructor, we need to consider a lattice with more \ntypes than just std and stdpos. For instance, this rectype declaration requires the constructor o to \nmap stdpos s to stdpos s, and e s to stdpos s. We can only express this as a refinement type if we create \na refinement type containing just e, which we shall call ?e. After creating this new refinement type, \nwe can give this type for O: 0 : ?e -) stdpos A stdpos + stdpos Thus the refinement types of bitstr \nare bitstr, std, stdpos, and ?e. Using straightforward generalizations of the mars, 1) are form algorithms \nwe can infer closed this lattice: under for that manipulating these four intersection regular refinement \nand union, tree types and gram\u00ad(plus they bitstr std \\ /\\ ?e stdpos In general, closure under intersection \nand union may add many new elements to the lattice a fact which, in an implementation, must be addressed \nthrough com\u00adpact representation methods such as those described in Graph-Based Algorithms for Boolean \nFunction Manip\u00adulation by Bryant [Bry86]. The types for the constructors in this example are calculated \nas e:?e o: ?e~ S%dpos ~ stdpos ~ stdpos z : stdpos -stdpos Note that, even though e also has type std, \nwe do not need to write e : ?e A std, since ?e A std is equivalent to ?e. The case statements for elements \nof the datatype bitstr will look like case E of e => El \\ o(m) => E2 I z(m) => E3 which we will treat \nas the following function call: CASE-bitstr E (fn () => El) (fn (m) => E2) (fn (m) => E3) The algorithm \nwhich analyzes recursive type decla\u00adrations assigns the type appearing in Figure 1 to CASE_bitstr. For \nan explanation of the type quanti\u00adfiers in this figure, see Section 5. 4 From Datatype Lattices to Function \nTypes The datatype lattice is a representation of the subtype relationship and the behavior of intersection \nand union of refinements of an ML datatype. Next we need to consider function types. More specifically \nwe will deal with how the subtype relationships, intersection, and union behave on the more general class \nof refinement types including --+ . The basic principle underlying most subtype systems allowing higher-order \nfunctions is that of (contravari\u00adance : al -i 71~ uz 7T2 if~l ~ T2 and uz < u1. If we think of crl + \nrl as a set of functions and ~ as subset, we can see why: a function accepting al as type-correct input \ncan certainly be given any element from a subtype of al, and since it then produces a value in T1 this \nvalue will also be in 72. We say the type constructor - is contra~ariant in its first argument and covariant \nin its second argument, Defined datatype constructors may also be covariant or contravariant in their \narguments, and our subtyping algorithm keeps track of this information in order to determine, for example, \nthat stdpos list is a subtype of std list. In the rare case that the constructors for a datatype are \nneither all covariant nor all contravariant no useful subtyping information can be calculated by our \nalgorithm. An example of this is the declaration datatype amixed =Cl of a IC2of a + bool For defining \nsubtype relations arising fiut of these ba\u00adsic observations and for the presentation of the type CASE-bit \nstr:Vcr.VTcrl ::a.yrcrz ::cY. vTcr3 ::a. ?e + (unit --+ mI) -+ (bitstr + Ta2) -+ (bitstr+ 7w3) +~al A \nstdpos-+ (unit -i ml) + ((?e V stdpos)--+ mz) + (stdpos+ 7ZK3) -+(?w2 V 7YY3) A std -+ (unit + mul) + \n((?e V stdpos)--+ 7c22) + (stdpos+ 7w3) +(?wl V rcr2 V TIa3) A bitstr--i (unit + ml) --i (bitstr --+ \nm22) -+ (bitstr-+ 7w3) +(?wl V mz V mx3) Figure 1: Type for CASE_bitstr. inference algorithm in the next \nsection, it is convenient to convert types to a normal form. We can do this by rewriting the type according \nto the following rewrite rules for any refinement types p, C, and r: pA(a VT)a(PAa)V (PAT) (P Va)+T5(p+T)A(a+r) \nThinking of function types as sets of functions provides some insights about why these are valid transforma\u00adtions. \nAlso, for any refinements of data types p, a, and r such that p = u V T, we rewrite p to u Vr. After \nwe apply these rewrites, the refinement types will fit the grammar unf ::= inf I unf V unf inf ::= < \nunf > reftyname I inf A inf \\ inf -+ unf I reftyvar :: mlt yvar where unf stands for union normal form \nand inf for intersection normal form. We now define the subtype ordering u < T for unf refinement types \nc and T where u and r are refinements of the same ML type. We have two cases, either their common ML \ntype is a datatype or it is a function type. If the bounding ML type is a datatype, the subtype relationship \nis determined by the partial order of the lattice. If the bounding ML type is a function type, the unf \nrefinement types have the form of a union of inf refine\u00adment types Ui and a;, and we have the rule rlvuzv. \n..vun<;vo v;-; v.. .vr~ if for each u; there is a U; such that Ui < uj. which leaves us with the problem \nof comparing inf re\u00adfinements of functional types. Given inf refinements for a function and its argument, \nwe can compute a refinement type for the value of the function application: if the function has type \nu = (pl --+ Tl)A(p24n) A... A (pm -+ T.) and the argument has type p, then the type of their application \n(written apptype(~, P)) is {ilP<P.} where A stands for intersection of a set of types. We can use this \nto solve the subtype problem for inf refinements of functional types. Suppose we are trying to solve \nthe problem u < cr , where C7=(p1+ T1)A(p2+T2)A. .. A(pn+Tn), and a =(p; +T; )A(p\\+Tj)A. .. A(P~+T~). \nIn this case we define a < u to mean, for all p h {Pl , P2 > . . ..pn. P{, Pj, .4.1 PA}, apptype(a, p) \n< apptype(cr , p). The correctness of this definition in general is implied by the theorem stated in \nSection 6: if an expression of type a evaluates to a value v, then v will also have type u. On the other \nhand, it is quite possible that more subtype relationships hold than can be established with the rules \nabove, which means that the types inferred for higher-order functions may not be as accurate as pos\u00adsible. \nThis is another case where decidability must be balanced with the desire for accuracy in type checking. \n 5 Polymorphism The interaction between polymorphism and subtypes is potentially problematic, The main \nmechanism con\u00adsidered so far in the literature is bounded quantifica\u00adtion [CCH089, CW85], where the domain \nof a type variable is restricted to range over subtypes of a given bound. In this paper we continue the \nseparation of the ML types and refinement types and obtain a restricted form of bounded quantification. \nWe define refinement type schemes by the following grammar: refly scheme ::= inf \\ Va . refty scheme \nI Vra :: a . refly scheme The first case in this grammar refers to types in inter\u00adsection normal form, \nwhich we have already discussed. The second case is quantification over an ML type variable, which is \nvery similar to quantification over ML type variables as used in ML. This can be regarded as an infinite \nintersection; for instance, the identity function valid =fnx=>x has the ML type vCY. CY--+a which we \ncan loosely regard as the intersection of for all ML types a, although in practice we do not rep\u00adresent \nML types this way. The third case quantifies over a refinement type vari\u00adable, and we also regard this \nas an intersection. How\u00adever, once we instantiate the ML type variable with an ML type, there are only \nfinitely many refinements of that ML type, so there are only finitely many types in the intersection. \nWhen we instantiate a refinement type, we perform this expansion. For example, the re\u00adfinement type for \nthe identity function id is d(Y, VI CY ;: cl!. TCY+ Tcl If we instantiate a to stdpos and instantiate \nthe refine\u00ad ment type quantifier, we get the refinement type bitstr--+bitstr A stdpos--+stdpos A stcl+ \nstd A ?e+?c, A 14 J- With this notion of instantiation, the refinements of ML type variables are exactly \nthe refinement type vari\u00adables. This notion is already implicit in the earlier examples: a singleton \nis a refinement of a list, but neither bool singleton nor std list are refinements of CY list. A relaxation \nof this notion could quickly lead to undecidable type inference problems, as in the Milner-Mycroft calculus \n[KTU89, MYC84]. On the other hand, this restriction entails some loss of accuracy in determining refinement \ntype information in some cases. Refinement type schemes are considered during type in\u00adference when analyzing \na let expression and when in\u00adstantiating the type of a polymorphic variable or con\u00adstant. 6 The Type \nInference Algo\u00adrit hm This section will present a type inference algorithm for refinement types as a \ndeductive system. Just as the de\u00adductive system for ML types leads to type inference by unification, \nour deductive system, too, can be given an operational interpretation which first performs an ML type \ninference pass and then a refinement type inference pass using abstract interpretation. Space unfortunately \ndoes not permit a more detailed discussion of the infer\u00adence rules or their operational reading. We infer \nrefinement types for the program by infer\u00adence system in Figure 2. The characters are used as follows \nin the inference rules: e, e are expressions, x> f are ML variables, c is a refinement type in inf, \nD is a refinement type in unf, L is an ML type, r is an environment mapping variables to refinement type \nschemes, and s is a refinement type scheme. The grammar for the language fragment used in this section \nis eql ::= variabte \\ ezp ezp ] A variable, ezp I exp : Tefty I let variable = ezp in ezp I fix variable. \nexp The notation 17 \\ e : D :: L means that in the type environment I , the expression e has refinement \ntype D which is a refinement of the ML type L. If we take this inference system and eliminate all of \nthe refinement types, leaving just the expressions and the ML types, we get a conventional inference \nsystem for Mini-ML. The rules in Figure 2 use the auxiliary judgment LOOP to compute successive approximations \nto the re\u00adfinement type of recursive functions until a fixpoint is reached. This is guaranteed to terminate \nbecause there are only finitely many refinement types below a given ML type (which our algorithm computes \nfirst). The ex\u00adpression close(I , C :: L) generalizes over the free type variables in (7 and L which \nare not free in I and returns the resulting refinement type scheme, Now we shall state a theorem that \nthe typing rules stated above are sound, This is sometimes paraphrased as welt-typed programs cannot \ngo wrong, that is, if an expression has refinement type u, and evaluation of that expression terminates, \nthen the value of the expression will also have the type u. The operational semantics is very close to \nthe one given for Mini-ML [C DDK86] and we omit it here. Theorem: For all valid type environments I and \nex\u00adpressions e, if e evaluates to v and r + e : D :: L then 171-v: D ::Lforsome D <D. INST:I !-a:C::.L \nif z : S is in 17 and C :: L is an instance of S. I , z: C{:: LIFe:.Di::L2 for each Ci that is a refinement \nof L1 ABS: I 1-k. e : Ai(Ci + Di) :: L1 + .L2 I t-el:Vi Ci::L1 (1 , z : (close (17, Ci :: Ll)) k e2 \n: Di :: L2) for each Ci LET: I t-let z=eline2:Vi Di::L2 17ke:D::L D<D RESTRICT: r 1-(e:D ) :D ::L FIX1: \nI 1-LOOP(~, ly. e, l,L) ~1x2: I k LOOP(~, ~y. e, Cl, L) I , f: C1::Lk Jy. e: C2::L I 1-LOOP(f, Au. e, \nC2, L) ~1x3: 17 t-LOOP(f, ~Y. e, C,L) l?, f: C:: LkAy. e: C::L I 1-fixf. Ay. e: C::L Figure 2: Rules \nfor type inference system We omit the proof, which proceeds by induction on The more refinements we \nconsider ofa given datatype, the structure of the definition of the evaluates to re-the slower type checking \nwill be. This problem is al\u00adlation. leviated when more distinct datatype declarations are made even \nif the datatypes present would be sufficient to encode the information we need to represent. In ML, \n Future Work this technique is good programming style in any case, as it enhances program readability \nand allows more type We currently have a naive prototype implementation errors to be detected at compile-time. \nWe also need of the type inference algorithm as shown above. This to consider embedded refinement type \ndeclarations (as prototype takes the lattice for each datatype, the types in let rectype . . . in . . \n. end) which naturally ex\u00ad for the constructors, and the types for the case state\u00adtends ML datatype declarations \nand also limits the vis\u00ad ments as inputs. The main implementation problem ap\u00adibility of refinements, \nthus cutting down on the size of pears to be to deal efficiently with refinements of types the refinement \ntype lattice. of higher-order functions, as the number of such refine-The refinement types proposed here \naddress only a ment types can become large very quickly. For example, subset of Standard ML [MTH90]. \nWe need to carefully since there are five refinements of the ML type stdpos examine the interaction of \nrefinement types with other used in the examples earlier, there are 55 functions map\u00ad features of the \nML type system, such as imperative type ping refinement types of stdpos to refinement types of variables \nand equality types, since we would like to ex\u00ad stdpos, A naive representation of the refinement types \ntend our proposal to encompass all of Standard ML. of stdpos + stdpos would list all of these functions. \nAlthough Standard ML does not provide primitives for Compact representations of refinement types, for \nexam\u00admanipulating the current continuation, some dialects ple through an appropriate generalization of \nBinary De\u00adof ML do, so we would like to be able to deal with cision Diagrams [Bry86, BCM+ 90] to deal \nwith function callcc also. Despite some potential problems which types, seem promising. Since finding \na type error in a may lead to a loss of accuracy of refinement type in\u00ad program with refinement types \nwill require looking at formation across modules, refinement types open the representations of refinement \ntypes, we will have to find possibility of communicating some information about a reasonably concise \nway to print these types. functions between modules without violating the pri\u00advacy of the modules. This \nappears to be much more difficult, if not impossible, in approaches using general set constraints as, \nfor example, in [HJ 90], or abstract interpretation which is not tied to the type system. We also would \nlike to explore the possibility of refin\u00ading predefine types, such as int, which are not given as dat \nat ype declarations. There are no conceptual dif\u00adficulties as long as the appropriate subtype structure \nforms a lattice. For example, we could distinguish the positive integers, the negative integers, and \nzero by giv\u00ading appropriate types to constants appearing in the pro\u00adgram and to the arithmetic operators. \nWe would have to devise some notation for doing this other than rectype declarations because we do not \nhave constructors for the integers. In some cases the refinement type information can be used for program \noptimization during compilation. We would like to explore this possibility further, though our primary \nmotivation remains static detection of program errors which currently elude the ML type-checker. Acknowledgements \n Thanks to Benjamin Pierce, Dave MacQueen, and John Reynolds for discussions about refinement types; \nBen\u00adjamin Pierce, Nevin Heintze, and the anonymous refer\u00adees for proofreading this paper; and to John \nReynolds for his TeX macros to draw diagrams. This research was supported by the Defense Advanced Research \nProjects Agency (DOD) and monitored by the Space and Naval Warfare Systems Command under Contract NOO039-85-C-0163, \nARPA Order No. 5167. References [AC90] Roberto M. Amadio and Luca Cardelli. Sub\u00adtyping recursive types. \nResearch Report 62, Digital Systems Research Center, Palo Alto, California, August 1990. [BCM+90] J. \nR. Burch, E. M. Clarke, K. L. McMil\u00adlan, D. L. Dill, and L. J. Hwang. Sym\u00adbolic model checking: 1020 \nstates and be\u00adyond. In Proceedings of the Fifih Annual IEEE Symposium on Logic in Computer Science, pages \n428-439, Philadelphia, PA, June 1990. IEEE Computer Society Press. [Bry86] Randal E. Bryant. Graph-based \nalgorithms for boolean function manipulation. IEEE Transactions on Computers, C-35(8):677\u00ad691, August \n1986. [Car89] [CCH089] [CDDK86~ [cw85] [GS84] [HJ90] [KTU89] [Mis84] [MTH90] [Myc84] [Pie89] Luca Cardelli. \nTypeful programming. Re\u00adsearch Report 45, Digital Equipment Corpo\u00adration, Systems Research Center, Palo \nAlto, California, February 1989. Peter Canning, William Cook, Walter Hill, and Walter Olthoff. F-bounded \npoly\u00admorphism for object-oriented programming. In Functional Programming Languages and Computer Architecture. \nACM, 1989. Dominique C16ment, Joelle Despeyroux, Thierry Despeyroux, and Gilles Kahn. A simple applicative \nlanguage: Mini-ML. In Proceedings of the 1986 Conference on LISP and Functional Programming. ACM Press, \n1986. Luca Cardelli and Peter Wegner. On un\u00adderstanding types, data abstraction, and polymorphism. ACM \nComputing Surveys, 17:471-522, 1985. Ferenc G6cseg and Magnus Steinby. Tree Automata. Akad&#38;miai Kiad6, \nBudapest, 1984. Nevin Heintze and Joxan Jaffar. A deci\u00adsion procedure for a class of set constraints. \nIn Proceedings of the Fifih .4nnual IEEE Symposium on Logic in Computer Science, Phzladeiphia. IEEE, \nJune 1990. A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. Type-checking in the presence of polymor\u00adphic recursion. \nTo appear in TOPLAS, Oc\u00adtober 1989. Prateek Mishra. Towards a theory of types in Prolog. In International \nSymposium on Logic Programming, pages 289-298. IEEE, 1984. Robin Milner, Mads Tofte, and Robert Harper. \nThe Dejimtion of Standard ML. MIT Press, Cambridge, Massachusetts, 1990. Alan Mycroft. Polymorphic Type \nSchemes and Recursive Definitions, pages 217 228. International Symposium on Programming. Springer-1 \nerlag, New York, 1984. LNCS 167. Benjamin Pierce. A decision procedure for the subtype relation on intersection \ntypes with bounded variables. Technical Report CMU-CS-89-169, School of Computer Sci\u00adence, Carnegie \nMellon University, Pitts\u00adburgh, Pennsylvania, September 1989. [Pie90] Benjamin C, Pierce. Preliminary \ninvesti\u00adgation of a calculus with intersection and union types. Unpublished manuscript, June 1990. [RDR88] \nSimone Ronchi Della scheme and unification discipline. Theoretical 59:181-209, 1988. Rocca. Principal \ntype for intersection type Computer Science, [Rey88] John C. Reynolds. Preliminary design of the programming \nlanguage Forsythe, Technical Report CMU-CS-88-159, Carnegie Mellon University, Pittsburgh, Pennsylvania, \nJune 1988. [YFS91] Eyal Yardeni, Thorn Fruehwirth, and Ehud Shapiro. Polymorphically typed logic pro\u00adgrams. \nIn Frank Pfenning, editor, Types in Logic Programming. MIT Press, Cambridge, Massachusetts, 1991. To \nappear.  \n\t\t\t", "proc_id": "113445", "abstract": "", "authors": [{"name": "Tim Freeman", "author_profile_id": "81538859956", "affiliation": "School of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania", "person_id": "PP31078379", "email_address": "", "orcid_id": ""}, {"name": "Frank Pfenning", "author_profile_id": "81100157780", "affiliation": "School of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania", "person_id": "PP39030152", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/113445.113468", "year": "1991", "article_id": "113468", "conference": "PLDI", "title": "Refinement types for ML", "url": "http://dl.acm.org/citation.cfm?id=113468"}