{"article_publication_date": "05-01-1991", "fulltext": "\n Occurrences in Debugger Specifications Yves Bertot INRIA Sophia-A ntipolis 2004, Route des Lucioles \n--b.P. 109 06561 VAlbonne Cedex (France) bertot @mirsa.inriadl Abstract We describe formal manipulations \nof program\u00adming language semantics that permit execution an\u00adimation for interpreters. We first study \nthe use of occurrences in the A-calculus and we describe an im\u00adplementation of the notion of residuals. \nWe then de\u00adscribe applications in the development of interpreters for the lazy A-calculus and the parallel \nlanguage Oc\u00adcam. 1. Introduction Formal descriptions of programming language semantics have already been \nshown to yield exe\u00adcutable specifications of interpreters for these lan\u00adguages [Mini-ML], [Esterel]. \nHowever, while the ob\u00adtained interpreters have the clear advantage of being certified implementations, \nthey lack a nice user in\u00adterface for the very reason that the definition only deals with semantic values. \nAn interpreter can be transformed into a debugging tool by adding tracing, profiling, or control of execution \nfunctionalities. For us, an execution trace is a list of basic instruction calls that describes a history \nof execution, a profile is a list of statistics of instruction usages, and execution control is the capability \nto stop program execution at any time to observe the current state of computation. These three functionalities \ncan easily be improved with the help of the basic facility that we call subject tracking in this paper \nand that permits to relate exe\u00adcution to locations in the program. For example, an execution trace message \nof the form instruction I is called with arguments L)) can be improved into a mes\u00adsage of the form instruction \n1 is called at position P with arguments L where P describes a location in Permission to copy without \nfee ell or part of this material ia granted provided thetthe copies ere not made or distributed for direct \ncommercial advantage, the ACM copyright notice and the titla of the publication and its date appeer, \nand notice is given that copying is by permission of the Association for Computing Mechinery. To copy \notherwise, or to republish, requires a fee andior specific permission. @ 1991 ACM 0-89791 -428.7/91/0005/0327,+0$1 \n,50 Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation. Toronto, \nOntario, Canada, Juna 26-28, 1991. the program. This is especially useful if instruction 1 is used in \nseveral places in the program, A profiler without subject tracking actually seems useless, since it is \nonly capable of giving the time spent in basic instructions, without indicating where these basic in\u00adstructions \nappear in the program, it is thus unable to show the parts of the program where most of the time is spent. \nThis possible with the help of sub\u00adject tracking. Also, a bare execution controller can only provide \nfunctionalities like execute one instruc\u00adtion and then stop or execute until the execution reaches a \nfunction call and then stop , whereas it can not provide functionalities like execute until the ex\u00adecution \nreaches location P and then stop where P is the location of a specific instruction or function call in \nthe program, unless subject tracking is provided. The problem of relating the execution state to lo\u00adcations \nin the program is relatively simple in the case of sequential programs, where the semantics uses tree \ntraversals to describe the execution. It is noticeably harder in the case of concurrent programs where \nthe semantics uses tree rewritings to describe execution. AS a result of tree rewritings, a part of the \noriginal program may appear at several instances in the term that represents the current state of execution. \nOur problem then corresponds to relating subparts of the rewritten term to the original program. A solution \nto this problem is to integrate the re\u00adlation to the original program within the semantic definition, \nusing occurrences which are the most nat\u00adural way to designate locations. However, this so lution has \nthe drawback of weighing down the work of the designer who produces the formal specification by asking \nhim to deal with features that are not re\u00adally related to the semantics of the language. The formal manipulations \nthat integrate occurrence com\u00adputations are shown, in fact, to be systematic and automatizable. Given \nan implementation of these manipulations, it is then possible to derive an inter\u00ad preter, which provides \nprogram animation, from the dynamic semantics of a programming language and the designer can be freed \nfrom this task, We base our study on the A-calculus, both be\u00adcause it serves as a foundation for a wide \nclass of programming languages and because it is the sim\u00adplest programming language whose semantics is \nde\u00adscribed using a rewriting system. On the formal side of our study, we provide a natural implementation \nto the notion of residuals. On the pragmatic side, we show how to use these results in interpreters for \nthe lazy A-calculus [Lazy] and a subset of the parallel lan\u00adguage Occam [Occam], 2. The Basic Material \n2.1. Occurrences Programs are trees. For designating locations in a tree we use occurrences as described \nin [TRS], for example. For every natural number k, we consider the function sk which maps any tree, op(tl, \n. . . ,t~, . . . . tn), to its child of rank k, i.e, tk. we call an occurrence any function obtained \nby composing an arbitrary number of times the functions sk. The composition operation is denoted o, we \ndenote its neutral element id, and O is the set of all the occurrences. Also, we use the no\u00adtation u \n~ v when v and u are in 0 and there exists u E O such that v = u o u. For example, if we con\u00adsider the \ntree T = j(g(l, 2), 3), we have S2(T) = 3, S1(T) = g(l,2), and S2 OS1(T) = 2. For any tree T we call \nits domain, denoted D(T ), the set of occurrences that are valid on this tree. For example, the domain \nof the tree T = ~(g(l, 2), 3) is the set D(T) = {id, sl, s2, sl OSI, S20SI}. 2.2. The A-calculus We first \nformalize the process of substitution. Substituting a term N for a variable ~ in a term M is represented \nby the formula M[x\\N] and is axiom\u00adatized using the following inference rules: ~: ikf[y\\y ] = M Ay.M[.r\\T] \nA.f [z\\T] = M = Ay .fw (y is a new variable) The with M[z\\T] = M app: MN[x\\T] relation of /?-reduction \nthe following rules: iV[Z\\T] = = M N M + M N is axiomatized 6: (~*.M)N + M[z\\N] M-+M (: Ax.M --+ ~x.M \nM-+M IJz MN --+ M N N-N P: MN --i MN The compilation of this specification into Prolog code [Typol] \nyields a A-term evaluator. 3. Introducing Occurrences The formula M -+ Ml means that there ex\u00adists an \noccurrence u such that u(M) = (~3.T1)T2, u(M ) = T1 [z\\T2], and M is equal to Ml otherwise, We manipulate \nthe specification to also compute u. 3.1. Computtng the Reduction Occurrence We axiomatize the formula \nt-M -+ M where M u is the result of reducing M at occurrence u, tM+M Uosz The modification for the rule \n/3 is simple. When this rule is applied, its subject is exactly the reduced re\u00addex. For the three other \nrules, a single principle ap\u00adpears. If T is the subterm of the rule s subject S at the occurrence o (expressed \nby the equation T = v(S)) and if the premise expresses that the reduced redex, R, is found in Tat the \noccurrence u (expressed by the equation R = u(T)), then this reduced redex is found in the rule s subject \nat the occurrence u o v (obtained from the equations R = u(v(S)) = u o v(S)), In rule U, for example, \nv is equal to S1. Assume t-M -+ M , the correctness of v is given by the existent; of a term (k .T1 \n)T2 such that v(M) = (Az.T1)TZ and v(M ) = T1 [x\\T2] (Proof by induction on the length of v, omitted \nhere). This manipulation permits an enhancement of our ~-term evaluator, so that we can specify in ad\u00advance \nthe reduction to perform, by giving the corre\u00adsponding occurrence. 3.2. Subject Trackzng The method \nwe present in this section is an al\u00adternative to the previous one. Here, we privilege the subject, SE, \nof the formula proved at the bottom of xxx Figure 1. A schematic reduction. the proof, the endformuia \nin Gentzen s terminology This equivalence simply means that if M is found in [Gentzen]. Tothesubject \nofevery formula we asso-the reference term SE at the occurrence v and the ciateits occurrence in SE, \nWeaxiomatize the formula reduction is done in SE at occurrence u o v, then this t-u : M 5 M . The parameters \nM and M are the reduction is actually done in M at occurrence u. In this new method, the occurrences \nwe use are same as in 1-M + M , The parameters u and u addresses relative to the reference SE, instead \nof being are such that M = U(SE) and the reduced redex is addresses relative to the subject of the correspondingU \n(SE). The obtained rules are as follows: formula. 4. Residual Tracking rn2(~): F u : (Jz.M)N s M[x\\N] \nIn the reduction shown in figure 1, the terms that were in areas 1, 2, and 3 reappear in the areas 1 \n, 2 , and 31, 3{1, and 3 . We wish to replace this geometric intuition by a systematic analytical treatment. \nLet us consider a ~-reduction K M + Ml, where v(M) = (~x .T1 )T2. The movements of ~ubterms be\u00adtween \nM and M are given by a function origin(~,v) : D(M1) + D(M) with the following properties: disjoint case: \n UE D(M), V~U + origin[~)o)(u) = u FSIOU; M<M m2(p):  body case: If u 6 Zl(T1) and U(T l) is not a free \noccur\u00adI-u: MN<M N rence of x in T1 then one has: origin(~,u)(u 0 v) c U O S2 o S1 o v argument case: \nIf U2 c D(T2), U1 e D(T1), and kS20U:Nti N U1(Tl ) is a free occurrence of the variable z in T1 then \nmz(v): one has: tu:MNti MN +-origin(~,v)(uz o U1 o v) = U2 o S2 0 v This manipulation is also systematic \nand very Remark that the three cases are exclusive, even similar to manipulation ml. The correctness \nof the when T1 = x. We wish now to compute the function computed occurrence is stated by the following \nequiv-origin, with the help of a proper data structure. alence (Proof by induction on the length of u, \nomit\u00ad 4.1. Eztended Occurrences ted): For a given A-term T we want to encode the val\u00adues of a function \nf : D(T) + S, for some set of values S. We use a tree of values T isomorphic to T that carries at each \nnode the value of ~. The tree T is in app / app M= /\\ k / x app /\\ Figure 2. The origin the set of \nthe trees of values constructed from the ele\u00adments of S as atomic operators and an operator m of arity \n3 (because both A-abstraction and application are operators of arit y 2). Thus, T has the following properties: \nIf u(T) = MN or u(T) = Ax.ikf then T must verify S3 o u(Z ) = ~(u). If u(T)= ~ then T must verify u(T \n) = f(u). To any tree of values t is associated a func\u00ad tion valuet such that valuet(u) = Vm if u(t) \n= m(tl, t2, Vm) or u(t) = Vm 6 0. We want to have valuet = f. In the case of origin functions, the values \nare themselves occurrences. We consider trees of values as an extension of occurrences and call them \nextended occurrences. Also, we encode the function f such that for all v, f(v) = v o u by the occurrence \nu. To express this abbreviation, the definition of the value func\u00adtion associated to a tree tis slightly \nmodified with a new equation: valuet(u) = v o Vm if u = v o u! and u (t) = Vmc 0. In the example given \nin figure 2, the function origin(~,~ ~J is given by the curved arrows that go from M to M. The reader \ncan check that it is encoded by the extended occurrence m(m(u2, S2 o sl, u,l), sz, id), whereul =S20S10S1 \nanduz ==sIo~l. 4.2. Computing Extended Occurrences We axiomatize formulae of the following two forms: \n(i) }u:M+u :M u (ii) t um :ikf[iz\\ut :T] = U :M Formula (i) means the same as 1-M --+ M for the parameters \nM, M , and v. For the par~meters u and u , we use a reference term S,g as in ~3.2; u is the occurrence \ndescribing the position of M in SE (M = U(SE)); u gives the value of the origin function for the subexpressions \nof M as coming from sub-expressions of SE. The parameter v is an address relative to the subject M. As \nfar as formula (ii) is concerned, it means the same as M[z\\T] = M for the parameters M function (curved \narrows). M, x, T, and MJ. For the parameters u~, ut, and u it expresses M = Um (SE), T = Ut (SE), and \nu is the extended occurrence describing the origin function for M , The specification uses a function \ntop such that top(t) = vaiuet(id): t-s20sl ou:M[x\\s20 u: N]=u :M ms(/3) t-u :(k.M)N ~ U :M tslou:M-+u \n:M ins(P): F u : MN ~-+1 (u > 2 v o u,top(u)) : M N tszou:N-+u :N ins(u): 1-u : MN ~;, m(sl o ~,u \n, top(u)) : MN tszou:M+u :M ins(<): b u : kc.M -+, 7TI(SI O Uv,U , tO~(U)) : kr.M Here again, the manipulation \nis systematic. The principle uses a notion of input and output parame\u00adters, very close to that introduced \nin [Typol Ag]. For every formula of the form } M + M we consider the parameter M to be inherw!ed and \nthe parameter M to be synthesized. For each rule, the inherited param\u00adeters of the conclusion and the \nsynthesized parame\u00adters of the premises are input parameters. Conversely, the synthesized parameters \nin the conclusion and the inherited parameters in the premises are output pa\u00adrameters, A distinct logical \nvariable is associated to each input parameter and the extended occurrences for the output parameters \nare then constructed to ex\u00adpress that these parameters are made of parts of the input parameters. We \nuse the same principle to axiomatize the for\u00admula (ii) from the rules that describe substitution. In \n1-M[z\\T] = M , the inherited parameters are M and T and the synthesized parameter is M . The principle \n is not exactly followed for the rule A to express that the origins are not altered by a-conversion: \nms(~) : t-A4f[y\\y ] = M k Szo u : M [x\\ut : T1 = Ui : Ml 1-u : ~y.M[z\\ut : T] = m(sl o u, u , top(u)) \n: ~y .M (y is a new variable) We do not give the other rules, for the sake of conciseness. The correctness \nof the computed data structure is stated as follows: I--U: MV$UU :M u VW G D(M ) va/ueU, (w) = origin(~,v)(to) \no u (Proof by induction on the size of the proof tree, omit\u00ad ted.) 4.3. Residuals The usual notion \nin A-calculus for tracking mo\u00adtion of subterms is that of residuals. A formal descrip\u00adtion, taken from \n[Barendregt], extends the language A of J-terms into a language A* by adding a marked operator A*. In \nthe natural semantics specification, three extra rules account for the marked terms: ~ : (A*z.M)N -+ \nM[t\\N] ~.: M[y\\y ] = M M [x\\~ = M A*y.M[x\\Tl = ~*y .M (y is a new variable) Given a term M of A and a \nset of occurrences T designating A-abstractions in M, we denote (M, ~) 6 A* the term where the A operators \ngiven by X are replaced by A* operators. Given a A-term M and a family of occurrences Y designating redexes \nin M, a redex occurrence v, and a A-term M1 such that M + M , the set of residuals v of F through the \nreduction at occurrence v is the set F such that (M, 810 7) + (M , S1 o X ). The origin function ~ermits \nto handle residuals in the following sense: (M, Y)y(M , r )A t-u: M+u :M w u 3 = {w E D(M ) I vaiueuf(w) \nE F o u} (Proof by induction on the size of the proof tree, omit\u00adted). 4.4. Composing Reductions We \nnow study the transitive closure of fi-reduc\u00ad tion, represented by formulae of the form 1-M ~ M , where \nS is a sequence of occurrences, We u~e the notation S1.S2for the concatenation of two sequences, the \nnot ation v. S for the sequence whose first element is the occurrence v and the rest is the sequence \nS, and the notation c for the empty sequence. The transitive closure is axiomatized using the following \ntwo rules: l-jt(f-+J# 1-M + M uT continue: 1-M ~> M StOp: FM-M E To a derivation M ~ M we associate an \norigin function defined by composing the origin function of all the elementary steps: o? igin(M,c) = \n~b(lq We use the composition of occurrences to repre\u00adsent the composition of origin functions. This leads \nto extra equations, which correspond to the associativity of function composition (u, VI, and V2 are \nextended occurrences, Vm is a pure occurrence): S1 om(w, v2, vm) = VI s~om(v~, vz,vm) = vz m(vl,vz,vm) \nOv = ?n(v, o V,V2 o V,top(vm o v)) where top(t) = valet. Thus, for any pure oc\u00adcurrence u and any extended \noccurrence t, we have value~ (u) = value~~~ (id), In an actual implement tion, these equations must be \nused as soon as pos\u00adsible to reduce the size of the extended occurrences, Without simplification, the \ndata structure can take on a size which is proportional to the length of the derivation; with simplification \nthe size can be kept proportional to the size of the resulting A-term. We apply m3 to the rules continue \nand stop, with the specification that in 1-M * M , M is inherited and M is synthesized. In the rules \nwe obtain, ex\u00adtended occurrences are truly used as generalization of pure occurrences. A proof tree for \n1-u : M ~ u : M may contain formulae of the form 1-v : N ~ v : N/ w where w is a pure occurrence but \nboth v and Vt are extended occurrences. The correspondence with residuals is still valid, as stated by \nthe following property:  ~ Figure 3. An example automated reduction. (M,7)y(M , ~ )A \\ibt@u :M u F = \n{w G D(M) I vaiueti~(w) C 7} (Proof by induction on the length of S, omitted). Given a set F of redex \noccurrences in a term M, a development is a derivation where every elementary step reduces a redex that \nis a residual of one of the redexes given by F. A complete development is ob\u00adtained when the resulting \nterm contains no residual of the redexes given by ~ any more. Using the results of this section, we can \nhave our evaluator perform complete developments for us. 4.5. Computer Implementation The specification \nobtained through m3 is used in an actual implementation within the Centaur system [Centaur]. In this \nimplementation, we can construct kterms using a syntax directed editor, select redexes, and compute reductions, \ndevelopments, and residuals from these A-terms and selections, The four windows given in figure 3 describe \nsuc\u00adcessive reductions of a A-term, In the three first win\u00addows the reduced sub-expression is shown in \ngray. We also selected a sub-expression of the first term in re\u00adverse video and all its residuals through \nthe successive reductions have been computed and shown in reverse video. 5. Application to Functional \nLanguages Functional programming languages are derived from the A-calculus. Basically, one adds data \nstruc\u00adtures with specific operators and rewrite rules for nu\u00admerals, booleans, pairs, etc. and one restricts \nthe reduction relation by choosing an evaluation strat\u00adegy. Here, we take as an example the lazy A-calculus, \nwhere one only considers closed terms, one does not reduce under a A-abstraction, and the parameter of \na function call is not evaluated at binding time, but only when needed. Following this strategy, evaluat\u00ading \na A-abstraction does nothing and evaluating an application begins by evaluating the function part un\u00ad \ntil a A-abstraction is obtained, then performs the @ reduction, and continues with the result, as stated \nin the following rules taken from [Lazy]. evx : t }x.M + /lx.M evapp : l-~4~Z.p l-P[z\\jV]=P tP +R I-MN*R \n The reader can check that these rules actually de\u00adscribe a subset of the derivation relation described \nin $4.4. As shown in [Abstract], substitution is a high level operation and can be replaced by an environ\u00adment. \nThis corresponds to delaying the substitution mechanism until it is actually needed, i. e., when one \nlooks at a variable, it should be substituted. An envi\u00adronment is a list of substitutions (pairs of a \nvariable and a value). When using environment, the correct value of a A-term, E, can be represented by \nthe pair (E, p), called a closure, of E and the environment p that gives the value of the free variables \nin E. The evaluation with an environment is given by the for\u00admula p t E ~ R, where E evaluates to R and \np gives the values of the free variables in E and R: p FN+R subst P : p[x\\(N, p )] 1-X + R ptx~RdzffP: \n(z#y) p[y\\N] t-z + R eva~aPP : p 1-M +-(Ax. P,p ) p [x\\(N, p)] 1-P + R pEMN~R Also, a jixpoint operator \nis usually added, with the semantics described by fizM = M (fizM). This fixpoint permits the definition \nof recursive functions. The evaluation rule for this operator is as follows: 5.1. Subject Tracking What \nshould be understood from the previous section is that a formal description of a functional pro\u00adgramming \nlanguage using environments as in [Mini-ML] is actually derivable from the basic rules of the ~-calculus. \nActually, if we replace every occurrence of ~izkf by Y&#38;f where Y = ~~.(~~.xz)(~z.$(xx))) we can establish \nthe following correspondence between formulae: 01-M=)-R + I-M-R We can derive occurrence computations \nfor the func\u00adtional programming language from the ones we have for the A-calculus. We first obtain two \nrules m(ev~) and rn(evaPP) that correspond to ev~ and evaPP. For conciseness we only give the Iat ter: \nt-slou:M+u/:Ax.P S20U[; P[x\\s20u:N]=v:P !-v: P ++u :R rn(evapp) : I-u: MN++u :R Already from this rule, \nwe see that the environ\u00adment will no longer be a list of pairs, but a list of triples [z\\un : N], where \nthe extra field corresponds to the parameter Un added by manipulation m3 in the formula u : M[z\\un : \nN] = u : M that used to describe substitution with subject tracking. For clo\u00adsures, the interpretation \nexpresses that the closure (N, p) corresponds to the term N where the sub\u00adstitutions given by p have \nto be applied. We con\u00adsider that such a structure has the same origin as its first child N. We can now \naxiomatize the formula p 1-u : M + u : R using the following rules: p kun:N~u :R m(substP) : p[z\\un :(N, \np )] F U :z + U :~ m(evalaPP) : p}slou: M+u~:(}x.P, p ) p [c\\s20u: (N, p)] fs20u~ :P+u :R pl-u:MN~u \n; R rn(evaif;$) : p t-u : fixAf.P a s~os~ou : (P, p[f\\u : (fixAf.P, p)])  5.2. Automatic Manipulation \nof the Ruies When presenting manipulation m~, we used a specification of inherited and synthesized expression \nin the logical formulae that appeared in the rules. In formula p 1-M + R we see that the expression p \nis not exactly treated like an inherited expression. The difference is that only one field of the pairs \ncon\u00ad tained in the environment is considered as an input parameter and the corresponding extra parameter \nis added in the pair itself. If we want to automatize the manipulation m we must add a possibility to \nspec\u00ad ify this feature. Thus, the specification will not only contain inherited and synthesized expressions, \nbut also expressions whose mode is represented by a structure. For example, environments receive the \nspecification (unspecified, inherited)*, thus expressing that they are lists of terms of arity 2, where \nonly the second child should be treated as inherited. This also ex\u00ad presses that the manipulation will \nincrease their arity to 3. Another feature we need to specify is the behav\u00adior of some constructors like \nthe closure constructor. If an occurrence is attached to closure of the form (M, p), we want to express \nthat this occurrence ap\u00adplies directly to the first field of the closure, M, as described by the following \nequation: u((M, p)) = u(M) Let us take for example the rule evalaPP: p F M + (k.p, p ) p [z\\(N, p)] 1-P \n+ R pl-MN+R The mode repartition for the formula p 1-M ~ R is that p has the mode (unspecified, inherited)*, \nM has the mode inherited and R has the mode synthesized. Thus, the input expressions are MN in the conclusion \nand Ax .P and R in the premises; the output expressions are R in the conclusion and M, N, and P in the \npremises. The computation of occurrences takes place as in 33.2 and yields the rule m(eval) given above. \n 5.3. Program Animation When compiling an inference system into a Pro\u00adlog program, logic formulae are \nrepresented by pred\u00adicates and inference rules are represented by clauses, where the conclusion of the \nrule is represented by the clause head and the premises are represented by pro\u00adcedure calls (predicates) \nin the clause tail. For exam\u00adple, the logic formula p t-u :N + u :R can be rep\u00adresented by the prolog \npredicate evcd(p, u, N, u , R), and the rule m(stibstP) is translated into the follow\u00ading clause: eval(cons(p, \ntriple(x, Un, cios(N, p ))), u, z, u , R) : eval(p , Un, N, u , R). Figure 4. Execution animation of \na small functional program. We can also add predicates in the clause, whose effect is not to change the \nresult of the execution, but to control or observe it. Thus, the actual translation of m( SUMP) may be \nthe following clause: eval(cons(p, triple(z, Un, c1os(N, p ))), u, z, u , R) :\u00ad contro/(substP, evai(cons(p, \ntriple . . . , R)), evai(p , Un, N, u , R). In this clause, we have added a call to the procedure cent \nrol, that receives two arguments. The first ar\u00adgument tells which rule is currently applied, the sec\u00adond \nargument tells the question this rule attempts to solve. We use this second parameter as a simplified \nrepresentation of the current state of execution. The predicate control itself can be defined by a clause \nof the following form: controi(rule, question) : < animation part > < user interaction part > < tracing \npart > In the animation part, we can use the occurrences in the program to change the aspect of the \ncorre\u00adsponding part of the program, either by underlining or changing the display colors. For example, \nwe know that if the applied rule is rn(stibstP) then the question is a predicate of operator evai whose \nsecond parame\u00adter, u, indicates the origin of the evaluated expression (a variable in this case). In \nthe user interaction part, we can perform some execution control. For example, the interpreter may maintain \na list of program locations which cor\u00adresponds to breakpoints. We only have to compare the origin of \nthe evaluated expression with the occur\u00adrences of breakpoints. If there is a match, then we can interrupt \nthe execution and let the user observe the current state of execution, represented by the ques\u00adtion, \nwith appropriate tools. If there is no match, the execution continues without any telling the user. In \nthe tracing part, we can use the information given in the question to perform side effects. In the case \nof a real trace, these side effects are outputting the relevant information in a file (for example to \nex\u00adpress that a variable is being evaluated); this infor\u00admation can use the occurrences that appear in \nthe question (to express which instance of the variable is evaluated). In the case of a profiler, the \norigins that appear in the question are important to describe the part of the program that is currently \nexecuted. For example, figure 4 gives successive snapshots of a window where the execution of a little \nprogram is animated. At each step, the evaluator shows in the program the expression that it is going \nto evaluate. Notice that the expression 3 is evaluated only when one needs to evaluate the variable c \nas is normal with lasy evaluation. 6. Application to Parallel Languages The technology presented so far \ncan also be adapted to parallel programming languages. We take for example a subset of the language \nOccam [Occam], where we keep only the parallel construct par, the sequence construct seq and the selection \nconstruct alt. Processes can communicate through channels using output commands (channel! value) and \ninput commands (charmel?input). The semantics of this language is specified using the transitive closure \nof a one-step reduction, as we already saw for the A-calculus. This semantics also uses an environment \nto store the values of variables and the state of communication channels. We axiom\u00ad_* I&#38;splay git \npar ... .. par I    R~J altmm OUT!result @km II OUT!result C)lIT!WI Figure 5. Execution animation \natize the formula p 1-P a p which expresses that the execution of the program P transforms the envi\u00adronment \np into the environment p and the formula p 1-P + P , p which expresses that a single step re\u00adduction \nof the program P in the environment p yields a new program P and an environment p . The rules for complete \nexecution are the following ones: pt-P+P , p p 1-P +p step: pF-P+p end: pl-P3p (P is finished) The rules \nfor one step execution are given below. To implement the rendez-vous implied by the chan\u00adnel communication, \nwe introduce two auxiliary con\u00adst ructs, sync and nothing. The semantics of these constructs is given \nby termination rules which we do not give here for the sake of simplicity. These rules are also used \nfor the semantics of the sequence. They simply express that there is nothing left to do in a given process, \nand that no output expression is wait\u00ading for a rendez-vous. For environments, the not at ion p[c] = \ni expresses that the environment p contains the value i for the charnel c, p + [c, i] denotes the envi\u00adronment \nthat contains the same values aa p except that the channel c has the value i, and p + (v, i) has the \nsame meaning for a variable v. pt-Pl+P; ,p p 1-parPl PQ * parP~ PQ, p pl-P2+P; ,p p 1-parPl Pz d parPIP~, \np pFPl+P; ,p p k seqPl P2 + seqP~P2, p! ~ie ~splay gdit @e Qkplsy ~dit ?ar Q alt l%mq OUT!result of \na small parallel program. pl-P2+P;, p (Pl has terminated in p) p 1-seqP~P2 + P;, p p 1-c!i -t sync(c), \n{p + [c, i]) p[c] =i p 1-C?V + nothing, p + [c, O](V, i) p 1-Cl ?Vl + nothing, p p t-alt Cl?vl P1 Cz?vz \nPz + PI, p p 1-C2?V2 + nothing, p p t-alt Cl?vl PI CQ?VZ PQ + Pz, p The manipulation ms can be directly \napplied to this semantics. One only has to take care of the exis\u00adtence of constructs of different arity. \n 6.1. Visualizing Parallel Execution The semantics given above is actually used to produce an interpreter \nfor this subset of Occam, The results of this paper permit to enhance this interpreter in two directions, \nFirst, we can animate the execution by showing all the elementary instructions that can be executed at \neach step of execution. Second, we can enable the user to guide the parallel execution by stating which \nbranch has to be chosen, when a non-deterministic choice appears. To perform these enhancements, we first \nhave to apply the manipulations m et ml to the rules for one step execution, and the manipulation m to \nthe rules for complete execution. The rule Step obtained after these manipulations has the following \nform : pl-u:P4u :P , p p tu ; P *p pt-u:P *p When translating this rule into a Prolog clause, we can \nadd ~ procedure call, as we did for the rules de\u00adscribing the functional programming language. The translation \nof the rule step thus becomes the following prolog clause: ezec(p, u, P, p ) : contro~(step, ezec(p, \nu, P, p ), v), one~i!ep(p, u, P, v, u , P ), exec(p , u , P , p ). The animation part can rely on an \nobservation program that can be deduced from the language s dy\u00adnamic semantics by a method we already \ndescribe in [Esterel]. This observation program permits to show two categories of locations in the executed \nprogram. The first category contains the redexes, that is, the el\u00adementary commands that can be executed \nnext. The second category contains the elementary instructions that are waiting for a rendez-vous. We \ncan then en\u00adable the user to choose among the occurrences of the first category the occurrence v where \nit wants the ex\u00adecution to be performed. The windows given in figure 5 are successive snapshots of a \nwindow where the execution of a small program is animated. At each step, the instructions that are executable \nare shown in grey and the instruc\u00adtions that are waiting for a rendez-vous are shown in reverse-video. \nNotice that our implementation of syn\u00adchronized communication states that an output com\u00admand is waiting \nfor a rendez-vous only after it has written in a channel and as long as the value is not read by an input \ncommand. 7. Discussion We have shown that occurrence computations were a central component of debugging \ntools, we have described a formal treatment of these computations for the A-calculus, and we have shown \nhow this work can be applied to a small functional language and a small subset of the parallel language \nOccam. An important feature of this work is that we use formal machinery to solve a practical problem, \nWe believe this can be used to develop a general method\u00adology for the implementation of debuggers and \npossi\u00adbly to create a system that would permit the direct creation of such debugging tools from a language \ns formal definition. The implementation of debuggers has until now been done in an ad hoc manner. Further \nwork can be done in two very different directions. On the formal side, it is important to au\u00adtomatize \nthe manipulations we have described in this paper and to give a precise meaning to the computed origin \nfunctions, We can also try to address more complicated labelling schemes, such as the ones used in [Optimal] \nor [Weak]. Such labelling schemes also have practical applications, as they permit to describe the history \nof parts of the execution state. On the practical side, the full range of applica\u00adtions for occurrence \ncomputations has yet to be ex\u00adplored, and real-size debuggers, tracers, or profilers have to be implemented \nusing these techniques, so that we can find other parts that could be shared from one tool to the other, \nor from one language to the other. Acknowledgements I am very grateful to A. Hirschowitz, G. Kahn, and \nJ .J. L&#38;y for their numerous discussions and sug\u00adgestions on early drafts of this paper. References \n[Abstract] J. HANNAN, D. MILLER, From Opera\u00adtional Semantics to Abstract Machines: Preliminary Results \n, Proceedings of the 1990 ACM Conference on Lisp an cl Functional Programming, Nice, France, June 1990, \npp. 32$332. [Barendregt] H. BARENDREGT, The Lambda Calcu\u00adlus, Studies in Logic, North Holland (1984). \n[Centaur] P. BORRAS ET AL., CENTAUR: the system , Proceedings of the ACM SIGSOFT 88: Third Symposium \non Software Development Envi\u00adronments, Boston, Massachusetts, November 1988. (Also appears as INRIA Research \nReport no. 777.) [Esterel] Y. BERTOT, (Implementation of an Inter\u00adpreter for a Parallel Language in Centaur \n, Proceed\u00adings of the European Symposium On Programming, Copenhagen, Denmark, May 1990, pp. 57-69. (Also \nappears as INRIA Research Report no. 1076.) [Gentzen] M. SZABO, The Collected Papers of Ger\u00adhard Gen \ntzen, Studies in Logic, North Holland, (1969). [Lazy] S. ABRAMSKY, The Lazy Lambda Calculus , Declarative \nProgramming, D. Turner (Editor), Ad\u00addison Wesley (1988). [Mini-ML] D. CLfiMENT, J. DESPEYROUX, T. DE-SPEYROUX, \nG. KAHN, A Simple Applicative Lan\u00adguage: Mini-ML , Proceedings of the 1986 ACM Conference on Lisp and \nFunctional Programming, Cambridge, Massachusetts, August 1986, [Occam] INMOS LIMITED, OCCAM Programming \nManual, Prentice Hall International Series in Com\u00adputer Science (1984). [TRS] G. BOUDOL, Computational \nsemantics of term rewriting systems , Algebraic Methods in Se\u00admantics, M. Nivat, J. Reynolds (Editors), \nCam\u00adbridge University Press (1985). [Typol] T. DESPEYROUX, Executable Specification of Static Semantics \nProceedings of the Interna\u00adtional Symposium on Semantics of Data Types, June 1984, Sophia-Antipolis, \nFrance, Springer-Verlag LNCS 173. [Typol Ag] 1. ATTALI, P. FRANCHI-ZANNETTACCI, Unification-free Execution \nof TYPOL Programs by Semantic Attributes Evaluation , Proceedings of the Fifth International Conference \nSymposium on Logic Programming, Seattle, The MIT Press) Au\u00adgust 1988. [Weak] L. MARANGET, Optimal Derivations \nin Weak Lambda-Calculi and in Orthogonal Terms Rewriting Systems. , Proceeding of the eight teenth ACM \nSymposium on Principles of Programming Languages, Orlando, Florida, January 1991, pp. 255-269. \n\t\t\t", "proc_id": "113445", "abstract": "", "authors": [{"name": "Yves Bertot", "author_profile_id": "81100267677", "affiliation": "INRIA Sophia-Antipolis, 2004, Route des Lucioles, b.P. 109, 06561 Valbonne Cedex France", "person_id": "PP39035236", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/113445.113473", "year": "1991", "article_id": "113473", "conference": "PLDI", "title": "Occurrences in debugger specifications", "url": "http://dl.acm.org/citation.cfm?id=113473"}