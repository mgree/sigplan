{"article_publication_date": "05-01-1991", "fulltext": "\n SOFT TYPING Robert Cartwright, Mike Fagan* Department of Computer Science Rice University Houston, \nTX 77251-1892 Abstract Type systems are designed to prevent the improper use of program operations. They \ncan be classified as either static or dynamic depending on when they de\u00adtect type errors. Static type \nsystems detect potential type errors at compile-time and prevent program ex\u00adecution. Dynamic type systems \ndetect type errors at run-time and abort program execution. Static type systems have two important advantages \nover dynamic type systems. First, they help program\u00admers detect a large class of program errors before \nexe\u00adcut ion. Second, the y extract information that a com\u00adpiler can exploit to produce more efficient \ncode. The price paid for these advantages, however, is a loss of expressiveness, generality, and semantic \nsimplicity. This paper presents a generalization of static and dynamic typing called soft typing--that \ncombines the best features of both approaches, The key idea un\u00adderlying soft typing is that a static \ntype checker need not reject programs that contain potential type errors. Instead, the type checker can \ninsert explicit run-time checks around suspect arguments of p~imitive op\u00aderations, converting dynamically \ntyped programs into statically type-correct form. The inserted run-time checks identify program phrases \nthat may be erro\u00adneous. For soft typing to be effective, the type system must avoid inserting unnecessary \nrun-time checks. To accomplish this objective, we have developed an exten\u00adsion of the ML type system \nsupporting union types and recursive types that assigns types to a wider class *The work of both authors \nwas partially supported by NSF and DARPA. Permission to copy without fee ell or part of this material \nis granted provided that the copies are not made or distributed for direct commercial advantege, the \nACM copyright notice and the title of the publication and its date appear, and notice is given that copying \nis by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires \na fee and/or specific permission. @ 1991 ACM 0-89791 -428 -7/91 /0005 /0278,,, $1 ,50 Proceedings of \nthe ACM SIGPLAN 91 Conference on Programming Language Design and Implementation Toronto, Ontario, Canada, \nJune 26-28, 1991. ~ of programs than ML. We have also developed an al\u00ad gorithm for frugally inserting \nrun-time checks in pro\u00ad grams that do not type check. 1 Introduction Computations in high-level programming \nlanguages are expressed in terms of op erat ions on abstract values such as integers, matrices, sequences, \ntrees, and func\u00adtions. Most of these operations are partial: they are defined only for inputs that satisfy \ncertain constraints. For example, the head operation on lists (car in LISP) is defined only for non-empty \nlists. Since the programs submitted to a language transla\u00adtor may contain undefined applications, the \nlanguage must provide some mechanism for coping with them. For this reason, most programming languages \nimpose a type discipline on program text. This discipline can either be static or dynamic. A statically \ntyped language prevents undefined applications by enforc\u00ading syntactic restrictions on programs that \nguarantee every application is defined. The language translator identifies ill-formed applications and \nrefuses to execute programs containing them. ML[19] is a prominent ex\u00adample of a statically typed language. \nIn contrast, a dynamically typed language accepts all programs. Undefined applications are detected during \nprogram execution by tests embedded in the code implementing each primitive operation. If an op\u00aderation \ns arguments are not acceptable, the operation generates a program exception, transferring control to \nan exception handler in the program or the operat\u00ading system. Scheme[5] is a prominent example of a dynamically \ntyped programming language. Static typing has two important advantages over dy\u00adnamic typing. They are: \nError Detection: The system flags all suspect program phrases before execution, helping the programmer \ndetect program errors early in the programming process. Optimization: The compiler can produce bet\u00adter \ncode by optimizing the representation of each type and eliminating most run-time checks. However, these \nadvantages are achieved at the loss of Expressiveness: No type checker can decide whether or not an arbitrary \nprogram will generate any undefined applications. Therefore, the type checker must err on the side of \nsafety and reject some programs that do not contain any semantic errors, Generality: Some abstractions \ncannot be encap\u00adsulated as procedures because they do not type check, As a result, a programmer may be \nforced to write many different instances of the same ab\u00adstraction. In Pszcal, it is impossible to write \na sort procedure applicable to arrays of different lengths; a separate sort procedure must be writ\u00adten \nfor each array index set. In ML, it is impossi\u00adble to write the polyadic t aut function presented in \nSection 6; a separate function must be written for each arity. Semantic Simplicity: The type system is \na com\u00adplex set of syntactic rules that a programmer must master to write correct programs. Otherwise, \nhe will repeatedly trip over the syntactic restrictions imposed by the type checker. In this paper, we \npresent a generalization of static and dynamic typing called SOD typing--that com\u00adbines the best features \nof both approaches. A soft type system can statically type check all programs writ\u00adten in a dynamically \ntyped language because the type checker is permitted to insert explicit run-time checks around the arguments \nof suspect) applications. In other words, the type checker transforms source pro\u00adgrams to type-correct \nprograms by judiciously insert\u00ading run-time checks. Soft typing retains the advantages of static typing \nbecause the final result is a type correct program in a sublanguage that conforms to a static type disci\u00adpline. \nIn the context of soft typing, a programmer can detect errors before program execution by inspect\u00ading \nthe program phrases where the type checker fails and inserts run-time checks. Compilers can generate \nefficient code for softly typed languages because the transformed program statically type checks. The \nkey technical obstacle to constructing a prac\u00adtical soft type system is devising a type system that satisfies \ntwo conflicting goals. The system must be rich enough to type most program components written in a dynamic \ntyping style without insert\u00ading any run-time checks, yet simple enough to accommodate aut onlatic type \nassignment (often called type inference or type re\u00adconstruction). Existing static type systems fail to \nsatisfy the first test, namely, the typing of most program components written in a dynamic style. In \nthis paper, we show how to construct a practi\u00adcal soft type system that satisfies the two preceding criteria. \nIt is a generalization of the ML type system based on an encoding technique for type expressions developed \nby Didier R6my[21] for typing records with inheritance. We use a variation on R6my s encoding to represent \narbitrary union types and recursive types composed from primitive type constructors. This en\u00adcoding reduces \nthe type assignment problem in our soft type system to the type assignment problem in ML, provided that \ncircular unification is used instead of ordinary unification. Consequently, we can use ex\u00adactly the same \ntype assignment algorithm as ML if we subsitute circular unification for ordinary unification. R6my s \nencoding also enables us to apply the ML type assignment algorithm on to transformed problem to determine \nwhat run-time checks to insert in programs that fail to type check. The rest of the paper is organized \nas follows. Sec\u00ad tion 2 presents a simple functional programming lan\u00ad guage that serves as a basis for \nour study of soft typing. Section 3 identifies the appropriate design criteria for a soft type system, \nfocusing on the necessary elements in the type language. Section 4 describes a type lan\u00adguage that meet \nthese criteria. Section 5 presents an inference system for deducing types for program ex\u00adpressions. Section \n6 gives an algorithm that automat\u00adically assigns types to program expressions. Section 7 describes a \nmethod for inserting run-time checks when the type assignment algorithm fails. Finally, Section 8 discusses \nrelated work, and Section 9 presents some di\u00adrections for further research. 2 A Simple Programming Language \nFor the sake of simplicity, we will confine our attention in this paper to the simple functional language \nExp introduced by Milner[18] as the functional core of ML. The automatic type assignment and coercion \ninsertion methods that we present for Exp can be extended to assignment and advanced control structures \nusing the same techniques that Tofte[24], MacQueen[3], and Dubs et al[lO] have developed for ML. We define \nthe syntax of Exp as follows: Definition 1 [The programming language] Let z range over a set of variables \nand c range over a set of constants 1<. A program M has the form: M::= xlc]k.Ml(MM)lletx =Min M We \npresume that the set of constants K contains data constructors that build values, selectors that tear \napart values, and case functions that conditionally combine operations. For example, the boolean con\u00adstants \ntrue and false are O-ary constructors, the list operation cons is a binary constructor, and the cor\u00adresponding \nhead and tail functions are selectors on non-empty lists. For each non-repeating sequence of constructors, \nthere is a case function. If (C1, . . . . cm) is a sequence of constructor names, then cas e(~l, .,C.) \ntakes n + 1 arguments: a value v, and n functions ol, . . ..o~. The case(cl, ,..,cn) function is informally \nde\u00adfined by the following equation: 01 (v) V= Cl(. ..) case{ .,, .,,,~j(v)(o,) . . .(on) = j~(v) v = \n~n( ~ ... wrong otherwise { The program text if x then y else z is syntactic sugar for the application \ncase(~rue,false) (~)(~~.I/)(~~.Z ). ternary if construct is syntactic sugar for the func\u00adtion caSe(true,f \nalse). Exp is a conventional call-by-value functional lan\u00adguage. All of the primitive and defined functions \nin Exp are strict: they diverge if any of their arguments diverge. The formal semantic definition for \nExp is given in Appendix A. The only unusual feature of the semantics is the inclusion of a special element \nwrong in the data domain to model failed applications which can never be executed in type correct programs. \nThe data domain also includes exception values to model the output of dynamic run-time checks. 3 Criteria \nfor a Soft Type System From the perspective of a programmer, soft typing is a mechanism for statically \ndetecting potential type errors in dynamically typed programs. From the per\u00ad spective of a compiler-writer, \nsoft typing is a mecha\u00ad nism for translating dynamically typed programs to equivalent statically typed \nprograms, reducing the problem of compiling a dynamically typed langauge to compiling a statically typed \nsubset. These two complementary perspectives on soft typ\u00ading dictate that a practical soft type system \nmust sat\u00adisfy the following two criteria: Minimal Text Principle The system should accept unannotated \ndynamically typed programs. Oth\u00aderwise, the programming interface will be more cumbersome than that provided \nby a conventional dynamically typed programming language. Minimal Failure Principle The type system \nshould be rich enough to assign static types to typical program components that produce no run-time type \nerrors. Otherwise, programmers will ignore the run-time checks inserted by the type checker because most \nof them are false indi\u00ad cators of potential program errors. To satisfy the minimal text principle, the \nsoft type system must perform automatic type assignment. Au\u00adtomatic type assignment deduces types for \nall program phrases by propagating the type information associ\u00adated with primitive operations. To satisfy \nthe minimal failure principle, a soft type system must accommodate parametric polymorphism, an important \nform of abstraction found in dynami\u00adcally typed languages. Parametric polymorphism is best explained \nby giving an example. Consider the well-known LISP function reverse that takes a list as input and reverses \nit. For any type a, reverse maps the type list (a) to list(a). To propagate precise type information \nabout a specific application of reverse, we need to capture the fact that the elements of the output \nlist belong to the same type as the elements of the input list. Otherwise, we will not be able to type \ncheck subsequent operations on the elements of the output list. For this reason, a soft typing system \nmust be able to deduce the fact that reverse has type da.list(a) --+ list(a). The ML type system supports \nautomatic type as\u00adsignment and parametric polymorphism, but it still falls short of satisfying the minimal-failure \ncriterion. There are two important classes of program expres\u00adsions that commonly occur in dynamically \ntyped pro\u00adgrams that do not type-check in the ML type system. 3.1 Heterogeneity The first class of troublesome \nprogram expressions is the set of expressions that do not return uniform results. Consider the following \nsample function defi\u00adnition. Example 1 Let f be the function Ax. if x then 1 else nil where if-then-else \nhas type Ya bool + a + ~ -+ ~. f takes a boolean value and returns either 1 or nil. Clearly, no run-time \nerror occurs if ~ is a boolean. Nevertheless, this function fails to type check, because 1 and nil belong \nto different types. To assign types to heterogeneous expressions, we need to introduce union types. In \na type system with union types, the function in Example 1 has type bool + int + nil where int + nil denotes \nthe set the\u00adoretic union of int and nil: {ZIZ E int or x E nil}. Union types also enable us to make finer \ngrained type distinctions because we can partition inductively de\u00adfined types into unions of subtypes \nthat distinguish how elements are constructed. The following example is a good illustration. Example \n2 The type list is the union of two different constructor types: the empty list nil and non-empty lists \ncons(a). The division of the type list(a) into the union of the types nil and cons(a) is important because \nit enables us to assign more precise types to the selector functions head and tail. head has type cons(a) \n~ a and tail has type cons(a) -list(a). Languages without union types typically define the type of head \nas list(a) -+ a and the type of tail as list(a) + list(a) permitting undefined applications such as (head \nnil) and (tail nil) to pass the type checker. 3.2 Recursivity The other class of troublesome program \nexpressions is the set of expressions that induce recursive type constraints. A classic example of this \nphenomenon is the self application function S = Am .($ Z) . Since x is applied as a function in the body \nof S, x must have type a -/3. But the self-application also forces a -+ D to be subtype of the input \ntype of x which is a. In a dynamically typed language like Scheme, the function S can be written and \nexecuted. If S is applied to the identity function or a constant function, it will produce a well-formed \nanswer, Nearly all static type systems, however, reject S. The simplest way to construct solutions to \nrecursive type constraints is to include a fixed-point operator fix in the language of type terms. This \nfeature is usually called recursive typing. Given the operator fix, we can assign the type fix t.t--+~ \nto S, In practice, recursive types naturally arise in con\u00adjunction with union types. The following simple \nex\u00adample (taken from an introductory Scheme course) is a good illustration of this phenomenon. Example \n3 Let the function deep be defined by the equation deep = An.(if (=? n O) O (cons (deep (pred n)) nil)) \n where O is the O-ary constructor denoting O and pred is the standard predecessor function. The deep \nfunction takes a natural number n as input and returns O nested inside n levels of parentheses, It does \nnot type check in ML because the output type is both heterogeneous and recursive. In a type sys\u00adtem with \nparametric types, union types, and recursive types, deep has type nat ~ fix t.O + cons(t) where nat = \nO+ SUC. 4 A Type Language Suitable for Soft Typing Our type language, called Typ, is a generalization \nof the ML type language. The definition of Typ is pa\u00adrametrized by the set of data constructors in Exp, \nWe assume that all data constructors are disjoint: no value v can be generated by two different construc\u00adtors. \nFor each data constructor c in Exp, we define a type constructor with the same name c. The set of type \nconstructors C consists of the type constructors derived from data constructors plus the special type \nconstructor -i for defining function types. The ar\u00ad ity of each type constructor depends on the degree \nof polymorphism inherent in the corresponding data con\u00adstructor. For example, the data constructor cons \nfor building lists accepts arbitrary values as its first argu\u00adment, but the second argument must be a \nlist, so the cons type constructor has arity 1. Similarly, the data constructor suc takes one argument, \nbut it must be a non-negative integer, so the type constructor suc has arity O. The special type constructor \n~ has arity 2, Before we define the syntax of Typ, we need to define several subsidiary notions including \npolyregular type expressions and tidy type expressions. Definition 2 Given a set of type constructors \nC, we define the set of type terms X(C, V) over a set of vari\u00adables V to be the free term algebra over \nC and V. The polyregular type expressions over C and V is the set of expressions inductively defined \nby the equation where x is any type variable in V, c is any type con\u00adstructor in G , and . . . is a list \nof n polyregular type expressions where n is the arity of c. To avoid ambi\u00adguity, we view expressions \nas trees rather than strings. The intended meaning of polyregular type expres\u00adsions is the obvious one, \nEvery closed type expres\u00adsion denotes a set of data objects. For each data con\u00adstructor c E C, the corresponding \ntype construction 1An explanation for the choice of this terminology and a dis\u00adcussion of the properties \nof polyregular types appears in Fagan s dissertation[ll]. C(Q!I, .,!, am) denotes the set of all data \nobjects of the form c(ol, . . . . z~) where (z) each argument xi corre\u00adsponding to a polymorphic parameter \nyi of c is taken from the type denoted by the matching2 argument aj and (ii) each non-polymorphic argument \nxi is taken from the type for ~i specified in the definition of the data constructor c. The function \ntype construction a ~ /? denotes the set of all continuous functions that map a into ~. The + operator \ndenotes the union op\u00aderation on sets and the fix operator denotes the fixed\u00ad point operation on type \nfunctions. A formal definition of the semantics of type expressions based on the ideal model[16] of MacQueen, \nPlotkin, and Sethi is given in Appendix B. 4.1 Tidy Type Expressions For technical reasons, we must \nimpose some modest restrictions on the usage of the fix and + operators in type expressions. Definition \n3 The set of tidy type expressions over C and V is the set of polyregular type expressions over C and \nV that satisfy the following two constraints: 1. Every subexpression of the form fix v,t is $or\u00adreally \ncontractile. Almost all uses of fix that arise in practice are formally contractile, but the formal definition \nis tedious. It is given in Ap\u00adpendix B. The expressions fix x.x and fix x.x+ nil are not formally contractile, \nbut fix x .Z -y and fix z.nil + cons(z) are. 2. Every subexpression of the form u + v is discrim\u00adinative. \nA polyregular type expression of the form u + v is discriminative iff (z) neither u or v is a type variable, \nand (ii) each type construc\u00adtor appears at most once at the top level (not nested inside another type \nconstructor) of u + v. The expressions t + true, cons(t)+ cons(y), and (fix z.cons(z)) +cons(y) are not \ndiscriminative, but false + true and nil+ cons(y) are.  4.2 Type Schemes The final step in defining \nour type language Typ is adding the notion of universal quantification. As in ML[8], we restrict universal \nquantification to the outside of type expressions. Tidy type expres\u00adsions that may contain quantifiers \nare called tidy type schemes. Definition 4 [The Language Typ] Let C be the set of type constructors for \nExp and let V be a set of type 2TYPe ~went ~ j corresponds to the jth PO h orph~c Pa\u00adrameter ~1 of the \ndata constructor c. Hence, j may be less than i. variables. A tidy type scheme over C and V is defined \nby the grammar: u ::= T I dt.cT where r denotes the set of tidy type expressions over C and V. Typ, \nthe soft type language for Exp is the set of tidy type schemes over C and V. The ML type language for \nExp is the set of type schemes in Typ that do not contain the + operator (union) or the fix operator. \nHence, the ML type language is defined by the same grammar as Typ, except that the symbol r is restricted \nto the set of type terms. The types of polymorphic operations are given by type schemes rather than type \nexpressions. The for\u00ad mal semantics for type expressions given in Appendix B can easily be extended to \ntype schemes by interpret\u00ad ing Vt.i7 as the intersection of all ideals a where t is an arbitrary ideal \n[16]. 5 Type Inference To assign types to programming language expressions, we use a type inference \nsystem, called Inf, similar to the type inference system for ML. Inf relies on two auxiliary relations \non type expressions: (i) the generic instance relation < on type schemes defined by Damas and Milner[8] \nfor the ML type system and (ii) a sub\u00adtyping relation G on union types, which we will sub\u00adsequent y define. \nDefinition 5 A generic instance of type scheme u is a type scheme u obtained by substituting tidy type \nexpressions for quantified variables of a. For example, given the type da.cons(a) ~ a, then cons(int) \n~ int is a generic inst ante. Definition 6 The subtyping relation ~ is defined on tidy type expressions \nby the inference system given in Figure 1 where r, r , Ti, and -r: denote tidy type expres\u00adsions; x and \ny denote type variables; and c denotes an mar y type constructor other than ~. The inference system presumes \nthat the + operator is associative, commutative, and idempotent. The subtyping inference system is decidable \nusing the encoding defined in the next section. Given tidy type expressions ~ and # , r G r iff the supertype \nencoding of r circularly unifies with the subtype en\u00adcoding of r . Given the two auxiliary relations \ndefined above, our type inference system Inf is defined as follows: Definition 7 [The type inference \nsystem Infj A typ\u00ading judgment is a formula e : c where e is a pro\u00adgram expression and a is a type scheme. \nThe in\u00adtended meaning of e : u is that e has type ~. Figure AXIOM: REFL: UNION: TRANS: CON: FUN: FIX1: \nA, ZGykr1Lr2 FIX2: A 1-fix X.rl ~ fix y.r2 Figure 1: Inference rules for subtype relation presents the \nrules in the inference system Inf for typ\u00ading judgments. In the figure, u and U1 denote tidy type schemes; \nr, r , T1, and rz denote tidy type expressions; e, el, e2, and f denote program expressions; x denotes \na type variable; and A denotes a set of type assump\u00adtions of the form x : u. The intended meaning of \nthe notation A 1-e : ~ is that A implies e :7, Inf consists of the conventional ML rules augmented by \nthe SUB rule to handle subtyping. The effect of adding the SUB rule is surprisingly subtle. The most \nimportant consequence is that program expressions do not necessarily have best (principal) types. The \nfol\u00adlowing counterexample demonstrates this fact. Example 4 [Multiple Typings] Let fl : (a --+ a) + a+~andf2 \n: a + b -a be program functions where a and b are O-ary type constructors. We can immediately deduce \nthat (~1 ~2) : a ~ a. Alterna\u00adtively, A 1-(fl f2) :a+ b ~ a+ b. These two typ\u00adings for (~1 ~2) are incomparable, \nso neither is best. Furthermore, an exhaustive case analysis reveals that VZ(X -x) is the only tidy type \nthat has both types as supertypes, but it is not a valid typing for (~1 ~z). On the other hand, Inf retains \nthe most important property of the ML type inference system, namely the soundness theorem and its corollaries. \nThe sound\u00adness theorem simply asserts that every provable typing judgment is true, according to our semantics \nfor the programming language, the type language, and type assertion language. On an informal level, the \nsound\u00adness theorem ensures that well-typed programs never execute undefined function applications. TAUT: \nAt-x:u A(x) = u INST: Ake; u GEN: x not free in A Ate:Vxu AU{x:#}l-el:~ ABST: AF&#38;z.el:#~r A1-f:rl-+rz \nA1-e:rl APP: At-( fe):r2 At-el:m AU{z:~}t-e2:r LET: A1-let~=eline2:r AEe:r SUB : ., rg# A1-e:T Figure \n2: The type inference rules 6 Automated Type Assignment To satisfy the minimal-text criterion for soft \ntyping, we must produce a practical algorithm for assigning types to program expressions. We have developed \nan algorithm based on the type assignment algorithm from ML (Milner s algorithm W). Our algorithm dif\u00adfers \nfrom the ML algorithm in two respects. First, we encode all program types as instances of a single polymorphic \ntype that has type pa\u00adrameters for every type constructor. Our encod\u00ading is based on an encoding developed \nby Didier R,6my[21] to reduce inheritance polymorphism on record types to parametric polymorphism.  \nSecond, we use circular unification[6] instead of regular unification to solve systems of type equa\u00adtions. \nCircular unification is required to infer re\u00adcursive types.  Our encoding for tidy type expressions \nexploits the fact that the set of type constructors is jinite. Given a finite set of type constructors, \nwe can enumerate (up to substitution instances) all the tidy subtypes and supert ypes of a given type \nexpression. Consider the following example. Example 5 Assume that the only constructors in our type language \nare a(z), b, c. Then the supertypes of the type b are {b, a(z)+b, b+c, a(x)+b+c} . We can describe this \nset using a simple pattern by analyzing which type constructors must appear in a supertype, which type \nconstructors may appear in a supertype, and which type constructors must not appear in a su\u00adpertype. \nThe following table presents the results of this anal\u00adysis: Statusa I Statusb I Statusc may must may \n The same form of analysis can be used to construct a pattern describing all the possible subtypes of \na given type. Since b has no subtypes other than itself, let s consider the type b + c instead. The subtypes \nof b + c are {b, c,b + c} . A must/may/must-not analysis of this set yields the table Status a Status \nb Status c must-not may may Note that in supertype patterns, positive ( must ) information plays a crucial \nrole, while in subtype pat\u00ad terns, negative ( must-not ) information is crucial. We need both forms of \npatterns because the function type constructor ~ inverts the form of information provided by its first \nargument. We can express these patterns in the framework of an ML type system by using the following \nrepresen\u00ad tation adapted from a similar translation that R&#38;my developed for record types with inheritance. \nConsider an ML type system with three type constructors: a highly polymorphic type constructor 7? and \ntwo type constants + and signifying must and must-not respectively. R has a flag parameter for each \ntype construct or in T yp and a pat t em parameter for each type argument taken by a constructor in Typ. \nA flag parameter must be instantiated by either + or A pattern parameter must be instantiated by a expression \nof the form 7?(. . .). For the type language described in the preceding ex\u00adample, the %? type constructor \ntakes four arguments: the flag for a, the pattern describing the type argu\u00adment of a, the flag for b, \nand the flag for e. Using this notation, we can encode the patterns presented in the example as follows. \nThe type b is encoded by the type term R(a : ,la : z,b : +,c : ) where z is a free type variable and \na, la, b, and c are field names included as annotation. la is the field for the type pa\u00ad rameter for \na. The value of pattern variable z is irrel\u00adevant because the corresponding constructor (a) is ex\u00adcluded \nfrom the encoded type. The supertypes of b are represented by the term 7Z(a : rl, la : z, b : +, c : \nTZ); every instantiation of the flag variables yields the rep\u00adresentation of a supertype of b. Similarly, \nthe type b+c is encoded as the term 7Z(a : ,la : z,b : +,c : +). The subtypes of b + c are represented \nby the term %?(a:-,la:z, b:~~, c : T4); every instantiation of the flag variables yields the representation \nof a suby\u00adtype ofb+c. Any non-recursive tidy type expression T in Typ can be encoded as a type term T{ \nover the three type constructors 7?, +, , where the the set of type param\u00adeters for the type constructor \n7? is tailored to the set of of t ype constructors in Typ. More importantly, the set of all supertypes \nof r can be encoded as a type term 1-+ over 7?, +,-. The encodings of the supertypes of r are simply \nthe terms generated by instantiating the flag variables of r+. Similarly, the set of all subtypes of \nT can be encoded as a type term r over %?, +, . The encodings of the subtypes of r are the terms gen\u00ad \nerated by instantiating the type variables of T . If we extend R&#38;my s notation to include quantifi\u00ad \n cation and the fix operator, then we can express all tidy type schemes and their corresponding sets \nof su\u00ad pert ypes and subtypes using R&#38;my s notation. R6my s encoding technique has two important \ntech\u00ad nical properties: It reduces the supertyping and subtyping rela\u00adtions to the instantiation of \nflag fields in the poly\u00admorphic type constructor R.  It eliminates the union operator + from type ex\u00adpressions. \n  The combination of these two properties permit us to infer tidy types for Exp programs using conventional \nML type inference augmented by a rule to unfold ap\u00ad plications of the fix operator. For every primitive \nop\u00ad eration $ : u in Exp, we map it to the R&#38;my type that encodes all of the superiypes of u because \nevery super\u00ad type of u is a valid typing for u. By the SUB rule, f : u and u G d implies .f : u . Consequently, \nany type in\u00ad ference that we perform using conventional ML type inference augmented by the fix rule is \nsound, More import antly, we can use the circular generalization of the ML type assignment algorithm \nto assign types to program expressions in Exp. The circular generalization of the ML type infer\u00ad ence \nsystem and type assignment algorithm to handle recursive types is based on work of Huet [15]. This ex\u00ad \ntension of ML type inference is well known in the ML community, but it has not been added to ML because \nrecursive types are not very useful in the absence of union types.  6.1 The Parametric Type Language \nWe now present the definition of the ML type lan\u00adguage in which we encode tidy type expressions. Al\u00adthough \nthe language only contains three constructors, the definition is tedious because the constructor 7? has \nso many type parameters. Definition 8 [Parametric Type Language] Given a set of type constructors C including \n--+ and a set of type variables v, the set of parametric type terms over C and V is the set of type terms \nZ(C , V) where C consists of the C)-ary constructors {+, } and the 7? constructor of arity N = ~(1 + \nanly(c))o CEC We assume that C has the form {ck 11< k < n} where c1 is the 2-ary function type constructor \n~. The jZag position for type constructor c~ (denoted p~) in the parameter list for 7? is given by the \nformula k w = ~ 1 + arity(ci). i=l The type parameter positions for constructor ck are pk + 1, ., ,,pk \n+ ardy(ck). A term &#38; in R(tI,. . .,t~) is a flag subterm iff i is a flag position for some type constructor \nch. A subterm p of a parametric type term p is a jlag subterm iff it is a flag subterm of some application \nof %? in p. Any subterm of p that is not a flag subterm is called a type subterm. A parametric type term \np is well-formed iff 1. All flag subterms of p are type variables or con\u00adst ants + and -. 2. All type \nsubterms of p are type variables or ap\u00adplications of %?. 3. The type variables occurring as flag subterms \nin p are disjoint from the other type variables in p, The former are called the flag variables of p, \n It is easy to show that our encoding (which we de\u00adfine below) always yields well-formed parametric \ntype terms. Similarly, ML type inference system (with cir\u00adcular unification) preserves well-formedness. \nConse\u00adquently, we will omit the adjective well-formed when referring to parametric type terms for the \nsake of brevity.  6.2 Definition of the Encoding Functions The preceding discussion indicated that we \ncan map a tidy type expression T to corresponding parametric type terms R+(~) and R-(~), respectively \ndenoting the supertypes and the subtypes of T. However, the definitions of the encoding functions R+ \nand R_ are not as straightforward as the preceding analysis sug\u00adgests because the function type constructor \nh is anti\u00admonotonic in its first argument, In the definitions of R+ and R , we must treat -as a special \ncase and make the definitions mutually recursive. Before we define the mappings from tidy type ex\u00adpressions \nto R6my not ation, we need to introduce some subsidiary definitions. Definition 9 Let II denote the syntactic \nconcatena\u00adtion operator defined by the equation: (a~,..., ak)ll(bl, . . .. bz)=(al .ak, bl,,,b~). .,b~) \nA tidy type expression ~ of the form c(tl, ..., t~) is a component of a tidy type expression u + v (written \n~ ~ ~+ u) iff ~ is identical to either u or v, or r is a component of either u or v. If no term of the \nform C(tl, . . . , tm) is a component of a expression w, we say that c does not occur in w (written c \n$ w). Definition 10 [Type Encoding] We define the map\u00adpings R+ and R-from tidy type expressions to para\u00admetric \ntype terms as follows: R+(t) = t tEv fix rn.lt+(t ) t= fix m.t R(R+,l(t)ll . . . llR+,~(t)) otherwise \n{ R-(t) = t tev fix m. R_(t ) t = fix m.t %!(R-,1 (t)tl . . . llR_,n(t)) otherwise { R+,I(t) = (+, \nR-(tl), R+(tz)) tI ~ tz 3 t { +2! t (/cj, z;, Zj) R+,i(t) = (+, R+(t~), . . ..l?+(tm)) Ci(tl,. ... tm)<t \n(q,%j,..., z~) Ci$t { R-,l(t) = (~j, R+(tl), R_(t,)) t, -+ tz < t ( (-, z{, Wj) +$ t R_,i(t) = [2,z;:(t,), \n#. . . R_(tna)) c~(tl, . . ..tm) tit Ci$t { . ..)%) where each occurrence of ~j and x; denotes a fresh \ntype variable distinct from all other type variables. ~j signifies a flag variable while Z: signifies \na pattern vari\u00adable. Recall that the index of the special constructor ~ in c is 1, which explains why \nthe definitions of R~,l and R ,1 are treated as special cases. The encoding functions can obviously be \nextended to map tidy type schemes to parametric type schemes.  6.3 Decoding Parametric Type Terms The \ninverse transformations are similar, but they con\u00adtain a surprising wrinkle. In some cases, a parametric \ntype term can denote a set of several tidy type expres\u00adsions instead of j ust one. The unusual situation \narises when the type assignment algorithm equates two flag variables. Example 6 Assume that the type \nsystem has four type construct ors: -and three 0-ar y type const ruc\u00adtors a, b, c. Their flags appear \nin argument positions 1, 4, 5, and 6, respectively, of the 7?(. . .) constructor. The type arguments \nfor -appear in positions 2 and 3. Let twice = ~~k.(~ (f z)) The function twice has type (a ~ a) -+ a \n-a. Now suppose F is a function of type a + b h a. Then the parametric type for F is 7?(+, R(-, zl, Yl, \nh,71, -)> R(62, z2, y2, +,72, ~2), ~!7!e) implying that (twice F) has type 7 = 7?(+: +,7?(-, Z1,Y1, \n+,71,-), R( , w,yl, +,-yl, ), , ] ) It is easy to show that this type is not the im\u00adage of a tidy type \nexpression under R+. Both rl = 7?(+, R(-, q, Yl, +j+) )) q-,q, yl,+, +,-) j-, > ) q = X?(+, n(-, zl, \nyl,+, , )7 R/(-, q,yl,+, , ), , , ) are flag instantiation of T, implying that T1 and rz denote supertypes \nof T. But rl and rz encode the types a --i a and a + b -+ a + b, respectively. From Example 4, we know \nthat these two types are not su\u00ad pertypes of any tidy type except Yx(x -+ x), which is not a valid typing \nfor (twice F ). In the general case, the parametric type for a pro\u00ad gram phrase represents a non-empty \nset of tidy types that could be inferred in Inf. Fortunately, it is easy to determine exactly how many \ntidy types a paramet\u00ad ric type represents and what they are, The decoding process translates a parametric \ntype scheme p into a unique tidy type scheme r iff there is a smallest type in the set of supertypes \ndenoted by p. Each occurrence of a flag variable contributes positively or negatively to the denoted \ntype. The decoding process yields a single tidy type iff all the occurrences of each flag variable are \neither positive or negative. Definition 11 An occurrence of a flag variable in a parametric type term \np is positive iff it appears within the left hand argument of of an even number of -+ constructors. Otherwise, \nthe occurrence is negative. A jlag substitution for p is a substitution that binds all the flag variables \nof p to + or and nothing else. A parametric type term p is univalent iff there is a flag substitution \n(substitution for flag variables) that binds every positive occurrence of a flag variable to . and every \nnegative occurrence to +. This substi\u00adtution is called the minimizing flag substitution. The result of \napplying the minimizing flag substitution to a univalent type term p is called the minimum instance of \np. parametric type term produced by applying A flag variable is a splitting variable in p iff it occurs \nboth positively and negatively. If p is not univalent, then its valence is 2~ where k is the number of \ndistinct splitting variables in p. A splitting substitution for a parametric type term p is a flag substitution \nthat binds all vari\u00adables that occur only positively to , all variables that occur only negatively to \n+, and the splitting variables to either + or . A parametric type term is ground iff it contains no flag \nvariables (type variables may still be free). Remark The minimizing substitution for a univalent term \nis a degenerate form of splitting substitution. Hence, the number of distinct splitting substitutions \nfor a parametric type term p equals the valence of p. Ground parametric type terms are easy to decode \nbecause they are the images of supertype encodings composed with minimizing substitutions. Let min be \nthe function that maps univalent parametric type terms to their minimum instances. Then the decoding \nfunction R-1 is the inverse of min o R+. Definition 12 [Decoding Function] The function R-1, which maps \nparametric ground terms to tidy type expressions, is defined by the following equat ions: R-l(p) = t \ntcv fix X. R-l(M) p= fix x.M ~, R;l(p) otherwise [  R;l(p) = t t~v fix X, R-](M) p =fix x.M ci(R-l(tl), \n. . ..l(tn)))) ~=~(sl,...,s~), Si=(+, tl, . . ..tn) 0 otherwise { Given the preceding definitions, it \nis easy to define the decoding translation of any parametric type term p. The translation consists of \ntwo steps. First, gener\u00adate the set S of all of the splitting flag substitutions for p. Second, for each \nsubstitution in s E S, compute R-1 (sp), yielding the set of tidy type expressions rep\u00adresented by p. \n6.4 Type Assignment Algorithm To recapitulate the preceding discussion, our type as\u00adsignment algorithm \nconsists of three steps. 1. Encode the set of supertypes for each primitive operation as parametric type \nterms (R6my nota\u00adtion). 2. Perform ordinary type assignment using the cir\u00adcular generalization of algorithm \nW. 3. Translate the parametric type expressions as\u00adsigned to progr~m phrases back into-(sets of) tidy \ntype expressions.  The algorithm is reasonably efficient because it is simply the circular generalization \nof Algorithm W from ML applied to a transformed collection of type constructors and t ypings for the \nprimitive operations. Circular unification like ordinary unification can be performed in linear time. \nOf course, the worst case running time of Algorithm W is exponential in the number of nested let declarations, \nbut this behavior has never been observed in practice presumably be\u00adcause the type expressions produced \nin these patholog\u00adical cases are enormous and hence incomprehensible. 6.5 Some examples Consider the \nfunction mixed = A x.if x then 1 else nil defined in Example 1. Our algorithm assigns the type true + \nfalse ~ suc + nil to mixed, A more interesting example is the function taut which determines whether \nan arbitrary Boolean func\u00ad tion (of any arity!) is a tautology (true for all inputs). Example 7 [Tautology \nexample] taut = AB,case B of true : true false: false fun : ((and (taut (1? true))) (taut (B false))) \nFor the taut function, our algorithm produces the typing taut : ~ ~ (true + false) where ~ = fix t.(true \n+ false + ((true+ false) ~ t)). 7 Inserting run-time checks As we explained in the introduction, no sound \ntype checker can pass all good programs. The polyreg\u00adular type checker described in section 6 succeeds \nin assigning static types to a large class programs. iTev\u00adertheless, some good programs will not pass \nour type checker, as the following example demonstrates. Example 8 ] The function NI = ~ ~. if ~(true) \nthen ~(5)+ f(7) else f(7) fails to type check because the parameter ~ has to satisfy conflicting constraints. \nThe if test forces f : true -+ true + false. Similarly, the true arm of the if requires $ : suc -+ z \n+ SUC. But there is no unifier for these two typings off, preventing the type checker from assigning \na type to N1. The function N1 is not badly defined, however, because iV1 (A *.x) never goes wrong. Sometimes \nour type checker fails to account for all the possible uses of a function. Consider the following modification \nof the previous example. Example 9 [An anomaly] Nz = ~ f. i.f ~(true) then ~(5) else f(7) In this case, \nour type assignment algorithm yields the typing N2 : (true+ suc ~ true+ false) ~ true i-false. However, \nthe application N2 (A z.z) is well-defined, but does not type check. In both of the preceding examples, \nthe program is meaningful, but the type anal ysis is not sufficiently powerful to assign an appropriate \ntype. The static type checker described in Section 6 will reject these programs, in spite of their semantic \ncontent. A soft type system, however, cannot reject programs, It must insert explicit run-time checks \ninstead. Hence, we must produce an algorithm to transform arbitrary programs to equivalent programs that \ntype check. To support the automatic insertion of explicit run\u00ad time checks, we force the programming \nlanguage Exp to include an exceptional value fault and a collection of functional constants called narrowers. \nThe narrow\u00ad ers perform run-time checks and the exceptional value propagates the fact that a run-time \ncheck failed, To define these notions more precisely, we need to intro\u00ad duce the concepts of primitive \nand simple types. Each type constructor determines a primitive type: it con\u00ad sists of all values that \nbelong to some instance of the type. We denote the primitive type corresponding to a constructor c by \nthe name of the constructor c. Since the type constructors are disjoint, every value (other than errors) \nbelongs to ezaciiy one primitive type. For values that are not functions, the primitive type of the value \nis the outermost constructor in the representa\u00ad tion of the value. For a function, the primitive type \nis simply a. A simpie type is simply a union of prim\u00ad itive types. Using notation analogous to type terms, \nwe denote the simple type consisting of the union of primitive types tl, . . ., tnby the expression tl \n+. . .+tn. The exceptional value is denoted by fault. Simi\u00ad larly, there is a narrower .IJ$ for every \npair of simple types such that S G T. It is defined by the equation v VET J; (v) = fault VES T { wrong \notherwise The type associated with the narrower J&#38; is sl +. . . ~ tl +... where S={sI,...} and T= \n{tI,...}. The type insertion algorithm consists of the follow\u00ading three steps: 1. Encode the set of supertypes \nfor each primitive operation in parametric form using R+ and con\u00advert all ~ flags in the encoding to \nfresh type variables eliminating all negative information. 2. Perform type assignment using the circular \ngen\u00aderalization of algorithm W, constructing a {posi\u00adtive type (in parametric form) for every program \nexpression. 3. For each occurrence of a primitive operation, unify the positive type with the original \ntype (encoded in parametric form), If unification fails, insert the narrower required for unification. \n  The invocation of Algorithm W in the type inser\u00adtion algorithm always succeeds in assigning a type \nto every program expression because the only way that Algorithm W can fail is to attempt to unify a + \nflag and a -) flag.3 Since no - flags can appear in any of the type terms manipulated by the algorithm, \nevery unification step must succeed. However, the type as\u00adsignment is based on the assumption that every \nprim\u00aditive operation explicitly checks the type-correctness of any argument that it evaluates. If the \ncheck fails, the primitive operation must return the special value fault as its answer. All of the primitive \noperations are strict with respect to this special value.4 The final unification step determines which \nrun-time checks are unnecessary. If the input program is statically type correct, no run-time checks \nare inserted. Note that the narrower inserter algorithm is essen\u00adtially the type assignment algorithm \npartitioned into two phases: the propagation of positive information followed by the propagation of negative \ninformation. In the second phase, narrowers are inserted where the negative information in the input \nside of prim\u00ad itive functions clashes with the positive information inferred for their arguments. 3Algorithm \nW never attempts to unify a flag variable with a pat tern variable or a fix operation because all parametric \ntype terms are we~l-fomzed. 4 We are using the term strict in a slightly different sense than it usually \nis in the literature. Primitive operations must return the value fault if they evaluate an argument and \nthat evaluation returns fault as the answer.  7.1 Examples To illustrate the insertion process, we analyze \nhow it handles the two troublesome examples that we pre\u00adsented at the beginning of this section. In both \nof these examples, let cl-and C2 denote the narrow\u00ad z+suc+true+falsez+suc+t~Ue+false and !true+false \n, re\u00aders Uz+suc s~ectivelv. L. The insertion algorithm changes the function IVl in example 8 to IV; \n= A ~. if c.2(~(true)) then cl(~(5)) + cl(~(7)) else ~(7) The type for IV{ is now (z + suc + true + \nfalse ~ z + suc + true + false) a z + suc and the applica\u00adtion N; (A X.2) is now type correct. Similarly, \nin example 9, assume that a program con\u00adtains definition of Nz and the application (lV2 (Ax.z)). Then \nour insertion algorithm will modify the definition of N2 to produce Nj = ~ ~. if cz(~(true)) then ~(5) \nelse ?(7) Now, the type system infers the type for N; as: (z+ suc + true + false+ z + suc + true+ false) \n-+ z + suc + true+ false and Nj(A Z.Z) now type checks. 8 l%elatecl Work The earliest work on combining \nstatic and dynamic type checking was an investigation of the type dy\u00ad namic conducted by Abadi et al[l]. \nThey added dy\u00ad namic data values to a conventional statically typed data domain and provided facilities \nfor converting data values to dynamic values by performing explicit tag\u00ad ging operations. This system \npermits statically typed programs to manipulate dynamic forms of data. But it does not meet the criteria \nfor soft typing because the programmer must annotate his program with explicit tagging and stripping \noperations to create dynamic values and to map them back to conventional (static values. In addition, \nprograms are still rejected; nar\u00ad rowers are not inserted by the type checker. More recently, Thatte[23] \nhas developed the notion of <quasi-static typing that augments a static type system with a universal \ntype f2 that contains tagged copies of all the values in the program data domain. Thatte s system resembles \nsoft typing because it en\u00ad sures that all programs can be executed by inserting narrowers when necessary \nto convert values of type Q to corresponding values belonging to a specific type. However, it does not \nmeet the other criteria required for soft typing for two reasons, First, it requires explicit declarations \nof the argument types for func\u00adtions. Second, it cannot type check many dynamically typed programs (without \ninserting narrowers) because it does not support parametric polymorphism, recur\u00ad sive types, or more \nthan one level of subtyping. Gomard[14] has modified the ML type system to include a type undefined and \ndynamically typed vari\u00adants of all the primitive operations, These variants accept arguments of undefined \ntype. His system can perform a weak form of soft typing by replacing prim\u00aditive operations by their dynamically \ntyped variants. But the types assigned by the system are not very precise because his system does not \naccommodate ei\u00adther parametric polymorphism or union types. As a result, his system cannot statically \ntype check many dynamically typed programs without modifying them. Researchers in the area of optimizing \ncompilers have developed static type systems for dynamically typed languages to extract information \nfor the purposes of code optimization. A good example is the system de\u00ad veloped by Aiken and Murphy \n[2] for FL, These type systems, however, have not been designed to be used or understood by programmers. \nConsequently, they lack the uniformity and generality required for soft typing. Finally, many researchers \nin the area of static type systems have developed extensions to the ML type system that can type a larger \nfraction of (good pro\u00ad grams. Both Mitchell[20] and Fuh and Mishra[12, 13] have studied the problem of \ntype inference in the pres\u00ad ence of subtyping. They augment type expressions by explicit constraints, \nwhich permits them to infer more precise types in some cases than we do. On the other hand, their type \ndescriptions are frequently ver\u00ad bose and difficult to comprehend. In addition, neither of of these systems \naccommodate parametric poly\u00ad morphism. Wand[25] augments the ML by adding record operations that support \na limited form of inher\u00ad itance polymorphism. Curtis[7] has proposed adding constrained quantification \nto the ML type system, The idea looks promising, but it is an open question whether a suitable type assignment \nalgorithm exists. Finally, R6my[21] has developed a clever reduction of inheritance polymorphism to ML \nparametric poly\u00ad morphism that supports parametric polymorphism in the original type language. }Ve have \nheavily relied on this reduction in the construction of our soft typing system. 9 Directions for Further \nResearch In this paper, we introduced a new approach to pro\u00adgram typing called sofl typing that combines \nthe best features of stattc and dynamic typing. To demonstrate that soft typing is feasible, we presented \na soft typing system incorporating union types, recursive types, and parametric polymorphism. For this \ntype system, we showed that there are efficient algorithms for perform\u00ading automatic type assignment \nand automatic coercion insertion. The algorithms are both variants of the type assignment algorithm for \nML. We are currently engaged in a project to design a dynamic generalization of ML and implement the \ngen\u00aderalized language by using a soft type checker to trans\u00adlate it to Standard ML. Since Standard ML \ndoes not infer either union types or recursive types, the soft type checker must perform some supplementary \ntrans\u00adlation. In particular, the type checker must: generate type definitions creating disjoint unions \nand tagged recursive types corresponding to all of the union types and recursive types inferred for \nthe program, and  insert explicit injection and projection operations  to add and remove tags for disjoint \nunions and tagged recursive types. We are also interested in developing new soft type systems that are \nricher than the one presented in this paper. In particular, we want to explore the possi\u00adbility of adding \nsome form of type intersection to the tidy polyregular types. Through this process, we may be able to \nconstruct a type system than subsumes the tidy polyregular types but possesses the principal typ\u00ading \nproperty, In addition, the new type system may have simpler translations to and from R6my notation. As \nwe observed in the paper, the R.6my translation oc\u00ad casionally yields multiple polyregular types for \na given program expression. In a system with intersection types, these multiple types could be expressed \nas a single intersection type. References [1]Martin Abadi, Luca Cardelli, Benjamin Pierce, and Gordon \nPlotkin. Dynamic typing in a stati\u00adcally typed language. In Proceedings of the Six\u00adteenth POPL Symposium, \n1989. [2] Alexander Aiken and Brian Murphy. Static type inference in a dynamically typed language. In \nProceedings of the 18th Annual Symposium on Principles of Programming Languages, 1991. To appear. [3] \nAndrew W. Appel and David MacQueen. Stan\u00addard ML of New Jersey Reference Manual. (in preparation), 1990. \n[4] Robert Cartwright. A constructive alternative to axiomatic data type definitions. In Proceedings \nof 1980 LISP Conference, 1980. [5] William Clinger and Jonathan Rees. Revise&#38;gg Report on the Algorithmic \nLanguage Scheme, Au\u00adgust 1990. [6] Alain Colmerauer. Prolog and infinite trees. In K. L. Clark and S. \nA. Tarnlund, editors, Logic Programming, pages 231 25 1. Academic Press, 1982.  [7] Pavel Curtis. Constrained \nquantification in poly\u00admorphic type analysis. Technical Report CSL-90\u00ad1, Xerox PARC, 1990. [8] Luis Damas \nand Robin Milner. Principal type\u00adschemes for functional programs. In Conference Record of the Ninth Annual \nACM Symposium on Principles of Programming Languages, 1982. [9] Luis Manuel Martins Damas. Type Assignment \nin Programming Languages. PhD thesis, University of Edinburgh, 1985. [10] Bruce F. Duba, Robert Harper, \nand David Mac-Queen. Typing first-class continuations in ML. In Conference Record of the Eighteenth Annual \nACM Symposium on Principles of Programming Languages, 1991. [11] Mike Fagan. Soft Typing: An Approach \nto Type Checking for Dynamically Typed Languages. PhD thesis, Rice University, 1990. [12] You-Chin Fuh \nand Prateek Mishra. Type infer\u00adence with subtypes. In Conference Record of the European Symposium on \nProgramming, 1988. [13] You-Chin Fuh and Prateek Mishra. Polymorphic subtype inference: Closing the theory-practice \ngap. In TAPSOFT, 1989. [14] Carsten K. Gomard, Partial type inference for un\u00adtyped functional programs. \nIn Proceedings of the 1990 ACM Conference on LISP and Functional Programming, 1990. [15] G&#38;ard Huet. \nRt%olution d ~quations clans les lan\u00adgages d ordre 1,2, ..., w. PhD thesis, Universitx$ Paris, 71976. \n[16] D. MacQueen, G. Plotkin, and R. Sethi. An ideal model for recursive polymorphic types. In Con\u00adference \nRecord of the Eleventh Annual ACM Sym\u00adposium on Principles of Programming Languages, 1983. [17] D. B. \nMacQueen and Ravi Sethi. A semantic model of types for applicative languages. In Con\u00adference Record of \nthe Tenth Annual ACM Sym\u00adposium on Principles of Programming Languages, 1982. [18] Robin Milner. A theory \nof type polymorphism in programming. Journal of Computer and System Sciences, 1978. [19] Robin Milner, \nMads Tofte, and Robert Harper. The Dejiniiion of Standard ML. MIT Press, 1990. [20] John C. Mitchell. \nCoercion and type inference. In Conference Record of the Eleventh Annual ACM Symposium on Principles \nof Programming Lan\u00adguages, 1983. [21] Dialer R&#38;my. Typechecking records and vari\u00adants in a natural \nextension of ml. In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming \nLanguages, 1989. [22] David A Schmidt. Denotational Semantics. Allyn and Bacon,Inc, 1986. [23] Sattish \nThatte. Quasi-static typing. In Proceed\u00adings of the Seventeenth POPL Symposium, 1990. [24] Mads 1 ofte. \nOperational Semantics and Polymor\u00adphic Type Inference. PhD thesis, University of Edinburgh, 1987. [25] \nMitchell Wand. Complete type inference for sim\u00adple objects. In Proceedings of the Second Sympo\u00adsium on \nLogic in Computer Science, 1987. A Programming language semantics We divide the specification of the \nsyntax of Exp into two parts. The first part is the syntax of the func\u00ad tional language Milner introduced \nto analyze paramet\u00ad ric polymorphism[18]. It is presented in definition 1 in Section 2 of the paper. \nThat syntax is parameterized by a set of constants 1<. The second part of our spec\u00ad ificat ion identifies \nand defines these constants. The set of constants K reflects the different kinds of data included in \nthe programming language. In Exp, every (non-functional) data value is built from data constructors. \nData constructors may be partial: they can impose modest restrictions on the form of ar\u00ad guments that \nthey accept (a simple form of dynamic typing). In addition to data constructors, K contains a separate \nset of seiectors for each constructor, one for each argument position of the constructor. The specification \nof the constructors and selectors can be succinctly expressed as a data tableau[4]. The follow\u00ading example \nillustrates this idea. Example 10 [A Data Tableau] Consider a program\u00ad ming language with natural numbers \nand lists as data values. We can define the construction of the natu\u00ad ral numbers from O and suc (successor) \nin the usual fashion. Lists are either empty (nil) or constructions built with cons. The data tableau \ndescribing this data language is: constructor O; constructor suc(pred: O + SUC); constructor nil; constructor \ncons(head: O + suc + cons + nil+ ~, tail: nil + cons) The tableau designates pred as the selector for \nsuc constructions, and head and tail as the selectors for cons constructions, It also indicates that \nthe argu\u00ad ment in a suc construction must be either the con\u00ad st ant O or a suc construction. The first \nargume~t of a cons construction may be anything, The pseudo\u00ad constructor ~ designates the set of functions \nso that functions may appear within constructed values. To manipulate the data values defined by a tableau, \nwe need to include case functions in K. For every non-empty, non-repeating sequence s of constructor \nnames (including -+), there is an n-ary case function where n is 1 + length(s), An informal description \nof the semantics of these functions is given in Section 2. We define the denotational semantics for Exp \nalong standard lines as presented in Schmidt [22]. The data domain D for Exp depends on the constants \nspecified in the data tableau. We define D as follows: Definition 13 [The data domain D] Let C = {ci \n12 ~ i < n} be the set data constructors (excluding -) de\u00adfined in the tableau and let Triv = {*, l..} \nbe a one point domain. Let Do, F, and W abbreviate Triv; let Dk abbreviate D @ D[k 1, where @ is the \ndomain smash product; and let DI c I abbreviate Dar@ fcl J. The data domain D is the least solution to \nthe equa\u00adtion DIO,I . . D= D~D@ ... .@F@W where 6 denotes the domain smash sum. The domains separated \nby @ operators on the right hand side of the equation are called summands of D. For each constructor \n(including ~), there is a cor\u00adresponding summand in definition 13. We define [Z]r) = q(z) [k.e]q = In~+~(M[e][z \n= 4) wrong dl = wrong fault dl = fault [(e, e~)]~ = wrong d2 = wrong fault d2 = fault { ~1 (d2) otherwise \nwhere dl = [el]q), dz = [ez]q f~ = Out~+~(dl) [let z = el in ez]y = [ez]q[~ = all], where dl = [el]q \nFigure 3: Semantic function for Exp fault = ~nF(x) and wrong = lnw(*). The wrong value represents undetected \nrun-time errors, and the fault value represents safely detected run-time excep\u00adtions. In the denotational \ndefinition for Exp we use the following notation, For each summand A, the symbol InA : A * D denotes \nthe standard injection function mapping A into D. Similary, the symbol @tA : D -i A denotes the standard \nprojection function mapping D onto A. In addition, the conditions appearing in a definition of the form \nvail condition f(z) = { Valk condition are tested in sequential order, implying no condition can be satisfied \nunless the conditions preceding it fail. Definition 14 [Denotational Semantics of Exp] Let Env be the \ndomain of environments Id ~ D. The semantic function [.] : Exp -+ Env --+ D is defined in figure 3. Before \nwe define the semantics for constants, we need to define some auxiliary functions. Let R = {rl, . . . \n. rn } be a set of constructors. The auxiliary function CR verifies that its argument belongs to one \nof the summands specified by R. It is defined by the equation: (d d = Innrl (d ) CR(d) = ~ d d = InDr-(d \n) \\ wrong otherwise [c] = IT2DC(*) n=(l [c] = In~+D(K) n # o iic~se(c,,..,,ck)l= lnD+D(c)  = In~+~(N) \n[u:] where Adl. ..dn. 1< = In~c(CR, ((all, . . . . dn))) I ~dfl....fk. fl(d) d = InC, (d ) c = d = \nInC, (d ) wrong otherwise fk(d) Ad, d CT(d) # wrong N= fault CS (d) # wrong /( wrong otherwise Figure \n4: Semantics for primitive operations where Dr, is the summand of D associated with con\u00adstructor r~. \nFor sets of constructors R~, 1< i < k, we define: CR,,...,R~((dl, . . .,d~)) = (d,,..., dk) foralli,l<i<k \nCR, (d~) # wrong wrong otherwise { Definition 15 [Semantics of Constants] The seman\u00adtics for constants \nis given in Figure 4 where c is an arbitrary constructor of arity n, Dc is the associated summand in \nD, and Ri indicates the set of restric\u00adtions on the i-th argument of c declared in the data tableau. \nSince the meaning of constants does not de\u00adpend on the environment, the environment argument is left \nimplicit, B Type Semantics Our semantics for types is based on the ideal model for recursive parametric \ntypes developed by MacQueen, Plotkin and Sethi[16]. Ideals are downward-closed, directed-closed subsets \nof D. We denote domain of ideals over D by the symbol Z. MacQueen, Plotkin and Sethi define a metric \non the ideals and use that metric to define a fixed point oper\u00ad ation on contractile type functions \nmapping Z into Z. They show that the abstraction of a type expression T[c]v = DC U fault T[c(tl, . . \n.,tn)]v = ~nDc((T[tl]~, . . . ,T[t&#38;)) U fault T[tl -+ tz]v = T[tl]v ~ T[tz]v U fault T[tl + tz]v \n= T[t@ U 7[tz]v T[fix a.t]v = P if(i) U fault where f(i) = T[t]v[a = i] Figure 5: Type Semantics that \nis formally contractile in the type variable x with respect z denotes a contractile function on Z. Definition \n16 [Formal Contractiveness ] A type ex\u00adpression E is formally contractile in a iff either: 1, E = c for \nc a O-ary type constructor. 2. E = x for some variable x # x. 3, E=c(E1, ..., En) for C. an n-ary type \nconstruc\u00adtor (including +). 4. E = El + Ez where El and Ez are type expres\u00adsions that are formally contractile \nin z 5. E = fix z .E1 where El is formally contractile in xand x .  Definition 17 [Type Semantics] \nThe semantics of the type language Typ is given by the meaning func\u00adtion To defined in Figure 5. In the \ndefinition, v : V -T denotes a valuation for free type variables; Ins de\u00adnotes the injection function \nfor summand S mapped over ideals of S (interpreted as sets); p stands for the fixed point operator on \ncontractile functions mapping Z into Z: c denotes any type constructor other than -+: and ~: Z ~ Z ~ \nZ denotes the ideal function space constructor defined by the equation: A~B={fc D~Dlf(A)~ B}, The type \nsemantics constructs ideals that exclude wrong so that undefined applications cannot type check. On the \nother hand, all of the ideals include the element fault, so that narrowers have a legiti\u00ad mate static \ntype. \n\t\t\t", "proc_id": "113445", "abstract": "", "authors": [{"name": "Robert Cartwright", "author_profile_id": "81406592800", "affiliation": "Department of Computer Science, Rice University, Houston, TX", "person_id": "PP43116956", "email_address": "", "orcid_id": ""}, {"name": "Mike Fagan", "author_profile_id": "81100015595", "affiliation": "Department of Computer Science, Rice University, Houston, TX", "person_id": "P200439", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/113445.113469", "year": "1991", "article_id": "113469", "conference": "PLDI", "title": "Soft typing", "url": "http://dl.acm.org/citation.cfm?id=113469"}