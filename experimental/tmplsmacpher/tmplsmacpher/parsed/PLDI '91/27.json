{"article_publication_date": "05-01-1991", "fulltext": "\n Monitoring Semantics: A Formal Framework for Specifying, Implementing, and Reasoning about Execution \nMonitors * Amir Kishon Paul Hudak Charles Consel Yale University Department of Computer Science P.O. \nBox 2158 Yale Station New Haven, CT 06520 {kishon,hudak, consel}@cs. yale. edu Abstract 1 introduction \nWe introduce monitoring semantics, a non-standard model A program execution monitor is a system that \nmonitors the of program execution that captures monitoring activity as dynamic run-time behavior of a \nprogram. Examples include found in debuggers, profilers, tracers, etc. A monitoring se-debuggers, profilers, \ntracers and demons. .,Monitors are an mantics is a conservative extension of a language s standard obviously \nimportant element in any software development dena,tational semantics, and is parameteri?ed with respect \nenvironment. However, ss was mentioned in a 1981 survey to specifications of monitoring activity. of \nthe field, program execution monitoring has been ne\u00adglected as a research topic; the available literature \ncontains 13eyond its theoretical interest, monitoring semantics mainly case studies, without an adequate \ndiscussion of the forms a practical baais for building effective monitors, with fundamental concepts, \ngoals and limitations [P N81]. The standard partial evaluation techniques being used as a key work described \nin this paper grew out of a perceived need for optimization strategy. In particular, specializing a moni\u00ad \na more formal treatment of program execution monitoring, torim g semantics with respect to a source program \namounts with the hope of developing a formal basis for such monitors to removing the interpretive overhead \nassociated with the that could easily be related to the standard semantics of a static aspects of monitoring, \nyielding an instrumented pro\u00adsource language, and that could form a practical basis for gram in which \nthe extra code to perform monitoring actions building effective monitors for use in the real world. has \nbeen automatically embedded into the program. This paper introduces monitoring semantics, a formal A. \nmonitoring semantics can be automatically derived for basis for program execution monitors. Monitoring \nsemantics any language for which a continuation semantics specific~ provides a generic semantic model \nfor monitors with the tion has been provided. This is achieved by using function\u00adfollowing characteristics: \nal toembed non-standard behavior at all levels of recursion. We illustrate the approach for a higher-order \nfunctional lan\u00ad 1. A monitoring semantics can be automatically de\u00adguage, showing examples of several \ndifferent monitor speci\u00adrived from any denotational semantics specification ex\u00adfications, including benchmarks \nof their implementations. pressed in continuation style. This is achieved by us\u00ad ~ his research wss supported \nby DARPA grant NOO014.SS-K-0573 ing ~unctionah to embed non-standard behavior at all and a DARPA sub-contract \nfrom Software Options, Inc. levels of recursion such that their fixpoints yield the Perrniseion to copy \nwithout fee all or pert of thie meterial is granted desired result. provided thet the copies ere not \nmede or distributed for direct commercial advantage, the ACM copyright notice end the title of the publication \nand 2. The derived monitoring eemantics is parameterized its date appear, and notice is given that copying \nis by permission of the with monitor specifications which, once instantiated, Association for Computing \nMachine~. To copy otherwise, or to republish, requires a fee and/or specific permission. are able to \ncapture any sequential, deterministic mon\u00ade 1991 ACM 0-89791 -428 -7/91 /0005 /0338 . ..$1 .50 itoring \nactivity. 3. Any monitoring semantics derived in this way is cora- Proceedings of the ACM SIGPLAN 91 \nConference on Programming Language Design and Implementation sistent with the original standard semantics \ni.e. it is Taronto, Ontario, Canada, June 26-28, 1991. [z Transliteration ~ ~ns~er ~ Stan.&#38;ard %fonitor \n Sernantia Specificatwns fi~fj) [Sectwns 5 &#38; 8] [Sectwn 3] I L Parameterize~ !lfonitorin~ 1 5Monit0rin$ \nSemantics *Semu.tics \u00ad fix (M{(j))) [Sectwn 4] Figure 1: Semantic not possible for a monitor to change \nprogram behavior. 4. The method is cotnpositionat-monitors may be built on top of other monitors to produce \ncomposite moni\u00adtorin~ behaviors. 5. Using standard partial evaluation techniques, it is pos\u00adsible to \nbuild practical monitors using our methodol\u00adogy; i.e. monitors whose execution speed matches that of \nconventional interpreters.  Points 1 and 2 indicate the degree of generality of our methodology it can \nbe used for any programming lauguage for which a continuation semantics is available, and it is able \nto capture a very broad class of program monitoring activ\u00adities. Points 3 and 4 highlight the safety \nand rnodularit~ of our approach, respectively, thus easing the processes of specifying and reasoning \nabout monitors. Finally, point 5 indicates the practicality of our approach, and indeed we have working \nimplementations of several monitors built us\u00ading our techniques. A philosophical consequence of our methodology \nis the raising of monitoring semantics to the same first-class sta\u00adtus as staudard semantics -a consequence \nthat seems emi\u00adnently desirable, given the intimate relationship between the programmer and the non-standard \nbehaviors that typify the program development process (it is only the final prod\u00aduct whose black-boxn \nbehavior corresponds most closely with the standard semantics). Perhaps more import antly, we believe \nthat our methodology will enable programmers to write their own monitors in an effective, straightforward \nway (without fear of changing program behavior), rather than be confined to the limitations and rigidity \nof most software development environments. As an example of our method\u00adology in action we will introduce \nthe monitoring semantics T $lro~ram &#38; Data I Transliteration i %2m0er &#38; Uni or ~ !Monitor Imteractwn \n relations diagram of a higher-order language and provide the specification of several common monitoring \nactivities for that language (a tracer, a profiler, a demon and a collecting monitor). Current Methodologies \nDespite the importance of moni\u00adtors in any software development environment, the lack of formal and general \ntreatment of the problem is evident in current research. Current approaches for const rutting mon\u00aditoring \nsystems are mainly based on instrumenting either the source code [DFH88, H085, TA90] or an interpreter \n(or abstract machine) [OH88, SS89, Sha82] to include monitor\u00ading behavior. As general methodologies many \nof these ap\u00adproaches have limitations: they may interact adversely with the normal execution of the program \n(or with other monitor\u00adiug activities), they have little formal semantic justification, and they usually \nrely on hand-crafted techniques. Our ap\u00adpreach attempts to resolve these problems by providing a general \nframework for specifying, implementing and reaaon\u00ading about monitors. Our work compares most closely \nwith O Donnell and Hall s work [H085, 0H881, which advocates . ., enhancement of program results with \ndebugging data, and with Safra and Shapiro s work [SS89], which advocates the use of partial evaluation \nto instrument interpreters. outline This paper is organized as shown in Figure 1, which also illustrates \nwell the relationships bet ween the var\u00adious semantic entities (e.g. standard semantics, monitoring semantics) \nand concrete entities (e.g. interpreters, monitors) that our methodology comprises. In Section 2 we present \nan overview of our approach, From the standard semantics specification G described in Section 3, we describe \nin Sec\u00adtion 4 how to automatically derive a parameterized monitor\u00ading semantics M(G). Then in Section \n5 we describe how to irwtantia te such a semantics with particular monitor speci-result in any significant \nloss of expressiveness, since a con\u00adfications, thus yielding a complete monitor. Sections 6 and tinuation \nsemantics is able to capture the behavior of any 7 discuss the compositionality and soundness of monitoring \ndeterministic sequential language. Languages that don t re\u00ad semantics, respectively, and Section 8 presents \nseveral ex-quire the extra expressiveness (such as purely functional lan\u00adamples. Finally, Section 9 addresses \nimplementation issues. guages) can still be expressed in a continuation style. 2 An Overview of Semantic \nMonitoring In a nutshell, our approach to monitoring program execution can be intuitively described as \nfollows: A language s continuation semantics specifies a linear or\u00addering on program execution, and thus \ncan be used as the basis for ordering monitoring activity (just as it is used to guide code generation \nin semantics-directed compilers ), But instead of interpreting a program s meaning as an ele\u00adment a in \na domain Ans of final answers, we will interpret it as a function ~ with type ~ = MS + (Ans x MS), where \nMS is a domain of monitor states . Given u : MS as an initial (presumably empty) monitor state, then \nj u = (cv , a ), where a is the resulting monitoring information. We construct such an interpretation \naa a parametrized se\u00admantics in such a way that all instantiation of the semantics (i.e. all possible \nmonitors defined using our approach) have the property that a = cr. The technique used in deriving the \nmonitoring semantics for a language is somewhat unique in itself, relying not just on standard use of \nhigher-order functions, but on the use of functional to embed non-standard behavior at all levels of \nrecursion such that their fixpoints yield the desired result. Finally, by treating the resulting specification \nas a pro\u00adgram (via transliteration into a functional language), we have essentially constructed a (non-standard) \ninterpreter. Although inefficient if executed directly, partial evaluation can be used to enhance efficiency \non a sound basis, just as is done in work on semantics-directed compilat ion. Notation The reader is \nassumed to be familiar with the concepts and terminology of continuation semantics as found, for example, \nin Gordon [Gor79], Schmidt [Sch86], and Stoy [Sto77]. We will use boldface for domains, and the notations \nX 4 A*i -+ Y and $ x a*i y to denote X+ Ail +.. .-+A;n -+ Yand fxa,, . .. a.. yfor some n respectively. \nAs an aid to the eye, continuations are enclosed in braces {}. Square brackets are used for environ\u00adment \nupdate, as in erzv[e ++ z]; angle brackets are used for tupling, as in (el, e2, es); and domain projection \nand injec\u00adtion are noted by (z ID) and (z in D) respectively. 3 Continuation Semantics Framevmrk As mentioned \nearlier, we assume that a continuation seman\u00ad tics is used to express the standard semantics. This does \nnot Definition 3.1 (Standard Continuation Semantics) A standard continuation semantics specification \nis a triple Den = (Syn, Alg, Val) where: Syn denotes the abstract syntax definition of the lan\u00adguage \nin the form of BNF rules specifying syntactic domains Si. Alg defines the set of semantic algebras, which \nare the semantic domains Ai plus operations over them. In particular Ans denotes the domain of answers. \nVal denotes the collection of valuation functional (one for each syntaz domain). Each valuation functional \ngi has functionality: ~$:Ti+T, where Ti = Si + A*, -+ Kent, -+ Ans Konti = A+,) -+ Ans The fixpoints \nVi : Ti Of the functional Gi (i.e. V, = fix ~,) are the valuation functions that map syntactic terms \nto their meanings. The explicit identification of the functional will allow us to derive new valuation \nfunctions that inherit the be\u00adhavior of the old. The sequence A*, of arguments to Yi constitutes the \nnormal semantic context necessary to per\u00adform an evaluation (e.g. environment, state, etc.), and the \nsequence A*,, of arguments to Kent, denotes intermediate results. As an example of this semantic framework, \nFigure shows the continuation semantics for a higher-order func\u00adtional language consisting of conventional \nconstructs such as applications, abstractions, constants, identifiers, condi\u00adtionals and letrec clauses. \nThis langnage, which we will call LA, will be used throughout the paper to illustrate the dis\u00adcussion; \nits simplicity will allow us to focus on the essence of our approach. 3.1 Parametrizing standard continuation \nsemantics with respect to its final answer Since a continuation represents a program s complete com\u00adputation \nupon some intermediate results, the continuation may contain some final processing that produces the \nfinal answer. This allows one to map a program s final answer to Abstract Syntax (Syn): k c Con Constants \nZ, ~ E Ide Identifiers, either bound variables or function names e E EXP Expressions e ::= k Constant \nlx Identifier [lambdaz. e Lambda abstraction I if el then ez else .3 Conditional I e, e~ Application \nI letrec ~ = lambda z . el in ez Letrec Semantic Algebras (Alg): b G Bas=Int+Bool+ . . . Basic values \nFun = V ~ Kent ~ Ans Function values v C V= Bas+ Fun Denotable values a E Ans Answers P e Env=Ide~V Environments \n~ E Kont=V~Ans Expression continuations Valuation Functional (Val): ~A : T~ a T~ Expression valuation \nfunctional where T~ = Exp a Env ~ Kent ~ Ans Gives meaning to expressions K: Con * V Gives meaning to \nconstants f7A&#38;ep~= case e of [k] : K(K [k]) [z] : fc(px) [lambda z . e] : K ((Av. C[e] p[z w v]) \nin Fun) [if el then ez else e~] : ~[el] p {Av. VIBOO1 + t~ez] p K, t[es] p K} [el e2] : t[e~] p {Avz. \nS[el] p {AtJI. (v~ll?un) v, E}} [letrec ~ = lambda z , el in e,] : t[ez] p K whererec p = p[.f * (Au \nE[el] p [z * v]) in Fun] Figure 2: Standard Continuation semantics for ZA arbitrary value spaces. For \nexample, consider the answer of a L ~ program with an initial continuation: Definition 3.2 (Answer Transformation) \nLet Den be a K.i*i* = {A?J. I inall%ocessing(v)) standard continuation semantics (Definition s.1) with \na standard answer domain Ans. An answer transformer for This would map .C~ s final answer to whatever \nis specified by Den is a function ~ such that: ~ : Ans -+ A~s where A;s FinalProcessing. As is mentioned \nin [Sch86] this general\u00ad is a new domain of answers. ization makes continuations especially suitable \nfor handling Correspondingly, Den s specification can be pararneter\u00ad unusual answers. Later, we will \nmake an extensive use of ized with respect to the answer domain by mapping everg this property in deriving \nthe monitoring semantics; but first answer value o E Ans produced in the specification to an let us formalize \nthis notion. element ii E Ans using an answer transformer ~ (given as a parameter to the specification) \nsuch that &#38; = (~ a). Note that by factoring out the answer transformer from the specification, we \nhave essentially parameterized the se\u00ad 341 man tics with respect to its answer domain. The explicit \nidentification of the answer transformation will later allow us to redefine the semantics final answer \nby changing this operator. For example, a possible initial continuation for the LX S specification shown \nin Figure 2 is provided by: since L ~ s final answer is solely produced by its initiat con\u00adtinuation; \nan initial continuation: will provide the desired paramet erization, Note that in the case of the standard \nsemantics ~ is the identity function. However, we can make the .Ca s final an\u00adswer more interesting by \nproviding a more elaborate answer transformation; for example: d,t, where ~,t~ : Bas + String 4.,, u \n= lThe result is: 1 + iostr-(v) where to% : Bas ~ String This answer transformer maps the results of \nLa to character strings. Similarly, in the next section we will redefine the answer transformer to map \nthe semantics finat answer to the m~nitoring answer domain. 4 Pararmterized Monitoring Semantics We now \nwish to enhance the continuation semantics in such a way as to yield a parametrized monitoring semantics \nwhich, when instantiated with the appropriate functional\u00adisty (a monitor sp ecificat ion), will yield \na complete monitor. The necessary changes to the continuation semantics are de\u00adscribed in the following \nparagraphs. 4.1 Monitoring Annotations We make only one assumption concerning the syntax of the programming \nlanguage: that every syntactic category may be tagged with auxiliary monitoring information. Tech\u00ad nically \nwe could avoid this assumption by noting that every program point may be uniquely identified by tracing \nits lo\u00ad cation from the root of the program s syntax tree, and thus one could provide, as a separate \nspecification, a mapping of these program points to the auxiliary information. However, we find our approach \nto be simpler and clearer. The annotations themselves may cent ain arbitrary infor\u00admation for use by \nthe monitor. In their simplest form they might act as labels through which the system may uniquely reference \nany program point; in more complex situations, they may involve directives to control the monitoring \npro\u00adcess. We imagine that in practice the annotations would not be added explicitly by the user, but \nrather would be supplied by a suitably engineered programming environment. For ex\u00adample, a user may invoke \na command to trace calls to the function f, and the system would then virtually (or perhaps literally) \nadd the appropriate annotation to the definition of f. The examples in Section 8 were in fact generated \nin this way. Such a mechanism eases the burden on the user and reduces the possibility of editing errors. \nIn any case, for technical convenience we assume the presence of annotations. Informally, for each synt \nattic do\u00admain S~, let pi c Anni be the set of annotations allowed for that domain, and define the annotated \nsyntactic domain ~i by: 3; G ~i ::= (original BNF clauses) I pi:st As an example, the enhanced syntax \nfor expressions in LA with p E Ann is simply: It is noteworthy that this enhancement can be expressed \nformally in a way analogous to the enhancement to the val\u00aduation functional (to be described in the next \nsection). To do so, we use a non-conventional method to prescribe the annotated syntax sgntactic functional. \nUsing the LA syntax to illustrate this method, let Ii be: ?-t(Exp) = Con u Ide u {[lambda x . e] I z \n6 Idej ec EXP} U {[if el then ez elsees] I el, ez, es c Exp} u {[el e2] I el, ez c Exp} U {[letrec ~ \n= lambda x . el in ez] ]z,f ~Ide, e,,ez6EXP} We interpret ($iz X) aa denoting the set satisfying EXP \n= H(Exp). The new grammar can then be defined by (fiz ~) where: . lt(Exp) = ?f(~) U {P,:z I pi G Anni \nand E 6 ~} This technique will be useful in incrementally enhancing the grammar in the presence of cascaded \nmonitors. 4.2 Monitoring State One of the assumed parameters in the new semantics will be the monitoring \nstate MS, which captures information of interest to the monitoring process, and which will be in\u00ad crementally \nmodified by the monitoring functions described below. 4.3 Monitoring Functions At program points that \nwe wish to monitor, we probe the evaluation process just before, and just after, evalua\u00ad tion. The flow \nof control necessary to achieve this is already captured by the continuations, and thus the monitoring \nse\u00admantics to be defined will essentially compose pre-and post\u00adprocessing functions before and after \neach monitored contin\u00ad uation. More specifically, foreach valuation function V8 :S, + A*i + Kent; -+ \nAns, a pair of monitoring functions Mvi is defined consisting of two functions M~~k and M~~.t with functionalities: \n v The pre-m onitoring function MPTe gathers information be. tore the evaluation of a program point, \nand thus takes as arguments the syntax, the semantic arguments A*i, and the current monitoring state; \nit yields a new monitoring state. The post-monitoring function M$,~ is invoked afler the valuation, and \nthus takes as an additional argument the intermediate resultsn Axi{ normally passed to the contin\u00aduation. \nThis behavior characterizes the interaction between the standard behavior and the monitoring behavior, \nand we argue that it captures the generic characteristics of any se\u00ad quential monitoring behavior. The \nresulting parametrized monitoring semantics is pre\u00adsented in Definition 4.1. In other words, as stated \nearlier, the meaning of a program will be a function mapping an initial monitor state into a pair: the \noriginal answer and a final monitoring state.2 To give some intuition behind parameterized monitor\u00ad ing \nsemantics, Figure 3 shows the monitoring semantics for CA. In particular, consider the valuation functional \n~~ of LA (Figure 2), whose derived valuation functiord ~ is shown in Figure 3. Note first that the functional \n~ has essentially the same behavior as ~~ for all expressions except labeled ones. It is the use of the \nfunctional describing the valuation functions that permits this extension to be carried out in a modular \nfashion. Since the valuation function is the fixpoint of the newly derived functional, the new behavior \nis exhib\u00adited at all levels of recursion, and thus for all subexpressions of the original program. This \ntechnique has also been used to specify a collecting interpretation @Y88] and to give formal semantics \nto in\u00adheritance in object-oriented languages [CP89, Red88]. The analogy to inheritance is very interesting \nsince the monitor\u00ading semantics ~ can be viewed as inheriting the behavior of the standard semantics \nGA to produce a more complex behavior. Recall that the valuation process communicates its dy\u00adnamic state \nto the monitor before and after valuation of a la\u00ad 1These three components will be packaged into a monitor \nin Def\u00ad inition 5.1. 2 It is worth pointing out that there is a relationship betw@en this transformation \nand monads as reported in [Mog89, Wad90]. Definition 4.1 (Parameterized Monitoring Semantics) Let Den \nbe a continuation semantics (see Definition 9. 1) pa. rameterized with a final answer domain (see Definition \n3..2), in which the final answer Ans has been lifted to ~ = MS -+ (Ans x MS) by the answer transformer: \ndmon :Ans + ~ ~mona=k. (a,u) A monitoring semantics for Den parameteri.d with:i o annotation sgntax pi \nE Anni (Section ~. 1). Q domain u c MS of monitor statea (Section ~..2) a monitoring function pair M \nt for each valuation function Vi in Den (Section 4.9). is defined as follows: Q Syntax: For each syntactic \ncategory Si define an an\u00adnotated syntax =i (see Section 4.1). Valuation Functional: For each valuation \nfunc\u00adtional Gi in Den, define ~i as follows: beled expression. This communication is carried out by the \nrbpdpre and updPost auxliary functions, which apply t~e corresponding pre-and post-monitoring functions \n(i.e. MP,e and MpOSt to the dynamic information needed to produce an updated monitor state. Note how \nthe updated monitor state is propagated throughout the evaluation process (just ) as would be the store \nin an imperative language). An initial continuation defined by ~init = {Av. d~.~ (vlBas)} with ~~o. as \ndefined in Definition 4.1 will return the desired result.  Abstract Syntax (Syn): e c Exp annotated \nexpressions p c Ann monitor annotations . H(Exp) = H(=) u {p,:e I Pi G Armi ma e c ~} (His defined in \nSection 4.1) Semantic Algebras (Alg): (same as in Figure 2) Valuation Functional (Val): T~ --+ T~ where \nT~ = ~-i Env-+Kont-+~ Kent = V+= Ans = MS + (Ans xMS) ~~~cp.= case~of [fl:z ] : (Z [d] p ~PO,,) o updPre \nwhere updPre : MS * MS K: updPre = M$~e [~] [~ ] ~ 6,.., = {Av. (K v) o Updl%t} where updPost : MS \n-MS updPost = M&#38;t [~] [e ] Q ~ else : GA2?cpK (~~ is defined in Figure Z) Figure 3: Parameterized \nMonitoring Semantics for .C~ 5 Denotational Specification of a Monitor In the last section the structure \nof parameterized monitoring semantics was formally defined. This section describes how to instantiate \na parameterized monitoring semantics with a monitor specification, thus yielding a complete monitor. \nThe format that we use is very similar to that of a conven\u00adtional language specification-it consists \nof three parts: the monitor syntax, the monitor algebras, and the monitoring functions. Definition 5.1 \n(Monitor Specification) A monitor specification for a standard continuation semantics Den is a triple \nMon = (MSyn, MAlg, MFun), where: MSyn denotes the monitor syntax which dejines the syntactic domain \nof monitor annotatiorw.  MAlg is the set of monitor algebras which includes the monitor state domain. \n e MFun denotes the set of pairs of monitoring functions, one pair for each ualuation function in Den. \n The similarity between the monitor semantics and a stan\u00addard language semantics is not surprising. Indeed, \nmonitor semantics consists of a language (monitor syntax) to specify monitoring operations, monitor domains \nas value spaces in monitoring semantics, and monitoring functions to map a language abstract syntax annotated \nwith monitor syntax to its monitoring meaning drawn from semantic and monitor domains. As an example \nof a complete monitor specification, Fig\u00adure 4 shows the specification of a profiler which performs the \nsimple chore of counting the number of times an expres\u00adsion with either annotation A or B is evaluated. \nThe first component of the specification is the annotation syn\u00ad tax, defined in the same way as the abstract \nsyntax of any programming language i.e. using conventional BNF nota\u00adtion. The state algebra is shown \nnext, consisting of a pair of counters together with operations that increment those counters. Last is \nthe specification of the monitoring func\u00ad tions which perform the obvious tasks: the pre-monitoring function \nincrements the appropriate counter, and the post\u00admonitoring function does nothing. The following program \nillustrates the use of the profiler: letrec fac = lambda z . if (z = O) then {A}:l else {B}:(z * fac(z \n 1)) in jac 5 Each branch of the conditional has been labeled with a different monitoring annotation. \nThe profiling information Monitor syntax (MSyn): i G Ann i ::=AIB Monitor Algebras (MAlg): 1. Monitor \nstate UC MS=(INX IN) Operations inc_A : MS -+ MS inc-A (m, nz) = (nl + l,n2) inc.B : MS -+ MS inc-B \n(nl, nz) = (nl,nz + 1) inkstate : MS inkstate = (O, O) Monitoring functions (MFun): M$~ :Ann -+Exp \n-+Env + MS + MS M;r= [A] [e] pu~ ~nc~ ~ incA u M$,~ [B] [e] Pu M~O,$ : Ann * Exp *Env4V+MS *MS M$,t \n11.d[e] P VU=u Figure 4: Specification of a simple profiler gathered by monitoring this program with \nthe above moni\u00adtor would be a = (1,5). 6 Monitors Maybe Composed With the simple constraint that the \nannotation syntaxes are disjoint, monitors may be composed in such a way that they are guaranteed not \nto interfere with each other. The method is simple: construct the first monitor from the original con\u00adtinuation \nsemantics as described earlier, then treat the result as a new continuation semantics, and repeat the \nsame pro\u00adcedure in constructing the second monitor. The new answer domain would then be: ~ = Ans xMS1 \n= MS2 a ((Ans xMS1) xMS2) This process may be repeated an arbitrary number of times. Furthermore, this \ntechnique could be used for building ex\u00adtensible programming development environment (a collec\u00adtion of \nmonitors, that is) in an effective, safe and straight\u00adforward way. Another interesting consequence of \ncascading monitors is that a monitor could monitor the behavior of the monitors before it in the cascade \nby providing its monitoring functions with the monitor states. As an example of this technique, Figure \n5 shows the re\u00adsult of starting with the parameterized monitoring semantics in Figure 3, treating it \nas a standard continuation seman\u00adtics, and deriving a new parameterized monitoring seman\u00adtics. The new \nmonitor is assumed to have monitor yta\u00adtions PZ and monitoring functions: M2$re and M2p0st. if Soundness \nThis section discusses the consistency of the monitoring se\u00admantics with the original standard semantics. \nIt is shown that monitoring semantics is a meaning preserving enhance\u00adment to the standard semantics. \nFor the simplicity of the presentation we will consider a standard semantics that has only one valuation \nfunctional. (Because of space limita\u00adtions, we omit the proofs which may by found in [KHC91].) We begin \nby defining some properties of the standard continuation semantics which we will take as assumptions \nin the main theorem. Since our approach is based on continuation semantics it is important to articulate \nthe characteristics of continuation semantics which are relevant to our framework. Obviously, the valuation \nfunctional should be specified as a standard continuation semantics as defined earlier. In particular, \nall calls to valuation functions or continuations must be ((tail\u00adirecursive : values are only passed \nforward. In other words, whenever some function calls either a valuation function or a continuation, \nthe calling function must return the same result as the called function, without performing any further \ncomputation. Indeed, these characteristics correspond to Reynolds definition of continuations [Rey72], \nin particular to his notion of serious functions. Note that we consider the monitoring functions to be \ntrivial (this is the reason why they are not expressed in continuation passing style). The following \ndefinition ensures that the standard se\u00admantics will behave correctly in the presence of monitor an\u00adnotations. \nDefinition 7.1 Let Den be a denotational specification with valuation functional g and suntax S. Given \nany s c S and s E S, such that g is s with added monitor annotations, then ~ is said to be oblivious \nto monitor annotations ifl: (fiz @ [s1 = (fi~ GQN) [~1 where ~O~J V ~ = case 3 of [p:s ] : v [3 ] else \n: GV3 In other words, if ~ is oblivious to monitor annotations then its derived ~A~ functional is guaranteed \nto disregard monitor annotations. Abstract Syntax (Syn): 2, G G doubly annotated expressions P2 G Ann \nmonitor annotations of second monitor . . H(Exp) = ~~) u {PZ:Z I p2 c Annz and Z G ~} (~ is defined \nin Figure 3) Valuation Functional (Val): ~: T~+TAwhere T~=-Exp +. Env -+ Kent + ~ Kent.V-+~ ~ = MS2 \n-+ MS1 + ((Ans x MSI) x MSZ) == G~EZpK= case~of [fb2:E ] : AYl. ((~ [3 ] p ~PO~t al) o updP~e) where \nupdPre : MS2 + MS2 updPre = Mz$,~ [P2] [~ ] P F@.., = {k a:. (x u a;) o ?@Jost} where updPost : MSZ -i \nMS2 updPost = M2;o,~ [/.J2] [~ ] P v = else : GA&#38;zp K Figure 5: Derived monitoring semantics for \nG Assumption 7.2 A denotational specification Den is said such that (~~~. o ~~on ) = ldAn~ = q$.td to \nbe well-specified with respect to monitoring semantics iff: We can now state the soundness theorem: * \nDen is specified scribed above). in continuation semantics (as de. Theorem 7.3 (Soundness) Let Den be \na we12-specijied se\u00ad mantics with valuation functional G and syntax S. Also, let * Den is parametrized \nwith the final answer (Defini. the derived monitoring semantics for Den have a valuation tion 3.2). functional \nG and annotated syntax ~. Given any s ~ S, ~ c ~, such that ~ is s with added monitor annotations, e \nDen s valuation functional are oblivious to monitor then for all values a*, K c Kent and u ~ MS: annotations \n(Definition 7.1,). Note that Assumption 7.2 does not result in any signif\u00adicant loss of generality since \nit closely corresponds to the 8 Exarqdes: a Tracer, a Profiler, a Demon and a collect\u00ad conventional style \nof specifying continuation semantics (see ing monitor for ,C~ Figure 2 as an example). In this section \nwe study four monitor specifications for LA- Notation we write ~ / ~ to denote that o is parame. a tracer, \na profiler, a demon and a collecting monitor. The terized with respect to an answer transformer +. Also, \nwe specifications follow the format of a monitor specification use ~$~d and ~~o~ to denote the standard \nand monitoring discussed in Section 5. In addition, we have implemented answer transformers respectively: \nall the examples in Haskell, and provide running output to demonstrate the results. It is important to \nnote that this framework can also sup\u00adport interactive monitors (e.g. symbolic debuggers, step\u00ad :Ans+-~ \npers) by providing an input as well as an output stream to $Jm.n a = Au. (a, u) and from the monitor. \nThe implementation of interactive tools is discussed in [Kis91]. ho. We define an inverse function for \nq$~o. : Monitor Syntax (MSyn): ~ G Ide Function name (defined in Fig. 2) Monitor Algebras: I. Monitor \nState: Counter Environment Domain MS = CEnv 11. Counter Environment Domain pc G CEnv = Ide ~ IN Operatiorw \n: incCtr : Ide e CEnv ~ CEnv ~nCCtT [fl p. = w =4 where n = [n G dom(pc) -+ p.(j)+ 1, 1 initEnv : CEnv \ninitEnv = Ax. J-~at Monitoring functions: M$e :Ide -Exp+EnvAMS-MS ~$e[.f] [e]P PC = incCtr [fl p= M&#38; \n~~.t:Ide-Exp-Env-VeMS~ MS &#38;,t[fl [e]PvP. = P. Figure 6: Profiler specification Profiler. The specification \nof a program execution profilers shown in Figure 6. The profiler counts the number of times that all \nnamed functions are called. An environment domain is introduced that maps a function name to its correspond\u00ading \ncounter value: PC c CEnv = Ide + IN. The operations for this domain include usual environment operations: \nen\u00advironment lookup, denoted by pc(f); environment update, denoted by pc[f ~ n]; and initial environment \ninitEnv. Also, incCtr increments the corresponding counter for a given function name (or initializes \nit to 1 if the function was never used.) The only algebra needed for the profiler is the counter environment \nalgebra (notice that it can also serve ss the result of the profiler). This suggests that the state of \nthis monitor is the domain CEnv. We profile by incrementing the counter associated with a function whenever \nthe function bod~ is evaluated. We there\u00adfore annotate each function body with its function name. The \nannotation will trigger the profiler semantics whenever the function body is evaluated and the annotation \nsyntax will provide the profiler with the name of the function. All named functions should be labeled \nthis way. For an example of the implemented profiler in action, consider the annotated program (assuming \n-, * and = are primitives): The profiler semantics would provide the following informa\u00adtion in the counter \nenvironment: letrec nml w lambda x. lambda y. {mul}: (x*y) in letrec fac = lambda x. {fat}: if (x=O) \nthen 1 else eml x (fat (x-l)) in fac 3 [fat I+ 4, mul I+ 3] Tracer. The specification of a program \nexecution tracer is shown in Figure 7. Note that the tracer state consists of an output channel and a \ntrace level indicator. We treat the output channel as an abetract datatype with operations addStream \nto add a new string to a given stream, and initStream which provides the initial stream. The trace level \nindicator is simply an integer. The tracer is designed to print tracing information before and after \nevaluating any function body annotated with an element from the syntax domain Fh (this provides the tracer \nwith the name of the function and its arguments). As an example of the implemented tracer in action, \ncon\u00adsider the annotated program: letrec mul = lambda x. lambda y. {mul(x,y)}: (x*y) in letrec fac = lambda \nx. {fat(x)}: if (x=O) then 1 else mul x (fat (x-l)) infac 3 The tracer provides the following information \non the output channel: [FAC receives (3)1 I [FAC receives (2)1 II tFAC receives (1)1 Ill [FAC receives \n(O)] Ill [FAC returns 1] Ill CMULreceives (1 1)1 Ill [MUL returns II II CFAC returns 11 II [WL receives \n(2 1)1 II [HUL returns 21 I [FAC returns 2] I [HrJL receives (3 2)] I [HUL returns 6] [FAC returns \n6] Event Monitoring--Demons Often a programmer wants to invoke monitoring actions if a specific execution \nevent (such as an assignment to a variable) occurs. A simple mechanism Monitor syntax: fh c Fh Function \nheader, where ~h ::= f(xl,..., a%) x, ~ G Ide (defined by the language abstract syntax) Monitor Algebras: \nI. State Domain u E MS = OutChan x IN Operations initState : MS inii!Staie = (initStream, O) II. Output \nchannel Domain o c OutChan = Stream Operations  printChan : String s IN ~ OutChan a OutChan printChan \nx n o = addstream x (indent n o) indent : IN -+ OutChan -+ OutChan indent n o = spaces n (addStream LF \no) where spaces O 0 = o spaces n o = spaces (n 1) (addStream I o) 111. Streams Domain s c Stream Operations \n addStTeam : String e Stream -+ Stream initStream : Stream Monitoring functions: M;,. :Fh + Exp ~ Env \n-+MS ~ MS M~relU(~l > . . ..xn)][e]p(o. n)=  (printChan ( [ ++[fl -H- receives ( ++ToStr(p(zl)) ++... \n-H-ToStr(p(zn)) t+ )] ) n o, n + 1) M$08t:Fh +Exp+Env-+V+ MS-MS M$st[~(m, .... Zn)] [e] p v (o, n) = \n(printChan ( [ ++(fl ++ returns ++ToStr(v) ++ ] ) (n -1) o, n -1) Figure 7: Fancy tracer specification \ncalled a demon is proposed in [DM S84] for event monitor-vided) for the events to trigger an action. \nFinally, we need to ing. This section discusses specifying demons in monitoring specify the actions to \nbe taken when a demon event occurs. semantics. These three steps correspond directly to the specification \nof a monitor. Magpie [DlvfS84], an interactive environment for Pas\u00adcal, supports an event monitoring \nmechanism that monitors Figure 8 presents the specification of a demon that checks events associated \nwith a particular identifier. Our approach for unsorted lists. For simplicity the monitor will only re\u00adimproves \non Magpie in that it provides a mechanism to spec-turn the name of the functions where unsorted lists \nwere if y demons for any semantic event. In particular, the spec-encountered. The monitor and the example \nthat follows are ification of a demon in monitoring semantics follows quite self explanatory, naturally: \nfirst we need to identify all the program points where the event might occur and label their corresponding \nsynt attic term with a demon annotation. Second, know\u00ading that the monitor will be called at these points, \nwe need to specify the criteria (based on the semantic context pro. I Monitor Syntax (MSyn): P c Ide \nProgram Point Label Monitor Algebras: 1. Name set Domain a c MS = {Ide} Operations (usual set operations) \nMonitoring functions: M~re :Ide + Exp --+Env + MS -+ MS @,.lIpl [e] Pu = u +Env+V+MS+MS @OSt : lde -:ap= \nsorted? t) + U> {51} u u  &#38;..t b] [e]P where sorted? (z : ZS) = case zs of (!/ : W) : (z <y) &#38; \n(sorted? ZS) Nil : True so Tted? Nil = True Figure 8: Simple demon For the following program letrec inclist \n= lambda 1. lambda acc. if (1=[1) then acc else inclist (tl 1) ((hd 1)+1) :acc h letrec 11 = {li]:(inclist \n[1,10,1001 [1) in letrec 12 = {12}: (inclist 11 []) in letrec 13 = {13]:(inclist 12 [1) in 13 The demon \nreturns the following information in its state: a= {11,13} Collecting Monitor A collecting interpretation \nof expres\u00adsions is an interpretation of a program that allows one to answer questions of the sort: What \nare all possible val\u00adues to which an expression might evaluate during program execution? [HY88]. A collecting \nmonitor &#38; la collecting in\u00adterpretation is defined in Figure 9. Each expression that we want to monitor \nis tagged with an identifier. The post monitoring function updates the environment which keeps the set \nofvalues for each tagged expression. Monitor Syntax (MSyn): x G Ide Name tags Monitor Algebras: 1. State: \nInterpretations Environment Domain ucMS = Ide + {V} Operations (usual) Monitoring functions: ME ~.. :Ide \n+ Exp -+Env -+MS + MS $e~z~ e] pu= + Env -v -MS +-MS M$~t : Ide ~ Exp &#38;.tiI~l [e] P v IJ= Cr[zw \nu(z) u {v}] Figure 9: Collecting Interpretation Monitor For the following program: letrec fac = lambda \nn. if {test}: (n=O) then 1 else ~nl:n * (fat (n-l)) in fac 3 The collecting monitor provides the following \ninformation in its final state: [test ++ {True, Fa/se}, n w {1,2,3}] 9 IWlementation Issues 9.1 Partial \nEvaluation A functional implementation of the monitored semantics can be obtained by straightforward \ntransliteration into a func\u00adtiord program. The resulting program is essentially an en\u00adhanced definitional \ninterpreter which is passed a set of mon\u00aditor specifications (representing the monitoring activities) \nand yields a value together with monitoring information. Thus, it has functionality: ~ : Men* x Prog \nx Input* ~ (Ans x MS) This monitoring process can clearly be optimized using par\u00adtisJ evaluation [BEJ88] \nby three levels of specialization: 1. Specializing the program representing ~ with respect to a fixed \nset of monitor specifications would automat\u00adically yield a concrete monito~ i.e. an interpreter in\u00adstrumented \nwith monitoring actions. Compiled specialized program Figure 10: Opportunities for Partial Evaluation \nin monitoring semantics 2. Specializing the monitor itse2f (from the previous step) with respect to a \nsource program would produce an instrumented program [SS89]; i.e. a program including extra code to perform \nthe monitoring actions. 3. Specializing the instrumented program (from the pre\u00advious step) with respect \nto some parti~ input would produce a specialized program.  These levels of optimizations are illustrated \nin Figure 10. Note that these instrumentations are achieved uniformly using partial evaluation. This \nshould be cent raat ed with the usual ad hoc techniques of instrumentation. As a preliminary evaluation \nof our approach we have im\u00adplemented a standard interpreter for .CA as well as the pa\u00adrametrized monitored \ninterpreter whose semantics is given in Section 4. We have optimized that interpreter according to the \nlevels of specialization suggested above and compared the results to the conventional approaches for \nmonitoring described in Section 1. At the first level of specialization, we have instrumented the parameterized \ninterpreter with the tracer specification described in Section 8. The specialization yields an in\u00adstrumented \ninterpreter similar to the first conventional ap\u00adproach; i.e. monitoring by instrumenting an interpreter. \nFor a given program, our tracer k about ll% slower than the standard interpreter this slowdown is caused \nby the extra tracing activity. However (in contrast with the conventional approach ) using Partial evaluation \nwe can go beyond in\u00adterpretation by specializing the monitored interpreter with respect to a source program \n(the second level of specializa\u00adtion). This yields a program instrumented with tracing op. erations which \nis 85~o faster than the monitored interpreter and 83~o faster than the standard interpreter. Interestingly, \nthe second specialization yields instru\u00admented code similar to the code expected from the second conventional \napproach: monitoring by program instrumen\u00adtation. However as mentioned above, the instrumentation is \nachieved uniformly using partial evaluation rather than by using ad hoc code instrumentation. These preliminary \nresults suggest that, like a standard semantics, a monitor semantics possesses both static and dynamic \ncomputations. The static computations depend on the program text, including monitoring annotations; and \nthe dynamic computations manipulate run-time values. Thus, the degree of optimization, obtained by partial \nevaluation, will depend on how much static computation is defined by the monitor. For example, the tracer \nof Section 8 has static environment lookup but dynamic stream operations. Figure 11 compares the performances \nof the ,CA standard interpreter and its tracer for a simple test program. Notice that the monitor performance \napproaches the standard in\u00adterpreter performance (the z axis) as the monitoring activity decreases (i.e. \nas the number of requested trace printouts de\u00adcreases). This suggests that the ordy overhead in using \nthe monitored interpreter is the extra computation performed by the monitoring activity. Consequently, \nthe monitored in\u00adterpreter performance graph in Figure 11 corresponds to the linear complexity of the \ntracer dynamic behavior. These experiments were achieved using Schism[Con89, Con90], a partial evaluator \nfor pure Scheme. 9.2 Haskell implementation We have implemented the framework presented in this pa\u00adper. \nThe implementation provides a generic programming environment which allows automatic integration of moni\u00adtoring \ntools with several language modules (lazy, strict and 350 19 :  EszzzEl 18.5 18 17.5 17 Monitoring \nSemnt ics Overhead t------\u00ad. 0.25 Sece (l%) i A o 100 200 300 400 500 I Standard Interpreter Performance \n(16.99 SeCS) Monitorin$ Activity (# of trace printouts) Figure 11: Performance graph imperative languages). \nThe system is written in Hask\u00adell [H W+ 90]. Currently the environment has a toolbox of predefine monitor \nspecifications which includes: an inter\u00adactive debugger d la clbx, a stepper, a tracer, a profiler, a \ncollecting monitor and other specific monitors for each lan\u00adguage. Furthermore, the user can compose \nseveral monitors from the existing toolbox with one of the existing language modules. For example: to \nprofile and use a symbolic de\u00adbugger for a strict interpretation of prog, the user simply types: evaluate \n(profile &#38; debug k strict) prog where &#38;is a composition operator defined for monitors. Sim\u00adilarly, \nthe user can compose his own defined tools with the existing languages and monitors; Haskell s static \ntype sys\u00adtem ensures that new specifications of monitors are well\u00addefined (this can be easily verified \nby inspecting the type of the monitor). Moreover, since a monitor can only modify its own state, we maintain \na high-degree of saft y such that new monitors can not change the behaviors of other elements in the \nenvironment. For details of this implementation, the reader is referred to [Kis9 1]. 10 Conclusion We \nhave introduced a semantic framework for run-time mon\u00ad itors. This framework is general in that a monitoring \nseman\u00ad tics can be automatically obtained from any denotational continuation semantics. Furthermore, \na monitoring seman\u00ad tics can capture any sequential, deterministic monitoring activity. Finally, monitoring \nsemantics is compositional and preserves the standard semantics. On the practical side, just as denotational \nsemantics of programming languages can be viewed as interpreters, mon\u00aditoring semantics can be seen as \nexecutable specifications of monitors. As such, not only does monitoring semantics provide a formal framework \nto reason about monitoring ac\u00adtivities, but it also enables practical implementation of mon\u00aditors. Using \npartial evaluation, instrument ed interpreters as well as instrumented programs can be derived from a \nmon\u00aditored semantics on a uniform basis. Finally, as was mentioned in Section 9.2, the framework presented \nin this paper has actually been implemented in Haskell @ W+ 90]. The implementation provides a program\u00adming \nenvironment that allows automatic integration of sev\u00aderal language modules with an expendable toolbox \nof moni\u00adtors [Kis91]. Acknowledgments We would like to thank Olivier Danvy, Siau-Cheng Khoo, Dan Rabin, \nRaman S. Sundaresh and the entire Yale Haskell group for their helpful comments. References [BEJ88] D. \nBj@rner, A. P. Ershov, tial Evaluation and Mixed Holland, 1988. and Com N. pu D. tation. Jones. Par-North\u00ad \n[Con89] C. Consel. New Haven, The Schism USA, 1989. M anual. Yale University, [Con90] C. Consel. Binding \ntime analysis for untyped functional languages. ACM on Lisp and Functional Progranaming, 272, 1990. higher \norder Conference pages 264 [CP89] W. Cook and J. Palsberg. tics of inheritance and its A denotational \ncorrectness. seman\u00ad00PSLA 1989, SIGPLAN Notices .24:10, 89. [DFH88] R, Kent Dybvig, D. P. Friedman, Haynes. \nExpansion-passing style: macro mechanism. In Lisp and S~putation, 1, pages 53 75. Kluwer Acalishers, \nNetherlands, 1988, and C. T. A general mbolic Com\u00addemic Pub\u00ad [DMS84] N. M. Delisle, D. E. Menicosy, \nand M. D. Schwarts. Viewing a programming environment as a single tool. In Proc. of the ACM SIG-SOFT/SIGPLAN \nSoftware Engineering Sympo\u00adsium on Practical Software Development Environ\u00adments, April 1984. ACM SIGPLAN \nNotices, Vol 19, No. 5, May 1984. [Gor79] M. J. C. Gordon. The Denotational Description of Programming \nLanguages. Springer, New York, 1979. [H085] C. V. Hall and J. T. O Donnell. Debugging in a side effect \nfree programming environment. In Proc. 1985 SIGPLAN Sgmposium on Program. ming Languages and Programming \nenvironments, June 1985. [HW+ 90] p. Hudak, P. Wadler, et aI. Report on the programming language haskell \n-a non\u00ad strict, purely functional language. Tech. Report YALEU/DCS/RR-777, Yale University, April 1990. \n [HY88] P. Hudak and J. Young. A collecting interpre\u00adtation of expressions (without powerdomains). In \nProceedings of the 1988A CM Symposium of Prin\u00adciples of Programming Languages. ACM, 1988. [KHC91] A. \nKishon, P. Hudak, and C, Consel. Monitor\u00ad ing semantics: A formal framework for specify\u00ad ing, implementing \nand reasoning about execution monitors. Technical Report YALEU/DCS/RR\u00ad 850, Yale University, New Haven, \nConnecticut, March 1991. [Kis91] A. Kishon. Monitoring Semantics: Theory and Practice of Semantics-directed \nExecution Moni\u00adtoring. PhD thesis, Yale University, 1991. (Forth\u00adcoming). [Mog89] Eugenio Moggi. Computational \nlambdwcalculus and monads. In Proceedings 1989 IEEE Sympo\u00adsium on Logic in Computer Science. IEEE, 1989. \n[OH88] J. T. O Donnell and C. V. Hall. Debugging in ap plicative languages. In Lisp and Symbolic Com\u00adputation, \n1. Kluwer Academic Publishers, Nether\u00adlands, 1988. [PN81] B, Plattner and J. Nievergelt. Monitoring pro\u00adgram \nexecution: A survey. IEEE Computer, pages 76 93, November 1981. [Red88] U. Reddy. Objects as closures: \nAbstract seman\u00adtics of object oriented languages. ACM Confer\u00adence on Lisp and Functional Programming, \n1988. [Rey72] J. C. Reynolds. Definitional interpreters for higher-order programming languages. Procs. \nACM National Conference, pages 717-740, 1972. [Sch86] David A. Schmidt. Denotational Semantics. Wm. C. \nBrown Publishers, Dubuque, Iowa, 1986. [Sha82] E. Shapiro. Algorithmic Program Debugging. MIT Press, \n1982. [SS89] S. Safra and E. Shapiro. Meta interpreters for real. In Concurrent Prolog, collected papers, \nvolume 2. MIT Press, 1989. [sto77] J. E. Stoy. Denotational Semantics: The Scott-Stracheg Approach to \nProgramming Language Theory. MIT Press, Cambridge, Massachusetts, 1977. [TA90] A. P. Tolmach and A. W. \nAppel. Debugging Stan\u00addard ML without reverse engineering. In Proc. 1990 ACM Conference on Lisp and junctional \nprogramming, June 1990. [Wad90] Philip L. Wadler. Comprehending monads. In Proceedings of the 199o A \nCM Conference on Lisp and Functional Programming, 1990. \n\t\t\t", "proc_id": "113445", "abstract": "", "authors": [{"name": "Amir Kishon", "author_profile_id": "81100166385", "affiliation": "Yale University, Department of Computer Science, P.O. Box 2158 Yale Station, New Haven, CT", "person_id": "P16030", "email_address": "", "orcid_id": ""}, {"name": "Paul Hudak", "author_profile_id": "81100539650", "affiliation": "Yale University, Department of Computer Science, P.O. Box 2158 Yale Station, New Haven, CT", "person_id": "PP40028396", "email_address": "", "orcid_id": ""}, {"name": "Charles Consel", "author_profile_id": "81100552270", "affiliation": "Yale University, Department of Computer Science, P.O. Box 2158 Yale Station, New Haven, CT", "person_id": "PP39048247", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/113445.113474", "year": "1991", "article_id": "113474", "conference": "PLDI", "title": "Monitoring semantics: a formal framework for specifying, implementing, and reasoning about execution monitors", "url": "http://dl.acm.org/citation.cfm?id=113474"}