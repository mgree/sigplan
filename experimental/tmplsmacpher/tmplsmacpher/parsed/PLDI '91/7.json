{"article_publication_date": "05-01-1991", "fulltext": "\n Parameterized Partial Evaluation * Charles Consel Siau Cheng Khoo Yale University Department of Computer \nScience New Haven, CT 06520 {consel, khoo}@cs. yale. edu Introduction Besides specializing programs with \nrespect to concrete val\u00adues, it is often necessary to specialize programs with re\u00adspect to abstract values, \ni.e., static properties such as signs, ranges, and types. Specializing programs with respect to static \nproperties is a natural extension of partial evalua\u00adtion and significantly contributes towards adapting \npartial evaluation to larger varieties of applications. This idea was first investigated by Haraldsson \n[13] and carried out in prac\u00adtice with a system called Redfun in the late seventies. Al\u00adthough this work \ncertainly started in the right direction, it has some limit ations: (:) the static properties cannot \nbe de\u00adfined by the user; they are fixed; (n) the approach is not formally defined: no safety condition \nfor the definition of symbolic values, no finiteness criteria for fixpoint iteration, etc.; and (m) because \nRedfun is an online partial evaluator the treatment of the program is determined as it gets processed \n and consists of numerous symbolic values and program transformations, it is computationally expensive. \nAs a by-product, Redfun could not be self-applied as no\u00adticed in [10, 13], and thus, the partial evaluation \nprocess could not be improved. This paper introduces pararneterized partial evaluation, a generic form \nof partial evaluation parameterized with re\u00adspect to user-defined static properties. We develop an al\u00adgebraic \nframework to enable modular definition of static properties. More specifically, from a concrete algebra, \nan abstract algebra called a facet is defined; it is composed of an abstract domain capturing the properties \nof interest and a set of abstract primitives that operate on this do\u00admain. Using abstract interpretation \n[1, 16], this can be for\u00admally achieved by relating the two algebras with a suitable abstraction function, \nHowever, unlike abstract interpreta\u00adtion, not only does a facet define primitive functions that compute \nstatic properties, abstract values to trigger tion time. Furthermore, an algebra whose domain are primitive \nfunctions, it evaluation itself as a facet. This research was supported but it also defines ones that \nuse computations at partial evalua\u00adconsidering partial evaluation as is syntactic terms and operations \nis possible to capture the partial in part by NSF and DARPA grants CCR-8809919 and NOOO1 4-88-K-0573, \nrespectively. The second au. thor was also supported by a National University of Singapore Over\u00adseas \nGraduate Scholarship. Permission to copy without fee all or part of this material is granted provided \nthst the copies are not made or distributed for direct commercial advantage, the ACM copyright notice \nand the title of the publication and its date appear, and notice is given that copying is by permission \nof tha Association for Computing Machinery. To copy otherwise, or to republish, requires a fee snd/or \nspecific permission. @ 1991 ACM 0-89791 -428 -7/91 /0005 /0092 . ..$1 .50 Proceedings of the ACM SIGPLAN \n91 Conference on Programming Language Design and Implementation. Toronto, Ontarior Canada, June 26-28, \n1991. In conventional partial ved by an ofline strategy tial evaluation process into sis that statically \ndetermines evaluation [3], efficiency is achie\u00ad that consists of splitting the par\u00ad two phases: binding \ntime analg\u00ad the static and dynamic expres\u00ad sions of a program given a known/unknown division of its \ninputs; and specialization which processes a program driven by the binding time information and the concrete \nvalues. Thus, the binding time information of a program can be used for specialization w long as the \ninput values match the known/unknown pattern given for binding time analy\u00adsis. Besides improving the \nspecialization phase, an ojj%e partial evaluator enables realistic self-application [17]. Our framework \nis general enough to capture offline par\u00adtial evaluation. Just aa a binding time analysis is used to \ncompute the static/dynamic property, we introduce a facet analysis to statically compute properties. \nA specialize can then use the result of facet analysis in the same way that it used the result of binding \ntime analysis previously to trig\u00adger computations. Because the facet analysis is performed statically, \nthe specialization phase is kept simple, as before, in contrast with an online strategy that performs \neverything at once. Our approach overcomes the limitations (~), (n) and (ut) mentioned above. Let us \nsummarize the new contributions of this paper. e The notion of facet offers a formal framework for intro\u00ad \nducing user-defined static properties: a facet is a safe abstraction of a concrete algebra. Partial evaluation \ncan now be pararneters%ed with re\u00adspect to any number of facets, each facet encapsulating properties \nof interest for any given application. o Facet analvsis, another novel asDect. allows facet com\u00adputation \nt; be lifted from par&#38;d evaluation keeping the specialization phase simple (unlike conventional program \ntransformation systems). Indeed, not only does the facet analysis statically determine which prop\u00aderties \ntrigger computations, but it also selects the cor\u00adresponding reduction operations prior to specializa\u00adtion. \nThis makes it possible to achieve self-application and improve the specialization process. The paper \nis organized as follows. Section 2 briefly in\u00adtroduces conventional partial evaluation. Section 3 describes \nthe abstraction methodology used to define properties of in\u00adterest. Section 4 presents online parameterized \npartial eval\u00aduation. In particular, Section 4.1 presents the notion of facet together with examples and \nSection 4.4 describes the 1. Synt attic Domains c6 Const Constants x ~ Var Variables pEPo Primitive Operators \n~EFn Function Names e G Exp Expressions ::= clzlp(el, . . ..en)l~(el. . . ..en)li.fele2e3 Pro; ::= {~a(~l, \n. . . ,Zn) = e:} (fl is the main function) 2. Semantics Domains b G Values = (Int + Bool) * P G Env \n= Var ~ Values 63 G FunEnv = Fn ~ Valuesn ~ Values 3. Valuation Functions EP.Og : Prog ~ Values  E: \nExp ~ Env ~ FunEnv # Values K : Const # Values Kp : PO + Valuesn -Values &#38;Pr09 [{ (zl~ . = ~[(~(bl \n$ . . . . bn) . &#38; [e,] (l[bk/~k]) @)/ji] ~ ~~11 wher~~~~ ~) = }1 = &#38;[c]p C3 = K [c] t[z]pfl \n= p [z] S@(el,..., en)]p@ = Kp~](t[el]p@,,,,,t[en] p~) t [if el ez es] p O = (t[ei]p~)+ t[e~]p~,$[cs]p~ \n&#38; [f(el,... ,en)]p@ = e[f](~[el]pe,..,t[en]pe) Figure 1: Standard Semantics of a First Order Language \nsemantics of online parametrized partial evaluation. Sec-function calls (unfoldlng and specialization). \nBecause this tion 5 presents offline parametrized partial evaluation. We treatment vastly differs from \none partial evaluator to an\u00adint reduce the notion of abstract facet in Section 5.1 and other, it is abstracted \nfrom the semantics by function A PP. present facet analysis in Section 5,4. In Section 5.5, we Domain \nSf defines a cache that keeps the specialization extend the facet analysis to handle higher order programs, \npatterns of each function and maps these patterns to the rep- Section 6 presents an example of online \nand offline parame\u00adresentation of the corresponding specialized functions. Es\u00ad terized partial evaluation. \nSection 7 concludes and discusses sentially, this achieves instantiation and folding as in [5], and future \nwork. ensures uniqueness of specialized functions. To keep track of each specialization, partial evaluation \nis single-threaded with respect to the cache. This causes the evaluation order Preliminaries of the language \nto be explicit. Function Mk.%og constructs a residud-program from the specialized functions containedIn \nthis section we examine conventional partial evaluation in the cache. for strict functional programs. \nFor conciseness we only con-Because partial evaluation is a source-to-source programsider first order \nprograms; although, as discussed in Section transformation, it operates on a syntactic domain de\u00ad 5.5, \nextending the framework to higher order programs is noted by Exp. Domain FnEnv recursively defines the \nmean\u00adstraightforward using existing techniques. ing of each function. Function K-l maps a value (e.g., \nin- Let us first examine Figure 1 that displays the standard teger and boolean) back to its textual representation. \n semantics for a first order functional language. As is cus\u00adtomary, we will omit summand projections \nand injections. Partial evaluation subsumes standard evaluation. This is reflected, for instance, in \nthe treatment of the primitiveDomain Values is a sum of the basic semantic domains (we functions: when \na primitive is called with constant argu\u00ad only consider the integer and boolean domains in this pa\u00adper). \nFunction K maps a constant to its semantic value; ments. its standard semantics is invoked. In eeneral. \nan ., expression is completely evaluated when it solely dependsfunction Kp defines the usual semantic \noperations for prim\u00adon available data. Lastly, notice that in partial evaluationitive operators. Domain \nFunEnv maps function names to the primitive operators compute new values; in dealing withtheir meaning. \nThe result of a program is the value of ~1. properties, we will want them to play a similar role. We \nassume all functions have the same arity. Figure 2 defines the semantics of a simple partial eval- With \nthis preliminary material in hand, we are now ready uator for programs written in our language. It is \nbased to introduce parameterized partial evaluation. on existing approaches ([3, 21, 6], for example). \nThe figure only highlights aspects of the semantics relevant to later dis\u00adcussion. For example, we omit \ndetails about treatment of 1. Synt attic Domains (defined in Figure 1) 2. Semantics Domains P E Env \n= Var -+ Exp w c FnEnv = Fn --t Exp ~ (EXP X Sf) Uesf = (Fn x Const ) ~ Exp  3. Valuation Functions \n sP&#38;Frog : Prog ~ Input ~ Prog ~ sP&#38; : ~~~ExEp;v ~~E~;Env +-Sf -+ (Exp x Sf) ~ SKP : MkProg \n: Sf ~ Prog (omitted) SP&#38;p~O~ [{ fi(%l,.. ,~n) = ei)] (ii,.-.,~n) = MkProg ( SPS [fI(m, . . . . \nzn)] (-L[i~/z~]) m L)J2 whererec w = J-[(A(#I, . , , , @n, ~) . sP~ [ei] (J--[@ k/~k]) w ~)/fi] sP&#38; \n[c] pw C7 = ([c], !7) SPS [z] p U7C7 = (P [~1, ~) SPt~(el,.. .,en)]pu7c7 = (~f:r~] (e!,..., e;), an) \n (ej, q) = SPt [cl] pw a (in, c.) = S>t [en] p w an-, SP&#38; [if el ezes] pw u = (e~e Const) ~ (K e;) \n~ SP&#38; [ez] pw I-71,SPS [e3] pw m, (Jif,ej ej ej], f73) (ej, a2) = SP&#38; [e.] p m LTI (ej, a3) \n= SPS [e~] pm uz where (e;, UI) = SPt [cl] p w a SPS [f(el,. ... en)] p w u = APP[f]ej...e~a~w where \n(e;, UI) = SPE [el] p m u -. (;n,CTn) = SP~ [en] p w an l SICP ~](el,..., en) = ~(ei E Const) -+ tC-l \n(KP~] ((K e~),,(~ en))), ~(e~,,en)] ,=1 Figure 2: Simple Partial Evaluation Semantics 3 The Abstraction \nMethodology This section presents a general methodology to introduce abstract values in the partial evaluation \nprocess. Sections 4 and 5 describe how to instantiate this methodology for online and offline partial \nevaluation. In optimizing compilation, static properties are intro\u00ad duced to reason about a program prior \nto its execution. Computation of static properties is then defined by abstract versions of primitive \nfunctions. This structure (domain/ope\u00adrations) naturally prompted us to use an algebraic approach to \nmodel static properties. In particular, a concrete algebra can be captured by the notion of semantic \nalgebra as defined in dqnotationrd semantics (e.g., [19]). Definition 1 (Semantic Algebra) A semantic \nalgebra, [D; O], con8ists of a semantic domain D, and a set of operations O on thi8 domain. Our approach \nconsists of defining, from the semantic al\u00adgebra, an abstract algebra composed of an abstract domain \n capturing the properties of interest and the set of ab\u00adstract primitives operating on this domain. \nUsing abstract interpret ation [1, 16], this can be formally achieved by relat\u00ading the two algebras with \nan abstraction function, Because we aim at addressing both online and offline partial evalua\u00adtion, a \ngiven algebra may be defined at three different levels  listed in increasing abstractness: standard \nsemantics, on\u00adline partial evaluation and offline partial evacuation. These levels respectively define \nsemantic algebras, facets and ab\u00adstract facets.  The rest of this section describes a general methodology \nto relate these dlfierent levels. In essence, this amounts to relating two algebras. To investigate this, \nwe first discuss how to relate the domains and their operations in Sections 3.1 and 3.2 respectively. \nThen, this is formalized in Section 3.3 where the notion of relating two algebras is precisely defined \ntogether with safety criteria. Notationally, a symbol s is noted 3 if it is used in on\u00adline partial evaluation \nand 3 in offline partial evaluation. Symbols that refer to standard semantics are unannotated. Finally, \nfor generality, any symbol used in either online or offiine partial evaluation is noted S.  3.1 Relating \nDomains Domains can be related using an abstraction function [9]. Such a function is strict and monotonic; \nit maps an initial domain into an abstract domain. As a simple example, say we wish to introduce some \nsymbolic computations on signs abstracted from the integer algebra [D; O]. To do so we first have to \ndefine an abst rac\u00adtion of the integer domain that captures the sign properties. A natural abstract domain \nis 6 = {1, POS, zero, neg, T}. Domains 5 and D are related by the following abstraction functicm.  cr--:D+ij \nAD a~(z) = LB ifd =&#38;D pos ifd>o zero if d=O neg ijd<O This example is further developed in Section \n4.1. 3.2 Relating Operations In abstracting one algebra from another, not only do we want to relate \na domain to an abstract domain but we also want to relate the operators to their abstract versions. More \nprecisely, we want to formulate the safety condition of an approximation to an operator. Essentially, \nrelating two operators consists of relating their graphs. To this end, we distinguish two classes of \noper\u00adators. The first class is composed of operators closed under the carrier of the algebra, That is, \nfor an algebra [A; O], we say that p E O is closed if and only if p :A ~ A. Thus, the abstract version \nof a closed operator will be passed abstract values to c~mpute new ones; this corresponds to an abstract \nprimitive in abstract interpr@ation. The second class of operators consists of those whose co\u00addomain \nis different from the carrier; they are referred to ss open. Intuitively, abstract versions of open operators \nwill use abstract values to perform actual computations. Inter\u00adestingly, we can relate this division \nto optimizing compila\u00adtion where, typically, a phase collects properties and another triggers optimizations \nusing these properties. For convenience, given an algebra [A; O], O. and O. will denote the set of open \nand closed operators, respectively. This division suggests that since an abstraction function relates \nthe carriers of two algebras, it can also be used to relate an operator and its abstract version when \nthis opera\u00ad tor is closed under the carrier. However, this does not apply to open operators since their \ndomain differs from their co\u00ad domain. Since an operator may be defined at three different levels (standard \nsemantics, online and offline partizd eval\u00ad uation), its corresponding co-domain will then have three \ndifferent definitions: in the standard semantics, an operator belongs to a semantic algebra; both open \nand closed op\u00ad erators produce basic values (domain Values). In online partial evaluation, an operator \nbelongs to a facet; when it is open it produces a constant provided it is called with appro\u00ad priate values \n(see Section 4). In offline partial evaluation, an operator belongs to an abstract facet; when the operator \nis open it mimics the facet operator and thereby produces a binding time value (i.e., Static or Dynamic) \n(see Section 5). Thus, in order to relate an open operator to its abstract version, we have to relate \ntheir co-domains. To do so let us define the abstraction functions relating the three levels of definition \nof domain Values. From need to this mapping standard semantics to online map basic values into their \nis defined as follows. partial textual evaluation, we representation; r Values + Values ;(c) = _Lv~e~ \nif z = Lvalaes K-1 x otherwise Because Values is a sum of basic domains it is more convenient to define \n~ as a family of abstraction functions indexed by t~e basic domain. That is, for each basic domain D, \nthere is an abstraction function % : D ~ Values defined. To keep the notation simple, we omit the indexing \nof function ?. Note that to be consistent with our framework, domain Va%es used above denotes a separated \nsum constructed by adding the elements -L and Tvxe$ to the original Values domain of constants Const; \nthese elements are respectively weaker and stronger than all the elements of Const. For convenience, \nwe assume the functions defined on Const to be also defined on Va~es (e.g., function K); this domain \nis further discussed in Section 4. To investigate the relation between online partial evalu\u00adation and \noffline partial evaluation, recall that conventional offline partial evaluation consists of a binding \ntime analysis  and a specialize. The binding time domain, noted Values, is composed of the set {Static, \nDgnamic} lifted with a least element Lvx~~. Thk domain forms a chain, with ordering J-Vx-, G Static G \nDynamic, and abstracts the online partial evaluation process in the following way. T VXes .+ ViEes F(Z) \n= J_v.-J&#38; ijx=l. Valuea Statac if z C Const Dynamic otherwise This reflects the fact that an expression \nis static if it partially evaluates to a constant. 3.3 Relating Algebras Given this preliminary discussion \nwe can now forrnahze the notion of algebra abstraction. Let [A; O] and [A ; O ] be two algebras, and \n~AJ : A - A and T : B -t Values be two abstraction functions. Then, the algebra abstraction is noted \naAJ : [A; O] ~ [A ; O ]. Definition 2 (Facet Mapping) aAJ : [A; O] -+ [A ; O ] is a facet mapping with \nrespeet to Values if and only if 1. At is an algebraic lattice of jinite heightx. 1ArI algebraic lattice \nis defined as an algebraic CPO that is also a complete lattice. All lattices defined in this paper are \nalgebraic lattices. Notice that with a lattice of infinite height, a widening op\u00aderator can be used to \nfind fixpoints in a finite number of steps (see [9]). 2. 1.pEO iaaclosedoperator, then p :At + A iade \ncorresponding abstrwct version. 9. If p c O is an open operatov with functionality A + B, whe~e B is \nsome domain diffevent f~om A, then PI : Al -+ Values is its comesponding abstract version. -1. VP E O \nand its comeapondin.q ab8tract version P E 01 cl~lop ~ p O aAl if P iS a closed operatov ~Op ~ p O~Al \nif p is an open operator with functionality A + B Notice that Condition 1 ensures termination in comput\u00ading \nabstract values. Also, for simplicity, we only consider a limited form of heterogeneous algebra (Conditions \n2 and 3): only the co-domain of an operator can be different from the carrier of the algebra. Finally, \nCondition 4 defines the safety criteria of an approximation to an operator. Given a facet mapping, we \ncan succinctly describe the relationship between the components of two algebras by a logical relation \n[18, 16]. Definition 3 (Logical Relation ~a~, ) M aAl : [A; O] * [A ; O ] be a facet mapping with Tespect \nto Values. We dejine the binary velation ~aA, as follows. 1. va CA, Va CA : a ~aA, a + ffAl(a) ~Al a \n. 2. Let p E O and p E 0 be closed operators. Then P LaA/ P *  VaG A, Va G A : a ~a~, a + p(a) ~a~, \np (a ) 3. LetpcOandpJc O beopenoperators andp :A+B for some domain B. Then P GaA/ P * VaEA, Va EA : a \n~a~, a * p(a) LF p (a ) where GF is the logical relation defined for the facet mapping T : [B; OB] x \n[Values; Ok]. Facet mappings ? and ? are presented in Definitions 7 and 10 respectively. Using this logical \nrelation, we can re-formulate the safety criteria expressed by Condition 4 of Definition 2 as follows. \nProperty 1 Let aA/ : [A; O] -+ [A ; O ] be a jac.i mapping with respect to Values, V p E O and itscorresponding \nabstTact OJeTsionp~ ~ of, P &#38;aA, P . 4 Online Parametrized Partial Evaluation This section presents \nonline parameterized partial evalua\u00adtion, We first define the notion of facet by instantiating the abstraction \nmet hodology described in Section 3. Then, we describe online parametrized partial evaluation. 4.1 Facets \nA facet captures symbolic computations performed in online partial evaluation. As a result, while a closed \noperator will compute new abstract values, an open operator will produce constants when provided with \nappropriate abstract values. Formally, Definition 4 (Facet) A facet for a semantic algebra [D; O] i~ \nan algebra [6; 6] defined by a facet mapping 85 : [D; O] 4 [b; ~] with respect to V~es. We refer to b \nas the facet domain and ~ as the set of facet operators. The use of facet mapping in the definition ensures \nthe following property about the open operators of a facet. Property 2 For any open operator p E O of \narity n, we have V#t c 6and. Vd16D~ud that d,~:=~tfO~i~{l,...t~}: D $(JI,. . . , &#38;+) 6 Const and \np(dl,..., d~) terminates =+ @(dI, . . . ,ln)=~(p(dl,..., dn)) In essence, this property states that \nif an open operator of a facet yields a constant for some abstract values, this constant is the same \nas that produced by the concrete oper\u00adator called with the corresponding concrete values. Notice that \nthis equality only holds if the call to the concrete op\u00aderator terminates. TheAconcrete values di are \nthose related to the abstract values di under the logical relation ~:~. D However, for some values, \nan open operator of a facet may not yield a constant. Indeed, it may be passed abstract values too coarse \nto be of any use. This is illustrated in the example below. As an example of a facet, say we wish to \ndefine a Sign facet from an integer algebra. The set of static properties would be {J-, pos, zero, rzeg, \nT}. Assume that the operators of this algebra are {+, <}. Then + would be a closed oper\u00adator: it operates \non two sign values to compute a new one. However, < is an open operator: it uses the abstract value of \nits arguments to trigger computation whenever possible (e.g., .?(zero, pos) = [true]). Example 1 Sign \ninformation forms a facet for semantic algebra [D; O] = [Int~; {+, <}]. 1.D = {Ll pOs, zero, neg, T} \nwith vj~fi,4GiLT 2. The abstraction function is :D-+fi :; cl: (z) = l.~ ifd=~D poa ifd>O zero i.fd=O \nneg ijd<O 3. ~ G80 U8Cwhere ~. G{<} and8. ={-&#38;} 4. Facet operators  +: fixfi+h 4 = A (C&#38;, J2). \n(-C L=1)V(J?=I)4 1, dl = zero -+ d2, i~=zero+ &#38;,j~ l.J c&#38;. (71 =- l)v(&#38;=L) + . 1, ({I = \npos) A ( ~z E {neg, z~;~) -+ [jars.], ((I = zero) A (d? = p., ) + [true], (~~ = zero) A (:2 c {neg, zero}) \n+ [false], ($ =Jsg) A ( d~ e {p.,, 2.90}) + [true], values We can now explain further our approach and \nexamine how the notion of facet achieves the parameterization of par\u00adtial evaluation. .4.2 Product of \nFacets Essentially, parameterized partial evaluation differs from the conventional partial evaluation \nin two aspects: it collects facet information and propagates useful results of any facet computation \nto all relevant facets. While the latter aspect is described explicitly in the new partial evaluation \nmodel presented in Section 4.4, the former is captured by the notion of the product of facets defhred \nin this section. A product of facets captures the set of facets defined for a given semantic algebra. \nIt consists of the product of facet domains and the set of facet operators. In particular, for each operator \np, a product operator, noted o+, triggers each facet operator ii with the corresponding abstract val\u00adues. \nIf p is a closed operator, the product operation yields a product of abstract values. Otherwise, it produces \neither a constant, lv~e~ or Tvme~ depending on the abstract values available. Definition 5 (Product \nof Facets) Let ~~ : [D; O] -+ [b;; ~,] jori~ {l,..., m) be the set of jacet mappings defined for a se\u00ad \n.. mantic algebra [D; O]. Its p~oduct o.fjacet.s, noted, [ D; 0], consists of two components: f. A domain~ \n= 61@. ..@6m s 6; ; it is a smaahed fi 1=1 product 2 of the facet domains; 2. A set o.f product operators \nfi such that for any p G O and its corresponding p?oduct operator 2P E S2, (a) i.f p E O is a closed \noperator, then P: D -+D, and LJp:v n+~ m tip= A(8~, . . . !$~) -J-JM$:) J2 i=l Given two lattices D \nand E, its smashed product, D @ E, is a lattice, the elements of which are defined by the function, smashed, \nsuch that: arnashed DxE+D@E smashed(d, e) = (d, e) if (d# LD) and (e # LE) J_D@E othemuise (b) otherwise, \np E O is an open operator p: D~+D for some domain D , and LIP:D 4 VZes tip= A(&#38;, . . ..&#38;J , (3j \nE{l,... ,773} St. c? = lV--JJ + lv~--,, (3je {l,... ,m} s.t. 83 G Const) + &#38;, Tv~e~ m 1=1 Notice \nthat the i-th component of an element of the do\u00ad main 5 is noted ~i; this domain is partially ordered \ncomponent\u00adwise. All product operators defined above are monotonic. Although facets of a product are defined \nindependently, the facet values with respect to which a program is special\u00adized must have some consistency. \nDefinition 6 Let [ 6; 6] be a pToduct oj facets of an a[gebra [D; O]; &#38; G 5 is consistent if and \nonly if m fl{dcD [ dC-._a, ~ } is not the empty set nor {L}. 1=1 Each set of concrete values corresponds \nto a particular facet property; it is defined by the logical relation ~; . No\u00ad , tice that if domain \nD is lifted, by definition of the relation g:, , the above intersection will at least yield the single\u00ad \nton {_L}; therefore this set must not imply consistency, In essence, the above definition ensures that \na product of ab\u00adstract values represents an actual subdomain of D. We assume that a program is always \nspecialized with re\u00adspect to consistent products of facet values. By definition of a facet the consistency \nproperty is preserved by the open and closed operators. This property contributes to the cor\u00adrectness \nof the following lemma which states that if there are more than one facet that produce concrete values, \nthose values are equal (see proof in [8]). Lemma 3 Let [ 6;6] be a product of facets and p G O be an \nopen operatov, If 3j, kG {l,... ,m}(j#~)and~l,.#.,FnC5 We have seen how properties of interest can be \nformally introduced via a facet and described how facets could be combined to form a product of facets, \nLet us now explore the generality of the approach. In particular, we want to examine how partial evaluation \ncan itself be captured by a facet.  4.3 Partial Evaluation Facet So far, we have used the notion of \nfacet to introduce sym\u00adbolic computations drawn from a semantic algebra defined in the standard semantics. \nApplication of the same notion to partial evaluation raises the following question: What can be captured \nby a partial evaluation facet? Just as a facet defines symbolic behavior of primitives, the partial evaluation \nfacet Will capture the partial evalu\u00adation behavior of primitives. More specifically, for a given semantic \nalgebra, the corresponding partial evaluation facet will define its standard semantics whenever it is \npassed con\u00adstant arguments. The partial evaluation facet is defined as follows. Definition 7 (Partial \nEvaluation Facet) The partial evalua\u00adtion facet of a semantic algebra [D; O] is dejined by the jacet \nmapping a Vatue, : [D; O] + [V~e~ ~] f. 2 : I) + V~es ~Vatues CX-ZT Values 2. V@ E60farityn @ : V%es \n-+ VZIes P =A (ii,...,dn). 3iG {l,... ,n} s.t. cl, = lv~--~ + lv~e~, ~(&#38; GConst) +;(Kp[pj(dI,,dn) \n),Tv~~ i=l wheve di = (K Cii) ie{l,+..,n] In fact, the abstraction function ~v~--$ is essentially the \nsame as ~ given in Section 3.2: it maps a value into its textual representation. Notice that, just as \nany other facet operator, a partial evaluation facet operator produces value Tv~e~ when it is passed \ntoo coarse values (that is, non-constant values). We can now define the semantics of parameterized partial \nevaluation. 4.4 Semantics of Online Parametrized Partial Evaluation Since this semantics aims at defining \npartial evaluation, we shall assume that the partial evaluation facet always exists. Thus, because a \npartial evaluation facet is defined for each semantic domain, it will be assigned to the first component \nof every product of facets. A sum of these products of facets is noted SD; each summand corresponds to \na semantic al\u00ad gebra. We shall use ; to denote an element of domain S-D. For readability, we do not index \n~ with a given summand and assume that it denotes an element of the appropriate summand. As before, ~ \ndenotes Lth facet value a product of facet values. Figure 3 displays the parametrized partial evaluation \nsemantics. For simplicity, we assume that every product of facets contains m facets (including the partial \nevaluation facet). Also, we assume that user-supplied facets are glob\u00adally defined, that is, the corresponding \nabstraction functions and product operators are globally defined. For a product of facets fi, ti~, denotes \nthe i-th abstrac\u00ad , tion function. Besides computing facet values, the partial evaluator haa to construct \nthe residual program and col\u00adlect the specialized functions. This triple forms the co\u00addomain of the partial \nevaluation function and is defined as Exp x S-D x Sf. Closed and open operators are respectively noted \np= and p . Notice that when an expression partially evaluates to a constant because the expression is \neither a constant or a primitive called with appropriate values functions ~ and ~P propagate this value \nto all facets in a product by invoking their corresponding abstraction function. The following theorem \nasserts that any constant pro\u00adduced by partial evaluating a primitive call is always correct with respect \nto the standard semantics, modulo termination (see proof in [8]). Theorem 1 Let [ 6; 6] be a product \nof jacets (including the par\u00adtial evaluation facet) for an algcbTa [D; O], 3jc {l,... ,m} such that, \n (Cc Const) and (Z[p(zl, . c. ,~n)]l[di/~i]-l) temni\u00ad nate$ + c = ~(S~(%l,.. ., On)]l[di/~i]J-) where \nc = (p$[P(Z1, . . . . ~n)].l[([~i], 6i)/~i]Ll.)J.l and di~ {d~ D I d~;~ $:}. ~3  Finally, let us point \nout that online partial evaluation as defined in Figure 3 provides a less complete treatment of conditional \nexpressions than the one described in Redfun [13]. Indeed, Redfun is able to extract properties from \nthe predicate of a conditional expression. Then, these proper\u00adties and their negation are propagated \nto the consequent and alternative branches respectively. This is somewhat similar to constraints in logic \nprogramming. We are currently in\u00advestigating this issue to possibly incorporate the notion of constraints \nin our approach. 5 Offline Parameterized Partial Evaluation As discussed earlier, in an online strategy \nall decisions about how to process an expression are made at partial evaluation time. This makes it possible \nto determine precise treat\u00adment based, for example, on concrete values. However, this is computationally \nexpensive because the partial evaluator must anal yze the context of the computation the available data \n to select the appropriate program transformation. This operation is repeatedly performed when processing \nre\u00adcursive functions. In conventional partial evaluation efficiency is achieved by au oflirae strategy \nwhich splits the partial evaluation phase into binding time analysis and specialization. In par\u00ad ticular, \nthe binding time analysis only computes the static/dy\u00ad namic property. In offline parameterized partial \nevaluation, we generalize the binding time analysis to facet analysis: a 98 1. Semantics Domains. ~ \nc S-D = ~fij where 5, = (~jl @ . . . @ fi~~) and s is the number of basic domains j=l e c Exp p c Env \n= Var + (Exp x S-D) w G FnEnv = Fn + Exp + S-D _ (Exp x S-D x Sf) u C Sf = (Fn x Exp x S-D ) + Exp \n2. Valuation Functions PEPrOg : Prog -+ Expn + S-D + Progl Pt : Exp + Env + ~n~nv + Sf + (Exp ~ ~? x \nSf)L Ep : PO + Expn - SD ~ Sf ~ (Exp xsD X Sf)l P&#38;Prog [{j, (zl, . . ..zn) = ei}] (e~,.,.,e~) (~l,...,~n) \n= (kfkProg a) whererec ( , a) = P&#38; ~~,(z,, . . . . xn)~ (l[(e~,~,)/z,]) U7 1 w = l[(~((e~,...,e~),($l,..., \n~ ,a6 ) ) . P&#38; [ei] [(e , ~~)/x~] w u)/.fi] Iv[c]pmr=t[ga Pf[z]pcuu= (e , 6, a) wlye (e , F) = p \n[z]A ~&#38; ~(el,.. -,en )]PWU = KP~](e~, ..2eL) (61,..., Fn)un where (e~,fil,a~) = P&#38; [e~]pcua \n phase that statically computes facet information. Conse\u00adquently, the task of program specialization \nreduces to fol\u00adlowing the information yielded by the facet analysis. To present offline parameterized \npartial evaluation, we follow the approach used in defining online parameterized partial evaluation: \nwe introduce the concept of abstract facet in Section 5.1, describe the product of abstract facets in \nSection 5.2, define the binding time facet in Section 5.3, and lastly, describe facet anal ysis in Section \n5.4. 5.1 Abstract Facets To lift facet computation from partial evaluation, we need to define a suitable \nabstraction of this process. In particular, we need to define an abstraction of a facet that enables \nfacet computation to be performed prior to specialization. The resulting facet is called an abstract \nfacet and is defined in this section. Not surprisingly an abstract facet has the same struc\u00adture as a \nfacet. In particular it has two classes of operators: open and closed. Similar to a facet, a closed operator \nof an abstract facet is passed abstract values and computes new ones. As for an open operator, it mimics \nthe corresponding facet operator: it uses abstract values to produce binding time values. More precisely, \ninstead of a constant it pro\u00adduces the binding time value Static and instead of Tv=e~ it produces Dynamic. \nJust as a facet is defined from a semantic algebra, an abstract facet is defined from a facet. Formally, \nDefinition 8 (Abstract Facet) An abstract facet [b; 6] o.f a jacet [6; 6] is defined by a .fa.et mapping \n=5 : [6; 6] + [~; 6] with respect to Values. This definition leads to the following property about \nopen operators. Property 4 Fov any open operatoT @ E O of arity n, we have V~I, . . ..&#38;Gfi and Vd, \nsuch thatd; ~z-~i~o~i~{l,...)n} D (p(J, ,... ,Cln) = stat;.) * @(al l,... ,CL) EV--J--, c jor c G Const. \n This property states that, when an open operator of an abstract facet maps some properties into the \nvalue Static, the open operator of the corresponding facet will yield a constant value at specialization \ntime, modulo termination. As an example of an abstract facet, say we wish to de\u00ad fine a Sign abstract \nfacet from the Sign facet (Example 1). This will amount to determining, prior to specialization, whether \nsign computation can produce constants. If so, the specializ at ion phase will collect sign information \nand trigger the open operators that produced the value Static at facet analysis time. Example 2 The abstract \nfacet for the Sign facet [6; ~] is defined as follows. 1. 6 = 6 (strntlar to Ecarnp/e 1) 2. ;: is simply \nthe identity mapping between 6 and ~. 3. 6 a {<, ~} where ~ has the same functionality as $ and < is \ndefined as follows.  -2 5x5+ VXes <= A(a, b). a=lvb=l+ l ---, a = pos A ( b E {rze~, z%%} ) -+ Static, \na = zero A b = pos ~ Static, a = zero A ( b 6 {neg, zero}) + Static, a = raeg A ( b G {p09, Zero}) -+ \nStQtiC, Dynamic  5.2 Product of Abstract Facets As in online parameterized partial evaluation, we now \ndefine the product of abstract facets. Definition 9 (Product of Abstract Facets) Let ~i : [b;; ~;] +[fit;~:lfo~~e{lt... \n7m} be the set of Facet mappings de\u00adfined joT the facets oj a semantic algebra [D; 0], Its product of \nabstvact facets, noted [D, !2], consists of two components: f. A domain 6 = G; is a smashed pToduct of \nthe abstTact O i=l jacet domains; 2. A set of product operators ~ such that for any p G O and its corresponding \nproduct operator 6P E ~, (a) ij fi is a closed operator, then p:D~+ D_, and GD:D +D 1=1 (b) otherwise, \n@ E 6 is an open ope rater, and p : D + D _joT some domain D!, and n 4 Values ~P:v tip= A(151,...,&#38;) \n. (3j G{l,... ,m} s.t. 3 = L VXes) + .x.. (3je {l,... , m} s.t. @ = Static) + Static, Dunamic The domain \n~ is partially ordered component-wise. Since all the product components are of finite height by definition, \nthe product domain is also of finite height. 5.3 Binding Time Facet While the partial evaluation semantics \nof algebraic operators is captured by a facet, the computation of their binding time values can similarly \nbe captured by the notion of abstract facet. Such an abstract facet is called a binding time facet. Definition \n10 (Binding Time Facet) The binding time facet ,-. of a partial evaluation Jacet [Values; O] is dejined \nby the facet mapping vatue~ : [V~e~ ~] + [VXes; a G] l.z : Values --i VZes -Values cl-z ; Values 2. \nV6GG0favityn 6: VGesm A Values n 5= A(dl, . . . , &#38;) .~(di = StOtiC)-+ Static, Dgnamic 1=1 Not surprisingly, \nthe above definition captures the prim\u00aditive functions of a conventional binding time analysis. As a \nresult, not only does the facet analysis compute user-defined abstract values but it also computes binding \ntime values, just as a binding time analysis.  5.4 Facet Analysis We are now ready to examine the facet \nanalysis. It is es\u00adsentially a conventional binding time analysis, as described in [2 I] for example, \nextended to compute facet information. Analogous to the definition of parameterized, online partial evaluation, \nwe assume the binding time facet to be always defined. The main semantic domain used by the analysis \nis denoted by SD, which is a sum of products of abstract facets each summand corresponds to a semantic \nalgebra. The bhding time facet is assigned to the first component of each product, Facet analysis is \ndisplayed in Figure 4. The notational conventions about indices are similar to Figure 3. The anal\u00adysis \naims at collecting facet information for each function in a given program; this forms the ~acet signature \nof the func\u00adtion. More precisely, a facet signature consists of a product of abstract facet values for \neach parameter of a function and is defined as S D . The result of the analysis (domain SigEnv) is a \nfunction mapping each user-defined function in the program to its facet signature, The valuation function \n~ maps each user-defined func\u00adtion into its abstract version. The resulting abstract func\u00ad tions are \nthen used by the valuation function A to compute the facet signatures, As usual, computation is accomplished \nvia fixpoint iteration. Functions ~ and ~P perform the ab\u00adstract computation on constants and primitive \noperators. This is similar to functions ~ and ZP defined in Figure 3. Finally, note that fixpoint iteration \nis performed over the domains S Dand SigEnv. Since these domains are of finite height and operations \nover these domains are monotonic, a fixpoint will be reached in a finite number of steps. 5.5 Higher \nOrder Offline Parametrized Partial Evalua\u00adtion The techniques for higher order online partial evaluation \nare now known (e.g., [20, 12]). However, traditionally problems arise when dealing with the oftline strategy. \nFor this reason, this section will concentrate on offline parameterized partial evaluation. In particular, \nwe will present a higher order facet analysis, the essential component of the offline strategy, just \nas binding time analysis for conventional offline partial evaluation. While the first order facet analysis \nextends conventional first order binding time analysis, the higher order analysis makes use of recently \ndeveloped technique in abstract inter\u00adpretation for analyzing higher order programs (e.g., [14, 15, 4, \n7]). With the introduction of higher order functions, the ab\u00adstract version of each user-defined function \nmay now take higher order abstract functions as arguments. This means that the abstract facet property \nshould be captured by a domain consisting of both first-order and higher order prop\u00aderties: q ~ AV=S \nD+ @v~Av) Figure 8 displays the facet analysis for higher order pro\u00ad grams. The language has been extended \nto include higher order functions. Similar to the first-order facet analysis, function ~ transforms a \nuser-d~fined function into its ab\u00adstract version, while function A uses the abstract function to collect \nabstract facet information for each user-defined function, Given two functions ~1 and f2, we define their \nmeet as follows: jl Ujz = (fl =Tc) V(f2=Tc) + Tc, (:/~\\.f*) = a,it~(j~)) + .., wn). fl(vl,. $, wn)uf2(wl,..., \nwn), Serr  where Tc denotes an operator which always returns the ap\u00adpropriate strongest element in the \ndomain Av; Serr denotes the error function. ~ performs fixpoint computation over the domain Av to produce \nthe abstract version of the user-defined functions. The semantics is self-explanatory, except for the \ntreatment of conditional expression: when a conditional expression re\u00adturns in higher order function, \nthe meet of the functions ob\u00adtained from the two branches is returned. However, when the test expression \nis dynamic, the unknown operator Tc is returned to indicate that the possible operators returned by the \nconditional expression cannot be determined stati\u00adcally, and therefore will not be applied at specialization \ntime. Functionally, Tc takes arbitrary number of arguments, and always returns the appropriate strongest \nelements in the do\u00admain Av. For convenience, we assume that it is pre-defined in the initial environment \n00. ~ performs a global analysis to collect the facet signature of each user-defined function. These \nsignatures are captured by the domain SignEnv, The co-domain of ~ is defined as follows. Ans = SigEnv \nx ((Avn x Ansn) -+ Ans) x P(Fn) The first component consists of the facet signatures as de\u00adscribed above. \nThe other two components are only signifi\u00adcant when the expression being analyzed is higher order, In \nthis case. these component~ represent its ak~t.met Lel. aviom in the following sense. When a higher order \nfunction is ap\u00adplied, it may induce new facet signatures; this is captured Figure 4: Facet Analysis by \nthe second component of AIM. Also, when a user-defined function is applied, we would like to update its \nfacet signa\u00adture; this is captured by the third component of Ans, which consists of the set of possible \nuser-defined functions that an expression may evaluate to, Let us now explain the treatment of a conditional \nex\u00ad pression by function ~. Besides the usual tasks of collecting signatures from each component of \nthe conditional, we also need to determine if the abstract facet information returned is the unknown \noperator. Since this operator indicates that the higher order functions returned by both branches will \nnot be applied at the specialization time, we must there\u00adfore apply the appropriate strongest abstract \nfacet values to these functions in order to collect the signature information from their function bodies. \nThe application is performed % advance before we return an answer from evaluating the conditional. For \nsimplicity, we assume that both the initial environ\u00adments QO and co contain functions that deal with \nprimitive operations. Thus, for each primitive p, we have @o@] P1. ..wn = &#38;@]wl... %l where ~P is \ndefined in Figure 4, and so El(( PI C pn), (m, ., an)) = (-L, Serr, {}). In general, the analysis as \ndescribed is not guaranteed to terminate. The reaeon is that a program may include higher order functions \nthat need to be analyzed an infinite number of times. This situation is described by Hudak and Young \nin [14]; they circumvent the problem by disallowing functions whose type is of arbitrary order or depth \n. Here, we adopt the same rest riction. 6 An Example This section illustrates further parameterized partial \neval\u00ad uation with an example of a program computing the inner product of two vectors. After describing \nthis program, we examine its online and offline partial evaluation when the size of the vectors is known. \nIn this example we consider vectors of floating point numbers. One can think of a vector as an abstract \ndata type V consisting of a set of operators O listed below. MktVec : Int + V creates a vector of the \nspecified size. UpdVec : V x Int x Float -$ V updates an element. Vecn : V + Int returns the size of \nthe vector. Vrej : V x Int -Float returns a specified element. The program for computing inner product \nis presented in Figure 5. To specialize the inner product program with respect to the size of the vectors \nour strategy consists of defining the size information as a property of a vector. 6.1 Online Parametrized \nPartial Evaluation In order to capture the size property of a vector, we define the Size facet [~; ~] \nfrom the vector algebra [V; O]. 1. ~ G Intu {l;, T-. } with the ordering l; g i ~ Tv Vi ~ Int. iprod(A, \nB) = let n = Vec#(A) in dotProd(A, B,n) dotProd(A, ifn=O else B,n) = then O Vref(A, n) + dotProd(A, * \nVref(B, B,n-l) n) Figure 5: Inner Product Program 2. A&#38;traction a? 2;(U) function ~ V*V = J+ Vecti(v) \nZfu=l. otherwise 3. Closed operators UpFe c : l!JpZec(6, 9 x V%es x V%es * i, r) = (i= 1 ==,) v (r = \n-L- , v Q lv~e*) 4. Open operators Let us now specialize the inner product program with respect to \na given size, say 3. The facet values passed to the pa;tial evalu~tor will be \u00ad <A, <Tvx--~ , 3>> and \n<B, cTv~--~, 37> where A and B are residual identifiers for iprod; T ~--, is the partial evaluation \nfacet value; and, 3 is the size facet value. When partially evaluating iprod, the size facet in\u00adformation \nis used to obtain the size of vector A. Variable n is then bound to a constant value. As a result, the \ntest ex\u00adpression in dotProd is static, and thus can be reduced. Also, the recursive call to dotProd can \nbe unfolded. The result\u00ading program is displayed in Figure 6. Notice that it is now non-recursive. Since \nelements of the vectors are unknown at partial evaluation time, the primitive operation Vref cannot be \nreduced; therefore, both the multiplication and addition operations are residual. iprod(A, B) = Vref \n(A, 3) * Vref(B,3) +Vref (A, 2) * Vref (B, 2) +Vref(A, 1) * Vref(B, 1) Figure 6: Residual Program for \nInner Product 6.2 Offline Parameterized Partial Evaluation In the offline parameterized partial evaluation, \nwe define the abstract Size facet [$; b]. 1. 2. Values s and d denote a static spectively. A~stract~on \nfur@ion 12.\u00ad:v+v -v 07(0) = _L; ifij=l; d zfO= T+-V s otheranse and a dynamic vector size, re\u00ad 3. Closed \noperators M=ec : V=es -+ ~ 4. Open operators v=! :GA VXes Vz[(ti) = (; = 1;) + 1 ==,, (0 = .) + static, \nDynamic V%f : V x VXes -+ VXZes Vwf(ti, i) = (t = L--)v (i = lv=e~) --? lv==~, Dynamic Let us now perform \na facet analysis on the inner prod\u00aduct program given that the actual value of both vectors is dynamic \nbut their size is static. Recall that besides the ab\u00adstract Size facet, the binding time facet (Definition \n10) is also defined. Both parameters of iProd will then be bound to the pair of abstract values <Dynamic, \ns>, As a result, the binding time value of variable n is Static. Thus, the facet analysis determines \nthat the test expression in dotProd is static, and the conditional expression can be reduced stati\u00adcally. \nThis coincides with the result of online parameterized partial evaluation; however, these reductions \nhave been de\u00adtermined statically. Figure 7 displays the information yielded by the facet analysis of \nthe inner product program when only the size of the vectors is static; more precisely, we show the facet \nvalues of the main expressions of the program. For concise\u00adness, the values Static and Dynamic are noted \nStat and Dyn respectively. The underlined binding time value represents the static value obtained from \nthe size abstract facet value. Notice that the size information is only used in the main function, iprod. \nThis means that, at specialization time, size facet computation is only required for iprod (in fact, \nit is only required for partial evaluation of an abstract syntax tree rooted by the open operation Vecj). \nBinding time analysis is the only facet computation performed for dotProd. This contrasts with the online \nparameterized partial evaluation of the inner product program where the size facet computa\u00adtions were \nperformed for each function manipulating vectors. 7 Conclusion and Future Works Redfun is the main approach \naimed at specializing programs with respect to static properties. Since then other partial evaluation \nsystems (e. g., [20, 12, 2]) have been developed based on this approach. Parameterized partial evaluation \ngoes beyond this in that: it captures both online and offline partial evaluation; the notion of facet \nprovides a formal method to introduce user\u00addefined static properties; finally facet analysis achieves \neffi\u00adciency of the specialization phase by enabling self-application. Furthermore, our approach subsumes \nconventional self\u00adapplicable partial evaluation d la Mix [17] in that it gen\u00aderalizes the notion of binding \ntime analysis to any static properties. We are currently implementing parameterized partial eval\u00aduation \nfor higher order functional programs and investigat\u00ading various extensions to this framework. In particular, \nwe are looklng into parameterized partial evaluation for a lazy language. We are also exploring partial \nevaluation parame\u00adtrized with respect to operational properties such as strict\u00adness properties. Acknowledgements \nTo the Yale Haskell Group. Thanks are aJso due to Karoline Malmkjzer, Olivier Danvy, Paul Hudak, Pierre \nJouvelot and David Schmidt for thoughtful comments on earlier versions of this paper. References [I] \nS. Abramsky and C. Hankin, editors. Abstract Interpre\u00adtation of Declarative Languages. Ellis Horwood, \n1987. [2] A. Berlin. Partial evaluation applied to numerical com\u00adputation. In ACM Conference on Lisp \nand Functional Programming, pages 139-150, 1990. [3] D. Bj@rner, A. P. Ershov, and N. D. Jones, editors. \nPartial Evaluation and Mixed Computation. North-Holland, 1988. [4] A. Bondorf. Automatic autoprojection \nof higher order recursive equations. In N. D. Jones, editor, ESOP $?o, 3 d European Symposium on Programming, \nvolume 432 of Lecture Notes in Computer Science, pages 70 87. Springer-Verlag, 1990. [5] R. M. Burstall \nand J, Darlington. A transformational system for developing recursive programs. Journal of ACM, 24(1):44-67, \n1977. [6] C. Consel. Analyse de Programmed, Evaluation Par\u00ad tielle et Gene.atiorz de Compilatetir.s. \nPhD thesis, lJni\u00ad versit4 de Paris VI, Paris, France, 1989. [7] C. Consel. Binding time analysis for \nhigher order untyped functional languages. In ACM Conference on Lisp and Functional Programming, pages \n264 272, 1990. [8] C. Consel and S. C, Khoo. Parameterized partial eval\u00aduation. Research report, Yale \nUniversity, New Haven, Connecticut, USA, 1991. Extended version. PTogTam iprod(A, B) = let n = Vecfl(A) \nin dotProd(A, B, n) dotProd(A, B, n) = if n =o then O else Vref(A, n) * Vref(B, n) + dotProd(A, B, n \n 1) Figure 7: Abstract Facet [9] P. Cousot and R. Cousot. Abstract interpretation: a unified lattice \nmodel for static analysis of programs by construction or approximation of fixDoints. In ACM Symposium \non P;i;ciples of Progr-am-rning Languages, pages 238-252, 1977. [10] P. Emanuelson and A, Haraldsson, \nOn compiling em\u00ad bedded languages in Lisp. In ACM Conference on Lisp and Functional Programming, Stanford, \nCalifor\u00adnia, pages 208-215, 1980. [11] H. Ganzinger and N. D. Jones, editors. Programs as Data Objects, \nvolume 217 of Lecture Notes in Computer Science. Springer-Verlag, 1985. [12] M. A. Guzowski, Toward developing \na reflexive par\u00adtial evaluator for an interesting subset of Lisp. Mas\u00adter s thesis, Department of Computer \nEngineering and Science, Case Western Reserve University, Cleveland, Ohio, 1988. [13] A. Haraldsson. \nA Program Manipulation System Based on Partial Evaluation. PhD thesis, Linkoping Univer\u00adsit y, Sweden, \n1977. Linkoping Studies in Science and Technology Dissertations No 14. [14] P. Hudak and J. Young. Higher-order \nstrictness analysis in untyped lambda calculus. In ACM Symposium on Principles of Programming Languages, \npages 97-109, 1986. [15] P. Hudak and J. Young. A collecting interpretation of expressions (without \nPowerdomains). In ACM S~mpo\u00adsium on Principles of Programming Languages, pages 107 118, 1988, [16] N. \nD Jones and F. Nielson. Abstract interpretation: a semantics-based tool for program analysis. Technical \nreport, University of Copenhagen and Aarhus Univer\u00adsity, Copenhagen, Denmark, 1990. [17] N. D. Jones, \nP. Sestoft, and H. S@ndergaard. Mix: a self-applicable partial evaluator for experiments in compiler \ngeneration. Lisp and Symbolic Computation, 2(1):9 50, 1989. [18] F. Nielson. Two-level semantics and \nabstract inter\u00adpretation. Theoretical Computer Science, 69:117 242, 1989. Abstract Facet Values A =< \nDyn, s>, B =< Dyn, s> Vecj(A) = < Stat > n =< Stat> A =< Dyn, s>,13 =< Dyn, s>, n =< Stat> n = <Stat> \n< Stat > Vref(A, n) == < Dyn >, Vref(B, n) = < Dyn > Information After Facet Analysis [19] D. A. Schmidt. \nDenotational Semantics: a Methodol\u00adogy for Language Development. Allyn and Bacon, Inc., 1986. [20] R. \nSchooler. Partial evaluation as a means of lan\u00adguage extensibility. Master s thesis, M.I.T. (LCS), Mas\u00adsachusetts, \nU.S.A, 1984. [21] P. Sestoft. The structure of a self-applicable partial evaluator. In [11], pages 236 \n256, 1985. 1. Synt attic Domains e c Exp Expressions  .f C Fn Functions e ::= clzl$li~ele2e312(m ,.. \n.,xn)el e(el , en)n)  2. Semantics Domai~ PCAV =SV+Av~Av T G SigEnv = Fn ~ Av  a c Ans = SigEnv x ((Av \nx Ansn) e Ans) x 7J(Fn) Q6 Env =Var .+Av $ E E~v = Var -+ (Av x Ansn) ~ Ans  3. V&#38;uation Functions \n  M : Program ~ S D e SigEnv IF: Exp .+ Env ~Av A: Exp -+Env -+E~v ~Ans H~{j,(zI,... ,z~) = e;}] (pi,...,pw) \n= (< M] (f%, ..,%%) (L , q)u _ wherer ec Q = @o[(~ (PI, ,, o, pn) . 8 [ei] Q[Pk/zk~)/j!] $ = <o[(~ \n((w, ,%),(m) , am)) . A [e,] e[p~/z~] ~[~~/x~])/fi] (F,(d), -.. ,Fm(d)) where F, = =;, o ~~, and d = \n(K c) Q [x] e [f] $%1= ~Av + ~Au, (% =_Static) + f$72 u %33, V2 E SV -+ (D-ynamic, p; u w:, ..., p? \nu p~), TC where pi = S-[ei] @ < fOT i = {1,2,3} @, ,w%J ) . S IIel (~9k/zkl) (c$[e] Q) (f [cdl e, ~,t \n[en] Q) -@e< = (1, Sem, {}) ~[f]eq = o-,< [f], {f}) ~[z]Qq = < [z]  A[ifele2e3]Qq = p = TC + (~u T , \nTF, {}), (T,g,Fz UF3) w~e~e (T , -,-) = gJ(T, ,T), (T, , T)) (m,, g,,$,) = ~ [e,] Q s for i = {1,2,3} \np=&#38;[ifeleze3]Q ~ = XlUlrZU~3 9 = 92 LJ93 x[A(zl,. ..!&#38; )en@~ = (~, ~((wl, , pn), (al, .. , \n%)) . x Ke] e[pk/zk] $[ah/zk], {}) XiIe(el,. -, en)l e~ = (m u ~ , g , F ) where (#, g , F ) = g ((qI, \n. . . ,qn), (al,. . ., an)) T = 7r[(~l, . . . ,~n)/f IVf GF] u ~~i ,:1 (~,g,F~= X[e]eg p, = f[et]e f0T2_={l, \n. . ..n} ai = (~., , ) = A[e,]g7f fori={l,. --, n} TF ((pi,...,p~),(al,a~))a~)) = (J-, TF, {}) Figure \n8: Facet Analysis for higher order Programs   \n\t\t\t", "proc_id": "113445", "abstract": "", "authors": [{"name": "Charles Consel", "author_profile_id": "81100552270", "affiliation": "Yale University, Department of Computer Science, New Haven, CT", "person_id": "PP39048247", "email_address": "", "orcid_id": ""}, {"name": "Siau Cheng Khoo", "author_profile_id": "81100241361", "affiliation": "Yale University, Department of Computer Science, New Haven, CT", "person_id": "PP39063683", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/113445.113454", "year": "1991", "article_id": "113454", "conference": "PLDI", "title": "Parameterized partial evaluation", "url": "http://dl.acm.org/citation.cfm?id=113454"}