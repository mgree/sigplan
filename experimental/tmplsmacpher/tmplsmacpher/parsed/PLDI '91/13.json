{"article_publication_date": "05-01-1991", "fulltext": "\n Tag-Free Garbage Collection for Strongly Typed Programming Languages Benjamin Department of Courant \nInstitute of New York Abstract With the emergence of a number of strongly typed km\u00adguages with very \ndynamic storage allocation, efficient meth\u00adods of storage reclamation have become especially impor\u00adtant, \nEven though no type tags are required for type checking programs written in these languages, current \nimplementa\u00adtions douse tags to support run time garbage collection, This often inflicts a high time and \nspace overhead on program ex\u00adecution. Since the early days of LISP (and Algo168 later on), there have \nbeen schemes for performing tag-free garbage collection, In this paper, we describe an improvement of \nex\u00adisting methods that leads to more effective storage rechuna\u00adtion in the absence of tags. Garbage collection \nhas also traditionally been viewed as being independent of the particular program being executed. This \nmeans that results of compile-time analyses which could increase the effectiveness of garbage collection \ncannot be incorporated easily into the garbage collection process. This paper describes a method for \nperforming garbage col\u00adlection 1) in the absence of tagged data, and 2) using com\u00adpile-time information. \nThis method relies on compiler-gen\u00aderated garbage collection routines specific to the program bekg executed \nand incurs no time overhead during execu\u00adtion other then the cost of the garbage collection process it\u00adself. \nWe describe tag-free garbage collection methods for monomorphically typed and polymorphically typed lan\u00adguages, \nand suggest how they might be extended to support parallel languages. Author s address: 251 Mercer Street, \nNew York N Y 10012. Email: goldberg@cs.nyu.edu This research was funded in part by the National Science \nFounda\u00adtion (#CCR-8909634) and by DARPA/ONR (#NOOO14-90-l110). Permission to copy without fee all or \npan of this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association for Computing Mewhinery. To Gopy rrtherwise, \nor m rapubliah, requiras a faa andlor specific permission. @ 1991 ACM 0-89791-428-7/91/0005/01 65...$1,50 \nProceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation. Toronto, \nOntario, Canada, June 26-28, 1991. ~ I 1 Goldberg Computer Science Mathematical Sciences University \n1. Introduction In the past decade, a number of programming languages with strong typing but very dynamic \nstorage allocation have emerged. These languages require, or could benefit from, run time garbage collection. \nSuch languages include ML mLH90], Ada [DoD83], and C++ [Stroustntp86], Traditionally, garbage collection \n(and dynamic type checking) required each datum to be tagged with type infor\u00admation (see ~ngar86] for \ndescription of various tagging schemes). During garbage collection, the tag of each datum is examined \nin order to determine how the datum should be handled. Naturally, whether the datum is a number, pointer, \nstructure, or closure will determine how the object is treated by the collector. For strongly typed languages, \nno run-time tags are re\u00adquired for type checking, since type checking occurs at com\u00adpile-time. However, \ncurrent implementations of ML, such as [AMW], retain tags to support garbage collection (Ada and C++ \nimplementations don t have garbage collection). Main\u00adtaining these tags inflicts a space and time overhead, \nnot only during garbage collection itself, but during the whole pro\u00adgram execution. This paper describes \nan method for completely tag-free garbage collection. It is based on the following idea (which was first \ndescribed in the Algo168 literature, and which we extend) When compiling a program, the compiler generates \nthe code necessary to support garbage collection. This code is specific to the program and, since the \ncompiler knows the type of each datum in the program, requires no tagging of data. For each type in the \nprogram, there is a garbage collection routine to manipulate objects of that type. When garbage collection \noccurs, the variables of each active procedure must be traced (i.e. marked or copied). In strongly typed \nlanguages, the types of the variables of each procedure in the program are known, and are the same for \nall calls to that procedure. Thus the type information can be as\u00adsociated with the procedure instead \nof the data. The compiler generates, for each procedure, garbage collection routines that know how trace \nthe elements of the procedure s activa\u00adtion record. When garbage collection occurs, the heap-allo\u00adcated \nstructures rooted in each procedure s activation record are traced by the garbage collection routine \ncorresponding to that procedure. While a procedure is executing, the number, types, and status (initialized \nor not) of the variables in its activation record might change. This occurs if locat variables are de\u00adclared \nin nested blocks within the procedure. To handle this, different garbage collection routines should be \nassociated with different points in the procedure. The advantages of this approach over tagged garbage \ncollection methods are as follows: More efficient use of heap space: Removing the need for tags may save \nconsiderable space, even in implementa\u00adtions that use several bits in each word (pointer, integer, etc.) \nas a type tag. Without such a tag, larger integers can be represented without resorting to multi-word \nrepre\u00adsentations and addressable objects do not have to be word-aligned (T%is is the case if the lowest \nbits would have otherwise been used as a tag. If the high bits would be used, a tag-free implementation \nprovides a larger ad\u00address space). More efficient execution: During program execution in a tagged data \nimplementation, the manipulation of type tags incurs run-time overhead. For example, in imple\u00admentations \nin which integers contain a one or two bit tag, the tag must be stripped off before most arithmetic operations \nare performed and reinstated in the result. Even the tagged arithmetic instructions provided by some \nprocessors do not eliminate the run-time overhead completely.  More accurate recognition of live data \nand garbagcz Typically marldsweep and copying collectors trace from all roots, including every variable \nin every activa\u00adtion record on the stack. However, various variables in an activation record may no longer \nbe needed and should not be traced. The compiler can determine (to  some degree) the point in a procedure \nafter which a cer\u00adtain variable will no longer be accessed. Therefore, if garbage collection occurs after \nthis point in the proce\u00addure, the garbage collection code that is executed (hav\u00ading been compiler-generated), \ndoes not trace that partic\u00adular variable. We have already seen that the run-time overhead of our method \nshould be considembly lower than that of ordinary tagged garbage collection. There will probably be an \nin\u00adcrease in code size, but this effect might be mitigated for the following reasons: s Programs manipulating \nsimple types will generate sim\u00adple garbage collection routines: Since the garbage col\u00adlection routines \nare program-specific, a program that manipulates mainly simple types (integers, reals, integer lists) \nwill have very simple and short garbage collection routines. In current garbage collection systems, the \ncode of the garbage collector is independent of the program and must be sophisticated enough to handle \nall possible user-defined types. Not only might this cause garbage collectors to be rather large, but \nmight inhibit optimiz\u00ading the representation of a complex data type because its structure must be transparent \nto the garbage collector, . Recognition of program points that could cause garbage collection: The compiler \ncan determine (to some de\u00adgree) which sections of a program cannot cause the ini\u00adtiation of a garbage \ncollection. In particular, an analysis can be performed that determines whether or not a given procedure \ncall could ultimately lead to garbage collec\u00adtion. If not, then no garbage collection code need be gen\u00aderated \nto trace the variables of the calling procedure while it is waiting for the call to complete. In this \npaper we provide a detailed description of the algo\u00adrithms and representations we have developed for \ntag free garbage collection, and describe some program analyses to make it more efficient. The source \nprogramming language that we shall use in our examples is ML. However, we shall defer any discussion \nof garbage collection in the presence of polymorphically typed functions to section 3. 1.1. Related Work \nIn the early days of LISP, tags were avoided by allocat\u00ading objects of different types in different areas \nof the heap. Thus the type of an object could be determined from its ad\u00ad dress. Unfortunately, this required \nheap allocation of inte\u00adgers (using two words due to the indirection involved) and was difficult to extend \nto languages with user-defined data types, A number of papers [BL70Jvhrshal170,Wodon70] were published \ntwenty years ago on garbage collection for Al\u00adgo168, some suggesting tagged data. In a paper by Brarquart \nand Lewi [BL70] two methods were described for using compile-time type information to avoid tags, One, \ncalled the intemretive method, associated with each type an encoding, typically a parse-tree like representation \ncalled a descriptor or template, of the structure of the type. The garbage cokc\u00adtor, as it traverses \nan aggregate structure, must also traverse the appropriate descriptor to determine how to handle the \nsubstructures. The other method which (in principle) is the same as one we are espousing, is the comt)iled \nmethod, Like the name suggests, the garbage collection routines for each type were generated by the compiler. \nThe fundamental difference be\u00adtween our method and the compiled method described in [BL70] is as follows: \nc In the Branquart and Lewi method, a table mapping stack locations to garbage collection routines was \nkept at run-time in order to figure out what garbage collec\u00adtion routine to use to trace each local variable \nin each ac\u00adtivation record. This table had to be updated every time a local variable bound to a heap-allocated \nstructure was created (which was seldom, since Algo168 discouraged the use of heap abated local variables \nin favor of heap-allocated global variables). No table entries were required for global variables, since \nboth the location of, and garbage collection routine for, each global variable was known at compile time. \n In our method, notable is required. We are able to deter\u00admine the garbage collection routines for each \nlocal vari\u00adablebyusingthereturnaddresspointers thatarealready stored in the stack. Garbage collection \nschemes for Pascal, similar to the ones for Algo168, were described in [Britton75]. Instead of using \na table, however, an extm pointer was stored in every activation record to point to the descriptor or \ncompiled rou\u00adtine corresponding to the types of the variables in the activa\u00adtion record, Appel [Appe189] \nhas proposed an extension (although omitting many of the details) to the interpreted methods of [BL70,Britton75] \nin order to support garbage collection for polymorphically typed languages. In particular, he recog\u00adnized \nthat the return address stored in each activation record can be used to find the type information (i.e. \nthe descriptor) for the variables stored in that activation record. In the fol\u00adlowing section, we give \na more extensive description of Ap\u00adpel s method. The use of the return-address pointer has been used \nto implement exception handling in a number of languages (e.g. Mesa, Ada). As exceptions traverse the \ndynamic chain, the procedure represented by each activation record is exam\u00adined to see if au appropriate \nexception handler is provided. 1.1.1 Appel s Tag-Free Collection Scheme In [Appe189], an important passage \ndescribing his tag\u00adfree garbage collection method is the following: When the garbage collector is invoked, \nit searches the stack for refensmces into the heap. From the retum\u00adaddress information on the stack, \nit can determine which procedure is associated with each stack frame, Since this is the only passage \ndescribing the use of the return address in each activation record, the reader is left to inter\u00adpret \nexactly how the return address is used. In this section, we provide a straightforward interpretation \nof the passage in which a single descriptor is associated with each procedure definition. This is implied \nby Appel since his method seems to rely only on finding out which procedure is associated with each activation \nrecord and does not take into account the current execution point in the procedure. In subsequent sections \nwe describe our algorithm, based on the compiled method, in which we are able to associate different \ngarbage collection routines with various points in each procedure. The garbage collector then determines \nthe current execution point of each procedure and uses that in\u00adformation to select the appropriate garbage \ncollection rou\u00adtine. As we shall show, this allows our scheme to make use of intraprocedural and interprocedural \nprogram analyses to optimize the garbage collection process. In (our interpretation of) Appel s method, \nwhen the gar\u00adbage collector encounters an activation record R, it deter\u00admines which procedure f is represented \nby R by following the return address pointer stored in R to the call instruction in the procedure that \ncalled~, The call instruction will con\u00adtain the starting address off The type descriptor for the vari\u00adables \nill~can be associated with~ s starting address -either through a table or by placing the descriptor (or \nits address) at some fixed distance from~. Some problems with associating a single descriptor with each \nprocedure definition are: * The number, types, and status of variables in an activa\u00adtion record change \nduring the execution of the corre\u00adsponding procedure. If there are variable definitions in nested blocks \nin the procedure, then local variables ap\u00adpear and disappear. Variables mayor may not be initialized \nat various points in a procedure. Uninitialized variables present a prob\u00adlem to the garbage collector \n(it may think that an unini\u00adtialized pointer contains a valid address). The solution to this would be \nto create all local variables de\u00adfined inside a procedure as soon as the procedure is called, and to \nimmediately initialize the variables. This imposes an additional time and space overhead during execution. \nIn addition, associating a single descriptor with a proce\u00addure definition misses a significant opportunity \nfor optimiza\u00adtion. At various points in a procedure, some lwd variables will be live and others will \nnot. If the garbage collector al\u00adways performs the same action on the activation record for a given procedure, \nit will have to assume that all variables are live. This will prevent the reclamation of heap structures \npointed to by local variables that are not actually live. The tag-free garbage collection algorithm that \nwe describe in the next section addresses these issues. 2. The Tag Free Garbage Collection Algorithm \nIn this section we describe our method for monomorphi\u00adcally typed sequential languages. In subsequent \nsections we extend the method to work with polymorphically typed lan\u00adguages and languages supporting \nparallelism. Even though we use ML in examples in this section, we restrict ourselves to monomorphic \nfunctions, For consistency throughout this paper, we will assume that a copying garbage collector is \nused, However, our meth\u00ad od will support mark/sweep collection as well (see [Co\u00ad hen81] for a survey \nof garbage collection schemes). 2.1. The Basic Method An important observation is that garbage collection \ncan only be initiated by a call to a procedure (such as cons, new, or malloc, depending on the language) \nthat allocates memo\u00adry. Such a procedure must be predefine in the language. Therefore, garbage collection \ncan only occur when each ac\u00adtive user-defined procedure is waiting for a procedure call to complete. \nWhen garbage collection begins, the activation record of each active procedure~ contains a valid return \naddress. This is typically the address of the call instruction in the calling procedure (on the SPARC, \nfor example). To return from ~, the CPU increments the return address (again, on the SPARC) by two words \n(8 bytes) to the second instruction following the call (the first instruction after the call sits in \nthe delay slot) and then jumps to that address. We use the return address stored in each activation \nrecord to find the garbage collection routine for tracing the activation record below it (i.e. of the \ncaller). The details are as follows: . Suppose, for a given procedure call, the address of the call instruction \nis n. We use the word at location n+8 (which is two 32-bit words after the call instruction) to store \nthe address of the garbage collection routine, which we refer to as aframe_gc_routine, that will spec\u00adify \nhow the elements of the activation record (frame) of the calling procedure should be traced, We shall \nrefer to the word at location n+8 storing the address of the frame&#38;c_routine as the gc_word. . During \ngarbage collection, the return address stored in the called procedure contains the value n. To trace \nthe calling procedure s activation record correctly, we sim\u00ad ply call the framegc_routine whose address \nis con\u00adtained in the gc_word at location n+8. . During normal execution, when a procedure call finish\u00ades, \ncontrol returns to the instruction at address n+12, where n was the return address stored in the called \npro\u00adcedure s activation record. On the SPARC, at least, this incurs no additional cost because the retl \ninstruction is just a pseudo-instruction representing jmpl 0/.07+8,0/.g0 and can simply be replaced by \njmpl %07+12,0/40. This representation is illustrated in Figure 1. When garbage collection occurs, the \ncollector simply traverses the stack (from most recent activation record to least recent), execut\u00ading \nthe framegc_routine associated with each activation record. Figure 2 shows the main loop of the garbage \ncollec\u00adtor, written in C (in actual implementations it would be writ\u00adten in assembly code). The frame~c_routines \nassociated with each procedure take a pointer to an activation record as a parameter and trace the variables \nin the activation record according to their types. 2.2. Higher Order Functions and Closures Many languages \nsupport higher-order functions, which means that closures must be constructed to represent func\u00ad Procl: \nProc2 Local Variable k . . . Local Variable 1 Return Ad&#38;as -Static Link Dynamic Link _ Parameeerm \n. . . Pardmerer 1 Local Variable j . . . . . . <code -r call <instruction> <address . . . <code ret \nProcl_gcl: ~ <code for variables before call> Proc2 in delay of Procl_gcl> after return>. tracing Procl \ns during call . . slot> 1 . . to Proc2> I Local Variable 1 ret Procl Return Addrws Static Link Dynamic \nLink Parameter n - * Proc2: . . . I ,,, Pammerer I r STACK CODE Figurel.Stack/Code Organization tions \nas data, Consider the (monomorphic) ML function This problem is easily solved. A closure contains a map: \npointertothecode ofthefunctionitrepresents. Supposethat the code starts at address n. In location n-4 \n(the word preced\u00ad fun map f ([]: int list) = [] : int list ing the start of the code) the compiler places \nthe address of a mapf(x::xs) =fx::mapfxs garbage collection routine for tracing the closure. This works \nWhen map is called, the first argument must be represented because all closures representing the same \nfunction have the by a closure. However, the size (number of fields containing same number and types \nof fields. When a closure is encoun\u00ad the free variables) and shape (types of those variables) of the \ntered during garbage collection, the closure s code pointer is closure may differ in different calls \nto map, There is no way followed to find its garbage collection routine. formap s frame~c_routines to \nknow how to trace the fields of the closure. garbage_collecto [ frame current_frame; void ( gc_routine)(); \ncurrent_frame = frame_pointec / start at the top of the stack / gc_routine = *(current_frame->return_addr \n+ 8); / get the frame_gc_routine for the next frame*/ while (current_frame != NULL) ( current_frame = \ncurrent_frame->dy namic_link; / visit next frame in the stack / ( frame4c-routine) (current_frame); / \ncall the frame_gc_routine / gc_roufine = *(current_frame->return_addr + 8); 1 get the next frame _gc_routine \n/ ) Figure 2. The garbage collector procedure 2.3. Variant Records Languages like Pascal and Ada support \nvariant records, which are records whose number and types of fields are de\u00adtermined by the value of a \ndiscriminant field at run time. Thus, when garbage collection occurs, the value of the dis\u00adcriminant \nmust be checked in order to determine the types of the current fields. This is easily supported by our \ntag-free collection strategy, since the framegc_routines associated with a procedure containing a variant \nrecord can test the record s discriminant and perform the appropriate action. ML has similar objects, \nwhose types are defined by ML s datatype declarations, for which the same garbage collec\u00adtion strategy \nworks (again, assuming only monotypes). 2.4. An Interesting Example For easeof presentation, we write \nthe implementation of the garbage collection routines in C instead of assembly code. We indicate the \nfrarne~c_routine associated with a procedure call as follows: f(x,y,z); --this-gc namely, by writing \nthe name of the frame~c_routine (in this case, this_gc) to the right of the procedure call, preceded \nby -- 0 This indicates that if garbage collection occurs during the call to f, the routine this_gc will \nbe called to trace the fields of the activation record of the caller. Consider the ML append function \nfor integer lists: fun append [] (YS int list) = YS i append (x::xs) ys = x::append xs ys It might be \nimplemented as follows: cons_ceii append(xs,ys) cons_ceii xs, ys; ( int temp; cons-ceii re% if (M == \nNULL) retum(ys); eise { temp = xs->cafi res = append(xs->cdr, ys); --no_trace res = int_cons(terrrp, \nres); --no_trace return (res); 1 1 Notice the following properties of this append o If garbage collection \noccurs during the recursive call to append, then the only variable whose value is required later is temp. \nSince temp is an integer on the stack, no action needs to be taken. . If garbage collection occurs during \nthe call to int_cons, no local variable or parameter is needed anymore, so again no action needs to be \ntaken (int-cons will trace its parameters). so, garbage collection never needs to trace the elements \nof an append activation record! The frame~c_routine asscxi\u00ad ated with both calls in the body of append \nsimply returns. Naturally, there is only one such frame~c_routine, in this case called no_trace, and \nmany gc_words will point to it. The gc_word following many procedure calls will con\u00adtain the address \nof no_trace for one of two reason~ Like the append function above, no heap-allocated structures rooted \nin the callers activation record need to be traced, or The compiler has determined that no garbage collection \ncan occur during the call. Such an analysis is described in seetion 5.1. Better yet, if both the calling \nand called procedure are aware that garbage collection cannot oc\u00adcur, then the gc_word following the \ncall instruction can be omitted. More examples of our garbage collection method are provid\u00ad ed in subsequent \nsections. It is worth noting that the method we have described can be adapted to the interpreted method. \nIn such a case, the gc_word that currently points to framegc_routine would in\u00adstead point to a descriptor \nthat describes the types of vari\u00adables in the activation record. Garbage collection would be somewhat \nslower, since the descriptor would have to be in\u00adterpreted while traversing the activation record. However, \nthe code size should be significantly less, since the descriptor should take less space then the corresponding \nframe~c_rou\u00adtine. What the precise space/time trade-off is remains to be seen from experiments that we \nare planning to perform in the near future. 3. Garbage Collection for Languages with Polymorphism In \na languages with polymo~hic functions, different calls to the same function may supply arguments of different \ntypes. For example, the append function in ML fun append [1 YS = YS I append (x::xs) ys = x::append xs \nys is polymorphic, and its type is dcx. a list + a list -+ a list. This means that for any type, append \ncan take two lists of el\u00adements of that type and return a list of elements of that type. In current ML \nimplementations, there is only one defi\u00adnition of each polymorphic function and all calls to that func\u00adtion \nexecute the same code. While that is not a necessary condition for implementing polymorphically typed \nlanguag\u00ades, it is a convenient way to do so. As we shall see, it is pre\u00adcisely this implementation decision \nthat makes tag-free gar\u00adbage collection more difficult and more interesting. Typically, the formal parameters \nof a polymorphic func\u00adtion, especially those which get bound to arguments of dif\u00adferent types in different \nfunction calls, are represented by a single word (integer or pointer) and polymorphic functions, such \nas cons and append, simply manipulate these words. cons, for instance, creates a cell with two one-word \nfields containing its arguments, no matter what the type of the ar\u00adguments are, Since all calls to a \npolymorphic function execute the same code, there is no way for the function s frame4c_rou\u00adtines to know \nprecisely the structure of all variables in the ac\u00adtivation record during garbage collection. This would \nseem to make tag-free garbage collection impossible. Appel [Appe189] suggests the following solution \n Suppose the garbage collector cannot determine the type of a variable in a polymorphic function s activation \nrecord. Since the types of the arguments to a polymor\u00adphic function determine the types of its parameters \nand local variables, the calling procedure (found by the re\u00adturn address) is examined to determine the \ntype of the arguments. If the calling procedure is itself polymor\u00adphic, then its caller may have to be \nexamined, and so on, This continues (that is, traversing down the dynamic chain) until the precise type \nof each variable in the cur\u00adrent activation record can be determined, The problem with this is that \nthe tracing of each poly\u00admorphic function s activation record may involve traversing a fair amount of \nthe stack and testing the identity of activa\u00adtion records many times. Furthermore, determining the type \nof the parameters by accessing the encoded types of the vari\u00adables of the caller (and its caller, etc.) \nquickly becomes very complicated. No details are provided in [Appe189], and just how the garbage collector \ncan determine the types of vari\u00adables in one activation record by looking at the descriptor for another \nactivation record is far from clear. Our solution differs in that the stack is traversed at most twice, \nno testing of activation records is required, and our method is easier to descrike and, hopefully, implement. \nOur solution is as follows: The stack is traversed from the oldest activation record to the most recent \n(i.e. in the opposite direction of the dynamic chain). In order to do this, an initial traversal of the \nstack may be necessary, to perform pointer-reversal on the dynamic links. The frame~c.routines associated \nwith a polymorphic function~are parametrized by garbage collection rou\u00adtines corresponding to the types \noffs parameters We shall refer to these routines as type_gc_routines because they trace objects of a \ncertain type rather than entire ac\u00adtivation records. During garbage collection, fs frame~c_routine is \npassed the type~c_routines corre\u00adsponding to fs arguments by the framegc_routine of the procedure that \ncalled J Thus the structure of each frame~c_routine will be: f_frame_gc(p, parl_gc,..o, par&#38;9c) stack_frame \np; type_gc_routine parl_gc,..., par._gc; ( frame_gc_routine next_gc; ... trace variables using parl_gc,..., \npar~gc ... rtext_gc = ... next frame s frarneAc_routine ... next_gc(p->next_frame, argl_gc,..., arg._gc) \n1 where argl_gc,..., argn_gc are the type_gc_routines passed to the next frame s frame~c_routine. They \ncor\u00adrespond to the types of the arguments passed by f to the function it called. Garbage collection \nstarts simply by calling the frame~c_routine of the bottom (oldest) activation record on the stack. Of \ncourse, the frame~c_routine calls are tail recursive and can be implemented as a loop. Closures representing \ntypeXc_routines my be con\u00adstructed during garbage collection, and reflect the cre\u00adation of structures \nduring execution. In this way, the process of garbage collection for a polymorphic lan\u00adguage greatly \nreflects the execution process. Consider, for example, the following program fragmerm let fun fx = let \ny =[x, x] in (y, [3]) end in (f [true], f 7) end If garbage collection occurs during the creation of \n[31 in f, the fr~e~c_routine for f must call a type~c_routine to trace y. The type~c_routine for y cannot \nknow the exact structure of y, since it will vary across different calls to f and is dependent on the \ntype of x. All y s typ~c_routine can know is that it is a list, and thus must be parameterized by the \nt~~c_routine for x. The frame~c_routine for f, which will have been passed the t~&#38;c_routine for x, \nmust pass that routine to y s type~c_routine. y s type&#38;c_routine will then apply x s type~c_routine \nto each element of y, as well as copying the cons cells of y. The function f and the main function (which \ncomputes the result expression) might be implemented as f(x) unknown x; [ cons_cell templ, ~ tuple-cell \ntemp2; templ = cons(x,Nll); --f_gcl y = cons(x,templ ); --f_gc2 templ = cons(3,NltJ; --f_gc3 temp2 = \ntuple(y,temp); --f-gc4 return(temp2);  ) and maino ( cons_cell c; tuple_cell templ, temp2; c = cons(true, \nNil); --main_gcl templ = f(c) --main_gc2 temp2 = f(7); --main_gc3 templ = tuple(templ ,temp2); --main_gc4 \nreturn(templ); 1. First, consider the code for f. If garbage collection occurs during the first call \nto cons, then x must be traced. If garbage collection occurs during the second cons call, then no vari\u00adables \nneed be traced. We have already described what must happen during the construction of [3], and no tracing \nis nec\u00adessary if the tuple call causes garbage collection. In the main routine, it is only if garbage \ncollection oc\u00adcurs during the second call to f that a variable in main s acti\u00advation record must be copied. \nThis variable is temp 1 and is bound to an object of type bool list list* int list. The frame~c_routines \nfor main are defined as follows: main_gc 1(p) main_stack_frame p; ( frame_gc_routine next_gc; next_gc \n= ... next hrne s frarne_gc_routine ... next_gc(p->next, const_gc, const_gc); 1 main_gc2(p) main_stack_frame(p); \n{ frame~c_routine next_gc; next_gc = ... next frame s frameJc_routine ... next_gc(p->next, trace_list_of(const_gc)); \n1 main_gc3(p) main_stack_frame p; { frame_gc_roufine next-gc; templ_gc(p->templ); next_gc = ... next \nframe s frame~c_routine ... next-gc(p->next, const_gc, const-gc); 1 main~c4(p) main_stack_frame(p); \n{ frame_gc_routine next_gc; next_gc = ... next frame s frarne~c_routine ... next_gc(p->next, templ_gc, \ntemp2_gc); ) where templ _gc is a routine to trace a structure of type bool list list* int list and \ntemp2_gc is a routine to trace a structure of type int list * int list. const_gc is the type~c_routine \nthat can be used for all objects, such as in\u00adtegers and booleans, that are not represented by pointers \ninto the heap, but rather by single word. const_gc takes a single\u00adword value and simply returns that \nvalue. trace_list_of is a function that takes a typegc_routine r and returns a closure representing anew \ntype~c_routine that can trace a list, each of whose elements can be traced by r. For example, Figure \n3 shows the closures resulting from trace_list_of(const_gc) for tracing a list of integers or booleans, \nand traceJist_of(trace_list-of(const_gc)) for tracing a list of lists of integers or booleans. The frame \ngc routines for f are defined as follows: L.gcl (P,x_gc) f_stack_frame p; gc_routine x_gc; [ next_gc \n= ... next frame s frarne~c_routine ... next_gc(p->next, x_gc, const~c); ) f_gc2(P,xsc) stack_frame \np; gc_routine x_gc; [ next_gc = ... next frame s frarne~c_routine ... next_gc(p->next, x_gc, trace_list_of(xgc)); \n1 trace_list_of const~c t= (a) (b) Closure for gc_routine for Closure for gc_routine for tracing a \ntracing a list of integers list of lists of integers Figure 3. The closure representation of gc routines \nf_gc3(p,x_gc) f_stack_frame p; gc_routine x_gc; ( p->y = apply(trace_list_of(x_gc), p->y); next_gc = \n... next frame s tkunefic_routine ... next_gc(p->next, const_gc, const_gc);  f-gc4(p,x_gc) stack_frame \np; gc_roufine x_gc; { next_gc = ... next frame s framegc_routine ... next_gc(p->next, trace_list_of \n(x_gc), trace_list_of(const_gc)); )  Tag-free garbage collection gets more complicated in the presence \nof higher-order polymorphic functions. Consid\u00ader, for example, the following function definition fun \nfg(x::xs) = let y=(gx) in (y, 1) end  in which case f has type (a + ~) + cxlist + ~ * int. The difficulty \nlies in determining, while performing garbage col\u00adlection on f, how to find the type2c_routines for x \nand for the result of (g x). This is due to f s fiame3c_routine being passed a ty@~c_routine for the \nlist (x::xs) rather than for x, and that the type~c_routine for (g x) is dependent on an in\u00adteraction \nbetween the type&#38;c_routine for g and the typegc_routine for X. The solution to these problems is \nas follows: The type~c_routine for (x::xs), passed to f s frame~c_routine, must be a closure resulting \nfrom an application of trace_tist_of to a type~c_routine appro\u00adpriate for each elements of (x::xs), and \nthus appropriate for x. ~us, the type~c_routine for x can be extracted from the closure (see Figure 3). \n The type~c_routine to trace the result of (g X) can be created by applying a special higher-order function, \ncall~ a resuk~c_routine, associated with g to the type~c_routine for x. The result3c_routine for g is \nac\u00adcessed via the code pointer of the closure representing tie type~c_routine for g. Figure 4 shows the \nrepresen\u00adtation of the closure for the type4c_routine for 9, where trace_g is the routine for tracing \ng and hace_re\u00adsult_of_g is the resultgc_routine for g. 4. Tag-Free Garbage Collection for Languages \nwith Tasking We now describe how our tag-free garbage collection method might be extended to support \nlanguages with task\u00ading, such as Ada. We will not attempt to describe all possible tag-free garbage collection \ntechniques for all different class\u00ades of parallel languages. Rather, we will choose a simple model of \nparallelism and describe an extension of our meth\u00adod. The model we choose is that of Ada, namely multiple \ntasks operating in a shared memory environment. We further simplify the problem of garbage collection \nin this environ\u00adment by placing the restriction that all executing tasks must be suspended during garbage \ncollection. Up to now, we have made the assumption that available heap space can only be exhausted during \na procedure call and not at arbitrary times. In a multi-tasking language, such as Ada, this assumption \ncannot automatically be made. In a shared-memory environment, one process may attempt to al\u00adlocate space \nfrom an exhausted heap while other processes are executing normally. If, upon the attempt to allocate \nspace, all tasks were immediately suspended and garbage collection initiated, then the other tasks might \nnot be in a <address of trace_result_of_g> m trace_g: < . . . code for tracing g...> .,. ret trace_result_of_g: \n~ < . ..tM.B function, parametrized by a type_gc_routine for x, return8 a tp_gc_routine for tracing (g \nx)..> t Closure representing a t~Jc_routine for g Figure4. Theclosure representation oftype#c_routines \nforfunctionvalues state that would allow the garbage collector to traverse their stacks. To solve this \nproblem, we enforce our old assumption thataprocess can onlybe suspended for garbage collection purposes \nwhen the process makes a procedure call. This im\u00adplies that when the heap is exhausted, some processes \nwill continue executing until they make Pendingonhowlong oneiswillingtolet while others are suspended, \naprocess oftwosituations: o l%eheapisexhausttxlandtheprocess routine,or Theheapisexhaustedandtheprocess \ndurecall. a procedure call. De\u00adsomeprocessesrun could suspend inone callsanallocation makesanyproce- \n In the first case, only the allocation routines incur the over\u00adheadofcheckingto see ifanotherprocess \nhasexhausted the heap. This reduces the number of times a test is made to see if the process should suspend, \nbut might es to run for a long time while others second case, a test to see if the process be made at \nevery call. To improve the case where a testis allow some process\u00adare suspended. In the should suspend \nmust made at every call, it may be possible to utilize the addressing modes of some processors to make \nthe test inexpensive (providing processes can share registers). Here is how: A register Rgc, initially \ncontaining O, is dedicated for the purpose of testing for suspension. . If the heap is exhausted when \na storage allocation pro\u00adcedure is called, the procedure modifies Rgc to contain some (probably negative) \nvalue n. . When a procedure call occurs, the target address of the jump instruction is computed by adding \nthe value of Rgc to the address of the procedure being called. If the heap has not been exhausted by \nanother process, the value of ~c will be O and the call will procecxl normally. Other\u00adwise, the address \nwill be a procedure (whose address is offset from the intended procedure by n) that causes the suspension \nof the process. When all processes are suspended, garbage collection starts and the stack of each process \nis traversed in turn. When gar\u00adbage collection is complete, the processes are resumed. We have not yet \ninvestigated the compatibility of our tag-free scheme with multiprocessor garbage collection schemes \ndescribed in the literature (a comprehensive survey can be found in mudalics88]). 5. Program analysis \nfor improving tag free garbage collection In this section, we describe some program analyses that would \nreduce the cost of tag free garbage, and suggest ways in which they could be performed. 5.1. Detecting \nwhen garbage collection is possible Garbage collection can be initiated only when a heap al\u00adlocation \nrequest, such as a call to the new operator in Pascal, is made. In a first order language it is easy \nto determine which calls can ultimately lead to garbage collection. The set S of functions that may ultimately \nlead to garbage collection can be computed by a simple fixpoint iteration, F={new} ~i =~i-1 ~  {f I \n~contains a call to a function in Si-l} Since there are only a finite number of functions in a pro\u00adgram, \nthere exists some j such that Y = Y-l and therefore #= S, the set we are looking for. A similar analysis \non programs with higher order func\u00adtions is more difficult. One way to perform a higher order analysis \nis via abstract interpretation, as in [BHA85]. Anoth\u00ader approach might be to use higher-order analysis \nbased on type-inference methods, as in [MK89]. 5.2. Live Variable Analysis We have already discussed \nhow live variable analysis (see [ASU86]) can be used to reduce the number of struc\u00adtures that are traced \nduring garbage collection. Those wri\u00ad ables in an activation record that are not live when garbage collection \nstarts can be ignored by the collector. 60 Summary In this paper, we have given a method for performing \ntag-free garbage collection for monomorphically typed and polymorphically typed languages, and for sequential \nlan\u00adguages as well as languages with tasking. The major contri\u00adbution of this work has been to: 1. Formulate \na method for garbage collection that incurs no run-time overhead in time or heap space, aside from the \ngarbage collection process itself. 2. Show how compile-time analysis can be used to optimize the garbage \ncollection process.  3, Provide a detailed description (missing in previous work) of the code that a \ncompiler could generate in order to perform efficient garbage collection for polymo~hically typed languages. \nWe have implemented, by hand, tag-free garbage collection routines for a number of small programs. In \norder to gain meaningful statistics on the efficacy of our approach, a real implementation is required. \nThis entails modifying the back\u00adend of a compiler, and we are currently in the planning stages of such \na project. 7. Acknowledgments I would like to thank the National Science Foundation and DARPA for supporting \nthis work. I would also like to thank Robert Dewar, Fritz Henglein, Malcolm Harrison, Konstantin Liiufer, \nGary Lindstrom, Andrew Appel, and Di\u00adanne Britton for their assistance.  References [AM87] Appel, A.W. \nand MacQueen, D.B. A Standard ML Compiler. In Proceedings of the Conference on Functional Programming \nand Computer Architecture. Springer-Verlag LNCS 274, pp 301-324,1987. [Appe189] Appel, A.W. Runtime Tags \nAren t Necessary. In Lisp and Symbolic Computation, 2, 153-162, 1989. [ASU86] Aho, A., Sethi, R., and \nUnman, J. Compilers, Principles, Techniques, and Tools. Addison-Wesley, 1986. @3HA85] G.L. Burn, C.L. \nHankin, and S. Abramsky. The theory of strictness analysis for higher order functions. In Programs as \nData Objects, LNCS 217. Springer-Verlag. 1985 ~L70] Branquart, P. and Lewi, J. A Scheme of Storage Allocation \nand Garbage Collection for Algol-68. In Algol-68 Implementation, North-Holland Publishing Company, 1970. \n~ritton75] Britton, D.E. Heap Storage Management for the Programming Language Pascal, Master s Thesis, \nUniversity of Arizona, 1975. [Cohen81] Cohen, J. Garbage Collection of Linked Data Structures. InAC&#38;lComputing \nSurveys, 13(3),341-367. September 1981. [DoD83] U.S. Dept. of Defense. Reference Manualfor the Ada Programming \nLanguage, ANSI/MIL-STD-1815A\u00ad1983. marshal170] Marshal, S. An Algol-68 Garbage Collector. In A/gel-68 \nImplementation, North-Holland Publishing Company, 1970. ~LH90] Milner, R,, Tofte, M., and Harper, R. \nThe Definition of Standard ML. MIT Press. 1990. 131K89J Mkhra, P, and Kuo, T-M. Strictness Analysi~ A \nNew Perspective Bawd on Type Inference. In Proceedings of the Cor@erence of Functional Programming Languages \nand Computer Architecture. pp. 260-271.1989, Rudalics88] Rudalics, M. Multiprocessor List Memory Management. \nPh.D. Thesis, Johannes Kepler University, Austria. RISC-LINZ report 88-87.0, December 1988. [stroustrup86] \nStroustrup, B, The C++ programming languuge. Addison-Wesley, 1986. wngar86] Ungar, D,M. The Design and \nEvaluation of a High Pe@ormance Smalltalk System. MIT Press. 1986. Wodon70] Wodon, P.L. Methods of Garbage \nCollection for Algol\u00ad 68. In Algol-68 Implementation, North-Holland Publishing Company, 1970. \n\t\t\t", "proc_id": "113445", "abstract": "", "authors": [{"name": "Benjamin Goldberg", "author_profile_id": "81100491830", "affiliation": "Department of Computer Science, Courant Institute of Mathematical Sciences, New York University", "person_id": "PP39045430", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/113445.113460", "year": "1991", "article_id": "113460", "conference": "PLDI", "title": "Tag-free garbage collection for strongly typed programming languages", "url": "http://dl.acm.org/citation.cfm?id=113460"}