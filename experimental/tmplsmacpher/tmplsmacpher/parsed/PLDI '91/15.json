{"article_publication_date": "05-01-1991", "fulltext": "\n Register Allocation via Hierarchical Graph Coloring David Callahan Brian Koblenz Tera Computer Company \n400 N 34th Street, Suite 300 Seattle, WA 98103 * Abstract We present a graph coloring register allocator \nde\u00adsigned to minimize the number of dynamic memory references. We cover the program with sets of blocks \ncalled tiles and group these tiles into a tree reflecting the program s hierarchical control structure. \nRegisters are allocated for each tile using standard graph coloring techniques and the local allocation \nand conflict information is passed around the tree in a two phase algorithm. This results in an allocation \nof reg\u00ad isters that is sensitive to local usage patterns while retaining a global perspective. Spill \ncode is placed in less frequently executed portions of the program and the choice of variables to spill \nis based on usage pat\u00ad terns between the spills and the reloads rather than usage patterns over the entire \nprogram. Introduction We examine the problem of efficiently allocating registers to hold program variables \nand compiler tem\u00adporaries. In this problem, a program is represented as a control flow graph consisting \nof basic blocks con\u00adnected with edges representing possible transfers of control. Each basic block consists \nof a sequence of instructions accessing variables. The target machine has a finite set R of physical \nregisters and an un\u00ad bounded set M of memory locations. Each reference to a program variable must be \nassociated with ei\u00ad ther a physical register or a memory location during *This research was supported \nby the United States Defense Advanced Research Projects Agency under Contract MDA972\u00ad 89-C.0002. The \nviews and conclusions contained in this docu\u00adment are those of Tera Computer Company and should not be \ninterpreted as representing the official policies, either expressed or implied, of DARPA or the U. S. \nGovernment. Permission to copy without fee all or part of this material is granted provided that the \ncopies are not made or distributed for direct commercial advantage, the ACM copyright notice and the \ntitle of the publication and its date appear, and notice is given that copying is by permission of the \nAssociation for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific \npermission. @1991 ACM ()-~9791-428-7/91 /0005/01 92...$1.50 compilation. The goal of the register allocator \nis to minimize the number of dynamic memory references in the program by placing heavily used variables \nin registers. Most of the work in recent years has cast the reg\u00adister allocation problem in terms of \ncoloring a graph where the nodes represent variables and the edges represent conflicts. Two variables \nin the graph are connected if they cannot simultaneously share a reg\u00adister at some point in the program. \nThe goal of the allocator is to assign a register ( color ) to every node such that each node has a different \ncolor than any of its neighbors. When it is impossible to color every node differ\u00adently from its neighbors \nthen some form of spilling is required.1 The placement of code to implement spill decisions has not received \nas much attention as the question of which variables to spill. Even though newer processor designs have \nmore registers, we be\u00adlieve that the appropriate placement of spill code will become more important in \nthe near future. The reason for this is that these processors have longer pipelines, longer latencies \nbetween the time an oper\u00adation is issued and the time the result is available, and more operations executing \nconcurrently. In or\u00adder to find these concurrent operations and hide the pipeline latency, aggressive \nloop unrolling and oper\u00adation scheduling are required, both of which increase register pressure at various \npoints in the program[5]. In Chaitin s allocator[6] the decision to spill a vari\u00adable is based on a weighted \nreference count and the number of conflict edges in the interference graph. This heuristic suffers because \nthe program flow struc\u00adture is not represented in the interference graph and local reference patterns \nare not visible. In addition, 1A ~able is spilled over a section of the rmOgram when references to that \nvariable are associated with memory rather than registers. The term reload is used to indkate a transition \npoint in the program where a spilled variable becomes associ\u00adated with a register aud the term 8Piff \nrefers to the opposite transition. Proceedings of the ACM SIGPLAN 91 Conference on Programming Language \nDesign and Implementation Torontor Ontario, Canadar June 26-28, 1991. ~ once a variable is spilled to \nmemory all references must fetch its value from memory and all definitions must store the value back. \nSimple methods within a basic block[2] [6] can be used to avoid multiple loads (or stores) of a variable \nif the register has not been used since the previous load, but no global mecha\u00adnism allows the variable \nto be allocated a register over some larger portion of the program, In the ex\u00adample shown in Figure 1, \nChaitin s allocator will spill either g 1 or g2 for the entire program resulting in the poor execution \nof one of the loops. Our work describes a graph coloring allocator that is sensitive to program flow \nstructure. Spilling occurs in less frequently executed portions of the program. The choice of variables \nto spill is based on usage pat\u00adterns between the spills and the reloads rather than usage patterns over \nthe entire program. The method allows a variable to be assigned to one register over a portion of the \nprogram, memory in a second por\u00adtion, and a different register in yet a third portion. Profiling information \ncan be trivially incorporated to improve the selection of spilled variables and the lG cation of the \nspill code because all analysis is based on the probability of being in a particular basic block or flowing \nalong a particular control flow edge. The main idea is to represent the program s loop and conditional \nstructure by a tree of tiles. Tiles are visited in a bottom up fashion and a local interference graph \nis created and colored (using pseudo registers) for each tile. A tile s local spill decisions are made \nbased on local usage and a compact summary of the local interference graph is passed to the parent tile \nto be incorporated into its interference graph, After the bottom-up pass has allocated variables to pseudo \nregisters for the entire tree, a top down walk binds pseudo registers to physical registers and introduces \nspill code where desirable and required, but not nec\u00adessarily where the decision to spill was made. In \naddition to better spill code placement, our ap\u00adproach also allows smaller conflict graphs to be con\u00adstructed. \nWe are not claiming to be asymptotically smaller, but with this technique it is not necessary to construct \nthe full conflict graph at any one time. This is similar to the benefit of clique separators described \nby Gupt a, Soffa, and Steele[l 1] yet we are able to re\u00adtain a global view of the program permitting \nbetter spill analysis. The next section describes the tile tree. Section 3 gives details for the allocation \nand section 4 describes how spill decisions are made. We conclude with com\u00ad parisons to other work and \nsome observations about the generality of our approach. 2 Tiles and Tile Trees Our goal is to represent \nthe hierarchical structure of a program as a tree because the tree representation is easy to reason about \nand separates areas of high and low execution frequency. We start with some definitions: A program is \nrepresented by a control flow graph G = (1?, 1?, start, stop) where B is the set of basic blocks, E is \nthe set of control flow edges between elements of B, start 6 B is the unique block with no predecessors \nand stop G B is the unique block with no successors. Let T be a collection of sets of basic blocks which \ncovers the set B. We say that T is a tile tree and each element of T a tile if the following conditions \nhold: 1. Each pair of sets in T are either disjoint or one is a proper subset of the other. If t2 C tl \nand there is no tE T such that t2 C t C tl, then we say that tzis a cl~ild or a subtile of tland tl is \nthe parent of tz,denoted by t 1 = parent (tz). We also define the set biocks(t) to be the set of basic \nblocks which are members oft but which are not members of any child oft. 2. For each edge e = (n,m) \nE E and tile t such that m ct,wehave n6tornE Mocks(parent(t)). If n G blocks(parent(t)) we say that e \nis an entry edge.  3. For each edge e = (m,n) c E and tile t such that m Gt, we have n c t orn E Idocks(purent(t)). \nIf n E biocks(parent(t)) we say that e is an exit edge. 4. There is some tile to such that blocks(to) \n= {start, stop} This tile is called the root tile. The first restriction is central to our hierarchical \nap\u00adproach to making spill decisions. The second and third are somewhat technical and we observe that \nempty basic blocks can be inserted along an edge to allow the original endpoints to be further apart \nin the tile tree. Intuitively each empty block becomes a point where spill code can be inserted if needed. \nThe final condition ensures a simple boundary case. Many collections T satisfy the above definition in\u00adcluding \nthe trivial tree consisting of two tiles, one of which is the root tile. Our goal is to make the tile \ntree represent the structure of the program so we combine a couple of heuristics to build the tree from \nthe con\u00adtrol flow graph. The algorithm to construct the tile tree is given in appendix A. Figure 1 shows \nthe tile tree resulting from the pro\u00adgram in figure 1 superimposed on the new control flow To Bl: B2 \nT T gl = . .. g2= . .. . .. gl .. . tl = . . . .. . tl . .. . 0Bl: gl = ... g2 = ... A B2: ... gl ... \ntl = ... ... tl .... v Fl: T2 T1 ...g2... t2 = . .. . .. t2 ... Q i B3: ...g2... t2 = ... ... t2 ... \nT3 B4: .. . gl . .. g2 ... . .. B4: t ... gl ... ... g2 ... P stop: stop: r o Figure 1: allocation right \nhand Example requires figure allocation gz to be shows the problem involving spilled before block hierarchical \ntile tree two loops, four variables and a two-register machine. 132 and reloaded before B3. gl should \nbe spilled after and the basic block inserted during tree construction. Optimal 132. The 194 graph. \nThe block labeled F1 is generated by the fix- UP code in figure 3. Though representing only the loop \nhierarchy may suffice in many cases, we include both loops and con\u00additionals in our hierarchy. By including \nthe condi\u00adtionally executed portions of the program the size of the interference graphs are further reduced \nand the placement of spill code is improved. For example, consider a variable v that is used inside a \ndeeply nested conditional that is rarely ex\u00adecuted. There may not be enough register pressure to cause \nthe variable to spill until higher in the tile tree, but the point higher in the tree is executed more \nfrequently than the conditional where the variable is used. This corresponds to the case where it is \ndesir\u00adable to spill a variable inside a conditional lower in the tile tree than is necessary. Alternatively, \nconsider a pair of nested loops and a variable v that cannot be allocated a register for the inner loop \n(represented by tile t). It is possible to spill inside of the outer loop (corresponding to spilling \nalong t s entry and exit edges), but if there are no references to w in the outer loop it is better to \nspill the variable outside of the outer loop, in a tile still higher in the tree. Allocation Each basic \nblock is populated with uses and defi\u00adnitions of variables. We assume that each program variable has \nbeen fully renamed[9] and that variables correspond to an unbounded set of pseudo-registers.2 We say \na variable v is local to a tile tif all refer\u00adences to v are made by blocks within -t and v is not live \nalong any entry or exit edge oft. Variables ref\u00aderenced in a tile but not local to the tile are called \nglobal with respect to that tile. The allocation process haa two phases. In the first phase, physical \nand pseudo registers are allocated in a bottom-up fashion for each tile using graph color\u00ading. Local \nspill decisions are made and a summary of the tile s allocation is passed to its parent. Once the entire \ntile tree has had pseudo registers allocated, the second phase makes a top-down walk of the tile tree \nmapping pseudo registers to physical registers and updating spill decisions. We distinguish phys. ical \nand pseudo registers in that a pseudo register will be bound to some physical register during the sec\u00adond \nphase. When certain values must be in particular physical registers, e.g. to satisfy linkage conventions, \nzRena~ng is not required but allows a variabk with dis\u00adtinct live ranges within a tile to receive distinct \nregisters for each live range. phasel(tile t) foreach subtile s oft do phasel(s) endfor compute conflicts \nbased on references in blocks(t) add preferences based on references in blocks(t) foreach subtile s oft \ndo incorporate s s tile summary variable con\u00adflicts foreach variable g global in s that is also in a \nregister in s do incorporate g s conflicts endfor add preferences from s endfor color tile interference \ngraph update spill information save conflict and preference information for parent(t) phase2(tile t) \nreconstruct interference from global variables and tile summary variables include global variables in \nregisters in parent(t) set preferences based on allocation in pareni( i) color interference graph using \nphysical registers save allocation for each subtile s of t foreach subtile s oft do phase2(s) endfor \n Figure 2: Overview of the two passes for register al\u00adlocation. The initial call passes the root tile. \nthose variables are assigned to the appropriate phys\u00adical registers during the first phase. Figure 2 \ngives a brief algorithmic overview of the allocation process. The steps are described in more detail \nin the succeeding sections. Allocation and Conflict Summary After the first phase has processed a tile, \neach variable refer\u00adenced in the tile will be either assigned a physical or pseudo register, or be spilled \nto memory. The first phase summarizes the allocation of local variables by creating one new variable \nfor each distinct register to which a local variable is allocated. These new vari\u00adables are referred \nto as tile summary variables and we define the mapping t st (w) which maps each local variable v in t \nto the tile summary variable associated with the register allocated to v. Tile summary vari\u00adables represent \nthe coalescing of local variables that were allocated to the same register and allow an effi\u00adcient representation \nof the conflicts between local and global variables. The number of tile summary variables for any given \ntile is bounded by the number of physical reg\u00adisters IIl?[ I and the conflicts with other tile summary \nvariables can be represented with a small bit matrix. For each global variable g that was assigned a \nreg\u00adister in tile t, we retain two sets of conflicting vari\u00adables. The first set, et(g), describes the \nlocal variables in t that conflict with g. If Lt is the set of variables local to tile tand X(V1, VZ) \nis the relation that VI and V2 conflict then we define: et(g) = {ts~(v)]v E Lt and X(v, g)} The second \nset of conflicts describes the global variables in t that both conflict with g and were as\u00adsigned to \nregisters in t.We observe that at most IIR[ I global variables can be in registers at any entry or exit \npoint to the tile and so the total amount of in\u00adformation in the summary is O((Zt IIR[I)2) where ~~ is \nthe number of blocks which are the destination of entry edges to tile tor sources of exit edges from \ntile t. For structured programs, this number is 2. Tile Interference Graph For each tile processed in \na bottom-up manner, an interference graph is built. The interference graph for tile tconsists of two \nkinds of variables: variables referenced in t,and tile sum\u00admary variables for each child of t, The first \nkind of variable corresponds to the typical uses and defini\u00adtions found in t, while the second kind of \nvariable corresponds to the registers used by variables local to a subtile oft. A subtle implication \nis that variables that are live but not referenced in t do not require a variable in t s interference \ngraph, The motivation here is that if any variable must be spilled, these variables would be the first \ncandidates. Omitting unreferenced live variables also provides a reduction in the size of the conflict \ngraphs. An example of this is in figure 1 where tile T2 does not need to represent g2 in its interference \ngraph. Edges in the graph represent conflicts between variables and prevent two variables from being \nas\u00ad signed the same register. These conflict edges come from a variety of sources. 1. A conflict edge \nexists between two variables if they conflict in a block in blocks(i). This initial conflict graph is \nbuilt ignoring the subtile infor\u00admation using an algorithm similar to Chaitin[6]. 2. A variable conflicts \nwith tile summary variables and other global variables as indicated in the conflict summaries for each \nsubtile. 3. Any variable that is live in a subtile but was not part of the subtile s allocation summary, \nconflicts with all of the subtile s tile summary variables. This includes variables that are not referenced \nanywhere in the subtree rooted at the subtile plus variables that have been spilled in the subtile but \nare live in the current tile. A second savings in graph size occurs because variables live across a tile \nnormally conflict with all local variables in the tile. These conflicts are more compactly represented \nas conflicts with the tile summary variables which represent a set of variables local to the subtile. \n 4, Each node corresponding to a tile summarv variable conflicts with other tile summary vari\u00adables \nfrom the same subtile as indicated in the conflict summaries for each subtile. Tile sum\u00admary variables \ndo not conflict with tile sum\u00admary variables from sibling tiles because tile summary variables in sibling \ntiles correspond to variables with non-overlapping live ranges. Coloring Once the interference graph \nhas been constructed it is colored using a standard heuristic: all variables with less than I]l?l I conflicts \nare placed on a colorable stack along with their edges. When a variable is placed on the stack all associated \nedges are removed from the graph enabling other variables to now be placed on the stack. When the remaining \ngraph consists solely of vari\u00adables with at least Ill?ll conflicts, spill analysis is used to determine \nthe next variable to push on the col\u00adorable stack. Variables that are least valuable for keeping in a \nregister as determined in section 4 are pushed on the colorable stack next. Eventually every variable \nis on the colorable stack as suggested by Briggs et al.[3]. At this point the assignment of physical \nand pseudo registers begins. A set of colors is maintained consisting of physical and pseudo register \ncolors as\u00adsigned to variables. The set is initialized to contain the physical registers that certain \nlocal variables re\u00adquire. The coloring process pops variables from the col\u00adorable stack and gives the \nvariable a color from the color set excluding any color already allocated to a conflicting variable. \nIf less than [\\R]\\ colors have been used and the variable requires a new color then a pseudo register \nis selected and added to the set of used colors. An exception is made for global variables live at the \ntile boundaries and those variables that are pref\u00aderence to them (see below). In order to avoid overly \nconstraining these variables, we attempt to select a color that is separate from any other color already \nused sub ject to the constraint of using only [[RI I col\u00adors. Because we keep a summary of the tile s \nconflicts, it is possible to bind these distinct local colors to the same physical register during the \ntop down phase. Alternatively, if we had coalesced local and global variables during the bottom up phase, \nit would be impossible to separate them even if it was desirable. An obvious implication of the preceding \ndiscussion is that when coloring a local variable we try to avoid colors that are allocated to uncoalesced \nglobal vari\u00adables. Since the algorithm may place a variable with [IRI] or more conflicts on the colorable \nstack, some vari\u00adables on the stack may not receive a color. However, due to the stack ordering of variables, \nit is guaranteed that the more important variables, based on the spill analysis, will receive registers \nbefore the less impor\u00adtant ones. After all variables have either been given color assignments or spilled, \nwe compute the tile conflict summary described earlier for variables still in a reg\u00adister. Preferencing \nIt is sometimes desirable to allocate different variables to the same register. Sources of these preferences \ninclude: 1. If a variable is used as a procedure call argu\u00adment or result and the linkage convention \nre\u00adquires the argument or result be in a particu\u00adlar physical register, then the variable becomes preference \nto that register. 2. If there is a simple assignment from one vari\u00adable to another, than those variables \nbecome preference.  Explicit preferencing is used as an alternative to co\u00ad aiescing[6] where nodes satisfying \nthe above condi\u00adtions, especially the last, would simply be subsumed into a single node before coloring. \nWe feel our method is superior because the separate live ranges of the in\u00addividual variables allow more \nprecise spill decisions to be made. The above cases are different in that the first case has specific \nregister requirements, while the second case simply desires to have two variables in the same, arbitrary \nregister. We handle these cases separately. To implement the first case of preferencing we as\u00adsociate \nan optional local preference register with each variable. When coloring a variable which has a local \npreference, if the desired register is available, then that register is assigned; otherwise the preference \nis ignored. When coloring a variable without a local preference, a color is found that does not conflict \nwith either the already colored conflicting variables or with the local preferences of still uncolored \ncon\u00adflicting variables. If no such color exists, we revert to standard coloring techniques choosing a \ncolor which is distinct from already colored conflicting variables. This mechanism prevents a variable \nfrom arbitrar\u00adily choosing a register that is the local preference of a conflicting variable. The only \ntime a local prefer\u00adence will not be awarded is if a higher priority vari\u00adable (based on the order of \nthe coloring stack) desires the preference register, or every available register is some other variable \ns local preference. The second type of preferencing described above does not set a local preference value \nbecause there is no particular register the two variables must share. Instead, each variable is added \nto the other s prefer. ence list. When a variable v is colored, each uncolored variable on v s preference \nlist is given v s color as its local preference. Thus, after one variable in a group of preference variables \nis colored the mechanism de\u00adscribed in the previous paragraph will then work to keep the register available \nfor the other member s of the group. In order to support inter-tile preferencing and reg\u00adister targeting \na couple of special cases are imple\u00admented: 1. If a global variable is allocated to a physical register \nin a subtile, then that physical register becomes a local preference in the parent tile. This propagates \npreferences up the tile tree and allows earlier definitions of a variable to target a desirable location. \n 2. If two global variables are preference in a sub\u00adtile and are allocated to the same pseudo regis\u00adter \n(the preferencing was successful in the sub\u00adtile), then the pair is added to a list of pairs of variables \nthat should be preference in the parent tile. When the parent tile s interference graph is constructed \nthe variables on this prop\u00adagated preferences list are preference to one another. 3. We also add preferences \nbetween global vari\u00adables and tile summary variables if there is a local variable that was preference \nwith the  global variable and both variables are assigned the same color. This handles the case where \nthere is a preference between the global and a local associated with the tile summary variable without \nthe need to retain additional preference information bet ween phases. Mapping pseudo registers to physical \nregisters When the root of the tile tree is colored, the final assignment of pseudo registers to physical \nregisters occurs in a top-down fashion. At each tile, the parent will have already placed certain global \nvariables into registers and assigned some tile summary variables to registers, Other global variables \nwill be spilled to memory and some tile summary variables will also be spilled to memory. To make the \nfinal register assignment, the tile con\u00adflict graph is recreated from the summary information and is \ncolored based on current preferences. Since, during the bottom-up walk, we ignored global vari\u00adables \nthat were not referenced in the subtree rooted at the current tile, we must now include those vari\u00adables \nthat received registers in the parent tile and are live across the subtile, We make these variables con\u00adflict \nwith every other variable in the conflict graph and preference them to the physical register they re\u00adceived \nin the parent. Variables with physical preferences are assigned to those physical registers. Global variables \nassigned to a register in the parent are preference to those registers if there is no physical local \npreference. Inserting Spill Code Once the final coloring for a tile is known, spill code may need to \nbe added on en\u00adtry and exit edges. There are four general situations: Spill When the parent assigns a \nregister to a global variable v that is spilled in the child, then on each entry edge where v is live \na store to mem\u00adory is inserted and on each exit edge where v is live a load is inserted. Transfer When \nthe parent assigns a register to a global variable which is assigned a different reg\u00adister in the child, \nthen on each entry or exit edge where the variable is live a register move is in\u00adserted. Reload When \nthe parent spills to memory a variable assigned to a register in the child, and it is cost effective \nto reload that variable, then on each entry edge where the variable is live a load from memory is inserted \nand on each exit edge where the variable is live a store to memory is inserted. No Change When both the \nparent and the child al\u00adlocate the variable to memory, no processing is necessary because there is a \nsingle memory lo\u00adcation associated with each spilled variable. The phrase inserted on an edge means that \na new basic block is created which is executed only when this edge is traversed; fix-up code is placed \nin this block. The fix-up code on entry and exit edges must be ordered: stores and moves from a register \nmust preceed loads and moves to a register. It is possible for a cycle of register to register moves \nto exist per\u00admuting the contents of a set of registers in which case an idle register is used to break \nthe cycle. In the worst case a register must be spilled just to provide an idle register. The above description \nof when to spill and reload is actually a bit too pessimistic. Consider the case of a definition of a \nvariable v prior to a loop, some uses of v inside the loop, and finally another use of v after the loop. \nAssume that v gets a register for the tile associated with the loop, but does not get a register outside \nof the loop. As described, there would be a reload of v before the loop is entered, and a spill of v \nafter the loop exit. The spill is unnecessary because v ww never modified in the loop so the correct \nvalue is already in memory. A simple solution is to mark each tile where a variable is defined and propagate \nthe information up the tile tree. Thus, a variable is reloaded only if there is a register definition \nof the variable deeper in the tile tree and there has been no spill of that variable since the definition. \n4 Spilling There are two primary issues to consider when spilling: . which variables should be spilled, \nand where should the spill code be located. We address both of these issues here. When the allocator \nreaches a point where all vari\u00adables not on the colorable stack have at least \\\\Rl\\ con\u00adflicts, then \none of the remaining variables may have to be spilled. Following Briggs et al. [3] we prioritize the \nremaining variables and next place the least valuable variable on the stack; we delay the actual decision \nto spill until a variable fails to find a valid color. Chaitin[6] spills the variable with the lowest \nspill cost to conflict count ratio where the spill cost is the penalty of accessing this variable from \nmemory. This is the variable that is least likely to benefit from a register and most likely to enable \nother variables to become colorable. Bernstein et al. [2] use a comple\u00ad mentary combination of spill \nheuristics and pick the best set of variables to spill over the entire program. Our algorithm could easily \nuse either method but is implemented using Chaitin)s heuristic with our cost metric. 198 As was previously \nmentioned, the best place for spill code may not be around the tile where the de\u00adcision to spill the \nvariable is made. Therefore, the information to make the spill location decision is com\u00adputed on the \nway up the tile tree and the actual spill code insertion is made on the walk back down the tree. To properly \ndetermine spill locations for variables, each variable that may want to be spilled higher or lower in \nthe tile tree is tracked in the subtiles. This does not include every variable since the only vari\u00adables \nthat may want to be spilled higher in the tree are those variables that have already been spilled, or \nthose that are referenced in this subtree and are vis\u00adible to the parent tile. Local variables will never \nbe spilled higher in the sub tree because they are not live. The following formulas are used to determine \nwhich variables are most deserving of registers and where spill code should be inserted. Assuming unit \ncost to load or store a variable: Local.weighft(v) = ~ Prob(b) . l?e~~(v) b Z rans~ert(v) = ~ Prob(e) \n. Liues(v) e Weightt(v) = ~ (Reg.(v) Merns(v)) + .L~caLzoezghtt (v) Regt(v) = Reg?t(v) . rnin(Transfert(v), \nW eightt(v)) Mernt(v) = Mem?t(v) . Tnmsfert(v) where e ranges over entry and exit edges, b ranges over \nthe blocks in blocks(t), and s ranges over the subtiles of tile t. Livee(v) is 1 if variable v is live \nalong edge e and O otherwise. Prob(b) is the probability of b be\u00ading executed and Prob(e) is the probability \ny of flowing along edge e. ~e~b(v) is the number of references to variable v in block b. .Reg?t(v) is \n1 if variable v was allocated a register in tile t and O otherwise. Simi\u00adlarly, Mem?$ (v) is 1 if variable \nv was not allocated a register in tile tand O otherwise. Local.weightt(v) corresponds to the value of \nkeep\u00ading v in a register contributed by blocks in tile t. Trunsfert (v) is the cost of spilling (and/or \nreload\u00ading) variable v on entry to and exit from tile t. Weighti (v) is used to drive the heuristic of \nwhich variable should be spilled. It is based on the num\u00ad ber of uses of the variable in the tile, the \npenalty of allocating v to memory in this tile if it desires a reg\u00ad ister in some subtiles, and the penalty \nof allocating v to a register in this tile if it must be spilled in some subt iles. The weight can be \nnegative if there is disin\u00ad centive to allocate v to a register. This occurs if the cost of spilling \nv back to memory in some subtiles outweighs the benefit of having v in memory for tile t and the subtiles \nthat want v in a register. Tile summary variables have zero Local-weight; their weight is based on their \nvalue in the subtile and the cost of transferring a variable on all of the tile en\u00ad try and exit edges. \nThis transfer cost approximates the penalty of spilling and reloading conflicting vari\u00adables that are \nlive and in registers at the child tile s boundaries. ltegt (v) is the penalty of having the parent tile \nallocate v to memory if this tile allocates it to a reg\u00adister. This is the lesser cost choice of doing \na transfer between memory and registers at t s boundary or sim\u00adply changing the allocation of v to be \nin memory in the subtile. If Regt (v) < 0 then there is incentive for the parent to place v in memory \nbecause some descendants oft will need to spill v regardless of t s decision and there are not enough \nlocal references to overcome the cost of the spill. Mernt (v) is the penalty of having the parent tile \nallocate v to a register if this tile allocates it in mem\u00adory. This is simply the cost of moving v between \nreg\u00adisters and memory around the current tile because v must remain in memory in the subtile once a decision \nto spill it has been made. The preceding equations are used in the bottom\u00adup walk of the tile tree to \ndetermine which variables are most important to allocate to registers and also to determine if a variable \nis not worth allocating a. register even if the parent tile can place the variable in a register. They \nare also used in the top-down assignment of physical registers to determine when the allocation of a \nvariable to a register should be changed to a memory allocation because the variable is in memory in \nthe parent tile. Making Spill Decisions When walking up the tile tree, it is possible to determine that \nsome variables are not worth allocating to registers. For example, a variable that is defined in the \ncurrent tile but already spilled in all subtiles may not be worth keeping in a register for this tile \nbecause the subtile spills can be eliminated if the variable is in memory. In this case, weighi$(v) < \n0 demonstrating the disincentive of allo\u00adcating v to a register. If this disincentive overshadows the \nbenefit even when the parent tile allocates v to a register, then we know v should be in memory in tile \nt regardless of whether the parent of t places v in a register. Thus, each variable v satisfying the \nin\u00adequality transfert (v) + weightt (v) < 0 is marked as not receiving a register for tile t. All other \nspilled variables (during the bottom up walk) are spilled based on register pressure and the decision \nof which variables to spill is based on the local benefit of keeping the variable in a register. Placement \nof Spill Code When walking back down the tile tree, spill code must be inserted at ap\u00ad propriate locations. \nThere are two relevant cases for a variable W. If v is in memory in tile t and in a register in the parent \noft then we insert code to move v to and from memory on t s boundary edges. This is because spill decisions \nare never undone. If the parent found it profitable to place v in a register then there were enough uses \nto overcome the disincentive represented by the cost of transferring w to memory around tile t. If w \nis in a register in t and in memory in the parent oft and if weightt(v) > trans~erj(v) we gener\u00ad ate \nmemory to register transfers otherwise we change the allocation of v in t to reflect that it should be \nin memory. Related Work Our work is primarily an extension of the work done by Chaitin[6]. We retain \nthe accuracy of Chaitin s interference graph but, unlike Chaitin, we are able to benefit from local usage \npatterns and can place spill code intelligently. Chow and Hennessy[8] and Larus and Hilfin\u00ad ger[13] handle \nconflicts more coarsely than we do. They represent each variable as a set, of contiguous basic blocks \n a live range where the variable must occupy a register. When the interference graph can\u00ad not be colored \nwith the available registers a live range is split into a pair of live ranges which are treated as separate \nvariables and allocated to registers indepen\u00ad dently. Spill code is inserted at the basic blocks that \nform the boundary of two live ranges to coalesce vari\u00ad ables that were split from a common ancestor. \nThe splitting of live ranges is greedy and based solely on the edges in the interference graph; the new \nlive range continues to grow as long as it is colorable. This can resuIt in live range boundaries inside \nof loops even though spilling outside the loop would produce better code. Another disadvantage of the \nChow and Hen\u00adnessy scheme is that they separate local and global variables and color them from distinct \nregister sets. This results in extra copies that coalescing and pref\u00aderencing can avoid and also reduces \nthe number of available registers for global coloring. Briggs, Cooper and Torczon[4] find the loop struc\u00adture \nof the program and perform live range splitting (with limited coalescing) at loop boundaries. They spill \nintelligently, but their interference graphs are large and they cannot spill inside of conditional state\u00ad \nments. Meltzer and Knobe[12] independently attempted to incorporate the program structure into a register \nallocator and have a similar notion of local and global variables. They construct a (control tree based \non the work of Sharir[14]. This is similar to our tile tree for structured programs but we believe our \nalgorithm is more easily adapted to varying tile granularities. Also, Sharir may view branches out of \nnested loops as if statements where we continue to see the natural loop structure. Meltzer and Knobe \ndo not go into detail about making spill decisions, but they claim the optimal location for spill code \nis at the highest point in the control tree. We believe their claim to be in error based on the discussion \nin section 2 and have tried to give a complete discussion of spill analysis to support our position. \n6 Summary and Observations To summarize, our method for register allocation covers the program with sets \nof blocks called tiles. The tiles are grouped into a tree reflecting the pro\u00ad gram s structure and resulting \nin an allocation of reg\u00ad isters that is sensitive to local usage patterns while re\u00ad taining a global \nperspective. Registers are allocated in each tile using standard graph coloring techniques and spill \ncode is inserted at infrequently executed tile boundaries to rectify different allocations between an \nancestor tile and its descendants. We conclude with a brief discussion of special top\u00ad ics which are \nhandled well by this method. When a variable corresponding to a machine in\u00ad struction operand is spilled, \nsome provision must still be made to deliver the variable s value to the pro\u00ad cessor. Most modern processor \ndesigns allow such operands to only come from registers and so a reg\u00ad ister must be made available to \nhold the value im\u00ad mediately before its use. A simple solution[13] to this problem is to reserve registers \nspecifically for this purpose. Another solution[6] is to introduce temporary variables for each such \nuse and then re. peat the entire register allocation process considering these temporary variables. Repeating \nthe allocation is expensive[3][11] and the potential for register spills is increased with aggressive \noptimization techniques. Our method avoids the need to iterate by introducing these temporaries as local \nvariables with infinite spill cost. Since these variables are visible in only one tile and no tile has \na large number of them, they do not contribute significantly to the cost of allocation. Another anomaly \nin register allocation is handling procedure calls. A linkage convention may specify Finally, our original \ngoal for this work was to find that particular registers should be saved by the caller, an efficient \nregister allocation scheme that could ex\u00adsaved by the callee, used as parameters, or used to ecute in \nparallel on our machine and thus speed the ret urn a value. The various conventions for handling entire \nallocation process. We achieved this goal since registers at call sites and procedure entry and exit \ncan sibling subtrees can be processed concurrently in both be handled uniformly with our technique. Parame-the \nbottom-up and top-down passes. The amount of ter passing and return values can be easily handled parallelism \ndepends on the shape of the tile tree, Our with preferencing, Spilling caller-save variables can primary \nlanguage is Fortran and our expectations be modeled by introducing, at the point of the call, confirmed \nby early experiments are that there is a local variable with infinite spill cost and a prefer-adequate \nbreadth in the tree to expect benefit from ence to a physical register. Handling callee-save reg-parallel \nevaluation. isters is analogous to spilling variables corresponding to the callee-saved registers that \nare live across the References entire procedure but not referenced anywhere in the procedure. When processing \nthe root tile, each callee-[1] F. E. Allen. Control Flow Analysis. In Proceed. save register is assumed \nto contain a live variable with ings of the SIGPLAN 70 Symposium on Com\u00adweight commensurate with the \nsave and restore cost piler Construction, pages 1-19, July 1970. and a preference to the callee-save \nregister. This vari\u00ad [2] D. Bernstein, D. Goldin, M. Golumbic,able competes with other variables during \nthe spill H. Krawczyk, Y. Mansour, I. Nahshon, andanalysis. R. Pinter. Spill code minimization techniquesFor \nexample, consider a case where a routine first for optimizing compilers. In Proceedings of thehas a quick \nreturn check and then does lots of com-ACM SIGPLAN 89 Conference on Program Lan\u00adputation. The bulk of \nthe computation will be in a guage Design and Implementation, pages 258\u00adsubtile with lower execution \nfrequency than the root 263, June 1989,tile. In this case, the cost analysis will indicate sub\u00ad tile \nsummary variables should be spilled in the root [3] P. Briggs, K. Cooper, K. Kennedy, and L. Torc\u00ad tile, \nrather than the variables occupying callee-save zon. Coloring Heuristics for Register Allocation. registers. \nThe net effect is the same as the shrink In Proceedings of the ACM SIGPLAN 89 Con\u00ad wrapping discussed \nby Chow[7]: a callee-save regis\u00adference on Program Language Design and Imple\u00ad ter is not saved until \nan execution path which actually mentation, pages 275 284, June 1989. requires the register is selected. \nInline expansion replacing a function call with [4] P. Briggs, K. Cooper, and L. Torczon. Aggres\u00ada copy \nof the body of the function is an optimiza-sive Live range Splitting. Technical report, Rice tion used \nto reduce the overhead of function calls and University, 1991. to allow more effective optimization in \nthe vicinity of [5] D. Callahan, S. Carr, and K. Kennedy, Im\u00adthe function call. However, inline expansion \ncan have proving Register Allocation for Subscripted Vari\u00ada detrimental effect on traditional register \nallocators ables, In Proceedings of the ACM SIGPLANsince a natural spill point (the call site) has been \nre\u00ad90 Conference on Program Language Design andmoved. Since our method retains natural spill points Implementation, \npages 53-65, June 1990. such as loop boundaries and nested control we should not suffer any side effects. \nFurther, since the local [6] G. Chaitin. Register Allocation and Spilling via variables of the inlined-function \nwill all be local to Graph Coloring. In Proceedings of the SIGPLAN the function s tile, the cost of coloring \nafter inline ex\u00ad 82 Symposium on Compiler Construction, pages pansion should be proportional to the combined \ncost 98-105, June 1982. of coloring each function separately, Some machines have more levels of programmer \n[7] F. Chow. Minimizing Register Usage Penalty addressable memory hierarchy than just registers and at \nProcedure Calls. In Proceedings of the ACM main memory. Our techniques can be easily extended SIGPLAN \n88 Conference on Program Language to handle this hierarchy by moving variables between Design and Implementation, \npages 85-94, June one hierarchical level and another at the tile bound-1988. aries. Allocation entails \nplacing the variable at the [8] F. Chow and J. Hennessy. Register Allocationhighest level where it can \nbe allocated and relying by Priority-based Coloring. In Proceedings of on the spill analysk to eliminate \nunprofitable moves between levels. the SIGPLAN 84 Symposium on Compiler Con\u00adstruction, SIGPLAN Notices \nVol. 19, No. 6, pages 222--232, June 1984. [9] R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and K. Zadeck. \nAn Efficient Method of Comput\u00ading Static Single Assignment Form. In Confere\u00adnce Record of the Sixteenth \nACM Symposium on the Pm nciples of Programming Languages, pages 25-35, January 1989. [10] J. Ferrante, \nK. J. Ot tenstein, and J. D. Warren. The Program Dependence Graph and Its Use in Optimization. ACM Transactions \non Progmm\u00adming Languages and Systems, 9(3):319 349, July 1987. [11] R. Gupta, M. L. Soffa, and T. Steele. \nRegister Allocation via Clique Separators. In Proceed\u00adings of the ACM SIGPLAN 89 Conference on Program \nLanguage Design and Implementation, pages 264-274, June 1989. [12] K. Knobe and A. Meltzer. Control Tree \nbased Register Allocation. Technical report, COM-PASS, 1990. [13] J. Larus and P. Hilfinger. Register \nAllocation in the SPUR Lisp Compiler. In Proceedings of the SIGPLAN 86 Symposium on Compiler Construction, \nSIGPLAN Notices Vol. 21, No. 7, pages 255-263, June 1986. [14] M. Sharir. Structural Analysis: A New \nAp\u00adproach to Flow Analysis in Optimizing Compil\u00aders. Computer Languages, 5:151 153, 1980. [15] R. E. \nTarjan. Testing Flow Graph Reducibil\u00adity. Journal of Computer and System Sciences, 9:355-365, 1974. A \nTile Tree Construction Many tile trees can be constructed from a pro\u00ad gram. We construct a tile tree \nby starting with a tile graph corresponding to the control flow graph and group nodes in the tile graph \ntogether until it forms a legal tile tree. The first step is to identify the loop structure based on \nintervals in the flow graph[l, 15]. An in\u00adterval is a set of basic blocks which form a loop in the program. \nLike tiles, intervals nest. We define a loop top as the single basic block that has incoming back edges \nand dominates every basic block in its loop. Al\u00adthough irreducible loops do not have a loop top, all \nblocks in an irreducible loop that are reached by a forward control flow edge from a basic block outside \ndefine t(n) to be the smallest tile which cent ains block n. foreach edge e = (n, m) do if n@ t(m) and \nm @ t(n) then let a be the smallest tile containing both nand m create a block na in a and in all tiles \ncontaining a replace e with (n, n.) and (n=, m). endif endfor while 3e = (n, rn) where m @ parent(t(n)) \ndo create n in parent (t(n)) and all ancestor tiles replace e with (n, n ) and (n , m) endwhile while \nSe == (m, n) where m @ parent(t(n)) do create m in parent (t(n)) and all ancestor tiles replace e with \n(n, m ) and (m , m) endwhile Figure 3: Tile tree fix-up: eliminate edges which vio\u00adlate conditions 2 \nor 3 by inserting empty blocks. the loop can be combined in the tile tree and treated as a single summary \nloop top. This summary node will dominate every basic block in the loop, Similarly for loops with multiple \nexits, we add a summary exit node so that each node in the interval will be post\u00addominated by a node \nin the interval. Each interval will be a tile. The interval structure could be used directly as a tile \ntree but we can further capture the control struc\u00adture within each interval. For each interval 1, we \nform a graph GI = (NI, EI). Each interval strictly contained in 1 is represented by a single node in \nN1 and each block in 1 not in a subinterval is repre\u00adsented by a node in NI. Edges EI are induced by \ncontrol flow edges between blocks in 1 as if blocks in subintervals were coalesced together. Self-loops \nand interval exit edges are ignored. We next find equiv\u00adalence classes of nodes in each GI which are \ntotally ordered by both the dominator and post-dominator relations:3 for Si = {rzl, . . . . nk}, we have \nnj dom\u00adinates and is post-dominated4 by nj +1. From each Si we construct S$ by including any node dominated \n3 These ~et~ me &#38;o~t the same as sets of nodes with the same control dependences[lO]. Since not all \nedges in the control flow graph are considered, the dominator and post-dominator relations are for this \ngraph are not subsets of the corresponding relations of the control flow graph. 4 we ~=ume ~ both dofinates \nand post-dotiates itse~. by a node in Si and post-dominated by a node in S i. Each of the sets S; will \nbe a tile. Since conflict graphs may have 0(n2) edges for n variables, it is desirable to control the \nsize of blocks(t) plus the number of subtiles of t.This suggests that we break large tiles up into pieces \nto bound this number. A natural way to break tiles is to partition large Si into disjoint pieces where \nall nodes in one piece dom\u00adinate those in another. A tile can, however, be bro\u00adken into arbitrary connected \ncomponents if no natural partition exists. Once an initial covering of tiles has been selected, empty \nbasic blocks are added where edges violate the second or third conditions on a tile tree. Figure 3 shows \nthe algorithm to add these basic blocks. The first loop finds edges which cross between sibling tiles \nand introduces an empty block in the smallest con\u00adtaining tile. The next two loops identify edges which \ncross from a tile to a containing tile which is not the parent. Each such edge is shortened by adding \nan empty block in the parent tile and replacing the in\u00advalid edge with an edge to the parent block and \nand edge from the parent block to the other endpoint. The former of these new edges satisfies restriction \ntwo and the latter is shorter than the original edge so this process must terminate. Execution time is \n0(11.11[1 . h(T )) where h(Z ) is the height of the tile tree: the length of the longest chain of tiles \ntotally ordered by subset inclusion. It is expected that ac\u00adtual times will not approach this bound in \npractice. Execution time of finding intervals is O(IIEII + IINII) and the execution time of finding tiles \nwithin intervals is dominated by the time to compute the dominator relation, O(IIEII log IIIVII).\n\t\t\t", "proc_id": "113445", "abstract": "", "authors": [{"name": "David Callahan", "author_profile_id": "81100653612", "affiliation": "Tera Computer Company, 400 N 34th Street, Suite 300, Seattle, WA", "person_id": "PP31051738", "email_address": "", "orcid_id": ""}, {"name": "Brian Koblenz", "author_profile_id": "81100482248", "affiliation": "Tera Computer Company, 400 N 34th Street, Suite 300, Seattle, WA", "person_id": "P32744", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/113445.113462", "year": "1991", "article_id": "113462", "conference": "PLDI", "title": "Register allocation via hierarchical graph coloring", "url": "http://dl.acm.org/citation.cfm?id=113462"}