{"article_publication_date": "05-01-1991", "fulltext": "\n Generalized Algorithmic Debugging and Testing Peter Fritzson (E-mail: paf@ida.liu.se) Phone +46 13281484 \n*Tibor Gyimothy (E-mail: h42gyi@ella.uucp) Phone +36 6212508 Mariam Kamkar (E-mail: mak@ida.liu.se) Phone \n+46 13281949 Nrthid Shahmehri (E-mail: nsh@ida.liu.se) Phone +4613 281464 Department of Computer and \nInformation Science Linkoping University, S-581 83 Lh_dcoping, Sweden. *Research Group on the Theory \nof Automata Hungarian Academy of Sciences, H-6720 Szeged Aradi vertanuk tere 1, Hungaty Abstract This \npaper presents a version of generalized algorithmic de\u00adbugging integrated with the category partition \nmethod for functional testing. In this way the efficiency of the algorith\u00admic debugging method for semi-automatic \nbug localization can be improved by using test specifications and test results. The long-range goal of \nthis work is a semi-automatic debug\u00adging and testing system which can be used during large-scale program \ndevelopment of non-trivial programs. The method is generally applicable to procedural lan\u00adguages, and \nis not dependent on any ad hoc assumptions re\u00adgarding the subject program. The original form of algorith\u00admic \ndebugging, introduced by Shapiro [Shapiro-83], is how\u00adever limited to small Prolog programs without side-effects. \nAnother drawback of the original method is the large number of interactions with the user during bug \nlocalization. To our knowledge, this is the first method which uses category partition testing to improve \nthe bug localization properties of algorithmic debugging. The method can avoid irrelevant questions to \nthe programmer by categorizing input parameters, and match these against test cases in the test da\u00adtabase. \nIn addition, we use program slicing, a data flow anal\u00adysis technique, to dynamically compute which parts \nof the program are relevant for the search, thus further improving bug localization. We believe that \nthis is the first generalization of algo\u00adrithmic debugging for programs with side-effects written in \nimperative languages such as Pascal. These improvements together makes it more feasible to debug larger \nprograms. A prototype generalized algorithmic debugger for Pas\u00adcal, and a test case generator for real \nsize application pro\u00adgrams in Pascal, C, dBase and LOTUS have been imple\u00admented. This work is supported \nby STU, the Swedish National Board for TechnicaJ Development Permission to copy without fee sII or part \nof this materiel is granted provided thst the copies ere not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its dete appear, and notice \nia given that copying ia by permiaaion of the Association for Computing Machinery. To copy otherwise, \nor to republish, requires a fee and/or specific parmiasion. @ 1991 ACM 0.89791-428-7/91/0005/031 7...$1.50 \n1. Introduction Debugging has always been a costly part of software devel\u00adopment, and several attempts \nhave been made to provide au\u00adtomatic computer support for this task [Seviora-87].The Al\u00adgorithmic Debugging \nTechnique, introduced by Shapiro [Shapiro-83] was the first attempt to lay a theoretical frame\u00adwork for \nprogram debugging and to take this framework as a basis for a partly automatic debugger. In this system, \nthe pro\u00adgrammer supplies a partial specification of the program dur\u00ading the bug localization process, \nby answering questions. However Shapiro s model cannot handle side-effects or loops, and has only been \napplied to Prolog programs. This restriction prevents the system from being practically useful for programs \nwritten in imperative languages. Furthermore, a major drawback of algorithmic debug\u00adging is the great \nnumber of user interactions during the de\u00adbugging process. Thus, an important improvement would be to \nsupply the debugging system with some information which can reduce this number. An algorithmic debugging \nmethod for imperative lan\u00adguages is dkcussed in [Shahmehri, Fritzson-89]. A major improvement in the \nbug-localization process is demonstrated in [Shahmehri, et al-90] by combining program slicing and algorithmic \ndebugging. Program slicing, as presented by [Weiser-84] is a method for automatically decomposing pro\u00adgrams \nby analyzing their data flow and control flow. This method isolates individual computation threads within \na pro\u00adgram. The size of a slice is usually program and input depen\u00addent. However in practice, a slice \nis often much smaller than the original program, especially for block-structured lan\u00adguages, In this \npaper we present a further improvement in the bug-localization process by combining the catego~ partition \ntesting method [Ostrand,Balcer-88] with the algorithm intro\u00ad duced in [Shahmehri, et al-90]. The main \nconcept of the im\u00ad provement is the following: During the debugging of a real program the user has to \nanswer a great number of difficult questions. For example, suppose that the program contains a procedure \nwhich computes the sum of an array and this pro\u00ad cedure is called with an actual parameter which is an \narray Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation. \nToronto, Ontario, Cenada, June 26-28, 1991. with hundred elements. The user cannot easily check the \ncor\u00adrectness of the result. However, if this procedure has already been tested, the test results can \nbe used in the debugging pro\u00adcess. We developed a Generalized Algorithmic Debugging and Testing method \n(GADT) which uses the program slicing concept and an extended version of category partition testing method \nduring the bug-localization process. In the remainder of this paper we fiqst give a brief over\u00adview of \nthe testing method used in GADT. Section 3 contains a short description of the algorithmic debugging. \nProgram slicing is briefly explained in section 4. Then, the GADT method is described in sections 5, \n6 and 7. In addition, an ex\u00adample is given in section 8 to show how the debugging sys\u00adtem works from \nthe user s point of view. We describe the im\u00adplementation status in section 9. 2. T-GEN-An Extended Version \nof the Catego\u00adry Partition Testing Method. In this section we describe a method which provides assis\u00adtance \nfor functional testing of programs. This method has been implemented in the T-GEN test case generator \ntool. T-GEN is able to generate executable test cases for testing pro\u00adgrams in C, Pascal, dBase or LOTUS. \nA detailed description of T-GEN can be found in [Szucs, Gyimothy-90] and [Toc\u00adzki, et al-90]. During \nthe process of functional testing, the programs cannot be tested with all the possible properties of \nthe input parameters. Hence, the tester s first task is to define the crit\u00adical properties of parameters. \nThese critical properties \u00adcalled categories -are investigated in the testing process. The categories \ncan be divided into classes -called choic\u00ades -presuming that the behavior of the elements of one choice \nis identical from the point of view of the test process. If the categories and choices for a program \nhave been defined, then T-GEN is able to generate all the possible test frames. A test frame contains \nexactly one choice from each category. In general, there are many superfluous frames among the generated \ntest frames. These frames can be eliminated by associating selector expressions with the choices. A choice \ncan be made in a test frame if the selector expression associ\u00adated with the choice is true. The selector \nexpressions contain property names, A property name is also associated with a choice and can be considered \nas a logical variable. The value of this variable is true if the given frame contains that choice. A \nprogram usually produces a number of results and the tester must define the interesting test frames. \nThe results of a program can also be divided into categories and choices by selector expressions. Running \ntest cases in applications usually necessitates time-consuming installation of environment parameters. \nThe test frames using the same environment can be divided into test scripts by way of selector expressions. \nIn the different parts of the test specification, the user can describe declarations and executable statements \nwhich are generated into the test cases. In Figure 1 we give the structure of a test specification for \nthe procedure arrsum, This procedure is able to compute the sum of the elements of an array. From the \nspecification given in Figure 1, T-GEN is able to generate test frames integrated in test scripts. For \nexample, under the label scripts in Figure 1, script_l contains two frames: (more, mixed, large) and \n(more, mixed, average). procedure arrsum(a: intarray; var b: integer); var i: integeq begin b:= O; for \ni:=l to n do b:= b + a[i]; end; (*we suppose that the value of n is defined globally *) test arrsurn, \ncategory size_of_amay; zero : property SINGLE, one : property SINGLE two :; more: property MO~, category \ntype_of_elements; positive: ; negative: ; mixed : if MORE property MIXED; category deviation; small : \n; large : if IvHXED; average : if MIXED; scripts script_l : if MIXED; script_2 : if not MIXED; result \nresult_l : if MIXED; Figure 1: The definition of the procedure and aj?amework of a test specification \nfor the given procedure Only one frame is generated for each choice associated with the SINGLE property \nBy extending the test specification with declarations and executable statements the system can generate \nexecutable test cases from test frames. During the execution of the test cases, test reports are produced \nin a database. These test reports can easily be ac\u00adcessed by using a coded form of the test frames. The \nsystem presented in [Ostrand, Balcer-88] investi\u00adgates only the generation of test frames with a restricted \nform of selector expressions. The new features implemented in T-GEN (test scripts, result categories, \ntest cases, test reports) extend the application possibilities of the category partition method. The \ntest specifications and test reports implemented for theprocedures ofaprograrn can beusedduring thealgorith-l?. \nmic debugging process (see 5.3.2). 3. Principles of the Algorithmic Debugging Technique Algorithmic \nprogram debugging as originally defined by Shapiro [Shapiro-83] is an interactive process where the de\u00adbugging \nsystem acquires knowledge about the expected be\u00adhavior of the debugged program and uses this knowledge \nto localize errors. The knowledge is collected by the system through a number of yes or no questions \nto the user. The tar\u00adget and implementation languages for the algorithms pre\u00adsented by Shapiro is Prolog. \n[Drabent, et al-88] suggest a generalization of the lan\u00adguage used to communicate with the debugger. \nIn addition to the usual yes and no answers, even assertions are allowed. The assertions give formal \nspecifications of some properties of the intended program. These specifications can be logic programs. \nThis mechanism may reduce the number of user interactions. We generalize the algorithmic debugging method \nto programs which may contain side-effects and which can be written in imperative languages, e.g. Pascal. \nWe follow Ban\u00adning s definition of side-eflects [Banning-78] [Banning-79] which consists of both variable \nside-effects and exit side-ef\u00ad fects. Assertions in this model are expressed in terms of Boolean expressions, \nwhich can refer to functions and proce\u00ad dures, parameters, and global variables. The current target and \nimplementation language for our algorithmic debugging system is Pascal. The algorithmic program debugger \ncan be invoked by the user after noticing an externally visible symptom of a bug. The debugger executes \nthe program and builds a trace execution tree at the procedure level while saving some use\u00adful trace \ninformation such as procedure names and input/out\u00adput parameter values. The algorithmic debugger traverses \nthe execution tree and interacts with the user by asking about the expected be\u00ad havior of each procedure. \nThe user has the possibility to an\u00ad swer yes or no or to give an assertion about the intended be\u00ad havior \nof the procedure. The search finally ends, and a bug is localized in a procedure p when one of the following \nholds: Procedure p contains no procedure calls. All procedure calls performed from the body of procedure \np fulfill the user s expectations. The output from the debugger shows that, given the in\u00ad put parameter \nvalues and the user s assertions about expected results, an error has been isolated to a certain procedure \nbody. As an example of algorithmic debugging, consider the procedure P which given the two input parameters \na and c computes the value of the two output parameters b and d. The value of variable b is computed \nby calling procedure Q, and the value of variable d is computed by calling procedure procedure P(a, c: \nintegeu var b, d: integer); procedure Q(a intege~ var b: integer); ... end; procedure R(c: integeu var \nd: integer); ... end; begin Q(a, b); R(c, d); cud; Assume that: A call to procedure P on input values \na and c returns the output values b and d . There is a bug in procedure R which causes the wrong output \nvalue&#38;. An interaction session with algorithmic debugger will be as follows. In the interaction sessions \npresented in this pa\u00adper, the boldface text stands for the debugging system s out\u00adput, and normal text \nrepresents user input. P(In a: a , In c: c , Out b: b , Out d: d )? no Q(In a: a , Out b: b )? yes R(In \nc: c , Out d: d )? no An error localized inside the body of procedure R. 4. The Concept of Program Slicing \nProgram slicing introduced by [Weiser-84] is a method for reducing the amount of code that needs to be \ninspected when debugging [Lyle,Weiser-87] or understanding pro\u00adgrams. Considering a specific subset of \na program s behav\u00adior, slicing reduces that program to a minimal form which still produces that behavior. \nThe reduced program which is an independent program is called a slice. A program slice at a program point \np on a variable v is all statements and predicates of the program that might affect the value of v at \npoint p. Figure 2 shows an example program and a slice of that program taken on the variable mul with \nre\u00adspect to the last line of the program. In the presence of procedures and procedure calls, inter\u00adprocedural \nslicing generates a slice of an entire program, where the slice crosses the boundaries of procedure calls \n[Weiser-84] [Horwitz, et al-88]. program p; program p; var x, y, z, sum, mul: integeq var x, y, mul: \nintegeu begin begin read(x,y); read(x,y); mul:= O; mul:= O, sum:= @ if x <= 1then ifx<= 1then sum:= x+y \nelsemul:= x*y; else begin end. read(z); mul:= x*y; end; end. (a) The original program (b) The sliced \nprogram Figure 2: (a) An example program p, which reads in variables x and y, and returns variables sum \nand mul. (b) A slice of the original program p on variable mul at the last line of program p. formations \ninclude the insertion of new formal parameters to 5. Functional Overview of GADT remove references of \nglobal variables, conversion of global We divide our algorithmic debugging methodology into gotos into \na combination of local gotos and tests on exit pa\u00adthree major phases: a transformation phase, a tracing \nphase rameters, and detection of loops caused by backward local and a debugging phase. The last phase \nconsists of the three jumps. Global data-flow and alias analysis is performed in major components: pure \nalgorithmic debugging, test case order to detect possible side-effects, which should be elimi\u00adlookup \nand partitioning, and program slicing, nated through transformations. Also, trace generating ac\u00adtions \nare added to the transformed program in this phase. Phase I &#38;II Trace generating actions are created \nfor all relevant units of a program. Here, we define a unit to be a procedure, a func-Program tion or \na loop inside a procedure/function, i.e. a local loop. \\Transformations More details about the transformations \ncan be found in [Shahmehri-91] or [Kamkar,et.al-90]./ The debugging system maintains a mapping betweenTracing \n / I I the original and the transformed program constructs. 5.2 The Tracing Phase Execution tree This \nphase builds an execution tree of the transformed pro\u00ad  / /0/ gram An execution tree of a program is \na tree structure con\u00ad taining information about the program s actual execution. I We refer to the actual \nprogram execution as the actual pro-Pure Algorithmic gram behavior [Ducass6, Erode-87]. The execution \ntree cre\u00adated in this phase contains trace information about each unit of the original program, such \nas parameter values and value of variables which cause global side-effects within the unit. Note that \nthe execution semantics of the original and the II IH I I&#38;QE!2El rogram icing I I transfomned program \nare equivalent. User 5.3 The Debugging Phase Figure 3. The.functional structure of the algorithmic de- \n The goal of the debugging phase is to localize a bug through bugging system. Arrows denote inf;rmatio; \ntransfer. a dialogue with the user with as few interactions as possible. The debugging phase uses the \nprogram representation pro\u00adduced by the transformation phase. However, the user never 5.1 The Transformation \nPhase sees the program in this intermediate form. This transparent This phase takes a program that may \ncontain side-effects, behavior is obtained through a mapping between the two rep\u00adwritten in an imperative \nlanguage, and transforms it to an resentations. The debugging phase consists of the following equivalent \nprogram without global side-effects. These trans-three components: pure algorithmic debugging, test case \nlookup, and program slicing. 5.3.1 Pure Algorithmic Debugging This component interacts with the user \nthrough queries about the expected result of the program s units, i.e. intended pro\u00adgram behavior, while \ntraversing the execution tree. During the tree traversal, at each step, a query is formulated by this \ncomponent. Before interacting with the user, the pure algo\u00adrithmic debugger checks with two existing \nsources of infor\u00admation. These two sources consist of assertions previously supplied by the user, and \nthe test case lookup component. If any of these two sources were able to supply an answer to the current \nquery, then the debugging process goes on without involving the user. Otherwise, the user has to give \nan answer to this query. The debugging process goes on until one of the following happens: . A bug is \nlocalized by the debugger at the procedure/ unit level, i.e. the debugging ends, or The program slicing \nis activated by the user, due to an error indication. This case happens when a unit produces several \noutput values and only some of these values are erroneous.  5.3.2 Test Case Lookup. Possible Interaction \nTypes The test specifications and test reports implemented for the procedures of a program can be used \nduring the algorithmic debugging. In the case of debugging process the concrete values of the input and \noutput parameters of a procedure are given. For a given input the user has two possibilities to de\u00ad termine \nthe correspondhig test frame. For many procedures a function can be defined which automatically selects \nthe suitable test frame. For example, it is easy to define a function which gives the correct test frame \nfor an input array using the test specification in Figure 1. These functions are called during the debugging \nprocess. For some procedures we cannot define such functions. In this case, the test specification can \nbe used in the user in\u00adteractions to select the correct test frame. The interactions based on the test \nspecification are much more convenient for the user, because he/she can select the suitable choices from \na menu. Then, the generated test report database is checked with the selected test frame. If the test \nframe is not included in the database or this frame produced a ~alse test report, then the debugging \nmust go on inside the procedure. In the case of program Main; var isok: boolean; procedure test(rl, r2: \nintege~ var isok: boolean); begin isok:= rl = r2; end; procedure arrsum(a: intarray; n: intege~ var \nb: integer); var i: intege~ begin b:= @ for i:= 1 ton do b:= b + a[i]; end; procedure square(y: integer \nvar r2: integer); begin r2:= y*y; end; procedure comput2(y: intege~ var r2: integer); begin square(y, \nr2); end; procedure add(sl, s2: integeu var rl: integer); begin rl:= S1 + s2; end; function decrement(y: \ninteger): intege~ begin decrement:= y + 1; (*a planted bug, should be: y -1 *) end; function increment(y: \ninteger): intege~ begin incremenc= y + 1; end; procedure sum2(y: intege~ var s2: integer); var t:integeq \nbegin s2:= decrement(y) * y div 2; end; procedure suml (y: integer var S1: integer); var z: intege~ begin \ns1:= y * increment(y) div 2; end; procedure partialsums(y: intege~ var S1, s2: integer); begin suml(y, \ns1); sum2(y, s2); end; procedure computl(y: integeu var rl: integer); var sl, s2: intege~ begin partialsums(y, \ns1, s2); add(sl, s2, rl); end; procedure computs(y: integeq var rl, r2: integer); begin computl(y, rl); \ncomput2(y, r2); end; procedure sqrtest(ary: intarray; n: integeq var isok: boolean); var rl, r2,t: intege~ \nbegin arrsum(ary, n, t); computs(t,rl,r2); test(rl,ti,isok); end; begin (* Main *) sqrtest([l ,2], 2, \nisok); end. Figure 4: An example program which computes the square of the sum of the array [1 ,2] in \ntwo ways and checks t~the results from both computations are the same. good test repent the debugger \nskips this procedure. Of course the reliability of testing is largely dependent on the tester. Hence, \nif the bug is not localized with this com\u00ad bined method we must repeat the debugging without using the \ntest results.  5.3.3 Program Slicing The program slicing component of the system focuses the bug localization \nprocess by slicing out irrelevant portions of the execution tree. The slicing is activated due to an \nerror indication where the user has pointed out a certain variable whose value is in\u00adcorrect at a certain \nprogram point. The slicing subsystem computes a slice of the program with respect to the variable at \nthat point. This slice has a corresponding execution tree which is returned to the pure algorithmic debugging \ncompo\u00adnent for continuation of the debugging process. This is de\u00adscribed in more detail in later sections. \nAs an example, one could ask if a bug would be correct\u00adly localized if the bug is a misnamed variable \nin an argument of a procedure call which would cause a shouId-be relevant computation to be sliced out. \nThe answer is yes: if all sub\u00adcomputations of the calling procedure are correct, the bug will be correctly \nlocalized to the calling procedure. Howev\u00ader, if there is a bug in a sub-computation, this bug will be \nlo\u00adcalized first, and the misnamed variable bug will be localized when this bug has been corrected. 6. \nPreparing Programs for Standard Algorith\u00admic Debugging The purpose of this section is to discuss program \ntransforma\u00adtions in more details. We start by describing two different ap\u00adproaches to the transformation \nphase. Then, some examples of our approach are given. One approach to such transformations is to transform \nthe subject program which contains side-effects and loops into a completely functional form, free from \nside-effects and loops. This approach is discussed in [Shahmehri,Fritzson\u00ad89]. Similar transformations \nfor a very small language are formally treated in [Lisper-89]. Since such transformations cause an increase \nin the size of the transformed program, it is desirable to restrict the transformations. Thus, another \napproach is to perform trans\u00adformations only on the program constructs which conflict with the principles \nof algorithmic debugging. Our system follows the second approach. Here, we describe program constructs \nwhich violate principles of algorithmic debugging and are subject to trans\u00adformations. Then the transformations \nfor these constructs are discussed. Side-effect Freeness: The Algorithmic debugging meth\u00adod is based \non the procedure abstraction. This means that the debugging process and hence user interactions are per\u00adformed \nat the procedure level. Thus, we can relax the condi\u00adtion for side-effect freeness at the statement level, \nand im\u00adpose it only at the procedure level. In a program written in an imperative language the pres\u00adence \nof constructs which cause any of the following effects, are said to have global side-effects: . Global \nside-effects in the form of side-effects on variables not locally declared in the current proce\u00addure. \nSuch a side-effect may be caused by a refer\u00adence to or modification of a variable value. The ref\u00aderence/modification \nmay either be direct or indirect, i.e. through a pointer. This paper does not yet cover side-effects \ncaused by pointers, due to the complex nature of that problem. . GOTO-statements from a procedure to \na label de\u00adclared/defined outside this procedure. Such state\u00adments cause global side-effects in the form \nof global transfers of control. Here we refer to such goto\u00adstatements as global goto s. Loops inside \na procedure do not prohibit the algorithmic debugging process. However, crucial computations are often \nperformed inside loops, Thus, they deserve to be treated in a similar way as procedures, i.e. as units \nfor algorithmic debug\u00adging. A loop may be created explicitly by a language con\u00adstruct, e.g. a while-statement. \nA backward goto-statement may create an implicit loop. In addition to the above mentioned transformations, \nthe intermediate program is augmented with trace generating statements. The augmentation is very straightforward. \nExamvles of Pro~ram Transformations: The program transformations are guided by information from control \nand data flow analysis. The transformations here are twofold. The first kind are those transfomnations \nwhich eliminate global side-effects and global goto s. The second kind augments the intermediate program \nwith calls to procedures which gener\u00adate trace information during the tracing phase. Here we give an \nexample of different cases of program transformations. * Conversion of global variables to parameters. \nprocedure p (var y: . . . ) ; procedure p (var y: . . ; in x:.. .; Out z:...); begin begin y:= x -!-1; \ny:= x i-1; Z:=y x ~:=y-x end; end; o Breaking global gotos into several structured local gotos, procedure \np(...); procedure p(...); label, 9; label 9; vaz exitcond: integer; procedure q(...); procedure q(...; \nvar exitcond: . . ) ; label exitlab; begin (* q *) begin (* q *) exitcond:=O; ... ... goto 9 exi tcond: \n=1; goko exitlab; ... ... ... exitlab: . . . end; end; begin (* p *) begin (* p *) ... ... cl(. ..); \nq(...r exitcond) ; if exitcond=l then goto 9; ... ... 9: ... 9: ... end; end; Handling gotos inside \na loop addressed outside the loop, Here a simple while-statement is considered. If the label 9 k declared \noutside the procedure surrounding the while-statement, then the new global goto is handled by a later \ntransformation. The transformed program will contain declarations for the label w zilelab and for the \nvariable leave. These declarations are not shown here. while B do begin while B and not leave do begin \n... ... goto 9; leave:= true; goto whilelab; ... ... whilelab: end; end: if leave then goto 9; Generating \ntrace generating actions (functions) forpro\u00adcedures and loops,l%is is shown for the procedure p be\u00adlow: \nprocadurep (vary: . . ..inx. . . ..outz. . ..). begin create exectree ret; save_iEcoming_values (x,y) \n; y:= x+1; z:= y-x; save_outgoing_values (y, z) ; end;   6.1 TransparentDebugging Relativetothe Original \nProgram Despite the fact that the program is transformed into an inter\u00adnal form, the debugger still presents \nthe original program when interacting withtheuser.This is important-otherwise it would be too hard for \nthe user to answer questions from the algorithmic debugger. For example, a typical question regarding \na procedure call could be: Is this call correct for these input parameters and input values on these \nglobal variables, and these values on output parameters and free global variables? Regarding loops: thedebugger \npresentstheoriginal looptotheuserand asks irrelevant iteration variables are correct foriteration 1, \niteration2etc. Likewise, forprogramsthat containgotosand have been transformed to goto-less form: this \ntransformation does not influence the procedure call structure and execution tree, and thus, creates \nno problems during algorithmic de\u00adbugging, Non-local gotosare represented as integer values on special \nadded return parameters, together with a local goto. A question to the user in this case will be: Given \nthese values on input parameters and free variables, is it correct to perform this non-local goto? Thus \nthe non-local goto is treat\u00aded as one of the results from the procedure call. 7. Program Slicing in Algorithmic \nDebugging ~he reason for activating the slicing component of the sys\u00adtem is that sometimes the algorithmic \ndebugger asks ques\u00adtions about procedures which do not have any relevance to the computation of the incorrect \nvariable value. Consider the following example in Figure 5 and the corresponding execu\u00adtion tree in Figure \n6, wherepl, p2,,.., pn are procedure calls, procedure p(...); ... begin pl (...); p2 (...); pn-l (...); \npn(x, y); ... end; Figure 5. A program jkagment to compute the value of the variable y, Assume that \nprocedure pn with variable x as input pa\u00ad rameter and variable y as output parameter computes the val\u00ad \nue of variable y using the value of variable x. Also assume that the value of variable x is independent \nof procedure calls pl to pn-1. The execution results in an incorrect value for the variable y, compared \nto the user expectation. Procedures pl, p2,..., pn-1 which execute before pn are not involved with the \ncomputation of y, but still the algorithmic debugger asks about the behavior of all of them. Here, we \nconsider the top\u00addown traversal of the execution tree, Figure 6. However, generally it doesn t matter \nwhich traversal method is used because the debugger has no knowledge about which proce\u00addures are relevant \nor irrelevant for the computation of a spe\u00adcific value. P( ...) Pl (...) P2 (...) . . . Pn (...) Figure \n6. Execution tree of the program in Figure 5. In such cases program slicing will remove irrelevant procedures \nand procedure calls while preserving the same er\u00adroneous behavior. While slicing gives a minimal form \nof a program, algo\u00adrithmic debugging gives guidance to the user during bug lo\u00adcalization. In our debugging \nsystem, the pure algorithmic debug\u00adging starts to work on the entire program and interacts with the user \nin order to locate a bug. As soon as the user can point out a variable, say x, whose value is incorrect \nwithin a proce\u00addure, say p, then slicing can compute a slice of the program Main I  sqrtest(In [1,2], \nIn 2, Out false) arrsum(In [1,2], In 2, Out 3) computs(In 3, Out 12, Out 9) test(In 12, In 9, Out false) \ncompute 1(In 3, Out 12) compute2(In 3, Out 9) ~~ partialsums(In 3, Out 6, Out 6) add(In 6, In 6, Out \n12) square(In 3, Out 9) /~ suml(In 3, Out 6) sum2(In 3, Out 6) II increment(In 3)=4 decrement(In 3)=4 \nFigure 7: The execution tree of the program from Figure 4. with respect to the variable x in procedure \np. The algorithmic debugging process continues from procedure p on the slice, rather than on the entire \nprogram, Later, whenever the user can indicate a new variable which has an incorrect value, slicing can \nagain compute a slice on that variable, and the de\u00adbugger can continue the bug localization process on \na small\u00ader and smaller set of procedures. In the following section, we explain the steps the debug\u00adging \nphase goes through for a given example. Interactions with the user are also presented. 8. An example \nof applying GADT, including slicing As an example of generalized algorithmic debugging and testing, consider \nthe program in Figure 4 which computes the square of the sum of the integer array [1, 21, i.e. the value \n3, in two ways and then checks if the results from both compu\u00adtations are the same. One way is by multiplication, \n3*3=9. The other is by summation, 1+2+3+2+1=9. The latter ex\u00adpression is split into two partial sums, \n1+2+3 and 1+2. Then the formula for the sum of 1 through n, n*(n+l)/2, is used for each sum. We introduce \na bug into the program by writing y+l in\u00adstead of y-1 in the function decrement. The result from the \nmultiplication way of computing is 3*3=9 but the summa\u00adtion way of computing produces 12 (from 6+6) instead \nof 9 (from 6+3) and the entire program results in a false value from the Boolean expression 12=9. Figure \n4 shows the sub\u00adject program. Step I. Pure algorithmic debugging and Testing: The debugging process starts \nat the root of the execution tree of the entire program (we use top-down search in this example), see \nFigure 7. >no computs(In y: 3, Out rl: 12, Out r2: 9)? >no, error on first output variable Presuming \nthat we have a test specification, a test report database and an automatic test frame selector function \nfor the procedure arrsum (see section 5.3.2), GADT was able to check this procedure call without any \nuser interactions. Thus, the query arrsum(In a: [1, 2], In n: 2, Out b: 3)? was never shown to the user. \nStep 2. Slicing: The slicing subsystem produces a slice of the program with respect to the first output \nvariable in the procedure computs. The corresponding execution tree from this slice contains fewer procedures, \nand from procedure computs downward, only the left subtree is retained from the previous execution tree \nas is shown in Figure 8. This pruned execution tree is returned to the pure algorithmic debugger. computs(In \n3, Out 12, Out 9) computel (In 3, Out 12) partialsums(In 3, Out 6, Out 6) add(In 6, In 6, Out 12) / \n-----\u00ad suml(In 3, Out 6) sum2(In 3, Out 6) II increment(In 3)=4 decrement(In 3)=4 Figure8:Partso~heexecutiontreefiomtheprograwlicedonce. \nStep 3. Pure algorithmic debugging: Algorithmic de\u00adbugging continues from procedure computs in the execution \ntree of Figure 7 and interacts with the usec sqrtest(In ary: [1,2], In n: 2, Out isok: false)? computl(In \ny: 3, Out rl: 12)? 324 >no partialsums(In y: 3, Out S1:6, Out s2: 6)? >no, error on second output variable \nStep 4. Slicing: The slicing subsystem again computes a slice of the program with respect to the second \noutput vari\u00adable in procedure partialsums. The corresponding execution tree of this slice will be much \nsmaller. From procedure par\u00adtialsums downward, this slice contains only the right subtree from the previous \nexecution tree, see Figure 9. This subtree is returned to the pure algorithmic debugger. partialsums(In \n3, Out 6, Out 6) sum2(In 3, Out 6) I decrement(In 3)=4 Figure 9: Parts of the execution treefiom the \nprogram sliced twice. Step 5. Pure algorithmic debugging: The algorithmic debugger traverses the execution \ntree, from procedure par\u00adtialsums and downward. and interacts with the use~ sum2(In y: 3, Out s2: 6) \n>no decrement(In y: 3)= 4? >no An error is localized inside the body of function decrement. There is \nno procedure call left in this path, thus, a bug has to be in the body of function decrement. ~e uiou \ndecrement(y: integer): intege~ decrement:= y + 1; (*a planted bug, should be: y -1 *) end; The above \nexample shows how GADT localizes the cause of incorrect behavior of a program, Thus, this hybrid debugger \ncan help the user localize the bug through a greatly reduced number of interactions, compared to pure \nalgorithmic debug\u00adging. 9. State of the Current Implementation Our implementation of an algorithmic debugger \nfor impera\u00adtive languages consists of three phases: a program transfor\u00admation phase, a tracing phase \nwhere the execution tree is built, and a debugging phase which interacts with the human user. Regarding \nthe transformation phase, all intended trans\u00adformations which consist of augmentation of parameter lists, \nbreaking global gotos into several structured local gotos and generating trace generating actions for \ndebugging units have been implemented. Small procedures usually grow less than a factor of two after \ntransformations. The system maintains both the original and the transformed code for each trans\u00adformed \nconstruct, in order to present a transparent view to the user. The tracing phase which builds an execution \ntree is fully implemented. The size of the execution tree depends on the number of nodes created during \nexecution and the size of each node. This is strongly application dependent, Each node contains parameter \nvalues in variable length string form. The debugging phase searches the execution tree and asks questions \nof the human user. The pure algorithmic de\u00adbugging subsystem is completely implemented for the han\u00addling \nof yes/no answers. For handling of answers which are assertions, we are going to use the incremental \ncompilation facilities of the DICE system [Fritzson-83] to provide an ef\u00adficient way of evaluating assertions \nduring the search. A dy\u00adnamic variant of inter-procedural program slicing is under implementation [Kamkar-9 \nlb]. Program flow analysis which is the basis for both the transformations and program slicing is implemented. \nWe are currently integrating this into our debugging system. The debugging system has so far been used \nto debug small Pascal programs which do not exceed four pages. We intend to test it on larger programs \nsoon. The T-GEN test case generator is completely imple\u00admented. Several large application programs in \ndifferent pro\u00adgramming languages have been tested by using this system. A prototype for integrating the \nalgorithmic debugging, the program slicing and the category test partitioning is under development. 10. \nReferences [13anning-78] J.P. Banning: A Methodfor Determining the Side Effects of Procedure Calls. Ph.D. \nThesis. Stanford University 1978. [J3anning-79] J.P. Banning: An Efficient Way to Find the Side-Effects \nof Procedure Calls and the Aliases of Variables. Conf. Record of the Sixth Annual ACM SIGPLAN/SIGSOFT \nSymposium on POPL. Pages 29\u00ad41, January 1979. [Drabent, et al-88] W. Drabent, S. Nadjm-Tehrani and J. \nMaluszynski: The Use of Assertions in Algorithmic De\u00adbugging. Proceeding of the FGCS conference, Tokyo, \npages 573-581, 1988. [Ducass6, Erode-87] M. Ducass6 and A. M. Erode: State of ihe Art in Automated Program \nDebugging. TR-LP-25, European Computer-Industry, Research Center GmbH, West Germany, September 1987. \n [Fritzson-83] P. Fritzson: Symbolic Debugging Through In\u00adcremental Compilation in an Integrated Environment. \nThe Journal of Systems and Software 3, pages 285-294, 1983. [Horwitz, et al-88] Susan Horwitz, Thomas \nReps and David Binkley: Interprocedural Slicing using Dependence Graphs. ACM Transactions on Programming \nLan\u00adguages and Systems, Vol. 12, No. 1, pages 26-61, Jan\u00aduary 1990. [Kamkar, et al-90] M. Kamkar, N. \nShahmehri, P. Fritzson: Bug Localization by Algorithmic Debugging and Pro\u00adgram Slicing. In Proc. of the \nInt. Conf. on Program\u00adming Language Implementation and Logic Programming, Aug 1990, LNCS 456, Springer-Verlag \n1990. [Kamkar-91a] M. Kamkar: An Overview of Static and Dy\u00adnamic Slicing. Research Report, Department \nof Com\u00adputer and Information Science, Linkoping University, Sweden, 1991. [Kamkar-91b] M. Karnkar: Interprocedural \nDynamic Slic\u00ading. Research Report, Department of Computer and In\u00adformation Science, Linkoping University, \nSweden, 1991. [Lisper-89] Bjorn Lisper: Single-Assignment Semantics for Imperative Programs. Lecture \nNotes in Computer Sci\u00adence, No. 366, PARLE 89, Vol. II, pages 321-334. [Lyle,Weiser-87] James R. Lyle, \nMark Weise~ Automatic Program Bug Location by Program Slicing. In 2:nd IEEE Symposium on Computers and \nApplications, Pe\u00adking, pages 877-883, June 1987. [Ostrand, Balcer-88] Thomas J. Ostrand, Marc J. Balcer: \nThe Category-Partition Methodfor Specfying and Gener\u00adating Functional Tests. CACM 31:6, June 1988, [Seviora-87] \nRudolph E. Seviora: Knowledge-Based Pro\u00adgram Debugging Systems. IEEE Software, Vol. 4 No. 3, May 1987. \n[Shahmehri, Fritzson-89] Nahid Shahmehri and Peter Fritz\u00adsorc Algorithmic Debugging for Imperative Languages \nwith Side-eflects. LiTH-IDA-R-89-49, Department of Computer and Information Science, Linkbping Univer\u00adsity, \nSweden, November 1989. [Shahmehri, et al-90] N. Shahmehri, M. Karnkar and P. Fritzson: Semi-automatic \nBug Localization in Software Maintenance. Proc. of IEEE Conf. on Soft. Mainte\u00adnance. San Diego, Nov 26-29,1990. \n[Shahmehri-91] N. Shahmehri: GeneralizedAlgorithmic De\u00adbugging. (provisional title). PhD thesis in preparation. \nDepartment of Computer and Information Science, Linkoping University, Sweden, 1991. [Shapiro-83] E. Y. \nShapiro: Algorithmic Program Debug\u00adging. MIT press. 1983. [Szucs, Gyimothy-90] R. Szucs and T. Gyimothy: \nT-GEN test case generator. User s Guide. Cogito Ltd. Szeged, Hungary. [Toczki, et al-90] J. Toczki, F.Kocsis,T.Gyimothy, \nG.Danyi and G. Kokai: SYS13 -a Software Development Tool. Proc. of CC 90. Schwerin, Germany, October \n1990. Pages 299-313. Part of this proceedings will appear in the LNCS series by Springer-Verlag during \n1991. [Weiser-84] Mark Weisex Program Slicing. IEEE Transac\u00adtions on Software Engineering, Vol. Se-10, \nNo. 4, pag\u00ades 352-357, July 1984.  \n\t\t\t", "proc_id": "113445", "abstract": "", "authors": [{"name": "Peter Fritzson", "author_profile_id": "81100533236", "affiliation": "Department of Computer and Information Science, Link&#246;ping University, S-581 83 Link&#246;ping, Sweden", "person_id": "PP14185011", "email_address": "", "orcid_id": ""}, {"name": "Tibor Gyimothy", "author_profile_id": "81100634456", "affiliation": "Research Group on the Theory of Automata, Hungarian Academy of Sciences, H-6720 Szeged, Aradi vertanuk tere 1, Hungary", "person_id": "PP39051737", "email_address": "", "orcid_id": ""}, {"name": "Mariam Kamkar", "author_profile_id": "81100619951", "affiliation": "Department of Computer and Information Science, Link&#246;ping University, S-581 83 Link&#246;ping, Sweden", "person_id": "P188956", "email_address": "", "orcid_id": ""}, {"name": "Nahid Shahmehri", "author_profile_id": "81100181796", "affiliation": "Department of Computer and Information Science, Link&#246;ping University, S-581 83 Link&#246;ping, Sweden", "person_id": "PP15025010", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/113445.113472", "year": "1991", "article_id": "113472", "conference": "PLDI", "title": "Generalized algorithmic debugging and testing", "url": "http://dl.acm.org/citation.cfm?id=113472"}