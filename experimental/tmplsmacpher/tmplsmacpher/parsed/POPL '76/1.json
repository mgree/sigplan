{"article_publication_date": "01-01-1976", "fulltext": "\n A Complexity Theory of Grammar Problems + H. B. Hunt, III Aiken Computation Laboratory Harvard University \nCambridge, Massachusetts 02138 i. Introduction The close relationship between programming language \nsyntax, context-free grammars (abbreviated cfgs), parsing, and compiling is well-known and is extensively \ndiscussed in [i]. Unfortunately, many of the problems about programming languages, one might wish to \n solve, are equivalent to undecidable grammar problems. Two especially important such problems are (I) \nthe emptiness of intersection problem, i.e. determining if the intersection of the languages generated \nby a pair of grammars is empty, and (2) the grammar class membership problem, i.e. determining for \na fixed class of grammars F and a grammar G, if G is an element of F. Here, we investigate two recently \nproposed ideas for circumventing the undecidability of such problems. The separability concept was introduced \nin [2] in an attempt to ameliorate the undecidability of such problems as the emptiness of intersection \nproblem. Intuitively, the idea of separability fs to replace arbitrary context-free languages (cfls) \nby approximating languages for which such problems are decidable. The inherent limitations of the separability \nconcept are discussed. We show that for many different families of separating languages F, it is \"undecidable \nif some language in F separates the languages generated by two arbitrary cfgs. We also show that there \nare fixed cfls L o such that for any family of languages F containing Lo, it is undecidable if some language \nin F separates the languages generated by two arbitrary cfgs. These cfls include {w#w rev I w~{0,1}*}, \n{ww rev w({0,1}*}, and all Dyck languages over two or more letters. The decidability of a variety of \nproblems related to problem (2) above is considered. We show that for many classes F of cfgs and many \nbinary relations p on the cfgs, all predicates of the form, \"for an arbitrary cfg G, GpH for some H in \nr\", are undecidable. Thus for example, letting r denote the class of strong LL, LL, strong LC, LC, SLR, \nLALR, LR, LR regular, or unambiguous cfgs, it is undecidable if an arbitrary cfg is, is equivalent to, \nis structurally equivalent to, is covered by, or covers, an element of F. The problem of deciding for \na class ~ of cfgs, a class T of grammatical transformations, and an arbitrary cfg G, if some transformation \nt in T maps G to an element of 4, is also considered. Thus for example, if each t in T is language preserving, \ni.e. for all cfgs G, L(t(G)) = L(G), and the identity transformation is in T, then for an arbitrary cfg \nG, it is undecidable if there exists t in T such that t(G) is a strong LL, LL, strong LC, LC~ SLR, LALR, \nLR, LR regular, or unambiguous cfg. Our results apply to many classes of transformations that do not \ncontain the identity transformation as well. We list several definitions and observations used in the \nremainder of this paper. We assume that the reader is familiar with the basic definitions of and results \nconcerning cfgs, cfls, the strong LL, SLR, and BRC grammars, Turing machines (Tms), and Turing machine \ncomputations, otherwise see [i] or [3]. Definition I.I: A language L over a finite alphabet Z is said \nto be (i) a definite event ~andonly~ L=A'Z*UB, where A,B_cZ* are---f~ite sets; and is said to be This \nresearch was supported in part by U.S. Army Contract No. DA-31-124-ARO-D-462 and by NSF Grant No. DCR75-22505. \n (ii) a reverse definite event if and only if L=~,--Where A, _~ are finite sets. We note that all definite \nand reverse definite events are regular sets. Moreover, the classes of definite and reverse definite \nevents are closed under complementation. The next two definitions formalize the separability concept. \n Definition 1.2: Let Ll, L2, and S be languages over a finite alphabet Z. We sa that S se arates L and \nL or Y _. P . i tea' S equivalentlyL 1 and L 2 are separa b~ if and only if- LiJS and L2nS=~, ~ or LinS=~ \nand L2~. Definition 1.3: Let F be any family of languages. Two languages L 1 and L 2 are said to be \n (i) F separable if and only if there exists a language SEF such that S separates L 1 and L2; and are \nsaid to be (ii) F H-separable if and only if there exist two disjoint languages S 1 and S2EF such that \nLi~S 1 and L2~S 2. Clearly if two languages are F H-separable, then they are F separable. However, F \nseparability does not in general imply F H-separability. If F is closed under complementation, then F \nseparability and F H-separability are the same. Thus if F is the class of definite or reverse definite \nevents over some finite alphabet Z, then two languages L 1 and L 2 are F separable if and only if they \nare F H-separable. 2. The Basic Construction In this section the basic technical construction needed \nto develop our complexity theory of grammar problems is presented. Unlike previous work, we do not prove \nthe undecidability of a problem by effectively reducing the halting problem for Tms, or some equivalent \nproblem, to N. Rather, we prove the undecidability of ~ by efficiently reducing the membership problem \nfor Turing machines that always halt to it. This shows that N is of nonrecursive computational complexity. \nFor the problems considered here, this suffices to show that they are undecidable. Let M be any deterministic \nTm, with tape alphabet T and state set S, that always halts on the right end of its tape. Then M is \nO(T(n)) time-bounded for some strictly inreasing recursive function T(n). Given an input string x to \nM, two cfgs Gi[M,x] and G2[M,x] can be constructed in linear time on a deterministic multi-tape Tm such \nthat L(Gi[M,x])=#'{Y\" #'zrev'# I Y, z are i.a.'s of H and y~ z}*'$, and L(G2[M,x])=#'x]. {#.yrev.#.y \nI Y is an i.d. of H}* -i#'zr.# [ z is an accepting  i.d. of M}.$, where x I is an initial  i.d. of \nH on x.  Let Z=TU(SxT)U{#,$}. We assume that T, (SxT), and {#,$} are mutually disjoint. For sufficiently \nfast strictly increasing functions r(n), no pair of words in L(Gi[M,x]) and L(G2[M,x]) hays common prefixes \nof length ~c'[T(Ixl)] z for some positive integer c depending only upon H not x. Horeover, Gi[U,x] and \nG2[M,x ] are strong LL, SLR, and BRC grammars. Proposition 2.1: Let H, T(n), c, Z, and x be -as described \nabove. Let F be any class of languages over Z containing all definite 2events over Z. Let k=c'[T(lxl)] \n. Then in time ~Cl. lX[, cfgs ~, G 2, and G 3 each of size ~c 2 + Ixl, where c 1 and c 2 are constants \ndepending only upon H not x, can be constructed by a deterministic multi-tape Tm such that the following \nare equivalent: (1) M accepts x; (2) L(Gi! N L(G2) ~ ;  (3) L(Gi) and L(G2) are not definite event separable; \n (4) L(Gi) and L(G2) are not F separable;  (5) L(G 1) and L(G2) are not F H:separable; (6) G 3 is \nambiguous; (7) Gx is inherently ambiguous; (8) G~ is not a strong LL(k) grammar; (9) G 3 is not an \nSLR(k) grammar; and (10) G 3 is not a BRC(k,k) grammar.  Proof: G 1 and G 2 are equal tO.Gl[H,x] and \n~,x] respectively. G 3 is the cfg whose productions consist of (a) all productions of G] and G2;  (b) \nS~ASi$S 3 I B\u00a2$25S4, Where S 1 and S 2 are the start symbols of G 1 and G2, respectively;  (c) A~\u00a2\u00a2; \n (d) B ~\u00a2; (e) S 3 ~ aTbcU; (f) T~aTblab; (g) U~cU[c; (h) S4~aVbWc ; (i) V~aV I a; and (j) w~ bWc \nI bc.  We assume that {S,A,S3,B,S4,T,U,V,W} is disjoint from the union of the nonterminal alphabets \nof G 1 and G 2. ~H-separability f s named after Hausdorf separability in topology.  If M accepts x \nthen there exists a string w E L(G) n L(G2). Thus L(G I) and L(G2) are not F or F H-separable for any \nfamily of languages F. Moreover, L(G3)N\u00a2\u00a2'w'$'Z, = \u00a2\u00a2'w'$\" {anbncmln,m~2}u{anbmcmln,m~2}].  Since \nthe unambiguous cfls are closed under intersection with regular sets and L(G3)N\u00a2'\u00a2'w'$.Z* is an inherently \nambiguous cfl, G 3 is an inherently ambiguous cfg. Hence afortiori, G 3 is ambiguous and is not a strong \nLL(g), SLR(~), or BRC(g,~) grammar for any choice of g and ~. If M does not accept x, then L(Gi) n L(G2) \n[~G and no pair of words in E(G I) ano 2) have a common prefix of size k. Thus L(Gi) and L(G2) are definite \nevent separable, F separable, and F H-separable. Moreover by inspection of the productions of G3, G~ \nis a strong LL(k), an SLR(k), and a BRC(k,k) grammar. In Sections 3 and 4, Proposition 2.1 is used to \nderive most of our grammar complexity results. More details of the constructions of the cfgs Gi, G2, \nand G 3 can be found in [4]. Finally, our undecidability proofs make use of the following two properties \nof recursive sets and Tms that always halt. Property 2.2: Every deterministic Tm that always halts makes \n~ T(n) moves for some strictly increasing recursive function T(n) and for all inputs of size n. Property \n2.3 For all recursive functions f, there is a recursive set Sf such that any Tm that recognizes Sf requires \ntime > f(n) for infinitely many n. A proof of Property 2.3 can be found in [5] . 3. Separability Separability \nwas introduced in [2] in an attempt to ameliorate the undecidability of such problems as the emptiness \nof intersection problem. The idea of separability is to approximate arbitrary cfls by languages for which \nsuch problems are decidable. Here the limitations of the separability concept are considered. We consider \nthe question - \"For what families F of languages is it decidable if an arbitrary pazr of cfls are F \nor F H-separable?\" --We show that this question is undecidable for many, if not most, interesting families \nof languages F. One obvious candidate for such an F is the family of regular sets. Definition 3.112]: \nTwo languages L1 and L~---~--'sa~-.... to be regular separable if t~ere exzst dlsjoxnt regular ~ets R \n1 and R2 such that LljRi and L2~R2. ~\" Results in [2] and [8] show that regular separability is undecidable \nfor the cfls. Another obvious candidate for F is the family of cfls. But letting F equal the cfls, two \ncfls L 1 and L 2 are F or F H-separable if and only if LinL 2 = ~.- Thus again F and F H-separability \nare undecidable. We show that both the undecidability of regular separability and the undecidability \nof emptiness of intersection of the cfls follow from a general separability undecidability theorem, Theorem \n3.2 below. Theorem 3.2: Let Z be any finite alphabet o~di~lity greater than one. Let F be any family \nof languages that contains all definite or reverse definite events over z. Then it is undecidable if \nthe languages generated by two arbitrary cfgs with terminal alphabets equal to Z are (i) F separable, \nor (ii) F H-separable. Proof: We only prove the theorem for the case,^when F contains all definite events \nover Z. The proof for the case, when F contains all reverse definite events over Z, is similar and is \nleft to the reader. The proof consists in showing that the decidability of F (or F H-separability), for \nany F containing all definite events over Z, contradicts Property 2.3. Suppose for some such P that \nF (or F H-)separability is decidable for the cfgs. Then since the set of cfgs with terminal alphabets \nequal to Z is a recursive set, by Proposition 2.2 there exists a strictly increasing recursive function \nf(n) that bounds the time required to decide P (or P H-separability) on a deterministic Tm. Let M be \nany O(T(n)) time-bounded deterministic Tm with T(n) a strictly increasing recursive function. We claim \nthat L(M) is recognizable by a cn + f(cn) time-bounded deterministic Tm~l, where c is a constant depending \nonly upon ~. Intuitively given input x to ~f, we would like dl to construct the cfgs G] = Gi[M,x] and \nG 2 = Gv [M,x] of Proposition 271 and then to ~est if L(G l) and L(G2) are F (or F H-)separable. ~owever, \nG 1 and G 2 of Proposition 2.1 can not be used directly because their terminal alphabets need not equal \nz. A straight-forward encoding can be used to construct cfgs G I and G 2 with terminal alphabets equal \nto Z such that the time and space required for their construction is still linear in Ix I and such that \nconclusions (i) through (~) of Proposition 2.1 hold with fi I and G 2 substituted for G 1 and G2, respectively. \n I. In our terminology, two languages are regular separable if and only if they are F H-separable, with \nF equal to the family of regular sets. 14 The Tm~operates as follows. $. Given input x, ~ constructs \nGI and G 2 2. df tests if L(Gi) and L(G 2) are F (or F H-)separable. If so~4frejects x. If not~accepts \nx. Step i requires at most cn time and step 2 requires at most f(cn) time, for some constant c depending \nonly upon M^ not x o~ n = Ixl. If x ~ L(H), then L(G I) and L(G2) are definite event, F, and F H-separable. \nThus Jfrejects x. If x EL(M), then L(Gi)NL(G2) ~ \u00a2, and L(Gi) and L(G2) are not F or F H-separable for \nany family of languages F. Thus~accepts x. Finally for all positive integers ~, the recursive function \nF(n) = n~ + f(n ~) is strictly greater than an + f(an), for all but finitely many values of n. Thus if \nF (or F H-)separability is decidable for the cfgs, the every recursive set is accepted by some Tm that \nis F(n) time-bounded, for all but finitely many values of n. This contradicts Proposition 2.3 Theorem \n3.2 shows how little is required for the undecidability of F or F H-separability. The following corollary \nillustrates its power and applicability. Theorem 3.3: Let Z be any finite alphabet oZf---~di~lity greater \nthan one. The following classes F of languages over Z satisfy the conditions of Theorem 3.2: (i) definite \nevents;  (2) reverse definite events;  (3) noncounting events;  (4) regular sets;  (5) for all k~l, \nthe LL(k) languages;  (6) LL languages;  (7) deterministic cfls;  (8) unambiguous cfls;  (9) cfls; \n(i0) linear cfls;  (ii) context sensitive languages; and  (12) recursively enumerable sets.  Thus \nletting F denote any of the above classes of cfls, it is undecidable if the languages generated by two \narbitrary cfgs with terminal alphabet equal to Z are F or F H-separable. Theorem 3.3 follows immediately \nfrom Theorem 3.2 and known properties of language classes (i) through (12). (Definitions of these language \nclasses can be found in [9](1-3), [i](4-i0), and [3](11-12).) A slight modification of the proofs of \nProposition 2.1 and Theorem 3.2 shows that the F and F H-separability problems for the cfgs are also \nundecidable for F equal to the s-languages in [i0], the strict and real-time strict deterministic languages \nin [ii], and the LR(0) languages ^defined in [i]. Finally since the cfgs Gland G 2 in the proof of Theorem \n3.2 are strong LL, SLR, and BRC grammars, many of the conclusions of Theorem 3.2 hold for any class of \ngrammars containing the intersection of these three grammar classes. Thus for example letting F denote \nthe definite events, noncounting events or the regular sets, it is undecidable if the languages generated \nby two arbitrary strong LL, SLR, LALR, LR, or BRC grammars are F or F H-separable. We have already shown \nthat the F and F H-separability problems for the cfgs are undecidable for all families of languages \nthat contain sufficiently many regular sets. Next a second sufficient condition on a family of languages \nF for the undecidability of F separability is presented. We show that there are fixed cfls L o such \nthat any family of languages F containing Lo, it is undecidable if some language in F separates two \n arbitrary cfls. Before presenting this result, we need several definitions from [12]. Definition 3.4: \n(i) C is the class of all cfls L o foT-~hich it is decidable if the language generated by an arbitrary \ncfg is a subset of L o. (ii) I is the class of all cfls L o for which-it is decidable if the intersection \nof the language generated by an arbitrary cfg G and L o is empty. Definition 3.5: A cfl L is said to \nbe forbidden -iT for all families of languages F such that LEF, it is undecidable if the languages generated \nby an arbitrary pair of cfgs are F separable. Definition 3.6: Let L be a cfl. Let z be the smalles~ \nfinite alphabet such that Lcz* Then T = E*-L. Theorem 3,7: There exist forbidden cfls. p-~ti~lar if \na cfl L is not an element of I, then L is forbidden. Similarly if both L and L are cfls, and L is \nnot an element of C, then L is forbidden. Proof: A proof that there exist cfls that are not elements \nof I can be found in [12]. We only show that if a cfl L is not an element of I, then L is forbidden. \n Let LfI. Let F be any family of languages containing L. Since L is a cfl, there exists a fixed cfg \nG O such that L=L(Go). For an arbitrary cfg G, L(G) and L=L(G n) are F separable if and only if L(G)nL=~. \nThus since LtI, F separability is undecidable. In [12] we show that {wwreVlwE{0,1}*}, {w#wreVlwE{0,1}*} \n, and all Dyck languages over two or more letters are forbidden. The language {w#wreVlwE{0,1}*} is especially \ninteresting because it is a non-regular  s-language. Theorem 3.7 and results in [12] can be used to \nshow that F separability is undecidable for a variety of families F of languages that do not contain \nthe definite or reverse define events, e.g. the parenthesis languages [13], the Dyck languages, the \nnon-regular s-languages, etc. 4. Complexity of Relations Recently in [4], [14], and [15] a complexity \ntheory for certain types of grammar problems was presented, these problems dealt primarily with the complexity \nof grammar class membership problems. Here, these results are extended to a variety of other types of \ngrammar problems. We show that for many grammar classes F, and for many binary relations p on the cfgs, \nall predicates of the form, \"For an arbitrary cfg G, there exists a cfg H in F such that GpH.\" are undecidable. \nThus for example, it is undecidable if an arbitrary cfg G is, is equivalent to, is structurally equivalent \nto, or is covered by, a strong LL, LL, strong LC, LC, SLR, LALR, or LR grammar. In what follows Z is \nany arbitrary finite alphabet of cardinality greater than one; and ~ equals the intersection of the classes \nof strong LL, SLR, and BRC grammars with terminal alphabets equal to Theorem 4.1: Let p be any binary \nrelation on the cfgs such that (i) for all G in ~, GpH for some H in ~, and  (ii) for all inherently \nambiguous cfgs G, GpH implies that H is inherently ambiguous. Let F be any class of cfgs such that  \n (iii) ~ oF; and (iv) F ~ontains no inherently ambiguous cfgs. Then for arbitrary^cfg G with terminal \n alphabet equal to Z, it is undecidable if there exists a cfg H in F for which GpH. Proof: The proof \nclosely follows that of Th~em 3.2. Let ~ denote the predicate, \"For an arbitrary ^cfg G with terminal \n alphabet equal to Z, there exists a cfg H in F for which GpN. ~. Suppose for some relation p, satisfying \nconditions (i) and (ii), and for some grammar class F, satisfying conditions (iii) and (iv), that \nthe predicate ~ is decidable. Then by Proposition 2.2 there exists a strictly increasing recursive \nfunction f(n) that bounds the time required to decide ~gon a deterministic Tm. Let H be any O(T(n)) \ntime-bounded deterministic Tm with T(n) a strictly increasing recursive function. ~e claim that L(M) \nis recognizable by a cn+f(cn) time-bounded deterministic Tm,/f 4 where c is a constant depending only \nupon ~. Intuitively given input x to .~4~, we would like ~g to construct the cfg G 3 of Proposition \n2.1 and then to test if there exists a cfg H in r for which G3pH. However, G 3 of Proposition 2.1 cannot \nbe used directly because its terminal alphabet need not equal z. A straight-forward^ encoding can be \nused to construct a^cfg G 3 with terminal alphabet equal to Z such that^the time and space required to \nconstruct G 3 is still linear in Ixl and such that conclusions (6) ~hrough (I0) of Proposition 2.1 hold \nfor G 3 substituted for G 3. The Tm~/Afoperates as follows.  I. Given input x, df constructs G3\" 2. \nif tests if there exists a cfg H in r for which G3PH. If sod4rejects x. If not~/gaccepts x. Step 1 requires \nat most cn time and step 2 requires at most f(cn) time, for some constant c depending only upon M not \nx or n=Ix I. If xfL(M), then G 3 is an element of ~ and by (i) and (iii) there exists a cfg H in F for \nwhich G3~H. Thus~rejects x. If x~L(H), then L(G3) is inherently ambiguous and by (ii) and (iv) there \ndoes not exist a cfg H in F for which G3PH. Thus,~'accepts x. Finally for all positive i~tegeEs c, the \nrecursive function F(n)=n~+f(n ~) is strictly greater than cn+f(cn), for all but finitely many values \nof n. Thus if~ is decidable for the cfgs, then every recursive set is accepted by some Tm that is F(n) \ntime-bounded, for all but finitely many values of n. This contradicts Proposition 2.3. The meaning, \npower, and applicability of Theorem 4.1 are best illustrated by examples. Theorem 4.2: Let p be any reflexive \nbinary relation on the cfgs such that for all cfgs G, H, GpH implies L(G)=L(H). Let F be any class of \ncfgs such that (i) ~cF; and (ii) T contains no cfgs. inh ere ntly ambiguous Then for arbitrary^cfg G \nwith terminal alphabet equal to ~, it is undecidable if there exists a cfg H in F for which GpH. Proof: \nThe relation p satisfies con~tions (i) and (ii) of Theorem 4.2. Theorem 4.3: Let F be any class of cfgs \nsuck that (i) ~cr; and  (ii) Y contains no inherently ambiguous cfgs.  Then for an arbitrary cfg \nG with terminal alphabet equal to Z, it is undecidable if G is, is equivalent to, is structurally equivalent \nto, covers, or is covered by, an element of r. Proof: The definitions of structural equivalence and \n(grammatical) covering can be found in [i]. Let p be any of the following binary relations on the cfgs: \n (i) GpH if and only if G=H;  (2) GpH if and only if L(G)=L(H);  (3) GpH if and only if G is structurally \nequivalent to H;  (4) GpH if and only if G covers H; and  (5) GpH if and only if G is covered by H. \n  Then p is reflexive and GpH implies L(G)=L(H). Thus each such relation p satisfies the conditions \nof Theorem 4.2, and Theorem 4.3 follows directly. Corollary 4.4: Let F be any of the following grammar \nclasses: (i) BRC grammars;  (2) strong LL grammars;  (3) LL grammars;  (4) strong LC grammars;  \n(5) LC grammars;  (6) ELC grammars;  (7) SLR grammars;  (8) LALR grammars;  (9) LR grammars; (i0) \nLR regular grammars;  (II) unambiguous grammars;  (12) basic SPM parsable grammars;  (13) full SPM \nparsable grammars;  (14) FSPA grammars; and  (15) RPP grammars.   Then for an arbitrary cfg G with \nterminal alphabet equal to Z, it is undecidable if G is, is equivalent to, is structurally equivalent \nto, covers, or is covered by, an element of F. Proof: Definitions of the above grammar classes can be \nfound in [1](1-5,7-9,11), [16] (6) , [2] (I0), [17] (12-13), and [18](14-15). The corollary follows \nimmediately from Theorem 4.3. Definition 4.5: (i) Any function t with domain and range equal to the \nfamily of cfgs (the family of cfgs with terminal alphabets equal to Z) is called a rammatical transformation \non ~ the cfgs on the ^cfgs with terminal alphabets equal ta z.) (ii) A grammatical transformation t is \nsaid to be language preserving if and only if for all cfgs G, t(L(G))=L~G). Theorem 4.6: Let T be any \nset of grammatical transformations on the cfgs with terminal alphabets equal to Z such that (i) for \nall t in T, t is language preserving; and  (ii) the identity transformation is in T. Let F be any class \nof cfgs such that  (iii) ~\u00a2F; and (iv) F contains no inherently ambiguous cfgs. Then for an arbitrary \ncfg G, it is undecidable if there exists t in T such that t(G) is an element of Y. Proof: The proof \nof Theorem 4.6 follows easy from Theorem 4.2 and is left to the reader. Finally we note that similar \nresults hold for many classes of transformations that do not contain the identity transformation, e.g. \nthe transformations in [16]. 5. Conclusions A complexity theory for many different grammar problems \nwas presented. Sufficient conditions on a class of languages F, for the undecidability of the F and F \nH-separability problems, were presented. Most classes of languages studied in the literature satisfy \nthose conditions. Sufficient conditions on grammar classes F and relations p, for the undecidability \nof the predicate \"For an arbitrary cfg G, there exists a cfg H in F for which GpH.\", were presented. \nRelations satisfying these conditions include equivalence, structural equivalence, and covering; grammar \nclasses satisfying these conditions include the classes of strong LL, LL, strong LC, LC, SLR, LALR, LR, \nand BRC grammars. Bibliography [i] A.V. Aho and J.D. Ullman, The Theory of Parsing~ Translations and \nCompil- inn~g, Vols. 1 and 2, Prentice-Hall lewood Cliffs, N.J., 1972 and 1973. [2] K. Culik, II and \nR. Cohen, LR-regular grammars --an extension of LR(k) grammars, JCSS 7, 1(1973), 66-96. [3] J.E. Hopcroft \nand J.D. Ullman, Formal Languages and Their Relation to--~o- mata, Addison-Wesley, Reading, Mass., 1969. \n [4] H.B. Hunt, III and T.G. Szymanski, Complexity metatheorems for context- free grammar problems, Princeton \nUni- versity Computer Science Technical Report 187, July 1975 (also submitted for publication). [5] \nJ. Hartmanis and J.E. Hopcroft, An overview of the theory of computa- tional complexity, JACM 18, 13(1971), \n444-475. [6] K. Culik, II and R. Cohen, LR-regular grammars --an extension of LR(k) grammars, JCSS 7, \n1 (1973), 66-96. [7] T.G. Szymanski, Generalized bottom-up parsing, Ph.D. thesis, Cornell Univer-sity, \nIthaca, New York, May 1973. [8] W.F. Ogden, unpublished note, Dec:em- ber 1974.  [91 R. McNaughton \nand S. Papert, Counter-Free Automata, HIT Press, Cambridge, Massachusetts, 1971. [i0] A.J. Korenjak and \nJ.E. Hopcroft, Sim- ple deterministic languages, IEEE Conference Record of 7th Annu~I--Sym- posium on \nSwitching and Automata Theory, October 1966, 36-46. [Ii] M.A. Harrison and I.M. Havel, Strict deterministic \ngrammars, JCSS 7, 3(1973), 237-277. [12] H.B. Hunt, III and J.L. Rangel, Decid- ability of equivalence, \ncontainment, intersection, and separability of con- text-free languages, Center for Research in Computing \nTechnology TR 19-75, Harvard University, Cambridge, Massachusetts, October 1975. [13] D.E. Knuth, A \ncharacterization of parenthesis languages, Inf. and Con- trol, 11(1967), 269-289. [14] H.B. Hunt, III, \nT.G. Szymanski, and J.D. Ullman, Operations on sparse relations and efficient algorithms for grammar \nproblems, Proc. 15th Annual IEEE Symp. on Switching and Automata Theory, October 1974, 127- 132.  [is] \n, On the complexity of LR(k) testing, Conference Record 2nd ACM Symp. on Principles of Program- ming \nLanguages, January 1975, 130- 136.  [16] B.M. Brosgol, Deterministic transla- tion grammars, Ph.D. \nthesis, Harvard University, Cambridge, Massachusetts, 1974. [17] C.N. Fischer, On parsing context- free \nlanguages in parallel environ- ments, Ph.D. thesis, Cornell Univer- sity, Ithaca, New York, April 1975. \n [18] T.G. Szymanski and J.H. Williams, Non-canonical extensions of bottom- up parsing techniques, to \nappear in SIAM Journal on Computing. \n\t\t\t", "proc_id": "800168", "abstract": "<p>The close relationship between programming language syntax, context-free grammars (abbreviated cfgs), parsing, and compiling is well-known and is extensively discussed in [1]. Unfortunately, many of the problems about programming languages, one might wish to solve, are equivalent to undecidable grammar problems. Two especially important such problems are</p> <p>(1) the emptiness of intersection problem, i.e. determining if the intersection of the languages generated by a pair of grammars is empty, and</p> <p>(2) the grammar class membership problem, i.e. determining for a fixed class of grammars r and a grammar G, if G is an element of T.</p>", "authors": [{"name": "H. B. Hunt", "author_profile_id": "81337489860", "affiliation": "", "person_id": "PP42050708", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800168.811536", "year": "1976", "article_id": "811536", "conference": "POPL", "title": "A complexity theory of grammar problems", "url": "http://dl.acm.org/citation.cfm?id=811536"}