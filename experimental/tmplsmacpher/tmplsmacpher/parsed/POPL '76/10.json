{"article_publication_date": "01-01-1976", "fulltext": "\n An Algorithm for Structuring Programs: EXTENDED ABSTRA CT Brenda S. Baker Bell Laboratories, Murray \nHill, New Jersey 07974 1. Introduction Structured programming emphasizes programming language constructs \nsuch as while loops, until loops, and if then else statements. Properly used, these constructs make occurrences \nof loops and branching of control obvious. They are preferable to goto statements, which tend to obscure \nthe flow of control [DDH,DIJ]. This paper describes an algorithm which transforms a flowgraph into a \nprogram written using repeat (do for-ever) and if then else statements. The goal of the algorithm is \nto produce readable pro- grams, rather than to avoid the use of goto statements entirely, goto statements \nare generated when there is no better way to describe the flow of control. A number of techniques for \neliminat- ing goto statements from programs have been previously published [AM, B J, BS, COO, KF, KOS, \nPKT]. However, these techniques do not necessarily produce clear flow of control [KN]. MisOse of control \nconstructs may mislead the reader into ex-pecting patterns of control flow which do not exist in the \nalgorithm. For example, these techniques may use ~/ repeat state-ment when the contained code cannot \nbe executed more than once or add numerous control variables to avoid goto statements. They also may \navoid goto statements by copying segments of code or creating sub- routines. The former method results \nin longer programs and bugs may be intro-duced when all the identical segments must be modified. The \nlatter method may result 113 in subroutines which appear unnatural. Therefore, this paper formalizes \nsome common programming practices as a set of principles for the use of basic control con-structs: if \nthen else, repeat, multilevel break (a branch to the statement following an en- closing repeat statement), \nmultilevel next (a branch to the next iteration of an enclosing repeat statement), stop, and goto. The \nprin- ciples fall into two classes: those which con- cern the nesting of statements and those which concern \nthe use of branching state-ments (goto, next, break, and stop). A pro- gram which obeys the structuring \nprinciples is called properly structured. An algorithm is presented which transforms a flowgraph into \na properly structured program, in which the predicates and straight line code state-ments are the same \nas those of the flow-graph in both number and execution order. In general, the properly structured program \nmay contain goto statements. However, the goto statements occur only where no other available control \nconstruct describes the flow of control. If a flowgraph can be written as a properly structured program \nwith no goto statements, the algorithm does it. Section 2 defines flowgraphs and intro- duces a simple \nstructured language SL. The principles concerning nesting and ordering of statements are described in \nSection 3. Section 4 presents the first part of the algo- rithm. The principles for the use of branch- \ning statements and the second part of the algorithm appear in Section 5. Section 6 studies how the structuring \nprinciples limit the possible forms of pro-grams representing the same flowgraph. If a flowgraph can \nbe represented by a properly structured program with no goto state-ments, this program is unique. More \ngen-erally, if a flowgraph contains no jumps into the middle of loops, all properly structured programs \nrepresenting it have the same nesting (but not necessarily order) of state- ments other than goto, next, \nbreak, and stop. Section 7 discusses briefly the applica- tion of the algorithm to structuring real \npro- grams. The algorithm has been implement- ed in a program called struct, which translates fortran \nprograms into ratfor [KER], a fortran preprocessor language. The structured programs generated by struct \nare much more readable than their fortran counterparts. It is not usually obvious that they are mechanically \ngenerated, since the structuring principles cause them to imitate common programming practice. An exam-ple \nof a program structured by struct is in- cluded at the end of the paper. The structuring algorithm presented \nin this paper is proposed as a tool for the maintenance of fortran programs. One of the problems in dealing \nwith fortran pro-grams is that the lack of convenient control structures makes programs hard to under-stand, \nfortran preprocessor languages such as ratfor have been developed so that new programs may be written \nusing convenient control structures. But many existing pro-grams were written in fortran without the \nbenefit of preprocessors. Mechanically structuring these programs improves ihe readability dramatically, \nfacilitating modification and debugging. 2. Goals of structuring This section defines flowgraphs, a sim- \nple structured language SL, and what it means for an SL program to be a structuring of a flowgraph. A \nflowgraph is a directed graph with labelled nodes representing computational steps and arcs representing \nflow of control between nodes. Each node is either a straight line code (sic) node with one outarc, a \nstop node with no outarcs, or a predicate (pred) node, with a \"true\" outarc and a \"false\" outarc. A flowgraph \nhas exact- ly one stop node, and there is a path to it from every node in the flowgraph. One node of \nthe flowgraph is designated as the start node. The structuring algorithm presented in this paper translates \na flowgraph into a sim- ple structured language SL. SL contains op- tionally labelled statements of the \nfollowing forms: (1) straight line code (sic) statements (i.e. assignment, read, write, etc.), (2) stop \n(3) goto L, where L is a label, (4) if (p) then {S1} else {$2}, where S1 and $2 are (possibly null) sequences \nof op- tionally labelled SL statements, and p is a predicate, (5) repeat {S}, where S is a (possibly \nnull) sequence of optionally labelled SL statements, (6) break(i), where i is a positive integer, (7) \nnext(i), where i is a positive integer. Statements of types 1-4 are interpreted in the standard way. \nrepeat {S} causes the se-quence S to be iterated until a stop is exe- cuted, or until a goto, break(i), \nor next(i) (i greater than 1) causes a jump out of the re-peat statement, break(i) causes a jump to the \nstatement following the ith enclosing repeat statement, next(i) causes a jump to the next iteration of \nthe ith enclosing repeat statement. For simplicity, no elseless if then statement is provided, but its \nequivalent is obtained by a null else clause. Also, more complex constructs such as while and until are \nnot provided since they can be ex-pressed in terms of repeat, if then else, and break. For simplicity, \nreturn is not includ-ed; it may be treated like stop during struc- turing. goto, next(i), stop, and break(i) \nstate-ments are referred to as branching state-ments~ other statements are nonbranching statements. \n114 An SL program is well-formed if the following conditions are satisfied: (1) Every statement is accessible \nfrom the start of the program, (2) the program contains at least one stop statement, and a stop statement \nis ac- cessible from every sic statement and from both the \"true\" and \"false\" evaluations of every if \npredicate.  As a result of condition (2), every loop in a well-formed program has an exit. A flowgraph \nFLOW(P) may be ob-tained from a well-formed SL program P to describe the flow of control between sic \nstatements, if predicates, and stop state-ments. Each sic statement in P is represented by a distinct \nsic node, each if predicate in P is represented by a distinct pred node, and all stop statements are \nrepresented by a single stop node in FLOW(P). There is an arc from an sic node p to a node q in FLOW(P) \nif after executing the corresponding sic statement in P, con- trol can pass directly to the statement \nrepresented by q, i.e. without first executing any other sle statement or if predicate. There is a \"true\" \n(\"false\") arc from a pred node p to a node q if control passes directly to the statement represented \nby q when the if predicate represented by p is evaluated to \"true\" (\"false\"). The start node of FLOW(P) \nis the node representing the first sic state- ment, if predicate, or stop statement execut- ed in P. \nTwo well-formed SL programs P1 and P2 are equivalent if FLOW(P 1 ) = FLOW(P 2 ). Note that this is a \nstronger statement than merely requiring that the se~t of execution paths be the same. If one program \nhas two copies of an sic statement while the other has only one, the programs may have ident- ical sets \nof execution paths but are not equivalent by this definition. This definition of equivalence was chosen \nbe-cause the algorithm of this paper does not copy code. A well-formed SL program P is a struc-turing \nof a flowgraph G if G =FLOW(P). The structuring algorithm presented in this paper identifies the basic \nstructure in- herent in a flowgraph and writes it as an SL program. It has two parts. The first part \ndetermines the organization of the final pro- gram, that is, it decides how many repeat statements to \nuse, how nonbranching state- ments should be nested, and the ordering of nonbranching statements. The \nresult is a program form. i.e. an incomplete program consisting only of sic, if then else, and re-peat \nstatements together with a specification of the correspondence between these state- ments and nodes in \nthe flowgraph. The second part of the algorithm determines where branching statements should be ad-ded \nto produce the proper flow of control. For example, if the final structured program generated by the \nalgorithm is repeat { if (p) then {x = x+l } else { y = y-I-1 if (q) then { goto 10 } else {} } y = \nf(y) 10 x = g(x) if (r) then {break(I) } else {} } z = h(x,y) stop then the first part of the algorithm \ngenerates the following: repeat { if (p) then {x = x+l } else { y = y+l if (q) then {} else {} ) y = \nf(y) x = g(x) if (r) then {} else {} } z = h(x,y) The second part of the algorithm adds the goto 10, \nthe label 10, the break(l), and the stop. The program form obtained by delet- ing all branching statements \nfrom an SL program P is denoted by FORM(P). Thus, if the algorithm generates an SL program P, the first \npart of the algorithm generates only FORM(P). 3. Deciding on principles for organizing programs The goal \nof the algorithm presented in this paper is not to eliminate goto state-ments, since the methods of eliminating \nall goto statements have not been found to produce readable programs [KN]. Instead, the algorithm follows \na set of principles for the use of control constructs to ensure that the mechanically structured programs \nap-pear natural to the reader. These principles describe some reasonable practices for pro- gramming \nin SL. They also appear to be followed (albeit flexibly) by many program- mers. Since a number of principles \nare needed to ensure production of natural SL programs, some examples are presented to motivate how this \nset of principles evolved for use in the structuring algorithm. The principles describe how repeat statements, \nif then else statements, and branching state-ments should be used in SL programs. First, some examples \nof uses of repeat statements are presented. In the following program, the repeat is inappropriate because \nit contains code which does not iterate. repeat { s=l stop } The following are some equivalent programs \nwith room for improvement in how repeat statements are used. (a) y=l goto 10 repeat { if (p) then {break(l) \n} else {} 10 y = f(y) } x = g(y) stop (b) goto 10 repeat { y = fly) if (p) then { break(l) } else { \nnext(l) } 10 y= 1 } x = g(y) stop In (a), the repeat statement can be entered only by jumping into it. \nIn (b), this prob- lem is compounded because the statement y=l is written inside the repeat even though \nit is executed only once. In particu- lar, this statement cannot be reached after executing the statement \ny = f(y) which is the first statement in the repeat. A much clearer way of writing the same computation \nis the following. y=l repeat { y : f(y) if (p) then {break(l) } else {} } x : g(y) stop  The objectionable \nprogram segments presented above can be avoided by obeying the following principle. 116  (1) Every repeat \nstatement can be entered through its \"head\", i.e. not just via a goto to a statement nested within it. \nEvery repeat statement contains at least one sic or if then else statement. Every statement within a \nrepeat is ac- cessible from the first statement within the repeat without exiting from the repeat. Every \nnonbranching state-ment within the repeat can lead to an iteration of the repeat without first ex- iting \nfrom the repeat.* Equivalent SL programs need not have the same number of repeat statements. Consider \nthe following examples. (a) repeat { repeat { if (p) then { break(l) } else {} } if (q) then {break(l) \n} else { x = x+l } } (b) repeat { if (p) then { if (q) then { break(l) } else { x : x+l } } else {} \n The first example uses two repeat state-ments where one suffices. The algorithm generates only one \nrepeat since a single re-peat appears simpler. (2) A. repeat statement may not be the first nonbranching \nstat~ement reached upon entering anothe/\" repeat state-ment. Next, two examples of peculiar uses of if \nthen else statements are presented. *Programmers often violate this principle in order to avoid goto \nstatements when a loop has several pieces of exit code. As implemented in struet, this principle has \nan associated size limit so that small segments of code (but not large segments) may appear in a repeat \nwithout iterating. (a) if (p) then { j=l goto I0 } else { j=2 I0 y = } f(j) stop (b) if (p) then {} else \n{ j=2 goto 10 } j:l 10 y = f(j) stop In (a), the statement y : ffi) is placed inside the else clause, \nforcing a jump into the else clause from the then clause. In (b), the statement j : 1 is placed after \nthe if state- ment, forcing the else clause to contain a goto jumping around the statement follow-ing \nthe if clause. Example (a) could be prevented by forbidding jumps into then or else clauses. Example \n(b) could be prevent- ed by requiring that a then or else clause contain as much as possible without \ncausing a jump into it or violating the conditions on repeat statements. But problems are caused by programs \nin which a loop may be entered in more than one place. A flowgraph G is reducible [HU72] if each cycle \nhas exactly one entry point, that is, if every cycle in G contains a node q such that every path from \nthe start node to a node in the cycle must pass through q. Otherwise, a flowgraph is irredu-cible. A \nwell-formed SL program P is reduci-ble (irreducible) if FLOW(P) is reducible (ir-reducible). Since reducibility \nis a property of flowgraphs, an irreducible program does not have an equivalent reducible program. (However, \nan irreducible flowgraph may be transformed into a reducible flowgraph by duplicating part of the graph.) \nConsider the following equivalent irreducible programs. (a) if (p) then { goto 10 } else {} repeat { \nif (q) then { j = I } eLse { lo j= 2 } if (r) then {stop } eLse {} } (b) if (p) then {goto I0 } else \n{} repeat {  if (q) then { j=l goto 20 } else {} I0 j=2 20 if (r) then {stop } else {} } The first \nexample allows a goto into the else clause from outside the smallest repeat enclosing the else clause. \nThe second ex-ample avoids the goto into the else clause but forces an additional goto to be generat- \ned in the then clause. Locally, i.e. within the repeat statement, the first example is structured better. \nIn particular, it does not look as if the statement j = 2 can be execut- ed after both the then and else \nclauses. Therefore, the following principles are used by the algorithm. (3a) A goto may jump into a then \nor else clause only from outside the inner-most repeat enclosing the clause. (3b) A statement in the \ninnermost repeat enclosing an if then else statement p must be placed within the then clause of p if \nthis does not force a violation of Principle (3a). The same principle ap- plies to else clauses. The \nfollowing principle guarantees that loops are created 0nly by repeat state-ments and that each goto statement \njumps to a statement which occurs after it in the program. (4) Control may flow to a lexically preced- \ning point in the program only to an iteration of a repeat, i.e. by executing a next(i) or by reaching \nthe bottom of a repeat statement. A well-formed SL program which satisfies principles (1)-(4) has proper \nnesting.  4. The first part of the structuring algo-rithm The first step in structuring a flow-graph \nG is to locate the loops in G. A loop is a path of G which begins and ends at the same node. A cycle \nis a loop in which only the first node (which is the same as the last node) occurs twice. Loops can be \nlocated by constructing a spanning tree by means of a depth first search [HU74], which.proceeds as follows. \nBegin by visiting the start node of G and setting NUM to the number of nodes in the flowgraph. When visiting \na node m, do the following: If node m has an arc to a node p not already visited, make p a child of m \nin the spanning tree, and visit p next. Otherwise, number m with NUM, de-crement NUM by l, and return \nto visit the parent of m (if it exists) again. A back arc is an arc from a descendant to an ancestor \nin the spanning tree; other arcs are forward arcs. Each node entered by one or more back arcs will become \nthe first state- ment within a repeat in the final program. If a cycle has more than one entry point, \nexactly one entry point is entered by a back arc. Let L be a list of the nodes of the graph ordered by \nthe numbering assigned during the depth first search. This list will be used to ensure that all gotos \nin the final program flow downward on the page. Note that an arc (p,q) is a back arc if and only if q \nappears before p in L. Also, if (p,q) is a back arc, there is a path from q to p which includes only \nnodes between q and p in L. At this point, the nodes which will be- come the first statements within \nrepeats have been determined. For each node n en- tered by a back arc, add a single repeat node 118 \n p. Replace each arc (q,n) by an arc (q,p), and add an arc (p,n). Insert the repeat node p immediately \nbefore n in L. Call the new graph the extension of G, EXT(G). Note that the addition of the new nodes \ndoes not change the ordering of the nodes already in L. Therefore, an arc (p,q) is a back arc if and \nonly if q precedes p in L.. A repeat node p is the head of all loops and cycles which include p but no \nnodes preceding p in L. In the final program, the corresponding repeat statement will contain the statements \ncorresponding to nodes in loops headed by p. For each node q, the al- gorithm determines HEAD(q), which \nis the repeat node which will correspond to the smallest repeat enclosing q in the final pro- gram. In \nparticular, of the repeat nodes which are heads of loops containing q, HEAD(q) is the closest one preceding \nq in L. If no such node exists, HEAD(q) is undefined. Note that for a repeat node p, HEAD(p) is either \na different repeat node or is undefined. The repeat corresponding to p will be nested within the repeat \ncorrespond-ing to HEAD(p) in the final program. To produce the following segment of code if(p) then {x=l \n} else { x = 2 }  y = f(x) the algorithm needs to know that the state-ments x = 1 and x ---- 2 can be \nreached only through the true and false branches of the if statement, but that y= fix) can be reached \nthrough both branches. Such branching and merging of con-trol can be described by dominators in the flowgraph \n[AU]. Node p dominates node q if every path from the start node to node q must pass through node p. Node \np is the immediate dominator of node q if no other dominator of q lies \"closer\" to q (that is, if every \ndominator of q other than p also dom- inates p). Every node in the flowgraph ex-cept the start node is \ndominated by at least one node, the start node. Moreover, every node except the start node has an immedi-ate \ndominator. Because principle (3) implies that the inside of a repeat must be structured as if the repeat \ncan be entered only at its head, the structuring algorithm uses a modified graph for calculating dominators. \nIntuitive-ly, it pretends that each arc entering a cycle at a point other than its head enters the head \ninstead. Let REDUCE(EXT(G)) be a flowgraph obtained as follows from EXT(G). If (p,q) is an arc and p \nis not in a cycle headed by HEAD(q), the arc (p,q) is replaced in REDUCE(EXT(G)) by an arc (p,r), where \nr is the first repeat node in L which is the head of a loop containing q but not the head of any loop \ncontaining p. The resulting graph REDUCE(EXT(G)) is reduci- ble. For each node p, DOM(p) is defined to \nbe the immediate dominator of p in the graph REDUCE(EXT(G) ). For each node p, HEAD and DOM are used \nto obtain a set FOLLOW(p) specifying nodes which belong \"after\" p at the same level of nesting as p. \nFor each pred node p, define FOLLOW(p) ={q[q is entered by 2 or more forward arcs in REDUCE (EXT(G) ), \np =DOM(q), and HEAD (p ) = HEAD ( q ) } For each repeat node p, define FOLLO W (p ) = { ql HEAD ( q ) \n= HEAD (p ) and DOM(q) is in a loop headed by p}. For each sic node p, define FOLLOW(p) = { q[ HEAD ( \nq ) =HEAD (p ) and p =DOM(q)}. Note that the sets FOLLOW(p) are pairwise disjoint, for all nodes p. Every \nnode is in a FOLLOW set except for the nodes which will correspond to the first statements at each level \nof nesting. In-tuitively, FOLLOW(p) is the set of non-branching statements reachable from p 119 which \nmust follow p at the same level of nesting as p. For example, suppose p is a re-peat node and q is in \nFOLLOW(p). Since HEAD(q) =HEAD(p), q must be placed within the smallest repeat containing p but not within \np. Since DOM(q) is in a loop headed by p, every path to q within this re-peat must pass through p. By \nprinciple (3), q must be at the same level of nesting as p within this repeat. Furthermore, q must be \nbelow p to avoid an upward goto. The nesting and ordering of non-branching statements in the program \nis determined by generating a program form from the flowgraph. G, i.e. a sequence PF(G) of nested nonbranching \nstatements which will be FORM(P) for the final pro-gram P generated by the algorithm. PF(G) is generated \nby calling the following recur-sive routine on the start node of the ex-tended flowgraph EXT(G). To be \nprecise, the correspondence between statements of PF(G) and nodes of EXT(G) should be specified; for \nsimplicity, it is merely as-sumed to exist. getform(n) { if (n is an sic node) then { print the straight \nline code } else if (n is a repeat node with arc to node q) then { print(\"repeat{\") call test(q) print(\"}\") \n} else if (n is a pred node with predicate r and a true arc to node p and a false arc to node q) then \n{ print(':if (r) then {\") call test(p) print(\"} else {\") call test(q) print(\"}\") }  for each member \nq of FOLLOW(n) in order of appearance in L {  call getform(q) }}  test(q) { if (q is not in any FOLLOW \nset) then { call getform(q) }} Since the FOLLOW sets are pairwise disjoint, getform is called exactly \nonce on each node in EXT(G). The resulting program form is PF(G). 5. Branching statements and the second \npart of the algorithm Next, the use of branching statements is considered. The first principle for the \nuse of branching statements is the following. (5) A goto statement may not jump to another branching \nstatement. A goto may not jump to the first statement inside a repeat; it must jump to the re-peat instead. \nA branching statement may not appear unless deleting it alters the flow of control in the pro-gram. The \nabove principle does not specify where branching statements should be used. Consider the following example. \n if (p) then { x=l stop } else { x=2  stop } The form of the following program is preferable. if (p) \nthen {x = I } else { x = 2 } stop On the other hand, when the then and else clauses jump to different \nplaces, it is prob- ably preferable to put the branching state-ments inside the then and else clauses. \nThe following principle is followed by the struc- turing algorithm to determine where branching statements \nshoul~ be added. 120  (6) A branching statement appears after a nonbranching statement p if and only \nif there is exactly one node q in the corresponding flowgraph such that both of the following conditions \nhold: (a) q does not correspond to an sic or if statement nested within p (b) q is the only node satisfying \n(a) which is entered, by an arc from the node corresponding to p or from a node corresponding to an sic \nor if statement nested within  p. The next principle assigns a prefer-ence order to branching statements \nto en-sure that branching statements following re-peat statements can be reached. (7) Branching statements \nare used in the following order of precedence: break(i) for any i, next(i) for any i, stop, goto. That \nis, a statement in the list may not be used if a choice earlier in the list may be substituted without \naltering the flow of control between non-branching statements. This principle ensures that a goto state-ment \nis not used when another branching statement suffices. A program which follows principles (5)-(7) has \nproper 6ranching. The second part of the algorithm adds proper branching to PF(G) by computing the statements \ndirectly reachable from each nonbranching statement but not nested within it. In particular, for a node \np in EXT(G), REACH(p) is the set consisting of all nodes q entered by arcs from p or from nodes corresponding \nto statements nested within p, such that q does not correspond to a statement nested within p. Branching \nstatements are added to the program recur-sively from outer levels of nesting to inner levels. A branching \nstatement is added after a nonbranching statement p if REACH(p) contains exactly one node q, and q is \nnot the node corresponding to the state- ment reached automatically in the program if no branching statement \nfollows p. If a then or else clause (or the entire program) contains no nonbranchiqg statements, a branching \nstatement is added if it is needed to ensure proper flow of control. The choice of branching statement \nis determined by principle (7) and EXT(G). A label is ad- ded to each statement entered by a goto. When \nthe above procedure is applied to the program form PF(G) generated by the first part of the algorithm, \nthe resulting program is called ALG(G). A well-formed SL program with prop-er nesting and proper branching \nis properly structured. If P is a structuring of a flow-graph G and P is properly structured, P is a \nproper structuring of G. Theorem 1. ALG(G) is a proper structuring of G. A nice feature of the algorithm \nis that it does not generate goto statements need-lessly. Theorem 2. If a flowgraph has a proper structuring \nwith no goto statements, the al- gorithm produces one. A simple analysis of the algorithm yields the \nfollowing upper bounds for time and space. Theorem 3. In the worst case, the genera-tion of ALG(G) from \nG requires at most space O(n 2) and time O(n21ogn), where n is the number of nodes in G. In practice, \nthe implementation of the algorithm in struct handles fortran programs several hundred lines in length \nin a reason- able amount of time on a pdp-ll/45 with 60K 8-bit bytes. 6. Properly structured programs \nIn this section, the implications of the structuring principles are investigated. One question one might \nask about the conditions for proper nesting and proper branching is how much flexibility they per- mit \nin writing programs. In particular, sup- pose one is given a computation specified by a flowgraph. In \nwriting an SL program to 121 perform this computation, how much flexi-bility is there in the number \nand type of control statements, in the nesting of state- ments, and in the ordering of statements at \neach level of nesting? In other words, where may differences occur between equivalent properly nested \nprograms? Con-sider the following example. if (p) then {} else { goto 10 } repeat { X ---- f(y) 10 \ny ffi f(x) if (q) then { break(l) }  else {} } This code segment could be rewritten as if (p) then \n{goto 10 } else {} repeat { y= fix)  if (q) then {break(l) } else {} 10 x---- fly) } There is a choice \nbecause the loop is en-tered in two places, that is, the underlying flowgraph is irreducible. However, \nwhen the underlying flowgraph is reducible, there is no flexibility in the number or nesting of nonbranching \nstatements. Theorem 4. If e I and P2 are equivalent properly nested reducible SL programs, then FORM(P \n1 ) and FORM(P 2) are identical in the number of occurrences of each non-branching statement and in how \nthe non-branching statements are nested within each other. Note that Theorem 4 does not state that P1 \nand P2 are identical in the order of nonbranching statements at each level of nesting. In fact, the order \nof statements is not uniquely determined. For example, consider the following code. 122 if (p) then \n{ if (q) then { goto 10 } else {} } else { if (r) then { goto 10 } else {}} x-~l goto 20 10 x=2 20 y \n= f(x) This segment could be rewritten by ex-changing x = 2 with x = 1 and moving the goto statements \nto the else clauses. However, there is no flexibility in ord- er when no goto statements occur. Theorem \n5. If Pl and P2 are equivalent properly nested SL programs with no goto statements, then FORM(P 1 ) -- \nFORM(P 2 ). Proper branching does not restrict the form of the program. Lemma 1. For every properly nested \nSL program P1, there exists an equivalent SL program P2 with proper branching such that FORM(P 2) =FORM(P \n1 ). Moreover, P2 is unique (except for labels on statements). From the above theorems and lemma, it \nfollows that equivalent properly structured SL programs with no goto statements are identical. In terms \nof the algorithm, this result may be stated as follows. Corollary 1. If P is a properly structured SL \nprogram with no goto statements, then e = ALG(FLOW(P)). Intuitively, this corollary states that flexibility \nin writing a go toless program oc-curs only in choosing the flowgraph or in choosing to violate the principles \nof proper structuring. In other words, when a pro-grammer wishes to write a properly struc- tured program'without \ngoto statements, flex- ibility lies only in modifying the computa-tion to be performed, i.e. the flowgraph \nfor the program, and not in the way the pro-gram itself describes the computation. It must be noted that \nan SL program without goto statements may not have an equivalent properly structured SL program because \nof the restriction that a repeat may not be the first statement inside another re-peat. The following \ncode segment is an ex- ample. repeat { repeat { if (s) then {break(2) } else { if (p) then { if (q) then \n{} else { break(l) } } else { if (r) then {} else {break(l) } x=x+l }} x=x+2 } If x ---- x+2 and x ---- \nx+l were within a sin- gle repeat, they would be at the same level of nesting as the if (p) statement. \nBut at most one of them could be reached without a goto from within the if (p) statement. Therefore, \nthere is no equivalent properly nested program without goto statements. 7. Applying the algorithm The \nalgorithm has been implemented in a program called struct, which rewrites fortran programs in ratfor[KER]. \nThe basic algorithm is extended in struct to generate (optional) additional constructs such as while \nloops and a form of case statement. Predicates are negated by. struct when necessary for the generation \nof if then statements, ratfor has only single-level break and next statements. Therefore, struct does \nnot adhere strictly to the condi- tions of proper branching. The Appendix contains an example of a fortran \nprogram and the ratfor program generated from it by struct. The mechanically structured versions of programs \nare easier to understand than their fortran counterparts, sometimes dramatically so. Their natural appearance \nindicates that the structuring principles describe reasonable programming practices. A more extensive \ndiscussion of struct and its success in structuring fortran appears in [BAK]. It is expected that struct \nwill be a use- ful tool in the maintenance of existing pro- grams. New programs may be written in ratfor, \nwhile existing fortran programs may be structured into ratfor for greater ease of modification and debugging. \nAcknowledgements The author wishes to thank A. V. Aho, R. A. Becker, S. C. Johnson, B. W. Kernighan, \nand M. D. Mcllroy for their helpful comments on this paper. References [AU] A. V. Aho and J. D. Ullman, \nThe Theory of Parsing, Translation, and Com- piling, Vol. H -Compiling, Prentice-Hall, Englewood Cliffs, \nN.J., 1973. [AM]E. Ashcroft and Z. Manna, Translating program schemas to while-schemas, SIAM J. on Comp. \n4,2 (1975), 125-146. [BAK]B. S. Baker, struct, a program which structures fortran, in preparation. [BJ] \nC. Bohm and G. Jacopini, Flow di-agrams, Turing machines and languages with only two formation rules, \nComm. ACM 9 (i966), 366-371. [BS] J. Bruno and K. Steiglitz, The expres- sion of algorithms by charts, \nJ. ACM 19 (1966),366-371. [COO]D. C. Cooper, Bohm and Jacopini's reduction of flow charts, Comm. ACM \n1OR (1967),463. 123  [DDH]O.-J. Dahl, E. W. Dijkstra, and C. A. R. Hoare, Structured Programming, Academic \nPress, New York, 1972. [DIJ] E. W. Dijkstra, Goto statement con-sidered harmful, Comm. ACM 11 (1968), \n147-148. [HU74]M. S. Hecht and J. D. Ullman, Char- acterizations of reducible flowgraphs, J. ACM 21,3 \n(1974), 367-375. [HU72]M. S. Hecht and J. D. Ullman, Flow graph reducibility, SIAM J. Comput. 1 (1972), \n188-202. [KER]B. W. Kernighan, ratfor -a preproces- sor for a rational fortran, Software Practice and \nExperience 5,4 (1975), 395-406. [KF] D. E. Knuth and R. W. Floyd, Notes on avoiding \"go to\" statements, \nlnJbr. Proc. Letters 1 (1971), 23-31. [KN] D. E. Knuth, Structured programming with goto statements, \nACM Comp. Sur- veys 6,4 (1974), 261-302. [KOS]S. R. Kosaraju, Analysis of structured programs, J. Comp. \nSys. Sci. 9,3 (1974), 232-254. [PKT]W. W. Peterson, T. Kasami, and N. Tokura, On the capabilities of \nwhile, repeat and exit statements, Comm. ACM 16 (1973), 503-512. 124  Appendix A fortran subroutine \n(from R. C. Singleton, Algorithm 347, an efficient algorithm for sorting with minimal storage, Comm. \nACM 12,3 (1969), p. 186): subroutine sort(a,ii,jj) c sorts array a into increasing order c from a(ii) \nto a(jj) dimension a(1),iu(16),il(16) integer a,t,tt m=l i= ii j=jj 5 if (i .ge.j) goto 70 10 k=i ij \n: (j+i)/2 t : a(ij) if (a(i) .le. t) goto 20 a(ij) : a(i) a(i) = t t=a(ij) 20 l=j if (aQ) .ge. t) goto \n40 a(ij) = aCj) a(j) = t t = a(ij) if (a(i) .le. t) goto 40 a(ij) = a(i) a(i) = t t = a(ij) goto 40 \n30 a(l) = a(k) a(k) = tt 40 1= 1--1 if (a(l) .gt. t) goto 40 tt = a(l) 50 k=k+l if (a(k) .It. t) goto \n50 if (k .le. 1) goto 30 if (l--i .le. j--k) goto 60 il(m) = i iu(m) = 1 i=k re=m+1 goto 80 60 il(m) \n= k iu(m)=j j=l re=m+1 goto 80 70 re:m--1 if(m.eq. 0) return i=il(m) j=iu(m) 80 if (j--i .ge. 11) goto \n10 if (i .eq. ii) goto 5 i=i--1 90 i=i+l if (i .eq. j) goto 70 t : a(i-I-1) if (a(i) .le. t) goto 90 \nk:i 100 a(k+l) = a(k) k: k--1 if (t .it. a(k)) goto 100 a(k+l) : t goto 90 end The preceding subroutine \nas structured by struct into ratfor: subroutine sort(a,ii,jj) # sorts array a into increasing order # \nfrom a(ii) to a(jj) dimension a(1),iu(16),il(16) integer a,t,tt m=l i=ii J--ii repeat if (i <j) go \nto 10 repeat { m= m--1 if (m==O) return i = il(m) j ---- iu(m) while (j--i>=11) 10 k=i ij = (j+i)/2 \nt = a(ij) if (a(i) > t) a(ij) = a(i) a(i) = t  t : a(i]) l=j if (a~j)< t) a(ij) = a(j) a(j) : t t= a(ij) \nif (a(i)>t) a(ij) = a(i) a(i) = t  t = a(ij) repeat != 1--1 if (a(l)<=t) { tt = a(l) repeat k = k+l \nif (a(k) >----t) break } if (k > 1) break a(l) : a(k) a(k)---- tt ) } if (l--i < :j-k) il(m) : k iu(m) \n--- j j----I m : m+l } else il(m) : i iu(m) = 1 i:k m : m+l ) if (i==ii) break i: i--1 repeat { i : i+1 \nif (i==j) break t = a(i+l) if (a(i)>O { k=i repeat { a(k+l) = a(k) k=k-1 if (t >=a(k)) break a(k-I-1) \n: t ) ) return end 126  \n\t\t\t", "proc_id": "800168", "abstract": "<p>Structured programming emphasizes programming language constructs such as <bold>while</bold> loops, <bold>until</bold> loops, and <bold>if then else</bold> statements. Properly used, these constructs make occurrences of loops and branching of control obvious. They are preferable to <bold>goto</bold> statements, which tend to obscure the flow of control [DDH,DIJ]. This paper describes an algorithm which transforms a flowgraph into a program written using <bold>repeat</bold> (<bold>do forever</bold>) and <bold>if then else</bold> statements. The goal of the algorithm is to produce readable programs, rather than to avoid the use of <bold>goto</bold> statements entirely. <bold>goto</bold> statements are generated when there is no better way to describe the flow of control.</p> <p>A number of techniques for eliminating <bold>goto</bold> statements from programs have been previously published [AM, BJ, BS, COO, KF, KOS, PKT]. However, these techniques do not necessarily produce clear flow of control [KN]. Misuse of control constructs may mislead the reader into expecting patterns of control flow which do not exist in the algorithm. For example, these techniques may use a <bold>repeat</bold> statement when the contained code cannot be executed more than once or add numerous control variables to avoid <bold>goto</bold> statements. They also may avoid <bold>goto</bold> statements by copying segments of code or creating subroutines. The former method results in longer programs and bugs may be introduced when all the identical segments must be modified. The latter method may result in subroutines which appear unnatural.</p>", "authors": [{"name": "Brenda S. Baker", "author_profile_id": "81100251227", "affiliation": "", "person_id": "PP14095999", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800168.811545", "year": "1976", "article_id": "811545", "conference": "POPL", "title": "An algorithm for structuring programs (Extended Abstract)", "url": "http://dl.acm.org/citation.cfm?id=811545"}