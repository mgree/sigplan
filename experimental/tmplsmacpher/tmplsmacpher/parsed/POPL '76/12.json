{"article_publication_date": "01-01-1976", "fulltext": "\n PLAN2D - SYNTACTIC ANALYSIS OF PRECEDENCE GRAPH GRAMMARS by Reinhold Franck Technical University of \nBerlin, Department of Cybernetics  ABSTRACT The syntactical analysis of pictures derived by a context-free \ngraph-grammar is a rather complicated algorithm. Analogously to the development for Chomsky- grammars \nten years ago we define the precedence-graph-grammars as a subclass of the context-free graph-grammars \nallowing for easier parsing algorithms. By table-lookup we can decide locally if an edge or a node is \npart of a handle and if it isn't in which direction to proceed to reach one.  INTRODUCTION PLAN2D is \na programming language where (parts of) a program may be described by diagrams (see /De 75/). The syntax \nof these pictures -represented as marked graphs -is determined by a context-free graph- grammar. So the \nproblem of syntax-analysis of PLAN2D- programs leads to the problem of looking for a deri- vation of \nthis graph-grammar. During syntactic analysis in order to do the next reduction step we have to search \nin a graph for a suitable subgraph to reduce. It is well-known that this problem is algorithmically solvable \nfrom the viewpoint of theory alone. In practice such an algorithm will work only for very small graphs \n- and even then will be very slowly. In order to get better syntax-analysis-properties we restrict our \nattention to a certain subclass of context-free graph grammars which we call precedence graph grammars \nand wh\u00a3ch turn out to have the following comfortable properties: - the search for the next handle (i.e. \nhere the next subgraph to reduce) can be done locally by investi- gating one edge and corresponding table-lookup; \n - these grammars are unambigous and the syntax-analy- sis can be done deterministically without backup. \n MARKED GRAPHS AND GRAPH GRAMMARS Definition A marked graph is a system (K,R,k,r) where K is a finite \nset of nodes, RcKxK a set of edges k:K )V a mapping for labelling the nodes, r:R )M a mapping for \nlabelling the edges. We suppose V and M as well-known finite sets. Their formal definition will be part \nof the grammar so that they have not to be included in the above definition. For the description of graphs \nwith several edges labelled differently between the same nodes we may generalize r to a relation which \ndomain is the whole set of R. Picture i gives an example for our use of marked graphs. In order to eliminate \nsuch trivial differences bet- ween graphs as e.g. a different order of numbering the nodes we define \nin a-suitable (and usual) way homomorphy, isomorphy and equivalence of marked graphs. The next important \nstep is to describe the process of substituting a certain subgraph by another graph. We define this \nderivation step as in /Sch 70/ which is sliqhtly different from the way in /EPS 73/. 134 ntrl 4 2C--- \n>- .... .3,, ~1--[.__ 5q F6.._ q 0v i 8 'fr  Picture I Example for a piece of a PLAN2D-program and \nthe formal description by a marked graph. The meaning of the labels for the edges is obvious. Let be \na marked graph G = (K,R,k,r) with a subgraph G'= (K',R',k',r') and the remaining restgraph G ''= (K\",R\",k\",r\"). \nBecause we restrict our attention to connected graphs only there must be some edges in G between K' and \nK\" the set of nodes of G' and G\" resp. Definition from(G',G) := R m(K'xK\") to(G',G) := R ~ (K\"~K') \nThese edges will be used to tie the graph which is to replace G' to the remaining parts of G. Suppose \nthat a marked graph G = (K,R,k,r) contains a subgraph Gi= (Ki,Rl,kl,r I) C G which we want to replace \nby Gr= (Kr,Rr,kr,rr). How to tie Gr to the cut-off ends of the edges of from(G1,G) and to(Gi,G)? If for \nexample (x,y) G to(Gi,G) and we know the nodes z in G which must be connected to x after replacement \n r then we can describe these new edges by pairs (y,z) ~ KixK r. So we have together with G 1 and G r \na set H~KiXK r. Additionally we let this process of heredity of in element outof to(Gi,G) depend on the \nlabel of this edge. For this distinction we have a label relation mt:H t ~M where the domain is the \"total \nset H t but which may have more than one value t for an element outof H . Analogously we have for the \ntying of the elements of f set 1 and the . mf:H f ~M  from(Gi,G) a HCKrXK relation f such that for \nevery h6 H there is at least one m~M f with (h,m) ~ m . Definition A graph grammar is a system GG = \n(V,T,M,P,S) where V is a finite set of symbols, TCV a set of terminal symbols, M a finite set of labels \nfor edges, S a marked graph, the start graph and P a finite set of productions of the form p = (Gi,Gr,Hf,mf,Ht,m \nt) where G 1 and G r are marked graphs with the set of nodes K 1 and  K r resp. , H~KrXKi, H~Ki\u00d7Kr, \nmf:H f > M and mt:H t )M as above. Example 1 The following example originates from the PLAN2D grammar. \nLet be GG = (V,T,M,P,S) where T : {~, O}, M = {in,ov,lf} and V = { ~r~, ~nnerstruc~, ~calar-roo~ , ~r~ \n, ~calar-row~ ,(scalar-column, I I , O } The start graph consists of only one node labelled ~t~ without \nany edges. We use a graphical description of the productions consisting of two parts: - on the left \nside there is a pictorial description of the graphs for both sides of the rule (i.e. of G 1 and Gr); \n-on the right side we give the marked graphs repre- senting both sides of the rule. For distinction the \nnodes of the left side are encircled twice. The elements of H f and H t are represented by dashed arrows \nso that an arrow from a to b stands for the element (a,b) outof Ki~Kr or Kr~K 1 resp. The labels for \nthe edges are attached to the corresponding arrows. So we define P to consist of the rules i to 9 des- \ncribed in picture 2. Definition For two marked graphs G and G' like above there exists the relation \nG G~G G' iff there exists a production p in the graph grammar GG, p = (Gi,Gr,Hf,mf,Ht,mt) such that \ni) GiC G and GrC G' ii) G -Gl= G'- G r iii) from(Gr,G')= { (z,x) I y~VK (y,x) ~ from(G1,G), 1 (z,y) G \nH f, r((y,x)) ~ mf((z,y)) t\u00b0(Gr,G') : { (x,z) I y~VKi(x,Y) C to(G1,G),  (y,z) ~ H t, r((x,y)) ~ at((y,z)) \n} No. G~aghical descri]~ti0n of a rule Marked graphs reoresenting both sides i 1 ~1 str'~ ) <innerst~tet) \n.... i~____(D ~ in \u00ae I ' 2 (linnerstruct) ~ (scalar-root) @~___An____\u00ae . . . . . . . . . . . . . . . \n. . . . . . . . 3 4 scalar-root) i (Isoalar_ro,.O ! ~sc~]ar-ro09 4 i ('scalar-root) > ~ scalar-rolL) \n_ _.in___~=--6-v---~ 5 (1.scalar_row) I > (sca] ar-column) ___/-~ _ _@-'--~-v-- :-@ 6 (Iscalar-column) \n> (Iscalar-eolum~ (sca]~.ar 7 ~soaZar-column} ~ ~ sca1~ in e,rs@s- if __ J..n_ __ __i~___ @,-~Trr=.@ \n Picture 2 Graphical representation of the rules of the grammar in example i The relation ~ GG turns \nout to be uniquely and the Chomsky hierarchy was. effectively to construct. The relation ~\" is In order \nto describe the derivation process of con- GG declared in the usual way as reflexive and transitive \ntext-free graph grammars and to define such a grammar closure of G~G to be unambigous we define generalized \nderivation Picture 3 gives an example of the derivation of a trees -which are no lonqer real trees -but \nwhich simple structure with the grammar of example I. give a similar description of the derivation of \na No of the Derived picture Representation as a marked graph ' apg]-ied rule I c ~~e~r,,o o I Gh_ \n?_ e 1c. ......... topOI ~in @ 1 .2~ ~ ~ I ~ln\u00ae L r~---~ dTaT~D I  ~--~ ifsD  ,r2 51  Picture 3 \nExample for a derivation with the grammar outof example i We define a'graph grammar to be context-free \niff the graph as the derivation tree does for a word derived left hand graph G 1 of every production \nhas only one by some context-free Chomsky grammar. node. In /Sch 70/ is shown that the graph grammars \ninclude PRECEDENCE GRAPH GRAMMARS  as a special case the Chomsky grammars (one only has to restrict \nto one sort of edges and to require that We generalize the idea of precedence realtions for R is totally \nordered). Therefore we get as result a easier parsing in the following way to graph grammars: hierarchy \nof graph grammars which is proper because Every edge of a marked graph has exactly one of the 136 three \nattributes:6,~ orb Starting at some arbitrary node x we proceed one edge starting (resp. ending) at x \nto the node y at the end (resp. start) of this edge as long as this edge (x,y) (resp. (y,x)) has the \nattribute ~ (resp. ~ ). A handle for reduction of the actual graph is a subgraph where all edges have \nthe attribute ~ and for all connections to the ~estgraph is true: if a is a node of the handle and b \na node of the restgraph which are sonnected by the edge (a,b) (resp. (b,a)) then the attribute of this \nedge is ~ (resp. ~). t\" \\% z / Picture 4 Example for a graph with attributed edges and four handles \n(the labels are omitted) For easier understanding we can imagine that the attributes indicate the 'altitude' \nof a node: for an edge (a,b) means ~ that a and b are on the same level, means that a is over b and \n~ indicates that a lies lower than b. The search for a handle means then to look for a summit consisting \nof one or some nodes from which every existing edge goes down to a lower node. How to realize these informal \nideas? The names for the nodes at both ends of an edge are arbitrary and therefore cannot serve to attach \nthe attributes to the edges. We will choose the prece- dence attributes depending on the symbols of \nthe nodes at both ends of the edge and on the label of the edge. So we get a mapping P:V~VxM ~{~,~,~}. \nThis map is to be implemented in form o~ a three- dimensional array -our so-called 'precedence-cube'. \n There is a representation of the following precedence- relations in terms of other relations combined \nby concatenation and star operation as well. But I pre- fer to give the following algorithmic definition \nfor filling the precedence-cube in four steps. First step: For all edges (a,b) on the right side of a \nproduction we must do the entry P(k(a) ,k(b) ,r((a,b)) := .~  where k, resp. r is the label function \nfor nodes, resp. edges. (Remember that we supposed the graph on the right side to be connected; so if \nwe found one node of a handle we can find the others by proceeding edges with attribute ~ only). Second \nstep: For all edges pointing from outside into a handle we have to insert ~. Such an edge is always originating \nfrom an edge (a,b) on the right side of a rule, k(b) is a nonterminal, the actual handle is derived from \nk(b) and during this derivation the edge in question always was inherited. The following algorithm searches \nfor all the symbols derivable from k(b) and to which the original edge (a,b) may be left. proc into \n= (symbol u, label rel, symbol v) void: if v nonterminal then co let be pl...pn the rules with v on \nthe left side c__o for j from I to n do for x e ~ with rel e m f (x)  a p~ do if P(u,rel,k(x)) = A then \nP(u,rel,k(x)) := ~; into(u,rel,k(x)) elif P(u,rel,k(x)) ~ <o then conflict(u,rel,k(x)) else skip co \nwe reached a loop c__o fi  od od else skip co end of recursion: v is terminal co fi; Third step: In \ncorrespondence to the second step we have to treat the edges starting at some node of a handle and ending \nat some node which belongs to the restgraph. This is done by the algorithm: proc out of = (symbol u, \nlabel tel, symbol v) void: if u nonterminal then co let be Pl\"'\" Pm the rules with u on the left side \nco for j from 1 to m do for x e H t with re/ e m t (x)  Pi ~ do if P(k(x),rel,v) = A-- then P(k(x),rel,v) \n:= ~; out of(k(x) ,rel,v) elif P(k(x),rel,v) @ o> then conflict (k (x) , rel, v) else skip co we reached \na loop co fi  od od else skip co end of recursion: u is terminal co fi; Fourth step: In the second \nand third step we worked The algorithms to test the second condition are shown out the cases where necessarily \na reduction of the above -there are also available algorithms to test node at one end of an edge had \nto be done before the if a grammar fullfills the third condition. other could be reduced. But by combination \nof the Theorem A precedence grammar is unambigous and can situations of the second and third step during \nderi- be analysed without backup in a very efficient way. vation there may exist edges where the next \nreduc- In the following we give an outline of a recursive tion step can be performed at both ends. To \nrealize parsing algorithm (which works only for correctly our original aim it would not be necessary \nto do derived pictures because all error handling is any entry into the precedence-cube in this case; \nbut omitted): in order to use the precedence-cube for a better and early syntax-error diagnostic we \nenter a special proc analyze = (node a) void: symbol to the cube: while diagram ~ start graph of the \ngrammar do while there is no complete summit to which belongs(a) proc complete = (symbol u,label tel,symbol \nv) void: do a := node with higher altitude od; for u'e V with P(u',rel,v) = reduce the summit reached \nand replace by b; do for v'~ V with P(u,rel,v') = analyze(b) do if P(u',rel,v') = od; then P(u',rel,v') \n:= <.> elif P(u',rel,v') The efficiency of this parsing method is due to the then conflict(u',rel,v') \nfact that we succeeded in localizing the parsing fi process: for every edge it is decidable by simple \nod od; table-lookup if it belongs to a handle (within the < > icft~ ' in ov:I% inlov if in~ovilf in \n0vl If in I ov!lf ~ in ~.ov ill 1 i B t <.> 1 i I>I <->! ,. , ' <'>i <'> , i i 1 i I 1 i > <.> <. \n<.> <'>i I <'> i ~ i  c~ <.> <.> .> <.> <.> < > ><> <> -> <->I <->i .> <-> <.>  : i [ Picture \n5 Precedence-cube\" for the graph-grammar of example i Definition A context-free graph-grammar is a prece- \nbool procedure there is nd complete summit to which dence grammar iff belongs). And in the case that \nthe actual node is i) it is uniquely invertible not part of a handle we get information where to ii) \nfor all edges on the right side of the rules the proceed (by node with higher altitude). three algorithms \nwork without conflict iii) the grammar derives only connected graphs and In picture 6 we demonstrate \nhow this algorithm every edge is inherited to at least one node. parses the diagram which was derived \nin picture by the grammar of example i. 138 F  No of the The part of the graph which rule which Representation \nof the diagram which is has to be visited to find the' Reduced diagram is going to reduced up to now \nby a marked graph next handle with precedence be inverted attributes (labels omitted) 1 V 2 I < > \n I \u00a2,. > '1 i in  [ 2~s|cal.....lumn] ] lo Q l 1-~ scal...... ) [ (!), (@.) Q( in \u00ae I 1 2:sea, ........ \n) I [ 2~'i..........t] ] - @) \u00ae i< struct~ \u00ae Picture 6 How the procedure analyze would parse the diagram \nderived in picture 3 Picture 6 consists of three parts: On the left there CONCLUSIONS is a marked \ngraph representing the diagram in the We tried to apply these ideas of precedence grammars middle. \nOn the right side we give the part of the to the graph grammar by which the two-dimensional marked \ngraph which has to be inspected to find the programming language PLAN2D is described. And we next handle. \nIn the right part the labels are omitted get similar results as early attempts to apply and the precedence \nattributes are attached to the p[ecedence ideas to existing linear programming edges. The actual handle \nis encircled. languages yielded: there are of course precedence In order to eliminate trivial indeterminism \nwe conflicts which can be eliminated by changing the suppose that the nodes are visited in the natural \n grammar - but this must be paid by higher complexity order of integers. of the grammar (greater number \nof nonterminals and rules especially). REFERENCES /De 75/ Denert,E. : PLAN2D -Konzept und Syntax einer \nzweidime~ionalen Programmi~-Sprache. Dissertation, Fachbereich Kybernetik, Technische Universit~t Berlin, \n1975 /DFS 74/ Denert,E., mranck,R., Streng,W.: PLAN2D -Towa~d~ a ~o-dime~iona~ Programming Language. \nLecture Notes in Comp. Sciences No 26, Springer Verlag, pp. 202 -213 /EPS 73/ Ehrig,H., Pfender,H., Schneider,H.J.: \nGraph Gramme: An Algebraic Approach. Proc. 14th Annual Conf. on Switching and Automata Theory 1973, pp. \n167 -180 /Fr 75/ mranck,R.: PLAN2D Syntaxanalyse yon Pr~zedenz-Graph-Grammatiken. -  Dissertation, Fachbereich \nKybernetik, Technische Universit~t Berlin, 1975 /Sch 70/ Schneider,H.J.: Chomsky-Systeme f6~ pa~ielle \nOrdnungen. Arbeitsberichte des Instituts f0r Math. Maschinen und Datenverarbeitung, Band 3, Nr.3, Erlangen, \nAugust 1970 /St 75/ Streng,W.: PLAN2D -Semantik einer zweidimensionalen Programmiersprache. Dissertation, \nFachbereich Kybernetik, Technische Universit~t Berlin, 1975  \n\t\t\t", "proc_id": "800168", "abstract": "<p>The syntactical analysis of pictures derived by a context-free graph-grammar is a rather complicated algorithm. Analogously to the development for Chomsky-grammars ten years ago we define the precedence-graph-grammars as a subclass of the context-free graph-grammars allowing for easier parsing algorithms. By table-lookup we can decide locally if an edge or a node is part of a handle and if it isn't in which direction to proceed to reach one.</p>", "authors": [{"name": "Reinhold Franck", "author_profile_id": "81100368737", "affiliation": "", "person_id": "P342235", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800168.811547", "year": "1976", "article_id": "811547", "conference": "POPL", "title": "PLAN2D - syntactic analysis of precedence graph grammars", "url": "http://dl.acm.org/citation.cfm?id=811547"}