{"article_publication_date": "01-01-1976", "fulltext": "\n Procedure Referencing Environments in SL5* Dianne E. Britton, Frederick C. Druseikis, Ralph E. Griswold \nDavid R. Hanson, and Richard A. Holmes Department of Computer Science, The University of Arizona Tucson, \nArizona 85721 SL5 is a programming language developed for experimental work in generalized pattern matching \nand high-level data structuring and access mechanisms. This paper describes the procedure mechanism and \nthe conventions for the interpreta- tion of identifiers in SL5. Procedure invocation in SL5 is decomposed \ninto the separate source-language operations of context creation, argument binding and procedure activation, \nand allows SL5 procedures to be used as recursive functions or coroutines. This decomposition has led \nto rules for scoping and for the interpretation of identifiers that are different from those found in \nother programming languages. Several examples of SL5 procedures are given, including a scanner based \non the coroutine model of pattern matching. i. Introduction The SNOBOL4 programming language has been \nused as a basic experimental tool for recent research in generalized string pat- tern matching [2,4] \nand advanced data structure manipulation [6]. Until recent- ly, the approach has been to extend or modify \nexisting SNOBOL4 implementations in order to conduct investigations in these areas. The formulation of \nthe coroutine model for pattern matching [2,3], and the introduction of programmer-defined scan- ning \nprocedures based on that model [4], have made this approach impracticable. The procedure mechanism required \nby the coroutine model necessitates a more versi- tile research vehicle than is provided by SNOBOL4 and \nother existing programming languages. Motivated primarily by the requirements of the coroutine model, \nthe SL5 programming language [5] has been developed and implemented as a research tool for experimental \nwork in the areas mentioned above. The purpose of this paper is to des- cribe the procedure mechanism \nof SL5 and the conventions that have been chosen for the interpretation of identifiers in SL5. SL5 provides \na coroutine mechanism that is based on a generalization of recursive procedures in which ordinary recursive \nfunction use is a special case. The con- ventions for the dynamic interpretation of identifiers have \nbeen designed to facili- tate the insertion of programmer-defined procedural abstractions into prior, \nor *This work was supported by the National Science Foundation under Grant DCR75-01307. builtin, procedural \nabstractions. For example, the conventions allow the exten- sion of the pattern-matching scanner by the \ninclusion of programmer-defined scanning procedures. The dynamic interpretation of identifiers used in \nSL5 is conceptually simpler than that used for programming languages such as Algol 60, whose scoping \nrules are too restrictive for general coroutine programming. For example, pro- cedures asarguments require \nspecial handling in Algol 60. In addition, the conventions provide for the necessary inter-procedure \ncommunication that is con- venient and suitable for applications requiring backtracking such as programmer- \ndefined scanning procedures [4]. 2. The SL5 Programming Language Experience with SNOBOL4 has motivated \nsome of the features of SL5, e.g., SL5 is a \"typeless\" language in the same sense that SNOBOL4 is --a \nvariable can have a value of any datatype at any time during program execution. A signaling mechanism \nis also included in SL5. Some parts of the language, however, are derived from the desire to include \nfacilities that are not commonly found in programming lan- guages and for which SNOBOL~ is inadequate. \nFor example, the syntax of SL5 is expression-oriented, and the control structures are similar to those \nin Algol 68. An expression returns a value and signals either \"success\" or \"failure\" (as in SNOBOL4). \nControl structures are 185 driven by these signals rather than by boolean values. For example, the \n expression if x > y then x := x -y else y := y -x; first evaluates the expression x > y. If that \nexpression succeeds, x :: x -y is evaluated; otherwise y := y -x is evalu- ated. Loop constructs are \ncontrolled in the same manner: while e I do e 2 repeatedly evaluates e 2 as long as e 1 succeeds. A \nsequence of expressions can be grouped together as a single expression using the begin ... end construct. \nOther typical constructs are included, and have interpretations consistent with the signaling mechanism. \n Procedures in SL5 are data objects and an identifier can be assigned a procedure as its value. For example, \nthe expression f := procedure(x,y) while x ~= y d__~ if x > y then x := x -y else y := y -x; succeed \nx end; assigns to f a procedure that computes the greatest common divisor of its arguments. 2.1 The \nDecomposition of Procedure Activation In most programming languages, the in- vocation of a procedure \nis considered an atomic operation. In SL5, procedure invocation is decomposed into several dis- tinct \ncomponents available to the pro- grammer at the source-language level. The invocation and execution of \na procedure requires the creation of a context, the binding of the actual arguments to that context, \nand the resumption of the proce- dure represented by the context. In SL5, the conventional function notation \n f(el,e 2,-..,e n) for the invocation of a procedure is decomposed into the steps tl := create f; \nt2 := tl with (el,e2,...,en); resume t2; The operator create takes a single argument of datatype procedure \nand returns an object of datatype context. This source-language data object is a context for the execution \nof the given procedure. Argument binding is accomplished using the with operator that binds the actual \n arguments, e I through en, to the indicated context. The actual activation of a procedure is accomplished \nby the resume operator, which takes a single argument of datatype context, resume causes the execution \nof the current procedure to be suspended and the execution of the procedure represented by the given \ncontext to commence or continue. The operations succeed e fail e result in the suspension of the execution \nof the current procedure and resumption of the instance of the \"resuming\" proce- dure. These operations \nare equivalent to return in the recursive case. The indi- cated signal (success or failure) and value \nare transmitted and become the signal and value of the resume operator. This decomposition provides \nthe mechan- ism for SL5 procedures to be used as recursive functions or coroutines. While this decomposition \nis useful and necessary in some coroutine programming situations, the abbreviated notation f(el,ev,... \n) may be used for the usual recur~ive 'en invocation. 3. The Interpretation of Identifiers The interpretation \nand scope of identi- fiers that appear in a procedure are determined by declarations. In many cases, \na procedure invoked in the standard recursive fashion needs some mechanism for inter-procedure communication. \nIn con- trast, a coroutine often requires that some data be inaccessible from any other coroutine. The \ndeclarations in SL5 are motivated by the need for dynamic communi- cation between instances of procedures \nand the need for identifiers whose values cannot be modified by any other procedure. 3.1 Public and \nPrivate Identifiers Declarations have the form ~rUblic v], u2, ..., v n e ~1' v2' \"''' Vn Public identifiers \nallow for dynamic communication between instances of proce- dures. A public identifier is accessible \nto the procedure in which it is declared and in any other procedure whose context is within the dynamic \nscope [8] of the context for the procedure containing the public declaration. When SL5 procedures are \nused in the standard recursive fash- ion, the interpretation of public  identifiers is equivalent to \nthe dynamic scope of identifiers in SNOBOL4. Private identifiers are available only to the procedure \nin which they are declared. The value of a private identi- fier cannot be examined or modified by any \nother procedure. This type of identi- fier is used, for example, in situations where a procedure must \n\"remember\" infor- mation in order to be able to reverse effects during backtracking. Unless otherwise \ndeclared, the formal parameters of a procedure are considered to be private identifiers.  3.2 Free \nIdentifiers Free identifiers are those that do not appear in any of the declarations in the procedure \nin which they are used. The interpretation of this type of identifier is dynamic and occurs at the time \nof the creation of a context for the procedure that contains the free identifiers. The interpretation \nis obtained by examining the current state of the creation history tree. The creation history tree provides \ninformation concerning the history of the creation of contexts during the course of program execution. \nThe tree grows when- ever a create operation is performed and is pruned upon the destruction of a con- \ntext. The actual tree consists of inter- connections among contexts that result from the create operation. \n An example of a creation history tree is shown in Figure i. The nodes of the tree in Figure i represent \ninstances of contexts for particular procedures. An arrow indicates the ancestral linkage between a context \nand the context that caused its creation. The subscripts on B Figure i. A Creation History Tree  187 \ndenote specific occurrences of a context for the same procedure. Contexts with a common ancestor but \nthat do not share a common ancestral linkage are referred to as parallel contexts. Serial contexts are \nthose in which creation history follows ancestral lines. B I and B 2 are serial contexts; B I and B 3 \nare parallel contexts. The context for the procedure in which public identifiers are declared is said \nto be the custodian of those identifiers. As described above, public identifiers are available to their \ncustodian and to any procedure whose context is a descendant of their custodian in the creation history \ntree. The dynamic interpretation of free identifiers is determined by the history of serial contexts. \nA search is performed along the ancestral linkage for the first context that contains a public declaration \nfor the free identifier, i.e., for the closest custodian of that free identifier. If the search is successful, \nthe free identifier (in the particular instance of the context) henceforth refers to the public identifier \nlocated in the custodian. In Figure l, assume that the procedure A (that is, the procedure represented \nby A) contains the declaration public x and that procedures B and E contain x as a free identifier. \nAt the time of crea- tion of the contexts B I and E, the inter- pretation given the free identifier \nx is the common public identifier x in the context A. In this case, the context A is the custodian \nof the public identifier x. During the execution of B I and E, x can be used for inter-procedure communica- \ntion between A, E, and B I. As another example, consider an identi- fier y declared public in both D \nand E but that is free in B. In this case, the interpretation given to y in B 2 refers to Y declared \npublic in D, whereas in B 3 the free identifier y refers to the publlc identifier declared in E. Communication \nbetween the serial con- texts B 1 and B 2, which are invoked in a recursive fashion, can be effected \nby reference to a free identifier (such as x) in B that is declared public in A. This interpretation \nof free identifiers allows procedures with instances of either serial or parallel contexts to communicate \nvia public identifiers declared in pro- cedures that are represented by their common ancestors in the \ncreation history tree. Since private identifiers are not considered during the interpretation of free \nidentifiers, their values are inaccessible from any other procedure activation. The root of the creation \nhistory tree is a context for a \"main procedure\" in which, conceptually, all builtin identi- fiers are \ndeclared public, and are initialized to their predefined values before program execution begins. The \nroot context contains, for example, identifiers that have builtin procedures as their initial value. \nUnless explicitly declared otherwise, when these identifiers are used as free identifiers in programmer-defined \nprocedures, the interpretation made is the value of the builtin identifier in the root context. The \nsearch of the creation history tree may fail to provide an interpretation for a free identifier. There \nare several possible solutions to this problem. Perhaps the most reasonable solution is to consider this \nsituation a programming error. An alternative is to provide an \"implicit\" public or private interpreta- \ntion for the identifier. If an implicit public interpretation is chosen, either the active context or \nthe root of the creation history tree could be chosen to be the custodian of the identifier. 4. Examples \n  4.1 Redefinition of a Procedure Since a procedure is a source-language data object, public identifiers \nprovide a convenient means for the dynamic redefini- tion of a programmer-defined or builtin procedure \nwithin a subtree of the creation history tree. For example, assume the procedure represented by Bi, B2, \nand B 3 in Figure i contains the expression j :: length(s) and length is a free identifier in B. At \nthe time of the creation of the contexts B I and BR an interpretation for length is sought. -Assuming \nthat the procedure represented by E does not contain a public declaration for length, the interpretation \nmade is the builtin identifier length (whose value is a procedure that returns the number of characters \nin its argument). If the identifier is declared public in the procedure represented by D, and assigned \na procedure as value, the effect is to cause the redefinition of length in the instance of procedure \nB represented by B^. The programmer can use this facility d to monitor the use of certain procedures \n or extend the domain of a procedure or operator to accomodate different types of arguments. 4.2 A \nGenerator of Random Number Generators The values of private identifiers in a context for a procedure \npartly characterize the state of that instance of the proce- dure. As such, they provide a mechanism \nfor the parameterization of a given in- stance of a procedure. For example, consider the procedure \nrangen defined as follows. rangen :: procedure(private s,p,c,m,n) repeat be_gin S := remdr((s * p) \n+ c,m); succeed ((s * n) / m) + i; end end; The procedure rangen computes a random number using the \nlinear congruence method [7]. A context for rangen computes the next random number within the range I \nto n in the sequence defined by the para- meters s, p, c, and m. A context for rangen is parameterized \nby the values of the arguments to rangen and generates the next random number from an independent sequence \nevery time it is resumed. Thus any number of generators may be created using a common procedure, rangen. \nIt is the context for each instance of rangen that is the generator. For example, the expressions gl \n:= create rangen with (0,12621,21131,100000,100); g2 :: create rangen with (0,12641,11241,10000,10); \n g3 := create rangen with (iii,12321,12231,i0000,50); assign to gl, g2, and g3 three separate contexts \nfor rangen, each of which gener- ates a distinct sequence of random numbers. To obtain the next random \nnumber in a sequence, the execution of the desired context is resumed, e.g., x :: resume g2; The superfluous \ndata structures that are usually needed to effect the type of parameterization desired for rangen are \nunnecessary in SL5. Private identifiers allow the parameterization data to be implicitly stored as a \npart of the context for the procedure. Moreover, since a con- text is a source-language data object, \na procedure activation and its associated parameterization data can be manipulated as a single object. \n 4.3 The Pattern-Matching Scanner Part of the motivation for the proce- dure facility in SL5 comes \nfrom the co- routine model of pattern matching [2,3]. The conventions adopted for the interpre- tation \nof identifiers facilitate the inter- action between the builtin scanner and scanning procedures and programmed-defined \nscanning procedures. In addition, the procedure mechanism is sufficiently general to allow the scanner \nto be written in SL5 for experimental purposes without sacrificing any of its capabilities. An SL5 implementation \nof the scanner, given below, illustrates the need for the conven- tions as defined. The pattern-matching \nscanner has two arguments --a subject and pattern. The pattern contains the information necessary to \ndirect the analysis of the subject string. In the coroutine model, the analysis is performed by scanning \nproce- dures, which are invoked as coroutines. It is the use of public and private identi- fiers in the \nscanning procedures that is of interest in this example. Further details of the coroutine model are given \nin References 2, 3, and 4. Patterns in SLS, as in SNOBOL4, are data objects. A pattern can be visualized \nas a tree of nodes in which each node has three fields: sproc, argl, and arg2. The sproc field contains \nthe scanning pro- cedure, which is an object of datatype procedure. The argl and arg2 fields con- tain \narguments supplied for the scanning procedure when the pattern is constructed. A pattern is constructed \nby a pattern- construction procedure and the actual matching is performed by the associated scanning \nprocedure. For example, fen(n) constructs a single-node pattern shown in Figure 2 whose sproc field contains \nthe scanning procedure slen, which attempts to advance the cursor position by n charac- ters during matching. \nA scanning procedure is called with a single argu- ment: the node in the pattern that caused its invocation. \n sproc .~..~-~ s I e n arg I --J ~'~-'-\"-~\"~ arg 2 Figure 2. The Pattern Constructed by len(n). Unlike \npattern matching in SNOBOL4, operatians such as alternation knd concat- enation are themselves scanning \nprocedures that perform only control operations. The pattern-constructing procedures for these operations \nin SL5 are denoted by the operators \"\\\" and \"--\" respectively.; salt and scat are the associated scanning \npro- cedures. For example, Figure 3 illus- trates the pattern constructed by the expression p := (len(1) \n--rpos(O)) \\ len(3) Pattern matching is initiated by the creation and resumption of the scanning procedure \ngiven in the root node of the pattern passed to the scanner. Matching proceeds as scanning procedures \nin the pattern are activated. A successful match is signaled by the resumption of the scanner with a \nsuccess signal. Thus the scanner can be written in SL5 as follows. scan := procedure(public subject, \nprivate pattern) public cursor; private e; cursor := O; e := create sproc(pattern),with pattern; \nif resume e then succeed else fail; end;  slen  ]~-~,~ slen ~ srpos Figure 3. A Pattern.  Communication \nbetween scanning proce- dures and the scanner is provided by the identifiers subject and cursor, which \nare declared public in scan. The value of subject is the string that is to be scanned and the value of \ncursor indicates the position in the string that is to be examined by a scanning procedure. The interpretations \nof the free identi- fiers subject and cursor that appear in scanning procedures are made when a con- \ntext for a scanning procedure is created and refers to the public identifiers in the nearest custodian \nin the creation history tree. The use of subject and cursor in scanning procedures is illus- trated by \nslen. slen := procedure(private p) private c; c := cursor; cursor := cursor + argl(p); if cursor >= \n0 &#38; cursor <= length(subject) then succeed; cursor := c; fail end; Note that slen is more general \nthan the corresponding SNOBOL4 primitive since its argument may specify a negative integer thereby causing \nthe cursor to be decremented. By convention [2-4], a scanning pro- cedure is resumed with a success \nsignal as a request to search for alternatives. It fails if it cannot find an alternative. In addition, \nbefore a scanning procedure can fail it must reverse any effects, such as cursor movement, that it caused \nduring matching. Private identifiers are used within scanning procedures to retain values that are necessary \nin order to reverse effects during backtracking. In the procedure for slen given above, the private identifier \nc is used to save the previous value of cursor, slen does not possess alternatives, so if it is resumed \nafter signaling success, it restores cursor to its previous value and fails. (Subsequent resumption of \na scanning pro- cedure that has signaled failure is a programming error.) Scanning procedures that perform \ncon- trol operations, such as scat and salt, do not examine or modify subject or cursor. They initiate \nother scanning procedures in order to implement their specific control relationships. For example, the \nscanning procedure for a primitive version of salt can be written as follows. salt := procedure(private \np) private e; e := create sproc(argl(p)) with argl(p); while resume e do succeed; e := create spro-~(arg2~) \nwith arg2(p); while resume e do succeed; fail end; (This primitive implementation of salt does not provide \nfor reversal of effects caused by arguments that contain alterna- tives. A complete version of salt is \ngiven in Reference 2.) The procedure salt creates a context for its first argument and resumes its execution. \nAs long as it succeeds, salt succeeds. If the first argument fails, indicating that no further alternatives \nexist, salt creates a context for its second argument and resumes its execution, succeeding as long as \nit does. Finally, salt signals failure only after all of the alternatives for both arguments have been \nexhausted. A scanning procedure may invoke the scanner. Since subject and cursor are declared in scan, \neach instance of scan becomes a custodian for new occurrences of these identifiers. The free identi- \nfiers subject and aursor in scanning procedures that are invoked in the course of pattern matching controlled \nby the nested instance of scan refer to those identifiers in that custodian. This is illustrated in Figure \n4, which shows a creation history tree containing two instances of scan (indicated by S I and S 2) and \nsix instances of scanning pro- cedures (Ci through C6). Ci causes a nested invocation of scan. Thus S \nI is the custodian of the subject and cursor referenced in Ci, C2, and C6 while S 2 is the custodian \nof those identifiers in C3, C4, and C5. Figure 4. A Creation History Tree for the Scanner. The builtin \nscanner is implemented in the same fashion as scan, viz., subject and cursor are treated as public identifi- \ners in each instance of the builtin scanner. Thus the concept of public iden- tifiers and the interpretation \nchosen for free identifiers are what permit programmer-defined scanning procedures to \"adapt\" themselves \nto the builtin mechan- ism. They also make possible the replace- ment of the builtin scanner by a programmer-defined \nprocedure, such as scan, which is able to interact with either builtin or programmer-defined scanning \nprocedures. 5. Conclusions The determination of the scope of identifiers is a persistent problem in \nprogramming language design. The static scoping conventions of most high-level languages, such as Algol \n60, are due in part to the atomic nature of traditional procedure activation. It is elear that in order \nto support the decomposition of pro- cedure activation described in this paper, the static mechanisms \nare inappropriate, and additional language features are required in order to perform functions such as \nbacktracking [1,8]. The decomposition of procedure activa- tion into separate components gives the programmer \nthe control, at the linguistic level, that is necessary for applications that involve sophisticated processes. \nThis decomposition and the implications of program manipulation of procedures and  contexts as data \nobjects have motivated the scoping conventions and dynamic inter- pretation of free identifiers used \nin SL5. The effect is a means for inter-procedure communication as well as a method of avoiding inter-procedure \ninterference. Initial experience indicates that the SL5 procedure mechanism does provide a research \ntool of sufficient generality for experimentation in the areas mentioned at the beginning of this paper. \nThe facilities allow significant language extensions to be made without changing the base implementation \nof SL5. For example, the scanner can be written completely in SL5 without loss of generality. As illus- \ntrated by scan, the ability to create and manipulate procedure contexts independent- ly of argument binding \nor invocation allows the programmer to adapt the general mechanism to a specific experimental application. \n References I. Bobrow, D. G. and Wegbreit, B. \"A Model and Stack Implementation of Multiple Environments\", \nCommunications of the ACM, Vol. 6, No. i0, 591-603 (October 1973). 2. Doyle, J. N. A Generalized Facility \nfor the Analysis and Synthesis of Strings and a Procedure-Based Model of an Implementation, SNOBOL4 Project \nDocument $4D48, The University of Arizona, Tucson, February 1975. . Druseikis, F. C. and Doyle, J. \nN. \"A Procedural Approach to Pattern Matching in SNOBOL4\", Proceedings of the ACM Annual Conference, \n311-317 (November 1974).  4. Griswold, R. E. \"Extensible Pattern Matching in SNOBOL4\", Proceedings of \nthe ACM Annual Conference, 248-252 (October 1975). . Griswold, R. E. and Hanson, D. R. An Overview \nof the SL5 Programming Language, SL5 Project Document S5LDi, The University of Arizona, Tucson, 1975. \n . Hallyburton, J. C., Jr. Advanced Data Structure Manipulation Facilities for the SNOBOL4 Programming \nLanguage, Ph.D. Dissertation, The University of Arizona, May 1974. . Knuth, D. E. The Art of Computer \nProgramming, Volume 2, Seminumerical Algorithms, Addison-Wesley, Reading, Mass., 1969, p. 9. . Prenner, \nC., Spitzen, J. and Wegbreit, B. \"An Implementation of Backtracking for Programming Languages\", Proceedings \nof the ACM Annual Conference, 763-771 (August 1972). \n\t\t\t", "proc_id": "800168", "abstract": "<p>SL5 is a programming language developed for experimental work in generalized pattern matching and high-level data structuring and access mechanisms. This paper describes the procedure mechanism and the conventions for the interpretation of identifiers in SL5. Procedure invocation in SL5 is decomposed into the separate source-language operations of context creation, argument binding and procedure activation, and allows SL5 procedures to be used as recursive functions or coroutines. This decomposition has led to rules for scoping and for the interpretation of identifiers that are different from those found in other programming languages. Several examples of SL5 procedures are given, including a scanner based on the coroutine model of pattern matching.</p>", "authors": [{"name": "Dianne E. Britton", "author_profile_id": "81541268056", "affiliation": "", "person_id": "PP309177100", "email_address": "", "orcid_id": ""}, {"name": "Frederick C. Druseiks", "author_profile_id": "81100553110", "affiliation": "", "person_id": "P340900", "email_address": "", "orcid_id": ""}, {"name": "Ralph E. Griswold", "author_profile_id": "81100430761", "affiliation": "", "person_id": "PP39042475", "email_address": "", "orcid_id": ""}, {"name": "David R. Hanson", "author_profile_id": "81100646433", "affiliation": "", "person_id": "PP39052292", "email_address": "", "orcid_id": ""}, {"name": "Richard A. Holmes", "author_profile_id": "81538450356", "affiliation": "", "person_id": "P342271", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800168.811552", "year": "1976", "article_id": "811552", "conference": "POPL", "title": "Procedure referencing environments in SL5", "url": "http://dl.acm.org/citation.cfm?id=811552"}