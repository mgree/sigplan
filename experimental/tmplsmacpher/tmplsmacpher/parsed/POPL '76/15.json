{"article_publication_date": "01-01-1976", "fulltext": "\n PRIMITIVE RECURSIVE PROGRAM TRANSFORMATION R. S. Boyer, IJ S. Moore, 2 and R. E. Shostak 3  ABSTRACT \nWe describe how to transform certain flowchart programs into equivalent explicit primitive recursive \nproerams. The input/outl~Ut correctness conditions for the trar~sformed proerams are more amenable to \nproof thai the verification cow~ditions for the corresponding flowchart programs. In particular, the \ntransformed correctness conditions can often be verified automatically by the theorem prover developed \nby Boyer and Moore [I]. KEY WORDS flowcharts, LISP, program verification, structural induction, theorem \nproving. INTRODUCTION Experiments with the theorem prover developed by R. Boyer and J Moore [I] have \nshown that structural induction in combination with symbolic evaluation and some generalization heuristics \ncan be used to prove properties of a wide variety of LISP functions completely automatically. The key \nproperty of these functions making them amenable to induction is their explicit primitive recursive specification. \nRoughly speaking, the explicit primitive recursive form produces the effect that when the formula to \nbe proved in the induction conclusion is symbolically evaluated, it assumes the form of the induction \nhypothesis. In order to use the theorem prover on flowchart programs, it is necessary to translate the \nflowcharts into functional form. The easiest approach is that described in McCarthy [3] which produces \npartial recursive specifications. One is then forced either to extend the theorem prover to cope with \na limited class Of partial recursive specifications tag Moore does in [4]) or to further transform these \nspecifications (where possible) into explicit primitive recursion. In this paper we are concerned with \nthe second approach. I R.S. Boyer is employed by Stanford Re:~earch Institute, Menlo Park, California. \nThis work was supported in part by ONR Contract N~. N00014-75-C-U3/6.2 J S. Moore is employed by Xerox \nPalo Alto Research Center, Palo Alto, California. 3 R. E. Shosltak is empluyed by Stanford Research lastitute. \nMcnlo l,ark, Cali,ornia. This work was supported in part by AFOSR Contract No. F44620-73- C-006g. Of \ncourse, not all programs compute primitive recursive functions (for example, programs that compute Ackermann's \nfunction or that interpret FORTRAN programs compute partial recursive, but not primitive recursive functions.) \nFurthermore, it is undecidable whether a function for which a partial recursive definition is given is \nprimitive rccursive. Thus. the method described here is not applicable to arbitrary flowchart programs, \nbut only to those fitting certain schemes known to describe primitive recursive functions. AN EXAMPLE \nOur approach is best outlined with an example. Although we have restricted our presentation to the domain \nof lists and numbers, the general ideas are more broadly applicable. Figure I shows a flowcbart program \ncomputing the fvnction int(::) that converts a binary number represented as a list of l's and O's into \nan integer. The program scans the input list from left to right. At each position scanned, it doubles \nthe value of an accunmlator A and adds the wdue of the scanned bit. After all bits have been scanned, \nthe value of the accumtdator is returned. Consider the theorem stating that left-shifting a binary number \n(i.e.. tacking a 0 onto the right end) has the effect of doubling that number's value: il) int(append(L,list(0))) \n= 2*int(L), where 1, is understood to be a universally quantified variable ranging over all lists of \nl's and 0's. The first step in proving tile theorem is to convert the flowchart program into functional \nform. McCarthy [3] has shown that one can do this in a mechanical way for arbitrary flowchart programs \nby introducing a new recursive function for each tag point, h} the above example, one obtains: int(x) \n= intl(x,O), intCx ) O I  X ~- X 0 j I I [ return(a) ~No ii i I x ~-calf(x) ] FIGUIIE l where int \nl(x,a) = if x : Nil, then a; else int l(cdr(x) , ear (x)+2*a) . The theorem to be proved can now be \nstated: (2) intt(append(L,list(O)),O) = 2*intl(L,0). One might now be tempted to try to prove (2) using \nstructural induction on L. The basis case, L = NIL, goes through easily because both sides of (2) symbolically \nevaluate to 0. The induction step, however, does not go through. For that step, one assumes the induction \nhypothesis (1), and tries to prove: (3) intl(append(cons(B,L), list(O)),0) = 2\" int 1 (cons(B, L) ,0), \nwhere 13 is a variable ranging over the set {0, I}. Symbolically evaluating both sides of (3) gives: \n(4) intl(append(L,list(0)),B) : 2*intl(L,B). At this point, if all had gone well, we would have been \nable to invoke the induction hypothesis (2) and been done. But although (4) is similar to (2), it is \nnot quite the same. Specifically, the second argument place of intl is filled with 0 in the one case \nand with B in the other. The source of the difficulty is that the form of the definition of intl is not \nprimitive recursive. In partictdar, the primitive recursive form requires all parameters but the \"control\" \nparameter (i.e., the one in the first argument position of intl) to be tmmodified in the internal recursive \ncalls. In the definition of intl, however, the second argument is changed from a to car(x)+2*a. TRANSFORMATION \nTO PRIMITIVE RECURSION The solution we propose here is to transform the non-primitive recursive definition \nof intl into one that is primitive recursive. The transformation works on all functions that are instances \nof the scheme: f(x,y) : if p(x) then g(x,y) else f(n(x),h(x,y)), where p, g, n, and h are primitive \nrecursive. The primitive recursive transform of f is f': f'(x,y) : g(finalx(x),finaly(rev(seqx(x)),y)) \n where finalx, finaly, and seqx are primitive recursive functions whose definitions are exhibited below: \nfinalx(x) : if p(x) then x else finalx(n(x)), finaly(xl,y) : if xl=NIL then y else h(car(xl), finaly(cdr(xl),y), \nseqx(x) : if p(x) then NIL else eons(x,seqx(n(x))), and rev is the primitive recursive function which \nreverses a list: rev(x) : if x=NIL then NIL else append(rev(cdr(x)). list(car(x))). The justification \nfor the theorem: f(Xo,Yo) f'(Xo,Yo) = is as follows: Let X i denote n~(XO) and let k be the smallest \nnon-negative integer such that P(Xk) , then (5) f(Xo,Yo) = g(X k, h(Xk_ 1, h(Xk_ 2 ..... h(X0,Y0)...)) \n). However, finalx(X0) = X k and seqx(X0) = (X 0 X 1 ... Xk_l). Thus, rev(seqx(X0) ) = (Xk_ 1 Xk- 2 \n... X 1 X 0) SO that finaly(rev(seqx(Xo)),Y O) = h(Xk- 1,h(xk_ 2 ..... h(X0,Y0)...)). Therefore, r'(Xo,Y \no) g(X k,h(Xk_ 1 ,h(Xk_ 2 .... h(X 0,Y0 ) . . )) ), which is just f(X0,Y0) by (5). Informally, seqx \nconstructs a list of the successive values x will take on during the computation of f. This list, in \nreverse order, is then given to finaly which computes the final value of the \"accumulator\" y. This value, \nand that of finalx which is the final value of x, is then given to g to compute the final output of f. \nIn the special case where p(x) is x=NIL, n(x) is edr(x), and h(x,y) can be expressed as a function, h', \nof car(x) and y the transform is simpler: f'(x,y) = g(NIL,finaly(rev(x),y)), where we use h' for h in \nthe definition of finaly. The informal justification of this is that if the final y can be computed only \nin terms of the car's of the successive values of x, then we need not compute the sequence of x values \nbut merely the sequence of car(x) values. But if p and n are as above this sequence is just x. It is \neasy to see that intl is an instance of the scheme described by f, and in fact is an example of the simpler \ncase, since we can let: p(x) = x=NIL g(x,y) = y n(x) = cdr(x) h(x,y) = car(x) + 2*y. Thus, we get: intl'(x,a) \n= finala(rev(x),a). where finala is: finala(x,a) = if x=NIL then a else car (x)+2* f ina la(cdr (x) , \na). Given this definition of intl', the example theorem: (2) intl(append(L,list(0)),0) = 2*iatl(L,0), \nbecomes: finala( rev(app(L, l i st(0)) ),0) = 2*finala(rev(L) ,0). While this theorem is somewhat more \ncomplicated (syntactically) than (2), all of tile functions in it are primitive recursive and it can \nbe proved immediately by the theorem prover described in [I]. DISCUSSION The idea that flowchart programs \ncan sometimes be replaced by eqnivalent explicit primitive rectlrsive functions was first mentioned in \nthe 1934 work of R. Peter [5]. To quote from Peler ([5], pp. 69): \"5. It may be seen in a similar way \nthat in general a recursion of the form q~(O,a) = a(a), ~(n+ I,a) : fl(n,a,q~(n,y 1 (n'a))'\u00a2P (n'7 2(n'a))'\"\"~(n \n'7 k(n'a))) and even a definition of the form m(O,a l,...,ar) = a(a i,...,ar), ~(n+ I,a l,...,ar) : \nfl(n,a i ,...,ar, q0(n,y I 1 (n'c~ I '\"\"a r )'''''Y I r (n'a I \"\"'ar ))' ~(n'Y 21 (n,a i ,...,C~r),...,y \n2r(n,ct i ,...,a r)), q0(n,Yk i (n,c~ i,..-,ar),...,Ykr(n,a i,...,Ctr))) of a function with arbitrarily \nmany argument places does not lead out from \" the class of primitive recursive functions.\" Peter's result \nfor the two argument case is easily seen, since it is just the theorcm: f(Xo,Yo) = f'(Xo,Yo), justified \nabove. This theorem can actually be proved completely automatically by the modified theorem prover described \nin [4]. Peter's proof of the theorem is somewhat complicated because she carries it out in number theory \nwhere a Goedel enumeration method must be used to express the notion of the list of x's used in the computation \nof f4. As noted in the introduction, it is possible to avoid the translation of the partial recursive \nspecifications into primitive recursive ones and still prove many theorems. Moore [4] describes how. \nRoughly stated, Moore's approach requires Iwo enrichments of the original theorem prover. First, the \ninduction principle must be strengthened .~o that to prove CO(X,Y) for all X and Y, where Y is used as \nan accumulator in some function f in cO, one first proves CO(0,Y) for all Y, and then inductively assumes \nCO(X,e(X+i,Y)) for any expression e, and proves CO(X+I,Y). Moore explains why this is a valid induction \nprinciple (also cf. Goodstein [2], pp. 123). The choice of the expression e is left to the theorem proving \nprocess, and Moore explains how it can be determined from the definition of f. The second augmentation \nrequired in [4] is the extension of the generalization heuristic so that accumulator argument positions \nwhich initially contain constants can be replaced by expressions containing free variables, allowing \nthe use of the induction method above. This generalization introduces a new function, called the \"accumulator \nfunction\", into the accumulator positions. It turns out that Moore's accun)ulator function is just our \nfinaly. The method of translation into primitive recursive form proposed in this paper does not require \neither the enriched form of induction or the subtle generalization. We have found that proofs of many \ntheorems involving f' are complicated by the introduction of terms such as finaly(append(x,y),z), due \nto the expansion of the rex, call in f'. However, use of the lemma: This is a good example of why future \nnumber theory courses should be taught using Pure LISP as the meta- language. finaly(append(x,y) ,z) \n= finaly(x, finaly(y, z)), (which can be proved by the theorem prover) allows these terms to be further \nsimplified. Ill fact, the use of this equality usually yields the same lemma produced by accumulator \ngeneralization and induction in [4]. REFERENCES [1] Boyer, R.S. and Moore, J Strother. Proving theorems \nabout LISP functions. J. ACM 22, I (January 1975), pp. 83-105. [2] Goodstein, R. L. Studies in logic. \nNorth-Holland Publishing Company, Amsterdam, 1964. [3] McCarthy, J. Recursive functions of symbolic functions \nand their computation by machine. C. ACM, 3 (April 1960). [4] Moore, J Strother. Introducing iteration \ninto the Pure LISP Theorem Prover. IEEE Transactions on Software Engineering, SE-I, No. 3 (September \n1975), pp. 328- 338. [5] Peter, R. Rect, rsive functions. Academic Press, New York, 1967, pp. 63-69. \n  \n\t\t\t", "proc_id": "800168", "abstract": "<p>We describe how to transform certain flowchart programs into equivalent explicit primitive recursive programs. The input/output correctness conditions for the transformed programs are more amenable to proof than the verification conditions for the corresponding flowchart programs. In particular, the transformed correctness conditions can often be verified automatically by the theorem prover developed by Boyer and Moore [1].</p>", "authors": [{"name": "R. S. Boyer", "author_profile_id": "81406598712", "affiliation": "", "person_id": "PP43120149", "email_address": "", "orcid_id": ""}, {"name": "J. S. Moore", "author_profile_id": "81342504985", "affiliation": "", "person_id": "PP43115516", "email_address": "", "orcid_id": ""}, {"name": "R. E. Shostak", "author_profile_id": "81100217203", "affiliation": "", "person_id": "PP39032963", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800168.811550", "year": "1976", "article_id": "811550", "conference": "POPL", "title": "Primitive recursive program transformation", "url": "http://dl.acm.org/citation.cfm?id=811550"}