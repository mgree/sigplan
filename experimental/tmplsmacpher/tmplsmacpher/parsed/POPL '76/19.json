{"article_publication_date": "01-01-1976", "fulltext": "\n TEST DATA AS AN AID IN PROVING PROGRAM CORRECTNESS Matthew Geller Department of Computer and Communication \nSciences The University of Michigan Ann Arbor, Michigan Abstract Proofs of program correctness tend \nto be long and tedious whereas testing, though useful in detecting errors, usually does not guarantee \ncorrectness. This paper introduces a technique whereby test data can be used in proving program correctness. \nIn addition to simplifying certifi- cation of correctness, this method simplifies the process of providing \nspecifications for a pro- gram. The applicability of this technique to procedures, recursive programs, \nand modular pro- grams is demonstrated. Keywords and Phrases: program verification, pro- gram testing, \nmodular programming, recursive pro- grams, inductive assertions. CR Categories: 4.22, 4.6, 5.24 i. \nIntroduction Traditionally, certification of programs has been attempted by \"testing\" programs on \"representative\" \ntest data. The problem with this kind of testing was aptly pointed out by Dijkstra when he stated Progrmn \ntesting can be used to show the presence of bugs, but never to show their absence.t Recently, several \nattempts have been made to provide techniques for choosing test data that would allow one to make meaningful \ncon- clusions about the absence of bugs in a pro- gram as a result of test runs. Much research has been \ndone in the area of choosing test data that exercises ~all the statements or paths of a program, cf. \nHowden [1974], Miller and Melton [1975]. The chief weakness in these techniques is that they do not match \nthe choice of test data to the specifica- tions for the program. Therefore, if a program is written which \nfails to examine a particular case, this error will not be detected using test data determined by the \nprogram as written. The type of error in which one completely forgets to handle some special kind of \ninput occurs quite often in programming. tDahl, Dijkstra, and Hoare, Structured Program- ming, p. 6. \n A new approach entails testing programs with symbolic as opposed to real values. Systems to symbolically \nexecute programs have been implemented by King [1975] and Boyer, Elspas, and Levitt [1975]. These systems \nhave proven very useful in providing information for debugging programs. How- ever, it is not always \nclear how to use all this information to guarantee the \"absence of bugs\". Recently, much research has \nbeen done in the area of providing formal proof of program correct- ness. London [1975] eloquently summarizes \nmuch of this work, and discusses many of the problems involved in providing a formal proof of correct- \nness. A substantial bibliography of work in the field can be found in this paper. The chief dif- ficulty \nof proving a program correct is the com- plexity of the process. Proving a program cor- rect can be extremely \ntedious and difficult. It may be easier to convince oneself that a program works properly on the whole \ninput domain on the basis of a few test cases. Information gained from running a program on sample test \ndata is very easy to procure. The processor for the language automatically gives us values of given program \nvariables resulting from the input of sample test data. A special case in which the use of test data \nwill often save us work in proving a program correct occurs when we are proving a program cor- rect using \nstructural induction, cf. Burstall [1969]. The basis can always be proven by running the program on \nthe basis \"test data\". Boyer and Moore [1975] also discuss how one can obtain valu- able information \nabout a LISP program by running the program. The use of test data has an additional great advantage. \nGoodenough and Gerhart [197S] point out that a so-called \"proof\" of program correct- ness may not in \nfact guarantee that a program actually does what we want it to do. Of course, one may argue that in this \ncase one did not think carefully enough about the specifications for the program's correctness. There \nare certain in- stances, however, where the specifications for a program are intuitively clear, yet where \nit is in fact quite easy to make a mistake in precisely stating these specifications. The specification \nproblem is discussed in depth by Liskov and Zilles [1975]. In this paper, we use the example of the \n calendar. We are all quite familiar with how a calendar works, yet in formalizing these notions, it \nit quite easy to make errors. This is espe- 209 cially easy when specifying the behavior of a cal- endar \nat month boundaries. One must realize at this point that \"proving\" a program correct is only worthwhile \nin that the specifications for a program somehow provide us additional assurance that a program is doing \nwhat we want it to do, above and beyond the program it- self. One can always, in fact, say that a pro- \ngram is \"correct\" by using a program as its own specifications. In order that we assure ourselves that \na program in fact behaves correctly at cer- tain boundary points, or anomalies, it may be extremely helpful \nto include in our specifica- tions the specific behavior that our program should obey at these points. \nOne might then be able to specify how the program should behave on the whole input domain as a function \nof its speci- fications for this test data. We wish to formalize these informal tech- niques whereby \none generalizes from specific test cases to a large domain. In this paper, we will suggest a technique \nwhereby information gained from testing a program can be used in helping to prove program correctness. \nViewed conversely, we might view the process of choosing test data for a program as being guided by a \npursuit of infor- mation useful in helping us prove our program correct. We wish to provide techniques \nwhich will allow us to make statements about a large, pos- sibly infinite set of inputs on the basis \nof some small set of inputs. Goodenough and Gerhart [1975] divide the input domain into a set of classes, \nand then prove that for each of these classes, if some single member of this class gives a correct answer \non testing, then every member of that class will produce the correct answer. Sintzoff [1972] also uses \nvaluation to verify certain properties of programs. Henderson [1975] validates programs by testing its \ncomponents in an environment provided by a finite state ma- chine. In this paper, we will divide the \ninput do- main into classes in order to prove inductive assertions at given points in the program, rather \nthan to attempt the more ambitious tasks of dividing the input domain into equivalence classes based \nsimply on output specifications. We wish to execute sections of a program as they are being developed, \nrather than to go to great pains to find test data that will exer- cise all statements or paths of a \nprogram that has been already written. Note that the techniques we shall discuss will provide a formal \nmeans of proving program correctness. They might be viewed as a special proof technique that may be useful \nin many cir- cumstances. They will be shown to be of particu- lar value in large, modularized programs, \ncf. Parnas [1972]. Before continuing, it seems necessary to dis- cuss some of the things that testing \nin fact can- not accomplish.' It has often been stated that testing has an advantage over proving program \ncor- rectness in that it detects run-time errors, such as out-of-bounds array references, which could \nnot be detected using proof techniques. This is mis- leading since one can and should show that all \narray references are in bounds as part of a proof of program correctness. A further argument for testing \nas opposed to proving correctness goes as follows. In proving program correctness, one might forget \nentirely that an array reference may be out of bounds. Testing the program might detect this error. The \nweakness of this approach is that if we are lucky enough to choose appropriate test data, the error \nwill show up during the test run. However, the test data that we choose may not detect this error. It \nmay, in fact, require a great deal of computation to find the particular test data that will cause \nan error. If we have gathered enough information to calculate test data that will guarantee that all \nreferences to arrays are in bounds, then it might have been easier to formally prove this property. \n The paper is divided into four sections. Section 2 will give the formalism that will be used. Section \n3 illustrates the use of this model with examples. In Section 4, conclusions are drawn and suggestions \nare made for further re- search. 2. The Model We shall begin this section with the model that we will \nuse to prove programs correct using test data. We will then provide two theorems that will be useful \nin generalizing test data from specific data to larger classes of data. In order to allow for the use \nof test data in proving program correctness, we must introduce the notion of distributed correctness. \nAccording to the model of Floyd [1967], in order to prove a program correct, one must show that for input \nthat meets the input criteria, that after running the program, the output variables must satisfy the \noutput predicates. We see that all the specifi- cations for the program are provided at the point of \ntermination of execution. In order to use test data to its fullest advantage, we must allow the prover \nto use as data the value of any variable in the program at any point in the execution of the program. \nIn order to check that the value of this variable is correct at this point, we must be able to set criteria \nthat the program should obey for the given test data at any point in the program. The use of distributed \ncorrectness will buy us much more than allowing us to use test data to prove a program correct. It will \nin addition allow us to greatly reduce the size of assertions throughout the program. Now, rather than \ncarrying a complicated predi- cate through the programs, until it is used in the output predicate, we \nsimply carry with us the fact that in some given respect, the program is correct. One need now only show \nthat this cor- rectness is maintained at any point at which we need to use it to prove further facts \nabout the program. Consider for example a compiler which is driven by a precedence parser. Part of \nthe pro- gram consists of initializing the tables of this parser. An output specification for the program \nwould have to have as one of the disjuncts the specifications for each of the entries in the table. It \nwould be necessary essentially to repeat the part of the program that initializes the table Even if there \nare errors in the table, this process is useless, since the person proving the program is likely to make \nexactly the same error in the specifications as in the pro- gram itself. We see here that we have provided \nno additional assurance that our program is cor- rect. Rather than stating as part of the out- put predicate \nthe entries of the table, one would only specify as part of the output predicate that the tables were \nin fact correct. One could then certify that the table was correct at the point in the program immediately \nafter the table had been created. One would then need only prove that the table was not changed after \nits creation, to assure that the correctness of the table was maintained to satisfy the output predicate. \n We now describe the assertions that we shall use in proving a program correct using test data. These \nassertions will be assigned to arcs of the program flow graph, as in Floyd [1967]. Each assertion consists \nof three parts, namely (i) Test data assertion (2) Generalization assertion and (3) Synthesized assertion. \n The test data assertion gives the values that some given variable should have at a given arc of the \nflow graph based on a given value of that variable entering that arc. The generaliza- tion assertion \nwill be some assertion which gen- eralizes from the value produced by the program for some given test \nvalue to a larger domain. That is, it will be an assertion that states \"If a program behaves a certain \nway on some given test data, perturbing the input data in a given fashion perturbs the output in a given \nfashion.\" For a synthesized assertion to hold, we must show that both the test data and generalization \nassertions are satisfiedand that the test data assertion and generalization assertion imply the synthesized \nassertion. Note that the proof that the test data assertion and generalization assertion imply the synthesized \nassertion can be done before testing the program. We now give a very simple example of what we have \nin mind. Example 2.1.. Consider the program IF X>0 THEN Y:=i ELSE Y:=0 Synthesized Assertion. if \nx>0 then y=l if x<0 then y=0 Test Data Assertion if x=l, y=l if x=0, y=0 Verification of Test Data \nAssertion This can be verified by running the program. Generalization Assertion Let f(x) be the value \nof y after executing the program with input variable x. For x > 0, f(x) = f(1). For x < O, f(x) = f(0). \n Proof. This follows immediately from the fact that 1 > 0 and 0 < 0, and the semantics of an IF-THEN-ELSE \nstatement. We now wish to prove our synthesized asser- tion using the test data assertion and the gener- \nalzation assertion. Proof of Synthesized Assertion. Let x > 0. Then f(x) = f(1) = I. Let x < 0. Then \nf(x) = f(o) = o. -[] This example is for illustrative purposes only. A simple proof that the synthesized \nasser- tion was satisfied could in fact be given without using test data. We now provide two theorems \nthat will be use- ful in proving a synthesized assertion, based on a test data assertion and a generalization \nasser- tion. These theorems are in no way meant to be a comprehensive set. They have been chosen in that \nthey represent two different ways in which one can generalize from test data. The first theorem shows \nhow one can generalize from test data when the output values can be divided by predicates into equivalence \nclasses in which the values are identical Definition 2.1. Let Qi,Q ......Q be predi- n cates on domain \nD, f a partial function on D. We say that f is totally determined by Qi,Q2,\"',  Qn if f(x) = k I whenever \n~Ql(X),~Q2(x),..., ~Qn- 1 (x), ~Qn (x) = k 2 whenever ~Qi(x),~Q2(x ) ..... ~Ore- 1 (x), Qn (x) = k \n3 whenever ~Ol(X),~Q2(x) ..... Qn- 1 (x) ,~ Qn (x) = k2nwhenever Qi(x),Q2(x) ..... Qn- i (x), Qn(x). \n This is a binary ordering. Example 2.2. Let D be the integers. Let Q1 be the predicate, x > 0. Let \nQ~ be the pre- dicate, x is even. Define f as foIlows. f(x) = 0 whenever x > 0, x is even. = 1 whenever \nx > O, x is odd = 2 whefi~ver x ~ 0, x is even. = 3 whenever x ~ 0, x is odd.  Then f is totally determined \nby x > 0, x is even. The following theorem shows how we can pick representative values from our domain \nto deter- mine the value of our function over the entire domain.  in x I .... ,x n, subtractive in \nYl .... 'Ym if Theorem 2 1. Let f and g be two partial functions on doamin D, both of which are totally \ndetermined by predicates Qi,Q2 ..... Qn on D. Let ~Ql(X),~Q2(x) ..... ~Qn_l(X),-qn(X) = Pl(X) ~Ql(X),~Q2(x) \n..... ~Qn_l(X),O.n(x) = P2(x) Q1 (x), Q2 (x) ..... %- 1 (x), Qn (x) = P 2n (x) Then Pl,''''P2n divide \nD into a set of equiva- lence classes Ei,...,E2n We now choose some set {x I .... ,x m} = T which consists \nof some represen- tative from each of the non-empty equivalence classes Assume f(xi) = g(xi) for 1 \n< i < m.  Then f(x) = g(x) for all x ~ D. Proof The proof of the theorem is immedi- ate. --[] We now \napply the theorem to our example Example 2 3 Choose D, Qi, Q~, f as in Z Example i. The non-empty \nequivalence classes are (x>0, x even), (x>0, x odd), (x<0, x even) and (x~0, x odd). Now we choose the \nset (4,3, -4,-3), elements from their respective equiva- lence classes. We see that we get (0,1,2,3) \nwhen f is applied to these elements. Let g be any other partial function defined on D. Suppose we know \nthat g(4) = 0, g(3) = l, g(-4) = 2, g(-3) = 3 and that g is totally determined by Q1 and Q2\" Then Theorem \n1 tells us that f = g. The theorem can be applied as follows. We let f be the function that is actually \ncomputed by some program P and g the specifications for P. We wish to prove that f = g. In order to \ndo this we must show two things, namely (I) the identical set of factors deter- mines how the program \nbehaves and how the pro- gram should behave, and  (2) the program behaves according to specifications \non the same test data.  Once we have shown these two facts, it will follow immediately from our theorem \nthat the pro- gram meets its specifications. Theorem 2.1 is used in proving the synthe- sized assertion \nafter line 4 in Example 3.2. Our second theorem will allow us to gener- alize from test data by showing \nthat on sample values the program meets its specifications, and that perturbing the test data in a given \nfashion has the same effect on the output of the program as on the value demanded by the specification \nWe first need a definition. Definition 2.2. We say that a function f(x I ..... Xn,Y 1 .... ,ym ) on \ndomain D is additive  f(x I ..... Xn,Yl,...,y m) = (Xl+...+Xn) -(yl+...+ym) +k where k is come constant. \n E__xample 2 4. Let f(x,y) = x-y+l. Then f(x,y) is additive in x, subtractive in y. We get the following \ntheorem Theorem 2.2. Let f and g be functions on D  that are additive in Xl,...,Xn, subtractive in \n YI' 'Ym' such that for some X~ o o .. , .. ,Xn,Y I, .., 0 0 0 0 0 0 Ym we have f(x I .... ,Xn,Yl,...,ym) \n= g(x I ..... Xn, y~ ..... ym\u00b0). Then for all x 1 ..... Xn' Yl ..... Ym we have f(x 1 .... ,Xn,Y 1 ..... \nym) = g(x I ..... Xn, Yl ..... Ym ) \" Proof. We have f(x I .... ,Xn,Y 1 ..... Ym ) = (Xl+ ..+x n) - \n (yl+Y2+. .+ym) + k , g(xl,...,Xn,Yl,...,ym) = (Xl+...+Xn) - (yl+Y2+...+ym) + I .  Since O O O O \nO f(x I .....Xn,Y 1 ..... Ym ) = g(x I ..... o o .,y~) , Xn,Y 1 ,  we have k = I. Therefore, f(x \nI .... ,Xn,Yl,...,ym ) = g(x I ..... Xn,Y 1 .... ,Ym ) []  Example 2 5. Suppose in some program we \nhave z = x -y + i. Let g(x,y) be some function that is additive in x, subtractive in y. Assume g(0,0) \n= i Then by Theorem 2.2, f(x,y) = g(x,y) for all x, y. Again, we let f represent the function com- puted \nby P, and g the specifications. In order to show that P meets its specifications, we must show that \n(i) the function meets is specification on the sample test data, x,  (2) the function computed by P, \nand the function defined by its specification are per- turbed in the same fashion as the value ~ is perturbed. \n  Theorem 2.2 is used in proving the synthe- sized assertion after line 5 in Example 3.2. 3. Examples \n In this section, three programs will be ver- ified using the techniques discussed in the pre- vious \nsection The programs that have been chosen can be verified using techniques that have been previously \ndiscussed in the literature. However, use of the techniques presented in this paper will in some cases \nsimplify the proof, and in most of the cases add to our confidence that the program is in fact accomplishing \nwhat it \"should\" accomplish. Example 3.1. Our first example is the famil- iar \"91\" function, cf. Manna \net. at. [1973], a re- cursive function often cited in the literature. The function is as follows: F(X) \n= IF x > i01 THEN x-10 ELSE F(F(x+ll)) We wish to show that the function computes the following values. \n for x > I01, F(x) = x -i0 for x < i01, F(x) = 91 where x is any integer. A typical proof of this \ntheorem is similar to one suggested in Manna et. al. [1973] as fol- lows. Proof of Example I. We have \nthree cases. Case i. x > I01. Clearly F(x) = x -I0. Case 2. i01 > x > 91. We wish to show that for \n0 < x < i0, that F(101-x) = 91. Basis: x = 0. We have F(101-x) = F(101) = 91 from Case i. Induction \nStem: We assume that for some x, where 0 < x < i0, we have F(101-x) < 91. Then F(101 -(x+l)) = F(100-x). \nSince 0--< x, we have (100-x) < i01. Therefore F(100-x) =--F(F(Iii-x)). Now, since X < I0, we have F(iii-x) \n= F(lll-x-10)= (101-x). Therefore F(100-x) = F(101-x). But, by our induction hypotheses, F(101-x) = 91. \n Case 3, 91 > x. We wish to show that for x, x ~ 0, that F(91-x) = 91. Basis: x = 0. We have F(91-x) \n= F(91) : 91 by Case 2. Induction Stem: We assume that for all x, 0 < x < X, where X > 0, we have F(91-x) \n= 91. Now F(91-(x+l)) = F~90-x). Since x > 0, we have F(90-x) = F(F(101-x)). If 0 < x < 15, we have F(101-x) \n= 91 by Case i. Therefore F(F(101-x)) = F(91). By Case 2, F(91) = 91. If x > I0, we have F(101-x) = F(91-(x-10)), \nwhere (x-10)--> 0. There- fore by our induction hypothesis, F(91-(x-10)) = 91. Thus F(F(101-x)) = F(91) \n= 91, by Case 2.0 We now give a proof of the correctness of this program using the techniques of Section \n2. Synthesized Assertion: For x >.i01, F(x) = x -I0, for x < I01, F(x) : 91 where x is any integer. \n Test Data Assertion. For all x such that 91 < x < 101, we have F(x) = 91. Verification of Test Data \nAssertion. We simply run our program with the values 91,92 ..... lO1 for x. We see that in each case, \nthe program behavior meets the specifications of our test  data assertion. We can now generalize from \nthese results to the domain of integers {I I I ~ I01}. Generalization Assertion. For any i, i < i0, \n we have f(i) = f(kJ(x) for some k > 1 and some x \"  such that 91 < x < I01. Proof. By induction \non (101 -i) DIV ii (where DIV represents integer division of the first argument by the second). Basis: \n(101-i) DIV Ii = 0. In this case 91 < i < i01, and the result is clearly true. Induction Step: We assume \nthat our proved assertion is true for (101-i) DIV ii = j, for some j > 0. Now choose 1 such that (i01-/) \nDIV Ii = j + i. Since j > 0, clearly 1 < 91. We have (i01 -(t+ll) + 11) DIV ii = j+l Therefore, (i01 \n-(/+ii)) DIV ii = j. It follows from our induction hypothesis that f(/+ll) = f(k)(x) for some k > l, \n91 < x < 101. But we know that f(/) = f(f(/+ll). Therefore f(/) = f(k+l)(x), and our Generalization \nAssertion holds. We are now ready to prove our Synthesized Assertion. Proof of Synthesized Assertion. \nIt follows directly from the program that for x > i01, F(x) = x -i0. It follows directly from our test \ndata assertion and generalization assertion that for x < I01, we have F(x) = 91. [] We see that our \nproof is substantially shorter than the first proof, and more intuitive. Notice how the use of test \ndata alone is insufficient to guarantee the correctness of the program. The technique suggested by some \nof breaking the input domain into classes on which the program gives the same value produces an infinite \nnumber of such classes, since a differ- ent result is produced for each x such that x > i01. Exampl \ne 3.2. For our second example, we choose a program which computes the number of days by which one date \nfollows another date in some given calendar year. This particular program was chosen on several grounds. \nAlthough the notion of the number of days between two days is easily understood, axiomatization of this \nconcept is quite difficult. Once we have provided an axio- matization for the correct numbers of days \nbe- tween two days, it is difficult to be sure that we have in fact chosen the correct axiomatization. \nIt is particularly easy for the axiomatization to specify answers that are off by one or two days in \ncertain cases. Since the calendar program involves setting up a table, the notion of distributed correctness \nwill allow us to greatly simplify our assertions, by allowing us to merely specify that the table is \nbe argued to hold directly from the semantics of correct. the statement DAYS :=DAY2 - DAY1. Comment. \nThe following procedure takes as input two dates in a given year, where a date is a pair (DAY,MONTH). \nWe assume that both dates are legitimate dates for the year in question, and that the first date does \nnot occur after the sec- ond date. The program computes the number of days by which the second date follows \nthe first date. PROCEDURE CALENDAR(DAYi,DAY2,MONTHi,MONTH2, YEAR); BEGIN (i) IF MONTH2=MONTHi THEN \nDAYS = DAY2 -DAY1 COMMENT IF THE DATES ARE IN THE SAME MONTH, WE CAN COMPUTE THE NUMBER OF DAYS BETWEEN \nTHEM IMMEDIATELY;  ELSE BEGIN DAYSIN(1) :=31; DAYSIN(3) :=31; DAYSIN(4) :=30; DAYSIN(5) :=31; DAYSIN(6) \n:=30; DAYSIN (7) :=31; DAYSIN(8) :=31; DAYSIN(9) :=30; DAYSIN(10) :=31;  (2) DAYSIN(ii) :=30; DAYSIN(12) \n:=31;  (3) IF ((YEAR MOD 4) ~ 0) OR ((YEAR MOD i00) = 0 AND (YEAR MOD 400) # '0\") THEN DAYSIN(2) :=28 \nELSE DAYSIN(2) :=29;  COMMENT SET DAYSIN(2) ACCORDING TO WHETHER OR NOT YEAR IS A LEAP YEAR;  (4) DAYS \n:=DAY2 + DAYSIN(MONTHI) - DAYi;  COMMENT THIS GIVES (THE CORRECT NUM- BER OF DAYS -DAYS IN COMPLETE \nINTER- VENING MONTHS); (5) FOR I = MONTH + i TO MONTH2 -I DO DAYS :=DAYSIN(I) + DAYS; COMMENT ADD \nIN THE DAYS IN COMPLETE INTERVENING MONTHS; END (6) PRINT (DAYS) END We now wish to verify the correctness \nof our procedure. Line i. We wish to prove the following synthe- sized assertion.  Synthesized Assertion. \nFor any two dates, DAYS gives the correct number of days by which the second date follows the first date, \nassuming that MONTH1 = MONTH2. It might at'first appear that our use of test data in this instance is \nunnecessary. One might argue that our synthesized assertion could easily Suppose, however, that we had \nreally wished to compute the number of days between the two dates, including the first and last days. \nIt would be very easy to err in the specifications for such a program, and on this basis argue that DAYS \ncorrectly computed this different quantity. This error, however, would be immediately detected by a choice \nof very simple test data. We now use the formalism of our technique to show that in fact DAYS is correctly \ncomputed to meet the specification of this program. We begin by providing the test data assertion. Test \nData Assertion. For DAY1 = 15, DAY2 = 15, we should have DAYS = 0 after execution of this statement. \n Our choice of the value 15 in particular was random. We could have chosen any other possible day of \nthe month. However, it was important that DAY1 and DAY2 were chosen to be very close to- gether. This \nallows us to easily state what the answer should be for the test data. Note that test data is useless \nunless it is simple to check whether or not the value produced by the program on the test data is correct. \nIf, in fact, one has to run the program to check what the value of the test data should be, then we have \ngained nothing by testing the program. Verification of Test Data Assertion. To verify the test data \nassertion, we now run the program from the point directly before where statement (I) lies, with DAY1 \n= 15, DAY2 = 15, and MONTH1 = MONTH2 = i. After executing state- ment (i), we check the value of DAYS. \nIn this case, since the program is correct, we find that we have the correct value of DAYS, namely O. \nNo- tice that since this statement is only executed once, the value 0 will be produced for the given \ntest data on every pass through this arc on the flow graph. We now need to be able to generalize from \nthis particular test data to any two particular days in the month. Our use of the generalization assertion \nwill make it clear why we chose DAY1 = DAY2. Our generalization assertion states that increasing DAY2 \nincreases DAYS in a certain fash- ion, increasing DAY1 decreases DAYS in a certain fashion. Generalization \nAssertion. DAYS is additive in DAY2, subtractive in DAY1. Verification of Generalization Assertion. \nWe see in our program that DAYS = DAY2 - DAY1. We now finally come to the point at which we prove the \nsynthesized assertion. Note that the test data assertion and generalization assertion were verified, \nthe test data assertion by use of test data, the generalizaed assertion logically. The synthesized assertion \nmust be shown to logi- cally follow from the test data assertion and generalization assertion.  214 \nProof of Synthesized Assertion. The proof follows directly from the test data assertion, the generalization \nassertion, and Theorem 2.2. [] Note how we have made use of the notion of distributive correctness here, \nby concluding that DAYS is \"correct\" under certain conditions. We now continue with out verification \nof the program. Line 2. This statement provides us with an example where the test data information \nprovides all the information that is necessary to assure us that this \"table\" of the number of days in \nall of the months but February is correct. The program in a sense provides its own documentation in creating \nthis table. It would certainly be valueless to add the values in this table as one of the dis- juncts \nin the output assertion of this program. We therefore have Test Data Assertion, Synthesized Assertion. \nDAYSIN(I) is correct for I = i, 3 < I < 12. One might object and say that the value of DAYSIN(I) for \nsome I might still be incorrect. This, of course, is true and the values inserted in the table should \nbe carefully checked. How- ever, the point still remains that the specifi- cations of a program can never \nbe guaranteed to correspond with what was \"meant\" to be done. Line 3.  We wish to show that line (3) \ncorrectly com- putes DAYSIN(2) for any possible year. Our syn- thesized assertion is: Sjnthesized Assertion. \nDAYSIN(2) is cor- rect.  Again, this could be shown by comparing some predicate that specified what \nthe program was supposed to compute, with the predicate actually computed by the program. Again, the \nproblem here is that these two predicates will probably be identical, and both could well be wrong. How- \never, if we allow ourselves the use of test data, we can check out the values produced on certain test \ndata by looking them up, perhaps in an al- manac. We will then be able to generalize from the specific \nyears used as test data to all years. Test Data Assertion. Our technique for choosing test data in this \nexample is similar to the technique used in Goodenough and Gerhart [1975], The major difference is that \nin this example, we are dividing the domain into classes locally. This is extremely crucial, since the \nnumber of test cases may grow exponentially in the number of factors we are considering. By def- inition, \ndividing our input into classes locally, the number of cases will be kept low. Our model is the limited \nentry decision ta- ble. Notice that not all of the combinations of predicates can be satisfied. We choose \none sam-  ple test data from each of the combinations of predicates that can be satisifed. Our particular \nchoice of test data should be motivated chiefly by simplicity of certifying the correctness of the value \nof the result. Our choice of test data in this example is given in Table 3.1. Table 3.1 Predicate \n YEAR MOD 4 # 0 / YEAR MOD 100 = 0 / / YEAR MOD 400 # 0 ~ / / Test Data 7 200 800 8 Correct Values \n28 28 29 29 / indicates that the given predicate is satisfied. Verification of Test Data Assertion. \nWe now run the statement on this sample test data, and find that the correct answers are generated. \nWe now wish to generalize from our test data.  Generalization Assertion. DAYSIN is totally determined \nby the predicates YEAR MOD 4 = 0, YEAR MOD I00 = 0, and YEAR MOD 400 # 0. Verification of Generalization \nAssertion. From the program, it is clear that DAYSIN is totally determined by the predicates YEAR MOD \n4 # 0, YEAR MOD i00 = 0, and YEAR MOD 400 # 0.  Notice that if we failed to consider some case, we \ncould still end up with a correctness \"proof\" of a program that did not do what we wanted. We have, however, \ngained the following advantages over a traditional correctness proof. First of all, we will catch an \nerror resulting from failingto combine the predicates correctly. Secondly, we are examining the predicates \nthat must be considered at the point in the program where these are to be considered, rather than at \nthe output arc. Finally, we prove our synthesized assertion.  Proof of Synthesized Assertion. The proof \nfollows directly from the test data assertion, the generalization assertion, and Theorem 2.1. [] Line \n4: Synthesized Assertion. DAYS = (# of days by which second date follows first date) (# of days in \ncomplete intervening months).  At this point, we wish to show that our pro- gram behaves properly over \nmonth boundaries. It is very simple here to make a mistake that will give answers that will be off by \none or even two days, both in the program and in its specifica- tions. We choose two days that are very \nclose together, yet in different months so that the answer produced can easily be cerified. In this particular \nexample, symbolic execution may be very helpful. We wish to show that the program gives us a 1 if DAYI \n= DAYSIN(1). The simplest way to do this is to symbolically execute the program with DAYSIN(I) as the \nsymbolic value of DAY1. Otherwise, we would have to execute the program with all possible values of DAYSIN(I) \nfor 1 < I < ii. We have the following Test Data Assertion. Let DAY1 = DAYSIN(I), MONTH(1) = I, DAY2 \n= i. Then DAYS = i. Verification of Test Data Assertion. We run the statement on the given symbolic \ntest data, and we find that DAYS = 1 after execution.  We now wish to generalize from this specific \ntest data. Our generalization assertion is Generalization Assertion. DAYS is additive in DAY2, subtractive \nin DAY1. Verification of Generalization Assertion. The assertion follows from the fact that DAYS = DAY2 \n+ DAYSIN(MONTH) DAY1, and that - DAYSIN(MONTHI) is independent of DAY2 and DAYI. Finally, we must \nprove our synthesized assertion.  Proof of Synthesized Assertion. \"The proof follows immediately from \nthe test data assertion, the generalization assertion, and Theorem 2.2. [] Line 5. The fifth line computes \nthe number of days in intervening months, and adds it to the value of DAYS that had been computed, giving \nus the number of days by which the second date follows the first. Synthesized Assertion. DAYS = number \nof days by which the second date follows the first. The proof of this assertion is greatly simplified \nby our use of distributed correct- ness. Proof. The lower and upper bounds of the FOR loop are MONTH2+1 \nand MONTH1-1. These are clearly the first and last complete intervening months. By the correctness of \nDAYSIN(I) for 1 < I < 12, proven after line 4, we know that this statement adds to DAYS the correct number \nof days in intervening months. Therefore after execution of line 5, we have DAYS = number of days by \nwhich second date follows first date - days in complete intervening month + days in complete intervening \nmonths. Therefore DAYS = number of days by which second date  follows first date. [] Line 6. Synthesized \nAssertion. The program prints the correct value of DAYS. Proof. If MONTH1 = MONTH2, then the program \nprints the correct value of DAYS. If MONTH1 # MONTH2, then the program prints the correct value of DAYS. \n[] Note that in this example, the proof follows directly from other assertions, and no test data information \nis really necessary or even desirable. Example 3.3. Our third and final example due to Parnas is reproduced \nfrom Robinson and Levitt [1975]. Similar examples can be found in Parnas [1972] and Hoare [1972]. It \nis reproduced below in Table 3.2. In this example, it is demonstrated that our testing techniques can \nbe extremely useful in verifying large programs. The example we use em- ploys Parnas modules, cf. Parnas \n[1972], to factor the program into pieces that can be verified. We shall show that our testing techniques \ncan be used to show the correctness of the behavior of each of these modules. Table 3.2 Register Module \nSpecification (Quotes signify value before application of func- tion.) integer V-Function: LENGTH Comment: \nRetu~is the number of occupied positions in the register. Initial value: LENGTH = 0 Exceptions: none \ninteger V-Function: CHAR (integer i) Comment: Returns the value of the i th element of the register. \nInitial value: Vi(CHAR(i) = undefined) Exceptions: I OUT OF BOUNDS: i < 0 ~ i>LENGTH 0-Function: INSERT \n(integer i,j) Comment: Inserts the value j after posi- tion i, moving subsequent values one position \nhigher. Exceptions: I OUT OF BOUNDS: i < 0 ~ i > LENGTH J OUT OF BOUNDS: j < 0 V j > 255 TOO LONG: LENGTH \n> 1000 Effects: LENGTH--= 'LENGTH' + 1 Vk (i < k < 'LENGTH' + i) [CHAR(k) = if k < i then 'CHAR'(k) \n else if k = i+l then j else 'CHAR'(k-i)] 0-Function: DELETE (integer i) th Comment: De-i~ ~he i element \nof the register, moving the subsequent values to fill in the gap. Exceptions: I OUT OF BOUNDS: i < 0 \n~ i>LENGTH UNDERFLOW: LENGTH = 0 Effects: LENGTH = 'LENGTH' -1 Vk (i < k < 'LENGTH' -I) [CHAR(k) = if \nk < i then 'CHAR' (k) else 'CHAR'(k+i)] CHAR('LENGTH') = undefined  216 Once the 0 and V functions \nhave been written, testing is ideal for checking whether or not they behave properly with respect to \nexception condi- tions. However, for this example, we concern our- selves mainly with the behavior of \nthe module as a whole. Robinson and Levitt [1975] cite four invari- ants that can be proven about the \nregister module, which they state are quite useful in shortening proof of programs that call the module. \nThese in- variants are (i) 0 < LENGTH < i000  (2) vi~0 < i < LENGTH DDEFINED(CHAR(i))).  (3) Vi(DEFINED(CHAR(i))D0<CHAR(i) \nS 255). (4) DEFINED(LENGTH).  We shall now sketch how testing can be used to verify the correctness \nof this module. For this example, we will present our arguments for cor- rectness in a style that a programmer \nmight wish to use in providing an informal argument for cor- rectness of his program. Only two of the \nfour are proven. In both of the proofs we shall present both test assertions and generalization assertions. \n (i) 0 < LENGTH < 1000.  Proof. Only the 0 functions can change the value of LENGTH. Therefore, we must \nprove that this invariant is preserved under the operations of INSERT and DELETE. We first check that \nLENGTH < i000 is an invariant. Since DELETE decreases' LENGTH, DELETE will cause no problems. For INSERT, \nwe have LENGTH = 'LENGTH' + i. It is clear that if the assertion is maintained for LENGTH = i000, the \nassertion will be maintained for any initial value of LENGTH. We run a test of INSERT with LENGTH = i000, \nand we find that an exception condition is generated. Next, we check that LENGTII > 0 is an invariant. \nSince INSERT increases LENGTH, INSERT will cause no problems. For DELETE, we have LENGTH = 'LENGTH' \ni. It is clear that if the assertion is main- tained for LENGTH = 0, the assertion will be maintained \nfor any initial value of LENGTH. We run a test of DELETE with LENGTH = 0, and find that an exception \ncondition is generated. [] (3) We wish to show V i(DEFINED(CHAR(i))~  0<CHAR(i)<255). We examine the \neffect of IN- SERT and DELETE on this invariant. It is easy to show that DELETE maintains this invariant. \nTo check if INSERT maintains the invariant, we execute calls INSERT(i,256) and INSERT(i,-1). We choose \n256 and -i since they lie immediately outside the boundaries of where CHAR(i) should be defined. Note \nthat i could be any value that we choose. We could either pick any value of i, and show that if the invariant \nis pre- served with some value of i, it is preserved with any value of i. If we had the facilities of \na symbolic executor, we might wish to execute our program with the symbol 'i'. We see that INSERT (i,256) \nand INSERT(i,-1) both generate exception conditions. Clearly, j > 256 and j < -1 will generate exception \nconditions based on general- izing from our test data.  have been very easy to make. Thus, our consider- \nation of test data results was crucial in arguing the invariance of these assertions. 4. Conclusions \n We have shown how information gained by testing a program may be useful in helping to prove the program \ncorrect. Rather than being antithetical to proving correctness, proper use of test data may in fact suggest \na simple strategy for proving programs correct. In the way in which we are using testing, the process \nin fact does not run counter to the ideas of structured programming Rather, it becomes an integral part \nof the process. When developing a program, it is quite natural to conceive of the programmer considering \nhow the program works on some specific examples, and trying to guarantee that in fact the program be- \nhaves in a similar fashion on the whole input domain. In the case of our calendar example, it was simpler \nto specify program behavior by speci- fying how it should behave on test data, and the use of test data \nsimplified the verification. The techniques described in this paper seem to formally model some of the \ninformal techniques used by programmers in checking the correctness of their programs. For practical \napplications, the techniques specified in this paper might be short-cut. For example, one might use these \ntechniques on larger chunks of code. By dealing with modules, we have shown how the technique is very \nflexible in terms of how large a chunk of code we deal with at a time. A great deal of work remains \nto be done in the area of using test data to prove program correctness. Some of the areas that should \nbe considered are: (i) Many additional theorems could be proven, similar to the ones in Section 2, to \nbe used in generalizing from specific test data to a larger domain.  (2) It would be useful to examine \ntech- niques for automatically generating test data. Techniques exist for automati- cally generating \nassertions, cf. Weg- breit [1974], Katz and Manna [1974]. Similar techniques might be used to automatically \ngenerate test data. This problem is probably very difficult.  (3) A system could be built for proving \nprograms correct using test data. Such a potential might be built into current symbolic execution systems. \n (4) The methods outlined in this paper should be tested against large-scale programs to examine their \nefficiency in either proving these programs as a whole, or in guaranteeing effectiveness of sections \nof these programs. The problem of testing interaction among modules of a large program should be examined \nfurther.  Acknowledgments  Notice how in both instances, the boundary I would like to acknowledge \nSusan L. Graham values were crucial points at which errors would and many graduate students of the Computer \nScience 217 Division at UC Berkeley, including Jeffrey Barth, 15. Miller, E.F. Jr. and Melton, R.A. \nAutomated Steven Glanville, Larry Ruzzo, Mark Wegman and generation of testcase datasets. Proceed- Amiram \nYehudai for their helpful suggestions. ings of International Conference on Reliable Bibliography i. \nBoyer, R.S., Elspas, B. and Levitt, K. SELECT - A formal system for testing and de- bugging programs \nby symbolic execution. Pro- ceeding s of International Conference on Reli- able Software (1975) pp. 234-245. \n 2. Boyer, R.S. and Moore, J.L. Proving theorems about LISP functions. Journal of the Associ- ation for \nComputing Machinery. Vol. 22 (Jan- uary 1975) pp. 129-144.  3. Burstall, R.M. Proving properties of \npro- grams by structural induction. Com~uter Journal, Vol. 12 (1969) pp. 41-48.  4. Dahl, O.J., Dijkstra, \nE.W. and Hoare, C.A.R. Structured Programming. Academic Press, London and New York, 1972.  5. Floyd, \nR.W. Assigning meanings to programs. Proceedings of a Symposium in Applie d Math- ~matics, Vol. 19 (J.T. \nSchwartz, ed.), Amer- ican Mathematics Sogiety (1967) pp. 19-32.  6. Goodenough, J.B. and Gerhart, S.L. \nToward a theory of test data selection. Proceedings of International Conference on Reliable Soft- ware \n(1975) pp. 493-510.  7. Henderson, P. Finite state modelling in pro- gram development. Proceedings of \nthe Inter- national Conference on Reliable Software  (1975) pp. 221-227.  8. Hoare, C.A.R. Proof of \ncorrectness of data representations. Acta Informatica, Vol. i, Fasc. 4 (1972) pp. 271-281.  9. Howden, \nW.E. Methodology for the generation of program test data. University of Califor- nia, Irvine, 1974. \n 10. Katz, S.M. and Manna, Z. Logical analysis of programs. The Weizmann Institute of Sci- ence, 1974. \n  ii. King, J.C. A new approach to program test- ing. proceedings of International Confer- ence on Reliable \nSoftware (1975) pp. 228- 233. 12. Liskov, B.H. and Zi'lles, S.N. Specifica- tion techniques for data \nabstractions. IEEE Transactions in Software Engineering, Vol. I, No. i, (March 1975) pp. 7-19.  13. \nLondon, R.L. A view of program verification. Proceedings of International Conference on Reliable Software \n(1975) pp. 534-545.  14. Manna, Z., Ness, S. and Vuillemin, J. Induc- tive methods for proving properties \nof pro- grams. Communications of the ACM 16, 8 (Au- gust 1973) pp. 491-502.  Software (1975) pp. 51-58. \n 16. Parnas, D.L. A technique for software module specification with examples. Communications of the \nACM 15, 5 (May 1972) pp. 330-336.  17. Robinson, L. and Levitt, K. Proof techniques for hierarchically \nstructured programs. Stanford Research Institute, Menlo Park, CA  (1975). 18. Sintzoff, M. Calculating \nproperties of pro- grams by valuations on specific models. Pro- ceedings of ACM Conference on Proving \nAsser- tions About Programs (January 1972) pp. 2'03- 207.  19. Wegbreit, B. The synthesis of loop predi- \ncates. Communications of the ACM 16, 2 (February 1974) pp. 102-112. 218 \n\t\t\t", "proc_id": "800168", "abstract": "<p>Proofs of program correctness tend to be long and tedious whereas testing, though useful in detecting errors, usually does not guarantee correctness. This paper introduces a technique whereby test data can be used in proving program correctness. In addition to simplifying certification of correctness, this method simplifies the process of providing specifications for a program. The applicability of this technique to procedures, recursive programs, and modular programs is demonstrated.</p>", "authors": [{"name": "Matthew Geller", "author_profile_id": "81536880256", "affiliation": "", "person_id": "PP31037504", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800168.811554", "year": "1976", "article_id": "811554", "conference": "POPL", "title": "Test data as an aid in proving program correctness", "url": "http://dl.acm.org/citation.cfm?id=811554"}