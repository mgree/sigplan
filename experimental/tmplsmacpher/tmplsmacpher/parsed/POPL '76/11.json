{"article_publication_date": "01-01-1976", "fulltext": "\n On Directly Constructing LR(k) Parsers Without Chain Reductions Wilf R. LaLonde Department of Systems \nEngineering Carleton University Ottawa, Canada. KiS 5B6 ABSTRACT A chain production is a production \nof the form A->M where A is a nonterminal and M is either a terminal or nonterminal. Pager in [PagS] \nhas presented an algorithm which removes all chain reductions from LR(1) parsers after they have been \nconstructed. In this paper, we present an algorithm for directly constructing LR(k) parsers with arbitrary \nsubsets of the chain productions, called the useless chain productions, optimized out. If this subset \nis empty, the algorithm is a standard one [And i, Kn]. If this subset consists of all chain productions, \nthe result is a parser with all chain reductions optimized away. The algor- ithm, as in [PagS], also \neliminates from the parsers all nonterminals which occur as the left part of useless chain productions. \nThis latter optimization along with the chain reduc- tion optimization significantly decreases the storage \nspace and execution times of the parsers. This provides an efficient solution of the open problem posed \nby Aho and Ullman [A&#38;U2] for all LR(k) grammars. INTRODUCTION In recent years, much attention has \nbeen focused on LR(k) techniques [Kor, DeRi, DeR2, Pagl to Pag4, A&#38;U2, A&#38;U3, Andl, And2, Jol, \nLaL]. Since LR(k) parsers are efficient and capable of parsing a large subset of the context free lan- \nguages, much of the effort has been devoted to decreasing its table storage space and increasing its \nparsing speed. One approach for doing this has been to eliminate useless chain reductions from the parsers \n[A&#38;U2, A&#38;U3, Andl, PagS]. How- ever, all of the techniques used above eliminate the chain reductions \nfrom the parsers after they have been constructed. In this paper, we present a technique for directly \nconstructing LR(k) parsers in such a way that reductions involving useless chain productions are eliminated. \nIn addition, all references to the nonterminals occurring as the left part of these productions are also \nelimi- nated. In practice, these two optimization significantly reduces the parser storage space and \nalso significantly increases the parsing speed. BACKGROUND In this section, we introduce the basic \nnotions necessary for the paper. A context free grammar (grammar for short) is a four-tuple G = (N,T,P,S) \nwhere N and T are finite disjoint sets of nonterminals and ter- minals respectively, S in N is the goal \nsymbol, and P is a finite set of productions of the form A->w where A, the left part, is in N and w, \nthe right part, is in (NUT)*. The vocabulary is NuT. For parsing purposes, we reserve ~ and 4, the left \nand right endmarker, as symbols dis- tinct from any used in the vocabulary of our grammars. We also assume \nthe productions are numbered 1,2,...,p in some order. We abbreviate productions A->wl, A->w2,...,A->wn \nby A->wll... I wn. Conventions: Let G = (N,T,P,S) be a grammar. (I) A,B,C denote nonterminals in N. \n(2) a,b,c denote terminals in T. (3) L,M,N denote nonterminals or terminals. (4) u,v denote strings in \nT* and w,x,y,z strings in (NUT)*. (5) e denotes the empty string. A production in P of the form A->M \nwhere M is in NuT is called a chain production. A useful chain production is one so declared by a user, \notherwise, is useless. For example, if a user has semantic actions associated with all pro- ductions, \nhe may declare all the chain produc- tions to be useful. Alternatively, he may declare only a subset \nto be useful --perhaps those in which the right part is a terminal, etc. If AO->Ai, Ai->A2, .... An-li>An \nis a se- quence of useless chain productions, we call AO a proper ancestor of An and An a proper descen- \ndant of AO. An ancestor (or descendant) of a symbol M in NUT is either M itself or a proper ancestor \n(or descendant) of M. A symbol without proper descendants is called a leaf (leaves in plural). A graph \nwhich displays this relationship is called an ancestor graph. Example Consider grammar G1 consisting \nof the four productions E->E+T I T, T->T*a I a. The ancestor graph of Gi, where all chain productions \nhave been declared useless, is shown in figure l(a). The ancestor graph of Gi, where only chain production \nE->T has been declared useless, is shown in figure l(b). // A grammar G = (N,T,P,S) is reduced if for \neach M in NuT, there is some derivation of the form S=>*xMy=>*w where w is in T*. We will assume that \nall our grammars are reduced. We define k:x as the first k symbols of x if Ixl> k I and as x otherwise. \nIf X is a set of strings in (NUT)*, we generalize k:X as {k:x I x is in X}. We further define FIRSTGK(X) \nas k:{w in T* I X=>G*W}. We drop G when no ambiguity arises. Example If G is a grammar with productions \nS->aSbS and S->e, then FIRSTi(S) = {e,a}, FIRSTi(b) = (b}, and FIRSTi(Sb) = {a,b}. // An augmented grammar \nassociated with a gram- mar G = (N,T,P,S) is a grammar G' = (Nu{S'},T,Pu {S'->S},S') where S' is a new \nnonterminal not in NuT. An LR(k) parsing machine M for grammar G = (N,T,P,S) based on the set Pu of \nuseless pro- ductions of G is-Ga finite state machine (FSM) with transition symbols of the form \"X\" or \n\"X if U\" where (I) X, an action of M, is an element of  (a) NuT (a shift action),  (b) P-Pu (a reduce \naction), or  (c) {Accept} (an accept action), and   (2) U, a lookahead set for X, is a subset of T* \nsuch that each w in U satisfies   lwl~k.  A reduce action of the form A->w where A->w is the ith production \nof G is also rep- resented by #i, a #-symbol (pronounced number symbol) of G. We represent a parsing \nmachine by its trans- ition graph. As it turns out, an LR(k) parsing machine has exactly one final state \nand this final state has no successors. For con- venience, we therefore leave the edges leading to this \nfinal state unterminated. A state of the parsing machine is inadequate if it contains at least two actions \none of which is a reduce action; otherwise it is adequate. Informally, a state is inadequate if \"lookahead\" \nis required to resolve between the actions of the state. This is not required for a state which is adequate. \n 1. Ixl stands for the length of x. Example The transition graph of an LR(1) parsing machine M1 for \nG1 is shown in figure 3(a). States 0, 2, 4, 5, and 7 are adequate; all others are inadequate. // The \nfollowing algorithm interprets LR(k) parsing machines. Algorithm 1 An LR(k) parsing machine interpreter. \n Input An LR(k) parsing machine M for grammer G = (N,T,P,S) and input string w in T*. Output A sequence \nof productions in P possibly followed by the word error. Method (i) [Initialize] Let IO be the initial \nstate of M and let  and ~ be the left and right end- marker. 2 Begin with current state p = IO, stack \ns = (~ ,IO), and current input string u : w 4. Iteratively perform step (2).  (2) [Perform one parse \nstep] Let u = au' and v = k:u. Perform one of (3), (4) 3 or (S) depending on which applies. J If none \napplies, output error and stop.  (3) [Shift Action] There exists a \"Shift a\" action in p with v in its \nlookahead set (if this set exists). Stack (a,q) where q is the a-successor of p, set p = q, and set u \n = U'. (4) [Reduce Action] There exists a \"Reduce A->w\" action in p with v in its lookahead set (if \nthis set exists). Output A->w, unstack lwl pairs from s leaving (M,q) as the top pair, stack (A,r) 4 \nwhere r is the B- successor of q and B is an arbitrary descendant of A which is a leaf, and set p = r. \n (s) [Accept Action] There exists an \"Accept\" action in p with v in its lookahead set (if this set exists). \nIf v # ~ , output error. In any case, stop.  2. Neither endmarker must be a member of NuT.  3. The \nadvantage of LR(k) parsing is that the choice is unique. Note also that the looka- head information is \nnot always needed.  4. Of course, q must contain a \"Shift B\" action. Also, it is well-known that only \nthe states are required for parsing purposes.  Example The result of applying algorithm 1 to M1 and \na+a*a is shown in figure 2(b). // The rest of the section contains the basic definitions used in the \nconstruction technique of the next section. Let G = (N,T,P,S) be a grammar and let Pu be the set of \nuseless chain productions of G. An LR(k) item for G is a pair <A->x.y#i,u> where A->xy is the ith production \nof P and lulSk. Symbol #i is called a #-symbol (pro- nounced number symbol). If the dot is to the left \nof symbol M, the LR(k) item is said to be an M-item (#-item if M is a #-symbol). If <A->x.y#i,u> is \nan LR(k) M-item of G, the action (and lookahead set) associated with it is either (i), (2), or (3) below \naccording to whether M is nonterminal B, terminal a, or #-symbol #i. (i) \"Shift B\",  (2) \"Shift a if \nV\" where V = FIRSTk(yu),  (3) \"Reduce A->w if {u)\" where A->w is the ith production of P.   We never \nassociate a lookahead set with nonterminal shift actions. Two actions are inconsistent if they are distinct \nand yet have non-disjoint lookahead sets; otherwise, they are consistent. Thus two actions, one of which \nis of type (i), must always be consistent. Two actions of the form \"Shift a if {u,...}\" and \"Reduce A->w \nif {u .... }\" are inconsistent. So are \"Reduce A->x i~ {u,...}\" and \"Reduce B->y if {u .... }\" for A->x#B->y. \n If there exists actions associated with distinct LR(k) items which are inconsistent, the LR(k) i'tems \nare also termed inconsistent; otherwise, they are termed consistent. A set of LR(k) items is consistent \nif every pair of items is consistent; otherwise, it is in- consistent. The Algorithm for Constructing \nLR(k) Parsers With Chain Production Optimizations Let G be a grammar and let Pu be the set of useless \nchain productions of G. We define relations-sand ~, the transition successor and immediate successor \nrelations respectively of G based on Pu below. Let I be the set of LR(k) items of G exclusive of those \nassociated with elements of Pu, and let M be a leaf of G. M = {(<A->x. Ly#i,u>, <A->xL.y#i,u>) in Ixl \nI L is an ancestor of M (which includes M)}. = {(<A->x. By#i,u>, <C->.z#j,v>) in IxI I C is a descendant \nof B (which includes B) and v is in FIRSTk(yu)) M  Relation =-=) is the transition M-successor of G \nbased on Pu. Relation-.mis the union of a-ll ,=~)such that M is a leaf of G. Example Consider grammar \nG1 of figure 1 where the productions have been numbered from 1 to 4. Suppose all chain productions are \ndeclared use- less. We compute the set PO.=--,)~*S where P0 = {<E->E.+T#1,+>}. We can write P1 = P0--~ \n= {<E->E+.T#1,+>}  P2 = P1 ~ = {<T->.T*P#3,+>} since T is a descendant of T and + is in FIRST l(e+) \n= FIRST1(+). Note that <T->.a#4,+> is not added since T->a is a useless chain production. P3 = P2~ = \n{<T->.T*P#3,*>} since * is in FIRSTi(*P+). P4 = P3~= P3. Thus the process is finished.  Therefore Q \n= {<E->E.+T#1,+>}-=~* = {<E->E+.T#1,+>, <T->.T*P#3,+>, <T->.T*P#3,*>}. Notice that Q T=|, is undefined \n\"V since T is not a leaf of G. However, Q a ~, is defined. Q0 = Q ~L = {<E->E+T.#1,+>, <T->T.*P#3,+% \n<T->T.*P#3,*>} since T is an ancestor of a. It shown that Q0~ is empty. Hence Q a ~* canQ~e // Algorithm \n2 Construction of LR(k) Parsing Machines. Input Grammar G, integer k, and set Pu of useless chain productions \nof G. Output The LR(k) parsing machine C for G based on Pu. Method Perform the following steps in succession. \n (i) [Initialize] Let G' = (N',T,P',S') be the augmented grammar for G = (N,T,P,S,) and number the productions \nso that S'->S is the 0th pro- duction of G' Let--~and ~ be the transition and immediate successor relations \n of G' based on Pu.  (2) [Compute the initial state] Add I0 = {<S'->.S#0:-~>} ~* 6 to the states of \nC (initially empty) and mark it \"unpro- cessed\".  (3) [Compute successor states] For each \"unprocessed\" \nstate R of C, mark R \"processed\", and for each leaf M such that R contains an LR(k) N-itemwhere N is \nmn ancestor__ of M (also for each #-symbol M), add R-~* to the states of C (as the M-suc- cessor of R) \nand mark it \"unprocessed\" if it is not already there. If M is a #-symbol, the successor state will be \nthe empty set. This state is taken as the sole final state of C.  (4) [Introduce an accept action] Replace \ntransition symbol #0 in state R 7 by  (a) \"Accept\" if R is adequate, or  (b) \"Accept if {4}\" if R is \ninadequate.   5. If R is a relation and X is a set, XR repre- sents the set {bl(a,b ) is in R and \na is in X} and XR* represents the smallest set A containing X such that if a is in A, then {a}R is contained \nin A. The set XRiR2...Rn represents (...((XRI)R2)...)Rn.  6. Symbol -~ is the right endmarker not in \nN'oT.  7. Only one state of C will contain transition symbol #0.  (s) [Introduce lookahead sets] For \neach inadequate state R of C, and each transition symbol M of R where M is either a terminal symbol or \n#-symbol, add the lookahead set L where L is the union of the lookahead sets associated with the LR(k) \nM-items of R. If the set of useless productions is empty, the above algorithm is a variant of Knuth's \nLR(k) table constructor [Kn, A&#38;Ui]. We will refer to the LR(k) parsing machine for G based on ~ as \nthe principle LR(k) parsing machine for G. As constructed, the actions of a parsing machine do not \nalways have associated lookahead sets. 8 However, it is possible to construct the parsing machine in \nsuch a way that the associated lookahead set is added to each action. When this is done, we say that \nthe parsing machine has forced lookahead sets. Example Figures 3 and 4 contain the incomplete (i.e. \nwithout lookahead) LR(1) parsing machines Cl and DI for G1 based on Pu = {E+T, T\u00f7a} and ~ respec- tively. \nThe completed LR(1) parsing machine Mi' for G1 based on {E\u00f7T, T\u00f7a} is shown in figure 5(a). The result \nof applying algorithm 1 to Mi' and a+a*a is shown in figure 5(b). It is instructive to compare the number \nof steps in figures 2(b) and 5(b). // Conditions For The Algorithm To Succeed In this section, we show \nthat the parsing machine M with forced lookahead obtained from an LR(k) grammar G with useless chain \nproductions Pu in conjunction with the interpreter i.e. algorithm 1 is in fact a parser for G which outputs \nan \"optimized\" bottom up parse of an input string in L(G) i.e. a sequence of produc- tions of G exclusive \nof those in Pu. We begin with some basic lemmas. Lemma 1 Let G be an LR(k) grammar, let <A\u00f7x. My#p,u> \nbe an LR(k) item in some state R of the principle LR(k) parsing machine for G, and let w be a string \nin FIRSTk(Myu). There exists in R an LR(k) item either of the form (I) <B\u00f7.#i,w>, or  (2) <B\u00f7~.az#i,v> \nwhere w is in FIRSTk(azv).   Proof Obvious. // Lemma 2 Let G be an LR(k) grammar, let C be the principle \nLR(k) CFSM for G, and let Bi, B2, A, and B be vocabulary symbols of G (B may be either a terminal or \nnonterminal) such that Bi=>*A=>B and B2=>*B by chain productions where each nonterminal of the derivations \n(except B) are different. If A\u00f7B is the rth production of G and LR(k) items <Al\u00f7xl. Blyl#p,ul> and <A2\u00f7x2.B2y2#q,u2> \n(the latter different from <A\u00f7.B#r,u2>) are in the same state R of C, then F = FIRSTk(ylul) N FIRSTk(y2u2) \n= ~.  Proof Consider S, the B-successor of R. Suppose the lemma is false. Then there exists a string \nw in F. Since Bi:>*A=>B and w is in FIRSTk(ylul), <A+.B#r,w> is in R. Therefore <A\u00f7B.#r,w> is in S. Now, \nconsider B2. If B2#B, there exists some nonterminal D#A such that B2=>*D=>B in the above derivation. \nTherefore there exists an LR(k) item of the form <D\u00f7.B#s,w> (for some #s) in R. Therefore <D-~B.#s,w> \nis in S and it is inconsistent with <A\u00f7B.#r,w> violating the condition that G is LR(k). If B2=B, LR(k) \nitem <A2\u00f7x2B2.y2#q,u2> is in S. If y2=e, it is inconsistent with <A*B.#r,w>, violating the condition \nthat G is LR(k). If y2#e, there also exists in S an LR(k) item either of the form <D-~.#i,w> or <D-~.az#i,v> \nwhere w is in FIRSTk(azv) by lemma i. But both of these are inconsistent with <A\u00f7B.#r,w>. // A pair \n<Al\u00f7xl.yl#i,ul> and <A2+x2.y2#j,u2> of LR(k) items satisfies the FIRSTk condition if FIRSTk(ylul)~FIRSTk(y2u2) \n= ~. Two sets S1 and $2 satisfy the FIRSTk condition if every pair of elements pl and p2 in S1 and $2 \nrespectively satisfy the FIRSTk condition. Lemma 3 Let G be an LR(k) grammar, let C be the principle \nLR(k) parsing machine for G, let R1 and R2 be states of C (not necessarily distinct), and let M1 and \nM2 be transition symbols of R1 and R2 respectively such that Mi=>*M and M2=>*M. If each pair of Mi- and \nM2-items in R1 and R2 respectively satisfies the FIRSTk condition, then so does each pair in the Ml-successor \nand M2-successor of R1 and R2 respectively. Proof If pl = <Al+xl.Mlyl#i,ul> and p2 = <A2+x2.M2y2#j,u2> \nare arbitrary LR(k) Mi- and M2-items in R1 and R2 respectively, then FIRSTk(Mlylul) ~FIRSTk(M2y2u2) = \n~. Since Mi=>*M and M2=>*M, M must generate strings of length less than k. Otherwise, the FIRSTk condition \nwould not hold. Let n be the maximum length of the generated strings. It follows that first of all FIRSTk_ \nn(ylul) n FIRSTk_ n(y2u2) = ~ and therefore FIRSTk(ylul)~ FIRSTk(y2u2) = ~ since l~k-n<k. // A proper \nsubset of a set of items is the largest subset which excludes those items associated with useless chain \nproductions. Lemma 4 Let G be an LR(k) grammar, let C be the principle LR(k) parsing machine for G, \nand let R1 and R2 be states of C with proper subsets S1 and $2 satisfying the FIRSTk condition. Then \nSIVS2 is consistent. Proof Obvious. // Theorem 1 Let G be a grammar, let Pu be a set of useless chain \nproductions of G, let C be the prin- ciple LR(k) parsing machine for G, and let C' be the LR(k) parsing \nmachine for G based on Pu. If G is LR(k), each state of C' is consistent. 8. This is because they are \nnot always necessary. Proof Suppose G is LR(k), If Pu is empty, there is nothing to prove since our \nalgorithm becomes the standard one. Suppose Pu is non-empty,  Suppose for induction that state R in \nC' is the union of the proper subsets of states Ri,R2,.. .,Rn in C pairwise satisfying the FIRSTk condition. \n For the basis, the initial state I' of C' consists of the proper subset of the initial state I of C. \nThe above is therefore satisfied trivially.  We wish to show that each successor of R satisfies the \nabove. Suppose R has an M-successor S. If M is a #-symbol, S is empty (trivially satisfying the above \ncondition). Otherwise, S is the union of the proper subsets of the following states in C: the L-successor \nof Ri (if it exists), l~i~n, where L is an ancestor of M. If only one such successor exists, we are done \nsince each state of C is consistent. Otherwise, consider any two such distinct successors S1 and $2. \nThen there exists some ancestors L1 and L2 of M and some p and q where l~p,q~n such that S1 is the Ll-successor \nof Rp and $2 is the L2-successor of Rq. If p#q, the proper subsets of S1 and $2 satisfy the FIRSTk condition \nby lemma 3. If p=q, then there exists some M' such that Li=>*M'=>*M and L2=>*M'=>*M by chain productions \nwhere every nonterminal (except M') in the derivations from L1 and L2 to M' are different. Suppose arbi-trarily \nthat L1 is different from M'. Then we can write Li=>*A=>M' and L2=>*M' for some nonterminal A. By lemma \n2, respective pairs of Mi- and M2-items in the proper subset of Rp=Rq satisfy the FIRSTk condition. By \nlemma 3, the proper subsets of S1 and $2 satisfy the FIRSTk condition. // If p0,pl,...,pn is a sequence \nof productions of G, the result of removing those productions which are members of Pu is said to be trimmed \naccording to Pu. Theorem 2 Let G be an LR(k) grammar, let Pu be the set of useless chain productions \nof G, and let C and C' be the LR(k) parsing machines with forced lookahead based on ~ and Pu respectively. \n If algorithm 1 with input C and w outputs (i) bottom up parse p0,pl .....pn or  (2) a partial bottom \nup parse followed  by error, then algorithm 1 with input C' and w respective- ly outputs (I) pO,pl \n.....pn trimmed according to Pu, or  (2) a partial bottom up parse trimmed according to Pu followed \nby error.  Proof It can be shown by induction that algorithm 1 with C' \"simulates\" all non-proper \n actions (those excluding reductions by useless chain productions) of algorithm 1 with C, including \nerror detection. The proof found in Pag5 for LR(1) grammars can be suitably generalized to LR(k) grammars. \n// If each state of C' (in the above theorem) is consistent, we claim that algorithm 1 with C' is a \n\"trimmed\" parser for G even if G is not LR(k). For instance, if G is S+AIB, A+a, B+a, then each state \nof the LR(k) parsing machine for G based on {A+a, B-~a} is consistent. If the parsing machine for G does \nnot have forced lookahead, there are cases where the parser (algorithm i) will fail to detect erroneous \nstrings (though it will work correctly for strings in L(G)). Consider the grammar S-+alblac. The LR(1) \nparsing machine for this grammar based on {S\u00f7a, S\u00f7b} is shown in figure 6. Algorithm 1 applied to this \nmachine accepts the string acc (among others) provided only that symbol a rather than symbol b be chosen \nas the arbitrary leaf descendant of S when reducing ac to S. On the other hand, if lookahead is forced, \nthe reduction of ac to S is possible only when the lookahead string is ~ (thus the error is detected). \n References [A6U1] A.V. Aho and J.D. Ullman, The Theory of Parsing, Translation, and Compiling. Prentice-Hall, \nEnglewood Cliffs, N.J.,1973 [A&#38;U2] A.V. Aho and J.D. Ullman, \"Optimization of LR(k) Parsers\", J. \nComputer and System Sciences, Vol. 6, Dec 72, pp. 573-602. [A&#38;U3] A.V. Aho and J.D. Ullman, \"A Technique \nfor Speeding Up LR(k) Parsers\", Siam J. Comp., Vol 2, June 73, pp. 106-127. [Andl] T. Anderson, \"Syntactical \nAnalysis of LR(k) Languages\", Ph.D. Thesis, Univ. of Newcastle Upon Tyne, Computing Lab. [And2] T. Anderson, \nJ. Eve, and J.J. Horning, \"Efficient LR(1) Parsers\", Acta Informatica 2 (1973), pp. 12-39. [DeR1] F.L. \nDeRemer, \"Practical Translators for LR(k) Languages\", Tech. Report MAC TR-65, Project MAC, Mass. Inst. \nof Tech., Cambridge, Oct 69. [DeR2] F.L. DeRemer, \"Simple LR(k) Grammars\", CACM, Vol. 14, July 71, pp. \n453-460. [Earl] J. Earley, \"An Efficient Context-Free Parsing Algorithm\", Ph.D. Thesis, Carnegie-Mellon \nUniv., Pittsburgh, PA. also see CACM 13:2, Feb 70, pp. 94-102. [Jol] M.L. Joliat, \"On The Reduced Matrix \nRepresentation of LR(k) Parser Tables\", Tech. Report CSRG-28, Computer Systems Research Group, Univ. \nof Toronto, Oct 73. [Knu] D.E. Knuth, \"On the Translation of Langua- ges from Left to Right\", Inf. Contr. \nVol. 8, Oct 65, pp. 607-639. [Kor] A.J. Korenjak, \"A Practical Method for Constructing LR(k) Processors\", \nCACM, Vol. 12, Nov 69, pp. 613-623. [LaL] W.R. LaLonde, \"An Efficient LALR Parser Generator\", Tech. \nReport CSRG-2, Computer Systems Research Group, Univ. of Toronto, Toronto, 1971. [Pagl] D. Pager, \"A \nSolution to an Open Problem by Knuth\", Inf. Contr., Vol. 17, Dec 70, pp. 462-473.  131 [Pag2 ] D. Pager, \n\"On Combining Compatible States in LR(k) Parsing\", Tech. Report PE 257, Information Sciences Program, \nUniv. of Hawaii, Honolulu, July 72. [Pag3] D. Pager, \"A Compaction Algorithm for Combining the Symbol-action \nLists of an LR(k) Parser\", Tech. Report PE 259, Univ. of Hawaii, July 72. [Pag4] D. Pager, \"On the Decremental \nApproach to Left-to-right Parsers\", to appear in Siam J. Computing.  [Pag5] D. Pager, \"On Eliminating \nUnit Productions from LR(k) Parsers\", Tech. Report from the Information Sciences Program, Univ. of Hawaii, \nHonolulu. List of Figures  (a) (b) The ancestor graph of Gl: The ancestor graph of Gl: E+E+TITT+T*.[. \nE-E+T[TT+T*.I. where all chain productions are where only E+T is a useless chain useless production \nFIG. I i~ STATE 2 STATE 4 The mCEPT l~ {4) STEP. P~MAINING ,NO. STAge l~Tlrr ) z ~o a+a*a 1 E 2 [0a4 \n@a'at T 8 ~T l 5 [0Ex+2r~ ~al {*} T+a * if {'1 f {~D+2T~*% v 4 t\u00b0r'+2T + .I [\u00b0E~ ~+g\u00f7T if {\u00f7,~} 12 \nACCEPT (.) (b) The trml~itiou grnph of hE(I) Using algorith~l with parsing t~achine E1 for Cl: input \nHI and a+~*a E~E4T{3 T,T+~]a }IC. p STATE 0 .__~ <E'*.E#O, {-~ }> [ \"g+\" E+T# I ' {+'~ }> I <z+.Z*a#3, \n{*,+,4 }>] .t <E'\u00f7E.#0,{4 }> I STATE 1 <E+E-+T#1 ,[+,~ } > #0 <T+T.*a#3, {*,+,~ }> I <T~T*.a#3, {*,+,q \n}> ~ STATE 3 [ <E+E+.T#I, {+,~ }> ] <T+~T*a.#3,{*,+,~}>~ STATE ~[<E+E+T.#1,{+,~}> \" --T \" I <T~'~#3,(*,+,q \n)>  \"~| \"1 \"incomplete\" LR(1) pa;sing machine for GI based on Pu ~ (E+T, T+a} GI: E+E+TIT T+Ttala Note: \nPu is the set of useless chain productions of GI FIG. 3 STAT I\u00b0 <S\"~'S#0'{II<S~.aC#3,{~ | | <S~a'c#3'{ \n}> I L STATE/o <E\u00f7.E\u00f7T#1, {+,.~ }> I <E~.T#2, {+,.~ ]> ] <T~.T,a#3, {,+, I }>] STATE'-M2 |<To.T,a#3, \n{*,+, ~ }>1|<T\u00f7. a#4, {*,+,.~ }> I /L --\"--'-T'---.L C if {c} [ l t:s: ,/:1A.....~S.#0,( ] Reduce S\u00f7ac \n#2 I<E-,,r.#2,~..l}, I ~\u00a3.#4,{;,+,~}>[ I \"1STATE 5 \" * !STATE 6 Tkc. LR(1) parsing ~chine for G based \non Pu G: S+alblac Pu = {S-~a, S,b} a STATE 7 I <T~T*v\" #3' {*'+'~ }>I #1 Fig. 6 The #3 i \"incomplete\" \nprinciple LR(1) parsing GI: E+E+TIT T~T*a[a FIG. 4 machine for Cl ~ ~ STEP. NO, STACK RE~LAINING INPUT \n ~CCEPT if <4 1 p -+~*~4 2 ~\u00b0a* +a'a4 4 ~\u00b0.l+3as *al 5 ~0al\u00f73aS*2 al e F\u00b0al+3aS*2a ~ T-~T*a E*E\u00f7T if \n{+,~ } (a) (b) The LR(1) parsing machine Mi' Using slsorithm I ~rfth input HI' for GI based on and a+a*a. \nNote: in step(7), Pu = {E-T, Tea} action \"Reduce T4T*a\" is interpreted. C1: E~E+T[T T~T*a[a Since syr~bol \na is n leaf descendant of T, the T-successor of 3 is taken as the e-successor of 3. Similarly for step(8). \n FIG. 5 \n\t\t\t", "proc_id": "800168", "abstract": "<p>A chain production is a production of the form A&#8594;M where A is a nonterminal and M is either a terminal or nonterminal. Pager in [Pag5] has presented an algorithm which removes all chain reductions from LR(1) parsers <underline>after</underline> they have been constructed.</p> <p>In this paper, we present an algorithm for directly constructing LR(k) parsers with arbitrary subsets of the chain productions, called the <underline>useless</underline> chain productions, optimized out. If this subset is empty, the algorithm is a standard one [And 1, Kn]. If this subset consists of all chain productions, the result is a parser with all chain reductions optimized away. The algorithm, as in [Pag5], also eliminates from the parsers all nonterminals which occur as the left part of useless chain productions. This latter optimization along with the chain reduction optimization significantly decreases the storage space and execution times of the parsers.</p> <p>This provides an efficient solution of the open problem posed by Aho and Ullman [A&amp;U2] for all LR(k) grammars.</p>", "authors": [{"name": "Wilf R. LaLonde", "author_profile_id": "81100065648", "affiliation": "", "person_id": "P298249", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800168.811546", "year": "1976", "article_id": "811546", "conference": "POPL", "title": "On directly constructing LR(k) parsers without chain reductions", "url": "http://dl.acm.org/citation.cfm?id=811546"}