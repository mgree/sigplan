{"article_publication_date": "10-01-2001", "fulltext": "\n A Categorization of Classes based on the Visualization of their Internal Structure: the Class Blueprint \n Michele Lanza Stephane Ducasse \u00b4 Software Composition Group Software Composition Group University Of \nBern University Of Bern Bern, Switzerland Bern, Switzerland lanza@iam.unibe.ch ducasse@iam.unibe.ch \nNote for the proceedings reader: this paper makes heavy use of colors in the .gures. Please obtain and \nread an online (colored) version of this paper in order to better understand the ideas pre\u00adsented in \nthis paper.  ABSTRACT The reengineering and reverse engineering of software systems is gaining importance \nin software industry, because the accelerated turnover in software companies creates legacy systems in \na shorter period of time. Especially understanding classes is a key activity in object-oriented programming, \nsince classes represent the primary abstractions from which applications are built. The main problem \nof this task is to quickly grasp the purpose of a class and its inner structure. To help the reverse \nengineers in their .rst contact with a foreign system, we propose a categorization of classes based on \nthe visualization of their internal structure. The contributions of this paper are a novel categorization \nof classes and a visualization of the classes which we call the class blueprint. We have validated the \ncategorization on several case studies, two of which we present here.  Keywords Reverse Engineering, \nProgram Understanding, Software Visualiza\u00adtion, Visual Patterns, Smalltalk 1. INTRODUCTION In object-oriented \nprogramming, understanding a certain class can be the key to a wider understanding of the system the \nclass is con\u00adtained in. Especially in the industrial context, where the turnover of developers is accelerating, \nreverse engineering of code is becom\u00ading more and more important. However, the basic approach to class \nunderstanding has basically not changed during the past decades(!) independently from the implementation \nlanguage and/or develop\u00adment environment and still is mainly based on source code reading. One can argue \nthat reading source code one has written poses no problem. However, in the current state of software \nindustry one- Permission to make digital or hard copies of part or all of this work or personal or classroom \nuse is granted without fee provided that copies are not made or distributed for profit or commercial \nadvantage and that copies bear this notice and the full citation on the first page. To copy otherwise, \nto republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or \na fee. OOPSLA 01 Tampa Florida USA Copyright ACM 2001 1-58113-335-9/01/10 $5.00 man projects have become \nrare, and even in those cases one has to reuse, i.e., understand foreign code in the form of frameworks, \nAPIs and class libraries. As Chikofksy and Cross [1] put it: Usu\u00adally, the system s maintainers were \nnot its designers, so they must expend many resources to examine and learn about the system. The bene.t \nof high level languages is that source code can be read like a text written in English. Thus, the names \nthe developers use for the classes, methods and attributes can already convey a sub\u00adstantial understanding \nwithout requiring an in-depth analysis of the source code. Apart from the obvious dif.culties which stem \nfrom the use of acronyms and domain speci.c terminology, it is the use of inheritance in object-oriented \nsoftware which can make code hard-to-read: Inheritance represents a form of incremental de.ni\u00adtion of \nclasses [28]. To fully understand a class one must therefore understand its super-and subclasses as well. \nAnother problem is represented by the dynamic of self calls, whose meaning can com\u00adpletely change if \na superclass is changed or a new superclass is inserted in the inheritance hierarchy. In the .rst contact \nwith a foreign software system there is a need for a quick and intuitive understanding of the classes. \nNote that to understand a class you do not need to read every line of its code and you do not need to \nunderstand every piece of functionality con\u00adtained therein. In this paper we propose a simple approach \nto ease the understand\u00ading of classes by visualizing the static structure of a class. The goal of our \nvisualization is to gain a certain quality of comprehen\u00adsion, a taste of the class: an intuitive and \nquick understanding of its internal structure and the way it interacts with its super-and subclasses. \nOur approach does not strive to understand the exact functionality of a class, as this still requires \nthe reading of the code. We do not take into account dynamic or run-time aspects, as in the context of \nreverse engineering they become relevant only at a later point in time. We focus on the static structure \nof classes and the way they make use of inheritance and leave out other collaboration aspects. We have \ncoined the term class blueprint for the visualiza\u00adtion presented in this paper. Based on the obtained \ninsights we es\u00adtablish a vocabulary of class blueprints to ease understanding and to have a common language \nwhich reverse engineers can use to com\u00admunicate with each other. We would like to stress that the approach \npresented here does not depend on a particular language, as our un\u00adderlying metamodel is language-independent \n[7, 5]. However we present results obtained on Smalltalk case studies and make also use of some of the \nfeatures of this language. The contributions of this paper are a novel categorization of classes and \na visualization of the classes which we call the class blueprint. This paper is structured as follows: \nIn the next section we present the concept of the class blueprint, based on which we build our cat\u00adegorization \npresented in the section afterwards. We then present a validation of the categorization applied on two \ncase studies. We .\u00adnally present our reengineering environment before concluding the paper with a discussion \non the obtained results and give an outlook on future work on this topic.  2. THE BLUEPRINT OF A CLASS \nIn this section we present the class blueprint, a way to visualize the internal structure of classes. \nFirst we present the layered struc\u00adture of the blueprint. We then discuss the way we display meth\u00adods \nand attributes, including the color schema we use. We shortly discuss the layout algorithm we use, before \n.nally displaying and discussing a .rst class blueprint visualization. 2.1 The Layers of a Class Blueprint \nIn Figure 1 we present a template class blueprint. From left to right we have the following layers: initialization, \ninterface, implemen\u00adtation, accessor and attribute. The .rst three layers and the meth\u00adods contained \ntherein are placed from left to right according to the method invocation sequence, i.e., if method a \ninvokes method b, b is placed to the right of a. CLASS NAME   Initialization Interface Implementation \nAccessor Attributes  INVOCATION SEQUENCE Figure 1: The decomposition of a class into layers. Every \nconcrete class can be mapped on this template class blue\u00adprint which has the layers described below. \nFor each layer we list some conditions which must be ful.lled to be assigned to a layer. Note that the \nlayers are not mutually exclusive except the attribute layer. Note also that the conditions listed below \nfollow a lightweight approach and are not to be considered as complete. However, we ve seen that they \nare suf.cient for our purposes. 1. Creation/Initialization Layer. The methods contained in this .rst \nlayer are responsible for creating an object and ini\u00adtializing the values of the attributes of the object. \nWe con\u00adsider a method as belonging to the initialization layer, if one of the following conditions holds: \n The method name contains the substring initialize or init .  The method is a constructor.  In the \ncase of Smalltalk, where methods can be clus\u00adtered in so-called method protocols, if the methods are \nplaced within protocols whose name contains the sub\u00adstring initialize .  In our current approach we \ndo not take into account static initializers [10] for Java, as they are not covered by our meta\u00admodel \n[5]. 2. (External) Interface Layer. The methods of this layer can be considered as the entry points to \nthe functionality pro\u00advided by the class. A method belongs to this layer if one the following holds: \n It is invoked by methods of the initialization layer.  In languages like Java and C++ it is declared \nas public or protected.  It is not invoked by other methods within the same class, i.e., it is a method \ninvoked from outside of the class, ei\u00adther by methods of collaborator classes or subclasses. Should the \nmethod be invoked both inside and outside the class, it is placed within the implementation layer.  \nWe do not count accessor methods to this layer, but to a layer of its own, as we show later on. 3. (Internal) \nImplementation Layer. The methods within this layer are the ones doing the main work of the class, by \nassur\u00ading that the class can provide the functionality promised by the interface layer. A method belongs \nto this layer if one of the following holds: In languages like Java and C++ if is declared as private. \n The method is invoked by at least one method within the same class.  4. Accessor Layer. This layer \nis composed of accessor meth\u00adods, i.e., methods whose sole task is to get and set the values of attributes. \n 5. Attribute Layer. The attribute layer contains all attributes of the class. The attributes are connected \nto the other layers by means of access relationships, i.e., the attributes are accessed by methods. \n 2.2 Representing Methods and Attributes in a Class Blueprint Within the layers of each class we represent \nmethods and attributes using colored boxes of various size and shape. Width Metric METHOD or Height \nMetricATTRIBUTE Figure 2: A graphical representation of methods and attributes using metrics. 2.2.1 \nSize and Shape of Methods and Attributes We use the width and height of the boxes to re.ect metric measure\u00adments \nof the entities which are represented by the boxes, as we see in Figure 2. This approach has been presented \nin [18] and [4]. For the method boxes we use the metric lines of code (LOC = number of non-blank lines \nin a method body) for the height and the number of invocations (NI = number of static call sites) for \nthe width [19, 13]. For the attribute boxes we use the metrics number of direct accesses from within \nthe class (NLA) for the width and number of direct accesses from outside of the class (NGA) for the height \n[18]. Note that the total number of accesses on an attribute is the sum of NGA and NLA. For further explanations \non the metrics please refer to [18]. 2.2.2 The Use of Colors in a Class Blueprint We make use of colors \nto display supplementary information in a class blueprint. In Table 1 we present a list of the colors \nwe use in the .gures of this paper. Note that the proceedings version of this paper could not be printed \nin color. Please obtain an online version of this paper in order to see how colors are used in a class \nblueprint. Description Color Attribute blue Abstract method cyan Extending method. A method with the \nsame orange name in the superclass which performs a super invocation Overriding method. A method which \ncompletely brown rede.nes the behavior of a method in the super\u00ad class with the same name without invoking \nthe superclass method Delegating method. A method which delegates yellow the functionality it is supposed \nto provide, by for\u00ad warding the method call to another object Constant method. A method which returns \na con\u00ad grey stant value Initialization layer method green Interface and Implementation layer method white \nAccessor layer method red Invocation of a method black line Invocation of an accessor. Semantically it \nis the cyan line same as a direct access Access of an attribute cyan line Table 1: A color schema for \nclass blueprints.  2.3 The Layout Algorithm of a Class Blueprint The placement of the methods and attributes \nwithin the layers is based on their context, e.g., if a method is an initialization method it is placed \nwithin the initialization layer. To further enhance the placement, we use a simple tree layout algorithm \nfrom left to right: if method A invokes method B, B is placed to the right of A and both are connected \nby an edge which represents the invocation re\u00adlationship. In the case of a method which accesses an attribute, \nthe edge represents an access relationship.  2.4 A First Visualization of a Class Blueprint Using the \nideas described in this section Figure 4 presents a blueprint visualization of a real class. We can see \nthat the class has 3 initial\u00adize layer methods, two of which are invoked by the leftmost one. We see \nthat the class has a wide external interface composed of 12 methods. The class has 6 attributes and an \nempty accessor layer. We also see, according to the color scheme of Table 1, that the class does not \ncontain overriding, extending, delegating or constant methods. Figure 4: An actual blueprint visualization \nof a class.  3. A CATEGORIZATION OF CLASSES BASED ON CLASS BLUEPRINTS In this section we present a \ncategorization of classes based on their blueprints, i.e., based on the way they display themselves using \nthe approach described in the previous section. The categoriza\u00adtion stems from the experiences we obtained \nwhile applying our approach on several case studies. We subdivide this section in two parts: In the .rst \npart we categorize the classes based on their in\u00adternal structure, while in the second part we extend \nthe context to the inheritance hierarchy where the class resides. We use the term pure class blueprint \nwhen it falls unequivocally into one of the cat\u00adegories proposed in this section. The only kind of collaboration \nbetween classes we discuss in this paper is inheritance. Due to the limited size of this paper, we also \nshow .gures which contain more than one kind of blueprint. Some of the blueprints are thus discussed \nafter the .gure. 3.1 The Single Class Perspective In this part we introduce a categorization of classes \nbased on their blueprint without considering the surrounding sub-and superclasses. Based on the class \nblueprint we make statements regarding the in\u00adternal implementation aspects of the class. Note that a \nclass can belong to more than one of the categories presented here. Single Entry.We de.ne a single entry \nclass as one which has very few or only one entry point to the interface layer. It then has a large implementation \nlayer with several levels of invocation rela\u00adtionships. Such classes are designed to deliver only one \nyet com\u00adplex functionality. Classes which implement a speci.c algorithm belong to this type. In Figure \n5 we see an actual single entry class. Figure 5: The blueprint of the class MSEXMIDTDProducer: a single \nentry class without accessors. Data Storage.We de.ne a data storage class as a class which mainly contains \nattributes whose values can be read and written by using accessor methods. Such a class does not implement \nany com\u00adplex behavior, but merely stores and retrieves data for other classes. The implementation layer \nis often empty, as the class functionality does not need complex mechanisms to be delivered. The attribute \nlayer often contains several attributes which are accessed directly or through accessor methods. In Figure \n6 we see an example of a data storage class. Figure 6: The blueprint of the class MSEModelAttribut\u00adeDescriptor: \na data storage class. We see that there are many accessors to the many attributes. The internal implementation \nlayer is empty. Wide Interface.A wide interface is one that offers many entry points to its functionality \nin respect to its overall implementation layer. A good example for such a class is a GUI class with many \nbuttons on the user interface which offers a method for every button the user can press. Note that a \ndata storage class also belongs to this type of class. In Figure 7 and Figure 8 we see examples of wide \ninterface class blueprints. Figure 7: The blueprint of the class MSELoaderEnvySubcan\u00advas: a wide interface \nclass. Large Implementation.A large implementation class has a large implementation layer with many methods \nand many invocations between those methods. A single entry class can also belong to this type, although \nits invocation tree is deep and narrow. Large classes often have a large implementation layer. In Figure \n8 we see a large implementation class: the class MSEImporterFacade from the Moose case study contains \nseveral layers of invocations. Delegator.A delegator is a class which de.nes delegating meth\u00adods. If \nthe class de.nes only delegating methods, we name it a pure delegator. The class delegates calls to its \nfunctionality to the classes which implement the needed functionality. Such a class of\u00adten has only methods \nwithin the interface layer which are marked as delegator methods. A delegator can represent either the \ndesign pattern Facade or Wrapper [12]. See Figure 8 for an example of a delegator. does Constant De.ner.A \nconstant de.ner class is one which de.nes Figure 8: The blueprint of the class MSEImporterFacade: a \nlarge implementation class, as well as a delegator and a wide interface. default methods which return \nconstant values. In Figure 12 we see an example of such a constant de.ner: the constant methods have \na grey color. Small Class.We de.ne a small class as a class which contains few methods and attributes \n(if at all). To understand the class it is often enough to know its name, especially if the class is \na standalone class, i.e., does not belong to an inheritance hierarchy.  3.2 The Inheritance Perspective \nWe expand the categorization of class blueprints by considering the way the classes make use of the inheritance \nrelationships with their ancestors and descendants. This perspective adds consider\u00adable meaning to the \nclass, as the functionality which can be pro\u00advided by the class is in fact distributed across the inheritance \nchain the class belongs to. In the case of inheritance we visualize every class blueprint separately \nand put the subclasses below the super\u00adclasses, similar to a inheritance tree layout, as we see in Figure \n9. Taking into account a whole inheritance hierarchy using our ap\u00adproach leads to a whole range of new \nclass categories. In this sec\u00adtion we make the following distinction: 1. De.ners are classes which reside \nat the top of a hierarchy. They may de.ne some kind of interface behavior for their Figure 9: The visualization \nof class blueprints in the context of inheritance. subclasses, apart from providing functionality of \ntheir own. 2. Specializers are leaf classes in inheritance hierarchies and implement and re.ne behavior \nat the bottom of the hierar\u00adchies. 3. Inbetweeners are classes which are none of the above. How\u00adever, \noften they can be put into one of the two categories nonetheless. For example, if a class in the higher \npart of an inheritance hierarchy is not a de.ner class, it can nonetheless be classi.ed as such if it \nshows the properties of a de.ner class.  3.2.1 De.ner Classes A de.ner class is one which resides in \nthe higher levels of an in\u00adheritance hierarchy and whose main purpose is to de.ne behavior and state \nwhich is common to its subclasses. To do so, it de.nes attributes (which are inherited to the subclasses) \nand abstract, de\u00adfault and hook methods which are overridden or extended by the subclasses. Below we \nlist types of de.ner classes based on the way they are de.ned and behave. The types listed here are not \nmutually exclusive, as a class can be of more than one of the following types. Pluggable.A pluggable \nclass is one which establishes an inheri\u00adtance policy by de.ning abstract methods which must be overrid\u00adden \nby its subclasses to make them compliant to the policy. This tightly ties the subclasses to the pluggable \nclass. A pure pluggable class is one which de.nes only abstract methods. Figure 10 is an example of a \npluggable class.  is to de.ne attributes (instance variables) which are then inherited, used and accessed \nby its subclasses. In Figure 11 we see a super\u00adclass which de.nes heavily accessed attributes, as the \nsize of the attributes shows.  Figure 12: The blueprints of classes from the Moose case study show a \nconstant de.ner superclass and two talking overriders, which are also siamese twins. 3.2.2 Specializer \nClasses Specializer classes are classes which specialize and extend the be\u00adhavior of their superclasses. \nIn this section we introduce the cat\u00adegories and discuss them later in detail. We present 3 ways for \nclasses to specialize the behavior of superclasses and 2 ways for them to communicate with each other. \nThe combination of these will result in 6 possible categories. In the context of inheritance, classes \nhave the following possibili\u00adties to extend the behavior of their superclasses: 2. Overriding. The subclass \ncontains at least one method which overrides the de.nition of a method with the same signature in the \nsuperclass, i.e., the functionality of the method de.ned in the superclass is completely rede.ned. There \nis no super call to the overridden superclass method. 3. Adding. A subclass can also add its own functionality \nto the one de.ned higher up the hierarchy by adding methods which are not present in the superclass. \n We distinguish two different ways of communication between classes which inherit from each other: 1. \nTalking. The subclass communicates (talks) with its super\u00adclasses by invoking the methods and by accessing \nthe at\u00adtributes of the superclasses. invocations 2. Mute. The subclass is mute if it does neither invoke \nsuper\u00adclass methods nor access superclass attributes.  Based on this inheritance classi.cation we summarize \nthe possible combinations in Table 2. Note that a mute extender is not possible, as the de.nition of \nextension includes a call to the superclass. Mute Talking Extending - Talking Ex\u00adtender Overriding Mute \nOver\u00adrider Talking Overrider Adding Mute Adder Talking Adder Table 2: A classi.cation schema based on \ninheritance. The following is a list of the combinations listed in the Table 2, their properties and \nclass blueprints. Talking Extender.A talking extender class communicates with its superclasses by invoking \ntheir methods and accessing their at\u00adtributes. It also contains extending methods, i.e., methods which \ndo a super call on a method with the same name. Note that such classes may be fragile, as a change in \na superclass (for example re\u00admoval of a method) has a direct effect on the depending subclasses [25]. \nThe case of a pure talking extender, likewecan seeinFig\u00adure 16 marked as B, is rare. Mute Overrider.A \nmute overrider class is one which contains at least one overriding method and is thus bound to its superclass. \nIt does however not invoke methods contained in it or access the attributes of the superclass. Talking \nOverrider.A talking overrider overrides methods con\u00adtained in the superclass and also communicates with \nit using method invocations and attribute accesses. Mute Adder.A mute adder does not communicate with \nits su\u00adperclass and does not override any methods. It thus contains only added functionality. In some \noccasions this may be a result of wrong subclassing, where the subclass does not have anything to do \nwith its superclass. The subclass can then be moved somewhere else without breaking its functionality. \nTalking Adder.A talking adder class is one which adds function\u00adality to its superclass and invokes methods \nand accesses attributes of the superclass. In the case of a pure talking adder one must check why the \nclass does not extend or override methods. Note that classes often belong to more than one category at \nthe same time. It is rare to have pure blueprints like a pure adder or a pure extender. A frequent case \nis for example a talking extender\u00adoverrider-adder class like the two subclasses we see in Figure 11. \n 3.2.3 Special Class Blueprints Moreover we have detected some special cases of class blueprints, which \nwe list here: Micro Specializer.A micro specializer is a small class which de\u00ad.nes overriding and extending \nmethods. Such classes are mainly used to specialize some kind of behavior. Siamese Twin. Sometimes we \nencounter siamese twins, sibling classes which have an impressive similarity with each other in terms \nof methods, attributes, method invocations and attribute accesses. This can be a case where the programmer \nforgot to refactor the common functionality into the superclass of the siamese twins. See Figure 12 for \nan example. Pure Accessor. A class which does not invoke superclass meth\u00adods, but directly accesses the \nattributes de.ned in the superclasses. Three examples of pure accessing overriders can be seen in Fig\u00adure \n10. Un.nished Realizer.An un.nished realizer class is one which does not ful.ll the inheritance contract \nwith its superclass, i.e., it does not override all abstract methods de.ned by the superclass. They are \neasy to detect if the number of overridden methods in the subclass is inferior to the number of abstract \nmethods in the superclass.  3.3 Interpreting Suspicious Class Blueprints Sometimes, at .rst sight, \nclass blueprints may be hard to classify or contain suspicious parts. In this section we present some \nfrequent cases: Splittable Classes. Sometimes you may have one class doing work that should be done by \ntwo. In the blueprint this comes out as two (or more) separate clusters of methods and attributes which \nare not connected in any way. Martin Fowler suggests in such a case an Extract Class refactoring [11]. \nNote that our current blueprint layout algorithm does not clearly show splittable classes, some manual \npost processing is needed. Inconsistent Accessor Use. As shown in Figure 13 there are two cases of inconsistent \nuse of accessors. The .rst is when a method accesses an attribute both directly and via the accessor. \nNote that this situation can become haphazard in case the accessor makes use of lazy initialization, \nas the accessed attribute may be in an unde.ned state. The second is when the accessor is not invoked \nat all. In this case the accessor method adds unneeded complexity to the class. A justi.cation for this \nis if the class is part of a framework or the class is intended for future reuse through subclassing. \nMethod Accessor Attribute  Method Figure 13: Two cases of inconsistent accessor use. Classes without \na Blueprint. One of the questions which remains yet to be answered is what happens when the visualized \nclass does not match one of our blueprints. This happens quite often for larger classes (say more than \n50 methods). Although such classes need not necessarily to be a sign of bad design, we think that the \nclasses are suspicious nonetheless and should be further examined. Misuse of Inheritance Hierarchy Policy. \nUsing our approach on inheritance hierarchies we have often seen that the whole hierarchy was built on \none main inheritance concept, for example extension. In such a case we have many extender subclasses. \nHowever, some\u00adtimes we happen across a class in such a hierarchy which is not compliant with the policy \nestablished for that hierarchy. We con\u00adclude from this that the class in question is either un.nished \nor has been added later by a developer who was unfamiliar with the inher\u00aditance policy local to the hierarchy. \nSeen at a lower level, it means that if a de.ner class de.nes two abstract methods we expect to see two \noverriding methods in its subclasses. Should this not be the case, it means it is a misuse of inheritance \nor the subclass is not .nished yet. Pure Mute Overriders. In the case of a pure mute overrider we have \na subclass B which does not invoke or access the superclass A and does only method overrides. In such \na case the subclass B may not really need to be a subclass but could be moved to be a sibling B of its \nsuperclass A and the overridden methods and the behavior de.ned in A could be pushed higher up into a \nnew super\u00adclass C NEW and made abstract. The subclass would thus become a sibling. The detection of such \ncases can provoke major changes in the inheritance hierarchy by enhancing the .exibility and design of \nthe system. This situation, shown in Figure 14, is similar to the Extract Superclass refactoring presented \nand discussed by Martin Fowler [11]. BEFORE AFTER A B C NEW  A B Figure 14: The Extract Superclass \nrefactoring.  4. VALIDATION OF THE APPROACH To validate our approach we used the following procedure: \none class of the case studies after the other has been visualized using our approach. After the blueprint \nvisualization we put the class into one of the categories mentioned in the previous section. We selected \nthe case studies based on our knowledge about them. In the .rst case we choose an application developed \nby ourselves to be able to a veri.cation of the obtained categorization. In the second case we chose \na foreign application to evaluate the approach in an unbiased fashion. To keep within the limits of this \npaper it is not possible for us to discuss every blueprint. We prefer to discuss some examples to show \nthe bene.ts of the blueprints and to summarize and discuss the .nal results. 4.1 Moose, a Reengineering \nEnvironment Moose is a reengineering framework written in Smalltalk since 1996 and is still being developed. \nIt contains two deep hierarchies, one for the language independent metamodel, the other for the tool \nsupport. It also contains other classes which are mainly responsible for the graphical user interface. \nIn Figure 15 we see an overview of Moose using CodeCrawler.. We have summarized the classes of Moose, \nVersion 1.49, in Ta\u00adble 3. Root Classes 4 Standalone Classes 27 Leaf Classes 42 Inbetweener Classes 22 \nTotal Number of Classes 95 Table 3: The summary of the classes of Moose 1.49. We have .rst treated the \nstandalone classes and given two exam\u00adples, shown in the previous section, to exemplify the insights \nwe get from the blueprint visualization. In Figure 5 we have already seen that the class is a single \nentry class: the methods invoke each other in a linear fashion from left to right. There is one attribute \non the right side which is accessed by one method. In Figure 7 we have seen an example of a wide interface \nclass: the interface layer of this class is wide compared to the rest of the class. We have then focused \non the small inheritance tree of 6 classes on the right side of Figure 15 marked as A. We see the blueprint \nof all those classes in Figure 16. Within this hierarchy we can see that the subclasses make heavy use \nof extension. The only class which has few extending methods, the one marked as A, has long methods (shown \nby the size of the method rectangles). We deduce from that that this class has been implemented rapidly \nand without a deep knowledge of the inheritance policy used in this inheritance hierar\u00adchy. We can also \nsee, marked as B, a very small talking extender.In the case of the root class, we de.ne it .rst of all \na large implemen\u00adtation class (4 layers) and also as an attribute de.ner. We see that the attributes \nin that class are heavily accessed by the subclasses. The next example, shown in Figure 12, is composed \nof a small subtree composed of three classes. The superclass, which is the root of a much larger inheritance \nhierarchy, is a constant de.ner class with a wide interface. Its subclasses are both nearly identical \ntalking overriders, which makes them siamese twins. After classifying all classes of Moose based on their \nblueprints, we have summarized our .ndings in Table 4. Conclusion. The conclusion which can be drawn \non Moose is that it shows many characteristics of a mature application: delegators which act as facades, \na tightly bound hierarchy which makes heavy use of extending and overridding methods. Although we are \namong the developers of Moose, we had some surprises. For example we detected 5 mute adders, 3 of which \nwere actual cases of wrong subclassing. Many other insights have triggered refactorings, espe\u00adcially \nthe inconsistent use of accessors. We detected a low number of false positives, i.e., there were only \n2 classes whose blueprint indicated the wrong category. However, there were also around 20 average-sized \nclasses without a clear blueprint, which we would categorize as being normal . We see this as a limit \nof our ap\u00adproach, especially in the context of reverse engineering legacy sys\u00adtems which have a tendency \nto have many classes like this. Single Entry 9 Data Storage 3 Wide Interface 22 Large Implementation \n1 Delegator 7 Small Class 33 Pluggable 6 Attribute De.ner 6 Constant De.ner 2 Talking Extender 1 Mute \nOverrider 3 Talking Overrider 2 Mute Adder 5 Talking Adder 2 Talking Adder-Overrider-Extender 34 Siamese \nTwin 6 Pure Blueprint 9 Table 4: The .nal summary of Moose based on its class blueprints.  4.2 Duploc, \na Duplication Detection Tool Duploc is an application written in Smalltalk by two developers. Duploc \nhas been under development for three years now and has become a complex and mature application whose \ngoal is to support the detection of duplicated code in large industrial applications. The version of \nDuploc we examined, consisted of 159 classes, many of which were either standalone or resided within \nsmall inheritance hierarchies. We have shown some blueprints of Duploc classes in Figure 12. We want \nto show the class in Figure 17 to give an im\u00adpression of the information a class blueprint conveys to \nthe user: The class is obviously a wide interface and a delegator class. It also de.nes many constants. \nThe peculiarity about this class is the fact that some parts of it behave like a single entry class. \nSingle Entry 10 Data Storage 7 Wide Interface 16 Large Implementation 7 Delegator 6 Small Class 59 Pluggable \n10 Attribute De.ner 2 Constant De.ner 1 Talking Extender 3 Mute Overrider 1 Talking Overrider 4 Mute \nAdder 1 Talking Adder 2 Talking Adder-Overrider-Extender 39 Siamese Twin 7 Pure Blueprint 10 Table 5: \nThe .nal summary of Duploc based on its class blueprints. Conclusion. We have summarized the .ndings \nin Table 5. The  Figure 17: A wide interface class of Duploc, which is also a del\u00adegator and which shows \nsome characteristics of a single entry. It even is also a constant de.ner. conclusion which we have drawn \nof Duploc, after looking at all its class blueprints, was that it contained innumerable small classes, \nand that the code contained many pattern-like structures like fa\u00adcades, wrappers, etc. Here again, 21 \nclasses could not be classi.ed using the blueprints, due to their considerable size and complexity. We \nhad many .ndings concerning inconsistent use of accessors, un.nished classes, and sometimes overly large \nmethods.  5. CODECRAWLER AND MOOSE CodeCrawler is the tool used in this paper to visualize the class \nblueprints. CodeCrawler supports reverse engineering through the combination of metrics and software \nvisualization [18, 4, 6]. Its power and .exibility, based on simplicity and scalability, has been repeatedly \nproven in several large scale industrial case studies, some of which we list in Table 6. XXZ C++ 1.2 \nMLOC (>2300 classes) XXY C++/Java 120 kLOC (>400 classes) XXX Smalltalk 600 kLOC (>2100 classes) XXW \nCOBOL 40 kLOC Table 6: A list of some of the industrial case studies Code-Crawler was applied upon. \nCodeCrawler is implemented on top of Moose. Moose is a lan\u00adguage independent reengineering environment \nwritten in Smalltalk. It is based on the FAMIX metamodel [5], which provides for a lan\u00adguage independent \nrepresentation of object-oriented sources and contains the required information for the reengineering \ntasks per\u00adformed by our tools. It is language independent, because we need to work with legacy systems \nwritten in different implementation languages. It is extensible, since we cannot know in advance all \nin\u00adformation that is needed in future tools, and since for some reengi\u00adneering problems tools might need \nto work with language-speci.c information, we allow for language plug-ins that extend the model with \nlanguage-speci.c features. Next to that, we allow tool plug\u00adins to extend as well the model with tool-speci.c \ninformation. A simpli.ed view of the FAMIX metamodel comprises the main object-oriented concepts -namely \nClass, Method, Attribute and In\u00adheritance -plus the necessary associations between them -namely Invocation \nand Access (see Figure 18). 6. RELATED WORK Software Visualization. Among the various approaches to sup\u00adport \nreverse engineering that have been proposed in the literature, graphical representations of software \nhave long been accepted as comprehension aids. Many tools make use of static information to visualize \nsoftware like Rigi [20], Hy+ [2], SeeSoft [8], ShrimpViews [26], TANGO [24] as well as commercial tools \nlike Imagix (see http://www.imagix.com) to name but a few of the more prominent examples. However, most \npublications and tools that address the problem of large-scale static software visualization treat classes \nas the smallest unit in their vi\u00adsualizations. There are some tools, for instance the FIELD pro\u00adgramming \nenvironment [23] which have visualized the internals of classes, but usually they limited themselves \nto showing method names, attributes, etc. Some of them also make use of color codes: the Classi.cation \nBrowser [3] uses colors to denote abstract meth\u00adods, etc. Substantial research has also been conducted \non runtime informa\u00adtion visualization, like in Various tools and approaches make use of dynamic (trace-based) \ninformation such as Program Explorer [17], Jinsight and its ancestors [21, 22], Graphtrace [16]. Various \nap\u00adproaches have been discussed like in [15] or [14] where interactions in program executions are being \nvisualized, to name but a few. We provide a visualization of the internal structure of the classes in \nterms of its implementation, static behaviour, as well as in the context of their inheritance relationships \nwith other classes. In this sense our approach proposes a new dimension in the understanding of systems. \nMetrics. Metrics have long been studied as a way to assess the quality and complexity of software [9], \nand recently this has been applied to object-oriented software as well [19, 13]. Metrics pro.t from their \nscalability and, in the case of simple ones, from their re\u00adliable de.nition. Metrics are often used to \nassess the internal com\u00adplexity of classes, for example by counting the number of methods or attributes. \nHowever, metrics do not provide a combined view of a class and its internal structure. 7. CONCLUSION \nIn this section we .rst discuss the lessons learned from the appli\u00adcation of our categorization on the \ncase studies. We then list the bene.ts and the limits of our approach and .nally give an outlook on the \nfuture work. 7.1 Lessons Learned from the Case Studies The case studies have shown that our approach \nis indeed useful. After a few visualizations of class blueprints, we could classify the blueprints in \na few seconds. We obtained a few insights, es\u00adpecially on our own system: we found several places that \nthe class blueprints indicated possible present and future problems. We have also seen that in the case \nof the specializer classes, the number of pure blueprints is very small. The most frequent case are subclasses \nwhich at the same time override, extend and add functionality to their superclasses. In the case of the \nforeign case study our approach was useful to make assumptions about the classes in terms of purpose, \ncoding style and coding conventions. Furthermore the number of false positives, i.e., the classes which \nwe wrongly classi.ed, was small. However, this last statement must be seen in the light of the fact that \nour own system was the only case study where we could deter\u00admine the false positives, as this requires \nus to know what the system actually does. 7.2 Bene.ts of the Approach The main bene.ts of the approach \npresented here are the following: Reduction of complexity: the taste of a class. Using a sim\u00adple visualization \nnamed class blueprint we can make assumptions about a class without having to read the whole source code. \nThis taste of the class, which conveys the purpose of a class, can be used in two contexts: 1. Single \nClass Perspective. Based on the blueprint we can make many assumptions and gain insights on the structure \nand internal implementation of a class. 2. Inheritance Perspective. Based on the blueprints of several \nclasses which are related by inheritance, we can make state\u00adments the way the class is embedded in its \ninheritance hier\u00adarchy and about the way it makes use of inheritance.  A common vocabulary. We have \nde.ned a common vocabulary for the different class categories based on their blueprints. This vocabulary \nis of utmost importance during a reverse engineering process, where complex contexts and situations must \nbe communi\u00adcated to another person in an ef.cient way. 7.3 Limits of the Approach The approach presented \nhere is limited in the following ways: Cognitive Science. The visualization algorithm presented here \nand the methodology coming with it are both ad hoc. Although is prov\u00adably useful, it shows little connection \nwith research from the .eld of cognitive science. At this time we are striving to update our knowledge \nin this .eld, for example as presented in [27]. Layout Algorithm. The approach presented here relies \nheavily on an ef.cient layout algorithm in terms of space and readability. Es\u00adpecially in the case of \nvery large classes it may happen that the only real statement we can make is that the class is large. \nFurthermore, some minor manual post processing is still required at this time. Functionality. The blueprint \nof a class can give the viewer a taste of the class at one glance. However, it does not show the func\u00adtionality \nthe class provides. The approach proposed here is thus complementary to other approaches used to understand \nclasses. Collaboration. We do not address collaboration aspects between classes for the time being. Static \nAnalysis. The approach presented here does not make use of dynamic information. This means we are ignoring \nruntime infor\u00admation about which methods get actually invoked in a class. This is especially relevant \nin the context of polymorphism and switches within the code. In this sense the class blueprint can be \nseen as a visualization of every possible combination of method invocations. 7.4 Future Work In the \nfuture we plan to make some more experiences to re.ne our blueprint naming scheme and to enhance the \nvisualization part, as the success of the approach heavily depends on it. In particular, we would like \nto apply it on legacy systems to evaluate the percentage of classes which cannot be categorized using \nthe class blueprints. We also plan to extend the approach to classes which are not within the same inheritance \nhierarchy, but collaborate with each other. We further plan to integrate this approach into the methodology \nwe have proposed in [6] and to extend and re.ne our reverse engineer\u00ading methodology. We would like to \nhave an empirical usability analysis and qualita\u00adtive validation of our approach by letting reverse engineers \nuse our system and to collect their experiences. A second possibility we want to explore is to compare \nthe reverse engineering ef.ciency of two groups of users, one with and the other without our tool. We \nplan to apply our approach on applications developed in Java and C++. We would like to evaluate if the \nlayers we have de.ned, especially the public interface layer, are still valid in such languages too. \nAs our metrics engine supports more than 50 metrics, we will also evaluate the use of other metrics than \nthe ones used in this paper. Acknowledgments. We wish to thank Gabriela Arevalo, Oscar Nierstrasz and \nSander Tichelaar for reviewing drafts of our paper. We also wish to thank the anonymous reviewers for \ntheir helpful comments.  8. REFERENCES [1] E. J. Chikofsky and J. H. Cross, II. Reverse engineering \nand design recovery: A taxonomy. IEEE Software, pages 13 17, Jan. 1990. [2] M. Consens and A. Mendelzon. \nHy+: A hygraph-based query and visualisation system. In Proceeding of the 1993 ACM SIGMOD International \nConference on Management Data, SIGMOD Record Volume 22, No. 2, pages 511 516, 1993. [3] K. DeHondt. \nA Novel Approach to Architectural Recovery in Evolving Object-Oriented Systems. PhD thesis, Vrije Universiteit \nBrussel, 1998. [4] S. Demeyer, S. Ducasse, and M. Lanza. A hybrid reverse engineering platform combining \nmetrics and program visualization. In F. Balmas, M. Blaha, and S. Rugaber, editors, Proceedings WCRE \n99 (6th Working Conference on Reverse Engineering). IEEE, Oct. 1999. [5] S. Demeyer, S. Tichelaar, and \nS. Ducasse. FAMIX 2.1 -the FAMOOS information exchange model. Technical report, University of Berne, \n2001. to appear. [6] S. Ducasse and M. Lanza. Towards a methodology for the understanding of object-oriented \nsystems. Technique et Science Informatique, 2001. To appear in Techniques et Sciences Informatiques, \nEdition Speciale Reutilisation. [7] S. Ducasse, M. Lanza, and S. Tichelaar. Moose: an extensible language-independent \nenvironment for reengineering object-oriented systems. In Proceedings of the Second International Symposium \non Constructing Software Engineering Tools (CoSET 2000), June 2000. [8] S.G.Eick, J. L. Steffen, and \nE.E.S.Jr. SeeSoft ATool for Visualizing Line Oriented Software Statistics. IEEE Transactions on Software \nEngineering, 18(11):957 968, November 1992. [9] N. Fenton and S. L. P.eeger. Software Metrics: A Rigorous \nand Practical Approach. International Thomson Computer Press, London, UK, second edition, 1997. [10] \nD. Flanagan. Java In a Nutshell: 3rd Edition. O Reilly, 3rd edition, 1999. [11] M. Fowler, K. Beck, J. \nBrant, W. Opdyke, and D. Roberts. Refactoring: Improving the Design of Existing Code. Addison-Wesley, \n1999. [12] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns. Addison Wesley, Reading, \nMA, 1995. [13] B. Henderson-Sellers. Object-Oriented Metrics: Measures of Complexity. Prentice-Hall, \n1996. [14] D. J. Jerding, J. T. Stansko, and T. Ball. Visualizing interactions in program executions. \nIn Proceedings of ICSE 97, pages 360 370, 1997. [15] R. Kazman and M. Burth. Assessing architectural \ncomplexity. Technical report, University of Waterloo, 1995. [16] M. F. Kleyn and P. C. Gingrich. Graphtrace \n understanding object-oriented systems using concurrently animated views. In Proceedings OOPSLA 88, ACM \nSIGPLAN Notices, pages 191 205, Nov. 1988. Published as Proceedings OOPSLA 88, ACM SIGPLAN Notices, volume \n23, number 11. [17] D. B. Lange and Y. Nakamura. Interactive visualization of design patterns can help \nin framework understanding. In Proceedings of OOPSLA 95, pages 342 357. ACM Press, 1995. [18] M. Lanza. \nCombining metrics and graphs for object oriented reverse engineering. Diploma thesis, University of Bern, \nOct. 1999. [19] M. Lorenz and J. Kidd. Object-Oriented Software Metrics: A Practical Guide. Prentice-Hall, \n1994. [20] H. M\u00a8uller. Rigi -A Model for Software System Construction, Integration, and Evaluation based \non Module Interface Speci.cations. PhD thesis, Rice University, 1986. [21] W. D. Pauw, R. Helm, D. Kimelman, \nand J. Vlissides. Visualizing the behavior of object-oriented systems. In Proceedings OOPSLA 93, ACM \nSIGPLAN Notices, pages 326 337, Oct. 1993. [22] W. D. Pauw and G. Sevitsky. Visualizing reference patterns \nfor solving memory leaks in Java. In R. Guerraoui, editor, Proceedings ECOOP 99, LCNS 1628, pages 116 \n134, Lisbon, Portugal, June 1999. Springer-Verlag. [23] S. P. Reiss. Interacting with the .eld environment. \nSoftware -Practice and Experience, 20:89 115, 1990. [24] J. T. Stasko. Tango: A framework and system \nfor algorithm animation. IEEE Computer, 23(9):27 39, September 1990. [25] P. Steyaert, C. Lucas, K. Mens, \nand T. D Hondt. Reuse contracts: Managing the evolution of reusable assets. In Proceedings of OOPSLA \n96 Conference, pages 268 285. ACM Press, 1996. [26] M.-A. D. Storey and H. A. M\u00a8uller. Manipulating and \ndocumenting software structures using shrimp views. In Proceedings of the 1995 International Conference \non Software Maintenance, 1995. [27] C. Ware. Information Visualization. Morgan Kaufmann, 2000. [28] N. \nWilde and R. Huitt. Maintenance support for object-oriented programs. IEEE Transactions on Software Engineering, \nSE-18(12):1038 1044, Dec. 1992.  \n\t\t\t", "proc_id": "504282", "abstract": "The reengineering and reverse engineering of software systems is gaining importance in software industry, because the accelerated turnover in software industry, because the accelerated turnover in software companies creates legacy systems in a shorter period of time. Especially understanding classes is a key activity in object-oriented programming, since classes represent the primary abstractions from which applications are built. The main problem of this task is to quickly grasp the purpose of a class and its inner structure. To help the reverse engineers in their first contact with a foreign system, we propose a categorization of classes based on the visualization of their internal structure. The contributions of this paper are a novel categorization of classes and a visualization of the which we call the <i>class blueprint</i>. We have validated the categorization on several case studies, two of which we present here.", "authors": [{"name": "Michele Lanza", "author_profile_id": "81100530597", "affiliation": "Software Composition Group, Univesity Of Bern, Bern, Switzerland", "person_id": "PP39047160", "email_address": "", "orcid_id": ""}, {"name": "St&#233;phane Ducasse", "author_profile_id": "81100625020", "affiliation": "Software Composition Group, Univesity Of Bern, Bern, Switzerland", "person_id": "PP15037878", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/504282.504304", "year": "2001", "article_id": "504304", "conference": "OOPSLA", "title": "A categorization of classes based on the visualization of their internal structure: the class blueprint", "url": "http://dl.acm.org/citation.cfm?id=504304"}