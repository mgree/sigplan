{"article_publication_date": "10-01-2001", "fulltext": "\n THE ARCHITECTURE OF A UML VIRTUAL MACHINE Dirk Riehle1, Steven Fraleigh1, Dirk Bucka-Lassen2, Nosa Omorogbe1 \n1SKYVA International 2Object Oriented, Ltd. One Cabot Road Kramgasse 5 Medford, MA 02155, U.S.A. 6004 \nLuzern, Switzerland ++ 1 781 306 7600 ++ 41 41 418 7071  dirk@riehle.org, sfraleigh@skyva.com, dirk@bucka-lassen.dk, \nnomorogbe@skyva.com ABSTRACT Current software development tools let developers model a soft\u00adware system \nand generate program code from the models to run the system. However, generating code and installing \na non-trivial system induces a time delay between changing the model and executing it that makes rapid \nmodel prototyping awkward if not impossible. This paper presents the architecture of a virtual ma\u00adchine \nfor UML that interprets UML models without any interme\u00addiate code-generation step. The paper shows how \nto embed UML in a metalevel architecture so that a key property of model-based systems, the causal connection \nbetween models and model in\u00adstances, is guaranteed. With this architecture, changes to a model have immediate \neffects on its execution, providing users with rapid feedback about the model s structure and behavior. \nThis approach supports model innovation better than today s code\u00adgeneration approaches. Categories and \nSubject Descriptors D.1.5 [Programming Techniques]: Object-oriented Program\u00adming metalevel architectures; \nD.2.2 [Software Engineering]: Design Tools and Techniques Evolutionary prototyping, Rapid prototyping, \nObject-oriented design methods; D.2.11 [Software Engineering]: Software Architectures Languages, UML; \nD.3.3 [Programming Languages]: Language Constructs and Fea\u00adtures Classes and objects, Frameworks; D.3.4 \n[Programming Languages]: Processors Code generation, Interpreters, Run\u00adtime environments, Virtual machines. \n General Terms Design, Languages. Keywords Metamodeling, Causal connection, UML virtual machines.  \n 1 INTRODUCTION Traditionally, object-oriented modeling languages like UML and OPEN have served to describe \nthe design of a software system Permission to make digital or hard copies of part or all of this work \nor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advantage and that copies bear this notice and the full citation on the first \npage. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior \nspecific permission and/or a fee. OOPSLA 01 Tampa Florida USA Copyright ACM 2001 1-58113-335-9/01/10 \n$5.00 [20, 3]. The implementation of the system is carried out as a sepa\u00adrate frequently time-consuming \nstep, in which detail is added to the design-level models. The separation of design from implemen\u00adtation \nposes a significant problem, because implementing a system can take a long time and its design and implementation \ncan easily get out of sync. Long time-to-market, missing documentation, and hard-to-change systems are \nthe consequence. With the industry-wide adoption of UML, a new breed of soft\u00adware development tools is \ngaining prominence. These tools gen\u00aderate code directly from the models. Users of a tool ideally model \ntheir domains using UML and then publish the models in the form of generated code into a runtime system. \nThe runtime system con\u00adnects the code with its environment, for example, databases or web-servers. Model-driven \ncode-generation has several advantages over the traditional approach, including: Shorter time-to-market. \nUsers model their domains rather than implement them. A modeling language like UML is bet\u00adter suited \nto express domain models than a programming language like Java or Smalltalk.  Increased reuse and fewer \nbugs. The tools hide the details of how the models are hooked up into the runtime system, free\u00ading users \nfrom knowing intricate details about used frame\u00adworks or system components.  Easier-to-understand system \nand up-to-date documentation.  Because design and implementation are always in sync, so is the documentation. \nThe system is easier to understand and better documented. However, code-generation does not solve all \nthe problems. In particular, it has the following drawback: Delay between model change and model instance \nexecution. Generating code from models, compiling this code, shutting down the existing system, installing \nand configuring the new system, and starting it up can take from minutes to hours. This time delay makes \nexploration and simulation of new models with immediate user feedback awkward if not impossible, thereby \nsignificantly hindering the innovative exploration of the model solution space. The resulting models \neasily become sub-optimal. This paper presents the architecture of a virtual machine for UML. The virtual \nmachine represents the modeling language (UML), the models described using UML, and the model instances \nas first\u00adclass entities. For executing a model, the virtual machine instanti\u00ad  Figure 1: Four-level \nmodeling architecture with Bank Account example. (Dotted lines, right to left, show an instance-of relationship.) \nates and interprets the model according to UML semantics. With all models on all levels being explicitly \nrepresented, changing a system s model leads to immediate (controlled) effects on the running system. \nAs a result, the system provides short feedback cycles and allows for simulation and rapid exploration \nof model variants, better supporting innovation than possible with code\u00adgeneration approaches. The virtual \nmachine has a logical architecture that is based on the UML four-level modeling architecture and a physical \narchitecture that realizes the logical architecture as an object-oriented frame\u00adwork. The logical architecture \nis a metalevel architecture, and the physical architecture implements it. As the paper s main contribu\u00adtion, \nwe discuss how the logical and physical architecture fulfill the causal connection requirement that seamlessly \nand recursively integrates a model with its instances. Thus, our discussion focuses on the structural \naspects of the architecture, leaving a discussion of the behavioral aspects to further papers. We discuss \nthe changes we applied to the UML specification and the enhance\u00adments that we added to UML to overcome \nits limitations. The architecture of the virtual machine has been explored in two projects at UBS and \nhas been consolidated as a core piece of the flagship product of SKYVA International. The virtual machine \nis part of a system that combines a modeling environment with a model execution environment, much like \nCLOS, Smalltalk, or Self systems provide both a programming environment and a pro\u00adgram execution environment \n[21, 7, 31]. We report about our experiences of using SKYVA s system in industry projects. Section 2 \nreviews the architecture of UML-based systems in gen\u00aderal. Section 3 presents the architecture of the \nvirtual machine and how it realizes the requirements set up in Section 2. Section 4 reviews key implementation \naspects. Section 5 reviews changes and additions we have applied to the UML specification. Section 6 \nthen reports about our experiences with the virtual machine. Section 7 finally lists related work and \nSection 8 shows how this work will proceed further and what challenges we see ahead.  2 MODEL-BASED \nSYSTEMS The UML specification defines four logical levels of modeling, called the M0, M1, M2, and M3-level \n(M stands for model) [20, 17]. These four levels define the logical architecture of any UML\u00adbased system \nand therefore form the requirements for a virtual machine that is capable of representing and running \nsuch a sys\u00adtem. The M0-level contains objects that represent the currently running system. These objects \nare also called user objects or domain objects.  The M1-level contains objects that represent a model \nof the currently running system. These objects are also called user classes or domain classes.  The \nM2-level contains objects that represent the modeling language, in our case UML. This level is also called \nthe metamodel level.  The M3-level contains objects that represent the language in which UML is represented. \nThis level is also called the meta\u00admetamodel level.  Every level provides the means to describe the \nnext lower level, so the M3-level is used to describe the M2-level (UML), the M2\u00adlevel is used to describe \nthe M1-level (system models), and the M1-level describes the M0-level (running systems). In theory, the \nnumber of levels is unbounded, but for most practical purposes, four levels are sufficient. 2.1 Causal \nConnection The four-level architecture is an object architecture that helps us understand a system s \nlogical object structure (as opposed to its physical architecture, see Section 3). Effectively, the logical \narchi\u00adtecture serves as a high-level explanation of how objects relate to each other (which object models \nwhich other object; which object is an instance of which other object).  Figure 2: Separation of modeling \nfrom runtime environment in code-generation approaches. Figure 1 displays these four levels and an example. \nThe examples are bank accounts. Each rectangle represents an object (using UML as the design notation). \nThe dependency arrows, from right to left, indicate a logical instance-of relationship. During development, \nsoftware developers use UML objects (M2\u00adlevel objects) to define user classes (M1-level objects). In \nthe example, developers define three types of bank accounts, Check\u00ading-, Savings-, and ForeignCurrencyAccount. \nAt run-time, the user classes are instantiated, displayed in Figure 1 as the user objects checking12345, \nsavings12345, etc. These user objects are M0-level objects.1 For a system of this architecture to be \nin a valid state, we define the causal connection property, as known from metalevel archi\u00adtectures [33, \n34]: M0-level user objects are different from M1-level Instance objects. Instances of the UML Instance \nconcept add to the specifi\u00adcation of an M1-level class, typically by participating in an illus\u00adtrating \nscenario of how instances of the class behave. However, they do not directly represent an instance of \nthe class. DEFINITION: CAUSAL CONNECTION A modeling level is causally connected with the next higher \nmodeling level, if the lower level conforms to the higher level and if changes in the higher level lead \nto according changes in the lower level. In a model-based system, in which modeling levels are causally \nconnected, changes to a model cause the structure and behavior of all model instances to change accordingly. \n 2.2 Code-generation Approach Current software development tools use a code-generation ap\u00adproach to \ncausally connect modeling levels. Typically using graphical editors, M2-level objects (UML classes) are \ninstantiated to give users M1-level objects, representing domain classes. For example, inside such a \nsoftware development tool, the checking-Account object logically represents what users of the tool perceive \nas their CheckingAccount class. Users of such tools design a do\u00admain model consisting of M1-level objects, \nwhich are instances of the M2-level UML classes.  Figure 3: Convergence of modeling and runtime environment. \nTo create and handle user objects like checking12345, the tool creates a programming-language-level class \nfor each M1-level object. The checking12345 object becomes an instance of the programming-language-level \nclass corresponding to the checking-Account object. Typically, there is a one-to-one correspondence between \na model-level class and a programming-language-level class or interface [8]. This code-generation approach \nfully sepa\u00adrates the modeling-language M1-level objects from the M0-level objects. This separation corresponds \nto the two types of environ\u00adments in which the objects are handled: M1-level objects solely exist in \na modeling environment, and M0-level objects solely exist in a runtime environment. Figure 2 illustrates \nthis separation. M1-level objects in the model\u00ading environment are mapped on the corresponding M1-level \nclasses of the runtime environment. The causal connection be\u00adtween model and model instances is maintained \nby the code\u00adgenerator. Only if the modeling environment generates code, do the model changes carry over \ninto the runtime environment, lead\u00ading to the execution of the model instances according to the changed \nmodel. A single round-trip between the modeling environment and the runtime environment can take several \nminutes if not hours. For non-trivial systems, the delay between model change and model execution makes \nrapid exploration of new models impossible, because the time delay between model change and execution \nis too long. Users, who may have to wait for hours until a model change becomes executable, tend not \nto explore a wide range of model options but go the easiest possible path, not exploring pos\u00adsibly better \nalternatives.  2.3 Virtual Machine Approach An interpreter approach avoids the intermediate step of \ngenerating M1-level classes out of M1-level objects. Rather, the runtime system directly interprets the \nM1-level objects. All objects exist in the same memory space, making the causal connection between a \nmodel and its instances immediate. Modeling and runtime envi\u00adronment converge, letting users explore \nnew models with rapid feedback on how these models execute. Simulation results can be immediately at \nhand, allowing for a rapid prototyping style on the modeling level as known from interpreted object systems. \nFigure 3 shows how modeling and runtime environment converge. Users can now interactively explore model \nbehavior and model variants in real-time. This leads to a working style as known from Smalltalk and Self \nwhere users incrementally define and explore models. This working style supports the innovative creation \nof new models in their respective application domain. We have designed and implemented a system that \ndirectly sup\u00adports the logical four-level architecture and embeds it in a com\u00adbined modeling and runtime \nenvironment. The centerpiece of this system is a virtual machine that directly interprets UML models. \nA UML virtual machine, like any virtual machine, is an abstract computing machine. It provides an instruction \nset and a memory model for representing objects [13, 6]. As the instruction set of the virtual machine, \nwe use UML itself. UML provides several behavior modeling capabilities that can be used to describe the \nbehavior of a model (including itself).2 Mod\u00adels are persistently represented using XMI, the OMG standard \nfor representing UML models using XML [19]. For the memory model of the virtual machine, we use the memory \nmanagement facilities of our implementation language, Java. Every logical object from any M-level is \nrepresented as a Java object. As Section 6 shows, we add additional capabilities for model and model \ninstance management and garbage collection. 2 The current UML specification (UML 1.3) is so imprecise \nthat it is unlikely that two different UML virtual machine imple\u00admentations behave the same. We address \nthis question in Section 3.5, 6, and 7. metaClass : MetaClass class : MetaClass checkingAccount : Class \nclassifier : MetaClass modelElement : MetaClass element : Class g1 : Generalization g2 : Generalization \ng3 : Generalization instance type parent parent child child g5 : Generalization g4 : Generalization child \nparent parent child type : AssociationEnd a1 : Association instance : AssociationEnd type instance type \nparent child type instance Logical Objects and Classes (Logical Architecture) checking12345 : Element \ninstance ModelElement Element Class MetaClass Classifier -instance0..* -type 1 Physical Classes (Physical \nArchitecture) Figure 4: Simplified structure of logical and physical architecture.  3 VIRTUAL MACHINE \nARCHITECTURE The architecture of the virtual machine has two parts: a logical architecture and a physical \narchitecture. The logical architecture describes the logical structure of how objects relate; it is \nan extension of the architecture of UML-based systems as discussed in Section 2.  The physical architecture \nrealizes the logical architecture; it takes the form of an object-oriented framework that imple\u00adments \nthe physical classes of the logical objects.  The logical architecture defines how to achieve the causal \nconnec\u00adtion property, and the physical architecture implements how to achieve this property. There can \nbe different physical implementa\u00adtion architectures, driven by different needs. Our architecture focuses \non the efficient representation of model instances. This section discusses the architecture and how it \nfulfills the causal connection property. 3.1 Logical Architecture The logical architecture is a pure \nobject architecture: everything is a first-class object, including classes and their specification of \ninstance behavior. Thus, objects represent UML classes, objects represent user classes, and objects represent \nuser objects. This part of the logical architecture conforms to the architecture of UML\u00adbased systems \nas discussed in Section 2. The upper half of Figure 4 shows the logical architecture. In the logical \narchitecture layer, we can see classes like element, modelElement, classifier, etc. (In the running text, \nlogical objects are set in italics.) Because these classes are objects and not programming-language\u00adlevel \nclasses, the only way of connecting them are object links. Hence, we represent relationships like inheritance \nand association using objects. For example, Figure 4 shows some inheritance relationships, represented \nas objects named g1, g2, g3, etc. Using UML terminology, any such object is a generalization object, \nand it connects a parent class with its child class.  Figure 5: Logical and physical instance-of relationships. \nThe root class of all classes in the logical architecture is called element. It specifies the properties \ncommon to all objects in the logical architecture. A prominent subclass of element is mod\u00adelElement, \nthe root class of all UML classes. A class in the logical architecture defines which attributes its instances \nmay have and with which elements its instances may be associated. The logical architecture defines the \nassociation a1 between the element class and the class class. This association specifies the link between \na logical object and its describing logical class. An element object in an instance of this association \nplays the instance role and a class in an instance of this association plays the type role. This association \nlinks every element with its class and is the primary means for fulfilling the causal connection property. \nThe logical architecture is a single rooted class hierarchy. Thus, every object is a direct or indirect \ninstance of element. Figure 4 shows several instances of the instance/type association between element \nand class: checking12345 is an instance of checkingAc\u00adcount, checkingAccount is an instance of class, \nand class is an instance of metaClass, just like the four-level modeling architec\u00adture for UML-based \nsystems requires. Summarizing, the logical architecture mirrors the architecture of UML-based systems \nas described in Section 2. It also adds several classes like element, and several new associations like \nthe in\u00adstance/type association that specifies how to logically connect an object with its class.  3.2 \nPhysical Architecture The physical architecture is a set of Java classes (in our case) that interact \nin well-defined ways; it forms an object-oriented frame\u00adwork [28, 25]. The physical architecture provides \nthe physical classes for the representation of logical objects. Every object in the logical architecture \nhas both a logical class and a physical class. The logical class defines its model-relevant properties \nand the physical class is the programming-language\u00adlevel class from which the object is physically instantiated. \nIn its lower half, Figure 4 shows the physical architecture. It shows the five programming-language-level \nclasses Element, ModelElement, Classifier, Class, and MetaClass. Element is the physical class of all \nlogical M0-level objects, Class is the physical class of all logical M1-level classes, and MetaClass \nis the class of all logical M2-level classes. ModelElement and Classifier are superclasses that are usually \nnot instantiated. The logical architecture provides a logical class for every class in the UML specification. \nThereby, the full UML specification is provided as first-class objects. Many of these logical classes \nhave a corresponding physical class, but not all. If a physical class ex\u00adists, its instances are used \nas instances of the corresponding logi\u00adcal class. If no immediately corresponding physical class exists, \nthe closest physical superclass in the inheritance hierarchy is used. Figure 5 shows examples of physical \nand logical instance-of rela\u00adtionships. The physical instance-of relationship exists between a physical \nclass and a logical object. The logical instance-of rela\u00adtionship exists between a logical class and \nits logical instances. For example, the checking12345 object has the physical class Element and the logical \nclass checkingAccount. The checkingAc\u00adcount object has the physical class Class and the logical class \nclass. The class object has the physical class MetaClass and the logical class metaClass. The logical \nclass of an object defines the properties of the object from a logical modeling perspective: it defines \nits attributes and associations; it defines its state model and runtime behavior. At any given point \nin time during the execution of the system can an object ask its class about its properties and may the \nclass change the properties of its instances. The implementation of physical classes like Element and \nClass makes sure that their instances behave according to their logical classes. Element is the root \nclass of all model-relevant physical classes (except for the data type implementations), including Class \nand MetaClass. It provides a generic attribute and association handling mechanism (and more) that is \ndiscussed in Section 3.4.  3.3 Model Representation Representing models using this architecture is straightforward. \nFigure 6 shows a domain model of a Customer and some Account classes. Figure 7 shows this model s representation \nusing logical objects as defined in the UML specification. The model representation in Figure 7 represents \nevery detail of the UML model in Figure 6 as an object, following the UML specifi\u00ad  Figure 6: Domain \nmodel of Customer and Accounts. Figure 7: Logical class representation of Customer and Accounts domain \nmodel. cation. For example, the inheritance arrow between Account and CheckingAccount is represented \nas an instance of the UML Gen\u00aderalization class. The class name given for an object in Figure 7 is the \nname of the physical class. The logical class is not shown. For example, ac\u00adcount is physically an instance \nof Class. Logically it is an instance of class. The generalization g7 is physically an instance of Gener\u00adalization \n(a physical class) and logically an instance of generaliza\u00adtion (a logical class object). The same mechanism \nthat lets us represent M1-level domain models also lets us represent M2-level models, including UML itself. \nFigure 8 shows a small excerpt from the UML specification, and Figure 9 shows its object representation. \nThe physical class of a UML class is MetaClass and the logical class is metaClass. For example, the logical \nclasses generalization and association are instances of MetaClass. The relationships are represented \nusing UML, which is a defined operation, because metaClass is a subclass of class. Hence, all modeling \nfunctionality applicable to class is also applicable to metaClass.  3.4 Physical Class Model The structural \nbackbone of the architecture is repeated in Figure 10. It takes the structure of a metalevel architecture \n[33, 10]. The following two classes are of particular importance: Element. This is the physical (super-)class \nof any logical object in the system.  Class. This is the physical (super-)class of all logical objects \nrepresenting classes in the system.  We discuss these two classes in turn. 3.4.1 Element UML defines \nthe modeling capabilities with which an M1-level user class can be described. Consequently, an M0-level \nobject must provide capabilities to do whatever its M1-level class speci\u00adfies. Thus, the UML specification \nindirectly determines the capa\u00adbilities of any M0-level object and hence the interface and imple\u00admentation \nof the Element class. The structural capabilities include: It may have attributes.  It may have links \nto other elements, where linked-to elements are conceptually different from attributes.  It may provide \nassociation objects for a given link, if so specified in the model.  It may be a node in an object composition \nhierarchy.  From this feature set, we derive the core functionality of the Ele\u00adment class. We add functionality \nthat supports handling of ele\u00adments for the virtual machine. Listing 1 shows this functionality, reduced \nto the essentials. The Element class makes some simplifying assumptions, for ex\u00adample, it does not support \nmulti-valued attributes and it pragmati\u00adcally distinguishes associations of multiplicity 0..1 from those \nof multiplicity 0..n. Section 5 discusses some of these simplifica\u00adtions. Section 4 discusses some efficiency \nconsiderations for im\u00adplementing the Element class. With these capabilities, any physical Element instance \ncan suc\u00adcessfully play the role of a logical instance of a logical class. Whatever structure or behavior \nis modeled for instances of that class, Element provides the functionality to represent it.  +child \n+generalization 1*  1 +parent +specialization * +type 1*   Figure 8: Small and simplified excerpt \nfrom the UML specification. a3 : Association generalization : MetaClass  a4 : Association  a5 : Association \nassociationEnd : MetaClass  Figure 9: Object representation of the model excerpt from Figure 8. 3.4.2 \nClass The single Element class is fully sufficient to represent all logical objects and hence the whole \nlogical architecture. Element in\u00adstances can play the role of the checking12345 object and the role of \nthe checkingAccount, class, and metaClass classes. However, this is hard to program with and not very \nefficient. It is hard to program with, because tool implementers have to program against a generic interface \nrather than a more specific interface that expresses the functionality of the class of the object. It \nis not very efficient because a generic implementation cannot take ad\u00advantage of constraints that a specific \nclass may be aware of. For this reason, we implement large parts of the UML as sub\u00adclasses of Element. \nBy making them subclasses of Element, they inherit its capabilities and hence become full-fledged UML\u00adspecified \nobjects themselves. Many of the methods, specifically for attribute and association access, are mere \nconvenience wrap\u00adpers around the generic methods inherited from Element. How\u00adever, every such class is \nfree to add functionality that makes using it easier. One such class is Class. Listing 2 shows its interface. \nThe Class interface provides methods that are derived from the UML specification. For every known feature \nand association, query and mutation methods exist. As mentioned, these methods are convenience wrappers \nof the more generic Element methods. Listing 3 shows the implementation of two such methods. Of more \ninterest is implementation functionality specific to class Class. A prime example is the provision of \nkeys that unambigu\u00adously identify attributes and associations. For modeling the attrib\u00adutes and associations \nof a class, UML provides dedicated Attrib\u00adute and Association classes. While suitable for modeling, they \nare too heavy for executing models, and hence we have replaced them with more lightweight key objects \nfor attribute and association access. These keys provide essential typing information and make attribute \nand association access more efficient. Section 4 discusses these and other implementation considerations. \n 3.4.3 Data types The implementation of primitive data types like integer and string and non-primitive \ndata types like money and currency is outside the scope of the Element class hierarchy. Their classes, \nhowever, are represented as UML DataType instances. For their implemen\u00adtation, we use the standard Java \nclasses Integer, String, etc. and the data type framework JValue [24].  3.4.4 Match Between Logical \nand Physical Model Every physical class is represented as a logical class in the logical architecture. \nThe physical model mirrors (parts of) the logical model. The class model of Figure 10 exists both on \nthe physical and logical level. Therefore, we have both a physical and logical class Element. The same \nholds true for MetaClass.  We match the physical with the logical model, because it reduces the intellectual \nburden for programmers that implement modeling tools. Programming with a statically typed interface is \neasier and less error-prone than programming with a generic interface.  3.5 Model Execution The discussion \nso far has focused on how to represent models across modeling levels. This subsection discusses how we \nexecute these models. We can only provide a partial solution, as we make several assumptions about model \nexecution based on our runtime architecture. As far as we know, every existing tool with claims similar \nto ours makes such restricting assumptions about the run\u00adtime system and therefore constrains what can \nbe modeled. There are two main reasons for this: first, UML is not defined precisely enough to allow \nfor unambiguous model execution, and second, even if UML was defined precisely enough, one still needs \na dedi\u00adcated runtime architecture on top of which the models run and with which they are integrated. \nOut of necessity, this runtime architecture imposes constraints on what can be executed and what cannot \nbe executed. In this section, we therefore only dem\u00adonstrate that model interpretation is possible, and \nleave the details to further papers. UML provides several modeling techniques for specifying the behavior \nof classes. Most of these techniques focus on illustrating behavior rather than completely specifying \nit. Examples of these techniques are object collaboration diagrams and message se\u00adquence diagrams. Illustrating \nbehavior means that any such dia\u00adgram illustrates one specific case of object interaction and behav\u00adior, \nbut it does not specify the overall possible set of interactions. While helpful to communicate design \nintent to human readers, these techniques are not sufficient for fully specifying object be\u00adhavior as \nneeded by a virtual machine to execute model instances. The one modeling technique that strives for complete \nbehavior modeling is UML state charts. We use them as the primary tool for modeling object behavior. \nEvery class has a state chart that describes the state space of its instances and the possible transi\u00adtions \nthat may occur. Each instance interprets the state chart whenever it receives an event in its mailbox. \nIt then reacts accord\u00adingly by possibly changing its state and sending out events that represent the \nstate transitions. The state machine interpretation is part of the Element class implementation. We further \nenrich class descriptions using OCL, the Object Con\u00adstraint Language [20] to ensure constraints like \nbusiness rules between elements. State charts serve well to describe the behavior of individual objects, \nbut they do not scale up to describe the behavior of larger parts of a system. We use OCL to describe \ninter-object dependencies as constraints between objects. This way, state transitions in one object are \ntranslated into events rele\u00advant to other objects that are not connected with the originating object \nthrough a state chart. Finally, UML is a modeling language and not (yet) a program\u00adming language, so \nwe add algorithmic detail as hand-programmed policy classes that fit into a well-defined extension architecture \n[25] (a.k.a. plug-in architecture [16]). This extension architecture is part of our runtime architecture. \nIt both supports and constrains developers in what is possible in terms of model execution. De\u00advelopers \nof a model do not only use UML to describe system be\u00adhavior, but also implement policy classes (using \nthe Strategy de\u00adsign pattern [4]) and hook them up into the model. Hand-programmed policy classes do \nnot contradict the idea of a UML virtual machine. First, UML is not fully executable; hence we need something \nlike policies to add algorithmic detail. Second, UML is not a programming language but rather a modeling \nlan\u00adguage. Until an executable Action semantics specification for public interface Element { // UML: \nattributes (single-valued) // The FeatureKey identifies the attribute. public Object getAttributeValue(FeatureKey \nfk); public void setAttributeValue(FeatureKey fk, Object value); ... // UML: associations with 0..1 \nmultiplicity // The AssociationKey identifies the association. public boolean hasLinkedElement(AssociationKey \nak); public Element getLinkedElement(AssociationKey ak); public void setLinkedElement(AssociationKey \nak, Element e); // UML: associations with 0..n multiplicity // The AssociationKey identifies the association. \npublic Iterator allLinkedElements(AssociationKey ak); public void addLinkedElement(AssociationKey ak, \nElement e); public void removeLinkedElement(AssociationKey ak, Element e); ... // UML: association object \naccess (functionally dependent on association) // The AssociationKey identifies the association. public \nboolean hasAssociationElement(AssociationKey ak); public AssociationElement getAssociationElement(AssociationKey \nak); ... // VM model: access to type object // With respect to its class, this element plays the instance \nrole. public Class getElementClass(); ... // VM implementation: backpointer // Provides list of objects \nlinked to this element. public Iterator backpointer(); ... }  Listing 1: Element interface, reduced \nto the essentials. UML is available, UML cannot also play the role of a program\u00adming language, and hence \nhas to be complemented by one. The need for more complete behavior specification and executable semantics \nof UML models has been recognized. The OMG issued a Request for Proposals (RFP) for executable Action \nsemantics and several groups have responded to it [18]. One of the most important uses of such executable \nAction semantics will be its application to UML itself, effectively providing a formal and as complete \nas possible UML virtual machine specification.  3.6 Causal Connection We need to show that the presented \narchitecture fulfills the causal connection property so that changes in a model lead to immediate changes \nin the model instances. As Figure 4 shows, the element class is logically the superclass of all other \nlogical classes. Every instance of element (independently of which modeling level it resides on) has \na link to its class. Thus, every element is connected with the specification of its behavior. The Element \nclass implementation makes use of this link to de\u00adtermine how an element is to behave and then makes \nit behave that way. This ensures that every element behaves according to its specification. In UML, a \nmodel is defined as a package of interconnected classes. In the discussed architecture, changes to a \nclass and hence to a model immediately affect any model instance. Thus, a model is causally connected \nwith its model instances. Schema evolution remains a difficult topic. SKYVA s system lets users specify \nhow instances of an old class version are to be con\u00adverted into instances of the new class version. These \nbridges be\u00adtween model versions are one of our extensions to UML. They integrate configuration management \nwith model evolution with instance upgrading.  4 IMPLEMENTATION At its primitive level, the implementation \nof the Element class and its related classes draws on the access of attributes and associa\u00adtions. Getting \nthe implementation of these primitives right deter\u00admines the overall performance more than any other \nfactor. All publicly available UML implementations that we have seen use string-based access to attributes \nand associations. We use key\u00adbased rather than string-based access to attributes and associa\u00adtions. This \nmade our virtual machine implementation perform significantly faster and removed dynamic typing problems \nthat occur when attributes or associations are named using potentially misspelled strings. A key object \nindicates a specific attribute or association. Effec\u00adtively, it is a shallow representation of the corresponding \nAttribute or AssociationEnd object. For attribute access, we provide dedi\u00adcated feature key objects, \nand for association access, we provide dedicated association key objects, as illustrated in Listings \n1, 2, public interface Class extends Classifier { // UML: a class has features that can be accessed \nby name public boolean hasFeature(String featureName); public Feature getFeature(String featureName); \npublic Iterator allFeatures(); public void addFeature(String featureName, Feature f); public void removeFeature(String \nfeatureName); ... // UML: a class has association ends that link it to associations public boolean hasAssociationEnd(String \nroleName); public AssociationEnd getAssociationEnd(String roleName); public Iterator allAssociationEnds(); \npublic void addAssociationEnd(AssociationEnd ae); public void removeAssociationEnd(AssociationEnd ae); \n... // VM implementation: provide access to keys public Iterator allFeatureKeys(); public FeatureKey \ngetFeatureKey(String attributeName); public Iterator allAssociationKeys(); public AssociationKey getAssociationKey(String \nroleName); ... }  Listing 2: Class interface (showing inherited Classifier methods for convenience). \npublic Feature allFeatures() { return allLinkedElements(FEATURE_KEY); } public void addFeature(Feature \nf) { addLinkedElement(FEATURE_KEY, f); }  Listing 3: How Class uses the generic methods of Element. \nand 3. For every attribute of a class, one feature key is created and updated whenever the attribute \ns definition changes. The same is done for associations and association keys. Because a class changes \nless frequently than its instances, creating and updating the keys does not pose a significant runtime \noverhead. Every key provides a unique index into an array for efficient ac\u00adcess to the attribute s value \nor linked-to element. The class man\u00adaging the keys has a complete overview of all its keys and can therefore \ncompute a perfect distribution of indices for the keys. Every element manages its attribute values and \nlinked-to elements in an array. Looking up an attribute s value or a referenced ele\u00adment is as simple \nand fast as the access to a field in the array. A key does not only provide an index into an array but \nalso pro\u00advides typing information. Effectively, type information is copied from the model into the key \nand transformed with the goal of speeding up type checking. Whenever an attribute or association is accessed, \nit must be checked whether the key is actually a valid key identifying an attribute and association that \nreally exists for the given object. This type checking is necessary to protect against bugs in the virtual \nmachine implementation and in the policy implementations by which users add programmatic behavior to \nmodels. A sequence of checks ensures integrity of access: the owner of the key and the logical class \nof the element must be identical, and the typing information found in the key must match the meta\u00adinformation \nstored directly in the element, for example, whether a linked-to element is truly a composed element \nor merely a regu\u00adlarly associated element. Finally, key objects are shared immutable objects. A managing \nobject controls their instantiation (see the Flyweight design pat\u00adtern [4]). This way, no client code \ncan create key objects. This lets the system maintain control over typing information. No typing information \never enters the system from the outside without being checked at the system boundaries. Client code like \npolicies re\u00adquest key objects, they do not create them. While this cannot pre\u00advent that a message is \nbeing sent to the wrong object, it at least ensures that the message is always a valid message. We discuss \nfurther implementation considerations and optimiza\u00adtions in a related paper [26].  5 UML EXTENSIONS \nIn Section 3 on the virtual machine architecture, we describe how we make UML part of a larger logical \narchitecture. In this section, we discuss some of our extensions to UML and some of the sim\u00adplifications \nwe applied. 5.1 Technical Domain Models (M1) For executing application domain models, users need a means \nto express how to present the model instances in user interfaces for user interaction, how to represent \nthem for persistence in data\u00adbases, and how to distribute them across different processes and computer \nsystems. M2+ Category M1+ Category  0..* -ownedElement -namespace 1  0..* -ownedElement -package \n1      Figure 11: Managing elements in packages and applications. This information is cast as technical \ndomain models that exist next to application domain models (technical meaning a technical in\u00adfrastructure \napplication domain as opposed to a business applica\u00adtion domain).3 Users can extend and configure the \ntechnical do\u00admain models as much as they can define and then extend and con\u00adfigure the application domain \nmodels. The first user of these technical domain models is the modeling environment itself. It uses models \nto describe user interface lay\u00adouts, database schema mappings, and system distribution. Most of the technical \ndomain models are specific to a given run\u00adtime environment and therefore may differ widely from implementation \nto implementation of a UML virtual machine. One common technical need, however, that is likely to be \nfound in any system implementation, is the need to organize model in\u00adstances in packages and applications. \nWe therefore extend the UML package concepts to apply to every element, not just UML model elements. \nFigure 11 shows the resulting model. Figure 11 shows two Package classes. On left, it shows the tradi\u00adtional \nUML Package class, which is a subclass of Namespace and which is reserved to contain only model elements. \nOn the right, Figure 11 shows a general Package class that can contain any kind of element, be it a UML \nmodel element or a non-UML element. The semantics of the general Package class are weaker than those \nof the UML Package class: it accepts different elements with the same name and it does not support package \ninheritance. This shift in semantics is the reason why we decided to introduce the gen\u00aderal Package class \nrather than to extend the existing UML Pack- These technical domain models are equivalent to the class \nlibraries and frameworks that come with Smalltalk and Java. age class to contain any type of element. \nA special subclass of the general Package class is Application. Its instances are the root objects for \na given application.   5.2 Modeling Language Extensions (M2) We extended UML to provide hooks for our \nspecific runtime architecture (see Section 3.5). These changes were necessary to make UML executable \n(within the limits of our architecture). Finally, we have developed a number of UML extensions (pro\u00adfiles) \nthat customize UML for use in organizational and supply chain modeling. 5.3 UML Simplifications In our \nUML implementation, we have applied a number of simpli\u00adfications. Structural simplifications include: \n No multi-valued attributes of elements.  Attributes of elements are always UML data types.  Only binary \nassociations between classes.  So far, we have not encountered any problems due to these restrictions. \n  6 EXPERIENCES We have built three systems with this type of architecture, two at UBS, one of the world \ns largest banks, and one at SKYVA Inter\u00adnational, a provider of supply-chain management software. The \ntwo systems built at Ubilab, the late IT research laboratory of UBS, were a research prototype that provided \na full-fledged metalevel architecture as described in this paper, and a produc\u00adtion-level system that \nlet users model, represent and edit corporate loans. The research prototype was used to explore and demon\u00adstrate \nthe idea of model-driven software systems based on a dy\u00adnamic object model, as we called it at that time. \nThe production\u00adlevel system is used in UBS corporate customer business. Its primary functionality is \nin capturing and presenting corporate loans. Effectively, it is an object-oriented product data manage\u00adment \nsystem. Both systems did not use UML on the M2-level but rather a simpler proprietary metamodel. Both \nsystems worked well for their purpose. However, both systems focussed primarily on representing and editing \nstructure, which is much simpler than representing and executing behavior. The UML virtual machine built \nat SKYVA International is part of SKYVA s main product for supply chain management and col\u00adlaborative \ne-commerce. It has been used in a number of industry projects and is the most extensive base of our implementation \nexperience. The system exhibits most characteristics discussed in this paper. It has a full-fledged UML-based \nmetalevel architec\u00adture. It lets users model their application domain and execute these models. Feedback \non model changes is immediate and sup\u00adports users in exploring domain models. Still, it is a hybrid system: \nfor innovative model exploration and system configuration, we use an interpreted approach, and for production-level \nsystem execution, we use a code-generation ap\u00adproach. Hence, we have two runtime environments: one UML \nvirtual machine that is embedded in the modeling environment and that allows for lightweight model execution, \nand one that is a separate system capable of carrying high volume transactions and mass data persistence. \nOur biggest remaining problem is modeling of behavior and exe\u00adcution of the modeled behavior. At the \ntime of writing, we still have to implement a significant amount of code (policies) to add behavior to \nthe models. UML s behavior modeling features are not sufficient to completely describe desired behavior \nand our behavior modeling extensions and implementations have not fully overcome this problem. However, \nother companies, for example Project Technology [22] and Kennedy Carter [11] have shown that precise \nbehavior modeling is possible with (an extended form of) UML. Their systems allow the execution of models \nbased purely on modeled rather than implemented behavior. Key to their approach as well as our approach \nis knowledge about the target runtime architecture. SKYVA s system comprises significantly more components \nthan the virtual machine discussed in this paper. The modeling envi\u00adronment provides an elaborate repository-based \ninfrastructure that supports model persistence, configuration management, collabora\u00adtion in a team and \nmore. The system provides not only technical domain models but generic application domain models as well, \ntargeted at supply-chain management and e-commerce. We have found that generic domain models are best \nsupported by UML extensions that reflect the domain concepts. Similarly, we have found that UML extensions \nwithout a complementing ge\u00adneric domain model are of limited use, because we cannot inte\u00adgrate separately \ndeveloped domain models. This is in contrast to industry s current attempts to provide standards by extending \nUML only without providing (generic M1-level) domain models. Also, we view the lack of a standardized \nElement class as a major hindrance for integrating independently developed domain models in UML-based \nmodeling. 7 RELATED WORK We discuss related work on virtual machines, metalevel architec\u00adtures, model-driven \nsoftware systems and UML-based software development tools. Virtual machines for programming languages \nlike Smalltalk [6], Self [31, 9], and Java [1, 13] have both inspired this work as a metaphor and provided \nsolid implementation advice. Like Small\u00adtalk and Self, and unlike Java, we fully represent the modeling \nlanguage using the system s own capabilities. The architecture of the virtual machine, however, probably \nowes most to CLOS [2, 21, 5]. CLOS simple yet elegant metalevel architecture directly influenced how \nwe extend UML with M1 and M3-level classes to turn the logical model into a reflective system. We share \nBrian Foote s conviction that a system should be built on flexible foundations in the form of open languages, \nimple\u00admented using a metalevel architecture approach [34]. For this reason, we represent UML and its \ndomain modeling extensions as models, available for introspection and possible change. While the described \narchitecture shares structural and behavioral properties with the CLOS metalevel architecture and related \nre\u00adflective architectures [14, 33, 10, 23, 34], we address a problem that has not been addressed by any \nsuch programming-language centric architecture: the modeling of application domains using a dedicated \nmodeling language and the execution of the resulting models. To the best of our knowledge, we are the \nfirst to combine a modeling language with a metalevel architecture with a virtual machine approach. Others \nhave recognized the need for model-driven software sys\u00adtems that provide an explicit model of them. Such \nsystems are said to have an adaptive or dynamic object model [32, 26]. Most notably, Tilman provides \nan account of an object-oriented frame\u00adwork that is used to capture models and model instances and to \npersist them between instantiations [30]. Tilman s application domain is form-based workflow-oriented \nbusiness applications. A similar system is discussed by Kovacs [12]. Kovacs and his col\u00adleagues built \na system for product configuration and workflow management of large high-energy physics detectors. Similarly, \nManolescu discusses a system that explicitly represents workflow descriptions next to the actual workflows \n[15]. Common to these systems is that they all have a modeling layer next to an instance layer. However, \nin all three cases, the modeling language is do\u00admain-specific (or specific to that system). Currently, \na lot of industry research and development is invested into UML-based modeling tools. As discussed in \nthe introduction, the common pattern is to model a system using UML and then to generate code and publish \nthe code into a runtime system [8]. A few systems have enhanced UML with precise behavior modeling so \nthat no programming by hand is necessary. An example is Pro\u00adject Technology s BridgePoint system [22], \noriginally based on the Shlaer Mellor methodology [29]. BridgePoint lets users model embedded systems \nusing an enhanced form of UML that supports precise behavior modeling. From the models, code is generated. \nAnother example is Kennedy Carter s iUML tool suite that sup\u00adports modeling of embedded systems using \nUML with precise action semantics [11]. iUML also let s users simulate the modeled system, providing \nfeedback about the system. Project Technology and Kennedy Carter have worked together on a submission \nto the OMG RFP for precise action semantics for UML. 8 CONCLUSIONS This paper presents the architecture \nof a virtual machine for UML. The virtual machine consists of a logical extension of the UML four-level \nmodeling architecture plus an object-oriented frame\u00adwork that implements this architecture. The virtual \nmachine ex\u00adplicitly represents UML, UML models, and UML model instances (actual instances of running \nsystems). The paper shows how a fundamental property of UML virtual machines, the causal con\u00adnection \nbetween a model and its instances, can be achieved. This approach lets users immediately see the effects \nof model changes. This feedback supports rapid model prototyping and innovative exploration of models \nbetter than possible with today s code\u00adgeneration approaches. We use rapid user feedback as the motivation \nfor choosing an interpreted approach over a code-generation approach. However, other advantages of the \nUML virtual machine approach weigh in as well. Most notably, using a seamless architecture avoids the \nimpedance mismatch and intellectual burden that a hybrid (code\u00adgeneration-based) system imposes on a \nuser. Also, it is signifi\u00adcantly easier to develop a high-availability system, because the reflective \narchitecture and the availability of explicit models ease system evolution. We have documented this and \nother business drivers behind our approach in [27]. We see several areas for further research: the execution \nspeed of the virtual machine, better precise behavior modeling, the defini\u00adtion and integration of modeling \nlanguage extensions to integrate otherwise unrelated domain models in a coherent system, and model evolution \nsupport. Our experience indicates that all of these areas are important and must be addressed, contributing \nsignifi\u00adcantly to the usefulness of the virtual machine approach. We have found many shortcomings in \nthe UML specification that limit its usefulness. However, these shortcomings are being rec\u00adognized. Future \nspecifications of UML and related technologies will provide a basis on top of which UML virtual machines \ncan be standardized. Then models will become exchangeable between virtual machines and lead to the same \nsystem behavior. ACKNOWLEDGEMENTS We would like to thank Thomas Gross, Christian Nester, Philipp Oser, \nJohan Ovlinger, Alan Perry, Wolf Siberski, and Hans Wegener for feedback that helped us improve the paper \nfor sub\u00admission. We would also like to thank the anonymous reviewers and the UIUC Software Architecture \nReading group for providing us with further feedback to improve the final version. REFERENCES [1] Ken \nArnold and James Gosling. The Java Programming Language. Addison-Wesley, 1996. [2] Daniel G. Bobrow, \nLinda G. DeMichiel, Richard P. Gabriel, Sonya E. Keene, Gregor Kiczales, and David A. Moon. Common Lisp \nObject System Specification. SIGPLAN Notices, 23 (Special Issue), September 1988. [3] Donald G. Firesmith, \nBrian Henderson-Sellers, Ian Gra\u00adham, and Meilir Page-Jones. Open Modeling Language Reference Manual. \nSIGS Publications, 1998. [4] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns: \nElements of Reusable Object-Oriented Software. Addison-Wesley, 1995. [5] Gregor Kiczales, Jim D. Rivieres, \nand Daniel G. Bobrow. The Art of the Metaobject Protocol. MIT Press, 1991. [6] Adele Goldberg and David \nRobson. Smalltalk: The Lan\u00adguage and Its Implementation. Addison-Wesley, 1983. [7] Adele Goldberg and \nDavid Robson. Smalltalk: The Lan\u00adguage. Addison-Wesley, 1989. [8] William Harrison, Charles M. Barton, \nand Mukund Raghavachari. Mapping UML to Java. In Proceedings of Ob\u00adject-Oriented Programming Languages, \nSystems, and Applica\u00adtions (OOPSLA 2000). ACM Press, 2000. [9] Urs H\u00f6lzle. Adaptive optimization for \nSelf: Reconciling High Performance with Exploratory Programming. Ph.D. Thesis STAN-CS-TR-94-1520. Stanford \nUniversity, 1994. [10] Akinori Yonezawa and Brian C. Smith (editors). Proceed\u00adings of the International \nWorkshop on New Models for Software Architecture 92: Reflection and Metalevel Architecture (IMSA 92). \nJapan: November 4-7, 1992. [11] Kennedy Carter. I-OOA Modelling Tool Technical Over\u00adview. Kennedy Carter, \n2000. Available from www.kc.com. [12] Zsolt Kovacs. The Integration of Product Data with Work Flow Management \nSystems through a Common Data Model. Ph.D. Thesis. University of the West of England, 1999. [13] Tim \nLindholm and Frank Yellin. The Java Virtual Ma\u00adchine Specification, Second Edition. Addison-Wesley, 1998. \n[14] Patti Maes and Daniele Nardi. Meta-Level Architectures and Reflection. Elsevier Science Publishers, \n1988. [15] Dragos-Anton Manolescu. Micro-Workflow: a Workflow Architecture Supporting Compositional Object-Oriented \nSoftware Development. Ph.D. Thesis. University of Illinois at Urbana-Champaign, 2001. [16] Klaus Marquardt. \nPatterns for Software Packaging, In\u00adstallation and Activation. In Proceedings of the 3rd European Conference \non Pattern Languages of Programming and Comput\u00ading (EuroPLoP 1998). Universit\u00e4tsverlag Konstanz, 1998. \n[17] OMG. Metaobject Facility Specification 1.3. OMG Document 99-06-05. OMG, 2000. Available from www.omg.org. \n[18] OMG. Action Semantics for the UML RFP. OMG Docu\u00adment 98-11-01. OMG, 1998. Available from www.omg.org. \n[19] OMG. OMG XML Metadata Interchange (XMI) Specifica\u00adtion. OMG, 2000. Available from www.omg.org. [20] \nOMG. OMG Unified Modeling Language Specification. Version 1.3. OMG, 2000. Available from www.omg.org. \n[21] Andreas Paepcke (editor). Object-Oriented Programming: the CLOS Perspective. MIT Press, 1993. [22] \nProject Technology. BridgePoint Tutorial. Project Tech\u00adnology, 2000. Available from www.projtech.com. \n[23] Gregor Kiczales (editor). Proceedings of Reflection 1996. Xerox Parc, 1996. [24] Dirk Riehle. The \nJValue Value Object Framework, Ver\u00adsion 0.5.1. Available from www.jvalue.org. [25] Dirk Riehle. Framework \nDesign: a Role Modeling Ap\u00adproach. Ph.D. Thesis, No. 13509. ETH Z\u00fcrich, 2000. Available from www.riehle.org/diss. \n[26] Dirk Riehle, Michel Tilman, and Ralph Johnson. Dy\u00adnamic Object Model. In Proceedings of the 2000 \nConference on Pattern Languages of Programs (PLoP 2000). Washington University Technical Report Number \nWUCS-00-29. [27] Dirk Riehle and Erica Dubach. Why a Bank Needs Dy\u00adnamic Object Models. Position Paper \nfor OOPSLA 98, Work\u00adshop 15. Available from www.riehle.org. [28] Dirk Riehle and Thomas Gross. Role Model \nBased Framework Design and Integration. Dirk Riehle and Thomas Gross. In Proceedings of the 1998 Conference \non Object-Oriented Programming Systems, Languages and Applications (OOPSLA 98). ACM Press, 1998. Page \n117-133. [29] Sally Shlaer and Neil Lang. Shlaer-Mellor Method: The OOA96 Report. Project Technology, \n1996. Available from www.projtech.com. [30] Michel Tilman and Martine Devos. A Reflective and Repository-Based \nFramework. In Implementing Application Frameworks. Wiley, 1999. Page 29-64. [31] David Ungar and Randall \nB. Smith. Self: The Power of Simplicity. In Proceedings of Object-Oriented Programming Languages, Systems, \nand Applications (OOPSLA 87). ACM Press, 1987. [32] Joseph Yoder, Brian Foote, Dirk Riehle, and Michel \nTilman. MetaData and Active Object Models. In Addendum to the Proceedings of the 1998 Conference on Object-Oriented \nPro\u00adgramming, Systems, Languages, and Applications (OOPSLA 98). ACM Press, 1998. [33] Chris Zimmermann \n(editor). Advances in Object-Oriented Metalevel Architectures and Reflection. CRC Press, 1996. [34] Brian \nFoote. Objects, Reflection, and Open Languages. Workshop on Object-Oriented Reflection and Metalevel \nArchitec\u00adtures (ECOOP 92). Available from www.laputan.org.  \n\t\t\t", "proc_id": "504282", "abstract": "Current software development tools let developers model a software system and generate program code from the models to run the system. However, generating code and installing a non-trivial system induces a time delay between changing the model and executing it that makes rapid model prototyping awkard if not impossible. This paper presents the architecture of a virtual machine for UML that interprets UML models without any intermediate code-generation step. The paper shows how to embed UML in a metalevel architecture so that a key property of model-based systems, the casual connection between models and model instances, is guaranteed. With this architecture, changes to a model have immediate effects on its execution, providing users with rapid feedback about the model's structure and behavior. This approach supports model innovation better than today's code-generation approaches.", "authors": [{"name": "Dirk Riehle", "author_profile_id": "81339524672", "affiliation": "SKYVA International, One Cabot Road, Medford, MA, U.S.A.", "person_id": "PP43136343", "email_address": "", "orcid_id": ""}, {"name": "Steven Fraleigh", "author_profile_id": "81100607207", "affiliation": "SKYVA International, One Cabot Road, Medford, MA, U.S.A.", "person_id": "P269844", "email_address": "", "orcid_id": ""}, {"name": "Dirk Bucka-Lassen", "author_profile_id": "81100115732", "affiliation": "Object Oriented, Ltd., Kramgasse 5, 6004 Luzern, Switzerland", "person_id": "P67452", "email_address": "", "orcid_id": ""}, {"name": "Nosa Omorogbe", "author_profile_id": "81100307381", "affiliation": "SKYVA International, One Cabot Road, Medford, MA, U.S.A.", "person_id": "P344306", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/504282.504306", "year": "2001", "article_id": "504306", "conference": "OOPSLA", "title": "The architecture of a UML virtual machine", "url": "http://dl.acm.org/citation.cfm?id=504306"}