{"article_publication_date": "10-01-2001", "fulltext": "\n Jiazzi: New-Age Components for Old-Fashioned Java Sean McDirmid, Matthew Flatt, Wilson C. Hsieh School \nof Computing University of Utah .mcdirmid,m.att,wilson.@cs.utah.edu ABSTRACT We present Jiazzi, a system \nthat enables the construction of large\u00adscale binary components in Java. Jiazzi components can be thought \nof as generalizations of Java packages with added support for exter\u00adnal linking and separate compilation. \nJiazzi components are practi\u00adcal because they are constructed out of standard Java source code. Jiazzi \nrequires neither extensions to the Java language nor special conventions for writing Java source code \nthat will go inside a com\u00adponent. Our components are expressive because Jiazzi supports cyclic component \nlinking and mixins, which are used together in an open class pattern that enables the modular addition \nof new fea\u00adtures to existing classes. This paper describes Jiazzi, how it en\u00adhances Java with components, \nits implementation, and how type checking works. An implementation of Jiazzi is available for down\u00adload. \n1. INTRODUCTION Current Java constructs for code reuse, including classes, are in\u00adsuf.cient for organizing \nprograms in terms of reusable software components [26]. Although packages, class loaders, and various \ndesign patterns [11] can implement forms of components in ad hoc manners, the lack of an explicit language \nconstruct for components places a substantial burden on programmers, and obscures a pro\u00adgrammer s intent \nto the compiler or to other programmers. As object-oriented software systems increase in size and complexity, \ncomponents are becoming central to the design process, and they deserve close integration with the language. \nComponents should support separate compilation, which enables development of large programs and deployment \nof components in binary form, and external linking, which eliminates hard-coded de\u00adpendencies to make \ncomponents as .exible as possible for client programmers [7]. In addition, components integrated into \na class\u00adbased language, such as Java, should also .t well with the class system: Permission to make digital \nor hard copies of part or all of this work or personal or classroom use is granted without fee provided \nthat copies are not made or distributed for profit or commercial advantage and that copies bear this \nnotice and the full citation on the first page. To copy otherwise, to republish, to post on servers, \nor to redistribute to lists, requires prior specific permission and/or a fee. OOPSLA 01 Tampa Florida \nUSA Copyright ACM 2001 1-58113-335-9/01/10 $5.00 Figure 1: Jiazzi components are constructed from Java \nclasses and other components, and can be loaded in Java Virtual Machines for execution. -Components should \nimport classes that can be both instanti\u00adated and subclassed within the component. Inheritance across \ncomponent boundaries is necessary for grouping classes and class extensions into reusable components. \n-Components should accept imported classes that supply more methods than the component requires or expects. \nRequiring an exact match on methods of an imported class would pro\u00adhibit the composition of class-extending \ncomponents; e.g., mixins [4]. -Cyclic component linking should be allowed to resolve mu\u00adtually recursive \ndependencies among components. Mutually recursive has a relationships are especially common at the class \nlevel, and naturally span component boundaries. Jiazzi is our new component system for Java based on \nprogram units [10]. Jiazzi provides the .rst combination of components and classes that supports all \nof the above features. Figure 1 illustrates at a high level how Jiazzi works: a Jiazzi component can \nbe built from Java classes and other Jiazzi components. The resulting component can execute directly \non a Java Virtual Machine. Jiazzi makes two contributions to component programming in Java that also \napply to other statically typed, object-oriented languages. First, no special core language extensions \nor conventions need to be used in the Java code used to construct a component. Instead, Jiazzi integrates \nwith Java using a stub generator and an external linker. Because subclassing across component boundaries \nand cyclic com\u00adponent linking is supported, component boundaries can be placed in the design naturally. \nThis also allows easy retro.tting of legacy Java code into component-based designs. Second, Jiazzi can \nsupport the addition of features to classes with\u00adout editing their source code or breaking existing class \nvariant re\u00adlationships. Such functionality is already provided by languages that support open classes \n[6]. A combination of mixins and cyclic component linking is used to simulate open classes with what \nwe call the open class pattern. Using the open class pattern in Jiazzi provides a solution to the extensibility \nproblem [7], which arises from the tension between adding features to and creating variants of a class. \nWith the open class pattern, we can replace the use of many design patterns used to implement modular \nfeature addition, such as abstract factories and bridges, with a combination of exter\u00adnal linking and \nJava s in-language constructs for subclassing and instantiation. Section 2 gives an overview of Jiazzi \ncomponents and shows how they can be used in program designs. Section 3 describes how Ji\u00adazzi can be \nused to modularly add features to classes with mixins and the open class pattern. Section 4 explains \nhow type checking in the presence of separate compilation works in Jiazzi. Section 5 de\u00adscribes our implementation \nof Jiazzi and the interactions between Java and Jiazzi. Section 6 discusses related work. Section 7 dis\u00adcusses \nfuture work, and summarizes our conclusions.  2. OVERVIEW Components in Jiazzi are constructed as units \n[10]. A unit is con\u00adceptually a container of compiled Java code with support for typed connections. There \nare two types of units: atoms, which are built from Java classes (including Java interfaces), and compounds, \nwhich are built from atoms and other compounds. Units import and export Java classes. Classes imported \ninto a unit are exported from other units; classes exported from a unit can be imported into other units. \nLinking speci.ed by compounds deter\u00admines how connections are made between exported and imported classes. \nGroups of classes are connected together when units are linked; we call these groups of classes packages \nto emphasize their similarity to packages in standard Java. Using package-grained connections reduces \nthe quantity of explicit connections between units, which allows the component system to scale to larger \nde\u00adsigns. Jiazzi includes a component language that provides a convenient way for programmers to build \nand reason about units. Using this language, the structure of classes in a unit s imported and exported \npackages can be described using package signatures. Because pack\u00adages can be used in multiple unit descriptions, \nthey enhance the component language s scaling properties. We introduce Jiazzi using a simple example \nthat composes a user interface (UI) library with an application into a complete program. Because they \nare used to describe units, we will .rst describe pack\u00adage signatures. 2.1 Package Signatures Package \nsignatures are constructs that are used to describe the visi\u00adble structure of classes in a Java package. \nIn Figure 2, the package signature ui sdescribes a UI library with classes Widget, But\u00adton, and Window; \nthe package signature applet s describes an application with class Program. In the package signature \nthe structure of a class is described using a class signature. The class signature of Windowin ui sspeci.es \nthat the class has the super\u00ad  .le: ./ui s.sig signature ui s<ui p> . class Widget extends Object \n.void paint(); . class Button extends ui p.Widget .void setLabel(String); . class Window extends ui \np.Widget .void add(ui p.Widget); void show(); . . .le: ./applet s.sig signature applet s<ui p> . class \nProgram extends ui p.Window .void run(); . . Figure 2: Package signatures ui s, which describes a user \ninter\u00adface library, and applet s, which describes an application; as conventions in this example, package \nsignature names end with s, and package parameters end with p. .le: ./applet.unit atom applet . import \nui in : ui s<ui in>; export applet out : applet s<ui in>; . Figure 3: An atom appletthat imports a \nuser interface library and exports an application; as conventions in this example, the names of imported \npackages end with in, and the names exported packages end with out. class ui p.Widgetand has the public \nmethods addand show.In our example, only the methods and superclasses of classes are de\u00adscribed, but \nclass signatures can also describe interface subtyping and class members such as .elds, constructors, \nand inner classes. Class signatures can also describe Java interfaces as well as class and member modi.ers \n(e.g., protected, abstract). Class signatures are parameterized by the enclosing package sig\u00adnature s \npackage parameters, which must be bound to packages when the package signature is used. The only package \nparameter of ui s is ui p. We assume Object and String are built-in for the purposes of this example, \nwhich also re.ects the close cou\u00adpling of these classes to the Java Virtual Machine (see Section 5 for \nmore details). Classes other than Object and String must be referred to through one of the package signature \ns package pa\u00adrameters. In ui s, the direct superclass of Windowis speci.ed as ui p.Widget, which only \ncomes from the same package as Win\u00addowif ui pis bound to the same package that provides Window. Allowing \na package to implicitly reference itself would limit the package signature s use; using the open class \npattern in Section 3 depends on the .exibility of package signatures that do not implic\u00aditly use self-reference. \n  2.2 Atoms The atom applet shown in Figure 3 imports Java classes in the package ui in that implement \na user interface library described by package signature ui s, and exports classes in a package ap\u00adplet \nout that implement an applet described by package signa\u00adture applet s. Within a unit, the package parameters \nin the pack\u00adage signatures used to describe each imported and exported pack\u00adage must be bound only to \nthe unit s imported and exported pack\u00ad                 .le: ./applet/applet out/Program.java \npackage applet out; public class Program extends ui in.Window . ui in.Button b = new ui in.Button(); \npublic Program() . b.setLabel(\"start\"); add(b); . public void run() .show(); . . Figure 4: The Java \nsource implementation of applet out.-Programin atom applet.     Jiazzi stub generator Java compiler \n  Jiazzi unit linker  Figure 5: The .les and development process of building applet; .les with source \nshown in other .gures are in the dashed rectangle, tools are in rectangles, .les are in rounded rectangles, \narchive .les are shaded rounded rectangles. ages. Therefore, class signatures of imported and exported \nclasses only refer to the unit s imported and exported classes. For example, after package signature \napplet s is used in applet, the super\u00adclass of applet out.Program is ui in.Window because the package \nparameter ui pis bound to ui in. A unit s declarations of imported and exported packages constitutes \nits unit signature. Class signatures provided by the unit signature are necessary to implement separate \ntype checking in Jiazzi. Inside a unit, the implementation of the unit s imported classes are not visible; \noutside the unit, the implementation of the unit s exported classes are not visible. We explain separate \ntype checking in more detail in Section 4. Atoms are built from Java classes that can be compiled from \nnor\u00admal Java source code. Shown in Figure 4 is the Java source for ap\u00adplet s exported class applet out.Program. \nThe Java source can instantiate and subclass imported classes. For example in the implementation of applet \nout.Program, the class ui in.Window can be subclassed and the class ui in.Button can be instan\u00adtiated. \nJava source can only refer to imported classes, exported classes, or private classes contained in the \natom. Figure 5 shows how the atom appletis developed in our imple\u00admentation of Jiazzi. Files provided \nby the developer, unit de.ni\u00adtions, package signatures, and Java source, are located in separate source \n.les. Since the implementation of imported classes are un\u00adavailable, standard Java source compilers (e.g., \njavac or jikes) can\u00adnot automatically know about the structure of imported classes. For this reason, \nour implementation provides a stub generator that uses the class signatures of imported classes to generate \nstub class .les. In our example, stub class .les are generated for the imported user interface classes \nin package ui in. These class .les are then used to compile Program.javainto Program.classusing a stan\u00ad \n      .le: ./ui.unit atom ui . export ui out : ui s<ui out>; . .le: ./linkui.unit compound linkui \n. export ui out : ui s<ui out>, applet out : applet s<ui out>; .. local u : ui, a : applet; link u@ui \nout to a@ui in, u@ui out to ui out, a@applet out to applet out; . Figure 6: An atom ui that exports \na user interface library, a com\u00adpound linkuithat links atoms uiand applettogether. dard Java source compiler. \nAfter Java source compilation, the Jiazzi component linker per\u00adforms type checking to ensure that the \natom s compiled Java code conforms to its unit signature. The class .les for classes contained in the \natom are placed into a Java archive (JAR) .le, which is the atom s binary form. For example, Program.class \nis placed into the atom applet s binary form, applet.jar. The atom s unit signature is also placed into \nthe JAR .le as component meta data. More information about developing with Jiazzi can be found in the \nuser manual [1].  2.3 Compounds The atom ui in Figure 6 exports a package of classes that im\u00adplement \nthe user interface library described by package signature ui sfrom Figure 2. The compound linkuiin Figure \n6 links this atom to the atom applet from Figure 3. The unit signature of a compound has the same form \nas that of an atom; linkuiexports packages described by the package signatures from Figure 2. Fol\u00adlowing \nits unit signature is the compound s link section. In the link section, the Java classes contained in \nunits are conceptually copied by instantiating the units into unit instances using the local state\u00adment. \nIn linkui, the atoms applet and ui are respectively instantiated into the unit instances aand u. The \nlink statement makes connections from source packages on the left to sink packages on the right of each \nto clause. A source package is either an imported package of the compound or an ex\u00adported package of \none of the compound s unit instances. A sink package is either an imported package of one of the compound \ns unit instances or an exported package of the compound. We write v@pas the notation for the imported \nor exported package pof unit instance v. In the compound linkui, the exported package u@ui out is connected \nto the imported package a@ui in. The meaning of this connection is that all references to classes in \nthe package ui in are replaced with references to classes in u@ui out in the unit instance a using name \nequivalence of the unquali.ed class name. For example, references to ui in.Widget inside the implemen\u00adtation \nof classes in unit instance a are replaced with references to Widget.ui outin u.           \n  Figure 7: A graphical illustration of the connections made by linkui. An exported package of a unit \ninstance is available outside of the linking compound if it is connected to one of the compound sex\u00adported \npackages. Encapsulation at the component level is hierar\u00adchical; linking compounds are only aware of \nthe compound s unit signature, and are unaware of the units that initially provided the exported packages. \nIn linkui, the exported package u@ui out is connected to the package ui out that is exported by the com\u00adpound. \nCompounds that instantiate linkuican use this exported package, but will not know that these classes \nare initially exported by the atom ui. An illustration of linkui s linking is shown in Figure 7. Unit \nin\u00adstances and the enclosing compound are represented as alternately shaded rounded rectangles. Packages \nare represented as boxes that are black tabbed on the left and rounded on the right. Imported packages \ncome into a unit from the left, while exported packages leave the unit from the right. Connections are \nrepresented as lines from the right rounded part of a package to the left black tabs of other packages. \nThe same unit can be used to create multiple unit instances, each of which can be used in different contexts. \nThe imports of each unit instance can be connected differently, and each unit instance exports a distinct \ngroup of classes. There is no restriction on the number of unit instances, within a single compound or \ncomplete program, that can be created using the same unit. Informally, a compound can be reduced to an \natom by: 1. Copying the (reduced) bodies of all units used to create a unit instances; 2. Concatenating \nall of the copied bodies, and renaming class references according to the mapping speci.ed by the link \nsection; this rewriting is analogous to the way that a linker .nds and updates offsets at link time. \n The result can itself be used to create unit instances that undergo further linking within larger compounds. \nOf course, there is no guarantee that the concatenated bodies are well-formed unless some form of checking \nhas been applied to units during linking. We ex\u00adplain these rules in Section 4. The development of linkui \nis shown in Figure 8. Both atoms applet and ui must be linked into their binary forms before linkui can \nbe linked. The Jiazzi component linker performs type checking and copies the class .les from each atom, \nwhich are rewritten according to how connections are made in the compound. In our example, the linker \ncreates the JAR .le linkui.jar, which is linkui s binary form. The class .le Program.class is copied \nfrom applet.jarinto linkui.jar. Since u@ui out is connected to a@ui in, Program.class s references of \nim\u00adported classes in the package ui in are changed in the copy to Figure 8: The .les and development \nprocess of building and exe\u00adcuting linkui.    .le: ./color s.sig signature color s<orig p> . class \nWidget extends orig p.Widget .void setColor(int); . class Button extends orig p.Button .. class Window \nextends orig p.Window .. . .le: ./font s.sig signature font s<orig p> . class Widget extends orig p.Widget \n.void setFont(int); . class Button extends orig p.Button .. class Window extends orig p.Window .. . \n.le: ./both s.sig signature both s<orig p> . class Widget extends orig p.Widget .void setColor(int); \nvoid setFont(int); . class Button extends orig p.Button .. class Window extends orig p.Window .. . .le: \n./nop s.sig signature nop s<orig p> . class Widget extends orig p.Widget .. class Button extends orig \np.Button .. class Window extends orig p.Window .. . Figure 9: Package signatures color s, font s, and \nboth s that describe packages which respectively add color, font, and both color and font features to \nthe package parameter orig p, and nop s, which is an empty extension of orig p. be references of the \nexported classes in u@ui out, which are also copied into linkui.jar. The format of a compound s binary \nform is the same as an atom s binary form; after linking there is no distinction between atoms and compounds. \nSince the compound linkui has no imports, its classes can safely be executed in a Java Virtual Machine \nby placing linkui.jarin the classpath.                  3. FEATURE EXTENSIBILITY In \naddition to decomposing a design into many classes, it is also useful to decompose a design into multiple \nfeatures [21]. Features cross cut class boundaries and bene.t from being implemented in separate components \n[13]. To demonstrate Jiazzi s expressiveness, .le: ./mix.color.unit atom mix.color . import ui init : \nui s<ui init>, ui in : nop s<ui init>; export ui out : color s<ui in>; . .le: ./mix.font.unit atom mix.font \n. import ui init : ui s<ui init>, ui in : nop s<ui init>; export ui out : font s<ui in>; . .le: ./mix.both.unit \ncompound mix.both . import ui init : ui s<ui init>, ui in : nop s<ui init>; export ui out : both s<ui \nin>; .. local c : mix.color, f : mix.font; link ui init to c@ui init, ui init to f@ui init, ui in to \nc@ui in, c@ui out to f@ui in, f@ui out to ui out; . Figure 10: Units mix.color, mix.font, and mix.both, \nwhich use mixin constructions to add color, fonts, and both color and fonts to a package of UI library \nclasses. we show how Jiazzi can be used to decompose class library features into multiple components. \nWe continue with our example of a UI library by adding the color and font feature to the UI library using \nthe package signatures in Figure 9. We present two approaches: the pure mixin approach, which utilizes \nmixins to add features to classes, and the open class pattern, which is an improvement of the pure mixin \napproach that uses cyclic linking to solve the extensi\u00adbility problem. 3.1 Mixins Units are powerful \nenough to express a kind of mixin [4], where an exported class subclasses an imported class. Such an \nexported class will have all methods present in the actual class connected to the imported superclass: \nif a method mis visible in a class imported into a unit, then outside of the unit mis visible in any \nexported class that subclasses the imported class, even if m is not visible in the imported class s signature \nwithin the unit. To use mixins in feature addition, suppose we are writing a unit that adds a feature \nto a single package of classes. The unit must import an initial construction of the classes before any \nfeatures are added, which we call the init-package. The init-package estab\u00adlishes variant relationships \nand provides initial functionality. The unit also imports the previous construction of the classes that \nare the result of the last feature added, which we call the in-package. The in-package is an extended \nversion of the init-package. The unit exports an out-package, which is the extended version of the in-package: \neach class in the out-package subclasses a class in the in-package with the same unquali.ed name, forming \na series of mixins. The features added by the unit are added to classes in the out-package. Figure 10 \nuses mixins in the atom mix.color to add the color feature to a package of classes that implement a UI \nlibrary. The imported packages ui inand ui initand the exported package ui outare a UI library s in-, \ninit-, and out-packages, respectively. The package signature ui                   \n sfrom Figure 2 describe the UI library s initial structure. The package signature nop s is used to \ndescribe the imported package ui inas an extension of ui initwithout any new methods. The package signature \ncolor sfrom Figure 9 adds the new method setColorto class Widgetand establishes normal mixin relationships \nbetween classes in ui outand ui in. The atom mix.font in Figure 10 adds the font feature to a UI library \nin the same way that the atom mix.color adds the color feature. The compound mix.bothcomposes both mix.color \nand mix.fonttogether to create a unit that adds both the font and color features (using package signature \nboth s from Figure 9) to a UI library. Inside mix.both, the method setColor is visi\u00adble in the class \nui out.Widget exported from the unit instance f because it is a subclass of ui out.Widget exported from \nthe unit instance c. This allows both methods setColorand set-Font to be visible in the class ui out.Widget \nexported from mix.both. The linking is illustrated in Figure 11. Mixins in Jiazzi enable reuse of class \nimplementations only; they do not provide a common type to describe the functionality they add, unlike \nlanguage-level mixin proposals such as the Java lan\u00adguage extension JAM [2]. Jiazzi mixins address a \ndifferent design space: they are link-time abstractions that enable transparent class inheritance across \ncomponent boundaries, as opposed to abstrac\u00adtions in the core language that enable .ne-grained mixin-oriented \nprogramming.        .le: ./open.color.unit atom open.color . import ui in : ui s<ui fixed>, ui \nfixed : nop s<ui out>; export ui out : color s<ui in>; . Figure 13: An atom open.colorthat uses the open \nclass pattern to add color feature to a UI library. Using the pure mixin approach to add features to \nclasses is prob\u00adlematic as we can see in Figure 12, which shows the subclassing re\u00adlationship of Widgetand \nButtoninside open.color(the sub\u00adclassing relationships of Windoware similar to Button s). Sub\u00adclassing \nis used to make the class Buttona variant of Widgetby having ui init.Buttonsubclass ui init.Widget. The \nfea\u00adture of color is added to Widget in the class ui out.Widget. Using mixins fails, however, because \nwe cannot combine classes ui out.Buttonand ui out.Widgetto create color buttons. The problem that occurs \nwhen trying to add features (a.k.a. ver\u00adtical class extension) and create variants (a.k.a. horizontal \nclass extension) is known as the extensibility problem [7]. We can solve this problem by using an approach \nthat utilizes cyclic component linking as well as mixins. 3.2 Open Class Pattern A general solution to \nthe extensibility problem must not only allow the modular addition of new features to existing classes; \nit must also ensure that added features are visible in all variants of the up\u00addated class. For example, \nthe new method setColor added to Widget must be visible in instances of Widget s variant But\u00adton. Open \nclasses in MultiJava [6] satis.es this requirement when features are new methods. Jiazzi does not directly \nsupport open classes, but the open class pattern utilizes Jiazzi s expressive link\u00ading facilities to \nsimulate open classes. The open class pattern utilizes mixins and upside-down mixins, which behave the \nsame as normal mixins, just from a different per\u00adspective: imported classes subclass exported ones. Method \nvisibil\u00adity is the reverse as that for mixins: if a method m is visible in a class exported from a unit, \nthen inside of the unit m is visible in any imported class that subclasses the exported class, even if \nm is not visible in the exported class s signature outside the unit. Us\u00ading upside-down mixins necessarily \nrequires cyclic component linking. To apply the open class pattern, suppose we are writing a unit that \nadds a feature to a single package of classes. Like the pure mixin approach, the unit must import an \nin-package and export an out\u00adpackage. The new feature is still implemented in the out package s classes, \nwhich is the extended version of the in-package (forming normal mixins). The key to the open class pattern \nis that instead of importing an initial-package, the unit instead imports a .xed\u00adpackage, which is the \nresult of all features applied to the package of classes. The .xed-package is the extended version of \nthe out\u00adpackage (forming the upside-down mixins). Figure 13 uses the open class pattern in the atom open.colorto \nadd the color feature to classes in a UI library. The imported pack\u00adages ui inand ui fixedand the exported \npackage ui outare the UI library s in-, .xed-, and out-packages, respectively. The          \n.le: ./open.color/ui out/Widget.java package ui out; public class Widget extends ui in.Widget . private \nint clr; public void setColor(int c) . clr= c; . protected int getColor() . return clr; . . .le: ./open.color/ui \nout/Button.java package ui out; public class Button extends ui in.Button . public void paint() . ... \n= this.getColor() ...; super.paint(); . . Figure 15: The Java source implementations of ui out.Widget \nand ui out.Buttonin color. package signature ui sfrom Figure 2 is used to describe the struc\u00adture of \nui in. The package signature nop s from Figure 9 is used to establish the upside-down mixin relationship \nbetween ui fixed and ui out. As with the pure mixin approach, the new method setColoris added to the \nclass Widgetin ui out. Figure 14 shows the subclassing relationship of Widgetand But\u00adtoninside open.color \n(again, the subclassing relationships of Window s is like that of Button). Only classes in the .xed\u00adpackage \nshould be instantiated or subclassed to create variants. For example, ui fixed.Widget, not only ui in.Widget,isasu\u00adperclass \nof ui in.Buttonsince Buttonis a variant of Widget. As can be seen in the .gure, the class ui out.Widget, \nwhich adds the new method setColor, is inserted as a superclass of ui fixed.Widget, which establishes \nthe upside-down mixin relationship. Shown in Figure 15 is the Java source for classes Widget and Button \nin package ui out. The method getColor is hidden outside of the atom open.color by ui out.Widget s class \n           .le: ./open.font.unit atom open.font . import ui in : ui s<ui fixed>, ui fixed : \nnop s<ui out>; export ui out : font s<ui in>; . .le: ./open.both.unit compound open.both . import ui \nin : ui s<ui fixed>, ui fixed : nop s<ui out>; export ui out : both s<ui in>; .. local c : open.color, \nf : open.font; link ui fixed to c@ui fixed, ui fixed to f@ui fixed, ui in to c@ui in, c@ui out to \nf@ui in, f@ui out to ui out; . Figure 16: An atom open.fontthat uses the open class pattern to add the \nfont feature to a UI library, and a compound open.both that adds both the color and font feature to a \nUI library . signature. Because of ui fixed.Widget s upside-down mixin relationship with ui out.Widget, \ninside open.color s imple\u00admentation the method getColor is visible in ui out.Button, as shown in the \nJava source for ui out.Button. Figure 16 shows how multiple feature-adding components can be combined \ninto one feature-adding component using a compound. The atom open.fontuses the open class pattern to \nadd the font feature to a UI library. The compound open.both instantiates both open.color and open.font \nand applies the resulting unit instances to its in-package import of the UI library. The com\u00adpound open.bothitself \nuses the open class pattern so that it ap\u00adpears to directly add both the color and font features to a \nUI library. Figure 17 shows how the open class pattern can be used end-to\u00adend to create a UI library. \nThe compound open.fixed uses the atom open.init and compound open.both to create a feature-complete UI \nlibrary. The atom open.init provides the initial implementation of the UI library, so it does not need \nto im\u00adport an in-package. Inside open.fixed, the features of the UI library are .xed by taking the out-package \nof unit instance band connecting it to the .xed-package imports of both unit instances i and b. Figure \n18 illustrates the linking done in both the compounds open.fixedand open.both. No more features can be \nadded to open.fixed using the open class pattern. The compound s exported package ui fixed ap\u00adpears outside \nof the compound to be a UI library that provides the color and font features. All intermediate classes, \nthose not exported from open.fixed, are hidden from clients of the UI library. As a result, clients of \nopen.fixedare isolated from the fact that the UI library was built using the open class pattern. Figure \n19 shows the global class inheritance hierarchy established by the compound open.fixed. Classes in independently \ndevel\u00adoped units can exist between each other in the class inheritance hierarchy! A color Buttonis both \na subclass of the original But\u00adton and a subclass of a color Widget, which solves the extensi\u00adbility \nproblem in Figure 12.                 .le: ./open.init.unit atom open.init . import \nui fixed : nop s<ui out>; export ui out : ui s<ui fixed>; . .le: ./.xed s.sig signature fixed s<ui p> \n. class Widget extends Object .void setFont(int); void setColor(int); void paint(); . class Button extends \nui p.Button .void setLabel(String); . class Window extends ui p.Window .void add(ui p.Widget); void show(); \n. . .le: ./open..xed.unit compound open.fixed . export ui fixed : fixed s<ui fixed>; .. local i : open.init, \nb : open.both; link i@ui out to b@ui in, b@ui out to i@ui fixed, b@ui out to b@ui fixed, b@ui out to \nui fixed; . Figure 17: A compound open.fixed that .xes the features of a UI framework.       \n      When combined with cyclic component linking, mixins have a non\u00adtrivial effect on type checking. \nInheritance cycles could be intro\u00adduced into the class hierarchy or method collisions could occur when \ntwo ambiguous methods exist in the same scope. As we show in Section 4, separate type checking in Jiazzi \ncan disallow these constructions. The open class pattern is not unique to Jiazzi; it can also be useful \nas a convention in Java code outside of Jiazzi components when separate compilation, and especially separate \ntype checking, is not important and source code is open to modi.cation. However, Jiazzi makes the open \nclass pattern s use more realistic, and also enables con.guration of features with external linking. \nThe open class pat\u00adtern, but not Jiazzi itself, necessarily causes a shift in the program\u00adming model \nof Java code that uses it to add features. At present, we are adding better support for the open class \npattern in Jiazzi to minimize the effects of this shift.  4. TYPE CHECKING The Java classes used in \nthe construction of an atom are checked according to the Java Language Speci.cation [12]. Jiazzi uses \na conventional Java compiler to perform these checks; stubs are gen\u00aderated for imported classes to ensure \nthat they are used correctly in classes that the atom contains. A Jiazzi component linker then ensures \nthat the atom s classes are consistent with the atom s unit signature. For compounds, the linker must \nensure that the link\u00ading of units within a compound is consistent with the compound s unit signature \nand the unit signature of units used to create unit in\u00adstances in the compound. All of these checks are \nperformed by type checking connections. Type checking each connection requires the matching of classes \nin a source package with classes in a sink pack\u00adage. Classes contained in an atom are in potential source \npackages, while classes exported in an atom s unit signature are in sink packages. An atom s source packages \nare implicitly connected to the atom s sink packages by package name equivalence. Classes imported in \na compound s unit signature and exported in the unit signatures of a compound s unit instances are in \npotential source packages, while classes exported in a compound s unit signature and imported in the \nunit signature of a compound s unit instances are in sink pack\u00adages. A compound s source packages are \nexplicitly connected to sink packages; source packages are on the left and sink packages are on the right \nof to clauses in a compound s link statements. To compare the class signatures of sources and sinks, \nJiazzi ex\u00adpands package signatures by replacing each package signature s package parameters with the \nnames of the packages they are bound to. Expansion checks are made to ensure that a package parameter \nis bound to a package that provides all classes referred to through the package parameter. Package signatures \nhave no other purpose during type checking other than being expanded to generate unit signatures. The \nindirect properties of a class, such as subclasses, superclasses, and inherited methods, require that \nthe class exist in an environ\u00adment of other classes, over which references to classes in the signa\u00adtures \nof these classes are closed. Properties for source classes are extracted from the source environment \nof a connection, and prop\u00aderties for sink classes are extracted from the sink environment of a connection. \nThe source environment is the same for all connec\u00adtions in a unit, and is created using the union of \nthe class signatures for all classes in potential sources and the class signatures of the unit s imported \nclasses. For classes contained inside an atom, class signatures are extracted directly from their class \nde.nitions. The sink environment is created using the union of the class signatures for all classes imported \nand exported into the unit or unit instance where the sink package is located. Type checking thus amounts \nto source sink class matching in the context of a source environment and sink environment. Consider a \nconnection from packages source to sink inside a unit u.Ifa class Cis described in sink, then Cmust be \ndescribed in source, otherwise u is rejected. In addition, the following rules must hold for uto be well-typed: \nR1. If method m is introduced in sink.C, then m must either be introduced in or an inherited method of \nsource.Caccording to the source environment. R2. If p.Dis a subclass of sink.Cand a method mis introduced \nin p.D according to the sink environment, then m must not be introduced in nor be an inherited method \nof source.C according to the source environment. R3. If class p.D is the direct superclass of sink.C \naccording to the sink environment, then each direct and indirect superclass of source.Cis either the \nclass q.D(where qis connected to p), a superclass of q.Daccording to the source environment, or a class \nthat is not visible in the sink environment. The .rst rule is straightforward; Rule R1 ensures that method \nre\u00adquirements are met. A method provided to the sink class could be found in either the source class \nor one of its superclasses. Rule R2 rejects constructions that would cause method collisions. We have \nchosen an interpretation of method collision that disallows both silent overriding, where the signatures \nof colliding methods are the same, and ambiguous method calls, where the signatures of collid\u00ading methods \ndiffer only by return type. .le: .//icon/Icon.java package icon; public class Icon extends Object . public \nvoid paint() . ... draw(); ... . void draw() .... . . .le: .//cw/Cowboy.java package cw; public class \nCowboy extends icon.Icon . public void duel() . ... draw(); ... . int draw() .... . . Figure 20: Valid \nconventional Java source code that demonstrates Java s built-in package scoping. Rule R3 ensures that \nsuperclass relationships are consistent be\u00adtween connections and it also prevents some subclassing relation\u00adships \nfrom being hidden. A class is not visible in the sink envi\u00adronment if is not exported from or imported \ninto the unit that con\u00adtains the sink. The rule ensures that subclassing relationships that are true \nlocally within a unit are also true globally in correct unit compositions, while still allowing subclass \nrelationship hiding to accommodate class hiding. The open class pattern in Section 3 re\u00adlies on subclass \nrelationship hiding, since intermediate classes in an open class construction are hidden to units that \nonly import .xed classes. Rule R2 depends on method scoping, in that it only checks for method collisions \nusing methods visible in class signatures. We explain method scoping in more detail in Section 4.1. We \ndiscuss type checking in the presence of abstract methods in Section 4.2. 4.1 Method Scoping A method \ncollision occurs when two methods have con.icting types and are visible in the same class. Since not \neverything is visible in the source and sink environments used to check connections, then according to \nRule R2, two methods can collide only if they are visible in the same scope. This is important since, \nin order to re\u00adject method collisions modularly in the presence of mixins, method scope must be accounted \nfor. Without considering method scope, a method collision occurs in the conventional (non-Jiazzi) Java \ncode of Figure 20. Even though the method void draw()already exists in its superclass Icon, the class \nCowboyintroduces the method int draw(). However because of package scoping, this Java code is valid. \nBoth draw methods are visible only in the enclosing package, because both lack public or protected access \ndeclarations. Since each class is in a different package, the scopes of the methods do not overlap and \nno ambiguity occurs. This observation is similar to the one made by Riecke and Stone [22] and elaborated \non by Vouillon [28] with respect to class-based typing. This same protocol is implemented in Jiazzi for \nunit scopes. Rule R2 does not consider methods that are hidden in class signatures. A method that is \nnot mentioned in the class signature of an imported .le: ./cw e s.sig signature cw e s<icon p> . class \nCowboy extends icon p.Icon .void duel(); int draw(); . . .le: ./icon e s.sig signature icon e s<> . \nclass Icon extends Object .void paint(); void draw(); . . .le: ./cw s.sig signature cw s<icon p> . class \nCowboy extends icon p.Icon .void duel(); . . .le: ./icon s.sig signature icon s<> . class Icon extends \nObject .void paint(); . . .le: ./mix.cowboy.unit atom mix.cowboy . import icon in : icon s<>; export \ncw out : cw e s<icon in>; . .le: ./cowboy.wrong.unit compound cowboy.wrong . import icon in : icon e \ns<>; export cw out : cw s<icon in>; .. local cw : mix.cowboy ; link icon in to cw@icon in, cw@cw out \nto cw out; . Figure 21: cowboy.wrong creates a method collision. class is hidden from that unit; a method \nthat is not mentioned in the class signature of an exported class is hidden outside of the unit. This \nhiding establishes method scopes, and if two methods do not exist in overlapping scopes, they cannot \ncollide. In some cases, method scope can be explicitly used to eliminate ac\u00adcidental method collisions \nthrough wrapping units in compounds. In Figure 21, the atom mix.cowboy exports a class Cowboy with both \nmethods dueland draw. A unit instance created using mix.cowboy is connected in the compound cowboy.wrong. \nBecause the class Iconimported into the compound also contains the method draw, a method collision occurs \nand cowboy.wrong is rejected. Instead of rewriting the unit mix.cowboy to hide drawin Cow\u00adboy, a programmer \ncan wrap the compound hide.draw around mix.cowboy, as shown in Figure 22. hide.draw hides the method \ndrawfrom its public interface, which allows hide.draw to be used in cowboy.right. In some situations, \na programmer would like to expose a pair of colliding methods to clients (e.g., both draw methods may \nneed to be visible in Cowboy), and let the client programmer choose one. In Jiazzi, ambiguous methods \nthat cannot be resolved using scope during composition are always rejected as method collisions.   \n              .le: ./hide.draw.unit compound hide.draw . import icon in : icon s<>; export \ncw out : cw s<icon in>; .. local cw : mix.cowboy; link icon in to cw@icon in, cw@cw out to cw out; \n. .le: ./cowboy.right.unit compound cowboy.right . import icon in : icon e s<>; export run out : run \ns<>; .. local cw : hide.draw ; link icon in to cw@icon in, cw@cw out to cw out; . Figure 22: hide.draw \nhides an unwanted method allowing the composition of a valid cowboy.right. Moby [9], in contrast, allows \nambiguous methods to be exposed in the same scope, and leaves the complexity of resolution to the caller. \n 4.2 Abstract Methods In addition to instance methods and subclassing, other Java lan\u00adguage features \ncan be expressed in class signatures. Instance .elds, static methods, and static .elds are checked like \ninstance methods. Constructors must be matched directly in the source class, because they are not inherited. \nChecking of abstract methods, however, de\u00adserves extra discussion. Unlike concrete virtual methods, an \nabstract method within a class or interface cannot be hidden by a class signature. Otherwise, a non-abstract \nsubclass of the class described by the class signature could contain hidden abstract methods. This restriction \nis present in MultiJava s open classes for the same reason [6]. Because of the need to upgrade libraries, \nJava allows abstract meth\u00adods to be unimplemented in concrete classes [18]. Successive ver\u00adsions of Java \ncore libraries have added abstract methods to exist\u00ading classes (e.g., compare the initial and current \nversion of class java.awt.Graphics). In Java, an abstract method invoked with\u00adout an implementation will \nraise a runtime error. Jiazzi s require\u00adment that concrete classes have no abstract methods con.icts \nwith Java s binary compatibility support.  5. IMPLEMENTATION Our current implementation of Jiazzi consists \nof a stub generator and an of.ine linker that operates on class .les. The linker per\u00adforms unit-level \ntype checking, and it rewrites class .les to form the binary forms of units. The binary forms of units \ncan be used to create unit instances in a compound, or can be loaded into a Java Virtual Machine (JVM). \nOnly the class .le s constant pools, which contains its symbols, are rewritten by the linker: there is \nno need to parse and inspect the bytecode instructions in method bodies. Class .le features such as debug \nattributes, which are important for com\u00adpatibility with existing Java development tools, are preserved \nin the rewritten class .les.          When compounds are linked, class .le symbol rewriting \nis used to update references to imported classes in class .les when con\u00adnections are made in compounds, \nand to rename classes based on whether they are hidden or exported from the compound. Class .le rewriting \nis also used to establish method scopes. Since method scopes are dependent on unit boundaries and not \non class or pack\u00adage boundaries, we cannot depend on any built-in JVM mecha\u00adnisms to delineate method \nscopes at runtime. Instead, class .le rewriting renames hidden methods. So that no accidental collisions \ncan occur in valid constructions, renaming is applied across mul\u00adtiple unit compositions so that distinct \nmethods remain uniquely named. The only run-time performance penalty due to using units arises from the \nduplication of the binary forms of units during linking. That is, using a single unit to create many \ndifferent unit instances could lead to binary bloat, which can have negative performance effects (e.g., \ndue to instruction cache and native compilation). On the other hand, units used in different contexts \ncould be optimized independently. For example, method scoping could be used to de\u00advirtualize method calls \n[29] as units are linked. Although the symbols used in Java class .les can easily be rewrit\u00adten, Symbols \nreferred to in Java native methods cannot. A Java na\u00adtive method is bound to a method based on the name \nof the method and its containing class. Changing either the name of the class or method breaks this connection. \nTherefore, only classes without na\u00adtive methods can be contained within units. Such renaming also interferes \nwith some uses of the Java Re.ection API where sym\u00adbols are referred to at runtime. A linked unit can \nbe loaded and linked directly by the JVM. Since such linking is primarily performed in the class loader, \nwe refer to this as class loader linking, in contrast to Jiazzi linking, which has been described so \nfar. The exported classes of the unit appear as normal Java classes, which can be loaded and be made \navailable through the class loader. Compared to Jiazzi linking, class loader linking is fragile. A class \ns imports can be bound to classes that differ from the classes com\u00adpiled (and type checked) against. \nSince there is no description of the classes originally compiled against, like those provided by Ji\u00adazzi \nwith a unit s signature, type checking during class loader link\u00ading is implemented in the JVM with incremental \nwhole-program analysis (using constraints [17]) and runtime checks (e.g., check\u00ading that abstract methods \nare implemented when invoked). Currently, component-based programs in Jiazzi must use a combi\u00adnation \nof Jiazzi and class loader linking. Many classes in the stan\u00addard language library, such as Object and \nString, are strongly tied to the language and can only be linked through the class loader. Also, because \nthey depend on re.ection or native methods, many class libraries cannot be repackaged as Jiazzi components. \n 6. RELATED WORK Many of the techniques and concepts used in Jiazzi have been ex\u00adplored previously: the \ncore component model is derived from pro\u00adgram units [7, 10] and Jiazzi s method-scoping rules resemble \nthose of Riecke and Stone [22] and Vouillon [28]. Our contribution in Jiazzi is demonstrating how these \ntechniques can be combined to de.ne a practical component system for Java that also applies to other \nstatically typed object-oriented languages. In doing so, we have solved the type challenge left open \nby Findler and Flatt [7]. The language ComponentJ [24] is a unit-like component system for Java. ComponentJ \nis a language extension in which components are objects that import and export methods but not types. \nComponents in ComponentJ are also .rst-class values. Moby [8, 9] is a structurally typed object-oriented \nlanguage that supports ML-style modules. Methods can be hidden in modules: object types created in these \nmodules do not propagate the hid\u00adden methods in their type. However, a hidden method can still be invoked \nby explicitly specifying its originating class type. Since Moby does not use subclassing relationships \nimplicitly when typ\u00ading method invocations, module applications that create method collisions are allowed. \nTo resolve ambiguous methods, Moby relies on object-view coercion to explicitly coerce the type of an \nexpres\u00adsion from a class to one of its superclasses. Moby does not support the cyclic linking of modules. \nMixins were pioneered in CLOS [15]. JAM [2] extends Java with in-language mixins. The module system of \nObjective Caml [16] supports external class connections. Since classes can be de.ned in modules, these \nclasses can also form something like mixins. How\u00adever, Objective Caml does not permit a class supplied \nto a compo\u00adnent (functor) to provide more methods than required by the com\u00adponent. JavaMod [3] is a theoretical \nmodule calculus for Java. It supports the import and export of classes and cyclic module linking. How\u00adever, \nthey do not consider situations where imported classes inherit from exported classes. JavaMod supports \nsubclassing across mod\u00adule boundaries, but extra methods provided for an imported class must be explicitly \nhidden, and resulting subclasses will not contain those hidden methods. Jiazzi s open class pattern provides \na modular way to add features to classes in object-oriented systems. Odersky [19] addresses the similar \nproblem of class adaptability by adding views to objects. A view is an unnamed function that adds methods \nand .elds to an existing class. Views cannot be implemented with separate compi\u00adlation. MultiJava [6] \nis a Java language extension that addresses adding new methods (but not .elds) to existing classes with \nopen classes. New methods can be added to a class using scoped compilation units. Separate compilation \nis supported since clients of the class explicitly choose which scopes they can view. It is possible \nfor new compilation units in MultiJava to add new methods to classes after execution begins, in contrast \nto Jiazzi where new methods and .elds can only be added when the units undergoes link-time con\u00adstruction. \nWork in separation of concerns, such as subject-oriented program\u00adming [13], address the issues of separating \nclass features into sepa\u00adrate modules. Feature-oriented programming [21] and role compo\u00adnents [27] use \nindividual mixin-like structures to decompose de\u00adsigns into feature hierarchies. An approach similar \nto the open class pattern is used in Mixin Layers [25]. Instead of using indi\u00advidual mixins, Mixin Layers \nprovides constructs that apply mixins to multiple classes at once. Java Layers [5] is an implementation \nof Mixin Layers for Java. Jiazzi does not provide a solution for the con.guration of run\u00adtime behavior \nas do other component systems such as COM [23], CORBA [20], and JavaBeans [14]. Such components are used \nat design time to con.gure runtime behavior and do not provide a good solution for system deployment. \nCon.guration of code versus runtime behavior address reusability at different times and granu\u00adlarities. \nJiazzi complements these component systems. For exam\u00adple, since a Bean in JavaBeans exists as a set of \nJava classes, it can be contained inside a Jiazzi unit. 7. CONCLUSIONS AND FUTURE WORK We have presented \nthe design and implementation of Jiazzi, which enhances Java with externally linked, hierarchical, and \nseparately compiled components. Jiazzi s support for mixin constructions and cyclic linking allows open \nclasses to be simulated leading to clean functional decomposition of features in programs. Jiazzi does \nnot change existing Java development practice: programs are still writ\u00adten in the Java language and still \nexecute on conventional Java vir\u00adtual machines. Although we have .nished Jiazzi s core component model \nand initial implementation, we are still enhancing Jiazzi in many areas: -Providing more integrated support \nfor open classes in Jiazzi; -Adding more .exibility to component composition by pro\u00adviding more control \nover method scopes and the hiding of abstract methods; -Add support for online linking of components, \nand a meta\u00adprogramming protocol that allows for con.guration of com\u00adponent linking at runtime instead \nof statically in the Jiazzi component language; -Integrating Jiazzi more closely into a JVM so class \nloader linking and bytecode duplication can be avoided, and to al\u00adlow re.ection and native methods inside \ncomponents. We expect that more areas of improvement will be revealed as we gain experience in using \nJiazzi to build large systems. An imple\u00admentation of Jiazzi for Java is available for download at: http://www.cs.utah.edu/plt/jiazzi. \nAcknowledgments We thank Don Batory, Richard Cardone, Craig Chambers, Eric Eide, Robby Findler, Kathleen \nFisher, Alastair Reid, Patrick Tull\u00admann, and the anonymous reviewers for comments on drafts of this \npaper. Sean McDirmid was supported in part and Wilson Hsieh in full by NSF CAREER award CCR 9876117. \nMatthew Flatt was supported by DARPA contract F33615-00-C-1696. 8. REFERENCES [1] Jiazzi Homepage, 2001. \nhttp://www.cs.utah.edu/plt/jiazzi. [2] D. Ancona, G. Lagorio, and E. Zucca. JAM a smooth extension of \nJava with mixins. In Proc. of ECOOP, pages 154 178, June 2000. [3] D. Ancona and E. Zucca. True modules \nfor Java classes. In In Proc. of ECOOP, To appear. [4] G. Bracha and W. Cook. Mixin-based inheritance. \nIn Proc. of OOPSLA, pages 303 311, Oct. 1990. [5] R. Cardone and C. Lin. Comparing frameworks and layered \nre.nement. In Proc. of ICSE, pages 285 294, May 2001. [6] C. Clifton, G. Leavens, C. Chambers, and T. \nMillstein. MultiJava: Modular open classes and symmetric multiple dispatch for Java. In Proc. of OOPSLA, \npages 130 146, Oct. 2000. [7] R. Findler and M. Flatt. Modular object-oriented programming with units \nand mixins. In Proc. of ICFP, pages 98 104, Sept. 1998. [8] K. Fisher and J. Reppy. The design of a class \nmechanism for Moby. In Proc. of PLDI, pages 37 49, May 1999. [9] K. Fisher and J. Reppy. Extending Moby \nwith inheritance-based subtyping. In Proc. of ECOOP, pages 83 107, June 2000. [10] M. Flatt and M. Felleisen. \nUnits: Cool modules for HOT languages. In Proc. of PLDI, pages 236 248, May 1998. [11] E. Gamma, R. Helm, \nR. Johnson, and J. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, \n1994. [12] J. Gosling, B. Joy, G. Steele, and G. Bracha. The Java Language Speci.cation, Second Edition. \nAddison-Wesley, Reading, Mass., 2000. [13] W. Harrison and H. Ossher. Subject-oriented programming (a \ncritique of pure objects). In Proc. of OOPSLA, pages 411 428, Nov. 1993. [14] JavaSoft, Sun Microsystems, \nInc. JavaBeans Components API for Java, 1997. JDK 1.1 documentation, http://java.sun.com/products/jdk/1.1/docs/guide/beans. \n[15] S. Keene. Object-Oriented Programming in Common Lisp: A Programming Guide in CLOS. Addison Wesley, \n1989. [16] X. Leroy, D. Doligez, J. Garrigue, D. R emy, and J. Vouillon. The Objective CAML system, documentation \nand user s manual, 2000. http://caml.inria.fr/ocaml/htmlman/. [17] S. Liang and G. Bracha. Dynamic class \nloading in the Java Virtual Machine. In Proc. of OOPSLA, Oct. 1998. [18] T. Lindholm and F. Yellin. The \nJava Virtual Machine Speci.cation, Second Edition. Addison-Wesley, Reading, Mass., 2000. [19] M. Odersky. \nObjects + views = components? In Proc. of Workshop on Abstract State Machines, pages 50 68, Mar. 2000. \n[20] OMG. CORBA/IIOP Speci.cation, 2.4.1 edition, 2000. Formal document 2000-11-07. http://www.omg.org/\u00adtechnology/documents/formal/corbaiiop.htm. \n[21] C. Prehofer. Feature-oriented programming: A fresh look at objects. In Proc. of ECOOP, pages 419 \n443, June 1997. [22] J. G. Riecke and C. A. Stone. Privacy via subsumption. Theory and Practice of Object \nSystems, 1999. [23] D. Rogerson. Inside COM. Microsoft Press, 1997. [24] J. Seco and L. Caires. A basic \nmodel of typed components. In Proc. of ECOOP, pages 108 128, June 2000. [25] Y. Smaragdakis and D. Batory. \nImplementing layered designs with mixin layers. In Proc. of ECOOP, pages 550 570, June 1998. [26] C. \nSzyperski. Component Software: Beyond Object-Oriented Programming. ACM Press and Addison-Wesley, New \nYork, N.Y., 1998. [27] M. VanHilst and D. Notkin. Using role components to implement collarboration-based \ndesigns. In Proc. of OOPSLA, pages 359 369, Oct. 1996. [28] J. Vouillon. Combining subsumption and binary \nmethods: An object calculus with views. In Proc. of POPL, pages 290 303, Jan. 2001. [29] A. Zaks, V. \nFeldman, and N. Aizikowitz. Sealed calls in Java packages. In Proc. of OOPSLA, pages 83 92, Oct. 2000. \n  \n\t\t\t", "proc_id": "504282", "abstract": "We present Jiazzi, a system that enables the construction of large-scale binary components in Java. Jiazzi components can be thought of as generalizations of Java packages with added support for external linking and separate compilation. Jiazzi components are practical becuase they are constructed out of standard Java source code. Jiazzi requires neither extensions to the Java language nor special conventions for writing Java source code that will go inside a component. Our components are expressive becuase Jiazzi supports cyclic component linking and mixins, which are used together in an <i>open class pattern</i> that enables the modular addition of new features to existing classes. This paper describes Jiazzi, how it enhances Java with components, its implementation, and how type checking works. An implementation of Jiazzi is available for download.", "authors": [{"name": "Sean McDirmid", "author_profile_id": "81100205762", "affiliation": "School of Computing, University of Utah", "person_id": "PP39032416", "email_address": "", "orcid_id": ""}, {"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "School of Computing, University of Utah", "person_id": "PP39045354", "email_address": "", "orcid_id": ""}, {"name": "Wilson C. Hsieh", "author_profile_id": "81100546684", "affiliation": "School of Computing, University of Utah", "person_id": "P300415", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/504282.504298", "year": "2001", "article_id": "504298", "conference": "OOPSLA", "title": "Jiazzi: new-age components for old-fasioned Java", "url": "http://dl.acm.org/citation.cfm?id=504298"}