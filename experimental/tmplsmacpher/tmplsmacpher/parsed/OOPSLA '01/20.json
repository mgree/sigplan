{"article_publication_date": "10-01-2001", "fulltext": "\n Object-Oriented Composition Untangled Klaus Ostermann Mira Mezini Siemens AG, Corporate Technology \nSE 2 Darmstadt University of Technology D-81730 Munich, Germany D-64283 Darmstadt, Germany Klaus.Ostermann@mchp.siemens.de \nmezini@informatik.tu-darmstadt.de ABSTRACT Object-oriented languages come with pre-de.ned composi\u00adtion \nmechanisms, such as inheritance, object composition, or delegation, each characterized by a certain set \nof com\u00adposition properties, which do not themselves individually exist as abstractions at the language \nlevel. However, of\u00adten non-standard composition semantics is needed, with a mixture of composition properties, \nwhich is not provided as such by any of the standard composition mechanisms. Such non-standard semantics \nare simulated by complicated archi\u00adtectures that are sensitive to requirement changes and can\u00adnot easily \nbe adapted without invalidating existing clients. In this paper, we propose compound references, a new \nab\u00adstraction for object references, that allows us to provide explicit linguistic means for expressing \nand combining in\u00addividual composition properties on-demand. The model is statically typed and allows \nthe programmer to express a seamless spectrum of composition semantics in the interval between object \ncomposition and inheritance. The resulting programs are better understandable, due to explicitly ex\u00adpressed \ndesign decisions, and less sensitive to requirement changes. 1. INTRODUCTION The two basic composition \nmechanisms of object-oriented languages, inheritance and object composition, are very dif\u00adferent concepts, \neach characterized by a di.erent set of prop\u00aderties. The properties of inheritance have been discussed \nin several works, e.g., [25, 31, 22]. Also, the relationship be\u00adtween inheritance and object composition \nis carefully stud\u00adied, e.g., in [17, 16]. The mixture of composition proper\u00adties supported by each mechanism \nis .xed in the language implementation and individual properties do not exist as abstractions at the \nlanguage level. However, often non-standard composition semantics is needed, with a mixture of properties, \nwhich is not as such Permission to make digital or hard copies of part or all of this work or personal \nor classroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advantage and that copies bear this notice and the full citation on the first page. To copy \notherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission \nand/or a fee. OOPSLA 01 Tampa Florida USA Copyright ACM 2001 1-58113-335-9/01/10 $5.00 provided by any \nof the standard techniques. We indi\u00adcate that in the absence of linguistic means for express\u00ading and \ncombining individual composition properties on\u00addemand, such non-standard semantics are simulated by complicated \narchitectures that are sensitive to requirement changes and cannot easily be adapted without invalidating \nexisting clients. Actually, the need to combine properties of inheritance and object composition has \nalready been the driving force for two families of non-standard approaches to object-oriented composition. \nOn one side, delegation [20] enriches object composition with inheritance properties. Please note that \nin contrast to the frequent use of the term delegation as a synonym for forwarding semantics, in this \npaper it stands for dynamic, object-based inheritance. In pure delegation-based mod\u00adels, objects are \ncreated by cloning other prototype objects, and objects may inherit from other objects, called parents. \nHence, in such models one has object composition and dele\u00adgation, but no class-based inheritance. The \nmost prominent programming language in this family is Self [32]. More re\u00adcently delegation-based techniques \nare integrated into stati\u00adcally typed, class-based languages, which thus provide class\u00adbased inheritance, \ndelegation, and object composition [18, 11, 4]. On the other side, several mixin-based models [7, 21, \n12, 2] approach the goal of combining inheritance and object composition properties from the opposite \ndirection, enrich\u00ading inheritance with object composition properties, such as the ability to statically/dynamically \napply a subclass to sev\u00aderal base classes. Like standard composition mechanisms, these approaches also \ndo not provide abstractions for explicitly expressing in\u00addividual composition properties that would allow \nto combine these properties on-demand. In this paper, we distinguish between .ve properties that can \nbe used to describe the rela\u00adtion that holds between two modules M and B (classes and/or objects) to \nbe composed, whereby B denotes the base mod\u00adule, M denotes the modi.cation module, and M(B) denotes the \ncomposition. 1. Overriding: The ability of the modi.cation to over\u00adride methods de.ned in the base. In \nM(B), M s de.ni\u00adtions hide B s de.nitions with the same name. Self\u00adinvocations within B ignore rede.nitions \nin M. 2. Transparent redirection: The ability to transpar\u00ad   Table 1: Composition properties supported \nby stan\u00addard mechanisms ently redirect B s this to denote M(B) within the com\u00adposition. 3. Acquisition: \nThe ability to use de.nitions in B as if these were local methods in M(B) (transparent for\u00adwarding of \nservices from M to B). 4. Subtyping: The promise that M(B) ful.lls the con\u00adtract speci.ed by B, or that \nM(B) can be used every\u00adwhere B is expected. 5. Polymorphism: The ability to (dynamically or stat\u00adically) \napply M to any subtype of B.  Table 1 shows the set of properties we discuss in the paper as row indexes. \nColumns are indexed by existing object\u00adoriented composition mechanisms. The key idea of the approach \npresented in this paper is the separation and independent applicability of these notions by providing \nexplicit linguistic means to express them. This al\u00adlows the programmer to build a seamless spectrum of \ncompo\u00adsition semantics in the interval between object composition and inheritance, depending on the requirements \nat hand, making object-oriented programs more understandable, due to explicitly expressed design decisions, \nand less sensitive to requirement changes, due to the seamless transition from one composition semantics \nto another. The remainder of the paper is organized as follows. Sec. 2 discusses examples where non-standard \ncombinations of composition properties are desirable. Sec. 3 presents the ba\u00adsic concepts of our model. \nThe model is evaluated in Sec. 4. Sec. 5 discusses some advanced issues related to static type safety. \nRelated work is discussed in Sec. 6. Sec. 7 summa\u00adrizes the paper and suggests areas of future work. \n 2. MOTIVATION In this section we consider three composition scenarios where non-standard combinations \nof composition properties make sense. In all cases, we discuss various designs that can be used to achieve \nthe desired composition semantics. How\u00adever, please note that this section is not about proposing THE \nultimate designs for the given scenarios. The reader might eventually come up with other, equivalent \nor even superior, designs to the same scenarios. Yet, this is not es\u00adsential for the purpose of this \nchapter: The main message Figure 1: Class diagram for account example we want to convey is rather (a) \nthat in all cases some so\u00adphisticated design is needed, which does not explicitly state important conceptual \nrelationships between the involved ab\u00adstractions, and (b) that di.erent designs are needed for dif\u00adferent \ncombinations of composition properties. 2.1 Composition Scenario 1: The Account Example Consider an application \nin the banking domain with per\u00adsons, companies, accounts, and standing orders. The re\u00adlation between \npersons/companies and accounts is usually one to many. However, in this example we want each ac\u00adcount \nto have a dedicated role for its owner. For exam\u00adple, we want a company to have a dedicated pay account \nand a dedicated rental account. This makes it possible to choose the appropriate account for speci.c \ntransfers auto\u00admatically. In this (simpli.ed) example, a Person has only one main account and a Company \nhas a rental and a pay ac\u00adcount. Di.erent kinds of accounts exist (SavingsAccount, CheckingsAccount), \nand accounts are subject to frequent changes at runtime. A particular account may be shared, as e.g., \ntwo persons may use the same account, or the pay account and the rental account of a company may be iden\u00adtical. \nA class SOP (standing order processing) is used for the registration, deregistration and execution of \nstanding orders. On execution, multiple standing orders with identical source and target accounts are \nsummarized to a single transfer. A class diagram for this problem is shown in Fig. 1. Based on the information \non a pay order, the OrderProcessingClerk gets the account objects from the involved Person/Company, creates \na StandingOrder and registers it with a SOP. This design is simple and easy to understand. However, it \nhas a problem: If the account of a person changes, a previously registered standing order will still \nbe executed with respect to the outdated account. With the design in Fig. 1, one has to update all account \nreferences that were ever given out by a person or company manually . That is de.nitely undesirable. \nGiven a reference p to a Person object, we ideally want p s account , i.e., a compound, or indirect reference \nto account via p, to be passed to SOP, rather than the account refer\u00adence itself. In other words, we \nwant some kind of redirect semantics for references: the meaning of account should be Figure 2: Decorator \ndesign for output streams late bound within the current context of the object referred to by p, whenever \np s account gets evaluated. Due to the lack of such compound references in standard object\u00adoriented languages, \nwe have to change the architecture of our design to simulate them. Some possible solutions are discussed \nbelow. A decorator [15] that contains an account object and forwards all calls to it is passed to SOP \ninstead of the account object itself. The base object of the decora\u00adtor (the account) can be changed \nwithout the need for further manual updates. However, the identity test in SOP fails: If two persons \nshare an account, SOP com\u00adpares non-identical decorators with the same base ob\u00adject. Other subtleties \nof an architecture that uses the decorator pattern for composition are highlighted in the next scenario. \n A second approach is to change the SOP class so that it accepts AccountOwner instead of Account objects \nwith AccountOwner being an interface with a single getAccount() method. Person and Company have to implement \nthe AccountOwner interface. This is di.\u00adcult in the Company case, because a company has two di.erent \naccounts. For this reason, we have to create a separate AccountOwner subclass for Company1 . Besides \nits complexity, the main drawback of this approach is that we have to modify the StandingOrderProcessing \nclass, which might not be desirable or even possible in case this class is purchased as part of a banking \ncom\u00adponent library. Another limitation of this proposal is that it works only for one level of redirection. \nFor example, we might want to register a standing order that transfers money to the account of a person \ns cur\u00adrent spouse (and, spouses are also subject to frequent changes these days).  A common approach \nto avoid the coupling of the  1In Java, these classes would probably be implemented as inner classes. \nFigure 3: Simulation of transparent redirection sender of a request to its receiver is the chain of re\u00adsponsibility \npattern [15]. Applied to our example this would mean that each account has an optional suc\u00adcessor account \nand new accounts are appended to the previous account. Calls to the account are forwarded to the last \nand current account in the chain. Besides its considerable complexity, this approach is not com\u00adpatible \nwith sharing of accounts. Another possible solution would be to let the SOP class be an observer [15] \nof persons and companies that is noti.ed whenever an account is exchanged. However, it is easy to see \nthat this would result in a design that is even more complicated than the previous ones.  2.2 Composition \nScenario 2: The Stream Example I/O Streams exist in multiple variations and the di.erent stream features \nare typically implemented as decorators [15] of a basic stream class (see e.g., the Java I/O package \n[29]), so that the set of desired features for a stream instance can be choosen dynamically. A typical \ndecorator design for out\u00adput streams is shown in Fig. 2. By using the decorator to compose basic OutputStream \nfunc\u00adtionality with optional .ltering features we want to achieve the following composition properties: \n(a) subtyping between the resulting composition and the base component, (b) ac\u00adquisition of the base \nbehavior within the .ltering functional\u00adity, (c) dynamic polymorphism -a certain .ltering should be applicable \nto any subtype of OutputStream, and (d) overrid\u00ading of the methods that have to be changed for the extended \nfunctionality. The decorator pattern realizes dynamic poly\u00admorphism of the composition by means of object \ncomposi\u00adtion and subtype polymorphism. Acquisition and overrid\u00ading is achieved by implementing the base \ncomponent s inter\u00adface by means of forwarding methods resp. decorator-speci.c methods. The decorator \nbecomes a subtype of the compo\u00adnent by inheritance. The simulation of these composition properties, however, \nhas a number of shortcomings: Figure 4: Structure of text justi.er and tree iterator The implementation \nof the decorator class is a tedious and error-prone work, due to the manual simulation of the acquisition \nfeature. In addition, it su.ers from the syntactic fragile base class problem [30]: Whenever the interface \nof the base component changes, the cor\u00adresponding forwarding methods have to be added or deleted.  We \nhave no transparent redirection. This means that method calls to this within the base component are not \ndispatched to their overridden methods in the dec\u00adorators but to the local implementations. A further \nconsequence is that if a base object passes this to other objects, it passes itself instead of the decorator. \nIn some situations, however, the opposite e.ect would be desirable. This anomaly is known as the self \nprob\u00adlem [20] or as broken delegation [16]. The manual simu\u00adlation of transparent redirection is rather \ncomplex and leads to a design that is very di.erent from the orig\u00adinal decorator pattern because the \nbase object needs some way of knowing about the decorators. One alter\u00adnative is to store a back reference \nto the decorator in the base, but this would prohibit multiple decorators for one base object. Another \nsolution with (again) a di.erent design is to pass the decorator to the base object in every method call. \nA corresponding design is illustrated in Fig. 3.  The base class may de.ne state. All decorators inherit \nthis state and become unnecessary heavy. Although merely a subtype relationship between the decorator \nand the base component is needed, the decorator is enforced to inherit the state, due to the use of inheri\u00adtance \nfor subtyping. This is usually no problem if the usage as a base for decorators was already anticipated \nat writing time. However, if a prede.ned library class should be decorated, this may be a problem.  \n 2.3 Composition Scenario 3: The TextJusti.er Example Envisage a TextJustifier command class in a text \nprocess\u00ading system, which justi.es all paragraphs in a document, ex\u00adcept for preformatted paragraphs. \nThe document elements to be justi.ed are stored in a recursive object structure, as shown in the diagram \non the left-hand side of Fig. 42 . 2In a more realistic situation, one would have to apply the visitor \npattern to connect TextJustifier and the DocEle- Figure 5: Usage of the iterator by inheritance For \nperforming the document justi.cation the text justi.er needs to iterate over the document structure. \nAssume that we have already implemented a tree iterator class shown on the right-hand side of Fig. 4. \nThe class TreeIterator en\u00adcodes a breadth-.rst iteration strategy for recursive object structures. It \ncan be used by overriding the action() and test() methods for the speci.c purpose. The iterator class \nprovides a number of iteration mechanisms, e.g., applying action() to all elements that satisfy test() \n(doAll()), or up to the .rst one that does not satisfy test() (doWhile()), and so on. Assume that the \ndesign shown in Fig. 53 where text justi.cation and iteration functionality are composed by means of \ninheritance is just good enough for satisfying the requirements on our system during an early stage of \nthe development process. In a later iteration stage, we realize that inheritance is not the composition \nsemantics we want. First, we do not want TextJustifier to be a subtype of TreeIterator anymore because \na TextJustifier is not a special kind of an itera\u00adtor. In addition, the acquisition semantics that comes \nwith inheritance is not desired anymore; all methods of TreeIt\u00aderator pollute the interface of TextJustifier, \nwhich has become complex anyway during the development. Second, the initial requirements have slightly \nchanged: It should be possible to determine the iteration strategy to be used with a TextJustifier at \nruntime. For this purpose, subclasses PreOrder and PostOrder of TreeIterator have been im\u00adplemented that \nre.ne the default breadth-.rst semantics by overriding the first() and next() methods. Now, the question \nis how to compose the text justi.er in Fig. 4 with the iteration hierarchy, such that the above set of \ncomposition properties are satis.ed. A feasible solution is schematically presented in Fig. 6. TextJustifier \nhas an instance variable, it, of type TreeIterator, which can be assigned to an instance of MyPreOrder, \nMyIterator, or MyPostOrder. The latter are de.ned as subclasses of the corresponding library classes \nand redundantly implement the test() and action() methods for the justi.cation pur\u00adposes. It is quite \nreasonable to assume that the test and the action performed in each step of the iteration needs infor\u00ad \nment hierarchy. For the sake of simplicity, we assume this is not the case in our example. The problems \nwe discuss here apply to a visitor-based design as well. 3In the design we assume that DocElement implements \nTree Figure 6: Initial design for dynamic composition mation from the text justi.er object, which is \nprovided via the context reference on the TextJustifier. Obviously, the design in Fig. 6 is very di.erent \nfrom the predecessor design in Fig. 5. That is, two di.erent mixtures of features for composing the same \npieces of functionality are realized by two very di.erent designs. Furthermore, the design is more complex \nthan the design in Fig. 5, and it does not re.ect the conceptual relationships between the entities in \nit. Additional classes and associations have been introduced, and the MyXXX classes contain duplicated \nimple\u00admentations of action() and test(). At this point, it becomes clear that the initial iterator de\u00adsign \nis unsatisfactory because it leads to code duplication as in Fig. 6. It would have been better to choose \na more sophisticated design for the iterator classes right from start, namely iterators that use a command \nclass (IterationStep) as shown in Fig. 7. But this still does not solve our prob\u00adlem: We still need a \ncomplex design such as in Fig. 7, al\u00adthough the conceptual relationship between TextJustifier and TreeIterator \nis as simple as the initial design in Fig 5. The design in Fig 5 would already be su.cient, even for \nthe dynamic composition, if only we could con.gure the re\u00adlation between TextJustifier and TreeIterator \nwith the properties in Tab. 1.  2.4 Problem Statement Summary So far so good. In all cases, the desired \ncomposition seman\u00adtics can indeed be achieved somehow. Still, the result is highly unsatisfactory. Why? \nFirst, the most severe problem is that the architectures we ended up with are completely di.erent, depending \non the desired mixture of composition properties. Second, the design gets complex, as soon as a composition \nis required that deviates from the semantics of the standard composition mechanisms directly supported \nby linguistic means. As illustrated by the .rst composition scenario, di.erent programmers may come up \nwith di.erent architectures even Figure 7: More sophisticated design for dynamic composition for the \nsame composition semantics. Moreover, any later change of the composition features might require switching \nto another architecture. This is not only a tough challenge for any programmer. It also a.ects the understandability, \nand hence maintenance of object-oriented programs: The very important knowledge about the encoded composition \nsemantics is not explicitly expressed by any of the designs that simulate non-standard semantics. In \ngeneral, it is not obvious how to separate the part of the architecture that is directly involved in \nencoding application logic from the part of the architecture that serves as an infrastructure for encoding \nnon-standard composition semantics. As a conse\u00adquence, it is hard to guess from looking at the design \nthat two architectures are di.erent merely because they encode di.erent composition semantics, or that \ntwo di.erent archi\u00adtectures actually implement the same application logic, and only di.er in the way \nthey encode the same composition semantics. The frequency of changes in the composition features is documented \nby refactorings, such as, Replace Delegation with Inheritance 4, Replace Inheritance with Delegation \n, Hide Delegate and Remove Middle Man [13]. In our ter\u00adminology, each of these refactorings can be seen \nas moving from an architecture with a certain mixture of composition properties to another one with another \nmixture of composi\u00adtion features that better .ts the requirements or the current state of the development \nprocess. The work on refactoring recognizes that such transformations are not trivial and aims at aiding \nprogrammers in performing them by describing the process in a systematic way, or even (partly) automating \nit by means of refactoring browsers. The highly positive echo that the work on refactoring has found \nin the object-oriented community, especially in the practice of everyday program\u00adming, actually supports \nour claim that the need for di.er\u00adent architectures to express di.erent composition semantics makes a \nprogrammer s life harder. 4Fowler uses the term delegation in the sense of decorator\u00adlike forwarding \nHowever, we follow another path in approaching the prob\u00adlem, motivated by the observation that identifying \nand de\u00adscribing common refactorings does not solve the core prob\u00adlem: It does not change anything in \nthe fact that di.erent architectures for di.erent composition semantics are needed and one still needs \nto switch from one architecture to the other in order to react to requirement changes. Conse\u00adquently, \nwe put the emphasis on tackling the problem in its roots: At language design. Our claim is that besides \nidentifying and describing refactorings we should strive for language mechanisms that make some of the \nrefactorings obsolete, or at least explicit in the language. This require\u00adment becomes even more relevant \nin a component setting where refactoring steps like adjust all clients to call the new server are no \nlonger feasible.  3. THE COMPOUND REFERENCE MODEL This section introduces the basic notions of our \nmodel as an extension of the Java programming language [3]. However, the concepts are easily applicable \nto other statically typed OO languages. Each introduced feature corresponds to a row in Table 1 and represents \na step forward on a seam\u00adless transition from object to inheritance-based composition semantics. 3.1 \nField Methods and Overriding To explain the operational semantics of our model, we use the notion of \n.eld methods.A .eld method is a method that pertains to a speci.c .eld. Syntactically, the a.liation \nof a method to a .eld is expressed by pre.xing the method name with the .eld name using . as separator. \nA class C with a .eld f of type F can be thought of as implicitly containing a method named f.m() for \nevery public method m() of F. The method named f.m() has the same signature as m() in F, and its visibility \nis identical to the visibility of f in C. The default implementation of f.m() in C is one that simply \nforwards m() to the object referred to by f, denoted within the implementation of f.m() by the special \npseudo-variable field. This is similar to the pseudo-variable super denot\u00ading an overridden method within \nthe overriding method. Fi\u00adnally, any invocation of m() on the object referred to by f within C should \nbe thought of as being dispatched to the corresponding implicit .eld method f.m(). For illustration, \nrecall the iterator example from Sec. 2. With the implicit .eld methods written down, the code for the \nTextJustifier would look like in Fig. 85 . The call it.doAll() within justify() should be thought of \nas ac\u00adtually calling the implicitly available .eld method named it.doAll(). Until know, the introduction \nof .eld methods into the im\u00adplementation of a class has no impact on the semantics of the class. The \nTextJustifier implementation presented in Fig. 8 is semantically equivalent to an implementation that \ndoes not contain any implicit .eld method. The decisive point is that implicit methods can be replaced \nby explicitly 5In the context of this section, the reader should think of the abstract methods as being \nimplemented empty. class TextJustifier { private TreeIterator it; public void justify() { ... it.doAll() \n... } // ** begin of implicitly available field methods ** private void it.doAll() { field.doAll(); } \nprivate void it.doWhile() { field.doWhile(); } private void it.doUntil() { field.doUntil(); } ... private \nvoid it.action(Item x) { field.action(x); } private boolean it.test(Item x) { return field.test(x); } \n // ** end of implicitly available field methods ** } Figure 8: Implicit .eld methods in TextJusti.er \n class TextJustifier { private TreeIterator it; private void it.doAll() { ... } public void justify() \n{... it.doAll(...); } } Figure 9: Explicit .eld methods in TextJusti.er available methods. For example, \nin order to implement an action to be undertaken whenever it.doAll() is called in TextJustifier, the \nprogrammer of TextJustifier would implement an explicit .eld method, called it.doAll(), en\u00adcoding the \ndesired behavior, as shown in Fig. 9. Please note that Fig. 9 is only an illustration of explicit .eld \nmethods and not our .nal solution for the TextJusti.er problem. Before leaving this section we would \nlike the reader to re\u00adcall that we we introduced implicit methods as a means to describe the operational \nsemantics of our model, indepen\u00addently of a speci.c implementation. 3.2 Field Redirection with Compound \nRefer\u00adences The central mechanism of our model is the notion of com\u00adpound references (CR). In contrast \nto primitive references , the binding of a CR to an object is not absolute, but rather relative to another \nreference. To gain a .rst insight for the usefulness of CRs reconsider the account example from Sec. \n2.1. We could solve the problem discussed there if we were able to express that person s account -meaning \nthe account reference within the context of the person refer\u00adence -should be passed to the standing order \nprocessing unit. This is where CRs come into play. A CR to a reference instVar within a class is created \nby means of this<-instVar. To illustrate their semantics, consider the class in Fig. 106 . The getPersonsAccount() \nmethod returns a compound reference to the account in\u00ad 6Please note that in Java all object-typed instance \nvariables are references. class Person { Account account; Account getAccount() { return account;} Account \ngetPersonsAccount() { return this<-account; } void setAccount(Account newAccount) { account = newAccount; \n} } class Client { public static void main(String[] args) { Person jack = ... Account ubsAccount = new \nAccount(\"UBS\", \"12345\"); Account dbAccount = new Account(\"Deutsche Bank\", \"54321\"); jack.setAccount(ubsAccount); \nAccount anAccount = jack.getAccount(); Account jacksAccount = jack.getPersonsAccount(); // anAccount \nand jacksAccount // refer to the UBS account jack.setAccount(dbAccount); // anAccount still refers to \nthe UBS account // but jacksAccount refers to the DB account } } Figure 10: Illustration of compound \nreferences stance variable of a person, while getAccount() returns a primitive reference to the account \ninstance variable of a person. The e.ect of the CR returned by getPersonsAc\u00adcount() is that it always \nrefers to the current value of the account reference within a Person object. After the setAc\u00adcount call \nin the last statement of Client::main in Fig. 10, which changes Jack s account from ubsAccount to dbAc\u00adcount, \njacksAccount will refer to Jack s current Deutsche Bank account, while anAccount will still refer to \nhis old UBS account. Fig. 11 and Fig. 12 schematically show the state before and after changing Jack \ns account. Just like object methods that di.er from functions in the sense that di.erent calls to them \nmay return di.erent val\u00adues, depending on the state of the method s owner (the re\u00adceiver), a CR is di.erent \nfrom a primitive reference in the sense that the evaluation of a CR might result in di.erent values depending \non the state of CR s owner object. CRs are very di.erent from pointers or pointers to pointers etc. A \npointer always explicitly speci.es the dimension of indi\u00adrection (in C++ the number of *). Pointer of \ndi.erent di\u00admensions (for example, Account **a1 and Account ***a2) are not compatible or substitutable7 \n. CRs, on the other hand, are a transparent replacement for usual references: It is generally not known \nwhether a reference is a CR or not, or how many levels of indirection are hidden in the CR. In a way, \nCRs are similar to symbolic links in a Unix .le system. 7A conversion from ** to *** is possible in C++, \nfor ex\u00adample a1= *a2, but the semantics is di.erent: If the .rst indirection of a2 is changed after this \nassignment, a1 still points to the previous account. A symbolic link may refer to a .le or to another \nsymbolic link. If objects were directories, we could create a symbolic account link in the SOP directory \nthat refers to the account link in the Jack directory. A CR can be de.ned relatively to a primitive reference \nor recursively to another CR. Hence, each CR may in general induce a path of object references. For example, \na class Person might return a CR to the spouse of that person. If the getPersonsAccount() method on this \nCR is called, we obtain a new CR with path personOID<-spouse<-account. In general, a CR is an OID o together \nwith a sequence of .eld names v1, ..., vn. ACR o<-v1<-...<-vn induces a corre\u00adsponding path of objects \no0<-o1<-...<-on such that o0 =o and oi =oi-1.vi (details and subtleties about creating an object path \nfor a CR are discussed in section 5). Such a path is not created directly but incrementally as a result \nof creating a CR to a reference that is actually already a CR. In the following, we regard a usual reference \nas a special case of a CR of length one. Relative to an element oi, we call oi-1 a predecessor and oi+1 \na successor. Furthermore, o0 is the head and on is the tail of the CR. Please note that a CR is itself \nimmutable, while the corresponding object path may change in the course of time due to a changing instance \nvariable on the path. Just like any reference in a statically typed language, (a) a CR has a type, (b) \nit can be compared to other CRs, and (c) methods can be invoked on it. We de.ne the static type of a \nCR to be the static type of its tail. It might seem to be straightforward to equally de.ne the dynamic \ntype of a CR. However, we decided to call the dynamic type of the tail the temporary type of a CR, because \nthis type may change as a side e.ect of a .eld update. Downcasts to the temporary type of a CR are disallowed \nin our model because references that are typed to the temporary type may become invalid after a .eld \nupdate. This issue is further discussed in section 5. Let us now consider the identity semantics in the \ncontext of compound references. The question is: Under which condi\u00adtions are two compound references \ns = o<-v1<-...<-vn and t = p<-w1<-...<-wm with their corresponding object paths o0<-o1<-...<-on and p0<-p1<-...<-pm \nconsidered identical? There are at least three possible answers: Head identity: s == t :. o == p.  \nTail identity: s == t :. on == pm.  Path identity: s == t :. n = m and oi == pi for i =0, ..., n.  \n Head identity seems to be awkward because references would be considered identical that are -in general \n-not even of the same type (the static type of a CR is the static type of its tail). For example, CRs \nto the account resp. to the address of the same person would be considered identical. Path identity, \non the other hand, seems to be too restrictive. Recall the account example. If Jack and Sally share an \naccount, then we want Jack s account, i.e., the CR jack<\u00adaccount, to be identical to Sally s account, \ni.e., to the CR sally<-account. Hence, tail identity seems to be the only reasonable identity semantics. \nFor this reason, we de.ne two CRs to be identical if and only if their tails are identical as de.ned \nabove. Finally, let us consider the method call semantics on a CR. If a method implemented by an object \no is called via a CR on o, the value of the implicit this parameter is actually the CR and not o. That \nis, if during the execution of the method the object o passes itself to another object, it actually passes \nthe CR by which the method was called. For convenience, we add some syntactic sugar: A method call (this<-a).m() \nis abbreviated to a<-m(). For illustration, reconsider the TextJustifier implementa\u00adtion in Fig. 9. Truly \nincremental modi.cation would mean to implement only test() and action() since these are the only methods, \nthe semantics of which should be speci.c when used in the context of a TextJustifier. The ques\u00adtion is \nnow, how would then the speci.c iteration step se\u00admantics implemented by TextJustifier::it.action() get \nintegrated into the iteration process which is performed by the doAll() method called on the instance \nvariable it of a TextJustifier? Here is where the interplay between .eld methods and CRs becomes relevant. \nIf methods are dis\u00adpatched via a compound reference, .eld methods override corresponding methods of successive \nobjects. In more de\u00adtail, the semantics is as follows. Let myref = o<-v1<-...<\u00advn be a CR with object \npath o0<-o1<-...<-on and m() be a method of the static type of vn. Furthermore, let i be the lowest index \nsuch that the class of oi contains a .eld method vi+1.....vn.m() (a normal method is regarded as a .eld \nmethod with empty pre.x). Then a method call myref.m() will be dispatched to the .eld method vi+1.....vn.m(). \nThe implementation in Fig. 13 illustrates the inter\u00adplay of CRs and explicit .eld methods. Within Figure \n12: State after changing Jack s ac\u00ad count class TextJustifier { private TreeIterator it; private void \nit.action(Object x) { ... } private boolean it.test(Object x) { ...} public void justify() {... it<-doAll(...); \n} } Figure 13: Explicit redirected .eld methods in Text-Justi.er TextJustifier::justify(), the method \ndoAll() is not called directly on it, but rather via the compound reference this<-it. Consequently, subsequent \ncalls to action() and test() that are made within the control .ow of TreeIterator::doAll() will be dis\u00adpatched \nto TextJustifier::it.action(), respectively TextJustifier::it.test(). With the implementation in Fig. \n13, the fact that Text-Justifier uses and even customizes an TreeIterator is completely hidden from clients \nand subclasses of Text-Justifier. It is not required for overriding methods to respect the visibility \nof the overridden methods, because TextJustifier is not a subtype of TreeIterator. With\u00adout any further \ncode modi.cation, it would also be possible to choose an iteration strategy at runtime (cf. subsection \n2.3) by simply assigning a new iterator object to it. Thus, the implementation in Fig. 13 actually realizes \na compo\u00adsition of TextJustifier and TreeIterator functionalities that supports overriding, transparent \nredirection, dynamic polymorphism, without subtyping and acquisition. So far, compound references to \nan aggregated object referred to by a .eld f are only explicitly created by the aggregating class containing \nf before a method call (cf. f<-m()). That is, the scope of the composition features mentioned above (overriding, \ntransparent redirection, and dynamic polymor\u00adphism) is an individual method call via an explicitly created \nCR to f. This is di.erent with .elds that are declared with // rf is a redirected field private void \nrf.m() { field<-m(); } // f is a non-redirected field private void f.m() { field.m(); } Figure 14: Field \nmethods and .eld redirection class TextJustifier { private redirect TreeIterator it; private void it.action() \n{ ... } private boolean it.test(Item x) { ...} public void justify() {... it.doAll(...);} } Figure 15: \nTextJusti.er with .eld redirection the modi.er redirect. Implicit .eld methods of a .eld that is annotated \nwith the redirect keyword have a di.erent se\u00admantics: Instead of simply forwarding the call to the .eld \nobject, they .rst implicitly create a CR to that .eld and call the method on the created CR. Fig. 14 \nshows the di.erence between the default implementation of implicitly available methods of a redirected \n.eld, rf and that of a non-redirected .eld f. For illustration, a version of TextJustifier with it declared \nas a redirect .eld is given in Fig. 15.  3.3 Field Acquisition Field acquisition is another step on \nthe road from object composition to inheritance. Orthogonal to the other modi\u00ad.ers, the acquire modi.er \ncan also annotate a .eld declara\u00adtion. The intuitive semantics is that the features available in the \n.eld become an inherent part of the aggregating class. A class C with an acquired .eld f of type F implicitly \ncon\u00adtains a method m() for every public method m() of F. The method m() retains its signature as declared \nin F and its visibility in C is public. The semantics of the implicit .eld methods remains the same as \nwith non-acquired .elds, ex\u00adcept that they are now provided in the interface of C. For illustration, \nconsider the example in Fig. 16. Although Emp\u00adtyFilterStream does not itself implement write(int) or \nwrite(int[]), these methods can be invoked on efs an instance of EmptyFilterStream due to the declaration \nof the instance variable stream as an acquired .eld. Acquired implicit methods can also be replaced by \nexplic\u00aditly programmed methods with the same signature. For the sake of uniformity and in order to facilitate \nchanging of a given composition semantics by means of changing the mod\u00adi.ers of an instance variable, \nthe pre.x notation has to be used when explicitly overriding acquired methods. For il\u00adlustration, consider \nthe sample code in Fig. 17. The class BufferedOutputStream acquires both write methods from its acquired \n.eld stream and overrides them to add bu.er\u00ading. Note that the bos.write(array) call in the client code \nin Fig. 17 only displays ... buffering 5 ints ... on the screen. The fact that no message ... buffer\u00ading \na single int ... appears on the screen suggests class OutputStream { public void write(int b) { System.out.println(\"Hello \nfrom write(int )\"); } public void write(int[] b) { System.out.println(\"Hello from write(int[] )\"); } \n} class EmptyFilterStream { acquire private OutputStream stream = new OutputStream(); } class Client \n{ static public void main(String[] args) { EmptyFilterStream efs = new EmptyFilterStream(); int[] array \n= ...; efs.write(3); // \"Hello from write(int )\" appears efs.write(array); // \"Hello from write(int[] \n)\" appears } } Figure 16: EmptyFilterStream with acquired .elds that the overridden write(int) method \nas implemented in BufferedOutputStream is not invoked, although, at this point the write(int) method \nof the underlying fout stream will actually be called 5 times (since the bu.er is already full, the overridden \n.eld method will be called for both the bu.er and the int array passed as a parameter). However, ... \nbuffering a single int ... is not displayed be\u00adcause neither stream is a redirected .eld, nor are the \ncalls field.write(buffer) and field.write(b) made via a compound reference this<-stream. Therefore, the \ncalls to write(int) from within field.write(...) escape the override by the BufferedOutputStream. This \ncorresponds to the broken delegation problem discussed in Sec. 2. In this case, this is indeed the desired \nsemantics, i.e., redirection is actually not desired. Once the bu.er is full, we want to .ush bu.er s \ncontent and the integers to be written imme\u00addiately to the underlying data sink. Hence, we indeed want \nto escape bu.ering. However, there might be cases, when we want all calls occurring within the control \n.ow of a call to an overrid\u00adden acquired method of an object outer to be also dis\u00adpatched to outer. If \n.eld acquisition is combined with .eld redirection, we obtain a perfect solution for this com\u00adposition \nrequirement. In the version of BufferedStream presented in Fig. 18, where stream is declared to be ac\u00adquired \nand redirected, it su.ces to do the bu.ering in the write(int) method, because calls to write(int) in \nthe write(int[]) method are automatically redirected to the bu.ering method. One important restriction \nis imposed on .eld acquisition: We allow every class to have at most one .eld acquisi\u00adtion. Otherwise \nwe would have to take charge of all those annoying multiple inheritance con.icts. However, due to class \nOutputStream { public void write(int b) { ... } public void write(int[] b) { for (i = 0; i < b.size(); \ni++) write(b[i]); } } class BufferedOutputStream { acquire private OutputStream stream; int[] buffer; \nint current; public BufferedOutputStream(out) { stream = out; buffer = ... ; } public void stream.write(int \nb) { System.out.println(\"... buffering a single int ... \"); if (buffer.notFull()) buffer[current++] \n= b; else { field.write(buffer); field.write(b); current = 0; } } public void stream.write(int[] b) \n{ System.out.println(\"... buffering \" + b.size + \"ints ...\"); if (buffer.size() >= current + b.size()) \n{ System.arraycopy(b,0,buffer,current,b.size); current += b.size; } else { field.write(buffer) field.write(b); \ncurrent = 0; } } } class Client { static public void main(String[] args) { FileOutputStream fout = new \nFileOutputStream(aFileName); BufferedOutputStream bos = new BufferedOutputStream(fout); int[5] array \n= ...; bos.write(3); // \"... buffering a single int...\" // appears on the screen ... //assume that buffer \nis full at this point bos.write(array); // \"... buffering 5 ints ...\" // appears on the screen } } Figure \n17: Overriding acquired .elds class BufferedStream { acquire redirect private OutputStream stream; public \nvoid stream.write(int b) { ...do buffering... field.write(b); } } Figure 18: Overriding and redirecting \nacquired .elds the fact that we can (a) do overriding and redirection for multiple .elds, and (b) combine \nmultiple classes by means of organizing them in an acquisition chain, this is no grave limitation. There \nis a second restriction that we need to make. Due to subtype polymorphism, an instance of a subtype of \nOut\u00adputStream may be assigned to the stream instance variable. This subtype may contain methods that \nare not available in OutputStream. These methods should not be overrid\u00adden, because this might lead to \nunexpected or unsound re\u00adsults: The result might be unexpected because the author of the overriding method \ndoes not know about the existence and semantics of the overridden methods. The result might also be unsound, \nbecause the overriding method may have a signature that is not compatible with the signature of the overridden \nmethod (e.g., has a di.erent return type, see also [18]). For this reason, we make the following restriction: \nA .eld method overrides a method de.ned in a .eld type if and only if it is already de.ned in the static \ntype of the .eld type. The addition of the acquire feature into the model, has fur\u00adther enriched the \nrange of composition semantics between the classes C and F that the programmer can express. Used in isolation, \nacquire enables C to transparently forward services to F, whenever it needs to do so, in order to sat\u00adisfy \na request from an external client. On the other hand, combining redirect and acquire yields a mechanism \nfor in\u00adcremental modi.cation that mimics the code reuse provided by inheritance or delegation. 3.4 Subtyping \nOne thing is still missing on the road to inheritance/delegation-based composition: Field acqui\u00adsition \ndoes not imply subtyping. A class can explicitly declare to be a subtype of a number of other types via \na subtypeof clause. Declaring a class C as a subtype of a type T, requires that C has to either implement \nall methods that are de.ned in T or be abstract. In contrast to Java s implements clause, in our model \nboth interfaces and classes may appear on the right hand side of a subtypeof clause8 . Declaring a class \nD to be a subtype of another class C means that D implements the interface of C, but it does not mean \nthat the implementation of C can automatically be used for the realization of the corresponding methods \nin D -D does 8It is still possible to use traditional inheritance with ex\u00adtends. class OutputStream { \n... } class FileOutputStream extends OutputStream { ... } class FilterStream subtypeof OutputStream \n{ acquire redirect protected OutputStream stream; } class BufferedOutputStream extends FilterStream \n{ public void stream.write(in b) { ... do buffering ... ; field.write(b); } class CompressedOutputStream \nextends FilterStream { ... } Figure 19: OutputStream in our model not automatically acquire the state \nand method implemen\u00adtations of C. However, D can still make use of the behavior de.ned in C, if this \nis desired, by declaring a .eld of type C with modi.ers acquire and redirect. This is an impor\u00adtant step \ntowards a better separation of types and classes. Decoupling subtype declaration from implementation \nreuse solves e.g., the last drawback of the decorator approach ex\u00adplained in section 2.2. For illustration, \nthe complete implementation of the stream example from Fig. 2 in our model is given in Fig. 19. Compare \nthis to the simulation of redirect semantics in Fig. 3.  3.5 Field Navigation If the object referred \nto by a .eld represents a facet that should be visible to clients, we would like to have this fact made \nexplicit in the declaration of the .eld, rather then re\u00adlying on the presence of appropriate getter methods. \nFor serving this purpose, a .eld can be made navigable by an\u00adnotating it with the navigable modi.er. \nFor example, we could annotate the account .eld of Person as navigable, as shown below. This allows clients \nto directly navigate to this part of the object by retrieving a compound reference to that part. This \nis illustrated below by having the client of the Person object p retrieve a CR to p s account and store \nit in a. Technically, the declaration of a .eld as navigable can be seen as short-cut for the corresponding \ngetter methods discussed above. class Person { private navigable Account account; } Person p = ... Account \na = p<-account; Note that declaring a .eld as navigable does not imply that clients can directly change \nthe .eld. The possibility to nav\u00adigate to a .eld becomes part of the class interface, similar to a getter \nmethod that returns the current value of a .eld. Actually, the navigable composition semantic .avor discour\u00adages \nrather than supports breaking encapsulation. Export\u00ading a CR to an instance variable to external clients \nas part of the interface of a class C can also be simulated by declar\u00ading a redirect .eld to be public. \nHowever, this breaks the encapsulation of C: clients can freely change the value of the reference. This \nis not possible with navigable references. The inverse navigation operation is provided by a CR reduc\u00adtion \noperator that can be used to access previous objects on the object path of a CR. A reduction <AType> \nmyref on a compound reference myref = o<-v1<-...<-vn creates a new compound reference o<-v1<-...<-vn-1. \nThe reduction suc\u00adceeds if the type of the shortened compound reference (that is, the static type of \nthe vn-1 variable) is a subtype of AType. If the length of the source path is two, a primitive reference \nto o is created. Since it is not statically known whether an account reference is a compound reference \nvia a person, a CR reduction has to be checked at runtime. The reduction operation is in a way similar \nto type downcasts in languages like Java. In the Account example, we could reduce a com\u00adpound reference \nto an Account to Person: Person p = ... Account a = p<-account; Person p2 = <Person> a; // ok, checked \nat runtime (p == p2) // true  4. EVALUATION OF THE MODEL After having introduced the individual steps \non the road from object composition to inheritance, it is now time to show how the problems discussed \nin Sec. 2 are addressed in our model. The key to addressing these problems is the availability of rich \nlinguistic means to express a variety of composition .avors by simply decorating object references with \ncomposition properties. To support the discussion, Fig. 20 introduces graphical notations for some of \nthe most relevant composition .avors between two classes C and F that can be expressed with the model9 \n. Please note that these notations do not address overriding because in our model overriding is implictly \navailable by means of .eld methods and need not be explicitly turned on or o.. Let us start with the \nthe composition .avor (b) -in the mid\u00addle of the road between object composition and inheritance. A composition \nC(F) with this .avor shares with inheritance overriding with late binding. This is not available with \nob\u00adject composition. On the other side, such a .avor shares with object composition dynamic polymorphism \nas well as lack of both acquisition and subtyping. The latter two fea\u00adtures are inseparable from inheritance/delegation, \nthough. The discussion of the TextJustifier example in Sec. 2 indi\u00adcated that such a mixture of features \nmight indeed be needed and that the lack of linguistic means to express it forces the programmer in an \nobject-oriented language to simulate the same semantics by means of complex, unclear architectures that \nare fragile with respect to requirement changes. In the previous section, we have modeled the same com\u00adposition \nscenario in our model. The implementation of the desired composition semantics between TextJustifier \nand the TreeIterator hierarchy is as simple as the code 9This list is not intended to cover all possible \ncombinations of composition features, but only those that are relevant for evaluating the model with \nrespect to the issues discussed in Sec. 2. in Fig. 15 and the design as clear as the class diagram pre\u00adsented \nin Fig. 21, which is as simple as the inheritance-based design in Fig. 5. However, in contrast to the \ninheritance\u00adbased design, with the CR-based solution (1) several itera\u00adtion strategies can be chosen \ndynamically, (2) the iteration functionality does not pollute the interface and implemen\u00adtation of TextJustifier, \nand (3) the conceptual view that a TextJustifier is not a special kind of TreeIterator is preserved. \nThe latter are features that were indeed also supported by the architecture based on object-composition \npresented in Fig. 6 and 7. However, our design does not share the complexity of the designs presented \nin Fig. 6 and Fig. 7. The complexity of designs that simulate non-standard com\u00adposition .avors was only \none of the problems that we identi\u00ad.ed in Sec. 2. The second and more important problem, was that di.erent \ncomposition .avors were modeled by di.erent architectures. In the following, we demonstrate, that this \nproblem is avoided in our model, by reconsidering the text justi.er and stream example from Sec. 2. The \ndesign in Fig. 21 encodes a composition with redirec\u00adtion, overriding and dynamic polymorphism. Assume, \nwe also want to have acquisition. In our model, we would sim\u00adply add the acquire modi.er to the declaration \nof it. The class diagram in Fig. 21 remains the same, except for re\u00adplacing the current it link with \nlink (d) in Fig. 20. On the contrary, with the designs in Fig. 6 and Fig. 7 we would have to change TextJustifier \nto implement all methods in the interface of TreeIterator by forwarding these methods to it. If we additionally \nwant to have TextJustifier be a subtype of TreeIterator, we would again merely have to replace the it \nlink with the link (e) in Fig. 20. The result\u00ading design would still encode a di.erent composition .avor \nas compared to the inheritance based composition in Fig. 5, since (1) we still have a composition that \nsupports dynamic polymorphism and (2) TextJustifier would not inherit the state of TreeIterator. Figure \n21: TextJusti.er using compound references A similar seamless transition from one composition .avor to \nthe other was observed when we modeled di.erent .avors of BufferedOutputStream in Fig. 17, Fig. 18, and \nFig. 19. Here we started with a .avor that is closer to the inheritance end of the composition .avor \nspectrum: Object composition with acquisition semantics. We then added redirection and subtyping in two \nseparate steps. Another important feature of our model which makes it su\u00adperior to standard composition \nmodels is the fact that a class can simultaneously reuse and adapt the functionality of several other \nclasses without su.ering from the known multiple-inheritance con.icts: Naming con.icts: Di.erent methods \nwith the same name are inherited.  Repeated inheritance (a.k.a. diamond inheritance): The same class \nis inherited twice indirectly, for ex\u00adample D is a subclass of B and C, both of which are subclasses \nof A. Is a single copy of A shared by B and C or are there two copies? What happens to methods that are \noverridden in B and C in the .rst case? Which copy of A do clients of D see in the latter case?  Di.erent \nmechanisms have been developed to cope with these problems, but avoiding a problem is certainly better \nthan .xing it. Due to our naming de.nition for .eld meth\u00adods (pre.xing it with the name of the attribute), \nwe have no naming con.icts. Problems related to repeated inheritance do not occur either, because every \ncompound reference in\u00adduces a unique path for message dispatch. The question whether we have a shared \nor replicated parent boils down to assigning the same, respectively di.erent instances of the aggregated \nclass to the corresponding attributes. Finally, we would like to bring up navigable .elds in this evaluation, \nbecause they foster another spectrum of relation\u00adships not discussed so far. Industrial component models \nlike COM [6] and CCM [23] have the notion of independent inter\u00adfaces or facets that a component exposes \nand that can be re\u00adtrieved by special navigation methods. Design patterns such as extension interface \n[26] or extension object [14] propose architectures to allow a class to export multiple unrelated interfaces \n` a la COM and CCM without employing inheri\u00adtance or subtyping. However, as also acknowledged by the \nauthors, the proposed patterns incur increased design and implementation e.ort, e.g., navigation infrastructure \nthat is of no functional use but necessary to retrieve the facets [26], and increased client complexity \n[14, 26]. This critique is in the vein of or our discussion in the motivation section. Navigable .elds \npresent an elegant approach to modeling classes that export several unrelated interfaces. A class C exports \nthe interfaces of all navigable .elds. This is explic\u00aditly declared in the class interface. This export \ninvolves no interface bloat because C s interface does not itself contain the methods of the exported \ninterfaces. This is in contrast to a class in Java implementing several di.erent interfaces. In contrast \nto the extension interface and extension object pat\u00adterns, the feature of exporting several unrelated \ninterfaces is built into the language and integrated with static type checking. The relationship that \nthe exported interfaces are facets of the behavior of the exporting class is explicit in the exporting \nclass interface. The same relationship is not explicit in the design of the extension interface and extension \nobject patterns as also indicated by Gamma [14].  5. ADVANCED ISSUES Until now, compound references \nhave been introduced in a rather informal way. In this section, we will provide more details. In particular, \nwe will show that our model is type safe. Type safety is threatened by subtle combinations of compound \nreferences and subtype polymorphism. In section 3.2, the static and the temporary type of a CR have been \nde.ned. We have argued that type casts to the temporary type of a CR should not be allowed because the \ntemporary type may change in the course of time. Enforce\u00adment of this invariant is trivial for explicit \ntype casts in the program code. However, there are situations when we have to cast a CR to its temporary \ntype: Consider a class A with a .eld b of type B. At runtime, an instance of BSub, a subtype of B, is \nassigned to b and A makes a call b<-m() to this object. The method m() of B is overridden in BSub. This \nmeans that we execute the method m() of BSub and the actual value of this is the CR a<-b with static \ntype B. However, the type of this has to be (at least) the type of the corresponding class because otherwise \nfeatures that are introduced in BSub could not be called. These casts to the temporary type are the cause \nthat under certain conditions the naive algorithm for creating an object path o0<-o1<-...<-on fora CR \no<-v1<-...<-vn, namely o0 =o and oi =oi-1.vi, fails. Fig. 22 shows three di.erent scenarios that lead \nto type errors if the naive algorithm is employed. In the .rst scenario, the algorithm fails because \nthe new object in b no longer contains a .eld c when the q() method of o is called. In the second one, \nthe Other instance expects its reference to be of type BSub, but the new value for b is an instance of \nB. In the last scenario, the CR that constitutes this during the execution of BSub::m() is changed while \nthe method is still on the call stack. Some of these problems also occur in delegation-based sys\u00adtems \nand di.erent solutions have been proposed (see [19] for an overview). However, most of these approaches \ndo not really .t in our model, because all .elds are the potential targets of CRs, so that trivially \ntype safe restrictions like requiring the new value of a .eld to be a subtype of the dynamic type of \nthe previous object are not practicable. Instead, we present a dispatch algorithm that guarantees static \ntype safety while preserving the unrestricted program\u00adming model. The main idea of our approach is as \nfollows: On every cast to the temporary type of a CR, we store the current .eld value in the CR. This \noriginal value is used whenever the current value would lead to a type error. For the de.nition of this \nalgorithm, we choose a recursive representation of CR: A CR is either a primitive reference or a pair \nparent<-v such that parent is a CR and v a .eld name. We call a CR that has been casted to its temporary \ntype (or a supertype of the temporary type that is not a supertype of the static type) a critical CR. \nA critical CR is a triple parent<-v | s such that s is the stored .eld value. Please note that due to \nthe recursive construction parent may already be a critical CR. A non-critical CR is converted to a critical \nCR by storing the current value of the .eld in s. This conversion (think of the CR as being passed by \nvalue ) takes place whenever the CR is subject to an implicit downcast to its temporary type. The decision \nwhether the current or the stored .eld value is used is based on an ad\u00additional parameter, the requested \ntype reqT ype, that de.nes which type is expected in the actual context. For a CR ref, reqT ype is the \ndeclared type of ref. In the following, Cv denotes the class in which the .eld v is de.ned. For non\u00adcritical \nCR, the object path is created as follows: objectP ath(parent<-v, reqT ype) := objectP ath(parent, Cv \n)<-tail(parent<-v, reqT ype) tail(parent<-v, reqT ype) := tail(parent, Cv ).v Except for the additional \nreqT ype parameter, this algorithm is equivalent to the non-recursive description oi =oi-1.vi. In the \ncritical case, the reqT ype parameter comes into play: tail(parent<-v | s, reqT ype) := if tail(parent, \nCv ).v instanceof reqT ype then tail(parent, Cv ).v else s An induction proof on the length of CR shows \nthat this algorithm preserves type safety. It su.ces to proof that the type of the object that is returned \nby the tail function is always a subtype of reqT ype. For CRs of length one (that is, primitive references) \nthe claim holds because the base language (without CR) is assumed to be statically type safe. Let ref \nbe a CR with length n and declared type T. Then ref may be a critical or a non-critical CR. 1. ref is \nnon-critical. Let ref = parent<-v. T = reqT ype is a supertype of the static type of ref be\u00adcause otherwise \nref would be critical. By induction hypothesis, the type of tail(parent, Cv ) is a subtype of Cv , so \nthat the .eld value v, ov can be safely retrieved. Subtyping guarantees that this object is a subtype \nof the declared type of v, and therefore also a subtype of reqT ype. 2. ref is critical. Let ref = parent<-v \n| s. By induction hypothesis, the type of tail(parent, Cv ) is a subtype of Cv , so that the .eld value \nv, ov can be safely retrieved. The if statement guarantees that ov is returned if and only if it is an \ninstance of reqT ype. If this is not the case, s is returned, so we have to show that s is a subtype \nof reqT ype. This is assured by the rule that a critical CR is created and initialized whenever a non\u00adcritical \nCR is casted to its temporary type because this implies that during the assignment of ref s has been \n(and is) a subtype of the static type of ref.  Applied to the scenarios in Fig. 22 this means that in \nsce\u00adnario 1, the reference c in o is critical, and the call to dan\u00adger() in Other::q() is dispatched \nvia the original object path bs<-c. This is also the case in scenario 2 and 3: The reference bs in o \nresp. this in bs is critical and the danger() call is dispatched via the original object path a<-bs. \nWe have shown that our dispatch algorithm renders the model statically type-safe. However, a price has \nto be paid: Although this happens only under very special conditions, it is an undesirable complication \nof the model that the in\u00advariant that all calls to a CR are always dispatched to the current object of \nthe corresponding .eld does not hold any\u00admore. We think that the reason for these problems is the existence \nof a magic triangle between (a) type safety, (b) expressive power, and (c) easy semantics. In our proposal, \nwe put the emphasis on (a) and (b) and got some problems with (c).  6. RELATED WORK Delegation appeared \n.rst in untyped, prototype-based lan\u00adguages [20]. The most prominent example in this category is Self \n[32]. As shown in Table 1, delegation includes all composition properties simultaneously; applying individual \nproperties independently is not explicitly supported. More recent proposals have been proposed to restrain \nthe extreme .exibility o.ered by Self and a number of related proposals by embedding delegation in a \nstatically typed lan\u00adguage. The Darwin model [18, 19] combines delegation and static inheritance in a \nstatically typed language. Darwin already incorporates a limited variant of composition prop\u00aderty separation: \nBesides delegation and inheritance, Dar\u00adwin also has the notion of consultation, which, in our ter\u00adminology, \ncorresponds to delegation without redirection. Generic wrappers [4] support a restricted variant of del\u00adegation: \nOnce a wrappee is assigned to a wrapper , the wrappee is .xed. In our terminology, this corresponds to \ndel\u00adegation with semi-dynamic polymorphism (parent .xed at runtime), and in our model would be expressed \nby declar\u00ading the corresponding attribute as final. B\u00a8uchi and Weck [4] emphasize the importance of being \nable to dynamically cast a wrapper to the dynamic type of its wrappee (trans\u00adparency). In our model, \nthis could be achieved by allowing explicit dynamic casts to the temporary type of a CR, which is not \nproblematic, when the attributes are annotated fi\u00adnal. However, further details on this aspect have been \nleft out of the scope of this paper. gbeta [11] also has a number of dynamic features that are related \nto delegation. Like in Generic Wrappers, parents in gbeta are .xed at runtime. gbeta also allows dynamic \nbehavior additions to objects that preserve object identity, for example a statement like aClass##->anObject## \nadds the structure of aClass to anObject. Another delegation\u00adbased approach is described in [28]. Steyaert \nand De Meuter propose a variant of delegation in which a class has to an\u00adticipate all its possible extensions \nin order to avoid certain encapsulation problems. Compared to these approaches to supporting delegation \nin a statically typed language, delegation, in our model, comes out as a special mixture of composition \nproperties, among many other possible mixtures. In addition, our model is more .exible in that in contrast \nto the aforementioned ap\u00adproaches, objects do not have a single special parent at\u00adtribute. In our model \nit is possible to override and redirect multiple arbitrary attributes. Predicate objects [10], Rondo \n[21], and the context relationship [27] allow the programmer to express certain kinds of context-dependent \nfacets of an object by explicit linguistic means. The composition of the basic behavior of an object \nand its facets obeys delegation semantics in [10, 27], and some form of mixin-based inheritance in [21]. \nOur model shares with these approaches the support for a two-dimensional incremental modi.cation: (1) \nvertically by means of inheritance in our model, Rondo, and con\u00adtext relationship, respectively by means \nof delegation in predicate objects, and (2) horizontally by means of an advanced form of delegation in \n[10], an advanced form of in\u00adheritance that supports the static/dynamic polymorphism property in [21, \n27], and by means of CRs in our model. However, in [10, 21, 27] the composition .avors in both axes are \nbuilt in; individual composition properties are not ex\u00adplicitly available for on-demand combination. \nMixin-based inheritance [7, 12, 2] is an enrichment of normal inheritance with the static polymorphism \nfeature of Tab. 1. In contrast to the normal inheritance, the super pseudo-variable of a subclass is \nnot bound to a certain base class when the subclass is de.ned. Rather, there is an ex\u00adplict composition \nstage, where super is statically bound to a composition-speci.c superclass. In this way, the same sub\u00adclass \n(mixin) can be statically applied to several base classes. However, inheritance enhanced with static \npolymorphism is the only composition .avor supported. Jigsaw [8] improves the modularity of the original \nmixin\u00adbased inheritance [7] by providing a suite of language opera\u00adtors that independently control several \nroles that classes play in standard languages such as combination of features, mod\u00adi.cation, encapsulation, \nname resolution, and sharing. This untangling of class composition semantics is in its core very similar \nto our untangling of standard composition seman\u00adtics. The motivation for undertaking these untanglings \nis di.erent, though. The main focus in Jigsaw is on .ne-grain control over the visibility of the features \nfrom the individual modules in a composition, to allow mixins, multiple inher\u00aditance, encapsulation, \nand strong typing to be combined in cohesive manner. The .exible control over the method dispatch via \n.lters at\u00adtached to an object complemented by the ability to de.ne di.erent factes of an objects in so-called \ninternal and ex\u00adternal objects supported by the composition filters ap\u00adproach [1] can probably also be \nused to simulate some of the .avors of composition semantics that can be expressed in our model. Still, \nthere are important di.erences between the two models. First, the composition filters approach lacks \na static type system. Second, di.erent .avors of com\u00adposition semantics need to be manually implemented \nin dif\u00adferent dispatch .lters. This might turn out to be a tedious end error-prone activity, especially \nif several internals and mixtures of composition properties are involved. In contrast, the speci.cation \nof the desired semantics is more declarative in our model. Third, it is not obvious how redirection se\u00admantics \ncould be programmed with dispatch .lters. Our notions of .eld methods and .eld navigation share some \ncommonality with the as-expressions of the point of view notion of multiple inheritance [9] in that they \nallow to adapt and combine multiple classes without su.er\u00ading from multiple inheritance con.icts. However, \ndue to the use of object rather than class composition, our approach is more .exible when coping with \nissues such as sharing and duplicating the features of common parents, typical for ap\u00adproaches to multiple \ninheritance. 7. SUMMARY AND FUTURE WORK In this paper, we showed that the traditional object-oriented \ncomposition mechanisms, object composition and inher\u00aditance/delegation, are frequently inappropriate \nto model non-standard composition scenarios. Non-standard compo\u00adsition semantics are simulated by complicated \narchitectures that are sensitive to requirement changes and cannot easily be adapted without invalidating \nexisting clients. This un\u00adsatisfactory situation is due to the fact that the combination of composition \nproperties supported by each mechanism is .xed in the language implementation and individual prop\u00aderties \ndo not exist as abstractions at the language level. We proposed compound references as a new and powerful \nab\u00adstraction for object references. On this basis, we were able to provide explicit linguistic means \nfor making individual com\u00adposition properties available and to allow the programmer to express a seamless \nspectrum of composition semantics in the interval between object composition and inheritance. The model \nis statically type-safe and makes object-oriented programs more understandable, due to explicitly expressed \ndesign decisions, and less sensitive to requirement changes. Two issues that have already been worked \nout but have been omitted due to space reasons are as follows: First, there is a well-known con.ict between \ndelegation and method header specialization [4, 19]. Second, the concept of abstract classes and abstract \nmethods is also useful for object-based overrid\u00ading. Statically safe solutions to both problem are proposed \nin [24]. There are some areas of future work. First, the .ne-grained scale between object composition \nand inheritance renders the common visibility modi.ers public and protected too coarse, so that a more \nsophisticated visibility concept is de\u00adsirable. Such a re.ned visibility concept may also solve en\u00adcapsulation \nproblems as described in [28]. Another interest\u00ading area is to investigate the space of possible composition \nproperty combinations for invalid combinations, which need to be rejected at compile-time. Finally, an \ninteresting ex\u00adtension of the CR concept would be to also allow CRs to dictionary entries, so that the \ndictionary keys take the roles of .eld names, and the corresponding values the role of .eld values. \n8. ACKNOWLEDGMENTS We thank Frank Buschmann, Lutz Dominick, Bernd Freisleben, Stephan Herrmann, G\u00a8unter \nKniesel, Markku Sakkinen and the anonymous reviewers for helpful com\u00adments.  9. REFERENCES [1] M. Aksit, \nK. Wakita, J. Bosch, L. Bergmans, and A. Yonezawa. Abstracting object interactions using composition \n.lters. In R. Guerraoui, O. Nierstrasz, and M. Riveill, editors, Object-Based Distributed Programming. \nSpringer, 1993. [2] D. Ancona, G. Lagorio, and E. Zucca. Jam -a smooth extension of Java with mixins. \nIn Proceedings ECOOP 2000, pages 154 178. LNCS, Springer, 2000. [3] K. Arnold and J. Gosling. The Java \nProgramming Language. Addison-Wesley, 1996. [4] M. B\u00a8uchi and W. Weck. Generic wrappers. In Proceedings \nof ECOOP 2000, LNCS 1850, pages 201 225. Springer, 2000. [5] K. Beck, M. Fowler, and J. Kohnke. Planning \nExtreme Programming. Addison-Wesley, 2000. [6] D. Box. Essential COM. Addison-Wesley, 1997. [7] G. Bracha \nand W. Cook. Mixin-based inheritance. In Proceedings OOPSLA/ECOOP 90, ACM SIGPLAN Notices 25(10), pages \n303 311, 1990. [8] G. Bracha and G. Lindstrom. Modularity meets inheritance. In Proceedings of IEEE Computer \nSociety International Conference on Computer Languages, pages 282 290, Washington, DC, April 1992. IEEE \nComputer Society. [9] B. Carr\u00b4e and J. Geib. The point of view notion for multiple inheritance. In Proceedings \nOOPSLA/ECOOP 90, pages 312 321. ACM SIGPLAN Notices, vol. 25 no. 10, 1990. [10] C. Chambers. Predicate \nclasses. In W.Oltho., editor, Proceedings ECCOP 93, LNCS 707, pages 268 297. Springer, 1993. [11] E. \nErnst. gbeta -a language with virtual attributes, Block Structure, and Propagating, Dynamic Inheritance. \nPhD thesis, Department of Computer Science, University of Aarhus, Denmark, 1999. [12] M. Flatt, S. Krishnamurthi, \nand M. Felleisen. Classes and mixins. In ACM Symp. on Principles of Programming Languages 98, pages 171 \n183, 1998. [13] M. Fowler. Refactoring -Improving the Desing of Existing Code. Addison-Wesley, 1999. \n[14] E. Gamma. Extension object. In R. Martin, D. Riehle, and F. Buschmann, editors, Pattern Languages \nof Program Design, pages 79 88. Addison-Wesley, 1998. [15] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. \nDesign Patterns. Addison Wesley, 1995. [16] W. Harrison, H. Ossher, and P. Tarr. Using delegation for \nsoftware and subject composition. Technical Report RC 20946(92722), IBM Research Division T.J. Watson \nResearch Center, Aug 1997. [17] F. J. Hauck. Inheritance modeled with explicit bindings: An approach \nto typed inheritance. In Proceedings OOPSLA 93, ACM SIGPLAN Notices, 1993. [18] G. Kniesel. Type-safe \ndelegation for run-time component adaptation. In R. Guerraoui, editor, Proceedings of ECOOP 99, LNCS \n1628. Springer, 1999. [19] G. Kniesel. Dynamic Object-Based Inheritance with Subtyping. PhD thesis, University \nof Bonn, Institute for Computer Science III, 2000. [20] H. Liebermann. Using prototypical objects to \nimplement shared behavior in object-oriented systems. In Proceedings OOPSLA 86, ACM SIGPLAN Notices, \n1986. [21] M. Mezini. Dynamic object evolution without name collisions. In Proceedings ECOOP 97, LNCS \n1241, pages 190 219. Springer, 1997. [22] M. Mezini. Variational Object-Oriented Programming Beyond Classes \nand Inheritance. Kluwer Academic Publisher, 1998. [23] Object Management Group. CORBA Components Final \nSubmission. OMG TC Document orbos/99-02-05, 1999. [24] K. Ostermann. Object-Oriented Composition: An \nAnalysis and a Proposal. Master s thesis, Universit\u00a8at Bonn, Institut f\u00a8ur Informatik III, 2000. [25] \nM. Sakkinen. Disciplined inheritance. In Proceedings ECOOP 89, pages 39 56. Cambridge University Press, \n1989. [26] D. Schmidt, M. Stal, H. Rohnert, and F. Buschmann. Pattern-Oriented Software Architecture \nVol. 2. Wiley, 2000. [27] L. Seiter, J. Palsberg, and K. Lieberherr. Evolution of object behavior using \ncontext relations. In D. Garlan, editor, Proceedings of the 4th ACM SIFSOFT Symposium on Foundations \nof Software Engineering, pages 46 56. ACM Press, 1996. Software Engineering Notes 21(6). [28] P. Steyaert \nand W. D. Meuter. A marriage of class\u00adand object-based inheritance without unwanted children. In W. Oltho., \neditor, Proceedings of ECOOP 95, pages 127 144. LNCS 952, Springer, 1995. [29] Sun Microsystems. Java \n2 SDK Documentation. http://java.sun.com/j2se/1.3/docs/index.html. [30] C. Szyperski. Component Software \n Beyound Object-Oriented Programming. Addison-Wesley, 1998. [31] A. Taivalsaari. On the notion of inheritance. \nACM Computing Surveys, 28(3):439 479, 1996. [32] D. Ungar and R. Smith. Self: The power of simplicity. \nIn Proceedings of OOPSLA 87, ACM SIGPLAN Notices 22(12), pages 227 242, 1987.  \n\t\t\t", "proc_id": "504282", "abstract": "Object-oriented languages come with pre-defined composition mechansims, such as inheritance, object composition, or delegation, each characterized by a certain set of composition properties, which do not themselves individually exist as abstractions at the language level. However, often non-standard composition semantics is needed, with a mixture of composition mechanisms. Such non-standard semantics are simulated by complicated architectures that are sensitive to requirement changes and cannot easily be adapted without invalidating existing clients. In this paper, we propose <i>compound references</i>, a new abstraction for object references, that allows us to provide explicit linguistic means for expressing and combining individual composition properties on-demand. The model is statically typed and allows the programmer to express a seamless spectrum of composition semantics in the interval between object composition and inheritance. The resulting programs are better understandable, due to explicity expressed design decisions, and less sensitive to requirement changes.", "authors": [{"name": "Klaus Ostermann", "author_profile_id": "81100028971", "affiliation": "Siemens AG, Corporate Technology SE 2, D-81730 Munich, Germany", "person_id": "PP14022906", "email_address": "", "orcid_id": ""}, {"name": "Mira Mezini", "author_profile_id": "81100583946", "affiliation": "Darmstadt University of Technology, D-64283 Darmstadt, Germany", "person_id": "P201627", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/504282.504303", "year": "2001", "article_id": "504303", "conference": "OOPSLA", "title": "Object-oriented composition untangled", "url": "http://dl.acm.org/citation.cfm?id=504303"}