{"article_publication_date": "10-01-2001", "fulltext": "\n On Objects and Events* Patrick Th. Eugster Distributed Programming Laboratory Swiss Federal Institute \nof Technology in Lausanne CH-1015, Switzerland  patrick.eugster@ep..ch Rachid Guerraoui Distributed \nProgramming Laboratory Swiss Federal Institute of Technology in Lausanne CH-1015, Switzerland  rachid.guerraoui@ep..ch \n  Christian Heide Damm Department of Computer Science University of Aarhus 8200 Aarhus N, Denmark  \ndamm@daimi.au.dk ABSTRACT This paper presents linguistic primitives for pub\u00adlish/subscribe programming \nusing events and objects. We integrate our primitives into a strongly typed object\u00adoriented language \nthrough four mechanisms: (1) seri\u00adalization, (2) multiple subtyping, (3) closures, and (4) deferred code \nevaluation. We illustrate our primitives through Java, showing how we have overcome its respective lacks. \nA precompiler transforms statements based on our publish/subscribe primitives into calls to speci.cally \ngenerated typed adapters, which resemble the typed stubs and skeletons generated by the rmic precompiler \nfor remote method invocations in Java. Categories and Subject Descriptors C.2 [Computer Systems Organization]: \nComputer Communication; C.2.4 [Computer Communication Networks]: Distributed Systems distributed applica\u00adtions; \nD.3 [Software]: Programming Languages; D.3.3 [Programming Languages]: Language Constructs and Features \nconcurrent programming structures General Terms Distributed Programming Keywords Java, type, publish/subscribe, \nevent, linguistic support * This work is partially supported by Agilent Laboratories and Lombard Odier \n&#38; Co. Christian is currently visiting the Swiss Federal Institute of Technology in Lausanne. Permission \nto make digital or hard copies of part or all of this work or personal or classroom use is granted without \nfee provided that copies are not made or distributed for profit or commercial advantage and that copies \nbear this notice and the full citation on the first page. To copy otherwise, to republish, to post on \nservers, or to redistribute to lists, requires prior specific permission and/or a fee. OOPSLA 01 Tampa \nFlorida USA Copyright ACM 2001 1-58113-335-9/01/10 $5.00 1. INTRODUCTION 1.1 RPC et al. One of the most \npopular styles of distributed program\u00adming relies on extending the notion of invocation to a dis\u00adtributed \ncontext, i.e., o.ering some form of remote procedure call (RPC) [7]. The integration of this distributed \ninterac\u00adtion style with an object-oriented programming language has been thoroughly studied, e.g., [41, \n11, 42, 10]. More recently, Java [29] has introduced its own variant, the re\u00admote method invocation (RMI) \n[61], through a precompiler approach. By using the same abstraction for distributed interactions as for \nlocal ones, RPC and its derivatives integrate naturally with a language, and make distributed programming \nlook simple. 1.2 Publish/Subscribe Motivated by the observation that RPC is not always the best solution, \nthe integration of alternative distributed in\u00adteraction styles, like asynchronous RPC (e.g., [65, 43]) \nor the tuple space [28] paradigm (e.g., [45]) with a language have also been studied. More recently, \nOki et al.[50] have pointed out the existence of many distributed event-based applications for which \na publish/subscribe interaction style is very appealing, thanks to its strong decoupling of partic\u00adipants \nin (1) time (participants don t have to be up at the same time), (2) space (participants don t have to \nknow each other), and (3) .ow (data reception/sending does not block participants). Several authors suggested \nlibraries for distributed inter\u00adaction based on publish/subscribe (e.g., JavaSpaces [27], SmartSockets \n[16], Distributed Asynchronous Collections [24]), also implementing standardized API s (CORBA Event &#38; \nNoti.cation Services [53, 51], Java Message Service [31], etc.), but to our knowledge, very little e.ort \nhas been done to inherently support publish/subscribe in a language. 1.3 Linguistic Support for Publish/Subscribe \nThe goal of this paper is precisely to explore the rami\u00ad.cations of integrating publish/subscribe primitives \ninto a strongly typed object-oriented language.1 1The goal of this paper is not to advocate for a library \nvs an integration approach in the case of publish/subscribe, Our linguistic primitives have been designed \nbased on four simple principles:2 LP1 Type safety. In a strongly typed language, strong typ\u00ading is enforced \nin local interactions, and as far as possi\u00adble, should also be enforced for remote object interaction. \nType errors should be recognized at compilation, allevi\u00adating the already cumbersome debugging of distributed \napplications. LP2 Encapsulation preservation. Events are to be consid\u00adered as objects, and hence as instances \nof abstract types. Their implementation details should not be revealed, and should not be systematically \nused to describe subscription criteria. LP3 Application-de.ned events. Events should be de.nable by the \napplication, with minimal imposed design choices. LP4 Composable event semantics. To express some form \nof Qualities of Service (QoS), di.erent semantics should be assignable to events, and these semantics \nshould be composable. Combining these principles is not straightforward. For in\u00adstance, combining (1) \ncontent-based subscription based on event properties and (2) preservation of encapsulation of event objects \n(i.e., not systematically expressing subscrip\u00adtions as attribute-value pairs, ruling out any query languages \nsuch as SQL) is already commonly pictured as a contradic\u00adtion per se [38]. Further complexity is added \nby requiring (3) transparency of subscriptions, i.e., giving the underlying publish/subscribe system \nfull access to subscription crite\u00adria in order to optimize the .ltering of events (e.g, by fac\u00adtoring \nout redundancies between subscriptions of di.erent subscribers [1]). 1.4 Contributions We present two \nlanguage primitives for the expression of type-based publish/subscribe programming: publish and subscribe. \nInstead of introducing a new programming language, we illustrate our three primitives through the well-known \ngeneral-purpose Java language. Along the way, we identify a set of four mechanisms, which provided by \na language, strongly enforce its support for publish/subscribe; roughly serialization, multiple subtyping, \nclosures, and deferred code evaluation. These are however not to be viewed as su.cient nor as necessary \nconditions, as shown by Java, which does not incorporate all these mechanisms. Our solution for the Java \nlanguage relies on a precompiler, which transforms our speci.c constructs to invocations on speci.cally \ngenerated typed adapters. In that sense, our precompiler can be seen as the pub\u00adlish/subscribe counterpart \nto the Java RMI compiler, and we but rather to explore the rami.cations of an integration ap\u00adproach (see \nSection 7). 2These principles have resulted from our previous expe\u00adriences around objects and publish/subscribe \n(e.g., [24, 22]), including applications we have helped devising in the domains of banking and telecommunications. \nObviously, these principles are not exclusive; other application domains might identify di.erent requirements. \n show that the two interaction paradigms are in fact not con\u00adtradictory, but that a combination of these \ntwo paradigms can be seen as a powerful tool for devising distributed ap\u00adplications. 1.5 Status Our \nprimitives were implemented using the infrastructure o.ered by the Distributed Asynchronous Computing \nEnvi\u00adronment (DACE). This infrastructure has already been the base for a library approach to integrating \npublish/subscribe with Java [24, 22] along similar principles, making however use of other mechanisms \nto their achievement, namely re\u00ad.ection and parametric polymorphism together with serial\u00adization. The \ngoal of this paper is to emphasize language issues, leaving aside issues related to distribution; the \nimplemen\u00adtation of our distributed architecture, its underlying algo\u00adrithms and their performance and \nscalability have been ad\u00addressed in other publications, e.g., [23, 21]. Supported by our two complementary \napproaches, we be\u00adlieve that the current work is not intrinsically tied to our architecture, but could \nbe deployed on most existing pub\u00adlish/subscribe systems. 1.6 Roadmap This paper is structured as follows: \nSection 2 introduces the type-based publish/subscribe variant which has allowed us to combine objects \nand events. Section 3 discusses the se\u00admantics of our primitives and their syntax in Java. Section 4 \npresents the implementation of our primitives. Section 5 discusses several issues, like design alternatives. \nSection 6 discusses related work. Section 7 concludes this paper.  2. TYPE-BASED PUBLISH/SUBSCRIBE This \nsection introduces our model of events and objects, and the type-based variant of publish/subscribe intrinsically \ncoupled with that model. We depict the e.ects of subscrib\u00ading to types in Java, and give a rough idea \nof our primitives for publish/subscribe interaction along with a simple exam\u00adple. 2.1 Model The core \nidea underlying our integration of pub\u00adlish/subscribe with objects consists in viewing events as .rst \nclass citizens, and subscribing to these events by explicitly specifying their type. 2.1.1 Obvents By \nconsidering events as .rst class citizens, that is, not as speci.c constructs (e.g., [30]), but as speci.c \napplication\u00adde.ned objects, we strongly enforce the support of LP3. To emphasize the object nature of \nevents, we call these event objects, or to abbreviate notation, simply obvents. Similarly to [50], we \ndistinguish mainly between two categories of objects, but introduce two further (sub)categories. Unbound \nobjects: Unbound objects are locality-unbound, that is, their semantics do not depend on any local resource. \nSuch objects could be serialized and transferred to another address space (in [50] these are termed data \nobjects). Obvents: Obvents represent a speci.c kind of unbound objects. Such objects are used to notify \nevents, and can in a nested way contain other unbound objects Bound objects: These objects are locality-bound, \ni.e., they are tied to an address space and remain in that address space during their entire lifetime. \nThey may make use of local resources (service objects in [50]). Subscribers: Potentially, any bound object \ncould take the role of subscriber, but in general, only particular ob\u00adjects subscribe to obvents. An \nobvent class can best be pictured as a factory for in\u00adstances incarnating noti.cations for events of \nthe same kind, i.e., from the same event source. A noti.cation from such an event source is rei.ed through \nan obvent; basically an object which is serialized and sent over the wire to a set of destinations, where \neach copy is deserialized. Note that we do not introduce a speci.c publisher type. Any object (bound \nbut also unbound) can publish obvents. The subscribers introduced will mainly be used for illustra\u00adtion \npurposes. As we will see shortly, the application will not be explicitly dealing with such objects, but \nwill view these as obvent handlers, or simply handlers. 2.1.2 Effects of Publishing Obvents Publishing \nan obvent o can thus be understood as some form of distributed object creation, where the created ob\u00adjects \nare clones of o which acts as template. More precisely, a distinct copy of a published obvent is created \nfor each subscriber: Obvent Global Uniqueness: Suppose an obvent o1 published from an address space a1: \nif an address space a2 contains two subscribers s1 and s2, these will receive references to two new distinct \nclones of o1, say o2 and o3. Obvent Local Uniqueness: In the above scenario, if the ad\u00address space a1 \nalso contains a subscriber s3, then s3 will receive a reference to a new obvent o4. A subscription can \nin that sense be seen as a contract for hosting objects created as copies of published objects. Note \nthat if the same obvent is published twice, two distinct copies will be created again for every subscriber. \n 2.1.3 Type-Based Subscription By using the type of obvents as basic subscription criterion, we strongly \nenforce the integration of pub\u00adlish/subscribe interaction into a language in a way that respects type \nsafety (LP1 ): by matching the notion of event kind with that of an event type, i.e., using the type \nscheme of the programming language as subscription scheme, the type of the received events is known, \nand compile-time type checks can be performed. Figure 1 illustrates the intuitive idea underlying our \nap\u00adproach, through a recurring example for publish/subscribe interaction, which is the stock trade application. \nA possible scenario is the following. The stock market, here denoted by p1, publishes stock quotes, and \nreceives purchase requests. These can be spot price requests, which have to be satis\u00ad.ed immediately, \nor market price requests for purchasing quotes only at the end of the day, or once another given cri\u00adterion \nis ful.lled. Latter requests can however expire, and for the broker s (such as p2) convenience, an intermediate \nparty (p3), e.g., a bank, might also handle such requests in behalf of her/him, for instance by issuing \nspot price requests to the stock market once the broker s criterion is satis.ed. Note that by subscribing \nto a type StockObvent, p3 receives all instances of its subtypes StockQuote and StockRequest, and hence \nall objects of type SpotPrice and MarketPrice. Figure 1: Type-based publish/subscribe  2.2 Type-Based \nPublish/Subscribe in Java In many strongly typed object-oriented languages like C++ [19] or Ei.el [46], \nthe inheritance hierarchy determines the conformance (subtype) relation. In such type schemes, the notions \nof type (abstract type, type de.nition, interface, signature) and class (concrete type, type implementation) \nare identical. The Java type system is inspired by the separation of in\u00adheritance and subtyping in the \nsense of [15]. To avoid prob\u00adlems known from multiple inheritance, Java o.ers only single inheritance, \nyet introduces multiple subtyping through in\u00adterfaces. In Java, types can be de.ned in the following \ntwo ways: Explicit declaration: A type can be explicitly declared by declaring an interface, which can \nsubtype several super\u00adinterfaces: an interface I1 which extends another interface I2 represents a subtype \nof the type declared by I2. Implicit declaration: De.ning a class C implicitly declares a type, and at \nthe same time gives the class which imple\u00adments it. If a class C1 inherits from another class C2, then \nthe type de.ned by C1 is a subtype of the type of C2. A class can subtype multiple interfaces: for any \ninterface I implemented by a class C, the type de.ned by C is a subtype of I. Note that a class C which \nimplements a single interface I without adding any new methods also de.nes a new type, which is a subtype \nof I s type. As a consequence of the intertwining of types and classes in Java, it must be possible to \nsubscribe to interfaces as well as to classes. 2.3 Expressing Type-Based Publish/Subscribe To express \nevent-based distributed interaction based on the type-based publish/subscribe paradigm, we introduce \ntwo primitives. We give here an abstract overview of these, and give more details in Section 3. 2.3.1 \nPublishing An obvent o is published through a primitive publish, leading to the simple syntax: publish \no; This statement triggers the creation of a copy of o for every subscribed object, according to the \nrules described before\u00adhand. In that sense, the publish primitive can be seen as a distributed variant \nof the new primitive found in many languages. Syntactically, the publish primitive bears more resemblances \nwith the very common return primitive, or the throw primitive for the raising of an exception in Java. \n 2.3.2 Subscribing In attempt to satisfy LP1, LP2, and LP4, we chose the obvent type as the basic subscription \ncriterion. A pure static subscription scheme, like topics (e.g., [50, 59, 2, 16, 64], also called subjects) \nor types in our case, has been shown to o.er only limited expressiveness. This observation has motivated \ncontent-based publish/subscribe (e.g., [1, 17, 12, 58], also called property-based publish/subscribe), \nwhere a subscrip\u00adtion takes properties of obvents into consideration. When subscribing, the desired properties \nare expressed through a predicate, or .lter. We thus combine a subscription to a type T with the declaration \nof such a .lter: Subscription s = subscribe (T t) {...} {...}; The .rst expression enclosed in brackets \nrepresents a block, provided by the application, which expresses how to handle obvents of type T (represented \nby a formal argument called t here) in order to return a boolean value indicating whether the obvent \nis of interest or not. The second expression is a block which is evaluated every time an event successively \npasses the .ltering phase, and corresponds thus to the sub\u00adscriber object. The same formal argument t \nrepresents the event of interest in this case. A subscription handle is re\u00adturned by a subscription expression. \nIt allows, among other things, the activation and deactivation of a subscription. The motivation of capturing \nthe code for .ltering in a closure is to delay its evaluation: to avoid redundant .lter\u00ading, as well \nas wasting network bandwidth, it is interesting to apply .lters on foreign hosts, which are possibly \nentirely dedicated to .ltering. By gathering .lters of several sub\u00adscribers on a given host, a compound \n.lter can be generated which factors out redundancies between these individual .l\u00adters. By doing so, \nperformance can be signi.cantly improved (e.g., [1]). The use of a closure also to capture the code applied \nfor the evaluation of received events enables the avoiding of a callback mechanism, which greatly enforces \ntype safety and has the great advantage of regrouping code related to a sub\u00adscription in a single succinct \nexpression. Note that one can easily subscribe to all obvents of a type T by doing something like the \nfollowing: Subscription s = subscribe (T t) { return true; } {...}; 2.3.3 Example Consider the stock \nmarket example introduced above. Stock quotes are published by the stock market, and are received by \nbrokers. Stock quotes carry a set of attributes, like the amount and price of the stock quotes. Figure \n2 shows the Java code for simple stock quotes and stock quote subscribers. The stock market can publish \na stock quote obvent by doing something like the following: StockQuote q = new StockQuote(\"Telco Mobiles\", \n80, 10); publish q; Below, we give an example of a subscription, which ex\u00adpresses an interest in all \nstock quotes of the Telco group with a price less than 100$: Subscription s = subscribe (StockQuote q) \n{ return (q.getPrice() < 100 &#38;&#38; q.getCompany().indexOf(\"Telco\") != -1); } { System.out.print(\"Got \noffer: \"); System.out.println(q.getPrice()); }; It can easily be seen that the stock quote published \nin the above example satis.es these criteria.  3. JAVAPS This section illustrates mechanisms which \nstrongly sup\u00adport the implementation of publish/subscribe in a language according to our model. We discuss \nthe syntax and precise semantics of our language primitives, and informally show how these .t into the \nJava language (leading to a new in\u00adstance of StatementWithoutTrailingSubstatement, and a new PrimaryNoNewArray \nexpression, \u00a7 14.5 and \u00a7 15.8 in [29] respectively). We refer to this extension as Javaps. The classes \nand interfaces related to our approach are regrouped in a package java.pubsub. 3.1 Inside Obvents Obvents \nare objects that are serialized, sent over the wire, and deserialized. Java incorporates a default serial\u00adization \nmechanism, which can be exploited by subtyping java.io.Serializable. 3.1.1 Basic Type The basic Java \nObvent type (Figure 3) thus subtypes that type. This eases the implementation of our obvent model in \ngeneral, and we state this as a .rst mechanism which enforces the realization of our model in a language: \n/* stock quote obvents */ public class StockObvent implements Obvent { private String company; private \nfloat price; private int amount; public String getCompany() { return company; } public float getPrice() \n{ return price; } public int getAmount() { return amount; } public StockObvent(String company, float \nprice, int amount) { this.company = company; this.price = price; this.amount = amount; } } public class \nStockQuote extends StockObvent { public StockObvent(String company, float price, int amount) { super(company, \nprice, amount); } } Figure 2: Stock quote noti.cations LM1 Default serialization mechanism. A language\u00adprovided \nserialization/deserialization mechanism eases the transformation of event objects into conveyable low-level \nmessages. This principle strongly supports LP3 : with a default se\u00adrialization mechanism, developers \ncan be relieved from the burden of implementing speci.c operations or hooks in their obvents. The design \nphase of obvents can be cut down to the essential meaning of the event. 3.1.2 Obvent Semantics Obvents \ncan also be viewed as rei.ed messages, or mes\u00adsage objects. According to the di.erent semantics that \nsuch messages can manifest, several semantics are imaginable for obvents. The .rst kind of characteristics \nare the delivery semantics associated with obvents; an expression of quality of delivery. Unreliable: \nWhen such an obvent is published, there is no guarantee that it will be received by any subscriber. There \nis only a best-e.ort attempt to deliver it. This is assumed by default. Reliable: Once successfully published, \na reliable obvent will be received by any subscriber that is up for long enough . A subscriber which \nnever fails will eventually deliver every such obvent. Certi.ed: With such obvents, even if a subscriber \ntemporar\u00adily disconnects or fails, it will eventually deliver the ob\u00advent. Totally ordered: Obvents can \nfurthermore be noti.ed in a total order to the subscribers: roughly spoken, two sub\u00adscribers s1 and s2 \nwhich deliver two obvents o1 and o2 both deliver o1 and o2 in the same order (we also term this subscriber-side \norder). package java.pubsub; import java.io.*; /* obvents */ public interface Obvent extends Serializable \n{...} public interface Reliable extends Obvent {} public interface Certified extends Reliable {} public \ninterface TotalOrder extends Reliable {} public interface FIFOOrder extends Reliable {} public interface \nCausalOrder extends FIFOOrder{} public interface Timely extends Obvent { public long getTimeToLive(); \npublic long getBirth(); } public interface Prioritary extends Obvent { public int getPriority(); } /* \nexceptions */ public abstract class NotificationException extends Exception {...} public class CannotPublishException \nextends NotificationException {...} public class CannotSubscribeException extends NotificationException \n{...} public class CannotUnsubscribeException extends NotificationException {...} /* subscription handle \n*/ public final class Subscription { public void activate() throws CannotSubscribeException; public void \nactivate(long id) throws CannotSubscribeException; public void deactivate() throws CannotUnsubscribeException; \npublic void setSingleThreading(); public void setMultiThreading(int maxNb); ... } Figure 3: Obvents, \nexceptions, and subscriptions FIFO ordered: Two obvents o1 and o2 that are published through the same \nobject are delivered to all objects whose subscription matches both o1 and o2, and in the same order \nthey were published (publisher-side order). Causally ordered: This type of obvents are delivered in the \norder they are published, as determined by the happens\u00adbefore relationship [39]. Note that the notion \nof event in [39] represents either a message send or receive. These translate respectively to the publishing \nand receiving of an obvent in our case (global order). Further semantics, called transmission semantics, \ncan be associated to obvents. These govern the handling of obvents when they are in transit, also with \nrespect to other obvents. Prioritary: Obvents can have priorities, that is, the delivery of obvents can \nbe delayed to defer to obvents with a higher priority. Timely: Similarly, obvents can be delayed to prioritize \nmore recent obvents. Also, obvents might expire, and become obsolete. These di.erent semantics are not \nall mutually exclusive. For instance, obvents can be certi.ed and have some notion of priority, or be \ncerti.ed and totally ordered at the same time. It appears that contradictions reside for instance be\u00adtween \nreliable and simultaneously timely limited obvents, as well as between total, .fo or causal order and \npriorities. In the above cases, the .rst type takes precedence (Figure 4 il\u00adlustrates the dependencies \nbetween the di.erent semantics). Note however that we have not yet explored all possible ram\u00adi.cations \nand combinations, and that the identi.cation and implementation of these semantics is an ongoing task. \nNote also that for any kind of order expressed by an ob\u00advent type, its instances satisfy that order with \nrespect to instances of the same type, its subtypes, and supertypes with that same order only. Figure \n4: Dependencies between obvent semantics 3.1.3 Expressing Obvent Semantics In our model, such characteristics \nare associated with the obvents, and should thus be part of these obvents. Indeed, it makes most sense \nthat every obvent re.ects its semantics (which can be seen as a context), such that a correct han\u00addling \nof the obvent can be assured at every moment of the transfer. Since instances of an obvent type are bound \nto the same obvent source, they present the same characteristics. In addition, the obvent type is the \nonly contract between publishers and subscribers, and we have thus chosen to use subtyping to express \nthis limited form of QoS, mandated by LP4. Figure 3 shows the Java types corresponding to the di.erent \nsemantics outlined above. Since several characteristics can be combined, this scheme requires some mechanism \nof expressing multiple subtyping. LM2 Multiple subtyping. While simple subtyping eases the expression \nand addition of di.erent event semantics, mul\u00adtiple subtyping enforces the composition of such seman\u00adtics. \nThis is independent of whether it is assured through some form of multiple inheritance as o.ered by C++, \nCecil [14] or Ei.el, through subtyping abstract types (e.g., interfaces in Java), or even mixins (e.g., \nFlavors [47], Ada [35]). The term multiple subtyping here simply denotes the ability of expressing multiple \nspecialization relationships.  3.2 The publish Primitive An obvent can be published, which means that \nit will be asynchronously sent to any concerned subscriber. Following the Java language speci.cation \ngrammar [29], based on a LALR(1) syntax, we introduce a new statement: PublishStatement: publish Expression \n; Here Expression is a non-null expression of type Obvent, as opposed to most classes relying on Java \nserialization: in Java, a serializable root type is often faked by using for\u00admal parameters of the root \ntype java.lang.Object, yet ex\u00adpecting an object of a speci.c type java.io.Serializable and throwing an \nexception if the actual argument is not of that type. We prefer detecting such type errors at compi\u00adlation. \nNevertheless, this primitive can throw an exception of type CannotPublishException, signalling any problems \nin transmitting the obvent. Figure 3 summarizes the basic exceptions. 3.3 The subscribe Primitive As \nbrie.y shown in Section 2, we introduce a second prim\u00aditive subscribe, to express a subscription. 3.3.1 \nSyntax A subscription expression combines the subscription to a type T with (1) a closure declaration \nrepresenting a .lter, where the full signature of that .rst closure is the following: boolean (T t) {...} \nand (2) the declaration of a second closure representing the handler, where the full signature is the \nfollowing: void (T t) {...} A subscription expression hence has the following syntax in Java (details \nare given in Figure 5): SubscriptionExpression: subscribe ( ObventType Identi.er ) Block Block ObventType \nrepresents a type which can be widened to the Obvent type, that is, ObventType is a special case of the \nClassOrInterfaceType (\u00a7 4.3 in [29]). The .lter represented by the .rst Block must return an expression \nof type boolean, while the handler returns nothing. The creation of a sub\u00adscription returns an object \nof type Subscription (cf. Fig\u00adure 3). Such a handle uniquely identi.es a subscription on a given host. \nSubscriptionExpression: subscribe SubscriptionDeclaration SubscriptionDeclaration: SubscriptionDeclarator \nFilterBody HandlerBody SubscriptionDeclarator: ( SubscriptionFormalParameter ) SubscriptionFormalParameter: \nObventType Identi.er FilterBody: Block HandlerBody: Block ObventType: ClassOrInterfaceType Figure 5: \nPrecise syntax of subscription statements 3.3.2 Handlers Handlers are very close to the closures known \nfrom Smalltalk (block closure) or Cecil (anonymous function), and represent an intuitive way of handling \ncallbacks from the underlying event dissemination system. In languages like Java, which lack support \nfor closures (or higher order functions [49]), such callbacks are often imple\u00admented by having the application \nprovide a callback object with a callback method. The argument of such a method represents the e.ective \nevent of interest. In Java, an inter\u00adface implemented for callbacks is commonly called a listener. To \nenforce strong typing, the type of the formal argument of a callback method in a listener must conform \nto the type of the event of interest. This can easily be achieved in lan\u00adguages which support parametric \npolymorphism [22], but in any case leads to isolating the event handling in a separate class. The use \nof a closure on the other hand enables the re\u00adgrouping of all code related to a subscription in a single \nsuccinct expression, and since handlers are a speci.c type of closures, a language which already provides \nsome gen\u00aderal form of closures can easily support the integration of subscription expressions. LM3 Closures. \nWith handlers being a speci.c type of clo\u00ad sures, a language which provides general closures supports \nthe expression of safely typed subscription primitives. By viewing these closures as objects, the handlers \ntake the role of the subscriber objects outlined in Section 2. 3.3.3 Filters Akin to handlers, .lters \nare closures with a speci.c signa\u00adture. Besides the concentration of subscription-related code, the use \nof such a syntax in the case of .lters is further con\u00adducted by the desire of con.ning the code for the \n.ltering, while still revealing it. This enables (1) the migration of such code to foreign hosts, as \nwell as (2) the factoring out of redundancies between .lters of di.erent subscribers gathered on individual \nhosts. The compilation of these .lters is hence deferred, in a sense similar to the paradigm of deferred \ncode evalution known from two-level programming [48] (or generalized to more than two levels, multi-stage \nprogramming as advocated by MetaML [63]). LM4 Deferred code evaluation. A mechanism providing some form \nof deferred code evaluation can easily sup\u00adport the expression of safely typed content-based .lters, \nin a way that supports optimizations (avoiding redundant queries) and the checking of the code. 3.3.4 \nRestrictions on Closures Local closures vary in the degree of self-containment they advocate: the .rst \nclass block closure in Smalltalk can use any variables in scope at the closure declaration (at com\u00adpilation), \nand these variables are bound for the entire life\u00adtime of the closure, even if it is executed in a context \nwhere some of these variables are not visible. To avoid some of this binding of variables, an anonymous \nclass in Java can only ac\u00adcess final variables from the enclosing block in addition to the non-local \nvariables (members) in scope at compilation. The handlers described previously adopt these semantics. \nOur distributed use of closures in the case of .lters re\u00adquires even more restrictions. Any variable \nused in a .lter might reference an object (which might reference an object, etc.) of a type which is \nnot known on a host where that .lter is evaluated, forcing the transfer of code. Similarly, any method \ninvocation, whether performed on a variable or as a static call, might force the transfer of further \ncode. In the case of Java, a class can be compiled if the types it uses are present as byte code, and \nit is very di.cult to fore\u00adsee the e.ects of calls to classes based on their byte code. Thus, method \ninvocations (including the use of construc\u00adtors) should be cut down to the essential ones, in order to \navoid .lters using opaque code as well as types unknown on .ltering hosts. Invocations: The only method \ninvocations allowed in a .lter are (nested) invocations on its variables. Variables: The only variables \nallowed in a .lter are (1) the formal argument representing a .ltered obvent, (2) local variables, and \n(3) final outer variables (from the enclos\u00ading block or class members). Latter two types of vari\u00adables \nare restricted to primitive types (e.g., int) and their object-counterparts (e.g., java.lang.Integer), \nincluding java.lang.String. These restrictions enforce the location-independency of the expressed .lter, \no.ering the possibility of applying it at a more favourable stage (e.g., a remote host) to reduce network \nload and .ltering cost. If the .lter declares any local variables of unallowed types, or performs invocations \ndi.ering from the ones described above, its migration might be problematic. In such a scenario, the .lter \nis applied lo\u00adcally (cf. next section). Note that the above restrictions do not fully guarantee the location-independency \nof the .lter, e.g., any Java object referred to by a variable gives access to a meta-object rep\u00adresenting \nits class (java.lang.Class), through which many undesired things can be done. We will come back to this \nparticular case in Section 5. At the present, we are inves\u00adtigating a precise semantical de.nition of \n.lters, aimed at ensuring their mobility . 3.3.5 Thread Policies Once an obvent has reached a process \nhosting an inter\u00adested subscriber, it is delivered by executing the handler. This is comparable to an \nRPC-style invocation of an arbi\u00adtrary method of a bound object, in the sense that the thread which is \nused in that target object s process for the invoca\u00adtion is blocked until completion of that invocation; \nthe main di.erence being that an invocation made in the context of an RPC can yield a reply which is \nsent back to the invoker. There are di.erent levels of concurrency which can be sup\u00adported. In our context, \nwe distinguish between two kinds of thread policies: Multi-threading: A handler can be executed concurrently \nfor any number of obvents. These semantics are assumed by default, except in the case of ordered obvents. \nSingle-threading: A handler never processes more than one obvent at a time. One could easily extend this \nset, for instance by a thread policy ensuring that only one instance of the same obvent class is processed \nat a time. Note that Java already integrates mechanisms for con\u00adcurrency control with which the two above \npolicies can be achieved. To ensure that never more than one obvent is processed at a time by a handler, \none could easily write: final Object lock = new Object(); Subscription s = subscribe (T t) {...} { synchronized(lock) \n{ /* handler */ } }; However, in languages which do not integrate any concur\u00adrency mechanisms, to obtain \nmore sophisticated concur\u00adrency control, or to involve the publish/subscribe system into concurrency \nissues with the goal of optimizing concur\u00adrency, thread policies should be made explicit. In our case, \nit seems most straightforward to express these through the subscription handle, since such an object \nuniquely de.nes a subscription. To control such parameters, corresponding methods are added to the Subscription \ntype shown in Figure 3. In general, the expression of QoS has been probably the most tedious task when \ndevising our language primitives. Such QoS seem to become increasingly important when pro\u00adgramming at \na distributed scale, but there is to our knowl\u00adedge only very little work on how to inherently express \nQoS in a programming language, in an other way than through an API.  3.4 Managing Subscriptions As explained \nabove, the subscribe primitive creates an expression representing a subscription. Such a subscription \nmust then be activated, triggering the e.ective action of sub\u00adscribing, and later on, deactivated, representing \nthe action of unsubscribing. 3.4.1 Activating a Subscription A subscription is activated by a call to \nthe activate() method on the corresponding subscription handle. This method throws a CannotSubscribeException \nexception if the subscription can not be issued, e.g., if the subscription is already activated. Subscription \ns = ...; s.activate(); ... The variant of the activate() method with a long argu\u00adment is used in combination \nwith certi.ed events. Indeed, with such events, the lifetime of subscriptions might exceed the actual \nlifetime of the hosting process. When recover\u00ading from a failure, or reactivating an intentionally deacti\u00advated \nsubscription, the concerned subscription can be (lo\u00adcally) uniquely identi.ed by using this method. \n3.4.2 Deactivating a Subscription Similarly, the action of unsubscribing is expressed through a deactivate() \nmethod de.ned on subscrip\u00adtion handles, which can throw an exception of type CannotUnsubscribeException. \n... s.deactivate(); ... As an immediate consequence, subscriptions can be can\u00adcelled also from inside \na subscription, i.e., its associated handler. This is interesting when a particular event, from the point \nof view of the concerned subscriber, supersedes any following events, or signals the absence of any further \nevents. Since a handler can only handle final variables de\u00adclared in its enclosing block however, the \nvariable that the subscription handle is assigned to must be declared outside of that block, for instance \nas a private attribute of the en\u00adclosing class. The activation/deactivation of subscriptions can be inter\u00adleavingly \nperformed an unlimited number of times. Cor\u00adresponding exceptions are also thrown upon an attempt of \n(de-)activating an already (de-)activated subscription.  4. IMPLEMENTATION ISSUES This section depicts \nhow we have implemented our primi\u00adtives for publish/subscribe interaction in Java in a way that satis.es \nthe principles stated in Section 1. 4.1 General Implementation Choices Along the lines of extensions \nto the Java language like Pizza [49] (adding parametric polymorphism, algebraic types and closures) or \n[8] (for multi-methods), we refrain from incorporating any new features into the Java virtual machine, \nas well as from extending a given compiler, or even modifying existing packages and classes of the Java \nenvironment. Instead, we advocate the use of a precompiler as the publish/subscribe counterpart to the \nrmic compiler for generation of remote invocation proxies [61]. Since remote invocations bene.t from \nan inherent support from the language, they require no speci.c primitives, and hence only remotely invocable \nJava types have to be com\u00adpiled with rmic. Besides generating obvent-speci.c classes, our psc precompiler \ntranslates publish/subscribe statements and expressions to calls to these classes, and must hence be \nrun not only on obvent types, but also on any class making use of our primitives. 4.2 DACE Distributed \nArchitecture The Distributed Asynchronous Computing Environment (DACE) infrastructure has been initially \ndeveloped as a general architecture to support publish/subscribe in\u00adteraction, and has later been specialized \nfor type-based publish/subscribe. The DACE architecture can be roughly pictured as relying on a class-based \ndissemination [22]. Every obvent class is mapped to a dissemination channel, representing a multicast \ngroup, which we refer to as multi\u00adcast class. In the DACE architecture, such multicast classes are then \nimplemented with di.erent multicast protocols with guarantees ranging from strong guarantees (exploiting \na broad variety of primitives from group communication [6], e.g., for causal ordering) to primitives \nwith weaker guarantees but strong focus on scalability (network-level protocols like IP multicast [18] \nor its derivates, e.g., [54, 33, 26], or gossip-based protocols, e.g., [5, 62, 23]). We have adopted \na re.exive approach, by using speci.c channels to disseminate protocol messages, like subscrip\u00adtion/unsubscription \nrequests, or the advertisement of the publishing of obvents. Such messages are obvents them\u00adselves, and \nallow distributed processes to learn about other, possibly new, multicast classes. 4.3 Typed Adapters \nTo avoid making the Java virtual machine distribution\u00adaware, and also to exploit our class-based dissemination, \nwe adopt the adapter [50] concept. Adapters are intermediate entities between the communication system \nand the applica\u00adtion, whose role consists mainly in mediating between events in a serialized representation \nand objects. In our case, adapters mainly mediate between serialized generic objects and strongly typed \nobvents. In other terms, adapters are type-speci.c, and are generated for each ob\u00advent class by the psc \ncompiler. For any given obvent class C psc generates a class CAdapter with code for publish\u00ading/subscribing \ninstances of C. Similarly, to support sub\u00adscriptions to abstract types (interfaces), for any given ab\u00adstract \nobvent type I, psc generates a class IAdapter with code for subscribing to instances of I. Figure 6 illustrates \nan adapter for a given obvent type T. 3 4.4 Translating Primitives With our psc precompiler, publish/subscribe \nstatements and expressions are translated to method invocations. 4.4.1 Publishing Since a published obvent \nis disseminated through the adapter for its dynamic type, which is only known at run\u00adtime, a PublishStatement \ncan not be directly transformed toa call to publish on the corresponding adapter class. Hence, we add \na publish() method to the Obvent interface 3Interestingly, the same parametric polymorphism applied to \nthe .rst class adapters used in our library approach [24], can not be applied here due to the purely \nstatic nature of the adapters. import java.pubsub.*; public final class TAdapter { public static Subscription \nsubscribe(LocalFilter l, Subscriber s) public static Subscription subscribe(RemoteFilter r, Subscriber \ns) /* ifTis aclass*/ public static void publish(T t) throws CannotPublishException {...} ... } Figure \n6: Obvent adapter for a type T in Java (Figure 7), whose body is however automatically generated by psc \nfor each obvent class C: public class C ... { /* generated by psc */ public void publish() throws CannotPublishException \n{ CAdapter.publish(this); } ... } Accordingly, a PublishStatement expressing the publish\u00ading of an Obvent \no, publish o; is transformed into a call to the publish() method of o, provided that o s static type \ncan be widened to Obvent. o.publish(); Note that every obvent class must implement a public no-argument \nconstructor, in order to enforce deserialization with Java s built-in mechanisms. 4.4.2 Subscriptions \nBy similarly transforming subscriptions to (static) calls to the corresponding obvent types, subscriptions \nto interfaces would be impossible. Hence, subscriptions, as well as unsub\u00adscriptions, are handled di.erently. \nIn short, a subscription statement involving a type T is transformed to an invocation of one of the subscribe() \nmethods in class TAdapter (pos\u00adsibly also OventAdapter in package java.pubsub), as shown in Figure 6. \nAn instance of an anonymous class representing a sub\u00adscriber is created from the handler of a subscription \nexpres\u00adsion such as the following: subscribe (T t) {...} { /* handler */ } It implements the Subscriber \ninterface given in Figure 7: new Subscriber() { public void notify(Obvent o) { T t = (T)o; /* handler \n*/ } } package java.pubsub; import java.io.*; /* obvents */ public interface Obvent extends Serializable \n{ /* generated by psc */ public void publish() throws CannotPublishException; } /* top level */ public \nfinal class ObventAdapter {...} public static Subscription subscribe(LocalFilter l, Subscriber s) public \nstatic Subscription subscribe(RemoteFilter r, Subscriber s) } /* filters */ public interface Filter \n{...} public interface RemoteFilter extends Filter {...} public interface LocalFilter extends Filter \n{ public boolean eval(Obvent o); } /* handlers */ public interface Subscriber { public void notify(Obvent \no); } Figure 7: Details of Obvent, and further types in java.pubsub Such an anonymous class declaration \nrepresents an ex\u00adpression, and can thus be passed as argument to the subscribe() method of the corresponding \nadapter. 4.4.3 Filters The handling of .lters represents the most complex task during precompilation. \nA .lter whose statements deviate from the guidelines which strongly enforce its mobility ac\u00adcording to \nthe previous section, is similarly transformed into an anonymous class representing a unary predicate \nof type LocalFilter shown in Figure 7, and applied locally. A sub\u00adscription expression such as subscribe \n(T t) { /* filter */ } {...} is hence transformed into an invocation of the corresponding adapter class: \nTAdapter.subscribe( new LocalFilter() { public boolean eval(Obvent o) { T t = (T)o; /* filter */ } }, \nnew Subscriber() {...} ) If the depicted restrictions are respected, psc generates an intermediate representation \nof the .lter, in a way similar to what is done for application-speci.c handlers (ASHs) [20], low-level \nmessage .lters, except that those are applied lo\u00adcally and expressed in a neutral speci.cation language, \nwhile our .lters promote the use of the native language syntax. Our precompiler generates two tree-like \nconstructs, which are more speci.c than for instance the parse trees used in Smalltalk [57]. Invocation \ntree: First, a representation of the invocations made in the .lter is generated: the root represents \nthe .ltered obvent, and every node represents a method invo\u00adcation. A leaf node stands for the outcome \nof a condition on the value obtained by applying the methods of the nodes on the path downto that leaf \nin a nested fashion (nodes can also represent attribute accesses). Evaluation tree: Second, a tree representing \nthe relation\u00adships between the leaves of the former tree and the out\u00adcome of the .ltering is generated: \nits nodes represent mainly logical combinations of its subnodes aso., and the leaves are references to \nthe leaves of the former tree. This information is stored in an instance of RemoteFilter (Figure 7). \nA general description of our approach to instrumenting Java with .rst class parse trees, based on a generalization \nof deferred code evaluation expressed through .lters, will be the subject of a future paper.  5. DISCUSSION \nThis section discusses several issues, including two design alternatives as well as interoperability \nissues. We also con\u00adtrast our type-based publish/subscribe with RMI, pointing our the fact that the two \nparadigms are not contradictory but complementary. 5.1 Fork We have explored several alternative primitives \nfor the expression of publish/subscribe based on our obvent model, among which we outline what we believe \nto be the two which are most likely to come into mind. This .rst alternative for the expression of publish/subscribe \nbased on our obvent model makes use of a fork-similar primitive for noti.cation delivery. 5.1.1 Obvent \nVariable A new noti.cation is assigned to a variable, and a block representing a handler is executed \nevery time a new value is put into the variable: T t = null; t = subscribe {...} {...}; /* here t is \nnull */ This primitive could, in the case of Java, be implemented similarly to the solution presented \nthroughout this paper. However this syntax makes it di.cult to express unsubscrip\u00adtions, a problem which \ndoes not occur in the case of the fork primitive: when spawning a new coroutine, the execution of the \ncorresponding block takes place once only. Here, noti\u00ad.cations are delivered continuously, leading to \na repeated evaluation of the handler. By the absence of a subscription handle, a subscription can not \nbe referred to from outside of its expression. Unsubscriptions would have to be dealt with inside the \nhandlers, either through a parameterless un\u00adsubscription statement, or by having the handler return a \nboolean value after each obvent evaluation to signal whether the subscription is to be pursued. Either \nvariant leads to a restrictive solution, where a subscription can only be can\u00adcelled after the next event \nhas been delivered. While this can be desirable in many cases, it should not be the only possibility \nof cancelling a subscription. 5.1.2 Filter Note that alternatively, with this model, one could think \nof implementing .lters by giving the application the pos\u00adsibility of instantiating the future variable \nt, and in that sense, using it simultaneously as a template object: T t = new T(...); t = subscribe {...}; \nHowever, .ltering events by matching them against tem\u00adplate objects o.ers only little expressiveness: \ntemplate ob\u00adjects are usually compared attribute-wise with events, mak\u00ading the matching of an attribute \nagainst a range of values, or, since attributes might themselves be objects, the match\u00ading only of a \nnested attribute di.cult to express. Alterna\u00adtively, the matching can be performed inside the template \nobject, which renders the matching opaque, disabling any optimizations targeted at avoiding redundancies. \n 5.2 Callback As outlined in Section 3, a very common way of imple\u00admenting a callback in a language \nsuch as Java consists in asking the application to provide a callback object imple\u00admenting a given interface. \n5.2.1 Listener This second considered alternative, which is promoted by nearly all Java API s for common \npublish/subscribe engines, introduces a speci.c listener like the Subscriber type pre\u00adsented in Figure \n7. This type, which, as depicted, is inher\u00adently implemented by every anonymous class representing a \nhandler, would in this case be explicitly implemented and instantiated by the application to catch event \nnoti.cations, e.g.: Subscriber sr = ...; Subscription s = subscribe (T t) { / *filter* / } sr; The declared \nnotify() method with its weakly typed argu\u00adment does however not address LP1.A dynamic overriding of \nthe notify() method, i.e., adding a variant with an ar\u00adgument type T that subtypes Obvent in order to \nsubscribe to instances of T public void notify(T t) {...} would also allow handlers for several obvent \ntypes to be pro\u00advided by the same subscriber, yet does not add type safety. 5.2.2 Dispatching Through \nthis dynamic overriding, the notify method be\u00adcomes a so-called multi-method. Yet, dispatching (method \nselection) in Java, unlike CLOS [36] or Cecil, does not sup\u00adport multi-methods. Dispatching in Java, \nsimilarly than in C++, o.ers dynamic uni-dispatch, i.e., the class of the ob\u00adject referenced by an invoked \nvariable (representing its dy\u00adnamic type) is determined at runtime, but only static multi\u00addispatch. This \nprevents a typed solution based on dynamic overriding of the notify() method desribed above. There have \nbeen several approaches to overcoming Java s lack for multi-methods, ranging from using re.ection over \nmodifying the compilation to extending the virtual ma\u00adchine. Another common technique is also given by \ndouble dispatch [34], which could however not be applied in this case, like some of the other solutions, \nunless a speci.c subscriber TSubscriber is generated and implemented for every obvent type T that a subscriber \ntype handles. This would however remove the main advantage of this approach based on listeners, which \nconsists namely in giving much freedom to the developer in de.ning event handlers for any types (including \nsubtypes of subscribed types). In addition, the required dynamic multi-dispatch is a high price to pay, \nespecially if only introduced for the use with publish/subscribe primitives, also given the fact that \nit does not improve type safety. Note furthermore, that the scenario of multiple subscrip\u00adtions of a \nsubscriber to the same type, or through subtyp\u00ading related types, is not straightforward to handle: are \nthe di.erent .lters combined, and is the same event delivered several times? On the other hand, the callback \napproach enables an easy expressing of thread policies: by subtyping a SingleThreadSubscriber, the developer \ncould express the desire of processing only one instance of a given obvent type at a time. Multiple subtyping, \nintroduced to express a lim\u00adited form of QoS for obvents, could here be used again to express complex \nevent handling semantics.  5.3 Obvents vs Objects In languages which provide a default serialization \nmech\u00adanism through a type which must be subtyped, e.g., Java (java.io.Serializable), obvents are instances \nof that type. Hence in a general case, as shown by our distinction between bound/unbound objects, not \nevery object can be an obvent: the opposite would have not only mandated the type system to be singly-rooted \n(requiring extensions to languages like C++ and Ada), but also to integrate the before-mentioned serialization \nmechanism at that very root like in Smalltalk, possibly including a publish() method. How about an obvent \npublishing obvents, or subscribing to obvents? The former case does not bear any particu\u00adlar dangers, \nand should thus not be prohibited. Similarly, subscriptions could also be issued inside obvents, since \na subscription expression does not a.ect the object in which it was declared. The e.ective handlers/subscribers \ncan not be referenced, and hence can not be passed around, and in particular, can not be attributes of \nobvents. To underline this characteristic of subscriptions, the Subscription type is not serializable. \nNote that in the second presented design alternative, any application object can be de.ned as a subscriber \nby im\u00adplementing a given interface, that is, a notify() method. Equipping all objects with the ability \nof subscribing would have translated to adding that notify() method to the root type. Furthermore, subscribers \ncould be attributes of ob\u00advents. The danger of endless recursions whenever an ob\u00advent subscribes to itself \ncould however easily be banned, by not considering a subscription as part of the state of a subscribed \nobvent: once published, the copies of an obvent would have to reissue any subscriptions performed by \ntheir master copy . 5.4 RPC and Publish/Subscribe Originally introduced as remote procedure call (RPC) \n[7], remote invocations have been quickly applied to object\u00adoriented languages, leveraging some form \nof remotely accessible entity, e.g., guardians in Argus [41] (its follow-up CLU [42]), network objects \nin Modula-3 [11] and Obliq [10] (every object is potentially a network object), and of course remote \nobjects in Java RMI [61]. 5.4.1 Invocations vs Events There are mainly two di.erences between such remote \nin\u00advocations and our event-based model: Interaction styles: The RPC model promotes the same ab\u00adstraction \nfor remote object interactions as for local ones. By doing so, (synchronous) RPC is inherently integrated \nwith the language, and requires little more support than that very inherent interaction abstraction. \nIn contrast, our model promotes two interaction styles, namely (1) event-based publish/subscribe interaction \nremotely, and (2) method invocations locally, making the application developer more aware of distribution. \nObject passing semantics: With remote invocations, there are two possible ways of passing objects, namely \n(1) by reference, i.e., a proxy object is created in the receiver s address space, and (2) by value. \nThe distinction goes along the notion of the granularity mediated in Section 2, i.e., large locality-bound \nobjects interact via remote in\u00advocations, where the invocation arguments are small unbound objects or \nreferences to large remotely invo\u00adcable objects. In contrast, when using our obvent-based model, objects \nare primarily passed by value. However, publish/subscribe and RPC are not contradic\u00adtory, but complement \neach other. A combination of both represents a very powerful tool for devising distributed ap\u00adplications, \ne.g., by passing object references with obvents. 5.4.2 Hand in Hand A collaboration between the two \ninteraction styles can be illustrated by reconsidering the simple example given in Sec\u00adtion 2. Though \nthe use of a publish/subscribe interaction for the dissemination of stock quotes seems appropriate by \nscal\u00ading easily to many brokers, it might seem more appropriate to use a sychronous interaction with \nthe stock market when purchasing stock options, e.g., a remote method invocation. Figure 8 shows how \nJava RMI and publish/subscribe can work together, hand in hand. To correctly handle the seri\u00adalization \nof remote objects (in the sense of RMI), the RMI serialization mechanism is used, enabling a transparent \nin\u00adtegration of RMI and publish/subscribe. However, the cur\u00adrent implementation of Java RMI presents \na severe caveat, which becomes especially visible through this integration with events. In fact, the \ndistributed garbage collection keeps a remotely accessible object from being garbage collected as long \nas there is at least one proxy for that object. When publishing an event containing a reference to a \nremote ob\u00adject, such a proxy is created for each subscriber, which can sum up to several 1000 s. Every \ntime a proxy is garbage col\u00adlected, the Java virtual machine hosting the represented ob\u00adject is noti.ed. \nConsequently, if a single subscriber crashes, the remote object will never be garbage collected. With \na weaker implementation of Java RMI, such as the one proposed in [13], this problem could be circumvented. \n 5.5 100% Pure Content Java, like most statically typed languages, uses name equivalence of types, which \nmeans that two types are compatible only if declared so. If two di.erent types T1 and T2 have exactly \nthe same parents in their type hierarchy, instances of T1 can not be assigned to variables of T2 or vice \nversa. A type scheme which allows this is said to enforce structural equivalence of types. 5.5.1 Re.ection \nWhen subscribing to obvents it might be of interest in cer\u00adtain cases to subscribe to any obvents which \nimplement a given method (speci.ed by its name and formal/actual pa\u00adrameters) irrespective of the types \nof these obvents. Java, just like Smalltalk, provides introspection mechanisms [60], that enable the \nquerying of objects for their type, and also members (attributes and methods, including facilities for \ndynamically reading/writing former ones and invoking lat\u00adter ones). Every Java object gives access to \nthese features through a method getClass(), which would enable the ex\u00adpression of a purely content-based \nsubscription like the fol\u00adlowing: Subscription s = subscribe (Obvent o) { ... Class c = o.getClass(); \nMethod m = c.getMethod(\"getPrice\", null); return m.invoke(o,null).equals(new Float(150)); ... } {...}; \nNow, any obvent type which implements a given method getPrice() (e.g., the StockQuote class) could be \ncaptured by this .lter, and the following handler could similarly dynamically extract information from \na conforming event. This feature, though giving much .exibility to the appli\u00adcation developer, is somehow \nopposed to our requirement for type safety (LP1 ), and we therefore do not consider introspection as \na necessary language mechanism, though our current Java prototype supports such untyped .lters. As shown \nby most currently existing engines, the lack for re.ection in programming languages can be made up easily \nby providing speci.c event types which explicitly implement a form of introspection, like the self-describing \nmessages advocated by [50]. 5.5.2 Tuples: Back to the Roots Another way of achieving structural equivalence \ncould consist in coming back to the concept of tuples used in Linda [28] (see next section), one of the \nspiritual ancestors of the publish/subscribe pardigm. In that sense, the publish primitive could be extended \nin order to accept any number of actual arguments: import java.rmi.*; import java.rmi.server.*; import \njava.pubsub.*; /* user */ public interface StockBroker extends Remote {...} /* stock market */ public \ninterface StockMarket extends Remote { public boolean buy(String company, float price, int amount, StockBroker \nbuyer) throws RemoteException; ... } /* stock quote obvents */ public class StockObvent implements Obvent \n{ private String company; private float price; private int amount; public String getCompany() { return \ncompany; } public float getPrice() { return price; } public int getAmount() { return amount; } public \nStockObvent(String company, float price, int amount) { this.company = company; this.price = price; this.amount \n= amount; } } public class StockQuote extends StockObvent { private StockMarket market; public Stockmarket \ngetMarket() { return market; } public StockObvent(String company, float price, int amount, StockMarket \nmarket) { super(company, price, amount); this.market = market; } } /* subscribing */ final StockBroker \nbroker = ...; /* this broker */ ... Subscription s = subscribe (StockQuote q) { return (q.getPrice() \n< 100 &#38;&#38; q.getCompany().indexOf(\"Telco\") != -1); } { ... boolean bought = q.getMarket().buy(q.getCompany(), \nq.getPrice(), q.getAmount(), broker); ... }; ... Figure 8: Buying stock quotes String company = ...; \nfloat price = ...; int amount = ...; StockMarket market = ...; publish (company, price, amount, market); \n Inversely, the subscribe primitive could be used with an arbitrary number of formal arguments, e.g, \nSubscription s = subscribe (String company, float price, int amount, StockMarket market) { /* filter \n*/ } { /* handler */ }; which could all be used as subscription criteria by the .lter, and could all \nbe accessed by the handler. Though one can argue that languages which do not inher\u00adently support structural \nequivalence should not be instru\u00admented with a distributed interaction style that relies on that paradigm, \nwe believe that this could lead to a very ap\u00adpealing style of distributed programming; requiring however \na more complex .ltering.  5.6 Language Integration vs Interoperability Language integration seems to \nbe somehow contradictory with the requirement of interoperability expressed in [50]. Publish/subscribe \nhas however nowadays found application in various contexts (e.g, virtual reality [30], group collabora\u00adtion \n[44], real time [25]), mainly due to its scalability prop\u00aderties achieved through strong decoupling of \nparticipants. Just like CORBA [52] has added interoperability to the RPC through a neutral interface \ndescription language (IDL), there have been several approaches to using a neutral event description language \n(EDL) to help adding interoperability to publish/subscribe. Proposals for such languages are plentiful, \nlike the OMG s object de.nition language (ODL) used in the Cambridge Event Architecture [4], languages \nused in tuple space implementations, e.g., object interchange language (OIL) in Objective Linda [37], \nor more recently, XML. We believe that such a speci.cation language could help adding interoperability \nto our system, and that in that sense, the types in package java.pubsub can be seen as a Java map\u00adping. \nHowever, since events are in our case not pictured as structures as in the above cases, but also encompass \nmeth\u00adods and thus code, an EDL can not by itself provide for interoperability. The issue of passing objects \nby value from one language to another has also been tackled in CORBA, and we are currently investigating \non the impact of an ap\u00adplication of those concepts to our system.  6. RELATED WORK Though publish/subscribe \nengines are plentiful, there has been only little work on integrating publish/subscribe inter\u00adaction \nwith an object-oriented programming language up to now. We .rst overview the two closest e.orts, and \nthen focus on linguistic support for alternative distributed interaction styles other than RPC, which \nhas already been discussed previously. 6.1 Publish/Subscribe Most event-based solutions focus less on \nlanguage integra\u00adtion, and more on interoperability. 6.1.1 ECO One approach to integrating event-based \ninteraction with C++ is discussed in [30], but also starting from a general event model. The authors \ndissociate two ways of adding event semantics to an object-oriented language, namely (1) by extension \nwith speci.c constructs and (2) by addition of speci.c classes, adopting the .rst approach. Their ECO \n(events + constraints + objects) model incorporates events as speci.c language constructs which are complementary \nto objects, and thus necessitate a considerable number of lan\u00adguage add-ons. The use of a precompiler \nto handle these extensions is also mentioned, but [30] gives no details about its implementation. 6.1.2 \nCEA The Cambridge Event Architecture (CEA) [4] promotes a publish/register/notify interaction style, \nwhere an inter\u00admediate event trader mediates between publishers and sub\u00adscribers. The CEA is based on \nan interopable object model, in which events are described by the ODMG s object def\u00adinition language \n(ODL), but alternative speci.cation lan\u00adguages, like XML, are also mentioned. Events are typed according \nto the de.nition language, and C++ and Java mappings are mentioned. Filtering mechanisms are also in\u00adcluded, \nhowever based on viewing the events as sets of at\u00adtributes, forcing the application to de.ne .lters based \non attribute-value pairs.  6.2 Message Passing Language integration has evolved along the communi\u00adcation \nparadigms. One of the .rst distributed interaction paradigms was message passing, consisting basically \nof a usually asynchronous send of messages (mainly for single sends, but also for addressing groups similar \nto publish), and a blocking receive primitive. Like many distributed interaction paradigms, message passing \nhas also extensively been used .rst in parallel and concurrent programming. Early, mainly procedural \nand process-oriented languages, like Occam [56] (using named unidirectional channels) or also SR [3] \n(.rst only with semi-synchronous sends, later also with synchronous remote procedure calls), included \nsome form of message passing. 6.3 Tuple Spaces The well-known tuple space paradigm [28] represents the \ndistributed interaction scheme which is closest to publish/subscribe. 6.3.1 The Original The tuple space, \n.rst introduced for parallel computing in Linda, can be viewed as a form of distributed shared mem\u00adory, \nwith the main di.erence being the structured form of data inserted into and retrieved from the tuple \nspace: tu\u00adples inserted into a tuple space are sets of values, and tuples read from the space are speci.ed \nas a set of formal and actual arguments, where former ones can be seen as placeholders de.ning the types \nof the corresponding elements, and latter ones de.ne the values of the corresponding elements for a candidate \ntuple. 6.3.2 Decoupling The original tuple space in Linda was based on a form of name-based addressing, \ni.e., tuple elements could be strings carrying a speci.c name. This idea has been reused in the original \npublish/subscribe variant based on topics, and the possibility of using more than one name element in \nLinda has been straightforwardly transposed to topic hier\u00adarchies, expressing containment relationships \non topics. In general, the publish/subscribe paradigm has been strongly in.uenced by the tuple space, \nmore speci.cally by its strong decoupling of participants in time and in space. 6.3.3 Publish/Subscribe \nvs Tuple Space Publish/subscribe further increases this decoupling by adding .ow decoupling, that is, \nreplacing the synchronous interaction (pulling) of the subscribers with an asyn\u00adchronous noti.cation \nmechanism. In fact, the original tuple space had three primitives, namely (1) out to push a tuple into \nthe space (similarly to publish), (2) read to read a tuple without erasing it, and (3) in to withdraw \na tuple from the space. Publish/subscribe adds an asynchronous callback mechanism, and by omitting an \nequivalence to in, sacri.ces concurrency control to scalability. 6.3.4 Linguistic Support There have \nbeen a series of attempts to transform the structured form of tuples to an object form, mainly by ex\u00adtending \nthe exact type equivalence for tuple elements in Linda to the notion of subtyping. While early approaches \nto integrating the tuple space with an object language like [45] (for Smalltalk) promoted tuples as sets \nof objects, later approaches, like [55] (C++) or [37] (Objective Linda) con\u00adsidered tuples, just like \nevents in our case, as single .rst class citizens, and added some form of content-based match\u00ading based \non templates. Very recently, callback mecha\u00adnisms have also been added, e.g. JavaSpaces [27], TSpaces \n[40] (both Java), supporting a publish/subscribe-like inter\u00adaction. In contrast to our approach however, \nlatter ones ba\u00adsically promote publish/subscribe interaction through some weakly typed .rst class channel, \nand advocate template\u00adbased matching.  7. CONCLUDING REMARK Throughout the history of computing, many \nparadigms have .rst been implemented as separate libraries, and have then made their way into programming \nlanguages. The monitor abstraction for concurrent programming introduced by Hoare [32] for instance, \nwas .rst implemented through a library before becoming a speci.c language construct (e.g., Portal [9]). \nNowadays, every Java object is potentially a monitor. This evolution does however not apply to all paradigms, \nas can be shown again by Java, which currently only includes a limited form of pointers through a library \n(Reference in java.lang.ref), while one of main spiritual ancestors, C++, integrates pointers as a .rst \nclass concept. This paper does not aim at advocating an integration vs a library approach to support \npublish/subscribe program\u00adming. Yet, we hope that based on the practical experi\u00adence we are currently \ngathering with both our library ap\u00adproach [24, 22] and the present integration approach, we will be able \nto answer the question of which kind of ap\u00adproach is more adequate to achieve object-oriented pub\u00adlish/subscribe \n. 8. ACKNOWLEDGMENTS Many ideas presented here have been re.ned through dis\u00adcussions with Andrew Black \n(Oregon Graduate Institute of Science and Technology), Joe Sventek (Agilent Laboratories, Edinburgh), \nMartin Odersky, Mathias Zenger, and Michel Schinz (Swiss Federal Institute of Technology, Lausanne), \nand Nicolas Ricci (Lombard &#38; Odier, Geneva). We would like to thank all the above-mentioned, as well \nas the anony\u00admous reviewers, for their valuable comments and sugges\u00adtions. 9. REFERENCES [1] M. Aguilera, \nR. Strom, D. Sturman, M. Astley, and T. Chandra. Matching Events in a Content-Based Subscription System. \nIn 18th ACM Symposium on Principles of Distributed Computing, 1999. [2] M. Altherr, M. Erzberger, and \nS. Ma.eis. iBus -a Software Bus Middleware for the Java Platform. In International Workshop on Reliable \nMiddleware Systems of the 13th IEEE Symposium On Reliable Distributed Systems, 1999. [3] G. Andrews and \nR. Olsson. The Evolution of the SR Language. Distributed Computing, 1(2), Apr. 1986. [4] J. Bacon, K. \nMoody, J. Bates, R. Hayton, C. Ma, A. McNeil, O. Seidel, and M. Spiteri. Generic Support for Distributed \nApplications. Computer, 33(3):68 76, Mar. 2000. [5] K. Birman, M. Hayden, O.Ozkasap, Z. Xiao, M. Budiu, \nand Y. Minsky. Bimodal Multicast. ACM Transactions on Computer Systems, 17(2):41 88, May 1999. [6] K. \nBirman and T. Joseph. Reliable Communication in Presence of Failures. ACM Transactions on Computer Systems, \n5(1):47 76, Feb. 1987. [7] A. Birrel and B. Nelson. Implementing Remote Procedure Calls. ACM Transactions \non Computer Systems, 2(1):39 59, Feb. 1984. [8] J. Boyland and G. Castagna. Parasitic Methods: Implementation \nof Multi-Methods for Java. In 12th ACM Conference on Object-Oriented Programming Systems, Languages and \nApplications, 1997. [9] A. Businger. PORTAL Language Description. Number 198 in LNCS. Springer-Verlag, \n1988. [10] L. Cardelli. A Language with Distributed Scope. In 14th ACM Symposium on Principles of Distributed \nComputing, 1995. [11] L. Cardelli, J. Donahue, M. Jordan, B. Kalsow, and G. Nelson. The Modula-3 Type \nSystem. In 16th ACM Symposium on Principles of Programming Languages, 1989. [12] A. Carzaniga. Architectures \nfor an Event Noti.cation Service Scalable to Wide-area Networks. PhD thesis, Politecnico di Milano, Dec. \n1998. [13] M. P. Ch. Nester and B. Haumacher. A More E.cient RMI for Java. In ACM 1999 Conference on \nJava Grande, 1999. [14] C. Chambers. The Cecil Language Speci.cation and Rationale: Version 2.0. Technical \nReport UW-CS Technical Report 93-03-05, Department of Computer Science and Engineering, University of \nWashington, Dec. 1995. [15] W. Cook, W. Hill, and P. Canning. Inheritance is not Subtyping. In 17th ACM \nSymposium on Principles of Programming Languages, 1990. [16] T. Corporation. Everything You Need to Know \nAbout Middleware: Mission-Critical Interprocess Communication (White Paper). http://www.talarian.com/, \n1999. [17] G. Cugola, E. D. Nitto, and A. Fuggetta. Exploiting an Event-Based Infrastructure to Develop \nComplex Distributed Systems. In 10th International Conference on Software Engineering, 1998. [18] S. \nDeering and D. Cheriton. Multicast Routing in Datagram Internetworks and Extended LANs. ACM Trans. on \nComputer Systems, 8(2):85 110, May 1990. [19] M. Ellis and B. Stroustrup. The Annotated C++ Reference \nManual. Addison-Wesley, 1992. [20] D. Engler, D. Wallach, and M.F.Kaashoek. Design and Implementation \nof a Modular, Flexible, and Fast System for Dynamic Protocol Composition. Technical Report TM-552, Massachusetts \nInstitute of Technology, Laboratory for Computer Science, 1996. [21] P.Th. Eugster, R. Boichat, and R. \nGuerraoui. E.ective Multicast Programming in Large Scale Distributed Systems. Technical Report DSC/2001/003, \nSwiss Federal Institute of Technology, Lausanne, 2001. [22] P.Th. Eugster and R. Guerraoui. Content-Based \nPublish/Subscribe with Structural Re.ection. In 6th Usenix Conference on Object-Oriented Technologies \nand Systems, 2001. [23] P.Th. Eugster, R. Guerraoui, S.B. Handurukande, A.-M. Kermarrec, and P. Kouznetsov. \nLightweight Probabilistic Broadcast. In IEEE International Conference on Dependable Systems and Networks, \n2001. [24] P.Th. Eugster, R. Guerraoui, and J. Sventek. Distributed Asynchronous Collections: Abstractions \nfor Publish/Subscribe Interaction. In 14th European Conference on Object-Oriented Programming, 2000. \n[25] C. Fetzer. Fail-Aware Publish/Subscribe in Erlang. In 4th International Erlang User Conference, \n1998. [26] S. Floyd, V. Jacobson, S. McCanne, C. G. Liu, and L. Zhang. A Reliable Multicast Framework \nfor Light-Weight Sessions and Application Level Framing. IEEE/ACM Transactions on Networking, Nov. 1996. \n[27] E. Freeman, S. Hupfer, and K. Arnold. JavaSpaces Principles, Patterns, and Practice. Addison-Wesley, \n1999. [28] D. Gelernter. Generative Communication in Linda. ACM Transactions on Programming Languages \nand Systems, 7(1):80 112, Jan. 1985. [29] J. Gosling, B. Joy, and G. Steele. The Java Language Speci.cation, \nSecond Edition. Addison-Wesley, 2000. [30] M. Haahr, R. Meier, P. Nixon, V. Cahill, and E. Jul. Filtering \nand Scalability in the ECO Distributed Event Model. In 5th International Symposium on Software Engineering \nfor Parallel and Distributed Systems, 2000. [31] M. Happner, R. Burridge, and R. Sharma. Java Message \nService. Technical report, Sun Microsystems Inc., 1998. [32] C. Hoare. Monitors: An Operating System \nStructuring Concept. Communications of the ACM, 17(10):549 557, Oct. 1974. [33] H. Holbrook, S. Singhal, \nand D. Cheriton. Log-Based Receiver-Reliable Multicast for Distributed Interactive Simulation. In 1995 \nACM Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication, \n1995. [34] D. Ingalls. A Simple Technique for Handling Multiple Polymorphism. In ACM Conference on Object-Oriented \nProgramming Systems, Languages and Applications, 1986. [35] International Organization for Standardization. \nAda 95 Reference Manual -The Language -The Standard Libraries, 1995. ANSI/ISO/IEC-8652:1995. [36] G. \nS. Jr. CommonLisp the Language. Digital Press, second edition, 1990. [37] T. Kielmann. Object-Oriented \nDistributed Programming with Objective Linda. In First International Workshop on High Speed Networks \nand Open Distributed Platforms, 1995. [38] P. Koenig. Messages vs. Objects for Application Integration. \nDistributed Computing, 2(3):44 45, Apr. 1999. [39] L. Lamport. Time, Clocks, and the Ordering of Events \nin a Distributed System. Communications of the ACM, 21(7):558 565, July 1978. [40] T. Lehman, S. M. Laughry, \nand P. Wycko.. Tspaces: The Next Wave. In Hawaii International Conference on System Sciences, 1999. [41] \nB. Liskov. Distributed Programming in Argus. Communications of the ACM, 31(3):300 312, Mar. 1988. [42] \nB. Liskov. A History of CLU. ACM SIGPLAN Notices, 28(3):133 147, Mar. 1993. [43] B. Liskov and L. Shrira. \nPromises: Linguistic Support for E.cient Asynchronous Procedure Calls in Distributed Systems. In ACM \nConference on Programming Language Design and Implementation, 1988. [44] A. Mathur, R. Hall, F. Jahanian, \nA. Prakash, and C. Rasmussen. The Publish/Subscribe Paradigm for Scalable Group Collaboration Systems. \nTechnical Report CSE-TR-270-95, University of Michigan, EECS Department, 1995. [45] S. Matsuoka and S. \nKawai. Using Tuple Space Communication in Distributed Object-Oriented Languages. In 3rd ACM Conference \non Object-Oriented Programming Systems, Languages and Applications, 1988. [46] B. Meyer. Ei.el: The Language. \nObject-Oriented Series. Prentice-Hall, 1992. [47] D. A. Moon. Object-Oriented Programming with Flavors. \nIn ACM Conference on Object-Oriented Programming Systems, Languages and Applications, 1986. [48] F. Nielson \nand H. Nielson. Two-Level Semantics and Code Generation. Theoretical Computer Science, 56(1):59 133, \nJan. 1988. [49] M. Odersky and P. Wadler. Pizza into Java: Translating Theory into Practice. In 24th \nACM Symposium on Principles of Programming Languages, 1997. [50] B. Oki, M. P.uegl, A. Siegel, and D. \nSkeen. The Information Bus -an Architecture for Extensible Distributed Systems. In 14th ACM Symposium \non Operating System Principles, 1993. [51] OMG. Noti.cation Service Standalone Document. OMG, June 2000. \n[52] OMG. The Common Object Request Broker: Architecture and Speci.cation. OMG, February 2001. [53] OMG. \nCORBAservices: Common Object Services Speci.cation, Chapter 4: Event Service. OMG, March 2001. [54] S. \nPaul, K. Sabnani, J. Lin, and S. Bhattacharyya. Reliable Multicast Transport Protocol (RMTP). IEEE Journal \non Selected Areas in Communications, 15(3):407 421, Apr. 1997. [55] A. Polze. Using the Object Space: \nA Distributed Parallel Make. In 4th IEEE Workshop on Future Trends of Distributed Computing Systems, \n1993. [56] D. Pountain. The Transputer and its Special Language, Occam. Byte Magazine, 9(8):361 366, \nAug. 1984. [57] F. Rivard. Smalltalk : a Re.ective Language. In International Conference on Metalevel \nArchitectures and Re.ection, 1996. [58] B. Segall and D. Arnold. Elvin has Left the Building: A Publish/Subscribe \nNoti.cation Service with Quenching. In Australian UNIX and Open Systems User Group Conference, 1997. \n[59] D. Skeen. Vitria s Publish-Subscribe Architecture: Publish-Subscribe Overview. http://www.vitria.com, \n1998. [60] Sun. Java Core Re.ection API and Speci.cation, 1999. [61] Sun. Java Remote Method Invocation \n-Distributed Computing for Java (White Paper), 1999. [62] Q. Sun and D. Sturman. A Gossip-Based Reliable \nMulticast for Large-Scale High-Throughput Applications. In IEEE International Conference on Dependable \nSystems and Networks, 2000. [63] W. Taha and T. Sheard. Multi-Stage Programming. In ACM International \nConference on Functional Programming, 1997. [64] TIBCO. TIB/Rendezvous White Paper. http://www.rv.tibco.com/, \n1999. [65] A. Yonezawa, J. P. Briot, and E. Shibayama. Object-Oriented Concurrent Programming in ABCL/1. \nACM Conference on Object-Oriented Programming Systems, Languages and Applications, 1986.   \n\t\t\t", "proc_id": "504282", "abstract": "This paper presents linguistic primitives for publish/subscribe programming using events and objects. We integrate our primitives into a strongly typed object-oriented language through four mechnisms: (1) serialization, (2) multiple subtyping, (3)closures, and (4) deferred code evaluation. We illustrate our primitives through Java, showing how we have overcome its respective lacks. A precompiler transforms statements based on our publish/subscribe primitives into calls to specifically generated typed adapters, which resemble the typed stubs and skeletons by the rmic precompiler for remote method invocations in Java", "authors": [{"name": "Patrick Th. Eugster", "author_profile_id": "81100562902", "affiliation": "Distributed Programming Laboratory, Swiss Federal Institute of Technology in Lausanne, CH-1015, Switzerland", "person_id": "PP48025202", "email_address": "", "orcid_id": ""}, {"name": "Rachid Guerraoui", "author_profile_id": "81100348136", "affiliation": "Distributed Programming Laboratory, Swiss Federal Institute of Technology in Lausanne, CH-1015, Switzerland", "person_id": "PP40026317", "email_address": "", "orcid_id": ""}, {"name": "Christian Heide Damm", "author_profile_id": "81100552433", "affiliation": "Department of Computer Science, University of Aarhus, 8200 Aarhus N, Denmark", "person_id": "P46565", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/504282.504301", "year": "2001", "article_id": "504301", "conference": "OOPSLA", "title": "On objects and events", "url": "http://dl.acm.org/citation.cfm?id=504301"}