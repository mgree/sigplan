{"article_publication_date": "10-01-2001", "fulltext": "\n Modular Mixin-Based Inheritance for Application Frameworks Dominic Duggan Ching-Ching Techaubol Dept \nof Computer Science Dept of Computer Science Stevens Institute of Technology Stevens Institute of Technology \nHoboken, New Jersey 07040 Hoboken, New Jersey 07040  dduggan@cs.stevens-tech.edu ctechaub@cs.stevens-tech.edu \nABSTRACT Mixin modules are proposed as an extension of a class-based programming language. Mixin modules \ncombine parallel ex\u00adtension of classes, including extension of the self types for those classes, with \nmixin-based inheritance. For soundness of subtyping purposes, they require an explicit distinction between \nmixin-based objects and class-based objects. Appli\u00adcations of mixin modules are in statically type-safe \nmonad\u00adbased aspect-oriented programming, and in modular mixin\u00adbased Internet programming.  Categories \nand Subject Descriptors D.3.1 [Programming Languages]: Formal De.nitions and Theory Semantics; D.3.3 \n[Programming Languages]: Language Constructs and Features Data Types and Struc\u00adtures General Terms Languages \n Keywords Mixin-Based Inheritance, Application Frameworks, Modu\u00adlarity 1. INTRODUCTION Component-based \nprogramming has become the central part of a paradigm shift in software development, moving pro\u00adgramming \naway from from-the-ground-up application de\u00advelopment and towards a model of plugging together o.-the\u00adshelf \ncomponents. Application frameworks have emerged in the object-oriented programming community as a ba\u00adsis \nfor facilitating component-based programming. In its most rudimentary form an application framework is \na library of classes, that are intended to be specialized by applica\u00adtion programmers with application \nsemantics. Speci.cation Permission to make digital or hard copies of part or all of this work or personal \nor classroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advantage and that copies bear this notice and the full citation on the first page. To copy \notherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission \nand/or a fee. OOPSLA 01 Tampa Florida USA Copyright ACM 2001 1-58113-335-9/01/10 $5.00 techniques such \nas formal methods and pattern languages may be used to facilitate the use of such libraries. While component-based \nprogramming at the class level has had some success, there is a growing recognition of the lim\u00aditations \nof such a low-level view in developing large appli\u00adcations from o.-the-shelf components. While module \nlan\u00adguages have been known at least since the days of languages such as Mesa, Modula and Ada [29, 26, \n32, 22, 25, 30], there is now growing interest in developing module lan\u00adguages speci.cally for composing \nclass libraries in object\u00adoriented languages. Since Java is now a popular object\u00adoriented language for \nboth practitioners and researchers, some of this work has at least implicitly been aimed at the Java \nlanguage. It can be argued that the essence of class-based object\u00adoriented languages is the incremental \nextension of recursive de.nitions via inheritance. This was the motivation for the .xed point semantics \nof inheritance by Cook et al, that in turn gave rise to research on self types that allowed method types \nto be specialized in subclasses derived via inheritance. The types being extended are object interfaces, \nwhich can be considered as a form of record type. So object interfaces can be viewed as recursively de.ned \nrecord types, and inher\u00aditance allows the incremental extension both of these types and of object implementations. \nNew applications suggest another view of recursive de.ni\u00adtions, that of recursively de.ned labelled trees. \nThis per\u00adspective is popularized by XML, which (at the risk of gross oversimpi.cation) can be viewed \nas a language for de.ning recursive tree types. Recursive tree types can be viewed as dual to recursive \nrecord types; indeed, the former corre\u00adspond to variant types and discriminated union types in the terminology \nof programming language types. The ultimate application of our work is in developing a framework for \ntype-safe mixin-based inheritance for compo\u00adnents of XML applications. In designing this framework we \nassume that processors for XML applications will be writ\u00adten in class-based languages such as Java or \nC#, since such processors will be easily downloadable over the Web. Pre\u00adsumably some, perhaps even many, \nXML processors will be written in XML-speci.c dialects such as XDuce and XML\u00adSQL, but it appears safe \nto assume that some large number will be written in class-based languages. Variant types can be represented \nusing only object types and subtyping: the tree type is de.ned as an abstract class or interface, and \nspeci.c node types of this tree type are represented as concrete classes that subclass this abstract \nclass. However this agglomeration of recursive record types and recursive variant types into the single \nconcept of object types confuses two concepts, and this confusion becomes problematic when we consider \nextensions. There are three extensions that we consider useful for the kind of reuse of XML applications \nthat we are interested in supporting: 1. Mixin-based inheritance: Traditional inheritance in\u00advolves the \nincremental extension of an existing applica\u00adtion. Mixin-based inheritance, popularized by CLOS, allows \nfragments of applications to be modularly com\u00adposed into complete applications. We envision an en\u00advironment \nfor XML applications where schema frag\u00adments, and processors for those fragments, are de.ned in a modular \nfashion and then combined as necessary for particular applications. A central design problem with mixin-based \ninheritance is that of choosing .eld names. For example unless care is taken it may be dif\u00ad.cult to combine \ntwo mixins, only because they have unrelated .elds with the same name. A facility for re\u00adnaming .elds \nin mixins could avoid this problem; how\u00adever this approach breaks with subtyping, since renam\u00ading prevents \nthe derivative class from being a subclass of the original class. Approaches based on distinguish\u00ading \ninternal and external .eld names [31] become problematic with parallel extensions of classes, and it \nis also not clear how .elds can be shared between mix\u00adins with this approach. 2. Parallel extensions: \nTraditional inheritance, and method type specialization, focus on the extension of a single class. XML \nschemas typically involve the def\u00adinition of several mutually recursive document types, and processors \nfor such document types will also in\u00advolve mutually recursive methods recursing over XML data structures. \nIn the style of processor de.nition envisioned for our framework, the inputs and outputs of these methods \nwould be represented as objects (to support mixin-based combination of processors [12]). Therefore support \nfor modular XML applications must be able to support the incremental extension and com\u00adbination of collections \nof mutually recursive types and processors. 3. Method type specialization: To be useful, our frame\u00adwork \nfor combining XML applications should ensure type safety. Method type specialization is a useful tool \ntowards this end, perhaps even essential with parallel extensions of types and processors. A standard \nexam\u00adple is given by abstract classes for the subject-observer pattern:  abstract class Subject { void \nnotify (Observer x); } abstract class Observer { void register (Subject x); }class WindowSubject extends \nSubject { ... }class WindowObserver extends Observer { ... } It would be very useful in the derivative \nclasses to have the instance variables specialized to types WindowObserver and WindowSubject, respectively. \nOth\u00aderwise objects of the derived classes must use down\u00adcasting at runtime to coerce objects to the required \ntypes, potentially reducing the reliability of the re\u00adsulting applications. On the other hand, allowing \nthe types to be specialized in this case leads to a loss of type safety: subtyping is incompatible with \nmethod type specialization in scenarios such as this. Our vehicle for adding these extensions to a class-based \nlan\u00adguage is mixin modules. A mixin module is a collection of mutually recursive type and implementation \nde.nitions. One might expect that a mixin module is then a collec\u00adtion of mutually recursive class de.nitions, \nsimilar to the approach advocated by Bruce et al for a statically safe al\u00adternative to virtual types \n[7]. However because of issues (1) and (3) described above, it is advantageous to break with the traditional \nconfusion of record and variant types in object\u00adoriented languages: 1. We retain classes in the traditional \nsense. Classes sup\u00adport extensions and overriding via inheritance, and an object of a class is also an \nobject of any superclass; there is subtyping based on class extensions. However classes do not support \n.eld renaming or method type specialization, since these are incompatible with sub\u00adtyping. In e.ect classes \nare the mechanism by which we de.ne variant types, and so class-based objects are the basis for representing \nXML data structures as trees. 2. We add mixins, as an alternative to classes, for de.n\u00ading object types \nand object implementations. Mixins can be combined in a modular fashion; however unlike the traditional \napproach to mixin-based combination, this combination is done at the level of modules rather than at \nthe level of mixins. Mixins support both ex\u00adplicit .eld renaming, to avoid .eld name con.icts, and also \nmethod type specialization. The di.culties de\u00adscribed earlier are avoided by not allowing subtyping for \nmixins; it is unnecessary, since the applications of subtyping are already handled by class-based objects, \nand it avoids the aforesaid problems.  As an example of the approach, assume we have two XML schemas \nfoo and bar, de.ning tags t1 and t2 respectively as components of the tag t. We want to modularly combine \nthese schemas into a single schema that de.nes a single tag t that can contain either a t1 tag ora t2 \ntag as its component. We represent this by two mixin modules foo and bar. The intended union tag t is \nde.ned as an abstract class, with t1 and t2 as subclasses of this class. We also attach a processor method \nproc to objects of the t class. We represent this in our framework by two mixin modules: module foo { \nabstract class t { Output proc (Input x); }; class t1 extends t { ... }; mixin Input { ... }; mixin Output \n{ ... }; }module bar { abstract class t { Output proc (Input x); }; class t2 extends t { ... }; mixin \nInput { ... }; mixin Output { ... }; } Then the intended union of these schemas is obtained by combination \nof mixin modules: module baz combines foo, bar; The resulting combination module has an abstract class \nt, and two subclasses t1 and t2. The module also has two mixins, Input and Output, corresponding to the \ninput and output of the processor application. The reason for de.ning these inputs and outputs as mixins \nis to support the mixin\u00adbased combination of the processor de.nitions. So the input arguments to the \nprocessor for the t1 tag are combined with the input arguments to the processor for the t2 tag, and similarly \nfor the outputs. If one thinks of XML documents as abstract syntax trees, and processors as attribute \ngram\u00admars, the inputs can be thought of as inherited attributes and the outputs as synthesized attributes. \nSo this can be viewed as a mixin-based approach to modularly combining attribute grammars. This can be \ngeneralized to a monadic approach to aspect-oriented programming described in [12], where modules include \nplugging code for weaving together inputs and outputs for each modular processor fragment. Each module \nprovides an aspect of the XML application, and mixin module combination uses the monadic de.nition of \nprocessor fragments to combine these aspects. As can be seen by example, names are an important part \nof combination. It is important that the base class have the same name (t) in both modules, that the \ninput and output mixins, Input and Output respectively, are called the same in both modules, and that \nthe processor method proc have the same name in both modules. Therefore mixin modules support renaming \nof both classes and mixins, and also of .eld names in mixins. In the next section we give an informal \noverview of a mini\u00adlanguage demonstrating the extension of a class-based lan\u00adguage with mixin modules. \nIn Sect. 3 we provide the key parts of the type system, while in Sect. 4 we provide the operational semantics. \nWe consider related work in Sect. 5, while Sect. 6 provides conclusions.  2. INFORMAL DESCRIPTION In \ndescribing the extension of a class-based language with mixin modules, we adopt the approach of FJ [23], \na small and economical kernel language that describes the essential core of Java. We provide an operational \nsemantics that can be viewed as an abstract interpreter for a class-based object\u00adoriented language extended \nwith mixin modules. We avoid basing mixin modules on Java inner classes, because the lat\u00adter introduce \nsome rather frightening complications [24]. We assume a collection of program variables x, y, z, w, . \n. . , and a collection of class, mixin and module names X, Y, Z, W, . . . . This latter class includes \na special module name This, a ref\u00aderence in a class or mixin de.nition to the .nal form of the module \n(after extensions and combinations) in which that de.nition occurs. The abstract syntax of our mini-language \nis de.ned in Fig. 1. A module de.nition P speci.es a collection of classes C and mixins M. Each class \nand mixin de.nition includes the spec\u00adi.cation of .elds, methods and a single constructor. A class or \nmixin is de.ned by extending an existing class or mixin that is de.ned in the same module. To reuse de.nitions \nfrom other mixin modules, we allow a module to extend another module, which introduces all of the (class \nand mixin) de.\u00adnitions in the latter module into the former module. So we have single inheritance for \nmodules, class and mixins. In\u00adheritance for modules and mixins serves a dual purpose: in addition to \nreusing de.nitions, it is also the operation for renaming classes and mixins (for modules) and renaming \n.elds and methods (for mixins) Since all class and mixin de.nitions are relative to a module, a type \nhas the form X.Y , where X is a module name and Y is the name of a class or mixin de.ned in that module \n(directly or indirectly via inheritance). A type of the form This.Y may be used to refer to the .nal \nmodule of the class or mixin Y when an object of this class or mixin is instantiated. For example1: module \nX extends Root {} {} { class Y extends Object { This.Y self () { return this; } }}module Z extends X \n{} {} { ... } Z.Y y1 = new Z.Y(); Z.Y y2 = y1.self();  There are two forms of mixin module de.nitions. \nAn atomic mixin module has the form module X extends Y. . { C; M; } The mixin module named X includes \nall of the de.nitions from the mixin module named Y , and extends it with new class de.nitions C and \nnew mixin de.nitions M. There is no notion of override; the additional classes and mixins must 1We assume \na special module named Root from which all other modules inherit. This module de.nes a root class Object \nand a root mixin MObject, analogous to the Object class in Java. e . Expression ::= new A(e1, . . . \n, ek) Object | e.x Class-based variable access | e.x(e1, . . . , ek) Class-based method invoke | A::e.x \nMixin-based variable access | A::e.x = e . Mixin-based variable update | A::e.x(e1, . . . , ek) Mixin-based \nmethod invoke | this This or self | x Variable | null Null | A::super.x(e1, . . . , ek) Mixin super | \nA::inner.x(e1, . . . , ek) Mixin inner | return e Method return A, B . Type ::= X.Y Type | This.Y Self \nType K . Constructor ::= X (A x, B y) { super(x); this.y = y; } Class constructor | X () { super(); this.xm \n= em; } Mixin constructor C . Class ::= class X extends Y { A x; K; F } Class de.nition M . Mixin ::= \nmixin X extends Y { A x; K; F } Mixin de.nition F . Method ::= A f(B x) { return (e); } Method de.nition \nP . Module ::= module X extends Y . . { C; M; } Module de.nition | module X combines Y, Z Module combination \n. ::= {X1 .. Y1, . . . , Xk .. Yk} De.nition Renaming . ::= {X1.x1 .. y1, . . . , Xk.xk .. yk} Label \nRenaming Figure 1: Abstract Syntax not share names with the existing classes and mixins in Y . To ensure \n.exibility, extending a mixin module allows class and mixin names in the old module to be renamed in \nthe new extended module, where this renaming is speci.ed by the de.nition renaming .. For example in \nthe code fragment: module X extends Root {} {} { class Z ... }module Y extends X {Z..W} {} { class Z \n... } Then the module Y contains two classes2: one named Y.W and one named Y.Z. The class named Y.W is \nactually a re\u00adnaming of X.Z, however there is no relationship between objects of the classes of X and \nobjects of the classes of Y. There is no subtyping relation between X.Z and Y.W. Even if the class Y.Z \ninherits from Y.W, there is no subtype rela\u00adtion between Y.Z and X.Z (although there is between Y.Z and \nY.W). It is not possible for Y.Z to be de.ned via inheri\u00adtance from X.Z. This restriction is enforced \nsimply because it would be unsound to do otherwise; well-typed programs could encounter run-time failure \ndue to invalid method calls without this restriction. The source of the unsoundness is that it is possible \nto specialize the types of mixins as a result of inheritance, as shown on the next page. So each mixin \nmodule de.nes a collection of mutually recursive classes and mixins, with subtype relations between classes \nonly valid within that module. This is compatible with the stated ob\u00adjective of mixin modules: to provide \nsupport for building safe reusable application frameworks, based on specializing classes in parallel. \nAs an example of the allowable subtype relations, we have: module X extends Root {} {} { class Y extends \nObject { void foo (This.Y y); }}module Z extends X {} {} { class W extends Y { void bar (); }} Z.W w \n= new Z.W(); w.foo (new X.Y()); // type error w.foo (new Z.Y()); // type-checks w.foo (w); // type-checks \nThe second form of mixin module allows a new form of mod\u00adule to be de.ned using module combination module \nX combines Y, Z This generalizes the combination of individual mixins, as in other approaches to mixin-based \ninheritance, to allow the simultaneous combination of collections of mixins. In this combination similarly \nnamed classes must be identical. Such classes arise from a common parent module W that the com\u00ad 2From \nnow on, we ignore the root class and mixin. bined modules Y and Z extend, and in the expected usage of \na mixin module the combined modules contribute extensions of this common base class. Module combination \nis de.ned as a binary operation for simplicity; it is straightforward to extend it to an n-ary operation \nfor n = 0. As an example of module combination, fragments of an ab\u00adstract syntax tree can be represented \nas: module Interp extends Root {} {} { class AST {...} ... }module FuncInterp extends Interp {} {} { \nclass Var extends AST { String x; } class Abs extends AST { String fml; AST body; } class App extends \nAST { AST rator; AST rand; }}module ImperativeInterp extends Interp {} {} { class Assign extends AST \n{ AST lhs; AST rhs; } class Deref extends AST { AST exp; }} module FuncImpInterp combines FuncInterp, \nImperativeInterp; Since our claim (and that of others [36]) is that XML schemas correspond in some sense \nto AST de.nitions, this exam\u00adple demonstrates how XML schemas can be combined using mixin module combination. \nOn the other hand, in mixin module combination, similarly named mixins are regarded as fragments that \nshould be coa\u00adlesced in the combination of the modules. In this coalescing, similarly named instance \nvariables must have the same type and are merged, so instance variables may be shared be\u00adtween mixins. \nSimilarly named methods must also have the same type. In their coalescence, the method implementation \nin the left-hand combinand is executed when the method is invoked on a mixin object. It is possible for \nthis method implementation to delegate to the implementation in the right-hand combinand; this is done \nusing the inner construct described below. For example: module Interp extends Root {} {} { mixin Input \nextends MObject ... {} mixin Output extends MObject ... {} class AST extends Object {Output eval(Input \nx);}}module FuncInterp extends Interp {} {} { class Env extends Object {...} mixin Input extends Input \n{ Env env; }}module ImperativeInterp extends Interp {} {} { class Store extends Object {...} mixin Input \nextends Input { Store store; }} module FuncImpInterp combines FuncInterp, ImperativeInterp; In the resulting \ncombination mixin module, an object of the mixin Input contains both an env .eld and a store .eld. The \nclass renaming operation that is part of mixin mod\u00adule extension appears to be essential to make this \napproach workable. Since part of our claim is that mixins can be used to de.ne attributes for evaluators \nthat walk over abstract syntax trees, this example demonstrates how such attribute de.nitions can be \ncombined using mixin module combina\u00adtion. An approach to modularly combining attribute evalu\u00adators, supported \nby our minilanguage, is described in [12]. A class de.nition has the form class X extends Y { Ax; K; \nF } This is exactly the same as a class de.nition in FJ. The de.nition introduces new instance variables \nx, and new and overriding method de.nitions F , and also de.nes a construc\u00adtor K. Every class extends \nanother class; we assume a spe\u00adcial root class analogous to Object in Java (although each module has \nits own version of Object, since subtyping is lo\u00adcal to a module). The class being extended must either \nbe de.ned in the current mixin module, or else have already been de.ned in the mixin module that the \ncurrent module extends. A mixin de.nition has the form mixin X extends Y { Ax; K; F } As with class de.nitions, \na mixin de.nition extends an ex\u00adisting mixin, contributing new instance variables, and new and overriding \nmethod de.nitions. Unlike with classes, only two forms of mixin extension are allowed: mixin X extends \nMObject ... mixin X extends X ... The .rst form de.nes a new mixin, while the second form de.nes the \nextension of an already-de.ned mixin (inherited from another module). A mixin extension must carry the \nsame name as the mixin being extended. This restriction is in order to ensure that references to the \noriginal mixin in a module being extended should rebind to the new mixin. As a result, mixins pro\u00advide \nsupport for method type specialization. For example, a module de.ning the interfaces for subjects and \nobservers could be speci.ed as follows: module SubjObs extends Root {} {} { mixin Subject extends MObject \n{ void register (This.Observer x) { ... } } mixin Observer extends MObject { void notify (This.Subject \nx) { ... }}} A windowing version of this module is de.ned by: module WindowSubjObs extends SubjObs {} \n{} { mixin Subject extends Subject { void notify (This.Observer x) { ... This.Observer::x.windowMeth() \n... } } mixin Observer extends Observer { void register (This.Subject x) {...}void windowMeth () {...}}} \nThe annotations for accessing (and updating) mixin object .elds (This.Observer::x.windowMeth() in this \nexample) are explained below. This results in a module WindowSubjObs with two mixins: Subject and Observer \n(and also the de\u00adfault MObject mixin). Then we can create objects of these mixins: WindowSubjObs.Subject \nws = new WindowSubjObs.Subject(...); WindowSubjObs.Observer wo = new WindowSubjObs.Observer(...); WindowSubjObs.Subject::ws.register(wo); \nThis example demonstrates method type specialization, since for example an object from the WindowSubjObs.Subject \nmixin has .elds contributed by both the base mixin and the derivative mixin, while the argument type \nof the notify method of an observer object has rebound to the new ex\u00adtended Subject type. We disallow \na subtype relation be\u00adtween mixins in order to avoid unsoundness due to method type specialization. For \nexample with such subtyping the following erroneous example would type-check: void bad (SubjObs.Subject \ns, SubjObs.Observer o) { SubjObs.Subject::s.register(o); }WindowSubjObs.Subject ws = new WindowSubjObs.Subject(); \nSubjObs.Observer o = new SubjObs.Observer(); bad (ws, o); It is because of method type specialization \nfor mixins that we do not allow a subtype relation between a class in one mixin module and a class in \na derivative mixin module. The following example demonstrates the unsoundness that would result otherwise: \nmodule X extends Root {} {} { mixin foo { int x; } class bar { void g (This.foo f) { This.foo::f.x=3; \n}}} module Y extends X {} {} { mixin foo extends foo { int y; } class baz extends bar { void g (This.foo \nf) { This.foo::f.y=4; } }}void bad (X.bar b, X.foo f) { X.bar::b.g(f); }bad (new Y.baz(), new X.foo()); \nField names are fundamentally important in mixins, because they are the basis for coalescing mixin de.nitions \nduring module combination. Therefore module extension allows .elds to be renamed in the mixins of the \nmodule being ex\u00adtended, using the .eld renaming .. For example: module X extends Root {} {} { mixin Z \n{ int x; }} module Y extends X {Z..W}{Z.x..y}{ mixin W extends W { String x; }} After these de.nitions, \nthe module Y has a single mixin, Y.W, with two .elds, a .eld x of type String and a .eld y of type int. \nIn summary we have three forms of extensions: 1. Module extension allows the de.nitions of one mod\u00adule \nto be included in another module. This operation also supports the renaming of de.nitions in the orig\u00adinal \nmodule, and the relabelling of .elds in mixins. This latter renaming is useful to support mixin combi\u00adnation, \nwhere it may not always be possible to ensure that two mixins have the same name for a .eld that they \nare expected to share. 2. Class extension is used to de.ne a variant or union type, where a base abstract \nclass de.nes a union type and concrete subclasses de.ne the variants of the union type. Therefore subtyping \nbetween subclass and base class are a fundamental part of class extensions. For this reason, class extension \ndoes not support method type specialization or any renaming. 3. Mixin extension allows a new mixin to \nbe de.ned via derivation from a base mixin. To understand the rela\u00adtionship between this and mixin combination, \nconsider the example of the Input mixin de.ned above:  So mixin extension is intended to be used to \nderive a concrete mixin from an abstract mixin or mixin inter\u00adface, while mixin combination is intended \nto modularly combine mixin implementations. Mixin module combination combines both classes and mix\u00adins: \n1. An abstract base class and its subclasses de.ne a union type in a module. If both of the combined \nmodules have the same base class, then combination forms the union of the corresponding union types in \nthe two modules, since all variants (derivative classes) will be subclasses of the base class in the \ncombination module. 2. If the same mixin is de.ned in both modules, then module combination combines \nthe two mixins into one. Similarly named .elds and mehtods must have the same types. Fields are shared \nbetween the mixins, and methods are combined using the inner construct, as explained below.  New objects \nare created by new. We follow the example of FJ and assume a stylized form of constructor de.nitions, \nwhere each class has a single constructor and that construc\u00adtor has an argument for each instance variable \nof the class. This restriction is only required for a simpli.ed description of the state of an object. \nLifting the restriction is straight\u00adforward but leads to a tedious complication of the semantics. With \nthis restriction, the state of an object is represented by an expression of the from new X.Y (e1,... \n,ek) where the expressions e1,... ,ek denote the values of the k instance variables of an object of class \nor mixin X.Y . We assume some canonical ordering of the instance variable names. The form of a class \nconstructor is required to be X(Ax, By) { super(x); this.y = y; } where {x} are the .elds de.ned in the \nsuperclass, and {y}are the .elds added by the current class de.nition. With this stylized constructor \nde.nition, the state of a class-based object can be represented as explained above. For mixin constructors, \nmatters are complicated by the fact that not all .elds are known when a constructor is de.ned; .elds \nmay be contributed by another mixin with which the current mixin is subsequently combined. Therefore \nthe form of a mixin constructor is X() { super(); this.y = e; } where {y} are the .elds contributed by \nthe current mixin de.nition. The expressions {e} are the default initial values for these .elds. An uninitialized \nobject is one of the form This.Y () where Y is a mixin in the current module X. This object is initialized \nwhen it evolves to one of the form X.Y (e1,... ,ek) where the mixin X.Y has k .elds, and ei is the default \ninitial value for the ith .eld. Therefore constructors for mixins are always nullary; they set the values \nof instance variables to default values, and rely on .eld update to provide more specialized values. \nFor objects from classes, there are the usual operations for accessing variables and invoking methods. \nFor objects from mixins, there are these operations and in addition there is a .eld update operation. \nThis .eld update operation is essen\u00adtial because (as explained) we cannot rely on the constructor to \ninitalize the variables. We make this update operation functional (it returns a new object with the updated \n.eld) only to simplify the operational semantics in Sect. 4, other\u00adwise it would be necessary to provide \na semantics involving stores etc. For mixins, the operations for .eld access and update, and for method \ninvocation, are annotated with the mixin type of the object on which the operation is being invoked. \nThis is not necessary either for typing programs or for the oper\u00adational semantics. It is only necessary \nbecause mixin exten\u00adsion allows some of the .elds of a mixin to be renamed, and the names used in the \nmixin code must then be relabelled in the derivative mixin. The type annotation identi.es those places \nin the code where the renaming must be done. For example: module X extends Root {} {} { mixin Y extends \nMObject { int x; int get() { return This.Y::this.x; } }}module Z extends X {} {Y.x..z}{} Z.Y w = new \nZ.Y(); Z.Y::w.get(); When Z.Y is derived from X.Y, the .eld x is renamed to z. The get method that is \ninherited from X.Y accesses the .eld using the old name of x. Therefore when the method is CT (X)=(module \nX extends Y .. { C; M; }) invoked from a Z.Y object, the attempted access to the x .eld is translated \nto an access to the z .eld. The type annotations ME = {(defname(M) .. M) | M . M}on .eld access and \nupdate and method invocation for mixin\u00ad (C. , ME)= de.ns(Y ) C= .(.(C))based objects serve to delineate \nthe places in method code ME= {(.(X) .. .(.(ME(X)))) | X . dom(ME)} where this renaming is necessary. \nde.ns(X) = ((C, C'), INH (ME, ME'')) Besides variable access and update, and method invocation, (Classes \nExtends) there are two other operations that may be formed on mixin\u00adbased objects. The super construct \nallows a method imple- CT (X)=(module X combines Y, Z) mentation to delegate to the implementation in \nthe par\u00ad (C, ME)= de.ns(Y )(C. , ME')= de.ns(Z) ent mixin. On the other hand the inner construct allows \na method implementation in a mixin to delegate to the im\u00ad de.ns(X) = ((C, C'), COMB(ME, ME')) plementation \nin a similarly named mixin with which it is (Classes Combines) combined, as a result of module combination. \nFor example: Figure 2: Flattened Inheritance Hierarchy module X extends Root {} {} { mixin foo extends \nMObject {void f() { print(\"X \"); } 3. TYPE SYSTEM } Both the static and dynamic semantics make use of \nvarious } metafunctions. In both of these semantics we assume a .xed module Y extends X {} {} { global \nmodule table CT , analogous to the global class table mixin foo extends foo { CT in the FJ semantics. \nThe most important of the meta\u00ad void f() { print(\"Y \"); super.f(); inner.f(); } functions is the function \nde.ns(X), where X is a module } name. This metafunction essentially .attens the inheritance } hierarchy \nfor a mixin module (arising both from extension module Z extends X {} {} { and from combination) into \na pair of a sequence of classes mixin foo extends foo { and a mapping ME from each mixin name to a tree \nof the void f() { print(\"Z \"); super.f(); } inherited and combined de.nitions for that mixin. The in\u00ad \n} heritance hierarchy for a mixin is described by the following } data structure: module W combines \nY, Z; W.foo x = new W.foo(); ::= inh(M, m) m W.foo::x.f(); | comb(m, m ') | mobj The output is YXZX. \nThe chain of delegations is described | M by this diagram: The case of m ::= M is only included as a \nconvenience for the Classes Extends rule in Fig. 2. This .gure gives the de.nition of the de.ns metafunction, \nthat performs the .attening of the inheritance hierarchy for a mixin module. This operation combines \nmixin environments using the INH and COMB metafunctions de.ned in Fig. 3. In the case of Classes Extends, \nwhere we compute the classes and mixins de.ned in the base module Y , the de.ni\u00adtion renaming . and label \nrenaming . are applied to these classes and mixins before they are combined with the new classes and \nmixins de.ned in the extension X. Some repre\u00adsentative cases in the de.nition of the application of a \nde.\u00adnition renaming and a label renaming are given in Fig. 3. The .attened inheritance hierarchy is used \nin the de.nition of metafunctions for computing method bodies and method types in Fig. 4. For a method \nde.ned in a class, we search for its de.nition in a class and then in the base class from which that \nclass is derived. This corresponds to the two cases Method Class Base and Method Class Extend in Fig. \n4. For a method de.ned in a mixin, there are three cases: either the method is de.ned in a mixin de.nition \n(Method Mixin InhL), or it is de.ned in a mixin from For simplicity we do not track when it is valid \nto invoke inner in a mixin method implementation. So it would be type-correct to add a call to inner.f() \nto Z above, and this would fail at run-time. We can .x this by extending mixins to specify an interface \nthey expect of any mixins with which they are combined, to ensure that calls to inner do not fail. We \nomit this check for simplicity.  INH (ME, ME')= {(X .. inh(ME(X), ME'(X))) | X . dom(ME) n dom(ME')}.{(X \n.. inh(ME(X), mobj )) | X . dom(ME) - dom(ME')}.{(X .. ME'(X)) | X . dom(ME') - dom(ME)} COMB(ME, ME')= \n{(X .. comb(ME(X), ME'(X))) | X . dom(ME) n dom(ME')}.{(X .. ME(X)) | X . dom(ME) - dom(ME')}.{(X .. \nME'(X)) | X . dom(ME') - dom(ME)} y if (X.x .. y) . . .X (x)= x otherwise .(C)= class X extends Y {Ax; \n.(K); .(F )} if C = (class X extends Y {Ax; K; F }) .(F )=(Af(Bx){return(.(e))}) if F = (Af(Bx){return(e)}) \n.(M)= mixin X extends Y {A.X (x); .(K); .X (F )} if M = (mixin X extends Y {Ax; K; F }) .X (F )=(A.X \n(f)(Bx){return(.(e))}) if F = (Af(Bx){return(e)}) W.Y ::.(e)..Y (x) if W = This .(W.Y ::e.x)= W.Y ::.(e).x \notherwise .(C)= class .(X) extends .(Y ) {.(A) x; .(K); .(F )} if C = (class X extends Y {Ax; K; F }) \n.(M)= mixin .(X) extends .(Y ) {.(A) x; .(K); .(F )} if M = (mixin X extends Y {Ax; K; F }) .(F )=(.(A) \nf(.(B) x){return(.(e))}) if F = (Af(Bx){return(e)}) W..(Y )::.(e).x if W = This .(W.Y ::e.x)= W.Y ::.(e).x \notherwise Figure 3: Metafunctions Figure 4: Method Body and Method Type classMeth(X.Y, f) = (A f (B x){. \n. . }, m) classMethTy(X.Y, f) = B . A (Method CType) (C, ME) = de.ns(X) (class Y extends Z { A x; K; \nF }) . C F = (A f(B x) { return (e); }) . F classMeth(X.Y, f) = F (Method Class Base) (C, ME) = de.ns(X) \n(class Y extends Z { A x; K; F }) . C f /. methnames(F ) classMeth(X.Y, f ) = classMeth(X.Z, f) (Method \nClass Extend) mixinMeth(X.Y, f) = (A f(B x){. . . }, m) mixinMethTy(X.Y, f) = B . A (Method MType) (C, \nME) = de.ns(X) Y . dom(ME) mixinMeth(X.Y, f) = mixinMeth(f, ME(X)) (Method Mixin) m = inh(M, m') M = \n(mixin X extends Y { A x; K; F }) F = (A f(B x) { return (e); }) . F mixinMeth(f, m) = (F, m. , ()) (Method \nMixin InhL) m = inh(M, m') M = (mixin X extends Y { A x; K; F }) f /. methnames(F ) mixinMeth(f, m) = \nmixinMeth(f, m') (Method Mixin InhR) m = comb(m1, m2) mixinMeth(f, m1) = (F, m. , (m'')) mixinMeth(f, \nm) = (F, m. , (m'', m2)) (Method Mixin CombL) m = comb(m1, m2) mixinMeth(f, m1) unde.ned mixinMeth(f, \nm2) = (F, m. , (m'')) mixinMeth(f, m) = (F, m. , (m'')) (Method Mixin CombR) mixinMeth(f, m) = (F, m'. \n, (m''')) mixinMeth(f, (m, m')) = (F, m'. , (m''. , m')) (Method Mixin SeqH) mixinMeth(f, m) unde.ned \nmixinMeth(f, m') = (F, m'. , (m''')) mixinMeth(f, (m, m')) = (F, m'. , (m''')) (Method Mixin SeqT) (C, \nME)= de.ns(X)(class Y extends Z { Ax; K; F }) . C (By)= classVars(X.Z) (Vars Class) classVars(X.Y )=(Ax, \nBy) (C, ME)= de.ns(X) Y . dom(ME) (Vars Mixin) mixinVars(X.Y )= removeDups(mixinVars(ME(Y ))) (By = \ne)= mixinVars(m) K = (Y (){super(); this.x = e'}) M = (mixin Y extends Z { Ax; K; F }) (Vars Mixin Inh) \n mixinVars(inh(M, m)) = (Ax = e',By = e) (Ax = e)= mixinVars(m)(By = e')= mixinVars(m') (Vars Mixin \nComb) ') mixinVars(comb(m, m')) = (Ax = e, By = e mixinVars(mobj ) = () (Vars Mixin MObject) classVars(X.Y \n)=(Ax) (Var Class Type) varType(X.Y, xi)= Ai mixinVars(X.Y )=(Ax = e) (Var Mixin Type) varType(X.Y, \nxi)= Ai (Sub Refl) (Sub Trans) (Sub Class) (Sub This) Figure 5: Instance Variables and Instance Variable \nType TE; A; W ; P; Mf e : B W f A = A TE; A, A; W, W ;(m, P); ((m), M) f return(e): B (Val Return) W \nf A = BW f B = C W f A = C TE; A; W ; P; Mf o (Val This) TE;(A, A); W ; P; Mf this : A (C, ME)= de.ns(X) \n(class Y extends Z {... }) . C TE; A; W ; P; Mf o (Val Var) W f X.Y = X.Z TE; A; W ; P; Mf x : TE(x) \n(C, ME)= de.ns(W ) TE; A; W ; P; Mf o (Val Null) (class Y extends Z {... }) . C TE; A; W ; P; Mf null \n: B W f This.Y = This.Z TE; A; W, W ; P; Mf e : AW f A = B TE; A; W, W ; P; Mf e : B Figure 8: Subtype \nRules (Val Subsumption) for computing a method body (Method CType for class Figure 7: Expression Type \nRules methods, Method MType for mixin methods). The Method Mixin rules in Fig. 4 for looking up methods \nwhich that mixin is derived by inheritance (Method Mixin in mixins return a triple as their result. The \n.rst element InhR), or it is de.ned in another mixin (of the same name) of this triple is the method \nde.nition. The second element with which it is combined by module combination (Method of this triple \nis an inheritance hierarchy for the parent of Mixin CombL or Method Mixin CombR). Computing a the mixin \nin which the method de.nition is found; refer\u00admethod type B . A is de.ned in terms of the operation ences \nto super in the method body are resolved using this (B y) = classVars(X.Y ) X .= This TE; A; W ; P; M \nf e : {X/This}B TE; A; W ; P; M f new X.Y (e) : X.Y (Val New Conc) (B y) = mixinVars(X.Y ) X .= This \nTE; A; W ; P; M f e : {X/This}B TE; A; W ; P; M f new X.Y (e) : X.Y (Val New Conc) (B y) = classVars(W.Y \n) TE; A; W, W ; P; M f e : B TE; A; W, W ; P; M f new This.Y (e) : This.Y (Val New Class) (C ' , ME) \n= de.ns(W ) Y . dom(ME) TE; A; W, W ; P; M f o TE; A; W, W ; P; M f new This.Y () : This.Y (Val New Mixin) \nTE; A; W, W ; P; M f e : X.Y Z = W if X = This, Z = X otherwise varType(Z.Y, x) = B TE; A; W, W ; P; \nM f e.x : {X/This}B (Val Access) TE; A; W, W ; P; M f e : X.Y Z = W if X = This, Z = X otherwise classMethTy(Z.Y, \nx) = B . B TE; A; W, W ; P; M f e : {X/This}B TE; A; W, W ; P; M f e.x(e) : {X/This}B (Val Invoke) TE; \nA; W, W ; P; M f e : X.Y Z = W if X = This, Z = X otherwise varType(Z.Y, x) = B TE; A; W, W ; P; M f \n(X.Y ::e.x) : {X/This}B (Val MAccess) TE; A; W, W ; P; M f e : X.Y Z = W if X = This, Z = X otherwise \nvarType(Z.Y, x) = B TE; A; W, W ; P; M f e ' : {X/This}B TE; A; W, W ; P; M f (X.Y ::e.x = e ' ) : X.Y \n(Val MUpdate) TE; A; W, W ; P; M f e : X.Y Z = W if X = This, Z = X otherwise mixinMethTy(Z.Y, x) = B \n. B TE; A; W, W ; P; M f e : {X/This}B TE; A; W, W ; P; M f (X.Y ::e.x(e)) : {X/This}B P = (m, m) mixinMeth(x, \nm) = (B ' x(B y){return(e)}) TE; A, A; W, W ; P; M f e : B TE; A, A; W, W ; P; M f A::super.x(e) : B \n' (Val MInvoke) (Val Super) A = X.Y mixinMethTy(W.Y, x) = B . B ' TE; A, A; W, W ; P; M f e : B TE; A, \nA; W, W ; P; M f A::inner.x(e) : B ' (Val Inner) Figure 6: Expression Type Rules hierarchy. The third \nelement of the triple is a sequence of inheritance hierarchies, corresponding to mixins with which the \nmixin containing the method de.nition has been com\u00adbined on the left. The latter sequence is used to \nresolve references to inner in the method body, in the operational semantics though not in the type system \nbecause not all of these combinands may be known at compile-time. This sequence of inheritance hierarchies \nwhile the inheritance hi\u00aderarchy is searched for a method de.nition; if the de.ni\u00adtion is found in the \nleft combinand of a mixin combination (Rule (Method Mixin CombL)), then the right combinand is added \nto this sequence of inheritance hierarchies. Fig. 5 de.nes metafunctions for computing the set of all \n(unique) instance variables de.ned in a class or mixin, and the type of an instance variable. The rule \nVars Class com\u00adputes the instance variables for a class by chasing up the inheritance hierarchy. The \nrule Vars Mixin computes the instance variables for a mixin by forming the sequence of all instance variables \ndeclared for all mixins with that name, and then removing duplicates. We omit the obvious de.ni\u00adtion \nof the metafunction removeDups. We omit type rules for modules, classes and mixins for lack of space; \nthey are reasonably straightforward. We concen\u00adtrate instead on the type rules for the core language, \npro\u00advided in Fig. 6 and Fig. 7. Here it is important to state that the type rules are intended to be \nused to type method bodies, but they are also intended to be used to type con.g\u00adurations of the operational \nsemantics provided in the next section. In the operational semantics, a program evaluates relative to \nseveral stacks, required because of the new, super and inner constructs: 1. Evaluation of new This.Y \n() for creating a mixin ob\u00adject requires knowledge of the current module, the module in which the currently \nrunning code is de.ned (perhaps by inheritance or combination from another module). Therefore the operational \nsemantics main\u00adtains a stack of module names, where the top of the stack gives the current module name. \n 2. Evaluation of A::super.x(e) and A::inner.x(e) require access to the next appropriate mixin in the \ninher\u00aditance hierarchy. For super the operational seman\u00adtics maintains a stack of inheritance hierarchies, \neach hierarchy corresponding to the parent mixin of the mixin in which the current method was de.ned. \nFor inner the operational semantics maintains a stack of sequences of inheritance hierarchies, each sequence \ncor\u00adresponding to the mixins with which the mixin con\u00adtaining the current method de.nition has been com\u00adbined. \nIt is also useful to have a stack of class/mixin names, where the top of the stack identi.es the current \nclass or mixin.  Stacks are required because, on each method call, the old module name, class name and \nremaining inheritance hierar\u00adchy must be saved until the method call terminates. The return construct \nis added to the language only as a place\u00adholder for a pending method call that has not yet returned. \nIf we give a type for an expression with stacks of size k + 1, then there must be a surrounding context \nthat contains return expressions nested to a depth of k. This is enforced by the type system in Fig. \n6 and Fig. 7. These type rules use sequents of the form TE; A; W ; P; Mf e : B where TE is a type environment, \na mapping from program variables (method parameters) to types. The sequence A is the sequence of class \nand mixin names, one per pending method call. The sequence W is the sequence of module names, while P \nis the stack of inheritance hierarchies for super and M is the stack of sequences of inheritance hierar\u00adchies \nfor inner. 4. OPERATIONAL SEMANTICS The operational semantics are provided in Fig. 9. The se\u00admantics \nis de.ned using small-step semantics, based on rewrite rules that map between 6-tuples (e, v, B, W, P, \nM) In this 6-tuple, e is an expression representing a running pro\u00adgram, the sequence of values v is a \nstack of objects (each such object corresponds to the this parameter to a suspended method invocation), \nthe sequence B is a stack of class and mixin names (each such name is the type of the correspond\u00ading \nthis parameter) and W a stack of module names, P is a stack of inheritance hierarchies (a sequence (m1,... \n,mk)) and M a stack of sequences of inheritance hierarchies (a se\u00adquence of sequences ((m1,1,... ,m1,n1 \n),... , (mm,1,... ,mm,nm )), as described in the previous section. The stacks grow from the right. As \nmethod invocation is commenced, the return construct is used to save a return point. The Red Ret Ctxt \nallows evaluation within a return (evaluation inside a method that has not yet returned). This rule ensures \nthat only the tops of the various stacks are visible in the evaluation of a method body. When evaluation \nof the expression reduces to a value, a return is e.ected by popping the stacks (Red Return). Values \nare de.ned as a subset of expressions for which no further evaluation is possible: v ::= null | new X.Y \n(v1,... ,vk),X .= This The stacks are pushed whenever a new method invocation is executed: Red Invoke, \nRed MInvoke, Red Super and Red Inner, corresponding to invocation of class ob\u00adject method, invocation \nof mixin object method, invocation via super and invocation via inner. When a class object method is \ninvoked (Red Invoke), dummy entries are placed on the super and inner stacks, since neither super nor \ninner are available within the body of a class method. The Red MInvoke rule for invoking a mixin method \npushes a new parent hierarchy m for super and a new sequence of hierar\u00adchies for inner m ' , both of \nthem obtained from the method lookup. The Red Super rule for invoking a method via super uses the top \nm of the super stack to search for the method de.ni\u00adtion in the parent mixin of the currently executing \nmethod s mixin. This returns a new parent inheritance hierarchy m ' and a new sequence of hierarchies \nm '' for inner. The former is pushed onto the super stack, the latter is appended to the top of the current \ninner stack and the result then pushed onto the inner stack. The motivation for the latter is that a \nmixin found in the parent hierarchy has been combined with the same mixins as the current mixin on the \nright, and in addition may have been combined with other mixins in the parent inheritance hierarchy. \nThe Red Inner rule for invoking a method via inner searches the sequence of hierarchies m at the top \nof the inner stack. Method lookup returns a new parent hierarchy m ' that is pushed onto the super stack, \nand a new sequence of hierar\u00adchies m '' that is pushed onto the inner stack. The Red Context rule allows \nevaluation within an evalu\u00adation context, de.ned by: E[] ::= [] | new A(... ,E[],... ) | E[].x | E[].x(e1,... \n,ek) | v.x(... ,E[],... ) | A :: E[].x | A :: E[].x = e | A :: v.x = E[] | A :: E[].x(e1,... ,ek) | A \n:: v.x(... ,E[],... ) | A :: super.x(... ,E[],... ) | A :: inner.x(... ,E[],... ) We deliberately omit \nreturn from this de.nition, so the Red Ret Ctxt rule must be used to evaluate inside a return. There \nis an auxiliary evaluation relation X f e =. e ' that is used to instantiate any occurrences of This. \nThe most important rule in this relation, Rule CRed New This, is provided in Fig. 9. Theorem 1. Suppose \ne does not have any subexpressions involving return. If {};(A); (W ); P; Mf e : B and W f e =. e ' then \n{};(A); (W ); P; Mf e ' : {W/This}B. Theorem 2 (Subject Reduction). Suppose B does not have any occurrences \nof This and {}; A; W ; P; Mf e : B and {}; (); (); (); () f v : A and ' ,v ' ,A'' , M ' (e, v, A, W , \nP, M) -. (e ,W ' , P ) then {}; (); (); (); () f v ' : A ' and {}; A ' ; W ' ; P ' ; M ' f e ' : B. Both \ntheorems are veri.ed by induction on type derivations. For subject reduction, the interesting cases are \nfor method invocations (Red Invoke, Red MInvoke, Red Inner and Red Super). For these we require a simple \nsubstitution lemma, and a lemma that veri.es that if a method (in a class or mixin) has a particular \ntype in a module, then it has the same type in any derivative of that module. Method types are parametric \nin This, the type of the module in which they are de.ned, and the auxiliary evaluation relation allows \nmethod bodies and their types to be instantiated appropri\u00adately at the point where they are used. 5. \nRELATED WORK A great deal of work in module languages has been done in the last few years in the functional \nprogramming community, speci.cally in the context of the ML functional language [21, 20, 27, 28, 34, \n14, 16]. ML provides a rich module structure where implementations are separated from interfaces (sim\u00adilarly \nto Modula-3), and where modules can parameterize over their imports. Such parameterized modules can then \nbe instantiated by applying them to a collection of imports matching the required interface. So ML follows \nthe model of programming-in-the-large as functional programming: a module that imports other modules \nis represented by a pa\u00adrameterized module, mapping from imports to exports, and linking is represented \nby the application of a parameterized module to its imports. This work builds on earlier work in algebraic \nspeci.cations, where module interfaces are alge\u00adbraic theories, module implementations are models of \nsuch theories, and modules are matched to interfaces by view morphisms from theory to model [19]. A weakness \nof the ML module system is that it does not handle circular imports, where a parameterized module may \nexport some de.nitions that are required by its imports. So for example two mutually recursive types, \nor two mutually recursive functions, must be de.ned in the same module and cannot be de.ned in separate \nmodules. This lack can be seen as symptomatic of a more general ability that would be desirable in a \nmodule language: to not only allow mutually recursive de.nitions to be split into separate modules, but \nto actually allow a recursive de.nition itself to be fragmented and the fragments to be de.ned in separate \nmodules. Duggan and Sourelis [14] proposed mixin modules as an extension of the ML module system that \nallowed exactly this kind of decomposition to be performed. In ML types mixinVars(X.Y )=(Bx = e) (CRed \nNew This) X f (new This.Y ()) =. (new X.Y (e)) (this, (v), (B), (W ), P, M) -. (v, (v), (B), (W ), P, \nM) (Red This) (Bx)= classVars(X.Y ) (Red Access) ((new X.Y (v)).xi, (vthis ), (B), (W ), P, M) -. (vi, \n(vthis ), (B), (W ), P, M) classMeth(X.Y, f)=(Bf(Bx){return(e)}) ''' ' v = (new X.Y (v)) X f e =. ee \n= (return({v '/x}e )) (v.f(v '), (vthis ), (B), (W ), P, M) -. (e '' , (vthis ,v), (B, X.Y ), (W, X), \n(P, mobj ), (M, ())) (Red Invoke) (Bx = e)= mixinVars(X.Y ) (Red MAccess) (A::(new X.Y (v)).xi, (vthis \n), (B), (W ), P, M) -. (vi, (vthis ), (B), (W ), P, M) v = new X.Y (v1,... ,vi,... ,vk)(Bx = e)= mixinVars(X.Y \n) (A::v.xi = v ' , (vthis ), (B), (W ), P, M) -. (new X.Y (v1,... ,v ' ,... ,vk)), (vthis ), (B), (W \n), P, M) (Red MUpdate) mixinMeth(X.Y, f)=(Af(Ax){return(e)}, m, m ' ) ''' ' v = (new X.Y (v)) X f e \n=. ee = (return({v ' /x}e )) ' (A::v.f(v ' ), (vthis ), (B), (W ), P, M) -. (e '' , (vthis ,v), (B, \nX.Y ), (W, X), (P,m), (M, (m ))) (Red MInvoke) ' '' P= (m) mixinMeth(f, m)=(Af(Ax){return(e)}, m, (m \n'')) P= (m, m ) ''' ' X f e =. ee = return({v/x}e ) M= ((m '''))) M ' = ((m '''), (m '' ,m '''))) '' \n' M ' (A::super.f(v, v), (vthis ), (B), (X), P, M) -. (e, (vthis ,vthis ), (B, B), (X, X), P , ) (Red \nSuper) M= ((m)) mixinMeth(f, m)=(Af(Ax){return(e)},m ' , (m '')) M ' = ((m), (m '')) ' '' ' ''' ' '''' \nX f e =. ee = return({v/x}e ) P= (m ) P= (m ,m )) (Red Inner) '' ' M ' (A::inner.f(v), (vthis ), (B), \n(X), P, M) -. (e, (vthis ,vthis ), (B, B), (X, X), P , ) ' ''' ' M ' e0 = return(e)(e, v, A, W, P, M) \n-. (e, v ' ,A' ,W, P , ) e0 = return(e ) ' (e0, (v, v), (A, A), (W, W ), (m, P), ((m), M)) -. (e0' , \n(v, v '), (A, A'), (W, W ), (m, P ' ), ((m), M ' )) (Red Ret Ctxt) (return(v ' ), (v, v), (A, A), (W,X), \n(P,m), (M, (m))) -. (v ' , v, A, W, P, M) (Red Return) ' M ' (e, v, A, W, P, M) -. (e ' , v, A ' ,W, \nP ' , ) (Red Context) ' M ' (E[e], v, A, W, P, M) -. (E[e ' ], v, A ' ,W, P ' , ) Figure 9: Reduction \nSemantics are datatypes, essentially named variant (or discriminated union) types. Mixin modules allowed \na datatype, and a func\u00adtion de.ned over that datatype, to be fragmented into sep\u00adarate modules. A new \nmodule composition operation then allowed the fragments of type and function de.nitions in two modules \nto be coalesced into a new module. The semantics of this were based on the semantics of mixin-based composi\u00adtion \nfor object-oriented languages developed by Bracha and Cook [5]. Bracha and Lindstrom [6] also developed \na gen\u00aderalization of the notion of mixins, which they called mod\u00adules and which were collections of mutually \nrecursive func\u00adtions that could be combined via mixin composition with other modules. The latter work \ndid not consider modules containing type components, nor did it consider the typing aspects of the language. \nThe current form of mixin modules has at least one com\u00adpelling advantage over the functional approach: \nin the func\u00adtional approach it is di.cult to ensure that a case statement examining a value of a variant \ntype will never fail for an un\u00admatched case, since the variant type may be extended by mixin module combination. \nThis is not a problem in the object-oriented approach, since the branches of the case can be distributed \nto the classes that provide the components of such a union type (subclassing from a common abstract base \nclass). The aspect that is in common with both Duggan and Sourelis mixin modules, and Bracha and Lindstrom \ns modules, is this: Inheritance is now understood semantically (thanks to the work of Cook [10, 9]) as \nthe incremental extension of the .xed point of a recursive de.nition, The aforesaid work generalizes \nthis to a form of inheritance that incrementally extends the .xed points of several mutually recursive \nde.\u00adnitions. In the work of Duggan and Sourelis, these are the .xed points of recursive types and recursive \nfunctions over values of those types. In the work of Bracha and Lindstrom, these are the .xed points \nof mutually recursive object gen\u00aderators. The need to consider inheritance over more than one class has \nbeen recognized in the literature. A standard example is that of the subject-observer pattern, where \nthe subject has a list of observers and each observer has a reference to the subject. If a generic subject-observer \npattern is provided as an application framework, a user of this framework would like to specialize both \nthe subject and observer classes for example to window subjects and window observers, and have the classes \nspecialized accordingly (a window observer object can only observe a window subject). An informal proposal \nfor an extension to Java was given by Bruce, Odersky and Wadler [7], and a formal semantics was given \nby Bruce [8]. Recursive modules have also been a focus of research [16, 18, 11, 2, 3, 37]. All of this \nwork has been based on al\u00adlowing mutually recursive de.nitions (sometimes including type de.nitions) \nto be de.ned in separate modules. This work has not considered issues concerned with inheritance and \nsubtyping, and their interaction with the combination of mutually recursive modular de.nitions. Although \nAncona and Zucca refer to their work as mixin modules, in fact their mixin modules are collections of \ndatatypes and func\u00adtions de.ned over values of those datatypes, rather than the more general form of \ndecomposition considered by Duggan and Sourelis [14]. Recent work on component languages for classes \nhas been based on some of this work [33], with partic\u00adular emphasis on dynamic loading. More recently \nDuggan [13] has considered an algebra for manipulating recursive modules, based on the operations of \nprocess algebras such as CCS. So combining modules is a form of parallel com\u00adposition, and there are \nalso operations for renaming module .elds and for coercively hiding module .elds. Analogous op\u00aderations \nare considered by Ancona and Zucca [3] and Wells and Vestergaard [37]. The module calculus considered \nhere has parallel composition (module combination) and renam\u00ading, but not coercive hiding, because the \nJava language has no notion of package types separate from package imple\u00admentations. While being a fundamental \nlimitation of the language, it also greatly simpli.es the work presented here. Besides the work of Bracha \nand Cook on mixin-based inher\u00aditance, more recent work has looked at .exible constructs for combining \nmixins. A central problem is that, because mixins are de.ned separately, it is di.cult to avoid .eld \nname con.icts when combining mixins. Flatt et al [17] solve this problem by having every access to a \nmixin object be made relative to an interface. However this approach does not allow a .eld to be shared \nbetween di.erent mixins, and the aforesaid work on mixin-based de.nition of modular in\u00adterpreters makes \ncritical use of shared .elds. They also do not consider the issues with specializing the .eld types of \nmixins considered here. Findler and Flatt [15] consider the combination of mixins with recursive modules. \nTheir ap\u00adproach amounts to the form of modular decomposition of variant types that was part of the motivation \nfor Duggan and Sourelis mixin modules. They do not consider the form of mixin-based combination of record \nde.nitions and the at\u00adtendant issues of .eld type specialization that are a critical consideration of \nthis work (providing a motivation for the distinction between classes and mixins that is not consid\u00adered \nby others). Ancona et al [1] have considered the addition of mixins (but not mixin modules) to the full \nJava languages, although there some critical issues regarding .eld name con.icts are left unresolved. \nDuggan [12] describes an approach to de.ning modular in\u00adterpreters in an object-oriented fashion, and \nspeculates on the form of language support required. Mixin modules, as described here, are capable of \nrepresenting that example. Speci.cally the types of abstract syntax trees can be rep\u00adresented using classes \n(abstract base class and derivatives) while the input and output types of the interpreter function can \nbe represented as mixins. Each interpreter fragment can then be represented as a mixin module containing \nboth class and mixin de.nitions. Mixin module combination coalesces the de.nitions in a type-safe manner. \nRelated to the latter work, the JTS project [4, 35] provides support for reusing abstract syntax trees \nand operations on those trees, with an emphasis on hygienic syntactic ma\u00adnipulations of ASTs. An interesting \npoint of comparison is that the JTS project recognizes the importance of mixin\u00adbased inheritance, at \nthe granularity of collections of classes rather than individual classes, for reusing DSLs. For exam\u00adple, \nif a language syntax has nonterminals for expressions and statements, then mixin-based inheritance for \nlanguage fragments must be able to simultaneously inherit from both expression and statement classes. \nThis is certainly a part of the framework described in [12]; however the latter frame\u00adwork goes beyond \nthis, to considering inheritance for se\u00admantic de.nitions and the proper composition mechanisms that \nallow modular semantic de.nitions to be combined via inheritance. The current work in addition shows \nthat this composition can be statically checked for type safety. 6. CONCLUSIONS We have described a kernel \nlanguage for an extension of a class-based language with mixin modules. This extension combines the parallel \nextension of classes via inheritance (with method type specialization for static type safety) with mixin-based \ninheritance. The intended application of this approach is in supporting application framework develop\u00adment \nand its use in a .exible and type-safe manner, using the module combination and extension operations \nof mixin modules. We are in the process of implementing this design in a compiler for Java, and we are \ninvestigating its applica\u00adtion in a concrete application domain for which Java has a good chance of being \nan application development language, that of portable XML processors. Regarding portability, it is certainly \nthe case that our exten\u00adsions, if carried through to the JVM instruction set, would make programs highly \nnon-portable. However at runtime only a .nished mixin module would be downloaded. Be\u00adcause of the self-contained \nnature of a mixin module (for example, all subtype relations are local), it is possible to translate \nfrom a mixin module to a collection of Java classes: class hierarchies are translated unchanged, while \nmixin hier\u00adarchies are collapsed into a Java class without superclasses. We are pursuing this approach \nin our implementation work. 7. ACKNOWLEDGEMENTS This work was supported by a grant from the New Jersey \nCommission on Science and Technology. Thanks to Phil Wadler for an interesting NJPLS talk. Thanks to \nDavid Naumann for helpful discussions. 8. REFERENCES [1] D. Ancona, G. Lagorio, and E. Zucca. Jam: A \nsmooth extension of Java with mixins. In European Conference on Object-Oriented Programming, Lecture \nNotes in Computer Science, Cannes, France, June 2000. Springer-Verlag. [2] D. Ancona and E. Zucca. A \ntheory of mixin modules: Basic and derived operators. Mathematical Structures in Computer Science, 8(4):401 \n446, 1998. [3] D. Ancona and E. Zucca. A primitive calculus for module systems. In Proceedings of the \nInternational Conference on Principles and Practice of Declarative Programming, Paris, France, September \n1999. Springer-Verlag. [4] D. Batory, B. Lofaso, and Y. Smaragdakis. JTS: Tools for implementing domain-speci.c \nlanguages. In Proceedings of the International Conference on Software Reuse. ACM Press, 1998. [5] G. \nBracha and W. Cook. Mixin-based inheritance. In Proceedings of ACM Symposium on Object-Oriented Programming: \nSystems, Languages and Applications, pages 303 311. ACM Press, October 1990. SIGPLAN Notices, volume \n25, number 10. [6] G. Bracha and G. Lindstrom. Modularity meets inheritance. In International Conference \non Computer Languages, pages 282 290. IEEE, 1992. [7] K. B. Bruce, M. Odersky, and P. Wadler. A statically \nsafe alternative to virtual types. In European Conference on Object-Oriented Programming (ECOOP), Brussels, \nJuly 1998. Extended abstract in: Workshop on Foundations of Object-Oriented Languages(FOOL 5), San Diego, \nJanuary 1998. [8] K. B. Bruce and J. Vanderwaart. Semantics-driven language design: Statically type-safe \nvirtual types in object-oriented languages. In Mathematical Foundations of Programming Semantics (MFPS), \n1999. [9] W. Cook, W. Hill, and P. Canning. Inheritance is not subtyping. In C. A. Gunter and J. C. Mitchell, \neditors, Theoretical Aspects of Object-Oriented Programming. The MIT Press, 1994. [10] W. Cook and J. \nPalsberg. A denotational semantics for inheritance and its correctness. In Proceedings of ACM Symposium \non Object-Oriented Programming: Systems, Languages and Applications, 1989. [11] K. Crary, R. Harper, \nand S. Puri. What is a recursive module? In Proceedings of ACM SIGPLAN Conference on Programming Language \nDesign and Implementation, Atlanta, GA, 1999. ACM Press. [12] D. Duggan. A mixin-based, semantics-based \napproach to reusing domain-speci.c programming languages. In European Conference on Object-Oriented Programming, \nLecture Notes in Computer Science, Cannes, France, June 2000. Springer-Verlag. [13] D. Duggan. Shared \nin typed module assembly language. In Workshop on Types in Compilation, Montreal, Quebec, Canada, September \n2000. [14] D. Duggan and C. Sourelis. Mixin modules. In Proceedings of ACM International Conference on \nFunctional Programming, pages 262 273, 1996. [15] R. Findler and M. Flatt. Modular object-oriented programming \nwith units and mixins. In Proceedings of ACM International Conference on Functional Programming, 1999. \n[16] M. Flatt and M. Felleisen. Units: Cool modules for HOT languages. In Proceedings of ACM SIGPLAN \nConference on Programming Language Design and Implementation, 1998. [17] M. Flatt, S. Krishnamurthi, \nand M. Felleisen. Classes and mixins. In Proceedings of ACM Symposium on Principles of Programming Languages, \npages 171 183. ACM Press, January 1998. [18] N. Glew and G. Morrisett. Type-safe linking and modular \nassembly languages. In Proceedings of ACM Symposium on Principles of Programming Languages, San Antonio, \nTexas, January 1999. ACM Press. [19] J. A. Goguen. Principles of parameterized programming. In T. J. \nBiggersta. and A. J. Perlis, editors, Software Reusability I: Concepts and Models, chapter 7, pages 159 \n226. ACM Press, 1989. [20] R. Harper and M. Lillibridge. A type-theoretic approach to higher-order modules \nwith sharing. In Proceedings of ACM Symposium on Principles of Programming Languages, pages 123 137, \nPortland, Oregon, January 1994. ACM Press. [21] R. Harper, J. Mitchell, and E. Moggi. Higher-order modules \nand the phase distinction. In P. Hudak, editor, Proceedings of ACM Symposium on Principles of Programming \nLanguages, pages 341 354. Association for Computing Machinery, 1990. [22] J. D. Ichbiach, J. G. P. Barnes, \nR. J. Firth, and M. Woodger. Rationale for the design of the Ada programming language. SIGPLAN Notices, \n14(6B), 1979. Special issue. [23] A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: A core calculus \nfor Java and GJ. In Proceedings of ACM Symposium on Object-Oriented Programming: Systems, Languages and \nApplications, Denver, CO, 1999. ACM Press. [24] A. Igarashi and B. C. Pierce. On inner classes. In European \nConference on Object-Oriented Programming, 2000. [25] Intermetrics, Cambridge, Mass. Ada-95 Reference \nManual, 1995. International standard ISO/IEC 8652:1995(E). [26] B. Lampson. A description of the Cedar \nlanguage. Technical Report CSL-83-15, Xerox Palo Alto Research Center, 1983. [27] X. Leroy. Manifest \ntypes, modules, and separate compilation. In Proceedings of ACM Symposium on Principles of Programming \nLanguages, pages 109 122, Portland, Oregon, January 1994. acmp. [28] X. Leroy. Applicative functors and \nfully transparent higher-order modules. In Proceedings of ACM Symposium on Principles of Programming \nLanguages, pages 154 163, San Francisco, California, January 1995. ACM Press. [29] B. Liskov, R. Atkinson, \nT. Bloom, E. Moss, J. C. Scha.ert, R. Schei.er, and A. Snyder. CLU Reference Manual. Lecture Notes in \nComputer Science. Springer-Verlag, 1981. [30] G. Nelson. Systems Programming in Modula-3. Prentice-Hall \nSeries in Innovative Technology. Prentice-Hall, 1991. [31] J. Riecke and C. Stone. Privacy via subsumption. \nIn Workshop on Foundations of Object-Oriented Languages, 1998. To appear in Information and Computation. \n[32] P. Rovner. On extending Modula-2+ to build large, integrated systems. IEEE Software, 3(6):46 57, \nNovember 1986. [33] J. Seco and L. Caires. A basic model of typed components. In European Conference \non Object-Oriented Programming, Lecture Notes in Computer Science. Springer-Verlag, 2000. [34] Z. Shao. \nTransparent modules with fully syntactic signatures. In Proceedings of ACM International Conference on \nFunctional Programming, Paris, France, September 1999. [35] Y. Smaragdakis and D. Batory. Implementing \nlayered designs with mixin layers. In European Conference on Object-Oriented Programming, 1998. [36] \nP. Wadler. The next 700 markup languages. In USENIX Conference on Domain-Speci.c Languages, October 1999. \nInvited talk. [37] J. Wells and R. Vestergaard. Equational reasoning for linking with .rst-class primitive \nmodules. In European Symposium on Programming, Berlin, Germany, April 2000. Springer-Verlag.  \n\t\t\t", "proc_id": "504282", "abstract": "Mixin modules are proposed as an extension of a class-based programming language. Mixin modules combine parallel extension of classes, including extension of the self types for those classes, with mixin-based inheritance. For soundness of sybtyping purposes, they require an explicit distinction between mixin-based objects and class-based objects. Applications of mixin modules are in statically type-safe monad-based aspect-oriented programming, and in modular mixin-based Internet programming.", "authors": [{"name": "Dominic Duggan", "author_profile_id": "81100303097", "affiliation": "Dept of Computer Science, Stevens Institute of Technology, Hoboken, New Jersey", "person_id": "P67811", "email_address": "", "orcid_id": ""}, {"name": "Ching-Ching Techaubol", "author_profile_id": "81100398575", "affiliation": "Dept of Computer Science, Stevens Institute of Technology, Hoboken, New Jersey", "person_id": "P344292", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/504282.504299", "year": "2001", "article_id": "504299", "conference": "OOPSLA", "title": "Modular mixin-based inheritance for application frameworks", "url": "http://dl.acm.org/citation.cfm?id=504299"}