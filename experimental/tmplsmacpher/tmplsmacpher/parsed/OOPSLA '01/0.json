{"article_publication_date": "10-01-2001", "fulltext": "\n Contract Soundness for Object-Oriented Languages Robert Bruce Findler Matthias Felleisen Rice University \nRice University &#38; Computer Science Department Northeastern University 6100 S. Main; MS 132 College \nof Computer Science Houston, TX 77006 Boston, Massachusetts 02115 USA USA ABSTRACT Checking pre-and post-conditions \nof procedures and methods at runtime helps improve software reliability. In the procedural world, pre-and \npost-conditions have a straightforward interpretation. If a procedure s pre-condition doesn t hold, the \ncaller failed to establish the proper context. If a post-condition doesn t hold, the procedure failed \nto compute the expected result. In the object-oriented world, checking pre-and post-conditions for methods, \noften called contracts in this context, poses complex prob\u00adlems. Because methods may be overridden, it \nis not suf.cient to check only pre-and post-conditions. In addition, the contract hi\u00aderarchy must be \nchecked to ensure that the contracts on overridden methods are properly related to the contracts on overriding \nmeth\u00adods. Otherwise, a class hierarchy may violate the substitution prin\u00adciple, that is, it may no longer \nbe true that an instance of a class is substitutable for objects of the super-class. In this paper, we \nstudy the problem of contract enforcement in an object-oriented world from a foundational perspective. \nMore speci.cally, we study contracts as re.nements of types. Pushing the analogy further, we state and \nprove a contract soundness theo\u00adrem that captures the essential properties of contract enforcement. We \nuse the theorem to illustrate how most existing tools suffer from a fundamental .aw and how they can \nbe improved. 1. INTRODUCTION Checking pre-and post-conditions of procedures is an important technique \nfor improving the reliability of software. It is available in many languages, including Ada [16], C [22], \nand Java [3, 4, 9, 10, 12, 17]. Several languages, including Eiffel [20], Sather [7], and Blue [11] have \nsupported runtime-checked pre-and post-condition contracts since their inception. Eiffel s community \nhas even de\u00adveloped the design by contract programming discipline, which is based on this idea [18, 19]. \nIn C-like languages, enforcing pre-and post-condition contracts is Permission to make digital or hard \ncopies of part or all of this work or personal or classroom use is granted without fee provided that \ncopies are not made or distributed for profit or commercial advantage and that copies bear this notice \nand the full citation on the first page. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists, requires prior specific permission and/or a fee. OOPSLA 01 Tampa Florida USA Copyright ACM \n2001 1-58113-335-9/01/10 $5.00 a simple and effective matter. Functions are annotated with pre-and post-conditions. \nIf a pre-condition is violated, the function s caller is to blame and if a post-condition is violated \nthe function itself is to blame. Rosenblum s study [22] demonstrates the effectiveness of contracts in \nthis world. In object-oriented languages, where contracts annotate method sig\u00adnatures, monitoring contracts \nis more complex than in procedural languages. The additional complexity is due to the subtyping re\u00adlationships \nthat are at the heart of object-oriented programming. Because instances of a type may be substituted \nin contexts expect\u00ading a supertype, the behavior of objects of a type must be related to the behavior \nof objects of the supertype. Further, because con\u00adtracts represent key aspects of an object s behavior, \nthe contracts on a given type must be related to the contracts of a supertype. Although a theory of object \nsubstitutability exists [15], a comple\u00admentary theory of contract monitoring is missing and, as a result, \nexisting contract monitoring tools are .awed. Our starting point for a theory of run-time contracts is \nthe theory of type systems. A major role for contracts is to specify prop\u00aderties similar to types, but \nthat cannot be checked by the type checker [22]. For example, a Java method may accept an integer, intending \nit to be an array index that must be within a certain range. Because Java s type system cannot express \nthe range constraint, a Java programmer must resort to contracts to state this fact. Addi\u00adtionally, type \nsystems have bene.ted from a well-developed theory. In particular, good type systems satisfy a type soundness \ntheorem, which ensures that the type checker respects the language s seman\u00adtics. Based on these observations, \nwe conclude that contract checkers could bene.t from a similarly well-developed theory. This paper develops \na .rst formal foundation for a theory of contracts. We discuss how contracts must respect a program s \nbehavior, and give a semantics that de.nes how contract hierarchies should be inter\u00adpreted. Additionally, \nwe state and prove a contract soundness theo\u00adrem. The theorem shows that our contract checker discovers \ninvalid contract hierarchies at method calls and returns. The paper consists of seven sections. The next \nsection motivates the contract checking theorem and explains it intuitively. Section 3 presents the syntax, \ntype checking, semantics, and contract elabo\u00adrator for Contract Java, a small model of (sequential) Java \n[8], ex\u00adtended with pre-and post-condition contracts. Section 4 states the contract soundness theorem, \nand proves that it holds for the con\u00adtract elaborator of section 3. Section 5 discusses existing contract \nchecking tools [2, 3, 4, 7, 9, 11, 12, 13, 17, 20] and explains how none of them (with the exception \nof Jass [2, 3]) satisfy the contract soundness theorem. Section 6 brie.y discusses an implementation. \nThe last section summarizes our results. 2. BEHAVIORAL SUBTYPING In programs without subtyping, checking \npre-and post-conditions is a simple matter. Consider this code, which implements a wrapper class for \n.oats: class Float { Float getValue() { ... } Float sqrt() { ... } @pre { getValue() > 0 } @post { Math.abs(sqrt \n* sqrt this.getValue()) <= 0.1 }} In this case, the pre-condition for sqrt ensures that the method is \nonly applied to positive numbers. The post-condition promises that the square of the result is within \na certain tolerance of the original input. Following tradition, we use the name of the method to stand \nfor its result in the body of the post-condition. In the case of the sqrt method, the pre-and post-conditions \nfully specify its correctness. In practice, however, programmers do not use pre-and post-conditions to \nspecify the entire behavior of the method; instead programmers use contracts to re.ne method type speci.cations. \nConsider this program: interface IConsole {int getMaxSize(); @post { getMaxSize > 0 }void display(String \ns); @pre { s.length() < this.getMaxSize() } } class Console implements IConsole {int getMaxSize() { ... \n}@post { getMaxSize > 0 }void display(String s) { ... }@pre { s.length() < this.getMaxSize() } } The \nIConsole interface contains the methods, types, and pre-and post-conditions for a small window that can \ndisplay a message, and the Console class provides an implementation of IConsole. The getMaxSize method \nreturns the limit on the message s size, and the display method changes the console s visible message. \nThe post\u00adcondition for getMaxSize and the pre-condition for display merely guarantee simple invariants \nof the console; they do not ensure cor\u00adrectness. As long as programs do not use inheritance, contract \nchecking merely involves evaluating the conditions that the programmer stated. Once programs employ inheritance \ncontract monitoring re\u00adquires more sophistication than that. According to the notion of behavioral subtyping \n[1, 14, 15], an instance of a subtype must be substitutable for an instance of a supertype. For pre-and \npost\u00adcondition contracts, behavioral subtyping mandates that the pre\u00adcondition of a method in a type \nimplies the pre-condition of the same method in each of its subtypes. Similarly, it requires that each \npost-condition in a subtype implies the corresponding post\u00adcondition in the original type. A contract \nchecker for object\u00adoriented languages must verify that the pre-condition and post\u00adcondition hierarchies \nmeet this behavioral subtyping requirement. As an example, consider this extension of Console: class \nRunningConsole extends Console {void display(String s) {... super.display (String.substring (s, ..., \n... + getMaxSize())) ... } @pre { true } } The display method creates a thread that displays whatever \nportion of the string .ts in the console and then updates the console s dis\u00adplay, scrolling the message \ncharacter by character. Since the pre\u00adcondition of display in RunningConsole is true, it is implied by \nthe pre-condition in Console, and thus RunningConsole is a behavioral subtype of Console. Not every pre-condition \non a method turns a subclass into a be\u00adhavioral subtype. Concretely, extensions of the Console class \nmay have pre-conditions that are not implied by the supertype s pre\u00adcondition. Consider this example: \nclass PrefixedConsole extends Console { String getPrefix() { return >> ; } void display(String s) { \nsuper.display(this.getPrefix() + s); } @pre { s.length() < this.getMaxSize() this.getPrefix().length() \n}} In this case, the pre-condition on Pre.xedConsole is not implied by the pre-condition on Console. \nAccordingly, code that is writ\u00adten to accept instances of Console may violate the pre-condition of Pre.xedConsole \nwithout violating the pre-condition of Console. Clearly, the code that expects instances of Console should \nnot be blamed, since that code ful.lled its obligations by meeting Con\u00adsole s pre-condition. Instead, \nthe blame must lie with the program\u00admer of Pre.xedConsole for failing to create a behavioral subtype \nof Console. In addition to classes, interfaces describe another type hierarchy. Like the class type hierarchy, \nthe interface type hierarchy must also specify a hierarchy of behavioral subtypes. Thus, the blame for \na malformed hierarchy can fall on the author of code that contains only interfaces. Consider the following \ntwo-part Java program: // Written by Guy // Written by James interface I { class C implements J { void \nm(int a); void m(int a) { ... } @pre { a > 0 } @pre { a > 10 } } public static void main(String argv[]) \n{interface J extends I { Ii = new C(); void m(int a); i.m(5); @pre { a > 10 }}}} Imagine that two different \nprogrammers, Guy and James, wrote the two different parts of the program. First, James s main method \ncreates an instance of C, but with type I. Then, it invokes m with 5. According to the contracts for \nI, this is perfectly valid input. According to the contract on J, however, this is an illegal input. \nThe behavioral subtyping condition tells us that J can only be a subtype of I if it is substitutable \nfor I in every context. This is not true, however, as J s m accepts fewer arguments than I s m. In particular, \nJ s m does not accept 1, 2, ..., 10 but I s m does. Guy s claim that J extends I is wrong. When the method \ncall from James s code fails, the blame for the contractual violation must lie with Guy. The preceding \nexamples suggest that contract checking systems for object-oriented languages should signal three kinds \nof errors: pre\u00adcondition violations, post-condition violations, and hierarchy er\u00adrors. The latter distinguishes \ncontract checking in the procedural world from contract checking in the object-oriented world. A hier\u00adarchy \nerror signals that some subclass or extending interface is not abehavioralsubtype,either becausethe hierarchyof \npre-conditions or the hierarchy of post-conditions is malformed. The goal of our paper is to develop \na theoretical framework in which we can state and prove claims about a contract monitoring system for \nJava. Following the reasoning of the introduction, we develop our framework in analogy to Milner s work \non type sys\u00adtems and type soundness theorems [21]. A type soundness the\u00adorem has two parts. First, it \nspeci.es what kind of errors (or run\u00adtime exceptions) the evaluation of a well-typed program can trigger. \nSecond, it implies that certain properties hold for the evaluation of subexpressions. For example, an \naddition operation in an ML program will always receive two numbers, and thus ML programs never terminate \nwith errors due to the misuse of the addition oper\u00adation. Similarly, an array indexing operation will \nalways receive an integer as an index, but the integer may be out of the array s range. Hence, an ML \nprogram may terminate due to a misuse of an array primitive. Here we show that a contract checking system \ncan satisfy a con\u00adtract soundness theorem. Like a type soundness theorem, the con\u00adtract soundness theorem \nspells out two properties. First, it states what kind of errors the evaluation of a monitored program \nmay sig\u00adnal. Second, it implies that the speci.ed hierarchy of interfaces and classes satis.es implications \nbetween the stated pre-and post\u00adconditions of overridden methods. To formalize these intuitions, we develop \na model of Java with con\u00adtracts in the form of a calculus. The calculus speci.es the syn\u00adtax, type system, \nand semantics of a small Java-like language with mechanisms for simple contract speci.cations. Based \non this cal\u00adculus we specify contract checking as a translation from the full language into a small kernel. \nUsing the calculus, we state and prove a contract soundness theorem.  3. CONTRACT JAVA Contract Java \nextends the Classic Java calculus [6] with pre-and post-condition contracts on methods. This section \npresents the Contract Java calculus, it syntax and semantics. Section 3.1 presents the syntax and type \nchecker. Section 3.2 is the focal point of this section; it presents the contract elaborator. Finally, \nsec\u00adtion 3.3 presents the operational semantics. 3.1 Syntax and Type Checking Figure 1 contains the \nsyntax for Contract Java. The syntax is di\u00advided into three parts. Programmers use syntax (a) to write \ntheir programs. The type checker elaborates syntax (a) to syntax (b), which contains type annotations \nfor use by the evaluator and con\u00adtract compiler. The contract compiler elaborates syntax (b) to syn\u00adtax \n(c). It elaborates the pre-and post-conditions into monitoring code; the result is accepted by the evaluator. \nA program P is a sequence of class and interface de.nitions fol\u00adlowed by an expression that represents \nthe body of the main method. Each class de.nition consists of a sequence of .eld dec\u00adlarations followed \nby a sequence of method declarations and their contracts. An interface consists of method speci.cations \nand their contracts. The contracts are arbitrary Java expressions that have type boolean.1 A method body \nin a class can be abstract, indi\u00adcating that the method must be overridden in a subclass before the class \nis instantiated. Unlike in Java, the body of a method is just an expression whose result is the result \nof the method. Like in Java, classes are instantiated with the new operator, but there are no class constructors2 \nin Contract Java; instance variables are initialized to null. Finally, the view and let forms represent \nJava s casting ex\u00adpressions and the capability for binding variables locally. In the code examples presented \nin this paper, we omit the extends and implements clauses when nothing would appear after them. The type \nchecker translates syntax (a) to syntax (b). It inserts addi\u00adtional information (underlined in the .gure) \nto used by the con\u00adtract elaborator and the evaluator. To support contract elabora\u00adtion, method calls \nare annotated with the type of the object whose method is called. To support evaluation, .eld update \nand .eld ref\u00aderence are annotated with the class containing the .eld, and calls to super are annotated \nwith the class. The contract elaborator produces syntax (c) and the evaluator ac\u00adcepts it. The @pre and \n@post conditions are removed from inter\u00adfaces and classes, and inserted elsewhere in the elaborated program. \nSyntax (c) also adds three constructs to our language: preErr, postErr, and hierErr. These constructs \nare used to signal contract violations. 1We could have carried out our study in a more complex contract \nspeci.cation language, but plain Java expressions suf.ce to express many important contracts. Additionally, \nusing a single language for pre-conditions, post-conditions, and expressions simpli.es the presentation \nand proofs. 2Pre-and post-condition contracts for constructors can be treated as contracts on methods \nthat are never overridden. P ::= defn* e defn ::= class c extends c implements i* { .eld* meth* }|interface \ni extends i* { imeth* } field ::= t fd meth ::= t md ( arg*) { body }@pre { e } @post { e }imeth ::= \nt md ( arg*) @pre { e } @post { e }arg ::= t var body ::= e |abstract e ::= new c |var |null |e.fd |e.fd \n= e |e.md (e*) |super.md (e*) |view t e |let {binding* }in e |if ( e ) e else e |true |false |{e ; e \n} binding ::= var = e var ::= a variable name or this c ::= a class name or Object i ::= interface name \nor Empty fd ::= a .eld name md ::= a method name t ::= c |i |boolean (a) Surface Syntax P ::= defn* \ne defn ::= class c extends c implements i* { .eld* meth* }|interface i extends i* { imeth* } field ::= \nt fd meth ::= t md ( arg*) { body }@pre { e } @post { e }imeth ::= t md ( arg*) @pre { e } @post { e \n}arg ::= t var body ::= e |abstract e ::= new c |var |null |e : c .fd |e : c .fd = e |e: t.md (e*) |super \n=this : c .md (e*) |view t e |let {binding* }in e |if ( e ) e else e |true |false |{e ; e } binding ::= \nvar = e var ::= a variable name or this c ::= a class name or Object i ::= interface name or Empty fd \n::= a .eld name md ::= a method name t ::= c |i |boolean (b) Typed Contract Syntax P ::= defn* e defn \n::= class c extends c implements i* { .eld* meth* }|interface i extends i* { imeth* } field ::= t fd \nmeth ::= t md ( arg*) {body } imeth ::= t md ( arg*) arg ::= t var body ::= e |abstract e ::= new c \n|var |null |e : c .fd |e : c .fd = e |e : t.md (e*) |super =this : c .md (e*) |view t e |let {binding* \n}in e |if ( e ) e else e |true |false |{e ; e }|return : t, c {e }|preErr(e) |postErr(e) |hierErr(e) \nbinding ::= var = e var ::= a variable name or this c ::= a class name or Object i ::= interface name \nor Empty fd ::= a .eld name md ::= a method name t ::= c |i |boolean (c) Core Syntax Figure 1: Contract \nJava syntax; before and after contracts are compiled away Expressions of the shape: return : t, c { e \n} mark method returns. The type t indicates the type of the object whose method was invoked, in parallel \nto the type annotations on method calls, and the class name, c, is the class that de.ned the in\u00advoked \nmethod. Unlike standard Java, in Contract Java the program\u00admer does not write return expressions in the \nprogram. Instead, the evaluator introduces return expressions as it executes the program. These annotations \nare used in the statement and the proof of the contract soundness theorem. There are three important \nrelations on the abstract syntax: =P , PREP , and POSTP . The .rst, =P , de.nes the subtyping rela\u00adtionship. \nA type t is a subtype of another type t' in a program P, written t=P t' , when one of these conditions \nholds: tand t' are the same type, ' '' t and tare both classes, t is derived from tin P, and '' =P t' \nt, tand t' are both interfaces, tis an extension of t'' in P (also '' =P t' written t.P i t'' ), and \nt,or  tis a class and t' is an interface, and either  timplements t' in P, ' timplements an interface \niin P and i=P t,or ' tis derived from a class cin P and c=P t. The relations PREP and POSTP relate expressions \nwith pairs of methods and types. An expression e is the pre-condition for min t in the program P, e PREP \n(t,m), if the expression e appears in the program P, declared as a precondition of m in t. Similarly \nan expression e is a postcondition of m in t in the program P if ePOSTP (t,m).  3.2 Contract Elaboration \nContract checking is modeled as a translation, called T, from syn\u00adtax (b) to syntax (c). Since contract \nchecking is triggered via method calls, we need to understand how T deals with those. Con\u00adsider the following \ncode fragment: IConsole o = ConsoleFactory(...); ... o.display( It s crunch time. ) ... Since the programmer \ncannot know what kind of console o rep\u00adresents at run-time, he can ensure only that the preconditions \nfor display that IConsole speci.es. Hence, the code that T produces for the method call must .rst test \nthe preconditions for display in IConsole. If this test fails, the author of the method call has made \na mistake. If the test succeeds, the contract monitoring code can check the ancestor portion of the class \nand interface hierarchy that is determined by o s class tag.3 These hierarchy checks ensure that the \nprecondition of an overriding method implies the precondition of the overridden method, and that the \npostcondition of an overrid\u00adden method implies the postcondition of each overriding method. To perform \nboth forms of checking, T adds new classes to check the subtype hierarchy and inserts methods into existing \nclasses to check pre-and post-conditions. For each method of a class, the elaborator inserts several \nwrapper methods, one for each type that instances of the class might have. These wrapper methods perform \nthe pre-and post-condition checking and call the hierar\u00adchy checkers. Additionally, the elaborator redirects \neach method call so it invokes the appropriate wrapper method, based on the static type of the object \nwhose method is invoked. So, in the above invocation, the elaborator inserts a display IConsole wrap\u00adper \nmethod into the each console class since each console class can be cast to IConsole. Additionally, it \nrewrites the call to the dis\u00adplay method to call the display IConsole method, since o s type is IConsole. \nEach display IConsole method checks IConsole s pre-condition and the pre-condition hierarchy from the \ninstantiated class upwards. Then the display Console method calls the origi\u00adnal display method. When \nit returns, the display IConsole method checks IConsole s post-condition and the post-condition hierarchy \nfrom the instantiated class upwards. The rest of this subsection presents the elaborator both concretely \nvia the example of the con\u00adsole classes and interfaces, and abstractly via judgements that de\u00ad.ne the \nelaborator. Formally, our contract elaborator is de.ned by these judgements: f P .p P' The program P \ncompiles to the program P ' . P f defn .d defn' defnpre defnpost defn compiles to defn' with checkers \ndefnpre and defnpost in P. P f imeth .i imeth' imeth compiles to imeth'. P,cf meth .m meth' meth compiles \nto meth' in class c. P, c, tf meth .w meth' meth' checks the pre-and post-conditions for t s meth, which \nblames c for contract violations. ' P,cf e .e e e compiles to e' , which blames c for contract violations. \n P,tf imeth .pre imeth' imeth' checks the hierarchy for the pre-condition of imeth in t. P,tf imeth .post \nimeth' imeth' checks the hierarchy for the post-condition of imeth in t. The .rst judgement, -p, is the \nprogram elaboration judgement. The -d judgement builds three de.nitions for each de.nition in the original \nprogram. The .rst is derived from the original de.ni\u00adtion. The second and third are the pre-and post-condition \nhierarchy checking classes, respectively. The -i judgements erases interface method contracts. The -m \n, -e, and -w judgements produce the annotated class. The -w 3Following ML tradition, we use the word \ntype to refer only to the static type determined by the type checker. We use the words class tag to refer \nto the so-called dynamic or run-time type.    defni f imethj i imeth'P,cf imethj pre methjpre P,cf \nimethj post methjpost for j . [1,n] j P f interface i extends i1 ... il imeth1 ... imethn d interface \ni extends i1 ... il imeth'... imeth' 1 n class check i pre imeth1pre ... imethnpre class check i post \nimeth1post ... imethnpost defnc P,cf methj m meth'P,cf methj pre methjpre P,cf methj post methjpost \nfor j . [1,n] j P, c, tf methj w wrapt methodj for j . [1,n], and tsuch that c =P t P f class c extends \nc' implements i1 ... il d class c extends c' implements i1 ... il meth1 ... methnmeth'... meth' 1 n wrapt \nmethod1 ... wrapt methodn ... class check c pre extends Object meth1pre ... methnpre class check c post \nextends Object meth 1post ... methnpost wrap '' eb PREP (t,md) ea POSTP (t,md) P,cf eb e eP,cf ea e \ne ba P, c, tf t' md (t1 x1, ..., tj xj) ... w t' t md (t1 x1, ..., tj xj , string cname) { ' if (e) \n{ b (new check c pre()).md(this, x1, ..., xj ); let { md = this.md(x1, ..., xj ) } ' in { if (e) a \n(new check c post()).md( dummy , true, this, md, x 1, ..., xj); else postErr(c); md }} else {preErr(cname); \n}} i pre P i' for all i' such that i .i P,if tmd (t1 var1 ... tn varn) { e } @pre { eb } @post { ea \n} pre boolean md (i this, t1 var1, ... tn varn) {let { next = (new check i' pre()).md(this, var1, ..., \nvarn) || ... res = eb }in if (!next || res)// next . res res else hierErr(i) } posti P i' for all \ni' such that i .i P,if tmd (t1 var1 ... tn varn) { e } @pre { eb } @post { ea } post boolean md (String \ntbb, boolean last, i this, t md, t 1 var1, ..., tn varn) {let { res = ea }in if (!last || res)// last \n. res (new check i' post()).md(c, res, this, md, var1, ..., varn)&#38;&#38; ... else hierErr(tbb) } \n calli '' P,cf e e eP,cf ej: i e efor j . [1,n] j ' '' P,cf e: i.md (e1, ..., en) e e.i md(e1, ..., \ne) n Figure 2: Blame Compilation constructs the wrapper methods that check the contracts. The -m judgement \nre-writes methods and erases class method contracts. The -e judgement rewrites expressions so that method \ncalls are re-directed to the wrapper methods, based on the type of the call. The .nal two judgements, \n-pre and -post, produce the methods for the pre-and post-condition hierarchy checkers. The important \nclauses for those judgements are given in .gure 2. The remainder of this section illustrates how the \njudgements work, using the console example from section 2. As the [defnc] rule and the [defni] rule show, \neach de.nition in the original program generates a de.nition and two additional classes. The .rst de.nition \ncorresponds to the original de.nition, with the contracts erased and, in the case of classes, wrapper \nmethods in\u00adserted. These wrapper methods check for pre-condition and post\u00adcondition violations, and invoke \nthe hierarchy checkers. The elab\u00adorator inserts wrapper methods based on the types that instances of \nthe class might have. Consider the Console class of section 2. The elaboration adds two wrapper methods \nfor getMaxSize, because instances of Console can have two types: IConsole and Console. The elaborator \nalso adds two wrapper methods for display: class Console implements IConsole {int getMaxSize() { ... \n} @post { ... }int getMaxSize IConsole ... int getMaxSize Console ... void display(String s) { ... } \n@pre { ... } void display IConsole ... void display Console ... } Similarly, for RunningConsole and PrefixedConsole, \nT adds three methods, since instances of each of those classes may take on three types. Here is RunningConsole: \nclass RunningConsole extends Console {int getMaxSize() { ... } @post { ... }int getMaxSize IConsole ... \nint getMaxSize Console ... int getMaxSize RunningConsole ... void display(String s) { ... } @pre { ... \n} void display IConsole ... void display Console ... void display RunningConsole ... } The [wrap] rule \nspeci.es the shape of the wrapper methods. It uses the program P, the class c where the wrapper method \nappears, the type t at which the method is being called, and the method header t ' md (t1 x1, ..., tj \nxj). The wrapper method accepts the same arguments that the original method did, plus one extra ar\u00adgument \nnaming the class whose program text contains the method call. The wrapper method .rst checks the pre-condition \ne b' .If it fails, it blames the calling context for not establishing the required pre-condition. If \nthe pre-condition succeeds, the wrapper calls the pre-condition hierarchy checker for c. The pre-condition \nhierarchy checker traverses the class and interface hierarchy, making sure that each subtype is a behavioral \nsubtype, for the pre-conditions. If the hierarchy checking succeeds, the wrapper method calls the original \nmethod. After the method returns, it saves the result in the variable md, checks the post-condition, \ne ' a and calls the post-condition hier\u00adarchy checker. Like the pre-condition hierarchy checkers, the \npost\u00adcondition hierarchy checker ensures that each subtype is a behav\u00adioral subtype, for the post-conditions. \nFinally, if the post-condition checking succeeds, the wrapper method delivers the result of the wrapped \nmethod. Additionally, the [wrap] rewrites the contract expressions them\u00adselves so that pre-and post-condition \nof methods invoked by the contracts are also checked. Here is Console s display Console wrapper method. \n4 void display Console(String s, string cname) { if ( s.length() < this.getMaxSize() ) { (new check Console \npre()).display(this, s); let { display = this.display(s) } in { (new check Console post()) .display( \ndummy , true, this, display, s); } } else { preErr(cname); } } The original console class s display \nmethod has no post-condition, so the if-expression from the [wrap] rule is eliminated. The vari\u00adable \ndisplay is bound to the result of the method, for the post\u00adcondition. The .rst two arguments to check \nConsole post are initial values for accumulators and are explained below. The second and third classes \nde.nitions introduced by the [defn i] and [defnc] rules are the hierarchy checkers. Each hierarchy checker \nis responsible for checking a portion of the hierarchy and combining its result with the rest of the \nhierarchy checkers. Unlike pre-and post-condition checking, hierarchy checking begins at the class tag \nfor the object; it is not based on the static type of the ob\u00adject. As an example, consider the hierarchy \ndiagram in .gure 3 and this code fragment: Io = new C(); o.m(); When m is invoked, the hierarchy checkers \nmust ensure that the hi\u00aderarchy is well-formed. Since instances of C can never be cast to D or K, only \nthe boxed portion of the hierarchy in .gure 3 is checked. Thus, when o s m is invoked, the hierarchy \nchecking classes en\u00adsure that I s pre-condition implies C s pre-condition and that J s pre-condition \nalso implies C s pre-condition. Similarly, when m returns, only I, J, and C s post-conditions are checked \nto ensure the post-condition hierarchy is well-formed, too. 4We omit the annotations inserted by the \ntype-checker to clarify the presentation. IJ ... . .. .. CK .. . . .. .. D Figure 3: Example Hierarchy \nDiagram In our running console example, the following classes are gener\u00adated: check IConsole pre,  \ncheck Console pre,  check RunningConsole pre,  check Pre.xedConsole pre,  check IConsole post,  check \nConsole post,  check RunningConsole post, and  check Pre.xedConsole post.  Each of the hierarchy-checking \nclasses has a method for each meth\u00adod in the original class. The methods in the hierarchy-checking classes \nhave the same names as the methods in the original class, al\u00adthough their purpose is different. The hierarchy \nchecking methods check the pre-or post-condition for that method. Then they com\u00adbine that result with \nthe results of the rest of the hierarchy checking to determine if there are any hierarchy violations. \nIn our example, each hierarchy checking class contains a getMaxSize method and a display method. The \n[prei] rule produces the pre-condition hierarchy checker for the md method of the interface i. The resulting \nmethod accepts the same arguments that md accepts, plus a binding for this. The this argument is passed \nalong so the contract checking code can test the state of the object. The hierarchy checking method returns \nthe result of the pre-condition for md. First, it recursively calls the hierarchy checkers for each of \nthe immediate super-interfaces of i and combines their results in a disjunction. Second, it evaluates \nthe pre-condition for md. Finally, the checker ensures that the hi\u00aderarchy is well-formed by checking \nthat the pre-conditions for the super-methods imply the current pre-condition. If the implication holds, \nthe checker returns res, the value of this pre-condition. If the implication does not hold, the hierarchy \nchecker method signals a hierarchy error and blames i, the extending interface. The rule for classes \nis analogous. The pre-condition checkers for RunningConsole and Console dis\u00adplay methods are:    \n   class check RunningConsole pre extends Object { boolean display (RunningConsole this, String s) \n{ let { next = (new check Console pre()).display(this, s) res = true } in if (!next || res) // next . \nres res else hierErr( RunningConsole ) } } and class check Console pre extends Object { boolean display \n(Console this, String s) { let { next = (new check IConsole pre()).display(this, s) res = s.length() \n< this.getMaxSize() } in if (!next || res) // next . res res else hierErr( Console ) } } The [posti] \nrule speci.es the post-condition hierarchy checking method. The post-condition hierarchy checker is similar \nto the pre\u00adcondition checker. Rather than returning the truth value of each condition, however, the post-condition \nchecker accumulates the re\u00adsults of the conditions in the last argument. Using an accumulator in this \nfashion means the post-condition checker uses the same re\u00adcursive traversal of the type hierarchy as \nthe pre-condition checker, but checks the implications in the reverse direction. The tbb argu\u00adment is \nalso an accumulator. It represents the subclass to be blamed if the implication does not hold. As mentioned \nabove, the initial values for the accumulators tbb and last are dummy and false, respectively. Since \nthe post-condition checker for a particular class actually blames a subclass for a hierarchy violation, \nthe .rst post\u00adcondition checker never assigns blame. The initial false passed via last guarantees that \nno blame is assigned in the .rst checker and that dummy is ignored. Additionally, the highest class or \ninter\u00adface in the hierarchy can never be blamed, since it cannot possibly violate the hierarchy. Here \nis the code for the post-condition hierarchy checker for get-MaxSize in both RunningConsole and Console: \nclass check RunningConsole post extends Object { boolean getMaxSize (String tbb, boolean last, RunningConsole \nthis, int getMaxSize) { let { res = getMaxSize > 0 } in if (!last || res) // last . res (new check Console \npost()) .getMaxSize( RunningConsole , res, this, getMaxSize) else hierErr(tbb) }} and class check Console \npost extends Object { boolean getMaxSize (String tbb, boolean last, Console this, int getMaxSize) {let \n{ res = getMaxSize > 0 } in if (!last || res) // last . res (new check IConsole post()) .getMaxSize( \nConsole , res, this, getMaxSize) else hierErr(tbb) } } Finally, the [calli] rule shows how the elaboration \nre-writes method calls. Each method call becomes a call to a wrapper method, based on the type of the \nobject whose method is invoked. For example, this code fragment: IConsole o = ConsoleFactory(... ); o.display( \nIt s crunch time ); is rewritten to this: IConsole o = ConsoleFactory(... ); o.display IConsole( It s \ncrunch time ); Figure 4 gathers the code fragments of our running example. The left column contains the \nproper interfaces and classes, enriched with wrapper methods. The right column contains the hierarchy \nchecking classes, plus the translation of the method call.  3.3 Evaluation The operational semantics \nfor Contract Java is de.ned as a con\u00adtextual rewriting system on pairs of expressions and stores [6, \n23]. Each evaluation rule has this shape: P f(e, S) '.(e, S) [reduction rule name] A store (S) is a mapping \nfrom objects to class-tagged .eld records. A .eld record (F) is a mapping from .eld names to values. \nWe consider con.gurations of expressions and stores equivalent up to a-renaming; the variables in the \nstore bind the free variables in the expression. Each e is an expression and P is a program, as de.ned \nin .gure 1. The complete evaluation rules are in Figure 5. For example, the call rule models a method \ncall by replacing the call expression with the body of the invoked method and syntactically replacing \nthe for\u00admal parameters with the actual parameters. The dynamic aspect of method calls is implemented \nby selecting the method based on the run-time type of the object (in the store). In contrast, the super \nre\u00adduction performs super method selection using the class annotation that is statically determined by \nthe type-checker. Both call and super expressions reduce to return expressions. The return expressions \nare markers that signal where post-condition contract violations might occur. They are inserted by method \ncall and super call reductions for the statement of the contract sound\u00adness theorem.  4. CONTRACT SOUNDNESS \nA contract monitoring system must have two properties. First, at a minimum, it must preserve the semantics \nof the programming lan\u00adguage. Second, contract monitoring must guarantee certain proper\u00adties for the \nevaluation of a program. Since contracts in our model are arbitrary Java expressions, they may have side-effects \nor raise errors and may thus affect the behav\u00adior of the underlying program. Considering the role of \ncontracts, this is undesirable. We therefore restrict our attention to contracts that are effect-free.5 \nDEFINITION 1(EFFECT-FREE EXPRESSION). An expression e is effect-free if for any store S such that the \nfree variables of e are included in dom(S), there exists a value v such that (e,S) .. * (v, S). The key \nto this de.nition is that the effect-free expressions evaluate to a value without changing the store \nor signalling an error. This does not mean that e never allocates, however. Since garbage col\u00adlection \nis modeled as a non-deterministic reduction step, a contract expression e may allocate as long as the \nnewly allocated objects are garbage when the evaluation of the contract produces a value. Kleene equality, \nanother supplementary de.nition, is used as the equality on programs. Informally, it states that terminating \npro\u00adgrams are equivalent when both produce the same answer or the same error. Additionally, all non-terminating \nprograms are equiva\u00adlent. DEFINITION 2(KLEENE EQUALITY). Two programs P1 and P2 are Kleene equal if one \nof the following conditions holds: (P1, \u00d8) . and (P2, \u00d8) .,  (P1, \u00d8) .. * (v, S) and (P2, \u00d8) ..* (v, \nS) for some store S and value v  (P1, \u00d8) .. * ( error: str,S1) and (P2, \u00d8) ..* ( error: str,S2) for \nsome stores S1 and S2 and error message str.  De.nition 4 speci.es coherence. Intuitively, coherence \nguarantees that the contract checker preserves the meaning of programs that do not violate any contracts. \nTo de.ne coherence, we use a trivial contract elaborator, Erase, which merely erases the contracts and \ndoes not insert any calls to the error-signalling primitives. DEFINITION 3(ELABORATION COHERENCE). An \nelaboration T from annotated Contract Java (syntax (b) in .gure 1) to unanno\u00adtated Contract Java (syntax \n(c) in .gure 1) is coherent if for any program P whose pre-and post-conditions are all effect-free ex\u00adpressions, \none of the following conditions holds: T(P) is Kleene equal to Erase(P), 5In practice, there are many \napproaches to enforcing this restric\u00adtion, each with different pros and cons. interface IConsole {int \ngetMaxSize(); void display(String s); } class Console implements IConsole { int getMaxSize() { ... } \nint getMaxSize IConsole ... int getMaxSize Console ... void display(String s) { ... } void display IConsole \n... void display Console(String s, string cname) { if ( s.length() < this.getMaxSize() ) {(new check \nConsole pre()).display(this, s); let { display = this.display(s) }in { (new check Console post()).display \n( dummy , true, this, display, s); } } else { preErr(cname); }}} class RunningConsole extends Console \n{int getMaxSize IConsole ... int getMaxSize Console ... int getMaxSize RunningConsole ... void display(String \ns) { ... super.display (String.substring (s, ..., ... + getMaxSize())) ... } void display IConsole ... \nvoid display Console ... void display RunningConsole ... } class PrefixedConsole extends Console {int \ngetMaxSize IConsole ... int getMaxSize Console ... int getMaxSize.PrefixedConsole ... String getPrefix() \n{ return >> ; } void display(String s) { super.display(this.getPrefix() + s) } void display IConsole \n... void display Console ... void display.PrefixedConsole ... } class check IConsole pre { ... } class \ncheck Console pre extends Object {boolean display (Console this, String s) {let { next = (new check IConsole \npre()).display(this, s) res = s.length() < this.getMaxSize() }in if (!next || res) // next . res res \nelse hierErr( Console )}}  class check RunningConsole pre extends Object {boolean display (RunningConsole \nthis, String s) {let { next = (new check Console pre()).display(this, s) res = true }in if (!next || \nres) // next . res res else hierErr( RunningConsole )  }} class check Pre.xedConsole pre { ... } class \ncheck IConsole post { ... } class check Console post extends Object {boolean getMaxSize (String tbb, \nboolean last, Console this, int getMaxSize) { let { res = getMaxSize > 0 } in if (!last || res) // last \n. res (new check IConsole post()) .getMaxSize( Console , res, this, getMaxSize) else hierErr(tbb)  \n}} class check RunningConsole post extends Object {boolean getMaxSize (String tbb, boolean last, RunningConsole \nthis, int getMaxSize) {let { res = getMaxSize > 0 }in if (!last || res) // last . res (new check Console \npost()) .getMaxSize( RunningConsole , res, this, getMaxSize) else hierErr(tbb)  }} class check Pre.xedConsole \npost { ... } IConsole o = ConsoleFactory(...); o.display IConsole( It s crunch time ); Figure 4: Elaborated \nConsole Example E = [] |E : c .fd |E : c .fd = e |v : c .fd = E e = ... |object | E.md(e ...) |v.md(v \n... E e ...) v = object |null | super =v : c .md(v ... E e ...) true |false | view tE |if ( E ) e else \ne |{E ; e }| let var = v ... var = E var = e ... in e P f(E[object : t.md(v1, ..., vn)], S)'.(E[return \n: t, c {e[object/this, v1/var1, ... vn/varn]}], S) [call] c where S(object)=(c, F)and (md,(t1 ...tn \n-. t), (var1 ... varn), e).P c P f(E[super =object : c .md(v1, ..., vn)], S) [super] '.(E[return : c, \nc {e[object/this, v1/var1, ... vn/varn]}], S) c where (md,(t1 ...tn -. t), (var1 ... varn), e).P c P \nf(E[return : t, c {v }], S)'.(E[v], S) [return] P f(E[new c], S)'.(E[object], S[objectd.(c, F)]) [new] \n' c '' c where object .dom(S)and F = {c .fdd.null |c=c and .ts.t. (c .fd, t)..c ' } P P ' P f(E[object \n: c .fd], S)'.(E[v], S) [get] ' where S(object)=(c, F)and F(c .fd)=v ' ' P f(E[object : c .fd = v], \nS)'.(E[v], S[objectd.(c, F[c .fdd.v])]) [set] where S(object)=(c, F) P f(E[view t ' object], S)'.(E[object], \nS) [cast] ' where S(object)=(c, F)and c=P t P f(E[let var1 = v1 ... varn = vn in e], S)'.(E[e[v1/var1 \n... vn/varn]], S) [let] P f(E[if ( true ) e1 else e2], S)'.(E[e1], S) [iftrue] P f(E[if ( false ) e1 \nelse e2], S)'.(E[e2], S) [iffalse] P f(E[{v ; e }], S)'.(E[e], S) [seq] P f(E[preErr(c)], S)'.(error: \nc violated pre-condition, S) [pre] P f(E[postErr(c)], S)'.(error: c violated post-condition, S) [post] \nP f(E[hierErr(t)], S)'.(error: tis a bad extension, S) [hier] P f(E[view t ' object], S)'.(error: bad \ncast, S) [xcast] where S(object)=(c, F)and c =P t ' P f(E[view t ' null], S)'.(error: bad cast, S) [ncast] \nP f(E[null : c .fd], S)'.(error: dereferenced null, S) [nget] P f(E[null : c .fd = v], S)'.(error: dereferenced \nnull, S) [nset] P f(E[null.md(v1, ..., vn)], S)'.(error: dereferenced null, S) [ncall] Figure 5: Operational \nsemantics for Contract Java  (T(P),\u00d8) ..* (error: c violated pre-condition,S), for some store S;  (T(P),\u00d8).. \n* (error: c violated post-condition,S), for some store S;  (T(P),\u00d8).. * (error: tis a bad extension,S), \nfor some store S.  Our elaboration does not change any expressions except method calls. Furthermore, \nthe wrapper methods have no effect if the con\u00adtracts have no effect and evaluate to true. If any contract \ndoes eval\u00aduate to false, our contract checker is guaranteed to signal one of the three errors listed \nabove. Thus, our elaboration T is coherent. De.nition 4 speci.es contract soundness. Intuitively, soundness \nguarantees that elaborated programs respect the contracts of the original program. More concretely, if \na program that the contract elaborator produces does not signal a contract error, the contract\u00aderased \nprogram must be contract sound at each step of its evalua\u00adtion. DEFINITION 4(CONTRACT SOUNDNESS). An \nelaboration T is contract sound if for any program P whose pre-and post\u00adconditions are effect-free expressions, \none of the following condi\u00adtions holds: (T(P),\u00d8) .. * (error: c violated pre-condition,S), for some \nstore, S,  (T(P),\u00d8).. * (error: c violated post-condition,S), for some store, S,  (T(P),\u00d8).. * (error: \nt is a bad extension,S), for some store, S,or  For each state (P ' ,S ' )such that (Erase(P),\u00d8) .. \n* (P ' ,S ' ), (P ' ,S ' ) is locally contract sound with respect to P (recall that Erase(P)is just P, \nbut with the contract annotations erased).  Roughly, local contract soundness for a con.guration (e,S)means \nthat in the given store S, the contracts about e hold and that the necessary relations between contracts \nin ehold as well. More pre\u00adcisely, all states that do not perform a method call or a method return are \nlocally contract sound. A state that is about to evaluate a method call is locally sound if the two conditions \nare true. First, the pre-condition on the method must be satis.ed. Second, the pre-condition hierarchy \nmust be behaviorally well-formed. That is, each type s pre-condition must imply each of its subtypes \npre\u00adconditions, for the method about to be invoked. Similarly, a state that is about to perform a method \nreturn is locally sound if the post\u00adcondition on the method is satis.ed and the post-condition hierar\u00adchy \nis behaviorally well-formed. DEFINITION 5(LOCAL CONTRACT SOUNDNESS). A program state (e,S) is locally \ncontract sound with respect to a Contract Java program P, if one of the following conditions holds: e=E[o.m \n: t(v1, v2, ..., vk)] and S(o)=(c,F) and if there exists a y such that y PRE P (t,m), then (y,S).. * \n(true,U)for some store U. and for any s,s ' such that c=P s=P s ' , if there exists an xand x ' such \nthat xPREP (s,m), x ' PREP (s ' ,m), then (x,S) .. * (b,T), (x ' ,S).. * (b ' ,T ' ), and b ' .b e=E[return \n: t,c {v}] and if there exists a y such that y POST P (t,m), then (y,S).. * (true,U)for some store U. \nand for any s,s ' such that c=P s=P s ' , if there exists an xand x ' such that xPOSTP (s,m), x ' POSTP \n(s ' ,m), then (x,S) .. * (b,T), (x ' ,S).. * (b ' ,T ' ), and b.b ' . e is neither a method call or \nmethod return. THEOREM 5. The elaboration T is contract sound. PROOF SKETCH. Let P be a program. Assume \nthat T(P)does not signal a contract error. If T(P)is to be contract sound, we must show that each reduction \nstep of Erase(P)is locally contract sound. Lemma: T(P) takes every reduction step that Erase(P) takes. \nSince the elaboration does not change any expressions except meth\u00adod calls, Erase(P)and T(P) are synchronized, \nas long as there are no method calls. Let us consider the .rst method call. The reductions for Erase(P)look \nlike this: (Erase(P),\u00d8) .. \u00b7\u00b7\u00b7 ..(E[o.m : t(v1, ... , vn)] ,S) ..(E[return : t, cb[x1/v1 ... xn/vn],S) \nSince the ellipses do not contain any method calls, the reductions up to the .rst method call are identical \nfor T(P). Then, the elabo\u00adrated version calls the wrapper method. We know that the wrapper method does \nnot have any effects, since their contract expressions are effect-free and T(P)does not signal a pre-condition \nerror or a hierarchy error. Thus, the reduction sequence looks like this: (T(P),\u00d8) .. \u00b7\u00b7\u00b7 ..(E[o.m t(v1, \n..., vn)] ,S).. \u00b7\u00b7\u00b7 ..(E[F[o.m : t(v1, ..., vn)]] ,S)  ..(E[F[return : t, cb[x1/v1 ... xn/vn]],S) The \nextra context, F, is the remainder of the wrapper method that checks the post-conditions and the post-condition \nhierarchy. Since the post-conditions are effect-free and T(P)does not raise a hi\u00aderarchy error or a post-condition \nerror, that code has no effect on the computation. Pictorially, the two reduction sequences look like \nthis: . . Erase(P) T(P) is a tautology and since . \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7 postsuper and posttype =.postsuper . .. . \n. . . . . . . . .  is also a tautology, these tools cannot detect malformed pre\u00ad \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7    pre-condition \npost-condition condition or post-condition hierarchies. Put differently, when checking checking for the \n.rst method call. The smaller arrows are the extra steps that T(P) takes, before and after each method \ncall. By an induc\u00adtive argument, we can conclude for each reduction that Erase(P) takes, T(P) also takes \nthe same reduction step, possibly with extra context that is the contract enforcement. Thus, the lemma \nholds. Now, using the lemma, we can prove the theorem. Let (e,S)be a stepinthereductionsequencestarting \nfrom Erase(P).If e does not decompose into some evaluation context and a method call or some evaluation \ncontext and a return instruction, it is locally hierarchy sound. Assume that it does decompose into a \ncontext and a method call. Now, we must show that the .rst bullet from de.nition 4 is true. Since T(P) \nreached the same method call by the previous argument, we know that the wrapper method was invoked. From \nthe [wrap] rule in .gure 2, we can see that the pre-condition check must have succeeded. All that remains \nis to show this: for any s,s ' such that c=P s=P s ' , if there exists an xand x ' such that xPREP (s,m), \nx ' PREP (s ' ,m), then (x,S) .. * (b,T), (x ' ,S).. * (b ' ,T ' ), and b ' .b This states that if \nthere are two types, s, and s ' with pre-conditions xand x ' that evaluate to band b ' , we must have \nb . b ' . Since the hierarchy checkers traverse the entire hierarchy checking that the pre-condition \nof each type implies the pre-condition of each of its subtypes, this holds. Thus, this step is locally \nhierarchy sound. Similarly, if e decomposes into a context and a method return, T(P) must also have returned \nand the wrapper method s code must have been invoked, so this step is also locally contract sound. . \n 5. RELATED WORK The calculus of Contract Java and its contract soundness theorem show what it means \nto monitor and enforce contracts in an object\u00adoriented world. They are analogous to typed lambda calculi \nwith constants and primitives and type soundness theorems. Using type soundness theorems, we can analyze \nthe type systems of exist\u00ading languages, say ML, and pinpoint their .aws. Similarly, we can study existing \ncontract enforcement mechanisms and determine how well they monitor the contracts in a program. Many \nexisting contract checking systems [4, 7, 9, 10, 11, 12, 17, 20] collect all pre-conditions of a method \nand its super-methods in a disjunction.6 Similarly, they collect the post-conditions of a method and \nits super-methods in a conjunction. Since =or presuper .presuper pretype 6Kiev s manual [10] seems to \nstate that it treats pre-and post\u00adcondition on derived methods in this manner, but we were unable to \nget Kiev to run. the tools rewrite the programmer s contracts, they assume that a programmer does not \nmake mistakes concerning the relationship of pre-conditions on methods and their super-methods or post\u00adconditions \non methods and their super-methods. Instead they as\u00adsume that the implementor of a class has a perfect \nunderstanding of the superclass s contracts and merely adds additional speci.\u00adcations. We believe that \nit is ironic that tools that check a pro\u00adgrammer s capability to maintain contracts for procedure-like \ncode trust the programmer when it comes to the even more subtle task of forming correct hierarchies of \ncontracts. Some tool designers are aware of the problem. For example, Kan\u00addorman et al. [9] point out \nthat re-writing the programmer s con\u00adtracts in the above-mentioned manner leads to undetected contract \nviolations and malformed type hierarchies. Here is their example: interface I {int m(int a); @pre { a \n> 0 }} The interface contains a single method, m, with the pre-condition requirement that a is greater \nthan 0. Now, imagine this extension: interface J extends I {int m (int a); @pre { a > 10 }} Since J extends \nI, the pre-condition for I should imply the pre\u00adcondition for J. That is not the case here. A witness \nto the fail\u00adure of the implementation is a method call where a is 5. Thus, the interface extension is \nfaulty, when judged with the programmer s original contracts. Unfortunately, rewriting a series of pre-conditions \ninto a disjunc\u00adtion cannot reveal the problem. Because (a> 0) =.(a>0) or (a> 10) is always true, none \nof these contract enforcement tools reveal that J s implementor did not properly understand the precondition \nof m in the interface I. In short, contract monitoring systems that rewrite hierarchy contracts into \nconjunctions and disjunctions are not con\u00adtract sound in the sense of our theorem. While this example \nmay look arti.cial at .rst glance, it is just an abstract version of the console example from section \n2. As a test, we translated IConsole, Console and PrefixedConsole to iContract syntax [12], using 4 as \nthe maximum and a dummy display routine that just prints to stdout. We created a main method that invokes \nthe PrefixedConsole s display method with the string abc , as follows: new PrefixedConsole().display( \nabc ); This call is erroneous, since the pre-condition on Pre.xedConsole s display method requires the \ninput to be a string of at most one char\u00adacter. iContract responded with this error message:7 java.lang.RuntimeException: \nerror: precondition violated (Console::display(String)): (/*declared in IConsole::display(String)*/ (s.length() \n< this.getMaxSize())) at Console.display at PrefixedConsole.display at Main.main iContract blames \nthe call to super.display inside Pre.xedConsole s display method, rather than blaming the hierarchy or \nthe caller of Pre.xedConsole s display. In general, any tool that rewrites the programmer s pre-and post-conditions \nin this manner would pro\u00adduce an analogous result for this program, and would cause pro\u00adgrammers to look \nfor errors in the wrong place. Jass [2, 3] is the only contract checker for Java that can discover errors \nin the type hierarchy. To discover hierarchy errors with Jass, a programmer must specify a simulation \nmethod that creates an object of a supertype from the current object. The contract checker uses the simulation \nmethod to create a supertype object each time a method is called or a method returns. Then, it checks \nthat the relevant contracts of the supertype object and the original object are related via the proper \nimplications. If not, the contract checker signals a hierarchy error. Jass and Contract Java differ in \nmany respects. First, subtypes in Contract Java must function on the same state space as their respec\u00adtive \nsupertypes. This implies that the programmer doesn t have to de.ne a simulation method, and that the \nchecks are signi.cantly cheaper than Jass s because no new objects are created. Second, Contract Java \ns notion of subtyping naturally extends to interfaces, unlike Jass s. Third, Contract Java checks the \nentire portion of a hi\u00aderarchy atop a given method, rather than just a single step. Finally, our model \ncomes with a contract soundness theorem. 6. IMPLEMENTATION FOR FULL JAVA The Contract Java elaborator \ngiven in section 3.2 produces inef\u00ad.cient Java code. There are several changes to the calculus that would \nimprove the ef.ciency of the generated code. First, many of the hierarchy checking classes can be eliminated. \nFor class def\u00adinitions, hierarchy checking methods can be added directly to the class. For interface \nde.nitions, a single class with static methods can hold all of the hierarchy checkers. Second, in the \ncase of a single inheritance hierarchy, the hierarchy checking can be turned into a loop. Finally, the \nvalue of the initial pre-condition test can be saved and re-used during the pre-condition hierarchy checking. \nSimilarly, the value of the post-condition test can be re-used during the post-condition hierarchy checking. \nSome of these issues are considered in more detail in a companion paper [5]. 7. CONCLUSION This paper \npresents Contract Java, a calculus of Java programs with contracts. These contracts come as pre-and post-conditions \non 7iContract s response has been edited for clarity and formatting. methods in classes and interfaces. \nThe calculus speci.es how pro\u00adgrams with contracts are elaborated into plain Java programs with code \nthat enforces the integrity of contracts. This code speci.cally enforces four properties of method calls \nand returns, respectively: the pre-conditions hold for a method call; the post-conditions hold for a \nmethod return; the pre-conditions of a method imply the pre\u00adconditions of overriding methods in the subtypes; \nand the post\u00adconditions of a method are implied by the post-conditions of over\u00adridden methods in the \nsupertypes. Our contract soundness theorem guarantees that the last two items are properly enforced as \nfar as the programmer-stated contracts are concerned. Contract Java is the .rst complete semantic account \nof run-time en\u00adforced contracts in an object-oriented setting. The contract sound\u00adness theorem is a formal \nsummary of its properties, especially with respect to behavioral subtyping. Our work thus .lls a gap \nbetween the established theory of behavioral subtyping [1, 14, 15] and es\u00adtablished practice of contract \nchecking for Java [2, 3, 4, 9, 10, 12, 17] and object-oriented languages in general [7, 11, 20]. ACKNOWLEDGEMENTS \nThanks to Philippe Meunier for his detailed comments on a draft of this paper. We also thank Daniel Jackson, \nShriram Krishnamurthi, andClemensSzyperskiforvaluablediscussionsaboutthiswork. In addition, we gratefully \nacknowledge the support of the NSF (CCR\u00ad9619756) and Texas ATP (#003604-0126-1999). 8. REFERENCES [1] \nAmerica, P. Designing an object-oriented programming language with behavioural subtyping. In Proceedings \nof Foundations of Object-Oriented Languages, volume 489 of Lecture Notes in Computer Science, pages 60 \n90. Springer-Verlag, 1991. [2] Bartetzko, D. Parallelit\u00a8at und Vererbung beim Programmieren mit Vertrag. \nDiplomarbeit, Universit\u00a8at Oldenburg, April 1999. [3] Bartetzko, D., C. Fischer, M. Moller and H. Wehrheim. \nJass -Java with assertions. In Workshop on Runtime Veri.cation, 2001. held in conjunction with the 13th \nConference on Computer Aided Veri.cation, CAV 01. [4] Duncan, A. and U. H\u00a8olze. Adding contracts to Java \nwith handshake. Technical Report TRCS98-32, The University of California at Santa Barbara, December 1998. \n[5] Findler, R. B., M. Latendresse and M. Felleisen. Behavioral contracts and behavioral subtyping. In \nProceedings of ACM Conference Foundations of Software Engineering, 2001. [6] Flatt, M., S. Krishnamurthi \nand M. Felleisen. Classes and mixins. In Proceedings of ACM Conference Principles of Programming Languages, \npages 171 183, Janurary 1998. [7] Gomes, B., D. Stoutamire, B. Vaysman and H. Klawitter. A Language \nManual for Sather 1.1, August 1996. [8] Gosling, J., B. Joy and G. Steele. The Java(tm) Language Speci.cation. \nAddison-Wesley, 1996. [9] Karaorman, M., U. H\u00a8olzle and J. Bruno. jContractor: A re.ective Java library \nto support design by contract. In Proceedings of Meta-Level Architectures and Re.ection, volume 1616 \nof lncs, July 1999. [10] Kizub, M. Kiev language speci.cation. http://www.forestro.com/kiev/, 1998. \n[11] K\u00a8olling, M. and J. Rosenberg. Blue: Language Speci.cation, version 0.94, 1997. [12] Kramer, R. \niContract the Java design by contract tool. In Technology of Object-Oriented Languages and Systems, \n1998. [13] Leavens, G. T., K. R. M. Leino, E. Poll, C. Ruby and B. Jacobs. JML: notations and tools supporting \ndetailed design in Java. In Object-Oriented Programming, Systems, Languages, and Applications Companion, \npages 105 106, 2000. Also Department of Computer Science, Iowa State University, TR 00-15, August 2000. \n[14] Liskov, B. H. and J. Wing. Behavioral subtyping using invariants and constraints. Technical Report \nCMU CS-99-156, School of Computer Science, Carnegie Mellon University, July 1999. [15] Liskov, B. H. \nand J. M. Wing. A behavioral notion of subtyping. ACM Transactions on Programming Languages and Systems, \nNovember 1994. [16] Luckham, D. C. and F. von Henke. An overview of Anna, a speci.cation language for \nAda. In IEEE Software, volume 2, pages 9 23, March 1985. [17] Man Machine Systems. Design by contract \nfor Java using jmsassert. http://www.mmsindia.com/DBCForJava.html, 2000. [18] Meyer, B. Object-oriented \nSoftware Construction. Prentice Hall, 1988. [19] Meyer, B. Applying design by contract. IEEE Computer, \n25(10):40 51, October 1992. [20] Meyer, B. Eiffel: The Language. Prentice Hall, 1992. [21] Milner, R. \nA theory of type polymorphism in programming. Journal of Computer Systems Science, 17:348 375, 1978. \n[22] Rosenblum, D. S. A practical approach to programming with assertions. IEEE Transactions on Software \nEngineering, 21(1):19 31, Janurary 1995. [23] Wright, A. and M. Felleisen. A syntactic approach to type \nsoundness. Information and Computation, pages 38 94, 1994. .rst appeared as Technical Report TR160, Rice \nUniversity, 1991.  \n\t\t\t", "proc_id": "504282", "abstract": "<p>Checking pre- and post-conditions of procedures and methods at runtime helps improve software reliability. In the procedural world, pre- and post-conditions have a straightforward interpretation. If a procedure's pre-condition doesn't hold, the caller failed to establish the proper context. If a post-condition doesn't hold, the caller failed to establish the proper context. If a post-condition doesn't hold, the procedure failed to compute the expected result.</p> <p>In the object-oriented world, checking pre- and post-conditions for methods, often called contracts in this context, poses complex problems. Because methods may be overridden, it is not sufficient to check only pre- and post-conditions. In addition, the contract hierarchy must be checked to ensure that the contracts on overridden methods are properly related to the contracts on overriding methods. Otherwise, a class hierarchy may violate the substitution principle, that is, it may no longer be true that an instance of a class is substitutable for objects of the super-class.</p> <p>In this paper, we study the problem of contract enforcement in an object-oriented world from a foundational perspective. More specifically, we study contracts as refinements of types. Pushing the analogy further, we state and prove a contract soundness theorem that captures the essential properties of contract enforcement. We use the theorem to illustrate how most existing tools suffer from a fundamental flaw and how they can be improved.</p>", "authors": [{"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "Rice University", "person_id": "PP14022884", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Rice University", "person_id": "PP39037684", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/504282.504283", "year": "2001", "article_id": "504283", "conference": "OOPSLA", "title": "Contract Soundness for object-oriented languages", "url": "http://dl.acm.org/citation.cfm?id=504283"}