{"article_publication_date": "10-01-2001", "fulltext": "\n Portable Resource Control in Java Walter Binder CoCo Software Engineering Margaretenstr. 22/9 A-1040 \nVienna Austria  w.binder@coco.co.at The J-SEAL2 Approach * Jarle G. Hulaas University of Geneva rue \nG\u00b4eral Dufour 24 en\u00b4CH-1211 Geneva 4 Switzerland hulaas@cui.unige.ch Alex Villaz\u00b4 on University of Geneva \nrue G\u00b4eneral Dufour 24 \u00b4CH-1211 Geneva 4 Switzerland villazon@cui.unige.ch ABSTRACT Preventing abusive \nresource consumption is indispensable for all kinds of systems that execute untrusted mobile code, such \nas mobile object systems, extensible web servers, and web browsers. To implement the required defense \nmecha\u00adnisms, some support for resource control must be available: accounting and limiting the usage of \nphysical resources like CPU and memory, and of logical resources like threads. Java is the predominant \nimplementation language for the kind of systems envisaged here, even though resource control is a missing \nfeature on standard Java platforms. This paper de\u00adscribes the model and implementation mechanisms underly\u00ading \nthe new resource-aware version of the J-SEAL2 mobile object kernel. Our fundamental objective is to achieve \ncom\u00adplete portability, and our approach is therefore based on Java bytecode transformations. Whereas \nresource control may be targeted towards the provision of quality of service or of usage-based billing, \nthe focus of this paper is on secu\u00adrity, and more speci.cally on prevention of denial-of-service attacks \noriginating from hostile or poorly implemented mo\u00adbile code.  Keywords Bytecode rewriting, Java, micro-kernels, \nmobile object sys\u00ad tems, resource control, security 1. INTRODUCTION Java [17] was designed as a general-purpose \nprogramming language, with special emphasis on portability in order to enhance the support of distributed \napplications. There\u00adfore, it is natural that access to low-level, highly machine\u00ad * This work was funded \nby CoCo Software Engineering GmbH and the Swiss National Science Foundation grants 20-54014.98 and 5003-057753. \n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. OOPSLA \n01 Tampa Florida USA Copyright ACM 2001 1-58113-335-9/01/10 $5.00 dependent mechanisms were not incorporated \nfrom the be\u00adginning. New classes of applications are however being con\u00adceived, which rely on the facilities \no.ered by Java, and which at the same time push and uncover the limits of the lan\u00adguage. These novel \napplications, based on the possibilities introduced by code mobility, open up traditional environ\u00adments, \nmove arbitrarily from machine to machine, execute concurrently, and compete for resources on devices \nwhere a very wide range of con.gurations can be found. We are therefore witnessing increased requirements \nregarding fair\u00adness and security, and it becomes indispensable to acquire a better understanding and \ngrasp of low-level issues such as resource management. Operating system kernels provide mechanisms to \nenforce re\u00adsource limits for processes. The scheduler assigns processes to CPUs re.ecting process priorities. \nFurthermore, only the kernel has access to all memory resources. Processes have to allocate memory regions \nfrom the kernel, which veri.es that memory limits for the processes are not exceeded. Like\u00adwise, a mobile \nobject kernel must prevent denial-of-service attacks, such as mobile objects allocating all available \nmem\u00adory. For this purpose, accounting of physical resources (i.e., memory, CPU, network bandwidth, etc.) \nand of logical re\u00adsources (i.e., number of threads, number of protection do\u00admains, etc.) is crucial. \nWhereas J-SEAL2 [5, 6] is primarily designed for mobile objects, the approach described here is in many \nways appli\u00adcable to other distributed programming paradigms practiced in Java, since the mobile object \nparadigm is very compre\u00adhensive in terms of involved issues and technologies. The techniques employed \nin J-SEAL2 could thus greatly improve stability and security in the execution of Java Applets, or traditional \ndistributed applications, where strong protec\u00adtion domains and resource control mechanisms are often \nneeded. Further potential use cases include technologies such as World-Wide-Web server extensions (Java \nServlets [27]) and Java application servers (e.g., Enterprise JavaBeans containers [25]). The great \nvalue of resource control is that it is not restricted to serve as a base for implementing security mechanisms. \nApplication service providers may e.g. need to guarantee a certain quality of service, or to create the \nsupport for usage\u00adbased billing, in order to amortize investments in hardware and software set at customers \ndisposal. The basic kernel extensions described here will be necessary to schedule the quality of service \nor to support the higher-level accounting system, which will bill the clients for consumed computing \nresources. This paper is however restricted to the kernel extensions that were necessary to add resource \ncontrol to J-SEAL2; faithful to the micro-kernel approach, J-SEAL2 relegates to the higher levels the \nmechanisms which do not absolutely have to be part of the kernel. This paper is organized as follows: \nThe next section gives a brief overview of the J-SEAL2 mobile object kernel. Section 3 presents the design \ngoals and the resulting resource con\u00ad trol model, and section 4 the corresponding APIs. Section 5 explains \nour implementation techniques, for which section 6 presents some performance measurements. Section 7 \ncom\u00ad pares our approach with related work, whereas section 8 concludes the paper.  2. THE J-SEAL2 MOBILE \nOBJECT KER-NEL This section gives some basic background on the J-SEAL2 mobile object kernel [5, 6], which \nwe selected as the target platform to integrate our resource control model. For de\u00adtails regarding J-SEAL2, \nsee the web pages at http://www. jseal2.com/. J-SEAL2 is a micro-kernel implemented in pure Java, which \nsupports the hierarchical process model of the Seal Calcu\u00adlus [33] that was .rst implemented by the JavaSeal \nmobile object system [9]. The J-SEAL2 kernel manages a tree hi\u00aderarchy of nested protection domains1, \nwhich may be either mobile objects or service components. Each mobile object and service executes in \na protection domain of its own, called a sealed object or seal for short. In J-SEAL2 mobile objects and \nservice components are com\u00adpletely separated from each other. Untrusted mobile objects are not allowed \nto directly use certain functionality of the JDK, such as .le or network IO, but they have to access \ndedicated J-SEAL2 services that are executing in separate protection domains. The inter-domain communication \nfacil\u00adities of the kernel prevent direct sharing of object references between distinct domains. Details \non the communication model of J-SEAL2 can be found in [5]. Figure 1 depicts a typical hierarchy of protection \ndomains, including several service components, stationary sandbox domains that enforce appropriate security \npolicies on their subdomains, as well as mobile objects. The root domain, RootSeal, is responsible for \ncreating the service components as well as the stationary domains. The network service al\u00adlows mobile \nobjects to migrate to another site. In .gure 1 one sandbox executes authenticated, fully trusted mobile \nob\u00adjects, while the other one is responsible for anonymous, po\u00adtentially malicious mobile objects. The \nsandbox of trusted 1In this paper the term protection domain refers to the concept of a process or task \nin an operating system, and not to the JDK class java.security.ProtectionDomain. mobile objects is granted \naccess to all installed services, whereas the sandbox of anonymous mobile objects may only use the network \nservice in a restricted way. In J-SEAL2 each protection domain has associated its own set of threads, \nwhich cannot cross domain boundaries ar\u00adbitrarily. Mobile objects are not allowed to directly create \nJava threads, but they have to use a safe wrapper class in\u00adstead. The J-SEAL2 kernel enforces additional \nconstraints on mobile objects, in order to ensure that a parent domain may terminate its children at \nany time, forcing the children to release all allocated resources immediately. For instance, mobile objects \nare not allowed to catch ThreadDeath excep\u00adtions, which are used by the kernel to stop running threads \nwhen a domain is terminated. Such restrictions are ensured by extended bytecode veri.cation; details \nare discussed in [6]. So far, the J-SEAL2 mobile object kernel has provided es\u00adsential functionality \nof an operating system kernel, such as protection, mediated communication, and safe domain ter\u00admination. \nThe kernel has however not been able to control resource allocation. In the next sections we present \nthe de\u00adsign and implementation of a new resource control model for Java and its integration in J-SEAL2, \nwhich will comple\u00adment J-SEAL2 to a complete Java operating system kernel. Therefore, a parent domain \nwill act not only as a commu\u00adnication controller for its children, but also as a resource manager. 3. \nOBJECTIVES AND RESULTING MODEL The ultimate objective of this work is to enable the creation of execution \nplatforms where anonymous mobile objects, or more general programs, may securely coexist without harm\u00ading \neach other, and without harming their environment. Ex\u00adamples of such platforms are user-extensible databases \n[16] or decentralized e-commerce and trading systems as e.g. in [18]. Java Applet execution platforms \n World-Wide-Web browsers as well as embedded Java devices also need such guarantees. The desire to deploy \nthis kind of platforms translates into the following requirements: Accounting of low-level, physical \nresources as well as higher-level, logical resources, such as threads.  Prevention against denial-of-service \nattacks that are based on CPU, memory, or communication misuse.  Fair distribution of resources among \nconcurrent do\u00admains, even outside the context of malicious activities.  Su.ciently abstract concepts2, \nin order to make map\u00adping of policies into implementations more straightfor\u00adward, and with a view to \nmaking resource control and eventual billing more manageable.  2The abstractions presented in this \npaper are limited to the resources provided by the kernel, such as memory and CPU. An extensible high-level \nAPI addressing arbitrary resources will be provided on top of the resource control model of the kernel. \n Figure 1: Nested protection domains in J-SEAL2. Fine-grained load-balancing of mobile object applica\u00adtions \non a cluster of machines. Since some aspects of resource control are to be manageable by the application \ndeveloper, it is important that the general model integrates well with the existing J-SEAL2 program\u00adming \nmodel [5]. The resource control facilities shall re.ect the hierarchical system structure. Hierarchical \nprocess mod\u00adels have been used successfully by operating system kernels, such as the Fluke micro-kernel \n[14]. The Fluke kernel em\u00adploys a hierarchical scheduling protocol, CPU Inheritance Scheduling [15], \nin order to enforce scheduling policies. In this model, a parent domain donates a certain percentage \nof its own CPU resources to a child process. Initially, the root of the hierarchy possesses all CPU resources. \nA general model for hierarchical resource control, such as e.g. Quantum [22], .ts very well to the J-SEAL2 \nhierar\u00adchical domain model. At system startup the root domain, RootSeal, owns by default all resources \nthe Java runtime system allocates from the underlying operating system, for example 100% CPU, the entire \nvirtual memory, unlimited network usage, the maximum number of threads the under\u00adlying Java Virtual Machine \n(JVM) [21] is able to cope with, an unlimited number of subdomains, etc. Moreover, the root domain, along \nwith the other domains loaded at plat\u00adform startup, are considered as completely safe, and, con\u00adsequently, \nno resource accounting will be enforced on them. This default behavior may however easily be overridden \nif speci.c con.gurations should require accounting even for trusted domains. When a nested protection \ndomain is created, the creator donates some part of its own resources to the new domain. Figure 2 illustrates \nthe way resources are either shared or distributed inside a seal hierarchy. In the formal model of J-SEAL2, \nthe Seal Calculus [33], the parent seal supervises all its subdomains, and inter-domain communication \nmanage\u00adment was the main concern so far. Likewise, in the resource control model proposed here, the parent \nseal is responsible for the resource allocation with its subseals. This produces a nested structure, \nwhere the parent seal is initially the sole owner of its resources, and it may either share them or dis\u00adpatch \nfractions of them to its subseals. However, the sum of all resources within a protection domain, e.g., \nin the Un\u00adtrusted application of .gure 2, remains constant.  Our resource control model stems from further \ndesign goals, such as portability and transparency: the next subsections are dedicated to describing \nthese. 3.1 Portability and Transparency Portability is crucial for the success of any mobile object platform. \nThere are already some Java-based systems o.er\u00ading resource control facilities, such as Alta [32], GVM \n[4], Ka.eOS [1, 2], etc. However, they rely on modi.ed Java runtime systems, which are not portable. \nAs a result, these systems are not suited for large-scale applications that have to support a wide variety \nof di.erent hardware platforms and operating systems. Our goal is to provide a general\u00adpurpose model \nwhich is not dependent on speci.c imple\u00admentation techniques, and to explore primarily completely portable \nsolutions. This entails that we have to cope with certain restrictions and with performance levels sometimes \ninferior to those of existing realizations. Our portable ap\u00adproach will nevertheless show its advantages \nin the longer term: our solution will always perform somewhat slower than the fastest JVMs without resource \ncontrol mechanisms, but, on the other hand, we will be able to exploit the latest techniques in Java \nimplementation optimizations, which will Figure 2: Illustration of the general resource control model. \noften not be possible with non-portable implementations. A related important requirement of our resource \ncontrol model is that unmodi.ed o.-the-shelf applications should be able to execute on our platform. \nIn other words, re\u00adsource control must be transparent to applications which do not explicitly manage \ntheir pool of resources. In section 6.2 we discuss to which extent this wish has been satis.ed. For portability \nreasons, it should also be stressed that the goal of this work is not to implement any kind of real-time \nguarantee. The resources that are managed and distributed internally to the JVM are thus entirely dependent \nupon what the JVM process itself is given by the underlying op\u00aderating system.  3.2 Minimal Overhead \nfor Trusted Domains Since J-SEAL2 is designed for large-scale applications, where a large number of services \nand mobile objects are executing concurrently, design and implementation must minimize the overhead of \nresource accounting. Some domains, such as core services, are fully trusted. Their resource consumption \nneed not be controlled by the kernel.  3.3 Support for Resource Sharing In certain situations protection \ndomains that are neighbors in the hierarchy may choose to share some resources. In this case, resource \nlimits are enforced together for a set of protection domains. As a result, resource fragmentation is \nminimized. For example, consider a mobile object creating a subdomain for a certain task. Frequently, \nthe creating domain does not want to donate some resources to the sub\u00addomain, but it rather prefers to \nshare its own resources with the subdomain. A property of our approach is that if a do\u00admain has unlimited \naccess to a resource, this means that it is sharing it with RootSeal.  3.4 Managed Resources Within \neach untrusted protection domain, the J-SEAL2 ker\u00adnel shall account for the following resources: CPU \nRELATIVE de.nes the relative share of CPU. It is expressed as a fraction of the parent domain s own relative \nshare, but takes a slightly di.erent meaning when the parent itself is a trusted domain; the precise \nsemantics is exposed in section 4.2.  MEM ACTIVE is the highest amount of volatile mem\u00adory that a protection \ndomain is allowed to use at any given moment.  THREADS ACTIVE speci.es the maximal number of active \nthreads by protection domain at any moment. Uncontrolled creation of threads has to be avoided, as it \nresults in increased load for the scheduler; it may even crash the JVM, as there is currently no standard \nJava construct allowing one to inquire about the maxi\u00admum number of threads a JVM implementation is able \nto cope with.  THREADS TOTAL limits the number of threads that may be created throughout the lifetime \nof a protection domain, as thread creation is an expensive (kernel\u00adlevel) operation.  DOMAINS ACTIVE \nspeci.es the maximal number of active subdomains a protection domain is allowed to have at any given \nmoment. This limit is to minimize management overhead inside the kernel by controlling the complexity \nof the seal hierarchy at any time.  DOMAINS TOTAL bounds the number of subdomains that a protection \ndomain may generate throughout its lifetime, as domain creation and termination are ex\u00adpensive kernel \noperations. Note that the kernel of J-SEAL2 is not responsible for net\u00adwork control. This is because \nthe micro-kernel does not provide access to the network. Instead, network access can be provided by multiple \nservices. These network services or some mediation layers in the hierarchy are responsible for network \naccounting according to application-speci.c secu\u00adrity policies. Let us stress that the network is not \na special case, since J-SEAL2, thanks to its homogeneous model, may limit communication with any services, \nlike e.g. .le IO. Another resource kind that could be expected in the above list of kernel-managed resources \nis the total amount of CPU allocated to a given protection domain throughout its life\u00adtime. It is however \nnot clear what the unit of measure\u00adment should be for this resource, while still preserving a completely \nhardware-independent model. The main objec\u00adtive of this kind of resource accounting would be to pre\u00advent \napplications from inde.nitely cluttering up platforms; in a heterogeneous set of servers it gives however \nmore sense to express total lifetime abstractly as the wall clock time elapsed since the application \nwas started, than as the num\u00adber of consumed CPU cycles. Using as unit of measurement the amount of executed \nJava bytecodes, although portable, was also regarded as too low-level. Measuring wall clock time can \nbe achieved at the application level, by establish\u00adment of a controlling domain with su.cient rights \nto kill all misbehaving applications; this is a viable approach, since in J-SEAL2, when a parent disposes \nof a child seal, all re\u00adsources are guaranteed to be freed properly. Accounting of total CPU time was \ntherefore discarded from the kernel. Finally, there is also no such resource as MEM TOTAL, a limit to \nthe accumulated amount of memory used through\u00adout the lifetime of a protection domain. It could be needed \nto prevent the kind of denial-of-service attacks where a ma\u00adlicious domain creates a lot of dynamic objects \nin order to keep the CPU busy with garbage collection. Its implemen\u00adtation would however require maintenance \nof an additional counter, which we preferred to avoid. Instead, J-SEAL2 will take preventive action by \ncharging an abstract amount of CPU as a compensation for the garbage collection induced by each object \ncreated. The six basic resource types retained for management by the J-SEAL2 kernel are discussed in \nmore detail in the API section below.  4. API In this section we give an overview of the resource control \nAPI provided by the J-SEAL2 kernel. A detailed speci.ca\u00adtion of the API can be found in [7]. There are \n2 kernel abstractions dedicated to resource con\u00adtrol: A resource object of type Res represents a resource \nof a certain type available for a protection domain. Resource sets of type ResSet ease the management \nof multiple resources. Furthermore, the kernel class Seal, which supports domain creation and termination, \nhas been extended to allow a par\u00adent domain to restrict the resources of its children. 4.1 De.nitions \nIn this section we provide some de.nitions, which simplify the description of the resource control API. \nIn the following de.nitions let S denote an arbitrary domain in the hierarchy. Root Res object: A root \nRes object of the domain S is a Res object responsible for resource control in S.A root Res object is \nreturned by an invocation of the method getCurrentRes in class Res (for details see the following section). \nDescendant Res object: A descendant Res object D of the domain S is the result of splitting a root Res \nobject R of S. R is also called the parent Res object of D. When a descendant Res object is used in a \nResSet object to create a nested domain, it will be used for resource control in the created child domain. \nNote that these de.nitions are relative to the domain S. A descendant Res object D of the domain S is \na root Res object in a child C of S, if D was in the ResSet object used for creating C. When we use the \nterms root and descendant Res objects in the description of a method, we implicitly assume Res objects \nof the domain invoking the method. 4.2 Class Res For each type of resource, a protection domain has \nan associ\u00adated root Res object re.ecting how much of the resource the domain has been granted. A Res \nobject de.nes a resource limit and provides information on the current resource us\u00adage in order to support \nresource aware computations. It o.ers an operation allowing a domain to split up some part of the resource. \nThis operation yields a new descendant Res object that may be donated to children domains. The root domain, \nRootSeal, creates an initial Res object for each type of resource during startup. RootSeal distributes \nresources to service components and to application domains accord\u00ading to a con.guration provided by the \nsystem administrator. Table 1 summarizes the interface of a Res object. The static method getCurrentRes \nreturns the root Res ob\u00adject for a given type of resource of the invoking domain. The constants CPU RELATIVE, \nMEM ACTIVE, THREADS ACTIVE, THREADS TOTAL, DOMAINS ACTIVE, and DOMAINS TOTAL (i.e., relative CPU share, \nactive memory in bytes, as well as ac\u00adtive and cumulative threads and subdomains) are used to indicate \nthe requested resource type. The information, for which type of resource a Res object is responsible, \nis perma\u00adnently associated with the Res object in order to prevent the programmer from mixing up di.erent \ntypes of resources by mistake. The getType method returns the type of resource a Res object is representing. \ngetLimit returns the resource limit of a Res object. A nega\u00adtive value means that there is no resource \nlimit. Concerning the semantics of the resource limit, the relative CPU share Table 1: The Res API. Table \n2: The ResSet API. public final class Res { public static final int CPU_RELATIVE = 0, MEM_ACTIVE = 1, \nTHREADS_ACTIVE = 2, THREADS_TOTAL = 3, DOMAINS_ACTIVE = 4, DOMAINS_TOTAL = 5; public static Res getCurrentRes(int \ntype); public int getType(); public long getLimit(); public long getUsage(); public Res split(long limit); \npublic void setLimit(long limit); public void combine(); } (CPU RELATIVE) is treated di.erently from \nall other resource types. A relative CPU share of n means that domains cre\u00adated with the corresponding \nRes object may use at most a fraction of n of the CPU time sum of all CPU limits in the system available \nto domains with a CPU limit = 03 . getUsage re\u00adturns the resource consumption of all domains sharing \nthe same root Res object. A negative value means that the J-SEAL2 kernel does not account for the resource. \nAs the Res API does not expose any public constructor, the split operation has to be used in order to \ncreate de\u00adscendant Res objects that may be donated to subdomains. split may be invoked only on root Res \nobjects. It returns a new descendant Res object responsible for the same type of resource as the root \nRes object, which becomes the par\u00adent of the descendant. The descendant Res object has the resource limit, \nwhich was passed to split as argument, and an initial resource usage of zero. The resource usage of the \nparent Res object is incremented by the limit given to the descendant. The setLimit method provides a \nmechanism to modify the resource limit of a Res object. The new resource limit is passed as argument. \nThe resource usage of the parent Res object is adjusted accordingly. A parent domain may use de\u00adscendant \nRes objects in order to monitor the resource usage of children domains. With the aid of setLimit, the \nparent is able to adjust the resource limits for the children domains. The combine operation allows to \nmerge Res objects that have been split before. If it is invoked on a root Res ob\u00adject, combine has no \ne.ect. If it is called on a descendant Res object, the descendant is combined with its parent Res In \nour current implementation, this resource is controlled by periodic sampling of the amount of executed \nbytecode instructions. The precision of the measurement is imple\u00admentation dependent; there is indeed \na bias induced by the fact that the CPU resource is not allocated by absolute val\u00adues, but by relative \nshares, while in the implementation, the reference value is the aggregated consumption measured among \nuntrusted domains and is not, as could be expected, the resource taken as a whole. public final class \nResSet { public static ResSet getCurrentResSet(); public ResSet copy(); public Res getRes(int type); \npublic void setRes(Res r); public void combine(); } object, i.e., the resource usage of the parent object \n(if it is accounted for) is reduced by the limit of the descendant. The descendant Res object is marked \nas invalid and cannot be used anymore. Combination is only possible, if the de\u00adscendant Res object is \nnot used by any subdomain (i.e., all subdomain created with the descendant Res object must be terminated \nbefore). 4.3 Class ResSet A ResSet object o.ers a convenient way to manage all re\u00adsources given to a \ndomain. It holds exactly one Res object for each type of resource. Table 2 summarizes the public interface \nof a ResSet object: The static method getCurrentResSet returns a ResSet ob\u00adject with the root Res objects \nof the domain the calling thread is executing in. This ResSet object may be used to access the individual \nRes objects of the domain. The copy method creates a shallow copy of a ResSet object. The copy contains \nthe same references to Res objects as the original ResSet object. The getCurrentResSet and copy methods \nare the only mechanisms allowing to allocate new ResSet objects. There is no public constructor, because \nthe API enforces the constraint that a ResSet always holds exactly one Res object for each type of resource. \nThe getRes method return the Res object for a given type of resource. The argument is a resource constant \nde.ned in the class Res. The setRes method replaces the Res object in the set, which has the same resource \ntype as the Res object given as argument. The combine method o.ers a convenient way to invoke combine \non all Res objects in the set. 4.4 Class Seal The Seal abstraction provides methods for domain creation \n(unwrapping) and removal (wrapping or disposing). Table 3 summarizes the unwrap methods of the Seal class. \nOther methods are not shown, because they are not a.ected by the resource control extension. The unwrap \nmethod with 3 arguments requires a wrapped representation of the subdomain to create (corresponding to \nthe serialized state of a mobile object), its name, as well as a ResSet object with the resources for \nthe new subdomain. The unwrap operation with 2 arguments implicitly shares the resources of the unwrapping \ndomain with the created child domain. When a domain is created, the parent s DOMAINS ACTIVE and Table \n3: The unwrap methods of class Seal. public class Seal { public static void unwrap(WrappedSeal wrapped, \nString sealname, ResSet resources); public static void unwrap(WrappedSeal wrapped, String sealname) { \nunwrap(wrapped, sealname, ResSet.getCurrentResSet()); } ... } Table 4: Resource control example. long \nMB = 1024*1024; ResSet rP = ResSet.getCurrentResSet(); Res cpu = rP.getRes(Res.CPU_RELATIVE); Res mem \n= rP.getRes(Res.MEM_ACTIVE); ResSet rA = rP.copy(); long cpuA = (long)(cpu.getLimit()*0.75); rA.setRes(cpu.split(cpuA)); \n ResSet rB = rP.copy(); rB.setRes(mem.split(10*MB)); Seal.unwrap(childA, nameOfChildA, rA); Seal.unwrap(childB, \nnameOfChildB, rB); DOMAINS TOTAL Res objects are charged for the created sub\u00addomain(s), while the child \ns resource objects are charged for the CPU time consumed for unwrapping (involving class\u00adloading and \nlinking), for memory allocation, as well as for the child s initializer thread.  4.5 Example The code \nfragment in table 4 demonstrates how the resource control API is used to control the resources of children \ndo\u00admains. This example corresponds to the Untrusted applica\u00adtion depicted in .gure 2. A parent domain, \nwhich has limited CPU and memory re\u00adsources, creates 2 subdomains: One child domain (childA) gets 75% \nof the parent s CPU resources and shares the mem\u00adory resources with the parent, while the other child \ndomain (childB) receives 10 MB of active memory and shares the CPU resources with the parent.  5. IMPLEMENTATION \nIn this section we present the techniques we are using for the implementation of the resource control \nmodel discussed in the previous sections. Since accounting for high-level re\u00adsources, such as active \nand cumulative threads and subdo\u00admains, requires only minor modi.cations to a few J-SEAL2 kernel primitives, \nwe focus on accounting for physical re\u00adsources, such as memory and CPU consumption. 5.1 No Direct Sharing \nSince its initial release the J-SEAL2 kernel is designed to ease the integration of resource control \nfacilities. It guar\u00adantees accountability, i.e., user-visible objects belong to ex\u00adactly one protection \ndomain. References to an object exist only within a single domain4, i.e., in J-SEAL2 there is no direct \nsharing of object references between distinct domains. Therefore, it is possible to account each allocated \nobject to exactly one protection domain. This feature not only simpli\u00ad.es resource accounting, but it \nis also crucial for immediate resource reclamation during domain termination. 5.2 Bytecode Rewriting \nIn our approach we employ bytecode rewriting techniques both for memory and CPU accounting. This is because \nit is to our understanding the only entirely portable way to im\u00adplement the needed accounting mechanisms. \nIt is unrealistic to expect the source code of every application to be available for modi.cation. Moreover, \nif we want guarantees against denial-of-service attacks, we cannot rely on foreign code to perform any \nvoluntary self-limiting operations, whereas if we modify its bytecode before it starts executing, we \ncan oblige it to provide any information needed by the kernel and to obey any restriction imposed on \nit by the environment. In\u00adstead of rewriting bytecode for CPU control, the J-SEAL2 kernel might e.g. \nask the underlying operating system for in\u00adformation about the CPU consumption of each thread, but this \nis possible only when Java threads are directly mapped into operating system threads. Another approach \nwould be to run a modi.ed JVM; the arguments against this are how\u00adever exposed elsewhere in this paper. \nA further discussion of existing (and non-portable) approaches is to be found in section 7.1. In the \npresent paper, the bytecode of a Java class is modi.ed before it is loaded by the JVM [21]. Code for \nmemory ac\u00adcounting is inserted before each memory allocation instruc\u00adtion (for details, see section 5.7). \nCPU accounting uses an abstract measure, the number of executed bytecode instruc\u00adtions. Therefore, code \nfor CPU accounting is inserted in every basic block of code (details are presented in section 5.8). Rewriting \nfor memory accounting has to be done before rewriting for CPU accounting, because memory accounting inserts \nadditional bytecode instructions to enforce memory limits, while accounting for CPU consumption does \nnot in\u00advolve any object allocation. 4The only exception to this rule are Res objects (see sec\u00adtion 4.2) \nused for resource sharing. The parent domain is charged for the Res objects of its children. Res objects \ncan\u00adnot be communicated between domains apart from domain creation. Because Res objects are small and \nthe number of Res objects donated to a child is limited, this minor inex\u00adactness is irrelevant. 5.3 \nDomain Types The resource control model supports trusted domains that have unlimited access to certain \ntypes of resources. For per\u00adformance reasons, the J-SEAL2 kernel does not account for the consumption \nof these resources. Regarding CPU and memory accounting, we distinguish 4 types of domains: NO-ACC: Domains \nwithout memory limit and without CPU control may execute unmodi.ed Java code, as they do not need to \nexecute any accounting instruc\u00adtions. CPU-ACC: Domains without a memory limit, but with CPU control have \nto execute CPU accounting instruc\u00adtions. However, code for memory accounting is not required in such \ndomains. MEM-ACC: Domains with a memory limit, but without CPU control have to execute memory accounting \nin\u00adstructions. However, code for CPU accounting is not required in such domains. CPU-MEM-ACC: Domains \nwith a memory limit and with CPU control have to execute accounting code for mem\u00ad ory allocation as well \nas for CPU consumption.  5.4 Accounting Objects In MEM-ACC and in CPU-MEM-ACC domains objects of the \nclass MemAccount represent memory limit and current usage. In CPU-ACC and in CPU-MEM-ACC domains ob\u00adjects \nof the class CPUAccount maintain CPU consumption. These objects are used only by the J-SEAL2 kernel, \nthey are not accessible by user code. Each thread has associated the MemAccount object and a CPUAccount \nobject of the domain it is executing in; null values indicate that a domain does not need a MemAccount \nor CPUAccount object. Java thread-local variables (instances of the class java.lang.ThreadLocal) are \nused to implement this association. The MemAccount and CPUAccount implementations provide the static \nmethod getCurrentAccount, which returns the corresponding ac\u00adcounting object of the domain the calling \nthread is executing in. Because access to MemAccount and above all to CPUAccount objects may be extremely \nfrequent, accessing these objects from thread-local variables in every method would cause a signi.cant \nperformance penalty5 . Therefore, non-native methods are rewritten in order to pass the necessary ac\u00adcounting \nobjects as additional arguments. Native methods are excluded from rewriting, because we cannot account \nfor memory allocated and CPU time consumed by native code. We are relying on modern inter-modular register \nallocation algorithms implemented by state-of-the-art JVMs to mini\u00admize the overhead of passing the accounting \nobjects through the whole method call-graph. As an example for the rewriting process, consider method \n5 In Sun s JDK 1.3 implementation thread-local variables are managed as hash-maps, i.e., each access \nto a thread-local variable requires a hash-map lookup. a given in table 5. The rewritten6 version of \nmethod a for a CPU-MEM-ACC domain is given in table 6. Here we are only presenting the additional arguments, \nwhile the inserted accounting code is discussed in sections 5.7 and 5.8. In this example, method a receives \ntwo additional arguments for the CPUAccount and MemAccount objects7 . The additional arguments are passed \nto all invoked methods (resp. con\u00adstructors). Table 5: Method a before rewriting. void a(int x) { b(null, \nx); } Table 6: Method a rewritten for a CPU-MEM-ACC domain. void a(int x, MemAccount mem, CPUAccount \ncpu) { b(null, x, mem, cpu); }  5.5 Callbacks from Native Code Native code invoking Java methods complicates \nthe resource control implementation, because the native code is not aware of the accounting objects to \nbe passed to Java methods as ex\u00adtra arguments. The following three scenarios of Java method invocation \nby native code are particularly important: Thread creation: The Java runtime system (native code) invokes \nthe run method of a thread object when a thread is started with the aid of the start method.  Static \ninitializers: Static initializers are invoked di\u00adrectly during class-loading, i.e., they are invoked \nby native code.  Re.ection: The methods invoke resp. newInstance of Java s re.ection classes Method \nresp. Constructor are native.  When the thread invoking a Java method from native code has already \nset its thread-local accounting objects, it is su.\u00adcient to provide for each method an additional one \nwith the same signature, which takes the required accounting objects from thread-local variables and \npasses them to the rewritten method. In the rewriting example given in tables 5 and 6 we have to supplement \nthe rewritten method with method a in table 7. Note that when a constructor is rewritten accord\u00ading to \nthis scheme, the invocation of another constructor of the same class or of a constructor of the superclass \nhas to antecede the lookup of the accounting objects. 6For the sake of easy readability, we present rewriting \ntrans\u00adformations at the Java level, even though the implementa\u00adtion works at the JVM bytecode level. \n7 Note that in a CPU-ACC or MEM-ACC domain only one additional argument would be necessary to hold the \naccount\u00ading object. Table 7: Solving callbacks from native code. void a(int x) { MemAccount mem = MemAccount.getCurrentAccount(); \nCPUAccount cpu = CPUAccount.getCurrentAccount(); a(x, mem, cpu); } When a new thread starts executing \nits run method, the thread-local accounting objects have not been initialized yet. As protection domains \nin J-SEAL2 do not have direct access to the class java.lang.Thread but have to employ a safe wrapper \nclass instead [6], the wrapper initializes the thread\u00ad local accounting variables with the accounting \nobjects of the protection domain the new thread belongs to. These objects are passed to the constructor \nof the wrapper by the J-SEAL2 kernel. When a new protection domain is created, the J-SEAL2 kernel allocates \na new initializer thread with the accounting objects for the new domain. While starting this thread, \nthe thread wrapper initializes the thread-local accounting vari\u00adables and starts to load the classes \nof the new protection domain. The class-loading already happens in the account\u00ading context of the new \ndomain.  5.6 Class-loading The J-SEAL2 kernel distinguishes between shared and repli\u00adcated classes [6]. \nShared classes are loaded by the sys\u00adtem class-loader (they exist only once in the JVM), while replicated \nclasses, such as the classes of a mobile object, are loaded by the class-loader of a protection domain \n(they are reloaded in each domain). All JDK classes8 as well as most classes from the J-SEAL2 kernel \nare shared. Certain J-SEAL2 library classes that are frequently used may be shared as well, in order \nto avoid the overhead of reloading them multiple times. Since a shared class may be referenced by fully \ntrusted do\u00admains (no accounting necessary) as well as by untrusted do\u00admains (resource control required), \nit has to provide multiple di.erent versions of each method. The version without re\u00adsource control corresponds \nto the unmodi.ed code, while the versions used by untrusted domains take the account\u00ading objects as extra \narguments and include the necessary accounting instructions. Optimizations to reduce the code size of \nrewritten shared classes are presented in [7]. Shared classes are rewritten o.-line (e.g., during the \ninstal\u00adlation of the J-SEAL2 platform), because we cannot modify the system-classloader, which is part \nof the Java runtime system, in a portable way. Replicated classes are rewritten on-line, immediately \nbefore they are linked into the JVM. Therefore, a mobile object may execute unmodi.ed code on a J-SEAL2 \nplatform where it is trusted, while on another J-SEAL2 installation the code of the same mobile object \nmay be rewritten for resource control. 8 It is not possible to load a JDK class with a loader di.erent \nfrom the system class-loader. Table 8: Rewriting methods in shared classes. void a(int x) { MemAccount \nmem = MemAccount.getCurrentAccount(); CPUAccount cpu = CPUAccount.getCurrentAccount(); if (cpu == null) \nif (mem == null) a(x, (NoAccount)null); else a(x, mem); else if (mem == null) a(x, cpu); else a(x, mem, \ncpu); } void a(int x, NoAccount _no) { b(null, x, _no); } void a(int x, CPUAccount cpu) { b(null, x, \ncpu); } void a(int x, MemAccount mem) { b(null, x, mem); } void a(int x, MemAccount mem, CPUAccount cpu) \n{ b(null, x, mem, cpu); } The example in table 8 shows how method a given in table 5 would be rewritten, \nif it was de.ned in a shared class. A method with the same signature as the original method dispatches \nto the appropriate implementation, when it is invoked from native code. For each type of domain, there \nis a di.erent method implementation. In this example we distinguished the signature of the NO-ACC implementation \nfrom the dispatcher method by adding a dummy argument of type NoAccount. The compilers of state-of-the-art \nJVMs may be able to remove this useless argument. Alternatively, it is possible to rename the NO-ACC \nim\u00adplementation. This approach complicates rewriting, since a table of renamed methods of shared classes \nhas to be maintained, but it has the advantage that replicated classes of trusted domains (e.g., classes \nof an authenticated, fully trusted mobile object) can be rewritten very e.ciently, be\u00adcause only method \nsignatures in the constant-pool [21] are a.ected, whereas the method code remains unchanged (in contrast, \npassing the extra NoAccount argument requires ad\u00additional bytecode instructions). 5.7 Memory Control \nMemory control has to limit the allocation of heap memory, as well as the size of the execution stacks \nof running threads. 5.7.1 Heap Enforcing memory limits requires exact pre-accounting for memory resources, \ni.e., an overuse exception is raised before a thread can exceed the memory limit of the domain it is \nexecuting in. In contrast to JRes [12], which maintains a separate memory limit for each thread, J-SEAL2 \nenforces a single memory limit for a multithreaded domain or even for a set of domains in the case of \nresource sharing. Because a single MemAccount object has to maintain the memory consumption and limit \nof a set of domains shar\u00ading the same memory resources, access to the MemAccount must be synchronized. \nFurthermore, accounting for an ob\u00adject as well as its allocation and initialization has to be an atomic \naction. Before the object is allocated, J-SEAL2 ensures that the memory limit is not exceeded and updates \nthe MemAccount. If the memory allocation fails, if the constructor raises an exception, or if the allocating \nthread is terminated asyn\u00adchronously, we have to ensure that the modi.cation of the MemAccount is undone. \nOtherwise, other threads or even other domains (using the same MemAccount) could su.er from memory leakage. \nDetails on the rewriting scheme for memory allocation instructions can be found in [7]. When the garbage \ncollector reclaims an object, we have to update the MemAccount that has been charged for this ob\u00adject. \nFor this reason, the MemAccount maintains a weak ref\u00aderence for each allocated object, which does not \nprevent the object from being reclaimed. When an object referenced by a weak reference is garbage collected, \nthe weak reference is enqueued in a reference queue, which can be polled by the MemAccount implementation \n(for details see [7]). 5.7.1.1 Object Size The size of an object is calculated from the number of .elds \nfor each Java basic type, the number of .elds holding object references, a constant for the object overhead, \nas well as a constant for the accounting overhead (i.e., the overhead for maintaining a weak reference \nto the allocated object). For arrays, the actual size must be computed from the array dimensions available \non the execution stack. Depending on the Java runtime system, the overhead for array objects may be larger \nthan for non-array objects, because of the size information stored within arrays. Constants for the object \noverhead and for the size of Java basic types and object references are managed in a con.gu\u00adration .le \nby the system administrator. Since in general the administrator does not know the object representation \nof the underlying Java runtime system, a tool helps to approx\u00adimate these constants (e.g., by avoiding \ngarbage collection and measuring the di.erence of allocated memory before and after creating certain \ntypes of objects). However, ob\u00adject alignment is not taken into account. 5.7.1.2 Optimizations While \nour approach works for objects as well as for arrays, we are also implementing an optimization for non-array \nob\u00adjects: Similar to JRes [12], in each allocated object we store a reference to the corresponding MemAccount \nobject. Rewrit\u00adten .nalizers are responsible for updating the MemAccount when an object is reclaimed \nby the garbage collector. Thus, we can avoid the signi.cant overhead of maintaining weak references, \nwhich is particularly important for small objects. For arrays, such an optimization cannot be implemented \nin pure Java. However, in practice the overhead for accounting for allocated arrays is not a serious \nproblem, because arrays frequently are large objects (compared to the accounting overhead they cause). \n  5.7.2 Stack The computation of recursive methods may rapidly blow up the execution stack of a thread \nwithout allocating a single object. Especially if domains are allowed to create large numbers of threads, \nan attacker could easily create a bunch of threads, and in each thread create a very deep call stack \nforcing the system to use large amounts of memory (pre\u00adcious memory, which cannot be garbage collected \nuntil the methods return). Most proposals for resource control in Java, like e.g. JRes [12], do not take \nthe memory consumption of the execution stacks into account. Our implementation supports control of stack \nmemory as an optional feature. During the installa\u00adtion, the system administrator has to decide whether \nstack control shall be enabled. When untrusted domains are al\u00adlowed to create only a small number of \nthreads and the un\u00adderlying JVM allocates execution stacks that cannot expand dynamically, it is su.cient \nto charge the MemAccount for the maximum stack size9 when a thread is created. However, if the JVM allows \nexecution stacks to grow up sig\u00adni.cantly, special e.ort is necessary in order to limit the size of the \nstack. For this purpose, we rewrite non-native meth\u00adods to pass an additional counter, indicating the \namount of memory the thread is allowed to use on the stack. On method entry, this counter has to be reduced \nby the num\u00adber of local variables and the maximum stack consumption of the invoked method10 . For each \nmethod, this information is available in the Java class-.le [21]. If the counter becomes negative, an \nappropriate exception is raised. The counter can be an integer that is passed by value. Therefore, a \ngood register allocator will help to keep the overhead small. As a further optimization, leaf methods \n(i.e., methods that do not invoke any other method) may omit the check of the counter.  5.8 CPU Control \nFor CPU control, we are accounting the number of executed bytecode instructions for each thread running \nin a CPU-ACC or CPU-MEM-ACC domain. A high-priority sched\u00aduler thread, which is part of the J-SEAL2 kernel, \nexecutes periodically in order to ensure that assigned CPU limits are respected. The scheduler thread \ncalculates the number of executed bytecode instructions for each set of domains shar\u00ading a CPU limit \nby summing up the CPU consumption of all threads executing in a domain in the set. The sched\u00aduler compares \nthe number of executed bytecodes with the desired schedule. If a set of domains has exceeded its CPU \nlimit, the priorities of threads executing in these domains are lowered. 9In order to approximately determine \nthe maximum stack size of a JVM implementation, we employ a cal\u00ad ibration program executing a recursive \nmethod until a StackOverflowError occurs. The maximum stack size cor\u00ad responds to the product of the \nmaximum recursion depth and the size of a stack frame of the recursive method. 10A Just-in-Time compiler \nwill completely remove the Java stack when it creates code for a register machine. Neverthe\u00ad less, the \nnumber of local variables and the maximum stack consumption of a method can be used as an approximation \nfor the size of a stack frame of the method. 5.8.1 Class CPUAccount In contrast to a MemAccount object, \nwhich is shared by all threads executing in a domain with memory account\u00ading, each thread running in \na domain with CPU accounting has associated its own CPUAccount object. Since CPU ac\u00adcounting occurs very \nfrequently, it is important that multiple threads do not have to synchronize on a common accounting object. \nAs only the scheduler thread makes any scheduling decisions, it is su.cient to account for each thread \nsepa\u00adrately. The scheduler is responsible for accumulating the accounting data of all threads executing \nin a set of domains sharing a CPU limit. A CPUAccount object simply maintains an integer counter, which \nis updated by the thread owning the object. Table 9 shows some parts of the CPUAccount implementation11 \n. Because the scheduler thread has to read the counter value, we are using a volatile variable in order \nto force the JVM to immediately propagate every update from the working memory of a thread to the master \ncopy in the main memory [17, 21]. Table 9: The CPUAccount implementation. public final class CPUAccount \n{ public volatile int usage; ... } In general, updating the counter requires loading the usage .eld of \nthe CPUAccount object from memory (it is volatile), incrementing the loaded value accordingly, and storing \nthe new value in the memory. A counter update requires about 6 bytecode instructions. 5.8.2 Scheduler \nIn this section we describe how the scheduler thread com\u00adputes the CPU consumption of a set of domains, \nand how it employs di.erent JVM priority levels in order to pre\u00advent CPU overuse. However, we do not \npresent a particu\u00adlar scheduling algorithm, because we are still experimenting with di.erent policies. \nFor each CPUAccount object, the scheduler thread always stores the value of the counter it has read most \nrecently. The scheduler calculates the di.erence between the current value and the previously stored \nvalue in order to determine the amount of bytecode instructions executed during the last time-slice (because \nof the lack of synchronization, the scheduler must not reset any CPUAccount object). If a thread has \nnot existed before, the scheduler assumes the previously stored value to be zero. When a thread terminates, \nits CPUAccount object is not disposed of immediately, but it is maintained until the scheduler has examined \nit. The scheduler has to deal with an over.ow in the counter of a CPUAccount object. The size of the \ncounter must be large 11For instance, we omitted the static getCurrentAccount method mentioned in section \n5.4. enough so that its full range cannot be used in a single time\u00adslice. For current JVMs and a reasonably \nsmall time-slice, a Java int is su.cient. However, in future high-performance systems, CPUAccount objects \nmay have to maintain long values12 . We are using di.erent JVM priority levels to control the CPU consumption \nof individual domains. As protection do\u00admains in J-SEAL2 do not have direct access to the class java.lang.Thread \n(they have to use a safe wrapper class instead [6], which does not o.er any mechanism to change the priority \nof a thread), an user-level thread cannot raise its own priority. Even though the Java language speci.cation \n[17] does not de.ne any scheduling policy, current JVM implementations respect assigned thread priorities. \nMany JVMs employ .xed priority scheduling, where a low-priority thread cannot ex\u00adecute, if there is a \nhigh-priority thread ready to run. The J-SEAL2 kernel uses the distinct JVM thread priority levels as \nfollows: MAX PRIORITY: The maximum priority is reserved to JVM internal tasks, such as handling weak \nrefer\u00adences. J-SEAL2 does not run any threads with the maximum priority.  MAX PRIORITY-1: J-SEAL2 uses \nthis priority level for kernel-level operations in order to prevent priority inversion, i.e., when a \nhigh-priority thread is waiting for an exclusive kernel lock (see [6]) because of a low\u00ad priority thread \nT executing in kernel mode, the prior\u00adity of T is temporarily boosted until thread T releases the kernel \nlock.  MAX PRIORITY-2: This priority level is used by the J-SEAL2 scheduler thread.  NORM PRIORITY \nMIN PRIORITY13: The scheduler assigns these priority levels to threads according to the CPU consumption \nof the corresponding domain and the assigned CPU share. Threads executing in NO-ACC or in MEM-ACC domains \nare always as\u00adsigned NORM PRIORITY. If a domain exceeds its CPU limit, the priorities of its threads \nare reduced (or at least the priorities of those threads overusing the CPU). If a domain does not consume \nits assigned CPU resources, the priorities of its threads may be increased again (but never exceeding \nNORM PRIORITY). We are experimenting with di.erent scheduling algorithms regarding the history of CPU \nconsumption.  5.8.3 Rewriting Algorithm In the description of the rewriting algorithm we use the fol\u00adlowing \nde.nition of an accounting block, which is related to the concept of a basic block of code. In order \nto minimize 12For a long variable, the volatile declaration is crucial, because some JVMs do not treat \nnon-volatile long values atomically [21]. 13 In this description we assume that NORM PRIORITY < MAX \nPRIORITY-2. the accounting overhead, we are considering blocks of max\u00adimal length. An accounting block \nis a bytecode sequence ful.lling the following constraints: If a bytecode instruction, which is neither \na method (resp. constructor) invocation nor a JVM subroutine invocation, changes the control-.ow non-sequentially \n(e.g., method return, exception raising, branch, JVM subroutine return, etc.), it must be the last instruction \nin the accounting block. That is, with the exception of method (resp. constructor) and JVM subroutine \nin\u00advocations, only the last bytecode instruction in the block may change the control-.ow non-sequentially. \nA method invocation does not terminate an accounting block, because otherwise the average block size \nwould be reduced signi.cantly, as method invocations are very frequent in object-oriented programs. \n Only branches to the begin of the block are allowed. There is no bytecode instruction branching to another \ninstruction in the same method, which is not the .rst one in its block. Furthermore, the .rst instruction \nof an exception handler must be always the .rst instruc\u00adtion in its block.  The bytecode rewriting algorithm \ninvolves the following 4 steps (an e.cient implementation may perform multiple steps together): 1. Method \n(resp. constructor) invocations are rewritten in order to pass the CPUAccount object as extra ar\u00adgument. \nBecause the CPUAccount is always the last argument14, it can be pushed onto the stack immedi\u00adately before \nthe method (resp. constructor) invocation instruction. 2. An accounting block analysis (similar to a \nbasic block analysis in traditional compilers) partitions the method code into a set of accounting blocks. \nEach block has an attribute indicating the accounting size of the block. Initially, this attribute holds \nthe number of bytecode instructions in the block15 . Furthermore, a control\u00ad.ow graph with the accounting \nblocks as nodes has to be constructed, if optimizations are to be performed in order to minimize the \naccounting overhead. Without any optimizations, accounting instructions have to be inserted into every \nblock. 3. Optimizations analyze the control-.ow graph in order to detect situations where accounting \nfor multiple dif\u00adferent blocks may be combined. The optimizations may decrement the accounting size attribute \nof one  14Since rewriting for memory accounting is done before rewriting for CPU control, the MemAccount \nargument is passed always before the CPUAccount object. 15In order to improve the accuracy of measurement, \nthe J-SEAL2 administrator may con.gure a weighting of bytecode instructions (integer values) according \nto their complexity. To simplify matters, we assume that all bytecode instruc\u00adtions have a weighting \nof 1. block and add it to the accounting size of another block. If the accounting size of a block becomes \nzero, it does not require any accounting instructions. Details concerning optimizations are presented \nin [7]. 4. For every block with a positive accounting size, ac\u00adcounting instructions are inserted at \nthe begin of the block. The only exception to this rule is the .rst block in a constructor: The invocation \nof another con\u00adstructor of the same class or of the superclass has to antecede the accounting code. The \nincluded in\u00adstructions add the accounting size of the block plus the number of inserted accounting instructions \nto the CPUAccount object. For performance reasons, updates of the CPUAccount object are not synchronized. \n This approach ensures that a thread is charged for at least the number of bytecode instructions it executes. \nFor each accounting block, a thread is charged for the number of in\u00adstructions in the block, before it \nexecutes these instructions (pre-accounting). When an instruction, which is not the last one in its accounting \nblock, raises an exception, the thread has been charged for more instructions than it has consumed. However, \nsince the number of executed bytecode instructions is only an approximation of the exact CPU con\u00adsumption, \nand because exception handling is expensive on many JVM implementations, this possible inexactness does \nnot pose any problem.  5.9 Accounting for Garbage Collection In order to prevent denial-of-service attacks \nby causing the garbage collector to consume a considerable amount of CPU time (e.g., an attacker may \ncreate a lot of garbage without exceeding its memory limit), the J-SEAL2 kernel has to ac\u00adcount for the \ntime spent by the garbage collector. Only CPU-MEM-ACC domains can be charged for the garbage they produce, \nbecause accounting for garbage collections requires the information, which domain has allocated a cer\u00adtain \nobject (such information is not available in NO-ACC or CPU-ACC domains), and because the time spent by \nthe garbage collector a.ects the CPU consumption of a domain (CPU consumption is not measured in NO-ACC \nor MEM-ACC domains). Since the exact CPU time spent by the garbage collector is not known, we are using \nan abstract measure. The J-SEAL2 administrator de.nes a rough approximation of the number of bytecode \ninstructions required to reclaim an object. Be\u00adfore an object is allocated, the J-SEAL2 kernel charges \nthe CPUAccount object of the allocating thread. That is, a do\u00admain has to pay for the garbage it eventually \nwill produce at the time it buys an object. This simple approach has the advantage that a CPU-MEM-ACC \ndomain is charged for all garbage it produces, even if the domain has already terminated when some objects \nare reclaimed. 5.10 Compensating for Native Code With the aid of bytecode rewriting techniques, it is \nnot pos\u00adsible to account for memory allocation and CPU consump\u00adtion in native code. Untrusted applications \nare not allowed to bring native code libraries into the system. Concern\u00ading JVM-provided standard operations, \nthe J-SEAL2 kernel tries to compensate for resources used by native code and prevents untrusted domains \nfrom using certain functional\u00adity leading to a signi.cant resource consumption by native code. In the \nfollowing we describe some important cases of resource consumption in native code and how J-SEAL2 solves \nthem: Class-loading: The Java runtime system manages an internal table of loaded classes. Memory for \ncompiled methods is allocated by the Just-in-Time compiler, which is usually implemented in native code. \nHow\u00adever, the set of classes untrusted domains (e.g., mobile objects) are allowed to access is limited \nand known to the J-SEAL2 kernel. Therefore, the kernel accounts for the classes using an approximation, \nwhich is pro\u00adportional to the size of the class-.les.  Deserialization: J-SEAL2 uses Java serialization \nin or\u00adder to create messages to be transferred across domain boundaries. When the receiving domain opens \na mes\u00adsage, it is being deserialized using the class-loader of the receiving domain to resolve class \nnames. Deseri\u00adalization requires native methods to allocate objects without invoking their constructors. \nJ-SEAL2 solves this hurdle by storing the amount of objects for each type, which is part of the serialized \nobject graph, in the message. The receiver performs resource checks before deserializing the message. \n Object cloning: Java supports object cloning to create shallow copies of objects. The shallow copy \nis allocated by a native method. A simple solution is to forbid untrusted domains to clone objects. \n Re.ection: The Java re.ection API provides a mecha\u00adnism to indirectly create a new instance of a class. \nThe object is allocated by native code. J-SEAL2 simply prevents untrusted domains from using the re.ection \nAPI.   6. EVALUATION This section assesses our approach, .rst by presenting the performance achieved \nwith our current implementation, then by discussing the limitations. 6.1 Measurements While in J-SEAL2 \nthe overhead for memory control is com\u00adparable to the overhead caused by JRes16 [12], the overhead of \nCPU control based on bytecode rewriting techniques has to be examined carefully, because such an approach \nhas not been used before. In this section we present performance measurements proo.ng that the overhead \ndue to our com\u00adpletely portable implementation of CPU accounting is ac\u00adceptable on modern JVM implementations17 \n. 16For an application allocating a new object every 250 byte\u00ad code instructions, the overhead for memory \ncontrol is less than 18%, if no memory limit is exceeded. 17We are not measuring the overhead for CPU \ncontrol in\u00ad curred by the scheduler, as it can always be kept small by choosing an appropriate time-slice. \n We have implemented a bytecode rewriting tool that per\u00adforms the necessary transformations of Java classes \nto sup\u00adport resource control. The tool was designed to add re\u00adsource accounting instructions into arbitrary \nJava applica\u00adtions, to create an extended version of the JDK, and to modify mobile object applications \nin J-SEAL2. Our current bytecode rewriting tool supports o.-line transformations of arbitrary Java classes. \nHowever, we are integrating the re\u00adsource control mechanism in the J-SEAL2 kernel, which re\u00adquires also \nload-time rewriting of mobile objects. Detailed results of our work will be published on our web pages \nat http://abone.unige.ch/. There are several low-level bytecode engineering frameworks written in Java \n(e.g., BCA [19], JOIE [11], BIT [20]), as well as higher-level frameworks, such as e.g. Javassist [10]. \nOur bytecode rewriting tool is based on BCEL (Byte Code Engineering Library, formerly called JavaClass) \n[13], which allows bytecode manipulations of Java classes and is also entirely written in Java. We chose \nBCEL since it is one of the most mature bytecode instrumentation frameworks and provides a powerful and \nintuitive API that is well adapted for our requirements. We measured the standard SPEC JVM98 benchmarks \n[30] on a Linux platform (Athlon AMD 1200MHz clock rate, 256MB RAM, Linux kernel 2.4.2) with IBM s JDK \n1.3 im\u00adplementation, which includes one of the best Just-in-Time compilers available today. We measured \nthe overhead due to CPU accounting in three di.erent con.gurations: Ubench-Ujdk: Unmodi.ed benchmarks \non an unmodi\u00ad.ed JDK.  Rbench-Ujdk: Rewritten benchmarks on an unmodi.ed JDK.  Rbench-Rjdk: Rewritten \nbenchmarks on a rewritten JDK18 .  For each measurement, table 10 shows the execution time of the benchmark \nin seconds (rounded to 3 decimal places), as well as the speedup of the original code compared to the \nrewritten version (rounded to 2 decimal places). In order to minimize the impact of compilation and garbage \ncollection, all results represent the median of 101 di.erent measure\u00adments. Furthermore, we also computed \nthe geometric mean for each con.guration. We rewrote about 520 Java class-.les for the CPU-aware version \nof SPEC JVM98 benchmarks, and about 5400 class-.les for the extended version of the JDK. The results \nin table 10 show that the overhead due to CPU accounting is about 25%, if we rewrite applications as \nwell as the whole JDK. With an unmodi.ed JDK, the overhead can be almost halved (this con.guration is \nnot useful for resource control, but it helps to extract the overhead due 18Modern JVMs allow to run \nuser-de.ned library classes with the -Xbootclasspath option. Table 10: Benchmarks measuring the overhead \nof CPU accounting (time in seconds). Benchmark Ubench-Ujdk Rbench-Ujdk Rbench-Rjdk 227 mtrt 3,783 (1,00) \n4,517 (1,19) 4,788 (1,27) 202 jess 5,299 (1,00) 5,842 (1,10) 6,415 (1,21) 201 compress 11,605 (1,00) \n13,344 (1,15) 13,449 (1,16) 209 db 19,775 (1,00) 20,443 (1,03) 23,381 (1,18) 222 mpegaudio 4,484 (1,00) \n6,316 (1,41) 6,345 (1,42) 228 jack 4,120 (1,00) 4,294 (1,04) 5,033 (1,22) 213 javac 9,400 (1,00) 10,643 \n(1,13) 12,401 (1,32) Geometric Mean 6,970 (1,00) 7,989 (1,15) 8,717 (1,25) to the rewritten JDK). Note \nthat we did not apply any op\u00adtimizations to reduce the accounting overhead. Simple op\u00adtimization rules, \nas discussed in [7], can help to reduce the overhead signi.cantly. The implementation of the optimiza\u00adtion \nalgorithm is still in progress.  6.2 Limitations Here we present the limitations that are inherent to, \nrespec\u00adtively, the way we implement resource control, and the de\u00adsign of the programming model. We terminate \nwith a short discussion of the security provided by our approach. 6.2.1 Limitations of the Implementation \nOur objective is to achieve a completely portable implemen\u00adtation of resource control. This means that \nwe should be able to supervise o.-the-shelf applications, and also that the execution environment should \nbe independent of any under\u00adlying hardware and operating system. In reality, we had to resort to language \nfeatures (e.g., weak references) that exist only since the Java 2 platform [26]. These are incorporated \nin the application during the rewrit\u00ading process, thus allowing backwards compatibility with code compiled \nfor previous versions of Java. Another limitation comes from the interdiction to use several parts of \nthe re.ec\u00adtion package, because it enables the programmer to circum\u00advent our resource control mechanisms. \nThe same remark applies to the use of arbitrary native code libraries. These limitations still allow \nour bytecode processing tool to encompass a very wide range of applications. However, once the goal is \nnot only to monitor resource consump\u00adtion, but also to control it, additional restrictions apply. In \nour approach, the runtime resource control libraries can\u00adnot e.g. allow an application to change the \npriorities of its threads, since this would confuse our scheduler. More gen\u00aderally, schedulers entirely \nimplemented in Java are always dependent on the reliability of the underlying threads and related priority \nmechanisms. This is the price to pay for portability. Finally, if we restrict ourselves to the J-SEAL2 \nplatform, then the application must conform to the corresponding pro\u00adgramming model, which implies respecting \nall of the previ\u00adously mentioned limitations, plus an additional set, as can be found in [6].  6.2.2 \nLimitations of the Programming Model Our approach is designed to enable the transparent execu\u00adtion of \nlegacy applications, as long as they respect the above limitations; their resource consumption will then \nbe con\u00adtrolled by the runtime system without their knowing. From the moment one wants to develop a resource-aware \napplication, it becomes necessary to conform to the basic API described in section 4. This API is however \nprimar\u00adily designed for use by the runtime system, and is probably too low-level for the application \nprogrammer. Therefore, we still have to de.ne an uniform and extensible programming interface that includes \nkernel-level resources, as well as ser\u00advice access, bandwidth limitations, elapsed wall-clock time, etc. \nAlso on our todo-list is the development of high-level pro\u00adgramming tools in order to support a friendlier \nevent noti.\u00adcation mechanism than the overuse exceptions generated by the J-SEAL2 kernel. User-speci.ed \nthresholds should enable applications to receive warnings in a timely manner before the actual overuse \nhappens. 6.2.3 Coverage of Security Issues Since the focus of this paper is on preventing excessive \nre\u00adsource consumption by hostile or poorly implemented pro\u00adgrams, we put forward the following qualitative \ncharacteri\u00adzation of our approach, until the resource control model is completely integrated in J-SEAL2: \n When a thread of a parent domain is executing, it is able to terminate its children.  Because there \nis no direct sharing between domains, all resources of a terminated domain can be reclaimed properly. \n A parent can always reserve a fraction of its CPU share for a supervisor thread, which will start executing \nwith priority NORM PRIORITY. This thread wakes up pe\u00adriodically to terminate children that are too long \nin the system; therefore, this thread will not use a lot of CPU time, and the scheduler will not lower \nits priority. All threads in the subdomains will have a priority less or equal to NORM PRIORITY (in particular, \na thread which uses the CPU excessively will have a priority less than NORM PRIORITY). Thus, the supervisor \nwill be eventually scheduled by the JVM, and be able to remove malicious domains.  Resource limits are \nassigned by the parent, and only fully trusted domains are able to create new quotas ex nihilo. A domain \nwith resource limits is not able to extend its own limits.   7. RELATED WORK We distinguish two broad \ncategories of related work on adding resource control to Java: those which have security as main objective, \nand those which follow other motivations. 7.1 Resource Control for Security Purposes Compared to existing \nproposals for realizing resource con\u00adtrol in Java, we broadly di.erentiate our approach in two ways: \n.rst, whether the model supports a process-based ap\u00adproach, with well-de.ned domain boundaries and resource \nallocation for each application, and, second, to which extent the implementation is portable or not. \nJRes [12] is a resource control system which takes CPU, memory, and network resource consumption into \naccount. The resource management model of JRes works at the level of individual Java threads; in other \nwords, there is no notion of application as a group of threads, and the implementation of resource control \npolicies is therefore cumbersome. JRes is a pure resource accounting system and does not enforce any \nseparation of domains; covering this other aspect is the goal of J-Kernel [34], a complementary project \nof the same research team. For its implementation, JRes does not need any modi.cation to the JVM, but \nrelies on a combination of bytecode rewriting and native code libraries. To perform CPU accounting, the \napproach of JRes is to make calls to the underlying operating system, which requires native code to be \naccessed19 . For memory accounting, it essentially uses bytecode rewriting, but still needs the support \nof a native method to account for memory occupied by array objects. Finally, to achieve accounting of \nnetwork bandwidth, the au\u00adthors of JRes also resort to native code, since they swapped the standard java.net \npackage with their own version of it. Ka.eOS [1] is a Java runtime system which supports the operating \nsystem abstraction of process to isolate applica\u00adtions from each other, as if they were run on their \nown JVM. Thanks to Ka.eOS, a modi.ed version of the freely available Ka.e virtual machine [35], it is \npossible to achieve resource control with a higher precision than what is possi\u00adble with bytecode rewriting \ntechniques, where e.g. memory accounting is limited to controlling the respective amounts consumed in \nthe common heap, and where CPU control does not account for time spent by the common garbage collec\u00adtor \nworking for the respective applications. The Ka.eOS approach should by design result in better performance, \nbut is however inherently non-portable. This means that op\u00adtimizations found in compilers and standard \nJVMs are not bene.ted from: in a recent publication [2] the authors report that, in absence of denial-of-service \nattack, IBM s compiler and JVM [24] is 2 5 times faster than theirs. Developed by the same team as Ka.eOS, \nAlta [32] is a pro\u00ad totype based on the Fluke hierarchical process model, and 19More precisely, CPU \naccounting in JRes is based on native threads, a feature not supported by every JVM. implemented on the \nKa.e virtual machine. The main dif\u00adferences with Ka.eOS are that a single garbage collector is responsible \nfor all applications, and that Alta entirely re\u00adspects the hierarchical process model of Fluke by providing \nresource control APIs, whereas Ka.eOS only retains a more implicit nested CPU and memory management scheme. \nNOMADS [29] is a mobile agent system which has the abil\u00ad ity to control resources used by agents, including \nprotection against denial-of-service attacks. The NOMADS execution environment is based on a Java compatible \nVM, the Aroma VM, a copy of which is instantiated for each agent. There is no resource control model \nor API in NOMADS; resources are managed manually, on a per-agent basis or using a non\u00adhierarchical notion \nof group. Relying on a specialized VM, it follows that the overhead is smaller than with our approach; \ncurrently, CPU control is however not implemented. Many other systems are proposed in the literature, \nbut none of them are as complete as JRes, Alta, and Ka.eOS. An ex\u00adcellent overview is provided in [3]. \nTo summarize, we might say that J-SEAL2 proposes a protection model inspired both from Alta and J-Kernel, \nand a memory accounting imple\u00admentation that is more reminiscent of JRes. 7.2 Other Java-centric Approaches \nto Resource Control There are several lines of research, where environments and analysis tools have been \ndesigned that can be exploited more or less with the same objectives as exposed in this paper. The Real-Time \nfor Java Experts Group [8] has published a proposal to add real-time extensions to Java. One impor\u00adtant \nfocus of this work is to ensure predictable garbage col\u00adlection characteristics in order to meet real-time \nguarantees. For instance, the speci.cation provides for several memory management schemes, such as areas \nwith limited lifetime or bounded allocation rates, which could be implemented or at least simulated \n with the J-SEAL2 extensions de\u00adscribed in the present paper. Another real-time system, PERC [23], extends \nJava to support real-time performance guarantees. To this end, the PERC system analyzes Java bytecodes \nto determine memory requirements and maximal execution times, and feeds that information to a real-time \nscheduler. The objective of real-time systems is to provide precise guarantees e.g. for worst-time execution; \nour focus, on the other hand, is on computing approximated resource consumptions in order to prevent \ndenial-of-service attacks. We are more interested in the relative values of applica\u00adtions, and less in \nabsolute .gures. This is con.rmed by the fact that we are not trying to estimate their real CPU con\u00adsumption, \nbut rather to compare the respective number of executed bytecodes. Pro.lers constitute another class \nof tools that have many aspects in common with resource control: both intend to gather information about \nresource usage. Pro.lers however are designed to help developers optimize the e.ciency of their applications, \nand not to externally control their re\u00adsource consumption. The Java Virtual Machine Pro.ling Interface \n(JVMPI) [28] is an API created by Sun; it is a set of hooks to the JVM which signals interesting events \nlike thread start and object allocations. Finally, we mention some approaches that rely on economics\u00adbased \ntheories, using virtual currencies to achieve natural load-balancing of concurrent applications, as well \nas recy\u00adcling of unused resources in open distributed environments, with the anticipated side-e.ect of \npreventing denial-of-service attacks [31]. Our focus is however more on how to implement the basic resource \naccounting mechanisms on a speci.c plat\u00adform, Java, than on the design of high-level and distributed \nresource allocation policies. Nevertheless, whereas the spirit of this paper is rather conservative, \nit does not ex\u00adclude the application of the presently described techniques to the implementation of open \ncomputational markets.  8. CONCLUSION The contributions of this paper are two-fold. First, we pro\u00adpose \na highly portable implementation of resource control in Java, and second, we show how this approach can \nbe cleanly integrated into an existing framework, J-SEAL2, with the creation of a corresponding programming \nmodel. The tech\u00adniques described in this paper have been tested with an o.\u00adline rewriting tool, and the \noverhead due to the accounting code has been measured with the standard SPEC JVM98 benchmarks. Whereas \nother approaches focus on high performance, or demonstrate a long-term, deep re-design of the Java runtime \nsystem, our proposal might be grossly characterized as a language-based patch. Our resource control system \ndoes in\u00addeed not provide the same level of accuracy of measurements and execution speed. On the other \nhand, J-SEAL2 per\u00adfectly ful.lls its job of isolating applications from each other, and particularly \nof preventing abusive resource consumption originating from inside the execution platform. Moreover, \nthe extensive compatibility and portability of our approach makes it immediately usable for the bene.t \nof large-scale distributed object systems, especially when mobile code is involved. Acknowledgments The \nauthors would like to thank Julien Francioli, Rudolf Freund, Andreas Krall, Patrik Mihailescu, Klaus \nRapf, and Jan Vitek for their valuable support. 9. ADDITIONAL AUTHORS Additional authors: Rory G. Vidal \n(University of Geneva, rue G\u00b4en\u00b4eral Dufour 24, CH-1211 Geneva 4, Switzerland, email: vidalr5@cuimail.unige.ch) \n 10. REFERENCES [1] G. Back and W. Hsieh. Drawing the red line in Java. In Seventh IEEE Workshop on Hot \nTopics in Operating Systems, Rio Rico, AZ, USA, Mar. 1999. [2] G. Back, W. Hsieh, and J. Lepreau. Processes \nin Ka.eOS: Isolation, resource management, and sharing in Java. In Proceedings of the Fourth Symposium \non Operating Systems Design and Implementation (OSDI 2000), San Diego, CA, USA, Oct. 2000. [3] G. Back, \nP. Tullmann, L. Stoller, W. Hsieh, and J. Lepreau. Techniques for the design of Java operating systems. \nIn Proceedings of the 2000 USENIX Annual Technical Conference, San Diego, CA, USA, June 2000. [4] G. \nBack, P. Tullmann, L. Stoller, W. C. Hsieh, and J. Lepreau. Java operating systems: Design and implementation. \nTechnical Report UUCS-98-015, University of Utah, Department of Computer Science, Aug. 6, 1998. [5] W. \nBinder. J-SEAL2 A secure high-performance mobile agent system. In IAT 99 Workshop on Agents in Electronic \nCommerce, Hong Kong, Dec. 1999. [6] W. Binder. Design and implementation of the J-SEAL2 mobile agent \nkernel. In The 2001 Symposium on Applications and the Internet (SAINT-2001), San Diego, CA, USA, Jan. \n2001. [7] W. Binder, J. Hulaas, and A. Villaz\u00b4on. Resource control in J-SEAL2. Technical Report Cahier \ndu CUI No. 124, University of Geneva, Oct. 2000. ftp: //cui.unige.ch/pub/tios/papers/TR-124-2000.pdf. \n[8] G. Bollella, B. Brosgol, P. Dibble, S. Furr, J. Gosling, D. Hardin, and M. Turnbull. The Real-Time \nSpeci.cation for Java. Addison-Wesley, Reading, MA, USA, 2000. [9] C. Bryce and J. Vitek. The JavaSeal \nmobile agent kernel. In First International Symposium on Agent Systems and Applications (ASA 99)/Third \nInternational Symposium on Mobile Agents (MA 99), Palm Springs, CA, USA, Oct. 1999. [10] S. Chiba. Load-time \nstructural re.ection in Java. In ECOOP, pages 313 336, 2000. [11] G. Cohen, J. Chase, and D. Kaminsky. \nAutomatic program transformation with JOIE. In 1998 USENIX Annual Technical Symposium, pages 167 178, \n1998. [12] G. Czajkowski and T. von Eicken. JRes: A resource accounting interface for Java. In Proceedings \nof the 13th Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA-98), \nvolume 33, 10 of ACM SIGPLAN Notices, pages 21 35, New York, USA, Oct. 18 22 1998. ACM Press. [13] M. \nDahm. Byte code engineering. In Java-Information-Tage 1999 (JIT 99), Sept. 1999. http://bcel.sourceforge.net/. \n[14] B. Ford, M. Hibler, J. Lepreau, R. McGrath, and P. Tullmann. Interface and execution models in the \n.uke kernel. In Proceedings of the Third Symposium on Operating Systems Design and Implementation (OSDI-99), \npages 101 116, Berkeley, CA, USA, Feb. 22 25 1999. Usenix Association. [15] B. Ford and S. Susarla. \nCPU Inheritance Scheduling. In Usenix Association Second Symposium on Operating Systems Design and Implementation \n(OSDI), pages 91 105, 1996. [16] M. Godfrey, T. Mayr, P. Seshadri, and T. von Eicken. Secure and portable \ndatabase extensibility. In Proceedings of the ACM SIGMOD International Conference on Management of Data \n(SIGMOD-98), volume 27,2 of ACM SIGMOD Record, pages 390 401, New York, USA, June 1 4 1998. ACM Press. \n[17] J. Gosling, B. Joy, and G. L. Steele. The Java Language Speci.cation. The Java Series. Addison-Wesley, \nReading, MA, USA, 1996. [18] J. Hulaas, L. Gannoune, J. Francioli, S. Chachkov, F. Sch\u00a8utz, and J. Harms. \nElectronic commerce of internet domain names using mobile agents. In Proceedings of the Second International \nConference on Telecommunications and Electronic Commerce (ICTEC 99), Nashville, TN, USA, Oct. 1999. [19] \nR. Keller and U. H\u00a8olzle. Binary component adaptation. In E. Jul, editor, ECOOP 98 Object-Oriented Programming, \nvolume 1445 of Lecture Notes in Computer Science, pages 307 329. Springer, 1998. [20] H. B. Lee and B. \nG. Zorn. BIT: A tool for instrumenting Java bytecodes. In Proceedings of the USENIX Symposium on Internet \nTechnologies and Systems (ITS-97), pages 73 82, Berkeley, Dec. 8 11 1997. USENIX Association. [21] T. \nLindholm and F. Yellin. The Java Virtual Machine Speci.cation. Addison-Wesley, Reading, MA, USA, second \nedition, 1999. [22] L. Moreau and C. Queinnec. Design and semantics of Quantum: a language to control \nresource consumption in distributed computing. In Usenix Conference on Domain-Speci.c Languages (DSL \n97), pages 183 197, Santa-Barbara, CA, USA, Oct. 1997. [23] K. Nilsen. Java for real-time. Real-Time \nSystems Journal, 11(2), 1996. [24] T. Suganuma, T. Ogasawara, M. Takeuchi, T. Yasue, M. Kawahito, K. \nIshizaki, H. Komatsu, and T. Nakatani. Overview of the IBM Java Just-in-Time compiler. IBM Systems Journal, \n39(1):175 193, 2000. [25] Sun Microsystems, Inc. Enterprise JavaBeans Technology. Web pages at http://java.sun.com/products/ejb/. \n[26] Sun Microsystems, Inc. JAVA 2 Platform, Standard Edition. Web pages at http://java.sun.com/j2se/1.3/. \n[27] Sun Microsystems, Inc. Java Servlet Technology. Web pages at http://java.sun.com/products/servlet/. \n[28] Sun Microsystems, Inc. Java Virtual Machine Pro.ler Interface (JVMPI). Web pages at http://java.sun. \ncom/j2se/1.3/docs/guide/jvmpi/index.html. [29] N. Suri, J. M. Bradshaw, M. R. Breedy, P. T. Groth, G. \nA. Hill, R. Je.ers, T. S. Mitrovich, B. R. Pouliot, and D. S. Smith. NOMADS: toward a strong and safe \nmobile agent system. In C. Sierra, G. Maria, and J. S. Rosenschein, editors, Proceedings of the 4th International \nConference on Autonomous Agents (AGENTS-00), pages 163 164, NY, June 3 7 2000. ACM Press. [30] The Standard \nPerformance Evaluation Corporation. SPEC JVM98 Benchmarks. Web pages at http://www.spec.org/osg/jvm98/. \n[31] C. F. Tschudin. Open resource allocation for mobile code. In Proceedings of The First Workshop on \nMobile Agents, Berlin, Germany, Apr. 1997. [32] P. Tullmann and J. Lepreau. Nested Java processes: OS \nstructure for mobile code. In Eighth ACM SIGOPS European Workshop, Sintra, Portugal, Sept. 1998. [33] \nJ. Vitek and G. Castagna. Seal: A framework for secure mobile computations. In Internet Programming Languages, \n1999. [34] T. Von Eicken, C.-C. Chang, G. Czajkowski, and C. Hawblitzel. J-Kernel: A capability-based \noperating system for Java. Lecture Notes in Computer Science, 1603:369 394, 1999. [35] T. Wilkinson. \nKa.e -a Java virtual machine. Web pages at http://www.kaffe.org/.   \n\t\t\t", "proc_id": "504282", "abstract": "Preventing abusive resource consumption is indispensable for all kinds of systems that execute untrusted mobile coee, such as mobile object sytems, extensible web servers, and web browsers. To implement the required defense mechanisms, some support for resource control must be available: accounting and limiting the usage of physical resources like CPU and memory, and of logical resources like threads. Java is the predominant implementation language for the kind of systems envisaged here, even though resource control is a missing feature on standard Java platforms. This paper describes the model and implementation mechanisms underlying the new resource-aware version of the J-SEAL2 mobile object kernel. Our fundamental objective is to achieve complete portability, and our approach is therefore based on Java bytecode transformations. Whereas resource control may be targeted towards the provision of quality of service or of usage-based billing, the focus of this paper is on security, and more specificlly on prevention of denial-of-service attacks orginating from hostile or poorly implemented mobile code.", "authors": [{"name": "Walter Binder", "author_profile_id": "81100315534", "affiliation": "CoCo Software Engineering, Margaretenstr. 22/9, A-1040 Vienna, Austria", "person_id": "PP39037357", "email_address": "", "orcid_id": ""}, {"name": "Jane G. Hulaas", "author_profile_id": "81452617827", "affiliation": "University of Geneva, rue G&#233;n&#233;ral Dufour 24, CH-1211 Geneva 4, Switzerland", "person_id": "P344299", "email_address": "", "orcid_id": ""}, {"name": "Alex Villaz&#243;n", "author_profile_id": "81100092572", "affiliation": "University of Geneva, rue G&#233;n&#233;ral Dufour 24, CH-1211 Geneva 4, Switzerland", "person_id": "PP31026832", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/504282.504293", "year": "2001", "article_id": "504293", "conference": "OOPSLA", "title": "Portable resource control in Java", "url": "http://dl.acm.org/citation.cfm?id=504293"}