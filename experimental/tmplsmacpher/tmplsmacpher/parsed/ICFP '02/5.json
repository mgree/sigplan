{"article_publication_date": "09-17-2002", "fulltext": "\n Contracts for Higher-Order Functions Robert Bruce Findler1 Matthias Felleisen Northeastern University \nCollege of Computer Science Boston, Massachusetts 02115, USA Abstract Assertions play an important role \nin the construction of robust soft\u00adware. Their use in programming languages dates back to the 1970s. \nEiffel, an object-oriented programming language, wholeheartedly adopted assertions and developed the \nDesign by Contract philos\u00adophy. Indeed, the entire object-oriented community recognizes the value of \nassertion-based contracts on methods. In contrast, languages with higher-order functions do not support \nassertion-based contracts. Because predicates on functions are, in general, undecidable, specifying such \npredicates appears to be meaningless. Instead, the functional languages community de\u00adveloped type systems \nthat statically approximate interesting pred\u00adicates. In this paper, we show how to support higher-order \nfunction con\u00adtracts in a theoretically well-founded and practically viable man\u00adner. Speci.cally, we introduce \n.CON , a typed lambda calculus with assertions for higher-order functions. The calculus models the as\u00adsertion \nmonitoring system that we employ in DrScheme. We es\u00adtablish basic properties of the model (type soundness, \netc.) and illustrate the usefulness of contract checking with examples from DrScheme s code base. We \nbelieve that the development of an assertion system for higher\u00adorder functions serves two purposes. On \none hand, the system has strong practical potential because existing type systems simply can\u00adnot express \nmany assertions that programmers would like to state. On the other hand, an inspection of a large base \nof invariants may provide inspiration for the direction of practical future type system research. Categories \n&#38; Subject Descriptors: D.3.3, D.2.1; General Terms: De\u00adsign, Languages, Reliability; Keywords: Contracts, \nHigher-order Func\u00adtions, Behavioral Speci.cations, Predicate Typing, Software Reliability 1Work partly \nconducted at Rice University, Houston TX. Address as of 9/2002: University of Chicago; 1100 E 58th Street; \nChicago, IL 60637 Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. ICFP 02, October 4-6, 2002, Pittsburgh, Pennsylvania, USA. Copyright 2002 ACM 1-58113-487-8/02/0010 \n...$5.00 1 Introduction Dynamically enforced pre-and post-condition contracts have been widely used in \nprocedural and object-oriented languages [11, 14, 17, 20, 21, 22, 25, 31]. As Rosenblum [27] has shown, \nfor example, these contracts have great practical value in improving the robust\u00adness of systems in procedural \nlanguages. Eiffel [22] even developed an entire philosophy of system design based on contracts ( Design \nby Contract ). Although Java [12] does not support contracts, it is one of the most requested extensions.1 \nWith one exception, higher-order languages have mostly ignored assertion-style contracts. The exception \nis Bigloo Scheme [28], where programmers can write down .rst-order, type-like con\u00adstraints on procedures. \nThese constraints are used to generate more ef.cient code when the compiler can prove they are correct \nand are turned into runtime checks when the compiler cannot prove them correct. First-order procedural \ncontracts have a simple interpretation. Con\u00adsider this contract, written in an ML-like syntax: f: int[> \n9] . int[0,99] val rec f = . x. \u00b7\u00b7\u00b7 It states that the argument to f must be an int greater than 9 and \nthat f produces an int between 0 and 99. To enforce this contract, a contract compiler inserts code to \ncheck that x is in the proper range when f is called and that f s result is in the proper range when \nf returns. If x is not in the proper range, f s caller is blamed for a contractual violation. Symmetrically, \nif f s result is not in the proper range, the blame falls on f itself. In this world, detecting contractual \nviolations and assigning blame merely means checking appropriate predicates at well-de.ned points in \nthe program s eval\u00aduation. This simple mechanism for checking contracts does not generalize to languages \nwith higher-order functions. Consider this contract: g: (int[> 9] . int[0,99]) . int[0,99] val rec g \n= . proc. \u00b7\u00b7\u00b7 The contract s domain states that gaccepts int . int functions and must apply them to \nints larger than 9. In turn, these functions must produce ints between 0 and 99. The contract s range \nobliges g to produce ints between 0 and 99. 1http://developer.java.sun.com/developer/bugParade/top25rfes.html \nAlthough g may be given f, whose contract matches g s domain contract, g should also accept functions \nwith stricter contracts: h: int[> 9] . int[50,99] val rec h = . x. \u00b7\u00b7\u00b7 g(h), functions without explicit \ncontracts: g(. x. 50), functions that process external data: read num : int[> 9] . int[0,99] val rec \nread num = . n. \u00b7\u00b7\u00b7 read the nth entry from a .le \u00b7\u00b7\u00b7 g(read num), and functions whose behavior depends \non the context: val rec dual purpose = . x. if \u00b7\u00b7\u00b7 predicate on some global state \u00b7\u00b7\u00b7 then 50 else 5000. \n as long as the context is properly established when g applies its argument. Clearly, there is no algorithm \nto statically determine whether proc matches its contract, and it is not even possible to dynamically \ncheck the contract when g is applied. Even worse, it is not enough to monitor applications of proc that \noccur in g s body, because g may pass proc to another function or store it in a global variable. Additionally, \nhigher-order functions complicate blame assignment. With .rst-order functions, blame assignment is directly \nlinked to pre-and post-condition violations. A pre-condition violation is the fault of the caller and \na post-condition violation is the fault of the callee. In a higher-order world, however, promises and \nobligations are tangled in a more complex manner, mostly due to function\u00advalued arguments. In this paper, \nwe present a contract system for a higher-order world. The key observation is that a contract checker \ncannot ensure that g s argument meets its contract when g is called. Instead, it must wait until proc \nis applied. At that point, it can ensure that proc s argu\u00adment is greater than 9. Similarly, when proc \nreturns, it can ensure that proc s result is in the range from 0 to 99. Enforcing contracts in this manner \nensures that the contract violation is signaled as soon as the contract checker can establish that the \ncontract has indeed been violated. The contract checker provides a .rst-order value as a wit\u00adness to \nthe contract violation. Additionally, the witness enables the contract checker to properly assign blame \nfor the contract violation to the guilty party. The next section introduces the subtleties of assigning \nblame for higher-order contract violations through a series of examples in Scheme [8, 16]. Section 3 \npresents .CON , a typed, higher-order functional programming language with contracts. Section 4 speci\u00ad.es \nthe meaning of .CON, and section 5 provides an implementation of it. Section 6 contains a type soundness \nresult and proves that the implementation in section 5 matches the calculus. Section 7 shows how to extend \nthe calculus with function contracts whose range de\u00adpends on the input to the function, and section 8 \ndiscusses the inter\u00adactions between contracts and tail recursion. 2 Example Contracts We begin our presentation \nwith a series of Scheme examples that explain how contracts are written, why they are useful, and how \nto check them. The .rst few examples illustrate the syntax and the ba\u00adsic principles of contract checking. \nSections 2.2 and 2.3 discuss the problems of contract checking in a higher-order world. Section 2.4 explains \nwhy it is important for contracts to be .rst-class values. Section 2.5 demonstrates how contracts can \nhelp with callbacks, the most common use of higher-order functions in a stateful world. To illustrate \nthese points, each section also includes examples from the DrScheme [5] code base. 2.1 Contracts: A First \nLook The .rst example is the sqrt function: ;; sqrt : number . number (de.ne/contract sqrt ((. (x)(= \nx 0)) -. (. (x)(= x 0))) (. (x) \u00b7\u00b7\u00b7)) Following the tradition of How to Design Programs [3], the sqrt \nfunction is proceeded by an ML-like [23] type speci.cation (in a comment). Like Scheme s de.ne,a de.ne/contract \nexpression consists of a variable and an expression for its initial value, a func\u00adtion in this case. \nIn addition, the second subterm of de.ne/contract speci.es a contract for the variable. Contracts are \neither simple predicates or function contracts. Func\u00adtion contracts, in turn, consist of a pair of contracts \n(each either a predicate or another function contract), one for the domain of the function and one for \nthe range of the function: CD -. CR. The domain portion of sqrt s contract requires that it always re\u00adceives \na non-negative number. Similarly, the range portion of the contract guarantees that the result is non-negative. \nThe example also illustrates that, in general, contracts check only certain aspects of a function s behavior, \nrather than the complete semantics of the function. The contract position of a de.nition can be an arbitrary \nexpression that evaluates to a contract. This allows us to clarify the contract on sqrt by de.ning a \nbigger-than-zero? predicate and using it in the de.nition of sqrt s contract: ;; bigger-than-zero? : \nnumber . boolean (de.ne bigger-than-zero? (. (x)(= x 0))) ;; sqrt : number . number (de.ne/contract sqrt \n(bigger-than-zero? -. bigger-than-zero? ) (. (x) \u00b7\u00b7\u00b7)) The contract on sqrt can be strengthened by relating \nsqrt s result to its argument. The dependent function contract constructor allows the programmer to specify \nrange contracts that depend on the value of the function s argument. This constructor is similar to -., \nex\u00adcept that the range position of the contract is not simply a contract. Instead, it is a function that \naccepts the argument to the original function and returns a contract: d CD -. (. (arg) CR) (module preferences \nscheme/contract (provide add-panel open-dialog ) ;; add-panel : (panel . panel ) . void (de.ne/contract \nadd-panel ((any -. (. (new-child ) (let ([children (send (send new-child get-parent) get-children )]) \n(eq? (car children ) new-child )))) -. any) (. (make-panel) (set! make-panels (cons make-panel make-panels \n)))) ;; make-panels : (listof (panel . panel )) (de.ne make-panels null ) ;; open-dialog : . void (de.ne \nopen-dialog (. () (let* ([d (instantiate dialog% () \u00b7\u00b7\u00b7)] [sp (instantiate single-panel% () (parentd \n))] [children (map (call-make-panel sp ) make-panels)]) \u00b7\u00b7\u00b7))) ;; call-make-panel : panel . (panel . \npanel ) . panel (de.ne call-make-panel (. (sp) (. (make-panel ) (make-panel sp))))) Figure 1. Contract \nSpeci.ed with add-panel Here is an example of a dependent contract for sqrt: ;; sqrt : number . number \n(de.ne/contract sqrt d (bigger-than-zero? -. (. (x) (. (res ) (and (bigger-than-zero? res ) (= (abs (- \nx (* res res ))) 0.01))))) (. (x) \u00b7\u00b7\u00b7)) This contract, in addition to stating that the result of sqrt \nis positive, also guarantees that the square of the result is within 0.01 of the argument.  2.2 Enforcement \nat First-Order Types The key to checking higher-order assertion contracts is to post\u00adpone contract enforcement \nuntil some function receives a .rst-order value as an argument or produces a .rst-order value as a result. \nThis section demonstrates why these delays are necessary and dis\u00adcusses some rami.cations of delaying \nthe contracts. Consider this toy module: (module delayed scheme/contract (provide save use) ;; saved \n: integer . integer (de.ne saved (. (x) 50)) ;; save : (integer . integer) . void (de.ne/contract save \n((bigger-than-zero? . bigger-than-zero? ) . any) (. (f)(set! saved f))) ;; use : integer . integer \n(de.ne use (module preferences scheme (provide add-panel open-dialog ) ;; add-panel : (panel . panel \n) . void (de.ne add-panel (. (make-panel) (set! make-panels (cons make-panel make-panels )))) ;; make-panels \n: (listof (panel . panel )) (de.ne make-panels null ) ;; open-dialog : . void (de.ne open-dialog (. \n() (let* ([d (instantiate dialog% () \u00b7\u00b7\u00b7)] [sp (instantiate single-panel% () (parentd ))] [children (map \n(call-make-panel sp ) make-panels)]) \u00b7\u00b7\u00b7))) ;; call-make-panel : panel . (panel . panel ) . panel (de.ne \ncall-make-panel (. (sp) (. (make-panel ) (let ([new-child (make-panel sp)] [children (send (send new-child \nget-parent) get-children )]) (unless (eq? (car children ) new-child ) (contract-error make-panel )) new-child \n) )))) Figure 2. Contract Manually Distributed (bigger-than-zero? . bigger-than-zero? ) (. (n)(saved \nn)))) The module [8, 9] declaration consists of a name for the module, the language in which the module \nis written, a provide declaration and a series of de.nitions. This module provides save and use . The \nvariable saved holds a function that should map positive numbers to positive numbers. Since it is not \nexported from the module, it has no contract. The getter (use ) and setter (save) are the two vis\u00adible \naccessors of saved. The function save stores a new function and use invokes the saved function. Naturally, \nit is impossible for save to detect if the value of saved is always applied to positive numbers since \nit cannot determine every argument to use. Worse, save cannot guarantee that each time saved s value \nis applied that it will return a positive result. Thus, the contract checker delays the enforcement of \nsave s contract until save s argument is actually ap\u00adplied and returns. Accordingly, violations of save \ns contract might not be detected until use is called. In general, a higher-order contract checker must \nbe able to track contracts during evaluation from the point where the contract is es\u00adtablished (the call \nsite for save) to the discovery of the contract violation (the return site for use ), potentially much \nlater in the eval\u00aduation. To assign blame, the contract checker must also be able to report both where \nthe violation was discovered and where the con\u00adtract was established. The toy example is clearly contrived. \nThe underlying phe\u00adnomenon, however, is common. For a practical example, consider DrScheme s preferences \npanel. DrScheme s plugins can add addi\u00adtional panels to the preferences dialog. To this end, plugins \nregister callbacks that add new panels containing GUI controls (buttons, list-boxes, pop-up menus, etc.) \nto the preferences dialog. ;; make/c : (aa . bool) . a . a . bool (de.ne (make/c op)(. (x)(. (y)(opy \nx)))) ;; =/c, =/c : number . number . bool (de.ne =/c (make/c =)) (de.ne =/c (make/c =)) ;; eq/c, equal/c \n: any . any . bool (de.ne eq/c (make/c eq? )) (de.ne equal/c (make/c equal?)) ;; any : any . bool (de.ne \nany (. (x) #t)) Figure 3. Abstraction for Predicate Contracts Every GUI control needs two values: a parent, \nand a callback that is invoked when the control is manipulated. Some GUI controls need additional control-speci.c \nvalues, such as a label or a list of choices. In order to add new preference panels, extensions de.ne \na function that accepts a parent panel, creates a sub-panel of the parent panel, .lls the sub-panel with \ncontrols that con.gure the extension, and returns the sub-panel. These functions are then registered \nby call\u00ading add-panel . Each time the user opens DrScheme s preferences dialog, DrScheme constructs the \npreferences dialog from the regis\u00adtered functions. Figure 1 shows the de.nition of add-panel and its \ncontract (boxed in the .gure). The contract requires that add-panel s arguments are functions that accept \na single argument. In addition, the contract guarantees that the result of each call to add-panel s argument \nis a panel and is the .rst child in its parent panel. Together, these checks ensure that the order of \nthe panels in the preferences dialog matches the order of the calls to add-panel . The body of add-panel \nsaves the panel making function in a list. Later, when the user opens the preferences dialog, the open-dialog \nfunction is called, which calls the make-panel functions, and the contracts are checked. The dialog% \nand single-panel% classes are part of the primitive GUI library and instantiate creates instances of \nthem. In comparison, .gure 2 contains the checking code, written as if there were no higher-order contract \nchecking. The boxed portion of the .gure, excluding the inner box, is the contract checking code. The \ncode that enforces the contracts is co-mingled with the code that implements the preferences dialog. \nCo-mingling these two de\u00adcreases the readability of both the contract and call-make-panel , since client \nprogrammers now need to determine which portion of the code concerns the contract checking and which \nperforms the function s work. In addition, the author of the preferences module must .nd every call-site \nfor each higher-order function. Finding these sites in general is impossible, and in practice the call \nsites are often in collaborators code, whose source might not be available.  2.3 Blame and Contravariance \nAssigning blame for contractual violations in the world of .rst-class functions is complex. The boundaries \nbetween cooperating compo\u00adnents are more obscure than in the world with only .rst-order func\u00adtions. In \naddition to invoking a component s exported functions, one component may invoke a function passed to \nit from another component. Applying such .rst-class functions corresponds to a .ow of values between \ncomponents. Accordingly, the blame for a corresponding contract violation must lie with the supplier \nof the bad value, no matter if the bad value was passed by directly apply\u00ading an exported function or \nby applying a .rst-class function. As with .rst-order function contract checking, two parties are in\u00advolved \nfor each contract: the function and its caller. Unlike .rst\u00adorder function contract checking, a more \ngeneral rule applies for blame assignment. The rule is based on the number of times that each base contract \nappears to the left of an arrow in the higher-order contract. If the base contract appears an even number \nof times, the function itself is responsible for establishing the contract. If it ap\u00adpears an odd number \nof times, the function s caller is responsible. This even-odd rule captures which party supplies the \nvalues and corresponds to the standard notions of covariance (even positions) and contravariance (odd \npositions). Consider the abstract example from the introduction again, but with a little more detail. \nImagine that the body of g isa call to f with 0: ;; g: (integer . integer) . integer (de.ne/contract \ng ((greater-than-nine? -. between-zero-and-ninety-nine? ) -. between-zero-and-ninety-nine? ) (. (f)(f \n0))) At the point when g invokes f, the greater-than-nine? portion of g s contract fails. According \nto the even-odd rule, this must be g s fault. In fact, gdoes supply the bad value, so g must be blamed. \nImagine a variation of the above example where g applies f to 10 instead of 0. Further, imagine that \nf returns -10. This is a violation of the result portion of g s argument s contract and, following the \neven-odd rule, the fault lies with g s caller. Accordingly, the con\u00adtract enforcement mechanism must \ntrack the even and odd positions of a contract to determine the guilty party for contract violations. \nThis problem of assigning blame naturally appears in contracts from DrScheme s implementation. For example, \nDrScheme creates a separate thread to evaluate user s programs. Typically, extensions to DrScheme need \nto initialize thread-speci.c hidden state before the user s program is run. The accessors and mutators \nfor this state implicitly accept the current thread as a parameter, so the code that initializes the \nstate must run on the user s thread.2 To enable DrScheme s extensions to run code on the user s thread, \nDrScheme provides the primitive run-on-user-thread . It accepts a thunk, queues the thunk to be run on \nthe user s thread and returns. It has a contract that promises that when the argument thunk is ap\u00adplied, \nthe current thread is the user s thread: ;; run-on-user-thread : (. void) . void (de.ne/contract run-on-user-thread \n(((. () (eq? (current-thread ) user-thread )) -. any) -. any) (. (thunk ) \u00b7\u00b7\u00b7)) This contract is a higher-order \nfunction contract. It only has one interesting aspect: the pre-condition of the function passed to run\u00adon-user-thread \n. This is a covariant (even) position of the function contract which, according to the rule for blame \nassignment, means that run-on-user-thread is responsible for establishing this contract. 2This state \nis not available to user s program because the accessors and mutators are not lexically available to \nthe user s program. (module preferences scheme/contract (provide add-panel \u00b7\u00b7\u00b7) ;; preferences:add-panel \n: (panel . panel ) . void (de.ne/contract add-panel d ((any -. (. (sp) (let ([pre-children (copy-spine \n(send sp get-children))]) (. (new-child) (let ([post-children (send sp get-children)]) (and (= (length \npost-children ) (add1 (length pre-children ))) (andmap eq? (cdr post-children) pre-children ) (eq? (car \npost-children ) new-child ))))))) -. any) (. (make-panel) (set! make-panels (cons make-panel make-panels \n)))) \u00b7\u00b7\u00b7 ;; copy-spine : (listof a) . (listof a) (de.ne (copy-spinel )(map (. (x) x) l))) Figure 4. \nPreferences Panel Contract, Protecting the Panel Therefore, run-on-user-thread contractually promises \nclients of this function that the thunks they supply are applied on the user s thread and that these \nthunks can initialize the user s thread s state.  2.4 First-class Contracts Experience with DrScheme \nhas shown that certain patterns of con\u00adtracts recur frequently. To abstract over these patterns, contracts \nmust be values that can be passed to and from functions. For exam\u00adple, curried comparision operators \nare common (see .gure 3). More interestingly, patterns of higher-order function contracts are also common. \nFor example, DrScheme s code manipulates mix\u00adins [7, 10] as values. These mixins are functions that accept \na class and returns a class derived from the argument. Since extensions of DrScheme supply mixins to \nDrScheme, it is important to verify that the mixin s result truly is derived from its input. Since this \ncontract is so common, it is de.ned in DrScheme s contract library: ;; mixin-contract : (class . class) \ncontract (de.ne mixin-contract d (class? -. (. (arg)(. (res)(subclass? res arg))))) This contract is \na dependent contract. It states that the input to the function is a class and its result is a subclass \nof the input. Further, it is common for the contracts on these mixins to guar\u00adantee that the base class \npassed to the mixin is not just any class, but a class that implements a particular interface. To support \nthese contracts, DrScheme s contract library provides this function that constructs a contract: ;; mixin-contract/intf \n: interface . (class . class) contract (de.ne mixin-contract/intf (. (interface ) ((. (x)(implements? \nx interface)) d -. (. (arg)(. (res)(subclass? res arg)))))) The mixin-contract/intf function accepts \nan interface as an argu\u00adment and produces a contract similar to mixin-contract , except that the contract \nguarantees that input to the function is a class that im\u00adplements the given interface. Although the mixin \ncontract is, in principle, checkable by a type system, no such type system is currently implemented. \nOCaml [18, 19, 26] and OML [26] are rich enough to express mixins, but type\u00adchecking fails for any interesting \nuse of mixins [7], since the type system does not allow subsumption for imported classes. This con\u00adtract \nis an example where the expressiveness of contracts leads to an opportunity to improve existing type \nsystems. Hopefully this example will encourage type system designers to build richer type systems that \nsupport practical mixins. 2.5 Callbacks and Stateful Contracts Callbacks are notorious for causing problems \nin preserving invari\u00adants. Szyperski [32] shows why callbacks are important and how they cause problems. \nIn short, code that invokes the callback must guarantee that certain state is not modi.ed during the \ndynamic ex\u00adtent of the callback. Typically, this invariant is maintained by ex\u00adamining the state before \nthe callback is invoked and comparing it to the state after the callback returns.3 Consider this simple \nlibrary for registering and invoking callbacks. (module callbacks scheme/contract (provide register-callback \ninvoke-callback) ;; register-callback : (. void) . void (de.ne/contract register-callback (any d -. (. \n(arg) (let ([old-state \u00b7\u00b7\u00b7 save the relevant state \u00b7\u00b7\u00b7]) (. (res) \u00b7\u00b7\u00b7 compare the new state to the old \nstate \u00b7\u00b7\u00b7)))) (. (c) (set! callback c))) ;; invoke-callback : . void (de.ne invoke-callback (. () (callback \n))) ;; callback : . void (de.ne callback (. () (void)))) The function register-callback accepts a callback \nfunction and reg\u00adisters it as the current callback. The invoke-callback function calls the callback. \nThe contract on register-callback makes use of the dependent contract constructor in a new way. The contract \nchecker applies the dependent contract to the original function s arguments before the function itself \nis applied. Therefore, the range portion of a dependent contract can determine key aspects of the state \nand save them in the closure of the resulting predicate. When that pred\u00adicate is called with the result \nof the function, it can compare the current version of the state with the original version of the state, \nthus ensuring that the callback is well-behaved. This technique is useful in the contract for DrScheme \ns preferences panel, whose contract we have already considered. Consider the revision of add-panel s \ncontract in .gure 4. The revision does more 3In practice, lock variables are often used for this; the \ntechnique pre\u00adsented here adapts to a lock-variable based solution to the callback problem. core syntax \np= d \u00b7\u00b7\u00b7 e d = val rec x: e = e e = . x. e | ee | x | .x x.e | n | e aop e | e rop e | e::e | [] | hd(e) \n| tl(e) | mt(e) | if e then e else e | true | false | str | e -. e | contract(e) | .atp(e) | pred (e) \n| dom(e) | rng(e) | blame (e) str = \"\" | \"a\" | \"b\" | \u00b7\u00b7\u00b7 | \"aa\" | \"ab\" | \u00b7\u00b7\u00b7 rop =+ |*|-| / aop = =| \n= x = variables n = 0 | 1 | \u00b7\u00b7\u00b7 | -1 |-2 | \u00b7\u00b7\u00b7 types t = t . t | t list | int | bool | string | t contract \nevaluation contexts P = val rec x:V = V \u00b7\u00b7\u00b7 val rec x:E = e d \u00b7\u00b7\u00b7 e | val rec x:V = V \u00b7\u00b7\u00b7 val rec x:V \n= E d \u00b7\u00b7\u00b7 e | val rec x:V = V \u00b7\u00b7\u00b7 E E = Ee | VE | E aop e| V aopE | E rop e | V ropE | E ::e | V ::E \n| hd(E) | tl(E) | if E then e else e | E -. e | V -. E | contract(E) | dom(E) | rng(E) | pred (E) | .atp(E) \n| blame (E) | D values V = V ::V | . x.M | str | n | true | false | V -. V | contract(V) Vp = val rec \nx:V = V \u00b7\u00b7\u00b7 V Figure 5. .CON Syntax, Types, Evaluation Contexts, and Values than just ensure that the \nnew child is the .rst child. In addition, it guarantees that the original children of the preferences \npanel remain in the panel in the same order, thus preventing an extension from removing the other preference \npanels.   3 Contract Calculus Although contracts can guarantee stronger properties than types about \nprogram execution, their guarantees hold only for particular program executions. In contrast, the type \nchecker s weaker guaran\u00adtees hold for all program executions. As such, contracts and types play synergistic \nroles in program development and maintenance so practical programming languages must support both. In \nthat spirit, this calculus contains both types and contracts to show how they interact. Figure 5 contains \nthe syntax for the contract calculus. Each pro\u00adgram consists of a series of de.nitions, followed by a \nsingle expres\u00adsion. Each de.nition consists of a variable, a contract expression and an expression for \ninitializing the variable. All of the variables bound by val rec in a single program must be distinct. \nAll of the P[I n1 l /0] -. error (/) Il + IlIl n1 n2 n1 + n2 Il*IlI l n1 n2 n1 * n2 IlIl n1 l /I n2 n1 \n/n2 Il-IlI l n1 n2 n1 - n2 I l=I l n1 n2 true if n1 = n2 Il l=I n1 n2 false if n1 < n2 Il l n1 = I n2 \ntrue if n1 = n2 Il l n1 = I n2 false if n1 = n2 . x.eV e[x/V] .x x.e e[x/ .x x.e ] P[x] -. P[e2] where \nP contains val rec x: e1 = e2 if true then e1 else e2 e1 if false then e1 else e2 e2 hd(V1 ::V2) V1 P[hd([])] \n-. error (hd) tl(V1 ::V2) V2 P[tl([])] -. error (tl) mt([]) true mt(V1 ::V2) false .atp(contract(V)) \ntrue .atp(V1 -. V2) false pred(contract(V)) V P[pred(V1 -. V2)] -. error (pred ) dom(V1 -. V2) V1 P[dom(contract(V))] \n-. error (dom) rng(V1 -. V2) V2 P[rng(contract(V))] -. error (rng) P[blame (p)] -. error (p) ' where \nP[e] -. P[e'] if e e Figure 6. Reduction Semantics of .CON de.nitions are mutually recursive, except \nthat the contract positions may only refer to de.ned variables that appear earlier in a program. Expressions \n(e) include abstractions, applications, variables, .x points, numbers and numeric primitives, lists and \nlist primitives, if expressions, booleans, and strings. The .nal expression forms specify contracts. \nThe contract(e) and e -. e expressions con\u00adstruct .at and function contracts, respectively. A .atp expression \nreturns true if its argument is a .at contract and false if its argument is a function contract. The \npred, dom, and rng expressions select the .elds of a contract. The blame primitive is used to assign \nblame to a de.nition that violates its contract. It aborts the program. This .rst model omits dependent \ncontracts; we return to them later. The types for .CON are those of core ML (without polymorphism), plus \ntypes for contract expressions. The typing rules for contracts are given in .gure 7. The .rst typing \nrule is for complete programs. A program s type is a record of types, written: ( t \u00b7\u00b7\u00b7 ) where the .rst \ntypes are the types of the de.nitions and the last type is the type of the .nal expression. Contracts \non .at values are tagged by the contract value construc\u00adtor and must be predicates that operate on the \nappropriate type. Contracts for functions consist of two contracts, one for the domain G + { xj = tj \n| 0 = j< i }. e1i :ti contract \u00b7\u00b7\u00b7 G + { xi = ti, \u00b7\u00b7\u00b7 } . e2i :ti \u00b7\u00b7\u00b7 G + { xi = ti, \u00b7\u00b7\u00b7 } . e:t G . \nval rec xi :e1i = e2i \u00b7\u00b7\u00b7 e: ( ti \u00b7\u00b7\u00b7 t ) G . e:t . bool G . e1 :t1 contract G . e2 :t2 contract G . \ne: string G . contract(e) :t contract G . (e1 -. e2) :t1 . t2 contract G . blame (e) :t G . e:t1 . t2 \ncontract G . e:t1 . t2 contract G . e:t contract G . e:t contract G . dom(e) :t1 contract G . rng(e) \n:t2 contract G . pred (e) :t . bool G . .atp(e) : bool G + {x: t1}. e:t2 G . e1 :t1 . t2 G . e2 :t1 G \n+ {x:t}. e:t G . . x. e : t1 . t2 G . (e1 e2) :t2 G + {x:t}. x:t G . .x x. e : t G . e1 : int G . e2 \n: int G . e1 : int G . e2 : int G . n: int G . e1 aop e2 : bool G . e1 rop e2 : int G . e1 :t G . e2 \n:t list G . e:t list G . e:t list G . e:t list G . e1 :: e2 :t list G . [] :t list G . mt(e) : bool G \n. hd(e) :t G . tl(e) :t list G . e1 : bool G . e2 :t G . e3 :t G . if e1 then e2 else e3 :t G . true \n: bool G . false : bool G . str : string Figure 7. .CON Type Rules and one for the range of the function. \nThe typing rule for de.ni\u00adtions ensures that the type of the contract matches the type of the de.nition. \nThe rest of the typing rules are standard. Consider this de.nition of the sqrt function: val rec sqrt \n: contract(. x.x = 0) -. contract(. x.x = 0) = . n. \u00b7\u00b7\u00b7 The body of the sqrt function has been elided. \nThe contract on sqrt must be an -. contract because the type of sqrt is a function type. Further, the \ndomain and range portions of the contract are predi\u00adcates on integers because sqrt consumes and produces \nintegers.4 More succinctly, the predicates in this contract augment the sqrt s type, indicating that \nthe domain and range must be positive. Figures 5 and 6 de.ne a conventional reduction semantics for the \nbase language without contracts [4].  4 Contract Monitoring As explained earlier, the contract monitor \nmust perform two tasks. First, it must track higher-order functions to discover contract vio\u00adlations. \nSecond, it must properly assign blame for contract viola\u00adtions. To this end, it must track higher-order \nfunctions through the program s evaluation and the covariant and contravariant portions of each contract. \nTo monitor contracts, we add a new form of expression, some new values, evaluation contexts and reduction \nrules. Figure 8 contains the new expression form, representing an obligation: e,x,xe The .rst superscript \nis a contract expression that the base expression is obliged to meet. The last two are variables. The \nvariables enable 4Technically, sqrt should consume and produce any number, but since .CON only contains \nintegers and the precise details of sqrt are unimportant, we consider a restricted form of sqrt that \noperates on integers. the contract monitoring system to assign blame properly. The .rst variable names \nthe party responsible for values that are produced by the expression under the superscript and the second \nvariable names the party responsible for values that it consumes. An implementation would add a fourth \nsuperscript, representing the source location where the contract is established. This superscript would \nbe carried along during evaluation until a contract violation is discovered, at which point it would \nbe reported as part of the error message. In this model, each de.nition is treated as if it were written \nby a different programmer. Thus, each de.nition is considered to be a separate entity for the purpose \nof assigning blame. In an implemen\u00adtation, this is too .ne-grained. Blame should instead be assigned \nto a coarser construct, e.g., Modula s modules, ML s structures and functors, or Java s packages. In \nDrScheme, we blame modules [9]. Programmers do not write obligation expressions. Instead, con\u00adtracts \nare extracted from the de.nitions and turned into obligations. To enforce this, we de.ne the judgment \np ok that holds when there are no obligation expressions in p. Obligations are placed on each reference \nto a val rec-de.ned vari\u00adable. The .rst part of the obligation is the de.nition s contract ex\u00adpression. \nThe .rst variable is initially the name of the referenced de.nition. The second variable is initially \nthe name of the de.ni\u00adtion where the reference occurs (or main if the reference occurs in the last expression). \nThe function I (de.ned in the accompanying technical report [6]) speci.es precisely how to insert the \nobligations expressions. The introduction of obligation expressions induces the extension of the set \nof evaluation contexts, as shown in .gure 8. They spec\u00adify that the value of the superscript in an obligation \nexpression is determined before the base value. Additionally, the obligation ex\u00adpression induces a new \ntype rule. The type rule guarantees that the obligation is an appropriate contract for the base expression. \nobligation expressions e,x,x e = \u00b7\u00b7\u00b7 | e obligation type rule G . e1 :t G . e2 :t contract G . e1 e2,x,x: \nt obligation evaluation contexts E = \u00b7\u00b7\u00b7 | eE,x,x | EV,x,x obligation values -. V,x,x V = \u00b7\u00b7\u00b7 | VV obligation \nreductions contract(V2),p,n] .at D[V1 -. D[if V2(V1) then V1 else blame (\"p\")] (V3 -. V4),p,nV2)] V3,n,p)V4,p,n] \nhoc D[(V1-. D[(V1 V2 Figure 8. Monitoring Contracts in .CON Finally, we add the class of labeled values. \nThe labels are function obligations (see .gure 8). Although the grammar allows any value to be labeled \nwith a function contract, the type soundness theorem coupled with the type rule for obligation expressions \nguarantees that the delayed values are always functions, or functions wrapped with additional obligations. \nFor the reductions in .gure 6, superscripted evaluation proceeds just like the original evaluation, except \nthat the superscript is car\u00adried from the instruction to its result. There are two additional re\u00adductions. \nFirst, when a predicate contract reaches a .at value, the predicate on that .at value is checked. If \nthe predicate holds, the contract is discarded and evaluation continues. If the predicate fails, execution \nhalts and the de.nition named by the variable in the pos\u00aditive position of the superscript is blamed. \nThe .nal reduction of .gure 8 is the key to contract checking for higher-order functions (the hoc above \nthe arrow stands for higher\u00adorder contract ). At an application of a superscripted procedure, the domain \nand range portion of the function position s superscript are moved to the argument expression and the \nentire application. Thus, the obligation to maintain the contract is distributed to the argument and \nthe result of the application. As the obligation moves to the argument position of the application, the \nvalue producer and the value consumer exchange roles. That is, values that are being provided to the \nfunction are being provided from the argument and vice versa. Accordingly, the last two superscripts \nof the obligation expression must be reversed, which ensures that blame is properly assigned, according \nto the even-odd rule. For example, consider the de.nition of sqrt with a single use in the main expression. \nThe reduction sequence for the application of sqrt is shown on the left in .gure 10. For brevity, references \nto variables de.ned by val rec are treated as values, even though they would actually reduce to the variable \ns current values. The .rst reduction is an example of how obligations are distributed on an application. \nThe domain portion of the superscript contract is moved to the argument of the procedure and the range \nportion is moved to the application. The second reduction and the second wrap: t contract . t . string \n. string . t wrap = .x wrap. . ct. . x. . p. . n. if .atp(ct) then if (pred (ct)) x then x else error \n(p) else let d = dom(ct) r = rng(ct) in . y. wrap r (x (wrapdy np)) p n Figure 9. Contract Compiler \nWrapping Function to last reduction are examples of how .at contracts are checked. In this case, each \npredicate holds for each value. If, however, the predicate had failed in the second reduction step, main \nwould be blamed, since main supplied the value to sqrt. If the predicate had failed in the second to \nlast reduction step, sqrt would be blamed since sqrt produced the result. For a second example, recall \nthe higher-order program from the introduction (translated to the calculus): val rec gt9 = . x. x = 9 \n val rec bet0 99 = . x. if 99 = x then x = 0 else false val rec g: ((gt9 -. bet0 99) -. bet0 99) = . \nf.f 0 g(. x. 25) The de.nitions of gt9 and bet0 99 are merely helper functions for de.ning contracts \nand, as such, do not need contracts. Although the calculus does not allow such de.nitions, it is a simple \nextension to add them; the contract checker would simply ignore them. Accordingly, the variable g in \nthe body of the main expression is the only reference to a de.nition with a contract. Thus, it is the \nonly variable that is compiled into an obligation. The contract for the obligation is g s contract. If \nan even position of the contract is not met, g is blamed and if an odd position of the contract is not \nmet, main is blamed. Here is the reduction sequence: ((gt9 -. bet0 99) -. bet0 99),g,main (. x. 25) g \n-. (g(. x. 25)(gt9 -. bet0 99),main,g)bet0 99,g,main -. ((. x. 25)(gt9 -. bet0 99),main,g 0)bet0 99,g,main \n-. (((. x. 25) 0gt9,g,main )bet0 99,main,g)bet0 99,g,main -. (((. x. 25) (if gt9(0) then 0 else blame \n(\"g\")))bet0 99,main,g)bet0 99,g,main -.* blame (\"g\") In the .rst reduction step, the obligation on g \nis distributed to g s argument and to the result of the application. Additionally, the vari\u00adables indicating \nblame are swapped in (. x. 25) s obligation. The second step substitutes . x. 25 in the body of g, resulting \nin an ap\u00adplication of . x. 25 to 0. The third step distributes the contract on . x. 25 to 0 and to the \nresult of the application. In addition, the vari\u00adables for even and odd blame switch positions again \nin 0 s contract. The fourth step reduces the .at contract on 0 to an if test that deter\u00admines if the \ncontract holds. The .nal reduction steps assign blame to g for supplying 0 to its argument, since it \npromised to supply a number greater than 9. ORIGINAL PROGRAM val rec sqrt : contract(. x.x = 0) -. contract(. \nx.x = 0) = . n. \u00b7\u00b7\u00b7 body intentionally elided \u00b7\u00b7\u00b7 sqrt 4 REDUCTIONS IN .CON sqrt(contract(. x.x = 0) \n-. contract(. x.x = 0)),sqrt,main 4 -. (sqrt 4contract(. x.x = 0),main,sqrt )contract(. x.x = 0),sqrt,main \n-. (sqrt (if (. x.x = 0) 4 then 4 else blame (main)))contract(. x.x = 0),sqrt,main -.* (sqrt 4)contract(. \nx.x = 0),sqrt,main -.* 2contract(. x.x = 0),sqrt,main -. if (. x.x = 0) 2 then 2 else blame (sqrt) -.* \n2 REDUCTIONS OF THE COMPILED EXPRESSION (wrap (contract(. x.x = 0) -. contract(. x.x = 0)) sqrt \"sqrt\"\"main\") \n4 -.* ((. y.wrap (contract(. x.x = 0)) (sqrt (wrap (contract(. x.x = 0)) y \"main\"\"sqrt\")) \"sqrt\"\"main\") \n4) For the next few steps, we show the reductions of wrap s argument before the reduction of wrap, for \nclarity. -. wrap (contract(. x.x = 0)) (sqrt (wrap (contract(. x.x = 0)) 4 \"main\"\"sqrt\")) \"sqrt\"\"main\" \n -.* wrap (contract(. x.x = 0)) (sqrt (if ((. x.x = 0) 4) then 4 else blame (\"main\"))) \"sqrt\"\"main\" -.* \nwrap (contract(. x.x = 0)) (sqrt 4) \"sqrt\"\"main\" -.* wrap (contract(. x.x = 0)) 2 \"sqrt\"\"main\" -.* if \n(. x.x = 0) 2 then 2 else blame (\"sqrt\") -.* 2 Figure 10. Reducing sqrt in .CON and with wrap This example \nshows that higher-order functions and .rst-order functions are treated uniformly in the calculus. Higher-order \nfunc\u00adtions merely require more distribution reductions than .rst-order functions. In fact, each nested \narrow contract expression induces a distribution reduction for a corresponding application. For simplic\u00adity, \nwe focus on our sqrt example for the remainder of the paper.   5 Contract Implementation To implement \n.CON, we must compile away obligation expressions. The key to the compilation is the wrapper function \nin .gure 9. The wrapper function is de.ned in the calculus (the let expression is short-hand for inline \napplications of .-expressions, and is used for clarity). It accepts a contract, a value to test, and \ntwo strings. These strings correspond to the variables in the superscripts. We write wrap as a meta-variable \nto stand for the program text in .gure 9, not a program variable. Compiling the obligations is merely \na matter of replacing an obli\u00adgation expression with an application of wrap. The .rst argument is the \ncontract of the referenced variable. The second argument is the expression under the obligation and the \n.nal two arguments are string versions of the variables in the obligation. Accordingly, we de.ne a compiler \n(C) that maps from programs to programs. It replaces each obligation expression with the corresponding \nappli\u00adcation of wrap. The formal de.nition is given in the accompanying technical report [6]. The function \nwrap is de.ned case-wise, with one case for each kind of contract. The .rst case handles .at contracts; \nit merely tests if the value matches the contract and blames the positive position if the test fails. \nThe second case of wrap deals with function con\u00adtracts. It builds a wrapper function that tests the original \nfunction s argument and its result by recursive calls to wrap. Textually, the .rst recursive call to \nwrap corresponds to the post-condition check\u00ading. It applies the range portion of the contract to the \nresult of the original application. The second recursive call to wrap corresponds to the pre-condition \nchecking. It applies the domain portion of the contract to the argument of the wrapper function. This \ncall to wrap has the positive and negative blame positions reversed as be.ts the domain checking for \na function. The right-hand side of .gure 10 shows how the compiled version of the sqrt program reduces. \nIt begins with one call to wrap from the one obligation expression in the original program. The .rst \nreduction applies wrap. Since the contract in this case is a function contract, wrap takes the second \ncase in its de.nition and returns a . expression. Next, the . expression is applied to 4. At this point, \nthe function contract has been distributed to sqrt s argument and to the result of sqrt s application, \njust like the distribution reduction in .CON (as shown on the left side of .gure 10). The next reduction \nstep is another call to wrap, in the argument to sqrt. This contract is .at, so the .rst case in the \nde.nition of wrap applies and the result is an if test. If that test had failed, the else branch would \nhave assigned blame to main for supplying a bad value to sqrt. The test passes, however, and the if expression \nreturns 4 in the next reduction step. <fn> if C(I (p)) -.* . x. e E(p)= Vp if C(I (p)) -.* Vp and Vp \n= . x. e error (x) if C(I (p)) -.* error (x) fh <fn> if I (p) -.* . x.p -.* VV2 -. V3,p,n <fn> if I \n(p) fh fh = Vp if I (p) -.* Vp where Efh(p) Vp = . x. e and V2 -. V3,p,n Vp = V1fh error (x) if I (p) \n-.* error (x) fw <fn> if I (p) -.* . x.e fw = Efw(p) V if I (p) -.* Vp and Vp = . x. e fw error (x) \nif I (p) -.* error (x) Figure 11. Evaluator Functions ... . . . . . .. .. . After that, sqrt returns \n2. Now we arrive at the .nal call to wrap. As before, the contract is a .at predicate, so wrap reduces \nto an if expression. This time, however, if the if test had failed, sqrt would have been blamed for returning \na bad result. In the .nal reduction, the if test succeeds and the result of the entire program is 2. \n 6 Correctness DEFINITION 6.1 DIVERGENCE. A program p diverges under -. if for any p1 such that p-.* \np1, there exists a p2 such that p1 -. p2. Although the de.nition of divergence refers only to -., we \nuse it for each of the reduction relations. The following type soundness theorem for .CON is standard \n[34]. THEOREM 6.2 (TYPE SOUNDNESS FOR .CON ). For any program, p, such that 0/ . p: ( t \u00b7\u00b7\u00b7 ) according \nto the type judgments in .gure 7, exactly one of the fol\u00adlowing holds: p -.* Vp: ( t \u00b7\u00b7\u00b7 ) p -.* error \n(x), where x is a val rec de.ned variable in p, /, hd, tl, pred dom, or rng, or  p diverges under -.. \n PROOF. Combine the preservation and progress lemmas for .CON . LEMMA 6.3 (PRESERVATION FOR .CON ). \nIf 0/ . p: ( t \u00b7\u00b7\u00b7 ) and p '' -. p then 0/ . p: ( t \u00b7\u00b7\u00b7 ). LEMMA 6.4 (PROGRESS FOR .CON ). If 0/ . p: \n( t \u00b7\u00b7\u00b7 ) then either ' p = Vp, or p -. p ' , for some p. The remainder of this section formulates and \nproves a theorem that relates the evaluation of programs in the instrumented semantics from section 4 \nand the contract compiled programs from section 5. To relate these two semantics, we introduce a new \nsemantics and show how it bridges the gap between them. The new semantics is an extension of the semantics \ngiven in .gures 5 and 6. In addition to those expressions it contains obligation expressions, .at evaluation \ncontexts, and -. reduction from .gure 8 (but not the hoc wrap new values or the -. reduction in .gure \n8), and the -. reduction: wrap D[(. x. e)(V1 -. V2),p,n] -. D[. y.((. x. e) yV1,n,p)V2,p,n] where yis \nnot free in e. fh DEFINITION 6.5 (EVALUATORS). De.ne -.* to be the transitive .athocfw closure of (-. \n. -. . -.) and de.ne -.* to be the transitive .atwrap closure of (-. . -. . -.). The evaluator functions \n(shown in .gure 11) are de.ned on pro\u00adgrams p such that p ok and G . p: ( t \u00b7\u00b7\u00b7 ). As a short-hand notation, \nwe write that a program value is equal to a value Vp = V when the main expression of the program Vp is \nequal to V. LEMMA 6.6. The evaluators are partial functions. PROOF. From an inspection of the evaluation \ncontexts, we can prove that there is a unique decomposition of each program into an evaluation context \nand an instruction, unless it is a value. From this, it follows that the evaluators are (partial) functions. \nTHEOREM 6.7 (COMPILER CORRECTNESS). E = Efh PROOF. Combine lemma 6.8 with lemma 6.9. LEMMA 6.8. E = Efw \nPROOF SKETCH. This proof is a straightforward examination of the evaluation sequences of E and Efw. Each \nreduction of an appli\u00ad.atwrap cation of wrap corresponds directly to either a -. or a -. reduc\u00adtion and \notherwise the evaluators proceed in lock-step. The full proof is given in an accompanying technical report \n[6]. LEMMA 6.9. Efw = Efh PROOF SKETCH. This proof establishes a simulation between Efh and Efw. The \nsimulation is preserved by each reduction step and it relates values to themselves and errors to themselves. \nThe full proof is given in an accompanying technical report [6]. 7 Dependent Contracts Adding dependent \ncontracts to the calculus is straightforward. The reduction relation for dependent function contracts \nnaturally ex\u00adtends the reduction relation for normal function contracts. The reduction for distributing \ncontracts at applications is the only dif\u00adference. Instead of placing the range portion of the contract \ninto the obligation, an application of the range portion to the function s original argument is placed \nin the obligation, as in .gure 12. dependent contract expressions d e = \u00b7\u00b7\u00b7 | e -. e dependent contract \ntype rule G . e1 :t1 contract G . e2 :t1 -. (t2 contract) d G . e1 -. e2 : (t1 -. t2) contract dependent \ncontract evaluation contexts E = \u00b7\u00b7\u00b7 | Ed -. E -. e | Vd dependent contract reductions d (V1 -. V2),p,nV4] \n-. D[(V3 V4V1,n,p)(V2 V4),p,n] D[V3Figure 12. Dependent Function Contracts for .CON The evaluation contexts \ngiven in .gure 8 dictate that an obligation s superscript is reduced to a value before its base expression. \nIn par\u00adticular, this order of evaluation means that the superscripted appli\u00adcation resulting from the \ndependent contract reduction in .gure 12 is reduced before the base expression. Therefore, the procedure \nin the dependent contract can examine the state (of the world) before the function proper is applied. \nThis order of evaluation is critical for the callback examples from section 2.5. 8 Tail Recursion Since \nthe contract compiler described in section 5 checks post\u00adconditions, it does not preserve tail recursion \n[2, 30] for proce\u00addures with post-conditions. Typically, determining if a procedure call is tail recursive \nis a simple syntactic test. In the presence of higher-order contracts, however, understanding exactly \nwhich calls are tail-calls is a complex task. For example, consider this program: val rec gt0 = contract(. \nx.x = 0) val rec f: (gt0 -. gt0) -. gt0 = . g.g 3 f (. x. x+1) The body of f is in tail position with \nrespect to a conventional inter\u00adpreter. Hence, a tail-call optimizing compiler should optimize the call \nto gand not allocate any additional stack space. But, due to the contract that g s result must be larger \nthan 0, the call to gcannot be optimized, according to the semantics of contract checking.5 Even worse, \nsince functions with contracts and functions without contracts can co-mingle during evaluation, sometimes \na call to a function is a tail-call but at other times a call to the same function call is not a tail-call. \nFor instance, imagine that the argument to f was a locally de.ned recursive function. The recursive calls \nwould be tail-calls, since they would not be associated with any top-level variable, and thus no contract \nwould be enforced. Contracts are most effective at module boundaries, where they serve the programmer \nby improving the opportunities for modular rea\u00adsoning. That is, with well-written contracts, a programmer \ncan study a single module in isolation when adding functionality or .xing defects. In addition, if the \nprogrammer changes a contract, the changed contract immediately indicates which other source .les must \nchange. 5At a minimum, compiling it as a tail-call becomes much more dif.cult. Since experience has shown \nthat module boundaries are typically not involved in tight loops, we conjecture that losing tail recursion \nfor contract checking is not a problem in practice. In particular, adding these contracts to key interfaces \nin DrScheme has had no noticeable effect on its performance. Removing the tail-call opti\u00admization entirely, \nhowever, would render DrScheme useless. Serrano presents further evidence for this conjecture about tail \nre\u00adcursion. His compiler does not preserve tail recursion for any cross\u00admodule procedure call not just \nthose with contracts. Still, he has not found this to be a problem in practice [29, section 3.4.1]. \n9 Conclusion Higher-order, typed programming language implementations [1, 12, 15, 19, 33] have a static \ntype discipline that prevents certain abuses of the language s primitive operations. For example, pro\u00adgrams \nthat might apply non-functions, add non-numbers, or invoke methods of non-objects are all statically \nrejected. Yet these lan\u00adguages go further. Their run-time systems dynamically prevent ad\u00additional abuses \nof the language primitives. For example, the prim\u00aditive array indexing operation aborts if it receives \nan out of bounds index, and the division operation aborts if it receives zero as a divi\u00adsor. Together \nthese two techniques dramatically improve the quality of software built in these languages. With the \nadvent of module languages that support type abstrac\u00adtion [13, 18, 24], programmers are empowered to \nenforce their own abstractions at the type level. These abstractions have the same expressive power that \nthe language designer used when specifying the language s primitives. The dynamic part of the invariant \nen\u00adforcement, however, has become a second-class citizen. The pro\u00adgrammer must manually insert dynamic \nchecks and blame is not assigned automatically when these checks fail. Even worse, as dis\u00adcussed in section \n2, it is not always possible for the programmer to insert these checks manually because the call sites \nmay be in unavailable modules. This paper presents the .rst assertion-based contract checker for languages \nwith higher-order functions. Our contract checker en\u00adables programmers to re.ne the type-speci.cations \nof their abstrac\u00adtions with additional, dynamically enforced invariants. We illus\u00adtrate the complexities \nof higher-order contract checking with a se\u00adries of examples chosen from DrScheme s code-base. These \nexam\u00adples serve two purposes. First, they illustrate the subtleties of con\u00adtract checking for languages \nwith higher-order functions. Second, they demonstrate that current static checking techniques are not \nex\u00adpressive enough to support the contracts underlying DrScheme. We believe that experience with assertions \nwill reveal which con\u00adtracts have the biggest impact on software quality. We hope that this information, \nin turn, helps focus type-system research in practical directions.  Acknowledgments Thanks to Thomas \nHerchenr\u00a8oder, Michael Vanier, and the anony\u00admous ICFP reviews for their comments on this paper. We would \nlike to send a special thanks to ICFP reviewer #3, whose careful analysis and insightful comments on \nthis paper have re\u00adnewed our faith in the conference reviewing process. References [1] AT&#38;T Bell \nLabratories. Standard ML of New Jersey, 1993. [2] Clinger, W. D. Proper tail recursion and space ef.ciency. \nIn Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 174 \n185, June 1998. [3] Felleisen, M., R. B. Findler, M. Flatt and S. Krishnamurthi. How to Design Programs. \nMIT Press, 2001. [4] Felleisen, M. and R. Hieb. The revised report on the syntactic theories of sequential \ncontrol and state. In Theoretical Com\u00adputer Science, pages 235 271, 1992. [5] Findler, R. B., J. Clements, \nC. Flanagan, M. Flatt, S. Krish\u00adnamurthi, P. Steckler and M. Felleisen. DrScheme: A pro\u00adgramming environment \nfor Scheme. Journal of Functional Programming, 12(2):159 182, March 2002. A preliminary version of this \npaper appeared in PLILP 1997, LNCS volume 1292, pages 369 388. [6] Findler, R. B. and M. Felleisen. Contracts \nfor higher-order functions. Technical Report NU-CCS-02-05, Northeastern University, 2002. [7] Findler, \nR. B. and M. Flatt. Modular object-oriented program\u00adming with units and mixins. In Proceedings of ACM \nSIG-PLAN International Conference on Functional Programming, pages 94 104, September 1998. [8] Flatt, \nM. PLT MzScheme: Language manual. Technical Report TR97-280, Rice University, 1997. http://www.plt\u00adscheme.org/software/mzscheme/. \n[9] Flatt, M. Composable and compilable macros: You want it when? In Proceedings of ACM SIGPLAN International \nCon\u00adference on Functional Programming, 2002. [10] Flatt, M., S. Krishnamurthi and M. Felleisen. A programmer \ns reduction semantics for classes and mixins. Formal Syntax and Semantics of Java, 1523:241 269, 1999. \nPreliminary ver\u00adsion appeared in proceedings of Principles of Programming Languages, 1998. Revised version \nis Rice University techni\u00adcal report TR 97-293, June 1999. [11] Gomes, B., D. Stoutamire, B. Vaysman \nand H. Klawitter. A Language Manual for Sather 1.1, August 1996. [12] Gosling, J., B. Joy and J. Guy \nSteele. The Java(tm) Language Speci.cation. Addison-Wesley, 1996. [13] Harper, R. and M. Lillibridge. \nA type-theoretic approach to higher-order modules with sharing. In Proceedings of ACM Conference Principles \nof Programming Languages, pages 123 137, Janurary 1994. [14] Holt, R. C. and J. R. Cordy. The Turing \nprogramming lan\u00adguage. In Communications of the ACM, volume 31, pages 1310 1423, December 1988. [15] \nJones, M. P., A. Reid and The Yale Haskell Group. The Hugs 98 User Manual, 1999. [16] Kelsey, R., W. \nClinger and J. R. (Editors). Revised5 report of the algorithmic language Scheme. ACM SIGPLAN Notices, \n33(9):26 76, 1998. [17] K\u00a8olling, M. and J. Rosenberg. Blue: Language Speci.cation, version 0.94, 1997. \n[18] Leroy, X. Manifest types, modules, and separate compilation. In Proceedings of ACM Conference Principles \nof Program\u00ad ming Languages, pages 109 122, Janurary 1994. [19] Leroy, X. The Objective Caml system, Documentation \nand User s guide, 1997. [20] Luckham, D. Programming with speci.cations. Texts and Monographs in Computer \nScience, 1990. [21] Luckham, D. C. and F. von Henke. An overview of Anna, a speci.cation language for \nAda. In IEEE Software, volume 2, pages 9 23, March 1985. [22] Meyer, B. Eiffel: The Language. Prentice \nHall, 1992. [23] Milner, R., M. Tofte and R. Harper. The De.nition of Standard ML. MIT Press, 1990. [24] \nMitchell, J. C. and G. D. Plotkin. Abstract types have existen\u00adtial type. ACM Transactions on Programming \nLanguages and Systems, 10(3):470 502, 1988. [25] Parnas, D. L. A technique for software module speci.cation \nwith examples. Communications of the ACM, 15(5):330 336, May 1972. [26] R\u00b4emy, D. and J. Vouillon. Objective \nML: A simple object\u00adoriented extension of ML. In Proceedings of ACM Conference Principles of Programming \nLanguages, pages 40 53, January 1997. [27] Rosenblum, D. S. A practical approach to programming with \nassertions. IEEE Transactions on Software Engineering, 21(1):19 31, Janurary 1995. [28] Serrano, M. Bigloo: \nA practical Scheme compiler, 1992 2002. [29] Serrano, M. Bee: an integrated development environment for \nthe Scheme programming language. Journal of Functional Programming, 10(2):1 43, May 2000. [30] Steele, \nG. L. J. Debunking the expensive procedure call myth; or, Procedure call implementations considered harm\u00adful; \nor, LAMBDA: The ultimate goto. Technical Report 443, MIT Arti.cial Intelligence Laboratory, 1977. First \nappeared in the Proceedings of the ACM National Conference (Seattle, October 1977), 153 162. [31] Switzer, \nR. Eiffel: An Introduction. Prentice Hall, 1993. [32] Szyperski, C. Component Software. Addison-Wesley, \n1998. [33] The GHC Team. The Glasgow Haskell Compiler User s Guide, 1999. [34] Wright, A. and M. Felleisen. \nA syntactic approach to type soundness. Information and Computation, pages 38 94, 1994. First appeared \nas Technical Report TR160, Rice Uni\u00adversity, 1991.  \n\t\t\t", "proc_id": "581478", "abstract": "Assertions play an important role in the construction of robust software. Their use in programming languages dates back to the 1970s. Eiffel, an object-oriented programming language, wholeheartedly adopted assertions and developed the \"Design by Contract\" philosophy. Indeed, the entire object-oriented community recognizes the value of assertion-based contracts on methods.In contrast, languages with higher-order functions do not support assertion-based contracts. Because predicates on functions are, in general, undecidable, specifying such predicates appears to be meaningless. Instead, the functional languages community developed type systems that statically approximate interesting predicates.In this paper, we show how to support higher-order function contracts in a theoretically well-founded and practically viable manner. Specifically, we introduce &#955;<sup><sc>con</sc></sup>, a typed lambda calculus with assertions for higher-order functions. The calculus models the assertion monitoring system that we employ in DrScheme. We establish basic properties of the model (type soundness, etc.) and illustrate the usefulness of contract checking with examples from DrScheme's code base.We believe that the development of an assertion system for higher-order functions serves two purposes. On one hand, the system has strong practical potential because existing type systems simply cannot express many assertions that programmers would like to state. On the other hand, an inspection of a large base of invariants may provide inspiration for the direction of practical future type system research.", "authors": [{"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "Northeastern University, Boston, MA", "person_id": "PP14022884", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University, Boston, MA", "person_id": "PP39037684", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/581478.581484", "year": "2002", "article_id": "581484", "conference": "ICFP", "title": "Contracts for higher-order functions", "url": "http://dl.acm.org/citation.cfm?id=581484"}