{"article_publication_date": "09-17-2002", "fulltext": "\n A Theory of Overloading * Peter J. Stuckey and Martin Sulzmann Department of Computer Science and Software \nEngineering The University of Melbourne, Vic. 3010, Australia {pjs,sulzmann}@cs.mu.oz.au Abstract We \npresent a minimal extension of the Hindley/Milner system to al\u00adlow for overloading of identi.ers. Our \napproach relies on a combi\u00adnation of the HM(X) type system framework with Constraint Han\u00addling Rules \n(CHRs). CHRs are a declarative language for writing incremental constraint solvers. CHRs allow us to \nprecisely describe the relationships among overloaded identi.ers. Under some suf.\u00adcient conditions on \nthe CHRs we achieve decidable type inference and the semantic meaning of programs is unambiguous. Our \nap\u00adproach allows us to combine open and closed world overloading. We also show how to deal with overlapping \nde.nitions. Categories and Subject Descriptors D.3.2 [Programming Languages]: Language Classi.cations \nApplicative (functional) languages; D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features \nPolymorphism; F.3.3 [Logics and Meanings of Programs]: Studies of Program Con\u00adstructs Type structure \n General Terms Languages, Theory  Keywords overloading, type classes, type inference, constraints 1 \nIntroduction The study of overloading, a.k.a. ad-hoc polymorphism, in the con\u00adtext of the Hindley/Milner \nsystem [23] dates back to Kaes [21], Wadler and Blott [35]. Since then, it became a powerful program\u00adming \nfeature in languages such as Haskell [27], Mercury [13, 14] , HAL [6] and Clean [28]. In particular, \nHaskell provides through its type-class system [15] one of the most powerful overloading * Current address: \nSchool of Computing, National University of Singapore, martin@comp.nus.edu.sg Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 02, October 4-6, 2002, Pittsburgh, Pennsylvania, \nUSA. Copyright 2002 ACM 1-58113-487-8/02/0010 ...$5.00 mechanisms. There have been a number of signi.cant \nextensions of Haskell s type class mechanism such as constructor classes [17], multi-parameter classes \n[20] and most recently functional depen\u00addencies [19]. Each of these extensions required a careful rein\u00advestigation \nof essential properties such as decidable type inference and coherent semantics. There is also a signi.cant \nbody of further closely related work, for example [10, 29, 4, 26, 24, 5]. Here, we present a minimal \nextension of the Hindley/Milner system to allow for overloading of identi.ers. EXAMPLE 1. Consider the \nfollowing type-annotated program where we provide de.nitions for overloaded functions leq and ins. overload \nleq :: Int -Int -Bool leq = primLeqInt overload leq :: Float -Float -Bool leq = primLeqFloat overload \nins :: Va.Leq (a -a -Bool)=[aJ-a -[aJ ins = let insList [] y = [y] insList (x:xs) y = if leq x y then \nx:(insList xs y) else y:x:xs in insList We assume that primLeqInt (primLeqFloat) is a primitive function, \ntesting for less-than-equal on integers (.oats). Note that the de.nition of ins depends on leq. This \nis re.ected in ins type where we .nd the constraint Leq (a -a -Bool).For simplicity, we omit further \nde.nitions of ins on other data structures such as trees etc. The novelty of our approach is that relationships \namong overloaded identi.ers are de.ned in terms of the meta-language of Constraint Handling Rules (CHRs) \n[7]. In case of the above example, we .nd the following set of CHR simpli.cation rules: (Leq1) Leq (Int \n-Int -Bool) .True (Leq2) Leq (Float -Float -Bool) .True (Ins1) Ins ([aJ-a -[aJ) .Leq (a -a -Bool) Rule \n(Leq1) states that leq is de.ned on type Int -Int -Bool. A similar property is stated by rule (Leq2). \nRule (Ins1) states that ins on type [aJ-a -[aJis de.ned iff leq is de.ned on type a -a -Bool. Logically, \nthe . symbol states an if-and-only-if relation. Operationally, a simpli.cation rule can be read as follows. \nWhenever there is a term which matches the left-hand side, then this term can be simpli.ed (replaced) \nby the right-hand side. CHRs also allow us to impose stronger constraints on the set of overloaded de.nitions \nvia propagation rules: (Leq3) Leq (Int -Int -a)= a =Bool (Ins2) Ins ([aJ-b -c)= b =a,c =[aJ For example, \nrule (Leq3) states that given both input arguments of leq are Int s, then the result must be of type \nBool. The logical meaning of =corresponds to Boolean implication. Operationally, we propagate (add) the \nright-hand side if there is a term matching the left-hand side. The original ideas of employing CHRs \nto deal with overloading were .rst described in [11]. The main contribution of the current paper is that \nwe establish some suf.cient conditions in terms of CHRs under which we achieve decidable type inference. \nCompare this to systems such as Cayenne [3], where decidability of type in\u00adference is left to the user. \nAdditionally, CHRs allow us to give a precise characterization under which a program is unambiguous. \nThe rest of this paper is structured as follows. Section 2 introduces some basic notation used throughout \nthe paper. Section 3 gives on overview of CHRs. Section 4 introduces our CHR-based over\u00adloading system. \nType inference issues are discussed in Section 5. Section 6 shows how to resolve overloading on the value-level. \nIn Section 7 we present an extended example, de.ning a generic fam\u00adily of zip-functions. Section 8 discusses \nextensions such as over\u00adlapping and closed de.nitions of overloaded identi.ers. Section 9 discusses related \nwork. We conclude in Section 10. Proofs can be found in an accompanying technical report [30].  2 Preliminaries \nWe shall be interested in manipulating constraints on types. A type is a variable a or of the form T \nt1tn where T is an n-ary type constructor and t1,,tn are types. A primitive constraint is an equation \nt1 =t2, or a user-de.ned con\u00adstraint U t1tn where U is a predicate symbol (In fact we restrict ourselves \nto unary user-de.ned constraints). A constraint C is a set of primitive constraints. Sometimes, we write \nc1 AA cn instead of { c1,,cn} where ci are primitive constraints. We use True as an abbreviation for \nthe empty constraint which denotes the true for\u00admula. We use False as an abbreviation for T1 =T2 which \ndenotes the unsatis.able equation where T1 and T2 are two distinct construc\u00adtor symbols. Given a constraint \nC, we use the notation hC to refer to the set of equations in C. We write x\u00afto denote a sequence of objects \nx.A substitution . = [t\u00af/a\u00afJsimultaneously replaces each a by its corresponding t.A uni\u00ad.er of conjunction \nof equations C of the form t11 =t12 A...A tn1 = tn2 is a substitution . such that .(ti1)is syntactically \nidentical to .(ti2)for 1 : i : n.A most general uni.er (mgu)for C is a uni.er . such that for each other \nuni.er .'of C there exists substitution . such that .'=.(.). We assume the reader is familiar with the \nbasics of .rst-order logic. Note, we use the . symbol to denote logical implication to dis\u00adtinguish it \nfrom the function type constructor -. We use Haskell notation for our example programs. Let fv(t)take \na syntactic term t and return the set of free vari\u00adables in t.We let : WF,where W is a set of variables \na1,,an, denote : a1 ...: anF.We let : F denote : fvCF)F. Similarly for V WF and V F.We let : \u00afWF denote \nthe formula : a1 ...: anF where { a1,,an} =fv(F)-W . Note that formulas F are always im\u00adplicitly universally \nquanti.ed. We write F1 1 =F2 to denote that F2 holds in any model of F1 where F1 and F2 are .rst-order \nformulae. A type scheme is of the form V a\u00af C t where a\u00afare the bound variables, C is a constraint and \nt a type. Note that we can al\u00adways view t as V a a =ta where a is fresh. We commonly use s to refer to \ntype schemes. We introduce an ordering among type schemes. We de.ne F I (V a\u00af1 C1 t1). (V a\u00af2 C2 t2)iff \nF 1 =C2 .: a\u00af1 (C1 A t1 =t2)where we assume there are no name clashes between a1 and a2 and F is a .rst-order \nformula. We de.ne F I s1 . s2 iff F I s1 . s2 and F I s2 . s1.  3 Constraint Handling Rules Constraint \nhandling rules [7] (CHRs) are a multi-headed concur\u00adrent constraint language for writing incremental \nconstraint solvers. In effect, they de.ne transitions from one constraint to an equiva\u00adlent constraint. \nTransitions serve to simplify constraints and detect satis.ability and unsatis.ability. Constraint handling \nrules (CHR rules) are of two forms simpli.cation (Rule1) c1,,cn d1,,dm propagation (Rule2) c1,,cn =d1,,dm \nIn these rules Rule1 and Rule2 are unique identi.ers for a rule, c1,,cn are user-de.ned constraints and \nd1,,dm are user\u00adde.ned constraints or equations. The simpli.cation rule states that given constraint \nc1,,cn we can replace it by constraint d1,,dm. The propagation rule states that given constraint c1,,cn, \nwe can add d1,,dm. Wesay aCHR is single-headed if the left hand side has exactly one user-de.ned constraint. \nA CHR program is a set of CHR rules. CHR rules can also be interpreted as .rst-order formulas. The trans\u00adlation \nfunction [[. JJfrom CHR rules to .rst-order formulas is: [[c1,,cn d1,,dmJJ = V a\u00af(c1 A...A cn (: \u00df\u00afd1 \nA...A dm)) [[c1,,cn =d1,,dmJJ = V a\u00af(c1 A...A cn . (: \u00df\u00afd1 A...A dm)) \u00af where a\u00af=fv(c1 A...A cn)and \n\u00df =fv(d1 A...A dm)-a\u00af.We de.ne the translation of a set of CHRs as the conjunction of the translation \nof each individual CHR rule. For the purposes of this paper, we will restrict ourselves to CHRs made \nup of propagation rules and single-headed simpli.cation rules. In Section 8 we investigate how we can \nmake use of larger classes of CHRs, including guards and disjunction. We also re\u00adquire that the CHRs \nare range-restricted. A CHR is range-restricted if any substitution . grounding c1,,cn also is such that \n. . .' grounds all variables in d1,,dm for any mgu .'of the equations in d1,,dm. Range-restrictedness \nis not an onerous condition, for our purposes we rarely want to introduce a new unconstrained type variable. \nThe operational semantics of CHRs are straightforward. We can apply a rule r in program P to a constraint \nC if C contains a subset matching a copy of the left hand side of the rule (we assume that substitutions \nrepresented by equations have already been applied, see examples below). The resulting constraint C'replaces \nthis sub\u00adset by the right hand side of the rule (if it is a simpli.cation rule), or adds the right hand \nside of the rule to C (if it is a propagation rule). This derivation step is denoted C --rC'or C --PC',see \nAppendix A for details. p A derivation, denoted C --PC'is a sequence of derivation steps using rules \nin P where no derivation step is applicable to C'.A p derivation C --PC'is successful iff hC. is satis.able. \nA set P of CHRs is terminating iff for any constraint C there exists a constraint p C'such that C --PC' \n. EXAMPLE 2. Consider the set of CHRs de.ned in the introduc\u00adtion. Then the following CHR derivation \nis possible: Ins ([aJ-b -c),Leq (Int -Int -d) --Leq3 Ins ([aJ-b -c),Leq (Int -Int -Bool),d =Bool --Leq1 \nIns ([aJ-b -c),d =Bool --Ins2 Ins ([aJ-a -[aJ),b =a,c =[aJ,d =Bool --Ins1 Leq (a -a -Bool),b =a,c =[aJ,d \n=Bool Con.uence of CHR programs is a vital property. Con.uence im\u00adplies that the order of the transitions \ndoes not affect the .nal result. Con.uent CHR programs are guaranteed to be consistent (in the usual \nsense of a theory). A CHR program P is con.uent iff for each constraint C0 for any two possible derivation \nsteps applicable to C0,say C0 --PC1 and pp C0 --PC2, then there exist derivations C1 --PC3 and C2 --PC4 \nsuch that C3 is equivalent (modulo new variables introduced) to C4, i.e. 1 =(: \u00af fvCC0)C3)(: \u00af fvCC0)C4). \nEXAMPLE 3. For example, another derivation for the goal in Ex\u00adample 2 is Ins ([aJ-b -c),Leq (Int -Int \n-d) --Ins2 Ins ([aJ-a -[aJ),b =a,c =[aJ, Leq (Int -Int -d) --Ins1 Leq (a -a -Bool),b =a,c =[aJ, Leq (Int \n-Int -d) --Leq3 Leq (a -a -Bool),b =a,c =[aJ, Leq (Int -Int -Bool),d =Bool --Leq1 Leq (a -a -Bool),b \n=a,c =[aJ,d =Bool CHRs transform one constraint into a constraint which is equiva\u00adlent w.r.t. the CHR \nprogram. While con.uence guarantees that the order of application of CHRs does not matter, in some cases \nwe can obtain stronger results. We now de.ne a class of CHRs which have a (weak) satis.ability test and \ngenerate a canonical form. We use this class to ensure decidable type inference. We say a constraint \nC is weakly satis.able w.r.t. a set P of CHRs iff 1 =: ([[PJJA C). LEMMA 1(WEAK SATISFIABILITY). Let \nP be a con.uent set of range-restricted CHRs where each simpli.cation rule is single\u00ad p headed. Let C \nbe a constraint and suppose C --PC'.Then 1 =: ([[PJJA C)iff 1 =: hC.. We can test the (weak) satis.ability \nof a constraint C by executing the CHR program and testing if the resulting equational constraints are \nsatis.able. Note that this weak satis.ability implicitly codes an open world understanding of the user-de.ned \nconstraints. The constraint is satis.able in some model of P, not all models. The following canonical \nform result will allow us to test equiva\u00adlence of constraints using CHRs. It is the .rst canonical form \nresult we know of for CHRs. LEMMA 2(CANONICAL FORM). Let P be a con.uent terminat\u00ading set of range-restricted \nCHRs where each simpli.cation rule is pp single-headed. Then [[PJJ1 =DD'iff D --PC andD' --PC' such that \n1 =(: \u00af fvCD)C)(: \u00af fvCD.)C' ). Note that for this result we require the CHRs P to be terminating, p \nthat is V C: C'C --PC' . There are some simple syntactic crite\u00adria, e.g. no cyclic dependencies among \nCHRs, which ensure that P is terminating. There are also a number of other approaches to proving termination \nof CHR programs [8]. For a terminating set of CHRs we have a decidable con.uence test [1]. In essence, \nwe need to build critical pairs and test whether they are joinable.  4 HM(CHR) and Overloading We employ \nthe HM(X) type system framework [34, 25] as the type\u00adtheoretic basis of our CHR-based overloading system. \nWe assume that the constraint domain X is described by a set P of CHRs. To support overloading we extend \nthe language of expressions by al\u00adlowing for overloaded de.nitions. We work with the following syntactic \ndomains: Programs p ::=overload f =e in p 1 e Expressions e ::=x 1 .xe 1 ee 1 let x =e in e 1 (e :: s) \nTypes t ::=a 1 t -t 1 T t\u00af Constraints C ::=t =t 1 U t\u00af1 C A C Type Schemes s ::=t 1V a\u00afC t where f ranges \nover overloaded identi.ers, .-. is the function type constructor, T is a user-de.ned n-ary type constructor, \n. =. denotes (syntactic) equality among types, U is a user-de.ned n-ary predicate symbol. and A denotes \nconjunction among constraints. Note that we use , for conjunction among constraints in CHR rules and \nexample CHR derivations. For syntactic convenience, we write example programs using overload f :: s instead \nof overload f =(e :: s)in f =e We will also make use of pattern matching syntax. The straightfor\u00adward \ndescription of this extension is omitted. We will always assume that the relationship among constraints \nis speci.edbyaset P of CHRs. We refer to P as the program the\u00adory. Typing judgments are of the form P,C,G \nI e : t where P is the program theory, C a constraint, G a typing environment, e an expression and t \na type. We will always require that constraints C appearing in typing judgments P,C,G I e : s and type \nschemes V a\u00afC t are weakly satis.able. Note that this models an open world understanding of user-de.ned \nconstraints. We will restrict our attention to valid judgments, i.e. those judgments which can be derived \nby the typing rules in Figure 1. The .rst six rules are the standard Hindley/Milner rules but ex\u00adtended \nwith a program theory P and constraint component C.We note that Gx denotes the typing environment obtained \nfrom G by excluding the variable x. In rule (V E) the statement [[PJJ1 =C1 [t\u00af/a\u00afJC2 requires that the \nconstraint C1 implies constraint [t\u00af/a\u00afJC2 (with a\u00afreplaced by t\u00af)in any model of [[PJJ. Our formulation \nof rule (V I) follows [15]. We push the free con\u00adstraint C2 into the type scheme. The now quanti.ed constraint \nC2 is simply erased from the left-hand side of the turnstile. Clearly, this rule is suitable for a lazy \nlanguage. The standard HM(X) quanti.er introduction rule keeps the constraint : a\u00afC2 on the left-hand \nside. This has some advantages as discussed in [34]. For the purpose of this paper, the present formulation \nof rule (V I) is suf.cient. Rule (Annot) is a straightforward extension of the standard Hind\u00adley/Milner \nrules to deal with type annotations. The novelty of the typing rules resides in rule (Over) which intro\u00adduces \noverloaded identi.ers (recall they can only appear at the top\u00ad P,C,Gx I e : s (x : s)E G (Var) (Let) \nP,C,Gxx : s I e ' : t' P,C,G I x : s P,C,Gx I let x =ein e ' : t' P,C,G I e1: t1 -t2P,C,Gxx : t I e : \nt' (Abs) (App) P,C,G I e2: t1 P,C,Gx I .xe : t -t' P,C,G I e1 e2: t2 P,C1 A C2,G I e : t P,C1,G I e \n: V a\u00afC2 t (V I) a\u00af E fv(C1)U fv(G) (V E) [[PJJ1 =C1 [t\u00af/a\u00afJC2 P,C1,G I e : V a\u00afC2 t P,C1,G I e : [t\u00af/a\u00afJt \n(Annot) P,C,G I e : s fv(s)=0/ P,C,G I (e :: s): s (Over) (f : V a Fa a)E G fv(V \u00afa Cf tf )=0/ P,C,G \nI e : V \u00afa Cf t f f mgu of hCf F ftf fCf E P P,C,G I p : t P,C,G I overload f :: (V \u00afa Cf t f )=ein p \n: t Figure 1. Typing Rules level). For each overloaded function f we introduce a new predicate symbol \nF. The identi.er f is available in e, p or any surrounding part of the program. Therefore, we assume \nthat the assumption f :: V aFa a is part of some initial type environment. We require that overloaded \nde.nitions are closed and are annotated with their type. Each de.nition gives rise to a simpli.cation \nrule F ftf fCf , where the role of f the mgu of hCf is to remove any equality constraints appearing in \nCf . Note that the set of available de.nitions depends on a programs typing. EXAMPLE 4. Consider parts \nof the program in Example 1 from the Introduction, but with a different typing. overload leq :: Va.a \n=Bool =Int -Int \u00ada leq = primLeqInt overload ins :: [IntJ-Int \u00ad[IntJ ins = ... The set P' s of CHRs arising \nis as follows: (Leq1) Leq (Int -Int -Bool) True (Ins1 ) Ins ([IntJ-Int \u00ad[IntJ) True Recall the set Ps \nof CHRs arising from Example 1: (Leq1) Leq (Int -Int -Bool) True (Ins1) Ins ([aJ-a -[aJ)Leq (a -a -Bool) \nWe .nd that the set Ps subsumes Ps' . The more general typing in Example 1 allows for a larger set of \noverloaded de.nitions. Note that not enforcing the side conditions in rule (Over), i.e. equal\u00adities on \nthe right-hand side of simpli.cation rules need not necessar\u00adily be resolved, would have resulted into \nthe following rule instead of rule (Leq1): (Leq1 ) Leq (Int -Int -a)a =Bool Such form of improvement \nmight actually be desired by the pro\u00adgrammer. However, we require that this must be explicitly speci\u00ad.ed. \n We note that in our system we do not impose any hierarchies among overloaded identi.ers. This is in \ncontrast to Haskell where over\u00adloaded identi.ers must be grouped into classes. Membership to a certain \nclass and super class relationships can always be mimicked by some appropriate set of CHR propagation \nrules. Assume we pro\u00advide de.nitions for two overloaded identi.ers eq and leq modeling the equality and \nless-than-equal relation. A super-class relationship between the two can be expressed as follows: (Super) \nLeq (a -a -Bool)=Eq (a -a -Bool) Note that this rule doesn t imply that we can extract an imple\u00admentation \nof eq out of a given implementation of leq. We only state that if a de.nition of leq on type a -a -Bool \nis present for some a, then there must be also a de.nition of eq present on the same type. For the remainder \nof the paper, we adopt the convention that Ps denotes the set of CHR simpli.cation rules arising from \nover\u00adloaded de.nitions for a given program p. We denote by Pp the set of programmer-speci.able CHR propagation \nrules. The set P =Ps U Pp forms the program theory. 4.1 Unambiguity An important restriction usually \nmade on constrained types is that they be unambiguous. This means that we can determine from the type \ncomponent alone, each of the types occurring in the con\u00adstraint part. Ambiguous types lead to dif.culties \nin implementing the function since non-deterministic choices need to be made about which de.nitions to \nuse. In Haskell 98 we require that for each type scheme V a\u00afC t we have that fv(C)n a\u00af. fv(t)n a\u00af.That \nis, all bound variables found in the constraint component must also appear in the type component. The \nrecent addition of functional dependencies [19] to Haskell made it necessary to adjust the unam\u00adbiguity \ncondition. Here, we present a general de.nition of unam\u00adbiguity of a type scheme w.r.t. a program theory \nwhich subsumes previous de.nitions. Let V a\u00afC t be a type scheme, P be the program theory used in this \ncontext and . be a variable renaming on a\u00af.Then V a\u00afC t is unambiguous iff [[PJJ1 =(C A .(C)A (t =.(t)))(a \n=.(a)) for each a E a\u00af. We also say that e is unambiguous if e :: s is a well-typed expression and s \nis unambiguous. Consider the type scheme V a,bH (a -b)b. Under the empty program theory this type scheme \nis ambiguous. The variable a can\u00adnot be determined from the constraint component alone. We .nd that 1 \n=H (a -b)A H (a ' -b' )A b =b' a =a '. Assume that our program theory consists of the following CHR (note \nthat this CHR mimics a functional dependency): (FH) H (a -b),H (a ' -b)=a =a ' In the above type scheme, \nvariable a is now determined by b.  4.2 Improvement The programmer-speci.able set Pp of CHR propagation \nrules al\u00adlows the programmer to impose stronger conditions on the set of constraints allowed to appear. \nIt is also common to refer to this as improvement1 of constraints. Functional dependencies are one example \nof improving constraints. For example, the declaration Leq (a -b -c)1 (a,b). c states that both input \narguments uniquely determine the result where (a,b). c is a functional de\u00adpendency. This behavior can \nbe modeled by the following CHR propagation rule: (FD) Leq (a -b -c),Leq (a -b -d)=c =d In general, any \ndeclaration with functional dependencies can be translated into a set of CHR propagation rules. Assume \nwe have F t 1 fd1,,fdm where fv(t)=a\u00afand fdi is a functional depen\u00addency of the form (ai1 ,,aik ). ai0. \nThe functional dependency asserts that given .xed values of ai1 ,,aik then there is only one value of \nai0 for which the constraint F t can hold. Note that in [19] the right-hand side of the . can have a \nlist of variables. For sim\u00adplicity, we only allow for one variable on the right-hand side. The expressiveness \nis equivalent. The translation creates for each func\u00adtional dependency a propagation rule of the form: \nF t,F .(.t)=ai0 =\u00dfi0 where . is a renaming on a\u00afsuch that .(ai)=\u00dfi and . maps each \u00dfij to aij and each \nother \u00dfl to itself. This allows us to model full and faithfully functional dependencies via CHRs. The \nability to specify arbitrary programmer-de.nable CHR propa\u00adgation rules clearly goes beyond functional \ndependencies. EXAMPLE 5. Consider the three de.nitions. overload f = (e1 :: Float -Float) overload f \n= (e2 :: Int -Float) overload f = (e3 :: Int -Int) We .nd the following set Ps (F1) F (Float -Float)True \n(F2) F (Int -Float)True (F3) F (Int -Int)True Our intention might be that every de.nition of f with argument \ntype Float must have result type Float. In our framework, this can be speci.ed by an additional propagation \nrule (F4) F (Float -a)=a =Float Such behavior cannot be speci.ed by functional dependencies. 1The term \nimprovement was coined by Jones [18].  4.3 Con.uence We require that program theories must be con.uent. \nEXAMPLE 6. Consider the following program overload eq :: Int -Int -Bool eq = primEqInt overload eq :: \nVa.Eq (a -a -Bool)=[aJ-[aJ-Bool eq = let eqL [] []= True eqL (x:xs) [] = False eqL [] (y:ys) = False \neqL (x:xs) (y:ys) = (eq x y) &#38;&#38; (eqL xs ys) in eqL overload leq:: Int -Int -Bool leq= primLeqInt \noverload leq:: Va.[aJ-[aJ-Bool leq= .l1..l2True . where primEqInt is a primitive equality function of \ntype Int -Int -Bool. The following set of CHRs arise from the above overloaded de.ni\u00adtions: (Eq1) Eq \n(Int -Int -Bool)True (Eq2) Eq ([aJ-[aJ-Bool)Eq (a -a -Bool) (Leq1) Leq (Int -Int -Bool)True (Leq4) Leq \n([aJ-[aJ-Bool)True Furthermore, we assume we are given the following user-de.ned propagation rule: (Super) \nLeq (a -a -Bool)=Eq (a -a -Bool) states that whenever leq is de.ned on type a -a -Bool,then eq must be \nde.ned on type a -a -Bool as well. Note that the above set of CHRs is non-con.uent, since Leq ([aJ-[aJ-Bool)has \ntwo derivations which are non-joinable. Leq ([aJ-[aJ-Bool)--Leq4 True and Leq ([aJ-[aJ-Bool) --Super \nLeq ([aJ-[aJ-Bool),Eq ([aJ-[aJ-Bool) --Leq4 Eq ([aJ-[aJ-Bool) --Eq2 Eq (a -a -Bool) Clearly, there is \na problem among the set of overloaded de.nitions and the super class relationship of eq and leq. There \nare however cases where it is safe to add some propagation rules to complete a non-con.uent program theory. \nEXAMPLE 7. Consider the following program overload ins :: [IntJ-Int -[IntJ ins = .xs..x.x : xs  The \nprogram theory consists of the following set of CHRs where rule (Func) states a functional dependency \namong the input values. (Ins1 ) Ins ([IntJ-Int -[IntJ)True (Func) Ins (c -e1 -c),Ins (c -e2 -c)=e1 =e2 \nThe above program theory is non-con.uent. Ins ([IntJ-Int -[IntJ),Ins ([IntJ-a -[IntJ) --Ins1. Ins ([IntJ-a \n-[IntJ) and Ins ([IntJ-Int -[IntJ),Ins ([IntJ-a -[IntJ) --Func Ins ([IntJ-Int -[IntJ), Ins ([IntJ-Int \n-[IntJ),a =Int --Ins1. Ins ([IntJ-Int -[IntJ),a =Int -a =Int -Ins1. are two distinct, non-joinable derivations. \nAdding the following propagation rule yields a con.uent program theory. (InsFunc1) Ins ([IntJ-a -[IntJ)=a \n=Int Note that rule (Func) states a general property which must hold for all ins de.nitions. Therefore, \nwe had to add in an additional propagation rule per overloaded de.nition to complete the program theory. \nCon.uence becomes a subtle issue in case of overlapping de.ni\u00ad tions. EXAMPLE 8. Consider the de.nition \nof eq of Example 6 extended with the following de.nition.  overload eq :: [IntJ-[IntJ-Bool eq = ... \nspecial treatment on integers ... We .nd the following program theory: (Eq1) Eq (Int -Int -Bool)True \n(Eq2) Eq ([aJ-[aJ-Bool)Eq (a -a -Bool) (Eq3) Eq ([IntJ-[IntJ-Bool)True The above program theory is con.uent. \nHowever, note that the sec\u00adond and third de.nition of eq are overlapping. We say two de.ni\u00adtions are \noverlapping if there exists a substitution f which uni.es the head atoms in the respective simpli.cation \nrules. In case we re\u00adquire a de.nition of eq at type [IntJ-[IntJ-Bool,we musttake an indeterministic \nchoice between two possibilities. As we will see in Section 5, con.uence is a suf.cient condition to \nensure correctness on the level of types. Correctness on the value level, i.e. a coherent semantics, \nadditionally requires that all simpli\u00ad.cation rules must be non-overlapping (see Section 6). In certain \ncases, it is possible to handle overlapping de.nitions via a simple extension of the CHRs (see Section \n8.2).  5 Type Inference We assume that we are given a program p and an initial environment G where \nall overloaded identi.ers f are recorded, i.e. (f :: V aFa a)E G. Stage (1) of type inference, extracts \nthe set Ps of simpli.cation out of the annotated program text via a simple translation. We introduce \njudgments of the form p I inf Ps: (Exp) e I inf 0/ f mgu of hC p I inf Ps (Over) P' =Ps U{ F ft fC} \ns overload f :: (V a\u00afC t)= e in p I inf Ps ' In addition, we are given a set Pp of programmer-speci.able \nprop\u00ad agation rules. Together, P =Ps U Pp,where p I inf Ps,forms the program theory. The curious reader \nmight ask what happens if we do not provide type annotations for overloaded de.nitions. This would require \nto infer the set of simpli.cation rules. We believe it is generally undecidable to .nd a terminating \nset of simpli.cation rules which satis.es overloaded de.nitions. To obtain complete type inference we \nrequire that P is terminating, con.uent and range-restricted. We have already seen cases were an incomplete \nset can be completed, see Example 7. We will neglect the issue of testing for termination, con.uence \nand completion of CHRs for the purpose of this paper and refer to [32] for more de\u00adtails. Stage (2) of \ntype inference proceeds by inference of expressions and checking that the annotated types match the actual \nimplementation, see Figure 2. The inference algorithm is formulated as a deduction system with inference \nclauses of the form t) P,G,p I inf (C where program theory P, type environment G and program p are input \nvalues, a constraint C and a type t are output values. The set P consists of the CHRs collected in the \nprevious stage and a user-de.ned set of propagation rules. Inference of expressions con\u00adsists of (a) \ngenerating constraints from the program text and solving them w.r.t. the given program theory, (b) checking \nfor unambiguity of type schemes, and (c) checking for validity of user-provided type annotations. Rules \n(Let),(Annot) and (Over) use a generalization procedure. Let G be a type environment, C a constraint \nand t a type. Then, we de.ne gen(G,C,t)=(True s)where a\u00af=fv(C,t)\\ fv(G)and s = V a\u00afC t. Rules (Let), \n(App) and (Over) make use of a procedure sat for checking satis.ability of constraints which is de.ned \nas follows: sat(P,C) p =True if C --PC'such that 1 =: hC. =False otherwise  Note that the condition \n1 =: hC. can be checked by a uni.cation pro\u00adcedure. Immediately, it follows from Lemma 1 that the satis.ability \ntest is decidable for terminating CHRs. Rules (Let) and (Annot) either use or build type schemes. The \npro\u00adcedure for checking of unambiguity of type schemes is de.ned as follows: unambig(P,V a\u00afC t) p =True \nif C A .(C)A t =.(t)--PC' such that 1 =C' (a =.(a))for each a E a\u00af where . is a variable renaming on \na\u00af =False otherwise The condition 1 =C' (a =.(a))is decidable (it holds iff the mgu of hC. uni.es a \nand .(a)) which ensures that the above procedure is decidable for terminating CHRs. EXAMPLE 9. Consider \nthe type scheme V a,a'H (a -a' )a' . The program theory consists of rule (FH) (see 4.1). We assume a''a''' \n that .(a)=and .(a' )=. We check unambiguity via the derivation a' ),H (a''a''' ),a'a''' H (a --= a' \n),H (a''a''' ),a'a'''a'' --FH H (a --=,a = Hence the type is unambiguous. Note that we do not need to \ncheck for satis.ability and unambiguity of type schemes in rule (Var). Given that this holds for the \ninitial type environment, our inference rules preserve these conditions. In rule (Annot) procedure entail \nperforms an entailment check to check the validity of the annotated type. The de.nition of entail is \nas follows: t) P,Gx,e I inf (C1 (C2 s)=gen(Gx,C1,t) \u00af (x : V a\u00afC t)E G\u00df new unambig(P,s) (Var) (Let) \nt' )\u00df/a\u00afJC [\u00df\u00af/a\u00afJt) P,Gxx : s,e ' I inf (C3 P,G,x I inf ([ \u00afC =C2 A C3 sat(P,C) ' t' ) P,Gx,let x =ein \ne I inf (C t1) P,G,e1 I inf (C1 t2) P,G,e2 I inf (C2 t' )a new C' =C1 A C2 A (t1 =t2 -a) P,Gxx : a,e \nI inf (C (Abs) (App) a -t' ) a new sat(P,C' ) a) P,Gx,.xe I inf (C P,G,e1e2 I inf (C' t2) P,G,e I inf \n(C2 gen(G,C2,t2)=( te)sat(P,Ce) s2) P,G,e I inf (Ce unambig(P,s2)unambig(P,V a\u00afC1 t1) P,G,p I inf (Cp \ntp)fv(s)=0/ (Annot) entail(P,s2,V a\u00afC1 t1)(Over) gen(G,Ce,te)=(. s' ) fv(V a\u00afC1 t1)=0/ unambig(P,s' )entail(P,s' \n,s) \u00af \u00df new C =C2 A [\u00df\u00af/a\u00afJC1 P,G,overload f :: s = tp) ein p I inf (Cp [\u00df\u00af/a\u00afJt1) P,G,e :: V a\u00afC1 t1 \nI inf (C Figure 2. Inference system entail(P,V a\u00afC t,V a\u00af'C't' ) p =True if C' A t' =a' A a =a' --PC1,and \np C' A t' =a' A a =a' A t =a A C --PC2 such that 1 =(: \u00af VC1)(: \u00af VC2) where a, a'are new variables and \nV =fv(C' A t' =a' A a =a' )U fv(V a\u00afC t) =False otherwise Theideais torewrite V a\u00afC t into the equivalent \ntype scheme V a\u00af,a C A t =aa, and then use equivalence testing (possible through the Lemma 2) to test \nimplication. Note that the condition 1 =(: \u00af VC1)(: \u00af VC2)is decidable. EXAMPLE 10. Consider the inference \nfor the second de.nition of ins in Example 4. The inferred type for the expression is V \u00df Leq (\u00df -\u00df -Bool)[\u00dfJ-[\u00dfJ-Bool, \nwhile the declared type is [IntJ-[IntJ-Bool. The entailment test determines [IntJ-[IntJ-Bool =a' ,a =a' \np --P [IntJ-[IntJ-Bool =a' =a and [IntJ-[IntJ-Bool =a' ,a =a' , [\u00dfJ-[\u00dfJ-Bool =a,Leq (\u00df -\u00df -Bool) [IntJ-[IntJ-Bool \n=a' =a, \u00df =Int,Leq (Int -Int -Bool) --Leq1 [IntJ-[IntJ-Bool =a' =a,\u00df =Int Hence the entailment condition \nholds. 5.1 Soundness Results We can state that procedures unambig and entail are sound. Sound\u00adness of \nsat follows from Lemma 1. LEMMA 3(SOUNDNESS OF UNAMBIGUITY). Let P be a set of CHRs, V a\u00afC t be a type \nscheme and . be a variable renaming p on a\u00afsuch that C A .(C)A t =.(t)--PC'where 1 =C' (a = .(a))for \neach a E a\u00af. Then for each a E a\u00af[[PJJ1 =(C A .(C)A (t = .(t)))(a =.(a)). LEMMA 4(SOUNDNESS OF ENTAILMENT). \nLet P be a set of CHRs, a and a'two fresh variables and s =V a\u00afC t and p s' =V a\u00af'C't'where C' A t' \n=a' A a =a' --PC1 and C' A t' = p a' A a =a' A C --PC2 such that 1 =(: \u00af VC1)(: \u00af VC2),where V =fv(s)U \nfv(s' )U fv(C' A t' =a' A a =a' ).Then [[PJJI ss' . We conclude that the inference system described in \nFigure 2 is sound w.r.t. the typing rules in Figure 1. THEOREM 1(SOUNDNESS OF TYPE INFERENCE). Let pbea \nprogram, G a type environment, Pp be a set of propagation rules, Ps be a set of CHRs, C a constraint \nand t a type such that p I inf Ps and Ps U Pp,G,e I inf (C t).Then Ps U Pp,C,G I e : t is valid. 5.2 \nCompleteness Results Lemma 1 implies that our weak satis.ability test is complete. LEMMA 5(COMPLETENESS \nOF UNAMBIGUITY). Let P be a con.uent set of range-restricted CHRs where each simpli.cation rule is single-headed, \nV a\u00afC t be a type scheme and . be a vari\u00adable renaming on a\u00afsuch that [[PJJ1 =(C A .(C)A (t =.(t)))(a \n= p .(a))for each a E a\u00af.Then C A .(C)A t =.(t)--PC'where 1 =C' (a =.(a))for each a E a\u00af. From Lemma \n2 we can derive completeness of entailment checking. Note that completeness only holds under the additional \nassumption that type schemes are unambiguous, a natural condition imposed on type schemes in our system. \nLEMMA 6(COMPLETENESS OF ENTAILMENT). Let Pbe ater\u00adminating, con.uent set of range-restricted CHRs whose \nsimpli\u00ad.cation rules are single-headed, a, a'two fresh variables and s =V a\u00afC t and s' =V a\u00af'C't'such \nthat [[PJJI ss'and s p is unambiguous. Then C' A t' =a' A a =a' --PC1 and C' A t' = p a' A a =a' A t \n=a A C --PC2 such that 1 =(: \u00af VC1)(: \u00af VC2), where V =fv(s)U fv(s' )U fv(C' A a =a' ). It is common \nknowledge that inference is incomplete in the pres\u00adence of ambiguous types. Therefore, we require that \nall type schemes in the principal judgment must be unambiguous. This is suf.cient to state weak completeness \nof inference. Let P be a set of CHRs, C a constraint, G an environment, e an expression and s a type \nscheme. We say (C,s)is the principal constrained type (w.r.t. P, G and e)iff (1) P,C,G I e : s, and (2) \nfor each P,C' ,G I e : s'we have that (a) [[PJJ1 =C' (\u00af C),and : fvCG) (b) [[PJJA C' 1 =I ss'.We say \n(C,s)is unambiguous iff s is unambiguous. A judgment P,C,G I p : s is principally unambigu\u00adous iff for \neach subexpression in p the principal constrained type is unambiguous. THEOREM 2(WEAK COMPLETENESS OF \nTYPE INFERENCE). Let P,C,G I p : t be a principally unambiguous judgment such that P is terminating, \ncon.uent, range-restricted and all simpli.cation rules are single-headed. Then P,G,p I inf (C' t' )for \nsome constraint C'and type t'such that [[PJJ1 =C : \u00af V (C' A t =t' ) where V =fv(G).  6 Evidence Translation \nWe follow the common approach (e.g. [35]) for giving a semantic meaning for programs containing overloaded \nidenti.ers by pass\u00ading around evidence values as additional function parameters. This translation process \nis driven by a programs typing. We wish to have a coherent system [16], i.e. the semantic meaning of \na translated expression should be independent of its typing. The input of the translation process is \na well-typed program which is translated into a target language. Target Expressions E ::=x 1 .xE 1 let \nx =E in E In particular, we assume we are given a denumerable set of evidence variables eC indexed by \na constraint C. Evidence variables will carry the appropriate de.nitions of overloaded identi.ers. We \nintroduce judgments of the form P,G,C I e : s . E where E is the result of translating a well-typed expression \ne with type s un\u00adder program theory P, environment G and constraint C.The most interesting rules are \n(V I) where we abstract over evidence variables and (V E) where we provide the proper evidence values. \nWe as- P sume that ec : C1 -[t\u00af/a\u00afJC2 is an evidence constructing function. Note that the context only \nprovides evidence for eC1.However, the instantiation site requires evidence e[t\u00af/a\u00aflC2. The premise states \nthat [[PJJ1 =C1 [t\u00af/a\u00afJC2. In fact, this is suf.cient to ensure that function ec must exist. Assume we \nhave a substitution f such that pp fC1 --P True. Then, we also have that f[t\u00af/a\u00afJC2 --P True.In p such \na situation, we .nd that f[t\u00af/a\u00afJC2 --Ps True,i.e. f[t\u00af/a\u00afJC2 can be solely reduced by simpli.cation \nrules. This is allows us to construct evidence ef[t\u00af/a\u00aflC2 by reading the CHR derivation back\u00adwards. \nRecall the de.nitions of eq in Example 6. overload eq :: Int -Int -Bool eq = primEqInt overload eq \n:: Va.Eq (a -a -Bool)=[aJ-[aJ-Bool eq = let eqL [] []= True eqL (x:xs) [] = False eqL [] (y:ys) = False \neqL (x:xs) (y:ys) = (eq x y) &#38;&#38; (eqL xs ys) in eqL Consider expxsys=(eq(tail xs) ys,eq13) where \ntail :: [aJ-[aJtakes the tail of a list. In a .rst step we translate overloaded de.nitions. We .nd ec \neqInt = primEqInt ec eqList eq = let eqL [] [] = True eqL (x:xs) [] = False eqL [] (y:ys) = False eqL \n(x:xs) (y:ys) = (eq x y) &#38;&#38; (eqL xs ys) in eqL Note that parameter eqrepresents evidence for \nthe equality function on type a -a -Bool. What remains is to insert the appropriate evidence values for \nexpression exp. Expression exp gives rise to the following constraints Eq ([aJ-b -c),Eq (Int -Int -d) \n where we assume xs :: [aJ, ys :: b, 1 :: Int and 3 :: Int.We .nd that Eq ([aJ-b -c),Eq (Int -Int -d) \n--Eq3 Eq ([aJ-b -c),Eq (Int -Int -Bool),d =Bool --Eq1 Eq ([aJ-b -c),d =Bool --Eq4 Eq ([aJ-[aJ-Bool),b \n=[aJ,c =Bool,d =Bool --Eq2 Eq (a -a -Bool),b =[aJ,c =Bool,d =Bool Resolution of remaining equalities \nvia uni.cation yields exp :: Va.Eq (a -a -Bool)=[aJ-[aJ-(Bool,Bool) expxsys=(eq(tail xs) ys,eq13) Expression \nexp s type states that we can implement exp given we can provide evidence for Eq (a -a -Bool). The two \ninstantiation sites of eq imply the existence of evidence constructors: P el:: Eq (a -a -Bool)-Eq ([aJ-[aJ-Bool)and \nP e2:: Eq (a -a -Bool)-Eq (Int -Int -Bool) Consider a particular ground instance, say a =[IntJ,of exp \ns type. Then, the .rst instantiation site of eq requires evidence eEq C[[Intll.[[Intll.Bool). By reading \nthe following CHR derivation backwards Eq ([[IntJJ-[[IntJJ-Bool) --Eq2 Eq ([IntJ-[IntJ-Bool) --Eq2 Eq \n(Int -Int -Bool) --Eq1 True we conclude that eEq C[[Intll.[[Intll.Bool) =eeqList(eeqListeeqlnt) Rule \n(Eq1) reduces to True.That is, eEq CInt.Int.Bool)must be present. Each (Eq2) rule application corresponds \nto applying ec eqList to the previously constructed evidence. We .nd that eleEq C[Intl.[Intl.Bool) =eeqList(eeqListeeqlnt) \nSimilarly, for the second instantiation site we have that e2eEq C[Intl.[Intl.Bool) =eeqlnt P,C,Gx I e \n: s . E (x : s)E G ' (Var) (Let) P,C,Gxx : s I e ' : t' . E P,C,G I x : s . x ' P,C,Gx I let x =ein \ne ' : t' . let x =E in E P,C,G I e1: t1 -t2 . E1 P,C,Gxx : t I e : t' . E (Abs) (App) P,C,G I e2: t1 \n. E2 P,C,Gx I .xe : t -t' . .xE P,C,G I e1 e2: t2 . E1 E2 P,C1,G I e : V a\u00afC2 t . E P,C1 A C2,G I e \n: t . E [[PJJ1 =C1 [t\u00af/a\u00afJC2 (V I) a\u00afE fv(C1,G) (V E) P ec :: C1 -[t\u00af/a\u00afJC2 P,C1,G I e : V a\u00afC2 t . \n.eC2 E P,C1,G I e : [t\u00af/a\u00afJt . E (ec eC1 ) Figure 3. Evidence-passing translation Note that this translation \nscheme requires run-time type informa\u00adtion. Evidence can only be constructed once we have enough infor\u00admation \navailable (the grounding substitution f). However, in case of the above example we are able to provide \nsome closed de.nitions for the evidence constructing functions. We de.ne el=eeqList and e2x=eeqlnt. Hence, \nt exp :: Va.(a -a -Bool)-[aJ-[aJ-(Bool,Bool) t exp2exsys=(eq(ec1e)(tail xs) ys,eq(ec2e)13) where eq \nx = x. We assume each overloaded identi.er simply passes on the appropriate calculated de.nition. Note \nthat Eq (a -a \u00adBool)has been turned into a matching function type. THEOREM 3(COHERENCE). Let P be a con.uent \nset of range\u00adrestricted CHRs where each simpli.cation rule is single-headed and non-overlapping. Then \nthe translation scheme in Figure 3 yields a coherent system. The exact details of the translation process \nincluding formal results and proofs go clearly beyond the scope of the present paper. A formal development \nincluding a concise coherence result can be found in [31].  7 A Generic Family of Zip-Functions The \navailability of a meta-language to reason about overloaded identi.ers allow us to provide type inference \nfor some interesting programs. Usually, we .nd the following family of zip-functions zip :: V a,b [aJ-[bJ-[(a,b)J \nzip3 :: V a,b,c [aJ-[bJ-[cJ-[(a,b,c)J Although straightforward, we can not give a generic de.nition of \nthe zip-function in a typed language such as Haskell. EXAMPLE 11. Consider the following generic de.nition \nof the zip function. zip2 :: Va,b.[aJ-[bJ-[(a,b)J zip2[] [] = [] zip2 (a:as) (b:bs) = (a,b):(zip2 as \nbs) zip2 [] (b:bs) = [] zip2 (a:as) [] = [] overload zip :: Va,b.[aJ-[bJ-[(a,b)J zip = zip2 overload \nzip :: Va,b,cs,e.Zip ([(a,b)J-cs -e)= [aJ-[bJ-cs -e zip as bs cs = zip (zip2 as bs) cs The corresponding \nCHR program for the above set of de.nitions is as follows: (Zip1) (Zip2) Zip ([aJ-[bJ-[(a,b)J)Zip ([aJ-[bJ-cs \n\u00ade) Zip ([(a,b)J-cs \u00ade) True In addition, we provide the following two propagation rules to en\u00adforce \nstronger properties on the set of overloaded identi.ers allowed to appear. (Zip3) Zip ([aJ-[bJ-[cJ)=c \n=(a,b) (Zip4) Zip (a -b -c)=a =[a ' J,b =[b' J Consider the following (partially) type-annotated expression. \ne :: [((Int,Bool),Char)] e= zip [1,2,3] [True,False] [ a , b , c ]  From the program text, we generate \nZip ([IntJ-[BoolJ-[CharJ-[((Int,Bool),Char)J Note that equalities have already been resolved by uni.cation. \nWe .nd that Zip ([IntJ-[BoolJ-[CharJ-[((Int,Bool),Char)J --Zip2 Zip ([(Int,Bool)J-[CharJ-[((Int,Bool),Char)J \n--Zip1 True Therefore, the above expression is translated into e :: [((Int,Bool),Char)] e = zip2 (zip2 \n[1,2,3] [True,False]) [ a , b , c ]  8 Extensions We discuss how to handle closing and overlapping \nde.nitions. Both extensions .t into our framework by employing more expressive CHRs. We also introduce \nmulti-headed simpli.cations. 8.1 Closing De.nitions Consider the following de.nitions. For simplicity, \nwe omit the ob\u00advious function bodies. overload eq :: Int -Int -Bool eq = ... overload eq :: V a Eq (a \n-a -Bool)[aJ-[aJ-Bool eq = ... We .nd the following set of CHRs: (Eq1) Eq (Int -Int -Bool)True (Eq2) \nEq ([aJ-[aJ-Bool)Eq (a -a -Bool) In our current scheme the following expression would be still well\u00adtyped. \nf:: V a Eq (Tree a -Tree a -Bool) Tree a -Tree a -Bool fxy= eq xy Although there is no equality de.nition \non trees in scope at the moment, this doesn t mean there might not be one available in the future. Compare \nthis to a closed world approach which would rule out the above program. Fortunately, there exists an \nextension of the CHR framework [2] presented so far that allows us to mix open and closed world style \noverloading. We introduce propagation rules where disjunction is allowed to appear on the right-hand \nside. By adding in the following propagation rule (CloseEq) Eq a =(a =Int -Int -Bool)V (a =[bJ-[bJ-Bool) \nwe enforce that the de.nitions corresponding to rules (Eq1) and (Eq2) are the only ones available. Note \nthat allowing for disjunction among equality constraints on the right-hand side of the =symbol in.uences \nthe constraint solv\u00ading process. In addition to simpli.cation and propagation of con\u00adstraints, we also \nnow perform constraint solving by search. While all of our results carry over to the extended set of \nCHRs, it is now much more dif.cult to ensure termination. The addition of rule (CloseEq) makes the above \nset of CHRs non-terminating. We follow [29] by disallowing recursive dependencies for closed de.nitions. \nThis requirement is suf.cient to ensure termination of CHRs involving closed de.nitions.  8.2 Overlapping \nDe.nitions Recall Example 8 from Section 4.3. Although, the program theory is con.uent, we cannot provide \na coherent translation because we must take an indeterministic choice in case we require eq on type [IntJ-[IntJ-Bool. \nWe can rely on yet another extension of the CHR framework to resolve the above ambiguity. Assume that \nby default we always want to choose the more speci.c de.nition. This can be modeled by incorporating \nguards constraint into simpli.cation rules. The guard constraint, a =Int, added to rule (Eq2), states \nthat this rule only .res if the instance type is different from Int. (Eq1) Eq (Int -Int -Bool)True (Eq2 \n) Eq ([aJ-[aJ-Bool)1 a =Int Eq (a -a -Bool) (Eq3) Eq ([IntJ-[IntJ-Bool)True To make the example more \ninteresting we assume that additionally a de.nition of eq on type Char is available. We only give the \nre\u00adsulting simpli.cation rule: (Eq4) Eq (Char -Char -Bool)True We avoid some clumsy type annotations \nby employing the follow\u00ading propagation rule: (Eq5) Eq (a -b -c)=a =b Type inference for expression \ng x y = (eq [x] [y]) :: Bool yields the constraint Eq ([aJ-[aJ-Bool)where x: a and y: a. Note that no \nfurther reduction steps are applicable at this point. We .nd that g:: V a Eq ([aJ-[aJ-Bool)a -a -Bool \ng x y = (eq [x] [y]) :: Bool t geqxy=(eq[x][y])  where tg is g s translation. Consider expression exp \n= (g [1] [2], g [ a , b ] [ a , b ]) whereweuse g at two different instantiation sites. In context g[1] \n[2] we require the constraint Eq ([IntJ-[IntJ-Bool)whereas in context g [ a , b ] [ a , b ] we require \nEq ([CharJ-[CharJ-Bool). We .nd the following derivations: Eq ([IntJ-[IntJ-Bool)--Eq3 True and Eq ([CharJ-[CharJ-Bool) \n--Eq2. Eq (Char -Char -Bool) --Eq4 True Note that rule (Eq2 ) .red because Char =Int. Out of the two \nderivations above we can calculate which evidence parameters we need to pass to tg. The translation of \nexp yields expt = (t gec eqList [1] [2], t g (ec eqList ec eqChar) [ a , b ] [ a , b ])  where ec eqList \nrepresents evidence for Eq ([IntJ-[IntJ-Bool) and ec eqChar represents evidence for Eq (Char -Char -Bool) \nand ec eqList is de.ned as in Section 6. We make the following observations. Overlapping de.nitions have \nno impact on typability as long as the program theory is still con\u00ad.uent. Note that Eq ([aJ-[aJ-Bool)and \nEq (a -a -Bool) are both equivalent w.r.t. the program theory represented by rules (Eq1-5). If the set \nPs of simpli.cation rules is overlapping, we can try to employ guard constraints to obtain a non-overlapping \nset Ps' . For example, in the above example we added a guard constraint to rule (Eq2) yielding rule (Eq2 \n). Then, we simply re-run all CHR derivations under P' =P' U Pp to compute the proper evidence val\u00ad s \n ues. This allows us to provide type inference and a coherent seman\u00adtics even in case of overlapping \nde.nitions. 8.3 Simplifying Constraints In Haskell it is common to simplify constraints before presenting \nthem to the user. One simple form of simpli.cation is uni.cation. That is, no explicit equality constraints \nare allowed to appear in constraints. Another form is to omit redundant constraints. As\u00adsume we have \nspeci.ed a super-class relation ship among eq and leq: (Super) Leq (a -a -Bool)=Eq (a -a -Bool) For details \nof overloaded de.nitions we refer to Example 6 in Sec\u00adtion 4.3. Consider the expression h:: V a Eq (a \n-a -Bool)A Leq (a -a -Bool) a -a -(Bool,Bool) hxy= (eq xy,leq xy) Note that [[PJJ1 =(Eq (a -a -Bool)A \nLeq (a -a -Bool)) Leq (a -a -Bool) where P consists of (Eq1-2), (Leq1-2) and (Super). Therefore, we could \nassign to expression h the equivalent but simpler type scheme V a Leq (a -a -Bool)a -a -(Bool,Bool). \nSuch form of simpli.cation can always be achieved by turning a rule such as (Super) into a multi-headed \nsimpli.cation rule of the form Leq (a -a -Bool),Eq (a -a -Bool) Leq (a -a -Bool) 9 Discussion Our approach \nis clearly inspired by Haskell style type classes and its various extensions. In contrast to previous \nwork [19, 20, 17], we are seeking a general formal framework within we can reason about overloading in \na concise way. CHRs turn out to be the perfect candidate. We have established some precise conditions \nin terms of CHRs under which we achieve decidable type inference and the meaning of programs is unambiguous. \nThe framework presented here can be seen as a formal basis for the ideas described by Jones [18]. He \nintroduces the concept of im\u00adproving and simplifying constraints by example whereas our work provides \nan actual proof system based on CHRs. Shields and Peyton-Jones [29] give an extensive discussion of var\u00adious \npossible extensions to Haskell style overloading. Their main motivation is to investigate which extensions \nare necessary to incor\u00adporate object-oriented classes into Haskell. In particular, they also discuss \nissues involving closed and overlapping de.nitions. As we have seen in Section 8, CHRs are able to cope \nwith such additional features. The work presented here shares ideas with the recent work by Neubauer, \nThiemann, Gasbichler and Sperber [10]. Both works can be seen as a consequent re.nement of the HM(X) \nframework by incorporating an actual programming language on the type-level. Whereas we employ CHRs, \nNeubauer et al. employ a functional\u00adlogic language [12]. The expressiveness of both system seems to be \nequivalent in power. One of the main differences is that we require con.uence of CHRs whereas Neubauer \net al. allow for a customiz\u00adability of evaluation strategies. Similarly to our proposal, Odersky, Wadler \nand Wehr [26] proposed a variation of overloading, named System O, where no class hi\u00aderarchies are imposed \non overloaded identi.ers. Their motivation was mainly to provide an untyped semantics for overloading. \nThis clearly results in a less expressive system. Camarao and Figueiredo [4] considered an extension \nof System O which is close to our proposal. Their system seems to be even more liberal by allowing for \nlocal overloading. Overloaded identi.ers can be de.ned via ordinary let-de.nitions at any arbitrary level. \nBy default their system codes a closed world assumption. We suspect that this must put decidable type \ninference in danger in the presence of closed recursive de.nitions (see Section 8.1). Implicit parameters \n[22] introduced by Lewis, Shields, Meijer and Launchbury are a complement to Haskell style overloading. \nIm\u00adplicit parameters can be seen as a mild form of local overloading while still retaining decidable \ntype inference and coherence. We are currently investigating how to incorporate local overloading into \nthe present approach. This should provide then a unifying framework within we can study implicit parameters \nand Haskell style overload\u00ading. It is also worth mentioning the work by Yang [36]. He shows how to express \ntype-indexed values in languages based on the Hind\u00adley/Milner system. This is clearly related to overloading, \nthough we yet have to work out the exact connections between his work and ours. 10 Conclusion It is folklore \nknowledge that via Haskell s type class system it is possible to encode logic programs on the level of \ntypes. However, there has not been any proposal so far to make this connection con\u00adcrete. In this paper, \nwe have proposed a general overloading framework based on CHRs. CHRs serve as a meta-language to describe \nrela\u00adtions among overloaded identi.ers. We can describe precisely in terms of CHRs under which conditions \ntype inference is decidable (Section 5) and the semantics of programs is well-de.ned (Sec\u00adtion 6). We \nbelieve that the range-restrictedness condition can be lifted as long as variables in the body of CHRs \nfunctionally de\u00adpend on variables in the head. Due to space limitations we could only sketch the coherence \nresult. For a detailed discussion we refer to [31]. The design space for overloading systems is huge. \nIn Section 8 we elaborate on some possible variations. We refer to [33] for more examples on how our \nCHR-based overloading system helps to im\u00adprove previous approaches. We are also in the process of imple\u00admenting \nthe CHR-based type inference engine for a Haskell like language including a translation scheme [32]. \nAcknowledgements We thank Kevin Glynn, Simon Peyton-Jones, Andreas Rossberg, Peter Thiemann, Jeremy Wazny, \nMatthias Zenger and the referees for their comments. 11 References [1] S. Abdennadher. Operational semantics \nand con.uence of constraint propagation rules. In Proc. of CP 97, LNCS 1330, pages 252 266. Springer-Verlag, \n1997. [2] S. Abdennadher and H. Sch\u00a8utz. CHR.: A .exible query lan\u00adguage. In Proc. of Flexible Query \nAnswering Systems, LNAI 1495, pages 1 14. Springer-Verlag, 1998. [3] Lennart Augustsson. Cayenne -a language \nwith dependent types. In Proc. of ICFP 98, pages 239 250. ACM Press, 1998. [4] C. Camarao and L. Figueiredo. \nType inference for over\u00adloading without restrictions, declarations or annotations. In Proc. of the 4th \nFuji International Symposium on Functional and Logic Programming, LNCS 1722, pages 37 52. Springer-Verlag, \n1999. [5] K. Chen, P. Hudak, and M. Odersky. Parametric type classes. In Proc. of ACM Conf. on Lisp \nand Functional Programming, pages 170 191. ACM Press, 1992. [6] B. Demoen, M. Garc\u00b4ia de la Banda, W. \nHarvey, K. Marriott, and P.J. Stuckey. An overview of HAL. In Proc. of CP 99, LNCS 1713, pages 174 188. \nSpringer-Verlag, 1999. [7] T. Fr\u00a8uhwirth. Constraint handling rules. In Constraint Pro\u00adgramming: Basics \nand Trends, LNCS 910. Springer-Verlag, 1995. [8] T. Fr\u00a8uhwirth. A declarative language for constraint \nsystems: Theory and practice of constraint handling rules, 1998. Ha\u00adbilitation. [9] T. Fr\u00a8Theory and \npractice of constraint handling uhwirth. rules. Journal of Logic Programming, 37(1 3):95 138, 1998. [10] \nM. Gasbichler, M. Neubauer, M. Sperber, and P. Thiemann. Functional logic overloading. In Proc. of POPL \n02, pages 233 244. ACM Press, 2002. [11] K. Glynn, P. Stuckey, and M. Sulzmann. Type classes and constraint \nhandling rules. First Workshop on Rule-Based Constraint Reasoning and Programming, July 2000. CORR http://xxx.lanl.gov/abs/cs.PL/0006034. \n[12] M. Hanus. The integration of functions into logic program\u00adming: From theory to practice. Journal \nof Logic Program\u00adming, 19&#38;20:583 628, 1994. [13] The Mercury language reference manual, 2001. http://www.cs.mu.oz.au/research/mercury/. \n[14] D. Jeffery, F. Henderson, and Z. Somogyi. Type classes in Mercury. In Proc. of 23rd Australasian \nComputer Science Conf., pages 128 135. IEEE Press, 2000. [15] M. P. Jones. Quali.ed Types: Theory and \nPractice. D.phil. thesis, Oxford University, September 1992. [16] M. P. Jones. Coherence for quali.ed \ntypes. Research Report YALEU/DCS/RR-989, Yale University, Department of Com\u00adputer Science, September \n1993. [17] M. P. Jones. A system of constructor classes: Overloading and implicit higher-order polymorphism. \nIn Proc. of FPCA 93, pages 52 61. ACM Press, 1993. [18] M. P. Jones. Simplifying and improving quali.ed \ntypes. In Proc. of FPCA 95, pages 160 169. ACM Press, 1995. [19] M. P. Jones. Type classes with functional \ndependencies. In Proc. of ESOP 00, pages 230 234 LNCS 1782. Springer-Verlag, 2000. [20] S. Peyton Jones, \nM. P. Jones, and E. Meijer. Type classes: an exploration of the design space. In Haskell Workshop, June \n1997. [21] S. Kaes. Parametric overloading in polymorphic program\u00adming languages. In Proc. of ESOP 88, \nLNCS 300, pages 131 141. Springer-Verlag, 1988. [22] J. Lewis, M. Shields, E. Meijer, and J. Launchbury. \nImplicit parameters: Dynamic scoping with static types. In Proc. of POPL 00, pages 108 118. ACM Press, \n2000. [23] R. Milner. A theory of type polymorphism in programming. Journal of Computer and System Sciences, \n17:348 375, Dec 1978. [24] T. Nipkow and C. Prehofer. Type reconstruction for type classes. Journal of \nFunctional Programming, 5(2):201 224, 1995. [25] M. Odersky, M. Sulzmann, and M. Wehr. Type inference \nwith constrained types. Theory and Practice of Object Systems, 5(1):35 55, 1999. [26] M. Odersky, P. \nWadler, and M. Wehr. A second look at over\u00adloading. In Proc. of FPCA 95, pages 135 146. ACM Press, 1995. \n[27] S. Peyton Jones et al. Report on the programming language Haskell 98. http://haskell.org. [28] \nM.J. Plasmeijer and M.C.J.D. van Eekelen. Lan\u00adguage report Concurrent Clean. Tech. Report CSI-R9816, \nUniversity of Nijmegen, June 1998. ftp://ftp.cs.kun.nl/pub/Clean/Clean13/doc/refman13.ps.gz. [29] M. \nShields and S. Peyton Jones. Object-oriented overloading for Haskell. In Workshop on Multi-Language Infrastructure \nand Interoperability, September 2001. [30] P. J. Sulzmann and M. Sulzmann. A theory of overloading. Technical \nreport 2002/2, The University of Melbourne, 2002. http://www.cs.mu.oz.au/ sulzmann/chr/. [31] M. Sulzmann \nand A. Rossberg. A theory of over\u00adloading part II: semantics and coherence. Techni\u00adcal report 2002/1, \nThe University of Melbourne, 2002. http://www.cs.mu.oz.au/ sulzmann/chr/. [32] M. Sulzmann, A. Rossberg \nand J. Wazny. The Chameleon language manual. http://www.cs.mu.oz.au/ sulzmann/chameleon. [33] M. Sulzmann \nand A. Rossberg. Beyond type classes. Working paper. www.cs.mu.oz.au/ sulzmann/chr/. [34] M. Sulzmann. \nA General Framework for Hindley/Milner Type Systems with Constraints. PhD thesis, Yale University, De\u00adpartment \nof Computer Science, May 2000. [35] P. Wadler and S. Blott. How to make ad-hoc polymorphism less ad-hoc.In \nProc. of POPL 89, pages 60 76. ACM Press, 1989. [36] Z. Yang. Encoding types in ML-like languages. In \nProc. of ICFP 98, pages 289 300. ACM Press, 1998.  A Constraint Handling Rules Individual rule application \nsteps are formalized below. Each con\u00adstraint C is split into a set of user-de.ned constraints Cu and \na set of equations Ce,i.e. C =Cu U Ce. Variables in CHR rules r are renamed before rule application. \nNote that we allow for guarded simpli.cation rules \u00afc 1 gd\u00af where the guard constraints g is a conjunction \nof disequality constraints. (Solve) Cu U Ce --P fCu U C' e if 1 =C' e Ce and f mgu of Ce (Simp) Cu U \nCe --P (Cu \u00ad\u00afc ' )U .(\u00afd)U Ce if \u00afc 1 g d\u00af E P and there exists \u00afc ' E Cu and a substitution . on variables \nin r such that .(\u00afc ' )= \u00afc and 1 =Ce .(g) (Prop) Cu U Ce --P Cu U Ce U .(d\u00af) if \u00afc =d\u00af E P and there \nexists a subset \u00afc ' Cu and a substitution . on variables in r such that .(\u00afc ' )= \u00afc The observant \nreader will notice that we have to prevent the in.nite application of CHR propagation rules. We refer \nto [1] for more details. We .nd the following result, see [9] for details. THEOREM 4(SOUNDNESS). Let \nP be a CHR program and C,C' p \u00af constraints such that C --PC'. Then, [[PJJ1 =C : fvCC)C' .  \n\t\t\t", "proc_id": "581478", "abstract": "We present a minimal extension of the Hindley/Milner system to allow for overloading of identifiers. Our approach relies on a combination of the HM(X) type system framework with Constraint Handling Rules (CHRs). CHRs are a declarative language for writing incremental constraint solvers. CHRs allow us to precisely describe the relationships among overloaded identifiers. Under some sufficient conditions on the CHRs we achieve decidable type inference and the semantic meaning of programs is unambiguous. Our approach allows us to combine open and closed world overloading. We also show how to deal with overlapping definitions.", "authors": [{"name": "Peter J. Stuckey", "author_profile_id": "81100133272", "affiliation": "The University of Melbourne, Vic., Australia", "person_id": "PP14057424", "email_address": "", "orcid_id": ""}, {"name": "Martin Sulzmann", "author_profile_id": "81100115708", "affiliation": "The University of Melbourne, Vic., Australia", "person_id": "PP39028024", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/581478.581495", "year": "2002", "article_id": "581495", "conference": "ICFP", "title": "A theory of overloading", "url": "http://dl.acm.org/citation.cfm?id=581495"}