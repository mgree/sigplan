{"article_publication_date": "09-17-2002", "fulltext": "\n Composable and Compilable Macros You Want it When? Matthew Flatt University of Utah Abstract Many macro \nsystems, especially for Lisp and Scheme, allow macro transformers to perform general computation. Moreover, \nthe lan\u00adguage for implementing compile-time macro transformers is usu\u00adally the same as the language for \nimplementing run-time functions. As a side effect of this sharing, implementations tend to allow the \nmingling of compile-time values and run-time values, as well as values from separate compilations. Such \nmingling breaks pro\u00adgramming tools that must parse code without executing it. Macro implementors avoid \nharmful mingling by obeying certain macro\u00adde.nition protocols and by inserting phase-distinguishing annota\u00adtions \ninto the code. However, the annotations are fragile, the pro\u00adtocols are not enforced, and programmers \ncan only reason about the result in terms of the compiler s implementation. MzScheme the language of \nthe PLT Scheme tool suite addresses the problem through a macro system that separates compilation without \nsacri.c\u00ading the expressiveness of macros. Categories and Subject Descriptors D.3.3 [Software]: Programming \nLanguages language constructs and features, Scheme; D.3.4 [Software]: Processors parsing, pre\u00adprocessors; \nD.2.12 [Software Engineering]: Interoperability General Terms Languages, Design  Keywords Macros, modules, \nlanguage tower 1 Introduction Macro systems provide a convenient interface for extending a com\u00adpiler \nto support new language constructs. In the most expressive macro systems, macro transformers are not \nconstrained to mere Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. ICFP 02, October 4-6, 2002, Pittsburgh, Pennsylvania, USA. Copyright 2002 ACM 1-58113-487-8/02/0010 \n...$5.00 pattern-matching transformations, but may perform arbitrary com\u00adputation during expansion [12, \n17, 3, 24, 26, 1]. In addition, macros may manipulate abstract syntax enriched with lexical information \ninstead of manipulating raw source text [15, 2, 4, 8], which means that macro-de.ned constructs can be \nassigned a meaning indepen\u00addent of details of the macro s expansion (e.g., whether the macro introduces \na local variable named temp or happens to call the car function). Finally, in the Lisp and Scheme tradition \nwhere macros are themselves de.ned in a macro-extensible language, extensions can be stacked in a language \ntower. Each extension of the lan\u00adguage can be used in implementing the next extension. Trouble with Expressive \nMacro Systems. In a typical Scheme system, however, language towers cause trouble [19]. Advances in macro \ntechnology have simpli.ed the creation of individual blocks for a tower, but they have not delivered \na reliable mortar for assem\u00adbling the blocks. For example, suppose \"P.scm\" is implemented in an extension \nof Scheme E , where E is implemented by \"E.scm\" directly in Scheme. A typical load sequence for P is \n(load \"E.scm\") (load \"P.scm\") The above statements might be placed in a .le \"loadP.scm\", which can then \nbe submitted to a Scheme interpreter to execute \"P.scm\" successfully. The problem starts when the program\u00admer \ntries to compile the program for later execution. Supplying \"loadP.scm\" to the compiler is useless, because \nthe result is sim\u00adply the compiled form of two load statements. A full compiler will be needed at run-time \nwhen \"P.scm\" is actually loaded. The problem is that the compile-time code in \"E.scm\" is not dis\u00adtinguished \nin any way from the run-time code in \"P.scm\", and the run-time load operation is abused as a con.guration-time \nopera\u00adtion. The conventional solution is to decorate \"loadP.scm\" and similar .les with eval-when annotations \n[7, 23] that designate the intended phase of an expression: (eval-when (compile) (load \"E.scm\")) (load \n\"P.scm\") This solution has three major weaknesses. First, the resulting anno\u00adtations are fragile; small \nchanges to the program organization can render a set of annotations incorrect. For example, suppose that \n\"E.scm\" initially contains only macro de.nitions, but a run-time support function is added. The eval-when \nannotation must be aug\u00admented with load to properly load the run-time parts of \"E.scm\". Second, for large \nexamples with tall language towers and with li\u00adbrary code written in different extensions of Scheme, \nthe correct eval-when annotations can be dif.cult to discern. Indeed, an\u00adnotating only (load \"E.scm\") \nis probably not the right strategy if \"E.scm\" de.nes a mixture of macros and run-time functions. Third, \nan incorrect set of annotations can appear to work correctly (for a time) due to the accidental implementation \nof compile-time functionality by run-time code that happens to be loaded. In gen\u00aderal, static checking \ncannot ensure that variable bindings are satis\u00ad.ed by code from the right phase. For macros to serve \nas reliable compiler extensions, the program\u00adming model must clearly separate the compile-time and run-time \nphases of all code at all times. The phases may be interleaved for interactive evaluation, but compiling \nnew code must not affect the execution of previously compiled code. Similarly, the amount of interleaving \nshould not matter: code should execute the same if it is compiled all in advance, if it is compiled with \ninterleaved execu\u00adtion, or if half the code is compiled today and the rest is compiled on a different \nmachine tomorrow. Finally, when a complete appli\u00adcation is compiled, the programming environment should \nbe able to strip all compile-time code from the .nal deliverable. Reliable Macros in MzScheme. The new \nmacro and module system in MzScheme (the implementation language of the PLT Scheme suite) supports compilable \nmacros in the above sense. More concretely, the system ensures that if a program works cor\u00adrectly when \nloaded interactively in the read-eval-print loop, then it works correctly when run through the compiler, \nrun in the debug\u00adger, parsed by the syntax checker, or expanded for static analysis and vice-versa. The \nimplemented system is backed up by a formal model. The model explains module compilation and demonstrates \nhow computational effects, including the introduction of variable bindings, are con.ned to a single phase. \nThe module system avoids the problems of eval-when by mak\u00ading module dependencies explicit (instead of \nrelying on the side\u00adeffects of load), and by distinguishing compile-time dependencies from run-time dependencies. \nMoreover, the macro system enforces a separation between different phases, i.e., compile-time variables \nare never resolved to run-time values that happen to be loaded. Figure 1 illustrates module and macro \nprogramming in MzScheme. The module M imports variables and syntax from L using require. These L imports \ncan be used for implementing run-time expressions in M, such as the right-hand side of a de.nition for \nf . In addition, M imports from R using require-for-syntax. The R imports can be used in implementing \ncompile-time expressions in M, such as the right-hand side of the macro de.nition s . Meanwhile, module \nB imports both M and R with require. Enforcing the separation of compile time and run time means instantiating \nR at least twice: once for compiling B, and once for running B. Furthermore, separating different compilations \nmeans instantiating R yet again to compile B2, and so on. Proper module instantiation is part of the \nsolution, but two indis\u00adpensable features of Scheme macros further complicate enforcing a phase separation: \n Macro-generating macros A macro expansion can generate an expression that is to be run in the same \nphase as its gener\u00adator. Such macro-generating macros are critically important to implement language \nextensions that bind compile-time in\u00adformation. For example, a class-de.nition form must bind compile-time \ninformation about the class s methods.  Lexical scope In the context of macros, lexical scope means \nthat a free identi.er introduced by a macro expansion refers to its binding in the macro-de.nition context, \nnot the  macro-use context, while a free identi.er in the macro use refers to its binding in the macro-use \ncontext (unless the pro\u00adgrammer explicitly breaks hygiene ) [8, 14]. Free variables thus bound may refer \nto either run-time values or other macro transformers (which potentially generate transformer expres\u00adsions). \nIn terms of Figure 1, these complications affect the striped box next to s within M. The implementation \nof s will contain templated ex\u00adpressions that are used in the output of the macro. Some of tem\u00adplated \ncode will turn out to be compile-time code, bound by striped imports from R, but some templated code \nwill turn out to be run\u00adtime code, bound by polka-dotted imports from L. Separating the different parts \nis not statically decidable. Tracking such dependencies requires an extension of previously known macro-expansion \ntechniques. Our extension tracks the phase and phase-speci.c binding of each transformed identi.er to \nresolve bindings correctly and at a well-de.ned time. Our users initial experience with the new macro \nand module sys\u00adtem has been overwhelmingly positive. Previously, after develop\u00ading a program interactively, \nthe programmer would embark on a lengthy process of adding eval-when-like annotations to the pro\u00adgram, \ncarefully tuning calls to load, and .nally divining the proper sequence of command-line .ags to push \nthe code through the com\u00adpiler or analyzer. Libraries frequently failed to load when incorpo\u00adrated into \na program in a previously untried order. When loading or compilation failed, users were at a loss to \nexplain the failure. All of these experiences are typical for users of Scheme and Lisp implementations, \nbut no longer in MzScheme. Moreover, the im\u00adplementation of MzScheme itself relies on syntactic extension \nand language towers to a much greater extent than before. The result is a substantially improved code \nbase and easier experimentation with new language constructs. L R require M require require B2  \nFigure 1. Example modules Roadmap. Section 2 provides an overview of MzScheme macros and modules. Section \n3 presents an example of syntactic extension that illustrates key problems in compiling macro-based code, \nand how MzScheme macros and modules solve the problems. Section 4 provides a few pragmatic details concerning \nmacros and modules in MzScheme. Section 5 sketches a formal model with its phase\u00adseparation results. \nSection 6 summarizes related work. 2 A Macros and Modules Primer In a module-based MzScheme program, \nall code resides within some module, whether the code implements a run-time function or a compile-time \nmacro. The syntax of a module declaration is (module module-name language-name body-element ...) The \nlanguage-name is usually MzScheme. In the MzScheme lan\u00adguage, a body-element is either a de.nition, an \nexpression (exe\u00adcuted for its effect), a syntax de.nition, an import, or an export: 0 body-element ::= \n(define id expr 0) | expr | (define-syntax id expr 1) | (require req-spec ...) | (require-for-syntax \nreq-spec ...) | (provide prov-spec ...) The 0 superscript in expr 0 indicates that the expression is \neval\u00aduated at run time, or phase 0. The 1 superscript in expr 1 for define-syntax indicates that the \nexpression is evaluated at com\u00adpile time. The require form imports bindings that are exported from an\u00adother \nmodule. Bindings imported with require apply only to run-time expressions, i.e., the expr 0s in the module \nbody. The require-for-syntax form is similar to require, but the imported bindings apply only to compile-time \nexpressions, i.e., 1 expr s. The provide form exports a subset of a module s macro and vari\u00adable bindings. \nEach exported binding must be either de.ned within the module with define or define-syntax, or imported \ninto the module with require. 2.1 Using Modules The following Zoo module provides functions for creating \nand ma\u00adnipulating zebra and lizard records: (module Zoo MzScheme (provide zebra zebra? zebra-weight zebra-stripes \nlizard ) ;; Creates a zebra record given its weight and stripes: (define (zebra weight stripes ) (list \nzebra weight stripes )) ;; Recognizes a zebra: (define (zebra? l ) (and (list? l )(= 3 (length l )) (eq? \nzebra (car l )))) ;; Extracts a zebra s weight: (define (zebra-weight l ) (list-ref l 1)) (define (lizard \nweight length color ) (list lizard weight length color )) ) [A  represents elided code.] In a separate \nMetrics module, we can implement an animal-weight function using the functions from Zoo: (module Metrics \nMzScheme (require Zoo) (provide animal-weight ) (define (animal-weight a ) (cond ((zebra? a )(zebra-weight \na )) ((lizard? a )(lizard-weight a ))))) When we invoke the Metrics module, the Zoo module is automat\u00adically \nexecuted, and it is executed before Metrics. More generally, we de.ne invoke on a module to mean execut\u00ading \nthe module s expr 0s, but only after executing the expr 0sof each required module. The require-execution \nrule applies up the chain of modules, so that every module used (directly or in\u00addirectly) by an invoked \nmodule is executed before its importers. Unused modules are ignored, and modules used through multiple \nrequire paths are executed only once.1 2.2 Macros In addition to exporting values, such as the zebra \nfunction, a mod\u00adule can export macros. For example, the Zoo module might pro\u00advide a zoo-switch macro \nfor conveniently dispatching on animal records, which we could then use to implement animal-weight more \ncompactly as follows: (define (animal-weight a ) (zoo-switch a ((zebra ws ) w ) ((lizard wlc ) w ))) \nThe Metrics module is compiled by .rst loading the macro def\u00adinitions of Zoo, which implies that Zoo \nmust be compiled earlier. In other words, just as executing a module causes its imports to be executed \n.rst, compiling a module requires that its imports are com\u00adpiled .rst. In addition, compiling a module \nexecutes the compile\u00adtime portions of imported modules to obtain macro transformers. The Zoo module de.nes \nthe zoo-switch macro using define-syntax: (module Zoo MzScheme (provide zebra  lizard  zoo-switch) \n (define-syntax (zoo-switch stx ) )) A macro is implemented as a transformer on syntax objects. The \nin\u00adput syntax object (stx for zoo-switch) corresponds to the macro use, and the output syntax object \nrepresents the expansion. A syntax object is similar to an S-expression, except that it also encapsulates \nsource-location and lexical information for each of its parts. In the case of zoo-switch, every use of \nthe macro must have two clauses one for zebra and another for lizard and the .rst clause must have two \nvariables, while the second clause must have three variables. Thus, the stx argument must be a syntax \nobject matching a particular shape. Input syntax is deconstructed using the pattern-matching syntax-case \nform [8]: 1The module-import relation must be acyclic. MzScheme pro\u00advides a separate mechanism for de.ning \nunits with mutually recur\u00adsive references [9], and units are implemented with macros. (define-syntax \n(zoo-switch stx ) (syntax-case stx (zebra lizard) ((zoo-switch expr ((zebra w-name s-name ) z-body ...) \n((lizard w-name lt-name c-name ) l-body ...)) ))) In the zoo-switch pattern, zebra and lizard are literals \n(because they are listed before the pattern), and expr , w-name , s-name , and z-body are pattern variables. \nWithin a pattern, ellipses (...) match a sequence of source sub-expressions to the preceding sub\u00adpattern, \nso that each variable in the sub-pattern is bound to a list of successively matching source parts. Thus, \nthe pattern for zoo-switch generates a list of z-body s when it matches, corre\u00adsponding to the sequence \nof body expressions in the zebra clause. The zoo-switch transformer must produce a cond expression whose \nclauses bind the variables provided in the macro use. After deconstructing syntax with syntax-case, a \nresulting syntax object is constructed with a quote-like # form. Unlike quote, the con\u00adtent of # can \nrefer to pattern variables bound by syntax-case. Each pattern variable under # is replaced by the matched \nsub\u00adexpression: (define-syntax (zoo-switch stx ) (syntax-case stx (zebra lizard) ((zoo-switch expr ((zebra \nw-name s-name ) z-body ...) ((lizard w-name lt-name c-name ) l-body ...)) # (let ((val expr )) (cond \n((zebra? val ) (let ((w-name (zebra-weight val )) (s-name (zebra-stripes val ))) z-body ...)) ))))) Within \na # -quoted template, ellipses duplicate the preceding sub\u00adtemplate so that, for each duplication of \nthe sub-template and for each variable in the sub-template, one source part is used from the variable \ns list of matching parts. Thus, the output expression for zoo-switch lists the same sequence of z-body \ns that matched the input pattern. Free variables inside a # template (that are not bound to pattern variables) \nobtain their bindings from the environment of the tem\u00adplate, not the environment of the macro use. Thus, \nzebra-weight in the expansion of zoo-switch always refers to the de.nition in Zoo, even if the context \nof the use of zoo-switch has a different binding for zebra-weight . 2.3 Compilation and Phases The result \nexpression in a syntax-case clause need not be an immediate # expression. Instead, the result expression \nmay per\u00adform arbitrary computation at compile time. One common use for compile-time computation is error \nchecking. For example, we can improve the zoo-switch macro by detecting multiple bindings of an identi.er \nwithin a clause, as in the following expression: (zoo-switch a ((zebra ww ) w );; . multiple bindings \nfor w ((lizard wlc ) w )) To implement the duplicate-variable check, the result part of the syntax-case \nclause for zoo-switch consists of a sequence of expressions: two to check for duplicate bindings in the \ntwo clauses, and one to generate the macro expansion. (define-syntax (zoo-switch stx ) (syntax-case stx \n(zebra lizard) ((zoo-switch expr ((zebra w-name s-name ) z-body ...) ((lizard w-name lt-name c-name ) \nl-body ...)) (begin (check-dups # (w-name s-name )) (check-dups # (w-name lt-name c-name )) # (let ((val \nexpr )) ))))) Many macros must check for duplicate variables, so we implement the check-dups function \nin its own Check module: (module Check MzScheme (provide check-dups ) (define (check-dups variables ) \n)) To make check-dups available to the implementation of zoo-switch, Zoo must import Check. Since the \nfunction is needed at compile time, not at run time, Zoo imports Check using require-for-syntax: (module \nZoo MzScheme (require-for-syntax Check) (define-syntax (zoo-switch stx ) )) Whenever the compile-time \nportion of Zoo is executed (e.g., to compile Metrics), the run-time portion of Check is executed, due \nto the require-for-syntax import. Thus, the check-dups func\u00adtion is available whenever the transformer \nfor zoo-switch might be applied. When the run-time portion of Zoo is executed, Check is ig\u00adnored. Indeed, \ncheck-dups is not even bound in the run-time expressions of Zoo, so it cannot be used accidentally at \nrun time. Similarly, if Check were imported with require instead of require-for-syntax, then check-dups \nwould not be bound in the implementation of zoo-switch. Modules must not contain free variables, so incorrectly \nimporting Check with require instead of require-for-syntax would lead to a syntax error for the free \noccurrences of check-dups . In general, we de.ne visit on a module to mean executing its expr 1s, but \nonly after invoking each require-for-syntaxed module. As we see in the next section, visiting a module \nalso visits the module s required modules. 2.4 Execution and Phases When a module is invoked, the need \nto invoke required modules is obvious: before an expression within a module can be evalu\u00adated, imported \nvariables must be .rst initialized. Furthermore, a chain of initialization dependencies, often in the \nform of a chain of function calls, forces a chain of invocations through require. For example, a Zookeeper \nmodule might import Metrics and call animal-weight , which in turn calls zebra? in Zoo. Though less obvious, \nvisiting a module must also visit required modules, in case macro uses are chained. For example, Metrics \nmight export a zoo-weight-switch macro that expands to zoo-switch, but exposes only the weight .eld in \neach clause: (define-syntax (zoo-weight-switch stx ) (syntax-case stx (zebra lizard) ((zoo-weight-switch \nexpr ((zebra w-name ) z-body ...) ((lizard w-name ) l-body ...)) # (zoo-switch expr ((zebra w-name hide-s \n) z-body ...) ((lizard w-name hide-l hide-c ) l-body ...))))) If the Zookeeper module uses zoo-weight-switch, \nthen the macro transformer from Metrics is applied, and the result is a zoo-switch expression. To continue \nexpanding, the zoo-switch transformer from Zoo is called. Thus, the compile-time portion of Zoo must \nbe executed whenever the compile-time portion of Metrics is executed.  3 Putting Macros and Modules \nto Work Although we can de.ne an animal-speci.c zoo-switch form that works with hand-rolled data structures, \nwe would certainly prefer a general define-record form with a corresponding record-switch dispatching \nform. Indeed, many such record\u00addeclaration extensions to Scheme have been implemented [10, 13, 21, 27], \nbut such implementations rarely provide compile-time checking for record-switch clauses. In the same \nway that zoo-match reports a syntax error when a clause has the wrong number of variables, record-switch \nshould trigger a syntax error when a clause mentions an unde.ned datatype or lists the wrong number of \n.elds for a datatype. In this section, we introduce a define-record form and a co\u00adoperating record-switch \nform that detects ill-formed switch clauses and rejects them at compile time. This syntax checking forces \na level of communication between the implementations of define-record and record-switch that is characteristic \nof so\u00adphisticated syntactic extensions. At the same time, the implemen\u00adtation of the communication channel \nexposes common problems in compiling with sophisticated syntactic extensions. 3.1 Record De.nition and \nDispatch A typical record-declaration form for Scheme generates a construc\u00adtor procedure for creating \ninstances of the record, a predicate pro\u00adcedure for recognizing instances of the record, and a .eld-selector \nprocedure for each .eld in the record. For our purposes, we choose the following simple syntax: (define-record \nconstructor-name predicate-name field-selector-name ...) The ellipses indicate a sequence of field-selector-name \ns, and the number of field-selector-name s determines the number of .elds in the record (and thus the \nnumber of arguments to the con\u00adstructor procedure). If we implement define-record in a Record module, \nwe can re\u00adimplement Zoo as: (module Zoo MzScheme (require Record) (provide zebra  lizard ) (define-record \nzebra zebra? zebra-weight zebra-stripes ) (define-record lizard lizard? lizard-weight lizard-length lizard-color \n)) Compile-Time Run-Time require-for-syntax require Record require Zoo require require  Metrics \nFigure 2. Modules de.ned in Section 3 Using the record-based predicate and .eld-accessor procedures, \na programmer can de.ne an animal-weight function like our orig\u00adinal version in Section 2. In many cases, \nhowever, a pattern\u00admatching form for record dispatch is especially convenient. Hence, we implement an \nadditional form, record-switch: (record-switch expr ((constructor-name local-field-var ...) body-expr \n) ...) where the initial expr produces the value to match, each constructor-name is the name of a record \nconstructor whose def\u00adinition is in scope, and one local-field-var is provided for each .eld in the corresponding \nrecord type. Each local-field-var is bound to its .eld value within the case s body-expr . If we implement \nrecord-switch alongside define-record in Record, we can revise Metrics as follows: (module Metrics MzScheme \n(require Record Zoo) (provide animal-weight ) (define (animal-weight a ) (record-switch a ((zebra w s \n) w ) ((lizard wl c ) w )))) Our key constraint for record-switch concerns error handling. If a programmer \nwrites (define (bad-animal-weight a ) (record-switch a ((zebrawsabc de ) w ) ; too many fields ((lizardwlc \n) w ))) then the de.nition must be rejected as illegal syntax. More generally, if a record-switch expression \nmentions a record constructor-name that has not been de.ned, or if the number of .eld variables does \nnot match the number of .elds in the de.\u00adnition of constructor-name , then record-switch must report \nan error with a precise diagnosis of the mismatch. Furthermore, we require that the error is reported \nat compile time, which is before the record-switch expression is evaluated (if ever). 3.2 Implementing \nRecords The main part of the Record module de.nes two syntactic trans\u00adformers using define-syntax: (module \nRecord MzScheme (provide define-record record-switch) (define-syntax (define-record stx ) ) (define-syntax \n(record-switch stx ) ))) The following sketch shows the pattern-matching parts of define-record and \nrecord-switch: (module Record MzScheme (define-syntax (define-record stx ) (syntax-case stx () ((define-record \nc-name p-name f-name ...) (begin  # (define-values (c-name p-name f-name ...) ))))) (define-syntax \n(record-switch stx ) (syntax-case stx () ((record-switch expr ((c-name f-local-name ...) body ) other \n...) (begin # (let ((val expr )) ;; Is val an instance of c-name ? (if ;; Yes: evaluate the body. (let \n((f-local-name )...) body ) ;; No: try other cases. (record-switch val other ...))))) ((record-switch \nexpr ) # (error \"no matching pattern:\" expr ))))) Using ellipses, the pattern for define-record generates \na list of f-name s when it matches, and the multiple-de.nition output lists the same sequence of f-name \ns. The pattern for record-switch similarly matches a number of local .eld names for the .rst switch clause, \nplus any number of additional clauses; the extra clauses are processed through a recursive use of the \nmacro. Eventually, record-switch is used with no clauses (matching the second pat\u00adtern), and the generated \nexpression reports a failed pattern match if it is reached at run time.2 The implementation of define-record \nand record-switch re\u00adquires computation at both compile time and run time. At compile time, define-record \nmust store record de.nitions with .eld in\u00adformation, and record-switch must consult stored information \nto generate uses of the predicate and .eld selectors (or to compute an appropriate error message). At \nrun time, a define-record form must generate a record type with its constructor, predicate, and se\u00adlector \nprocedures, and a record-switch form must pattern-match records. To make the separation especially clear, \nwe place the compile-time functions in a Compile-Time module, and the run-time support in a Run-Time \nmodule. The Compile-Time module de.nes a table to hold record-de.nition information: (module Compile-Time \nMzScheme (provide (all-defined))) ;; Export everything. (define table null ) (define (register-def c-name \np-name f-names ) (set! table (cons (list c-name p-name f-names ) table ))) (define (check-constructor \nc-name f-names ) ;; Find c-name in table , and raise a syntax error ;; if it s not there or if the .eld \ncount differs. ) (define (constructor->predicate c-name ) );; Find c-name in table , return p-name \n. (define (constructor->field-accessors c-name ) )) ;; Find c-name in table , return f-names . 2An alternative \ndesign is to put a set of record de.nitions to\u00adgether in a named datatype, so that missing clauses can \nbe reported at compile time [10] as in ML. The Run-Time module de.nes the tag and procedure generators: \n(module Run-Time MzScheme (provide (all-defined)) (define counter 0) (define (generate-unique-tag ) \n(set! counter (+ counter 1)) counter ) (define (make-record-procs tag f-names ) )) ;; Return multiple \nprocedure values. The Record module brings the two together with require and require-for-syntax: (module \nRecord MzScheme (require-for-syntax Compile-Time) (require Run-Time) (provide define-record record-switch) \n(define-syntax (define-record stx ) ) (define-syntax (record-switch stx ) )) Implementing the rest \nof Compile-Time and Run-Time is straight\u00adforward, so we concentrate on completing the Record module. \n3.2.1 First Attempt (Failure) Naively, define-record might use register-def to register a constructor-name \nmapping before generating the expanded expres\u00adsion: (define-syntax (define-record stx ) (syntax-case \nstx () ((define-record c-name p-name f-name ...) (begin (register-def # c-name # p-name # (f-name ...)) \n# (define-values (c-name p-name f-name ...) ))))) To see why this strategy fails, consider compiling \nthe Zoo and Metrics modules in separate Scheme sessions. Since Metrics imports Zoo, Zoo must be compiled \n.rst. While compiling Zoo, zebra and lizard are added to a table of record de.ni\u00adtions, but the compiled \nuses of define-record do not mention register-def . Instead, the compile-time table of registrations \ndisappear when the compilation of Zoo is complete. Later, when Metrics is compiled in a new Scheme session, \nthe table of record registrations is created afresh, and neither zebra nor lizard is registered. A key \nfeature of the MzScheme module system is that compiling Metrics will fail even when the modules are compiled \nin the same session. Thus, the implementor of the define-record macro is alerted to the problem immediately, \nrather than at some later point where separate compilation (or even separate syntax checking) be\u00adcomes \nimportant. 3.2.2 Second Attempt (Success) To work with MzScheme s module system, define-record must \npermanently attach record registrations to Zoo as compile-time information. With the registrations so \nattached, executing the compile-time portion of Zoo for compiling Metrics (because Metrics imports Zoo \nwith require) will reinstate the zebra and lizard registrations. Macro-generating macros provide define-record \nwith a mech\u00adanism to attach compile-time information to Zoo. If the define-record s macro expansion is \na new macro de.nition, then the new macro de.nition is attached to Zoo as a compile\u00adtime expression. \nTechnically, define-record can generate a dummy macro de.nition that calls register-def instead of producing \na transformer procedure. For readability, we use a begin-for-syntax form instead: (define-syntax (define-record \nstx ) (syntax-case stx () ((define-record c-name p-name f-name ...) # (begin (begin-for-syntax ;; Register \nthe record on every compilation: (register-def # c-name # p-name # (f-name ...))) (define-values (c-name \np-name f-name ...) (let ((tag (generate-unique-tag ))) (make-record-procs tag (f-name ...)))))))) The \nbody of a begin-for-syntax expression is executed at com\u00adpile time, just like the right-hand side of \ndefine-syntax. Con\u00adsequently, the expansion of define-record in the compiled form of Zoo will contain \na compile-time registration of zebra . When Metrics is compiled, the import of Zoo triggers the execution \nof Zoo s compile-time expressions, thus registering zebra . Indeed, each individual time that Metrics \nis compiled, the compile-time portions of Zoo and Record are executed afresh. Since the compile-time \nportion of Record imports Compile-Time, then Compile-Time is also executed afresh when Metrics is com\u00adpiled. \nThis fresh execution of Compile-Time explains why the .rst attempt at implementing define-record triggers \na predictable compile-time error. Even when Zoo and Metrics are compiled in the same Scheme session, \nthey are compiled with different exe\u00adcutions of Compile-Time, and thus with different record tables. \n 3.3 Phase Separation Besides losing a phase-speci.c calculation too early, as in the .rst attempt at \nimplementing define-record, a programmer might inadvertently mingle compile-time and run-time operations \nin a macro. For example, the programmer might forget the begin-for-syntax wrapper around the use of register-def \n: (define-syntax (define-record stx ) (syntax-case stx () ((define-record c-name p-name f-name ...) # \n(begin (register-def # c-name # p-name # (f-name ...)) (define-values (c-name p-name f-name ...) (let \n((tag (generate-unique-tag ))) (make-record-procs tag (f-name ...)))))))) In this case, the macro result \nmakes no sense: register-def is used in a run-time position, but the only binding of register-def refers \nto a compile-time function. MzScheme .ags a syntax error for the resulting expression, because the register-def \nvariable is free in the run-time portion of Record. The syntax check is important. The register-def function \nmight actually exist at compile time if compilation is interleaved with run time (as in a typical read-eval-print \nloop). Even in that case, the use of register-def must be disallowed, so that interleaved compi\u00adlation \nproduces the same result as separate compilation. The detection of an identi.er s phase occurs relatively \nlate in the macro-expansion process. For example, in the output of the cor\u00adrect define-record, the phase \nof the register-def identi.er is determined after the output is generated, when it is found to be in \nbegin-for-syntax. In general, the phase of a templated identi.er cannot be de\u00adtermined statically from \nthe # -quoted template. For example, we might de.ne a my-begin-syntax macro instead of using begin-for-syntax: \n(define-syntax (define-record stx ) (syntax-case stx () ((define-record c-name p-name f-name ...) # (begin \n(my-begin-syntax (register-def # c-name # p-name # (f-name ...))) (define-values (c-name p-name f-name \n...) (let ((tag (generate-unique-tag ))) (make-record-procs tag (f-name ...)))))))) In this case, the \nmy-begin-syntax expression must be expanded to discover that register-def is used at compile time. A \nper\u00adverse implementation of my-begin-syntax might even dynami\u00adcally choose to put its body in a compile-time \ncontext or a run-time context. To permit identi.er resolution in the proper phase, each identi.er must \ncarry two versions of its lexical information, one for each phase. This new twist on lexically scoped \nmacros is the key to supporting simple and reliable compilation. Separating phases begs the question \nof which phase contains the Scheme implementation s kernel procedures. After all, functions such as cons \nand + are often needed both at compile time and at run time. The answer is that any module (including \nthe one for core Scheme) can exist in multiple phases, but each phase contains a distinct execution of \nthe module. In particular, the MzScheme language declaration for Record effectively imports core Scheme \nforms with both require and require-for-syntax, but the two instantiations of core Scheme are separate; \nthe compile-time cons is (in principle) unrelated to the run-time cons. More generally, the MzScheme \nmodule system allows a module to import a single identi.er from two different modules for two different \nphases.  4 MzScheme Details and Pragmatics In practice, every module in MzScheme is placed within its \nown .le, and modules refer to each other through relative .le paths and library paths. For example, Zoo \nwould be placed in a \"zoo.scm\" .le, and Metrics would import it with (require \"zoo.scm\"). Library paths \nrely on a mechanism similar to the CLASSPATH envi\u00adronment variable that Java implementations use to .nd \nlibraries. In a module declaration (module module-name language-name body-element ...) language-name \nrefers to another module, and the built-in module MzScheme is only one possible choice. The syntax and \nsemantics of the body-element s are determined by language-name . In other words, the module body starts \nwith no syntax or variable bindings, and language-name is used as an initial import to introduce bind\u00adings \nfor the module body, including bindings for define, provide, and require. 4.1 De.nitions, Imports, and \nExports As indicated in Section 2, a body-element in the MzScheme lan\u00adguage is either a de.nition, an \nexpression, a syntax de.nition, an import, or an export: 0 body-element ::= (define id expr 0) | expr \n| (define-syntax id expr 1) | (require req-spec ...) | (require-for-syntax req-spec ...) | (provide prov-spec \n...) The grammar for expr extends the standard Scheme grammar [14], including let-syntax, which introduces \na local macro: n n expr ::= id | (lambda (id ...) expr n) | (expr ...) n | (syntax-case expr ) | # template \n| (let-syntax ((id expr n+1) ...) expr n) | Within let-syntax, the n + 1 superscript for each binding \nexpres\u00adsion indicates that the expression is evaluated one phase earlier than the let-syntax body. The \nrequire form imports either all of the bindings of a module, pre.xed versions, a subset, a pre.xed subset, \nor renamed bindings: req-spec ::= module-name | (prefix pfx-id module-name ) | (all-except module-name \nidentifier ...) | (prefix-all-except pfx-id module-name id ...) | (rename module-name local-id export-id \n) The provide form can export bindings individually (optionally with renaming), and bindings originating \nfrom a particular module can be exported as a group: prov-spec ::= id | (rename local-id export-id ) \n| (all-from module-name ) | (all-from-except module-name id ...) | (all-defined) | (all-defined-except \nid ...) Unexported module de.nitions are private to the module. A module can contain any number of require, \nprovide, and require-for-syntax declarations, in any order. A macro use can expand to require, require-for-syntax, \nand provide decla\u00adrations, as well as de.nitions and expressions. The scope of every imported or de.ned \nname covers the entire module body. No name can be multiply de.ned, and free variables are disallowed. \nSince local and imported macros can expand to additional de.ni\u00adtions and imports, a module s body is \npartially expanded to discover all de.nitions. As a consequence of disallowing multiple de.ni\u00adtions for \nan identi.er, a successful partial expansion leads to an unambiguous expansion. All variables within \na module must be bound, whether in a run\u00adtime position or in a compile-time position. At run time, modules \nimport and export variables, as opposed to values, which means that assignments to a variable with set! \nare visible outside the module. Imported variables cannot be mutated with set!, so if a variable is not \nmutated within its de.ning module, it is immutable. This re\u00adstriction is enforced during compilation, \nwhich allows the compiler to perform optimizations based on immutable bindings.3 3Thanks to Kent Dybvig \nfor recommending this restriction. 4.2 Compilation and Invocation As a module is compiled, the module \nitself is visited (i.e., the right\u00adhand expr 1 of each define-syntax declaration in the module is evaluated \nimmediately). Since the require-for-syntax form triggers an invocation dur\u00ading a syntax-invocation, require-for-syntax \nforces a certain amount of interleaving of compilation and execution. Furthermore, due to the phase-shifting \nnature of let-syntax, macro expansion can involve many concurrent phases of compilation in an arbitrarily \ntall tower of expanders . Nevertheless, the state for each phase is kept separate through lex\u00adical scoping \nand the phase-speci.c binding of imports. The value of a expr n variable cannot be accessed by expr n-1 \ncode, or vice\u00adversa. Furthermore, invocation of a compiled module does not re\u00adquire any syntax-invocations. \nIn particular, after the main module for a program is compiled, the compiler can strip all compile-time \ncode from the program (i.e., expr 1s), including entire modules that are used only through require-for-syntax. \n 4.3 Syntax Primitives A syntax object is a .rst-class value, and syntax objects can exist at run time \nas well as compile time, but they are used primarily at compile time. Built-in operations support the \ndeconstruction of a syntax object, the composition of new syntax objects from old ones, and the comparison \nof binding properties for two identi.er syntax objects (e.g., determining whether they refer to the same \nlexical binding). The syntax-case form in MzScheme expands to an expression that uses the built-in operations \nto deconstruct and pattern-match syntax objects. The quote-syntax primitive form is similar to quote, \nexcept that it generates syntax-object constants instead of lists and sym\u00adbols. The # template form expands \nto an expression that uses quote-syntax on the portions of the template that do not re\u00adfer to pattern \nvariables. Meanwhile, syntax-case communi\u00adcates pattern-variable bindings to # in roughly the same way \nthat define-record communicates to record-switch.  5 A Model of Compilation Our formal model of MzScheme \ns macro and module system builds on Dybvig et al. s model [8]. Here, we provide a sketch of the model \nand its key results, which demonstrate various separation properties. The model is a simpli.cation of \nMzScheme in several ways. First, every module is implemented in a .xed base language. Sec\u00adond, modules \nexport all de.nitions, and no renaming is allowed on export or import. Third, the order of declarations \nin a mod\u00adule body is .xed (require-for-syntax declarations are .rst, etc.), and macro applications cannot \nexpand to imports or def\u00adinitions. Despite these simpli.cations, the model includes both require-for-syntax \nand let-syntax, so that the model cov\u00aders phase-sensitive lexical scope, macro-de.ning macros, and in\u00adterleaved \nexecution of phases. Source Grammar. A source program consists of a sequence of module declarations followed \nby a single (invoke mod id). The .nal invoke declaration triggers the execution of the module mod, and \nextracts the computed value for that module s id variable. prog ::= decl ... (invoke mod id) decl ::= \n(module mod (require-for-syntax mod) ... (require mod) ... (define-syntax id s-exp) ... (define id s-exp) \n...) s-exp stx ::= ::= stx | prim | (s-exp ...) an identi.er with lexical info (see Figure 3) prim ::= \na primitive value or operator id ::= an identi.er mod ::= a module name Each module declaration contains \na sequence of for-syntax imports, a sequence of normal imports, a sequence of syntax de.nitions, and \na sequence of normal de.nitions. The expressions in de.nitions are arbitrary syntax objects, represented \nby the s-exp non-terminal, at least until they are parsed. Core Language Expressions. Parsing and macro \nexpansion are intertwined, so that s-exp is as much as we can write for a true grammar of source expression. \nIn the absence of macros and ig\u00adnoring shadowing, however, the core grammar of expressions is as follows: \nbase-s-exp ::= (app base-s-exp base-s-exp ...) | (lambda (id) base-s-exp) | (let-syntax (id base-s-exp) \nbase-s-exp) | (macro-app id base-s-exp ...) | (quote-syntax s-exp) | prim | id This core source language \nconsists of function applications (writ\u00adten with an explicit app), functions, local macro de.nitions, \nmacro uses (written with an explicit macro-app), quoted literals, prim\u00aditives, and variable references. \nThe app, lambda, etc. names are not keywords; they are merely bound in the initial environment to mean \nthe primitive application form, the primitive function form, etc., respectively. Executable Grammar. \nParsing and compiling an input s-exp pro\u00adduces an executable c-exp. Compiling a sequence of source module \ndeclarations produces a sequence of compiled cmodule declara\u00adtions: cprog ::= cdecl ... (invoke mod id) \ncdecl ::= (cmodule mod (require-for-syntax mod) ... (require mod) ... (define-syntax id c-exp) ... (define \nid c-exp) ...) c-exp ::= (app c-exp c-exp ...) | id | mod.id.p | val val ::= (lambda (id) c-exp) | (lit \ns-exp) Our target language thus consists of functions, function appli\u00adcations, lexical variable references, \nmodule variable references mod.id.p (i.e., for a certain module, variable, and phase), and lit\u00aderal constants. \nConstants encapsulate lexical-context information, which is useful when the constant is used in a macro \nimplementa\u00adtion. The evaluation of c-exps is de.ned in the usual manner, with rules for primitives such \nas ((app (lit car)(lit (s-exp0 s-exp1... s-expn))),S) -. ( (lit s-exp0),S) where S is the store. Primitives \ncan consult, extend, or modify the store. Invoking or visiting a module also extends the store. Evaluat\u00ading \na variable reference mod.id.p accesses a module-installed bind\u00ading in the store. Module Compilation. \nThe compile-module function compiles an entire source module, given a sequence of previously compiled \nmodules that are available for import: compile-module : decl \u00d7 cdecl-list . cdecl The module-compilation \nfunction does not consume or produce a store. Instead, it starts from an empty store, re.ecting the separate \ncompilation of separate modules, and the separation of compile\u00adtime state from run-time state. Using \nthe fresh store, compile-module visits required modules and updates the store with imported bindings. \nThe compile-module function also invokes require-for-syntaxed modules. After visiting and invoking imported \nmodules, compile-module an\u00adnotates the s-exps in the body of the module to record the imports and de.nitions \nof the module. The annotation includes an appro\u00adpriate phase: 0 for local de.nitions and require imports, \n1 for require-for-syntax imports. Next, expressions are compiled from the right-hand side of all define-syntax \ndeclarations us\u00ading compile-expr (de.ned below) with phase 1; if any macro uses state-modifying primitives, \nthe store is updated in the process. The store is then updated with the resulting syntax-transformer \nbind\u00adings, and all expressions from right-hand side of define declara\u00adtions are compiled using compile-expr \nwith phase 0. Finally, both sets of compiled expressions are collected into a compiled module. Expression \nCompilation. An expression is parsed, expanded, and compiled at once with a recursive compile-expr function: \ncompile-expr : s-exp \u00d7 p \u00d7 E \u00d7 S . c-exp \u00d7 S This function compiles the source expression s-exp for execution \nin phase p. The environment E maps identi.ers to locally bound syntax transformers, and the store S contains \ncompile-time state, as well as bindings for invoked and visited modules (e.g., bindings for imported \nsyntax). The result of compilation is a pair consisting of a compiled expression and an updated store. \nFigure 3 de.nes [[s-exp]]p which is shorthand for applying E,S , compile-expr to s-exp, p, E, and S. \nThe result is an expression store pair (c-exp,S). In the process of parsing an s-exp, compile\u00adexpr adds \nmark and subst annotations to maintain lexical scope. A mark annotation effectively records whether a \nbinding was intro\u00adduced by a macro, so that it does not accidentally capture variables at the macro-use \nsite. A subst annotation effectively a-renames an identi.er, so that variables introduced by a macro \nare not acci\u00addentally captured at the macro-use site. (The original source must have no such annotations.) \nFor more information about mark and subst, see Dybvig et al. [8]. Parsing does not add new reqd annotations. \nInstead, the compile\u00admodule function (de.ned above) records module bindings with reqd annotations before \npassing body expressions to compile-expr. The main step in compiling an expression (stx0 s-exp1 ... s-expn) \nis to determine the meaning of stx0 based on its lexical information, the environment, the store, and \nthe current phase. For example, if stx0 resolves to the free symbol lambda, then the expression is compiled \nas a function. If stx0 resolves to an identi.er bound to a macro transformer, then the transformer function \nis applied to (lit (stx0 s-exp1 ... s-expn)) to produce a new s-exp and updated Syntax objects: stx \n::= id | (mark stx mrk) | (subst stx stxid p) | (reqd stx mod id p) mrk ::= a mark p ::= a phase number \nThe compile-expr function: [[(stx0 s-exp0 s-exp1... s-expn)]]Ep ,S0 = ((app c-exp0 ... c-expn),Sn+1) \nif resolvep(stx0) = (app,free) where (c-expi,Si+1) =[[s-expi]]Ep ,Si [[(stx0(stx) s-exp)]]Ep ,S = ((lambda \n(id) c-exp),S') ' if resolvep(stx0) = (lambda,free) where s-exp= subst(s-exp, stx, id, p) and (c-exp,S') \n=[[s-exp']]Ep ,S and id is fresh [[(stx0(stx s-exp1) s-exp2)]] p = [[s-exp2']] p E,SE.{id=val},S'' ' \nif resolvep(stx0) = (let-syntax,free) where (c-exp1,S') =[[s-exp1]]0p/,+S 1 ' and (val,S'') = eval(c-exp1, \nS ') ' and s-exp2 = subst(s-exp2, stx, id, p) and id is fresh [[(stx0 stx s-exp0)]] p = [[s-exp3]] p \nE,SE,S' if resolvep(stx0) = (macro-app,free) where s-exp1 = mark(s-exp0, mrk) and (resolvep(stx) = (id,lexical \np) and ((lit s-exp2),S') = and E(id) = val) eval((app val (lit s-exp1)), S) or (resolvep(stx) = (mod.id, \nmodule) and s-exp3 = mark(s-exp2, mrk) and S(mod.id.p) = (val,macro)) and mrk is fresh [[(stx0 s-exp)]]Ep \n,S = ((lit s-exp),S) if resolvep(stx0) = (quote-syntax,free) [[stx]]Ep ,S = (id,S) if resolvep(stx) = \n(id,lexical p) and id . dom(E) [[stx]]Ep ,S = (mod.id.p,S) if resolvep(stx) = (mod.id,module) and S(mod.id.p) \n= (val,macro) [[prim]]Ep ,S = ((lit prim),S) Recording substitutions and marks: subst(stx1, stx2, id, \np) = (subst stx1 stx2 id p) subst(prim, stx2, id, p) = prim subst((stx1... stxn), stx, id, p) = (stx'1... \nstx') where stx'= subst(stxi, stx, id, p) for i . [1,n] ni mark(stx, mrk) = (mark stx mrk) ... Identi.er \nresolution: resolvep(id) = (id,free) resolvep((mark stx mrk)) = resolvep(stx) . ' . (id,lexical p) \nif marksof(stx1) = marksof(stx2) resolvep((subst stx1 stx2 id p')) = and resolve0(stx1) = resolve0(stx2) \n. resolvep(stx1) otherwise . . (mod.id,module) if resolvep(stx) = (id,free) ' resolvep((reqd stx mod \nid p')) = and p = p . resolvep(stx) otherwise marksof(id) = 0/ marksof((mark stx mrk)) = . marksof(stx) \n. is exclusive union {mrk}\u00d7where \u00d7marksof((subst stx1 stx2 id p)) = marksof(stx1) marksof((reqd stx mod \nid p)) = marksof(stx) Figure 3. Expression parsing, expansion, and compilation store; the new s-exp and \nstore are sent back into the compile-expr function. If stx0 resolves to the free symbol let-syntax, then \na sub-expression is sent to compile-expr with phase p + 1, the result is bound in E, and the body sub-expression \nis compiled with the new environment in phase p. Module Invocation. All modules are compiled as if they \nwill be invoked in phase 0 (the phase shows up in literals), but a require-for-syntaxed module must be \ninvoked in phase 1, a require-for-syntaxed module of a require-for-syntaxed module must be invoked in \nphase 2, and so on. Thus, invoca\u00adtion requires a phase-shifting operation on compiled expressions; ((c-exp))p \nshifts c-exp by p phases. The visit function augments a store by executing the syntax portion of a module \nfor some phase p, given the collection of compiled modules so far: visit : mod \u00d7 p \u00d7 cdecl-list \u00d7 S . \nS Every require import in mod triggers a recursive visit in phase p. Every require-for-syntax import \nin mode triggers an invoke in phase p + 1, as well as a recursive visit in phase p + 1. Finally, each \nphase-1 expression in mod is shifted by p and evaluated, and the store is updated with syntax bindings \nthat name the module, the de.ned identi.er, and the phase p. The invoke function performs the corresponding \naction for the run\u00adtime part of a module: invoke : mod \u00d7 p \u00d7 cdecl-list \u00d7 S . S Every require import \nin mod triggers a recursive invoke in phase p. Afterwards, each phase-0 expression in mod is shifted \nby p and evaluated, and store is updated with variable bindings that name the module, the de.ned identi.er, \nand the phase p.For invoke, require-for-syntax imports are ignored, and visit is never used. Program \nExecution. Executing a program means .rst compiling each of the program s modules, one by one, with compile-module. \nFor each compilation, modules already compiled are available as imports. After compiling all modules, \nthe main module designated by (invoke mod id) is executed with invoke in a fresh initial store. The result \nof the the program is the value of mod.id.0 in the store. Formal Results. The formal model makes certain \nseparation prop\u00aderties immediately apparent: 1. State modi.cations during module compilations do not \naffect each other or the .nal execution, since module compilation neither consumes nor produces a store. \n 2. All phase 1 code can be stripped before execution of the desig\u00adnated main module with no effect on \nthe result, since applying invoke with phase 0 executes only phase 0 code.   6 Related Work Lexically \nscoped macros. Kohlbecker et al. s de.nition of hy\u00adgienic macros [15] initiated a chain of research in \nScheme macros, leading to the syntax-case system of Dybvig et al. [8]. Notable points along the way include \nBawden and Rees s syntactic clo\u00adsures [2] and Clinger and Rees s lexically scoped, pattern-matching macros \n[4]. Our work builds directly on the syntax-case model. In the origi\u00adnal model, a local phase separation \nexists via let-syntax, though the model does not explain how out-of-phase errors are detected and reported. \nOur model .lls this small gap while generalizing the model to cover module phases. Lexical macro systems \nare not restricted to Lisp dialects. For ex\u00adample, Maya [1] extends Java with support for lexically scoped \nsyntax transformers. Maya transformers are implemented in Maya, which means that they can perform arbitrary \ncomputation, and that they can be implemented in an extended variant of Maya. Macro\u00adgenerating macros \nare limited, however, by the separation of trans\u00adformer de.nition (as a normal Java class) from transformer \nuse (through a use clause names an already-compiled class) to achieve a phase separation. Module systems. \nCurtis and Rauen s module system for Scheme [5] allows modules to export both variables and syntax, but \nsyntax transformers must be implemented in plain Scheme. Syn\u00adtax transformers may keep state, and the \nrestrictions on such state (in terms of what is guaranteed to work) seem to match ours, but Curtis and \nRauen provide no information on how to enforce the re\u00adstrictions. The Scheme48 module system [20] supports \nthe compile-time im\u00adport of variables for macro transformers by wrapping an import dec\u00adlaration with \nfor-syntax; such compile-time imports bind only compile-time code within the module. However, templated \niden\u00adti.ers in macros appear to be statically assigned a run-time status, which causes problems for macro-de.ning \nmacros that are de.ned within a module. Furthermore, a module is instantiated only once within a session, \neven if it is used in multiple phases or for compil\u00ading multiple modules in the session, which means \nthat state can be preserved accidentally across module compilations. Dybvig and Waddell [25] integrate \nlexically scoped macros with a module construct for Chez Scheme [7], but they do not distinguish phases \nfor module imports; programmers must manage the differ\u00adence between compilation and interactive evaluation \nwith load, visit, and eval-when. Unlike MzScheme s module form, the Chez module form works in any de.nition \nposition. (It can be im\u00adplemented as a macro in MzScheme, except for the import-only form that hides \nlexical bindings.) Dylan [22] provides pattern-matching macros that respect module scope, but macros \ncannot perform arbitrary computation. Organizing language towers. Queinnec [19] de.nes a protocol for \nmacro expansion that supports a tower of languages. The proto\u00adcol is independent of the macro-de.nition \nlanguage and expansion function. MzScheme essentially automates the protocol through the module language, \nwhile integrating lexically scoped macros into the tower. Other Work. Staged evaluation languages, such \nas .. [6] and MetaML [16], support programs that generate and combine pro\u00adgram fragments, much like a \nmacro transformer. Such program\u00admanipulating programs serve a different purpose than macros, be\u00adcause \nthey do not extend the syntax of a language processed by compilers and other programming tools. Staged \nevaluation can be a platform for constructing macro systems, however, as exempli.ed by the compilation \nof MacroML [11] to MetaML. Languages that support dynamic compilation, such as C [18], are similar to \nstaged-evaluation languages, but that they have no phase distinction. Dynamically generated and compiled \ncode is meant to be executed along with the program-manipulating host code. 7 Conclusion A language \nthat allows macro transformers to perform arbitrary computation must enforce a separation between computations: \nrun time versus compile time, as well as the compile time of one module versus the compile time of another. \nWithout an enforced separation, the meaning of a code fragment can depend on the order in which code \nis compiled and executed. At best, programmers must work hard to manage the dependencies. At worst, and \nmore commonly, the dependencies are too subtle for programmers to manage cor\u00adrectly, and they cannot \nexpect predictable results when combining libraries in new ways or when using new programming tools. \nThe MzScheme macro system enforces the separation of run-time and compile-time computations. This enforcement \ndoes not re\u00adstrict the kinds of macros that can be implemented. Instead, MzScheme enables the implementation \nof sophisticated, cooper\u00adating syntactic extensions through well-de.ned channels of com\u00admunication. We \nhave demonstrated this expressiveness through a small define-record and record-case example, and the \nsame techniques apply for implementing other constructs: classes for object-oriented programming, component \nde.nition and linking constructs, lex and yacc forms, and forms for static typing. From the Scheme programmer \ns perspective, MzScheme modules and macros work in the obvious way for most tasks. Indeed, users report \na short learning curve for putting module to work. More complex tasks require careful reasoning, and \nfuture work remains in providing precise and clear feedback for phase violations. Most important, however, \nis that phase violations never pass undetected. In practical terms, this means that extension producers \ncan be con\u00ad.dent of their extensions, and extension consumers spend no time wrestling with command-line \n.ags or con.guration parameters. Acknowledgments: I would like to thank Robby Findler, Matthias Felleisen, \nand the rest of PLT for the discussions that launched and re.ned this work. Thanks to Mike Sperber for \nmany module-related discussions. Thanks to Wilson Hsieh, Eric Eide, Alastair Reid, and Jason Baker for \nfeedback on the paper. 8 References [1] J. Baker and W. C. Hsieh. Maya: Multiple-dispatch syntax extension \nin Java. In Proc. ACM Conference on Programming Language Design and Implementation, pages 270 281, June \n2002. [2] A. Bawden and J. Rees. Syntactic closures. In Proc. ACM Conference on Lisp and Functional Programming, \npages 86 95, July 1988. [3] H. Bromley. Lisp Lore: A Guide to Programming the Lisp Machine. Kluwer Academic \nPublishers, 1986. [4] W. Clinger and J. Rees. Macros that work. In Proc. ACM Symposium on Principles \nof Programming Languages, pages 155 162, Jan. 1991. [5] P. Curtis and J. Rauen. A module system for Scheme. \nIn Proc. ACM Conference on Lisp and Functional Programming, pages 13 28, 1990. [6] R. Davies and F. Pfenning. \nA modal analysis of staged com\u00adputation. In Proc. ACM Symposium on Principles of Program\u00adming Languages, \npages 258 270, Jan. 1996. [7] R. K. Dybvig. Chez Scheme User s Guide. Cadence Research Systems, 1998. \n[8] R. K. Dybvig, R. Hieb, and C. Bruggeman. Syntactic abstrac\u00adtion in Scheme. Lisp and Symbolic Computation, \n5(4):295 326, 1993. [9] M. Flatt and M. Felleisen. Units: Cool modules for HOT lan\u00adguages. In Proc. ACM \nConference on Programming Language Design and Implementation, pages 236 248, June 1998. [10] D. P. Friedman, \nM. Wand, and C. P. Haynes. Essentials of Programming Languages. The MIT Press, Cambridge, Mas\u00adsachusetts, \n2001. [11] S. Ganz, A. Sabry, and W. Taha. Macros as multi-stage computations: Type-safe, generative, \nbinding macros in MacroML. In Proc. ACM International Conference on Func\u00adtional Programming, pages 74 \n85, Sept. 2001. [12] T. P. Hart and T. G. Evans. Notes on implementing lisp for the m-460 computer. In \nE. C. Berkeley and D. G. Bowbrow, editors, The Programming language LISP: Its Operation and Applications, \npages 191 203. MIT Press, 1964. [13] R. Kelsey. SRFI 19: De.ning record types, 1999. http://srfi.schemers.org/srfi-9/. \n[14] R. Kelsey, W. Clinger, and J. Rees (Eds.). The revised5 re\u00adport on the algorithmic language Scheme. \nACM SIGPLAN Notices, 33(9), Sept. 1998. [15] E. Kohlbecker, D. P. Friedman, M. Felleisen, and B. Duba. \nHygienic macro expansion. In Proc. ACM Conference on Lisp and Functional Programming, pages 151 181, \nAug. 1986. [16] E. Moggi, W. Taha, Z. El-Abidine Benaissa, and T. Sheard. An idealized MetaML: Simpler, \nand more expressive. In Proc. European Symposium on Programming, volume 1576 of Lec\u00adture Notes in Computer \nScience, pages 193 207. Springer-Verlag, Apr. 1999. [17] D. A. Moon. MACLISP Reference Manual. MIT Press, \n1974. [18] M. Poletto, W. C. Hsieh, D. R. Engler, and M. F. Kaashoek. C and tcc: a language and compiler \nfor dynamic code gener\u00adation. ACM Transactions on Computing Systems, 21(2):324 369, Mar. 1999. [19] C. \nQueinnec. Macroexpansion re.ective tower. In Proc. Re\u00ad.ections Conference, pages 93 194, Apr. 1996. [20] \nJ. Rees. Another module system for Scheme, 1994. Scheme48 documentation. [21] M. Serrano. Bigloo: A practical \nScheme compiler , 2002. [22] A. Shalit. The Dylan Reference Manual. Addison-Wesley, 1996. [23] G. L. \nSteele Jr. Common Lisp: The Language. Digital Press, second edition, 1990. [24] G. L. Steele, Jr. and \nG. J. Sussman. The revised report on SCHEME: A dialect of LISP. Technical Report 452, MIT, Jan. 1978. \n[25] O. Waddell and R. K. Dybvig. Extending the scope of syn\u00adtactic abstraction. In Proc. ACM Symposium \non Principles of Programming Languages, pages 203 213, Jan. 1999. [26] D. Weise and R. F. Crew. Programmable \nsyntax macros. In Proc. ACM Conference on Programming Language Design and Implementation, pages 156 165, \nJune 1993. [27] A. K. Wright. Pattern Matching for Scheme, Mar. 1996.   \n\t\t\t", "proc_id": "581478", "abstract": "Many macro systems, especially for Lisp and Scheme, allow macro transformers to perform general computation. Moreover, the language for implementing compile-time macro transformers is usually the same as the language for implementing run-time functions. As a side effect of this sharing, implementations tend to allow the mingling of compile-time values and run-time values, as well as values from separate compilations. Such mingling breaks programming tools that must parse code without executing it. Macro implementors avoid harmful mingling by obeying certain macro-definition protocols and by inserting phase-distinguishing annotations into the code. However, the annotations are fragile, the protocols are not enforced, and programmers can only reason about the result in terms of the compiler's implementation. MzScheme---the language of the PLT Scheme tool suite---addresses the problem through a macro system that separates compilation without sacrificing the expressiveness of macros.", "authors": [{"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "University of Utah", "person_id": "PP39045354", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/581478.581486", "year": "2002", "article_id": "581486", "conference": "ICFP", "title": "Composable and compilable macros:: you want it when?", "url": "http://dl.acm.org/citation.cfm?id=581486"}