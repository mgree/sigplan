{"article_publication_date": "09-17-2002", "fulltext": "\n Type Classes With More Higher-Order Polymorphism Matthias Neubauer Peter Thiemann Universit\u00a8 at Freiburg \n{neubauer,thiemann}@informatik.uni-freiburg.de Abstract We propose an extension of Haskell s type class \nsystem with lambda abstractions in the type language. Type inference for our extension relies on a novel \nconstrained uni.cation procedure called guided higher-order uni.cation. This uni.cation procedure is \nmore general than Haskell s kind-preserving uni.cation but less powerful than full higher-order uni.cation. \nThe main technical result is the soundness and completeness of the uni.cation rules for the fragment \nof lambda calculus that we admit on the type level.  Categories and Subject Descriptors D.3.2 [Programming \nLanguages]: Language Classi.cations Applicative (functional) languages; D.3.3 [Programming Lan\u00adguages]: \nLanguage Constructs and Features Polymorphism; F.3.3 [Logics and Meanings of Programs]: Studies of Program \nCon\u00adstructs Type Structure General Terms Languages, Theory  Keywords type classes, higher-order uni.cation, \ntype inference, Haskell 1 Introduction Haskell s type system is among the most powerful type systems \nimplemented in a programming language. This is mostly due to Haskell s type class system which supports \nparametric overload\u00ading on type constructors and thus higher-order polymorphism [12]. These features \nhave found many applications in everyday program\u00adming problems. Abstract concepts like monads and functors \ncan be Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n02, October 4-6, 2002, Pittsburgh, Pennsylvania, USA. Copyright 2002 ACM 1-58113-487-8/02/0010 ...$5.00 \nconveniently expressed using type classes of higher-order construc\u00adtors. To retain a decidable type inference \nalgorithm, Haskell s type language is restricted to a combinator language, i.e., there are only type \nconstructors and variables, but no abstractions. However, there are a number of interesting examples, \nwhere the lack of lambda abstraction in the type language is limiting and leads to awkward programming \nexercises. Hence, we propose to extend Haskell s type language with a (suit\u00adably restricted) notion of \nlambda abstraction. The main prob\u00adlems here are to remain downwards compatible with Haskell98 and to \nkeep type inference decidable. If we were to add un\u00adrestricted lambda abstraction, then type inference \nwould have to rely on uni.cation for simply-typed lambda terms (higher-order uni.cation [11]). There \nare well-known decidable subclasses of this problem, for instance, pattern uni.cation [20], generalizations \nthereof [35], and bounded higher-order uni.cation [36]. These sub\u00adclasses are used for implementing logic-based \nprogramming lan\u00adguages (.Prolog [25], Elf [33] and its descendants) and theorem provers (most notably \nIsabelle [30]). Unfortunately, the subclasses mentioned above are not really suited for type inference \nas we will demonstrate in Section 1.5. Technically, the paper reports the following results. We de.ne \na restricted simply-typed lambda calculus .GHOU suitable as a type language for extended Haskell.  We \nde.ne a Henkin model for .GHOU and prove that every function type in the model is inhabited only by injective \nfunc\u00adtions. This is required for downwards compatibility.  We de.ne guided higher-order uni.cation and \nprove the soundness and completeness of the uni.cation rules. Unfor\u00adtunately, we currently have to rely \non a heuristic to guarantee termination of this procedure.  In the next subsections, we exhibit some \nprogramming problems that motivate the introduction of lambda abstraction into the type language. Then, \nwe discuss the problems of using existing higher\u00adorder uni.cation procedures (which are too non-deterministic), \nwe recall Haskell s approach, and explain our approach informally. Section 2 starts the formal treatment. \nAfter introducing some no\u00adtation, we de.ne a syntax for our language (Section 2.2) and a se\u00admantics for \n.GHOU, the type-level language (Section 2.3), based on sets of injective functions. After stating some \nproperties of .GHOU, we de.ne guided higher-order uni.cation in Section 2.4 and prove soundness and completeness \nof the rules. We brie.y discuss ter\u00admination issues (Section 2.5) and sketch an extension of Milner s \nalgorithm W to our system in Section 2.6. Section 3 evaluates our proposal by reviewing the motivating \nexamples and by discussing some limitations. Finally, we discuss related work (Section 4) and conclude. \nWe have completed a prototype implementation and have per\u00adformed some preliminary experiments with it. \nIn particular, all ex\u00adamples presented in this paper have been checked. The implemen\u00adtation builds on \nJones s work on Typing Haskell in Haskell [16]. The implementation of higher-order uni.cation is inspired \nby Nip\u00adkow s paper [27]. Throughout, we assume familiarity with Haskell [9]. We always refer to Haskell98 \nas speci.ed in the standard, not to the many ex\u00adtensions present in Haskell implementations. 1.1 Functors \nThe type class Functor expresses the essence of the categorical concept of a functor by specifying the \naction of the functor on a function of type a->b.If f is a functor, then the map function for f, called \nfmap, transforms a function of type a->binto a function of type fa->f b. The following type class de.nition \nformalizes this. class Functor f where fmap:: (a-> b) ->(f a ->f b) Many one-parameter type constructors \nare in fact functors, for ex\u00adample, the type constructor [] that maps a type a to the type [a] of lists \nwith elements of type aor the type constructor Maybethat maps a type a to the type Maybe a with elements \nNothing and Just x, for some x of type a. The following instance declarations illustrate the map functions \nfor the [] and Maybe functors. instance Functor [] where fmaph[] =[] fmaph (x:xs)= hx:gxs instance \nFunctor Maybe where fmap h Nothing = Nothing fmap h (Just x) = Just (h x) The concept of a functor \nhas much in common with the usual notion of a map between sets, only at a higher level. One commonality \nis the fact that there is an identity functor that maps each type to itself and  the composition of \ntwo functors is again a functor.  Unfortunately, these concepts are not readily available in Haskell. \nIn both cases, additional data structures have to be introduced that provide names for the identity functor \nand for the composition op\u00aderator. Here is a suitable de.nition for the identity functor. dataId x =Id \nx instance Functor Id where fmaph (Idx) = Id(h x) The composition operator requires another special \nfeature of Haskell. Type variables may not just range over types, but also over functions on types, functions \non functions on types, and so on. Hence, the following de.nitions make sense. dataComp fg x = Comp(f \n(gx)) instance (Functor f, Functor g) => Functor (Comp f g) where fmap h (Comp fgx) = Comp (fmap (fmap \nh) fgx) While it is possible to write functions with composable functors and functor identify using \nthese de.nitions, it seems rather awkward to be forced to provide names for something as simple as the \nidentity function or function composition. Life would be much easier for the poor programmer if we could \nde.ne similar instances of functor, but without having to introduce the data types Id and Comp1. If we \nwere to make a wish, then we would rather write the following code: instance Functor (. x.x) where fmaph \nx =h x instance (Functor f, Functor g) => Functor (. x.f (g x)) where fmap h fgx = fmap (fmap h) fgx \nThat is, instead of using a named identity function and a named composition operator, we employ anonymous \nfunctions, i.e., lambda expressions in the type language. 1.2 Contravariant Functors Once we have accepted \nthe use of lambdas in the type language, we can readily identify further applications. For example, the \nfunc\u00adtion type constructor -> is a functor in its second (result) parameter and this fact is easily expressed \nas a standard instance declaration (where (->) is the pre.x notation for the in.x operator ->): instance \nFunctor ((->) a) where fmaph g =h . g However, it is well-known that -> is a contravariant functor (where \nthe action of f on a mapping a-> b exchanges domain and range) in its .rst argument. Of course, this \nconcept can be captured in a type class, as well. class OpFunctor g where opmap:: (a-> b)-> (f b-> f \na) Unfortunately, in Haskell it is not possible to make the function type constructor -> an instance \nof OpFunctor because it is not possible to abstract over the .rst parameter of ->. Given lambda expressions \nin the type language, this turns out to be easy. instance OpFunctor (. x.x -> a) where opmaph g=g.h \n 1.3 A Real-World Example: WASH/CGI Before the reader is tempted to rate this motivation as an academic \nexercise, here is a real-world example, taken from our work on WASH/CGI [37, 39], an embedded domain-speci.c \nlanguage for server-side Web scripting. In this context, we need to perform a task which is known as \nkind lifting in the generic programming community. Roughly spoken, the essence of lifting is to pull \ntype parameters out from contexts. Among other features, WASH/CGI provides a means to construct typed \ninteractions as follows. The programmer constructs an HTML form by using the combinator inputField to \nconstruct typed input .elds. Another combinator, submit, speci.es the ac\u00adtion taken when the form is \nsubmitted (via the submit button). Here is an example: demo = run (ask (standardPage \"Demo\" (makeForm \n$ do text \"Enter a number \" 1Besides being awkward they also impose a performance penalty. f1 <-inputField \n(fieldSIZE 10) submit f1 showIt (fieldVALUE \"Echo\")))) showIt :: InputField Int VALID -> CGI () showIt \nf1 = let n1 = value f1 in htell $ standardPage \"Input Echo\" (text (show n1)) The important point here \nis that the evaluation of inputField (fieldSIZE 10) creates a handle, f1, to an input .eld of type InputField \nInt INVALID. The submit combinator, used at type submit :: InputField Int INVALID -> (InputField Int \nVALID -> CGI ()) -> HTMLField () validates the input .eld (it checks that the input .eld is present \nand contains a number) and passes it to the function, showIt, that pro\u00adcesses the form once it is submitted. \nSince there are different kinds of input .elds (pushbuttons, selec\u00adtions boxes, etc.), the combinator \nsubmit is overloaded as follows: submit :: InputHandle h => h INVALID -> (h VALID -> CGI ()) -> HTMLField \n() where the class InputHandle has instances for the input .elds listed above. For example instance \nInputHandle (InputField a) where ... In the class constraint InputHandle h, the variable h ranges over \ntype constructors of kind *->*. This is also evident in the in\u00adstance declaration where InputField is \nonly applied to one type argument (a) instead of two, as it is declared. Now consider the case where \nwe want to pass a pair of handles to the processing function: submit (f1, f2) actionOnSubmit ... Unfortunately, \nthis results in a strange type error message with Haskell98. As a workaround, the programmer2 must invent \na suitable lifted datatype and must make it an instance of the InputHandle class: dataF2 a bx = F2 (ax) \n(bx) instance (InputHandle a, InputHandle b) => InputHandle (F2 a b) where ... The reason for having \nto invent F2 is as follows. To apply submit to (f1, f2) it is necessary to unify the argument type of \nsubmit with the type of (f1, f2): submit :: InputHandle h =>  h INVALID -> (h VALID -> CGI ()) -> HTMLField \n() (f1, f2) :: (InputField Int INVALID, InputField Char INVALID) Hence, the type checker must solve \nthe equation h INVALID =?= (InputField Int INVALID, InputField Char INVALID) This equation cannot be \nsolved by .rst-order uni.cation (which is the basis of Haskell s type inference). In this situation there \nare (at least) two remedies. Either, we perform kind lifting explicitly by introducing the F2 type shown \nabove. Or we might consider using higher-order uni.cation in the type checker. In fact, higher-order \nuni.cation can proceed by substituting h . . . x(h1 x, h2 x), with h1and h2fresh type variables, which \nis called an imitation step 2. . . or rather the library designer. in higher-order uni.cation. Applying \nthis substitution and simpli\u00adfying (. x.(h1 x, h2 x)) INVALID leads to (h1 INVALID, h2 INVALID) =?= (InputField \nInt INVALID, InputField Char INVALID) This can be decomposed to h1 INVALID =?= InputField Int INVALID \nh2 INVALID =?= InputField Char INVALID Again by imitation, we substitute h1 . . . xInputField (h11 x) \n(h12 x), again with h11 and h12 fresh type variables, in the .rst equation and obtain InputField (h11 \nINVALID) (h12 INVALID) =?= InputField Int INVALID We conclude by two further standard steps in higher-order \nuni.ca\u00adtion: imitation h11 . . . xInt and projection h12 . . x.x, which completely reduce the equation. \nThe second equation is re\u00adduced analogously. Analogous problems arise when we try to pass no input handles \nto the actionOnSubmit or a list of input handles: submit () actionOnSubmit submit [f1, f2] actionOnSubmit \n They may be addressed in an analogous manner as for pairs: either by introducing explicit lifting types \nF0 and FL (as it is done in the current version of WASH/CGI) or by using higher-order uni.cation in the \ntype checker. We feel that the introduction of explicit lifting types, as forced by Haskell, is particularly \ninappropriate for an embedded domain\u00adspeci.c language like WASH/CGI. Experts can program around this \nproblem by introducing specialized wrapper data types like F2 above and enclosing input .elds into suitable \nwrappers. However, we argue that this is inconvenient, leads to obscure programs, and is hard to explain \nto non-expert users, which are the intended cus\u00adtomers of WASH/CGI. Using our proposed extension, there \nis much less to explain because it is possible to directly use Haskell s stan\u00addard data structures, like \npairs and lists.  1.4 What is Higher-Order Uni.cation Anyway? In the preceding subsections we have already \nhinted at using higher\u00adorder uni.cation [11] in the type checker. To be able to discuss the pros and \ncons of using higher-order uni.cation for type check\u00ading purposes, we give a short and rather informal \nexplanation what higher-order uni.cation is in this subsection. The comparison to the better known notion \nof .rst-order uni.ca\u00adtion might be helpful for some readers: in .rst-order uni.cation, the underlying \nformal languages are .rst-order terms over a given signature of function symbols and a set of .rst-order \nvariables. A uni.cation problem is a pair of terms, and its solution is a substitu\u00adtion that makes both \nterms syntactically equal. In contrast to that, the language considered for higher-order uni.ca\u00adtion \nis the simply-typed .-calculus with constants. Again, a uni.ca\u00adtion problem is a pair of terms, and a \nsolution of it is a substitution of the (free) variables such that the two resulting terms both have \nthe same normal form. The difference to .rst-order uni.cation is clear cut: substituted functions do \nnot compose only from given func\u00adtion symbols, but can consist of arbitrarily complex anonymous .-expressions. \nSince .-terms are usually compared with respect to an equational theory, we likewise search for solutions \nthat result in equal terms that is, for terms with the same normal form. Although higher-order uni.cation \nis undecidable Hilbert s tenth problem can be reduced to it [4], there exist an algorithm, known as Huet \ns algorithm [11], that is a sound and complete semi\u00addecision procedure for higher-order uni.cation problems. \nIn the following we will brie.y sketch the algorithm formulated as a set of transformation rules working \non .nite sets of term equations. For each step an applicable rule is chosen to transform the actual set \nof equations E into a new one. We silently assume that terms occurring in equations are always in long \n\u00df.-normal form that is, a term is .rst reduced to its normal form using the usual \u00df-reduction rules, \nand then .-expanded to exactly re.ect its type structure. The decision whether a rule is applicable to \nan equation is based on the nature of the head symbols of both terms. We call a term rigid if its head \nsymbol is a constant or a bound (universal) variable, and we call it .exible if its head symbol is a \nfree variable. In case one of the equations E is a .ex-.ex pair, the decomposition rule applies: . x1 \n... xm.c t1 ... tn =?= . x1 ... xm.c t1 ... tn decomposes into n different equations each pair of arguments \ncre\u00adates a new equation . x1 ... xm.t1 =?= . x1 ... xm.t1 , ... whereas bound variables as head symbol \nact similar to constants. In case the head symbols differ, the procedure fails immediately. There are \ntwo rules that cover .ex-rigid pairs. To match the rigid side, any substitution for the .ex variable \nmust eventually result in a term with the same head symbol as on the rigid side. There are two possibilities \nwhere this symbol may come from: .rst, the substitu\u00adtion for the free variable f may introduce the symbol \nitself this is called imitation. The equations E . x1 ... xk.f t1 ... tn =?= . x1 ... xk.c t1 ... tm \n, E are substituted by the preliminary solution for f f . . . x1 ... xnc (g1 x1 ... xn) ... (gm x1 ... \nxn), where g1, ..., gm are fresh variables, that are substituted later on. The other possibility is, \nthat the needed symbol comes from one of the arguments of f. The projection rule handles this case the \napplied substitution projects one of the arguments of f to the head position f . . . x1 ... xnxi (g1 \nx1 ... xn) ... (gj x1 ... xn) whereas the number of arguments of xi is determined by its type. Clearly, \nunless the kind of f is * there is a non-deterministic choice for each .ex-rigid pair as to which rule \nto apply. Provided that there exists at least one constant cof kind *, we know that a .ex-.ex pair always \nhas at least one solution: an equation . x1 ... xk.f t1 ... tn =?= . x1 ... xk.g t1 ... tm can be solved \nby substituting f . . . x1...xnc, g . . . x1...xmc. Hence, only the .rst three kind of rules are successively \napplied until only .ex-.ex pairs remain. 1.5 Why Higher-Order Uni.cation Won t Work We argue that full \nhigher-order uni.cation (besides being undecid\u00adable) introduces too much non-determinism to produce useful \nre\u00adsults. On the other hand, pattern uni.cation [20], which is decid\u00adable and unitary, is too restrictive \nfor our intended applications. Our conclusion is that we need the power of higher-order uni.cation, but \nwe must restrict the non-determinism by providing guidance to the algorithm. Hence, we set out to investigate \nguided higher-order uni.cation. To exhibit the problems of higher-order uni.cation, let us recon\u00adsider \nthe example uni.cation of Subsection 1.3. After a number of simpli.cation steps (imitation, decomposition, \nand imitation, again) we arrived at the equations h11 INVALID =?= Int h12 INVALID =?= INVALID which \nwe solved by the imitation h11 . . . xInt and the projec\u00adtion h12 . . x.x (in this case, imitation would \nalso work: h11 . . x.INVALID). Now suppose we start from h a =?= (InputField Int INVALID, InputField \nChar INVALID) where a is a type variable. All the steps of the previous subsection go through, up to \nthe point where above equations are reached: h11 a =?= Int h12 a =?= INVALID At this point, the desired \nchoice is to unify awith INVALIDand have h11 ignore its argument, using the imitation h11 . . . xInt \nand the projection h12 . . x.x. However, this choice is only one out of three possible choices (choosing \nprojection for both equations fails immediately) and from the point of view of the uni.cation algorithm, \nall choices look equally plausible. Hence, the algorithm has no way of telling if imitation or projection \nis desired.  To see why higher-order patterns are too restrictive for our pur\u00adposes, it is suf.cient \nto consider the term h INVALID that occurs in the above example. In this term the free variable h has \na constant argument INVALID. However, in a pattern (as well as in a relaxed pattern [35]), the arguments \nof free variables are restricted to dis\u00adtinct bound variables, as in . x.h x. 1.6 What Haskell Does \nLet s have a look at the de.nition of Haskell for a hint at what can be done. By ruling out lambdas from \nthe type language, Haskell reduces the uni.cation problem to a .rst-order one. That is: In case of a \n.ex-rigid pair, Haskell always chooses imitation.  If the kind of the .exible head variable does not \nmatch the kind of the constructor, then a pre.x of suitable kind of the constructor term is substituted \nfor the head variable. If no such pre.x exists, the uni.cation fails.  Flex-.ex pairs are treated in \nthe same way as .ex-rigid pairs.  Decomposition applies also in the .ex-.ex case.  1.7 Our Proposal \nOur approach is to restrict the syntax of lambda terms so that pro\u00adjection terms are ruled out. Hence, \nthe uni.cation algorithm can S,Gnk0 a : G(a) S,Gnk0 c : S(c) S,G nk0 t1: .2 ..1 S,G nk0 t2: .2 S,G nk0 \nt1 t2: .1 Figure 1. Kinding Judgement always choose imitation in the case of a .ex-rigid pair. We further \nrestrict the calculus to Church s .I terms, i.e, terms where lambda abstraction can only abstract variables \nthat occur free. This restric\u00adtion enables us to deal with .ex-.ex pairs almost in the same way as Haskell \ndoes: decomposition is applicable to .ex-.ex pairs with identical head variable and the imitation-style \ntreatment of uncon\u00adstrained .ex-.ex pairs is also sound. It remains to consider the case of .ex-.ex and \n.ex-rigid pairs where a head variable is restricted by a type class constraint. In the thus restricted \n.ex-rigid case, we do not use the general substitution as in Huet s imitation rule, but rather the instance \ndeclaration for the predicate. This way, we avoid subsequent choices between imita\u00adtion and projection \nby simply taking them in the instance declara\u00adtion. Flex-.ex pairs, where the restrictions on the head \nvariables are different, are not simpli.ed on the spot but rather deferred and kept as constraints (as \ncustomary in higher-order uni.cation). This deferral departs from Haskell s practice (and thus leads \nto different inferred types) but it is necessary because the instance substitution for the restricted \nhead variable cannot be chosen without the guid\u00adance of a rigid term. At program level, we expect that \nall such .ex-.ex constraints are resolved (or give rise to typing errors) be\u00adcause top-level programs \nare usually not polymorphic. Unresolved .ex-.ex constraints at this point give rise to unresolved overloading \nerrors.  2 The Formal Type System Before developing the formal system, we .x some notation. We write \nxn = x1x2 ...xn to abbreviate lists of syntactic phrases. Fur\u00adthermore, t(tn)= tt1t2 ...tn is n-fold \nnested function application, and .n . . is the corresponding kind .1 . .2 . \u00b7\u00b7\u00b7 . ..For lambda calculus, \nwe employ the standard notation and de.nitions of Barendregt [1]: FV(t) for the free variables, =for \nsyntactic iden\u00adtity. We employ Barendregt s variable convention. Functions are total set-theoretic functions \nunless otherwise noted and A . B denotes the set of such functions between sets A and B. We write . x.e \nfor the function {(x,e) |x . A}.A .B. A .nal note on our notation for variables and constructors (con\u00adstants): \nHaskell s constructors are capitalized and variables are written in lower case, but the standard in logic \nprogramming is ex\u00adactly the opposite. We decided to break both standards, by distin\u00adguishing the two \nsyntactic categories by name instead of by capi\u00adtalization. We let c range over constructors and a range \nover type variables. 2.1 Haskell s Type Language The type language of Haskell is generated by the grammar \nt ::= a | c |tt where a is a type variable, c is a constant (a type constructor), and tt is type application. \nThis language is itself typed according to the rules of the simply-typed lambda calculus. To avoid confusion, \ntypes of types are called kinds, where kinds are generated by the grammar . ::= *|. .. The kind * is \nthe only base kind and it categorizes all types. The kind .1 ..2 categorizes all (type) constructor functions \nthat map a constructor of kind .1 to one of kind .2. Figure 1 contains the well-known kinding rules. \nFor convenience, we use kinded type variables a. or f . from now on and drop the kind annotation if the \nkind is not important. With kinded variables, each term t has exactly one kind, which we write as KindS(t). \nSince uni.cation for this type language boils down to many\u00adsorted (syntactic) term uni.cation (aka kind-preserving \nuni.ca\u00adtion [12, 9]), it is possible to extend an ML-style type inference al\u00adgorithm to support higher-order \ntypes while retaining its soundness and completeness properties [12, 14]. In the general case, the exten\u00adsion \nwith higher-order polymorphism requires higher-order uni.ca\u00adtion in the type inference algorithm [32], \nwhich is undecidable [11].  2.2 Syntax Our type language extends Haskell s type language by a restricted \nnotion of lambda abstraction. These restrictions are suf.cient to re\u00adtain the most important features \nof kind-preserving uni.cation. We must distinguish between variables that may be substituted by uni\u00ad.cation \nand variables that are introduced in a lambda abstraction. Hence, we call variables which are substituted \nfor during uni.ca\u00adtion existential variables, ranged over by a, f ,g, and variables in\u00adtroduced by lambda \nabstraction universal variables, ranged over by x,y3. While existential variables always occur free in \na type term, universal variables may occur free or bound4. The judgement S,G nkt : . restricts the judgement \nfor nk0 toasetof lambda terms in normal form as shown in Figure 2. The restricted lambda terms in the \nthus de.ned set .GHOU have a head symbol that is either a constant or an existential variable, and universal \nvari\u00adables must always occur free in the corresponding lambda bodies (as in Church s .I-calculus). To \nstay inside this restricted language, we de.ne substitution so that it performs \u00df-reduction on-the-.y. \nSince this is standard practice in the literature on logical frameworks, we only give some illustra\u00adtive \ncases of the de.nition: substituting a lambda expression for an existential variable. The de.nition takes \nadvantage of the assump\u00adtion that .exible functions are fully .-expanded and that universal variables \nnever appear in function position. (.xm.t)[ f = . .yn.t] .xm.(t[ f..yn.t]) ( f (tn))[ f t[yn.tn] ..yn.t]= \n(c (tm))[ f c (tm[ f..yn.t]) . .yn.t]= x[ f = ..yn.t] x Due to the restriction on universal variables, \nsubstitution for them can never create a \u00df-redex. On top of this type language, a (constrained) type \nscheme has the form s ::= .ai.(P,E) .t 3Note the connection to uni.cation under mixed pre.x [21]. 4This \ndistinction is often avoided in treatments of higher-order uni.cation, by considering only terms in long \n\u00df.-normal form. Then free and bound variables are immediately apparent. (k-var-ex) S,G nkf : G( f ) \n(k-var-univ) S,G nkx : G(x) (k-const) S,G nkc : S(c) S,G nkt1: .2 ..1 S,G nkt2: .2 (k-app) if t1 is neither \nlambda nor universal variable S,G nkt1 t2: .1 S,G nkc : .n .* S,G{xm : .'}nk ti : .i m (k-lam-1) if \nxm .FV(tn) S,G nk .xm.c (tn) : .'.* m ' S,G nkf : .n .* S,G{xm : .}nk ti : .i m (k-lam-1) if xm .FV(tn) \nS,G nk .xm. f (tn) : .'.* m Figure 2. Kinding Judgement for Restricted Lambda-Calculus where t is a \ntype term of kind *, the ai are type variables, and (P,E) is a constrained uni.cation problem. That is \n P = {pk(gk)}is a set of class predicates (each pi is the name of a type class) on existential variables \nand  E = {tn =? t'}is a set of equations on type terms.  n A program is a triple (Classes, Instances,e) \nwhere Classes is a set of class declarations of the form class p( f ) where x : .ai.(P, E) .t where FV(.ai.(P, \nE) .t)= {f }. It de.nes a class named p, introduces a type variable f that ranges over members of the \nclass, and de.nes the type scheme of the single member value, x. Instances is a set of instance declarations \nof the form inst pk(gk) .p(.xm.c (t')) where x = e n where each free variable occurs at most once in \n.xm.c (t'), n {xm}.FV(c (t')), and n each ti'is either one of the xm or it has the form g (yl ) where \ng /. .{xm}and {yl }.{xm} This declaration de.nes an instance of class p for a type start\u00ading with type \nconstructor c. The arguments of c are restricted according to the type class predicates pk(gk). For each \npair c and p there is at most one instance declaration. e is an expression at the value level, de.ned \nby e ::= v term variables | .v.e lambda abstraction | ee application | let v = e in e let expression \nOur restriction on instance declarations is a simple generalization of Haskell98 s restriction. For the \ntime being, we ignore the ex\u00adpression in the instance declarations, which declares the member s value. \nFor purposes of type inference, we are only interested in the set Instances, and  the typing environment \nG0 generated by Classes:   2.3 Semantics Interestingly, we need to de.ne a semantics for our type language. \nWe have not been able to prove soundness and completeness of the transformation rules for our uni.cation \nalgorithm using purely syn\u00adtactical reasoning. Our semantics is given in terms of a Henkin model [24]. \nThe underlying mathematical structures of Henkin models are typed applicative structures: DEFINITION \n1. A typed applicative structure A is a triple (A. ,App.',. ,Const), where A. is a kind-indexed family \nof sets;  App.,.' is an indexed family of application operators App.,.' : A(...') .A. .A.'; and  Const \nis constant interpretation functions that maps each constant c into the appropriate set AS(c).  To become \na Henkin model, a typed applicative structure A must satisfy two additional criteria: it must be extensional \nand it must have a certain well-de.ned meaning function A[D(environment \u00b7 model condition). Or more formally: \nDEFINITION 2. A Henkin model is a typed applicative structure A = (A. ,App.,.',Const)where A is extensional, \ni.e., every App is a one-to-one mapping from A(...') into A. .A.', and  the meaning function [S, G nkt \n: .D. is a well-de.ned total function (given in Figure 3) where environments . are par\u00ad  . tial functions \nfrom variables to . A. so that . |= G, that is, dom(.)= dom(G) and (.x .dom(.)) .(x) .AG(x). We need \na few de.nitions to state our intended Henkin model. First, we need a strong notion of two semantic values \nbeing different. The kind-indexed relation .. captures this notion. It is the usual equality at base \ntypes. At function types, it differs from the usual pointwise notion of inequality. DEFINITION 3. Let \n(A. ,App.,.',Const) be a typed applicative structure. The kind-indexed binary relation .. (strongly different) \nis de.ned inductively. G0(x)= .f ,ai.(p( f ),P,E) .t iff class p( f ) where x : .ai.(P, E) .t .Classes \nx .* yiff x= y where x, y .A* ; [S,G nkx : .D. = .(x) [S,G nkc : .D. = Const(c) [S,G nkt1 t2: .D. =App.' \n,.([S,G nkt1: .'. .D.)([S,G nkt2: .' D.) ' [S,G nk .x .t : .'. .D. = the unique f . A.'.. s.th. ' .d \n. A.' .App fd =[S,G{x : .'}nkt : .D.[x '. y] Figure 3. Environment Semantics f ..'..'' g (where f ,g \n. A.'..'' )iff (.x . A.' ) f (x)..'' g(x)and ' ''. A.' ''. f (x '') (.x ,x )x '..' x ')..'' g(x. f . \nA.'..'' DEFINITION 4. A function is strongly injective if ' ''. A.' ' ''. f (x '') (.x ,x )x ..' x ')..'' \nf (x. For our intended Henkin model for .GHOU, we de.ne the following typed applicative structure I =(A. \n,App.,.' ,Const): A* is the set of closed .GHOU-terms of kind *, i.e., A* ={t | S,0/ nkt : *}. A.'..'' \nis the set of strongly injective functions from A.' to A.'' , i.e., A.'..'' . A.'' ={ f : A.'| f strongly \ninjective}. App.,.' : A...'. A. . A.' is function application: f . (x . f (x)).  Const(c)is the curried \nterm formation operator for the con\u00adstant symbol c.  Let s consider some examples for illustration, \nwhere we write the function type constructor, ->, as a pre.x operator: A*.{ Int,Bool,Float, List Int,List \nBool,List Float, Pair Int Int,Pair Int Bool, -> Int Int,-> Int Bool }  A*.* . . t.List t A*.*.* .{ \n. s.. t.Pair st,  . s.. t.-> st } Const(Int)=Int Const(List)=. t.List t Const(Pair)=. s.. t.Pair \nst  LEMMA 1. For each c, Const(c)is strongly injective. However, before we can accept this as a de.nition \nof a Henkin model, we need to make sure that the unique f . A.'.. s.th. ' .d . A.' .App fd =[S,G{x : \n.'}nkt : .D.[x '. y] indeed exists, i.e., we have to prove that it is strongly injective. Fortunately, \nthis comes out for free from the next theorem. Every function that we deal with in .GHOU must be (at \nleast) in\u00adjective so that uni.cation can apply the decomposition rule without limitation. In brief, the \ndecomposition rule for a variable, say f , requires that ft1 ... tn = ft ' ... t ' iff t1 =t ' ... tn \n=tn' . 1 n 1 Whereas the direction from right to left follows directly from the compatibility of \u00df-equivalence, \nthe direction from left to right re\u00adquires more attention. In fact, it is only valid if f is always an \ninjective function. Unfortunately, it is hard to prove directly that every functional .GHOU-term is injective, \nbut it is possible to prove the stronger claim of strong injectivity. THEOREM 1. For all .GHOU-terms \nt, it holds that: for all .1,.2,G such that judgement J holds (where J is S,G nkt : .) and .i |=G, for \ni =1,2, and for all X . FV(t): iffor all x . FV(t)either x ./X and .1(x)=.2(x)or  x . X and .1(x).G(x) \n.2(x)  then . .'' if . =.' then [JD.i is strongly injective, for i =1,2; and  exactly one of the following \nis true  X n FV(t)=0/ and [JD.1 =[JD.2;or  X n FV(t)=0/ and [JD.1 .. [JD.2.   PROPOSITION 1. The \ntyped applicative structure I is a Henkin model for .GHOU. Next, we turn to solving equations in .GHOU. \n 2.4 Guided Higher-Order Uni.cation Guided higher-order uni.cation simpli.es a constrained uni.cation \nproblem (P,E)5. We need some preliminaries to give the de.nition of a solution of (P,E). Instance satisfaction \nrelates a set of instance declarations Instances to a predicate p applied to a type t. Instances n p(t)holds \nexactly if the collected instance declarations indicate that type t belongs to the class p. In particular, \na type constructor .xm.c (tn)is an instance of p if there is an instance declaration inst pk(gk) . p(.xm.c \n(t ' )). Instances n with the same head symbol c, and for each argument ti ' of c in this declaration \n' if ti is xi, the corresponding subterm ti of c tn is also xi, '  if ti is f yl , where f is unconstrained, \nthe corresponding sub\u00adterm ti is an arbitrary term t of the same kind as f , and  ' if ti is gj yl , \nwhere gj is one of the variables mentions in p(gk), the corresponding subterm ti of c tn must be an instance \nof pj. 5Since we are leaving some .ex-.ex pairs unresolved, it might be more appropriate to speak of \npre-uni.cation. (strip) P,E .{.x.t =? .x.t '},s (decomp) P,E .{c (tn)=? c (t ')},s n(.ex-rigid-1) P,E \n.{f . (tm)=? c (t ')},s n (.ex-rigid-2) P .{p( f )},E .{f (tm)=? c (t ')},s n (.ex-.ex-1) P,E .{f . (tn)=? \ng. (t ')},s n (.ex-.ex-2) P,E .{f . (tm)=? g (t ')},s n . P,E .{t =? t '},s . P,E .{tn =? t '},s  \nn . .(P),.(E .{tm =? t '}),. .s l+m where . = f . .c (t ') l and l + m = n and (.p) p( f .) .P and \nKindS(c (t ')) = . l ' and f . .FV(t ) l '' . .(P) .{pk(gk)},.(E) .{t [xm ..(tm)] =? t '},. .s nnf \n..xm.c (t '' where . =) n and inst pk(gk) .p(.xm.c (t '')) n and f .FV(t ') n . .(P),.(E .{tn =? \nt '}),. .s n where ((.p) p( f .) .P iff p(g.) .P) or . = * f . .g. and . = . .(P),.(E .{tm =? t '}),. \n.s l+m where . = f . .g (t ') l and l + m = n and ((.p) p( f .) ./P and p(g) ./P) or . = * and KindS(g \n(t ')) = . l and f .FV(tl ') Figure 4. Guided Higher-Order Uni.cation These side conditions are enforced \nby an auxiliary judgement Instances,pk(gk) nt ' .t. DEFINITION 5. The instance satisfaction relation \nInstances np(t) is de.ned by inst pk(gk) .p(.xm.c (t ')) .Instances nInstances,pk(gk) nti ' .ti for each \ni Instances np(.xm.c (tn)) Instances,pk(gk) nxi .xi KindS( f )= KindS( f ) Instances,pk(gk) n f (yl ) \n.t (yl ) Instances npj(.yl .t) Instances,pk(gk) ngj yl .t DEFINITION 6. A substitution s is a solution \nto constrained uni.\u00adcation problem (P,E), written s |=(P,E),iff for each t =? t '.E, it holds that s(t)= \ns(t '), and  for each p(g) .P, Instances np(s(g)).  The rewriting system in Figure 4 speci.es the guided \nuni.cation procedure. A con.guration of the rewriting system is a triple P,E,s where P = {p1(g1),...}a \nset of predicates on existential variables;  E = {t1 =? t1' ,...}a set of equations;  s = {g1 .t1,...} \na substitution of existential variables by .GHOU-terms.  The rules are to be interpreted similarly as \nin the .rst stage of Nip\u00adkow s article [27]. All rules are closed under symmetry of the =? relation. \nIn the (strip) rule, the bound variables on both sides can be assumed equal due to a-conversion. This \nrule never fails: If one side does not start with a lambda, then the term is implicitly .-expanded. In \nthe (decomp) rule, constants may also be universal variables (as customary in higher-order uni.cation) \nbut this case will not arise in .GHOU. An attempt to unify two terms with differ\u00adent head symbols fails \nimmediately, although this is not re.ected in the rules. Equations where one head symbol is an existential \nvariable and the other head symbol is a constant are handled by the rules (.ex-rigid\u00ad1) and (.ex-rigid-2) \nrespectively. The former rule handles the cases where there are no class constraints restricting the \nfree variable f . Those cases mimic the current behavior of Haskell98: the free vari\u00adable f gets substituted \nby the constant on the right hand side ap\u00adplied to leading arguments depending on the kinds involved. \nThe rule only applies if all kinds match and the free variable f does not occur in the pre.x of the right \nhand side. The latter rule is used to guide the uni.cation process when determining a the substitution \nfor the free variable f . If there is a constraint on the free variable f , we use the instance declarations \nof f s predicate p as a substitu\u00adtion; given the side conditions on instance declarations and the head \nsymbol c, this selection is deterministic. If there is an equation with an existential variable on either \nside, we only handle the equation if we can de.nitely decide how to simplify it. This is either the case \nif both variables are applied to the same number of arguments and also both variable are constrained \nby ex\u00adactly the same set of predicates, or we have a different number of arguments but no constraints \nat all. In the former case (.ex-.ex-1) we unify both variables and decompose the terms, in the latter \ncase (.ex-.ex-2) we again mimic Haskell98 as in the (.ex-rigid-1) rule. The uni.cation rules are sound \nand complete, that is, they do not change the set of solutions of a constrained uni.cation problem. LEMMA \n2. For any transformation P, E,s .P ' ,E ' ,. .s, it holds that . |=(.(P),.(E))iff . |=(P ' ,E ').  \n2.5 Termination A study of the proof for Lemma 2 reveals that the condition f ./' FV(t ) is not needed \nfor proving soundness and completeness of nrule (.ex-rigid-2). However, this side condition is a necessary \ncon\u00addition for the rules to terminate. Suppose we are given a rule (.ex-rigid-2 ) de.ned just like rule \n(.ex-rigid-2), but without the condition f ./FV(t '). The following n con.guration leads to non-termination: \n? {p(f )},{fx =c (fy)},s In the presence of the instance declaration inst p(g) . p(.x.c (gx)), the con.guration \nrewrites in one (.ex-rigid-2 ) step to ? {p(g)},{gx =c (gy)}, (f ..x.c (gx)).s Since the resulting predicate \nand equation are just renamings of the original ones, the same rule (.ex-rigid-2 ) applies over and over \nagain. The problem is that the substitution for f introduces a vari\u00adable g that matches up in the next \nstep with the constant c which is also introduced by the same substitution. Still, this restriction is \nnot suf.cient to ensure termination. The rea\u00adson for this is that the occur check cannot be applied in \nthe usual ob\u00advious way. Since some decompositions are delayed (cf. rules (.ex\u00ad.ex-2)) and a constrained \n.ex-rigid match only leads to a partial substitution (.ex-rigid-2), the occurrence of a variable in a \nsubsti\u00adtution need not become obvious at some point. For that reason, we are relying on a heuristic to \nstop the uni.cation procedure. Roughly, the heuristic marks each symbol (variable or constant) in the \norig\u00adinal set of equations with a unique label and labels each equation with the empty set. Whenever \na rule applies, the newly generated equations inherit the label from the originating equation. The ex\u00adception \nhere is the (.ex-rigid-2), where we add the pair of the label of variable f and the constant c to the \nset on the newly generated equations. The fresh variables generated by this rule application in\u00adherit \nthe label from variable f . Rewriting stops (reporting failure to unify) if the pair (f , c)is already \npresent in the set of label pairs of the equation triggering the rule (.ex-rigid-2). 2.6 Type Inference \nThe type inference rules in Figure 5 are the straightforward adaption of Milner s algorithm W [22] to \nour extended type language. The algorithm is formulated as a syntax-directed typing judgement nW . Each \nrule (P,E), s, G nWe : t states for a certain form of ex\u00adpression e considered under typing assumptions \nG what its type t is and which constraints (P,E)the free type variables must satisfy considering a certain \nsubstitution s. The (i-var) and (i-lam) rules are standard. The (i-app) rule uses our guided higher-order \nuni.cation procedure instead of a .rst-order uni.cation algorithm. The (i-let) rule uses a generalization \nproce\u00addure Gen. Its purpose is to generate a type scheme by generalizing over all free variables that \nare not occurring free in the type assump\u00adtions and by adding only such constraints that are affected \nby free G(x)=.ai.(P, E).t bi new (i-var) W (P, E)[ai .bi],0/,G nx : t[ai .bi] (P, E),s,G{x .a}nWe : ta \nnew (i-lam) (P, E),s,G nW .x.e : s(a).t (P1,E1),s1,G nWe1: t1 (P2,E2),s2,s1G nWe2: t2 a new (i-app) s2(P1).P2,s2(E1).E2 \n.{s2(t1)=? t2 .a}.* P3,E3,s3 (P3,E3),s3,G nWe1 e2: s3(a) (P1,E1),s1,G nWe1: t1 ((P2,E2),s)=Gen(G, P1,E1,t1) \n(i-let)(P3,E3),s2,s1G{x .s}nWe2: t2 (P, E)=(s2(P2).P3,s2(E2).E3) (P, E),s2 .s1,G nW let x =e1 in e2: \nt2 Figure 5. Type Inference variables. This is speci.ed as follows: Gen(G,P,E,t)= ((P1,E1),.ai.(P2,E2).t) \nwhere {ai}=FV(t)\\FV(G) and P2 ={p(t).P |FV(t)n{ai}=0/} and E2 ={t =? t '.E |FV(t =? t ')n{ai}=0/} and \nE1 =E \\E2 and P1 =P \\P2 In addition, our implementation performs predicate normalization before generalization \nin (i-let). DEFINITION 7(PREDICATE NORMALIZATION). norm(0/)= 0/ norm(P .{p(t)})= if t =.xm.c(tn) and \ninst pk(gk) .p(.xm.c (t ')).Instances nthen norm(P .{pj(.yl .ti)|t ' =gj (yl )}) i else norm(P).{p(t)} \nPredicate normalization terminates always, due to the syntactic re\u00adstriction on instance declarations. \nIf normalization .nds a suitable instance declaration in scope (using Instances), it decomposes the argument \nof the predicate p and recursively tries to normalize the arguments. If there is no suitable instance \ndeclaration (perhaps be\u00adcause t is .-equivalent to an existential variable), then the predicate is returned \nwithout change.  3 Evaluation In this section, we reconsider the examples from Section 1 in the light \nof the proposed extensions. We also present an example which yields a typing with remaining .ex-.ex pairs. \n3.1 Functors In this example, our desire was to express the identity functor . x.x and functor composition \n. x.f (g x) using instances of the Functor class. It turns out that we cannot model the identity functor \nbecause .x.x is not an .GHOU-term and we cannot model functor composition directly, either. However, \nwith a little bit of foresight, we can make all functor instances composable! The idea is to write instance \n(Functor g) => Functor (. x.[g x]) where fmaph = g whereg []= [] g (x:xs)= fmaph x: g xs instance \n(Functor g) => Functor (. x.Maybe (g x)) where ... instead of the instances in Section 1.1. Hence, one \nuse of the iden\u00adtity type Id is still required to start a stack of composable functors, but there is \nno need for an explicit composition operator. 3.2 Contravariant Functors The example of the motivation \nsection, where the function arrow is abstracted over its .rst parameter, works as desired. instance OpFunctor \n(. x.x -> a) where opmaph g=g.h 3.3 WASH/CGI The instance declarations for class InputHandle may now \nbe writ\u00adten as follows: --as before instance InputHandle (InputField a) where ... instance InputHandle \n(RadioGroup a) where ... --instead of defining data type FL: instance (InputHandle h) => InputHandle \n(. x.[h x]) where ... --instead of defining data type F2: instance (InputHandle h1, InputHandle h2) => \nInputHandle (. x.(h1 x, h2 x)) where ... --lifting of F0 is not possible: instance InputHandle F0 where \n... In the last case, the introduction of the F0 data type cannot be avoided: dataF0 x =F0 Since F0 \nstands for a constant function . x.(), it does not .t into our framework because it is not a .I term. \n 3.4 Flex-Flex Pairs To show how a typing with remaining .ex-.ex pairs could occur, we present another \nexample. Consider the following algebraic data type T and the associated function fun: dataTf=T(fChar) \n--fhaskind*->* fun(T x) =fmap ordx The type constructor T abstracts over types that result of applying \na type constructor f to the type of characters. The function fun takes a value of an instance of a type \nconstructed from T and maps the library function ord over it using fmap. For simplicity, we assume the \nfollowing typings: fmap:: (Functorg)=> (a ->b) -> ga -> gb ord :: Char -> Int For typing fun, the inferencer \nconsiders the pattern on the left hand side of the declaration. The result is a type assumption for the \npat\u00adtern variable x: x :: f Char When inferring the type of the body of the function fun, we .rst consider \nthe .rst function application fmap ord and get the fol\u00adlowing uni.cation problem: Functorg, (a-> b)->ga->gb=?=(Char-> \nInt)-> c Using the rules (decomp) and (.ex-rigid-1), we get: fmap ord :: (Functor g) => g Char -> g \nInt The type inference of the second function application (fmap ord) x leads to the new uni.cation problem: \nFunctor g, g Char -> g Int =?= f Char -> d which simpli.es to Functor g, g Char =?= f Char, g Int =?= \nd by using the (decomp) rule. The second equation can be elimi\u00adnated using (.ex-.ex-2), but the .rst \none is a remaining .ex-.ex pair since we cannot be sure that f and g necessarily is the same type constructor. \nHence, the resulting type for fun is: fun :: (Functor g, g Char =?= f Char) => T f -> g Int  3.5 Discussion \nThe two places were our framework seems to fall short of our ex\u00adpectations is that it does not include \nconstant functions and projections, and  it does not include the identity functions.  However, both \nadditions are not desirable because they either defer parts of the uni.cation or they lead to ambiguities. \nThe addition of constant functions and projections complicates the applicability of the rules for .ex-.ex \npairs. Since these rules only hold for strongly injective functions, we have to make sure that nei\u00adther \nhead variable may be instantiated with a constant function later on. In addition, we have to make sure \nthat no argument term dis\u00adappears , for example, if the term only appears as the argument of a variable \nthat may be instantiated with a constant function. The addition of identity functions introduces ambiguities \nat the level of instance declarations. The typical way of introducing such an identity would be as in \nthe example for Functor: instance Functor (. x.x) where ... This declaration would play the role of a \ndefault instance declara\u00adtion. For example, consider the equation fa =? Tree Int where Functor f . In \nthe absence of an instance for Tree, we might use the default instance and obtain the equation a =? Tree \nInt. It might be worthwhile considering such an extension. However, we refrained from doing so in this \nwork for two reasons: On the one hand, this kind of overlapping instances has no counterpart in standard \nHaskell, and on the other hand, the resulting uni.cation procedure will not be deterministic anymore. \nWe have omitted subclasses from our de.nitions. However, they are easy to add at the price of complicating \nthe de.nition of instance satisfaction (De.nition 5) in the usual way [16] and by insisting that corresponding \nterms in instance declarations match. The latter is easy to check using (decidable) pattern uni.cation, \nsince instance terms happen to be higher-order patterns [20].  4 Related Work The most closely related \nwork analyzes algorithms for equality and uni.cation in the presence of notational de.nitions [34]. The \nau\u00adthors introduce a notion of strictness of a lambda term, .x.t, that enables them to prove that a strict \nterm behaves like an injective function under \u00df-reduction. Given a de.nition a = .xm.t, where the term \nis strict in xm, equality of terms with head symbol a can be de\u00adcided by just checking the arguments \nof a for equality, thus avoiding the need for expanding the de.nition of a. A similar improvement is \npossible in the uni.cation algorithm. Our notion of a strongly in\u00adjective function is also motivated \nby the desire for a strong decom\u00adposition rule in the uni.cation algorithm (.ex-.ex-1). It would be interesting \nto compare the notion of strictness with strong injectiv\u00adity, but this may not be straightforward because \nstrictness is de.ned syntactically whereas strong injectivity is de.ned semantically, by recourse to \na speci.c model. 4.1 Type Inference A polymorphic typing discipline with a type reconstruction algo\u00adrithm \nis one of the key features of a number of successful functional programming languages, like ML [23] and \nHaskell [9]. Starting from the algorithm of Hindley [10] and Milner [22], a variety of extensions has \nbeen proposed and implemented. Among them, the biggest boost has come from the introduction of parametric \nover\u00adloading, as it was suggested by a number of authors [18, 19, 38, 5]. This proposal was modi.ed and \nintegrated in the programming lan\u00adguage Haskell in the form of type classes. A type class is an in\u00adductively \nde.ned set of types. A type class quali.cation (or class constraint) can be used to restrict a polymorphic \ntype to the mem\u00adbers of a particular class (or classes). A number of works have tried to explain type \ninference for Haskell from .rst principles [28, 29]. Subsequently, further extensions have been investigated. \nIn his the\u00adsis [13], Jones has investigated quali.ed types. Quali.ed types can be instantiated to a range \nof interesting type systems, among them type classes, record types, and subtyping. This work has paved \nthe way for more explorations. Multi-parameter type classes [31] generalize type classes from sets of \ntypes to inductively de.ned re\u00adlations on types. Unfortunately, they come with non-trivial ambi\u00adguity \nproblems that render them virtually useless. This problem has prompted Jones [17] to add functional dependencies \nto multi\u00adparameter type classes. Their addition resolves many ambiguity problems arising in practice. \nThe semantic foundation of this work has been laid in earlier work on simpli.cation and improvement of \ntype class constraints during type reconstruction [15]. In another line of work, type classes have been \ngeneralized to con\u00adstructor classes [12]. A constructor class de.nes a set of type con\u00adstructors. This \nwork has also become part of the Haskell language, and it is indeed the basis for convenient programming \nwith mon\u00adads, which is in turn essential to write Haskell programs that use I/O. Type inference for constructor \nclasses can be implemented us\u00ading .rst-order many-sorted uni.cation. 4.2 Higher-order Uni.cation At \nthis point, we can only give a very brief impression of a com\u00adplicated research area. More information \nmay be found in Dowek s survey article [4]. Higher-order uni.cation has .rst been considered by Huet \n[11]. Huet showed that the general problem is undecidable and gave a semi-algorithm (which may not terminate) \nfor its so\u00adlution. The undecidability result was later strengthened to include second order terms, too \n[8, 7]. Miller [20] de.ned higher-order pat\u00adterns, for which the uni.cation problem is decidable and \nunitary, regardless of the order of the terms. In the monadic case, where all constant symbols are unary, \nuni.cation is decidable for second order terms [6], but undecidable at higher orders [26]. Matching is \nbelieved decidable [40], but concrete results only exist for second and third order problems [11, 2, \n3]. Our work is inspired by Miller s work on pattern uni.cation [20] and its generalization by Prehofer \n[35]. For the implementation, Nipkow s transformation of a rule-based description of pattern uni\u00ad.cation \ninto a readily implementable functional version proved very helpful, although our Haskell implementation \ncan avoid some of its complications [27].  5 Conclusion The construction of an extension of Haskell \ns type class system with a restricted notion of lambda abstraction is not a straightforward task. We \nhave achieved to de.ne a system that types a number of interesting examples that were not possible before, \nalthough some could be made to work at the price of some awkward programming. Our extension is conservative \nin the sense that all programs typeable in Haskell98 are still typeable in the extended language. On \nthe downside, type schemes get more complicated because the con\u00adstraints now include the remaining .ex-.ex \npairs where at least one head variable carries a predicate. In some contrived cases that involve data \nstructures with arrow-kinded type parameters the ex\u00adtended language infers types with such constraints. \n  References [1] H. P. Barendregt. The Lambda Calculus Its Syntax and Semantics. North-Holland, 1984. \n[2] G. Dowek. A second order pattern matching algorithm in the cube of typed .-calculi. In Proceedings \nof Mathematical Fun\u00addation of Computer Science Lecture Notes in Computer Sci\u00adence 520, pages 151 160, \n1991. Rapport de Recherche 1585, INRIA, 1992. [3] G. Dowek. Third order matching is decidable. In Proceedings \nof the 1992 IEEE Symposium on Logic in Computer Science. IEEE Computer Society Press, June 1992. [4] \nG. Dowek. Higher-order uni.cation and matching. In A. Robinson and A. Voronkov, editors, Handbook of \nAuto\u00admated Reasoning, volume 2, chapter 16, pages 1009 1062. North-Holland, 2001. [5] D. Duggan, G. V. \nCormack, and J. Ophel. Kinded type in\u00adference for parametric overloading. Acta Inf., 33(1):21 68, 1996. \n[6] W. M. Farmer. A uni.cation algorithm for second-order monadic terms. Annals of Pure and Applied Logic, \n39:131 174, 1988. [7] W. M. Farmer. Simple second-order languages for which uni\u00ad.cation is undecidable. \nTheoretical Comput. Sci., 87(1):25 41, Sept. 1991. [8] W. D. Goldfarb. The undecidability of the second-order \nuni\u00ad.cation problem. Theoretical Comput. Sci., 13(2):225 230, Feb. 1981. [9] Haskell 98, a non-strict, \npurely functional language. http: //www.haskell.org/definition, Dec. 1998. [10] J. R. Hindley. The principal \ntype scheme of an object in com\u00adbinatory logic. Transactions of the American Mathematical Society, 146:29 \n60, 1969. [11] G. Huet. A uni.cation algorithm for typed .-calculus. Theo\u00adretical Comput. Sci., 1(1):27 \n57, 1975. [12] M. P. Jones. A system of constructor classes: Overloading and implicit higher-order polymorphism. \nIn Arvind, editor, Proc. Functional Programming Languages and Computer Ar\u00adchitecture 1993, pages 52 61, \nCopenhagen, Denmark, June 1993. ACM Press, New York. [13] M. P. Jones. Quali.ed Types: Theory and Practice. \nCam\u00adbridge University Press, Cambridge, UK, 1994. [14] M. P. Jones. Functional programming with overloading \nand higher-order polymorphism. In Advanced Functional Pro\u00adgramming, volume 925 of Lecture Notes in Computer \nSci\u00adence, pages 97 136. Springer-Verlag, May 1995. [15] M. P. Jones. Simplifying and improving quali.ed \ntypes. In S. Peyton Jones, editor, Proc. Functional Programming Lan\u00adguages and Computer Architecture \n1995, pages 160 169, La Jolla, CA, June 1995. ACM Press, New York. [16] M. P. Jones. Typing Haskell in \nHaskell. In E. Meijer, editor, Proceedings of the 1999 Haskell Workshop, number UU-CS\u00ad1999-28 in Technical \nReports, 1999. ftp://ftp.cs.uu.nl/ pub/RUU/CS/techreps/CS-1999/1999-28.pdf. [17] M. P. Jones. Type classes \nwith functional dependencies. In G. Smolka, editor, Proc. 9th European Symposium on Pro\u00adgramming, number \n1782 in Lecture Notes in Computer Sci\u00adence, pages 230 244, Berlin, Germany, Mar. 2000. Springer-Verlag. \n[18] S. Kaes. Parametric overloading in polymorphic program\u00adming languages. In H. Ganzinger, editor, \nProc. 2nd European Symposium on Programming 1988, number 300 in Lecture Notes in Computer Science, pages \n131 144. Springer-Verlag, 1988. [19] S. Kaes. Type inference in the presence of overloading, sub\u00adtyping \nand recursive types. In Proc. 1992 ACM Conference on Lisp and Functional Programming, page x, San Francisco, \nCalifornia, USA, June 1992. [20] D. Miller. Uni.cation of simply typed lambda-terms as logic programming. \nIn K. Furukawa, editor, Eighth Interna\u00adtional Logic Programming Conference, pages 255 269, Paris, France, \nJune 1991. MIT Press. [21] D. Miller. Uni.cation under a mixed pre.x. Journal of Sym\u00adbolic Computation, \n14(4):321 358, Oct. 1992. [22] R. Milner. A theory of type polymorphism in programming. J. Comput. Syst. \nSci., 17:348 375, 1978. [23] R. Milner, M. Tofte, R. Harper, and D. MacQueen. The De.\u00adnition of Standard \nML (Revised). MIT Press, 1997. [24] J. Mitchell. Foundations for Programming Languages. MIT Press, 1996. \n[25] G. Nadathur and D. Miller. An overview of . PROLOG. In R. A. Kowalski and K. A. Bowen, editors, \nProceedings of the Fifth International Conference and Symposium on Logic Programming, pages 810 827, \nSeattle, 1988. ALP, IEEE, The MIT Press. [26] P. Narendran. Some remarks on second order uni.cation. \nTechnical Report 89/356/18, University of Calgary, July 1989. [27] T. Nipkow. Functional uni.cation of \nhigher-order patterns. In Proc. of the 8th Annual IEEE Symposium on Logic in Com\u00adputer Science, pages \n64 74. IEEE Computer Society Press, 1993. [28] T. Nipkow and C. Prehofer. Type checking type classes. \nIn Proceedings of the 1993 ACM SIGPLAN Symposium on Principles of Programming Languages, pages 409 418, \nCharleston, South Carolina, Jan. 1993. ACM Press. [29] T. Nipkow and G. Snelting. Type classes and overloading \nresolution via order-sorted uni.cation. In J. Hughes, editor, Proc. Functional Programming Languages \nand Computer Ar\u00adchitecture 1991, number 523 in Lecture Notes in Computer Science, pages 1 14, Cambridge, \nMA, 1991. Springer-Verlag. [30] L. C. Paulson. Isabelle: The next 700 theorem provers. In P. Odifreddi, \neditor, Logic and Computer Science, pages 361 385. Academic Press, 1990. [31] S. Peyton Jones, M. Jones, \nand E. Meijer. Type classes: An exploration of the design space. In J. Launchbury, editor, Proc. of the \nHaskell Workshop, Amsterdam, The Netherlands, June 1997. Yale University Research Report YALEU/DCS/RR-1075. \n[32] F. Pfenning. Partial polymorphic type inference and higher\u00adorder uni.cation. In ACM Conference on \nLisp and Functional Programming, pages 153 163, Snowbird, Utah, 1988. ACM Press. [33] F. Pfenning. Logic \nprogramming in the LF logical frame\u00adwork. In G. Huet and G. Plotkin, editors, Logical Frame\u00adworks, pages \n149 181. Cambridge University Press, 1991. [34] F. Pfenning and C. Sch\u00a8urmann. Algorithms for equality \nand uni.cation in the presence of notational de.nitions. In T. Al\u00adtenkirch, W. Naraschewski, and B. Reus, \neditors, Types for Proofs and Programs, number 1657 in Lecture Notes in Com\u00adputer Science, pages 179 \n193, Kloster Irsee, Germany, Mar. 1998. [35] C. Prehofer. Decidable higher-order uni.cation problems. \nIn Automated Deduction CADE-12, 12th International Confer\u00adence on Automated Deduction. Springer, 1994. \n[36] M. Schmidt-Schau\u00df and K. U. Schulz. Decidability of bounded higher order uni.cation. Technical Report \nFrank-15, Universit\u00a8at Frankfurt, 2001. [37] P. Thiemann. Wash/CGI: Server-side Web scripting with ses\u00adsions \nand typed, compositional forms. In Practical Aspects of Declarative Languages, Proceedings of the Fourth \nInterna\u00adtional Workshop, PADL 02, number 2257 in Lecture Notes in Computer Science, pages 192 208, Portland, \nOR, USA, Jan. 2002. Springer-Verlag. [38] P. Wadler and S. Blott. How to make ad-hoc polymorphism less \nad-hoc. In Proc. 16th Annual ACM Symposium on Princi\u00adples of Programming Languages, pages 60 76, Austin, \nTexas, Jan. 1989. ACM Press. [39] Web authoring system in Haskell (WASH). http: //www.informatik.uni-freiburg.de/ \nthiemann/ haskell/WASH, Mar. 2001. [40] D. A. Wolfram. The Clausal Theory of Types. Cambridge tracts \nin Theoretical Computer Science. Cambridge Univer\u00adsity Press, 1993. \n\t\t\t", "proc_id": "581478", "abstract": "We propose an extension of Haskell's type class system with lambda abstractions in the type language. Type inference for our extension relies on a novel constrained unification procedure called guided higher-order unification. This unification procedure is more general than Haskell's kind-preserving unification but less powerful than full higher-order unification.The main technical result is the soundness and completeness of the unification rules for the fragment of lambda calculus that we admit on the type level.", "authors": [{"name": "Matthias Neubauer", "author_profile_id": "81100042558", "affiliation": "Universit&#228;t Freiburg", "person_id": "P343130", "email_address": "", "orcid_id": ""}, {"name": "Peter Thiemann", "author_profile_id": "81100458917", "affiliation": "Universit&#228;t Freiburg", "person_id": "PP39043747", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/581478.581496", "year": "2002", "article_id": "581496", "conference": "ICFP", "title": "Type classes with more higher-order polymorphism", "url": "http://dl.acm.org/citation.cfm?id=581496"}