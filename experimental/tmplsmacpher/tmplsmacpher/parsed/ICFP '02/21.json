{"article_publication_date": "09-17-2002", "fulltext": "\n There and Back Again * Functional Pearl Olivier Danvy Mayer Goldberg BRICS Department of Computer Science \nDepartment of Computer Science University of Aarhus BenGurionUniversity \u00a7 Dear Reader: Before proceeding \nany further, could you .rst ponder on the two following riddles? Computing a symbolic convolution: Given \ntwo lists [x1,x2, ..., xn-1,xn]and [y1,y2, ..., yn-1,yn], where n is not known in advance, write a function \nthat constructs [(x1,yn), (x2,yn-1), ..., (xn-1,y2), (xn,y1)] in n recursive calls and with no auxiliary \nlist. Detecting a palindrome: Given a list of length n,where n is not known in advance, determine whether \nthis list is a palindrome in In/2l recursive calls and with no auxiliary list. Thank you. * With apologies \nto Tolkien. Basic Research in Computer Science (www.brics.dk), funded by the Danish National Research \nFoundation.  Ny Munkegade, Building 540, DK-8000 Aarhus C, Denmark E-mail: danvy@brics.dk \u00a7 Be er Sheva \n84105, Israel E-mail: gmayer@cs.bgu.ac.il Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 02, October 4-6, 2002, Pittsburgh, Pennsylvania, USA. Copyright \n2002 ACM 1-58113-487-8/02/0010 ...$5.00.  Abstract We present a programming pattern where a recursive \nfunc\u00adtion traverses a data structure typically a list at return time. The idea is that the recursive \ncalls get us there (typi\u00adcally to a base case)and the returns get us back again while traversing the \ndata structure. We name this programming pattern of traversing a data structure at return time There \nAnd Back Again (TABA). The TABA pattern directly applies to computing a sym\u00adbolic convolution. It also \nsynergizes well with other pro\u00adgramming patterns, e.g., dynamic programming and travers\u00ading a list at \ndouble speed. We illustrate TABA and dynamic programming with Catalan numbers. We illustrate TABA and \ntraversing a list at double speed with palindromes and we obtain a novel solution to this traditional \nexercise. A TABA-based function written in direct style makes full use of an Algol-like control stack \nand needs no heap allo\u00adcation. Conversely, in a TABA-based function written in continuation-passing style, \nthe continuation acts as a list iterator. In general, the TABA pattern saves one from con\u00adstructing intermediate \nlists in reverse order. Categories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs \nand Features control structures; procedures, functions, and subroutines; recursion; F.2.2 [Analysis of \nAlgorithms and Problem Complexity]: Nonnumerical Algorithms and Pro\u00adblems computations on discrete structures; \nF.3.3 [Logics and Meanings of Programs]: Studies of Program Con\u00adstructs control primitives; functional \nconstructs; program and recursion schemes; I.1.2 [Symbolic and Algebraic Manipulation]: Algorithms Analysis \nof algorithms; I.2.8 [Arti.cial Intelligence]: Problem Solving, Control Meth\u00adods, and Search backtracking. \n General Terms Design, Languages, Theory. Keywords Symbolic convolutions, Catalan numbers, palindrome \ndetec\u00adtion, continuation-based programming. 1. A symbolic convolution Symbolically convolving the two \nlists [x1,x2, ..., xn-1,xn] and [y1,y2, ..., yn-1,yn] yields the list [(x1,yn), (x2,yn-1), ..., (xn-1,y2), \n(xn,y1)]. Numeric convolutions are used, e.g., to multiply generating functions [6, Section 5.4], and \nthey have occurred very early in the history of mathematics [12]. Computing a symbolic convolution is \nstraightforward for a functional programmer; it is achieved by zipping the .rst list and the reverse \nof the second list. In Standard ML: This de.nition induces a compiler warning about non-exhaust\u00adive pattern \nmatching, but this warning is unfounded since the two input lists have the same length. (In a version \nof ML with dependent types [16], the type of cnv1 would be .n . N .a list(n) \u00d7 \u00df list(n) . (a \u00d7 \u00df) list(n).) \n(* cnv1 : a list * b list -> ( a * b) list *) (* zip: alist* blist->( a* b) list *) (* rev: blist-> \nblist *) fun cnv1 (xs, ys) = let fun zip (nil, nil) =nil | zip (x :: xs, y :: ys) = (x, y) :: (zip (xs, \nys)) in zip (xs, rev ys) end At any rate, cnv1 performs two iterations one to reverse the second list \n(rev above), and one to traverse the .rst list and the reversed list (zip above). In addition, rev constructs \nan intermediate list. Could we do better, i.e., could we traverse each list only once and construct no \nintermediate list? Similar problems have been considered before. For example, Launchbury and Sheard s \nwarm fusion comes to mind [8]. In our solution, we traverse the .rst list (walk below)while building \na list iterator (the second parameter of walk below). On reaching the end of the .rst list, we apply \nthe list iterator to the second list to traverse it and construct the result: (* cnv2 : a list * b list \n-> ( a * b) list *) (* walk : a list * (( a * b) list * b list *) (* -> ( a * b) list) *) (* -> ( a * \nb) list *) fun cnv2 (xs, ys) = let fun walk (nil, k) = k (nil, ys) |walk(x::xs, k) = walk (xs, fn (r, \ny :: ys) => k ((x, y) :: r, ys)) in walk (xs, fn (r, nil) => r) end Figuratively speaking, traversing \nthe .rst list winds up a list-traversal spring, which we explicitly unwind over the second list. This \nhigher-order solution is reminiscent of the call-by\u00advalue version of Bird s famous repmin function [1], \nwhere a function is constructed while a tree is traversed, and even\u00adtually applied. In contrast to repmin, \nhowever, walk is writ\u00adten in continuation-passing style (CPS), since its carries a higher-order accumulator \nand all of its calls are tail calls. Having identi.ed that walk is in CPS, and since there is nothing \nintrinsic to CPS about it, let us write it in direct style. The resulting function traverses the .rst \nlist at call time and the second list at return time: (* cnv3 : a list * b list -> ( a * b) list *) (* \nwalk : a list -> ( a * b) list * b list *) fun cnv3 (xs, ys) = let fun walk nil = (nil, ys) |walk(x::xs) \n= let val (r, y :: ys) = walk xs in ((x, y) :: r, ys) end in let val (r, nil) = walk xs in r end end \nFiguratively speaking, the calls implicitly wind up a list\u00adtraversal spring and the returns unwind it. \nThis direct-style solution only allocates storage to con\u00adstruct the result, and all its intermediate \nresults are held on the control stack if one uses an implementation of a deriva\u00adtive of ALGOL 60 such \nas Chez Scheme (http://www.scheme. com)or OCaml (http://caml.inria.fr). Generalizing, we can see that \nevery time we want to fold a function over the result of zipping a list and the reverse of another list, \nwe can avoid reversing the other list and avoid zipping. Instead, we can use only one recursive de\u00adscentto \ntraverse one listatcall timeand to traverse the other at return time. The situation is crystallized in \nthe fol\u00adlowing fusion-like law, which is reminiscent of Launchbury and Sheard s warm fusion [8], though \ndistinct from it. Proposition 1 (There And Back Again). For all suitably typed f and b,and for all lists \nxs and ys with the same length, foldr f b (zip (xs, rev ys)) = let val (r, nil) = foldr (fn (x, (r, y \n:: ys)) => (f ((x, y), r), ys)) (b, ys) xs in r end The rest of this article illustrates further the \nTABA pro\u00adgramming pattern of traversing a list at return time, in\u00adcluding trivial calls in Appendix A \nand multiple returns in Appendix B. 2. The Catalan numbers The Catalan numbers are recursively de.ned \nas follows [6, 7, 15]: C0 =1 Cn = C0Cn-1 + ... + CkCn-k-1 + ... + Cn-1C0 This speci.cation .ts the TABA \npattern very well: given a list [C0, ..., Cn-1], one computes Cn with a numeric self\u00adconvolution. We \ncan de.ne a function computing Catalan numbers us\u00ading course-of-values induction, i.e., iteratively building \na list of intermediate Catalan numbers in reverse order. The re\u00adsult reads as follows. (* catalan : int \n-> int *) (* cat : int list -> int *) (* walk : int list -> int * int list *) (* iterate : int * int \nlist -> int *) fun catalan m = let fun cat a = let fun walk nil = (0, a) |walk(n::ns) = let val (r, \nn :: ns ) =walk ns in (r+(n * n ),ns ) end in let val (r, nil) = walk a in r end end fun iterate (i, \na) =ifi> m then hd a else iterate (i+1, (cat a) :: a) in iterate (1, [1]) end The local function iterate \nbuilds an intermediate list of Catalan numbers [..., C2,C1,C0]. Givensuchanintermedi\u00adate list, the local \nfunction cat yields Cn if the intermediate list starts with Cn-1. It traverses this list in the TABA \nfashion. We could even take advantage of the symmetry in the de.nition of Cn above to traverse the .rst \nhalf of the in\u00adtermediate list at call time, and to traverse the second half at return time. Let us illustrate \nthis idea of traversing the second half of a list on the momentum of traversing the .rst half. An analogy: \nconvolving the two halves of a list of even length. The following function takes a list and its length \nn,which must be even, and yields a convolution of its .rst and second halves. It does so in n/2 calls \nonly: (* cnv_halves : a list * int -> ( a * a) list *) (* walk : int * a list -> ( a * a) list *) fun \ncnv_halves (xs, n) = let fun walk (0, xs) = (nil, xs) |walk(n,x::xs) = let val (r, y :: ys) = walk (n-2, \nxs) in ((x, y) :: r, ys) end in let val (r, nil) = walk (n, xs) in r end end Applying cnv halves to \n[0,1,2,3,4,5,6,7,8,9] and 10,for example, yields [(0,9),(1,8),(2,7),(3,6),(4,5)] in .ve re\u00adcursive calls. \nThe idea applies directly to de.ning another function computing Catalan numbers using course-of-values \ninduction, with half as many calls to walk in cat.We leave this de.nition as an exercise for the reader. \n 3. Palindromes A list L is a palindrome if it is the concatenation of a list and of its reverse, with \npossibly an element in between if the length of L is odd. To detect whether a list is a palin\u00addrome, \ngiven its length, we can just traverse half of the list at call time and traverse the other half at return \ntime, as convolve halves in Section 2. But what if we do not know its length? Actually, we do not need \nto know the length of a list to reach its middle, if we use two pointers one going twice as fast as the \nother [14, Section 15.2]. Eventually, the fast one either points to the empty list or it points to a \nlist whose tail is the empty list. The slow one then points to the middle of the list. Once we have reached \nthe middle of the list, we can re\u00adturn the second half of the list and use the chain of returns to traverse \nit, incrementally comparing each of its elements with the corresponding element in the .rst half. There \nis no need to test for the end of the list, since by construction, there are precisely enough returns \nto scan both halves of the input list. Using CPS, the returns manifest themselves as a function traversing \na list, i.e., as a list iterator. 3.1 A CPS solution (* pal_c : a list -> bool *) (* walk : a list \n* a list * ( a list -> bool) *) (* -> bool *) fun pal_c xs = let fun walk (xs1, nil, k) = k xs1 (* even \nlength *) |walk(_::xs1,_::nil,k) = k xs1 (* odd length *) |walk(x::xs1,_::_ :: xs2, k) = walk (xs1, xs2,fn(y::ys) \n=> x= y andalso kys) in walk (xs, xs, fn nil => true) end Description. The local function walk is passed \nthe input list twice and an initial continuation, and it traverses the list recursively. For the i-th \ncall to walk (starting at 0), the three parameters are the i-th tail of the input list, the 2i\u00adth tail, \nand a continuation. Eventually, the continuation is sent the second half of the input list, which is \nof length n. The continuation of the i-th call is only invoked if listing the n - i right-most elements \nof the .rst half of the input list and the n - i left-most elements of the second half forms a palindrome. \nAnalysis. pal c constructs a list iterator for scanning the sec\u00adond half of the input list. This iterator \neither completes the traversal and yields true, or it aborts and yields false. The continuation is not \nused linearly and therefore writing this program in direct style requires a control operator [4]. In \nthe following direct-style solution, we choose to use an exception. 3.2 A direct-style solution (* pal_d \n: a list -> bool *) (* walk : a list * a list -> a list *) fun pal_d xs0 = let exception FALSE fun \nwalk (xs1, nil) = xs1 (* even length *) |walk(_::xs1,_::nil) = xs1 (* odd length *) |walk(x::xs1,_::_ \n:: xs2) = let val (y :: ys) = walk (xs1, xs2) in ifx= y then ys else raise FALSE end in let val nil = \nwalk (xs0, xs0) in true end handle FALSE => false end Description. The local function walk is passed \nthe input list twice and traverses the list recursively. For the i-th call to walk (starting at 0), the \ntwo parameters are the i-th tail of the input list and the 2i-th tail. Eventually, the second half of \nthe input list, which is of length n, is returned. Each i-th call returns normally if listing the n - \ni right-most elements of the .rst half of the input list and the n - i left-most elements of the second \nhalf forms a palindrome. Otherwise the computation aborts and yields false. Analysis. This direct-style \nversion demonstrates that one can detect whether a list is a palindrome in one traversal, with no list \nreversal, and using no other space than what is provided by a traditional control stack a solution that \nis more e.cient than the traditional solutions from trans\u00adformational programming [11, Example 3]. Speci.cally, \nif a list has length m, Pettorossi and Proietti count 2m hd\u00adoperations, 2m tl-operations, m cons-operations, \nand m clo\u00adsures for their solution [10, Section 2, page 410] and for Bird s solution [1]. In contrast, \nour solution requires m hd-operations if m is even and m - 1if m is odd, 2m tl\u00adoperations, 0 cons-operations, \nand 0 closures. Variations. For the same number of operations, we could halve the number of recursive \ncalls by using four pointers instead of two to traverse the putative palindrome. We could even halving \nit further by using eight pointers, etc. Using three pointers, we could also recognize 3-palindromes \n(i.e., the concatenation of three occurrences of a list of length n or of its reverse)in n recursive \ncalls. And using m point\u00aders, we could recognize m-palindromes (i.e., the concatena\u00adtion of m occurrences \nof a list of length n or of its reverse) in n recursive calls, for any given m.  4. Conclusion and issues \nMaybe because of the map functional, lists make one think iteratively (or do we still think that recursive \ncalls are ex\u00adpensive and should be avoided? [9, 13]). There is more to processing a list, however, than \nsimply traversing it. The TABA programming pattern hinges on the fact that a re\u00adcursive descent provides \njust enough expressive power to tra\u00adverse another list iteratively, at return time. Besides, since ALGOL \n60, the infrastructure for running recursive pro\u00adgrams is geared to hold multiple intermediate results \nwith\u00adout having to represent them explicitly, e.g., in an auxiliary list. (This does not necessarily \nmean that a control stack is cheaper to use than the heap, especially in the presence of .rst-class continuations \n[2].) In this article, we have put these observations to use. When convolving two lists, we have avoided \nconstructing an intermediate list for the sole purpose of reversing it. When detecting palindromes, we \nhave avoided constructing an in\u00adtermediate list for the sole purpose of traversing it again. This last \nexample has led us to a new solution for the tra\u00additional palindrome problem. Appendix A. List reversal \nThe TABA programming pattern makes it possible to write a recursive version of the reverse function that \ncompletely traverses the input list at call time and then re-traverses it at return time, constructing \nthe result. (* taba_rev : a list -> a list *) (* walk : a list -> a list * a list *) fun taba_rev xs \n= let fun walk nil = (nil, xs) |walk(_::xs) = let val (r, x :: xs) = walk xs in (x :: r, xs) end in let \nval (r, nil) = walk xs in r end end This extreme de.nition is not that alien, though, since CPS\u00adtransforming \nit and defunctionalizing the result yields the usual reverse function with an accumulator [5]. B. Convolving \nsuccessive pre.xes A simple variant of cnv2 in Section 1 makes it possible to list the symbolic convolutions \nof the successive pre.xes of two lists of length n in n recursive calls and n(n +1)/2 returns: (* cnv2 \n: a list * b list -> ( a * b) list list *) (* walk : a list * (( a * b) list * b list *) (* -> ( a * \nb) list) *) (* -> ( a * b) list list *) fun cnv2 (xs, ys) = let fun walk (nil, k) = (k (nil, ys)) :: \nnil |walk(x::xs, k) = (k (nil, ys)) :: (walk (xs, fn (r, y :: ys) =>k((x,y)::r,ys))) in walk (xs, fn \n(r, _) => r) end Indeed applying cnv2 to [1,2,3,4] and [10,20,30,40] yields [[], [(1,10)], [(1,20),(2,10)], \n[(1,30),(2,20),(3,10)], [(1,40),(2,30),(3,20),(4,10)]] The de.nition of walk is not in CPS since two \ncalls to k are not in tail position. It can still be written without the higher-order accumulator, i.e., \nin direct style, if one uses the control operator shift and the control delimiter reset [3]. Acknowledgments. \nWe want to thank all the functional pro\u00adgrammers and implicit computational complexity theorists whom \nwe subjected with the examples presented here. We are also grateful to Mads Sig Ager, Julia L. Lawall, \nHenning Korsholm Rohde, Michael Sperber, and the anonymous re\u00adviewers for comments.  References [1] \nRichard S. Bird. Using circular programs to eliminate multiple traversals of data. Acta Informatica, \n21:239 250, 1984. [2] William Clinger, Anne H. Hartheimer, and Eric M. Ost. Implementation strategies \nfor .rst-class continuations. Higher-Order and Symbolic Computation, 12(1):7 45, 1999. [3] Olivier Danvy \nand Andrzej Filinski. Representing control, a study of the CPS transformation. Mathematical Structures \nin Computer Science, 2(4):361 391, 1992. [4] Olivier Danvy and Julia L. Lawall. Back to direct style \nII: First-class continuations. In William Clinger, editor, Proceedings of the 1992 ACM Conference on \nLisp and Functional Programming,LISP Pointers, Vol. V, No. 1, pages 299 310, San Francisco, California, \nJune 1992. ACM Press. [5] Olivier Danvy and Lasse R. Nielsen. Defunctionalization at work. In Harald \nS\u00f8ndergaard, editor, Proceedings of the Third International Conference on Principles and Practice of \nDeclarative Programming, pages 162 174, Firenze, Italy, September 2001. ACM Press. Extended version available \nas the technical report BRICS RS-01-23. [6] Ronald L. Graham, Donald E. Knuth, and Oren Patashnik. Concrete \nMathematics. Addison-Wesley, 1989. [7] Luo Jian-Jin. Catalan numbers in the history of mathematics in \nChina. In H.P. Yap et al., editor, Combinatorics and Graph Theory: Proc. Spring School and International \nConference on Combinatorics, pages 68 70, Hefei, China, 1993. World Scienti.c. [8] John Launchbury and \nTim Sheard. Warm fusion: Deriving build-cata s from recursive de.nitions. In Simon Peyton Jones, editor, \nProceedings of the Seventh ACM Conference on Functional Programming and Computer Architecture, pages \n314 323, La Jolla, California, June 1995. ACM Press. [9] Y. Annie Liu and Scott D. Stoller. From recursion \nto iteration: what are the optimizations? In Julia L. Lawall, editor, Proceedings of the 2000 ACM SIGPLAN \nWorkshop on Partial Evaluation and Semantics-Based Program Manipulation, SIGPLAN Notices, Vol. 34, No \n11, pages 73 82, Boston, Massachusetts, November 2000. ACM Press. [10] Alberto Pettorossi and Maurizio \nProietti. Importing and exporting information in program development. In Dines Bj\u00f8rner, Andrei P. Ershov, \nand Neil D. Jones, editors, Partial Evaluation and Mixed Computation, pages 405 425. North-Holland, 1988. \n[11] Alberto Pettorossi and Maurizio Proietti. A comparative revisitation of some program transformation \ntechniques. In Olivier Danvy, Robert Gl\u00a8uck, and Peter Thiemann, editors, Partial Evaluation, number \n1110 in Lecture Notes in Computer Science, pages 355 385, Dagstuhl, Germany, February 1996. Springer-Verlag. \n\u00b4 [12] Jagadguru Sw\u00afam\u00afi Sr\u00afiBh\u00afarat\u00afiKrsna .. T\u00afirthaj\u00afiMah\u00afar\u00afaja. Vedic Mathematics. Motilal Banarsidass \nPublishers Private Limited, 1992. [13] Guy L. Steele Jr. Debunking the expensive procedure call myth. \nIn Proceedings of the ACM National Conference, pages 133 162, Seattle, Washington, October 1977. Extended \nversion available as MIT AI Memo 443. [14] Guy L. Steele Jr. Common Lisp: The Language. Digital Press, \n1984. [15] Robert A. Sulanke. Moments of generalized Motzkin paths. Journal of Integer Sequences, 3(00.1.1), \n2000. http://www.math.uwaterloo.ca/JIS/. [16] Hongwei Xi and Frank Pfenning. Dependent types in practical \nprogramming. In Alex Aiken, editor, Proceedings of the Twenty-Sixth Annual ACM Symposium on Principles \nof Programming Languages, pages 214 227, San Antonio, Texas, January 1999. ACM Press.  \n\t\t\t", "proc_id": "581478", "abstract": "We present a programming pattern where a recursive function traverses a data structure---typically a list---at return time. The idea is that the recursive calls get us there (typically to a base case) and the returns get us back again <i>while traversing the data structure</i>. We name this programming pattern of traversing a data structure at return time \"There And Back Again\" (TABA).The TABA pattern directly applies to computing a symbolic convolution. It also synergizes well with other programming patterns, e.g., dynamic programming and traversing a list at double speed. We illustrate TABA and dynamic programming with Catalan numbers. We illustrate TABA and traversing a list at double speed with palindromes and we obtain a novel solution to this traditional exercise.A TABA-based function written in direct style makes full use of an Algol-like control stack and needs no heap allocation. Conversely, in a TABA-based function written in continuation-passing style, the continuation acts as a list iterator. In general, the TABA pattern saves one from constructing intermediate lists in reverse order.", "authors": [{"name": "Olivier Danvy", "author_profile_id": "81100394275", "affiliation": "University of Aarhus", "person_id": "PP15031217", "email_address": "", "orcid_id": ""}, {"name": "Mayer Goldberg", "author_profile_id": "81100491789", "affiliation": "Ben Gurion University", "person_id": "PP39045428", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/581478.581500", "year": "2002", "article_id": "581500", "conference": "ICFP", "title": "There and back again", "url": "http://dl.acm.org/citation.cfm?id=581500"}