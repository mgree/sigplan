{"article_publication_date": "09-17-2002", "fulltext": "\n Interactive Visual Functional Programming Keith Hanna University of Kent Canterbury, Kent, UK fkh@ukc.ac.uk \nABSTRACT An interactive graphical environment for supporting the de\u00advelopment and use of Haskell applications \nprograms is de\u00adscribed. The environment, named Vital, is particularly in\u00adtended for supporting the open-ended, \nincremental develop\u00adment style often preferred by non-specialist users in which successive steps of program \ndevelopment are motivated and informed by results so far obtained. Signi.cant features of Vital include:the \ngraphical dis\u00adplay of data structures in a format de.ned by a datatype\u00adindexed stylesheet, the way that \nevaluation of (possibly in\u00ad.nite) values is demand-driven by the action of the user scrolling around \nan unbounded workspace, and support for copy-and-paste graphical editing of data structures. This latter \nallows, for example, the user to modify a complex data structure by point-and-click operations, or to \ncreate (by functional evaluation) a regular data structure and then edit values or expressions into it. \nThe e.ect of each editing operation is immediately re.ected in the Haskell program source code.  Categories \nand Subject Descriptors D.1.1 [Software]:Programming Techniques  General Terms Languages, Design, Human \nfactors  Keywords Functional, visual, interactive, edit, live, stylesheet, Haskell. 1. INTRODUCTION \nFunctional programming languages, such as Haskell, al\u00adthough they embody many desirable properties, are \nnot yet widely used outside academia[22]. Conversely, another class of declarative language, the spreadsheet \nlanguages, although they embody few desirable properties[6], are very widely Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for profit or commercial advantage and that copies bear this \nnotice and the full citation on the first page. To copy otherwise, to republish, to post on servers or \nto redistribute to lists, requires prior specific permission and/or a fee. ICFP 02, October 4-6, 2002, \nPittsburgh, Pennsylvania, USA. Copyright 2002 ACM 1-58113-487-8/02/0010 ...$5.00. used. Indeed, for every \nuser of Haskell, there are perhaps (as an informal estimate) some 105 users of spreadsheets. Arguably, \nthere are two real advantages o.ered by the spreadsheet style of programming. Firstly, the facility they \no.er to de.ne simple data structures (albeit it limited to untyped rectangular arrays), to display their \ncontents in an easily comprehensible form (ie, as labelled tables) and to provide direct editing of their \ncontents (by direct keyboard entry and by copy-and-paste operations). Secondly, the live\u00adness of the \nspreadsheet system:the fact that the results of updates are immediately visible and the overall display \nis always in a consistent state. These two factors particularly support an incremental approach to program \ndevelopment in which the task to be accomplished may not be well-de.ned at the outset but, rather, is \ninformed and motivated by the actual data and intermediate results (this is characteristic of much everyday \nprogramming activity). Of course, the drawbacks of spreadsheet programming are all too obvious; the impoverised \nsemantics (typically a .rst\u00adorder, weakly-typed language with no facilites for functional abstraction \nor for user-de.ned types) leads to spreadsheets that are verbose, opaque and highly prone to error. For \ninstance[16]: . . . Freeman (in 1996) cites data from the expe\u00adrience of a consulting .rm, Coopers and \nLybrand in England, which found that 90% of all spread\u00adsheets with more than 150 rows that it audited \ncontained errors. . . 1.1 Vital The Vital project[12] aims to combine the complementary strengths of \nthese two, very di.erent, classes of declarative language. That is, it seeks to combine the expressiveness, \nclarity and soundness of Haskell with the direct data display and liveness of the spreadsheet. A typical \nuser will be an analyst or engineer who has some knowledge of Haskell and who is using a supplied library \nof types, functions and styles to accomplish a task for which the expressiveness (semantic or graphical) \nor integrity of an ordinary spreadsheet system is inadequate. In the remainder of this paper we outline \nthe main features of the Vital approach and its relation to existing work. We then discuss, in more detail, \nthe way that the look-and-feel of Haskell datatypes are de.ned by using stylesheets, the way that large \n(or in.nite) data structures are handled, and the semantics of various modes of editing.  2. OVERVIEW \nAVital script consists of a collection of Haskell declara\u00adtions. These individual declarations may be \ninteractively entered by the user and each one placed at a chosen location within an unbounded 2-dimensional \nworkspace. The user can specify that the values de.ned by particular declarations are displayed in a \ngraphical form within the workspace. The form that this representation takes for each Haskell type is \nde.ned by a stylesheet. A stylesheet is a structured collec\u00adtion of attribute name-value pairs; it is \nassociated with, but is not part of, the Haskell script. The Vital workspace is live in the sense that \nthe value of a component of a data structure can be changed by editing operations (such as copy-and-paste) \non its graphical repre\u00adsentation and such changes are immediately re.ected in the Haskell source code \nof the script and hence in the resultant displayed values. This feature allows a user to create empty \ndata structures (thought of as containers)and then, ata later stage, to edit data into them. 2.1 An example \nAs an example, suppose the user wished to create a trian\u00adgular array and then to populate it, perhaps \nsparsely, with data. The user begins by entering a Haskell declaration for a function1 that will build \na concrete representation of an empty triangular array (taking the form of a list of lists of Nothing \nvalues): triArray n = v [[Nothing|j<-[1..i]|i<-[1..n]] At the same time, the user loads (or creates) \nan appropriate stylesheet for the desired graphical representation of Haskell values of this type. The \nuser then creates an instance of (for example) a 5 by 5 triangular array by entering the declaration \nta = triArray 5 This will (depending on the stylesheet) give rise to a display like Fig. 1 The user might \nalso enter other related declarations, such as a declaration for a function arraySum that sums the values \nof the non-empty cells of an array and a declaration s = arraySum ta to sum the above array. The user \ncan then populate the empty array with data by clicking its individual cells and typing in expressions \nsuch as Just 12. (Cell values can also be entered using copy-and\u00adpaste editing operations between cells.) \nAs each expression is entered, the Haskell source script and overall display are immediately updated. \nA typical resultant display is shown in Fig. 2. The stylesheet used for this example speci.ed that: \nOnly the actual list data (and not the list structure) is visible.  Nothing values (of the standard \nMaybe datatype) are displayed as blank cells, and only the n component of Just n values are displayed. \n 1For the moment, treat the function v as if it is the identity function. Its purpose is explained in \n\u00a74.2. The de.nition for triArray (but not its value) is dis\u00adplayed, neither the de.nition nor value for \narraySum is displayed, but both the de.nitions2 and values for ta and s are displayed. At any stage, \nthe modi.ed Haskell script can be saved. Restoring this program on a later occasion (and specifying the \nsame stylesheet) would reconstitute an identical display (which could, if desired, be subjected to further \nediting or incremental extension). 2.2 The workspace In general, the graphical representation of a value \nmay be large or even in.nite. In accordance with Haskell s non\u00adstrict semantics, only those components \nof a value that are required for display within the current viewport are evalu\u00adated. At any time, the \nuse may use the mouse to drag the workspace relative to the viewport and so force the evalu\u00adtion and \ndisplay of further components of a value. As an example, suppose the current script consists of the declara\u00adtions \nns=[0, 5 ..] ms=map(*2) ns and the user has selected a stylesheet that causes these lists to be displayed \nas horizontal sequences of cells. This will cause a pre.x of the two in.nite lists to be evaluated and \ndisplayed (Fig. 4). But, by dragging the workspace left\u00adwards, the user can force the evaluation and \ndisplay (Fig. 5) of any further section of the lists.  2.3 Algebraic datatypes It is often appropriate \nto introduce user-de.ned algebraic datatypes for representing particular kinds of data. For ex\u00adample, \nthe following dataype would be suitable for repre\u00adsenting a family tree: data Person = Unknown | Person \n{name :: String} | Parents {father :: Person, name :: String, mother :: Person} A particular advantage \nof introducing a new datatype in Vi\u00adtal is that it allows (via the stylesheet) detailed control over \nthe graphical representation of values of that type. For in\u00adstance, a stylesheet might specify that values \nof type Person are to be represented as in Fig. 3. Here the stylesheet spec\u00adi.es that: All three .elds \nin values of the form Parents t1 s t2 are to be displayed (with the values of t1 and t2 to be displaced \nsideways and downwards). The constructor itself is not to be shown but .eld labels are to be.  The .eld \nin values of the form Person s is to be dis\u00adplayed in-place, and neither the constructor nor the .eld \nlabel is to be shown (as illustrated by the mother of Athelstan in the image).  Values of the form Unknown \nare not to be shown at all (as illustrated by the mother of Osburg).  2Normally the de.nition of a bulky \nliteral like ta would not be displayed; it is displayed here only for purposes of illustration.  Figure \n1: An empty triangular array of Maybe values Figure 2: The triangular array after it has been partly \n.lled. The editor panel is also visible. Figure 3: A family tree Figure 4: Display of two lists  Figure \n5: Display of the lists after the workspace has been dragged some distance to the left In addition to \nthe pointwise entry of expressions into data structures (as described earlier), Vital also supports mouse\u00addriven \ncopy and paste editing operations. For example, an arbitrary subtree (of type Person) may be selected, \ncopied to the clipboard and, later, pasted in to de.ne or update a component (of type Person) of another \ndata structure. As before, the corresponding Haskell declaration in the script is updated to re.ect the \nchange. (Editing operations are described in detail in \u00a76.) 2.3.1 Guarded datatypes Quite often there \nare occasions where a datatype could bene.cially be used in place of an abstract type if it were possible \nto restrict the domains of the constructors of the former (a typical example is described in \u00a74.4). It \nturns out that the ability to do this is especially useful in the present context given the editing and \nstylesheet mechanisms avail\u00adable for datatypes. Accordingly, the dialect of Haskell used in Vital is \nextended with a construction that allows a guard to be associated with each constructor in a datatype. \nSuch a guard takes the form of a predicate on the .eld names of the constructor and has the e.ect of \nrestricting the domain of the constructor to those arguments for which the guard evaluates to True. As \nan example, here is a datatype declaration for non\u00adempty intervals data Interval = Intvl {lower, upper \n:: Float | lower < upper} Given this declaration, an expression like Intvl exp1 exp2 is treated as equivalent \nto let {v1 = exp1; v2 = exp2} in if v1 < v2 then Intvl_ v1 v2 else error \"Domain error\" (where Intvl_ \nrepresents the unguarded constructor). Thus, evaluating an expression like Intvl 2.05.0 will construct \na value of type Interval whilst evaluating one like Intvl 5.02.0will give rise to a domain error. Any \npattern\u00admatching operation on values of this type can therefore rely upon the above invariant being respected, \nirrespective of the context in which the value was constructed.  2.4 Implementation The approach described \nhere has been prototyped and is available (together with accompanying tutorial materi\u00adals) for downloading \nfrom [12]. The prototype system does not (at present) implement the whole of Haskell; in partic\u00adular \ntype checking and type classes are not yet present (an approach along the lines of the incremental type-checking \nscheme of Aditya[1] is planned). There are also signi.cant omissions and variations from standard Haskell. \n 3. RELATED WORK The computational realisation of a spreadsheet (hitherto the term denoted a paper document) \nwas introduced by Bricklin[2] and, including subsequent commercial embellish\u00adments, it embodies several \nkey concepts upon which Vital builds: A workspace in which formulae (expressed in a declar\u00adative notation) \ncan be located and their values dis\u00adplayed.  Copy-and-paste editing operations and, more gener\u00adally, \nthe principle of direct manipulation[21] (namely that there is a continuous representation of the objects \nof interest and that the e.ects of user interaction are immediately visible).  The use of a stylesheet \nto de.ne the way data is pre\u00adsented, independently of the data itself.  Other systems, including widely-used \ntechnical comput\u00ading environments and computer algebra systems (such as Mathcad and Mathematica) are \nalso built on similar foun\u00addations (the latter even supporting the use of higher-order functions[14]). \nThere are also many experimental systems of this genre, of which the following are particularly relevant: \n The FunSheet system [9] is an implementation of a conventional tabular spreadsheet system but with the \ncell formulae being expressed in a non-strict, higher\u00adorder functional language.  The FORMS/3 system \n[5] is a declarative, .rst-order language with facilities for data abstraction. It allows the user to \nassociate a user-de.nable, iconisable graph\u00adical representation (a form ) with each record type. Each \n.eld of a form may depend functionally on other .elds or its value may be set by user interaction.  \nThe Functional Hypersheets system [8] is a proposal for a set of generalised spreadsheets termed hyper\u00adsheets. \nEach hypersheet represents the types and bind\u00adings (lazily evaluated) of a Haskell module, may con\u00adtain \nhyperlinks to other hypersheets, and may have a user-de.nable graphical representation.  More generally, \naspects of Vital draw upon concepts and techniques introduced in the .eld of visual programming lan\u00adguages \n(see [3] for a comprehensive bibliography). Within this .eld, several papers have have explored graphical \nrep\u00adresentations for the abstract syntax of functional programs [13, 20, 19, 7]. Apart from the niche \napplication areas of sig\u00adnal/image processing, such techniques have not been widely adopted, perhaps \nbecause such syntactic representations do not scale well (they tend to be bulky compared with text). \n 4. STYLESHEETS In Vital, the abstract values are de.ned by Haskell scripts whilst the presentation \n(or look and feel) of these values are de.ned by stylesheets. This allows a clean separation be\u00adtween \nconcerns with the correctness of a script and concerns with the aesthetics of its presentation. In some \ninstances, these two concerns may be the responsibility of di.erent in\u00addividuals. A stylesheet for a \nscript consists of: A family of declaration styles that de.ne aspects such as the location in the workspace \nof each value declara\u00adtion and its display modes (ie, name and/or de.nition and/or value) .  A family \nof datatype styles (described below in more detail) that de.ne the way that the values of each datatype \nare presented.  A workspace style that de.nes behavioural aspects (such as evaluation depth limits for \ncatching unbounded re\u00adcursion) and stylistic aspects (such as background grids and default styles for \nthe above families of styles) of the overall workspace and evaluation mechanism.  Scripts and stylesheets \nare only loosely related; a given script may be customised with di.erent stylesheets and a given stylesheet \nmay be applied to di.erent scripts. Scripts and stylesheets are stored in di.erent .les. 4.1 Datatype \nstyles Suppose that the declaration for the ith datatype is of the form data Ti ... = ... |Cij {..., \naijk :: tyijk, ...}| ... (where aijk is the .eld name associated with the kth argu\u00adment position of Cij \n,the jth constructor). Then the part of a stylesheet that de.nes datatype attributes includes an i-indexed \nfamily of datatype styles, each of which includes a j-indexed family of constructor styles, each of which \nincludes a k-indexed family of .eld styles. Each of these styles consists of a collection of attributes \n(ie, name-value pairs), each of which de.nes some aspect of the presentation. For example, the attributes \nassociated with each constructor specify: Whether or not it is visible.  Its dimensions and colours. \n Its orientation (whether its .elds are laid out horizon\u00adtally or vertically).  Whether or not its \n.eld labels (such as head and tail) are displayed.  In a similar way, the attributes associated with \neach .eld specify: Whether or not it is visible. (This a.ects its behaviour under editing; an invisible \n.eld cannot be selected and hence its contents cannot be modi.ed.)  Its dimensions and colours.  An \n(optional) o.set for the contents of the .eld. If an o.set is non-zero, then a link is shown relating \nthe displaced contents to the .eld.  The ability to displace the contents of a .eld is of particular \nrelevance with recursive datatypes (where the contents of a recursive .eld can be arbitrarily large). \nFor instance, the Prelude de.nes the standard list type as data List a = Nil | Cons {head :: a, tail \n:: List a} (with the standard [] and : notation available as a syntactic alternative). The Prelude stylesheet \nassociates a horizontal linked style with the Cons constructor. Thus, by default, the list ns=[0,5..] \nappears as shown in Fig. 6. However, by changing the stylesheet (so that neither constructors, tail cells, \nlinks nor .eld names are shown) lists can be displayed in the more natural form shown earlier in Fig. \n4. Default styles It would place a heavy burden on the user if it were necessary to de.ne the attributes \nindividually for each constructor of each datatype, and for each .eld of each constructor. To avoid this, \ninheritance/delegation is extensively used to de\u00ad.ne default values. For example, by default all .elds \nof a datatype inherit their style from their constructor .eld style, in turn inherited from their datatype \n.eld style, in turn in\u00adherited from the workspace .eld style. This latter style is de.ned by the Prelude \nstylesheet.  4.2 2-D layouts Tabular data structures can be represented by nested lists. In order to \ndisplay such a structure in a 2-dimensional form, it is necessary to be able to render the outer list \nvertically and the inner one horizontally. One way of achieving this is to introduce a variant form of \nlist data VList a = VNil | VCons a (VList a) The style of the VCons constructor can then be set so that \nit is laid out vertically and this datatype can be used for the outer list. So as to allow the existing \ncollection of list com\u00adbinators (map, foldr, etc.) to be used with both ordinary lists and variant lists, \na bijection v :: List -> VList and h :: VList -> List is de.ned for mapping between these two forms. \nAs an example of this approach, consider again the func\u00adtion introduced in \u00a72.1 for de.ning triangular \narrays: triArray n = v [[Nothing|j<-[1..i]|i<-[1 .. n]] The inclusion of the v function means that this \nfunction yields results of type VList (List (Maybe a)) Using the Prelude stylesheet (with a minor adjustment \nto displace the contents of head .elds downwards) to display the value of, for example, triArray 5 results \nin the (rebarbitive) display shown in Fig. 7. However, by adjusting the stylesheet so that: The VNil \nconstructor and the VCons constructor (and both its .elds) are invisible.  The Nil constructor and the \nCons constructor (and both its .elds) are invisible.  The Just constructor (but not its .eld) is invisible \nand the name of the Nothing constructor (but not the constructor itself) is invisible.  the visually \ndistracting sca.olding can be entirely removed and triangular arrays displayed as shown in Fig. 2 earlier. \n Figure 6: The default style for the List datatype Figure 7: A triangular array as displayed using \nthe default Prelude stylesheet 4.3 Implementation The stylesheet scheme outlined above is fully implemented \nin Vital. Although the above description may have given a contrary impression, the system is, in fact, \nrelatively straight\u00adforward and natural to use. The mechanism used for setting attributes uses three, \ndependently-linked, tables (Fig. 8). Each table has a drop-down list and an update button. On the .rst \ntable, the drop-down list allows the user to select from the set of the datatypes (Bool, Maybe, ..., \nList, . . . ) de.ned in the Prelude or script. Once this choice(eg, List) is made, the drop-down list \nin the second table changes to allow the user to select from the set of con\u00adstructors (eg, Nil and Cons) \nof the selected datatype. Once this choice (eg, Cons) is made, the drop-down list in the third table \nchanges to allow the user to select from the set of .elds (eg, head and tail) of the selected constructor. \nEach of the three tables of attributes so selected presents a list of at\u00adtributes (controlling all aspects \nof the geometry, labelling and appearance of values of the datatype). The user can set these attributes \nat the datatype level, at the constructor level or at the level of individual .elds. Settings at either \nof the upper two levels can be propagated downwards by press\u00ading one of the Update buttons). Using separate \ntables (not shown) attributes controlling the presentation of the entire workspace and of each value \ndeclaration can be set. Finally, there are controls allowing both scripts and (independently) stylesheets \nto be saved to .le and restored from .le. Internally, a stylesheet is stored in a hierarchical data structure \nthat parallels the structure of the program at run\u00adtime. The structure is optimised for rapid access \nduring rendering operations. Since stylesheets and programs are logically distinct, the implementation \nneeds to be able to generate default values for any missing datatype styles and it needs to be able to \nkeep a stylesheet consistent when a program is edited (for example, when datatypes, construc\u00adtors or \n.elds are added or removed).  4.4 Authentication A major bene.t a.orded by the use of a strongly-typed \nlanguage is that its type discipline can be used to guar\u00adantee that constructed values satisfy a given \ninvariant. In standard Haskell, this can be achieved by not exporting the constructors of a datatype \nfrom the module in which they are declared. In the Vital dialect of Haskell, the guarded datatype construction \n(described in \u00a72.3.1 earlier) can be used to achieve a similar e.ect without requiring the use of a module \nstructure. This mechanism is supported by the conventions used in displaying datatype values; their constructors \nare given a distinctive appearance (a corner is truncated). By this means, the possibility of some stray \ndatatype .eld value being used (either accidentally or deliberately) to mimic a constructor is excluded. \nIn turn, this means that the display of a constructor provides an unforgable guarantee that any invariants \nassociated with its type have been respected. As an example of the use of this feature, consider a user \nwho wishes to be able to construct proofs of propositional logic tautologies in a natural deduction sequent \ncalculus and to be able to convince a sceptic of their soundness.Since for\u00admulae and sequents are unconditionally \nwell-formed, they can be represented by ordinary datatypes. However, proofs (ie, derivations of theorems) \nare only well-formed if, in their construction, they satisfy a certain, inductively-de.ned in\u00advariant \n(namely, that they respect the rules of inference of the calculus). Such proofs can be represented (see \n[11] for principles) by a guarded datatype of the form: data Proof = Assume Form | AndIntro Proof Proof \n| AndElimL {pr :: Proof | isAndElimL pr} ... | ModusPonens { pr1, pr2 :: Proof | isModusPonens pr1 pr2} \n Figure 8: Tables used for setting attributes associated with datatypes. In the .rst table, the List \ndatatype has been selected, in the second, the Cons constructor of this type has been selected and in \nthe third, the tail .eld of this constructor has been selected. This latter table shows that background \ncolour of a tail cell is white (coded as 7), its contents are displaced 100 units to the right, its size \nis 50 by 15 units and it is not invisible. Each constructor of the datatype corresponds to a rule of \nin\u00adference of the calculus (Assumption, And-introduction, And\u00adleft-elimination, ..., Modus ponens) with \nthe guard predi\u00adcates being used to guarantee that the values of their argu\u00adments conform to the structure \nof the hypotheses required by their respective inference rules. For instance, the guard associated with \nthe ModusPonens constructor checks that the proofs associated with its two arguments establish theorems \nthat conform to the structure of the hypotheses in the rule: G1 . f . . G2 . f Modus Ponens G1 . G2 . \n. The end result is that the display of a constructor of type Proof provides an (unforgable) guarantee \nthat the object, irrespective of its context or origins, does indeed represent a sound proof. Similar \nprinciples can be used in other domains (such as .\u00adnance) to guarantee the integrity of constructed values \n(rep\u00adresenting objects such as a complex invoice or a company balance sheet).  4.5 Discussion The stylesheet \nsystem as described above is fully imple\u00admented in Vital and allows a wide range of useful e.ects to \nbe achieved across a wide spectrum of examples. But, it su.ers from one signi.cant limitation:it does \nnot scale well for larger, more complex programs. 4.5.1 Parameterised styles The root of the problem \nis that, in practice, one often needs to be able to apply di.erent styles to values of the same type. \nFor example, in the case of lists, one may wish to render one list horizontally but another one vertically. \nSometimes, one may even need a diagonal rendition (for in\u00adstance, for displaying a triangular array symmetrically). \nOn other occasions, a more abstract rendition in which element values are suppressed may be appropriate. \nThe present ap\u00adproach, in which it is necessary to introduce variants (such as List and VList) of a datatype \nto allow di.erent styles to be imposed is clumsy. However, with some relatively minor modi.cations and \nextensions, this problem can be overcome. The revised mechanism (not at present implemented) will allow \nstyles to be named and to be parameterised and hence allow more than one style to be associated with \na particular type. The user will then have a choice of styles that can be applied, independently, to \neach value declaration. For in\u00adstance, with a base type such as Int a user might choose to de.ne styles \nsuch as SmallInt, RightJustifiedInt, ElidedInt, and so on. Likewise, with a type constructor such as \nList, a user might choose to de.ne style constructors such as BasicList, HorizontalList, CompactVerticalList. \nThese will take a style as a parameter, thus allowing the user to specify styles such as HorizontalList \nSmallInt,or CompactVerticalList (BasicList RightJustifiedInt) and so on. These styles can then be associated \nwith indi\u00advidual value declarations (of conforming type). 4.5.2 Other attributes Although the existing \nsystem allows a wide range of style attributes, the need has been identi.ed for yet others, in\u00adcluding: \n An attribute to specify that values of scalar types should be rendered/controlled by widgets (booleans \nby checkboxes, enumerated types by radio buttons, .oats by sliders, etc.) rather than textually.  An \nattribute to specify that a particular value declara\u00adtion should be windowed. (The present system cannot \nhandle the display of more than one in.nite 2-D array at a time since they necessarily overlap. The ability \nto associate individual viewports with such declarations will avoid this problem.)  An attribute to \nspecify that a component of a value should be displayed in textual form rather than graphi\u00adcal form. \n(This will allow textual syntax and graphical syntax to be freely mixed at all levels in a data struc\u00adture. \nThis is useful since a textual representation is usually more compact than a graphical one. For ex\u00adample, \nwhen constructing or viewing a proof tree, the spine of the tree should be rendered graphically but the \nvalues at its nodes (ie, the theorems) are better rendered textually.  An attribute to inhibit evaluation \nof a particular .eld of a data structure until explicitly requested. (Some data structures, such as game \ntrees, may be too proli.c to allow the components of even a single node to be properly displayed. This \nattribute would allow a user to selectively explore a particular path through a large or in.nite structure.) \n  Figure 9: The active region is the smallest rectangle that contains both the origin and the viewport. \n  5. EVALUATION STRATEGIES Haskell semantics are non-strict (or lazy); that is to say, evaluation of \nan expression is demand driven by the output device. In the case of Vital, evaluation is driven by the \nneed to render the region of the workspace visible through the viewport. (In this respect, it is similar \nto several other visual programming environments, including [15, 10, 5].) In outline form, the algorithm \nused to render the viewport is: 1. Render the background of the viewport (the rendering of any grids, \netc will depend on the current o.set of the viewport) 2. Consult the stylesheet to determine the root \nlocation Li of each declaration Di in the program, then render Di.  To render a value declaration D \nat root location L Consult the stylesheet to determine which combination of its aspects (its name, its \nexpression E, the value of E) are to be visible, then render them accordingly. To render the value of \nan expression E at a root location L. Determine whether L is within the active region of the workspace \n(see Fig. 9). If so, then invoke the evaluator to reduce E to weak head normal form (sim. to nor\u00admal \nform, except that constructor arguments remain unevaluated[17]).  Consult the stylesheet to determine \nhow the construc\u00adtor (or primitive value) should be rendered and the visibility and o.sets of each of \nits .elds. Then com\u00adpute the root locations, Li, for each of its .elds (i in 1 .. constructor arity)., \nand identify the argument subex\u00adpressions Ei  Then recursively render each of the Ei at root location \nLi.  If the user subsequently changes the o.set of the viewport (by dragging the workspace with the \nmouse) then this causes the above process to be repeated. However, since the decla\u00adrations are already \nin a partly (or totally) evaluated state, there may be little or no extra reduction required. (In prac\u00adtice, \nthe workspace usually appears to scroll smoothly when dragged as there is little computation required \nto update the display.) 5.1 Localisation of errors Standard Haskell semantics require that the occurrence \nof a (run-time) error immediately terminates the overall pro\u00adgram. However, one of the intended uses \nof Vital is for de\u00adveloping programs in an incremental, exploratory mode in which results gained from \na partially developed program are used to inform and motivate further development. To facil\u00aditate this \nmode, Vital deviates from standard Haskell error semantics[18] and, in common with many other visual \nenvi\u00adronments, uses an approach based on error-values[4]. This allows the e.ects of any errors in a Vital \nprogram to be con\u00adtained as tightly as possible (since the results a program does produce may be useful \nin their own right or for diagnosing the sources of a problem).  An error in the syntax of a declaration \nresults in an error indication being shown at the root location of the declaration and the declaration \nbeing ignored, but does not otherwise a.ect the rest of the program.  Type checking is not at present \nimplemented. (An incremental approach, along the lines suggested by Aditya[1] is planned and will be \nimplemented in such a way that an isolated type error causes minimal dis\u00adruption.)  During evaluation, \nerrors are usually due to:  1. unde.ned values (eg, due to unbound identi.ers) and out-of-range values \n(eg, division by zero or unsatisi.ed pattern matches).  2. unbounded recursion. This is trapped by a \n(stylesheet settable) limit on the numbers of reduction steps allowable for reaching WHNF when evaluating \na subexpression. (At any stage, the user can in\u00adcrease this limit, and continue exploration of a data \nstructure.)   In either case, the erroneous expression is deemed to have an Error value (which propagates \nupwards through functional application as far as the .rst containing con\u00adstructor) and is rendered as \nan Error marker. For ex\u00adample, entering the declaration ns =[1,2, div 30,zz, f0,6] (where fn= f(n+1) \nand zz is an unbound variable) will display the entire list with error markers in posi\u00adtions 3, 4 and \n5.  5.2 Discussion This evaluation mechanism is more .exible than the serial output stream mechanism \nusually employed by lazy func\u00adtional languages (whether or not monadic). With the latter, further evaluation \nof an expression to WHNF, and thence to normal form, always takes place in normal order (ie, the arguments \nto the leftmost, outermost constructor are re\u00adduced .rst). With the present system, however, the order \nof reduction is determined by the direction in which the user moves the viewport. For example, given \nan in.nite, two-dimensional array (such as table, earlier) moving the viewport rightwards will force \nfurther evaluation of the inner lists whereas moving it downwards will force further evalu\u00adation of the \nouter list and part evaluation of a new inner Figure 11: Ragged array list. In the case of a large or \nin.nite tree (for example, the game tree for chess) this would allow the user to explore, in reasonable \ntime, a given path through the tree3 . One limitation of this user-driven evaluation technique arises \nwhen the stylesheet speci.es that a .eld of a con\u00adstructor is displaced leftwards or upwards relative \nto the constructor. Consider, for example, the following program dataPath =L Path |R Path |U Path |D \nPath|End path = (D.D.D.R.R.R.U.U.R.R.D.D.D.R.R) path and assume that the stylesheet is set so that the \nargument of the constructor L is displaced to its left, that of the con\u00adstructor U to above it, and so \non. This will (Fig. 10) re\u00adsult in an in.nite path that meaders in a generally right\u00adwards/downwards \ndirection across the workspace. No mat\u00adter where the viewport happens to be located, the path will be \ndisplayed without any problem. If, however, the path were such that it meandered .rst in a rightwards/downwards \ndirection before looping back on itself then evaluation would cease before this latter section had been \nreached and so it would not be displayed. Since a path can be arbitrarily long before turning back on \nitself, there is in principle no means by which this kind of problem can always be overcome. In practice, \nit can usually be avoided by judicious choice of style parameters.  6. EDITING A key feature of Vital \nis the way in which it allows editing operations to be carried out on data structures. An opera\u00adtion \nmay simply involve a pointwise change to the contents of a .xed data structure (as was illustrated in \n\u00a72.1) or it may involve changes to a structure itself. For example, an easy way (see Fig. 11) to create \na ragged array is .rst to set up an in.nite array and then to prune it to the desired shape (by truncating \nits sublists). Conversely, one way to create an in.nite, repeating data structure (such as the path shown \nin Fig. 10, earlier) is .rst to create a .nite one and then to loop it back on itself (by editing leaf \ncells to refer back to the overall structure). 3Limitations in the present implementation have prevented \npractical exploration of this technique. Although the editing operations are nominally presented as operations \non Haskell values, the operations in fact mod\u00adify the Haskell source code of the program. This indirect \napproach brings two advantages: Portability. Since the end result of an editing session is an ordinary \nHaskell program, Vital can be used as a supportive interactive environment in which to develop and validate \nHaskell programs and datasets that may subsequently be run o.-line elsewhere.  Persistence. It allows \na program and its associated stylesheet to be saved to disk at any stages in its de\u00advelopment and later \nreinstated, thus allowing develop\u00adment and use to be spread over more than one session.  The Vital GUI \nis live; that is to say, the e.ect of any change is immediately visible in the workspace. The user is \nresponsible for ensuring that each change is syntactically correct and well typed. (In retrospect, it \nwould sometimes be useful if it were possible to group sequences of edits to\u00adgether since, in practice, \nsome changes necessarily involve going via inconsistent states, and visual feedback from such states \nis distracting.) 6.1 Kinds of editing Vital supports two distinctive kinds of editing operation (as \nwell as, of course, simple textual editing of the script): Copy-and-paste editing. The user can select \n(by double\u00adclicking) a location in a data structure displayed in the workspace and then press the Copy \nbutton to cause the subexpression at that location to be copied to the clipboard. From here, it can be \ninserted into another location by selecting that location and pressing the Paste button. (A location \nmaybeeitherthe entire RHS of a value declaration or, if the RHS denotes a data structure, it may be any \n.eld of any constructor within the data structure.)  Insert editing. The user can select a location \nin a data structure and type in a Haskell expression de.ning a new value for the contents of that location. \n(This is essentially a special case of copy-and-paste editing and is not considered further.)  6.1.1 \nEditing modes Both copy and paste operations can be carried out in ei\u00adther of two modes: by value or \nby reference4.The choice of mode de.nes whether evaluation is immediate or deferred, and determines whether: \n editing can take place on in.nite values or on values (such as functions) that cannot be displayed. \n the modi.ed declaration retains its dependence on pos\u00adsible subsequent changes to other declarations; \n The two modes o.er complementary features. The seman\u00adtics for a copy operation from a location loc \nin a source expression can be: Copy by value:The sub-expression at loc (which must be of an displayable \ntype) is fully evaluated. This value (which must be .nite) is unparsed and the resultant string is inserted \nin the clipboard. 4The reference mode is not supported by the present imple\u00admentation of Vital.  Copy \nby reference:A Haskell let-expression is created that will (if/when evaluated) extract the required com\u00adponent \nfrom loc and this expression (in textual form) is inserted in the clipboard. The semantics for a paste \noperation to a location loc in a target declaration can be: Paste by value:The RHS of the target declaration \n(which must be of an displayable type) is fully eval\u00aduated. This value (which must be .nite) is then \nun\u00adparsed, but with the contents of the clipboard replac\u00ading the subvalue at location loc. The resultant \nstring is then adopted as the RHS of the updated target dec\u00adlaration.  Paste by reference:A Haskell \nlet expression is created that will (if/when evaluated) yield the value of the original expression but \nwith the content of location loc replaced by the contents of the clipboard. The RHS of the target declaration \nis then overwritten with this let expression.   6.1.2 Example A simple example will clarify the above \ndescription and illustrate the particular bene.ts o.ered by each combination of modes. Assume the following \ndeclarations: n=3 m=5 ps=[i*n|i<-[1..4]] --[3, 6, 9, 12] qs = [(m-1) .. (m+1)] --[4, 5, 6] and assume \nthat the source location is the tail of the value of ps (that is, the subterm [6, 9, 12]) and the target \nlocation is the tail of the tail of the value of qs (that is, the subterm [6]). Then there are four combinations \nof modes of edit operation possible; each of these cause the declaration for qs to depend on the declarations \nfor n and m in a di.erent way. Copy by value, paste by value. This mode forces imme\u00addiate evaluation \nof both source and target expressions, and creates the declaration: qs=4:5:6:9:12: [] This is a pure \nvalue (in e.ect, a structured literal); it has no remaining dependency on any other declaration. It is \nmaximally e.cient (in both space and time). It is espe\u00adcially suitable for the cases where a dataset \nis incrementally constructed by a large number of individual edit operations since (unlike the remaining \ncases) the complexity of the re\u00adsultant declaration is independent of the number of editing operations. \nCopy by reference, paste by value. This mode forces im\u00admediate evaluation of its target declaration but \nuses pat\u00adtern matching to extract the selected subexpression from its source. qs=let _:rs=ps in4: 5:rs \nSince evaluation of the selected subexpression is not forced, it may denote a value that is in.nite or \nis not displayable (eg, a function). The modi.ed declaration for qs will carry forward a dependence on \nthe original declaration of ps (and so also of n). Thus, any subsequent edits to the latter will be faithfully \nre.ected in the former. The mode also has the advantage that the edited declaration contains the original \nversion of the declaration within it, and thus allows an ex\u00adperienced reader of the Haskell source code \nto understand the way the program was developed. Copy by value, paste by reference. This mode forces \nim\u00admediate evaluation of its source declaration but uses pattern matching to insert the selected subexpression \ninto the tar\u00adget. qs=letq1:q2:_=[(m-1) .. (m +1)] in q1: q2: 6: 9: 12: [] Since evaluation of the target \n(ie, the container datastruc\u00adture) is not forced, it may denote an in.nite value. This mode o.ers two \nsigni.cant advantages: It allows point changes to be made in an in.nite struc\u00adture. For example, if a \ncalendar is represented as an in.nite list of (Date, [Event]) pairs then, using this mode, particular \nevents (meetings, etc.) could be edited into the calendar at any point. If a container datastructure \n(for example, n=10, ta = triArray n, a triangular array of size 10) is set up and data is edited into \nit, then the size of the con\u00adtainer may subsequently be edited (eg, n=12) without losing the data. Copy \nby reference, paste by reference. This mode uses pattern matching both to extract the selected subexpression \nfrom the source declaration and to insert it in the target. qs=let_:ps1 =ps q1: q2:_=[(m-1)..(m+1)] in \nq1: q2: ps1 It o.ers the maximal .exibility; either of the source or tar\u00adget can be in.nite and need \nnot be displayable, and any subsequent edits in either will be faithfully re.ected in the result.  6.2 \nDiscussion The editing operations outlined above blend well with the semantics of Haskell. The blurring \nof the normally rigid distinction between edit-time operations and run-time ones works well only in the \ncontext of a pure declarative language and the provision of the two editing modes allows both for e.cient \nhandling of simple concrete values (numbers, etc.) as well as for .exible manipulation of functional \nvalues and in.nite data structures. In practice, the editing operations have been found to be intuitive \nand easy to use.  7. CONCLUSIONS The kinds of task for which Vital is intended are those (in domains \nsuch as engineering and .nance) in which com\u00adplex data structures are incrementally developed, in which \nprogram development is likely to be results-driven in an ex\u00adploratory manner and (especially) those that \ncan bene.t from the expressiveness, generality and integrity associated with the use of a language like \nHaskell. The innovative aspects of the approach described include:  The graphical presentation of data \nstructures in an unbounded workspace with the form of representation being speci.ed by a datatype-indexed \nstylesheet (an approach that allows a clean separation of concerns between program correctness and presentational \naes\u00adthetics).  An evaluation strategy in which reduction is demand driven as the user moves the viewport \nover the workspace, an approach that allows large/in.nite datastructures to be selectively explored. \n A mechanism that allows the source code of a Haskell value declaration to be edited (in a variety of \nby-value and by-reference combinations) using simple copy-and\u00adpaste operations on a live graphical representation \nof its (partially evaluated) value.  Vital does not aim to displace the conventional, speci.cation\u00adlead \napproach to functional programming deployed by the computer scientist. Rather, it seeks to make available \nsome of the fruits of functional programming to a section of the much wider community of users of spreadsheets \nand related declarative systems. Acknowledgments Thanks are due to Claus Reinke and to the anonymous \nref\u00aderees for helpful, perceptive comments on earlier drafts of this paper.  8. REFERENCES [1] S. Aditya \nand R. S. Nikhil. Incremental polymorphism. In J. Hughes, editor, Proc. Functional Programming Languages \nand Computer Architecture, 5th ACM Conference, volume 523 of Lecture Notes in Computer Science, pages \n379 405. Springer, 1991. [2] D. Bricklin. VisiCalc spreadsheet. Announced at National Computer Conference, \nNew York City, Jun 1979. [3] M. Burnett. Visual language research bibliography. Technical report, Oregon \nState University, 2002. Available from http://www.cs.orst.edu/~burnett/vpl.html. [4] M. Burnett, A. \nAgrawal, and P. van Zee. Exception handling in the spreadsheet paradigm. IEEE Trans. on Software Engineering, \npages 923 942, Oct 2000. [5] M. Burnett et al. Forms/3:A .rst-order visual language to explore the boundaries \nof the spreadsheet paradigm. J. Functional Programming, 11(2):155 260, March 2001. [6] R. J. Casimir. \nReal programmers don t use spreadsheets. ACM SIGPLAN Notices, 27(6):10 16, June 1992. [7] L. Dami and \nD. Vallet. Higher-order functional composition in visual form. In D. Tsichritzis, editor, Object Applications, \npages 139 154. Univ. of Geneva, 1996. [8] A. Davie and K. Hammond. Functional hypersheets. In P. Trinder, \neditor, Proc. 1996 Glasgow workshop on Functional Programming, 1996. [9] W.A.C.A.J.deHoon, L. M. W. J. \nRutten, and M. C. J. D. van Eekelen. Implementing a functional spreadsheet in Clean. J. Functional Programming, \n5(3):383 414, July 1995. [10] W. Du and W. W. Wadge. A 3D spreadsheet based on intensional logic. IEEE \nSoftware, pages 78 89, May 1990. [11] K. Hanna. Implementing theorem provers in a purely functional style. \nJ. Functional Programming, 9(2):147 166, March 1999. [12] K. Hanna. Overview of Vital. University of \nKent, 2001. Includes tutorial, reference manual and download. Available from http://www.cs.ukc.ac.uk/people/staff/fkh/Vital. \n[13] J. Kelso. Visual representation for functional programs. Technical Report CS-95-01, Dept of Comp. \nSc., Murdoch University, 1995. [14] R. E. Maeder. Higher-order functions. The Mathematica journal, 5:61 \n67, 1995. [15] B. Myers, D. Guise, R. Dannenberg, B. V. Zanden, D. Kosbie, E. Pervin, A. Mickish, and \nP. Marchal. Garnet:Comprehensive support for graphical, highly interactive user interfaces. IEEE Computer,pages \n71 85, November 1990. [16] R. R. Panko. What we know about spreadsheet errors. J. End User Computing, \n10(2):15 21, 1998. [17] S. Peyton Jones. The implementation of functional programming languages. Prentice \nHall, 1987. [18] S. Peyton Jones, A. Reid, F. Henderson, C. A. R. Hoare, and S. Marlow. A semantics for \nimprecise exceptions. In SIGPLAN Conference on Programming Language Design and Implementation, pages \n25 36, 1999. [19] J. Poswig, G. Vrankar, and C. Morara. VisaVis:a higher-order functional visual programming \nlanguage. J. Visual Languages and Computing, 5(1):83 111, 1994. [20] H. J. Reekie. Visual Haskell:a .rst \nattempt. Technical Report 94.5, Centre for Adv. Comp. Sc., Univ. of Tech., Sydney, 1994. [21] B. Shneiderman. \nDesigning the User Interface. Addison-Wesley, 1998. [22] P. Wadler. Why no one uses functional languages. \nACM SIGPLAN Notices, 33(8):23 27, 1998.  \n\t\t\t", "proc_id": "581478", "abstract": "An interactive graphical environment for supporting the development and use of Haskell applications programs is described. The environment, named Vital, is particularly intended for supporting the open-ended, incremental development style often preferred by non-specialist users in which successive steps of program development are motivated and informed by results so far obtained.Significant features of Vital include: the graphical display of data structures in a format defined by a datatype-indexed stylesheet, the way that evaluation of (possibly infinite) values is demand-driven by the action of the user scrolling around an unbounded workspace, and support for copy-and-paste graphical editing of data structures. This latter allows, for example, the user to modify a complex data structure by point-and-click operations, or to create (by functional evaluation) a regular data structure and then edit values or expressions into it. The effect of each editing operation is immediately reflected in the Haskell program source code.", "authors": [{"name": "Keith Hanna", "author_profile_id": "81100461689", "affiliation": "University of Kent, Canterbury, Kent, UK", "person_id": "PP14161641", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/581478.581493", "year": "2002", "article_id": "581493", "conference": "ICFP", "title": "Interactive visual functional programming", "url": "http://dl.acm.org/citation.cfm?id=581493"}