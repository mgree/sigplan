{"article_publication_date": "09-17-2002", "fulltext": "\n Meta-programming with Names and Necessity Aleksandar Nanevski School of Computer Science Carnegie Mellon \nUniversity Pittsburgh, PA 15213-3891 aleks@cmu.edu Abstract Meta-programming languages provide infrastructure \nto gener\u00adate and execute object programs at run-time. In a typed setting, they contain a modal type constructor \nwhich classi.es object code. These code types generally come in two .avors: closed and open. Closed code \nexpressions can be invoked at run-time, but the computations over them are more rigid, and typically \nproduce less ef.cient residual object programs. Open code provides better inlining and partial evaluation \nof object pro\u00adgrams, but once constructed, expressions of this type cannot in general be evaluated. Recent \nwork in this area has focused on combining the two no\u00adtions into a sound system. We present a novel way \nto achieve this. It is based on adding the notion of names from the work on Nominal Logic and FreshML \nto the .D-calculus of proof terms for the necessity fragment of modal logic S4. The re\u00adsulting language \nprovides a more .ne-grained control over free variables of object programs when compared to the ex\u00adisting \nlanguages for meta-programming. In addition, this ap\u00adproach lends itself well to addition of intensional \ncode analy\u00adsis, i.e. ability of meta programs to inspect and destruct object programs at run-time in \na type-safe manner, which we also undertake. Categories and Subject Descriptors D.3.1 [Software]: Programming \nLanguages Formal De.\u00adnitions and Theory General Terms Languages  Keywords modal lambda-calculus, higher-order \nabstract syntax Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. ICFP 02, October 4-6, 2002, Pittsburgh, Pennsylvania, USA. Copyright 2002 ACM 1-58113-487-8/02/0010 \n...$5.00 1 Introduction Meta-programming is a paradigm referring to the ability to al\u00adgorithmically compose \nprograms of a certain object language, through a program written in a meta-language. A particularly intriguing \ninstance of this concept, and the one we are inter\u00adested in in this work, is when the meta and the object \nlanguage are: (1) the same, or the object language is a subset of the meta language; and (2) typed functional \nlanguages. A lan\u00adguage satisfying (1) makes it possible to also invoke the gen\u00aderated programs at run-time. \nThis setup is usually refered to as homogeneous meta-programming [20]. Among the advantages of meta-programming \nand of its homo\u00adgeneous and typed variant we distinguish the following (and see [20] for a comprehensive \nanalysis). Ef.ciency Rather than using one general procedure to solve many different instances of a problem, \na program can gen\u00aderate specialized (and hence more ef.cient) subroutines for each particular case. If \nthe language is capable of executing thus generated procedures, the program can choose dynami\u00adcally, \ndepending on a run-time value of a certain variable or expression, which one is most suitable to invoke. \nA particular instance of this idea is the functional programming concept of staged computation, and has \nbeen considered before in a typed setting [23, 24, 3]. Maintainability Instead of maintaining a number \nof special\u00adized, but related, subprograms, it is easier to maintain their generator. In a language capable \nof invoking the generated code, there is the added bonus of being able to accentuate the relationship \nbetween the synthesized code and its producer; the subroutines can be generated and bound to their respective \nidenti.ers in the initialization stage of the program execution. Languages in which programs can not \nonly be composed and executed but also have their structure inspected add further ad\u00advantages. Ef.ciency \nbene.ts from various optimizations that can be performed knowing the structure of the code. For exam\u00adple, \nGriewank reports in [8] on a way to reuse common subex\u00adpressions of a numerical function in order to \ncompute its value at a certain point and the value of its n-dimensional gradient, but in such a way that \nthe complexity of both evaluations per\u00adformed together does not grow with n. Maintainability (and in \ngeneral the whole program development process) bene.ts from the presence of types on both the level of \nsynthesized code, and on the level of program generators. Finally, there are applications from various \ndomains, which seem to call for the ability to execute a certain function as well as recurse over its \nstructure: see [19] for examples in computer graphics and numerical analysis, and [18] for an example \nin machine learn\u00ading and probabilistic modeling. Recent developments in type systems for meta-programming \nhave been centered around two particular modal .-calculi: .D and .O. The .rst is a language of proof \nterms for the modal logic S4, whose necessity constructor Dannotates valid propositions [3, 15]. The \nsecond is the proof language for dis\u00adcrete linear temporal logic, whose modal operator O anno\u00adtates the \ntime-level separation between propositions [2]. Both calculi provide a distinction between levels of \nterms, and this explains their use in meta-programming. The lowest, level 0, is the meta language, which \nis used to manipulate the terms on level 1 (terms of type DA in .D and OA in .O). This .rst level is \nthe meta language for the level 2 containing another stratum of boxed and circled types, etc. Functional \nprogram\u00adming interpretation of these two constructors assigns type DA to closed code i.e. to closed terms \nof type A, while OA is the type of postponed code, i.e. it classi.es terms of type A which are associated \nwith the subsequent time moment. Postponed code in .O may refer to outside context variables, as long \nas they are on the same temporal level, and this has contributed to it frequently being associated with \nthe notion of open code. For this exact reason, the concept of code in .O is obviously broader, allowing \nfor more expressiveness and generation of better and more optimized residual programs (as already ob\u00adserved \nin [2]), but, unlike .D, it has no language support for mixing of the code levels, and in particular, \nno language sup\u00adport for execution of the generated code. There have been several proposed systems which \nincorpo\u00adrate the advantages from both languages, most notable being MetaML [11, 22, 1]. MetaML starts \nwith the postponed/open code type of .Oand strengthens the notion to introduce closed code as its re.nement \n as postponed code which happens to contain no variables declared outside of it. The approach of our \npaper is the opposite. Rather than re.ning the notion of open code, we relax the notion of closed code. \nWe start with the system of .D, but provide the additional expressiveness by allowing the code to contain \nspeci.ed object variables as free (and rudiments of this idea have already been considered in [13]). \nThe fact that a given code expression depends on a set of free variables will be re.ected in its type. \nThe object vari\u00adables themselves are represented by a separate semantic cate\u00adgory of names (also called \nsymbols or atoms), which admits equality. The treatment of names is adopted, with signi.cant modi.cations, \nfrom the work on Nominal Logic and FreshML by Pitts and Gabbay [7, 17, 16, 6]. This design choice lends \nitself well to the addition, in an orthogonal way, of intensional code analysis, which we also undertake \nfor the simply-typed segment of the language. Thus, we can also treat our simply\u00adtyped code expressions \nas data; they can not only be evaluated, but can also be compared for structural equality and destruc\u00adted \nvia pattern-matching, much in the same way as one would work with any abstract syntax tree. 2 Background \nIn this section we review the basic development of .D\u00adcalculus. We describe only the core language, but \nin the pre\u00adsented examples we assume the presence of certain types and term constructs, like integers, \nconditionals or recursion. We refer the reader to the accompanying technical report [12] for a more detailed \ntreatment of this and other related work. The example we use throughout for illustration is the exponentia\u00adtion \nfunction, presented below in a MinML-like notation. pow = fix pow:int->int->int. .n:int. .x:int. if \nn = 0 then 1 else x * pow (n-1) x The functional programming motivation behind the .D cal\u00adculus is to \nensure proper staging of programs. For example, consider the following equivalent of the exponentiation \nfunc\u00adtion. pow = fix pow:int->int->int. .n:int. if n = 0 then .x:int.1 else let val u = pow (n -1) \n in .x:int. x * u(x) end One can argue that pow is preferable to pow because it al\u00adlows a partial evaluation \nof the function when only n is known, but not x. Indeed, in such a situation, the expression pow n produces \na residual function specialized to computing the n-th power of its argument x. In particular, this function \nwill not perform any operations or make decisions at run-time based on the value of n; in fact, it does \nnot even depend on n all the computation steps dependent on n have been taken during the partial evaluation. \nThe type system of .D allows the programmer to specify the intended staging of operations, so that computations \nfrom the subsequent stages are independent of the computations from the current stage. This is achieved \nby explicitly annotating the stages of the computation and requiring that each stage is a closed term, \ni.e. that it is free of variables declared in the surrounding code. Then the type system can check whether \nthe written code conforms to the staging speci.cation, making staging errors into type errors. Types \nA ::= 1 |A1 .A2 |DA Terms e ::= *|x |.x:A. e |e1 e2 |box e | let box u = e1 in e2 Contexts .,G ::= \u00b7|G,x:A \nValues v ::= *|.x:A. e |box e To declare that a subterm e of type A is closed, .D provides the type constructor \nDand its introduction term box,so that box e has type DA (consult the typing rules below). It is in this \nsense that the type constructor Dis associated with closed code. In the spirit of this run-time code \ngeneration interpre\u00adtation, the operational semantics does not proscribe reductions under the box; boxed \nexpressions are values. For the purposes of this paper, we will consider boxed code expressions to be \nuncompiled, i.e. stored and carried around in the form of their abstract syntax trees. The elimination \nform for Dis let box u = e1 in e2.Opera\u00adtionally, it evaluates e1 to a boxed value, then binds the unre\u00adduced \nexpression under that box to u in e2. Notice that u is not an ordinary variable it stands for an unevaluated \nclosed syntactic expression, rather than a value. This fact motivates having two variable contexts in \nthe typing judgment: G for or\u00addinary value variables, and . for closed syntactic expression variables. \nIn order to have proper staging, code expressions should not depend on value variables from G, but they \ncan de\u00adpend on expression variables from .. The typing and evalua\u00adtion rules of .D are presented below. \nx:A .G u:A ...;G,x:A fe : B .;Gfx : A .;G fu : A .;G f.x:A. e : A .B .;G fe1: A .B .;G fe2: A .;\u00b7fe : \nA .;G fe1 e2: B .;G fbox e : DA .;G fe1: DA .,u:A;G fe2: B .;G flet box u = e1 in e2: B c '.c .x:A. \ne '..x:A. e e1 '..x:A. ee2 '.v2 [v2/x]e '.v e1 e2 '.v e1 '.box e [e/u]e2 '.v box e '.box e let box u \n= e1 in e2 '.v The staging of pow can be made explicit in the following way. powbox = fix pow:int -> \nD(int->int). .n:int. if n = 0 then box (.x:int. 1) else let box u = pow (n -1) in box (.x:int. x * \nu(x)) end Application of powbox at argument 2 produces a boxed func\u00adtion for squaring. -sqbox = powbox \n2; val sqbox = box (.x:int. x * (.y:int. y * (.z:int. 1) y) x):D(int->int) It can then be evaluated in \norder to be applied itself. -sq = (let box u = sqbox in u); val sq = [fn] : int -> int -sq 3; val it \n= 9 : int This .D staging of powboxleaves a lot to be desired. In partic\u00adular, the residual programs \nthat powbox produces, e.g. sqbox, contain variable-for-variable redices, and hence are not as ef\u00ad.cient \nas one would want. Ideally, we would like to com\u00adpletely inline all the function calls from sqbox and \nobtain sqbox = box(.x:int. x*x*1). The reason the unwanted redices occur is, of course, because boxed \ncode expressions are values; they completely suspend the evaluation of the en\u00adclosed term. As witnessed \nby the example of sqbox,it may be advantageous to have a general programming mechanism1 whereby one could \nspecify that certain reductions in a code expression are to take place. Of course, .D already contains \nmechanisms to encode substitutions of closed code, but there is no way to perform substitutions of open \ncode which is re\u00adquired in the sqbox example. The solution should be to extend the notion of code to \ninclude not only closed expressions, but also expressions which may contain free variables.  3 Core \nlanguage In this section we present the syntax and static semantics of our core language. It extends \nthe .D calculus with constructs for a uni.ed treatment of the notions of closed and open code a problem \nwhich initiated the extension of .Ointo MetaML [11, 22]. The motivational distinction between these two \nsys\u00adtems and our calculus is that we want to provide intensional code analysis as part of the language, \nwhile .O and MetaML do not do that. To be clear, we believe that extending .O or MetaML with code analysis \nis possible. It will most likely require similar machinery as developed here, except that the considerations \nwould probably be more complicated because these calculi are more involved than .D.At any rate, the ex\u00adtension \nof .D with the machinery required by code analysis already attains enough expressiveness to encode quite \na few, if not all, interesting programs from .Oand MetaML. Under\u00adstanding the exact relationship between \nall these languages, however, remains future work. Our approach starts with the closed code of .D, and \nallows a code expression to contain only those free variables that have been listed as dependencies in \nits type. Only the ex\u00adpressions with no dependencies will be executable. To be\u00adgin with, we handle free \nvariables of a code expression not as meta-level bound variables (as it happens to be the case in .O \nand MetaML), but by a separate binding and abstraction mechanism. The main reason is the following: intensional \ncode analysis ought to provide a test whether two free vari\u00adables in a code expression are different \nor equal. The result of this test is obviously not preserved under substitution, so it looks questionable \nto tie the free code variables to outside lambda abstractions. Having them both tied to the same mech\u00adanism \nof variable binding will almost certainly cause prob\u00adlems in the long run (as witnessed by, e.g., interaction \nof code analysis with cross-stage persistence in MetaML, explained in 1Thus we are interested in something \nmore than just devis\u00ading an operational semantics which scans boxed expressions and actually reduces \nall variable-for-variable redices. [21]). The introduction of a separate binding mechanism for free variables \nof syntactic code expressions has been proposed before in [20], and even earlier in [10]. Furthermore, \nwe do not want the variable introduction form of this second mechanism to be a type introduction form \nas well. The reason for this is that we want to support recur\u00adsion over syntax trees of code expressions. \nA function which scans syntactic code expressions and recurses under a lambda binder, has to provide \nsome symbol to stand for the bound variable, before it can go on and recurse over the body of the abstraction. \nIntroduction of that temporary symbol should not change the type of the recursing function. Thus, we \nneed to resort to names (see for example [14]). Additionally, we opt to separate the operation of name \ncreation (renameability), from the name abstraction (hiding of a name), because that provides strictly \nmore expressiveness in manipulation of code and names, than if the two are combined into a single con\u00adstructor. \nThis is where we employ the mechanisms of Nom\u00adinal Logic and FreshML, which were designed with exactly \nthat purpose in mind (see [16] and [17]). We introduce a new semantic category of names (also called \nsymbols, atoms or in\u00addeterminates) which are to stand for free variables in boxed expressions. Thus, \nboxed expressions, as before in .D, cannot contain free variables, but we allow them to contain names, \nunder the provision that the occurring free names are listed in the type of the expression. Correspondingly, \nthe boxed types arenow of theform D(A[C]) where C is a .nite set of names2 that the boxed term may depend \non. Informally, a term depends on a certain name if that name must be provided with a de.nition before \nthe term can be evaluated. As only expressions with empty support can actually be eval\u00aduated, we needs \na construct that would eliminate a name from the expression s support, eventually turning unexecutable \nexpressions into executable ones. The construct for that is . {X = e1} e2, and it stands for explicit \nsubstitution of the value of e1 for the occurrences of the name X on the current code level of e2. Notice \nthe emphasis on the current code level; the explicit name substitution of X only removes the occurrences \nof X which actually contribute to the support of e2. It does not (and it would not be sound if it did) \nremove those occur\u00adrences of X which lie under one or more box constructors. This way, name substitution \nprovides extensions,i.e. de.ni\u00adtions for names, while still allowing names under boxes to be used for \nthe intensional information of their identity. Another construct that we need in the language is name \nab\u00adstraction. Quite often we need to express that a term depends on some name, but it is not really important \nhow that name is called (or the name is not accessible in the local context). For example, such a need \narises when recursing over a syn\u00adtax tree for a .-expression. Before descending under the .,a temporary \nname has to be introduced on the .y to stand for the bound variable, but the identity of that name is \nnot really important. We adopt the treatment of name abstraction from Nominal Logic and FreshML. For \nexample, if X is a name of type P, the construct for abstracting the name X would be X . (-), and it \nhas a corresponding type constructor (-), X:P which binds the occurrences of the name X in the supplied \nN type. The intended operational semantics of X . e is to pair up the name X and the value of e into \na closure, thus explicitly hiding the identity of X (or, which is equivalent, returning the The set of \nnames that a term depends on is called the support of the term. The notion of evaluation that we have \nin mind in these de.nitions is the one from .D calculus. In particu\u00adlar, since the boxed expressions \nin .D are values, the boxed expressions must have empty support. For example, assuming for a moment that \nX and Y are names of type int, and that the usual operations of addition, multi\u00adplication and exponentiation \nof integers are primitive in our language, the term t1 = X3 + 3X2Y + 3XY 2 +Y 3 would have type int and \nsupport set {X,Y }. Indeed, in order to evaluate t1 to an integer, we .rst need to substitute integer \nvalues for X and Y , and thus t1 depends on both X and Y .On the other hand, if we box the term t1, we \nobtain t2 = box (X3 + 3X2Y + 3XY 2 +Y 3) which has type D(int[X,Y ]), but its support is the empty set, \nas t2 is already a value. Notice how support of a term (in this case t1) becomes part of the type, once \nthe term itself is boxed. This way, the types maintain the information about the support of subterms \nof all code levels no matter under how many box s a subterm may appear. For example, the term t3 = (X2 \n,box Y 2) has the type int \u00d7 D(int[Y ]) with support {X}. 2Actually, C will have a bit more complex structure, \nto be introduced shortly a-equivalence class of e with respect to X). The quanti.er N has already been \ninvestigated in [6] and [16], but it has not been used explicitly in the de.nition of FreshML. Just as \nin FreshML, the elimination form for name abstraction is name concretion. Its syntax is e@Y ,where e \nis a name abstraction and Y is a name not occurring in e. Its operational meaning is to swap Y with the \nname abstracted in e. For example, assuming as before that X,Y :int are available names, we can create \nthe term t4 = X . box (X2 - 1) which depends on one name (e.g. a polynomial in one in\u00addeterminate), ignoring \nthe exact identity of that name. The type of t4 is D(int[Z]), re.ecting the fact that the actual N Z:int \nindeterminate is not really known. But, if a need arises to ma\u00adnipulate the unknown indeterminate, we \ncan always provide a fresh name for it by concretion, like in the term t5 = t4@Y which reduces to box \n(Y 2 - 1). We also need a way to dynamically introduce fresh names into the computation. Just like in \nFreshML, this duty is given to the term constructor new X:P in e which creates a new local name X and \nproceeds to evaluate e in the extended environment. Just like in FreshML, the type sys\u00adtem will make \nsure that the value of e does not contain unsub\u00adstituted or unabstracted occurrences of X. Unlike in \nFreshML, where types of names belong to a separate universe, our name structor can have arbitrary type \nP, as long as P is simple (i.e. D-free). X:P N A is also a binder, abstracting a name X:P from the Notice \nthat this constraint on simple types is fairly arbitrary; type A, but it does not introduce a new name \ninto the name we wanted to understand the restricted language .rst before context. As usual, capture \navoiding substitution is de.ned to rename variables and names when descending into their scope. we extend \nit and generalize it. As D-types can now explicitly store the information about the support of the terms \nthey classify, another feature we need to consider is explicit support polymorphism. A program may want \nto manipulate code expressions no matter what their sup\u00ad port sets are, or code expressions whose supports \nare unknown at compile time. A typical example would be a function which scans over some boxed term. \nWhen it encounters a lambda expression, it has to place a fresh name instead of the bound variable, and \nrecursively continue scanning the body of the Free support variables of a given type A are denoted by \nfp(A), free variables of a term e by fv(e), and its free names are fn(e). Example 1 To illustrate our \nlanguage constructs and motivate the further development, we present a version of the staged exponentiation \nfunction that we could write in our system. In this example we assume that the language is extended with \nthe base type of integers. In general, in the examples throughout the paper, we will assume the additional \ntype and term con\u00ad structs as we need them, either to illustrate the point or just improve readability. \nIn any of the cases, the addition should lambda, which is itself a boxed expression, but depending on \nthis newly introduced name. For such uses, we extend the no\u00adtion of support of a term to not only list \nthe names appearing in the term, but to also allow variables standing for unknown not impose tremendous \ntechnical dif.culties. pow = support sets. Our language provides a term construct .p#K. e fix pow :.p. \nD(int[p])->int->D(int[p]). .p. .e:D(int[p]). .n:int. of type .p#K. A which is a polymorphic abstraction \nof an un\u00ad if n = 0 then box 1 known support set p disjoint from a set of names K.Both the constructs \nbind the variable p, and two terms/types differ\u00ading only by a-variation of the bound variable are considered \nequal. When K is empty, we abbreviate the constructs into .p. e and .p. A.The term e [[C]] is the polymorphic \ninstantia\u00adtion, substituting a support set C for the support variable bound in e. The syntax of our \nlanguage is presented in Figure 1. Simi\u00adlarly to .D, we make a distinction between ordinary (value) variables \nand expression variables. We further distinguish be\u00adtween expression variables and expressions that have \nempty support, and those that may depend on some name; the .rst kind can be compiled and executed, and \nthe second cannot. In analogy with Kripke semantics for Modal Logic, we will call the .rst kind re.exive, \nand the second kind nonre.exive. Thus, a variable context G may contain three forms of vari\u00adable typings: \nx:A for value variables, u::A[C] for re.exive and t-::A[C] for nonre.exive expression variables with \nsupport C. Notice that in a seeming contradiction to the de.nition of re\u00ad.exive expression variables, \nwe allow the support C to occur in their typing. The reason for it is in the interaction of expres\u00adsion \nvariables with the term constructor box for expressions. Expression variables which are non-re.exive \n(and hence un\u00adreachable) outside a boxed term, will be accessible in the in\u00adside of it. It is in this \nsense that non-re.exive expressions can\u00adnot be executed, but only substituted into other non-re.exive \nexpressions. This intuition will be formalized later in the typ\u00ading judgment where the rule for box introduction \nwill change the status of non-re.exive variables into re.exive ones. We call the type A with a support \nC an annotated type. The support variable context . associates support variables with disjointness annotations. \nFor example, p#K . . would mean that the support set variable p stands for an unknown support set C such \nthat: (1) C contains no names from the set K,and (2) if q .C is a support variable, then q#K . ., too. \nEnlarging an appropriate context by a new variable or a name is subject to Barendregt s Variable Convention: \nthe new vari\u00adables are assumed distinct, or are renamed in order not to clash with already existing ones. \nTerms which differ only in names of their bound variables are considered equal. The type con\u00ad else let \nbox e1 = pow [[p]] e(n-1) box e2 = e in box (e1 * e2) end pow : int -> D(int -> int) = .n:int. new X:int \nin let box e = pow [[X]] (box X) n in box (.x:int. {X=x} e) end -sqcode = pow 2; val sqcode = box \n(.x:int. x * (x * 1)):D(int->int) The function pow takes an integer n and generates an inte\u00adger name \nX. Then it calls the helper function pow to build the expression e = X *\u00b7\u00b7\u00b7*X *1 of annotated type int[X].Fi\u00ad \n' -v \" n nally, it substitutes the name X in e with a newly introduced bound variable x, before returning. \nThe helper function pow is support-polymorphic; its support variable p is instantiated with the relevant \nsupport set as part of the application. Notice that the generated residual code for sqcode does not contain \nany unnecessary redices, in contrast to the .D version of the program from Section 2. 3.1 Auxiliary \njudgments In order to state the typechecking rules, we will need a couple of auxiliary judgments. First \nis the judgment for disjointness (alsoreferredtoas freshness) of support sets. It has the form . fC # \nK,where . is a context storing support variables with their freshness annotations, C is a support set, \nand K is a set of names. The judgment is satis.ed if none of the names from K appears in C, and if all \nthe variables from C are declared disjoint from K in the context .. Simple types P ::= 1 |P1 .P2 Types \nA ::= 1 |A1 .A2 |D(A[C]) | A |.p#K. A Terms e ::= X:P *|x |X |.x:A. e |e1 e2 |box e |let box u = e1 \nin e2 | . X . e |e@X |new X:P in e |.p#K. e |e [[C]] |{a = e1}e2 |.x x:A. e Variable contexts G ::= \n\u00b7|G,x:A |G,t-::A[C] |G,u::A[C] Name contexts S ::= \u00b7|S,X:P Supportvariable contexts . ::= \u00b7|., p#K Figure \n1. Syntax of the core language (K is a .nite set of names, and C is a .nite set of names and support \nvariables). N The concept of disjointness for support sets is then extended to disjointness for types, \nso that we have a judgment . fA # X, where A is a type and X is a name. It is satis.ed if X does not \nappear free in the dependencies of A on any code level. We will often combine the two judgments into \na new judgment for disjointness of annotated types . fA[C] # X. Also required is a judgment to decide \nif a given type A is well-formed in the name context S and parameter context ., i.e. whether all the \nfree names and support variables of A are declared in S or ., respectively. We denote it as S;. fA wf. \nWe next de.ne weakening on types: if a type depends on a certain set of names, we can always pass it \nas a type with a superset of names instead. Notice that we may need to alpha- X:PX:P A : BC .DA : BK \n.M NN D(A[C]) : D(B[D]) .p#K. A : .p#M. B Finally, we implicitly equate two types A and B if A : B and \nB : A. This is justi.ed by the fact that two types will be in this relation iff they differ only in the \nordering of names and variables in their supports. But support sets are indeed considered sets, so this \nordering should not matter.  3.2 The type system The typing judgment of our language has the form S;G \nf. e : A[C] It reads: in the presence of name context S, variable context G and support variable context \n.,the term e has type A and the support of e is included in C. As customary, we presuppose that all involved \ncontexts are well-formed. In particular, all the variables, names and parameters are distinct, and all \ntheir types are well-formed. Before proceeding further, we de.ne an operation G' on vari\u00adable contexts. \nIt erases the ordinary variables from G and changes nonre.exive expression hypotheses t-::A into re.ex\u00adive \nones t::A. As already hinted before, it will be used in the box introduction rule to make the non-re.exive \nvariables ac\u00adcessible under the box. (\u00b7)' = \u00b7 (G,x:A)' = G' (G,t-::A[C])' = G',t::A[C] (G,u::A[C])' = \nG',u::A[C] The typing rules of our language are presented in Figure 2. We explain the most important \nones of them next. Hypothesis rules Notice .rst that the hypotheses rules ex\u00adist only for the ordinary \nvalue variables and for the re.exive expression variables. The non-re.exive variables cannot be accessed \nuntil they are turned into the re.exive ones by the rule for box introduction. Thus, as already commented \nbefore, non-re.exive code expressions cannot be evaluated, but can only be used to compose new code expressions. \nThe intention behind this is to prevent evaluation of code which is not closed. In addition, all the \nhypothesis rules check if the their support sets are well-formed, i.e. if all the names and support vari\u00adables \nare declared in the name context S and the dependency variable context .. rename the bound names when \ncomparing two -types. .-calculus fragment Therulefor .-abstraction relies on one A : B N B1 : A1 A2 : \nB2 1 :1 A1 .A2 : B1 .B2 A : B of the auxiliary judgments to check whether the type A of the bound variable \nis well-formed, i.e. whether all its names and support variables have been already declared in the name \ncontext S and support variable context .. This ensures that the contexts used in the judgment are kept \nwell-formed. The synthesized type B does not have to be checked for well\u00adformedness, as the typing rules \nguarantee it. Modal fragment Just as in .D-calculus, our rule for box checks the boxed expression e against \na variable context G' from which the value variables have been erased. In addition, G' changes the status \nof all the nonre.exive expression vari\u00adables into re.exive ones, so that they can be used in e (e being \non a higher code level from box e). The support set of box e is empty, and thus it can be freely extended \nin the judgment by a well-formed support set D. We also have two different rules for the let box constructor: \none classi.es its local variable as re.exive, the other classi.es it as non-re.exive, depending on the \nsupport set of the expression bound to the variable. Names fragment The construct new generates a fresh \nname, and then checks, using the auxiliary disjointness judgment, if the synthesized type and support \nset do not contain free occur\u00adrences of this new name. The operation .#X extends with X the freshness \nannotation of every support variable in ..This is justi.ed because X is a new name, and is necessary \nin order to type possible abstractions with name X in the body of new. In our system, just like in FreshML, \nthe process of name abstraction and concretion is separated from name creation which is carried out by \nnew. Thus, the typing rules for abstrac\u00adtion, concretion and explicit substitution require that the name \nthey use has already been placed into the name context. The side condition . ffp(A) # X in the typing \nrules for abstrac\u00adtion and concretion is a bit harder to explain. It ensures that the x:A . G C . dom(S,.) \nu::A[C] . G C . D . dom(S,.) X:P . SC . dom(S,.) S;G f. x : A[C] S;G f. u : A[D] S;G f. X : P[X,C] S;. \nf A wf S;G,x:A f. e : B[C] x. dom(G) S;G f. e1: A . B[C] S;G f. e2: A[C] S;G f..x:A. e : A . B[C] S;G \nf. e1 e2: B[C] S;. f A wf S;G,x:A f. e : A[C] x . dom(G) S;G f. .x x:A. e : A[C] S;G ' f. e : A[C] D \n. dom(S,.) S;G f. e1: D(A[])[C] S;G,u::A[] f. e2: B[C] u . dom(G) S;G f. box e : D(A[C])[D] S;G f. let \nbox u = e1 in e2: B[C] S;G f. e1: D(A[D])[C] S;G,t-::A[D] f. e2: B[C] t. dom(G) D = 0/ S;G f. let box \nt = e1 in e2: B[C] S,X:P;G f. e : A[C] . f fp(A) # X S,X:P;G f. e : ( A)[C] . f fp(A) # X X:P A)[C] \nS,X:P;G f. e@X : A[C] N S,X:P;G f. X . e : ( N X:P S,X:P;G f.#Xe : A[C] .#X f A[C] # XX. dom(S) S;G \nf. new X:P in e : A[C] S;G f.,p#Ke : A[C] p . dom(.) S;G f. e : .p#K. A[C] . f D # KD . dom(S,.) S;G \nf..p#K. e : .p#K. A[C] S;G f. e [[D]] : ([D/p]A)[C] S,X:P;G f. e1: P[C] S,X:P;G f. e2: B[X,C] S;G f. \ne : A[C] A : B . S,X:P;G f. {X = e1} e2: B[C] S;G f. e : B[C] Figure 2. Typing rules of the core language. \nsupport variables occurring in e could not be substituted with In the rest of this section we present \nthe basic structural prop\u00ada set containing the name X. If that were possible, the new erties of our calculus. \nAs a .rst step, notice that the usual occurrence of X would be abstracted on the level of terms, properties \nof exchange, weakening and contraction for vari\u00adbut there would be no binding in the corresponding type, \nthus able context G hold in our system, too. In addition, we have causing unsound behavior. The reason \nfor that is that the quan-exchange and weakening for name contexts, support variable ti.er in A is itself \na binder, and two name abstraction types contexts and support sets themselves. Strengthening of vari- \nN X:p able contexts holds as well: if a term which does not mention which differ only in the identities \nof their bound names, are a certain variable x . G is well typed, then it is well typed in considered \nequal. the context obtained by omitting x from G. Another important observation about the rule for name \nab\u00adstraction is that it does not change the support C of the in\u00advolved term. In particular, it does not \nremove the abstracted name from it. This is justi.ed by the intended interpretation of name abstraction \n(X . e):it .rst evaluates its body e before creating the closure with X. Thus, the set of names that \nneed to be provided with de.nitions in order to evaluate (X . e) is the same set required for the evaluation \nof e itself. In other words, the two expressions have the same support. Similar considerations motivate \nthe typing rule for concretion as well. Subtyping As already commented before, the nature of sup\u00adport \nsets makes it natural to pass a type with a smaller support annotation when a type with a bigger support \nannotation is re\u00adquired. Thus, we provide a rule that explicitly coerces terms We de.ne two new operations \non contexts, G8 and G',which, together with the already de.ned G ' , will be important for stating the \nsubstitution principles for our language. G8 re\u00admoves the ordinary value variables from G, leaving only \nex\u00adpression variables in it. G' changes the re.exive expression variables with nonempty name dependencies \ninto nonre.exive ones. (\u00b7)8 = \u00b7 (G,x:A)8 = G8 (G,t-::A[C])8 = G8,t-::A[C] into types with extended support, \nas de.ned by one of the aux-G8 (G,u::A[C])8 = ,u::A[C] iliary judgments. (\u00b7) ' = \u00b7 (G,x:A) ' = G ' ,x:A \n(G,t-::A[C]) ' = G ' ,t-::A[C] (G,u::A[0/]) ' = G ' ,u::A[0/] (G,u::A[C]) ' = G ' ,u-::A[C] if C = 0/ \nThe next step is to de.ne a capture-avoiding name substitu\u00ad tion {X/e}e. It substitutes the name X by \ne,but only on the current code level in e'; the occurrences of X on higher code levels (i.e. under boxes), \nas well as the names in abstracting and concreting positions, or in polymorphic abstractions and instantiations \nwill not be touched. This operation and its cor\u00adresponding substitution principle (Lemma 1.4) will be \nused to justify the operational semantics of the term construct for name substitution {X = e} e. We further \nadopt the operation (XY )(-) of name transposi\u00adtion (or name swapping) from Nominal Logic and FreshML \n[17]. The operation interchanges all the occurrences of names X and Y in the argument expression/type/context/support \nset. Name transposition is different from name substitution: the former swaps two names throughout the \ngiven term or type, no matter the code level on which any of the names occur, while the later only works \non the current code level. Lemma 1 (Substitution Principles) 1. if S;G f. e1: A[C] and S;G,x:A f. e2: \nB[C],then S;G f. [e1/x]e2: B[C]. 2. if S;G8f. e1: A[D] and S;G2,u::A[D] f. e2: B[C],then 1 S;G1,G2 f. \n[e1/u]e2: B[C]. 3. if S;G ' f. e1: A[D] and S;G2,t-::A[D] f. e2: B[C],then 1 S;G1,G2 f. [e1/t]e2: B[C]. \n 4. if S,X:P;G1 f. e1: P[C] and S,X:P;G ' f. e2: B[X,C], 2 then S,X:P;G1,G ' f. {e1/X}e2: B[C]. 2 The \npremises in the formulation of the substitution principles deserve further elaboration. Principle 1.2 \nrequires that the sub\u00adstituted term e1 is typable in a context G8 1 , i.e. that it does not contain any \nfree value variables. The intuition behind this is that e1 substitutes an expression variable u. Expression \nvari\u00adables may occur on multiple code levels, so the substitution will copy e1 to multiple code levels \ntoo. But the ordinary value variables are anchored by the type system to only the current code level, \nand thus e1 must contain none of them. Similar considerations guide the formulation of Principle 1.3. \nThe added twist is that the nonre.exive expression variables from G1 can be treated as re.exive in e1 \nbecause e1 will not occur in executable positions in the residual term. Most importantly, Principle 1.4 \nrequires that the context in both the second premise and in the conclusion be of special form G ' 2 , \ni.e. that its re.exive variables only have empty sup\u00adport. Note that the principle describes a way to \nreduce the support of a term e2 by substituting away the name X.But, the way the operation of name substitution \nis de.ned, it may not necessarily change the expression e2 itself. For example, consider the case when \ne2 = u in the context G = u::A[X].The substitution {X/e1}u produces a term u itself, but there is no \ntyping S;G f. u : A[]. That is why we require that the involved re.exive variables have no support. In \nretrospect, the need to distinguish between expression variables with and without support, which arises \nfrom this principle, was the main reason why we introduced nonre.exive variables into the design of the \ntype system at all, instead of staying with only the re.ex\u00adive variables of .D . Another observation \nof crucial importance is that the local variables of a boxed expression form a context G,which is exactly \nof the form the Principle 1.4 requires, i.e. G = G ' . This can easily be seen, as all the re.exive variables \nwhich will be put into the context have empty support (see the typ\u00ading rules for let box in Figure 2). \nThis would allow us to use the meta operation of name substitution {e1/X}e2 to de.ne the operational \nsemantics of the language construct for name . substitution {X = e1} e2. The idea is to use this construct \nto perform substitutions within box-annotated expression, and the Principle 1.4 ensures that these substitutions \ncan be car\u00adried out without the postponement of evaluation which is the usual operational semantics associated \nwith boxed expressions in .D . The following lemma describes the behavior of typing with respect to substitution \nand name transposition. It is used in the proof of the Type Preservation and Progress theorem to justify \nthe operational semantics assigned to the term constructors for support-polymorphic instantiation and \nconcretion. Lemma 2 (Parametricity) 1. if S;G f.,p#Ke : A[C] and D is a well-formed support set, i.e. \nD . dom(S,.), and is fresh for K,i.e. . f D # K, then S;[D/p]G f. [D/p]e : ([D/p]A)[[D/p]C] 2. if S;G \nf. e : A[C],and X,Y :P are names (not necessarily in S), then (XY )S;(XY )G f(XY). (XY )e : (XY )A[(XY \n)C]   4 Operational semantics In this section we de.ne the structured operational semantics for our \ncore language, and formulate the appropriate Progress and Type Preservation theorem. We start by introducing \nthe notion of contraction, which will be instrumental in de.ning the values of our language. The idea \nis that we do not consider, like in .D, that all boxed expressions are values. Rather, in or\u00adder to be \nvalues, boxed expressions have to be contracted , i.e. not reduced completely, but only freed of (some) \nname substitution they may contain. The name substitutions that are carried out (i.e. contracted) under \na box in a given expression satisfy two properties: (1) they occur on the current code level, and (2) \nthe substituted name is created outside of the boxed term, rather than being local to it. This is in \naccordance with the above observation about the Substitution Principle 1.4 that the variable context \nG of variables encountered when travers\u00ading the current code level of a boxed term, and not descending \ninto further and further boxes, is always of a form G = G ' . Thus, the said substitution principle is \napplicable, and the en\u00adcountered name substitutions can actually be carried out with\u00adout postponing. \nThe judgment for contraction has the form S e -.w and means: if the name substitutions in the expression \ne of names other than those in S are carried out, we obtain w.The protected set S carries the locally \nde.ned names of e (see the contraction rule for new), and is introduced in order to comply with the requirement \n(2) from above. The judgment is de.ned with the rules S,X:P e ---.w S new X:P in e -.new X:P in w SS \ne1 -.w1 e2 -.w2 X .dom(S) . S. {X =e1} e2 -.{X = w1} w2 SS e1 -.w1 e2 -.w2 X .dom(S) . S {X = e1} e2 \n-.{w1/X}w2 and is structural (i.e. commutes) with the other language con- S structs. An expression e \nis S-contracted if e -. e.It is con\u00adtracted if and only if it is 0/-contracted. We use the letter w to \nrange over S-contracted expressions. Lemma 3 (Contraction Termination) If S1,S2;G ' f. e : A[C] then \nthere exists unique term w,such S2 that e -.w.Furthermore, w is S2-contracted and S1,S2;G ' f. w : A[C]. \nWe can now de.ne our syntactic category of values. v ::= *|.x. e |X .v |.p#K. e |box w It is not dif.cult \nto prove that name substitution preserves S\u00adcontracted expressions. In the same way, name transposition \npreserves S-contracted expressions as well, and as a conse\u00adquence, it also preserves values. We are now \nin position to de.ne a small-step operational se\u00admantics (see Figure 3), and formulate the Type Preservation \nand Progress theorem for the core part of the language. Note that the theorem requires empty variable \ncontexts and support. Theorem 4 (Progress and Type Preservation) If S;\u00b7fe : A[], then either 1. e is \na value, or 2. there exists S'. S such that S,e ,e';furthermore  -. S' e' is unique and S';\u00b7fe' : A[]. \n  5 Intensional code analysis This section presents the de.nition and the theory of pattern\u00admatching \non code expressions. Pattern matching code is used to inspect the structure of an object program and \ndestruct it into its component parts. For the purposes of this work, we limit ourselves to intensional \nanalysis of only the simply typed .\u00adcalculus fragment of our language. Thus, admittedly, our cur\u00adrent \nresults are far from complete, but nevertheless, we present them here as a .rst step towards a stronger \nand more robust system. Patterns p ::= *|x |X |[Ex1 \u00b7\u00b7\u00b7xn] |.x:P.p |(p1)(p2:P) The higher-order pattern \n[Ex1 \u00b7\u00b7\u00b7xn] declares a pattern vari\u00adable E matching a code expression subject to condition that the expression \ns free variables are among x1,...,xn. We will denote pattern variables with capital E and its variants. \nPat\u00adtern .x:P.p matches a lambda expression of domain type P.It declares a variable x which is local \nto the pattern, and demand that the body of the matched expression conforms to the pat\u00adtern p. Bound \nvariables, like x above, are to be distinguished from pattern variables, like [Ex1 \u00b7\u00b7\u00b7xn]. The later \nprovides a placeholder for the matching process; upon execution of a successful matching, it will be \nbound to a certain expression. The former is just a syntactic constant, which is introduced by a pattern \nfor lambda expressions, and can match only itself. Pattern a matches a name a from the global name context. \nPattern (p1)(p2:P) matches an application; in order to avoid polymorphic types in patterns, we require \nthat the this pattern proscribes the exact type of the argument in the application. The judgment for \ntypechecking patterns has the form S;G .p : P[C]=.G1 and reads: in the context of global names S, global \nparameters ., and a context of locally declared variables G, the pattern p has the type P, support set \nincluded in C and produces a residual context G1 of pattern variables and their typings. This residual \ncontext is to be passed to subsequent computations. The rules of this judgment are presented in Figure \n4. Note that, because we are limited to only the simply-typed fragment, the local variables that the \ntyping rules deposit in G will always be ordinary value variables, and always simply typed. On the other \nhand, we do allow a bit more generality in the case of pattern variables [Ex1 \u00b7\u00b7\u00b7xn]; they still can \nmatch only terms of simple types, but these terms can have subterms of more general typing. However, \nit will always be the case that G1 = G ' whichiseasytoshow. 1 In order to incorporate pattern matching \ninto the core lan\u00adguage, we enlarge the syntax with a new term constructor. Terms e ::= ...|case e0 of \nbox p . e1 else e2 The intended operational interpretation of case is to evaluate the argument e0 to \nobtain a boxed expression box w,then match w to the pattern p. If the matching is successful, it cre\u00adates \nan environment with bindings for the pattern variables, and then evaluates e1 in this environment. If \nthe matching fails, the branch e2 is taken. The typing rule for case is: S;G f. e0: D(P[D])[C] S;\u00b7 .p \n: P[D]=.G1 S;G,G1 f. e1: B[C] S;G f. e2: B[C] S;G f. case e0 of box p . e1 else e2: B[C] Observe that \nthe upper-right premise of case requires an empty '' S,e1 -. S ' ,eS,e2 -. S ' ,e 12 S,(e1 e2)-. S ' \n,(e ' 1 e2) S,(v1 e2) -. S ' ,(v1 e ' 2) S,((.x:A.e) v)-. S,[v/x]e ' S,e1 -. S ' ,e1 S,(let box u = e1 \nin e2)-. S ' ,(let box u = e1 ' in e2) S,(let box u = box w in e2) -. S,[w/u]e2 e -. we not contracted \nS,.x x:A.e -. S,[.x x:A.e/x]eS,box e -. S,box wS,(new X:P in e) -. (S,X:P),e '' ' S,e -. S ' ,eS,e -. \nS ' ,eS,e -. S ' ,e ' S,(X . e)-. S ' ,(X . e ' ) S,(e@X) -. S ' ,(e ' @X) S,(Y . v)@X -. S,(XY )vS,(e \n[[C]])-. S ' ,(e [[C]]) ' S,e1 -. S ' ,e1 ' . .. S,((.p#K.e ' )[[C]])-. S,[C/p]eS,({X = e1} e2)-. S \n' ,({X = e ' 1} e2) S,({X =v} e2)-. S,{v/X}e2 Figure 3. Structured operational semantics of the core \nlanguage. xi:Pi . G C . dom(S,.) C . dom(S,.) C . dom(S,.) S;G . [E .x]: P[C]=. E: ... D(P[C,X]) S;G,x:P \n. x : P[C]=.\u00b7 S,X:P;G. X : P[X,C]=.\u00b7 X1:P1 Xn:Pn NN S;G,x:P1 .p : P2 [C]=. G1 S;G .p1: P2 . P[C]=. G1 \nS;G .p2: P2 [C]=. G2 S;G ..x:P1. p : P1 . P2 [C]=. G1 S;G. (p1)(p2: P2): P[C]=. G1,G2 Figure 4. Selected \ntyping rules for patterns. variable context, so that patterns cannot contain outside value or expression \nvariables. The operational semantics for patterns is given through the new judgment S;G;w . p=. S ' ,T \n which reads: in a global context of names S, global context of parameters ., context of local variables \nG, and the support C, the matching of contracted expression w to the pattern p extends the global store \nto S ' and generates a substitution T for the pattern-variables of p. We present several interesting \nrules below. fv(w).{x1,...,xn} X1,...,Xn fresh xi:Pi . G S;.;G;w . [E .x]=. (S,Xi:Pi),[E . (.X . box \n[.X/.x]w)] S;.;G,x:P;w . p=. S ' ,T S;.;G;.x:P.w . .x:P.p=. S ' ,T S;G;w1 . p1 =. S1,T1 S;G f w2: P2 \n[S] S1;G;w2 . p2 =. S2,T2 S;G;(w1 w2). (p1)(p2:P2)=. S2,(T1 . T2) As already mentioned, the pattern \nvariable [Ex1 \u00b7\u00b7\u00b7 xn] should match an expression w provided that w depends only on vari\u00adables x1,...,xn. \nThus, the rule for pattern variables explicitly provides the required check. The residual substitution \nbinds the pattern variable E to a term obtained from w in which the listed variables xi are substituted \nby newly generated names Xi and then abstracted. The soundness of the operational seman\u00adtics for patterns \nhinges on the following de.nition and lemma.  De.nition 5 (Types for Substitutions) The judgment S f.T \n: G denotes that T is a substitution for the variables in G, and that the substituting terms allow occur\u00adrences \nof only the names in S.In other words S f.T : G if for every pattern-variable E:A . G we have S;\u00b7f.T(E) \n: A[]. Lemma 6 (Pattern-matching Type Preservation) If S;G ' .p : P[C]=. G2 and S;G ' f. w : P[C] and \n11 S;.;G ' 1;w . p=. S ' ,T,then S 'f.T : G2. The theory already developed for the core languages readily \nextends to intensional code analysis. In particular, it is easy to establish the new cases arising in \nthe Substitution Principles (Lemma 1), Parametricity of Typing (Lemma 2), and espe\u00adcially in the Progress \nand Preservation theorem (Theorem 4). The interested reader is referred to the forthcoming report [12] \nfor the details. Example 2 We can generalize the exponentiation ex\u00ad ample further: instead of powering \nonly integers, we can power functions too, i.e. have a functional com\u00ad puting f . .x. (fx)n . The functional \nis passed the code for f , and an integer n, and returns the code for .x. ( fx)n . The idea is to have \nthis residual code be as fpow1 : D(int->int) -> int -> D(int->int) = .f:D(int->int). .n:int. let box \np = pow n box g = f in box (.z:int. p (g z)) end -fpow1 (box .y:int. y + 1) 2; Example 3 This example \nis a (segment) of a function for sym\u00adbolic differentiation. The function takes a name abstraction as \nan argument: the body of the abstraction is a boxed term en\u00adcoding the expression to be differentiated; \nthe abstracted name represents the variable with respect to which the differentia\u00adtion takes place. When \nthe boxed expression is a sum of two subexpressions, the function just recurses over them. When the boxed \nexpression is a beta-redex (of a limited form), it .rst reduces it before recursing. Other names and \nconstants are matched in the default case, which thus returns the derivative 0. val it = box (.z:int. \n(.x.x*(x*1)) ((.y.y+1) z)) : D(int->int) diff : .p. (fix diff. N X:real.Dreal[X, p]) -> ( N X:real.Dreal[X, \np]) = optimized as possible, while still computing the extensionally .p. .e:( X:real.Dreal[X, p]). same \nresult. One possible implementation of this functional in our core language is given above. As a matter \nof fact, there is at least one other way to obtain the same: we can eliminate the outer beta redex from \nthe above residual code, at the price of duplicating the inner one. fpow2 = .f:D(int->int). .n:int. new \nX:int in let box f = f box e = pow [[X]] (box (f X)) n in box (.x:int. {X=x} e) end -fpow2 (box (.y:int. \ny + 1)) 2; val it = box (.x:int. ((.y.y+1) x) * ((.y.y+1) x) * 1) : D(int->int) Neither of the above \nimplementations is quite satisfactory, since, evidently, the residual code in both cases contains un\u00adnecessary \nredices. The reason is that we do not utilize the intensional information that the passed argument is \nactually a boxed lambda abstraction, rather than a more general expres\u00adsion of a functional type. Both \nthe shown programs can be en\u00adcoded in other meta-programming languages such as .O and MetaML. In .D, \none has to be content with a rather weaker program that produces even more unnecessary redices. But, \nin our language extended with intensional code analysis, we could do a bit better. We could test the \nargument at run-time and output a more optimized code if it is a lambda expression. This way we obtain \nthe most simpli.ed, if not the most ef.\u00adcient residual code. fpow : D(int->int) -> int -> D(int->int) \n= .f:D(int->int). .n:int. case f of box (.x:int. [E x]) => new X:int in let box F = pow [[X]] (E @ \nX) n in box (.x:int. {X=x} F) end else fpow1 f n -fpow (box .x:int. x + 1) 2; val it = box(.x:int.(x+1)*(x+1)*1): \nD(int->int) new X:real in case (e @ X) of box X => X.(box 1) | box ([E1] + [E2]) => let box e1 = \n(diff [[p]] (X.E1)) @ X box e2 = (diff [[p]] (X.E2)) @ X in X.box (e1 + e2) end | box ((.x:real. [E1 \nx]) [E2]:real) => new Y:real in let box e1 = E1 @ Y box e2 = E2 in diff [[p]] (X.box ({Y= e2} e1)) \nend else X.(box 0) Notice that the present lack of polymorphic patterns prevents us from recognizing, \nlet alone reducing all the beta redices that could possibly occur in the argument; we currently let them \npass through the default case.  6 Conclusions and future work This paper presents a typed functional \nlanguage for meta\u00adprogramming, employing a novel way to de.ne a modal type of code. The system combines \nthe .D-calculus [15] with the notion of names based on the developments in FreshML and Nominal Logic \n[17, 7, 16, 6]. The motivation for combin\u00ad ing the two comes from the long-recognized need for meta\u00adprogramming \nto handle code expressions with free variables [2, 22, 11]. .D provides a way to encode closed syntactic \ncode expressions, and names serve to stand for the eventual free variables. Taken together, they give \nus a way to encode open syntactic code expressions, and also compose, evaluate, inspect and destruct \nthem. N Another way to view the work presented here is as a higher\u00adorder extension of the FreshML concept \nof names. Indeed, in FreshML, types of names are separated from the types of the rest of the language. \nIn this sense, the syntax trees that FreshML can manipulate are .rst-order. But, if one wants syn\u00adtax \ntrees of typed syntax (i.e. higher-order syntax), then it seems necessary to make a distinction between \nthe meta-level and the object-level (i.e. syntax level) of the language. In other (* the differentiating \nname *) words, one needs a modal type constructor like our D.Not sur\u00adprisingly then, yet another way \nto view our contribution is as a generalization of the system presented in [4] for primitive recursion \nover higher-order abstract syntax. We list below some extensions of the language which we hope to explore \nin the future. Higher-order types for names With the limitation that names can only be simply-typed, \nour language can encode only ob\u00adject programs with simply-typed free variables. This makes it a two-level, \nrather than a multi-level language like .O and MetaML. It would be interesting to investigate how further \ngeneralization of the typing for names, if possible at all, will in.uence the rest of the language, in \nparticular the operations of name abstraction and concretion. Type polymorphism and type-polymorphic \nrecursion In a meta-programming language, the typing of object programs is made part of the typing of \nthe meta programs. Consequently, such a language has a lot of types to care for and thus needs strong \nnotions of type polymorphism. This was already evi\u00addent from our example program for symbolic differentiation \nin Section 5. Models Last, but probably most important, we should build models for our type system and \nput it on a sound logical foot\u00ading. Interaction between names and modal logic has been of interest to \nphilosophical investigations for quite some time (see [9] and [5]). We hope to draw on this work for \nthe future developments. 7 References [1] C. Calcagno, E. Moggi, and T. Sheard. Closed types for a safe \nimperative MetaML. Journal of Functional Programming, 2001. to appear. [2] R. Davies. A temporal logic \napproach to binding-time analy\u00adsis. In E. Clarke, editor, Proceedings of the Eleventh Annual Symposium \non Logic in Computer Science, pages 184 195, New Brunswick, New Jersey, July 1996. IEEE Computer Society \nPress. [3] R. Davies and F. Pfenning. A modal analysis of staged com\u00adputation. In Conf. Record 23rd ACM \nSIGPLAN/SIGACT Symp. on Principles of Programming Languages, POPL 96, St. Peters\u00adburg Beach, FL, USA, \n21 24 Jan 1996, pages 258 270. ACM Press, New York, 1996. [4] J. Despeyroux, F. Pfenning, and C. Sch\u00a8urmann. \nPrimitive re\u00adcursion for higher-order abstract syntax. In R. Hindley, edi\u00adtor, Proceedings of the Third \nInternational Conference on Typed Lambda Calculus and Applications (TLCA 97), pages 147 163, Nancy, France, \nApr. 1997. Springer-Verlag LNCS. An ex\u00adtended version is available as Technical Report CMU-CS-96\u00ad172, \nCarnegie Mellon University. [5] M. Fitting and R. L. Mendelsohn. First-Order Modal Logic. Kluwer Academic \nPublishers, 1999. [6] M.J.Gabbay. A Theory of Inductive De.nitions with a-Equivalence. PhD thesis, Cambridge \nUniversity, August 2000. [7] M. J. Gabbay and A. M. Pitts. A new approach to abstract syn\u00adtax with variable \nbinding. Formal Aspects of Computing, 2001. Special issue in honour of Rod Burstall. To appear. [8] A. \nGriewank. On Automatic Differentiation. In M. Iri and K. Tanabe, editors, Mathematical Programming: Recent \nDe\u00ad velopments and Applications, pages 83 108. Kluwer Academic Publishers, 1989. [9] S. A. Kripke. Naming \nand Necessity. Harvard University Press, 1980. [10] D. Miller. An extension to ML to handle bound variables \nin data structures. In Proceedings of the Logical Frameworks BRA Workshop, May 1990. [11] E. Moggi, W. \nTaha, Z.-E.-A. Benaissa, and T. Sheard. An ideal\u00adized MetaML: Simpler, and more expressive. In European \nSym\u00adposium on Programming, pages 193 207, 1999. [12] A. Nanevski. Meta-programming with names and necessity. \nTechnical Report CMU-CS-02-123, School of Computer Sci\u00adence, Carnegie Mellon University, April 2002. \n[13] M. F. Nielsen. Combining close and open code. Unpublished, 2001. [14] M. Odersky. A functional theory \nof local names. In Proceedings of 21st Annual ACM SIGACT-SIGPLAN Symposium on Prin\u00adciples of Programming \nLanguages (POPL), pages 48 59, New York, NY, USA, 1994. ACM Press. [15] F. Pfenning and R. Davies. A \njudgmental reconstruction of modal logic. Mathematical Structures in Computer Science, 11:511 540, 2001. \nNotes to an invited talk at the Workshop on Intuitionistic Modal Logics and Applications (IMLA 99), Trento, \nItaly, July 1999. [16] A. M. Pitts. Nominal logic: A .rst order theory of names and binding. In N. Kobayashi \nand B. C. Pierce, editors, TACS,vol\u00adume 2215 of Lecture Notes in Computer Science, pages 219 242. Springer, \n2001. [17] A. M. Pitts and M. J. Gabbay. A metalanguage for program\u00adming with bound names modulo renaming. \nIn R. Backhouse and J. N. Oliveira, editors, Mathematics of Program Construction, MPC2000, Proceedings, \nPonte de Lima, Portugal, July 2000, volume 1837 of Lecture Notes in Computer Science, pages 230 255. \nSpringer-Verlag, Heidelberg, 2000. [18] N. Ramsey and A. Pfeffer. Stochastic lambda calculus and mon\u00adads \nof probability distributions. In Conf. Record 29th ACM SIGPLAN/SIGACT Symp. on Principles of Programming \nLan\u00adguages, POPL 02, Portland, OR, USA, pages 154 165, New York, 2002. ACM Press. [19] G. J. Rozas. Translucent \nprocedures, abstraction without opac\u00adity. Technical Report AITR-1427, Massachusetts Institute of Technology \nArti.cial Intelligence Laboratory, 1993. [20] T. Sheard. Accomplishments and research challenges in meta\u00adprogramming. \nIn W. Taha, editor, SAIG, volume 2196 of Lecture Notes in Computer Science, pages 2 44. Springer, 2001. \n[21] W. Taha. A sound reduction semantics for untyped CBN multi\u00adstage computation. or, the theory of \nMetaML is non-trival. ACM SIGPLAN Notices, 34(11):34 43, 1999. [22] W. Taha. Multi-Stage Programming: \nIts Theory and Applica\u00adtions. PhD thesis, Oregon Graduate Institute of Science and Technology, 1999. \n[23] P. Wickline, P. Lee, and F. Pfenning. Run-time code genera\u00adtion and Modal-ML. In SIGPLAN Conference \non Programming Language Design and Implementation, pages 224 235, 1998. [24] P. Wickline, P. Lee, F. \nPfenning, and R. Davies. Modal types as staging speci.cations for run-time code generation. ACM Com\u00adputing \nSurveys, 30(3es), 1998.  \n\t\t\t", "proc_id": "581478", "abstract": "Meta-programming languages provide infrastructure to generate and execute object programs at run-time. In a typed setting, they contain a modal type constructor which classifies object code. These code types generally come in two flavors: closed and open. Closed code expressions can be invoked at run-time, but the computations over them are more rigid, and typically produce less efficient residual object programs. Open code provides better inlining and partial evaluation of object programs, but once constructed, expressions of this type cannot in general be evaluated.Recent work in this area has focused on combining the two notions into a sound system. We present a novel way to achieve this. It is based on adding the notion of names from the work on Nominal Logic and FreshML to the &#955; -calculus of proof terms for the <i>necessity</i> fragment of modal logic S4. The resulting language provides a more fine-grained control over free variables of object programs when compared to the existing languages for meta-programming. In addition, this approach lends itself well to addition of intensional code analysis, i.e. ability of meta programs to inspect and destruct object programs at run-time in a type-safe manner, which we also undertake.", "authors": [{"name": "Aleksandar Nanevski", "author_profile_id": "81100503327", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP17010203", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/581478.581498", "year": "2002", "article_id": "581498", "conference": "ICFP", "title": "Meta-programming with names and necessity", "url": "http://dl.acm.org/citation.cfm?id=581498"}