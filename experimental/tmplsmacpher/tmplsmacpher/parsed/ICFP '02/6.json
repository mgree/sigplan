{"article_publication_date": "09-17-2002", "fulltext": "\n An Interoperable Calculus for External Object Access [Extended Abstract] * Atsushi Ohori School of Information \nScience JAIST (Japan Advanced Institute of Science and Technology) Ishikawa 923-1292, Japan ohori@jaist.ac.jp \n Kiyoshi Yamatodani School of Information Science JAIST (Japan Advanced Institute of Science and Technology) \nIshikawa 923-1292, Japan ABSTRACT By extending an ML-style type system with record polymor\u00adphism, recursive \ntype de.nition, and an ordering relation induced by .eld inclusion, it is possible to achieve seam\u00adless \nand type safe interoperability with an object-oriented language. Based on this observation, we de.ne \na polymor\u00adphic language that can directly access external objects and methods, and develop a type inference \nalgorithm. This cal\u00adculus enjoys the features of both higher-order programming with ML polymorphism and \nclass-based object-oriented pro\u00adgramming with dynamic method dispatch. To establish type safety, we de.ne \na sample object-oriented language with multiple inheritance as the target for interoperability, de\u00ad.ne \nan operational semantics of the calculus, and show that the type system is sound with respect to the \noperational semantics. These results have been implemented in our pro\u00adtotype interpretable language, \nwhich can access Java class .les and other external resources. Categories and Subject Descriptors D.3.2 \n[Programming Languages]: Language Constructs and Features General Terms: Languages  Keywords interoperability, \ntype inference, record polymorphism, ML, object-oriented language, Java * Atsushi Ohori s work was partially \nsupported by Grant\u00adin-aid for scienti.c research on priority area informatics A01-08, grant no:14019403. \nKiyoshi Yamatodani s current address: Ascade, Inc., 14-3 Takadanobaba 3, Shinjuku, Tokyo 169 0075, Japan. \nE-mail: yamatodani@ascade.co.jp. Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 02, October 4-6, 2002, Pittsburgh, Pennsylvania, USA. Copyright \n2002 ACM 1-58113-487-8/02/0010 ...$5.00. 1. INTRODUCTION Recently emerging component architecture such \nas Java Virtual Machine classes [13], COM [4], and Microsoft .NET, brings a new software develop environment \nwhere the pro\u00adgrammer can use rich collections of libraries implemented in various di.erent languages \nwithout knowing the details of their implementation languages. Unfortunately, however, there does not \nseem to exist any easy and natural way to ma\u00adnipulate these components from an existing statically typed \nfunctional language. This is due to a form of impedance mismatch between interface speci.cation of component \nar\u00adchitecture and static polymorphic typing of modern func\u00adtional languages. One way to overcome this \nproblem is to establish a type theoretical basis for integrating object\u00adoriented model, which underlies \nmost of component frame\u00adworks, and ML-style polymorphism, which underlies func\u00adtional languages. Although \nthere are some similarities, these two paradigms di.er in essential ways in their strength, expressiveness \nand programming styles. In object-oriented programming, the combination of an explicitly declared inheritance \nrelation on classes and dynamic method dispatch achieves .exible ob\u00adject manipulation and .nely controlled \nmethod sharing. For example, this paradigm can naturally represent heteroge\u00adneous collections of objects \nhaving some common properties, and generic methods performing the desired specialized ac\u00adtion dependent \non the target object class. These features are not easily representable in a typed higher-order functional \ncalculus. In contrast, ML-style polymorphic type inference allows type-safe and .exible manipulation \nof higher-order functions without requiring type annotation. A program can be developed by composing \npolymorphic higher-order functions. This feature is not well supported in an object\u00adoriented language. \nThese two paradigms are complementary ones, and we would like to have a language system where we can \nenjoy the bene.ts of both of them. Type theoretical foundations of object-oriented programming have been \nextensively studied and several methods for object-encoding have been proposed (see, for example, [9] \nfor a collection of works on the subject). These results can be used to introduce object manipulation \nprimitives in a polymorphic functional language. This ap\u00adproach is taken in OCaml [12, 20], Moby [7], \nand O Haskell [17]. While this approach can introduce some features of object-oriented programming, it \ncomplicates the language on which it is based, and even with sophisticated type theo\u00adretical machinery, \nit is rather di.cult to provide the simplic\u00adity, .exibility and expressiveness of existing object-oriented \nlanguages. In the present work, we take an alternative approach of developing an ML-style language with \na minimum extension for interfacing with a class-based object-oriented language. This is based on our \nfollowing observations. The typing mechanism for using classes should be much simpler than that for \nde.ning classes and methods. Al\u00adthough it appears to be rather di.cult to extend an ML-style type inference \nsystem with the full features of object-oriented programming including inheritance and dynamic method \ndispatch, it would be feasible to extend it with a mechanism to use existing classes and methods implemented \nin an object-oriented language.  This approach would also yields an ML-style interop\u00aderable language, \nwhere the programmer can freely use a rich collection of object-oriented classes within an advanced polymorphic \ntype inference system.  The goal of this paper is to establish type theoretical ba\u00adsis for interoperability \nand to develop such an interoperable language. We de.ne (in Section 3) a functional calculus as an exten\u00adsion \nof the core of ML with the primitives for object creation and method invocation. The intended semantics \nof these primitives is to call an external object-oriented language and to perform object creation and \ndynamic method dis\u00adpatch in the external language. The external object-oriented language can be any one \nas far as it is a class-based stati\u00adcally typed language such as Java. For the functional calcu\u00adlus, \nwe develop a polymorphic type system and an ML-style type inference algorithm. To incorporate the two \nimportant features of objects polymorphic method invocation and subsumption we base our development \non a polymorphic record calculus [18], whose type system is strong enough to represent objects and methods \nin a given class hierarchy. To show type safety of our interoperable primitives, we de\u00ad.ne (in Section \n4) a sample object-oriented language and its operational semantics. We then de.ne (in Section 5) an operational \nsemantics of our calculus, which refers to the operational semantics of the object-oriented language, \nand establish that the type system is sound with respect to the operational semantics. The interoperable \ncalculus presented in this paper has been implemented with Java as the target for its interoper\u00adability. \nIn this language, a program can import a collection of Java classes and invoke object constructors and \nmethods, which are executed in a Java Virtual Machine runtime sys\u00adtem through JNI interface. In Section \n6, we discuss some practical issues in designing an interoperable language and describe our prototype \nimplementation. Before giving a technical development of our interoperable calculus, in the next section, \nwe outline our approach and compare it with related works. 2. AN APPROACH TO INTEROPERABLE TYPE SYSTEM \nThe static structure of an object-oriented program is rep\u00adresented as a collection of classes connected \nwith a sub\u00adclass relation. A straightforward approach of extending ML with objects would be to add class \nhierarchy (a collection of classes and the associated subclass relation) with the sub\u00adsumption rule of \nthe form: T . e : c c<: c . T . e : c . This seemingly simple extension signi.cantly complicates both \nthe type inference algorithm and the representation of a type of a program. An inferred type of a polymorphic \nprogram involves a set of order constraints, and becomes di.cult to understand for the programmer. For \nexample, even a very simple function such as .f..x.f x can no longer be given a simple polymorphic type. \nConsidering extensive usage of higher-order polymorphic functions in ML program\u00adming, we would like to \navoid this complication. Our strategy is to decompose the mechanism of class in\u00adheritance into parametric \npolymorphism and a limited form of object subsumption. The class inheritance in object\u00adoriented programming \nappears to support the following two features. 1. Polymorphic method invocation. A method of a class \ncan be applied to objects of its subclasses. For example, move method in a point class can be applied \nto an object of colorPoint class. More\u00adover, if a method is rede.ned in some of the subclasses, then \nthe method code actually invoked is determined by the actual (run-time) class of the object. 2. Object \nsubsumption. An object of a class can be used as an object of any of its superclasses. For example, one \ncan form a pointSet containing objects of various subclasses of point, and iterate a method move over \nthe collection.  In an object-oriented class system, these two are combined. However, these two aspects \nhave di.erent requirements in a static polymorphic type system. The .rst feature is precisely represented \nby the combi\u00adnation of record polymorphism [18, 19] and external method invocation. We represent the \ntype of an object as a form of a record type containing all the applicable method signatures. Suppose \na class c contains a set of methods m1 : .1,...,mn : .n. Then the type of an object of class c is represented \nas a record type of the form {m1 : .1,...,mn : .n,...}. Poly\u00admorphic typing of .eld selection expression \ne.m in a record calculus is su.cient for typechecking polymorphic method invocation. We then bind the \nmethod invocation e.m not to a particular method but to a code in the external language that performs \ndynamic method invocation. Conceptually, the meaning of e.m is the .-expanded method invocation operation \nof the form .x.invoke(x, m) in the target object-oriented language where invoke is an operation that \nperforms dynamic method dispatch such as invokevirtual in JVM. In this way, we achieves the desired features \nof polymorphic method invocation with dynamic method dispatching semantics. The above structural encoding \nmay incorrectly equate classes that have the same set of method names and signa\u00adtures. In order to rectify \nthis problem and also to account for the second feature of object subsumption, we re.ne our representation \nof a class c as follows {m1 : .1,...,mn : .n,...,c : unit, c1 : unit, . . . , cn : unit} to include class \nname c and all its superclass names c1,...,cn as record labels. This encoding explicitly speci.es the \nset of all classes to which an object belongs, and properly rep\u00adresents the uniqueness of each class. \nFurthermore, by com\u00adbining a shallow subsumption relation on record types, this encoding allows us to \ntype expressions such as [p,cp,...] or if e then p else cp where [e1,e2,...] is a list for\u00admation expression \nand p and cp are assumed to be of type point and colorPoint respectively. Since we do not extend this \nrelation to other type constructors including function type, the necessary extension to polymorphic type \ninference is relatively small. We should note that this subsumption relation is not needed for polymorphic \nmethod invocation. In fact, eliminating this mechanism yields a slightly cleaner type system while retaining \nmost of the features except for heterogeneous collections. Since method signatures . in general contain \nclasses, we represent a given set of classes as a set of mutually recursive type equations of the form \nc =[ c] where [ c] is the encoding of c described above. To illustrate some .avor of the polymorphic \ninteroperable calculus we shall develop in this paper, let us show some examples. Suppose we have a class \nprintable containing a method toString, then we can easily write a polymorphic function fun layout L \n= foldr (fn (obj,rest) => obj.toString ^ rest) \"\" L : .(t :: { toString : t . string} ).list(t) . string \nand map layout function over a list of printable objects, where fun is ML-style function de.nition and \nlist(t) is list type whose element type is t. The notation .(t :: { toString : t . string} ) indicates \nthat type variable t ranges over ob\u00adject types containing the .eld toString : t . string. When applied, \nthis function invokes toString method on each ob\u00adject of the list in the target object-oriented language, \nper\u00adforming the desired specialized action depending on the ac\u00adtual class of the object. Figure 1 shows \nsome more exam\u00adples. As seen from these examples, object-oriented features including method dispatch \nand manipulation of heteroge\u00adneous collections can be freely combined with the feature of higher-order \nfunctions with ML polymorphism. Super.cially, these examples may appear simple instances of well studied \nrecord calculi, but they are not. We note that the external method invocation such as p.move dispatches \nmove method on the object denoted by p, achieving the e.ect of dynamically choosing the appropriate methods \ndepending on the actual class of the object. 2.1 Comparison with other approaches Most of existing approaches \nuse some form of subtyping to represent subclass relation in object-oriented programming. The simplest \nform of subtyping in type theory is struc\u00adtural subtyping [2], which is derived from the inclusion rela\u00adtion \non sets of .elds of record types. This has been the basis of polymorphic method de.nition and for object \nsubsump\u00adtion. However, a subclass relation in typical object-oriented languages is a name subtyping explicitly \ndeclared by the programmer, and is not directly representable by structural subtyping. One of the central \nissues in designing a functional language with object oriented features has been to properly capture \nname subtyping. Moby [7] combines structural sub\u00adtyping with name subtyping to form a hybrid system. \nA type system of Objective ML [20], which underlies OCaml [12], introduces explicitly declared class \nhierarchy on top of a type system with structural subtyping. O Haskell [17] adopts a name subtyping on \nrecord like constructs. Each of these approaches captures the features of subclass rela\u00adtion to some \nextent. Observing the complexity of required type theoretical machinery and also the di.culty of achiev\u00ading \nsimple and powerful inheritance of object-oriented lan\u00adguage, Mondrian [14] avoids subtyping and resolves \nsubclass relation dynamically with a mechanism for catching runtime type error. Complications in these \napproaches come from their need to provide language constructs for de.ning class hierarchy. In contrast, \nour approach shows that record types and record polymorphism are su.cient to use an existing class hierar\u00adchy. \nThe feature of name subtyping is represented by in\u00adcluding class names in the representing record type. \nApproaches most closely related to ours are those based on phantom types . In [5], it is shown that interface \nhi\u00aderarchy of COM is represented in Haskell using phantom types. However, this approach does not directly \napplicable to multiple interface inheritance found, for example in Java. This problem is solved in Lambada \n[15] by using type class mechanism [10] of Haskell based on the following techniques. Java class c is \nencoded as a type T using phantom types, and if c implements interfaces I1, \u00b7\u00b7\u00b7 ,In, a type class is \nde\u00adclared for each Ii with T as its instance. While we see that this encoding works, type class itself \nis an elaborate system requiring certain amount of type theoretical machinery, and its relationship to \nsubclass is not entirely clear. Also, in these proposals, the issue of type safety is not investigated. \nIn contrast, our system achieves seamless interoperabil\u00adity with existing classes using the basic properties \nof record structures, and its type soundness is formally established.  3. THE INTEROPERABLE CALCULUS \nThis section de.nes the interoperable calculus. 3.1 Syntax of the calculus The set of terms of the calculus \nis given by the following abstract syntax. e ::= c b | x | .x.e | ee | let x = e in e end | if e then \ne else e | new c(e, \u00b7\u00b7\u00b7 ,e) | e.l | e.m(e, \u00b7\u00b7\u00b7 ,e) The .rst two lines are those of core ML. The rest \nare those for invoking operations in an external object-oriented lan\u00adguage. new c(e1, \u00b7\u00b7\u00b7 ,en) creates \na new object of class c by calling the constructor of c with n arguments. e.l retrieves the value of \n.eld l of e. e.m(e1, \u00b7\u00b7\u00b7 ,en) invokes method m on e with n arguments. Objects reside in a heap of an \nex\u00adternal object-oriented language, and all these operations are performed in the external language. \nAlthough we only explicitly include external object types and base types, various (internal) data structures \ncan also be added. As we mentioned, the introduction of the standard list type enables us to represent \nheterogeneous collections of external objects without any additional machinery. There are some issues \nin adding records depending on whether we type point = {X : int, Y : int, move : int \u00d7 int . unit, point \n: unit} and colorP oint = {X : int, Y : int, color : string, move : int \u00d7 int . unit, point : unit, colorPoint \n: unit} fun getX p = p.X : .(t2::U, t1::{ X : t2} ).t1 . t2 fun slide p = (p.move(getX p,0); p) (* \n(e1; e2) is a sequence expression a la ML *) : .(t2::U, t3::U, t1::{ X : t2, move : t2 \u00d7 int . t3} ).t1 \n. t1 val points = [new point (0,0), new cpoint (0,0,\"red\")] : list({X : int, Y : int, move : int \u00d7 int \n. unit, point : unit}) map slide points : list({X : int, Y : int, move : int \u00d7 int . unit, point : unit}) \nFigure 1: Example typings in the interoperable calculus want to treat objects and records uniformly or \nnot. We shall comment on this when we describe our prototype implemen\u00adtation in Section 6.  3.2 Assumptions \non class structures The calculus includes external objects. To develop a static type system for the calculus, \nwe need to make some assump\u00adtions on static structure of classes to which those external objects belong. \nWe let c range over class names and b range over base types. We use o to denote either a class name or \na base type, and . to denote a method type of the form o1 \u00d7\u00b7\u00b7\u00b7\u00d7 on . o representing the type of a method \nwhich takes a tuple of objects of types o1,...,on (other than the receiver object) and yields an object \nof type o. In an actual programming language, the external classes to be used is declared by the programmer. \nIn Section 6, we discuss a mechanism for importing external classes in the perspective of practical language \ndesign and implemen\u00adtation. However, since they do not a.ect the typing mecha\u00adnism we develop in this \npaper, to simplify the presentation, we assume that we are given a .xed collection of classes, and that \ntheir static structure is described in a class environment C consisting of the following: the set of \nclass names and the associated subclass re\u00adlation,  for each class name c, the set fields of .eld signa\u00adtures \n{f1 : o1,...,fn : on} of c (including all those inherited),  for each class name c, the type of its \nconstructor, and  for each class name c, the set methods of method sig\u00adnatures {m1 : .1,...,m1 : .1} \nof c (including all those inherited).  ' ' We write Cf c<: cif c is a subclass of c, and write C(c).ancestors \nfor {c'|C f c<: c'}; we write C(c).fields and C(c).methods for the sets of .eld signatures and method \nsignatures of c in C, respectively. We also use the following notations. Cf f : o . c if c has a .eld \nf : o,  Cf m : . . c if c has a method m : ., and  Given a set of class de.nitions in an object-oriented \nlanguage such as Java class .les, a class environment can easily be extracted. 3.3 Object types and \nclasses We write {l1 : .1, \u00b7\u00b7\u00b7 ,ln : .n} for a type of an external object whose static properties are \ndetermined by the set of .elds l1 : .1, \u00b7\u00b7\u00b7 ,ln : .n. To deal with mutual dependency between classes \nand method signatures, we represent a class as a recursive object type. Since the class structure C is \nalready given, it is su.cient to introduce explicit recursive type declarations. Furthermore, since objects \nare created by primitive construct new, no special mechanism for recursive object creation is needed. \nLet c1,...,cn be the set of class names de.ned in a given class environment C. We regard c1,...,cn as \ntype names in the calculus, and de.ne for each c, the encoding C[ c] of the object structure of c under \nC as follows. C[ c] = {f1 : o1, \u00b7\u00b7\u00b7 ,fk : ok, m1 : .1, \u00b7\u00b7\u00b7 ,mm : .m, c1 : unit, . . . , cn : unit} where \nC(c).fields = {f1 : o1, \u00b7\u00b7\u00b7 ,fk : ok} C(c).methods = { m1 : .1, \u00b7\u00b7\u00b7 ,mm : .m} C(c).ancestors = {c1,...,cn} \nThe encoding of the class hierarchy described in C is given by the following mutually recursive type \nequations. type c1 = C[ c1] . . . and cn = C[ cn] The type system of the interoperable calculus is de.ned \nwith respect to this set of recursive type equations. Di.erent from datatype declarations in Standard \nML, these are treated as transparent equations, i.e. ci is equal to the corresponding object type.  \n3.4 The type system The type system is given based on the kinded type system [18] for record polymorphism. \nThe set of monotypes (ranger Cf new : . . c if . is the type of the constructor of c. over by t ), kinds \n(ranged over by k), and polytypes (ranged over by s) are given by the following abstract syntax. t ::= \nt | o | . | t . t |{l : t, \u00b7\u00b7\u00b7 ,l : t} k ::= U |{ l : t, \u00b7\u00b7\u00b7 ,l : t} s ::= t |.(t :: k, \u00b7\u00b7\u00b7 ,t :: k).s \nt stands for a given countably in.nite set of type variables. U is the universal kind, denoting the set \nof all monotypes. { l : t, \u00b7\u00b7\u00b7 ,l : t } is an object kind (corresponding to a record kind in [18]) denoting \nthe set of all object types contain\u00ading the designated .elds. .(t :: k, \u00b7\u00b7\u00b7 ,t :: k).s is a kinded abstract \ntypes whose instances are restricted to those that satisfy kind constraints. Types are considered modulo \ntype equivalence de.ned in a given C. In the following development, we generally as\u00adsume type equations \nimplicitly, and use type name ci for the declared object type. When we need to mention type equivalent \nexplicitly, we write Cf c = t if c is equal to t under C. The calculus does not have any constructor \nfor method type . or a tuple type o1 \u00d7\u00b7 \u00b7\u00b7\u00d7 on. These are only used in external object manipulation, \nand . appearing outside of object types are useless. On the set of object types, we de.ne the following \nshallow subtype relation. t <t {l1 : t1, \u00b7\u00b7\u00b7 ,ln : tn, \u00b7\u00b7\u00b7} < {l1 : t1, \u00b7\u00b7\u00b7 ,ln : tn} Di.erent from the \nordinary subtyping such as those [16, 2, 3] and subsequent studies on subtyping, it indicates inclusion \nof .elds of object types, and it is identity on all the other types. The following de.nitions on kinding \nare taken from [18]. The set of free type variables of a type s or a kind k are denoted by FTV (s) and \nFTV (k), respectively. A kind assignment, ranged over by K, is a mapping from a .nite set of type variables \nto kinds. A kind assignment K is well formed if for all t . dom(K), FTV (K(t)) . dom(K), where dom(f) \ndenotes the domain of function f. We implicitly as\u00adsume that any kind assignment appearing in the rest \nof the development is well formed. A type s has a kind k under K, denoted by Kf s :: k, if it is derivable \nby the following set of kinding rules. Kf t :: U Kf t :: k if K(t)= k Kf{l1 : t1, \u00b7\u00b7\u00b7 ,ln : tn} :: { \nl1 : t1, \u00b7\u00b7\u00b7 ,ln : tn} Kf t :: { l1 : t1, \u00b7\u00b7\u00b7 ,ln : tn,... } Kf t :: { l1 :: t1, \u00b7\u00b7\u00b7 ,ln : tn} A substitution \nS is well formed under a kind assignment K if for any t . dom(S), S(t) is well formed under K.A kinded \nsubstitution is a pair (K,S) of a kind assignment K and a substitution S that is well formed under K. \nThe kind assignment K in (K,S) speci.es kind constraints of the result of the substitution. A kinded \nsubstitution (K,S) is ground if K = \u00d8. We usually write S for a ground kinded substitution (\u00d8,S). A kinded \nsubstitution (K1,S) respects a kind assignment K2 if for any t . dom(K2), K1 f S(t) :: S(K2(t)). Let \ns1 be a polytype well formed under K. We say that s2 is a generic instance of s1 under K, written Kf \ns1 if s1 = .(t11::k1 \u00b7\u00b7\u00b7 ,tn1 n = s2, 1, ::k1 ).t1, K, T . c b : b Kf s = t K, T{x : s} . x : t K, T{x \n: t1} . e : t2 K, T . .x.e : t1 . t2 K, T . e1 : t1 . t2 K, T . e2 : t1 K, T . e1 e2 : t2 K, T . e1 : \nt1 Cls(K, T ,t1)=(K ' ,s) K ' , T{x : s} . e2 : t2 K, T . let val x = e1 in e2 end : t2 K, T . e0 : bool \nK, T . e1 : t K, T . e2 : t K, T . if e0 then e1 else e2 : t K, T . e : t Kf t :: { l : t1} K, T . e.l \n: t1 K, T . e : t Kf t :: { m : t1 \u00d7\u00b7 \u00b7\u00b7\u00d7 tn . t0} K, T . ei : ti (1 = i = n) K, T . e.m(e1, \u00b7\u00b7\u00b7 ,en): \nt0 Cf new : o1 \u00d7\u00b7 \u00b7\u00b7\u00d7 on . o . c K, T . ei : oi (1 = i = n) K, T . new c(e1, \u00b7\u00b7\u00b7 ,en): o K, T . e : \nt1 t1 <t2 K, T . e : t2 Figure 2: The type system of the interoperable cal\u00adculus s2 = .(t12::k12 , \u00b7\u00b7\u00b7 \n,t2 ::k2 ).t2, and there is a substitution S mm 112 2 such that dom(S)= {t1, \u00b7\u00b7\u00b7 ,tn},(K{t1::k12 , \u00b7\u00b7\u00b7 \n,tm::k2 },S) m respects K{t11::k1 \u00b7\u00b7\u00b7 ,t1 ::k1 } and t2 = S(t1). 1, nn A typing environment, ranged over \nby T , is a mapping from a .nite set of variables to polytypes. We write T{x : s}for the type environment \nT ' such that dom(T ' )= dom(T ). {x}, T ' (x)= s, and T ' (y)= T (y) for all y . dom(T ' ),y =. x. The \nclosure of t under T , K, denoted by Cls(K, T ,t ), isa pair (K ' , .(t1::k1, \u00b7\u00b7\u00b7 ,tn::kn).t ) s.t. K \n' {t1::k1, \u00b7\u00b7\u00b7 ,tn::kn} = K and {t1, \u00b7\u00b7\u00b7 ,tn} is the set of type variables free in t under K but not \nfree in T under K. Using these notations, the type system is de.ned as a proof system to derive a judgment \nof the form K, T . e : t indicating the fact that e has type t under T and K. The set of typing rules \nis given in Figure 2. The combination of our object representation, record poly\u00admorphism and object subsumption \nprovides the su.cient power to use objects and methods within an ML-style poly\u00admorphic calculus. The \ntyping examples shown in Figure 1 are indeed derivable typings in this type system.  3.5 Type inference \nOne of the goal of designing this calculus is to preserve the bene.t of ML-style polymorphic type inference. \nFor this purpose, we need to develop a type inference algorithm. We use the kinded uni.cation algorithm \n[18] for record type inference. A kinded set of equations is a pair (K,E) consisting of a kind assignment \nK and a set E of pairs of types such that E is well formed under K. We say that a substitution S satis.es \nE if S(t1)= S(t2) for all (t1,t2) . E. A kinded substitution (K1,S) is a uni.er of a kinded set of equations \n(K,E) if it respects K and if S satis.es E.(K1,S) is a most general uni.er of (K2,E) if it is a uni.er \nof (K2,E) and if for any uni.er (K3,S2) of (K2,E) there is some substitution S3 such that (K3,S3) respects \nK1 and S2 = S3 . S. The following is shown in [18]. Theorem 1. The algorithm U takes any kinded set of \nequations, computes a most general uni.er if one exists, and reports failure otherwise. In order to infer \ntypes under the implicit subtyping on objects, we also need the following two algorithms S and F for \nsubtype checking and for the least upper bound compu\u00adtation: S(K,t1,t2) returns (K ' ,S) such that t0 \n= S(t1) < S(t2) if such substitution exists otherwise it returns failure.  F(K,t1,t2) returns (K ' ,t0,S) \nsuch that (1) t0 is the least one satisfying t0 <S(t1) and t0 <S(t2), and  (2) t0 contains at least \none class label, if such K, S, to exist, otherwise it returns failure. These algorithms are given in \nFigure 3. Using these auxiliary algorithms, we de.ne a type in\u00adference algorithm WK which takes (K, T \n,e) and returns (K ' , S, t) or failure. The algorithm is given in Figure 4. For this algorithm, we can \nshow the soundness property simi\u00adlarly to the corresponding theorem in [18]. This algorithm is, however, \nnot complete; there is a ty\u00adpable term for which the type inference algorithm reports failure. This occurs \nin combination of .rst-class functions and object subsumption. To show a typical counter exam\u00adple, we \nassume that Cf c<: c ' , Cf new : int . c . c, and Cf new : int . c ' . c ' . Then the following term \ncan be typable but the algorithm reports failure. (.x.z (yx)(y (new c(0))) (yx)) (new c ' (0)) The problem \nis that type inference algorithm only consider possibility of applying subsumption rule for concrete \nobject types but not for type variables. As a result, the type of x is (prematurely) uni.ed to c. This \nincompleteness would have been a severe limitation if subsumption rule were the source of polymorphism \nof method application. In our calculus, however, method invo\u00adcation (e.m(e1,...,en)) is given polymorphic \ntyping through kinded record polymorphism, and the subsumption rule is introduced for typing heterogeneous \ncollections. We believe that typable terms that are rejected by our conservative type inference are negligible. \nA trivial way to recover completeness of type inference is to eliminate the subsumption rule in the type \nsystem, and to modify the type inference algorithm so that S and F return failure if the two types are \nnot uni.able. The resulting type system is still strong enough to interfacing with an object\u00adoriented \nlanguage. In fact, our prototype implementation S(K, {F1}, {F2})= if dom(F1) . dom(F2) then U(K, {(F1(l),F2(l))|l \n. dom(F1)}) else failure S(K,t1,t2)= U(K, {(t1,t2)}) F(K, {F1}, {F2})= let L = dom(F1) n dom(F2) (K1,S1)= \nU(K, {(F1(l),F2(l))|l . L}) F3 = the restriction of F1 on L in if L does not contain class label then \nfailure else (K1,S1,S1({F3})) F(K,t1,t2)= let(K,S)= U(K, {(t1,t2)}) in(K, S, S(t1)) Figure 3: Subtyping \nchecking and least upper bound computation does not contain subsumption rule for a di.erent reason, which \nwe shall discuss in Section 6, and it still demonstrates its expressiveness. The only missing feature \nis heterogeneous collections. A more systematic way to recover completeness of type in\u00adference retaining \nthe subsumption rule would be to perform type inference modulo subclass relation similarly to those in \n[16, 8, 21]. The rationale of not pursuing this direction is twofold: (1) it signi.cantly complicates \nthe type inference system and makes inferred types di.cult to understand, and (2) the extra generality \nis negligible. We believe that the current de.nition is a good com\u00adpromise for adding the feature of \nheterogeneous collections without introducing much complication to the underlying ML-style type inference \nsystem.  4. A SAMPLE OBJECT-ORIENTED LAN-GUAGE We believe that the proposed calculus serves as a model \nof a language that achieves type safe interoperability with various object-oriented languages. To demonstrate \nthis, we de.ne a sample object-oriented language. It is not our pur\u00adpose to study type theoretical issues \nin object-oriented lan\u00adguages but to de.ne a language that is expressive enough to study the issues in \ninterfacing with other systems. To this purpose, we believe a language with the following features is \nsu.cient: a class system with multiple inheritance, and  dynamic method dispatch.  Since the interoperable \nprimitives only depends on class structures in its static semantics, and on method dispatch in its dynamic \nsemantics, the results we shall establish with the sample language should be applicable to other object\u00adoriented \nlanguages with various features such as interface de.nitions. WK(K, T ,x)= if x .. dom(T )then failure \nelse let .(t1 :: k1, \u00b7\u00b7\u00b7 ,tn :: kn).t = T (x), S =[s1/t1, \u00b7\u00b7\u00b7 ,sn/tn](s1, \u00b7\u00b7\u00b7 ,sn fresh) in (K{s1 :: \nS(k1), \u00b7\u00b7\u00b7 ,sn :: S(kn)}, \u00d8,S(t)) WK(K, T ,e1 e2)= let (K1,S1,t1)= WK(K, T ,e1) (K2,S2,t2)= WK(K1,S1(T \n),e2) (K3,S3)= U(K2, {(S2(t1),t . s)})(t, s fresh) (K4,S4)= S(K3,S3(t2),S3(t)) in (K4,S4 . S3 . S2 . \nS1,S4 . S3(s)) WK(K, T , let x = e1 in e2 end)= let (K1,S1,t1)= WK(K, T ,e1) (K1' ,s1)= Cls(K1,S1(T ),t1) \n(K2,S2,t2)= WK(K ' 1, (S1(T )){x : s1},e2) in (K2,S2 . S1,t2) WK(K, T , if e0 then e1 else e2)= let \n(K0,S0,t0)= WK(K, T ,e0) (K1,S1)= U(K0, {(t0, bool)}) (K2,S2,t1)= WK(K1,S1 . S0(T ),e1) (K3,S3,t2)= WK(K2,S2 \n. S1 . S0(T ),e2) (K4,S4,t )= F(K.,t1,t2) in (K4,S4 . S3 . S2 . S1 . S0,t ) WK(K, T ,e1.l)= let (K1,S1,t1)= \nWK(K, T ,e1) (K2,S2)= U(K1{t :: U,s :: { l : t}}}, {(s, t1)})(t, s fresh) in (K2,S2 . S1,S2(t)) WK(K, \nT , e.m(e1, \u00b7\u00b7\u00b7 ,en)) = let (K0,S0,t0)= WK(K, T ,e) (K1,S1,t1)= WK(K0,S0(T ),e1) (K2,S2,t2)= WK(K1,S1 \n. S0(T ),e2) . . . (Kn,Sn,tn)= WK(Kn-1,Sn-1 .\u00b7 \u00b7\u00b7. S0(T ),en) (Kn+1,Sn+1)= U(Kn{t :: U,s :: { m : t}}}, \n{(s, Sn .\u00b7 \u00b7\u00b7. S1(t0))})(t, s fresh) (Kn+2,Sn+2)= U(Kn+1, {(Sn+1(t), Sn+1 .\u00b7 \u00b7\u00b7. S2(t1)\u00d7 \u00b7\u00b7\u00b7\u00d7 Sn+1(tn) \n. r)}) (r fresh) in (Kn+2,Sn+2 .\u00b7 \u00b7\u00b7. S0,Sn+2(r)) WK(K, T , new c(e1, \u00b7\u00b7\u00b7 ,en)) = let (K1,S1,t1)= WK(K, \nT ,e1) (K2,S2,t2)= WK(K1,S1(T ),e2) . . . (Kn,Sn,tn)= WK(Kn-1,Sn-1 .\u00b7 \u00b7\u00b7. S1(T ),en) (Kn+1,Sn+1)= U(Kn, \n{(.0, Sn .\u00b7 \u00b7\u00b7. S2(t1) \u00d7\u00b7 \u00b7\u00b7\u00d7 tn . t)}) where Cf new : .0 . c and t fresh in (Kn+1,Sn+1 .\u00b7 \u00b7\u00b7. S1,Sn+1(t)) \n Figure 4: Type inference algorithm (excerpts) 4.1 The syntax and the type system We consider the language \ngiven by the following syntax. P ::= classdef C; \u00b7\u00b7\u00b7 ; C in e C ::= class c extends {c, . . . , c} = \nF with M F ::= {f : o, . . . , f : o} M ::= {m : . = .(x, . . . , x).e, . . . , m : . = .(x, . . . , \nx).e} e ::= c b | x | this | e.f | e.m(e, . . . , e) | new c(e, . . . , e) A program is a sequence of \nclass de.nitions C1; \u00b7\u00b7\u00b7 ; Cn with a main program e. Each class de.nition consists of super\u00adclass declarations, \n.eld declarations F and method declara\u00adtions M. A method body can use a special variable this which will \nbe bound to the receiver object. There are several potentially subtle issues in de.ning a type system \nfor this calculus regarding the interaction be\u00adtween multiple inheritance, method overriding and the \nthis variable. Although they are important in designing a sound type system for expressive object-oriented \nlanguage, they are internal in typing a method and do not a.ect typing issues in interfacing with another \nlanguage. For this rea\u00adson, we do not consider these issues and make the following simplifying assumptions. \n The relation induced by extends is acyclic.  The set of .elds of a class contains all the .elds de.ned \nin its superclasses.  Overriding .elds and methods have the same types.  No name con.ict occurs among \nsuperclasses.  The constructor takes the set of .eld values in a .xed order determined by some prede.ned \nordering on .eld names.  Under these assumptions, a set of class de.nition determines the following \nclass environment C. 1. The subclass relation Cf c<: c ' is determined by the following rules. Cf c<: \nc class c1 extends {\u00b7 \u00b7 \u00b7 c2 \u00b7\u00b7\u00b7}\u00b7\u00b7\u00b7 .C Cf c1 <: c2 Cf c1 <: c2 Cf c2 <: c3 Cf c1 <: c3 2. C(c).fields \nis the set of .elds declared for c. By the assumption, if Cf c1 <: c2 then C(c1).fields .C(c2).fields \n3. C(c).methods is the union of the sets of methods de\u00adclared for c ' such that Cf c<: c ' . By our assumption, \nif a method m is de.ned in both c and c ' then there types must be the same. 4. Cf new : o1 \u00d7\u00b7\u00b7\u00b7\u00d7 on \n. c . c where o1, \u00b7\u00b7\u00b7 ,on is the types of .elds in C(c).fields ordered by a prede.ned ordering on the \nlabels.  Based on these assumptions, we de.ne typing rules for expressions, method and each class de.nition \nrelative to a T . x : o if x : o .T T . c b : b T . e : c Cf f : o . c T . e.f : o T . e : c Cf m : o1 \n\u00d7\u00b7 \u00b7\u00b7\u00d7 on . o . c T . ei : oi T . e.m(e1,...,en): o C(c).fields = {f1 : o1,...,fn : on}T . ei : oi (1 \n= i = n) T . new c(e1,...,en): c T . e : c Cf c<: c ' T . e : c ' Figure 5: Expression typing in a sample \nobject\u00adoriented language given class environment C. We then de.ne a type-checking rule for a program. \nThe type system of expressions is given in Figure 5. Under a given class environment C, a method de.nition \nof the form m : o1 \u00d7\u00b7 \u00b7\u00b7\u00d7 on . o = .(x1,...,xn).e is type correct under C if {this : c, x1 : o1,...,xn \n: on} . e : o is derivable under C. A class de.nition of the form class c extends {c1,...,cn} = F with \nM is type correct if all the methods in M are type correct. We now de.ne the type-checking rule for programs. \nA program classdef C1; \u00b7\u00b7\u00b7 ; Cn in e is type correct if the following conditions are met. The set of \nclass de.nitions C1; \u00b7\u00b7\u00b7 ; Cn is well formed (i.e. it satis.es the set of assumptions stated earlier), \nyielding a class environment C. each class de.nition in Ci is type correct under C, and  e is type \ncorrect under C, i.e. \u00d8 . e : o is derivable for some o under C.  4.2 Operational semantics and type \nsoundness In order to model realistic interoperability, we de.ne an operational semantics of this language \nusing heaps (ranged over by h) and heap addresses (ranged over by p). Aheapis a mapping from a .nite \nset of heap address to heap values. Heaps, heap values (ranged over by vh) and runtime values (ranged \nover by v) are given as follows. h ::= {p . vh,...,p . vh} vh ::= c b |(f = v, . . . , f = v)c v ::= \nc b | p | wrong where (f = v, . . . , f = v)c is an object whose runtime type is c, and wrong denotes \nruntime error. We write h{p . v} d fo (h, x) . (h, d(x)) d fo (h, cb) . (h, cb) d fo (h, e) . (h ' ,p) \nh ' (p)= (...,f = v, . . .)c d fo (h, e.f ) . (h ' ,v) d fo (h, e) . (h1,p) h1(p)= (F )c Cf m : . = \n.(x1,...,xn).e0 . c d fo (hi,ei) . (hi+1,vi) (1 = i = n) d{this : p, x1 : v1,...,xn : vn}fo (hn+1,e0) \n. (h0,v) d fo (h, e.m(e1,...,en)) . (h0,v) d fo (hi-1,ei) . (hi,vi) (1 = i = n) C(c).fields = {f1 : \no1,...,fn : on} h ' n = hn{p .(f1 = v1,...,fn = vn)c} (p fresh) d fo (h0, new c(e1,...,en)) . (h ' ,p) \nn Figure 6: An operational semantics of the object\u00adoriented language for the extension of h with {p . \nv}. A similar notation is used for H. The operational semantics is de.ned as an evaluation re\u00adlation \nof the form d fo (h, e) . (h ' ,v) indicating the fact that expression e yields a value v and a new heap \nh ' when evaluated under environment d and heap h. The set of evaluation rules is given in Figure 6. \nThis set of rules is taken with the implicit rules saying that the evaluation yields wrong if the conditions \nspeci.ed in a rule are not met or evaluation of some of its subexpressions yields wrong. Runtime values \nmay form cycles and sharing through ob\u00adject pointers. To de.ne value typing without resorting to co-induction, \nwe follow [11] and de.ne types of values rela\u00adtive to a heap type (ranged over by H) specifying the struc\u00adture \nof a heap, which is a function from a .nite set of heap addresses to types. The following three relations \ndetermine value typing. |= o h : H (heap h satis.es heap type H.) if dom(H)= dom(h), and for each p . \ndom(h), one of the following holds: 1. h(p)= c b and H(p)= b, 2. H(p)= c, h(p)= (f1 = v1,...,fn = vn,...)cl \n, Cf c ' <: c, C(c).fields = {f1 : o1,...,fn : on}, and H |= o vi : oi (1 = i = n).  H |= o v : o (v \nhas type o under H) if either H |= o c b : b or H |= o p : c for some c such that Cf H(p) <: c.  H |= \no d : T (d is a model of T under H) if dom(d)= dom(T ), and for all x . dom(d) H |= o d(x): T (x).  \nA heap type H ' is an extension of H if dom(H ' ) . dom(H) and H ' (p)= H(p) for p . dom(H). The following \ntheorem shows soundness of the type system with respect to this se\u00admantics. Theorem 2. If T . e : o, \n|= o h : H, H |= o d : T then . (h '' if d fo (h, e) ,v) then there is an extension H of H h ' '' such \nthat |= o : H , H |= o v : o. Proof. The proof is by induction on the length of evaluation steps using \nthe following simple lemma. Lemma 1. 1. If H |= o v : o and H ' is an extension of H then H ' |= o v \n: o. 2. If H |= o v : o and Cf o<: o ' then H |= o v : o ' . The proof of the theorem proceeds by cases \nin term of the rule used in the last evaluation step. Case e = e1.f. By the evaluation rule, d fo (h, \ne1) . (h ' ' ,v0) for some v0. By the typing rule, there are some c, o such that T . e1 : c, Cf f : o \n' . c and Cf f : o ' <: o. By the induction hypothesis, there is some extension H ' of H such that |= \no h ' : H ' and H ' |= o v0 : c. By the de.nition of runtime typing, v0 = p such that Cf H ' (p) <: c. \nSince Cf f : o ' . c and the property of |= o h ' : H ' , h ' (p) must be an object containing f = v \nsuch that H ' |= o v : o ' . Then by lemma we have H ' |= o v : o as desired. Case e = new c(e1,...,en). \nBy the typing rule, C(c).fields = {f1 : o1,...,fn : on} for some types o1,...,on. By the evaluation rule, \nd fo (h, ei) . (hi,vi) for some vi (1 = i = n). By induction hypothesis and Lemma 1, there are H . H1 \n. \u00b7\u00b7\u00b7 . Hn such that |= o hi : Hi, Hi |= o vi : oi. Let h ' n = hn{p .(f1 = v1,...,fn = vn)c} (p fresh). \nWe can then take H ' = Hn{p . c}, for which |= o h ' : H ' and H ' |= o p : c by the de.nition of value \nand heap typing. Since Cf c<: o, by lemma H ' |= o p : o as desired. The cases for variables and constants \nare trivial. The case for method invocation can be shown by combining the techniques of the above two \ncases. . We de.ne value typing and heap typing as follows. h |= o v : o (v has type o under h) if there \nis some H such that |= o h : H and H |= o v : o.  h |= o d : T (d satis.es T under h) if there is some \nH such that |= o h : H and H |= o d : T .  Then the above theorem yields the following. Corollary 1. \nIf T . e : o and h |= o d : T then if d fo (h, e) . (h ' ,v) then h ' |= o v : o.  5. SEMANTICS AND \nTYPE SOUNDNESS OF THE INTEROPERABLE CALCULUS We now give a formal operational semantics of our interop\u00aderable \ncalculus with the sample object-oriented language as the target language for interoperability, and establish \ntype soundness of the calculus. 5.1 Operational semantics We write (X) to emphasize that X is an entity \nin the object-oriented language. The set of runtime values (ranged over by V ) is given by the following \nsyntax. V ::= c b |(p)| cls(., .x.M ) We assume that constants (c b) of base types are implicitly marshaled. \n(p) is a heap address in the external object\u00adoriented language. cls(., .x.M) represents a function clo\u00adsure. \n. is a runtime environment, which is a mapping from a .nite set of variables to runtime values. The operational \nsemantics is de.ned by specifying the set of evaluation rules of the form: . f. ((h),M) . ((h ' ),V ) \nindicating the fact that under environment . and exter\u00adnal heap (h), expression M evaluates to value \nV yielding a modi.ed heap (h ' ). The set of rules is given in Figure 7.  5.2 Value typing and type \nsoundness Typing of values and runtime environments are given as follows. H |= p c b : b  H |= p (p) \n: o if H |= o p : o  H |= p cls(., .x.M ): t1 . t2 if there is some T such that H |= p .: T and T . \n.x.M : t1 . t2.  H |= p V : s if H |= p V : t for any kind-respecting instance t of s.  H |= p .: T \nif dom(.) = dom(T ) and for all x . dom(.), H |= p .(x): T (x).  These are relative to a given class \nenvironment C. We can now show the following type soundness theorem. Theorem 3. If K, T .M : t , S is \na K-respecting ground substitution, |= o h : H, H |= p .: S(T ) and . f. ((h),M) . ((h ' ),V ) then there \nis some extension H ' of H such that |= o h ' : H ' and H ' |= p V : S(t). Proof. The proof is by induction \non the length of evaluation steps using Theorem 1. Proof proceeds by cases in terms of the rule used \nin the last evaluation step. We only show the case for external method invocation. The other cases are \nsimpler. Case M = M0.m(M1,...,Mn). Suppose K, T . M0.m(M1,...,Mn): t. Then \u00d8,S(T ) . M0.m(M1,...,Mn): \nS(t). By the typing rule, \u00d8,S(T ) . M0 : t0 such that \u00d8f t0 :: { m : o1 \u00d7\u00b7 \u00b7\u00b7\u00d7 on . o} , and \u00d8,S(T ) \n. Mi : oi. t0 is a ground type containing a .eld m : o1 \u00d7\u00b7 \u00b7 \u00b7 on . o. By the de.nition of the type system, \nthe only possible t0 satisfying this condition is some c such that Cf c = t . By the evaluation relation, \n. f. ((h),M0) . ((h1),V0). By induction hypothesis, there is some H0 . H such that |= o h ' : H0, and \nH0 |= p V0 : c. By the de.nition of value typings, V0 = p0 for some p0 such that H ' |= o po : c. By \nevaluation relation and induction hypothesis, we can show that there are some Hi(1 = i = n) such that \nH0 . H1 . \u00b7\u00b7\u00b7 . Hn, |= o hi : Hi, and Hi |= p Vi : oi. By the de.nition of value typing, either Vi = \nc b and o = b, or Vi = (p), oi = ci, and Hi |= o pi : ci. Let vi = pi if Vi = pi otherwise vi = Vi. Then \nHn+1 |= o {x : p, x1 : v1,...,xn : vn} : {x : o, x1 : o1,...,xn : on}. By the encoding of c in the record \ncalculus, we must have Cf m : o1 \u00d7\u00b7\u00b7\u00b7\u00d7 on . o . c, and therefore {x : o, x1 : o1,...,xn : on}.x.m(x1,...,xn): \n o. By evaluation relation, {x : p, x1 : p1,...,xn : pn}fo (hn, x.m(x1, \u00b7\u00b7\u00b7 ,xn)) . (hn+1,p). By Theorem \n1, there is some extension Hn+1 of Hn such that |= o hn+1 : Hn+1 and Hn+1 |= v : o. Then either v = c \nb = V and o = b or v = p, V = (p) and o = c. In either case, we can take Hn+1 as the  . f. ((h),x) \n. ((h), .(x)) . f. ((h),c b) . ((h),c b). f. ((h), .x.M) . ((h), cls(., .x.M)) ' . f. ((h),M) . ((h1), \n(p)) . f. ((h),M1) . ((h1), cls(. ' , .x.M 1)) . f. ((hi-1),Mi) . ((hi), (pi)) (1 = i = n). f. ((h1),M2) \n. ((h2),V2) ' C(c).fields = {f1 : o1,...,fn : on} . ' {x : v2}f. ((h2),M 1) . ((h3),V ) (h0) = (hn{p \n: (f1 : p1,...,fn : pn)c}) (p fresh). f. ((h),M1 M2) . ((h3),V ) . f. ((h), new c(M1, \u00b7\u00b7\u00b7 ,Mn)) . ((h0), \n(p)) . f. ((h),M0) . ((h0), (p0)) . f. ((hi-1),Mi) . ((hi),Vi) (1 = i = n), Vi = (pi) or Vi = c b . f. \n((h),M) . ((h1), (p)) let vi = pi if Vi = pi otherwise vi = Vi ({x : p}fo (h1, x.l) . (h2,p)) ({x : p0,x1 \n: v1,...,xn : vn}fo (hn, x.m(x1, \u00b7\u00b7\u00b7 ,xn)) . (hn+1,p)) . f. ((h), M.l) . ((h2), (p)) . f. ((h),M0.m(M1, \n\u00b7\u00b7\u00b7 ,Mn)) . ((hn+1),V ) Figure 7: Operational semantics ' '' necessary H for which we have |= p h ' \n: H and H |= p V : o, as desired. . Similarly as before, we de.ne the following value typing. h |= p \nV : t (v has type t under h) if there is some H such that |= o h : H and H |= p V : t .  h |= p .: T \n(. satis.es T under h) if there is some H such that |= o h : H and H |= p .: T .  We then have the following \ndesired result. Corollary 2. If K, T . M : t , S is a K-respecting ground substitution, h |= p .: S(T \n) and . f. ((h),M ) . ((h ' ),V ) then h ' |= p V : S(t).  6. EXTENSIONS AND IMPLEMENTATION This work \nis part of our ongoing project of developing an Interoperable ML. The aim of the project is to design \nand develop a polymorphic language that is interoperable with other programming models, including object-oriented \nlanguages and database systems. As a step toward such an interoperable language, we have implemented \nan experimen\u00adtal prototype system1 embodying the interoperable calculus we have presented in this paper. \nIn design and development of the prototype system, we have considered several issues other than those \npresented in this paper, and have implemented some of them. An impor\u00adtant one of them is the development \nof a uniform mechanism for interfacing with external languages of various di.erent programming models. \nIn this paper, we have so far consid\u00adered interoperability with a single object-oriented language. Foreign \nfunction interfaces of most existing functional lan\u00adguages also usually presuppose single external model, \nespe\u00adcially that of C language [1, 6]. In practice, however, it is desirable and sometimes essential \nto be able to manipulate objects of various di.erent models, such as Java, CORBA, COM and .NET, simultaneously. \n1The current experimental prototype system, which we tentatively called Amethyst, is available at http://pllab.jaist.ac.jp:8080/amethyst/index.html. \nThe interested reader may copy and try the system. Note, however, that this is a prototype made available \nfor evalua\u00adtion, and not intended for general release. We are planning to develop Interoperable ML a \npractical polymorphic interoperable language. To handle objects in various models, it is necessary to \nhave some language constructs for distinguishing name spaces and for specifying required access protocols. \nTo achieve this in a modular and uniform way, we have introduced in our implementation a notion of a \ndomain representing a par\u00adticular object model, and let object types of some object model belong to the \ndomain corresponding to the model. The usual built-in records can be treated as object types belonging \nto a special built-in domain. Our implementa\u00adtion extends the core of Standard ML (i.e. those except \nfor the module system) with a mechanism for domains. Its runtime system consists of a bytecode executor \nand plug-in modules, each of which realizes a particular domain. Cur\u00adrent prototype includes a module \nfor accessing Java class libraries and one for accessing PostgreSQL database server. The module for Java \ndomain is implemented using Java Na\u00adtive Language Interface (JNI). The bytecode compiler of the main \nlanguage together with the Java module realizes the interoperable calculus presented in this paper. The \nactual implementation di.ers from the formal presen\u00adtation in that it does not implement subsumption \non object types. The rationale of this deviation is due to our con\u00adsideration of the relationship between \nexternal objects and internal records. Since they are similar in their properties and usage, the programmer \nmay often want to treat them uniformly. Based on this observation, we make the elimi\u00adnation operations \nof records (.eld selection primitives and polymorphic record pattern matching) applicable also to ex\u00adternal \nobjects. The lack of object subsumption is the price of this uniform treatment. We could of course implement \nexternal objects as those independent of records by intro\u00adducing two sets of elimination operations. \nWe are currently investigating a typing mechanism that allows both object subsumption and uniform treatment \nof records and objects. Let us show some examples in our prototype system be\u00adlow. First, types and functions \nnecessary for manipulating Java objects are declared through domain statement as fol\u00adlows. domain Java \n= imports \"init\" of \"jnilib\"; external type t JObject = JObject of t imports \"JObject\" of Java; fun ObjOf \n(JObject obj) = obj; In the .rst line, Java domain which is implemented in a mod\u00adule speci.ed by \"jnilib\" \nis declared, and \"init\" speci.es the entry point of the module. external type statement de\u00adclares types \nrepresenting external data structures, and has the property similar to datatype declaration in Standard \nML. Type JObject wraps external Java classes, and plays a role as a marker to distinguish them from object \ntypes of other domains. A type parameter of JObject is the repre\u00adsentation of the class structure. The \nfunction de.ned in the bottom line extracts the wrapped object. This extra layer of type de.nition is \nnecessary to deal with multiple domains. If the only possible target language is Java, then we could \nhave used the same type encoding as in our formal development. Using these declarations, we show examples \nof using Java classes. Suppose we have the following Java class. public class C{ public String Name; \nprivate int Age; public C(String Name,int Age){ this.Name = Name; this.Age = Age; } public int getAge(){ \nreturn this.Age; } } Class C is imported as follows. external type C = {Name:string \"field:Name:Ljava/lang/String;\", \ngetAge:unit->int \"method:C:getAge:()I\", java lang Object:unit \"class\", C:unit \"class\"} imports \"C\" of \nJava; external fun C : string -> int -> C JObject = imports \"new:C:(Ljava/lang/String;I)V\" of Java; C \nis an object type representing Java class C containing four members. Name corresponds to the Name .eld \nof class C. The string literal \"field:Name:Ljava/lang/String;\" is used by Java domain to identify the \ncorrespondence between mem\u00adbers of external type and those of Java class. The second member getAge corresponds \nto getAge method of class C. The third and fourth members specify the ancestor classes of C, i.e. java.lang.Object \nand C itself. A constructor of class C is declared here as an external function by an external fun statement. \nThese declarations allows us to manipulate Java objects safely within the polymorphic type system. Moreover, \nwe can treat those Java objects in the same way as built-in records of ML as seen in the following. fun \ngetName x = #Name x; getName {Name=\"Murata\"}; getName (ObjOf(C \"Togo\" 58)); Through this feature, we \ncan enjoy the bene.ts of both ML\u00adstyle polymorphism and object-oriented programming. For example, we \ncan manipulate Java objects using ML-style higher-order functions as seen below. val s = C \"Saigo\" 78; \nval t = C \"Togo\" 58; map (getName o ObjOf) [s,t]; The resulting system is to some extent more .exible \nthan the original Java type system in manipulating Java objects due to ML s polymorphic functions with \nrecord polymorphism. For example, suppose we have another class de.nition of the form class D{ public \nString Name; } Since D and C has no common superclass having Name .eld, it is impossible in Java type \nsystem to de.ne a function (method) for extracting Name attribute that is applicable to both C and D \nobjects. By contrast, in our system the above getName can be applied to C and D objects. getName (ObjOf(C \n\"Togo\" 58)); getName (ObjOf(D \"Yamamoto\" 21)); In this way, we can de.ne various useful polymorphic func\u00adtions \nmanipulating Java objects by exploiting parametric polymorphism extended to Java objects. 7. CONCLUSIONS \nWe have de.ned a polymorphic calculus that is capable of interfacing with an object-oriented language, \nand have de\u00adveloped an ML-style type inference algorithm. The calculus enjoys the features of higher-order \nprogramming with ML\u00adstyle polymorphism and class-based object-oriented program\u00adming with dynamic method \ndispatch. Method invocation is type checked in the polymorphic type system of the calcu\u00adlus. Its operational \nsemantics is to call an external object\u00adoriented language for dynamic method invocation. We have shown \nthat the type system is sound with respect to an operational semantics which faithfully models linking \nto an external object-oriented language. These results have been implemented in our prototype interoperable \nlanguage, which can access Java class .les and other external resources. This is our .rst step toward \ndeveloping a statically typed interoperable languages, and there are a number of issues to be investigated. \nWe only mention two of them below. 1. Accessing functions from an object-oriented language. We have only \nconsidered the problem of accessing ex\u00adternal classes from a polymorphic higher-order lan\u00adguage. We would \nalso like to develop a mechanism for accessing functions in a polymorphic language from an object-oriented \nlanguage. It should not be so hard to access .rst-order functions from an object-oriented language as \na native static method. More challeng\u00ading issues is to combine and use foreign higher-order functions \ndirectly in an object-oriented language. 2. Memory management in interoperable languages. In our formalism \nand in our implementation, values in the polymorphic calculus may contain pointers to the heap of the \nexternal object-oriented language, but not vise versa. Due to this simple structure, garbage collection \nin the object calculus can be done by includ\u00ading the set of exported pointers in the root set. How\u00adever, \nif we extend the formalism to allow bi-directional interoperability as discussed above, then the heaps \n of participating languages may contain global cycles, and garbage collection could be a serious problem. \nGarbage collection method in distributed computing may give us some hint. We are now investigating these \nand other issues using our experimental prototype system. Acknowledgments We would like to thank anonymous \nreviewers for their help\u00adful comments, which have been very useful for improving the presentation of \nthis paper. 8. REFERENCES [1] M. Blume. No-longer-foreign: Teaching an ML compiler to speak C natively \n. In N. Benton and  A. Kennedy, editors, Electronic Notes in Theoretical Computer Science, volume 59. \nElsevier Science Publishers, 2001.  [2] L. Cardelli. A semantics of multiple inheritance. In Semantics \nof Data Types, Lecture Notes in Computer Science 173. Springer-Verlag, 1984. [3] L. Cardelli and P. Wegner. \nOn understanding types, data abstraction, and polymorphism. Computing Surveys, 17(4):471 522, Dec. 1985. \n[4] M. Corporation and D. Corporation. The component object model speci.cation, 1995. [5] S. Finne, D. \nLeijen, E. Meijer, and S. L. P. Jones. Calling hell from heaven and heaven from hell. In International \nConference on Functional Programming, pages 114 125, 1999. [6] S. Finne, D. Leijen, E. Meijer, and S. \nP. Jones. H/Direct: A binary foreign language interface for Haskell. In Proceedings of the ACM SIGPLAN \nInternational Conference on Functional Programming (ICFP 98), volume 34(1) of ACM SIGPLAN Notices, pages \n153 162. ACM, June 1999. [7] K. Fisher and J. H. Reppy. The design of a class mechanism for Moby. In \nSIGPLAN Conference on Programming Language Design and Implementation (PDLI), pages 37 49, 1999. [8] \nY.-C. Fuh and P. Mishra. Type inference with subtypes. In Proceedings of ESOP 88, pages 94 114, 1988. \nSpringer LNCS 300. [9] C. Gunter and J. Mitchell, editors. Theoretical Aspects of Object-Oriented Programming. \nMIT Press, 1994. [10] C. V. Hall, K. Hammond, S. L. Peyton Jones, and P. L. Wadler. Type classes in Haskell. \nACM Transactions on Programming Languages and Systems, 18(2):109 138, Mar. 1996. [11] X. Leroy. Polymorphic \ntyping of an algorithmic language. PhD thesis, University of Paris VII, 1992. [12] X. Leroy. The Objective \nCaml system: Documentation and user s manual, 2000. (with Damien Doligez, Jacques Garrigue, Didier R\u00b4emy, \nand J\u00b4er ome Vouillon Available from http://caml.inria.fr.) [13] T. Lindholm and F. Yellin. The Java \nvirtual machine speci.cation. Addison Wesley, second edition edition, 1999. [14] E. Meijer and K. Claessen. \nThe design and implementation of Mondrian. In Haskell Workshop. ACM, June 1997. [15] E. Meijer and S. \nFinne. Lambada, Haskell as a better java. In G. Hutton, editor, Electronic Notes in Theoretical Computer \nScience, volume 41. Elsevier Science Publishers, 2001. [16] J. Mitchell. Type inference and type containment. \nIn Semantics of Data Types, Lecture Notes in Computer Science 173, pages 257 277. Springer-Verlag, 1984. \n[17] J. Nordlander. Pragmatic subtyping in polymorphic languages. In International Conference on Functional \nProgramming (ICFP), 1998. [18] A. Ohori. A polymorphic record calculus and its compilation. ACM Transactions \non Programming Languages and Systems, 17(6):844 895, 1995. A preliminary summary appeared at ACM POPL, \n1992 under the title A compilation method for ML-style polymorphic record calculi . [19] D. Remy. Typechecking \nrecords and variants in a natural extension of ML. In Proc. ACM Symposium on Principles of Programming \nLanguages, pages 242 249, 1989. [20] D. R\u00b4emy and J. Vouillon. Objective ML: An e.ective object-oriented \nextension to ML. Theory And Practice of Object Systems, 4(1):27 50, 1998. Summary in Proc. ACM POPL Symposium, \n1997. [21] R. Stansifer. Type inference with subtypes. In Proc. ACM Symposium on Principles of Programming \nLanguages, pages 88 97, 1988.   \n\t\t\t", "proc_id": "581478", "abstract": "By extending an ML-style type system with record polymorphism, recursive type definition, and an ordering relation induced by field inclusion, it is possible to achieve seamless and type safe interoperability with an object-oriented language. Based on this observation, we define a polymorphic language that can directly access external objects and methods, and develop a type inference algorithm. This calculus enjoys the features of both higher-order programming with ML polymorphism and class-based object-oriented programming with dynamic method dispatch. To establish type safety, we define a sample object-oriented language with multiple inheritance as the target for interoperability, define an operational semantics of the calculus, and show that the type system is sound with respect to the operational semantics. These results have been implemented in our prototype interpretable language, which can access Java class files and other external resources.", "authors": [{"name": "Atsushi Ohori", "author_profile_id": "81100168829", "affiliation": "JAIST (Japan Advanced Institute of Science and Technology, Ishikawa, Japan", "person_id": "PP39030730", "email_address": "", "orcid_id": ""}, {"name": "Kiyoshi Yamatodani", "author_profile_id": "81100491309", "affiliation": "JAIST (Japan Advanced Institute of Science and Technology, Ishikawa, Japan", "person_id": "P394769", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/581478.581485", "year": "2002", "article_id": "581485", "conference": "ICFP", "title": "An interoperable calculus for external object access", "url": "http://dl.acm.org/citation.cfm?id=581485"}