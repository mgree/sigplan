{"article_publication_date": "09-17-2002", "fulltext": "\n Tagless Staged Interpreters for Typed Languages Emir Pa.sali\u00b4c * Walid Taha Tim Sheard OGI School \nof Science &#38; Engineering Computer Science Department OGI School of Science &#38; Engineering Oregon \nHealth &#38; Science University Rice University Oregon Health &#38; Science University pasalic@cse.ogi.edu \ntaha@cs.rice.edu sheard@cse.ogi.edu Abstract Multi-stage programming languages provide a convenient \nnota\u00adtion for explicitly staging programs. Staging a de.nitional inter\u00adpreter for a domain speci.c language \nis one way of deriving an implementation that is both readable and ef.cient. In an untyped setting, staging \nan interpreter removes a complete layer of inter\u00adpretive overhead , just like partial evaluation. In \na typed setting however, Hindley-Milner type systems do not allow us to exploit typing information in \nthe language being interpreted. In practice, this can mean a slowdown cost by a factor of three or more. \nPreviously, both type specialization and tag elimination were ap\u00adplied to this problem. In this paper \nwe propose an alternative ap\u00adproach, namely, expressing the de.nitional interpreter in a depen\u00addently \ntyped programming language. We report on our experience with the issues that arise in writing such an \ninterpreter and in de\u00adsigning such a language. To demonstrate the soundness of combining staging and \ndepen\u00addent types in a general sense, we formalize our language (called Meta-D) and prove its type safety. \nTo formalize Meta-D, we extend Shao, Saha, Trifonov and Papaspyrou s .H language to a multi\u00adlevel setting. \nBuilding on .H allows us to demonstrate type safety in a setting where the type language contains all \nthe calculus of in\u00adductive constructions, but without having to repeat the work needed for establishing \nthe soundness of that system. Categories and Subject Descriptors D.3 [Software]: Programming Languages \nGeneral Terms Languages, Performance  Keywords Multi-stage programming, de.nitional interpreters, calculus \nof constructions, domain-speci.c languages. *Supported by NSF CCR-0098126. Supported by NSF ITR-0113569. \nThis work was done while the authors was at Yale University. Supported by NSF CCR-0098126. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 02, October \n4-6, 2002, Pittsburgh, Pennsylvania, USA. Copyright 2002 ACM 1-58113-487-8/02/0010 ...$5.00 1 Introduction \nIn recent years, substantial effort has been invested in the devel\u00adopment of both the theory and tools \nfor the rapid implementation of domain speci.c languages (DSLs) [4, 22, 40, 47, 45, 23]. DSLs are formalisms \nthat provide their users with a notation appropri\u00adate for a speci.c family of tasks. A promising approach \nto imple\u00admenting domain speci.c languages is to write a de.nitional inter\u00adpreter [42] for the DSL in \nsome meta-language, and then to stage this interpreter either manually, by adding explicit staging annota\u00adtions \n(multi-stage programming [55, 30, 45, 50]), or by applying an automatic binding-time analysis (off-line \npartial evaluation [25]). The result of either of these steps is a staged interpreter. A staged interpreter \nis essentially a translation from a subject-language (the DSL) to a target-language1. If there is already \na compiler for the target-language, the approach yields a simple compiler for the DSL. In addition to \nthe performance bene.t of a compiler over an inter\u00adpreter, the compiler obtained by this process often \nretains a close syntactic connection with the original interpreter, inspiring greater con.dence in its \ncorrectness. This paper is concerned with a subtle but costly problem which can arise when both the subject-and \nthe meta-language are stati\u00adcally typed. In particular, when the meta-language is typed, there is generally \na need to introduce a universal datatype to represent values uniformly (see [48] for a detailed discussion). \nHaving such a universal datatype means that we have to perform tagging and untagging operations at run \ntime. When the subject-language is un\u00adtyped, as it would be when writing an ML interpreter for Scheme, \nthe checks are really necessary. But when the subject-language is also statically typed, as it would \nbe when writing an ML interpreter for ML, the extra tags are not really needed. They are only neces\u00adsary \nto statically type check the interpreter. When this interpreter is staged, it inherits [29] this weakness, \nand generates programs that contain super.uous tagging and untagging operations. Early esti\u00admates of \nthe cost of tags suggested that it produces up to a 2.6 times slowdown in the SML/NJ system [54]. More \nextensive studies in the MetaOCaml system show that slowdown due to tags can be as high as 10 times [21]. \nHow can we remove the tagging overhead inherent in the use of universal types? One recently proposed \npossibility is tag elimination [54, 53, 26], a transformation that was designed to remove the super.uous \ntags in a post-processing phase. Under this scheme, DSL implemen\u00adtation is divided into three distinct \nstages (rather than the tradi\u00adtional two). The extra stage, tag elimination, is distinctly different \nfrom the traditional partial evaluation (or specialization) stage. In essence, tag elimination allows \nus to type check the subject pro\u00ad 1Explicit staging in a multi-stage language usually implies that the \nmeta-language and the target-language are the same language. gram after it has been transformed. If it \nchecks, super.uous tags are simply erased from the interpretation. If not, a semantically equivalent \ninterface is added around the interpretation. Tag elim\u00adination, however, does not statically guarantee \nthat all tags will be erased. We must run the tag elimination at runtime (in a multi-stage language). \nIn this paper, we study an alternative approach that does provide such a guarantee. In fact, the user \nnever introduces these tags in the .rst place, because the type system of the meta-language is strong \nenough to avoid any need for them. In what follows we describe the details of super.uous tags prob\u00adlem. \n1.1 Untyped Interpreters We begin by reviewing how one writes a simple interpreter in an untyped language.2 \nFor notational parsimony, we will use ML syn\u00adtax but disregard types. An interpreter for a small lambda \nlanguage can be de.ned as follows: datatype exp = B of int | V of string | L of string * exp | A of exp \n* exp fun eval e env = case e of Bi =>i |Vs =>envs | L (s,e) => fn v => eval e (ext env s v) | \nA (f,e) => (eval f env) (eval e env) This provides a simple implementation of subject programs rep\u00adresented \nin the datatype exp. The function eval evaluates exps in an environment env that binds the free variables \nin the term to values. This implementation suffers from a severe performance limita\u00adtion. In particular, \nif we were able to inspect the result of a an interpretation, such as (eval (L(\"x\",V \"x\")) env0), we \nwould .nd that it is equivalent to (fn v => eval (V \"x\") (ext env0 \"x\" v)). This term will compute the \ncorrect result, but it contains an unex\u00adpanded recursive call to eval. This problem arises in both call-by\u00advalue \nand call-by-name languages, and is one of the main reasons for what is called the layer of interpretive \noverhead that degrades performance. Fortunately, this problem can be eliminated through the use of staging \nannotations [48].  1.2 Untyped Staged Interpreters Staging annotations partition the program into stages. \nBrackets .<_>. surrounding an expression lift it to the next stage (building code). Escape . _ drops \nits surrounded expression to a previous stage (splicing in already constructed code to build larger pieces \nof code), and should only appear within brackets. Staging anno\u00adtations change the evaluation order of \nprograms, even evaluating under lambda abstraction, and force the unfolding of the evalfunc\u00adtion at code-generation \ntime. Thus, by just adding staging annota\u00adtions to the eval function, we can change its behavior to achieve \nthe desired operational semantics: fun eval e env = (case e of B i => .<i>. |Vs =>envs 2Discussing the \nissue of how to prove the adequacy of represen\u00adtations or correctness of implementations of interpreters \nis beyond the scope of this paper. Examples of how this can done can be found elsewhere [54]. | L (s,e) \n=> .<fn v => . (eval e (ext env s .<v>.))>. | A (f,e) => .<. (eval f env) . (eval e env))>. Computing \nthe application eval (L(\"x\",V \"x\")) env0directly yields a term .<fn v => v>. Now there are no leftover \nrecursive calls to eval. Multi-stage languages come with a run annotation .!_ that allows us to execute \nsuch a code fragment. A staged interpreter can therefore be viewed as user-directed way of re.ecting \na subject program into a meta\u00adprogram, which then can be handed over in a type safe way to the compiler \nof the meta-language.  1.3 Hindley-Milner Staged Interpreters In programming languages, such as Haskell \nor ML, which use a Hindley-Milner type system, the above eval function (staged or unstaged) is not well-typed \n[48]. Each branch of the case statement has a different type, and these types cannot be reconciled. Within \na Hindley-Milner system, we can circumvent this prob\u00adlem by using a universal type. A universal type \nis a type that is rich enough to encode values of all the types that appear in the result of a function \nlike eval. In the case above, this includes function as well as integer values. A typical de.nition of \na universal type for this example might be: datatype V = I of int | F of V -> V The interpreter can then \nbe rewritten as a well-typed program: fun unF (F v) = v fun eval e env = (case e of Bi =>Ii |Vs =>envs \n | L (s,e) => F (fn v => eval e (ext env s v)) | A (f,e) => (unF (eval f env)) (eval e env)); Now, when \nwe compute (eval (L(\"x\",V \"x\")) env0) we get back a value (F (fn v => eval (V \"x\") (ext env0 \"x\" v))). \nJust as we did for the untyped eval, we can stage this version of eval. Now computing (eval (L(\"x\",V \n\"x\")) env0) yields: .<(F (fn v => v))>. 1.4 Problem: Super.uous Tags Unfortunately, the result above \nstill contains the tag F. While this may seem like minor issue in a small program like this one, the \nef\u00adfect in a larger program will be a profusion of tagging and untagging operations. Such tags would \nindeed be necessary if the subject\u00adlanguage was untyped. But if we know that the subject-language is \nstatically typed (for example, as a simply-typed lambda calcu\u00adlus) the tagging and untagging operations \nare really not needed. Benchmarks indicate that these tags add a 2-3 time overhead [54], sometimes as \nlarge as 3-10 times [21]. There are a number of approaches for dealing with this prob\u00adlem. None of these \napproaches, however, guarantee (at the time of writing the staged interpreter) that the tags will be \neliminated be\u00adfore runtime. Even tag elimination, which guarantees the elimina\u00adtion of tags for these \nparticular examples, requires a separate meta\u00adtheoretic proof for each subject language to obtain such \na guarantee [54]. 1.5 Contributions In this paper we propose an alternative solution to the super.u\u00adous \ntags problem. Our solution is based on the use of a dependently typed multi-stage language. This work \nwas inspired by work on writing dependently typed interpreters in Cayenne [2]. To illustrate viability \nof combining dependent types with staging, we have de\u00adsigned and implemented a prototype language we \ncall Meta-D. We use this language as a vehicle to investigate the issues that arise when taking this \napproach. We built a compiler from an interpreter, from beginning to end in Meta-D. We also report on \nthe issues that arise in trying to develop a dependently typed programming lan\u00adguage (as opposed to a \ntype theory). Meta-D features Basic staging operators  Dependent types (with help for avoiding redundant \ntyping an\u00adnotations)  Dependently typed inductive families (dependent datatypes)  Separation between \nvalues and types (ensuring decidable type checking)  A treatment of equality and representation types \nusing an  equality-type-like mechanism The technical contribution of this paper is in formalizing a \nmulti\u00adstage language, and proving its safety under a sophisticated depen\u00addent type system. We do this \nby capitalizing on the recent work by Shao, Saha, Trifonov and Papaspyrou s on the TL system [44], which \nin turn builds on a number of recent works on typed interme\u00addiate languages [20, 7, 59, 43, 9, 57]. \n1.6 Organization of this Paper Section 2 shows how to take our motivating example and turn it into a \ntagless staged interpreter in a dependently typed setting. First, we present the syntax and semantics \nof a simple typed language and show how these can be implemented in a direct fashion in Meta-D. The .rst \npart of this (writing the unstaged interpreter) is similar to what has been done in Cayenne [2], but \nis simpli.ed by the presence of dependent datatypes in Meta-D (see Related Work). The key ob\u00adservation \nhere is that the interpreter needs to be de.ned over typing derivations rather than expressions. Dependently \ntyped datatypes are needed to represent such typing derivations accurately. Next, we show how this interpreter \ncan be easily staged. This step is ex\u00adactly the same as in the untyped and in the Hindley-Milner setting. \nIn Section 3 we point out and address some basic practical prob\u00adlems that arise in the implementation \nof interpreters in a depen\u00addently typed programming language. First, we show how to con\u00adstruct the typing \njudgments that are consumed by the tagless inter\u00adpreter. Then, we review why it is important to have \na clear sepa\u00adration between the computational language and the type language. This motivates the need \nfor representation types, and has an effect on the code for the tagless staged interpreter. Section 4 \npresents a formalization of a core subset of Meta-D, and a formal proof of its type safety. The original \nwork on TL used this system to type a computational language that includes basic effects, such as non-termination \n[44]. In this paper, we develop a multi-stage computational language, and show how essentially the same \ntechniques can be used to verify its soundness. The key technical modi.cations needed are the addition \nof levels to typing judgments, and addressing evaluation under type binders. Section 5 discusses related \nwork, and Section 6 outlines direc\u00adtions for future work and concludes. An extended version of the paper \nis available on-line as a techni\u00adcal report [36].  2 A Tagless Staged Interpreter In this section we \nshow how the example discussed in the in\u00adtroduction can be redeveloped in a dependently typed setting. \nWe begin by considering a de.nition of the syntax and semantics (of a simply typed version) of the subject \nlanguage. 2.1 Subject-Language Syntax and Semantics Figure 1 de.nes the syntax, type system, and semantics \nof an example subject language we shall call SL. For simplicity of the development, we use de Bruijn \nindices for variables and binders. The semantics de.nes how the types of SL are mapped to their in\u00adtended \nmeaning. For example, the meaning of the type N is the set of natural numbers, while the meaning of the \narrow type t1 . t2 is the function space [[t2]][[t1]] . Furthermore, we map the meaning of type assignments \nG, into a product of the sets denoting the .nite number of types in the assignment. Note that the semantics \nof pro\u00adgramsisde.ned on typing judgments, and maps to elements of the meanings of their types. This is \nthe standard way of de.ning the semantics of typed languages [56, 18, 39], and the implementation in \nthe next section will be a direct codi.cation of this de.nition.  2.2 Interpreters in Meta-D An interpreter \nfor SL can be simply an implementation of the de.nition in Figure 1. We begin by de.ning the datatypes \nthat will be used to interpret the basic types (and typing environments) of SL. To de.ne datatypes Meta-D \nuses an alternative notation to SML or Haskell datatype de.nitions. For example, to de.ne the set of \nnatural numbers, instead of writing datatype Nat = Z|Sof Nat we write inductiveNat:*1 =Z :Nat|S:Nat->Nat \n The inductive notation is more convenient when we are de.ning dependent datatypes and when we wish to \nde.ne not only new types but new kinds (meaning types of types ). Now type expression and type assignments \nare represented as follows: inductive Typ : *1 = NatT : Typ | ArrowT : Typ -> Typ -> Typ inductive Exp \n: *1 = EI : Nat -> Exp | EV : Nat -> Exp | EL : Typ -> Exp -> Exp | EA : Exp -> Exp -> Exp inductive \nEnv : *1 = EmptyE : Env | ExtE : Env -> Typ -> Env The *1 in these de.nitions means that we are de.ning \na new type. To implement the type judgment of SL we need a dependently typed datatype indexed by three \nparameters: a type assignment Env,an expression Exp, and a type Typ. We can de.ne such a datatype as \nshowninFigure 2.3 Each constructor in this datatype corresponds to one of the rules in the type system \nfor our object language. For example, consider the rule for lambda abstraction (Lam) from Fig\u00adure 1. \nThe basic idea is to use the judgments as types principle [19], and so we can view the type rule as a \nconstant combinator on judgments. This combinator takes hypothesis judgments (and their free variables) \nand returns the conclusion judgment. In this case the rule requires an environment G, two types t and \nt', a body e of the lambda abstraction, a judgment that G,t f e : t', and returns a judg\u00adment G f .t.e \n: t . t'. This rule is codi.ed directly by the following constructor JL : (e1 : Env) -> (t1 : Typ) -> \n(t2 : Typ) -> (s2 : Exp) -> J(ExtE e1 t1, s2, t2) -> J(e1, EL t1 s2, ArrowT t1 t2). In the de.nition \nof J we see differences between the traditional datatype de.nitions and inductive datatypes: each of \nthe construc\u00adtors can have dependently typed arguments and a range type J in\u00addexed by different indices. \nIt is through this variability in the return 3For practical reasons that we will discuss in the next \nsection, this datatype is not legal in Meta-D. We will use it in this section to explain the basic ideas \nbefore we discuss the need for so-called representation types. t . T1 = N | t . t [[N]] = N G . G1 = \n() | G,t [[t1 . t2]] = [[t2]][[t1]] e . E1 = n | .t.e | ee | #n [[()]] = 1 [[G,t]] =[[G]] \u00d7 [[t]] (Nat) \n(Var) G f n : N G,t f #0 : t [[G f e : t]] : [[G]] . [[t]] [[G f n : N]]. = n . N G f #n : t G,t f \ne : t ' (Weak) (Lam) [[G,t f #0 : t]]. = p2(.) G,t 'f #(n + 1) : t G f .t.e : t . t ' [[G,t 'f #(n \n+ 1) : t]]. =[[G f #n : t]](p1.) G f e1: t . t ' G f e2: t [[G f .t.e : t . t ']]. = x. ([[G,t f e : \nt']] (.,x)) (App) [[G f e1 e2: t]]. =[[G f e1: t '. t]].([[G f e2: t ']].) G f e1 e2: t ' Figure 1. \nSemantics of SL inductive J : (Env, Exp, Typ) -> *1 =  JN : (e1:Env) -> (n :Nat) -> J(e1,EI n,NatT) \n| JV : (e1:Env) -> (t1:Typ) -> J(ExtE e1 t1,EV Z,t1) | JW : (e1:Env) -> (t1:Typ) -> (t2:Typ) -> (i:Nat) \n-> J(e1,EV i,t1) -> J(ExtE e1 t2,EV (S i), t1) | JL : (e1:Env) -> (t1:Typ) -> (t2:Typ) -> (s2:Exp) -> \nJ(ExtE e1 t1,s2,t2) -> J(e1,EL t1 s2, ArrowT t1 t2) | JA : (e:Env) -> (s1:Exp) -> (s2:Exp) -> (t1:Typ) \n-> (t2 : Typ) -> (J(e,s1,ArrowT t1 t2)) -> (J(e,s2,t1)) -> J(e, EA s1 s2, t2)  Figure 2. The typing \njudgment J(without representation types) type of the constructors that dependent datatypes can provide \nmore information about their values.  2.2.1 Interpreters of Types and Judgments After de.ning judgments, \nwe are ready to implement the in\u00adterpretations. Note, however, that the type of the result of the interpretation \nof judgments, depends on the interpretation of SL types. This dependency is captured in the interpretation \nfunction typEval. Figure 3 presents the implementation of the interpreta\u00adtion of types typEval; the mapping \nof type assignments into Meta-D types envEval; and the interpretation of judgments eval. The function \neval is de.ned by case analysis on typing judg\u00adments. Computationally, this function is not signi.cantly \ndifferent from the one presented in Section 1.2. Differences include addi\u00adtional typing annotations, \nand the case analysis over typing judg\u00adments. Most importantly, writing it does not require that we use \ntags on the result values, because the type system allows us to spec\u00adify that the return type of this \nfunction is typEval t.Tags are no longer needed to help us discriminate what type of value we are getting \nback at runtime: the type system now tells us, statically.  2.3 Staged Interpreters in Meta-D Figure \n4 shows a staged version of eval. As with Hindley-Milner types, staging is not complicated by dependent \ntypes. The staged interpreter evalS, returns a value of type (code (typEval t)). Note that the type of \nvalue assignments is also changed (see envEvalS in Figure 4): Rather than carrying runtime values for \nSL, it carries pieces of code representing the values in the variable assignment. Executing this program \nproduces the tagless code frag\u00adments that we are interested in. Even though the eval function never performs \ntagging and un\u00adtagging, the interpretative overhead from traversing its input is still considerable. \nJudgements must be deconstructed by eval at run\u00adtime. This may require even more work than deconstructing \ntagged values. With staging, all these overheads are performed in the .rst stage, and an overhead-free \nterm is generated for execution in a later stage. Staging violations are prevented in a standard way \nby Meta-D s type system (See technical report [36]). The staging constructs are those of Davies [10] \nwith the addition of cross-stage persistence [55]. We refer the reader to these references for further \ndetails on the nature of staging violations. Adding a run construct along the lines of previous works \n[51, 30] was not considered here. Now we turn to addressing some practical questions that are unique \nto the dependent typing setting, including how the above\u00admentioned judgements are constructed.  3 Practical \nConcerns Building type judgments amounts to implementing either type\u00adchecking or type inference for the \nlanguage we are interpreting. Another practical concern is that types that depend on values can lead \nto either undecidable or unsound type checking. This happens when values contain diverging or side-effecting \ncomputations. In this section we discuss how both of these concerns are addressed in the context of Meta-D. \n 3.1 Constructing Typing Judgments Requiring the user of a DSL to supply a typing judgment for each program \nto be interpreted is not likely to be acceptable (although it can depend on the situation). The user \nshould be able to use the implementation by supplying only the plain text of the subject pro\u00adgram. Therefore, \nthe implementation needs to include at least a type checking function. This function takes a representation \nof a type\u00adannotated program and produces the appropriate typing judgment, if it exists. We might even \nwant to implement type inference, which does not require type annotations on the input. Figure 4 presents \na function typeCheck. This function is useful for illustrating a num\u00adber of features of Meta-D: The type \nof the result4 of typeCheck is a dependent sum, written [t : Typ] J(e,s,t). This means that the result \nof typeCheck consists of an SL type, and a typing judgment that proves that the argument expression has \nthat particular type under a given type assignment. 4 In a pure (that is with no computational effects \nwhatsoever) setting the result of typeCheck should be option ([t : Typ] (J (e,s,t))), since a particular \nterm given to typeCheck may not be well-typed. In the function given in this paper, we omit the option, \nto save on space (and rely on incomplete case expressions instead). fun typEval (t : Typ) : *1 = case \nt of NatT => Nat | ArrowT t1 t1 => (typEval t1) -> (typEval t2) fun envEval (e : Env) : *1 = case e \nof EmptyE => unit | ExtE e2 t => (envEval e2, typEval t) fun eval (e : Env) (rho: envEval(e)) (s : Exp) \n(t : Typ) (j : J(e,s,t)) : (typEval t)= case j of JN e1n1 =>n1 | JV e1 t1 => #2(rho) | JW e1 t1 t2 i \nj1 => eval e1 (#1(rho)) (EV i) t1 j1 | JL ee1 et1 et2 es2 ej1 => fn v : (typEval et1) => (eval (ExtE \nee1 et1) (rho,v) es2 et2 ej1 ) | JA e s1 s2 t1 t2 j1 j2 => (eval e rho s1 (ArrowT t1 t2) j1) (eval e \nrho s2 t1 j2) Figure 3. Dependently typed tagless interpreter (without representation types) fun envEvalS \n(e : Env) : *1 = case e of EmptyE => unit | ExtE e2 t => (envEvalS e2, code (typEval t)) fun evalS (e \n: Env) (rho: envEvalS e) (s : Exp) (t : Typ) (j : J(e,s,t)) : (code (typEval t)) = case j of JN e1 \nn1 => .<n1>. | JV e1 t1 => #2(rho)  | JW e1 t1 t2 i j1 => evalS e1 (#1(rho)) (EV i) t1 j1 | JL ee1 \net1 et2 es2 ej1 => .<fn v:(typEval et1) => (. (evalS (ExtE ee1 et1) (rho,.<v>.) es2 et2 ej1))>. | JA \ne s1 s2 t1 t2 j1 j2 => .<(. (evalS e rho s1 (ArrowT t1 t2) j1)) (. (evalS e rho s2 t1 j2))>. fun typeCheck \n(e : Env) (s : Exp) : ([t : Typ] J(e,s,t)) = case s of EI n => [t = NatT] (JN e n) | EV nn => (case nn \nof Z => (case e of ExtE ee t2 => [t = t2](JV ee t2)) | S n => (case e of ExtE e2 t2 => ((fn x : ([rt:Typ]J(e2,EV \nn,rt)) => case x of [rx : Typ]j2 => ([t = rx](JW e2 rx t2 n j2)) ) (typeCheck e2 (EV n))))) | EL targ \ns2 => ((fn x : ([rt : Typ](J(ExtE e targ,s2,rt))) => case x of [rt : Typ] j2 => [t = ArrowT targ rt] \n(JL e targ rt s2 j2)) (typeCheck (ExtE e targ) s2)) |EA s1s2=> ((fn x1 : [rt1 : Typ](J(e,s1,rt1)) => \n(fn x2 : [rt2 : Typ](J(e,s2,rt2)) => case x1 of [rt1 : Typ]j1 => case x2 of [rt2 : Typ]j2 => (case rt1 \nof ArrowT tdom tcod => [t = tcod] (JA e s1 s2 tdom tcod j1 (cast [assert rt2=tdom,J(e,s,tdom), j2])) \nend))) (typeCheck e s1) (typeCheck e s2)) fun typeAndRunNat (s : Exp) : Nat = ((fn x : ([t1 : Typ] J(EmptyE,s,t1)) \n=> case x of [t1 : Typ] j => (case t1 of NatT => eval EmptyE () s NatT j | ArrowT t2 t3 => Z )) (typeCheck \nEmptyE s)) Figure 4. Staged tagless interpreter and the function typeCheck(without representation types) \n Since judgments are built from sub-judgments, a case(strong dependent sum elimination) construct is \nneed to deconstruct the results of recursive calls to typeCheck.  The case for constructing application \njudgments illustrates an interesting point. Building a judgment for the expres\u00adsion (EA s1 s2) involves \n.rst computing the judgments for the sub-terms s1 and s2. These judgments assign types (ArrowT tdom tcod) \nand rt2 to their respective expres\u00adsions. However, by de.nition of the inductive family J,in order to \nbuild the larger application judgment, tdom and rt2 must be the same SL type (i.e., their Typ values \nmust be equal).  We introduce two language constructs to Meta-D to express this sort of constraints \nbetween values. First, the expression of the form assert e1 = e2 introduces an equality judgment, ID \ne1 e2 between values of equality types.5 An elimination construct cast[e1,T,e2] is used to cast the expression \ne2 from some type T[v1] to T[v2],where e1 is an equality judgment of the type ID v1 v2. The type checker \nis allowed to use the Leibniz\u00adstyle equality to prove the cast correct, since e1 is an equality judgment \nstating that v1 and v2 are equal. Operationally, the expression assert e1=e2evaluates its two subexpressions \nand compares them for equality. If they are in\u00addeed equal, computation proceeds If, however, the two \nvalues are not equal, the program raises an exception and terminates. The cast construct makes sure that \nits equality judgment in\u00adtroduced by assert is evaluated at runtime, and if the equality check succeeds, \nsimply proceeds to evaluate its argument ex\u00adpression. An alternative to using assert/cast is to include \nequality judgments between types as part of typing judgments, and build equality proofs as a part of \nthe typeCheck function.6 This approach, while possible, proves to be verbose, and will be omitted in \nthis paper. The assert/cast, however, can serve as a convenient programming shortcut and relieves the \nuser from the effort formalizing equality at the type level and manipulating equality types.  3.2 Representation \nTypes Combining effects with dependent types requires care. For ex\u00adample, the typeCheck function is partial, \nbecause there are many input terms which are just not well typed in SL. Such inputs to typeCheck would \ncause runtime pattern match failures, or an equality assertion exception. We would like Meta-D to continue \nto have side-effects such as non-termination and exceptions. At the same time, dependently typed languages \nperform computations during type checking (to determine the equality of types). If we allow effectful \ncomputations to leak into the computations that are done during type checking, then we risk non-termination, \nor even unsoundness, at type-checking time. This goal is often described as preserving the phase distinction \nbetween compile time and run\u00adtime [5]. The basic approach to dealing with this problem is to allow types \nto only depend on other types, and not values. Disallowing any kind 5This feature is restricted to ground \ntypes whose value can be shown equal at runtime. 6 Due to space limitation we omit this approach here, \nbut de.ne an alternative type-checking function in the accompanying techni\u00adcal report [36]. of such dependency, \nhowever, would not allow us to express our type checking function, as it produces a term whose type depends \non the value of its argument. A standard solution to is to introduce a mechanism that allows only a limited \nkind of dependency between values and types. This limited dependency uses so-called singleton or representation \ntypes [60, 7, 9, 57]. The basic idea is to allow bijections on ground terms between the value and type \nworld. Now, we can rewrite our interpreter so that its type does not de\u00adpend on runtime values, which \nmay introduce effects into the type\u00adchecking phase. Any computation in the type checking phase can now \nbe guaranteed to be completely effect-free. The run-time val\u00adues are now forced to have representation \ntypes that re.ect, in the world of values, the values of inductive kinds. In Meta-D, a special type constructor \nR is used to express this kind of dependency. For example, we can de.ne an inductive kind Nat inductiveNat:*2 \n=Z :Nat|S:Nat->Nat Note that this de.nition is exactly the same as the one we had for the type Nat, \nexcept it is not classi.ed by *2 instead of *1.Once this de.nition is encountered, we have introduced \nnot only the con\u00adstructors for this type, but also the possibility of using the special type constructor \nR. Now we can write R(S(S Z)) to refer to a type that has a unique inhabitant, which we also call rep \n(S(S Z)). Figure 5 presents the implementation with representation types. Introducing this restriction \non the type system requires us to turn the de.nition of Exp, Env,and Typ into de.nitions of kinds (again \nthis is just a change of one character in each de.nition). Because these terms are now kinds, we cannot \nuse general recursion in de.ning their interpretation. Therefore, we use special primitive recursion \nconstructs provided by the type language to de.ne these interpreta\u00adtions. Judgments, however, remain \na type. But now, they are a type indexed by other types, not by values. For the most part, the de.nition \nof judgments and the interpreta\u00adtion function do not change. We need to change judgments in the case \nof natural numbers by augmenting them with a representation for the value of that number. The constructor \nJN now becomes JN:(e1:Env)->(n :Nat)-> (rn:Rn) -> J(e1,EI n,NatT) and the de.nition of eval is changed \naccordingly. The modi.ed eval uses a helper function to convert a representation of a natural type to \na natural number.7 The de.nition of the typeCheck function requires more substan\u00adtial changes (Figure \n5). In particular, this function now requires car\u00adrying out case analysis on types [20, 7, 59, 43, 9]. \nFor this purpose Meta-D provides a special case construct tycase x by y of C_n x_n => e_n. A pattern \n(C_n x_n) matches against a value x of type K,where K is some inductive kind, only if we have provided \na representation value y of type R(x). Pattern matching over inductive kinds can\u00adnot be performed without \nthe presence of a corresponding runtime value of the appropriate representation type. Inside the body \nof the case (e_n), the expression rep x_n provides a representation value for the part of the inductive \nconstructor that x_n is bound to.  4 Formal Development In this section we report our main technical \nresult, which is type safety for a formalized core subset of Meta-D. This result shows that multi-stage \nprogramming constructs can be safely used, even when integrated with a sophisticated dependent type system \nsuch as that of TL [44]. We follow the same approach used by the de\u00ad 7In practice, we see no fundamental \nreason to distinguish the two. Identifying them, however, requires the addition of some spe\u00adcial support \nfor syntactic sugar for this particular representation type. inductive nat : *1 = zero : nat | succ : \n(nat -> nat) inductiveNat:*2 =Z :Nat|S:(Nat->Nat)  inductive Typ : *2 = ArrowT : Typ -> Typ -> Typ | \nNatT : Typ inductiveExp:*2 =EI:Nat->Exp|EV:Nat->Exp |EL:Typ->Exp->Exp |EA:Exp->Exp->Exp inductive Env \n: *2 = EmptyE : Env | ExtE : Env -> Typ -> Env inductive J : (Env, Exp, Typ) -> *1 =  JN :(e1 : Env) \n-> (n : Nat) -> (rn:Rn) -> J(e1,EI n,NatT) | JV :(e1 : Env) -> (t1 : Typ) -> J(ExtE e1 t1,EV Z,t1) | \nJW :(e1 : Env) -> (t1 : Typ) -> (t2 : Typ) -> (i : Nat) -> J(e1,EV i,t1) -> J(ExtE e1 t2,EV (S i), t1) \n| JL :(e1 : Env) -> (t1 : Typ) -> (t2 : Typ) -> (s2 : Exp) -> J(ExtE e1 t1,s2,t2) -> J(e1,EL t1 s2,ArrowT \nt1 t2) | JA :(e : Env)-> (s1 : Exp)-> (s2 : Exp)-> (t1 : Typ)-> (t2 : Typ) -> J(e,s1,ArrowT t1 t2)-> \nJ(e,s2,t1)-> J(e,EA s1 s2,t2) val typEval : Typ -> *1 = primrecTypnat(fnc:*1=>fn d:*1=>c->d) val envEval \n: Env -> *1 = primrec Env unit (fn r : *1 => fn t : Typ => (r,typEval t) fun cast (n : Nat) (rn : R(n)) \n: nat = tycase n by rn of Z => zero | S n2 => succ (cast n2 (rep n2)) fun eval (e : Env) (rho: envEval \ne) (s : Exp) (t : Typ) (j : J(e,s,t)) : (typEval t) = case j of JN e1 n1 rn1 => cast n1 rn1 | JV e1 \nt1 => #2(rho) | JW e1 t1 t2 i j1 => eval e1 (#1(rho)) (EV i) t1 j1 | JL ee1 et1 et2 es2 ej1 =>fn v : \n(typEval et1) => (eval (ExtE ee1 et1) (rho,v) es2 et2 ej1) | JA e s1 s2 t1 t2 j1 j2 => (eval e rho s1 \n(ArrowT t1 t2) j1) (eval e rho s2 t1 j2) fun typeCheck (e : Env) (re: R(e)) (s : Exp) (rs: R(s)) : ([t \n: Typ] (R(t),J(e,s,t))) = tycase s by rs of EI n => [t = NatT] (NatT ,(JN e n (rep n))) |EV n => (tycase \nn by (rep n) of Z => (tycase e by re of ExtE ee t2 => [t = t2](rep t2, JV ee t2)) | S n => (tycase e \nby re of ExtE (e2) (t2) => ((fn x : ([t:Typ] (R(t), J(e2,EV n,t))) => case x of [rx : Typ]j2 => ([t = \nrx] (#1 j2, JW e2 rx t2 n (#2 j2))) (typeCheck e2 (rep e2) (EV n) (rep (EV n))))))) | EL targ s2 => ((fn \nx : ([t : Typ](R(t),(J(ExtE e targ,s2,t)))) => case x of [t : Typ] j2 => [t = ArrowT targ t] (rep (ArrowT \ntarg (#1 t))), (JL e targ t s2 (#2 j2)) ) (typeCheck (ExtE e targ) (rep (ExtE e targ)) s2 (rep s2))) \n|EA s1s2=> ((fn x1 : [t1 : Typ](R(t1),(J(e,s1,t1))) => (fn x2 : [t2 : Typ](R(t2),(J(e,s2,t2))) => case \nx1 of [t1 : Typ]j1 => case x2 of [t2 : Typ]j2 => (tycase t1 by (#1 (j1)) of ArrowT tdom tcod => [t = \ntcod] (rep tcod, (JA e s1 s2 tdom tcod j1 (cast [assert t2=tdom,J(e,s,tdom),j2]))) end))) (typeCheck \ne (rep e) s1 (rep s1)) (typeCheck e (rep e) s2 (rep s2))) Figure 5. Tagless interpreter with representation \ntypes in MetaD inductive .O :Kind ::= snat : Nat ..O |sbool : Bool ..O |.: .O..O..O . |tup : Nat .( Nat \n..O) ..O |.k : .k :Kind.( k ..O) ..O |.k : .k :Kind.( k ..O) ..O |.KS : .k :KScheme.( k ..O) ..O |.KS \n: .k :KScheme.( k ..O) ..O |O : .O..O |EQ :Nat .Nat ..O Figure 6. The TL de.nition of the types of .HO \nX = type variables of TL A = type expressions of TL 00  exp0 .E0 ::= x |n |tt |ff | f0 |.xx : A.f0 |e1 \ne1 |e0[ A] |([ X = A1,e0: A2]) 0 00 0000 000 | open eas X,x in e0 |( e0,...en-1) |sel [ A]( e1,e2) |e1 \n.e2 |if [ A1,A2]( e,X1.e1,X2.e2) |(e1)00 00 | assert e1: A1 = e2: A2 | cast ( e1,A,e2) fn ::= .X : A.en \n|.x : A.en expn+ ::= x |m |tt |ff | fn+ |.xx : A.fn+ 1 |en+ en+ |en+[ A] |([ X = A1,en+ : A2]) |open \nen+ as X,x in en+ n+ n+ 1 n+ n+ n+ n+ n+ n+ n+ | ( e,...,em-1) |sel [ A]( e,e) |e.e|(en++ )| en |if [ \nA1,A2]( e,X1.e,X2.e) 0 1212 1 2 ++ ++ | assert e: A1 = e : A2 | cast ( e1 ,A,e2 ) 12 00 v0 .V0 ::= n \n|tt |ff | f0 |.xx : A.f0 |([ X = A1,v0: A2]) |( v1,...,vm-1) |(v1) | assert v0: A = v0: B vn+ 1 .Vn+ \n1 ::= En Figure 7. Syntax of .HO ()|n = ()  .|n,X : Am = n .,X : Am|n = .|n otherwise . fn G ( x : \nAm) .G m =n . fn G OK . fn G OK . fn G OK .;G fnx : A .;G fnm : snat m .;G fn tt : sbool True .,G fn \nff : sbool False n .|nfA : .O .;G fe1: A1 . A2 nn .;G,x : An fnf : A .|nfA1: .O .;G,x : A1 n fe : A2 \n.;G fe2: A1 .;G fn ( .xx : A.f) : A .;G fn ( .x : A1.e) : A1 . A2 .;G fne1 e2: A2 .|nfB : s .|nfA : B \nnn+ 1 n .,X : Bn;G fnf : A .,G fe : .sX : B.A2 .;G fe : A .;G fe : OA .;G fn ( .X : B.f) : .sX : B.A \n.;G fne[ A] : A2[ X := A] .;G fn (e): OA .;G fn+ 1 e : A n .|nfA : B .,G fe : .sX ' : B.A1 n .;G fe1: \nsnat A1 .|nfB : s .|nfA2: .O nn n .;G fe2: snat A2 .;G fe : A[ X := A1] .,X : B;G,x : A1[ X ' := X] \nfe2: A2 X .. .;G fne1 .e2: snat ( A1. A2) .;G fn ([ X = A1,e : A]) : .sX : B.A .;G fn open e1 as X,x \nin e2: A2 n n n  .;G fe1: tup A3 B .|nfB : Bool .Kind .;G fe : sbool A3 .;G fe2: snat A2 .|nfA : BA3 \n.,X1: B true;G fe1: A2 .|nfA : LT A2 A3 .|nfA2: .O .,X2: B false;G fe2: A2 .;G fn sel [ A]( e1,e2) : \nBA2 .;G fn if [ B,A]( e,X1.e1,X2.e2) : A2 n n 0 =i < m..,G fei : Ai .;G fe : A1 A1 = A2 .|nfA2: .O .;G \nfn ( e0,...,em-1) : tup m ( nth [ A0,...,Am-1]) .;G fne : A2 nn nn .;G fe1 :snat A .;G fe2 :snat B .;G \nfe1 :ID AB .;G fe2 :snat A nn .;G f assert e1: A = e2: B :ID AB .;G fcast ( e1,B,e2) :snat B Figure 8. \nType system of .HO velopers of TL, and build a computation language .HO that uses TL as its type language. \nIntegrating our formalization into the TL framework gave us signi.cant practical advantages in formal \ndevel\u00adopment of .HO : Important meta-theoretic properties of the type language we use, TL, have already \nbeen proven [44]. Since we do not change anything about the type language itself, all these re\u00adsults \n(e.g., the Church-Rosser property of the type language, decidable equality on type terms) are easily \nreused in our proofs.  .HO is based on the computational language .H [44]. We have tried to make the \ndifference between these two languages as small as possible. As a result, the proof of type safety of \n.HO is very similar to the type safety proof for .H .Again, we were able to reuse certain lemmata and \ntechniques developed for .H to our own proof.  A detailed proof of the type safety of .HO is presented \nin an ex\u00adtended technical report [36]. Figure 6 de.nes .HO computational types, and is the .rst step \nneeded to integrate .HO into the TL framework. The syntax of the computational language .HO is given \nin Figure 7. The lan\u00adguage .HO contains recursion and staging constructs. It contains two prede.ned representation \ntypes: naturals and booleans. The if construct, as in .H , provides for propagating proof information \ninto branches (analogous to the tycase construct of MetaD); full implementation of inductive datatypes \nin the style of MetaD is left for future work. Since arbitrary dependent types are prohibited in .HO \n, we use universal and existential quanti.cation to express de\u00adpendencies of values on types and kinds. \nFor example, the identity function on naturals is expressed in .HO as follows: (.n : Nat..x :snat n.x) \n: .n : Nat.snat n . snat n In .HO , we also formalize the assert/cast construct, which requires extending \nthe language of computational types with equal\u00adity judgment types. Similarly, we add the appropriate \nconstructs to the syntax of .HO . To be able to de.ne the small-step semantics for a staged lan\u00adguage, \nwe had to de.ne the syntax of .HO in terms of level-indexed families of expressions and values [48]. \nThe typing judgment (Fig\u00adure 8), as well as the type assignments, of .HO has also been appro\u00adpriately \nextended with level annotations [55]. A level-annotation erasure function (\u00b7|n)is used to convert .HO \ntyping assignments into a form required by the typing judgment of TL[44]. This inter\u00adface then allows \nus to reuse the original TL typing judgment. Due to lack of space we do not show all the de.nitions for \nthe small-step semantics of .HO . These, together with proofs of the relevant theorems, are included \nin a companion technical report [36]. Here, we list the most important theorems. LEMMA 1(PROGRESS). If \n.;G+ fn en : A, then en . Vn or '' .e .e -. e. Proof is by structural induction on en . En, and then \nby examination of cases of the typing judgment. LEMMA 2(SUBJECT REDUCTION). . n. if .,G fne : A and e \n. ' e ' ,then .,G fne : A. ' Proof is by cases of possible reductions e . e . n * THEOREM 1(TYPE SAFETY). \nIf .;G+ fn en : Athen e -. vn, and .,G+ fnv : A,or e .. Proof uses subject reduction (Lemma 2) and progress \n(Lemma 1) lemmas and follows Wright and Felleisen s syntactic technique [58].  5 Related Work Barendregt \n[3] is a good high-level introduction to the theory of dependent type systems. There are a number of \nother references to (strictly terminating) functional programming in dependent type theory literature \n[32, 31, 6]. Cayenne is a dependently typed programming language [1]. In essence, it is a direct combination \nof a dependent type theory with (potentially) non-terminating recursion. It has in fact been used to \nimplement an (unstaged) interpreter similar to the one discussed in this paper [2]. The work presented \nhere extends the work done in Cayenne in three respects: First, Cayenne allows types to de\u00adpend on values, \nand thus, does not ensure that type checking termi\u00adnates. Second, Cayenne does not support dependent \ndatatypes (like J(e,s,t)), and so, writing an interpreter involves the use of a sep\u00adarate proof object \nto encode the information carried by J(e,s,t)), which is mostly just threaded through the program. The \nnumber of parameters passed to both the Meta-D and Cayenne implementation of the eval function is the \nsame, but using dependent datatypes in Meta-D allows direct analogy with the standard de.nition of the \nsemantics over typing judgments rather than raw terms. Third, Cayenne does not provide explicit support \nfor staging, an essen\u00adtial component for achieving the performance results that can be achieved using \ntagless staged interpreters. Xi and Pfenning study a number of different practical approaches to introducing \ndependent types into programming languages [59, 60]. Their work concentrates on limiting the expressivity \nof the dependent types, and thus limiting the constraints that need to be solved to Presburger arithmetic \nproblems. Singleton types seem to have been .rst used by Xi in the context of DML [60]. The idea was \nlater used in a number of works that further developed the idea of representation types and intensional \ntype analysis. Logical frameworks [19, 37] use dependent types as a basis for proof systems. While this \nis related to our work, logical frame\u00adworks alone are not suf.cient for our purposes, as we are inter\u00adested \nin computational programming languages that have effects such as non-termination. It is only with the \nrecent work of Shao, Saha, Trifonov and Papaspyrou that we have a generic framework for safely integrating \na computation base language, with a rich de\u00adpendent type system, without losing decidability (or soundness) \nof type-checking. Dybjer extensively studies the semantics of inductive sets and families [11, 12, 13, \n14, 16] and simultaneous inductive-recursive de.nitions [15]. TL uses only the former (in the type level), \nand we also use them at the value level (J(e,s,t)). The Coq proof assistant provides fairly extensive \nsupport for both kinds of de.ni\u00adtions [17, 34, 35]. In the future, it will be interesting to explore \nthe integration of the second of these techniques into programming languages. One interesting problem \nis whether self-interpretation is possible in a given programming language. This is possible with simply\u00adtyped \nlanguages [54]. It is not clear, however, that it can be done in a dependently typed language [38]. Exploring \nthis problem is interesting future work. Finally, staged type inference [46] can also be used as a means \nof obtaining programs without tags. Of the techniques discussed in this paper, it is probably closest \nin spirit to tag elimination. In fact, in a multi-stage setting tag elimination is applied at runtime \nand is nothing but a non-standard type analysis. Key differences are that in the staged type inference \nsystem the code type that is used does not re.ect any type information, and type information can only \nbe determined by dynamic type checking. More impor\u00adtantly, the success and failure of staged type inference \ncan depend on whether the value in the code type has undergone simpli.ca\u00adtion, and it is easy to return \na value that tells us (at runtime, in the language) whether this dynamic inference succeeded or not. \nTag elimination, on the other hand, works on code that has an explicit static type. Additionally, by \nusing carefully crafted fall-back plan projection/embedding pairs, runtime tag elimination is guaranteed \nto always have the same denotational semantics (but certainly not operational semantics) independently \nof the test of the code being analyzed and any simpli.cations that may be done to the subject program \n[54].  Conclusions and Future Work In this paper we have shown how a dependently typed program\u00adming \nlanguage can be used to express a staged interpreter that com\u00adpletely circumvents the need for runtime \ntagging and untagging op\u00aderations associated with universal datatypes. In doing so we have highlighted \ntwo key practical issues that arise when trying to de\u00advelop staged interpreters in a dependently typed \nlanguage. First, the need for functions that build the representations of typing judg\u00adments that the \ninterpretation function should be de.ned over. And second, the need for representation types to avoid \npolluting the type language with the impure terms of the computational language. To demonstrate that \nstaging constructs and dependent types can be safely combined, we formalize our language as a multi-stage \ncom\u00adputational language typed by Shao, Saha, Trifonov, and Papaspy\u00adrou s TL system. This allows us to \nprove type safety in a fairly straightforward manner, and without having to duplicate the work done for \nthe TL system. A practical concern about using dependent types for writing in\u00adterpreters is that such \nsystems do not have decidable type inference, which some view as a highly-valued feature for any typed \nlanguage. We did not .nd that the annotations were a burden, and some sim\u00adple tricks in the implementation \nwere enough to avoid the need for redundant annotations. In carrying out this work we developed a deeper \nappreciation for the subtleties involved in both dependently typed programming and in the implementation \nof type checkers for dependently typed languages. Our current implementation is a prototype system that \nwe have made available online [27]. Our next step is to study the integration of such a dependently typed \nlanguage into a practical implementation of multi-stage programming, such as MetaOCaml [28]. We have \nalso found that there a lot of opportunities in the con\u00adtext of dependently typed languages that we would \nlike to explore in the future. Examples include syntactically lighter-support for representation types, \nformalizing some simple tricks that we have used in our implementation to help alleviate the need for \nredundant type annotations. We are also interested in exploring the use of de\u00adpendent types to re.ect \nthe resource needs of generated programs [8, 24, 52]. 7 References [1] Lennart guage Augwith ustsson. \ndependent Cayenne types. a Available lan\u00adfrom http://www.cs.chalmers.se/ augustss/cayenne. [2] Lennart \nAugustsson and Magnus Carlsson. An exercise in dependent types: A well-typed inter\u00adpreter. In Workshop \non Dependent Types in Pro\u00adgramming, Gothenburg, 1999. Available online from www.cs.chalmers.se/ augustss/cayenne/interp.ps. \n[3] Henk P. Barendregt. Lambda calculi with types. In S. Abram\u00adsky, D. M. Gabbay, and T. S. E. Maibaum, \neditors, Handbook of Logic in Computer Science. Oxford University Press, Ox\u00adford, 1991. [4] Jon Bentley. \nLittle languages. CACM, 29(8):711 721, 1986. [5] Luca Cardelli. Phase distinctions in type theory. Unpublished \nmanuscript available online from author s homepage, 1988. [6] Thierry Coquand, Bengt Nordstr\u00a8om, Jan \nM. Smith, and Bjorne von Sydow. Type theory and programming. Bulletin of the European Association for \nTheoretical Computer Science, 52:203 228, February 1994. Columns: Logic in Computer Science. [7] Karl \nCrary and Stephanie Weirich. Flexible type analysis. In Proceedings of the Fourth ACM SIGPLAN International \nCon\u00adference on Functional Programming (ICFP-99), volume 34.9 of ACM Sigplan Notices, pages 233 248, N.Y., \nSeptember 27 29 1999. ACM Press. [8] Karl Crary and Stephanie Weirich. Resource bound certi.ca\u00adtion. \nIn the Symposium on Principles of Programming Lan\u00adguages (POPL 00), pages 184 198, N.Y., January 19 21 \n2000. ACM Press. [9] Karl Crary, Stephanie Weirich, and J. Gregory Morrisett. In\u00adtensional polymorphism \nin type-erasure semantics. In Inter\u00adnational Conference on Functional Programming (ICFP) , Baltimore, \nMaryland, USA, pages 301 312, 1998. [10] Rowan Davies and Frank Pfenning. A modal analysis of staged \ncomputation. In the Symposium on Principles of Pro\u00adgramming Languages (POPL 96), pages 258 270, St. Peters\u00adburg \nBeach, 1996. [11] Peter Dybjer. Inductively de.ned sets in Martin-L\u00a8of s set theory. In A. Avron, R. \nHarper, F. Honsell, I. Mason, and G. Plotkin, editors, Workshop on General Logic, February 1987. [12] \nPeter Dybjer. Inductive sets and families in Martin\u00adL\u00a8of s type theory and their set-theoretic semantics. \nIn G. Huet and G. Plotkin, editors, Preliminary Proc. of 1st Int. Workshop on Logical Frameworks, An\u00adtibes, \nFrance, 7 11 May 1990, pages 213 230. 1990. ftp://ftp.inria.fr/INRIA/Projects/coq/types/Proceedings/ \nbook90.ps.Z. [13] Peter Dybjer. Inductive sets and families in Martin-L\u00a8of s type theory and their set-theoretic \nsemantics. In G. Huet and G. Plotkin, editors, Logical Frameworks, pages 280 306. Cambridge University \nPress, 1991. [14] Peter Dybjer. Inductive families. Formal Aspects of Comput\u00ading, 6(4):440 465, 1994. \n[15] Peter Dybjer. A general formulation of simultaneous inductive-recursive de.nitions in type theory. \nJournal of Sym\u00adbolic Logic, 65(2):525 549, 2000. [16] Peter Dybjer and Anton Setzer. Finite axiomatiza\u00adtions \nof inductive and inductive-recursive de.nitions. In R. Backhouse and T. Sheard, editors, Informal Proc. \nof Workshop on Generic Programming, WGP 98, Marstrand, Sweden, 18 June 1998. Dept. of Comput\u00ading Science, \nChalmers Univ. of Techn., and G\u00a8oteborg Univ., June 1998. Electronic version available at http://wsinwp01.win.tue.nl:1234/WGPProceedings/. \n[17] Eduardo Gim\u00b4enez. A tutorial on recursive types in Coq. Tech\u00adnical Report TR-0221, INRIA Rocquencourt, \nMay 1998. [18] Carl A. Gunter. Semantics of Programming Languages.MIT Press, 1992. [19] Robert Harper, \nFurio Honsell, and Gordon Plotkin. A frame\u00adwork for de.ning logics. In Proceedings Symposium on Logic \nin Computer Science, pages 194 204, Washington, 1987. IEEE Computer Society Press. The conference was \nheld at Cornell University, Ithaca, New York. [20] Robert Harper and Greg Morrisett. Compiling polymorphism \nusing intentional type analysis. In Conference Record of POPL 95: 22nd Annual ACM SIGPLAN-SIGACT Sympo\u00adsium \non Principles of Programming Languages, San Fran\u00adcisco, Calif., pages 130 141, New York, NY, January \n1995. ACM. [21] Liwen Huang and Walid Taha. A practical implementation of tag elimination. In preperation. \n[22] Paul Hudak. Building domain speci.c embedded languages. ACM Computing Surveys, 28A:(electronic), \nDecember 1996. [23] Paul Hudak. Modular domain speci.c languages and tools. In Proceedings of Fifth International \nConference on Software Reuse, pages 134 142. IEEE Computer Society, June 1998. [24] R.J.M. Hughes, Lars \nPareto, and Amr Sabry. Proving the correctness of reactive systems using sized types. In Guy L. Steele \nJr, editor, In proceedings of the ACM Symposium on Principles of Programming Languages (POPL), volume \n23, St Petersburg, Florida, 1996. ACM Press. [25] Neil D. Jones, Carsten K Gomard, and Peter Sestoft. \nPar\u00adtial Evaluation and Automatic Program Generation. Prentice-Hall, 1993. [26] Henning Makholm. On Jones-optimal \nspecialization for strongly typed languages. In [49], pages 129 148, 2000. [27] Meta-D: A dependently \ntyped multi-stage language. Available online from http://www.cse.ogi.edu/ pasalic/metad/, 2002. [28] \nMetaOCaml: A compiled, type-safe multi-stage pro\u00adgramming language. Available online from http://cs\u00adwww.cs.yale.edu/homes/taha/MetaOCaml/, \n2001. [29] Torben Mogensen. Inherited limits. In Partial Evaluation: Practice and Theory, volume 1706 \nof Lecture Notes in Com\u00adputer Science, pages 189 202. Springer-Verlag, 1999. [30] Eugenio Moggi, Walid \nTaha, Zine El-Abidine Benaissa, and Tim Sheard. An idealized MetaML: Simpler, and more ex\u00adpressive. In \nEuropean Symposium on Programming (ESOP), volume 1576 of Lecture Notes in Computer Science, pages 193 \n207. Springer-Verlag, 1999. [31] Bengt Nordstr\u00a8om. Programming in constructive set the\u00adory: Some examples. \nIn Proceedings of the ACM Confer\u00adence on Functional Programming and Computer Architecture, Portsmouth, \nNH, pages 141 154, New York, 1981. ACM. [32] Bengt Nordstr\u00a8om, Kent Peterson, and Jan M. Smith. Pro\u00adgramming \nin Martin-Lof s Type Theory, volume 7 of Interna\u00adtional Series of Monographs on Computer Science. Oxford \nUniversity Press, New York, NY, 1990. Currently available online from .rst authors homepage. [33] Oregon \nGraduate Institute Technical Reports. P.O. Box 91000, Portland, OR 97291-1000,USA. Available online from \nftp://cse.ogi.edu/pub/tech-reports/README.html. [34] Christine Paulin-Mohring. Inductive de.nitions in \nthe sys\u00adtem Coq: Rules and properties. Research report RR 92-49, Laboratoire de l Informatique du Parall\u00b4elisme, \nEcole normale sup\u00b4erieure de Lyon, December 1992. [35] Christine Paulin-Mohring. Inductive de.nitions \nin the system Coq: Rules and properties. In M. Bezem and J. F. Groote, ed\u00ad itors, Proc. of 1st Int. Conf. \non Typed Lambda Calculi and Ap\u00adplications, TLCA 93, Utrecht, The Netherlands, 16 18 March 1993, volume \n664 of Lecture Notes in Computer Science, pages 328 345. Springer-Verlag, Berlin, 1993. [36] Emir Pa.sali\u00b4c, \nWalid Taha, and Tim Sheard. Tagless staged interpreters for typed languages (formal development). Tech\u00adnical \nReport 02-006, OGI, 2002. Available from [33]. [37] Frank Pfenning. Logic programming in the LF logical \nframe\u00adwork. In G\u00b4erard Huet and Gordon Plotkin, editors, Logical Frameworks, pages 149 181. Cambridge \nUniversity Press, 1991. [38] Frank Pfenning and Peter Lee. LEAP: A language with eval and polymorphism. \nIn Josep D\u00b4iaz and Fernando Ore\u00adjas, editors, TAPSOFT 89: Proceedings of the International Joint Conference \non Theory and Practice of Software Devel\u00adopment,, volume 352 of Lecture Notes in Computer Science, pages \n345 359. Springer-Verlag, 1989. [39] Benjamin C. Pierce. Basic Category Theory for Computer Scientists. \nMIT Press, Cambridge, Mass., 1991. [40] Calton Pu, Andrew Black, Crispin Cowan, and Jonathan Walpole. \nMicrolanguages for operating system specializa\u00adtion. In Proceedings of the Workshop on Domain-Speci.c \nLanguages, Paris, 1997. [41] John C. Reynolds. De.nitional interpreters for higher-order programming \nlanguages. In ACM National Conference, pages 717 740. ACM, 1972. [42] John C. Reynolds. De.nitional interpreters \nfor higher-order programming languages. Higher-Order and Symbolic Com\u00adputation, 11(4), 1998. (Reprinted \nfrom the proceedings of the 25th ACM National Conference (1972) [41]). [43] Zhong Shao and Andrew W. \nAppel. A type-based compiler for standard ML. In Proceedings of the ACM SIGPLAN 95 Conference on Programming \nLanguage Design and Imple\u00admentation (PLDI), pages 116 129, La Jolla, California, 18 21 June 1995. [44] \nZhong Shao, Bratin Saha, Valery Trifonov, and Nikolaos Pa\u00adpaspyrou. A type system for certi.ed binaries. \nACM SIG-PLAN Notices, 31(1):217 232, January 2002. [45] Tim Sheard, Zine El-Abidine Benaissa, and Emir \nPa.sali\u00b4c. DSL implementation using staging and monads. In Second Conference on Domain-Speci.c Languages \n(DSL 99), Austin, Texas, 1999. USEUNIX. [46] Mark Shields, Tim Sheard, and Simon L. Peyton Jones. Dy\u00adnamic \ntyping through staged type inference. In In proceed\u00adings of the ACM Symposium on Principles of Programming \nLanguages (POPL), pages 289 302, 1998. [47] Yannis Smaragdakis and Don Batory. DiSTiL: A transforma\u00adtion \nlibrary for data structures. In USENIX Conference on Domain-Speci.c Languages, October 1997. [48] Walid \nTaha. Multi-Stage Programming: Its Theory and Ap\u00adplications. PhD thesis, Oregon Graduate Institute of \nScience and Technology, 1999. Available from [33]. [49] Walid Taha, editor. Semantics, Applications, \nand Implemen\u00adtation of Program Generation, volume 1924 of Lecture Notes in Computer Science, Montr\u00b4eal, \n2000. Springer-Verlag. [50] Walid Taha. A sound reduction semantics for untyped CBN multi-stage computation. \nOr, the theory of MetaML is non\u00adtrivial. In Proceedings of the Workshop on Partial Evaluation and Semantics-Based \nProgram Maniplation (PEPM), Boston, 2000. ACM Press. [51] Walid Taha, Zine-El-Abidine Benaissa, and Tim \nSheard. Multi-stage programming: Axiomatization and type-safety. In 25th International Colloquium on \nAutomata, Languages, and Programming (ICALP), volume 1443 of Lecture Notes in Computer Science, pages \n918 929, Aalborg, 1998. [52] Walid Taha, Paul Hudak, and Zhanyong Wan. Directions in functional programming \nfor real(-time) applications. In the International Workshop on Embedded Software (ES 01),vol\u00adume 221 \nof Lecture Notes in Computer Science, pages 185 203, Lake Tahoe, 2001. Springer-Verlag. [53] Walid Taha \nand Henning Makholm. Tag elimination or type specialisation is a type-indexed effect. In Subtyping \nand Dependent Types in Programming, APPSEM Workshop. IN-RIA technical report, 2000. [54] Walid Taha, \nHenning Makholm, and John Hughes. Tag elim\u00adination and Jones-optimality. In Olivier Danvy and Andrzej \nFilinski, editors, Programs as Data Objects, volume 2053 of Lecture Notes in Computer Science, pages \n257 275, 2001. [55] Walid Taha and Tim Sheard. Multi-stage programming with explicit annotations. In \nProceedings of the Symposium on Par\u00adtial Evaluation and Semantic-Based Program Manipulation (PEPM), pages \n203 217, Amsterdam, 1997. ACM Press. [56] Robert D. Tennent. Semantics of Programming Languages. Prentice \nHall, New York, 1991. [57] Valery Trifonov, Bratin Saha, and Zhong Shao. Fully re.ex\u00adive intensional \ntype analysis. In Proceedings of the ACM Sig\u00adplan International Conference on Functional Programming \n(ICFP-00), volume 35.9 of ACM Sigplan Notices, pages 82 93, N.Y., September 18 21 2000. ACM Press. [58] \nAndrew K. Wright and Matthias Felleisen. A syntactic ap\u00adproach to type soundness. Information and Computation, \n115(1):38 94, 1994. [59] Hongwei Xi and Frank Pfenning. Eliminating array bound checking through dependent \ntypes. In Proceedings of the ACM SIGPLAN 98 Conference on Programming Language Design and Implementation \n(PLDI), pages 249 257, Mon\u00adtreal, Canada, 17 19 June 1998. [60] Howgwei Xi and Frank Pfenning. Dependent \ntypes in practi\u00adcal programming. In Conference Record of POPL 99: The 26th ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages, San Antonio, Texas, pages 214 227, New York, NY, January 1999. \nACM. \n\t\t\t", "proc_id": "581478", "abstract": "Multi-stage programming languages provide a convenient notation for explicitly staging programs. Staging a definitional interpreter for a domain specific language is one way of deriving an implementation that is both readable and efficient. In an untyped setting, staging an interpreter \"removes a complete layer of interpretive overhead\", just like partial evaluation. In a typed setting however, Hindley-Milner type systems do not allow us to exploit typing information in <i>the language being interpreted</i>. In practice, this can mean a slowdown cost by a factor of three or mor.Previously, both type specialization and tag elimination were applied to this problem. In this paper we propose an alternative approach, namely, expressing the definitional interpreter in a dependently typed programming language. We report on our experience with the issues that arise in writing such an interpreter and in designing such a language. .To demonstrate the soundness of combining staging and dependent types in a general sense, we formalize our language (called Meta-D) and prove its type safety. To formalize Meta-D, we extend Shao, Saha, Trifonov and Papaspyrou's &#955;H language to a multi-level setting. Building on &#955;H allows us to demonstrate type safety in a setting where the type language contains all the calculus of inductive constructions, but without having to repeat the work needed for establishing the soundness of that system.", "authors": [{"name": "Emir Pa&#353;ali&#917;", "author_profile_id": "81100006230", "affiliation": "Oregon Health & Science University", "person_id": "P394762", "email_address": "", "orcid_id": ""}, {"name": "Walid Taha", "author_profile_id": "81100239752", "affiliation": "Rice University", "person_id": "PP39034018", "email_address": "", "orcid_id": ""}, {"name": "Tim Sheard", "author_profile_id": "81331504269", "affiliation": "Oregon Health & Science University", "person_id": "PP43124236", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/581478.581499", "year": "2002", "article_id": "581499", "conference": "ICFP", "title": "Tagless staged interpreters for typed languages", "url": "http://dl.acm.org/citation.cfm?id=581499"}