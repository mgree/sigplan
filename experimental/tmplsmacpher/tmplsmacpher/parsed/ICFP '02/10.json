{"article_publication_date": "09-17-2002", "fulltext": "\n Modular Typechecking for Hierarchically Extensible Datatypes and Functions * Todd Millstein, Colin Bleckner, \nand Craig Chambers Department of Computer Science and Engineering University of Washington {todd,colin,chambers}@cs.washington.edu \nAbstract One promising approach for adding object-oriented (OO) facili\u00adties to functional languages like \nML is to generalize the existing datatype and function constructs to be hierarchical and extensible, \nso that datatype variants simulate classes and function cases simu\u00adlate methods. This approach allows \nexisting datatypes to be easily extended with both new operations and new variants, resolving a long-standing \ncon.ict between the functional and OO styles. How\u00adever, previous designs based on this approach have \nbeen forced to give up modular typechecking, requiring whole-program checks to ensure type safety. We \ndescribe Extensible ML (EML), an ML-like language that supports hierarchical, extensible datatypes and \nfunc\u00adtions while preserving purely modular typechecking. To achieve this result, EML s type system imposes \na few requirements on datatype and function extensibility, but EML is still able to express both traditional \nfunctional and OO idioms. We have formalized a core version of EML and proven the associated type system \nsound, and we have developed a prototype interpreter for the language. Categories and Subject Descriptors \nD.3.3 [Programming Languages]: Language Constructs and Fea\u00adtures classes and objects, data types and \nstructures, procedures, functions, and subroutines; D.3.1 [Programming Languages]: Formal De.nitions \nand Theory syntax, semantics General Terms Design, Languages, Theory  Keywords extensible datatypes, \nextensible functions, modular typechecking * An earlier version of this paper was presented at the Ninth \nInter\u00adnational Workshop on Foundations of Object-Oriented Languages (FOOL 9), Portland, Oregon, January \n19, 2002. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n02, October 4-6, 2002, Pittsburgh, Pennsylvania, USA. Copyright 2002 ACM 1-58113-487-8/02/0010 ...$5.00 \n1 Introduction Many researchers have noted a difference in the extensibility bene\u00ad.ts offered by the \nfunctional and object-oriented (OO) styles [28, 9, 25, 11, 19, 15, 30]. Functional languages like ML \nallow new oper\u00adations to be easily added to existing datatypes (by adding new fun declarations), without \nrequiring access to existing code. However, new data variants cannot be added without a potentially whole\u00adprogram \nmodi.cation (since existing functions must be modi.ed in place to handle the new variants). On the other \nhand, tradi\u00adtional OO approaches allow new data variants to be easily added to existing class hierarchies \n(by declaring subclasses with overrid\u00ading methods), without modifying existing code. However, adding \nnew operations to existing classes requires access to the source code for those classes (since methods \ncannot be added to existing classes without modifying them in place). There have been several recent \nresearch efforts to integrate the bene.ts of the functional and OO styles in the context of ML. OCaml \n[26] adds OO features including class and method de.ni\u00adtions to ML. The OO constructs essentially form \ntheir own sub\u00adlanguage which is largely separate from the existing ML datatype and fun constructs. Adding \na set of new constructs has the advan\u00adtage that existing language constructs are minimally affected by \nthe extension, retaining their traditional semantics and typing proper\u00adties. Further, the augmented language \naddresses the expressiveness differences of the functional and OO styles in a very simple way, by providing \nboth options. However, such simplicity comes at a cost to programmers, who are forced to choose up front \nwhether to rep\u00adresent an abstraction with datatypes or with classes. As described above, this decision \nimpacts the kind of extensibility allowable for the abstraction. It may be dif.cult to determine a priori \nwhich kind of extensibility will be required, and it is dif.cult to change the de\u00adcision after the fact. \nFurther, it is not possible for the abstraction to enjoy both kinds of extensibility at once. An alternative \napproach is to generalize existing ML constructs to support the OO style. OML [27], for example, introduces \nan objtype construct for modeling class hierarchies. This construct can be seen as a generalization of \nML datatypes to be hierarchi\u00adcal and extensible. Therefore, programmers need not decide be\u00adtween datatypes \nand classes up front; both are embodied in the objtype construct. However, OML still maintains a distinction \nbe\u00adtween methods and functions, which have different bene.ts. New methods may not be added to existing \nobjtypes without modify\u00ading existing code, while ordinary ML functions may be. Methods dynamically dispatch \non their associated objtype, while functions support ML-style pattern matching. ML= [3] integrates the \nOO style further with existing ML con\u00adstructs. Like OML, ML= generalizes ML datatypes to be hierar\u00adchical \nand extensible. Further, methods are simulated via function cases that use OO-style dynamic dispatching \nsemantics. In this ap\u00adproach, programmers need not choose between two forms of exten\u00adsibility; a single \nlanguage mechanism supports the easy addition of both new operations and new variants to existing datatypes. \nHowever, there are important ways in which ML= is not well in\u00adtegrated with existing ML language features. \nFirst, ML= does not support ML-style pattern matching. Patterns are essentially restricted to be top-level \ndatatype constructor tests, which are the analogue of dynamic dispatch tests in OO languages. Other com\u00admon \nML-style patterns and patterns on sub-components cannot be programmed. Second, extensible datatypes are \nof limited utility without exten\u00adsible functions, which allow existing functions to be updated with new \ncases as new data variants are declared. However, ML= does not support extensible functions: all function \ncases are provided when a function is declared. The authors sketch a source-level lan\u00adguage that supports \nextensible functions. Unfortunately, this criti\u00adcal generalization of their work causes a loss of modular \nreasoning: static typechecking of a program cannot be completed until link\u00adtime, when all modules are \navailable. Therefore, important software engineering bene.ts are lost, including early detection of errors, \nli\u00adbraries that are guaranteed to be typesafe in any context satisfying their interface requirements, \nindependent development of typesafe modules by separate teams of programmers, and incremental mod\u00adi.cation \n(and subsequent incremental re-typechecking) of code. The checks that must be delayed to link-time in \nML= constitute what we call implementation-side typechecking (ITC), which en\u00adsures that each function \nin the program is completely and unam\u00adbiguously implemented [8].1 In traditional functional languages, \nITC checks each function for match nonexhaustive and match re\u00addundant errors. Each function can be checked \nmodularly, since a function declaration includes all of its cases and datatypes are not extensible. In \ntraditional OO languages, ITC checks that each class declares or inherits a most-speci.c method for each \nsupported oper\u00adation. Each class can be checked modularly, since a class declara\u00adtion includes all of \nits (non-inherited) methods and new operations cannot be added to existing classes. The implicit restrictions \nin the traditional functional and OO set\u00adtings that allow for modular ITC do not hold in the presence \nof ex\u00adtensible datatypes and functions. Unlike traditional functional lan\u00adguages, no module is guaranteed \nto have access to all of a function s cases. Unlike traditional OO languages, no module is guaranteed \nto have access to all of a datatype variant s associated functions and function cases. Therefore, ML= \nis forced to perform ITC globally, when the whole program is available. In this work, we describe an \nML-like language called Extensible ML2 (EML). EML introduces a class construct, which is a form of hierarchical, \nextensible datatype in the spirit of the constructs in OML and ML=. AsinML=, methods are simulated by \nfunction cases. In addition: 1Implementation-side typechecking contrasts with client-side typechecking \nof functions, which checks that each function appli\u00adcation in the program is type-correct. Client-side \ntypechecking is standard and can be performed modularly. 2not to be confused with Extended ML [18] structure \nSetMod = struct abstract class Set() of {} class ListSet(es:int list) extends Set() of {es:int list \n= es} class CListSet(es:int list, c:int) extends ListSet(es) of {count:int = c} fun add:(int * #Set) \n. Set extend fun add (i, s as ListSet {es=es})= if (member i es) then s else ListSet(i::es) extend fun \nadd (i, s as CListSet {es=es,count=c})= if (member i es) then s else CListSet(i::es,c+1) fun size:Set \n. int extend fun size (ListSet {es=es}) = length es extend fun size (CListSet {es= ,count=c})=c fun elems:Set \n. int list extend fun elems (ListSet {es=es})= es end Figure 1. A hierarchy of integer sets in EML. \nEML generalizes the OO dispatching semantics in ML= to al\u00adlow arbitrary ML-style patterns. This generalization \nprovides idioms that are not expressible by either traditional functional or OO languages.  EML supports \nextensible functions while preserving purely modular typechecking: each module can be typechecked given \nonly the interfaces of the modules it statically depends upon (in a sense described later), with no whole-program \nchecks required. To make per-module implementation-side typechecking sound without necessitating link-time \nchecks, EML s type system imposes certain requirements via the no\u00adtion of a function s owner position, \nwhich serves to coordinate otherwise independent extensions to the function. The owner position generalizes \nsome of the properties of a method s re\u00adceiver in traditional OO languages, shedding new light on how \nthose languages achieve modular typechecking. Despite the imposed requirements, EML s classes and functions \nare still able to simultaneously express traditional functional and OO extensibility idioms. The requirements \nare adapted from our earlier work on Dubious [22, 23], a calculus designed to ex\u00adplore modular typechecking \nfor OO languages based on mul\u00adtimethods.  The rest of the paper is organized as follows. Section 2 describes \nEML by example. Section 3 discusses the challenges for performing modular implementation-side typechecking \nin EML and presents our solution to these challenges. Section 4 de.nes MINI-EML,a core language for EML \nused to formalize our modular type system. Section 5 describes how the features of EML interact with \nan ML\u00adstyle module system, including signature ascription and functors. Section 6 discusses related work, \nand section 7 concludes. We have proven the type system of MINI-EML sound. A companion tech\u00adnical report \n[21] contains the complete formal dynamic and static semantics of MINI-EML as well as the type soundness \nproof.  2 EML by Example Figure 1 shows an EML implementation of integer sets. Classes, functions, and \nfunction cases are declared in ML-style structs. In our discussion we assume that structs contain only \nthose three kinds of declarations. This assumption is lifted in section 5, which describes the interaction \nof EML s features with an ML-style mod\u00adule system. 2.1 Classes The Set class in .gure 1 is the top of \nthe integer set hierarchy. The ListSet class inherits from Set, implementing sets via lists. The CListSet \nclass inherits from ListSet, additionally keeping track of the number of elements in the set. A program \ns subclass relation is the re.exive, transitive closure of the declared extends relation. Classes support \nonly single inheritance. However, like Java [1, 16], EML supports a notion of interface, and a class \ncan implement multiple interfaces. We ignore interfaces in this pa\u00adper for simplicity. The Set class \nis declared abstract,soit may not be instantiated, while its subclasses ListSet and CListSet are concrete. \nEach class declares a record type of its instance variables, using the of clause. Superclass instance \nvariables are inherited: the repre\u00adsentation type of a class C is the representation type (recursively) \nof its direct superclass (if any) concatenated with the type in the of clause in C s declaration. For \nexample, the representation type of CListSet is {es:int list,count:int}, since ListSet s repre\u00adsentation \ntype is {es:int list}. Each class declaration also implicitly declares a constructor, similar to constructor \ndeclarations in OCaml [26] and XMOC [13], a core language for Moby [12]. For example, the CListSet constructor \nexpects arguments es of type int list and c of type int, initial\u00adizes inherited instance variables via \nthe call ListSet(es) to the superclass constructor, and initializes the new count instance vari\u00adable \nto c. In general, the arguments to the superclass constructor call and the instance-variable initializers \nmay be arbitrary expres\u00adsions. It would be straightforward to allow a class to have multiple constructors \nby introducing a separate constructor declaration, similar to makers in Moby. Classes can be used to \nsimulate ordinary ML-style datatypes. In particular, an ML datatype of the form datatype DT = C1 of {L11:T11,...,L1m:T1m} \n| \u00b7\u00b7\u00b7 |Cr of {Lr1:Tr1,...,Lrn:Trn} is encoded in EML by the following class declarations: abstract class \nDT of {}class C1(I11:T11,...,I1m:T1m) extends DT() of {L11:T11=I11,...,L1m:T1m=I1m}\u00b7\u00b7\u00b7 class Cr(Ir1:Tr1,...,Irn:Trn) \nextends DT() of {Lr1:Tr1=Ir1,...,Lrn:Trn=Irn} Unlike the variants in ordinary ML datatypes, classes are \nfull\u00ad.edged types, and other classes may inherit from them. A concrete class is instantiated by invoking \nits constructor. For ex\u00adample, the result of ListSet([5,3]) is an instance of ListSet representing the \nset {5,3}. Like values of ML datatypes, class in\u00adstances have no special object identity or mutable state; \nrefs can be used in a class s representation type for this purpose.  2.2 Functions and Function Cases \nTo make functions extensible, we break an ML-style function dec\u00adlaration into two pieces. The fun declaration \nintroduces a function and speci.es its type. The size function in .gure 1, for example, is declared to \naccept an instance of Set or a subclass and to return an integer. The # in the add function s argument \ntype signi.es that the second argument to add is in the owner position. As a syntactic sugar, the owner \nposition of a function is assumed to be the entire argument when no # is present in the function s argument \ntype. A function and its cases must satisfy several requirements with respect to its owner position, \nto ensure that the function can be modularly checked for exhaustiveness and unambiguity. These requirements \nare discussed in section 3. The owner position has no dynamic ef\u00adfect. The extend fun declaration adds \na case to an existing function. The declaration speci.es the name of the function being extended, a pattern \nguard, and the new case s body. There are two size func\u00adtion cases in .gure 1, handling ListSets and \nCListSets, respec\u00adtively. In a traditional OO language, these size cases would be declared as size methods \nin the ListSet and CListSet class dec\u00adlarations. The extend fun declaration is imperative, updating the \nset of cases associated with the speci.ed function rather than cre\u00adating a new function containing the \nextra case. The imperative se\u00admantics allows extensible functions to faithfully model OO-style methods, \nwhich conceptually update a generic function consist\u00ading of all methods that dynamically override some \nparticular top method. The imperative semantics is necessary to support common OO idioms. For example, \nclients of an OO class hierarchy often im\u00adport only the abstract base class of the hierarchy, with any \nmessage sends through that class s interface dynamically dispatched to the appropriate methods of (potentially \nunknown) concrete subclasses. An ML-style function consisting of n function cases is encoded in EML as \na fun declaration followed by n extend fun declarations. EML functions can be passed to and returned \nfrom other functions, like lambdas and ML-style functions. However, a function s exten\u00adsibility is second-class: \nnew cases may only be added to statically known functions. Patterns in EML subsume both OO-style dynamic \ndispatching and ML-style pattern matching. For example, the second size case in .gure 1 is only applicable \ndynamically if the argument is an in\u00adstance of CListSet or a subclass, whose instance variables match \nthe given representation pattern (which in this case is fully general). As usual, the pattern also binds \nidenti.ers for use in the case s body. An OO-style best-match policy decides which function case to invoke; \ntheir order does not matter. Given an application of func\u00adtion f with argument value v, .rst the applicable \ncases of f for v are retrieved. These are the cases that have a pattern that v matches. Of the applicable \ncases, the unique case that is more speci.c than all other applicable cases is invoked. Intuitively, \ncase c1 is more spe\u00adci.c than case c2 if the set of values matching c1 s pattern is a subset of the set \nof values matching c2 s pattern. We call the invoked case the most-speci.c applicable case. If a function \napplication has no applicable cases, a match nonexhaustive error occurs. If a function application has \nat least one applicable case but no most-speci.c one, a match ambiguous error occurs. For example, consider \nthe invocation size(CListSet([5,3],2)). Both size cases in .gure 1 are applicable to the argument value, \nand the second case is invoked because it is the more-speci.c one. The best-match semantics contrasts \nwith the traditional .rst\u00admatch semantics of function cases in ML. The .rst-match se\u00admantics does not \ngeneralize naturally to handle extensible datatypes and functions, where typically the more-speci.c function \ncases are written after the less-speci.c ones, as new data variants are de.ned. structure UnionMod = \nstruct fun union:(#Set * Set) . Set extend fun union (s1, s2) = fold add s2 (elems s1)  extend fun \nunion (ListSet {es=e1}, ListSet {es=e2})= ListSet(merge(sort(e1), sort(e2))) end Figure 2. Adding new \nfunctions in EML. structure HashSetMod = struct class HashSet(ht:(int,unit) hashtable) extends Set() \nof {ht:(int,unit) hashtable = ht} extend fun add (i, s as HashSet {ht=ht})= if containsKey(i,ht) then \ns else HashSet(put(i,(),ht)) extend fun size (HashSet {ht=ht}) = numEntries(ht) extend fun elems (HashSet \n{ht=ht}) = keyList(ht) end Figure 3. Adding new data variants in EML. Implementation-side typechecking \nensures that match nonexhaus\u00adtive and match ambiguous errors cannot occur at run-time. Each module s \ntypechecks include ITC for functions whose exhaustive\u00adness and unambiguity may be affected by the module. \nThese are functions declared in the module, functions with cases declared in the module, and functions \nthat can accept instances of classes declared in the module. For example, ITC of SetMod in .gure 1 checks \nthe three functions declared there. Consider checking the size function for exhaustiveness and unambiguity. \nAny ListSet instance will invoke the .rst size case, and any CListSet instance will invoke the second \nsize case. The Set class need not have a most-speci.c applicable case, because Set is declared abstract. \nTherefore, ITC for size succeeds. On the other hand, if the .rst size case were missing, a match nonexhaustive \nerror would be sig\u00adnaled statically. Alternatively, if another size case with pattern ListSet {es=es} \nwere declared, a match ambiguous error would be signaled statically.  2.3 Adding New Functions As with \nML datatypes, but unlike traditional classes, EML supports the easy addition of new functions to an existing \nclass hierarchy. For example, .gure 2 adds a function for computing the union of two Sets, without modifying \nany code in the SetModmodule.3 Two union function cases are provided. The .rst case is applicable to \nany pair of Sets. The second union case provides a more ef.cient implementation for two ListSets. ITC \nof UnionMod checks union for exhaustiveness and unambiguity. Any pair of ListSets and CListSets will \ninvoke the second union case, so the function s check succeeds. 2.4 Adding New Data Variants Unlike \nML datatypes, classes in EML also support the easy addi\u00adtion of new data variants to existing hierarchies, \nwithout modifying existing code. An example is shown in .gure 3, which provides a 3Technically, all references \nto Set, ListSet, add, and elems in UnionMod should instead be to SetMod.Set, SetMod.ListSet, SetMod.add, \nand SetMod.elems. For readability, we omit the full path names in examples when clear from context. structure \nSortedListSetMod = struct class SListSet(es:int list) extends ListSet(es) of {} extend fun add (i, s \nas SListSet {es=es})= if (member i es) then s else let (lo,hi) = partition (fn j=>j<i) es in SListSet(lo@(i::hi)) \nend extend fun union (SListSet {es=e1}, SListSet {es=e2})= SListSet(merge(e1,e2)) fun getMin:SListSet \n. int extend fun getMin (SListSet {es=es}) = hd(es) end Figure 4. Class hierarchies in EML. new implementation \nHashSet of sets using an existing implemen\u00adtation (not shown) of hash tables. Implementations of add, \nsize, and elems are provided for the new kind of set. In a traditional OO language, HashSetMod corresponds \nto the declaration of a new subclass of Setwith some overriding methods. ITC of HashSetMod re-checks \nadd, size, and elemsto ensure that they handle HashSet instances. For example, if the new size case were \nnot declared, a match nonexhaustive error for size would be signaled statically. HashSetMod and UnionMod \nfrom .gure 2 illustrate EML s support for both OO and functional forms of extensibility in a single class \nhierarchy. The original Setabstraction is .exibly reused by clients, who add a specialized implementation \n(subclass) of the abstraction and also augment the abstraction with client-speci.c functionality, all \nwithout modifying existing code. HashSetMod and UnionMod are completely independent: either, both, or \nneither module could be linked into the .nal program. In this way, different versions of the Set abstraction \nmay be used in different programs, depending on the needs of a particular application. If both UnionMod \nand HashSetMod are present in a program, then HashSet implicitly supports the union operation and inherits \nany applicable cases. This expressiveness is at the heart of the problem of modular ITC. Because the \ntwo modules are independent, neither is aware of the other during its static typechecks. Therefore, nei\u00adther \nmodule s ITC ensures that union is completely and unambigu\u00adously implemented for HashSets. In this example, \nunion happens to have a case that handles HashSets (by handling any pair of sets). Without extra requirements, \nhowever, things do not always work out so well, as we show in section 3. Another example of data-variant \nextensibility is illustrated in .g\u00adure 4. A new subclass of ListSetis created, representing an imple\u00admentation \nof sets via sorted lists. SListSet inherits the representa\u00adtion type of ListSet (adding no new instance \nvariables) as well as the applicable function cases of size and elems. Overriding cases of add and union \nare provided, as well as a new operation for ac\u00adcessing the minimum element of a set implemented as a \nsorted list. ITC of SortedListSetMod checks add, size, elems, union, and getMin to ensure exhaustiveness \nand unambiguity for SListSets. 2.5 Parametric Polymorphism EML supports a polymorphic type system. Class, \nfunction, and function case declarations optionally bind type variables. Refer\u00ad abstract class a Set() \nof {} class a ListSet(es: a list) extends a Set() of {es: a list = es}class a CListSet(es: a list, c:int) \nextends a ListSet(es) of {count:int = c} fun a add: ( a * # a Set * ( a . a Set . bool)) . a Set extend \nfun a add (i, s as ListSet {es=es}, member) = if (member i s) then s else a ListSet(i::es) extend fun \na add (i, s as CListSet {es=es,count=c}, member) = if (member i s) then s else a CListSet(i::es,c+1) \nFigure 5. Polymorphic sets in EML. ences to a polymorphic class or function specify a particular type \ninstantiation. As an example, .gure 5 shows some of the declara\u00adtions for a polymorphic version of the \nsets in .gure 1. Each class in the set hierarchy is now parameterized by the element type, as is the \nadd function. Each function case is also explicitly parameterized, allowing its function s type variables \nto be renamed for use in the case s body. References to classes in a case s pattern do not contain type \nparameters. The appropriate type instantiation for such classes can be inferred from the declared argument \ntype (for example, the reference to CListSet in the second add case s pattern is implicitly a CListSet). \nEML s polymorphic type system is deliberately simple in several ways. First, EML is explicitly typed. \nSecond, we require that sub\u00adclasses have the same type variables as their superclasses. This requirement \nis consistent with polymorphism in ML, where data variants have the same type variables as their associated \ndatatype. Third, type parameters are invariant; for example, T1 ListSet is a subtype of T2 Set if and \nonly if T1=T2. Finally, there is no support for bounded polymorphism, which would, for example, obviate \nthe need to explicitly pass the membership function to add. We have chosen to make the polymorphic type \nsystem simple be\u00adcause polymorphism is orthogonal to the problems of modular ITC that we address in this \nwork. Those problems arise from the fact that some related classes, functions, and function cases are \nnot mod\u00adularly aware of one another; the problems are neither reduced nor exacerbated by polymorphic \ntypes. Therefore, our polymor\u00adphic type system could be generalized in standard ways without affecting \nour results. For example, we could adopt ML= s subtype\u00adconstrained polymorphic types [3] and associated \ndecidable type system. Recent work [2] has presented a simpli.ed account of ML= s type system and has \nadditionally shown how to incorporate a form of type inference.  3 Modular Implementation-side Type\u00adchecking \nThis section focuses on the problem of modular ITC for EML. First we de.ne our notion of modular typechecking. \nNext we illustrate the ways in which naive modular ITC is unsound. Finally we de\u00adscribe the requirements \nwe impose to achieve modular type safety. 3.1 Modular Typechecking We say that a language s typechecking \nscheme is modular if it has two properties. First, each module m can be typechecked given only the interfaces \nof other modules (without requiring access to the associated implementations). Second, m can be typechecked \ngiven only those interfaces that m statically depends upon. Mod\u00adule m statically depends upon interface \ni if either of the following conditions holds: Module m refers to a name that is bound in i.  Module \nm statically depends upon module interface i', and i' refers to a name that is bound in i.  Traditional \nfunctional languages can support modular typecheck\u00ading. For example, each structure in ML could be typechecked \ngiven only its statically depended-upon structure interfaces. A structure s interface is either an explicitly \nascribed signature or else the struc\u00adture s principal signature. Similarly, each class in a standard \nOO language can be typechecked given only the statically depended\u00adupon class interfaces. Informally, \nthe interface of a class consists of its list of superclasses, the types of its visible .elds, and the \nheaders, but not bodies, of its visible methods. A modular typechecking scheme for EML must typecheck \neach structure given only the interfaces it statically depends upon. We implicitly use a structure s \nprincipal signature as its interface. The principal signature of an EML structure includes all of its \nclass and function declarations, as well as the headers (but not the bodies) of all function case declarations. \nExplicit signatures provide a richer notion of structure interface, as described in section 5. Classes, \nfunctions, and cases that are declared in m or speci.ed in an inter\u00adface upon which m statically depends \nare said to be available during the typechecking of m. All other classes, functions, and cases are unavailable \nand may not be considered during the typechecking of m. Our de.nition of modular typechecking validates \nthe intuition that union of .gure 2 and HashSet of .gure 3 are not aware of one another. Neither UnionMod \nnor HashSetMod statically depends upon the other s interface. Therefore, HashSet is unavailable dur\u00ading \nmodular typechecks on UnionModand unionis unavailable dur\u00ading modular typechecks on HashSetMod, so neither \nmodule s type\u00adchecks ensure that union properly handles HashSets.  3.2 Implementation-side Typechecking \nand Modularity Consider ITC for an EML module m. A straightforward approach to modular ITC checks each \nof m s available functions f for ex\u00adhaustiveness and unambiguity, given all available function cases \nand classes. We call this approach naive modular ITC. Unfor\u00adtunately, naive modular ITC is unsound. The \nhierarchy of EML classes in .gure 6 illustrates the kinds of problems that can occur. Naive modular ITC \nin ShapeMod checks intersect for exhaus\u00adtiveness and unambiguity. Since ShapeMod doesn t statically de\u00adpend \nupon any interfaces (other than its own), the check succeeds vacuously: Shape is abstract and so need \nnot have an intersect implementation. Since CircleMod declares a new intersect case, intersect is again \nchecked during naive modular ITC in CircleMod. CircleMod statically depends on the interface of ShapeMod \nbut not that of RectMod,so CircleMod s check does not consider the Rect class.4 Therefore, the only argument \nto check from CircleMod is a pair of two Circles. The intersect case in CircleMod is most-speci.c for \ntwo Circles, so intersect is 4Indeed, RectMod may not even have been written when CircleMod is typechecked. \nstructure ShapeMod = struct abstract class Shape() of {} fun intersect:(#Shape * Shape) . bool end structure \nCircleMod = struct class Circle() extends Shape() of {} extend fun intersect(Circle , Shape )= \u00b7\u00b7\u00b7 end \n structure RectMod = struct class Rect() extends Shape() of {}extend fun intersect(Shape , Rect )= \u00b7\u00b7\u00b7 \nfun print:Shape . unit extend fun print(Rect )= \u00b7\u00b7\u00b7 end   Figure 6. Challenges for modular implementation-side \ntypechecking. found to be exhaustive and unambiguous. By similar reasoning, intersect passes the checks \nfrom RectMod, since RectMod does not statically depend on the interface of CircleMod. Therefore each \nmodule typechecks, with naive modular ITC declar\u00ading the intersect function to be both exhaustive and \nunambigu\u00adous. However, intersect has neither of these properties. If intersect is invoked on a pair of \na Rect and a Circle (in that order), a match nonexhaustive error will occur since neither intersect case \nis applicable. If intersect is invoked on a pair of a Circle and a Rect (in that order), a match ambiguous \nerror will occur since both intersect cases apply but neither is more speci.c than the other. A .nal \nproblem concerns the print function in RectMod. Since RectMod does not statically depend on CircleMod \ns interface, RectMod s naive modular ITC .nds print to be exhaustive and un\u00adambiguous. However, if a \nCircle is ever passed to print,a match nonexhaustive error will result.  3.3 Achieving Modular ITC As \nwe have seen, naive modular ITC is too permissive, allowing forms of extensibility that are not typesafe. \nTo address this problem, we augment naive modular ITC with some requirements on EML modules that ensure \nthe soundness of ITC. A fundamental design goal is that the requirements still allow the use of both \nfunctional and OO extensibility idioms in a single class hierarchy. We are willing to sacri.ce other \nkinds of extensibility allowed by naive modular ITC to support the traditional functional and OO idioms \nin a modularly typesafe manner. Functional languages allow a new function to be added to an ex\u00adisting \ndatatype. Therefore, EML must allow a new function to be added to an existing class. OO languages allow \na new subclass to be added to an existing class, along with associated overriding meth\u00adods that have \nthe new subclass as their receiver. To formulate this idiom in EML we employ a function s owner position, \nwhich gen\u00aderalizes a similar notion in the Dubious language [22]. A function s owner position has some \nproperties in common with the receiver position in standard OO languages. Rather than forcing the owner \nposition to be the .rst argument to a function, it can be speci.ed as an arbitrary (and arbitrarily nested) \nposition of the argument, via the # in a function s declared argument type. The type at the owner position \nin a function s argument type must be a class; that class is the function s owner. For example, Set is \nthe owner of add in .gure 1. To express the OO extensibility idiom in EML, we must allow a new subclass \nto be added to an existing class C, along with overriding cases of functions for which C is the owner. \nFor the purposes of our modular requirements, we partition func\u00adtions into two categories. A function \nis called internal if itis de\u00adclared in the same module as its owner; otherwise the function is external. \nAn internal function is guaranteed to be available to all modules that declare subclasses of the function \ns owner, while that is not true of an external function. Therefore, an internal function can be thought \nof as part of the initial interfaces of its owner class and subclasses, while an external function is \na later extension to those interfaces. External functions have no analogue in traditional OO languages, \nin which a class s methods must all be declared with the class. The special properties of internal functions \nare exploited in one of our three requirements, which are now discussed in turn. 3.3.1 Completeness Requirement \nfor External Func\u00adtions Consider the completeness problem with the print function in RectMod in .gure \n6. Because new subclasses can be added to ex\u00adisting classes, some subclasses of a function s owner may \nnot be available in the function s module. Indeed, Circle is not available in print s module. On the \nother hand, because print is external, there is no guarantee that print will be available to all modules \ndeclaring subclasses of Shape. Indeed, print is not available to Circle s module. Therefore, to modularly \nensure that print is complete, we require its module to contain a global default case. A global default \nis a case whose pattern is applicable to all type\u00adcorrect arguments to the function. In general, we require \na module that declares an external function to include a global default case for the function. Therefore, \nITC on RectMod fails, because the global-default re\u00adquirement is not satis.ed for its external function \nprint.If print had a case with, for example, pattern (Shape {}), then the require\u00adment would be satis.ed \nand the completeness problem for Circle would be avoided. As another example, the external function union \nin .gure 2 satis.es the requirement because its .rst case is a global default, thereby handling the unavailable \nHashSet class of .gure 3 and any other unavailable Set subclasses. The global-default requirement does \nnot impose an extra burden from the point of view of standard OO languages, as such languages do not \neven allow external functions to be declared. However, stan\u00addard functional languages do allow external \nfunctions, without re\u00adquiring global default cases. Those languages disallow data-variant extension, \nso an external function can be modularly checked against all possible data variants. EML s modular ITC \nmust allow for the possibility of unavailable subclasses of a function s owner, thereby sometimes requiring \nthe declaration of global default cases that will never be used. Section 5 introduces a mechanism for \nsealing class hierarchies, which can obviate the need for global default cases.  3.3.2 Completeness \nRequirement for Internal Func\u00adtions Consider the incompleteness for a pair of one Rect and one Circle \nin the internal intersectfunction of .gure 6. One way to solve the problem would be to require a global \ndefault case, as we require for external functions. Indeed, if ShapeMod contained an intersect case that \nis applicable to any pair of Shapes, the incompleteness would be resolved. While requiring global default \ncases solves the problem, it is unnecessarily burdensome. As mentioned earlier, an internal function \nis guaranteed to be available to all modules declar\u00ading subclasses of the function s owner. Therefore, \nrather than re\u00adquiring the function s module to handle all unknown subclasses, we can require each module \nthat declares a concrete subclass of the function s owner to ensure completeness for its subclass. This \nidea is inspired by standard OO languages, in which a method in an ab\u00adstract class may safely remain \nunimplemented, with each concrete subclass declaring or inheriting a concrete implementation of the method. \n Our requirement is that each module declaring a concrete subclass C of an internal function s owner \nmust also declare or inherit a local default case for the function. A local default case of a class C \nis a case whose pattern accepts only instances of C and subclasses at the owner position, while every \nother argument position can be passed any value of the appropriate type. Local default cases are the \nEMLanalogueoftraditionalOOmethods,whichdispatchonthe surrounding class at the receiver position and do \nnot dispatch on any other argument position. A class s local default cases ensure that the class completely \nimplements all of the functions in its initial interface. Given the local-default requirement, ITC on \nRectMod fails to typecheck because it does not declare or inherit a local default intersect case for \nRect. (An isomorphic error would occur in CircleMod if the second argument position in the pair were \ndesig\u00adnated the owner position.) The requirement would be satis.ed, for example, if RectModhad an intersectcase \nwith pattern (Rect , Shape ), accepting Rects at the owner position and accepting all Shapes in the other \nposition. That case resolves the incompleteness for a pair of one Rect and one Circle. A global default \ncase need not be written: intersect may still be safely left unimplemented for two Shapes. As another \nexample, the internal add function in .gure 1 does not have a global default case. Instead, it has local \nde\u00adfault cases for its two concrete subclasses ListSet and CListSet. When HashSet is introduced in .gure \n3, an associated local default is also declared, satisfying the requirement and ensuring that add is \ncomplete for HashSets. The local-default requirement does not impose an extra burden from the point of \nview of standard OO languages. Whenever a local de\u00adfault case of some internal function f is required \nfor a class C,an OO language would require C s declaration to contain an f method, so that C is properly \nimplemented. Therefore, the abstract-class id\u00adioms of traditional OO languages are preserved in EML. \nHowever, standard functional languages do allow internal functions, without requiring local default cases. \nAs above, this is possible because such languages disallow data-variant extension. EML s ITC must always \nassume the possibility of unavailable subclasses of classes in non-owner positions of a function s argument \ntype, thereby some\u00adtimes requiring the declaration of local default cases that will never be used. Again, \nwe can use sealing, discussed in section 5, to obvi\u00adate the need for local default cases.  3.3.3 Ambiguity \nRequirement In .gure 6 the two intersect cases are ambiguous, but neither CircleMod nor RectMod statically \ndepends upon the other, so the ambiguity is not modularly detected. We address this problem by restricting \nEML s function extensibility such that cases declared in modules that do not statically depend upon one \nanother are guaran\u00adteed to be disjoint: the cases are not applicable to a common value and hence are \nnot ambiguous. Our restriction generalizes the im\u00adplicit restrictions in standard functional and OO languages. \nFirst we introduce the concept of a function case s owner, which is the class (if any) at the owner position \nof the case s pattern. For ex\u00adample, ListSet is the owner of the second union case in .gure 2 because \nit appears at the owner position, while the .rst union case has no owner.  In functional languages, \neach case must be declared in the mod\u00adule that declares the associated function. In OO languages, each \nmethod must be declared inside the method s receiver. Our require\u00adment is the disjunction of these conditions: \nevery function case must either be declared in the module that declares the case s func\u00adtion or in the \nmodule that declares the case s owner (if any). RectMod now fails to typecheck because its intersect \ncase does not satisfy our requirement: neither intersect nor Shape, the case s owner, is declared in \nRectMod. (An isomorphic error would occur in CircleMod if the second argument position in the pair were \ndesignated the owner position.) Therefore, RectMod may not extend intersect in that way. The requirement \ncan be satis.ed, for example, by modifying the intersect case s pattern to (Rect , Shape ). This modi.cation \nresolves the ambiguity for a pair of a Circle and a Rect, since the revised case is no longer ap\u00adplicable. \nAs another example, the add cases in HashSetMod and SortedListSetMod of .gures 3 and 4 are never compared \nfor am\u00adbiguity, because the two modules do not statically depend upon one another. However, each case \nsatis.es our requirement by following the traditional OO idiom of implementing an overriding method for \na newly declared subclass. Therefore the two cases are guaranteed to be disjoint. Since our ambiguity \nrequirement is the disjunction of the implicit requirements in standard functional and OO languages, \nour require\u00adment does not restrict those programming styles and allows them to coexist. Therefore, we \nhave achieved our design goal of allowing the functional and OO extensibility idioms in a single class \nhier\u00adarchy while preserving modular type safety.5 However, other use\u00adful kinds of extensibility are disallowed \nby the ambiguity require\u00adment. For example, a client of both UnionMod and HashSetMod from .gures 2 and \n3 may want to implement union specially for HashSets, so that these independent extensions of the Set \nabstrac\u00adtion will work well together. However, the new case would violate our ambiguity requirement, \nso HashSets are forced to use the de\u00adfault union case (or HashSetMod must be modi.ed in place to add \nthe new case).  4 Mini-Eml This section describes MINI-EML, a core language used to formal\u00adize the \nfundamental ideas in EML. We give the full dynamic seman\u00adtics but only a brief introduction to the static \nsemantics. The com\u00adplete details of MINI-EML are available in our companion technical report [21]. 5In \nthe presence of multiple implementation inheritance, other kinds of ambiguities that elude modular detection \ncan arise, neces\u00adsitating an extra requirement [23]. However, multiple interface in\u00adheritance, as in \nJava, cannot cause such ambiguities.  4.1 Syntax Figure 7a de.nes the syntax of types, expressions, \nand patterns in MINI-EML. The syntax is essentially that of EML as informally presented so far, but we \nomit standard constructs including base types, conditionals, lambdas, local variables, references, and \nex\u00adceptions. The domain Mt represents marked types, which contain a # mark on a single component class \ntype. The instance expres\u00adsion Ct {V =E}is not available at the source level, as instances may only be \ncreated via a constructor call Ct(E). The construct {V =E}differs from an ordinary record in two ways. \nFirst, the la\u00adbels are scoped: the name of the structure in which an instance vari\u00adable was introduced \nbecomes part of the instance variable s name. In the presence of the ability to make instance variables \nprivate (see section 5), scoping allows subclasses to introduce a new instance variable without con.icting \nwith the name of a hidden one in the superclass. Instance variables in EML use this mechanism implic\u00aditly; \nregular static scoping rules determine which instance variable is referred to. Second, for simplicity \nthe components of {V =E}are ordered, unlike traditional records. The notation and semantic style of MINI-EML \nwere in.uenced by Featherweight Java [17], a core language for Java. As in that lan\u00adguage, we formally \nrepresent classes by their names. A class is uniquely represented as Sn.Cn, where Cn is the name of the \nclass and Sn is the name of the structure that declares Cn. Extensible functions are represented similarly. \nThe subset of expressions that are MINI-EML values is described by the following grammar, which includes \nclass instances, function values, and tuple values: v ::= Ct {V =v}|Fv |(v) The syntax of structures \nand declarations is shown in .gure 7b. For convenience in the core language, each structure explicitly \nnames the other structures (often including itself) whose interfaces it stat\u00adically depends upon, via \nthe depends upon Sn clause. ITC for a structure employs only the interfaces of the structures named in \nthe depends upon clause. The static semantics ensures that the given dependency relation is well-formed, \nas described below. The syntax of the three declarations is faithful to that of EML, except that cases \nnow contain a case name Mn. This name is used in the semantics to uniquely identify each function case \ndeclaration (see section 4.2). Analogous with Featherweight Java, a MINI-EML program is a pair of a structure \ntable and an expression. A structure table is a .nite function from structure names to the associated \nstructure declara\u00adtions. The semantics assumes a .xed structure table denoted ST. The structure table \nST is accessed by the dynamic and static se\u00admantics rules when information about a given OO declaration \nis required. The domain of a structure table ST is denoted dom(ST). 4.2 Dynamic Semantics MINI-EML s \ndynamic semantics is de.ned as a mostly standard small-step operational semantics. The metavariable . \nranges over environments, which are .nite functions from identi.ers to values. We use |D| to denote the \nlength of the sequence D. The nota\u00adtion [I1 .E1,...,Ik.Ek]D denotes the expression resulting from the \nsimultaneous substitution of Ei for each occurrence of Ii in D, for 1 =i =k, and similarly for [a1 We \nuse .t1,...,ak.tk]D. [I .E]D as a shorthand when I and E have the same length, and similarly for [a In \na given inference rule, fragments en\u00ad .t]D.      closed in <> must either be all present or all \nabsent, and similarly for <<>>. We sometimes treat sequences as if they were sets. For example, Ood .Ood \nmeans that Ood is one of the declara\u00adtions in Ood. We use Ood .ST(Sn)as shorthand for ST(Sn)= structure \nSn =struct depends upon Sn Ood end and Ood . Ood. Figure 8a contains the rules for evaluating expressions. \nFor simplic\u00adity in the semantics, E-NEW de.nes constructor calls as syntactic sugar for instance expressions. \nIt would be straightforward to in\u00adstead use a call-by-value semantics for constructor calls, at the cost \nof some additional mechanism. E-NEW makes use of the .rst two auxiliary rules in .gure 8b. CONCRETE checks \nthat the class to be instantiated was declared without the abstract keyword. REP initializes the .elds \nof the new instance as directed by the class s implicit constructor. The last rule in .gure 8b formalizes \nfunction-case lookup, used in E-APPRED. The top line of LOOKUP s premises speci.es the case to invoke, \nand the second line ensures that the chosen case is ap\u00adplicable. The remaining premise ensures that the \nchosen case is most-speci.c: the case is strictly more speci.c than any other ap\u00adplicable case. The condition \nSn.Mn .Mn' uses the case names =Sn'to ensure that the chosen case is not compared for speci.city with \nitself. The rules for pattern matching and speci.city are shown in .g\u00adure 9, completing the dynamic semantics. \nThe matching rules are straightforward except for E-MATCHCLASS. The notation C =C' denotes that (C,C')is \nin the re.exive, transitive closure of the de\u00adclared class extends relation. E-MATCHCLASS recursively \npat\u00adtern matches on the instance variables, unlike traditional OO lan\u00adguages and ML=. We allow an instance \nto have more instance variables than the given representation pattern, so that subclass instances can \nmatch superclass patterns. For example, the value CListSet {es=[5,3],count=2} matches the pattern in \nthe elems case of .gure 1. The judgment Pat =Pat' means that Pat is at least as speci.c as Pat'. The \npattern speci.city semantics generalizes OO-style best\u00admatch semantics to support ML-style patterns. \nClass pattern speci\u00ad.city (SPECCLASS) follows the ordering induced by subclassing. Analogous with E-MATCHCLASS, \nthe more-speci.c pattern may contain extra instance variables. The natural rule SPECTUP for tu\u00adple patterns \nmakes pattern speci.city a generalization of the sym\u00admetric multimethod speci.city semantics in OO languages \n[6, 7]. When a tuple is used to send multiple arguments to a function, tu\u00adple patterns allow all arguments \nto be dynamically dispatched upon, and no argument position is more important than the rest. This contrasts \nwith traditional single dispatch, as in Java, where only a unique receiver argument may be dispatched \nupon.  4.3 Static Semantics Figure 10 contains the rules for typechecking structures and OO declarations. \nG is a type environment, mapping identi.ers to types. The notation Mt denotes the type t equivalent to \nMt, but with the # markremoved. Structuresaretypechecked (STRUCTOK)bycheck\u00ading each declaration in turn. \nIt is assumed that S OK holds for each structure S in the range of ST. The rules for typechecking the \nthree OO declarations are largely straightforward. The premises rely on several kinds of judgments. A \njudgment of the form a ft OK ensures that t is a well-formed t ::= a | Ct | t1 .t2 | t1 *\u00b7\u00b7\u00b7*tk S ::= \nstructure Sn = Mt ::= # Ct | t1 *\u00b7\u00b7\u00b7*ti-1 *Mt *ti+1 *\u00b7\u00b7\u00b7*tk struct depends upon Sn Ood end E ::= I | \nFv | E1 E2 | Ct(E)| (E)| Ct {V =E} Ood ::= <abstract> class a Cn(I : t) Pat ::= | I as Pat |C {V =Pat}| \n(Pat) <<extends Ct(E)>> of {Vn : t0 =E0} Ct ::= t C Fv ::= t F | fun a Fn : Mt .tC ::= Sn.Cn V ::= Sn.Vn \n| extend funMn a FPat =E F ::= Sn.Fn (a) (b) Figure 7. (a) MINI-EML types, expressions, and patterns; \n(b) MINI-EML structures and declarations. Metavariable a ranges over type variable names, I over identi.er \nnames, Sn over structure names, Cn over class names, Vn over instance variable names, Fn over function \nnames, and Mn over case names. D denotes a comma-separated list of elements (and is independent of any \nvariable named D). Angle brackets (<>) and double angle brackets (<<>>) denote independent optional pieces \nof syntax. The notation V =E abbreviates V1 =E1,...,Vk =Ek where V is V1,...,Vk and E is E1,...,Vk for \nsome k =0, and similarly for V =Pat, Vn : t0 =E0, and I : t. ' E -. E Ct =(t C) concrete(C) rep(Ct(E0))={V \n=E1} E-NEW Ct(E0)-. Ct {V =E1} ' E -. E E-REP Ct {V0 =v0,V =E,V1 =E1}-. ' Ct {V0 =v0,V =E ,V1 =E1} ' \nE -. E E-TUP (v0,E,E1)-.(v0,E ' ,E1) E1 -. E1 ' E2 -.E2 ' E-APP1 E-APP2 E1 E2 -. E1 ' E2 v1 E2 -.v1 \nE ' 2 most-speci.c-case-for(Fv,v)= ({(I,v)},E) E-APPRED Fv v -. [I .v]E (a) concrete(C) (class a Cn \n...) .ST(Sn) CONCRETE concrete(Sn.Cn) rep(Ct(E0))={V =E} (<<abstract>>class a Cn(I : t1)<extendsCt(E0)> \nof {Vn : t2 =E2}).ST(Sn) <rep(Ct(E0))={V =E1}> REP rep((t Sn.Cn)(E))=[I .E][a .t]{<V =E1,> Sn.Vn =E2} \nmost-speci.c-case-for (Fv,v)=(.,E) (extend funMn a FPat =E) .ST(Sn) match(v,Pat)= . .Sn '.dom(ST)..(extend \nfunMn ' a' FPat ' ...) .ST(Sn '). ..' .(match(v,Pat ' )= .'.Sn.Mn =Sn ' .Mn ' .Pat =Pat '.Pat '=Pat) \nmost-speci.c-case-for ((t F),v)=(.,[a .t]E) (b) LOOKUP Figure 8. (a) Evaluation rules for expressions. \n(b) Auxiliary inference rules. The notation (I,v)abbreviates (I1,v1),...,(Ik,vk); Sn.Vn =E abbreviates \nSn.Vn1 =E1,...,Sn.Vnk =Ek. match(v,Pat)=. Pat =Pat' E-MATCHWILD SPECWILD match(v, )={} Pat = Pat1 =Pat2 \nPat1 =Pat2 match(v,Pat)=. SPECBIND1 SPECBIND2 E-MATCHBIND I as Pat1 =Pat2 Pat1 =I as Pat2 match(v,I \nas Pat)=..{(I,v)} C =C ' Pat1 =Pat2 SPECCLASS C =C ' match(v,Pat)=. .E-MATCHCLASS C {V =Pat1,V3 =Pat3}=C \n'{V =Pat2} match(t C {V =v,V1 =v1},C '{V =Pat})=. Pat1 =Pat2 SPECTUP match(v,Pat)=. (Pat1)=(Pat2) .E-MATCHTUP \nmatch((v),(Pat))=.  (a) (b) Figure 9. (a) Pattern matching. (b) Pattern speci.city. The notation match(v,Pat)=. \nabbreviates match(v1,Pat1)=.1 \u00b7\u00b7\u00b7match(vk,Patk)= .k, and similarly for Pat1 =Pat2. S OK Sn fOod OK in \nSn STRUCTOK structure Sn = structdepends upon Sn Ood end OK Sn fOod OK in Sn <Ct =a Sn.Cn >< G;a fCt(E)OK \n> a ft OK a ft0 OK G ={(I ,t )} G;a f E0: t1 t1 =t0 Sn fSn.Cn transDependedUpon concrete(Sn.Cn).Sn ffuns-have-ldefault-for \nSn.Cn CLASSOK Sn f<<abstract>>class a Cn( I : t) <extendsCt(E)> of {Vn : t0 =E0} OK in Sn a f a f t \nOK .Cn Mt OK owner(Sn.Fn)=Sn ' Sn =Sn '.Sn fSn.Fn has-gdefault FUNOK Sn ffun a Fn : Mt .t OK in Sn (fun \na' Fn : Mt . t).ST(Sn ') matchType([a'.a]Mt ,Pat)=(G,t0) G;a fE : t' t'=[a'.a]t Sn fSn ' .Fn dependedUpon \nSn;Sn fextend funMn a Sn ' .Fn Pat =E unambiguous CASEOK Sn fextend funMn a Sn ' .Fn Pat =E OK in Sn \nFigure 10. Static semantics of structures and OO declarations. The notation Sn f Ood OK in Sn abbreviates \nSn f Ood1 OK in Sn \u00b7\u00b7\u00b7 Sn f Oodk OK in Sn; a f t OK abbreviates a f t1 OK \u00b7\u00b7\u00b7 a f tk OK; (I ,t )abbreviates \n(I1,t1),...,(Ik,tk); G;a f E : t abbrevi\u00adates G;a f E1: t1 \u00b7\u00b7\u00b7 G;a f Ek : tk; t1 = t0 abbreviates t11 \n= t01 \u00b7\u00b7\u00b7 t1k =t0k. type: only type variables in a are referred to in t, and each class in t has the \ncorrect number of type parameters. A judgment of the form t1 =t2 denotes that t1 is a subtype of t2; \nthe subtyping rela\u00adtion is completely standard [5]. A judgment of the form G;a fE : t ensures that expression \nE has type t, in the context of the current type environment and sequence of type variables in scope. \nA judg\u00adment of the form G;a f Ct(E)OK is used in CLASSOK to ensure that the superclass constructor call \nis well-formed. A judgment of the form matchType(t,Pat)=(G,t')ensures that a case s pattern Pat is compatible \nwith the associated function s declared argument type t; the type environment G contains bindings for \nthe identi.ers in Pat and is used to typecheck the case s body. The transDependedUpon and dependedUpon \njudgments in CLASSOK and CASEOK check properties of a structure s declared depends upon relation. The \n.rst judgment ensures that a struc\u00adture containing a class is declared to depend upon all structures \nthat declare a (re.exive, transitive) superclass of the class. The sec\u00adond judgment ensures that a structure \ncontaining a function case is declared to depend upon the structure containing the associated function. \nIn either case, if Sn is required to declare a dependency on Sn ' , then Sn does indeed statically depend \nupon Sn ' according to the de.nition of static dependency given in section 3.1. The declared dependency \nrelation may include more structures than are statically depended upon, but the soundness proof relies \nonly on the above two properties of the declared dependency relation, thereby ensur\u00ading that modularity \nis respected. Finally, each of the rules for typechecking declarations enforces one of the three modular \nrequirements described in section 3.3. CLASSOK enforces the local-default requirement on the new class \n( funs-have-ldefault-for ), if it is concrete. FUNOK enforces the structure BadMod = struct class C() \nof {} fun f:C . unit val bad = f(C()) extend fun f (C {})= () end Figure 11. Value declarations and \nITC. global-default requirement on the new function ( has-gdefault ), if it is external. CASEOK enforces \nthe ambiguity requirement and explicitly checks ambiguities of the new case with any available function \ncases ( unambiguous ).  4.4 Type Soundness We have proven type soundness for MINI-EML. As usual, we \nprove type preservation and progress theorems. The notation f E : T de\u00adnotes the typechecking of E in \nthe context of the empty type envi\u00adronment and empty sequence of type variables. THEOREM 1. (Type Preservation) \nIf f E : t and E -. E ' , then there exists t' such that fE ' : t' and t'=t. THEOREM 2. (Progress) If \nfE : t and E is not a value, then there exists E ' such that E -.E ' . Proving type preservation is straightforward, \nas it is completely in\u00addependent of ITC. Proving progress requires reasoning about mod\u00adular ITC, in order \nto show that function applications can always make progress. The key lemma says that a most-speci.c applicable \nfunction case exists for each type-correct application: LEMMA 1. If f Fv : t2 . t and f v : t' 2 and \nt2 '= t2, then there exist . and E such that most-speci.c-case-for (Fv,v)=(.,E). Details are available \nin our companion technical report [21].  5 ML-Style Modules Thissectiondiscusseshow EML sfeaturescaninteractwithanML\u00adstyle \nmodule system including structures, signatures, and functors. 5.1 Structures Thus far we have assumed \nthat EML structures contain only a se\u00adquence of class, function, and function case declarations. We would \nalso like to accommodate the ordinary ML declarations, including value, type, exception, and structure \ndeclarations. The latter three kinds of declarations can be straightforwardly incorporated, but special \ncare is needed to handle value declarations. Figure 11 shows an example of the problems that can occur. \nITC on BadMod will succeed, because function f has an appropriate case for C.How\u00adever, at run-time a \nmatch nonexhaustive error will occur when the val declaration is executed, because f s function case \nwill have not yet been declared. There are several approaches to handling this problem. We could adopt \na two-pass style of structure evaluation. The .rst pass would evaluate all of the declarations except \nthe value declarations, and the second pass would evaluate the value declarations. In our ex\u00adample, this \nsemantics ensures that f s function case is declared be\u00adfore f is invoked. An alternative approach is \nto make the unit of modularity used in our ITC requirements more .ne-grained than an entire structure, \nwith val declarations forming the boundaries of signature ShapeSig = sig abstract class Shape() of {} \nfun bad:Shape . unit extend fun bad s end structure ShapeMod = struct abstract class Shape() of {} fun \nprint:Shape . unit fun bad:Shape . unit extend fun bad s = print s end : ShapeSig structure CircleMod \n class Circle() extends Shape() of {}end Figure 12. Unsoundnesses with hiding OO declarations. these \nunits. For example, BadMod would consist of two units, one of which contains the .rst two declarations \nand the other contain\u00ading the last declaration. When ITC is performed on the .rst unit, the incompleteness \nof f for C would result in a static error. Our prototype EML interpreter uses a variant of this approach. \nInstead of inferring the modular units, we introduce a new kind of OO dec\u00adlaration of the form Ood and \nOod ' (similar syntactically, but not semantically, to the and construct in ML), which groups a sequence \nof class, function, and function case declarations. A group of anded OO declarations is treated as a \nunit for the purposes of modular ITC. 5.2 Signature Ascription Signature ascription provides information \nhiding in ML. Clients of a structure expression of the form S : Sig, where Sig is a signa\u00adture, may only \naccess S s components via the interface provided in Sig. Signature ascription for EML provides forms \nof OO-style encapsulation. For example, classes, functions, and function cases can be hidden from clients, \nmaking them private to their enclosing structure. However, these declarations cannot be hidden arbitrar\u00adily, \nor else modular ITC would become unsound. Figure 12 shows a simple example of the problems that can occur. \nShapeMod cre\u00adates the abstract Shape class and two associated functions. ITC in ShapeMod .nds print to \nbe exhaustive and unambiguous, since Shape is abstract. Ascription to the ShapeSig signature hides print. \nTherefore, print is not part of ShapeMod s interface, so print is not available to CircleMod and is therefore \nnot checked again for exhaustiveness and unambiguity. If a Circle instance is passed to bad, however, \nprint will be invoked, causing a match nonexhaustive error. Our example is purposely similar to the print \nexample in .gure 6. In that case, the ITC requirements ensure that the problem is mod\u00adularly detected. \nThe same solution can be used here: a set of decla\u00adrations can be safely hidden if that set could have \nbeen written as a separate module that passes modular ITC [23]. The print function in .gure 12 does not \nsatisfy this condition. If print were in its own module, the type system would force the existence of \na global default case for print, which is now an external function. If print had such a case, then the \nfunction (and that case) could be safely hidden via signature ascription, and the problem for Circle \nwould be resolved. Aside from hiding entire declarations, it is useful to hide certain properties of \na declaration. Several properties of classes may be hidden. First, a subset of a class s instance variables \nmay be hid\u00adden. As mentioned in section 4, instance variables are scoped structure PointMod = struct \n abstract class Point() fun draw:Point . unit end signature APointSig = sig class APoint(x:int,y:int) \nextends Point of {x:int,y:int} extend fun draw (APoint {x=x,y=y}) end functor Colorize(M:APointSig) = \nstruct class ColorPoint(x:int,y:int,color:int) extends M.APoint(x,y) of {color:int=color} extend fun \ndraw (ColorPoint {x=x,y=y,color=color})= ... fun getColor:ColorPoint . int extend fun getColor (ColorPoint \n{x=x,y=y,color=color}) = color end Figure 13. Idioms involving EML functors. the name of the structure \ndeclaring an instance variable is implic\u00aditly part of the name of the instance variable. Therefore, there \nis no con.ict if a subclass in a new module creates an instance variable of the same name as a hidden \none in the superclass. A concrete class can also be viewed as an abstract one, thereby disallowing clients \nfrom instantiating the class. Finally, a signature can declare a class C sealed [29], which prevents \nclasses declared outside of C s module from directly subclassing C. This construct can be used to faithfully \nmodel ML-style (non-extensible) datatypes. Our modular requirements can be relaxed in the presence of \nsealed hierarchies. For example, if an external function s owner and all available sub\u00adclasses are sealed, \nthen the function need not have a global default case, as in ML. A function may be sealed by ascribing \nit and all associated cases to an ordinary ML-style value speci.cation. Clients may still invoke the \nfunction but its extensibility is hidden, so clients may not add new cases. Therefore, function sealing \nallows us to model ML-style (non-extensible) functions. Function sealing is allowed under the same circumstances \nthat the function and its cases may be hidden. Finally, a speci.cation of the form val I : t may be replaced \nby val I : t', where t' is a supertype of t. Several forms of information hiding are not captured by \nour ascrip\u00adtion rules. It would be useful to ascribe a class declaration to one that speci.es only a \ntransitive, rather than direct, superclass. Unfor\u00adtunately, this .exibility makes modular ITC unsound. \nFor example, a client of two classes C and C ' can write ambiguous function cases that appear to be disjoint, \nand therefore pass static checks, if the fact that C subclasses C ' is hidden from the client. It would \nalso be useful to ascribe a class declaration to a type declaration, possibly augmented with Modula-3-style \npartial revelations [24] to reveal some of the class s underlying structure. 5.3 Functors In the presence \nof EML s features, functors can provide a great deal of .exibility. Figure 13 illustrates the kinds of \nidioms we would like to express. The Colorize functor implements a form of mixin [4, 11, 14], which is \na class parameterized by its superclass. The functor creates a colored version of some unknown subclass \nAPoint of Point. An overriding case for the existing draw func\u00adtion is given, in order to draw colored \npoints specially. The functor also introduces a new function for accessing the color of a colored point, \nwith an associated case. We would like to perform modular ITC once on a functor body, guaranteeing completeness \nand unambiguity of all relevant func\u00adtions no matter how the functor is instantiated. The major challenge \nfor modular ITC of functors like Colorize is the fact that the iden\u00adtities of some classes, for example \nM.APoint, are unknown. Instead we have only partial information about the relationship between M.APoint \nand other classes. To address this challenge, we can generalize the subclass relation in the static semantics \nto be three\u00advalued, conservatively saying don t know when the partial class hierarchy information is \ninconclusive. We then appropriately gen\u00aderalize modular ITC to be conservative with respect to three-valued \nsubclassing. Consider performing ITC on the body of Colorize. Although the identity of M.APoint is unknown, \nits relationship to ColorPoint is known, and this is enough information for modular ITC on draw to succeed. \nWe have formalized this three-valued se\u00admantics in an earlier version of MINI-EML but have not proven \nit sound. The restrictions on signature ascription described earlier limit the expressiveness of our \nColorize functor. For example, the functor can only be instantiated with a class APoint that is a direct \nsub\u00adclass of Point, rather than a transitive one. Also, APoint s mod\u00adule must contain a draw case with \nexactly the pattern described in APointSig, and the module can have no other draw cases for APoint (e.g. \na special case to handle the origin). However, we can safely remove these restrictions if we are willing \nto move some of the burden of ITC to clients of the functor. For example, we can al\u00adlow APointto be instantiated \nwith a transitive subclass of Pointon the condition that the resulting structure passes modular ITC. \nIn the limit, this approach performs modular ITC once per instantiation of the functor, where the identities \nof all classes are known, rather than once on the functor body. However, it is possible that most of \nITC could still be performed on the functor body in isolation, with only a few additional checks performed \nper instantiation.  6 Related Work OML [27] and ML= [3] were described earlier. Zenger and Oder\u00adsky \n[30] describe an extensible datatype mechanism in the context of an OO language. Extending a datatype \nhas the effect of creat\u00ading a new datatype that subtypes from the original one. To ensure exhaustiveness \nin the presence of datatype extension, all functions on extensible datatypes must include a global default \ncase, while EML often requires only local defaults. Because Zenger s functions are not extensible, if \nnew data variants require overriding function cases, a new function must be created that inherits the \nexisting func\u00adtion cases and clients must be modi.ed to invoke the new function. Like OML, Zenger s language \nincludes both OO-style methods and ML-style functions. Zenger s language also retains a distinction be\u00adtween \ndatatype cases and regular OO classes. Because Zenger s language supports subtyping between entire datatypes \n(rather than individual variants), it can provide more precise types than EML. Garrigue shows how to \nuse polymorphic variants, which are vari\u00adants de.ned independent of any particular datatype, to obtain \nboth modular data-variant and function extensibility in ML [15]. How\u00adever, unlike EML, both kinds of \nextensibility require advance plan\u00adning. When de.ning a type as a set of polymorphic variants, an extra \ntype parameter must be used in place of recursive references to the type, to allow for future extension. \nSimilarly, a function must take an extra parameter function to invoke in place of recursive ref\u00aderences. \nAs in Zenger s language, when a function is extended any clients that require the new functionality must \nbe modi.ed. Unlike EML, polymorphic variants preserve ML-style type inference. Previous work on unifying \nfunctional and OO dispatching [10] pro\u00advides ITC for patterns that are more general than those in EML, \nin\u00adcluding conjunctions, disjunctions, and negations of arbitrary pred\u00adicates. However, the ITC algorithm \nrequires access to the entire program. Jiazzi [20], a component system for Java, addresses issues of \nsig\u00adnature ascription and parameterized modules in the context of a tra\u00additional OO language. Jiazzi \ndisallows hiding abstract methods be\u00adcause of problems analogous to the one shown in .gure 12. Jiazzi \nalso restricts the hiding of a superclass relationship, like EML,but Jiazzi allows such hiding if the \nsuperclass itself is also hidden. EML and Jiazzi each have challenges for information hiding that have \nno analogue in the other system: EML s unique challenges arise from its generalization of OO and functional \ndispatching semantics, and Jiazzi s unique challenges arise from cyclic linking. EML s modular requirements \nare adapted from our previous work on Dubious [22, 23], a multimethod-based OO calculus supporting modular \ntypechecking. In EML, we have generalized the require\u00adments to .t an ML context and have also substantially \nsimpli.ed both their informal and formal presentations. The notion of mod\u00adularity in Dubious is coarser \nthan EML s static dependency rela\u00adtion: a Dubious module requires access to more of the program to soundly \nperform ITC than does an EML module. Dubious does not consider patterns, polymorphism, or ML-style modules. \n 7 Conclusions and Future Work We described Extensible ML, an ML-like language that supports hierarchical, \nextensible datatypes and functions. Such constructs allow for the easy addition of both new data variants \nand new op\u00aderations to existing abstractions, resolving a long-standing tension between the functional \nand object-oriented styles. At the same time, EML retains completely modular typechecking of function \nimple\u00admentations. This contrasts with previous languages based on ex\u00adtensible datatypes and functions, \nwhich require link-time checks to ensure type safety. We have formalized EML in MINI-EML and proven its \ntype system sound. There are several directions for future work. We have built a pro\u00adtotype interpreter \nfor the core of EML, and we plan to pursue case studies to gauge the utility of our modular type system \nin prac\u00adtice. Currently EML does not allow aliasing of classes or extensible functions. A general approach \nto handling aliasing would allow classes and extensible functions to be less second-class. Finally, more \nwork is needed to integrate EML with ML-style modules, par\u00adticularly functors. We will pursue the ideas \npresented in section 5, formalize this extension in MINI-EML, and implement it in our in\u00adterpreter. \n8 Acknowledgments Thanks to Jonathan Aldrich, Sorin Lerner, and Vass Litvinov for helpful comments on \nthe paper. This work was supported in part by NSF grant CCR-9970986, NSF Young Investigator Award CCR\u00ad9457767, \ngifts from Sun Microsystems and IBM, and a Wilma Bradley Graduate Fellowship.  References [1] K. Arnold, \nJ. Gosling, and D. Holmes. The Java Programming Lan\u00adguage Third Edition. Addison-Wesley, Reading, MA, \nthird edition, 2000. [2] D. Bonniot. Type-checking multi-methods in ML (a modular ap\u00adproach). In The \nNinth International Workshop on Foundations of Object-Oriented Languages, FOOL 9, Portland, Oregon, USA, \nJan\u00aduary 2002. [3] F. Bourdoncle and S. Merz. Type-checking higher-order polymorphic multi-methods. In \nConference Record of POPL 97: The 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Lan\u00adguages, \npages 302 315, Paris, France, 15 17 Jan. 1997. [4] G. Bracha and W. Cook. Mixin-based inheritance. In \nECOOP/OOPSLA 90, pages 303 311, 1990. [5] L. Cardelli. A semantics of multiple inheritance. Information \nand Computation, 76(2/3):138 164, Feb. 1988. Also appeared in Seman\u00adtics of Data Types, LNCS 173, 1984. \n[6] G. Castagna, G. Ghelli, and G. Longo. A calculus for overloaded functions with subtyping. Information \nand Computation, 117(1):115 135, Feb. 1995. A preliminary version appeared in ACM Conference on LISP \nand Functional Programming, June 1992 (pp. 182 192). [7] C. Chambers. Object-oriented multi-methods in \nCecil. In O. L. Mad\u00adsen, editor, ECOOP 92, European Conference on Object-Oriented Programming, Utrecht, \nThe Netherlands, volume 615 of Lecture Notes in Computer Science, pages 33 56. Springer-Verlag, New York, \nNY, 1992. [8] C. Chambers and G. T. Leavens. Typechecking and modules for mul\u00adtimethods. ACM Transactions \non Programming Languages and Sys\u00adtems, 17(6):805 843, Nov. 1995. [9] W. R. Cook. Object-oriented programming \nversus abstract data types. In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, Foundations \nof Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume \n489 of Lecture Notes in Computer Science, pages 151 178. Springer-Verlag, New York, NY, 1991. [10] M. \nErnst, C. Kaplan, and C. Chambers. Predicate dispatching: A uni\u00ad.ed theory of dispatch. In E. Jul, editor, \nECOOP 98 Object-Oriented Programming, volume 1445 of Lecture Notes in Computer Science, pages 186 211. \nSpringer, 1998. [11] R. B. Findler and M. Flatt. Modular object-oriented programming with units and mixins. \nIn Proceedings of the ACM SIGPLAN Inter\u00adnational Conference on Functional Programming (ICFP 98), volume \n34(1) of ACM SIGPLAN Notices, pages 94 104. ACM, June 1998. [12] K. Fisher and J. Reppy. The design of \na class mechanism for MOBY. In Proceedings of the ACM SIGPLAN 99 Conference on Program\u00adming Language \nDesign and Implementation, pages 37 49, Atlanta, Georgia, May 1 4, 1999. [13] K. Fisher and J. Reppy. \nExtending Moby with inheritance-based sub\u00adtyping. In 14th European Conference on Object-Oriented Program\u00adming, \nvolume 1850 of Lecture Notes in Computer Science, pages 83 107, June 2000. [14] M. Flatt, S. Krishnamurthi, \nand M. Felleisen. Classes and mixins. In Conference Record of POPL 98: The 25TH ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages, San Diego, California, pages 171 183, New York, NY, 1998. [15] \nJ. Garrigue. Code reuse through polymorphic variants. In Workshop on Foundations of Software Engineering, \nNovember 2000. [16] J. Gosling, B. Joy, G. Steele, and G. Bracha. The Java Language Spec\u00adi.cation Second \nEdition. The Java Series. Addison-Wesley, Boston, Mass., 2000. [17] A. Igarashi, B. C. Pierce, and P. \nWadler. Featherweight Java: a min\u00adimal core calculus for Java and GJ. ACM Transactions on Program\u00adming \nLanguages and Systems, 23(3):396 450, May 2001. [18] S. Kahrs, D. Sannella, and A. Tarlecki. The de.nition \nof extended ML: A gentle introduction. Theoretical Computer Science, 173(2):445 484, 28 Feb. 1997. [19] \nS. Krishnamurthi, M. Felleisen, and D. P. Friedman. Synthesizing object-oriented and functional design \nto promote re-use. In E. Jul, edi\u00adtor, ECOOP 98 Object-Oriented Programming, 12th European Con\u00adference, \nBrussels, Belgium, volume 1445 of Lecture Notes in Com\u00adputer Science, pages 91 113. Springer-Verlag, \nJuly 1998. [20] S. McDirmid, M. Flatt, and W. C. Hsieh. Jiazzi: new-age components for old-fashioned \njava. In Proceedings of the OOPSLA 01 conference on Object Oriented Programming Systems Languages and \nApplica\u00adtions, pages 211 222. ACM Press, 2001. [21] T. Millstein, C. Bleckner, and C. Chambers. Modular \ntypecheck\u00ading for hierarchically extensible datatypes and functions. Tech\u00adnical Report UW-CSE-02-07-05, \nDepartment of Computer Sci\u00adence and Engineering, University of Washington, July 2002. ftp://ftp.cs.washington.edu/tr/2002/07/UW-CSE-02-07-05.pdf. \n[22] T. Millstein and C. Chambers. Modular statically typed multimethods. In R. Guerraoui, editor, ECOOP \n99 Object-Oriented Programming 13th European Conference, Lisbon Portugal, volume 1628 of Lecture Notes \nin Computer Science, pages 279 303. Springer-Verlag, New York, NY, June 1999. [23] T. Millstein and C. \nChambers. Modular statically typed multimethods. Information and Computation, 175(1):76 118, May 2002. \n[24] G. Nelson. Systems Programming with Modula-3. Prentice Hall, 1991. [25] M. Odersky and P. Wadler. \nPizza into Java: Translating theory into practice. In Conference Record of POPL 97: The 24th ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Lan\u00adguages, pages 146 159, Paris, France, 15 17 Jan. 1997. [26] \nD. R\u00b4emy and J. Vouillon. Objective ML: An effective object-oriented extension of ML. Theory and Practice \nof Object Systems, 4(1):27 52, 1998. [27] J. Reppy and J. Riecke. Simple objects for Standard ML. In \nPro\u00adceedings of the ACM SIGPLAN 96 Conference on Programming Language Design and Implementation, pages \n171 180, Philadelphia, Pennsylvania, 21 24 May 1996. [28] J. C. Reynolds. User de.ned types and procedural \ndata structures as complementary approaches to data abstraction. In D. Gries, editor, Programming Methodology, \nA Collection of Articles by IFIP WG2.3, pages 309 317. Springer-Verlag, New York, NY, 1978. [29] A. Shalit. \nThe Dylan Reference Manual: The De.nitive Guide to the New Object-Oriented Dynamic Language. Addison-Wesley, \nReading, Mass., 1997. [30] M. Zenger and M. Odersky. Extensible algebraic datatypes with de\u00adfaults. In \nProceedings of the 2001 ACM SIGPLAN International Con\u00adference on Functional Programming. ACM, September \n3-5 2001. \n\t\t\t", "proc_id": "581478", "abstract": "One promising approach for adding object-oriented (OO) facilities to functional languages like ML is to generalize the existing datatype and function constructs to be hierarchical and extensible, so that datatype variants simulate classes and function cases simulate methods. This approach allows existing datatypes to be easily extended with both new operations and new variants, resolving a long-standing conflict between the functional and OO styles. However, previous designs based on this approach have been forced to give up <i>modular</i> typechecking, requiring whole-program checks to ensure type safety. We describe Extensible ML (<sc>eml</sc>), an ML-like language that supports hierarchical, extensible datatypes and functions while preserving purely modular typechecking. To achieve this result, <sc>eml</sc>'s type system imposes a few requirements on datatype and function extensibility, but <sc>eml</sc> is still able to express both traditional functional and OO idioms. We have formalized a core version of <sc>eml</sc> and proven the associated type system sound, and we have developed a prototype interpreter for the language.", "authors": [{"name": "Todd Millstein", "author_profile_id": "81100018064", "affiliation": "University of Washington", "person_id": "PP14019523", "email_address": "", "orcid_id": ""}, {"name": "Colin Bleckner", "author_profile_id": "81100565828", "affiliation": "University of Washington", "person_id": "P394760", "email_address": "", "orcid_id": ""}, {"name": "Craig Chambers", "author_profile_id": "81100528252", "affiliation": "University of Washington", "person_id": "PP39047060", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/581478.581489", "year": "2002", "article_id": "581489", "conference": "ICFP", "title": "Modular typechecking for hierarchically extensible datatypes and functions", "url": "http://dl.acm.org/citation.cfm?id=581489"}