{"article_publication_date": "09-09-2012", "fulltext": "\n Transporting Functions across Ornaments Pierre-Evariste Dagand Conor McBride Mathematically Structured \nProgramming group University of Strathclyde {dagand,conor}@cis.strath.ac.uk Abstract Programming with \ndependent types is a blessing and a curse. It is a blessing to be able to bake invariants into the de.nition \nof datatypes: we can .nally write correct-by-construction software. However, this extreme accuracy is \nalso a curse: a datatype is the combination of a structuring medium together with a special pur\u00adpose \nlogic. These domain-speci.c logics hamper any effort of code reuse among similarly structured data. In \nthis paper, we exorcise our datatypes by adapting the notion of ornament to our universe of inductive \nfamilies. We then show how code reuse can be achieved by ornamenting functions. Using these functional \nornaments, we capture the relationship between functions such as the addition of natural numbers and \nthe concatenation of lists. With this knowl\u00adedge, we demonstrate how the implementation of the former \nin\u00adforms the implementation of the latter: the user can ask the de.\u00adnition of addition to be lifted to \nlists and she will only be asked the details necessary to carry on adding lists rather than numbers. \nOur presentation is formalised in a type theory with a universe of datatypes and all our constructions \nhave been implemented as generic programs, requiring no extension to the type theory. Categories and \nSubject Descriptors D.1.1 [Programming Tech\u00adniques]: Applicative (Functional) Programming Keywords Dependent \ntypes, Datatype, Ornament 1. Introduction Imagine designing a library for a ML-like language. For instance, \nwe start with natural numbers and their operations, then we move to binary trees, then rose trees, etc. \nIt is the garden of Eden: datatypes are data-structures, each coming with its optimised set of opera\u00ad \nprogrammer can enforce invariants on top of the data-structures. In such a system, programmers strive \nto express the correctness of programs in their types: a well typed program is correct by con\u00adstruction, \nthe proof of correctness being reduced to type-checking. A simple yet powerful recipe to obtain these \nricher datatypes is to index the data-structure. These datatypes have originally been studied in the \ncontext of type theory under the name of inductive families [Dybjer 1994; Morris et al. 2009]. Inductive \nfamilies made it to mainstream functional programming with Generalised Alge\u00adbraic Data-Types [Xi et al. \n2003], a subset of inductive families for which type inference is decidable. Re.nement types [Freeman \nand Pfenning 1991; Swamy et al. 2011] are another technique to equip data-structures with rich invariants. \nAtkey et al. [2011] have shown how re.nement types relate to inductive families, and Bernardy and Lasson \n[2011] establish a connection with realisability. However, these carefully crafted datatypes are a threat \nto any library design: the same data-structure is used for logically incom\u00adpatible purposes. This explosion \nof specialised datatypes is over\u00adwhelming: these objects are too specialised to .t in a global library. \nYet, because they share this common structure, many operations on them are extremely similar, if not \nexactly the same. To address this issue, McBride [2012] developed ornaments, describing how one datatype \ncan be enriched into others with the same structure. Such structure-preserving transformations take two \nforms: one can extend the initial type with more information such as obtaining MaybeA from Bool or ListA \nfrom Nat: data Bool: SET where data Nat: SET where Bool 3 true Nat 3 0 | false | suc (n :Nat) . . Maybe-OrnList-Orndata \nMaybe [A: SET ]: SET where data List [A: SET]: SET where MaybeA 3 just (a :A) ListA 3 nil tions. If, \ntempted by a snake, we move to a language with richer datatypes, such as a dependently typed language, \nwe enter the Augean stables. Where we used to have binary trees, now we have complete binary trees, red-black \ntrees, AVL trees, and countless other variants. Worse, we have to duplicate code across these tree\u00adlike \ndatatypes: because they are de.ned upon this common binarily branching structure, a lot of computationally \nidentical operations | nothing | cons (a :A)(as :ListA) Or one can re.ne the indexing of the initial \ntype by a .ner disci\u00adpline e.g., obtaining Fin by indexing Nat with a bound n: data Nat: SET where Nat \n3 0 | suc (n :Nat) will have to be duplicated for the type-checker to be satis.ed. Since the ML days, \ndatatypes have evolved: besides provid\u00ading an organising structure for computation, they are now offering \nmore control over what is a valid result. With richer datatypes, the Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation . Fin-Orn data Fin (n :Nat): SET where Fin (n = suc n') 3 f0 (n' :Nat) ' | fsuc \n(n:Nat)(fn :Fin n') One can also do both at the same time such as extending Nat into a ListA while re.ning \nthe index to match the length of the list: data Nat: SET where Nat 3 0 | suc (n :Nat) on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. ICFP 12, September 9 15, 2012, Copenhagen, Denmark. Copyright &#38;#169; 2012 \nACM 978-1-4503-1054-3/12/09 $15.00. . Vec-Orn data Vec [A: SET ](n :Nat): SET where VecA (n = 0) 3 nil \n' VecA (n = suc n') 3 cons (n:Nat)(a :A)(vs :VecA n')  Note that we declare datatype parameters [A : \nSET] in brackets (m :Nat) < (n :Nat): Bool and datatype indices (n : Nat) in parentheses. We make equational \nm < 0 . false constraints on the latter only when needed, and explicitly. 0 < suc n . true Because of \ntheir constructive nature, ornaments are not merely suc m < suc n . m < n identifying similar structures: \nthey give an effective recipe to build =. new datatypes from old, guaranteeing by construction that the \nstructure is preserved. Hence, we can obtain a plethora of new ? lookup (m :Nat)(xs :ListA): MaybeA datatypes \nwith minimal effort. Whilst we now have a good handle on the transformation of individual datatypes, \nwe are still facing a major reusability issue: a datatype often comes equipped with a set of operations. \nOrnamenting this datatype, we have to entirely re-implement many similar operations. For example, the \ndatatype Nat comes with operations such as addition and subtraction. When de.ning ListA as an ornament \nof Nat, it seems natural to trans\u00adport some structure-preserving function of Nat to ListA, such as moving \nfrom addition of natural numbers to concatenation of lists: lookup m nil . nothing lookup 0 (cons a xs) \n. just a lookup (suc n)(cons a xs) . lookup n xs Figure 1. Implementation of < and lookup This paper \nis an exercise in constructive mathematics: upon (m :Nat)+(n :Nat): Nat identifying an isomorphism, we \nshall look at it with our construc\u00ad 0 + n . n tive glasses and obtain an effective procedure that lets \nus cross the (suc m)+ n . suc (m + n) isomorphism. In this paper, we put a strong emphasis on the pro\u00ad \n. (xs :ListA) ++(ys :ListA): ListA nil ++ ys . ys (cons a xs) ++ ys . cons a (xs ++ ys) Or moving from \nsubtraction of natural numbers to dropping the pre.x of a list: (m :Nat) - (n :Nat): Nat 0 - n . 0 m \n- 0 . m (suc m) - (suc n) . m - n gramming aspect: we shall only hint at the isomorphisms through concrete \nexamples and let the reader consult the companion techni\u00adcal report for the actual mathematical proofs. \nWe shall write our code in a syntax inspired by the Epi\u00adgram [McBride and McKinna 2004] programming language. \nIn particular, we make use of the by ( . ) and return ( . ) program\u00adming gadgets, further extending them \nto account for the automatic lifting of functions. For brevity, we write pattern-matching de.ni\u00adtions \nwhen the recursion pattern is evident and unremarkable. We shall also make ample use of mathematical \nnotations and symbols in the programming language itself (in particular, mix.x opera\u00adtors), hence appealing \nto our reader s eye for mathematics, rather . drop (xs :ListA)(n :Nat): ListA than to the intricate details \nof a particular formal syntax. Like ML, unbound variables in type de.nitions are universally quanti.ed, \nfurther abating syntactic noise. The syntax of datatype de.nitions drop nil n . nil . xs draws upon \nthe ML tradition as well: its novelty will be presented drop xs 0 drop (cons a xs)(suc n) . drop xs n \nMore interestingly, the function we start with may involve sev\u00aderal datatypes, each of which may be ornamented \ndifferently. In this paper, we develop the notion of functional ornament as a generali\u00adsation of ornaments \nto functions: We adapt ornaments to our universe of datatypes [Chapman et al. 2010] in Section 3. This \npresentation bene.ts greatly from our ability to inspect indices when de.ning datatypes. This allows \nus to consider ornaments which delete index-determined information, yielding a key simpli.cation in the \nconstruction of an algebraic ornament from an ornamental algebra ;  We describe how functions can be \ntransported through func\u00adtional ornaments: deletion allows us a contrasting approach to Ko and Gibbons \n[2011], internalising proof obligations. First, we manually work through an example in Section 2. Then, \nwe formalise the concept of functional ornament by a universe con\u00adstruction in Section 4. Based on this \nuniverse, we establish the connection between a base function (such as + and - ) and its ornamented version \n(such as, respectively, ++ and drop). Within this framework, we redevelop the example of Section 2 with \nall the automation offered by our constructions ;  In Section 5, we provide further support to drive \nthe computer into lifting functions semi-automatically. As we can see from our examples above, the lifted \nfunctions often follow the same recursion pattern and return similar constructors: with a few generic \nconstructions, we shall remove further clutter and code duplication from our libraries.  by way of examples \nin Section 3. All the constructions presented in this paper have been modelled in Agda, using only standard \ninduc\u00adtive de.nitions and two levels of universe. The formalisation and technical report are available \non Dagand s website. 2. From < to lookup, manually There is an astonishing resemblance between the comparison \nfunc\u00adtion < on natural numbers and the list lookup function (Fig. 1). The similarity is not merely at \nthe level of types but also in their implementation: their de.nitions follow the same pattern of recur\u00adsion \n(.rst, case analysis on the second element; then induction on the .rst element) and they both return \na failure value (false and nothing respectively) in the .rst case analysis and a success value (true \nand just respectively) in the base case of the induction. This raises the question: what exactly is the \nrelation between < and lookup? Also, could we use the implementation of < to guide the construction of \nlookup? First, let us work out the relation at the type level. To this end, we use ornaments to explain \nhow each individual datatype has been promoted when going from < to lookup: < lookup idO: : Nat Nat Nat \nList\u00ad. . Nat ListA Orn Maybe. . Bool MaybeA -Orn Note that the .rst argument is ornamented to itself, \nor put differ\u00adently, it has been ornamented by the identity ornament.  Each of these ornaments come \nwith a forgetful map, computed from the ornamental algebra: length (as :ListA): Nat isJust (m :MaybeA): \nBool length nil . 0 isJust nothing . false length (cons a as) . suc (length as) isJust (just a) . true \nUsing these forgetful map, the relation, at the computational level, between < and lookup is uniquely \nestablished by their orna\u00admentation. This relation is captured by the coherence property: .n :Nat..xs \n:ListA. isJust (lookup n xs) = n < length xs. Let us settle the vocabulary at this stage. We call the \nfunction we start with the base function (here, < ), its type being the base type (here, Nat . Nat . \nBool). The richer function type built by ornamenting the individual pieces is called the functional ornament \n(here, Nat . ListA . MaybeA). A function inhabiting this type is called a lifting (here, lookup). A lifting \nis said to be coherent if it satis.es the coherence property. It is crucial to understand that the coherence \nof a lifting is relative to a given functional ornament: the same base function ornamented differently \nwould give rise to different coherence properties. We now have a better grasp of the relation between \nthe base function and its lifting. However, lookup remains to be imple\u00admented while making sure that \nit satis.es the coherence property. Traditionally, one would stop here: one would implement lookup and \nprove the coherence as a theorem. This works rather well in a system like Coq [The Coq Development Team] \nas it offers a pow\u00aderful theorem proving environment. It does not work so well in a system like Agda \n[Norell 2007] that does not offer tactics to its users, forcing them to write explicit proof terms. It \nwould not work at all in Haskell with GADTs, which has no notion of proof. However, we are not satis.ed \nby this laborious approach: if we have dependent types, why should we use them only for proofs, as an \nafterthought? We should rather write a lookup function correct by construction: by implementing a more \nprecisely indexed ver\u00adsion of lookup, the user can drive the index-level computations to unfold, hence \nmaking the type-checker verify the necessary invari\u00adants. We believe that this is how it should be: computers \nshould replace proofs by computation; humans should drive computers. The other way around where humans \nare coerced into computing for computers may seem surreal, yet it corresponds to the current situation \nin most proof systems. To get the computer to work for us, we would rather implement the function ilookup: \nilookup (m :Nat)(vs :VecA n): IMaybeA (m < n) ilookup m nil . nothing ilookup 0 (cons a vs) . just a \nilookup (suc m)(cons a vs) . ilookup m vs Where IMaybeA is MaybeA indexed by its truth as computed by \nisJust. It is de.ned as follows1: data IMaybe [A: SET ](b :Bool): SET where IMaybeA true 3 just (a :A) \nIMaybeA false 3 nothing This comes with the following forgetful map: forgetIMaybe (mba :IMaybeA b):(ma \n:MaybeA) \u00d7 isJust ma = b forgetIMaybe (just a) . (just a, re.) forgetIMaybe nothing . (nothing, re.) \n The rationale behind ilookup is to index the types of lookup by their unornamented version, i.e. the \narguments and result of < . Hence, we can make sure that the result computed by ilookup respects the \noutput of < on the unornamented indices: the result is correct by indexing! The type of ilookup is naturally \nderived from 1 Note that we have overloaded the constructors of Maybe and IMaybe: for a bi-directional \ntype-checker, there is no ambiguity as constructors are checked against their type. the ornamentation \nof < into lookup and is uniquely determined by the functional ornament we start with. Expounding further \nour vocabulary, we call coherent liftings these .nely indexed functions that are correct by construction. \nKo and Gibbons [2011] use ornaments to specify the coherence requirements for functional liftings, but \nwe work the other way around, using ornaments to internalise coherence requirements. From ilookup, we \ncan extract both lookup and its proof of cor\u00adrectness without having written any proof term ourselves: \nlookup (m :Nat)(xs :ListA): MaybeA lookup m xs . p0(forgetIMaybe (ilookup m (makeVec xs))) cohLookup \n(n :Nat)(xs :ListA): isJust (lookup n xs) = n < length xs cohLookup m xs . p1(forgetIMaybe (ilookup m \n(makeVec xs))) where makeVec :(xs : ListA) . VecA (length xs) simply turns a list into a vector of the \ncorresponding length. With this example, we have manually unfolded the key steps of the construction \nof a lifting of < . Let us recapitulate each steps: Start with a base function, here < : Nat . Nat . \nBool  Ornament its inductive components as desired, here Nat to ListA and Bool to MaybeA in order to \ndescribe the desired lifting, here lookup : Nat . ListA . MaybeA satisfying .n : Nat..xs : ListA. isJust \n(lookup n xs) = n < length xs  Implement a carefully indexed version of the lifting, here  ilookup \n:(m :Nat)(vs :VecA n) . IMaybeA (m < n) Derive the lifting, here lookup, and its coherence proof, without \nproving any theorem This manual unfolding of the lifting is instructive: it involves a lot of constructions \non datatypes (here, the datatypes ListA and MaybeA) as well as on functions (here, the type of ilookup, \nthe de.nition of lookup and its coherence proof). Yet, it feels like a lot of these constructions could \nbe automated. In the next Section, we shall build the machinery to describe these constructions and obtain \nthem within the type theory itself. 3. A universe of datatypes and their ornaments In dependently typed \nsystems such as Coq or Agda, datatypes are an external entity: each datatype de.nition extends the type\u00adtheory \nwith new introduction and elimination forms. The validity of datatypes is guaranteed by a positivity-checker \nthat is part of the meta-theory of the proof system. A consequence is that, from within the type theory, \nit is not possible to create or manipulate datatype de.nitions, as they belong to the meta-theory. 3.1 \nA closed theory of datatypes In our previous work [Chapman et al. 2010], we have shown how to internalise \ninductive families into type theory. The practical impact of this approach is that we can manipulate \ndatatype declarations as .rst-class objects. We can program over datatype declarations and, in particular, \nwe can compute new datatypes from old. This is particularly useful to formalise the notion of ornament \nentirely within the type theory. This also has a theoretical impact: we do not need to prove meta-theoretical \nproperties of our constructions, we can work in our type theory and use its logic as our formal system. \nNote that our results are not restricted to this setting where datatype de.nitions are internalised: \nall our constructions could be justi.ed at the meta-level and then be syntactically presented in a language, \nsuch as, say, Agda, Coq, or Haskell with GADTs. Working with an internalised presentation, we can simply \navoid these two levels of logic and work in the logic provided by the type theory itself.  data IDesc \n[I : SET ]: SET1 where IDesc I 3 var (i :I ) Secondly, indexed datatypes can be de.ned following the \nAgda | 1 convention: indices are constrained to some particular value. For | .(S : SET )(T :S . IDesc \nI ) example, Vec could be de.ned by constraining the index to be 0 in | S(S : SET )(T :S . IDesc I ) \n'' the nil case and suc n for some n :Nat in the cons case: [(D :IDesc I )] (X :I . SET ): SET data Vec \n[A: SET ](n :Nat): SET where [ var i] X . Xi VecA (n = 0) 3 nil ' VecA (n = suc n ' ) 3 cons (n :Nat)(a \n:A)(vs :VecA n ' ) . 1 [ 1] X [ . ST ] X . (s :S) . [Ts] X i [ S ST ] X . (s :S) \u00d7 [Ts] X Vec-Desc (A: \nSET )(n :Nat): IDesc Nat vnil Vec-Desc An . .. .. Figure 2. Universe of inductive families nil . S(n \n= 0) . . 1 ' . S(n = suc n ' ). . vcons . S Nat .n S cons .. ' S A . . var n For the sake of completeness, \nlet us recall a few de.nitions and results from our previous work. As in previous work, our requirements \non the type theory are minimal: we will need S-, .\u00adtypes, and at least two universes. For convenience, \nwe require a type of .nite sets, which lets us build collections of labels2. We also need a pre-existing \nnotion of propositional equality, upon which we make no assumption. We internalise the inductive families \nby a universe construction (Fig. 2): an indexed datatype is described by a function from its index to \ncodes. The codes are then interpreted to build the .x-point: data \u00b5 [D :I . IDesc I ](i :I ): SET where \n\u00b5 Di 3 in (xs :[Di] (\u00b5 D)) For readability purposes, we use an informal notation to declare datatypes. \nThis notation is strongly inspired by Agda s datatype declarations. Note that these de.nitions can always \nbe turned into IDesc codes: when de.ning a datatype T , we will denote T -Desc the code it elaborates \nto. Similarly, we denote T -elim and T -case the induction principle and case analysis operators associated \nwith T . For instance, Nat-case corresponds to case analysis over natu\u00adral numbers (either 0 or suc) \nwhile Nat-elim corresponds to stan- The elaboration naturally captures the constraints on indices by \nusing propositional equality. In the case of Vec, we .rst abstract over the index n, introduce the choice \nof constructors with the .rst S and then, once constructors have been chosen, we restrict n to its valid \nvalue(s): 0 in the .rst case and suc n ' for some n ' in the second case. Hence the placement of the \nequality constraints in the above de.nition: after the constructor is chosen, we .rst introduce a fresh \nvariable and then constrain the index with it. If no fresh variable needs to be introduced, we directly \nconstrain the index. Thirdly, we can compute over indices: here, we make use of the crucial property \nthat a datatype de.nition is a function from index to IDesc codes. Hence, our notation should re.ect \nthis ability to de.ne datatypes as functions on their index. For instance, inspired by Brady et al. [2004], \nan alternative presentation of vector would match on the index to determine the constructor to be presented, \nhence removing the need for constraints: data Vec [A: SET](n :Nat): SET where VecA n . Nat-case n VecA \n0 3 nil VecA (suc n) 3 cons (a :A)(vs :VecA n) dard induction on natural numbers. These operations can \nbe imple\u00admented by generic programming, along the lines of McBride et al. [2004]. Formalising the elaboration \nof datatypes de.nitions down to code is beyond the scope of this paper. However, it is simple i Vec-Desc \n(A: SET )(n :Nat): IDesc Nat Vec-Desc An . Nat-case n (. . IDesc Nat) 1 enough to be understood with \na few examples. Three key ideas are at play. First, non-indexed datatypes de.nitions follow the ML tradition: \nwe name the datatype and then comes a choice of constructors. For example, List and Brouwer ordinals \nwould be written and elaborated as follows: data List [A: SET]: SET where ListA 3 nil | cons (a :A)(as \n:ListA) i (.n. S A . . var n) In order to be fully explicit about computations, we use here the Epigram \n[McBride and McKinna 2004] by (.) programming gad\u00adget, which let us appeal to any elimination principle \nwith a syn\u00adtax close to pattern-matching. However, standard pattern-matching constructions [Coquand 1992; \nNorell 2007] would work just as well. Again, we shall write pattern-matching de.nitions when the recursion \npattern is unremarkable. Our syntax departs radically from the one adopted by Coq, Agda, and GADTs in \nHaskell. It is crucial to understand that this List-Desc (A: SET )(x :1): IDesc 1 J sJ is but re.ecting \nthe actual semantics of inductive families: we s nil nil . 1 cons cons . S A . . var * can compute over \nindices, not merely constrain them to be what we would like. With our syntax, we give the user the ability \nto write these functions: the reader should now understand a datatype List-Desc A * . S data Ord: SET \nwhere Ord 3 0 de.nition as a special kind of function de.nition, taking indices | suc (o :Ord) as arguments, \npotentially computing over them, and eventually | lim (l :Nat . Ord) emitting a choice of constructors. \ni  3.2 Ornaments .. Ord-Desc (x :1): IDesc 1 0 .. .. .. Originally, McBride [2012] presented the notion \nof ornament for a 0 . 1 universe where the indices a constructor targets could be enforced only by equality \nconstraints. As a consequence, in that simpler Ord-Desc * . S suc suc . var * .... lim lim . . Nat . \n. var * setting, computing types from indices was impossible. We shall 2 We denote .nite sets of tagged \nelements by { x, y, z,...}. Their elimi-now adapt the original de.nition to our setting. nation principle \nconsists of an exhaustive case enumeration and is denoted Just as the original de.nition, an ornament \nis de.ned upon a by { x . vx, y . vy, z . vz, . . .}. If the tags are vertically aligned, base datatype \n speci.ed by a function D : I . IDesc I and we shall skip the separating comma. indices are re.ned up \nto a reindexing function re : J . I. The difference in our setting is that, just as the code of datatypes \ncan be computed from the indices, we want the ornament to be computable from its J-index. Hence, an ornament \nis a function from j : J to ornament codes describing the ornamentation of D (re j): orn(reI :J . I \n)(reO :P . O)(D :O . IDesc I ): SET1 orn reI reO D . (p :P) . Orn reI (D (reO p)) As for the ornament \ncodes themselves, they are similar to the original de.nition: we shall be able to copy the base datatype, \nextend it by inserting sets, or re.ne the indexing subject to the relation imposed by re. However, we \nalso have the J-index in our context: following Brady s insight that inductive families need not store \ntheir indices [Brady et al. 2004], we could as well delete parts of a datatype de.nition as long as we \ncan recover this information from the index. Hence, we obtain the following code3: data Orn [re :J . \nI ](D :IDesc I ): SET1 where Extend with S: Orn re D 3 insert (S : SET )(D+ :S . Orn re D) Re.ne index: \nOrn re ( var i) 3 var (j :re -1 i) Copy the original: Orn re 1 3 1 Orn re ( . ST) 3 .(T + :(s :S) . Orn \nre (Ts)) Orn re ( S ST) 3 S(T+ :(s :S) . Orn re (Ts)) Delete S: | delete (replace:S)(T+ :Orn re (T replace)) \nNote that the recursive structure of the original data-type as speci.ed by . is preserved by the ornament: \nwe have thus ensured, by construction, that the source datatype and its ornament have the same recursive \nstructure. Being able to insert or delete .-quanti.ers would defeat our purpose by making ambiguous the \nconnection between the source datatype and its ornamented form. Given an ornament, we can interpret it \nas the datatype it de\u00adscribes. The implementation consists in traversing the ornament code, introducing \na S when inserting new data and computing the ornament at the replaced value when deleting some redundant \ndata: (o :orn reI reO D)]orn (p :P): IDesc J where [ o]orn p . intOrn (D (reO p)) (op) intOrn(D :IDesc \nI )(O :Orn re D):IDesc J intOrn D (insert SD+) . S S .s. intOrn D (D+ s) intOrn ( var (re j )) ( var \n(inv j )) . var j intOrn 1 1 . 1 intOrn ( . ST)( . T +) . . S .s. intOrn (Ts)(T + s) intOrn ( S ST)( \nS T+) . S S .s. intOrn (Ts)(T+ s) intOrn ( S ST)(delete replace T +) . intOrn (T replace)(T + replace) \nNote that in the delete case, no S code is generated: the set S has been deleted from the original datatype. \nThe witness of this existential is instead provided by replace. Once again, we adopt an informal notation \nto describe orna\u00adments conveniently. The idea is to simply mirror our data de.ni\u00adtion, adding from which \ndatatype the ornament is de.ned. When specifying a constructor, we can then extend it with a new element \nusing [s : S] or delete an element originally named s by giving its value with [s . value]. Some typical \nexamples of extension are presented in Figure 3. While the de.nition Vec in Figure 3 mirrors Agda s convention \nof constraining indices with equality, our de.nition of ornaments lets us de.ne a version of Vec that \ndoes not store its indices: data Vec [A: SET ](n :Nat) from ListA where VecA 0 3 nil VecA (suc n ' ) \n3 cons (a :A)(vs :VecAn ' ) 3 The inverse image of a function is de.ned by: data (-1)[f :A . B](b :B): \nSET where f -1 (b = fa) 3 inv (a :A) data List [A: SET ] from Nat where ListA 3 nil | cons [a :A](as \n:ListA) data Vec [A: SET](n :Nat) from ListA where VecA n 3 nil [q :n = 0] '' | cons [n :Nat][q :n = \nsuc n ](a :A)(vs :VecAn ' ) data Fin (n :Nat) from Nat where ' Fin n 3 f0 [n :Nat][q :n = suc n ' ] ' \n| fsuc [n :Nat][q :n = suc n ' ](fn :Fin n ' ) Figure 3. Examples of ornament Note that such a de.nition \nwas unavailable in the basic presenta\u00adtion [McBride 2012]. Brady et al. [2004] call this operation detag\u00adging: \nthe constructors of the datatype are determined by the index. The de.nition of Fin given in Figure 3 \nis also subject to an opti\u00admisation: by matching the index, we can avoid the duplication of n by deleting \nn ' with the matched predecessor and deleting the re\u00adsulting, obvious proof. Hence, Fin can be further \nornamented to the optimised Fin , which makes crucial use of deletion: data Fin (n :Nat) from Fin where \nFin 0 3 [b :0] no constructor ' Fin (suc n) 3 f0 [n . n][q . re.] ' | fsuc [n . n][q . re.](fn :Fin \nn ' ) Again, this de.nition was previously unavailable to us. Besides, we are making crucial use of the \ndeletion ornament to avoid dupli\u00adcation. Brady et al. [2004] call this operation forcing: the content \nof the constructors here n ' and the constraint are retrieved from the index, instead of being needlessly \nduplicated. Just as the datatype declaration syntax was elaborated to IDesc codes, this high-level syntax \nis elaborated to ornament codes. A for\u00admal description of the translation is beyond the scope of this \npaper. Note that we require the order of constructors to be preserved, as their name might change from \nthe original to the ornamented ver\u00adsion. From the de.nition of an ornamented type T , we will assume \nthe existence of its corresponding ornament code T -Orn. As described by McBride [2012], every ornament \ninduces an or\u00adnamental algebra: intuitively, an algebra that forgets the extra data, hence mapping the \nornamented datatype back to its unornamented form. From an ornament O : orn reD, there is a natural transforma\u00adtion \nfrom the ornamented functor down to the unornamented one, which we denote: O-forgetNat:(X :I . SET )(j \n:J ) . [[O]ornj ](X . re) . [D(rej )]X Applied with \u00b5D for X and post-composed with in, this natural \ntransformation induces the ornamental algebra: O-forgetAlg:(j :J ) . [[O]orn j ] (\u00b5 D . re) . \u00b5 D (re \nj ) In turn, this algebra induces an ornamental forgetful map denoted: O-forget:(j :J) . \u00b5 [O]orn j . \n\u00b5 D (re j ) We do not re-implement these functions here: it is straightforward to update the original \nde.nitions to our setting. 3.2.1 Algebraic ornaments An important class of datatypes is constructed \nby algebraic or\u00adnamentation over a base datatype. The idea of an algebraic or\u00adnament is to index an inductive \ntype by the result of a fold over the original data. From the code D : I . IDesc I and an algebra a :(i \n: I) . [D i] X . X i, there is an ornament that de.nes a code Da :(i : I) \u00d7 X i . IDesc (i : I) \u00d7 X i \nwith the property that: \u00b5Da (i, x) ~ =(t : \u00b5Di) \u00d7 .a. t = x We shall indiscriminately use Da to refer \nto the ornament and the resulting datatype. Seen as a re.nement type, the correctness  property states \nthat \u00b5Da (i, x) ~{t . \u00b5D i | a t = x}. The = type theoretic construction of Da is described by McBride \n[2012]. We shall not reiterate it here, the implementation being essentially the same. A categorical \npresentation is also given in Atkey et al. [2011] that explores the connection with re.nement types. \nConstructively, the correctness property gives us two (mutually inverse) functions. The direction \u00b5Da(i, \nx) . (t :\u00b5 Di) \u00d7 .a. t = x relies on the generic Da-forget function to compute the .rst com\u00adponent of \nthe pair and gives us the following theorem: a coherentOrn:.t:\u00b5Da(i, x). .a. (Da-forget ta) = x This \ncorresponds to the Recomputation theorem of McBride [2012]. We shall not reprove it here, the construction \nbeing similar. In the other direction, the isomorphism gives us a function of type: (t :\u00b5D i) \u00d7 .a. t \n= x . \u00b5Da(i, x) Put in full and simplifying the equation, this corresponds to the function Da-make:(t \n:\u00b5D i) . \u00b5Da(i, .a. t). This corresponds to the remember function of McBride [2012]. Again, we will assume \nthis construction here. A typical use-case of algebraic ornaments is the implementa\u00adtion of semantic-preserving \noperations on syntax trees [McBride 2012]. For example, let us consider arithmetic expressions, which \nsemantics is given by interpretation in Nat: data Expr: SET where aeval (es :[Expr-Desc] Nat): Nat Expr \n3 const (n :Nat) aeval (const n) . n | add (de :Expr) aeval (add mn) . m+n Using the algebra aeval, we \nconstruct the algebraic ornament of Expr and obtain expressions indexed by their semantics: data Expraeval \n(k :Nat): SET where Expraeval (k = n) 3 const (n :Nat) Expraeval (k = m+n) 3 add (mn : Nat) (d : Expraeval \nm)(e : Expraeval n) Hence, we can enforce semantics preservation by typing. For ex\u00adample, let us optimise \naway all additions of the form 0+ e : optimize-0+ (e : Expraeval n): Expraeval n optimize-0+ (const n) \n. const n optimize-0+ (add 0 n (const 0) e) . optimize-0+ e optimize-0+ (add mnde) . add mnde If the \ntype-checker accepts our de.nition, we have that, by con\u00adstruction, the operation preserves the semantics. \nWe can then prune the semantics from the types using the coherentOrn theorem and retrieve the transformation \non raw syntax trees.  3.2.2 Reornaments In this paper, we are interested in a special sub-class of algebraic \nornaments. As we have seen, every ornament O induces an orna\u00admental algebra O-forgetAlg, which forgets \nthe extra information introduced by the ornament. Hence, given a datatype D and an or\u00adnament OD of D, \nwe can algebraically ornament [OD]orn using the ornamental algebra OD-forgetAlg. The resulting ornament \nis denoted DOD . McBride [2012] calls this object the algebraic or\u00adnament by the ornamental algebra. \nFor brevity, we call it the reor\u00adnament of OD. Again, we shall overload DOD to denote both the ornament \nand the resulting datatype. A standard example of reor\u00adnament is Vec: it is the reornament of List-Orn. \nPut otherwise, a vector is the algebraic ornament of List by the algebra computing its length, i.e. the \nornamental algebra from List to Nat. Reornaments can be implemented straightforwardly by unfold\u00ading their \nde.nition: .rst, compute the ornamental algebra and, sec\u00adond, construct the algebraic ornament by this \nalgebra. However, such a simplistic construction introduces a lot of spurious equal\u00adity constraints and \nduplication of information. For instance, using this naive de.nition of reornaments, a vector indexed \nby n is con\u00adstructed as any list as long as it is of length n. We can adopt a more .ne-grained approach \nyielding an isomor\u00adphic but better structured datatype. In our setting, where we can compute over the \nindex, a .ner construction of the Vec reornament would be as follows: We retrieve the index, hence obtaining \nn ;  By inspecting the ornament List-Orn, we obtain exactly the information by which n is extended into \na list: if n =0, no supplementary information is needed and if n = suc n ' , we need to extend it with \nan a : A. We call this the Extension of n ;  By inspecting the ornament List-Orn again, we obtain the \nre\u00adcursive structure of the reornament by deleting the data already fully determined by the index and \nits extension, and re.ning the indexing discipline: the tail of a vector of size suc n ' is a vector \nof size n '. The recursive structure is denoted by Structure.  A reornament is thus the Extension of \nits index followed by the recursive structure as de.ned by Structure4. Based on this intu\u00adition, we de.ne \nthe associated reornament at index t = in xs : \u00b5D by, .rst, inserting the valid extensions of t with \nExtension, then, building the recursive structure using Structure: reornament (O :orn re D): orn p0 [O]orn \nreornament O . .(j , in xs). insert (Extension (Oj ) xs) .e. Structure (Oj ) xs e Applied to the reornament \nof List-Orn, this construction gives the fully Brady-optimised detagged and forced version of Vec, \nhere written in full: data Vec [A: SET](n :Nat): SET where VecA 0 3 nil VecA (suc n) 3 cons (a :A)(vs \n:VecA n) Note that our ability to compute over the index is crucial for this construction to work. Also, \nit is isomorphic to the datatype one would have obtained with the algebraic ornament of the ornamental \nalgebra. Consequently, the correctness property of algebraic orna\u00adments is still valid here: constructively, \nwe get the coherentOrn theorem in one direction and the *-make function in the other. In this Section, \nwe have adapted the notion of ornament to our universe of datatypes. In doing so, we have introduced \nthe concept of a deletion ornament, using the indexing to remove duplicated information in the datatypes. \nThis has proved useful to simplify the de.nition of reornaments. We shall see how this can be turned \nto our advantage when we transport functions across ornaments. 4. A universe of functions and their ornaments \nWe are now going to generalise the notion of ornament to functions. In order to do this, we .rst need \nto be able, in type theory, to manipulate functions and especially their types. Hence, we de.ne a universe \nof functions. With it, we will be able to write generic programs over the class of functions captured \nby our universe. Using this technology, we de.ne a functional ornament as a dec\u00adoration over the universe \nof functions. The liftings implementing the functional ornament are related to the base function by a \ncoher\u00adence property. To minimise the theorem proving burden induced by coherence proofs, we expand our \nsystem with patches: a patch is the type of the functions that satisfy the coherence property by con\u00adstruction. \nFinally, and still writing generic programs, we show how we can automatically project the lifting and \nits coherence certi.cate out of a patch. 4 For space reasons, we shall refer the reader to the companion \ntechnical report for the type-theoretic de.nition of Extension and Structure. Their exact de.nition is \nnot necessary for the understanding of this paper.  data FunOrn (T :Type): SET1 where (T+ :FunOrn T \n)]FunOrn : SET FunOrn (\u00b5{Di }. T ) 3 \u00b5+{(O :orn re D)(j :re -1 i) }. (T + :FunOrn T) \u00b5+{O (inv j ) }. \nT + . \u00b5 O FunOrn (\u00b5{Di }\u00d7 T) 3 \u00b5+{(O :orn re D)(j :re -1 i) }\u00d7 (T+ :FunOrn T ) \u00b5+{O (inv j ) }\u00d7 T + ]FunOrnorn \nj . [T +]FunOrn ]FunOrn . \u00b5 [ O] orn j \u00d7 [T+]FunOrn FunOrn 1 3 1 . 1 [ 1]FunOrn (a) Code (b) Interpretation \nFigure 4. Universe of functional ornaments 4.1 A universe of functions For clarity of exposition, we \nrestrict our language of types to the bare minimum: a type can either be an exponential which domain \nis an inductive object, or a product which .rst component is an inductive object, or the unit type used \nas a termination symbol: data Type: SET1 where Type 3 \u00b5{(D :I . IDesc I )(i :I ) }. (T :Type) | \u00b5{(D \n:I . IDesc I )(i :I ) }\u00d7 (T :Type) | 1 Hence, this universe codes the function space from some (maybe \nnone) inductive types to some (maybe none) inductive types. Con\u00adcretely, the codes are interpreted as \nfollows: (T :Type)]Type : SET \u00b5{Di }. T]Type . \u00b5 Di . [T ]Type \u00b5{Di }\u00d7 T ]Type . \u00b5 Di \u00d7 [T]Type [ 1]Type \n. 1 The constructions we develop below could be extended to a more powerful universe such as one supporting \nnon-inductive sets or having dependent functions and pairs. However, this would needlessly complicate \nour exposition. Example 1 (Coding < ). Written in the universe of function types, the type of < is: type< \n: Type type< . \u00b5{Nat-Desc * }. \u00b5{Nat-Desc * }. \u00b5{Bool-Desc * }\u00d7 1 The implementation of < is essentially \nthe same as earlier, ex\u00adcepted that it must now return a pair of a boolean and an inhabitant of the unit \ntype. To be explicit about the recursion pattern of this function, we make use of Epigram s by ( . ) \nconstruct: < : [type<]Type m < n . Nat-case n m < 0 . (false, *) m < suc n . Nat-elim m 0 < suc n . (true, \n*) suc m < suc n . m < n That is to say: we .rst do a case analysis on n and then, in the successor case, \nwe proceed by induction over m. Example 2 (Coding + ). Written in the universe of function types, the \ntype of + is: type+: Type type+ . \u00b5{Nat-Desc * }. \u00b5{Nat-Desc * }. \u00b5{Nat-Desc * }\u00d7 1 Again, up to a multiplication \nby 1, the implementation of + is left unchanged. 4.2 Functional ornament From the universe of function \ntypes, it is now straightforward to de.ne the notion of functional ornament: we traverse the type code \nand ornament the inductive types as we go. Note that it is always possible to leave an object unornamented: \nwe ornament by the identity that simply copies the original de.nition. Hence, we obtain the de.nition \ngiven in Fig. 4(a). From a functional ornament, we get the type of the liftings by interpreting each \nornaments (Fig. 4(b)). This de.nes the universe of functional ornaments. We will want our ornamented \nfunction to be coherent with the base function we started with: for a function f : \u00b5D . \u00b5E, the ornamented \nfunction f+ : \u00b5 [OD]orn . \u00b5 [OE ]orn is said to be coherent with f if it satis.es the following equation: \n+ +) .x :\u00b5 [OD]orn.f (OD-forget x +) = OE -forget (f+ x To generalise the de.nition of coherence to any \narity, we proceed by induction over the universe of functional ornaments: Coherence(T + :FunOrn T )(f \n:[T]Type)(f + :[T+]FunOrn): SET Coherence (\u00b5+{O (inv j ) }. T +) ff + . + .x:\u00b5 [O]orn j .Coherence T \n+ (f (forgetOrn x+)) (f +x+) ox ++ Coherence (\u00b5+{O (inv j ) }\u00d7 T+)(x, xs) x, xs . + x = forgetOrn x+ \n\u00d7 Coherence T+ xs xsCoherence 1 ** . 1 Example 3 (Ornamenting type< to describe lookup). In Section 2, \nwe have identi.ed the ornaments involved to transport the type of < to obtain the type of lookup. From \nthere, we give the functional ornament describing the type of the lookup function: typeLookup : FunOrn \ntype< typeLookup . \u00b5+{idONat * }. \u00b5+{List-Orn * }. \u00b5+{Maybe-Orn * }\u00d7 1 The user can verify that [typeLookup]FunOrn \ngives us the type of the lookup function, up to multiplication by 1. Also, computing Coherence typeLookup \n( < ) gives the expected result: .f + :[typeLookup]FunOrn. .n :Nat..xs :ListA.isJust (f + n xs) = n < \nlength xs Note that this equation is not specifying the lookup function: it is only establishing a computational \nrelation between < and a candidate lifting f+, for which lookup is a valid choice. However, one could \nbe interested in other functions satisfying this coherence property and they would be handled by our \nsystem just as well. Example 4 (Ornamenting type+ to describe ++ ). The func\u00adtional ornament of type+ \nmakes only use of the ornamentation of Nat into ListA: type++ : FunOrn type+ type++ . \u00b5+{List-Orn * }. \n\u00b5+{List-Orn * }. \u00b5+{List-Orn * }\u00d7 1 Again, computing [type++]FunOrn indeed gives us the type of ++ while \nCoherence type++ ( + ) correctly captures our re\u00adquirement that list append preserves the length of its \narguments. As before, the list append function is not the only valid lifting: one could for example consider \na function that reverts the .rst list and appends it to the second one.  4.3 Patches By de.nition of \na functional ornament, the lifting of a base function f : [T ]Type is a function f+ of type [T +]FunOrn \nsatisfying the coherence property Coherence T + f. To implement a lifting that is coherent, we might \nask the user to .rst implement the lifting f+ and then prove it coherent. However, we .nd this process \nunsatisfactory: we fail to harness the power of dependent types when implementing f+, this weakness being \nthen paid off by tedious proof obligations. To overcome this limitation, we de.ne the notion of Patch \nas the type of all the functions that are coherent by construction.  Note that we are looking for an \nequivalence here: we will de\u00ad.ne patches so that they are in bijection with liftings satisfying a coherence \nproperty, informally: =(f + Patch TT + f ~:[T +]FunOrn) \u00d7 Coherence T + f f + (1) In this paper, we constructively \nuse this bijection in the left to right direction: having implemented a patch f++ of type Patch TT + \nf, we will show, in the next Section, how we can extract a lifting together with its coherence proof. \nBefore giving the generic construction of the Patch object, let us .rst work through the < example. After \nhaving functionally ornamented < with typeLookup, the lifting function f+ and coherence property can \nbe represented by the following pair: (f + :Nat \u00d7 ListA . MaybeA) \u00d7 .m :Nat..as :ListA.m < List-forget \nas = Maybe-forget (f + m as) Applying dependent choice, this is equivalent to: ~ =(m :Nat) \u00d7 (n :Nat) \n\u00d7 (as :ListA) \u00d7 List-forget as = n . (ma :MaybeA) \u00d7 Maybe-forget ma = m < n Now, by de.nition of reornaments, \nwe have that: ~ (as :ListA) \u00d7 List-forget as = n = VecA n and (ma :MaybeA) \u00d7 Maybe-forget ma = b ~= IMaybeA \nb Applying these isomorphisms, we obtain the following type, which we call the Patch of the functional \nornament typeLookup: ~ =(m :Nat) \u00d7 (n :Nat) \u00d7 (vs :VecA n) . IMaybeA (m < n) Which is thus equivalent \nto a pair of a lifting and its coherence. Intuitively, the Patch construction consists in turning the \npairs of data and their algebraically de.ned constraint into equivalent re\u00adornaments. The coherence property \nof reornaments tells us that pro\u00adjecting the ornamented function down to its unornamented compo\u00adnents \ngives back the base function. By turning the projection func\u00adtions into inductive datatypes, we enforce \nthe coherence property directly by the index: we introduce a fresh index for the arguments (here, introducing \nm and n) and index the return types by the result of the unornamented function (here, indexing IMaybeA \nby m<n). To build this type generically, we simply proceed by induction over the functional ornament. \nUpon an argument (i.e. a \u00b5 +{O }. ), we introduce a fresh index and the reornament of O. Upon a result \n(i.e. a \u00b5 +{O }\u00d7 ), we ask for a reornament of O indexed by the result of the base function. Patch(T \n:Type)(T + :FunOrn T )(f :[T]Type): SET Patch (\u00b5{D (re j ) }. T )(\u00b5+{O (inv j ) }. T +) f . (x :\u00b5 D (re \nj )) . \u00b5 DO (j , x) . Patch TT+ (fx) Patch (\u00b5{D (re j ) }\u00d7 T )(\u00b5+{O (inv j ) }\u00d7 T +)(x, xs) . \u00b5 DO (j \n, x) \u00d7 Patch TT+ xs Patch 1 1 * . 1 Example 5 (Patch of typeLookup). The type of the coherent liftings \nof < by typeLookup, as de.ned by the Patch of < by typeLookup, computes to: (m :Nat) . (m+ :\u00b5 NatidONat \nm) . (n :Nat) . (vs :\u00b5 NatListA n) . \u00b5 BoolMaybeA (m < n) \u00d7 1 Note that \u00b5 NatidONat n is isomorphic to \n1: all the content of the datatype has been forced the recursive structure of the datatype is entirely \ndetermined by its index and detagged the choice of constructors is entirely determined by its index, \nleaving no actual data in it. Hence, we discard this argument as computationally and BoolMaybeA uninteresting. \nOn the other hand, NatListA are, respectively, the previously introduced VecA and IMaybeA types. Example \n6 (Patch of type+). Similarly, the Patch of + by type+ computes to the type of the vector append function: \n(m :Nat) . (xs :NatListA m) . (n :Nat) . (ys :NatListA m) . NatListA (m + n) \u00d7 1 Discussion: While these \nprecisely indexed functions remove the burden of theorem proving, this solution is not relevant in all \nsitu\u00adations. For instance, if we were to implement a length-preserving list reversal, our patching machinery \nwould ask us to implement vrev : VecA n . VecA n that will inevitably require some proving to match up \nthe types: we must appeal to the equational theory of addition in this case, n+1 = suc n and this is \nbeyond the grasp of our type-checker, which can only decide de.nitional identities. Unless the type-checker \nworks up to equational theories, as done in CoqMT [Strub 2010], the programmer is certainly better off \nusing our machinery to generate the coherence condition (Section 4.2) and implement the lifting and its \ncoherence proof manually, rather than using patches. However, this example gives a hint as to what can \nbe seen as a good coherence property: because we want the type-checker to do all the proving, the equations \nwe rely on at the type level need to be de.nitionally true, either because our logic has a rich de.nitional \nequality, or because we rely on operations that satisfy these identities by de.nition.  4.4 Patching \nand coherence At this stage, we can implement the ilookup function exactly as we did in Section 2. From \nthere, we now want to obtain the lookup function and its coherence certi.cate. More generally, having \nim\u00adplemented a function satisfying the Patch type, we want to extract the lifting and its coherence proof. \nPerhaps not surprisingly, we obtain this construction by look\u00ading at the isomorphism (1) of the previous \nSection through our constructive glasses: indeed, as the Patch type is isomorphic to the set of liftings \nsatisfying the coherence property, we effec\u00adtively get a function taking every Patch to a lifting and \nits co\u00adherence proof. More precisely, we obtain the lifting by general\u00adising the reornament-induced *-forget \nfunctions to functional or\u00adnaments while we obtain the coherence proof by generalising the reornament-induced \ncoherentOrn theorem. We call patching the action of projecting the coherent lifting from a Patch function. \nAgain, it is de.ned by mere induction over the functional ornament. When ornamented arguments are introduced \n(i.e. with \u00b5 +{O }. ), we simply patch the body of the function. This is possible because from x + : \n\u00b5 [OD]orn, we can forget the ornament to compute f (forgetOrn x +) and we can also make the reornament \nto compute f++ (makeAlgOrn x +). When an ornamented result is to be returned, we simply forget the reornamentation \ncomputed by the coherent lifting: patch (T+ :FunOrn T )(f :[T ]Type)(p :Patch TT + f ): [T +]FunOrn f \n++ patch (\u00b5+{O (inv j ) }. T +) f . + .x. patch (f (forgetOrn x+)) (f ++ (forgetOrn x+)(makeAlgOrn x+)) \nox ++ ++ patch (\u00b5+{O (inv j ) }\u00d7 T +)(x, xs) x, xs . ox ++ ++ forgetOrn x, patch T+ xs xs patch 1 * * \n.* Extracting the coherence proof follows a similar pattern. We introduce arguments as we go, just as \nwe did with patch. When we reach a result, we have to prove the coherence of the result returned by the \npatched function: this is a straightforward application of the coherentOrn theorem: coherence (T+ :FunOrn \nT )(f :[T ]Type)(p :Patch TT + f ): Coherence T + f (patch T + fp) coherence (\u00b5+{O (inv j ) }. T +) fp \n. + .x. coherenceT + (f (forgetOrn x +)) (p (forgetOrn x+)(makeAlgOrn x +)) ox + coherence (\u00b5+{O (inv \nj ) }\u00d7 T +)(x, xs) x, p . ox + coherentOrn x, coherence T+ xs p coherence 1 ** .*  < : [type<]Type \nilookup (m :Nat)(vs :VecA n): IMaybeA (m < n) m < n . Nat-case n ilookup m vs . Vector-case vs m < 0 \n. (false, *) ilookup m nil . nothing m < suc n . Nat-elim m ilookup m (cons a vs) . Nat-elim m 0 < suc \nn . (true, *) ilookup 0 (cons a vs) . just a suc m < suc n . m < n ilookup (suc m)(cons a vs) . ilookup \nm vs Figure 5. Implementations of < and ilookup Example 7 (Obtaining lookup and its coherence certi.cate, \nfor free). This last step is a mere application of the patch and coherence functions. Hence, we de.ne \nlookup as follows: lookup : [typeLookup]FunOrn lookup . patch typeLookup ( < ) ilookup And we get its \ncoherence proof, here spelled in full: cohLookup (n :Nat)(xs :ListA): Maybe-forget (p0(lookup n xs)) \n= p0(n < List-forget xs) cohLookup n xs . coherence typeLookup ( < ) ilookup n xs Example 8 (Obtaining \n++ and its coherence certi.cate, for free). Assuming that we have implemented the coherent lifting vappend, \nwe obtain concatenation of lists and its coherence proof by simply running our generic machinery: ++ \n: [type++]FunOrn ++ . patch type++ (+ ) vappend coh++ (xs :ListA)(ys :ListA): List-forget (p0(xs ++ ys)) \n= p0((List-forget xs) +(List-forget ys)) coh++ xs ys . coherence type++ (+ ) vappend xs ys Looking back \nat the manual construction in Section 2, we can measure the progress we have made: while we had to duplicate \nen\u00adtirely the type signature of lookup and its coherence proof, we can now write down a functional ornament \nand these are generated for us. This is not just convenient: by giving a functional ornament, we establish \na strong connection between two functions. By pinning down this connection with the universe of functional \nornaments, we turn this knowledge into an effective object that can be ma\u00adnipulated and reasoned about \nwithin the type theory. We make use of this concrete object when we construct the Patch induced by a \nfunctional ornament: this is again a construction that is generic now, while we had to tediously (and \nperhaps painfully) construct it in Section 2. Similarly, we get patching and extraction of the co\u00adherence \nproof for free now, while we had to manually .ddle with several projection and injection functions. We \npresented the Patch as the type of the liftings coherent by construction. As we have seen, its construction \nand further pro\u00adjection down to a lifting is now entirely automated, hence effort\u00adless. This is a signi.cant \nstep forward: we could either implement lookup and then prove it coherent, or we could go through the \ntrouble of manually de.ning carefully indexed types and write a function correct by construction. We \nhave now made this second alternative just as accessible as the .rst one. And, from a program\u00adming perspective, \nthe second approach is much more appealing. In a word, we have made an appealing technique extremely \ncheap! Finally, we shall reiterate that none of the above constructions involve extending the type theory: \nusing our universe of datatypes, functional ornaments are internalised as a few generic programs and \ninductive types. For systems such as Agda, Coq, or Haskell with GADTs, this technology would need to \nbe provided at the meta-level. However, the fact that our constructions type-check in our system suggests \nthat adding these constructions at the meta\u00adlevel is consistent with a pre-existing meta-theory. 5. Lazy \nprogrammers, clever constructors In our journey from < to lookup, we had to implement the ilookup function. \nIt is instructive to put < and ilookup side-by\u00adside (Fig. 5). First, both functions follow the same recursion \npat\u00adtern: case analysis over n/vs followed by induction over m. Sec\u00adond, the returned constructors are \nrelated through the Maybe or\u00adnament: knowing that we have returned true or false when imple\u00admenting < \n, we can deduce which of just or nothing will be used in ilookup. Interestingly, the only unknown, hence \nthe only neces\u00adsary input from the user, is the a in the just case: it is precisely the information that \nhas been introduced by the Maybe ornament. In this Section, we are going to leverage our knowledge of \nthe de.nition of the base function such as < to guide the implementation of the coherent lifting such \nas ilookup: instead of re-implementing ilookup by duplicating most of the code of < , the user indicates \nwhat to duplicate and only provides strictly necessary inputs. We are primarily interested in transporting \ntwo forms of structure: Recursion pattern: if the base function is a fold a and the user provides us \nwith a coherent algebra \u00df of a, we automatically construct the coherent lifting \u00df of a ; Returned constructor: \nif the base function returns a constructor C and the user provides us with a coherent extension C of \nC, we automatically construct the coherent lifting of C We shall formalise what we understand by being \na coherent alge\u00adbra and a coherent extension below. The key idea is to identify the strictly necessary \ninputs from the user, helped in that by the orna\u00adments. It is then straightforward to, automatically \nand generically, build the lifted folds and values. 5.1 Transporting recursion patterns When transporting \na function, we are very unlikely to change the recursion pattern of the base function. Indeed, the very \nreason why we can do this transportation is that the lifting uses exactly the same structure to compute \nits results. Hence, in the majority of the cases, we could just ask the computer to use the induction \nprinciple induced by the base one: the only task left to the user will be to give the algebra. For clarity \nof exposition, we restrict ourselves to transporting folds. However, the treatment of induction is essentially \nthe same, as hinted by the fact that induction can be reduced to folds [Fumex et al. 2011]. To illustrate \nthis approach, we work through a concrete exam\u00adple: we derive hd : ListA . MaybeA from isSuc : Nat . \nBool by transporting the algebra. For the sake of argument, we arti.cially de.ne isSuc by a fold: isSuc \n(n :Nat): Bool isSuc n . aisSuc n where aisSuc (xs :[Nat-Desc] Bool): Bool aisSuc 0 . false aisSuc ( \nsuc xs) . true Our objective is thus to de.ne the algebra for hd, which has the following type: ahd :[List-Desc] \nMaybeA . MaybeA  (a) Request lifting of algebra: (user input) ihd ihd {?} (vs :VecA n) : IMaybeA isSuc \nn lift. lift-fold (b) Result of lifting the algebra: (system output) ihd (vs :VecA n) : IMaybeA (isSuc \nn) ihd lift. lift-fold where aihd (vs :[Vec-Desc] (.n ' . IMaybeA (isSuc n ' )) n) aihd nil aihd ( cons \na xs) : {?}{?} IMaybeA (isSuc n) (c) Request lifting of constructors: (user input) ihd (vs :VecA n) : \nIMaybeA (isSuc n) ihd lift. lift-fold where aihd (vs :[Vec-Desc] (.n ' . IMaybeA (isSuc n ' )) n) : IMaybeA \n(isSuc n) aihd nil lift. {?} aihd ( cons a xs) lift. {?} (d) Result of lifting constructors: (system \noutput) ihd (vs :VecA n) : IMaybeA (isSuc n) ihd lift. lift-fold where aihd (vs :[Vec-Desc] (.n ' . IMaybeA \n(isSuc n ' )) n) : IMaybeA (isSuc n) aihd nil lift. nothing {?:1} [ {?:1} ] aihd ( cons a xs) lift. just \n{?:A} [ {?:1} ] (e) Type-checked term: (automatically generated from (d)) ihd (vs :VecA n) : IMaybeA \n(isSuc n) ihd vs . lift-fold aisSuc aihd where aihd (vs :[Vec-Desc] (.n ' . IMaybeA (isSuc n ' )) n) \n: IMaybeA (isSuc n) aihd nil . lift-constructor nil {?:1} {?:1} * aihd ( cons a xs) . lift-constructor \n( suc n) {?:A} {?:1} * Figure 6. Guided implementation of ihd such that its fold is coherent. By the \nfold-fusion theorem [Bird and de Moor 1997], it is suf.cient (but not necessary) for ahd to satisfy the \nfollowing condition: .ms :[List-Desc] MaybeA. isJust (ahd ms) = aisSuc (List-forgetNat([List-Desc] isJust \nms)) Following the same methodology we applied to de.ne the Patch type, we can massage the type of ahd \nand its coherence condition to obtain an equivalent de.nition enforcing the coherence by index\u00ading. In \nthis case, the natural candidate is: ' aihd :[Vec-Desc] (.n . IMaybeA (isSuc n ' )) n . IMaybeA (isSuc \nn) This construction generalises to any functional ornament. That is, from an algebra a:(i :I) . [D i] \n(. . [T ]Type) . [T ]Type together with an ornament OD : orn reD and a functional ornament T + : FunOrn \nT , the type of coherent algebras for a is: \u00df :(j :J)(t :\u00b5D (re j )) . [DO (j , t)] (.(j , t). Patch \nT ( a t) T +) . Patch T ( a t) T + It can formally be proved that algebras of this type capture exactly \nthe algebras satisfying the coherence condition. Constructively, we get that such a coherent algebra \ninduces a coherent lifting, by a mere fold of the coherent algebra: lift-fold (a:(i :I ) . [Di] (. . \n[T ]Type) . [T]Type) (\u00df :(j :J )(t :\u00b5 D (re j )) . [DO (j , t)] (.(j , t). Patch T ( a t) T +) . Patch \nT ( a t) T+) : Patch (\u00b5{D (re j ) }. T ) a (\u00b5+{Oj }. T +) ++ ++ lift-fold a\u00df . .x. .x.\u00df x ysis is now \nsimple, as case analysis is derivable from induction by stripping out the induction hypotheses [McBride \net al. 2004]. Example 9 (Transporting the recursion pattern of isSuc). We can now apply our generic machinery \nto transport isSuc to hd: in a high-level notation, we would write the command of Fig. 6(a). To this \ncommand, an interactive system would respond by automati\u00adcally generating the algebra, as shown in Fig. \n6(b). In the low-level type theory, this would elaborate to the following term: ihd (vs :VecA n): IMaybeA \n(isSuc n) ihd vs . lift-fold aisSuc aihd where ' aihd (vs :[Vec-Desc] (.n . IMaybeA (isSuc n ' )) n): \nIMaybeA (isSuc n) aihd nil .{?} aihd ( cons a xs) .{?} Once again, it is beyond the scope of this paper \nto formalise the elaboration process from the high-level notation to the low\u00adlevel type theory. The reader \nwill convince himself that the high\u00adlevel notation contains all the information necessary to conduct \nthis task. We shall now freely use the high-level syntax, with the understanding that it builds a low-level \nterm that type-checks. Example 10 (Transporting the recursion pattern of < ). To im\u00adplement ilookup, \nwe use lift-case to transport the case analysis on n and lift-ind to transport the induction over m. \nIn a high-level notation, this interaction results in: ilookup : Patch type< typeLookup < lift m ilookup \nmmnvs . lift-case m ilookup mm0 nil {?} lift m ilookup mm(suc n)(cons a vs) . lift-ind ilookup 0 0 0 \nnil {?}Generalising this idea, we can similarly lift induction: we de-ilookup (suc m)(suc mm ) 0 nil \n{?}note lift-ind the corresponding clever constructor. Lifting case anal\u00ad  5.2 Transporting constructors \nJust as the recursive structure, the returned values often simply mirror the original de.nition: we are \nin a situation where the base function returns a given constructor and we would like to return its ornamented \ncounterpart. Informing the computer that we simply want to lift the constructor, it should .ll in the \nparts that are already determined by the original constructor and ask only for the missing information, \ni.e. the data freshly introduced by the ornament. Remember that, when implementing the coherent lifting, \nwe are working on the reornaments of the lifting type. Hence, when returning a constructor-headed value, \nwe are building an inhabitant of a reornament. When de.ning reornaments in Section 3.2.2, we have shown \nthat, thanks to deletion ornaments, a reornament can be decomposed in two components: .rst, the extension \nthat contains all the extra information intro\u00adduced by the ornament ;  second, the recursive structure \nof the re.ned datatype, which de.nes the type of the arguments of the constructor  And no additional \ninformation is required: all the information pro\u00advided by indexing with the unornamented datatype is \noptimally used in the de.nition of the reornament. Thus, there is absolutely no duplication of information. \nThis clear separation of concerns is a blessing for us: when lift\u00ading a constructor, we only have to \nprovide the extension and the arguments of the datatype, nothing more. In terms of implementa\u00adtion, this \nis as simple as: lift-constructor (xs :[D (re j )] \u00b5 D) (e :Extension (Oj ) xs) coherent extension (a \n:[[Structure O xs e]orn] (\u00b5 DO )) arguments (t++ :Patch TtT+) : Patch (\u00b5{D (re j ) }\u00d7 T ) (in xs, t) \n(\u00b5+{Oj }\u00d7 T +) ox lift-constructor xs e a t++ . in (e, a), t++ Example 11 (Transporting the constructors \nof isSuc). Let us .nish the implementation of hd from isSuc. Our task is simply to trans\u00adport the true \nand false constructors along the Maybe ornament. In a high-level notation, we would write the command \nshown in Fig. 6(c). The interactive system would then respond by generat\u00ading the code of Fig. 6(d). The \n1 goals are trivially solved, probably automatically by the system. The only information the user has \nto provide is a value of type A returned by the just constructor. Example 12 (Transporting the constructors \nof < ). In the imple\u00admentation of ilookup, we want to lift the returned true and false to the Maybe ornament. \nIn a high-level notation, this would be repre\u00adsented as follows: ilookup:Patch type< typeLookup < lift \nm ilookup mmnvs . lift-case lift m ilookup mm0 nil . nothing *[*] lift m ilookup mm(suc n)(cons a vs) \n. lift-ind lift ilookup 0 0 (suc n)(cons a vs) . just {?:A} [*] ilookup (suc m)(suc mm )(suc n)(cons \na vs) {?} As before, in an interactive setting, the user would instruct the machine to execute the command \nlift . and the computer would come back with the skeleton of the expected inputs. 6. Related work Our \nwork is an extension of the work of McBride [2012] on or\u00adnaments, originally introduced to organise datatypes \naccording to their common structure. This gave rise to the notion of ornamen\u00adtal algebras forgetting \nthe extra information of an ornamented datatype and algebraic ornaments indexing a datatype accord\u00ading \nto an algebra. This, in turn, induced the notion of algebraic ornament by ornamental algebras, which \nis a key ingredient for our work. However, for simplicity of exposition, these ornaments had originally \nbeen de.ned on a less index-aware universe of datatypes. As a consequence, computation over indices was \nimpossible and, therefore, deletion of duplicated information was impossible. A corollary of this was \nthat reornaments contained a lot of duplica\u00adtion, hence making the lifting of value from ornamented to \nreorna\u00admented datatype extremely tedious. Our presentation of algebraic ornament has been greatly im\u00adproved \nby the categorical model developed by Atkey et al. [2011]: the authors gave a conceptually clear treatment \nof algebraic orna\u00adment in a Lawvere .bration. At the technical level, the authors con\u00adnected the de.nition \nof algebraic ornament with truth-preserving liftings, which are also used in the construction of induction \nprin\u00adciples, and op-reindexing, which models S-types in type theory. Whilst the authors did not explicitly \naddress the issue of trans\u00adporting functions across ornaments, much of the infrastructure was implicitly \nthere: for instance, lifting of folds is a trivial specialisa\u00adtion of induction. Also, the characterisation \nof the .x-point of an algebraic ornament as op-reindexing of the fold is a key ingredient to understanding \nindex-level computations and assimilate them at the term level. In their work on realisability and parametricity \nfor Pure Type Systems, Bernardy and Lasson [Bernardy and Lasson 2011] have shown how to build a logic \nfrom a programming language. In such a system, terms of type theory can be precisely segregated based \non their computational contribution and their logical contribution. In particular, the idea that natural \nnumbers realise lists of the corre\u00adsponding length appears in this system under the guise of vectors, \nthe re.ection of the realisability predicate. The strength of the re\u00adalisability interpretation is that \nit is naturally de.ned on functions: while McBride [2012] and Atkey et al. [2011] only consider or\u00adnaments \non datatypes, their work is the .rst, to our knowledge, to capture a general notion of functions realising \n i.e. ornamenting other functions. Following the steps of Bernardy, Ko and Gibbons [2011] adapted the \nrealisability interpretation to McBride s universe of datatypes and explored the other direction of the \nPatch equiva\u00adlence, using reornaments to generate coherence properties: they describe how one could take \nlist append together with a proof that it is coherent with respect to addition and obtain the vector \nappend function. Their approach would shift neatly to our index-aware setting, where the treatment of \nreornaments is streamlined by the availability of deletion. However, we prefer to exploit the direction \nof the equivalence which internalises coherence: we would rather use the full power of dependent types \nto avoid explicit proof. Hence, in our framework, we simultaneously induce list append and implicitly \nprove its co\u00adherence with addition just by de.ning vector append. Of course, which approach is appropriate \ndepends on one s starting point. Moreover, our universe of functions takes a step beyond the related \nwork by supporting the mechanised construction of liftings, leaving to the user the task of supplying \na minimal patch. Our framework could easily be used to mechanise the realisability predicate con\u00adstructions \nof Bernardy and Lasson [2011], Ko and Gibbons [2011]. 7. Conclusion In this paper, we have developed \nthe notion of functional ornament and shown how one can achieve code reuse by transporting func\u00adtions \nalong a functional ornament. To this end, we have adapted McBride s ornaments to our universe of datatypes \n[Chapman et al. 2010]. This gave us the ability to compute over indices, hence in\u00adtroducing the deletion \nornament. Deletion ornaments are a key in\u00adgredient for the internalisation of Brady s optimisation [Brady \net al. 2004] over inductive families. In particular, this gave us a simpler implementation of reornaments. \n We then generalised ornaments to functions: from a universe of function type, we de.ne a functional \nornament as the ornamenta\u00adtion of each of its inductive components. A function of the resulting type \nwill be subject to a coherence property, akin to the ornamental forgetful map of ornaments. We have constructively \npresented this object, by building a small universe of functional ornaments. Having functional ornaments, \nthis raises the question of trans\u00adporting a function to its ornamented version in such way that the coherence \nproperty holds. Instead of asking our user to write cum\u00adbersome proofs, we de.ned a Patch type as the \ntype of all the func\u00adtions that satis.es the coherence property by construction. Hence, we make extensive \nuse of the dependently typed programming machinery offered by the environment: in this setting, the type\u00adchecker, \nthat is the computer, is working with us to construct a term, not waiting for us to produce a proof. \nHaving implemented a function correct by construction, one then gets, for free, the lifting and its coherence \ncerti.cate. This is a straightforward application of the equivalence between the Patch type and the set \nof coherent functions. These projection functions have been implemented in type theory by simple generic \nprogramming over the universe of functional ornaments. To further improve code reuse, we provide two \nclever construc\u00adtors to implement a Patch type: the idea is to use the structure of the base function \nto guide the implementation of the coherent lift\u00ading. Hence, if the base function uses a speci.c induction \nprinciple or returns a speci.c constructor, we make it possible for the user to specify that she wants \nto lift this element one level up. This way, the function is not duplicated: only the new information, \nas determined by the ornament, is necessary. To conclude, we believe that this is a .rst yet interesting \nstep to\u00adward code reuse for dependently typed programming systems. With ornaments, we were able to organise \ndatatypes by their structure. With functional ornaments, we are now able to organise functions by their \nstructure-preserving computational behaviour. Besides, we have developed some appealing automation to \nassist the implemen\u00adtation of functional ornaments, without any proving required, hence making this approach \neven more accessible. 7.1 Future work Whilst we have deliberately chosen a simple universe of functions, \nwe plan to extend it in various directions. Adding type dependency (.-and S-types) but also non inductive \nsets is a necessary .rst step. Inspired by Bernardy and Lasson [2011], we would like to add a parametric \nquanti.er: in the implementation of ilookup, we would mark the index A of VecA and IMaybeA as parametric \nso that in the cons a case, the a could automatically be carried over. The universe of functional ornaments \ncould be extended as well, especially once the universe of functions has been extended with dependent \nquanti.ers. For instance, we want to consider the introduction and deletion of quanti.ers, as we are \ncurrently doing on datatypes. Whilst we have only looked at least .xed points in this paper, we also \nwant to generalise our universe with greatest .xed points and the lifting of co-inductive de.nitions. \nFurther, our framework relies crucially on the duality between a reornament and its ornament presentation \nsubject to a proof. We cross this isomorphism in both directions when we project the lifting from the \ncoherent lifting. In practice, this involves a traversal of each of the input datatypes and a traversal \nof each of the output datatypes. However, computationally, these traversal are identities: the only purpose \nof these terms is at the logical level, for the type-checker to .x the types. We are looking at transforming \nour library of clever constructor into a proper domain-speci.c language (DSL). This way, implementing \na coherent lifting would consists in working in a DSL for which an optimising compiler could compute \naway the computationally irrelevant operations. Finally, much work remains to be done on the front of \nusability: for convenience, we have presented some informal notations for datatypes, their ornaments \nand an extension of Epigram program\u00adming facility with liftings. A formal treatment of these syntaxes \nand of their elaboration to the low-level type theory is underway: we are con.dent that a suf.ciently \nabstract semantics can be given to these syntaxes by giving a relational speci.cation of the elaboration \npro\u00adcess, in the style of Harper and Stone [2000] for Standard ML. Acknowledgements We owe many thanks \nto the anonymous re\u00adviewer, their comments having signi.cantly improved this paper. We are also very \ngrateful to Guillaume Allais, Stevan Andjelkovic and Peter Hancock for their meticulous reviews of this \npaper. We shall also thank Edwin Brady for suggesting the study of lookup functions and Andrea Vezzosi \nfor spotting an issue in our de.ni\u00adtion of reornaments. Finally, this paper would have remained a draft \nwithout the help and encouragement of Jos\u00b4e Pedro Magalh aes. The authors are supported by the Engineering \nand Physical Sciences Research Council, Grant EP/G034699/1. References R. Atkey, P. Johann, and N. Ghani. \nWhen is a type re.nement an inductive type? In FOSSACS, volume 6604 of Lecture Notes in Computer Science, \npages 72 87. Springer, 2011. J.-P. Bernardy and M. Lasson. Realizability and parametricity in pure type \nsystems. In FOSSACS, volume 6604 of Lecture Notes in Computer Science, pages 108 122. Springer, 2011. \nR. S. Bird and O. de Moor. Algebra of programming. Prentice Hall, 1997. E. Brady, C. McBride, and J. \nMcKinna. Inductive families need not store their indices. In Types for Proofs and Programs, pages 115 \n129. 2004. J. Chapman, P.-E. Dagand, C. McBride, and P. Morris. The gentle art of levitation. SIGPLAN \nNot., 45:3 14, September 2010. T. Coquand. Pattern matching with dependent types. In Types for Proofs \nand Programs, 1992. P. Dybjer. Inductive families. Formal Asp. Comput., 6(4):440 465, 1994. T. Freeman \nand F. Pfenning. Re.nement types for ML. SIGPLAN Not., 26: 268 277, May 1991. C. Fumex, N. Ghani, and \nP. Johann. Indexed induction and coinduction, .brationally. In CALCO, pages 176 191, 2011. R. Harper \nand C. Stone. A Type-Theoretic interpretation of standard ML. In Proof, Language, and Interaction: essays \nin honour of Robin Milner, 2000. H.-S. Ko and J. Gibbons. Modularising inductive families. In Workshop \non Generic Programming, pages 13 24, 2011. C. McBride. Ornamental algebras, algebraic ornaments. Journal \nof Func\u00adtional Programming, to appear, 2012. C. McBride and J. McKinna. The view from the left. J. Funct. \nProgram., 14(1):69 111, 2004. C. McBride, H. Goguen, and J. McKinna. A few constructions on construc\u00adtors. \nIn TYPES, pages 186 200, 2004. P. Morris, T. Altenkirch, and N. Ghani. A universe of strictly positive \nfamilies. Int. J. Found. Comput. Sci., 20(1):83 107, 2009. U. Norell. Towards a practical programming \nlanguage based on dependent type theory. PhD thesis, Chalmers University of Technology, 2007. P.-Y. Strub. \nCoq modulo theory. In CSL, pages 529 543, 2010. N. Swamy, J. Chen, C. Fournet, P.-Y. Strub, K. Bhargavan, \nand J. Yang. Secure distributed programming with value-dependent types. In ICFP, pages 266 278. ACM, \n2011. The Coq Development Team. The Coq Proof Assistant Reference Manual. H. Xi, C. Chen, and G. Chen. \nGuarded recursive datatype constructors. In POPL, 2003.    \n\t\t\t", "proc_id": "2364527", "abstract": "<p>Programming with dependent types is a blessing and a curse. It is a blessing to be able to bake invariants into the definition of datatypes: we can finally write correct-by-construction software. However, this extreme accuracy is also a curse: a datatype is the combination of a structuring medium together with a special purpose logic. These domain-specific logics hamper any effort of code reuse among similarly structured data. In this paper, we exorcise our datatypes by adapting the notion of ornament to our universe of inductive families. We then show how code reuse can be achieved by ornamenting functions. Using these functional ornaments, we capture the relationship between functions such as the addition of natural numbers and the concatenation of lists. With this knowledge, we demonstrate how the implementation of the former informs the implementation of the latter: the user can ask the definition of addition to be lifted to lists and she will only be asked the details necessary to carry on adding lists rather than numbers. Our presentation is formalised in a type theory with a universe of datatypes and all our constructions have been implemented as generic programs, requiring no extension to the type theory.</p>", "authors": [{"name": "Pierre-Evariste Dagand", "author_profile_id": "81413605432", "affiliation": "University of Strathclyde, Glasgow, United Kingdom", "person_id": "P3804315", "email_address": "dagand@cis.strath.ac.uk", "orcid_id": ""}, {"name": "Conor McBride", "author_profile_id": "81548019889", "affiliation": "University of Strathclyde, Glasgow, United Kingdom", "person_id": "P3804316", "email_address": "conor@cis.strath.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2364527.2364544", "year": "2012", "article_id": "2364544", "conference": "ICFP", "title": "Transporting functions across ornaments", "url": "http://dl.acm.org/citation.cfm?id=2364544"}