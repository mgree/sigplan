{"article_publication_date": "09-09-2012", "fulltext": "\n Proof-Producing Synthesis of ML from Higher-Order Logic Magnus O. Myreen Scott Owens Computer Laboratory, \nUniversity of Cambridge, UK {magnus.myreen,scott.owens}@cl.cam.ac.uk Abstract The higher-order logic \nfound in proof assistants such as Coq and various HOL systems provides a convenient setting for the devel\u00adopment \nand veri.cation of pure functional programs. However, to ef.ciently run these programs, they must be \nconverted (or ex\u00adtracted ) to functional programs in a programming language such as ML or Haskell. With \ncurrent techniques, this step, which must be trusted, relates similar looking objects that have very \ndifferent semantic de.nitions, such as the set-theoretic model of a logic and the operational semantics \nof a programming language. In this paper, we show how to increase the trustworthiness of this step with \nan automated technique. Given a functional program expressed in higher-order logic, our technique provides \nthe corre\u00adsponding program for a functional language de.ned with an oper\u00adational semantics, and it provides \na mechanically checked theorem relating the two. This theorem can then be used to transfer veri.ed properties \nof the logical function to the program. We have implemented our technique in the HOL4 theorem prover, \ntranslating functions to a core subset of Standard ML, and have applied it to examples including functional \ndata structures, a parser generator, cryptographic algorithms, and a garbage collector. Categories and \nSubject Descriptors D.2.4 [Software/Program Veri.cation]: Formal Methods General Terms Program Synthesis, \nVeri.cation 1. Introduction The logics of most proof assistants for higher-order logic (Coq, Isabelle/HOL, \nHOL4, PVS, etc.) contain subsets which closely resemble pure functional programming languages. As a result, \nit has become commonplace to verify functional programs by .rst coding up algorithms as functions in \na theorem prover s logic, then using the prover to prove those logical functions correct, and then simply \nprinting (sometimes called extracting ) these functions into the syntax of a functional programming language, \ntypically SML, OCaml, Lisp, or Haskell. This approach is now used even in very large veri.cation efforts \nsuch as the CompCert veri.ed compiler [20] and several projects based on CompCert [1, 29, 38]; it has \nalso been used in database veri.cation [27]. However, the printing step is a potential weak link, as \nHarrison remarks in a survey on re.ection [14]: Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. [...] the .nal jump from an abstract function inside the logic \nto a concrete implementation in a serious programming language which appears to correspond to it is a \nglaring leap of faith. In this paper we show how this leap of faith can be made into a trustworthy step. \nWe show how the translation can be automatically performed via proof a proof which states that (A:) \nthe transla\u00adtion is semantics preserving with respect to the logic and an op\u00aderational semantics of the \ntarget language. Ideally, one could then (B:) run the generated code on a platform which has been proved \nto implement that operational semantics. This setup provides the highest degree of trust in the executing \ncode without any more ef\u00adfort on the part of programmers and prover users than the current printing/extraction \napproach. In previous work, we have shown that A and B are possible for the simple case of an untyped \n.rst-order Lisp language [32], i.e. we can synthesise veri.ed Lisp from Lisp-like functions living in \nhigher-order logic; and achieve B by running the generated programs on a veri.ed Lisp implementation \n[33] which has been proved to implement our operational semantics. In this paper, we tackle the more \ncomplex problem of perform\u00ading A for higher-order, typed ML-like functions, i.e. we show how semantics \npreserving translations from higher-order logic into a subset of ML can be performed inside the theorem \nprover. We be\u00adlieve our method works in general for connecting shallow and deep embeddings of functional \nprogramming languages. However, for this paper, we target a speci.c subset of a Standard ML language, \nfor which we will be able to achieve B in future work with a ver\u00adi.ed compiler and runtime similar to \n[6], [9], or [33]. We call our ML subset MiniML and use SML syntax. 1.1 Example To illustrate what our \nsemantics preserving translation provides, assume that the user de.nes a summation function over lists \nusing foldl as follows:1 sum = foldl (.(x, y).x + y)0 This sum function lives in higher-order logic but \nfalls within the subset of the logic that corresponds directly to pure ML. As a result, we can translate \nsum into ML (like Poly/ML [28], our MiniML supports arbitrary precision integer arithmetic). val sum \n= foldl (fn (x,y) => x+y) 0 For each run, our translation process proves a certi.cate theo\u00adrem relating \nthe function in the logic, sum, to the abstract syntax of the ML function, sum, w.r.t. an operational \nsemantics of ML. For sum, this automatically derived certi.cate theorem states: when the closure that \nrepresents sum is applied to an argument of the right type, a list of numbers, then it will return a \nresult, a number, which ICFP 12, September 9 15, 2012, Copenhagen, Denmark. Copyright &#38;#169; 2012 \nACM 978-1-4503-1054-3/12/09 $15.00.  is exactly the same as the result of applying the HOL function \nsum to the same input. The challenge is to do this translation in an easily automated, mechanical manner. \nIn particular, one has to keep track of the re\u00adlationship between shallowly embedded values, e.g., mathematical \nfunctions, and deeply embedded values in the ML semantics, e.g., closures. Our solution involves re.nement/coupling \ninvariants and combinators over re.nement invariants.  1.2 Contributions The main contribution of this \npaper is a new technique by which functions as de.ned in higher-order logic (HOL) can be translated, \nwith proof, into pure ML equipped with an operational semantics. The ML-like subset of higher-order logic \nwe consider includes: total recursive functions,  type variables,  functions as .rst-class values, \n nested pattern matching and user-de.ned datatypes, and  partially speci.ed functions, e.g. those with \nmissing pattern match cases.  We also show how our translation technique can be extended with new translations \nfor user-de.ned operations and types. As an ex\u00adample, we show how to add support for translation of operations \nover .nite sets. This work improves on the current state of the art of program synthesis from theorem \nprovers (sometimes called program extrac\u00adtion, e.g. extract in Coq, emit-ML in HOL4 and code generation \nin Isabelle/HOL) by removing that step from the trusted computing base without requiring any additional \nwork from the user. We prove the trustworthiness of the translation with certi.cate theorems stat\u00ading \nthat the generated code has exactly the behaviour (including termination) of the original logic function \nfor all inputs where the original function is not partially speci.ed. We show that our technique is practical \nwith case studies from the HOL4 examples repository, and other examples from the litera\u00adture, including \nfunctional data structures, a parser generator, cryp\u00adtographic algorithms, and a garbage collector. Our \ntranslator, all of our examples, our semantics for MiniML, and its veri.ed metatheory are all available \nat http://www.cl. cam.ac.uk/~mom22/miniml/. 2. Synthesising Quicksort: an example Before explaining how \nour technique works, we .rst show what it does on a simple, but realistic, example: quicksort. Section \n4 presents several larger and more signi.cant examples. One can de.ne quicksort for lists in higher-order \nlogic as fol\u00adlows.2 Here ++ appends lists and partition splits a list into two: those elements that satisfy \nthe given predicate, and those that do not. (qsort R [] = []) . (qsort R (h :: t)= let (l1,l2)= partition \n(.y.R y h) t in (qsort Rl1)++[h]++(qsort Rl2)) Given this de.nition of the algorithm, one can use HOL \nto prove the correctness of quicksort: Theorem 1 (Quicksort correctness). Given a transitive, total rela\u00adtion \nR and a list l, qsort returns a sorted permutation of list l. 2 In fact, we are re-using Konrad Slind \ns veri.ed quicksort algorithm from HOL4 s library. Proof. Mechanically veri.ed in HOL4 s library: a textbook \nexer\u00adcise in program veri.cation. Note that this de.nition and proof could be (and indeed were) developed \nin HOL4 without any reference to an intended use of the ML synthesis technique presented in this paper. \nGiven quicksort s de.nition, our translator can then generate the AST for the following MiniML function \n(MiniML doesn t have built-in lists; the Nil, Cons, and append constructors and function come from translating \nthe HOL4 list library used by quicksort): fun qsortr=fn l=>caselof | Nil => Nil | Cons(h,t) => let valx \n= partition(fny=>ryh) tin case x of | Pair(l1,l2) => append (append (qsort r l1) (Cons(h,Nil))) (qsort \nr l2) end In the process of generating the above code, the translator also establishes a correspondence \nbetween MiniML values and HOL terms and proves the following theorem stating correctness of the translation. \nTheorem 2 (Certi.cate theorem for qsort). When given an ap\u00adplication of qsort to arguments corresponding \nto HOL terms, the MiniML operational semantics will terminate with a value that cor\u00adresponds to the application \nof HOL function qsort to those terms. Proof. Automatically proved as part of the translation, the details \nof which are the topic of this paper. This proof uses the induction theorem that arises from the de.nition \nof qsort in HOL [39]. We can use this automatically proved theorem to push the veri\u00ad.cation result for \nqsort (Theorem 1) to also apply to the generated MiniML code qsort: Theorem 3 (MiniML quicksort correctness). \nIf 1. qsort is bound in the MiniML environment to the implementa\u00adtion listed above, 2. leq_R is a value \nthat corresponds to a transitive, total HOL relation leq, and 3. unsorted_l is a value that corresponds \nto HOL list l,  then evaluation of MiniML program qsort leq_R unsorted_l terminates with a list value \nsorted_l that corresponds to the sorted HOL list (qsort leq l). Proof. Trivial combination of the two \ntheorems above. In summary, we have taken the quicksort algorithm, expressed as a de.nition in higher-order \nlogic and veri.ed in that setting, and we have generated a pure functional MiniML program and auto\u00admatically \nproved that it is correct, according to the operational se\u00admantics of MiniML. Note that the meaning of \nHOL s qsort func\u00adtion is in terms of the proof theory or model theory of higher-order logic, while the \nMiniML qsort function has an operational mean\u00ading, which is understood by ML compilers. 3. Overview of \napproach In this section, we give a tutorial introduction to our translation approach. Subsequent sections \nwill provide the details (Sect. 5), case studies (Sect. 4) and formal de.nitions (Sect. 6) that we omit \nin this section.  3.1 Basic judgements Our translation from HOL to MiniML derives certi.cate theorems \nstated in terms of a predicate called Eval (which is reminiscent of a logical relation). Eval env exp \npost Such statements are true if MiniML expression exp evaluates in environment env to some value x and \nthe postcondition post is true for this x, i.e. post x. Here env is a list of bindings: names are bound \nto MiniML values (as modelled in our semantics of MiniML), exp is abstract syntax for a MiniML expression \nand post is a function from MiniML values to bool. Typically, post will be instantiated with a re.nement \ninvariant relating a value from HOL to a MiniML value. An example of such an invariant is int. The relation \nint nv is true if integer n is represented in MiniML as value v. With this re.nement invariant we can \nstate that the deep embedding of MiniML expression 5 evaluates to 5 in HOL, as follows. We will denote \nMiniML abstract syntax trees of our MiniML language using SML syntax inside L\u00b7J. Eval env L5J (int 5) \n(1) We can similarly state that MiniML variable n evaluates to the value held in HOL integer variable \nn by writing: Eval env LnJ (int n) (2) From statements such as (1) and (2), we can derive properties \nof compound expressions, e.g. for addition of numbers: Eval env Ln+5J (int (n + 5)) (3) 3.2 Re.nement \ncombinator for functions The above examples considered simple MiniML expressions that produce concrete \nvalues. However, MiniML values can also be closures, such as produced by fnn =>n+5 To handle closures, \nwe want to combine the re.nement invari\u00adants for the input and for the output types; in this case both \nuse in\u00advariant int. To do this, we have a re.nement combinator, ., which takes two invariants, a and \nb, as arguments: a . b The statement (a . b) fv is true if the value v is a closure such that, when the \nclosure is applied to a value satisfying re.nement invariant input a, it returns a value satisfying output \nb; and further\u00admore, its input-output relation coincides with f. In other words, when evaluated v corresponds \nto evaluation of HOL function f. For example, (int . int)(.n. n + 5) v speci.es that v is a closure in \nMiniML which has an input-output relation corresponding to the HOL function .n. n +5. The . re.nement \ncombinator can be introduced using a rule for the MiniML closure constructor fn. For example, we can \nderive the following from statement (3) and its assumption on n, i.e. (2). Eval env Lfn n=> n+5J ((int \n. int)(.n. n + 5)) (4) Closures that are speci.ed using the . combinator can be ap\u00adplied to arguments \nof the corresponding input re.nement invari\u00adant . For example, we apply (4) to (1) to arrive at their \ncombination: Eval env L(fnn=>n+5) 5J (int ((.n. n + 5) 5)) 3.3 Type variables and functions as .rst-class \nvalues The above examples used int as a .xed type/invariant. So how do we translate something that has \nHOL type a, i.e. a variable type? Answer: for this we use a regular HOL variable for the invariant, e.g. \nwe can use variable a with HOL type: a . ml value . bool as the invariant. (Here and throughout ml value \nis the HOL datatype which models MiniML values in HOL as a deep embed\u00adding.) The HOL type of int is int \n. ml value . bool, i.e. all that we did was abstract the constant int to a variable a and, similarly \nin its type, we abstracted the type int to a. With this variable a ranging over all possible re.nement \ninvari\u00adants, we can state that MiniML variable x evaluates to HOL vari\u00adable x of type a as follows. Eval \nenv LxJ (ax) Similarly, we can use the invariant combinator from above to spec\u00adify that the MiniML value \nis some closure such that HOL function f of type a . a is an accurate representation in the HOL logic. \nEval env LfJ ((a . a) f) Since these statements are stated in terms of re.nement invari\u00adants and ., we \ncan apply the combinator rules mentioned above. For example, we can derive MiniML code corresponding \nto a HOL function .f x.f (fx) which has an abstract type involving a. Eval env Lfnf =>fnx =>f (fx)J (5) \n(((a . a) . a . a)(.f x.f (fx))) Evaluation of fn f=> fnx=> f(f x) results in the fol\u00adlowing closure \nin our semantics of MiniML:3 Closure env \"f\" Lfn x => f (f x)J If we assume that MiniML variable name \n\"twice\" is bound to this value in the evaluation environment env then we can prove, from (5), that the \nMiniML code twice evaluates to a closure with exactly the same behaviour as a HOL function de.ned by \ntwice = .f x.f (fx). env \"twice\" = Closure twice env ... =. (6) Eval env LtwiceJ (((a . a) . a . a) twice)) \nThis is the way we translate non-recursive functions into MiniML. The example above used variables in \nplace of some re.nement invariants. These variables can, of course, be instantiated when combined with \nEval-theorems of more speci.c types. For example, we can plug together (4) and (6) to derive: env \"twice\" \n= Closure ... =. Eval env Ltwice (fn n => n+5)J ((int . int)(twice (.n. n + 5))))  3.4 Recursive functions \nML code for non-recursive functions can be derived as shown above. However, recursive functions require \nsome additional effort. To illustrate why, consider the following de.nition of gcd. gcd mn = if 0 <n \nthen gcd n (m mod n) else m If we were to do exactly the same derivation for the right-hand side of the \nde.nition of gcd, we would get stuck. The algorithm that the examples above illustrate proceeds in a \nbottom-up manner: it traverses the structure of the HOL term for which we want to generate MiniML. When \ntranslating the right-hand side of a recursive function s de.nition, what are we to use as the Eval\u00addescription \nof the effect of applying the recursive call? At that stage we would like to have a theorem of the form: \n... =. Eval env LgcdJ ((int . int . int) gcd) In other words, we would like to assume what we set out \nto prove. Our solution is to make a more precise assumption: we formu\u00adlate the assumption in such a way \nthat it records for what values it was applied; we then discharge these assumptions using an induc\u00adtion \nwhich will be explained later.  We use a new combinator eq to record what values we have assumed that \nthe recursive call is applied to. The de.nition of eq, eq ax = .y v. (x = y) . ayv is explained in Section \n6.7 together with a more thorough explana\u00ad tion of this example. However, for now, read the following \nas saying that a call to MiniML gcd has exactly the behaviour of HOL gcd if it is applied to int inputs \nm and n. Eval env LgcdJ ((eq int m . eq int n . int) gcd) (7) For the rest of this example we abbreviate \n(7) as P mn. For the recursive call in gcd s right-hand side we can derive the following Eval-theorem. \nNote how the assumption P mentions exactly what values gcd was called with. P n (m mod n)=. Eval env \nLgcdn(m mod n)J (int (gcd n (m mod n))) By making this kind of assumption at every recursive call site, \nwe can proceed with our bottom-up derivation as before. The entire right-hand side of gcd produces the \nfollowing result: (0 <n =. P n (m mod n)) =. Eval env Lif0<n thengcd ...J (int (gcd mn)) We now proceed \nto package the right-hand side of gcd into a closure, very much as we did for twice above, except this \ntime we need a recursive closure (which is described in Section 6.2). We omit the details regarding recursive \nclosures here, but note that the result of this packaging is a theorem: env \"gcd\" = Recclosure ... Lif \n0< n ...J =. (8) .m n. (0 <n =. P n (m mod n)) =. P mn We now turn to the phase where we discharge the \nassumptions that were made at the call sites. For this we will use an induction principle which arises \nfrom the totality proof for gcd. All functions in HOL are total, and as a side product of de.nitions \nwe get an automatically proved induction scheme that is tailored to the structure of the recursion in \nthe de.nition. The induction scheme that comes out of the de.nition of gcd is: .P. (.m n. (0 <n =. Pn \n(m mod n)) =. P mn) (9) =. (.mn.P mn) Note that this induction scheme matches the structure of (8) precisely. \nThis means that, by one application of modus ponens of (8) and (9), we arrive at a theorem with a right-hand \nside: .m n. P mn. By expanding the abbreviation P (and some sim\u00adpli.cation to remove eq as explained \nin Section 6.8), we arrive at the desired certi.cate theorem for gcd: env \"gcd\" = Recclosure ... Lif \n0< n ...J =. Eval env LgcdJ ((int . int . int) gcd) To summarise: we use eq together with the custom \ninduction scheme that HOL gives us for each recursive de.nition to perform translations of recursive \nHOL functions.  3.5 Datatypes and pattern matching HOL provides ways of de.ning ML-like datatypes, e.g. \nthe list type can be de.ned as follows: datatype a list = Nil | Cons of a \u00d7 (a list) These datatypes \ncan be used in ML-like pattern matching. In the following text we will write Cons as :: and Nil as []. \nWe can support such datatypes in translations by de.ning a re.nement invariant for each datatype that \nis encountered. For a list, we de.ne list which takes a re.nement invariant a as an argument. We write \napplication of list in post-.x notation, i.e. a list, to make it look like a type. The de.nition of list \ncan be automatically produced from the datatype de.nition. Here Conv is a constructor-value from the \nMiniML semantics (as opposed to, say, a Closure value we saw previously). (a list)[] v =(v = Conv \"Nil\" \n[ ]) (a list)(x :: xs) v = .v1 v2. (v = Conv \"Cons\" [v1,v2]) axv1 . (a list) xs v2 Based on this de.nition, \nwe can derive lemmas (see Section 6.6) with which we can translate constructors and pattern matching \nfor this datatype. However, there is one trick involved: HOL functions that have pattern matching at \nthe top-level tend to be de.ned as multiple equations. For example, the map function is typically de.ned \nin HOL using two equations: map f [] = [] map f (x :: xs)= fx :: map f xs In the process of de.ning this \nin HOL, the theorem prover reduces the multi-line de.nition to a single line with a case statement: map \nf xs = case xs of ... It is these single-line de.nitions that we translate into MiniML functions with \nsimilar case statements. The translation of case statements will be explained in more detail in Section \n6.6.  3.6 Partial functions and under speci.cation The use of pattern matching leads to partiality.4 \nThe simplest case of this partiality is the de.nition of hd for lists, which is de.ned intentionally \nwith only one case: hd (x :: xs)= x This de.nition could equally well have been de.ned in HOL as: hd \nxs = case xs of [] . ARB | (x :: xs) . x using the special ARB5 constant in HOL, which cannot be trans\u00adlated \ninto MiniML. When translating a partial de.nition into MiniML, we can only prove a connection between \nMiniML and HOL for certain well\u00adde.ned input values. For this purpose we use eq from above to restrict \nthe possible input values. The theorem that relates hd to its MiniML counterpart includes a side-condition \nxs [] on the = input, which is applied via eq: (env \"hd\" = ...) . xs =[] =. Eval env LhdJ ((eq (a list) \nxs . a) hd) The generated MiniML code includes raise Error in the places where the translation is disconnected \nfrom the HOL func\u00adtion. hd xs = case xs of [] => raise Error | ... At the point in the derivation where \nwe require a MiniML value corresponding to ARB, we have a trivially true theorem with false on the left-hand \nside of an implication. false =. Eval env Lraise ErrorJ (a ARB) This false assumption trickles up to \nthe top level causing the side condition, xs = [] for hd. 4 All functions in HOL are total. However, \ntheir de.nitions can omit cases causing their equational speci.cation to appear partial. 5 ARB is de.ned \nnon-constructively using Hilbert s arbitrary choice opera\u00adtor.  Translation of recursive partial functions \nresults in recursive side conditions, e.g. the zip function is de.ned in HOL as: zip ([ ], []) = [] zip \n(x :: xs, y :: ys)=(x, y) :: zip (xs, ys) The side condition which is produced for zip is: zip side ([ \n], []) = true zip side ([ ],y :: ys)= false zip side (x :: xs, []) = false zip side (x :: xs, y :: ys)= \nzip side (xs, ys) These side conditions arise in the derivation as assumptions that are not discharged \nwhen the de.nition-speci.c induction is applied.  3.7 Equality types There is another source of partiality: \nequality tests. MiniML and HOL have different semantics regarding equality. In MiniML, equality of function \nclosures cannot be tested, while equality of functions is allowed in HOL. Whenever an equality is to \nbe trans\u00adlated, we use the following lemma which introduces a condition, EqualityType, on the re.nement \ninvariant a for the values that are tested. The de.nition of EqualityType is given in Section 6.4. Eval \nenv LxJ (ax) . Eval env LyJ (ay)=. EqualityType a =. Eval env Lx=yJ (bool (x = y)) In contrast to the \npartiality caused by missing patterns, this form of partiality is neater in that it applies to the re.nement \ninvariant, not the actual input values. For each datatype de.nition we attempt to prove a lemma which \nsimpli.es such equality type constraints, e.g. for the list invariant we can automatically prove: .a. \nEqualityType a =. EqualityType (a list) Such lemmas cannot always be proved, e.g. if the datatype contains \na function type.  3.8 User-de.ned extensions Our approach to supporting user-de.ned datatypes in Section \n3.5 involves machinery which automatically de.nes new re.nement invariants and proves lemmas that can \nbe used in the translation process. The same kind of extensions can also be provided by the user with \ncustom re.nement invariants and lemmas for types de.ned in ways other than datatype (e.g., a quotient \nconstruction). As a simple example, consider the following naive re.nement invariant for .nite sets represented \nas lists in MiniML: (a set) sv = .xs. (a list) xs v . (s = set from list xs) Using basic list operations \nwe can prove judgements that can be used for translating basic sets and set operations, e.g. {}, . and \n. are implemented by [], append and mem. The last one also depends on EqualityType a. Eval env L[]J ((a \nset) {}) Eval env LxJ ((a set) x) . Eval env LyJ ((a set) y)=. Eval env Lappend x yJ ((a set)(x . y)) \nEval env LrJ (ar) . Eval env LxJ ((a set) x)=. Eval env Lmem r xJ (bool (r . x)) The example above is \nnaive and can potentially produce very inef.cient code. However, the basic idea can be applied to more \nef.cient data structures, e.g. the datatypes presented in Okasaki s book on functional data structures \n[36]. We have implemented extensions which can deal with .nite sets, .nite maps, natural numbers and \nn-bit machine arithmetic. 4. Case studies Our translation is implemented (Section 5.1) as an ML program \nthat operates over the HOL4 prover s internal representation of higher\u00adorder logic terms, producing HOL4 \ntheorems about MiniML pro\u00adgrams (whose semantics we have formally speci.ed in HOL4, see Section 6.2). \nTo demonstrate that it is robust, we have successfully applied it to the following algorithms: Miller-Rabin \nprimality test (by Hurd [16]) This example uses higher-order, recursive, and partial func\u00adtions, and \nit requires that all three of these aspects be handled simultaneously.  An SLR parser generator (by \nBarthwal [2]) This is non-trivial algorithm with a long de.nition: 150 lines in HOL. Its de.nition makes \nuse of pattern matching.  AES, RC6 and TEA private key encryption/decryption algo\u00adrithms (veri.ed by \nDuan et al. [11]) These algorithms operate on .xed-size word values, which we support through the technique \nfor user-de.ned extensions (Sec\u00adtion 3.8). We represent .xed-size words as integers in MiniML and use \na re.nement invariant to make sure the correspondence is maintained.  McCarthy s 91 function, quicksort \n(by Slind [39]), and a regu\u00ad lar expression matching function (by Owens [37]) The 91 function and regular \nexpression matcher both have intri\u00adcate totality proofs, but our technique can easily and automat\u00adically \nprove termination based on the HOL-provided induction principles (which were justi.ed by the original \ntotality proofs).  A copying Cheney garbage collector (by Myreen [31]) This is a model of Cheney s algorithm \nfor copying garbage collection a veri.ed algorithm used in constructing a veri.ed Lisp runtime [33]. \nIt models memory as a mapping from natural numbers to a datatype of abstract memory values.  Functional \ndata structures from Okasaki s book [36]  heap datatypes: leftist, pairing, lazy, splay, binomial set \ndatatypes: unbalanced, red-black sorting algorithms: merge sort list datatypes: binary random-access \nlists queues datatypes: batched, bankers, physicists, real-time, implicit, Hood-Melville The algorithms \nfrom all but the last point above have been pre\u00adviously veri.ed in HOL4. We have veri.ed 13 of the 15 \nfunctional data structures from the last point. These data structures are the examples that Chargu\u00b4eraud \n[4] uses for his characteristic formula technique (except that we omit the bootstrapped heap and catenable \nlist whose datatypes are not supported by HOL s datatype package). Compared with Chargu\u00b4 eraud s veri.cation \nproofs, ours are similar in length. However, Chargu\u00b4 eraud had to use special purpose tactics to deal \nwith his characteristic formulae. In contrast, our veri.cation proofs use only conventional HOL4 tactics. \nSee the related work section for further comparison. 5. Algorithm We have thus far omitted details and \nexplained our approach through examples. Here, and in the next section, we provide formal de.nitions \nand explain that technicalities that earlier text avoided. We start with an outline of the algorithm \nfor translation. Our method translates one top-level function de.nition at a time. Each function is translated \nusing the following automatic steps:  Information retrieval. The initial phase collects the necessary \nin\u00adformation about the function, e.g. is it a constant de.nition, is it recursive? If it is recursive \nthen the induction theorem associ\u00adated with its de.nition is fetched from the context. Preprocessing. \nThe next step prepares the de.nition for transla\u00adtion: the de.nition is collapsed to a single top-level \nclause, as mentioned in Section 3.5, and certain implicit pattern matching is rewritten into explicit \npattern matching, e.g. .(x, y). body is expanded into .x. case x of (x, y) . body. For the rest of this \nsection, assume that the de.nition is now of the form: f x1 x2 ... xn = rhs Bottom-up traversal. The \nnext phase takes the right-hand side of the de.nition to be translated and constructs an Eval-theorem, \nas demonstrated in Section 3. This theorem is derived through a bottom-up traversal of the HOL expression. \nAt each stage the proof rule or lemma which is applied introduces the correspond\u00ading MiniML syntax into \nthe Eval-theorem. The result of this traversal is a theorem where the right-hand side of the HOL function \nappears together with its derived MiniML counterpart. assumptions =. Eval env derived code (inv rhs) \nThe next phases attempt to discharge the assumptions. Trivial assumptions, such as some EqualityType \nassumptions, can be discharged as part of the bottom-up traversal. Packaging. The next phase reduces \nthe rhs to the function con\u00adstant f. To do this, rules are applied which introduce a . for each formal \nparameter, and then perform the following simpli\u00ad.cation on the right-hand side: the de.nition is collapsed \nand eta conversion is performed. .x1 x2 . . . xn. rhs = .x1 x2 . . . xn. f x1 x2 . . . xn = f Introduction \nof . in the right-hand side of the HOL expression introduces closures on the MiniML side. For recursive \nfunc\u00adtions, the .nal closure lemma is a special rule for introducing a recursive closure, explained in \nSection 6.5. Induction. For recursive functions, the induction theorem associ\u00adated with the function \nde.nition is used to discharge the as\u00adsumptions that were made at the recursive call sites. The as\u00adsumptions \nthat the induction theorem fails to discharge are col\u00adlected and de.ned to be a side-condition. Such \nside conditions usually arise from partiality in pattern matching (Section 3.6). Simpli.cation. As mentioned \nin Section 3.4, after the induction theorem has been applied the resulting theorem contains redun\u00addant \noccurrences of the eq combinator. These are removed us\u00ading rewriting as explained in Section 6.8. Future \nuse. Once the translation is complete, the certi.cate theo\u00adrem is stored into the translator s memory. \nFuture translations can then use this certi.cate theorem in their Bottom-up traver\u00adsal phase, when function \nconstant f is encountered. 5.1 Implementation Implementing the above algorithm in a HOL theorem prover \nis straightforward. One writes an ML program which performs the proof steps outlined above. Concretely, \nthis involves writing ML functions that construct elements of type thm using the logical ker\u00adnel s primitives \n(which correspond to axioms and inference rules of higher-order logic). Following the LCF-approach, this \ndesign en\u00adsures that all proved theorems are the result of the basic inference rules of higher-order \nlogic. t := a | tc | (t1,...,tn)tc | t1 . t2 p := x | Cp1 ...pn e := x | ARB | Ce1 ...en | .x.e | e1 \ne2 | e1 = e2 | e1 . e2 | e1 . e2 | if e1 then e2 else e3 | let x = e1 in e2 | case e of p1 . e1 | ... \n| pn . en c := C | C of t1 . ... . tn d := x1 = c11 | ... | c1n1 ; ... ; xm = cm1 | ... | cmnm | (x1 \np11 ...p1n1 = e1) . ... . (xm pm1 ...pmnm = em) where x ranges over identi.ers, C over constructor names, \nand tc over type constructor names Figure 1. Core HOL source grammar t := ... | bool | int | num | char \n| t1 \u00d7 t2 | t list | t option p := ... | T | F | Z| N| (p1,p2) | [] | p1 :: p2 | SOME p1 | NONE e := \n... | T | F | Z| N| (e1,e2) | [] | e1 :: e2 | SOME e1 | NONE Figure 2. HOL source grammar after prelude \nextension We have implemented our translator in the HOL4 theorem prover. Source code and examples are \navailable at: http://www.cl.cam.ac.uk/~mom22/miniml/ 6. Technical details This section dives into some \ntechnical details. We provide de.ni\u00adtions and descriptions of the lemmas that are used as part of trans\u00adlations. \n6.1 HOL source language Figure 1 gives the subset of HOL de.nitions d that we can trans\u00adlate. This grammar \ndescribes a subset of the HOL4 logic, it is not deeply embedded in HOL4, nor do we formally reason about \nit. It includes (possibly mutually) recursive, higher-order functions that operate over (possibly mutually) \nrecursive, user-de.ned datatypes. The translation will fail if it encounters a term not in this subset \n(e.g. universal and existential quanti.ers, Hilbert s choice) in the de.nitions being translated. The \ntranslator comes with a standard prelude that includes support for booleans, integers, natural num\u00adbers, \ncharacters, pairs, lists, and options (Figure 2).  6.2 MiniML target language Figure 3 gives the source \ngrammar for MiniML types t, values v, patterns p, expressions e, type de.nitions td/c and top-level de.ni\u00adtions \nd. The language is a mostly unsugared subset of core Standard ML. It includes mutually recursive datatype \nde.nitions; higher\u00adorder, anonymous, and mutually recursive functions; nested pattern matching; and abrupt \ntermination (a simpli.ed raise). MiniML integers are arbitrary precision (which is how the Poly/ML com\u00adpiler \nimplements integers natively, other ML implementations usu\u00adally support them as a library). Unsupported \nfeatures are records, mutable references, exception handling, and the module system. We give MiniML both \nsmall-step and big-step call-by-value operational semantics, and a type system. Each of these three has \nan expression-level and de.nition-level component; here we only present the expression level, but see \nhttp://www.cl.cam.ac. uk/~mom22/miniml/ for complete de.nitions as well as HOL4 proofs of the theorems \nbelow, at both levels. The type system is typical. Figure 4 gives the auxiliary de.nitions needed to \nsupport the semantics (in this .gure we abbreviate ml value to v), and Figure 5 gives the shapes of the \nvarious semantic relations.  t := a | x | (t1, ... ,tn)x | t1 -> t2 | int | bool v := C | true | false \n| Z p := x | v | C(p1, ... ,pn) e := raise ex | x | v | C(e1, ... ,en) | fn x => e | e1 e2 | e1 op e2 \n| e1 andalso e2 | e1 orelse e2 | if e1 then e2 else e3 | case e of p1 => e1 | ... | pn => en | let val \nx = e1 in e2 end | let fun x1 y1 = e1 and ... and xn yn = en in e end c := C | C of t1 * ... * tn td \n:= (a1, ... ,am) x = c1 | ... | cn | x = c1 | ... | cn d := val p = e | fun x1 y1 = e1 and ... and xn \nyn = en | datatype td1 and ... and tdn ex := Bind | Div op := = | + | -| * | div | mod | < | <= | > \n| >= where x and y range over identi.ers and C over constructor names Figure 3. MiniML source grammar \n:= C(v1, ... ,vn) |(env, x, e) |(env, (fun x1 y1 = e1 and ... and xn yn = en),x) | C | true | false | \nZ F := [] e | v [] | [] op e | v op [] | [] andalso e | [] orelse e | if [] then e2 else e3 | case [] \nof p1 => e1 | ... | pn => en | let val x = [] in e end | C(v1, ... ,vn,[],e1, ... ,en) S := (Cenv, env, \ne, (F1, env1) ... (Fn, envn)) Rmatch := env | no match | type error Rstep := S | type error | stuck Reval \n:= v | raise ex | type error where env ranges over .nite maps from x to v, Cenv ranges over .nite maps \nfrom C to (N, 2C ). envT ranges over .nite maps from x to (a1,...,an) t, and CenvT ranges over .nite \nmaps from C to ((a1,...,am),t1 ...tn,x) Figure 4. Semantic auxiliaries for MiniML The small-step semantics \nis a CEK-like machine [12] (see [13] for a textbook treatment) with states S (Figure 4) using a contin\u00ad \nuation stack built from frames F and environments env. Values are extended with constructed values (e.g., \nSome(1)), with closures pairing a function s environment, parameter, and body, and with re\u00adcursive closures \npairing an environment with a mutually recursive nest of functions. A single reduction step either gives \na new state, signals a type error , e.g., due to a misapplied primitive, or gets stuck (Rstep ). We use \nthe small-step semantics to support a type soundness proof via preservation and progress [41], and to \nensure a satisfactory treatment of divergence. Small-step evaluation and divergence are de.ned in terms \nof the transitive closure of the re\u00adduction relation. Our technique for translating from HOL to MiniML \nuses a bottom-up, syntax-directed pass, and so requires a syntax-directed big-step semantics. The big-step \nsemantics returns the same kind of things as small-step evaluation: values, exceptions and type er\u00adrors \n(Reval ). We ensure that it gives type errors in enough cases so Pattern matching: (Cenv, p, v, env). \nRmatch Small-step reduction: S -. Rstep Small-step evaluation: S . Reval Small-step divergence: (Cenv, \nenv,e). Big-step evaluation: (Cenv, env,e). Reval Alternate big-step evaluation: (env,e). Reval Typing: \n(CenvT , envT)f e : t Typing for environments: Cenv f env : envT Figure 5. MiniML semantic relations \nthat only diverging expressions are not related to any result. This allows us to use (in our non-concurrent, \ndeterministic setting) an in\u00adductive relation, instead of following a co-inductive approach [21]. Theorems \n4 and 6 guarantee this property.  6.3 MiniML metatheory Theorem 4 (Small-step/big-step equivalence). \n(Cenv, env,e, E). Reval iff (Cenv, env,e). Reval . Proof. In HOL4. Forward implication: We .rst extend \nstack inputs, Fs We then show the that bi:= if g-step relation with (F1, env1) . . . (Fn, (Cenv1, env1, \ne1, Fs1) context envn). -. (Cenv2, env2,e2, Fs2) and (Cenv2, env2,e2, Fs2). Reval then (Cenv1, env1,e1, \nFs1). Reval by cases on the small\u00adstep relation. We then .nish the proof by induction on the transitive \nclosure of -.. Note that unlike type soundness, we go backwards along the small-step trace; this is necessary \nto properly handle non-termination. Reverse implication: By induction on the big-step relation, with \npervasive reasoning about adding context frames to the frame stacks of many-step small-step reduction \nsequences. Theorem 5 (Big-step determinism). If (Cenv, env,e). Reval 1 and (Cenv, env,e). Reval 2 then \nReval 1 = Reval 2. Proof. In HOL4, by induction on the big-step evaluation relation. Corollary 1 (Small-step \ndeterminism). If (Cenv, env,e, E). Reval 1 and (Cenv, env,e, E). Reval 2 then Reval 1 = Reval 2. Theorem \n6 (Untyped safety). (Cenv, env,e, E). Reval iff it is not the case that (Cenv, env,e).. Proof. In HOL4, \nby cases on the small-step relation. Theorem 7 (Type soundness). If Cenv and CenvT are well-formed and \nconsistent,  CenvT f env : envT , and  (CenvT , envT)f e : t  then either (Cenv, env,e)., or  (Cenv, \nenv,e, E). Reval and Reval = type error.   The small-and big-step semantics are given a Cenv which \nal\u00adlows them to return type error when an unde.ned data construc\u00adtor (i.e., one not de.ned in a datatype \nde.nition) is applied, or when a data constructor is applied to the wrong number of argu\u00adments. However, \nwe can simplify the translation from HOL by us\u00ading an alternate big-step semantics that omits this argument. \nThis alternate big-step semantics differs only in that mis-applied con\u00adstructors are accepted and do \nnot result in an error. However, they coincide on well-typed programs. Theorem 8 (Alternate big step \nequivalence). If Cenv and CenvT are well-formed and consistent, and CenvT f env : tenv and (CenvT, envT \n)f e : t then (Cenv, env,e). Reval iff (env,e). Reval . Proof. In HOL4, by induction on the big-step \nrelation, and Theo\u00adrems 6 and 7 and Corollary 1.  6.4 Key de.nitions As described in earlier sections, \nour translation makes statements about the semantics in terms of a predicate called Eval. We de.ne this \npredicate as follows using the alternate big-step semantics evaluation relation .. We de.ne Eval env \nexp post to be true if exp evaluates, in environment env, to some value v such that post v. The fact \nthat it returns a value as opposed to an error, raise ex tells us that no error happened during evaluation, \ne.g. evaluation did not hit any missing cases while pattern matching. Eval env exp post = .v. (env, exp). \nv . post v Here post has type ml value . bool. The interesting part is what we instantiate post with, \ni.e. the re.nement invariants. The basic re.nement invariants have the fol\u00adlowing de.nitions. Boolean \nand integer values relate to correspond\u00ading literal values in the MiniML semantics: bool true = .v. (v \n= true) bool false = .v. (v = false) int i = .v. (v = i) where i . Z We also have combinators for re.nement \ninvariants. The de.ni\u00adtion of the eq combinator was given in Section 3.4. We now turn to the . combinator \nwhich lifts re.nement invariant to closures. The . combinator s de.nition is based on an evaluation relation \nfor application of closures, evaluate closure (which is de.ned in terms of ., and applies to non-recursive \nand recursive closures). Read evaluate closure v cl u as saying: application of closure cl to argument \nv returns value u. We de.ne a total-correctness Hoare\u00adtriple-like Spec for closure evaluation on top \nof this: Spec p cl q = .v. pv =..u. evaluate closure v cl u . qu The de.nition of the . combinator is \nan instance of Spec, where an abstract value x is universally quanti.ed: (a . b) f = .v. .x. Spec (ax) \nv (b (fx)) Here the type of f is a . \u00df and the type of v is simply the type of a MiniML value in our \nMiniML semantics, i.e. ml value. The remaining de.nition is that of EqualityType a. A re.ne\u00adment invariant \na supports equality if the corresponding MiniML value cannot be a closure, not contains closure, and \ntesting for structural equality of MiniML values is equivalent to testing equal\u00adity at the abstract level: \nEqualityType a = (.xv. axv =. not contains closure v) . (.xvyw. axv . ayw =. (v = w .. x = y)) For example, \nbool and int, de.ned above, satisfy EqualityType.  6.5 Lemmas used in translations In this section we \npresent the lemmas about Eval that are used to perform the translations. All variables in these theorems \nare implicitly universally quanti.ed at the top-level. The proof of these lemmas follow almost directly \nfrom the underlying de.nitions: none of the proofs required more than ten lines of script in HOL4. Closure \napplication. We start with the rule for applying a closure. A closure a . b can always be applied to \nan Eval-theorem with a matching re.nement invariant a. Eval env LfJ ((a . b) f ) . Eval env LxJ (ax)=. \nEval env LfxJ (b (fx)) Closure introduction. Closures can be created with the following rule if the abstract \nand concrete values, x and v, which the body depends on can be universally quanti.ed. Here n . v extends \nthe environment env with binding: name n maps to value v. (.x v. a x v =. Eval (env[n . v]) LbodyJ (b \n(fx))) =. Eval env Lfn n => bodyJ ((a . b) f ) Alternative closure introduction. The rule above is not \nalways applicable because side conditions restrict the variable x, i.e. the universal quanti.cation cannot \nbe introduced. This is an al\u00adternative rule which achieves the same without universal quan\u00adti.cation \nof x at the cost of introducing the eq combinator. (.v. a x v =. Eval (env[n . v]) LbodyJ (b (fx))) \n=. Eval env Lfn n => bodyJ ((eq ax . b) f) Closure evaluation. The translator always returns theorems \nwhere the code is described by an assumption stating that the function name refers to the relevant code \nin the environment, i.e. an as\u00adsumption of the form env name = closure ... . The follow\u00ading rule is used \nfor deriving theorems with such assumptions for non-recursive closures: Eval cl env Lfn n => bodyJ p \n=. env name = Closure cl env n LbodyJ =. Eval env LnameJ p Introduction of recursive closure. Our rule \nfor introducing recur\u00adsive closures, i.e. closures where the environment can refer to it\u00adself and hence \nperform recursive function calls to itself, is more verbose. Introduction of recursive closures is done \nusing the following lemma. For this lemma to be applicable some name name must refer to a recursive closure \nwhere name is given. Let Recclosure cl env [(name, n, LbodyJ)] name be abbre\u00adviated by Rec below. (.v. \na x v =. Eval (env[n . v, name . Rec]) LbodyJ (b (fx))) =. env name = Rec =. Eval env LnameJ ((eq ax \n. b) f) Let introduction. Let-statements are constructed using the follow\u00ading lemma. Here let is HOL \ns internal combinator which repre\u00adsents let expressions. In HOL, let fx = fx and the HOL printer knows \nto treat let as special, e.g. let (.a. a + 1) x is printed on the screen as let a = x in a +1. Eval env \nLxJ (ax) . (.v. a x v =. Eval (env[n . v]) LbodyJ (b (fx))) =. Eval env Llet val n = x in body endJ (b \n(let fx)) Variable simpli.cation. During translation, the intermediate theo\u00adrems typically contain assumptions \nspecifying which HOL val\u00adues relate to which MiniML values. It s convenient to state these as Eval env \nLmJ (inv n), for some inv and some .xed vari\u00adable name m. When variables get bound, e.g. as a result \nof in\u00adtroducing a closure, env is specialised and these assumptions can be simpli.ed. We use the following \nlemma to simplify the assumptions when env gets specialised.  Eval (env[name . v]) LmJ p = if m = name \nthen pv else Eval env LmJ p If statements. The translation of HOL s if statements is done using the following \nrule. Note that the assumptions h2 and h3 get pre.xed by the guard expression x1. (h1 =. Eval env Lx1J \n(bool x1)) . (h2 =. Eval env Lx2J (inv x2)) . (h3 =. Eval env Lx3J (inv x3)) =. (h1 . (x1 =. h2) . (\u00acx1 \n=. h3)) =. Eval env Lif x1 then x2 else x3J (inv (if x1 then x2 else x3)) Literal values. MiniML has \nboolean and integer literals. The rele\u00advant lemmas for such literals: Eval env LtrueJ (bool true) Eval \nenv LfalseJ (bool false) Eval env LiJ (int i) where i . Z Binary operations. Each of the operations over \nthe integers and booleans have separate lemmas. A few examples are listed below. Division and modulo \nhave a side condition. Eval env LiJ (int i) . Eval env LjJ (int j)=. Eval env Li+jJ (int (i + j)) Eval \nenv LiJ (int i) . Eval env LjJ (int j)=. j =0 =. Eval env Li div jJ (int (i div j)) Eval env LiJ (int \ni) . Eval env LjJ (int j)=. Eval env Li<jJ (bool (i<j)) Eval env LaJ (bool a) . Eval env LbJ (bool b)=. \nEval env La andalso bJ (bool (a . b)) There are also dynamically derived lemmas, e.g. each translation \nresults in a new lemma that can be used in subsequent translations and datatype de.nitions result in \na few lemmas (as described in the next section). Users can also manually provide additional lemmas. \n 6.6 Lemmas automatically proved for datatypes For each datatype, we de.ne a re.nement invariant that \nrelates it to ML values. Type variables cause these de.nitions to take re.nement invariants as input. \nFor example, for the list datatype from Section 3.5 we de.ne a re.nement invariant, called list, as the \nfollowing map into constructor, Conv, applications in MiniML. We write application of list in post-.x \nnotation, i.e. a list, to make it look like a type. (a list) [] v =(v = Conv \"Nil\" [ ]) (a list)(x :: \nxs) v = .v1 v2. (v = Conv \"Cons\" [v1,v2]) axv1 . (a list) xs v2 Based on this de.nition we can derive \nlemmas that aid transla\u00adtion of constructor applications in HOL. Eval env LNilJ ((a list) []) Eval env \nLxJ (ax) . Eval env LxsJ ((a list) xs)=. Eval env LCons(x,xs)J ((a list)(x :: xs)) We also derive lemmas \nwhich aid in translating pattern match\u00ading over these HOL constructors. As mentioned in Section 3.5, \nmulti-line pattern matches, i.e. HOL de.nitions that are de.ned as multiple equations, are merged into \na single line de.nition with a case statement by the de.nition mechanism. By making sure trans\u00adlations \nare always performed only on these collapsed single line de.nitions, it is suf.cient to add support for \ntranslations of case statements for the new datatype: case l of [] . ... | (x :: xs) . ... In HOL, case \nstatements (including complicated-looking nested case statements) are internally represented as primitive \ncase func\u00adtions . The case function for the list datatype is de.ned using the following two equations: \nlist case [] f1 f2 = f1 list case (x :: xs) f1 f2 = f2 x xs Thus, in order to translate case statements \nfor the list datatype, it is suf.cient to be able to translate any instantiation of list case lf1 f2. \nThe lemma which we use for this is shown below. This lemma can be read as a generalisation of the lemma \nfor translating closure introduction and if statements. (h0 =. Eval env LlJ ((a list) l)) . (h1 =. Eval \nenv LyJ (bf1)) . (.x xs v vs. axv . (a list) xs vs . h2 x xs =. Eval (env[n . v][m . vs]) LzJ (b (f2 \nx xs))) =. (.x xs. h0 . ((l = []) =. h1) . ((l = x :: xs)=. h2 x xs)) =. Eval env Lcase lof Nil =>y |Cons(n,m)=> \nzJ (b (list case lf1 f2))  6.7 Translation of recursive functions The most technical part of our approach \nis the details of how re\u00adcursive functions are translated. In what follows, we expand on the gcd example \ngiven in Section 3.4 and explain our use of induction and eq in more detail. gcd mn = if 0 <n then gcd \nn (m mod n) else m As was already mentioned, when such a function is to be trans\u00adlated, we perform the \nbottom-up traversal (Section 5) for the right\u00ad hand side of the de.nition. When doing so we encounter \nthe recur\u00adsive call to gcd for which we need an Eval theorem. In this theorem we need to make explicit \nwith what values we make the recursive call. For this purpose we use the eq combinator eq ax = .y v. \n(x = y) . ayv which when used together with . restricts the universal quanti.er that is hidden inside \nthe . function combinator. One can infor\u00admally read, re.nement invariant int . ... as saying for any \nint input, . . . . Similarly, eq int i . ... can be read as for any int input equal to i, . . . , which \nis the same as for int input i, ... .  For the rest of this example we abbreviate (10) as P mn. In order \nto derive an Eval theorem for the expression gcd n (m mod n), we .rst derive an Eval theorem argument \nn Eval env LnJ (int n)=. Eval env LnJ (int n) and an Eval theorem argument m mod n Eval env LmJ (int \nm) . Eval env LnJ (int n) . n =0 =. Eval env Lm mod nJ (int (m mod n)) Next, we use the following rule \nto introduce eq combinators to the above theorems .a x m. Eval env m (ax)=. Eval env m ((eq ax) x) and \nthen we apply to Closure application rule from Section 6.5 to get an Eval theorem for gcd n (m mod n). \nEval env LmJ (int m) . P n (m mod n) . Eval env LnJ (int n) . n =0 =. Eval env Lgcdn(m modn)J (int (gcd \nn (m mod n))) By then continuing the bottom-up traversal as usual and pack\u00adaging up the right-hand side \nfollowing the description in Section 5, we arrive at the following theorem where our abbreviation P ap\u00adpears \nboth as an assumption and as the conclusion. env \"gcd\" = Recclosure ... Lif 0< n ...J =. (11) .m n. (0 \n<n =. P n (m mod n)) =. P mn Note that the shape of the right-hand side of the implication matches the \nleft-hand side of the following induction which HOL provides as a side product of proving totality of \nthe gcd function. .P. (.m n. (0 <n =. Pn (m mod n)) =. P mn) (12) =. (.mn.P mn) By one application of \nmodus ponens of (11) and (12), we arrive at a theorem with a right-hand side: .m n. P mn. By expanding \nthe abbreviation P and some simpli.cation to remove eq (explained in the next section), we arrive at \nthe desired certi.cate theorem for the gcd function: env \"gcd\" = Recclosure ... Lif 0< n ...J =. Eval \nenv LgcdJ ((int . int . int) gcd) The gcd function is a very simple function. However, the tech\u00adnique \nabove is exactly the same even for functions with nested re\u00adcursion (e.g. as in McCarthy s 91 function) \nand mutual recursion (in such cases the induction has two conclusions). We always use the eq combinator \nto record input values, then apply the induction arising from the function s totality proof to discharge \nthese assump\u00adtions and .nally rewrite away the remaining eq combinators as de\u00adscribed in the next section. \n 6.8 Simpli.cation of eq Our gcd example in Section 3.4 glossed over how eq combinators are removed. \nIn this section, we expand on that detail. When translating recursive functions, we use the eq combinator \nto record what values we instantiate the inductive hypothesis with. Once the induction has been applied, \nwe are left with an Eval-theorem which is cluttered with these eq combinators. The theorems have this \nshape: .x1 x2 ... xn. Eval env code ((eq a1 x1 . eq a2 x2 . ... . eq an xn . b) func) Next, we show how \nthese eq combinators can be removed by rewriting. First, we need two new combinators. The examples be\u00adlow \nwill illustrate their use. A ayv = .x.axy v E ayv = .x.axy v We use these combinators to push the external \n. inwards. The following rewrite theorem shows how we can turn an external . into an application of the \nA combinator. Here (Ax. p x) is an abbreviation for A (.x. p x). (.x. Eval env code ((px) f)) = (13) \nEval env code ((Ax. p x) f) Once we have introduced A, we can push it through . using the following two \nrewrite theorems. Ax. (a . px)=(a . (Ax. p x)) (14) Ax. (px . a) = ((Ex. p x) . a) (15) These rewrites \npush the quanti.ers all the way to the eq combina\u00adtors. We arrive at a situation where each eq combinator \nhas an E quanti.er surrounding it. Such occurrences of E and eq cancel out Ex. eq ax = a leaving us with \na theorem where all of the eq, A and E combinators have been removed: Eval env code ((a1 . a2 . ... . \nan . b) func) The proofs of (13) and (14) require that the underlying big\u00ad step operational semantics \nis deterministic. This requirement arises from the fact that these lemmas boil down to an equation where \nan existential quanti.er is moved across a universal quanti.er. .x. .v. (env, code). v . ... = .v. (env, \ncode). v ..x. ... Such equations can be proved if we assume that . is deterministic since then there \nis only one v that can be chosen by the existential quanti.er. Note that the de.nition of Eval in Section \n6.4 would not have had its intended meaning if the operational semantics had been genuinely non-deterministic. \n7. Related work There is a long tradition in interactive theorem proving of using log\u00adics that look like \nfunctional programming languages: notable exam\u00adples include LCF [30], the Boyer-Moore prover [3], the \nCalculus of Constructions [8], and TFL [19, 39]. The logic of the Boyer-Moore prover (and it successor, \nACL2 [18]) are actual program\u00ad ming languages with standard denotational or operational seman\u00adtics. However, \nmany other systems, including Coq [7] and various HOL systems [35] (including Isabelle/HOL [17] and HOL4 \n[15]), use a more mathematical logic with model-theoretic or proof\u00adtheoretic semantics that differ from \nstandard programming lan\u00adguages, e.g. the logics of HOL systems include non-computational elements. However, \nbecause these logics are based on various .\u00adcalculi, they still resemble functional languages. A contribution \nof our work is to make this resemblance concrete by showing how (computable) functions in these logics \ncan be moved to a language with a straight-forward operational semantics while provably pre\u00adserving their \nmeaning. Slind s TFL library for HOL [39] and Krauss extensions [19] make HOL s logic (which is roughly \nChurch s simple theory of types) look like a functional language with support for well\u00adfounded general \nrecursive de.nitions and nested pattern matching. We rely on TFL to collapse multi-clause de.nitions \nand to simplify pattern matching expressions (Sections 6.6 and 3.5). Extraction from Coq [22] has two \nphases. First, purely logical content (e.g., proofs about the de.nitions) are removed from the de.nitions \nto be extracted, then the remaining, computational con\u00adtext is printed to a programming language. The \n.rst step is theoret\u00adically well-justi.ed; the second operates much as in HOL provers and is what we \naddress in this paper.  ACL2 uses a .rst-order pure subset of Common Lisp as its logic, thus there is \nno semantic mismatch or need to perform ex\u00adtraction; logical terms are directly executable in the theorem \nprover. However, a translation technique similar to the one described in this paper can be of use when \nverifying the correctness of such theorem provers (including the correctness of their re.ection mechanisms), \nas we did in previous work [10] using [32]. Proof producing synthesis has previously been used in HOL \nfor various low-level targets including hardware [40] and assembly\u00ad like languages [24 26]. These systems \nimplement veri.ed compil\u00ad ers by term rewriting in the HOL4 logic. They apply a series of rewriting theorems \nto a HOL function yielding a proof that it is equivalent to a second HOL function that uses only features \nthat have counterparts in the low-level language. Only then do they take a step relating these low-level \nHOL functions to the low-level language s operational semantics. This approach makes it easy to implement \ntrustworthy compiler front-ends and optimisations, but signi.cantly complicates the step that moves to \nthe operational set\u00adting. In contrast, we move to (MiniML s) operational semantics im\u00admediately, which \nmeans that any preconditions we need to gener\u00adate are understandable in terms of the original function, \nand not phrased in terms of a low-level intermediate language. This is why we can easily re-use the HOL-generated \ninduction theorems to au\u00adtomatically prove termination. In the other direction, proof producing decompilation \ntech\u00adniques [23, 34] have addressed the problem of reasoning about low\u00ad level machine code by translating \nsuch code into equivalent HOL functions; however, these functions retain the low-level .avour of the \nmachine language. Chargu\u00b4eraud s characteristic formulae approach also addresses translation in the other \ndirection, from OCaml to Coq [4], and it can support imperative features [5]. With his technique, an \nOCaml pro\u00ad gram is converted into a Coq formula that describes the program s behaviour, and veri.cation \nis then carried out on this formula. His approach tackles the problem of verifying existing OCaml pro\u00adgrams, \nwhich in particular requires the ability to handle partial functions and side effects. In contrast, this \npaper is about gener\u00adating, from pure functional speci.cations, MiniML programs that are correct by construction. \nPart of our approach was inspired by Chargu\u00b4eraud s work, in particular our Eval predicate was inspired \nby his AppReturns predicate. 8. Future work In this paper, we show how to create a veri.ed path from \nthe the\u00adorem prover to an operational semantics that operates on abstract syntax trees. We have not attempted \nto solve the problem of veri.ed parsing or pretty printing. Ultimately, we want a veri.ed compiler that \nwill be able to accept abstract syntax as input, avoiding the problem altogether. However, it would still \nbe useful to verify a translation from ASTs to concrete syntax strings for use with other compilers. \nWe have implemented our technique in HOL4 for translation to MiniML; however, we believe it would work \nfor other target languages, so long as they both support ML-like features and can be given big-step semantics. \nHaskell support should be straightfor\u00adward; laziness poses no problems because we are already proving \ntermination under a strict semantics. We do rely on determinism of the big-step semantics for the quanti.er \nshifting used in eq combi\u00adnator removal (Section 6.8), but most languages that do not de.ne evaluation \norder (e.g., Scheme, OCaml) should be able to support a deterministic semantics for the pure, total subset. \nOur technique should also extend to other provers, including Isabelle/HOL and Coq. For function de.nitions \nthat are in the ML\u00adlike fragment (i.e., that do not use sophisticated type classes or dependent types), \nincluding most of those in CompCert, it should be straightforward to implement our technique, although \nthe details of the automation will vary. Lastly, because MiniML also has a small step semantics, we hope \nto be able to verify complexity theoretic results about, e.g., our functional data structure case studies. \n9. Conclusion This paper s contribution is a step towards making proof assistants into trustworthy and \npractical program development platforms. We have shown how to give automated, veri.ed translations of \nfunc\u00adtions in higher-order logic to programs in functional languages. This increases the trustworthiness \nof programs that have been veri\u00ad.ed by shallowly embedding them in an interactive theorem prover, which \nhas become a common veri.cation strategy. We believe this is the .rst mechanically veri.ed connection \nbetween HOL func\u00adtions and the operational semantics of a high-level programming language. Our case studies \ninclude sophisticated data structures and algorithms, and validate the usefulness and scalability of \nour tech\u00adnique. Acknowledgments We thank Arthur Chargu\u00b4eraud, Anthony Fox, Mike Gordon, Kathy Gray, Ramana \nKumar and Tom Sewell for commenting on drafts of this paper. This work was partially supported by EPSRC \nResearch Grants EP/G007411/1, EP/F036345 and EP/H005633. References [1] G. Barthe, D. Demange, and D. \nPichardie. A formally veri.ed SSA\u00adbased middle-end Single Static Assignment meets CompCert. In H. Seidl, \neditor, 21st European Symposium on Programming, ESOP 2012, volume 7211 of LNCS, pages 47 66. Springer, \n2012. [2] A. Barthwal and M. Norrish. Veri.ed, executable parsing. In G. Castagna, editor, 18th European \nSymposium on Programming, ESOP 2009, volume 5502 of LNCS, pages 160 174. Springer, 2009. [3] R. S. Boyer \nand J. S. Moore. Proving theorems about LISP Functions. Journal of the Association for Computing Machinery, \n22(1):129 144, 1975. [4] A. Chargu\u00b4 eraud. Program veri.cation through characteristic formulae. In Proceeding \nof the 15th ACM SIGPLAN International Conference on Functional Programming, ICFP 2010, pages 321 332. \nACM, 2010. [5] A. Chargu\u00b4Characteristic formulae for the veri.cation of im\u00ad eraud. perative programs. \nIn Proceeding of the 16th ACM SIGPLAN Inter\u00adnational Conference on Functional Programming, ICFP 2011, \npages 418 430. ACM, 2011. [6] A. Chlipala. A veri.ed compiler for an impure functional language. In Proceedings \nof the 37th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2010, pages 93 \n106. ACM, 2010. [7] Coq. The Coq home page, 2012. http://coq.inria.fr/. [8] T. Coquand and G. Huet. The \ncalculus of constructions. Inf. Comput., 76(2 3):95 120, Feb. 1988. [9] Z. Dargaye. V`eri.cation formelle \nd un compilateur pour langages fonctionnels. PhD thesis, Universit`e Paris 7 Diderot, July 2009. [10] \nJ. Davis and M. O. Myreen. The self-verifying Milawa theorem prover is sound (down to the machine code \nthat runs it), 2012. http: //www.cl.cam.ac.uk/~mom22/jitawa/. [11] J. Duan, J. Hurd, G. Li, S. Owens, \nK. Slind, and J. Zhang. Functional correctness proofs of encryption algorithms. In G. Sutcliffe and A. \nVoronkov, editors, Logic for Programming, Arti.cial Intelligence, and Reasoning: 12th International Conference, \nLPAR 2005, volume 3835 of LNAI, pages 519 533. Springer-Verlag, 2005.  [12] M. Felleisen and D. P. Friedman. \nControl operators, the SECD\u00admachine, and the lambda-calculus. In 3rd Working Conference on the Formal \nDescription of Programming Concepts, Aug. 1986. [13] M. Felleisen, R. B. Findler, and M. Flatt. Semantics \nEngineering with PLT Redex. MIT Press, 2009. [14] J. Harrison. Metatheory and re.ection in theorem proving: \nA survey and critique. Technical Report CRC-053, SRI Cambridge, Cambridge, UK, 1995. [15] Hol. The HOL4 \nhome page, 2012. http://hol.sourceforge. net/. [16] J. Hurd. Veri.cation of the Miller-Rabin probabilistic \nprimality test. J. Log. Algebr. Program., 56(1-2):3 21, 2003. [17] Isabelle. The Isabelle home page, \n2012. http://www.cl.cam.ac. uk/research/hvg/isabelle/. [18] M. Kaufmann and J. S. Moore. The ACL2 home \npage, 2011. http: //www.cs.utexas.edu/users/moore/acl2/. [19] A. Krauss. Automating Recursive De.nitions \nand Termination Proofs in Higher-Order Logic. PhD thesis, Technische Universiti\u00a8at M\u00a8unchen, 2009. [20] \nX. Leroy. A formally veri.ed compiler back-end. J. Autom. Reason\u00ading, 43(4):363 446, 2009. [21] X. Leroy \nand H. Grall. Coinductive big-step operational semantics. Inf. Comput., 207(2):284 304, 2009. [22] P. \nLetouzey. A new extraction for Coq. In Proceedings of the 2002 International Conference on Types for \nProofs and Programs, TYPES 02, pages 200 219. Springer-Verlag, 2003. [23] G. Li. Validated compilation \nthrough logic. In M. Butler and W. Schulte, editors, FM 2011: Formal Methods -17th International Symposium \non Formal Methods, volume 6664 of LNCS, pages 169 183. Springer, 2011. [24] G. Li and K. Slind. Compilation \nas rewriting in higher order logic. In F. Pfenning, editor, Automated Deduction -CADE-21, 21st Inter\u00adnational \nConference on Automated Deduction, volume 4603 of LNCS, pages 19 34. Springer, 2007. [25] G. Li and K. \nSlind. Trusted source translation of a total function lan\u00adguage. In C. R. Ramakrishnan and J. Rehof, \neditors, Tools and Al\u00adgorithms for the Construction and Analysis of Systems, 14th Interna\u00adtional Conference, \nTACAS 2008, volume 4963 of LNCS, pages 471 485. Springer, 2008. [26] G. Li, S. Owens, and K. Slind. Structure \nof a proof-producing com\u00adpiler for a subset of higher order logic. In R. D. Nicola, editor, Programming \nLanguages and Systems: 16th European Symposium on Programming, ESOP 2007, volume 4421 of LNCS, pages \n205 219. Springer, 2007. [27] J. G. Malecha, G. Morrisett, A. Shinnar, and R. Wisnesky. Toward a veri.ed \nrelational database management system. In Proceedings of the 37th ACM SIGPLAN-SIGACT Symposium on Principles \nof Programming Languages, POPL 2010, pages 237 248. ACM, 2010. [28] D. Matthews. Poly/ML home page, 2012. \nhttp://www.polyml. org. [29] A. McCreight, T. Chevalier, and A. P. Tolmach. A certi.ed frame\u00adwork for \ncompiling and executing garbage-collected languages. In Proceeding of the 15th ACM SIGPLAN International \nConference on Functional Programming, ICFP 2010, pages 273 284, 2010. [30] R. Milner. Logic for computable \nfunctions; description of a machine implementation. Technical Report STAN-CS-72-288, A.I. Memo 169, Stanford \nUniversity, 1972. [31] M. O. Myreen. Reusable veri.cation of a copying collector. In G. T. Leavens, P. \nW. O Hearn, and S. K. Rajamani, editors, Veri.ed Soft\u00adware: Theories, Tools, Experiments, Third International \nConference, VSTTE 2010, volume 6217 of LNCS, pages 142 156. Springer, 2010. [32] M. O. Myreen. Functional \nprograms: conversions between deep and shallow embeddings. In L. Beringer and A. Felty, editors, Interac\u00adtive \nTheorem Proving (ITP), volume 7406 of LNCS, pages 412 418. Springer, 2012. [33] M. O. Myreen and J. Davis. \nA veri.ed runtime for a veri.ed theorem prover. In M. C. J. D. van Eekelen, H. Geuvers, J. Schmaltz, \nand F. Wiedijk, editors, Interactive Theorem Proving (ITP), volume 6898 of LNCS, pages 265 280. Springer, \n2011. [34] M. O. Myreen, K. Slind, and M. J. C. Gordon. Extensible proof\u00adproducing compilation. In O. \nde Moor and M. I. Schwartzbach, editors, Compiler Construction, 18th International Conference, CC 2009, \nvolume 5501 of LNCS, pages 2 16. Springer, 2009. [35] M. Norrish and K. Slind. A thread of HOL development. \nComput. J., 45(1):37 45, 2002. [36] C. Okasaki. Purely Functional Data Structures. Cambridge University \nPress, 1998. [37] S. Owens and K. Slind. Adapting functional programs to higher-order logic. Higher-Order \nand Symbolic Computation, 21(4):377 409, Dec. 2008. [38] J. .c\u00b4ik , V. Vafeiadis, F. Z. Nardelli, S. \nJagannathan, and P. Sewell. Sev.Relaxed-memory concurrency and veri.ed compilation. In Proceed\u00adings of \nthe 38th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2011, pages 43 54. \nACM, 2011. [39] K. Slind. Reasoning about Terminating Functional Programs. PhD thesis, TU Munich, 1999. \n[40] K. Slind, S. Owens, J. Iyoda, and M. Gordon. Proof producing synthesis of arithmetic and cryptographic \nhardware. Formal Aspects of Computing, 19(3):343 362, Aug. 2007. [41] A. K. Wright and M. Felleisen. \nA syntactic approach to type sound\u00adness. Inf. Comput., 115(1):38 94, 1994.    \n\t\t\t", "proc_id": "2364527", "abstract": "<p>The higher-order logic found in proof assistants such as Coq and various HOL systems provides a convenient setting for the development and verification of pure functional programs. However, to efficiently run these programs, they must be converted (or \"extracted\") to functional programs in a programming language such as ML or Haskell. With current techniques, this step, which must be trusted, relates similar looking objects that have very different semantic definitions, such as the set-theoretic model of a logic and the operational semantics of a programming language.</p> <p>In this paper, we show how to increase the trustworthiness of this step with an automated technique. Given a functional program expressed in higher-order logic, our technique provides the corresponding program for a functional language defined with an operational semantics, and it provides a mechanically checked theorem relating the two. This theorem can then be used to transfer verified properties of the logical function to the program.</p> <p>We have implemented our technique in the HOL4 theorem prover, translating functions to a core subset of Standard ML, and have applied it to examples including functional data structures, a parser generator, cryptographic algorithms, and a garbage collector.</p>", "authors": [{"name": "Magnus O. Myreen", "author_profile_id": "81392605670", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P3804317", "email_address": "magnus.myreen@cl.cam.ac.uk", "orcid_id": ""}, {"name": "Scott Owens", "author_profile_id": "81337492133", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P3804318", "email_address": "scott.owens@cl.cam.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2364527.2364545", "year": "2012", "article_id": "2364545", "conference": "ICFP", "title": "Proof-producing synthesis of ML from higher-order logic", "url": "http://dl.acm.org/citation.cfm?id=2364545"}