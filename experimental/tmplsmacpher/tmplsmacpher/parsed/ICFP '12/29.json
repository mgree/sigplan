{"article_publication_date": "09-09-2012", "fulltext": "\n Explicitly Heterogeneous Metaprogramming with MetaHaskell Geoffrey Mainland Microsoft Research gmainlan@microsoft.com \nAbstract Languages with support for metaprogramming, like MetaOCaml, offer a principled approach to code \ngeneration by guaranteeing that well-typed metaprograms produce well-typed programs. However, many problem \ndomains where metaprogramming can fruitfully be applied require generating code in languages like C, \nCUDA, or assembly. Rather than resorting to add-hoc code generation tech\u00adniques, these applications should \nbe directly supported by explicitly heterogeneous metaprogramming languages. We present MetaHaskell, \nan extension of Haskell 98 that pro\u00advides modular syntactic and type system support for type safe metaprogramming \nwith multiple object languages. Adding a new object language to MetaHaskell requires only minor modi.cations \nto the host language to support type-level quanti.cation over ob\u00adject language types and propagation \nof type equality constraints. We demonstrate the .exibility of our approach through three ob\u00adject languages: \na core ML language, a linear variant of the core ML language, and a subset of C. All three languages \nsupport metapro\u00adgramming with open terms and guarantee that well-typed Meta-Haskell programs will only \nproduce closed object terms that are well-typed. The essence of MetaHaskell is captured in a type sys\u00adtem \nfor a simpli.ed metalanguage. MetaHaskell, as well as all three object languages, are fully implemented \nin the mhc bytecode com\u00adpiler. Categories and Subject Descriptors D.3.3 [Software]: Program\u00adming Languages \nGeneral Terms Languages, Design Keywords Metaprogramming, open terms, type systems, quasiquo\u00adtation, \nlinear languages 1. Introduction Large bodies of widely-used scienti.c code, such as FFTW3 [14], ATLAS \n[40], and SPIRAL [29], are built using ad-hoc, custom code generators. Though code generators provide \na certain kind of abstraction, allowing one program to express many different, specialized versions of \na function, the implementer is typically consigned to a printf purgatory in which program fragments are \nrepresented as arrays of characters and the primary form of composition is string splicing. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 12, September \n9 15, 2012, Copenhagen, Denmark. Copyright &#38;#169; 2012 ACM 978-1-4503-1054-3/12/09 $15.00. Languages \nsuch as MetaML [37] and MetaOCaml [35] pro\u00advide metaprogramming environments on the other end of the \nspectrum they guarantee that well-typed metaprograms produce well-typed object programs. However, these \nlanguages focus on homogeneous metaprogramming, in which the metalanguage and object language are identical. \nThis makes them less suited for ap\u00adplications that must generate code in some other object language. \nIdeally programmers could write type safe metaprograms and have .exibility in choosing an object language. \nWe take a step towards the goal of type safe heterogenous metaprogramming with MetaHaskell. We make the \nfollowing con\u00adtributions: A type system for an idealized metalanguage/object language pair that guarantees \nthat well-typed metaprograms only ever produce closed object language terms that are well-typed. Ob\u00adject \nterms may contain free variables, and these free variables may be used polymorphically. To our knowledge, \nno other metaprogramming language allows free variables to be used polymorphically.  MetaHaskell, a \nextension of Haskell 98 implemented in the mhc compiler that provides modular type system support for \nmetaprogramming with multiple object languages.  Three object language plug-ins; a core ML language, \nMiniML, a linear variant of the core ML language, Linear MiniML, and Cb.Cb is a subset of C that is expressive \nenough to serve as a target for type safe, heterogeneous, run-time code generation which we demonstrate \nwith a compiler for regular expression matchers.  A methodology for converting a base language and type \nsystem into an object language and type system suitable for metapro\u00adgramming.  The rest of the paper \nis organized as follows. We give an overview of MetaHaskell through several small examples in Sec\u00adtion \n2. In Section 3 we outline our goals for a heterogeneous metaprogramming language. A simpli.ed type system \nthat captures the features of MetaHaskell that are relevant to metaprogramming is described in Section \n4 along with the type system of MiniML, a small ML-like language. In Section 5 we show that our frame\u00adwork \ncan accommodate even a substructural object language with little trouble. Cb, a C-like object language, \nis described in Sec\u00adtion 6 in the context of a regular expression compiler that performs run-time code \ngeneration. We give some further details of our im\u00adplementation in Section 7. Section 8 describes related \nwork, and we conclude and describe future work in Section 9. The mhc compiler, which implements MetaHaskell \nand the object languages described in this paper, is publicly available.  2. MetaHaskell Basics Syntactically, \nMetaHaskell builds on the quasiquotation feature of GHC [22]. Quasiquotation provides syntactic convenience \nwhen working with fragments of abstract syntax instead of writing an inscrutable mess of constructor \napplications to build the abstract syntax tree representation of a term, the programmer can write the \nsame term using concrete syntax. Given a quasiquoter, exp, that parses a core Haskell language, we can \nwrite the classic staged power function as follows. power ::Int .Exp .Exp power n x n =0 = [exp 1] n \n=1 = [exp $x] even n = square (power (n div 2) x) otherwise = [exp $x * $(power (n -1) x)] where square \n::Exp .Exp square x =[exp $x * $x] The power function takes an integer n and an abstract syntax tree \nx and returns a new abstract syntax tree representing x raised to the power n. The syntax [expb\u00b7] is \na quasiquote. At compile time, the argument between the brackets is passed as a string constant to the \nquasiquoter exp which returns a Haskell expression represented using GHC s internal Haskell AST data \ntype. The effect is just as if the programmer had written the equivalent Haskell term directly, but the \nsyntax is usually much more pleasant. The quasiquoter will often support antiquotation, written here \nusing the syntax $(...). Internally, exp parses the antiquotation as a Haskell expression and splices \nthe result into the abstract syntax tree in place of the antiquotation. Antiquotation support is purely \nthe responsibility of the quasiquoter, but its inclusion makes the mechanism vastly more useful. We have \nused quasiquotation for the purposes of code gen\u00aderation in past work in the context of sensor networks \n[25] and GPUs [24]. It is also used to support quasiquotation of perl and Ruby-style interpolated strings, \nregular expressions, parser gram\u00admars [15], and JavaScript [3] among other applications. Though quasiquotation \nprovides syntactic convenience and some type safety since it supports terms represented using algebraic \ndata types instead of strings, the terms it produces are still fundamentally un\u00adtyped. There is nothing \nto stop the programmer from passing the power function a value of type Exp that represents a string expres\u00adsion. \nA Haskell program containing this call to power will happily type check only to generate an ill-typed \ncore Haskell term at run\u00adtime. We would like to do better. Rather than building a Haskell term of type \nExp, our quasiquoter should build a Haskell term with a more accurate type. Ideally, it would build a \nterm with a type that is somehow isomorphic to the type the quoted term has in the type system of the \nquoted language. That is, when we quote a term in core Haskell, it should receive a core Haskell type \nsuitably lifted to Haskell. MetaHaskell allows quasiquoters to re.ect object language types into the \nHaskell type system. We can write the same power function, now with more accurate types. power ::...Int \n.[exp . IInt] .[exp . IInt] power n x n =0 = [exp 1] n =1 = [exp $x] even n = square (power (n div 2) \nx) otherwise = [exp $x * $(power (n -1) x)] where square ::...[exp . IInt] .[exp . IInt] square x =[exp \n$x * $x] Only the type signatures have changed. Although we have writ\u00adten them out explicitly here, these \ntypes appear exactly as they would be inferred by MetaHaskell. As well as expressions, object language \ntypes can be quoted. The type [expb. pInt] is the type of code that, in any type environment ., has type \nInt. That is, ob\u00adject terms can be polymorphic in their typing environment. Note that we quantify over \n. at the metalanguage level. We discuss this further in Section 4. MetaHaskell quasiquoters provide strong \ntyping of object lan\u00adguage terms by plugging in to the metalanguage s type system. In all object languages \nwe describe, object language types are re.ne\u00adments of Haskell types. For example, in the case of power, \nwe re\u00ad.ned the Haskell type Exp of abstract syntax trees. The run-time representation of a quasiquoted \nobject term is just the correspond\u00ading abstract syntax term with an unre.ned type. This means that, at \nrun-time, we can convert an object language term to its abstract syntax representation via a safe erase \nfunction de.ned in terms of unsafeCoerce. erase ::.., a.[exp . Ia] .Exp erase =unsafeCoerce  2.1 Safe \nrun-time code generation Strongly typed quasiquotation guarantees that only well-typed ob\u00adject language \nterms will be constructed, at least up until the point of erasure, but we can use it for more than just \ngenerating abstract syntax. Consider again our power function, but imagine instead that we wish to generate \na specialized version of the power function at run-time as MetaOCaml would allow. MetaHaskell includes \nsup\u00adport for the Cb object language, a restricted form of C, as well as a quasiquoter for Cb functions \nthat instead of producing a value whose run-time representation is an abstract syntax tree, produces \na pointer to an actual compiled function. A code-generating version of the power function, cpower, can \nbe written as follows. As with power, the type signatures for both go and cpower are not neces\u00adsary as \nthey would be inferred by MetaHaskell as shown. cpower ::Int .FunPtr (CDouble .IO CDouble) cpower n [cfun \ndouble pown (double x) {double r; $stms:(reverse (go n)) return r; }]) where go ::...Int .[[cstm {double \nx; double r} . Ivoid]] go n n =0 =[[cstm r =1.0]] n =1 =[[cstm r =x; ]] even n =[cstm r =r *r; ]:go (n \ndiv 2) otherwise =[cstm r*= x; ] :go (n -1) We note several aspects of MetaHaskell that are newly illus\u00adtrated \nby cpower. First of all, [cfunb\u00b7] takes a quoted function and returns a FunPtr the type of foreign function \npointers in Haskell s foreign function interface indexed by the Haskell translation of the quoted function \ns type. That is, because the quoted function pown has the Cbtype double (*)(double), the index to FunPtr \nis its translation, CDouble . IO CDouble. This is in contrast to power, which returned a value with an \nobject language type. Be\u00adcause [cfunb\u00b7] performs run-time code generation and therefore re\u00adquires the \nquoted function to be closed, attempting to quote an open Cbfunction using [cfunb\u00b7] results in a compile-time \nerror. Also in contrast to the core Haskell quasiquoter, Cb provides quasiquoters for multiple syntactic \ncategories. We use the [cstmb\u00b7quasiquoter to build up the body of the pown function via recursive ] calls \nto go. The [cstmb\u00b7] quasiquoter does return a value with an object language type the type of the quoted \nCb statement. The type of go re.ects the fact that it returns a list of statements, each of which is \nvalid in a type environment where the variables x and r have type double. The implementation of cpower \nuses Cb s ability to antiquote lists of statements to build the body of pown.  2.2 Why not GADT s? \nThis seems like a lot of trouble to go to when GADTs [41] suf.ce to write the power function. A quasiquoter \nhas three basic jobs. First, it provides concrete syntax for an object language. Second, it em\u00adbodies \na decision procedure that provides a type which may be an object language type for the quoted term (and \nits antiquotations). Third, it must re.ect the type provided by the decision procedure into the host \nlanguage. The .rst job is no different from that performed by quasiquot\u00aders as implemented in GHC it \nis a purely syntactic task. We argue that the second job performing type inference on object terms is \nuseful even when object language types have a strong encoding in the metalanguage s type system, i.e., \nwhen the encoding is in\u00adjective. For example, although GADTs can encode open lambda terms [1], dealing \nwith the structural rules required to work with such terms involves a great deal of bookkeeping exactly \nthe sort of bookkeeping that a type inference procedure automates. Further\u00admore, it is not clear how \noften an object language s type system has a strong encoding in Haskell with GADTs. Consider the following \nMetaHaskell term. polyopen = [exp (f 1, f True)] This MetaHaskell term, which uses the free variable \nf polymor\u00adphically, has the following type. .a, \u00df, ., ..[exp {f ::[Int .a; Bool .\u00df ].}. I(a, \u00df)] This \ntype states that the quoted term is valid in any type envi\u00adronment that contains at least a binding for \nf, that the binding for f must have at least both the types Int .a and Bool .\u00df, and that in such an environment \nthe quoted expression has type (a, \u00df). We give further details in Section 4, but suf.ce to say that inference \nis tricky and the appropriate GADT encoding for such a type is not immediately obvious. However, even \nif our host language were a language like Coq, which in this case would ensure a strong em\u00adbedding of \nthe object language type system, we would still like to have access to the decision procedure embodied \nin the object lan\u00adguage quasiquoter and a framework for object language integration. 3. Design Goals \nBefore proceeding, we outline our design goals for a heteroge\u00adneous metaprogramming languages. In what \nfollows we primar\u00adily use small, idealized object and metalanguages. Rather than uti\u00adlizing the concrete \nMetaHaskell syntax seen in Section 2, we use MetaML-like syntax for quotation and antiquotation. For \nexample, in the following expression, the body of the lambda is a quotation containing the antiquoted \nterm f 1. .f ..(g1, (f 1)). Syntactic support: The programmer should be able to write object terms using \nthe object language s syntax.  Antiquotation: The metalanguage should allow abstraction over object \nlanguage sub-terms. That is, object terms should be able to contain antiquoted sub-terms.  Heterogeneity: \nThe metalanguage should provide support for multiple object languages in the same overall framework. \nIde\u00adally, support for new object languages can be added to the meta\u00ad  language in a modular way that \nrequire little or no modi.cation of the metalanguage implementation. Type soundness: Well-typed metaprograms \nshould only gener\u00adate well-typed object terms.  Type inference: The metalanguage should be able to infer \nthe types of object terms without excessive programmer burden. Annotations on the level of those that \nHaskell requires for, e.g., impredicative instantiation, are reasonable. If the object language s type \nchecker can infer the type of an object term, then the metalanguage s type inference engine should be \nable to infer the type of the same object term when it appears in a metaprogram.  Open object terms: \nThe metalanguage should permit object terms with free variables. Ideally, inference for open object terms \nwould not require additional programmer annotations. This would allow us to quote object language fragments \nlike the C expression .sin (x)., where both sin and x are free.  Subterm typability: If an object term \nis well-typed, then any of its sub-terms, when appearing in isolation, should also be well-typed.  Subterm \nabstractability: We want the property that, at the metalanguage level, we can perform \u00df-abstraction over \nobject language sub-terms. That is, we want to be able to abstract over any sub-term of an object term, \napply the abstraction to the ab\u00adstracted sub-term, and have the new application be well-typed. Obviously \nwe want preservation to hold, so if this application is well-typed, then it has the same type as the \noriginal term, which we would recover via \u00df-reduction. For example, we want it to be the case that the \nmetalanguage term  .let f = .x .x in (f1, f true). is equivalent to the metalanguage term (.e ..let \nf = .x .x in e.).(f1, f true). This is slightly different from subterm typability which only requires \nthat any object language sub-term be typeable in isola\u00adtion, not that an object language term be \u00df-abstractable. \nIn par\u00adticular, there is dif.culty with abstracting over a sub-term that appears in the right-hand side \nof a recursive let binding which we discuss in Section 4.1. Fresh name generation: The metalanguage \nshould provide facilities for generating fresh names for use in object terms. That is, we want to be \nable to gensym names that are guaranteed not to occur in any object language term so we can avoid unintended \nvariable capture when generating code.  Hygiene: The programmer should have the ability to require that \nfree variables appearing in an antiquote be used hygieni\u00adcally. For example, consider the term:  .let \nx = ... in (f .x.)). Here x appears free in the argument to f, which appears in an antiquotation and \nis some metalanguage function that manipu\u00adlates object language fragments. We would like the program\u00admer \nto be able to reason about this fragment without knowing the implementation details of f. In particular, \nthe programmer should not have to know what object language context f might place its argument in in \nthe process of building a new object lan\u00adguage term even if that context might bind a variable named \nx. We want hygiene the x appearing in .x. should always re\u00adfer to the x bound by the top-level let, not \nto any x that might be bound in the term constructed by f in which .x. may .nd itself.  Object term \nelimination: The programmer should be able to eliminate as well as introduce object language terms. That \nis, we want to be able to use the metalanguage to perform intensional analysis of object terms while \nretaining full object term typing. MetaHaskell make substantial progress in providing these de\u00adsirable \nfeatures: it provides syntactic support, antiquotation, het\u00aderogeneity, type soundness, inference, open \nterms, and subterm ty\u00adpability. We have not addressed hygiene, fresh name generation, or object term \nelimination. Ideas for making further progress are outlined in Section Section 9. 4. A Type System for \nHeterogeneous Metaprogramming MetaHaskell consists of Haskell 98 plus extensions for heteroge\u00adneous metaprogramming \nit is a rather large language. As such, in this section we describe the type system not of full MetaHaskell, \nbut of MiniMeta, a simpli.ed version of MetaHaskell that nonethe\u00adless contains all the type system features \nessential to MetaHaskell s support for metapgrogramming. Jointly, we present the type system for MiniML, \nan ML-like object language. 4.1 MiniML: Object Language Essentials Two of our object language design \ngoals are to support open terms and antiquotation, e.g., object language terms in which we have abstracted \nover a sub-term, as in the term .x .. x +1.. Both requirements present dif.culties. The presence of free \nvariables means that we no longer face a type inference problem, but a typing inference problem. The \ndifference between the two is that given a term, typing inference must produce a typing context as well \nas a type, whereas type inference need only produce a type. Although ML does have the principal type \nproperty, it does not have principal typings. We can see this by considering the (open) object language \nterm xx 1. We could give this term one of the following two typings {x :.a.a}.xx :.a.a {x :.a.a .a}.xx \n:.a.a .a The former derivation provides more because the term has type .a.a, but it requires more than \nthe latter derivation because it can only occur in a typing environment where x has type .a.a. Neither \nderivation is more general than the other. Shao and Appel [33] partly addressed the issue of typing open \nterms in solving the smartest compilation problem. They present an algorithm to infer the minimal import \ninterface required by a compilation unit. In essence they are inferring a minimal context, i.e., a typing. \nJim [16] connects smartest compilation to the typing problem and gives a more explicit presentation of \na typing infer\u00adence algorithm. ML s lack of principal typings will not hinder us because we will allow \ncontexts to include more types than can ap\u00adpear in the expression language. The algorithm presented by \nShao and Appel [33] collects constraints on variable instantiations and then matches them against the \npoltype inferred at the variable s binding site. The algorithm presented by Jim [16] uses intersection \ntypes to represent what are morally the same constraints, a tech\u00adnique we will reuse for MiniML. Open \nterms present dif.culties, but at least it is syntactically ap\u00adparent which variables are free in an \nopen term. An object language term containing an antiquotation is not so well-behaved. After all, what \nare the free variables in the term . x +1.? It is apparent that 1 This example is taken from Jim [16]. \nTerm variables Type variables . . x, y, z, f, g, h a, b, c Extension variables . Row variables . Expressions \ne ::= i true false i .x.e e1 e2 x Types Type schemes t s ::= ::= let x = e1 in e2 int bool t1 .t2 .a.t \na Type environment schemes . ::= .[ti]. s . Type environments G ::= {xi :.i}G .#x Context environments \n. ::= { i :Gi Isi} Figure 1: Object language syntax we must somehow express joint constraints on the \ncontext of a quo\u00adtation and the contexts of its constituent antiquotations. The syntax of MiniML is given \nin Figure 1. We use a type\u00adwriter font to distinguish MiniML terms from metalanguage terms. Its differences \nwith respect to a standard ML-like language are highlighted. The only change in the syntax of expressions \nis the presence of contexts for antiquotations, i . Although our concrete syntax inlines antiquotations \ninto quotations, antiquotation is re\u00adally an abstraction/application pair. For example, the quasiquote \n.x .. x +1. desugars into .x . . 1 +1. x. A syntactically valid MiniML term will only contain sequentially \nand distinctly numbered contexts, although there is no constraint on which per\u00admutation of context numbering \nis chosen in practice the parser numbers the contexts sequentially in parse order. We represent contexts \nusing R\u00e9my s extensible records [30, 31]. This is a natural way to express the joint constraints be\u00adtween \nquasiquotation contexts and their antiquotations. Extensible records use row variables to represents \nthe rest of the .elds in a record, allowing expressions to be polymorphic in the records they manipulate \nonly the .elds that are accessed are required to be present, but the record may also contain additional \nunreferenced .elds that are represented by the row variable. Similarly, row vari\u00adables allow our object \nlanguage terms to be polymorphic in the rest of their context. This form of polymorphism is permissible \nbecause our object language allows weakening. MiniML s type en\u00advironments, G, use R\u00e9my s record type, \nincluding row variables with lacks constraints of the form .#x . A lacks constraint speci\u00ad.es which variables \n(record labels) may not appear in the record extension associated with the row variable that it annotates. \nType environments do not bind variables to type schemes, but to type environment schemes. A type environment \nscheme is either a polytype or an extensible intersection type. Extensible intersection types type free \nvariables in open terms. For example, the quotation .(f1, f true). has the type .a, b, ., .. {f :.[int \n.a; bool .b].}. p(a, b) Note that quoted terms are metalanguage terms, so this type is a metalanguage \ntype. In this type we have quanti.ed over the object language typing variables a, b, ., and ., but the \nquanti.cation is   G; . . s . e OBJINT OBJBOOL G; . .. i :int G; . .. {true, false}:bool x :.[t1 ...tn]s \n.G OBJVAR G; . .. x :s x :.[t1 ...ti ...tn]. .G OBJFREEVAR G; . .. x :ti G, x :t1;. .. e :t2 OBJABS G; \n. .. .x.e :t1 .t2 G; . .. e1 :t1 .t2 G; . .. e2 :t1 OBJAPP G; . .. e1 e2 :t2 G; . .. e1 :s G, x :s;. \n.. e2 :t OBJLET G; . .. let x = e1 in e2 :t G; . .. e :s a .ftv(G).ftv(.) OBJGEN G; . .. e :.a.s ' G; \n. .. e :ss .s OBJINST ' G; . .. e :s i :Gi Isi .. Gi;. .. i :si ANTI Figure 2: Declarative typing rules \nfor MiniML done at the metalanguage level. The type of the object language term is enclosed in a box \nwhen it appears in a metalanguage type to distinguish it as an object language type. We further discuss \nthese details in Section 4.2, but for now the germane aspect of this type is the extensible intersection \ntype assigned to f in the typing environment, .[int .a; bool .b].. This type says that f must have both \ntype int .a and type bool .b, but that it may also have additional types in the typing environment, indicated \nby the extension variable .. Extension variables serve the same function in extensible intersection types \nas row variables serve for extensible records. Context environments, ., provide typings for contexts, \nof the form G ps, that specify both an environment G and a polytype s. The declarative type system for \nMiniML is given in Figure 2 along with the corresponding subsumption relation in Figure 3; we again highlight \nthe differences with respect to the standard declarative rules for an ML-like language. The rule for \ntyping contexts, ANTI, requires that the environment component Gi of a context s typing in the context \nenvironment . must exactly match the Gi in the derivation where the context i occurs. This directly implies \nthat any bound variable that scopes over i , as well as any variable that occurs free anywhere in the \nquotation in which i appears, must be present in Gi. These free variables may be used at additional types \nin the expression plugged in to the context due to the extension variable ., and this expression may \nalso use additional free variables that do not appear explicitly in G due to the row variable .. As we \nexplain in Section 4.2, the type variables . and . are instantiated at the metalanguage level whenever \na quotation is applied to an antiquotation. s .s ' \u00dfi . ftv(.a.t) .a.t ..\u00df.[a .t ']t Figure 3: MiniML \ntype subsumption relation Type environment schemes have the form .[ti]s, where s is a polytype, or .[ti]., \nwhere . is an extension variable, and in both cases the intersection may be empty. Though the polytype \nform of type environment schemes is not strictly necessary for the declarative rules, it is a technical \ndevice for the bene.t of the algorithmic rules, which we do not present here, allowing them to substitute \na polytype s for an extension variable . in the typing rules for binders. A type environment scheme .[ti]s \nis therefore only well-formed when s can be instantiated to each of the ti in the intersection. A variable \nx with a type environment scheme .[t1 ...tn]s must therefore have type s according to OBJVAR. A variable \nthat occurs free is expected to have a type environment scheme .[t1 ...tn]. and may have any type ti, \n1 = i = n, according to OBJFREEVAR. There is a subtlety with generalization: the rule OBJGEN must look \nfor free type variables in both G and .. Consider the following term .x ..let y = .z .z x in (y (.u .1), \ny (.v .true)). Because z will appear in the . used to type the context 1 (where x occurs), we cannot \ngeneralize y, so this term cannot be typed. To see why this must be the case, imagine applying this lambda \nto the expression .z 2. In general, the presence of an antiquotation in the right-hand\u00adside of a binding \nprevents generalization. This means that our extended language does not satisfy the subterm abstractability \ngoal de.ned in Section 3. If we also added type ascription, then a type signature would suf.ce in this \ncase to assign y a polymorphic type. 4.2 MiniMeta: Object Language Type System Integration MiniMeta \nintegrates support for using MiniML as an object lan\u00adguage. Though we present it here in a setting where \nMiniML is the only supported object language, we will shortly point out the type system features that \nare necessary to support MiniML and show that they are general enough to also support a variety of other \nob\u00adject languages. In Section 4.4 we give a more detailed qualitative description of the process for \ntransforming a base language s syn\u00adtax and type system into a suitable object language syntax and type \nsystem. The syntax of MiniMeta is given in Figure 4. Quotations, of the form .e., are the only non-standard \nexpression syntax. We have also already seen object language typings, of the form G ps . The third novel \naspect of MiniMeta is that it allows quanti.cation over types by object language type variables (a), \nobject language row variables (.), and object language extension variables (.). Quanti.cation must be \ndone at the metalanguage level if there is any hope of connecting typing constraints on quotations to \ncon\u00adstraints on their constituent antiquotations. Consider the term .x ..(f1, x). The metalanguage binds \nx, which must have an object language typing (we will show the typing rules shortly). There are no con\u00adstraints \non the type of x, so we will simply use the type variable  Term variables Type variables Quanti.cation \nvariables . . x, y, z, f, g, h . a, b, c ::= a a . . Expressions e ::= i true false x .x.e e1 e2 let \nx = e1 in e2 .e. Types . ::= int bool .1 ..2 a  Type schemes . ::= .... Type environments T ::= {xi \n:.i} Figure 4: MiniMeta syntax T . e . INT BOOL T . i :int T .{true, false}:bool x :. .T T . x :. VAR \nT,x :.1 . e :.2 T . e1 :.1 ..2 T . e2 :.1 ABS APP T . .x.e :.1 ..2 T . e1 e2 :.2 T . e1 :. T,x :. . \ne2 :. T . let x = e1 in e2 :. LET ' T . e :.. . ftv(T) T . e :.. = . GEN INST ' T . e :.... T . e :. \n Figure 5: Declarative typing rules for MiniMeta b to represent this type. However, we do know that the \ntyping en\u00advironment of x s object language typing must include f at least at the type int . a for some \na. Furthermore, x may also use free variables other than f, and in fact may use f at other types, but \nwhatever these uses may be, they will also occur in the quotation .(f1, x). where x occurs as a sub-expression. \nWe use type vari\u00adables . and . to represent these shared uses of the environment. The full expression \ntherefore has the type .a, b, ., .. {f :.[int .a].}. pb . {f :.[int .a].}. p(a, b) MiniMeta s typing \nrules appear in Figure 5. Although we have not explicitly kinded the four varieties of type variables \nin our presentation, morally they do have different kinds as shown by the subsumption relation given \nin Figure 6. Object language types are just types in our metalanguage. A term with an object language \ntype, e.g., a quasiquotation, can ap\u00adpear in a program, and an object language type can be used to in\u00ad \n  . =. ' bi, bj ,.k,.l .ftv(....) .... =.b b . ..[a .. ' , a .. '' ,. .., . .T]. Figure 6: MiniMeta \ntype subsumption relation stantiate a type variable a. However, object language type variables that appear \nin metalanguage types, name a, ., and ., serve only as evidence no values will ever have a type with \nan object language kind. Quotations are typed with the QUOTE rule. This rules makes use of the object \nlanguage judgment to type the quoted object lan\u00adguage term and results in an arrow type with as many \narguments as there are contexts in the quotation. Recall that the typing envi\u00adronment for contexts must \nmatch up exactly with the typing en\u00advironment in the derivation where the context occurs. This means \nthat for the abstraction introduced by a quotation to be applied, the ith applicand an antiquotation \nmust have precisely the type Gi psi . This may be unsettling because it seems to place too many restrictions \non Gi. However, it is only unsettling because we are not used to encountering polymorphic environments. \nJust as a classic polymorphic function like cons allows us to build a list at many types, row and extension \nvariables allow us to use a typing polymorphically and therefore use an object term at many typings. \nWe use an object term at many typings the same way we would use cons at many types by instantiating its \ntype variables within the metalanguage. That is, metalanguage instantiation lets us match up the G s \nin object language types. 4.3 Hygiene Although we listed hygiene as one of our goals in Section 3, MiniML \nand MiniMeta are unhygienic, a rather undesirable fea\u00adture. Kim et al. [20] allow programmer control \nover hygiene by introducing hygienic lambda abstraction, . * , that performs capture-avoiding substitution \non the abstraction before it is ap\u00adplied. We believe this extension could be incorporated easily into \nour system: instead of elaborating to abstract syntax trees, quasiquoted expressions would elaborate \nto computations in a name-generating monad. Assuming that computations in our name\u00adgenerating monad were \nrun via runQ, the erase function would then be de.ned as erase ::.., a.[exp . Ia] .Exp erase = runQ .unsafeCoerce \n We note that our desire for subterm abstractability is incom\u00adpatible with hygiene. However, providing \nboth hygienic and un\u00adhygienic binding forms also allows the programmer to choose be\u00adtween subterm abstractability \nand hygiene on a case-by-case basis.  4.4 Crafting an Object Language Our metalanguage and object language \nseem to be tied together in\u00adtimately. This raises two related questions: how easily can a new object \nlanguage be integrated into MiniMeta, and how does one transform a base language a language, like core \nML, without sup\u00adport for antiquotation and without a typing inference procedure into an object language \nsuitable for integration. There are four points of integration between MiniMeta and MiniML. 1. Syntactic \nsupport for quoting object language terms and object language types.  2. Type system support for object \nlanguage types appearing as terms in metalanguage types. 3. Quanti.cation over object language type \nvariables in metalan\u00adguage types. 4. Passing type equality constraints from the metalanguage s type \nchecker to the object language.  Importantly, MiniMeta knows nothing about the term structure of either \nMiniML types or MiniML terms object language expres\u00adsions and object language types are both completely \nopaque to the metalanguage. Syntactic support for quasiquotation is straightfor\u00adward, as the object language \nparser need only produce an object language term and a list of antiquotations which the metalanguage \nparser then handles. The object language must provide hooks for working with object language type variables, \nbut this can be done in a generic way. Similarly, the metalanguage type checker can simply pass equality \nconstraints between object language types to the object language type checker without requiring any knowledge \nof the structure of these types. We claim that the metalanguage is largely agnostic with respect to the \nform of the object language and its types and that integrating new object languages requires few changes \nto the metalanguage and its type system, and we back up this claim in Section 5. More dif.cult is the \nquestion of how, in general, to convert a base language and its type system into an object language. \nThe syntactic portion of the problem is easy just add support for antiquotation to the object language. \nEven the type inference problem is not too hard if we simply require all free variables and contexts \nto be fully annotated. However, this seems somewhat draconian and we have three examples of object languages \nthat do not require such an annotation burden but still provide inference MiniML, Linear MiniML, and \nCb so we expect there to be a general method for providing inference even in the presence of free variables \nand antiquotation. Given a base language to convert to an object language, it is clear that we must .rst \nsolve the typing inference problem for the base language. During type inference, bindings are known, \nand uses of a binding generate constraints that are immediately resolved using the binding s de.nition. \nFor languages based on Hindley-Milner, this immediate resolution is performed using uni.cation. To move \nfrom type inference to typing inference, the type system must be extended so that it can capture these \nconstraints in a type. For MiniML, these constraints are captured by an extensible intersection type. \nA typing is then a pair of an environment, which maps free variables to types that accurately re.ect \nthe constraints imposed by the uses of the free variables, and a type. Typings are not quite enough to \nget us where we want to go be\u00adcause we must also address the issue of antiquotation. It is useful to \nthink of an object language quotation as representing an entire class of base language syntax trees formed \nby substituting a base language expression for each of the contexts, i , in the quotation. But each object \nlanguage quotation must be paired with a typing derivation that parameterizes the base language derivations \nfor the same class of base language expressions that the quotation repre\u00adsents. Furthermore, these term/derivation \npairs must be constructed in such a way that when they are composed that is, when an object language \nterm is plugged in to a context and its corresponding derivation is plugged in to the parent derivation \nthe resulting object language term/derivation pair still consists of a valid rep\u00adresentative of an entire \nclass of base language term/typing deriva\u00adtions. Consider a variant of MiniML that did not allow antiquotation. \nFor such a language, intersection types alone would be enough to provide typings there would be no need \nfor either extension variables or row variables. This wouldn t be a particularly useful language after \nall, how would one ever construct a closed term from an open term without antiquotation. However, the \npoint of proposing such an object language is to make the observation that we could represent entire \nclasses of base language derivations using object language types that do not make use of row or extension \nvari\u00adables. The need for row and extension variables arises in MiniML because of antiquotation. Unlike \nderivations for our hypothetical antiquotation-free variant, MiniML derivations have holes where the \nderivations for antiquoted terms must eventually be plugged in. The process for constructing the object \nlanguage MiniML from a core ML base language consisted of the following steps Modify the term structure \nof expressions to allow object lan\u00adguage expressions to represent entire classes of base language expressions \nby adding support for antiquotation.  Extend the base language type system so that types can repre\u00adsent \nthe constraints a term s use of free variables imposes on those variables types.  Extend the base language \ntype system so that object lan\u00adguage derivations represent classes of derivations where sub\u00adderivations, \ncorresponding to antiquotations, are left free. For MiniML this required adding row and extension variables \nto represent typing environment constraints shared by a derivation and its free sub-derivations.  We \nconjecture that only type systems that can be written in a syntax-directed form are suitable for use \nin an object language as quotations consists of terms and derivations whose holes line up in a one-to-one \ncorrespondence. In the following two sections we support our claim that MiniMeta represents a general \nmetaprogramming framework that can support many object languages by describing two additional object \nlan\u00adguages, a linear variant of MiniML and a C-like language. 5. A linear object language The type system \nwe have presented is expressed for a pair of lan\u00adguages: a metalanguage and a speci.c object language. \nIt is natu\u00adral to ask whether or not the type system fragment associated with the metalanguage can be \nadapted to other object languages, and if so, how dif.cult this might be. In particular, one might expect \nthat because we expend so much effort on context manipulation, sup\u00adporting an object language with a \nsubstructural type system would be particularly challenging. In this section we demonstrate that al\u00adthough \nimplementing the type checker for a linear object language is non-trivial and requires some novel techniques, \nintegrating it into the metalanguage takes almost zero effort essentially the only change to the metalanguage \nthat is required is to allow quanti.\u00adcation over a newly-kinded type variable. Our linear language, Linear \nMiniML, is a variant of MiniML that adds two new binding constructs: a linear let binding and a linear \n. binding. Its syntax is shown in Figure 7 with the differences with respect to MiniML highlighted. Many \nexisting presentations of substructural type systems an\u00adnotate types with use notations that capture, \ne.g., when variables are used in a linear [38] or unique (in the sense of uniqueness typ\u00ading) [12] way. \nWhile one could imagine using a version of our pre\u00advious object language s type system extended with \nsuch annota\u00adtions to type open terms, there is a complication that makes this approach a non-starter: \nantiquotation. The dif.culty with antiquo\u00adtation is that it is not syntactically obvious which variables \nwill be used by a term that is substituted into a context i , much less which variables it will use linearly! \n Term variables . x, y, z, f, g, h Type variables . a, b, c Extension variables . Row variables . Use \nvariables . Expressions e ::= true false x i .x.e .1 x.e e1 e2 let x = e1 in e2 let1 x =e1 in e2 (e1 \n, e2 ) case e1 of { (u, v) .e2 } Types t ::= int bool t1 .t2 t1.t2 a (t1, t2) Variable use sets . ::= \n. {x} 1 0 .1 n.2 .1 ..2 Type schemes s ::= .a.t Environment schemes . ::= .[ti]. s . Type environments \nG ::= {xi :.i}G .#x Context environments . ::= { i :Gi Isi} Figure 7: Linear object language syntax \nConsider the following term, in which z is a linear binding, i.e., it must be used linearly in the body \nof the let .x ..let1 z = true in x. Unfortunately we have abstracted over the body of the let, so we \nmust somehow .gure out how to assign x a type that re.ects the fact that it must use the (free) variable \nz linearly. Our approach to solving this problem is to construct a typing judgment that tracks two sets \nof disjoint variables that are free in the expression under judgment: those that are use linearly and \nthose that are not used linearly. These sets of variables must contain not just object language variables, \nsuch as z, but also metavariables ., that themselves represent sets of variables. These metavariables \nwill allow us to quantify over sets of variables. Our typing judgment has the following form, where .1 \nis the set of variables used linearly by e and .. is the set of variables that e does not use linearly. \nG; . .. e :sb(.1,..) We claim that our previous quotation of a linear term has the type 1 . .a,.,v,v \n. {z :bool}. pab(v1.v1n{z}.{z},v.) . . pab(v1.v1n{z},v.) Though we will shortly show that we can infer \nthis type automatically, we make no claims regarding its readability or programmer-friendliness, so we \nwill walk through our claim care\u00adfully. We use the set operations intersection, n, and symmetric difference, \n., to represent sets of variables. Our type quanti.es over two variable use metavariables, v 1 and v \n.. The type of the binder should not look entirely foreign; it says that the binder is an object language \nterm that is only valid in a type environment that must at least contain a binding for z at type bool \nand that in such an environment it has the type a. However, its type also places a constraint on the \nset of variables that the binder must use linearly we claim that the constraint requires that z is a \nmember of this set. To see this, let us calculate the intersection of v 1 .v 1 n{z}.{z} with the set \ncontaining just the variable z (v 1 .v 1 n{z}.{z})n{z}= v 1 n{z}.v 1 n{z}.{z} ={z} A similar calculation \nshows that the result of applying the lambda is an object expression that is guaranteed not to use a \nfree variable z linearly. The typing rules for our linear language are given in Figure 8. They utilize \njoin (.) and meet (.) operators, de.ned in Figure 9, for combining the two variable use sets according \nto whether two sub\u00adexpressions execute in sequence (.) or as alternatives (.) (note that set union and \nset difference can be expressed in terms of nand .). We see both mixing operators at work in rule LINIFTHENELSE. \nThe variable uses of e2 and e3, the then and else branch, respec\u00adtively, of an if expression, must be \ncombined so that only those variables that are used linearly in both branches are judged to be used linearly \nin the body of the if expression; this is the job of the meet (.) operator. In contrast, only those variables \nthat are used linearly in either the scrutinee of the if expression, e1, or the body, may be judged to \nbe used linearly by the if expression as a whole; this is the job of the join (.) operator. The standard \nabstraction rule, LINABS, is unsurprising. The ap\u00adplication rule, LINAPP, must take care to recognize \nthat because the . being applied is not guaranteed to use the variable it binds linearly, a variable \nused linearly by the argument cannot be guar\u00adanteed to be used linearly by the application as a whole. \nLinear abstraction, LINABS1, is like LINABS but with an additional side condition requiring that the \nvariable it binds is present in the set of variables used linearly by the body of the .1. Application \nof a .1\u00adbinding is judged by LINAPP1 to use linearly any variables that are used linearly by the argument \nsince the .1-binding is guaranteed to only use its argument linearly. The other rules follow similarly. \nAs Kennedy [19] observed in the setting of labels for extensi\u00adble records, variables sets with the union \nand symmetric difference operators form a Boolean ring with 0 being the empty set and 1 the set of all \nlabels. Amazingly, uni.cation over Boolean rings is decidable and unitary [2, 26]. MetaHaskell includes \nthe linear lan\u00adguage in Figure 7 as an object language, and the object language s type checker uses Boolean \nuni.cation to provide type inference. Coming up with a type system and corresponding inference pro\u00adcedure \nfor our linear language required some thought we could not simply reuse an existing language as-is. Although \nwe provided a qualitative description of how to go about converting a language and type system to a form \nsuitable for use as an object language in Section 4.4, one has to expect that adding support for typing \ninfer\u00adence (in contrast to just type inference) as well as antiquotation to an existing language will \nrequire some non-trivial amount of work. However, adding support for our linear object language required \nonly a few, small changes to the metalanguage in three areas: 1. The MetaHaskell parser was changed to \nrecognize quoted Lin\u00adear MiniML expressions and types. 2. The algebraic data type representing object \nlanguage type metavariables was extend with a constructor for the Linear MiniML metavariables that can \nbe quanti.ed at the metalan\u00adguage level, i.e., ., ., and ..   G; . .. e s (.1,..) LINBOOL G; . .. {true, \nfalse}:bool (\u00d8,\u00d8) x :.[t1 ...tn]s .G LINVAR G; . .. x :s (x,\u00d8) G; . .. e1 :bool .1 G; . .. e2 :t G; \n. .. e3 :t .2 .3 LINIFTHENELSE G; . .. if e1 then e2 else e3 :s .1.(.2..3) G, x :t1;. .1 . e :t2 (v,v.) \nLINABS G; . . . .x.e :t1 .t2 (v1\\x,v.\\x) G; . .:t1 G; . .: . e1 .t2 (u1,u.) . e2 t1 (v1,v.) LINAPP G; \n. . . e1 e2 :t2 (u1,u.).(\u00d8,v1.v.) 1 G, x :t1;. .:x .v . et2 (v1,v.) LINABS1 G; . .. .1 x.e :t1.t2 (v1\\x,v.) \nG; . .. e1 :t1.t2 (u.) G; . .. e2 :t1 (v.) 1,u1,v LINAPP1 G; . .. e1 e2 :t2 (u1,u.).(v1,v.) G; . .. e1 \n:s (u1.) G, x :s;. .. e2 :t (v1.) ,u,vLINLET G; . .. let x = e1 in e2 1.u :t (\u00d8,u.).(v1\\x,v.\\x) G; . \n.. e1 :s (u1,u.) 1 G, x :s;. .. e2 :.) x . v t (v1,v LINLET1 G; . .. let1 x = in e2 e1 :t (u1,u.).(v1\\x,v.) \nG; . .. e :s a .ftv(G).ftv(.) . LINGEN G; . .. e :.a.s . ' G; . .. e :ss . s . LININST ' G; . .. e :s \n. i :G Is .. . LINANTI G; . .. i :s . Figure 8: Declarative typing rules for the linear object language \n3. The algebraic data type representing object languages types was extended with a construct for Linear \nMiniML typings, and the metalanguage uni.cation procedure was modi.ed to pass equalities between Linear \nMiniML types to the Linear MiniML solver. In total, these changes amounted to a few tens-of-lines of \ncode. Both the metalanguage type system presented in Section 4 and its implementation in the context \nof MetaHaskell are .exible enough to easily incorporate a variety of object languages, even substruc\u00adtural \nlanguages. 11 (u ,u .).(v ,v .)= ((u 1 \\v .).(v 1 \\u .),u . .v . .(u 1 nv 1)) 11 1 (u ,u .).(v ,v .)=(v \n1 nu ,u . .v . .(u 1 .v 1)) Figure 9: Variable use operators 6. Regular Expression Compilation in Cb \nOne of the original motivations for this work grew out of our experiences using Haskell to generate code \nfor C-like languages in Flask [25] and Nikola [24]. Projects like FFTW [14], ATLAS [40], and SPIRAL [29] \nshow that there are many practical applications for code generation, but that these applications require \ntargeting C-like languages. In this section we describe Cb, a pared-down version of C meant to demonstrate \nthat the MetaHaskell approach to heterogeneous metaprogramming is .exible enough to support these languages. \nAlthough the code generating applications we have cited, with the exception of Nikola, are used in an \noff-line fashion to gener\u00adate libraries for later linking with application code, we believe that on-line \ncode generation is also useful. In general, settings where pro.le-guided optimization [7] is bene.cial \nmay also be candidates for run-time code generation. A more concrete application that we believe would \nbene.t from run-time code generation is network packet inspection and processing which often includes \na compo\u00adnent that performs some kind of evaluation of a decision tree con\u00adstructed from pattern matching \nrules. The organization of branches in such a decision tree could easily be optimized given knowl\u00adedge \nabout the distribution of packets. In practice, this distribution will change over time, and we would \nlike to recompile our pattern matcher periodically to adapt it to the new packet distribution. If rules \nare added or removed as the packet inspection is executing, there is even more reason to desire run-time \ncode generation. We present a simple example in this vein: a regular expres\u00adsion compiler that generates \nexecutable binary code from a regular expression represented as a string. Because we take advantage of \nMetaHaskell s support for Cbas an object language, we don t have to include regular expression compilation \nas a primitive as .NET does with RegexOptions.Compiled. Instead, we can implement our own regular expression \ncompiler as a library without sacri.cing type safety. Figure 10 shows the DFA compilation stage of our \nregular ex\u00adpression compiler written to use GHC s QuasiQuotes language extension (we have elided the \nother stages suchs as regular expres\u00adsion parsing and NFA to DFA conversion). The function dfa2c has \ntype DFA . C.Func; it produces an abstract syntax tree repre\u00adsentation of a C function that implements \nthe DFA given to it as an argument. This version is not type safe we have no guarantee about the type \nof the generated code, although we do at least know that the genrated code will be syntatically correct. \nHowever, we can use MetaHaskell to write the same function and gain type safety. The type-safe version \nof the DFA compiler, written in Meta-Haskell, is given in Figure 11. We have elided some code that is \nun\u00adchanged with respect to the previous version all that has changed is the type signatures. Furthermore, \nthese signatures are exactly the types inferred by the Cbobject language inference engine and could themselves \nbe elided. Note that the use of the free variables state and accept in the quotation in the body of trans2c \nis propagated to the type of the quoted Cbstatement in the body of state2c. Although we could have de.ned \nan erasure function, as we did with MiniML, to convert a quoted Cb function de.nition to its corresponding \nabstract syntax, this would not have allowed us to maintain type safety when generating compiled code. \nThe [cfunb\u00b7] quasiquoter, in addition to elaborating a quoted function  dfa2c ::DFA .C.Func dfa2c (DFA \nstart states)= [cfun int matches (char *s) { int state =$int:(fromIntegral start); int accept =$int:(if \ndaccept startState then 1 else 0); while (*s ! =0){ switch (state){ $stms:(map state2c (map snd states))}} \nreturn accept; }] where startState ::DFAState startState =fromJust (lookup start states) state2c ::DFAState \n.C.Stm state2c (DFAState i accept trans)= [cstm case $int:(fromIntegral i):{ switch (*s+) { $stms:(map \ntrans2c trans) default:return 0; } break; }] trans2c ::(Char, DLabel).C.Stm trans2c (c, next)= [cstm \ncase $char:c:{ state =$int:(fromIntegral next); accept =$int:(if daccept nextState then 1 else 0); break; \n}] where nextState ::DFAState nextState = fromJust (lookup next states) Figure 10: DFA compiler in GHC \nto a Haskell term representing a FunPtr, must also incorporate a type function that translates Cb types \nto Haskell FFI types. The other delta with respect to MiniML and Linear MiniML is Cb s support for quoting \nand antiquoting multiple syntactic categories: functions, statements, and expressions can be quoted, \nand state\u00adments, lists of statements, expressions, and various constants can be antiquoted. 7. Implementation \nMetaHaskell is implemented in mhc which supports Haskell 98 plus MetaHaskell extensions. It includes \na type checker that elaborates to FC2 [39], a bytecode compiler, and a bytecode execution engine. Every \nMetaHaskell program can in fact be erased to a plain Haskell program, so it would take little effort \nto modify mhc to output pure Haskell. In essence, an object language quasiquoter consists of a parser, \na quasiquote type checker, and a uni.cation procedure for object lan\u00adguage types. The parser converts \na quasiquote into a pair consisting of the quote itself and a list of antiquotations, each of which is \nthen parsed by mhc as a MetaHaskell expression. The quasiquote type dfa2c ::DFA .FunPtr (CString .IO \nCInt) dfa2c (DFA start states)= ... where startState ::DFAState startState =... state2c :: DFAState \n.[cstm {int accept; int state; char *s} . Ivoid] state2c (DFAState i accept trans)=... trans2c :: (Char, \nDLabel) .[cstm {int accept; int state} . Ivoid]trans2c (c, next)=... Figure 11: DFA compiler in MetaHaskell \nchecker takes a quote and the Haskell expressions representing the elaborations of its antiquotes and \nreturns the type of the quote, the types each of its antiquotations must have, an elaborated Haskell \nterm representing the quote, and the type of the elaborated term. mhc then checks that the antiquotations \nhave the types speci.ed by the quasiquoter. The mhc type inference engine passes equality con\u00adstraints \nbetween object language type to the object language s type inference engine. Although the type inference \nengines for MiniML and Lin\u00adear MiniML required a fair amount of work, incorporating them into mhc took \ncomparatively little effort, as we detailed for Linear MiniML in Section 5. The Cb object language reused \na great deal of code from the language-c-quote package on Hackage [23]. We also reused much of the code \nfrom MiniML for inferring type environments, and as Cb is not polymorphic, type inference was otherwise \nstraightforward. The run-time code generation feature of Cb is implemented via unsafePerformIO by calling \nout to gcc to compile a function into a shared library and then dynamically load\u00ading the shared library. \nThis use of unsafePerformIO by the erasure of a [cfunb\u00b7] term is rendered safe by the extra type information \ncarried by the un-erased term. 8. Related Work There are a large number of type systems designed explicitly \nfor metaprogramming. We attempt to describe the major players and their important features here. Most \nof these systems are multi\u00adstage they support arbitrary nesting of quotation and antiquota\u00adtion. Stages \nare typically numbered by the quotation nesting level at which they occur, so programs without any quotations \nexist en\u00adtirely at stage 0. All systems are homogeneous, so the object lan\u00adguage and the metalanguage \nare identical. Some of these type sys\u00adtems support open code in the sense that quoted terms at stage \nn may contain free variables, but in all system but one, these free variables must be bound in a previous \nstage m < n. The use of variables bound in stage m by stages n > m is called cross\u00adstage persistence. \nCross-stage persistence and support for multiple stages make sense for homogeneous metaprogramming languages, \nbut they seem signi.cantly less important in the heterogeneous set\u00adting; support for cross-stage persistence \nwould require providing a meaningful translation of values from one language to the other, and multiple \nstages would require that the object language, which is different from the metalanguage, also be a metaprogramming \nlan\u00adguage. Mini-ML. [10, 11] and its corresponding core calculus, .. , support staged computation but \nnot open code. In contrast, .. [9] supports cross-stage persistence, but it does not provide a way to \nexpress (in the type system) the fact that a particular term is closed. . Nanevski [27] adds support \nfor intensional analysis to ..  .a [36] classi.es open code terms by their environment. Calcagno et \nal. [5] show that inference for .a is not possible and give a subset, .i let, for which inference can \nbe performed. As with .., a free variable must be bound in a previous stage. MiniMLmeta [4] adds support \nfor computational effects. ref + Chen and Xi [8] develop .code and show that it can be embed\u00added in a \nlanguage with GADTs. Neither polymorphic object terms nor open object terms are supported. We believe \nthat the combina\u00adtion of quasiquotation and GADTs in Haskell would serve to im\u00ad + plement all the features \nof .code. A prototype implementation of .code + exists, and .i let is essen\u00adtially the language supported \nby MetaOCaml. None of these sys\u00adtems support explicitly heterogeneous code. However, Eckhardt et al. \n[13] describe implicitly heterogeneous metaprogramming in which the meta-and object languages are both \nMetaOCaml, but a subset of object language terms can be translated or offshored automatically to C. Though \noffshoring cannot handle all MetaO-Caml terms, it is capable of handling non-trivial examples [34]. In \ncontrast, our system supports explicit metaprogramming in multi\u00adple object languages. We also provide \na path to adding heteroge\u00adneous metaprogramming support to an existing language through relatively minor \nlanguage extensions, whereas offshoring must be built on an existing homogeneous metaprogramming language. \nThe work most similar to ours is Kim et al. [20]. They sup\u00adport open code, inference, and effects for \nthe polymorphic lambda calculus. Like us, they use extensible records to provide principal typings for \ntheir multi-stage homogenous metaprogramming lan\u00adguage. Unlike MiniML, their system does not support \npolymorphic uses of free variables, so they cannot type the term (.e ..let f = .x .x in e.).(f1, f true). \nbecause the free variable f is instantiated at two different types in the object term .(f1, f true).. \nThey can, however, type the \u00df-reduced form, .let f = .x .x in (f1, f true).. Rhiger [32] shows how to \nsupport open code and inference, but in a simply\u00adtyped setting. Nanevski et al. [28] give a foundational \naccount of the kind of modal type system needed to support languages metaprogramming, but they ignore \nthe practical issue of inference. Kim et al. [20] describe an inference algorithm, but they do not provide \nan implementation. A signi.cant body of work addresses practical metaprogram\u00adming issues in the context \nof MetaOCaml [6, 17, 18, 21, 34]. We are very interested in adapting ideas from the MetaOCaml community \nto our setting, particularly those related to ef.cient object language code generation described by Swadi \net al. [34] and Kameyama et al. [18]. 9. Conclusions and Future Work MetaHaskell provides a modular framework \nfor supporting type safe heterogeneous meatprogramming with multiple object lan\u00adguages. Although two \nof the object languages we describe, MiniML and Linear MiniML, required novel type system features to \nsupport antiquotation and open terms, integrating then into MetaHaskell as object languages required \nlittle work. Our framework accommo\u00addates even exotic languages with substructural type systems. We also \nprovide a methodology for constructing an object language and its type system from a base language that \ndoes not support metaprogramming. MetaHaskell meets many of the goals outlined in Section 3. It provides \nsyntactic support, antiquotation, heterogeneity, type soundness, inference, open terms, and subterm typability. \nAlthough it seems we cannot in general provide subterm abstractability, we believe annotations are an \nacceptable solution. We have not ad\u00addressed fresh name generation or hygiene, but we expect that hy\u00adgiene \ncan be provided as outlined in Section 4.3. Our language only allows construction of type safe object \nlan\u00adguage terms. Intensional analysis of the terms is only possible by .rst calling a function like erase \nto yield an abstract syntax tree, losing type information in the process. Maintaining types while al\u00adlowing \nintensional analysis of object terms requires moving to a dependently typed language. An intermediate \nsolution that we plan to implement in MetaHaskell is a partial function check that, given an abstract \nsyntax tree and an object type, will check that the term represented by the abstract syntax tree has \nthe speci.ed type and cast the AST to an object term of that type. Although we do not describe them here, \nwe have both a syntax\u00addirected and an algorithmic version of the declarative type system for MiniML given \nin Figure 2. We are in the process of prov\u00ading progress and preservation, as well as soundness and complete\u00adness \nof the algorithmic system. We use R\u00e9my s uni.cation algo\u00adrithm [31], which is decidable and unitary, \nto unify typing contexts, and we use a similar algorithm to unify our extendable intersection types. \nOur inference algorithm for Linear MiniML is not complete because the type system does not quantify over \nlinearity; inference always makes the assumption that a free variable applied to an ar\u00adgument is not \na linear function. We also plan to translate our work to a dependently typed setting, like Coq. Although \nembedding an object language in Coq will not require modi.cations to Coq s type system since a strong \nembedding of the object language s type system should be possible, our techniques for constructing object \nlanguages and providing inference will still be useful. Furthermore, the modi.cations we made to Haskell \ns type system to support metaprogramming will provide guidance as we encode object language types in \nCoq. Acknowledgments We are grateful to Greg Morrisett for his early support and helpful discussions. \nDimitrios Vytiniotis helped clarify our thinking about generalization in the presence of antiquotation \nand suggested a greater focus on developing a methodology for constructing object languages from base \nlanguages. Claudio Russo and Nick Benton provided useful feedback on drafts of this paper. Andrew Kennedy \nbrought Boolean uni.cation to our attention. References [1] Robert Atkey, Sam Lindley, and Jeremy Yallop. \nUnembedding domain-speci.c languages. In Proceedings of the 2nd ACM SIGPLAN Symposium on Haskell (Haskell \n09), pages 37 48, Edinburgh, Scot\u00adland, 2009. ACM. [2] Franz Baader and Tobias Nipkow. Term Rewriting \nand All That. Cambridge University Press, 1998. [3] Gershom Bazerman. jmacro, jul 2011. [4] Cristiano \nCalcagno, Eugenio Moggi, and Tim Sheard. Closed types for a safe imperative MetaML. Journal of Functional \nProgramming, 13(03):545 571, 2003. [5] Cristiano Calcagno, Eugenio Moggi, and Walid Taha. ML-Like in\u00adference \nfor classi.ers. In In European Symposium on Programming (ESOP 04), volume 2986 of Lecture Notes in Computer \nScience, pages 79 93, 2004. [6] Jacques Carette. Gaussian elimination: A case study in ef.cient genericity \nwith MetaOCaml. Science of Computer Programming, 62 (1):3 24, sep 2006. [7] P. P. Chang and W.-W. Hwu. \nInline function expansion for compiling c programs. In Proceedings of the ACM SIGPLAN 1989 Conference \non Programming language design and implementation, PLDI 89, page 246 257, New York, NY, USA, 1989. ACM. \nISBN 0-89791-306-X. [8] Chiyan Chen and Hongwei Xi. Meta-Programming through typeful code representation. \nJournal of Functional Programming, 15(06): 797 835, 2005.  [9] R. Davies. A temporal-logic approach \nto binding-time analysis. In Proceedings of the 11th Annual IEEE Symposium on Logic in Com\u00adputer Science, \npage 184. IEEE Computer Society, 1996. [10] Rowan Davies and Frank Pfenning. A modal analysis of staged \ncomputation. In Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages, \npages 258 270, St. Petersburg Beach, Florida, United States, 1996. ACM. [11] Rowan Davies and Frank Pfenning. \nA modal analysis of staged computation. Journal of the ACM (JACM), 48:555 604, may 2001. ACM ID: 382785. \n[12] Edsko de Vries. Making Uniqueness Typing Less Unique. PhD thesis, Trinity College, Dublin, Ireland, \n2008. [13] Jason Eckhardt, Roumen Kaiabachev, Emir Pa ali\u00b4c, Kedar Swadi, and Walid Taha. Implicitly \nheterogeneous multi-stage programming. New Gen. Comput., 25(3):305 336, 2007. [14] Matteo Frigo and Steven \nG Johnson. The design and implementation of FFTW3. Proceedings of the IEEE, 93(2):216 231, 2005. Special \nissue on Program Generation, Optimization, and Platform Adapta\u00adtion . [15] Hideyuki Tanaka. peggy, feb \n2012. [16] Trevor Jim. What are principal typings and what are they good for? In Proceedings of the 23rd \nACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 42 53, St. Petersburg Beach, \nFlorida, United States, 1996. ACM. [17] Yukiyoshi Kameyama, Oleg Kiselyov, and Chung-chieh Shan. Clos\u00ading \nthe stage: from staged code to typed closures. In Proceedings of the 2008 ACM SIGPLAN symposium on Partial \nevaluation and semantics\u00adbased program manipulation, pages 147 157, San Francisco, Califor\u00adnia, USA, \n2008. ACM. [18] Yukiyoshi Kameyama, Oleg Kiselyov, and Chung-Chieh Shan. Shift\u00ading the stage: staging \nwith delimited control. Journal of Functional Programming, 21(06):617 662, 2011. [19] Andrew J. Kennedy. \nType inference and equational theories. Technical Report LIX/RR/96/09, LIX, Ecole Polytechnique, 91128 \nPalaiseau Cedex, France, sep 1996. [20] Ik-Soon Kim, Kwangkeun Yi, and Cristiano Calcagno. A polymorphic \nmodal type system for lisp-like multi-staged languages. In Conference record of the 33rd ACM SIGPLAN-SIGACT \nsymposium on Principles of programming languages, pages 257 268, Charleston, South Car\u00adolina, USA, 2006. \nACM. [21] Oleg Kiselyov and Walid Taha. Relating FFTW and Split-Radix. In Embedded Software and Systems, \npages 488 493. 2005. [22] Geoffrey Mainland. Why it s nice to be quoted: Quasiquoting for haskell. In \nHaskell 07: Proceedings of the ACM SIGPLAN Workshop on Haskell, page 73 82, New York, NY, USA, 2007. \nACM. [23] Geoffrey Mainland. language-c-quote, 2010. [24] Geoffrey Mainland and Greg Morrisett. Nikola: \nembedding com\u00adpiled GPU functions in haskell. In Proceedings of the third ACM Haskell symposium on Haskell, \npages 67 78, Baltimore, Maryland, USA, 2010. ACM. [25] Geoffrey Mainland, Greg Morrisett, and Matt Welsh. \nFlask: Staged functional programming for sensor networks. In Proceeding of the 13th ACM SIGPLAN International \nConference on Functional Pro\u00adgramming (ICFP 08), page 335 346, New York, NY, USA, 2008. ACM. [26] Urusula \nMartin and Tobias Nipkow. Boolean uni.cation The story so far. Journal of Symbolic Computation, 7(3 4):275 \n293, apr 1989. [27] Aleksandar Nanevski. Meta-programming with names and necessity. In Proceedings of \nthe seventh ACM SIGPLAN International Confer\u00adence on Functional Programming, pages 206 217, Pittsburgh, \nPA, USA, 2002. ACM. [28] Aleksandar Nanevski, Frank Pfenning, and Brigitte Pientka. Contex\u00adtual modal \ntype theory. ACM Transactions on Computational Logic (TOCL), 9:23:1 23:49, jun 2008. ACM ID: 1352591. \n[29] Markus P\u00fcschel, Jos\u00e9 M. F. Moura, Bryan Singer, Jianxin Xiong, Jeremy Johnson, David Padua, Manuela \nVeloso, and Robert W. John\u00adson. Spiral: A generator for Platform-Adapted libraries of signal pro\u00adcessing \nalogorithms. International Journal of High Performance Com\u00adputing Applications, 18(1):21 45, feb 2004. \n[30] Didier R\u00e9my. Type inference for records in natural extension of ML. Research Report 1431, Institut \nNational de Recherche en Informatique et Automatisme, 1991. [31] Didier R\u00e9my. Syntactic theories and \nthe algebra of record terms. Research Report 1869, Institut National de Recherche en Informatique et \nAutomatisme, Rocquencourt, BP 105, 78 153 Le Chesnay Cedex, France, 1993. [32] Morten Rhiger. First-class \nopen and closed code fragments. In Pro\u00adceedings of the Sixth Symposium on Trends in Functional Program\u00adming, \n2005. [33] Zhong Shao and Andrew W. Appel. Smartest recompilation. In Pro\u00adceedings of the 20th ACM SIGPLAN-SIGACT \nsymposium on Princi\u00adples of programming languages, pages 439 450, Charleston, South Carolina, United \nStates, 1993. ACM. [34] Kedar Swadi, Walid Taha, Oleg Kiselyov, and Emir Pasalic. A monadic approach \nfor avoiding code duplication when staging mem\u00adoized functions. In Proceedings of the 2006 ACM SIGPLAN \nsympo\u00adsium on Partial evaluation and semantics-based program manipula\u00adtion, PEPM 06, page 160 169, New \nYork, NY, USA, 2006. ACM. ACM ID: 1111570. [35] Walid Taha. A gentle introduction to multi-stage programming. \nIn Christian Lengauer, Don S. Batory, Charles Consel, and Martin Oder\u00adsky, editors, Domain-Speci.c Program \nGeneration, volume 3016 of Lecture Notes in Computer Science, page 30 50. Springer, 2003. [36] Walid \nTaha and Michael Florentin Nielsen. Environment classi.ers. In Proceedings of the 30th ACM SIGPLAN-SIGACT \nsymposium on Principles of programming languages, POPL 03, page 26 37, New York, NY, USA, 2003. ACM. \n[37] Walid Taha and Tim Sheard. Multi-stage programming with explicit annotations. In Proceedings of \nthe 1997 ACM SIGPLAN symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM 97), \npages 203 217, Amsterdam, The Netherlands, 1997. ACM. [38] Philip Wadler. Is there a use for linear logic? \nIn Proceedings of the 1991 ACM SIGPLAN symposium on Partial evaluation and semantics\u00adbased program manipulation, \nPEPM 91, page 255 273, New York, NY, USA, 1991. ACM. ISBN 0-89791-433-3. [39] Stephanie Weirich, Dimitrios \nVytiniotis, Simon L. Peyton Jones, and Steve Zdancewic. Generative type abstraction and type-level compu\u00adtation. \nIn Proceedings of the 38th ACM SIGPLAN-SIGACT sympo\u00adsium on Principles of programming languages (POPL \n11), Austin, TX, 2011. [40] R. Clint Whaley and Antoine Petitet. Minimizing development and maintenance \ncosts in supporting persistently optimized BLAS. Softw. Pract. Exper., 35(2):101 121, 2005. [41] Hongwei \nXi, Chiyan Chen, and Gang Chen. Guarded recursive datatype constructors. In Proceedings of the 30th ACM \nSIGPLAN-SIGACT symposium on Principles of programming languages -POPL 03, pages 224 235, New Orleans, \nLouisiana, USA, 2003.   \n\t\t\t", "proc_id": "2364527", "abstract": "<p>Languages with support for metaprogramming, like MetaOCaml, offer a principled approach to code generation by guaranteeing that well-typed metaprograms produce well-typed programs. However, many problem domains where metaprogramming can fruitfully be applied require generating code in languages like C, CUDA, or assembly. Rather than resorting to add-hoc code generation techniques, these applications should be directly supported by <i>explicitly heterogeneous</i> metaprogramming languages.</p> <p>We present MetaHaskell, an extension of Haskell 98 that provides modular syntactic and type system support for type safe metaprogramming with multiple object languages. Adding a new object language to MetaHaskell requires only minor modifications to the host language to support type-level quantification over object language types and propagation of type equality constraints. We demonstrate the flexibility of our approach through three object languages: a core ML language, a linear variant of the core ML language, and a subset of C. All three languages support metaprogramming with open terms and guarantee that well-typed MetaHaskell programs will only produce closed object terms that are well-typed. The essence of MetaHaskell is captured in a type system for a simplified metalanguage. MetaHaskell, as well as all three object languages, are fully implemented in the mhc bytecode compiler.</p>", "authors": [{"name": "Geoffrey Mainland", "author_profile_id": "81100519306", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P3804377", "email_address": "gmainlan@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2364527.2364572", "year": "2012", "article_id": "2364572", "conference": "ICFP", "title": "Explicitly heterogeneous metaprogramming with MetaHaskell", "url": "http://dl.acm.org/citation.cfm?id=2364572"}