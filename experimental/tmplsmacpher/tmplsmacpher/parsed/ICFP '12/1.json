{"article_publication_date": "09-09-2012", "fulltext": "\n Veri.ed Heap Theorem Prover by Paramodulation Gordon Stewart Lennart Beringer Andrew W. Appel Princeton \nUniversity, Princeton, NJ, USA {jsseven, eberinge, appel}@cs.princeton.edu Abstract We present VeriStar, \na veri.ed theorem prover for a decidable subset of separation logic. Together with VeriSmall [3], a proved-sound \nSmallfoot-style program analysis for C minor, VeriStar demonstrates that fully machine-checked static \nanalyses equipped with ef.cient theorem provers are now within the reach of formal methods. As a pair, \nVeriStar and VeriSmall represent the .rst application of the Veri.ed Software Toolchain [4], a tightly \nintegrated collection of machine-veri.ed program logics and compilers giving foundational correctness \nguarantees. VeriStar is (1) purely functional, (2) machine-checked, (3) end\u00adto-end, (4) ef.cient and \n(5) modular. By purely functional, we mean it is implemented in Gallina, the pure functional programming \nlan\u00adguage embedded in the Coq theorem prover. By machine-checked, we mean it has a proof in Coq that \nwhen the prover says valid , the checked entailment holds in a proved-sound separation logic for C minor. \nBy end-to-end, we mean that when the static analy\u00adsis+theorem prover says a C minor program is safe, \nthe program will be compiled to a semantically equivalent assembly program that runs on real hardware. \nBy ef.cient, we mean that the prover imple\u00adments a state-of-the-art algorithm for deciding heap entailments \nand uses highly tuned veri.ed functional data structures. By modular, we mean that VeriStar can be retro.tted \nto other static analyses as a plug-compatible entailment checker and its soundness proof can easily be \nported to other separation logics. Categories and Subject Descriptors F.3.1 [Specifying and Verify\u00ading \nand Reasoning about Programs]: Mechanical veri.cation General Terms Veri.cation Keywords Separation Logic, \nParamodulation, Theorem Proving 1. Introduction Can you trust your decision procedure? When your memory \nanalysis that calls upon this decision procedure returns safe , how con.dent can you be that your C program \nwon t dereference a null pointer? If you re writing safety-or security-critical code then such questions \nare crucial, but often dif.cult to answer: state-of-the-art theorem provers are large, intricate programs \n(Z3, for example, is over 300k lines of proprietary code [18]). A bug in the decision procedure might \ncamou.age a bug in your static analysis regime, which may itself hide a disastrous bug in your safety-critical \nprogram. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n12, September 9 15, 2012, Copenhagen, Denmark. Copyright &#38;#169; 2012 ACM 978-1-4503-1054-3/12/09 \n$15.00. To bridge the trust gap, you can instrument the decision pro\u00adcedure to produce witnesses as in \nproof-carrying code (PCC) [5, 11, 27] or implement and verify the decision procedure di\u00ad rectly in a \nproof assistant [6, 12, 33]. Although one might suspect that separating the prover from the checker is \nnecessary for ef.\u00adciency, modern proof assistants have advanced to the point that it is now feasible \nto implement and verify even sophisticated analyses in a foundational way. As evidence of this claim, \nwe present VeriStar, an ef.cient machine-veri.ed decision procedure for entailments in separation logic, \nthe de facto standard for reasoning about shape properties of heap data. Tools based on separation logic, \nsuch as SLAyer [10], SpaceInvader [15], Infer [14] and Xisa [16], have been successfully applied to industrial \ncode bases but have lacked foundational certi.\u00adcation. VeriStar integrates with VeriSmall [3], a machine-checked \nsymbolic executor, to yield a fully veri.ed shape analysis for sep\u00adaration logic. When connected to the \nCompCert certi.ed C com\u00adpiler [23], VeriSmall+VeriStar enables end-to-end automatic veri.\u00ad cation of \nshape properties all the way from C to x86 or PowerPC assembly. Because CompCert s correctness theorem \nmakes a claim directly about the generated assembly, the user of our system need trust only the Coq typechecker \nand CompCert s model of either x86 or PowerPC assembly. Contributions. The VeriStar system is: Purely \nfunctional. We implemented VeriStar in Gallina, the pure functional language embedded in the interactive \ntheorem prover Coq. The use of a pure functional implementation lan\u00adguage gave us both an elegant programming \nenvironment and an attractive proof theory for reasoning about our code.  Machine-checked. We proved \nVeriStar sound with a machine\u00adchecked proof in Coq. Soundness means that when the prover returns valid \n, the entailment checked holds in an separation logic for C minor [22]. The separation logic is proved \nsound, in turn, with respect to C minor s operational semantics.  End-to-end. C minor programs veri.ed \nwith VeriStar can be compiled to (PowerPC or x86) assembly by the semantics\u00adpreserving compiler CompCert. \nThe end-to-end machine\u00adchecked proof ensures the absence of soundness bugs anywhere along the chain. \n Ef.cient. VeriStar implements a state-of-the-art decision pro\u00adcedure based on paramodulation, a variant \nof resolution (cf. Navarro P\u00b4 erez and Rybalchenko [26]), and can be compiled using Coq s code extraction \nutility and the OCaml system to native code for nearly any architecture. It uses highly tuned veri\u00ad.ed \nfunctional data structures such as a new implementation of red-black trees to implement clause sets. \n Modular. Although VeriStar forms the core of the fully veri.ed static analysis VeriSmall, its modular \nstructure means it can be retargeted to third-party separation logics and retro.tted to ex\u00ad   isting \nstatic analysis tools such as Smallfoot [9]. As supporting evidence, we describe two alternative separation \nlogics (Sec\u00adtion 4) and demonstrate the integration of our prover into the original (Berdine et al.) \nSmallfoot system. To the best of our knowledge, VeriStar is the .rst machine-checked theorem prover for \nseparation logic that connects to a real-world operational semantics (CompCert C minor). The VeriStar \narchitec\u00adture employs a novel abstraction of separation logic, the Separation Logic Interface, in order \nto separate the system s soundness proof from the details of the separation logic implementation, and \nthus increase modularity. More generally, the lessons we learned while building VeriStar on the effectiveness \nof code extraction as an execution model for veri.ed software, on the power of an elegant proof theory \nfor reasoning about functional programs, and on the importance of modular interfaces to proofs will inform \nthe future construction of large, veri.ed software toolchains from independent, machine-checked components. \nWe have evaluated VeriStar on a suite of separation logic entail\u00adments generated by the original Smallfoot \ntool during symbolic exe\u00adcution. On these real-world entailments, VeriStar s performance is comparable \nto that of Smallfoot s unveri.ed entailment checker both systems are fast enough. On a suite of arti.cial \nentailments designed to simulate the heap inconsistency checks often performed during symbolic execution, \nVeriStar actually outperforms Small\u00adfoot on the majority of entailments. On the other hand, VeriStar \nis still a small system that lacks features found in more established theorem provers. The current implementation \nof VeriStar supports just four atomic predicates: the points-to predicate of separation logic describing \nthe singleton heap, a predicate describing acyclic list segments, a predicate describing empty heaps \nand an equality predicate on program variables. This assertion language resembles Smallfoot s quite closely \nbut does not yet permit general intermix\u00ading of predicates from other theories, as in SMT solvers. Finally, \nalthough VeriStar s performance is adequate for veri.cation of small to medium-sized programs, it could \nbe further improved by memo\u00adizing common terms in the clause database through techniques such as hash-consing, \nor by performing multiple inferences at once, as is done in some state-of-the-art equational theorem \nprovers [24]. None of these limitations is insurmountable. We foresee few technical dif.culties in adding \nsupport for user-de.ned nonspatial predicates and spatial predicates for other sorts of data structures \nsuch as trees. Switching to a more ef.cient term and clause representation will require straightforward \nengineering. 2. VeriStar by Example Figure 1 presents the main components of the VeriStar theorem prover. \nTo build an intuition for how the pieces .t together, consider the following (valid) VeriStar entailment \na = d . a . b * lseg(b, c) * lseg(b, d) f lseg(a, c) = c . b which consists of two assertions separated \nby a turnstile (f). The .rst assertion states that program variable a does not equal c, b equals d and \nthe heap contains a pointer from a to b and two list segments with heads b and tails c and d, while the \nassertion to the right of the turnstile states that the heap is just the list segment with head a and \ntail c. The task of the theorem prover is either to show that this entailment is valid that every model \nof the assertion on the left is a model of the assertion on the right or to return a counterexample in \nthe process. Most existing theorem provers for separation logic (e.g., Small\u00adfoot [9], SLAyer [10]) attack \nthe entailment problem top-down, by systematically exploring proof trees rooted at the goal. Each step \nof a top-down proof is an entailment-level deduction justi.ed by a validity-preserving inference rule. \n Figure 1: The main components of the VeriStar system, each of which is de.ned by a well-speci.ed interface \n(Module Type) in Coq. Superpose and HeapResolve form the heart of the heap theorem prover, performing \nequational and spatial reasoning respectively. The ClauseSet module de.nes the clausal embedding of assertions \nas well as the prover s clause database using a tuned red-black tree implementation of the Coq MSets \ninterface. VeriStar, by contrast, is bottom-up and indirect. Instead of exploring proof trees rooted \nat the goal, it .rst decomposes the negation of the goal (hence indirect) into a logically equivalent \nset of clauses (its clausal normal form), then attempts to derive a contradiction from this set through \nthe application of clausal inference rules. One can think of the clauses that form this initial set as \na logically equivalent encoding of the original entailment into its atomic parts. In particular, a VeriStar \nclause is a disjunction (p1 . ... . pm ) . (p1'. ... . pn') . (s1 * ... * sr ) of positive pure literals \np (by pure we mean those that are heap\u00adindependent), negated pure literals p' and a spatial atom S consist\u00ading \nof the star-conjoined simple spatial atoms s1 * ... * sr . The atom S may be negated or may occur positively \nbut not both: we never require clauses containing two atoms S and S' of different polarities. We write \npositive spatial clauses (those in which S occurs positively) as G . ., S, where G and . are sets of \npure atoms and S is a spatial atom, and use analogous notation for pure and negative spatial clauses. \nFor example, in negative spatial clauses, S appears to the left of the arrow (G, S . .), and in pure \nclauses S does not appear at all (G . .). The empty clause \u00d8.\u00d8 has no model because on the left, the \nconjunction of no clauses is True, and on the right, the disjunction of no clauses is False. Clauses \nsuch as G . a = a, . and G, a = b . a = b, . are tautologies. To express the negation of the entailment \nas a set of clauses, VeriStar passes the entailment to ClauseSet.cnf (Figure 1), which takes advantage \nof the fact that it can encode any positive atom p as the positive unit clause \u00d8. p and any negative \natom p' as the negative unit clause p' .\u00d8. It can do the same for negative and positive spatial atoms. \nSince the negation of any entailment F f G is equivalent, classically, to F .\u00acG, the original entailment \nbecomes: a = c . \u00d8 \u00d8 . b \u00d8 . alseg(a, c) . \u00d8 = d . b * lseg(b, c) * ls eg(b, d) (1) (2) (3) (4) Here \nthe spatial atom lseg(a, c) appears to the left of the arrow in clause (4) since it appears in the right-hand \nside of the original entailment. Likewise, the spatial atom a . b*lseg(b, c)*lseg(b, d)  (a) Integration \ninto the Veri.ed Software Toolchain, (b) Compilation toolchain yielding an end-to-end soundness proof \nFigure 2: VeriStar s soundness proof (2a) and compilation toolchain (2b). Trusted components (dashed \nin red) are those that must be understood by the user to have con.dence in the system. Veri.ed components \n(solid in blue) have machine-checked correctness proofs. Cminor opsem and x86, PowerPC opsem are axiomatic \nde.nitions of the Cminor language and CompCert target languages respectively. When connected to the Veri.ed \nSoftware Toolchain (2a), machine-checked proofs from VeriSmall/VeriStar through CompCert to assembly \nprovide a foundational correctness guarantee with respect to the operational semantics of CompCert s \ntarget languages, x86 and PowerPC assembly. The modular construction of the soundness proof through the \nSeparation Logic Interface facilitates retargeting VeriStar to third-party separation logics. VeriSmall \nis proved directly with respect to the C minor separation logic, and therefore is slightly less portable. \nIn Figure 2b, we use Coq s extraction mechanism and the OCaml system to compile VeriStar to an executable \napplication. appears to the right of the arrow in clause (3) since it appears in the left-hand side of \nthe original entailment. After encoding the entailment as a set of clauses, VeriStar enters its main \nloop (VeriStar.main loop in Figure 1). First, it .lters the pure clauses from the initial clauseset (clauses \n(1) and (2) above), then passes these clauses to Superpose.check pures, the pure prover. Superpose attempts \nto derive a contradiction from the pure clauses by equational reasoning. In this case, however, Superpose \nis unable to derive a contradiction, or indeed, any new clauses at all from the set, so it constructs \na model of the pure clauses by setting b equal to d (completeness of the superposition calculus guarantees \nthat this model exists) and passes the model, along with the current clauseset, to HeapResolve for spatial \nnormalization and unfolding. HeapResolve uses the fact that b equals d in the model as a hint to normalize \nthe spatial clauses (3) and (4) by clause (2), resulting in the new spatial clause \u00d8. a . d * lseg(d, \nc) * lseg(d, d) (5) in which b has been rewritten to d and therefore no longer appears. But now the spatial \nprover recognizes that since list segments are acyclic, lseg(d, d) can hold only if it denotes the empty \nheap. Thus lseg(d, d) can be simpli.ed to emp, resulting in the new clause \u00d8. a . d * lseg(d, c). (6) \nClause (7) can then be resolved with clause (6) to produce the positive unit clause \u00d8. a = c. (8) Superpose \nnow resolves clause (8) with clause (1) to derive the empty clause \u00d8.\u00d8, which is unsatis.able. Since \nthe inference rules of the HeapResolve and Superpose systems preserve all models, the original set of \nclauses encoding the negation of the entailment VeriStar set out to prove is unsatis.able; the entailment \nmust therefore be valid. 2.1 Overview of the Rest of the Paper In the next section, we introduce VeriStar \nin the context of the Veri\u00ad.ed Software Toolchain [4], a series of tightly integrated machine\u00ad veri.ed \ncomponents that connect end-to-end to yield foundational correctness guarantees. We also describe VeriStar \ns execution model. Sections 4 and 5 give the technical details of our model of separa\u00ad tion logic and \nthe VeriStar implementation and its soundness proof in Coq. Section 7 makes a case for machine-checked \nproofs, with examples from this case study. Section 8 describes our experience optimizing VeriStar. In \nSection 9, we evaluate the relative sizes in lines-of-code of the components of the prover and measure \nVeri\u00adStar s performance on a suite of benchmarks. This new clause can almost be resolved against clause \n(4) using spatial resolution an inference rule allowing negative and positive occurrences of spatial \natoms in two different clauses to be eliminated but only if clause (4) is unfolded to accommodate the \nnext atom a . d in clause (6). Unfolding lseg(a, c) to a . d * lseg(d, c) is sound, in turn, only when \nlseg(a, c) is nonempty, i.e., when a = c. To encode this fact, HeapResolve generates the new clause a \n. d * lseg(d, c) . a = c. (7) 3. The Veri.ed Software Toolchain The Veri.ed Software Toolchain [4] connects \nmachine-checked program analyses to machine-checked program logics; the logics are connected to machine-checked \ncompilers such as Leroy s CompCert, giving an end-to-end result. Figure 2a puts VeriSmall and VeriStar \nin the context of the current instantiation of the Veri.ed Software Toolchain: VeriStar is proved sound \nwith respect to an abstract axiomatization of separation logic, the Separation Logic Interface (Section \n4.2). VeriSmall is proved sound directly with respect to the C minor separation logic. Of course, VeriSmall \ns soundness proof must rely on that of VeriStar since VeriSmall frequently calls the prover to decide \nentailments during symbolic execution.  We instantiate the Separation Logic Interface with Hobor et \nal. s separation logic for C minor [22], which has a machine\u00ad checked soundness proof in Coq with respect \nto CompCert C minor s operational semantics. Because CompCert preserves the semantics of safe C minor \nprograms, properties proved at the source level using VeriSmall/VeriStar will hold of the generated assembly. \nFurthermore, although the operational semantics of C minor and those of CompCert s intermediate languages \nplay a role in the end\u00adto-end proof, only the operational semantics of the target languages, PowerPC \nand x86 assembly, must be trusted since the compiler s correctness theorem makes a claim directly about \nthe behavior of the target program. 3.1 Execution via Extraction We use Coq s extraction utility to \ngenerate OCaml code (veristar.ml, Figure 2b) for VeriStar. A small, trusted translation from Smallfoot\u00ad \nstyle entailments to VeriStar entailments (driver.ml) allows our mod\u00adi.ed Smallfoot to call VeriStar.check \nentailment as a subroutine, thus replacing Smallfoot s standard entailment checker with a for\u00admally veri.ed \none and reducing the size of Smallfoot s trusted com\u00adputing base by approximately 20% (modulo correctness \nof the Coq typechecker1). When connected to the machine-checked static anal\u00ad ysis VeriSmall, VeriStar \ns trusted computing base is even smaller: just the Coq typechecker and CompCert s speci.cations of either \nPowerPC or x86 assembly. 4. Separation Logic Semantics To ensure VeriStar can be retargeted to separation \nlogics for a variety of languages and compiler frameworks, we proved the system sound with respect to \nan abstract model of separation logic. We .rst de.ned a generic Separation Logic Interface (Section 4.2) \nspecifying the operators of separation logic on which the proof depends. We then constructed an abstract \nmodel of separation logic generically for any concrete implementation satisfying the interface (Section \n4.3). We have instantiated the interface with two such implementations, Hobor et al. s Separation Logic \nfor C minor [22] and a bare-bones implementation (cf. Appendices B and C of the extended version of this \npaper [1]) but expect the interface, and hence VeriStar s soundness proof, to be general enough to be \nwidely applicable. 4.1 The Assertion Language Atomic assertions in VeriStar (Figure 3) denote equalities \nand inequalities of program variables, singleton heaps and acyclic list segments. The assertion emp denotes \nthe empty heap. The assertion a . b (Next ab in VeriStar syntax) denotes the heap containing just the \nvalue of variable b at the location given by a (and is empty everywhere else), while Lseg ab denotes \nthe heap containing the acyclic list segment with head pointer a and tail pointer b. Equalities and inequalities \nof variables are pure assertions because they make no reference to the heap, whereas a . b and Lseg are \nspatial assertions. A complex assertion . . S is the conjunction of the pure atoms . with the separating \nconjunction of the spatial atoms S. The separating conjunction s1 * s2 (also called star) of two assertions \na notion from separation logic is satis.ed by any heap splittable into two disjoint subheaps satisfying \ns1 and s2, respectively. The assertion . . S is satis.ed by any environment e and heap h such 1 and the \nCoq program-extractor, and the OCaml compiler that compiles both veristar.ml and driver.ml, and the C \ncompiler that compiles OCaml s runtime system... For a discussion of these issues, see [4, Section 11]. \nExpressions a, b Nil null pointer Var x Program variable Pure Atoms p (pn atom) Equ a b Expression a \nequals b. Nequ a b Expression a does not equal b. Spatial Atoms s (space atom) emp Empty heap Next ab \nSingleton heap with a . b Lseg ab Acyclic list segment from a to b Assertions F , G Assertion .S Pairs \nof pure atoms . and spatial atoms S Entailments ent Entailment FG Assertion F implies G. Figure 3: VeriStar \nsyntax that e satis.es all the assertions in . and the pair (e, h) satis.es the separating conjunction \nof the assertions in S. Entailments F f G are valid whenever all the models satisfying F also satisfy \nG, i.e.: .(e, h). F (e, h) . G(e, h). 4.2 The Interface We present a selection of the components of \nthe Separation Logic In\u00adterface in Listing 1. The interface axiomatizes the types of locations loc and \nvalues val; the special values nil val, corresponding to the null pointer, and empty val, corresponding \nto unde.ned (i.e., not in the domain of a given heap); an injection val2loc from values to locations; \nthe types of variable environments env and heaps (heap) and a points-to operator on heaps (rawnext). \nWe assume a separation algebra [20] on values (Sep alg val), meaning that in addition to the operators \non values speci.ed in the interface (e.g., val2loc) we may use the join operator, written ., to describe \nthe union of two disjoint values. In simple separation logics, v1 . v2 is de.ned only when either v1 \nor v2 is the empty val (that is, two nonunit values are never disjoint). However, a more re.ned separation \nalgebra on values, say with shares denoting read and write permissions, is often useful in concurrent \nseparation logic. Our interface and the soundness proof are indifferent to the separation algebra actually \nused. The parameter heap gives the type of program memories. As with val, we require a separation algebra \non heaps. We also require two operators on heaps, rawnext, a low-level version of the . predicate of \nseparation logic, and emp at (l:loc)(h:heap), which de.nes when a heap h is empty at a location l. The \nbehavior of these operators is de.ned by a series of axioms. For example, the axiom rawnext out asserts \nthat the heap rawnext lv is empty everywhere except at location l (i.e., it is a singleton heap). The \nconstructor mk heap rawnext allows one to construct new singleton heaps. In the de.nition of mk heap \nrawnext, comparable hh ' means that h and h ' share the same unit in our multi-unit separation algebras \n' (thus they are comparable).2 The assertion rawnext lv extends rawnext lv to any heap that contains \nl . v as a subheap. The behavior of rawnext ' is given by a series of axioms not shown in Listing 1 but \ngiven in the code.  4.3 The Abstract Model We de.ned our abstract separation logic model with respect \nto the opaque interface of Listing 1. In our Coq implementation, this model is literally a functor over \nmodules satisfying the interface: we make 2 Dockins et al. [20] describes why multi-unit separation algebras \nare preferable to standard, single-unit ones.  Module Type VERISTAR LOGIC. (*Locations and values*) \nParameters loc val : Type. Declare Instance Sep val : Sep alg val. Parameter val2loc : val . option loc. \nParameter nil val : val. Parameter empty val : val. (*Environments*) Parameter env : Type. Parameter \nenv get : env . var . val. Parameter env set : var . val . env . env. Axiom gss env : .(x : var) (v:val) \n(e:env), env get (env set xve) x = v. Axiom gso env : .(xy : var) (v:val) (e:env), x = y . env get (env \nset xve) y = env get ey. Parameter empty env : env. (*Heaps*) Parameter heap : Type. Declare Instance \nSep heap: Sep alg heap. Parameter rawnext : .(x:loc) (y:val) (e:heap), Prop. Parameter emp at: .(l:loc) \n(h:heap), Prop. De.nition nil or loc(v:val) := v=nil val ..l:loc, val2loc v = Some l. Axiom mk heap \nrawnext : .hx0 xy, val2loc x0 = Some x . nil or loc y . '' ' .h , rawnext xyh . comparable hh . Axiom \nrawnext out : .xx0 x ' yh, rawnext xyh . val2loc x0 = Some x ' . x ' = x . emp at x ' h. De.nition rawnext \nxyh := .h0, join sub h0 h . rawnext xyh0. (*Further parameters and axioms are elided.*) End VERISTAR \nLOGIC. Listing 1: Selected values, operators and their properties from the Separation Logic Interface. \nThe abstract types val, loc, var, env and heap are interface parameters. no assumptions in the proof \nabout the underlying module beyond those de.ned in the interface, thus increasing portability. States \nare pairs of environments e and heaps h. Inductive state := State: .(e:env) (h:heap), state. The Coq \nkeyword Inductive declares a new inductively de.ned datatype with, in this case, a single constructor \nnamed State. State takes as parameters an environment e and a heap h. In more conventional ML-like notation, \nthis type is equivalent to the product type State of (env * heap). Predicates on states, called spreds, \nare functions from states to Prop. Notation spred := (state . Prop). One can think of Prop as the type \nof truth values True and False, analogous to bool, except that predicates in Prop need not be decidable \nand are erased during program extraction. Thus, we use Prop in our proofs, but bool in the veri.ed code. \nA Coq Notation simply de.nes syntactic sugar. The interpretations of expressions (expr denote), expression \nequality (expr eq) and pure atoms (pn atom denote) are standard. List segments lseg are de.ned by an \ninductive type with two constructors. Inductive lseg : val . val . heap . Prop := | lseg nil : .xh, emp \nh . nil or loc x . lseg xxh | lseg cons : .xyzlh0 h1 h, x = y . val2loc x = Some l . rawnext lzh0 . lseg \nzyh1 . join h0 h1 h . lseg xyh. The lseg nil constructor forms the trivial list segment whose head and \ntail pointers are equal and whose heap is emp. The lseg cons constructor builds a list segment inductively \nwhen x does not equal y, x is injected to a location l such that l . z, and there is a sub-list segment \nfrom z to y. The function space atom denote maps syntactic spatial as\u00adsertions such as Lseg xy to their \nsemantic counterparts (i.e., lseg xy). De.nition space atom denote (a: space atom) : spred := match a \nwith Next xy . fun s . match val2loc (expr denote xs) with | None . False | Some l . rawnext l (expr \ndenote ys) (hp s) . nil or loc (expr denote ys) end | Lseg xy . fun s . lseg (expr denote xs) (expr denote \nys) (hp s) end. For Next xy assertions, it injects the value of the variable x to a location l and requires \nthat the heap contain just the location l with value v (that is, the heap must be the singleton l . v), \nwhere v is the interpretation of variable y. Coq s match syntax does case analysis on an inductively \nde.ned value (here the space atom a), de.ning a distinct result value for each constructor. An Assertion \n.S is the conjunction of the pure atoms p . . with the separating conjunction of the spatial atoms s \n. S. De.nition assertion denote (f :assertion) : spred := match f with Assertion .S . fold pn atom denote \nandp (space denote S) . end. The function space denote interprets the list of spatial atoms S as the \nfold of space atom denote over the list, with unit emp. Thus (space denote S) is equivalent to  *s.Sspace \natom denote(s)* emp (where *is iterated separating conjunction) and the denotation of Assertion .S is \n pn atom denote(p) .*s.Sspace atom denote(s) p.. if one simpli.es P * emp to P (recognizing that emp \nis the unit for *). Here space denote S is the unit of the fold. Entailments from F to G are interpreted \nas the semantic entailment of the two assertions. 5. The VeriStar Algorithm A key strength of the Navarro \nP\u00b4 erez and Rybalchenko algorithm is that it splits the theorem prover into two modular components: the \nequational theorem prover for pure clauses (Superpose) and the spatial reasoning system HeapResolve, \nwhich calls Superpose as a subroutine in between rounds of spatial inference. This modular structure \nmeans well-studied techniques from equational theorem proving can be applied to the equational prover \nin isolation, while improving the performance of the heap theorem prover as a whole.  1 Function main \nloop 2 (n: positive ) (S: list space atom) (ncl: clause) (S: M.t) 3 {measure nat of P n} := 4 if Coqlib. \npeq n 1 then Aborted (M.elements S) else 5 match Superpose.check pures S with 6 | (Superpose.Valid, units,,) \n. Valid 7 | (Superpose.C example R sel, units, S * ,) . 8 let S ' := simplify atoms units S in 9 let \nncl ' := simplify units ncl in 10 let c := norm sel (PosSpaceClause nil nil S ' ) R in 11 let S1 := \nincorp (do wellformed c) S * in 12 if isEq (M.compare S1 S * ) 13 then if is model of . (List.rev R) \nncl ' 14 then let c ' := norm sel ncl ' in 15 let us := pures (unfolding cc ' ) in 16 let S2 := incorp \nus S1 in 17 if isEq (M.compare S1 S2) then C example R 18 else main loop (Ppred n) S ' ncl ' S2 c 19 \nelse C example R 20 else main loop (Ppred n) S ' ncl ' S1 c 21 | (Superpose.Aborted l, units,,) . Aborted \nl 22 end. 23 Proof. 24 (*Termination proof here, that n decreases*) 25 De.ned. 26 27 De.nition check \nentailment (ent: entailment) := 28 let S := pure clauses (map order eqv clause (cnf ent)) in 29 match \nent with 30 | Entailment (Assertion .S) (Assertion . ' S ' ) . 31 match mk pureR ., mk pureR . ' with \n32 | (.+, .-), (. '-) . +, . ' 33 main loop m S (NegSpaceClause . ' + S ' . '-) 34 (clause list2set S) \n35 end 36 end. Listing 2: The main VeriStar procedures In this section, we describe our veri.ed implementation \nof the algorithm of Navarro P\u00b4 erez and Rybalchenko and give an outline of its soundness proof in Coq. \n5.1 Overview of the Algorithm Listing 2 de.nes the main procedures of the VeriStar system, in slightly \nsimpli.ed form (we have commented out the termination proof for main loop, line 24). The .rst step is \nto encode the entailment, ent, as a set of clauses (its clausal normal form, line 28). The algorithm \nthen enters its main loop, .rst calling Superpose.check pures (line 5) on the current set of pure clauses \nS, a subset of the clauses that encode ent, and checking whether the equational prover was able to derive \nthe empty clause from this set. If it was, the algorithm terminates with Valid (line 6). Otherwise, Superpose \nreturns with a model R of the set of pure clauses (line 7) and a list of unit clauses units derived during \nsuperposition inference (also line 7). VeriStar .rst rewrites the spatial atoms S and spatial clause \nncl by units (lines 8-9), then normalizes the rewritten positive spatial atom S ' using the model R (line \n10). It then adds any new pure clauses implied by the spatial wellformedness rules to the pure set (line \n11). This process repeats until it converges on a .xed point (or the prover aborts abnormally; see Section \n7 for details). Once a .xed point is reached, more normalization of spatial atoms is performed (line \n14), and unfolding of lsegs is attempted (line 15), possibly generating new pure clauses to feed back \ninto the loop. If no new pure clauses are generated during this process, the algorithm terminates with \na counterexample.  5.2 HeapResolve for Spatial Reasoning VeriStar divides spatial reasoning (lines 10-15 \nin Figure 2) into four major stages: normalization of spatial atoms, wellformedness inference, unfolding \nof list predicates and spatial resolution. Normalization rules perform substitutions into spatial atoms \nbased on pure facts inferred by the superposition system, as well as eliminate obviously redundant list \nsegments of the form lseg(x, x). Wellformedness rules generate new pure clauses from malformed spatial \natoms. Consider, for example, the clause G . ., lseg(x, y) * lseg(x, z) which asserts that G implies \nthe disjunction of . and the spatial formula lseg(x, y) * lseg(x, z ). Since the separating conjunction \nin the spatial part requires that the two list segments be located in disjoint subheaps, we know that \nthe list segments cannot both start at location x unless one of the list segments is empty. However, \nwe do not know which one is empty.3 To formalize this line of reasoning, VeriStar generates the clause \nG . x = y, x = z, . whenever it sees a clause with two list segments of the form given above. This new \nclause states that G implies either . (the positive pure atoms from the original clause) or x = y . x \n= z . The other wellformedness rules allow VeriStar to learn entirely pure facts from spatial facts in \nmuch the same way. The spatial unfolding rules formalize the notion that nonempty list segments can be \nunfolded into their constituent parts: a points-to fact and a sub-list segment, or in some cases, two \nsub-list segments. List segments should not be unfolded ad in.nitum, however it would be sound to do \nso, but our algorithm would in.nite-loop. Instead, VeriStar performs unfolding only when certain other \nspatial facts are present in the clause database. These hints or triggers for rule application are key \nto making the proof procedure tractable. As an example, consider Navarro P\u00b4 erez and Rybalchenko s inference \nrule U3 ' '' G . ., lseg(x, y) * SG , lseg(x, nil) * S . . ' '' G , lseg(x, y) * lseg(y, nil) * S . . \nwhich states that list segments lseg(x, nil) in negative positions should be unfolded to lseg(x, y) * \nlseg(y, nil), but only when there is a positive spatial clause somewhere in the clause database that \nmentions lseg(x, y). In this rule, the left-hand side clause G . ., lseg(x, y) * S is unnecessary for \nsoundness but necessary operationally for limiting when the rule is applied. Our Coq implementation of \nthis rule follows the declarative version rather closely. De.nition unfolding3 (sc1 sc2:clause) := match \nsc1, sc2 with | PosSpaceClause G.S, NegSpaceClause G ' . S ' . ' let l0 := unfolding3 nil SS ' in let \nbuild clause S0 := NegSpaceClause G ' S0 . ' in map build clause l0 | , . nil end. Here unfolding3 is \nan auxiliary function that searches for and unfolds list segments from variable x to Nil in S ' with \ncounterpart lists of the appropriate form in S. 3 The spooky disjunction of Berdine et al. [9].  Finally, \nVeriStar performs spatial resolution of spatial atoms that appear both negatively and positively in two \ndifferent clauses. G, S . .G ' . . ' , S G, G ' . ., . ' Like the wellformedness rules, spatial resolution \nmakes it possible to infer new pure facts from clauses with spatial atoms, in the special case in which \nS occurs both positively and negatively in two different clauses.  5.3 Superposition of Pure Clauses \nIn this section, we brie.y describe our implementation of Bachmair and Ganzinger s System S [7], the \nsuperposition calculus with selection. We chose System S because it is a well-studied equational calculus \nthat appears to perform well in practice but there are others (see, for instance, Nieuwenhuis and Rubio \ns System I [32]). System S operates by repeatedly applying inference rules of the form G . x = y, .G \n' . x = z , . ' PS G, G ' . y = z, ., . ' to sets of clauses. The rule PS (positive superposition) implements \nthe clausal form of replacement of equals with equals (i.e., substitu\u00adtion) in positive positions. System \nS includes rules for substitution in negative positions and equality factoring as well. The main superposition \nprocedure, check pures, operates inter\u00adnally on two sets of clauses, the given set and the unselected \nset. The given set contains those clauses that were chosen to participate in superposition inference \nat least once in the past. The unselected set contains whichever clauses are left. At the beginning of \nthe search, all clauses are in the unselected set and the given set is empty. At each step of the superposition \nprocedure, a new clause is chosen from the unselected set (the given clause). This clause may be cho\u00adsen \nuniformly, but we instead apply a simple heuristic that greatly improves the search: choosing the smallest \nclause .rst. Intuitively, this optimization is pro.table because it favors the generation of small clauses \nover large ones, and the ultimate goal of the search is to produce the empty clause. Once the given clause \nhas been chosen, we simplify it with respect to the current clauses in the given set, then perform all \nsuperposition inferences possible for c, the resulting simpli.ed clause, and the given set extended with \nc. Simpli.cation essentially rewrites the given clause by all the unit equalities in the given set. Any \nnew clauses inferred in this process are added back to the unselected set and the process is repeated \nuntil either the empty clause is derived or a .xed point is reached. 6. Soundness End-to-end One would \nhope that the modular structure of the prover lends itself to a modular soundness proof: that is, each \ncomponent of the prover is shown sound in isolation and these veri.ed modules are stitched together to \nprove the soundness of the entire system end-to-end. Of course, for this strategy to work the functionality \nand correctness of each component must be guarded by a narrow interface via a module type. Otherwise, \nmaintenance to the prover and its soundness proof becomes overwhelming. We employed exactly this strategy \nwhile proving the soundness of VeriStar and found that it greatly simpli.ed the initial construc\u00adtion \nof the soundness proof and the rounds of optimizations we performed thereafter, each of which required \nchanges both to the prover and to its soundness proof. To facilitate a modular structure, we divided \nthe prover into the following major components: Clausal normal form encoding of entailments;  Superposition; \n Spatial normalization;  Spatial wellformedness inference rules;  Spatial unfolding rules; and  \nModel generation and selection of clauses for normalization.  Each of these components was then proved \nsound with respect to a minimal interface. As an example of one such interface, the main soundness theorem \nfor the clausal normal form encoding states that the negation of the clausal normal form of an entailment \nis equivalent to the original entailment before it was encoded as a clauseset. Theorem cnf correct: .(e:entailment), \nentailment denote e . .(s:state), \u00ac(fold clause denote andp TT (cnf e) s). Here the notation fold f \nandp TT ls meansx.l (fxs). TT is the always true predicate. The function clause denote de.nes our interpretation \nof clauses, i.e., disjunctions of pure and spatial atoms. Theorem cnf correct is the only theorem about \nthe clausal normal form encoding that we expose to the rest of the soundness proof, thus limiting the \nexposure of the rest of the proof to isolated updates to the cnf component. Likewise, the main soundness \ntheorem for the superposition system states that if Superpose.check pures was able to derive the empty \nclause from a set of clauses init, then the conjunction of the clauses in init entails the empty clause. \nTheorem check pures Valid sound: .init units g u, check pures init = (Valid, units, g, u) . fold clause \ndenote andp TT (M.elements init) f clause denote empty clause. We need an additional theorem for Superpose, \nhowever, since the pure prover may return C example for some clausesets, in addition to those for which \nit returns Valid. In the counterexample case, VeriStar constructs a model for the pure clauses, then \nuses this model to normalize spatial ones. Any clauses inferred by the pure prover while it was searching \nfor the empty clause must therefore be entailed by the initial set of clauses. Theorem check pures Cexample \nsound: .init units .nal empty R sel, check pures init = (C example R sel, units, .nal, empty) . fold \nclause denote andp TT (M.elements init) f fold clause denote andp TT (M.elements sel) &#38;&#38; fold \nclause denote andp TT (M.elements .nal) &#38;&#38; fold clause denote andp TT units. To prove the soundness \nof VeriStar.check entailment, the main function exported by the prover (Listing 2), we made each of the \ncomponents described above a functor over our abstract sepa\u00adration logic model, VERISTAR MODEL. As we \ndescribed in Section 4.3, our abstract model is itself a functor over mod\u00adules satisfying the VERISTAR \nLOGIC interface of Listing 1. VERISTAR MODEL and by extension, our soundness proof is therefore entirely \nparametric in the low-level details of the target separation logic implementation (e.g., the de.nition \nof the maps-to operator). In the main soundness proof for VeriStar.check entailment, we imported the \nsoundness proof for each component, instantiated each of the functors by Vsm:VERISTAR MODEL, then composed \nthe soundness theorems exported by each component to prove the main correctness theorem, check entailment \nsound. Module VeriStarSound (Vsm:VERISTAR MODEL). Module SPS := SP Sound Vsm. (*Superposition*) Module \nNS := Norm Sound Vsm. (*Normalization*) ...  Module WFS := WF Sound Vsm. (*Wellformedness*) Module UFS \n:= UF Sound Vsm. (*Unfolding*) Theorem check entailment sound: .(ent:entailment), VeriStar . check entailment \nent = Valid . entailment denote ent. End VeriStarSound. check entailment sound states that if the prover \nreturns Valid, the original entailment is semantically valid in the Vsm model. Because of VeriStar s \nmodular design, the proof of this theorem goes by a straightforward application of the soundness lemmas \nfor each of the subcomponents. 6.1 Specialization to C minor To target the soundness proof to C minor, \nwe built an implementation of the VERISTAR LOGIC interface for C minor addresses, values, local variable \nenvironments and heaps (CminLog). We instantiated our abstract separation logic by this module Module \nCmm:VERISTAR MODEL:=VeriStarModel CminLog. then applied VeriStarSound to Cmm, Module Vss : VERISTAR SOUND \n:= VeriStarSound Cmm. yielding an end-to-end proof. Here the module CminLog de.nes the operators and \npredicates on environments and heaps (env get, env set, rawnext, etc.) required by our soundness proof, \nand proves all of the required properties for these operators and predicates. The main soundness theorem \nfor the VeriSmall static analyzer, check sound, Theorem check sound : .G PcQ, check0 PcQ = true . semax \nG (assertion2wpred P) (erase stmt c) (RET1 (assertion2wpred Q)). relies on Vss to prove that calls made \nto VeriStar during symbolic execution are valid. The theorem states that when VeriSmall suc\u00adcessfully \nchecks a Hoare triple (check0 PcQ = true), the triple is sound in our axiomatic semantics for C minor \n(semax).4 The axiomatic semantics, in turn, has a machine-veri.ed correctness proof with respect to the \noperational semantics of CompCert C mi\u00adnor. Thus we achieve an end-to-end correctness guarantee: C minor \nprograms deemed safe by the static analyzer will be compiled by CompCert to observationally equivalent \nassembly programs. 7. Why bother with machine-checked proofs? It takes some effort to encode an algorithm \nin a proof assistant like Coq and then prove it correct with a machine-checked proof. One might wonder \nwhether all this effort is really worth it. That is, do we gain anything over LATEXproofs and unveri.ed \nimplementations by formally proving an implementation of an algorithm correct? Soundness. In this case \nstudy, we can concretely say yes . For\u00admal veri.cation of VeriStar uncovered two related soundness bugs \nin Navarro P\u00b4 erez and Rybalchenko s spatial unfolding rules (speci.\u00adcally, rules U4 and U5 in [26, Section \n4, Fig. 1]). It appears likely that because of the interaction of rules U4 and U5 with the spatial resolution \nrule, these bugs did not result in unsoundness of Navarro s implemented system. However, we have been \nunable to verify that this is the case since we lack access to the source code (and, of course, the absence \nof such bugs cannot be 4 Since VeriSmall and VeriStar operate on syntax, we must lift the syntactic assertions \nP and Q to semantic assertions operating on worlds of the program logic (assertion2wpred). con.rmed even \nby extensive testing). We have veri.ed the soundness of corrected forms of U4 and U5, discovered independently \nby us and Navarro P\u00b4 erez and Rybalchenko. We present the corrected rules here. G . ., lseg(x, y) * next(z, \nw) * S ' '' G , lseg(x, z) * S . . U4 ' y = z ' '' G, G , lseg(x, y) * lseg(y, z) * S . ., . G . ., lseg(x, \ny) * lseg(z, w) * S ' '' G , lseg(x, z) * S . . U5 ' y = z ' '' G, G , lseg(x, y) * lseg(y, z) * S . \nz = w, ., . The new U4 and U5 rules required adding G and . to the conclu\u00adsion of each rule so that the \nsuccedent of the .rst hypothetical clause (., lseg(x, y) * next(z, w) * S and ., lseg(x, y) * lseg(z \n, w) * S resp. in U4 and U5) could be made to hold in the model. By ensuring that next(z , w) (resp. \nlseg(z, w)) be disjoint from lseg(x, y), we avoid the counterexample we found for the original system \n(with\u00adout G, .) in which lseg(x, z) does not hold because z points back into lseg(x, y) (lists must be \nacyclic). Appendix A of the extended version of this paper [1] presents this counterexample in more detail. \nThis modi.cation to rules U4 and U5 was not obvious to us initially, before we attempted to verify the \nrules, since in the other unfolding rules in Navarro P\u00b4 erez and Rybalchenko s system, the .rst hypothetical \nclause acts only as an operational trigger for unfolding and is never necessary for soundness. Termination. \nAll Coq functions are total, so a computable func\u00adtion implemented in Coq must terminate. One convinces \nthe Coq system that a function terminates either by presenting a structurally recursive function (using \nCoq s Fixpoint notation) in which all recursive calls are clearly on substructures of the corresponding \nformal parameter; or by presenting a general function (using Coq s Function notation) along with a proof \nthat one of the arguments decreases in some well-founded order. Navarro P\u00b4 erez and Rybalchenko state \ntheir termination proof as follows: [T]he algorithm terminates since the growing set S is bounded by \n... the .nite number of distinct pure clauses which can be written with the constant symbols occurring \nin E. Unfortunately this proof has some weaknesses. In real implementations, including Navarro s and \nincluding our own, the set S does not grow mono\u00adtonically, because optimizations are implemented to rewrite \nby unit equalities and remove redundant clauses. What does seem to grow is the closure of S under the \naddition of certain kinds of redundant clauses, but the proof of this is not at all straightforward. \nWe have implemented a machine-checked termination proof of the superpose loop. Termination of check entailment \nis much trickier and we have not yet implemented that proof. Instead we resort to a common hack: we provide \nVeriStar s main loop with an additional numeric argument, and after a set number of iterations it times \nout. As usual when this hack is applied, it does not compromise the soundness proof: time-out does not \nreturn a result that demands soundness. Then we pass a time-out parameter that is suf.ciently large for \nall conceivable applications. Still, even though we have not implemented a proof, we believe the algorithm \ndoes terminate, i.e. on any input, given a large enough n, it will not time out. Completeness. Navarro \nP\u00b4 erez and Rybalchenko [26] also proved completeness: when the algorithm returns counterexample, the \norig\u00adinal entailment is invalid. We have not yet done so for our Coq implementation of their algorithm. \nFor many applications of veri.ed software, completeness is not quite as important as soundness an attacker \ncould exploit a soundness bug in the veri.cation toolset, but not a completeness bug. Nevertheless, to \nformally prove com\u00adpleteness of our implementation would con.rm that we have imple\u00admented the right algorithm. \n optimization speedup program proof ratio clausesets 1.21x 305 4,213 13.8x priority heuristic 3.43 35 \n50 1.43 priority caching 1.26 66 113 1.71 int31 1.39 180 471 2.62 set ops 1.04 183 326 1.78 redundancy \nelim. 1.40 47 45 0.96 model-based saturation 2.09 338 732 2.17 total: 22.1 1,154 5,950 5.16 Figure 4: \nGeomean speedups across a suite of 9,000 random separation logic entailments for the last six optimizations \nwe performed. Columns program and proof show how many lines of code were modi.ed to implement the improvement; \nratio is proof/program. 8. Performance Tuning Veri.ed Software There is no secret to writing ef.cient \nprograms [8]: (1) Take a baseline; (2) optimize; (3) evaluate the results; and (4) repeat. It is perhaps \nno surprise that the same methodology can be applied to veri.ed software in much the same way, except \nnow we are working with machine-veri.ed software and must update soundness and termination proofs as \nwe perform each optimization. In this section, we report on some optimizations we performed while building \nVeriStar and measure (1) the speedup achieved by each optimization (second column of the table in Figure \n4), and (2) the number of lines of code we modi.ed in both the program and the proof to implement each \noptimization (last three columns of Figure 4). The total speedup for all optimizations was 22.1x. We \nreport on these optimizations to show that veri.ed software written in Coq is real software: when extracted \nand compiled with the OCaml system, it runs on real hardware, subject to the same performance constraints \nas all software. The corollary is that veri.ed functional programs can be performance-tuned in predictable \nways. Clausesets. We replaced Coq s standard-library AVL-tree imple\u00admentation of the MSets interface \nfor ef.cient .nite sets, with a new red-black tree implementation. (We use MSets to store the clause \ndatabase.) This new implementation included optimized routines for set insertion, lookup, and union; \nand we expanded the MSets interface with optimized versions of composite operations such as with minimum-element \ndeletion and insertion-with-membership\u00adquery. This resulted in a relative speedup over our baseline VeriStar \nimplementation of 1.21x. Priority Heuristic. The superpose one inference step picks a clause from the \nclauseset; any new clause will do (for soundness and completeness). An optimization is to pick the smallest \nnew clause (see Section 5.3). This priority heuristic greatly winnows the size of the search space. We \nuse the MSets not only to implement clause sets, but to simultaneously implement an ef.cient priority \nqueue: the total ordering we supply for the red-black searchtree is a lexicographic ordering of clause \npriority and then clause content. We then use our ef.cient delete-min operation to pluck the smallest \nclause from the set in log N time. This heuristic gives speedup of 3.43x, compared to selecting an arbitrary \nnew clause. Priority Caching. Caching the priorities, as integers with the clauses, yields speedup of \n1.26x. OCaml Native Integers. Our initial implementation used Coq standard-library positive integers \nto represent variables and priorities. It is a data structure representing arbitrary precision binary \nnumbers, so 101001 is xI(xO(xO(xI(xO(xI xH))))) in the datatype, Inductive positive := | xI : positive \n. positive | xO : positive . positive | xH : positive. To make things faster, we now use OCaml native \n31-bit integers for variables and priorities, yielding speedup of 1.39x. When extracting to 31-bit OCaml \nintegers, we had to be very careful about over.ow. Coq positives are potentially unbounded (thus no over.ow), \nwhereas OCaml integers have mod-231 addition. However, VeriStar never performs addition or multiplication \nof variables, and never generates new variables.5 VeriStar does some arithmetic on priorities, but the \nsoundness and completeness proofs are oblivious to the speci.c priority function used, so our algorithm \nis still correct even if priorities happen to over.ow. To ensure that our machine-checked soundness proof \ncannot rely on properties of int31 arithmetic, we do not even axiomatize arithmetic on variables and \npriorities we de.ne + and \u00d7 as unaxiomatized operators. Set Operations. Our paramodulation loop (Fig. \n2) had used lists of clauses. We switched to set operations (MSets) primarily to make the code more elegant, \nbut it also gives speedup of 1.04. Redundancy Elimination. We remove redundant pure clauses before passing \nclausesets to Superpose. This yields a relatively large speedup of 1.40x since it often reduces the number \nof clauses passed to Superpose between rounds of spatial inference. Model-based Saturation. Our main \nimplementation of the super\u00adposition calculus uses the given-clause algorithm to saturate claus\u00adesets. \nAs a last optimization, we rewrote the superposition engine to employ a more intelligent saturation procedure: \ninstead of .nding the smallest clause at each saturation step, we attempt to construct a model of the \ncurrent clauseset (whether saturated or not). Com\u00adpleteness of the superposition calculus implies that \nthis model exists whenever the clauseset is saturated (and does not contain the empty clause). Moreover, \nfor unsaturated sets the completeness proof tells us exactly which clause to select for inference, and \nfor which type of inference (superposition right, superposition left, etc.) in order to bring the set \ncloser to saturation. In this optimization pass, we also improved the global propagation of unit equalities. \nThese two optimizations together resulted in speedup of about 9x over our original saturation procedure \n(the clausesets version, which did not use the priority heuristic or priority caching). In the table, \n2.09x gives the pairwise speedup of model-based saturation over the next most recent version of the prover \n( redundancy elimination ). On optimization effort. Most optimizations required minimal updates to the \nproofs relative to the size of each change to the program (often under 2x, see Figure 4). Figure 5 gives \nthe total sizes, in lines-of-code, of each of the VeriStar source .les. To prove the int31 optimization \nsound, we had to abstract all properties of variables on which the proof depended, resulting in 5 This \nis not true for VeriSmall since the static analysis must generate fresh variables during symbolic execution. \nBut since VeriSmall as opposed to VeriStar is not complete in general, it can simply return don t know \nwhenever generating fresh variables results in an over.ow.  source .le program proof compare.v - 253 \nvariables.v 77 59 datatypes.v 60 - superpose.v 342 - superpose termination - 1,904 superpose modelsat.v \n335 - heapresolve.v 448 - veristar.v 150 - model type.v - 89 model.v - 310 clause lemmas.v - 183 cclosure.v \n169 - superpose sound.v - 584 superpose modelsat sound.v - 732 spred lemmas.v - 542 clausify sound.v \n- 474 wellformed sound.v - 399 unfold sound.v - 1,809 norm sound.v - 233 veristar sound.v - 354 clauses.v \n308 594 list denote.v - 946 driver.ml 127 - subtotals (excl. redblack.v): 2,016 9,465 ratio: 4.69 redblack.v \n281 4,110 totals: 2,297 13,575 ratio: 5.91 Figure 5: Sizes of system components in lines-of-code. Ratio \nis proof/program. prover Smallfoot VeriStar SLP jStar runtime (seconds) 0.013 0.019 0.049 0.180 Figure \n6: Average runtimes over 100 trials of Smallfoot, VeriStar, SLP and jStar on 209 entailments generated \nby Smallfoot. more global changes. The clausesets optimization was somewhat of an outlier: to meet the \nexisting Coq MSets interface, we had to prove many lemmas not even used by our soundness proof. On the \nother hand, the red-black tree implementation of Coq MSets is reusable even independently of VeriStar. \n9. Measurements We evaluated VeriStar s performance against that of jStar [19], Smallfoot and SLP on \ntwo suites of separation logic entailments. All evaluation was done on a SunFire X4100 server with two \ndual-core 2.2GHz Opteron 275 processors and 16GB of RAM running CentOS Linux. The .rst suite contains \n209 separation logic entailments generated by Smallfoot during veri.cation of 18 different list\u00admanipulating \nprograms found in the Smallfoot distribution. The second includes 22,000 synthetic entailments tuned \nfrom moderate to dif.cult. The synthetic entailments are the full suites used by Navarro P\u00b4 erez and \nRybalchenko to evaluate their Prolog-based theorem prover SLP against jStar and Smallfoot [26]. The Smallfoot \nentailments are Navarro P\u00b4 erez and Rybalchenko s .rst clone set, slightly modi.ed since our prover does \nnot yet deal with arbitrary spatial predicates. On the real-world entailments derived from programs in \nSmallfoot s test suite, VeriStar s performance was comparable to that of Smallfoot and SLP (on the order \nof hundredths of a second for the 209 entailments). jStar solved 101 of the 170 valid entailments in \nthe suite in 0.180 seconds. We report the average runtime of each prover on these 209 entailments over \n100 trials in Figure 6. To test the provers at a .ner granularity on more dif.cult entailments, we ran \neach prover on the 22,000 synthetic entailments in Navarro P\u00b4 erez and Rybalchenko s Bolognesa and Spaguetti \nsuites. The Spaguetti benchmarks consist of 11,000 entailments of the form . . S f., simulating the inconsistency \nchecks that are often required during symbolic execution. The Bolognesa benchmarks consist of 11,000 \ngeneral entailments of the form . . S f . ' . S '. For each prover, we measured the number of independent \nentailments solved within 0.01 to 5 seconds. Figure 7 shows the results of these measurements. Within \n5 seconds, jStar checked 8,757 of the 22,000 entailments in the combined suites, VeriStar checked 18,610 \nentailments and Smallfoot checked 21,483. SLP checked 21,981 entailments within 5 seconds. Assessment. \nOn real-world entailments generated by Smallfoot during symbolic execution (Figure 6), VeriStar s performance \nis more than adequate it solved all 209 entailments in slightly less than two hundredths of a second, \nthree hundredths of a second faster than SLP and only slightly slower than Smallfoot. VeriStar is also \nthe only one of the four systems with a machine-checked soundness proof. On Navarro P\u00b4 erez and Rybalchenko \ns synthetic entailments (Figure 7), VeriStar is, in a majority of cases, faster than Smallfoot when deciding \nheap inconsistency entailments (those of the form . . S f., the Spaguetti suite) and is almost as fast \nSLP. On general entailments (the Bolognesa suite), VeriStar is not quite as fast as Smallfoot, and not \nnearly as fast as SLP. Though it is certainly fast enough for Smallfoot-like applications, there is room \nfor improvement. We believe the main issues are: VeriStar is a pure functional program. Functional programs \nhave a clean proof theory that makes veri.cation a breeze (or at most, a stiff wind). But it means that \nwe pay a log N penalty in some places, where we use red-black trees instead of arrays or hash tables. \nUsing imperative techniques might speed things up, and yet still .t within the Coq framework [5].  The \nparamodulation framework for resolution theorem-proving in its modern form is more than two decades old, \nand a prover such as SLP uses a large combination of time-tested heuristics. By comparison, VeriStar \nis still immature, and the incorporation of more of these standard techniques would likely improve performance \nsigni.cantly.  10. Related Work Proof-carrying code (PCC) [27] demonstrated the effectiveness of proof \nwitnesses derivation trees in a core logic as a means of incorporating large untrusted components into \nsafe systems. But the problems with PCC were twofold: (1) the proof witnesses were unacceptably large \nin practice; and (2) the proof checkers, often running to tens of thousands of lines of code, had to \nbe trusted. Necula [28, 29] showed how to reduce the size of the proof by compressing common subterms \nand extending the proof checker to reconstruct these terms from the context. Foundational PCC [2] addressed \n(2) by proving the soundness of the proof checker from basic axioms but still required large proofs. \nIn this project, we go further: the VeriStar system when connected to VeriSmall and the rest of the Veri.ed \nSoftware Toolchain combines strong, founda\u00adtional correctness guarantees (all the way down to the compiled \nassembly program) with minimal proofs : just the program text itself, possibly annotated with light assertions \nsuch as loop invari\u00adFigure 7: Number of independent entailments checked within 0.01 to 5 seconds by SLP, \nSmallfoot, VeriStar and jStar. (Higher is better.) The Spaguetti benchmark suite contains 11,000 entailments \nof the form, . . S f., simulating heap inconsistency checks. The Bolognesa benchmark suite contains 11,000 \ngeneral separation logic entailments of the form . . S f . ' . S ' .  ants. These assertions guide \nthe proved-sound static analyzer to an appropriate safety proof. More recent work on integrating decision \nprocedures into trusted systems has focused on ef.ciently translating and checking low-level certi.cates. \nArmand et al. [5] connect SAT (ZChaff, MiniSat) and SMT solvers (VeriT) to Coq and Isabelle/HOL by translating \nunsat cores and boolean models to ef.cient certi.cates. These certi.cates are then veri.ed through a \ncombination of small machine-veri.ed proof checkers for resolution chains, linear arithmetic, congruence \nclosure and other theories. Besson et al. describe a related system [11] that permits Nelson-Oppen-style \ntheory combination and sup\u00adports additional theories besides those supported by Armand et al. In Besson \ns system, a signi.cant portion of total proof time is con\u00adsumed by certi.cate generation and checking. \nAlthough VeriStar is signi.cantly simpler than a state-of-the-art SMT solver, it demon\u00adstrates that for \ncertain application domains, it is possible to verify the prover, not just the checker, and thus bypass \nlow-level certi.cate generation and checking completely. Chlipala s Bedrock system [17], an impressive \ntoolkit for proving the correctness of low-level code, includes an ad hoc simpli.cation procedure and \nentailment checker for separation logic that together appear to work well in practice. One advantage \nof Bedrock s checker is that it works on the unencoded implications generated by veri.cation. Errors \nare therefore easier to communicate to the user in a transparent way. VeriStar entailments, by contrast, \nare encoded and checked at the clause level, both for ef.ciency and for interoperability with the Superposition \nsystem, and therefore are slightly less human-friendly. Nguyen and Chin equip a Smallfoot-style entailment \nchecker with a mechanism to integrate user-provided lemmas, complement\u00ading the folding/unfolding lemmas \nthat are automatically generated from inductive de.nitions [30]. Brotherson et al. [13] present a heap \ntheorem prover imple\u00ad mented in HOL that employs a notion of cyclic proof. Their work opens an avenue \nfor the integration of user-de.ned inductive types and auxiliary lemmas that relate such de.nitions, \nbut is apparently not yet integrated with a prover for the pure part, and is not pre\u00adsented in clausal \nform. We expect that our modular architecture will allow us to explore the integration of this and other \nspatial theorem provers into paramodulation-based reasoning tools comparatively easily, as any such prover \ncan be substituted for (or complement) the present unfolding rules for singly-linked lists. THOR [25] \ninfers invariants by combining symbolic execution with abstraction. An alternative to reimplementing \ninvariant infer\u00adence in Coq is to use THOR, or some other tool like SLAyer, to annotate loops with invariants \nthat are then con.rmed by Veri\u00adSmall+VeriStar. The HIP/SLEEK project [31] employs an inter\u00ad esting shallow \nembedding technique for resource use veri.cation that might also be adapted to our setting. 11. Lessons \nLearned Extraction for Execution and Pro.ling. Coq s code extraction facilities make it easy to write \na Gallina program, extract it to OCaml (or Haskell or Scheme) and get decent performance by compiling \nusing an optimizing compiler like ocamlopt. When the Gallina program is written in a straightforward \nfunctional style forgoing extensive use of more advanced features of Coq such as dependent types6 code \nextraction followed by compilation is predictable enough even to support pro.ling in a traditional style, \nusing a conventional tool like gprof [21]. One .rst extracts a veri.ed Gallina program to OCaml, compiles \nthe OCaml program with ocamlopt -p, then does a pro.ling run using gprof. Because the extracted OCaml \ncode is very similar in structure to the Gallina source, the gprof pro.ling data can be used to optimize \nthe Gallina program quite effectively. Figure 8 presents an excerpt of one such pro.ling run we performed \nusing gprof, which showed us that demodulation (unit equality propagation) was a bottleneck for the prover \non entailments in Navarro s Spaguetti suite. On the Proof Theory of Functional Languages. Because Gallina \nprograms are purely functional (one must even prove termination), Gallina has an elegant proof theory \nthat is more tractable than that of ML or Haskell, and much nicer than that of C. This attractive proof \ntheory made the difference, in our estimation, between a 6 Such features are of course fair game when \nproving a Gallina program correct; Coq s type system ensures that only the program is ever extracted, \nnever the proof.  time seconds seconds calls name 20.81 7.63 7.63 943778606 demodulate_3526 10.42 11.45 \n3.82 1247887428 apply2 9.27 14.85 3.40 343207163 pcompare_176 5.40 16.83 1.98 297862037 pplus_111 5.02 \n18.67 1.84 412584893 zplus_200 4.12 20.18 1.51 2338512 fold_left_299 4.09 21.68 1.50 943778606 fun_9033 \n2.70 22.67 0.99 114722856 zlength_aux_322 Figure 8: Excerpt from the gprof trace of a single run of \nthe extracted prover on 1000 entailments in the Spaguetti suite. couple man-months to complete VeriStar \ns soundness proof and a couple man-years for a comparable machine-checked proof of a C implementation \nof the same algorithm. The Importance of Modular Proofs. The importance of module systems for the construction \nof large software projects is well-known. We were surprised at just how effective conventional, ML-style \nmodule and functor systems (as implemented in Coq) were for building and evolving modular proofs of programs \nas well. By protecting the soundness proof of each component of the prover with an opaque Module Type \nin Coq (Section 6), we saved a great deal of time and energy, especially as we evolved the prover through \nsuccessive rounds of optimization (Section 8). 12. Conclusion VeriStar is the .rst machine-veri.ed theorem \nprover for separation logic that connects to a real-world operational semantics (CompCert C minor). Together \nwith VeriSmall, VeriStar enables automatic foun\u00addational checking of shape properties with respect to \nthe compiled x86 or PowerPC assembly. VeriStar implements an ef.cient decision procedure for separation \nlogic [26] using highly tuned functional data structures. VeriStar s implementation and soundness proof \ncan be retargeted to new domains through an opaque axiomatization of separation logic. Finally, VeriStar \ns design, and its integration with VeriSmall and our C minor separation logic through well-de.ned interfaces, \nprovides a blueprint for the design of certi.ed end-to-end systems more generally. Acknowledgments Anindya \nBanerjee, members of the Princeton PL group and the anonymous referees provided helpful suggestions on \nprior drafts. Aleksandar Nanevski and David Walker gave the .rst author advice on appropriate venues \nfor this work. This work was supported in part by AFOSR grant FA9550-09-1-0138 and NSF grant CNS-0910448. \nReferences [1] URL http://www.cs.princeton.edu/~jsseven/p/veristar. [2] A. W. Appel. Foundational proof-carrying \ncode. In LICS, 2001. [3] A. W. Appel. VeriSmall: Veri.ed Smallfoot shape analysis. In First International \nConf. on Certi.ed Programs and Proofs, Dec. 2011. [4] A. W. Appel. Veri.ed Software Toolchain. In ESOP, \npages 1 17, 2011. [5] M. Armand, G. Faure, B. Gr\u00b4ery, and B. Werner. egoire, C. Keller, L. Th\u00b4A modular \nintegration of SAT/SMT solvers to Coq through proof witnesses. In First International Conf. on Certi.ed \nPrograms and Proofs, 2011. [6] R. Atkey. Amortised resource analysis with separation logic. Logical Methods \nin Computer Science, 7(2:17), 2011. [7] L. Bachmair and H. Ganzinger. Equational Reasoning in Saturation-Based \nTheorem Proving. In W. Bibel and P. Schmitt, editors, Automated Deduction -A Basis for Applications, \nvolume I, 1998. [8] J. L. Bentley. Writing Ef.cient Programs. Prentice-Hall, 1982. [9] J. Berdine, C. \nCalcagno, and P. W. O Hearn. Smallfoot: Modular automatic assertion checking with separation logic. In \nFormal Methods for Components and Objects, pages 115 135, 2005. [10] J. Berdine, B. Cook, and S. Ishtiaq. \nSLAyer: Memory safety for systems-level code. In CAV, pages 178 183, 2011. [11] F. Besson, P.-E. Cornilleau, \nand D. Pichardie. Modular SMT proofs for fast re.exive checking inside Coq. In First International Conf. \non Certi.ed Programs and Proofs, 2011. [12] T. Braibant and D. Pous. Tactics for reasoning modulo AC \nin Coq. In First International Conf. on Certi.ed Programs and Proofs, 2011. [13] J. Brotherston, D. Distefano, \nand R. L. Petersen. Automated cyclic entailment proofs in separation logic. In Proceedings of CADE-23, \npages 131 146, 2011. [14] C. Calcagno and D. Distefano. Infer: an automatic program veri.er for memory \nsafety of C programs. In Third International Conference on NASA Formal Methods, pages 459 465, 2011. \n[15] C. Calcagno, D. Distefano, P. O Hearn, and H. Yang. Compositional shape analysis by means of bi-abduction. \nSIGPLAN Not., 44:289 300, January 2009. [16] B.-Y. E. Chang and X. Rival. Relational inductive shape \nanalysis. In POPL, pages 247 260, 2008. [17] A. Chlipala. Mostly-automated veri.cation of low-level programs \nin computational separation logic. In PLDI 11, pages 234 245, 2011. [18] L. M. de Moura and N. Bj\u00f8rner. \nZ3: An ef.cient SMT solver. In TACAS, 2008. [19] D. Distefano and M. J. Parkinson J. jStar: Towards practical \nveri.cation for Java. In OOPSLA, 2008. [20] R. Dockins, A. Hobor, and A. W. Appel. A fresh look at separation \nalgebras and share accounting. In APLAS: 7th Asian Symposium on Programming Languages and Systems, pages \n161 177, 2009. [21] S. L. Graham, P. B. Kessler, and M. K. McKusick. Gprof: A call graph execution pro.ler. \nIn Proc. SIGPLAN 82 Symp. on Compiler Construction, SIGPLAN Notices, pages 120 126. ACM Press, 1982. \n[22] A. Hobor, A. W. Appel, and F. Zappa Nardelli. Oracle Semantics for Concurrent Separation Logic. \nIn ESOP, pages 353 367, 2008. [23] X. Leroy. A formally veri.ed compiler back-end. Journal of Automated \nReasoning, 43(4):363 446, 2009. [24] B. Lochner and S. Schulz. \u00a8An evaluation of shared rewriting. In \nProceedings of the Second International Workshop on Implementation of Logics, Technical Report MPI-I-2001-2-006, \npages 33 48, 2001. [25] S. Magill, A. Nanevski, E. Clarke, and P. Lee. Inferring invariants in separation \nlogic for imperative list-processing programs. In Third Work\u00adshop on Semantics, Program Analysis, and \nComputing Environments for Memory Management (SPACE), 2006. [26] J. A. Navarro P\u00b4erez and A. Rybalchenko. \nSeparation logic + super\u00adposition calculus = heap theorem prover. In PLDI, pages 556 566, 2011. [27] \nG. Necula. Proof-carrying code. In POPL, pages 106 119, 1997. [28] G. C. Necula and P. Lee. Ef.cient \nrepresentation and validation of proofs. In LICS, pages 93 104, 1998. [29] G. C. Necula and S. P. Rahul. \nOracle-based checking of untrusted software. In POPL, pages 142 154, 2001. [30] H. H. Nguyen and W.-N. \nChin. Enhancing program veri.cation with lemmas. In CAV, pages 355 369, 2008. [31] H. H. Nguyen, C. David, \nS. Qin, and W.-N. Chin. Automated veri.cation of shape and size properties via separation logic. In VMCAI, \npages 251 266, 2007. [32] R. Nieuwenhuis and A. Rubio. Paramodulation-based theorem proving. In A. Robinson \nand A. Voronkov, editors, Handbook of Automated Reasoning, 2001. [33] T. Tuerk. A formalisation of Smallfoot \nin HOL. In Theorem Proving in Higher Order Logics, pages 469 484, 2009.    \n\t\t\t", "proc_id": "2364527", "abstract": "<p>We present <i>VeriStar</i>, a verified theorem prover for a decidable subset of separation logic. Together with VeriSmall [3], a proved-sound Smallfoot-style program analysis for C minor, VeriStar demonstrates that fully machine-checked static analyses equipped with efficient theorem provers are now within the reach of formal methods. As a pair, VeriStar and VeriSmall represent the first application of the <i>Verified Software Toolchain</i> [4], a tightly integrated collection of machine-verified program logics and compilers giving foundational correctness guarantees.</p> <p>VeriStar is (1) <i>purely functional</i>, (2) <i>machine-checked</i>, (3) <i>end-to-end</i>, (4) <i>efficient</i> and (5) <i>modular</i>. By purely functional, we mean it is implemented in Gallina, the pure functional programming language embedded in the Coq theorem prover. By machine-checked, we mean it has a proof in Coq that when the prover says \"valid\", the checked entailment holds in a proved-sound separation logic for C minor. By end-to-end, we mean that when the static analysis+theorem prover says a C minor program is safe, the program will be compiled to a semantically equivalent assembly program that runs on real hardware. By efficient, we mean that the prover implements a state-of-the-art algorithm for deciding heap entailments and uses highly tuned verified functional data structures. By modular, we mean that VeriStar can be retrofitted to other static analyses as a plug-compatible entailment checker and its soundness proof can easily be ported to other separation logics.</p>", "authors": [{"name": "Gordon Stewart", "author_profile_id": "81548018889", "affiliation": "Princeton University, Princeton, NJ, USA", "person_id": "P3804294", "email_address": "jsseven@cs.princeton.edu", "orcid_id": ""}, {"name": "Lennart Beringer", "author_profile_id": "81335488012", "affiliation": "Princeton University, Princeton, NJ, USA", "person_id": "P3804295", "email_address": "eberinge@cs.princeton.edu", "orcid_id": ""}, {"name": "Andrew W. Appel", "author_profile_id": "81548018891", "affiliation": "Princeton University, Princeton, NJ, USA", "person_id": "P3804296", "email_address": "appel@princeton.edu", "orcid_id": ""}], "doi_number": "10.1145/2364527.2364531", "year": "2012", "article_id": "2364531", "conference": "ICFP", "title": "Verified heap theorem prover by paramodulation", "url": "http://dl.acm.org/citation.cfm?id=2364531"}