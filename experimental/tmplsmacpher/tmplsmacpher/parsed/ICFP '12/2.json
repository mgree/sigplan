{"article_publication_date": "09-09-2012", "fulltext": "\n Formal Veri.cation of Monad Transformers (Abstract) Brian Huffman Institut f\u00a8ur Informatik, Technische \nUniversit\u00a8at M\u00a8unchen hu.man@in.tum.de Abstract We present techniques for reasoning about constructor \nclasses that (like the monad class) .x polymorphic operations and assert poly\u00admorphic axioms. We do not \nrequire a logic with .rst-class type con\u00adstructors, .rst-class polymorphism, or type quanti.cation; instead, \nwe rely on a domain-theoretic model of the type system in a univer\u00adsal domain to provide these features. \nThese ideas are implemented in the Tycon library for the Isabelle theorem prover, which builds on the \nHOLCF library of domain theory. The Tycon library provides various axiomatic type constructor classes, \nincluding functors and monads. It also provides automation for instantiating those classes, and for de.ning \nfurther subclasses. We use the Tycon library to for\u00admalize three Haskell monad transformers: the error \ntransformer, the writer transformer, and the resumption transformer. The error and writer transformers \ndo not universally preserve the monad laws; however, we establish datatype invariants for each, showing \nthat they are valid monads when viewed as abstract datatypes. Categories and Subject Descriptors F.3.1 \n[Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams mechanical \nveri.cation. Keywords denotational semantics, monads, polymorphism, theo\u00adrem proving, type classes 1. \nIntroduction Much Haskell code is written with equational properties in mind: Programs, libraries, and \nclass instances may be expected to sat\u00adisfy some laws, but unfortunately, there is no formal connection \nbe\u00adtween programs and properties in Haskell. One way to get around this limitation is to verify our Haskell \nprograms in an interactive proof assistant, or theorem prover. Isabelle/HOL (or simply Isabelle ) is \na generic interactive the\u00adorem prover, with tools and automation for reasoning about induc\u00adtive datatypes \nand terminating functions in higher-order logic [8]. Isabelle has an ML-like type system extended with \naxiomatic type classes, where users must supply proofs of class axioms in order to establish a class \ninstance. HOLCF is a library of domain theory for Isabelle/HOL, which supports denotational reasoning \nabout programs written in pure functional languages [3, 7]. HOLCF provides tools for de.ning and working \nwith (possibly lazy) recursive datatypes, general recursive functions, partial and in.nite values, and \nleast .xed-points. Copyright is held by the author/owner(s). ICFP 12, September 9 15, 2012, Copenhagen, \nDenmark. ACM 978-1-4503-1054-3/12/09. In addition to ordinary type classes, Haskell also supports type \nconstructor classes like Functor and Monad, which classify type constructors of kind *.*. The operations \nin constructor classes are often polymorphic: For example, fmap :: (Functor t) . (a . \u00df) . ta . t\u00df is \npolymorphic over a and \u00df. The functor laws (identity and composition) are also polymorphic, and we expect \nthe laws to hold at all type instances. Formal reasoning with construc\u00adtor classes thus requires support \nfor both polymorphism and type quanti.cation, neither of which is natively supported by Isabelle. Fortunately, \nwe can model these features in HOLCF with the help of a universal domain type. 2. De.ation model of types \nHOLCF provides a universal domain type U, which can repre\u00adsent a large class of cpos that includes all \nHaskell datatypes [2]. HOLCF formalizes representable domains with overloaded func\u00adtions emba :: a . \nU and proja :: U . a which form an embedding\u00adprojection pair: proja . emba = ida and emba . proja c idU \n. The composition proja . emba yields a de.ation, i.e., an idem\u00adpotent function below id. HOLCF de.nes \na type D of de.ations over U as a subtype of U . U. De.ations model types: Each representable domain \ntype in HOLCF has a representation [a] = emba . proja of type D. Conversely, we can construct a repre\u00adsentable \ndomain from any given de.ation, using its image set. 3. The Tycon library The Tycon library [4] uses \nde.ations to reason about new type system features. To model Haskell type application, we de.ne a binary \nIsabelle type constructor (-\u00b7-) [5]. The right argument must be a representable domain, which models \nkind *. The left argument must be in a new class Tycon, which models kind *.*. class Tycon t where {|t|} \n:: D . D The Tycon library then de.nes type t \u00b7 a so that [t \u00b7 a] = {|t|}[a]. Haskell s Functor class \n.xes a function fmap :: (Functor t) . (a . \u00df) . (ta . t\u00df). However, we cannot use this type for a class \nfunction in Isabelle; the extra polymorphism over a and \u00df is not allowed. Our solution is to replace \nthe polymorphic fmapt with a single, monomorphic constant fmapt representing fmapt . We then de.ne the \npolymorphic fmapt by coercion from fmapUt,. U class (Tycon t) . Functor t where fmapt :: (U . U) . (t \n\u00b7 U . t \u00b7 U) fmap :: (Functor t) . (a . \u00df) . t \u00b7 a . t \u00b7 \u00df fmapt = coerce fmapt a,\u00df To coerce between \nany two representable domains, we use the func\u00adtion coercea,\u00df = proj\u00df .emba. Instances of emb and proj \nare de.ned so that coerce on datatypes coincides with mapping coerce over the elements. Similarly, coercion \nbetween function types satis.es coerce f = coerce . f . coerce.  The Isabelle formalization of class \nFunctor also includes class axioms about fmapt, which are suf.cient to derive the polymorphic functor \nlaws fmapid = id and fmap ( f .g)= fmap f . fmapg. (Due to space constraints, we omit the details here.) \nTo facilitate Functor class instances, the Tycon library provides a new user-level type de.nition command. \nIts capabilities are sim\u00adilar to the HOLCF Domain package [3], and it reuses much of the same code. The \ndifference is that it produces Tycon instances in\u00adstead of ordinary representable domains. It also de.nes \nfmap and proves the identity law. (Users must prove composition.) Users can formalize subclasses of Functor \nby a standard process involving naturality laws. As an example, we formalize a class FunctorPlust with \nan associative operation (++) :: ta . ta . ta. class (Functor t) . FunctorPlus t where (+ t) :: t \u00b7 U \n. t \u00b7 U . t \u00b7 U t fmapt f (x + y)=(fmapt fx)+ t ( fmapt fy) tt t (x + y)+ z = x + t (y + z) As above, \nwe de.ne the polymorphic (++) by coercion from a monomorphic class function. The class axioms include \na monomor\u00adphic associativity law, as well as a naturality law whose form is de\u00adrived from the polymorphic \ntype of (++). The naturality law holds in Haskell as a consequence of parametricity [10]. We derive polymorphic \nversions of the class axioms by rewrit\u00ading with a set of rules about coerce. Combinations of coercions \nbe\u00adtween t \u00b7U and t \u00b7a yield new occurrences of fmapt; the naturality law then helps to complete the \ntransfer proofs. Monad and other constructor classes are de.ned similarly. 4. Verifying monad transformers \nThe Tycon library can easily formalize simple Monad instances like List. It can also de.ne Tycon instances \nwith additional type param\u00adeters, which may be type constructors themselves. For example, we have formalized \nthe resumption monad transformer: data ResT t \u00b7 a = Done a | More (t \u00b7 (ResT t \u00b7 a)) (Note that although \nwe call it a monad transformer, the class in\u00adstance Monad (ResT t) only requires t to be a functor.) \nWe have also formalized the error monad transformer [6], which composes the inner monad with an ordinary \nerror monad. data Error e \u00b7 a = Err e | Ok a newtype ErrorT(e,t) \u00b7 a = ErrorT {runET :: t \u00b7 (Error e \n\u00b7 a)} Unfortunately, proving an instance of Monad (ErrorT(e,t)) is not possible, because not all of the \nclass axioms hold. We de.ne the monad operations as separate constants instead. unit a = ErrorT (returnt \n(Ok a)) bind mk = ErrorT (runET m > = t. x. case x of Err e . returnt (Err e); Ok a . runET (ka)) We \ncan verify that the left unit law bind (unit a) k = ka holds, and that bind satis.es the associativity \nlaw. On the other hand, the right unit monad law bind m unit = m is not satis.ed in gen\u00aderal. Unless \nthe inner monad t has a strict return function, m = ErrorT (return .) is a counterexample to the right \nunit law. However, it turns out that it is impossible to construct the value ErrorT (return .) using \nonly the standard ErrorT operations unit, bind, throw, catch, and lift. Furthermore, we can show that \nfor all constructible values, the monad laws do always hold. In fact, the right unit law bind m unit \n= m is an invariant which is preserved by all of the ErrorT operations. So when viewed as an abstract \ndatatype, we could still consider ErrorT to be a valid monad. A similar situation occurs when formalizing \nthe standard Haskell writer monad transformer [6]. The monad instance fails because neither the left \nnor the right unit laws are preserved in general. But as before, the right unit law is an invariant which \nis preserved by all operations; the invariant also implies the left unit law. Thus the writer monad transformer \nis a valid monad when viewed as an abstract datatype. 5. Related work A different domain-theoretic model \nof polymorphism is presented by Amadio and Curien [1]. Here, polymorphic functions are mod\u00adeled as functions \nfrom types (i.e. de.ations) to values. However, this model allows non-parametric polymorphic functions \nthat de\u00adpend non-trivially on the type argument. Sozeau and Oury [9] recently developed a type class \nmechanism for the Coq theorem prover. Coq has a powerful dependent type system that allows reasoning \nabout type constructors, .rst-class polymorphic values and type quanti.cation. They de.ne a monad class \nwith laws. However, Coq s logic of total functions does not permit all the recursive de.nitions possible \nin HOLCF. Our earlier formalization of axiomatic constructor classes [5] could express many of the same \ntype de.nitions as the current work, although the classes were de.ned differently. Instead of natu\u00adrality \nlaws, it used a de.ation membership relation x ::: d to encode polymorphic types. Some automation for \nthe Functor and Monad classes was present, but transfer proofs for polymorphic laws were tedious, making \nsubclass de.nitions impractical. Overall, the new Tycon library provides much better automation for users. \nFor the full version of this paper, see arXiv:1207.3208 [cs.LO]. References [1] Roberto M. Amadio and \nPierre-Louis Curien. Domains and Lambda-Calculi. Cambridge University Press, New York, NY, USA, 1998. \n[2] Brian Huffman. A purely de.nitional universal domain. In Stefan Berghofer, Tobias Nipkow, Christian \nUrban, and Makarius Wenzel, editors, Proceedings of the 22nd International Conference on Theo\u00adrem Proving \nin Higher Order Logics (TPHOLs 09), volume 5674 of LNCS, pages 260 275. Springer, 2009. [3] Brian Huffman. \nHOLCF 11: A De.nitional Domain Theory for Ver\u00adifying Functional Programs. Ph.D. thesis, Portland State \nUniversity, 2012. [4] Brian Huffman. Type constructor classes and monad transform\u00aders. Archive of Formal \nProofs, June 2012. http://afp.sf.net/ entries/Tycon.shtml, Formal proof development. [5] Brian Huffman, \nJohn Matthews, and Peter White. Axiomatic construc\u00adtor classes in Isabelle/HOLCF. In Joe Hurd and Tom \nMelham, editors, Proceedings of the 18th International Conference on Theorem Proving in Higher Order \nLogics (TPHOLs 05), volume 3603 of LNCS, pages 147 162. Springer, 2005. [6] Mark P. Jones. Functional \nprogramming with overloading and higher\u00adorder polymorphism. In First International Spring School on Ad\u00advanced \nFunctional Programming Techniques, volume 925 of LNCS, B\u00b0 astad, Sweden, May 1995. Springer-Verlag. [7] \nOlaf M\u00a8uller, Tobias Nipkow, David von Oheimb, and Oskar Slotosch. HOLCF = HOL + LCF. Journal of Functional \nProgramming, 9:191 223, 1999. [8] Tobias Nipkow, Lawrence C. Paulson, and Markus Wenzel. Is\u00adabelle/HOL \n A Proof Assistant for Higher-Order Logic, volume 2283 of LNCS. Springer, 2002. [9] Matthieu Sozeau and \nNicolas Oury. First-class type classes. In Ot\u00admane Ait Mohamed, C\u00b4esar Mu noz, and So.`ene Tahar, editors, \nThe\u00adorem Proving in Higher Order Logics, 21st International Conference (TPHOLs 08), volume 5170 of LNCS, \npages 278 293. Springer, Au\u00adgust 2008. [10] Philip Wadler. Theorems for free! In Functional Programming \nLanguages and Computer Architecture, pages 347 359. ACM Press, 1989.  \n\t\t\t", "proc_id": "2364527", "abstract": "<p>We present techniques for reasoning about constructor classes that (like the monad class) fix polymorphic operations and assert polymorphic axioms. We do not require a logic with first-class type constructors, first-class polymorphism, or type quantification; instead, we rely on a domain-theoretic model of the type system in a universal domain to provide these features. These ideas are implemented in the Tycon library for the Isabelle theorem prover, which builds on the HOLCF library of domain theory. The Tycon library provides various axiomatic type constructor classes, including functors and monads. It also provides automation for instantiating those classes, and for defining further subclasses.</p> <p>We use the Tycon library to formalize three Haskell monad transformers: the error transformer, the writer transformer, and the resumption transformer. The error and writer transformers do not universally preserve the monad laws; however, we establish datatype invariants for each, showing that they are valid monads when viewed as abstract datatypes.</p>", "authors": [{"name": "Brian Huffman", "author_profile_id": "81442603935", "affiliation": "Technische Universit&#228;t M&#252;nchen, Munich, Germany", "person_id": "P3804297", "email_address": "huffman@in.tum.de", "orcid_id": ""}], "doi_number": "10.1145/2364527.2364532", "year": "2012", "article_id": "2364532", "conference": "ICFP", "title": "Formal verification of monad transformers", "url": "http://dl.acm.org/citation.cfm?id=2364532"}