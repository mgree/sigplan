{"article_publication_date": "09-09-2012", "fulltext": "\n Pure Type Systems with Corecursion on Streams From Finite to In.nitary Normalisation Paula Severi Department \nof Computer Science, University of Leicester, UK ps56@mcs.le.ac.uk Abstract In this paper, we use types \nfor ensuring that programs involving streams are well-behaved. We extend pure type systems with a type \nconstructor for streams, a modal operator next and a .xed point operator for expressing corecursion. \nThis extension is called Pure Type Systems with Corecursion (CoPTS). The typed lambda calcu\u00adlus for reactive \nprograms de.ned by Krishnaswami and Benton can be obtained as a CoPTS. CoPTSs allow us to study a wide \nrange of typed lambda calculi extended with corecursion using only one framework. In particular, we study \nthis extension for the calculus of constructions which is the underlying formal language of Coq. We use \nthe machinery of in.nitary rewriting and formalise the idea of well-behaved programs using the concept \nof in.nitary normalisa\u00adtion. The set of .nite and in.nite terms is de.ned as a metric com\u00adpletion. We \nestablish a precise connection between the modal oper\u00adator ( A) and the metric at a syntactic level by \nrelating a variable of type ( A) with the depth of all its occurrences in a term. This syntactic connection \nbetween the modal operator and the depth is the key to the proofs of in.nitary weak and strong normalisation. \nCategories and Subject Descriptors F.4.1 MATHEMATICAL LOGIC AND FORMAL LANGUAGES [Mathematical Logic]: \nLambda calculus and related systems; D.3.2 PROGRAMMING LANGUAGES [Language Classi.cations]: Applicative \n(func\u00adtional) Programming Keywords Typed lambda calculus, modal operator, recursion, streams, in.nitary \nnormalisation 1. Introduction In this paper, we are interested in using types to ensure that pro\u00adgrams \ninvolving streams de.ned by recursive equations are well\u00adbehaved. As an example, we consider streams \nin Haskell. The pro\u00adgram zeros de.ned by the following corecursive equation: zeros = 0:zeros is well-behaved \nbecause the run-time system yields a value which is a potentially in.nite normal form: 0 :(0 :(0 :(...))) \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n12, September 9 15, 2012, Copenhagen, Denmark. Copyright c &#38;#169; 2012 ACM 978-1-4503-1054-3/12/09. \n. . $10.00 Fer-Jan de Vries Department of Computer Science, University of Leicester, UK fdv1@mcs.le.ac.uk \nThe following three programs are not well-behaved because they do not produce any output. omega = omega \nomegaprime = tail (0: omegaprime) e = filter (\\x-> (x>0)) zeros The last program does not produce the \nempty list, but it loops like the other two programs. Intuitively, the above programs are badly behaved \n. The idea of badly behaved programs is formalised in in\u00ad.nitary rewriting: programs are deemed to be \nbad behaved if they are not in.nitary normalisation [25 27], where a program is in.ni\u00adtary (weakly) normalising \nif it has either a reduction to .nite or a reduction to in.nite normal form. None of the above three \nexam\u00adples are in.nitary normalising. A typed lambda calculus satis.es the property of in.nitary normalisation \nif all typable terms are in\u00ad.nitary normalising. Unfortunately, the typed lambda calculus un\u00adderlying \nHaskell is not in.nitary normalising since it allows us to type the above three non-in.nitary normalising \nterms. omega :: a omegaprime :: [Integer] e :: [Integer] The typed lambda calculus of reactive programs \nde.ned by Krish\u00adnaswami and Benton can type some recursive programs such as zerosprime and disallows \nterms like omega [30]. Their system is the simply typed lambda calculus extended with corecursion on \nstreams. In this paper, we extend their typed lambda calculus of reactive programs to the calculus of \nconstructions which is a subset of the underlying formal language for Coq [11]. This extension will allow \nus to write other forms of abstractions: 1. Polymorphic functions such as map and zip. 2. Type constructors \nsuch as the following one (written in Haskell notation):  type DoubleFun a = [a] -> [a] -> [a] 3. Properties \non streams and their proofs, using the Curry Howard isomorphism [12, 13, 22]. For example, we can have \na constant EqStr :.X:set.(Stream X) . (Stream X) . prop to represent equality between streams. To give \na more general presentation, we consider pure type systems (PTSs) [2, 4, 40]. Pure type systems are a \nframework to de.ne several existing typed lambda calculi \u00e0 la Church in a uniform way.1 In particular, \nthis includes the systems of the .-cube and the calculus of constructions [11]. We de.ne Pure Type Systems \nwith Corecursion (CoPTSs) by extending the set of pseudoterms of a PTS with:  1. The type for streams \n(Stream A) with the constructor cons and the destructors head and tail. 2. The next modal type ( A), \nthe constructor . which moves one step after and a destructor await which moves one step before the moment \nin which the term is evaluated. 3. The .xed point operator to express corecursion which is de\u00adnoted \nby co.x.  The judgements of a CoPTS are written as G f a:iA where i is an index representing time. A \nterm of type ( A) represents the information that is going to be displayed later in the future . CoPTSs \nallow us to study a wide range of typed lambda cal\u00adculi extended with corecursion using only one framework. \nWe will study the properties of in.nitary (weak) normalisation and in.ni\u00adtary strong normalisation for \nCoPTSs. These notions are the ana\u00adlogues of weak and strong normalisation in .nite rewriting. Proving \nin.nitary weak normalisation of a typed lambda calculus is a way of ensuring that all typable programs \nare well-behaved. In.nitary weak normalisation expresses that typable terms have a reduction to .nite \nor in.nite normal form. In.nitary strong normalisation ex\u00adpresses something stronger, namely, that any \nreduction strategy will .nd the possibly in.nite normal form. What does an in.nite normal form of a typable \nterms look like? To describe the in.nite normal forms of typable terms, we de.ne a set C8 of .nite and \nin.nite terms as a metric completion of the set of .nite terms over the given syntax using an appropriate \nmetric. We will use a metric based on a notion of depth where only the depth of a subterm b in the contexts \n(cons ab) and (.b) is counted as one (level) deeper than the depth of the terms (cons ab) and (.b) themselves. \nThis type of completion is well known from in.nitary versions of term rewriting systems, lambda calculus \nand combinatory reduction systems [25 27]. One way of proving in.nitary weak normalisation is to give \na reduction strategy that .nds an in.nite or in.nite normal form of a term if it has one. It is well-known \nthat in classic, .nitary lambda calculus the leftmost strategy is normalising [3, Theorem 3.2.2]. However, \nwhen we allow for both .nite and in.nite normal forms, the leftmost strategy is not longer in.nitary \nnormalising. In the example, zeross = zeros: zeross the leftmost strategy does not .nd the in.nite normal \nform in .\u00adsteps.2 For CoPTSs, we follow an in.nitary normalising strategy that reaches the normal form \nin .-steps which is a variation of the depth-.rst leftmost strategy. Figure 1 shows a tree representation \nof the in.nite normal form of zeross that respects our notion of depth. The tree is .nitely branched. \nThe .rst line is at depth 0 and it should be printed .rst, the second line is at depth 1 and it should \nbe printed second, and so on. We establish a precise connection between the modal operator and the metric \nat a syntactic level by relating a variable of type ( A) with the depth of its occurrences in a term. \nThis syntactic 1 By typing \u00e0 la Church, we mean that abstractions are of the form .x:A.b, i.e. the variable \nin the abstraction is provided with an explicit type declara\u00ad tion. 2 In the in.nitary lambda calculus, \nthe situation is actually worse: in.nite left spines, which are terms of the form ((...)P2)P1 don t have \na leftmost redex, when for instance each Pi contains a redex. (cons (cons 0 \u00b7 ) \u00b7 ) (cons 0 \u00b7 ) (cons \n(cons 0 \u00b7 ) \u00b7 ) . . . (cons 0 \u00b7 ) . . . . . . Figure 1. The in.nite normal form of zeross represented \nas a tree connection between the modal operator and the depth is the key to the proofs of in.nitary weak \nand strong normalisation. A pro\u00adgramming language will never be able to display the whole in.nite normal \nform 0 :(0 :(0 :(...))) but it will display only its trunca\u00adtion at certain depth n (an approximant): \n0 :(0 : ... (0 : .) ...)) The modal operator ( A) represents the information that will ap\u00adpear later \nin the computation which is also the information that appears deeper in the in.nite normal form. The \nconnection between the modality and the depth is for\u00admalised as follows. If x:i( A) f b:iB then all occurrences \nof x in b occur at depth (strictly) greater than 0. Similarly, If x:i+1A f b:iB then all occurrences \nof x in b occur at depth (strictly) greater than 0. For typing (co.x x:A.b), we require that x:i+1A f \nb:iA. This means that the variable x in (co.x x:A.b) occurs in b at depth (strictly) greater than 0. \nIn other words, the truncation of b at depth 1 contains no occurrences of x. Let s examine what happens \nduring the computation. Let .. be the reduction that unfolds .xed points: (co.x x:A.b) .. b[x := (co.x \nx:A.b)] After contracting the .xed point, we have that the truncation of b[x := (co.x x:A.b)] at depth \n1 does not contain any residuals of the contracted redex. As an example, we consider the program zeros \nwhich is expressed in our syntax as follows. zeros =(co.x xs:(Stream Nat).(cons 0 xs)) The .-redex occurs \nat depth 0 in zeros. We perform one .\u00adreduction step: zeros .. (cons 0 zeros) In the future of zeros, \nthat is in the reduct (cons 0 zeros), the .-redex occurs at depth 1. The truncation (cons 0 .) of (cons \n0 zeros) at depth 1 represents the information that has been obtained in the .rst time step. The truncated \nsubterm zeros at depth 1 in (cons 0 zeros) represents the information that will appear later. This paper \nis organised as follows. Section 2 gives an overview of PTSs. Section 3 de.nes the notion of CoPTSs. \nSection 4 shows some basic properties, the most important one concerns \u00dfs-strong normalisation. Section \n5 de.nes the set C8 of .nite and in.nite terms as metric completion of the set of .nite terms. Section \n6 stud\u00adies in.nitary weak normalisation. Section 7 studies in.nitary strong normalisation. Section 8 \ndraws some conclusions and explains re\u00adlated work. Section 9 gives some plan for future work.  2. Preliminaries \non Pure Type Systems In this section, we recall the notion of pure type system (PTS) [2]. Pure type systems \nwere introduced independently by Berardi and Terlouw [4, 40] as a way of generalising the systems of \nthe .-cube [2]. Pure type systems consists of seven typing rules, Two of them are parametrised by what \nis called a speci.cation: the axiom and the product rule. By instantiating the parameters, we can describe \nmany kinds of typed lambda calculi such as the the extended calculus of constructions [35] including \ninconsistent systems [21]. The word pure stands for the fact that there is only one type constructor \n. and only one reduction \u00df. We recall the de.nition of speci.cation. The speci.cation in\u00adstantiates the \nparameters in the de.nition of pure type system. De.nition 2.1 (Speci.cation). A speci.cation is a triple \nS = (S, A, R) such that 1. S is a set of symbols called sorts, 2. A.S\u00d7S called set of axioms, 3. R.S\u00d7S\u00d7S \ncalled set of rules.  We will follow custom to abbreviate rules of the form (s1,s2,s2) by just (s1,s2). \nWe will need the notion of single sorted speci.cation to ensure unicity of types (Theorem 4.6) and the \nwell-de.nedness of the encoding in .. (De.nition 4.9). De.nition 2.2 (Single Sorted Speci.cation). We \nsay that a speci.\u00adcation is single sorted if '' 1. If (s1,s2) and (s1,s2) are in A, then s2 = s2. '' \n2. If (s1,s2,s3) and (s1,s2,s3) are in R, then s3 = s3. Types and terms are de.ned in the same set T \n. De.nition 2.3 (Pseudoterms). The set TS (or T for short) of pseudoterms is de.ned as follows. T ::= \nV|S| (.V:T .T ) | (TT ) | (.V:T .T ) ' Sorts are denoted by s,s,..., variables by x, y, . . . and pseu\u00addoterms \nby capital A, B, . . . and also by lower case a, b, . . .. The set fv(A) of free variables of A is de.ned \nin the usual way and A . B is an abbreviation for .x:A.B if x . fv(B). De.nition 2.4 (\u00df-Reduction). We \nde.ne \u00df-reduction as usual: (.x:A.b) a . b[x := a](\u00df) The relation .\u00df is de.ned as the smallest relations \non pseudoterms that are closed under the \u00df-rule and under contexts. In the following section, we will \nde.ne other notions of reduc\u00adtions such as s and .. We introduce the following notation which works for \nall of them. Notation 2.5. Let . be a notion of reduction. 1. M .. N denotes a one step reduction from \nM to N; 2. M . . N denotes a .nite reduction from M to N, possibly consisting of 0 steps;  . + 3. M \n. N denotes a .nite reduction from M to N consisting at least one step; 4. M = . N denotes conversion, \n(.. ...) *  A pseudocontext is a .nite ordered sequence of type declara\u00adtions: G= x1:A1,x2:A2,...xn:An \nwhere xi are all different vari\u00adables and Ai are pseudoterms for all 1 = i = n. De.nition 2.6 (Pure Type \nSystem). A Pure Type System (PTS) denoted by .(S) is given by the judgement G fS a : A (or just G f a \n: A) and de.ned by the typing rules of Figure 2. (axiom) f s1:s2 if (s1,s2) .A G f A:s (start) x G-fresh \nG,x:A f x:A G f A:s G f b:B (weak) x G-fresh G,x:A f b:B G f A:s1 G,x:A f B:s2 (prod) (s1,s2,s3) .R \nG f (.x:A.B):s3 G,x:A f b:B G f (.x:A.B):s (abs) G f (.x:A.b):(.x:A.B) G f b:(.x:A.B)G f a:A (app) \nG f (ba):B[x := a] G f a:A G f A':s (\u00df-conv) A= \u00df A' G f a:A' Figure 2. Pure Type Systems Example 2.7 \n(Systems of the .-cube). The systems of the .-cube are obtained from the following set of sorts and axioms \n[2]. S = {type, kind}A = {(type, kind)} Ranging the parameters s1,s2 in (s1,s2) .R over {type, kind}we \ncan represent different types of functions: (type, type) for terms depending on terms (functions), (kind, \ntype) for terms depending on types (polymorphic func\u00ad tions), (type, kind) for types depending on terms \n(dependent types), (kind, kind) for types depending on types (type constructors). The set {(type, type), \n(kind, type), (type, kind), (kind, kind)} has eight subsets that contain {(type, type)}. This gives us \nBaren\u00addregt s \".-cube\" consisting of eight pure type systems. The smallest such subset gives rise to \nthe simply typed lambda calculus and the biggest subset to the calculus of constructions, [11]. We show \nthe speci.cation of the four systems that we will use later. The simply typed lambda calculus .. is obtained \nfrom the speci.cation S. de.ned by the common sets S and A given above for the systems of the .-cube \nand the following set of rules: R = {(type, type)} The second order lambda calculus [21, 38] is the pure \ntype system .2 similarly obtained from the set of rules: R = {(type, type), (kind, type)} The pure type \nsystem .. corresponds to F. of [21] and is obtained from the set of rules: R = {(type, type), (kind, \ntype), (kind, kind)} The calculus of constructions [11] is obtained from the set of rules: R = {(type, \ntype), (kind, type), (type, kind), (kind, kind)} Example 2.8 (Inconsistent Pure Type Systems). The system \n.V is given by the following speci.cation (called .* in [2]). S = {type}A = {(type, type)}R = {(type, \ntype)} This system is inconsistent in the sense that all types are inhab\u00adited [2, 21]. For examples where \nthe circularity type:type is not necessary to derive inconsistency, see [2, Example 5.2.4]. In any inconsistent \nlogical pure type system, a looping com\u00adbinator can be derived from any term of type . =.X:type.X  [10]. \nThe paper [17] shows that Curry s and Turing s .xed point combinators Y = .f.(.x.f(xx))(.x.f(xx)) and \nT = (.xf.f(xxf))(.xf.f(xxf) cannot be typed in .V . De.nition 2.9 (Term and Context). Let S be a speci.cation. \n1. A (typable) term is a pseudoterm a such that G f a:A for some G and A. 2. A (legal) context is a \npseudocontext G such that G f a:A for some a and A.  In the following de.nition, we consider an arbitrary \nreduction .. In later sections, we will de.ne other notions of reduction besides \u00df. De.nition 2.10 (Weak \nand Strong Normalisation). Let . be a notion of reduction. 1. We say that a pseudoterm a is weakly .-normalising \nif there exists a pseudoterm b in .-normal form such that a . . b. 2. We say that a pseudoterm a is \nstrongly .-normalising if all .\u00adreduction sequences starting from a are .nite.  De.nition 2.11 (Weakly \nand Strongly Normalizing PTS). We say that .(S) is strongly (weakly) \u00df-normalising if for all G f a:A \nwe have that a and A are strongly (weakly) \u00df-normalising. Notation 2.12. We use the notation .(S) |= \n.-SN if .(S) is strongly .-normalising, and .(S) |= .-WN if .(S) is weakly .\u00adnormalising. Obviously, \n.(S) |= .-SN implies .(S) |= .-WN. A proof of the following result can be found in [2]. Theorem 2.13 \n(Strong Normalisation of .(C)). We have that .(C) |= \u00df-SN. The following result is proved in [2, Proposition \n5.2.31]. We use the abbreviation . =.X:type.X. Theorem 2.14 (Inconsistent implies not normalizing). Let \n.(S) be a PTS extending .2. Suppose G f a:. . Then, a is not weakly \u00df-normalising. Hence, .(S) |= \u00df-WN. \nAs a consequence of the previous theorem, the inconsistent pure type system .V from Example 2.8 is not \nweakly normalising. 3. Pure Type Systems with Corecursion In this section, we de.ne the notion of pure \ntype system with corecursion (CoPTS). The set T of pseudoterms is extended to include the type constructor \n(Stream A) for streams of type A, ( A) for the modality next and a .xed point operator (co.x x:A.a) for \nexpressing corecursion. De.nition 3.1 (Pseudoterms with Streams and Corecursion). The set CS (or C for \nshort) is de.ned by the following grammar. C ::= V|S| (.V:C.C) | (CC) | (.V:C.C) C | .C | (await C) | \n(Stream C) | (cons CC) | (hd C) | (tl C) | (co.x V:C.C) We introduce two other reductions besides \u00df-reduction: \n.\u00adreduction for unfolding .xed points and s-reduction for computing the destructors of next and stream \ntypes. De.nition 3.2 (s and .-Reductions). We de.ne the following re\u00adduction rules: (await (.a)) . a \n(s) (hd (cons ab)) . a (s) (tl (cons ab)) . b (s) (co.x x:A.b) . b[x := (co.x x:A.b)] (.) The relations \n.s, .. are de.ned as the smallest relations on pseudoterms that are closed under the respective rules \nand under contexts. The relation .\u00dfs. is the union of .\u00df, .s and .. . Judgements of CoPTSs are of the \nform G f a :i A where i is an index representing time . A pseudocontext G= x1:i1 A1,x2:i2 A2,...xn:in \nAn for a CoPTS is a .nite ordered sequence of type declarations where xi are all different variables \nand Ai are pseudoterms in C for all 1 = i = n. We extend the typing rules of pure type systems for our \nex\u00adtended set C of pseudoterms. Recall that S. is the speci.cation for the simply typed lambda calculus \nde.ned in Example 2.7. De.nition 3.3 (Pure Type System with Corecursion). Let S be a speci.cation extending \nS..A Pure Type System with Corecursion on Streams (CoPTS) denoted by .co(S) is given by the judgement \nG fco S a :i A (or just G f a:iA) for i . Nand de.ned by the typing rules of Figure 3. Example 3.4 (Typed \n.-calculus of Reactive Programs as a CoPTS). Krishnaswami and Benton s typed lambda calculus presented \nin [30] can be obtained as a CoPTS using the speci.cation of the simply typed lambda calculus given in \nExample 2.7. This system will be denoted as .co .. Remark 3.5 (Alternative Typing Rules for co.x using \nModality). As in [30, 31], we add a constant co.x to represent the .xed point combinator. The typing \nrule for (co.x) in Figure 3 is similar to the one presented in [31]. In this version of the rule, the \nvariable x needs to have type A using the index i+1. There is another version of the rule that uses modality \nA and it is as follows. G,x:i A f b:iA G f A:itype (co.x ) G f co.x ' x: A.b:iA The typing rules (co.x) \nand (co.x ) are equivalent. The rule (co.x) allows us to derive (co.x ') by de.ning co.x ' x: A.b = co.x \ny:A.b[x := (.y)]. Conversely, we can set co.x y:A.b = co.x ' x: A.b[y := (await x)] and hence both systems \nare equiva\u00adlent. It is also easy to see that the typing rule for co.x is equivalent to adding a type \ndeclaration of the form co.x '' :i ( A . A) . A for all i as in [30]. In spite of the fact that the rules \n(co.x) and (co.x ) are equiv\u00adalent, we prefer the rule (co.x) to (co.x ). The terms that will be shown \nlater in our examples are typed using (co.x) and we see that in these examples the modality is not necessary. \nIf we had de.ned the type system using the rule (co.x ), our programmes would have been burdened with \nmodalities. For example, let s write the exam\u00adple of zeros given in the introduction using co.x . zeros \n' =(co.x ' xs: (Stream Nat).(cons 0 (await xs))) The explicit type given for xs contains and the recursive \ncall needs to use await. None of this is necessary when zeros is written using co.x (see Example 3.6). \nThis means that depending on the applications we may be able to remove the rules for modalities from \nour system. We include the modality to encompass the type system of reactive programs as a CoPTS [30] \n(examples where modalities are necessary can be found in [30 32]). Nakano s type system has modalities \nwithout indices with help of subtyping and recursive types [36]. In our current formulation, the indices \ncannot be removed. But this does not matter, because the indices are hidden to the programmer as they \nare handled by the type checker.  (axiom) f s1:is2 if (s1,s2) .A G f A:is j = i (start) x G-fresh G,x:iA \nf x:j A G f A:is G f b:j B (weak) x G-fresh G,x:iA f b:j B G f A:is1 G,x:iA f B:is2 (prod) (s1,s2,s3) \n.R G f (.x:A.B):is3 G,x:iA f b:iB G f (.x:A.B):is (abs) G f (.x:A.b):i(.x:A.B) G f b:i(.x:A.B)G f a:iA \n (app) G f (ba):iB[x := a] G f a:iA G f A ' :is (\u00dfs.-conv) A=\u00dfs. A ' G f a:iA ' G f A:itype (mod) G \nf A:itype G f a:i+1A ( I) G f.a:i A G f a:i A ( E) G f (await a):i+1A G f A:itype (stream) G f (Stream \nA):itype G f a:iA G f b:i+1(Stream A) (cons) G f (cons ab):i(Stream A) G f a:i(Stream A) (hd) G f (hd \na):iA G f a:i(Stream A) (tl) G f (tl a):i+1(Stream A) G,x:i+1A f b:iA G f A:itype (co.x) G f (co.x \nx:A.b):iA Figure 3. Pure Type Systems with Corecursion on Streams We will give examples of terms typable \nin CoPTSs. We de.ne a context GNat containing the following type declarations: Nat :i type 0 :i Nat suc \n:i Nat . Nat + :i Nat . Nat . Nat * :i Nat . Nat . Nat Bool :i type < :i Nat . Nat . Bool if :i Bool \n. (Stream Nat) . (Stream Nat) For the sake of the example, adding those constants via a context suf.ces, \nso that we can ignore the corresponding computational and typing rules that would come with this extra \nsyntax. Example 3.6 (Terms typable in .co De.ne the following: .). FunSNat =(Stream Nat) . (Stream Nat) \n. (Stream Nat) zeros =(co.x xs:(Stream Nat).(cons 0 xs)) interleave = co.x f: FunSNat. .xs :(Stream \nNat). .ys :(Stream Nat). (cons (hd xs)(f ys (tl xs))) sumlist = co.x f:FunSNat. .xs:(Stream Nat). .ys:(Stream \nNat). cons (+ (hd xs)(hd ys)) (f (tl xs)(tl ys)) merge = co.x f:FunSNat. .xs:(Stream Nat). .ys:(Stream \nNat). if (hd xs) < (hd ys) then (cons (hd xs)(f (tl xs) ys)) elseif (hd xs) < (hd ys) then (cons (hd \nys)(f xs (tl ys))) else (cons (hd xs)(f (tl xs)(tl ys))) We have that all the above terms can be typed \nin .co .. GNat f zeros :i (Stream Nat) GNat f interleave :i FunSNat GNat f sumlist :i FunSNat GNat f \nmerge :i FunSNat Example 3.7 (CoPTSs beyond .co .). Going beyond .co . we can type polymorphic functions, \ntype constructors and prove properties on streams using the Curry-Howard isomorphism. The polymor\u00adphic \nmap function: map = .X:type. .Y :type. .g:X . Y. co.x f:(Stream X) . (Stream Y ). .xs :(Stream X). (cons \n(g (hd xs)) (f (tl xs))) can be typed in .co2, i.e. f map:i.X:type..Y :type. (X . Y ) . (Stream X) . \n(Stream Y ) We can also write type constructors such as: DoubleFun = .X:type. (Stream X) . (Stream X) \n. (Stream X) which can be typed in .co. as follows. f DoubleFun :i type . type In .co(C), we can write \nand prove properties on streams. For ex\u00adample, we can have a constant EqStr to represent equality between \nstreams. GNat, EqStr:i.X:type.(Stream X) . (Stream X) . type f EqStr Nat zeros zeros:itype Example 3.8 \n(Typable Terms in CoPTS not satisfying guardedness condition). The proof assistant Coq ensures that corecursive \nde.\u00adnitions are well-de.ned by means of the the guardedness condition, i.e. the recursive calls should \nbe guarded by constructors [9, 20].  The following programmes can all be typed in .co2 but they do not \nsatisfy the guardedness condition. Let mapn = map Nat Nat. zeros '' =(co.x xs:(Stream Nat).) (cons 0 \n(interleave xs xs) .b = co.x xs:(Stream Nat). (cons 1(cons 1(sumlist xs (tl xs)))) hamming = co.x h:(Stream \nNat). cons 1 (merge (mapn (.x:Nat.2 * x) h) (merge (mapn(.x:Nat.3 * x) h) (mapn (.x:Nat.5 * x) h))) They \ncan all be typed in .co2 as follows. '' GNat f zeros :i Nat GNat f .b :i Nat GNat f hamming :i Nat We \nformalise the badly behaved Haskell programmes given in the introduction in our setting and show that \nthey are not typable. Example 3.9 (The Undesirables). The badly behaved programmes shown in the introduction \ncan be written in our syntax as follows. O =(co.x x:A.x) Otail =(co.x xs:A.(tl xs)) O ' =(co.x xs:A.(tl \n(cons 0 xs))) O '' =(co.x x:A.(await (.x))) E = .lter Nat (.xs:(Stream Nat).x > 0) zeros) where the function \n.lter is de.ned as follows: .lter = .X : type..P : X . Bool. co.x f:(Stream X) . (Stream X). .xs:(Stream \nX). if (P (hd xs)) then (cons (hd xs)(f (tl xs))) else (f (tl xs)) None of the above terms are typable \nin any CoPTS. More formally, we have that the following holds for all A and i: A :i type f O :i AA :i \ntype f Otail :i A A :i type f O ' :i AA :i type f O ' :i A  GNat f .lter ::i A GNat f E ::i A The terms \nO, Otail and .lter are not typable because the depth of the variable for the .xed point operator happens \nto be at depth 0 (Theorem 7.6). The terms O ' and O '' are not typable because they s-reduce to O which \nis not typable (Theorem 4.5). The term E is not typable because it has a subterm which is not typable. \nWe de.ne auxiliary type systems that will be used later in the proof of in.nitary normalisation. De.nition \n3.10 (Pure Type System with Corecursion from n). Let S be a speci.cation extending S. and n . N.A Pure \nType System with Corecursion on Streams from n (CoPTSn) denoted by .co(S) n is given by the judgement \nG fn S a :i A (or just G fn a:iA) for i . N and de.ned by replacing the rule (co.x) from the typing rules \nof Figure 3 by the following one: G,x:i+1A fn b:iA G fn A:itype (co.xn) i = n G fn (co.x x:A.b):iA 4. \nBasic Properties In this section we prove some basic properties on CoPTSn s. which apply to CoPTSs as \nwell since we have that G f a:iA iff G f0 a:iA. Theorem 4.1 (Con.uence). (C, . \u00dfs. ) is con.uent. Proof. \nThis follows from [29, Corollary 13.6] (see also [28]) by observing that (C, . \u00dfs. ) is an orthogonal \ncombinatory reduction system. Theorem 4.2 (s-strong normalization). Let a .C. Then, a is strongly s-normalising. \nProof. Observe that the number of symbols decreases in each s\u00adreduction step. The notation G+k means \nthat we add k to the index of every hypothesis in G. Theorem 4.3 (Time Adjustment). If G, G ' fn a:iA \nthen G, G ' a:i+kA. +k fn The above theorem is proved by induction on the derivation. Lemma 4.4 (Substitution). \nIf G fn a:iA and G,x:iA, G ' fn b:j B then G, G ' [x := a] fn b[x := a]:j B[x := a]. Proof. This lemma \nfollows by induction on the derivation using Theorem 4.3 for the case of the (start)-rule. Theorem 4.5 \n(Subject Reduction). Let a . \u00dfs. a '. If G fn a:iA then G fn a ' :iA. Proof. We extend the reduction \nto contexts G .\u00dfs. G ' by allowing to reduce the types in G. We have to prove the following two statements \nsimultaneously: 1. If G fn a:iA and a . \u00dfs. a ' then G fn a ' :iA. 2. If G fn a:iA and G . \u00dfs. G ' then \nG ' fn a:iA.  We use Lemma 4.4, Theorem 4.3 and the analogon of Generation Lemma [2, Lemma 5.2.13] adapted \nto the typing rules for CoPTSs Theorem 4.6 (Uniqueness of Types). Let S be single sorted. If G fn a:iA \nand G fn a:iA ' then A = \u00dfs. A ' . The proof of the above theorem is similar to [2, Lemma 5.2.21]. De.nition \n4.7 (Strongly Normalizing CoPTS). Let . be a notion of reduction. We say that .co(S) is weakly (strongly) \n.-normalising if for all G f a:iA, we have that a and A are weakly (strongly) .\u00adnormalising. Notation \n4.8. .co(S) |= .-WN (SN) if .co(S) is weakly (strongly) .-normalising. We use the following abbreviations: \n. =.X:type.X S = .X:type..Y :type.(X . Y . Y ) . Y We consider the context G0 de.ned as c:. where c is \nfresh .  De.nition 4.9 (Encoding in ..). Let G f d:iD. We de.ne {d} by induction on d. {x} = x {s} = \ns {.x:A.B} =.x:{A}.{B} {.x:A.b} = .x:{A}.{b} {(ab)} =({a}{b}) { A} = {A} {.a} = {a} {(await a)} = {a} \n{(Stream A)} = S {A} {(cons ab)} = .Y :type..f:A0 . Y . Y. f {a} ({b} Yf) {(hd a)} = {a} A0 (.x:A0.y:A0.x) \n {(tl a)} = {a}(S A0)(.x:(S A0).y:(S A0).y) {(co.x x:A.b)} =(.x:{A}.{b})(c {A}) When d is either (cons \nab), (tl a) or (hd a), we de.ne the type A0 as the \u00df-normal form (if it exists) of {A} where A is a type \nsatisfying in each one of those cases: G f (cons ab):i(Stream A) G f (tl a):i(Stream A) G f (hd a):iA \nThe map {} is extended to contexts in the obvious way. {x1:i1 A1,...,xn:in An} = x1:i1 {A1},...,xn:in \n{An} The following statements are not dif.cult to prove. Theorem 4.10. 1. If a .\u00df a ' then {a}. + {a \n' }. \u00df 2. If a .s a ' then {a}. \u00df {a ' }. Theorem 4.11 (Encoding from .co. to ..). If G f. d :i D then \n{G}, {d}, {D} are well de.ned and G0, {G}f. {d} : {D}. Proof. This follows by induction on the structure \nof the term using Generation Lemma. We show the case d =(cons ab). Suppose G f (cons ab):i(Stream A) \nand G f (cons ab):i(Stream A ' ). Note that in .co., we only have \u00df-conversion without s.. It fol\u00adlows \nfrom Theorem 4.6 that A = \u00df A '. By Theorem 4.10, we have that {A} = \u00df {A ' }. Hence, G f a :i A and \nG f a :i A '. By Induc\u00adtion Hypothesis, {G}f{a} : {A} and {G}f{a} : {A ' }. Since .. is strongly \u00df-normalising, \nA0 from De.nition 4.9 is uniquely determined since the \u00df-normal forms of A and A ' are the same. Hence, \n{d} is well de.ned. Theorem 4.12 (Strong Normalization of .co. without Contracting Fixpoints). .co. |= \n\u00dfs-SN. Proof. Suppose G f a :i A. By Theorem 4.11, we have that {a} is typable in .. and hence, it is \n\u00df-strongly normalising. We prove that a is strongly \u00dfs-normalising by contradiction. Suppose that a is \nnot strongly \u00dfs-normalising. That is, suppose there exists an in.nite \u00dfs-reduction sequence starting \nfrom a. Observe that the number of \u00df-reduction steps in this sequence must be in.nite because s is strongly \nnormalising (Theorem 4.2). Hence, the sequence is of the form: a = a0 . s a1 .\u00df a2 . s a3 .\u00df a4 . s a5 \n.\u00df a6 ... By Theorem 4.10, we have that: {a} = {a0}. \u00df {a1}.\u00df {a2}. \u00df {a3}.\u00df {a4}. \u00df ... which contradicts \nthe fact that {a} is \u00df-strongly normalising. In order to prove that .co(C) is \u00dfs-strongly normalising, \nwe adapt the proof that .. |= \u00df-SN implies .C |= \u00df-SN given in [2] to CoPTSs. De.nition 4.13. We consider \n.co(C). We say that A is a kindif G fco a : kind for some G.  We say that A is a type constructor if \nG fco A : B : kind for some G and B.  We say that a is an object if G fco a : A : type for some G and \n A. We consider the context G1 de.ned as 0:type,c:. . where 0,c are fresh . As in [2], we de.ne three \nmappings: 1. The mapping . on kinds is exactly as in [2, De.nition 5.3.3]. 2. The mapping t on type \nconstructors and kinds is the extension of [2, De.nition 5.3.7] with the following clauses:  t ( (A)) \n= t (A) t(Stream A)= Stream t (A) 3. The mapping [ _] on objects, type constructors and kinds is the \nextension of [2, De.nition 5.3.10] with the following clauses: [ A] = c (0 . 0) [ A] [ .a] = .[ a] \n[[(await a)]] =(await [ a]]) [[(Stream A)]] = c (0 . 0) [ A] [[(cons ab)]] =(cons [ a] [ b]]) [[(hd \na)]] =(hd [ a]]) [[(tl a)]] =(tl [ a]]) [[(co.x x:A.b)]] =(.z:0.(co.x x:t (A).[ b]]))[[A] Lemma 4.14 \n(Mapping on kinds). Let G fC A :i kind. 1. Then f. .(A):i kind. 2. If A . \u00dfs. A ' then .(A) = .(A ' \n).  The .rst statement follows by induction on the derivation. The second one follows by induction on \nthe structure of A. Lemma 4.15 (Mapping on type constructors and kinds). Let G fC A :i B where G fC B \n:i kind or B = kind. 1. Then, t (G) f. t(A):i .(B). 2. If A . \u00dfs. A ' then t (A) . \u00df t(A ' ).  The \n.rst statement follows by induction on the derivation using Lemma 4.14. The second one follows by induction \non the structure of A observing that t deletes the objects which are the only ones that can contain s.-redexes. \nLemma 4.16 (Mapping on objects, type constructors and kinds). Let G fC a :i A. 1. t (G) f. [ a] :i t(A). \n 2. If a .\u00dfs a ' then [ a] . + [ a ' ] .  \u00dfs The .rst statement follows by induction on the derivation \nusing Lemma 4.15. The second one follows by induction on the structure of a. Theorem 4.17. .co(C) |= \n\u00dfs-SN. Proof. Suppose a is typable in .co(C). By Lemma 4.16 part (1), [ a] is typable in .co.. Suppose \ntowards a contradiction that there exists an in.nite \u00dfs-reduction sequence starting from a. By Lemma \n4.16 part (2), there also exists an in.nite \u00dfs-reduction starting from [ a] . This contradicts Theorem \n4.12. Remark 4.18. The above theorem is about \u00dfs-reduction and does not mention ., because CoPTSs are \nin general not .-normalising as terms containing a .xed point may have an in.nite .-reduction.  (cons \n1 \u00b7 ) (cons 1 \u00b7 ) (cons 2 \u00b7 ) (cons 3 \u00b7 ) . . . Figure 4. The term partial.b represented as a tree 5. \nIn.nite Pseudoterms The program .b of Example 3.8 is not .nitary but in.nitary nor\u00admalising, i.e. the \nnormal form of .b is the in.nite term (cons 1(cons 1(cons 2(cons 3(cons 5 ...))))) What do in.nite normal \nforms of typable terms look like? CoPTSs cannot type (co.x x:A.f x) but they can type (co.x x:A.f (.x)): \nA :i type,f :i A . A f (co.x x:A.f (.x)) :i A To describe the in.nite normal forms of typable terms, \nwe de.ne a set C8 of .nite and in.nite terms as a metric completion. The in.nite terms in C8 have .nitely \nmany symbols at any given depth, where we will count depth of a subterm in a term as the number of cons \nor . operators on the path from the root of the term to the root of the subterm. We do not use any of \nthe existing metrics de.ned in the literature on in.nitary rewriting [25 27]. This is because we want \nto correlate the modal operator, the level n of a CoPTSn and the index i in G f a:iA to the above notion \nof depth (Theorems 6.4 and 7.5). This connection will later be exploited in the proofs of in.nitary weak \nand strong normalisation. De.nition 5.1 (Subterm at position p). Let p be a sequence of 0 s and 1 s. \nThe subterm at position p, denoted as a|p, is de.ned by induction as follows. a|E = a (.x:A.B)|0.p = \nA|p (.x:A.B)|1.p = B|p .x:A.b|0.p = A|p .x:A.b|1.p = b|p (ab)|0.p = a|p (ab)|1.p = b|p ( A)|0.p = A|p \n(.a)|0.p = a|p ((await a))|0.p = a|p (Stream A)|0.p = A|p (cons ab)|0.p = a|p (cons ab)|1.p = b|p (hd \na)|0.p = a|p (tl a)|0.p = a|p (co.x x:A.b)|0.p = A|p (co.x x:A.b)|1.p = b|p Let partial.b be the result \nof unfolding .b three times. partial.b =(cons 1(cons 1(cons 2(cons 3(cons 5 .b))))) The subterm of partial.b \nat position 1.1.1 is (cons 3(cons 5 .b)). Let p, q be two positions, i.e. sequences of 0 s and 1 s. We \nde.ne p<q if there exists a non-empty position r such that q = p.r. De.nition 5.2 (Depth). The depth \nof a subterm b of a is the number of subterms of a at positions q<p such that a|q is either of the form \n(cons cd) or (.c). For example, the depth of (cons 3(cons 5 .b)) in partial.b is three. Figure 4 illustrates \nour notion of depth by drawing the term as a .nitely branched tree. We will de.ne a metric on the collection \nC of terms using truncations. To de.ne truncations we add a new constant . to the syntax. The idea is \nthat we truncate a term by replacing all its subterms at depth n by .. De.nition 5.3 (Truncation). The \ntruncation of a at depth n is denoted by a n and de.ned by induction as follows. a 0 = . n+1 x = x n+1 \ns = s .x:A.Bn+1 =.x:An+1.Bn+1 = .x:An+1.bn+1 n+1 bn+1) .x:A.bn+1 (ba)n+1 =(a ( A)n+1 = An+1 (.a)n+1 n \n= .a ((await a))n+1 =(await a n+1) (Stream A)n+1 =(Stream An+1) (cons ab)n+1 =(cons a n+1 bn) (hd a)n+1 \n=(hd a n+1) (tl a)n+1 n+1 =(tl a ) (co.x x:A.b)n+1 =(co.x x:An+1.bn+1) For example, the truncation of \npartial.b at depth three is (cons 1(cons 1(cons 2 .))) De.nition 5.4 (Metric). We de.ne a(n ultra-)metric \nd : C\u00d7C . [0, 1] as follows: d(a, b)=0, if a = b and d(a, b)=2-m, where m = max{n . Nat | a n = bn}. \nDe.nition 5.5 (Set of Finite and In.nite Pseudoterms). C8 is the metric completion of (C,d). Note that \nrestricted to the subset of lambda terms in C the metric d is just the discrete metric. Hence C8 contains \nall .nite lambda terms, but it does not contain the in.nite lambda terms in the syntax of in.nitary lambda \ncalculus [25, 26]. Example 5.6 (In.nite Pseudoterms in C8). The following are in.nite pseudoterms belonging \nto C8: (cons 0 (cons 0 ...)) .(.(. ...)) (cons 0 (tl (cons 0 (tl ...)))) (await (.(await (. ...)))) Example \n5.7 (What is not in C8?). The following terms do not belong to C8 . (f (f ...)) .x1..x2..x3.... (((...)x3)x2)x1 \n(tl (tl (tl ...))) (await (await (await ...))) The .rst three terms are characteristic examples of respectively \na B\u00f6hm tree, L\u00e9vy Longo and Berarducci tree [1, 3, 5, 25, 33, 34]. These terms belong to syntax of the \nin.nitary lambda calculus [25, 26]. The last two terms belong to the metric completions de.ned for in.nitary \nterm rewriting and in.nitary combinatory reduction systems [25, 27]. n Notation 5.8 (Reduction at depth \nn). We denote a .. b if the contracted .-redex is at depth n. De.nition 5.9 (Strongly Converging Reductions). \nA strongly con\u00advergent .-reduction sequence of length a (an ordinal) is a sequence {a\u00df | \u00df = a} of terms \nin C8, such that 1. a\u00df .. a\u00df+1 for all \u00df<a, 2. a. = lim\u00df<. a\u00df for every limit ordinal . = a.   3. \nlimi.. di = 8 where di is the depth of the redex contracted at ai .. ai+1 for every limit ordinal . = \na. Notation 5.10 (Strongly convergent reduction). a . . b denotes a strongly converging reduction from \na to b. By construction, the set C8 is closed under strongly converging reduction. Example 5.11 (Strongly \nConverging Reductions). We have that zeros . . (cons 0 (cons 0 (cons 0 ...))) via the following strongly \nconvergent reduction of length . (we indicate the depth of the contracted redex in the superscript of \nthe rewrite arrows): 0 zeros .. (cons 0 zeros) 1 .. (cons 0 (cons 0 zeros)) .. (cons 0 (cons 0 (cons \n0 zeros))) .. ...  2 3 . . . (cons 0 (cons 0 (cons 0 ...))) Let nfzeros =(cons 0 (cons 0 (cons 0 ...))) \nbe the in.nite normal form of zeros (see De.nition 6.1). We show an example of a reduction sequence of \nlength .2 . zeross . . . . . . (cons nfzeros zeross) (cons nfzeros (cons nfzeros zeross) . . . . . . \n(cons nfzeros (cons nfzeros (. . .)) As we mentioned in the introduction, there exists a strongly con\u00adverging \nreduction sequence of length . from zeross to the in.nite normal form by following a depth-.rst-leftmost \nstrategy. Example 5.12 (Non-strongly Converging Reductions). The follow\u00ading in.nite reduction sequences \nare not strongly convergent: 000 O .. O .. O .. ... 000 Otail .. (tl Otail) .. (tl (tl Otail)) .. ... \n0 (co.x x:A.f x) .. f (co.x x:A.f x) 0 .. f (f (co.x x:A.f x)) .. ...  0 6. In.nitary Weak Normalisation \nIn this section, we introduce the concept of an in.nitary weakly normalising typing system. We prove \nthat any \u00dfs-normalising CoPTS is in.nitary weakly \u00dfs.-normalising. Proving in.nitary weak normalisation \nencounters several concerns: 1. Contracting .-redexes can create \u00dfs-redexes. 2. Contracting \u00dfs-redexes \ncan decrease the depth of subterms.  We will overcome these concerns by using the auxiliary system fn \nin analogy to a construction in [30]. De.nition 6.1 (In.nitary Weak Normalisation). Let . be a notion \nof reduction. We say that a is in.nitary weakly .-normalising if there exists a possibly in.nite .-normal \nform b such that a . . b. The undesirable terms (see Example 3.9) are not in.nitary weakly \u00dfs.-normalising. \nThe term (mapNat Nat id xs) is in\u00ad.nitary weakly \u00dfs.-normalising. Its normal form is depicted as a tree \nin Figure 5. Our way of drawing of the term as tree re.ects the notion of depth. (cons (hd xs) \u00b7 ) (cons \n(hd (tl xs)) \u00b7 ) . . . Figure 5. In.nite normal form of (map Nat Nat id xs) as a tree De.nition 6.2 \n(In.nitary Weak Normalizing CoPTS). We say that .co (S) is in.nitary weakly .-normalising if for all \na .C such that G f a :i A, we have that a is in.nitary weakly .-normalising. .co(S) | Notation 6.3. = \n.-WN8 if .co(S) is in.nitary weakly .-normalising In the next theorem, we relate the n of a CoPTSn with \nthe truncation at depth n. Theorem 6.4 (Truncation at depth n of a term in CoPTSn). Let n = i. If G fn \na:iA then a n-i is in .-normal form, i.e. a n-i does not have .xed points. Proof. We prove this simultaneously \nwith the statement: if x:j B is in G then Bn-j is in .-normal form. We de.ne a function that contracts \nall co.x occurrences of a pseudoterm just once. De.nition 6.5. We de.ne Ial by induction on a. Ixl = \nx Isl = s I.x:A.bl =.x:IAl.Ibl I.x:A.bl = .x:IAl.Ibl I(ab)l =(IalIbl) I Al = IAl I.al = .Ial I(await \na)l =(await Ial) I(Stream A)l =(Stream IAl) I(cons ab)l =(cons IalIbl) I(hd a)l =(hd Ial) I(tl a)l =(tl \nIal) I(co.x x:A.b)l = Ibl[x := (co.x x:IAl.Ibl)] The map Il is extended to contexts in the obvious way. \nIx1 :i1 A1,...,xn :in Anl = x1 :i1 IA1l,...,xn :in IAnl Note that a . . Ial. Theorem 6.6. Let G fn a:iA. \nThen IGlfn+1 Ial:iIAl. Proof. This is proved by induction on the derivation. We show the key case: G,x:i+1A \nfn b:iA G fn A:itype (co.xn) G fn (co.x x:A.b):iA i = n By Induction Hypothesis, IGl, x:i+1IAl fn+1 Ibl:iIAl \n(1) IGl fn+1 IAl:itype (2) From the above rule, we know that i = n. However, we cannot apply co.xn+1 \nunless i = n +1. The trick is to apply Time Adjustment (Theorem 4.3) to (1) and (2). IGl,x:i+2IAlfn+1 \nIbl:i+1IAl IGlfn+1 IAl:i+1type  Since i +1 = n +1, we can apply (co.xn+1) and obtain: IGlfn+1 (co.x \nx:IAl.Ibl):i+1IAl (3) It follows from Substitution Lemma (Lemma 4.4), (1) and (3) that IGlfn+1 Ibl[x \n:= (co.x x:IAl.Ibl)]:iIAl Since I(co.x x:A.b)l = Ibl[x := (co.x x:IAl.Ibl)], we are done. Theorem 6.7 \n(In.nitary Weak \u00dfs.-Normalisation). If .co(S) |= \u00dfs-WN then .co(S) |= \u00dfs.-WN8 . Moreover, if a term has \na possibly in.nite \u00dfs.-normal forms, it can be found in at most .\u00adsteps. Proof. Suppose G f a :i A. Hence, \nG f0 a :i A. We show that there exists a normalising strategy starting from a. We construct a reduction \nsequence of following form: a = a0 . . a ' 0 . \u00dfs a1 . . a ' 1 . \u00dfs a2 ... (4) We de.ne a0 ' as Ia0l. \nBy Theorem 6.6, we have that IGlf1 a0 ' :i IAl. Since .co(S) is \u00dfs-weakly normalising, so is .co(S) for \nall n. n We can, then, de.ne a1 as the \u00dfs-normal form of a0' . By Theorem 4.5, IGlf1 a1 :i IAl. We repeat \nthis process for each n. Either this process stops and we are done, or the reduction sequence (4) has \nthe following form: a = a0 . \u00dfs. a1 . \u00dfs. a2 . \u00dfs. ... (5) fn where for all n there exist Gn and An such \nthat Gn an :i An. By Theorem 6.4, we have that (an)n is in \u00dfs.-normal form for all n = i. From i onwards, \nthe sequence of truncations 01 2 ai ,ai+1,ai+2,... is increasing (with respect to the subterm re\u00ad lation). \nHence the reduction sequence (5) is strongly converging to an in.nite limit a. in \u00dfs.-normal form. The \ngeneral compression lemma [25, 27]. for left-linear rewriting systems implies that this reduction can \nbe compressed to one of at most . many steps. Corollary 6.8. .co(C) and all the systems of the .-cube \nextended with corecursion are in.nitary weakly \u00dfs.-normalising. Proof. It follows from Theorems 4.17 \nand 6.7, that .co(C) is in.ni\u00adtary weakly \u00dfs.-normalising. Since all the systems of the .-cube extended \nwith corecursion are included in .co(C), we can conclude in.nitary weakly \u00dfs.-normalisation for all of \nthem. 7. In.nitary Strong Normalisation In this section, we connect the index and the modality with the \ndepth. We also de.ne the concept of in.nitary strong normalisation and prove that CoPTSs are strongly \n.-normalising. De.nition 7.1 (In.nitary Strong Normalisation). Let . be a notion of reduction. We say \nthat a is in.nitary strongly .-normalising if we have that all .-reduction sequences starting from a \nare strongly convergent. For example, the term (.x:A.zeros)O is in.nitary weakly \u00dfs.\u00adnormalising but \nit is not in.nitary strongly \u00dfs.-normalising. De.nition 7.2 (In.nitary Strongly Normalizing CoPTS). Let \n. be a notion of reduction. We say that .co(S) is in.nitary strongly .\u00adnormalising if for all a .C such \nthat G fco a :i A we have that a is strongly .-normalising. Notation 7.3. .co(S) |= .-SN8 if .co(S) is \nin.nitary strongly .-normalising Note that .co(S) |= .-SN8 implies .co(S) |= .-WN8 . Theorem 7.4 (Depth \nof Variables). Let G,x:iA, G ' f b:j B. Then the depth of all occurrences of x in b is greater than i \n- j if i>j. Proof. We have to prove it simultaneously with the statement: if G,x:iA, G ' f b:j B and \ny:kC . G ' then all occurrences of x in C occur at depth greater than i - k if i>k. Corollary 7.5 (Depth \nof x of type ( A)). If G,x:i( A) f b:iB then the depth of all occurrences of x in b is greater than 0. \nCorollary 7.6 (Depth of x in co.x). If G f (co.x x:A.b):iA then the depth of all occurrences of x in \nb is greater than 0. As a consequence of Theorem 7.4, we have that if a .xed point occurs in a typable \nterm at depth n then it will occur at depth n +1 after its contraction. Let card.xn(a) be the number \nof .xed points of a at depth n. Theorem 7.7 (Strong Normalisation of .-reduction at depth n). Let G f \na:iA. n 1. If a .. b then card.xn(a) > card.xn(b). n 2. Any reduction sequence of .. steps is .nite. \nProof. The .rst statement is proved by induction on the struc\u00adture of a using Corollary 7.6. The second \none follows by ab\u00adsurd. Suppose there is an in.nite reduction sequence starting from nn a = a0 .. a1 \n.. a2 .... From the .rst part, we would have an in.nite decreasing sequence of natural numbers card.xn(a0) \n> card.xn(a1) > ... This is a contradiction. This means that this reduction sequence has to be .nite. \nTheorem 7.8 (In.nitary Strong .-normalisation). We have that .co(S) |= .-SN8 . Proof. Suppose there is \nan in.nite reduction sequence starting from a = a0 .. a1 .. a2 ... with an in.nite number of steps at \ndepth 0. By Theorem 7.7, the number of steps at depth 0 in that sequence must be .nite. Hence, there \nexists ak such that from ak onwards, all reduction steps contract redexes at depth greater than 1. We \nrepeat the process for n =1 and then for each depth n observing that the number of .xed points of a term \nat depth n decreases if we only contract redexes at depth greater or equal than n. 8. Conclusions and \nRelated Work Comparison with other typed lambda calculi. Nakano de.nes a typed lambda calculus with modality, \nsubtyping and recursive types where Curry s and Turing s .xed point combinators Y and T can be typed \nand both have type ( A . A) . A [36]. Nakano proves that all typable terms have a B\u00f6hm tree without . \nwhich amounts to saying that they have an in.nite \u00df-normal form in the in.nitary lambda calculus with \nthe 001 metric of [26]. Nakano s type system can type terms that CoPTSs cannot type (their in.nite normal \nforms do not belong to C8). For example, it can type Yf whose in.nite normal form is the following: (f \n(f ...)) and also Y(.xy.yx) is typable using the recursive type \u00b5X.( X . B) . B whose in.nite normal \nform is the following: (.y1.y1(.y2.y2(.y3.y3 ...))) Krishnaswami and Benton s typed lambda calculus of \nreactive programs use an equational theory instead of reduction [30]. Corol\u00adlary 6.8 generalises and \nstrengthens in several directions the result in [30] where only weak normalisation is proved for the \nfragment of .co . without .xed points. Krishnaswami, Benton and Hoffman consider a variant of .co . with \nlinearity in [32]. They de.ne a notion of reduction and show that all typable terms reduce to some value. \nSince values are essen\u00adtially abstractions. we can view this result as somewhat similar to weak head \nnormalisation.  Gim\u00e9nez studies an extension of the calculus of constructions with inductive and coinductive \ntypes [19]. A type constructor A is introduced that resembles a modal operator. The meaning of this operator \nis not the same as A. While A can be understood as the information displayed in the future, A represents \nthe set of terms that are guarded by constructors. Borghuis studies modal pure type systems (MPTSs) in \n[8]. CoPTSs are essentially MPTSs with .xed points and streams but without the double negation axiom. \nThe contexts for MPTSs look a bit different because they group together type declarations with the same \nindex Gn, Gn-1,..., G0 where Gi = {x1:iA1,...,xn:iAn}. Judgements in a MPTS can only infer types at time \n0. Productivity. The notion of productivity given in [14, 42] is equivalent to our notion of weak normalisation. \nThe notion of pro\u00adductivity is de.ned as weak normalisation but excluding terms that do not contain constructors \nsuch as (tl (tl (tl ...))). In our case, we exclude terms without constructors from the start by de.ning \nan appropriate metric on terms. The guardedness condition is a criterion that ensures produc\u00adtivity [9]. \nWe cannot say that the guardedness condition is more restrictive than CoPTS. On one hand, CoPTSs can \ntype some terms that do not satisfy the guardedness condition as shown in Example 3.8. On the other hand, \nCoPTSs cannot type the following example which satis.es the guardedness condition: pairup (a1:a2:xs) \n= cons (a1, a2) (pairup xs) The papers [14, 42] de.ne a decidable criterion on (.rst order) term rewriting \nsystems to ensure that programs using corecursive equations are productive [14, 42]. Using this criteria, \nthe terms given in Example 3.8 would satisfy their criterion as well as the example of pairup above. \nAs pointed out by Eduardo Gim\u00e9nez in [21], the guardedness condition (this applies to the criterion in \n[14, 42] as well) has the problem of being a syntactic condition that can be checked only when the proof \nhas been completed. So, it would be desirable to have a typing mechanism that prevents the user from \ndoing a bad recursive call while she is writing the proof and not at the end. Other approaches to corecursion. \nHutton and Jaskelioff propose a methodology that ensures that the .xed point of a function on streams \nis well de.ned [23]. In this methodology each particular case has to be treated on its own, and it is \nnot clear how it can be automatised. Our approach with with typing treats all programs in a uniform way \nand could be automatised. However Hutton and Jaskelioff can handle functions as zeros ''' that CoPTSs \ncannot type. zeros ''' =(co.x xs:(Stream Nat).) (cons 0 (interleave xs (tl xs))) The in.nite normal form \nof zeros ''' is (cons 0 (cons 0 (cons 0 ...))) Techniques to prove normalisation. In order to prove preserva\u00adtion \nof strong normalisation without contracting .xed points, we use two translations: one from .co. into \n.. (Theorem 4.12) and another one from .co(C) to .co. (Theorem 4.17). The translation from .co(C) to \n.co. is an adaptation of the one given by Geuvers and Nederhof in [16]. This translation preserves reduction \nin a way that one step is mapped into one or more steps. The translation from .co (C) to .co. codes the \nstreams making use of polymorphism and ignores the modality. As a consequence of this, s-steps that contract \nthe modal operator can be cancelled. In spite of this, we can prove preservation of strong normalisation \nusing the fact that s is strongly normalising on untyped terms. A similar technique has been used to \nprove .S|= \u00df-SN implies .d(S) |= \u00dfd-SN where .d(S) is the extension of .(S) with de.nitions where the \ntransla\u00adtion can cancel d-steps [39]. In order to prove in.nitary weak normalisation we used an auxiliary \nsystem fn (and the unfolding Ial). This technique is used in [31] to prove that all typable terms have \nan m-normal form for a calculus based on .co . with linearity. The notion of m-normal form is de.ned \nin [31] in terms of the auxiliary system fn. This does not ensure yet that typable terms are well-behaved. \n9. Future Work Our work is closely related to the metric model introduced by Birkedal et al. in [6] (used \nlater by Krishnaswami and Benton in [30]). It will be interesting to de.ne a B\u00f6hm model for corecursion \non streams by interpreting terms as in.nite normal forms [5, 24]. Once we have a B\u00f6hm Model for corecursion \non streams, we would like to .nd a way of integrating the syntactic model of B\u00f6hm trees which is an ultra \nmetric space with the model of ultra metric spaces [6, 30] and the topos of trees [7]. To ensure that \nthe B\u00f6hm model is well de.ned, we need to prove in.nitary con.uence besides in.nitary weak normalisation. \nThe problem is that . \u00dfs. is not con.uent on untypable terms. We construct a counter-example from the \ns-rules which are hypercol\u00adlapsing, i.e. they are of the form C[x] . x [25, 26]. Example 9.1 (Failure \nof Con.uence). We have that  sO '  .   O (tl (cons 0 (tl (cons 0 ...)))) cannot be joined. The terms \nO and (tl (cons 0 (tl (cons 0 ...)))) can only reduce to themselves. Ketema and Simonsen prove con.uence \nup to hypercollapsing terms for orthogonal in.nitary combinatory reduction systems [27]. However, we \ncannot apply their result. This is because C8 is strictly included in their syntax and their con.uence \nresult may give us a common reduct which is outside our syntax We have proved that .co(S) is in.nitary \nstrongly .-normalising. However, it remains open to prove it for \u00dfs.. In this paper we have considered \nonly streams which is one particular coinductive data type. It will be interesting to consider a general \nform of coinductive data type in the spirit of Coq and the Calculus of Inductive Constructions [18 20, \n41]. This will allow us to capture other notions of in.nite data apart from streams such as in.nite trees \nor equality between in.nite objects . Consider a basic primitive recursive function such as + de.ned \nas follows: += (.x : Nat. co.xf:(Nat . Nat). .y : Nat. case y is 0 then x is (succ z) then succ (fz) \nIt is not typable because the variable f occurs at depth 0 (see Theorem 7.6). We think that the solution \nto this problem is to have two different .xed points, one for expressing recursion on inductive data \ntypes and the other one for corecursion on coinductive data types as in [18 20]. In in.nitary rewriting \nother metrics have been considered that result in more in.nite lambda terms in the completion of the \n.nite lambda calculus [25 27]. It would be interesting to know whether there are typing systems that \ntype the normal forms in the lambda calculi of respectively the B\u00f6hm trees, the L\u00e9vy Longo trees and \nthe Berarducci trees. This will help us in the study of con.uence and normalisation for a calculus with \na general form of coinductive data type.  Finally, we did not consider a .-reduction because, as is \nwell\u00adknown, con.uence of \u00df. on untypable terms with annotated types does not hold. The counterexample \ndue to Nederpelt is .x:A.(.y:B.y)x for A = B [37]. A general con.uence proof for weakly \u00df.-normalising \nPTSs is proved in [15]. It should be possible to adapt this proof to CoPTSs. Acknowledgments We would \nlike to acknowledge Alexander Kurz, Tadeusz Litak and Daniela Petri\u00b8san for discussing the papers by \nKrishnaswami and Benton with us. We would also like to thank Neelakantan Krishna\u00adswami for a helpful \nemail exchange. Finally, we are grateful to the reviewers for their detailed and helpful comments and \nsuggestions. References [1] S. Abramsky and C.-H. L. Ong. Full abstraction in the lazy lambda calculus. \nInform. and Comput., 105(2):159 267, 1993. ISSN 0890\u00ad5401. [2] H. Barendregt. Lambda calculi with types. \nIn S. Abramsky, D. Gabbay, and T. Maibaum, editors, Handbook of Logic in Computer Science, volume 2, \npages 118 310. Oxford University Press, 1992. [3] H. P. Barendregt. The Lambda Calculus: Its Syntax and \nSemantics. North-Holland, Amsterdam, Revised edition, 1984. ISBN 0-444\u00ad86748-1; 0-444-87508-5. [4] S. \nBerardi. Type Dependency and Constructive Mathematics. PhD thesis, Carnegie Mellon University and Universit\u00e1 \ndi Torino, 1990. [5] A. Berarducci. In.nite .-calculus and non-sensible models. In Logic and algebra \n(Pontignano, 1994), pages 339 377. Dekker, New York, 1996. [6] L. Birkedal, J. Schwinghammer, and K. \nSt\u00f8vring. A metric model of lambda calculus with guarded recursion. Presented at FICS 2010, 2010. [7] \nL. Birkedal, R. E. M\u00f8gelberg, J. Schwinghammer, and K. St\u00f8vring. First steps in synthetic guarded domain \ntheory: Step-indexing in the topos of trees. In LICS, pages 55 64, 2011. [8] T. Borghuis. Modal pure \ntype systems. Journal of Logic, Language and Information, 7(3):265 296, 1998. [9] T. Coquand. In.nite \nobjects in type theory. In TYPES, pages 62 78, 1993. [10] T. Coquand and H. Herbelin. A-translation and \nlooping combinators in pure type systems. J. Funct. Program., 4(1):77 88, 1994. [11] T. Coquand and G. \nP. Huet. The calculus of constructions. Inf. Comput., 76(2/3):95 120, 1988. [12] H. B. Curry and R. Feys. \nCombinatory Logic, volume I. North-Holland, 1958. [13] N. G. de Bruijn. A survey of the AUTOMATH project. \nIn J. R. Hindley and J. Seldin, editors, To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus \nand Formalism. Academic Press, 1980. [14] J. Endrullis, C. Grabmayer, D. Hendriks, A. Isihara, and J. \nW. Klop. Productivity of stream de.nitions. Theor. Comput. Sci., 411(4-5): 765 782, 2010. [15] H. Geuvers. \nThe Church-Rosser property for beta-eta-reduction in typed lambda-calculi. In LICS, pages 453 460, 1992. \n[16] H. Geuvers and M.-J. Nederhof. Modular proof of strong normal\u00adization for the calculus of constructions. \nJ. Funct. Program., 1(2): 155 189, 1991. [17] H. Geuvers and J. Verkoelen. On .xed points and looping \ncombinators in type theory. Note, 2009. [18] E. Gim\u00e9nez. A Calculus of In.nite constructions and its \napplications to the veri.cation of communicating systems. PhD thesis, Ecole Normale Sup\u00e9rieure de Lyon, \n1996. [19] E. Gim\u00e9nez. Structural recursive de.nitions in type theory. In ICALP, pages 397 408, 1998. \n[20] E. Gim\u00e9nez and P. Caster\u00e1n. A tutorial on [co-]inductive types in coq. Technical report, Inria, \n1998. [21] J.-Y. Girard. Interpr\u00e9tation fonctionelle et \u00e9limination des coupures de l arithm\u00e9tique d \nordre sup\u00e9rieur. PhD thesis, Universit\u00e9 Paris VII, 1972. [22] W. A. Howard. The formulae-as-types notion \nof construction. In J. R. Hindley and J. Seldin, editors, To H.B. Curry: Essays on Combinatory Logic, \nLambda Calculus and Formalism. Academic Press, 1980. [23] G. Hutton and M. Jaskelioff. Representing Contractive \nFunctions on Streams. Submitted to the Journal of Functional Programming, 2011. [24] J. R. Kennaway, \nJ. W. Klop, M. R. Sleep, and F.-J. de Vries. In.nitary lambda calculi and B\u00f6hm models. In RTA, pages \n257 270, 1995. [25] J. R. Kennaway, J. W. Klop, M. R. Sleep, and F.-J. de Vries. Trans.nite reductions \nin orthogonal term rewriting systems. Inf. Comput., 119 (1):18 38, 1995. [26] J. R. Kennaway, J. W. Klop, \nM. R. Sleep, and F.-J. de Vries. In.nitary lambda calculus. Theor. Comput. Sci., 175(1):93 125, 1997. \n[27] J. Ketema and J. G. Simonsen. In.nitary combinatory reduction systems. Inf. Comput., 209(6):893 \n926, 2011. [28] J. W. Klop. Combinatory Reduction Systems. PhD thesis, Rijkuniver\u00adsiteit Utrecht, 1980. \n[29] J. W. Klop, V. van Oostrom, and F. van Raamsdonk. Combinatory reduction systems: Introduction and \nsurvey. Theor. Comput. Sci., 121 (1&#38;2):279 308, 1993. [30] N. R. Krishnaswami and N. Benton. Ultrametric \nsemantics of reactive programs. In LICS, pages 257 266, 2011. [31] N. R. Krishnaswami and N. Benton. \nA semantic model for graphical user interfaces. In ICFP, pages 45 57, 2011. [32] N. R. Krishnaswami, \nN. Benton, and J. Hoffmann. Higher-order functional reactive programming in bounded space. In POPL, pages \n45 58, 2012. [33] J.-J. L\u00e9vy. An algebraic interpretation of the .\u00dfK-calculus, and an application of \na labelled .-calculus. Theoretical Computer Science,2 (1):97 114, 1976. [34] G. Longo. Set-theoretical \nmodels of .-calculus: theories, expansions, isomorphisms. Ann. Pure Appl. Logic, 24(2):153 188, 1983. \nISSN 0168-0072. [35] Z. Luo. ECC, an Extended Calculus of Constructions. In LICS, pages 386 395, 1989. \n[36] H. Nakano. A modality for recursion. In LICS, pages 255 266, 2000. [37] R. P. Nederpelt. Strong \nNormalization in a typed lambda calculus. PhD thesis, Technische Universiteit Eindhoven, The Netherlands, \n1973. [38] J. C. Reynolds. Towards a theory of type structure. In Symposium on Programming, pages 408 \n423, 1974. [39] P. Severi and E. Poll. Pure type systems with de.nitions. In LFCS, pages 316 328, 1994. \n[40] J. Terlouw. Een nadere bewijstheoretische analyse van GSTT s. Manuscript, 1989. [41] B. Werner. \nUne th\u00e9orie des constructions inductives. PhD thesis, Universit\u00e9 Paris VII, 1994. [42] H. Zantema and \nM. Raffelsieper. Proving productivity in in.nite data structures. In RTA, pages 401 416, 2010.  \n\t\t\t", "proc_id": "2364527", "abstract": "<p>In this paper, we use types for ensuring that programs involving streams are well-behaved. We extend pure type systems with a type constructor for <i>streams</i>, a modal operator <i>next</i> and a fixed point operator for expressing <i>corecursion</i>. This extension is called <i>Pure Type Systems with Corecursion</i> (CoPTS). The typed lambda calculus for reactive programs defined by Krishnaswami and Benton can be obtained as a CoPTS. CoPTSs allow us to study a wide range of typed lambda calculi extended with corecursion using only one framework. In particular, we study this extension for the calculus of constructions which is the underlying formal language of Coq. We use the machinery of infinitary rewriting and formalise the idea of well-behaved programs using the concept of infinitary normalisation. The set of finite and infinite terms is defined as a metric completion. We establish a precise connection between the modal operator (&#8226; <i>A</i>) and the metric at a syntactic level by relating a variable of type (&#8226; <i>A</i>) with the depth of all its occurrences in a term. This syntactic connection between the modal operator and the depth is the key to the proofs of infinitary weak and strong normalisation.</p>", "authors": [{"name": "Paula G. Severi", "author_profile_id": "81100191623", "affiliation": "University of Leicester, Leicester, United Kingdom", "person_id": "P3804322", "email_address": "ps56@mcs.le.ac.uk", "orcid_id": ""}, {"name": "Fer-Jan J. de Vries", "author_profile_id": "81548019168", "affiliation": "University of Leicester, Leicester, United Kingdom", "person_id": "P3804323", "email_address": "fdv1@mcs.le.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2364527.2364550", "year": "2012", "article_id": "2364550", "conference": "ICFP", "title": "Pure type systems with corecursion on streams: from finite to infinitary normalisation", "url": "http://dl.acm.org/citation.cfm?id=2364550"}