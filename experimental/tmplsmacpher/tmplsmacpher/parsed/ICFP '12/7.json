{"article_publication_date": "09-09-2012", "fulltext": "\n Practical Typed Lazy Contracts Olaf Chitil University of Kent, UK O.Chitil@kent.ac.uk data Formula \n= Abstract Until now there has been no support for specifying and enforcing contracts within a lazy \nfunctional program. That is a shame, be\u00adcause contracts consist of pre-and post-conditions for functions \nthat go beyond the standard static types. This paper presents the de\u00adsign and implementation of a small, \neasy-to-use, purely functional contract library for Haskell, which, when a contract is violated, also \nprovides more useful information than the classical blaming of one contract partner. From now on lazy \nfunctional languages can pro.t from the assurances in the development of correct programs that contracts \nprovide. Categories and Subject Descriptors D.1.1 [Programming Tech\u00adniques]: Applicative (Functional) \nProgramming General Terms Languages, Reliability Keywords purely functional, lazy, library, Haskell \n1. Introduction Pre-and post-conditions have been important tools for develop\u00ading correct programs since \nthe early days of programming. A con\u00adtract for a function comprises both a pre-and a post-condition. \nFig\u00adure 1 shows de.nitions in Haskell of two functions with contracts that operate on the type Formula, \nwhich represents propositional logic formulae. The two functions clausalNF and clause have rather non-descriptive \ntypes. The function clausalNF transforms a propositional formula into clausal normal form. To work cor\u00adrectly, \nthe function requires its input to be in conjunctive normal form and to be right-bracketed , that is, \nfor example And (Atom a ) (And (Atom b ) (Atom c )) is used instead of And (And (Atom a ) (Atom b )) \n(Atom c ). The output is a list of list of literals, where a literal is an atom or a negated atom. This \npre-condition and post-condition are expressed in the contract conjNF &#38; right >-> list (list lit), \nwhich is attached to clausalNF using the function assert in the de.nition of the contracted function \nvariant clausalNF. The function clause has a similar contract. For any contract c the function assert \nc is roughly the identity function, except that it also enforces the con\u00adtract. The program states the \ncontracts and monitors them at run\u00adtime. Since the work of Findler and Felleisen [12] on contracts for \nea\u00adger functional languages, contracts have become an important item Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. Imp Formula Formula | And Formula Formula | \nOr Formula Formula | Not Formula | Atom Char clausalNF = assert (conjNF &#38; right >-> list (list lit)) \nclausalNF clausalNF :: Formula -> [[Formula]] clausalNF (And f1 f2) = clause f1 : clausalNF f2 clausalNF \nf = [clause f] clause = assert (disj &#38; right >-> list lit) clause clause :: Formula -> [Formula] \nclause (Or f1 f2) = f1 : clause f2 clause lit = [lit] Figure 1. Contracts of functions for clausal normal \nform in the toolbox of the Racket/Scheme programmer. Other functional languages, however, have not yet \npro.ted from the support of con\u00adtracts for several reasons: Eager functional contracts were introduced \nas a small library of contract combinators. However, the implementation in Racket uses its powerful macro \nsystem to smoothly integrate contracts into the language1. Thus contracts are very easy to use, for ex\u00adample, \ndo not require user-supplied program location parame\u00adters. Implementors of other programming languages, \nhowever, do not have such a powerful macro system and are wary of mak\u00ading the implementation effort and \nof extending the language.  In contrast to dynamically typed Racket, many functional programming languages \nhave a static type system based on Hindley-Milner types with parametric polymorphism. Thus contract combinators \nneed to be statically typed too and it is desirable to have type-directed contract combinators such as \nlist :: Contract a -> Contract [a].  We also have to avoid classes in types. To see why, consider the \nfollowing example usage of the Haskell object observation debugger HOOD [16]: length :: Observable a \n=> [a] -> Int length = observe \"fun\" length length :: [a] -> Int length = List.length  ICFP 12, September \n9 15, 2012, Copenhagen, Denmark. 1 Recently added features concerning mutable data also required modi.ca-Copyright \n&#38;#169; 2012 ACM 978-1-4503-1054-3/12/09 $15.00. tions of the language implementation [10].  Here \nobserve \"fun\" behaves like an identity function but also records input and output of the length function \nfor debugging purposes. However, the observation function does not have the type of the identity function: \nthe type of length includes the class Observable and thus adding an observation may require substantial \nchanges to type annotations in the whole program. To avoid this problem, we have to ensure that contract \ncombi\u00adnators have simple parametrically polymorphic types, without class contexts. Eager functional contracts \nare strict. Let nat be the contract that holds only for non-negative integers. With strict contracts \nwe would get assert (list nat) [4,-1,2] = error \"...\" Asserting an eager contract yields either the unchanged \nargu\u00adment or an error/exception. In contrast, lazy functional lan\u00adguages demand lazy contracts. Asserting \na lazy contract yields those parts of the argument data structure that meet the contract; only those \nparts that violate the contract are cut off : assert (list nat) [4,-1,2] = [4,error \"...\",2] Because \nlazy evaluation generally only evaluates parts of a data structure, a computation may succeed without \nany contract vio\u00adlation error, if it only demands those data structure parts that meet the contract. \nSuch lazy contracts preserve the lazy se\u00admantics of the program and thus ensure that we can add con\u00adtracts \nanywhere in a program without changing its semantics, provided contracts are not violated. For example, \nthe following de.nition of the in.nite list of .bonacci numbers requires lazy contracts: fibs :: [Integer] \nfibs = assert (list nat) (0 : 1 : zipWith (+) fibs (tail fibs)) In this paper we develop a library for \ncontracts in Haskell that makes the following contributions: The contract combinators have simple parametrically \npolymor\u00adphic types, such that adding a contract does not change the type of a function (Section 2). \n The library provides lazy contract combinators. Adding con\u00adtracts leaves the semantics of a program \nunchanged, unless a contract is violated (Sections 2 and 3).  The library is written in pure, portable \nHaskell, without any use of side-effecting primitives such as unsafePerformIO that could change the semantics \nof the program (Section 3).  All data-type-dependent code is simple and thus easy to write by hand if \nnecessary (Section 3).  The contract combinators have a nice algebra of properties. Contract assertions \nare partial identities and we claim that they are idempotent too. Thus contracts are projections, like \neager contracts (Section 4).  If a contract is violated, then the raised exception does not simply blame \nthe server (contracted expression) or its client, but provides additional information about the speci.c \nvalue that caused the violation (Section 5).  The library can use Template Haskell to derive all data-type\u00addependent \ncode and include source code locations. Thus the programmer can formulate contracts for new algebraic \ndata types without any additional work (Section 6).  The contract library for Haskell is available on \nHackage2.  2. Simple Contract Combinators with a Problem Using previous work on eager contracts [11] \nand typed contracts [19], we can easily design and implement most of a contract library for Haskell. \nWe implement a parametric type Contract a and a function assert :: Contract a -> (a -> a) that turns \na contract into a partial identity, that is, assert c . id. Here . is the standard information-theoretic \npartial order on values with least element .. For simplicity we consider . to be an expression. It represents \nboth non-termination and an exception raised by a violated contract. Most of the contract library consists \nof combinators for building contracts of type Contract T, for various types T. We start with a combinator \nthat turns a predicate into a contract: prop :: Flat a => (a -> Bool) -> Contract a used for example \nas nat :: Contract Integer nat = prop (>=0) to specify natural numbers as integers greater or equal zero. \nWe have to restrict prop by a new class Flat to be used for .at types only. A type is .at if for all \nvalues v1 and v2 the ordering v1 C v2 implies v1 = .. We cannot use prop for non-.at types such as lists, \nbecause the predicate could be arbitrarily strict and thus violate our aim of building lazy contracts \n[2]. For example nats = prop (all (>=0)) :: Contract [Integer] would not be lazy and thus would be unusable \nfor our in.nite list of .bonacci numbers. So the class Flat has only a few instances such as instance \nFlat Integer instance Flat Float instance Flat Char In our initial example in Figure 1 we already used \ntwo combi\u00adnators for building contracts: (&#38;) :: Contract a -> Contract a -> Contract a (>->) :: Contract \na -> Contract b -> Contract (a -> b) The conjunction combinator (&#38;) builds a contract that is vio\u00adlated \nif one of the components is violated. The combinator (>->) looks similar to the function type; it does \nnot indicate logical im\u00adplication. The function combinator combines a pre-and a post\u00adcondition to a contract \nfor a function. For a function to be be correct, whenever the pre-condition holds, the post-condition \nmust hold too. However, if the pre-condition is violated, then the client (caller) of the function is \nwrong. A function contract is an agree\u00adment between both a function and its client. So neither pre-nor \npost-condition should be violated. In summary, the function con\u00adtract combinator is rather like the conjunction \ncombinator, except that values of two possibly different types are monitored. A contract that is always \nmet is useful as component of a bigger contract to express that some values are irrelevant. The opposite \ncontract that is never met can still be occasionally useful in a lazy functional language. We can use \ntrue :: Contract a false :: Contract a for example in 2 http://hackage.haskell.org  type Contract a \n= a -> a assertc=c class Flat a where prop :: (a -> Bool) -> Contract a propp=\\x->ifpx then x else error \n\"...\" pNil[] =[] pNil ( : ) = error \"...\" pCons c cs [] = error \"...\" pCons c cs (x:xs) =cx:csxs true \n= id false = const (error \"...\") c1&#38;c2 =c2 .c1 pre>->post=\\f->post.f.pre Figure 2. A lazy contract \nimplementation for most combinators const = assert (true >-> false >-> true) const const ::a ->b-> a \nconst xy=x to express that the second argument of the function is never de\u00admanded. Because that argument \nis never demanded, its contract will never be used and thus will never be violated. Finally we need combinators \nto build contracts for algebraic data types, which generally are not .at. Here we introduce for each \ndata constructor a combinator that is used like a data constructor in pattern matching. pNil :: Contract \n[a] pCons :: Contract a -> Contract [a] -> Contract [a] Now we can de.ne a contract for in.nite lists: \ninfinite :: Contract [a] infinite = pCons true infinite If this contract is asserted for a .nite list \nand evaluation demands the last constructor, [], of this .nite list, then a contract violation exception \nis raised. Here we also use the contract true to state that we do not restrict the list elements in any \nway. All our combinators can be implemented using the same con\u00adtract type as for the well-known eager \ncontracts. Even the new data constructor combinators can easily be implemented using that type. The short \nimplementation is given in Figure 2. However, one important combinator is still missing. On their own, \ndata constructor combinators such as pNil and pCons are of rather limited use, the in.nite list contract \nbeing one of the few examples where they suf.ce. We need a combinator for combining two data constructor \ncontracts disjunctively: (|>) :: Contract a -> Contract a -> Contract a This combinator allows us, for \nexample, to de.ne the contract of a (.nite or in.nite) list of natural numbers as follows: nats :: Contract \n[Integer] nats = pNil |> pCons nat nats The de.nition intentionally looks very similar to the de.nition \nof an algebraic data type. We cannot de.ne (|>) using the contract type de.nition type Contract a = a \n-> a type Contracta=a-> Maybe a assert :: Contract a -> (a -> a) assertcx=casecxof Just y ->y Nothing \n-> error \"Contract violated.\" class Flat a where prop :: (a -> Bool) -> Contract a proppx=ifpx then Just \nx else Nothing pNil :: Contract [a] pNil [] = Just [] pNil ( : ) = Nothing pCons :: Contract a -> Contract \n[a] -> Contract [a] pCons c cs [] = Nothing pCons c cs (x:xs) = Just (assert c x : assert cs xs) true \n:: Contract a true = Just false :: Contract a false = const Nothing (|>) :: Contract a -> Contract \na -> Contract a c1|>c2=\\x-> c1x mplus c2x (&#38;) :: Contract a -> Contract a -> Contract a c1&#38;c2=\\x->c1x>>= \nc2 (>->) :: Contract a -> Contract b -> Contract (a -> b) pre >-> post = \\f -> Just (f seq (assert \npost . f . assert pre)) Figure 3. Implementation of typed lazy contract combinators We can combine two \nfunctions of type a->a only by composi\u00adtion and we have done so already for the contract combinator (&#38;). \nFor disjunction we would need to apply both functions separately and then somehow combine the two results: \nif one is an exception, then we should return the value of the other one. We cannot test for exceptions \nin a purely functional language3.  3. Implementing Lazy Contract Combinators A simple modi.cation of \nour contract type de.nition solves our problem: type Contracta=a-> Maybe a The Maybe a type enables us \nto test for contract violation and then to try the next contract. The return value Nothing indicates \nthat the contract is violated for the top constructor of the monitored value. The return value Just v \nindicates successful matching of the top constructor and returns the value with possibly further contracts \nattached to its components. Recall that for Maybe a its monadic functions are de.ned as follows: (>>=) \n:: Maybe a -> (a -> Maybe b) (Just x) >>=f=fx Nothing >>= f = Nothing 3 There is an impure solution [6] \nthat, however, still cannot handle non\u00adtermination in one argument.  mplus :: Maybe a -> Maybe a -> \nMaybe a (Just x) mplus m = Just x Nothing mplus m = m Figure 3 lists the full implementation of our contract \ncombina\u00adtors. In the de.nition of the function contract combinator seq .rst evaluates the function itself \nbefore returning it wrapped in asser\u00adtions. This de.nition ensures assert (c1 >-> c2) . = . that is, \nfunction contracts are strict like all other contracts. Without seq the expression assert (c1 >-> c2) \n. instead would be the function that demands no argument and always returns .,which in Haskell can be \ndistinguished from the function . itself. Thus the function contract combinator would change the semantics \nof a program even when the contract is not violated. Admittedly, we do not expect this case to ever occur \nin practice. The presence or absence of seq makes no difference for the contract properties given in \nthe next section. The contract type reminds of parser combinators. However, contracts are deterministic: \ncontract application assert c is a function for any contract c. No value of a second type, e.g. a parse \ntree, is constructed. Hence we only need the Maybe a type with its two choices, not the more general \nlist type [a] that would provide an arbitrary number of choices. A pattern combinator tests only for \nthe top constructor. If that .ts, then the pattern combinator succeeds. Hence assert (pCons nat pNil \n|> pCons true pNil) [-3] = [error \"Contract violated.\"] Here matching the list constructor of pCons nat \npNil succeeds and therefore the second list contract pCons true pNil is never tried, even though the \ncontract for the list element, nat, is violated. For all our examples the simple semantics suf.ces and \nit is easy to understand. For example, we can de.ne a parameterised contract for the list data type list \n:: Contract a -> Contract [a] list c = pNil |> pCons c (list c) and use it to de.ne the contract of list \nof natural numbers: nats :: Contract [Integer] nats = list nat We can also de.ne functions with non-contract \nparameters to construct contracts: listOfLength :: Int -> Contract [a] listOfLength 0 = pNil listOfLength \n(n+1) = pCons true (listOfLength n) However, in such a case we need to be sure that the parameter value \nis well-de.ned, so that it cannot introduce non-termination into the program. For example lengthAtLeast \n:: Int -> Contract [a] lengthAtLeast 0 = true lengthAtLeast (n+1) = pCons true (lengthAtLeast n) contractTake \n:: Int -> [a] -> [a] contractTake n = assert (lengthAtLeast n >-> listOfLength n) (take n) is only safe, \nbecause the function take is strict in its integer param\u00adeter, which determines how many list elements \nshall be returned. prop p1 |> prop p2 = prop (\\x -> p1 x||p2 x) prop p1 &#38; prop p2 = prop (\\x -> p1 \nx&#38;&#38;p2 x) c1 &#38;(c2 &#38;c3) = (c1 &#38;c2)&#38;c3 true &#38; c = c c &#38; true = c false &#38; \nc = false c1 |> (c2 |> c3) = (c1 |> c2)|>c3 false |> c = c c |> false = c true |> c = true c|>c = c c1 \n|> (c2 |> c1) = c1 |> c2 c1 |> (c1 &#38;c2) = c1 c1 >-> false = c2 >-> false (c1 >-> c2)&#38;(c3 >-> \nc4) = (c3 &#38;c1) >-> (c2 &#38;c4) (c1 >-> c2)|>(c3 >-> c4) = c1 >-> c2 Figure 4. Contract properties \nc1 &#38;(c1 |> c2) = c1 c1 &#38;(c2 &#38;c1) = c1 &#38;c2 c&#38;c = c Figure 5. Claimed contract properties \n 4. Properties of Contracts Our contract type Contract a is a combination of the function type with \nthe Maybe monad. Thus we have a rich set of known properties to work with for establishing an algebra \nof contracts. Contract itself is not a monad. 4.1 An Algebra of Contracts Figure 4 lists many simple \nproperties enjoyed by contracts. All of these can be proved by simple equational reasoning, using the \nmonad laws of Maybe a. All the properties of conjunction and disjunction of contracts also hold for conjunction \nand disjunction of Booleans in a lazy lan\u00adguage. Recall that some standard properties of Boolean algebra \ndo not hold for the Boolean type in non-strict languages. For example, (&#38;&#38;) and || are not commutative \nand the standard distribution laws do not hold. These properties do not hold for contracts either, with \nsimilar counterexamples. So the non-strict algebra of (&#38;&#38;) and || is a good guideline for developing \nthe lazy contract algebra of &#38; and |>. The distribution law for conjunction and function contract \nmay at .rst surprise. It holds because the function contract com\u00adbinator is not some kind of implication \nbut more a kind of con\u00adjunction. A function contract holds only if both the input and the output of a \nfunction meet the respective subcontracts. From this distribution law of conjunction and function plus \nidempotence of conjunction further laws follow:  (c1 >-> c) &#38; (c3 >-> c) = (c1 &#38;c3) >-> c (c \n>-> c2) &#38; (c >-> c4) = c >-> (c2 &#38;c4) Figure 5 lists further properties of contracts that we \nhave not proved but claim also hold. They require stronger proof methods than equational reasoning, but \nare linked to the idempotence of con\u00adtracts discussed in the subsequent subsection. The last property \nin the list, idempotence of conjunction, is a corollary of the preceed\u00ading property, taking c2 = true. \n 4.2 Contracts are Projections Eager contracts are projections [1, 11], that is, they are idempotent \nand partial identities. Lemma 4.1 (A contract is a partial identity). For any contract c assert c id \nThis can be proved using induction on the contract combinators. Idempotence is more dif.cult to establish. \nIt would follow from idempotence of conjunction, c&#38;c = c.Inpractice, bothprop\u00aderties probably need \nto be established in a single inductive proof. Intuitively idempotence holds because if a contract returns \nJust v, that value v is the same as would be returned by the eager contract type a->a, and pattern contracts \nonly test for the top constructor before returning Just v or Nothing. Claim 4.2 (A contract is idempotent). \nFor any contract c assert c . assert c = assert c 4.3 Distinct Contract Exceptions We identi.ed non-termination \nand any contract exception as the single value .. However, we might distinguish them, following [22], \nsuch that exceptions are values above . in the information order, but still values of any type. We would \nchange our partial order to consider exceptions as least elements, because a contract replaces some parts \nof values by exceptions. However, with that choice our contracts are neither partial identities, nor \nidempotent (the properties of Figure 4 are unaffected). The reason is that contracts such as . :: Contract \na prop . :: Flat a => Contract a prop (\\x -> if odd x the True else .) :: Contract Int exist. They would \nstill introduce . instead of exceptions. For related reasons other works [1, 8] restricted the de.nitions \nof contracts such that a contract can never introduce . itself. However, the desirable freedom to use \nthe whole language to de.ne contracts and the fact that we are just de.ning a library makes this an impractical \nchoice.  5. Informative Contract Violation A contract is concluded between two partners, a server and \na client. If a contract is violated, one of the two partners is to blame for it. A major contribution \nof Findler and Felleisen s functional contracts [12] is its system for choosing whom to blame. In a higher-order \nlanguage function arguments can themselves be functions. If such a functional argument is used within \nthe function such that the pre\u00adcondition of the functional argument is violated, then the function itself \nhas to be blamed for contract violation, not the caller that passed the functional argument. type Contracta=a-> \nBool -> Either Bool a assert :: Contract a -> (a -> a) assert = monitor True monitor :: Bool -> Contract \na -> (a -> a) monitorbcx= casecxbof Rightx ->x Left b -> error (\"Contract violated. Blame \" ++ if b then \n\"server.\" else \"client.\") (>->) :: Contract a -> Contract b -> Contract (a->b) pre >-> post = \\f b -> \nRight (f seq (monitor b post . f . monitor (not b) pre)) true :: Contract a true=\\xb ->Right x false \n:: Contract a false = \\x b -> Left (not b) Figure 6. Implementing blaming 5.1 Blaming The blaming system \nfor higher-order functional languages applies to both eager and lazy languages equally, and thus we can \neas\u00adily add it to our lazy contract library. For eager languages sev\u00aderal equivalent implementations \nfor handling blame are known [11, 12, 19]. Here we simply extend a contract by a Boolean state that indicates \nwhether the server or the client of the contract are to blame in case of violation. The Maybe monad is \nreplaced by Either Bool a so that blame information is available when a sub\u00adcontract is violated. Figure \n6 shows the most interesting extended de.nitions. Contract monitoring starts by potentially blaming the \nserver, that is, the expression for which the contract is asserted. The function contract combinator \n>-> negates the Boolean blame indicator for monitoring the contra-variant argument, but passes it unchanged \nfor monitoring the co-variant result. Now there are two different possible implementations of the contract \nfalse that can never be met: The contract either always blames the party indicated by the given Boolean \nargument, or it always blames the opposite party by negating the Boolean value. So let us look back at \nour example of Section 2: const = assert (true >-> false >-> true) const Any client of const will provide \nsome second argument, but if that second argument is actually demanded, then clearly const is wrongly \nde.ned and has to be blamed. In this example false is in a contra-variant position of the whole contract \nand hence to blame the server, false has to negate its Boolean parameter. So on its own, false always \nblames its client, never its server. We do not provide the server-blaming variant in the library, because \nit does not seem to be of any practical use.  5.2 Witness Tracing Blaming alone, however, is rather \nunsatisfactory. It just points the .nger at one partner without providing any evidence that would explain \nin which way a complex contract was violated. Blaming hardly provides a good starting point for debugging. \nFurthermore, blaming can be misleading. Often when a contract is violated nei\u00adther server nor client \nare wrong, but the contract itself! Specifying  type Contract a = (String -> String) -> a -> Either \nString a assert :: Contract a -> (a -> a) assert = monitor id monitor :: (String->String) -> Contract \na -> (a->a) monitor wccx= casecwcxof Right v -> v Left w -> error (\"Contract violated. Witness:\" ++ wc(\"{\"++w++\"}\")) \n(>->) :: Contract a -> Contract b -> Contract (a->b) pre >-> post = \\wc f -> Right (f seq (monitor (wc \n. \\w->(\"(_->\"++w++\")\")) post . f . monitor (wc . \\w->(\"(\"++w++\"->_)\")) pre)) pNil :: Contract [a] pNil= \n\\wc x-> casexof [] -> Right x _:_ -> Left \"_:_\" pCons :: Contract a -> Contract [a] -> Contract [a] pConscxcxs=\\wcx-> \ncase xof (y:ys) -> Right (monitor (wc . \\w->(\"(\"++w++\":_)\")) cx y : monitor (wc . \\w->(\"(_:\"++w++\")\")) \ncxs ys) [] -> Left \"[]\" Figure 7. Implementing witness tracing the right contract is challenging and \ncontract monitoring just checks whether speci.cation and implementation agree. Hence our lazy contracts \nreport, when they are violated, the top data constructor, or whole .at value, that causes the contract \nviola\u00adtion, plus all data constructors in the path above it. For example *Main> clausalNF form [[Atom \na ],[Atom b ,Not *** Exception: Contract violated. Witness: ((And (Or (Not {Not })))-> ) Here we do \nnot need to know the full de.nition of the formula form. The error message tells us all that we need \nto know: The for\u00admula contains a double-negation and therefore is not in conjunctive normal form, as \nthe contract of clausalNF requires. More pre\u00adcisely, the contract was asserted for a function that took \nas argu\u00adment a formula with And at the top, with Or as second argument, which has a Not as second argument, \nwhich has the forbidden Not as argument. To trace the required information of a potential witness of \ncon\u00adtract violation, our contracts pass an additional argument that accu\u00admulates a description of the \ncontext of a monitored value, and a vio\u00adlated contract returns a string describing the offending value \nitself. The representation of the context is of type String -> String to easily slot another context \nor expression representation into the hole of the context. Figure 7 gives an outline of the implementa\u00adtion. \nThe printed witness describes just the data that needs to be evaluated to notice the contract violation. \n 5.3 Location + Blame + Witness Our .nal contract library combines blaming and witness tracing, records \nthe source location of a contract and raises a special ex\u00adception to provide the maximal information \nwhen the contract is violated. For example: *Main> clausalNF form [[Atom a ],[Atom b ,Not *** Exception: \nContract at ContractTest.hs:101:3 violated by ((And (Or (Not {Not })))-> ) The client is to blame.  \n6. Deriving Contract Combinators For every data constructor Con that we want to pattern match in a contract \nwe have to de.ne a pattern contract pCon. These de.ni\u00adtions are simple, even with handling of location, \nblame and witness information, but they are still tedious. Hence our contract library al\u00adlows their automatic \nderivation using Template Haskell [23]. Tem\u00adplate Haskell is a meta-programming extension of Haskell \nthat the Glasgow Haskell compiler, the only Haskell system used for professional Haskell program development, \nprovides. Template Haskell allows us to de.ne in the contract library functions that will generate Haskell \ncode at compile time, type check that code and compile it. The user no longer needs to de.ne these pattern \ncontracts at all, but can basically derive them on demand where needed, that is, directly write conjNF \n= $(p And) conjNF conjNF |> disj disj = $(p Or) disj disj |> lit lit = $(p Not) atom |> atom atom = $(p \nAtom) true Here p is a Template Haskell function that receives the name of a data constructor as argument. \nThe $ and the single quote in front of the data constructor are syntax required by Template Haskell. \nThe de.nition of a pattern contract is short so that repeated derivation is not a problem. Alternatively, \nthe programmer can also write the declaration $(deriveContracts Formula) to derive all pattern contract \nde.nitions for the type Formula. Finally, assert is also a Template Haskell function: clausalNF = $assert \n(conjNF &#38; right >-> list (list lit)) clausalNF Template Haskell allows the de.nition of assert to \ndetermine its own location in the .le and then generate code for calling the real assertion function \nwith that location as parameter.  7. Further Contract Features Initial experience of using contracts \nraises new questions and de\u00admand for additional contract combinators. 7.1 Negation We have conjunction, \n&#38;, and disjunction, |>, of contracts. However, we cannot have negation neg :: Contract a -> Contract \na for contracts. General negation would violate basic semantic prop\u00aderties of contracts [2]. Nonetheless, \nin practice we often want to express that the top data constructor of a monitored value is not a speci.c \ngiven data constructor. Hence we introduce additional combinators such as the following for every data \ntype. pNotImp :: Contract Formula pNotAnd :: Contract Formula pNotOr :: Contract Formula pNotNot :: Contract \nFormula pNotAtom :: Contract Formula  These negated pattern contracts provide nothing new. In fact pNotImp \n= pAnd true true |> pOr true true |> pNot true |> pAtom true However, for types with many data constructors \nthese combina\u00adtors are certainly substantial abbreviations and they are needed fre\u00adquently. Additionally, \nour implementation can perform an ef.cient single pattern match instead of many repeated ones. We use \nthese negated pattern contracts in the de.nition of con\u00adtracts for our initial propositional formulae \nexample. They substan\u00adtially simplify our de.nition of right-bracketedness . conjNF, disj, lit, atom, \nright, rightConjNF :: Contract Formula conjNF = pAnd conjNF conjNF |> disj disj = pOr disj disj |> lit \nlit = pNot atom |> atom atom = pAtom true right = pImp (right &#38; pNotImp) right |> pAnd (right &#38; \npNotAnd) right |> pOr (right &#38; pNotOr) right |> pNot right |> pAtom true rightConjNF = conjNF &#38; \nright Even for data types with few constructors they can express an idea more clearly. So head = assert \n(pNotNil >-> true) head is more direct than head = assert (pCons true true >-> true) head to express \nthat the function only works on non-empty lists.  7.2 Contracts for the IO monad We have contract combinators \nfor .at types, algebraic data types and the function type constructor. However, a real programming language \nhas more types, especially abstract data types. The most notorious in Haskell is the IO monad that is \nrequired for any input or output actions. For example, we may want to write a contract for an IO action \nthat gets a natural number from standard input: getNat :: IO Integer getNat = assert (io nat) getNat \n The choice of contract combinator is natural, following our general approach of type-directed contract \ncombinators. How do we de.ne the IO contract combinator? io :: Contract a -> Contract (IO a) io c = \\io \n-> Just (io >>= return . assert c) Our de.nition simply follows the scheme we are already using for the \nfunction contract combinator >->. After all, the function type is just an abstract data type as well4. \nWith this de.nition our 4 The forced evaluation with seq by the function contract combinator is required \nbecause of the peculiar semantics of functions in Haskell. It is not needed for other types. For example, \nif io = ., then also io >>= return . assert c = .. IO contract combinator also has the same properties \nas the function contract combinator: io c1 &#38;ioc2 = io (c1 &#38;c2) io c1 |> ioc2 = io c1 io true \n= true Our de.nition of the contract combinator for the abstract data type IO a raises the question whether \nwe should do the same for other data types. For example, we have list :: Contract a -> Contract [a] list \nc = pNil |> pCons c (list c) Alternatively we could follow our de.nition of io: list c = \\xs -> Just \n(xs >>= return . assert c) which is the same as list c = \\xs -> Just (map (assert c) xs) It turns out \nthat the two de.nitions are equivalent5, thus con.rm\u00ading our original de.nition. Hence we prefer to de.ne \na contract combinator for a non-abstract algebraic data type such as list in terms of the only primitive \ncontract combinators, the pattern con\u00adtract combinators, such as pNil and pCons. For an abstract data \ntype we de.ne a contract combinator using the scheme above with the respective map function for the type. \n 7.3 Strict data types Haskell allows the de.nition of strict data types. The strictness .ag ! in a \ndata type de.nition states that the data constructor is strict in that argument. For example, data SListBool \n= SNil | SCons !Bool !SListBool de.nes the type of .nite Boolean lists that are either . or fully de.ned. \nHappily we do not need to adapt our de.nition of contract combinators. As usual we have pSNil :: Contract \nSListBool pSNil SNil = Just SNil pSNil (SCons b bs) = Nothing pSCons :: Contract Bool -> Contract SListBool \n-> Contract SListBool pSCons c cs SNil = Nothing pSCons c cs (SCons b bs) = Just (SCons (assert c b) \n(assert cs bs)) A contract traverses the strict list and builds a new strict list. Thus demanding the \ntop data constructor of a contracted strict list automatically forces checking the whole list. The result \nwill be either a contract violation (.) or the whole list. So on strict data types lazy contracts behave \nlike eager contracts. It would be possible to de.ne more expressive contract combinators for data types \nwith strictness .ags, that, for example, ensure that a list is ordered; but because strictness .ags are \nrarely used in Haskell programs, such an extension does not seem worthwhile. In the de.nition of SListBool \nall constructor arguments are strict and the only other types used are .at types. In such a case the \ndata type is actually a .at type. We can declare it an instance of the class Flat and use expressive \nprop contracts. 5 They are not equal, because list . = .,but list . = Just .. However, in the context \nof a contract with assert they always yield the same result.   8. Related Work This paper builds .rmly \non three sets of previous work: Findler and Felleisen s work on eager contracts for higher-order functions \n[12], Hinze, Jeuring and L\u00a8oh s work on typed contracts for func\u00adtional programming, and our own previous \nwork on lazy functional contracts. Eager Higher-Order Contracts Findler and Felleisen s paper on contracts \nfor higher-order functions [12] made contracts popular for eager functional programming languages. All \ninteresting properties of functional values, which are passed around by higher-order func\u00adtions, are \nundecidable; it is impossible to monitor a function con\u00adtract for all argument-result-pairs. However, \nFindler and Felleisen realised that it is suf.cient to monitor both pre-and post-condition of a functional \nvalue only when this function is applied. The result\u00ading contract system is sound. The second major contribution \nof that paper is a system for correctly attributing blame in case of contract violation and its implementation. \nWe easily added blaming to our lazy contract library. However, additionally our contracts report a witness, \na partial value, that caused a contract violation. Findler and Felleisen s contract system also provides \ndependent function contracts, where the contract for the function codomain can use the actual argument \nvalue. Such dependent contracts are more expressive but easily change a non-strict function into a strict \nfunction; hence our lazy contract combinators do not provide them. Subsequent work [11, 13] stresses \nthat contracts are projections and thus they can be implemented in a simple, modular and ef.cient way. \nOur .rst implementation of Figure 2 copies that work and our full implementation with disjunction is \nan extended variant. The papers do not discuss algebraic data types, because in strict languages these \ndomains are .at and hence contracts for algebraic data types are predicates like for other .at types. \nConsequently disjunction is not considered either. Because of the universality of predicate contracts \nin strict and dynamically typed functional languages, type-directed contracts such as list are also of \nlittle interest. Although disjunction is not discussed in the papers, the contract system of Racket does \nprovide a disjunctive contract combinator [14, Version 5.2.1] [15]. To support disjunction, a Racket \ncontract for type a contains both a function of type a->a and a function of type a -> Bool. Together \nthey are used similarly to our type a -> Maybe a. In particular, the disjunctive combinator applies the \na -> Bool functions of all its direct sub-contracts, checks that at most one of the results is True (otherwise \nit fails) and then applies the corresponding sub-contract further [10]. So disjunction behaves similarly \nto |> but is not sequential. Blume et al. proposed and studied several semantic models of eager higher-order \ncontracts [1, 11, 13]. To prove soundness, the de.nition of contracts is .rst restricted, to avoid e.g. \nhaving a con\u00adtract .. Later, recursive contracts are added to regain expressiv\u00adity. In a discussion of \nthe most permissive contract, true, Findler and Blume point out that the contract true, to be the most \npermis\u00adsive contract, should always report contract violation and blame the client. However, they also \nnote that such a contract would be use\u00adless in practice. In contrast, our true, which cannot be violated, \nis very useful to leave parts of a contract unconstrained. Similarly, the least permissive contract should \nalways blame the server, but we demonstrated in Section 5.1 that our de.nition of false,which always \nblames the client, is more useful. As a consequence in our li\u00adbrary false = prop (const False) does not \nhold for .at types whereas true = prop (const True) does. Typed Contracts for Functional Programming \nHinze, Jeuring and L\u00a8oh [19] transferred contracts for higher-order functions to the statically typed \nlanguage Haskell. Hence they proposed con\u00adtract combinators with parametrically polymorphic types; we \nhave adopted all of them except for dependent contracts. Typed con\u00adtracts also emphasis type-directed \ncontract combinators such as list. However, the work disregards the lazy semantics of Haskell, de.ning \ncontracts with a seemingly random mixture of eager and lazy monitoring. Predicate contracts can be applied \nto expressions of all types, not just .at types, thus breaking laziness. However, these predicate contracts \nare required for expressing many interest\u00ading properties, because a type-directed contract combinator \nsuch as list can only express a uniform property over all list elements: our pattern contracts and disjunction \nare missing. Contracts are not projections, because generally they are not idempotent. Idempotence is \nlost because of the eagerness of pred\u00adicate contracts. Hinze et al. make the point that if contract con\u00adjunction \n&#38; was commutative, then idempotence would be a simple consequence. However, our lazy contracts demonstrate \nthat com\u00admutativity of conjunction is not necessary for idempotence; we can have the latter without the \nformer. Hinze et al. also provide an interesting technique for provid\u00ading more informative error messages \nthan standard blaming. Their library provides several source locations as explanation of a sin\u00adgle violated \ncontract. However, these sets of source locations are still hard to understand for a programmer and the \nsystem requires a source code transformation to insert source locations into the pro\u00adgram. Otherwise \nthe programmer would have to do this substantial work. Lazy Contracts for Functional Languages Lazy contracts \nwere .rst discussed and several implementations presented in 2004 [5]. That paper makes the point that \nwhile eager contracts must be True, lazy contracts must not be False. This means that uneval\u00aduated parts \nof a data structure can never violate a lazy contract. The paper uses predicates on values of all types \nand hence, de\u00adspite some technical tricks using concurrency, the contracts are lazy but neither idempotent \nnor prompt. The paper itself gives exam\u00adples of where contract violations are noticed too late. This \nprob\u00adlem was later recti.ed [3, 4]. Both these papers implement lazy assertions as libraries that require \nonly the commonly provided non-pure function unsafePerformIO, which performs side effects within a purely \nfunctional context. The .rst lazy and idempotent implementation [4] uses patterns contracts similar to \nthose in this paper to express contracts over algebraic data types. However, a non-deterministic implementation \nof disjunction leads to seman\u00adtic problems. Later [3] provided a more user-friendly language for expressing \ncontracts and improved the internal structure of the im\u00adplementation, but the implementation principles \nwere identical and hence the non-deterministic disjunction remained. A semantic investigation [2] developed \ncontracts that are pure and implementable within the functional language. However, for every algebraic \ndata type its contracts requires a different imple\u00admentation type. Thus disjunction is not a parametrically \npolymor\u00adphic combinator but requires a class context. Furthermore, the im\u00adplementations of some combinators \nare large and complex. Dis\u00adjunction is more powerful than in the lazy contracts described in the present \npaper, for example assert (pCons nat pNil |> pCons true pNil) [-3] =assert (pCons (nat |> true) (pNil \n|> pNil)) =[-3] but this additional expressibility does not seem to be needed in practice. Comparing \nContracts Degen, Thiemann and Wehr [7, 8] classify existing contract systems for Haskell as eager (straight \ntranslation of [12]), semi-eager [19] and lazy [3 5]. They check whether the systems meet their desirable \nproperties of meaning preservation and completeness. Each contract system meets at most one of these \nproperties. The authors show that it is impossible to meet both properties. Our lazy contracts are meaning \npreserving but not complete. The notion of completeness seems to be biased towards a strict semantics, \ncontradicting the principle that unevaluated parts can never violate a lazy contract. Our lazy contracts \nhave limited expressibility, but they have a clear semantics.  Generic Programming We use Template Haskell \nto derive pat\u00adtern contracts and to enable the assertion function to determine its own location in the \nsource code [23]. The derivation of pattern con\u00adtracts is an instance of generic programming. Many generic \npro\u00adgramming systems have been proposed and even been implemented for Haskell [17, 18, 20, 21]. All of \nthese have two disadvantages that make them unsuitable for being used for our pattern contracts: First, \nthey introduce one or more classes that will then appear in the type of every derived pattern contract. \nThus pattern contracts will not be parametrically polymorphic. Second, they consider func\u00adtions as second \nclass values. That means that either they can only generically de.ne code for types that do not involve \nfunction types at all, or they can recognise a functional value within an algebraic data type, but cannot \ndo anything with it, that is, apply any trans\u00adformation to it. Template Haskell provides few static guarantees \nand thus re\u00adquires us to ascertain that our contract library will derive typeable and correct code for \nany data constructor. However, Template Haskell provides all the functionalities needed in the contract \nli\u00adbrary.  9. Conclusions and Future Work This paper describes the design of a practical contract library \nfor lazy typed functional languages and its implementation for Haskell. The library meets many essential \ncriteria, such as combinators with simple parametric types, a lazy semantics, a rich algebra of properties, \ninformative exceptions in case of contract violation and automatic code generation to make it easy to \nuse. Interestingly the resulting contract system reminds strongly of a subtyping system, especially with \na de.nition of sub-contracts/types for algebraic data types that looks very similar to the actual type \nde.nition of algebraic data types. De.ning subtypes of algebraic data types is also where we see the \nmain application area of the con\u00adtract system. Many programs require several variants of some big algebraic \ndata types. In practice programmers then simply ignore the subtyping and de.ne a single algebraic data \ntype that encom\u00adpasses all variants, because they want to reuse functions that work on several subtypes \nand have the .exibility to exchange some code without having to change between numerous similar but separate \ndata types. The classical example is a compiler: it consists of a long sequence of passes, each of which \nworks with a slightly differently structured abstract syntax tree, In practice, subtle differences are \nignored and only a few different abstract syntax tree structures are used in one compiler. Lazy contracts \nprovide a new solution. Our next step is to develop the algebra of contract combinators further and thus \nalso prove our claim that these contracts are idem\u00adpotent. The main current shortcoming and thus biggest \nchallenge for future development of the contract library is its lack of a depen\u00addent function contract \ncombinator that allows using the function argument in the post-condition. We can de.ne (>>->) :: Contract \na -> (a -> Contract b) -> Contract (a -> b) pre >>-> post = \\f -> Just (\\x -> f seq (let y = assert pre \nx in assert (post y) (f y))) and use it for example in contractTake :: Int -> [a] -> [a] contractTake \n= assert (nat >>-> \\n -> lengthAtLeast n >-> listOfLength n) take It is easy to extend this picky implementation \nto use indy moni\u00adtoring [9], which may blame the contract itself, not just the server or the client. \nHowever, >>-> is not a lazy contract combinator; the post-condition may force evaluation of too much \nof the function argument and thus the contract may change the semantics of the program. A de.nition of \na lazy dependent function combinator is still an open problem. Meanwhile the existing contract library \ncan be used in practice.  Acknowledgments I thank Simon Thompson and Stefan Kahrs for useful advice \non early versions of this work and the anonymous ICFP reviewers and Robby Findler for their detailed \ncomments.  References [1] M. Blume and D. McAllester. Sound and complete models of contracts. J. Funct. \nProgram., 16(4-5):375 414, 2006. [2] O. Chitil. A semantics for lazy assertions. In Proceedings of the \n20th ACM SIGPLAN workshop on Partial evaluation and program manipulation, PEPM 2011, pages 141 150, January \n2011. [3] O. Chitil and F. Huch. Monadic, prompt lazy assertions in Haskell. In APLAS 2007, LNCS 4807, \npages 38 53, 2007. [4] O. Chitil and F. Huch. A pattern logic for prompt lazy assertions in Haskell. \nIn Implementation and Application of Functional Languages: 18th International Workshop, IFL 2006, LNCS \n4449, 2007. [5] O. Chitil, D. McNeill, and C. Runciman. Lazy assertions. In Im\u00adplementation of Functional \nLanguages: 15th International Workshop, IFL 2003, LNCS 3145, pages 1 19. Springer, November 2004. [6] \nN. A. Danielsson and P. Jansson. Chasing bottoms, a case study in program veri.cation in the presence \nof partial and in.nite values. In D. Kozen, editor, Proceedings of the 7th International Conference on \nMathematics of Program Construction, MPC 2004, LNCS 3125, pages 85 109. Springer-Verlag, July 2004. [7] \nM. Degen, P. Thiemann, and S. Wehr. True lies: Lazy contracts for lazy languages (faithfulness is better \nthan laziness). In 4. Arbeitstagung Programmiersprachen (ATPS 09),L\u00a8 ubeck, Germany, October 2009. [8] \nM. Degen, P. Thiemann, and S. Wehr. The interaction of contracts and laziness. In Proceedings of the \nACM SIGPLAN 2012 workshop on Partial evaluation and program manipulation, PEPM 12, pages 97 106, 2012. \n[9] C. Dimoulas, R. B. Findler, C. Flanagan, and M. Felleisen. Correct blame for contracts: no more scapegoating. \nIn Proceedings of the 38th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages, \nPOPL 11, pages 215 226, 2011. [10] R. B. Findler. Comparison with Racket s contract system. Personal \ncommunication, 2012. [11] R. B. Findler and M. Blume. Contracts as pairs of projections. In International \nSymposium on Functional and Logic Programming (FLOPS), LNCS 3945, pages 226 241, 2006. [12] R. B. Findler \nand M. Felleisen. Contracts for higher-order functions. In ICFP 02: Proceedings of the seventh ACM SIGPLAN \ninternational conference on Functional programming, pages 48 59, 2002. [13] R. B. Findler, M. Blume, \nand M. Felleisen. An investigation of contracts as projections. Technical report, University of Chicago \nComputer Science Department, 2004. TR-2004-02. [14] M. Flatt and PLT. Reference: Racket. Technical Report \nPLT-TR\u00ad2010-1, PLT Inc., 2010. http://docs.racket-lang.org/trl/. [15] M. Flatt, R. B. Findler, and PLT. \nThe Racket guide. http://docs.racket-lang.org/guide/index.html, 2012.  [16] A. Gill. Debugging Haskell \nby observing intermediate datastructures. Electronic Notes in Theoretical Computer Science, 41(1), 2001. \n(Proc. 2000 ACM SIGPLAN Haskell Workshop). [17] R. Hinze. Generics for the masses. J. Funct. Program., \n16(4-5): 451 483, July 2006. [18] R. Hinze and A. L\u00a8oh. Generic programming in 3d. Sci. Comput. Program., \n74(8):590 628, June 2009. [19] R. Hinze, J. Jeuring, and A. L\u00a8oh. Typed contracts for functional programming. \nIn Proceedings of the 8th International Symposium on Functional and Logic Programming, FLOPS 2006, LNCS \n3945, pages 208 225, 2006. [20] R. L\u00a8ammel and S. P. Jones. Scrap your boilerplate: a practical design \npattern for generic programming. In Proceedings of the 2003 ACM SIGPLAN international workshop on Types \nin languages design and implementation, TLDI 03, pages 26 37, 2003. [21] R. L\u00a8ammel and S. P. Jones. \nScrap more boilerplate: re.ection, zips, and generalised casts. In Proceedings of the ninth ACM SIGPLAN \ninternational conference on Functional programming, ICFP 04, pages 244 255, 2004. [22] S. Peyton Jones, \nA. Reid, T. Hoare, S. Marlow, and F. Henderson. A semantics for imprecise exceptions. In Proceedings \nof the ACM SIGPLAN 99 Conference on Programming Language Design and Implementation, pages 25 36, 1999. \n[23] T. Sheard and S. P. Jones. Template meta-programming for Haskell. In Proceedings of the 2002 ACM \nSIGPLAN workshop on Haskell, Haskell 02, pages 1 16, 2002.  \n\t\t\t", "proc_id": "2364527", "abstract": "<p>Until now there has been no support for specifying and enforcing contracts within a lazy functional program. That is a shame, because contracts consist of pre- and post-conditions for functions that go beyond the standard static types. This paper presents the design and implementation of a small, easy-to-use, purely functional contract library for Haskell, which, when a contract is violated, also provides more useful information than the classical blaming of one contract partner. From now on lazy functional languages can profit from the assurances in the development of correct programs that contracts provide.</p>", "authors": [{"name": "Olaf Chitil", "author_profile_id": "81100243192", "affiliation": "University of Kent, Canterbury, United Kingdom", "person_id": "P3804309", "email_address": "O.Chitil@kent.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2364527.2364539", "year": "2012", "article_id": "2364539", "conference": "ICFP", "title": "Practical typed lazy contracts", "url": "http://dl.acm.org/citation.cfm?id=2364539"}