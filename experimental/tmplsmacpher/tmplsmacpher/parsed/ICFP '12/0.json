{"article_publication_date": "09-09-2012", "fulltext": "\n Agda-curious? An Exploration of Programming with Dependent Types Conor McBride University of Strathclyde \n conor.mcbride@strath.ac.uk Abstract I explore programming with the dependently typed functional language, \nAGDA. I present the progress which AGDA has made, demonstrate its usage in a small development, re.ect \ncritically on the state of the art, and speculate about the way ahead. I do not seek to persuade you \nto adopt AGDA as your primary tool for systems development, but argue that AGDA stimulates new useful \nways to think about programming problems and deserves not just curiosity but interest, support and contribution. \nCategories and Subject Descriptors D.1.1 [Programming Tech\u00adniques]: Applicative (Functional) Programming; \nD.3.3 [Language Constructs and Features]: Data types and structures General Terms Design, Languages, \nTheory Keywords Dependent types 1. Introduction AGDA (the Swedish form of Agatha) was implemented around \nthe millenium by Catarina Coquand and is now in its second incarna\u00adtion, implemented by Ulf Norell as \npart of his PhD [Norell, 2007]. Engineered to resemble HASKELL where convenient, it has gained quite \nsome traction in the FP community, at least amongst enthusi\u00adasts for the typed frontier. I can recommend \nAGDA tutorials by Norell [2008] and Bove and Dybjer [2008], but my focus here is more to investigate \nthe issues which AGDA provokes, why you might become interested in them, and some of the ways in which \nthere is still considerable work to be done: key questions for the Agda-curious. 2. What s the same? \nAt heart, AGDA is a typed .-calculus extended with datatypes and pattern matching, very much in the mode \nof ML and HASKELL. It has a module system which sits nearer the package management of HASKELL than the \nfull blown functors of ML. Whether you prefer call-by-value or something lazier, the outcome of evaluating \nan expression will be what you expect. Milner s variable rule for specialising polymorphic types remains \nthe means to avoid type-clutter Damas and Milner [1982]. Schematic arguments are routinely omitted at \nusage sites and inferred by uni.cation. AGDA treats types as values. However, just like all the depen\u00addent \ntype theories in the Martin-L\u00f6f tradition, there is no type\u00adcase , so it is perfectly possible to erase \ntypes for run-time. We can compile by extraction to an existing functional language with its typechecker \ngagged, or by standard supercombinator approaches. 3. What s different? By allowing expressions in types, \nidenti.ed up to computation, AGDA gains considerable powers of precision and abstraction. However, the \nprimary mode of precision is not in the propositions\u00adas-types tradition embodied by COQ. Instead of using \ndependent types to build logical superstructure for ordinary datatypes and functions, an AGDA programmer \nusually prefers to design indexed datatypes which internalize key invariants, improving the basic hy\u00adgiene \nof programming without recourse to proof. The gap with current FP languages is decreasing as GADTs gain \nadoption and more interesting kinds of index [Yorgey et al., 2012]. AGDA s typechecker can double as \na proof validator, supporting integrated development of programs and proofs, the latter being programs \none prefers not to run. However, the point is to shift the workload between the two, increasing the reach \nof typechecking the program as a broadly applicable but shallow formal method. The ability to capture \nrequirements by indexing datatypes creates a new design space which calls for fresh insight. AGDA is \na total language with codata, as advocated by Turner [2004]. Head-normalization terminates, so the typechecker \ncan boldly compute expressions in types, but in.nitary processes such as operating systems and Turing \nmachines can still be presented in a demand-driven way. Totality thus places no restriction on the expressable \nprocesses but rather enhances trust in their status: a type is a guarantee of a meaningful value. Termination \nof recursion and productivity of corecursion are checked by an oracle based on the size-change principle \n[Abel and Altenkirch, 2002, Lee et al., 2001]. AGDA deviates critically from the ML tradition by abandoning \ntype inference in favour of a bidirectional mode of type checking: types come .rst. Milner s let rule \nrestricts type schemes to be machine-guessable: for the price of declaring types for de.nitions, we get \nto say what we really mean. Declared types push inward, resolving overloading and .xing types of variables. \nA type is an input also to the editing process, with information for missing components, mechanical splitting \nof patterns into cases, and type\u00addriven search for candidate code. Types may be static , but they help \nus make programs, not just error messages. 4. What s it like? Copyright is held by the author/owner(s). \nICFP 12, September 9 15, 2012, Copenhagen, Denmark. I illustrate AGDA, and its indexing design space, \nby implementing ACM 978-1-4503-1054-3/12/09. a very small stack machine bytecode with two instructions. \n data Inst : Set where PUSH : (v : N ) . Inst ADD : Inst A .rst attempt to interpret a list of instructions \nas a function from initial to .nal stacks runs into the problem of under.ow. run : List Inst . List N \n. List N run [] vs = vs run (PUSH v , is) vs = run is (v, vs) run (ADD , is)[] = ? run (ADD , is)(v, \n[]) = ? run (ADD , is)(v2 , v1 , vs)= run is (v1 + v2 , vs) No sensible compiler will ever deploy an \nADD instruction for a short stack, so we should not need to consider the problem cases marked ?. We can \nnail stack usage down, indexing our instructions with before and after stack heights [McKinna and Wright, \n2006]. data Inst : N . N . Set where PUSH : .{h}. (v : N ) . Inst h (1 + h) ADD : .{h}. Inst (2 + h)(1 \n+ h) Code becomes a Path of instructions with height indices .tting domino-style. A stack is a height-indexed \nVector, and run acquires more precise type which enables an easy de.nition. run : .{ij}. Path Inst ij \n. Vec N i . Vec N j run [] vs = vs run (PUSH v , is) vs = run is (v, vs) run (ADD , is)(v2 , v1 , vs)= \nrun is (v1 + v2 , vs) No under.ow is no longer a theorem to prove: it is basic. Moreover, we can index \nby the stack contents, paired with and dependent on the stack height. data InstC : S N (Vec N ) . S N \n(Vec N ) . Set where PUSH : .{h vs}. (v : N ) . InstC ( h , vs)(1 + h, (v , vs)) ADD : .{hv1 v2 vs}. \nInstC (2 + h , (v2 , v1 , vs)) (1 + h, (v1 + v2 , vs)) The InstC type can be seen as the systematic ornamentation \nof Inst by the behaviour of run. Given an expression type Expr with a reference interpreter [_], a compiler \nshould now map an expression e to a code sequence which effectively pushes [e]. compile : .{h}{vs : Vec \nN h}. (e : Expr) . Path InstC (h, vs)(1 + h, ([e], vs)) It may turn out that indexing to this detail \nadmits compile with not much more effort than at a simpler type, but nothing to prove, or else the detail \nmight make the job too complex for the reward. This negotiation is what makes AGDA programming a new \nand fascinating skill. 5. What s the catch? As with anything which requires a new skill, the main catch \nis that you need to undergo learning. The familiar-looking syntax risks stimulating misplaced entitlement, \nand thence frustration. More of the translation from design to execution is machine-mediated, which necessitates \na clarity many of us guiltily strive to avoid. A sad omission, therefore, is machine support for rethinking \nfailed programming attempts. It is thrilling to work from good de.nitions to beautiful code, but that \nhappens only in the last cycle of a turgid process of getting stuck and propagating improvements. Datatype \nindexing is not only the key contribution but the key new source of misery. This will remain true while \ndistinct datatype declarations remain islands unconnected by exposition of common structure. Dependent \ntypes can express .rst class descriptions of datatypes, thus supporting abstraction over indexing schemes, \nbut we await a language design which breaks the mould of separate generative datatype declarations and \nseizes this opportunity. To deliver proven code, we also face the issue that AGDA is a much more a FP \nlanguage than a theorem prover: writing proof terms is rather low-level and far from perspicuous. I agree \nwith Adam Chlipala s warning that the certifying programmer can cope much more readily with weak programming \ntools than weak proof tools. If AGDA is to compete in COQ s market, it will need an investment of fresh \nthought about how to pick up the pieces when typechecking delivers less than the theorem required. Meanwhile, \nif AGDA is to compete in HASKELL s market, it will need a much more comprehensive treatment of the stuff \nof real life , including a good compiler, primitive numeric and character types, and a broad library. \nThese things will come with time and effort, but there is also a clear design challenge to face: how \nshall we program with computational effects? 6. What s my point? We should relish the opportunity to \nthink afresh about certifying program properties in a setting where it is feasible to internalize some \nof those properties in the types of data and functions and en\u00adsure them as part of the basic hygiene \nof typechecking. The fun of AGDA programming comes from the theorems you do not need to prove: it is \nthrilling to be drawn towards the right program by a pre\u00adcise type. FP has already seen one generation \nof languages evolve from poetry to power-tools. In the next generation, power will come from keeping \nthe promises that let programs play together. AGDA is not yet the next power-tool, but it offers us new \nand lasting lessons about programs which keep promises. Let us learn. References A. Abel and T. Altenkirch. \nA predicative analysis of structural recursion. J. Funct. Program., 12(1):1 41, 2002. A. Bove and P. \nDybjer. Dependent types at work. In A. Bove, L. S. Barbosa, A. Pardo, and J. S. Pinto, editors, LerNet \nALFA Summer School, volume 5520 of Lecture Notes in Computer Science, pages 57 99. Springer, 2008. ISBN \n978-3-642-03152-6. L. Damas and R. Milner. Principal type-schemes for functional programs. In R. A. DeMillo, \neditor, POPL, pages 207 212. ACM Press, 1982. ISBN 0-89791-065-6. C. S. Lee, N. D. Jones, and A. M. Ben-Amram. \nThe size-change principle for program termination. In C. Hankin and D. Schmidt, editors, POPL, pages \n81 92. ACM, 2001. ISBN 1-58113-336-7. J. McKinna and J. Wright. A type-correct, stack-safe, provably \ncor\u00adrect, expression compiler in epigram. Submitted to the Journal of Functional Programming, 2006. U. \nNorell. Towards a Practical Programming Language based on Dependent Type Theory. PhD thesis, Chalmers \nUniversity of Technology, 2007. U. Norell. Dependently Typed Programming in Agda. In P. W. M. Koopman, \nR. Plasmeijer, and S. D. Swierstra, editors, Advanced Functional Programming, volume 5832 of LNCS, pages \n230 266. Springer, 2008. D. A. Turner. Total functional programming. J. UCS, 10(7):751 768, 2004. B. \nA. Yorgey, S. Weirich, J. Cretin, S. L. P. Jones, D. Vytiniotis, and J. P. Magalh\u00e3es. Giving haskell \na promotion. In B. C. Pierce, editor, TLDI, pages 53 66. ACM, 2012. ISBN 978-1\u00ad4503-1120-5.  \n\t\t\t", "proc_id": "2364527", "abstract": "<p>I explore programming with the dependently typed functional language, AGDA. I present the progress which AGDA has made, demonstrate its usage in a small development, reflect critically on the state of the art, and speculate about the way ahead. I do not seek to persuade you to adopt AGDA as your primary tool for systems development, but argue that AGDA stimulates new useful ways to think about programming problems and deserves not just curiosity but interest, support and contribution.</p>", "authors": [{"name": "Conor Thomas McBride", "author_profile_id": "81548019889", "affiliation": "University of Strathclyde, Glasgow, United Kingdom", "person_id": "P3804292", "email_address": "conor.mcbride@strath.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2364527.2364529", "year": "2012", "article_id": "2364529", "conference": "ICFP", "title": "Agda-curious?: an exploration of programming with dependent types", "url": "http://dl.acm.org/citation.cfm?id=2364529"}