{"article_publication_date": "09-09-2012", "fulltext": "\n A Traversal-based Algorithm for Higher-Order Model Checking Robin P. Neatherway C.-H. Luke Ong Steven \nJ. Ramsay University of Oxford University of Oxford University of Oxford robin.neatherway@cs.ox.ac.uk \nluke.ong@cs.ox.ac.uk steven.ramsay@cs.ox.ac.uk Abstract Higher-order model checking the model checking \nof trees gen\u00aderated by higher-order recursion schemes (HORS) is a natural generalisation of .nite-state \nand pushdown model checking. Re\u00adcent work has shown that it can serve as a basis for software model checking \nfor functional languages such as ML and Haskell. In this paper, we introduce higher-order recursion schemes \nwith cases (HORSC), which extend HORS with a de.nition-by-cases construct (to express program branching \nbased on data) and non\u00addeterminism (to express abstractions of behaviours). This paper is a study of \nthe universal HORSC model checking problem for de\u00adterministic trivial automata: does the automaton accept \nevery tree in the tree language generated by the given HORSC? We .rst char\u00adacterise the model checking \nproblem by an intersection type sys\u00adtem extended with a carefully restricted form of union types. We \nthen present an algorithm for deciding the model checking prob\u00adlem, which is based on the notion of traversals \ninduced by the fully abstract game semantics of these schemes, but presented as a goal-directed construction \nof derivations in the intersection and union type system. We view HORSC model checking as a suitable \nbackend engine for an approach to verifying functional programs. We have implemented the algorithm in \na tool called TRAVMC, and demonstrated its effectiveness on a test suite of programs, including abstract \nmodels of functional programs obtained via an abstraction\u00adre.nement procedure from pattern-matching recursion \nschemes. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; \nF.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams General \nTerms Algorithms, Veri.cation Keywords Model-checking, Higher-order Programs 1. Introduction Over the \npast decade, model checking and its allied methods have been applied to program veri.cation with great \neffect. For Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n12, September 9 15, 2012, Copenhagen, Denmark. Copyright c &#38;#169; 2012 ACM 978-1-4503-1054-3/12/09. \n. . $10.00 .rst-order, imperative programs, highly optimised .nite-state and pushdown model checkers \n(such as SLAM [2] and BLAST [3]) have been successfully applied to bug-.nding, property check\u00ading and \ntest case generation. Building on theoretical results on the model checking of higher-order recursion \nschemes (HORS) [6, 16], Kobayashi [8] has sparked a growing interest in the de\u00ad velopment of an analogous \nmodel checking framework for higher\u00adorder, functional programs. A HORS is a kind of higher-order grammar, \nwhich can be viewed as a mechanism for generating a possibly-in.nite, ranked tree. HORS model checking \nis concerned with the problem of deciding whether the tree generated by a given HORS satis.es a given \nproperty and, when the property is expressed by a formula of the modal mu\u00adcalculus (equivalently, an \nalternating parity tree automaton), then the problem is known to be decidable [16]. Since they can equally \nwell be viewed as a closed, ground-type term of the simply-typed lambda calculus with recursion and uninterpreted \n.rst-order con\u00adstants, HORS are a natural home for models of higher-order com\u00adputation. Indeed, HORS \nmodel checking is a smooth generalisation of .nite-state and pushdown model checking (.nite-state programs \nand pushdown systems/Boolean programs are captured by order-0 and order-1 HORS respectively). HORS model \nchecking is, inherently, an extremely complex prob\u00adlem. Ong [16] has shown that the modal mu-calculus \nmodel checking problem for order-n recursion schemes is n-EXPTIME (i.e. tower of exponentials of height \nn) complete. Even for the purposes of safety veri.cation (model checking against properties expressible \nas deterministic trivial tree automata (DTT)), the prob\u00adlem is (n - 1)-EXPTIME complete [11], which is \nstill formidably complex. Hence, the feasibility of HORS model checking as a veri\u00ad.cation technology \nis predicated upon the ability to design decision procedures that hit the worst-case complexity only \nin pathological cases. That such algorithms are possible was demonstrated by Kobayashi s hybrid algorithm, \npresented in [7], which solves the safety veri.\u00ad cation problem. In an attempt to avoid the hyper-exponential \nbot\u00adtleneck, the algorithm closely analyses the actual behaviour of the HORS as it is evaluated, generating \nthe ranked tree. The hybrid algorithm builds a graph to record the trace of this computational behaviour \nand from the graph derives guesses at proofs which wit\u00adness the satisfaction of the property. The algorithm \nis implemented in the TRECS tool [9], which has been shown to perform remark\u00ad ably well in a variety \nof applications. However, whilst HORS allow for the expression of higher-order behaviour very naturally, \nthey lack two important features which, we believe, are highly desirable in a convenient abstract model \nof functional programs. The .rst is a case analysis construct, with which one can express program branching \nbased on data; the sec\u00adond is non-determinism1, with which one can express abstractions of behaviour. \nIn this paper, we present a class of structures called higher-order recursion schemes with cases (HORSC) \nwhich extend HORS in both these directions, allowing grammar rules to be non\u00addeterministic and incorporating \na .nitary case analysis construct.  Example 1. The Risers program from Mitchell and Runciman [14] provides \nan interesting example of a program with partial pattern matching that cannot crash: risers [] = [] risers \n[x] = [[x]] risers (x : y : etc)= if x = y then (x : s): ss else [x]:(s : ss) where (s : ss)= risers \n(y : etc) A natural abstraction that might be selected by an automated ap\u00adproach is to the .nite domain \n{Nil, Cons1, Cons2} (for lists of length 0, 1 or more and 2 or more respectively). Using non\u00addeterministic \nchoice for the if statement and a case construct oper\u00adating on the .nite domain yields: risers xs . case(xs, \nNil, Cons1, ifthenelse) ifthenelse . cons (destruct (risers Cons1)) ifthenelse . cons (cons (destruct \n(risers Cons1))) destruct xs . case(xs, error, Nil, Cons1) destruct xs . case(xs, error, Nil, Cons2) \ncons xs . case(xs, Cons1, Cons2, Cons2) The pattern match error is preserved it occurs in the case where \nan empty list is destructed under the assumption that it has length at least one. Furthermore, the safety \nof the original program has been preserved in the abstraction to HORSC-like syntax. Our central contribution \nis an algorithm to decide the model check\u00ading problem of HORSC against DTT. Our algorithm is inspired \nby the game-semantic analysis (in particular, the notion of traversals) behind the original decidability \nproof of Ong [16] for the model checking problem for HORS. The technical machinery of game se\u00admantics \nis not required for this algorithm, but here we offer a brief overview for the interested reader. Game \nsemantics [5] is a way of giving meanings to programs by viewing computation as a game between Proponent \n(whose point of view is the program) and Op\u00adponent (whose point of view is the program context). The \ntype of a program M : . is interpreted as an arena [ .] , and the program is in\u00adterpreted as a Proponent \nstrategy, [ M] , for playing in the arena [ .] . Inspired by the success of the hybrid algorithm, we \naim to search for proofs in a way which is guided by an analysis of the behaviour of the HORS but, rather \nthan evaluating the HORS and analysing its traces, we analyse the traversal induced by its game semantics. \nThe standard method to evaluate such a .-term is by \u00df-reduction but, because of the nature of substitution, \n\u00df-reduction deforms the syntactic structure of the term and information about the computa\u00adtion that took \nplace can be lost in the reduct. The game semantics of the simply-typed .-calculus gives rise to a method \nof evaluat\u00ading a term M by traversing its computation tree, .(M), which is a slightly souped-up version \nof its abstract syntax tree. In contrast, evaluation by traversal leaves the structure of the term in \nquestion intact. Example 2 (Traversals over recursion scheme G1). Let a : o, b : o . o and c : o . o \n. o be terminal symbols. Consider the recursion scheme G1 given by the following recursive de.nition \nof 1 In fact, there is no requirement for HORS to be purely deterministic by de.nition, but the type \ntheory on which the model checking tools are built has only been properly developed for deterministic \nHORS. Figure 1. Traversals in .(G1) (Example 2) functions, S : o and F : o . o, viewed as rewrite rules: \nS . Fa cFx . cx (F (bx)) a c b c . . a . Unfolding from S, we have S . Fa . ca (F (ba)) . ca (c (ba)(F \n(b (ba)))) . \u00b7 \u00b7\u00b7 thus generating the in.nite term ca (c (ba)(c (b (ba))) (\u00b7\u00b7\u00b7 )). De.ne the tree generated \nby G1, [ G1] , to be the abstract syntax tree of the in.nite term, as shown above (on the right). The \ncomputation tree .(G1) is the underlying tree in Figure 1 whose nodes are labelled by symbols ., .x, \n@, a, b and c. We will not give the rules that de.ne the traversals over a computation tree. Instead, \nwe illustrate how traversals compute the paths in [ G1] that are labelled c \u00b7 a and c \u00b7 c \u00b7 b \u00b7 a respectively. \nThe path c \u00b7 a in [ G1] corresponding to the traversal over .(G1) from the root to (1), jumping to the \nsegment that starts from (1), namely, .\u00b7@\u00b7.x\u00b7c\u00b7.\u00b7 x\u00b7.\u00b7a. The path c\u00b7c\u00b7b\u00b7a in [ G1] corresponding to the \ntraversal over .(G1) from the root to (2), jumping to the segment that starts from (2) and which ends \nat (3), and jumping to the segment that starts from (3); namely, . \u00b7 @ \u00b7 .x \u00b7 c \u00b7 . \u00b7 @ \u00b7 .x \u00b7 c \u00b7 . \n\u00b7 x \u00b7 . \u00b7 b \u00b7 . \u00b7 x \u00b7 . \u00b7 a. Let S= { a, b, c }. Note that the S-projection of the two traversals are \nthe two paths in [ G1] . An insight of Kobayashi, which has been instrumental in the design of practical \nmodel checking algorithms, is that the HORS model checking problem can be characterised as a problem \nof type infer\u00adence in a certain intersection type system. By this characterisation, searching for a proof \nthat a given HORS satis.es a given property is reduced to searching for a typing for the given HORS in \nthe type system induced by the given property. We show that the HORSC model checking problem also has \nan elegant, type-theoretic charac\u00adterisation, but that the combination of higher-order functions, case\u00adanalysis \nand non-determinism lead one to consider a system of in\u00adtersection and union types. Since we want to \nminimize any increase to the size of the search space of typings (which, by the characteri\u00adsation, act \nas potential witnesses to property satisfaction), we have carefully constructed a type system in which \nunion types can oc\u00adcur only in a restricted fashion. In particular, unions are only ever allowed over \na subset of the ground types.  In light of this type-theoretic characterisation, we present our model \nchecking algorithm as a goal-directed construction of a typ\u00ading derivation. (For reasons of exposition, \nwe suppress the game\u00adsemantic origin and interpretation of the algorithm, but present a formal account \nof the correspondence in the long version of the paper) The ultimate aim is to show that the start symbol \nS of the HORS is typable by a type representing the initial state of the prop\u00aderty automaton q0, so the \ninitial goal is to .nd a typing environment G such that G f S : q0. In our type system, we are allowed \nto take for G the environment that consists of the single typing S : q0, but only if we are able to show \nthat the de.nition of S (by a produc\u00adtion rule in the HORS) respects this typing. Hence, following the \ntype system, the algorithm is obliged to spawn a subgoal (itself a typing judgement) according to the \nde.nition of S. In general, to solve a goal the algorithm simply attempts to construct a typing derivation \naccording to the rules of the type system, but, where this construction involves making additional assumptions \n(such as in the typing derivation for S : q0 as above) an obligation is incurred to justify these assumptions. \nSince discharging such obligations can sometimes require jumping back to re.ne previously com\u00adpleted \ntyping derivations, the construction is not a straightforward bottom-up exercise in tree building. In \nfact, the pattern of construc\u00adtion (precisely, the sequence of calls to the Close--procedures of Algorithm \n1) follows exactly the game-semantic traversals over the corresponding computation tree. Based on an \nempirical evaluation, the traversal algorithm is several orders of magnitude faster than Kobayashi s \nlinear-time algorithm GTRecS [10]. Although it does not quite match Kobayashi s hybrid algorithm (which \nis generally up to an order-of-magnitude faster), the traversal algorithm is still remarkably fast and \npractical, in view of the worst-case asymptotic complexity of the problem, which is (n - 1)-EXPTIME complete \n[11]. Outline The rest of the paper is organised as follows. We intro\u00adduce higher-order recursion schemes \nwith cases in Section 2, and recall some standard de.nitions from the literature. In Section 3 we describe \nan intersection and union type system used to characterise the model checking problem for HORSC, before \ngoing on to de\u00adscribe a type inference algorithm in Section 4. Section 5 presents the empirical evaluation \nof our methods and algorithms, with a dis\u00adcussion of related work in Section 6, followed by our conclusion \nand further directions in Section 7. Note: a long version of the pa\u00adper is available [15], which contains \nproofs and additional material. 2. Higher-Order Recursion Schemes with Cases We introduce a new class \nof structures, higher-order recursion schemes with cases and their model checking problem, and agree \non familiar de.nitions of S-labelled trees and deterministic trivial tree automata. Recursion Schemes \nwith Cases Let D be a set of directions (e.g. D = { 1, 2, \u00b7\u00b7\u00b7 ,m }). A D-tree (or simply tree) is a pre.x-closed \nsubset T of D *. Let S be a ranked alphabet. A S-labelled tree is a function t : dom(t) . S such that \ndom(t) is a tree. We refer to elements of dom(t) as nodes of t. In what follows, we refer to simple types \nas kinds (reserving the word type for intersection types, to be introduced shortly) and de.ne the set \nof kinds by . ::= d | o | . . . where o is the kind of S-labelled trees, and d is the kind of a .nite \ndomain for de.nition by cases. As usual, the order of a kind is the maximum nesting of an arrow on the \nleft, that is: ord(o)=0 and ord(.1 . .2) = max(ord(.1)+1, ord(.2)). We use \u00df and \u00dfi to range over ground \n(i.e. order-0) kinds. De.nition 1. A (non-deterministic) higher-order recursion scheme with cases (HORSC) \nis a quadruple G = (S, N , R,S) where (i) S is an alphabet of well-kinded terminal symbols (ranged over \nby f, g, a, b, etc.) with kinds drawn from those of order at most one. Further S contains a distinguished \nsubset of d-kinded symbols, B = { b1,..., bn }; and if f . (S \\B) then f has return kind o i.e. f :: \n\u00df1 . \u00b7 \u00b7\u00b7 . \u00dfm . o where m = 0. (ii) N is an alphabet of kinded non-terminal symbols (ranged over by \nF , G etc.).  (iii) R is a set of rewrite rules of the form Fx1 \u00b7\u00b7\u00b7 xm . e where F :: .1 . \u00b7\u00b7\u00b7 . .m \n. \u00df with \u00df .{ d, o }, each xi :: .i is drawn from a countably in.nite set of variables and e :: \u00df is \na (well\u00adkinded) applicative term generated from the following grammar e ::= x | f | F | e1 e2 | case(e, \ne1,...,en) where n is the cardinality of B, x .{ x1,...,xm },f . S and F .N . When a term contains no \noccurrence of a variable x, we say that it is closed. The kinding rule for the case construct is: if \ns :: d and each ti :: \u00df (base kind) then case(s, t1,...,tn) :: \u00df; the other kinding rules are standard. \nWe consider R to be a function de.ned by: R(F ) := { .x1 \u00b7\u00b7\u00b7 xm.e | Fx1 \u00b7\u00b7\u00b7 xm . e . R} When G is deterministic, \nthat is, for each F .N , R(F ) is a singleton, we abuse notation and identify R(F ) with its only member. \n(iv) S .N is a distinguished start symbol of kind o, and R(S) is a singleton set. By abuse of notation \nwe write S .R(S) for the unique rule for S. The (call-by-name) reduction relation of the HORSC G, written \n.G (or simply . whenever G is understood), is a binary relation over closed, ground-kinded terms, de.ned \nby induction over the following rules. .x1 ...xm.t .R(F )1 = i = n Fs1 ...sm . t[s/x] case(bi,s1,...,sn) \n. si ' s . s C[s] . C[s'] where the (one-holed) contexts are de.ned as follows: C ::= [] | Cs | sC | \ncase(C, t1,...,tn) | case(s, t1,...,ti, C, ti+2,...tn). We refer to (closed, ground-kinded) terms of \nthe shape Fs1 ...sm ' or case(bi,s1,...,sn) as redexes. Note that whenever s . s, there are unique C \nand . such that s = C[.] and . is the redex ' contracted (i.e. . .\u00b7= C[ \u00b7 . and s.]). Write S. for the \nalphabet S extended with symbol . of arity 0. Given a term t, we de.ne t. for the (.nite) S.-labelled \ntree de\u00ad.. .ned inductively by (i) (fs1 ...sn). := fs1 . ...sn (ii) t:= . if t is of the form Fs1 ...sn \nor case(s, t1,...,tn). With respect to the standard approximation ordering . (de.ned by the compatible \nclosure of .. t for all t), the set of S.-labelled trees is a com\u00adplete partial order. The tree language \ngenerated by G, written [ G] , . is de.ned to be the set of S.-labelled trees of the form i.I twhere \nI is a pre.x of ., and (ti)i.I is a maximal (possibly in.\u00adnite) sequence of closed, ground-kinded terms \nsatisfying: (outermost) The term t0 = S and for each i . I, ti . ti+1 is an  outermost reduction (i.e. \nthe redex contracted is not a subterm of another redex in ti) (fairness) Every outermost redex is eventually \ncontracted i.e. for each i . I and each outermost redex . in ti, there exists i ' = i such that . is \ncontracted in ti1 . ti1+1.2 Example 3. The HORSC G2 is speci.ed by terminal symbols b1 :: d, b2 :: d, \nzero :: o, succ :: o . o and pred :: o . o; non-terminal symbols S :: o, H :: d and G :: (o . o) . o, \nstart symbol S and rules: S . case(H, G succ, G pred) H . b1 H . H Gg . g zero It computes the single, \n.nite tree which, when written as a term, is denoted succ zero i.e. [ G2] = { succ zero }. Remark 1. \nHORSC extends Kobayashi s recursion schemes with .nite data domains (RSFD) [13] in several ways: (i) \nThe bis of HORSC are terminals, but the dis of RSFD are data (distinct from variables, terminals and \nnon-terminals). (ii) In RSFD the return kind of both non-terminals and the case construct must be o. \nThere is no such restriction in HORSC. (iii) RSFD does not handle non\u00addeterminism. A consequence of (i) \nand (ii) is that in RSFD, the .rst argument of the case construct must be an atomic datum di or a variable. \nIn contrast, the .rst argument of a case construct in HORSC is an arbitrary term of kind d i.e. any term \nwhich may reduce to an element of B or otherwise diverge. For example, the HORSC G2 is not a RSFD, since \nit is non-deterministic, and contains a case construct that has a non-terminal as the .rst argument. \nDeterministic Trivial Tree Automata We use a simple form of automata over in.nite trees to specify properties \nof the tree languages of HORSC. De.nition 2. A deterministic trivial tree automaton (DTT) is a quadruple \nA = (S, Q, d, q0) where (i) S is a ranked alphabet; (ii) Q is a .nite set of states containing an initial \nstate q0;  (iii) d : Q \u00d7 S -Q * is a (partial) transition function such that if d(q, a)= q1 ...qn then \nn is the arity of a. A S-labelled tree t is accepted by a DTT A just if there is a Q\u00adlabelled tree r, \ncalled a run-tree of A over t, satisfying: (i) dom(r)= dom(t); (ii) r(E)= q0; (iii) for every a . dom(r), \n(r(a),t(a),r(a 1) \u00b7\u00b7\u00b7 r(am)) . d where m is the arity of t(a). Thus a run tree of A over t is an annotation \nof the nodes of t with states that respects d such that the root is annotated q0. Example 4 (A DTT A1). \nTake the ranked alphabet S of Ex\u00adample 2; [ G1] is accepted by A1 = (S, {q0,q1}, d, q0), where d :(q0,c) \n. q1q0, (q1,b) . q1, (q1,a) . E. Thus A1 accepts a 2 Note that if s = C[.] . C[ \u00b7 .] and . is outermost, \nand . ' is a different outermost redex in s, then . ' occurs in C i.e. . has a unique residual in C[ \n\u00b7 .]. S-labelled tree t if, and only if, a and b are seen only on the left of a c. c, q0 a, q1 c, q0 \nb, q1 c, q0 . . a, q1 . Universal HORSC Model Checking Problem Let A = (S, Q, d, q0) be a DTT. De.ne \nthe DTT A. := (S., Q, d ' ,q0) by d ' := d .{ (q, .,E) | q . Q } (so that A. will accept any subtree \nlabelled . from any state). Given a HORSC G and a DTT A, we say that the tree language [ G] is universally \naccepted (respectively existentially) by the DTT A just if every (respectively some) element of the tree \nlanguage [ G] is accepted by A.. The Universal HORSC Model Checking Prob\u00adlem for DTT is to check whether \nthe language [ G] is universally accepted by A.. Henceforth, we will refer to this problem simply as \nthe HORSC Model Checking Problem. 3. An Intersection and Union Type System We wish to characterise the \nHORSC model checking problem as a kind of type inference problem in an intersection type system. In doing \nso, we not only establish decidability, but also rephrase the question of acceptance as one of bounded \nsearch which is much better understood algorithmically. Well-Kinded Types We introduce an intersection \nand union type system parameterised by a DTT A = (S, Q, d, q0) with B. S. First we de.ne the set of well-kinded \ntypes simultaneously with a kinding relation on types, which is de.ned by induction over the following \nrules: q . QB .B .i :: .1 (for all i . I) . :: .2 f q :: oB :: d (.i) . . :: i.I .1 . .2 Any expression \ns such that s :: . is derivable in the above system is a well-kinded type. For example, given Q = {q0,q1}, \nthe expressions q1 . q0 and ((q1 . q1) . (q0 . q0)) . q0 are well-kinded types while (q0 . (q0 . q1)) \n. q1 is not. Note that there are only .nitely many well-kinded types of each kind. We write Type for \nthe collection of well-kinded types. Henceforth, we will say type to mean well-kinded type. We writef \nlk .i forf{.1, \u00b7\u00b7\u00b7 ,.k}, and T forf \u00d8; similarly i=1 we write bij for {bi1 , \u00b7\u00b7\u00b7 , b}and . for \u00d8; further \nwe j=1 il f write {bi} simply as bi. Note that intersection is only allowed on the left of an arrow; \nand union is only de.ned on a subset of B. Type System We now present the type system itself. Intuitively, \na typing for a term t describes the tree generated by t. For example, the typing a : q0 indicates that \nthe trivial tree a is accepted from state q0. Intuitively a term has an intersection type if it generates \na tree that is acceptable from every state in the intersection; a term has a union type if it generates \na singleton tree bi for some i. For example, the typing .x.s :(q0 . q1) . (b0 . b1) says that we have \na function that takes a tree accepted from both q0 and q1 as an argument and returns a tree s[t/x] that \nis either b0 or b1.  A type environment (typically G) is a .nite set of type bindings, which are pairs \n. : t where . is a non-terminal symbol or a variable, and t is a type. Note that non-terminal symbols \nand variables are treated in the same way by the system; and different types may be bound to the same \nsymbol in an environment. A judgement is a triple, written G fA t : ., in which G is a type environment, \n. is a type and t is a .-term with case construct. A judgements is valid just if it can be derived in \nthe following system: . is well-kinded VAR G,x : . fA x : . d(q, a)= q1 \u00b7\u00b7\u00b7 qn TERM G fA a : q1 . \u00b7 \u00b7\u00b7. \nqn . q - G fA s :( .i) . . G fA t : .i (i . I) i.I APP G fA st : . G,x : .1,...,x : .n fA t : . x/. G \n-ABS G fA .x.t :( i.{1,...,n} .i) . . G fA t :bi G fA ti : . (i . I) i.I .-ELIM / CASE G fA case(t, \nt1,...,tn): . .i . I \u00b7 G fA t : bi .-INTRO / UNION G fA t :i.I bi BASE G fA bi : bi Note in particular \nthe .nal three rules, which cover the addition of case to the term language. In .-ELIM each possible \ntyping for t re\u00adquires a proof of typability of the corresponding ti. The disjunction can only be eliminated \nhere, ensuring that disjunction types cannot be used in other contexts. A canonical typing derivation \nwill reserve the .-INTRO rule to be used immediately before BASE, delaying the choice of which member \ntype of the disjunction to choose as late as possible. Each b .B can be typed by a singleton disjunc\u00adtion \nof a type of the same name. Characterisation Following Kobayashi [8, 12], we characterise the HORSC model \nchecking problem in terms of the existence of certain type environ\u00adments that are appropriate to the \nscheme that we are checking. De.nition 3. Fix a HORSC G and a DTT A. We say that a type environment G \nis fG,A-complete, written fG,A G, just if (i) dom(G) .N (ii) G fA S : q0  (iii) for each (F : .) . \nG and for each .x.t .R(F ) we have G fA .x.t : .. Intuitively, a type environment G is fG,A-complete \nwhenever it contains enough well-kinded typings for the non-terminal symbols in G so that S can be typed \nwith q0, but not so many that some are inconsistent with the behaviour of their de.ning rules. Theorem \n1 (Characterisation). Given a HORSC G and a DTT A, [ G] is accepted by A. if, and only if, there exists \na fG,A-complete type environment. Given a HORSC G and a DTT A, the number of non-terminal sym\u00adbols in \nG and the number of well-kinded types is .nite. It follows that the problem of the existence of a fG,A-complete \ntype environ\u00adment is decidable. However, the size of the search space is hyper\u00adexponential in the largest \norder of the kind of any non-terminal symbol. Thus, in the following section we describe an algorithm \nwhich is able to explore this vast expanse in a goal-directed way, which, we will argue in Section 5, \ngives good performance in prac\u00adtice. Remark 2. In fact, since the data types in HORSC are .nite, the \nmodel checking problem can be shown to be decidable by reduc\u00adtion, via determinisation and a Church-style \nencoding of constants as projection functions, to an instance of the HORS model checking problem. However, \nsuch a transformation is known to increase the order and arity of the non-terminal symbols and so is \nnot palatable from a practical point of view. Example 5 (A typing for G1). We can see that G1 = {S : \nq0,F : q1 . q0} is fG1,A1 -complete, hence, thanks to Theorem 1, [ G1] is accepted by A1. 4. The HORSC \nModel Checking Algorithm Our approach to deciding the HORSC model checking problem exploits the characterisation \nby the intersection and union type system as stated in Theorem 1. Given a HORSC G and a DTT A, the decision \nprocedure seeks to construct a fG,A-complete type environment. Fix A = (S, Q, d, q0). Consider a term \nt0 t1 ...tn (where t0 is atomic) which is expected to produce a tree of type q, the canonical example \nbeing the term R(S) and the type q0. This can be viewed as a typing judgement f t0 t1 ...tn : q. Our \ngoal is to construct a derivation for it. After n (bottom-up) applications of the APP rule, a subgoal \nf t0 : . is generated where . = a1 . \u00b7 \u00b7\u00b7 . an . q and the ai are type variables that are as yet undetermined. \nThe values they take on will depend on how t0 uses its arguments, and we can explore this in a syntax-directed \nmanner. -Suppose t0 is a terminal symbol. Since d(q, a) is unique, all ai will be fully determined, yielding \nn further subgoals, which are judgements of the form ti : ai to prove. -Encountering a non-terminal, \nsay t0 = F , requires us to assume that F : . and to build new derivations showing that s : . for all \ns .R(F ). Bear in mind the characterisation of the problem by fG,A-completeness (Theorem 1). -In case \nthe symbol t0 is a variable (i.e. a formal parameter), we must ensure that the corresponding actual parameter \nhas the necessary return type. The use of type variables (such as ai above) captures the connec\u00adtion \nmade by term variables between typing derivations and enables us to detect the situation where a typing \nderivation is redundant. A type variable is instantiated to a set of type expressions (call open types) \nwhich may themselves contain type variables. A derivation need not be explored further when two derivations \nboth aim to show R(F ): ., one of which is already complete. We use a restricted system of union types \nto represent non-deterministic choices in the argument to a case term, which is illustrated in the following \nex\u00adample. Example 6 (Building a derivation for G2 F A2). We consider a simple DTT A2 = ({succ, pred, \nzero}, {q0,q1}, d, q0) where d is the map: (q0, succ) . q1, (q1, zero) . E. Starting with the  VAR fA \nb1 : b1 fA b1 : \u00df BASE .-INTRO {g : a1} f g : a2 . q0 {g : a1} f g zero : q0 f .g.g zero : a1 . q0 APP \nABS Go fA H : \u00df VAR VAR Go fA G : a1 . q0 Go fA succ : a2 . q0 Go fA G succ : q0 APP .-ELIM Go fA case(H, \nG succ, G pred): q0 Table 1. Examples of pre-derivations (Go = {H : \u00df}) initial goal of showing S : q0, \nit immediately becomes necessary to build a derivation rooted at fA R(S): q0. Since the right-hand side \nof S R(S)= case(H, G succ, G pred) is a case construct, we assume that H : \u00df where \u00df is a fresh type \nvariable and proceed to explore R(H) to .nd which members of the .nite domain B it can reduce to. This \nleaves us with the derivation VAR {H : \u00df}fA H : \u00df APP {H : \u00df}fA case(H, G succ, G pred): q0 and two further \nderivations to build, which are rooted at the follow\u00ading, corresponding to the respective right-hand \nsides of H: \u00d8fA H : \u00df \u00d8fA b1 : \u00df f where \u00df is instantiated to \u00d8 = . initially, avoiding the need to show \nany typings for the choice terms in the case construct. As usual, . represents nontermination, which \nis exactly the situation that would prevent the case from reducing to any choice term. If the exploration \nof the scrutinee (here H) ever reduces to a bi then \u00df will be updated accordingly. Notice that taking \nthe type environ\u00adment to be G= {S : q0,H : \u00df} in the sense of Theorem 1, the derivations to ensure that \nthe right-hand sides match the typings are already in place, although as yet incomplete. To build a derivation \nrooted at the right-hand judgement we use the .-INTRO and BASE rules (see the derivation on the left \nin the top row of Table 1). This requires \u00df to contain b1, causing an additional obligation to type the \n.rst choice term (G succ) of the case construct. To complete this example, we aim to build a derivation \nrooted at this new judgement {H : \u00df}fA G succ : q0. In order to apply the APP rule (in a bottom-up fashion), \nwe intro\u00adduce another type variable, a1. Dually to the use of .-ELIM, a1 is initially instantiated to \n\u00d8 = T, again avoiding the need to prove any typing for succ at this time. Exploring the right-hand side \nof G (top-right in Table 1), as for H, we .nd a use of the variable g. Looking at the typing rules, we \n.nd that this typing must be jus\u00adti.ed by the VAR rule, which requires enlarging a1, and just as before, \nafter adding the new type to a1, the use of the APP rule to close the judgement {H : \u00df}fA G succ : q0 \nis no longer valid. We must add an extra judgement for the operand (see the lower derivation in Table \n1), which in turn can be justi.ed by the TERM rule. This captures informally how we build up the typing \nderiva\u00adtions. Notice that if we take G to be the union of all non-terminal type bindings in the various \nderivations then (i) dom(G) .N ; (ii) G fA S : q0; (iii) If all judgements are closed then for each \nF : . in G, each t .R(F ), we have G fA t : .. Clearly if the tree language generated by the HORSC is \n.nite, then all judge\u00adments will eventually be closed following this approach. However in general we \nrequire a more complex termination condition.  Open Types, Instantiation and Rei.cation Maps We now \nformalise the method introduced in Example 6. First we introduce open types, which represent intersection \ntypes using type variables. An open type has the form a1 . \u00b7 \u00b7\u00b7 . an . \u00df where each variable ai ranges \nover .nite sets of intersection types, and \u00df . Q .P(B). Given an instantiation map (to be de.ned shortly), \nopen types are a representation of types. Assume, for each kind ., a countably in.nite set A. of type \nvariables. The set P. of open types of kind . is de.ned by recursion over . as follows (we use .o,.1o \n, \u00b7\u00b7\u00b7 to range over P.). Po := Q Pd := P(B) P.1..2 := { a . .o | a . A.1 ,.o . P.2 }  Let A := A. and \nP := P.. We say that a ..Kind ..Kind function T: A .P(P) is an instantiation map if it is (i) .nite: \nthere exists a .nite subset C of A such that T maps every element of (A\\C) to \u00d8, and (ii) kind-respecting: \nfor each kind ., T restricts to a function from A. to the set P.n(P.) of .nite subsets of P.. Instantiation \nmaps T: A .P(P) are used to reify open types. Given such a map, we derive from it a kind-indexed family \nof maps on open types, ewith . . Kind, as follows: T. : P. . Type. eef B To(q) := q, Td(B) := B ee(.o \n. e(.o) T.1..2 (a . .o) := .o.T(a) T.1 1)T.2 1 Note that for each a . A.1 , T(a) is a .nite subset of \nP.1 . The map eis well-de.ned by structural induction on .. We de.ne T. eT.(.o T: P . Type by .o . e) \nfor .o . P., and call it the rei.cation map. Example 7. Let . = ((o . o) . o) . o . o, and take .o = \na1 . a2 . q1, an element of P.. Let T be the instantiation map: a1 .{ a3 . q2,a4 . q1 },a2 .{ q1 },a3 \n.\u00d8,a4 . { a5 . q0 },a5 .{ q0 }. Then e T(.o)={T . q2, (q0 . q0) . q1 }. q1 . q1. Open types are used \nto build up intermediate information about the necessary typings of non-terminal symbols while keeping \nthe relation between these different types explicit in the mapping. This relationship would be lost using \nconcrete types.  For notational convenience we use some further conventions. We use the superscript \no to mean open (in the sense of containing variables). Thus open types are ranged over by .o,.1o , \u00b7\u00b7\u00b7 \n; simi\u00adlarly, open-type environments are ranged over by Go , G1o , \u00b7\u00b7\u00b7 . The rei.cation map Teis extended \nto open-type environments Go where it proceeds point-wise. Let J =Go f t : .o be an open-type judge\u00adment. \nWe write T(eJ) to mean the judgement T(GeoT(.o ) fA t : e). Further, let . be a .nite tree whose nodes \nare labelled by open-type judgements (such as typing derivations). We write e T(.) to mean the tree that \nis obtained from . by replacing each judgement J by e T(J). Recall that a typing derivation is a tree \nwhose nodes are labelled by judgements; each such judgement is justi.ed by a rule if it labels an internal \nnode, or by an axiom if it labels a leaf node. Informally a pre-derivation is a .nite tree whose nodes \nare labelled with open\u00adtype judgements. In a pre-derivation, a judgement that occurs at a leaf-node is \nsaid to be closed if there is a line above it; otherwise it is said to be open. A pre-derivation that \nhas no open judgements is said to be closed; otherwise it is open. We write D for the set of pre-derivations. \nThe Model Checking Algorithm The algorithm proceeds by growing a tree D and an accompany\u00ading instantiation \nmap T. Each node n of D is associated with a type binding of the form (F, s : .o) where F is a non-terminal, \ns .R(F ) and .o is an open type; and n represents the subgoal of building a derivation for the judgement \nGo f s : .o for some open-type environment Go. In the process of constructing such a derivation (in a \nbottom-up fashion), new derivation subgoals may be created, which are represented by the spawning of \nnew nodes (corresponding to the subgoals); and T is updated. The root node is associated with the binding \n(S, R(S): q0) (recall that we write S .R(S) for the unique rule for S), and it represents the original \ngoal, namely, to build a derivation for \u00b7\u00b7\u00b7 f R(S): q0. Formally, a state of the algorithm is a pair \n(D, T) where D is a ((R\u00d7 P) \u00d7 D)-labelled tree, and T is an instantiation map. Each node n of D is labelled \nby a quadruple, D(n)=(F, s : .o , .), such that the judgement at the root of the pre-derivation . has \nthe form Go f s : .o for some term s .R(F ) and open-type environment Go. Observe that (F, s) uniquely \nidenti.es a rule from R. Henceforth we shall refer to . as the pre-derivation of n, and the triples (F, \ns : .o) and (F, s : e)) respectively as the open\u00ad T(.otype binding and rei.ed-type binding of n. Given \na state (D, T), a node of D is said to be closed if its pre-derivation . is closed (and we shall see \nLemma 1 that it follows that e T(.) is a valid type derivation of fA); otherwise, the node is open. The \nfunction open, when applied to D, returns the set of judgements J that is currently open (in some open \npre-derivation of D). The top loop of the algorithm is shown in Algorithm 1 and follows the ideas outlined \nin Example 6. As mentioned earlier, we must start with the open judgement \u00d8fR(S): q0 and this informs \nthe initialisation. (W.l.o.g. we assume that R(S) is a singleton set.) The open judgements, Go f s : \n.o, are then closed in turn by ap\u00adplication of the appropriate rule (as implemented by one of the six \nClose procedures), depending on the shape of s. Termination of the loop depends on the existence of a \ncomplete cut of a certain initial subtree of D. Fix a state (D, T). De.ne Dcl := { n . dom(D) | n and \nall its D-ancestors are closed }. Thus Dcl is the largest initial subtree of D consisting only of closed \nnodes. Let t be a S-labelled tree. As usual a subset C . dom(t) is a cut of t just if for every maximal \npath B of t, B n C is a singleton set. Let C be a cut of Dcl. We write n -C to mean that n is an ancestor \nof some element of C (read: n is an interior node of C); and n . C to means that n -C or n . C. De.nition \n4. We say that a cut C of the tree Dcl is complete if for every c . C, either c is a leaf-node3 of D, \nor there is an interior node of C that has the same rei.ed-type binding as c. (Observe that open(D)= \n\u00d8 if, and only if, every node of D is closed. Hence, if open(D)= \u00d8, the set of its leaf-nodes is a complete \ncut; note that D is .nite.) Algorithm 1: Model Checking input : HORSC G = (S, N , R,S), DTT A = (S, Q, \nd, q0) output: Whether G F A, with a witness D := singleton tree with label (S, R(S): q0, \u00d8fR(S): q0) \nT := {a .\u00d8| a . A} while Dcl does not have a complete cut do foreach (Go f s : .o) as J . open(D) do \nif s = tu then CloseApp(J) if s .N then CloseNonTerm(J) if s . V then CloseVar(J) if s .B then CloseUnion(J) \nif s = case(t, t) then CloseCase(J) if s . S then try CloseTerm(J) with Trace s . return (NO,s) end end \nreturn (YES, D) Procedure CloseNonT erm input : J =Go f F : .o in pre-derivation . // .o = a1 . \u00b7 \u00b7\u00b7 \n. an . \u00df foreach Go 1 f s : .1 o in pre-derivation . do Go 1 := Go 1 .{F : .o} end J := Go f F : .o foreach \n.x1 ...xn.s .R(F ) do Add a fresh node, labelled (F, .x1 ...xn.s : .o,J ' ), as the rightmost child of \nthe node of D containing J where {xi : ai | 1 = i = n}f s : \u00df J ' := \u00d8f .x1 ...xn.s : .o end Example \n8 (Completion of analysing G2 against A2). We will now look at the completed data structures, continuing \nfrom Example 6. .1, .2 and .3 are the pre-derivations explored in the previous example, with .2, .3 and \n.4 being required to prove .1, as can be seen from D in Table 2. Tracing the computation from Example \n6 to this state is left as an exercise to the reader. In this case, the open pre-derivations .5 and .6 \ntrivially have the same rei.ed-type binding as .3 and .4 (H, H : b1 and H, b1 : b1). As a 3 which means \nthat \u00d8f s : S T(.o) is valid (since c is closed and thanks to Lemma 1, page 8), where (F, s : .o) is \nthe open-type binding of c  result the environment G= {S : q0,G :(q1 . q0) . q0,H : b1} Procedure AddDer \nis guaranteed to be a witness to [ G2] F A2. input : Type variable a, open type .o // Find intro. of \na in pre-derivations of Correctness D Go ' f t : a . .1 o \u00b7\u00b7\u00b7 if . ! J = then Go f tu : .1 o J ' := Go \nf t : a . .1 o Go f u : .o \u00b7\u00b7\u00b7 Go f tu : .1 o else (.o = bi) ' Go f t : a \u00b7\u00b7\u00b7 . ! J = Go f case(t, t1,...,tn): \n.1 o ' f t : a f ti : .o \u00b7\u00b7\u00b7 Go Go J := Go f case(t, t1,...,tn): .1 o end T := T[a . T(a) .{ .o }] Procedure \nCloseApp input : J =Go f tu : .o Go f t : a . .o J := (a fresh) Go f tu : .o Procedure CloseV ar input \n: J =Go f x : .o J := Go f x : .o AddDer(Go(x),.o) Procedure CloseT erm input : J =Go f a : .o // .o \n= a1 . \u00b7 \u00b7\u00b7 . an . q if (q, a) ./d then raise (Trace (counter-example trace)) else (d(q, a)= q1 ...qn) \nJ := Go f a : .o foreach i .{1,...,n} do AddDer(ai,qi) end end Procedure CloseCase input : J =Go f case(t, \nt1,...,tn): \u00df Go f t : \u00df J := Go f case(t, t1,...,tn): .o Procedure CloseUnion input : J =Go f bi : \u00df \nGo f bi : bi J := Go f bi : \u00df AddDer(\u00df, {bi}) First we observe that Algorithm 1 never gets stuck: every \nopen judgement is matched by one of the six rules (corresponding to the six Close-procedures). We formulate \nit as an important invariant of the algorithm. Lemma 1 (Invariant). Let (D, T) be a state of the algorithm, \nn be a node of D, and D(n)=(F, s : .o , .) where the judgement at the root of the pre-derivation . is \nGo f s : .o (where s .R(F )). (i) Every internal judgement (respectively closed judgement) of e T(.) \nis an instance of a rule (respectively axiom) of fA. Hence, e if n is closed then T(.) is a valid type \nderivation, witnessing e T(Go) f s : e). T(.o (ii) Let Go = { F1 : .1o ,...,Fl : .o } and for each i, \nR(Fi)= { si1,...,siri }. Then l { ni1, \u00b7 l \u00b7\u00b7 ,niri } is the set of succes\u00ad i=1 sor nodes of n, where \nD(nij )=(Fi,sij : .io , .ij ) for each i. Proof. (Sketch) Given (D, T) we prove that each of the six \nrules (corresponding to the six Close-procedures) preserve these prop\u00aderties. Lemma 2. Let (D, T) be \na state of the algorithm. Suppose there is a complete cut C of Dcl. De.ne . to be the set: . := { F : \ne) |.n.n , .) }T(.oC .D(n)=(F, s : .o Then fG,A . (in the sense of Theorem 1). Proof. Take nC with D(n)=(F, \ns : .o , .). We need to show that there exists G . . such that G fA T(.o), s : efor every s .R(F ). We \nmay assume that n -C; for if not, since C is a complete cut, there is some interior node n ' of C that \nhas the same rei.ed-type binding as n; and so, we take n ' instead of n. Since n is a node in Dcl, by \nLemma 1, for some Go = { F1 : .1o ,...,Fl : .o }, we have l F1 : eT(.o T(.o T(.1 o),...,Fl : el ) fA \ns : e) where the set of successors of n is N = l { ni1,...,niri }, i=1 with D(nij )=(Fi,sij : .io , .ij \n) for each sij .R(Fi). If N = \u00d8, we are done. Otherwise, take an arbitrary successor of n, say, n11. \nSince C is a cut, n11 -C or n11 . C. If the latter, since C is complete, there is an interior node of \nC that has the same rei.ed-type binding as n11. Thus there is a subset N ' consisting of interior nodes \nof C such that the set of rei.ed-type bindings of nodes in N coincide with the set of rei.ed-type bindings \nof nodes in N ', and we are done. Now take s ' .R(F ). By assumption, s ' C, using the same reasoning \nas before, we can show the desired result. Theorem 2 (Correctness). Let G = (S, Q, d, R,S) be a HORSC \nand A a DTT. (i) If Algorithm 1 returns YES then A accepts [ G] . (ii) If Algorithm 1 returns NO then \nA rejects [ G] .  (iii) Algorithm 1 terminates on every input.  D =(S, case(H, G succ, G pred): q0, \n.1) (G, .g.g zero : a1 . q0, .2) (H, H : \u00df, .3) (H, H : \u00df, .5) (H, b1 : \u00df, .4) (H, b1 : \u00df, .6) VAR \nTERM Go fA G : a1 . q0 Go fA succ : a2 . q0 VAR APP .1 = Go fA H : \u00df Go fA G succ : q0 .-ELIM Go fA \ncase(H, G succ, G pred): q0 VAR TERM {g : a1}f g : a2 . q0 {g : a1}f zero : q1 APP .2 = {g : a1}f g \nzero : q0 ABS f .g.g zero : q0 BASE fA b1 : b1 .3 =.5 = H : \u00df fA b1 : \u00df fA b1 : \u00df .-INTRO VAR .4 =.6 \n= fA H : \u00df fA H : \u00df Go T= {a1 .{a2 . q0},a2 .{q1},\u00df .{b1}} = {G : a1 . q0,H : \u00df} Table 2. A terminating \nstate (D, T) of the algorithm with input G2 and A2 (Example 8). Remark 3 (Round). We organise the computation \nof the while\u00adloop in Algorithm 1 into rounds. In each round, for each J . open(D) we apply the appropriate \nClose-procedure repeatedly to the judgement that is opened up, until we reach a non-terminal. Thus at \nthe end of each round, the open judgements (if any) are all non-terminals. Proof. (i) follows from Lemma \n2. (ii) It suf.ces to show that given a state (., T), for every judge\u00adment G f t : .o . . with q as the \nresult type of .o, we can construct a term t ' that is a subterm of some u such that S . * u; G further \nif there is a run tree r, then r(\u00df)= q where u(\u00df)= t '. Intu\u00aditively this means that for every such judgement \ndetermines a path in a runtree. (iii) Let N = { F1,...,Fm } where F1 = S, and let N be the product of \nthe number of rewrite rules and the total num\u00adber of types (of the relevant kinds) of G. Using our standard \nnotion of round (Remark 3), the open nodes of a state tree D are necessar\u00adily leaf nodes. To show termination \nof the algorithm (in case of a yes-instance), we aim to exhibit a state tree such that every path in \nit is either suf.ciently long to guarantee a recurrence of a rei.ed type binding, or it ends in a closed \nnode. To this end, we systematically compute all traversals. For each traversal, we keep on extending \nit until we reach a closed node, or it has induced a path in the state tree of length greater than N. \nTermination of such a computation of traversals is a consequence of [16, Lemma 14 (long version)]. An \nalternative argument from .rst principles is Lemma 3, which is proved in the long version of this paper. \nCorrespondence with Traversals The computation of the algorithm can be represented by a possibly in.nite \ntree, called justi.ed judgement tree, which is de.ned to be a (justi.ed) tree of judgements (i.e. the \nnodes are labelled by judge\u00adments; we shall refer to a node by its label) such that J ' is a suc\u00adcessor \nof J just if the execution of the call Close.(J) (where the suf.x ., which is one of Abs,NonTerm,V ar,Term,Case \nand Union, is determined by the head symbol of the term in J) con\u00adstructs the open judgement J ' either \nin the same pre-derivation as J or in a new pre-derivation. Thus each path in the justi.ed judge\u00adment \ntree represents a sequence of judgements that are successively closed by one of the four Close. procedures. \nThe judgement tree is justi.ed in the sense that some nodes have a pointer back to an ancestor node. \nIn the long version of this paper, we show that the justi.ed judgement tree and the traversal tree (in \nthe sense of [16]) are isomorphic with respect to both the successor and pointer rela\u00adtions. Theorem \n3 (Correspondence). (i) There is a bijective map F from maximal paths in the traversal tree to maximal \npaths in the computation tree. (ii) Further, for every maximal path p, the S\u00adprojection of p to S coincides \nwith the S-projection of F(p). Lemma 3. If a traversal is well-founded (in the sense that there exists \nN = 0 such that all paths that are induced in the state tree have length less than N) then it is .nite. \nOptimisations A crucial optimisation is Actual Parameter Revisit Avoidance. Fix a node n with open-type \nbinding F : .o, and a variable x that occurs more than once in R(F ). Suppose at state (D, T), the open \njudgement J2 =Go f x : .2 o in the pre-derivation of n (call it .) is chosen and CloseVar(J2) is called \nwith Go(x)= a and .02 = \u00df1 . \u00b7 \u00b7\u00b7 . \u00dfn . q. Suppose at an earlier state, a judgement of the form J1 =Go \nf x : .1 o with .1 o = a1 . \u00b7 \u00b7\u00b7 . an . q was closed (and let J1 be the .rst such), and so, we have .1 \no . T(a). Then we optimise as follows. (i) When executing AddDer(a, .2o) as called by CloseVar(J2), do \nnot search for J ' nor update it (using the notation of the procedure AddDer), instead, after executing \nT(a) := T(a) .{ .2 o }, perform: for each i, T(\u00dfi) := T(ai); and for each . 'o . T(\u00dfi), call AddDer(\u00dfi,. \n'o). (ii) Subsequently, every call to AddDer(ai,. 'o) automatically triggers a call to AddDer(\u00dfi,. 'o), \nfor i .{ 1, \u00b7\u00b7\u00b7 ,n }.  To see why the optimisation is sound, consider AddDer(a, .1 o), which constructs \na new open judgement Go 1 f u : .1 o (say). Eventu\u00adally for some i .{ 1, \u00b7\u00b7\u00b7 ,n }, AddDer(ai,. 'o) is \ncalled, which performs the update T(ai) := ai .{ . 'o } with control then re\u00adturning the original pre-derivation \n., seeking to prove a typing  . 'o for the ith-argument (of the .rst occurrence) of x. Let this se\u00adquence \nof calls to a Close procedure between AddDer(a, .1o) and AddDer(ai,. 'o) be .i,.1o . Now consider a call \nto CloseVar(J2) which calls AddDer(a, .2o), and which constructs a new open judgement Go 1 f u : .2 o \n(say). Note that for each i and . 'o , .i,.1o determines a corresponding sequence of calls to a Close \nprocedure between AddDer(a, .2 o) and AddDer(\u00dfi,. 'o). The optimisation removes such call sequences for \neach i and . 'o (but not their ef\u00adfects). Our experiments (see Section 5) demonstrate that the opti\u00ad \nmisation results in close to an order-of-magnitude improvement for HORS of orders 4 or higher. Translated \ninto the language of traversals, the optimisation says that if the traversal reaches a variable x with \nstate q, instead of jumping to the actual parameter of x, one can immediately traverse down\u00adwards with \nstate q ' to the i-child of x, provided the traversal has vis\u00adited another occurrence of x before with \nstate q and subsequently visiting its (the earlier occurrence s) i-child with state q ' . The canonical \ntypes optimisation aids with the critical part of a complete cut (and thus termination) is .nding two \nnodes with the same concrete type bindings. We can increase the chance of .nding two such nodes using \nsubtyping to yield canonical types. Given any intersection type i.I .i . . it is suf.cient to consider \ninstead j.J .j . . where J . I and for all k . I \\ J, there exists some j . J such that .j = .k (where \n= is standard intersection type subtyping). Intuitively, this .k may be removed because .j already places \na stronger requirement on a parameter to this function. Any typing tree that uses x : .k could therefore \nbe replaced with one that uses x : .j instead. Removing these redundant types during rei.cation of open \ntypes allows us to consider a smaller space of canonical types. At a lower-level, rei.cation caching \nwas introduced to handle the relatively expensive calculation of Teas the requirement to search for a \ncut after each round of operation led this to dominate the runtime of the algorithm. By caching the result \nof Tefor each a e and maintaining a dependency mapping (such that if a ' . T(a) then a depends on a ') \nwe can avoid the majority of T lookups while preserving correctness by invalidating cache entries in \nthe transitive closure of the dependencies for any a that we update. Finally, an unguided execution of \nthe algorithm can yield a vast number of subgoals very quickly. Every time a terminal symbol of arity \nn is encountered, the number of subgoals rises by n - 1. To address this, our implementation uses a search \nguided by the termination check. While searching for a complete cut using a breadth-.rst search of D, \nany subtree rooted at a node with a type binding already seen is not explored, and any open judgements \nwithin this subtree are not expanded at this time. This focuses the attention of the algorithm on areas \nof the tree that could not currently form part of a complete cut. In the extremal case, all open judgements \nare contained in such subtrees, and the algorithm terminates. 5. Empirical Results and Evaluation We \nhave constructed TRAVMC, an implementation of Algorithm 1 presented in Section 4. The implementation, \nand all the exam\u00ad ples presented here, can be accessed through a web interface at http://mjolnir.cs.ox.ac.uk/horsc/. \nFor comparison we have considered not just HORSC, but also standard HORS, which can be handled by our \nalgorithm as a degenerate case. Instance example2-1 .leocamlc .leocamlc2 .leorder5-2 .lewrong .ow g35 \ng41 lock2 m91 order5 order5-variant stress O S R H G T TB T' 1 2 Y 2 1 34 0 33 4 21 Y 8 1680 60 23 718 \n4 22 Y 7 1980 58 18 918 5 30 Y 109  201 167 4 11 N 0  86 47 85 4 7 Y 1 3 32 0 32 3 11 Y  136 4 8 Y \n 608 55 15 4 11 Y 10  64 23 132 5 25 Y 39  429 381 5 9 Y 5  62 8 46 5 11 Y 12  47 7 317 1 13 Y 29 \n3 187 133 180 Table 3. HORS MC comparison HORSC O S R T TH checknz checkpairs .lepath .lter-nonzero \n.lter-nonzero-1 last map-head-.lter map-head-.lter-1 map-plusone map-plusone-1 map-plusone-2 mkgroundterm \nrisers safe-foldr1 safe-head safe-init safe-tail 1 1 1 4 4 1 2 2 4 4 4 1 1 2 2 2 2 27 86 369 49 69 60 \n110 190 39 49 63 108 165 145 106 235 154 Y N Y N Y Y N Y Y Y Y Y Y Y Y Y Y 46 53 1950 74 1756 71 62 1080 \n83 296 4144 179 113 450 71 209 88 36 93 156 45 116 1538 161 860 96 127 625 56 288 74 RSFD O S R T \nH gap id homrep merge addr mult remove b xhtmlm-drop-a xhtmlm id xhtmls-remove-meta xhtmlf id 3 4 1 1 \n2 1 1 1 1 26 12 7 5 7 33 33 13 51 Y Y Y Y Y Y Y Y Y 248 1767 52 52 54 1252 996 277 15 7 1 1 2 146 64 \n9 456 Table 4. HORSC MC results HORS Model Checking For HORS, we have used a benchmark suite containing \na number of examples from the literature, along with some fresh examples. The columns O , S and R in \nthe table indicate the order, number of rules and result of the example respectively. The H and G columns \ncontain timing data (in milliseconds) for Kobayashi s hy\u00adbrid (TRECS version 1.32) and game-based algorithms \n(GTRECS version 0.104). Those labelled T or TB (resp. T' ) are for the algorithm introduced in this paper \nwith (resp. without) the Re\u00advisit Avoidance optimisation at order 1, the subscript B indicating a batch \nprocessing mode. Where an algorithm did not terminate within 10 seconds this is indicated by . 4 We \ndid not have access to a GTRECS binary, as a result experiments were carried out through the author s \nweb interface. Timings are not directly comparable, but indicative.  Table 3 shows that for most examples \nTRAVMC performs approx\u00adimately an order of magnitude slower than the current version of TRECS. However, \ngiven the immature state of our implementa\u00adtion, we believe that this gap may be crossed given careful \nopti\u00admisation. For the very rapid examples (around 100ms and below), we found that the runtime was dominated \nby the .rst round of ex\u00adpansion. We believe that this is JIT overhead tied to our use of F# on .NET (both \nTRECS and GTRECS are implemented in OCaml). This is supported by our batch mode experiment, which saw \nall ex\u00adamples processed consecutively by a single invocation of the model checker, avoiding the repeated \nstartup overhead commonly associ\u00adated with JIT compilers and reduced the runtime by around 50ms consistently. \nOne area where we believe signi.cant speedups may be gained are in extending the Actual Parameter Revisit \nAvoidance optimisation to orders 2 and above. Although some savings are still made at higher orders in \nthe current implementation, the amount of work which is potentially avoided can be increased exponentially \nby extending the optimisation to each order. Furthermore, in or\u00adder to keep the cost of checking the \ntermination condition low, it is currently somewhat conservative, but it is possible that a more thorough \nprocedure, if carefully engineered, could potentially de\u00adtect termination earlier. Exploring this trade-off \ncould provide sub\u00adstantial bene.ts. It is worth noting that both TRECS and TRAVMC could handle almost \nall of the examples without trouble, implying that further work on more taxing examples is needed to \nbetter understand where each algorithm breaks down. One direction in which both algo\u00adrithms struggled \nis a set of examples introduced by Kobayashi [10] known as Gn,m. When checked by the hybrid algorithm, \nthese ex\u00adamples require O(expn(m)) expansions to obtain type informa\u00adtion for non-terminals at the bottom \nof a hyper-exponential tree. Our new algorithm s performance improved markedly due to the Revisit Avoidance \noptimisation, checking G4,1 even faster than Kobayashi s linear-time algorithm GTRECS, although higher \nval\u00adues of n and m resulted in timeouts. We believe the speedup will be lifted to higher values of n \nwith a full implementation of the Revisit Avoidance optimisation. Such examples display the power of \nGTRECS fully and it is en\u00adcouraging to note that TRAVMC seems to be able to handle some such recursion \nschemes. In more realistic cases, TRAVMC outper\u00adforms GTRECS by several orders of magnitude. HORSC Model \nChecking For HORSC, we have generated some examples as the output of an abstraction procedure based on \nearlier work [17]. The abstrac\u00ad tion procedure operates on a pattern-matching recursion scheme (PMRS), \nwhich can be thought of as an instance of a simply-typed programming language with higher-order, recursive \nfunctions and pattern-matching over algebraic data-types. The abstract models that are produced are not \nstrictly HORSC, since they can have pat\u00adterns on the left-hand side of grammar rules which include free \nvariables (though such variables are not allowed to appear on the right-hand side of grammar rules), \nso they are .rst put through a translation which is detailed in the long version of this paper. For some \nexamples (those with numbers appended) we performed re\u00ad.nement of the abstraction and here we give the \ntimings for each round of model checking. See Table 4, where the columns are la\u00ad belled as before. In \norder to evaluate the usefulness of a primitive case analysis construct, which is afforded by HORSC, \nwe have compared the results of checking these HORSC model checking instances with corresponding HORS \nencodings (using TRAVMC in both cases). In each case, the HORS encoding of the HORSC is obtained by determinising \nand modelling the constants as projection functions. Unavoidably, this raises the order and arity, and \nhence worst-case complexity signi.cantly (see Remark 2). The time to check the original instance is given \nin column T and to check the encoding can be seen in the column TH . For some examples, particularly \nthe simpler ones, checking HORS is fast enough, but as the size and order of the example increases, this \napproach breaks down. We believe that this offers a compelling argument for the introduction of HORSC. \nPattern-match safety An important veri.cation problem in func\u00adtional programming is that of ensuring \nthat partial pattern matches never receive one of the missing cases and so are safe . Pattern\u00admatch safety \nis reducible to reachability, and the results for these can be seen at the top of the table. One simple \nexample is the list-processing function last, which assumes that its input is a non\u00adempty list. The CATCH \ntool [14] targets this veri.cation problem, and we have used some of the same examples: the Risers pro\u00adgram \nand Safe and FilePath libraries, which contain partial pattern matching that we verify to be safe. The \ninput HORSC is in both cases rather large, but the algorithm still terminates quickly. A more complex \nexample uses .lter to remove empty lists from the input before invoking head on the remaining lists (map-.lter-head). \nThe mkgroundterm program contains a counting function that sums the values of constants within a ground \nterm. By guarding the input to this partial function (by removing variables), we are able to prove that \nthe program is safe. Output term While pattern-match safety reduces to reachability, we can check more \ninteresting properties such as verifying some structure of the output of a function. The .lter-nonzero \nexample uses .lter with a nonzero function and veri.es that the output list contains no element equal \nto zero. For the map-plusone example, we add one to all elements of an input list of naturals and verify \nagain that the output list contains no zeroes. RSFD Kobayashi, Tabuchi and Unno model check recursion \nschemes with .nite data domains (RSFD) as part of their work [13]. RSFD form a sub-class of HORSC in \nwhich there are additional typing restrictions on the scrutinee appearing in each case analysis. Since \neach RSFD can be viewed as a HORSC, our tool is also able to solve the RSFD model checking problem. We \nhave compared the performance of our tool (column T ) versus the TRECS (version 1.32) tool of Kobayashi \net al. (column H ) in the second part of Table 4. The data reveals that, perhaps unsurprisingly, the \nspecialist RSFD checker is more ef.cient in all examples. Indeed, the partic\u00adular additional restrictions \nimposed in the de.nition of RSFD make the class particularly appealing from an algorithmic point of view, \nthough one which is not expressive enough for our purposes. How\u00adever, even at higher orders or with a \nlarge number of automaton states, our tool can solve almost all the example instances. 6. Related Work \nMSO Model Checking Problem The MSO model checking prob\u00adlem for order-n recursion schemes was .rst proved \nto be decidable (with optimal complexity of n-EXPTIME) by Ong [16]. His proof used game semantics to \nreduce the model checking problem to the solution of parity games over variable pro.les. To date, three \nother proofs are known, employing different methods to build appropri\u00adate parity games. Hague et al. \n[4] constructed con.guration graphs of collapsible pushdown automata; Kobayashi and Ong [12] used intersection \ntypes; and Salvati and Walukiewicz [19] appealed to Krivine machines. For the restricted class of trivial \nautomata (but for the full hierarchy of HORS), Aehlig [1] gave a decidability proof based on a novel \n.nite semantics for simply-typed lambda calculus. Kobayashi s proof of the same result, which was based \non intersection types [8], used a similar idea.  Practical Model Checking Algorithms for HORS As discussed \nin the Introduction, the .rst practical model checking algorithm for HORS against trivial automata was \nKobayashi s hybrid algo\u00adrithm [7], which was implemented in the model checker TRECS [9]. There are important \ndifferences between the hybrid algorithm and our traversal algorithm. The hybrid algorithm extracts intersec\u00adtion \ntypes by partial evaluation of the HORS followed by an over\u00adapproximation; whereas the traversal algorithm \n(following game semantics) harvests variable pro.les from the traversals in game semantics. Secondly \nthe hybrid algorithm uses a loop each itera\u00adtion being a greatest .xpoint construction starting from \na seed type environment which will eventually compute a fG,A-complete type environment in case (G, A) \nis a yes-instance. In contrast, the traversal algorithm builds a fG,A-complete type environment from \nbelow . Kobayashi s FoSSaCS 11 algorithm [10] is inspired by game se\u00ad mantics, even though the formal \ndevelopment of the algorithm is purely type-theoretic, and no concrete relationship with game se\u00admantics \nis known. A notable feature of the algorithm is its sim\u00adplicity, which consists of two .xpoint constructions, \n.rst least then greatest. Thanks to Rehof and Mogensen s optimisation [18], a con\u00ad sequence of the .xpoint \ndesign is its linear-time complexity in the size of the HORS, assuming that the other parameters are \n.xed. The main innovation of the algorithm lies in the least .xpoint com\u00adputation. Given a candidate \ntype environment G, for each subset G1 . G, and each F : . . G, more expansive versions of G1 and ., \nnamely, G ' and . ' (satisfying G1 :O G ' and . :P . ') re\u00adspectively, are selected such that G ' fR(F \n): . '. (The expansive relations :O and :P represent Opponent and Proponent moves respectively.) The \ntype environment that is constructed in the next iteration consists of G extended by G ' .{ F : . ' }, \nfor all F : . and for all such G ' and . '. Our traversal algorithm may be viewed as a process of approximating \na (canonical) fG,A-complete type envi\u00adronment from below. There are however two differences. First the \nsuccessive approximants are not related by containment. Secondly, our algorithm selects just one such \npair of G ' and . ', as determined by the traversal development. 7. Conclusions and Further Directions \nWe have presented a practical algorithm for the universal model checking problem for higher-order recursion \nschemes with cases (HORSC) against deterministic trivial automata. The algorithm is based on traversals, \nand is induced by the fully abstract game se\u00admantics of the recursion schemes, but presented as a goal-directed \nconstruction of derivations in an intersection and union type sys\u00adtem. We view HORSC model checking as \na suitable backend for an approach to verify functional programs (presented as pattern\u00admatching recursion \nschemes) via an abstraction-re.nement pro\u00adcedure. Preliminary experiments with our tool implementation \nTRAVMC indicate that the algorithm performs remarkably well on a number of small but realistic examples \ngenerating schemes with hundreds of rules. We hope to explore the scalability of our approach by verifying \nlarger examples of pure functional programs from the literature. 8. Acknowledgements We would like to \nthank our reviewers for their helpful comments on the .rst version of this paper. We would also like \nto thank Naoki Kobayashi for his assistance when benchmarking against his tools, and for offering an \nautomated approach for performing the translation from HORSC to HORS (see Section 5). References [1] \nKlaus Aehlig. A .nite semantics of simply-typed lambda terms for in.nite runs of automata. Logical Methods \nin Comp. Sci., 3(3), 2007. [2] Thomas Ball, Rupak Majumdar, Todd D. Millstein, and Sriram K. Rajamani. \nAutomatic predicate abstraction of C programs. In PLDI, pages 203 213, 2001. [3] Dirk Beyer, Thomas A. \nHenzinger, Ranjit Jhala, and Rupak Majumdar. The software model checker blast. STTT, 9(5-6):505 525, \n2007. [4] Matthew Hague, Andrzej S. Murawski, C.-H. Luke Ong, and Olivier Serre. Collapsible pushdown \nautomata and recursion schemes. In LICS, pages 452 461, 2008. [5] J. M. E. Hyland and C.-H. Luke Ong. \nOn full abstraction for PCF: I, II, and III. Inf. Comput., 163(2):285 408, 2000. [6] Teodor Knapik, Damian \nNiwinski, and Pawel Urzyczyn. Higher-order pushdown trees are easy. In FoSSaCS, pages 205 222, 2002. \n[7] Naoki Kobayashi. Model-checking higher-order functions. In PPDP, pages 25 36, 2009. [8] Naoki Kobayashi. \nTypes and higher-order recursion schemes for veri.cation of higher-order programs. In POPL, pages 416 \n428, 2009. [9] Naoki Kobayashi. http://www-kb.is.s.u-tokyo.ac.jp/ koba/trecs/. 2009. [10] Naoki Kobayashi. \nA practical linear time algorithm for trivial au\u00adtomata model checking of higher-order recursion schemes. \nIn FOS-SACS, pages 260 274, 2011. [11] Naoki Kobayashi and C.-H. Luke Ong. Complexity of model checking \nrecursion schemes for fragments of the modal mu-calculus. In ICALP (2), pages 223 234, 2009. [12] Naoki \nKobayashi and C.-H. Luke Ong. A type system equivalent to the modal mu-calculus model checking of higher-order \nrecursion schemes. In LICS, pages 179 188, 2009. [13] Naoki Kobayashi, Naoshi Tabuchi, and Hiroshi Unno. \nHigher-order multi-parameter tree transducers and recursion schemes for program veri.cation. In POPL, \npages 495 508, 2010. [14] Neil Mitchell and Colin Runciman. Not all patterns, but enough -an automatic \nveri.er for partial but suf.cient pattern matching. In Haskell 08: Proceedings of the .rst ACM SIGPLAN \nsymposium on Haskell, pages 49 60. ACM, September 2008. [15] Robin P. Neatherway, C.-H. Luke Ong, and \nSteven J. Ram\u00adsay. A traversal-based algorithm for higher-order model check\u00ading. Long version, available \nfrom: http://mjolnir.cs.ox. ac.uk/papers/traversal.pdf, 2012. [16] C.-H. Luke Ong. On model-checking \ntrees generated by higher\u00adorder recursion schemes. In LICS, pages 81 90, 2006. Long version (55 pp.) \nhttp://www.cs.ox.ac.uk/people/luke. ong/personal/publications/ntree.pdf. [17] C.-H. Luke Ong and Steven \nJ. Ramsay. Verifying functional programs with pattern matching algebraic data types. In POPL, pages 587 \n598, 2011. [18] Jakob Rehof and Torben \u00c6. Mogensen. Tractable constraints in .nite semilattices. Sci. \nComput. Program., 35(2):191 221, 1999. [19] Sylvain Salvati and Igor Walukiewicz. Krivine machines and \nhigher\u00adorder schemes. In ICALP (2), pages 162 173, 2011.  \n\t\t\t", "proc_id": "2364527", "abstract": "<p>Higher-order model checking - the model checking of trees generated by higher-order recursion schemes (HORS) - is a natural generalisation of finite-state and pushdown model checking. Recent work has shown that it can serve as a basis for software model checking for functional languages such as ML and Haskell. In this paper, we introduce <i>higher-order recursion schemes with cases</i> (HORSC), which extend HORS with a definition-by-cases construct (to express program branching based on data) and non-determinism (to express abstractions of behaviours). This paper is a study of the <i>universal HORSC model checking problem for deterministic trivial automata</i>: does the automaton accept every tree in the tree language generated by the given HORSC? We first characterise the model checking problem by an intersection type system extended with a carefully restricted form of union types. We then present an algorithm for deciding the model checking problem, which is based on the notion of <i>traversals</i> induced by the fully abstract game semantics of these schemes, but presented as a goal-directed construction of derivations in the intersection and union type system. We view HORSC model checking as a suitable backend engine for an approach to verifying functional programs. We have implemented the algorithm in a tool called <b>TravMC</b>, and demonstrated its effectiveness on a test suite of programs, including abstract models of functional programs obtained via an abstraction-refinement procedure from pattern-matching recursion schemes.</p>", "authors": [{"name": "Robin P. Neatherway", "author_profile_id": "81548018877", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P3804390", "email_address": "robin.neatherway@cs.ox.ac.uk", "orcid_id": ""}, {"name": "Steven J. Ramsay", "author_profile_id": "81548018878", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P3804391", "email_address": "steven.ramsay@cs.ox.ac.uk", "orcid_id": ""}, {"name": "Chih-Hao Luke Ong", "author_profile_id": "81548018879", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P3804392", "email_address": "luke.ong@cs.ox.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2364527.2364578", "year": "2012", "article_id": "2364578", "conference": "ICFP", "title": "A traversal-based algorithm for higher-order model checking", "url": "http://dl.acm.org/citation.cfm?id=2364578"}