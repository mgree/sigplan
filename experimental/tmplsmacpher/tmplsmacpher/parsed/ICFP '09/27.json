{"article_publication_date": "08-31-2009", "fulltext": "\n Automatically RESTful Web Applications Marking Modular Serializable Continuations Jay McCarthy Brigham \nYoung University jay@cs.byu.edu Abstract Continuation-based Web servers provide distinct advantages \nover traditional Web application development: expressive power and modularity. This power leads to fewer \nerrors and more interesting applications. Furthermore, these Web servers are more than proto\u00adtypes; they \nare used in some real commercial applications. Unfor\u00adtunately, they pay a heavy price for the additional \npower in the form of lack of scalability. We .x this key problem with a modular program transformation \nthat produces scalable, continuation-based Web programs based on the REST architecture. Our programs \nuse the same features as non-scalable, continuation-based Web programs, so we do not sacri.ce expressive \npower for performance. In particular, we allow continuation marks in Web programs. Our system uses 10 \npercent (or less) of the memory required by previous approaches. Categories and Subject Descriptors D.3.3 \n[Language Constructs and Features]: Control structures General Terms Languages, Performance, Theory Keywords \nContinuations, Stack Inspection, Web Applications 1. Introduction The functional programming community \nhas inspired Web appli\u00adcation developers with the insight that Web interaction corresponds to continuation \ninvocation (Hughes 2000; Queinnec 2000; Graham 2001). This insight helps to explain what Web applications \ndo and when ad hoc continuation capture patterns are erroneous (Krishna\u00admurthi et al. 2007). This understanding \nleads to more correct Web applications. Many continuation-based Web development frameworks try to apply \nthis insight directly by automatically capturing continuations for Web application authors. These frameworks \nare often frustrated because they limit modularity, are not scalable, or only achieve correct continuation \ncapture without more expressive power. Whole-program compilation systems are unusable by real\u00adworld developers \nbecause they sacri.ce modularity and interac\u00adtion with third-party libraries for performance and formal \nelegance (Matthews et al. 2004; Cooper et al. 2006). Modular compilation systems are unattractive to \nreal world developers when they do Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 09, August 31 September 2, 2009, Edinburgh, Scotland, UK. Copyright \n&#38;#169; 2009 ACM 978-1-60558-332-7/09/08. . . $10.00 not add expressive power (Pettyjohn et al. 2005; \nThiemann 2006). Continuation-based Web servers are unusable by real world devel\u00adopers, though they add \nmore expressive power, because they are inherently not scalable (Ducasse et al. 2004; Krishnamurthi et \nal. 2007). This paper presents a modular program transformation that pro\u00adduces scalable Web applications \nand offers more expressive power than existing modular systems. Web applications written using our system \ncan of.oad all state to clients the gold standard of scalability or, if necessary, keep state on the \nserver and use ten times less memory.  2. Background The largest problem Web developers solve is imposed \nby the state\u00adlessness of HTTP: when a server responds to a client s request, the connection is closed \nand the Web program on the server ex\u00adits. When the client makes a subsequent request, the request de\u00adlivered \nto the server must contain enough information to resume the computation. The insight of functional programmers \nis that this information is the continuation. Traditional Web programmers call this representational \nstate transfer (REST) (Fielding and Taylor 2002).1 It is naturally scalable due to the lack of per-session \nstate. Session state is poison to scalability because each session has an absolute claim on server resources. \nThere is no sound way to reclaim space since dormant sessions may reactivate at any time. This is clearly \ninef.cient. Consequently, unsafe and ad hoc resource policies, like timeouts, are used to restore some \nscalability. The scalability of REST also comes at a price in the form of programming dif.culty. We will \ndemonstrate this by porting a calculator to the Web.2 (de.ne (calc) (display (+ (prompt \"First:\")(prompt \n\"Second:\")))) We must break this single coherent function into three different functions to create a \nWeb application. Each function represents a distinct part of the control-.ow of the application: entering \nthe .rst number, entering the second, and displaying their sum. (de.ne (calc)(web-prompt \"First:\" get-2nd \n#f)) (de.ne (get-2nd .rst)(web-prompt \"Second:\" sum .rst)) (de.ne (sum .rst second)(display/web (+ second \n.rst))) 1 Unfortunately, modern Web programmers have forgotten this de.nition of REST. They use the acronym \nREST to refer to a resource-based URL structure where database operations (like create, replace, update, \nand delete) are mapped to suggestive combinations of URLsand HTTP request types (like PUT, POST, GET,and \nDELETE). We will not use REST in this way. 2 All program examples are written in PLT Scheme.  (de.ne \n(calc) ;; new-session allocates server-side storage (web-prompt \"First:\" get-2nd (new-session))) (de.ne \n(get-2nd session-id .rst) ;; session-set! modi.es server-side storage (session-set! session-id .rst .rst) \n(web-prompt \"Second:\" sum session-id)) (de.ne (sum session-id second) ;; session-lookup references server-side \nstorage (de.ne .rst (session-lookup session-id .rst)) (display/web (+ second .rst))) Figure 1. REST Without \nAll the REST The continuation is encoded by the developer in the second argument of web-prompt and the \nfree variables of the continuation in the third argument. Unfortunately, it is tiresome in most Web programming \nenviron\u00adments to marshal all data to the client and back but convenient to access the server-side store \n(through session objects and databases), so developers use this naturally RESTful style in an entirely \nnon-RESTful way. (See Figure 1.) The Web s RESTful style is a form of continuation-passing style (CPS) \n(Fischer 1972). There are well-known transformations from direct style code into CPS that allow Web applications \nto be written in the natural way but converted into the scalable style by the server before execution. \nMatthews et al. (2004) gave an automatic translation from di\u00adrect style programs into traditional Web \napplications. This tool per\u00adforms a CPS transformation, .-lifting, defunctionalization, and a store-passing \nstyle transformation (to capture the store as a cookie value).ThesedirectstyleWebapplicationsareentirely \nRESTfulbe\u00adcause the lexical environment and store are transferred to the user between interactions. Unfortunately, \nthe CPS transformation is not modular; the entire code-base, including libraries, must be transformed. \nThus, this technique is not feasible in applications that rely on unmodi.able libraries or separate compilation. \nThe PLT Web Server by Krishnamurthi et al. (2007) does not have this problem. It enables direct style \nWeb applications written in PLT Scheme through .rst-class continuations. These implicit continuations \navoid the CPS transformation and thereby provide modularity. However, the PLT implementation technique \nsacri.ces the REST architecture. Continuations (and the environments they close over) in PLT Scheme cannot \nbe serialized into an external format or transferred to the client. Thus, the PLT Web Server stores continuations \nin the server s memory and provides the client with a unique identi.er for each continuation. These continuations \nare per-session server state, and their unique identi.ers are new GC roots. Because there is no sound \nway to reclaim these continuations, they must be retained inde.nitely or unsoundly deleted. The memory \nproblems associated with this un-RESTful pol\u00adicy are well known. For example, a recent ICFP experience \nreport (Welsh and Gurnell 2007) concurs with our experience managing the CONTINUE service (Krishnamurthi \n2003) by reporting unrea\u00adsonable memory usage. CONTINUE is a Web application for pa\u00adper submissions, \nreviews, and PC meetings, so there is no intrin\u00adsic reason for this memory usage. We have experimented \nwith a number of stopgap strategies, such as explicit continuation man\u00adagement through the primitive \nsend/forward (Krishnamurthi et al. (de.ne (fact n) (if (zero? n) (begin (display (c-c-m fact)) 1) (w-c-m \nfact n (* n (fact (sub1 n)))))) (fact 3) . console output: (123) computed value: 6 (de.ne (fact-tr n \na) (if (zero? n) (begin (display (c-c-m fact)) a) (w-c-m fact n (fact-tr (sub1 n)(* na))))) (fact 3) \n. console output: (1) computed value: 6 Figure 2. Factorial with Continuation Marks 2007) and a Least \nRecently Used (LRU) continuation management strategy. While useful remedies for some symptoms, they are \nnot solutions. In contrast, the work presented herein reduces memory consumption by ten times for these \nsame Web applications. Despite its memory problems, the PLT Web Server provides a valuable Web application \nframework, in part because of its expres\u00adsive features, like continuation marks. Many programming languages \nand environments allow access to the runtime stack in one way or another. Examples include Java security \nthrough stack inspection, privileged access for debuggers in .NET, and exception handlers in many languages. \nAn abstraction of all these mechanisms is provided by PLT Scheme in continuation marks (Clements et al. \n2001). Using the with-continuation-mark (w-c-m) language form, a developer can attach values to the con\u00adtrol \nstack. Later, the stack-walking primitive current-continuation\u00admarks (c-c-m) can retrieve those values \nfrom the stack. Continu\u00adation marks are parameterized by keys and do not interfere with Scheme s tail-calling \nrequirements. These two mechanisms allow marks to be used without interfering with existing code. A pedagogic \nexample of continuation mark usage is presented in Figure 2. fact is the factorial function with instrumentation \nusing continuation marks: w-c-m records function arguments on the stack and c-c-m collects them in the \nbase case. fact-tr is a tail-recursive version of factorial that appears to be an identical usage of \ncontinu\u00adation marks, but because they preserve tail-calling space usage, the intermediate marks are overwritten, \nleaving only the .nal mark. Continuation marks are useful in all programs, but are partic\u00adularly useful \non the Web. If the control stack is isomorphic to the user s position in the application, then continuation \nmarks can be used to record information about where the user has gone and is going. For example, in CONTINUE \nwe use a continuation mark to hold the identity of the user. The essence of this technique is shown in \nFigure 3. This mark is stored on login and retrieved inside display-site for tasks like paper rating. \nThis is more convenient than threading the state throughout the application and allows a trivial implementation \nof user masquerading, so an administrator can debug a user s problems, and delegation, so a reviewer \ncan assign a sub-reviewer limited powers. Web application developers are torn between the REST archi\u00adtecture, \ndirect style code, modularity, and expressive features, like  (de.ne (start-server ireq) (w-c-m current-user \n(show-login)(display-site))) (de.ne (who-am-i) (.rst (c-c-m current-user))) (de.ne (delegate email paper) \n(w-c-m current-user (list delegate paper (who-am-i)) (email-continuation-url email) (display-paper paper))) \n(de.ne (masquerade user) (if (symbol=? (who-am-i) admin) (w-c-m current-user user (display-site)) (access-denied))) \nFigure 3. Marks in Web Applications continuation marks. In this paper, we present a modular program transformation \nthat automatically produces RESTful versions of di\u00adrect style Web programs that utilize continuation \nmarks.  3. Transformation Intuition Our modular RESTful transformation is based on one from Pet\u00adtyjohn \net al. (2005). Unfortunately, their transformation does not support continuation marks in the input language, \nso it is not suf\u00ad.cient for our purposes. Our transformation is structurally similar to theirs, so we \nreview their transformation before turning to our contribution. The Pettyjohn et al. (2005) transformation \nrelies on the modular Administrative Normal Form (ANF) transformation (Flanagan et al. 2004) and stack \ninspection to simulate call/cc. ANF is a canonical form that requires all function arguments to be named. \nThis has the implication that the entire program is a set of nested let expressions with simple function \ncalls for bodies. If the lets are expanded into .s, then the continuation of every expression is syntactically \nobvious. Any expression can be modularly transformed into ANF without modifying the rest of the program. \nThe main insight of Pettyjohn et al. (2005) was that c-c-m can capture the continuation, just like call/cc, \nif the components of the continuation are installed via w-c-m. Their transformation does this by duplicating \nthe continuation into marks. This is easy be\u00adcause ANF makes these continuations obvious, and the tail-calling \nproperty of marks mirrors that of continuations themselves, so the two stay synchronized. Their work \nis a testament to the power of continuation marks; we will review the essence of the transformation. \nFunction applications, like (ka), are transformed as (k (w-c-m 0 ka)) where 0 is a special key known \nonly to the transformation. This effectively duplicates the continuation in a special mark. Then (call/cc \ne) is transformed as (e (let ([ks (c-c-m 0)]) (. (x)(abort (resume ks x))))) where resume restores the \ncontinuation record from the 0 marks into an actual control stack. resume must also reinstall the 0 marks \nso subsequent invocations of call/cc are correct. (de.ne (resume l x) (if (empty? l) x (let ([k (.rst \nl)] [l (rest l)]) (k (w-c-m 0 k (resume l x)))))) This transformation produces RESTful Web applications, \nbe\u00adcause standard modular .-lifting and defunctionalization transfor\u00admations encode all values into serializable \nrepresentations that can be sent to the client. The great irony of the Pettyjohn et al. (2005) transformation \nis that, while it shows the immense power of continuation marks, it does not support continuation marks \nin the input language; it cannot be used for Web applications that use marks themselves. Furthermore, \nit is not trivial to add support for continuation marks in the transformation: a semantic insight is \nnecessary this is our formal contribution, in addition to the other practical extensions we have made. \n3.1 Capturing Marks The most intuitive strategy for supporting marks is to simply cap\u00adture all the continuation \nmarks whenever the marks that record the continuation are captured. However, this is not possible. Continuation \nmarks are parameterized by a key. When a devel\u00adoper uses c-c-m, she or he must provide a key and only \nmarks associated with that key are returned. If a mark is added with a unique, or unknowable, key, such \nas a random value or uninterned symbol (a gensym ), then it cannot be extracted by the context it wraps. \nThis is an essential feature of continuation marks: they are invisible to the uninitiated. Without this \nproperty, the behavior of an expression could drastically change with a change to its context: new results \ncould mysteriously return from c-c-m without any ex\u00adplanation. This would have a dynamic scope level \nof grotesqueness to it. We must record the continuation marks, as we record the con\u00adtinuation components, \nso they can be extracted when performing continuation capture. A simple strategy is to transform all \ninstances of (w-c-m kve)into (w-c-m kv (w-c-m 0 (cons k v) e)) where 0 is a key known only to the transformation. \nIt seems straightforward to adapt the transformation so call/cc captures and restores these marks as \nwell (e (let ([ks (c-c-m 0)] [cms (c-c-m 0)]) (. (x)(abort (re-mark cms (. () (resume ks x))))))) where \nre-mark is similar to resume: (de.ne (re-mark l e) (if (empty? l)(e) (let* ([cm (.rst l)] [l (rest l)] \n[m (car cm)] [v (cdr cm)]) (w-c-m mv (w-c-m 0 (cons mv)(re-mark l e)))))) While simple and elegant, these \nstrategies are incorrect.  3.2 Reinstalling Marks The .rst problem is that resume and re-mark do not \ninteract cor\u00adrectly. Consider the following program: (f (w-c-m k1 v1 (g (call/cc e)))) This is transformed \ninto (f (w-c-m 0 f (w-c-m k1 v1 (w-c-m 0 (cons k1 v1) (g (w-c-m 0 g (e (let ([ks (c-c-m 0)] [cms (c-c-m \n0)])  (. (x)(abort (re-mark cms (. () (resume ks x))))))))))))) If e calls the continuation with a \nvalue, x, it reduces to (w-c-m k1 v1 (w-c-m 0 (cons k1 v1) (f (w-c-m 0 f (g (w-c-m 0 gx)))))) The mark \nfor k1 is lifted outside of f . The problem is that even though the 0 and 0 marks are recorded in the \nsame stack frames, they are collected and installed sepa\u00adrately: the 0s are put before the 0s. We can \ncollect these together by extracting multiple keys at once. We correct the transformation of (call/cc \ne)as (e (let ([k*cms (c-c-m 0 0)]) (. (x)(abort (resume k*cms x))))) When c-c-m is given n arguments, \nthe marks are returned as a list of frames, where each frame is a list of length n where (list-ref l \ni) is the value of associated with the i argument or #f if none exists. Naturally, resume must combine \nthe previous resume and re-mark operations. (de.ne (resume l x) (if (empty? l) x (let* ([M (car l)] [l \n(cdr l)] [k (car M)] [cm (cadr M)]) (cond [(and k (not cm)) (k (w-c-m 0 k (resume l x)))] [(and (not \nk) cm) (let ([m (car cm)] [v (cdr cm)]) (w-c-m mv (w-c-m 0 cm (resume l x))))] [else (resume (list* (list \nk #f)(list #f cm) l) x)])))) Even though the marks are now in the correct order, there is still an error \nin our transformation.  3.3 The Algebra of Marks Consider the transformation of the following program: \n(w-c-m k1 v1 (w-c-m k2 v2 e)) This is transformed as (w-c-m k1 v1 (w-c-m 0 (cons k1 v1) (w-c-m k2 v2 \n(w-c-m 0 (cons k2 v2) e)))) Because continuation marks respect the tail-calling properties of Scheme, \nif a frame already contains a mark for a key, the mark is overwritten. Thus, the following are equivalent: \n (w-c-m kv (w-c-m ku e)) and (w-c-m ku e) Similarly, marks with different keys share the same frame. \nTherefore, the following are equivalent: (w-c-m xv (w-c-m yu e)) and (w-c-m yu (w-c-m xv e)) Thus, the \ntransformation is equivalent to (w-c-m k1 v1 (w-c-m k2 v2 (w-c-m 0 (cons k1 v1)(w-c-m 0 (cons k2 v2) \ne)))) which is equivalent to (w-c-m k1 v1 (w-c-m k2 v2 (w-c-m 0 (cons k2 v2) e))) e ::= a | (we) | (letrec \n([sv]) e) | (w-c-m aae) | (c-c-m [a]) | (match wl) | (abort e) | (call/cc w) l ::= [(Kx)e] a ::= w | \n(Ka) w ::= v | x v ::= (.(x) e) | (Kv) | s | ..E x . Variables s . References where Variables n References \n= \u00d8 E. ::= (w-c-m vv' Ev,.) where v/. . | [] | (v E) S ::= \u00d8| S[s . v]    Figure 4. SL Syntax We \nve lost the record of the k1 mark in the 0 mark. One solution is to maintain a map from keys to values \nin 0 marks and explicitly update that map with the continuation mark transformation. For example, we \nwill transform (w-c-m kve)into (w-c-m kv (c-w-i-c-m 0 (. (cms) (w-c-m 0 (map-set cms k v) e)) empty)) \nwhere (c-w-i-c-m key-v proc default-v)(c-w-i-c-m = call-with\u00adimmediate-continuation-mark) calls proc \nwith the value associated with key-v in the .rst frame of the current continuation. This is the value \nthat would be replaced if this call were replaced with a call to w-c-m. If no such value exists in the \n.rst frame, default-v is passed to proc. The call to proc is in tail position. This function can be implemented \nusing just w-c-m and c-c-m (Clements et al. 2008). After changing resume to operate on mark sets, we \nhave a cor\u00adrect transformation of continuation marks in the input language. The rest of the transformation \ndoes not need to change dramati\u00adcally for the entire PLT Scheme language. Now RESTful Web appli\u00adcations \ncan be written in direct style.  4. Formal Treatment Armed with intuition, we present the continuation \n(mark) recon\u00adstruction transformation formally. 4.1 The Source Language The language in Figure 4, dubbed \nSL for source language, is a mod\u00adi.ed version of A-Normal form (ANF) (Flanagan et al. 2004). It uses \n. instead of let. Furthermore, we allow applications of arbi\u00adtrary length. The language is extended with \ncall/cc, abort, letrec, algebraic datatypes, and continuation marks. This is different from the source \nlanguage of Pettyjohn et al. (2005) by including continu\u00adation marks and abort, which were included in \nthe target language there. Algebraic datatypes are essential to using marks; abort is in\u00adcluded for consistency \nwith the target language. X denotes zero or more occurrences of X. Instances of algebraic datatypes are \ncreated with constructors (K, Km) and destructured with match. We leave the actual set of constructors \nunspeci.ed, though we assume it contains the standard list constructors cons and nil.  (1) S/E[((.(x) \ne) v)] - .SL S/E[e[x . v]] (2) S/E[(match (Kv) l)] - .SL S/E[e[x . v]] where [(Kx)e] . l and is unique \n (3) S/E[(letrec ([sv]) e)] - .SL S[s . v]/E[e] (4) S/E[(sv)] - .SL S/E[e[x . v]] where S(s)=(.(x) e) \n (5) S/E[(match sl)] - .SL S/E[(match S(s) l)] S/E[(w-c-m vk v1 S/E[(w-c-m vk v2 (6) E ' vk [(w-c-m \nvk v2 e)])] - .SL E ' vk [e])] where E ' vk contains only w-c-ms (7) S/E[(w-c-m vk v1 v2)] - .SL S/E[v2] \n(8) S/E[(c-c-m [v])] - .SL S/E[.v(E, (nil))] (9) S/E[(abort e)] - .SL S/e (*) S/E[(call/cc v)] - .SL \nS/E[(v..E)] S/E[(..E ' v)] - .SL S/E ' [v] .vs(E)= .vs(E, (nil)) .vs([],vl)= vl .vs((v E),vl)=(cons vl \n.vs(E, (nil)) .vs((w-c-m vk vv E),vl)= .vs(E, (cons (cons vk vv ) vl))) if vk . vs .vs((w-c-m vk vv E),vl)= \n.vs(E,vl) otherwise Figure 5. SL Semantics The operational semantics is speci.ed via the rewriting system \nin Figure 5. It is heavily based on target language semantics of Pet\u00adtyjohn et al. (2005). The .rst rule \nis the standard \u00dfv-rewriting rule for call-by-value languages (Plotkin 1975). The second handles al\u00adgebraic \ndatatypes. Rules 3, 4, and 5 specify the semantics for letrec. Bindings es\u00adtablished by letrec are maintained \nin a global store, S.For sim\u00adplicity, store references (s) are distinct from identi.ers bound in lambda \nexpressions (Felleisen and Hieb 1992). Furthermore, to simplify the syntax for evaluation contexts, store \nreferences are treated as values, and dereferencing is performed when a store ref\u00aderence appears in an \napplication (rule 4) or in a match expression (rule 5). The next six rules implement the continuation-related \noperators. Recall that continuation marks allow for the manipulation of con\u00adtexts. Intuitively, (w-c-m \nkve) installs a mark for the key k as\u00adsociated with the value v into the continuation of the expression \ne, while (c-c-m [v]) recovers a list of all marks for the keys in v embedded in the current continuation. \nTo preserve proper tail-call semantics, if a rewriting step results in more than one w-c-m of the same \nkey, surrounding the same expression, the outermost mark is replaced by the inner one. Similarly, marks \nfor different keys are considered to be a single location. The mark interleaving requirement is enforced \nby a grammar for evaluation contexts that consists of one parameterized non\u00adterminal. The parameter of \nE (.) represents the keys that are not allowed to appear in the context. Thus, multiple adjacent w-c-m \nexpressions (of the same key) must be treated as a redex. When e ::= a | (we) | (letrec ([sv]) e) | (w-c-m \naae) | (c-c-m [a]) | (match wl) | (abort e) l ::= [(Kx)e] a ::= w | (Ka) w ::= v | x v ::= (.(x) e) \n| (Kv) | s x . Variables s . References where Variables n References = \u00d8 E. ::= (w-c-m vv ' Ev,.) where \nv/. . | [] | (v E) S ::= \u00d8| S[s . v] Figure 6. TL Syntax such a redex is encountered, the redundant marks \nare removed, starting with the outermost (rule 6). Marks that surround a value are discarded after the \nevaluation of the subterm (rule 7). The evaluation of c-c-m employs the function . to extract the marks \nof the keys from the evaluation context (rule 8). Marks are extracted in order, such that c-c-m evaluates \nto a list of lists of pairs of keys and their value, starting with the oldest. The evaluation rules for \ncontinuations (rules * and r)are stan\u00addard; abort abandons the context (rule 9) to facilitate reimplement\u00ading \ncontinuations.  4.2 The Target Language The target language (TL) in Figure 6 is identical to SL, except \nthat call/cc has been removed along with the continuation values associated with it. The semantics (Figure \n7) is also identical, except for the removal of rules * and r for continuation capture and application. \n 4.3 Replacing Continuation Capture Following Pettyjohn et al. (2005), we de.ne our translation (Fig\u00adure \n9) from SL to TL as CMT ,for continuation mark transform. The translation decomposes a term into a context \nand a redex by thegrammarinFigure8. We prove that the decomposition is unique and thus the transla\u00adtion \nis well-de.ned. Lemma 1 (Unique Decomposition). Let e . SL. Either e . a or e = E[r] for some redex r. \nThe translation rules are straightforward, except for application, continuation capture, values and marks. \nContinuation values are transformed using a variation of the rule for call/cc. call/cc uses c-c-m to \nreify the context and applies resume to reconstruct the context after a value is supplied. abort is used \nin the continuation\u00adas-closure to escape from the calling context, as the SL semantics does. Continuations \nrely on the insertion of marks to capture the continuation as it is built. This strategy employs the \nproperty of ANF that every continuation is obvious, in that it is the value in the function position \nof function applications. The translation marks each application, using the 0 mark to record the continuation. \n S/E[((.(x) e) v)] S/E[(match (Kv) l)] S/E[(letrec ([sv]) e)] S/E[(sv)] S/E[(match sl)] S/E[(w-c-m \nvk v1 E ' vk [(w-c-m vk v2 e)])] ' (1) - .TL (2) - .TL where (3) - .TL (4) - .TL where (5) - .TL (6) \n- .TL S/E[e[x . v]] S/E[e[x . v]] [(Kx)e] . l and is unique S[s . v]/E[e] S/E[e[x . v]] S(s)=(.(x) e) \nS/E[(match S(s) l)] S/E[(w-c-m vk v2 E ' vk [e])] where E vk contains only w-c-ms S/E[(w-c-m vk v1 v2)] \nS/E[(c-c-m [v])] S/E[(abort e)] (7) - .TL (8) - .TL (9) - .TL S/E[v2] S/E[.v(E, (nil))] S/e .vs(E)= .vs(E, \n(nil)) .vs([],vl)= vl .vs((v E),vl)=(cons vl .vs(E, (nil)) .vs((w-c-m vk vv E),vl)= .vs(E, (cons (cons \nvk vv ) vl))) if vk . vs .vs((w-c-m vk vv E),vl)= .vs(E,vl) otherwise Figure 7. TL Semantics r ::= (w) \n| (letrec ([sw]) e) | (w-c-m aaw) | (c-c-m [a]) | (match wl) | (abort e) | (call/cc e) E. ::= (w-c-m \nvv ' Ev,.) where v/. . | [] | (v E) Figure 8. Translation Decompositions Similarly, all continuation \nmarks are recorded with the 0 mark. Later, these marks will be collected by c-c-m and used to reproduce \nthe context. The resume function (Figure 10) is used by the translated pro\u00adgram. resume faithfully reconstructs \nan evaluation context from a list of pairs of continuation functions and mark sets. It traverses the \nlist and recursively applies the functions from the list and rein\u00adstalls the marks using restore-marks. \nIt restores the original 0 and 0 marks as well so that the context matches exactly and subsequent call/cc \noperations will succeed. Variables and Values: CMT [x]= x CMT [s]= s CMT [(.(x) e)] = (.(x) CMT [e]) \nCMT [..E]=(kont/ms .{D,o}(CMT [E], (nil))) CMT [(Ka)] = (K CMT [a]) Redexes: CMT [(w)] = (CMT [w]) CMT \n[(letrec ([sw]) e)] = (letrec ([s CMT [w]]) CMT [e]) CMT [(w-c-m e)] = (w-c-m CMT [e]) CMT [(c-c-m [a])] \n= (c-c-m [CMT [a]]) CMT [(,atch wl)] = (match CMT [w] CMT [l]) CMT [[(Kx)e]] = [(Kx)CMT [e]] CMT [(abort \ne)] = (abort CMT [e]) CMT [(call/cc w)] = (CMT [w] kont) kont =(kont/ms (c-c-m [0 0])) kont/ms =(.(m)(.(x) \n(abort (resume m x)))) Contexts: CMT [[]] = [] CMT [(w E)] = (K (w-c-m 0 K CMT [E])) where K =(.(x)(CMT \n[w] x)) CMT [(w-c-m vv ' E)] = (w-c-m vv ' (c-w-i-c-m 0 (. (cms) (w-c-m 0 (map-set cmsv v ' ) CMT [E])))) \nCompositions: CMT [E[r]] = CMT [E][CMT [r]] Figure 9. Translation from SL to TL  4.4 Correctness Let \n( v if \u00d8/p . * v evalx(p)= .\u00d8/p . * ... Theorem 1. CMT [evalSL(p)] = evalTL(CMT [p]) Overview. If a source \nterm reduces in k steps, then its translation will reduce in at least k steps, such that the result of \nthe translation s reduction is the translation of the source s result. This is proved by induction on \nk. The base case is obvious, but the inductive case must be shown by arguing that TL simulates each step \nof SL in a .nite number of steps. This argument is captured in the next lemma. Lemma 2 (Simulation). \nIf S/E[e] .SL S ' /E ' [e ' ] then CMT [S]/CMT [E[e]] .+ TL CMT [S ' ]/CMT [E ' [e ' ]] Overview. This \nis proved by a case analysis of the .SL re\u00adlation. It requires additional lemmas that cover the additional \n (letrec ([resume (. (lv) (match l [(nil) v] [(cons ms l) (match ms [(nil)(resume l v)] [(cons (cons \n0 k) nil) (k (w-c-m 0 k (resume l v)))] [(cons (cons 0 cms) nil) (restore-marks cms (. () (w-c-m 0 cms \n(resume l v))))] [(cons (cons 0 k)(cons 0 cms)) (w-c-m 0 k (restore-marks cms (. () (w-c-m 0 cms (resume \nl v)))))] [(cons (cons 0 cms)(cons 0 k)) (w-c-m 0 k (restore-marks cms (. () (w-c-m 0 cms (resume l v)))))])]))] \n[restore-marks (. (cms thnk) (match cms [(nil)(thnk)] [(cons (cons mv) cms) (w-c-m mv (restore-marks \ncms thnk))]))] [c-w-i-c-m (. (k proc default-v) ...)] [map-set (. (map k v) ...)]) ...) Figure 10. Necessary \nDe.nitions steps that .TL takes to reduce a program to images of sub\u00adexpressions/contexts of the original. \nLemma 3 (Compositionality). TL CMT [S]/CMT [E][e] CMT [S]/CMT [E][CMT [e]] . * Sketch. CMT [] only introduces \nw-c-m into the context or abstracts the continuation of an argument to a function. These additional contexts \nare eventually erased as the argument is evaluated or the surrounding w-c-m is removed as a value is \nreturned. Lemma 4 (Reconstitution). CMT [S]/(resume .{D,o}(CMT [E ' ]) CMT [v]) .+ ' TL CMT [S]/CMT [E \n][CMT [v]] Proof. We proceed by cases on the structure of E ' . Suppose E ' =[],then CMT [E ' ]= [],so \n. returns (nil) and resume returns CMT [v], which is equal to [][CMT [v]]. Suppose E ' =(w E),then CMT \n[] expands to a mark that captures E ' as a function abstracted over E in the 0 mark, which is restored \nby resume. E is preserved by induction. Suppose E ' =(w-c-m vv ' E),then CMT [] expands to a mark that \ncaptures v and v ' in the 0 mark, which is restored by resume. E is preserved by induction. Lemma 5 (Substitution). \nCMT [e[x . v]] = CMT [e][x .CMT [v]] Sketch. The CMT [] transformation is applied to every subexpres\u00adsion \nin the transformed expression. Thus, the vs substituted in will eventually have CMT [] performed on them \nif x appears in e.If an identi.er appears in the argument to CMT [], it is not transformed, but left \nas is, so it could be substituted after the transformation with the CMT []of the value v.  4.5 Defunctionalization \nWe do not need to extend the defunctionalization de.ned by Pet\u00adtyjohn et al. (2005) in any interesting \nway, but in our implemen\u00adtation we have extended it in the trivial way to keyed continuation marks and \nthe numerous PLT . forms.  5. Extensions Continuation marks, however, are not the only expressive features \nof PLT Scheme we aim to support. We discuss how to support .uid state, Web cells, advanced control .ow, \nand continuation management in turn. 5.1 Parameters Web applications often use .uid state. State is .uid \nwhen it is bound only in a particular dynamic context. The continuation mark demonstration from the introduction \n(Figure 3) is an application of .uid state: when the user authenticates to CONTINUE, the current user \nidentity is bound in the dynamic context of the display\u00adsite call. Every link presents the user with \na new page using the same user identity. If another type of state were used, it would be more dif.cult \nto program or would prevent certain kinds of user behavior. For example, if the environment were used, \nthen the user identity would need to be an argument to every function; if the store were used, then there \nwould be only one user identity for all URLs associated with a session, thereby disallowing a free implementation \nof masquerading and delegation. PLT Scheme provides a mechanism for .uidly bound state: pa\u00adrameters. \nParameters are effectively a short-hand for continuation mark operations. (parameterize pve)wraps e in \na continuation mark for the key associated with p bound to v. The parameter p can then be referenced \ninside e and will evaluate to whatever the closest mark is. Unfortunately, parameters are not implemented \nthis way, be\u00adcause they also provide ef.cient lookup, thread-safety, and thread\u00adlocal mutation. Instead, \nthere is a single continuation mark key for all parameters. This key is not serializable, so our mark \nrecording and reconstitution strategy fails. The key is included in the captured continuation structure \nbut destroys its serializability. We compen\u00adsate by providing an implementation of parameters using a \ndistinct serializable key for each parameter. This way, Web servlets can ef\u00adfectively use .uid state, \nlike parameters.  5.2 Web Cells Sometimes .uid state (parameters), the environment (lexical vari\u00adables), \nand the store (mutable structures) are all inappropriate for Web applications. A simple example is maintaining \nthe preferred sort state of a list while the user is exploring the application, with\u00adout forcing the \nuser to have one sort state per session. If .uid state is used, then the entire application must be written \nas tail calls to ensure that the dynamic extent of sort state modi.ca\u00adtions is the rest of the session. \nThis means the program must be written in CPS. If the lexical environment is used, then the sort state \nmust be threaded throughout every part of the application, including those that are not related to the \nsorted list. This means the program must be written in store-passing style, an invasive and nonmodular \nglobal program transformation. If the store is used, then a single sort state will be used for all browsers \ndisplaying the same list. This means the user will not be able to use the Web interactions provided by \nthe browser, such as Open in New Window, to compare different sorts of the same list.  Web cells (McCarthy \nand Krishnamurthi 2006) provide a kind of state appropriate for the sort state. Semantically, the set \nof Web cells is a store-like container that is part of the evaluation context; however, unlike the store, \nit is captured when continuations are captured and restored when they are invoked. Since continuation \ncapture corresponds to Web interaction, this state is .uid over the Web interaction tree, rather than \nthe dynamic call tree. It is easy to add support for Web cells in our system. We have a thread-local \nbox that stores the cells for the execution of a continuation. Whenever a continuation is captured, these \nare saved. Our serializable continuation data structure contains (a) the continuation components, (b) \nthe continuation marks, and (c) the Web cell record. Each of these are restored when the continuation \nis called.  5.3 Request Handlers send/suspend is the fundamental operator of the PLT Web Server. This \nfunction captures the current continuation, serializes it into a URL, and calls a display function with \nthe URL. This works well for applications with a linear control-.ow. However, most applica\u00adtions have \nmany possible continuations (links) for each page, and therefore are dif.cult to encode with send/suspend. \nWe can simulate this control-.ow by dispatching on some extra data attached to a single continuation \ncaptured by send/suspend. This dispatching pattern is abstracted into send/suspend/dispatch (s/s/d) (Hopkins \n2003). This function allows request handling pro\u00adcedures to be embedded as links; when clicked, the request \nis given to the procedure, and the procedure returns to s/s/d s continuation. For example, consider the \nservlet (de.ne (show message) (send/suspend/dispatch (. (embed/url) (html (h1 ,message) (a ([href ,(embed/url \n(. (show \"One\")))]) \"One\") (a ([href ,(embed/url (. (show \"Two\")))]) \"Two\"))))) This servlet generates \na page with two links: one for each call to embed/url. When clients click on either, they are sent to \nan identical page that contains a header with the link text. s/s/d can either build a hash-table and \nperform dispatching with a single continuation, or it may be written (Krishnamurthi et al. 2007) succinctly \nas (de.ne (send/suspend/dispatch mk-page) (let/cc application-context (local [(de.ne (embed/url handler) \n(let/ec mk-page-context (application-context (handler (send/suspend mk-page-context)))))] (send/back \n(mk-page embed/url))))) This encoding employs a clever use of continuations to embed the handler in the \ncontinuation captured by send/suspend.When embed/url is called, it captures the continuation of mk-page, \nmk\u00adpage-context, which is in the process of constructing a link. em\u00adbed/url provides this link by giving \nthe continuation mk-page\u00adcontext to send/suspend, which calls its argument with a link to send/suspend \ns continuation. embed/url is arranged so that when send/suspend returns, its return value is given to \nthe handler, whose return value is given to the caller of send/suspend/dispatch,via application-context. \nThis encoding generates one continuation per call to s/s/d (application-context) and one escape ( one-shot \n) continuation per call to the embedding procedure (mk-page-context). We can do better with serializable \ncontinuations. Because ev\u00aderything is serializable and manipulable, we can implement s/s/d as (de.ne \n(send/suspend/dispatch mk-page) (call-with-serializable-current-continuation (. (application-context) \n(de.ne (embed/url handler) (de.ne application+handler-context (kont-cons handler application-context)) \n(kont.url application+handler-context)) (send/back (mk-page embed/url))))) Like before, this implementation \n.rst captures the continuation of s/s/d. embed/url accepts a procedure and returns a continuation serialized \ninto a URL. This serialized continuation is the continu\u00adation of s/s/d with the procedure appended to \nthe end. Since the components of the continuation are represented as a list, we can do this directly. \nHowever, the continuation components are stored in reverse order, so a logical append is a prepend on \nthe representa\u00adtion. In the program, (f (g (h (s/s/d (. (embed/url)(embed/url i)))))) application-context \nis (list hg f )and application+handler-context is (list ihgf ). This captures only a single continuation \nregardless of how many handler procedures are embedded. This improves our time and space ef.ciency. \n 5.4 Continuation Management In our system, continuations are serialized and embedded in the URLs given \nto the client by default. However, there are some prag\u00admatic reasons why this is not always a good idea. \nFirst, there is, in principle, no limit to the size of a continuation. If the lexical environment contains \nthe contents of a 100MB .le, then the continuation will be at least 100MBs (modulo clever com\u00adpression). \nMost Web clients and servers support URLs of arbitrary length, but some browsers and servers do not. \nIn particular, Mi\u00adcrosoft Internet Explorer (IE) limits URLs to 2,048 characters and Microsoft IIS limits \nthem to 16,384 characters. Second, if a continuation is embedded in a URL and given to the user, then \nit is possible to manipulate the continuation in its serialized form. Thus, the environment and Web cell \ncontents are not secure when handled directly by users. Providing security is not always appropriate, \nso we allow Web application developers to customize the kont.url function that is used to embed continuations \nin URLs with stuffers. We provide a number of different stuffer algorithms and the ability to compose \nthem. They compose because they produce and consume serializ\u00adable values. Plain The value is serialized \nwith no special considerations. GZip The value is compressed with the GZip algorithm. Sign The value \nis signed with a parameterized algorithm. Crypt The value is encrypted with a parameterized algorithm. \nHash Thevalueishashedwiththe MD5or SHA1algorithm.Thevalue is serialized into a database addressed by \nthe hash and the hash is embedded in the URL. Len(s) Stuffer s is used if the URL would be too long when \nstuffed with the value. These techniques can be combined in many ways. For exam\u00adple, an application \nwith small continuations and no need for se\u00adcrecy could just use the Plain algorithm. An application \nthat had larger continuations might add the GZip algorithm. An application that needed to protect against \nchanges could add the Sign algo\u00adrithm, while one that needed to guarantee the values could not be inspected \nmight add Crypt. Finally, an application that did not want the expense in either bandwidth or computational \ntime could just use the Hash algorithm. Every URL would be the same length, and identical continuations \nwould be stored only once. Although the Hash method is not truly RESTful, it performs drastically better \nthan the traditional method of storing the con\u00adtinuations in memory. It uses less space because the continuation \nrepresentation is tailored to the particular application, in contrast to the standard C-stack copy. Furthermore, \nit takes less time to service requests. This might seem implausible since the operating system s virtual \nmemory system seems morally equivalent to a continuation database because unused parts of memory are \nmoved to disk. How\u00adever, the VM considers memory unused only when it is not touched by the application. \nIn PLT Scheme, the garbage collector stores a tag bit with objects. Thus, even though the collector doesn \nt need to walk all data, collection affects these tag bits, which causes the operating system to bring \nthe entire page into main memory. This paging, which would not be present with a swap-sensitive garbage \ncollector (Hertz et al. 2005), causes severe performance degrada\u00adtion. The Hash method has the additional \nadvantage of providing multi-server scalability easily, compared to other possible server\u00adside continuation \nstores. Since the Hash method guarantees that two writes to the same key must contain the same data, \nbecause otherwise the hashing algorithm would not be secure, multiple Web servers do not need to coordinate \ntheir access to the database of serialized continuations. Therefore, replication can be done lazily and \nef.ciently, avoiding many of the problems that many session object databases are fraught with. 5.4.1 \nReplay Attacks Since the URLs of our application completely specify what the Web application will do \nin response to a request, it is natural to assume that our applications are particular susceptible to \nreplay attacks. For example, suppose we build a stock-trading application and at some point a user sells \n10 shares. An adversary could capture the continuation for sell 10 shares and replay it n times to sell \n10n shares, even with encryption in place. This seems utterly unacceptable. However, consider the same \napplication on another platform where the continuation is speci.ed through an ad-hoc combination of URL, \nform data, and cookies. In this case as well, a request may be replayed to perform this attack. On a \ntraditional platform, this would be prevented by some server-side state. For example, each server response \nwould include a unique identi.er that would be sent back with requests; each identi.er would be allowed \nto be received only once, and the identi.er would be cryptographically tied to the incoming requests, \nso that new identi.ers could not be used to freshen old requests to replay them. This same strategy can \nbe implemented in our system as well, except perhaps better because the unique identi.er can be combined \nwith the entire continuation since it is explicitly represented, in one place, in our system. As before \nwith the various stuffer algorithms, it is not always appropriate to disallow replays. For example, it \nis useful to use the browser s Refresh button and to send links to colleagues. If we provided replay \nprotection for free, we would also disallow many useful Web applications. 5.4.2 Serialization Format \nEach continuation record is scarcely more than 100 bytes. This is split between Web cells, the continuation \nmarks, and the continua\u00adtion function components. The cells and marks are comparable to the lexical values \ncaptured in the continuation. Each function is se\u00adrialized as a unique identi.er that refers to the compiled \ncode and the captured values of free variables. The continuation record has a list of these functions. \nA sanitized, sample record is below. (serialized ((web-server/lang/abort-resume . web:kont) (web-server/lang/web-cells \n. web:frame) (application/servlet . web:300)) (web:kont (web:frame (list (cons web:23-1 (path #\"static-path\" \n. unix)) (cons web:10-0 (path #\"db-path\" . unix)) (cons web:36-2 \"username\"))) (list (vector (web:300) \n#f)))) This can be seen as a short program that constructs the serialized value. The .rst part records \nwhat modules contain the de.nitions of data-structures that are created. The module path refer to code \nloaded into the PLT Scheme instance that is deserializing the con\u00adtinuation. If they are resolved to \nthe wrong code, or if the module are simply not available, then deserialization will fail. This means \nany PLT Scheme instance with access to the same source can de\u00adserialize this continuation. Our system \nprotects against certain er\u00adrors by including in a hash of the module source in the names of continuation \ndata structures. In the real record that this example corresponds to, the token 300 would include a hash \nof the source of application/servlet to result in a deserialization error if the code were changed, rather \nthan the unsafe behavior that would result if a different kind of continuation were populated with erroneous \ndata from this record. The second part is an expression that creates the continuation record. Its .rst \n.eld contains the record of the Web cells. This is an association list from identifying symbols to values. \nIn this example, two of the values are paths, while the other is a string. The second .eld of the continuation \nis the continuation record. This is the list that will be passed to resume. In the example, there is \na single function, web:300, with no accompanying continuation mark recording.   6. Evaluation The formal \ntreatment of Section 4 can tell us if the transformation is correct and if it formally has the modularity \nproperties we desire, but it cannot tell us if it is useful for producing scalable, RESTful, direct-style \nWeb applications. 6.1 Scalability We observe that Web applications in our system written in direct style \ncan be entirely RESTful. Their usage of the lexical environ\u00adment, .uid state, and Web cells are all contained \nin serializable structures. These can then be stored by the client in encrypted and compressed URLs. \nCookies can easily capture store state, and since nearly all data structures are serializable, any value \ncan be stored in cookies. Finally, our programs may choose to use server state where appropriate. However, \nour system would not really be useful if it greatly slowed down the developer (with compilation lag) \nor the client (with execution lag), so we measure those. Compilation takes, on average, twice the amount \nof time as compiling normal Scheme. This measurement was based on com\u00adpiling a collection of 15 servlets. \nThis is because our compiler is implemented as a PLT module language (Flatt 2002) that performs  #lang \nscheme (require web-server/servlet) (de.ne (get-number which) (string->number (extract-binding/single \nnumber (send/suspend (. (k-url) (html (body (form ([action ,k-url]) ,which \" number:\" (input ([name \n\"number\"])))))))))) (de.ne (start req) (html (body ,(number->string (+ (get-number \"First\") (get-number \n\"Second\")))))) Figure 11. Add-Two-Numbers (Before) .ve passes over the source code before it produces \nnormal Scheme. These .ve passes cause a delay that is noticeable to developers but not prohibitive. There \nis no noticeable difference in the execution time of our servlets versus standard servlets. Although \nit is possible to cause slow down by serializing large objects. We tested scalability by comparing the \nspace usage of a typi\u00adcal Web application before and after conversion to our system. Be\u00adfore, the LRU \nmanager kept memory usage scarcely below 128MB. This pattern of hugging the edge of the limit matches \nour ex\u00adperience with CONTINUE (Krishnamurthi 2003). After conversion, the server uses about 12MB, of \nwhich approximately 10MB is the bytecode for the application and its libraries. We tested with multiple \nserialization regimes. When GZip is used, no continuation is larger than IE s limit, so there is no per\u00adsession \nstate on the server. When we use Hash, the continuation store is about 24MB for approximately 150 users. \nThis means that we use about 20 percent of the preconversion storage, while pro\u00adviding more service, \nbecause continuations are never revoked. But remember, we don t need to use that storage because the \nclient can hold every continuation.  6.2 Modularity &#38; Compatibility The .nal way we evaluate our \nwork is by its ability to run unmod\u00adi.ed Scheme programs, in particular, Web applications. In most cases, \nthere is no dif.culty whatsoever; the user simply changes one line at the top of his or her program. \nFigure 11 presents a servlet and Figure 12 shows the same servlet using our transformation: the .rst \nline selects the compiler, and the second eliminates the unnec\u00adessary require speci.cation. There are \ntwo categories of programs that lead to errors when transformed. The .rst category is programs that include \nnonseri\u00adalizable data structures in the environment of their captured con\u00adtinuations. The second category \nis programs that use higher-order library procedures with arguments that capture continuations. 6.2.1 \nNon-serialized Data Structures Our transformation implements continuations with closures and renders \nclosures serializable through defunctionalization. However, other data structures remain unserializable: \nports, foreign pointers, global and thread-local boxes, untransformed closures, parameters, #lang web-server \n; . different ; . different (de.ne (get-number which) (string->number (extract-binding/single number \n(send/suspend (. (k-url) (html (body (form ([action ,k-url]) ,which \" Number:\" (input ([name \"number\"])))))))))) \n(de.ne (start req) (html (body ,(number->string (+ (get-number \"First\") (get-number \"Second\")))))) Figure \n12. Add-Two-Numbers (After) etc. If a program includes these data structures in the environment of serialized \ncontinuations, then the continuation is not serializable. In most cases this is not problematic, because \nthese data structures are often de.ned at the global level or used during a computation but not between \nWeb interactions. For example, it is much more common for the function + to be invoked during a computation \nthan for the function + to be stored in a list that it is in the envi\u00adronment of a continuation. Only \nthe second prevents serialization. Since these practices are so uncommon, we have not found con\u00adstraint \nto prevent compatibility in practice. 6.2.2 Higher-order Third-Party Library Procedures Programs that \nuse higher-order third-party library procedures can\u00adnot be used safely with our system. For example, \n(map get-number (list \"First\"\"Second\")) This does not work because the send/suspend inside of get\u00adnumber \nrelies on the 0 mark to capture the continuation, but be\u00adcause map is not transformed, its part of the \ncontinuation is not recorded. We can detect this situation and signal a runtime error as described by \nPettyjohn et al. (2005). However, it is always possible to recompile the necessary code (i.e., map) under \nour transforma\u00adtion.  7. Conclusion We presented a modular program transformation that produces RESTful \nimplementations of direct style Web programs that use expressive features, like continuation marks. We \nhave discussed how to extend this transformation into a deployable system. We have discussed the opportunities \nfor con\u00adtinuation management this allows. We have evaluated the perfor\u00admance of our work and found that \nit meets the gold standard of scalability no server-side session state and can use as little as 10% of \nthe memory when server-side state is desirable. This work relies on continuation marks, so it is dif.cult \nto ap\u00adply it to programming languages other than PLT Scheme. How\u00adever, practitioners could apply our \ntechnique easily once contin\u00aduation marks were available. Since continuation marks can be implemented \nfor both C# (Pettyjohn et al. 2005) and JavaScript (Clements et al. 2008), it should be possible to automatically \npro\u00adduce RESTful Web applications in those languages as well.  In the future, we will explore how to \nallow continuation cap\u00adture in an untransformed context. We anticipate that the WASH ap\u00adproach (Thiemann \n2006) of combining multiple continuation cap\u00adture methods will be appropriate. Acknowledgments We thank \nMatthew Flatt for his superlative work on PLT Scheme. We thank Greg Pettyjohn for his work on the prototype \nour system is based upon. We thank Matthias Felleisen, Matthew Flatt, Shriram Krishnamurthi, and the \nanonymous review\u00aders for their comments on this paper. This material is based upon work supported under \na National Science Foundation Graduate Re\u00adsearch Fellowship.  References John Clements, Matthew Flatt, \nand Matthias Felleisen. Modeling an algebraic stepper. In European Symposium on Programming, April 2001. \nJohn Clements, Ayswarya Sundaram, and David Herman. Imple\u00admenting continuation marks in JavaScript. In \nScheme and Func\u00adtional Programming Workshop, 2008. Ezra Cooper, Sam Lindley, Philip Wadler, and Jeremy \nYallop. Links: Web programming without tiers. In Formal Methods for Components and Objects, 2006. St\u00b4ephane \nDucasse, Adrian Lienhard, and Lukas Renggli. Seaside \u00ada multiple control .ow web application framework. \nIn European Smalltalk User Group -Research Track, 2004. Matthias Felleisen and Robert Hieb. The revised \nreport on the syntactic theories of sequential control and state. Theoretical Computer Science, 102:235 \n271, 1992. Roy T. Fielding and Richard N. Taylor. Principled design of the modern web architecture. ACM \nTransactions on Internet Technology, 2(2):115 150, 2002. M. J. Fischer. Lambda calculus schemata. ACM \nSIGPLAN No\u00adtices, 7(1):104 109, 1972. In the ACM Conference on Proving Assertions about Programs. Cormac \nFlanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. The essence of compiling with continuations. \nSIG-PLAN Notices, 39(4):502 514, 2004. Matthew Flatt. Composable and compilable macros. In Interna\u00adtional \nConference on Functional Programming, 2002. Paul Graham. Lisp for web-based applications, 2001. http://www.paulgraham.com/lwba.html. \nMatthew Hertz, Yi Feng, and Emery D. Berger. Garbage collection without paging. In Programming Language \nDesign and Imple\u00admentation, pages 143 153, 2005. Peter Walton Hopkins. Enabling complex UI in Web applications \nwith send/suspend/dispatch. In Scheme Workshop, 2003. John Hughes. Generalising monads to arrows. Science \nof Computer Programming, 37(1 3):67 111, May 2000. Shriram Krishnamurthi. The CONTINUE server. In Practical \nAspects of Declarative Langauges, January 2003. Shriram Krishnamurthi, Peter Walton Hopkins, Jay McCarthy, \nPaul T. Graunke, Greg Pettyjohn, and Matthias Felleisen. Im\u00adplementation and Use of the PLT Scheme Web \nServer. Higher-Order and Symbolic Computation, 2007. Jacob Matthews, Robert Bruce Findler, Paul T. Graunke, \nShriram Krishnamurthi, and Matthias Felleisen. Automatically restruc\u00adturing programs for the Web. Automated \nSoftware Engineering, 11(4):337 364, 2004. Jay McCarthy and Shriram Krishnamurthi. Interaction-safe state \nfor the Web. In Scheme and Functional Programming,Septem\u00adber 2006. Greg Pettyjohn, John Clements, Joe \nMarshall, Shriram Krishna\u00admurthi, and Matthias Felleisen. Continuations from general\u00adized stack inspection. \nIn International Conference on Functional Programming, September 2005. Gordon D. Plotkin. Call-by-name, \ncall-by-value, and the .\u00adcalculus. Theoretical Computer Science, 1975. Christian Queinnec. The in.uence \nof browsers on evaluators or, continuations to program web servers. In International Confer\u00adence on Functional \nProgramming, pages 23 33, 2000. Peter Thiemann. Wash server pages. Functional and Logic Pro\u00adgramming, \n2006. Noel Welsh and David Gurnell. Experience report: Scheme in com\u00admercial web application development. \nIn International Confer\u00adence on Functional Programming, September 2007.   \n\t\t\t", "proc_id": "1596550", "abstract": "<p>Continuation-based Web servers provide distinct advantages over traditional Web application development: expressive power and modularity. This power leads to fewer errors and more interesting applications. Furthermore, these Web servers are more than prototypes; they are used in some real commercial applications. Unfortunately, they pay a heavy price for the additional power in the form of lack of scalability.</p> <p>We fix this key problem with a modular program transformation that produces scalable, continuation-based Web programs based on the REST architecture. Our programs use the same features as non-scalable, continuation-based Web programs, so we do not sacrifice expressive power for performance. In particular, we allow continuation marks in Web programs. Our system uses 10 percent (or less) of the memory required by previous approaches.</p>", "authors": [{"name": "Jay A. McCarthy", "author_profile_id": "81329490606", "affiliation": "Brigham Young University, Provo, UT, USA", "person_id": "P1613955", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596594", "year": "2009", "article_id": "1596594", "conference": "ICFP", "title": "Automatically RESTful web applications: marking modular serializable continuations", "url": "http://dl.acm.org/citation.cfm?id=1596594"}