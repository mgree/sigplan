{"article_publication_date": "08-31-2009", "fulltext": "\n Functional Pearl: La Tour D Hano\u00a8i Ralf Hinze Computing Laboratory, University of Oxford, Wolfson Building, \nParks Road, Oxford, OX1 3QD, England ralf.hinze@comlab.ox.ac.uk Abstract This pearl aims to demonstrate \nthe ideas of wholemeal and projec\u00adtive programming using the Towers of Hanoi puzzle as a running example. \nThe puzzle has its own beauty, which we hope to expose along the way. Categories and Subject Descriptors \nD.1.1 [Programming Tech\u00adniques]: Applicative (Functional) Programming; D.3.2 [Program\u00adming Languages]: \nLanguage Classi.cations Applicative (func\u00adtional) languages, Haskell; D.3.3 [Programming Languages]: \nLanguage Constructs and Features Frameworks, patterns, recur\u00adsion General Terms Algorithms, Design, Languages \nKeywords Towers of Hanoi, wholemeal programming, projective programming, Hanoi graph, Sierpi\u00b4nski graph, \nSierpi\u00b4nski gasket graph, Gray code 1. Introduction Functional languages excel at wholemeal programming, \na term coined by Geraint Jones. Wholemeal programming means to think big: work with an entire list, rather \nthan a sequence of elements; de\u00advelop a solution space, rather than an individual solution; imagine a \ngraph, rather than a single path. The wholemeal approach often offers new insights or provides new perspectives \non a given prob\u00adlem. It is nicely complemented by the idea of projective program\u00adming: .rst solve a more \ngeneral problem, then extract the interest\u00ading bits and pieces by transforming the general program into \nmore specialised ones. This pearl aims to demonstrate the techniques us\u00ading the popular Towers of Hanoi \npuzzle as a running example. This puzzle has its own beauty, which we hope to expose along the way. 2. \nThe Hanoi graph The Towers of Hanoi puzzle was invented by the French number theorist Edouard Lucas more \nthan a hundred years ago. It consists \u00b4of three vertical pegs, on which discs of mutually different diame\u00adters \ncan be stacked. For reference, we call the pegs A, B and C and let a, b and c range over pegs. data Peg \n=A | B | C I own a version of the puzzle where the pegs are arranged in a row. However, the mathematical \nstructure of the puzzle becomes clearer, Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 09, August 31 September 2, 2009, Edinburgh, Scotland, UK. Copyright \nc &#38;#169; 2009 ACM 978-1-60558-332-7/09/08. . . $10.00 if we arrange them in a circle. Initially, \nthe discs are placed on one peg in decreasing order of diameter. The task is then to move the disks, \none at a time, to another peg subject to the rule that a larger disk must not be placed on a smaller \none. This restriction implies that a con.guration can be represented by a list of pegs: the .rst element \ndetermines the position of the largest disc, the second element the position of the second largest disc, \nand so forth. Consequently, there are 3n possible con.gura\u00adtions where n is the total number of discs. \nLucas original puzzle contained 8 discs. The instructions of the puzzle refer to an old Indian legend, \nattributed to the French mathematician De Parville, according to which monks were given the task of moving \na total of 64 discs. Since the day of the world s creation, they transfer the discs, one per day. According \nto the legend, once they complete their sacred task, the world will come to an end. Now, taking a wholemeal \napproach, let us .rst develop the big picture. The set of all con.gurations together with the set of \nlegal moves de.nes a graph, which turns out to enjoy a nice inductive de.nition. If there are no discs \nto move around, the graph consists of a singleton node: .. For the inductive step we reason as follows: \nthe largest disc can only be moved, if all the smaller discs reside on one other peg. The smaller discs, \nhowever, can be moved independent of the largest one. As the largest disk may rest on one of three pegs, \nthe graph for n +1 discs consequently incorporates three copies of the graph for n discs linked by three \nedges. The diagram in Fig. 1 illustrates the construction. The graph has the shape of a triangle; the \ndashed lines indicate the sub-graphs (for n =0 the sub-graphs collapse to singleton nodes); the three \nsolid lines connect the sub-graphs. The inductive construction shows that BBn   AAn CCn  Figure 1. \nInductive construction of the Hanoi graph. the graph is planar: it can be drawn so that no edges intersect. \nFig. 2 displays the graph for 4 discs. To reduce clutter, the peg of the largest disc is always written \nin the centre of the respective sub\u00adgraph, with the size of the font indicating the size of the disc. \nCan you .nd the con.guration [B, A, B, C]? The corners of the triangle correspond to perfect con.gurations: \nall the discs reside on one peg. The example graph shows that every con.guration permits three different \nmoves, except for the three perfect con.gurations, where only two moves are possible.  Figure 2. The \nHanoi graph for 4 discs. Let us turn our attention to the layout of the sub-graphs. The fol\u00adlowing notation \nproves to be useful: the arrangement xyz denotes a permutation of x, y and z, which by assumption are \npairwise dif\u00adferent. Using abc to indicate the position of the largest disc the largest disc in the left \ntriangle resides on a and so forth we ob\u00adserve that if the corners of the graph are abc, then the corners \nof the cb a sub-graphs are ab, ca and bc, respectively. Using this observa\u00adtion, we can capture the informal \ndescription of the construction as a pseudo-Haskell program. graph0 (abc)= . graphn+1 (abc)= b < graphn \n(cba ) / \\ a < graphn (acb) c < graphn (bac) The function graphn maps an arrangement abc to an undirected \ngraph, whose vertices are lists of pegs of length n. The notation a < g means prepend a to all the vertices \nof g; . denotes a singleton node labelled with the empty list. We leave the type of graphs unspeci.ed. \nIf the type were a functor, then a < g would be fmap (a :) g. The call graph4 (ABC) yields the graph \nin Fig. 2. A few observations are in order. The de.nition of graphn im\u00adplies that the graph has 3n nodes \n(a0 =1, an+1 =3 \u00b7 an) and (3n+1 -3)/2 edges (a0 =0, an+1 =3 \u00b7an +3). Furthermore, the length of a side \nof the triangle is 2n -1 (a0 =0, an+1 =2\u00b7an +1). Since there are only 3!= 6 permutations of three different \nitems, the graph contains at most six different mini-triangles: ABC, CAB, CCB A BA, AB, CA and BC. Note \nthat the .rst three arrange the pegs clockwise and the last three counterclockwise. Inspecting the de.nition \nof graphn , we see that the direction changes with every recursive step. The diagram in Fig. 3 illustrates \nthe change of di\u00adrection. This observation implies that the recursion pattern is quite regular: at any \ndepth there are only three different recursive calls. Fig. 4 visualises the call structure using three \ndifferent colours. AAn ABn CBn CCn Figure 3. Change of direction. 3. Towers of Hanoi, recursively Solving \nthe Towers of Hanoi puzzle amounts to .nding a shortest path in the corresponding graph. Clearly, the \nshortest path between two corners is along the side of the triangle. Projecting onto the lower side, \nwe transform graphn to hanoi.0 (abc) = [[]] b ca hanoi.n+1 (ac)= a < hanoi.n (ab)+ c < hanoin.(bc) . \nNow, a < x is shorthand for fmap (a :) x. The call hanoi.n (abc) returns a list of con.gurations solving \nthe problem of moving n discs from a to c using b . Instead of con.gurations (vertices of the graph) \nwe can alterna\u00adtively return a list of moves (corresponding to edges). hanoi0 (abc) = [] bc a hanoin+1 \n(ac)= hanoin (ab) + [(a, c)] + hanoin (bc)  Figure 4. Call structure of hanoi at recursion depth 4. \nThe pair (a, c) represents the instruction move the topmost disc from a to c . Here is the sequence of \nmoves for n =4: > hanoi4 (ABC) [(A, B), (A, C), (B, C), (A, B), (C, A), (C, B), (A, B), (A, C), (B, C), \n(B, A), (C, A), (B, C), (A, B), (A, C), (B, C)] . Note that the lower part of the list can be obtained \nfrom the upper part via a clockwise rotation of the pegs: acb becomes bac. There is at least one further \nvariation: instead of an arrangement one can pass a source and a target peg. hanoi0 ac = [] hanoin+1 \nac = hanoin a (a . c) + [(a, c)] + hanoin (a . c) c The function ., which determines the other peg , \nis given by A . A=A; A . B=C; A . C=B B . A=C; B . B=B; B . C=A C . A=B; C . B=A; C . C=C . We will .nd \nsome use for . later on. For the moment, we just note that the operation is commutative and idempotent, \nbut not associative. 4. Towers of Hanoi, parallelly Imagine that the monastery always accommodates as \nmany monks as there are discs. The tallest monk is responsible for moving the largest disc, the second \ntallest monk for moving the second largest disc, and so forth. Can we set up a work schedule for the \nmonastery? Inspecting Fig. 2, we notice that, somewhat unfairly, the small\u00adest monk is the busiest. Since \nthe smallest triangles correspond to moves of the smallest disc, he is active every other day. We can \nex\u00adtract his work plan from hanoin by omitting all the moves, except when n equals 1. cycle0 (abc) = \n[] cycle1 (abc) = [(a, c)] bca cycle(ac)= cycle(ab)+ cycle(bc) n+1 nn The function is called cycle , \nbecause the smallest disc cycles around the pegs: in the recursive call it is moved from a to b and then \nfrom b to c. Whether it cycles clockwise or counterclock\u00adwise depends on the parity of n the direction \nchanges with every recursive call of cycle . Of course, the smallest disc is by no means special: all \nthe discs cycle around the pegs, albeit at a slower pace and in alternating directions. In fact, hanoi \nsatis.es the following fractal property: b bb hanoin+1 (ac)= cyclen+1 (ac) Y hanoin (ac) , (1) where \nY denotes the interleaving of two lists. [] Y bs = bs (a : as) Y bs = a :(bs Y as) The fractal property \nsuggests the following alternative de.nition of hanoi , which has a strong parallel .avour. phanoi0 (abc) \n= [] b bb phanoi(ac)= cycle(ac) Y phanoi(ac) n+1 n+1 n In words, the smallest monk starts to work on \nthe .rst day; he is active every second day and moves his disc, say, clockwise around the pegs. The second \nsmallest monk starts on the second day; he is active every fourth day and moves his disc counterclockwise. \nAnd so forth. Actually, only the smallest monk must remember the direction; for the larger discs there \nis no choice, as one of the other two pegs is blocked by the smallest disc.  There is an intriguing \ncross-connection to binary numbers: the activity diagram of the monks (Which monk has to work on a given \nday?) discs0 = [] discsn+1 = discsn + [n ]+ discsn yields the binary carry sequence or ruler function \nas n goes to in.nity (Hinze, 2008). This sequence gives the number of trailing zeros in the binary representations \nof the positive numbers, most signi.cant bit .rst. Or put differently, it speci.es the running time of \nthe binary increment. We will make use of this observation later on. The fractal property (1) enjoys \na simple inductive proof, which makes essential use of the following abide law. If x1 and x2 are of the \nsame length, then (x1 + y1) Y (x2 + y2)=(x1 Y x2) + (y1 Y y2) . The basis of the induction is straightforward. \nHere is the inductive step. cyclen+2 (abc) Y hanoin+1 (abc) = { de.nition of cycle and de.nition of hanoi \n} (cycle(acb)+ cycle(bac)) n+1 n+1 Y (hanoin (acb) + [(a, c)] + hanoin (bac)) = { abide law } (cyclen+1 \n(acb) Y hanoin (acb)) + [(a, c)] ++(cyclen+1 (bac) Y hanoin (bac)) = { ex hypothesi } hanoin+1 (acb) \n+ [(a, c)] + hanoin+1 (bac) = { de.nition of hanoi } hanoin+2 (abc) The abide law is applicable in the \nsecond step, because the two lists, cyclen+1 (acb) and hanoin (acb) + [(a, c)], have the same length, \nnamely, 2n . Speaking of the length of lists, note n that 2n+1 - 1= P i=0 2i is a simple consequence \nof the fractal property. 5. When will the world come to an end? Many visitors come to the monastery. \nLooking at the con.guration of discs, they often wonder how many days have passed since the creation \nof the world. Or, when will the world come to an end? We can answer these questions by locating the current \ncon.g\u00aduration in the Hanoi graph. If we use as positions the three digits 021 that is, 0 for the left \ntriangle, 2 for the upper triangle and 1 for the right triangle then we obtain the answer to the .rst \nques\u00adtion in binary. Fig. 5 displays the Hanoi graph for 4 discs suit\u00adably re-labelled this graph is \nalso known as the Sierpi\u00b4nski graph. The 24 nodes on the lower side of the triangle, and only those, \nare labelled with binary numbers. Consequently, if the current position contains a 2, we know that the \nmonks have lost track. (To answer the second question, we use as positions 120 instead of 021. If we \nare only interested in the distance to the .nal con.guration, we simply replace the digit 2 by a 1.) \npos (abc) [] = [] pos (abc)(p : ps) | pa =0: pos (acb ) ps | pb =2: pos (cba ) ps | pc =1: pos (bac) \nps For instance, pos (ABC) [A, B, C, A] yields [0, 1, 0, 1], the bi\u00adnary representation of 5, most signi.cant \nbit .rst. The function pos (abc) de.nes a bijection between {A, B, C}n and {0, 2, 1}n for any given initial \narrangement abc. This arrangement can be seen as representing the bijective mapping {a . 0, b . 2, c \n. 1}. Al\u00adternatively, we can use an arrangement, say, ltr as a representation of the inverse mapping \n{A . l, B . t, C . r} obtaining the following slightly more succinct variant of pos. pos (ltr )[] =[] \npos (ltr ) (A : ps)= l : pos (lrt ) ps pos (ltr ) (B : ps)= t : pos (rtl ) ps pos (ltr ) (C : ps)= r \n: pos (tlr ) ps The two variants are related by pos (ABC)= pos (021). The latter de.nition is particularly \neasy to invert. conf (abc)[] =[] conf (abc) (0 : ps)= a : conf (acb ) ps conf (abc) (2 : ps)= b : conf \n(cba ) ps conf (abc) (1 : ps)= c : conf (bac) ps The call conf (ABC) [0, 1, 0, 1] yields [A, B, C, A], \nthe con.gu\u00adration we obtain after 5 days. The functions pos and conf are actu\u00adally identical, if we identify \nA with 0, B with 2 and C with 1. Then pos is an involutive graph isomorphism between Hanoi graphs and \nSierpi\u00b4 nski graphs of the same order. If the monks have lost track a 2 appears in the answer list then \nwe can use the idea of locating a con.guration in the Hanoi graph to determine the shortest path to the \n.nal con.guration c n . This leads to the following generalised version of hanoi . ghanoi0 [] (abc) = \n[] ghanoin+1 (p : ps)(abc) | pa = ghanoips (acb) + [(a, c)] + hanoin (bac) | pb = ghanoips (bca ) + [(b, \nc)] + hanoin (abc) n n | pc = ghanoips (abc) n (The index n is actually redundant: it always equals \nthe length of the peg list.) Depending on the location of p, we either walk within the left triangle \nand then along the lower side, or within the upper triangle and then along the right side, or within \nthe right triangle. The reader should convince herself that ghanoin ps (abc) indeed yields the shortest \npath between ps and c n. Note that the .rst two equations are perfectly symmetric, in fact, ghanoin ps \n(abc)= ghanoin ps (bac). As an aside, if we fuse ghanoi with length, then we obtain a function that yields \nthe distance to the .nal con.guration. 6. Towers of Hanoi, iteratively The generalised version of the \npuzzle moving from an arbitrary con.guration to a perfect con.guration serves as an excellent starting \npoint for the derivation of an iterative solution, that is, a function that maps a con.guration to the \nnext move or to the next con.guration. The next move is easy to determine: we fuse ghanoi with the natural \ntransformation .rst :: [a] . Maybe a .rst [] = Nothing .rst (a : as)= Just a that maps a list to its \n.rst element. We obtain move0 [] (abc)= Nothing moven+1 (p : ps)(abc) | pa = moven ps (acb)+ Just(a, \nc)+ .rst(hanoin (bac)) | pb = moven ps (bca )+ Just(b, c)+ .rst(hanoin (abc)) | pc = moven ps (abc) . \n  0         Figure 5. The Sierpi\u00b4nski graph of order 4. The operator + is overloaded to also \ndenote concatenation of Maybe values (+ is really the mplus method of MonadPlus). (++) :: Maybe a . Maybe \na . Maybe a Nothing + m = m Just a + m = Just a We can simplify the de.nition of move drastically: since \nJust a + m = Just a, the calls to hanoi can be eliminated; because of that the index n is no longer needed. \nFurthermore, the .rst two equations can be uni.ed through the use of ., the operator that determines \nthe other peg . Finally, the second argument, abc, can be simpli.ed to c, the target peg. move [] c = \nNothing move (p : ps) c | p c = move ps (p . c)+ Just (p, c) | pc = move ps c Here is a short interactive \nsession that illustrates the use of move. > move [A, B, B, A, C, C, C, B] C Just (B, C) > move [A, B, \nB, A, C, C, C, C] C Just (A, B) > move [C, C, C, C, C, C, C, C] C Nothing Since the pair (B, C) means \nmove the topmost disc from peg B to peg C, the con.guration following [A, B, B, A, C, C, C, B] is [A, \nB, B, A, C, C, C, C]. Incidentally, if we start with the initial peg list [A, A, A, A, A, A, A, A] and \ntarget C, we obtain these con.gurations after 110 and 111 steps. The function move implements a two-way \nalgorithm: on the way down the recursion it calculates the target peg for each disc (using .); on the \nway up the recursion it determines the smallest disc that is not yet in place (using + ). The following \ntable makes the target pegs explicit. The rows labelled ci lists the target peg for each disc: the .rst, \nuser-supplied target is c0 =C, the next target is c1 = p0 . c0, and so forth. i 01234567 110 pi ABBACCCB \nci CBBBCCCCA 111 pi ABBACCCC ci CBBBCCCCC The smallest disc is not in place, so it is moved from B to \nC. In the next round, disc 3 has to be moved from A to B. The smaller discs are moved more frequently, \nso it is actually prudent to reverse the list of pegs so that the peg on which the smallest disc is located \ncomes .rst. The situation is similar to the binary increment: visiting the digits from least to most \nsigni.cant bit is more ef.cient than the other way round. Let us assume for the moment that we know the \nlast target , the value of c that is discarded in the .rst equation of move (the pegs that stick out \nin the example above). Since . is reversible, p.c = c iff c = p.c , we can reconstruct the previous target \nc from the next target c . The following variant of move makes use of this fact the suf.x i indicates \nthat the input list is now arranged in increasing order of diameter. movei [] c = Nothing movei (p : \nps) c | p (p . c )= Just (p, p . c )+ movei ps (p . c ) | p (p . c )= movei ps c We consistently changed \nthe second argument of move to re.ect the fact that we compute the previous from the next target and \nadditionally replaced the remaining occurrences of c by p . c . Again, we can simplify the code: p (p \n. c ) is the same as p c . Applying Just a + m = Just a once more, we can eliminate the .rst recursive \ncall to movei so that the function stops as soon as the smallest displaced disc is found this was the \npurpose of the whole exercise. We obtain  movei [] c = Nothing movei (p : ps) c | pc = Just (p, p . \nc ) | pc = movei ps c . In a nutshell, movei determines the smallest disc that does not reside on the \nlast target. So, for an iterative version of hanoi we have to maintain two pieces of information: the \ncurrent con.guration and the current last target . It remains to determine the initial last target and \nhow the last target changes after each move. If the list of pegs is given in the original decreasing \norder, then we can transform move to last [] c = c last (p : ps) c = last ps (p . c) , which yields \nthe last target. It is not hard to see that last is an instance of the famous foldl: last ps c = foldl \n(.) c ps. If we reverse the list, we simply have to replace foldl by foldr addi\u00adtionally using the fact \nthat . is commutative: foldr (.) c ps = foldl (.) c (reverse ps). Next, we augment movei so that it returns \nthe next con.gura\u00adtion instead of the next move and additionally the next last target . step ([ ], c \n)= Nothing step (p : ps, c ) | pc = Just ((p . c ): ps, p . c ) | pc = do {(ps , c) . step (ps, c ); \nreturn (p : ps , p . c)} Consider the second equation: p is moved to p .c . After the move, the disc \nresides on the target peg. Consequently, the next target is also p . c recall that . is idempotent. This \ntarget is then updated in the third equation on the way back mimicking move s mode of operation. The \nfunction step runs in constant amortised time, since it performs the same number of steps as the binary \nincrement recall that the activity diagram of the monks coincides with the binary carry sequence. The \nnext last target can, in fact, be easily calculated by hand. Consider the following two subsequent moves \n(as usual, a, b and c are pairwise different). nn - 1 n - 2 10 \u00b7\u00b7\u00b7 ac c \u00b7\u00b7\u00b7 cc \u00b7\u00b7\u00b7 bc c \u00b7\u00b7\u00b7 ccc \u00b7\u00b7\u00b7 bc \nc \u00b7\u00b7\u00b7 cc \u00b7\u00b7\u00b7 bb a \u00b7\u00b7\u00b7 bab Assume that the .rst con.guration ends with an even number of cs. The topmost \ndisc of a is then moved to b. The new succession of target pegs consequently alternates between b and \na: since the number of cs is even, the new last target is b; for an odd number, it is a. So, the monks \ncan be instructed as follows: determine the smallest disc that is not on c. Transfer it from a to b. \nIf the disc s number is even, the new last target is b; otherwise, it is a. If we solve the original \npuzzle, that is, if the con.gurations lie on one of the sides of the triangle, then the next last target \nis even easier to determine: like the discs, it cycles around the pegs. If the pegs are arranged ABC \nand we move the discs from A to C, then the last target moves counterclockwise for an even number of \ndiscs and clockwise for an odd number. Summing up, we obtain the following iterative implementation for \nsolving the generalised Hanoi puzzle. ihanoi ps c = map fst (iterate step (ps, foldr (.) c ps)) iterate \n:: (a . Maybe a) . (a . [a ]) iterate f x = x : case fx of {Nothing . [ ]; Just x . iterate f x } 7. \nLongest paths and Sierpi \u00b4nski s triangle So far we have considered shortest paths in the Hanoi graph. \nSince the destruction of the world hangs in the balance, as a gift to future generations, we might want \nto look for the longest path. In the following variant of hanoi the largest disc makes a detour. (According \nto the Indian legend, the temple is actually in Bramah rather than in Hanoi, hence the name of the function.) \nbramah0 (abc) = [] bramahn+1 (abc)= bramahn (abc) + [(a, b)] + bramahn (cba ) + [(b, c)] + bramahn (abc) \n The largest disc is .rst moved from a to b, and then from b to c. Since bramahn returns 3n -1 moves \n(a0 =0, an+1 =3 \u00b7an +2), we have actually found a Hamiltonian path. The path has another interesting \nproperty: if the pegs are arranged in a row, abc, then discs are only moved between adjacent pegs. The \nHamiltonian path for four discs is displayed in Fig. 6. The picture is quite appealing. Actually, if \nwe move the sub-triangles closer to each other so that the corners touch, we obtain a nice frac\u00adtal image. \nFig. 7 shows the result for 7 discs. The corresponding graph is known as the discrete Sierpi\u00b4nski gasket \ngraph.1 The pic\u00adture has been drawn using Functional Metapost s turtle graphics (Korittky, 1998). curve0 \nd = forward &#38; turn (2 * d) &#38; forward curven+1 d = turn d &#38; curven (-d) &#38; turn d &#38; \ncurven d &#38; turn d &#38; curven (-d) &#38; turn d The command forward moves the turtle one step forward, \nturn d turns the turtle clockwise by d degrees, and &#38; sequences two turtle actions. Since turtle \ngraphics is state-based the turtle has a position and faces a direction recursive de.nitions typically \nmaintain an invariant. To draw the triangle abc, we start at a looking at b and stop at c looking away \nfrom b. The overall change of direction is twice the second argument of curve , which for equilateral \ntriangles is either 60. or -60. . The curve is closely related to Sierpi\u00b4 nski s arrowhead curve. In \nfact, both curves yield Sierpi\u00b4 nski s triangle as n goes to in.nity. As an aside, Sierpi\u00b4 nski s triangle \nis a so-called fractal curve: it has the Hausdorff dimension log 3/ log 2 ~1.58496, as it consists of \n= three self-similar pieces with magni.cation factor 2. 8. Gray code The function bramah enumerates the \ncon.gurations {A, B, C}n changing only one peg at a time. In other words, the succession of con.gurations \ncorresponds to a ternary Gray code! To investigate the correspondence a bit further, here is a version \nof bramah that returns a list of con.gurations, rather than a list of moves. bramah0 (abc) = [[]] bramahn+1 \n(abc)= a < bramahn (abc) + b < bramahn (cba ) + c < bramahn (abc)  1 The term gasket graph is actually \nnot used consistently. Some authors call the counterpart of the Hanoi graph the Sierpi\u00b4nski gasket graph, \nand its contracted variant the Sierpi\u00b4 nski graph.  C   A C A C A B A C B B A A  C C B A B B \n C A C C B B A A C          Figure 6. A Hamiltonian path in the Hanoi graph for 4 discs. Figure \n7. A Hamiltonian path in the Hanoi graph for 7 discs. There are two standard ternary Gray codes: the \nso-called modular code, the digits vary 012|201|120 \u00b7\u00b7\u00b7, and the re.ected code, the digits vary 012|210|012 \n\u00b7\u00b7\u00b7. The de.nition above yields the latter, as the discs are only moved between adjacent pegs. In fact, \nwe have bramahn (cba )= reverse (bramahn (abc)). Using this property on the second recursive call, we \ncan simplify bramahn (012) somewhat. gray3 0 = [[]] gray3 =0 < gray3 + 1 < reverse gray3 + 2 < gray3 \nn+1 n nn For comparison, here is the de.nition of the Gray binary sequence. gray2 0 = [[]] gray2 =0 < \ngray2 + 1 < reverse gray2 n+1 nn Actually, the binary Gray code is also hidden in the Tower of Hanoi \npuzzle. We only have to work with a different con.guration space: instead of {A, B, C}n we use {0, 1}n \nkeeping track whether a disc has been moved an even or an odd number of times. The initial con.guration \nAAn becomes 00n, the .nal con.guration CCn becomes 10n. Since the ith disc is moved 2i times, all the \ndiscs make an even number of moves, except for the largest, which makes a single move. We can easily \nadapt ihanoi to generate binary Gray code. We take as a starting point the .rst de.nition of movei, slightly \nmod\u00adi.ed so that the next con.guration is returned instead of the next move (we also applied the Just \na + m = Just a simpli.cation). con.gi [] c = Nothing con.gi (p : ps) c | p (p . c )= Just (p . c : ps) \n| p (p . c )= p < con.gi ps (p . c ) Now, the Gray code equivalent of . is the Boolean operation exclusive \nor, that is, inequality of Booleans. This implies that the last target c corresponds to a parity bit. \nThus, con.gi becomes (the code uses Booleans rather than bits) codei [] p = Nothing codei (b : bs) p \n| b (bp)= Just ((bp): bs) | b (bp)= b < codei bs (bp) . Again, we can simplify the code a bit: inequality \nand equality of Boolean values are associative (Backhouse and Fokkinga, 2001), so b (bp) is simply p. \nUsing False b = b and True b = \u00ac b, we obtain codei [] p = Nothing codei (b : bs) p | p = Just (\u00ac b : \nbs) |\u00ac p = b < codei bs b . In words: we traverse the list p : bs up to the .rst 1; the following bit, \nif any, is .ipped. As for ihanoi, we have to maintain two pieces of information: the current Gray code \nand the current parity bit. The latter is easy to update: it is .ipped in each step. Summing up, we obtain \nthe following Gray code generator. igray bs = map fst (iterate step (bs, foldr () True bs)) where step \n(bs, p)= do {bs . codei bs p; return (bs , \u00ac p)} This is, in fact, the functional version of Knuth s \nAlgorithm G (2005). 9. Conclusion and further reading We have come to the end of the Tour D Hano\u00a8i. In \nthe spirit of the wholemeal approach we started with an inductive de.nition of the Hanoi graph. From \nthat we derived a series of programs evolving around the Tower of Hanoi theme. Knowing the big picture \nwas jolly useful: for instance, calculating the number of moves could be reduced to the problem of locating \na con.guration in the graph. Projective program transformations are abundant: hanoi is derived from graph \nby projecting onto the lower side of the graph, cycle is derived from hanoi by mashing out the moves \nof the larger discs, and so forth. The transformations could be made rigorous within the Algebra of Programming \nframework (Bird and de Moor, 1997). Occasion\u00adally, this comes at an additional cost. For instance, to \nderive cycle from hanoi we would additionally need the disc number, which is not present in hanoi s output. \nA lot is left to explore. There are literally hundreds of papers on the subject: Paul Stockmeyer s comprehensive \nbibliography has a total of 369 entries (2005). From that bibliography I learned that my de.nition of \nthe Hanoi graph is not original: Er introduced it to analyse the complexity of the generalised Tower \nof Hanoi problem (1983). The original instructions of the game already alluded to the recursive procedure \nfor solving the puzzle. It has been used since to illustrate the concept of recursion. The parallel version \nusually classi.ed as iterative is due to Buneman and Levy (1980). Back\u00adhouse and Fokkinga (2001) show \nthat each disc cycles around the pegs exploiting the associativity of equivalence. To the best of the \nauthor s knowledge the iterative, or stepwise variant is original. The connection to Gray codes has .rst \nbeen noticed by Gardner (1972). Acknowledgments Special thanks are due to Daniel James for enjoyable \ndiscussions and for suggesting a number of stylistic and presentational im\u00adprovements. Thanks are also \ndue to the anonymous referees for an effort to make the paper less dense. References Backhouse, Roland, \nand Maarten Fokkinga. 2001. The associativ\u00adity of equivalence and the Towers of Hanoi problem. Informa\u00adtion \nProcessing Letters 77:71 76. Bird, Richard, and Oege de Moor. 1997. Algebra of Programming. London: Prentice \nHall Europe. Buneman, Peter, and Leon Levy. 1980. The Towers of Hanoi problem. Information Processing \nLetters 10(4 5):243 244. Er, M.C. 1983. An analysis of the generalized Towers of Hanoi problem. BIT 23:429 \n435. Gardner, Martin. 1972. Mathematical games: The curious proper\u00adties of the Gray code and how it can \nbe used to solve puzzles. Scienti.c American 227(2):106 109. Reprinted, with Answer, Addendum, and Bibliography, \nas Chapter 2 of Knotted Dough\u00adnuts and Other Mathematical Entertainments, W. H. Freeman and Co., New \nYork, 1986. Hinze, Ralf. 2008. Functional Pearl: Streams and Unique Fixed Points. In Proceedings of the \n2008 International Conference on Functional Programming, ed. Peter Thiemann, 189 200. ACM Press. Knuth, \nDonald E. 2005. The Art of Computer Programming, Volume 4, Fascicle 2: Generating All Tuples and Permutations. \nAddison-Wesley Publishing Company. Korittky, Joachim. 1998. Functional METAPOST. Diplomarbeit, Universit\u00a8 \nat Bonn. Stockmeyer, Paul K. 2005. The Tower of Hanoi: A bibliography. Available from http://www.cs.wm.edu/~pkstoc/biblio2. \npdf.  \n\t\t\t", "proc_id": "1596550", "abstract": "<p>This pearl aims to demonstrate the ideas of wholemeal and projective programming using the Towers of Hanoi puzzle as a running example. The puzzle has its own beauty, which we hope to expose along the way.</p>", "authors": [{"name": "Ralf Hinze", "author_profile_id": "81332504302", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P1613974", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596555", "year": "2009", "article_id": "1596555", "conference": "ICFP", "title": "Functional pearl: la tour d'Hano&#239;", "url": "http://dl.acm.org/citation.cfm?id=1596555"}