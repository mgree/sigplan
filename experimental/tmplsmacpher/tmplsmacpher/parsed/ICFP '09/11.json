{"article_publication_date": "08-31-2009", "fulltext": "\n A Universe of Binding and Computation Daniel R. Licata* Robert Harper * Carnegie Mellon University \n{drl,rwh}@cs.cmu.edu Abstract We construct a logical framework supporting datatypes that mix binding \nand computation, implemented as a universe in the depen\u00addently typed programming language Agda 2. We \nrepresent binding pronominally, using well-scoped de Bruijn indices, so that types can be used to reason \nabout the scoping of variables. We equip our universe with datatype-generic implementations of weaken\u00ading, \nsubstitution, exchange, contraction, and subordination-based strengthening, so that programmers need \nnot reimplement these op\u00aderations for each individual language they de.ne. In our mixed, pronominal setting, \nweakening and substitution hold only under some conditions on types, but we show that these conditions \ncan be discharged automatically in many cases. Finally, we program a variety of standard dif.cult test \ncases from the literature, such as normalization-by-evaluation for the untyped .-calculus, demon\u00adstrating \nthat we can express detailed invariants about variable usage in a program s type while still writing \nclean and clear code. Categories and Subject Descriptors F.3.3 [Logics and Meanings Of Programs]: Studies \nof Program Constructs Type structure General Terms Languages, Veri.cation 1. Introduction There has been \na great deal of research on programming lan\u00adguages for computing with binding and scope (bound variables, \na-equivalence, capture-avoiding substitution). These languages are useful for a variety of tasks, such \nas implementing domain-speci.c languages and formalizing the metatheory of programming lan\u00adguages. Functional \nprogramming with binding and scope involves two different notions of function: functions-as-data and \nfunctions\u00adas-computation. Functions-as-data, used to represent abstract syn\u00adtax with variable binding, \nhave an intensional, syntactic, character, in the sense that they can be inspected in ways other than \nfunc\u00adtion application. For example, many algorithms that process ab\u00adstract syntax recur under binders, \ntreating variables symbolically. On the other hand, functions-as-computation, the usual functions of \n* This research was sponsored in part by the National Science Foundation under grant number CCF-0702381 \nand by the Pradeep Sindhu Computer Science Fellowship. The views and conclusions contained in this document \nare those of the author and should not be interpreted as representing the of.cial policies, either expressed \nor implied, of any sponsoring institution, the U.S. government or any other entity. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 09, August 31 September \n2, 2009, Edinburgh, Scotland, UK. Copyright c &#38;#169; 2009 ACM 978-1-60558-332-7/09/08. . . $5.00 \nfunctional programming, have an extensional character a function from A to B is a black box that, when \ngiven an A, delivers a B.A function-as-data determines a function-as-computation by substi\u00adtution (plugging \na value in for a variable), but not every function\u00adas-computation determines a function-as-data, because \nthe syntax appropriate for a particular problem may not allow the expression of every black box. In previous \nwork (Licata et al., 2008), we began to study a programming language that provides support for both functions\u00adas-data \nand functions-as-computation as two different types. Our framework provides one type constructor . for \nfunctions-as-data, used to represent variable binding, and another type constructor . for functions-as-computation, \nused for functional programming. This permits representations that mix the two function spaces. As a \nsimple example of such integration, consider a syntax for arithmetic expressions constructed out of (1) \nvariables, (2) numeric constants, (3) let binding, and (4) arbitrary binary primitive operations, repre\u00adsented \nby functions-as-computation of type nat . nat . nat. In SML, we would represent this syntax with the \nfollowing datatype: datatype arith = Var of var | Num of nat | Letbind of arith * (var * arith) | Binop \nof arith * (nat -> nat -> nat) * arith We use ML functions(-as-computation) to represent the primops. \nHowever, because SML provides no support for functions-as-data, we must represent variable binding explicitly \n(with a type var), and code notions such as a-equivalence and substitution ourselves. In contrast, our \nframework naturally supports mixed datatypes such as this one. We specify it by the following constructors: \nnum : arith . nat letbind : arith . arith . (arith . arith) binop : arith . arith . (nat . nat . nat) \n. arith The symbol . is used for datatype constructors, which have the form D . A, for a datatype name \nD and a type A. We use . (functions-as-data) to represent the body of the letbind, and . (functions-as-computation) \nto represent the primops. Our framework takes a pronominal approach to the variables introduced by functions-as-data: \nvariables are thought of as pro\u00adnouns that refer to a designated binding site, and thus are intrinsi\u00adcally \nscoped. This is in contrast to the nominal approach taken by languages such as FreshML (Pitts and Gabbay, \n2000; Pottier, 2007; Shinwell et al., 2003), where variables are thought of as nouns they are pieces \nof data that exist independently of any scope. The pronominal approach inherently requires some notion \nof context to be present in the language s type system, so that variables have something to refer to; \nwe write (.) A as the classi.er of a pro\u00adgram of type A with variables .. The practical advantage of \nthese contextual types is that they permit programmers to express useful invariants about variable-manipulating \ncode using the type system, such as the fact that a .-calculus evaluator maps closed terms to closed \nterms.  In a pronominal setting, the interaction of functions-as-data and functions-as-computation has \ninteresting consequences for the structural properties of variables, such as weakening (introduc\u00ading \na new variable that does not occur) and substitution (plugging a value in for a variable). For example, \none might expect that it would be possible to weaken a value of type A to a function-as\u00addata of type \nD . A. However, this is not necessarily possible when A itself is a computational function type: Contextual \ncom\u00adputational functions of type (.) A . B are essentially interpreted as functions from (.) A to (.) \nB, and (.) D . A classi.es val\u00adues of type A in an extended context ., x : D. Now, suppose we are given \na function f of type (.) A . B; we try to construct a function of type (.) D . (A . B). This requires \na function from (., x : D) A to (., x : D) B. Since f is a black box, we can only hope to achieve this \nby pre-and post-composing with appropriate functions. The post-composition must take (.) B to (., x : \nD) B, which would be a recursive application of weakening. However, the pre-composition has a contravariant \n.ip: we require a strengthening function from (., x : D) A to (.) A in order to call f and such a strengthening \nfunction does not in general exist, because the value of type A might be that very variable x. Similarly, \nsubstitution of terms for variables is not necessarily possible, because substitu\u00adtion requires weakening. \nPut differently, computational functions permit the expression of side conditions that inspect the context, \nwhich causes the structural properties to fail. As a concrete exam\u00adple, consider computational functions \nof type (\u00b7) (arith . arith), which are de.ned by case-analysis over closed arithmetic expres\u00adsions, giving \ncases for constants and binops and let-binding but not for variables, because there are no variables \nin the empty con\u00adtext. Weakening such a function to type arith . (arith . arith) enlarges its domain, \nasking it to handle cases that it does not cover. What are we to do about this interaction of binding \nand com\u00adputation? One option is to work in a less general setting, where it does not come up. For example, \nin nominal languages such as FreshML (Shinwell et al., 2003), the type of names is kept open\u00adended (it \nis considered to have in.nitely many inhabitants). Thus, any computational function on syntax with binding \nmust account for arbitrarily many names, and is therefore weakenable. How\u00adever, many functions on syntax \nare only de.ned for certain classes of contexts (e.g., only closed arithmetic expressions can be eval\u00aduated \nto a numeral), and the nominal approach does not allow these invariants to be expressed in a program \ns type (though they can be reasoned about externally using a speci.cation logic (Pot\u00adtier, 2007)). Alternatively, \nin languages based on the LF logical framework, such as Twelf (Pfenning and Sch\u00fcrmann, 1999), Del\u00adphin \n(Poswolsky and Sch\u00fcrmann, 2008), and Beluga (Pientka, 2008), the structural properties always hold, because \ncomputational functions cannot be used in LF representations of logical systems. In our framework, we \ntake a more general approach, which requires admitting that weakening and substitution may not always \nbe de.ned. Thus, we should be more careful with terminology, and say that the type D . A classi.es values \nof type A with a free variable of type D. In some cases, D . A determines a function given by substitution, \nbut in some cases it does not. In this sense, our approach is similar to representations of binding using \nwell\u00adscoped de Bruijn indices (Altenkirch and Reus, 1999; Bellegarde and Hook, 1994; Bird and Paterson, \n1999), which are pronominal, because variables are represented by pointers into a context, but make no \ncommitment to weakening and substitution. However, our framework improves upon such representations by \nobserving that weakening and substitution are in fact de.nable generically, not for every type D . A, \nbut under certain conditions on the types D and A. For example, returning to our failed attempt to weaken \nA . B above, if variables of type D could never appear in terms of type A, then the required strengthening \noperation would exist. As a rough rule of thumb, one can weaken with types that do not appear to the \nleft of a computational arrow in the type being weakened, and similarly for substitution. Our framework \nimplements the structural properties generically but conditionally, providing programmers with the structural \nproperties for free in many cases. This preserves one of the key bene.ts of working in LF, where weakening \nand substitution are always de.ned. In our previous work (Licata et al., 2008), we investigated the logical \nfoundations of a pronominal approach to mixing binding and computation. In the present paper, we give \nan implementa\u00adtion of (a slight variant of) our framework, and we demonstrate the viability of our approach \nby programming some standard dif\u00ad.cult test cases from the literature. For example, we implement normalization-by-evaluation \n(Berger and Schwichtenberg, 1991; Martin-L\u00f6f, 1975) for the untyped .-calculus, an example consid\u00adered \nin FreshML by Shinwell et al. (2003). Our version of this al\u00adgorithm makes essential use of a datatype \nmixing binding and com\u00adputation, and our type system veri.es that evaluation maps closed terms to closed \nterms. Rather than implementing a new language from scratch, we con\u00adstruct our type theory as a universe \nin Agda 2 (Norell, 2007), a dependently typed functional programming language that provides good support \nfor programming with inductive families, in the style of Epigram (McBride and McKinna, 2004). This means \nthat we (a) give a syntax for the types of our type theory and (b) give a function mapping the types \nof our language to certain Agda types; the programs of our language are then the Agda programs of those \ntypes. This implementation strategy allows us to reuse the consid\u00aderable implementation effort that has \ngone into Agda, and to exploit generic programming within dependently typed programming (Al\u00adtenkirch \nand McBride, 2003) to implement the structural proper\u00adties; additionally, it permits programs written \nusing our framework to interact with existing Agda code. Also, our development pro\u00advides a successful \nexample of prototyping a new language with an interesting type system using a dependently typed programming \nlanguage. In our Agda implementation, we have chosen to repre\u00adsent variable binding using well-scoped \nde Bruijn indices. In summary, we make the following technical contributions: (1) We show that our \nprevious type theory for integrating bind\u00ading and computation can be implemented as a universe in Agda. \nThe types of the universe permit concise, point-free descriptions of contextual types: a type in the \nuniverse acts as a function from contexts to Agda types. (2) We implement a variety of structural properties \nfor the universe, including weakening, substitution, ex\u00adchange, contraction, and subordination-based \nstrengthening (Virga, 1999), all using a single generic map function for datatypes that mix binding and \ncomputation. (3) We de.ne the structural prop\u00aderties preconditions computationally, so that our framework \ncan discharge these conditions automatically in many cases. This gives the programmer free access to \nweakening, substitution, etc. (when they hold). (4) We program a variety of examples, and demonstrate \nthat we can express detailed invariants about variable usage in a program s type while still writing \nclean and clear code.  In this paper, we consider only a simply-typed universe, for writing ML-like \nprograms that manipulate binding in a well-scoped manner; we leave dependent types to future work. Also, \nthe com\u00adpanion code for this paper (see http://www.cs.cmu.edu/~drl/) is written in Agda minus termination \nchecking, as many of our examples require non-termination; we discuss which parts of our code pass the \ntermination checker below. The remainder of this paper is organized as follows: In Sec\u00adtion 2, we introduce \nour language and its semantics in Agda. In Section 3, we present examples. In Section 4, we discuss the \nstruc\u00adtural properties. In Sections 5 and 6, we discuss related work and conclude. Appendix A contains \na brief introduction to Agda.  2. Language De.nition 2.1 Types The grammar for the types of our language \nis as follows: De.ned atoms D ::= ... Var. Types C ::= (a subset of D) Contexts . ::= [] | (.,C) Types \nA ::= 0+ | 1+ | A . B | A . B | listA | A . B D+ D | C# | . . * A | oA .c ..A |.c ..A |.=C A |.=C A \nThe language is parametrized by a class of de.ned atoms D, which are the names of datatypes. A subset \nof these names are variable types, which are allowed to appear in contexts. This dis\u00adtinguishes certain \ntypes C which may be populated by variables from other types D which may not. This de.nition of VarType \npermits only variables of base type, rather than the full language of higher-order rules that we considered \nin previous work (Licata et al., 2008). Contexts are lists of variable types, written with cons on the \nright. The types on the .rst line have their usual meaning. The type D+ D is the datatype named by D. \nFollowing Delphin (Poswolsky and Sch\u00fcrmann, 2008), we include a type C# classifying only the variables \nof type C. The type . . * A classi.es inhabitants of A in the current context extended with .. The type \noA classi.es closed inhabitants of A. The types .c and .c classify universal and existential context \nquanti.cation; .=C A and .=C A provide bounded quanti.cation over contexts containing only the type C. \n2.1.1 Agda implementation We now represent these types in Agda. Those readers who are not .uent in dependent \nprogramming can .nd a review of Agda syntax, well-scoped de Bruijn indices, and universes in Appendix \nA. We represent de.ned atoms, variable types and contexts as follows: DefAtom = DefinedAtoms.Atom data \nVarType : Set where . : (D : DefAtom) {_ : Check(DefinedAtoms.world D)} -> VarType Vars = List VarType \nDefinedAtoms.Atom is a parameter that we will instantiate later. DefinedAtoms.world returns true when \nD is allowed to appear in the context; Check turns this boolean into a proposition (Check True is the \nunit type; Check False is the empty type; see Ap\u00adpendix A for an introduction). A VarType is thus a pair \nof an atom along with the credentials allowing it to appear in contexts. We represent the syntax of types \nin Agda as follows: data Type : Set where types that have their usual meaning 1+ : Type _._ : Type -> \nType -> Type 0+ : Type _._ : Type -> Type -> Type list_ : Type -> Type _._ : Type -> Type -> Type datatypes \nand context manipulation D+ : DefAtom -> Type _# : VarType -> Type _.*_ : Vars -> Type -> Type D : Type \n-> Type .c : (Vars -> Type) -> Type .c : (Vars -> Type) -> Type .= : VarType -> Type -> Type .= : VarType \n-> Type -> Type The only subtlety in this de.nition is that we represent the bod\u00adies of .c and .c by \ncomputational functions in Agda. This choice has some trade-offs: on the one hand, it means that the \nbodies of quanti.ers can be speci.ed by any Agda computation (e.g. by re\u00adcursion over the domain). On \nthe other hand, it makes it dif.cult to analyze the syntax of Types, because there is no way to inspect \nthe body of the quanti.er. Indeed, this caused problems for our implementation of the structural properties, \nwhich we solved by adding certain instances of the quanti.ers (.. and .., discussed below), which would \notherwise be derived forms, as separate Type constructors. In future work, we may pursue a more syntactic \ntreat\u00adment of the quanti.ers (which would of course be easier if we had good support for variable binding. \n. . ). A rule, which is the type of a datatype constructor, pairs the de.ned atom being constructed with \na single premise type (no/multiple premises can be encoded using 1+ and .): data Rule : Set where _._ \n: DefAtom -> Type -> Rule We will make use of a few derived forms: We write (.. A) for (.c\\. -> . .* \nA), and similarly for .. (note that \\ x -> e introduces an anonymous func\u00adtion). This type quanti.es \nover a context . and immediately binds it around A. Similarly, we write [ . ]* A for o (. .* A)  We \nwrite (C . .) for .* with a single premise.  We write (C +) for (D+ C) when C is a variable type.  \nWe write bool for 1+ . 1+ and A option for A . 1+ .   2.2 Semantics A universe is speci.ed by a inductive \ndatatype of codes for types, along with a function mapping each code to a Set. In this case, the Types \nabove are the codes, and the semantics is speci.ed in Figure 1 by a function < . >A, mapping a context \nand a Type to an Agda Set. The .rst six cases interpret the basic types of the simply-typed .-calculus \nas their Agda counterparts, pushing the context inside to the recursive calls. The next two cases interpret \ndatatypes. We de.ne an auxiliary datatype called Data which represents all of the data types de.ned in \nthe universe. Data is indexed by a context and a de.ned atom, with the idea that the Agda set Data . \nD represents the values of datatype D in context .. For example, the values of Data . arith will represent \nthe arithmetic expressions de.ned by the sig\u00adnature given in the introduction. There are two ways to \nconstruct a datatype: (1) apply a datatype constructor to an argument and (2) choose a variable from \n.. Constants are declared in a signature, represented with a predicate on rules InS : Rule -> Set, where \nInS Ris inhabited when the rule Ris in the signature. The .rst con\u00adstructor, written as in.x \u00b7, pairs \na constant with the interpretation of the constant s premise. The second constructor, C, injects a variable \nfrom . into Data.1 See the appendix for the de.nition of the type ., which represents well-scoped de \nBruijn indices (Altenkirch and Reus, 1999; Bellegarde and Hook, 1994; Bird and Paterson, 1999). A DefAtomD \nis in the context if there exist credentials c for which the VarType formed by (C D {c}) is in the list \n.. Finally, we provide a collection of types that deal with the context: . .*A extends the context (we \nwrite + for append); o A clears the context. The quanti.ers .c and .c are interpreted as the corresponding \nAgda dependent function and pair types. Finally, 1 Agda allows overloading of datatype constructors between \ndifferent types, and we tend to use . for injections from one type to another, as with VarType above. \n AllEq : Vars -> VarType -> Set AllEq . D = Check (List.all (eqVarType D) .) mutual data Data (. : \nVars) (D : DefAtom) : Set where _\u00b7_ : {A : Type} -> InS (D . A) -> < . > A -> Data . D :{c:_}->( D{c}) \n. . -> Data . D <_>_ : Vars -> Type -> Set basic types < . > 1+ = Unit < . > 0+ = Void < . > (A . B) \n=(< . > A) \u00d7 (< . > B) < . > (A . B) = Either (< . > A) (< . > B) < . > (list A) = List (< . > A) < . \n> (A . B) = (< . > A) -> (< . > B) data types < . > (D+ D) = Data . D < . >(D#) =D . . context manipulation \n< . >(.new .* A) = < . + .new >A <_>(D A) =<[]>A < . >(.c t)= S \\ . -> < . >(t . ) < . >(.c t) =(. : \nVars) -> < . >(t . ) < . >(.= D A) = (. : Vars) -> AllEq . D -> < . + . >A < . >(.= D A) = S \\(. : Vars) \n-> AllEq . D \u00d7 < . + . >A Figure 1. Semantics the types .= DA and .= DA quantify over contexts . for \nwhich AllEq . Dholds. The type AllEqsays that every variable type in . is equal to the given type D (List.all \nis true when its argument is true on all elements of the list; eqVarType is a boolean-valued equality \nfunction for variable types). (We could internalize AllEq . D as a type alleq D given meaning by < . \n> (alleq D) = AllEq . D in which case the bounded quanti.er could expressed as a derived form, but we \nhave not needed alleq D in a positive position in the examples we have coded so far.) An Agda datatype \nis strictly positive if it does not appear to the left of any Agda function types (->) in its own de.nition; \nthis positivity condition ensures that the user does not de.ne general recursive types (e.g. \u00b5D.D . D), \nwhich can be used to inhabit any type and to write non-terminating code. The above type Data does not \npass the positivity checker: it is de.ned mutually with <_>_, and <_>_ occurs to the left of an Agda \nfunction type in the meaning of .. In this paper, we wish to program with general recursive types, so \nwe will ignore this failure of positivity checking. An interesting direction for future work would be \nto consider a total variant of our framework, which admits only strictly positive types. This would require \na more re.ned explanation of the construction of the de.ned atoms in the universe, e.g. using containers \n(Abbott et al., 2005), because the positivity of a de.ned atom D depends on the rules for D in the signature \nInS. We also de.ne versions of o and .. that construct Agda Sets, so that we do not need to write < [] \n> o Aand so on as the Agda type of a term. (We intentionally use a very similar notation for these; to \na .rst approximation, one can read our examples without keeping this distinction in mind.) D : Type -> \nSet D A = < [] > A .._ : Type -> Set .._A=(. : Vars) -> < . >A subst : (A : Type) {D : VarType} {_ \n: Check(canSubst (un Cut) A)} -> (.. (D . A) . (D +) . A) weaken : (A : Type) {D : VarType} {_ : Check \n(canWeaken (un D) A)} -> (.. A . (D . A)) strengthen : (A : Type) {D : VarType} {_ : Check (canStrengthen \n(un D) A)} -> .. (D . A) . A exchange2 : (A : Type) {D1 D2 : VarType} -> (.. (D2 . D1 . A) . (D1 . D2 \n. A)) contract2 : (A : Type) {D : VarType} -> (.. (D . D . A) . (D . A)) weaken*/bounded : (A : Type) \n(. : Vars) {D : VarType} -> (AllEq . D) -> {canw : Check (canWeaken (un D) A)} -> (.. A . (. .* A)) Figure \n2. Type signatures of structural properties  2.3 Structural Properties In Figure 2, we present the type \nsignatures for the structural prop\u00aderties; this is the interface that users of our framework see. For \nexample, the type of substitution should be read as follows: for any A and D, if the conditions for substitution \nhold, then there is a function of type (.. (D . A) . (D +) . A) (for any context, given a term of type \nA with a free variable, and something of type D + to plug in, there is a term of type A without the free \nvariable). Weakening coerces a term of type A to a term with an extra free variable; strengthening does \nthe reverse; exchange swaps two variables; contraction substitutes a variable for a variable. We also \ninclude an n-ary version of weakening for use with the bounded quanti.er: if A can be weakened with D, \nthen A can be weakened with a whole context comprised entirely of occurrences of D. We discuss the meaning \nof the conditions (canSubst, etc.) below; in all of our examples, they will be discharged automatically \nby our implementation. 3. Examples In this section, we illustrate programming in our framework, adapt\u00ading \na number of examples that have been considered in the liter\u00adature (Pientka, 2008; Poswolsky and Sch\u00fcrmann, \n2008; Shinwell et al., 2003). Throughout this section, we compare the examples coded in our framework \nwith how they are/might be represented in Twelf, Delphin, Beluga, and FreshML. We endeavor to keep these \ncomparisons objective, focusing on what invariants of the code are expressed, and what auxiliary functions \nthe programmer needs to de.ne. Aside from Twelf, we are not expert users of these other systems, and \nwe welcome feedback from those who are. Several additional examples are available in the companion Agda \ncode, in\u00adcluding a translation from .-terms to combinators, a type checker for simply-typed .-calculus \nterms, an evaluator for .-calculus with mutable references (using variables to represent locations), \nand an alternate version of normalization-by-evaluation, which has sim\u00adpler types at the expense of slightly \nmore-complicated code. To use our framework, we give a type DefAtomrepresenting the necessary datatypes \nnames, along with a datatype data InS : Rule -> Set where de.ning the datatype constructors.  We use \nthe following naming convention: De.ned atoms are given names that end in A; e.g., for the signature \nfor arithmetic expressions given in the introduction, we will de.ne natA and arithA. For types of variables, \nwe de.ne <atom>C to be <atom>A injected into VarType: arithC = arithA We de.ne <atom>to be the Typeconstructed \nby D+ <atom>A; e.g.: nat = D+ natA arith = D+ arithA 3.1 Evaluating Arithmetic Expressions We de.ne a \nsignature for the arithmetic example mentioned above: zero : InS (natA . 1+) succ : InS (natA . nat) \nnum :InS (arithA . nat) letbind : InS (arithA . arith . (arithC . arith)) binop : InS (arithA . arith \n. (nat . nat . nat) . arith) Natural numbers are speci.ed by zero and successor. Arithmetic expressions \nare given as a mixed datatype, with . used to represent the body of the letbind and . used to represent \nprimops. Next, we de.ne an evaluation function that reduces an expres\u00adsion to a number: eval : D (arith \n. nat) eval (num \u00b7 n) =n eval (letbind \u00b7 (e1 , e2)) = eval (subst arith _ e2 e1) eval (binop \u00b7 (e1 , \nf , e2)) = f (eval e1) (eval e2) eval ( ()) Evaluation maps closed arithmetic expressions to natural \nnum\u00adbers (the type expression D (arith . nat)reduces to the Agda function type Data [] arithA . Data \n[] natA). Constants evaluate to themselves; binops are evaluated by applying their code to the values \nof the arguments; let-binding is evaluated by substitut\u00ading the expression e1 into the letbind s body \ne22 and then eval\u00aduating the result. A simple variation would be to evaluate e1 .rst and then substitute \nits value into e2. The .nal clause covers the case for variables with a refutation pattern: there are \nno variables in the empty context. Comparison. This example provides a nice illustration of the bene.ts \nof our approach: Substitution is provided for free by the framework, which infers that it is permissible \nto substitute for arithC variables in arith. The type system enforces the invariant that evaluation produces \na closed natural number. It is not possible to de.ne the type arithin Twelf/Delphin/Beluga, as LF representations \ncannot use computational functions. One could program this example in FreshML, but it would be necessary \nto implement substitution directly for arith, as FreshML does not provide a generic substitution operation. \nAgda checks that eval s pattern matching is exhaustive. How\u00adever, Agda is not able to verify the termination \nof this function, as it recurs on a substitution-instance of one of the inputs. Setting aside the computational \nfunctions in binop, it would be possible to get the call-by-value version of this code to pass Twelf \ns termination 2 The arith argument to subst is the type A in the D . A argument to substitution; Agda \ns type reconstruction procedure requires this annotation. The underscore is the context argument instantiating \nthe .. in the type of subst; this could be eliminated by adding an implicit context quanti.er (whose \nmeaning is { . : Vars } -> ...) to the universe. The cre\u00addentials for performing substitution are marked \nas an implicit argument, so there is no evidence of it visible in the call to subst. checker, which recognizes \ncertain substitution instances as smaller. We have not yet investigated how to explain this induction \nprinciple to Agda.  3.2 Closure-based Evaluator Next, we implement a closure-based evaluator for the \nuntyped .\u00adcalculus. .-terms and closures are represented by types exp and clos as follows: lam :InS (expA \n. (expC . exp)) app :InS (expA . exp . exp) closure : InS (closA . (.. (expC . exp) . (expC # . D clos))) \nExpressions are de.ned by the usual signature, as in LF. The type of closures, clos, is a recursive type \nwith one constructor closure. The premise of closure should be read as follows: a closure is constructed \nfrom a triple (. ,e, s), where (1) . is an ex\u00adistentially quanti.ed context; (2) e is an expression in \n. with an extra free variable, which represents the body of a .-abstraction; and (3) s is a substitution \nof of closed closures for all the variables in .. We represent a substitution as a function that maps \neach ex\u00adpression variable in the context (classi.ed by the type expC #) to a closure. The type of the \npremise provides a succinct description of all of this: .. introduces the variables in the existentially \nquan\u00adti.ed context into scope without explicitly naming the context; . extends the context with an additional \nvariable; (expC #) ranges over all of the variables in scope. For comparison, in . this type reduces \nto the Agda type S \\(. : Vars) -> (Data (. + . expC) expA) \u00d7 (expC . (. + . ) -> Data [] closA) (where \nwe write for cons on the right). In this example, unlike the above evaluator for closed arithmetic expressions, \nwe recur over open expressions, so eval is quanti.ed over an unknown context . using ... Evaluation takes \ntwo further arguments: (1) an expression with free variables in ., and (2) an environment, represented \nby a function that yields a closed closure for each expression variable in .; eval returns a closed closure. \nenv : Type env = expC # . D clos eval : D (.. exp . env . D clos) eval . ( x) s = s x eval . (lam \u00b7 e) \ns = closure \u00b7 (. ,e, s) eval . (app \u00b7 (e1 , e2)) s with eval . e1 s ... | closure \u00b7 (. , e , s ) = eval \n(. expC) e (extend{(D clos)} _ s (eval . e2 s)) ... | x = impossible x A variable is evaluated by applying \nthe substitution. A lam eval\u00aduates to the obvious closure. To evaluate an application, we .rst evaluate \nthe function position. To a .rst approximation, the reader may think of Agda s with syntax as a case \nstatement in the body of the clause, with each branch marked by ... |. Case-analyzing the evaluation \nof e1gives two cases: (1) the value is constructed by the constructor closure; (2) the value is a variable. \nIn the .rst case, we evaluate the body of the closure in an extended environment. The call to the function \nextendextends the environment s so that the last variable is mapped to the value of e2. The de.nition \nof extend is as follows: extend : {A : Type} {D : VarType} -> (.. (D # . A) . A . (D . D #) . A) extend \n. s new i0 = new extend . s new (iS i) = s i  At the call site of extend, we must explicitly supply \nthe type A (in this case o clos) to help out type reconstruction. The underscore stands for the instantiation \nof the .., which is marked as an explicit argument, but can in this case be inferred. The second case \nis contradicted using the function impossible, which refutes the existence of a variable at a non-VarType \nwhich clos is, because we never wish to have clos variables. The context argument . to eval does not \nplay an interesting role in the code, but Agda s type reconstruction requires us to supply it explicitly \nat each recursive call. In future work, we may consider whether this argument can be inferred. Agda is \nunable to verify the termination of this evaluator for the untyped .-calculus, as one would hope. When \nwriting this code, one mistake a programmer might make is to evaluate the body of the closure in s instead \nof s , which would give dynamic scope. If we make this mistake, Agda high\u00adlights the occurrence of s \nand helpfully reports the type error that . != ., indicating that the context of the expression does \nnot match the context of the substitution. Comparison. In Twelf, one cannot represent substitutions s \nus\u00ading computational functions, because these are not available for use in LF encodings. However, because \nthe domain of the substi\u00adtution is .nite, a .rst-order representation of substitutions could be used. \nAdditionally, Twelf does not provide the o and .. connec\u00adtives that we use here to describe the contexts \nof closures. While it should be possible for the programmer to express the neces\u00adsary context invariants \nusing explicit contexts (Crary, 2008), this is a fairly heavy encoding technique. Because of these two \nlimi\u00adtations, the resulting Twelf code would be more complicated than the above. One would hope for better \nDelphin and Beluga imple\u00admentations than a port of the Twelf code, but Delphin lacks exis\u00adtential context \nquanti.cation and o, and Beluga lacks the param\u00adeter type exp #, so our de.nition of clos cannot be straightfor\u00adwardly \nported to either of these languages.3 One could implement this example in FreshML (Shinwell et al., 2003), \nbut the type sys\u00adtem would not enforce the invariant that closures are in fact closed. To our knowledge, \na proof of this property for this example has not been attempted in Pure FreshML (Pottier, 2007), though \nwe know of no reason why it would not be possible.  3.3 Variable Manipulation Next, we consider a suite \nof simple variable manipulations. 3.3.1 Size First, we compute the size of a .-term. Addition is de.ned \nas usual, with a contradictory variable case because no natA variables are allowed. plus : D (nat . nat \n. nat) plus (zero \u00b7 _) m = m plus (succ \u00b7 n) m = succ \u00b7 (plus n m) plus( ()) _ size : (.. exp . D nat) \nsize . ( x) = succ \u00b7 (zero \u00b7 _) size . (app \u00b7 (e1 , e2)) = succ \u00b7 (plus (size . e1) (size . e2)) size \n. (lam \u00b7 e) = succ \u00b7 (size (. expC) e) Agda successfully termination-checks these functions. 3 Beluga \nprovides a built-in type of substitutions, written [. ]., so one might hope to represent closures as \n...([., x : exp]exp) \u00d7 [.].; how\u00adever, the second component of this pair associates an expression with \neach expression variable in ., whereas, in this example, we need to associate a closure with each expression \nvariable in .. The type of size expresses that it returns a closed natural num\u00adber. For comparison, we \nimplement a second version that does not make this invariant explicit: size : D (.= expC (exp . nat)) \nsize . bound ( x) = succ \u00b7 (zero \u00b7 _) size . bound (app \u00b7 (e1 , e2)) = succ \u00b7 (plus . bound (size . bound \ne1) (size . bound e2)) where plus : D (.= expC (nat . nat . nat)) plus . b = weaken*/bounded (nat . nat \n. nat) . b [] plus size . bound (lam \u00b7 e) = strengthen nat _ (size (. expC) bound e) Without the o, \nsize must return a number in context .: in the ap\u00adplication case, we must weaken plus into ., and in \nthe lam case we must strengthen the extra expCvariable out of the recursive call. Strengthening expression \nvariables from natural numbers is permit\u00adted by our implementation of the structural properties because \nnat\u00adural numbers cannot mention expressions; we use a subordination\u00adlike analysis to determine this (Virga, \n1999). To ensure that these weakenings and strengthenings are permitted, we type size with a bounded \nquanti.er over exp. Comparison. The .rst version is similar to what one writes in FreshML, except in \nthat setting there is no need to pass around a context .. In the second version, the strengthening of \nthe recur\u00adsive result in the lam case is analogous to the need, in FreshML 2000 (Pitts and Gabbay, 2000), \nto observe that nat is pure (always has empty support); FreshML (Shinwell et al., 2003) does not re\u00adquire \nthis. In Beluga, one can express either the .rst or second ver\u00adsions. In Twelf and Delphin, one can only \nexpress the second variation, as these languages do not provide o. However, the Twelf/Delphin/Beluga \nsyntax for weakening and strengthening is terser than what we have been able to construct in Agda: weaken\u00ading \nis handled by world subsumption and is not marked in the proof term; strengthening is marked by pattern-matching \nthe result of the recursive call and marking those variables that do occur, which in this case does not \ninclude the expression variable. For example, the lam case of size in Twelf looks like this: -: size \n(lam ([x] E x)) (succ N) <-({x : exp} size (E x) N). Twelf s coverage checker veri.es that expression \nvariables can be strengthened out of natural numbers when checking this case. We would like to explore \na similarly terse syntax for weaken\u00ading/strengthening in future work.  3.3.2 Counting occurrences of \na variable A simple variation is to count the number of occurrences of a dis\u00adtinguished free variable. \nThe input to this function has type (expC . exp), and we count the occurrences of the bound variable: \ncnt : .. (expC . exp) . D nat cnt . ( i0) = succ \u00b7 (zero \u00b7 _) cnt . ( (iS _)) = zero \u00b7 _ cnt . (app \u00b7 \n(e1 , e2)) = plus (cnt . e1) (cnt . e2) cnt . (lam \u00b7 e) = cnt (. expC) (exchange2 exp . e) In the .rst \ntwo cases, we pattern-match on the variable: when it is the last variable, the last variable occurs once; \nwhen it is not, it occurs zero times. The lam case recurs on the exchange of e, so that the last variable \nremains the one we are looking for. Agda fails to termination-check this example because it recurs on \nthe result of exchange. Because this use of exchange is a common recursion pattern for (exp -> exp) in \nTwelf, we plan to consider a derived induction principle that covers this case in future work.  Comparison. \nPattern-matching on variables is represented us\u00ading higher-order metavariables in Twelf/Delphin/Beluga \nand using equality tests on names in FreshML. The exchange needed in the lam case is written as a substitution \nin the Twelf/Delphin/Beluga version of this clause. In Twelf one would write: -: cnt ([x] lam ([y] E \nx y)) N <-({y:exp} cnt ([x] E x y) N). In the input to this clause, the metavariable E, which stands \nfor the body of the function, refers to the last variable in the context (the lam-bound variable) as \ny and the second-last variable (the variable being counted) as x. In the recursive call, y is exchanged \npast the binding of x, so the instantiation Exy swaps last and second\u00adlast .  3.3.3 Computing free variables \nNext, we consider a function computing the free variables of an expression, of type (.. exp . list (expC \n#)) in any con\u00adtext, this function accepts an expression in that context and pro\u00adduces a list of variables \nin that context. This typing ensures that we do not accidentally return a bound variable. remove : {D \n: VarType} -> (.. (D . list (D #)) . list (D #)) remove . [] =[] remove . (i0 :: ns) = (remove . ns) \nremove . ((iS i) :: ns) = i :: (remove . ns) fvs : (.. exp . list (expC #)) fvs . ( x)=[x] fvs . (lam \n\u00b7 e) = remove . (fvs (. expC) e) fvs . (app \u00b7 (e1 , e2)) = (fvs . e1) ++ (fvs . e2) In the lam case, \nwe use the helper function remove to remove the lam-bound variable from the recursive result. The function \nremove takes a list of variables, itself with a distinguished free variable, and produces a list of variables \nwithout the distinguished variable. If the programmer were to make a mistake in the second clause by \naccidentally including i0 in the result, he would get a type error. Agda successfully termination-checks \nthis example. Comparison. For comparison with FreshML (Shinwell et al., 2003), the type given to removehere \nis analogous to their Figure 6: remove : (<name> (name list)) -> name list where <a>t is a nominal abstractor. \nThe authors comment that they prefer the version of remove in their Figure 5: remove : name -> (name \nlist) -> name list where the name to removed is speci.ed by the .rst argument, rather than using a binder. \nUsing dependent types, we can type this second version of remove as follows: remove : (. : Vars) (i : \nexp . .) -> List (exp . .) -> List (exp . (. -i)) where . -iremoves the indicated element element from \nthe list. This type is of course expressible in Agda, but we have not yet integrated dependent types \ninto our universe.  3.3.4 .-Contraction In Twelf/Delphin/Beluga, one can recognize .-redices by writing \na meta-variable that is not applied to all enclosing locally bound variables. E.g. in Twelf one would \nwrite -: contract (lam [x] app F x) F. The metavariable F:exp is bound outside the scope of x, and thus \nstands only for terms that do not mention x. (To allow it to mention x, we would bind F:exp -> exp and \nwrite (F x) in place of F.) Unfortunately, Agda does not provide this sort of pattern match\u00ading for our \nencoding pattern variables are always in the scope of all enclosing local binders so we must explicitly \ncall a strength\u00adening function that checks whether the variable occurs: strengthen? : .. (expC . exp) \n. exp option strengthen? . ( i0) =Inr_ strengthen? . ( (iSi))=Inl( i) strengthen? . (app \u00b7 (e1 , e2)) \nwith strengthen? . e1 | strengthen? . e2 ... | Inl e1 | Inl e2 = Inl (app \u00b7 (e1 , e2 )) ...|_ |_ =Inr_ \nstrengthen? . (lam \u00b7 e) with strengthen? (. expC) (exchange2 exp . e) ... | Inl e = Inl (lam \u00b7 e ) ...|_ \n=Inr_ contract-. : .. exp . exp option contract-. . (lam \u00b7 (app \u00b7 (f , i0))) = strengthen? . f contract-. \n. _ = Inr <> We conjecture that strengthen?could be implemented datatype\u00adgenerically for all purely positive \ntypes (no . or .c or .=) it is not possible to decide whether a variable occurs in the values of these \ncomputational types (cf. FreshML, where it is not pos\u00adsible to decide whether a name is in the support \nof a function). This strengthening function is not an instance of the generic map that we de.ne below, \nas it changes the type of the term (exp to exp option); in future work, we plan to consider a more general \ntraversal that admits this operation.  3.4 Normalization by Evaluation In Figure 3, we present a serious \nexample mixing binding and computation, \u00df-normalization-by-evaluation for the untyped .\u00adcalculus. NBE \nworks by giving the syntax a semantics in terms of computational functions (evaluation) and then reading \nback a normal form (rei.cation). The NBE algorithm is similar to a Kripke logical relations argument, \nwhere one de.nes a type-and context-indexed family of relations [ A] in .. The key clause of this de.nition \nis: ''' ([[A arrow B] in .) = ... ([[A] in .,.) . ([[B] in .,.) That is, the meaning of A arrow B in \n. is a function that, for any future extension of the context, maps the meaning of A in that extension \nto the meaning of B in that extension. In our type theory, we represent (a simply-typed version of) this \nlogical relation as a datatype sem. The datatype constructor corresponding to the above clause would \nhave the following type: sem . (.. sem . sem) However, for the argument to go through, we must ensure \nthat the context extension . consists only of variables of a speci.c type neu, so we use a bounded context \nquanti.er below. We represent the semantics by the datatypes neu and sem in Figure 3. The type neu (neutral \nterms) consists of variables or neutral terms applied to semantic arguments (napp); these are the standard \nneutral proofs in natural deduction. A sem(semantic term) is either a neutral term or a semantic function. \nA semantic function of type (.= neuC (sem . sem)) is a computational function that works in any extension \nof the context consisting entirely of neu variables. We de.ne rei.cation .rst, via two mutually recursive \nfunctions, reifyn (for neutral terms) and reify (for semantic terms). It is typical in logical relations \narguments to use two independent contexts, one for the syntax and one for the semantics. Thus, we  napp \n: InS (neuA . neu . sem) neut : InS (semA . neu) slam : InS (semA . (.= neuC (sem . sem))) reifyn : \n.. .c\\ .s -> (var2var neuC .s expC) . [ .s ]* neu . exp reifyn .e .s s ( x)= (s x) reifyn .e .s s (napp \n\u00b7 (n , s)) = app \u00b7 (reifyn .e .s s n , reify .e .s s s) reify : .. .c\\ .s -> (var2var neuC .s expC) . \n[ .s ]* sem . exp reify .e .s s (slam \u00b7 .)= lam \u00b7 reify (.e expC) (.s neuC) (extendv2v .s .e s) (. \n[ neuC ] _ (neut \u00b7 ( i0))) reify .e .s s (neut \u00b7 n) = reifyn .e .s s n reify .e .s s ( x) = impossible \nx appsem : .. sem . sem . sem appsem _ (slam \u00b7 .) s2 = . [] _ s2 appsem _ (neut \u00b7 n) s2 = neut \u00b7 (napp \n\u00b7 (n , s2)) appsem _ ( x) _ = impossible x evalenv : Vars -> Type evalenv .s = (expC #) . ([ .s ]* sem) \n eval : .. .c\\.s -> evalenv .s . exp . ([ .s ]* sem) eval .e .s s ( x)= s x eval .e .s s (app \u00b7 (e1 , \ne2)) = appsem .s (eval .e .s s e1) (eval .e .s s e2) eval .e .s s (lam \u00b7 e) = slam \u00b7 . where . :< .s>(.= \nneuC (sem . sem)) . . ctxinv s = eval (.e expC) (.s+ . ) s e where s :< .e > (expC . (evalenv (.s+ . \n))) s i0 =s s (iS i) = weaken*/bounded sem . ctxinv .s(s i) Figure 3. Normalization by evaluation parametrize \nthese functions by two contexts, one consisting for neu variables for the semantics, and the other consisting \nof exp variables for the syntax. We will write .s for the former and .e for the latter. In the type of \nreify, we must name one of these contexts, be\u00adcause each context scopes over two disconnected parts of \nthe type. We choose to name the semantic context and let the expression con\u00adtext be the ambient one. \nThe outer .. thus binds the expression context, whereas we use the full binding form .c for the seman\u00adtic \ncontext. The type of reify then says that, under some con\u00addition expressed by the type var2var, reify \nmaps semantics in the semantic context (recall that [ . ]* A stands for o (. .* A); lexically, [ . ]* \nA binds more tightly than .) to expressions (in the ambient expression context). The type var2var C1 \n.1 C2 means that every variable of type C1 in .1 maps to a variable of type C2 in the ambient context. \nIt is de.ned in a library as follows: var2var : VarType -> Vars -> VarType -> Type var2var C1 .1 C2 = \n([ .1 ]* (C1 #)) . (C2 #) Even though reify is given a precise type describing the scop\u00ading of variables, \nits code is as simple as one could want. To reify neutral terms: The rei.cation of a variable is the \nvariable given in the substitution. The rei.cation of an application is the applica\u00adtion of the rei.cations. \nTo reify semantic terms: The rei.cation of a function (slam \u00b7 .)is the .-abstraction of the rei.cation \nof an in\u00adstance of .. In the recursive call, the expression context is extended with a new exp variable \n(which is bound by the lam) and the se\u00admantic context is extended with a new neu variable. We instantiate \nthe semantic function ., which anticipates extensions of the con\u00adtext, with this one-variable extension \n([x]constructs a singleton list), and apply it to the variable. The library function extendv2v makes \nthe \"parallel\" extension of a var2var in the obvious way, mapping the one new variable to the other: \nextendv2v : {D1 D2 : VarType} -> (.s : Vars) -> .. (var2var D1 .s D2) . D2 . (var2var D1 (D1 :: .s) D2) \nextendv2v .s .e s (i0) = i0 extendv2v .s .e s (iS i) = iS (s i) The neutral-to-semantic coercion is rei.ed \nrecursively, and we dis\u00adallow sem variables from the context. To de.ne evaluation, we .rst de.ne an auxiliary \nfunction appsem that applies one semantic term to another. This requires a case-analysis of the function \nterm: when it is an slam (i.e. the application is a \u00df-redex), we apply the embedded computational function, \nchoosing the nil context extension, and letting the argu\u00adment be s2. When the function term is neutral, \nwe make a longer neutral term. The type of eval is symmetric to reify, except the environ\u00adment that we \ncarry along in the induction maps expression variables to semantic terms rather than just variables. \nThe type evalenv .s means that every expression variable in the ambient context is mapped to a semantic \nvalue in .s. A variable is evaluated by look\u00ading it up; an application is evaluated by combining the \nrecursive results with semantic application. A lam is evaluated to an slam whose body . has the type \nindicated in the .gure. When given a context extension . and an argument s in that extension, . eval\u00aduates \nthe original body e in an extended substitution. The new sub\u00adstitution s maps the .-bound variable i0 \nto the provided seman\u00adtic value, and defers to s on all other variables. However, s pro\u00advides values \nin .s, which must be weakened into the extension . . Fortunately, the bounded quanti.er provides suf.cient \nevidence to show that weakening can be performed in this case, because sem s can be weakened with neu \nvariables. Normalization is de.ned by composing evaluation and rei.ca\u00adtion. We de.ne a normalizer for \nclosed .-terms as follows: emptyv2v : D (var2var neuC [] expC) emptyevalenv : D (evalenv []) norm : \nD (exp . exp) norm e = reify [] [] emptyv2v (eval [] [] emptyevalenv e) Our type system has veri.ed \nthe scope-correctness of this code, proving that it maps closed terms to closed terms. Amusingly, Agda \naccepts the termination of this evaluator for the untyped .\u00adcalculus, provided that we have told it to \nignore its issues with our universe itself a nice illustration of the need for the positivity check on \ndatatypes. Our companion code includes an alternate version of NBE, which has simpler types (it does \nnot maintain separate contexts .e for expressions and .s for semantics) at the expense of more-complicated \ncode (various appeals to weakening and strengthening are necessary). Comparison. The type semis a truly \nmixed datatype: the premise (.= neuC (sem . sem)) uses both . and . (recall that there is a . buried \nin the de.nition of .=). Because it uses . in a re\u00adcursive datatype, it is not representable in LF. Because \nit uses ., it would not even be representable in Delphin/Beluga extended with standard recursive types \n(that did not interact with the LF part of the language). Despite the fact that our implementation enforces \nstrong invariants about the scope of variables, the code is essentially as simple as the FreshML version \ndescribed by Shinwell et al. (2003), aside from the need to pass the contexts .e and .s along. Invari\u00adants \nabout variable scoping can be proved in Pure FreshML (Pot\u00adtier, 2007), but we would like to enforce these \ninvariants within a type system, not using an external speci.cation logic. Relative to a direct implementation \nin Agda, our framework provides the weak\u00adening function needed in the .nal case of eval for free.  4. \nStructural Properties The structural properties are implemented by instantiating a generic traversal \nfor < . >A. The generic traversal has the following type: map : (A : Type) {.. : Vars} -> (Co A .. ) \n-> < . >A -> < . >A This should be read as follows: for every A .. , under the condition Co A .. , there \nis a map from terms of type A in . to terms of type A in . . Co : Type -> Vars -> Vars -> Set is a variable \nrela\u00adtion, a type-indexed family of relations between two contexts. Co is in fact a (module-level) parameter \nto the generic map; it must provide (1) a variable or term in . for each variable in . that the traversal \nruns into; and (2) enough information to keep the traversal going inductively. We will instantiate Cowith \na speci.c relation for each traversal; e.g., for weakening with a variable of type D, Cowill relate . \nto (. D) under appropriate conditions on D and A. For expository purposes, we present a slightly simpli.ed \nver\u00adsion of the traversal .rst; the generalization is described with weak\u00adening below. 4.1 Compatibility \nWe ensure that Co provides the two pieces of information men\u00adtioned above using the notion of compatibility. \nSuppose that Coand Contraare variable relations. We say that Coand Contraare com\u00adpatible iff there is \na term compat : ({A : Type} {.. : Vars} -> Co A .. -> Compat A .. ) where Compat is de.ned as follows: \nCompat : Type -> Vars -> Vars -> Set Compat (D #) .. = (D . .) -> (D . . ) Compat (D+ D) .. = ({A : Type} \n-> (c : InS (D . A)) -> Co A .. ) \u00d7 ({ch:_}->( D{ch}) . . -> < . > D+ D) Compat (A . B) .. = Contra A \n. . \u00d7 Co B .. Compat (.0 .* A) .. = CoA(. + .0) (. + .0) Compat (list A) .. = CoA .. Compat (D A) .. \n= Unit ... Compat imposes certain conditions on Co and Contra. For exam\u00adple, for variable types D#, it \nsays that Co (D #) .. induces a map from variables of type D in . to variables in . . For de.ned atoms \nD+ D, Compat says that Co (D+ D) .. induces a map from variables in . to terms in . , and that Co A .. \nholds for every premise A of every constant inhabiting D. In all other cases, Compat provides enough \ninformation to keep the induction going in map below. This amounts to insisting that Co (or Contra) holds \non the subexpressions of a type in all appropriate contexts. For ex\u00adample, the condition for .0 .*A is \nthat Co holds for A in the contexts extended with .0. In the usual monadic traversals of syntax (Altenkirch \nand Reus, 1999), Co _ .. is taken to be (D : VarType) -> D . . -> < . >D i.e. a realization of every \nvariable in . as a term in . . In our setting, this does not suf.ce to de.ne a traversal, be\u00adcause (1) \nit does not provide for the contravariant .ip necessary to process the domains of computational functions \nand (2) it does not allow us to express a conditional traversal, where conditions on the map : (A : Type) \n{.. : Vars} -> (Co A .. ) -> < . > A -> < . >A map (D+ Dat) co ( x) = (snd (compat co) x) map (Dat #) \nco x = ((compat co) x) map (A . B) co e = \\ y -> (map B (snd (compat co)) (e (map A (fst (compat co)) \ny))) map (.0 .* A) co e = map A (compat co) e map (list A) co [] = [] map (list A) co (x :: xs) = map \nA (compat co) x :: map (list A) co xs map (D+ Dat) co (_\u00b7_ {A} c e) = c \u00b7 map A (fst (compat co) c) e \nmap (D A) coe=e ... more cases Figure 4. Map (excerpt) types ensure that the traversal will only .nd \ncertain variables, and thus that only those variables need realizations. Compatibility en\u00adsures that \nCo provides enough information for Contra to process the contravariant positions to the left of a computational \narrow. Ad\u00additionally, it permits conditional traversals: below, we will instanti\u00adate Co so that it is \nuninhabited for certain A. 4.2 Map Suppose that Coand Contraare compatible, and assume a function map \n: (A : Type) {.. : Vars} -> (Contra A .. ) -> < . > A -> < . >A that is the equivalent of map for the \nContravariant positions. Then we implement map in Figure 4. In the .rst and second cases, the compatibility \nof Co induces the map on variables that we need. In the third case, we pre-compose the function with \nmap and post-compose with map. In all other cases, map simply commutes with constructors, or stops early \nif it hits a boxed term. 4.3 Exchange/Contraction Exchange and contraction are implemented by one instantiation \nof map. In this case, we take Co A .. = Contra A .. =(. . . \u00d7 . . .) where . means every variable in \none context is in the other. It is simple to show that these relations are compatible, because Co (a) \nprovides the required action on variables directly and (b) ignores its type argument, so the compatibility \ncases for the type constructors are easy. Exchange is de.ned by instantiating the generic map with Co, \nwhere map is taken be map itself, which works because Co = Contra.  4.4 Strengthening Next, we de.ne \na traversal that strengthens away variables that, based on type information, cannot possibly occur. The \ninvariant for strengthening is the following:4 Co : Type -> Vars -> Vars -> Set Co A .. = S \\(D : VarType) \n-> S \\(i : D . .) -> Check(irrel (un D) A) \u00d7 Id . (. -i) Here i, a pointer into the initial context . \nis the variable to be strengthened away; the propositional equality constraint repre\u00adsented by the Identity \nsays that the .nal context . is the ini\u00adtial context with i removed. The type Check(irrel (unC D) A) \n4 For concision, we suppress some details arising from the implementation of irrel, which takes a visited \nlist as an extra argument; see the companion code for details.  computes to Unit when strengthening \nis possible, and Void when it is not. Here unC simply peels off the injection of a de.ned atom into a \nVarType. The crucial property of irrel is that Check(irrel (unC D) (D+ D)) computes to Void. This forbids \nstrengthening a variable of type D out of a term of type D. This is necessary because we cannot satisfy \nthe usual compatibility condition for (D+ D), which would require mapping all variables including the \nvariable-to-be\u00adstrengthened i to a term of type D that does not mention i. More generally, Check(irrel \n(unC D) A) means that vari\u00adables of type Dcan never be used to construct terms of type A, which ensures \nthat strengthening never runs into variables of the type be\u00ading strengthened. The function irrel D Ais \nde.ned by traversing the graph structure of types (i.e., it unrolls the de.nitions of de.ned atoms) and \nchecks not (DefinedAtoms.eq D Dat)for each de\u00ad.ned atom Dat it .nds. To account for contravariance, we \nmust de.ne strengthening simultaneously with weakening by irrelevant assumptions, which is similar. About \n250 lines of Agda code shows that these two relations together are compatible. Their traversals are then \nde.ned by instantiating maptwice, mutually recursively each is passed to the other as map for the contravariant \nrecursive calls.  4.5 Weakening In addition to weakening by irrelevant types (e.g. weakening a nat with \nan exp), we can weaken by types that do not appear to the left of a computational arrow (e.g., weakening \nan exp with an exp). For a simple version of weakening, the variable relation is similar to strengthening, \nbut uses a different computed condition, and .ips the role of . and . (now . is bigger): Co : Type -> \nVars -> Vars -> Set Co A .. = S \\(D : VarType) -> S \\(i : D . . ) -> Check(canWeaken (un D) A) \u00d7 Id . \n(. -i) The function canWeaken is a different graph traversal than before: this time, we check irrel (unC \nD) A for the left-hand side of each computational arrow A . B. Weakening can then be de.ned using strengthening \nin contravariant positions, as irrel is exactly the condition that strengthening requires. This suf.ces \nfor a simple version of weakening. However, we can be more clever, and observe that types of the form \n.. Aare al\u00adways weakenable, because their proofs are explicitly parametrized over arbitrary extensions \nof the context. Similarly, .= CA is weakenable with any context composed entirely of C s. Capitalizing \non this observation requires a slight generalization of the traversal described above: computationally, \nweakening .. A does not re\u00adcursively traverse the proof of A, like map usually does, but stops the traversal \nand instantiates the context quanti.er appropriately. Thus, our actual implementation of mapis parametrized \nso that, for each type A, either it is given suf.cient information to transform A directly (a function \n< . > A -> < . >A), or it has enough information to continue recursively, as in the compatibility condi\u00adtions \ndescribed above. We use the former only for weakening the quanti.ers (map < . -i>(.. A) to < . >(.. A)). \nWe refer the reader to our Agda code for details. All told, weakening takes about 210 lines of Agda code \nto de.ne and prove compatible.  4.6 Substitution Substitution is similar to weakening and strengthening. \nIts invari\u00adant has the same form, using a condition canSubst (unC D) A. This condition ensures two things: \n(1) that Dis irrelevant to the left\u00adhand-sides of any computational arrow, so that substitution can be \nde.ned using weakening-with-irrelevant-assumptions in the con\u00adtravariant position, and (2) that D is \nweakenable with all variable types bound by A, so that the term being plugged in for the variable can \nbe weakened as substitution goes under binders. Substitution takes about 220 lines to de.ne and prove \ncompatible. 5. Related Work We have provided comparisons with several other systems through\u00adout the paper: \nRelative to LF-based systems such as Twelf (Pfen\u00adning and Sch\u00fcrmann, 1999), Delphin (Poswolsky and Sch\u00fcr\u00admann, \n2008), and Beluga (Pientka, 2008), our framework per\u00admits de.nitions that mix binding and computation; \nthis is essen\u00adtial for de.ning the datatype sem in the NBE example. Relative to FreshML (Pottier, 2007; \nShinwell et al., 2003), our framework enforces invariants about variable scoping in the type system. \nSuch invariants can be proved in Pure FreshML (Pottier, 2007), but we would like to enforce these invariants \nwithin a type system, not using an external speci.cation logic. Aydemir et al. (2008) provide a nice \noverview of various tech\u00adniques that are used to implement variable binding, including named, de Bruijn, \n{locally / globally} {named /nameless}, and weak higher-order abstract syntax (Bucalo et al., 2006; Despey\u00adroux \net al., 1995). More recently, Chlipala (2008) has advocated the use of parametric higher-order abstract \nsyntax. We have chosen well-scoped de Bruijn indices (Altenkirch and Reus, 1999; Bel\u00adlegarde and Hook, \n1994; Bird and Paterson, 1999) for our Agda implementation, a simple representation that makes the pronoun \nstructure of variables explicit. It would be interesting to investigate whether any bene.ts can be obtained \nby implementing our uni\u00adverse with a different representation. Relative to these techniques for representing \nbinding, the advantage of our framework is that it provides datatype-generic implementations of the structural \nproper\u00adties, including substitution. Both the Hybrid frameworks (Ambler et al., 2002; Capretta and Felty, \n2007; Momigliano et al., 2007), Hickey et al. (2006) s work, and Lambda Tamer (Chlipala, 2007) describe \nlanguages or tools for specifying data with binding, pro\u00adviding generic implementations of the structural \nproperties. How\u00adever, to the best of our knowledge, these logical frameworks do not make the computational \nfunctions of the meta-language available for use in the framework (except inasmuch as they are, in some \ncases, used to represent binding itself). In contrast, our universe includes both . and .. In this work, \nwe have created a universe of contextual types in Agda. Contextual types appear in Miller and Tiu s work \n(Miller and Tiu, 2003), as well as in contextual modal type theory (Nanevski et al., 2007). Miller and \nTiu s self-dual V connective is closely re\u00adlated to ., also capturing the notion of a scoped constant. \nHow\u00adever, the V proof theory adopts a logic-programming-based dis\u00adtinction between propositions and types, \nand V binds a scoped term constant in a proposition. In our setting, . allows the meaning of certain \npropositions (de.ned atoms) to vary. Fiore et al. (1999) and Hofmann (1999) give semantic accounts of \nvariable binding. In a sense, the present paper gives a semantics for our type theory, where binding \nis represented by an indexed in\u00adductive de.nition. However, this semantics does not shed any new light \non the datatype-generic de.nition of the structural properties; it would be interesting to explore a \nsemantic characterization of the conditions under which weakening and substitution are de.nable. 6. Conclusion \nIn this paper, we have constructed a logical framework supporting datatypes that mix binding and computation: \nOur framework is im\u00adplemented as a universe in the dependently typed programming lan\u00adguage Agda. Binding \nis represented in a pronominal manner, so the type system can be used to reason about the scoping of \nvariables. Our implementation provides datatype-generic implementations of the structural properties \n(weakening, subordination-based strength\u00adening, exchange, contraction, and substitution). We have used \nthe framework to program a number of examples, including a scope\u00adcorrect version of the normalization-by-evaluation \nchallenge prob\u00adlem discussed by Shinwell et al. (2003). We believe that these ex\u00adamples demonstrate the \nviability of our approach for simply-typed programming.  We hope also to have clari.ed the gap between \nLF-based sys\u00adtems for programming with binding, such as Twelf, Delphin, and Beluga, and a generic dependently \ntyped programming language like Agda. For simply-typed programming, the bene.ts of the LF\u00adbased systems \nthat we were unable to mimic include: (1) the ability to write pronominal variables with a named syntax; \nand (2) a conve\u00adnient syntax for applying the structural properties. For example, the syntax of weakening \nand strengthening is relatively heavy in our setting. In Twelf, weakening is silent, and strengthening \n(includ\u00ading strengthen?used in the .-contraction example) is marked by saying which variables do occur, \nusing a non-linear higher-order pattern. In our Agda implementation, weakening must be marked explicitly, \nand strengthening requires one to enumerate those vari\u00adables that do not occur instead. However, the \nmore convenient syn\u00adtax seems within reach for a standalone implementation of our framework; e.g., weakening \ncould be implemented using a form of coercive subtyping. Of course, one way in which all of the LF-based \nsystems out\u00adpace ours is that they support dependent types, which are crucial for representing logics \nand for mechanizing metatheory. Our most pressing areas of future work are to investigate a dependently \ntyped extension of our universe, and to address the termination issues that we have deferred here. One \nkey issue for the dependently typed version will be the equational behavior of the structural properties, \nwhich we have not yet investigated. We would hope that they have the right behavior up to propositional \nequality (otherwise there is a bug in the code presented here), but it remains to be seen whether we \ncan get Agda s de.nitional equality to mimic the equations proved automatically by, e.g., Twelf. That \nsaid, the fact that the map function de.ned in Section 4 commutes with all term constructors de.nitionally \nin Agda gives us some hope in this regard. A. Agda Overview In this section, we review Agda s syntax, \nwe show a simple ex\u00adample of well-scoped de Bruijn indices, and we give a simple example of a universe. \nWe refer the reader to the Agda Wiki (http://wiki.portal.chalmers.se/agda/) for more intro\u00adductory materials. \n  A.1 Well-scoped de Bruijn indices in Agda We review the representation of well-scoped de Bruijn indices \nas an indexed inductive de.nition (Altenkirch and Reus, 1999; Bellegarde and Hook, 1994; Bird and Paterson, \n1999). Agda data types are introduced as follows: data List (A : Set) : Set where [] :ListA _::_ : A \n-> List A -> List A Setclassi.es Agda classi.ers, like the kind typein ML or Haskell. Mix.x constructors \nare declared by using _in an identi.er; e.g., :: can now be used in.x as in Zero :: (Zero :: []). Functions \nare de.ned by pattern-matching: append : {A : Set} -> List A -> List A -> List A append [] ys = ys append \n(x :: xs) ys = x :: (append xs ys) The curly-braces mark an implicit dependent function space. Applications \nto implicit arguments are not marked in the program; e.g., we do not explicitly apply append to the Set \nargument A. Agda attempts to infer implicit function arguments and reports an error if they cannot be \nreconstructed. Indexed datatypes are de.ned using a notation similar to GADTs in GHC. For example, we \nde.ne a datatype . representing indices into a list: data _._ {A : Set} : A -> List A -> Set where i0:{x:A} \n{xs:ListA}->x . (x :: xs) iS : {x y : A} {xs : List A} -> y . xs -> y . (x :: xs) For any Set A, and \nterms x and xs of type A and List A, there is a type x . xs. The .rst constructor, i0, creates a proof \nof x . (x :: xs) i.e. x is the .rst element of the list. The second constructor iS, creates a proof of \nx . (y :: xs) from a proof that x is in the tail. As a simple example of dependent pattern matching, \nwe de.ne an n-ary version of iS: skip : {A : Set} (xs : List A) {ys : List A} {y : A} -> y . ys -> y \n. (append xs ys) skip[] i=i skip (x :: xs) i = iS (skip xs i) We use an implicit-quanti.er for all arguments \nbut the list xs; explicit-quanti.ers are written with parentheses instead of curly\u00adbraces. The fact that \nthis code type-checks depends on the compu\u00adtational behavior of append; e.g., in the .rst case, the expression \nappend [] ys reduces to ys, so we can return the index i un\u00adchanged. Well-scoped syntax for the untyped \n.-calculus is de.ned as follows: data Term (G : List Unit) : Set where : <> . G -> Term G Lam : Term \n(<> :: G) -> Term G App : Term G -> Term G -> Term G The type Unit is de.ned to be the record type with \nno .elds, with inhabitant written <>. We represent variables as indices into a list G containing elements \nof the one-element type Unit. (Such lists are isomorphic to natural numbers, but this illustrates the \npattern for variables of more than one type.) The constructor C makes a term from an index into G, which \nrepresents a variable. The body of Lam can refer to all of the variables in G, as well as a new bound \nvariable represented by extending G to (<> :: G). The K combinator .x..y.x is represented as follows: \nLam (Lam (C (iS i0))). The values of Term G correspond exactly to the .-terms with free variables in \nG.  A.2 Universes A universe is speci.ed by a inductive datatype of codes for types, along with a function \nmapping each code to a Set. For example, a simple universe with an empty type, a unit type, and binary \nproducts is speci.ed as follows: data Type : Set where 0+ : Type 1+ : Type _._ : Type -> Type -> Type \nElement : Type -> Set Element 0+ = Void Element 1+ = Unit Element (t1 . t2) = (Element t1) \u00d7 (Element \nt2) In the right-hand side of Element, we write A \u00d7 B for the Agda pair type, etc. Datatype-generic programs \nare implemented by recursion over the codes; e.g, every element of the universe can be converted to a \nstring:  show : (t : Type) -> Element t -> String show 0+ () show 1+ <> = \"<>\" show (t1 . t2) (e1 , \ne2) = \"< \" ^ (show t1 e1) ^ \" , \" ^ (show t2 e2) ^ \" >\" In the .rst clause, the empty parentheses are \na refutation pat\u00adtern, telling Agda to check that the type in question (in this case Element 0+) is uninhabited, \nand allowing the programmer to elide the right-hand side. As another example, we will often view booleans \nas a two\u00adelement universe, with only True inhabited: data Bool : Set where True : Bool False : Bool Check \n: Bool -> Set Check True = Unit Check False = Void Because Agda implements extensionality for Unit (there \nis only one record with no .elds), terms of type Check True can be left implicit and inferred. Acknowledgements \nWe thank Noam Zeilberger for discussions about this work, and we thank the anonymous reviewers for their \nhelpful feedback on an earlier version of this article. References M. Abbott, T. Altenkirch, and N. Ghani. \nContainers: constructing strictly positive types. Theoretic Computer Science, 342(1):3 27, 2005. T. Altenkirch \nand C. McBride. Generic programming within dependently typed programming. In IFIP TC2 Working Conference \non Generic Programming, Schloss Dagstuhl, 2003. T. Altenkirch and B. Reus. Monadic presentations of lambda \nterms using generalized inductive types. In CSL 1999: Computer Science Logic. LNCS, Springer-Verlag, \n1999. S. Ambler, R. L. Crole, and A. Momigliano. Combining higher order abstract syntax with tactical \ntheorem proving and (co)induction. In International Conference on Theorem Proving in Higher-Order Logics, \npages 13 30, London, UK, 2002. Springer-Verlag. B. Aydemir, A. Chargu\u00e9raud, B. C. Pierce, R. Pollack, \nand S. Weirich. Engineering formal metatheory. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages, pages 3 15, 2008. F. Bellegarde and J. Hook. Substitution: A formal methods case study using \nmonads and transformations. Science of Computer Programming, 23(2 3):287 311, 1994. U. Berger and H. \nSchwichtenberg. An inverse of the evaluation functional for typed .-calculus. In IEEE Symposium on Logic \nin Computer Science, 1991. R. S. Bird and R. Paterson. De Bruijn notation as a nested datatype. Journal \nof Functional Programming, 9(1):77 91, 1999. A. Bucalo, M. Hofmann, F. Honsell, M. Miculan, and I. Scagnetto. \nConsis\u00adtency of the theory of contexts. Journal of Functional Programming, 16 (3):327 395, May 2006. \nV. Capretta and A. Felty. Combining de Bruijn indices and higher-order abstract syntax in Coq. In Proceedings \nof TYPES 2006, volume 4502 of Lecture Notes in Computer Science, pages 63 77. Springer-Verlag, 2007. \nA. Chlipala. A certi.ed type-preserving compiler from .-calculus to assem\u00adbly language. In ACM SIGPLAN \nConference on Programming Language Design and Implementation, 2007. A. Chlipala. Parametric higher-order \nabstract syntax for mechanized se\u00admantics. In ACM SIGPLAN International Conference on Functional Programming. \nACM, 2008. K. Crary. Explicit contexts in LF. In International Workshop on Logical Frameworks and Meta-Languages: \nTheory and Practice, 2008. J. Despeyroux, A. Felty, and A. Hirschowitz. Higher-order abstract syntax \nin Coq. In M. Dezani-Ciancaglini and G. Plotkin, editors, International Conference on Typed Lambda Calculi \nand Applications, volume 902 of Lecture Notes in Computer Science, pages 124 138, Edinburgh, Scot\u00adland, \n1995. Springer-Verlag. M. Fiore, G. Plotkin, and D. Turi. Abstract syntax and variable binding. In IEEE \nSymposium on Logic in Computer Science, 1999. J. Hickey, A. Nogin, X. Yu, and A. Kopylov. Mechanized \nmeta-reasoning using a hybrid HOAS/de Bruijn representation and re.ection. In ACM SIGPLAN International \nConference on Functional Programming, pages 172 183, New York, NY, USA, 2006. ACM. M. Hofmann. Semantical \nanalysis of higher-order abstract syntax. In IEEE Symposium on Logic in Computer Science, 1999. D. R. \nLicata, N. Zeilberger, and R. Harper. Focusing on binding and computation. In IEEE Symposium on Logic \nin Computer Science, 2008. P. Martin-L\u00f6f. An intuitionistic theory of types: Predicative part. In H. \nRose and J. Shepherdson, editors, Logic Colloquium. Elsevier, 1975. C. McBride and J. McKinna. The view \nfrom the left. Journal of Functional Programming, 15(1), 2004. D. Miller and A. F. Tiu. A proof theory \nfor generic judgments: An extended abstract. In IEEE Symposium on Logic in Computer Science, pages 118 \n127, 2003. A. Momigliano, A. Martin, and A. Felty. Two-level hybrid: A system for reasoning using higher-order \nabstract syntax. In International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice, \n2007. A. Nanevski, F. Pfenning, and B. Pientka. Contextual modal type theory. Transactions on Computational \nLogic, 2007. To appear. U. Norell. Towards a practical programming language based on dependent type theory. \nPhD thesis, Chalmers University of Technology, 2007. F. Pfenning and C. Sch\u00fcrmann. System description: \nTwelf -a meta-logical framework for deductive systems. In H. Ganzinger, editor, International Conference \non Automated Deduction, pages 202 206, 1999. B. Pientka. A type-theoretic foundation for programming \nwith higher-order abstract syntax and .rst-class substitutions. In ACM SIGPLAN-SIGACT Symposium on Principles \nof Programming Languages, pages 371 382, 2008. A. M. Pitts and M. J. Gabbay. A metalanguage for programming \nwith bound names modulo renaming. In R. Backhouse and J. N. Oliveira, editors, Mathematics of Program \nConstruction, volume 1837 of Lecture Notes in Computer Science, pages 230 255. Springer-Verlag, Heidelberg, \n2000. A. Poswolsky and C. Sch\u00fcrmann. Practical programming with higher\u00adorder encodings and dependent \ntypes. In European Symposium on Programming, 2008. F. Pottier. Static name control for FreshML. In IEEE \nSymposium on Logic in Computer Science, 2007. M. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: \nProgramming with binders made simple. In ACM SIGPLAN International Conference on Functional Programming, \npages 263 274, August 2003. R. Virga. Higher-Order Rewriting with Dependent Types. PhD thesis, Carnegie \nMellon University, 1999.  \n\t\t\t", "proc_id": "1596550", "abstract": "<p>We construct a logical framework supporting datatypes that mix binding and computation, implemented as a universe in the dependently typed programming language Agda 2. We represent binding pronominally, using well-scoped de Bruijn indices, so that types can be used to reason about the scoping of variables. We equip our universe with datatype-generic implementations of weakening, substitution, exchange, contraction, and subordination-based strengthening, so that programmers need not reimplement these operations for each individual language they define. In our mixed, pronominal setting, weakening and substitution hold only under some conditions on types, but we show that these conditions can be discharged automatically in many cases. Finally, we program a variety of standard difficult test cases from the literature, such as normalization-by-evaluation for the untyped lambda-calculus, demonstrating that we can express detailed invariants about variable usage in a program's type while still writing clean and clear code.</p>", "authors": [{"name": "Daniel R. Licata", "author_profile_id": "81100639330", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1614005", "email_address": "", "orcid_id": ""}, {"name": "Robert Harper", "author_profile_id": "81100140064", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1614006", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596571", "year": "2009", "article_id": "1596571", "conference": "ICFP", "title": "A universe of binding and computation", "url": "http://dl.acm.org/citation.cfm?id=1596571"}