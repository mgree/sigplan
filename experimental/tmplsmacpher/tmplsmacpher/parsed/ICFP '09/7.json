{"article_publication_date": "08-31-2009", "fulltext": "\n EffectiveInteractiveProofsforHigher-OrderImperative Programs* AdamChlipala GregoryMalecha GregMorrisett \nAvrahamShinnar RyanWisnesky HarvardUniversity,Cambridge,MA,USA {adamc, gmalecha, greg, shinnar, ryan}@cs.harvard.edu \nAbstract We present a new approach for constructing and verifying higher\u00adorder,imperativeprograms using \ntheCoqproof assistant.Webuild on the past work on the Ynot system, which is based on Hoare Type Theory. \nThat original system was a proof of concept, where every program veri.cation was accomplished via laborious \nman\u00adual proofs, with much code devoted to uninteresting low-level de\u00adtails. In this paper, we present \na re-implementation of Ynot which makesitpossible toimplementfully-veri.ed,higher-orderimpera\u00adtiveprograms \nwith reasonableproofburden. At the same time, our new system is implemented entirely in Coq source .les, \nshowcas\u00ading the versatility of thatproof assistantasaplatformforresearch onlanguage design and veri.cation. \nBothversions ofthe systemhavebeen evaluated with case stud\u00adiesinthe veri.cation ofimperativedata structures, \nsuchashash ta\u00adbles withhigher-orderiterators.The veri.cationburdenin our new systemis reducedby atleast \nan order of magnitude comparedtothe old system, by replacing manual proof with automation. The core of \nthe automation is a simpli.cation procedure for implications in higher-order separation logic, with hooks \nthat allow programmers to adddomain-speci.c simpli.cation rules. We arguefor the effectiveness ofourinfrastructureby \nverifying a number of data structures and a packrat parser, and we compare to similar efforts within \nother projects. Compared to competing approaches todata structure veri.cation, our systemincludes much \nless codethatmustbetrusted; namely, about ahundredlines ofCoq code de.ning a program logic. All of our \ntheorems and decision procedures have or build machine-checkable correctness proofs from .rstprinciples,removing \nopportunitiesfortoolbugstocreate faulty veri.cations. Categories and Subject Descriptors F.3.1[Logics \nand meanings of programs]:Mechanicalveri.cation; D.2.4[Software Engineer\u00ading]:Correctnessproofs,formalmethods, \nreliability General Terms Languages,Veri.cation Keywords functional programming, interactive proof assistants, \ndependent types, separationlogic * This researchwas supportedinpartbyagiftfromMicrosoftResearchand aNational \nScienceFoundationGraduateResearchFellowship. Permission to make digital or hard copies of all or part \nof this work for personal or classroomuseisgranted withoutfeeprovided that copiesarenot madeordistributed \nforpro.tor commercial advantage andthat copiesbearthis notice andthefull citation onthe .rstpage.Tocopy \notherwise,torepublish,topostonservers ortoredistribute tolists, requiresprior speci.cpermission and/or \nafee. 1. Introduction Akeygoal of typesystemsistoprevent bad states fromarising in the execution of \nprograms. However, today s widely-used type systems lack the expressiveness needed to catch language-level \nerrors, such as a null-pointerdereference or an out-of-bounds array index, let alone library-and application-speci.c \nerrors such as removing an element from an empty queue, failing to maintain the invariants of a balanced \ntree, or forgetting to release a critical resource such as a database connection. For safety-and security\u00adcritical \ncode, a type system should ideally let the programmer assign types to libraries such that client code \ncannot suffer from these problems, and, in the limit, the type system should make it possibleforprogrammers \nto verifythat their codeis correct. There are many recent attempts to extend the scope of type systems \nto address a wider range of safety properties. Represen\u00adtative examples include ESC/Java (Flanagan et \nal. 2002), Epi\u00adgram(McBride andMcKinna2004),Spec#(Barnett et al.2004), ATS(Chen andXi2005),Concoqtion(Pasalicetal.2007),Sage(Gron\u00adski \net al. 2006), Agda (Norell 2007), and Ynot (Nanevski et al. 2008).Each of these systemsintegrates someform \nof speci.cation logicinto thetype systemin order to rule out a wider range oftruly bad states. However,inthe \ncase ofESC/Java,Spec#, andSage,theprogram logicis too weak to support full veri.cationbecause these systems \nrely completely upon provers to discharge veri.cation conditions automatically. While there havebeen \ngreat advances in theperfor\u00admanceof automatedprovers,inpractice,they canonlyhandle rel\u00adatively shallow \nfragments of .rst-order logic. Thus, programmers arefrustrated when correct codeisrejectedbythetype-checker.For \nexample, none of these systemsis able toprove that an arrayindex isinbounds when the constraints stepoutsidequanti.er-freelinear \narithmetic. In contrast, Agda, ATS, Concoqtion, Epigram, and Ynot use powerful, higher-order logics that \nsupport a much wider range of policies including (partial) correctness. Furthermore, in the case of Ynot, \nprogrammers can de.ne and use connectives in the style of separation logic (Reynolds 2002) to achieve \nsimple, modular speci.cations of higher-order imperative programs. For example, a recentpaper(Nanevski \net al.2008) coauthoredby some ofthe present authors describes how Ynot was used to construct fully\u00adveri.ed \nimplementations of data structures such as queues, hash tables,and splay trees,including supportforhigher-orderiterators \nthat take effectfulfunctions as arguments. Thepricepaidforthese morepowerful type systemsisthat,in general,programmers \nmustprovide explicitproofs to convince the type-checker that codeis correct.Unfortunately, explicitproofs \ncan bequitelarge when comparedtothe code.For example,intheYnot code implementing dequeue for imperative \nqueues, only 7 lines ICFP 09, August31 September2,2009,Edinburgh,Scotland,UK. Copyright c &#38;#169; \n2009ACM978-1-60558-332-7/09/08. . .$5.00  of program code are required, whereas the proof of correctness \nis about70lines. Thispaper reports ourexperience re-designingand re-implementing Ynot todramatically \nreduce theburden of writing and maintaining the necessary proofs for full veri.cation. Like the original \nYnot, our systemisbased ontheideas ofHoareTypeTheory(Nanevski et al. 2006) and is realized as an axiomatic \nextension of the Coq proof assistant(Bertot andCast\u00b4eran2004).This allows us toin\u00adherit the full power \nof Coq s dependent types for writing code, speci.cations, andproofs, andit allows us to useCoq sfacilityfor \nextraction to executableML code.However, unlikein theprevious version, we have taken advantage of Coq \ns tactic language, Ltac, to implement a set of parameterized procedures for automatically discharging, \nor at least simplifying, the separation logic-style ver\u00adi.cationconditions.Thecarefuldesign of theseprocedures \nmakes itpossibleforprogrammers to teachtheprover about newdomains as they arise. We describe this new \nimplementation of Ynot and report on our experienceimplementing and verifying variousimperativedata structuresincluding \nstacks,queues,hashtables,binomialtrees, and binary search trees. When compared with the previous version \nof Ynot, we observe roughlyan order of magnitude reductioninproof size. In most cases, to realize automation, \nprogrammers need only provekeylemmas regardingtheabstractions usedintheirinterfaces andplug theselemmasinto \nour extensible tactics.Additionally, we show that the tactics used togenerate theproofs are robust to \nsmall changesin the code or speci.cations. In the next section, weintroduce the new Ynotin tutorial style. \nNext, we describe the automation tactics that we built, report on further evaluation of our system via \ncase studies, compare with related work, and conclude. 1.1 Coq asanExtensibleAutomatedTheoremProver Almost \neveryone familiar with Coq associates it with a particu\u00adlar style of proof development, which might be \ncalled the video game approach, after a comment by Xavier Leroy. A theorem is proved in many steps of \nmanual interaction, where Coq tells the user whichgoals remain tobeproved, the user enters a short com\u00admand \nthat simpli.es the current goal somewhat, and the process repeats until nogoals remain.One of our ancillary \naimsin thispa\u00adper is to expose a broad audience to a more effective proof style. Coq provides very good \nsupport for fully automatic proving, via its domain-speci.c programming language Ltac(Delahaye 2000). \nThis support can be mixed-and-matched with more manual prov\u00ading, anditis usually the case that a well-writtendevelopment \nstarts out moremanual andgradually transformstoa .nalformwhereno sequentialproof steps are spelled outbeyond \nwhichinductionprin\u00adciple to use. Proof scripts of that kind often adapt without change to alterationsin \nspeci.cations andimplementations. We believe that awareness of this style is one of the crucial missing \npieces blocking widespread use of proof assistants. We hope that the reader will agree that some of the \nexamples that follow provide evidence that, for programmers with a few years of training using proof \nassistants, imperative programming with correctness veri.cation need notbe muchharderthanprogramming \ninHaskell.  2. TheYnotProgrammingEnvironment To a .rst approximation, Coq can be thought of as a functional \nprograming language like Haskell or ML, but with support for dependent types. For instance, one can have \noperations with types such as: div :nat -> forall n:nat, n<> 0-> nat which uses dependency to capture \nthe fact that div can only be called when a proof can be supplied that the second argument is non-zero.One \ncan also writefunctions such as: Definition avg (x:list nat) : nat := let sum := fold plus 0 x in let \nlen := length x in match eq_nat_dec len 0 with | inl(pf1: len = 0) => 0 | inr(pf2: len <> 0) => div \nsum len pf2 end. Thisfunction averages the valuesin alistof natural numbers.It has a normal type like \nyou might .nd in ML, and its implementa\u00adtionbeginsin anML-like way, using ahigher-order fold function. \nTheinterestingpartisthematch expression.Wematch ontheresult of a call to eq nat dec,adependently-typed \nnatural numbercom\u00adparisonfunction.Thisfunction returns a sum type withan equality proofin onebranch and \naninequalityproofin the other.Webind a name for each proof explicitly in the pattern for each match case. \nTheproof that len is not zeroispassed to div tojustify the safety of the operation. AllCoqfunctionshavetobepure \nterminating without sideef\u00adfects.Thisis necessary to ensure thatproofs really areproofs, with no spurious \ninvalid proofs by in.nite loop. Ynot extends Coq with support for side-effecting computations. Similarly \ntoHaskell, we introduce a monadic type constructor ST T which describes computations that might diverge \nand that might have side effects, butthat,iftheydo return, return values oftypeT.The ST typefam\u00adilyprovides \na safe way tokeep the effectful computations separate from thepure computations. Unlike Haskell s IO \nmonad, the ST type family is parameter\u00adized by a pre-and post-condition, which can be used to describe \nthe effects of the computation on a mutable store. Alternatively, one can think of the axiomatic base \nof Ynot as a fairly standard Hoare logic. The main difference of our logic from usual presen\u00adtationsis \nthatitisdesigned tointegrate well withCoq sfunctional programming language. Therefore, instead of de.ning \na language of commands, we formalize a language of expressions in the style of theIO monad. Aprogramderivation \nis of theform {P} e {Q}, where P is a pre-condition predicate over heaps, and Q is a post\u00adconditionpredicate \nover aninitialheap, the value that resultsfrom evaluating e, and a .nal heap. For instance, where we \nwrite sel and upd for the heap selection and update operations used in the ESCtools(Flanagan etal.2002), \nwe canderivethefollowingfacts, where p1 and p2 are pointer variables bound outside of the com\u00admands that \nwe are verifying. {. . .} return(1) {.h, v,h ' .h ' = h. v =1} and {.h.sel(h,p1 )= p2 } x . !p1 ; x := \n1 {.h, ,h ' . sel(h,p1 )= p2 . h ' = upd(h,p2 , 1)} Unlike other systems, Ynot does not distinguish \nbetween pro\u00adgrams and derivations. Rather, the two are combined into one de\u00adpendent type family, whose \nindices give the speci.cations of pro\u00adgrams.Forinstance,thetypeofthe return examplewouldbe: ST (fun _=> \nTrue) (fun h vh => h = h/\\ v= 1) Heaps are representedasfunctionsfrompointerstodynamically\u00adtyped packages, \nwhich are easy to implement in Coq with an in\u00adductive typede.nition.Thepointer readrule enforces thattheheap \nvalue being read has the type that the code expects. The original Ynotpaper(Nanevski et al.2008) containsfurtherdetails \nof the baseprogramlogic.  {P1 } e1 {Q1 } (.x,{P2 (x)} e2 {Q2 })(.x,Q1 (x) . P2 (x)) {emp} return(v) \n{.v ' . [v = v ' ]}{P1 } x . e1 ; e2 {Q2 } {emp} new(v) {.p.p . v} {.v,p . v} free(p) {. . emp} {.v,p \n. v * P(v)} !p {.v.p . v * P(v)} {.v,p . v} p := v ' {. .p . v ' } '' } e {Q ' Q ' P . P {P }. Q {P} \ne {Q} {P} e {Q}{P * R} e {Q* R} Figure1. The main rules of thederived separationlogic 2.1 ADerivedSeparationLogic \nDirectreasoning aboutheapsleadsto very cumbersomeproof obli\u00adgations, with many sub-proofsthatpairs ofpointers \narenot equal. Separation logic(Reynolds 2002) is the standard tool for reducing that complexity. Theprevious \nYnot systembuilt a separation logic on top of the axiomatic foundation, and we do the same here. We introduce \nno new inductive type of separation logic formulas. In\u00adstead, wede.nefunctions that operate on arbitrarypredicates \nover heaps, withtheintention that we will only apply thesefunctions on separation-styleformulas.Nonetheless,it \ncanbehelpfultothink of our assertionlanguage asde.nedby: P ::= [f] | x . y | P * P |.x,P For any pure \nCoq proposition f, [f] is the heap predicate that asserts that f is true and the heap is empty. We write \nemp as an abbreviation for [True], which asserts only that the heap is empty. x . y asserts that the \nheap contains only a mapping from x to y. P1 * P2 asserts that theheap can be broken into twoheaps h1 \nand h2 withdisjointdomains, such that h1 satis.es P1 and h2 satis.es P2 .The .nal clauseprovidesexistentialquanti.cation. \nTheembeddinginCoqprovides much more expressiveformu\u00adlas than in most systems based on separation logic. \nNot only can any pure proposition be injected with [\u00b7], but we can also use ar\u00adbitrary Coq computation \nto build impure assertions. For instance, we can model deterministic disjunction with pattern-matching \non values of algebraic datatypes, and we can include calls to cus\u00adtom recursive functions that return \nassertions. We need no special support in the assertion language to accommodate this, and Coq s theorem-proving \nsupport for reasoning about pattern-matching re\u00adcursivefunctions canbe used without modi.cation. If wehadde.ned \naninductive type of speci.cations, we would have needed to encode most of the relevant Coq features explic\u00aditly. \nFor instance, to allow pattern matching that produces speci.\u00adcations, our inductive type would need a \nconstructor standing for dependentpattern matching, whichisquite a tallorder onits own. Perhaps surprisingly, \nwe have met with general success in im\u00adplementing realistic examples usingjust these connectives. Stan\u00addard \nuses of other connectives can often be replaced by uses of higher-order features, and the connectives \nthat we do use are par\u00adticularly amenable to automation. In Section 2.2, we try to give a .avor of how \nto encode disjunction, in the context of a particular example. Fully-automated systems like Smallfoot \n(Berdine et al. 2005) build in restrictions similar to ours, but it surprised us that we neededlittle \nmore todofull correctness veri.cation. 2.1.1 TheImportanceofComputationalIrrelevance What we have described \nso far is the same as in the original Ynot work. The primary departure of our new system is that we use \na more standard separationlogic.The oldYnot separationlogic used binary post-conditions that may refer \nto both the initial and .nal heaps.(Inbothsystems,speci.cationsmay refertocomputation result values, \nso we avoid counting thoseindistinguishingbetween unary and binary post-conditions.) This is in stark \ncontrast to traditionalseparationlogics, where all assertions are separationfor\u00admulasoverasingleheap,and \nall veri.cationproof obligationsare implicationsbetween such assertions.The utility of thisformalism \nhas been born out in the wealth of tools that have used separation logic for automated veri.cation. In \ncontrast, proofs of the binary post-conditions in the old Ynot tended to involve at least tens of steps \nof manualproofperline ofprogram code.Today, evenpencil\u00adand-paper proofs about relationships between multiple \nheaps can draw on no logical formalism that comes close to separation logic in crispness or extent of \nempirical validation. While binary post\u00adconditions are strictly more expressive than unarypost-conditions, \nthe separationlogic communityhasdeveloped standard techniques for mitigatingtheproblem. To make up for \nthis lost expressiveness, we need, in effect, to move to a richer base logic. The key addition that lets \nus use a more standard formulation is the feature of computationally\u00adirrelevant variables, which correspond \nto speci.cation variables (also known as ghost variables ) in standard separation logic. Suchvariables \nmaybe mentionedin assertions andproofs only, and an implementation must enforce that they are not used \nin actual computation. Coq * , a system based on the Implicit Calculus of Constructions (Barras and Bernardo \n2008), supports this feature natively. From a theoretical standpoint, it would be cleanest to implement \nYnot as a Coq * library. However, in implementing the original Ynot system, we hesitated to switch to \nthis nonstandard branch of theCoqdevelopmenttree.Indesigning thenewsystem, we felt the same trepidation, \nsince we might encounter dif.culties using libraries written for the standard Coq system, and the users \nof ourlibrary would need toinstall anunusual versionofCoq.We hope that,inthelongterm,the newCoq * features \nwillbecomepart of the standardCoqdistribution. For now, we use an encodingof computationally-irrelevant \nvari\u00adablesthatis effectivein standardCoq, modulo some caveatsthat we discuss below. Our reimplementation \nemploys the trick of repre\u00adsenting speci.cationvariablesintypesthat aremarked as proofs instead of programs, \nsuch that we can take advantage of Coq s standard restrictions on information .ow from proofs to pro\u00adgrams.Concretely, \ntheCoqstandardlibraryhasfor some time con\u00adtained a typefamily called inhabited, de.nedby: Inductive inhabited \n(A:Type) : Prop := inhabits : A -> inhabited A.  This code demonstrates Coq s standard syntax for inductive \ntype de.nitions, which is quite similar to the syntax for algebraic datatype de.nitions in ML and Haskell. \nThis type family has one parameter A of type Type, which can be thought of as the type of all types1.The \nconstructor inhabits lets us inject any value into inhabited. While the original value may have an arbitrary \ntype, the inhabited package has a type in the universe Prop, theuniverse oflogicalpropositions.Termswhosetypesareinthis \nuniverse are considered to be proofs and are erased by program extraction. We willseeinthefollowing exampleshowthis \nencoding neces\u00adsitates some mildly cumbersome notation around uses ofirrelevant variables. Further, to \nreason effectively about irrelevant variables, we need to assert withoutproof an axiom stating that the \nconstruc\u00adtor inhabits isinjective. Axiom pack_injective : forall (T : Set) (x y : T), inhabits x = inhabits \ny -> x = y. Our library additionally assumes the standard axiom of function extensionality ( functions \nare equal if they agree at all inputs ) and the very technical unicity of equality proofs axiom that \nis included in Coq s standard library. This pair of axioms has been proved consistent for Coq s logic, \nand we could avoid appealing to extensionality at the cost of more proving work in the library, by formalizing \nheaps as lists instead of functions. Such a change would be invisible to most users of the library, who \nonly need to use standard theoremsproved about theheap model. However, the pack injectivity axiom contradicts \nthe axiom of proofirrelevance(whichwedo not usein any of ourdevelopments, but which ispopular among Coq \nusers), and itis an openquestion in theCoq community whether this axiomis consistent withCoq s logic \neven by itself.Past work built a denotational model forYnot minusthisfeature(Petersenet al.2008), and \nthe architects of that model are now considering how to add irrelevance, which would complete the foundational \nstory for the framework that we use in thispaper.Wehope that the experiences we reporthere canhelp to \njustifytheinclusion ofirrelevance as a coreCoqfeature.  2.1.2 TheRulesof theSeparationLogic Figure 1 \npresents the main rules of our separation logic. The no\u00adtable divergence from common formulations is \nin the use of ex\u00adistential quanti.ers in the rules for freeing, reading, and writing. Thesedifferences \nmake sensebecauseYnotisimplemented within a constructive logic. Coq s constructivity is inspired by the \nCurry-Howardisomorphism, whereprogramsandproofscanbeencoded in the same syntactic class. A more standard, \nclassical separation logic would probably require that, in the rule for free, the value v pointedtobypbeprovidedas \nan argumenttotheproof rule.In con\u00adstructive logic, such a value can only be produced when it can be computedby \nan algorithm,just as afunctionalprogram may only refer to a value that it has said how to compute. Additionally, \nwe would not be able to use any facts implied by the current heap as\u00adsertiontobuild one ofthese rule \nwitnesses, andperhaps the witness can onlybeprovedto exist using suchfacts.The explicit existential quanti.erfreesustoreasoninsidetheassertionlanguagein \n.nding the witness. Because it uses quanti.cation in this way, the read rule must also take a kind of \nexplicit framing condition. This condition is parameterized by the value being read from the heap, making \nit a kind of description of the neighborhood around that value in the heap. More standard separation \nlogics force the exact value being 1To avoid the standard soundness problems with including a type of \nall types, actualCoqtype-checkinginfers numericalindicesfor all occurrences of Type. Module Type STACK. \n Parameter t : Set -> Set. Parameter rep (T : Set) : t T -> list T -> hprop. Parameter new T : Cmd \nemp (fun s: tT=> rep s nil). Parameter free T (s : t T) : Cmd (rep s nil) (fun _ : unit => emp). Parameter \npush T (s : t T) (x : T) (ls : [list T]) : Cmd (ls ~~ rep s ls) (fun _: unit => ls ~~ rep s(x :: ls)). \n Parameter pop T (s : t T) (ls : [list T]) : Cmd (ls ~~ rep s ls) (fun xo : option T => ls ~~ match \nxo with | None => [ls = nil] * rep s ls | Some x => Exists ls :@ list T, [ls =x :: ls ] * rep s ls \n end). End STACK. Figure2. The signature of animperative stack module read to be presented as an argument \nto the proof rule, but here we wantto allow veri.cation ofprograms wherethe exact valueto read cannotbe \ncomputedfrom thepieces ofpuredata that arein scope. We want to emphasize that the changes we have made \nin the Ynot separation logic have no effect on the theory behind the sys\u00adtems.Inboth the old and new \nsystems, a separationlogicisde.ned on top of the base Hoare logic with binary post-conditions, intro\u00adducing \nno new axioms. Here, we use the same base logic as in the past work, sothepastinvestigationsintoits metatheory(Petersen \net al. 2008) continue to apply. The sole metatheoretical wrinkle is the one which wediscussed above,involving \ncomputational irrele\u00advance, whichis orthogonal toprogramlogic rules. Intherestof thissection, wewillintroducetheYnotprogram\u00adming \nenvironment more concretely, via several examples ofveri.ed data structureimplementations.  2.2 Verifying \nanImplementationofImperativeStacks Figure 2 shows the signature of a Ynot implementation of the stack \nADT. The signature is expressed in Coq s ML-like module system. Each implementation contains a type family \nt, where, for any type T, a value of t(T) represents a stack storing elements of T. The rep component \nof the interface relates an imperative stack s to a functional list ls in a particular state. Thus, rep \ns ls is a predicate on heaps (hprop) which can be read as s represents the list ls in the current state. \nJust as abstraction over thetypefamily t allows animplementation to choosedifferentdata structures to \nencode the stack, abstraction over the assertion rep allows animplementation to choosedifferentinvariants \nconnecting the concrete representation to anidealized model. In Section 2.1, we gave a grammar for our \nspeci.cation lan\u00adguage. In contrast to most work on separation logic, our real im\u00adplementationhas no \nsuchspeci.cationlanguage.Rather, wede.ne the type hprop as heap -> Prop, so that speci.cations and in\u00advariants \nare arbitrary predicates over heaps. In Figure 2, we see notations involving emp, asserting that the \nheap is empty; [...], for injecting pure propositions; *, for the standard separating con\u00adjunction;and \nExists,for standard typed existentialquanti.cation.  Not shown in this .gure is the binary points-to \noperator -->. The relative parsing precedences of the operators place --> high\u00adest,followedby * and Exists.We \nonly need to usefunny symbols for syntax like Exists x :@ T, P (meaning there exists x of type T such \nthat P ) to avoid confusing the LL(1)parser that is at the heart of Coq s syntax extension facilities. \nOur library de.nes hprop-valued functionsimplementing these usual separationlogic connectives, but users \ncan de.ne their own connectives just as easily.For example, hereishow wede.ne Exists: Definition hprop_ex \n(T : Type) (p : T -> hprop) := fun h :heap => exists v: T, p vh. Hereishowweadd asyntaxextension(or \nmacro ) thatletsus write existentialquanti.cationin the way seeninFigure2: Notation \" Exists v :@ T , \np\" := (hprop_ex T (fun v : T => p)). By reading the types of the methods exposed in the STACK sig\u00adnature, \nwe can determine the contract that each method adheres to. The Cmd type family is our parameterized monad \nof compu\u00adtations with separation logic speci.cations; the two arguments to Cmd givepreconditions andpostconditions. \nCmd isde.nedin terms of the more primitive ST parameterized monad, in the same way asin ourpast work(Nanevski \net al.2008)2.Our speci.cations fol\u00adlowthe algebraic approach toproofs aboutdata abstraction(asin Liskov \nandZilles(1975)), where an abstract notion of stateis re\u00adlated to concrete states. Each operation needs \na proof that it pre\u00adserves the relation properly. In Ynot developments, abstract states are manipulated \nby standard,purely-functional Coqprograms, and method speci.cations include explicit calls to these state \ntransfor\u00admation functions. Each post-condition requires that the new con\u00adcrete, imperative state be related \nto the abstract state obtained by transforming theinitial abstract state. The type of the new operation \ntells us that it expects an empty heap oninput, and on output theheap containsjust whatever map\u00adpings \nare needed to satisfythe representationinvariantbetween the function return value and the empty list.The \nfree operation takes a stack s as an argument, and it expects the heap to satisfy rep on s and the empty \nlist. The post state shows that all heap values associated with s arefreed. The speci.cation for push \nsays that it expects any valid stack as input and modi.es the heap so that the same stack that stood \nfor somelistl beforehand now standsfor thelist x:: l, where x is the appropriate function argument. We \nsee an argument ls with type [list T]. The brackets are a notation de.ned by the Ynot library, standing \nfor computational irrelevance. The syntax [T] expands to inhabited T. To review our discussion from Section \n2.1.1,this meansthatthetype-checker shouldenforcethatthe value of ls is not needed to execute the function. \nRather, such values may only be used in stating speci.cations and discharging proof obligations. We use \nCoq s notation scope mechanism to overload bracketsfor writingirrelevant types andliftedpurepropositions. \nFor an assertion P that mentions the irrelevant variable v, the notation v~~ P must be used to unpack \nv explicitly. The type of the unpack operation is such that it may only be applied to assertions and \nmay not be used to allow an irrelevant variable s value to leak into the computational part of aprogram. \nUnpacking hasno logical meaning;itisonly usedtosatisfythetype-checker in the absence of native support \nfor irrelevance. The notation is de.ned by this equation, where we write [v /v] informally to denote \nthe substitution of variable v for variable v in aCoq term. v ~~ P = (exists v , v = inhabits v /\\ P[v \n/v]) 2Thederived monadiscalled STsep inthatpast work. The type of pop showcases how we avoid the disjunctive \ncon\u00adnectives of separation logic. The function returns an optional T value, which will be None when the \nstack is empty and will be Some x when x is at the top of the stack. We use a Coq match expression togive \nadifferentpost-conditionfor each case. We can implement a module satisfying this signature. With the \ntype T as a local variable, we can de.ne the type of nodes of the linked lists that we will use. We use \nthe abstract type ptr of untypedpointersfrom theYnotlibrary. Record node : Set := Node { data : T; \nnext : option ptr }. Tode.nethe representationinvariant, we wanta recursivefunc\u00adtion specifying what \nit means for a possibly-null pointer to repre\u00adsent a functional list. Our code contains a struct annotation \nthat gives a termination argumentfor thefunction. Fixpoint listRep (ls : list T) (hd : option ptr) {struct \nls} : hprop := match ls with | nil => [hd = None] | h :: t => match hd with | None => [False] | \nSome hd => Exists p :@ option ptr, hd --> Node hp* listRep tp end end. We can represent stacks as \nuntyped pointers to the heads of linkedlistsbuiltfrom Nodes. Definition stack := ptr. We achieve type \nsafety through the representationinvariant. Definition rep (s : stack) (ls : list T) : hprop := Exists \npo :@ option ptr, s --> po * listRep ls po. Before we start implementing the ADT methods, we should \nset up some proof automation machinery. Systems like Small\u00adfoot (Berdine et al. 2005) have hardcoded \nsupport for particular heappredicateslike acycliclinkedlist-ness, cycliclinkedlist-ness, and so on. These \nsystemsperform simpli.cations onformulas that mention the predicates that they understand. In Ynot, on \nthe other hand, the programmer can de.ne his own new predicates, as we havejustdone.Not only that,buthe \ncan alsoprovelemmasthat correspond to the simpli.cation rules built into automated tools, andhe canplughislemmasinto \nageneral separationlogic solver. All of this is done with no risk that a mistake by the programmer willlead \nto afaulty veri.cation; everylemma mustbeprovedfrom .rstprinciples. In a realproof, ofcourse, thehumanproof \narchitect onlylearns which automation will be effective in the course of verifying his program. Ynot \nsupports this kind of incremental automation very well, as we hope to demonstrate in the rest of the \nsection, using sampleinteractiveCoq sessions.Due to space constraints, we must skip some steps and go \nstraight to the right answers, but we have tried toincludeenoughiterationtogivea .avorforYnotdevelop\u00adment. \nAs we progress through the methods, we will be improving a custom tactic, or proof procedure, that we \nwill design speci.cally for this data structure, and we will call that tactic tac. We begin with a version \nof tac thatdelegates all work tothe separationlogic simpli.er sep thatisincluded withYnot.  Ltac tac \n:= sep fail auto. We will explain each of the twoparameters to sep aswe .nd a useforit.Weimplement each \nstack methodby statingits type as a proofsearchgoal, using tacticsto realize thegoal stepby step.The \n.rst method to implement is new, and we do so using the syntax New for the new(\u00b7) operationfromFigure1. \nDefinition new : Cmd emp (fun s : stack => rep s nil). refine {{New None}}; tac. A simple two-step proof \nscript should suf.ce. We .rst use the refine tactic to provide a template for the implementation. The \ntemplate mayhaveholesinit, and eachholeis added as a subgoal. We chain ourtac tactic withthe semicolon \noperator, so that tac is applied to each subgoalgeneratedfrom ahole. Here,we see noproofholestobe .lledin,butsome \nare nonethe\u00adless there, hidden by the notation {{...}}, which we de.ne in a Coq source .leinourlibrary,usingCoq \nssyntaxextensionmech\u00adanism: Notation \"{{ st }}\" := (SepWeaken _ (SepStrengthen _ st _) _). This rule \nrequests that every use of thedouble braces be expanded usingthetemplate onthe secondline,leavingfourholestobe \n.lled. The SepWeaken and SepStrengthen functions are for weaken\u00ading post-conditions and strengthening \npre-conditions, and the four holes,inorder,aretobe .lledby anewpost-condition, anewpre\u00adcondition, a proof \nthat the new pre-condition implies the old, and a proof that the old post-condition implies the new. \nIn the case of the new method, the new speci.cations aredeterminedby standard type inference, while the \ntwo proofs must be added as new goals. With the proof script we have used so far, one proof goal remains \nin thede.nition of new andis shown to the user: v --> None ==> rep v nil The syntax ==> isforimplicationbetweenheap \nassertions, and ithaslowerparsingprecedence than any of the other operators that we use. We see that \nit is important to unfold the de.nition of the representation predicate, so we modify our tactic de.nition, \nand now theproof completes automatically. Ltac tac := unfold rep; sep fail auto. The de.nitions of free \nand push are not much more compli\u00adcated. We use some new notations, including a Haskell-inspired monadic \nbind syntax, and all are de.ned in our library with Coq macros, asin the example ofdouble braces above. \nDefinition free (s : stack) : Cmd (rep s nil) (fun _ : unit => emp). refine (fun s => {{Free s}}); tac. \nQed. Definition push (s : stack) (x : T) (ls : [list T]) : Cmd (ls ~~ rep s ls) (fun _:unit => ls \n~~ rep s(x :: ls)). refine (fun s x ls => hd <-!s; nd <-New (Node x hd); {{s ::= Some nd}} ); tac. \nQed. The implementation of pop uses another syntax extension, whichprovides an IfNull expressionform.The \noption-typed ar\u00adgument to IfNull is checked for nullness(i.e., equality to None). In an Else branch, \nwhere thepointerisknown tobe non-null, that fact is added as a usable proof hypothesis, and the variable \nbeing tested is rebound with a non-option type. We use ;; instead of ; after imperative commands that \ndo not bind variables, because attemptstodootherwiseconfuseCoq s .nickyLL(1)parser. Definition pop (s \n: stack) (ls : [list T]) : Cmd (ls ~~ rep s ls) (fun xo : option t => ls ~~ match xo with | None => \n[ls = nil] * rep s ls | Some x => Exists ls :@ list T, [ls = x:: ls ] *rep s ls end). refine (fun \ns ls => hd <-!s; IfNull hd Then {{Return None}} Else nd <-!hd; Free hd;; s ::= next nd;; {{Return \n(Some (data nd))}}); tac. Several unproved subgoals are returned, this one among them, containing a \nuni.cation variable ?1960: s --> Some hd0 * listRep x (Some hd0) ==> hd0 --> ?1960 * hd0 --> ?1960 Wecantell \nthat somethinghasprobablygone wrong, sincethe conclusion of the implication contains an unsatis.able \nseparation formulathatmentionsthesamepointertwice.Ourautomated sep\u00adaration simpli.cationisquite aggressive \nand often simpli.es satis\u00ad.ableformulasto unsatis.ableforms,butthe results ofthisprocess tend toprovidehints \nabout whichfacts would havebeen useful.In this case, we see a use of listRep where the pointer is known \nto be non-null. We can prove a lemma that would help simplify such formulas. Theorem listRep_Some : \nforall (ls : list T) (hd : ptr), listRep ls (Some hd) ==> Exists h :@ T, Exists t :@ list T, Exists \np :@ option ptr, [ls = h:: t] * hd --> Node hp* listRep tp. destruct ls; sep fail ltac:(try discriminate). \nQed. Weprovethat afunctionallistrelated toa non-nullpointerde\u00adcomposes in the expected way. All it takes \nis for us to request a case analysis on the variable ls, followed by a call to the sep\u00adaration solver. \nHere we put to use the second parameter to sep, which gives a tactic to try applying throughout proof \nsearch. The discriminate tactic solves goals whose premises include incon\u00adsistent equalities over values \nof datatypes, like nil = x:: ls; and adding try infrontpreventsdiscriminate from signalingan errorif \nno such equality exists. We can modify our tac tactic to take listRep Some into ac\u00adcount. First, wede.ne \nanotherprocedure for simplifying animpli\u00adcation. Ltac simp_prem := simpl_IfNull; simpl_prem ltac:(apply \nlistRep_Some). Our tactic .rst calls a simpli.cation procedure associated with the IfNull syntax extension. \nNext, our procedure calls a tactic simpl prem from the Ynot library, for simplifying premises of implications. \nThe argument to simpl prem gives a procedure to attempt on eachpremise, until nofurtherprogress canbe \nmade. We can rede.ne tac to use simp prem, by passing that new procedure as the .rst argument to sep. \nThat .rst argument is used by sep tosimplify agoalbeforebeginning the mainproof search.  let pop s= \nsepBind (sepStrengthen (sepRead s)) (fun hd -> match hd with | Some v -> sepBind (sepStrengthen (sepRead \nv)) (fun nd -> sepSeq (sepStrengthen (sepFrame (sepFree v))) (sepSeq (sepStrengthen (sepFrame (sepWrite \ns (next nd)))) (sepWeaken (sepStrengthen (sepFrame (sepReturn (Some (data nd)))))))) | None -> sepWeaken \n(sepStrengthen (sepFrame (sepReturn None)))) Figure3. SampleOCamlcode extractedfrom the stack example \nWe also suggest to sep that try discriminate may be useful throughoutproof search. Ltac tac := unfold \nrep; sep simp_prem ltac:(try discriminate). When we rerun the de.nition of pop, we have made progress. \nOnly onegoal remains toprove: emp ==> [x = nil] We see that this goal probably has to do with a case \nwhere we know thatthelistbeingmodeledis nil.We were successful at using simpl prem todealwiththe case \nwhere weknowthelistisnon-nil, and we can continue with that strategybyproving anotherlemma. Theorem listRep_None \n: forall ls : list T, listRep ls None ==> [ls = nil]. destruct ls; sep fail idtac. Qed. Now our veri.cation \nof pop completes, after we modify the de.nition of simp prem: Ltac simp_prem := simpl_IfNull; simpl_prem \nltac:(apply listRep_None || apply listRep_Some). We completetheimplementation ofthe stackADTwith atrivial \nde.nition ofthe typefamily t, relying on the representationinvari\u00adant to ensureproper use. Definition \nt (_ : Set) := stack. For our modest efforts, we can now extract an executable OCaml version of our \nmodule. Figure 3 shows part of the result of running Coq s automatic extraction command on our Stack \nmodule. In the implementation of pop, we see invocations of functions whose names begin with sep. These \ncome from the Ynot library, and we must provide their OCaml implementations. Any Ynot program that returns \na type T may be represented in unit -> T in OCaml, regardless of the speci.cation appearing in the original \nCoq type. This makes it easy to implement the basic functions, in the spirit of how the Haskell IO monad \nis implemented. We see callstoexplicit weakening,strengthening, andframing rulesinthe extracted code.InOCaml,these \ncanbeimplemented as no-ops and erasedby an optimizer. Notice that all speci.cation variables andproofs \nare eliminated automaticallyby theCoq extractor. With the erasure of weakening and related operations, \nwe arrive at exactly the kind of monadic code that is standard fare for Haskell, such that the compilation \ntechniques developed for Haskell can be put to immediate use in creating an ef.cient compilationpipelineforYnot. \nIt is also worth pointing out that the sort of tactic construction effortdemonstratedhereisgenerallyperdata \nstructure, notperpro\u00adgram. We can verify a wide variety of other list-manipulatingpro\u00adgrams using the \nsame tac tactic that we developed here. Usually, the tactic work for a new data structure centers on \nidentifying the kind of unfoldinglemmas that weproved above.  2.3 VerifyingImperativeQueues It is not \nmuch harder to implement and verify a queue structure. We de.ne an alternate list representation, parameterized \nby head and tailpointers. Fixpoint listRep (ls : list T) (hd tl : ptr) {struct ls} : hprop := match \nls with | nil => [hd = tl] | h :: t => Exists p :@ ptr, hd --> Node h (Some p) * listRep t p tl end. \n Record queue : Set := Queue { front : ptr; back : ptr }. Definition rep (ls : list T) (fr ba : option \nptr) := match fr, ba with | None, None => [ls = nil] | Some fr, Some ba => Exists ls :@ list T, Exists \nx :@ T, [ls = ls ++ x :: nil] * listRep ls fr ba * ba --> Node x None | _, _ => [False] end. Definition \nrep (q : queue) (ls : list T) := Exists fr :@ option ptr, Exists ba :@ option ptr, front q --> fr * back \nq--> ba *rep ls fr ba. For this representation, we prove similar unfolding lemmas to those weprovedfor \nstacks, with comparable effort.We also need a newlemmafor unfolding aqueuefrom theback. Lemma rep _back \n: forall (ls : list T) (fr ba : ptr), rep ls (Some fr) ba ==> Exists nd :@ node, fr --> nd * Exists \nls :@ list T, [ls = data nd :: ls ] * match next nd with | None => [ls = nil] | Some fr => rep ls (Some \nfr ) ba end. The proof of the lemma relies on some lemmas about pure functionallists.Withthose available, \nweproverep back in under 20 lines. When we plug this and the two other unfolding lemmas into the sep \nprocedure, we arrive atquite a robustproofprocedure for separation assertions about lists that may be \nmodi.ed at either end. Again, in our .nal queue implementation, every proof obliga\u00adtion is proved by \na tac tactic built from sep. We write under 10 lines of new tactic hints to be applied during proof search, \nand we must prove one key lemma by induction. We discover the impor\u00adtance of this lemma while trying \nto verify an implementation of enqueueing.  Definition enqueue : forall (q : queue) (x : T) (ls : [list \nT]), Cmd (ls ~~ rep q ls) (fun _ :unit => ls ~~ rep q (ls ++ x :: nil)). refine (fun q x ls => ba \n<-!back q; nd <-New (Node x None); back q ::= Some nd;; IfNull ba Then {{front q ::= Some nd}} Else \n ban <-!ba; ba ::= Node (data ban) (Some nd);; {{Return tt}}); tac. Coq returns a single unprovedgoal: \nlistRep v2 v4 p * p --> Node v3 (Some nd) ==> listRep (v2 ++ v3 :: nil) v4 nd Considering this goal, \nwe see that the problem is that it can onlybeprovedby induction. Ingeneral, we mustbe explicit about \ninduction everywhere we need it, so we need to prove a lemma about this case. The lemma itself is quite \neasy to automate, when we add one hint from the Ynot library about the commutativity of separating conjunction. \nLemma push_listRep : forall (ba : ptr) (x : T) (nd : ptr) (ls : list T) (fr : ptr), ba --> Node x (Some \nnd) * listRep ls fr ba ==> listRep (ls ++ x :: nil) fr nd. Hint Resolve himp_comm_prem. induction \nls; tac. Qed. To get the original veri.cation to go through, we only need to addthislemmatothehintdatabase, \nusing abuilt-inCoq command. Hint Immediate push_listRep.  2.4 Loops Like with many semi-automated veri.cation \nsystems, we require annotations that are equivalent toloop invariants.SinceCoq spro\u00adgramming language \nis functional, it is more natural to write loops as recursivefunctions, and theloopinvariantsbecome thepre-and \npost-conditions ofthesefunctions. Wesupportgeneral recursionwith aprimitive .xpoint operator in thebaseprogramlogic, \nand itis easy tobuild a separation logic version on top of that. We can also build multiple-argument \nrecur\u00adsive and mutually-recursive function forms on top of the single\u00adargumentform, without needing tointroduce \nnewprimitive combi\u00adnators. An exampleis agetElements function,de.nedinterms ofthe list invariant that \nwe wrote for the stack example. This operation returns the functional equivalent of an imperative list. \nThe task is not sotrivial asit maylook at .rst,becausethecomputationalirrel\u00adevance of thefunction s second \nargumentprohibitsits use toin.u\u00adence the return value. This means that we are not allowed to name theirrelevant \nargument as onethatdecreases on each recursive call, which prevents us from using Coq s native recursive \nfunction def\u00adinitions, where every function must be proved to terminate using simple syntactic criteria. \nNonetheless, the de.nition is easy using thegeneral recursion combinators supported byYnot. Definition \ngetElements (hd : option ptr) (ls : [list A]) : Module Type MEMO. Parameter T : Set. Parameter t : \nforall (T : T -> Set), hprop -> (forall x, T x -> Prop) -> Set. Parameter rep : forall (T : T -> \nSet) (inv : hprop) (fpost : forall x, T x -> Prop), t inv fpost -> hprop. Parameter create : forall \n(T : T -> Set) (inv : hprop) (fpost : forall x, T x -> Prop), (forall x, Cmd inv (fun y :T x=> [fpost \n_y] *inv)) -> Cmd emp (fun m : t inv fpost => rep m). Parameter funcOf : forall (T : T -> Set) (inv \n: hprop) (fpost : forall x, T x -> Prop) (m : t inv fpost), forall (x : T), Cmd (rep m * inv) (fun \ny :T x=> rep m* [fpost _ y] *inv). End MEMO. Figure4. Signature of a memoization module Cmd (ls ~~ listRep \nls hd) (fun res : list A => ls ~~ [res = ls] * listRep ls hd). refine (Fix2 (fun hd ls => ls ~~ listRep \nls hd) (fun hd ls res => ls ~~ [res = ls] * listRep ls hd) (fun self hd ls => IfNull hd Then {{Return \nnil}} Else fn <-!hd; rest <-self (next fn) (ls ~~~ tail ls) <@> _; {{Return (data fn :: rest)}})); \ntac. Qed. Thecodedemonstratesauseofoneofthederived.xpoint com\u00adbinators, Fix2. Of the three arguments \nthat we pass, the .rst two givethepre-conditionandpost-conditionintermsofthetwo real arguments(and,for \nthepost-condition, the return value). The third argument is the function body. It takes a recursive self-reference \nasits.rst argument,followedby thetwo real arguments.Native Coq recursive function de.nitions must often \ninclude annotations explaining why they terminate, but Ynot deals only with partial correctness, so no \nsuch annotations are required for our .xpoint combinators. The notation x ~~~ e is for building a new \ncomputationally\u00adirrelevantvalue out of an old one.The notation e <@> P is explicit invocation of the \nframe rule. With the current system, one usually wants to invoke that rule at each function call. The \nframing asser\u00adtion canbe written as an underscore to ask thatitbeinferred.  2.5 ADependently-TypedMemoizingFunction \nAsfar as wehavebeen abletodetermine, allprevious toolsfordata structure veri.cation lack either aggressive \nautomation or support for higher-order features. The original Ynot supported easy inte\u00adgration ofhigher-orderfunctions \nanddependent types,but the very manual proof style became even more onerous for such uses. Our reimplementedYnot \nmaintains the original shigher-orderfeatures, and ourproof automationintegrates very naturally with them.This \nis ade.ning advantage of our newframework over all alternatives.  For instance, it is easy to de.ne \na module supporting memo\u00adization ofimperative functions. Figure4gives the signature of our implementation, \nwhich is actually an ML-style functor that pro\u00adduces implementations of this signature when passed appropriate \ninput modules. The type T is thedomain of memoizable functions, and typeslike t inv fpost standfor memo \ntables.The argument inv is an assertion giving an invariant that the memoized function maintains, and \nthe pure assertion fpost gives a relation between inputs and outputs of the function. The rep predicate \ncaptures the heap invariants associated with a memo table. The create func\u00adtion produces a memo table \nwhen passed an imperative function with theproper speci.cation.Finally,the funcOf function maps a memo \ntable to afunction that consults the table to avoid recompu\u00adtation. We can implement a MEMO functor in \n50 lines when we use a memo table that only caches the most recent input-output pair. Like in the previous \nexamples, we build a specialized automation procedure with a one-line instantiation of library tactics. \nWe give a 7-line de.nition of rep, give one one-liner proof of a lemma to use in proof search, and include \ntwo lines of annotations within the de.nition of funcOf. All of the rest of the development is no longer \nor more complicatedthaninML.ComparedtoML, wehave thegreatbene.t of using types to control thebehavior \noffunctions to be memoized. A function could easily thwart an ML memoizer byproducing unexpected computational \neffects.  3. TacticSupport The examples from the last two sections show how much of the gory details \nofproofs can be hidden fromprogrammers. In actual\u00adity, everycommand triggersthe addition of one or moreproof \nobli\u00adgations that cannot be discharged effectively by any of the built-in Coqautomation tactics.Not onlyisithardtoprove \nthe obligations, butitis alsohard toinfer the rightintermediate speci.cations.Our separationlogicformulas \nrange well outsidethepropositionalfrag\u00adment that automated tools tend to handle; speci.cation inference \nandproving mustdeal withhigher-orderfeatures. Here is an example of the proof obligations generated for \nthe code wegave earlierfor the stack push method.Numberspre.xed withquestion marks are uni.cation variables, \nwhose valuesthe sep tactic mustinfer. ls ~~ rep sls ==> Exists v :@ option ptr, s --> v * ?200 v forall \nv : option ptr, s --> v * ?200 v ==> ?192 v ?192 hd ==> ?217 * emp forall v : ptr, ?217 * v --> Node \nx hd ==> ?206 v ?206 nd ==> ?234 * (Exists v :@ ?231, s --> v ) ?234 * s--> Some nd ==> ls ~~ rep s \n(x :: ls) We can see that eachgoal, compared to theprevious goals, has at most one new uni.cation variable \nstandingfor a speci.cation; of the two new variables appearing in the second lastline, one stands for \na type, whichwillbe easy toinferby standard uni.cation, once the values of prior variables are known. \nAlso, each new speci.\u00adcation variable has its value determined by the value of the new variable from \nthe previous goal. This is no accident; we designed our combinators and notations tohave thisproperty. \nThe effective range of speci.cations is too large to be solvable byanyparticular magicbullet tactic.Nonetheless,wehavefound \nthat, in practice, a speci.c parameterized proof strategy can dis\u00adcharge most obligations. In contrast \nto the situation with classical veri.cationtoolsthat arebackedby automated.rst-ordertheorem\u00adprovers, \nwhen any proof strategy fails in Coq, the user can always program his own new strategy or even move to \nmostly-manual proof.However,our experience suggeststo usthat mostgoals about data structures can be solved \nby the procedure that we present in this section. That procedure is implemented as the sep tactic that \nwe used in our examples. We do not have space to include the literal Coq code implementing it; we will \noutline the basicprocedure instead. The implementation is in Coq s Ltac language (Delahaye 2000), a domain-speci.c, \ndynamically-typed language for writing proof\u00adgeneratingproofsearchprocedures.Alloftheproof scripts wehave \nseen so far are really Ltac programs. The full language includes recursivefunctionde.nitions, which,along \nwithpattern-matching on proof goals, makes it possible to code a wide variety of proof manipulationprocedures. \nAs our examples have illustrated, sep takes two arguments, which we willcall unfolder and solver.Thetask \nof unfolder is to simplifygoalsbefore speci.cationinference, usuallyby unfold\u00adingde.nitions of recursivepredicates,based \nonknown facts about their arguments.The task of solver isto solve allof thegoals that remain aftergeneric \nseparationlogic reasoningis applied. Coqcomes withthe standard tactic tauto,forprovingproposi\u00adtional \ntautologies.Thereis a moregeneral version of tauto called intuition, which will apply a user-supplied \ntactic to .nish off sub-proofs, while taking responsibility for handling propositional structure on its \nown. The intuition tactic also exhibits the help\u00adful behavior of leaving for the user any subgoals that \nit could not establish. sep is meanttobe an analogue ofintuition for separa\u00adtionlogic.We also wantittohandle \neasyinstantiation of existential quanti.ers, since theyappear so oftenin our speci.cations. We can divide \nthe operation of sep into .ve main phases. We will sketch the workings of eachphase separately. 3.1 SimpleConstraintSolving \nItistrivialtodeterminetheproper valuefor anyuni.cation variable appearing alone on one side of theimplication.Forinstance,given \nthegoal p--> x *q --> y ==> ?123 we simply set ?123 to p--> x *q --> y. Given the slightly more complicatedgoal \np--> x *q --> y ==> ?123 x we abstract over x in the premise to produce fun x => p --> x * q--> y. \n 3.2 IntermediateConstraintSolving When the trivial uni.cation rules are not suf.cient, we need to do \nmore work. We introduce names for all existential quanti.ers and computationally-irrelevant variables \nin the premise. For instance, starting with m~~ Exists v:@ T, p --> v* rep mv ==> ?123 *Exists x:@ T, \np--> x weintroduce names to simplify thepremise,leading to thisgoal: p--> v *rep m v ==> ?123 * Exists \nx :@ T, p --> x Now we run the user s unfolder tactic, which might simplify some use of ade.nition. \nLet us assume that no such simpli.cation occurs for this example. We notice that the points-to fact on \nthe right mentions the same pointer as a fact on the left, so these twofacts may be uni.ed, implying \nx =v .Canceling thisknown information, we areleftwith  rep m v ==> ?123 which is resolvable almost \ntrivially. We cannot give ?123 a value that mentions the variables m and v , since we introduced them \nwith elimination rules within our proof. These variables are not in scope at the point in the original \nprogram where the speci.cation must be inserted. Instead, we remember how each local variable wasintroduced \nand re-quantify at the end,like this: m ~~ Exists v :@ T, rep m v ==> ?123 Now the trivial uni.cationis \nvalid. The crucialpart of thisprocess was the matching of the two points-two facts. We have special\u00adcase \nrulesfor matching conclusion facts underquanti.ers,for con\u00adclusions that match the pre-conditions of \nthe read, write, and free rules.Beyond that,weapply cancellationofidentical termsonthe two sides of the \nimplication, when those terms do not fall under thescopes ofquanti.ers.Thesesimplerulesseemtoservewellin \npractice.  3.3 PremiseSimpli.cation After speci.cation inference, the next step is to simplify the premise \nof the implication. Any emp in the premise may be re\u00admoved, and any lifted pure formula [f] may be removed \nfrom the implication andaddedinstead tothe normalproof context.We also remove existentialquanti.ers andirrelevant \nvariable unpackingsin the same way asin thepreviousphase. 3.4 ConclusionSimpli.cation The main sep loopisfocused \nondealing withpartsof theconclu\u00adsion. We remove occurrences of emp, and we remove any pure formula [f] \nthat the user s solver tactic is able to prove. An ex\u00adistential formula Exists x :@ T, P(x) in the conclusion \nis re\u00adplacedbyP(?456),for afresh uni.cation variable ?456.When no more ofthese rules apply, welookfor \napair of uni.able subformu\u00adlas on the sides of the implication. All such pairs are uni.ed and crossed \nout.This maydetermine the value of a variableintroduced for an existentialquanti.er. Forinstance, say \nwebegin with thisgoal. [m < 17] *p--> m ==> Exists x :@ nat, p--> x *[x <42] Premise simpli.cation would \nmove the initial impure fact into the normalproof context,leaving us with this. p --> m==> Exists x:@ \nnat, p --> x *[x <42] Conclusion simpli.cation would introduce a name for the existentially-bound variable. \np --> m ==> p --> ?789 * [?789 < 42] Next,conclusion simpli.cation would matchthetwo p points-to facts, \nsince theirpointers unify trivially. emp ==> [m < 42] Thisgoal canbe reduced to emp ==> emp by using \nthe normal proof context todeduce thefactinside thebrackets. 3.5 StandardCoqAutomation When sep has \nrun out of rules to apply, the remaining subgoal is subjected to standard Coq automation. Propositional \nstructure and callsto recursivefunctions are simpli.ed wherepossible. sep ends byrunning aloop overthose \nsimpli.cations andthe simpli.cations performedbythe user ssolver tactic,until nofurtherprogress can be \nmade.Finally,sep discharges allgoals oftheformP ==> P,by re.exivity. Everystep ofthe overallprocessisimplementedinLtac, \nsothat only a bug in Coq would allow sep to declare an untrue goal as true,nomatterwhich customizationtheprogrammerprovides.By \nconstruction, every stepbuilds an explicitproof term, which canbe validated afterward with an independent \nchecker that is relatively simple, compared to the operation of all of thedecisionprocedures that mayhave \ncontributed to theproof.  4. Evaluation Wehave usedour environmenttoimplement and verify severaldata \nstructures,including theStack andQueue examplesthat appeared inSection2.We alsofollowthe evaluation ofourpriorYnot \nsystem inimplementing agenericsignatureofimperative .nitemaps.We builtthree verydifferentimplementations:a \ntrivialimplementation based on pointers to heap-allocated functional association lists, an implementation \nbased on binary search trees, and an implementa\u00adtionbased onhash tables.Any of theimplementations canbe \nused interchangeably via ML-style functors, and their shared signature is phrased in terms of dependently-typed \nmaps, where the type of data associatedwith akeyis calculatedfrom an arbitraryCoqfunc\u00adtion over thatkey.Ourlargest \nexample, apackratPEGparser(Ford 2004),usesthese .nitemapstocacheintermediateresults. We also veri.ed \none more exoticdata structure:binomial trees, which aretreestructures with anon-trivial rulefordetermininghow \nmany pointers are stored at each node. This data structure is often applied in implementing priority \nqueues. Our implementation is interesting in its use of a dependently-typed recursive function to characterizefunctional \nmodels of such trees. Finally, we chose representative examples from two competing data structure veri.cation \nsystems,Smallfoot(Berdine et al.2005) and Jahob(Zee et al.2008), and reimplemented those examples in \nour newYnot. Figure5presentscodesizestatisticsforourcasestudies. Pro\u00adgram codeiscodethatispreservedby \nextraction. Specs arethe pre-and post-conditions of every function de.ned in the module. The core of \na Ynot module consists of heap representation rep code(e.g., thede.nitions named rep in our examples), \nalong with proofs (e.g., push listRep) and tactics (e.g., simp prem) deal\u00ading with these representations. \nThe annotations column counts the number oflines ofprogrammer speci.ed annotations(e.g., <@>). The total \noverhead column sums proofs, tactics, and annotations. We alsopresenttype-checking andproving times(in \nminutes and seconds), as measured on a2.8GHzPentiumD with1GB of mem\u00adory.Sofar, wehave not optimized ourtacticsfor \nrunningtime;they are executedbydirectinterpretation ofprogramsin adynamically\u00adtypedlanguage. Our previous \nversion of Ynot placed a signi.cant interactive proofburden ontheprogrammer.ThepreviousYnothashtable,for \ninstance, required around320 explicitCoq tacticinvocations.Each tacticinvocation(indicatedby aterminating \n. inCoq) represents a manual intervention by the Ynotprogrammer. Theseinvocations tended to be low-level \nsteps, like choosing which branch of a disjunction to prove. As such, these proofs are brittle in the \nface of minor changes. In some previous Ynot developments, the ratio of manualproof toprogram textis \nover10 to1.For comparison, a large scale compiler certi.cation effort(Leroy2006) has reported aproof-to-code \nratio of roughly6 to1. In contrast, our new hash table requires only about 70 explicit tactic invocations. \nThese invocations tend to be high level steps, like performing induction or invoking the sep tactic. \nWe have   Program Specs Rep Proofs Tactics Annotations Total Overhead Time (m:s) Stack 14 8 14 7 5 \n0 12 0:12 Queue 26 12 22 41 25 0 66 1:36 Ref to Functional Finite Map 8 16 2 2 2 0 4 0:05 Hash Table \n34 21 6 70 38 34 142 0:45 BST Finite Map 31 16 6 22 8 4 34 1:35 Binomial Tree 19 12 13 0 9 7 16 2:33 \nAssociation List 48 34 17 41 51 10 102 3:10 Linked List Segments 84 34 19 91 208 7 306 2:15 Packrat PEGParser \n277 110 15 102 55 5 162 1:20 Figure5. Breakdown of numbers oflines ofdifferentkinds of codein the case \nstudies observed that such tactic-based proofs are signi.cantly easier to maintain. We also made rough \ncomparisons against two veri.cation sys\u00adtems that do not support reasoning about .rst-class functions. \nThe Jahob(Zee et al.2008) system allows the speci.cation and veri\u00ad.cation of recursive, linked data structures \nin a fragment of Java. We implemented an association list data structure that is included as an example \nin the Jahob distribution. Code-size-wise, the two implementations are quite similar. For instance, they \nboth require around twentylinesofheap representationcode,and theyboth re\u00adquire aboutadozenlines of codefor \nthelookupfunction sloopin\u00advariant.OurYnotimplementation uses explicitframing conditions inplaces whereJahobdoes \nnot,butwe speculate that we canprob\u00adably remove these annotations with additional, custom automation. \nOursecond comparisonisagainsttheSmallfoot(Berdineetal. 2005) system, which does completely automated \nveri.cation of memory safety via separation logic. We implemented Ynot ver\u00adsions of 10 linked list segment \nfunctions included with the Small\u00adfootdistribution.In eachcase,theYnot andSmallfoot versionsdif\u00adferedby \nno more than afewlines of annotationburden.  5. RelatedWork Considering the two automated systems that \nwe just mentioned, Smallfoot uses a very limited propositional logic, and Jahob uses an undecidablehigher-orderlogic.Manyinterestingprogram \nspec\u00adi.cations cannot be written in Smallfoot s logic and cannot be proved to hold by Jahob s automated \nprover. Neither of these sys\u00adtems supportshigher-orderprograms, and neither supports custom\u00adprogrammed \nproof procedures, for cases where standard automa\u00adtionisinsuf.cient. TheESC/Java(Flanagan et al.2002) \nandSpec#(Barnett et al. 2004) systems tackle some related problems within the classical veri.cationframework.These \nsystemshave strictlyless supportfor modelingdata structures thanJahob has, so thatitisimpractical to \nuse them toperformfull veri.cations of manydata structures. A number of systems have been proposed recently \nto support dependently-typedprogrammingin a settingoriented moretowards traditional softwaredevelopmentthanCoqis.Agda(Norell2007) \nand Epigram (McBride and McKinna 2004) are designed to in\u00adcrease the convenience of programming in type \ntheory over what Coq provides, but, out of the box, these systems support neither imperativeprogramming \nnor customproof automation.ATS(Chen and Xi 2005) includes novel means for dealing with imperative state, \nbut it includes no proof automation beyond decision proce\u00addures for simple base theories like linear \narithmetic. This makes it much harder to write veri.ed data structure implementations than inYnot.Concoqtion(Pasalic \netal.2007) allows the use ofCoqfor reasoning about segments ofgeneralOCamlprograms.Whilethose programs \nmay use imperativity, the Coq reasoning is restricted to pureindex terms.Sage(Gronski et al. 2006) supports \nhybrid type\u00adchecking, where typing invariants may be speci.ed with boolean\u00advalued program functions and \nchecked at runtime. This approach generallydoes notenablefull static correctness veri.cation. Partly \nas a way to support imperativeprogramming in type the\u00adory,SwierstraandAltenkirch(2007) have studiedpurefunctional \nsemantics for effectful programming language features, with em\u00adbeddingsinHaskell andAgda. Chargu\u00b4eraud \nandPottier(2008) have demonstrated a translation from a calculus of capabilities to apurefunctionallanguage.In \neach case, the authors statedplans to do traditional interactive veri.cation on the pure functional mod\u00adels \nthat they generate. Since such veri.cation is generally done in logicswithoutgeneral recursion,thesetranslations \ncannotbeused to verify general recursive programs without introducing an extra syntacticlayer,in contrast \ntoYnot.Each other approach alsointro\u00adduces restrictions on the shape of the heap, such as the absence \nof stored impure functions in the case of Swierstra and Altenkirch s work. Other computer proof assistants \nare based around pure func\u00adtionalprogramminglanguages, withopportunitiesfor encoding and verifyingimperativeprograms.Nonetheless, \nwe seethe elegance of our approach as depending on the con.uence of a number of fea\u00adtures notfoundin \nother matureproof assistants.ACL2(Kaufmann and Moore 1997) does not support higher-order logic or higher\u00adorderfunctionalprogramming. \nBulwahn et al.(2008) describe a systemfor encoding and verifyingimpure monadicprogramsinIs\u00adabelle/HOL. \nTheir implementation does not support storing func\u00adtions in the heap. They suggest several avenues for \nloosening this restriction, and the approaches that supportheap storage ofimpure functionsinvolve restrictingattentiontofunctionsthatareconstruc\u00adtive \nor continuous(propertiesthathold of allCoqfunctions), neces\u00adsitating some extraproofburden or syntactic \nencoding. Thereisclosely related workinthe .eld of shapeanalysis.The TVLA system(Sagivetal.2002) modelsheap \nshapeswith a .rst\u00adorder logic with a built-in transitive closure operation. With the right choices of \npredicates that may appear in inferred speci.ca\u00adtions, TVLA is able to verify automatically many programs \nthat involve both heap shape reasoning and reasoning in particular de\u00adcidable theories such as arithmetic. \nTheXisa system(ChangandRival2008) uses an approach sim\u00adilarto ours, asXisaisbasedon user speci.cation \nofinductive char\u00adacterizations of shape invariants. Xisa builds this inductive de.ni\u00adtion mechanism into \nits framework, while we inherit a more gen\u00aderal mechanism from Coq. Xisa is based on hardcoded algorithms \nfor analyzing inductive de.nitions and determining when and how they should be unfolded. Such heuristics \nlack theoretical guaran\u00adtees abouthowbroadly they apply.In thedesign of our system, we recognize this \nbarrier and allow users to extend the generic solver with custom rulesfordealing with custominductivepredicates. \nIn comparing the new Ynot environment to the above systems and all others that we are aware of, there \nare a number of com\u00admon advantages. No other system supports both highly-automated proofs based on separation \nlogic (when they work) and highly human-guidedproofs(whenthey are needed),let alone combina\u00adtions of \nthe two. None of the systems with signi.cant automation support the combination of imperative and higher-order \nfeatures, like we handle in the example of our higher-order memoizer and iterators.Wealso .nd noautomated \nsystemsthatdeal withdepen\u00addenttypesinprograms.The .rstof theseadvantagesseemscritical in the veri.cation \nof imperative programs that would be dif.cult to prove correct even if refactored to be purely functional. \nFor in\u00adstance,it seemsplausiblethat our environment couldbe used even\u00adtually to build a veri.ed compiler \nthat uses imperative data struc\u00adtures for ef.cient data.ow analysis, uni.cation in type inference, and \nso on. None of the purely-automated tools that we have sur\u00adveyed could be applied to that purpose without \ndrastic redesign. We are not aware of any previous toolkit for manual proof about imperative programs \nin proof assistants that would make the task manageable; the manual reasoning about state would overwhelm \ntheinterestingparts of compiler veri.cation.  6. Conclusions&#38;FutureWork The latest Ynot source \ndistribution, including examples, can be downloaded from theproject web site: http://ynot.cs.harvard.edu/ \n Concurrency is a big area for future work on Ynot. Systems likeSmallfoot(Berdine et al.2005)do automated \nseparation-logic reasoning about memory safety of concurrentprograms.We would like to extend that work \nto full correctness veri.cation, by design\u00ading a monadic version of concurrent separation logic that \n.ts well withinCoq. ThefullpotentialoftheYnot approach alsodepends on explicit handling of other computational \neffects, such as exceptions and input-output. Ourpriorprototype handled theformer, and ongoing work considers \nsupporting thelatter. As with any project in automated theorem proving, there is al\u00adways roomforimprovementsto \nautomation andinference.Afuture version of Ynot could bene.t greatly in usability by incorporating abstract \ninterpretation to infer speci.cations, as several automated separationlogic tools alreadydo. Nonetheless, \nour current system already .lls a crucial niche in the space of veri.cation tools. We have presented \nthe .rst tool that performs well empirically in allowing mixes of manual and highly-automated reasoning \nabout heap-allocated data structures, aswell asthe .rsttool toprovideaggressiveautomationinproofs of \nhigher-order, imperative programs. We hope that this will form a signi.cant step towards full functional \nveri.cation of imperative programs withdeep correctness theorems.  References Mike Barnett, K. Rustan \nM. Leino, and Wolfram Schulte. The Spec# programming system: An overview. In Proc. CASSIS, 2004. BrunoBarrasandBrunoBernardo. \nTheImplicitCalculusofCon\u00ad structions as aprogramming language withdependent types. In Proc. FoSSaCS,2008. \nJosh Berdine, Cristiano Calcagno, and Peter W. O Hearn. Small\u00ad foot: Modular automatic assertion checking \nwith separation logic. In Proc. FMCO,2005. Yves Bertot and Pierre Cast\u00b4eran. Interactive Theorem Proving \nand Program Development. Coq Art: The Calculus of Inductive Constructions. TextsinTheoreticalComputerScience.Springer \nVerlag,2004. Lukas Bulwahn, Alexander Krauss, Florian Haftmann, Levent Erk\u00a8ok, andJohnMatthews. Imperativefunctionalprogramming \nwithIsabelle/HOL. In Proc. TPHOLs,2008. Bor-YuhEvanChang andXavierRival. Relationalinductive shape analysis. \nIn Proc. POPL,2008. ArthurChargu\u00b4eraud andFranc\u00b8oisPottier. Functional translation of a calculus of capabilities. \nIn Proc. ICFP,2008. Chiyan Chen and Hongwei Xi. Combining programming with theoremproving. In Proc. ICFP,2005. \nDavid Delahaye. A tactic language for the system Coq. In Proc. LPAR,2000. Cormac Flanagan, K. Rustan \nM. Leino, Mark Lillibridge, Greg Nelson, James B. Saxe, and Raymie Stata. Extended static checkingforJava. \nIn Proc. PLDI,2002. Bryan Ford. Parsing expression grammars: A recognition-based syntacticfoundation. \nIn Proc. POPL,2004. Jessica Gronski, Kenneth Knowles, Aaron Tomb, Stephen N. Fre\u00adund, and Cormac Flanagan. \nSage: Hybrid checking for .exible speci.cations. In Proc. Scheme Workshop, 2006. Matt Kaufmann and J. \nS. Moore. An industrial strength theorem prover for a logic based on Common Lisp. IEEE Trans. Softw. \nEng.,23(4),1997. Xavier Leroy. Formal certi.cation of a compiler back-end or: programming a compiler \nwith aproof assistant. In Proc. POPL, 2006. BarbaraLiskov andStephenN.Zilles. Speci.cationtechniquesfor \ndata abstractions. IEEE Trans. Software Eng.,1(1):7 19, 1975. Conor McBride and James McKinna. The view \nfrom the left. J. Functional Programming, 14(1):69 111, 2004. Aleksandar Nanevski, Greg Morrisett, and \nLars Birkedal. Poly\u00admorphism and separation in Hoare Type Theory. Proc. ICFP, 2006. AleksandarNanevski,GregMorrisett,AvrahamShinnar,PaulGov\u00adereau, \nand Lars Birkedal. Ynot: Reasoning with the awkward squad. In Proc. ICFP,2008. Ulf Norell. Towards a \npractical programming language based on dependent type theory. PhD thesis, Chalmers University of Technology, \n2007. EmirPasalic,Jeremy Siek,WalidTaha,andSethFogarty. Conco\u00adqtion:Indexed types now! In Proc. PEPM,2007. \nRasmusL.Petersen,LarsBirkedal,AleksandarNanevski, andGreg Morrisett. A realizability model for impredicative \nHoare Type Theory. In Proc. ESOP,2008. John C. Reynolds. Separation logic: A logic for shared mutable \ndata structures. In Proc. LICS,2002. Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. Parametric shape \nanalysis via3-valuedlogic. ACM TOPLAS,24,2002. WouterSwierstra and Thorsten Altenkirch. Beauty in thebeast:A \nfunctional semantics for the awkward squad. In Proc. Haskell Workshop,2007. Karen Zee, Viktor Kuncak, \nand Martin Rinard. Full functional veri.cation oflinkeddata structures. In Proc. PLDI,2008.  \n\t\t\t", "proc_id": "1596550", "abstract": "<p>We present a new approach for constructing and verifying higher-order, imperative programs using the Coq proof assistant. We build on the past work on the Ynot system, which is based on Hoare Type Theory. That original system was a proof of concept, where every program verification was accomplished via laborious manual proofs, with much code devoted to uninteresting low-level details. In this paper, we present a re-implementation of Ynot which makes it possible to implement fully-verified, higher-order imperative programs with reasonable proof burden. At the same time, our new system is implemented entirely in Coq source files, showcasing the versatility of that proof assistant as a platform for research on language design and verification. Both versions of the system have been evaluated with case studies in the verification of imperative data structures, such as hash tables with higher-order iterators. The verification burden in our new system is reduced by at least an order of magnitude compared to the old system, by replacing manual proof with automation. The core of the automation is a simplification procedure for implications in higher-order separation logic, with hooks that allow programmers to add domain-specific simplification rules.</p> <p>We argue for the effectiveness of our infrastructure by verifying a number of data structures and a packrat parser, and we compare to similar efforts within other projects. Compared to competing approaches to data structure verification, our system includes much less code that must be trusted; namely, about a hundred lines of Coq code defining a program logic. All of our theorems and decision procedures have or build machine-checkable correctness proofs from first principles, removing opportunities for tool bugs to create faulty verifications.</p>", "authors": [{"name": "Adam Chlipala", "author_profile_id": "81100341086", "affiliation": "Harvard University, Cambridge, MA, USA", "person_id": "P1613992", "email_address": "", "orcid_id": ""}, {"name": "Gregory Malecha", "author_profile_id": "81342503370", "affiliation": "Harvard University, Cambridge, MA, USA", "person_id": "P1613993", "email_address": "", "orcid_id": ""}, {"name": "Greg Morrisett", "author_profile_id": "81339518683", "affiliation": "Harvard University, Cambridge, MA, USA", "person_id": "P1613994", "email_address": "", "orcid_id": ""}, {"name": "Avraham Shinnar", "author_profile_id": "81314491648", "affiliation": "Harvard University, Cambridge, MA, USA", "person_id": "P1613995", "email_address": "", "orcid_id": ""}, {"name": "Ryan Wisnesky", "author_profile_id": "81435603377", "affiliation": "Harvard University, Cambridge, MA, USA", "person_id": "P1613996", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596565", "year": "2009", "article_id": "1596565", "conference": "ICFP", "title": "Effective interactive proofs for higher-order imperative programs", "url": "http://dl.acm.org/citation.cfm?id=1596565"}