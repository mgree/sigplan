{"article_publication_date": "08-31-2009", "fulltext": "\n Experience Report: Ocsigen, a Web Programming Framework Vincent Balat J\u00b4ome Vouillon er Boris Yakobowski \nLaboratoire Preuves, Programmes et Syst`emes Universit\u00b4 e Paris Diderot (Paris 7), CNRS Paris, France \n{vincent.balat, jerome.vouillon, boris.yakobowski}@pps.jussieu.fr Abstract The evolution of Web sites \ntowards very dynamic applications makes it necessary to reconsider current Web programming tech\u00adnologies. \nWe believe that Web development would bene.t greatly from more abstract paradigms and that a more semantical \napproach would result in huge gains in expressiveness. In particular, func\u00adtional programming provides \na really elegant solution to some im\u00adportant Web interaction problems, but few frameworks take advan\u00adtage \nof it. The Ocsigen project is an attempt to provide global solutions to these needs. We present our experience \nin designing this general framework for Web programming, written in Objective Caml. It provides a fully \nfeatured Web server and a framework for program\u00adming Web applications, with the aim of improving expressiveness \nand safety. This is done by taking advantage of functional program\u00adming and static typing as much as \npossible. Categories and Subject Descriptors D.1.1 [PROGRAMMING TECHNIQUES]: Applicative (Functional) \nProgramming; H.3.5 [INFORMATION STORAGE AND RETRIEVAL]: Online Informa\u00adtion Services Web-based services \nGeneral Terms Design, Languages, Reliability, Security Keywords Ocsigen, Web, Networking, Programming, \nImplemen\u00adtation, Objective Caml, ML, Services, Typing, Xhtml 1. Introduction In the last few years, the \nWeb has evolved from a data-centric plat\u00adform into a much more dynamic one. We tend now to speak more \nand more of Web application, rather than Web sites, which hints that the interaction between the user \nand the server is becoming much more complex than it used to be. What is striking is that this evolution \nhas not been induced, nor even followed, by a corresponding evolution of the underlying technology. The \nRFC specifying the version of the HTTP protocol currently in use dates back to 1999 and current HTML \nlooks very much like the one we were using ten years ago. The main change is probably the increasing \nuse of JavaScript, mainly due to imple\u00admentation improvements, which made possible the advent of a new \nkind of Web applications. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. Web programming is highly constrained by technology (pro\u00adtocols, standards and browsers \nimplementations). Commonly used Web programming tools remain very close to this technology. We believe \nthat Web development would bene.t a lot from higher level paradigms and that a more semantical approach \nwould result in huge gains in expressiveness. It is now widely known in our community that functional \npro\u00adgramming is a really elegant solution to some important Web in\u00adteraction problems, as it offers a \nsolution to the statelessness of the HTTP protocol (Queinnec 2000; Graham 2001; Hughes 2000). But this \nwisdom has not spread in the Web programming community. Almost no major Web framework is taking advantage \nof it.1 We believe the reason is that functional programming has never been fully exploited and that \none must be very careful about the way it is integrated in a complete framework in order to match precisely \nthe needs of Web developers. The Ocsigen project is trying to .nd global solutions to these needs. In \nthis paper, we present our experience in designing Ocsi\u00adgen, a general framework for Web programming \nin Objective Caml (Leroy et al. 2008). It provides a full featured Web server and a framework for programming \nWeb applications, with the aim of im\u00adproving expressiveness and safety. This is done by taking advantage \nof functional programming and static typing as much as possible (Balat 2006). This paper is a wide and \nquick overview of our experience regarding this implementation. In section 2, we describe our use of \nfunctional programming. In section 3, we show how some very strong correctness properties can be encoded \nusing Ocaml s type system. Finally, in section 4, we describe the implementation of a concrete Web application \nusing our solutions. 2. Functional Programming for the Web The Ocsigen project provides a Web server \nwritten in Objective Caml. This server offers all the features one would expect from a general purpose \nWeb server, starting with a comprehensive support of the HTTP 1.1 protocol (Fielding et al. 1999) (including \nrange requests and pipelining). Data compression, access control and authentication are all supported. \nThe server is con.gured through .exible XML-based con.guration .les. The server is designed in a modular \nway. It can therefore be extended very easily just by writing new modules in Ocaml. Among the modules \ncurrently available are a module for running CGI scripts, a reverse proxy (which makes it easy to use \nOcsigen with another Web server), a .lter to compress contents, etc. In the remainder of this section, \nwe highlight the concurrency model used for the Web server implementation, and then our main ICFP 09, \nAugust 31 September 2, 2009, Edinburgh, Scotland, UK. Copyright &#38;#169; 2009 ACM 978-1-60558-332-7/09/08. \n. . $5.00 1 A notable exception being Seaside (Ducasse et al. 2004).  c  extension to the server, that \nis, Eliom, a framework for writing Web applications in Ocaml. 2.1 Cooperative Threads A Web server is \ninherently a highly concurrent application. It must be able to handle simultaneously a large number of \nrequests. Fur\u00adthermore, composing a page may take some time, for instance when several database queries \nare involved. The server should not to be stalled in the meantime. We have chosen to use cooperative \nmulti\u00adthreading to address this issue. Indeed, cooperative threads make it possible to write multi-threaded \ncode while avoiding most race conditions, as context switches only occur at well-speci.ed points. Between \nthese points, all operations are executed atomically. In particular, it is easy to use safely shared \nmutable datastructures, such as hash tables, without using any lock. We use the Lwt thread library (Vouillon \n2008), which provides a monadic API for threads. With this library, a function creating a Web page asynchronously \nwill typically have type: unit . html Lwt.t. It returns immediately a promise (sometimes also called \nfuture) of type html Lwt.t, that is, a value that acts as a proxy for the value of type html eventually \ncomputed by the function. Promises are a monad. The return operator of the monad has type: a . a Lwt.t. \nIt creates an immediately ful.lled promise. The bind operator has type: a Lwt.t . ( a . b Lwt.t) . b \nLwt.t. It takes as arguments a promise and a function to be applied to the value of the promise when \nit becomes available. The promise returned by the operator gives access to the value eventually com\u00adputed \nby the function. This operator can be used for sequencing asynchronous operations, as well as for synchronization \n(for wait\u00ading for the completion of some operation before performing further operations). In order to \nmake it possible to use third-party non-cooperative libraries, Lwt also allows to detach some computations \nto preemp\u00adtive threads.  2.2 Web Programming Eliom (Balat 2007) is the most innovative part of the project. \nThis Web server extension provides a high-level API for programming dynamic Web sites with Ocaml. Its \ndesign goals are twofold: to propose a new Web programming paradigm based on semantic concepts rather \nthan relying on technical details, and to ensure the quality of Web application by using static typing \nas much as possible (this latter point is detailed in section 3). The main principle on which Eliom is \nbased is the use of .rst\u00adclass values for representing the services provided by the Web server. What \nwe call a service is a proxy for a function which can be called remotely from a browser to generate a \npage or perform an action. Eliom keeps track of the mapping from URLs to services: instead of having \none script or executable associated to each URL, like many traditional Web programming tools, Eliom s \nservices are programmatically associated to URLs. This lets the programmer organize the code in the most \nconvenient way. In particular, it makes it easy to share behaviors between several pages, as the same \nservice can be associated to several URLs. As an example, the following piece of code creates a service \nsrv at URL http://foo/bar (on some server foo). let srv = register_new_service ~path:[\"bar\"] ~get_params:unit \nf The .rst argument (labelled ~path), corresponds to the path in the URL to which the service will be \nbound. The second argument (labelled ~get_params) describes URL parameters (here none, as this service \ndoes not expect any parameter). The function f is used to produce the corresponding page. Inside Eliom, \none can generate an anchor linking to this service by applying the HTML anchor constructor a to the service \nsrv, the current service context sp (which contains in particular the current URL, and is used to construct \nrelative links), the text of the anchor anchor_contents and the unit value () corresponding to the absence \nof parameters. a srv sp anchor contents () Note that the service URL can be changed just by modifying \nthe path at a single location in the source code, and all links will remain correct as they are computed \nautomatically. Several services can share the same URL, for instance when they expect different parameters. \nThis means that a service will not respond if some of its arguments are missing or ill-typed, avoiding \na whole class of hard-to-detect errors.2 More generally, a full range of service kinds is provided, allowing \nto describe precisely how services are attached to URLs. This makes it possible to describe very .exible \nand precise Web interactions in just a few lines of code. A service can be associated to a path (and \npossibly parameters), to the value of a special parameter, or to both or them. The choice of the right \nservice to invoke is performed automatically by Eliom. Services can be dynamically created in response \nto previous interactions with the user. Their behavior may depend for instance on the contents of previous \nforms submitted by the user or the result of previous computations. This is implemented by recording \nthe behavior associated to the service as a function closure in a table on the server. This is an instance \nof continuation-based Web programming (Queinnec 2000; Hughes 2000; Graham 2001), This is known to be \na really clean solution to the so-called back button problem, but is provided by very few Web frameworks. \nIt is also possible to classify services with respect to the type of the value they return. Usually services \nreturn an HTML page, but it is also possible to build services sending for example .les, redirections, \nor even no content at all. The latter are called actions, as they are used to perform an effect on the \nserver (for example a database change). Eliom also provides a kind of action that will redisplay the \npage automatically after having performed the effect. It is also possible to write services that will \nchoose dynamically the kind of output they want. 3. Typing a Web Application 3.1 XML Typing Historically, \nbrowsers have treated HTML errors leniently. As a re\u00adsult, Web pages are often written in loosely standardized \nHTML dialects (so-called tag soups). However, the interpretation of mal\u00adformed markup can vary markedly \nfrom one browser to the next. Ensuring that Web pages follow precisely existing speci.cations makes it \nmore likely that they will be interpreted similarly by all Web browsers. 2 This mainly concerns URLs \nwritten by hand or outdated: as explained in \u00a73.2, Eliom automatically guarantees that links inside pages \nare correct.  Our framework ensures statically that all Web pages served by the server are well-formed \nand valid with respect to W3C recom\u00admendations. Two ways are provided to the developer to this end. The \nfunctor-based API of Eliom makes it possible to support these two choices. The .rst way is to use the \nXHTML module developed by Thorsten Ohl.3 This library provides combinators to write HTML pages. HTML \nelement types are encoded using phantom types (Leijen and Meijer 1999) and polymorphic variants. The \ncovariant abstract type of elements is type a elt. For instance, the combinator p takes as argument a \nlist of elements which are either text or inline elements, optionally some common attributes such as \nclass or id, and returns a paragraph element: val p : ?a:([< common ] attrib list) -> [< inline | PCDATA \n] elt list -> [> P] elt Here is a piece of code that builds a simple page, given a list of elements \nthe_page_contents. html (head (title (pcdata \"Hello world!\")) []) (body (h1 [pcdata \"Hello world\"] :: \nthe_page_contents)) By using a syntax extension based on the Camlp4 preprocessor, HTML fragments can \nbe directly incorporated into an Ocaml source code. The fragments are translated in Ocaml code that relies \non the library above. << <html> <head> <title>Hello world!</title> </head> <body> <h1>Hello world</h1> \n$list:the_page_contents$ </body> </html> >> The second way of writing valid Web pages is to use Ocaml-Duce \n(Frisch 2006), which brings together Ocaml and the CDuce language (Benzaken et al. 2003). The latter \nis speci.cally designed for XML, and allows to manipulate XML documents with very pre\u00adcise (in fact, \nexact) typing. {{ <html> [<head>[<title>\"Hello world!\"] <body>[<h1>\"Hello world\" !{:the_page_contents:}]] \n}} Unlike the XHTML library, which is speci.c to XHTML documents, OcamlDuce can be used to create any \nkind of XML documents, for instance, Atom feeds (Nottingham and Sayre 2005). The only drawback is that \nOcamlDuce is incompatible with Camlp4 at the moment, requiring somewhat complicated compilation schemes \nwhen OcamlDuce .les are mixed with Ocaml .les that use syntax extensions.  3.2 Typing Web Interactions \nEliom s .rst-class notion of service makes it possible to check the validity of links and forms. A service \nis represented as an abstract data structure containing all the information about its kind, its URL, \nits parameters, etc. As we saw in section 2.2, links are built automatically by a function taking as \nparameter a service, rather than a URL. This makes broken links impossible! The types and names of service \nparameters are declared when constructing a service. Here is an example of service with two pa\u00adrameters \nyear and reverseorder, of types int and bool respec\u00adtively. 3 http://physik.uni-wuerzburg.de/~ohl/xhtml/ \n let events_info = register_new_service ~path:[\"events\"] ~get_params:(int \"year\" ** bool \"reverseorder\") \n(fun sp (year, reverseorder) () -> ...) The third argument is the function implementing the service. \nIt takes three parameters: sp corresponds to the current request con\u00adtext (it contains all information \nabout the request, like the IP ad\u00address of the client, its user-agent, etc). The second one is for URL \nparameters (GET) and the third one for the body of the HTTP re\u00adquest (POST parameters, here none). When \na request is received, the actual arguments are automat\u00ad ically type-checked and converted from string \nto the right ML datatype by the server. Note that the type of the function imple\u00ad menting a service depends \non the value of the second parameter: here, it expects a pair of type int * bool. This is not easy to \nimplement in Ocaml. We have considered two solutions to this problem. The .rst one, used before version \n0.4.0 of Ocsigen was to rely on functional unparsing (Danvy 1998). The current solu\u00ad tion consists in \na simulation of generalized algebraic datatypes (GADT) (Xi et al. 2003; Pottier and R\u00b4egis-Gianas 2006) \nimple\u00ad mented using unsafe features of Ocaml, anticipating their future introduction in the language. \nIn the example above, int, bool and ** are the GADT constructor functions, and the strings \"year\" and \n\"reverseorder\" are HTTP parameters names. Parameters are statically checked when building a link with \nparameters. Concretely, the function a, that builds a link, takes as last parameter the arguments to \nbe given to the service. These arguments will be encoded in the URL. Again, the type of this parameter \ndepends on the service. a events_info sp (pcdata \"Last year seminars\") (2008, true) When generating a \nlink, service parameter names are taken from the abstract structure representing the service. This ensures \nthat they are always correct and makes it possible to change them without needing to update all links. \nHere, the generated relative link is: events?year=2008&#38;reverseorder=on Eliom also provides some static \nguarantees that a form corre\u00adsponds to its target service. As with link functions, the function that \ncreates an HTML form takes as parameters the service and the in\u00adformation sp about the request. But instead \nof being directly given the contents of the form, it expects a function that will build the contents \nof the form. This function takes as parameters the names of the different .elds of the form. The following \nexample shows how to create a form to our events_info service: get_form events_info sp make_form Here \nis in an excerpt of the de.nition of the make_form function: let make_form (year_name, reverseorder_name) \n= ... int_input ~input_type: Text ~name:year_name (); bool_checkbox ~name:reverseorder_name (); ... The \nfunctions int_input and bool_checkbox are used to create respectively an input form widget, and a checkbox. \nTo ensure a correct typing of the .elds, we use an abstract parametric type a param_name for names instead \nof simply type string. The parameter of this type is a phantom type corresponding to the type of the \nservice parameter. Each function generating form widgets uses the appropriate type for the name of the \nparameter it corresponds to. For instance, the ~name parameter of the function int_input above has type \nint param_name, whereas it has type bool param_name for the function bool_checkbox. This ensures that \nthe .eld names correspond exactly to those expected by the service, and that their types are correct. \nBut there is no guarantee that all required parameters are present, nor that the same parameter is not \nused several times in the form. Indeed, this would require a very sophisticated type system for forms, \nwhich would also need to interact gracefully with the type system for HTML. Rather than trying to write \nan hazardous and complex extension to Ocaml s type system, we decided to relax somewhat the static checks \nfor forms.  3.3 Typing Database Accesses Database accesses are crucial for Web programming. We have \nfound it very convenient to use PG OCaml4, an interface to Post\u00ad greSQL5 written by Richard Jones. In \nparticular, Ocsimore, our content management system (see section 4), relies on it. We ac\u00ad tually included \nsome changes in PG OCaml to turn its implemen\u00adtation into monadic style, in order to make it usable with \nLwt. Thus, even though we do not use preemptive threads, queries still do not block the Web server. The \nmost noteworthy feature of PG OCaml is that SQL state\u00adments are statically typed, with type inference. \nAnother key point is that it is immune to SQL code injection vulnerabilities, as queries are automatically \ncompiled into SQL prepared statements (which are pre-compiled, well-formed, queries that can receive \nar\u00adguments). Static typing relies on the DESCRIBE statement command provided by recent versions of PostgreSQL. \nThis command returns the types of the placeholders and return columns of the given state\u00adment. At compile \ntime, SQL statements inside the Ocaml code are thus fed into the PostgreSQL frontend by a Camlp4-based \nprepro\u00adcessor, which answers with their types. Types are then converted back into Ocaml types and used \nto generate the appropriate code. As an example, the following code fun db wiki -> PGSQL(db) \"SELECT \nid, contents FROM wikiboxes WHERE wiki_id = $wiki\" de.nes an Ocaml function of type db . wiki id . (wikibox \nid \u00d7 string option) list. The .eld contents is an SQL text .eld which can be NULL. It is thus mapped \nto the Ocaml type string option. The fact that queries are typed proved extremely useful, as it helps \nto .nd out rapidly which queries have to be modi.ed when\u00adever the database structure is changed during \nprogram develop\u00adment. We see a few potential improvements to PG OCaml. First, the code passed to PG OCaml \nmust be a valid SQL query. Hence, it is not possible to write queries as subblocks that are concate\u00adnated \ntogether, as is often done. It would be interesting to in\u00adcorporate a comprehension-based query language \n(Trinder 1992) into Objective Caml. Second, SQL .elds are often mapped to the same Ocaml type. In the \nexample above, we have in fact wiki id = wikibox id = int32. Making wiki id and wikibox id ab\u00adstract \ntypes in the Ocaml code results in a lot of (explicit) conver\u00adsions, including problematic ones inside \ncontainers. We would like to use explicit coercions (id :> int32) and (int32 :> id) in\u00adstead, but this \nis not currently possible in Ocaml. 4 http://developer.berlios.de/projects/pgocaml/ 5 http://www.postgresql.org/ \n 4. An Application: Writing a Wiki with Ocsigen 4.1 An Overview of Ocsimore We have started the development \nof Ocsimore, a content manage\u00adment system written using Eliom. At the moment, it mostly consists in a \nwiki, with an advanced gestion of users and groups. Currently in .nal beta state, it is already used \nto publish the PPS laboratory website (http://www.pps.jussieu.fr/). At the heart of Ocsimore is the notion \nof box. Wiki pages are composed by putting together or nesting boxes. This provides strong possibilities \nof modularity and code reuse: HTML code can be shared between several pages simply by putting it in a \ncommon box. Moreover, a box can be a container, that is, it can contain a hole that is to be .lled by \nthe contents provided by an outer box. In the example below, the .rst box has a hole (named by convention \n<<content>>) and is included in the second box. Box 1: The text at the end is in bold: **<<content>>**. \nBox 2: Let us call 1: <<wikibox box= 1 | In bold >> The second box is thus displayed as: Let us call \n1: The text at the end is in bold: In bold. The default wiki syntax of Ocsimore is Wikicreole (Sauer \net al. 2007). It is translated into well-formed XHTML using Ocaml-Duce. Ocsimore features an authentication \nmechanism, for ei\u00adther PAM, NIS or Ocsimore-speci.c users. Wikis and wikipages can be assigned read, \nwrite and administration rights. The per\u00admissions system is very general, with the possibility to put \nusers into groups which can themselves be nested. Moreover, Ocsimore features a notion parameterized \ngroups. For example, the groups WikiWriters and WikiReader are parameterized by the id of a wiki, and \nWikiWriters(3) is the group of the users that can write in the third wiki. One can also add generic inclusions \nbetween pa\u00adrameterized groups with similar arguments, and WikiWriters(i) is included in WikiReaders(i) \nfor any i.  4.2 General Structure of the Code Ocsimore is written using the object system of Ocaml in \norder to de.ne modi.able and extensible widgets in a modular way. This makes it easy to add extensions \nwithout any modi.cation to the core system. For instance, a comment system (forum, blogs, news) is currently \nbeing implemented. The wiki is also extensible: syntax extensions can be implemented and then included \ninside wiki boxes. Ocsimore makes use of Eliom s most advanced features. For instance, it takes advantage \nof non-attached services, i.e. services that are not associated to any path (they are implemented using \nspecial URL parameters). These services are used for implementing a connection widget on each page of \nthe site in just a few lines of code. Indeed, we do not have to consider that each page may optionally \ntake credential information as parameters. Instead, the special connection service just performs the \naction of opening a session and then triggers the redisplay of the current page after logging. The same \nkind of service is also used for editing wiki boxes. As the central notion in our wiki is not the notion \nof page but the notion of box (where a box can be included in several pages) it is important to keep \nthe information of the current page while editing a box. This behavior is really easy to implement using \nEliom, and is a good example of the simpli.cation of the code induced by Eliom s high level features. \nIt is noteworthy that making the implementation of common complex Web interactions so easy has an impact \non the ergonomics of Web sites. The example of the connection box is eloquent: in many sites, lazy PHP \nprogrammers prefer having the connection box only in the main page of the site, rather than duplicating \nthe code for each page.  5. Conclusion A few other projects also take advantage of functional program\u00adming \nfor the Web. The two most closely related are Links (Cooper et al. 2006) and Hop (Serrano et al. 2006). \nA few other tools have also implemented continuation-based Web programming: Seaside (Ducasse et al. 2004), \nWash/CGI (Thiemann 2002) and PLT Scheme (Krishnamurthi et al. 2007). Eliom departs from all these others \nprojects in that it is based on Ocaml and proposes a very rich set of services. The wide overview of \nthe Ocsigen project we have given in this paper demonstrates that building a Web programming framework \nis complex, as many very different issues have to be addressed. Continuation-based Web programming is \na key notion of the sys\u00adtem but is not suf.cient in itself. It needs to be integrated within a full environment. \nWe believe that, far beyond this pecular point, functional programming is the ideal setting for de.ning \na more high-level way of programming the Web. It allows the programmer to concentrate on semantics rather \nthan on implementation details. Note that this abstraction from low-level technologies does not en\u00adtail \nany limitation but offers a huge step forward in expressiveness. One of the main concerns of our project \nhas been to improve the reliability of Web applications using static typing, which is at the opposite \nof traditional Web programming, based on scripting languages. We think this evolution is necessary because \nof the growing complexity of Web applications. Our experience in writing application with Eliom and in \nimplementing the whole system itself shows that relying heavily on sophisticated features of the typing \nsystem simpli.es a lot the maintenance and evolution of large pieces of software. For all this project, \nwe made the choice of using the Ocaml language rather than de.ning a new one. This makes it possible \nto take full advantage of the large set of available Ocaml libraries. We were surprised of being able \nto encode most of the properties we wanted using Ocaml s type system. Very few things are missing (a \nbetter typing of forms is one of them). Up to now, we have concentrated mainly on server-side pro\u00adgramming. \nWe intend to extend this work to other aspects of Web programming, namely database interaction and client-side \npro\u00adgramming. This last point is really challenging as it is not obvious how to build a Web site where \nsome parts of the code run on the server and other parts on the client, with strong safety guarantees. \nOur .rst experiment in that direction has been the implementation of a virtual machine for Ocaml in Javascript \n(Canou et al. 2008). Currently, the Ocsigen implementation is mature enough to be used for developing \nand operating real Web sites. Ocsigen is an open source project with a growing community of users, who \nhave already developed signi.cant Eliom-based applications, and who were a great help in building a strong \nand usable tool. We thank them all. References Vincent Balat. Ocsigen: Typing Web interaction with Objective \nCaml. In International Workshop on ML, pages 84 94. ACM Press, 2006. ISBN 1-59593-483-9. doi: http://doi.acm.org/10.1145/1159876.1159889. \nVincent Balat. Eliom programmer s guide. Technical report, Laboratoire PPS, CNRS, universit\u00b4e Paris-Diderot, \n2007. URL http://ocsigen. org/eliom. V\u00b4eronique Benzaken, Giuseppe Castagna, and Alain Frisch. CDuce: \nAn XML-centric general-purpose language. In ACM SIGPLAN Interna\u00adtional Conference on Functional Programming \n(ICFP), Uppsala, Swe\u00adden, pages 51 63, 2003. ISBN 1-58113-756-7. Benjamin Canou, Vincent Balat, and Emmanuel \nChailloux. O browser: Objective Caml on browsers. In ML 08: Proceedings of the 2008 ACM SIGPLAN workshop \non ML, pages 69 78, New York, NY, USA, 2008. ACM. ISBN 978-1-60558-062-3. doi: http://doi.acm.org/10.1145/ \n1411304.1411315. Ezra Cooper, Sam Lindley, Philip Wadler, and Jeremy Yallop. Links: Web programming without \ntiers. In FMCO 2006, 2006. Olivier Danvy. Functional unparsing. Journal of Functional Programming, 8(6):621 \n625, 1998. St\u00b4Seaside aephane Ducasse, Adrian Lienhard, and Lukas Renggli. multiple control .ow web \napplication framework. In Proceedings of ESUG Research Track 2004, pages 231 257, 2004. R. Fielding, \nJ. Gettys, J. Mogul, H. Frystyk, L. Masinter, P. Leach, and T. Berners-Lee. Hypertext transfer protocol \n HTTP/1.1, 1999. URL http://www.ietf.org/rfc/rfc2616.txt. Alain Frisch. OCaml + XDuce. In International \nconference on Func\u00adtional programming (ICFP), pages 192 200, New York, NY, USA, 2006. ACM. doi: http://doi.acm.org/10.1145/1160074.1159829. \nPaul Graham. Beating the averages, 2001. URL http://www. paulgraham.com/avg.html. John Hughes. Generalising \nmonads to arrows. Science of Computer Programming, 37(1 3):67 111, 2000. Shriram Krishnamurthi, Peter \nWalton Hopkins, Jay Mccarthy, Paul T. Graunke, Greg Pettyjohn, and Matthias Felleisen. Implementation \nand use of the PLT Scheme Web server. In Higher-Order and Symbolic Com\u00adputation, 2007. Daan Leijen and \nErik Meijer. Domain speci.c embedded compilers. In Domain-Speci.c Languages, pages 109 122, 1999. URL \nciteseer. ist.psu.edu/leijen99domain.html. Xavier Leroy, Damien Doligez, Jacques Garrigue, J\u00b4er ome Vouillon, \nand Dider R\u00b4emy. The Objective Caml system. Software and documentation available on the Web, 2008. URL \nhttp://caml.inria.fr/. Mark Nottingham and Robert Sayre. The Atom Syndication Format. RFC 4287, December \n2005. Franc\u00b8ois Pottier and Yann R\u00b4Strati.ed type inference for egis-Gianas. generalized algebraic data \ntypes. In Proceedings of the 33rd ACM Symposium on Principles of Programming Languages (POPL 06), pages \n232 244, Charleston, South Carolina, January 2006. Christian Queinnec. The in.uence of browsers on evaluators \nor, continu\u00adations to program web servers. In International conference on Func\u00adtional programming (ICFP), \npages 23 33, Montreal (Canada), Septem\u00adber 2000. Christoph Sauer, Chuck Smith, and Tomas Benz. Wikicreole: \na com\u00admon wiki markup. In WikiSym 07: Proceedings of the 2007 inter\u00adnational symposium on Wikis, pages \n131 142, New York, NY, USA, 2007. ACM. ISBN 978-1-59593-861-9. doi: http://doi.acm.org/10.1145/ 1296951.1296966. \nManuel Serrano, Erick Gallesio, and Florian Loitsch. Hop, a language for programming the Web 2.0. In \nDynamic Languages Symposium, October 2006. Peter Thiemann. Wash/CGI: Server-side Web scripting with sessions \nand typed, compositional forms. In PADL 02, January 2002. Phil Trinder. Comprehensions, a query notation \nfor DBPLs. In DBPL3: Proceedings of the third international workshop on Database program\u00adming languages \n: bulk types &#38; persistent data, pages 55 68, San Fran\u00adcisco, CA, USA, 1992. Morgan Kaufmann Publishers \nInc. ISBN 1\u00ad55860-242-9. J\u00b4ome Vouillon. Lwt: a cooperative thread library. In ML 08: Proceedings er \nof the 2008 ACM SIGPLAN workshop on ML, pages 3 12, New York, NY, USA, 2008. ACM. ISBN 978-1-60558-062-3. \ndoi: http://doi.acm. org/10.1145/1411304.1411307. Hongwei Xi, Chiyan Chen, and Gang Chen. Guarded recursive \ndatatype constructors. In Proceedings of the 30th ACM SIGPLAN Symposium on Principles of Programming \nLanguages, pages 224 235, New Orleans, January 2003.   \n\t\t\t", "proc_id": "1596550", "abstract": "<p>The evolution of Web sites towards very dynamic applications makes it necessary to reconsider current Web programming technologies. We believe that Web development would benefit greatly from more abstract paradigms and that a more semantical approach would result in huge gains in expressiveness. In particular, functional programming provides a really elegant solution to some important Web interaction problems, but few frameworks take advantage of it.</p> <p>The Ocsigen project is an attempt to provide global solutions to these needs. We present our experience in designing this general framework for Web programming, written in Objective Caml. It provides a fully featured Web server and a framework for programming Web applications, with the aim of improving expressiveness and safety. This is done by taking advantage of functional programming and static typing as much as possible.</p>", "authors": [{"name": "Vincent Balat", "author_profile_id": "81100419337", "affiliation": "Paris Diderot university, Paris, France", "person_id": "P1613956", "email_address": "", "orcid_id": ""}, {"name": "J&#233;r&#244;me Vouillon", "author_profile_id": "81100141421", "affiliation": "CNRS, Paris, France", "person_id": "P1613957", "email_address": "", "orcid_id": ""}, {"name": "Boris Yakobowski", "author_profile_id": "81322510752", "affiliation": "CNRS, Paris, France", "person_id": "P1613958", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596595", "year": "2009", "article_id": "1596595", "conference": "ICFP", "title": "Experience report: ocsigen, a web programming framework", "url": "http://dl.acm.org/citation.cfm?id=1596595"}