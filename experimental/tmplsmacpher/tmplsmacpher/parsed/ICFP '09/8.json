{"article_publication_date": "08-31-2009", "fulltext": "\n Experience Report: seL4 Formally Verifying a High-Performance Microkernel Gerwin Klein Philip Derrin \nKevin Elphinstone NICTA and University of NSW NICTA NICTA and University of NSW gerwin.klein@nicta.com.au \nphilip.derrin@nicta.com.au kevin.elphinstone@nicta.com.au Abstract We report on our experience using \nHaskell as an executable speci.\u00adcation language in the formal veri.cation of the seL4 microkernel. The \nveri.cation connects an abstract operational speci.cation in the theorem prover Isabelle/HOL to a C implementation \nof the mi\u00adcrokernel. We describe how this project differs from other efforts, and examine the effect \nof using Haskell in a large-scale formal ver\u00adi.cation. The kernel comprises 8,700 lines of C code; the \nveri.ca\u00adtion more than 150,000 lines of proof script. Categories and Subject Descriptors D.2.4 [Software \nEngineer\u00ading]: Software/Program Veri.cation; D.1.1 [Programming Tech\u00adniques]: Functional Programming; \nD.4.5 [Operating Systems]: Reliability Veri.cation General Terms Veri.cation, Design, Languages Keywords \nHaskell, seL4, microkernel, Isabelle/HOL 1. Introduction We report on our experience using the functional \nprogramming language Haskell in the formal veri.cation of the seL4 micro\u00adkernel (Elphinstone et al. 2007). \nThe seL4 kernel is an evolution of the high-performance L4 microkernel family (Liedtke 1995) for secure, \nembedded devices. It provides essential operating sys\u00adtem services such as threads, inter-process communication, \nvir\u00adtual memory, interrupts, and authorisation via capabilities. In ear\u00adlier work (Derrin et al. 2006), \nwe reported on our experience with Haskell as a speci.cation language for seL4. In this paper, we con\u00adcentrate \non the effect our choice of Haskell had on the formal veri.\u00adcation of the kernel, from abstract operational \nspeci.cation down to high-performance C code. To our knowledge this is the .rst large\u00adscale formal veri.cation \nproject that employs Haskell (or any other functional programming language) in this way.1 We found that \nworking with Haskell decreased our kernel de\u00adsign time, enabled an iterative prototyping process in an \narea where usually only top-down and bottom-up approaches are advocated, 1 The ACL2 prover uses LISP \nas its formal language. Our use of Haskell differs in the sense that our executable kernel prototype \nin Haskell is an independent program that can stand on its own without theorem prover involvement. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 09, August \n31 September 2, 2009, Edinburgh, Scotland, UK. Copyright c &#38;#169; 2009 ACM 978-1-60558-332-7/09/08. \n. . $5.00 Figure 1. Speci.cation layers in the L4.veri.ed project. and made formal veri.cation towards \nabstract and concrete levels substantially easier and faster than they would have been otherwise. The \nbasic structure of the veri.cation project is shown in Fig. 1. The left-hand side follows the classic \npattern of a traditional re.ne\u00adment. There is an abstract speci.cation at the top, an executable speci.cation \nin the middle, and a C implementation on the bottom. Elkaduwe et al. (2008) have also created an even \nmore abstract se\u00adcurity model with security proof that would be placed above the ab\u00adstract speci.cation, \nbut it has not yet been formally connected with the rest of the stack. In the setting of a commercial \nCommon Cri\u00adteria evaluation, the abstract speci.cation is the high-level design and the executable speci.cation \nis the low-level design. Cock et al. (2008) present details on the proof between abstract and executable \nlevel; the proof between executable speci.cation and implementa\u00adtion will appear elsewhere (Winwood et \nal. 2009). While neither the main property (functional correctness) nor the main proof methodology (re.nement) \nare unusual, the size and scope of the project are. The veri.cation does not stop at a speci.cation, \nbut descends to the implementation level: 8,700 lines of high-performance, manually tuned C code close \nto hardware. All proofs in this project are machine-checked in the interactive theorem prover Isabelle/HOL \n(Nipkow et al. 2002). The project is also unusual in the approach it takes to kernel design and implementation. \nTwo teams were involved: a kernel de\u00adsign team with an operating systems background, and a veri.cation \nteam with a formal methods background. The right-hand side of Fig. 1 indicates that the executable speci.cation \nof seL4 is pro\u00adduced from a kernel prototype written in Haskell. We have imple\u00admented an automatic translator \nthat converts our subset of Haskell into Isabelle/HOL. The Haskell prototype is written and maintained \nby the design team. It is the principal embodiment of their design decisions. It also became, after automatic \ntranslation, the starting point for the veri.cation effort. The traditional model for green\u00ad.eld projects \nis to work top-down from a high-level speci.cation, and for existing implementations to work bottom-up \nfrom the im\u00adplementation level; beginning veri.cation with an executable spec\u00adi.cation is unusual. The \neffects of this choice on the veri.cation are discussed below.  The abstract speci.cation and the C \nimplementation were devel\u00adoped manually; both were started before the design and there\u00adfore the executable \nspeci.cation was completely stable. Both activities fed changes back into the Haskell prototype, but \nthey did not supersede it. The Haskell prototype remained the central refer\u00adence model throughout the \nduration of the project. 2. Executable and Abstract Speci.cation Microkernels in the L4 family share \na number of basic design prin\u00adciples, set out by Liedtke (1995). They provide only the abstrac\u00adtions \nthat are essential for performance or security primarily vir\u00adtual memory, threads, and inter-process \ncommunication. They are designed with an emphasis on IPC performance, which is critical to the overall \nperformance of microkernel-based systems. They have, historically, provided only minimal support for \nmanaging kernel resources and for controlling access to communication. The seL4 project set out to design \na new microkernel based on the same basic principles, but taking a new approach with capability-based \nresource management and access control. Since this entailed designing a new API that was signi.cantly \ndifferent to that of previous L4 kernels, there was a large design space to explore. We decided, at the \noutset, that implementing a new kernel in C from scratch when the design was still uncertain was a risky \nproposition; much time would be wasted on rewrites and low-level, hardware-dependent debugging before \na .nal design emerged. On the other hand, designing a kernel formally on paper before imple\u00admenting it \nmight result in an API with limited application to real\u00adworld use. We wanted to be able to execute user-level \nprograms to test our proposed designs. Also, since we intended to formally ver\u00adify safety properties \nof the kernel (Tuch et al. 2005), we desired a precise speci.cation with well-de.ned semantics. Thus, \nwe developed an executable model of the design in Haskell. This model was gradually developed into a \ncomplete pro\u00adtotype, exploring various design alternatives in the process (see Derrin et al. 2006). We \nwere able to exercise user-level programs on the binary level by attaching a processor and platform simula\u00adtion \nto the Haskell prototype. At the same time, we formalised the Haskell prototype by translating it into \nIsabelle/HOL; the transla\u00adtion was initially performed by hand, but was later automated. When, after \na number of iterations, the kernel design in Haskell had begun to stabilise, we constructed an abstract, \noperational spec\u00adi.cation with fewer data structure details, and with features like scheduling underspeci.ed \nso that different implementation choices could be explored in later versions of the kernel. The abstract \nspec\u00adi.cation is meant to specify what the kernel does; the executable speci.cation gives details on \nhow it is done. This initial abstract formalisation process provided immediate feedback on correctness \nand safety to the design team. The feedback increased when we started the re.nement proof between the \ntwo layers (see Sect. 4). Isabelle/HOL is based on lambda calculus, and can be seen as a functional programming \nlanguage extended with logical opera\u00adtors. It is less expressive than Haskell in some ways: every function \nmust terminate, which limits use of laziness; type classes cannot have multiple parameters, and there \nare no constructor type class, so there is no built-in Monad typeclass, nor was there initially do\u00adsyntax \nfor lists of sequential operations. However, Isabelle s syntax is easily extensible, and we were able \nto de.ne our own do-syntax for the speci.c monads used by our abstract and executable mod\u00adels. Unsurprisingly, \nthe Isabelle/HOL standard library is geared to\u00adwards theorem proving and felt therefore limited for implementing \na large-scale functional program. Again, this was easily extended. We were able to implement all of the \nmonad and list functions that we used of the Haskell library in Isabelle. Proving termination for every \nfunction was less dif.cult than we anticipated for primitive recursion and for functions with a sim\u00adple \nlexicographic termination measure the proofs are straightfor\u00adward and in many cases entirely automatic. \nHowever, we avoided complex recursion patterns, such as nested mutual recursion, be\u00adcause they would \nhave been more dif.cult to translate. This was also desirable because the microkernel has to operate \non strictly limited and known stack depth, so recursion ultimately had to be implemented by loops in \nC anyway. We used only a constrained subset of Haskell that could be translated to Isabelle/HOL. Besides \nforgoing the use of laziness in any essential way, we made limited use of type classes in Haskell (in \nparticular using only three speci.c instances of MONAD m), and avoided most GHC extensions. The use of \nHaskell at this stage had two main effects on the ver\u00adi.cation component of the project. First, it removed \nthe need to in\u00adterpret vague and inaccurate natural language design speci.cations, user manuals, or incomprehensible \noptimised C code. Second, it constrained the design team to a subset of Haskell that could be handled \nby the automatic translation, leading them to instinctively favour designs suitable for formal speci.cation. \nSince extending the subset had an obvious cost in terms of modi.cations to the translator, there was \na natural counter-force to increasing this sub\u00adset too much. The question How would we write this in \nHaskell?, and therefore How can it be formalised?, was a topic in design team discussions. In a normal \nkernel design process, it would not have been. 3. High Performance C Implementation The goals of the \nHaskell prototype were twofold: predictable be\u00adhaviour to provide an easy path to formalisation, and \nenough detail to provide an easy path to a C implementation. The second requirement, especially, led \nto an imperative-style Haskell program with extensive use of the StateT and ErrorT mon\u00adads, including \nan explicit model of kernel memory addressed by typed pointers. An explicit hardware interface made it \neasier to con\u00adnect the prototype to different simulators (M5, qemu, and our own ARMv6 instruction simulator). \nThis interface also became the ma\u00adchine interface of the C kernel. As performance tuning is essential \nfor microkernels, we did not attempt to generate C code from the model, but implemented the kernel manually, \nfollowing the structure of the executable speci.\u00adcation closely. The direct C implementation work was \nroughly 2 person months in effort, which is insigni.cant compared to the 20 person years spent on the \ncomplete project. The extremely rapid manual implementation was possible thanks to the precise exe\u00adcutable \nspeci.cation. Not many implementation choices had to be made, and the structure of the program was clearly \nlaid out already. D. Wheeler s SLOCCount estimates that the effort for implement\u00ading the kernel directly \nin C would have been 4 person years. The ef\u00adfort for designing, writing and documenting the Haskell prototype \nwas ca 2 person years. Based on this estimate, the use of Haskell reduced the implementation effort by \n50%. In the .rst implementation pass, we did not pay any attention to performance. The result of this \ninitial pass was therefore unsur\u00adprisingly slow (on the order of the Mach microkernel), a factor of 3 \nslower than comparable operations in existing L4 kernels. After a .rst round of manual optimisations, \nseL4 IPC performance is now comparable to OKL4 2.1 (2008) on ARMv6. Another consequence of using a functional \nlanguage as the design source was the structured use of tagged unions in the C code. Veri.cation of unstructured \nunions in C is unpleasant. Since unions and structs were used in a principled way, we managed to avoid \nthis additional veri.cation burden entirely. Moreover, we did not trust the compiler to translate C bit.elds \ncorrectly and with the .ne-grained control we required; instead, we generated the C code for these structures \nand tagged unions automatically from a separate speci.cation language (Cock 2008). We also generated \nthe corresponding Isabelle/HOL proof of code correctness.  Our veri.cation framework treats a large, \ntrue subset of C99. The main restrictions are: we do not allow the address-of (&#38;) op\u00aderator on local \nvariables, because the stack is modelled separately from the heap; we do not allow function pointers \nand goto state\u00adments; we make some expressions such as x++ statement forms; and we allow at most one \nside-effecting sub-expression in any as\u00adsignment, because execution order is arbitrary otherwise. The \nfunc\u00adtion pointer prohibition implies that we did not make heavy use of higher-order functions in Haskell \napart from some speci.c func\u00adtions that are used to emulate C control structures such as mapM , zipWithM, \ncatchError, and so on. This prohibition could be lifted fairly easily from the C translation, but we \nfound it advantageous to strive for simplicity over features when possible in our Hoare logic framework \nfor C. We translate C types precisely into Isabelle/HOL, including pointers, address arithmetic, .nite \nintegers, structs, and padding in structs (Tuch et al. 2007). Our target architecture is ARMv6; the compiler \nis GCC 4.2.2. Strictly speaking, Fig. 1 is inaccurate in that we do not reason on C directly, but on \na translation of C into Isabelle/HOL. In contrast to the Haskell/Isabelle translation, this is a comparatively \nsmall translation step, with explicit care taken to map the semantics of C precisely into the theorem \nprover. Although our experience was in general favourable, ef.cient kernel code does not always translate \nwell from Haskell. For ex\u00adample, the executable model s error handling code contains a func\u00adtion that \nloads a message into a user-level context (setMRs), which is applied to the results of one of several \nfunctions that generate messages (as lists of machine words) from various error types. Translating this \ndirectly to C leads to implicit allocation of memory to temporarily hold the message, and double copying \nof the mes\u00adsage s contents; in order to keep the C code ef.cient, we manually unfolded the de.nition \nof setMRs and fused it with the message generation functions before translating. More generally, we found \nthat Haskell at times encouraged coding practices that are inef.\u00adcient in our subset of C if translated \nnaively: passing large struc\u00adtures as function arguments, throwing and catching exceptions for error \nhandling, and function composition that depends on laziness to be ef.cient. An interesting observation \non the C implementation was that the C program was in parts less verbose than the explicit mem\u00adory model \nwe used in Haskell, because load-check-modify-store idioms are simply written as pointer accesses and \nupdates in C. The more verbose style for this part in Haskell did not hinder veri.ca\u00adtion. On the contrary, \npointers made up a large part of the hidden complexity of the C program that was dealt with explicitly \nin the executable and abstract models. The additional verbosity was local only. In total, the Haskell \nprototype comes to 5,700 LOC compared to 8,700 LOC in C (numbers according to SLOCCount). To summarise, \nwe restricted our use of Haskell to a suitable subset and were able to manually implement a high-performance \nC version of the kernel in very little time. The Haskell and C versions have almost identical data and \ncode structures. We exploited this fact heavily in the veri.cation. 4. Formal Veri.cation As mentioned \nin the introduction, the formal veri.cation of seL4 consisted of two major re.nement steps: between abstract \nand executable speci.cation, and between executable speci.cation and implementation. Our embedding of \nHaskell into Isabelle is shallow, the embedding of C into Isabelle is deep for statements and shallow \nfor expressions. The main statement we proved in each of the two steps is formal re.nement, reduced to \nforward simulation: if the initial states are in a system-global state relation R, and the concrete level \ntakes one step, then the abstract level must be able to take a corresponding step such that the resulting \nstates again are in the relation R. Cock et al. (2008) extend this classic notion to state monads, integrating \nthe aspects of failure, non-determinism and exceptions needed in the kernel speci.cations. The notion \nimplies, and we have proved in Isabelle/HOL, that all Hoare triples that are true on the abstract level \nare also true on the concrete level, modulo the state relation R. 4.1 First Re.nement Step Re.nement \nstep one in the veri.cation took ca 8 person years in total and manually produced 117,000 lines of Isabelle/HOL \nproof script. This step contains the conceptually interesting part of the proof, reasoning about the \ndesign aspects of execution safety and correctness. We cannot go into the details of this proof here \nfor space reasons, but the simpler and higher-level data structures of the abstract speci.cation require \ninvariants on their more detailed counterparts on the executable level to show correspondence. Basic \npreconditions of the correspondence proof are that each operation is well de.ned, that memory accesses \nare correctly typed, that as\u00adsertions do not fail, that objects that are read from do exist, and that \npartially de.ned functions (e.g. those with incomplete patterns in Haskell) are used only within their \ndomain. These preconditions for safe execution spawned a number of complex invariants on how the kernel \nworks, how it explicitly re-uses memory, and how it pre\u00advents dangling references to deleted objects \nin any part of the kernel (including all of memory). Reasoning on this level included explicit decoding \nof binary system call arguments read from user registers and full argument checking to ensure safe operation \nfor any kernel input, be it benign, maliciously crafted, or simply garbage. The effect our use of Haskell \nhad on this proof can be sum\u00admarised as: the ability to exploit structural similarities, an increased \nuse of library functions, initial increased technical friction in work\u00ading with generated de.nitions, \nand different proof style. We explain each of these in more detail in the following paragraphs. The Haskell \nprototype existed .rst, and therefore the abstract speci.cation was inspired by it in structure. We were \nable to exploit this structural similarity to make the proof easier. Being inspired by the executable \nlevel also means that our abstract speci.cation is probably more concrete than it may have been without \nthis input. A higher-level abstract speci.cation would have meant more distance for the re.nement proof \nto the executable level, but possibly less distance to further layers above. For showing speci.c properties \nof the kernel that turn out to be too complex for the complete abstract operational speci.cation, we \nwould add a further, more abstract layer to the stack that is specialised to the property under consideration, \nsuch as we are currently exploring with the abstract access control model of seL4 (Elkaduwe et al. 2008). \nHaskell being a fully-featured programming language led the design team to make more extensive use of \nlibrary functions like mapM and zipWithM than they otherwise may have. At the time, there were no Isabelle \nversions of these functions. Introducing them saved veri.cation work because we avoided repeating proofs \nover many similar recursion patterns. On the less positive side, we observed more technical friction \nin the proofs that were concerned with de.nitions generated from Haskell than in those that were written \nin Isabelle directly. This was expected. Programming idioms did not always match up with how rules were \nphrased in the Isabelle library. The executable speci.cation was generated Isabelle code that was not \nas concise as the Haskell source, and not always nice to read. This turned out to be an initial problem \nonly. The new idioms became manageable once the veri.cation team were used to them, and had built up \na library of matching rules. The generated code could often be rewritten trivially with associativity \nand other simple, general state\u00admonad laws to read more nicely.  Due to the monadic, imperative style \nof the Haskell prototype and therefore the executable speci.cation, the majority of the proof took the \nform of Hoare triples, weakest precondition reasoning, and correspondence calculus reasoning. Apart from \nthe rewrites mentioned above we used only little of the algebraic reasoning that would usually be associated \nwith verifying functional programs. This proof structure is mainly an artefact of the application area \nand of having C as a target implementation language. We did use induction where recursion was involved \nin the Haskell program. In C, these were replaced by loops. This .rst proof lead to around 200 changes \nin the Haskell prototype and 300 changes in the abstract speci.cation. Less than half of these were genuine \nbugs or design defects. Most changes were for proof convenience: reshuf.ing functions to match up more \nclosely, adding assertions to transport information across levels, and adding local checks or re-arranging \ncode to make properties more obviously true. The majority of the bugs we found during veri.cation were \nmundane: simple typos and some copy &#38; paste errors. We did also .nd more subtle problems in the initial \ndesign like missing argument checking, potential security violations etc. Of course, it does not matter \nif the defect is mundane or not: the kernel will happily crash or allow a security attack either way. \nIt is interesting to note that the actual discovery of defects does not necessarily occur when they leap \nfrom the screen in the form of a counter example or unprovable lemma (although that did happen). Instead, \nmany defects were found when new invariants became necessary and the veri.cation and design teams discussed \nwhat these should be, whether they would hold, and, if so, why. One answer a veri.cation team should \nbe wary of is this is never done anywhere in the kernel. This answer usually means proving a new fact \nabout the whole kernel instead of quick local reasoning. It is not clear if the use of Haskell would \nhave been bene.cial in just the proof of the .rst re.nement step in isolation. Nicer, more elegant reasoning \nmight have been possible in a more abstract, still executable setting with de.nitions written directly \nin Isabelle/HOL. The detailed executable model, and its use as a prototype running user binaries, injected \na sometimes unpleasant dose of realism into the proof forcing us to consider implementation details \nthat are necessary for an ef.cient kernel, rather than one that simply func\u00adtions correctly. For example, \none part of the .rst re.nement proof that was particularly challenging was the relation between the ab\u00adstract \nand executable models versions of the capability derivation tree. This is one of the two main metadata \nstructures in the seL4 implementation; it is conceptually a forest of directed trees, and is represented \nin the abstract model by simple functions that encode a binary relation between pointers to the nodes. \nThe executable model represents it the way a real kernel implementation would: as a set of doubly linked \nlists, each corresponding to a pre-order traversal of a tree. The depth information is implicitly encoded \nin the nodes, and is available only by comparing two nodes; the depth comparison function requires that \nits arguments are in the stored or\u00adder. Furthermore, the lists are not represented by Haskell s standard \nlist type, but by pairs of pointers stored in separate node objects in the modelled physical memory \nas they would be in C. Naturally, the invariants that must be maintained by operations on these struc\u00adtures \nare complex, and therefore so is the re.nement proof for those operations. This realism paid off in the \nsecond re.nement step.  4.2 Second Re.nement Step One important observation about the .rst re.nement \nstep is that we spent roughly 80% of the proof effort on showing invariants of the abstract and executable \nlevels and only 20% on the correspondence itself. The invariants were necessary preconditions for the \ncorre\u00adspondence, but they also carry a large amount of information on how precisely the kernel works \nand why its internal data structures are safe to use. Because the Haskell and C implementations share \nalmost iden\u00adtical data and code structures, we were able to avoid these 80% for the second step. The \nimportant invariants had already been proved on the executable speci.cation level, and no complex semantic \nrea\u00adsoning was necessary on the C level. The most complex new rela\u00adtionships we had to show on the C \nlevel were the implementation of Haskell or Isabelle lists as doubly linked lists, some of which were \nencoded in existing data structures. The C veri.cation did lead us to prove new invariants on the level \nof the executable speci.cation, but far fewer than we needed in the .rst step. They were mainly due to \noptimisations in C that made use of conditions known to be true over kernel execution. The main challenges \nin the second step were dealing with C lan\u00adguage semantics and data structure encodings, but without \ncomplex data re.nement. Having to prove at the same time that the C code maintains complex invariants \nas we had shown in step one would have made this proof much harder. At the time of writing, the proof \non the C level is completed for 474 functions out of 518 and we have so far spent 26 person months on \nthis part of the veri.cation. The speed of veri.cation on this level was 3 4 functions per person per \nweek with 3 5 persons working on this body of proofs concur\u00adrently. Even though the kernel implementation \nhad in the meantime been used in a number of small student projects, had been ported to the x86 architecture, \nand had been run through static analysis tools, we still found 97 defects in C during the veri.cation. \nWe had not attempted to test the implementation in great detail, because for\u00admal veri.cation was scheduled \nanyway. For each of the defects we could have found a test case that demonstrated it, but of course the \nquestion is whether we would have thought of these beforehand. Unsurprisingly, the defects were concentrated \nin parts of the kernel that were less used in the student projects and that were compli\u00adcated to use. \nMost of them were simple translation errors and typos in the implementation step from Haskell to C, fewer \nwere defects in new data encodings and optimisation. We also observed compiler speci.c errors: for instance, \nsome functions that we had annotated with GCC s pure and const attributes to enable optimisations were \nnot in fact pure or const. The compiler did not check the attributes, and neither did we initially in \nthe veri.cation. This lead to unex\u00adpected execution behaviour in otherwise already veri.ed code. We have \nupdated the veri.cation framework in the meantime to include such compiler hints and make them proof \nobligations. The pure and const attributes are now checked automatically. As in the .rst re.nement step, \nit was crucial for the veri.cation that we were able to change the C code as well as the Haskell source \nfor proof convenience instead of having to prove complex reorder\u00ading theorems. For some optimisations, \nwe changed the observable behaviour of both the abstract and the executable speci.cations. For instance, \nwe changed the order in which data was stored in global data structures, or the order in which arguments \nwere checked (and therefore which error messages would be reported .rst). In summary, the veri.cation \nof seL4 proceeded in two main steps. Step one dealt with mostly semantic content in a shallow embedding; \nstep two was more syntactic and dealt with C, its memory model and speci.c optimisations. We were able \nto avoid a large part of the proof in the second step, because of the structural similarity between the \nC and the Haskell implementations.  5. Conclusion We have presented our experience in using Haskell \nin the veri.ca\u00adtion of the seL4 microkernel. The aspects of the veri.cation that are speci.c to this \nproject are its size, the implementation level it descends to, and its iterative development cycle. As \nthere is not suf.cient space to survey related work in this article we refer to the comprehensive overview \nby Klein (2009). We consider it important for the success of this project that the kernel was designed \nby a team with an OS background, not by the veri.cation team. The veri.cation team believes it would \nhave designed a much more elegant, but much more useless microkernel. The connection between the two \nteams was the Haskell prototype. All of the veri.cation and implementation activities fed back into this \ncentral reference speci.cation of the project. We could have created the executable speci.cation in Isabelle \ndirectly, but that would have left the design team out of the loop. We could also have chosen another \nfunctional language, such as ML, rather than Haskell; the primary motivation for our choice was the local \navailability of experienced Haskell programmers at UNSW, where Haskell is used in several research projects \nand was used as the introductory undergraduate programming language at the time. In addition, we consider \nthe extensive tool-chain support for Haskell (compiler, foreign function interface, literate Haskell) \nan important contributor to the success of the Haskell source as a simultaneous binary-compatible prototype, \ndesign document, and formal executable speci.cation. The part of the OS team that ac\u00adtively wrote the \nHaskell code had previous experience with Haskell. The part of the OS team that did not have extensive \nexperience with Haskell was comfortable with the new language after less than one month. The culture \nshock between the Formal Methods and Operating Systems groups was smaller than expected and greatly alleviated \nby team members who had gone through advanced courses in both areas. Will this approach work for everything? \nWe believe that for high assurance on the level of kernel and systems code where performance and hardware \ninteraction are important, the approach will work well. On the application level, it might be suf.cient \nto stop at the level of an executable speci.cation, possibly in Haskell or ML, if the compiler, runtime, \nand translation into Isabelle can be trusted. Acknowledgments We thank Timothy Bourke, Michael Norrish, \nand Thomas Sewell for reading and discussing drafts of this article. NICTA is funded by the Australian \nGovernment as represented by the Department of Broadband, Communications and the Digital Economy and \nthe Australian Research Council through the ICT Centre of Excellence program. References D. Cock. Bit.elds \nand tagged unions in C: Veri.cation through automatic generation. In B. Beckert and G. Klein, editors, \nProceedings of the 5th International Veri.cation Workshop (VERIFY 08), volume 372 of CEUR Workshop Proceedings, \npages 44 55, Sydney, Australia, Aug 2008. D. Cock, G. Klein, and T. Sewell. Secure microkernels, state \nmonads and scalable re.nement. In O. A. Mohamed, C. Mu noz, and S. Tahar, editors, 21st TPHOLs, volume \n5170 of LNCS, pages 167 182, Montreal, Canada, Aug 2008. Springer. P. Derrin, K. Elphinstone, G. Klein, \nD. Cock, and M. M. T. Chakravarty. Running the manual: An approach to high-assurance microkernel devel\u00adopment. \nIn ACM SIGPLAN Haskell WS, Portland, OR, USA, Sep 2006. D. Elkaduwe, G. Klein, and K. Elphinstone. Veri.ed \nprotection model of the seL4 microkernel. In J. Woodcock and N. Shankar, editors, VSTTE 2008 Veri.ed \nSoftw.: Theories, Tools &#38; Experiments, volume 5295 of LNCS, pages 99 114, Toronto, Canada, 2008. \nSpringer. K. Elphinstone, G. Klein, P. Derrin, T. Roscoe, and G. Heiser. Towards a practical, veri.ed \nkernel. In 11th HotOS, pages 117 122, 2007. G. Klein. Operating system veri.cation an overview. S\u00afadhan\u00afa, \n34(1): 27 69, Feb 2009. J. Liedtke. On \u00b5-kernel construction. In 15th SOSP, pages 237 250, Copper Mountain, \nCO, USA, Dec 1995. T. Nipkow, L. Paulson, and M. Wenzel. Isabelle/HOL A Proof Assistant for Higher-Order \nLogic, volume 2283 of LNCS. Springer, 2002. Open Kernel Labs. OKL4 v2.1. http://www.ok-labs.com, 2008. \nH. Tuch, G. Klein, and G. Heiser. OS veri.cation now! In 10th HotOS, pages 7 12, Santa Fe, NM, USA, \nJun 2005. USENIX. H. Tuch, G. Klein, and M. Norrish. Types, bytes, and separation logic. In M. Hofmann \nand M. Felleisen, editors, 34th POPL, pages 97 108, 2007. S. Winwood, G. Klein, T. Sewell, J. Andronick, \nD. Cock, and M. Norrish. Mind the gap: A veri.cation framework for low-level C. In S. Berghofer, T. Nipkow, \nC. Urban, and M. Wenzel, editors, Proc. 22nd International Conference on Theorem Proving in Higher Order \nLogics (TPHOLs 09), volume 5674 of LNCS. Springer, 2009. To appear.  \n\t\t\t", "proc_id": "1596550", "abstract": "<p>We report on our experience using Haskell as an executable specification language in the formal verification of the seL4 microkernel. The verification connects an abstract operational specification in the theorem prover Isabelle/HOL to a C implementation of the microkernel. We describe how this project differs from other efforts, and examine the effect of using Haskell in a large-scale formal verification. The kernel comprises 8,700 lines of C code; the verification more than 150,000 lines of proof script.</p>", "authors": [{"name": "Gerwin Klein", "author_profile_id": "81100142186", "affiliation": "NICTA & UNSW, Sydney, Australia", "person_id": "P1613997", "email_address": "", "orcid_id": ""}, {"name": "Philip Derrin", "author_profile_id": "81318488298", "affiliation": "NICTA, Sydney, Australia", "person_id": "P1613998", "email_address": "", "orcid_id": ""}, {"name": "Kevin Elphinstone", "author_profile_id": "81100042921", "affiliation": "NICTA & UNSW, Sydney, Australia", "person_id": "P1613999", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596566", "year": "2009", "article_id": "1596566", "conference": "ICFP", "title": "Experience report: seL4: formally verifying a high-performance microkernel", "url": "http://dl.acm.org/citation.cfm?id=1596566"}