{"article_publication_date": "08-31-2009", "fulltext": "\n A Theory of Typed Coercions and its Applications Nikhil Swamy Michael Hicks * Gavin M. Bierman Microsoft \nResearch, USA University of Maryland, College Park Microsoft Research Cambridge, UK nswamy@microsoft.com \nmwh@cs.umd.edu gmb@microsoft.com Abstract A number of important program rewriting scenarios can be recast \nas type-directed coercion insertion. These range from more theoretical applications such as coercive \nsubtyping and supporting overloading in type theories, to more practical applications such as integrating \nstatic and dynamically typed code using gradual typing, and in\u00adlining code to enforce security policies \nsuch as access control and provenance tracking. In this paper we give a general theory of type\u00addirected \ncoercion insertion. We speci.cally explore the inherent tradeoff between expressiveness and ambiguity \nthe more power\u00adful the strategy for generating coercions, the greater the possibil\u00adity of several, semantically \ndistinct rewritings for a given program. We consider increasingly powerful coercion generation strategies, \nwork out example applications supported by the increased power (including those mentioned above), and \nidentify the inherent am\u00adbiguity problems of each setting, along with various techniques to tame the \nambiguities. Categories and Subject Descriptors D.3.1 [Formal De.nitions and Theory]: Semantics; D.3.4 \n[Processors]: Compilers General Terms Design, Languages, Theory Keywords coercion insertion, nonambiguity, \ntype-directed trans\u00adlation, provenance, gradual typing 1. Introduction For nearly two decades, researchers \nhave considered the problem of type-directed coercion insertion, in which data of one type can be automatically \ncoerced to another type, without explicit intervention by the programmer [Breazu-Tannen et al. 1991, \nBarthe 1996, Luo 1996]. For example, suppose a value of type lazy a, called a thunk, represents a suspended \ncomputation that when evaluated will have type a. When needed, a thunk s underlying value is acquired \nby passing it to the function force : lazy a . a. Rather than require the programmer to manually insert \ncalls to force, the programmer can use lazy a values as if they were a values, and coercion in\u00adsertion \nwill add the needed calls to force automatically. Coercion insertion has been proposed to support numeric \nand other represen\u00adtational conversions, both in mainstream programming languages and type theories, \nand overloading, among other applications. * Work performed while this author was visiting Microsoft \nResearch, Cam\u00adbridge, and the University of Cambridge Computer Laboratory. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 09, August 31 September 2, 2009, Edinburgh, \nScotland, UK. Copyright c &#38;#169; 2009 ACM 978-1-60558-332-7/09/08. . . $10.00 We became interested \nin the coercion insertion problem while developing the Fable calculus [Swamy et al. 2008]. In that work \nwe showed how to precisely enforce a broad range of security poli\u00adcies, including access control and \nnoninterference-style informa\u00adtion .ow policies, by mediating access to security-relevant objects using \nwhat amounts to sophisticated coercions. For .ne-grained, end-to-end security policies like information \n.ow tracking, we found that manually inserting the necessary calls was tedious and resulted in confusing \nand complicated code. Thus it seemed nat\u00adural to apply coercion insertion to add security checks automati\u00adcally. \nUnfortunately, we found existing work on coercion insertion suffered from being too inexpressive or unpredictable \nbecause of ambiguous rewriting. In this paper, we develop a new theory of type-directed coercion insertion \nfor the simply-typed lambda calculus that consists of two interrelated judgments: ' Coercion generation: \nS f t <d tr c Type-directed coercion insertion: S; G fd,d' e r m : t Both judgments are parameterized \nby a coercion set S con\u00adsisting of the name and type of each primitive coercion, e.g., force:.a.lazy \na . a. The coercion generation judgment is used to construct coercion terms c of type t . t' built from \nprimitive coercions in S. We study several de.nitions of the coercion generation judgment, each iden\u00adti.ed \nby an index d. The most powerful de.nition permits primitive coercions to have polymorphic types (though \nsource terms do not), and may construct coercion terms by composing primitive coer\u00adcions transitively \n(e.g., S f t1 <d t3 r c via c1 : t1 . t2 and c2 : t2 . t3) and component-wise according to type structure, \n'' as in coercive subtyping (e.g., S f t1 \u00d7 t2 <d t1 \u00d7 t2 r c via '' c1 : t1 . t1 and c2 : t2 . t2). \nNo prior system has incorpo\u00adrated all three of these elements into coercion generation with the same \ndegree of .exibility; e.g., Luo allows only primitive, poly\u00admorphic coercions [Luo and Kie\u00dfling 2004, \nLuo 2008]; and while the coercions of Sa\u00a8ibi [1997] include elements of our structural and polymorphic \njudgments, his restrictions on the use of polymor\u00adphism make them unsuitable for our applications. As \nwe demon\u00adstrate in \u00a76.3, we have found the combination of the three to be crucial for implementing coercions \nthat track information prove\u00adnance [Cheney et al. 2007] whereby our framework inserts calls to these \ncoercions automatically. On the other hand, we show that weaker de.nitions of coercion generation are \nuseful for avoiding potentially ambiguous rewrit\u00adings, and may be preferred for some applications. With \ndifferent coercion generation de.nitions we show our system can implement many applications, including \noverloaded operators (\u00a72), equality\u00adwitnessing coercions (used in dynamic software update safety checking \n[Stoyle et al. 2007]) (\u00a74.3), coercive subtyping [Luo 1996] (\u00a75.3), forms of dynamic and gradual typing \n[Henglein 1994, Siek and Taha 2006] (\u00a75.5), and transparent proxies for fu\u00adtures [Pratikakis et al. 2004] \n(\u00a76.1). In several cases, we are the .rst to demonstrate that coercion insertion can be used to imple\u00adment \nthese applications.  The coercion insertion judgment S; G fd,d ' e r m : t is used to rewrite a term \ne by inserting generated coercions; e.g., to rewrite a source term f 1 to (force f)1. The indices d, \nd ' identify the co\u00adercion generation de.nition(s) to be used. For a given S there may be many ways to \nrewrite a term, in which case we say that coer\u00adcion insertion is ambiguous. Ambiguity is a problem when \ndifferent rewritings may have different run-time semantics, since program\u00admers can no longer reason about \nthe meaning of their source pro\u00adgram. We .nd treatment of ambiguous rewriting in prior work lack\u00ading \nin two ways. First, rather than avoid ambiguity, several systems attempt to argue that all possible rewritings \nare con.uent, and thus semantically equivalent. However, not all useful coercions exhibit the necessary \nequivalences to make such arguments. For example, coercions that cause a loss in precision may not have \ninverses, e.g., (int2.oat . .oat2int) x x, for all x. Additionally, when co\u00ad = ercions and/or the source \nlanguage include effects, such as I/O or run-time failure, different rewritings can be distinguished \nbased on the order of evaluation. Second, prior work often does not consider the root causes of ambiguity \ndue to S; for example, a S containing two coercions of type t . t ' is problematic because any rewriting \nthat uses the .rst coercion could just as well use the second. Work that does consider this problem is \noverly restrictive. Our work addresses both of these limitations. To address the .rst problem, we employ \na purely syntactic notion of ambiguity. We show that our syntactic restrictions make our system no less \nexpressive than a system without such restrictions (which would instead rely on more limited con.uence \narguments). For the second problem, we develop necessary and suf.cient conditions that can be used to \ncheck, for a given S and coercion generation judgment, whether coercion insertion will be strongly unambiguous, \nmeaning that every possible term rewriting is unam\u00adbiguous (i.e., there is exactly one rewriting). Sa\u00a8ibi \n[1997] and Luo and Kie\u00dfling [2004] also develop suf.cient conditions, but they are overly strong, ruling \nout useful rewritings that would actually be unambiguous. Interestingly, we have found some useful coercion \nsets S that are not strongly unambiguous for some de.nitions of co\u00adercion generation there will be ambiguous \nrewritings for at least some terms e. For these cases, the programmer must indicate via annotations which \nrewriting is preferred. In summary, the primary contribution of this paper is a frame\u00adwork for type-directed \ncoercion insertion that is extremely expres\u00adsive, and yet carefully accounts for the problem of ambiguous \nrewritings (\u00a72 and \u00a73). We develop increasingly powerful de.ni\u00adtions for coercion generation and use \nthem to show how our frame\u00adwork can be used to encode many interesting applications (\u00a74 \u00a76), suggesting \nour approach to type-directed coercion insertion may be a worthwhile addition to mainstream programming \nlanguages. 2. Type-directed coercion insertion We explore the type-directed coercion insertion problem \nfor the simply typed lambda calculus; its syntax is given at the top of Figure 1. While we ultimately \nwish to support coercion insertion for a polymorphically-typed term language, simply-typed source terms \nnevertheless present signi.cant challenges, and are relevant in many contexts, as we show throughout \nthe paper. Types consist of base types B, function types t1 . t2, and product types t1 \u00d7 t2, corresponding \nto the usual source language terms e. We also include type ascriptions e:t and type casts (t)e, which \nthe programmer can use to direct the program rewriting and avoid ambiguity, as we discuss below. Our \ncoercion insertion judgment is written S; G fd,d ' e r m : t. Here, S is a set of primitive coercions \nof the form f:t1 . t2, where f is an identi.er with type t1 . t2. Primitive coercions are the building \nblocks used to rewrite source language terms e. The result of coercion insertion is a (type-correct) \ntarget language term m, paired with its type, to which e can be rewritten. Coercions are produced by \na coercion generation judgment, S f t <d t ' r c, a relation that states that a term of type t may be \ncoerced to a term of type t ' by applying coercion term c. An extremely simple de.nition of coercion \ngeneration, which we call Base, is shown in Figure 2. A coercion c is either drawn di\u00adrectly from S (CB-Prim) \nor is the identity coercion idt = .x:t.x (CB-Id). Sections 4, 5, and 6 consider progressively more pow\u00aderful \nde.nitions of coercion generation, where each de.nition of S f t <d t ' r c is distinguished by an index \nd (Base has index b). More powerful de.nitions enable more applications, but com\u00adplicate reasoning about \nambiguity. To tame such problems, we may use different de.nitions of coercion generation when rewriting \npar\u00adticular sub-terms, as we explain below. As such, the coercion in\u00adsertion judgment S; G fd,d ' e r \nm : t is parameterized by two indices, d and d ', to indicate the forms of coercion generation to be \nused. The inference rules for coercion insertion are shown at the mid\u00addle of Figure 1. Rule (T-Var) simply \nproduces the source variable x paired with its type; no coercion is applied. The rule (T-As) re\u00adturns \na rewritten term of the ascribed type t; later we illustrate how ascriptions can be used to locally resolve \nambiguity. (T-Abs) and (T-Pair) simply rewrite the subterms as appropriate. The rules (T-Cast), (T-Proj) \nand (T-App) capture the cases where a source term may have generated coercions inserted to pro\u00adduce a \ntype-correct target term. In contrast to (T-As) which does not insert a coercion, (T-Cast) .rst rewrites \nthe subterm e to a target term m of type t ' and generates a coercion from t ' to the required type t. \nIf the generated coercion is the identity coercion, then we do not bother to insert it (this is captured \nusing the ((\u00b7))\u00b7 notation de.ned at the bottom of the .gure). (T-Proj) rewrites the subterm e to a target \nterm m of type t and inserts a generated coercion from t to a product type t1 \u00d7t2. The (T-App) rule has \nthe same basic form, except that both the functional component e1 and the argument e2 may have coercions \napplied. These rules obey a design pattern: a source term is rewritten so that its type matches that \nrequired by the context in which it appears. If the context imposes no constraint, then no coercion is \ninserted. For example, (T-Var) simply returns x with its given type, rather than rewriting x by inserting \na coercion from x s given type to some other type. Such eager coercion would result in no addi\u00adtional \nexpressive power the only time a coercion is needed for type-correctness is when x appears in an elimination \nposition, as in proji(x) or xe which requires x to have some type t1 \u00d7 t2 or t1 . t2. We expect this \nbasic pattern of inserting coercions at elimination positions should apply to many other standard pro\u00adgramming \nlanguage features, such as references, conditionals, and datatypes with pattern matching. Note that, \nthough not in elimination position, we also allow co\u00adercions to be applied to function arguments. The \nreason is that ap\u00adplying structural coercions, introduced in \u00a75, to function terms may lead to ambiguity. \nHence, we parameterize the coercion insertion judgment with two coercion generation forms, d and d ', \none for function (and pair) terms, one for function arguments. 2.1 Examples Simple coercions. With the \ncoercion set S and environment G de.ned as below, S= ftoi:Float . Int G= f:Int . Int,x:Float we can rewrite \nthe term fx using the Base coercion generation judgment according to S; G fb,b fx r (f (ftoi x)) : Int. \nThis  Types t, s ::= B | t1 . t2 | t1 \u00d7 t2 Primitive coercions S ::= \u00b7| S,f:t1 . t2 Source terms e \n::= x | e:t |(t)e | .x:t.e | e1 e2 | (e1,e2) | proji(e) Typing context G ::= \u00b7| G,x:t Target terms c, \nm ::= x | f | .x:t.m | m1 m2 | (m1,m2) | proji(m) S; G fd,d ' e r m:t Coercion generation def. d, d ' \n::= b (Base) | r (Trans) | s (Struct) | p (PolyTrans) | q (PolyStruct) S; G fd,d ' e r m : t ' S; G fd,d \n' e r m : t S f t ' <d ' t r c T-Var T-As T-Cast S; G fd,d ' x r x : G(x) S;G fd,d ' e:t r m : t S; G \nfd,d ' (t)e r ((c))m : t S; G fd,d ' e1 r m1 : t1 S; G,x:t fd,d ' e r m : t ' S; G fd,d ' e2 r m2 : t2 \nT-Abs T-Pair S; G fd,d ' .x:t.e r .x:t.m : t . t ' S; G fd,d ' (e1,e2) r (m1,m2): t1 \u00d7 t2 S; G fd,d ' \ne r m : t S; G fd,d ' e1 r m1 : t1 S f t1 <d t1 ' . t2 ' r c S f t <d t1 \u00d7 t2 r c S; G fd,d ' e2 r m2 \n: t2 S f t2 <d ' t ' 1 r c ' T-Proj T-App S; G fd,d ' proji(e) r proji(((c))m): ti S; G fd,d ' e1 e2 \nr (((c))m1)(((c ' ))m2): t2 ' ((c))m = m if c = idt (cm) otherwise Figure 1. Type-directed coercion insertion \nfor the simply-typed lambda calculus judgment states that applying f to x can be made type correct by \nleaving f alone and rewriting the argument x to be ftoi x. In fact, this is the only possible type-correct \nrewriting for this program. Overloading. Luo [2008] has shown that coercions can be used to implement \nsimple forms of overloading. Suppose we extend the S and G from above as follows: S ' = ptof :P . Float \n. Float . Float, ptoi:P . Int . Int . Int, S G ' = plus:P, G Here, G ' includes a binary operator plus:P, \nwhere P is some dis\u00adtinguished base type, and the coercion set S ' includes two coer\u00adcions that allow \nplus to be applied both to a pair of Floats as well as a pair of Ints. We can prove S ' ;G ' fb,b plus \nxx r ((ptof plus) xx): Float. This is perhaps the expected re\u00adsult, but is not the only possibility another \npossible rewriting is ((ptoi plus)(ftoi x)(ftoi x)) : Int. It is not hard to see that each rewritten \nterm has a different type, so the ambiguity can be re\u00adsolved via a type ascription: source term (plus \nxx):Float would produce the .rst and (plus xx):Int would produce the second. Note that (ftoi ((ptof plus) \nxx)) : Int is not a possible rewriting. As mentioned previously, this is because applying a co\u00adercion \nto the application itself has no impact on the type correctness of the rewritten term; i.e., (ptof plus) \nxx is already type-correct. The programmer could force this result using a type cast in the source term, \nwriting it (Int)(plus xx).1  2.2 Type correctness The goal of type-directed coercion insertion is to \nproduce only type-correct target terms m that can be formed by rewriting a source term e. Additionally, \nwe want to show that every well\u00adtyped source program e is also well-typed according to our coercion insertion \njudgment. We formalize these statements as follows, and 1 Note that there are two rewritings for this \nterm: (ftoi ((ptof plus) xx)) : Int and ((ptoi plus)(ftoi x)(ftoi x)) : Int. A type ascription can be \nused in the source term to further constrain the rewriting, i.e. (Int)((pl us x x):Float) rewrites to \n(ftoi ((ptof plus) x x)) : Int. f :t . t ' . S CB-Prim CB-Id S f t <b t ' r f S f t <b t r idt Figure \n2. Basic coercion generation (Base) prove them for each coercion generation de.nition d developed subsequently: \n2 Theorem 1 (Soundness). .S, G, e, m, t, d, d ' .S; G fd,d ' e r m : t . S, G f m : t. Theorem 2 (Suf.ciency). \n.S, G, e, t, d, d ' .G f e : t . S; G fd,d ' e r e : t. These propositions presume a standard type-checking \njudgment G f m : t on source and target terms. The context used to check the term m in the .rst judgment \nis S, G, the concatenation of the original primitive coercion list S and the original typing context \nG. The second proposition claims that when a source term e is typable, one possible rewriting of coercion \ninsertion judgment includes the unmodi.ed e. 3. Non-ambiguity We would like to ensure that rewriting \nis unambiguous there should be a single meaning attributable to e. We do this syntacti\u00adcally. Speci.cally, \nwe state that a derivation is unambiguous when it produces at most one type-correct rewriting. De.nition \n3 (Non-ambiguity). Given S, G, d, d ' , a term e can be unambiguously rewritten if there exists a unique \nm, t such that S; G fd,d ' e r m : t. Our .rst example in \u00a72.1 is unambiguous by this de.nition, while \nthe second example is not. 2 The proofs of all theorems for the fragment of our system in which d, d \n' .{b, r, s} are available as Coq proof scripts at http://research. microsoft.com/~nswamy/papers/coercion-proofs.tgz. \nProofs of theorems for our polymorphic system can be found in a companion techni\u00adcal report [Swamy et \nal. 2009].  A syntactic notion of ambiguity has the bene.t that we need not reason about the semantics \nof coercions, which is particularly useful in the presence of side effects. For example, suppose our \nftoi coercion can sometimes fail, e.g., if its argument is NaN. Given the type-incorrect source term \nlet y =(.z:Int.NaN)0 in (e; 1+ y) we could rewrite it to apply ftoi to either NaN within the body of \nthe lambda term, or to y in the .nal expression 1+ y. If e contains side effects, then the semantics \nof the two rewritten programs will be visibly different the call to ftoi will fail prior to the execution \nof e in the .rst case, but after it in the second. Our system avoids this potential problem by preferring \na single rewriting, and in this case produces only the second. 3.1 Strong non-ambiguity De.nition 3 considers \nnon-ambiguity for a single term. We are also interested in non-ambiguity at the level of the rewriting \nsystem itself, i.e., for all terms. We refer to this property as strong non\u00adambiguity. De.nition 4 (SNA(S, \nd, d ' ): Strong non-ambiguity). .G, e, m1,t1,m2,t2. S; G fd,d ' e r m1 : t1 . S; G fd,d ' e r m2 : t2 \n . (m1 = m2 . t1 = t2) Strong non-ambiguity depends on the particular forms of co\u00adercion generation and \nthe set of primitive coercions S for some de.nitions of coercion generation, and some S, coercion insertion \nwill be strongly unambiguous, but for others it will not. For the second example in \u00a72.1, Base coercion \ngeneration (Figure 2) used with the given S ' causes coercion insertion to not be strongly un\u00adambiguous, \nevidenced by the fact that our example term plus xx has two possible rewritings. On the other hand, it \nturns out that with the S from the .rst example, Base is strongly unambiguous: there is no possibility \nof producing multiple rewritings for any program under S= ftoi:Float . Int.  3.2 Establishing strong \nnon-ambiguity Strong non-ambiguity is a property of the program rewriting sys\u00adtem, but we can prove that \nit can be characterized by three con\u00adstraints (NACp, NAC\u00d7, and NACapp) on the coercion generation judgment, \nfor a given S. The most obvious constraint is that coercion generation must be a partial function from \npairs of types to coercions given some S, coercion generation should produce at most one term c that \ncoerces values between given source and target types t and t ' . In later sections, we show how this \nconstraint can be decided by viewing a coercion term as a path in a graph. We can formalize this requirement \nas follows: De.nition 5 (NACp(d, S): unique coercion paths). ''' ''' .t,t ,c,c . S f t <d t r c . S f \nt <d t r c . c = c To guarantee strong non-ambiguity, we require two further con\u00adstraints that arise \nfrom the way terms are rewritten by the coercion insertion judgment. First, when rewriting a term proji(e) \nusing the (T-Proj) rule, if there is more than one product type to which to coerce e, the rewriting could \nbe ambiguous. For example, it could be that S f t<d t1 \u00d7t2 r c and S f t <d t1 ' \u00d7t2 ' r c ', and as \nsuch (assuming e has type t), we could rewrite proji(e) to both proji(ce):ti and proji(c ' e):ti' . Thus \nwe must require that any type t can be coerced to at most one product type t1 \u00d7 t2 we formalize this \ncondition as follows: Coercion paths p ::= {t1,...,tk} CC-Id S fp t <r t r idt f:t . t '' . S S fpl{t \n'' }'' ' t <r t r c CC-PrimTrans S fp ' t <r t r c . f S f{t} t <r t ' r c CC-InitPath S f t <r t ' r \nc Figure 3. Transitive composition of coercions (Trans) De.nition 6 (NAC\u00d7(d, S): unique coercion to a \nproduct type). '' ' .t, t1,t2,t 1,t 2,c,c . '' ' S f t <d (t1 \u00d7 t2) r c . S f t <d (t1 \u00d7 t2) r c . t1 \n= t1 ' . t2 = t2 ' A similar situation arises when rewriting a term e1 e2 using the (T-App) rule. Assume \nthat e1 is rewritten to a term of type t1 and e2 is rewritten to a term of type t2. To preserve strong \nnon-ambiguity there must be only one way to coerce the type t1 to a function type t ' . t '' (where t2 \ncan be coerced to t '). This property is de.ned as follows: De.nition 7 (NACapp(d, d ' , S): unambiguous \napplications). .t1,t2,t3,t4,t5,t6,c1,c2,c3,c4. S f t1 <d (t3 . t5) r c1 . S f t2 <d ' t3 r c3 . S f t1 \n<d (t4 . t6) r c2 . S f t2 <d ' t4 r c4 . (t3 = t4 . t5 = t6) The theorem below establishes that these \nthree conditions are both necessary and suf.cient for strong non-ambiguity. Theorem 8 (Strong non-ambiguity). \n.S, d, d ' .SNA(S, d, d ' ) . NACp(d, S) . NACp(d ' , S) . NAC\u00d7(d, S) . NACapp(d, d ' , S) Additional \nconditions similar to these may be needed to handle other language features. For example, a condition \nanalogous to NACapp would be needed to handle assignments to references e1 := e2. On the other hand, \nno additional condition is needed to support conditionals; NACp is suf.cient. It is easy to check that \nour overloading example S= ptof :P . Float . Float . Float, ptoi:P . Int . Int . Int is strongly unambiguous. \nHowever, if the coercion ftoi:Float . Int is included in S then NACapp(b, b, S) no longer holds, so ambigu\u00adous \nderivations become possible, as we have seen. In subsequent sections we present algorithms that either \nprecisely decide or ap\u00adproximate these NAC constraints for particular coercion generation de.nitions. \n4. Composing primitive coercions We can increase the number of rewritable programs by increas\u00ading the \npower of the coercion generation judgment. However, as expressive power increases so, too, does the likelihood \nof am\u00adbiguous rewritings. In this and the next two sections we de.ne more powerful coercion generation \njudgments that can generate compound coercions. In this section we consider Trans, which may generate \ncompound coercions by transitive composition (e.g., S f t1 <d t3 r c via c1 : t1 . t2 and c2 : t2 . t3); \nin \u00a75 we consider Struct, which extends Trans to generate com\u00adpound coercions component-wise, according \nto type structure (e.g., '' '' S f t1 \u00d7t2 <d t1 \u00d7t2 r c via c1 : t1 . t1 and c2 : t2 . t2); and in \u00a76 \nwe consider PolyTrans and PolyStruct, which extend Trans and Struct, respectively, to support primitive \ncoercions with poly\u00admorphic types. In each section we explore substantial applications enabled by this \nadded power, and consider conditions that are suf\u00ad.cient to ensure strong non-ambiguity.  4.1 Generating \ncomposite coercions A natural extension to the Base judgment is to allow the sequential composition of \nprimitive coercions. We call this extended relation Trans; its rules are given in Figure 3. Coercion \nterms c consist of the identity coercion idt and/or the composition of some number of primitive coercions, \nwritten c . f (equivalent to .x.c (fx)). Coercion generation S f t <r t ' r c is given by a single top\u00adlevel \nrule (CC-InitPath), which in turn appeals to the judgment S fp ' t <r t r c, whose de.nition is rather \nstraightforward. (We discuss the parameter p shortly.) While the idea of generating composite coercions \nappears a simple extension, it adds potential for some subtle ambiguities. The rules in Figure 3 are \ndesigned to prevent two forms of ambiguity that we call syntactic ambiguity (SA) and cyclical ambiguity \n(CA). Fortunately, both can be avoided with no loss to expressive power. Syntactic ambiguity would arise \nfrom having a general rule of transitivity instead of embedding it as in rule (CC-PrimTrans). For example, \nsuppose we have S= f:A . B, g:B . C. Then to coerce A to C, Trans offers one possibility: S f A <r C \nr (idC . g) . f. However if we had extended Base with a general rule of transitivity: ' '''' S f t <b \nt r c S f t <b t r c Strawman-Trans S f t <b t '' r c ' . c then we would be able to generate many different \ncoercions: S f A <b C r (idC . g) . f, S f A <b C r idc . (g . f), S f A<b C r (idc .(idc .g)).f, S f \nA<b C r (idc .g).(idb .f), etc. While each of these coercions is semantically equivalent, and we could \nendeavor to prove that this is the case, we .nd it cleaner to force syntactic and semantic ambiguity \nto correspond, and then focus on eliminating the former. To this end, our rules force a left\u00adassociative \ncomposition of coercions, with exactly one application of the identity coercion at the end.3 As an example \nof cyclical ambiguity consider the coercion set S= f:A . B, b:B . A. Then in our strawman judgment we \ncan prove both S f A <b A r idA and S f A<b A r b.f (and S f A <b A r b .f .b . f, ad in.nitum). Clearly \nS is the source of the problem, as it contains coercions that can be composed in cycles. However, we \ncannot simply rule out S such as this one, since doing so would rule out useful applications (we give \nan example in \u00a74.3). Instead, we disallow cyclic compositions by using a path parameter p, which records \nthe domain type of each primitive coercion composed in sequence; rule (CC-InitPath) initializes the path \nwith the original source type t. The (CC-PrimTrans) rule adds the intermediate type t '' to the path \nif it is not already present, since addition is via the disjoint union operator l. Thus no composed coercion \never visits the same type twice. 4.2 Strong non-ambiguity To use the Trans relation to rewrite terms, \nwe write our coercion insertion judgment as S; G fr,r e r m : t. In order for rewriting to be strongly \nunambiguous, we need to check the NAC constraints of \u00a73.2. One natural way to do so is to view S as a \ngraph on types. De.nition 9 (Coercion Graph). A coercion set S induces a coer\u00adcion graph GS =(V, E), \nwhere (t, t ' ) . E iff .f. S(f)= t . t ' 3 We could use a device similar to ((c))m from Figure 1 to \neliminate the trailing idt. S= conX :X . Int, absX :Int . X, conY :Y . X, absY :X . Y G= y:Y, f:X . X \n. X S; G fr,r fy 1 r f (idX .conY y)(idX .absX 1) :X Figure 4. Proteus Abs/con example derivation ' and \nV = {t, t ' }. We write Reachable(S, t, t ) when\u00ad (t,t ' ).E ever a (possibly empty) sequence of edges \nfrom t leads to t ' in GS. NACp(r, S) holds iff a depth-.rst search started from each node in the graph \nproduces no cross or forward edges. Such edges indicate two potential paths, and thus two possible compositions \nof primitive coercions, from the source node s type to the type of the forward or cross edge s target \nnode. Back edges are not problematic they indicate the potential for cycles, which are ruled out by the \njudgment s p parameter. NAC\u00d7(r, S) can be decided by constructing the set Pt = {t1 \u00d7 t2 | Reachable(S, \nt, t1 \u00d7 t2)}, for every node s type t in GS, and checking |Pt|= 1. To decide NACapp (r, r, S), we compute \nthe set At = {t2 |.t1,t ' .Reachable(S, t, t1 . t2) . Reachable(S,t ' ,t1)}, for each node type t . GS, \nand check |At|= 1. The construction of At and Pt can be interleaved with the depth-.rst traversals of \nGS. Thus, the complexity of deciding strong non-ambiguity for the Trans judgment is O(n 2) where n = \n|S|.  4.3 Application: Proteus abs/con insertion An interesting example of the program rewriting enabled \nby Trans arises from dynamic software updating (DSU). DSU is a technique by which a running program can \nbe updated with new code and data without interrupting its execution. A core problem in DSU arises from \ntiming; particular updates are legal only at certain times. In prior work [Stoyle et al. 2007] we de.ned \na language Proteus which supported type equations for named types, e.g., typename X = t where t is the \nde.nition of X (and may itself be, or contain, abstract type names). A named type s de.nition can be \nupdated on-the-.y provided that no actively running function references the old representation. Proteus \nemploys an explicit coer\u00adcion conX to witness the use of a value of type X as one of type t, while coercion \nabsX witnesses the reverse. An update to type X is permitted so long as the text of actively running \nfunctions contains no mention of absX or conX coercions. As such explicit coercions are rather cumbersome, \nProteus sup\u00adports a custom algorithm that takes a source program with (abstract) type equations and automatically \ninserts the needed coercions. This coercion insertion algorithm can be expressed precisely using our \ncoercion insertion framework. An example is shown in Figure 4. We can show that the algorithm is strongly \nunambiguous, by the proposition below. Proposition 10 (Abs/con strongly unambiguous). Assuming a set \n of base types X1,X2, ...Xn, let S= {conXi :Xi . 1=i=nti, absXi :ti . Xi}. Then SNA(r, r, S). Equality \ncoercions like abs/con are also useful in type-preserving compilation, inserted as proofs of term equality \nin the typed in\u00adtermediate language [Sulzmann et al. 2007]. We conjecture our system could be used in \nthis setting as well. 5. Structural coercions This section presents Struct, a coercion generation de.nition \nthat extends Trans to also produce lifted coercions over function and product type constructors; we call \nsuch synthesized coercions structural coercions. For example, given coercions f:t1 . s1 and g:t2 . s2, \nStruct can generate coercions from t1 \u00d7 t2 to s1 \u00d7 s2 and from s1 . t2 to t1 . s2. Struct adds further \nsources of potential ambiguity, and we employ several devices to eliminate them without unduly compromising \nexpressiveness we show that Struct is expressive enough to represent a canonical form of coer\u00adcive subtyping. \nFurthermore, we de.ne ef.ciently decidable, suf\u00ad.cient conditions for proving strong non-ambiguity. This \nsection concludes with examples that use structural coercions to encode forms of dynamic and gradual \ntyping [Henglein 1994, Siek and Taha 2006].  5.1 Coercion generation The de.nition of Struct in Figure \n5 begins with a top-level rule (CS-Init), which initializes two indices a and p for controlling am\u00adbiguity. \nAfter .rst explaining the general structure of the remaining rules we consider these ambiguity controls \nin detail. The (CS-Id) and (CS-PrimTrans) rules are analogous to the versions of these rules in Figure \n3. (CS-Id) generates the identity coercion for a type t, while (CS-PrimTrans) allows a primitive coercion \nf to be composed transitively with some (potentially complex) coercion c generated in the second premise. \nThe (CS-FunTrans) rule constructs a coercion from a function type t1 . t2 to some target type t ' by \n.rst assembling a coercion to another function type t ' 1 . t2' , and then composing it with a coercion \nfrom t1 ' . t2 ' to t '. As in structural subtyping, coercion generation on functions is contravariant \nin the argument and covari\u00adant in the return type. So, in the .rst premise of (CS-FunTrans), we construct \na coercion c1 from t1 ' to t1, and, in the second premise, a coercion c2 from t2 to t2' . The third premise \nde.nes a term c that, when applied to a function f of type t1 . t2, will coerce it to type t1 ' . t2 \n' by waiting until f is eventually applied and, at that point, applying the coercions c1 and c2 to the \narguments and return value of f , respectively. Note that both c1 and c2 are constructed by making use \nof the Struct relation. This allows us to use the structural rules to an arbitrary depth when coercing \nhigher\u00adorder function types; e.g., with the appropriate coercion set S, (CS-FunTrans) allows us to generate \ncoercions between types of the '' ' form (t1 . t2) . t3 <s (t1 . t2) . t3. The rule (CS-PairTrans) is \nsimilar to (CS-FunTrans) and pro\u00advides structural coercions for product types. The coercions c1 and c2 \nare covariant on each component of the product type again, these may themselves make use of the structural \nrules in order to construct coercions between nested products.  5.2 Eliminating cyclical and syntactic \nambiguity The Trans judgment was formulated to remove possible syntactic and cyclical ambiguities. Both \nforms of ambiguity are also present in the Struct relation and we employ similar devices to eliminate \nthem. For cyclical ambiguity, the judgment is indexed by a path p that is initialized in (CS-Init), and, \njust as before, every rule (except (CS-Id)) checks and augments p. To avoid syntactic ambiguity, the \nassociativity of coercion com\u00adposition is normalized in (CS-PrimTrans) as in Trans, and the same device \nis applied by (CS-FunTrans) and (CS-PairTrans) since these rules also employ transitivity. Struct employs \nan additional index a on the turnstile to elimi\u00adnate a form of syntactic ambiguity new to Struct. Without \nrestric\u00adtion it is possible to construct multiple coercions between the same constructed types by using \ndifferent interleavings of structural co\u00adercion rules and transitivity. As an illustration, consider \nhow we could coerce a product type t1 \u00d7 t2 to another product type s1 \u00d7 s2 using (CS-PairTrans) with \nS= f:t1 . s1,g:t2 . s2: S f t1 <s s1 r f S f t2 <s s2 r g c = .x:t1 \u00d7 t2.(f proj1(x),g proj2(x)) pl{s1\u00d7s2} \nS fe s1 \u00d7 s2 <s s1 \u00d7 s2 r ids1\u00d7s2 CS-PairTrans S fp . t1 \u00d7 t2 <s s1 \u00d7 s2 r ids1\u00d7s2 . c Without the a \nindex to prevent us, we could also construct the coercion thus: S f t1 <s t1 r idt1 S f t2 <s s2 r g \nc = .x:t1 \u00d7 t2.(proj1(x),g proj2(x)) S fpl{t1\u00d7s2}' t1 \u00d7 s2 <s s1 \u00d7 s2 r c c ' = ids1\u00d7s2 . (.x:t1 \u00d7 s2.(f \nproj1(x), proj2(x))) (2) S fp t1 \u00d7 t2 <s s1 \u00d7 s2 r c ' . c Here, c ' is produced by another application \nof (CS-PairTrans). If f and g were effectful (suppose each printed a message) and we assume left-to-right \nevaluation order, then the .rst case, when the constructed coercion is evaluated f would print its message \n.rst, then g, while in the second case, g would print .rst, then f. To avoid this issue, we observe that \nin many circumstances (characterized precisely by Theorem 11, below), if we can prove S f t<s t ' r c \nby applying structural rules (CS-PairTrans) and/or (CS-FunTrans) in succession, as in the second case \nabove, we can also prove S f t <s t ' r c ' via a derivation that uses a single structural rule followed \nby a non-structural rule, as in the .rst case. Therefore, we augment Struct s rules with an index a to \nprevent structural rules from being used in succession. In particular, in the conclusion of (CS-PairTrans) \nand (CS-FunTrans) we require the index a = .; in the last premise of these rules, we require the index \na = e. For our example above, this device forces the .rst rewriting. Non-structural rules may still occur \nin succession; (CS-PrimTrans) places no limit on the index of its second premise. There is one .nal source \nof syntactic ambiguity which arises because the rules in Figure 1 permit inserting coercions on both \nthe left and right-hand-side of applications. To illustrate, suppose we have S= ftoi : Float . Int and \nG= f:Int . Int,x:Float. Then the term (fx) can be rewritten to (f (ftoi x)) and to ((.g:Int . Int..y:Float.g \n(ftoi y)) f) x). The choice depends on whether we rewrite the left-hand or right-hand-side of the ap\u00adplication. \nIn general, if we can rewrite a function s argument, as in the former case, we could have rewritten the \nfunction using (CS-FunTrans), as in the latter case. To avoid this syntactic ambiguity, we may use the \nStruct rules on either the left-or right-hand-side of an application, but not both. We choose to use \nStruct only on the right-hand-side because applying it on the left-hand-side would create another problem. \nIn particular, for some S the Struct rules can coerce a type t to in.nitely many function types, all \nwith the same domain type t ' . For example, with S= f:t . (t ' . t), we can construct ' '' ''' t <s \n(t . t), t <s (t . (t . t), t <s (t . (t . (t . t))), etc. A similar problem can arise when rewriting \na term proji(x) for certain S, there may be an in.nite number of product types to which a given type \ncan be coerced. To control the choice of coercion generation during rewriting, we parameterize the rewriting \njudgment by two indices d and d ' , writing it S; G fd,d ' e r m : t. Following the reasoning outlined \nabove, we use the judgment S fr,s e ' r m : t, which indicates that Trans is used to rewrite terms e \nthat appear within a projection or on the left-hand-side of function applications, while Struct is used \nto rewrite terms on the right-hand-side of function applications. Consider an application ee ' where \nthe subterm e is rewritten to a term of type t and e ' is rewritten to type t '. By restricting to the \nuse of Trans, there are .nitely many function types that t can be coerced to. It is then decidable to \nuse Struct to generate a coercion from t ' to the domain of each function type.  Index on turnstile \n(alternation of structural rules) a ::= e | . CS-Init S f{t}. t <s t ' r c S f t <s t ' r c CS-Id S fp \na t <s t r id CS-PrimTrans f:t . t1 . S S fpl{t1}a ' t1 <s t ' r c S fp a t <s t ' r c . f CS-FunTrans \nS f t ' 1 <s t1 r c1 S f t2 <s t ' 2 r c2 c = .f:t1 . t2.(.x:t ' 1.c2 (f (c1 x))) S f pl{t ' 1.t ' 2}e \nt ' 1 . t ' 2 <s t ' r c ' S fp . t1 . t2 <s t ' r c ' . c CS-PairTrans S f t1 <s t ' 1 r c1 S f t2 <s \nt ' 2 r c2 c = .x:t1 \u00d7 t2.(c1 proj1(x), c2 proj2(x)) S f pl{t ' 1\u00d7t ' 2}e t ' 1 \u00d7 t ' 2 <s t ' r c ' \nS fp . t1 \u00d7 t2 <s t ' r c ' . c Figure 5. Generating structural coercions (Struct) 5.3 Expressiveness \nWhile the additional devices outlined above eliminate problematic ambiguities for Struct, we may be concerned \nthat they also unduly reduce its expressiveness. The theorem below establishes that this is not the case \nin many common situations. We compare our system to a standard declarative formulation of subtyping for \nthe lambda calculus, in which subtyping can be applied to any term, and uses of transitivity are unrestricted. \nThe rules are essentially standard, and we elide them. To simplify the proof, we write this judgment \nS; G f e : t, where each coercion f:t . t ' . S is read as a subtyping relation t<: t ' between base \ntypes; typically subtyping between base types would be expressed as distinct rules. As is usual with \nsubtyping systems, we do not consider base subtyping relations between structured types. Thus, for this \ntheorem, we do not permit primitive coercions of the form f :(t1 . t2) . t ' . S and denote this constraint \non S as BaseCoercions(S). Theorem 11 (Expressiveness of structural coercions). .S, G, e, t. BaseCoercions(S) \n. S; G f e : t . .m, t ' , c. S; G fr,s e r m:t ' . S f t ' <s t r c This theorem establishes that our \ncoercion insertion system is at least as expressive as a system that provides a standard form of structural \nsubtyping. One interesting point to note is that our coer\u00adcion insertion system produces a term typable \nat t ' ,a subtype of the type t produced by the subtyping system. This is an artifact of the restriction \nin our system that inserts coercions only in elimination forms. Of course, a top-level coercion cast \ncan always be used to produce a term of the desired super-type of t ' .  5.4 Strong non-ambiguity Proving \nstrong non-ambiguity for the coercion insertion judg\u00adment S; G fr,s e r m : t requires establishing NAC\u00d7(r, \nS), NACapp(r, s, S), NACp(r, S), and NACp(s, S) de.ned in \u00a73. It turns out to be particularly dif.cult \nto decide NACp(s, S) for arbi\u00adtrary S. One dif.culty (as mentioned in \u00a75.2) is that using the Struct \nrelation, one can coerce a type t to in.nitely many other types. Fur\u00adthermore, given a coercion set S= \nf1:t1 . t1' ,...,fn:tn . tn' , it is possible to derive a Struct coercion S f t <s t ' r c, where neither \nt nor t ' are among the types ti,t ' i that are mentioned in S. Thus, the simple strategy of enumerating \nall possible coercion paths between types that are mentioned in S, which worked well for Trans (\u00a74.2), \ncannot be applied to Struct. In the remainder of this section, we show how to approximate NACp(s, S) \nby impos\u00ading a slightly stronger constraint on S that is ef.ciently decidable. Our approach is to reduce \nthe problem of deciding NACp(s, S) to deciding a related property of the simpler Trans relation. We begin \nby introducing some convenient notation to describe the structure of a coercion derivation. We write \nS f t <r t1 <s t ' r c when we can decompose a derivation S f t <s t ' r c into a segment S f t <r t1 \nr cr that uses transitive rule (CS\u00ad 1. t ... (Tt1 t2)(Tt ' t ' ) ... t ' <r <r <s 12<r <r \u00ac2.t <r ... \n<r ... <r ... <r ... <r t ' ' t ' \u00ac3.t <r ... <r (Ss1 s2) <s (Ss ' 1 s ) <r ... <r 2 NAC* .. p(s, S) \n''' '' .T,t1,t2,t 1,t 2,t,t ,S,s1,s2,s 1,s 2. S f t <r (Tt1 t2) <s (Tt ' 1 t2' ) <r t ' . S f(Tt1 t2) \n<r (Tt ' 1 t2' ) . '' '' {T,t1,t2,t 1,t 2} = {S, s1,s2,s 1,s 2}. ' '' S ft <r t . S ft <r (Ss1 s2) <s \n(Ss ' 1 s2) <r t Figure 6. NAC* p(s, S): non-redundant subtyping paths PrimTrans), and a segment S f \nt1 <s t ' r cs that uses one of the structural rules (CS-FunTrans) or (CS-PairTrans). We elide the coercion \nterm c when it is unimportant. This notation extends naturally to composition of longer sequences of \ncoercions; e.g., we sometimes write S f t1 <r t2 <s t3 <r t4 etc. Finally, for compactness, we write \nthe application of a binary type constructor Tt1 t2 to stand for either the type t1 \u00d7 t2 or t1 . t2. \nOur reduction of NACp(s, S) relies on the assumption that NAC\u00d7(r, S) holds. Under the constraint NAC\u00d7(r, \nS), the problem of deciding the uniqueness of arbitrary subtyping paths is consid\u00aderably easier. If, \nfor the moment, we focus only on product types, we can decide NACp(s, S) by only considering coercion \nderiva\u00adtions of the form S f t <r t1 \u00d7 t2 <s t1 ' \u00d7 t2 ' <r t '. That is, un\u00adder NAC\u00d7(r, S), the only \nviable coercion generation derivations that use a structural rule begin with a (possibly empty) pre.x \nthat coerces t to (t1 \u00d7 t2) using (CS-PrimTrans); then, a single appli\u00adcation of a structural rule coerces \n(t1 \u00d7 t2) to (t ' 1 \u00d7 t2' ); and, .\u00adnally, a (possibly empty) transitive suf.x coerces the latter type \nto the goal t '. A coercion derivation that is not of this form, such as '' '' S f t <r (t1 \u00d7 t2) <s \n(t1 \u00d7 t2) <r (s1 \u00d7 s2) <s (s1 \u00d7 s2), vi\u00adolates NAC\u00d7(r, S), since it includes a primitive coercion between \ndistinct pair types, i.e., S f t1 ' \u00d7 t2 ' <r s1 \u00d7 s2. Using this insight, we formulate a necessary condition \nfor strong non-ambiguity, NAC* p(s, S), in Figure 6. The grey box at the top of the .gure illustrates \nthe condition on S that we aim to de\u00adcide. On the .rst line, we show a derivation from t to t ' that \nmakes use of the Struct judgment in the form (Tt1 t2) <s (Tt ' 1 t ' 2). Whenever S admits such a derivation, \nfor non-ambiguity, we re\u00adquire that the use of the structural rule in the .rst derivation is essential \nto coercing t to t '. We want to rule out derivations, such as the one shown on line 2, which can coerce \nt to t ' using primi\u00adtive coercions only. Additionally, we require that derivations of the form shown \non line 3 are also not admitted by S, i.e., there must be at most one way to use structural rules to \ncoerce t to t ' .  \u00af S= b:Bool . Dyn, b:Dyn . Bool, i:Int . Dyn, i:Dyn . Int, \u00af\u00af f :(Dyn . Dyn) . Dyn, \nf :Dyn . Dyn . Dyn p:(Dyn \u00d7 Dyn) . Dyn, \u00afp:Dyn . Dyn \u00d7 Dyn S; \u00b7fr,s (.x:Dyn.x)1 r (.x:Dyn.x)(i 1) : Dyn \nS; \u00b7fr,s 1 true r ((\u00aff . i) 1) (b true): Dyn Figure 7. Dynamic typing: coercion set and example derivations \nDeciding NAC* p(s, S) is relatively straightforward. As in \u00a74.2, we construct a coercion graph GS, and \nfor each pair of types t1 and t2 in the graph, we identify the sets of types R1 = {(T tt ' ) | Reachable(GS,t1, \n(T tt ' ))} and R2 = {(Sss ' ) |Reachable(GS, (Sss ' ),t2)}. Next, for each pair of types t, t ' in the \ncartesian product R1 \u00d7 R2, we check that at most one pair is related by the Struct judgment. That is, \nwe construct the set R = {c | S f t <s t ' r c . t, t ' . R1 \u00d7 R2} and check that |R|= 1. If R contains \nmore than one element, then S must violate NAC* is reachable from t in p(s, S). If R is a singleton, \nand if t ' GS, then once again, we have detected a violation of NAC* p(s, S). In a system that includes \nonly product types, it is possible to show that the conditions NAC* p(s, S), NAC\u00d7(r, S), NACp(r, S) and \nNACapp (r, s, S) are both necessary and suf.cient for strong non-ambiguity. A similar property can be \nshown in a setting with only function types. However, when we include both function and product types \nin the same system (or, for that matter, struc\u00adtural coercions for arbitrary type constructors) then \nthe four NAC\u00adconditions above are necessary, but not suf.cient, for strong non\u00adambiguity. The problem \nis that our reduction of coercion deriva\u00adtions to a form that contains a Trans pre.x, a single application \nof a Struct coercion, followed by a Trans suf.x is not valid when both function and product types are \npresent. For example, the derivation '' '' S f t<r (t1 \u00d7t2)<s (t1 \u00d7t2)<r (s1 . s2)<s (s1 . s2) is admis\u00adsible \nsince the primitive coercion S f (t1 ' \u00d7 t2) <r (s1 . s2) does not violate NAC\u00d7(r, S). To remedy this, \nwe propose a strength\u00adening of NAC\u00d7 and NACapp to NACT (r, S), a condition that requires that each type \nt be coercible to at most one type of the form (Tt1 t2). The de.nition below makes this condition precise. \nThe theorem that follows establishes that ef.ciently decidable con\u00additions NAC* p(s, S) and NACT (r, \nS) are a conservative approxi\u00admation of the necessary condition for non-ambiguity, NACp(s, S). De.nition \n12 (NACT (d, S): coercions to a type constructor). .t, T, t1,t2, S, s1,s2, c, c ' . S f t <d (Tt1 t2) \nr c . S f t <d (Ss1 s2) r c ' . T = S . t1 = s1 . t2 = s2 . c = c ' Theorem 13 (Suf.ciency of NAC* p(s, \nS)). .S, G.NACp(r, S) . NACT (r, S) . NAC* p(s, S) . NACp(s, S)  5.5 Application: Dynamic and Gradual \ntyping A typical implementation of the untyped lambda calculus (e.g., for Scheme) tags each class of \nrun-time value, and the interpreter checks for the appropriate tag before the value can be used. For \nexample, the interpreter reduces the application (.x.x)1 after it con.rms the left term .x.x has a function \ntag, but fails to reduce (1 true) when it .nds that 1 has a non-function tag. Henglein [1994] observed \nthat tagging and untagging opera\u00adtions can be made explicit in a typed source language, where a standard \nuntyped term is automatically translated to a typed term prior to evaluating it. The translation can \navoid some redundant tag checks, improving on a na\u00a8ive interpreter that would always implic\u00aditly perform \na check. We can implement this idea directly. The typed language extends a standard typed lambda calculus \nwith the type Dyn for classifying untyped terms, along with a pair of coercions for each type constructor \ntc. The .rst converts a term of type tc(Dyn, ..., Dyn) to Dyn by tagging it with tc. The second converts \nDyn back to tc(Dyn, ..., Dyn) by removing the expected tag tc, but fails if the term has some other tag \ninstead. The S shown in Figure 7 enumerates such coercions: f and \u00aff for the . constructor; p and \u00afp \nfor the \u00d7 constructor; b and \u00afb for the Bool base type (a nullary constructor); and i and \u00afi for the \nInt base type. Given a term in the source language e ::= x | .x:Dyn.e |( e1,e 2) | proji( e), the same \nas our typed language e, but with\u00adout explicit casts or ascriptions and where all bound-variable type \nannotations are Dyn, we perform coercion insertion using S from Figure 7. Derivations for the above examples \nappear at the bot\u00adtom of the .gure (with the trailing ids in the composed coercions elided for perspicuity). \nIt is easy to see that coercion insertion will always succeed, and thus all dynamically-typed terms will \nbe ac\u00adcepted, since S permits any type to be coerced to any other type. It is also worth noting that \nthe translation eliminates some unneces\u00adsary tag checks. For the .rst example, an interpreter would na\u00a8ively \ntag the lambda term and then immediately untag it at the applica\u00adtion, whereas our translation leaves \nthe term alone. We have not proved that our translation optimally eliminates tag checks (pro\u00adducing a \nminimal completion in the terminology of Henglein), but plan to explore this issue in future work. It \nis fairly easy to prove that the S of Figure 7 satis.es NAC\u00d7(r, S), NACapp(r, s, S), NACp(r, S), and \nNACp(s, S), and thus, by Theorem 8, S admits only strongly unambiguous rewritings. However, our choice \nof S here also reveals the impre\u00adcision of our approximation of NACp(s, S) using NACT (r, S) and NAC* \np(s, S). In particular, although we have NACp(s, S), be\u00ad\u00af cause f and p\u00afare both in S, NACT (r, S) does \nnot hold. While it is relatively straightforward to weaken NACT (r, S) to account spe\u00adcially for coercion \nsets that resemble the particular S here, a precise necessary and suf.cient condition for non-ambiguity, \nwhich is still ef.ciently decidable for arbitrary S, remains an open question. Gradual Typing. Siek and \nTaha [2006] introduced gradual typ\u00ading as an approach to allowing programmers to mix dynamic and statically \ntyped code. We can encode Siek and Taha s approach by viewing it as a generalization of the dynamic typing \nproblem just considered. First, we allow source terms to be annotated with types other than Dyn; i.e., \nour source language becomes e ::= x |.x:t.e e1, ( | ( e2) | projie), where t is as in Figure 1 and base \ntypes include Dyn, Int, and Bool, as above. Second, we initialize the p parameter for coercion generation \nto prevent transitive com\u00adpositions of coercions via Dyn. In particular, for Trans we change (CC-InitPath) \nas follows (and make a similar change to (CS-Init) for Struct): t ' = Dyn . p = {t}t ' = Dyn .{t, Dyn}S \nfp t <r t ' r c CC-InitPath S f t <r t ' r c With this change, for Struct we have that for all t, S f \nDyn <s t r c and S f t <s Dyn r c ' for some c, c ', but we do not ''' ' have S f t <s t r c for all \nt , thanks to our initialization of p. As a result, Struct coercion generation matches Siek and Taha \ns type consistency relation, and thus ensures that terms not ascribed a Dyn type receive a useful degree \nof static checking, identifying some type errors and optimizing away some unnecessary coercions. Consider \nonce again our examples from Figure 7. For (1 true), the rewriting hinges on proving S f Int <r Dyn . \nDyn r c, \u00af where c = id . f . i. But S f Int <r Dyn . Dyn r c for our modi.ed de.nition because Dyn in \nthe initial p prevents Open types t ::= a | b | t1 . t2 | t1 \u00d7 t2 HM types s .&#38;  ::= a.t HM Coercions \nS ::= \u00b7| S,f:s | S,f:t Target language c, m ::= ... | f[&#38;t ] Coercion path p ::= {c1,...,cn,t1,...,tk}Substitutions \n. ::= {(a1,t1),..., (an,tn)}Index on relation pq ::= p (PolyTrans) | q (PolyStruct) FV(t1)= a&#38;f.&#38; \na.t1 . t2 f : .&#38;t1 t : . a.t1 . t2 . S pl{t2,f}' t2 = .(t2)S fa ' t2 <pq t r c CPQ-PrimTrans S fpa \nt <pq t ' r c . (f [.(a&#38;)]) Figure 8. Polymorphic coercions (PolyTrans and PolyStruct) \u00af composing \nf and i. Thus we would reject this type-incorrect source term. The second example is the same with either \nde.nition. But if we annotate the bound variable we eliminate the need for the inserted coercion: S; \n\u00b7fr,s (.x:Int.x)1 r (.x:Int.x)1: Int. 6. Polymorphic coercions This section presents the .nal enhancement \nto our coercion gener\u00adation de.nition: the addition of primitive coercions with Hindley-Milner (HM)-style \npolymorphic types. The added expressiveness of HM types means we can program with object proxies e.g., \nthunks and related constructs as described in the Introduction as if they were the underlying objects \nthemselves, and coercions will be inserted as necessary to mediate access. We illustrate the util\u00adity \nof HM coercions by encoding provenance tracking, such that a proxy is used to track the provenance of \nits underlying object. Provenance tracking is particularly important in queries to curated scienti.c \ndatabases [Cheney et al. 2007]. 6.1 Coercion generation We extend both the Trans and Struct coercion \ngeneration de.ni\u00adtions so that primitive coercions in S can have HM polymorphic types .&#38; a.t , where \nopen types t are as types t but may contain (quanti.able) type variables a. We call the extended coercion \ngen\u00aderation de.nitions PolyTrans and PolyStruct. For both systems, co\u00adercion insertion produces target \nterms m that may contain instanti\u00adated coercion applications f[&#38;t ]. The source language e is the \nsim\u00adply typed lambda calculus, as before (Figure 1). Polymorphically typed source language terms create \nsigni.cant complication, so we leave their consideration to future work. The PolyStruct judgment is identical \nto Struct, except for one additional rule, (CPQ-PrimTrans) shown in Figure 8 all the rules in the resulting \njudgment are indexed by q. PolyTrans is de.ned likewise as an extension to Trans, using index p.4 Rule \n(CPQ-PrimTrans) has three differences from (CS-PrimTrans). First, to use a polymorphic coercion with \ntype .&#38;1' , the second premise a.t1 . t requires that t, the source type of the coercion, is uni.able \nwith t1 according to substitution .. Next, the third premise applies . to t2 to produce closed type t2 \nwhich is then used in the fourth premise to, as before, transitively produce a coercion to the target \ntype t ', adding t2 to the path p. That t2 is closed implies dom(.) . FV (t2); to ensure this is always \nthe case, polymorphic types s in rng(S) must satisfy the condition f s, which requires all bound 4 Technically, \nthe version of (CPQ-PrimTrans) for PolyTrans is written ' S fp t <p t ' . c; the indices a and a that \nsubscript the turnstile in the rule de.nition in Figure 8 are dropped. type variables occur in the domain \nof a polymorphic coercion. The alternative of allowing .(t2) to contain free type variables adds signi.cant \ncomplication to the rules, while the f s restriction is satis.ed by most applications we have considered. \nFinally, notice in the last premise we also add f to the path p; we explain why below. PolyStruct has \nthe same problem as Struct in that for some S it could be used to generate an in.nite number of function \nor product type coercions from a given source type (Section 5.2). To avoid this problem, as before, we \ncan limit the use of PolyStruct to the right-hand side of a function application, i.e., by only considering \na coercion insertion judgment of the form S fp,q e r m : t (or S fp,p e r m : t, but not S fq,q e r m \n: t). Interestingly, notice that without adding f to p in the fourth premise of (CPQ-PrimTrans), it is \nalso possible for PolyTrans to generate an in.nite number of product and function coercions. For example, \nwith f : .a.a . (a \u00d7 a), we can generate S f Int <p Int \u00d7 Int r f[Int], and S f Int <p (Int \u00d7 Int) \u00d7 \n(Int \u00d7 Int) r (f[Int \u00d7 Int]) . (f[Int]), and so on. Adding f to p ensures that in a transitively generated \ncoercion chain c1 .....f[&#38;t].....cn, no c . c1 ...cn will be f[t&#38;' ]. Note that f may still appear \nin structural coercions used to construct some ci within the chain, since p is reset when generating \ncoercions for the component types. Eliminating this restriction, should doing so become necessary, remains \nfuture work. Example: Dynamic proxies. Polymorphic coercions are use\u00adful for implementing dynamic proxies, \nsuch as thunks (for lazy evaluation) and futures (for parallel evaluation) [Pratikakis et al. 2004]. \nCoercions for thunks can be de.ned as follows: S= lazy:.a.(Unit . a) . Lazy a, force:.a.Lazy a . a. The \nlazy coercion injects a thunk Unit . a into a Lazy a, while force converts a Lazy a to a a by evaluating \nit. Thus we have S; \u00b7f (.y:Lazy Int.y +1) (.x:Unit.e) r (.y:Lazy Int.(force[Int] y)+1) (lazy .x:Unit.e): \nInt Notice that the programmer must indicate the expression e to eval\u00aduate lazily by thunkifying it manually. \nWe could imagine instead using something like OCaml s lazy e annotation from which a syn\u00adtax manipulation \ntool like camlp4 would perform the thunki.cation and insert the lazy coercion. Coercion insertion complements \nsuch an approach, since a tool like camlp4 cannot automatically insert calls to force since doing so \nprecisely requires type information.  6.2 Strong non-ambiguity Each of the necessary and suf.cient strong \nnon-ambiguity con\u00adstraints presented in Section 3 also apply to rewritings that make use of polymorphic \ncoercions. Developing an ef.cient algorithm for deciding these conditions is an open problem. Here we \ndiscuss some of the dif.culties presented by this problem. To decide NACp(p, S), we need to detect when \ntwo coer\u00adcions in S overlap. Consider, for example, a set S that contains f:.a.a . (a \u00d7 Int), g:Int . \n(Int \u00d7 Int), and h:.a.a . (Int \u00d7 a). This set is ambiguous since the type of g is an instance of the \ntype of f. However, simply removing g from S does not eliminate the ambiguity, since, although neither \nf nor h is an in\u00adstance of the other, there are still two ways to coerce an Int to a pair (Int \u00d7Int). \nWhen the structural rules of PolyStruct are added, the problem is harder still. Deciding NAC\u00d7(p, S) (and \nalso NACapp(p, q, S)) is also chal\u00adlenging. For example, f, above, provides a way to coerce one prod\u00aduct \ntype to another, i.e., S f (Int \u00d7Int)<p ((Int \u00d7Int)\u00d7Int) r f[Int \u00d7Int]. To detect a violation of NAC\u00d7, \none must .nd instanti\u00adations of coercions type variables that enable coercion paths from a type t to \ndistinct product types. While the offending instantiation  enzymes pid name mw prov 1 .avodoxin 19.7 \nPLib1 2 ferrodoxin 12.3 PLib2 . . . . . . . . . . . . xrefs rid pid 1 1 1 2 . . . . . .  reactions \nrid name prov 1 G(1) Lab1 2 R(8) Lab2 . . . . . . . . . Query: Sum of enzyme weights in each reaction \nReaction name Sum weights name name prov weight weight prov G(1) R(8) . . . Lab1 Lab2 . . . 19.7 + 12.3 \n. . . . . . PLib1, PLib2 . . . . . . Figure 9. A query on a database of biochemical reactions for a \nin our example is relatively easy to .nd, we have not devel\u00adoped a general decision procedure for this \npurpose. Despite the lack of an algorithm for deciding SNA(p, q, S), with only a little guidance from \nthe programmer even ambiguous sets of polymorphic coercions can be put to good use. The next ex\u00adample \nillustrates how a form of dynamic information .ow tracking can be encoded as an instance of polymorphic \ncoercion insertion. Through the careful placement of a few type ascriptions, a pro\u00adgrammer can direct \nthe coercion insertion process to ensure that the program is always unambiguously rewritten.  6.3 Application: \nProvenance tracking Cheney et al. [2007] have developed a semantics for tracking prove\u00adnance in database \nqueries, an application that is useful for both se\u00adcurity and reliability. In this section, we borrow \none of their ex\u00adamples and show how we can automatically rewrite queries with coercions that do the provenance \ntracking. Figure 9 illustrates a database of biochemical records over which we wish to run queries and \nFigure 10 shows how we model this scenario. The database contains three tables: enzymes, reactions and \nxrefs. We represent each table as a list of tuples, and the typing environment at the top of Figure 10 \nbinds variables for each of the tables.5 The enzymes table has three main columns: a primary key pid, \nthe name of the protein in the enzyme, and the molecular weight mw of that protein. A .nal column, prov, \nrecords the provenance of the information in each row, e.g., the .rst row in the enzymes table was obtained \nfrom the protein library PLib1 . Our encoding of this table in Figure 10 gives enzymes the type List \n(Prov protein). The type abbreviation protein expands to a tuple with three .elds, matching the .rst \nthree columns of the table. The whole row is given type Prov protein our encoding represents a t-typed \nvalue that is tagged with provenance metadata using the type Prov t. We leave the representation of the \nprovenance metadata unspeci.ed; here we think of it as a String. The second table records a collection \nof biochemical reactions with a primary key rid and the name of the reaction. As with the enzymes table, \neach row in reactions is tagged with its prove\u00adnance, say, the name of the laboratory that provided this \ninforma\u00adtion. In Figure 10, we represent this table using a value of type List Prov(Int \u00d7String). A .nal \ntable, xrefs, cross-references the reactions and enzymes tables, indicating all the proteins involved \nin a particular reaction. Our goal is to run a query that, for each reaction, computes a result that \npairs the name of the reaction with the sum of the molecular weights of all the proteins that are used \nin that reaction. Of course, this query must also track provenance. So, as shown 5 For this example, \nwe assume that base types also include type constructor applications like List t and Prov t. We do not \nassume the presence of any structural rules that allow coercions to be lifted into these types. in Figure \n9, the query result includes a row that pairs the reaction name G(1) with the name of the laboratory \nLab1 ; and the sum 19.7 + 12.3 paired with Plib1, PLib2 , to indicate that the result involved data from \nboth these sources. Our coercion insertion approach allows a programmer to focus solely on the core query \nsemantics, without worrying about insert\u00ading coercions to track provenance. Programmers need only specify \nsimple general purpose combinators for provenance tracking and our system can automatically retro-.t \na query with provenance\u00adtracking semantics. For example, a value of type Prov t can be used by the programmer \nat type t, and our system will insert the appropriate coercion. We .rst describe the structure of the \nsource query (at the bottom-left of Figure 10) and then discuss the speci.c coercions that we use to \nrewrite the program. Our example uses the convenience of let-bindings, but we are careful to annotate \nall .-bindings with their types. We also make use of if-expressions. A translation from this extended \nsyntax to our core calculus is straightforward. We write our query as a function over a single row in \nthe reac\u00adtion table and then, at line 13, apply this function to the reactions ta\u00adble. In the body of \nthe query, we project out the rid and name .elds from the reaction and then construct an aggregate query \nwhich is supposed to perform a summation of all the molecular weights of proteins by consulting the xrefs \nand enzymes tables. The result of the query is the name of the reaction paired with the aggregate query \napplied to the xrefs table. The aggregate query is written in the style of a function that can be used \nto fold over a list. Its .rst argument sum is an accumulator; the second argument is a row from the xrefs \ntable. In the body of the aggregate query, we .rst check if the reaction id in the xref record matches \nthe reaction being processed by the query, i.e., this is the equivalent of checking a join constraint. \nIf the check succeeds, we look up the related protein, project out its weight and add it to the accumulator. \nNotice that the typing environment provides a function lookup that retrieves a row in the enzymes table \nbased on its primary key and a plus function to add .oating point numbers. We rewrite this query using \na S that includes primitive poly\u00admorphic coercions to manipulate the Prov t and List t types. No\u00adtice \nthat all of these coercions satisfy our well-formedness restric\u00adtion on HM types. The lift function injects \nan arbitrary type a into the Prov a type (by pairing it with some default provenance in\u00adformation). The \nlower coercion allows nested provenance wrap\u00adpers to be collapsed. The coercion asfun allows a function \nf that has been lifted into the Prov (a . \u00df) type to be applied to a provenance-tracked value x of type \nProv a. Since the value re\u00adturned by a function depends both on the provenance of the func\u00adtion and the \nprovenance of the argument, asfun is expected to tag the resulting \u00df-value with the provenance of both \nf and x. (It is interesting to note that the lift and asfun functions together make our Prov t type an \nidiom [Lindley et al. 2008].) The asprod co\u00aderces a provenance-tracked product into a product of provenance\u00adtracked \nvalues. Finally, the coercion set includes functions rmap and foldl, both standard combinators on lists. \nNotice, however, that the order of arguments in these functions is important; we cannot swap the .rst \ntwo arguments in rmap, for example, since f.a, \u00df.List a . (a . \u00df) . List \u00df. The coercion set S that we \nuse for this example does not satisfy the necessary conditions for non-ambiguity. For example, a product \ntype t1 \u00d7 t2 can be coerced both to itself and, via asprod . lift, to Prov t1 \u00d7 Prov t2.Nevertheless, \nwith a single type ascription for the entire query (shown on line 13 of the source program), the pro\u00adgrammer \ncan pick one of the several possible rewritings to resolve the ambiguity. For brevity, we leave out the \ntype instantiations on polymorphic coercions.  Typing environment G: Tables declared as lists of records \nrather than products for clarity; a type abbreviation, and some utility functions. enzymes:List (Prov \nprotein) protein = (pid:Int \u00d7 (name:String \u00d7 mw:Float)) reactions:List (Prov (rid:Int \u00d7 name:String)) \nlookup:Int . List (Prov protein) . Prov protein xrefs:List (rid:Int \u00d7 pid:Int) plus:Float . Float . Float, \nneq:Int . Int . Bool Coercion set S: Prov t is the type of a t-value tagged with provenance metadata; \nwe omit the data constructors for List t and Prov t. lift:.a.a . Prov a lower:.a.Prov (Prov a) . Prov \na asfun:.a, \u00df.Prov (a . \u00df) . Prov a . Prov \u00df asprod:.a, \u00df.Prov (a \u00d7 \u00df) . Prov a \u00d7 Prov \u00df rmap:.a, \u00df.(a \n. \u00df) . List a . List \u00df foldl:.a, \u00df.(a . \u00df . a) . a . List \u00df . a Source program 1 let query = 2 .reaction:(Int \n\u00d7String). 3 let rid = proj1 reaction in 4 let name = proj2 reaction in 5 let aggregate= 6 .sum:Prov Float. \n.xref:(Int \u00d7Int). 7 if neq (proj1 xref) rid then sum else 8 let pid = proj1 xref in 9 let protein = lookup \npid enzymes in 10 let wgt = proj2 (proj1 protein) in 11 plus wgt sum in 12 (name, aggregate 0 xrefs) \nin 13 query reactions : List Prov (Prov String \u00d7Prov Float) Target (rewritten) program 1 let query (* \n(Int \u00d7String) . (Prov String \u00d7Prov Float) *) = 2 .reaction:(Int \u00d7String). 3 let rid = proj1 reaction \nin 4 let name = proj2 reaction in 5 let aggregate (* Prov Float . (Int \u00d7Int) . Prov Float *) = 6 .sum:Prov \nFloat. .xref:(Int \u00d7Int). 7 if neq (proj1 xref) rid then sum else 8 let pid = proj2 xref in 9 let protein \n= lookup pid enzymes in 10 let wgt = proj2 (asprod (proj1 (asprod protein))) in 11 (asfun ((asfun . lift) \nplus) wgt) sum in 12 (lift name,(foldl aggregate)(lift 0) xrefs) in 13 ((rmap . asfun. lift) query) reactions \n: List Prov (Prov String \u00d7Prov Float) Figure 10. Equipping database queries with provenance tracking \nWe describe the rewritten query, given in the lower right of the .gure, from inside out, starting with \nthe body of the aggregate query. The .rst rewrite occurs at line 10. To project the mw .eld from protein, \nwe .rst coerce the Prov protein to a prod\u00aduct Prov Int \u00d7(Prov(String \u00d7Float)) using asprod, then coerce \nit again before projecting out the weight at the type Prov Float. To add two Prov Float values, at line \n11 we need to lift the plus func\u00adtion into the Prov idiom using lift and then asfun. Since plus is curried, \nthe partial application (asfun . lift plus) wgt is given the type Prov (Float . Float). With another \napplication of the asfun we may apply sum to get a value of type Prov Float. The type of the rewritten \naggregate query is shown as a comment on line 5. To apply the aggregate query to the xrefs table, we \ncoerce it using foldl to Prov Float . List (Int \u00d7Int) . Prov Float. We ap\u00adply the result to the constant \n0 lifted into the Prov Float type, and again to the xrefs table itself. By lifting name into the Prov \ntype, we can give query the type shown as a comment on line 1. Ap\u00adplying query to reactions is similar \nto the application of plus at line 11. The coercion rmap . asfun . lift coerces query to the type List \n(Prov (Int \u00d7String)) . List (Prov (Prov String \u00d7Prov Float)) which is the type necessary to apply it \nto run the query over reactions table. It is worth considering the precision that our method provides \nwhen tracking provenance. Swamy et al. [2008] have shown that this encoding of provenance is suf.cient \nto establish dependency correctness, a property due to Cheney et al. [2007]. This is an ex\u00adtremely strong \nproperty and can be used to track both explicit and implicit dependences, in a manner related to noninterference-based \ninformation .ow [Sabelfeld and Myers 2003]. However, if not used carefully, our encoding can produce \nprovenance results that claim, for example, that an element of a result set depends on all other data \nin the database. Suppose, for example, that instead of using lookup primitive on the protein table, we \nperformed a scan of the table (using rmap) to explicitly search for the entry with a primary key pid. \nAccording to dependency correctness, every aggregate molec\u00adular weight in the result would depend (negatively) \non every row in the enzymes table. While this is technically correct, it is not very useful. Handling \nnegative and implicit dependences is a challenge even faced by custom provenance tracking system, e.g., \nin the sys\u00adtem of Cheney et al. [2007]. Our approach allows programmers to provide special functions \nlike lookup to control how aggressively provenance information is tracked through a query. 7. Related \nwork Compared to the prior work on coercive subtyping our work in\u00adcludes, .rst, a more careful treatment \nof ambiguity and, second, provides greater expressiveness. With regards to the .rst, the struc\u00adture of \nour judgments allows us to treat ambiguity purely syntac\u00adtically, which makes it indifferent to the semantics \nof coercions, e.g., even if they are effectful. All prior work we know of either allows ambiguous rewritings \nbut proves they are con.uent (typi\u00adcally assuming coercions, or the source language, is not effectful), \nor preferentially selects a particular rewriting in an ad hoc way (e.g., a program that type checks without \nany coercions is left un\u00adtouched), which is less intuitive [Henglein 1994, Luo 1996, 1999, Luo and Luo \n2005, Luo 2008]. Our conditions for strong nonambi\u00adguity are necessary and suf.cient; prior works .nd \nsuf.cient con\u00additions (e.g., Sa\u00a8ibi [1997], and Luo and Kie\u00dfling [2004]), but these are more restrictive \nthan necessary, ruling out some useful, unam\u00adbiguous rewritings. Our coercions are more expressive in \nthat they include tran\u00adsitivity, structural rules, and polymorphism. We have not found this combination, \nwith the same degree of .exibility, in the liter\u00adature. For example, the coercion calculus of [Henglein \n1994] in\u00adcludes structurally and transitively-composed coercions, and work by Luo and Luo [2005], building \non the works of Aczel [1995] and Barthe [1996], does likewise. More recently, Luo [2008] has con\u00adsidered \nHM polymorphism, but without transitivity or structural rules. Sa\u00a8ibi s coercion system for Coq does \nsupport transitivity, structural rules, and polymorphism, but he imposes a uniformity restriction that \nseverely limits the use of polymorphism; e.g., co\u00adercions of the form .a, \u00df.Prov(a . \u00df) . Prov a . Prov \n\u00df cannot be expressed in his system.  Another difference in expressiveness when comparing our ap\u00adproach \nto coercive subtyping is that we wish to handle applications where coercions may have operational effect \nthis is partly the rea\u00adson why it is particularly important to ensure that coercion inser\u00adtion is unambiguous. \nTraditional coercive subtyping treats subtyp\u00ading as an identity coercion [Sulzmann et al. 2007, Breazu-Tannen \net al. 1991], or expects coercions to be total functions [Sa\u00a8ibi 1997]. This makes prior works unsuitable \nfor applications such as prove\u00adnance and gradual typing where the coercions necessarily have computation \neffect (to store provenance tracking information in the database, or for downcasts to fail). Henglein \n[1994] considers dy\u00adnamic typing as a coercion insertion problem (Section 5.5) where inserted coercions \nperform dynamic checks that may fail. He devel\u00adops a rewriting system that aims to produce a canonical, \noptimally safe rewriting, assuming a particular semantics for coercions. Thus his work is less general \nthan ours, but provides a stronger guarantee for this application. We consider a simply-typed source \nlanguage while other works consider source terms with dependent types [Sa\u00a8ibi 1997], Fsub source terms \n[Breazu-Tannen et al. 1991], or ML [Luo and Kie\u00dfling 2004]. Simply-typed source terms are useful in and \nof themselves, for example to apply this to rewriting database queries, or to retro.t monomorphic C code \nwith security checks [Ganapathy et al. 2006]. Nevertheless, extending our work to handle a polymorphic \nsource language is signi.cant future work. 8. Conclusions and future work In this paper we have de.ned \na general framework for type-directed coercion insertion. One of the innovations of our framework is \nto directly address the problem of ambiguity and separately de.ne mechanisms to curb ambiguity. We developed \nvarious versions of coercion generation that differ in the expressivity they provide to the rewriting \nsystem. To justify our work we have shown how a number of purpose-built rewriting schemes ranging from \nDSU to type systems to provenance tracking can be seen as speci.c instances of our general-purpose system. \nIn future work we should like to further explore the applicabil\u00adity of our work to type-directed rewriting \nproblems considered in the literature, such as other forms of gradual typing [Wadler and Findler 2009, \nSiek et al. 2009] and hybrid typing [Flanagan 2006]. We should also like to consider our framework in \nthe richer set\u00adting of dependent types. This is not just out of theoretical curiosity; our original motivation \nfor this work, Fable [Swamy et al. 2008], is a dependently typed language for enforcing user-de.ned secu\u00adrity \npolicies. Indeed, the encoding of provenance tracking in \u00a76.3 is closely related to an encoding that \nis used in Fable, although Fa\u00adble s type system enables the provenance of a value to be made evident \nin its type, not just in its runtime representation. Acknowledgments The authors would like to thank \nJeff Foster, Phil Wadler, Dimitrios Vytiniotis, Iulian Neamtiu, Polyvios Pratikakis, Peter Sewell, and \nthe anonymous reviewers for helpful comments that led to signif\u00adicant improvements in the paper s presentation. \nHicks was sup\u00adported in part by NSF grants CCF-0541036, CCF-0524036, and CNS-0346989 and by Microsoft \nResearch, Cambridge, while on sabbatical during the Fall of 2009, when much of this work was carried \nout. References P. Aczel. A notion of class for type theory, 1995. Unpublished manuscript. G. Barthe. \nImplicit coercions in type theories. In Proc. of Types workshop, 1996. V. Breazu-Tannen, T. Coquand, \nC. Gunter, and A. Scedrov. Inheritance as implicit coercion. Information and Computation, 93:172 221, \n1991. J. Cheney, A. Ahmed, and U. A. Acar. Provenance as dependency analysis. In Proc. of DBPL, 2007. \nC. Flanagan. Hybrid type checking. In Proc. of POPL, 2006. V. Ganapathy, T. Jaeger, and S. Jha. Retro.tting \nlegacy code for authoriza\u00adtion policy enforcement. Proc. of Security and Privacy, 2006. F. Henglein. \nDynamic typing: syntax and proof theory. Science of Computer Programming, 22:197 230, 1994. S. Lindley, \nP. Wadler, and J. Yallop. Idioms are oblivious, arrows are meticulous, monads are promiscuous. In Proc. \nof MSFP, 2008. Z. Luo. Coercions in a polymorphic type system. Mathematical Structures in Computer Science, \n18(4):729 751, 2008. Z. Luo. Coercive subtyping in type theory. In Proc. of CSL, 1996. Z. Luo. Coercive \nsubtyping. Journal of Logic and Computation, 9(1):105 130, 1999. Z. Luo and R. Kie\u00dfling. Coercions in \nHindley-Milner systems. In Proc. of Types, 2004. Z. Luo and Y. Luo. Transitivity in coercive subtyping. \nInformation and Computation, 197(1-2):122 144, 2005. P. Pratikakis, J. Spacco, and M. Hicks. Transparent \nproxies for Java futures. In Proc. of OOPSLA, 2004. A. Sabelfeld and A. C. Myers. Language-based information-.ow \nsecurity. JSAC, 21(1):5 19, 2003. A. Sa\u00a8ibi. Typing algorithm in type theory with inheritance. In Proc. \nof POPL, 1997. J. G. Siek and W. Taha. Gradual typing for functional languages. In Proc. of Scheme and \nFunctional Programming Workshop, 2006. J. G. Siek, R. Garcia, and W. Taha. Exploring the design space \nof higher\u00adorder casts. In Proc. of ESOP, 2009. G. Stoyle, M. Hicks, G. Bierman, P. Sewell, and I. Neamtiu. \nMutatis Mutandis: Safe and .exible dynamic software updating. ACM TOPLAS, 29(4), 2007. M. Sulzmann, M. \nM. T. Chakravarty, S. Peyton Jones, and K. Donnelly. System F with type equality coercions. In Proc. \nof TLDI, 2007. N. Swamy, B. J. Corcoran, and M. Hicks. Fable: A language for enforcing user-de.ned security \npolicies. In Proc. of Security and Privacy, 2008. N. Swamy, M. Hicks, and G. Bierman. A theory of typed \ncoercions and its applications. Technical Report MSR-TR-2009-69, Microsoft Research, 2009. P. Wadler \nand R. B. Findler. Well-typed programs can t be blamed. In Proc. of ESOP, 2009.    \n\t\t\t", "proc_id": "1596550", "abstract": "<p>A number of important program rewriting scenarios can be recast as type-directed coercion insertion. These range from more theoretical applications such as coercive subtyping and supporting overloading in type theories, to more practical applications such as integrating static and dynamically typed code using gradual typing, and inlining code to enforce security policies such as access control and provenance tracking. In this paper we give a general theory of type-directed coercion insertion. We specifically explore the inherent tradeoff between expressiveness and ambiguity--the more powerful the strategy for generating coercions, the greater the possibility of several, semantically distinct rewritings for a given program. We consider increasingly powerful coercion generation strategies, work out example applications supported by the increased power (including those mentioned above), and identify the inherent ambiguity problems of each setting, along with various techniques to tame the ambiguities.</p>", "authors": [{"name": "Nikhil Swamy", "author_profile_id": "81342513197", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P1613962", "email_address": "", "orcid_id": ""}, {"name": "Michael Hicks", "author_profile_id": "81100060959", "affiliation": "University of Maryland, College Park, MD, USA", "person_id": "P1613963", "email_address": "", "orcid_id": ""}, {"name": "Gavin M. Bierman", "author_profile_id": "81100249578", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P1613964", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596598", "year": "2009", "article_id": "1596598", "conference": "ICFP", "title": "A theory of typed coercions and its applications", "url": "http://dl.acm.org/citation.cfm?id=1596598"}