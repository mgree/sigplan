{"article_publication_date": "08-31-2009", "fulltext": "\n A Functional I/O System * or, Fun for Freshman Kids Matthias Felleisen Robert Bruce Findler Matthew \nFlatt Shriram Krishnamurthi Northeastern University Northwestern University University of Utah Brown \nUniversity Abstract Functional programming languages ought to play a central role in mathematics education \nfor middle schools (age range: 10 14). After all, functional programming is a form of algebra and pro\u00adgramming \nis a creative activity about problem solving. Introducing it into mathematics courses would make pre-algebra \ncourse come alive. If input and output were invisible, students could implement fun simulations, animations, \nand even interactive and distributed games all while using nothing more than plain mathematics. We have \nimplemented this vision with a simple framework for purely functional I/O. Using this framework, students \ndesign, implement, and test plain mathematical functions over numbers, booleans, string, and images. \nThen the framework wires them up to devices and performs all the translation from external information \nto internal data (and vice versa) just like every other operating system. Once middle school students \nare hooked on this form of programming, our curriculum provides a smooth path for them from pre-algebra \nto freshman courses in college on object-oriented design and theorem proving. Categories and Subject \nDescriptors D.2.10 [Software Engineer\u00ading]: Design methodologies; D.4.7 [Operating Systems]: Orga\u00adnization \nand Design interactive systems General Terms De\u00adsign, Languages Keywords Introductory Programming  1. \nFunctions for Freshmen Based on our decade-long experience (Felleisen et al. 2004a), novices to programming \ntend to accept languages that they haven t heard of as long as they can quickly construct a program that \nis like the applications they use on their computers. To this end, the chosen language must come with \na rich framework for input and output (I/O), ideally via graphical interfaces. Chakravarty and Keller \n(2004) present corroborating evidence based on a thorough analysis of their Haskell-based introductory \ncourses. They also re\u00adport, however, that most Haskell texts deemphasize I/O. Our own review shows that \nthree (Thompson 1997; Bird and Wadler 1998; Hutton 2007) of four major Haskell-based text books introduce \nI/O in the last third of the book or the .nal chapter; only Hudak (2000) tackles it head-on, though in \na quasi-imperative manner. * This research was partially supported by several grants from the National \nScience Foundation. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. ICFP 09, August 31 September 2, 2009, Edinburgh, Scotland, UK. Copyright c &#38;#169; 2009 \nACM 978-1-60558-332-7/09/08. . . $5.00 Surprisingly, even O Sullivan et al. (2008) s Real World Haskell \nhas dif.culties explaining I/O, according to some on-line reviews. Here we present our approach to reconciling \nI/O with purely functional programming, especially for a pedagogical setting. The I/O framework extends \nthe DrScheme (Findler et al. 2002) teaching languages for our text How to Design Programs (HtDP) (Felleisen \net al. 2001), but it is also accessible from other dialects. Our frame\u00adwork does not require the use \nof any monads or other threading devices, meaning middle school students can write animation and interactive \ngames as a bunch of mathematical functions. Indeed, be\u00adcause everything is just a function on numbers, \nstrings, and images, students can also test every step as they design their programs. For the past three \nyears, the curriculum has been deployed at eight mid\u00addle schools (ages 10 14). The students tend to embrace \nprogram\u00adming enthusiastically after a nine-week course. Moreover, this kind of programming experience \nseems to improve the performance of these students in standard mathematics courses. The purpose of our \npaper is to share our technical development so that others can duplicate our pedagogical experiences, \nwhether the functional I/O library is layered on top of an imperative library (as in our implementation) \nor on top of an I/O monad (as an im\u00adplementation for Haskell would be). The next section provides an \noverview of our experiences to explain some of the sociological context where we apply functional programming \nwith I/O. Sec\u00adtion 3 illustrates how we start middle school students on functional programming. The rest \nof the paper focuses on the technical foun\u00addations.Sections 4 and 5 explain the I/O library and how to \nuse it. Section 6 is about the college-level curricular context. In section 7, we compare our approach \nto the Clean Event I/O system, which is closest to our framework, and to some other pieces of work. \n 2. Experience Age group Since Framework Schools middle school 2006 animation eight two-or three-object \ngames, simplistic sound high school 2004 animation = 30 N object games, simulations college 2003 animation \n= 20 N object games, simulations, visualization college &#38; MS program 2008 dist. prog. Chicago &#38; \nNEU distributed two-player games Variants of our I/O library have been in use since 2003 at a vari\u00adety \nof places. The nearby table provides a concise overview of the kinds of students, sites, and projects \nthat it enables. Clearly, the library is primarily useful in college-level freshman courses. Start\u00ading \nin 2004, we also introduced the library into the TeachScheme! workshops; some 30 schools have run courses \nwith it. Three years ago, Emmanuel Schanzer derived the Bootstrap curricu\u00adlum (www.bootstrapworld.org) \nfrom HtDP for Citizen Schools (www.citizenschools.org), which runs after-school programs on a wide range \nof topics in poor neighborhoods across the US. At this point, eight sites (in Austin, the Bay Area, Boston \nand surroundings, and New York City) have used Bootstrap with a spe\u00adcialized variant of the I/O library. \nFinally, the .rst author uses the library in an immersion course for Northeastern s MS program.  Middle \nschool students in the Bootstrap after-school courses typically have little background in mathematics. \nThey are barely comfortable with calculations on numbers; they struggle with vari\u00adables, if they have \nencountered them at all; and many are discour\u00adaged about the entire topic. Occasionally some of the students \nare concurrently enrolled in a .rst pre-algebra course. One goal of Bootstrap is to bring across the \nnotion of a function as something that relates quantities, though not necessarily num\u00adbers. Naturally, \nthe citizen teachers (volunteer instructors working for Citizen Schools) do not tell students that they \nare about to study a parenthesized form of algebra. Instead, they demonstrate interac\u00adtive computer games \nand encourage students to think about creating such games on their own. A normal Citizen Schools course \nlasts nine weeks, with one two-hour session per week and no homework assignments. Within this time, most \nstudents design and systematically implement an in\u00adteractive game of their choice that involves a .xed \nnumber of mov\u00ading objects, object collisions, and score keeping. They code these games in the Beginning \nStudent language of HtDP, extended with our new library. Citizen teachers report that the majority of \nstudents actively and enthusiastically participate in these courses, many ask\u00ading for more when the course \nends.1,2 By the end of the course, some of the citizen teachers share with the students that their game \nprograms are mathematics. Anecdotal evidence suggests that making mathematics come alive in this manner \nhas a direct impact on students performance in subsequent mathematics courses. Numerous instructors report \nconversations with mathematics teachers on how the students have changed their attitude about mathematics \nand how their grades have improved. The I/O library plays a similarly important role in high school courses \nand .rst-year college curricula as it does for Bootstrap. Many high school teachers and college instructors \nhave noticed that students fail to understand mathematical functions. An intro\u00adductory curriculum that \nmakes functions critical and fun for anima\u00adtions, simulations, and interactive and multi-player/multi-computer \ngames can thus play a central role in enhancing students prepara\u00adtion. Once students understand the basic \nidea of a function, it is easy to motivate them to study the systematic design of functions as advertised \nin HtDP (Felleisen et al. 2004b). After all, designing properly enables them to write more interesting \nsimulations, ani\u00admations, games, etc. As we explain in section 6, this kind of .rst course also prepares \nstudents well for the rest of the .rst year, in\u00adcluding applicative and imperative object-oriented programming. \nSome typical examples are the freshman courses at the Uni\u00adversity of Chicago and Northeastern University. \nAlthough Chicago uses a quarter system, its course reaches the same milestones as Northeastern s, due \nto the small class size at Chicago and students strong academic preparation. In both courses, students \nwork out at least two complete game project in a purely functional setting, 1 Due to the demand, Schanzer \n[personal communication, Dec. 2008] is working on a second-level course for next summer. 2 Over the past \nfew years, Alice [alice.org]and Scratch [scratch.mit. edu] have been touted as frameworks for teaching \nmiddle school students how to program. Both efforts are incomparable with Bootstrap for two rea\u00adsons. \nFirst, both Alice and Scratch are mostly imperative and thus fail to have direct bene.ts for the students \nmathematics education. Second, as others also note (Powers et al. 2007), these GUI-oriented systems come \nwithout a natural transition to full-.edged programming whereas our cur\u00adriculum spells out a natural \npath from middle school mathematics to the second semester in college. often the same ones at both places \n(2008: Snake, Chat Noir). The .rst project (between 500 and 1,000 lines) is repeated twice, once to ensure \nstudents can implement suggestions and a second time to in\u00adtroduce abstraction via higher-order functions. \nThe second project (some 1,000 2,000 loc) is typically an end-of-semester/quarter project where students \nhave some creative freedom, too. The au\u00adthors have repeatedly observed that students continue to work \non their game programs after the semester/quarter ends.  3. Arithmetic, Algebra, and Movies In middle \nschool, mathematics teachers often ask students to deter\u00admine the next number in a sequence such as 1,4,9. \nOr they show students a series of shapes and ask what the next shape should look like. Eventually these \nseries are arranged in the form of tables, e.g., x = 0 1 2 3 4 ... i y = 0 1 4 9 ? ... y(i) and students \nare asked to .ll in the result for 4 and to determine a general formula for determining any element in \nthe sequence. Next comes an algebra course where students experience the joys of such exciting problems \nas two trains leaving from Chicago and Philadelphia and colliding in Pittsburgh. Functional programmers \nknow that these students are encoun\u00adtering their .rst core concept in their mathematical education: func\u00adtions \nand variable expressions. They also know that functions and expressions don t need to be restricted to \nnumbers and operations on numbers. It is perfectly acceptable to speak of the arithmetic and algebra \nof booleans, chars, strings, etc. DrScheme programmers also formulate functions and expres\u00adsions that \ncompute with images as .rst-class values, e.g., (empty-scene 100 100) returns a blank square of 100 \nby 100 pixels, and (place-image  10 20 (empty-scene 100 100)) combines the image of the rocket with \nthe blank square by placing the former 10 pixels to the right of the left margin and 20 pixels down from \nthe top margin of the latter. Now imagine teaching in this context. Teachers can ask students what the \nnext image in the following series is: x = 0 1 2 3 4 z =  ? and what the general formula is for the \nimage. As before, students would struggle and eventually come up with an answer. At this point, teachers \ncould explain that displaying 25 to 30 of these scenes per second would create the effect of a movie \nthat simulates a rocket landing. Students know movies, and students .nd movies more interesting than \ntrains colliding in Pittsburgh. So the teacher could show them how to play this movie in DrScheme: (define \n(rocket-scene i)  (place-image 50 i (empty-scene 100 100))) The function de.nition captures the general \nanswer to the teacher s question, though in parentheical syntax. Although this isn t close to the historically \ngrown in.x notation of mathematics (or to that of fashionable languages), our experience shows that students \ndon t seem to mind after some initial reluctance. If the student now applies the library function run-simulation \nto rocket-scene, the library generates a series of scenes. More precisely, it applies its  argument \n(here: rocket-scene) to 0, 1,2,3, . . . and displays the resulting series of images in a separate window, \nlike the one embedded in this paragraph, at the rate of 28 numbers per second. The rest of the paper \nshows how to general\u00adize this idea so that the language of 9th grade school mathematics can be used \nto design interactive, and even dis\u00adtributed, games.  4. Designing a World The HtDP curriculum heavily \nemphasizes functional programming. DrScheme (Findler et al. 2002), HtDP s accompanying IDE, sup\u00adports \na series of .ve teaching languages, each expanding the ex\u00adpressive power of its predecessor. The .rst \nfour of these teaching languages are purely functional, and they are usually the only ones used in courses \nfor novice programmers. Universe type WorldSt ... body ... type KeyEvt = ... type MouseEvt = ... val \nbig-bang: WorldSt x (WorldSt -> WorldSt) x (WorldSt KeyEvt -> WorldSt) x (WorldSt Nat Nat MouseEvt \n-> WorldSt) -> WorldSt WorldProgram type KeyEvt; type MouseEvt; val big-bang: WorldSt x (WorldSt -> \nWorldSt) x (WorldSt KeyEvt -> WorldSt) x (WorldSt Nat Nat MouseEvt -> WorldSt) -> WorldSt ... body \n... type WorldSt Figure 1. A unit perspective of world programs and UNIVERSE Our I/O framework comes \nas a library, dubbed UNIVERSE.The library implements and exports two expression forms for launching world \nand universe programs. This section explains worlds; the next one is about universes. 4.1 The World \nis a Virtual Machine To a student, the UNIVERSE library represents the computer s op\u00aderating system and \nhardware. As such the library is the keeper of a representation of the state of the world. When the hardware \nor operating system notices certain events, the library hands over the state of the world to a function \nin the student s program and ex\u00adpects another state back. We call this state a world, and the phrase \nworld program denotes the collection of functions that interact with the library. Combining the library \nand a world program creates an executable program. The library is parameterized over the kinds of states \ncalled WorldSt that the world program wishes to deal with as well as the event handlers that process \nthese states. A world program matches these two parameters with a data de.nition for the collection of \nstates and with a collection of functions. Figure 1 expresses this dependency between the library and \na student s program via a unit diagram (Flatt and Felleisen 1998). The universe library is parameterized \nover the type WorldSt; it exports two types and a function that consumes WorldSt-processing functions. \nConversely, a world program is a unit that imports all of this, exporting in return a WorldSt type. Linking \nthe two creates the executable. In reality, though, programs specify types as comments, and UNIVERSE \ndoes not export a function for specifying event handlers but a syntactic extension, dubbed big-bang: \n(big-bang WorldState-expr ) (on-tick tock-expr rate-expr (on-key react-expr) (on-mouse click-expr) (stop-when \ndone-expr) (on-draw render-expr width-expr height-expr ) ) A big-bang expression has one required sub-expression \nthe initial state of the world and .ve optional clauses (indicated via superscripts). These clauses are \nintroduced via one of .ve key\u00adwords (on-tick, on-key, on-mouse, stop-when,and on-draw), mimicking keyword-based \nparameter passing. Each clause speci\u00ad.es at least one sub-expression; two have additional optional sub\u00adexpressions \n(see superscripts). When PLT Scheme encounters a big-bang expression, it .rst evaluates all sub-expressions \nand checks some basic properties. The result of WorldState-expr becomes the initial state of the world. \nThe remaining values give access to a subset of the underly\u00ading platform s events: 1. Ifan on-tick clause \nexists, big-bang starts a clock that ticks at a rate of 28 times per second or as often as the result \nof rate-expr a natural number speci.es. The expression tock-expr must evaluate to a function of one argument: \n;; WorldSt . WorldSt Speci.cally, the function consumes a state of the world and produces one. The universe \nlibrary invokes it on the current state every time the clock ticks; its result becomes the next state. \n2. An on-key clause speci.es how a world program reacts to a keyboard event. Its sub-expression must \nevaluate to a function of two arguments: ;; WorldSt KeyEvt . WorldSt The .rst is again the current state \nof the world; the second is a data representation of the keyboard event. In UNIVERSE, a keyboard event \nis represented as either a one\u00adcharacter string (e.g., \"a\") or a number of special strings (e.g., \"left\", \n\"release\"). The former denote regular keys on the keyboard; the latter are used to represent arrow keys, \nother special keys, and the event of releasing a key. The library invokes this function for every keyboard \nevent and uses the result of the invocation as the new state of the world. 3. Similarly, an on-mouse \nclause determines how a world program reacts to a mouse event with a function of four arguments: ;; WorldSt \nNat Nat MouseEvt . WorldSt As always, the .rst argument is the current state of the world. The next two \narguments capture the x and y coordinates of the  Figure 2. A state transition diagram for world programs \nevent, measured in the number of pixels from the left and top of the screen. Finally, the MouseEvt argument \ndetermines what kind of mouse action has taken place. It is one of the following six strings: \"button-up\", \n\"button-down\", \"drag\", \"move\", \"enter\", \"leave\". Like the underlying operating system, the UNIVERSE library \ndoes not notify a world program of every mouse event, but it samples the mouse events at a reasonably \nhigh rate. The result of applying the mouse-event handler function be\u00adcomes the next world. 4. The stop-when \nclause determines when the world ends. Its sub-expression must evaluate to a predicate: ;; WorldSt . \nBoolean After handling an event with one of the above event-handling functions, UNIVERSE uses this predicate \nto .nd out whether the resulting state of the world is a .nal state. If the result state satis.es the \npredicate, no further events are processed. 5. Last but not least, a big-bang expression may come with \nan on-draw clause, which has either one or three sub-expressions. The .rst sub-expression must evaluate \nto a function of one argument: ;; WorldSt . Image If the big-bang expression speci.es such a function, \nthe UNI-VERSE library opens a separate window whose size is deter\u00admined by the size of the .rst image \nthat the function produces. Alternatively, a program may specify the size of the canvas explicitly via \nthe two additional sub-expressions, which must evaluate to natural numbers. The function speci.ed in \non-draw is used every time an event\u00adhandling function produces a state. The resulting image is ren\u00addered \nin the separate window. Once the world ends, big-bang returns the .nal state.3 As .gure 2 suggests, the \ncore of an executable world program denotes a state machine. Each element W, WI, WII, ...of WorldSt is \na state of this machine. For each state and for each kind of event, the event handlers (plus event-speci.c \ninputs) specify the successor state; that is, each state except for .nal ones is the source of three \n(family of) arrows (with distinct targets). The .nal states are those for which the predicate speci.ed \nin the stop-when clause produces true. 3 It is instructive to contrast this to the type of reactimate \nin Fran (Elliot and Hudak 1997). What the .gure does not show is the orthogonally speci.ed rendering \nof each state as a scene or image. Although these images are values in PLT Scheme, they are usually not \na component of world states. One way to imagine this rendering process is to add a different kind of \narrow to each state and connecting this arrow to thescenethat the on-draw function produces for this \nstate. Given this explanation, we can explain the workings of the run-simulation function. Its world \nis the world of natural num\u00adbers, i.e., the state of the world represents the number of times the clockhas \ntickedsofar: ;; WorldSt = Nat ;; interp. the number of clock ticks As for run-simulation, it consumes \na function from natural num\u00adbers to Scenes. Its purpose is to start the world, to count the number of \nclock ticks, and to invoke the given function on each clock tick to render a series of Scenes: ;; (Nat \n. Scene) . Nat (define (run-simulation render) (big-bang 0 (on-tick add1) (on-draw render))) The result \nof run-simulation is a natural number: speci.cally, the number of clock ticks that have passed (once \nthe simulation halts).  4.2 Designing a World Program Designing a world program is surprisingly easy. \nThe .rst step is to design a data representation for the information that varies and that is to be tracked \nthrough the duration of the program execution. We recommend expressing the data representation as a data \n(type) de.nition (or several) and equipping it with comments that interpret this data in terms of the \nvisible canvas (world). Naturally, this data de.nition .lls in for the WorldSt type from the preceding \nsection. The second step is to tease out constants that describe properties of the world. This includes \nboth quasi-physical constants, e.g., the width and height of the screen, as well as image constants, \ne.g., the background or a .xed shape that moves across the scenery. The third step is to design the event-handling \nfunctions. Here design refers to the design recipe from HtDP. Given that we already have data de.nitions \n(from the .rst step and the library), we also have contracts for all the top-level functions. Hence the \nnext step is to think through examples and to turn them into tests. The creation of templates usually \n(but not always) uses the WorldSt type for orientation. After coding, it is important to run the tests. \nAlso following HtDP, iterative development is the most ap\u00adpropriate approach for world programs. Speci.cally, \nwe recom\u00admend that students provide a minimally useful data de.nition for WorldSt and then design one \nstate-processing event handler and the rendering function. This enables them to test the core of the \nprogram and interact with it. From here, they can pursue two dif\u00adferent directions: enriching the data \nand adding event handlers.  4.3 Controlling a UFO Let us illustrate how to design world programs with \nan example from the second or third week in a college freshman course. The goal of the exercise is to \nmove a UFO ( .ying saucer ) across the canvas in a continuous manner. Later we add functions that allow \nplayers to control the UFO s movements via the arrow keys on the keyboard and via mouse clicks. A moving \nobject on a .at canvas has (at least) four properties, meaning we need to use a structure4 to represent \nthe essential data: 4 In teaching languages, a structure de.nition like this one introduces three kinds \nof functions: a constructor (make-ufo), a predicate (ufo?), and one selector per .eld to extract the \nvalues (ufo-x, ufo-y, ufo-dx, ufo-dy). PLT Scheme also adds imperative mutators on demand.  ;; WorldSt \nKeyEvt . WorldSt ;; control the ufo s direction via the arrow keys (check-expect (control (make-ufo 5 \n8 -1 -1) \"down\") (make-ufo 5 8 -1 +1)) ;; ... more test cases ... (define (control w ke) (cond [(key=? \nke \"up\") (set-ufo-dy w -1)] [(key=? ke \"down\") (set-ufo-dy w +1)] [(key=? ke \"left\") (set-ufo-dx w -1)] \n[(key=? ke \"right\") (set-ufo-dx w +1)] [else w])) ;; WorldSt Int . WorldSt (define (set-ufo-dy u dy) \n(make-ufo (ufo-x u) (ufo-y u) (ufo-dx u) dy)) ;; WorldSt Nat Nat MouseEvt . WorldSt ;; move the ufo to \na new position on the canvas (check-expect (hyper (make-ufo 10 20 -1 +1) 40 30 \"button-up\") (make-ufo \n10 20 -1 +1)) ;; ... more test cases ... (define (hyper w x y a) (cond [(mouse=? \"button-down\" a) (make-ufo \nx y (ufo-dx w) (ufo-dy w))] [else w])) ;; WorldSt . Boolean ;; has the ufo landed? (check-expect (landed? \n(make-ufo 5 (-SIZE 5) -1 +1)) false) ;; ... more test cases ... (define (landed? w) (>= (ufo-y w) SIZE)) \n Figure 3. Using keyboard and mouse events to control a ufo (define-struct ufo (x y dx dy)) ;; WorldSt \n= (make-ufo Nat Nat Int Int) ;; interp. the location (pixels) ;; and velocity (pixels/tick) Because \nnothing else in this game changes over time, we identify the state of the world with the state of the \nUFO. Next we .x the size of the canvas, the background (an empty scene), and the shape of the UFO: (define \nSIZE 400) (define MT (empty-scene SIZE SIZE))  (define UFO (overlay (circle 10 \"solid\" \"green\") (rectangle \n40 2 \"solid\" \"green\"))) (define UFO.version2 ) This time we use basic image creation and manipulation \nprim\u00aditives to create the right kind of shape; using the de.nition of UFO.version2 instead of UFO would \nof course work equally well. With the above data de.nition, we have determined the com\u00adplete type signature \nof the event-handling functions for clock tick events. Of course we should add a purpose statement: ;; \nWorldSt . WorldSt ;; move the ufo for one tick of the clock The next step in our design recipe calls \nfor examples that describe the behavior of the function. We formulate these examples imme\u00addiately in \nthe unit testing framework that comes with DrScheme s teaching languages:5 (check-expect (move (make-ufo \n10 20 -1 +1)) (make-ufo 9 21 -1 +1)) The example illustrates that the function s purpose is to add the \nvelocity to the current position and to use it as the new position: (define (move w) (make-ufo (+ (ufo-x \nw) (ufo-dx w)) (+ (ufo-y w) (ufo-dy w)) (ufo-dx w) (ufo-dy w))) 5 DrScheme collects all check-expect \nexpressions and evaluates them after all de.nitions and expressions are evaluated. It then outputs the \nresults and tabulates failed test cases with hyper-links to the source text of the test. Before we can \ninteract with the program, we must design one more function, namely, a function for rendering the current \nstate of the world as a scene: ;; WorldSt . Scene ;; place the ufo into MT at its current position (check-expect \n(render (make-ufo 10 20 -1 +1)) (place-image UFO 10 20 MT)) (define (render w) (place-image UFO (ufo-x \nw) (ufo-y w) MT)) Designing such a function proceeds according to the same recipe as designing the move \nfunction. Also notice that we can test the outcome of this function as if it were a function on the reals. \nBe\u00adcause images are .rst-class values, it makes sense to construct the expected output and to compare \nit to the actual result of the func\u00adtion. PLT Scheme s standard equal? function works for images, too. \nWhile we recommend that students develop such expected results expression (interactively in the REPL) \nto gain some under\u00adstanding of how the function should proceed, it is indeed possible to insert an actual \nimage instead of such an expression: (check-expect (render (make-ufo 10 20 -1 +1)) ) Equipped with move \nand render, it is possible to de.ne a main function and to watch these .rst two de.nitions in action: \n;; WorldSt . WorldSt ;; run a complete world program, ;; starting in state w0 (define (main w0) (big-bang \nw0 (on-tick move) (on-draw render))) In short, we have .nished the .rst stage of our iterative design \ncycle, creating a .rst useful part of the overall program. From here, it is easy to design the rest of \nthe function. See the left-hand side of .gure 3 for the de.nition of a function that controls the movements \nof the UFO via arrow keys. The function key=? compares two keyboard events. The right-hand side of the \nsame .gure displays functions for making the UFO jump to the position of a mouse click; mouse=? of course \ncompares mouse events. The last function checks whether the UFO has landed.   5. Universe: A World \nis Not Enough Designing interactive graphical programs via purely functional pro\u00adgramming is only half \nthe game. The other half is about designing distributed programs, especially distributed games. The principles \nremain the same, but the differences deserve a close look. 5.1 Universes A universe consists of a distributed \ncollection of world programs that communicate with each other via a programmable server: We make no \nassumption about where the programs run, in particu\u00adlar, UNIVERSE cannot .nd servers automatically. The \ncommunication links rely on TCP/IP connections, meaning messages sent from a world to a server (or vice \nversa) are guaran\u00adteed to arrive in the order in which they are dispatched. Of course, when two distinct \nworld programs send messages to the server, there is no guarantee that the messages arrive in the order \nthey were sent; similarly, if the server broadcasts messages to (some of) the participating worlds, the \nmessages may again arrive at distinct worlds in an unrelated order. In order to design a universe based \non the UNIVERSE teachpack, students design a communication protocol, which they implement via a server \nprogram. Some protocols simply pass messages from one world program to another and back, with the server \nplaying the role of a conduit. Other protocols assume that the server is an arbiter, enforcing the rules \nof a game or directing traf.c among the participants, as in a chat room. Finally, the server could be \ncon.gured in such a way that the world programs simulate peers in a peer-to-peer neighborhood. 5.2 A \nWorld in the Universe For a world program to participate in a universe, it registers with the server \nusing a (register ip-expr) clause in its big-bang ex\u00adpression. The sub-expression designates an IP address \n(as a string). A registered world program sends messages via its event han\u00addlers.Tothisend,the UNIVERSE \nlibraryde.nes package structures and exports its constructor and predicate: (define-struct package (world \nmsg)) ;; Package = (make-package World S-exp) Moreover, the library actually deals with event handlers \nthat return one of two kinds of results, meaning the signature of, say, key event handlers is really \n;; WorldSt KeyEvt . (. Package WorldSt) instead of the one speci.ed in the preceding section. If an event \nhandler produces a package, the library uses the value in the .rst .eld as the next state of the world, \nand the value in the second .eld is sent off to the server. Otherwise, the library assumes the result \nis just the state of the world. To receive messages, a world program installs an event-handling function \nvia an on-receive clause in big-bang. It subexpres\u00adsion must evaluate to a function with the following \nsignature: ;; WorldSt S-exp . (. Package WorldSt) When a message in the form of an S-expression arrives, \nthis event handler is applied to the current state of the world and the message. Like all other event \nhandlers, this handler may return a Package. Figure 4. State transition view of world communicating \nprograms Figure 4 is a revision of .gure 2 for communicating worlds. Again, all elements of WorldSt are \nstates, but now all states come with four kinds of transition arrows. The fourth one is the event handler \nthat deals with message receipts. In addition, each arrow now comes with an optional output label in \nthe form of an S\u00adexpression. Just as UNIVERSE displays the rendering of a state as an image for a world \nprogram, it also implements the sending these messages from state transitions to the universe s server. \n 5.3 The Universe and its Server The UNIVERSE library supports the design of servers in a manner that \nis analogous to the design of world programs. A programmer describes a server via a pair of speci.cations: \na data de.nition of universe states, dubbed UniSt,and a universe description, which is analogous to a \nbig-bang description. For a server, three kinds of events matter most: the entry of an additional world \ninto the universe, a world s disappearance, and the arrival of a message from a participating world. \nAccordingly server programs must deal with representations of participating worlds, and UNIVERSE supports \nthis: (define-struct iworld (name in out)) ;; IWld = (make-iworld String Port Port) ;; interp. internal \nrepresentation ;; of a participating world The iworld structure keeps track of a world program s name, \nits input TCP port, and its output port, though a server program may only access the name .eld of iworld \nstructures. Other than that, server programs must compare worlds and do so with iworld=?. Here is the \ncore grammar of a universe description: (universe UniSt-expr (on-new new-expr) (on-msg msg-expr) (on-disconnect \ndisc-expr disc-expr) ...) The .rst, required sub-expression determines the initial state of the server. \nFurthermore, every universe description comes with an on-new clause and an on-msg clause. Optionally, \nit may also contain an on-disconnect clause. Every server s event handler consumes the current state \nof the universe as perceived and maintained by the server s event handlers and the representatin of a \nparticipating world; it may also consume a message received from such a world. An event handler produces \na bundle, i.e., a UNIVERSE-speci.ed structure that contains three distinct pieces of information: the \nnew server state (UniSt); a list of messages to designated worlds; and the list of worlds to be discarded: \n (define-struct bundle (state mails to-discard)) (define-struct mail (to msg)) ;; Bundle = (make-bundle \nUniSt Mail* IWld*) ;; Mail* = [Listof (make-mail IWld S-exp)] ;; IWld* = [Listof IWld] Event handlers \nmay only construct bundlesand mails; they may not destructure them. The event handlers function as follows: \n1. An on-new handler has the signature ;; UniSt IWld . Bundle i.e., it consumes the server state and \na representation of the world that wishes to join. The resulting bundle may contain this new world as \none that should be discarded, which effectively represents a rejection of the request. Optionally, the \nhandler may send out messages about the event. 2. An optional on-disconnect event handler has the same \nsigna\u00adture as an on-new handler, but it deals with the disappearance of a world from the universe: ;; \nUniSt IWld . Bundle This kind of event is usually due to a severed connection or because the corresponding \nworld program shut down. 3. The signature for on-msg handlers also includes the message that arrived \nin the form of an S-expression: ;; UniSt IWld S-exp . Bundle When the on-msg event handler is invoked, \nit is applied to the state of the server, the world that sent in a message, and the message itself. The \nresult bundle determines how this event is shared with other worlds in the universe. Optional handlers \nmay drive the server via clock ticks, render the current state of the server in a console, or deal with \nother events. A complete universe program as speci.ed in a universe expression is best thought of as \na state-transition machine, just like the one for world programs depicted in .gure 4. Each element of \nUniSt is a state of the machine; each event handler (and its auxiliary parameters) represents one possible \ntransition from one UniSt element to another. In contrast to world programs, the state transitions in \na universe program come with two labels: one for sending mail to a list of participating worlds, and \nanother one for deleting worlds from the list of participants.  5.4 Designing a Universe Designing a \nuniverse requires two different perspectives: a global one concerning coordination and local ones for \nthe server and the world programs. Once the global view has been developed, the local design of the servers \nand world programs proceeds just like stand-alone world programs. The global perspective demands the \ndesign of a coordination and communication protocol. This protocol design has the goal of creating and \nmaintaining an invariant for the universe. In order to achieve this goal, we teach students to consider \nthe start-up phase, the steady-state phase, and the shut-down phase of a universe. For all cases, it \nis important to understand (1) the order in which events occur and (2) which S-expressions encode which \nmessages. Our experimentation with the UNIVERSE library suggests that interaction diagrams like those \nused for object-oriented designs based on UML are a good medium for discussing ideas. Instead of spelling \nout this recommendation in detail, however, we illustrate it with a simple example.  5.5 Serving a Turn \nAs mentioned, the coordination among the worlds of a universe depends on the server and the message protocol \nit employs. We and our students have implemented a number of servers. Here we illustrate the power of \nthe UNIVERSE library with the design of a server and some UFO controller clients where each client gets \na turn to control a (local) UFO. We start with the protocol design, followed by the design of the server, \nand then the adaptation of the UFO program from section 4 to support distribution. Protocol Design The \nprose suggests the following, informal and schematic interaction diagram: server The three vertical \nlines are world life-lines, while the horizontal lines are registration or message sending steps. This \nparticular diagram shows the key properties of our pro\u00adposed universe. The server is on the left; the \nparticipating worlds are to its right. After creation, a world registers with the server, which we assume \nsends along a name for the world. Our diagram shows that as soon as a .rst world has registered, the \nserver gives this world a turn without waiting for any other world to show up. If another world shows \nup possibly during some turn the server becomes aware of it but continues to wait for a \"done\" signal \nfrom the world whose turn it is. Once the active world ends its turn, the server gives a turn to the \nnext world on the list. Finally, the dia\u00adgram also shows what happens when a world disappears, say due \nto the closure of a connection. The server notes the disappearance and gives a turn to (one of) the remaining \nworlds. Server Design From here, the design of the server proceeds just like the design of a world program, \nthough we must observe the constraints imposed by the protocol. We start with the required data de.nition: \n;; UniSt = IWld* ;; interp. list of worlds in the order they take ;; turns, starting with the active \none ;; the active world (if any) is first  ;; UniSt IWld . Bundle ;; nw is joining the universe (check-expect \n(add-world (list iworld2) iworld1) (make-bundle (list iworld2 iworld1) () ())) ;; ... more test cases \n... (define (add-world ust nw) (if (empty? ust) (make-bundle (list nw) (m2 nw) ()) (make-bundle (append \nust (list nw)) () ()))) ;; UniSt IWld \"done\" . Bundle ;; mw sent message m; assume mw = (first ust), \nm = \"done\" (check-expect (switch (list iworld1 iworld2) iworld1 \"done\") (make-bundle (list iworld2 iworld1) \n(m2 iworld2) ())) ;; ... more test cases ... (define (switch ust mw m) (local ((define l (append (rest \nust) (list mw))) (define nxt (first l))) (make-bundle l (m2 nxt) ()))) ;; UniSt IWld . Bundle ;; dw \ndisconnected from the universe (check-expect (del-world (list iworld1 iworld3) iworld3) (make-bundle \n(list iworld1) () ())) ;; ... more test cases ... (define (del-world ust dw) (if (not (iworld=? (first \nust) dw)) (make-bundle (remq dw ust) () ()) (local ((define l (rest ust))) (if (empty? l) (make-bundle \n() () ()) (local ((define nxt (first l)) (define mll (m2 nxt))) (make-bundle l mll ())))))) ;; IWld \n. Mail* ;; create single-item list of mail to w ;; no test cases (define (m2 w) (list (make-mail w \"your-turn\"))) \n Figure 5. A primitive functional server program Note again interpretation that comes with the data \nde.nition. It has several implications for the design of the event handlers. Since this server deals \nwith three kinds of events registration of a world, message receipt, and disconnection of a world from \nthe universe we need three event handlers. The UNIVERSE spec\u00adi.cations and the agreement to send certain \nmessages dictate the contract statements: ;; add-world : UniSt IWld . Bundle ;; switch : UniSt IWld \"done\" \n. Bundle ;; del-world : UniSt IWld . Bundle The names of the three functions are suggestive of their \npurpose. Just as in the case of the UFO controller, we can design these functions in a systematic manner. \nIn support of unit tests for event handlers in a server, UNIVERSE exports three sample worlds iworld1, \niworld2,and iworld3; of course, it does not export the capability of creating representations of participating \nworlds. Otherwise, the design of these three server functions proceeds in a straightforward fashion. \nThe three de.nitions and fragments of their test suites are dis\u00adplayed in .gure 5:6 1. the top-left box \ncontains the code for adding a world; 2. the box in the bottom-left de.nes the function for dealing \nwith a message from the active world, which is the only kind of messages that the server expects; 3. \nthe top-right box concerns the event of a world disconnecting from the universe; and 4. the .nal box \nin the bottom right contains the de.nition of a auxiliary function for creating a list of mail to a single \nworld.  As far as the server is concerned, the only task left to do is to for\u00admulate the universe expression \nand to evaluate it at DrScheme s reply to start the server: 6 The de.nitions use the local construct \nfrom the HtDP teaching lan\u00adguages. Roughly speaking, (local defs body) introduces the mutually recursive \nde.nitions defs for the evaluation of body. Unlike Scheme s internal de.nitions, local de.nitions have \nthe exact same semantics as global de.nitions but come with a restricted lexical scope. (universe () \n(on-new add-world) (on-msg switch) (on-disconnect del-world)) Adding this expression to the bottom launches \na process that waits for TCP/IP events and deals with them by invoking one of the three event handlers. \nClient Design To illustrate how the client side works, let us consider a small change to our UFO controller \nfrom the preceding section. Suppose we give each player a turn to land a UFO and that when the UFO touches \nthe ground, it is the next world s turn. One obvious implication is that there is now a distinct new \nkind of state of the world: ;; WorldSt is one of: ;; ---\"rest\" ;; ---(make-ufo Nat Nat Int Int) When \nit isn t this world s turn, the world is in a \"rest\" state. Next we replace the event handler for ticks \nwith a function that sends out messages when the UFO lands: ;; WorldSt . (. WorldSt Package) (define \n(move.global w) (cond [(string? w) w] [else (local ((define v (move w))) (if (not (landed? v)) v \n (make-package \"rest\" \"done\")))])) The function distinguishes the two cases from the data de.nition. \nFor a string, it returns the world as is. Otherwise, it moves the world using the old move function and \nthen checks whether the UFO has landed; if so, the new event handler produces a package. In addition, \nwe need a handler for \"your-turn\" messages: ;; WorldSt \"your-turn\" . WorldSt ;; assume: messages arrive \nonly ;; if the state is \"rest\" (define (receive w msg) (make-ufo 20 10 -1 +1))  ;; WorldSt (WorldSt \n. WorldSt) (WorldSt KeyEvt . WorldSt) (WorldSt Nat Nat MouseEvt . WorldSt) [Listof Event] ;; . ;; WorldSt \n;; process a list of events given the initial world and event handlers (define (big-bangF w0 tickH keyH \nmouseH loe0) (local (... dispatch: see below, on the right ... ;; accumulator design: w is the result \nof dealing with all events between loe0 and loe (inclusive) (define (big-bangF w loe) (cond [(empty? \nloe) w] [else (big-bangF (dispatch w (first loe)) (rest loe))]))) (big-bangF w0 loe0)))  (define-struct \ntick ()) ;; WorldSt Event . WorldSt (define-struct key (kind)) ;; deal with a single event, given the \nstate of the world (define-struct mouse (x y kind)) (define (dispatch w e) ;; An Event is one of: (cond \n;; ---(make-tick) [(tick? e) (tickH w)] ;; ---(make-key KeyEvt) [(key? e) (keyH w (key-kind e))] ;; ---(make-mouse \nNat Nat MouseEvt) [(mouse? e) (mouseH w (mouse-x e) (mouse-y e) (mouse-kind e))])) Figure 6. The semantics \nof functional event handling Unlike move.global, receive does not distinguish two kinds of worlds. Whether \nthe world is in a resting state or not, the function returns some UFO. The revised main function registers \nthe world with the server and speci.es a name for the world that is used for registration: ;; String \n. WorldSt (define (main-for-client n) (big-bang \"rest\" (on-tick move) (on-draw renderR) (on-rec receive) \n (name n) (register LOCALHOST))) Here we assume the server is running on the same computer as the client \nand that renderR renders the new kind of worlds. Note: The design assumes that all participating worlds \nand the server implement the protocol correctly. The assumptions above suggest how functions may protect \nthemselves against errors in the implementations or attacks. The reader may wish to explore the small \nchanges needed to check those assumptions.  6. Design and Curriculum Designing reactive programs in \na purely functional manner comes with several advantages. For one, it is straightforward to explain big-bang \nas if it were a function. As .gure 6 shows, this function traverses a list of events,7 accumulating the \nchanges to the initial world. Also, it uniquely .ts in with our design curriculum, which covers functional \ndesign followed by courses on logical reasoning and object-oriented design. 6.1 Design Recipe HtDP introduces \nits teaching programming languages as a general\u00adization of school mathematics. Instead of functions over \njust num\u00adbers, these languages can express functions and expressions that deal with atomic data (numbers, \nsymbols, chars, strings, images, boolean data) and compound data (structures, vectors, and lists). In \n7 Our implementation replaces the list with an imperative stream of events, plus a thread for receiving \nmessages from the server. The stream dispatcher and the thread are coordinated via the CML-inspired synchronization \nprim\u00aditives of PLT Scheme. the third and fourth part of the book (and its teaching languages) lambda \nand local de.nitions are added. Programming is developed as the systematic design of compu\u00adtational solutions \nto word problems. The design of individual functions follows a general six-step procedure paired with \na sys\u00adtematic development of data de.nitions. The design of programs is presented as an iterative re.nement \nprocess, comparable to the scienti.c process of developing models of the world. Speci.cally the program \nis the model, and the world is the set of our (or our client s) objectives. As we re.ne the program, \nour model satis.es more and more of the objectives. Obviously, this design recipe also applies to the \ndesign of I/O functions for world and universe programs. The key is that UNI-VERSE translates external \ninformation into internal data and in\u00advokes the event handlers on the latter. Furthermore, the event \nhan\u00addlers produce only internal data, which UNIVERSE then displays as external information. The translations \nare hidden from the students transformations. Hence, the process of formulating contracts, func\u00adtional \nexamples, etc. remains the same. Because images are just another form of atomic data, the design recipe \neven applies to the rendering functions that produce complex graphical scenes. The separation of the \nactual act of performing I/O from the pro\u00adcessing or production of I/O data is critical for effective \ntesting. It empowers a programmer to unit-test every single function, cover\u00ading the complete chain from \nwhere input data appears to the point of where output data is delivered. As a matter of fact, this covers \nthe testing of image-producing functions for which we recommend two different testing strategies. The \n.rst is to develop an expression in the read-eval-print loop of DrScheme that creates an image for sim\u00adple \ninputs. This kind of experimentation suggests both an expected value expression as well as the body for \nthe desired function. The second strategy is to create the expected image separately: (check-expect (create-ufo) \n) (check-expect (render-world (make-ufo ...)) (place-image  ... ... (empty-scene SIZE SIZE)) As \nthe second check-expect speci.cation shows, it is of course possible to mix and match those two strategies. \nOnce tests are developed, DrScheme s built-in test coverage tool pin-points those expressions that haven \nt been evaluated during a  (define world% (class fun-world% (super-new) (init-field ufo) (field [MT \n(empty-scene 500 500)]) ;; . world% ;; deal with a tick event in this world (define/augment (tick) (new \nworld% [ufo (send ufo move/tick)]) ) ;; . scene<%> ;; render this world as a scene (define/augment (render) \n(send ufo render MT)))) (define ufo% (class object% (super-new) (init-field x y dx dy) (field [UFO (overlay \n(rectangle ...) (circle ...))]) ;; . ufo% ;; move this ufo for one tick (define/public (move/tick) (new \nufo% [x (+ x dx)][y (+ y dy)][dx dx][dy dy]) ) ;; . scene<%> ;; add this ufo to the given scene s (define/public \n(render s) (place-image UFO x y s)))) (define world% (class imp-world% (super-new) (init-field ufo) \n(field [MT (empty-scene 500 500)]) ;; . void ;; deal with a tick event in this world (define/augment \n(tick) (send ufo move/tick) ) ;; . scene<%> ;; render this world as a scene (define/augment (render) \n(send ufo render MT)))) (define ufo% (class object% (super-new) (init-field xydx dy) (field [UFO (overlay \n(rectangle ...) (circle ...))]) ;; . void ;; effect: change this ufo s coordinates, for a move (define/public \n(move/tick) (begin (set! x (+ x dx)) (set! y (+ y dy))) ) ;; . scene<%> ;; add this ufo to the given \nscene s (define/public (render s) (place-image UFO x y s))))  Figure 7. Applicative and imperative world \nclasses test run. We want novice programmers to attempt to cover all ex\u00adpressions, except for those that \nconnect the event handlers to the un\u00adderlying operating system (big-bang, universe). While com\u00adplete \ncoverage is a good .rst goal, the design of reactive programs tends to demonstrate that unit testing \ndoes not suf.ce. Even when an individual reactive function passes all unit tests, the composition of \nall the reactive functions to deal with a large stream of events of\u00adten concocts scenarios that the unit \ntests don t cover. Put differently, reactive programming demands some amount of integration testing, \ntoo. Given our list of events semantics, programmers can usually mimic these scenarios with the composition \nof event handlers. Last but not least, because the event handlers are just functions, we can also subject \nthem to the functional random testing (Claessen and Hughes 2000) tools now built into DrScheme or its \ntheorem proving environment (Eastlund 2009). Indeed, programmers who learn to formulate conjectures and \nvalidate conjectures via random testing are ideally prepared to study the automated veri.cation of interactive/reactive \nprograms.  6.2 Reasoning about Worlds and Universes During their second semester at Northeastern University, \ncomputer science majors study the logic of computation. The course com\u00adbines a standard theoretical introduction \ninto logic with practical hands-on exercises based on the ACL2 system (Boyer and Moore 1996); see our \nexperience report on the test run of this course (East\u00adlund et al. 2007). Roughly speaking, the ACL2 \nsystem consists of an applicative Common Lisp and an automatic theorem prover based on .rst-order classical \nlogic. Two years ago we extended the ACL2 system with the UNI-VERSE library, enabling students to write \nreactive games, formu\u00adlate conjectures about the safety of their game programs, and prove them correct \nvia the ACL2 theorem prover (Eastlund and Felleisen 2009). Here is a typical theorem from such experiments: \n(defthm preserve-safety (implies (safe-state game-state) (safe-state (tick game-state))) When the theorem \nprover fails, students are encouraged to subject their conjectures to our ACL2 random tester (Eastlund \n2009). The mechanized proofs are based on the semantics of the big-bang function in .gure 6 and a more \ngeneral version for universes of world programs. Speci.cally, a macro unfolds claims about a speci.c \ninstance of big-bang expressions into an appli\u00adcation of a function like big-bangF to all possible lists \nof events.  6.3 On to Classes At the same time as freshmen learn to formulate claims about their functional \nanimation programs and to prove them correct, they are enrolled in a parallel course on design in the \ncontext of class-based object-oriented languages. We prepare the transition at the end of the .rst semester \nwith some simple conventions and arrangements. Speci.cally, instead of arranging functions by feature \n(e.g., all rendering functions in one place, all key-event related functions somewhere else), we organize \nfunctions around data de.nitions. For example, we start with all event handlers for WorldSt: ;; WorldSt \nis one of ... ;; WorldSt . WorldSt (define (world-tickh w) ...) ;; WorldSt . Scene (define (world-render \nw) ...) ;; WorldSt KeyEvt . WorldSt (define (world-keyh w ke) ...) and follow it up with an arrangement \naround UFO: ;; UFO is one of ... ;; UFO . UFO (define (ufo-move u) ...) ;; UFO Scene . Scene (define \n(ufo-add-to-scene u s) ...) ;; UFO Symbol . UFO (define (ufo-chg u dir) ...)  We always make the current \nstate the .rst parameter of a function, analogous to the implicit this parameter in methods. An experienced \nprogrammer can immediately see that program\u00adming functional I/O methods is notationally even more convenient \nin a class-based context than in a functional language. In contrast to functions, methods are de.ned \nin a context where all the pieces of a world are accessible as .elds. Consider the left-hand side of \n.gure 7. It displays a version of the UFO program in PLT Scheme s class system (Flatt et al. 2006).8 \nThe functions from section 4 have been turned into methods of a class world% and ufo%. Each event-handling \nmethod returns a new instance of the class. Instead of selectors, the methods use .eld names to access \nthe current values of the world state. Furthermore, the world% class is derived from an abstract class \nthat provides default functionality for all event handlers and the imperative func\u00adtionality for connecting \nevent-handling methods to the machine s devices. It naturally motivates inheritance and overriding. Finally, \nwhile an applicative world design with classes is no\u00adtationally superior to a structure-based design, \nit still suffers from the notational overhead of creating new objects for every transfor\u00admation. The \nmove/tick ( move per tick ) method in ufo%,for in\u00adstance, copies both the dx and the dy .eld into the \nnew instance. Compare this method with move/tick in the imperative variant of ufo% on the right-hand \nside of .gure 7. In general, the tran\u00adsition from a state-transforming functional program to an imper\u00adative \nobject-oriented program is straightforward, easy to explain, and thus clari.es to students how the design \nprinciples of their .rst, functional experience carries over to the languages they expect to encounter \nin college.  7. Related Work From a technical perspective, the Clean Event I/O system (Achten and Plasmeijer \n1995) comes closest to our approach.9 The Clean programming language supports so-called abstract I/O \ndevices to which programs attach event handlers. In contrast to our event handlers, a Clean event handler \nhas the following signature ;; WorldSt \u00d7*DeviceSt . WorldSt \u00d7*DeviceSt where DeviceSt type represents \nthe state of an abstract I/O de\u00advice. The * notation on a type adds a linearity constraint on the type; \nthe type system enforces this linearity constraints for the matching function parameter. For event handlers, \nthe linearity con\u00adstraint means that reading and writing to the I/O devices is enabled and translated \ninto ef.cient imperative actions. Naturally, linearity constraint also has implications for the design \nand organization of event handlers, making them look like imperative functions. Our I/O framework supports \nonly devices (windows, keyboards, mouse clicks, clocks) whose state can be supplied all at once when \nan event handler is invoked. Conversely, if a state needs to change, the event handlers don t write to \nthe device. Instead, the library uses an orthogonal rendering function to translate the state into an \nimage that it displays, or it allows event handlers to return an additional value that it writes to a \nTCP port. In short, because our framework completely decouples event processing from writing to a device, \nthere is no need in our framework to use linearity types and to thread the state of a device through \nan event handler. An additional difference between Clean and UNIVERSE con\u00adcerns the nature of the devices. \nIn Clean I/O devices are abstract types; in UNIVERSE the rendering functions translate states into 8 \nIn our courses and workshops, we use Java. 9 Acten (with Weirich, 2000) turned the Clean Event I/O system \ninto the Clean Object I/O system and later ported it to Haskell (Achten and Jones 2001). Daan Leijen \nprovided a binding to the wx media kit, now known as the wxHaskell toolkit [Achten, personal communication, \nFeb. 2009]. concrete types (images). This concreteness enables UNIVERSE pro\u00adgrammers to test all functions \nof an interactive graphical program, including those that produce output. Contrast this situation with \nthe use of an abstract device type in Clean and of the I/O monad in Haskell. The testing of I/O functions \nin such a framework is similar to the testing of imperative procedures, requiring elaborate set-up and \ntear-down steps. We consider this activity out of reach for mid\u00addle school students and distracting for \ncourses that focus on design. Functional reactive programming (FRP) (Elliot and Hudak 1997) overcomes \nthis problem by enabling programmers to write in a functional style over imperative values (event streams, \nbehav\u00adiors). The programmer effectively describes a data.ow graph via expression dependencies; the run-time \nsystem updates values using this graph. While programming with event streams and behaviors is truly elegant, \nour pedagogic experience has been that the neces\u00adsity of operators like switch puts it out of the reach \nof novices. Technically, FRP also has the disadvantage of requiring devices to be adapted to behave as \nreactive elements, which is a research problem that has been solved only partially (Ignatoff et al. 2006). \nErlang (Armstrong et al. 1996) factors its I/O framework in a different but related manner. A distributed \nprogram in Erlang also consists of world-transforming event handlers, though such a program also need \na process-local loop to keep track of the state. Our UNIVERSE library naturally separates these two concerns \nby factoring out the common loop from the server and the participants. From a pedagogical perspective, \nvan Dam and his colleagues (1987, 1995) pioneered the event-oriented approach for teaching novices in \nthe 1980s, but via imperative object-oriented program\u00adming. Bruce et al. (2001, 2004) resumed this direction \nin the early 2000s. We consider the functional alternative presented here even more useful than an imperative, \nobject-oriented approach. On one hand, a functional approach is close to the mathematics that stu\u00addents \nencounter, meaning our approach promises a straightforward skill transfer. While we have only anecdotal \nevidence so far, we are convinced that a formal evaluation would con.rm this con\u00adjecture. On the other \nhand, we consider object-oriented program\u00adming for novices an overkill because beginners don t have pro\u00adgrams \nof enough complexity to bene.t from the structuring that object-orientation provides and demands. Chakravarty \nand Keller (2004) share our analysis concerning the teaching of functional programming languages in the \n.rst course as well as the problems of Haskell I/O. Their reaction is to turn this weakness of Haskell \ninto an advantage. Speci.cally, the course switches perspective, emphasizing the imperative character \nof I/O actions and the need for ordering actions. While we acknowledge the pedagogical need for a transition \nto imperative programming, we consider this strategy a kludge and prefer the systematic ap\u00adproach via \nobjects explained in section 6.3. After all, postponing I/O suggests that functional programming can \nt cope with the full spectrum of programming tasks and fails to exploit it for the moti\u00advational aspects \nof assignments. An alternative and appealing solution is due to Achten (2008), who packaged up one special-purpose \ncase study (playing soccer) along the lines of our framework. Sadly focusing on soccer limits the appeal \nof the framework to certain cultures and countries. Finally, Hudak and Peterson each brie.y taught Haskell-based \nfunctional programming to small groups of selective middle school and high school students. Both arranged \nlectures around Haskore and Pan but did not use any texts [Hudak and Peterson, independent personal communication, \nFeb. 2009.]  8. Conclusion Our work demonstrates that with a suitable I/O framework, purely functional \nprogramming is an engaging medium for students of all ages. The Bootstrap effort routinely guides middle \nschool students without apparent mathematical talent to write interactive games in a language that is \nbasically equivalent to high school algebra. For freshman students, we exploit the same framework to \nsimultane\u00adously strengthen their mathematical skills and to introduce them to the basics of program design. \nIn one second-semester course, stu\u00addents even use an automatic theorem prover to establish interesting \nproperties about such interactive games. At the same time, event\u00addriven programming can also be used \nto prepare freshmen for a course on object-oriented programming.  Our work relies on two key insights \nand one technicality. First, it is important to leave the translation of external information into internal \ndata (structures) to the framework and vice versa. As far as students are concerned, these are tasks \nthat the computer and/or the operating systems takes on for the program. Second, the framework must separate \nevent handling (as state transitions) from rendering (from states to images, sounds, or message transmission). \nThis sep\u00adaration of concerns empowers novice programmers to design one function per task, without worrying \nabout ordering any computa\u00adtional actions. One DrScheme-speci.c technicality facilitates the second step: \nturning images into .rst-class values. Although insert\u00ading images into programs and dealing with them \ndirectly at an in\u00adteractive read-eval-print can be especially helpful, we don t expect this technicality \nto be critical for an adaptation of our approach to other functional languages. In short, we conjecture \nthat every func\u00adtional language can easily supplement its I/O system with a library such as ours and \ncould thus become an appealing medium for a range of educational applications. Acknowledgments We gratefully \nacknowledge the help of many people: Carl Eastlund for feedback on the design and for discus\u00adsions concerning \nits logical content; Kathi Fisler for using experi\u00admental releases of the library in her courses; Emmanuel \nSchanzer for creating and coordinating the Bootstrap outreach program; and Danny Yoo for extending the \nlibrary with hierarchical GUI features.  References Peter Achten. Teaching functional programming with \nsoccer-fun. In Proc. 2008 International Workshop on Functional and Declarative Program\u00adming in Education, \npages 61 72, 2008. Peter Achten and Simon L. Peyton Jones. Porting the Clean object I/O li\u00adbrarytoHaskell. \nIn IFL 00: Selected Papers from the 12th International Workshop on Implementation of Functional Languages, \npages 194 213, London, UK, 2001. Springer-Verlag. Peter Achten and Marinus J. Plasmeijer. The ins and \nouts of Clean I/O. J. Funct. Program., 5(1):81 110, 1995. Peter Achten and Martin Wierich. A tutorial \nto the Clean Object I/O library (version 1.2). Technical report, University of Nijmegen, February 2000. \nJoe Armstrong, Robert Virding, Claes Wikstr\u00a8om, and Mike Williams. Con\u00adcurrent Programming in Erlang \n(2nd Edition). Prentice-Hall, 1996. Bird and Wadler. Introduction to Functional Programming (2nd Edition). \nPrentice Hall PTR, 1998. Robert S. Boyer and J Strother Moore. Mechanized reasoning about pro\u00adgrams and \ncomputing machines. In R. Veroff, editor, Automated Rea\u00adsoning and Its Applications: Essays in Honor \nof Larry Wos, pages 146 176. The MIT Press, Cambridge, Massachusetts, 1996. URL citeseer.ist.psu.edu/boyer96mechanized.html. \nKim B. Bruce, Andrea Danyluk, and Thomas P. Murtagh. Event-driven programming is simple enough for cs1. \nSIGCSE Bull., 33(3):1 4, 2001. Kim B. Bruce, Andrea Danyluk, and Thomas P. Murtagh. Event-driven programming \nfacilitates learning standard programming concepts. In Object-oriented programming systems, languages, \nand applications: Educators Symposium, pages 96 100, 2004. Manuel Chakravarty and Gabriele Keller. The \nrisks and bene.ts of teaching purely functional programming in .rst year. J. Funct. Program., 14(1): \n113 123, 2004. Koen Claessen and John Hughes. QuickCheck: a lightweight tool for random testing of Haskell \nprograms. In ACM SIGPLAN International Conference on Functional Programming, pages 268 279, 2000. Carl \nEastlund. DoubleCheck your theorems. In Proc. 8th Intern. Works. ACL2 and its Applications, pages 41 \n46. Lulu Press, 2009. Carl Eastlund and Matthias Felleisen. Automatic veri.cation for interactive graphical \nprograms. In Proc. 8th Intern. Works. ACL2 and its Applica\u00adtions, pages 33 41. Lulu Press, 2009. Carl \nEastlund, Dale Vaillancourt, and Matthias Felleisen. ACL2 for fresh\u00admen: First experiences. In Proc. \n7th Intern. ACL2 Symposium, pages 200 211. ACM Press, 2007. Conal Elliot and Paul Hudak. Functional reactive \nanimation. In ACM SIGPLAN International Conference on Functional Programming, pages 196 203, 1997. Matthias \nFelleisen, Robert Bruce Findler, Matthew Flatt, and Shriram Kr\u00adishnamurthi. How to Design Programs. MIT \nPress, 2001. URL http://www.htdp.org/. Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, and Shriram \nKr\u00adishnamurthi. The TeachScheme! project: Computing and programming for every student. Computer Science \nEducation, 14:55 77, 2004a. Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, and Shriram Kr\u00adishnamurthi. \nThe structure and interpretation of the computer science curriculum. J. Funct. Program., 14(4):365 378, \n2004b. Robert Findler, John Clements, Cormac Flanagan, Matthew Flatt, Shriram Krishnamurthi, Paul Steckler, \nand Matthias Felleisen. DrScheme: A programming environment for Scheme. J. Funct. Program., 12(2):159 \n182, March 2002. Matthew Flatt and Matthias Felleisen. Units: Cool modules for HOT languages. In ACM \nSIGPLAN Conference on Programming Language Design and Implementation, pages 236 248, June 1998. Matthew \nFlatt, Robert Bruce Findler, and Matthias Felleisen. Scheme with classes, mixins, and traits. In Asian \nSymposium on Programming Lan\u00adguages and Systems (APLAS) 2006, pages 270 289, November 2006. Paul Hudak. \nThe Haskell School of Expression: Learning Functional Programming through Multimedia. Cambridge Univ. \nPress, 2000. Graham Hutton. Programming in Haskell. Cambridge Univ. Press, 2007. Daniel Ignatoff, Gregory \nH. Cooper, and Shriram Krishnamurthi. Crossing state lines: Adapting object-oriented frameworks to functional \nreactive languages. In International Symposium on Functional and Logic Pro\u00adgramming, pages 259 276, 2006. \nBryan O Sullivan, Donald Stewart, and John Goerzen. Real World Haskell. O Reilly Media, Inc., 2008. Kris \nPowers, Stacey Ecott, and Leanne Hirsh.eld. Through the looking glass: teaching CS0 with Alice. SIGCSE \nBulletin, 39(1):213 217, 2007. Simon Thompson. Haskell: the Craft of Functional Programming. Addison \nWesley Longman Publishing Co., Inc., 1997.  \n\t\t\t", "proc_id": "1596550", "abstract": "<p>Functional programming languages ought to play a central role in mathematics education for middle schools (age range: 10-14). After all, functional programming is a form of algebra and programming is a creative activity about problem solving. Introducing it into mathematics courses would make pre-algebra course come alive. If input and output were invisible, students could implement fun simulations, animations, and even interactive and distributed games all while using nothing more than plain mathematics. We have implemented this vision with a simple framework for purely functional I/O. Using this framework, students design, implement, and test plain mathematical functions over numbers, booleans, string, and images. Then the framework wires them up to devices and performs all the translation from external information to internal data (and vice versa)--just like every other operating system. Once middle school students are hooked on this form of programming, our curriculum provides a smooth path for them from pre-algebra to freshman courses in college on object-oriented design and theorem proving.</p>", "authors": [{"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northwestern University, Boston, MA, USA", "person_id": "P1613983", "email_address": "", "orcid_id": ""}, {"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "Northwestern University, Evanston, IL, USA", "person_id": "P1613984", "email_address": "", "orcid_id": ""}, {"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "University of Utah, Salt Lake City, UT, USA", "person_id": "P1613985", "email_address": "", "orcid_id": ""}, {"name": "Shriram Krishnamurthi", "author_profile_id": "81100512233", "affiliation": "Brown University, Providence, RI, USA", "person_id": "P1613986", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596561", "year": "2009", "article_id": "1596561", "conference": "ICFP", "title": "A functional I/O system or, fun for freshman kids", "url": "http://dl.acm.org/citation.cfm?id=1596561"}