{"article_publication_date": "08-31-2009", "fulltext": "\n OXenstored An Ef.cient Hierarchical and Transactional Database using Functional Programming with Reference \nCell Comparisons Thomas Gazagnaire Vincent Hanquez Citrix Systems First Floor Building 101, Cambridge \nScience Park, Milton Road Cambridge, CB4 0FY, United Kingdom {thomas.gazagnaire,vincent.hanquez}@citrix.com \nAbstract We describe in this paper our implementation of the Xenstored ser\u00advice which is part of the \nXEN architecture. Xenstored maintains a hierarchical and transactional database, used for storing and \nman\u00adaging con.guration values. We demonstrate in this paper that mixing functional data-structures together \nwith reference cell comparison, which is a limited form of pointer comparison, is: (i) safe; and (ii) \nef.cient. This demonstra\u00adtion is based, .rst, on an axiomatization of operations on the tree\u00adlike structure \nwe used to represent the Xenstored database. From this axiomatization, we then derive an ef.cient algorithm \nfor co\u00adalescing concurrent transactions modifying that structure. Finally, we experimentally compare \nthe performance of our implementa\u00adtion, that we called OXenstored, and the C implementation of the Xenstored \nservice distributed with the XEN hypervisor sources: the results show that OXenstored is much more ef.cient \nthan its C counterpart. As a direct result of this work, OXenstored will be included in fu\u00adturereleasesof \nXENSERVER,thevirtualization product distributed by Citrix Systems, where it will replace the current \nimplementation of the Xenstored service. Categories and Subject Descriptors D.1.1 [Programming Tech\u00adniques]: \nApplicative (Functional) Programming; H.2.4 [Database Management]: Systems Transaction processing; D3.3 \n[Pro\u00adgramming Language]: Language Constructs and Features Data types and structures General Terms Algorithms, \nDesign, Performance Keywords Databases, Transactions, Concurrency, Pre.x Trees 1. Introduction XEN (Barham \net al. 2003) is an open-source type 1 hypervisor, pro\u00adviding the ability to run multiple operating systems, \ncalled guests, concurrently on a single physical processor. Type 1 (or native, bare\u00admetal) hypervisors \nare software systems that run directly on the Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. ICFP 09, August 31 September 2, 2009, Edinburgh, Scotland, UK. \nCopyright c &#38;#169; 2009 ACM 978-1-60558-332-7/09/08. . . $5.00 host s hardware. They have been very \npopular architecture since the CP/CMS (Creasy 1981), developed at IBM in the 1960s. The XEN hypervisor \nis very popular and is used, for example, by the Amazon Elastic Compute Cloud project1 which allows customers \nto rent computers on which they can run their own applications. In a virtual architecture, each guest \nruns securely partitioned from others in a virtualized environment. Using a technique called para-virtualization, \nwhich involves modifying processors admin\u00adistrative instructions into calls into the hypervisor, processors \nef\u00ad.ciencies are close to native performance. When operating system modi.cations are not practical or \nimpossible, the XEN hypervisor leverages the use of special instructions, called VMM instructions. These \ninstructions give the ability to run the guest unmodi.ed but trapping all administrative operations securely. \nIn the XEN architecture, a para-virtualized privileged guest called the control domain is in charge of \nall the I/O needs of the other guests. Consequently, all virtual guests devices (disks, net\u00adwork interfaces) \nhave to be handled at this level too. For example, each guest s virtual disk is associated with at least \na process in the control domain. Subsequently, when a new guest starts, it is nec\u00adessary that the corresponding \nprocesses have already been started in the control domain and con.gured correctly. In the XEN archi\u00adtecture, \nit is thus necessary to have a speci.c service in the control domain to exchange control and con.guration \ndata between guests. This service is called Xenstored and can be seen as a tuple space system, providing \nconcurrent-safe access to a key-value association database. This service has originally been implemented \nin C and is distributed with the XEN hypervisor sources. We will refer to it as CXenstored. This paper \ndescribes another implementation of the Xensto\u00adred requirements, done using Objective Caml (Leroy et \nal. 1996), and we will refer to it as OXenstored. This new implementation uses functional data-structures \nas well as reference cell compar\u00adison (Pitts and Stark 1993; Claessen and Sands 1999), which is a limited \nform of pointer comparison. OXenstored is a .fth of the size of CXenstored (around 2000 lines of code) \nand signi.\u00adcantly improves the performance in several respects: particularly, it increases by a factor \nof 3 the number of guests per host (up to 160). Moreover, we formalized the new algorithms implemented \nby OXenstored and we proved that they are safe, that is concurrent accesses always leave the database \nin a consistent state. Finally, 1 Part of the Amazon Web Services: http://aws.amazon.com/ec2/  as a \nresult of this work, OXenstored will replace CXenstored in future releases of XENSERVER, the virtualization \nproduct com\u00admercialized by Citrix Systems2 which is built on top of the XEN hypervisor. OXenstored sources \ncan be found on: http://xenbits.xen.org/ext/xen-ocaml-tools.hg Consequently, we believe that these arguments \ndemonstrate that (i) functional (and thus immutable) data-structures are the most in\u00adtuitive and simple \ncandidates for manipulating tree-like structured data; and (ii) reference cell comparisons can be used \nin a very safe way to obtain great performance as well as proven consistency. This paper is organized \nas follows: Section 2 gives a high-level overview of the Xenstored service s architecture, as well as \nan example of how it interacts with the XEN framework. Section 3 gives an informal explanation of the \nalgorithm used by OXensto\u00adred. Then, Section 4 formalizes the functional data-structure used in OXenstored \nfor modeling the database and section 5 derives the notion of a transaction in this context. Then, we \nexplain in Section 6 how, unlike CXenstored, OXenstored is able to coalesce concurrent transactions which \nare affecting distinct parts of the database. We conduct some experiments in Section 7 to validate our \napproach and show that, indeed, the simplistic way of handling transactions of CXenstored can makes the \nsystem live-lock in a very common situation (starting a lot of guests), as opposed to OXenstored. Fi\u00adnally, \nSection 8 compares our approach with other work focused on transactional databases and Section 9 discusses \nthe results given in this paper.  2. Xenstored Design and Use-Case We give in Section 2.1 an overview \nof the design of the Xenstored service and, in Section 2.2, an example use-case of how it interacts with \nthe XEN hypervisor. 2.1 Overview of the Xenstored Design The Xenstored service is a single-threaded daemon, \nrunning in the control domain. It is the central point of communication, as guests communicate to each \nothers using it. Basically, it is a .le-system\u00adlike database, where control data is hierarchically organized. \nThere is two different ways a client can connect and communi\u00adcate with the Xenstored service: First, \nusing the ring buffers. These are two circular buffers stored inside in the guests memory: one for sending \nrequest to the Xenstored service and one for reading its replies.  Second, using the Unix sockets. These \nare accessible only for processes running inside the control domain. Clients of the Xenstored service \nuse the standard Unix read and write oper\u00adations to access to the database.  From the client point of \nview, the Xenstored service offers a hi\u00aderarchical key-value association database which has the following \nproperties: Structured key database Contents in the database are structured into nodes which are addressed \nby Unix .lesystem-style paths. For example, the ith guest stores its virtual-disk con.guration under \nthe path /local/domain/i/device/vbd/ in a XEN\u00adbased system. Each path corresponds to a node in the database \nand it can store a value even if it has some children. 2 Citrix Systems, http://www.citrix.com. Simple \ndatabase operation The clients of the Xenstored service (which are either guests or are components running \ninside the control domain) have only a small set of atomic operations to set and get the contents from \nthe database: write: create or modify a new path;  read: get the value associated with a path;  mkdir: \ncreate a new node in the database;  getperm: get the permissions of a node;  setperm: set the permissions \nof a node.  Noti.cation The clients of the Xenstored service can ask to be noti.ed of changes in a node. \nWhen a node is changed or created, all the guests watching this node or a parent of this node will be \nnoti.ed asynchronously that a speci.c path has been modi.ed. Permissions Each node has its own permissions. \nA permission is made up of an owner, which has all privileges on the node, and an access control list \nwhich speci.es who is allowed to access or modify the node. Quotas Unprivileged guests can be limited \nin the number of nodes they are authorized to create. This permits the Xenstored ser\u00advice s memory usage \nto stay at reasonable levels and this pro\u00adtects the control domain memory from malicious guests. Transactions \nThe clients of the Xenstored service have the abil\u00adity to run a set of multiple operations modifying/reading \nthe database in an atomic fashion. From the start to the end of the transaction, the Xenstored service \nwill ensure that the database stays consistent. If a transaction cannot be made consistent, then the \nXenstored service will reply to the client that the transaction needs to be retried. A client can have \nmultiple opened transac\u00adtion at the same time, and thus each transaction needs to be identi.ed by a unique \ntransaction ID whenever a client sends a request to the Xenstored service, it will associate to its \nrequest such a transaction ID. A transaction ID of 0 means that the re\u00adquest is not associated to a transaction \nand will be executed directly. These requirements have originally been implemented in CXen\u00adstored. However, \nin CXenstored, transactions are handled in a sim\u00adplistic way. In a set of concurrent transactions, only \none would be able to successfully complete, all the other transactions would have to retry from the beginning. \nThis way of handling multiple con\u00adcurrent transactions makes the mechanism really simple to provide consistency, \nhowever it also adversely affects the performance of the system: when the number of concurrent transactions \nis high, a slow or long transaction will be disadvantaged in an environment when only the .rst to .nish \ncan be completed successfully. In case a client of the Xenstored service is doing a small and fast transac\u00adtion \nin a loop, this will cause a live-lock and some transactions of other clients will never be able to complete. \n 2.2 Example Use-Case In this section we give a small example which describes the se\u00adquence of steps \ninvolved when starting a new guest. This sequence of steps involves three different clients of the Xenstored \nservice: The Control domain s Kernel (CK). The kernel of the control domain is able to set up the virtual \ndisk drivers and the virtual network drivers inside the control domain, for the new guests.  The new \nGuest Kernel (GK). When running, the kernel of the guest will try to connect to its virtual disk and \nnetwork drivers which should be running inside and exported by the control domain.   The management \nTool-Stack (TS). It is running inside the con\u00adtrol domain and it receives direct orders from the user. \nPartic\u00adularly, when a user wants to start a speci.c guest, the manage\u00adment tool-stack is in charge of \ninitiating the guest start protocol. Starting a guest can be summarized as follows. Lines are pre\u00ad.xed \nwith the name of client doing the action (ie. (CK), (GK) or (TS)). Almost all of these steps should be \ndone atomically (ie. us\u00ading transactions) in order to not pollute the con.guration database in case one \nof the three clients fails. (TS) The management tool-stack queries the XEN hypervisor to cre\u00adate a fresh \nguest. At this point, the guest is paused. The XEN hy\u00adpervisor responds to the management tool-stack \nby giving i,the ID of the created guest. Then, the management tool-stack cre\u00adates a collection of paths \n/local/domain/i/devices/... in the database. (TS) The management tool-stack noti.es the control domain \ns kernel (whose guest ID is 0) that it wants to set up some kernel devices by atomically writing a collection \nof con.guration keys in /local/domain/0/backend/.... (CK) The control domain s kernel is watching for \nmodi.cations on the path /local/domain/0/backend, and thus is noti\u00ad.ed by the Xenstored service that \nsomeone wants it to con\u00ad.gure new drivers inside the control domain. Once this is done, the control domain \ns kernels write some special values in /local/domain/0/backend to notify the management tool\u00adstack that \nthe devices are ready. (TS) The management tool-stack is noti.ed that the devices are ready inside the \ncontrol domain. It can now ask the XEN hypervisor to really start the guest. (GK) When the guest kernel \nis booting, it will read the con.guration values put in /local/domain/i/devices/... by the man\u00adagement \ntool-stack. Using these data, it will be able to con.g\u00adure the data-path of its devices correctly, through \nthe drivers of the control domain s kernel.  3. Informal Description of the Algorithm Basically, the \ndatabase of OXenstored is modeled as an immutable pre.x tree (Okasaki 1999). Each transaction is associated \nwith a triplet (T1, T2, p), where T1 is the root of the database just before the transaction starts, \nT2 is the current local copy of the database with all updates made by the transaction up to that point \nin time, p is the path to the node furthest from the root of T2 whose sub\u00adtree contains all the updates \nmade by the transaction up to that point. The transaction updates T2 by substitution and copying all \nthe nodes from the root of T2 to the node where the substitution takes place. At the end of the transaction, \nthe system tries to com\u00admit. At this point, the system checks if T1 is still the root of the current \ndatabase. If it is, it just commits by setting T2 to be the current database. If it is not, it checks \nif the subtree at p in T1 is same as the subtree at p in the current database. If it is, it means that \nno-one has yet touched the nodes touched by the transaction, so it just commits by substituting the subtree \nat p in the database by the subtree at p in T2. Otherwise, someone must have touched the nodes touched \nby the transaction, and therefore the transaction must abort to ensure serialisability (H\u00a8arder and Reuter \n1983). Let us now consider a small example to see how this algorithm works. Let us consider an initial \ndatabase associating 0 to e,5to a and 4 to b, and a transaction trying to associate 7 to b.This transaction \nis represented by the triplet (T1, T2, b), where T1 and T2 are two pre.x trees sharing in memory the \nsame node associated to the key a, as described in Figure 1. Moreover, let us assume that T , the pre.x \ntree described in this .gure, is the state of the database just before committing the transaction. When \ncommitting (T1, T2, b)to T , the system observes .rst that T1 and T s roots are not in the same memory \nlocation. However, the subtree at b in T1 is the same as thesubtreeat b in T . Thus, the new database \nstate becomes the pre.x tree T ' in .gure 1, which is the substitution of the subtree at b in T by the \nsubtree at b in T2. In the next sections, we formalize that algorithm and demonstrate that it works correctly. \nT2 T1 T T ' Figure 1. An example of how the algorithm implemented by OXenstored works.  4. Database \nRepresentation In this section we introduce the data structures we decided to use for internally representing \nthe OXenstored database, namely the pre.x trees,or simply tries (Fredkin 1960), which are ef.cient structures \nfor representing dictionaries. We only consider functional tries, ie. data-structures whose states are \nnot mutable: an update operation on these structures creates a new structure and tries to share as much \ndata as possible with the previous one. We .rst give in Section 4.1 some general de.nitions and properties \nof tries and we explain in Section 4.2 the more precise assumptions and choices we made for implementing \na trie library in Objective Caml:this leads to an axiomatization of the trie data-structure library on \nwhich the following sections can rely on to prove the correctness of our transaction-coalescing algorithm. \n 4.1 Basic Materials First, let us .x a .nite set K of keys and let us consider the free monoid K*, ie. \nthe set of string over alphabet SK, de.ned as the in.nite set of (possibly empty) key sequences n.N and \nthe Kn composition law, having the empty sequence e as neutral element and for which uv = a1 ...anb1 \n...bm if u = a1 ...an and v = b1 ...bm;and ue = eu = u.Elements of K* are called paths. A pre.x of u \n= a1 ...an is either e,ora path a1 ...ak with k .{1 ...n}. A strict pre.x of u is either e or a path \na1 ...ak with k<n. Moreover, the size of a path u, denoted by |u|,is the number of elements contained \nin the sequence; more formally, |a1 ...an| = n and |e| =0. In OXenstored, a path is represented as a \nslash-separated list of names, as /local/domain/0/device. This path can be understood as the sequence \nof keys a1a2a3a4, where a1 = local, a2 = domain, a3 = 0 and a4 = device. Second, let us .x a .nite set \nV of values.A trie is a structure which partially maps paths to values. Thus, it can also be consid\u00adered \nas a total function T : K* . (V. {.}),where . is a special symbol introduced to denote the fact that \na path has no associated value.  Finally, the singleton trie associating a value x with the path e and \n. to anything else is denoted by {x}. The in.nite collection of tries is denoted by T(K, V) or simply \nby T. Tree Representation In practice, this hierarchical mapping can be used to optimize space utilization \nof a trie: indeed, it can then be implemented as a .nite tree whose nodes and edges are labelled by values \nand keys respectively. Such a tree T can be decomposed into a structure (x, {ai,Ti}i.I),where x .V, I \n= {1 ...n} and for any i .I, ai .K and Ti . T such that: T (e)= x;  For any u = bv .K * such that b \n.K, v .K *,we have:  If T (b)= . then there is no i such that ai = b;  Otherwise T (u)= Ti(v) where \ni is such that ai = b.   Thus, for any path u in K * the value associated with u in T is either T (u) \n.V if there is a node associated with the path u in the tree representing T ,or T (u)= . otherwise. Figure \n3 shows such a trie T :paths /vm/0, /vm/1 and /vm/2 share the same pre.x /vm and thus the values T (/vm/0), \nT (/vm/1) and T (/vm/2) are stored in thesamesubtreeat /vm in T . For this trie, we also have T (/vm/3)= \n.. We are now ready to de.ne basic operations on tries. We con\u00adsider in this paper two operations, namely \nthe substitution and re\u00adstriction. Substitution First, the substitution operation consists to replace \nany subtree of the original trie by another subtree. More formally, the trie substitution can be de.ned \nas follows: given two tries T1 and T2 in T and a path u in K *, the substitution of T1 on path u by T2, \ndenoted by T1[u/T2], is a new trie such that, for any path v and w in K *,we have T1[u/T2](uw)= T2(w) \nand if u is not a pre.x of v,then T1[u/T2](v)= T1(v). We can also extend these notations to de.ne T [u/x] \nwhere T . T can be decomposed into (y, {ai,Ti}), u .K * and x .V, to be the substitution T [u/(x, {ai,Ti})]. \nRestriction Second, the restriction operation selects a speci.c subtree in the initial tree: given a \ntrie T in T and a path u in K * , the restriction of T to u, denoted by T |u, is a trie such that, for \nany path v in K * , (T |u)(v)= T (uv). The trie T |u is also called a sub\u00adtrie of T . The restriction \noperation might also be seen as a partial application on tries. Figure 3 shows an example of trie restrictions: \nthe trie whose nodes are labeled by b, d, e and f is a sub-trie of T , obtained its restriction to the \npath /vm, ie. it is T |/vm.  4.2 Axiomatization using Reference Cell Equality When the question of implementing \nthe substitution and restric\u00adtion operators de.ned above in an ef.cient trie library arises, the programmer \nstill has a lot of freedom: the given de.nitions do not explain directly how to express the substitution \nand restriction in terms of tree operations. Indeed, the above de.nitions hold for path/value associations \nonly and nothing is said about the location of these values. In particular, nothing is speci.ed about \nsubtree sharing. However, every modern compiler of functional languages, such as Objective Caml (Leroy \net al. 1996) or Scheme (Serrano 2000), enforces that multiple copies of an immutable structures share \nthe same location in memory. is possible to design a trie li\u00adbrary which enforces the sharing of subtrees \nas much as possible. In order to de.ne more formally the notion of sharing, the refer\u00adence cell equality \n(Pitts and Stark 1993; Claessen and Sands 1999), denoted by =, has been introduced. This equality, also \nknown as physical equality, is a limited form of pointer equality. It compares the location of values \ninstead of the values themselves and thus can be used to observe value sharing: two values are shared \nif they have the same location, that is, if they are physically equal. In light of this discussion, Figure \n2 rede.nes the substitution and the restriction in order to enforce the sharing of values: rules (E1) \nand (E2) focus on the behavior of physical equality only; rules (S1), (S2), (S3) and (S4) focus on the \nsubstitution operator and its inter\u00adactions with the restriction operator; .nally, rules (R1), (R2) and \n(R3) focus on the restriction operator only. These de.nitions can be considered as axioms that any implementation \nof tries should satisfy and for which any formal reasoning can rely on. (E1) .T . T, T = T (E2) .T1,T2 \n. T and .u, v .K * , if T1|u = T2|v,then T1(u)= T2(v) (S1) .T1,T2 . T and .u, v .K * , T1[u/T2]|uv = \nT2|v (S2) .T1,T2 . T and .u, v .K* , T1[uv/T2]|u = T1|u (S3) .T1,T2 . T and .u, v .K*,if: cu is not a \npre.x of v and cv is not a pre.x of u then T1[v/T2]|u = T1|u (S4) .T1,T2 . T and .u, v .K* , if v = e,then \nT1[uv/T2](u)= T1(u) (R1) .T . T, T |e = T (R2) .T . T and .u, v .K * , T |u|v = T |uv (R3) .T1,T2 . T \nand .u .K * , if T1 = T2,then T1|u = T2|u Figure 2. Axiomatization of the reference cell equality on \ntries, with respect to substitution and restriction operations. Physical Equality More informally, .rst \nof all, the two .rst rules are related to the reference cell equality behavior only. Rule (E1) states \nthat a given symbol always physically represents the same trie and rule (E2) states that reference cell \nequality implies usual structural equality: if the reference cells of two tries are identical, then they \nalso associate the same values to the same keys. Substitution Second, the next four rules are related \nto the sub\u00adstitution operator and its interactions with the restriction one. Rule (S1) states that sub-tries \nof a substituted trie are physically equiv\u00adalent to sub-tries of the newly inserted trie. Rule (S2) states \nthat nodes which are on the path of the substitution are never physi\u00adcally equivalent to the respective \nnodes in the initial trie: they cor\u00adrespond to newly allocated reference cells. Rule (S3) states that \nnodes which are not related to the substitution are not modi.ed, ie. substitution is a local operation \nwhich enforces node sharing be\u00adtween tries produced by substitution. Finally, rule (S4) states that even \nthough (S2) states that nodes which are on the path are newly allocated, the value they contain is preserved \nand is still equal to the value of the initial trie. Restriction Finally, the last rules are related \nto the restriction operator. Rule (R1) states that the restriction of any trie to an empty path is the \ntrie itself. Rule (R2) states that it is (physically) equivalent to restrict a trie twice with two given \npath that to restrict a trie by the composition of these two paths. Finally, rule (R3) states that if \ntwo tries are physically equal, then their restriction to the same path are also physically equal.  \nTree Representation The tree representation introduced in Sec\u00adtion 4.1 can be then reformulated using \nthe axioms of Figure 2 to be the following: a tree T can be decomposed into a structure (x, {ai,Ti}i.I),where \nI = {1 ...n}, x .V and for any i .I, ai .K and Ti . T such that: T (e)= x;  There is no ai such that \nT (ai)= .;  T |ai = Ti.  In this case, rule (R2) ensures that for any u .K * , T |aiu = T |ai|u,that \nis T |aiu = Ti|u. Finally rule (E2) ensures that T (aiu)= Ti(u). For example, Figure 3 gives the graphical \nrepresentation of a trie T , which can be decomposed as follows: (a, {(vm, (b, {(0, (d, \u00d8)), (1, (e, \n\u00d8)), (2, (f, \u00d8))}), (vss, (c, \u00d8))}) T Figure 3. Example of a tree representation. In this Figure, the \nvalues associated with the paths /vm and /vm/1 are b and e respectively and T |vm designates the sub-tree \nwhose root is labeled by b.  5. Transactions We stated that the Xenstored database can be represented \nas an im\u00admutable trie; this database can then be updated using the trie sub\u00adstitution operator as follows: \nif the trie T . T is the current state of the database, then replacing the value associated with u .K \n* by x .V is done by replacing the current state of the database by the trie T [u/x]. However, Xenstored \nis a transactional database. That is, it is possible to ask for any sequences of access and modi.cation \nto be done atomically. First of all, in order to simplify the following de.nitions and re\u00adsults, we consider \nany reading operation as an identity substitution: for any trie T in T and path u in K *, getting T (u) \ndoes not modify T but when considering sequences of read/update operations it is necessary to remember \nthat u had been read. So in this case, we write T [u/(T |u)] as rule (S2) of Figure 2 states that in \nthis case T = T [u/(T |u)]. However, it is possible to extend the de.nitions and results we present in \nthis paper to reading operations which do not update the database state. We can now de.ne transactions: \nDe.nition 5.1 (transaction). A transaction is a sequence of substi\u00adtutions. That is, a transaction s \nbelongs to (K * \u00d7 T) *, ie. either s is the empty sequence e or s =[u1/T1] ... [un/Tn],where for any \ni .{1 ...n}, ui .K* and Ti . T. Such a sequence can be applied to an initial trie T . T in order s to \nobtain a new trie T ' . T, which is denoted by T -. T ' .This application consists of sequential application \nof each substitution [ui/Ti] for i from 1 to n,that is: T ' =((... (T [u1/T1]) ...)[un/Tn]) For example, \nlet us consider the following transaction: 1. Write x .V in the path u1 .K* ; 2. Read the value associated \nwith the path u2 .K * ; 3. Write y .V in the path u3 .K * .  Let us have the trie T . T representing \nthe current state of the database. Then the above transaction can be de.ned as: s =[u1/(T1|u1)][u2/(T2|u2)][u3/(T3|u3)] \nwhere T1 is T [u1/x], T2 is T1[u2/T1(u2)] and T3 is T2[u3/y]. s Finally, T ' , the updated state of the \ndatabase is such that T -. T ' . Furthermore, the Xenstored requirements are that transactions can proceed \nconcurrently. That is, multiple connections to the database can be opened and all of them can start independent \ntrans\u00adactions. As we consider immutable data-structures, this is not a problem: for each transaction \nstarted, the initial database is copied ef.ciently (as it is suf.cient to copy only the location of the \ntrie root, which is done in O(1)) and then modi.cations done by a transaction are applied directly to \ntheir own copy of the initial database. However, ending (or committing ) a transaction is more com\u00adplex. \nIndeed, the initial database might have been modi.ed, since concurrent transactions or non-transactional \nevents may have up\u00addated its state. It is thus necessary to carefully design what happens when a transaction \nends. First of all, Figure 4 describes the general algorithm which one has to solve when committing a \ntransaction. COMMIT ALGORITHM Input: Atrie T1 . T (the initial database state) A modi.cation sequence \nst . (K * \u00d7 T) * (the transaction) A modi.cation sequence s1 . (K * \u00d7 T) * (the concurrent modi.cations) \n Output: A modi.cation sequence s2 . (K * \u00d7 T) * (the consistent merging of s1 and st)  Avalue r .{abort, \ncommit}  (the result of the merging) Figure 4. The general commit algorithm. Figure 5 illustrates this \nsituation. In this .gure, the trie T1 is the initial state of the database, ie. its state just before \nthe transaction starts; the trie Tt is the state of the database copy associated with the transaction, \nie. is obtained by applying the transaction st to T1;the trie T2 is the state of the database which might \nhave been updated since the beginning of the transaction (s1 is empty if nothing has been executed concurrently \nwith st); furthermore, the trie T3 is the state of the database after the modi.cations caused by st have \nbeen taken into account to update T2 accordingly; .nally, the dashed lines between Tt and T3 illustrates \nthat this process is asymmetric: the Ti tries, for i .{1, 2, 3}, are associated with visible states of \nthe database, as Tt is an internal copy which carry modi.cation information only. Thus, in case it is \nnot possible to merge Tt with T2, it is safe to completely discard the changes introduced by st, that \nis to return s2 = e and r = abort, to obtain T3 = T2.  Tt s1 s2 T1 T2 T3 Figure 5. Relationship between \ntries used in the commit algo\u00adrithm. Time goes from left to right. Thus, there exist very simple algorithms \nwhich are able to merge changes introduced by transactions into the visible database state: the .rst \none is the one which never commits anything, that is which always returns s2 = e and r = abort. This \nbehavior is correct, however it is not very useful in practice. Furthermore, CXenstored implements an \nalgorithm which commits the changes only if T1 has not been updated since the transaction has been started, \nie. if and only if T1 = T2. Otherwise, the transaction is aborted and retried after a short delay from \nthe beginning. The hope is that nobody will update the database concurrently this time. In this case, \nT3 is very simple to compute, as it is exactly Tt when the transaction is committed and T2 otherwise. \nIn practice, this simple algorithm is suf.cient when transactions do not occur too often and it was implemented \nsuccessfully by CXenstored. However, experiments show that in cases where the system is under load, this \nsimple al\u00adgorithm doesn t work any more as the transaction abort-and-retry mechanism live-locks (see \nSection 7). Thus we designed a better algorithm, able to merge (or coalesce) concurrent transactions \nand implemented it in OXenstored. Regarding the the context of utilization of Xenstored, it is im\u00adportant \nto remark that transactions are localized and are closely related to the hierarchical structure of the \ndatabase. Indeed, each guest has its own con.guration values and the transactions it will create will \naccess and modify only these values (and for security reasons, we do not want it to access or modify \ncon.guration values of other guests). For guests whose ID is i these con.guration values are stored in \nspeci.c sub-tries of /local/domain/i. Then access\u00ading information about disk or network con.guration \ncan be done in accessing only the sub-tries ./device/vbd and ./device/vif respectively: it is then not \nnecessary to block other transactions accessing different sub-tries to commit. In the following, we use \nthat remark to coalesce concurrent transactions accessing distinct sub-tries of the database. However, \nit is important to remember that we are still in a transactional model, that is some transactions will \nstill eventually fail. So, there are still some corner-cases when, under load, the system will live-lock. \nHowever, in practice, Xenstored transactions often have a very speci.c shape (they are localized on some \nsub\u00adtries) and thus the algorithm we give in the next section corrects this behavior and leads to more \nstable performance.  6. Transaction Coalescing In the previous section, we de.ned transactions in terms \nof se\u00adquences of trie modi.cations. We explain in this section how to merge these transactions with the \nmain state of the database. In order to properly explain how the coalescing algorithm we im\u00adplemented \nin OXenstored works, we .rst introduce in Section 6.1 some basic de.nitions useful for dealing with trie \nmodi.cations. In Section 6.2, we explain how optimizing a part of the coalescing al\u00adgorithm, by incrementally \nupdating what we will call the modi.ca\u00adtion pre.x of the transaction. Finally, we give the main OXenstored \nalgorithm in Section 6.3 as well as its complexity in Section 6.4. 6.1 Main Results The .rst of these \nde.nitions is about comparing the modi.cations done on two tries. More precisely, it is about locating \nthe longest path which address sub-tries that are not physically equal in the two given tries. This longest \npath is called the modi.cation pre.x and can be more formally de.ned as the following: De.nition 6.1 \n(modi.cation pre.x). Let T1 and Tt be two tries. The modi.cation pre.x of T1 and Tt, denoted by p(T1,Tt),is \nan element u in ({T} . K * ) such that: If T1 = Tt then u = T; Otherwise, u is the longest path such \nthat, for any v .K* : If v is a strict pre.x of u,then T1(v)= Tt(v); If v is a pre.x of u,then T1|v = \nTt|v; If T1|v = Tt|v then either u is a pre.x of v or v is a pre.x of u.  Hence, p(T1,Tt) is the longest \npath such that Tt|p(T1,Tt) is not a sub-trie of T1 (and conversely, it the longest path such that T1|p(T1,Tt) \nis not a sub-trie of Tt). Moreover, let us remark that in case T1(e)= Tt(e),then p(T1,Tt)= e, as there \nis no strict pre.x of e and any path has e as pre.x; moreover (E2) and (R1) state that T1(e)= Tt(e) implies \nthat T1 = Tt. Furthermore, let us consider the trie T of Figure 5 and let us consider a new trie Tt obtained \nby applying the transaction [uv/x][uw/y] to T ,where x, y .V. In this case, one can check that p(T,Tt) \nis exactly u. The second of these de.nitions is about merging tries while enforcing a sub-trie sharing \npolicy as much as possible. In order to understand the intuition of this de.nition, it is useful to consider \nthe diagram shown in Figure 5. However, the following de.nition is more general and holds for any 3-tuple \nof tries: De.nition 6.2 (coalescing trie). Let T1, T2 and Tt be three tries. The trie T3 is a coalescing \ntrie of T2 and Tt, relative to T1,if,for any path v in K *, it satis.es the following conditions: 1. \nIf T1|v = Tt|v,then T3|v = T2|v; 2. If v is not a strict pre.x of p(T1,Tt) and T1|v = T2|v,then T3|v \n= Tt|v; 3. In all cases, either T3(v)= Tt(v) or T3(v)= T2(v).  We are now ready to introduce the main \nresult of this paper. The following theorem states how to compute the coalescing trie of three tries \norganized as in the diagram of Figure 5, ie. with an initial trie T1 representing the initial state of \nthe database, from which two distinct modi.cation sequences lead to the two tries T2 (the database s \ncurrent state) and Tt (the local state associated with the current transaction). Basically, in the majority \nof cases, it is suf.cient to substitute the database s current state by the sub-trie of Tt addressed \nby the modi.cation pre.x of T1 and Tt.However, this theorem is not complete, that is there are some cases \nwhere building this coalesced trie is not possible. In this case, we can simply consider Tt as a trie \nrelated to a transaction and T2 as the current state of the database, and as already discussed, in practice \nit is acceptable to discard the transaction trie Tt and let the database client retry the sequence of \nmodi.cations.  Theorem 6.3 (coalescing tries). Let T1, T2 and Tt be three tries st and st be a transaction \nsuch that T1 -. Tt.If p(T1,Tt)= T and T1|p(T1,Tt) = T2|p(T1,Tt), then the coalescing trie of T2 and Tt, \nrelative to T1,is: T2 p(T1,Tt) / (Tt|p(T1,Tt)) Proof. Let us .x u = p(T1,Tt). We assume that u = T and \nthus we can .x T3 to be T2[u/(Tt|u)]. Now, we want to check that the three assertions of De.nition 6.2 \nholds for T3. Before starting the core of the proof, let us show a useful result. From the de.nition \nof T3,we have: T3|u = T2[u/(Tt|u)]|u (using (R3)) = (Tt|u)|e (using (S1)) = Tt|u (using (R2)) Thus, \nwe can .x, within the scope of this proof, the following as\u00adsumptions: (A1) T3 = T2[u/(Tt|u)] (A2) T1|u \n= T2|u (A3) T3|u = Tt|u We are now ready to prove Theorem 6.3. v, w are in K * . 1. Following the structure \nof De.nition 6.2, we .rst need to prove that T1|v = Tt|v implies that T3|v = T2|v.To dothis, letus consider \nthe following three possible cases: (a) v is a pre.x of u;(b) u is a pre.x of v and (c) neither u is \na pre.x of v nor v is apre.x of u. (a) If u = vw: T1|v = Tt|v . (T1|v)|w = (Tt|v)|w (using (R3)) . T1|u \n= Tt|u (using (R2)) However, as u is a valid pre.x of u, De.nition 6.1 states that T1|u = Tt|u. Contradiction. \n(b) If v = uw: Using (A1), we have T3 = T2[u/(Tt|u)]. Then, we have: T3|v = T2[u/(Tt|u)]|uw (using (R3)) \n= (Tt|u)|w (using (S1)) = Tt|v (using (R2)) Thus, T1|v = Tt|v implies that T1|v = T3|v. Then, let us \ndevelop (A2): T1|u = T2|u . (T1|u)|w = (T2|u)|w (using (R3)) . T1|v = T2|v (using (R2)) Thus, T1|v = \nTt|v implies that T3|v = T2|v. (c) If neither u is a pre.x of v nor v is a pre.x of u: Let us start from \n(A1): T3|v = T2[u/(Tt|u)]|v (using (A1)) = T2|v (using (S3)) Thus, we showed that, in every case, T1|v \n= Tt|v implies that T3|v = T2|v. 2. Second, let us prove that if v is not a pre.x of u and T1|v = T2|v,then \nT3|v = Tt|v. To do this, let us consider the following two possible cases: (a) u is a pre.x of v and \n(b) neither u is a pre.x of v nor v is a pre.x of u. (a) If v = uw: Let us start from (A3): T3|u = Tt|u \n. (T3|u)|w = (Tt|u)|w (using (R3)) . T3|v = Tt|v (using (R2)) (b) If neither u is a pre.x of v nor v \nis a pre.x of u: Using De.nition 6.1, we have T1|v = Tt|v. Then, we start from (A1) to obtain: T3|v \n= T2[u/(Tt|u)]|v (using (R3)) = T2|v (using (S3)) Thus, if T1|v = T2|v,then T3|v = T1|v and thus, T3|v \n= Tt|v. Thus, we showed that, in every case, if v is not a pre.x of u and T1|v = T2|v,then T3|v = Tt|v. \n3. Finally, let us prove that all cases, T3(v)= Tt(v) or T3(v)= T2(v). To do this, let us consider the \nfollowing three possible cases: (a) v is a pre.x of u;(b) u is a pre.x of v and (c) neither u is a pre.x \nof v nor v is a pre.x of u. (a) If u = vw: (A3) states that T3|v = T2[u/(Tt|u)]|v. Then using (S4), we \nobtain that T3(v)= T1(v). (b) If v = uw: Let us start from (A3):  T3|v = T2[u/(Tt|u)]|v . T3|v = Tt|v \n(S3) . T3(v)= Tt(v)(E2) (c) If neither u is a pre.x of v nor v is a pre.x of u: Let us start from (A3): \n T3|v = T2[u/(Tt|u)]|v . T3|v = T2|v (S3) . T3(v)= T2(v)(E2) Hence, for all cases, we showed that either \nT3(v)= Tt(v) or T3(v)= T2(v). D  6.2 Computing the Modi.cation Pre.x In the last section, we explained \nhow to properly coalesce trans\u00adactions: it suf.ces to substitute the database s current state by the \ntransaction state on the modi.cation pre.x of the transaction trie and initial database state. However, \ncomputing the modi.cation pre.x of two tries can be costly if we do not have additional infor\u00admation. \nFortunately, the modi.cation sequence of the transaction can be used to ef.ciently compute that modi.cation \npre.x: Lemma 6.4. T1 and Tt are two tries and st =[u1/Tb1] ... [un/Tbn] st be a non-empty transaction \nsuch that T1 -. Tt.Then p(T1,Tt), the modi.cation pre.x of T1 and Tt, is exactly the longest path which \nis a common pre.x of every ui,for i .{1 ...n}. Proof. Let us prove Lemma 6.4 by induction on the size \nof st. (i) Let us show the .rst induction step. Let us .x st =[u1/Tb1], that is, Tt = T1[u1/Tb1] and \nlet us prove that the longest common pre.x of u1 is the modi.cation pre.x of T1 and Tt, that is u1 = \np(T1,Tt). According to De.nition 6.1, we have to show three implications: First, we have to prove that, \nfor any v .K *,if v is a strict pre.x of u1,then T1(v)= Tt(v):if v is a strict pre.x of u1,thatis u1 \n= vw with w = e, then (S4) states that T1[u1/Tb1](v)= T1(v),that is Tt(v)= T1(v);  Second, we have to \nprove that, for any v .K *,if v is a  pre.x of u1,then T1|v = Tt|v:if v is a pre.x of u1,thatis u1 = \nvw, then (S2) states that T1[u1/Tb1]|v = T1|v,thatis Tt|v = T1|v;  Finally, we have to prove that, for \nany v .K*,if T1|v = Tt|v, then either u1 is a pre.x of v or v is a pre.x of u1:if T1|v = Tt|v,thatis \nT1|v = T1[u1/Tb1]|v, then (S3) states that either u is a pre.x of v or v is a pre.x of u. (ii) Let us \nthen complete the induction process. Let us .x st = s[un/Tbn], with s a non-empty transaction of size \nn - 1 and let s us consider the trie T such that T1 -. T . Let us then have p = p(T1,T ). The induction \nhypothesis gives us that p is also the longest common pre.x of {u1,...,un-1}. Hence, for every v .K * \n: (a) If v is a strict pre.x of p,then T1(v)= T (v); (b) If v is a pre.x of p then T1|v = T |v; (c) \nIf T1|v = T |v then either v is a pre.x of p or p is a pre.x of v.  Let u be the longest common pre.x \nof {u1,...,un} and let us show that u is also the modi.cation pre.x of T1 and T [un/Tbn]. According to \nDe.nition 6.1, we have to show three implica\u00adtions: First, we have to prove that, for any v .K *,if \nv is a strict pre.x of u,then T1(v)= Tt(v):if v is a strict pre.x of u, we have u = vw with w = e, and \nthus we have un = vw with w = e. Then (S4) states that T [un/Tbn](v)= T (v). Using (a), we obtain that \nTt(v)= T1(v), with v being the longest common pre.x of {u1,...,un};  Second, we have to prove that, \nfor any v .K *,if v is a pre.x of u,then T1|v = Tt|v:if v is a pre.x of u,we have u = vw,for w .K *, \nthus we have un = vw. We can then use (S2) to obtain that T [un/Tbn]|v = T1|v. Using (b), we obtain that \nTt|v = T1|v, with v being the longest common pre.x of {u1,...,un};  Finally, we have to prove that, \nfor any v .K *,if T1|v = Tt|v, then either u is a pre.x of v or v is a pre.x of u: if T1|v = Tt|v then \nit is due either to T1|v = T |v or to T |v = Tt. In the .rst case, (c) states that either v is a pre.x \nof p or p is a pre.x of v; in the second one (S3) states that either v is a pre.x of un or un is a pre.x \nof v. Thus, if p is the longest common pre.x of p and un, that is the longest common pre.x of {u1,...,un}, \nthen we have either v is a pre.x of p or p is a pre.x of v;  Thus we showed that Lemma 6.4 is valid \nfor any size of st. It is then straightforward to derive from Lemma 6.4 an incre\u00admental algorithm to \ncompute the modi.cation pre.x of tries asso\u00adciated with a transaction: indeed, at each step of the sequence, \nit suf.ces to take the longest common pre.x between the path cur\u00adrently modi.ed by the current step and \nthe modi.cation pre.x al\u00adready computed from the beginning of the transaction.  6.3 Algorithms OXenstored \nis able to properly coalesce unrelated transactions, ie. transactions which modify disjoint subtrees \nof the current store. To do this ef.ciently, it exploits the functional tree representa\u00adtion of the database. \nMore precisely, consider a transaction s = [u1/T1] ... [un/Tn]. This transaction is executed incrementally \nso we can also consider a sequence of time tk,for k .{0 ...n}, where t0 corresponds to a time just before \nthe transaction starts, ie. to the sub-sequence s0 = e of s and each tk corresponds to a time when only \nthe sub-sequence sk =[u1/T1] ... [uk/Tk] of s has been executed. We can now de.ne, for any k .{0 ...n},the \nstate of a transaction at the time tk as a structure (T k,Ttk,pk),where: T k . T is a snapshot of the \nstate of the database just before the transaction started.  Ttk . T is a local trie attached to the \ntransaction and where the modi.cation it contains are done, while letting the main database state unchanged \nuntil the transaction is committed. Its  sk value is such that T 0 - . Ttk; pk . ({T} . K* ) is either \nT if no modi.cations yet been executed (ie. k =0)or u if u the modi.cation pre.x associated with T k \nand Ttk (ie. p(T k,Ttk)), that is, it is the longest such that Ttk|pk is not a sub-trie of T k . As already \nstated in Section 2.1, OXenstored gives a unique identi.er to each started transaction. This identi.er \nis created when a client sends to OXenstored a starting request for a new trans\u00adaction; this identi.er \nis associated internally with the structure (T,T, T),where T is the current state of the database. This \niden\u00adti.er is also sent back to the client; the client can then put this identi.er in the header of packets \nit will send later in order to up\u00addate the state of this speci.c transaction. Eventually, it can also \nnotify OXenstored that it wants the transaction to commit, ie. to push the changes introduced by the \ntransaction into the current state of the database. In the following, we give the algorithms used by \nOXenstored to update the structure associated with a transaction and to commit the changes induced by \na transaction into the current database state. We assume here that (i) a client already started a transaction \nsk, whose associated structure is (T k,Ttk,pk); (ii) the client has been sending the requests to either \nupdate or commit a transaction; and (iii) OXenstored has already decoded the packet header of that request \nand the associated transaction structure is exactly (T k,Ttk,pk). Updating a Transaction First of all, \nlet us detail how to update the structure associated with a transaction. Let us assume that OXenstored \ndecoded the packet content and found that the clients want to substitute the trie Tk+1 on path uk+1. \nOXenstored has to compute the new transaction structure (T k+1t ,pk+1).We ,T k+1 have: For any k .{1 \n...n}, T k is identical, as it is a snapshot of the state just before the beginning of the transaction; \n De.nition 5.1 states that a transaction is updated by applying to its local state the substitution \n[uk+1/Tk+1];  Lemma 6.4 shows that the modi.cation pre.x can be com\u00adputed online: indeed it is suf.cient \nto compute incrementally the longest pre.x of pk and uk+1.  Input: (T k,T k,pk) and the substitution \n[uk+1/Tk+1] t Output: the new transaction structure (T k+1t ,T k+1,pk+1) T k+1 . T k; T k+1 . T k tt \n[uk+1/Tk+1]; pk+1 . longest-common-prefix(pk , uk+1); return (T k+1,Ttk+1,pk+1) Algorithm 1: Updating \na transaction. These lead directly to Algorithm 1, that explains how to com\u00adpute (T k+1,pk+1) from (T \nk,T k,pk) and [uk+1/Tk+1], ,T k+1 tt for any k .{1 ... (k - 1)}. Note that this algorithm uses the function \nlongest-common-prefix(u,v) which returns either the longest common pre.x of u and v if u, v .K * or returns \nv if u = T (and u if v = T).  Committing a Transaction Second, let us detail how to commit the structure \nassociated with a transaction into the current state of the database, in coalescing concurrent transactions \nwhen pos\u00adsible. Let us assume that OXenstored decoded a packet whose header contains an identi.er internally \nassociated with the structure (T k,Ttk,pk) and whose content contains a commit order. OXen\u00adstored has \nto compute the new state of the database, which should share, as much as possible, nodes from the current \ndatabase state T and from the transaction local state Ttk; more precisely, we want to ensure that this \nnew database state is exactly the coalescing trie of T and Ttk, relative to T k (see De.nition 6.2). \nBasically, there are three cases: The .rst case is when no modi.cations are done concurrently with the \ncurrent transaction on the entire database. This case can be checked easily. Indeed, rule (S2) states \nthat, in case a substitution is done on between T and T k, then there exists u .K * such that T |u = \nT k. Finally, rule (R3) states that T = T k. When this case is detected, it is then safe to replace the \ndatabase s current state by the local state of the transaction.  The second case is when no modi.cations \nare done concur\u00adrently with the current transaction on the sub-trie corresponding to the scope of that \ntransaction. Being able to detect this case ef.ciently is the main improvement from CXenstored to OXen\u00adstored. \nHowever, in our settings, this is relatively easy. Indeed, De.nition 6.1 states that pk is the longest \npath such that Ttk|p is not a sub-trie of T k,thatis Ttk|p is the biggest sub-trie modi.ed by the current \ntransaction. Thus, to detect if no modi.cations are done concurrently with the current transaction, it \nsuf.ces to check that the corresponding sub-trie in the database s current state has not been modi.ed, \nie. that Tt|p = Ttk|p (as stated by rules (S2) and (R3), as in the last bullet). When this case is detected, \nTheorem 6.3 states it is safe to replace the sub-trie of the database s current state by the corresponding \nsub-trie of the transaction s local state.  The last case relates to aborting the transaction if it \nis not possible to commit it. In this case, the database s current state remains unchanged and the client \nis noti.ed that it has to retry the transaction.  These lead to Algorithm 2. Input: the current database \nstate T and (T k,Ttk,pk)Output: the new database state and the transaction status  if T = T k then /* \nif the database has not been updated */ return (Ttk , commit); else if T |pk = T k|pk then /* if the \nsub-trie T ' . T [pk/(T k t |pk)]; return (T ' , commit); has not been updated */ /* otherwise, abort \nreturn (T , abort); */  else end Algorithm 2: Committing a transaction. Extension In the extended version \nof our implementation, where we do not consider that reading operations update the state of the database, \nthe algorithm remains more or less the same. However, instead of keeping a unique modi.cation pre.x pk \nfor each trans\u00adaction, we keep two of them: one for read operations, pk R,and for W . Then, for deciding \nif the sub-trie of the transaction have been concurrently updated in the database s cur\u00adrent state, we \ncheck that T |pk = T k|pk and T |pk = T k|pk one write operations, pk RRW W stands. If this is the case, \nwe only update the sub-trie corresponding to writing operations, ie. we set T ' . T [pkt |pk W ]/(T k \n). This could be helpful to reduce the con.ict rate between concurrent transac\u00adtions which read and write \nin distinct sub-tries and dramatically increase the ef.ciency of the coalescing in case a transaction \nonly performs read operations. 6.4 Complexity In order to .nd the complexities of the algorithms, we \ncan .rst derive the complexity of the trie operations from the axioms of Figure 2 and the tree representation \ndetailed in Section 4.2. First of all, using the tree representation of tries and assum\u00ading a linear \ncomplexity for accessing children of a node it is then straightforward to obtain that, given tries T,T \n' . T(K, V) and apath u .K *, the complexity of computing the restriction T |u and the substitution T \n[u/T ' ] is O(|u||K|) (thus, independent of the size of T or of T ' ). Moreover, the complexity of computing \nthe physical equality T = T ' is in O(1). Thus, the complexity of Algorithm 1 is in O(|uk+1||K|),where \n|u k| is the size of the path which is modi.ed and the complexity of Algorithm 2 is in O(|pk||K|),where \n|pk| is the size of the longest common pre.x of any path which are modi.ed. Thus, the complexity of these \nalgorithms does not depend at all of the size of the current database, which gives very stable performance. \nMoreover, in practice, the number of keys K and the path size are very rarely over 10, which can already \nlead to databases with 1010 entries, while keeping a good level of ef.ciency for modi.cation operations. \n  7. Evaluation In the previous sections, we explained how the OXenstored al\u00adgorithm for coalescing \ntransactions works and we argued that, although transactions can still be aborted, the rate of committed \ntransactions in a practice should be very high. In this section, we validate this statement experimentally, \nby comparing the perfor\u00admance of CXenstored and OXenstored. Not surprisingly, the results we obtained \nshow that OXenstored scales much better than CXen\u00adstored: indeed CXenstored exhibits a live-lock in a \nvery common situation (sequentially starting as many guests as possible), unlike OXenstored. More precisely, \nthe tests we ran are the following: .rst in Sec\u00adtion 7.1, we measured the performance under load of CXenstored \nand OXenstored in an isolated context, by creating random trans\u00adactions and without interacting with \nthe XEN hypervisor. Then, we measured the performance of CXenstored and OXenstored when they are interacting \nwith the XEN hypervisor, with and without load, in Section 7.2 and Section 7.3 respectively. 7.1 Performance \nunder Load Experiment Description We .rst wanted to test the transaction time latency mechanism, on a \nfew workloads, with no interaction with the XEN hypervisor. We wanted to simulate the behavior of starting \na guest, as described in Section 2. So, we created 128 processes, each simulating the behavior of a guest \nand performing the following transaction: They all read the value of the same path in the database; \nand  They all write in different parts of the database.   Furthermore, we repeated that transaction \n500 times on each pro\u00adcess. Then, on each process, we measured the time taken by each transaction to \ncommit and we ordered the results. 0.45 0.4 0.35 0.3 0.25 0.2 0.15 0.1 0.05 0 0 20 40 60 80 100 120 140 \nProcess Name  (a) minimum delays 16 14 12 10 8 6 4 2 0 0 20 40 60 80 100 120 140  Process Name (b) \naverage delays 900 800 700 600 500 400 300 200 100 0 0 20 40 60 80 100 120 140 Process Name (c) maximum \ndelays Duration (in seconds) Duration (in seconds) Duration (in seconds) Figure 6. Comparison between \nCXenstored and OXenstored for the time taken by 128 concurrent processes to to commit 500 transactions \nwhich read from the same path and write on different ones. Processes are ordered following their completion \ntime. Experiment Results Part of the results of this experiment are shown in Figure 6. More precisely, \nthese .gures show for each process the time taken by: (a) The fastest transaction to commit;  (b) The \naverage time of the transactions to commit; and (c) The time taken by longest transaction to commit. \n  Graph (a) shows that transactions are always committed faster in OXenstored than in CXenstored. Moreover, \nin the best case, the commit rate of OXenstored is very stable at around 700 transac\u00adtions per second, \nas opposed to the commit rate of CXenstored which is around 300 transactions per second. Furthermore, \nin the average case, Graph (b) shows that the OXenstored performance are much stable for OXenstored than \nfor CXenstored, as the average delays for OXenstored are very low (always under 1 second), unlike CXenstored \nwhich committed few transactions over 10 seconds. Finally, In the worst case, Graph (c) shows that CXenstored \ncan live-lock as some commit delays are over 12 minutes. On the other hand, even in the worst case, OXenstored \nperformance remains very stable (around 1 second). On graphs (a) and (b), there is a small glitch around \nthe 17th process. It is not totally clear what is the cause of that behavior. Experiment Conclusions \nThe obtained results clearly indicate that CXenstored cannot deal with more than 100 concurrent trans\u00adactions, \nas opposed to OXenstored which does not show any sign of performance issues. Furthermore, when access \nto the database is the performance bottleneck, OXenstored is always quicker than CXenstored, even in \nthe case of few concurrent transactions. Fi\u00adnally, OXenstored has a very small variance compared to CXensto\u00adred, \nwhich means that we can expect that the system will behave in amorepredictable way.  7.2 Performance \nwhen interacting with the XEN hypervisor Experiment Description Subsequently, we designed a more real\u00adistic \ntest than the one of Section 7.1, to compare the performance of CXenstored and OXenstored to start real \nguests. For this exper\u00adiment, we installed one guest running Windows XP and then we repeated the following \nsteps 100 times: 1. clone 50 guests from the initial one (a clone is functionally equivalent to a fresh \ninstall, but it quicker); 2. sequentially start all the cloned guests; 3. sequentially shut-down all \nthe cloned guests; and 4. uninstall (ie. destroy) all the cloned guests.  At the same time, we measured \nthe time taken for starting and shutting-down each guest. Experiment Results The results are shown in \nFigure 7. These .g\u00adures show the integral of distribution probability for the time taken to complete \nguest start and shutdown. The results for OXenstored and CXenstored are quite similar: half the guest \nare started in less than 4.5 seconds and are shut down in less than 2 seconds. Further\u00admore, 90% of the \nguests are started by OXenstored and CXenstored in less than 7.5 seconds and are shut down in less than \n2.9 seconds. Experiment Conclusions The results we obtained show that there is no major differences between \nOXenstored and Xenstored in this case, that is CXenstored is clearly not a bottleneck under normal load. \n 7.3 Performance under load when interacting with the XEN hypervisor Experiment Description In this \nexperiment, we wanted to start as many guests as possible and compare the performance of CXensto\u00adred \nand OXenstored. Thus, we needed minimalist guests which do not use many physical resources. Hence, we \nused a modi.ed ver\u00adsion of mini-OS , a very small operating system distributed with the XEN hypervisor \nsources, in order to start a lot of very small guests performing long con.icting transactions concurrently. \nMore precisely, we created 160 mini-OS guests, with 1 virtual disk and  minutes, it never commits the \ntransaction which should con.gure and start the 70th guest. On the other hand, OXenstored keeps starting \nthe guests at a constant rate every 2 seconds and it started 0 all the 160 guest in less than 6 minutes. \n20 Cumulative probability Cumulative probability 0.6 18 16 0.4 14 Duration (in minutes) 12 10 8 3 3.5 \n4 4.5 5 5.5 6 6.5 7 7.5 6Duration (in seconds) (a) Starting a guest. 4 2 0.9 0.8 0.7 0.6 0.5 0.4 0.3 \n0.2 0.1 0Duration (in seconds) (b) Shutting down a guest. 0 0 20 40 60 80 100 120 140 Number of guests \nstarted. Figure 8. Comparison of the time taken by CXenstored and OXen\u00adstored to start as many mini-OS \nguests as possible, when these guests perform long transactions in a loop. Experiment Conclusions Is \nis quite clear that OXenstored is not at all in.uenced by the long transactions, as opposed to CXenstored \nwhich begins to live-lock when more than 40 guests are started. Hence, the performance of OXenstored \nis more stable and it scales much better than CXenstored.  8. Related Work Transactional databases \nhave been widely studied in the last few decades (H\u00a8arder and Reuter 1983; Bernstein et al. 1987). They \nprovide to the user a very simple way of encapsulating a group of actions, called a transaction, with \nthe following properties: If one part of the transaction fails, the entire transaction fails (atomicity); \nat every moment, the database remains in a consistent state: only valid data are written in the database \n(consistency); other opera\u00adtions cannot access or see the data of an intermediate state during a transaction \n(isolation); once the user has been noti.ed that one of its transactions has succeeded, the transaction \nwill persist and not be undone, even in case of a failure (durability). These properties make the concurrent \nprogramming of such systems very easy, as the user does not have to worry anymore about using locks to \nen\u00adsure data consistency. The most common way to ensure atomicity in transactional databases is a mechanism \ncalled compensation (Gray and Reuter 1992). In case of failure, compensation consists of executing the \ncompensating actions, corresponding to the executed actions of the failed process, in the reverse order \nof their execution. This ap\u00adproach has recently gained renewed popularity in the context of general-purpose \nprogramming known as Software Transactional Memory (Shavit and Touitou 1995; Harris and Fraser 2003; \nEn\u00adnals 2005; Riegel et al. 2006), where the purpose is to minimize the use of locks (by the use of lock-free \ndata structures, for ex\u00adample). The same compensation mechanisms have also been ap\u00adplied successfully \nto build ef.cient and robust transactional web\u00adservices (Biswas 2004; Biswas et al. 2008). Due to the \nnature of the compensation mechanism (ie. keeping a list of the actions executed by each started transaction), \nthere is a straightforward but very costly way to merge transactions: when a transaction is committed, \nFigure 7. Integral of the distribution probability of the time taken by CXenstored and OXenstored to \nstart a real guest. 1 virtual network each, which all do the following when they are started: 1. start \na transaction; 2. write a value in /local/domain/X/device/foo (where X is the current guest ID) using \nthe opened transaction; 3. sleep 1 second; 4. write a value in /local/domain/X/device/bar (where X \nis the current guest ID) using the opened transactions; 5. close the opened transaction; 6. sleep 1 \nsecond; and 7. go back to step 1.  These transactions simulate the way some monitors report statistics \ninside each guest (as the current memory usage for guests which are not modi.ed to run on top of the \nXEN hypervisor, as Windows guests). We then sequentially started as many guests as we can on one host \nand we measured the cumulative time taken to start each of the guests. Experiment Results Figure 8 shows \nthe cumulative time taken to start as many guests as possible in less than 20 minutes. CXenstored begins \nto starts 30 guests at a constant rate of 2 seconds per guest started, but it starts to live-lock around \n40 guests. Finally, after 20 only the started transactions that read values written by the com\u00admitted \ntransactions are aborted. Note that this may lead to further abortions of other transactions and so on, \nan effect called cascading aborts. This effect can lead to very hard-to-predict performance.  Thus, \nour approach based on optimistic transaction control, where each transaction has a local copy (called \na shadow tree in the database literature) of the database which it is modifying, leads to much more predictable \nperformance on tree-structured databases. Hence, a few other systems have used the same form of opti\u00admistic \ntransaction control based on shadow trees, the .rst one of them probably being the object store of GemStone \n(Butterworth et al. 1991), two decades ago. However, our approach is much crisper and simpler as the \napplications we consider have a greater degree of locality to be exploited compared to the more general \nobject database applications usually considered. Furthermore, functional data-structures, including tries, \nhave been widely studied (see the Okasaki s book (Okasaki 1999), as ex\u00adample). Our axiomatization is \na step forward to integrate trie prop\u00aderties in a theorem prover in order to demonstrate the correctness \nof algorithms on tries. Moreover, to the best of our knowledge our work is the .rst to consider the use \nof tries in transactional setting. Few other functional structures have been studied in that context, \nas functional binary search (Trinder 1989). In that work, transac\u00adtions are pure functions taking an \nimmutable database state as an argument and returning an output and a new database state. Concur\u00adrent \ntransactions are serialized by a database manager which then uses a data dependency analysis and the \nreferential transparency property of pure functions to ef.ciently schedule the transaction s operations. \nOur approach is more .exible as it allows us to mix functional and imperative features when using transactions \n(as in Objective Caml). More recently, the aim of the Harmony project (Foster et al. 2007) is to de.ne \na safe way of synchronizing different views of a shared persistent tree data-structure. The synchronization \nmech\u00adanism of Harmony can be seen as the commit phase of a transac\u00adtional database, but where the only \nknowledge is the current state of the transaction, rather than a trace of modi.cations as in the case \nwith compensation. The merging algorithm used by that tool needs to be speci.ed by the users and thus \ncan become very complex. On the other hand, our approach is much simpler and more ef.cient but it requires \nsome extra knowledge about the transaction which is committed (ie. the modi.cation pre.x) and thus cannot \nbe used in our work.  9. Conclusion This paper describes the design of OXenstored, a successful ap\u00adplication \nof functional technology in an industrial setting which demonstrates the effectiveness of a limited form \nof pointer com\u00adparison in a functional context. Indeed, the OXenstored database is represented and manipulated \nusing an immutable pre.x tree, for which we give a simple and formal semantics. For performance reasons, \nOXenstored uses reference cell comparison. This is a lim\u00adited form of pointer comparison which can be \nelegantly integrated with the pre.x-tree semantics, ensuring a safe and ef.cient way to merge concurrent \ntransactions. We also demonstrate the validity of our approach by implement\u00ading in Objective Caml the \nalgorithms described in this paper and evaluating them against CXenstored, the Xenstored service written \nin C and distributed with the XEN hypervisor sources. These ex\u00adperimental results show that our transaction \nprocessor is not only one third of the size of of its C counterpart, but signi.cantly out\u00adperforms it. \nAs a direct consequence of these results, OXenstored will replace CXenstored in future releases of XENSERVER. \n Acknowledgements The authors would like to thank very much Jonathan Davies and Richard Sharp for making \nuseful suggestions. They also would like to thank the anonymous ICFP reviewers whose comments greatly \nimproved some parts of the paper.  References Paul Barham, Boris Dragovic, Keir Fraser, Steven Hand, \nTim Harris, Alex Ho, Rolf Neugebauer, Ian Pratt, and Andrew War.eld. Xen and the Art of Virtualization. \nIn SOSP 03: Proceedings of the nineteenth ACM symposium on Operating systems principles, pages 164 177. \nACM Press, 2003. Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman. Concur\u00adrency Control and \nRecovery in Database Systems. Addison-Wesley, 1987. Debmalya Biswas. Compensation in the World of Web \nServices Composi\u00adtion. In SWSWPC, pages 69 80. LNCS 3387, 2004. Debmalya Biswas, Thomas Gazagnaire, and \nBlaise Genest. Small logs for transactional services: Distinction is much more accurate than (positive) \ndiscrimination. IEEE International Symposium on High-Assurance Sys\u00adtems Engineering, pages 97 106, 2008. \nPaul Butterworth, Allen Otis, and Jacob Stein. The gemstone object database management system. Commun. \nACM, 34(10):64 77, 1991. Koen Claessen and David Sands. Observable Sharing for Functional Circuit Description. \nIn In Asian Computing Science Conference, pages 62 73. Springer-Verlag, 1999. Robert J. Creasy. The Origin \nof the VM/370 Time-Sharing System. IBM Journal of Research and Development, 25(5):483 490, 1981. Robert \nEnnals. Ef.cient software transactional memory. Technical Report IRC-TR-05-051, Intel Research Cambridge \nTech Report, 2005. J. Nathan Foster, Michael B. Greenwald, Jonathan T. Moore, Benjamin C. Pierce, and \nAlan Schmitt. Combinators for bidirectional tree transfor\u00admations: A linguistic approach to the view-update \nproblem. ACM Trans. Program. Lang. Syst., 29(3):17, 2007. Edward Fredkin. Trie memory. Commun. ACM, 3(9):490 \n499, 1960. Jim Gray and Andreas Reuter. Transaction Processing: Concepts and Techniques. Morgan Kaufmann \nPublishers Inc., 1992. Theo H\u00a8arder and Andreas Reuter. Principles of transaction-oriented database recovery. \nACM Comput. Surv., 15(4):287 317, 1983. Tim Harris and Keir Fraser. Language Support for Lightweight \nTransac\u00adtions. In OOPSLA, 2003. Xavier Leroy, J\u00b4er ome Vouillon, Damien Doligez, et al. The Objective \nCaml system. http://caml.inria.fr/ocaml/, 1996. Chris Okasaki. Purely Functional Data Structures. Cambridge \nUniversity Press, 1999. Andrew Pitts and Ian Stark. Observable properties of higher order functions that \ndynamically create local names, or: What s new. In Mathematical Foundations of Computer Science, Proc. \n18th Int. Symp., pages 122 141. Springer-Verlag, 1993. Torvald Riegel, Christof Fetzer, and Pascal Felber. \nSnapshot Isolation for Software Transactional Memory. In Proceedings of the First ACM SIGPLAN Workshop \non Languages, Compilers, and Hardware Support for Transactional Computing, 2006. Manuel Serrano. Bee: \nan integrated development environment for the Scheme programming language. Journal of Functional Programming, \n10(4):353 395, 2000. Nir Shavit and Dan Touitou. Software Transactional Memory. In Sympo\u00adsium on Principles \nof Distributed Computing, pages 204 213, 1995. Phil Trinder. A functional database. PhD thesis, 1989. \n  \n\t\t\t", "proc_id": "1596550", "abstract": "<p>We describe in this paper our implementation of the Xenstored service which is part of the Xen architecture. Xenstored maintains a hierarchical and transactional database, used for storing and managing configuration values.</p> <p>We demonstrate in this paper that mixing functional data-structures together with reference cell comparison, which is a limited form of pointer comparison, is: (i) safe; and (ii) efficient. This demonstration is based, first, on an axiomatization of operations on the tree-like structure we used to represent the Xenstored database. From this axiomatization, we then derive an efficient algorithm for coalescing concurrent transactions modifying that structure. Finally, we experimentally compare the performance of our implementation, that we called OXenstored, and the C implementation of the Xenstored service distributed with the Xen hypervisor sources: the results show that Oxenstored is much more efficient than its C counterpart.</p> <p>As a direct result of this work, OXenstored will be included in future releases of Xenserver, the virtualization product distributed by Citrix Systems, where it will replace the current implementation of the Xenstored service.</p>", "authors": [{"name": "Thomas Gazagnaire", "author_profile_id": "81384616771", "affiliation": "Citrix Systems, Cambridge, United Kingdom", "person_id": "P1614023", "email_address": "", "orcid_id": ""}, {"name": "Vincent Hanquez", "author_profile_id": "81442619844", "affiliation": "Citrix Systems, Cambridge, United Kingdom", "person_id": "P1614024", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596581", "year": "2009", "article_id": "1596581", "conference": "ICFP", "title": "OXenstored: an efficient hierarchical and transactional database using functional programming with reference cell comparisons", "url": "http://dl.acm.org/citation.cfm?id=1596581"}