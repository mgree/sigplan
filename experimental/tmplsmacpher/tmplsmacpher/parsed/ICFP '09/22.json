{"article_publication_date": "08-31-2009", "fulltext": "\n Attribute Grammars Fly First-Class How to do Aspect Oriented Programming in Haskell Marcos Viera S. \nDoaitse Swierstra Wouter Swierstra Instituto de Computaci\u00b4on Department of Computer Science Chalmers \nUniversity of Technology Universidad de la Rep\u00b4ublica Utrecht University G\u00a8oteborg, Sweden Montevideo, \nUruguay Utrecht, The Netherlands wouter@chalmers.se mviera@.ng.edu.uy doaitse@cs.uu.nl Abstract Attribute \nGrammars (AGs), a general-purpose formalism for de\u00adscribing recursive computations over data types, avoid \nthe trade-off which arises when building software incrementally: should it be easy to add new data types \nand data type alternatives or to add new operations on existing data types? However, AGs are usually \nim\u00adplemented as a pre-processor, leaving e.g. type checking to later processing phases and making interactive \ndevelopment, proper er\u00adror reporting and debugging dif.cult. Embedding AG into Haskell as a combinator \nlibrary solves these problems. Previous attempts at embedding AGs as a domain-speci.c language were based \non extensible records and thus exploiting Haskell s type system to check the well-formedness of the AG, \nbut fell short in compactness and the possibility to abstract over oft oc\u00adcurring AG patterns. Other \nattempts used a very generic mapping for which the AG well-formedness could not be statically checked. \nWe present a typed embedding of AG in Haskell satisfying all these requirements. The key lies in using \nHList-like typed heteroge\u00adneous collections (extensible polymorphic records) and expressing AG well-formedness \nconditions as type-level predicates (i.e., type\u00adclass constraints). By further type-level programming \nwe can also express common programming patterns, corresponding to the typ\u00adical use cases of monads such \nas Reader, Writer and State. The paper presents a realistic example of type-class-based type-level programming \nin Haskell. Categories and Subject Descriptors D.3.3 [Programming lan\u00adguages]: Language Constructs and \nFeatures; D.1.1 [Programming techniques]: Applicative (Functional) Programming General Terms Design, \nLanguages, Performance, Standardiza\u00adtion Keywords Attribute Grammars, Class system, Lazy evaluation, \nType-level programming, Haskell, HList 1. Introduction Functional programs can be easily extended by \nde.ning extra func\u00adtions. If however a data type is extended with a new alternative, Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 09, August 31 September \n2, 2009, Edinburgh, Scotland, UK. Copyright c &#38;#169; 2009 ACM 978-1-60558-332-7/09/08. . . $5.00 \neach parameter position and each case expression where a value of this type is matched has to be inspected \nand modi.ed accordingly. In object oriented programing the situation is reversed: if we imple\u00adment the \nalternatives of a data type by sub-classing, it is easy to add a new alternative by de.ning a new subclass \nin which we de.ne a method for each part of desired global functionality. If however we want to de.ne \na new function for a data type, we have to inspect all the existing subclasses and add a method describing \nthe local con\u00adtribution to the global computation over this data type. This prob\u00adlem was .rst noted by \nReynolds (Reynolds 1975) and later referred to as the expression problem by Wadler (Wadler 1998). We \nstart out by showing how the use of AGs overcomes this problem. As running example we use the classic \nrepmin function (Bird 1984); it takes a tree argument, and returns a tree of similar shape, in which \nthe leaf values are replaced by the minimal value of the leaves in the original tree (see Figure 1). \nThe program was origi\u00adnally introduced to describe so-called circular programs, i.e. pro\u00adgrams in which \npart of a result of a function is again used as one of its arguments. We will use this example to show \nthat the computa\u00adtion is composed of three so-called aspects: the computation of the minimal value as \nthe .rst component of the result of sem Tree (asp smin), passing down the globally minimal value from \nthe root to the leaves as the parameter ival (asp ival), and the con\u00adstruction of the resulting tree \nas the second component of the result (asp sres). Now suppose we want to change the function repmin into \na function repavg which replaces the leaves by the average value of the leaves. Unfortunately we have \nto change almost every line of the program, because instead of computing the minimal value we have to \ncompute both the sum of the leaf values and the total number of leaves. At the root level we can then \ndivide the total sum by the total number of leaves to compute the average leaf value. However, the traversal \nof the tree, the passing of the value to be used in constructing the new leafs and the construction of \nthe new tree all remain unchanged. What we are now looking for is a way to de.ne the function repmin \nas: repmin = sem Root (asp smin . asp ival . asp sres) so we can easily replace the aspect asp smin by \nasp savg: repavg = sem Root (asp savg . asp ival . asp sres) In Figure 2 we have expressed the solution \nof the repmin problem in terms of a domain speci.c language, i.e., as an attribute grammar (Swierstra \net al. 1999). Attributes are values associated with tree nodes. We will refer to a collection of (one \nor more) related attributes, with their de.ning rules, as an aspect. After de.ning the underlying data \ntypes by a few DATA de.nitions, we de.ne the different aspects: for the two result aspects we 4  1 2 \n8 3 6 1 1 1 1 1 1 data Root = Root Tree data Tree = Node Tree Tree | Leaf Int repmin = sem Root sem Root \n(Root tree) = let (smin, sres)=(sem Tree tree) smin in (sres) sem Tree (Node l r) = .ival . let (lmin, \nlres) = (sem Tree l ) ival (rmin, rres) = (sem Tree r ) ival in (lmin min rmin, Node lres rres) sem \nTree (Leaf i) = .ival . (i, Leaf ival)  . Figure 1. repmin replaces leaf values by their minimal value \n introduce synthesized attributes (SYN smin and SYN sres), and for the parameter aspect we introduce \nan inherited attribute (INH ival). Note that attributes are introduced separately, and that for each \nattribute/alternative pair we have a separate piece of code describ\u00ading what to compute in a SEM rule; \nthe de.ning expressions at the right hand side of the =-signs are all written in Haskell, using minimal \nsyntactic extensions to refer to attribute values (the identi\u00ad.ers starting with a @). These expressions \nare copied directly into the generated program: only the attribute references are replaced by references \nto values de.ned in the generated program. The attribute grammar system only checks whether for all attributes \na de.nition has been given. Type checking of the de.ning expressions is left to the Haskell compiler \nwhen compiling the generated program (given in Figure 1). As a consequence type errors are reported in \nterms of the gen\u00aderated program. Although this works reasonably well in practice, the question arises \nwhether we we can de.ne a set of combinators which enables us to embed the AG formalism directly in Haskell, \nthus making the separate generation step uncalled for and immedi\u00adately pro.ting from Haskell s type checker \nand getting error mes\u00adsages referring to the original source code. A .rst approach to such an embedded \nattribute grammar nota\u00adtion was made by de Moor et al. (de Moor et al. 2000b). Unfortu\u00adnately this approach, \nwhich is based on extensible records (Gaster and Jones 1996), necessitates the introduction of a large \nset of com\u00adbinators, which encode positions of children-trees explicitly. Fur\u00adthermore combinators are \nindexed by a number which indicates the number of children a node has where the combinator is to be ap\u00adplied. \nThe .rst contribution of this paper is that we show how to overcome this shortcoming by making use of \nthe Haskell class sys\u00adtem. The second contribution is that we show how to express the pre\u00advious solution \nin terms of heterogeneous collections, thus avoiding the use of Hugs-style extensible records are not \nsupported by the main Haskell compilers. DATA Root | Root tree DATA Tree | Node l, r : Tree | Leaf i \n: {Int } SYN Tree [smin : Int ] SEM Tree | Leaf lhs .smin =@i | Node lhs .smin =@l.smin min @r.smin INH \nTree [ival : Int ] SEM Root | Root tree.ival = @tree.smin SEM Tree | Node l .ival = @lhs.ival r .ival \n= @lhs.ival SYN Root Tree [sres : Tree ] SEM Root | Root lhs .sres =@tree.sres SEM Tree | Leaf lhs .sres \n= Leaf @lhs.ival | Node lhs .sres = Node @l.sres @r.sres Figure 2. AG speci.cation of repmin Attribute \ngrammars exhibit typical design patterns; an example of such a pattern is the inherited attribute ival, \nwhich is distributed to all the children of a node, and so on recursively. Other exam\u00adples are attributes \nwhich thread a value through the tree, or collect information from all the children which have a speci.c \nattribute and combine this into a synthesized attribute of the father node. In normal Haskell programming \nthis would be done by introducing a collection of monads (Reader, State and Writer monad respec\u00adtively), \nand by using monad transformers to combine these in to a single monadic computation. Unfortunately this \napproach breaks down once too many attributes have to be dealt with, when the data .ows backwards, and \nespecially if we have a non-uniform gram\u00admar, i.e., a grammar which has several different non-terminals \neach with a different collection of attributes. In the latter case a single monad will no longer be suf.cient. \nOne way of making such computational patterns .rst-class is by going to a universal representation for \nall the attributes, and packing and unpacking them whenever we need to perform a computation. In this \nway all attributes have the same type at the attribute grammar level, and non-terminals can now be seen \nas functions which map dictionaries to dictionaries, where such dictionaries are tables map\u00adping Strings \nrepresenting attribute names to universal attribute val\u00adues (de Moor et al. 2000a). Although this provides \nus with a power\u00adful mechanism for describing attribute .ows by Haskell functions, this comes at a huge \nprice; all attributes have to be unpacked before the contents can be accesses, and to be repacked before \nthey can be passed on. Worse still, the check that veri.es that all attributes are completely de.ned, \nis no longer a static check, but rather some\u00adthing which is implicitly done at run-time by the evaluator, \nas a side-effect of looking up attributes in the dictionaries. The third contribution of this paper is \nthat we show how patterns correspond\u00ading to the mentioned monadic constructs can be described, again \nusing the Haskell class mechanism. The fourth contribution of this paper is that it presents yet another \nlarge example of how to do type-level programming in Haskell, and what can be achieved with it. In our \nconclusions we will come back to this. Before going into the technical details we want to give an im\u00adpression \nof what our embedded Domain Speci.c Language (DSL)  data Root = Root{tree :: Tree }deriving Show data \nTree = Node{l :: Tree, r :: Tree }| Leaf {i :: Int }deriving Show $(deriveAG Root) $(attLabels [\"smin\", \n\"ival\", \"sres\" ]) asp smin = synthesize smin at {Tree }use min 0 at {Node }de.ne at Leaf = i asp ival \n= inherit ival at {Tree }copy at {Node }de.ne at Root.tree = tree.smin asp sres = synthesize sres at \n{Root, Tree }use Node (Leaf 0) at {Node }de.ne at Root = tree.sres Leaf = Leaf lhs.ival asp repmin = \nasp smin . asp sres . asp ival repmin t = select sres from compute asp repmin t Figure 3. repmin in our \nembedded DSL looks like. In Figure 3 we give our de.nition of the repmin prob\u00adlem in a lightly sugared \nnotation. To completely implement the repmin function the user of our library1 needs to undertake the \nfollowing steps (Figure 3): de.ne the Haskell data types involved; optionally, generate some boiler-plate \ncode using calls to Tem\u00adplate Haskell;  de.ne the aspects, by specifying whether the attribute is inher\u00adited \nor synthesized, with which non-terminals it is associated, how to compute its value if no explicit de.nition \nis given (i.e., which computational pattern it follows), and providing de.ni\u00adtions for the attribute \nat the various data type constructors (pro\u00adductions in grammar terms) for which it needs to be de.ned, \nresulting in asp repmin;  composing the aspects into a single large aspect asp repmin  de.ne the function \nrepmin that takes a tree, executes the se\u00admantic function for the tree and the aspect asp repmin, and \nselects the synthesized attribute sres from the result.  Together these rules de.ne for each of the \nproductions a so\u00adcalled Data Dependency Graph (DDG). A DDG is basically a data\u00ad.ow graph (Figure 4), \nwith as incoming values has the inherited at\u00adtributes of the father node and the synthesized attributes \nof the chil\u00addren nodes (indicated by closed arrows), and as outputs the inher\u00adited attributes of the \nchildren nodes and the synthesized attributes of the father node (open arrows). The semantics of our \nDSL is de\u00ad.ned as the data-.ow graph which results from composing all the DDGs corresponding to the individual \nnodes of the abstract syntax tree. Note that the semantics of a tree is thus represented by a func\u00adtion \nwhich maps the inherited attributes of the root node onto its synthesized attributes. The main result \nof this paper is a combinator based implementa\u00adtion of attribute grammars in Haskell; it has statically \ntype checked 1 Available as AspectAG in Hackage. ival  lmin min rmin Node lres rres  rmin lmin ival \nival rres lres sem Tree sem Tree Figure 4. The DDG for Node semantic functions, it is statically checked \nfor correctness at the at\u00adtribute grammar level, and high-level attribute evaluation patterns can be \ndescribed. In Section 2 we introduce the heterogeneous collections, which are used to combine a collection \nof inherited or synthesised at\u00adtributes into a single value. In Section 3 we show how individual attribute \ngrammar rules are represented. In Section 4 we introduce the aforementioned . operator which combines \nthe aspects. In Section 5 we introduce a function knit which takes the DDG asso\u00adciated with the production \nused at the root of a tree and the map\u00adpings (sem ... functions) from inherited to synthesised attributes \nfor its children (i.e. the data .ow over the children trees) and out of this constructs a data .ow computation \nover the combined tree. In Section 6 we show how the common patterns can be encoded in our library, and \nin Section 7 we show how default aspects can be de.ned. In Section 8 we discuss related work, and in \nSection 9 we conclude. 2. HList The library HList (Kiselyov et al. 2004) implements typeful het\u00aderogeneous \ncollections (lists, records, ...), using techniques for de\u00adpendently typed programming in Haskell (Hallgren \n2001; McBride 2002) which in turn make use of Haskell 98 extensions for multi\u00adparameter classes (Peyton \nJones et al. 1997) and functional depen\u00addencies (Jones 2000). The idea of type-level programming is based \non the use of types to represent type-level values, and classes to represent type-level types and functions. \nIn order to be self-contained we start out with a small introduc\u00adtion. To represent Boolean values at \nthe type level we de.ne a new type for each of the Boolean values. The class HBool represents the type-level \ntype of Booleans. We may read the instance de.nitions as the type-level values HTrue and HFalse have \nthe type-level type HBool : class HBool x data HTrue ; hTrue = . :: HTrue data HFalse; hFalse = . :: \nHFalse instance HBool HTrue instance HBool HFalse Since we are only interested in type-level computation, \nwe de\u00ad.ned HTrue and HFalse as empty types. By de.ning an inhabitant for each value we can, by writing \nexpressions at the value level, construct values at the type-level by referring to the types of such \nexpressions. Multi-parameter classes can be used to describe type-level re\u00adlations, whereas functional \ndependencies restrict such relations to functions. As an example we de.ne the class HOr for type-level \ndisjunction: class (HBool t, HBool ti, HBool tii) i . tii . HOr t ti tii | tt where hOr :: t . ti . \ntii iii The context (HBool t, HBool t, HBool t) expresses that the types t, ti and tii have to be type-level \nvalues of the type-level type HBool. The functional dependency tti . tii expresses that the parameters \nt and ti uniquely determine the parameter tii . This implies that once t and ti are instantiated, the \ninstance of tii must be uniquely inferable by the type-system, and that thus we are de.ning a type-level \nfunction from t and ti to tii. The type-level function itself is de.ned by the following non-overlapping \ninstance declarations:  instance HOr HFalse HFalse HFalse where hOr = hFalse instance HOr HTrue HFalse \nHTrue where hOr = hTrue instance HOr HFalse HTrue HTrue where hOr = hTrue instance HOr HTrue HTrue HTrue \nwhere hOr = hTrue  If we write (hOr hTrue hFalse), we know that t and ti are HTrue and HFalse, respectively. \nSo, the second instance is chosen to select hOr from and thus tii is inferred to be HTrue. Despite the \nfact that is looks like a computation at the value level, its actual purpose is to express a computation \nat the type\u00adlevel; no interesting value level computation is taking place at all. If we had de.ned HTrue \nand HFalse in the following way: data HTrue = HTrue ; hTrue = HTrue :: Htrue data HFalse = HFalse; hFalse \n= HFalse :: HFalse then the same computation would also be performed at the value level, resulting in \nthe value HTrue of type HTrue. 2.1 Heterogeneous Lists Heterogeneous lists are represented with the data \ntypes HNil and HCons, which model the structure of a normal list both at the value and type level: data \nHNil = HNil data HCons e l = HCons e l The sequence HCons True (HCons \"bla\" HNil) is a correct heterogeneous \nlist with type HCons Bool (HCons String HNil). Since we want to prevent that an expression HCons True \nFalse represents a correct heterogeneous list (the second HCons argu\u00adment is not a type-level list) we \nintroduce the classes HList and its instances,and express express this constraint by adding a context \ncondition to the HCons... instance: class HList l instance HList HNil instance HList l . HList (HCons \ne l) The library includes a multi-parameter class HExtend to model the extension of heterogeneous collections. \nclass HExtend e l li | el . li , li . el where hExtend :: e . l . li  The functional dependency el . \nli makes that HExtend is a type-level function, instead of a relation: once e and l are .xed li is uniquely \ndetermined. It .xes the type li of a collection, resulting from extending a collection of type l with \nan element of type e. The member hExtend performs the same computation at the level of values. The instance \nof HExtend for heterogeneous lists includes the well-formedness condition: instance HList l . HExtend \ne l (HCons e l) where hExtend = HCons  The main reason for introducing the class HExtend is to make \nit possible to encode constraints on the things which can be HCons\u00aded; here we have expressed that the \nsecond parameter should be a list again. In the next subsection we will see how to make use of this facility. \n 2.2 Extensible Records In our code we will make heavy use of non-homogeneous collec\u00adtions: grammars \nare a collection of productions, and nodes have a collection of attributes and a collection of children \nnodes. Such collections, which can be extended and shrunk, map typed labels to values and are modeled \nby an HList containing a heterogeneous list of .elds, marked with the data type Record. We will refer \nto them as records from now on: newtype Record r = Record r An empty record is a Record containing an \nempty heterogeneous list: emptyRecord :: Record HNil emptyRecord = Record HNil A .eld with label l (a \nphantom type (Hinze 2003)) and value of type v is represented by the type: newtype LVPair l v = LVPair{valueLVPair \n:: v } Labels are now almost .rst-class objects, and can be used as type\u00adlevel values. We can retrieve \nthe label value using the function labelLVPair, which exposes the phantom type parameter: labelLVPair \n:: LVPair l v . l labelLVPair = . Since we need to represent many labels, we introduce a polymor\u00adphic \ntype Proxy to represent them; by choosing a different phan\u00adtom type for each label to be represented \nwe can distinguish them: data Proxy e; proxy = . :: Proxy e Thus, the following declarations de.ne a \nrecord (myR) with two elements, labelled by Label1 and Label2 : data Label1 ; label1 = proxy :: Proxy \nLabel1 data Label2 ; label2 = proxy :: Proxy Label2 .eld1 = LVPair True :: LVPair (Proxy Label1 ) Bool \n.eld2 = LVPair \"bla\" :: LVPair (Proxy Label2 )[Char ] myR = Record (HCons .eld1 (HCons .eld2 HNil) Since \nour lists will represent collections of attributes we want to ex\u00adpress statically that we do not have \nmore than a single de.nition for each attribute occurrence, and so the labels in a record should be all \ndifferent. This constraint is represented by requiring an instance of the class HRLabelSet to be available \nwhen de.ning extendability for records: instance HRLabelSet (HCons (LVPair l v) r) . HExtend (LVPair \nl v)(Record r) (Record (HCons (LVPair l v) r)) where hExtend f (Record r)= Record (HCons f r) The class \nHasField is used to retrieve the value part corre\u00adsponding to a speci.c label from a record: class HasField \nl r v | lr . v where hLookupByLabel :: l . r . v At the type-level it is statically checked that the \nrecord r indeed has a .eld with label l associated with a value of the type v. At value-level the member \nhLookupByLabel returns the value of type v. So, the following expression returns the string \"bla\": hLookupByLabel \nlabel2 myR  The possibility to update an element in a record at a given label position is provided by: \nclass HUpdateAtLabel l v r ri | lvr . r i where hUpdateAtLabel :: l . v . r . r i  In order to keep \nour programs readable we introduce in.x oper\u00adators for some of the previous functions: (.*.)= hExtend \n.=. v = LVPair v r # l = hLookupByLabel l r  Furthermore we will use the following syntactic sugar to \ndenote lists and records in the rest of the paper: { v1 , ..., vn } for (v1 .*. ... .*. vn .*. HNil) \n{{ v1 , ..., vn }} for (v1 .*. ... .*. vn .*. emptyRecord) So, for example the de.nition of myR can \nnow be written as: myR = {{ label1 .=. True, label2 .=. \"bla\" }} 3. Rules In this subsection we show \nhow attributes and their de.ning rules are represented. An attribution is a .nite mapping from attribute \nnames to attribute values, represented as a Record, in which each .eld represents the name and value \nof an attribute. type Att att val = LVPair att val The labels2 (attribute names) for the attributes \nof the example are: data Att smin; smin = proxy :: Proxy Att smin data Att ival; ival = proxy :: Proxy \nAtt ival data Att sres; sres = proxy :: Proxy Att sres When inspecting what happens at a production \nwe see that infor\u00admation .ows from the inherited attribute of the parent and the syn\u00adthesized attributes \nof the children (henceforth called in the input family) to the synthesized attributes of the parent and \nthe inherited attributes of the children (together called the output family from now on). Both the input \nand the output attribute family is repre\u00adsented by an instance of: data Fam cp = Fam cp A Fam contains \na single attribution for the parent and a collection of attributions for the children. Thus the type \np will always be a Record with .elds of type Att, and the type c a Record with .elds of the type: type \nChi ch atts = LVPair ch atts where ch is a label that represents the name of that child and atts is \nagain a Record with the .elds of type Att associated with this particular child. In our example the Root \nproduction has a single child Ch tree of type Tree, the Node production has two children labelled by \nCh l and Ch r of type Tree, and the Leaf production has a single child called Ch i of type Int. Thus \nwe generate, using template Haskell: data Ch tree; ch tree = proxy :: Proxy (Ch tree, Tree) data Ch r; \nch r = proxy :: Proxy (Ch r, Tree) data Ch l; ch l = proxy :: Proxy (Ch l, Tree) data Ch i; ch i = proxy \n:: Proxy (Ch i, Int) Note that we encode both the name and the type of the child in the type representing \nthe label. 2 These and all needed labels can be generated automatically by Template Haskell functions \navailable in the library smin sres smin ival  smin sres   ival sres ival Figure 5. Repmin s input \nand output families for Node Families are used to model the input and output attributes of at\u00adtribute \ncomputations. For example, Figure 5 shows the input (black arrows) and output (white arrows) attribute \nfamilies of the repmin problem for the production Node. We now give the attributions as\u00adsociated with \nthe output family of the Node production, which are the synthesized attributes of the parent (SP) and \nthe inherited attri\u00adbutions for the left and right child (IL and IR): type SP = Record (HCons (Att (Proxy \nAtt smin) Int) HCons (Att (Proxy Att sres) Tree) HNil) type IL = Record (HCons (Att (Proxy Att ival) \nInt) HNil) type IR = Record (HCons (Att (Proxy Att ival) Int) HNil) The next type collects the last \ntwo children attributions into a single record: type IC = Record (HCons (Chi (Proxy (Ch l, Tree) IL) \nHCons (Chi (Proxy (Ch r, Tree) IR) HNil) We now have all the ingredients to de.ne the output family for \nNode-s. type Output Node = Fam IC SP Attribute computations are de.ned in terms of rules. As de.ned by \n(de Moor et al. 2000a), a rule is a mapping from an input family to an output family. In order to make \nrules composable we de.ne a rule as a mapping from input attributes to a function which extends a family \nof output attributes with the new elements de.ned by this rule: type Rule scipicspici sp i = Fam sc ip \n. Fam ic sp . Fam ici sp i Thus, the type Rule states that a rule takes as input the synthe\u00adsized attributes \nof the children sc and the inherited attributes of the parent ip and returns a function from the output \nconstructed thus far (inherited attributes of the children ic and synthesized attributes of the parent \nsp) to the extended output. The composition of two rules is the composition of the two functions after \napplying each of them to the input family .rst: ext :: Rule sc ip ici sp i icii sp ii . Rule scipicspici \nsp i . Rule scipicspicii sp ii (f ext g) input = f input.g input  3.1 Rule De.nition We now introduce \nthe functions syndef and inhdef , which are used to de.ne primitive rules which de.ne a synthesized or \nan inherited attribute respectively. Figure 6 lists all the rule de.nitions for our running example. \nThe naming convention is such that a rule with name prod att de.nes the attribute att for the production \nprod. Without trying to completely understand the de.nitions we suggest the reader to compare them with \ntheir respective SEM speci.cations in Figure 2.  leaf smin (Fam chi par) = syndef smin (chi # ch i) \nnode smin (Fam chi par) = syndef smin (((chi # ch l)# smin) min ((chi # ch r)# smin)) root ival (Fam \nchi par) = inhdef ival { nt Tree }{{ ch tree .=. (chi # ch tree)# smin }} node ival (Fam chi par) = inhdef \nival { nt Tree } {{ ch l .=. par # ival , ch r .=. par # ival }} root sres (Fam chi par) = syndef sres \n((chi # ch tree)# sres) leaf sres (Fam chi par) = syndef sres (Leaf (par # ival)) node sres (Fam chi \npar) = syndef sres (Node ((chi # ch l)# sres) ((chi # ch r)# sres)) Figure 6. Rule de.nitions for repmin \n The function syndef adds the de.nition of a synthesized at\u00adtribute. It takes a label att representing \nthe name of the new at\u00adtribute, a value val to be assigned to this attribute, and it builds a function \nwhich updates the output constructed thus far. syndef :: HExtend (Att att val) sp sp i . att . val . \n(Fam ic sp . Fam ic spi) syndef att val (Fam ic sp)= Fam ic (att .=. val .*. sp) The record sp with \nthe synthesized attributes of the parent is ex\u00adtended with a .eld with name att and value val, as shown \nin Fig\u00adure 7. If we look at the type of the function, the check that we have not already de.ned this \nattribute is done by the constraint HExtend (Att att val) sp sp i, meaning that sp i is the result of \nadding the .eld (Att att val) to sp, which cannot have any .eld with name att. Thus we are statically \npreventing duplicated attribute de.nitions. sp sp,att = val ... icn ... icn ic1 ic1 Figure 7. Synthesized \nattribute de.nition Let us take a look at the rule de.nition node smin of the attribute smin for the \nproduction Node in Figure 6. The children ch l and ch r are retrieved from the input family so we can \nsubsequently retrieve the attribute smin from these attributions, and construct the computation of the \nsynthesized attribute smin. This process is demonstrated in Figure 8. The attribute smin is required \n(under\u00adlined) in the children l and r of the input, and the parent of the output is extended with smin. \nIf we take a look at the type which is inferred for node sres we .nd back all the constraints which are \nnormally checked by an off-line attribute grammar system, i.e., an attribute smin is made available ival \nsres sres smin smin ... ..., smin ... ... ... ...  Figure 8. Rule node sres by each child and an attribute \nsmin can be safely added to the current synthesized attribution of the parent: 3 node sres :: (HasField \n(Proxy (Ch l, Tree)) sc scl , HasField (Proxy Att smin) scl Int , HasField (Proxy (Ch r, Tree)) sc scr \n, HasField (Proxy Att smin) scr Int , HExtend (Att (Proxy Att smin) Int) sp sp i) . Rule scipicspicspi \nThe function inhdef introduces a new inherited attribute for a collection of non-terminals. It takes \nthe following parameters: att the attribute which is being de.ned; nts the non-terminals with which this \nattribute is being associated; vals a record labelled with child names and containing values, describing \nhow to compute the attribute being de.ned at each of the applicable child positions. The parameter nts \ntakes over the role of the INH declaration in Figure 2. Here this extra parameter seems to be super.uous, \nsince its value can be inferred, but adds an additional restriction to be checked (yielding to better \nerrors) and it will be used in the introduction of default rules later. The names for the non-terminals \nof our example are: nt Root = proxy :: Proxy Root nt Tree = proxy :: Proxy Tree The result of inhdef \nagain is a function which updates the output constructed thus far. inhdef :: Defs att nts vals ic ici \n. att . nts . vals . (Fam ic sp . Fam ici sp) inhdef att nts vals (Fam ic sp)= Fam (defs att nts vals \nic) sp The class Def is de.ned by induction over the record vals contain\u00ading the new de.nitions. The \nfunction defs inserts each de.nition into the attribution of the corresponding child. class Defs att \nnts vals ic ici | vals ic . ici where defs :: att . nts . vals . ic . ici We start out with the base \ncase, where we have no more de.nitions to add. In this case the inherited attributes of the children \nare returned unchanged. instance Defs att nts (Record HNil) ic ic where defs ic = ic The instance for \nHCons given below .rst recursively processes the rest of the de.nitions by updating the collection of \ncollections of inherited attributes of the children ic into ici. A helper type level 3 In order to keep \nthe explanation simple we will suppose that min is not overloaded, and takes Int s as parameter.  function \nSingleDef (and its corresponding value level function singledef ) is used to incorporate the single de.nition \n(pch) into ici, resulting in a new set icii. The type level functions HasLabel and HMember are used to \nstatically check whether the child be\u00ading de.ned (lch) exists in ici and if its type (t) belongs to the \nnon-terminals nts, respectively. The result of both functions are HBools (either HTrue or HFalse) which \nare passed as parame\u00adters to SingleDef . We are now ready to give the de.nition for the non-empty case: \ninstance (Defs att nts (Record vs) ic ici , HasLabel (Proxy (lch, t)) ici mch , HMember (Proxy t) nts \nmnts , SingleDef mch mnts att (Chi (Proxy (lch, t)) vch) ici icii) . Defs att nts (Record (HCons (Chi \n(Proxy (lch, t)) vch) vs)) ic icii where defs att nts ~(Record (HCons pch vs)) ic = singledef mch mnts \natt pch ici where ici = defs att nts (Record vs) ic lch = labelLVPair pch mch = hasLabel lch ici mnts \n= hMember (sndProxy lch) nts The class Haslabel can be encoded straightforwardly, together with a function \nwhich retrieves part of a phantom type: class HBool b . HasLabel l r b | lr . b instance HasLabel l r \nb . HasLabel l (Record r) b bii instance (HEq l lpb, HasLabel l r bi , HOr bbi ) . HasLabel l (HCons \n(LVPair lp vp) r) bii instance HasLabel l HNil HFalse hasLabel :: HasLabel l r b . l . r . b hasLabel \n= . sndProxy :: Proxy (a, b) . Proxy b sndProxy = .  We only show the instance with both mch and mnts \nequal to HTrue, which is the case we expect to apply in a correct attribute grammar de.nition: we do \nnot refer to children which do not exist, and this child has the type we expect.4 class SingleDef mch \nmnts att pv ic ici | mch mnts pv ic . ici where singledef :: mch . mnts . att . pv . ic . ici instance \n(HasField lch ic och , HExtend (Att att vch) och ochi , HUpdateAtLabel lch ochi ic ici) . SingleDef \nHTrue HTrue att (Chi lch vch) ic ici where singledef att pch ic = hUpdateAtLabel lch (att .=. vch .*. \noch) ic where lch = labelLVPair pch vch = valueLVPair pch och = hLookupByLabel lch ic We will guarantee \nthat the collection of attributions ic (inherited attributes of the children) contains an attribution \noch for the child lch, and so we can use hUpdateAtlabel to extend the attribution 4 The instances for \nerror cases could just be left unde.ned, yielding to unde.ned instance type errors. In our library we \nuse a class Fail (as de.ned in (Kiselyov et al. 2004), section 6) in order to get more instructive type \nerror messages. for this child with a .eld (Att att vch), thus binding attribute att to value vch. The \ntype system checks, thanks to the presence of HExtend, that the attribute att was not de.ned before in \noch. 4. Aspects We represent aspects as records which contain for each production a rule .eld. type Prd \nprd rule = LVPair prd rule For our example we thus introduce fresh labels to refer to repmin s productions: \ndata P Root; p Root = proxy :: Proxy P Root data P Node; p Node = proxy :: Proxy P Node data P Leaf ; \np Leaf = proxy :: Proxy P Leaf We now can de.ne the aspects of repmin as records with the rules of Figure \n6.5 asp smin = {{ p Leaf .=. leaf smin , p Node .=. node smin }} asp ival = {{ p Root .=. root ival , \np Node .=. node ival }} asp sres = {{ p Root .=. root sres , p Node .=. node sres , p Leaf .=. leaf sres \n}} 4.1 Aspects Combination We de.ne the class Com which will provide the instances we need for combining \naspects: class Com r ri r ii | rr i . r ii where ( . ) :: r . r i . r ii With this operator we can now \ncombine the three aspects which together make up the repmin problem: asp repmin = asp smin . asp ival \n. asp sres Combination of aspects is a sort of union of records where, in case of .elds with the same \nlabel (i.e., for rules for the same production), the rule combination (ext) is applied to the values. \nTo perform the union we iterate over the second record, inserting the next element into the .rst one \nif it is new and combining it with an existing entry if it exists: instance Com r (Record HNil) r where \nr . = r instance (HasLabel lprd r b , ComSingle b (Prd lprd rprd) rr iii , Com riii (Record ri) r ii) \n . Com r (Record (HCons (Prd lprd rprd) r i)) r ii where r . (Record (HCons prd ri)) = r ii where b = \nhasLabel (labelLVPair prd) r r iii = comsingle b prd r r ii = r iii . (Record ri) We use the class ComSingle \nto insert a single element into the .rst record. The type-level Boolean parameter b is used to distinguish \nthose cases where the left hand operand already contains a .eld for the rule to be added and the case \nwhere it is new. 6 5 We assume that the monomorphism restriction has been switched off. 6 This parameter \ncan be avoided by allowing overlapping instances, but we prefer to minimize the number of Haskell extensions \nwe use.  class ComSingle b f r r i | bf r . r i where comsingle :: b . f . r . r i  If the .rst record \nhas a .eld with the same label lprd, we update its value by composing the rules. ii) instance (HasField \nlprd r (Rule sc ip ici sp i icii sp , HUpdateAtLabel lprd (Rule sc ip ic sp icii ii sp ) rr i) . ComSingle \nHTrue (Prd lprd (Rule scipicspici sp i)) i rr where comsingle f r = hUpdateAtLabel n ((r # n) ext v) \nr where n = labelLVPair f v = valueLVPair f In case the .rst record does not have a .eld with the label, \nwe just insert the element in the record. instance ComSingle HFalse f (Record r) (Record (HCons f r)) \nwhere comsingle f (Record r)= Record (HCons f r) 5. Semantic Functions Our overall goal is to construct \na Tree-algebra and a Root-algebra. For the domain associated with each non-terminal we take the function \nmapping its inherited to its synthesized attributes. The hard work is done by the function knit, the \npurpose of which is to combine the data .ow de.ned by the DDG which was constructed by combining all \nthe rules for this production with the semantic functions of the children (describing the .ow of data \nfrom their inherited to their synthesized attributes) into the semantic function for the parent. With \nthe attribute computations as .rst-class entities, we can now pass them as an argument to functions of \nthe form sem <nt>. The following code follows the de.nitions of the data types at hand: it contains recursive \ncalls for all children of an alternative, each of which results in a mapping from inherited to synthesized \nattributes for that child followed by a call to knit, which stitches everything together: sem Root asp \n(Root t) = knit (asp # p Root) {{ ch tree .=. sem Tree asp t }} sem Tree asp (Node l r) = knit (asp # \np Node) {{ ch l .=. sem Tree asp l , ch r .=. sem Tree asp r }} sem Tree asp (Leaf i ) = knit (asp # \np Leaf ) {{ ch i .=. sem Lit i }} sem Lit e (Record HNil)= e Since this code is completely generic we \nprovide a Template Haskell function deriveAG which automatically generates the functions such as sem \nRoot and sem Tree, together with the labels for the non-terminals and labels for referring to children. \nThus, to completely implement the repmin function we need to undertake the following steps: Generate \nthe semantic functions and the corresponding labels by using: $(deriveAG Root) De.ne and compose the \naspects as shown in the previous sec\u00adtions, resulting in asp repmin. De.ne the function repmin that \ntakes a tree, executes the semantic function for the tree and the aspect asp repmin, and selects the \nsynthesized attribute sres from the result. repmin tree = sem Root asp repmin (Root tree) ()# sres 5.1 \nThe Knit Function As said before the function knit takes the combined rules for a node and the semantic \nfunctions of the children, and builds a function from the inherited attributes of the parent to its synthesized \nattributes. We start out by constructing an empty output family, containing an empty attribution for \neach child and one for the parent. To each of these attributions we apply the corresponding part of the \nrules, which will construct the inherited attributes of the children and the synthesized attributes of \nthe parent (together forming the output family). Rules however contain references to the input family, \nwhich is composed of the inherited attributes of the parent ip and the synthesized attributes of the \nchildren sc. knit :: (Empties fc ec, Kn fcicsc) . Rule sc ip ec (Record HNil) ic sp . fc . ip . sp knit \nrule fc ip = let ec = empties fc (Fam ic sp)= rule (Fam sc ip) (Fam ec emptyRecord) sc = kn fcic in \nsp The function kn, which takes the semantic functions of the children (fc) and their inputs (ic), computes \nthe results for the children (sc). The functional dependency fc . ic sc indicates that fc determines \nic and sc, so the shape of the record with the semantic functions determines the shape of the other records: \nclass Kn fcicsc | fc . ic sc where kn :: fc . ic . sc We declare a helper instance of Kn to remove the \nRecord tags of the parameters, in order to be able to iterate over their lists without having to tag \nand untag at each step: instance Kn fcicsc . Kn (Record fc)(Record ic)(Record sc) where kn (Record fc)(Record \nic)= Record $ kn fcic When the list of children is empty, we just return an empty list of results. instance \nKn HNil HNil HNil where kn = hNil The function kn is a type level zipWith ($), which applies the functions \ncontained in the .rst argument list to the corresponding element in the second argument list. instance \nKn fcr icr scr . Kn (HCons (Chi lch (ich . sch)) fcr) (HCons (Chi lch ich) icr) (HCons (Chi lch sch) \nscr) where kn ~(HCons pfch fcr) ~(HCons pich icr)= let scr = kn fcr icr lch = labelLVPair pfch fch = \nvalueLVPair pfch ich = valueLVPair pich in HCons (newLVPair lch (fch ich)) scr  The class Empties is \nused to construct the record, with an empty attribution for each child, which we have used to initialize \nthe computation of the input attributes with. class Empties fc ec | fc . ec where empties :: fc . ec \n In the same way that fc determines the shape of ic and sc in Kn, it also tells us how many empty attributions \nec to produce and in which order: instance Empties fc ec . Empties (Record fc)(Record ec) where empties \n(Record fc)= Record $ empties fc instance Empties fcr ecr . Empties (HCons (Chi lch fch) fcr) (HCons \n(Chi lch (Record HNil)) ecr) where empties ~(HCons pch fcr)= let ecr = empties fcr lch = labelLVPair \npch in HCons (newLVPair lch emptyRecord) ecr instance Empties HNil HNil where empties = hNil 6. Common \nPatterns At this point all the basic functionality of attribute grammars has been implemented. In practice \nhowever we want more. If we look at the code in Figure 2 we see that the rules for ival at the production \nNode are free of semantics , since the value is copied unmodi.ed to its children. If we were dealing \nwith a tree with three children instead of two the extra line would look quite similar. When pro\u00adgramming \nattribute grammars such patterns are quite common and most attribute grammar systems contain implicit \nrules which au\u00adtomatically insert such trivial rules. As a result descriptions can decrease in size dramatically. \nThe question now arises whether we can extend our embedded language to incorporate such more high level \ndata .ow patterns. 6.1 Copy Rule The most common pattern is the copying of an inherited attribute from \nthe parent to all its children. We capture this pattern with the an operator copy, which takes the name \nof an attribute att and an heterogeneous list of non-terminals nts for which the attribute has to be \nde.ned, and generates a copy rule for this. This corresponds closely to the introduction of a Reader \nmonad. copy :: (Copy att nts vp ic ici , HasField att ip vp) . att . nts . Rule scipicspici sp Thus, \nfor example, the rule node ival of Figure 6 can now be written as: node ival input = copy ival { nt Tree \n} input The function copy uses a function defcp to de.ne the attribute att as an inherited attribute \nof its children. This function is similar in some sense to inhdef , but instead of taking a record containing \nthe new de.nitions it gets the value vp of the attribute which is to be copied to the children: copy \natt nts (Fam ip)= defcp att nts (ip # att) defcp :: Copy att nts vp ic ici . att . nts . vp . (Fam ic \nsp . Fam ici sp) defcp att nts vp (Fam ic sp)= Fam (cpychi att nts vp ic) sp The class Copy iterates \nover the record ic containing the output attribution of the children, and inserts the attribute att with \nvalue vp if the type of the child is included in the list nts of non-terminals and the attribute is not \nalready de.ned for this child. class Copy att nts vp ic ici | ic . ici where cpychi :: att . nts . vp \n. ic . ici instance Copy att nts vp (Record HNil)(Record HNil) where cpychi = emptyRecord instance (Copy \natt nts vp (Record ics) icsi , HMember (Proxy t) nts mnts , HasLabel att vch mvch , Copyi mnts mvch att \nvp (Chi (Proxy (lch, t)) vch) pch , HExtend pch icsi ic) . Copy att nts vp (Record (HCons (Chi (Proxy \n(lch, t)) vch) ics)) ic where cpychi att nts vp (Record (HCons pch ics)) = cpychii mnts mvch att vp pch \n.*. icsi where icsi = cpychi att nts vp (Record ics) lch = sndProxy (labelLVPair pch) vch = valueLVPair \npch mnts = hMember lch nts mvch = hasLabel att vch The function cpychii updates the .eld pch by adding \nthe new attribute: class Copyi mnts mvch att vp pch pchi | mnts mvch pch . pchi where cpychii :: mnts \n. mvch . att . vp . pch . pchi When the type of the child doesn t belong to the non-terminals for which \nthe attribute is de.ned we de.ne an instance which leaves the .eld pch unchanged. instance Copyi HFalse \nmvch att vp pch pch where cpychii pch = pch We also leave pch unchanged if the attribute is already \nde.ned for this child. instance Copyi HTrue HTrue att vp pch pch where cpychii pch = pch In other case \nthe attribution vch is extended with the attribute (Att att vp). instance HExtend (Att att vp) vch vchi \n. Copyi HTrue HFalse att vp (Chi lch vch) (Chi lch vchi) where cpychii att vp pch = lch .=. (att .=. \nvp .*. vch) where lch = labelLVPair pch vch = valueLVPair pch  6.2 Other Rules In this section we introduce \ntwo more constructs of our DSL, with\u00adout giving their implementation. Besides the Reader monad, there \nis also the Writer monad. Often we want to collect information provided by some of the children into \nan attribute of the parent. This can be used to e.g. collect all identi.ers contained in an ex\u00adpression. \nSuch a synthesized attribute can be declared using the use rule, which combines the attribute values \nof the children in similar way as Haskell s foldr1 . The use rule takes the following arguments: the \nattribute to be de.ned, the list of non-terminals for which the attribute is de.ned, a monoidal operator \nwhich combines the attribute values, and a unit value to be used in those cases where none of the children \nhas such an attribute.  use :: (Use att nts a sc, HExtend (Att att a) sp sp i) . att . nts . (a . a \n. a) . a . Rule scipicspicspi Using this new combinator the rule node smin of Figure 6 be\u00adcomes: node \nsmin = use smin { nt Tree } min 0 A third common pattern corresponds to the use of the State monad. \nA value is threaded in a depth-.rst way through the tree, being updated every now and then. For this \nwe have chained at\u00adtributes (both inherited and synthesized). If a de.nition for a syn\u00adthesized attribute \nof the parent with this name is missing we look for the right-most child with a synthesized attribute \nof this name. If we are missing a de.nition for one of the children, we look for the right-most of its \nleft siblings which can provide such a value, and if we cannot .nd it there, we look at the inherited \nattributes of the father. chain :: (Chain att nts val sc ic sp ici sp i , HasField att ip val) . att \n. nts . Rule scipicspici sp i 7. De.ning Aspects Now we have both implicit rules to de.ne attributes, \nand explicit rules which contain explicit de.nitions, we may want to combine these into a single attribute \naspect which contains all the de.nitions for single attribute. We now refer to Figure 9 which is a desugared \nversion of the notation presented in the introduction. An inherited attribute aspect, like asp ival in \nFigure 9, can be de.ned using the function inhAspect. It takes as arguments: the name of the attribute \natt, the list nts of non-terminals where the attribute is de.ned, the list cpys of productions where \nthe copy rule has to be applied, and a record defs containing the explicit de.nitions for some productions: \ninhAspect att nts cpys defs =(defAspect (FnCpy att nts) cpys) . (attAspect (FnInh att nts) defs)  The \nfunction attAspect generates an attribute aspect given the ex\u00adplicit de.nitions, whereas defAspect constructs \nan attribute aspect based in a common pattern s rule. Thus, an inherited attribute as\u00adpect is de.ned \nas a composition of two attribute aspects: one with the explicit de.nitions and other with the application \nof the copy rule. In the following sections we will see how attAspect and defAspect are implemented. \nA synthesized attribute aspect, like asp smin and asp sres in Figure 9, can be de.ned using synAspect. \nHere the rule applied is the use rule, which takes op as the monoidal operator and unit as the unit value. \nsynAspect att nts op unit uses defs =(defAspect (FnUse att nts op unit) uses) . (attAspect (FnSyn att) \ndefs)  A chained attribute de.nition introduces both an inherited and a synthesized attribute. In this \ncase the pattern to be applied is the chain rule. chnAspect att nts chns inhdefs syndefs =(defAspect \n(FnChn att nts) chns) . (attAspect (FnInh att nts) inhdefs) . (attAspect (FnSyn att) syndefs) 7.1 Attribute \nAspects Consider the explicit de.nitions of the aspect asp sres. The idea is that, when declaring the \nexplicit de.nitions, instead of completely writing the rules, like: {{ p Root .=. (.input . syndef sres \n((chi input # ch tree)# sres)) , p Leaf .=. (.input . syndef sres (Leaf (par input # ival))) }} we just \nde.ne a record with the functions from the input to the attribute value: {{ p Root .=. (.input . (chi \ninput # ch tree)# sres) , p Leaf .=. (.input . Leaf (par input # ival)) }} By mapping the function ((.)(syndef \nsres)) over such records, we get back our previous record containing rules. The function attAspect updates \nall the values of a record by applying a function to them: class AttAspect rdef defs rules | rdef defs \n. rules where attAspect :: rdef . defs . rules instance (AttAspect rdef (Record defs) rules , Apply rdef \ndef rule , HExtend (Prd lprd rule) rules rulesi) . AttAspect rdef (Record (HCons (Prd lprd def ) defs)) \nrulesi where attAspect rdef (Record (HCons def defs)) = let lprd =(labelLVPair def ) in lprd .=. apply \nrdef (valueLVPair def ) .*. attAspect rdef (Record defs) instance AttAspect rdef (Record HNil)(Record \nHNil) where attAspect = emptyRecord The class Apply (from the HList library) models the function application, \nand it is used to add speci.c constraints on the types: class Applyf ar | fa . r where apply :: f . a \n. r In the case of synthesized attributes we apply ((.)(syndef att)) to values of type (Fam sc ip . val) \nin order to construct a rule of type (Rule scip icspicsp i). The constraint HExtend (LVPair att val) \nsp sp i is introduced by the use of syndef . The data type FnSyn is used to determine which instance \nof Apply has to be chosen. data FnSyn att = FnSyn att instance HExtend (LVPair att val) sp sp i . Apply \n(FnSyn att)(Fam sc ip . val) (Rule scipicspicspi) where apply (FnSyn att) f = syndef att.f In the case \nof inherited attributes the function applied to de.ne the rule is ((.)(inhdef att nts)). data FnInh att \nnt = FnInh att nt instance Defs att nts vals ic ici . Apply (FnInh att nts)(Fam sc ip . vals)  asp smin \n= synAspect smin { nt Tree } --synthesize at min 0 { p Node } --use at {{ p Leaf .=. (.(Fam chi ) . chi \n# ch i) }} --de.ne at asp ival = inhAspect ival { nt Tree } --inherit { p Node } --copy at {{ p Root \n.=. (.(Fam chi ) . {{ ch tree .=. (chi # ch tree)# smin }}) }} --de.ne at asp sres = synAspect sres { \nnt Root, nt Tree } --synthesize at Node (Leaf 0) { p Node } --use at {{ p Root .=. (.(Fam chi ) . (chi \n# ch tree)# sres) --de.ne at , p Leaf .=. (.(Fam par) . Leaf (par # ival)) }} Figure 9. Aspects de.nition \nfor repmin (Rule scipicspici sp) where hand, because Agda only permits the de.nition of total functions, \napply (FnInh att nts) f = inhdef att nts.f 7.2 Default Aspects The function defAspect is used to construct \nan aspect given a rule and a list of production labels. class DefAspect de. prds rules | de. prds . rules \nwhere defAspect :: de. . prds . rules It iterates over the list of labels prds, constructing a record \nwith these labels and a rule determined by the parameter de. as value. For inherited attributes we apply \nthe copy rule copy att nts, for synthesized attributes use att nt op unit and for chained attributes \nchain att nts. The following types are used, in a similar way than in attAspect, to determine the rule \nto be applied: data FnCpy att nts = FnCpy att nts data FnUse att nt op unit = FnUse att nt op unit data \nFnChn att nt = FnChn att nt Thus, for example in the case of the aspect asp ival, the applica\u00adtion: \ndefAspect (FnCpy ival { nt Tree }) { p Node } generates the default aspect: {{ p Node .=. copy ival \n{ nt Tree } }} 8. Related Work There have been several previous attempts at incorporating .rst\u00adclass \nattribute grammars in lazy functional languages. To the best of our knowledge all these attempts exploit \nsome form of extensible records to collect attribute de.nitions. They however do not exploit the Haskell \nclass system as we do. de Moor et al. (2000b) introduce a whole collection of functions, and a result \nit is no longer possible to de.ne copy, use and chain rules. Other approaches fail to provide some of \nthe static guarantees that we have enforced (de Moor et al. 2000a). The exploration of the limitations \nof type-level programming in Haskell is still a topic of active research. For example, there has been \nrecent work on modelling relational data bases using techniques similar to those applied in this paper \n(Silva and Visser 2006). As to be expected the type-level programming performed here in Haskell can also \nbe done in dependently typed languages such as Agda (Norell 2008; Oury and Swierstra 2008). By doing \nso, we use Boolean values in type level-functions, thereby avoiding the need for a separate de.nition \nof the type-level Booleans. This would certainly simplify certain parts of our development. On the other \nwe would need to maintain even more information in our types to make it evident that all our functions \nare indeed total. An open question is how easy it will be to extend the approach taken to more global \nstrategies of accessing attributes de.nitions; some attribute grammars systems allow references to more \nremote attributes (Reps et al. 1986; Boyland 2005). Although we are con\u00advinced that we can in principle \nencode such systems too, the ques\u00adtion remains how much work this turns out to be. Another thing we could \nhave done is to make use of associated types (Chakravarty et al. 2005) in those cases where our relations \nare actually functions; since this feature is still experimental and has only recently become available \nwe have refrained from doing so for the moment. 9. Conclusions In the .rst place we remark that we have \nachieved all four goals stated in the introduction: 1. removing the need for a whole collection of indexed \ncombina\u00adtors as used in (de Moor et al. 2000b) 2. replacing extensible records completely by heterogeneous \ncol\u00adlections 3. the description of common attribute grammar patterns in order to reduce code size, and \nmaking them almost .rst class objects 4. give a nice demonstration of type level programming  We have \nextensive experience with attribute grammars in the construction of the Utrecht Haskell compiler (Dijkstra \net al. 2009). The code of this compiler is completely factored out along the two axes mentioned in the \nintroduction (Dijkstra and Swierstra 2004; Fokker and Swierstra 2008; Dijkstra et al. 2007), using the \nnotation used in Figure 2. In doing so we have found the possibility to factor the code into separate \npieces of text indispensable. We also have come to the conclusion that the so-called monadic approach, \nalthough it may seem attractive at .rst sight, in the end brings considerable complications when programs \nstart to grow (Jones 1999). Since monad transformers are usually type based we already run into problems \nif we extend a state twice with a value of the same type without taking explicit measures to avoid confusion. \nAnother complication is that the interfaces of non-terminals are in general not uniform, thus necessitating \nall kind of tricks to change the monad at the right places, keeping information to be reused later, etc. \nIn our generated Haskell compiler (Dijkstra et al. 2009) we have non-terminals with more than 10 different \nattributes, and glueing all these together or selectively leaving some out turns out to be impossible \nto do by hand.  In our attribute grammar system (uuagc on Hackage), we per\u00adform a global .ow analysis, \nwhich makes it possible to schedule the computations explicitly (Kastens 1980). Once we know the evalua\u00adtion \norder we do not have to rely on lazy evaluation, and all param\u00adeter positions can be made strict. When \ncombined with a unique\u00adness analysis we can, by reusing space occupied by unreachable attributes, get \nan even further increase in speed. This leads to a considerable, despite constant, speed improvement. \nUnfortunately we do not see how we can perform such analyses with the approach described in this paper: \nthe semantic functions de.ning the values of the attributes in principle access the whole input family, \nand we cannot .nd out which functions only access part of such a family, and if so which part. Of course \na straightforward implementation of extensible records will be quite expensive, since basically we use \nnested pairs to rep\u00adresent attributions. We think however that a not too complicated program analysis \nwill reveal enough information to be able to transform the program into a much more ef.cient form by \n.atten\u00ading such nested pairs. Note that thanks to our type-level functions, which are completely evaluated \nby the compiler, we do not have to perform any run-time checks as in (de Moor et al. 2000a): once the \nprogram type-checks there is nothing which will prevent it to run to completion, apart form logical errors \nin the de.nitions of the attributes. Concluding we think that the library described here is quite use\u00adful \nand relatively easy to experiment with. We notice furthermore that a conventional attribute grammar restriction, \nstating that no at\u00adtribute should depend on itself, does not apply since we build on top of a lazily \nevaluated language. An example of this can be found in online pretty printing (Swierstra 2004; Swierstra \nand Chitil 2009). Once we go for speed it may become preferable to use more con\u00adventional off-line generators. \nIdeally we should like to have a mixed approach in which we can use the same de.nitions as input for \nboth systems. 10. Acknowledgments We want to thank Oege de Moor for always lending an ear in discussing \nthe merits of attribute grammars, and how to further pro.t from them. Marcos Viera wants to thank the \nEU project Lernet for funding his stay in Utrecht. Finally, we would like to thank the anonymous referees \nfor their helpful reviews. References Richard S. Bird. Using circular programs to eliminate multiple \ntraversals of data. Acta Inf., 21:239 250, 1984. John Boyland. Remote attribute grammars. Journal of \nthe ACM (JACM, 52(4), Jul 2005. URL http://portal.acm.org/citation.cfm?id=1082036.1082042. Manuel M. \nT. Chakravarty, Gabriele Keller, and Simon Peyton Jones. Associated type synonyms. In ICFP 05: Proceedings \nof the tenth ACM SIGPLAN international conference on Functional programming, pages 241 253, New York, \nNY, USA, 2005. ACM. Oege de Moor, Kevin Backhouse, and S. Doaitse Swierstra. First-class attribute grammars. \nInformatica (Slovenia), 24(3), 2000a. Oege de Moor, L. Peyton Jones, Simon, and Van Wyk, Eric. Aspect-oriented \ncompilers. In GCSE 99: Proceedings of the First International Symposium on Generative and Component-Based \nSoftware Engineering, pages 121 133, London, UK, 2000b. Springer-Verlag. ISBN 3-540-41172-0. Atze Dijkstra \nand S. Doaitse Swierstra. Typing Haskell with an Attribute Grammar. In Advanced Functional Programming \nSummerschool, number 3622 in LNCS. Springer-Verlag, 2004. Atze Dijkstra, Jeroen Fokker, and S. Doaitse \nSwierstra. The structure of the essential haskell compiler, or coping with compiler complexity. In Implementation \nof Functional Languages, 2007. Atze Dijkstra, Jeroen Fokker, and S. Doaitse Swierstra. The architecture \nof the Utrecht Haskell compiler. In Haskell Symposium, New York, NY, USA, September 2009. ACM. Jeroen \nFokker and S. Doaitse Swierstra. Abstract interpretation of functional programs using an attribute grammar \nsystem. In Adrian Johnstone and Jurgen Vinju, editors, Language Descriptions, Tools and Applications, \n2008. Benedict R. Gaster and Mark P. Jones. A polymorphic type system for extensible records and variants. \nNOTTCS-TR 96-3, Nottingham, 1996. Thomas Hallgren. Fun with functional dependencies or (draft) types \nas values in static computations in haskell. In Proc. of the Joint CS/CE Winter Meeting, 2001. Ralf Hinze. \nFun with phantom types. In Jeremy Gibbons and Oege de Moor, editors, The Fun of Programming, pages 245 \n262. Palgrave Macmillan, 2003. Mark P. Jones. Typing Haskell in Haskell. In Haskell Workshop, 1999. URL \nhttp://www.cse.ogi.edu/ mpj/thih/thih-sep1-1999/. P. Jones, Mark. Type classes with functional dependencies. \nIn ESOP 00: Proceedings of the 9th European Symposium on Programming Languages and Systems, pages 230 \n244, London, UK, 2000. Springer-Verlag. Uwe Kastens. Ordered Attribute Grammars. Acta Informatica, 13: \n229 256, 1980. Oleg Kiselyov, Ralf L\u00a8ammel, and Keean Schupke. Strongly typed heterogeneous collections. \nIn Haskell 04: Proceedings of the ACM SIGPLAN workshop on Haskell, pages 96 107. ACM Press, 2004. Conor \nMcBride. Faking it simulating dependent types in haskell. J. Funct. Program., 12(5):375 392, 2002. Ulf \nNorell. Dependently typed programming in Agda. In 6th International School on Advanced Functional Programming, \n2008. Nicolas Oury and Wouter Swierstra. The power of Pi. In ICFP 08: Proceedings of the Thirteenth ACM \nSIGPLAN International Conference on Functional Programming, 2008. Simon Peyton Jones, Mark Jones, and \nErik Meijer. Type classes: an exploration of the design space. In Haskell Workshop, June 1997. W. Reps, \nThomas, Carla Marceau, and Tim Teitelbaum. Remote attribute updating for language-based editors. In POPL \n86: Proceedings of the 13th ACM SIGACT-SIGPLAN symposium on Principles of programming languages, pages \n1 13, New York, NY, USA, 1986. ACM. J.C. Reynolds. User de.ned types and procedural data as complementary \napproaches to data abstraction. In S.A. Schuman, editor, New Directions in Algorithmic Languages. INRIA, \n1975. Alexandra Silva and Joost Visser. Strong types for relational databases. In Haskell 06: Proceedings \nof the 2006 ACM SIGPLAN workshop on Haskell, pages 25 36, New York, NY, USA, 2006. ACM. ISBN 1-59593-489-8. \nS. Doaitse Swierstra and Olaf Chitil. Linear, bounded, functional pretty-printing. Journal of Functional \nProgramming, 19(01):1 16, 2009. S. Doaitse Swierstra, Pablo R. Azero Alcocer, and Jo ao A. Saraiva. Designing \nand implementing combinator languages. In S. D. Swierstra, Pedro Henriques, and Jos\u00b4e Oliveira, editors, \nAdvanced Functional Programming, Third International School, AFP 98, volume 1608 of LNCS, pages 150 206. \nSpringer-Verlag, 1999. S.D. Swierstra. Linear, online, functional pretty printing (extended and corrected \nversion). Technical Report UU-CS-2004-025a, Inst. of Information and Comp. Science, Utrecht Univ., 2004. \nPhil Wadler. The Expression Problem. E-mail available online., 1998.     \n\t\t\t", "proc_id": "1596550", "abstract": "<p>Attribute Grammars (AGs), a general-purpose formalism for describing recursive computations over data types, avoid the trade-off which arises when building software incrementally: should it be easy to add new data types and data type alternatives or to add new operations on existing data types? However, AGs are usually implemented as a pre-processor, leaving e.g. type checking to later processing phases and making interactive development, proper error reporting and debugging difficult. Embedding AG into Haskell as a combinator library solves these problems.</p> <p>Previous attempts at embedding AGs as a domain-specific language were based on extensible records and thus exploiting Haskell's type system to check the well formedness of the AG, but fell short in compactness and the possibility to abstract over oft occurring AG patterns. Other attempts used a very generic mapping for which the AG well-formedness could not be statically checked.</p> <p>We present a typed embedding of AG in Haskell satisfying all these requirements. The key lies in using HList-like typed heterogeneous collections (extensible polymorphic records) and expressing AG well-formedness conditions as type-level predicates (i.e., type-class constraints). By further type-level programming we can also express common programming patterns, corresponding to the typical use cases of monads such as Reader, Writer and State. The paper presents a realistic example of type-class-based type-level programming in Haskell.</p>", "authors": [{"name": "Marcos Viera", "author_profile_id": "81319503384", "affiliation": "Universidad de Republica, Montevideo, Uruguay", "person_id": "P1613937", "email_address": "", "orcid_id": ""}, {"name": "S. Doaitse Swierstra", "author_profile_id": "81100040645", "affiliation": "Utrecht University, Utrecht, Netherlands", "person_id": "P1613938", "email_address": "", "orcid_id": ""}, {"name": "Wouter Swierstra", "author_profile_id": "81337493862", "affiliation": "Chalmers University of Technology, G&#246;teborg, Sweden", "person_id": "P1613939", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596586", "year": "2009", "article_id": "1596586", "conference": "ICFP", "title": "Attribute grammars fly first-class: how to do aspect oriented programming in Haskell", "url": "http://dl.acm.org/citation.cfm?id=1596586"}