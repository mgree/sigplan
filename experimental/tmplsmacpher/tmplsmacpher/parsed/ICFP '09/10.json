{"article_publication_date": "08-31-2009", "fulltext": "\n Scribble: Closing the Book on Ad Hoc Documentation Tools Matthew Flatt Eli Barzilay Robert Bruce Findler \nUniversity of Utah and PLT Northeastern University and PLT Northwestern University and PLT m.att@cs.utah.edu \neli@ccs.neu.edu robby@eecs.northwestern.edu Abstract Scribble is a system for writing library documentation, \nuser guides, and tutorials. It builds on PLT Scheme s technology for language extension, and at its heart \nis a new approach to connecting prose references with library bindings. Besides the base system, we have \nbuilt Scribble libraries for JavaDoc-style API documentation, liter\u00adate programming, and conference papers. \nWe have used Scribble to produce thousands of pages of documentation for PLT Scheme; the new documentation \nis more complete, more accessible, and bet\u00adter organized, thanks in large part to Scribble s .exibility \nand the ease with which we cross-reference information across levels. This paper reports on the use of \nScribble and on its design as both an extension and an extensible part of PLT Scheme. Categories and \nSubject Descriptors I.7.2 [Document and Text Processing]: Document Preparation Languages and systems \nGeneral Terms Design, Documentation, Languages 1. Documentation as Code Most existing documentation tools \nfall into one of three categories: LATEX-like tools that know nothing about source code; JavaDoc\u00adlike \ntools that extract documentation from annotations in source code; and WEB-like literate-programming tools \nwhere source code is organized around a prose presentation. Scribble is a new documentation infrastructure \nfor PLT Scheme that can support and integrate all three kinds of tools. Like the LATEX category, Scribble \nis suitable for producing stand-alone documents. Like the other two categories, Scribble creates a connection \nbe\u00adtween documentation and the program that it describes but with\u00adout restricting the form of the documentation \nlike JavaDoc-style tools, and with a well-de.ned connection to the language s scop\u00ading that is lacking \nin WEB-like tools. Speci.cally, Scribble lever\u00adages lexical scoping as supplied by the underlying programming \nlanguage, instead of ad hoc textual manipulation, to connect doc\u00adumentation and code. This connection \nsupports abstractions across the prose and code layers, and it enables a precise and consistent association \n(e.g., via hyperlinks) of references in code fragments to speci.cations elsewhere in the documentation. \nFor example, @scheme[circle] in a document source gen\u00aderates the output text circle. If the source form \nappears within a lexical context that imports the slideshow library, then the rendered circle is hyperlinked \nto the documentation for the Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. ICFP 09, August 31 September 2, 2009, Edinburgh, Scotland, UK. Copyright c &#38;#169; \n2009 ACM 978-1-60558-332-7/09/08. . . $5.00  Figure 1: DrScheme with binding arrows and documentation \nlinks on Scribble code slideshow library and not to the documentation of, say, the htdp/image library, \nwhich exports a circle binding for a different GUI library. Moreover, the hyperlink is correct even if \n@scheme[circle] resides in a function that is used to generate documentation, and even if the lexical \ncontext of the call does not otherwise mention slideshow. Such lexically scoped fragments of documentation \nare built on the same technology as Scheme s lex\u00adically scoped macros, and they provide the same bene.ts \nfor docu\u00admentation abstraction and composition as for ordinary programs. To support documentation in \nthe style of JavaDoc, a Scribble program can include a source library and extract its documen\u00adtation. \nBindings in the source are re.ected naturally as cross\u00adreferences in the documentation. Similarly, a \nsource program can use module-level imports to introduce and compose literate\u00adprogramming forms; in other \nwords, the module system acts as the language that Ramsey (1994) has suggested to organize the composition \nof noweb extensions. Scribble s capacity to span documentation-tool categories is a consequence of PLT \nScheme s extensibility. Extensibility is an obstacle for JavaDoc-style tools, which parse a program s \nsource text and would have to be extended in parallel to the language. Scribble, in contrast, plugs into \nthe main language s extensibility machinery, so it both understands language extensions and is itself \nextensible. Similarly, Scheme macros accommodate a WEB-like organization of a library s implementation, \nand the same macros can simultaneously organize the associated documentation. Indeed, Scribble documents \nare themselves Scheme programs, which means that PLT Scheme tools can work on Scribble sources. Figure \n1 shows this paper s source opened in DrScheme. After clicking Check Syntax, then a right-click on a \nuse of emph directly accesses the documentation of the emph function, even though the surface syntax \nof the document source does not look like Scheme. Such documentation links are based on the same lex\u00adical \ninformation and program-expansion process that the compiler uses, so the links point precisely to the \nright documentation. We developed Scribble primarily for stand-alone documenta\u00adtion, but we have also \ndeveloped a library for JavaDoc-style ex\u00adtraction of API documentation, and we have created a WEB-style \ntool for literate programming. In all forms, Scribble s connection between documentation and source plays \na crucial role in cross\u00adreferencing, in writing examples within the documentation, and in searching the \ndocumentation from within the programming envi\u00adronment. These capabilities point the way toward even \nmore so\u00adphisticated extensions, and they illustrate the advantages of treating documentation as code. \n2. Scribbling Prose The beginning of the PLT Scheme overview documentation demon\u00adstrates several common \ntypesetting forms: Welcome to PLT Scheme Depending on how you look at it, PLT Scheme is a programming \nlanguage a descendant of Scheme, which is a dialect of Lisp;  a family of programming languages variants \nof Scheme, and more; or  a set of tools for using a family of programming lan\u00adguages.  Where there \nis no room for confusion, we use simply Scheme to refer to any of these facets of PLT Scheme. The Scribble \nsyntax for generating this document fragment is rem\u00adiniscent of LATEX, using @ (like texinfo) instead \nof \\: #lang scribble/doc @(require scribble/manual) @section{Welcome to PLT Scheme} Depending on how \nyou look at it, @bold{PLT Scheme} is @itemize[ @item{a @emph{programming language} ---a descendant of \nScheme, which is a dialect of Lisp;} @item{a @emph{family} of programming languages ---variants of Scheme, \nand more; or} @item{a set of @emph{tools} for using a family of programming languages.} ] Where there \nis no room for confusion, we use simply Scheme to refer to any of these facets of PLT Scheme. The \ninitial #lang scribble/doc line declares that the module uses Scribble s documentation syntax, as opposed \nto using #lang scheme for S-expression syntax. At the same time, the #lang line also imports all of the \nusual PLT Scheme functions and syn\u00adtax. The @(require scribble/manual) form imports ad\u00additional functions \nand syntactic forms speci.c to typesetting a user manual. The remainder of the module represents the \ndocument con\u00adtent. The semantics of the document body is essentially that of Scheme, where most of the \ntext is represented as Scheme strings. Although we build Scribble on Scheme, a LATEX-style syntax works \nbetter than nested S-expressions, because it more closely resembles the resulting textual layout. First, \nalthough all of the text belongs in a section, it is implicitly grouped by the section title, instead \nof explicitly grouped into something like a section function call. Second, the default parsing mode is \ntext instead of expression, so that commas, periods, quotes, paragraphs, and sections behave in the usual \nway for prose, while the @ notation provides a uniform way to escape to a Scheme function call with text-mode \narguments. Third, various automatic rules convert ASCII to more sophisticated typeset forms, such as \nthe conversion of --\u00adto an em-dash and ... to curly quotes. Although LATEX and Scribble use a similar \nsyntax, the semantics are completely different. For example, itemize is a function that accepts document \nfragments created by the item function, instead of a text-parsing macro like LATEX s itemize environment. \nThe square brackets after itemize in the document source re.ect that it accepts item values, whereas \nitem and many other functions are followed by curly braces that indicate text arguments. The @\u00adnotation \nis simply another way of writing S-expressions, as we describe in detail in Section 4. 3. Scribbling \nCode The PLT Scheme tutorial Quick: An Introduction to PLT Scheme with Pictures starts with a few paragraphs \nof prose and then shows the following example interaction: >5 5 > \"art gallery\" \"art gallery\"  The > \nrepresents the Scheme prompt. The .rst 5 is a constant value in an expression, so it is colored green \nin the tutorial, while the second 5 is a result, so it is colored blue. In Scheme, the syntax for output \ndoes not always match the syntax for expressions, so the different colors are useful hints to readers \nbut only if they have the consistency of an automatic annotation. The source code for the .rst example \nis simply @interaction[5 \"art gallery\"] where interaction is provided by a Scribble library to both \nevaluate examples and typeset the expressions and results with syntax coloring. Since example expressions \nare evaluated when the document is built, examples never contain bugs where evaluation does not match \nthe predicted output. The second example in the Quick tutorial shows a more inter\u00adesting evaluation: \n> (circle 10)  Here, again, the expression is colored in the normal way for PLT Scheme code. More importantly, \nthe circle identi.er is hyper\u00adlinked to the de.nition of the circle function in the slideshow library, \nso an interested reader can follow the link to learn more about circle. Meanwhile, the result is shown \nas a circle im\u00adage, just as it would be shown when evaluating the expression in DrScheme. The source \ncode for the second example is equally simple: @mr-interaction[(circle 10)] The author of the tutorial \nhad to implement the mr-interaction syntactic form, because interaction does not currently support picture \nresults. The syntax coloring, hyperlinking, and evaluation of (circle 10), however, is implemented by \nexpanding to in\u00adteraction. In particular, circle is correctly hyperlinked be\u00adcause the module containing \nthe above source also includes @(require (for-label slideshow)) which causes the circle binding to be \nimported from the slideshow module for the purposes of hyperlinking. Based on this import and a database \nmapping bindings to de.nition sites, Scribble can automatically insert the hyperlink. A module that is \nimported only with for-label is not run when the documentation is built, because the time at which a \ndocument is built may not be a suitable time to actually run a module. As an extreme example, an author \nmight want to document a module whose job is to erase all .les on the disk. More practically, executing \na GUI library might require a graphics terminal, while the documentation for the graphics library can \nbe built using only a text terminal. Pervasive and precise hyperlinking of identi.ers greatly im\u00adproves \nthe quality of documentation, and it relieves a document author from much tedious cross-referencing work, \nmuch like au\u00adtomatic hyperlinking in wikis. The author need not specify where circle is documented, but \ninstead merely import for-label a module that supplies circle, and the documentation system is responsible \nfor correlating the use and the de.nition. Further\u00admore, since hyperlinks are used in examples everywhere, \nan au\u00adthor can expect readers to follow them, instead of explicitly writ\u00ading for more information on \nthe circle procedure used above, see ... These bene.ts are crucial when a system s documentation runs \nto thousands of pages. Indeed, PLT Scheme s documentation has 57,997 links between manuals, which is \nroughly 15 links per printed page (and which does not count the additional 105,344 intra-manual links). \nClicking the circle hyperlink leads to its documentation in a standard format:  (circle diameter) . \npict? diameter : real? Creates an un.lled ellipse. In this de.nition, real? and pict? are contracts for \nthe function argument and result. Naturally, they are in turn hyperlinked to their de.nitions, because \nsuitable libraries are imported for-label in the documentation source. The above documentation of circle \nis implemented using defproc: @defproc[(circle [diameter real?]) pict?]{ Creates an unfilled ellipse. \n}  Alternatively, instead of writing the documentation for cir\u00adcle in a stand-alone document where there \nis a possibility that the documented contract does not match the contract in the implementation the documentation \ncould be written with the im\u00adplementation of circle. In that case, the documentation would look slightly \ndifferent, since it would be part of the module s export declarations: (provide/doc [circle ([diameter \nreal?] . -> . pict?) @{Creates an unfilled ellipse.}])  With provide/doc, the single contract speci.cation \nfor cir\u00adcle is used in two ways: at run time to check arguments and re\u00adsults for circle, and when building \nthe documentation to show the expected arguments and results of circle. Although defproc and provide/doc \nare provided with Scribble, they are not built into the core typesetting engine. They are written in \nseparate libraries, and Scribble users could have implemented these forms. We describe this approach \nto extending Scribble further in Section 8. 4. @s and []s and {}s, Oh My! Users of a text-markup language \nexperience .rst and foremost the language s concrete syntax. The same is true of any language, but in \nthe case of text, authors with different backgrounds have arrived at a remarkably consistent view of \nthe appropriate syntax: it should use blank lines to indicate paragraph breaks, double-quote characters \nshould not be special, and so on. At the same time, a programmable mark-up language needs a natural escape \nto the programming layer and back. From the perspective of a programming language, conventional notations \nfor string literals are terrible for writing text. The quot\u00ading rules tend to be complex, and they usually \nomit an escape for arbitrarily nested expressions. Here strings and string interpola\u00adtion can alleviate \nsome of the quoting and escape problems, but they are insuf.cient for writing large amounts of text with \nfre\u00adquent nested escapes to the programming language. More impor\u00adtantly, building text in terms of string \nescapes and operations like string-append distracts from the business of writing prose, which is about \ntext and markup rather than strings and function calls. Indeed, many documentation systems, like JavaDoc, \navoid the limitations of string literals in the language by de.ning a com\u00adpletely new syntax that is \nembedded within comments. Of course, this approach sacri.ces any connection between the text and the \nprogramming language. For Scribble, our solution is the @-notation, which is a text\u00adfriendly alternative \nto traditional S-expression syntax. More pre\u00adcisely, the @-notation is another way to write down arbitrary \nS\u00adexpressions, but it is tuned for writing blocks of free-form text. The @-expression notation is a strict \nextension of PLT Scheme s S-expression syntax; the @ character has no special meaning in Scheme strings, \nin comments, or in the middle of Scheme iden\u00adti.ers. Furthermore, since it builds on the existing S-expression \nparser, it inherits all of the existing source-location support (e.g., for error messages). 4.1 @-expressions \nas S-expressions The grammar of an @-expression is roughly as follows (where @, [, ], {, and } are literal, \nand x? means that x is optional): (at-expr) ::= @(op)?[(S-expr)*]?{(text)}? (op) ::= (S-expr) that does \nnot start with [ or { (S-expr) ::= any PLT Scheme S-expression (text) ::= text with balanced {...} and \nwith @-exprs An @-expression maps to an S-expression as follows:  An @(op){...} sequence combines (op) \nwith text-mode argu\u00adments. For example, @emph{Yes!} is equivalent to the S-expression (emph \"Yes!\") Also, \nsince @ keeps its meaning inside text-mode arguments, @section{Country @emph{and} Western} is equivalent \nto the S-expression (section \"Country \" (emph \"and\") \" Western\") An @(op)[...] sequence combines (op) \nwith S-expression ar\u00adguments. For example, @itemize[(item \"a\") (item \"b\")] is equivalent to the S-expression \n(itemize (item \"a\") (item \"b\")) An @(op)[...]{...} sequence combines S-expression argu\u00adments and text-mode \narguments. For example, @title[#:style toc]{Contracts} is equivalent to the S-expression (title #:style \ntoc \"Contracts\") where #:style uses PLT Scheme notation for a keyword. An @(op) sequence without an immediately \nfollowing { or [ is equivalent to just (op) in Scheme mode. For example, @username is equivalent to the \nS-expression username so that @emph{committed by @username} is equivalent to (emph \"committed by \" username) \nAn (op) can be omitted in any of the above forms. For example, @{Country @emph{and} Western} is equivalent \nto the S-expression (\"Country \" (emph \"and\") \" Western\") which is useful in some quoted or macro contexts. \n Another way to describe the @-expression syntax is simply @(op)[...]{...} where each of the three parts \nis optional. When (op) is included but both kinds of arguments are missing, then (op)can produce a value \nto use directly instead of a function to call. The (op) in an @-expression is not constrained to be an \nidenti.er; it can be any S-expression that does not start with { or [. For example, an argumentless @(require \nscribble/manual) is equivalent to the S-expression (require scribble/manual). The spectrum of @-expression \nforms enables a document author to use whichever variant is most convenient. For a given opera\u00adtion, \nhowever, one particular variant is typically used. In general, @(op){...} or @(op)[...] is used to imply \na typesetting operation, whereas @(op) more directly implies an escape to Scheme. Hence, the form @emph{Yes!} \nis preferred to the equivalent @(emph \"Yes!\"), while @(require scribble/manual) is pre\u00adferred to the \nequivalent @require[scribble/manual]. A combination of S-expression and text-mode arguments is often \nuseful to customize an operation that consumes text. The @title[#:style toc]{Contracts} example illustrates \nthis combination, where the optional toc style customizes the typeset result of the title function. In \nother cases, an operation that speci.cally leverages S-expression notation may also have a text component. \nFor example, @defproc[(circle [diameter real?]) pict?]{ Creates an unfilled ellipse. } is equivalent \nto (defproc (circle [diameter real?]) pict? \"Creates an unfilled ellipse.\") but as the description of \nthe procedure becomes more involved, us\u00ading text mode for the description becomes much more convenient. \nAn @ works both as an escape from text mode and as a form constructor in S-expression contexts. As a \nresult, @-forms keep their meaning whether they are used in a Scheme expression or in a Scribble text \npart. This equivalence signi.cantly reduces the need for explicit quoting and unquoting operations, and \nit helps avoid bugs due to incorrect quoting levels. For example, instead of @itemize[(item \"a\") (item \n\"b\")], an itemization is normally written @itemize[@item{a} @item{b}], since items for an itemization \nare better written in text mode than as conventional strings; in this case, @item{a} can be used directly \nwithout .rst switching back to text mode. Overall, @-expressions are crucial to Scribble s .exibility \nin the same way that S-expressions are crucial to Scheme s .exibility and, in the same way, the bene.t \nis dif.cult to quantify. Fur\u00adthermore, just as S-expressions can be used for more than writ\u00ading Scheme \nprograms, the @ notation can be used for purposes other than documentation, and the @-notation parser \nis available for use in PLT Scheme separate from the rest of the Scribble in\u00adfrastructure. We use it \nas an alternative to HTML for building the plt-scheme.org web pages, more generally in a template sys\u00adtem \nsupported by the PLT Scheme web server, and also as a text preprocessor language similar in spirit to \nm4 for generating plain\u00adtext .les. 4.2 Documentation-Speci.c Decoding The @ notation supports local \ntext transformations and mark-up, but it does not directly address some other problems speci.c to organizing \na document s source:  Section content should be grouped implicitly via section, subsection, etc. declarations, \ninstead of explicitly nesting section constructions.  Paragraph breaks should be determined by empty \nlines in the source text, instead of explicitly constructing paragraph values.  A handful of ASCII character \nsequences should be converted automatically to more sophisticated typesetting elements, such as converting \n and to curly quotes or ---to an em-dash.  These transformations are speci.c to typesetting, and they \nare not appropriate for other contexts where the @ notation is useful. Therefore, the @ parser in Scribble \nfaithfully preserves the original text in Scheme strings, and a separate decode layer in Scribble provides \nadditional transformations. Functions like bold and emph apply decode-content to their arguments to perform \nASCII transformations, and item calls decode-flow to transform ASCII sequences and form para\u00adgraphs between \nempty lines. In contrast, tt and verbatim do not call the decode layer, and they instead typeset text \nexactly as it is given. For example, the source document #lang scribble/doc @(require scribble/manual) \n @title{Tubers} @section{Problem} You say potato. I say potato. @section{Solution} Call the whole thing \noff. invokes the decode layer, producing a module that is roughly equiv\u00adalent to the following (where \na part is a generic section): #lang scheme/base (require scribble/struct) (provide doc) (define doc \n(make-part (list \"Tubers\") (list (make-part (list \"Problem\") (list (make-paragraph (list \"You say \\u201Cpotato.\\u201D\")) \n(make-paragraph (list \"I say \\u201Cpotato.\\u201D\")))) (make-part (list \"Solution\") (list (make-paragraph \n(list \"Call the whole thing off.\"))))))) 5. Document Modules Like all PLT Scheme programs, Scribble documents \nare organized into modules, each in its own .le. A #lang line starts a mod\u00adule, and most PLT Scheme modules \nstart with #lang scheme or #lang scheme/base. A Scribble document normally starts with #lang scribble/doc \nto use a prose-oriented notation with @ syntax, but a Scribble document can be written in any nota\u00adtion \nand using any helper functions and syntax, as long as it exports a doc binding whose value is an instance \nof the Scribble part structure type. For example, #lang scheme (require scribble/decode) (define doc \n(decode (\"Hello, world!\"))) (provide doc)  implements in Scheme notation a Scribble document that contains \nonly the text Hello, world! Larger documents are typically split across modules/.les along section boundaries. \nSubsections are incorporated into a larger sec\u00adtion using the include-section form, which expands to \na re\u00adquire to import the sub-section module and an expression that produces the doc part exported by \nthe module. Since document inclusion corresponds to module importing, all of the usual PLT Scheme tools \nfor building and executing modules apply to Scribble documents. When a large document source is split \ninto multiple modules, most of the modules need the same basic typesetting functions as well as the same \nstandard bindings for examples. In Scribble, both sets of bindings can be packaged together; since for-label \ndeclarations build on the module system s import mechanisms, they work with the module system s re-exporting \nmechanisms. For example, the documentation for a library that builds on the scheme/base library might \nuse this \"common.ss\" library: #lang scheme/base (require scribble/manual (for-label lang/htdp-beginner)) \n(provide (all-from-out scribble/manual) (for-label (all-from-out lang/htdp-beginner)))  Then, each part \nof the document can be implemented as #lang scribble/doc @(require \"common.ss\") ....  instead of separately \nrequiring scribble/manual and (for\u00adlabel lang/htdp-beginner) in every .le. 6. Modules and Bindings As \nan embedded domain-speci.c language, Scribble follows a long tradition of using Lisp-and Scheme-style \nmacros to implement little languages. In particular, Scribble relies heavily on the Scheme notion of \nsyntax objects (Sperber 2007), which are fragments of code that have lexical-binding information attached. \nBesides using syntax objects in the usual way to implement macros, Scribble uses syntax objects to carry \nlexical information all the way through document rendering. For example, @scheme[lambda] expands to roughly \n(typeset-id # lambda), where # lambda is similar to lambda but produces a syntax object (with its lexical \ninformation intact) instead of a symbol. At the same time, many details of Scribble s implementation \nrely on PLT Scheme extensions to Scheme macros. Continuing the above example, the typeset-id function \napplies PLT Scheme s identifier-label-binding function to the given syn\u00adtax object to determine the source \nmodule of its binding. The typeset-id function can then construct a cross-reference key based on the \nidenti.er and the source module; the documentation for the binding pairs the same identi.er and source \nmodule to de\u00ad.ne the target of the cross-reference. A deeper dependence of Scribble on PLT Scheme relates \nto #lang parsing. The #lang notation organizes reader extensions of Scheme (i.e., changes to the way \nthat raw text is converted to S\u00adexpressions) to allow new forms of surface syntax. The identi.er after \n#lang in the original source act as the language of a module. To parse a #lang line, the identi.er after \n#lang is used as the name of a library collection that contains a \"lang/reader.ss\" module. The collection \ns \"lang/reader.ss\" module must ex\u00adport a read-syntax function, which takes an input stream and produces \na syntax object. The \"lang/reader.ss\" module for scribble/doc parses the given input stream in @-notation \ntext mode, and then wraps the result in a module form. For example, #lang scribble/doc @(require scribble/manual) \nIt was a @bold{dark} and @italic{stormy} night. in a .le named \"hello.scrbl\" reads as (module hello \nscribble/doclang doc () \"\\n\" (require scribble/manual) \"\\n\" \"It was a \" (bold \"dark\") \" and \" (italic \n\"stormy\") \"night.\" \"\\n\") where doc is inserted by the scribble/doc reader as the iden\u00adti.er to export \nfrom the module, and the () is a convenience ex\u00adplained below. The module form is PLT Scheme s core module \nform, and it generalizes the standard library form (Sperber 2007) to give macros more control in transforming \nthe body of a module. Within a module, the .rst identi.er is the relative name of the module, and the \nsecond identi.er indicates a module to supply initial bind\u00adings for the module body. In particular, the \ninitial import of a mod\u00adule is responsible for supplying a #%module-begin macro that is implicitly applied \nto the entire content of the module. In the case of scribble/doclang, the #%module-begin macro lifts \nout all import and de.nitions forms in the body, passes all remaining content to the decode function, \nand binds the result to an exported doc identi.er. Thus, macro expansion converts the hello module to \nthe following: (module hello scheme/base (require scribble/doclang scribble/manual) (provide doc) (define \ndoc (decode \"\\n\" \"\\n\" \"It was a \" (bold \"dark\") \" and \" (italic \"stormy\") \"night.\" \"\\n\"))) A subtlety \nin the process of lifting out import and de.nition forms is that they might not appear directly, but \ninstead appear in the process of macro expansion. For example, include\u00adsection expands to a require of \nthe included document plus a reference to the document. The #%module-begin macro of scribble/doclang \ntherefore relies on a PLT Scheme facility for forcing the expansion of sub-forms. Speci.cally, #%module\u00adbegin \nuses local-expand to expand each sub-form just far enough to determine whether it is an import form, \nde.nition form, or expression. If the sub-form is an import or de.nition, then #%module-begin suspends \nfurther work and lifts out the import or de.nition immediately; the import or de.nition can then supply \nbindings for further expansion of the module body. The need to suspend and continue lifting explains \nthe () inserted in the body of a module by the scribble/doc reader; #%module-begin uses that position \nto track the sub-forms that have been expanded already to expressions. Aside from (1) the ability to \nforce the expansion of nested forms and (2) the ability of macros to expand into new imports, macro ex\u00adpansion \nof a module body is essentially the same as for libraries in the current Scheme standard (Sperber 2007). \nWhere the standard allows choice in the separation of phases, we have chosen maximal separation in PLT \nScheme, so that compilation and expansion as consistent as possible (Flatt 2002). That is, bindings and \nmodule instantiations needed during the compilation of a module are kept separate from the bindings and \ninstantiations needed when execut\u00ading a module for rendering. Furthermore, to support the connection \nbetween documentation and library bindings, PLT Scheme introduces a new phase that is orthogonal to compile \ntime or run time: the label phase level. As noted in Section 3, a for-label import introduces bindings \nfor documentation without triggering the execution of the imported module. In PLT Scheme, the same identi.er \ncan have different bindings in different phases. For example, when documenting the Intermediate Scheme \npedagogical language, a document author would like uses of lambda to link to the lambda speci.cation \nfor Intermediate Scheme, while procedures used to implement the document itself will more likely use \nthe full PLT Scheme language, which is a different lambda. The two different uses of lambda are kept \nstraight naturally and automatically by separate bindings in separate phases. 7. Core Scribble Datatypes \nThe doc binding that a Scribble module exports is a description of a document. Various tools, such as \nthe scribble command-line program, can take this description of a document and render it to a speci.c \nformat, such as LATEX or HTML. In particular, Scribble defers detailed typesetting work to LATEX or to \nHTML browsers, and Scribble s plug-in architecture accommodates new rendering back-ends. Scribble s documentation \nabstraction re.ects a least-common denominator among such document formats. For example, Scrib\u00adble has \na baked-in notion of itemization, since LATEX, HTML, and other document formats provide speci.c support \nto typeset item\u00adizations. For many other layout tasks, such as formatting Scheme code, Scribble documents \nfall back to a generic table abstraction. Similarly, Scribble itself resolves most forms of cross-references \nand document dependencies, since different formats provide differ\u00adent levels of automatic support; tables \nof contents and indexes are mostly built within Scribble, instead of the back-end. A Scribble document \nis a program that generates an instance of a part structure type. A part can represent a section or a \nbook, and it can have sub-parts that represent sub-sections or chapters. This paper, for example, is \ngenerated by a Scribble document whose resulting part represents the whole paper, and it contains sub-parts \nfor individual sections. The part produced by a Scheme document for a reference manual is rendered as \na book, where the immediate sub-parts are chapters. Figure 2 summarizes the structure of a document under \npart in a UML-like diagram. When a .eld contains a list, the diagram shows a double arrow, and when a \n.eld contains a lists of lists, the diagram shows a triple arrow. The dashed arrows call attention to \ndelayed .elds, which are explained below. Each part has a .ow that is typeset before its sub-parts (if \nany), and that represents the main content of a section. A .ow is a list of blocks, where each block \nis one of the following: a paragraph, which contains a list of elements that are type\u00adset inline with \nautomatic line breaks;  a table, which contains a list of rows, where each row is a list of .ows, one \nper cell in the table;   Figure 2: Scribble s core document representation an itemization, which \ncontains a list of .ows, one per item;  a blockquote, which contains a single .ow that is typically \ntypeset with more indentation than its surrounding .ow; or  a delayed-block, which eventually expands \nto another block, using information gathered elsewhere in the document. Accordingly, the block .eld of \na delayed-block is not just a block, but a function that computes a block when given that other information. \nFor example, a delayed-block is used to implement a table of contents.  A Scribble document can construct \nother kinds of blocks that are implemented in terms of the above built-in kinds. For example, a defproc \nblock that describes a procedure is implemented in terms of a table. An element within a paragraph can \nbe one of the following: a plain string;  an instance of the element structure type, which wraps a \nlist of elements with a typesetting style, such as bold, whose detailed interpretation depends on the \nback-end format;  a target-element, which associates a cross-reference tag with a list of elements, \nand where the typeset elements are the target for cross-references using the tag;  a link-element, which \nassociates a cross-reference tag to a list of elements, where the tag designates a cross-reference from \n the elements to elsewhere in the document (which is rendered in HTML as a hyperlink from the elements); \n a delayed-element eventually expands to a list of ele\u00adments. Like a delayed-block, it typically generates \nthe elements using information gathered from elsewhere in the document. A delayed-element often generates \na link\u00adelement after a suitable target for cross-referencing is lo\u00adcated.  A collect-element is the \ncomplement of delayed\u00adelement: it includes an immediate list of elements, but also a procedure to record \ninformation that might be used elsewhere in the document. A collect-element often includes a target-element, \nin which case its procedure might regis\u00adter the target s cross-reference tag for discovery by delayed\u00adelement \ninstances.  A few other element types support more specialized tasks, such as communicating between \nphases and specifying tooltips.  A document as represented by a part instance is an immutable value. \nThis value is transformed in several passes to eliminate delayed-block instances, delayed-element instances, \nand collect-element instances. The result is a simpli.ed part instance and associated cross-reference \ninformation. Once the cross-reference information has been computed, it is saved for use when building \nother documents that have cross-references to this one. Finally, the part instance is consumed by a rendering \nback-end to produce the .nal document. In the current implementation of Scribble, all documents are transformed \nin only two passes: a collect pass that collects infor\u00admation about the document (e.g., through collect-elements), \nand a resolve pass that turns delayed blocks and elements into nor\u00admal elements. We could easily generalize \nto multiple passes, but so far, two passes have been suf.cient within a single document. When multiple \ndocuments that refer to each other are built sepa\u00adrately, these passes are iterated as explained in Section \n9. In some cases, the output of Scribble needs customization that is speci.c to a back-end. Users of \nScribble provide the customiza\u00adtion information by supplying a mapping from the contents of the style \n.eld in the various structures for the style s back-end ren\u00addering. For HTML output, a CSS fragment can \nextend or override the default Scribble style sheet. For LATEX output, a \".tex\" .le can extend or rede.ne \nthe default Scribble LATEX commands. 8. Scribble s Extensibility Scribble s foundation on PLT Scheme \nempowers programmers to implement a number of features as libraries that ordinarily must be built into \na documentation tool. More importantly, users can exper\u00adiment with new and more interesting ways to write \ndocumentation without having to modify Scribble s implementation. In this section, we describe several \nlibraries that we have al\u00adready built atop Scribble: for stand-alone API documentation, for automatically \nrunning examples when building documentation, for combining code with documentation in the style of JavaDoc, \nand for literate programing. 8.1 API Speci.cation Targets for code hyperlinks are de.ned by defproc (for \nfunc\u00adtions), defform (for syntactic forms), defstruct (for structure types), defclass (for classes in \nthe object system), and other such forms one for each form of binding. When a library de.nes a new form \nof binding, an associated documentation library can de.ne a new form for documenting the bindings. As \nwe demonstrated in Section 3, the defproc form docu\u00adments a function given its name, information about \nits arguments, and a contract expression for its result. Information for each argu\u00adment includes a contract \nexpression, the keyword (if any) for the argument, and the default value (if any). For example, a louder \nfunction that consumes and produces a string might be documented as follows: @defproc[(louder [str string?]) \nstring?]{ Adds ! to the end of @scheme[str]. } The description of the function refers back to the formal \nargument str using scheme. In the typeset result, the reference to str is typeset in a slanted font both \nin the function prototype and description. (louder str) . string? str : string? Adds ! to the end of \nstr. As usual, lexical scope provides the connection between the formal-argument str and the reference. \nThe defproc form ex\u00adpands to a combination of Scribble functions to construct a table representing the \ndocumentation and Scheme local-macro bindings to control the expansion and typesetting of the procedure \ndescrip\u00adtion. For the above defproc, the for-label binding of louder partly determines the library binding \nthat is documented by this defproc form. A single binding, however, can be re-exported by many modules. \nOn the reference side, the scheme and scheme\u00adblock forms follow re-export chains to discover the .rst \nexporting module for which a binding is documented; on the de.nition side, defproc needs a declaration \nof the module that is being docu\u00admented. The module declaration is no extra burden on the document author, \nbecause the reader of the document needs some indication of which module is being documented. The defmodule \nform both generates the user-readable expla\u00adnation of the module being documented and declares that all \nde.\u00adnitions within the enclosing section (and sub-sections, unless over\u00adridden) correspond to exports \nfrom the declared module. Thus, if louder is exported by the comics/string library, it is docu\u00admented \nas follows: #lang scribble/doc @(require scribble/manual (for-label scheme/base comics/string)) @title{String \nManipulations} @defmodule[comics/string] @defproc[(louder [str string?]) string?]{ Adds ! to the end \nof @scheme[str]. } The defproc form is implemented by a scribble/manual layer of Scribble, which provides \nmany functions and forms for typesetting PLT Scheme documentation. The scribble/manual layer is separate \nfrom the core Scribble engine, however, and other libraries can build up defproc-like abstractions on \ntop of the core typesetting and cross-referencing capabilities described in Section 7.  8.2 Examples \nand Tests In the documentation for a function or syntactic form, concrete examples help a reader understand \nhow a function works, but only if the examples are reliable. Ensuring that examples are correct is a \nsigni.cant burden in a conventional approach to documentation, because the example expressions must be \ncarefully checked against the implementation (often by manual cut and paste), and a small edit can easily \nintroduce a bug. The examples form of the scribble/eval library type\u00adsets an example along with its result \nusing the style of a read-eval\u00adprint loop. For example, @examples[(/ 1 2) (/ 1 2.0) (/ 1 +inf.0)] produces \nthe output Examples: > (/ 1 2) 1/2 > (/ 1 2.0)   0.5 > (/ 1 +inf.0) 0.0 Since building the documentation \nruns the examples every time, the typeset results are reliable. When an author makes a mistake, or when \nan implementation changes so that the documentation is out of sync, the example remains correct though \nit may not re.ect what the author intended. For example, if we misspell +inf.0 in the example, then the \noutput is still accurate, though unhelpful in describing the behavior of division: Example:  > (/ 1 \n+infinity.0) reference to unde.ned identi.er: +in.nity.0 To guard against such mistakes, an example \nexpression can be wrapped with eval:check to combine it with an expected result: @examples[(eval:check \n(/ 1 +infinity.0) 0.0)] Instead of typesetting an error message, this checked example will raise an \nexception when the document is built, because the expres\u00adsion does not produce the expected result 0.0. \nIn this way, docu\u00admentation source can serve partly as a test suite. Evaluation of example code mingles \ntwo phases that we have otherwise worked to keep separate: the time at which a library is executed, and \nthe time at which its documentation is produced. For simple functional expressions, such as (/ 1 2), \nthe separation does not matter, and examples could simply duplicate its argu\u00adment in both an expression \nposition and a typeset position. More generally, however, examples involve temporary de.nitions and side-effects. \nTo prevent examples from interfering with each other while building a large document, examples uses a \nsandboxed en\u00advironment, for which PLT Scheme provides extensive support (Flatt et al. 1999; Flatt and \nPLT Scheme 2009, \u00a713). 8.3 In-Code Documentation For some libraries, the programmer may want to write \ndocumenta\u00adtion with the source instead of in a separate document. To support such documentation, we have \ncreated a Scheme/Scribble extension that is used to document some libraries in the PLT Scheme distri\u00adbution. \n Using this extension, the comics/string module could be implemented as follows: #lang at-exp scheme/base \n(require scheme/contract scribble/srcdoc) (require/doc scheme/base scribble/manual) (define (louder \ns) (string-append s \"!\")) (provide/doc [louder ([str string?] . -> . string?) @{Adds ! to the end \nof @scheme[str].}]) The #lang at-exp scheme/base line declares that the module uses scheme/base language \nextended with @-notation. The imported scribble/srcdoc library binds require/doc and provide/doc. The \nrequire/doc form imports bindings into a documentation phase, such as the scheme form that is used in \nthe description of louder. The provide/doc form ex\u00adports louder, annotates it with a contract for run-time \ncheck\u00ading, and records the contract and description for inclusion in doc\u00adumentation. The description \nis an expression in the documentation phase; it is dropped by normal compilation of the module, but com\u00adbined \nwith the require/doc imports and inferred (require (for-label ...)) imports to generate the module s \ndocu\u00admentation. The documentation part of this module is extracted using include-extracted, which is \nprovided by the scrib\u00adble/extract module in cooperation with scribble/srcdoc. The extracted documentation \nmight provide the entire text of the document directly, or it might be incorporated into a larger docu\u00adment: \n#lang scribble/doc @(require scribble/manual scribble/extract (for-label comics/string)) @title{Strings} \n@defmodule[comics/string] The @schememodname[comics/string] library provides functions for creating punchlines. \n @include-extracted[comics/string] An advantage of using scribble/srcdoc and scrib\u00adble/extract is that \nthe description of the function is with the implementation, and the function contract need not be duplicated \nin the source and documentation. Similarly, the fact that string? in the contract gets its binding from \nscheme/base is speci.ed once in the code and inferred for the documentation. At the same time, a phase \nseparation prevents document-generating expressions from polluting the library s run-time execution, \nand vice versa.  8.4 Literate Programming The techniques used for in-source documentation extend to \nthe creation of WEB-like literate programming tools. Figure 3 shows an example use of our literate-programming \nlibrary; the left-hand side shows a screenshot of DrScheme editing the source code for a short, literate \ndiscussion of the Collatz conjecture, while the right\u00adhand side shows the rendered output. Literate programs \nwritten with our library look like ordinary Scribble documents, except that they start with #lang scrib\u00adble/lp \nand use chunk to introduce a piece of the implementa\u00adtion. A use of chunk consists of a name followed \nby de.nitions and/or expressions: @chunk[<name-of-chunk> ... definitions ... ... expressions ...] The \nde.nitions and expressions in a chunk can refer to other chunks by their names. Unlike a normal Scribble \nprogram, running a scribble/lp program ignores the prose exposition and instead evaluates the pro\u00adgram \nin the chunks. In literate programming terminology, this pro\u00adcess is called tangling the program. Thus, \nto a client module, a lit\u00aderate program behaves just like its illiterate variant. The compiled form of \na literate program does not contain any of the documenta\u00adtion, nor does it depend on the runtime support \nfor Scribble, just as if an extra-linguistic tangler had been used. Consequently, the literate implementation \nsuffers no overhead due to the prose. To recover the prose, the @lp-include[filename] form extracts \na literate view of the program from filename. In literate programming terminology, this process is called \nweaving the program. The right-hand side of Figure 3 shows the woven version of the code in the screenshot. \nBoth weaving and tangling with scribble/lp work at the level of syntactic extensions, and not in terms \nof manipulating source text. As a result, the language for writing prose is extensible, because Scribble \nlibraries such as scribble/manual can be imported into the document. The language for implementing the \nprogram is also obviously extensible, because a chunk can include imports from other PLT Scheme libraries. \nFinally, even the bridge between the prose and the implementation is extensible, because the document \nauthor can create new syntactic forms that expand to a mixture of prose, implementation, and uses of \nchunk. Tangling via syntactic extension also enables many tools for Scheme programs to automatically \napply to literate Scheme pro\u00adgrams. The arrows in Figure 3 s screenshot demonstrate how DrScheme can \ndraw arrows from chunk bindings to chunk refer\u00adences, and from the binding occurrence of an identi.er \nto its bound occurrences, even across chunks. These latter arrows are particu\u00adlarly helpful with literate \nprograms, where lexical scope is some\u00adtimes obscured by the way that textually disparate fragments of \na program are eventually tangled into the same scope. DrScheme s interactive REPL, test-case coverage \nsupport, module browser, ex\u00adecutable generation, and other tools also work on literate programs. To gain \nsome experience with non-trivial literate program\u00adming in Scribble, we have written a 34-page literate \nprogram that describes our implementation of the Chat Noir game, which is distributed with PLT Scheme. \nThe source is included in the distribution as \"chat-noir-literate.ss\", and the ren\u00addered output is in \nthe help system and online at http://docs. plt-scheme.org/games/chat-noir.html. 9. Building and Installing \nDocumentation PLT Scheme documentation resides with the source code. The setup process that builds bytecode \nfrom Scheme source also renders HTML documentation from Scribble source. The HTML output is accompanied \nby cross-reference information that is used both for building more documentation when new libraries are \ninstalled and for online help in the programming environment. Although many existing PLT Scheme tools \nhelp in building doc\u00aduments, the process of generating HTML is signi.cantly different from compilation \ntasks. The main difference is that cyclic depen\u00adConsider a function that, starting from (collatz n), \nrecurs with  <even> ::=  (collatz (/ n 2)) if n is even and recurs with <odd> ::= (collatz (+ (* \n3 n) 1)) if n is odd. We can package that up into the collatz function: <collatz> ::= (define (collatz \nn) (unless (= n 1) (if (even? n) <even> <odd>))) The Collatz conjecture is true if this func\u00adtion terminates \nfor every input. Thanks to the .exibility of literate pro\u00adgramming, we can package up the code to compute \norbits of Collatz numbers too: <collatz-sequence> ::= (define (collatz n) (cond [(= n 1) (1)] [(even? \nn) (cons n <even>)] [(odd? n) (cons n <odd>)])) Finally, we put the whole thing together, after establishing \ndifferent scopes for the two functions. <*> ::= (require scheme/local) (local [<collatz-sequence>]  \n(collatz 18)) (local [<collatz>] (collatz 18))  Figure 3: Literate programming example dencies are common \nin documentation, whereas library dependen\u00adcies are strictly layered. For example, the core language \nreference contains many pointers into the overview and a few pointers to the GUI library and other extensions; \nall documents, meanwhile, refer back to the core reference. Resolving mutual dependencies directly would \nrequire loading all documents into memory at once, which is impractical for the scale of the PLT Scheme \ndocumentation. The setup processes therefore builds documents one at a time, reading and writing serialized \ncross-reference information until it arrives at a .xed point for all documents. A .xed point usually \nrequires two iterations, so that all documents see the information collected from all other documents. \nA handful of documents require a third pass, because they contain section titles from other documents, \nwhere each section title is based on still other documents (e.g., by using an identi.er whose typesetting \ndepends on whether it is documented as a procedure or syntactic form). Another challenge in building \na uni.ed set of documentation is that individual users might augment the main installation with user\u00adspeci.c \nlibraries. The main installation includes a table of contents that is the default starting point for \nreading documentation, and this table is updated when a new package is placed into the main installation. \nWhen a user-speci.c library is installed, in contrast, its document is built so that hyperlink references \ngo into the main installation s documentation, and a user-speci.c table of contents is created. When \na user opens the documentation via DrScheme s Help menu, a user-speci.c table of contents is opened (if \nit exists). Instead of explicitly installing a library, a user can implicitly install a package from \nthe PLaneT repository (Matthews 2006) by using a library reference of the form (planet ....). When a \nlibrary is installed in this way, its documentation is installed as the library is compiled. PLaneT supports \nlibrary versioning, and mul\u00adtiple versions of a package can be installed at a time. In that case, multiple \nversions of the documentation are installed; document ref\u00aderences work with versions just as reliably \nas library references, since they use the same underlying module-import mechanisms to precisely identify \nthe origin of a binding. 10. Experience Scribble is part of the PLT Scheme distribution as of version \n4.0, which was released in June 2008, and all PLT Scheme documen\u00adtation is created with Scribble. Developing \nScribble, porting old PLT Scheme documentation, and writing new documentation took about a year, but \nthe @ notation evolved earlier through years of experimentation. The documentation at http://docs.plt-scheme.org/ \nis built nightly by Scribble from a snapshot of the PLT Scheme source repository. The same documentation \nis available in PDF form at http://pre.plt-scheme.org/docs/pdf/. At the time of this writing, the 70 \nPDF .les of current documentation total 3778 pages in a relatively sparse format, which we estimate would \n.t in around 1000 pages if compressed into a conference\u00adstyle, two-column layout. This total includes \ndocumentation only for libraries that are bundled with PLT Scheme; additional libraries for download \nvia PLaneT are also documented using Scribble. PLT Scheme documentation was previously written in LATEX \nand converted to HTML via tex2page (Sitaram 2007). Although tex2page was a dramatic improvement over \nour original use of latex2html, the build process relied on layers of fragile LATEX macros, HTML hacks, \nand pre-and post-processing scripts, which made the documentation all but impossible to build except \nby its authors. Consequently, most library documentation used a plain\u00adtext format that was easier to \nwrite but inconsistent in style and dif.cult to index. The documentation index distinguished identi.er \nnames from general terms, but it did not attach a source module to each identi.er name, so online help \nrelied on textual search. The Scribble-based documentation system is accessible to all PLT Scheme users, \nwho write their own documentation using Scribble and often supply patches to the main document sources. \nScribble produces output that is more consistent and easier to nav\u00adigate than the old documentation, \nand the resulting documentation works better with online help. More importantly, the smooth path from \nAPI documentation to stand-alone documents has let us pro\u00adduce much more tutorial and overview documentation, \nhelping users .nd their way through the volumes of available information. 11. Related Work As noted in \nthe introduction, most existing documentation tools fall into one of three categories: LATEX-like tools, \nJavaDoc-like tools, and WEB-like tools. The LATEX category includes general word-processing tools like \nMicrosoft Word, but LATEX offers the crucial advantage of pro\u00adgrammability, where macros enable automatic \nformatting of API details. Systems like Skribe (Gallesio and Serrano 2005) improve LATEX by offering \na sane programming language. Even in a pro\u00adgrammable documentation language, however, a lack of connection \nto source code means that information is duplicated in documenta\u00adtion and source, and binding and evaluation \nrules inherent to the source language are not automatically re.ected in documentation and in examples \nrelated to those bindings. The JavaDoc category includes perldoc for Perl, RDoc for Ruby, Haddock (Marlow \n2002) for Haskell, OCamlDoc (Leroy 2007), Doxygen (van Heesch 2007) for various languages (including \nJava, C++, C#, and Fortran), and many others. Such tools improve on the LATEX category, in that they \nprovide a closer connection to the programs that they document. In particular, they are speci.cally designed \nfor library API documentation, where they shine in auto\u00admatic extraction of API details from the source \ncode. These tools are not suitable for other kinds of stand-alone documents, such as overview documents, \ntutorials, and papers (like this one), where prose and document structuring are more central than API \ndetails. Literate programming tools such as WEB (Knuth 1984) and noweb (Ramsey 1994) are designed for \ndocumenting the imple\u00admentation of a library as much as the API that a library exports. In a sense, these \ntools are an extreme version of the JavaDoc cat\u00adegory, where the information communicated to a reader \nis drawn from both the prose and the executable source. In doing so, unfor\u00adtunately, the tools typically \nrevert to a textual slice-and-dice of the program and prose sources, instead of a programmable layer \nthat spans the two halves. Simonis and Weiss (2003) provide a more complete overview of existing systems \nand add ProgDoc, which is similar to noweb in the way that it uses a pipeline of tools. Scribble builds \non many ideas from these predecessors, but .ts them into an extensible framework backed by an expressive \nprogramming language. Skribe (categorized above in the LATEX group) is by far the system most closely \nrelated to Scribble. Like Scribble, Skribe builds on Scheme to construct representations of documents \nusing Scheme functions and macros, and it uses an extension of Scheme syntax to make it more suitable \nfor working with literal text. (Skribe uses square brackets to quote strings, and within square brack\u00adets, \na comma followed by an open parenthesis escapes back into Scheme.) Skribe s format-independent document \nstructure and its use of passes to render a document in.uenced the design of Scrib\u00adble. Skribe, however, \nlacks an integration with lexical binding and the module system that is the heart of Scribble. For example, \na scheme form that typesets and links and identi.er in a lexically sensitive way is not possible to implement \nin Skribe without build\u00ading a PLT Scheme-style module and macro layer on top of Skribe. Scribble builds \non a long line of work in Lisp-style language extensibility, including traditional Lisp macros, lexically \nscoped macros in Scheme (Dybvig et al. 1993), and readtable-based syntactic extension as in Common Lisp. \nPhase-sensitive binding through for-label is speci.c to PLT Scheme, as is the disci\u00adplined approach to \nreader extension embodied by #lang. The SLATEX (Sitaram 2007) system provides automatic for\u00admatting \nof Scheme code within a LATEX document. To identify syntactic forms and constants, SLATEX relies on defkeyword \nand defconstant declarations. In this mode, the author of a work in progress must constantly add another \nstandard bind\u00ading to SLATEX s list; SLATEX s built-in table of syntactic forms is small compared to the \nnumber of syntactic forms available in PLT Scheme. More generally, the problem is the usual one for stan\u00addards \n: there are many to choose from. Scribble solves this problem with for-label imports and by directly \nusing the namespace\u00admanagement functionality of PLT Scheme modules. Many systems follow the Lisp tradition \nof docstrings, in which documentation is associated to run-time values and used for online help. Python \nsupports docstrings, and its doctest module even extracts and executes examples as tests, analogous to \nScribble s examples form. Scribble supports a docstring-like connection between run-time bindings and \ndocumentation, but using lexical\u00adbinding information instead of the value associated with a bind\u00ading. \nFor example, (help cons) in PLT Scheme s read-eval-print loop opens documentation for cons based on its \nbinding as im\u00adported from scheme/base, and not based on the procedure ob\u00adtained by evaluating cons. Smalltalk \nprogramming environments (Kay 1993) have always encouraged programmers to use the source (with its comments) \nas documentation, and environments like Eclipse and Visual Stu\u00addio now make code navigation similarly \nconvenient for other lan\u00adguages. Such tools do not supplant the need for external documen\u00adtation, however, \nsuch as guides and tutorials. In terms of surface syntax, many documentation systems build on either \nS-expression notation (or its cousin XML) as a way to en\u00adcode both document structure and program structure. \nSuch repre\u00adsentations are especially appropriate for an intermediate representa\u00adtion of documentation, \nas in DocBook (Walsh and Muellner 2008). S-expression encodings of documentation are especially common \nin Lisp projects, where data and code are mingled easily. 12. Conclusion A documentation language should \nbe designed not by piling escape conventions on top of a comment syntax, but by re\u00admoving the weaknesses \nand restrictions of the programming language that make a separate documentation language ap\u00adpear necessary. \nScribble demonstrates that a small number of rules for forming documentation, with no restrictions on \nhow they are composed, suf.ce to form a practical and ef.\u00adcient documentation language that is .exible \nenough to sup\u00adport the major documentation paradigms in use today. Clinger s introduction to the RnRS \nstandards, adapted for Scribble Our design for Scribble relies on a thread of language-extension work \nthat starts in Lisp macros, runs through Scheme s introduction of lexically scoped syntax, and continues \nwith PLT Scheme inno\u00advations on modules, phases, and an open syntax expander. Mean\u00adwhile, LATEX and Skribe \ndemonstrate the advantages of building a document system on top of a programming language, and tools \nlike JavaDoc demonstrate the power of leveraging the information available in a program s source to automate \nand link documentation about the program. Scribble combines all of these threads for the .rst time, pro\u00adducing \na tool (or library, or language, depending on how you look at it) that spans and integrates document \ncategories. We are aware of no programming system besides PLT Scheme that is distributed with tutorials, \nprogrammer guides, and detailed API documenta\u00adtion, all extensively and precisely cross-referenced. We \nalso know of no other system that makes it so easy for third parties to add new documentation of all \nkinds with the same level of integration, to say nothing of being able to extend the documentation system \nitself. Trying Scribble To install an HTML version of this paper where Scheme and Scrib\u00adble identi.ers \nare hyperlinked to their documentation, .rst install PLT Scheme 4.1.5 or later from http://plt-scheme.org/. \nThen, start DrScheme, enter the program #lang scheme (require (planet mflatt/scribble-paper))  and click \nRun. Running the program installs the paper and di\u00adrects your default browser to the starting page. To \nview the document source, click Check Syntax and then right-click on mflatt/scribble-paper to open its \nsource. Acknowledgements: We would like to thank Matthias Felleisen and the anonymous reviewers for helpful \nfeedback on this paper. This work is supported in part by the NSF. Bibliography R. Kent Dybvig, Robert \nHieb, and Carl Bruggeman. Syntactic Abstraction in Scheme. Lisp and Symbolic Computation 5(4), pp. 295 \n326, 1993. Matthew Flatt. Compilable and Composable Macros, You Want it When? In Proc. ACM Intl. Conf. \nFunctional Programming, pp. 72 83, 2002. Matthew Flatt, Robert Bruce Findler, Shriram Krishnamurthi, \nand Matthias Felleisen. Programming Languages as Operating Systems (or Revenge of the Son of the Lisp \nMachine). In Proc. ACM Intl. Conf. Functional Programming, pp. 138 147, 1999. Matthew Flatt, and PLT \nScheme. Reference: PLT Scheme. PLT Scheme Inc., PLT-TR2009-reference-v4.2, 2009. Erick Gallesio, and \nManuel Serrano. Skribe: a Functional Authoring Lan\u00adguage. J. Functional Programming 15(5), pp. 751 770, \n2005. Alan C. Kay. The early history of Smalltalk. ACM SIGPLAN Notices 28(3), 1993. Donald E. Knuth. \nLiterate Programming. Computer Journal 27(2), pp. 97 111, 1984. Xavier Leroy. The Objective Caml System, \nrelease 3.10. 2007. Simon Marlow. Haddock, a Haskell Documentation Tool. In Proc. ACM Wksp. Haskell, \npp. 78 89, 2002. Jacob Matthews. Component Deployment with PLaneT: You Want it Where? In Proc. Wksp. \nScheme and Functional Programming, 2006. Norman Ramsey. Literate Programming Simpli.ed. IEEE Software \n11(5), pp. 97 105, 1994. Volker Simonis, and Roland Weiss. ProgDOC A New Program Docu\u00admentation System. \nIn Proc. Perspectives of System Informatics, Lecture Notes in Computer Science volume 2890, pp. 438 449, \n2003. Dorai Sitaram. TeX2page. 2007. http://www.ccs.neu.edu/home/ dorai/tex2page/tex2page-doc.html Dorai \nSitaram. How to Use SLaTeX. 2007. http://www.ccs.neu. edu/home/dorai/slatex/ Michael Sperber (Ed.). \nThe Revised 6 Report on the Algorithmic Language Scheme. 2007. Norman Walsh, and Leonard Muellner. DocBook: \nThe De.nitive Guide. O Reilly &#38; Associates, Inc., 2008. Dimitri van Heesch. Doxygen Source Code Documentation \nGenerator Tool. 2007. http://www.stack.nl/ dimitri/doxygen/  \n\t\t\t", "proc_id": "1596550", "abstract": "<p>Scribble is a system for writing library documentation, user guides, and tutorials. It builds on PLT Scheme's technology for language extension, and at its heart is a new approach to connecting prose references with library bindings. Besides the base system, we have built Scribble libraries for JavaDoc-style API documentation, literate programming, and conference papers. We have used Scribble to produce thousands of pages of documentation for PLT Scheme; the new documentation is more complete, more accessible, and better organized, thanks in large part to Scribble's flexibility and the ease with which we cross-reference information across levels. This paper reports on the use of Scribble and on its design as both an extension and an extensible part of PLT Scheme.</p>", "authors": [{"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "University of Utah and PLT, Salt Lake City, UT, USA", "person_id": "P1614002", "email_address": "", "orcid_id": ""}, {"name": "Eli Barzilay", "author_profile_id": "81100158320", "affiliation": "Northeastern University and PLT, Boston, MA, USA", "person_id": "P1614003", "email_address": "", "orcid_id": ""}, {"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "Northwestern University and PLT, Evanston, IL, USA", "person_id": "P1614004", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596569", "year": "2009", "article_id": "1596569", "conference": "ICFP", "title": "Scribble: closing the book on ad hoc documentation tools", "url": "http://dl.acm.org/citation.cfm?id=1596569"}