{"article_publication_date": "08-31-2009", "fulltext": "\n Experience Report: OCaml for an Industrial-Strength Static Analysis Framework Pascal Cuoq * Julien \nSignoles with Patrick Baudin, Richard Bonichon, CEA LIST, Software Reliability Labs, G\u00b4ic Correnson, \neraud Canet, Lo\u00a8Boite 65, 91191 Gif-sur-Yvette Cedex, France Benjamin Monate, Virgile Prevosto, First.Last@cea.fr \nArmand Puccetti Abstract This experience report describes the choice of OCaml as the imple\u00admentation \nlanguage for Frama-C, a framework for the static anal\u00adysis of C programs. OCaml became the implementation \nlanguage for Frama-C because it is expressive. Most of the reasons listed in the remaining of this article \nare secondary reasons, features which are not speci.c to OCaml (modularity, availability of a C parser, \ncontrol over the use of resources. . . ) but could have prevented the use of OCaml for this project if \nthey had been missing. Categories and Subject Descriptors D1.1 [Programming tech\u00adniques]: Applicative \n(Functional) Programming General Terms Design, Languages, Veri.cation 1. Introduction Frama-C is a framework \nthat allows static analyzers, implemented as plug-ins, to collaborate towards the study of a C program. \nAl\u00adthough it is distributed as Open Source, Frama-C is very much an industrial project, both in the size \nit has already reached and in its intended use for the certi.cation, quality assurance, and reverse\u00adengineering \nof industrial code. Frama-C is written in OCaml, and this article reports on the most noticeable consequences \nof this choice on the human (section 2) and technical (section 3) levels, as well as providing an overview \nof the implementation of Frama-C (section 4). 2. Human Context Frama-C is developed collaboratively between \nthe ProVal team (a joint laboratory of INRIA Saclay Ile-de-France and LRI) and CEA LIST. This article \ndescribes our (CEA LIST) own analysis of this collaborative development. The Open Source nature of the \nsoftware and other partnerships involving CEA LIST mean that Frama-C is in fact developed at three different \nsites, by around ten full-time programmers, with infrequent inter-site face-to-face meetings. * This \nwork has been supported by the french RNTL project CAT ANR05RNTL00301 Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. 2.1 Recruiting OCaml programmers It is typical \nfor an article of this nature to include a few words to the effect that it is harder to .nd people who \ncan program in functional language Y (Minsky 2007; Nanavati 2008) than in C++, sometimes nuanced by more \nwords pointing out that this is balanced by the higher quality of Y candidates. The .rst proposition \ndid not apply for us in the case of Frama-C and OCaml. CEA LIST is an applied research laboratory that \nrecruits almost exclusively PhDs. When the choice is restricted to candidates with a PhD in the .eld \nof formal methods, it is not harder to .nd a candidate with the motivation to program in OCaml than in \nC++.  2.2 Objectives of the Frama-C project Although it is developed by research institutes, Frama-C \ntries to ful.ll focused, speci.c needs expressed by industrial partners. It aims past the R&#38;D departments \nand into the hands of the engi\u00adneers who develop embedded code in any industry with criticality issues1. \nFrama-C is structured as a kernel to which different anal\u00adysis plug-ins are connected. It is composed \nas a whole of 100 to 200 thousands of lines of OCaml2. All this OCaml code provides a wide range of functionalities, \nbut the plug-ins do not just sit side by side. It is more accurate to think of them as built on top of \neach other. To give an example, a value analysis plug-in computes su\u00adpersets of possible values for the \nvariables of the program (Canet et al. 2009), indexed by statement of the original program. Unions, structs, \narrays and casts thereof are handled with the precision nec\u00adessary for embedded code (Cuoq 2008). These \nvalues, especially the values of pointers and expressions used as indices in arrays, are used by another \nplug-in to compute synthetic functional dependen\u00adcies between the inputs and the outputs of each analyzed \nfunction. These synthetic dependencies are in turn used by a slicer plug-in which produces simpli.ed, \ncompilable C programs that are guar\u00adanteed to be equivalent to the original for the slicing criterion. \nAnd the building blocks of this slicer are used by one of Frama-C s most sophisticated plug-ins to date, \na security-aware slicer that preserves the con.dentiality of information: the (functional) con.dentiality \nis guaranteed to be exactly the same in the sliced program as in the original program (Monate and Signoles \n2008). This means that it is safe to study functional con.dentiality on the (smaller) sliced program, \nfor instance for a security audit of the source code. This would not be possible with a traditional slicer, \nbecause a traditional 1 or even without criticality issues, but so far the industrial interest has come \nfrom critical embedded systems 2 The command wc find . -name \\*.ml -o -name \\*.mli re- ICFP 09, August \n31 September 2, 2009, Edinburgh, Scotland, UK. ports 220000 lines as of this writing, which include comments, \nthe CIL Copyright &#38;#169; 2009 ACM 978-1-60558-332-7/09/08. . . $5.00 and ocamlgraph libraries, and \nsome testing scripts c  slicer might remove information leaks in particular, a malicious programmer \ncould insert information leaks that he knows the tradi\u00adtional slicer used for the audit will remove. \n Figure 1. Frama-C s value analysis displaying results in the GUI  2.3 History of Frama-C At the Software \nReliability Labs, Frama-C was initially seen as a major evolution to Caveat (Baudin et al. 2002; Randimbivololona \net al. 1999; Delmas et al. 2008), a software veri.cation tool for C programs based on Hoare logic. Caveat \nis used by Airbus for part of the veri.cation of part of the software embedded in the A380. As the DO-178B \nstandard mandates, Caveat has been quali.ed by Airbus as a veri.cation tool to be used for the certi.cation \nof this particular software. Caveat is supported by the Software Reliability Labs but new ideas are now \ndeveloped within Frama-C. OCaml was pushed as the implementation language to choose for Frama-C by the \nnew hires, but the actual reason it was ac\u00adcepted is that OCaml was not completely unheard of to the \nsenior researchers there. Indeed, OCaml was already used in the (predom\u00adinantly C++) Caveat project as \nthe scripting language that allows an interactive validation process to be re-played in batch mode. 3. \nTechnical context 3.1 Expressivity OCaml s expressivity was crucial in the adoption phase of the lan\u00adguage. \nAn initial one-person internal prototype was able to produce results that convinced management to extend \nthe experiment to two programmers. Eventually, this prototype was able to persuade in\u00addustrial users \nto get involved in a national project. To be precise, industrial partners agreed to be part of the project \nbecause of their previous experiences with the providers of static analyzers in the project. Some of \nthe tools that they were familiar with were written in OCaml (Caduceus by the ProVal team), and some \nof them weren t (Caveat). The time it takes to build these relationships should not be underestimated, \nand we are not saying that the choice of any programming language can shorten it. However, the progress \nmade by Frama-C after the project had started, which can at least partly be attributed to OCaml, convinced \nthe industrial participants to become involved beyond expectations. At each phase of the bootstrap process, \nOCaml s expressivity was important in quickly writing the proof-of-concept that took the project to the \nnext stage. 3.2 Control over the use of resources One of Frama-C s .rst plug-ins was a value analysis \nbased on ab\u00adstract interpretation. This plug-in computes supersets of possible values for expressions \nof the program. Among other things, these over-approximated sets are useful to exclude the possibility \nof a run-time error. In contrast with the heuristic techniques used in other static analysis tools, which \nmay be very ef.cient but solve a different problem, shortcuts do not work when the question is to correctly \n that is, without false negatives .nd all possible run-time errors in large embedded C programs. The \nanalysis has to start from the entry point of the analyzed program and unroll function calls (and often \nloops). In addition, the modular nature of Frama-C and the interface that the value analysis aimed at \nprovid\u00ading to other plug-ins meant that abstract states had to be memo\u00adrized at each statement, which \ndictated the choice of persistent data structures, with sharing between identical sub-parts of states \n(Cuoq and Doligez 2008). This meant at the very least that a garbage\u00adcollected language had to be used. \nWhile there are popular imper\u00adative languages that are garbage-collected nowadays, and some of these \nlanguages have huge libraries of data structures ready to use, persistent data structures are often under-represented \nin these li\u00adbraries, and are slightly annoying to write in these languages. For writing a static analyzer, \none is not worse off with OCaml and a few select libraries (Conchon et al. 2008; Filli atre and Conchon \n2006) than with any of Python, the .NET framework or the Java platform, although it is by no means impossible \nto write static analyzers in any of these. By contrast, in the development of Caveat in C++, there were \nexplicit deallocation functions, and sanity checks that warned at the end of a session if deallocation \nhad been forgotten for some nodes. Programming time that could have been spent usefully was spent writing \nthe calls to the deallocation primitives and the source code s readability was diminished, but this is \nneglectable compared to the time that had to be spent debugging (the warnings told the developper that \nthe deallocation had been forgotten, not where it should have been done). The solution to a subtle deallocation \nproblem was often to make copies of existing nodes (although it is not meaningful to compare the memory \nconsumption of Caveat to that of Frama-C s value analysis, because they work on different principles). \nTo conclude, in Frama-C, garbage collection paradoxically en\u00adables a tighter control of memory usage \nthan explicit deallocation because it makes sharing possible in practice. OCaml is a strict lan\u00adguage. \nWe do not know what the in.uence of lazy evaluation would be on memory use.  3.3 Existence of CIL CIL \n(Necula et al. 2002) is an OCaml library that provides a parser and Abstract Syntax Tree (AST)-level \nlinker for C code. CIL is well documented and provides ready-made generic analyses that are very useful \nto get a prototypal analyzer started. Unlike the earlier mentioned data structures that are nice to .nd \nin OCaml but could be written quickly if they were missing, having to write a C parser when one s goal \nis to write a static analyzer would be a major time-sink. It would have been a signi.cant counter-argument \nto the choice of OCaml if such a library had not existed. We were probably a little bit lucky, and OCaml \nis certainly at a disadvantage with respect to other languages from this point of view. We weren t perhaps \nlucky to .nd a C parser so much as to be working in a .eld that is also of interest to academia. So many \nresearchers in software engineering use OCaml for their experiments that despite the amount of work involved, \nsuch a parser could be expected to get written someday. On the other hand, .nding a library, or even \nbindings to an existing library, for an OCaml project in a .eld that does not interest students and researchers \ncould be a problem.  This drawback (less developers implies less available libraries) is mitigated by \nhigher code re-usability when you do .nd code to re-use, the existence of the Caml Hump3 and the fact \nthat the grapevine works well between OCaml developers. OCaml does not have anything that begins to compare \nfor instance with CPAN, the Comprehensive Perl Archive Network, but it does have a healthy community. \n 3.4 Portability It would have been an annoyance if the development platform for Frama-C had allowed \nit to be used only on Unix variants, because many potential users only have access to Windows stations. \nUnix being the system used by the majority of the researchers at the Software Reliability Labs, the switch \nto a Windows-only platform was not considered. Motivated users and at this time actually deploying formal \nmethods requires motivation anyway have found their way past this limitation for previous projects developed \nat the Labs. Fromthispointofview,thechoiceofOCaml(andlaterof GTK+ as the toolkit for the graphical interface, \nthrough the lablgtk bind\u00adings) was an excellent compromise, with Unix clearly being the primary platform \nof the compiler, and Win32 robustly supported through either Cygwin or Visual C++. Compiling a large \nOCaml project on Windows+Cygwin is slow. This is probably caused one way or the other by the use of Unix \ncompilation idioms (con.g\u00aduration script, make.le) on an OS where things are usually done differently, \nand is not a limitation in this context. It should be noted that many OCaml developments are refer\u00adenced \nin the source distribution GODI, with dependency lists and automated compilation scripts. All of those \nFrama-C dependencies that are written in OCaml are referenced in GODI, and Frama-C it\u00adself is. Some Frama-C \nusers who have no interest in OCaml outside of Frama-C have found that this was the most convenient installa\u00adtion \npath for them. Frama-C has been tested under Windows, Mac OS X, Solaris (32-bit), OpenBSD and Linux. \nBinaries are also distributed for some of these platforms. 64-bit readiness A 64-bit address space is \navailable to OCaml programs for many 64-bit platforms. Frama-C compiles in both 32-and 64-bit mode, and \nthe resulting versions are functionally identical. This was not a big effort, as OCaml encourages to \nwrite high-level code, for instance by providing bignums. For some 64\u00adbit-aware platforms (Mac OS X), \nit is a simple configure option to choose between 32-bit or 64-bit pointers at the time of compiling \nOCaml. For others, it is troublesome to go against the default size (Linux). With Linux, getting an OCaml \ncompiler with a word size different from the distribution default is akin to building a cross\u00adcompiler. \nHowever, efforts are under way in the OCaml community to improve support for cross-compilation, including \nfrom Linux to Win32. We are looking forward to the maturation of such initia\u00adtives. Availability of a \ngraphical toolkit Frama-C uses the GTK+ toolkit for its graphical user interface. This section does not \ndiscuss the merits or demerits of this toolkit with respect to others. The ques\u00adtion it tries to answer \nis If I choose OCaml for a software project, will I .nd one satisfactory toolkit to design the user interface \nwith? . The choice of GTK+ for Frama-C was somewhat arbitrary, but it allows to give a positive answer \nto the question above, without prejudice to other available toolkits. Our experience is that for some \nUnix variants (Solaris, Mac OS X, very old Linux distributions), it is necessary to obtain and compile \nthe missing GTK+ libraries manually, or semi-manually 3 The Caml Hump an is informal central repository \nfor OCaml libraries with the help of source distribution systems such as GARNOME or MacPorts. In this \ncase, retrieving and installing the dependencies of the gtksourceview1 library (a GTK+ widget for displaying \nsource code) is a pain. This is not directly an OCaml problem, but another development platform could \nhave made it possible to use the mod\u00adern gtksourceview2 (which solves the dependencies problem) or provided \nmore toolkits to choose from initially (to the best of our knowledge, OCaml only offers Tk and GTK+ at \nthis time). Now that gtksourceview2 has become stable, there is talk on the lablgtk development list \nabout including it in lablgtk. This is anyway a very minor quibble. It should be kept in mind for comparison \nthat Java or .NET/Mono do not come pre-installed on every platform either. Again, we have no reason to \nregret the choices of OCaml and GTK+ from the standpoint of portability. OCaml as a scripting language \nIt should be noted that while this is not its strongest point, OCaml is an acceptable scripting lan\u00adguage. \nIn other words, when OCaml is chosen as the main language for a new project, the project may be saved \nthe introduction of addi\u00adtional dependencies towards various dedicated scripting languages down the road. \nFor instance, the HTML pages of the Frama-C web site are processed with the yamlpp preprocessor4, which \nis written in OCaml. For comparison, in its 15 years of development, Caveat had at one point accumulated \ndependencies towards Perl, Python, Bash and Zsh (in addition to C++, and in addition to OCaml, used for \njournalizing and re-playing). Some of these dependencies have since be removed, by replacing some tools \nwith OCaml equivalents. Whatever the main language, discipline is obviously the foremost factor in avoiding \ndependency creep .  3.5 Module system OCaml s module system (Leroy 1996) has direct advantages: it creates \nseparate namespaces and, when the modules are in separate .les and interfaces have been de.ned, fully \ntype-checked separate compilation. It is easy to underestimate the importance of these features in the \nmanagement of a big project because they make the compiler transparent, but when they are missing, their \nabsence is unpleasantly noticeable. We discuss these, and the (theoretically more interesting) functor \nsystem per se. Separate compilation With OCaml, in bytecode, separate com\u00adpilation has the same meaning \nas everywhere: compilation is par\u00adallelizable and only modi.ed .les need to be recompiled, with a quick \n.nal link phase. With native compilation, all the ancestors of the modi.ed modules in the dependency \ngraph must be recompiled, and the compilation of two .les with a parenthood relationship can not be parallelized. \nDepending on the structure of an OCaml project, recompilation after an incremental change in a low-level \nmodule may sometimes feel longish, but in truth, it is much faster to recompile Frama-C with ocamlopt \nthan to recompile Caveat with g++. The existence of two OCaml compilers, one with blazingly fast compilation \nin general, the other with acceptable recompilation time and producing reasonably fast code, allows very \nshort modify\u00adrecompile-test cycles. Again, it is easy to take short recompilation times for granted but \nwith other languages, when a software project grows in size, this can sometimes be lost, and sorely missed. \nThe OCaml compiler tries very hard not to get in the way between a programmer and his program, and it \ndoes not force the programmer to write interfaces. However, if the interface m.mli is missing for module \nM, the compiled interface is generated from m.ml. This means that any change to m.ml changes the compiled \ninterface and forces the recompilation of every module that uses M, even in bytecode. In a large project, \nmodules should always have 4 http://www.lri.fr/~filliatr/yamlpp.en.html  interfaces, if only for the \nsake of separate compilation. OCaml has an option to generate automatically the interface m.mli that \nexports everything from M. Separate namespaces for compilation units Orthogonally to sep\u00adarate compilation, \nbut as importantly for big projects, OCaml s module system provides separate namespaces. Better yet, \nthe com\u00adpiler option -pack allows to group several compilation units into a namespace. As a consequence, \ncompilation units that have been put into different packs may safely use the same name for a type, variable \nor module. For instance the types tree in .les both called m.ml in packs lib1 and lib2 are seen as Lib1.M.tree \nand Lib2.M.tree. This feature is very useful for libraries because libraries may use very common .lenames \n(util.ml) with the guarantee that there will not be a clash at link-time for users of this library (on \ncondition that the pack name itself is unique). In Frama-C, plug-ins are independent from each other: \neach plug-in only interfaces with the Frama-C kernel, and does not see the implementation details of \nother plug-ins. In order to implement this separation, the Frama-C system automatically packs each plug\u00adin. \nThus, two different plug-ins may use .les with identical names and still be linked together within Frama-C. \nInterfaces and functors The possibility to write functors (mod\u00adules that are parameterized by other modules \nor functors), intro\u00adduced before objects (at the time of Caml Special Light), has proved a workable, \nand completely statically checked, alternative to object-oriented programming. We use OCaml objects only \nwhen interfacing with existing OCaml code that uses objects (CIL and lablgtk), and use functors for the \nrest. Some very structural idioms seem destined to be expressed with objects (or, for that matter, class \ntypes): equality, pretty\u00adprinting, hashconsing or marshaling functions5. Most of our data structure are \ncomplicated enough that automatically produced pretty-printers or equality functions would not .t the \nbill. Con\u00adsequently, it is in our case neither more nor less tedious to write modules (and interfaces) \nthat sport, in addition to a type t, func\u00adtions such as pretty: Format.formatter -> t -> unit and equal: \nt -> t -> bool, and for unmarshaling values of a hash\u00adconsed type, rehash: t -> t. But, speaking of equality, \nit should be noted on the other hand that OCaml s polymorphic comparison functions (including =, >= and \neven ==) are dangerous pitfalls. The type-checker does not complain when they are applied wrongly instead \nof, for instance, equal above. In OCaml, the module system allows to encapsulate the de.ni\u00adtions of data \nstructures, and in particular to give a purely functional interface to a sophisticated data structure \nthat uses mutable values internally for optimization. With this compromise, the amount of stateful information \nthat the programmer has to keep in mind is limited by the module boundaries, and the implementation s \nalgo\u00adrithmic complexity may be better than that of all known pure im\u00adplementations. Some in the OCaml \ncommunity call such an impure module persistent (Conchon and Filli atre 2007). In fact, some positive \nreports on the industrial use of Haskell (Nanavati 2008) resonate deeply with our own programming experience, \nexcept that we attribute to OCaml s module system the advantages attributed there to Haskell s purity. \n 3.6 Labels and optional arguments OCaml allows to use labels for function arguments. This feature does \nnot make anything possible that was not already, but in prac\u00adtice, labels provide a concise way to remove \nthe risk of confusion 5 In the presence of hashconsing, not only do you have to write your own unmarshaling \nfunctions, but they are extremely tricky to get right when a function takes several arguments of the \nsame type with no obvious normal order between them. The only language that we know of with a feature \nvaguely similar to OCaml s labels is Objec\u00adtive C s in.x notation for function calls. Syntax begets style. \nThe OCaml style is to write pure func\u00adtions unless an exception needs to be made because the syntax re\u00adwards \nthe use of immutable de.nitions, as seen in the following: let x= 2in ... x... let x= ref2in ... !x... \nWe argue that using labels rewards consistent naming schemes in a similar fashion. When it is common \nfor an argument to be passed repeatedly as-is from caller to callee without any computations ac\u00adtually \nhappening to it (and in a persistent setting as much of Frama-C is, this happens with a lot of arguments), \nthe labels syntax re\u00adwards the consistent choice of a unique label and eponymous vari\u00adable name for this \nargument by a very concise syntax. In this ex\u00adample, the function f is being de.ned and calls functions \ng and eval. letf~mode~envxy = let context = ... in ... g ~mode ~context (x+y) ... ... eval ~mode ~context \n~env ... If the programmer deviates from this style by using different la\u00adbel names or variable names \nfor mode, context, or env, he re\u00adceives a gentle slap on the wrist in the form of the awkward ~context:computation_context \nsyntax. This changes the way of reading labels-enabled OCaml programs, too. The reader can put more trust \nin the names of variables, without having to look for context all the time. The level of obtrusiveness \nof the label syntax is exactly the same as with the de.nition of mutable values, and it is exactly right, \ntoo. Good style is encouraged but the system can be circumvented when it needs to. Optional arguments \n(a syntax for giving a labeled argument a default value if it is omitted) are convenient when the consequences \nof the omission (and subsequent use of the default value) are visible and traceable (for instance, to \nprovide a toolkit interface that is both powerful and beginner-friendly). It is in general a bad idea \nto use an optional argument to add a new mode to an existing function, both because of all the existing \ncalls to this function that the compiler would be glad to help the programmer inspect if s/he did not \nuse an optional argument and because of all the calls to be written in the future where the optional \nargument will be omitted by accident. 4. Development of Frama-C There are a number of features in Frama-C \ns architecture that any Frama-C developer must be aware of. The goal of this section is not to provide \na complete list which can be found in the Frama-C plug-in development guide (Signoles 2008) but to \ngive a mildly technical overview of each interesting one, with reference to the OCaml feature(s) that \nmake its implementation possible. 4.1 Software architecture The software architecture of Frama-C is \nplug-in-oriented. This ar\u00adchitecture allows .ne-grained collaboration of analysis techniques (as opposed \nto the large-grain collaboration that happens when one technique is used in a .rst pass and another in \na second pass). As a consequence, mutual recursion between plug-ins must be possi\u00adble: a plug-in A must \nbe able to use a plug-in B that uses A.A Frama-C plug-in is a packed compilation unit (see Section 3.5) \nbut, unfortunately, OCaml does not support mutually-recursive compi\u00adlation units. This problem is circumvented \npragmatically by using references to functions placed in a module that all plug-ins are al\u00adlowed to depend \non.  This central directory module is called db.ml and a snippet of it may look like: /* db.ml: kernel \ndatabase of plug-in stubs */ module Plugin1: sig val run: (unit->unit) ref end module Plugin2: sig ... \nend During its initialization, a plug-in registers each of its exported functions in the appropriate \nstub in Db another OCaml feature is that each compilation unit can have its own initialization effects. \n/* plugin1_register.ml */ let run () = ... (* the analysis goes here *) (* registration of [run] in \nthe kernel *) let () = Db.Plugin1.run := run Thought this solution is the most common way to break mu\u00adtual \nrecursion between compilation units, it has trade-offs. Firstly, polymorphic functions may not be registered \nthis way. This is not an issue here: each plug-in is a static analyzer, and none of the analyzers we \nhave written so far wanted to provide polymorphic functions. Secondly, the types of the registered functions \nhave to be known by the Frama-C kernel. Here again, that is not a big issue in our context, especially \nbecause Frama-C encourages the use of ACSL (Baudin et al. 2008), a common speci.cation language, as the \nlingua franca to transmit knowledge between plug-ins. Finally, the most signi.cant trade-off with this \nsolution is that any plug-in that wishes to provide an interface to other plug-ins (as opposed to interacting \nwith the user only) needs to modify some well-identi.ed parts of the Frama-C kernel. This has not been \na problem so far because, for now, plug-ins written outside Frama-C s development team have all been \ndedicated to answering a speci.c problem, as opposed to providing computations to help other plug-ins. \n 4.2 Dynamic loading of plug-ins OCaml has allowed dynamic linking of bytecode compilation units (through \nmodule Dynlink) for a long time. In OCaml 3.11, dy\u00adnamic linking of native code became available for \na large number of target architectures. Frama-C uses dynamic linking where available in order to pro\u00advide \ndynamic loading of plug-ins. This is an alternative way to plug analyzers into the Frama-C kernel. When \ndynamic linking is used for the plugging, the plug-in s functions are registered in a global table in \nthe kernel at load-time. Because all functions do not have the same ML type, phantom types (Rhiger 2003) \nare used in or\u00adder to dynamically ensure the program s safety (see Section 4.6). Dynamic linking solves \ntwo out of three issues of static linking: it ceases to be necessary for the kernel to be aware of the \ntypes of all plug-ins exported functions, and it becomes more convenient to distribute a plug-in separately \nfrom Frama-C (in particular a plug\u00adin no longer needs to patch the kernel). 4.3 Impure functional programming \nMost analyses in Frama-C are written in a functional style. How\u00adever Frama-C s value analysis (whose \nresults are used by many other plug-ins) relies on hashconsing (Filli atre and Conchon 2006) and memoization, \nwhich are both implemented with mutable data structures. More generally, Frama-C makes use of imperative \nfea\u00adtures in order to improve ef.ciency. For instance, the abstract syn\u00adtax tree (inherited from CIL) \ncontains many mutable .elds. Besides, Frama-C has a global state which is composed of many global ta\u00adbles. \n 4.4 Multi-project framework Frama-C is able to handle several ASTs simultaneously. This al\u00adlows to build \nslicing plug-ins where an original AST is navigated through while a reduced AST is being built. Each \nof these ASTs has its own state (containing for instance the results of the analy\u00adses that have been \nrun on this AST). The AST and corresponding state form what is called a project (Signoles 2009). The \ndesirable safety property of projects is the absence of interference between two distinct projects. To \nenforce this property, each global mutable value of Frama-C must be projecti.ed . A set of functors are \npro\u00advided to this effect (these functors add a project-aware indirection to any mutable data that is \nused by any of the functions made visible by the plug-in). We wish OCaml s type system helped us enforce \nthis rule, but we plan to move to dynamic tags to detect at least at analysis-time when a variable that \nshould have been projecti.ed wasn t. 4.5 Journalization During an interactive session, Frama-C journalizes \nmost of the ac\u00adtions which modi.ed its global state. This means that, like Caveat, it generates an OCaml \nscript retracing what happened during the session. The journal may be compiled and statically or dynami\u00adcally \nlinked with the Frama-C kernel in order to replay the same actions. Furthermore, the journal can be used \nto grasp Frama-C s internals (translating GUI actions into function calls), and it is pos\u00adsible to modify \nit before compiling and replaying it. As for dynamic loading, phantom types allow to safely implement \nthis feature (see Section 4.6).  4.6 Phantom types for dynamic typing in a static setting Both dynamic \nloading and journalization rely on phantom types (Rhiger 2003). Phantom types parameterized types which \nem\u00adploy their type variables for encoding meta-information are used in both cases to ensure the dynamic \nsafety of function calls which cannot be checked by the OCaml type system. Indeed we provide a library \nof dynamic typing. Its implementation requires the use of unsafe features (through OCaml standard library \ns module Obj) but phantom types allow to provide a safe interface: the use of the library cannot break \ntype safety (as long as there is no implemen\u00adtation error in the library). 5. Conclusion We have not \nyet considered the point of view of the external Frama-C plug-in developer. We hope to see in the future \nmany useful plug\u00adins written outside the circle of the initial developers. It is too early to draw conclusions \non the consequences of the choice of OCaml as the platform s language for this goal. Responses so far \nhave ranged from the enthusiastic ( and it s even written in OCaml ) to the rejection ( [...]drawback \nthat the extensions have to be written in Ocaml[sic] ), with in the middle at least one person who decided \nto learn OCaml because there was something s/he wanted to do with Frama-C. Acknowledgments We would like \nto acknowledge the help of our colleagues at ProVal, at INRIA Sophia Antipolis projects Everest and now \nMarelle, and at CEA LIST, in the building of Frama-C. The feedback of users of Frama-C within the CAT \nproject, at Fraunhofer FIRST or elsewhere has been great. The anonymous referees suggested various improvements \nto this experience report. Special thanks go to the developers of the OCaml system. Keywords OCaml, software \narchitecture, plug-ins, static analysis  References Patrick Baudin, Anne Pacalet, Jacques Raguideau, \nDominique Schoen, and Nicky Williams. Caveat: a tool for software validation. In Dependable Systems and \nNetworks, 2002, pages 537+, 2002. Patrick Baudin, Jean-Christophe Filli atre, Thierry Hubert, Claude \nMarch\u00b4e, Benjamin Monate, Yannick Moy, and Virgile Prevosto. ACSL: ANSI C Speci.cation Language (preliminary \ndesign V1.4), preliminary edition, October 2008. URL http://frama-c.cea.fr/acsl.html. G\u00b4eraud Canet, \nPascal Cuoq, and Benjamin Monate. A value analysis for C programs, 2009. To appear in the proceedings \nof SCAM2009. Sylvain Conchon and Jean-Christophe Filli atre. A persistent union-.nd data structure. In \nML 07: Proceedings of the 2007 workshop on Workshop on ML, pages 37 46, New York, NY, USA, 2007. ACM. \nISBN 978-1\u00ad59593-676-9. doi: http://doi.acm.org/10.1145/1292535.1292541. Sylvain Conchon, Jean-Christophe \nFilli atre, and Julien Signoles. Designing a generic graph library using ML functors. In Marco T. Moraz\u00b4an, \neditor, Trends in Functional Programming, volume 8 of Trends in Functional Programming, pages 124 140. \nIntellect, UK/The University of Chicago Press, USA, 2008. ISBN 978-1-84150-196-3. Pascal Cuoq. Documentation \nof Frama-C s value analysis plug\u00adin, 2008. URL http://frama-c.cea.fr/download/ frama-c-manual-Lithium-en.pdf. \nPascal Cuoq and Damien Doligez. Hashconsing in an incrementally garbage-collected system: a story of \nweak pointers and hashconsing in OCaml 3.10.2. In ML 08: Proceedings of the 2008 ACM SIGPLAN workshop \non ML, pages 13 22, New York, NY, USA, 2008. ACM. ISBN 978-1-60558-062-3. David Delmas, St\u00b4ephane Duprat, \nPatrick Baudin, and Benjamin Monate. Proving temporal properties at code level for basic operators of \ncon\u00adtrol/command programs. In 4th European Congress on Embedded Real Time Software, 2008. Jean-Christophe \nFilli atre and Sylvain Conchon. Type-safe modular hash\u00adconsing. In ML 06: Proceedings of the 2006 workshop \non ML, pages 12 19, New York, NY, USA, 2006. ACM. ISBN 1-59593-483-9. Xavier Leroy. A syntactic theory \nof type generativity and sharing. Journal of Functional Programming, 6:1 32, 1996. Yaron Minsky. Caml \ntrading: Experiences in functional programming on Wall Street. In Wouter Swierstra, editor, The Monad.Reader, \nApril 2007. Benjamin Monate and Julien Signoles. Slicing for security of code. In Peter Lipp, Ahmad-Reza \nSadeghi, and Klaus-Michael Koch, editors, TRUST, volume 4968 of Lecture Notes in Computer Science, pages \n133 142. Springer-Verlags, March 2008. Ravi Nanavati. Experience report: a pure shirt .ts. SIGPLAN Not., \n43(9): 347 352, 2008. ISSN 0362-1340. George C. Necula, Scott Mcpeak, Shree P. Rahul, and Westley Weimer. \nCIL: Intermediate language and tools for analysis and transformation of C programs. In International \nConference on Compiler Construction, pages 213 228, 2002. Famantanantsoa Randimbivololona, Jean Souyris, \nPatrick Baudin, Anne Pacalet, Jacques Raguideau, and Dominique Schoen. Applying formal proof techniques \nto avionics software: A pragmatic approach. In FM 99: Proceedings of the Wold Congress on Formal Methods \nin the De\u00advelopment of Computing Systems-Volume II, pages 1798 1815, London, UK, 1999. Springer-Verlag. \nISBN 3-540-66588-9. Morten Rhiger. A foundation for embedded languages. ACM Transactions on Programming \nLanguages and Systems (TOPLAS), 25(3):291 315, 2003. ISSN 0164-0925. Julien Signoles. Plug-in development \nguide, 2008. URL http:// frama-c.cea.fr/download/plug-in_development_guide.pdf. Julien Signoles. Foncteurs \nimp\u00b4es: la notion de projets eratifs et compos\u00b4dans Frama-C. In Actes des Journ\u00b4 ees Francophones des \nLangages Applicatifs, pages 37 54, January 2009. In French.   \n\t\t\t", "proc_id": "1596550", "abstract": "<p>This experience report describes the choice of OCaml as the implementation language for Frama-C, a framework for the static analysis of C programs. OCaml became the implementation language for Frama-C because it is expressive. Most of the reasons listed in the remaining of this article are secondary reasons, features which are not specific to OCaml (modularity, availability of a C parser, control over the use of resources...) but could have prevented the use of OCaml for this project if they had been missing.</p>", "authors": [{"name": "Pascal Cuoq", "author_profile_id": "81100049170", "affiliation": "Commissariat &#224; l'Energie Atomique, Saclay, France", "person_id": "P1613944", "email_address": "", "orcid_id": ""}, {"name": "Julien Signoles", "author_profile_id": "81384607973", "affiliation": "Commissariat &#224; l'Energie Atomique, Saclay, France", "person_id": "P1613945", "email_address": "", "orcid_id": ""}, {"name": "Patrick Baudin", "author_profile_id": "81100085910", "affiliation": "Commissariat &#224; l'Energie Atomique, Saclay, France", "person_id": "P1613946", "email_address": "", "orcid_id": ""}, {"name": "Richard Bonichon", "author_profile_id": "81460645564", "affiliation": "Commissariat &#224; l'Energie Atomique, Saclay, France", "person_id": "P1613947", "email_address": "", "orcid_id": ""}, {"name": "G&#233;raud Canet", "author_profile_id": "81442618272", "affiliation": "Commissariat &#224; l'Energie Atomique, Saclay, France", "person_id": "P1613948", "email_address": "", "orcid_id": ""}, {"name": "Lo&#239;c Correnson", "author_profile_id": "81100446564", "affiliation": "Commissariat &#224; l'Energie Atomique, Saclay, France", "person_id": "P1613949", "email_address": "", "orcid_id": ""}, {"name": "Benjamin Monate", "author_profile_id": "81100225567", "affiliation": "Commissariat &#224; l'Energie Atomique, Saclay, France", "person_id": "P1613950", "email_address": "", "orcid_id": ""}, {"name": "Virgile Prevosto", "author_profile_id": "81100041395", "affiliation": "Commissariat &#224; l'Energie Atomique, Saclay, France", "person_id": "P1613951", "email_address": "", "orcid_id": ""}, {"name": "Armand Puccetti", "author_profile_id": "81442603697", "affiliation": "Commissariat &#224; l'Energie Atomique, Saclay, France", "person_id": "P1613952", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596591", "year": "2009", "article_id": "1596591", "conference": "ICFP", "title": "Experience report: OCaml for an industrial-strength static analysis framework", "url": "http://dl.acm.org/citation.cfm?id=1596591"}