{"article_publication_date": "08-31-2009", "fulltext": "\n Experience Report: Using Objective Caml to Develop Safety-Critical Embedded Tools in a Certi.cation \nFramework Bruno Pagano Olivier Andrieu Thomas Moniot 1 Esterel Technologies, 8, rue Blaise Pascal, \n78890 Elancourt, France {Bruno.Pagano,Olivier.Andrieu, Thomas.Moniot}@esterel-technologies.com Benjamin \nCanou2,3 Emmanuel Chailloux Philippe Wang 2 Laboratoire d Informatique de Paris 6, (LIP6 -CNRS UMR 7606), \nUniversit\u00b4e Pierre et Marie Curie, UPMC, 104, avenue du Pr\u00b4esident Kennedy, 75016 Paris, France {Benjamin.Canou,Emmanuel.Chailloux, \nPhilippe.Wang}@lip6.fr Jean-Louis Colac\u00b8o * 4 Prover Technology S.A.S 21 Rue Alsace Lorraine, 31000 Toulouse, \nFrance Jean-Louis.Colaco@prover.com Pascal Manoury 3 Laboratoire Preuves, Programmes et Syst`emes, (PPS \n-CNRS UMR 7126), Universit\u00b4e Pierre et Marie Curie, UPMC, 175 rue du Chevaleret, 75013 Paris, France. \n Pascal.Manoury@pps.jussieu.fr Abstract High-level tools have become unavoidable in industrial software \ndevelopment processes. Safety-critical embedded programs don t escape this trend. In the context of safety-critical \nembedded sys\u00adtems, the development processes follow strict guidelines and re\u00adquirements. The development \nquality assurance applies as much to the .nal embedded code, as to the tools themselves. The French company \nEsterel Technologies decided in 2006 to base its new SCADE SUITE 6TM certi.able code generator on Objective \nCaml. This paper outlines how it has been challenging in the context of safety critical software development \nby the rigorous norms DO\u00ad178B, IEC 61508, EN 50128 and such. Categories and Subject Descriptors D.1.1 \n[Applicative (Func\u00adtional) Programming]; D.2.1 [Requirements/speci.cations]: Tools; D.2.5 [Testing and \nDebugging]: Testing tools General Terms Reliability, Experimentation, Measurement, Ver\u00adi.cation Keywords \nsafety critical, DO-178B, Objective Caml, SCADE SUITE 6TM code generator * This work started while the \nauthor was at Esterel Technologies. Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 09, August 31 September 2, 2009, Edinburgh, Scotland, UK. Copyright \nc &#38;#169; 2009 ACM 978-1-60558-332-7/09/08. . . $5.00 1. Introduction The civil avionics authorities \nde.ned a couple of decades ago the certi.cation requirements for aircraft embedded code. The DO\u00ad178B \nstandard (RTCA/DO-178B 1992) de.nes all the constraints ruling the aircraft software development. This \nprocedure is in\u00adcluded in the global certi.cation process of an aircraft, and now has equivalents in \nother industrial sectors concerned by critical soft\u00adware (FDA Class III for the medical industry, EN \n50128 for railway applications, IEC 61508 for the car industry, etc). The Esterel Technologies company \nmarkets SCADE SUITE 6TM 1 (Berry 2003; Camus and Dion 2003), a model-based develop\u00adment environment dedicated \nto safety-critical embedded software. The code generator (KCG 2) of this suite that translates models \ninto embedded C code is DO-178B compliant and allows to shorten the certi.cation process of avionics \nprojects which make use of it. Us\u00ading such a code generator allows the end user (the one that develops \nthe critical embedded application) to reduce the development costs by avoiding the veri.cation that the \ngenerated code implements the SCADE model (considered here as a speci.cation). The veri.ca\u00adtion and validation \nactivities are reduced to provide evidence that the model meets the functional requirements of the embedded \nap\u00adplication. In this way, a large part of the certi.cation charge weighs on the SCADE framework and \nthis charge is shared (through the tool provider) between all the projects that make use of this tech\u00adnology. \nThe .rst release of the compiler was implemented in C and was available in 1999. It was based on a code \ngenerator written in an Eiffel s dialect (LOVE) (ECMA 2005) and was, at that time, rewritten in the mainstream \nC language to avoid the risk of being rejected by certi.cation authorities. Then, since 2001, Esterel \nTechnologies has investigated new compiling techniques (Colac\u00b8o and Pouzet 2003) and language ex\u00ad 1 SCADE \nstands for Safety Critical Application Development Environment. 2 KCG stands for quali.able Code Generator. \n tensions (Colac\u00b8o et al. 2005). The aim was to demonstrate that us\u00ading an academic approach for the \nspeci.cations of the language (types systems, etc.) and Objective Caml (OCaml) for its imple\u00admentation \nwas also an ef.cient and clean approach for an indus\u00adtrial project The project quickly led to the expected \ngood technical results but took some time to convince managers that such an ap\u00adproach should be accepted \nby a reasonable certi.cation authority. It has now appeared that OCaml allowed to signi.cantly reduce \nthe distance between the speci.cations and the implementation of an engineering tool, to have a better \ntraceability between a for\u00admal description of the input language of the tool and its compiler implementation. \nThus, Esterel Technologies has designed its new SCADE SUITE 6TM in OCaml. This paper describes the speci.c \ndevelopment activities per\u00adformed by Esterel Technologies to certify KCG with the several norms: DO-178B, \nIEC 61508 and EN 50128. The differences and particularities of these standards are not in the scope of \nthis paper; for convenience, we focus on the FAA standard (DO-178B, level A). 2. Certi.cation of safety \ncritical code The well known V-cycle dear to the software engineering indus\u00adtry is the traditional framework \nof any certi.ed/quali.able devel\u00adopment project. Constraints are reinforced by DO-178B but the principles \nstay the same: the product speci.cations are written by successive re.nements, from high level requirements \nto low level design and then implementation. Each step involves several inde\u00adpendent veri.cation activities: \nchecking complete traceability of re\u00adquirements between successive steps, testing each stage of code \nproduction with adequate coverage, code and coding rules reviews. Figure 1. V-cycle 2.1 The programming \nlanguage in the development process Traceability is one of the keywords of the compliance to DO-178B, \nany part of any activity of the project cycle pertains to other parts of the previous and of the following \nactivities. For instance, any requirement of the detailed design has to be related to one or several \nrequirements of the architecture design and to the lines of code implementing this requirement. Furthermore, \nthe relation has to exist with the corresponding veri.cation activity. In our example, the detailed design \nrequirement has to be related to unitary tests that exercise this requirement. The evidence of these \nrelations is one of the most important documents of a certi.cation .le. In a DO-178B compliant project, \nto ensure that the software sat\u00adis.es all the requirements and that any single line of the software is \nnecessary to its purpose, nothing can appear in the code without being clearly speci.ed and identi.ed \n.rst with a good traceability to high-level requirements (the speci.cations). These traceability links \npass through architectural design and detailed design require\u00adments. The choice of a programming language \nclose and adapted to the software to develop is very important since a well-suited language leads to \na simpler and more direct way to encode the software requirements and consequently, a better and simpler \ntraceability. In the same vein, when the programming language is adapted to the developed software, the \narchitecture of the software is close to the functional description of the software. The links between \nar\u00adchitecture and speci.cations, and between architecture and detailed design are simpler to establish \nand verify. The code is tested but it is also reviewed by other developers. To ease this veri.cation, \nthe code must be short (in the sense that it contains more about fundamental algorithms than on resource \nmanagement) and readable. Furthermore, the libraries and especially the system library have to be treated \nin the same way as the main source code: it is manda\u00adtory to have the same traceability and veri.cations \non any speci.c part of the code. So, the choice of a suitable programming language is relevant for the \nvarious veri.cation activities required in DO-178B compli\u00adant projects. This is, of course, always true, \nbut becomes crucial when one has to defend a project in front of a certi.cation author\u00adity.  2.2 Code \ncoverage The DO-178B de.nes several veri.cation activities and, among these, a test suite has to be constituted \nto cover the set of speci\u00ad.cations of the software in order to verify and to establish the con\u00adformity \nof their implementation. As any activity during a DO-178B compliant development process, the veri.cation \nactivities are eval\u00aduated. Some criteria must be reached to decide that the task has been completed. \nOne of these criteria is the activation of any part of the code during a functional test. On this particular \npoint, more than a complete structural exploration of the code, the DO-178B standard requires that a \ncomplete exploration of the control .ow has to be achieved following the Modi.ed Condition / Decision \nCoverage (MC/DC) measurement that we explain below. A decision is the Boolean expression evaluated in \na test instruc\u00adtion to determine the branch to be executed. It is covered if tests exist in which it \nis evaluated to true and false.  A condition is an atomic subexpression of a decision. It is covered \nif there exist tests in which it is evaluated to true and false.  The MC/DC requires that, for each \ncondition c of a decision, there exist two tests which must change the decision value while keeping the \nsame valuations for all conditions but c. It ensures that each condition can affect the outcome of the \ndecision and that all contribute to the implemented function (no dead code is wanted).  The MC/DC is \nproperly de.ned on an abstract Boolean data .ow language (Hayhurst et al. 2001) with a classical automata \npoint of view. The measure is extended to imperative programming lan\u00adguages, especially the C language, \nand is implemented in veri.ca\u00adtion tools able to compute this measure. The challenging consequences of \nthe choice of OCaml instead of the usual C or ADA on MC/DC test campaigns is described in section 4. \n  2.3 Source to object code traceability The code veri.cation takes place essentially on the source \ncode. But, the real need is to assert that all veri.ed properties of the source code are also properties \nof the object code and, indeed, the executable binary. Most of the time these veri.cations activities \nare neither possible to do on the binary, nor on the object .le. To handle this contradiction, the process \nrequires to verify that the properties of the source code are also properties of the object code. The \ncompiler analysis focuses on three points: the traceability of the object code generation: by transitivity, \none can deduce from that, the traceability of the requirements in the object code.  the management of \nthe system calls: processes for safety critical applications are very suspicious about calls of system \nsubrou\u00adtines.  conservation of the control .ow: the code coverage measure\u00adment is relevant if and only \nif the control .ow is traceable from source to object code.  More than the choice of a programming language, \na DO-178B project manager has to choose the complete development suite, in\u00adtegrating the code generator \nand test management tools which will be the most convenient to manage all the development activities; \nincluding coding but also all the veri.cation activities about this coding. Section 5 describes how the \nthree above requirements can be addressed. 3. Using OCaml in the development process OCaml is a functional, \nimperative and object oriented ML dialect. The development environment provided by INRIA contains a na\u00adtive \ncompiler dedicated to the most common architectures3. As a functional language, OCaml is adapted to symbolic \ncom\u00adputation and so, particularly suitable for compiler design and for\u00admal analysis tools which rely \nmainly on symbolic computation. As well for its bootstrapping (Leroy et al. 2008), OCaml is used in Lu\u00adcid \nSynchrone (Pouzet 2006), the ` a la Lustre language for reactive systems implementation, or the Coq (Project \n2006) proof assistant implementation. Some years ago Dassault major avionics industry approached the \nuse of OCaml in software engineering for safe real\u00adtime programs development. The experience of Surlog \nwith AGFL4 and the usage of Astr\u00b4 ee (Cousot et al. 2005) by AIRBUS industries show that tools written \nin OCaml can be integrated in a critical software development process. The Esterel Technologies project \npresented in this paper is a code generator, named KCG, that translates SCADE models (data\u00ad.ow with state \nmachines) into embeddable C code. SCADE is a Lustre(Halbwachs et al. 1991) dialect (program directed \nby equa\u00adtions with time constructions) enhanced by powerful control .ow constructions (automata). KCG \nhas a classical architecture: a front-end with several steps of type-check, a middle-end performing a \nscheduling and transla\u00adtion of the equational and temporal source language into an im\u00adperative intermediate \nlanguage, and a back-end which generates a bunch of C .les. It also contains several optimization passes. \nA par\u00adticularity of KCG compared to other compilers resides in its ability to ensure a maximum of traceability \nbetween the input model and the generated C program. KCG is speci.ed in a 500 page document containing \nmore than a thousand high-level requirements: one third of them describe the functional requirements \nof the tool, the others explain the semantics of the input language. 3 In the sequel OCaml compiler will \ndesign the INRIA OCaml compiler 4 www.surlog.com The high-level requirements that specify the static \nand dynamic semantics of the Scade language involve logical inference rules. The distance between such \na form of requirements and a program written in ML is small and the implementation is very routine, even \nstraightforward for some parts. Indeed: the functional abstraction and the modularity of OCaml are high-level \nenough to be used as architectural requirements (di\u00adrect traceability).  the extensive usage of algebraic \ndata types and pattern matching meets the algorithmic description.  this functional architecture based \non well identi.ed compiler phases allows an independent validation of each pass.  As any modern functional \nlanguage, OCaml bene.ts from a compiler that produces trustable applications, safer than most of the \nmainstream languages which require to make use of dedicated veri.cation tools. In particular, the safety \nof its static typing allows to skip some veri.cations that would be mandatory with other languages: among \nthe most evident are the memory allocation, coherency, initialization checks, which are no longer relevant \nand can therefore be omitted when using OCaml. The OCaml code is compact, which allows to concentrate \nthe veri.cation efforts on the real dif.culties, i.e. the algorithmic ones, and very little efforts are \ndevoted to data encoding or resource management issues. On the other hand, some of the high-level constructs \nof this pro\u00adgramming language may have a bad incidence on the veri.cation activities. We decided not \nto support the complete OCaml language, and thus forbade or restricted the usage of the most complex \nparts: the object-oriented paradigm is not used for the reason that the control it offers is very dif.cult \nto manage statically,  modules and functors constructions are allowed but without some unnecessary constructs \nsuch as the manifest types and other artifacts,  exceptions and higher-order constructions are restricted \nby spe\u00adci.c coding rules to avoid complex behaviors that would other\u00adwise be hard to verify.  While \nusing OCaml in a development process has undeniable advantages, it remains to answer the speci.c requirements \nof the safety-critical software context. This point is addressed in the two following sections. 4. Code \nCoverage for OCaml programs An OCaml program such as KCG uses two kinds of library code: the OCaml standard \nlibrary, written mainly in OCaml, and the run\u00adtime library, written in C and assembly language. Both \nare shipped with the OCaml compiler and linked with the .nal executable. The dif.culty of specifying \nand testing such low-level library code led us to adapt and simplify it. The bulk of the modi.cations \nof the runtime library was to remove unessential features according the coding standard of KCG. In particular, \nthe support for concurrency and serialization was removed. Most of the work consisted in simplifying \nthe ef.cient but complex memory management subsystem. We successfully replaced it by a plain Stop&#38;Copy \ncollector with a reasonable loss of performance. As most of the standard library is written in plain \nOCaml, its certi.cation is no more dif.cult than that of any OCaml application. Regarding the OCaml part, \nwe developed a tool, called mlcov5, capable of measuring the MC/DC rate of OCaml programs. The tool .rst \nallows to create an instrumented version of the source code that handles a trace .le. Running the instrumented \nexecutable then 5 http://www.esterel-technologies.com/technology/free-software/  leads to (incremental) \nupdate of the counters and structures of the trace .le. Finally, the coverage results are presented through \nHTML reports generated from the trace .le. MC/DC for OCaml sources Since OCaml is an expression lan\u00adguage, \nwe have to address the coverage of expression evaluation: we state that an expression has been covered \nas soon as its eval\u00aduation has ended. Expressions are instrumented with a mark al\u00adlowing to record by \nside-effect that this point of the program has been reached. Some constructions of the OCaml language \n(such as if then else) may introduce several execution branches. Cov\u00aderage of expressions entails tracing \nthe evaluation of each one of the branches independently. These transformations are detailed in (Pagano \net al. 2008). The mlcov implementation The mlcov tool is built on top of the front-end of the OCaml compiler. \nFor our speci.c purposes, a .rst pass is done, prior to the instrumentation stage, in order to reject \nOCaml programs that do not comply with the coding standard of KCG. The .gure 2 shows a source code annotated \naccording to test programs: conditions in light gray ful.ll the MC/DC criterion, while those in dark \ngray are not completely covered. And the .gure 3 gives the structural coverage and MC/DC statistics for \nthese tests. Figure 2. Annoted source code Performance Results Performances are good enough for code \ncoverage analysis since this activity mainly consists in applying a lot of pretty small examples targeting \nspeci.c requirements. 5. Traceability from sources to binaries A DO-178B level A software development \nimposes to give evi\u00addence about the trustability of the tools and compilers used in the process. To reach \nthis goal, we expertized the OCaml compiling process in order to set up hints for the traceability from \nthe source code to the object code. On the basis of this expertise, among other required documentation, \ntest sets have been produced and are part of the bunch of documents for the certi.cation of KCG. We present \nin this section the guidelines of this study, mainly focused on two points: the safe management of system \ncalls and the traceability of control .ow. Figure 3. Coverage rates Actually, not only does the executed \nobject code of an OCaml program consist of the generated code but also includes some ser\u00advice assembly \ncode, the runtime library and the so-called standard OCaml libraries. All those components are linked \ntogether at the end of the compilation step. As noticed in section 4, the set of OCaml libraries had \nbeen slightly simpli.ed to keep only the ones written in OCaml, thus it falls under the regular treatment \nof pieces of OCaml code. The run\u00adtime library, developed in C, is mainly concerned with garbage col\u00adlection. \nA little static assembly code provides mechanisms for ex\u00adternal calls to memory management C functions \nand for exception handling. As for any OCaml application, when compiling KCG, an ad hoc piece of assembly \ncode is generated to set the optimized mechanism of functional application of OCaml. The code for all \nthe standard and runtime libraries used in KCG is reasonably compact, especially after the drastic simpli.cation \nof the GC. External calls are well con.ned in small static assembly code and no use of the libc library \ncan escape from it. So, ful.lling the two requirements cited above (traceability and safe management \nof system calls) for this part of OCaml programs can be done by following the usual process. To deal \nwith the generated code, we .rst bene.ted from the facts that the source code of the OCaml compiler is \nopen and its functional architecture designs a clear process of re.ning step by step the intermediate \nlanguages, from the abstract syntax tree to the assembly code. The OCaml compilation is itself traceable \nin the sense that all the intermediate rewritings of the source program can be pretty-printed. It is \nnotable that the bootstrapped OCaml compiler itself naturally offers the traceability facilities that \nwere intentionally designed for the KCG code generator (see section 3). It is possible to stop the OCaml \ncompiling process after the emission of assembly code. Then, one can assemble by hand and link all the \ncomponents, using the same command as the one the compiler would have used, and .nally obtain the same \nexecutable as the one the full compiling process would have produced. As a consequence, it is enough \nto establish traceability from source code to assembly code: a test set can consist in a piece of OCaml \ncode as input and its corresponding piece of assembly code as expected output. At this level of the expertise, \nthree main points had to be taken into consideration: the translation of explicit controls of the source \ncode, including pattern matching and exception handling;  the controls introduced by the compiler itself \nwhich are indeed few and have been tracked;  the so called primitive functions which may either be translated \nto assembly language or generate calls to external functions.  Concerning the .rst point, rather than \nan unfeasible full correct\u00adness test of the OCaml compiler, we proceeded to a review of its design principles, \ndeep enough to set a methodology able to ensure the above intended properties of the compiler for a given \nOCaml application (restricted to the coding standard of the project). Concerning the second point, a \ndetailed review of the code led us to enumerate the few occurrences where tests are generated: memory \nallocation, call to the GC, division by 0, access to array or string elements and the mechanism of functional \napplication. In each case, either one can design test sets to cover them, or the branching may stop the \nprogram in a safe state6. Concerning the third point, all the primitives actually appear in the intermediate \nlambda code and an exhaustive study of their appearance in the generated assembly code has been performed. \n6. Conclusion In the .eld of safety-critical avionics software, the mainstream programming languages \nare exclusively C and ADA. Even to de\u00advelop tools, which are not embedded themselves but which are used \nto implement embedded applications, the usage of object-oriented programming languages as Java or C++ \nis not considered relevant due to the complexity of their control .ow. The restrictions needed to develop \nsafety-critical Java/C++ software remove all the features that differentiate OOP languages than C/ADA. \nAt the very beginning of the project, using OCaml instead of C was a challenge; the point was to have \na programming language closer to the functional speci.cations but further away from the ex\u00adecutable program. \nThe main risk resided in the problems that could have been met to show the traceability between the different \nlevels of speci.cations and the binary resulting from the compilation of a highly functional and polymorphic \nsource code. This project has shown that this was not an issue thanks to the good traceability of the \nOCaml compiler and its compilation schemes. Another risk was to express and reach a full code coverage \nwith respect to the MC/DC measure. It was managed by the develop\u00adment of a tool and the performing of \na classic test campaign, which revealed neither longer nor more expensive than the previous ex\u00adperiences \nof code coverage involving code generators written in C code. The additional cost of development of a \nspeci.c tool (mlcov) is balanced by a gain when qualifying as a veri.cation tool a soft\u00adware that is \ncompletely designed for our purpose. The new KCG, developed with OCaml, is certi.ed with respect to the \nIEC 61508 and EN 50128 norms. It is used in several civil avionics DO-178B projects (such as the A380 \nAirbus plane, for in\u00adstance) and will be quali.ed simultaneously to the project quali.ca\u00adtions (with \nthe DO-178B, the tools are not quali.ed by themselves, but by their usage in a project). The project \nhas been accomplished with the expected delays and costs. The software consists in 65k lines of OCaml \ncode, including a lexer and a parser, plus 4k lines of C code for the runtime library. The development \nteam was com\u00adposed of 6 software engineers and 8 test engineers during almost 2 years. It is a real DO-178B \nproject, yet with only one singularity compared to other tool development in this certi.cation framework: \nthe use of OCaml as the main programming language. There are others industrial usages of OCaml in some \nbig com\u00adpanies in the .eld of embedded avionics systems and they have an increasing interest on the usage \nof this kind of language for build\u00ad 6 This is not acceptable for embedded code, but it is for development \ntools in the sense that it ensures that no faulty code will ever be silently produced. ing software engineering \ntools. In the transportation domain, Prover Technology also provides certi.able solutions for automating \nveri\u00ad.cation activities. To meet a high level of certi.cation (SIL 4 in IEC 61508 standard) required \nby these applications, a diversi.ed imple\u00admentation of some software modules present in the toolchains. \nThis diversi.cation consists in having two implementations each using its own implementation technology \nand comparing the result. For this purpose, OCaml has been chosen jointly with the mainstream C language. \nThis different approach of certi.cation is another op\u00adportunity for functional languages. The main result \nfor the ICFP community is that the use of our fa\u00advorite languages to build compilers is starting to be \nwell understood and accepted by industrial processes and certi.cation authorities in the context of software \nengineering tools. We can be optimistic to see that, in the middle of all the mainstream (and ef.cient \nfor other purposes) languages, there is a room for functional technologies and culture. References G\u00b4The \nEffectiveness of Synchronous Languages for the erard Berry. Development of Safety-Critical Systems. Technical \nreport, Esterel-Technologies, 2003. Jean-Louis Camus and Bernard Dion. Ef.cient Development of Air\u00adborne \nSoftware with SCADE SuiteTM . Technical report, Esterel-Technologies, 2003. Jean-Louis Colac\u00b8o and Marc \nPouzet. Clocks as First Class Abstract Types. In Third International Conference on Embedded Software \n(EM-SOFT 03), Philadelphia, Pennsylvania, USA, oct 2003. Jean-Louis Colac\u00b8o, Bruno Pagano, and Marc Pouzet. \nA Conservative Extension of Synchronous Data-.ow with State Machines. In ACM International Conference \non Embedded Software (EMSOFT 05), Jersey city, New Jersey, USA, sep 2005. P. Cousot, R. Cousot, J. Feret, \nL. Mauborgne, A. Min\u00b4e, D. Monniaux, and X. Rival. The astr\u00b4 ee analyser. In European Symposium on Programming. \nLNCS, April 2005. ECMA. ECMA-367: Eiffel analysis, design and programming language. ECMA (European Association \nfor Standardizing Information and Com\u00admunication Systems), pub-ECMA:adr, June 2005. N. Halbwachs, P. \nCaspi, P. Raymond, and D. Pilaud. The synchronous data.ow programming language lustre. In Proceedings \nof the IEEE, pages 1305 1320, 1991. Kelly J. Hayhurst, Dan S. Veerhusen, John J. Chilenski, and Leanna \nK. Rierson. A Practical Tutorial on Modi.ed Condition/Decision Coverage. Technical report, NASA/TM-2001-210876, \nMay 2001. Xavier Leroy, Damien Doligez, Jacques Garrigue, Didier Rmy, and Jrme Vouillon. The Objective \nCaml system, documentation and user s manual release 3.11. INRIA, December 2008. URL http://caml.inria.fr/pub/docs/manual-ocaml/. \nBruno Pagano, Olivier Andrieu, Benjamin Canou, Emmanuel Chailloux, Jean-Louis Colao, Thomas Moniot, and \nPhilippe Wang. Certi.ed de\u00advelopment tools implementation in objective caml. In Paul Hudak and David \nScott Warren, editors, Tenth International Symposium on Practi\u00adcal Aspects of Declarative Languages (PADL), \nvolume 4902 of Lecture Notes in Computer Science, pages 2 17. Springer, 2008. Marc Pouzet. Lucid Synchrone \nversion 3.0 : Tutorial and Reference Man\u00adual, 2006. (www.lri.fr/%7Epouzet/lucid-synchrone). The Coq Development \nTeam LogiCal Project. The Coq Proof Assistant Reference Manual, 2006. (coq.inria.fr/V8.1beta/refman). \nRTCA/DO-178B. Software Considerations in Airborne Systems and Equip\u00adment Certi.cation. Radio Technical \nCommission for Aeronautics RTCA, pages 31,74, December 1992.   \n\t\t\t", "proc_id": "1596550", "abstract": "<p>High-level tools have become unavoidable in industrial software development processes. Safety-critical embedded programs don't escape this trend. In the context of safety-critical embedded systems, the development processes follow strict guidelines and requirements. The development quality assurance applies as much to the final embedded code, as to the tools themselves. The French company Esterel Technologies decided in 2006 to base its new SCADE SUITE 6TM certifiable code generator on Objective Caml. This paper outlines how it has been challenging in the context of safety critical software development by the rigorous norms DO-178B, IEC 61508, EN 50128 and such.</p>", "authors": [{"name": "Bruno Pagano", "author_profile_id": "81100622646", "affiliation": "Esterel Technologies, Toulouse, France", "person_id": "P1614025", "email_address": "", "orcid_id": ""}, {"name": "Olivier Andrieu", "author_profile_id": "81442596407", "affiliation": "Esterel Technologies, Elancourt, France", "person_id": "P1614026", "email_address": "", "orcid_id": ""}, {"name": "Thomas Moniot", "author_profile_id": "81442613291", "affiliation": "Esterel Technologies, Elancourt, France", "person_id": "P1614027", "email_address": "", "orcid_id": ""}, {"name": "Benjamin Canou", "author_profile_id": "81372593722", "affiliation": "LIP6 - Universite UPMC, Paris, France", "person_id": "P1614028", "email_address": "", "orcid_id": ""}, {"name": "Emmanuel Chailloux", "author_profile_id": "81100622511", "affiliation": "LIP6 - Universite UPMC, Paris, France", "person_id": "P1614029", "email_address": "", "orcid_id": ""}, {"name": "Philippe Wang", "author_profile_id": "81442611554", "affiliation": "LIP6 - Universite UPMC, Paris, France", "person_id": "P1614030", "email_address": "", "orcid_id": ""}, {"name": "Pascal Manoury", "author_profile_id": "81548018674", "affiliation": "PPS - Universite UPMC, Paris, France", "person_id": "P1614031", "email_address": "", "orcid_id": ""}, {"name": "Jean-Louis Cola&#231;o", "author_profile_id": "81100608108", "affiliation": "Prover Technologies S.A.S, Toulouse, France", "person_id": "P1614032", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596582", "year": "2009", "article_id": "1596582", "conference": "ICFP", "title": "Experience report: using objective caml to develop safety-critical embedded tools in a certification framework", "url": "http://dl.acm.org/citation.cfm?id=1596582"}