{"article_publication_date": "08-31-2009", "fulltext": "\n Generic Programming with Fixed Points for Mutually Recursive Datatypes Alexey Rodriguez Yakushev1 Stefan \nHoldermans2 Andres L\u00a8oh2 Johan Jeuring2,3 1Vector Fabrics B.V., Paradijslaan 28, 5611 KN Eindhoven, The \nNetherlands 2Department of Information and Computing Sciences, Utrecht University, P.O. Box 80.089, 3508 \nTB Utrecht, The Netherlands 3School of Computer Science, Open University of the Netherlands, P.O. Box \n2960, 6401 DL Heerlen, The Netherlands alexey.rodriguez@gmail.com {stefan,andres,johanj}@cs.uu.nl Abstract \nMany datatype-generic functions need access to the recursive posi\u00adtions in the structure of the datatype, \nand therefore adopt a .xed point view on datatypes. Examples include variants of fold that traverse the \ndata following the recursive structure, or the Zipper data structure that enables navigation along the \nrecursive posi\u00adtions. However, Hindley-Milner-inspired type systems with alge\u00adbraic datatypes make it \ndif.cult to express .xed points for anything but regular datatypes. Many real-life examples such as abstract \nsyn\u00adtax trees are in fact systems of mutually recursive datatypes and therefore excluded. Using Haskell \ns GADTs and type families, we describe a technique that allows a .xed-point view for systems of mutually \nrecursive datatypes. We demonstrate that our approach is widely applicable by giving several examples \nof generic functions for this view, most prominently the Zipper. Categories and Subject Descriptors D.1.1 \n[Programming Tech\u00adniques]: Applicative (Functional) Programming; D.2.13 [Software Engineering]: Reusable \nSoftware Reusable libraries; D.3.3 [Pro\u00adgramming Languages]: Language Constructs and Features Data types \nand structures General Terms Design, Languages 1. Introduction One of the most ubiquitous activities \nin software development is structuring data. Indeed, many programming methods and devel\u00adopment tools \ncenter around the creation of datatypes (or XML schemas, UML models, classes, grammars, et cetera). Once \nthe structure of the data has been decided on, a programmer adds func\u00adtionality to the datatypes. Here, \nthere is always some functional\u00adity that is speci.c to a datatype and part of the reason that the datatype \nhas been designed in the .rst place. Other functionality is, however, generic and similar or even the \nsame on many datatypes. Classic examples of such generic functionality are testing for equal\u00adity, ordering, \nparsing, and pretty printing. Implementing generic functionality can be tiresome and, there\u00adfore, error-prone: \nit involves adapting and applying the same high- Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. ICFP 09, August 31 September 2, 2009, Edinburgh, Scotland, UK. \nCopyright c &#38;#169; 2009 ACM 978-1-60558-332-7/09/08. . . $5.00 level programming patterns to different \ndatatypes, time and time again. Datatype-generic programming alleviates this burden by en\u00adabling programmers \nto write generic functions, i.e., functions that are de.ned once, but that can be used on many different \ndatatypes. Over the years, a vast body of work has emerged on adding support for datatype-generic programming \nto mainstream func\u00adtional programming languages, most notably Haskell (Peyton Jones 2003). While early \nproposals encompassed extending the under\u00adlying language with dedicated new constructs for generic pro\u00adgramming \n(Jansson and Jeuring 1997; Hinze 2000a,b), recent ap\u00adproaches favour the de.nition of generic functions \nin Haskell itself using Haskell s advanced type-class system (Cheney and Hinze 2002; Hinze 2004; L\u00a8 ammel \nand Peyton Jones 2003). The various approaches to generic programming generally dif\u00adfer in the expressivity \nof the generic functions that can be de.ned and the classes of datatypes that are supported. The most \npromi\u00adnent example is that quite a number of generic functions operate on the recursive structure of \ndatatypes, but most approaches do not provide access to the recursive positions in a datatype s def\u00adinition. \nThe approaches that do provide access to these recursive positions are limited in the sense that they \nonly apply to a re\u00adstricted set of datatypes. In particular, the full recursive structure of families \nof mutually recursive datatypes is beyond the reach of these approaches. Still, many real-life applications \nof functional programming do involve mutually recursive datatypes, arguably the most striking example \nbeing the representation of abstract syn\u00adtax trees in compilers. Moreover, the generic functions that \narise in such applications typically require access to the full recursive structure of these types; examples \ninclude navigation (Huet 1997; Hinze et al. 2004; McBride 2008), uni.cation (Jansson and Jeuring 1998), \nrewriting (Jansson and Jeuring 2000; Van Noort et al. 2008), and pattern matching (Jeuring 1995) and, \nmore generally, recursion schemes such as fold and the like (Meijer et al. 1991) and down\u00adwards accumulations \n(Gibbons 2000). In this paper, we present an approach to datatype-generic pro\u00adgramming embedded in Haskell \nthat does enable the de.nition of generic functions over the full recursive structure of mutually re\u00adcursive \ndatatypes. Speci.cally, our contributions are the following: We show how to generalise the encoding \nof regular datatypes as .xed points of functors (reviewed in Section 2) to arbitrary families of mutually \nrecursive types. We make use of a single higher-order .xed point operator (Section 3).  The functors \nfor families of mutually recursive datatypes can be constructed from a small set of combinators, thereby \nenabling datatype-generic programming (Section 4).   We present several applications of generic programming \nin this setting, most notably the Zipper for mutually recursive types in Section 5 and generic rewriting \nin Section 6. Related work is presented in Section 7, and future work and con\u00adclusions in Section 8. \nA strength of our approach is that it can be readily implemented in Haskell, making use of language extensions \nsuch as type fami\u00adlies (Schrijvers et al. 2008) and GADTs (Peyton Jones et al. 2006). The multirec and \nzipper libraries that are based on this paper can be obtained from HackageDB. 2. Fixed points for representing \nregular datatypes Let us .rst review generic programming using .xed points for regular datatypes. While \nthis is well-known, it serves not only as an introduction to the terminology we are using, but also as \na template for our introduction of the more general case for families of mutually recursive types in \nSection 4. A functor is a type constructor of kind *.* for which we can de.ne a map function. Fixed points \nare represented by an instance of the Fix datatype: data Fix f = In {out :: (f (Fix f))} Haskell s record \nnotation is used to introduce the selector function out :: Fix f . f (Fix f). 2.1 De.ning a pattern functor \ndirectly Using Fix, we can represent the following datatype for simple arithmetic expressions data Expr \n= Const Int | Add Expr Expr | Mul Expr Expr by its pattern functor: data PFExpr r = ConstF Int | AddF \nrr | MulF rr type Expr' = Fix PFExpr The types Expr and Expr' are isomorphic, and in Haskell we can \nwitness this isomorphism by instantiating a class class Regular a where deepFrom :: a . Fix (PF a) deepTo \n:: Fix (PF a) . a  where type family PF a :: *.* The type family PF is an open type-level function \nmapping a regular type a of kind * to its pattern functor PF a of kind *.*. We can instantiate it by \nsaying type instance PF Expr = PFExpr The functions deepFrom and deepTo are straightforward to de.ne. \nIn practice, converting between a datatype and its .xed-point repre\u00adsentation occurs often when programming \ngenerically, and travers\u00ading the whole value as required by deepFrom and deepTo is often more work than \nis actually required. We therefore present an alternative correspondence, making use of the isomorphism \na = Fix (PF a) ~=(PF a) a ~=(PF a)(Fix (PF a)) ~ This means that we relate a to its one-layer unfolding \nPF a a (a shallow conversion). We rede.ne class Regular to use the following conversion functions from \nand to: class Regular a where from :: a . PF a a to :: PF a a . a  As before, in the instance for expressions, \ninstance Regular Expr where from = fromExpr to = toExpr  the shallow conversion functions fromExpr and \ntoExpr are trivial to de.ne. In order to establish that PFExpr really is a functor, we make it an instance \nof class Functor: instance Functor PFExpr where fmap f (ConstF i)= ConstF i fmap f (AddF ee')= AddF (fe)(fe') \nfmap f (MulF ee')= MulF (fe)(fe')  Given fmap, many recursion schemes can be de.ned, for example: fold \n:: (Regular a,Functor (PF a)) . (PF a r . r) . (a . r) fold f = f . fmap (fold f) . from unfold :: (Regular \na,Functor (PF a)) . (r . PF a r) . (r . a) unfold f = to . fmap (unfold f) . f  Note how the conversions \nin the class Regular allow us to work with the original datatype Expr rather than its .xed point represen\u00adtation \nExpr', but it is easy to de.ne the deep conversion functions. For instance, fold In turns a regular datatype \na into its .xed-point representation Fix (PF a). Another recursion scheme we can de.ne is compos (Bringert \nand Ranta 2006). Much like fold, it traverses a data structure and performs operations on the children. \nThere are different variants of compos, the simplest is equivalent to PolyP s mapChildren (Jans\u00adson and \nJeuring 1998): it applies a function of type a . a to all children. This parameter is also responsible \nfor performing the re\u00adcursive call, because compos itself is not recursive: compos :: (Regular a,Functor \n(PF a)) . (a . a) . a . a compos f = to . fmap f . from  2.2 Building functors systematically The approach \npresented above still requires us to write fmap by hand for every datatype. Furthermore, other applications \nsuch as navigation or rewriting require functions de.ned on the pattern functor that cannot directly \nbe derived from fmap. Thus, having to write fmap and such other functions manually for each datatype \nis undesirable. Fortunately, it is also unnecessary. In the following, we present a .xed set of datatypes \nthat can be used to construct pattern functors systematically: data Ka r = K a data Ir = I r data (f \n:\u00d7: g) r = fr :\u00d7: gr data (f :+: g) r = L (fr) | R (gr) in.xr 7:\u00d7: in.xr 6:+:  The type K is used to \nrepresent occurrences of constant types, such as Int and Bool in the Expr example. The type I represents \nrecursive positions. Using :\u00d7:, we can combine different .elds of a constructor, and with :+:, we can \ncombine constructors. Using the above datatypes, we can thus represent the pattern functor of Expr as \nfollows: type PFExpr = K Int :+: (I :\u00d7: I) :+: (I :\u00d7: I) type Expr' = Fix PFExpr  Datatypes, such as \nExpr, whose recursive structure can be repre\u00adsented by a polynomial functor (consisting of sums, products \nand constants) are often called regular datatypes. The uniform encod\u00ading allows us to de.ne functions \nthat work on all regular datatypes. In particular, we can now de.ne a generic map function by declar\u00ading \nthe following instances of the class Functor: class Functor f where fmap :: (a . b) . fa . fb instance \nFunctor I where fmap f (Ix)= I (fx) instance Functor (Ka) where fmap (Kx)= Kx instance (Functor f,Functor \ng) . Functor (f :+: g) where fmap f (Lx)= L (fmap f x) fmap f (Ry)= R (fmap f y) instance (Functor f,Functor \ng) . Functor (f :\u00d7: g) where fmap f (x :\u00d7: y)= fmap f x :\u00d7: fmap f y With these declarations, we obtain \nfmap on PFExpr for free. Simi\u00adlarly, we get fmap on all datatypes as long as we express them as .xed \npoints of pattern functors using K, I,:\u00d7: and :+:. Using fmap, we get fold, unfold and compos for free \non all these datatypes. By providing one structural representation of a datatype (the instantia\u00adtions \nof PF and Regular), we gain access to a multitude of powerful functions, and can easily de.ne more. Being \nable to convert between the original datatype such as Expr and the .xed point Expr ' or the one-layer \nunfolding PF Expr Expr now becomes much more important, because for application-speci.c, non-generic \nfunctions, we want to be able to use the original constructor names rather than sequences of con\u00adstructor \napplications for the representation. This is re.ected in the fact that the conversion functions fromExpr \nand toExpr, while still being entirely straightforward, now become more verbose. Here is fromExpr as \nan example: fromExpr :: Expr . PF Expr Expr fromExpr (Const i)= L (Ki) fromExpr (Add ee')= R (L (Ie :\u00d7: \nIe')) fromExpr (Mul e e')= R (R (Ie :\u00d7: Ie')) To facilitate the conversion, some generic programming \nlanguages automatically generate mappings that relate datatypes such as Expr with their structure representation \ncounterparts (Expr ') (Jansson and Jeuring 1997; L\u00a8 oh 2004; Holdermans et al. 2006). In this case if \nwe do not want to extend the compiler we can use a meta-programming tool such as Template Haskell (Sheard \nand Peyton Jones 2002) to generate the PF and Regular instances for a datatype. 3. Fixed points for mutually \nrecursive datatypes In Section 2, we have shown how we can generically program with regular datatypes \nby expressing them as .xed points of functors. In practice, one often has to deal with large families \nof mutually recursive datatypes, which are not regular. As an example, consider the following extended \nversion of our Expr datatype: data Expr = Const Int | Add Expr Expr | Mul Expr Expr | EVar Var | Let \nDecl Expr data Decl = Var := Expr | Seq Decl Decl type Var = String We now have two datatypes that \nare mutually recursive, Expr and Decl. Both make use of a third type Var. In order to deal with families \nsuch as this representation of an abstract syntax tree, we will now demonstrate how to generalize the \nrepresentation of datatypes as .xed points of functors to such families. 3.1 Fixed points for a speci.c \nnumber of datatypes Swierstra et al. (1999) have shown how to represent a family of two mutually recursive \ntypes as a .xed point in Haskell. The idea is to introduce a different .xed point datatype that abstracts \nover bifunctors of kind *.*.* rather than functors of kind *.*: data Fix2 fg = In2 (f (Fix2 fg)(Fix2 \ngf)) We can easily generalize this idea further and de.ne Fix3, Fix4 and so on. Depending on whether \nwe want to count Var as a full member of our abstract syntax tree family or not, we can then use either \nFix2 or Fix3 to represent such a family as a .xed point of functors. The problem, however, is that we \ncan also no longer use I, K,:+: and :\u00d7: to construct functors for arbitrary families systematically. \nInstead, it turns out that we require new variants of I, K,:+: and :\u00d7: for each arity. In the end, we \nhave to rework our entire generic programming machinery for each arity of family we want to support, \ndefeating the very purpose of generic programming. Furthermore, families of datatypes can be very large, \nand we cannot hope that supporting a limited amount of arities will suf.ce in practice. 3.2 A uniform \nway to represent .xed points At .rst, it looks like we cannot easily abstract over the arities of .xed-points \nin Haskell. However, it is well-known that an n-tuple of types can be encoded as a function taking an \nindex (between 0 and n - 1) to a type. In other words, we have an isomorphism between the kinds *n and \nn .* provided that n is a kind with exactly n different inhabitants. Let us apply this idea to .xed points. \nA .xed point of a single datatype is given by Fix :: (*.*) .* For a family of two datatypes, we need \ntwo applications of Fix2 :: (*.*.*) . (*.*.*) .* which modulo currying is the same as Fix2 :: (*2 .*)2 \n.* For a family of n datatypes, we need n applications of Fixn :: (*n .*)n .* or a single application \nof Fixn :: ((*n .*)n .*)n Applying the isomorphism between *n and n .*, we get Fixn :: n . (n . ((n \n.*) .*)) .* Reordering the arguments reveals that we have really generalized from a .xed point for kind \n* to a .xed point for n .*: Fixn :: ((n .*) . (n .*)) . (n .*) Apart from the fact that n is not available \nin Haskell s kind system, we now have a uniform representation of a .xed-point combina\u00adtor that is suitable \nto express arbitrary families of datatypes. Fortu\u00adnately, the remaining gap is easy to bridge, as we \nshow in the next section. 4. Indexed .xed points in Haskell After having presented the idea of how to \nget a uniform representa\u00adtion of .xed points, we are now going to explain how to make use of this idea \nin Haskell. We develop a library for generic program\u00adming with families of mutually recursive types much \nin the same style as we did in Section 2 for regular datatypes. We are going to use the family of abstract \nsyntax trees from the introduction of Section 3 as our running example. 4.1 Encoding indexed .xed points \nin Haskell s kind system First, we have to .nd a way to encode n in Haskell s kind system, where n is \nsupposed to be a kind that has exactly n types as inhabitants. Haskell offers just one base kind, namely \n*, so we are left with little choice. However, we can simply approximate n by * in Haskell, as long as \nwe promise to instantiate * with only n different types. In practice, if we have a family . with n different \ntypes, we use the types in the family themselves as the indices to instantiate such positions of *. In \nthis paper, we will write *. rather than * for such positions in order to make it more explicit that \nwe are using a virtual subkind of * that only consists of the members of family .. Thus, our uniform \n.xed-point combinator now has kind HFix :: ((*. .*) . (*. .*)) . (*. .*) and can be de.ned in Haskell \nas data HFix (f :: (*. .*) . (*. .*)) (ix :: *. )= HIn (f (HFix f) ix)  In our abstract syntax tree \nexample, we have a family that we choose to call AST with three different types, and we are going to \nwrite * AST for the subkind of * consisting only of the types Expr, Decl, and Var. We go even further \nand introduce a family-speci.c GADT (that we also call .) and de.ne it such that a value of . ix can \nserve as a proof that ix is a type that belongs to .. Whenever we quantify over a variable of kind *. \n, we will pass such a value of type . ix to make explicit that we quantify over a limited set of types. \nFor the example, we introduce the GADT data AST :: * AST .* where Expr :: AST Expr Decl :: AST Decl Var \n:: AST Var  such that a value of AST ix serves as a proof that ix is a member of the AST family. One \nexample where we make use of explicit proofs is when de.ning a map function for higher-order functors. \nSince the type has changed, we have to de.ne a new class class HFunctor (. :: *. .*) (f :: (*. .*) . \n(*. .*)) where hmap :: (.ix.. ix . r ix . r ' ix) . . ix . f rix . fr ' ix The function hmap has a rank-2 \ntype. The function that is mapped is quanti.ed over all members ix of family .. If for every index ' \n ix in ., this function transforms an r ix into an r ix, then we can transform a functor with recursive \ncalls given by r into a functor ' with recursive calls given by r . It is perhaps instructive to note \nthat if . is a family consisting of only one type, there will be only one choice for . ix, and the type \nof hmap reduces to the type of fmap for regular functors. Instead of using explicit proofs of type . \nix, it is sometimes helpful to use a type class class El (. :: *. .*)(ix :: *. ) where proof :: . ix \n and then use an implicit class constraint El . ix instead of a value of type . ix. For the AST family, \nwe de.ne the following instances: instance El AST Expr where proof = Expr instance El AST Decl where \nproof = Decl instance El AST Var where proof = Var  4.2 De.ning a pattern functor directly Before we \ndiscuss how to represent functors of families generically, let us show how we can represent our family \nfor abstract syntax trees as a .xed point in terms of HFix directly. The functor for AST can be de.ned \nas follows: data PFAST :: (* AST .*) . (* AST .*) where ConstF :: Int . PFAST r Expr AddF :: r Expr . \nr Expr . PFAST r Expr MulF :: r Expr . r Expr . PFAST r Expr EVarF :: r Var . PFAST r Expr LetF :: r \nDecl . r Expr . PFAST r Expr BindF :: r Var . r Expr . PFAST r Decl SeqF :: r Decl . r Decl . PFAST r \nDecl VF :: String . PFAST r Var  The parameter r is used to denote a recursive call. At each recursive \nposition, we apply r to the appropriate index in order to indicate the type we recurse on. Furthermore, \neach constructor of the functor targets a speci.c member of the family. By using HFix on the pattern \nfunctor, we obtain types that are isomorphic to the original family: type Expr ' = HFix PFAST Expr type \nDecl ' = HFix PFAST Decl type Var ' = HFix PFAST Var  The isomorphisms can be witnessed by conversion \nfunctions once more, and for this purpose, we declare a class Family that corre\u00adsponds to Regular: class \nFamily . where from :: . ix . ix . PF . I* ix to :: . ix . PF . I* ix . ix type family PF (. :: *. .*) \n:: (*. .*) . (*. .*) Like in the class Regular, we decide to implement a shallow con\u00adversion rather \nthan a deep conversion. Note that all conversion functions take a . ix as .rst argument, as proof that \nix is indeed a member of .. In the pattern functor, we have to describe the type of the recursive positions \nby means of a datatype of kind *. .*. The one-layer unfolding uses the original datatypes of the family \nin the recursive positions, and we express this by choosing I*: data I* (ix :: *. )= I*{unI* :: ix} \nThe type I* behaves as the identity on types so that recursive occurrences inside the functor are stored \nas is . Although the de.nition of I* is essentially the same as that of I in Section 2, we give it a \ndifferent name to highlight that we are using it conceptually at kind *. .* rather than kind *.*, even \nthough the two kinds coincide in the Haskell code. Here is the Family instance of AST: type instance \nPF AST = PFAST instance Family AST where from = fromAST to = toAST  The functions fromAST and toAST \nare straightforward and not given here. We can now go on to de.ne a HFunctor instance and sub\u00adsequently \nrecursion schemes such as fold and unfold for PFAST. However, since we strive for programming generically \nwith fami\u00adlies of datatypes, we want to avoid having to de.ne HFunctor man\u00adually for our family. Instead, \nwe will try as we have before in Section 2 to build our functor systematically from a .xed set of datatypes. \n 4.3 Building functors systematically It turns out that we can use almost the same datatypes as before \nto represent functors. The datatypes K,:\u00d7:, and :+: can be lifted from being parameterized over an r \nof kind * to being parameterized over an r of kind *. .* and an index ix of kind *. : data Ka (r :: *. \n.*)(ix :: *. )= K a data (f :+: g)(r :: *. .*)(ix :: *. )= L (f rix) | R (g r ix) data (f :\u00d7: g)(r :: \n*. .*)(ix :: *. )= f rix :\u00d7: g r ix The type I has been used to represent a recursive call. In the current \nsituation, recursive calls can be to a speci.c index in the family. Therefore, I gets an additional argument \nxi :: *. that is used to determine the recursive call to make: data I (xi :: *. )(r :: *. .*)(ix :: *. \n)= I (r xi) It is perhaps surprising that xi is different from ix. But where ix projects out a certain \nmember of the family, the type of the recursive call is independent of the type we are ultimately interested \nin. In fact, we have not yet used the parameter ix anywhere. If we look at the direct de.nition of PFAST, \nwe see that depending on the index we choose to project out of the functor, we get different functors. \nOnly the .rst .ve constructors of PFAST contribute to PFAST r Expr, for example. We introduce another \ncombinator for pattern functors in order to express such constraints on the index: in.x 6:e: data (f \n:e: (xi :: *. )) (r :: *. .*)(ix :: *. ) where Tag :: f rxi . (f :e: xi) r xi  By tagging a functor \nwith an index from the family, we make explicit that the tagged part only contributes to the structure \nof that particular member of the family. We now have all the combinators we need to give a structural \nrepresentation of the AST pattern functor: type PFAST = K Int :e: Expr :+: --Const (I Expr :\u00d7: I Expr) \n:e: Expr :+: --Add (I Expr :\u00d7: I Expr) :e: Expr :+: --Mul I Var :e: Expr :+: --EVar (I Decl :\u00d7: I Expr) \n:e: Expr :+: --Let (I Var :\u00d7: I Expr) :e: Decl :+: --:= (I Decl :\u00d7: I Decl) :e: Decl :+: --Seq K String \n:e: Var --V To match the structure of the direct de.nition of PFAST more closely, we have chosen to \ntag the representation of every construc\u00adtor with the index it targets. Alternatively, we could have \ntagged the sum of all constructors of a type just once. If we use the structural version of PFAST in \nthe Family in\u00adstance, we have to adapt the conversion functions. Again, these are straightforward, but \nlengthy. We only show fromAST: fromAST :: AST ix . ix . PFAST I* ix fromAST Expr (Const i)= L (Tag (Ki)) \nfromAST Expr (Add ee')= R (L (Tag (ci e :\u00d7: ci e'))) fromAST Expr (Mul ee')= R (R (L (Tag (ci e :\u00d7: ci \ne')))) fromAST Expr (EVar x)= R (R (R (L (Tag (ci x))))) fromAST Expr (Let d e)= R (R (R (R (L (Tag (ci \nd :\u00d7: ci e)))))) fromAST Decl (x := e)= R (R (R (R (R (L (Tag (ci x :\u00d7: ci e))))))) fromAST Decl (Seq \nd d')= R (R (R (R (R (R (L (Tag (ci d :\u00d7: ci d')))))))) fromAST Var x = R (R (R (R (R (R (R (Tag (Kx)))))))) \nci x = I (I* x)  4.4 Generic hmap We still have to establish that our new functor combinators are actually \nhigher-order functors themselves: instance El . xi . HFunctor . (I xi) where hmap f (Ix)= I (f proof \nx) instance HFunctor . (Ka) where hmap f (Kx)= Kx instance (HFunctor . f,HFunctor . g) . HFunctor . \n(f :+: g) where hmap f p (Lx)= L (hmap f p x) hmap f p (Ry)= R (hmap f p y) instance (HFunctor . f,HFunctor \n. g) . HFunctor . (f :\u00d7: g) where hmap f p (x :\u00d7: y)= hmap f p x :\u00d7: hmap f p y instance HFunctor . f \n. HFunctor . (f :e: ix) where hmap f p (Tag x)= Tag (hmap f p x) Despite our generalization, the code \nfor hmap looks almost com\u00adpletely identical to the code for fmap. We need an additional, but trivial \ncase for (:e:). A slight change occurs in the case for I, where we additionally have to require that \nthe recursive call is actually in our family via El . xi, to be able to pass the required proof to the \nmapped function f. 4.5 Generic compos Using hmap, it is easy to de.ne compos: compos :: (Family .,HFunctor \n. (PF .)) . (.ix.. ix . ix . ix) . . ix . ix . ix compos f p = to p . hmap (. p . I*. fp . unI*) p . \nfrom p The only differences to the version in Section 2 are due to the presence of explicit proof terms \nof type . ix and because the actual values in the structure are now wrapped in applications of the I* \nconstructor. Bringert and Ranta (2006) describe in their paper on compos how to de.ne the function on \nfamilies of mutually recursive datatypes. Their solution, however, requires to modify the fam\u00adily of \ndatatypes and rewrite them as a single GADT. Our version of compos works on families of mutually recursive \ndatatypes without modi.cation. As an example use of compos, consider the following expres\u00adsion: example \n= Let (\"x\" := Mul (Const 6)(Const 9)) (Add (EVar \"x\")(EVar \"y\")) The following function renames all variables \nin example note how renameVar' can use the type representation to take different actions for different \nnodes in this case, .lter out nodes of type Var. renameVar :: Expr . Expr renameVar = renameVar' Expr \nwhere renameVar' :: AST a . a . a renameVar' Var x = x ++ \"_\" renameVar' px = compos renameVar' px The \ncall renameVar example yields: Let (\"x_\" := Mul (Const 6)(Const 9)) (Add (EVar \"x_\")(EVar \"y_\"))  \n4.6 Generic fold We can also de.ne fold using hmap. Again, the de.nition is very similar to the single-datatype \nversion: type Algebra . r = .ix.. ix . PF . r ix . r ix fold :: (Family .,HFunctor . (PF .)) . Algebra \n. r . . ix . ix . r ix fold f p = fp . hmap (. p (I* x) . fold f p x) p . from p  Using fold is slightly \ntrickier than using compos, because we have to construct a suitable argument of type Algebra. This algebra \nar\u00adgument involves a function operating on the pattern functor, which is itself a generically derived \ndatatype. We therefore have to write a function that destructs a sum of products, where the .elds in \nthe products are wrapped by occurrences of K or I. It is much more natural to de.ne an algebra by giving \none function per construc\u00adtor, with the functions taking as many arguments as there are .elds, preferably \neven in a curried style. This problem is not caused by having families of many datatypes. The generic \nprogramming language PolyP (Jansson and Jeuring 1997) has a special ad-hoc construct that helps in de.ning \nalgebras in a convenient style. We can do better: in the following, we will de.ne a type-indexed datatype \n(Hinze et al. 2004) for algebras, as a type family inductively de.ned over the structure of functors. \nWe can then de.ne algebras in a convenient style, and use them in a generic fold. The type-indexed datatype \nAlg is de.ned as follows: type family Alg (f :: (*. .*) .*. .*) (r :: *. .*)(ix :: *) :: * type instance \nAlg (Ka) r ix = a . r ix type instance Alg (I xi) r ix = r xi . r ix type instance Alg (f :+: g) r ix \n=(Algf rix,Alg g r ix) type instance Alg (Ka :\u00d7: g) r ix = a . Alg g r ix type instance Alg (I xi :\u00d7: \ng) r ix = r xi . Alg g r ix type instance Alg (f :e: xi) r ix = Algf rxi The de.nition shows how we \nwant to de.ne our algebras: Oc\u00adcurrences of K and I are unwrapped. An algebra on a sum is a pair of algebras \non the components. In the product case, we make use of knowledge on how datatypes are built: products \nare always nested to the right, and the left components are always .elds, either wrapped by K or I. Hence, \nwe can give two cases that allow us to turn algebras on a product into curried functions. The case for \ntags simply recurses. We then have to show that we can transform such a more convenient algebra into \nthe form that fold expects. To this end, we de.ne the generic function apply: class Apply (f :: (*. .*) \n.*. .*) where apply :: Algf rix . f rix . r ix instance Apply (K a) where apply f (Kx)= fx instance Apply \n(I xi) where apply f (Ix)= fx instance (Apply f,Apply g) . Apply (f :+: g) where apply (f,g)(Lx)= apply \nf x apply (f,g)(Rx)= apply g x instance Apply g . Apply (K a :\u00d7: g) where apply f (Kx :\u00d7: y)= apply \n(fx) y instance Apply g . Apply (I xi :\u00d7: g) where apply f (Ix :\u00d7: y)= apply (fx) y instance Apply f \n. Apply (f :e: xi) where apply f (Tag x)= apply f x We can further facilitate the construction of algebras \nby de.ning an in.x operator for pairing: in.xr 1&#38; (&#38;)=(,) As an example, let us specify an evaluator \non our abstract syntax tree types using an algebra. Because different types in our family are mapped \nto different results, we need another family of datatypes for the result type of our algebra: data family \nValue a :: * data instance Value Expr = EV (Env . Int) data instance Value Decl = DV (Env . Env) data \ninstance Value Var = VV Var type Env = [(Var,Int)]  An environment maps variables to integers. Expressions \ncan con\u00adtain variables, we therefore interpret them as functions from en\u00advironments to integers. Declarations \ncan be seen as environment transformers. Variables evaluate to their names. We can now state the algebra: \nevalAlg :: Algebra AST Value evalAlg = const (apply ( (. x . EV (const x)) &#38; (. (EV x) (EV y) . EV \n(. m . x m + y m)) &#38; (. (EV x) (EV y) . EV (. m . x m * y m)) &#38; (. (VV x) . EV (fromJust . lookup \nx)) &#38; (. (DV e) (EV x) . EV (. m . x (e m))) &#38; (. (VV x) (EV v) . DV (. m . (x,v m) : m)) &#38; \n(. (DV f) (DV g) . DV (g . f)) &#38; (. x . VV x))) --Const --Add --Mul --EVar --Let --:= --Seq --V Testing \neval :: Expr . Env . Int eval x = let (EV f) = fold evalAlg Expr x in f in the expression eval example \n[(\"y\",-12)] yields 42. 4.7 Summary We have now introduced a library for generic programming on families \nof mutually recursive types. The library consists of the type family PF, the classes Family and El, and \nthe functor constructors I, K,:+:, :\u00d7:, and :e:. Furthermore, the library contains classes and instances \nfor a number of generic functions, such as all the HFunctor code, the de.nitions of compos, fold and \nunfold. To use the library for a speci.c family a user has to do the following: de.ne a GADT such as \nAST, instantiate the type family PF to the pattern functor, and construct Family and El instances. This \nmay still seem a signi.cant amount of work, but all of this code is entirely straightforward and can \neasily be automated. In fact, we have implemented the generation of most of this boilerplate code in \nTemplate Haskell, so that only the de.nition of the GADT and a call to a Template Haskell function remains. \nOnce the library is instantiated, all generic functions that are provided by the library are available \nfor this family without any further work. 5. The Zipper For a tree-like datatype, the Zipper (Huet 1997) \nis a derived data structure that allows ef.cient navigation through a tree, along its recursive nodes. \nAt every moment, the Zipper keeps track of a location: a point of focus paired with a context that represents \nthe rest of the tree. The focus can be moved up, down, left, and right. For regular datatypes, it is \nwell-known how to de.ne Zippers generically (Hinze et al. 2004). In the following, we .rst show how to \nde.ne a Zipper for a system of mutually recursive datatypes us\u00ading our example of abstract syntax trees \n(Section 5.1). Then, in Sec\u00adtion 5.2, we give a generic algorithm in terms of the representations introduced \nin Section 4.3. 5.1 Zipper for mutually recursive datatypes We .rst give a non-generic presentation of \nthe Zipper for abstract syntax trees as de.ned in Section 3. A location is the current focus paired with \ncontext information. In a setting with multiple types, the type of the focus ix is not known hence, we \nmake it existential, and carry around a representation of type AST ix: data LocAST :: * AST .* where \nLoc :: AST ix . ix . CtxsAST a ix . LocAST a  The type CtxsAST encodes context information for the focus \nas a path from the focus to the root of the full tree. The path is stored in a stack of context frames: \ndata CtxsAST :: * AST .*AST .* where Nil :: CtxsAST aa Cons :: CtxAST ix b . CtxsAST a ix . CtxsAST ab \n A context stack of type CtxsAST ab represents a value of type a with a b-typed hole in it. More speci.cally, \na stack consists of frames of type CtxAST ix b that represent constructor applications that yield an \nix-value with a hole of type b in it. The full tree that is represented by a location can be recovered \nby plugging the value in focus into the topmost context frame, plugging the resulting value into the \nnext frame, and so on. For this to work, the target type ix of each context frame must be equal to the \ntype of the hole in the remainder of the stack as enforced by the type of Cons. 5.1.1 Contexts A single \ncontext frame CtxAST is following the structure of the types in the AST system closely. data CtxAST :: \n* AST .*AST .* where AddC1 :: Expr . CtxAST Expr Expr AddC2 :: Expr . CtxAST Expr Expr MulC1 :: Expr \n. CtxAST Expr Expr MulC2 :: Expr . CtxAST Expr Expr EVarC :: CtxAST Expr Var LetC1 :: Expr . CtxAST Expr \nDecl LetC2 :: Decl . CtxAST Expr Expr BindC1 :: Expr . CtxAST Decl Var BindC2 :: Var . CtxAST Decl Expr \nSeqC1 :: Decl . CtxAST Decl Decl SeqC2 :: Decl . CtxAST Decl Decl  The relation between CtxAST and AST \nbecomes even more pro\u00adnounced if we also look at the directly de.ned pattern functor PFAST from Section \n4.2. For every constructor in PFAST, we have as many constructors in CtxAST as there are recursive positions. \nWe can descend into a recursive position. The type of the recursive position then becomes the type of \nthe hole, the second argument of CtxAST. The other components of the original constructor are stored \nin the context. As an example, consider: Let :: Decl . Expr . Expr LetF :: r Decl . r Expr . PFAST r \nExpr We have two recursive positions. If we descend into the .rst, then Decl is the type of the hole, \nwhile Expr remains and so we get LetC1 :: Expr . CtxAST Expr Decl If, however, we descend into the \nsecond position, then Expr is the type of the hole with Decl remaining: LetC2 :: Decl . CtxAST Expr Expr \n 5.1.2 Navigation We now de.ne functions that move the focus, transforming a loca\u00adtion into a new location. \nThese functions return their result in the Maybe monad, because navigation may fail: we cannot move down \nfrom a leaf of the tree, up from the root, or right if there are no more siblings in that direction. \nMoving down analyzes the current focus. For all constructors that do not build leaves, we descend into \nthe leftmost child by making it the new focus, and by pushing an appropriate frame onto the context stack. \nFor leaves, we return Nothing. down :: LocAST ix . Maybe (LocAST ix) down (Loc Expr (Add e e') cs)= Just \n(Loc Expr e (Cons (AddC1 e') cs)) down (Loc Expr (Mul e e') cs)= Just (Loc Expr e (Cons (MulC1 e') cs)) \ndown (Loc Expr (EVar x) cs)= Just (Loc Var x (Cons EVarC cs)) down (Loc Expr (Let d e) cs)= Just (Loc \nDecl d (Cons (LetC1 e) cs)) down (Loc Decl (x := e) cs)= Just (Loc Var x (Cons (BindC1 e) cs)) down (Loc \nDecl (Seq d d') cs)= Just (Loc Decl d (Cons (SeqC1 d') cs)) down = Nothing  The function right succeeds \nfor nodes that actually have a right sibling. The size of the context stack remains unchanged: we just \nreplace its top element with a new frame. right :: LocAST ix . Maybe (LocAST ix) right (Loc e (Cons (AddC1 \ne') cs)) = Just (Loc Expr e' (Cons (AddC2 e) cs)) right (Loc e (Cons (MulC1 e') cs)) = Just (Loc Expr \ne' (Cons (MulC2 e) cs)) right (Loc d (Cons (LetC1 e) cs)) = Just (Loc Expr e (Cons (LetC2 d) cs)) right \n(Loc x (Cons (BindC1 e) cs)) = Just (Loc Expr e (Cons (BindC2 x) cs)) right (Loc d (Cons (SeqC1 d') cs)) \n= Just (Loc Decl d' (Cons (SeqC2 d) cs)) right = Nothing  The function left is very similar to right. \nFinally, the function up is applicable whenever the current focus is not the root of the tree, i.e., \nwhenever the context stack is non-empty. We then analyze the top context frame and plug in the old focus, \nyielding the new focus, and retain the rest of the context. The de.nition is omitted for reasons of space. \n 5.1.3 Using the Zipper To use the Zipper, we need functions to turn syntax trees into locations, and \nback again. For manipulating trees, we provide an update operation that replaces the subtree in focus. \nTo enter the tree, we place it into the empty context: enter :: AST ix . ix . LocAST ix enter p e = Loc \np e Nil  To leave, we move up as far as possible and then return the expres\u00adsion in focus. leave :: \nLocAST Expr . Expr leave (Loc e Nil)= e leave loc = leave (fromJust (up loc)) To update the tree, we \npass in a function capable of modifying the current point of focus. Because the value in focus can have \ndifferent types, this function needs to be parameterized by the type representation. update :: (.ix.AST \nix . ix . ix) . LocAST Expr . LocAST Expr update f (Loc p x cs)= Loc p (fpx) cs As an example, we modify \nthe multiplication in example = Let (\"x\" := Mul (Const 6)(Const 9)) (Add (EVar \"x\")(EVar \"y\"))  To combine \nthe navigation and edit operations, it is helpful to make use of .ipped function composition (>>>) :: \n(a . b) . (b . c) . (a . c) and monadic composition (>=>)::Monad m . (a . mb) . (b . mc) . (a . mc). \nThe call enter Expr >>> down >=> down >=> right >=> update solve >>> leave >>> return $ example with \nsolve :: AST ix . ix . ix solve Expr = Const 42 solve x = x results in Just (Let (\"x\" := Const 42)(Add \n(EVar \"x\")(EVar \"y\")))  5.2 A generic Zipper We now de.ne a Zipper generically for a system of mutually \nre\u00adcursive datatypes. We make the same steps as in the example for abstract syntax trees before. The \ntype de.nitions for locations and context stacks stay essen\u00adtially the same: data Loc :: (*. .*) .*. \n.* where Loc :: (Family .,Zipper . (PF .)) . . ix . ix . Ctxs . a ix . Loc . a data Ctxs :: (*. .*) \n.*. .*. .* where Nil :: Ctxs . aa Cons :: . ix . Ctx (PF .) ix b . Ctxs . a ix . Ctxs . ab Instead of \na speci.c proof term AST ix, we now store a generic proof term . ix for an arbitrary family in a location. \nAdditionally, we need a Zipper for the system .. This condition is expressed by Zipper (PF .) and will \nbe explained in more detail below. In the stack Ctxs, we also require that the types of the elements \nare in . via the .eld . ix. 5.2.1 Contexts The context type is de.ned generically on the pattern functor \nof .. We thus reuse the type family PF de.ned in Section 3. We have to distinguish between different \ntype constructors that make up the pattern functor, and therefore de.ne Ctx as a datatype family: data \nfamily Ctx f :: *. .*. .* Like the context stack, a context frame is parameterized over both the type \nof the resulting index and the type of the hole. The simple cases are for constant types, sums and products. \nThere is a correspondence between the context of a datatype and its formal derivative (McBride 2001): \ndata instance Ctx (Ka) ix b = CK Void data instance Ctx (f :+: g) ix b = CL (Ctxf ixb) | CR (Ctx g ix \nb) data instance Ctx (f :\u00d7: g) ix b = C1 (Ctxf ixb)(gI* ix) | C2 (fI* ix)(Ctx g ix b) For constants, \nthere are no recursive positions, hence we produce an empty datatype, i.e., a datatype with no constructors: \ndata Void For a sum, we are given either an f or a g, and compute the context of that. For a product, \nwe can descend either left or right. If we descend into f, we pair a context for f with g. If we descend \ninto g, we pair f with a context for g. We are left with the cases for I and (:e:). According to the \nanalogy with the derivative, the context of the identity should be the unit type. However, we are in \na situation where there are multiple types involved. The type index of I .xes the type of the hole. We \nexpress this type equality as follows, by means of a GADT:1 data instance Ctx (I xi) ix b where CId :: \nCtx (I xi) ix xi  For the case of tags, we have a similar situation. A tag does not affect the structure \nof the context, it only provides information for the type system. In this case, not the type of the hole, \nbut the type of the context itself is required to match the type index of the tag: data instance Ctx \n(f :e: xi) ix b where CTag :: Ctxf xib . Ctx (f :e: xi) xi b  This completes the de.nition of Ctx. We \ncan convince ourselves that instantiating Ctx to PF AST results in a datatype that is iso\u00admorphic to \nCtxAST. It is also quite a bit more complex than the hand-written variant, but fortunately, the programmer \nnever has to use it directly. Instead, we can interface with it using generic navi\u00adgation functions. \n 5.2.2 Navigation The navigation functions are again generically de.ned on the struc\u00adture of the pattern \nfunctor. Thus, we de.ne them in a class Zipper: class Zipper . f where ... We will .ll this class with \nmethods incrementally. Down To move down in a tree, we de.ne a generic function .rst in our class Zipper: \nclass Zipper . f where ... .rst :: (.b.. b . b . Ctxf ixb . a) . fI* ix . Maybe a  The function takes \na functor fI* ix and tries to split off its .rst recursive component. This is of some type b where we \nknow . b. The rest is a context of type Ctxf ixb. The function takes a continuation parameter that describes \nwhat to do with the two parts. Function down is de.ned in terms of .rst: down :: Loc . ix . Maybe (Loc \n. ix) down (Loc p x cs)= ' .rst (. p zc . Loc p' z (Cons p c cs)) (from p x) We try to split the tree \nin focus x. If this succeeds, we get a new focus z and a new context frame c. We push c on the stack. \n1 Currently, GHC does not allow instances of datatype families to be de.ned as GADTs. In the actual implementation, \nwe therefore simulate the GADT by including an explicit proof of type equality (Peyton Jones et al. 2006; \nBaars and Swierstra 2002). We de.ne .rst by induction on the structure of pattern functors. Constant \ntypes constitute the leaves in the tree. We cannot descend, and return Nothing. instance Zipper . (Ka) \nwhere ... .rst f (Ka)= Nothing In a sum, we descend further, and add the corresponding context constructor \nCL or CR to the context. instance (Zipper . f,Zipper . g) . Zipper . (f :+: g) where ... .rst f (Lx)= \n.rst (. pzc . fpz (CL c)) x .rst f (Ry)= .rst (. pzc . fpz (CR c)) y We want to get to the .rst child. \nTherefore, we .rst try to descend to the left in a product. Only if that fails (mplus), we try to split \nthe right component. instance (Zipper . f,Zipper . g) . Zipper . (f :\u00d7: g) where ... .rst f (x :\u00d7: y)= \n.rst (. pzc . fpz (C1 c y)) x mplus .rst (. pzc . fpz (C2 x c)) y  In the I case, we have exactly one \npossibility. We split I (I* x) into x and the context CId and pass the two parts to the continuation \nf: instance El . xi . Zipper . (I xi) where ... .rst f (I (I* x)) = return (f proof x CId) It is interesting \nto see why this is type correct: the type of x is xi, so applying f to x instantiates b to xi and forces \nthe .nal argument of f to be of type Ctx (I xi) ix xi. But that is exactly the type of CId. Finally, \nfor a tag, we also descend further and apply CTag to the context. instance Zipper . f . Zipper . (f :e: \nxi) where ... .rst f (Tag x)= .rst (. pzc . fpz (CTag c)) x This is type correct because Tag introduces \nthe re.nement that CTag requires: applying CTag to c results in Ctx (f :e: xi) xi b. This can be passed \nto f only if ix from the type of .rst is equal to xi. But it is, because the pattern match on Tag forces \nit to be. Up Now that we can move down, we also want to move up again. We employ the same scheme as before: \nusing an inductively de.ned generic helper function .ll, we then de.ne up. The function .ll has the following \ntype: class Zipper . f where ... .ll :: . b . b . Ctxf ixb . fI* ix The function takes a value together \nwith a compatible context frame and plugs them together, producing a value of the pattern functor. This \noperation is total, so no Maybe is required in the result. With .ll, we can de.ne up as follows: up :: \nLoc . ix . Maybe (Loc . ix) up (Loc p x Nil)= Nothing up (Loc p x (Cons p' c cs)) = Just (Loc p' (to \np ' (.ll p x c)) cs) We cannot move up in the root of the tree and thus fail on an empty context stack. \nOtherwise, we pick the topmost context frame, and call .ll. Since .ll results in a value of the pattern \nfunctor, we have to convert back into the original form using to. We start the de.nition of .ll with \nthe case for K. As an argument to .ll, we need a context for K, for which we de.ned but one constructor \nCK with a Void parameter. In other words, in order to call .ll on K, we have to produce a value of Void, \nwhich, apart from ., is impossible. In the context of our Zipper library, we can guarantee that . is \nnever produced for Void. We therefore de.ne: instance Zipper . (Ka) where ... .ll p x (CK void)= impossible \nvoid impossible :: Void . a impossible void = error \"impossible\"  The de.nition of .ll is very straight-forward: \nfor I, we return the element to plug itself; for (:e:) and (:+:), we call .ll recursively. In the case \nfor products, we recurse into the context: instance (Zipper . f,Zipper . g) . Zipper . (f :\u00d7: g) where \n... .ll p x (C1 c y)= .ll p x c :\u00d7: y .ll p y (C2 x c)= x :\u00d7: .ll p y c Right As a .nal example of a \nnavigation function, we de.ne right. We again employ the same scheme as before. We de.ne a generic function \nnext with the following type: class Zipper . f where ... next :: (.b.. b . b . Ctxf ixb . a) . (. b . \nb . Ctxf ixb . Maybe a)  The function takes a context frame and an element that .ts into the context. \nBy looking at the context, it tries to move the focus one element to the right, thereby producing a new \nelement possibly of different type and a new compatible context. These can, as in .rst, be combined \nusing the passed continuation. With next, we can de.ne right: right :: Loc . ix . Maybe (Loc . ix) right \n(Loc p x Nil)= Nothing right (Loc p x (Cons p' c cs)) = ' next (. pzc '. Loc p z (Cons p' c cs)) pxc \n We cannot move right in the root of the tree, thus right fails in an empty context. Otherwise, we only \nneed to look at the topmost context frame, and pass it to next, together with the current focus. On success, \nwe take the new focus, and push the new context frame back on the stack. Most cases of next are without \nsurprises: calling next for K is again impossible; in sums and on tags we recurse. Since an I indicates \na single child a leaf in the tree we cannot move right from there and return Nothing. The most interesting \ncase is the case for products. If we are currently in the .rst component, we try to move to the next \nelement there, but if this fails, we have to select the .rst child of the second component, calling .rst. \nIn that case, we also have to plug the old focus x back into its context c, using .ll. If, however, we \nare already in the right component, we do not need a case distinction and just try to move further to \nthe right using next. instance (Zipper . f,Zipper . g) . Zipper . (f :\u00d7: g) where ... next f p x (C1 \nc y)= ' next (. p zc '. fp' z (C1 c' y )) pxc ' mplus .rst (. p zc '. fp' z (C2 (.ll p x c) c ')) y next \nf p y (C2 x c)= ' next (. p zc '. fp' z (C2x c ')) pyc  5.2.3 Using the Zipper The functions enter, \nleave and update can be converted from the speci.c case for AST almost without change. The code is exactly \nas before, we only have to adapt the types. enter :: (Family ., Zipper . (PF .)) . . ix . ix . Loc . \nix enter p x = Loc p x Nil leave :: Loc . ix . ix leave (Loc p x Nil)= x leave loc = leave (fromJust \n(up loc)) update :: (.ix.. ix . ix . ix) . Loc . ix . Loc . ix update f (Loc p x cs)= Loc p (fpx) cs \n Let us repeat the example from before, but now use the generic Zip\u00adper: apart from the additional argument \nto enter, nothing changes enter Expr >>> down >=> down >=> right >=> update solve >>> leave >>> return \n$ example and the result is also the same: Just (Let (\"x\" := Const 42)(Add (EVar \"x\")(EVar \"y\"))) 6. \nGeneric rewriting Term rewriting can be speci.ed generically, for arbitrary regular datatypes, if these \nare viewed as .xed points of functors (Jansson and Jeuring 2000,Van Noort et al. 2008). In the following \nwe show how to generalize term rewriting even further, to work on families with an arbitrary number of \ndatatypes. For reasons of space, we do not discuss generic rewriting in complete detail, but focus on \nthe operation of matching the left-hand side of a rule with a term. 6.1 Schemes of regular datatypes \nBefore tackling matching on families of mutually recursive data\u00adtypes, we brie.y sketch the ideas behind \nits implementation on regular datatypes. Consider how to implement matching for the simple version of \nthe Expr datatype introduced in Section 2. First, we de.ne expression schemes, which extend expressions \nwith a constructor for rule meta-variables. Then we de.ne matching of those schemes against expressions: \ndata ExprS = MetaVar String | ConstS Int | AddS ExprS ExprS | MulS ExprS ExprS match :: ExprS . Expr \n. Maybe [(String, Expr)] On success, match returns a substitution mapping meta-variables to matched \nsubterms. For example, the call match (MulS (MetaVar \"x\")(MetaVar \"y\")) (Mul (Const 6)(Const 9))  yields \nJust [(\"x\",Const 6),(\"y\",Const 9)]. To implement match generically, we need to de.ne the scheme of a \ndatatype generically. To this end, recall that a regular datatype is isomorphic to the type Fix f, for \na suitably de.ned f. A meta\u00advariable can appear deep inside a scheme, this suggests that the extension \nwith MetaVar should take place inside the recursion, and hence on f. This motivates the following de.nition \nfor schemes of regular datatypes: type Scheme a = Fix (K String :+: PF a) For example, the expression \nscheme that is used above as the .rst argument to match can be represented by In (R (R (R (I (In (L (K \n\"x\"))) :\u00d7: I (In (L (K \"y\")))))))  6.2 Schemes of a datatype family and substitutions A family of mutually \nrecursive datatypes requires as many sorts of meta-variables as there are datatypes. For example, for \nthe family used in Section 3, we need three meta-variables, ranging over Expr, Decl and Var, respectively. \nFortunately, we can deal with all these meta-variables in one go: type Scheme . = HFix (K String :+: \nPF .) As in the regular case, the pattern functor is extended with a meta\u00advariable representation. We \nwant meta-variable representations to be polymorphic, so, unlike other constructors, K String is not \ntagged with (:e:). Now, the same representation can be used to encode meta-variables that match, for \nexample, Expr, Decl and Var. Dealing with multiple datatypes affects the types of substi\u00adtutions. We \ncannot use a homogeneous list of mappings as we did earlier, because different meta-variables may map \nto different datatypes. We get around this dif.culty by existentially quantifying over the type of the \nmatched datatype: data DynIx . = .ix.DynIx (. ix) ix type Subst . = [(String,DynIx .)]  6.3 Generic \nmatching Generic matching is de.ned as follows: type MatchM s a = StateT (Subst s) Maybe a matchM :: \n(Family .,HZip . (PF .)) . . ix . Scheme . ix . I* ix . MatchM . () matchM p (HIn (L (K metavar))) (I* \ne) = do subst . get case lookup metavar subst of Nothing . put ((metavar, DynIx pe) : subst) Just . fail \n(\"repeated use: \" ++ metavar) matchM p (HIn (Rr)) (I* e) = combine matchM r (from p e) Generic matching \ntries to match a term of type I* ix against a scheme of corresponding type Scheme . ix. The resulting \ninforma\u00adtion is returned in the MatchM monad. The de.nition of MatchM uses Maybe for indicating possible \nfailure, and on top of that monad we use the state transformer StateT. The state monad is used to thread \nthe substitution as we traverse the scheme and the term in parallel. The class HZip, which contains functionality \nfor zipping, is introduced in the following subsection. Generic matching consists of two cases. When \ndealing with a meta-variable, we .rst check that there is no previous mapping for it. (For the sake of \nbrevity, we do not show how to deal with multiple occurrences of a meta-variable.) If that is the case, \nwe update the state with the new mapping. The second case deals with matching constructors against constructors. \nMore speci.\u00adcally, this corresponds to matching Mul (Const 6)(Const 9) against MulS (MetaVar \"x\")(MetaVar \n\"y\"). This is handled by the generic function combine, which matches the two pattern functor representations. \nIf the representations match (as in our example), then matchM is applied to the recursive occurrences \n(for instance, on MetaVar \"x\" and Const 6, and MetaVar \"y\" and Const 9). Now we can write the following \nwrapper on matchM to hide the use of the state monad that threads the substitution: match :: (Family \n.,HZip . (PF .)) . . ix . Scheme . ix . ix . Maybe (Subst .) match p scheme tm = execStateT (matchM p \nscheme (I* tm)) []  6.4 Generic zip and combine The generic function combine is de.ned in terms of a \nanother function, which is a generalization of zipWith for arbitrary functors. Like hmap, the function \nhzipM is de.ned by induction on the pattern functor by means of a type class: class HZip . f where hzipM \n:: Monad m . (.ix.. ix . r ix . r ' ix . m (r '' ix)) . f rix . fr ' ix . m (fr '' ix)  ' The function \nhzipM takes an argument that combines the r and r structures stored in the pattern functor. The traversal \nis performed in a monad to notify failure when the functor arguments do not match, and to allow the argument \nto use state, for example. In the case of combine, we are not interested in the resulting '' merged \nstructure (r ix). Indeed, matchM stores information only in the state monad, so we de.ne combine to ignore \nthe result. data K* ab = K*{unK* :: a} combine :: (Monad m, HZip . f) . (.ix.. ix . r ix . r ' ix . m \n()) . f rix . fr ' ix . m () combine f x y = do hzipM wrapf x y return () where wrapf p x y = do fpxy \nreturn (K* ())  In the above, K* is used to ignore the type ix in the result. The de.nition of hzipM \ndoes not differ much from that used when dealing with a single regular datatype: instance El . xi . HZip \n. (I xi) where hzipM f (Ix)(Iy)= liftM I (f proof x y) instance (HZip . a, HZip . b) . HZip . (a :\u00d7: \nb) where hzipM f (x1 :\u00d7: x2)(y1 :\u00d7: y2) = liftM2 (:\u00d7:)(hzipM f x1 y1)(hzipM f x2 y2) instance (HZip . \na, HZip . b) . HZip . (a :+: b) where hzipM f (Lx)(Ly)= liftM L (hzipM f x y) hzipM f (Rx)(Ry)= liftM \nR (hzipM f x y) hzipM f = fail \"zip failed in :+:\" instance HZip . f . HZip . (f :e: ix) where hzipM \nf (Tag x)(Tag y)= liftM Tag (hzipM f x y) instance Eq a . HZip . (Ka) where hzipM f (Kx)(Ky) | x = y \n= return (Kx) | otherwise = fail \"zip failed in K\" In the de.nition above, we use liftM and liftM2 to \nturn the pure structure constructors into monadic functions. 7. Related work Malcolm (1990) shows how \nto de.ne two mutually recursive types as initial objects of functor-algebras. Swierstra et al. (1999) \nshow how to implement .xed points for mutual recursive datatypes in Haskell. They introduce a new .xed \npoint for every arity of mutu\u00adally recursive datatypes. None of these approaches can be used as a basis \nfor an implementation of .xed points for mutually recursive datatypes in Haskell suitable for implementing \ngeneric programs. Higher-order .xed points like our HFix have been used by Bird and Paterson (1999) and \nJohann and Ghani (2007) to model folds on nested datatypes. Several authors discuss how to generate folds \nand other re\u00adcursive schemes on mutually recursive datatypes (B\u00a8ohm and Be\u00adrarducci 1985; Sheard and \nFegaras 1993; Swierstra et al. 1999; L\u00a8ammel et al. 2000). Again, the de.nitions in these papers can\u00adnot \nbe directly generalised to families of arbitrary many datatypes in Haskell. Mitchell and Runciman (2007) \nshow how to obtain traversals for mutually recursive datatypes using the class Biplate. However, the \ntype on which an action is performed remains .xed during a traversal. In contrast, the recursion schemes \nfrom Section 4.4 can apply their function arguments to subtrees of different types. Since dependently \ntyped programming languages have a much more powerful type system than Haskell extended with GADTs and \ntype families, it is possible to de.ne .xed-points for mutually recursive datatypes in many dependently \ntyped programming lan\u00adguages. Benke et al. (2003) give a formal construction for mutually recursive datatypes \nas indexed inductive de.nitions in Alfa. Some similarities with our work are that the pattern functor \nargument is indexed by the datatype sort, and recursive positions specify the sort index of the subtree. \nAltenkirch and McBride (2003) show how to do generic programming in the dependently typed programming \nlanguage OLEG. We believe that it is easier to write generic pro\u00adgrams on mutually recursive datatypes \nin our approach, since we do not have to deal with kind-indexed de.nitions, environments, type applications, \ndatatype variables and argument variables, in addition to the cases for sums, products and constants. \nMcBride (2001) .rst described a generic Zipper on regular datatypes, which was implemented in Epigram \nby Morris et al. (2006). The Zipper has been used as an example of a type-indexed datatype in Generic \nHaskell (Hinze et al. 2004), but again only for regular datatypes. The dissection operator introduced \nby McBride (2008) is also only de.ned for regular datatypes, although McBride remarks that an implementation \nin a dependently typed program\u00adming language for mutually recursive datatypes is possible. In most other \ngeneric programming approaches, recursion is not explicitly represented and types occurring at such positions \ncannot be changed. Such approaches cannot be used to de.ne the examples in this paper. For example SYB \n(L\u00a8ammel and Peyton Jones 2003) and EMGM (Oliveira et al. 2006) cannot be used to de.ne fold. In fold, \nthe algebra function is applied to constructor .elds where the recursive positions have been replaced \nby the carrier of the algebra. However, in these approaches, values at recursive positions cannot be \ntransformed into values of other types. PolyLib (Norell and Jansson 2004) supports the de.nition of fold, \nbut it is limited to regular datatypes. A similar argument can be made for type\u00adindexed types. Generic \napproaches that support type-indexed types (Oliveira and Gibbons 2005) need to represent recursion explicitly \nin order to de.ne the Zipper and generic rewriting. 8. Conclusions Until now, many powerful generic algorithms \nwere known, but their adoption in practice has been hindered by their restriction to regular datatypes. \nIn this paper, we have shown that we can overcome this restriction in a way that is directly applicable \nin practice: using recent extensions of Haskell, we can de.ne generic programs that exploit the recursive \nstructure of datatypes on families of arbitrarily many mutually recursive datatypes. For instance, extensive \nuse of generic programming becomes .nally feasible for compilers, which are often based on an abstract \nsyntax that consists of many mutually recursive datatypes. Furthermore, our approach is non\u00adinvasive: \nthe de.nitions of large families of datatypes need not be modi.ed in order to use generic programming. \nAdditionally, we have demonstrated our approach by imple\u00admenting several recursion schemes such as compos \nand fold, the Zipper, and rewriting functionality. Based on this paper, the libraries multirec and zipper \nhave been developed. They are available for download from HackageDB. A version of the rewriting library \nbased on multirec will be released soon. The multirec library contains Template Haskell code to auto\u00admatically \ngenerate the boilerplate code for a family of datatypes. Also, in addition to the functionality shown \nhere, the library offers access to the names of constructors. Furthermore, in this paper we have focused \non functions that consume or transform values rather than functions that produce values. This, however, \nis no limitation, and we have for instance implemented a function that generates val\u00adues of a particular \ntype according to certain criteria using multirec. Initial measurements indicate that our approach is \nin the slower half of generic programming libraries for Haskell. On the other hand, some benchmarked \nfunctions expose signi.cant optimisation opportunities to GHC. In one such example, GHC optimisations \nremoved the intermediate use of generic values leaving code that is similar to what one would write manually. \nAs a result, this example runs only 1.7 times slower than handwritten code (compared to 68.7 for the \nslowest library). More details can be found in the thesis of Rodriguez (2009). In its current form, \nour approach cannot be used directly on parameterized types and does not support functor composition. \nWe have, however, prototypical code that demonstrates that our approach can be extended to support these \nconcepts without too much dif.culty, and we plan to integrate this functionality into the library in \nthe near future. We plan to study the application of our representation using (:e:) to arbitrary GADTs, \nhopefully giving us fold and other generic operations on GADTs, as in the work of Johann and Ghani (2008). \nIn parallel to the Haskell version, we have also experimented with an Agda (Norell 2007) version of our \nlibrary, using dependent types. The Agda version has proved to be invaluable in thinking about the development \nwithout having to worry about Haskell lim\u00aditations at the same time. As to Haskell, we hope that the \nsupport for type families, which we rely on very much, will continue to sta\u00adbilize in the future, and \nthat perhaps the kind system will be slightly improved with possibilities to encode kinds such as our \n*. , or with the possibility to de.ne kind synonyms. Acknowledgements Jos\u00b4e Pedro Magalh aes and Marcos \nViera commented on a previous version of this paper. Claus Reinke sug\u00adgested to us the type families \ndesugaring trick to get around a problem with the type checker in an older version of GHC. The anonymous \nreviewers have provided several useful suggestions for improving the presentation. This research has \nbeen partially funded by the Netherlands Organisation for Scienti.c Research (NWO), through its projects \non Real-life Datatype-Generic Programming (612.063.613) and Scriptable Compilers (612.063.406). References \nT. Altenkirch and C. McBride. Generic programming within dependently typed programming. In Generic Programming, \npages 1 20. Kluwer, 2003. A. Baars and D. Swierstra. Typing dynamic typing. In ICFP 02, pages 157 166, \n2002. M. Benke, P. Dybjer, and P. Jansson. Universes for generic programs and proofs in dependent type \ntheory. Nordic J. of Comp., 10(4):265 289, 2003. R. Bird and R. Paterson. Generalised folds for nested \ndatatypes. Formal Aspects of Computing, 11:11 2, 1999. C. B\u00a8ohm and A. Berarducci. Automatic synthesis \nof typed .-programs on term algebras. Theoretical Computer Science, 39:135 154, 1985. B. Bringert and \nA. Ranta. A pattern for almost compositional functions. In ICFP 06, pages 216 226, 2006. J. Cheney and \nR. Hinze. A lightweight implementation of generics and dynamics. In ACM SIGPLAN Haskell Workshop, 2002. \nJ. Gibbons. Generic downwards accumulations. SCP, 37(1 3):37 65, 2000. R. Hinze. A new approach to generic \nfunctional programming. In POPL 00, pages 119 132, 2000a. R. Hinze. Polytypic values possess polykinded \ntypes. In MPC 00, volume 1837 of LNCS, pages 2 27. Springer, 2000b. R. Hinze. Generics for the masses. \nIn ICFP 04, pages 236 243, 2004. R. Hinze, J. Jeuring, and A. L\u00a8oh. Type-indexed data types. SCP, 51(2): \n117 151, 2004. S. Holdermans, J. Jeuring, A. L\u00a8oh, and A. Rodriguez. Generic views on data types. In \nMPC 06, volume 4014 of LNCS, pages 209 234. Springer, 2006. G. Huet. The Zipper. JFP, 7(5):549 554, 1997. \nP. Jansson and J. Jeuring. A framework for polytypic programming on terms, with an application to rewriting. \nIn WGP 00, 2000. P. Jansson and J. Jeuring. PolyP a polytypic programming language extension. In POPL \n97, pages 470 482, 1997. P. Jansson and J. Jeuring. Polytypic uni.cation. JFP, 8(5):527 536, 1998. J. \nJeuring. Polytypic pattern matching. In FPCA 95, pages 238 248, 1995. P. Johann and N. Ghani. Foundations \nfor structured programming with GADTs. In POPL 08, pages 297 308, 2008. P. Johann and N. Ghani. Initial \nalgebra semantics is enough! In Proceed\u00adings, Typed Lambda Calculus and Applications, pages 207 222, \n2007. R. L\u00a8ammel and S. Peyton Jones. Scrap your boilerplate: A practical design pattern for generic \nprogramming. pages 26 37. ACM Press, 2003. R. L\u00a8ammel, J. Visser, and J. Kort. Dealing with large bananas. \nIn WGP 00, 2000. A. L\u00a8oh. Exploring Generic Haskell. PhD thesis, Utrecht University, 2004. G. Malcolm. \nData structures and program transformation. SCP, 14:255 279, 1990. C. McBride. Clowns to the left of \nme, jokers to the right (pearl): dissecting data structures. In POPL 08, pages 287 295, 2008. C. McBride. \nThe derivative of a regular type is its type of one-hole contexts. strictlypositive.org/diff.pdf, 2001. \nE. Meijer, M. Fokkinga, and R. Paterson. Functional programming with bananas, lenses, envelopes, and \nbarbed wire. In FPCA 91, volume 523 of LNCS, pages 124 144. Springer, 1991. N. Mitchell and C. Runciman. \nUniform boilerplate and list processing. In ACM SIGPLAN Haskell Workshop, 2007. P. Morris, T. Altenkirch, \nand C. McBride. Exploring the regular tree types. In Types for Proofs and Programs, LNCS. Springer, 2006. \nT. van Noort, A. Rodriguez, S. Holdermans, J. Jeuring, and B. Heeren. A lightweight approach to datatype-generic \nrewriting. In WGP 08, 2008. U. Norell. Towards a practical programming language based on dependent type \ntheory. PhD thesis, Chalmers University of Technology, 2007. U. Norell and P. Jansson. Polytypic programming \nin Haskell. In IFL 03, volume 3145 of LNCS, pages 168 184. Springer, 2004. B. C. d. S. Oliveira and J. \nGibbons. Typecase: A design pattern for type\u00adindexed functions. In ACM SIGPLAN Haskell Workshop, 2005. \nB. C. d. S. Oliveira, R. Hinze, and A. L\u00a8oh. Extensible and modular generics for the masses. In H. Nilsson, \neditor, TFP 06, pages 199 216, 2006. S. Peyton Jones, editor. Haskell 98 Language and Libraries: The \nRevised Report. Cambridge University Press, Cambridge, 2003. S. Peyton Jones, D. Vytiniotis, S. Weirich, \nand G. Washburn. Simple uni.cation-based type inference for GADTs. In ICFP 06, pages 50 61, 2006. A. \nRodriguez. Towards Getting Generic Programming Ready for Prime Time. PhD thesis, Utrecht University, \n2009. T. Schrijvers, S. Peyton Jones, M. Chakravarty, and M. Sulzmann. Type checking with open type functions. \nIn ICFP 08, pages 51 62, 2008. T. Sheard and L. Fegaras. A fold for all seasons. In FPCA 93, pages 233 \n242, 1993. T. Sheard and S. Peyton Jones. Template meta-programming in Haskell. In ACM SIGPLAN Haskell \nWorkshop, 2002. D. Swierstra, P. Azero, and J. Saraiva. Designing and implementing com\u00adbinator languages. \nIn AFP, volume 1608 of LNCS, pages 150 206. Springer, 1999.    \n\t\t\t", "proc_id": "1596550", "abstract": "<p>Many datatype-generic functions need access to the recursive positions in the structure of the datatype, and therefore adopt a fixed point view on datatypes. Examples include variants of fold that traverse the data following the recursive structure, or the Zipper data structure that enables navigation along the recursive positions. However, Hindley-Milner-inspired type systems with algebraic datatypes make it difficult to express fixed points for anything but regular datatypes. Many real-life examples such as abstract syntax trees are in fact systems of mutually recursive datatypes and therefore excluded. Using Haskell's GADTs and type families, we describe a technique that allows a fixed-point view for systems of mutually recursive datatypes. We demonstrate that our approach is widely applicable by giving several examples of generic functions for this view, most prominently the Zipper.</p>", "authors": [{"name": "Alexey Rodriguez Yakushev", "author_profile_id": "81337495069", "affiliation": "Vector Fabrics B.V., Eindhoven, Netherlands", "person_id": "P1613933", "email_address": "", "orcid_id": ""}, {"name": "Stefan Holdermans", "author_profile_id": "81337489874", "affiliation": "Utrecht University, Utrecht, Netherlands", "person_id": "P1613934", "email_address": "", "orcid_id": ""}, {"name": "Andres L&#246;h", "author_profile_id": "81100364350", "affiliation": "Utrecht University, Utrecht, Netherlands", "person_id": "P1613935", "email_address": "", "orcid_id": ""}, {"name": "Johan Jeuring", "author_profile_id": "81100339289", "affiliation": "Utrecht University, Utrecht, Netherlands", "person_id": "P1613936", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596585", "year": "2009", "article_id": "1596585", "conference": "ICFP", "title": "Generic programming with fixed points for mutually recursive datatypes", "url": "http://dl.acm.org/citation.cfm?id=1596585"}