{"article_publication_date": "08-31-2009", "fulltext": "\n Identifying Query Incompatibilities with Evolving XML Schemas Pierre Genev`es CNRS pierre.geneves@inria.fr \nAbstract During the life cycle of an XML application, both schemas and queries may change from one version \nto another. Schema evolu\u00adtions may affect query results and potentially the validity of pro\u00adduced data. \nNowadays, a challenge is to assess and accommodate the impact of these changes in evolving XML applications. \nSuch questions arise naturally in XML static analyzers. These analyzers often rely on decision procedures \nsuch as inclusion between XML schemas, query containment and satis.ability. However, existing decision \nprocedures cannot be used directly in this context. The reason is that they are unable to distinguish \ninformation related to the evolution from information corresponding to bugs. This paper proposes a predicate \nlanguage within a logical framework that can be used to make this distinction. We present a system for \nmonitoring the effect of schema evo\u00adlutions on the set of admissible documents and on the results of \nqueries. The system is very powerful in analyzing various scenarios where the result of a query may not \nbe anymore what was expected. Speci.cally, the system is based on a set of predicates which allow a .ne-grained \nanalysis for a wide range of forward and backward compatibility issues. Moreover, the system can produce \ncounterex\u00adamples and witness documents which are useful for debugging pur\u00adposes. The current implementation \nhas been tested with realistic use cases, where it allows identifying queries that must be refor\u00admulated \nin order to produce the expected results across successive schema versions. Categories and Subject Descriptors \nD.3.4 [Software]: Program\u00adming Languages Processors; D.2.4 [Software]: Engineering Software/Program Veri.cation \nGeneral Terms Languages, Standardization, Veri.cation Keywords XML, Schema, Queries, Evolution, Compatibility \n1. Introduction XML is now commonplace on the web and in many information systems where it is used for \nrepresenting all kinds of information resources, ranging from simple text documents such as RSS or Atom \nfeeds to highly structured databases. In these dynamic en\u00advironments, not only data are changing steadily \nbut their schemas Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. ICFP 09, August 31 September 2, 2009, Edinburgh, Scotland, UK. Copyright c &#38;#169; 2009 \nACM 978-1-60558-332-7/09/08. . . $10.00 Nabil Laya\u00a8ida Vincent Quint INRIA {nabil.layaida,vincent.quint}@inria.fr \n also get modi.ed to cope with the evolution of the real world enti\u00adties they describe. Schema changes \nraise the issue of data consistency. Existing documents and data that were valid with a certain version \nof a schema may become invalid on a new version of the schema (for\u00adward incompatibility). Conversely, \nnew documents created with the latest version of a schema may be invalid on some previous versions (backward \nincompatibility). In addition, schemas may be written in different languages, such as DTD, XML Schema, \nor Relax-NG, to name only the most popu\u00adlar ones. And it is common practice to describe the same structure, \nor new versions of a structure, in different schema languages. Doc\u00adument formats developed by W3C provide \na variety of examples: XHTML 1.0 has both DTDs and XML Schemas, while XHTML 2.0 has a Relax-NG de.nition; \nthe schema for SVG Tiny 1.1 is a DTD, while version 1.2 is written in Relax-NG; MathML 1.01 has a DTD, \nMathML 2.0 has both a DTD and an XML Schema, and MathML 3.0 is developed with a Relax-NG schema and is \nexpected to have also a DTD and an XML Schema. An issue then is to make sure that schemas written in \ndifferent languages are equivalent, i.e. they describe the same structure, possibly with some differences \ndue to the expressivity of the language [Murata et al. 2005]. An\u00ad other issue is to clearly identify \nthe differences between two ver\u00adsions of the same schema expressed in different languages. More\u00adover, \nthe issues of forward and backward compatibility of instances obviously remain when schema languages \nchange from a version to another. Validation, and then compatibility, is not the only purpose of a schema. \nValidation is usually the .rst step for safe processing of documents and data. It makes sure that documents \nand data are structured as expected and can then be processed safely. The next step is to actually access \nand select the various parts to be handled in each phase of an application. For this, query languages \nplay a key role. As an example, when transforming a document with XSL, XPath queries are paramount to \nlocate in the original document the data to be produced in the transformed document. Queries are affected \nby schema evolutions. The structures they return may change depending on the version of the schema used \nby a document. When changing schema, a query may return nothing, or something different from what was \nexpected, and obviously further processing based on this query is at risk. These observations highlight \nthe need for evaluating precisely and safely the impact of schema evolutions on existing and future instances \nof documents and data. They also show that it is important for software engineers to precisely know what \nparts of a processing chain have to be updated when schemas change. In this paper we focus on the XPath \nquery language which is used in many situations while processing XML documents and data. The XSL transformation \nlanguage was already mentioned, but XPath is also present in XLink and XQuery for instance. 2. Analysis \nFramework The main contribution of this paper is a framework that allows the automatic veri.cation of \nproperties related to XML schema and query evolution. In particular, it offers the possibility of checking \n.ne-grained properties of the behavior of queries with respect to successive versions of a given schema. \nThe system can be used for checking whether schema evolutions require a particular query to be updated. \nWhenever schema evolutions may induce query mal\u00adfunctions, the system is able to generate annotated XML \ndocuments that exemplify bugs, with the goal of helping the programmer to un\u00adderstand and properly overcome \nundesired effects of schema evo\u00adlutions. The system relies on a predicate language (presented in Sec\u00adtion \n4) speci.cally designed for studying schema and query com\u00ad patibility issues when schemas evolve. In \nparticular, predicates al\u00adlow characterizing in a precise manner nodes subject to evolution. For instance, \npredicates allow to distinguish new nodes selected by the query after a schema change from new nodes \nthat appear in the modi.ed schema. Predicates also allow to describe nodes that ap\u00adpear in new regions \nof a schema compared to its original version, or even in a new context described by a particular XPath \nexpression. Predicates, together with the composition language provided in the system allow to express \nand analyze complex settings. The system has been fully implemented [Genev`es and Laya\u00a8ida 2009] and \nis outlined in Figure 1. It is composed of a parser for reading the text .le description of the problem \n(which in turn use speci.c parsers for schemas, queries, logical formulas, and predicates), compilers \nfor translating schemas and queries into their logical representations, a solver for checking satis.ability \nof logical formulas, and a counter example XML tree generator (described in [Genev`es et al. 2008]). \nWe .rst introduce the data model we consider for XML docu\u00adments, schemas and queries. XML Trees with \nAttributes An XML document is considered as a .nite tree of unbounded depth and arity, with two kinds \nof nodes respectively named elements and attributes. In such a tree, an element may have any number of \nchildren elements, and may carry zero, one or more attributes. Attributes are leaves. Elements are ordered \nwhereas attributes are not, as illustrated on Figure 4. In this paper, we focus on the nested structure \nof elements and attributes, and ignore XML data values. Type Constraints As an internal representation \nfor tree gram\u00admars, we consider regular tree type expressions (in the manner of [Hosoya et al. 2005]), \nextended with constraints over attributes. As\u00ad suming a set of variables ranged over by x, we de.ne a \ntree type expression as follows: t ::= tree type expression \u00d8 empty set () empty sequence t | t t, t \ndisjunction concatenation l(a)[t ] element de.nition x variable let x = t in t binder The let construct \nallows binding one or more variables to associated formulas. Since several variables can be bound at \na time, the notation x = t is used for denoting a vector of variable bindings (possibly with mutual recursion). \nWe impose a usual restriction on the recursive use of variables: we allow unguarded (i.e. not enclosed \nby a label) recursive uses of variables, but restrict them to tail positions1. With that restriction, \n1 For instance, let x = l(a)[t],x | () in x is allowed. tree types expressions de.ne regular tree languages. \nIn addition, an element de.nition may involve simple attribute expressions that describe which attributes \nthe de.ned element may (or may not) carry: a ::= attribute expression () empty list list | a disjunction \n list ::= attribute list list, list commutative concatenation l? optional attribute l required attribute \n\u00acl prohibited attribute We use the usual semantics of regular tree types found in [Hosoya et al. 2005] \nand [Genev`es et al. 2008]. Our tree type expressions capture most of the schemas in use today [Murata \net al. 2005]. In practice, our system provides parsers that convert DTDs, XML Schemas, and Relax NGs \nto this internal tree type representation. Users may thus de.ne constraints over XML documents with the \nlanguage of their choice, and, more importantly, they may refer to most existing schemas for use with \nthe system. Queries The set of XPath expressions we consider is given by the syntax shown on Figure 2. \nThe semantics of XPath expressions is described in [Clark and DeRose 1999], and more formally in [Wadler \n2000]. We observed that, in practice, many XPath expres\u00ad sions contain syntactic sugars that can also \n.t into this fragment. Figure 3 presents how our XPath parser rewrites some commonly found XPath patterns \ninto the fragment of Figure 2, where the no\u00ad tation (axis::nt)k stands for the composition of k successive \npath steps of the same form: axis::nt/.../axis::nt. | {z } k steps query ::= /path absolute path path \nrelative path query | query union query n query intersection path ::= path/path path composition path[quali.er] \nquali.ed path axis::nt step quali.er ::= quali.er and quali.er conjunction quali.er or quali.er disjunction \nnot(quali.er) negation path path path/@nt attribute path @nt attribute step nt ::= node test s node \nlabel * any node label axis ::= tree navigation axis self | child | parent descendant | ancestor descendant-or-self \nancestor-or-self following-sibling preceding-sibling following | preceding Figure 2. XPath Expressions. \n select(\"a//b[ancestor::e]\", Unsatis.able (property proved) type(\"XHTML1-strict.dtd\", let $X=e &#38; \n<1>$X... \"html\"))   Parsing and Satis.ability Test Compilation Logical formula over Satis.able Satisfying \nbinary Sample XML binary trees with tree with document inducing Synthesis binary to n-aryXML Problem \nDescription (Text File) attributes attributes a bug Figure 1. Framework Overview. . nt[position() = \n1] . nt[not(preceding-sibling::nt)] nt[position() = last()] . nt[not(following-sibling::nt)] nt[position() \n= k] . nt[(preceding-sibling::nt)k-1] |{z} k>1 count(path)=0 . not(path) count(path) > 0 . path count(nt) \n>k. nt/(following-sibling::nt)k |{z} k>0 preceding-sibling::*[position() = last() and quali.er] . preceding-sibling::*[not(preceding-sibling::*) \nand quali.er] Figure 3. Syntactic Sugars and their Rewritings. The next Section presents the logic underlying \nthe predicate lan\u00adguage. Section 4 describes predicates for characterizing the impact of schema changes. \nFinally, experiments on realistic use cases are reported in Section 5. 3. Logical Setting It is well-known \nthat there exist bijective encodings between un\u00adranked trees (trees of unbounded arity) and binary trees. \nOwing to these encodings binary trees may be used instead of unranked trees without loss of generality. \nIn the sequel, we rely on a simple .rst-child &#38; next-sibling encoding of unranked trees. In this \nen\u00adcoding, the .rst child of an element node is preserved in the binary tree representation, whereas \nsiblings of this node are appended as right successors in the binary representation. Attributes are left \nun\u00adchanged by this encoding. For instance, Figure 5 presents how the sample tree of Figure 4 is mapped. \na <r c=\"\" a=\"\" b=\" \"> b rc <s d=\" \"> d <v/><w/><x e=\" \"/> </s>  stu <t/> <u/> vwx </r> XML Notation \n e Figure 4. Sample XML Tree with Attributes. The logic we introduce below, used as the core of our frame\u00adwork, \noperates on such binary trees with attributes. 3.1 Logical Formulas The concrete syntax of logical formulas \nis shown on Figure 6, where the meta-syntax (X)E means one or more occurences of a  b rc d s vt wu \n  e x Figure 5. Binary Encoding of Tree of Figure 4. X separated by commas. The reader can directly \nuse this syntax for encoding formulas as text .les to be used with the system [Genev`es and Laya\u00a8ida \n2009]. This concrete syntax is used as a single unifying notation throughout all the paper. . ::= formula \nT true F false l element name p atomic proposition # start context . | . disjunction . &#38; . conjunction \n. => . implication . <=> . equivalence (.) parenthesized formula . negation <p>. existential modality \n<l>T attribute named l $X variable let ($X = .)E in . binder for recursion predicate predicate (See Section \n4) p ::= program inside modalities 1 .rst child 2 next sibling -1 parent -2 previous sibling Figure \n6. Concrete Syntax of Formulas. The semantics of logical formulas corresponds to the classical semantics \nof a \u00b5-calculus interpreted over .nite tree structures. A formula is satis.able iff there exists a .nite \nbinary tree with at\u00ad tributes for which the formula holds at some node. This is formally de.ned in [Genev`es \net al. 2007], and we review it informally below through a series of examples. Sample Formula Tree XML \na &#38; <1>b a b <a><b/></a> a &#38; <1>(b &#38; <2>c) a b c <a><b/><c/></a> e &#38; <-1>(d &#38; <2>g) \ne d g <d><e/></d><g/> f &#38; <-2>(g &#38; ~<2>T) none none Table 1. Sample Formulas and Satisfying \nTrees. There is a difference between an element name and an atomic proposition2: an element has one and \nonly one element name, whereas it can satisfy multiple atomic propositions. We use atomic propositions \nto attach speci.c information to tree nodes, not related to their XML labeling. For example, the start \ncontext (a reserved atomic proposition) is used to mark the starting context nodes for evaluating XPath \nexpressions. The logic uses modalities for navigating in binary trees. A modality <p>. can be read as \nfollows: there exists a successor node by program p such that . holds at this successor . As shown on \nFigure 6, a program p is simply one of the four basic programs {1, 2, -1, -2}. Program 1 allows navigating \nfrom a node down to its .rst successor, and program 2 allows navigating from a node down to its second \nsuccessor. The logic also features converse pro\u00adgrams -1 and -2 for navigating upward in binary trees, \nrespectively from the .rst successor to its parent and from the second successor to its previous sibling. \nTable 1 gives some simple formulas using modalities for navigating in binary trees, together with sample \nsat\u00adisfying trees, in binary and unranked tree representations. The logic allows expressing recursion \nin trees through the re\u00adcursive binder. For example the recursive formula: let$X= b|<2>$Xin $X means \nthat either the current node is named b or there is a sibling of the current node which is named b. For \nthis purpose, the variable $X is bound to the subformula b | <2>$X which contains an oc\u00adcurence of $X \n(therefore de.ning the recursion). The scope of this binding is the subformula that follows the in symbol \nof the for\u00admula, that is $X. The entire formula can thus be seen as a compact recursive notation for \na in.nitely nested formula of the form: b | <2>(b | <2>(b | <2>(...))) Recursion allows expressing global \nproperties. For instance, the recursive formula: ~let$X=a|<1>$X| <2>$Xin $X expresses the absence of \nnodes named a in the whole subtree of the current node (including the current node). Furthermore, the \n.xpoint operator makes possible to bind several variables at a time, which is speci.cally useful for \nexpressing mutual recursion. For example, the mutually recursive formula: 2 In practice, an atomic proposition \nmust start with a . let $X = (a &#38; <2>$Y) | <1>$X | <2>$X, $Y = b | <2>$Y in $X asserts that there \nis a node somewhere in the subtree such that this node is named a and it has at least one sibling which \nis named b. Binding several variables at a time provides a very expressive yet succinct notation for \nexpressing mutually recursive structural patterns (that are common in XML Schemas, for instance). From \na theoretical perspective, the recursive binder let $X = . in . corresponds to the .xpoint operators \nof the \u00b5-calculus. It is shown in [Genev`es et al. 2007] that the least .xpoint and the greatest .xpoint \noperators of the \u00b5-calculus coincide over .nite tree structures, for a restricted class of formulas called \ncycle-free for\u00admulas. Translations of XPath expressions and schemas presented in this paper always yield \ncycle-free formulas (see [Genev`es et al. 2008] for more details). 3.2 Queries The logic is expressive \nenough to capture the set of XPath expres\u00adsions presented in Section 2. For example, Figure 7 illustrates \nhow the sample XPath expression: child::r[child::w/@att] is expressed in the logic. From a given context \nin an XML docu\u00adment, this expression selects all r child nodes which have at least one w child with an \nattribute att. Figure 7 shows how it is ex\u00adpressed in the logic, on the binary tree representation. The \nformula holds for r nodes which are selected by the expression. The .rst part of the formula, ., corresponds \nto the step child::r which se\u00adlects candidates r nodes. The second part, ., navigates downward in the \nsubtrees of these candidate nodes to verify that they have at least one immediate w child with an attribute \natt. # r ...  vs att .  wr Translated Query: child::r[child::w/@att] Translation: r &#38; (let $X=<-1># \n| <-2>$X) &#38; <1>let $Y=w &#38; <att>T | <2>$Y |{z}| {z } .. Figure 7. XPath Translation Example. \nThis example illustrates the need for converse programs in\u00adside modalities. The translated XPath expression \nonly uses forward axes (child and attribute), nevertheless both forward and backward modalities are required \nfor its logical translation. Without con\u00adverse programs we would have been unable to differentiate selected \nnodes from nodes whose existence is simply tested. More gener\u00adally, properties must often be stated on \nboth the ancestors and the descendants of the selected node. Equipping the logic with both forward and \nconverse programs is therefore crucial. Logics without converse programs may only be used for solving \nXPath emptiness but cannot be used for solving other decision problems such as con\u00adtainment ef.ciently. \nA systematic translation of XPath expressions into the logic is given in [Genev`es et al. 2007]. In this \npaper, we extended it to deal with attributes. We implemented a compiler that takes any expression of \nthe fragment of Figure 2 and computes its logical translation. With the help of this compiler, we extend \nthe syntax of logical formulas with a logical predicate select(\"query\",.). This predicate compiles the \nXPath expression query given as pa\u00ad rameter into the logic, starting from a context that satis.es .. \nThe XPath expression to be given as parameter must match the syn\u00ad tax of the XPath fragment shown on \nFigure 2 (or Figure 3). In a similar manner, we introduce the predicate exists(\"query\",.) which tests \nthe existence of query from a context satisfying ., in a quali.er-like manner (without moving to its \nresult). Addition\u00ad ally, the predicate select(\"query\") is introduced as a shortcut for select(\"query\", \n#), where # simply marks the initial context node of the XPath expression3. The predicate exists(\"query\") \nis a shortcut for exists(\"query\", T). These syntactic extensions of the logic allow the user to easily \nembed XPath expressions and for\u00ad mulate decision problems out of them (like e.g. containment or any other \nboolean combination). In the next sections we explain how the framework allows combining queries with \nschema information for formulating problems. 3.3 Tree Types Tree type expressions are compiled into \nthe logic in two steps: the .rst stage translates them into binary tree type expressions, and the second \nstep actually compiles this intermediate representation into the logic. The translation procedure from \ntree type expres\u00adsions to binary tree type expressions is well-known and detailed in [Genev` es 2006]. \nThe syntax of output expressions follows: t ::= binary tree type expression \u00d8 empty set () empty tree \nt | t l(a)[x, x] disjunction element de.nition let x = t in t binder  Attribute expressions are not \nconcerned by this transformation to binary form: they are simply attached, unchanged, to new (binary) \nelement de.nitions. Finally, binary tree type expressions are com\u00ad piled into the logic. This translation \nstep was introduced and proven correct in [Genev`es et al. 2007]. Originally, the translation takes a \ntree type expression t and returns the corresponding logical for\u00ad mula. Here, we extend it slightly but \ncrucially: the logical trans\u00ad lation of an expression t is given by the function tr(t ) .. de.ned according \nto the predicate nullable(x) which indicates whether the type T = () bound to x contains the empty tree. \nThe function tra(a) compiles attribute expressions associated with element de.nitions as follows: def \ntra(())= notothers(()) def tra(list | a)= tra(list) &#38; notothers(list) def tra(list, list')= tra(list) \n&#38; tra(list') def tra(l?)= l | l def tra(l)= l def tra(\u00acl) = l In usual schemas (e.g. DTDs, XML Schemas) \nwhen no attribute is speci.ed for a given element, it simply means no attribute is al\u00ad lowed for the \nde.ned element. This convention must be explicitly stated in the logic. This is the role of the function \nnotothers(list) which returns the negated disjunction of all attributes not present in list. As a result, \ntaking attributes into account comes at an extra\u00ad cost. The above translation appends a (potentially \nvery large) for\u00ad mula in which all attributes occur, for each element de.nition. In practice, a placeholder \natomic proposition is inserted until the full set of attributes involved in the problem formulation is \nknown. When the whole formula has been parsed, placeholders are re\u00ad placed by the conjunction of negated \nattributes they denote. This extra-cost can be observed in practice, and the system allows two modes \nof operations: with or without attributes4. Nevertheless the system is still capable of handling real \nworld DTDs (such as the DTD of XHTML 1.0 Strict) with attributes. This is due to (1) the limited expressive \npower of languages such as DTD that do not al\u00ad low for disjunction over attribute expressions (like list \n| a ); and, more importantly, (2) the satis.ability-testing algorithm which is implemented using symbolic \ntechniques [Genev`es et al. 2008]. Tree type expressions form the common internal representation for \na variety of XML schema de.nition languages. In practice, the logical translation of a tree type expression \nt are obtained directly from a variety of formalisms for de.ning schemas, including DTD, XML Schema, \nand Relax NG. For this purpose, the syntax of logi\u00adcal formulas is extended with a predicate type(\" \u00b7 \n\", \u00b7). The logical translation of an existing schema is returned by type(\"f \",l) where f is a .le path \nto the schema .le and l is the element name to be considered as the entry point (root) of the given schema. \nAny oc\u00ad below, that takes additional arguments . and .: curence of this predicate will parse the given \nschema, extract its def internal tree type representation t, compile it into the logic and re\u00ad = F for \nt = \u00d8, () .. .. tr(t) tr(t1 | t2)turn the logical formula tr(t )FT . def = tr(t1) =(l &#38; . &#38; \ntra(a) &#38; s1(x1) &#38; s2(x2)) | . .... | tr(t2)  3.4 Type Tagging A tag (or color ) is introduced \nin the compilation of schemas with def .. .. tr(l(a)[x1,x2]) tr(let xi = ti in t) def = let $Xi = tr(ti) \n .. in tr(t ) .. the purpose of marking all node types of a speci.c schema. A tag The addition of . \nand . (respectively in a new conjunction and a new disjunction) is a key element for the de.nition of \npredi\u00adcates in Section 4. More precisely, this allows marking type sub\u00ad expressions so that they can \nbe distinguished in predicates, as ex\u00adplained in Section 3.4. In addition, . and . are either true, false, \nor simple atomic propositions. Thus, it is worth noticing that their ad\u00addition does not affect the linear \ncomplexity of tree type translation. The function s\u00b7(\u00b7) describes the type for each successor: 8 < <p>T \nif x is bound to () sp(x)= <p>T | <p>$X if nullable(x): <p>$X if not nullable(x) 3 This mark is especially \nuseful for comparing two or more XPath expres\u00adsions from the same context. is simply a fresh atomic \nproposition passed as a parameter to the translation of a tree type expression. For example: tr(t )F \nxhtml is the logical translation of t where each element de.nition is annotated with the atomic proposition \nxhtml . With the help of tags, it becomes possible to refer to the element types in any context. For \ninstance, one may formulate tr(t )F )smil F for denoting the xhtml | tr(t 'union of all t and t ' documents, \nwhile keeping a way to distinguish element types; even if some element names are shared by the two type \nexpressions. Tagging becomes even more useful for characterizing evolu\u00adtions between successive versions \nof a single schema. In this set\u00adting, we need a way to distinguish nodes allowed by a newer 4 The optional \nargument -attributes must be supplied for attributes to be considered. schema version from nodes allowed \nby an older version. This dis\u00adtinction must not be based only on element names, but also on content models. \nAssume for instance that t ' is a newer version of schema t . If we are interested in the set of trees \nallowed by t ' but not allowed by t then we may formulate: ' )F tr(t T &#38; tr(t )FT If we now want \nto check more .ne-grained properties, we may rather be interested in the following (tagged) formulation: \n' F old complement tr(t )all &#38; tr(t )T In this manner, we can distinguish elements that were added \nin t ' and whose names did not occur in t , from elements whose names already occured in t but whose \ncontent model changed in t ', for instance. In practice, a type is tagged using the predicate type(\"f \n\", l, ., . ' ) which parses the speci.ed schema, converts it into its logical representation t and returns \nthe formula tr(t ).' . . This kind of type tagging is useful for studying the consequences of schema \nupdates over queries, as presented in the next sections. 4. Analysis Predicates This section introduces \nthe basic analysis tasks offered to XML ap\u00adplication designers for assessing the impact of schema evolutions. \nIn particular, we propose a mean for identifying the precise rea\u00adsons for type mismatches or changes \nin query results under type constraints. For this purpose, we build on our query and type expression \ncompilers, and de.ne additional predicates that facilitate the formu\u00adlation of decision problems at a \nhigher level of abstraction. Specif\u00adically, these predicates are introduced as logical macros with the \ngoal of allowing system usage while focusing (only) on the XML\u00adside properties, and keeping underlying \nlogical issues transparent for the user. Ultimately, we regard the set of basic logical formulas (such \nas modalities and recursive binders) as an assembly language, to which predicates are translated. We \nillustrate this principle with two simple predicates designed for checking backward-compatibility of \nschemas, and query satis\u00ad.ability in the presence of a schema. The predicate backward incompatible(t,t \n' ) takes two type expressions as parameters, and assumes t ' is an altered version of t. This predicate \nis unsatis.able iff all instances of t ' are also valid against t . Any occurrence of this predicate \nin the input formula will automatically be compiled as tr(t ' )FT &#38; tr(t)FT .  The predicate non \nempty(\"query\",t ) takes an XPath expres\u00adsion (with the syntax de.ned on Figure 2) and a type ex\u00ad pression \nas parameters, and is unsatis.able iff the query al\u00adways returns an empty set of nodes when evaluated \non an XML document valid against t. This predicate compiles into select(\"query\", tr(t )TF &#38;#) where \nthe top-level predicate select(\"query\",.) compiles the XPath expression query into the logic, starting \nfrom a context that satis.es ., as explained in Section 3.2. This can be used to check whether the modi.cation \nof the schema does not contradict any part of the query.  Notice that the predicate non empty(\"query\",t \n) can be used for checking whether a query that is valid5 against a schema re\u00admains valid with an updated \nversion of a schema. In other terms, this predicate allows determining whether a query that must always \nreturn a non-empty result (whatever the tree on which it is eval\u00aduated) keeps verifying the same property \nwith a new version of a schema. 5 We say that a query is valid iff its negation is unsatis.able. A second, \nmore-elaborate, class of predicates allows formulat\u00ad ing problems that combine both a query query and \ntwo type expres\u00ad sions t, t ' (where t ' is assumed to be a evolved version of t): new element name(\"query\", \nt, t ' ) is satis.ed iff the query query selects elements whose names did not occur at all in t . This \nis especially useful for queries whose last navigation step contains a * node test and may thus select \nunexpected elements. This predicate is compiled into: element(t ) &#38; select(\"query\", tr(t ' )TF ) \nwhere element(t) is another predicate that builds the disjunc\u00adtion of all element names occuring in t \n. In a similar manner, the predicate attribute(.) builds the logical disjunction of all attribute names \nused in .. new region(\"query\",t,t ' ) is satis.ed iff the query query se\u00adlects elements whose names already \noccurred in t , but such that these nodes now occur in a new context in t '. In this setting, the path \nfrom the root of the document to a node selected by the XPath expression query contains a node whose \ntype is de.ned in t ' but not in t as illustrated below: node selected by query path from root to selected \nnode contains node in t ' \\ t ' XML document valid against t but not against t The predicate new region(\"query\",t,t \n' ) is logically de.ned as follows: new region(\"query\", t, t ' ) def = F ' old complement select(\"query\", \ntr(t ) &#38; tr(t )) all T &#38; added element(t,t ' ) &#38; ancestor( old complement) &#38; descendant( \nold complement) &#38; following( old complement) &#38; preceding( old complement) The previous de.nition \nheavily relies on the partition of tree nodes de.ned by XPath axes, as illustrated by Figure 8. The de.nition \nof new region(\"query\",t,t ' ) uses an auxiliary predicate added element(t, t ' ) that builds the disjunction \nof all element names de.ned in t ' but not in t (or in other terms, elements that were added in t '). \nIn a similar manner, the pred\u00adicate added attribute(., . ' ) builds the disjunction of all attribute \nnames de.ned in t ' but not in t. The predicate new region(\"query\", t, t ' ) is useful for check\u00ading \nwhether a query selects a different set of nodes with t ' than with t because selected elements may occur \nin new regions of the document due to changes brought by t ' . new content(\"query\", t, t ' ) is satis.ed \niff the query query selects elements whose names were already de.ned in t , but whose content model has \nchanged due to evolutions brought by t ', as illustrated below:  Figure 8. XPath axes: partition of \ntree nodes. node selected by query subtree for selected node has changed (new content model) ' XML \ndocument valid against t but not against t The de.nition of new content(\"query\", t, t ' ) follows: new \ncontent(\"query\", t, t ' ) def = F ' old complement select(\"query\", tr(t )&#38; tr(t ) ) all T &#38; \nadded element(t, t ' ) &#38; ancestor(added element(t, t ' )) &#38; descendant( old complement) &#38; \nfollowing( old complement) &#38; preceding( old complement) The predicate new content(\"query\",t,t ' ) \ncan be used for ensuring that XPath expressions will not return nodes with a possibly new content model \nthat may cause problems. For instance, this allows checking whether an XPath expression whose resulting \nnode set is converted to a string value (as in, e.g. XPath expressions used in XSLT value-of instructions) \nis affected by the changes from t to t ' . The previously de.ned predicates can be used to help the pro\u00adgrammer \nidentify precisely how type constraint evolutions affect queries. They can even be combined with usual \nlogical connectives to formulate even more sophisticated problems. For example, let us de.ne the predicate \nexclude(.) which is satis.able iff there is no node that satis.es . in the whole tree. This predicate \ncan be used for excluding speci.c element names or even nodes selected by a given XPath expression. It \nis de.ned as follows: def exclude(.)= ancestor-or-self(descendant-or-self(.)) This predicate can also \nbe used for checking properties in an iter\u00adative manner, re.ning the property to be tested at each step. \nIt can also be used for verifying .ne-grained properties. For instance, one may check whether t ' de.nes \nthe same set of trees as t modulo new element names that were added in t ' with the following for\u00admulation: \n(t <=> t ' ) &#38; exclude(added element(t, t ' )) This allows identifying that, during the type evolution \nfrom t to t ' , the query results change has not been caused by the type extension but by new compositions \nof nodes from the older type. In practice, instead of taking internal tree type representations (as de.ned \nin Section 2) as parameters, most predicates do actually take any logical formula as parameter, or even \nschema paths as parameters. We believe this facilitates predicates usage and, most notably, how they \ncan be composed together. Figure 9 gives the syntax of built-in predicates as they are implemented in \nthe system, where f is a .le path to a DTD (.dtd), XML Schema (.xsd), or Relax NG (.rng). In addition \nof aforementioned predicates, the predicate predicate ::= select(\"query\") select(\"query\",.) exists(\"query\") \nexists(\"query\",.) type(\"f \",l) type(\"f \", l, ., . ' ) forward incompatible(., . ' ) backward incompatible(., \n. ' ) element(.) attribute(.) descendant(.) exclude(.) added element(., . ' ) added attribute(., . ' \n) non empty(\"query\",.) new element name(\"query\", \"f \", \"f ' \",l) new region(\"query\", \"f \", \"f ' \",l) \nnew content(\"query\", \"f \", \"f ' \",l) predicate-name((.)E) Figure 9. Syntax of Predicates for XML Reasoning. \n descendant(.) forces the existence of a node satisfying . in the subtree, and predicate-name((.)E) is \na call to a custom predicate, as explained in the next section. 4.1 Custom Predicates Following the spirit \nof predicates presented in the previous sec\u00adtion, users may also de.ne their own custom predicates. The \nfull syntax of XML logical speci.cations to be used with the system is de.ned on Figure 10, where the \nmeta-syntax (X)E means one or more occurrence of X separated by commas. A global problem speci.cation \ncan be any formula (as de.ned on Figure 6), or a list of custom predicate de.nitions separated by semicolons \nand fol\u00adlowed by a formula. A custom predicate may have parameters that are instanciated with actual \nformulas when the custom predicate is called (as shown on Figure 9). A formula bound to a custom pred\u00ad \nicate may include calls to other predicates, but not to the currently de.ned predicate (recursive de.nitions \nmust be made through the let binder shown on Figure 6). spec ::= . formula (see Fig. 6) def ; . def \n::= predicate-name((l)E)= . ' custom de.nition def ; def list of de.nitions Figure 10. Global Syntax \nfor Specifying Problems. Schema Variables Elements Attributes XHTML 1.0 basic DTD 71 52 57 XHTML 1.1 \nbasic DTD 89 67 83 MathML 1.01 DTD 137 127 72 MathML 2.0 DTD 194 181 97 Table 2. Sizes of (Some) Considered \nSchemas. 5. Framework in Action We have implemented the whole software architecture described in Section \n2 and illustrated on Figure 1. The tool [Genev`es and Laya\u00a8ida 2009] is available online from: http://wam.inrialpes.fr/xml \nWe have carried out extensive experiments of the system with real world schemas such as XHTML, MathML, \nSVG, SMIL (Table 2 gives details related to their respective sizes) and queries found in transformations \nsuch MathML content to presentation [Pietriga 2005]. We present two of them that show how the tool can \nbe used to analyze different situations where schemas and queries evolve. Evolution of XHTML Basic The \n.rst test consists in analyzing the relationship (forward and backward compatibility) between XHTML basic \n1.0 and XHTML basic 1.1 schemas. In particular, backward compatibility can be checked by the following \ncommand: backward_incompatible(\"xhtml-basic10.dtd\", \"xhtml-basic11.dtd\", \"html\") The test immediately \nyields a counter example as the new schema contains new element names. The counter example (shown below) \ncontains a style element occurring as a child of head, which is not permitted in XHTML basic 1.0: <html> \n<head> <title/> <style type=\"_otherV\"/> </head> <body/> </html> The next step consists in focusing on \nthe relationship between both schemas excluding these new elements. This can be formulated by the following \ncommand: backward_incompatible(\"xhtml-basic10.dtd\", \"xhtml-basic11.dtd\", \"html\") &#38; exclude(added_element( \ntype(\"xhtml-basic10.dtd\",\"html\"), type(\"xhtml-basic11.dtd\", \"html\"))) The result of the test shows a \ncounter example document that proves that XHTML basic 1.1 is not backward compatible with XHTML basic \n1.0 even if new elements are not considered. In particular, the content model of the label element cannot \nhave an a element in XHTML basic 1.0 while it can in XHTML basic 1.1. The counter example produced by \nthe solver is shown below: <html> <head> <object> <label> <a> <img/> </a> <img/> </label> <param/> \n</object> <meta/> <title/> <base/> </head> <body/> </html> XTML basic 1.0 validity error: element \"a\" \nis not declared in \"label\" list of possible children Notice that we observed similar forward and backward \ncompat\u00adibility issues with several other W3C normative schemas (in partic\u00adular for the different versions \nof SMIL and SVG). Such backward incompatibilities suggests that applications cannot simply ignore new \nelements from newer schemas, as the combination of older el\u00adements may evolve signi.cantly from one version \nto another. MathML Content to Presentation Conversion MathML is an XML format for describing mathematical \nnotations and capturing both its structure and graphical structure, also known as Content MathML and \nPresentation MathML respectively. The structure of a given equation is kept separate from the presentation \nand the rendering part can be generated from the structure descrip\u00adtion. This operation is usually carried \nout using an XSLT transfor\u00admation that achieves the conversion. In this test series, we focus on the \nanalysis of the queries contained in such a transformation sheet and evaluate the impact of the schema \nchange from MathML 1.0 to MathML 2.0 on these queries. Most of the queries contained in the transformation \nrepresent only a few patterns very similar up to element names. The following three patterns are the \nmost frequently used: Q1: //apply[*[1][self::eq]] Q2: //apply[*[1][self::apply]/inverse] Q3: //sin[preceding-sibling::*[position()=last() \n and (self::compose or self::inverse)]] The .rst test is formulated by the following command: new_region(\"Q1\",\"mathml.dtd\",\"mathml2.dtd\",\"math\") \nThe result of the test shows a counter example document that proves that the query may select nodes in \nnew contexts in MathML 2.0 compared to MathML 1.0. In particular, the query Q1 selects apply elements \nwhose ancestors can be declare elements, as indicated on the document produced by the solver: <math xmlns:solver=\"http://wam.inrialpes.fr/xml\" \nsolver:context=\"true\"> <declare> <apply solver:target=\"true\"> <eq/> </apply> <condition/>  </declare> \n</math> Notice that the solver automatically annotates a pair of nodes related by the query: when the \nquery is evaluated from a node marked with the attribute solver:context, the node marked with solver:target \nis selected. To evaluate the effect of this change, the counter example is .lled with content and passed \nas an input parameter to the transformation. This shows immediately a bug in the transformation as the \nresulting document is not a MathML 2.0 presentation document. Based on this analysis, we know that the \nXSLT template associated with the match pattern Q1 must be updated to cope with MathML evolution from \nversion 1.0 to version 2.0. The next test consists in evaluating the impact of the MathML type evolution \nfor the query Q2 while excluding all new elements added in MathML 2.0 from the test. This identi.es whether \nold ele\u00adments of MathML 1.0 can be composed in MathML 2.0 in a differ\u00adent manner. This can be performed \nwith the following command: new_content(\"Q2\",\"mathml.dtd\",\"mathml2.dtd\",\"math\") &#38; exclude(added_element(type(\"mathml.dtd\",\"math\"), \ntype(\"mathml2.dtd\", \"math\"))) The test result shows an example document that effectively combines MathML \n1.0 elements in a way that was not allowed in MathML 1.0 but permitted in MathML 2.0. <math xmlns:solver=\"http://wam.inrialpes.fr/xml\" \nsolver:context=\"true\"> <apply solver:target=\"true\"> <apply> <inverse/> </apply> <annotation-xml> <math/> \n</annotation-xml> <condition/> </apply> </math> Similarly, the last test consists in evaluating the \nimpact of the MathML type evolution for the query Q3, excluding all new ele\u00adments added in MathML 2.0 \nand counter example documents con\u00adtaining declare elements (to avoid trivial counter examples): new_regions(\"Q3\",\"mathml.dtd\",\"mathml2.dtd\",\"math\") \n&#38; exclude(added_element(type(\"mathml.dtd\",\"math\"), type(\"mathml2.dtd\",\"math\"))) &#38; exclude(declare) \nThe counter example document shown below illustrates a case where the sin element occurs in a new context. \n<math xmlns:solver=\"http://wam.inrialpes.fr/xml\" solver:context=\"true\"> <apply> <annotation-xml> <math> \n<apply> <inverse/> <sin solver:target=\"true\"/> </apply> </math> </annotation-xml> </apply> </math> Applying \nthe transformation on previous examples yields doc\u00aduments which are neither MathML 1.0 nor MathML 2.0 \nvalid. As a result, the stylesheet cannot be used safely over documents of the new type without modi.cations. \nIn addition, the required changes to the stylesheet are not limited to the addition of new templates \nfor MathML 2.0 elements. The templates that deal with the composi\u00adtion of MathML 1.0 elements should \nbe revised as well. All the previous tests were processed in less than 30 seconds on an ordinary laptop \ncomputer running Mac OS X. The 30s cor\u00ad respond to the most complex use cases. Most complex means an\u00ad \nalyzing recursive forward/backward and quali.ed queries such as Q3, under evolution of large and heavily \nrecursive schemas such as XHTML and MathML (large number of type variables, elements and attributes: \nsee Table 2). These are the hardest cases measured in practice with the implementation. Most of other \nschemas and queries usually found in applications are much simpler than the ones presented in this paper \nand will obviously be solved much faster. Given the variety of schemas occurring in practice, we fo\u00ad \ncused on the most complex W3C standard schemas. The accom\u00ad panying full online implementation [Genev`ida \n2009] es and Laya\u00a8allows to run all the tests described in the paper as well as user\u00ad supplied ones. \nIt shows intermediate compilation stages, generated formulae (in particular the translation of schemas \ninto the logic), and reports on the performance of each step of the analysis. 6. Related Work Schema \nevolution is an important topic and has been extensively explored in the context of relational, object-oriented, \nand XML databases. Most of the previous work for XML query reformulation is approached through reductions \nto relational problems [Beyer et al. 2005]. This is because schema evolution was considered as a storage \nproblem where the priority consists in ensuring data consistency across multiple relational schema versions. \nIn such settings, two distinct schemas and an explicit description of the mapping between them are assumed \nas input. The problem then consists in reformulating a query expressed in terms of one schema into a \nsemantically equivalent query in terms of the other schema: see [Yu and Popa 2005] and more recently \n[Moon et al. 2008] with references thereof. In addition to the fundamental differences between XML and \nthe relational data model, in the more general case of XML pro\u00adcessing, schemas constantly evolve in \na distributed, independent, and unpredictable environment. The relations between different schemas are \nnot only unknown but hard to track. In this context, one priority is to help maintaining query consistency \nduring these evolutions, which is still considered as a challenging problem [Sed\u00ad lar 2005, Rose 2004]. \nThe absence of evolution analysis tools for XML/XPath contrasts with the abundance of tools and methods \nroutinely used in relational databases. The work found in [Moro et al. 2007] discusses the impact of \nevolving XML schemas on query reformulation. Based on a taxonomy of XML schema changes during their evolution, \nthe authors provide informal not exact nor systematic guidelines for writing queries which are less \nsensitive to schema evolution. In fact, studying query reformulation requires at least the ability to \nanalyze the relationship between queries. For this reason, a closely related work is the problem of determining \nquery containment and satis.ability under type constraints [Benedikt et al. 2005, Colazzo et al. 2006, \nGenev`es et al. 2007]. The work found in [Benedikt et al. 2005] studies the complex\u00ad ity of XPath emptiness \nand containment for various fragments (see [Benedikt and Koch 2006] and references thereof for a survey). \nIn [Colazzo et al. 2004, 2006], a technique is presented for statically ensuring correctness of paths. \nThe approach deals with emptiness of XPath expressions without reverse axes. The work presented in [Genev`es \net al. 2007] solves the more general problem of contain\u00ad ment, including reverse axes. The main distinctive \nidea pursued in this paper is to develop a logical approach for guiding schema and query evolution. In \ncontrast to the previous use of logics for proving properties such as query emptiness or equivalence, \nthe goal here is different in that we seek to provide the necessary tools to produce relevant knowledge \nwhen such relations do not hold. From a complexity point-of-view, it is worth noticing that the addition \nof predicates does not increase complexity for the underlying logic shown in [Genev`es et al. 2007]. \nWe would also like to emphasize that, to the best of our knowl\u00adedge, this work is the .rst to provide \nprecise analyses of XML evolution, that was tested on real life use cases (such as XHTML and MathML types) \nand complex queries (involving recursive and backward navigation). As a consequence, in this context, \nanalysis tools such as type-checkers [Hosoya and Pierce 2003, Benzaken et al. 2003, M\u00f8ller and Schwartzbach \n2005, Gapeyev et al. 2006, Castagna and Nguyen 2008] do no match the expressiveness, typ\u00ad ing precision, \nand analysis capabilities of the work presented here. 7. Conclusion In this article, we present an application \nof a logical framework for verifying forward/backward compatibility issues caused by schemas and queries \nevolution. We provide evidence that such a framework can be successfully used to overcome the obstacles \nof the analysis of XML type and query evolution. This kind of analyses is widely considered as a challenging \nproblem in XML programming. As mentioned earlier, the dif.culty is twofold: .rst it requires dealing \nwith large and complex language constructions such as XML types and queries, and second, it requires \nmodeling and reasoning about evolution of such constructions. The presented tool allows XML designers \nto identify queries that need reformulation in order to produce the expected results across successive \nschema versions. With this tool designers can ex\u00adamine precisely the impact of schema changes over queries, \nthere\u00adfore facilitating their reformulation. We gave illustrations of how to use the tool for both schema \nand query evolution on realistic exam\u00adples. In particular, we considered typical situations in applications \ninvolving W3C schemas evolution such as XHTML and MathML. The tool can be very useful for standard schema \nwriters and main\u00adtainers in order to assist them enforce some level of quality assur\u00adance on compatibility \nbetween versions. There are a number of interesting extensions to the proposed system. In particular, \nthe set of predicates can be easily enriched to detect more precisely the impact on queries. For example, \none can extend the tagging to identify separately every navigation step and quali.er in a query expression. \nThis will help greatly in the identi.cation and reformulation of the navigation steps or quali.ers affected \nby schemas evolution. References Michael Benedikt and Christoph Koch. XPath leashed. submitted, 2006. \nMichael Benedikt, Wenfei Fan, and Floris Geerts. XPath satis.ability in the presence of DTDs. In PODS \n05, pages 25 36. ACM Press, 2005. ISBN 1-59593-062-0. doi: http://doi.acm.org/10.1145/1065167.1065172. \nV\u00b4eronique Benzaken, Giuseppe Castagna, and Alain Frisch. CDuce: An XML-centric general-purpose language. \nIn ICFP 03: Proceedings of the Eighth ACM SIGPLAN International Conference on Functional Programming, \npages 51 63, New York, NY, USA, 2003. ACM Press. ISBN 1-58113-756-7. \u00a8 DB2/XML: designing for evolution. \nIn SIGMOD 05, pages 948 952. ACM, 2005. ISBN 1-59593-060-4. doi: http://doi.acm.org/10.1145/ 1066157.1066299. \nKevin Beyer, Fatma Ozcan, Sundar Saiprasad, and Bert Van der Linden. Giuseppe Castagna and Kim Nguyen. \nTyped iterators for XML. In ICFP, pages 15 26, 2008. James Clark and Steve DeRose. XML path language \n(XPath) version 1.0, W3C recommendation, November 1999. http://www.w3.org/TR/ 1999/REC-xpath-19991116. \nDario Colazzo, Giorgio Ghelli, Paolo Manghi, and Carlo Sartiani. Types for path correctness of XML queries. \nIn ICFP 04: Proceedings of the ninth ACM SIGPLAN international conference on Functional programming, \npages 126 137, New York, NY, USA, 2004. ACM Press. ISBN 1-58113\u00ad905-5. Dario Colazzo, Giorgio Ghelli, \nPaolo Manghi, and Carlo Sartiani. Static analysis for path correctness of XML queries. J. Funct. Program., \n16 (4-5):621 661, 2006. ISSN 0956-7968. Vladimir Gapeyev, Franc\u00b8ois Garillot, and Benjamin C. Pierce. \nStatically typed document transformation: An Xtatic experience. In PLAN-X 2006: Proceedings of the International \nWorkshop on Programming Language Technologies for XML, volume NS-05-6 of BRICS Notes Series, pages 2 \n13, Aarhus, Denmark, January 2006. BRICS. Pierre Genev`Logics for XML. PhD thesis,es. Insti\u00adtut National \nPolytechnique de Grenoble, December 2006. http://www.pierresoft.com/pierre.geneves/phd.htm. Pierre Geneves \nand Nabil Laya`\u00a8ida. The XML reasoning solver project, February 2009. http://wam.inrialpes.fr/xml. Pierre \nGenev`es, Nabil Laya\u00a8ida, and Alan Schmitt. Ef.cient static anal\u00adysis of XML paths and types. In PLDI \n07, pages 342 351. ACM Press, 2007. ISBN 978-1-59593-633-2. doi: http://doi.acm.org/10.1145/ 1250734.1250773. \nPierre Genev`ida, and Alan Schmitt. Ef.cient static analysis es, Nabil Laya\u00a8of XML paths and types. Long \nversion of [Genev`es et al. 2007], Research Report 6590, INRIA, July 2008. URL http://hal.inria. fr/inria-00305302/en/. \nHaruo Hosoya and Benjamin C. Pierce. XDuce: A statically typed XML processing language. ACM Trans. Inter. \nTech., 3(2):117 148, 2003. ISSN 1533-5399. Haruo Hosoya, J\u00b4ome Vouillon, and Benjamin C. Pierce. Regular \nexpres\u00ader sion types for XML. ACM TOPLAS, 27(1):46 90, 2005. ISSN 0164\u00ad0925. doi: http://doi.acm.org/10.1145/1053468.1053470. \nAnders M\u00f8ller and Michael I. Schwartzbach. The design space of type checkers for XML transformation languages. \nIn Proc. Tenth Inter\u00adnational Conference on Database Theory, ICDT 05, volume 3363 of LNCS, pages 17 36, \nLondon, UK, January 2005. Springer-Verlag. Hyun J. Moon, Carlo A. Curino, Alin Deutsch, and Chien-Yi \nHou. Manag\u00ading and querying transaction-time databases under schema evolution. In VLDB 08, pages 882 \n895. VLDB Endowment, 2008. Mirella M. Moro, Susan Malaika, and Lipyeow Lim. Preserving xml queries during \nschema evolution. In WWW 07, pages 1341 1342. ACM, 2007. ISBN 978-1-59593-654-7. doi: http://doi.acm.org/10.1145/ \n1242572.1242841. Makoto Murata, Dongwon Lee, Murali Mani, and Kohsuke Kawaguchi. Taxonomy of XML schema \nlanguages using formal language theory. ACM TOIT, 5(4):660 704, 2005. ISSN 1533-5399. doi: http://doi.acm. \norg/10.1145/1111627.1111631. Emmanuel Pietriga. MathML content2presentation transformation, May 2005. \nhttp://www.lri.fr/ pietriga/mathmlc2p/mathmlc2p.html. Kristoffer H. Rose. The XML world view. In DocEng \n04: Proceedings of the 2004 ACM symposium on Document engineering, pages 34 34, New York, NY, USA, 2004. \nACM. ISBN 1-58113-938-1. doi: http://doi.acm. org/10.1145/1030397.1030403. URL http://www.research.ibm. \ncom/XML/Rose-DocEng2004.pdf. Eric Sedlar. Managing structure in bits &#38; pieces: the killer use case \nfor XML. In SIGMOD 05, pages 818 821. ACM, 2005. ISBN 1-59593\u00ad060-4. doi: http://doi.acm.org/10.1145/1066157.1066256. \nPhilip Wadler. Two semantics for XPath. Internal Technical Note of the W3C XSL Working Group, http://homepages.inf.ed.ac.uk/wadler/papers/xpath-semantics/xpath\u00adsemantics.pdf, \nJanuary 2000. Cong Yu and Lucian Popa. Semantic adaptation of schema mappings when schemas evolve. In \nVLDB 05, pages 1006 1017. VLDB Endowment, 2005. ISBN 1-59593-154-6.  \n\t\t\t", "proc_id": "1596550", "abstract": "<p>During the life cycle of an XML application, both schemas and queries may change from one version to another. Schema evolutions may affect query results and potentially the validity of produced data. Nowadays, a challenge is to assess and accommodate the impact of these changes in evolving XML applications. Such questions arise naturally in XML static analyzers. These analyzers often rely on decision procedures such as inclusion between XML schemas, query containment and satisfiability. However, existing decision procedures cannot be used directly in this context. The reason is that they are unable to distinguish information related to the evolution from information corresponding to bugs. This paper proposes a predicate language within a logical framework that can be used to make this distinction.</p> <p>We present a system for monitoring the effect of schema evolutions on the set of admissible documents and on the results of queries. The system is very powerful in analyzing various scenarios where the result of a query may not be anymore what was expected. Specifically, the system is based on a set of predicates which allow a fine-grained analysis for a wide range of forward and backward compatibility issues. Moreover, the system can produce counterexamples and witness documents which are useful for debugging purposes. The current implementation has been tested with realistic use cases, where it allows identifying queries that must be reformulated in order to produce the expected results across successive schema versions.</p>", "authors": [{"name": "Pierre Genev&#232;s", "author_profile_id": "81331492783", "affiliation": "CNRS, Grenoble, France", "person_id": "P1614033", "email_address": "", "orcid_id": ""}, {"name": "Nabil Laya&#239;da", "author_profile_id": "81100149392", "affiliation": "INRIA, Grenoble, France", "person_id": "P1614034", "email_address": "", "orcid_id": ""}, {"name": "Vincent Quint", "author_profile_id": "81100637924", "affiliation": "INRIA, Grenoble, France", "person_id": "P1614035", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1596550.1596583", "year": "2009", "article_id": "1596583", "conference": "ICFP", "title": "Identifying query incompatibilities with evolving XML schemas", "url": "http://dl.acm.org/citation.cfm?id=1596583"}