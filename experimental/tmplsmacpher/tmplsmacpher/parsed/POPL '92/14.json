{"article_publication_date": "02-01-1992", "fulltext": "\n Typing Record Concatenation for Free Didier R&#38;my INRIA, France Abstract We show that any functional \nlanguage with record ex\u00adtension possesses record concatenation for free. We exhibit a translation from \nthe latter into the former. We obtain a type system for a language with record concatenation by composing \nthe translation with type\u00adchecking in a language with record extension. We ap\u00adply this method to a version \nof ML with record ex\u00adtension and obtain an extension of ML with either asymmetric or symmetric concatenation. \nThe latter extension is simple, flexible and has a very efficient type inference algorithm in practice. \nConcatenation together with removal of fields needs one more con\u00adstruct than extension of records. It \ncan be added to the version of ML with record extension. However, many typed languages with record cannot \ntype such a construct. The method still applies to them, pro\u00adducing type systems for record concatenation \nwithout removal of fields. Object systems also benefit of the encoding which shows that multiple inheritance \ndoes not actually require the concatenation of records but only their extension. Introduction Dictionaries \nare an imported data abstraction in func\u00adtional programming languages. They are basically partial functions \nfrom keys to values. A simple imple\u00admentation of dictionaries is the association list, com\u00admonly called \nA-1ist . A-lists are lists of pairs, the first component being the key to access the value of the second \ncomponent. The usual cons and append opera\u00adtions provide facilities for extending the domain of an A-list \nand merging two A-lists into one defined on the union of the domains of the input lists, respectively. \nAccess to a given key may fail when the key is not in the domain of the A-list, this cannot be checked \nstat\u00adically. Records are a highly restricted form of A-lists. Keys may no longer be any values, but belong \nto a Permission to copy without fee all or part of this matertial is granted provided that the copies \nare not made or distributed for direct commercial advantage, the ACM copyright notice and the title of \nthe publication and its date appear, and notice is given that the copying is by permission of the Association \nfor Computing Machinery. To copy other\u00adwise, or to republish, requires a fee andlor specific permission. \ndistinguished set of atomic values, called labels. All fields of a record must be specified at creation \ntime. These restrictions make it possible to perform static checks on accesses to record fields. Then, \nan important goal in typechecking records, was to allow a record with many fields to be used instead \nof a records with fewer fields, Thk was first suggested by Cardelli in the language Amber [Car86] using \ninclusion on monomorphic types. Later, Wand [Wan87] used polymorphism instead of a specific inclusion \nrelation on types. He also re\u00adimported the cons operation of A-lists which became the extension of records \nwith new fields. Originally, this construction was free (existing fields could be re\u00addefined), but strict \nversions (existing fields could not be redefined) have been proposed [OB88, JM88] to avoid typechecking \ndifficulties. Note that cons on A-Iists naturally implements free extension. Record extension quickly \nbecame popular, but, many languages still only provide the strict ver\u00adsion [JM88, 0h090, HP90a]. Finally, \nWand re\u00adimported the append of A-lists, calling it record con\u00adcatenation. An important motivation for \nthis is the encoding of multiple inheritance [Wan89] in object ori\u00adent ed languages. Record concatenation \nis still considered a challenge, since it is either very restricted [HP90a] or leads to combinatorial \nexplosion for typechecking [Wan88]. We propose a general approach to concatenation, In fact we claim \nthat concatenation comes for free once record extension is provided. We justify this assertion by pre\u00adsenting \nan encoding of the latter into the former. The interest of the encoding is to provide a type system for \nrecord concatenation by composing the coding with a type system for record extension. We introduce the \ntranslation in an untyped frame\u00adwork in section 1. In section 2, we apply it to an extension of ML for \nrecord extension. In the last sec\u00adtion we briefly illustrate the encoding on a few other languages. 1 \nEncoding of concatenation In this section we describe how concatenation can be encoded with extension. \nThe language with record extension, L, is an extension of the untyped A calculus @ 1992 ACM 089791-453-8/92/0001/0166 \n$1.50 plus distinguished constructs for record expressions: M ::= X variable IJz.M abstraction IMM application \nempty record I{} l{ Mwithu=M} record extension I M.a record access The semantics of records is the usual \none. Informally, they are partial functions from labels to values. The empty record is defined nowhere. \nAccessing a field of a record is applying the record to that field. It produces an error if the accessed \nfield is not defined. The free extension of a recordl with a new field defines or redefines that field \nwith the new value. The strict extension does the same if the field was undefined, but produces an error \notherwise. The concatenation (or mer:ye ) operator [1 takes two records and returns a record composed \nof all fields de\u00adfined in any of its arguments. There are different se\u00admantics given to the merge, when \nboth records define the same field: symmetric concatenation rejects this case [HP90b] while asymmetric \nconcatenation takes the value from the last record [Wan89]. We will not consider recursive concatenation \nthat would compute the concatenation of common fields by recursively con\u00adcatenating their values. The \nlanguage with record concatenation, Lll is ,I {} {a=M} M\\l M M.a The language is an extension of L with \na construct for concatenation, but record extension has been replaced by one field records that ar,e \nmore primitive in the presence of concatenation, sincel: Reading this equality from right to left is \nalso inter\u00adesting: it means that one field concatenation can be written with record extension only. It \ngives the ex\u00adpected semantics of asymmetric concatenation when the extension is free and the semantics \nof symmet\u00adric concatenation when the eztension is strict. In the next section, we generalize this to \na translation from the language LII with record concatenation to the lan\u00adguage L with record extension. \n1.1 The untyped translation The following translation works for both asymmetric and symmetric concatenation. \nWe arbitrarily choose asymmetric concatenation. 1This is similar to the correspondence between append \nand cons in on A-1ists, in this particular case: [M] append ~ = M cons r. The extension of fields provides \nthe one field con\u00adcatenation operation: Ar. (r II {a= M}) := ~r. {r with a= M}, which we write: {a:=M}t. \nIn fact we can compute r II s whenever we know ex\u00adactly the fields of s, since r[l{al=Ml;...a=M~}a}a \n{... {~ with al=.ikf l}... with a~=ikf~}. This equivalence could also have been deduced from the decomposition \nof s into one field concatenations (... (r II {al =M:~}) . . . II {an= Mn}), which is also the composition \n({an=itfm}t0... {al =Ml}t) r, We write {aI=Ml; . . . an= Mn}t for the abstraction of the previous expression \nover r. More generally we define the transformation t on record expressions by {}t=Au. u {a=M}t s Au. \n{u with a = Mt} (M IIN)t E Nt OMt The transformation t is called record abstraction . Since any record \nexpression can be decomposed into a combination of the thr(ee previous forms, the trans\u00adformation is \ndefined for all records. It satisfies the property ~t = Au. (u IIr). Thus 1 = rt {}. If we transform \nall record expressions in a program, then we have to replace the access r.a by (rt {}).a. Actually, it \nis enough to apply r to a record r that does not contain the a field and read the a field of the result \n(r r ) .a. In a typed language this solution will leave more flexibility for the type of r. Thus we complete \nthe translation by This works quite well in an untyped framework. How\u00adever the encoding is not injective, \nfor instance it iden\u00adtifies the empty record with the identity function. In the next section we adapt \nthe translation to a typed framework. 1.2 The tagged translation In this section we improve the translation \nso that the encoding become injective. The main motivation is to prepare the use of the encoding to get \na typed ver\u00adsion of Lll by pulling back the typing rules of a typed version of L. The well typed programs \nin Lll will be the reverse image of the well typed programs in L. The translation should be injective \non well typed pro\u00adgrams. A solution is to tag the encoding of records, so that they become tagged abstractions \nand distinguish themselves from other abstractions. In fact, we replace L by LTag Untag, that is L plus \ntwo constants Tag and Untag used to tag and untag values. The only reduction involving Tag or Untag is \nthat Untag (Tag M) reduces to M. Tag and Untag can be thought as the unique constructor and the unique \ndestructor of an abstract data type, respectively. In SML [HMT90] they could be defined by abstype (cr, \n~) tagged = Tagged of cx -+ @ with valTag = fnx+ Tagged x vat Untag = fn Tagged x + x end; Their role \nis to certify that some functional values are in fact record abstractions, Tag stamps them and Untag \nreads and removes the stamps. Obviously these constants are not accessible in LII, i.e. they are private \nto the translation. Syntactically the existence of Tag and Untag is not a question, but semantically \na model of a calculus with record extension might not possess such constants. On the opposite, finding \na particular model in which the constants Tag and Untag exists might be as difficult as finding a direct \nmodel for concatenation. Anyhow, we limit our use of the encoding to syntactic issues. The tagged translation \nis: {}* G Tag (Au. u) {a=ikf}t ~ Tag (Au. {u with a = I@}) (JI4 II IV)t s Tag (Au. (Untagl@) (UntagAlt \nu)) (Iii.a)t a ((Untag Ivft) {}).a It does not modify other constructs: (AZ, M)t R Az. I@ (M N)t EI@ \nN~ ~+~x We would like to show a property such as: starting with a calculus of record extension, we can \ntranslate any program of a calculus with record concatenation into the first calculus enriched with constants \nTag and Untag using the translation above, and thereby get in some sense an equivalent program. t L{Tag \n,Untag }Ll[ _, J/fll t-----+ikf eval eval $ 4 ~11 .....! ......... ~ Without any such result, the translation \nt is no more than a good intuition to understanding record corl\u00adcatenation. In the next section it helps \nfinding a type system for a language with concatenation LII from a typed language with extension L, by \ntranslating Lll programs and then typing them in L. 1.3 Concatenation with removal of fields We omitted \none construction in the language L: the restriction of fields. We extend both language L and Lll with \nthe construct M::=... lM\\a It takes a record and removes the corresponding field from its domain. As \nfor extension of fields, restriction of fields can be free or strict. We consider free restric\u00adtion here. \nThe question is obviously the extension of the transformation t to restriction of fields. The guide line \nis to keep the equality (M\\a)t=~u. u[l(M\\a) true, since it was true before the addition of the re\u00adstriction. \nActually this equality is needed because the translation of the extraction of fields was based on it. \nUnfortunately the transforrilation (M\\a)t = Au. (Mtu) \\a does not work: the record u II (M\\ a) is not \nequal to (Mt u)\\a, since if the record u provides an a field, this field is defined in the left expression \nbut is undefined in the right expression, In fact u II (M \\ a) is equal to Mt u on all fields but am \non the a field it is undefined if u is or defined with the value of the a field of u otherwise. This \noperation cannot be written in the language L; we need another construct {M but a from N} called combining. \nFrom two records M and N, it de\u00adfines one that behaves exactly as M on all fields but a, and as N on \nthe a field. The record N may not de\u00adfine the a field. This primitive is stronger than (.\\ a) which could \nbe defined as {. but a from {}}. Now, the translation of (.M \\ a) can be defined by (Al \\a)t s Au. {I@ \nubut ufrom u} Its tagged version is: (A4 \\ a)t s Tag (Au. {Untag (Aft u) but a from u}) We call L+ the \nlanguage L extended with the com\u00adbining construct. This construct has never been in\u00adtroduced in the literature \nbefore. If the language L is typed, it may be the case that the combining primi\u00ad tive cannot be assigned \na correct and decent type in the type system of L and L+ might not be a trivial extension of L or even \nnot exist. The combining construct is not in Lll and there is no easy way to provide it in an extension \nof LII. Therefore L+ is a sublanguage of Lll but L is not, 2 Application to a natural ex\u00adtension of ML \nIn this section we apply the translation where L is a version of ML with record extension, and we get \na lan\u00adguage with record concatenation. We first review the language II taken from [R6m90, R6m91b] for \nrecord extension. Then we describe in detail two versions of the typed language 1111obtained by pulling \nback the typing rules of II. Last, we discuss the system 1111on its own, and compare it with other existing \nsystems with concatenation. 2.1 An extension of ML for records The language, called II, is taken from \n[R6m90, R6m91b]. It is an extension of ML, where the lan\u00adguage of types has been enriched with record \ntypes in such a way that record operations can be introduced as primitive functions rather tlhan built \nin constructs. The main properties are described in [R6m91b] and proved in [R&#38;m90, R6m91a]. The following \nsummary should be sufficient for understanding the next sec\u00adtions. The reader is referred to [R6m91b] \nfor a more thorough presentation. Let ~ be a denumerable set of labels. We write a, b and c for labels \nand L for iinite subsets of labels. The language of types is informally described by the following grammar \n(a formal description using sorts can be found in [R6m91b]):  T .. .. al T+ TIIIpf types P~ ::= # \nI abs~ I a: p;p~u (al a # .L rows p ::= 0 I abs ] pre (~) fields where a, ~ and ~ are type variables, \nX, T and row variables and O and E are field variables. Intuitively, a row with superscript L describes \nall fields but those in L, and tells for each of them whether it is present with a value of type -r (positive \ninforma\u00adtion pre (T))or absent (negative information abs ). A template row is either abs or a row variable. \nIt always describes an infinite set of fields. The superscripts in row expressions L are finite sets \nof labels. Their main role is to prevent fields from being defined twice: the type II (a: 0; (a: E; XL)) \n cannot be written for any .L. Similarly, all occurrences of the same row variable should be preceded \nby the same set of labels (possibly in a different order). The type If(a:O; #) + II(XL). cannot be written \neither, since the row variable x can\u00adnot be both in the syntactic class of rows not defining label a \nand the syntactic class of rows defining all la\u00adbels. The superscripts are part of the syntax, but we \nshall omit them whenever they are obvious by the con\u00adtext. We write a: a; b:~;;r for a: CM;(b:~;v). Example \n1 II (a: pre (a); b: pre (num); abs ~ b: pre (num); abs ) Types are equal modulo the following equations: \n left commutativity, tcl reorder fields: (a: O; b:e; X)=(b:c; a:O; X)  distributivity, to access absent \nfields:  abs = (a: abs; abs ) Example 2 The record ty-pes II (a: pre (a); abs ) and II (b: abs; a: \npre (a); abs ) are equal. Any field defined by a template can be extracted from it using substitution \nif the template is a variable or distributivity if it is abs. Example 3 In II (a: pre (a); abs ), the \ntemplate is abs; its superscript is {a}. In order to read the b field, we replace abs by b: abs; abs. \nThe original type becomes II (a: pre (a); b: abs; abs ), and the new tem\u00adplate has superscript {a, b}. \nIn II(a: pre (a.); X), the x variable can be substituted by b: S; T. The type becomes II(a:pre(a);b:s;n) \n and x is the new template. The language of expressions is the core ML lan\u00adguage. ~::=zl~x.~[~~lletz=~in~ \nIC where the constants C include the following primitives operating on records: {}: II(abs) ..a : II(a:pre(a); \nX) --+ a {with a=.} :IZ(a:abs; X)+a + H (a:pre(a); X) _\\a:II(a:6; X)-+ II(a:abs; X) Primitives for Record \nExtension (II). The extension by a field {-with a= -} is strict: a field can only be added to a record \nr that does not possess this field yet. But the restriction of a field -\\ a is free: it can be applied \nto a record which does not have field a. Free extension by a field is achieved by restriction on this \nfield followed by extension. That is, the composition (-\\ a) o ({. with a=-}): II(a:O; X)+a+II (a:pre(a); \nX) that we abbreviate {-with !a = -}. In the simplest language, the removal of fields would not be provided, \nand the extension would be given whether strict or free. Typing rules are the same as those of ML but \nwhere type equality is taken modulo the equations. As in ML, any typeable expression possesses a prin\u00adcipal \ntype. We show a few examples extracted from [R6m91b] and run on a CAML prototype (all examples preceeded \nby # are processed by the prototype). Records are built all at once as in #let car = # {name = Toyota \n; age = old ; registration = 7866};; car: II (name :pre (string); registration: pre (num); age: pre \n(string); abs) # or from previous records by removing or adding fields: #let truck = # {car\\ age with \nname = Blazer ; # registration = 6587867567};; truck: II (name:pre (string); registration:pre (num); \nage:abs; abs) Fields are accessed as usual with the dot operation. #let registration x = x.registration;; \nregistration :11 (registration: pre (6); X) + 6J Here, the field registration must be defined with a \nvalue of type a, so the field registration has type pre (a), and other fields may or may not be defined; \nthey are grouped in the template variable X. The return value has type CY.. The function eq below takes \ntwo records possessing at least a registration field of the same type2 #let eq x y = equal (registration \nx) (registration y);; eq: II (registration II (registration: :pre pre (e); x) (6); z) -+ --+ bool #eq \ncar truck;; it :bool The identifier it is bound to the last toplevel phrase (the prototype does not \nevaluate expressions but types them). The two records car and truck do not have the same set of fields, \nbut could still be passed to the function registration. 2.2 An extension of ML with record concatenation \nThe language II described in section 2.1 can easily be extended with a combining primitive {. but a from \n-}: II(a:i9; X)+ II(a:c; 7r)--+H(a:s; X) The extended language is referred to as 11+. We apply the transformation \nt with II as L. We first consider the strict version of 11+, show a few examples and treat the free version \nof 11+ at the end. Symmetric concatenation We encode the language 1111with symmetric concate\u00adnation into \nthe version of H + with strict extension. We introduce a new type symbol { -* -.} of arity two, and we \nassume given the two constants: Tag: (lI(X)+ II(n) )+{ X+ ~}, Untag:{ X*n}+(II (X)+ II(T)). The type \nsymbol { -+ -} and the two constants Tag and Untag could be defined in SML3 in SML [HMT90] as abstype \n{X + m} = Tagged of II (x) + II (m) with val Tag = fn x + Tagged x val Untag = fn Tagged x + x end; They \nare private to the translation. A program is typable in Ill] if and only if its transla\u00adtion is typable \nin IITag ~untag (II extended with Tag and Untag ). However, composing the translation with zFor simplicity \nof examples we assume the existence a poly\u00admorphic equality equal. 3Thi3 assumes an extended version \nof SML with record types and also a more flexible syntax, otherwise {X + n} should be written (x,x) tagged. \n typechecking in IITag ~untag is the same as typecheck\u00ading in Ill] with the following types for its primitives: \n{}:{ X+-X} ..a:{a: abs; z~a:pre(a); x} -+a {a=-} :a+{a:abs; X+a:pre(a); X} \\a:{a:@; X*a:&#38;;7r} -i{a:O \n; X*a:&#38;;7r} [1 :{x+~}+{~+ <}-+{x+t} Primitives for symmetric concatenation (Id). Thus the translation \ncan be avoided. When typing directly in 1111with the rules above, all record types are written with {. \n~ -} and the type symbol II can be removed; thle grammar for types be\u00adcomes T::= al T+ Tl{pf *pO} The \ntype { x a n } should be read I am a record which given any input row of fields x returns the out\u00adput \nrow n. The types for tlhe primitives above can be read with the following intuition: The empty record \nretu:rns the input row un\u00adchanged.  As remarked above (section 1), we encoded the extraction of field \na in .M as the extraction of field a in the application of M to any record that does not contain the \na field. Otherwise we would have got the weaker type:  -.a:{abs ~a:pre(a); x}-ia Thus, the extraction \nof the a field of r takes a record r which given any row where a is absent, produces a row where a is \ndefined with some value v. The result r.a is this value v.  A one-field record extends the input row, \ndefin\u00ading one more field (that should not be previously defined).  The removal of field a from a record \nM returns a record that acts as ill except on the field a where it acts as the empty reco:rd.  Finally, \nconcatenation composes its arguments.  It is easy to see that any program in II is also a pro\u00adgram in \n1111.First, define the extension primitive by {Mwith a= N} GMll{a=N} It has type: {X+a:abs; r}+a+{x \n+-a:pre(a); n} Check that all the following typing assertions are cor\u00ad rect in 1111: {}:{abs +x} -.a:{abs \naa:pre(cu); fi}+a {_with a=_} :{ab:s +a:abs; n}+a +{abs+a:pre(a); m} .\\a:{abssa:~; fi} +{abs~a:abs; ~} \n Last, abbreviate { abs + p } as If (p) to conclude that Ifll possessesall the primitives of II with \nall types that II can assign to them. The rest of the language II is core ML and is also in 1111. Examples \nWe show a few examples processed by a prototype written in CAML [CH89, Wei89]. The type inference engine \nis exactly the one of II; only the primitives have changed. The syntax is similar to CAML syntax. The \ntype of a one field record says that the record cannot be merged with another record defining this field: \n#let a= {a = l};; a:{a:abs; x ~ a:pre (num); X} Two records r ands can be merged if they do not define \ncommon fields. For instance, r can be merged on the left with {a= 1} if its output row on a is absent. \n #let leftr= r[/{a = l};; Ieft:{x a a:abs; m} + {X a a:pre (num); m} The resulting record mo(iifies \nits input row as r but on field a which is added, Similarly, s can be merged on the right with a if the \ninput field a is present (with the right type). #let right s= {a = 1} IIs;; right: {a:pre (num); x + \nm} + {a:abs; x +-m} In particular, s cannot define an a field, otherwise its input field a would be \nabsent. Non overwriting of fields is guaranteed on the left by negative information (absent field) at \na positive occurrence (row), and on the right by positive infor\u00admation (present field) at a positive \noccurrence (row). Some symmetry is preserved! However writing r [1 s instead of s [/ r in a program sometime \nmatters: one might typecheck while the other does not, though none of the programs would overwrite fields. \nIf both type\u00adcheck, the type of the result will be the same (provided all fields are symmetric). Here \nare a few more examples: #let foo = fun r s --+ (r II s).a;; foo:{a:abs; x + x} -+ {z ~ a:pre (r?); g} \n-8 This shows the functionality of concatenation on both sides. The result shall have an a field, but \nwe do not know which argument will provide it. #let gee = foo {b = l};; gee:{ b:pre (num); a:abs; x + \na:pre (0); m} -+ 8 Now, the argument of gee must define the a field. #gee a;; it:num Asymmetric concatenate \nion The system II may also provide free extension, with the following primitive: {with !a=.}:II (a:abs; \nX)--+ a+lI(a:pre(a); X) This will make concatenation asymmetric: {!a=-}: a-+{a:O; x+a:pre(~); x} This \nprimitive is already definable in Dll by: Ax. Au. (u\\a) ]I{a=z} #let ab = # (fun r-+ {!a = 1} IIr) {!a \n= true; !b= l};; ab: {a:a; b:~; x + a:pre (boot); b:pre (num); x} This shows that asymmetric fields \ncan be redefined with values of possibly incompatible types. The choice between strict and free extension \nis en\u00adcoded in the extension primitive, but the choice be\u00adtween asymmetric and symmetric concatenation \nis not encoded in the concatenation primitive which is al\u00adways the composition. It is not concatenation \nwhich is symmetric or not but record fields themselves! We can have symmetric and asymmetric fields coexisting \npeacefully. #{!a = 1; b = true};; it: {b:abs; a:a; x + a:pre (num); b:pre (booI); x} Primitives to modify \nthese properties of fields can eas\u00adily be provided s~ma:{a:6; X*a:pre(a); X} +{a:abs ;X%a:pre(a); X} \nasym :{ a:~; x+a:pre(a); x} --{a: e; X+a:pre(a); X} But it is not possible to make all fields of a record \nsymmetric, or asymmetric; this has to be done field by field. With asymmetric fields, the following examples \nreach the limit of ML polymorphism. For instance, the function #fun rs+ s.b, rIIs;; it: {X + b:abs; T} \n-+ {b:abs; z a b:pre (r9); $} + 6 * {X + b:pre (@); f} does not accept a record r which has a b field, \nthough the program would still run correctly if the b field of s is asymmetric. This is due to ML polymorphism \nweakness: the second argument is A-bound and thus is not polymorphic. The field b of s is observed by \nsetting its input to abs, which has to be the output field bof rinrIIs. Since s has definitely a b field, \nthe concatenation r II s is equal to the concatenation r \\ b Ii S. we call rewrite the previous program \nas #fun r s + s.b, (r\\b II s);; it: {b:cz; X + b:~; m} --+ {b:abs; T + b:pre (f?); f} -+ f? * {b:abs; \nx * b:pre ($); g} which can now be applied to any record r. The restriction _\\b of field b only changes \nthe type of its arguments but does not modify it; it is called a re\u00adtyping function . Many weaknesses \nof 1111originating in the restricted polymorphism provided by the ML type system can be solved by adding \nretyping func\u00adtions. They insert type information in the program helping the type inference engine. We \nwill describe other ways of solving these examples by strengthening the type inference engine in section \n2.3. 2.3 Strength and weakness of Hll We compare our language with Wand s pro\u00adposal [Wan89], and Harper \nand Pierce s system and mention possible extensions. Comparison with other systems There are only a few \nother systems that implement concatenation. Wand s proposal [Wan89] is still more powerful that our system \nHll. For instance is typable in Wand s system but not in ours. Wand s system polymorphism is carried \nby the concatenation operator, at the cost of bringing in the type system a restricted form of conjunctive \ntypes and having dis\u00adjunction of principal types instead of unique principal types. In contrast, in our \nsystem, polymorphism is carried by records themselves. As mentioned above, we can regenerate polymorphism \nof records by insert\u00ading retyping functions. If the same restricted form of conjunctive types was brought \nin our system, then 17\u00ad 1/4 retyping functions would be powerful enough to regen\u00aderate all fields of \na record without having to mention them explicitly. This would give back all the power of Wand s system. \nThis shows that the additional power of Wand s sys\u00adtem comes from conjunctive types. Conversely, our \nsystem succeeds with only generic polymorphism on examples that needed conjunctive types in Wand s sys\u00adtem. \nWe are going to explain how this happens. Wand s system can be reformulated in system IL A simple idea \nis to type the concatenation operator by introducing an infix type operattor II of arity two: II :rI(~)+ \nrI(7r)-+II(~l17r) But we have to eliminate [1operators that might hide type collisions. In the system \nII, we entice distributing concatenation on fields with the equations: The field operator II can be defined \nby enumerating the triples (0, e,@ II c). They are all triples of the form (0, abs,@) or (d,pre (@),pre \n(~)). This disjunction in the relation II breaks the principal type property of type inference. Worse, \ndisjunctions on different fields combine and make the resulting type (conjunction of types) explode in \nsize. Our system emphasizes that O II s is uniform on 6: once we know .s, we can eliminate the conjunction \nin O II s. A field a, instead of carrying its type E, carries the function O ~ d II e. For instance, \nif ill has type ~, the record {a= M} would have type If(a: pre (~); abs ) in II. On field a, since s \nis now pre (~), the merging 0 II s is equal to pre (-r). In the ternplate, m is abs, and thus x II m \nis x. We deduce the type in 1111: { (a:fl * pre(T)); (X +-X) }, i.e. { (a:6; x) * (a:pre(~);x) }. Another \nsystem with type inference was proposed by Ohori and Buneman in [OB88]. Their concatenation on records \nis recursive concatenation, which we do not provide. Note that they have a very restricted form of recursive \nconcatenation since types in record fields must not contain any function type. In explicitly typed languages, \nthe only system with concatenation is the one of Harper and Pierce [HP90b]; it implements symmetric concatenation. \nSince their system is explicitly (higher order) typed, we say that typing a Ifll program h4 succeeds \nin HP90 if we can find a HP90 program whose erasure (the program ob\u00adtained by erasing all type information) \nis M. Their system has not free restriction of fields, but we shall ignore this difference. The following \n1111program cannot be typed in HP90: #let either r s = (r II s).a in # if true then either {a = 1} {b \n= 2} # else either {b = 2} {a = l};; it:num In the expression (r II s).a, one has to choose whether \nr or s is defining field a, and thus the function either cannot be used with two alternatives, This breaks \nthe symmetry of concatenation. Conversely, there are programs that can be typed in HP90 but not in Ifll \nas a result of ML polymorphism restrictions. For instance the function #let reverse r s = if true then \nr II s else s II r;; reverse:{x * x} + {x => x} --+ {x %-x} cannot be applied to {a = 1} and {b = 2} \nin 1111.In HP90 it would have type  vx. v7r#x. x+7r+(x[17r) and could be applied to any two compatible \nrecords. It is difficult, though, to tell whether the failure comes from a limitation of polymorphism \nin general, or the inability to quantify with constraints, since the two are strongly related. Next section \nprovides a better basis for comparison between the two systems. Limitations and extensions Since the \ntype inference engine of 1111is the same as the one of II (only types of primitives have changed), both \nsystems enjoy the samle properties, Record poly\u00admorphism is provided by ML genericity introduced in let \nbindings. If this is too restrictive, then one should introduce type inclusion. One could also have a \nre\u00adstricted conjunctive engine as in [Wan89]; however this would decrease considerably the efficiency \nof type inference, and the readability of types. Allowing re\u00adcursion on types would also require an extension \nof the results (though in practice the mechanism is al\u00adready present). In I Ill, as in II, present fields \ncannot be implicitly forgotten, but have to be explicitly re\u00admoved, unless the structure of fields is \nenriched with flags. All these improvements are discussed in detail in [R6m91b]. 3 Other applications \nThe transformation can also be applied to other lan\u00adguages. 3.1 Application to Harper and Pierce s calculus. \nThe higher order typed language of Harper and Pierce [HP90a] already possesses concatenation, but records \n173 are not abstractions. It can still benefit from the en\u00adcoding. Instead of presenting special constructs \nfor opera\u00adtions on records, we could assume given the following primitives in their language: {} {} ..a:Va. \nVx#a. ({a:a} [[x)-+ a, {a=_} :Vo4a--+{a:a} \\a:Va. Vx#a({a:a}llx )+x II :vx. v7r#x. x+7T--+(xll7r) Primitives \nfor HP90. But the type system is not enough sophisticated to type the primitive {. but a from -}. Thus \nwe apply the translation dropping the removal of fields. Using the encoding, the primitive operations \non records in the language HP9011 have the following types: {}: VX. (X*X) -.a:Va VX#a. V7r#a. (X*{ a:a} \n[Im)+a {a=_} :va. a+vx#a. (x+{a:a}\\[x) \\\\ :vx. vfl. v~. (x+m)+(m+~)+(x=() Primitives for HP9011. We \ncan define a function either: Aa. Ax. Ax#a. Ar:({}a X). As:(X*{a:a}ll n). (-a [4 [{ }1[T] (1I [{ }1[xl \n[{a:~} IId T s)) and apply it to records {a= 1} and {b= 2} in any order. For instance, either [num] \n[{a: num }] [{b: num }] ({a= 1} [{ }]) ({b=2} [{a: num}]) Remind that this example is not typable in \nHP90. Conversely, the program letreversers=iftrue then rIIselses IIr in reverse {} {a = 1}, reverse {} \n{a = l};; can be typed in HP90, but we conjecture that it cannot be typed in HP9011. In fact its typability \nin HP II is equivalent to the following term being the erasure of a term of F with the constant U of \ntype A a. a + a --+ a: (fun r--+ K(r IK)(r KI)) U(funfg +(funx+f(g x)) (fun x -t g(fx))) where Ibefunx+x \nand Kisfunxy +x. To summarize none of the language HP90 or HP9011 would be strictly more powerful than \nthe other. Re\u00admark that type applications and type abstractions are located in completely different places, \nthus a partial translation of explicitly typed terms from HP9011 to HP90 can only be global. A previous \nlanguage proposed by Harper and Pierce in [HP90a] had no concatenation, but shared the same spirit as \nHP90. The transformation applies to it as well, and results in a language with concatenation closed to \nHP9011.  3.2 Application to Cardelli and Mitchell s calculus. Unlike Harper and Pierce s calculus, the \nlanguage of Cardelli and Mitchell [CM89] does not already pro\u00advide concatenation of records, but only \nstrict exten\u00adsion, The encoding applies to it and results in a lan\u00adguage very similar to HP90. The language \ncannot be easily extended with the combining construct, there\u00adfore we skip the removal of fields. Using \nCM89 types, primitives for records operations in CM8911 have the following types: {}:vx. (x+~) _.a:Va. \nVx<(()) \\a. V7r<(())\\a. (x=+ ((7r/\\a:a)))-+a {a=-} :Va. a+ Vx<(())\\a. (x +((xlla:a))) II :Vx-vm. v(. \n(x+ fi)+(fi+f)+(x+g) Primitives for CM8911. We can again define the function either: Aa. AX. An<(())\\a. \n~~:((())+x).~s: (x+ ((~lla:a))). (- a[al[(())1[~1(11[(())1[X][((mIIa:a))] T s)) and apply it to the \nrecords {a= 1} and {b= 2}: either [num] [((a: num))] [((b: num))] ({a =1} [(())]) ({b= 2} [((a: num))]) \n 3.3 Multiple inherit ante wit bout record concatenation Multiple inheritance has been encoded with \nrecord concatenation [Wan89]. We have encoded record con\u00adcatenation with record extension. By composition, \nmultiple inheritance can be encoded with record ex\u00adtension. Given the strengthening of the type inference \nengine to recursive types, the system Ifll would support multi\u00adple inheritance as presented in [Wan89]. \nBut multiple inheritance makes very little use of concatenation. It is only necessary for building new \nmethods, but objects do not need it. Thus it may be worth revisiting the typechecking of multiple inheritance \nof [Wan89] and eliminating the need for concatenation by abstracting methods as we abstracted records. \nThe following encoding of multiple inheritance was used by Wand in [Wan89]. The definition of a class \nclass (Z) inherits ~ + methods a = A4 end was encoded as AZ. A self. P(Q)l {a=} The creation of objects \nof that class instance C(iV) was the recursive expression Y(c(iV)) Sending a method a to an object \nx was the same as reading the field x of a. The problem with this encod\u00ading is that it requires record \nconcatenation. We can easily get read of it, using our trick. We encode a class definition as i.e. AZ. \nAu. ~ self. {F (@ o u with a] which only requires record elctension. Then creating an object of that \nclass becomes Y(c(i){}) and sending a method is unchanged. Remarks Since removing of fields is not needed \nhere, this section applies ~0 all typed calculi with record extension. This section uses Wand s conception \nof inheritance. Objects are carrying their dictionaries. Other views of objects do not encode with record \noperations. This section does not apply to the:m. Conclusion We have described how a functional language \nwith records and record extension automatically provides record concatenation. Though records are data, \nthey should be typed as if there were abstractions over an input row of fields that they modify. Their \nbehavior can be observed at any time by giving them the empty row as input. Concatenation is then composition. \nWe have applied the methcjd to a record extension of ML. We have obtained a language implementing all \noperations on records except the recursive merge, allowing type inference in a very efficient way in \nprac\u00adtice. The extra information in abstract record types is useless if one does not need concatenation, \nand whether concatenation should be provided or encoded depends on how much use of it is made. The kind \nof type system that we have obtained seems complementary to Harper and Pierce s one. Ex\u00adploiting the \nbest of the two systems would be interest\u00ading investigation. The encoding also helps understanding concatena\u00adtion. \nHowever the relationship between the semantics of a program in the language with concatenation and the \nsemantics of its translation need to be investigated closely before claiming that concatenation itself \ncomes for free. Acknowledgments I am grateful for interesting discussions with Luca Cardelli, Georges \nGontlhier, Benjamin Pierce and Mitchell Wand, and particularly thankful to Xavier Leroy whose comments \non the presentation of this ar\u00adticle were very helpful. References [Car86] Luca Cardelli. Amber. In Cornbinators \nand Functional Programming Languages, vol\u00adume 242 of Lecture Notes in Computer Sci\u00adence, pages 21-47. \nSpinger Verlag, 1986. Proceedings of the 13th Summer School of the LITP. [CH89] Guy Cousineau and G&#38;ard \nHuet. The CAiWL Primer. Institut National de Recherche en In formatique et Automa\u00adtism, France, 1989. \n[CM89] Luca Cardelli and John C. Mitchell. Op\u00aderations on records. In Fifth International Conference \non Mathematical Foundations of Programming Semantics, 1989. [HMT90] Robert Harper, Robin Milner, and \nMads Tofte. The definition of Standard ML. The MIT Press, 19!)0. [HP90a] Robert W. Harper and Benjamin \nC. Pierce. Extensible records without sub\u00adsumption. Technical Report CMU-CS-90\u00ad102, Carnegie Mellon University, \nPittsburg, Pensylvania, February 1990. [HP90b] Robert W. Harper and Benjamin C. Pierce. A record calculus \nbased on symmetric con\u00adcatenation, Technical Report CMU-CS-90\u00ad157, Carnegie Mellon University, Pittsburgh \nPensylvania, February 1990. [JM88] Lalita A. Jategaonkar and John C. Mitchell. ML with extended pattern \nmat thing and subtypes. In Proceedings of [OB88] [Oho90] [R6m90] [R6m91a] (R6m91b] [Wan87] [Wan88] [Wan89] \n[Wei89] the 1988 Conference on LISP and Func\u00adtional Programming, 1988. Atsushi Ohori and Peter Buneman. \nType inference in a database langage. In ACM Conference on LISP and Functional Pro\u00adgramming, pages 174 \n183, 1988. Atsushi Ohori. Extending ml polymor\u00adphism to record structure. Technical re\u00adport, University \nof Glasgow, 1990. Didier R6my. Alg2bres Touffues. Appli\u00adcation au Typage Polymorphe des Objects Enregistrements \nclans les Langages Fonc \u00adtionnels. Thkse de doctorat, University de Paris 7, 1990. Didier R6my. Syntactic \ntheories and the algebra of record terms. Technical report, Inria, Rocquencourt, 1991. To appear. Also \nin [Rem90a], chapter 2. Didier R6my. Type inference for records in a natural extension of ML. Technical \nRe\u00adport 1431, Inria, Rocquencourt, May 1991. Also in [Rem90], chapter 4. Mitchell Wand. Complete type \ninference for simple objects. In Second Symposium on Logic In Computer Science, 1987. Mitchell Wand. \nCorrigendum: Complete type inference for simple objects. In Third Symposium on Logic In Computer Science, \n1988. Mitchell Wand. Type inference for record concatenation and multiple inheritance. In Fourth Annual \nSymposium on Logic In Computer Science, pages 92-97, 1989. Pierre Weis. The CAML Reference Manual. Institut \nNational de Recherche en Informa\u00adtique et Automatisme, France, 1989.  \n\t\t\t", "proc_id": "143165", "abstract": "<p>We show that any functional language with record extension possesses record concatenation for free. We exhibit a translation from the latter into the former. We obtain a type system for a language with record concatenation by composing the translation with type-checking in a language with record extension. We apply this method to a version of ML with a record extension and obtain an extension of ML with either asymmetric or symmetric concatenation. The latter extension is simple, flexible and has a very efficient type inference algorithm in practice. Concatenation together with removal of fields needs one more construct than extension of records. It can be added to the version of ML with record extension. However, many typed languages with record cannot type such a construct. The method still applies to them, producing type systems for record concatenation without removal of fields. Object systems also benefit of the encoding which shows that multiple inheritance does not actually require the concatenation of records but only their extension.</p>", "authors": [{"name": "Didier R&#233;my", "author_profile_id": "81100311096", "affiliation": "", "person_id": "PP39077767", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143202", "year": "1992", "article_id": "143202", "conference": "POPL", "title": "Typing record concatenation for free", "url": "http://dl.acm.org/citation.cfm?id=143202"}