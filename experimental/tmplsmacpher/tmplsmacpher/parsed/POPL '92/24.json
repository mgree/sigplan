{"article_publication_date": "02-01-1992", "fulltext": "\n Parametricity as Subtyping (Preliminary Report) QingMing Ma* School of Computer Science Carnegie-Mellon \nUniversity Qingming .Ma@cs. cmu. edu Abstract A polymorphic function is parametric if it has uniform \nbehavior for all type parameters. This property is use\u00ad ful when writing, reasoning about, and compiling \nfunc\u00ad tional programs. We show how to syntactically define and reason about parametricity in a language \nwith intersection types and bounded polymorphism. Within this framework, parametricity is subtyping, \nand reasoning about para\u00ad metricity becomes reasoning about the well-typedness of terms. This work also \ndemonstrates the expressive\u00ad ness of languages that combine intersection types and bounded polymorphism. \n1 Introduction A polymorphic function is parametric if it uses the same algorithm regardless of which \ntype parameter is inst an\u00adtiated. As a consequence, it has a uniform behavior over all type parameters, \nin the sense that for any related in\u00adputs, the function produces related outputs. Let us look at an example. \nConsider the polymorphic doubling function double = Ar. ~~,+r. kc, . $($x) : VT.(T+7)+.(T--W). By passing \nint and bool to this function, we get the doubling functions for int and bool: doubleint = ~ji~~+i~~. \n/lZi~~. ~(fZ) : (int+int)+(int+int)  This research was supported in part by NSF Grant CCR\u00ad8922109 and \nin part by the Avionics Lab, Wright Research and Development Center, Aeronautical Systems Division, U.S. \nAir Force, Wright-Patterson AFB, OH 45433-6543 under Contract F33615-90-C-1465, Arpa Order No. 7597. \nPermission to copy without fee all or part of thk material is granted provided drat the copies are not \nmade or distributed for direct commercial advantage, the ACM copyright notice and Use title of the publication \nand its date appear, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy other\u00ad wise, or to republish, requires a fee and/or specific permission. @ 1992 ACM \n089791-453-8/92/0001/0281 $1,50 doub!ebool = ~~bOOl+bOO1. ~~bool. ~(j~) : (bool+bool)-+(bool--+bool) \n Although doubleint and doublebOOl accept arguments of different types, they have the same algorithm. \nNamely, for any inputs j and x, the computation of double ap\u00adplies the f twice to the x. Assume that \nwe represent bool by int in such a way that even numbers represent true, and odd numbers represent false. \nThat is, we have a relation R ~ int x bool such that R = {(2n, true)} U {(2n + l, false)} . Given g: \nint+int and h: bool~bool. The function g is said to represent h iff (n,b)6 R implies (gn, M) eR , or, \ng relates h by RsR. Parametricity of double im\u00adplies that, if g represents h, then doubleintg: int+int \nrepresents doub!eboolh: bool+bool as well, i.e., (n, b) c R implies (doubleintgn, doubleboo~hb) E R . \n This can be checked out straightforwardly, since dottbleintgn = g(gn) and doub!eboo~hb = h(hb). If we \nlet even?: int -+bool be the representation func\u00adtion that tests whether an integer is even or odd, then \nthat g: int+int represents h: bool+bool is equivalent to saying that g and h satisfy the equation even?og \n= hoeven?. Parametricity of double implies that doubleintg and doubleboolh satisfy the same property: \neven? o (doubleintg) = (doubiebOOlh) o even? . In fact, this property holds not just for the function \ndou\u00adble but for all functions of the type dr.(r+-r)+(~-+~). In other words, for any polymorphic type \n(e.g. V~.(~~~)~(~ar)), there is a property (or condition), called parametricity, which is detertnined \nby the struc\u00adture of the type and possessed by all parametric poly\u00admorphic functions of this type. The \nproperty is not derivable from rules for computing polymorphic func\u00ad tions (e.g. @q-rules). Nevertheless, \nit is useful when writing, reasoning about, and compiling functional pro\u00ad grams. This property is possessed \nby the polymorphic functions in the languages such as Fun [7], Quest [5], and Leap [18], where polymorphic \nfunctions are %rst\u00ad class values , as well as by the polymorphic functions in ML-like languages, where \npolymorphic functions are not first-class values . At this point, one may ask: How can one systemat\u00ad \n ically reason about parametricity so that one needn t prove free theorems ([27] ) over and over again? \nHow can one show that a given polymorphic function satisfies the parametricity condition of its type? \nIn this paper, we propose a syntactic method to de\u00ad fine and reason about parametricity. We study the \nparametricity of the Girard-Reynolds system F in a language called Target, which is a variant of Pierce \ns system FA ([20]) that contains intersection types and bounded polymorphism. The parametricity condition \nfor each polymorphic type in F is represented as a subtyping relation, and reasoning about parametricity \nbecomes a simple matter of reasoning about the well typedness of terms in Target. We also extend this \nmethod to studying parametricity of FA. To make the point clear, we first briefly describe inter\u00ad section \ntypes and bounded polymorphism. Intuitively, intersection types are kinds of finite polymorphism, and \nbounded polymorphism is polymorphism where type parameters may be limited to a certain range of types. \nA term e has an intersection type U1 A 02 if it has both type UI and type U2; and a term e has a bounded \npolymorphic type Vr<ul. V2, if e has the type U2 under the assumption T < al of subtyping. A polymorphic \nfunction e of type Vr<ul. U2 can only be instantiated to those type parameters that are subtypes of U1, \nWe view a relation R between two types u and u as a subtyping relation S(R) < u x u in Target. For each \npolymorphic type Vi-u in F, we have a type (VT. u)* and a subtyping relation (Vr. a) < (VT. a) x (VT. \na) in Target. The parametricity condition for VT. a is determined by the subtyping in the sense that \na poly\u00admorphic function p of the type VT. a is parametric iff the typing judgement + (Z%P) : (v~. u) \n is valid in Target. We show that all polymorphic func\u00adtions defined in F have this property. Let us \ngo back to the above example. For the type d~.a = V~.(~+r)+(~-+~), the type (VT. u)* is defined to be \n(VT . u)* = v~%- vr<x~ ~ . (&#38;+d)A(#xd ) where 0 = (~-~) A (( T +T ) x (T + T )), CT = [T /I-]a, \nand u = [~ /~]a. Assume we have established that all polymorphic functions in F satisfy the parametricity \nconditions of their respective types. Then we have the following valid typing judgement in Target: F \n(double, double) : (VT. a) , By substituting # and ~ with int and bool and r with the type S(R) determined \nby the relation R ~ int x bool and applying a typing rule for intersection types, we have the following \ntyping judgement: 1-(doubleint, doublebOOl) : (($(R) -+S(R)) A ((int--+int)x(bool+bool))) +((S(R)+S(R)) \nA ((int+int) x (bool+bool))) . Hence, for g : int-+int and h : bool-+bool, if ~ (9, h) : (c$(R)-+S(R)) \nA ((int+int) x (bool+bool)) ~,~~{;g) maps pairs related by R to pairs related by > h (doubleintf, doubleboolg) \n: (S(R) -+S(R)) A ((int--+int)x (bool+bool)) . i.e., (doublei~t~, doubleboo~g) also maps pairs related \nby R to pairs related by R. Hence, the property for dou bleint and doubiebOOl we discussed above is derived \nfrom reasoning about the well typedness. The study of parametricity was initiated by Reynolds in [24], \nwhere parametricity conditions were defined in terms of naive set-theoretic models by using second\u00adorder \nlogical relations. Parametricity has received much attention in recent years. Here is a brief summary: \n Parametricity has been further studied by Mitchell and Meyer [17], Bainbridge, Freyd, Scedrov, and Scott \n[3], Freyd [11], Abramsky, Mitchell, Scedrov, and Wadler [2], Abramsky and Jensen [1], Cardelli, Mitchell, \nMartini, and Scedrov [6], and Ma and Reynolds [15]. The focus of this research is on model-theoretic \naspects of parametricity, such as representation independence, observational equiv\u00adalence, strictness \nanalysis, constructing parametric models.  Wadler [27] gave many interesting examples show\u00ading how to \nget free theorems in functional pro\u00adgramming and program verification by using para\u00admetricity. Since \nsecond-order logical relations can be formalized in second-order logic systems, this leads to Mairson \ns ([16]) proof-theoretic study of parametricity.  282 Parametricity introduces equalities between func\u00adtions \nthat are not implied by usual computation rules (e.g. @-q rules). Using these equalities prop\u00aderly, the \ncomputation of a polymorphic function may be substantially simplified, and also more effi\u00adcient code \nmay be generated by a compiler. Pfen\u00adning [19] pointed out the possible connection be\u00adtween parametricity \nand uniqueness of the repre\u00adsentation of a term in an inductive type. However, to date, parametricity \nhaa been mostly stud\u00adied at the model level. (Mairson s work is an exception. We ll discuss this later.) \nTherefore, it is not easily un\u00adderstood by people who are unfamiliar with model the\u00adory. This is because, \nfor the polymorphic languages, the models themselves are already difficult to understand. Hence, it is \ndesirable to have a syntactic treatment of parametricity, so that it can be easily understood and convenient \nto reason about. The paper is organized as follows. In section 2, we introduce the source languages F \nand F~ and the tar\u00adget language Target. We study parametricity of F in Section 3. In section 4, some \nexamples are given to show that Walder s free theorems can be recast in out framework. In section 5, \nwe discuss some model\u00adtheoretic issues of our method and give some initial re\u00adsults about parametricity \nof PER models. In section 6, we extend our method to studying parametricity of the system FA. 2 Languages \nIn this section, we introduce briefly three languages: F, F~, and Target. Both F and FA are source lan\u00adguages. \nWe study parametricity of F and F~ by trans\u00adlating them into Target, 2.1 The system F The Girard-Reynolds \n[13, 23] system F provides a type\u00adtheoretic formalization of parametric polymorphism by adding to the \nordinary typed lambda calculus the ability to pass types as parameters. The set of F types are defined \nby u ::= 7-I al+cz I VT.U The set of unchecked F terms are defined by: e::= z IAr:a. eIe2el IAr. eIe[u] \n A context I is a finite (possibly empty) set of variables with associated types that are assigned by \nr: r={%~:o~,. ... zn: an} such that no variable occurs twice. Typing judgments have the from I 1-e:a, \nwhich means that the term e has type u under the con\u00adtext 17. The valid typing judgments in F are those \nthat are provable from the following typing rules: (T-AP) We skip the equational rules (e.g. @and q-rules), \nThe details can be found in [13, 23]. The system introduced is an explicitly typed version of F An implicit \nF can be got by erasing type informa\u00adtion in e of 171-e : u above: Erase(z) = r Erase(Xz: a. e) = Az. \nErase(e) Erase (e2el) = Erase(e2)Erase(e1) Erase(Ar. e) = Erase(e) Erase(e[u]) = Erase(e) For any type \nderivation for r F e : u in the ex\u00adplicit F, there is a corresponding type derivation for I F Erase(e) \n: a in the implicit F. However, we note that, in explicit F, type derivation is unique for a well\u00adtyped \nterm. But this is no longer true in implicit F. 2.2 The system F~ The system FA, introduced in Pierce \ns dissertation [21], is a calculus that combines intersection types ([25]) and bounded polymorphism ([7]). \nThe system presented here is an implicitly typed version. More information about syntactic, semantic, \nand pragmatic details can be found in [21]. Information about intersection types or bounded polymorphism \ncan be found in [4, 22, 25, 26] or [6, 7, 8, 9, 10, 12, 20]. The set of FA types is defined by: Here \nA is the binary intersection operator, ns denotes the null intersection, and VT~Ul. U2 is for bounded \npoly\u00admorphism. We denote Vr<ns. U2 as VT. 02. A type context is a sequence of type variables with associated \nbounds, such that no type variable T is defined twice, and no defined type variable appears in its own \nbound or in the bounds of type variables defined to its left. Subtyping judgments are of the form: which \nmeans that the subtyping relation U1 + IY2 holds under the type context @. The valid subtypmg judgm\u00ad \nents in FA are those that are provable from the sub\u00ad typing rules listed in the Appendix, Term contexts \nof FA are defined recursively as follows: r::= {}lr; r<alr; %:a such that f , got by erasing the declarations \nof the form x: u, is a type context. Typing judgments in FA are of the form I te:O. Equality judgments \nin FA are of the form I Fe =e :0. Subtyping rules, typing rules, and the equational the\u00adory of FA appear \nin the Appendix. 2.3 Target Target is a variant of Pierce s FA. First, product types (ux p) and related \nsubtyping rules are added in order to study binary {relations . Accordingly, the new terms of the forms \n(e , e ), fst (e), and snd(e) are added. This addition is unnecessary if we just want to study unary \n<relations . Second, some extra subtyping and typing rules are used. These special rules are listed in \nthe Appendix. For parametricity with unary relations, only two extra rules are needed. They are PRE-DEF \nand Q-LB. The rule DIST-IP is used for studying parametricity of FA, otherwise can be omitted. Third, \nTarget is an open language in the sense that it is parametrized by predefine types and predefine subt \nying relations between closed types. This makes it possible that, for different applications, Target \nmay subscribe different predefine types and predefine sub\u00adtyping relations. Also, for the special purpose \nof this paper, we have the form (e , e ) : u of typing, when u is a subtype of a product type u! x v \n). It denotes a term of u that is coerced to (e , e ) by the coercion function from a to u xUlf. 3 Parametricity \nof F We study parametricity of F and explain informally why our met hod works. 3.1 Parametricity We \nstudy parametricity of the system F. For each type u in F, we define a type u in Target. For each type \nderivation 17 F e: u in the explicit F, we have a cor\u00adresponding type derivation for r 1-Erase(e): a \nin the implicit F. We translate the latter type derivation to a type derivation for I * F (Erase(e), \nErase(e)): u* in Target, whereby the parametricity for e can be rea\u00ad soned about. In the following discussion, \nwe neglect the erasing procedure from the explicit F to the implicit one, and treat all type derivations \nas in the implicit F. Let c be an arbitrary type in F with free type vari\u00ad ables {1-1, . . . , ~n}. Then \nu is also a type in Target. Let @ be the type context ~j<ns;rfl<ns;rl<r{x~f, . . . ,7-~< ns;7{<ns; r. \n< ~~xr~, and let o = [~{/rl, . . . . r~/rn]u and a = [rf/r,, . . . . rn /~n]a, where all ~~ and r: are \nfresh type variables in Target. Note that, if a is a closed type, then u!= u = u. We inductively define, \nfor each type u in F, a type a in Target as follows: * T > (U+p; = a +~ A ((0 --+/) X(d +p )) , (VT a)* \n= VT f. VT . VT<T{ Xrf . U* . Lemma 3.1 In Target, the following subtyping judge\u00adment is valid: el-c \n<u xa . Definition 3.1 Let VT. u be a closed type. A polymor\u00adphic function of the type dT. u is parametric \nifl + (P)P) : W-. ~) is valid in Target. We now prove that all closed terms of polymorphic types in \nF are parametric. Following the work in [24], we prove a more general result, i. e., the Abstraction \nTheorem. Let r be the context {xl: al, . . . . xk: ok}. Notice that we have ei-aj<o:xufl (l<i<k). We \ndefine a context r*=@; (~~, x~):a~, . . ..(O~. x#):ai, in Target, where all zj and z: are fresh variables \nin Target. Foe each term e in F, we define e = [c~/rn, . . . ,z~/x~]e , II e = [z{/cn, . . . ,z~/x~]e \n. Then, for each derivation J7 k e : u in F, we define a type derivation r* F-(e , e ) :u* in Target \nby induction on the typing inference rule used in the last step in deriving the typing judgement in F. \n c If I? 1-e : u is got by using the rule (VAR), then r* 1-(e , e ) : 0 is got from (z , d ): U* c r* \nr* t-(d, z /): O* c If r 1-e : a is got by using the rule (ABS), then r* t-(e , e ) : 0 is got from r*; \n(z , z ) : O* 1-(e , e ) : P* r* 1-(k , e , kv . e ) : (u-p) by the rule ARROW-I , If I t-e : 0 is got \nby using the rule (AP), then r* 1-(e , e ) : a is got from r* F (e;, e~) : u* r* t-(ej, efj ) : (u-p) \nr* i-(e~e~, e~ej) : p by the rule ARROW-E . If r 1-e : u is got by using the rule (T-ABs), then r* 1-(e \n, e ) : u* is got from r*; r <ns; r <ns; r<r xr 1-(e , e ) : u* r* F (e , e ) : VT VT VT<7 XT . O* If \nr 1-e : a is got by using the rule (T-AP), then r* 6-(e , e ) : u* is got from r* t-(e , e ) : (V7-. \na) P E a < a xd r F (e/, e ~) : [a*/~][al/#, cd /@* Lemma 3.2 For any types u and m in F, we have ([a/T] \na)* = [a*/T][a /T , a /T ]u* . Proposition 3.1 [Abstraction Theorem] 1} I 1-e : a is a valid typing \njudgement in F, then r* 1-(e , e ) :u in Target Note that each valid typing judgement in F is a valid \ntyping judgement in Target aa well. So, the Abstrac\u00adtion Theorem is equivalent to saying that I te:u \nr* 1-(e , e ) :a is a valid typing rule in Target for all valid typing judgments 1?b e : u in F. Corollary \n3.1 [Parametricity] Let VT. u be a closed type, and 1-e :0 be valid in F. Then 1-(e , e ) : (VT. U)* \nis valid in Target. The above proving process provides us a syntactic way to use parametricity by viewing \nthe parametricity condition of a polymorphic type Vr.u as the subt yping e 1-(vT.U)*x (vT.&#38;).  \n  < (VT.C7) To reason about parametricity of a term r t-e : Vr. u, we use the valid typing judgement: \nr* F (e , e ) :(VT. u) . As we noted before, Target may subscribe different predefine types and subtyping \nrelations. Accordingly, the parametricity conditions defined may have differ\u00adent meanings. For a particular \napplication, we may de\u00adfine Target with a particularly choose set of predefine types and subtyping relations. \nFor example, we may define the set of predefine types and subt yping relations such that, for any two \nclosed types a and a ! , and any subset R of closed terms of at x a)!, i.e., there is a constant type \nS(R) and a pre\u00addefine subt yping relation 1-S(R) <P,, d X d , such that for 1-e :a and t-e :al) in F \n1-(e , e ) : S(R) iff (e , e ) e R . In many cases, we do not want to distinguish between terms that \nare provably equal in F. Hence, every pre\u00addefine type S(R) should be closed terms that are prov\u00adably \nequal in F. This property is preserved by the con\u00adstruction of u*. We only consider such cases in this \npaper. 3.2 Relations as subtyping Parametricity is originally defined in [24] by second\u00adorder logical \nrelations. As shown in [15, 2] to define second-order logical relations, one first need to have a set \n1? of relations between closed types. This 7? may be chosen differently for different applications. But \n7Z should be closed for the relation operators ~ and V de\u00adfined below. Let R o and RP ~ be two relations. \nA relation R s *RP IP over types u +p and u +p is defined such that, for r i-f : Ut+pl and r 1-j 11: \nu +.p , (f , f ) 6 R ,u ~Rp ,P iff (V(e , e ) E R  ) (f e , f e ) e RP Ifl . To define relations on \na variable type u, let us assume that u contain only one free type variable r. Since the r in u may be \nsubstituted by different type parameters, a relation RO O on CTshould change along with differ\u00adent relations \nbet ween type parameters. Hence, RUI should contain a relation variable R . By substitut\u00ading RT with \nRa se , we get a relation [Ra a /RT]RU between [cr /~]a and [a? /~]a. The relation VRT. R on v r. u \nis defined such that, for any F p :vr. u and k p : dT.a, (p , p ) GVR . RO iff (VRa @ e 7?) (p [a ], \np [a ]) ~ [Ra @ /RT]Ru . If u contains n+ 1 free type variables, then n+ 1 re\u00ad lation variables are \nused, and the relation operator V is defined pointwise by fixing n relation variables to n relations \nat a time. By reviewing each relation R  on closed type u and u as a subtyping relation F S(RU lU \n) < U Xa suc,h that S(R q ) has all elements that are related by R o , the relation operators s and \nV can be properly represented by intersection and bounded quantification constructors, Let C and u be \ntwo types in F, ~h~~h contains type variables rl, . . . . rn. Any relation RO ~ between u and u should \ncontain n relation variables. Hence, the sub\u00adtyping corresponding to R  is of the form e E S(RO J ) \n< U xu , where @ is as in Section 3. Assume that we have established subtyping relations @ b S(R >U ) \n~ u XU and El l--S(RP P ) < p xp . Then the subtyping @ h S(R ) aP )P ) < (a --+) ) X(u -+ ) , should \nbe such that, for 17 t-f : a ap and r I-~ : &#38;l+ptt, r* ~ (f,f/J):$(#>0 -+#,P )  iff I * 1-(e , et \n): S(R U ) implies I * } (~ e , j e ): S(RP IP Hence, we define S(R IU aRP IP ) to be (S(RU )U )-+S(Rp \np ))A( (~p~)X)X (d ~p )) . To represent the relation VRT. R , let u and U1 con\u00adtain n+l type variables \nrl, . . . . rn, r, supposewehave established (where @ = ~; d<ns; # <ns;-~<# x r 1) @ t-S(RU ) ) < [r \n/r]o X [# /~]u , We want to have a subtyping relation @ ~ S(Rv~ o >v~ 0 ) < V7, ~ xv~. ~ such that, for \nany 171-p : VT. d and I k p t : VT.u , r* F (pt, p ) : S(RV7 o ~v~ ~ ) iff (Va , a )(va)e t-a! < a! xa \n) r* t-(P [a ], pll[a ]) ; [a/r, d/T , d /7 ]S(RlO ) ). 286 This leads to the definition S(VRr. RU O \n) Gf Vi-t. VT .VT<Tt X I-t . S(RU )U ) .  4 Examples Some examples are given to show that Wadler s \n(free theorems can be recast in our framework. 4.1 Identity Consider the polymorphic type V~.I-~~. For \nany closed term h e : Vr.~~r in F, let p = Erase(e). Hence, ~ (P>P) : Vr V7 f7<Tt x T t. ~~~ A (~ ~~ \n) x (~ ~~ ) in Target. For any two closed types a and a 1 in F and any subt yping F ~<a x a in Target, \n~ (P, P) : 9+P A (~t-+~t) x (~ +~ ) . Thus, for t-(b , b ) : a x a , F (6 , b ) : ~ implies F (pb , pb \n) :,8. Specifically, if (b , b ): /? is defined by a function ~ : cr ao? such that b = f b , then p(fb \n) = f(pb ). Fill\u00ad ing in the type information in these terms, the equality means e(a ](fb ) = f(e[a ]b \n). If (Vbl ~ a ) f(b ) = z, then e[a ]z = z. Hence, every closed term of VT. r--w is extensionally equivalent \nto the polymorphic identity function Ar. Ax: r. x. 4.2 An isomorphism It is well known ([11, 24]) that, \nwith parametricity, the type /3 = VT. (a~r)-+r is isomorphic to a in any ex\u00adtensional model, To get such \nan isomorphism, let ). i = Af:p, f[a](hxa . x) :,6 -+ c1, ~ G Az:a. AT. Jg: gz:a--+@  CY--+T.. It \nis easy to check that the equality i(j(z)) = z holds in F. However, the term j(i(~)) = A~.Ag: a~r, g(~[a](h: \na. z)) is not flq-equivalence to ~. To be the case, it must have f[r]g = g(f[a](k?x cl. 2)). By erasing \ntype information, we need to show that for any type r ?:fl,9:@+ F ~g = g(f(k. z)) : r . (As an aside, \nif one side of the equality is used for an\u00adother in a compiler, the object code efficiency may be increased.) \n The parametricity condition for /3 (treating a as a type variable) is the subtyping By instantiating \nal and al to the closed type Q and CX<a?Xa t to Z(cY)<axcY, we have * (f, /a][da , ct/d ]p  f) : ([~(@) \n where 1-Z(a) < a x a is the subtyping such that, for closed terms e and e of F, r (e , e ) : Z(a) iff \n1-e = e :a in F. For any closed types 0 and 1-g : a14 in F, let R < a x 0 be the subtyping that, for \nany F e) : a and 1-et :0 in F, 1-(e , e ) :R iff 1-ge = e :0in F. Hence, for any t-f :~, we have: ~ (f) \nf) : [WCX)-+R) A (w-w) x (@--@]~R Since 1-(Az. z, g) : Z(a)+R A ((a-w) x (a+%)), we have t-(f(k. x), \nfg) : R. So, fg = g(f(kc. z)). By filling in type information, this means f [O]g = g( f [a](kv: a. z)). \nWith extension\u00adality, we have f [r]g = g(f [a](k: a. z)), and therefore (i, j) is an isomorphic pair. \n4.3 Products The product of two types a and ~ in F is defined as VT.(ci+~-T)-+T (tentatively denoted \nas a ,6 to avoid the confusion with ax ~ in Target). The pair composed of x: a and g: ~ is represented \nas Ar.~f: a+fi+r. f xy. By erasing type information, we have x: cl , y:p 1-Af.fxy : Cl*@ (denoted as \n[z, y]). (A similar argument as in section 4.2 can be made to show that, with parametricity, so/3 is \nthe usual Cartesian product. We will not get into the details, but assume that the fact is true.) Using \nthe method of section 3, we have the subtyping C@ Xd!; ~gl x/31 t (Q+?) < (a e@ )x (d + ) . We show \nthat f F (Af . f z?y , Af . Pz TJ ) : (crop) iff (z , x ) :a and (y , y ) :~ where r = xI: at; x 1: \n~{t; Yt: PI; Ytt: ~tt. In other words, [z?, z ] and [y , vI ] are related componentwise. One direction \ncan be got directly from the proof of the Abstraction Theorem: (x: a, y: /3) 1-(Af .f dyt, Af t..f zy \n) ) : (CYOB)* To get the other direction, we need to use the para\u00admetricity of the polymorphic projections: \nt-pl = Ap. p(A2.Ay.z) : Vavp(@op+a) 1-p~ = Ap. p(Az.Ay.y) : vdflq@+,f3) For pl, it means that the typing \na<a xa ; p<p x~ t-(pi, pi) : (aep+a) is valid. If (z!, 2 ): a X&#38; ; (y , y ): p xpt F ([z , y ], [$ \n, y ]) : (so/3)* then we have (x:a; y:p)* t-(p,[% , y ], pz[z , y ]) : a Since PI [~t, y ] = z and pi \n[z , Ytt] = z in F, thus (z , Z t) : a. Using a similar procedure, it can be shown that (yt, y ) : /3. \nLet o?, /3 , al , and ~ are closed types, and g: a -+d and h: CJ1+P1l be two functions. The functions \ng and h determine two subtyping relations a < a x a and ,B ~ @ x /3 1. We can define a function geh : \na e@ + a te~ ) that maps [z , y ] to [z , y ]. This function determines a subt yping relation (asp) < \n(cdo,8 ) x (a e/? ). From the parametricity of projections, we have gop~ =plogoh and hop2=p20goh. By \nfilling in type information, it means g OPI[d] [,6 ] = PI[a ][/? ]Ogoh h OpZ[Crt]= Ogoh  [/? ] PZ[cY \n7[/3 ] 4.4 Lists Most free theorems in [27] are given for functions on lists. Due to the space limitation, \nwe can not recast them here. However, we note that there is no essential difficult to do so. In F, list(a) \nis defined as d~.(a-v~r)~r~r. A list [Z,,..., xn] of n elements is coded as Ar. Af: a+r-w.~a: ~.fxl(fizz \n. . . (fzna) . . .), or Af.fzl(fc2 . . . (fzna) . . ,), without type information. Similar to the discussion \nfor the case of products, for any subtyping a<at x a , we may build a subtyping re\u00adlation list(a)* <list(a \n) xlist(a ), such that for two lists [x; ,..., z;] and [z!, . . . . z:] of the same length n, (z{, zj \n) : cr xa t-[xj,..., z~], [z~,..., z;]) : list(a)* iff (Vi<n)(zj , Xy) : a! (To prove this, in addition \nto parametricity, induc\u00adtion is needed.) With this property of the subtyping Iist(cx) <list(a ) x Iist(a \n), it is not difficult to rebuild Wadler s (free theorems . 5 Semantics We address briefly some semantic \nissues, sketch the pos\u00adsibility of using our method to study parametricity of models of F, and give some \ninitial results about para\u00admetricity of PER. 5.1 PER interpretation Models of subtyping and bounded \nquantification have received much attention recently. The most successful models to date are constructed \nfrom partial equivalence relations (abbreviated p.e. r. s) on natural numbers w or an applicative structure \n(D, ). In these models, sub\u00ad typing is interpreted as sub-relations (i. e., subsets by viewing relations \nas subsets of w x w or D x D). However, the subtyping rule DIST-PA of Target is not valid in PER models. \nHence, we limit our discussion to parametricity with unary relations, since no product types and related \nsubtyping are needed in such cases, Target just contains two more subt yping reules (PRE- DEF and Q-LB) \nthan FA, and therefore can be modeled by PER. Let (D, C)be an applicative structure, such that D ~ D~D. \nA p.e.r. A on D is a symmetric and transitive relation on D. We use (a, b) c A or aAb when a relates \nb by A. Let Q(A) = {{a}A \\ (a, a) e A} denote the quotient set of A, where {a}A = {b I aAb}. A p.e.r. \nB is said to be a sub-p.e.r. of C (denoted as B < C) iff, for any d and e, dBe implies dCe. To model \ntype constructors in Target, we define: NS = DxD, Am = {(dl, dz) I d1Ad2 and d1Bd2} , n~<CY(B) = {(all, \ndz) I (V13 s C ) d1F(B)d2}. where Y is a function from PER to PER. With the above definition, it is easy \nto see how to de\u00adfine types and subtyping relations of Target in PER, if the predefine types and subtyping \nrelations are prop\u00aderly defined. It is also easy to check that all subtyping rules are sound.  5.2 Parametric \nmodels Given a model of F and second-order logical relations on the model. Informally, the model is parametric \nwith respect to the logical relations if, for any closed type VT. u, [VT. a] contains only parametric \nfunctions with respect to the given logical relations. In other words, if ~ ~ ~r. u] then, for any a \nand a in the model, ~[a ] and ~[a ] map related arguments to related values in the model. Assume we have \na model of Target that extends the model of F in three ways: Every type of F is interpreted the same \nas in the model of F; The set of relations 288 defined on the model of F are the same as the set of \nsubtyping relations in the extended model; For every type a in F, [u*] coincides with the relation on \n[u] defined in the model of F. Then the model of F is parainetric if, for every closed types Vi-. a, \n~r. a] is isomorphic to [(VT. u)*] under the coercion function in the model of Target. Let us consider \nPER models of F. The extension of PER to Target failed to satisfy the above condi\u00ad tions. The reason \nis that if we define unary relations as sub-p,e.r. s, the coincidence of [a ] and R - can not be achieved. \nTo save the situation, we need to change the definition for [a A p]. But this may require the change \nof the definition for subtyping and bounded polymor\u00ad phism, which is beyond the scope of this paper. \n Hence, we consider the case that a unary relation RA on a p.e.r. A is a subset of Q(A). It is clear \nthat RA determines a unique sub-p .e.r. of A. Thus, subt yping relations in PER contain unary relations \nas instances. Let RA and RB be two relations on A and B, respec\u00ad tively. The relation RA +RB is the \nsubset {{d}A~B I {a}~ c RA implies {d ~U}B 6 RB} of Q(A~B). This set is exactly the quotient set of \nthe p.e.r. (by viewing RA and RB as p.e.r. s) Let u be a type in F with only one type variable r and \nwith no occurrence of type binding V inside, The relation RVT u defined on VT. u is the subset {{d}[v,. \n.] [a](A)e Q([u*](A, I (vAepER)(VRA){d}RA))} of Q(~r. a]), which is the quotient set of the p .e,r. \nnA@~~ n~~ [u ](A, RA). Hence, [(VT. 0) ] = nA~pER n~<A a*(A, 1?) is a sub\u00adp.e,r, of RVT u (when viewed \nas ~ p,e,r.). We have: [(VT. u) ] s Rv u < ~r. u]. Especially, for the type of the form VT. u = VT. r-r-+ \n,..*T in F, (Vr. u)* (for unary relations) is of the form Obviously, VT. u and (VT. u)* are interpreted \nby the same p.e.r. in PER. This implies that, in PER, dr. r-++ ~~ con\u00adtains only parametric (w.r.t. unary \nsubset relations) functions. 6 Parametricity of FA In this section, we show how our method can be ex\u00adtended \nto studying parametricity of F~. Let u be an arbitrary type in F~ with free type vari\u00adables {rl, . . \n. , rn }. Let u and u be the same as before. The type u* in Target as follows: ns* = ns, * = r, (a Apj \n= u* Ap*, (U-+p) = c +p A ((u +) X (c7 -+p )) , (b T<p. C)* = ~T <p .~T <p .VT<p* A(T X T ). U* . In \nobject-oriented programming, properties of a pro\u00adgram are often verified by using the properties of its \nsupert ypes. This is called supert ype abstraction (see [14]). In our framework, it means that if 1-a \n~ p is valid in FA, then F a* ~ p* must be valid in Target. This condition is also needed to prove the \nAbstraction Theorem for FA. Let @ be a type context in FA. A type context ~ in Target can be inductively \ndefined by 0 =0 (@;T<cT)* = @*;T <u ; T + ; T<u*A(T x T ). Proposition 6.1 If @ 1-c < p is valid in \nF~, -then both ~ ~ U* < u xu and 0 1-u < p* are valid in Target. Lemma 6.1 For any well defined type \nu of F~, we have ([a/T] a)* = [fY*/T][cJ//, cY /](7*(7*. To prove a similar abstraction theorem for \nFA, for any context 1?in FA, a context I * in Target is defined as: 0 =0 (r; @T)* = I *; r ~u ; r <u \n; T<u*A(T xT ); It is obvious that f = I!*. For each typing derivation 17+ e : u in FA, a typing derivation \nI * 1-(e , e ) : u in Target can be defined. The interesting cases are: If r h e : 02 is got by using \nthe rule ALL-I, then r* 1-(e , e ) : a* is got from r* b (e , e ) : (VT@l. a2)* r l-a<ml r* 1-(e e ) \n: [a /r] [a /T , o! /# ]a~ where 6 and 51 include three cases: &#38; = al and o-l = u;, &#38; = a and \nel = a!, and &#38;= a* and til =u~. If I t-e : u is got by using the rule SUB, then r* 1-(e , e ) : cr \nis got from r*E(e ,e ) :U* f Fg <p* r* F (e , e ) :p* Proposition 6.2 [Abstraction Theorem] I? I 1-e \n: a is a valid typing judgement in FA, then r* t-(e , e ) :a is valid in Target. 7 Conclusion We presented \na syntactic treatment of parametricity of the Girard-Reynolds system F in Target a variant of Pierce \ns F~, and extended it to the study of parametric\u00adity of the system FA. We showed how parametricity conditions \nare represented as subt yping, and reasoning about parametricity becomes a simple matter of rea\u00adsoning \nabout the well-typedness of terms in a syntac\u00adtic formalism. Some semantic issues are discussed and an \ninitial result about parametricity of PER models is given. The work illustrates the expressiveness of \nthe languages that combine intersection types and bounded polymorphism. However, due to the fact that \na general framework for models of bounded polymorphism is not yet avail\u00adable, we have not yet established \nthe soundness of this approach with respect to the logical relations developed in [15]. Due to the same \nreason, we are not clear either how expressive the languages like FA are. Though, with refer to Mairson \ns work [16], the internal logic of models of these languages should have the power of fragments of second-order \nlogic systems that are needed for defining second-order logical relations. The work in this paper is \nstill in its early stage. To study binary relations, some specical subtyping, typing, and equality rules \nemployed in Target are not yet well\u00adunderstood. Though, this understanding may require a better understanding \nof subtyping and bounded quan\u00adtification. Another interesting work is to investigate whether our method \nreally makes parametricity more accessible in functional programming and compiler construction. One concern \nto our work is Pierce s recent work ([21]) on undecidability of bounded quantification. This im\u00admediately \nleads to the fact that subtyping in Target is undecidable as well. However, for the sake of para\u00admetricity, \na weak form of ALL If 17 F e : u is got by using the rule ALL-E, then r* 1-(e , e ) : 0 is got from \ncan be used in FA, Even with the replacement, it is still unknown whether subtyping in Target is decidable \nor not, since some special subtyping rules (e.g., Q-LB) are used. Another concern to our work is Mairson \ns work in [16], where an attempt to a proof theory study of para\u00admetricity in second-order logic systems \nwas made. For a particular application of parametricity, a particular semantic model is needed. But it \nis unclear how to get a model for second-order logic form a model of F. Practically, the problem with \nsecond-order logic is that the axioms for defining parametricity are complicated for the cases of higher \nfunctions and, therefore, difficult to use. To manage these formulas is obviously more difficult than \nto reason about the well-typedness in a programming environment. Acknowledgements I wish to thank Luca \nCardelli, Andrzej Filinski, Tim Freeman, Robert Harper, and Frank Pfenning for their encouragement and \ndiscus\u00adsions. My advisor, John Reynolds, substantially im\u00adproved a draft of this paper. Special thanks \nare due to Benjamin Pierce, with whom I had many illuminating discussions about FA and the work of this \npaper. References [1]Samson Abramsky and Thomas P. Jensen. A re\u00adlational approach to strictness analysis \nfor higher\u00adorder polymorphic functions. In Conference Record of the Eighteenth Annual ACM Symposium on \nPrinciples of Programming Languages, pages 49\u00ad54, 1991. [2] Samson Abramsky, John C. Mitchell, Andre \nSce\u00addrov, and Philip Wadler, Relators. Unpublished draft, 1991. [3] E. S. Bainbridge, P, J. Freyd, A. \nScedrov, and P. J. Scott. Functorial polymorphism. Theoretical Com\u00adputer Science, 70(1):35 64, January \n151990. Cor\u00adrigendum in (3) 71, 10 April 1990, p. 431, [4] Val Breazu-Tannen, Thierry Coquand, Carl A. \nGunter, and Andre Scedrov. Inheritance as im\u00adplicit coercion. Information and Computation, 93(1):172-222, \nJuly 1991. [5] Luca Cardelli. Typeful programming, Research Re\u00adport 45, Digital Equipment Corporation, \nSystems Research Center, Palo Alto, California, February 1989. [6] Luca Cardelli, Simone Martini, John \nC. Mitchell, and Andre Scedrov. An extension of system F with subtyping. In Theoretical Aspects of Computer \nSci\u00adence, 1991. To appear. [7] Luca Cardelli and Peter Wegner. On understanding types, data abstraction, \nand polymorphism. ACM Computing Surveys, 17:471-522, 1985. [8] M. Coppo, M. Dezani-Ciancaglini, and B. \nVen\u00adneri. Functional characters of solvable terms. Zeitschrifl fur Mathematische Logik und Grundla\u00adgen \nder Mathematik, 27:45-58, 1981. [9] Pierre-Louis Curien and Giorgio Ghelli. Coherence of subsumption. \nMathematical Structures in Com\u00adputer Science, 1991. To appear. [10] Pierre-Louis Curien and Giorgio \nGhelli. Subtyp\u00ading -F extensionality: confluence of flrpreductions in F<. In Theoretical Aspects of Computer \nScience, 19911 To appear. [11] Peter J. Freyd. Structural polymorphism. Unpub\u00adlished, January 231989. \n[12] Giorgio GheHi. Proof Theoretic Studies about a Minimai Type System Integrating Inclusion and Parametric \nPolymorphism. PhD thesis, University di Piss, March 1990. Technical report TD-6/90, Dipartimento di Informatica, \nUniversity di Piss. [13] Girard, J.-Y. Une extension de l interpretation de Godel ~ l analyse, et son \napplication a l elimination des coupures clans l analyse et la th60rie des types. In J. E. Fenstad, editor, \nProceedings of the Second Scandinavian Logic Symposium, pages 63-92, Am\u00adsterdam, 1971. North-Holland. \n[14] Gary T. Leavens and Don Pigozzi. Typed homo\u00admorphic relations extended with subtypes. In Pro\u00adceedings \nof Mathematical Foundations of Program\u00adming Semantics, March 1991. To appear. [15] Qingming Ma and John \nC. Reynolds. Types, abstraction, and parametric polymorphism: Part 2. In Proceedings of Mathematical \nFoundations of Programming Semantics, March 1991. To appear. [16] Harry G. Mairson. Outline of a proof \ntheory of parametricity. In Proceedings of Fifth Inter\u00adnational Conference on Functional Programming \nLanguages and Computer Architecture, pages 313\u00ad 327. Springer-Verlag, 1991. [17] .John C. Mitchell and \nAlbert R. Meyer. Second\u00adorder logical relations. In R. Parikh, editor, Pro\u00adceedings of Conference on \nLogic of Programs, Lec\u00adture Notes in Computer Science, pages 225-236, Berlin, 1985. Springer-Verlag. \n[18] Frank Pfenning and Peter Lee. Metacircularity in the polymorphic lambda-calculus. Theoretical Computer \nScience, 1990. To appear. A preliminary version appeared in TAPSOFT 989, Proceedings 290 of the International \nJoint Conference on Theory and Practice in Software Development, Barcelona, Spain, pages 345-359, Springer-Verlag \nLNCS 352, March 1989. [19] Frank Pfenning and Christine Paulin-Mohring. In\u00adductively defined types in \nthe Calculus of Construc\u00adtions. In M. Main, A. Melton, M. Mislove, and D. Schmidt, editors, Proceedings \nof the Fifih Con\u00adference on the Mathematical Foundations of Pro\u00adgramming Semantics, Tulane University, \nNew Or\u00adleans, Louisiana, pages 209-228. Springer-Verlag LNCS 442, March 1989. [20] Benjamin C. Pierce. \nBounded quantification is undecidable. Technical Report CMU-CS-91-161, Carnegie Mellon University, July \n1991. [21] Benjamin C. Pierce. Programming with Intersec\u00adtion Qpes and Bounded Polymorphism. PhD the\u00adsis, \nCarnegie Mellon University, December 1991. To appear. [22] Benjamin C, Pierce. Programming with inter\u00adsection \ntypes, union types, and polymorphism. Technical Report CMU-CS-91-106, Carnegie Mel\u00adlon University, February \n1991. [23] John C. Reynolds, Towards a theory of type struc\u00adture. In Proceedings, C olloque sur la Programma\u00adtion, \nvolume 19 of Lecture Notes in Computer Sci\u00adence, pages 408 425, Berlin, 1974. Springer-Verlag. [24] John \nC. Reynolds. Types, abstraction and para\u00admetric polymorphism. In R. E. A. Mason, editor, information \nProcessing 89, pages 513 523, Ams\u00adterdam, 1983. Elsevier Science Publishers B. V. (North-Holland). [25] \nJohn C. Reynolds. Preliminary design of the pro\u00adgramming language forsythe. Report CMU-CS-88\u00ad159, Carnegie \nMellon University, June 1988. [26] John C. Reynolds. The coherence of languages with intersection types. \nIn Theoretical Aspects of Com\u00ad puter Science, September [27] Philip Wadler. Theorems of Fourth International \nProgramming Languages ture, pages 347 359. ACM Subtyping rules of F~ E)tu<u 1991. To appear. for free. \nIn Proceedings Conference on Functional and Computer Architec\u00adpress, 1989. (REFL) (TRANS) (TVAR) @Fns<nsxns \nTyping rules of F~ ~:u~r rt-z:~ I ; x: fflt-f3:u2 r 1-h. e : C71--W2 rt-e2:a1-+a2 171-e l:al r 1-ezel \n: U2 rl-e:al I l-e:az r 1-e : U1ACT2 r;7<u1t-e:a2 I *e :VT<U1. C72 rke:vT~CT1.(T2 rbU~UI r E e : [U/~]C72 \nI 1-e:ns I l-e:O1 i tal~O-2 I 1--e:u2 Equational theory of F~ I 1-e=e :u 17t-e =e :m (Ns-G) (Ns-IA) (Ns-IQ) \n(Ns-IP) (VAR) (ARRow-I) (ARRow-E) (INTER-I) (ALL-1) (ALL-E) (Ns-1) (SUB) (SYMM) r~e)=f+l:aI 1--e=e :u \nrl-e=e :u I Fe:f7 I ke=e:u I 1-e=e :ns I te=e :ul I te=e :u2 I t-e=et:ul Acr2 I ; x:ult-e=e :02 r FAx. \ne= Ax. e :U1+U2 I ; r~ult-e=e :u2 1 Fe=e :Vrg71. u2 rtel=ej:al r h ez = e; : U1-+U2 r F ezel = e~e~ :U2 \nI t-e=e :V@71. u2 rl-a<ul r 1-e = e : [a/7]u2 I i-el=e~:q I ; z: f71t-e2=e\\:a2 r 1-(kv. ez)el = [e~/z]e~ \n: uz Subtyping rules of Target that are 1-(7 <Pre u @i-u <(7 (TRAN) (REFL-E) (Ns) (INTE) (ABS-TERM) (ABS-TYPE) \n(APPL-TERM) (APPL-TYPE) (BETA) not in F~ (PRE-DEF) Equality rules of Target that are not in FA I l-el=e~:al \nI te2=e~:u2 (PAIR) I l-(cl, e2)= (e;, ej) :f.71xc72 I 1-e=e :u1xcr2 17ke=e :ulxuz (PROJ) r 1-fst(e) = \nfst(e ): 01 I E snd(e) = snd(e ): uz rt-(el, ez) = (e~,e~) :c71xc2 (FsT) r F fst(el, ez) = e; : al (SND) \nrF (dl, d2) = (d~,d~) :&#38;l r 1-(el,ez) = (e~,e~) : fr1+c72 (APPL-TERMS ) r t-(eldl, e2cZ2) = (e~cl~,e~di) \n: c72 rF (czl, d2) = (d; ,d~) :01 r; (Zl, ZZ) : al 1-(el, e2) = (ei, e!) : U2 (BETA ) r 1-(al, a2) = \n([d~/zJej, [di/~21e4) : Uz 171-(el, e2) = (e~,e~) : U1+UZ y @ dom r (ETA ) r t-(~y.ely, ~y.ezy) = (e{, \ne~) : U1+72 @1-(uI+pI) x (C72-+P2) < (m1A~2)-+(p1Ap2) (DIsT-PA) Typing rules of Target that are not in \nFA rl-el:ul r 1-(el, ez) I 1-e2:u2 : alxaz (PRoD-I) 17t-e:ulxuz 17te:u1xu2 (PRoD-E) r F fst(e) : CTl \n17 k snd(e) : Oz r; (z , d ): al t-(e , e ) : uz x ge x ge (ARRow-I ) r 1-(k?. e , h? . e ) : a1+fY2 \n  \n\t\t\t", "proc_id": "143165", "abstract": "<p>A polymorphic function is parametric if it has uniform behavior for all type parameters. This property is useful when writing, reasoning about, and compiling functional programs.</p><p>We show how to syntactically define and reason about parametricity in a language with intersection types and bounded polymorphism. Within this framework, parametricity is subtyping, and reasoning about parametricity becomes reasoning about the well-typedness of terms. This work also demonstrates the expressiveness of languages that combine intersection types and bounded polymorphism.</p>", "authors": [{"name": "QingMing Ma", "author_profile_id": "81543148456", "affiliation": "", "person_id": "PP31087771", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143225", "year": "1992", "article_id": "143225", "conference": "POPL", "title": "Parametricity as subtyping", "url": "http://dl.acm.org/citation.cfm?id=143225"}