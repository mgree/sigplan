{"article_publication_date": "02-01-1992", "fulltext": "\n Generalized Dominators and Post-dominators Rajiv Gupta * University of Pittsburgh Department of Computer \nScience Pittsburgh, PA 15260 E-mail: gupta(ijcs.pitt.edu Abstract The notion of dominators is generalized \nto include multiple-vertex dominators in addition to single-vertex dominators. A multiple-vertex dominator \nof a vertex is a group of vertices that collectively dominate the vertex. Existing algorithms compute \nimmediate single-vertex dominators, and an algorithm for computing immediate multiple-vertex dominators \nis presented in this paper. The immediate dominator information is expressed in the form of a directed \nacyclic graph referred to as the dominator DAG or the DDAG. The generalized domina\u00adtor set of any vertex, \nwhich consists of all single-vertex and multiple-vertex dominators of the vertex, can be computed from \nthe DDAG. The single-vertex dominator information restricts the propagation of loop invariant statements \nand array bound cheeks out of loops. Gen\u00aderalized dominator information avoids these restrictions. In \naddition, it can be used to identify natural loops and improve the existing optimization algorithm for \ncode hoisting. The dual notion of generalized post-dominators can be used for computing control dependence \nand automatic generation of compact test suites for pro\u00ad grams. 1. Introduction In order to perform \ncertain global code optimiza\u00adtion, dominator information is required. 1 A vertex v in a program control \nflow graph (CFG) dominates another vertex w, if every path from the beginning of the CFG to vertex w \ncontains v. The dominators problem has been extensively studied, and several algorithms have been developed \nfor computing dominatcrrs.s~ 9, IS-15 * Paniatly supported by an NSF Presidential Young Investigator \nAward CCR-9157371 10 she l..hiversi~y of Piu.sburgh. Permission to copy without fee atf or part of this \nmatestial is granted provided that the copies are not made or distributed for direct commercial advantage, \nthe ACM copyright notice and the title of the publication and ita date appear, and notice is given that \nthe copying is by permission of the Association for Computing Machinery. To copy otAer\u00adwise, or to republish, \nrequires a fee and/or specific permission. In previous research only single-vertex domina\u00adtors have been \nconsidered. The single-vertex dominators prohibit the full exploitation of optimization. For exam\u00adple, \nconsider the code segment shown in Figure l(i). This code segment can be optimized by propagating a loop \ninvariant subscript expression and array bound checks (shown in italics) out of the loop resulting in \nthe code segment shown in Figure 1(ii). However, none of these optimization can be performed using single\u00advertex \ndominators since loop invariants and may bound checks are only moved out of a loop by existing algo\u00adrithms \nif they belong to a vertex in the loop which dom\u00adinates all loop exits. I6 (i) i=rnin b t 131 + J (ii) \ni.~ t = j+l 11<= mbs andmaxe=ul 12<=t<=u2 + t B1 f + Figure 1: Propagation of Loop Invariant and Array \nBound Checks. @ 1992 ACM 089791-453-8/92/0001/0246 $1.50 In this paper the notion of dominators is \ngeneral\u00adized to include sets of vertices which collectively dom\u00adinate a given vertex. This generalization \nenables the optimization of code in Figure 1. The vertices B 1 and B2 together dominate the loop exit \nand therefore the invariant expression and bound checks present in both B1 and B2 can be moved out of \nthe loop. In addition, the generalized dominator information is also shown to be useful for code hoisting \nand identification of natural loops in a program. Another related problem is that of computing post-dominators. \nA vertex v in a program CFG post\u00addominates another vertex w if every path from w to the end of the program \ncontains v. In this paper the notion of post-dominators is also generalized to include sets of vertices \nwhich collectively post-dominate a given vertex. We demonstrate that control dependences4 can be com\u00adputed \nfrom generalized postdominator information. Generalized post-dominators are also useful for the automatic \ngeneration of compact test suites for testing of programs. In section 2 we define the notion of generalized \ndominators formally and present an algorithm for com\u00adputing generalized dominators. In section 3 we demon\u00adstrate \nthe application of generalized dominator informa\u00adtion in identifying natural loops and performing code \noptimization. Section 4 discusses the computation of generalized post-dominators and sections 5 and 6 \ninclude discussion on the use of this information for computing control dependence and generating test \nsuites. 2, Generalized Dominators The generalized dominator set of a vertex v, denoted as D(v), consists \nof sets containing single\u00advertex and multiple-vertex dominators of v. Therefore, a member of a generalized \ndominator set is a set contain\u00ading one or more vertices. Definition: A set of vertices V obminates vertex \nv iff the following two conditions are mec (i) all paths from the beginning of the program to vertex \nv contain some vertex w &#38; V; and (ii) for each vertex w e V, there is at least one path from the \nbeginning of the program to vertex v which contains w and does not contain any other vertex  inV. In \nFigure 1 the set (B 1,B2] dominates the loop exit since all paths from the start to the loop exit must \npass through either B 1 or B2. The above definition encompasses the traditional notion of single-vertex \ndom\u00adinators since it reduces to the definition of a single\u00advertex dominator if the cardinality of set \nV is one. The second condition in the above definition leads to the fol\u00adlowing lemma. Lemma 1: Given \na set of vertices V which dominates vertex v, there does not exist any set of vertices V c V such that \nV dominates v. Proofi Let us assume that there is a set V c V which dominates vertex v. Let w be a vertex \nin set V which does not belong to V . Since V dominates v there is a path from the start of the program \nto v which contains w and does not contain any other vertex in V. Since V c V this path does not pass \nthrough any vertex in V . This contradicts our assumption that V dominates v. Thus, there is no V which \ndominates v. 0 2.1. Computing Generalized Dominators An algorithm developed by Purdom and Moore14 computes \nsingle-vertex dominators for all the vertices in a CFG. In this algorithm the dominator set for a vertex \nv is computed by taking the intersection of the dominator sets of (immediate) predecessors of v. The \nalgorithm is based upon the observation that if a vertex v is dom\u00adinated by another vertex u, then u \nmust also dominate all predecessors of vertex v, Along the same lines the fol\u00adlowing observation can \nbe made regarding generalized dominators. If a vertex v is dominated by a set of ver\u00adtices V, then for \neach predecessor of v, say p, V must contain a set of vertices which dominates p. This obser\u00advation implies \nthat if we consider a combination of ver\u00adtices which is obtained by unioning together a dominator of \neach predecessor of a vertex v, then this combination must contain a set of vertices which dominates \nv. In theorem 1 we prove this result formally. However, in order to so we first prove the following lemma. \nLemma 2: Given a set of vertices V which dominates vertex v, there does not exist any V c V which dom\u00adinates \na vertex w c V V . Proof Let us assume that V dominates w &#38;k -V . All paths from the start of the \nprogram to vertex w must pass through some vertex in V . Thus, there is no path from the start of the \nprogram to vertex v which contains w and does not contain any other vertex in V. How\u00adever, this contradicts \nour assumption that V dominates v. Thus, there is no V which dominates a vertex w E  v v . 1 lPred(v \n) I Theorem 1: Let d denote a set ~ ~i such that di c D (pi), where pi is the i h predecessor of vertex \nv. There exists a set d c d which dominates vertex v. Proofi In order to prove the above result first \nwe will show that d satisfies the first condition for being domi\u00adnator of vertex v. Next we show that \neither d also satisfies the second condition or a subset of d (d ) satisfies the two conditions specified \nin the definition of dominator. In order to reach vertex v, we have to visit one of its predecessors. \nFurthermore, to arrive at a predecessor of vertex v, say pi, we have to visit one of the vertices in \ndi. By including a dominator (di ) of each predeces\u00adsor (pi ) in the set d, we have ensured that we will \nvisit one of the vertices in d before arriving at v. This satisfies the first condition for d to be a \ndominator of v. At this point if d satisfies the second condition then it is a dominator of vertex v. \nHowever, if d dm?s not satisfy the second condition then thel e is a subset of d (say d ) which does \nsatisfy the second condition or lemma 1. This set d can be constructed from d using lemma 2. The vertices \nto be removed from d to obtain d are the ones which have a dominator in d. Therefore each ver\u00adtex v in \nd such that a domimtor of v &#38; d is removed from d. The resulting set (d ) is a subset of set d which \nsatisfies the two conditions for it to be a dominator of v. 0 Based upon the above result we develop \nthe fol\u00adlowing approach for computing the generalized domina\u00adtor set of a vertex. First, the single-vertex \ndominators are computed using an existing algorithm. 1 13-15 Next, the multiple-vertex dominators are \ndetermined by consider\u00ading combinations of dominators of its predecessor. In order to verify whether \na set of vertices V, with cardinal\u00adity I V 1, dominates a vertex v, we must ensure that no subset of \nvertices in V dominates v. These checks require that the dominators of cardinality less than I V I should \nbe known. Thus, the computation of dominators consisting of n vertices is carried out after the computa\u00adtion \nof dominators consisting of fewer than n vertices. An algorithm based upon this approach is presented \nin Figure 2. The computation of all dominators can result in large dominator sets. In practice only a \nsmall subset of dominators are needed for performing code optimiza\u00adtion, In particular, the dominator \nrelationships among the vertices that belong to a loop are required for per\u00adforming loop optimization. \nNext we present an approach for avoiding the computation of unnecessary Atgorithm Generalized Dominators \nInpuk Control Flow Graph CFG = (V, E). Output Dominator set D(v) for each vertex v &#38;V. Card= 1; \nCompute all single-vertex dominators. White changes to any D(v) occur Do Cardti, Forv &#38;V -{vo} Do \nlp,~)ldi, For each set d = where di ED (p; ) D (V ) and p; is the i A predecessor of v and Id I=Card \nDo For each vertex w s d Do If3V&#38;D(w) and V~d -{w] Thend = d -{w) Endif End for D(v)= D(v)w {d]; \nEnd for End for While changes to any D(v) occur Do D(v)= D(v)u ,~(,)D@) Endwhile Endwhile Figure 2: Computing \nGeneralized Dominator Sets. dominator information using the notion of generalized immediate dominators. \nA vertex w is an immediate single-vertex dominator of vertex v if w is dominated by all other dominators \nof vertex v. This information is represented in the form of a dominator tree. An immedi\u00adate multiple-vertex \ndominator of a vertex v is defined to be a subset of v s predecessors which dominates v. The addition \nof immediate multiple-vertex dominators to the dominator tree results in a directed acyclic graph (DAG) \ncalled the dominator DAG or the DDAG. The entire generalized dominator set of any vertex can be com\u00adputed \nby traversing the DDAG. Furthermore, it is also possible to compute dominators whose vertices belong \nto a specific loop by restricting the traversal of the DAG to the part that represents the loop. If a \npredecessor of a vertex dominates the vertex, then the vertex does not have an immediate multiple-vertex \ndominator. However, if this is not the case the following result guarantees that the vertex has an immediate \nmultiple-vertex dominator. Corollary 1: Let Pred (v ) denote the predecessor set of vertex v. There \nexists a set jdom (v ) ~ Pred (v ), such that idom (v) dominates v. Proof Each vertex dominates itself \nand therefore the set Pred (v ) is a combination of dominators of predecessors of vertex v. Thus, from \nTheorem 1 it follows that there is a subset of Pred (v ) which dominates vertex v. l The DDAG for an \nexample CFG is shown in Fig\u00adure 3. The predecessor set of vertex 7 is (6,4) and since 6 does not dominate \n4 and 4 does not dominate 6, the set {6,4) is an immediate multiple-vertex dominator of 7. The predecessor \nset of vertex 6 is (5,3) and since 3 dominates 5 the vertex 6 does not have an immediate multiple-vertex \ndominator. start I stop+ Figure 3: A Control Flow Graph and its DDAG. An algorithm for computing all \nimmediate domi\u00adnators is shown in Figure 4. First all single-vertex domi\u00adnators are computed and dominator \ntree is constructed. Next immediate multiple-vertex dominators of increas\u00ading cardinalities are computed \nand added to the DDAG. The immediate multiple-vertex dominator of a vertex v, idom (v ), is initialized \nto v s predecessor set Pred (v ). Next we continue to remove vertices from idom (v ) until it satisfies \nlemma 2. In order to ensure that a set of cardi\u00adnrtlity Card satisfies lemma 2, we require multiple\u00advertex \ndominators of cardinrdity less than Card for each vertex in the set. The required information is computed \nusing the function Expand. The function Expand(c,v) computes all of the multiple-vertex dominators of \nvertex v with cardinality c. If a set of vertices V dominates vertex v additional dominators of v, with \ncardinality c, are generated by replacing elements in V by appropriate dominators of those elements. \nIn particular a vertex w &#38; V is replaced by a dominator of w, say d, if d does not dominate any vertex \nother than w in V. This condition is essential to ensure that the set of vertices obtained after replacing \nw in V by d satisfies lemma 2 and hence represents a multiple-vertex dominator of v. The immediate multiple-vertex \ndominators of a given cardi\u00adnality are computed after dominators of lower cardinrdi\u00adties have been computed. \nIn order to compute the immediate multiple-vertex dominators the above algorithm may potentially com\u00adpute \nmultiple-vertex dominators other than immediate multiple-vertex dominators. However, these dominators \nare a small fraction of all multiple-vertex dominators. This is because firstly this information is only \ncomputed for a subset of vertices. Secondly the non-immediate multiple-vertex dominators computed have \na cardinality less than maxp, which is the maximum number of predecessors of any vertex, while the maximum \ncardi\u00adnality of any multiple-vertex dominator can significantly higher than nuxp. For majority of the \nvertices in a pro\u00adgram maxp is a small constant (1 or 2) and therefore the determination of the immediate \nmultiple-vertex domina\u00adtor of these vertices will not require the computation of any non-immediate multiple-vertex \ndominators. For example, in the CFG shown in Figure 3 no vertex has more than two predecessors, and therefore \nall immediate multiple-vertex dominators are computed from single\u00advertex dominator information. Run-time \nComplexity of Computing Immediate Multiple-Vertex Dominators: The time spent on com\u00adputing immediate \nmultiple-vertex dominators is O ( I V I ), where n is the maximum cardinality of any immediate multiple-vertex \ndominator (for example n is two for the CFG in Figure 3). The value of n is bounded by maxp, the maximum \nnumber of predecessor of any vertex. Proof The computation of immediate muhiple-vertex dominators involves \ntwo types of set operations. The first kind of operations are performed when dominator checks are made \nto eliminate predecessors that do not belong to the immediate multiple-vertex dominator set of a vertex. \nThe second kind of operations are per\u00adformed to compute the dominators so that the above checks can be \nperformed. The immediate multiple\u00adAlgorithm BuildDominatorDAG V. -the start vertex of the control flow \ngraph; Red(v) -predecessor set of vertex v; D (v) -the dominator set of ve~x v; ~ Computation of single-vertex \ndominators / D(vo) := { {vo] ] For each v &#38; V -(vo] Do D(v):= ( {vo), {vI], (V2), ..... {v Iv]) } \nEndfor While there is a change in any dominator set Do For each v c V Do D(v):= ( (v) 1 u ,~(v)D@) Endfor \nEndwhile Construct dominator tree from single-vertex dominator information. p Computation of multiple-vertex \ndominators*/ For each vertex v Do idom (v )=1%-ed(v ) Endfor If [idom (v ) I=1 Then done (v )=true Else \ndone (v )=false Endif Card =1 While 3 v such that done (v )=faise Do Card++; For each vertex v such \nthat done (v )=~alse Do For each vertex w &#38; idom (v ) Do Ifa d gidom(v)-(w), where Id I=Card-l andd \ncD(w) Then idom (v )=idom (v )-(WJ) Endif End for If Iidom (v) [<Card Then/* idom (v ) satisfies lemma \n2 / Add node idom (v ) to the DDAG; done (v )=true Endif End for For each vertex w &#38; idom (v ) st \ndone (v )=false Do Expand(Card,w ) Endfor Endwhile EndBuildDominatorDAG Expand(c,v) p compute all multiple-vertex \ndominators of v with cardinality c / For each V ED (v) Do For each w &#38;V Do Foreachd stale D(w) andZx \n&#38;V-(w}std&#38;D(x)Do V =vud -{w) If lV l=c Then D(v)= D(v) U(V ) Endif End for End for Endfor EndExpand \n Figure 4: An Algorithm for Computing Generalized Immediate Dominators. vertex dominators ate computed \nin a series of steps. In each step we identify the immediate multiple-vertex dominators of cardinality \nhigher than the cardinality of immediate multiple-vertex dominators identified in the previous step. \nLet m be the cardinality of the immediate multiple-vertex dominator of vertex v. The identiilcation of \nv s immediate multiple-vertex dominator will take m 1 steps. In each step dominator checks are per\u00adformed. \nDuring the ith step at most i mCm.i checks are performed. Thus, the total number of dominator checks \nperformed during the computation of the immediate m -1 multiple-vertex dominator for vertex v is i MCm-i \nor T ,= m (2 -1 1). Thus, the maximum number of dominator checks performed during the computation of \nall immedi\u00adate multiple-vertex dominators is n (2 -1 1) I V 1, where n is the maximum cardinality immediate \nmultiple-vertex dominator. Since n is bounded by muxp, which is typi\u00adcally a small constant compared \nto total the number of vertices, we conclude that O ( IV I) time is spent on per\u00adforming dominator checks. \nDominators must be com\u00ad puted so that dominator checks can be performed. The computation of immediate \nmultiple-vertex domimtor sets of cardinality i requires that the multiple-vertex dominators of cardinality \nless than i be known. Thus, if the maximum cardinality of any immediate multiple\u00advertex dominator is \nn, then we may have to compute all dominators of cardinality less than n. The computation of multiple-vertex \ndominators takes time linear in the number of such dominators. Thus, the total time spent on computing \nall required dominators for a single vertex is -1 Iv lci or O ( I V I -l). Thus, the time spent on the \nT ,= computation of multiple-vertex dominators for all ver\u00adtices is O ( IV I ). Thus, the total time \nspent on comput\u00ading immediate multiple-vertex dominators for all ver\u00adtices is O ( I V I ), where n is \nbounded by muxp. El From the DDAG the generalized dominator set of any vertex v can be computed. This \ncomputation is merely an extension of function Expand described in Figure 4. The ancestors of the vertex \nin the DDAG clearly dominate the vertex. Additional dominators can be computed by recursively carrying \nout the replace\u00adment process used during function Expand of Figure 4. If a dominator that has been previously \nencountered is generated again, we stop performing replacements on this dominator since all dominators \nresulting from this dominator should have been previously generated. The detailed algorithm is presented \nin Figure 5, The computation of the generalized dominator set for vertex 12 of the CFG in Figure 3 is \nshown in Figure 6(i). It should be noted that vertex 12 has multiple\u00advertex dominators of cardinality \nfour although the value of maxp is only two. This indicates that the approach based upon immediate dominators \nis indeed far more efficient than the approach based upon computing all dominators. Algorithm ComputeAllDominators \nInputi A vertex v and the DDAG. Outputi The generalized dominator set D(v). D(v)= {{v]] u {d:d isanancestorofv \ninthe DDAG) For each V &#38;D(v) Do Expand(V) EndFor EndComputeAllDominators Expand(V) For each w &#38;V \nDo For each ancestor of w, say d Do If d is not an ancestor of a vertex in V-(w ] Then V =v ud -(w} If \nV does not belong to D (v ) Then D(V)= D(V) U(V } Expand(V ) Endif Endif End for Endfor EndExpand Figure \n5: Computing the Generalized Dominator Set of Vertex v from the DDAG. As mentioned earlier, for loop \noptimization, only the dominators of loop exit composed of vertices belonging to the loop are required. \nThis subset of infor\u00admation can be computed by restricting the traversal of the DDAG to the subgraph \nrooted at the vertex in the DAG representing the head of the loop. For example, when considering the \nouter loop (J&#38;., ) in Figure 3, only the dominators of vertex 12 composed of vertices belonging only \nto Lou ,, need to be computed. During the computation of dominators for vertex 12, the inner loop can \nbe considered as single vertex denoted as Liwr . As shown in Figure 6(ii) the above process reduces the \nsize of the dominator set for vertex 12 from fourteen dominators to five dominators. tion. (i) D(12) \n{12) {1) (7,11) (2,11] {6,4,11) (7,8) (7,9,10} 4~ (2,8) (2,9,10) {3,4,11) (6,4,8} {64.9,10) {3,4G,9,1O] \n(ii) D(12) = {1),( 12),{ ~8],{2,11),{7,8 ),{7,11), (2,9,10 ],(3,4,8},{3,4,11 ),(6,4,8),(6,4,11), (7,9,10 \n),{3,4,9,10),{6,4,9,10)) D (12) = (( ).(12 ),(km8),{hmll), (km9,10)) Figure 6: Computing Dominators \nfrom the DDAG. 2.2. All-Vertex Inclusion Property The leaves of a dominator tree are vertices that do \nnot dominate any other vertex in the flow graph. If we construct the DDAG for the same CFG, we will find \nthat all immediate multiple-vertex dominators are composed of leaves from the dominator tree. For example, \nin Fig\u00adure 3 the vertices 4, 6, 7, 9, 10, and 11 which are included in immediate multiple-vertex dominators \nare all leaves of the dominator tree. However, all leaf ver\u00adtices need not belong to some immediate multiple-vertex \ndominator. Vertex 5 in the same example is such a ver\u00adtex. If there is no such vertex the CFG is said \nto satisfy the all-vertex inclusion property. Definition: A CFG possesses the all-vertex inclusion property \nif each vertex v belongs to a dominator (single-vertex or multiple-vertex) of a vertex other than v. \nThis property is of interest because it enables the identification of loops from generalized dominator \ninfor\u00admation. In section 4 we also show that this property is essential for computing control dependence \nfrom gen\u00aderalized post-dominator information. Although all CFGS do not satisfy this property a simple \ntransformation of the flow graph can ensure this property. Each vertex that does not belong to a dominator \nof another venex can be easily identified by examining the DDAG. Corresponding to each such vertex v, \na new vertex w is added to the CFG so that v belongs to an immediate multiple-vertex dominator of a successor \nof vertex v. The following theorem describes the all-vertex inclusion transformation and the reasoning \nbehind tie transforma-Theorem 2: Given a vertex v which does not belong to a dominator of any other vertex. \nLet 1 be the immediate dominator ofs, a successor of v, such that 1 c Pred(s ). There exists a vertex \nd &#38; 1 such that the introduction of a new vertex w along the edge ffom d +s creates an immediate \ndominator ofs which contains v (and w). In addition to creatings s immediate multiple-vertex dom\u00adinator \nwhich includes v, the only other change in the DDAG is that d is the immediate single-vertex domina\u00adtorofw. \nFroofi If v &#38; Pred (s ) and Z c Pred (s ) is an immediate dominator ofs, there must exist 1 c 1 which \ndominates v. This directly follows from lemma 2 which describes the computation of immediate dominators. \nConsider a vertex d t Z . If we introduce a new vertex w along the edge from d tos, then d will no longer \nbe a predecessor of s and thus will no longer belong to an immediate dominator ofs. Let Z denote the \nset of all those prede\u00adcessors ofs which lie along a path from d to s. The immediate dominator of s, \nin the modified CFG, must contain all vertices in 1 because all paths from d to s must contain a vertex \nfrom the immediate dominator of s. Thus, the immediate dominator of s is I-{d ) @. Since v belongs to \nPred (s ) and it lies along a path from d tos, it must belong to the new immediate dominator of s. The \ntransformation of the control flow graph is illustrated in Figure 7.  ++ Figure % Transforming the CFG. \nThe DDAG should also be modified to reflect the changes in the CFG. The immediate multiple-vertex dominator \nof vertexs is changed to 1-{d}@. Also the vertex w must be added to the DDAG. Since w has a single predecessor \nwhich is d, d is w s immediate single-vertex dominator. The vertex w does not dom\u00adinate any other vertex \nkcause any vertex reachable from w is also reachable through the path which goes through V instead of \nw . l The all-vertex inclusion transformation preserves the dominator information. In other words all \ndomina\u00adtors of the original flow graph are still valid. Each new dominator created involves at least \none of the newly introduced vertices. The transformation increases the size of the graph. The worst case \nincrease is shown in Figure 8. The vertices v 1, V2 .... v. do not belong to any dominator. However, \nthe introduction of w 1, W2 .... Wn changes this. The increase in the number of vertices is bounded by \na factor of 1.5. (i) $ T T - - T F------FF Vi a -%.+.. V2 n Figure 8: Worst-case Growth of the CFG. \n 3. Code Optimization Next we show how the generalized domimtor information can be used for performing \ncode optimiza\u00adtion. The optimization of code within loops is impor\u00adtant because the potential execution \ntime savings from loop optimization is significant. The generalized domi\u00adnator information can be used \nto identify loops and pro\u00adpagate loop invariants and array bound checkS out of loops. It can also be \nused to assist in code hoisting which reduces the code size. 3.1. Loop Identification Before optimization \nthe loop s presence is detected and loop idendjication is carried out. The pres\u00adence of a loop is detected \nby identifying a back-edge, which is an edge from the tail (t) of the loop to the head (h) of the loop \nsuch that h dominates r. If a set of ver\u00adtices N dominates the tail I but does not dominate the head \nh, then all vertices in N belong to the loop corresponding to the back-edge from t to h. Therefore the \nvertices belonging to the loop can be identified by traversing the DDAG as shown below. All vertices \nbelonging to the loop can be reached by traversing the DDAG because of the all-vertex inchtsion property. \nLoop = (Lt);IdentifyLoop (t ) Identifibop(s ) For each immediate predecessor p ofs in the DDAG Do If \np#h Then Loop = Loop up ; For each v ep Do ldentifybop(v ) Endfor Endif End for EmiIdentifiLaop 3.2. \nPropagation of Loop Invariants and Array Bound Checks In order to move a loop invariun$ computation or \nan array bound checl# out of a loop, existing algorithms ensure that it belongs to a vertex that dominates \nthe loop exit. However, in practice if an identical invariant expression or a bound check on a subscript \nexpression appears in multiple vertices that together dominate the loop exi4 the statement can be moved \nout. Thus, if we compute the generalizul dominator set of the loop exit, we will be able to move more \ninvariants out of the loop, Consider the example shown in Figure 1. The invariant expression and bound \nchecks were moved out of the loop because blocks B 1 and B2 together dominate the loop exit. In order \nto perform loop invariant code motion we only compute those dominators of the loop exit which contain \nvertices from the loop. The desired subset of dominators can be computed by restricting the traversrd \nof the DAG up to the head of the loop. (lften the tail of the loop is also the loop exit. In this situation \nthe construction of the loop and computation of the exit s dominator set can be combined into a single \npass. So far we have only considered loops with a sin\u00adgle exit. The extension to a loop with multiple \nexits is straightforward. We need to identify combinations of vertices belonging to the loop which together \ndominate all loop exits. The following definition specifies the desired property. Definition: A set of \nvertices V dominates a set of ver\u00adtices w im (i) for every vertex w E W there is a set of vertices V \nin V such that V dominates w; and (ii) there is no subset V of V such that V dominates W.  Thus if \nW is the set of vertices representing the loop exits, then the set V, which dominates all loop exits, \ncan be computed by simply unioning together a dominator of each vertex w &#38; W. 3.3. Code Hoisting \nAnother code optimization which uses dominator information is code hoisting. In this optimization an \nexpression is hoisted to a point p which dominates all computations of the expression. The result is \na reduction in code size. The optimization can be applied only if the variables used in the expression \nare not redefined along the paths from p to the blocks where the expression is computed. If generalized \ndomimtor information is avail\u00adable, then in a situation where it is not possible to hoist code to point \np, we may be able to hoist the expression to a group of vemices V that dominate C, which is the set of \nall vertices where the expression is computed. (ii) v c Figure 9: Example of Code Hoisttng. An example \nis shown in Figure 9. If the cardinal\u00adit y of C is more than the cardinality of V, savings Wfii result. \nThis generalized code hoisting algorithm can be implemented using generalized dominator information as \nfollows. The CFG is @aversed in the reverse direc\u00adtion, starting from each computation of the expression, \nuntil either point p is encountered or a definition of a variable used in the expression is encountered. \nIf the union of vertices at which traversal terminates dom\u00adinates the vertices which compute the expression, \nthen code hoisting can be performed. 4. Generalized Post-dominators A vertex v Post-dominatw a vertex \nw if all paths from w to the end of the program must pass through v. As in the case of dominators we \ndefine the notion of generalized post-dominators by considering mttltiple\u00ad vertex post-dominators. The \ngeneralized post-dominator information for a CFG is same as the generalized domi\u00ad nator information for \nthe reverse CFG, which is con\u00ad structed by simply reversing the direction of all edges in the CFG. Thus, \nthe generalized post-dominators can be computed by applying the algorithms developed in sec\u00adtion 2 to \nthe reverse CFG. Alternatively, the post\u00addominator set of a vertex v can be computed from the post-dominator \nsets of the successors of v. The all\u00advertex inclusion property is also defined in the context of post-dominators. \nThe application of the all-vertex inclu\u00adsion transformation to the reverse CFG ensures that this property \nis satisfied. 4.1. Computing Control Dependence Control dependence, 4,12 information has been used for \na variety of applications including program slic\u00ading,lO 16 building program dependence graphs,4 and parallelism \ndetection and scheduling.2, 5 A statement y is control dependent upon a predicate x if the result of \nthe execution of x directly determines whether y will be executed or not. Associated with control dependence \nis a label. The label is true (false) if y is executed as a result of x evaluating to true (false). Control \ndependence can be defined in terms of post-dominator relationships as follows: Definition: Vertex y \nis control dependent upon vetlex x iffi (i) ~ a path P from x toy and all vertices in P exclud\u00ading x \nare post-dominated by y; and (ii) x is not post-dominated by y. In this section we show that the control \ndepen\u00addence information is a subset of generalized post\u00addominator information. However, the CFG must \nbe transformed to satisfy the all-vertex inclusion property before control dependence are computed. Tle \nsubset of post-dominators that specify the control dependence  relationships are the primary post-dominators \nwhich are defined as follows. Definition: A set of vertices V, such that I V I >1, represents primary \npost-dominator (PPD) of vertex v iffi (i) Visa post-dominator of vertex v; and (ii) each vertex w &#38; \nV postdominates at least one immediate successor of v.  Theorem 3: If vertex y &#38; V, where V is \na PPD of ver\u00adtex x, then y is control dependent upon x. Proof Since y c V, a set of vertices that together \npost\u00addominate vertex x, vertex y does not post-dominate x by itself. This is because if V post-dominates \nx then no subset of V can post-dominates x. This satisfies the second condition for y to be control dependent \nupon x. Next we must show that the first condition which requires that all vertices along the path from \nx to y, excluding x, should be post-dominated by y. Since y belongs to a PPD of x it must post-dominate \na successor of x, Next we show that y post-dominates all vertices along the path from x toy. Let us assume \nthat vertex v along the path from x toy is not post-dominated by y. Thus, there is a path from v to the \nend of the program that does not include y. However, this implies that we have a path from the successor \nof x to the end of the program that does not contain y and therefore y does not post-dominate the immediate \nsuccessor of x on this path. This contradicts the fact that y belongs to the PPD of x. Thus, by contradiction \nwe have shown that y post-dominates all vertices along the path from x to y excluding x. Hence, we have \nshown that y is control dependent upon x. l The PPDs are the multiple-vertex post-dominators of a vertex \nwhich are constructed by tmioning singleton post-dominator sets of the successors of a vertex. The labels \n(true/false) are associated with PPD elements by taking note of the label on the edge from a vertex and \nits successor from whose post-dominator set the element was chosen. A detailed algorithm can be found \nin Fig\u00adure 10. Since an immediate multiple-vertex post\u00addominator of a vertex v is a subset of v s successors \nand each vertex post-dominates itself, an immediate multiple-vertex post-dominator is also a PPD. The \nall\u00advertex inclusion property ensures that all vertices which are control dependent upon some other vertex \nbelong to an immediate multiple-vertex post-dominator and hence a PPD. Thus all control dependence will \nbe identified using the PPDs. The example in Figure 11 shows the computation of control dependence for \na sample graph. With each vertex belonging to a PPD a label true/false (t/f) is asso\u00adciated. The set \n{3,6) is a PPD of vertex 1 since it is con\u00adstructed from single vertex post-dominators of vertex 1 (vertex \n6 post-dominates vertex 2 and vertex 3 post\u00addominates itself). Since vertex 2 is the true succewor of \nvertex 1 and vertex 3 is the false successor of vertex 1, the labels associated with vertices 3 and 6 \nare false and true respectively (denoted as { 3f,6t) ). From this PPD we Algorithm Control Dependence \nInputi Control Flow Graph. Outpufi For each vertex determine the vertex, if any, it is control dependent \nupon. vf -the stop vertex of the control flow graph, Succ(v)-irnmdlate successorsetofvertexv; PD (v \n) -post-dominator set of vertex v; /* Computation of single-vertex post-dominators / PD(vf ) := (V/ \n) Foreachvs V-{vf]Do PMv) := ( vo> vI> vz>..... VIVI ) Endfor While there is a change in any post-dominator \nset Do PD(v) := ( V ) U ~~(V)pD (~) Endwhile /* Computation of PPD s / For each condhional vertex v &#38; \nV -{vf ] Do Let v, and Vf be the true and false successorsof v For each pair (d, ,df ), where d, c PD \n(v, ) PD (v ) and df &#38;PD (vf )-PD (V ) Do If not (d, EPD (df ) or df EPD (d, )) Then {d, t,df f) \nis a PPD of vertex v, that is, d, and df are control dependent upon v Endif Endfor Endfor Figure 10: \nComputing Primary Post-Dominators and Control Dependence. conclude that vertices 3 and 6 are control \ndependent upon vertex 1. Other control dependence can be simi\u00adlarly inferred from the PPDs. In this section \nwe have shown that there is a rela\u00adtionship between generalized post-dominators and con\u00adtrol dependence. \nWe presented a simple algorithm for computing control dependence. However, there are other algorithms \nfor computing control dependence. The algorithm based upon the notion of dominance fron\u00adtiers is the \nmost efficient.3 start Single Vertex Post-Dominators and PPDs ({1], {7),{ 3f,6t),{3f,2t)) ((2], (6),( \n7),{4t,5f)) {{31. {71,{ 5L8f),{6t,8f)l {{4). {6),{ 7)1 ((5], {6],[7)) {{6),(7)] ({7)) {{8),{ 7)) Nodes \n6,2 1 3 : 4 ; t 5 2 f 5,6 3 t 8 3 f Figure 11: Computation of Control Dependence.   4.2. Automatic \nTest Generation Techniques for automatic generation of test cases that satisfy a given set of testing \nrequirements have been developed.7, 11 The testing requirements specify the statements in a program that \nmust be executed by the test cases, To generate a small number of test eases that satisfy the given testing \nrequirements, the generalized post-dominator relationships among the vertices corresponding to the statements \nthat must be executed by the test cases can be exploited. A collection of sets of vertices VI. V2, .... \nV. is found such that, Vi is post\u00addominated by V2 ..,. is post-dominaied by V. and each set Vi contains \nat least one vertex corresponding to a statement that is to be tested. This ordering can be used to guide \nthe generation of test cases as follows. Test case(s) that visits relevant statement(s) in VI is found \nand then extended to visit relevant statement(s) in V2 and so on till test case(s) that executes all \nrelevant state\u00adments is found. Since an attempt is made to use the same test case for satisfying different \nrequirements before a new test case is added to the suite, this approach results in fewer test cases. \nAs an example, let us assume that for the CFG in Figure 3 test case(s) are required to test the vertices \n1,3, and 7. We can find sets of vertices {l), (3, 4, 9, 10), and {7, 11) which satisfy the conditions \nmentioned ear\u00adlier. During the generation of test cases the vertices will be visited in the order 1, \n3, and 7. This process can result in a single test case which follows the execution path 1, 2, 3, 6, \n7, 12, assuming that this is a feasible path. Thus, we would have found a single test case that satisfies \nall of the requirements. If the pxt-dominator information is not used to guide the generation of test \ncases we may generate three test cases to satisfy the above requirements. Let us assume that we first \nattempt to generate a test case that executes vertex 1. The first test ease, rest 1, may be found in \nthis attempt. Next we attempt to find a test case for vertex 7 which results in testz and finally we \nfind a third test case for vertex 3 which results in test q. testl: 0, 8, 9, 11, 12 testz: 1, 2, 4, 0, \n12 tests: 1, 2, lZIl, 6, 7, 12 By examining the above test eases we can deter\u00admine that tests satisfies \nall of the requirements. Thus, in order to obtain a compact test suite we cart discard the other two \ntest eases. However, this process will not help in reducing the overhead of test case generation since \nthe test eases have already been generated. The same approach can also be used for data flow testing \nin which test eases are required to exercise specified clef-use pairs. Although the cost of computing \nall generalized post-dominators for the entire program is significrm~ it is far less than the cost of \ntest case generation which is an exponential process. Any reduction in the cost of test ease generation \ncan be expected to outweigh the cost of computing generalimxl post-dominator information. 5. Summary \nIn this paper the notion of multiple-vertex domi\u00adnators and post-dominators was introduced. The single\u00advertex \ndominator information has been used for loop detection and for performing hop invariant code motion and \ncode hoisting. It was demonstrated that the multiple-vertex dominators can also be used to assist in \nloop identification and avoiding resrnctions on loop invariant code motion and code hoisting. The single\u00ad \nvertex post-dominator information has been used for computing control dependence and for guiding the \ngen\u00aderation of test cases. It was also shown that multiple\u00advertex post-dominators can also be used for \ncomputing 10. control dependence and effectively guiding the genera\u00adtion of compact test suites. Algorithms \nfor computing multiple-vertex dominators and post-dominators were presented. 11. Acknowledgements I \nthank Mary Lou Soffa for her comments on drafts of this paper. 12. References 1. A.V. Aho, R. Sethi, \nand J.D. Unman, Compilers: Principles, Techniques, and Tools, Addison-Wesley, 1986. 13. 2. F. Allen, \nM. Burke, P. Charles, R. Cytron, and J. Ferrante, An Overview of the PTRAN Analysis System for Multiprocessing, \nThe Journal of Parallel and Distributed Computing, vol. 5, no. 5, 14. pp. 617-640, C)ct. 1988. 3. R. \nCytron, J. Ferrante, B.K. Rosen, M.N. Weg\u00adman, and F.K. Zadeck, An Efficient Method of Computing Static \nSingle Assignment Form, Proc. of the 16th Annual ACM Symposium on 15. Principles of Programming Languages, \npp. 25-35, Jan., 1989. 16. 4. J, Ferrante, K. Ottenstein, and J. Warren, The Progmm Dependence Graph \nand its Use in Optim\u00adization, ACM Transactions on Programming Languages and Systems, vol. 9, no. 3, pp. \n319\u00ad349, July 1987. 5. R. Gupta and M.L. Soffa, Region Scheduling: An Approach for Detecting and Redistributing \nParallelism, IEEE Transactions on Software Engineering, vol. 16, no. 4, pp. 421-431, April 1990. 6. \nR. Gupta, A Fresh Look at Optimizing Array Bound Checking, Proc. of the ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, White Plains, New York, pp. 272-282, June 1990. 7. R. Gupta and \nM.L. Soffa, Automatic Generation of a Compact Test Suite, Technical Report, University of Pittsburgh, \n1991. 8. D. Harel, A Linear Time Algorithm for Finding Dominators in Flow Graphs and Related Prob\u00adlems, \nProc. of the 17th ACM Symposium on Theory of Computing, pp. 185-194, May 19g5.  9< M.S. Hetch and J.D. \nUnman, A Simple Algo\u00adrithm for Global Data Flow Analysis of Pro\u00adgrams, SIAM Journal of Computing, vol. \n4, pp. 519-532,1975. S. Horowitz, T. Reps, and D. Binkley, lnterpro\u00adcedural Slicing Using Dependence \nGraph, Proc. of the ACM SIGPLAN Conference on Program\u00adming Language Design and Implementation, Atlanta, \nGeorgia, pp. 35-56,1988. B. Korel, Automated Software Test Data Gen\u00aderation, IEEE Transactions on Software \nEngineering, vol. SE-16, no. 8, pp. 870-879, August 1990. D.J Kuck, R.H. Kuhn, D.A. Padua, B. Leasure, \nand M. Wolfe, Dependence Graphs and Com\u00adpiler Optimization, 8th Annual ACM Symp. on Principles of Programming \nLanguages, pp. 207\u00ad218,1981. T. Lengauer and R.E. Tarjan, A Fast Algorithm for Finding Dominators in \na Flowgraph, ACM Transactions on Programming Languages and Systems, vol. 1, pp. 121-141,1979.  P.W. \nPurdom and E.F. Moore, Immediate Predominators in a Directed Graph, Communi\u00adcations of the ACM, vol. \n15, no. 8, pp. 777-778, 1972. R.E. Tarjan, Finding Dominators in Directed Graphs, SIAM Journal of Computing, \nvol. 3, no. 1, pp. 62-89, 1974. M. Weiser, Progmm Slicing, IEEE Transac\u00adtions on Sof ware Engineering, \nvol. SE-10, no, 4, pp. 352-357, July 1984.   \n\t\t\t", "proc_id": "143165", "abstract": "<p>The notion of dominators is generalized to include multiple-vertex dominators in addition to single-vertex dominators. A multiple-vertex dominator of a vertex is a group of vertices that collectively dominate the vertex. Existing algorithms compute immediate single-vertex dominators, and an algorithm for computing immediate multiple-vertex dominators is presented in this paper. The immediate dominator information is expressed in the form of a directed acyclic graph referred to as the dominator DAG or the DDAG. The generalized dominator set of any vertex dominators of the vertex, can be computed from the DDAG. The single-vertex dominator information restricts the propagation of loop invariant statements and array bound checks out of loops. Generalized dominator information avoids  these restrictions. In addition, it can be used to identify natural loops and improve the existing optimization algorithm for code hoisting. The dual notion of generalized post-dominators can be used for computing control dependences and automatic generation of compact test suites for programs.</p>", "authors": [{"name": "Rajiv Gupta", "author_profile_id": "81100027751", "affiliation": "", "person_id": "PP39072798", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143216", "year": "1992", "article_id": "143216", "conference": "POPL", "title": "Generalized dominators and post-dominators", "url": "http://dl.acm.org/citation.cfm?id=143216"}