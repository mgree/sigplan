{"article_publication_date": "02-01-1992", "fulltext": "\n Modellling Prolog Control * Roberto Barbuti, Michael Codish, Roberto Giacobazzi, Giorgio Levi Dipartimento \ndi Informatica Universit&#38; di Piss Corso Italia 40, 56125 Piss (barbuti,codish,giaco,levi)tlldipisa.di.unipi.it \n Abstract of the program as well as the control of the execu\u00ad tion model. For semantics-based program \nanal ysis an The goal of this paper is to construct a semantic ba\u00ad enhanced or coliect~ing semantics \nwhich recaptures sis for the abstract interpretation of Prolog programs, some of these details is usually \nrequired. After all, the Prolog is a well-known logic programming language purpose of program imalysis \nis to analyse the ted of which applies a depth-first search strategy in order the program with respect \nto the control of its execution to provide a practical approximation of Horn clause model, In general, \nthe fact that collecting semantics logic. While pure logic programming has clean fix\u00ad can be viewed as \nuncovering details which the stan\u00ad point, model-theoretic and operational semantics the dard semantics \nhas bidden imposes a restriction on situation for Prolog is different. Difficulties in captur\u00ad the choice \nof semantic models upon which program ing the declarative meaning of Prolog programs have analyses can \nbe based. led to various semantic definitions which attempt to In the case of logic programs, standard \nsemantics encode the search strategy in different mathematical traditionally associate programs with \nthe set of ground frameworks. However semantic based analyses of Pro\u00ad atoms which they imply. Program \nanalyses, in con\u00ad log are typically achieved by abstracting the more sim\u00ad trast, are often required to \ncapture: (1) answer sub\u00ad ple but less precise declarative semantics of pure logic stitutions for a query; \nand (2) call patterns that Programs. is how particular clauses in the program are used in We propose \ninstead to model Prolog control in a refutations of a query. It is no coincidence that in simple constraint \nlogic language which is ,presented most cases practical abstract interpretations of logic together with \nits declarative and operational seman\u00ad programs approximate top-down semantics based on tics. This enables \nus to maintain the usual approach SLD resolution (e.g. [9]). The information concerning to declarative \nsemantics of logic programs while cap\u00ad control and textual details of a program are more nat\u00ad turing \ncontrol aspects such as search strategy and se\u00ad urally recovered (and collected) from such semantics, \nlection rule. An alternative approach is taken in [10] and fur\u00ad ther pursued in this :paper. Instead \nof enhancing the semantic basis for analysis to capture control the 1 Introduction program itself is \nenhanced so that its standard mean\u00ad ing reflects the required control. The key idea is to Standard semantics \ntypically associate programs with enhance a program F by a transformation M so that entities which capture \nthe essence of what they do the standard meaning of M(P) reflects the control in\u00ad while abstracting \naway from details related to the text formation required for the analysis of P. So for exam\u00ad ple, the \ndeclarative meaning of a logic program P en\u00ad *This work has been supported by Progetto Fina,lizzato Sis\u00adtemi \nInformatici e Calcolo Parallelo of C .N .R. under grant n. hanced by a magic set transformation [4] is \nshown to 91 OO88O.PF69 and by the Esprit Basic Research Action 3012\u00ad reflect the call patterns of P enabling \nbottom-up anal- Compulog. ysis (e.g. [5,10,20]). The approach of modelling control has two main advantages: \n(1) the standard semantics Permission to copy without fee all or part of this matertial is granted provided \nthat the copies are not made or distributed for direct commercial advantage, the ACM copyright notice \nand the title of the is not required to be extended to a collecting seman\u00adtics; and (2) any of the alternative \nsemantic definitions publication and its date appear, and notice is given that the copying is by for \na language are potential choices as a basis for anal\u00ad permission of the Association for Computing Machinery. \nTa copy other\u00ad ysis. wise, or to republish, requires a fee and/or specific permission, In this paper \nwe apply the idea of modelling control @ 1992 ACM 089791453-8/92/0001/0095 $1.50 95 to define a declarative \nsemantics for Prolog with the intention of providing a semantic basis for program analysis. The semantics \nof Prolog is usually specified by encoding its (sequential) control within different frameworks such \nas dynamic algebras [6], determin\u00adistic transition systems [12] or denotational semantics [17,3,13]. \nHowever, (semantics-based) analyses of Pro\u00adlog are usually achieved by abstracting the more sim\u00adple but \nless precise semantics of pure logic programs. Unfortunately, it is not straightforward to encode Prolog \ncontrol directly in terms of pure logic programs. Instead, we propose to model Prolog control in a con\u00adstraint \nlogic language r which is expressive enough to capture Prolog control yet restricted enough to have a \nsimple declarative semantics. A transformation from Prolog to ~ is defined to describe the meaning of \na Prolog program P in terms of the declarative seman\u00adtics of the corresponding r program P . The target \nlanguage ~ is an instance of the cc class of concur\u00adrent constraint languages [22]. Constraints are used \nto specify that a clause may be chosen for reduction only if computation with the preceding (Prolog) \nclauses ter\u00adminates. We present a semantics for ~ which is open with respect to the interpretation of \nthese (termina\u00adtion) constraints. The meaning of a Prolog program is constructed by composing the meaning \nof the ap\u00adpropriate ~ program (the logic component ) with a corresponding termination theory (the control \ncom\u00adponent ). This approach supports the analysis of Pro\u00adlog programs based on the abstract interpretation \n[11] of r programs consisting of two corresponding compo\u00adnents: (1) a standard analysis for the logic \ncomponent of the program; and (2) a termination analysis for the control component. An approximate model \nfor termination can be pro\u00advided either by applying techniques of abstract inter\u00adpretation or by applying \nproof procedures. It is in\u00adteresting to note that a precise model for termination provides a result which \nreflects the standard Prolog control; while the worst approximation (which speci\u00adfies that all termination \nconditions are possibly true) reflects the meaning of P as a pure logic program. The rest of the paper \nis organized as follows: Section 2 presents briefly some preliminary definitions and no\u00adtations. Section \n3 introduces the r language together with operational and declarative semantics, Section 4 describes \nhow to model depth first control of Pro\u00adlog using the r language. Section 5 discusses the in\u00adterpretation \nof the termination conditions. Section 6 describes related work and concludes. Full proofs, not included \ndue to space limitations, are present in the full version of this paper. 2 Preliminaries In the following \nwe assume familiarity with constraint logic programming (CLP) [16] and logic programming theory [1,19]. \nLet E and Var be denumerable sets of function sym\u00adbols, and variables respectively; T(Z) and T(Z, Var) \ndenote the corresponding ground and non-ground term algebras respectively. Likewise, if II denotes a \ndenumerable set of predicate symbols, A(E, ~, Var) denotes the set of atoms of the form P( tl, . . . \n. tn ) where p E IIand4~T(X, Var) (1< z< n). When clear from the context we will refer to elements of \nA(E, II, Var) as II-atoms or simply as atoms. The set of all sequences of atoms is denoted Atom*. The \nsequence of atoms with first element A followed by the sequence B is denoted A \\ B; the concatenation \nof two sequences B and B is denoted B :: B . The empty sequence is denoted by A. The set of variables \nthat occur in a syntactic object t is denoted vars(t). Let 1 ~ A(X, H, Var) and V ~ Var; A < v I denotes \nthat A is a renaming of an element of I which contains no variables in V. Moreover, we extend this notation \nfor any syntactic object. Let M denote the standard Her\u00adbrand constraint system of equations on terms. \nAn equation is an expression of the form t = s where t, s E T(X, Var). A set of equations E is unifiable \niff there exists a mapping 0 from Var into T(Z, Var) (called a solution) such that V(t = s) c E, (id) \ns (s0) where E denotes syntactic equivalence and tr?is the term obtained by replacing each variable z \nin twith d(z). Solutions apply in the same way to any syntactic object. The empty set of equations is \ndenoted ~. The application of a set of equations a to a syntactic ob\u00adject A is defined by Aa = {Ad I \nO is a solution of u}. Notice that the set Au is closed under instantiation and hence under renamings. \nThe standard ordering on atoms (i.e. less general or more instantiated) is captured by defining A < B \niff there is a unifiable set of equations u such that Ae = Bo.  3 The T language This section introduces \na constraint logic language ~ which is applied in the next section to model Prolog control. We present \nand prove equivalent two seman\u00adtic definitions for ~. An operational semantics defined in terms of a \nsimple transition system is later used to justify the proposed modelling of Prolog. A declara\u00adtive semantics \nis given in terms of an immediate con\u00adsequence operator and in combination with the trans\u00adformation proposed \nin the next section provides the basis for bottom-up abstract interpretations of Prolog programs. A t-program \nconsists of ask-tell constrained clauses as in the cc paradigm [22]. However in contrast with terpreted \nover different algebraic structures:  Tell constraints are interpreted over the usual Herbrand system, \nH [16].  Ask constraints correspond to semi-decidable tests which are intended to specify termination \nconditions (applied below to model termination of Prolog goals). These tests are interpreted by an associated \ntermination theory, T,  3.1 Syntax Let X, II and Var be given as above and let IIfi = {=}, IIT and \nII-p be a partition of Ii. We assume an element hwe c IIT. A finite sequence of IIp-atoms is called a \nIIp-resolvent or a resolvent for short. Definition 3.1 (goals and constraints) A tell constraint or a \nstore 2s a jinite set of 11~ \u00adatoms. The set of stores is denoted by Store. An ask constraint is an element \nof the form. t(g) where t c llr and g is a IIp-resolvent. Ask constraints oj i!he form t(A) are denoted \nt. A constraint is a pair (ask : tell) consisting of an ask and a tell constraint. A goal is a pair c \n0 B consisting of a constraint c and a resolveni B. The set of goa!s is denoted by Goal. The empty tell \nconstraint is denoted by true . Definition 3.2 (programs) A r program consists of a finite set of clauses \nof the form H+-c 0 B where H is a llp-atom and c 0 B is a goal. Ask and tell constraints are interpreted \nover cor\u00adresponding T and Z theories. T is a dcjwnward closed (i.e. closed under instantiation) set of \nask con\u00adstraints called a termination theory. We assume that true(g) e 7 for every resolvent g. Constraint \nconsistency is defined for a given envi\u00adronment specified by a resolvent and a store. Definition 3.3 \n(ask and tell consistency)l Let p be a resolvent, o a store and (ask : tell) a constraint with ask = \nt(g), we write: Z l=c tell ifl u U tell has a solution,  T ~~ ask iflt(g :: P)U < T,  -( H, T) +$ \n(ask : tell) i.f?t +0 tell and 7 +$ ask and say that ask and tell are respective~~ % and T consistent \nfor u and p. Example 3.1 Consider a store u = {v = S(z) 1, a resolvent A and a termination theory T \n=-{t(g) I g c .4(X, IIP, Var) } with ,X = {O, s}, IIP = {p} and a constraint c = (t(p(y)) : y = s(0)). \nSince u U {y = s(0)} has a solution and t(p(y))u ~ T, therefore (H, T) ~=~ c. 3.2 Operational Semantics \nAn operational semantics for r is given in terms of a transition relation on goals. A pair in the relation \ncorresponds to the reduction of a goal with a renamed clause from the program. The conditions on the \ntell parts of the goal and clause are the standard ones (e.g. CLP(7f) [16]). At each step the ask conditions \nof the chosen clause are tested with respect to a current store and resolvent. Ask constraints are not \ncollected since downward closure of T implies that any test sat\u00adisfied in a store will be continuously \nsatisfied in sub\u00adsequent (updated) stores. Definition 3.4 (transition system) Let P be a T program and \n!et 7 be a termination theory. Define 2P ~ Goal x Goai to be the smallest relation such that: T (true \n: teil) 0 A IB -P (true : tellu {H = A} Utell ) l B :: B if C 0 H +-(ask! : tell } 0 B <<v P where \nV = vars((true : teli) 0 A ( B)j H l=,.,, {H = A} U tell ask!, and T %Hu{H=A} The (non-ground) success \nset of a ~ program is specified (similar to the case of logic programs, e.g. [15]) in terms of the atomic \ngoals of the form (true : true) 0 p(i) which have successful computations as specified by the transitive \nclosure of the transition re\u00adlation (given a termination theory T). Definition 3.5 (success set) Let \nP be a T program and let T be a termination theory. The success set of P with respect to T is: $7(P) \n= { p(l)m (true : true) 0 p(~) ~~ (true : u) 0 }. The operational semantics of a r program is defined \nin terms of the successful computations for (consistent) initial goals: Definition 3.6 (operational semantics) \nLet P be a T program and let T be a termination theory. Define C&#38;(P) : Goal + 2st0 e by: Or(P) = \nA(ask : teii) D G. ~ (true : tell) 0 G ~~ (true : u) 0, ?f &#38;@ teil and 7 ~~ ask { } Example 3.2 \nLet T be a termination theory {t(g) I g @ A(X,lIp, @)*}, IIp = {p}, X = {O, s}, and let P be the following \nT program: p(z) +(i7-ue:z=O) 0 . p(z) +(i(p($)):z= s(y)) 0p(y). The goal (true : true) 0 p(s(z)) cannot \nbe reduced since reduction with the first clause would result in an inconsistent tell constraint while \nreduction with the second clause is not ask consistent. The goal (irwe : true) 0 p(s(o)) has a successful \ncomputation: (true : true) 0 p(s(())) ~P (true :y = O) 0 p(y) 3P (true :y = O) 0 . The success set of \nP with respect toT is {P(o) >P(do)), P(d40))), .}.  3.3 Declarative semantics We now define a declarative \nsemantics for T programs which is open [8] with respect to the interpretation of ask constraints. It \nis defined in terms of unfoldings of clauses [18] which contain uninterpreted ask condi\u00adtions. This approach \nfacilitates separation of termi\u00adnation from computation when applied to modelling Prolog control. Unfoldings \nof clauses with ask and tell constraints result in sequences of constraints which we term constrained \natoms. Definition 3.7 (constrained atoms) A constrained atom, r, is a formula of the form h +-(askl : \ntelll) +-+ (askn : ielln) where h is an atom and (askl : telll), . . . . (askn, : telln) are constraints. \nWe oflen denote ~ = h +-(ask, : tell,)~=l and tell(7r) =,QI teill. The notion of consistency extends \nnaturally to con\u00adstrained atoms: Definition 3.8 (consistent constrained atom) Let go be a store, p a \nresoluent, T a termination theory and r = p(~) I-(ask, : iella)~=l a constrained atom. We write: . H \n~oo 7r zff M ~ao teii(~), 2-*:O x iff for z = 1,. IL, T +$t_l aski where at = IJ, -1 U tell,, o (MIT) \nl=~o T iflfi +.O m and T l=$u r. Example 3.3 Let ~ = p(z) -(t(p(z)) : z = s(g)) + (t(p(~)) : y = s(2)) \n-(t(p(z)) :2 = s(w)), a = {z = Sss(o)} and 7 = {f(P(o)), i(p(s(o))), t(P(ss(0))), . . .}. Then ( li, \nT) l=: r because H ~a {z = s(y), y = S(Z), Z = s(w)} and T +$ t(p(z)), t(p(rj)) and T l%{.=,(y)} t(p(z)). \n 7 l=$u{z=s(Y), Y=s(.)} The following example demonstrates that consis\u00adtency of constrained atoms is \norder dependent: Example 3.4 Let T = {t(p(f(a)))}, u = @ and rl = p(z) +--(true : z = f(a)) + (t(p(z)) \n: true), mz = p(z) + (t(p(z)) : true) 4--(true : z = f(a)); then (?f, T) +$ ml but ( l-f, T) ~$ 72. \nThe semantic objects will consist of (equivalence classes) of consistent constrained atoms. In the fol\u00adlowing \nwe will often denote by ~ any sequence of con\u00adstraints (ti(g$ ) : telli) ~=1 and by q[p] the sequence \n(t,(ga :: p) : i!e//,)~=l. Definition 3,9 (equiv. of constrained atoms) Let ~1 and X2 be constrained \natoms; ~1 N ~z ifffor every termination theory T, store u and resolvent p there is a renaming ~~ of X2 \nsuch that (HIT) t=: mle (H,q t=:m!. Note that for any constrained atom T = p(i) + q there is an equivalent \nconstrained atom of the form # = p(~) -~ (in which z are distinct variables not occurring in n) defined \nby taking new variables % and q = (true : z = i) + q. So in the following, any constrained atom may be \ndenoted as p(I) + q. Definition 3.10 (l?; base) Let P be a T program. The base of interpretations for \nPI denoted B; is the set of equivalence classes of constrained atoms over the alphabet of P. Definition \n3.11 (interpretation) An interpretation is any subset of B$. In the following we give a fixpoint characterization \nof the semantics in terms of a continuous immediate r-consequence operator T;. Definition 3.12 Let P \nbe a r-program. The mapping is defined by: T$(I) = CSH+COBI, . . .. B., EP, for i= l..n Pz=Bi+l, . . \n..Bn. T,= H, -q,, [m,]-c 1, iji = (true : H; = ~i) +-~i[pi], C, rl, . . . . Xn are renamed apart, ?j=c+?=jl+.. \n.qn, n, H~OH+ij Definition 3.13 (Fixpoint semantics) The fixpoint semantics for a r-program P is defined \nby 7(P) = /fp(TJ) = T; ~ W. Example 3.5 Consider the following r pro,grams P( and P; where IIT = {t}: \n P;: p(z) + true 0. p(z) + (i(p(z)) : z = s(y)) 0 p(y). P;: p(z) + (t(p(z)) : true) 0 . p(z) 4-(true \n: z = s(y)) 0 p(y). The fixpoint semantics of P; and P; are: 3(P;) = ~ p(r) + true, p(z) + (t(p(z)) \n:$ = s(y)), p($) + (t(p(z)) : z = s(y)) + (t(p(?J)) : ?J= S(2)), p(z) -(i(p(z)) : t = s(y)) -(t(p(y)) \n: y = s(2)) -(t(p(z)) : z = s(w)), } 3(P;) = p(z) + (t(p(z)) : true), p(z) + (true : x = s(y)) + (t(p(y)) \n: true), p(z) + (true : z = s(y)) t-(true : y 0 s(z)) + (t(p(z)) : true), . { 1 In Example 3.6 (below) \nwe show how to compose an interpretation for the ask predicate t with 2:( P{ ) and f(PJ ) to provide \nsuccess sets for P: and P;. The choice of P; and P; is further motivated by Example 4.3. Equivalence \nof operational and declarative semantics By composing the open declarative semantics 7(P) of a program \nP with a termination theory T we can derive the corresponding success set S7 (P). Definition 3.14 (composition) \nLet I be an interpretation, p a reso!vent and T a termination theory. The composition 1[7] of I and T \nwith respect to p is defined by: IIT](P) = Proposition 3.2 (monotonicity of composition) Let I be an \ninterpretation. If ?1 < Tz then for each resolvent p l[7~](p) ~~ l[7z](p), Example 3.6 Consider the programs \nP; and P; from Example 3.5 and let TI = {f(g) I g c A(II, IIP, Var)*} and T, = {t(g) I g E A(Z, IIP, \nO)*} where 22 = {O,s} and IIP = {p}. Then T-( Pf)[Tl](A) = {p(t) I t ~ T(X, Var)} and X( P~)[T_](A) = \n{p(t) ] t c T(Z)}. The following theorem states the soundness and completeness of the fixpoint semantics \nwith respect to the operational notion of success set. Theorem 3.3 (soundness and completeness) Let P \nbe T program and T be a termination. theory. Then ST(P) = 3( P)[7](A). PROOF. [(comment)] The proof of \n(~) is by induction on the length of the refutation while the proof of (~) is by induction on the power \nof T;. Both apply the sequential (left-to-right) composition of the operational semantics: for a goal \n(true : ao) 0 Bl, ....l?~ (true:uo) 0 l?~,...,ll~~~ (true :o~) 0 iff (true :u~) aBi+l, ....Bk to the \ninduction hypothesis. 0 Strong equivalence shows the equivalence between the operational semantics of \na program and the an\u00adswers which can be computed from its fixpoint seman\u00adtics for arbitrary goals: Definition \n3.15 (answers of an atomic goal) Let I be an interpretation and let T be a termination theory. The set \nof answers for a goal G = (true : teil) Dpl(71), ...,p~(l~) in I for T is defined by: ans~(G) = for \ni= l..n Pz(32) ~ ~[q(Pz+l(~~+l), ,Pn(~n)), u Pl(~l), . . ., pn(~n), G are renamed apart, ~ =iQl {Ez = \nii} Utf31/, H +0 C7 {} Theorem 3.4 (strong equivalence) Let P be r progmm, T a termination theory and \nG = (true : tell) O 111,..., Bn be a goal. Then u C ans~(P)(G) iff a ~ OT(P)(G) and Gu = Gu .  4 Modelling \nProlog in r The basic idea applied in this section is to specify in a <declarative way the condition \nupon which a Pro\u00ad log clause might eventually be chosen under a depth first strategy. Namely, that there \nis no infinite path to the left in the corresponding SLD tree. This idea is first applied to model Prolog \ncontrol in r. A transfor\u00ad mation which associates a Prolog program P with a corresponding r program Pr \nis introduced. The same idea is then applied to define an operational seman\u00ad tics for Prolog which is \nused to argue the correctness of this transformation. We assume that Prolog evaluation proceeds until \nall answers are generated and that Prolog evaluation is sound. A Prolog program is viewed as a set of \npred\u00ad icates, each predicate consisting of an ordered set of clauses. Prolog goals are sequences of atoms. \nThe basic idea is demonstrated by an example: Example 4.1 Consider the following Prolog program with \nthe ini\u00adtial goal G = p(i), r-(~): p(i) -q(i). P(L) + ~(~). The intended operational semantics can be \ndescribed by: 1. The first clause is applied to p(~) if ~ unifies with fi. The success of G then depends \non the suc\u00adcess of the goal q ({z), r(;), under the unification substitution. 2. The second clause is \napplied if (a) starting the computation of G with the first clause for p, it terminates (e.g. finitely \nfails or succeeds); and (b) i unifies with ~.   The success of the goal then depends on the suc\u00ad cess \nof r(~), r(~) under the unification substitu\u00ad tion. This behaviour is naturally captured by the follow\u00ading \nT program: p(l) + (true :Z = ~) 0 q(fi). p(z) + (temn~(p(i)) : z = 73) 0 7-(74), The ask ierv-n~(p(~)) \nis intended to test if a Prolog goal can be resolved with the second clause for p. Namely, that the computation \nwhich applies the first clause to that goal terminates, In fact, the operational seman\u00adtics of ~ will \ntest temn~(p(~) :: p) where p corresponds to the rest of the Prol;g goal. The claim is that-given the \nintended termination theory for term; (i.e. -the one which corresponds to the Prolog program) the op\u00ad \nerational semantics of the above ~ program captures the intuitive meaning of the original Prolog program. \nThis argument is justified below. The following definitions specify the transformation from Prolog to \n~ and what we mean by the intended termination theory. Definition 4.1 (t ransforrnation) Let P be a Prolog \nprogram. For each predicate {Cl, . . . . Cm} in P we generate from the clause Ci ~ P(l) +--Body a corresponding \nT clause: C; s p(i) + (ierm~(p(~)) :2 = ;) 0 Body. The corresponding r program P is then defined by collecting \nthe respective C[ clauses for all the predi\u00adcates in P: {c,,..., cn}c P, pr = CT t i~{l, . . ..n} { } \nThe IIT predicates tern$(p(i)) in the above defini\u00adtion correspond to tests which are intended to enable \n~ reduction of a goal with a clause C,T only in case Prolog computation of the corresponding goal start\u00ading \nwith the preceding clauses for that predicate (i.e. {c,,..., Ci_l}) terminates. Note that under this \nin\u00adterpretation term; is vacuously true. By SLD reduction we mean usual resolution with a left-to-right \nselection rule [19]. An SLD reduction is captured by: Definition 4.2 (resolve) Let Clause denote the \nset of Horn clauses. Dejine: resolve : Atom x Clause -+ 2At0m by: resolve( G, H +--Body) = (Body ::B){H \n= A} if G = A IB, 0 otherwise. { The following definition is motivated by the observa\u00adtion (e.g. [2]) \nthat when reasoning about termination of all solutions for a goal with a Prolog program, it is possible \nto ignore depth first search and hence to consider the corresponding SLD tree (with a left-to\u00adright selection \nrule). The proof of this observation is straightforward. Definition 4.3 (intended termination theory) \nLet P be a Proloq proqram. The intended termina\u00adtion theory for P is dejined by: 7-p,o,og(P) = {CI,..., \n}.} defines pin Pand forl~i~n term;(g) if g E U resolve(g, Cj) then J<2 { the SLD tree for P and g is \nfinite under instantiation). PROOF. [(comment)] The proof follows from properties of SLD trees. l In \nthe next section we discuss how to approximate the intended termination theory for a Prolog program. \nMeanwhile, we claim that given the intended termina\u00adtion theory for a Prolog program, the corresponding \nT program captures the operational meaning of P. To formalise this we introduce an operational semantics \nfor Prolog. We will need the following: Definition 4.4 (finite-transitive) A relation R ~ X x X on a \nset X is finite-transitive for x E X ifl the muiti-sei {x I xR*x } is jinile. The following definition \nspecifies a transition rela\u00adtion for logic programs with a left-to-right selection rule (but ignores \nthe depth-first search of Prolog). This definition is then applied to specify the transi\u00adtion relation \nfor Prolog. The implicit use c)f stores instead of substitutions is not essential. Definition 4.5 (transition \nrelation for SILD) Let P be a logic program; *P ~ Atom+ x Atom* is the relation defined by: S ld 9 -p \n9 @ g E u resolve(g, C) C6P We denote by predp(A) the predicate (i.e. ordered set of clauses) for atom \nA in Prolog program P. Definition 4,6 (transition relation for Prolog) pro log Let P be a Prolog program; \np ~ Atom* x Atom is the smallest relation such that pvolog AIB p G ifpredP(A) = {Cl,..., Cn}; 1s i s \nn; G E resotue(A I B, Ci); and VG c u resolve(A I B, Cj) the ]<% relation tip is jinite-transitive for \nG . The success set of a Prolog program P is captured prolog in terms of the transitive closure of P. \nDefinition 4.7 (Prolog success set) Sprolog : Prolog + 2At0m Sp,.l.g(P) = { A e A~om A =; true ) Theorem \n4.2 Let P be a Prolog program and P the corresponding r program. The Prolog success set SPrOiOg(P) = \n7( P )[7&#38;o/.g(P)](A). The proof argues the correspondence between the respective operational behaviors \nof P and of P7 given the corresponding intended termination theory. The ask conditions for termination \nin a computation of P correspond precisely to the conditions for a Prolog transition. u Note that: Proposition \n4.3 Let P be a Prolog program and 71P denote a termination theory which for every predicate p and corresponding \nith clause contains term:(g) for every resolvent g. 7( P )[Trp](A) is the success set of P interpreted \nas a iogic program. In the following examples we write true instead of the corresponding termination \nconditions for the first clause. Furthermore we do not specify these atoms in the respective termination \ntheories. This simplifies somewhat the present ation. Example 4.2 Consider the following two Prolog pro\u00adgrams \nwith Z = {O, s} and IIP = {p}: PI p(x). p(s(y)) -p(y). P2 p(s(y)) +-p(y). P(x). The transformed programs \nare respectively ?; p(x) i--(true : true) Cl, p(x) + (term~(p(x)) : z = s(y)) D p(y). P; p(z) 4-(true \n: x = s(y)) 0 p(y). p(z) + (term~(p(z)) : true) 0 . The intended termination theories for PI and P2 \nconsist respectively of the non-ground and ground sets of goals: T&#38;OlOg(Pl) = {term;(g) I g c A(E, \nHT, Var) } and TP~0r0g(p2) = {ierm~(g) 19 E A(Z, ~P, O)*}. The open declarative meanings of P; and P; \ncorre\u00adspond to those given in Example 3.5; the success sets correspond to those given in Example 3.6: \nSProlog(pl ) = Y(P:)[TP.O]Og(Pl )l(A) = {u(t) I tE T(E, Var)} sPro?og(p2 ) = f(P;)[Tpro/og(Pz)] (A) = \n{P(t) t c T(Z)}, which express the computational beha.viour of the original Prolog programs. In particular, \n F(~i)[TPMg(P2)](A) does not inclucle p(z) which corresponds to the fact the the Prolog computation does \nnot succeed for that goal (because it diverges). Note that while the depth-first search strategy is captured \nby the transformation and the corresponding termination conditions, the left-to-right selection rule \nis modelled by the sequential composition of atoms in the bodies in ~-clauses. In the following example \nwe show how the order of the atoms in the body of a Prolog clause leads to different solutions and how \nthe declarative semantics of the transformed program captures this fact. Example 4.3 The Prolog program \nQ q(z) -p(r), r(z) p(s(y)) +--p(y). p(z). r(0). is transformed in a ~-program Q : q(z) +-(true : true) \n0 p(z), r(z). p(z) + (true : z = s(y)) U p(y). p(x) +-(terrn~(p(z)) : true) 0 . r(x) f--(true : z = O) \n0 . The declarative meaning of Q is $(Q ) = r(z) +-(true :x = O) g(z) +--(termj(p(z), r(z)) : true) IJ \n7( P;) -(true :x = O) {} where f(P~ ) is defined in Example 3.5. Note that the solutions z = Sn (0) \nare inconsistent, with the only solution for r (i.e. z = O). The intended termination theory TprOIO~ \n( Q) con\u00adtains {termj(p(t), r(t )) I t G T(X), t c 7 (X, Var)}. By considering the intended termination \ntheory, the goal q(z) does not succeed because T&#38;o/og(Q) ## terrn~(p(z), r(z)), while q(0) succeeds. \nChanging the order of the atoms in the body of the first Prolog clause (and in the corresponding r one) \nleads to the model F(QT) = r(z) +-(true :2 = O) q(z) +-(true(p(z)) : z = O) (J 7(P;). +..-(ter???j(p(Z)) \n: true} {1 In this case q(z) succeeds with answer z = O.  5 Modelling Termination In the previous section, \nwe have shown how to cap\u00adture declaratively the success set of a Prolog program P by composing an interpretation \nfor a correspond\u00ad ing r program P7 with the intended termination the\u00adory TprO/Og P). Of course TPrOiOg \n(P) cannot be effec\u00ad ( tively computed. However, the goal of this paper is to provide a semantic basis \nfor the analysis of Pro\u00adlog programs and for this purpose approximations of T&#38;~I~g(P) both from above \nand from below can be useful: from above: T. z 7P,O/Og(P) * ~(p )[T~](A) Q 7(PT )[TPro]og (P)] (A) hence \nproviding an approx\u00adimation from above of the (Prolog) success set for P. This may provide better approximations \nthan can be achieved when abstracting the meaning of P as a logic program. In particular because by Proposition \n4.3 the success set of the logic pro\u00adgram P is 7( P7)[T1P](A) and taking T. C 71P, gives 7( P )[7.](A) \nC 7(PT )[fil,](A). from below: Th Q 7prO(Og(P) + F(P )[Tb](A) ~ 7( P7)[7P,010g(P)](A) hence providing \nan approx\u00adimation from below of the (Prolog) success set for P which can be useful for example in the \ncontext of the complexity analysis described in [14]. Figure 5 illustrates the computation tree for a \nlogic program P and a goal G for a left-to-right selection rule in which the left most infinite branch \nis indicated. Let P denote the corresponding r program. The so\u00adlutions for G correspond to the success \nbranches of the entire tree. These can be derived by composing T(PT ) with TrP. The solutions for G assuming \nPro\u00adlog s depth-first strategy are those which are to the left of the infinite branch. These can be derived \nby composing 7(P~) with the intended termination the\u00adory TprOIO~ (P). Approximations of the Prolog solu\u00adtions \nfor G from above and below can be derived by composing X(PT ) respectively with Ta and Tb which approximate \nT from above and from below. We would like to capture the intended termina\u00adtion theory for a Prolog program \nP as the declara\u00adtive meaning of some corresponding t-program. This would provide a precise declarative \nspecification of Z+-0109(P) by applying the ~ semantics. Furthermore it would enable approximations to \nbe derived by ab\u00adstract interpretation. Consider the following example: Example 5.1 Let 117~ = {#} (i.e. \nnot unijiab[e ) and consider the following ~ program R: t(z) -(z + s(-) : true) 0 l. t(z) +--(true : \nx = s(z )) Cl t(z ). 102 so as to model termination from within and applying abstract interpretation. \nThe basic idea of defining semantics for Prolog with\u00adout considering notions such as depth-first search \nand backtracking, which are more (sequential) implemen\u00adtation oriented is an important contribution of \nthis paper. In particular, this idea can be applied to de\u00adfine a simple and concise operational semantics. \nWe are currently in the process of applying this idea to other semantic definitions and extending our \nresults to model full Prolog. References T~ \\ [1] K. R. Apt. Introduction to Logic Programming. ~lp \nIn J. van Leeuwen, editor, Handbook of Theoret\u00adinfinite branch ical Computer Science, volume B: Formal \nMod\u00ad \\ els and Semantics. Elsevier, Amsterdam and The MIT Press, Cambridge, 1990. Figure 5 SLD-tree \nfor G with P [2] K. R. Apt and D. Pedreschi. Proving Termina\u00adtion of General Prolog Programs. In Proc. \nof Int. The declarative meaning of R is Con~ on Theoretical Aspects of Computer Sofl\u00adware, Sendai, Japan, \n1991. t(x) -(z # s(-) : true), 3(R) = t(z) +-(true : z = s(z )) +-(z # s(-)), [3] B. Arbab and D.M. Berry. \nOperational and De\u00ad. . . notational Semantics of Prolog. Journal of Logic {} Programming, 4:309-330, \n1987. If T# is the (downward closed) theory corresponding to not-unifiable and x = {O, S} then F(R) \n[T#](A) [4] F. Bancilhon, D. Maier, Y. Sagiv, J. D, Unman. gives the set {t(O), t(s(0)), t(ss(0)), . \n..} which, corre-Sets Other Ways Magic and Strange to Imple\u00adsponds to the intended termination theory \nfor the Pro\u00ad ment Logic Programs. Proceedings of the ACM log program P2 in Example 3.5. Symposium on \nPrinciples of Database Systems, pages 1-15, Cambridge, Massachusetts, 1986. However, in general to model \nintended termination theories as r programs we need to introduce a notion [5] R. Barbuti, R. Giacobazzi, \nand G. Levi, A Gen\u00ad of user defined predicates in the ask parts of clauses eral Framework for Semantics-based \nBottom-up and to interpret them as local tests which do not affect Abstract Interpretation of Logic Programs. \nTech\u00ad the global bindings of variables. nical Report TR 12/91, Dipartimento di Infor\u00admatica, Universit&#38; \ndi Piss, 1991. Submitted for publication. Conclusions [6] E. Borger. A logical operational semantics \nof We have presented a simple constraint logic language T full Prolog. In E. Borger, H. Kleine, H. Buning,together \nwith its operational and declarative seman\u00adand M. Richter, editors, CSL 89. 3rd workshoptics. The operational \nsemantics is used to justify a on Computer Science Logic, volume 440 of Lec\u00adtransformation which captures \nthe control of a Pro\u00adture Notes in Computer Science. Springer-Verlag, log program given a suitable termination \ntheory. The Berlin, 1990. declarative semantics is parametric with respect to this theory enabling the \nspecification of Prolog mean\u00ad [7] A. Bossi, N. Cocco, and M. Fabris. Proving Ter\u00ading by composition of \na logic part with a control mination of Logic Programs by Exploiting Term part . Because the declarative \nsemantics of r is both Properties. In S. Abramsky T.S .E. Maibaum, simple and in the usual Tp style it \nprovides a suit\u00ad editor, Proc. TAPSOFT 91, volume 494 of Lec\u00adable basis for abstract interpretation of \nProlog via the ture Notes in Computer Science, pages 153-180. defined transformation. Springer-Verlag, \nBerlin, 1991. The required termination theory can be approxi\u00admated either by integrating results on Prolog \ntermina-[8] A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. tion (e.g. [2,7,21,23]) or by extending \nthe ~ language Contributions to the Semantics of Open Logic Programs. Technical report, Dipartimento \ndi In\u00adformatica, University di Piss, 1991. [9] M. Bruynooghe, G. Janssens, B. Demoen, and A. Callebaut. \nAbstract Interpretation: Towards the Global Optimization of Prolog Programs. In Proc Fourth IEEE Symp. \nLogic Programming, pages 192-204. IEEE Comp. Sot. Press, 1987. [10] M. Codish, D. Dams, and E. Yardeni. \nBottom\u00adup Abstract Interpretation of Logic Programs. Technical report, Dept. of Computer Science, The \nWeizmann Institute, Rehovot, 1990. Submitted for publication. [11] P. Cousot and R. Cousot. Abstract \nInterpreta\u00adtion: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation \nof Fixpoints. In Proc. Fourth ACM Symp. Prin\u00adciples of Programming Languoges, pages 238 252, 1977. [12] \nA. de Bruin and E. de Vink. Continuation seman\u00adtics for Prolog with cut. In J. Diaz and F. Ore\u00adjas, editors, \nProc. CAAP 89, volume 351 of Lec\u00adture Notes in Computer Science, pages 178-192. Springer-Verlag, Berlin, \n1989. [13] S. K. Debray and P. Mishra. Denotational and Operational Semantics for Prolog. In M. Wirs\u00ading, \neditor, Formal Description of Programming Concepts III, pages 245-269. North-Holland, Am\u00adsterdam, 1987. \n[14] S.K. Debray and N.W. Lin. Automatic Complex\u00adity Analysis of Logic Programs. In K. Furukawa, editor, \nProc. Eighth Int 1 Conf. on Logic Program\u00adming, pages 599 613. The h41T Press, Cambridge, Mass., 1991. \n[15] M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. Declarative Modeling of the Op\u00aderational \nBehavior of Logic Languages. Theoret\u00adical Computer Science, 69(3):289 318, 1989. [16] J. Jaffar and J.-L. \nLassez. Constraint Logic Pro\u00adgramming. In Proc. Fourteenth Annual ACM Symp. on Principles of Programming \nLanguages, pages 111-119. ACM, 1987. [17] N. D. Jones and A. Mycroft. Stepwise Develop\u00adment of Operational \nand Denotational Semantics for Prolog. In Sten-~ke Tarnlund, editor, Proc. Second Int 1 Conf. on Logic \nProgramming, pages 281-288, 1984. [18] G. Levi. Models, Unfolding Rules and Fixpoint Semantics. In R. \nA. Kowalski and K. A. Bowen, editors, Proc. Fifth Int 1 Conf. on Logic Program\u00ad ming, pages1649 1665. \nThe MIT Press, Cam\u00adbridge, Mass., 1988. [19] J. W. Lloyd. Foundations of Logic Programming. Springer-Verlag, \nBerlin, 1987. Second edition. [20] K. Marriott and H. S@ndergaard. Bottom-up Ab\u00adstract Interpretation \nof Logic Programs. In R. A. Kowalski and K. A. Bowen, editors, Proc. Fifth Int 1 Conf. on Logic Programming, \npages 733\u00ad 748. The MIT Press, Cambridge, Mass., 1988. [21] L. Plumer. Termination Proofs for Logic \nPro\u00adgrams, volume 446 of Lecture Notes in Artifi\u00adcial Intelligence -subseries of LNCS. Springer-Verlag, \nBerlin, 1990. Ph.D. Thesis. [22] V. A. Saraswat and M. Rinard. Concurrent con\u00adstraint programming. In \nProc. Seventeenth An\u00adnual ACM Symp. on Principles of Programming Languages. ACM, 1990. [23] K. Vershaetse \nand D. De Shreye. Deriving Termi\u00adnation Proofs for Logic Programs, Using Abstract Procedures, In K. Furukawa, \neditor, Proc, Eighth Int 1 Conf. on Logic Programming, pages 301\u00ad 315. The MIT Press, Cambridge, Mass., \n1991.  \n\t\t\t", "proc_id": "143165", "abstract": "<p>The goal of this paper is to construct a semantic basis for the abstract interpretaion of Prolog programs. Prolog is a well-known logic programming language which applies a depth-first search strategy in order to provide a practical approximation of Horn clause logic. While pure logic programming has clean fix-point, model-theoretic and operational semantics the situation for Prolog is different. Difficulties in capturing the declarative meaning of Prolog programs have led to various semantic definitions which attempt to encode the search strategy in different mathematical frameworks. However semantic based analyses of Prolog are typically achieved by abstracting the more simple but less precise declarative semantics of pure logic Programs.</p><p>We propose instead to model Prolog control in a simple constraint logic language which is presented together with its declarative and operational semantics. This enables us to maintain the usual approach to declarative semantics of logic programs while capturing control aspects such as search strategy and selection rule.</p>", "authors": [{"name": "Roberto Barbuti", "author_profile_id": "81100607617", "affiliation": "", "person_id": "P247082", "email_address": "", "orcid_id": ""}, {"name": "Michael Codish", "author_profile_id": "81100633343", "affiliation": "", "person_id": "P196640", "email_address": "", "orcid_id": ""}, {"name": "Roberto Giacobazzi", "author_profile_id": "81100572239", "affiliation": "", "person_id": "PP14198144", "email_address": "", "orcid_id": ""}, {"name": "Giorgio Levi", "author_profile_id": "81341493216", "affiliation": "", "person_id": "PP39079615", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143186", "year": "1992", "article_id": "143186", "conference": "POPL", "title": "Modelling Prolog control", "url": "http://dl.acm.org/citation.cfm?id=143186"}