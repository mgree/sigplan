{"article_publication_date": "02-01-1992", "fulltext": "\n PER moclels of subtyping, and higher-order Kim Bruce* Computer Science Department Williams College Williamstown, \nMA 01267 lrirn~cs .williams .edu Abstract We relate standard techniques for solving recursive domain \nequations to previous models with types in\u00adterpreted as partial equivalence relations (per s) over a \nDm lambda model. This motivates a particular choice of type functions, which leads to an exten\u00adsion of, \nsuch models to higher-order polymorphism. The resulting models provide natural interpretations for function \nspaces, records, recursively defined types, higher-order type functions, and bounded polymor\u00adphic types \nY-X <: Y. A where the bound may be of a higher kind. In particular, we may combine recursion and polymorphism \nin a way that allows the bound Y in VX <: Y. A to be recursive y defined. The model may also be used \nto interpret so-called F-bounded polymorphism. Together, these features allolv us to represent several \nforms of type and type functions that seem to arise naturally in typed object-oriented pro\u00ad gramming. \n Introduction In type systems aimed towards object-oriented pro\u00adgramming, several typing ideas naturally \narise. The most basic are subtyping, the fact that values of one type may be treated as values of another, \npolymor\u00adphism, and recursively defined types. Since many of *Part of this work was done while the author \nwas on leave at the Computer Science Department, Stanford University, and at the DEC Systems Research \nCenter. Partially supported by NSF grant CCR-9105316 and, at Stanford, the Powell Foundation. t s~lpported \nin part by an NSF PYI Award, matching funds from Digital Equipment Corporation, the Powell Foundation, \nand Xerox Corporation NSF grant CCR-881 4921 and the Wal\u00ad lace F. and Lucille M. Davis Faculty Scholarship. \n Pennksion to copy without fee all or part of this material is granted provided that tie copies are not \nmade or distributed for direct commercial advantage, the ACM copyright notice and the title of tbe publication \nand its date appear, and notice is given that copying is by permission of tbe Association for Computing \nMachinery. To copy other\u00adwise, or to republish, requires a fee sad/or specific permission. recursive \ntypes polymorphism John C. Mitchellf Computer Science Department Stanforcl University Stanforcl, CA 94305 \nmitchell@cs .stanf oral. edu the existing, implemented type systems for object\u00adoriented languages have \nnotable errors (see, e.g., [CO089]), it is important to prove the soundness of these type systems. The \nprimary technique for do\u00ading so is by constructing a selmantic model. A class of semantic models for \nlanguages with subtyp\u00ading, polymorphism and recursion are developed in [Cop85, Ama91, Car89, AP90]. These \nmodels all in\u00ad terpret types as partial equivalence relations (per s) over suitable Dm structures obtained \nby the so-called inverse limit ) construction. The main contributions of this paper are to provide a \ngeneral framework for understanding type recursion in these models and to extend per models to higher-order \ntype functions and additional forms of polymorphism. Since the use of per s over a single domain gives \nus natural interpre\u00ad tations of subtyping and polymorphism, most of the technical effort, in the previous \npapers and our own, is directed toward the problem of recursively-defined types. The first contribution \nof this paper is a categorical diagram relating the apparently ad hoc view of type recursion in [Cop85, \nAma91, Car89] to the category of domains approximating D@. While similar in form to the view expressed \nby Abadi and Plotkin in [AP90], our fundamental cliagram may be applied directly to the earlier models \nof [Cop85, Ama91, Car89]. We also use this diagram to identify a larger class of type functions with \nfixed points than the [AP90] con\u00adstruction. This allows us to interpret some useful forms of polymorphism \n(specifically, bounded and F\u00adbouncled polymorphism) that were excluded from the Abadi-Plotkin model. \nOur second contribution is to extend previous mod\u00adels to alternate and higher-order forms of polymor\u00adphism, \nincluding solving domain equations over higher kinds. Bounded polymorphism, presented in [CW85], is extremely \nsuggestive for object-oriented programm\u00ading. The bounded polymorphic type VX <: A. B(X) is the type of \nall functions which, when applied to any subtype X of A, returns an element of the type @ 1992 ACM 089791-453-81921000110316 \n$1.50 B(X). For example, VX <: int. X-+X is the type of functions which, when applied to a subtype X \nof znt, maps X to X. Introduced in [CCH+89], F\u00adbounded polymorphism arises naturally in typing a style \nof object-oriented programming, and appears more useful than the original form of bounded poly\u00admorphism \nin the presence of recursive types. The type VX <: F(X). B(X) is the type of all functions which, for \nany type X satisfying the constraint X<: I (X) have functionality given by the type B(X). An alter\u00adnative, \ndiscovered independently by Luca Cardelli and the second author, is to use the type VG <: F. B(jix G), \nwhere G and F are both functions from types to types, in place of VX <: F(X). B(X). This seems to work \njust as well as F-bounded quantification on all of the motivating examples, but requires higher-order \npolymorphism, i. e., expressions parameterized by type functions and, possibly, higher-order functions \nfrom types to types. Before discussing higher-order type recursion in our models, we give a motivating \nexample. It might first appear that type constructors (functions from types to types) such as list and \ntree are recursively-defined functions. Although the usual definition, list(t) = unit+ t x list(t), \nappears to be the recursive definition of a function from types to types, we may actually de-sugar this \ninto a definition list = At: T.jx~(Jl: T. unit + t x 1) using an operator jixT that finds the least \nfixed point of any function from T to T, where T is the kind (col\u00adlection) of types. (Here, unit is the \ntrivial type with a single element. ) Since we only use a fixed point opera\u00adtor on type functions, as \nopposed to type functional, tree only requires recursive definitions of types. The same is true of other \nfamiliar recursive type construc\u00adtors such as tree. If we try to define a type of list (objects, in the \nsense of object-oriented programming, then we seem to need higher-order type recursion. This example \nwas brought to our attention by Luca Cardelli and the Abel Group at HP Labs [CCH91, Car91]. In an object-oriented \nprogram, a list object will have meth\u00ad ods such as empty?, to say whether the list is empty, and head \nand tail to return the head and tail of the list represented by the object. The types of these meth\u00ad \nods would appear in the type of the list object, as discussed in [CM91, CHC90, CCH+89, Mit90a], for example. \nThis gives us an ordinary recursive defini\u00ad tion such as list(t) = { head: unit -+ t tail: unit ~ kt(t) \nempty?: unit -+ bool} in which list appears recursively, but the definition may be written so that only \na fixed point operator for ordinary type recursion is required. If we wish to add a map function to \nlist objects, where map takes an function argument and applies this to every element of the list, then \nwe would define lists by the more complicated recursive type list(t) = { ... map: Vs. (t -+ s) -/2s1(s)}. \n The significant aspect of the type of the map function is that now list appears with an argument other \nthan t. For this reason, we must interpret this declaration as the result of applying a higher-order \nfixed-point oper\u00adator to a functional that maps type functions to type functions. This is illustrated \nin Section 7. Another example that might be of interest is the type of list objects with a method power: \nunit ~ Zist(kt(t)). Some related kinds of polymorphism have been dis\u00ad cussed in connection with proper \nextensions of ML [Myc84, Hen89, KTU89]. In this paper, we show how to extend any suitable per model to \nhigher-order type functions by identify\u00ading a general class of rank-ordered sets and func\u00adtions. These \nform a cartesian closed category such that every rank-increasing function has a unique fixed point. Several \nclasses of per s over D~ may be rank-ordered, using ranks induced by the domains DO, D1, DZ, . . . approximating \nDw, allowing us to in\u00adterpret type functions, type functional, and so on as rank-preserving functions. \nIn type-theoretic terms, this technique gives a model of Fw with subtyping at each kind (order) and recursion \noperators (with a minor technical restriction on uses of recursion) at each kind. The construction may \nbe carried out for a variety of collections of per s. In particular, we ob\u00adtain one model whose types \nare the same as those in [Ama91, Car89] and another whose types are similar to those in [A P90]. The \nadvantage of the latter ver\u00adsion is that the set of elements of each type forms an u-algebraic cpo, allowing \nproofs by fixed point induc\u00adtion. By choosing an appropriate D@ model to begin with, any of the previous \nmodels could be extended to the basic form of records described in [Car88]. Al\u00ad though we do not discuss \nrecords at any length in this paper, it is our belief that the moclels given here ex\u00ad tend to more flexible \nforms of record types, possibly including the type operations described in [CM9 1]. We hope to explore \nthis in future work. The models obtained by our techniques are closely related to others appearing in \nthe literature. The pa\u00ad per [BL90] describes a model of subt ypes and bounded polymorphism based on partial \nequivalence relations. The semantic models described in [Ama91, Car89] added support for type recursion \nto models of sub\u00adtypes and bounded polymorphism, although the lat\u00adter is not discussed explicitly in \n[Ama91]. However, as presented, the previous models do not provide an interpretation for recursively-defined \ntype functions or any extension of bounded polymorphism that in\u00advolves type functions. In [AP90], where \na similar but more structured class of models are developed, the type functions are realizable functors. \nHowever, these models do not have an obvious interpretation of bounded quantification, since this type \noperation is not functorial (treating VZ <: A. B as a function of the bound A). In this instance, the \nstrict categorical approach does not seem adequate for treating com\u00ad binations of type recursion and \nbounded quantifica\u00ad tion. Another class of related models are those based on partial equivalence relations \nover the natural num\u00ad bers. In [FRMS90], a form of domain is developed within the standard effective \ntopos over natural num\u00ad bers with partial recursive function application; re\u00ad lated work may be found \nin the references of that paper. The precise relation between domains in an effective setting and the \neffective topos over a domain does not seem clear at the time of this writing. As a final pointer into \nthe literature, we mention that [BTCGS90, BTCGS91] describe a method for inter\u00ad preting languages with \nsubtyping and related forms of polymorphism in models of languages without subtyp\u00ad ing. 2 Overview of \nthe model In concrete terms, the main idea is that we choose some suitably rich cpo D@, constructed \nas the limit of cpo s Do, Dl, D2, . . .. and interpret types as certain partial equivalence relations \n(per s) over DW. Recall that a per over a set A is a symmetric and transi\u00ad tive binary relation on A \n(see [Mit86, Mit90b], for example, for further explanation). For each suitable per R &#38; DW x DW, there \nis a sequence of relations R[q , R[l] , R[2] , . . .. determined by R and the sequence of domains Do, \nDl, DZ) . . .. such that R is the limit of the R(il s in a natural and entirely standard sense. We call \nthe relation R[il the rank z approximation of R, or sometimes the ith approximation of R for short. \nThe type functions in the model are all func\u00ad tions from suitable per s to suitable per s which re\u00ad \nspect the ranked approximations of relations in a cer\u00ad t ain way. Each such function, F, has an approximat\u00ad \ning sequence, F[ol, F[ll, F[21, . . .. and so the collection of type functions turns out to have the \nsame abstract rank ordered structure as the collection of suitable pers. This allows us to repeat the \ndefinition of suitable function for higher kinds (such as functions from type functions to type functions). \nSince all of this is done using per s over a single domain, we have standard interpretations of subtyping, \nas in [B L90], and poly\u00admorphism, as in [BL90, CL90, Gir72, Mit86, Tro73]. Moreover, every function with \na certain rank property has a unique fixed point. This gives us recursion op\u00aderators at all kinds. Finally, \nall of the standard type constructors and all variations of bounded quantifica\u00adtion mentioned in the \nintroduction have the required rank-related properties to be included in the model. 3 PEELs and the \nD~ construc\u00adtion 3.1 Categorical setting for recursive domain equations We begin by describing the setting \nfor the D~ con\u00adstruction. We work with w-complete partial orders and two classes of maps, continuous \nfunctions and embedding-projection pairs. The reader may re\u00adcall from [Bar84, GS90, SP82] that an embedding\u00adprojection \npair between cpo s D and E consists of maps e:D -E and p:E -+ D such that poe = idD and e o p < idB. \nThe map e is called the embedding, and p the projection. Each determines the other, as\u00adsuming both exist, \nso it suffices to name the embed\u00adding or the projection. We find it convenient to work with projections \nand leave embeddings implicit. We write CPO for the category of u-complete partial or\u00adders with continuous \nmaps, and CPOP for the category of u-complete partial orders with projections. If Al is a continuous \nfunctor from CPO p to CPOP, then we may construct a cpo D@ as the inverse limit of the w-diagram  AY(l)wir(qw \n where 1 = {-L} is the one-element cpo (the terminal object of both GPO and CPOP) and x is the unique \nprojection from H(L) to the terminal object. It is common notation to write Di for Hi (J_) and say that \nDm is the limit of the Di s. We write pi for the projec\u00ad tion from Dm to ,D~, A consequence of the continuity \nof h! is that Dm is isomorphic to H(Dm); this is in fact the definition of u-continuity for functors. \nAn important fact is that each Di is isomorphic to some subdomain ~i ~ Dm, with projection ii from Dm \nto Di. If d c Dm, we write d[q for fli (d) and note that each d c D~ is the limit (inside Dm ) of the \nu-chain [0] < d[l] < 42] < .... It is worth mentioning that most functors of interest are continuous \non CPOp; to be continuous on CPO p, it suffices to be locally con\u00ad tinuous over GPO [SP82]. 3.2 The category \nCPER of complete pers On morphisms, F is H x H, i.e., F($, g) = A general setting for studying per s \nand recursion is the category CPER. The objects of this category are pairs (R, D), where D is a cpo and \nR is a par\u00adtial equivalence relation on D which is closed under sups of w-chains. The morphisms of CPER \nare pairs of continuous functions which respect the relations. More specifically, (~, g) is a morphism \nfrom (R, D) to (R , D ) if ~, g: D-D are continuous and ~ R y im\u00adplies ~(z) R g(y). This is a subcategory \nof the infec\u00adtive scone of CPO x CPO [AMSW91], which is a sub\u00adcategory of the comma category (CPO J CPO \nx CPO), also called the scone or Freyd cover of CPO x CPO [LS86]. A related category may be found in \n[SP82, Example 6]. The argument given in [SP82, Example 6] also shows that CPER is an O-category with \nall w\u00adlimits. We write CPERP for the subcategory of CPER with projection maps. In the following section, \nwe use the category CPER to motivate the definition of rank-increasing functions. Using this category, \nthe general results of [SP82] im\u00adply that every rank-increasing function on pers has a fixed point, since \neach such function determines a con\u00adtinuous functor on CPERP. A caveat, however, is that the category \nCPER is not the category we use to-give meanings to expressions. The morphisrns of CPER are continuous \nfunctions, while the meaning of a term in any of the class of models covered by this paper is an equivalence \nclass of continuous functions. The impor\u00adtance of the equivalence relations are that these are required \nto make the models extensional. An alternative category is the one obtained from CPER by taking equivalence \nclasses of continuous func\u00adtions as morphisms. However, there does not appear to be a natural ordering \non equivalence classes un\u00adless we consider only antisymmetric pers (see Sec\u00adtion 8 and [AP90]), and only \nthe profinite, bifinite, or sfp domains. The arguments given in [AP90] may be used to show that this \nmore specialized category is an O-category with w-limits. The development given in the following section \nmay be carried out for CPER, as stated, or with CPER replaced with the cat\u00adegory whose objects are antisymmetric \npers over bifi\u00adnite domains and morphisms are equivalence classes of continuous functions. (Two continuous \nfunctions ~,g from R~DxDtoS~ExEareequivalent if $(x) S g(y) whenever x R y.) 3.3 Continuous extensions \nof CPO func\u00adtors to CPER We say functor F: CPERP -+ CPERP extends functor H: CPOP -+ CPOP if the following \nconditions are sat\u00adisfied: (Hall). We will only be interested in the case where both func\u00adtors are continuous. \nThe importance of this definition is given in the foliowing proposition, and the associ\u00adated fundamental \ndiagram in Figure 1. Proposition 3.1 IfF on CPERP extends H on CPOP, both continuous, then the diagram \nFn(l) in CPERP is a diagram of relations over the diagram Hn(l) in CPOP and, furthermore, the limit of \nFn(l) is a rela\u00adtion R@ over the limit Dm of Hn(l). The special caae we are interested in, as suggested \nby the terminology, is when H is the functor on CPO which is used to construct the Dm model we want. \nThen we have fixed points of each continuous F ex\u00adtending H, obtainable as limits of a diagram consisting \nof relations over the D~ s. In our models, the types wiil be per s and we will use the fundamental diagram \nto solve recursive equations over these types. Note that if F extends H, the action of F on morphisms \nis com\u00adpletely determined by H. For this reason, when we fix H, we work with object maps on CPERP, which \nare simply maps from pers to pers. This explains why we are able to give a categorical explanation to \na model whose type functions are simply per maps, rather than fUnCtOrS on CPER. 3.4 A specific D ~ and \ncollection of pers To construct a specific model, we choose a continuous functor H: CPOP -+ CPOP such \nthat the resulting limit cpo Dm is rich enough to interpret the programming language expressions of interest. \nFor concreteness, the reader may consider H(D)= A+[L-+D]+[D~D] as the standard example, where A is some \ncpo of atomic values (say natural numbers), L is a count\u00adably infinite flat cpo of labels used as component \nnames in records, and [D -+ D] is the cpo of all con\u00adtinuous functions from D to D. A technical detail \nthat will save the careful reader some confusion when we get to recursive type definitions is that + \nmust be coalesced, as opposed to separated, sum. This is so that all types over D@ share the same least \nelement. In working with bifinite domains and antisymmetric pers, A must be finite. This is not as severe \na restric\u00adtion as it might first appear, since a finite A here may lead to a countably infinite surnmand \nin the limit cpo, Dm = H(Dm). See [AP90] for more details. The types over Da will be partial equivalence \nrela\u00adtions satisfying certain conditions. . If F(R, D) = (R , D ) then D = H(D). Definition 3.2 A per \nR ~ Dm x Dm is nice if R = F(R) ... ... Do =-  Dl= Dz ... _ Dn Figure 1: The Fundamental Diagram: \nDi+l = H(Di) and Ri+l = F(Ri). 0 (l, l)c R The first clause is clearly necessary if per s are going to \ninterpret types in our models. (In the case that ad\u00ad If {(di, ei) Ii > O} is an w-chain in D~ x Dm ditional \ntype constructors are required, we would add with limit (d, e) and (di, ei) 6 R for each i, then appropriate \nrequirements to our notion of acceptable(d, e) GR. collection of per)s. ) The second clause on the exis\u00ad~ \nForalld, e~DW, (d, e) c R ifl (d[i], e[il) E R for tence of unique sups of increasing chains of per s \nwill all i. enable us to find unique solutions to domain equations over types. It plays the same role \nin our construction The first two conditions are needed to give closure as the completeness requirement \nin complete partialunder limits. The third, which also appears in [Cop85, orclers. Ama91, Car89], may \nnow be seen as the requirement The two specific collections of per s we mention inthat each per be the \nlimit of a sequence of pers of the Section 8 are acceptable for any collection of type con\u00adapproximating \ndomains Do, D1, . . as in Figure 1. If structors we have considered. The first is the collec- R is a \nnice per then we write R[il for the restriction of tion 7?. of all nice pers, called CUA in [Car89] and \nGU- R tothe subdomain Di of Dm. PER in [Ama9 1]. The second is all antisymmetric pers Standard type constructors \nsuch as function space, over a Dm model constructed in the category of bifi\u00adrecords, polymorphism and \nbounded quantification nite domains. For the rest of this section, we simply may all be interpreted as \noperations on per s; see require some acceptable collection of per s over a suit\u00ad [BL90, CL90]. We give \nprecise definitions of function ably rich Dm structure. For notational simplicity, we space, records, \nand F-bounded quantification in Sec\u00adrefer to elements of this collection as nice per s. tion 7. Ordinary \nsubtype bounded quantification is covered as a special case of F-bounded quantification. 3.5 A natural \nclass of per Imaps Definition 3.3 A collection R of nice pers over Da is acceptable if An appealing idea \nwhich is useless without further re\u00adfinement is that there is a cpo structure on nice pers. e 1? contains \nthe per, {(1, 1)}, and is closed under If R is a nice per with R = R[il for some i, then we function \nspace, records, and F-bounded quantifi\u00addefine the rank of R by cation. rnk(R) = min{i I R = R[il}. * \nIf {Ri~i < UJ ~ 7? satisfies the property that for al!j ~ i, R{il = Ri) then there is a unique R E 72, \n IfR#R[il foralli,wesayrnk(R) =~. WesayR such that for ail i, RLq = Ri. approximates S, and write R ~ \nS if rnk(R) is finite and R = S[~~~(R)]. The limit, or least upper bound, of an w-chain R. QRI ~R2 Q. \n. . of nice pers with rnk(Ri) = i is the relation R satisfying d R e iff d[zl Ri e[zl for all i, so the \ncollection of nice pers becomes a cpo with each R the limit of the R[q s. Since the collection of nice \npers has a cpo struc\u00adture, it is plausible to consider the collection of con\u00adtinuous functions from nice \npers to nice pers as the type functions of some model, and extend to higher kinds inductively as usual. \nBy the standard argument showing that any continuous function on a complete partial order has a least \nfixed point, we would ob\u00adtain recursion operators at every kind. However, this does not work! The most \nobvious problem is that the function space constructor is not monotonic, let alone continuous, with respect \nto the cpo structure on pers we have just described. In particular, if A a A then A ~ B a A -+ B, rather \nthan the reverse. This is the usual problem of the function space constructor being contravariant in \nits first argument. Therefore, we will have to refine the notions of cpo and continuous func\u00adtion in \norder to get a natural and suitable class of type functions. One contribution of this paper is to identify \na set of nice maps on nice pers. We say a function F from nice pers to nice pers is runk-increasing if \nfor all nice per s A, and all j ~ i 1, (F(A))iil = (F(Ahl))[q. In other words, all elements of F(A) \nof rank i are determined by the elements of A of rank i 1. This definition was discovered by examining \nthe fundamental diagram. After we had investigated rank-ordered sets with rank\u00adpreserving functions (defined \nbelow), we learned that this was a subcategory of the category of bounded ul\u00adtrametrics with non-expansive \nmaps, which has sin~i\u00adlar properties. We relate rank properties of functions to the fun\u00addamental diagram \nas follows. Let R ~ D@ x Dm be a nice per. Then for each i, (R[il, Di) is an ob\u00adject of CPER. If F extends \nH then F(R[il, D~) = Di+l) where F(R, Dm) = (R , Din). If, by (Rfi+l] a slight abuse of notation, we \nwrite R = F(R), then (F(R))[il = (lT (R[i_ ,1))[,1, as in the definition of rank\u00ad increasing maps. Although \nthis may be extracted from the fundament\u00adal diagram, we show directly in Section 5 that ev\u00adery rank-increasing \nfunction has a unique fixed point, and the collection of rank-increasing functions has the same abstract \nstructure as an acceptable collection of nice pers. It is shown in Section 7 that the type con\u00adstructors \nfor function space, records, and F-bounded quantification are rank-increasing. This suggests that we \ncould take the collection of type functions to be all rank-increasing functions on an acceptable collection \nof per s, and repeat the construction through higher kinds. The only drawback of this is that certain \ntrivial functions, like the identity map from types to types, only satisfy a weaker rank-preserving property, \nand are not rank-increasing. Since the larger class of rank\u00adpreserving functions are also rank-ordered, \nthe more natural model contains all rank-preserving functions. A mild embarrassment we have about this \nconstruc\u00adtion is that only the rank-increasing subset of the rank-preserving functions have unique fixed \npoints. A mitigating factor is that since all the type con\u00adnective are rank increasing, and the composition \nof rank-increasing functions with rank-preserving ones produces a rank increasing function, the only \nlimita\u00adtion that this yields is that in applying a recursion operator to a type function or functional \nof some or\u00adder, the body of the function must involve at least one type connective or operator (such \nas ~ or F-bounded quantification). While we would like to lift this re\u00adstriction on recursion, the only \nalternative we know of at this point is to work with the smaller class of type functions described in \n[AP90]. However, this would involve dropping even simple bounded quantification, which is a nontrivial \ntrade-off. In the special case that we restrict the language to F3, as opposed to FW, we are able to \nconstruct a model with unrestricted use of recursion by adding identity and projection maps to the rank-increasing \nfunctions. Since F3 is adequate for most practical examples, this is an appealing variant of our construction. \n 4 The CCC of rank-ordered sets In this section we define ra.nlt-ordered sets and show that rank-ordered \nsets with rank-preserving functions form a cartesian closed category (ccc). Since any ac\u00adceptable collection \nof nice pers may be rank-ordered, this gives us an interpretation of higher-order lambda calculus in \nwhich each kind (including the collection of types, collection of type functions, etc. ) is a rank\u00adordered \nset. An important fact is that every rank\u00adincreasing function on a rank-ordered set has a unique fixed \npoint and, moreover, all of the type constructors we have considered turn out to be rank-increasing. \nDefinition 4.1 A set K is rank-ordered if there is a map, (.)[i]: K e K, jor each i ~ O, satisfying the \nfollowing three conditions. 1. For all A G K, (A[q)u] = A[~in(~,~)I. 2. For all A, B G K, we have A[ol \n= B[ol. We write BotIf fO? A[o] . 3. The jinal condition is stated using two de,jinitions. For each \ni, we iet ri[~l = {A[il I A c K}. FrJr A,B E I<, we write A di B if A = BI~l. (This  implies A 6 K[il.) \nThe final condition is that ij {Ai}i<ti is a sequence from K with Az di Ai+l, then there is a unique \nA E K such that for all i, Ai = A[il To show that the set of rank-ordered sets forms a ccc, we must \ndefine products, rnorphisms and expo\u00adnential. We begin with products. Definition 4.2 If K and L are rank-ordered \nsets, we !et KxL={(k,l)lk ~K,l~L}. We rank-order K x L by defining (k, i)~il = (k~q, llq), To show that \nK x L is a rank-ordered set, we must verify the three conditions above. The first and sec\u00adond follow \ntrivially from the fact that K and L are rank-ordered. The third follows easily by choosing U(ki, t,) \nto be (u, ku,h), if {(ki,ii)}i<ti is an in\u00adcreasing chain. The morphisms between rank-ordered sets are \nfunc\u00adtions which are defined smoothly with respect to ap\u00adproximations to terms of restricted ranks. Definition \n4.3 A function F: K ~ L is rank\u00adpreserving if for ali j ~ i, (F(A))[il = (F(A~l))Iq and rank-increasing \nif for all j ~ i 1, (F(A))[il = (F IAUl))Iil. We write [K ~ L] for the collection of rank-preserving \nfunctions and [K &#38; L] for the col\u00ad lection of rank-increasing functions. We rank-order [K+ L] by \ndefining l [il = AA ~ K.(F(A))[il. It is straightforward to verify that the collection of rank-preserving \nfunctions from K to L is a rank\u00adordered set. In addition, since the limit of a sequence of rank-increasing \nfunctions is rank-increasing, the col\u00adlection of rank-increasing functions from K to L is a rank-ordered \nset. Theorem 4.4 The collection of rank-ordered sets, with rank-preserving functions, is a Cartesian \nclosed category. 5 Properties of rank-increasing functions In this section we identify some useful closure \nprop\u00ad erties of rank-increasing functions. In particular, the fixed point of a rank-increasing function \nis ~anli\u00ad increasing, and the composition of a rank-increasing function with a rank-preserving (or increasing) \none is ranli-increasing. For the rest of this section, we assume that K, L, and M are rank-ordered sets. \nTo ease read\u00ad ability, we also write F(A, 1?) rather than Z?((A, B)). Lemma 5.1 Let F: K x L -+ M. Then \nF is rank\u00adpreserving (respectively, rank-increasing) i@ it is rank\u00adpreserving (respectively, rank-increasing) \nin each of its arguments separately. In particular, 1. If F is rank-preserving, then (F(A, B))[ij = \nF(A[i], B)[iI = (F(A, B[i]))[i]  2. If F is ronk-increasing, then  (F(A, B))[i] = F(A[i-ll, B)[i] = \n(F(A, B[i-l]))[i]. The advantage of rank-increasing functions is that each enclo-fuuction has a unique \nfixed point. In addi\u00adtion, the fixed point of a multi-argument function that is rank-increasing in one \nargument retains its rank\u00adrelated properties in other arguments. Theorem 5.2 If F: K x L -K is rank-increasing \nin its first argzment and rank-preserving in its sec\u00adond, then there is a unique function, G: L -+ K \n= @.F(t, S), returning the fixed point of F in its first argument. Moreover, if F is rank-increasing \nin its sec\u00adond argument, then G is rank-increasing. Proof. SIietch: Construct G(S) such that G(S) = F(G(S), \nS) by constructing an approximating chain for G. Define GO(S) = Botzf, and, for i ~ 1, Gi(S) = (F(Gi_l(S), \nS))[il. One can show by induction that Gi(S) ai Gi+l (S), for all i. Let G(S) = Ui Gi (S). Then F(G(S)l \nS) = Ui(F(G(S)l S))[i] = lJi(f ((G(s))[i-1], S))[i] = u, G,(S) = G(S). It is not difficult to show that \nG is unique and rank\u00adpreserving (rank-increasing), if F is rank-preserving (respectively, ranli-increasing) \nin its second argument. Lemma 5.3 Let G:K * L, and F:L -+ M. If at least one of F and G is rank-increasing \nand the other is rank-preserving, then F o G is rank-increasing. 6 Partial equivalence relations over \n11~ In this section we present the fundamental notions involved in the construction of specialized partial \nequivalence relations over Dm models of the untyped lambda, calculus. As in Section 3, we assume that \nDm is constructed as the inverse limit of a continu\u00ad ous functor If: CPOp -+ CPOP. For example, let A \nbe a fixed CPO representing atomic types, L a flat domain corresponding to a set of (labels , and + be \nthe coalesced sum over cpo s. Then a model con\u00ad structed from the functor whose definition on objects \nis H(D) = A + [L -+ D] + [D -+ D] ,results in acpo, Dm, such that D@&#38; A+[L~Dm]+[Dm4Dm]. The following \ndefinition is taken from [Car89]. Definition 6.1 A notion of approximation over a cpo D is a family of \ncontinuous mappings (.)[nl: D a D satisfying the following conditions for all d 6 D: 1. d[ol= 1. ~. \n(~[n])[na]= = (d[m])[n] d[min(m,n)]. 9. d= ui d[i]. 4. Ifa GLUA, then forall O<i<w, a[il=a. 5. lf f \n~ [D ~ D] and n s k, then f[~+ll(d[~l) =  f[n+l](q?l])  6. Iff 6 [D a D] andn ~ k, then (f[k+ll(%d))[nl \n= f[n+ll(d[nl). 7. ~f f c [D --+ D] then fi~+ll(d[~l) = fi~+ll(d) = (f (d[nl))[nl 8. f = f[~+ll if and \nonly iffor all dc D,f(d) = (f(d[n]))[m] Since these properties were extracted from the Dm  model construction. \nThe following proposition should not come as a surprise. Proposition 6.2 There exists a notion of approxima\u00adtion \nover Dm. The following properties will be useful in several technical proofs later on. Proposition 6.3 \nEvery notion of approximation over D satisfies the following: 1. Ifn s m then d[nl c d[ml, where C is \nthe ordering in the cpo D. 2. IfdG[D -+ D] andeeDthen d(e) = u, d[~+lj(e~~j). Recall the definition of \nnice pers and acceptable col\u00adlections from Section 3. We define a notion of rank on nice per s as follows: \nDefinition 6.4 If R is a nice per, let R[nl = {(dIn], e[nl)l(d, e) ~ R} = R n (Dn x Din). (Note R[n] \nis nice.) Write R<. R iff R = R~nl. Note that if R is nice, and R~n R , then (d, e) &#38; R im\u00adplies \n(d[~l, e[,,l) ~ R. Also, note that for all n, Ri~l an R and R[nl an R[n+ll. Proposition 6.5 If 1? is \nan acceptable collection of nice per s then 7? is a rank-ordered set. Proof. Since each R E 1? is nice, \nelements in pairs from R satisfy all of the properties in Definition 6.1. Thus point 1 of the definition \nof rank-ordered sets (Definition 4.1) follows from point 2 of Definition 6.1. Point 2 of ranl<-ordering \nis satisfied by {(1, 1)}. The last point in the definition of rank-ordering is the last condition in \nthe definition of an acceptable collection of per s (Definition 3.3). 7 Models of F. with F-bounded \n.. quant ificat ion In this section we describe models of Fw with F\u00adbounded quantification whose types \nare elements of an acceptable collection of per s, We use the termi\u00adnology of [BMM90]. In particular, \na model involves a set X of kinds, which includes the collection T of all types as well as the product \nK1 x Ii z and function kind lil =+ 1{2 for any 1{1, K2 E K. For the rest of this section, let 7? be a \nfixed, acceptable set of per s. Definition 7.1 The kind structure, K, generated from R is the smallest \ncollection of rank-ordered sets which contains 7? and is c!osed under ~ and x, where these operations \nare as dejined in Section 4. It follows from our previous results that a kind structure is a ccc. As \nin [BMM90], we will use the kind structure over %? to provide the interpretation of types, as well as \nall the higher kinds of a model of Fw with F-bounded quantification. We will interpret the set of all \ntypes as the set 7?. We already know by the definition of an acceptable collection of per s, that 7? \nis closed under our type operators: function space, records, and F-bounded quantification. We must show \nthat the type operators themselves are elements of the appropriate kinds. Before proving this, we give \nprecise definitions of each type operator. In order to define higher-order F-bounclecl quantifica\u00adtion, \nwe order the elements of each kind. For types, the relevant order is the subtype ordering; for type functions, \nwe use the induced pointwise order, as in the following definition. Definition 7.2 Let K be the kind \nstructure gener\u00adated from 7?. If A,B ~ It, dejine A <R B iff A ~ B. Suppose <I< and <L have been defined. \nFor F, G 6 [K ~ L], dejine F <[]{*L] G iflfor all A E K, F(A) <L G(A). For (A, B), (C, D) c [K x L], \ndefine (A, B) <[11.L] (C, D) i.fl A SI~ C and B <~ D. The following lemma is easily provecl by induction \non the construction of kinds. Lemma 7.3 Let K E K wilh A, B GA_. Then We now define the type operators. \nNote that our definition of F-bounded quantification follows the form used in [BL90] for bounded quantification. \nIt cliffers from the definition using a simple intersection which is more commonly used (see [Mitt36] \nfor the more tra\u00additional definition). Our slightly more complex defini\u00adtion is necessary to make the \nfunction rank-increasing. Definition 7.4 1. IfA,Bc7?,let Thus H ~[[K + 1<]X[K + T] 4 T] A+ B = {(dje) \nEDW xD~lforal~(a,b) E A,(d. a,e. b)e B}. 2. lf{l~, . . ..l~}QL and Al. A~~R,tfienlein1ei {il:Al,..., \ni~:A~} = {(d, e) E D~ x D~lfor all li,(d.ii,e.ii)~Ai}.  3. Let K6K. If AcIKti K] and Gs[K~T] then let \nb s <: A(s) .G(s) = {(d, e) E DW x Dml for all a,bE Dm, for all R <A> A(R) such that R E K, (da,eb) E \nG(R)}.  4. If F E[K ~ I<] then let lM.F(s) = the least A E K such that F(A) = A. Note that simple bounded \nquantification can be ob\u00adtained from F-bounded by choosing the type bound to be a constant function. \nThe following theorem shows that our model is closed under the above constructions. Recall that 1<1 4 \n1{2 is the set of rank-increasing functions from I{l to 1<2, which is a subset of the set of rank\u00adpreserving \nfunctions from 1<1 to Kz. Theorem 7.5 Let K be the kind structure generated byK., and let K, L, and M \nEK, Then 1. H(X,Y)= X+ Ye[Tx T&#38;T]. 2. Let {1~, . . ..l~} ~ L. Then H(X1, . .,Xn) =  {l,:x,,..., \nJn:xn}E[T~3 T]. 3. IfA=[K * K] andG6[K * T]then H(A, G) = ds <: A(s).G(s) E [[~< % K] X [~< + T]4 T]. \n 4. IfFc[K xK ~ K], then H(S) =pt.F(t, S )c [K =$K]. Moreover if F ~ [K x K ~ K] is rank-increasing \nin its first argument, then H(S) = @.F(t, S) E [K a K]. Proof. We just include the proofs for the last \ntwo cases in this conference paper. 3. Let H(A, G) = Vs <: A(s). G(s). Show (~(A[i-1], G[;-l]))[i] = \n(~(A, G))[i] Let (~, e) E (~(A[i-11, G[i-II))[iI and R <K A(R). T1lus R[i-1] <K (A(R) )[i-1] = &#38;I](&#38;l]) \nby Lemma 7,3 and the definition of rank-preserving func\u00adtion. As a result, for all a,b ~ D~, (cl a,e \n. b) E G[;-l](R[i-1]) = (G(R[i-l]))[i-1] = (G(R) )[i-1] ~ G(R), since G is rank-preserving. Hence (d, \ne) c (H(A, G))[~]. Let (cl, e) e (H(A, G))[il. Therefore for all a, b s Dm and all R SK A(R), (d .a,e.b) \nE G(R). Let R ~1{ A[i_ll(R) ~~~ A(R) and a, b ~ D~. Therefore (a! a,e b) = ((a!. a)[i_ll, (e ~b)~i-lj) \nc (G(R) )~i-lj = GIi_ll(R). Hence (d, e) c (17(AIi-1], G[i-l]))[i]. 4. Let F(T, S) E [K x K A K]. We \nalready showed in Lemma 5,2 that H(S) = pt.F(t, S) is rank-increasing, and hence is in [1< ~ 1{]. Lemma \n5.2 also gives the result for F rank-increasing in its first argument and rank-preserving in its second. \na Thus we may use the definitions given above of types and functions from types to types in order to \nconstruct a model of the u-order typed lambda calculus, FW, with F-bounded quantification. Theorem 7.6 \nLet K be the kind structure generated by 7Z. If we interpret T, the set of types, as IL, and the higher \nkinds as the appropriate elements of K, then we obtain a mode! for the w-order typed lambda calcu \u00adlUS, \nFu, with subtyping, F-bounded ~~antification, and records. This model has the property that every rank\u00adincreasing \nfunction on any kind has a unique fixed point. The proof combines arguments in [BL90] for subtyp\u00ading \nwith the fixed-point properties of rank-increasing functions developed here, and direct verification \nof conditions for F-bounded quantification. Details are omitted from this conference paper. Returning \nto the example presented in the intro\u00adduction, we illustrate how to define list: T a T such that list(t) \n= { head: unit -+ t tail: unit + list(t) empty?: unit -+ boo! nzap: Vs.(t 4 s) + list(s)} where unit \nrepresents a fixed type with one element and bool is a fixed type with two (non-_L) elements. Define \nF:(T~T)=+T~Tby F(l)(t) = { head: unit -+ t tail: unit ~ l(t) empty?: unit -+ bool map: Vs. (t a s) -+ \nl(s)} Because the record constructor is rank-increasing, F is rank-increasing. Thus F has a least fixecl \npoint, list. Other highe~ -order domain equations are solved similarly. ~ Acceptable collections of per \ns In this section we show that two natural collections of per s are acceptable, thus giving us two models \nof FW with F-bounded quantification. We begin by worliing with CUA, the collection of all nice per s, \nand then work with a restriction of CUA which ensures that the set of elements of any type forms a cpo. \nTheorem 8.1 CUA is an acceptable collection of Theorem 8.5 ACUA is an acceptable collection of per s. \nper s. Proof. We only prove closure under F-bounded quantification in this conference paper. Let K be \nthe kind structure generated from CUA and let K 6K. IfA~[K ~ I{] and Gc[K ~ CUA] then recall Vs <: A(s) \n.G(s) =dej {(d, e) ~ Dm x Dm I for all (ajb) E D@, for all R SK A(R) , (d. a,e b) E G(R)}, %Ve must show \nthat B =&#38;j Vs <: A(s).G(s) E CUA. Clearly, B is a per and (J_, 1) G B. We must show that it is closed \nunder sup s of increasing chains and approximations. Suppose (di) and (ei) are increasing chains in D \nsuch that for alli~w, (di,ei) EB. Let d=Uidi and e = Ui ei We must show (d,e) E B. That is, we must show \nthat for all R SK A(R), and all a, b c D~, that (d . a, e . b) E G(R). We already know that (di.a, e \nb) E G(F) and G(R) ~ CUA. Thus (da,e.b) = (Ui(dz a), u~(e b)) = Ui(di ~a, et ~b) E G(R), where the first \nequality holds since . is continuous. Thus (d, e) EB. The proof of closure under approximations is simi\u00adlar. \n Thus we can use CUA as the basis for our first model of Fu with F-bounded quantification. This model \nis an extension of those in [Ama91] and [Car89]. Our next model is based on a construction in [AP90]. \nLemma 8.2 (A badi-Plotkin] For any appropriately chosen continuous functor H over bifinite cpo s, there \nis an intrinsic preorder, <s, for each nice per, S, over the corresponding limit, DW = H(DW ), such that \n1. <s is the least compiete preorder containing ~ and S. 2. f s,$_T g imp!ieS that for all Z ~ \\Sl, \nf($) <T g(x). (Similarly for x and F-bounded quant.ijica\u00adtion.) 3. a <s b implies that for all i < W, \na[i] <S1ll b[i].  An additional condition is needed to partially order equivalence classes. Definition \n8.3 We say that a per, S, is antisymmet\u00adric iffor aila,y~S, ifz<s y<s xthen (x,y)ES. Define ACUA = {S \nE CUAIS is antisymmetric}. The important fact about ACUA is that the set of equivalence classes of each \nper in ACUA forms a cpo. Let [Sl = {% E Dl(r, x) E S} and Q(S) = {[z]sIz E ISI}. For z,y c ISI, define \n[X]S s [y]s iff z ss y. Antisymmetry ensures that this is well-defined. Theorem 8.4 (A badi-Plotkin) \nIf S e ACUA, then (Q(S), <) is an w-a~gebraic cpo. We can add different conditions to CUA S to get other \nmodels as long as the resulting collection of per s is acceptable. For instance, [AP90], defines the \ncol\u00adlection of good per s to be CUA S which also satisfy meet-closure and convexity conditions. This \nset also forms an acceptable collection of per s. For any such condition, we obtain a model with the \nproperties stated in Theorem 7.6. 9 Summary In this paper, we have described a general tech\u00adnique for \nconstructing per models of FW (higher\u00adorder lambda calculus) that support function spaces, records, and \nhigher-ordered F-bounded polymor\u00adphism, and that also contain solutions to all non\u00adtrivial recursive \ndomain equations. Acceptable col\u00adlections of nice per s, built over a model of Dm, serve as the collection \nof types of the model. Key properties in the definition of acceptable collections of per s are that they \nare closed under the type opera\u00adtions of the model, and they satisfy a closure condition relating to \nsup s of approximation chains of per s. The approximation ordering is derived from the ranks of elements \nin the Dm construction. The closure con\u00addition on approximation chains enables the solution of recursive \ndomain equations. Since the construction is general, different models can be built from different acceptable \ncollections of per s. The first model considered extended that pre\u00adsented (independently) by Amadio [Ama91] \nand Car\u00addone [Car89] by adding functions of higher kinds and allowing F-bounded quantification over elements \nof higher kinds, while still providing solutions to all non\u00adtrivial (higher-order) domain equations. \nThe types in the second model are similar to those in the model of Abadi and Plotkin [AP90], but the \nset of functions from kinds to kinds is larger (we do not restrict to realizable functors) than that \ngiven in their model. A major contribution of the Abadi-Plotkin model is that all types are cpo s, presenting \nthe possi\u00adbility of reasoning by fixed point induction. By keep\u00ading their type structure, but allowing \na larger set, of functions from kinds to kinds, we were able to solve do\u00admain equations involving both \nsimple and F-bounded quantification, something which does not seem to be possible in Abadi and Plotkin \ns original model. A side issue that we have not explored is the connec\u00adtion between an F-bounded type \nVX <: F(X). B(X) and the type VG <: F. B( f ix G) defined using a fixed\u00adpoint operator in place of F-bounded \nquantification. Since both type expressions make sense in our model, provided we interpret (VG <: F as \nquantifying over rank-increasing functions, and both seem to serve the same purpose in practical examples, \nit would be inter\u00ad esting to explore their semantic connections. A clmowledgements: Thanks to Gordon \nPlotkin, Peter Freyd and Martin Abadi for comparative comments and explanation of their related work, \nand to Luca Cardelli and other participants in the 1991 Stanford subtypes seminar. References [Ama91] \nR.M. Amadio. Recursion over realizabil\u00adity structures. Information and Compu\u00adtation, 91(1):55-86, 1991. \n[AMSW91] S. Abramsky, J. Mitchell, A. Scedrov, and P. Wadler. Relators. Manuscript, 1991. [AP90] M Abadi \nand G. Il. Plotkin. A PER model of polymorphism and recursive types. In Proc. IEEE Symp. on Logic in \nComputer Science, pages 355-365, 1990. [Bar84] HP. Barendregt. The Lambda Calcu\u00ad lus: Its Syntax and \nSemantics. North- Holland, Amsterdam, 19S4. Second . edi\u00ad tion. [BL90] K. Bruce and G. Longo. A mod\u00adest \nmodel of records, inheritance and bounded quantification. Information and Computation, 87(1/2):196-240, \n1990. [BMM9,0] K. B. Bruce, A. R. Meyer, and J. C. Mitchell. The semantics of second-order lambda calculus. \nInformation and Com\u00adputation, 85(1):76 134, 1990. Reprinted in Logical Foundations of Functions! Pro\u00adgramming, \ned. G. Huet, Addison-Wesley (1990) 213-273. [BTCGS90] V. Breazu-Tannen, T. Coquand, C.A. Gunter, and \nA. Scedrov. Computing with coercions. In Proc. ACM Conference on Lisp and l%nctional Progranlnling, pages \n44-61, 1990. [BTCGS91] V. Breazu-Tannen, T. Coquand, CA. Gunter, and A. Scedrov. Inheritance as explicit \ncoercion. Information and Com\u00adputation, 93(1):172-221, 1991. [Car88] L. Cardelli. A semantics of multiple \nin\u00adheritance. Information and Computation, 76:138 164, 1988. Special issue devoted to Symp. on Semantics \nof Data Types, Sophia-Antipolis (France), 19S4. 326 [Car89] [Car91] [CCH+89] [CCH91] [CHC90] [CL90] [CM91] \n[CO089] [COP85] [CW85] [FRMS90] [Gir72] F. Ca,rdone. Relational semantics for recursive types and bounded \nquantifica\u00adtion, In ICALP, pages 164-178, Berlin, 1989. Springer LNCS 372. L. Cardelli. Examples of type \nrecursion. Personal communication, 1991. P. Canning, W. Cook, W. Hill, J. Mitch\u00adell, and W. Olthoff. \nF-bounded quantifi\u00adcation for object-oriented programming. In Functional Prog. and Computer Archi\u00adtecture, \npages 273-280, 1989. P, Canning, W. Cook, and W. Hill. Ex\u00adamples of type recursion. Personal com\u00admunication, \n1991. W. Cook, W. Hill, and P. Canning. In\u00adheritance is not subt yping. In Proc. 17th ACM Symp. on Principles \nof Program\u00adming Languages, pages 125 135, January 1990. L. Cardelli and G. Longo. A semantic ba\u00adsis for \nQuest. Technical Report 55, DEC Systems Research Center, 1990. To ap\u00adpear in J. Functional Programnting. \nL. Cardelli and J .C. Mitchell. Operations on records. Math. Structures in Com\u00adputer Science, 1(1):3 \n48, 1991. Summary in Math. Foundations of Prog. Lang. Se\u00admantics, Springer LNCS 442, 1990, pp 22-52. \nW.R. Cook. A proposal for making Eiffel type-safe. In European Conf. on Object-Oriented Programming, \npages 57\u00ad72, 1989. M. COPPO. A completeness theorem for recursively-defined types. In Proc. ICALP, pages \n120 130, Berlin, 1985. Springer LNCS 194. L. Carclelli and P. Wegner. On un\u00adderstanding types, data \nabstraction, and polymorphism. Computing Surveys, 17(4):471 522, 19S5. P. Freycl, G. Rosoliui, P. Mulry, \nand D.S. Scott. Extensional PER s. In Proc. IEEE Symp. on Logic in Computer Science, pages 346-354. IEEE, \n1990.  J.-Y. Girard, Interpretation fonc\u00adtionelle et elimination des coupures de l arithmetique d ordre \nsuperieur. These D Etat, University Paris VII, 1972. [GS90] [HenS9] [KTU89] [LS86] [Mit86] [Mit90a] \n[Mit90b] [Myc84] [SP82] [Tro73] C.A. Gunter and D.S. Scott. Seman\u00adtic domains. In J. van Leeuwen, editor, \nHandbook of Theoretical Computer Sci\u00adence, Volume B, pages 633 674. North- Holland, Amsterdam, 1990. \nF. Henglein. Polymorphic Type Inference and Semi-Unification. PhD thesis, Rut\u00adgers University, April \n1989. also NYU Technical Report 443, May 1989. A. Kfoury, J. Tiuryn, and P. Urzy\u00adczyn. Computational \nconsequences and partial solutions of a generalized unifica\u00adtion problem. In Proc. IEEE Symp. on Logic \nin Computer Science, June 1989. J. Lambek and P.J. Scott. Introduc\u00ad tion to Higher-Order Categorical \nLogic. Cambridge University Press, Cambridge, U.K, 1986. J .C. Mitchell. A type-inference approach to \nreduction properties and semantics of polymorphic expressions. In ACM Con\u00adference on LISP and Funciioncd \nPro\u00adgramming, pages 308-319, August 1986. Revised version in Logical Foundations of Functional Programming, \ned. G. Huet, Addison-Wesley (1990) 195-212. J .C. Mitchell. Toward a typed founda\u00adtion for method specialization \nand inher\u00aditance. h~ Proc. 17th ACM Symp. on Principles of Programming Languages, pages 109-124, January \n1990.  .J.C. Mitchell. Type systems for pro\u00adgramming languages. In J. van Leeuwen, editor, Handbook \nof Theoretical Com\u00adputer Science, Volume B, pages 365-458. North-Holland, Amsterdam, 1990. A. Mycroft. \nPolymorphic type schemes and recursive definitions. In Proc. 6ih Int. Conf. on Programming, LNCS 167, \n1984. M. Smyth and G.D. Plotkin. The category-theoretic solution of recursive domain equations. SIAM \nJ. Computing, 11:761-783, 1982. A.S, Troektra. MatLemaiicai Investi\u00adgation of Intuitionisiic Arithmetic \nand Analysis. Springer LNM 344, Berlin, 1973.  \n\t\t\t", "proc_id": "143165", "abstract": "", "authors": [{"name": "Kim Bruce", "author_profile_id": "81100168232", "affiliation": "", "person_id": "P161589", "email_address": "", "orcid_id": ""}, {"name": "John C. Mitchell", "author_profile_id": "81338490160", "affiliation": "", "person_id": "PP43125642", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143230", "year": "1992", "article_id": "143230", "conference": "POPL", "title": "PER models of subtyping, recursive types and higher-order polymorphism", "url": "http://dl.acm.org/citation.cfm?id=143230"}