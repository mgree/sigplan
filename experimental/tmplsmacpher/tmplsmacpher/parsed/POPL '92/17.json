{"article_publication_date": "02-01-1992", "fulltext": "\n Type isomorphisms in a type-assigment framework From library searches using types to the completion \nof the ML type checker Roberto Di Cosmo LIENS (CNRS) -DMI Ecole Normale Sup&#38;ieure 45, Rue d Ulm 75005 \nParis -France E-mail: dicosmo@dmi.ens.fr Dipartimento di Informatica Corso Italia, 40 56100 Piss -Italy \nE-mail: dicosmo@dipisa. DI.UNIPI.IT  Abstract This paper contains a full treatment of isomorphic types \nfor languages equipped with an ML style poly\u00admorphic type inference mechanism. Surprisingly enough, the \nresults obtained contradict the common\u00adplace feeling that (the core of) ML is a subset of sec\u00adond order \nA-calculus: we can provide an isomorphism of types that holds in the core ML language, but not in second \norder ~-calculus. This new isomorphism not only allows to provide a complete (and decidable) ax\u00adiomatisation \nof all the types isomorphic in ML style languages, a relevant issue for the type as specifica\u00ad tions \nparadigm in library searches, but also suggest a natural extension that in a sense completes the type\u00adinference \nmechanism in ML. This extension is easy to implement and allows to get a further insight in the nature \nof the let polymorphic construct. Introduction The interest in building models satisfying specific iso\u00admorphisms \nof types (or domain equations) is a very long standing one, as it is a crucial problem in the de\u00adnotational \nsemantics of programming languages. Since 1984, though, some interest started to develop around the dual \nproblem of finding the domain equations (type isomorphisrns) that must hold in every model of a given \nlanguage, or valid isomorphisms of types, as we will call them in the sequel. The seminal paper Permission \nto copy without fee afl or part of this material is granted provided that the copies are not made or \ndistributed for direct commercial advantage, the ACM copyright notice and the title of the publication \nand its date appear, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy other\u00adwise, or to republish, requires a fee and/or specific permission. by Bruce and \nLongo ([BL85]) addressed then the case of pure first and second order typed ~-calculus with essentially \nmodel-theoretic motivations, but due to the connections between typed A-calculus, Cartesian Closed Categories, \nProof Theory and Functional Pro\u00ad gramming, the notion of valid isomorphism of types showed up as a central \nidea that translates easily in each of those different but related settings. In the framework of Category \nTheory, Soloviev already stud\u00adied the problem of characterizing types (objects) that are isomorphic in \nevery cartesian closed category, pro\u00adviding a model theoretic proof of completeness for the theory Th~~ \nwe will see later on [S0183]. A treat\u00adment of this same problem by means of purely syn\u00adtactic methods \nfor a A-calculus extended with Subjec\u00adtive Pairing and unit type was developed in [BDCL90], where the \nrelations between these settings and Proof Theory, originally suggested by Mints, have been stud\u00adied, \nand pursued further on in [D CL89], where a new model of typed A-calculus is also proposed. Finally, \n[DC91] provides a complete characterization of valid isomorphisms of types for second order A-calculus \nwith Subjective Pairing and unit type, that includes all the previously studied systems. Meanwhile, these \nresults were starting to find their applications in the area of Functional Programming, where the problem \nof retrieving functions in a library was showing up as an increasingly relevant issue: while the size \nof the function libraries grows steadily (the standard library of CAML v.2.6 contains already more than \n1000 user-level identifiers, for example), the tools generally available today to retrieve functions \nstored in a library are still nothing more than a prehistorical alphabetical index of identifiers, maybe \nwith some fa\u00adcility to enable regular-expression searches (like in the CAML interpreter, see [CH88]), \nor some kind of the\u00adsaurus, useful when you have to find your way in an @ 1992 ACM 089791-453-8/92/000110200 \n$1.50 Language Name Type ML of Edinburgh LCF itlist VX.VY.(X + Y + Y) + List(x) + Y + Y ?1 CAML list \nit Haskell foldl VX.VY.(X + Y + x) + x + List(Y) + x SML of New ;Jersey fold VX.VY.(X x Y + Y) + List(x) \n-+ Y + Y The Edinburgh SML Library foldleft VX.VY.(X x Y ~ Y) + Y ~ l,zst(X) + Y Table 1: an example \nUNIX manual (the well known -k option of the man command). But the name given to a function is left to \nthe more or less origimd imagination of the programmer, so if you change system, you change dialect also: \nborrow\u00ading an amusing example from [Rlt90b], if we look for a function that distributes a binary operation \non a list, we can easily collect a nice amount of names: ztlist, list. it, foldl, fold and fold-left, \nso that the rudimen\u00ad tary tools available to search the libraries dent help at all. If we are using strongly \ntyped functional lan\u00ad guages, though, the Proofs as Types paradigm just tells us that a type can be \nconsidered as a (partial) logical specification of a program, suggesting to use the type of a function \nas a search key in order to pro\u00advide the programmer with a uniform and sensible tool to retrieve data \nin libraries. The types, with their logi\u00adcal counterpart, would provide the necessary standard language. \nThis simple, but rather new idea is the starting point of work done by Mikael. Rlttri ([Rlt89], [Rlt90a]), \nCoJin Runciman and Ian Toyn ([RT89]) in this di\u00adrection. They immediately notice how functions that we \nwant to consider essentiidly the same turn out to be assigned pretty different types. Borrowing from \n[Rit90b], we can provide an example of this unpleas\u00adant phenomenon, just by looking at the type that \nthe Mist -list-it -foldl -fold -foldSefl function is assigned in five different widely used languages \nbased on the same polymorphic type discipline originally presented in Milner s ML [Mi178] (see Table \n1). The syntactic equality of types is too much a fine relation on types to be used for our purposes: \nso what is the right way to compare types? We need a coarser relation on types that take into account, \nfor exam\u00adple, currying-uncurrying and argument permutation. Moreover, this notion of equivalence ought \nnot depend on the particular implementation of the language, and it needs to be decidable in order to \nbe of any u~e. We can clearly see the connection with the no\u00adtion of type isomorphism described above: \nfor any typed functional language L, the equivalence relation on types will be exaclty the one given \nby the notion of valid isomorphism. Definition 1.1 (Valid isomorphisms) A ~ B as a valid isomorphism \nu for any M model of L, M~Az B,z. e, 3f:A_+B, g: B4As.t. go f= idA, fOg=idB. What is needed then is \nthe ability to search types up to such isomorphismls, i.e. a complete and decid\u00adable characterization \nof the valid isomorphisrns. The completeness of the theory is obviously essential, as a sound theory \nthat is incomplete would miss part of the functions in the library. In this paper, we survey the known \nresults on valid isomorphisms of types (Section 2) and we point out why they are not adequi~te to handle \nlanguages where the let polymorphic construct is allowed. We study thereafter in Section 3 the problem \nof valid isomor\u00adphisms in the pr-esence of such a polymorphic con\u00adstruct, and we provide a, complete \nand decidable char\u00adacterization for it in Section 4. This characterization uncovers a new and much unexpected \nisomorphism that does not hold for second order typed A-calculus. It can be used to extend the usual \nML type-inference algorithm, as proposed in Section 5. Finally, in Sec\u00adtion 6 we summarize the key contributions \nof this pa\u00adper and some open issues arising from this work. 2 Survey In this section we survey the known \nresults about the vaHd isomorphisms of types for first and second order A-calculi, and we build up the \nnecessary machinery to handle vdld isornorphisms in type-assignment systems with the let constructor. \nFor the full syntax of the typed calculi referred below, see [CDC91]. 2.1 First order isomorphic types \nIn [BL85], Bruce and Longo showed that two types A and B are isomorphic in every model of the simple \n 1. AxB=Bx A 2. Ax(Bx C)=(AXB)XC 3. (Ax B)+ C= A+(B+C) 4. A-+( BxC)=(A+B)X(A+C) 5. AxT=A 6. A-+T=T \n 7. T+A=A 8. VX.VY.A = VY.VX.A  9. QX.A = VY.A[Y/X] (X free for Yin A, Y not free in A) Th2 10. VX.(A \n* B) = A + v X.B (X not free in A) /  11. VX.A XB = VX.A XVX.B 12. VX.T =T  A, B, C can be arbitrary \ntypes and T is a constant for the unit type. Notice that the axiom (swap) of Thl is provable in l h~T \nby axioms 1 and 3. Table 2: The theories of valid isomorphisms typed A-calculus Al ~q if and only if \nthey can be shown equal in the equational theory Thl that has only the following proper axiom (swap) \nA+(B+C)=B+(A+C) where A, B, C can be arbitrary types. A key point in the proof of completeness is the \nfact, very easy to show, that valid isomorphisms are always definable by programs in the language, i.e. \nProposition 2.1 (Definable isomorphisms) A z B ~ there exist A-terms M :A -B and N :B h A such that ~1/3q \nt-it40N = IB and A1~q 1-NoM = 1A, where IA and IB aTe the identities of type A and B, and MoN is the \nusual composition of terms Ax. M(Nz). This result holds for any of the languages we will survey in this \nsection (see [DC91] for details), so we will talk indifferently about valid or definable isomor\u00adphisms, \nor just about isomorphisms. Remark 2.2 Notice that we are in an explicitly typed framework, so the isomorphism \nbetween type A and B is given by explicitly typed terms M : A ~ B and N :B -i A. Later on, this approach \nwas extended to the lambda calculus with subjective pairing and terminzd object (A1~7VT*), i.e. the \ninternal language of Cartesian Closed Categories. In [S0183] this problem is solved by model theoretic \nmethods that can essentially be traced down to work done in number theory by Mar\u00adtin ([Mar72]), while \na completely new proof based on proof theoretic methods was provided by Bruce, Longo and the author (see \n[BDCL90]). The notion of iso\u00admorphism between types presented there is exactly the same adopted by Rittri \nin the case of ML-style languages, to the study of which he devotes the two papers [Rit89] and [Rlt90a]. \nThe resulting fundamental theorem in [S0183] and [BDCL90] states that two types A and B are isomor\u00adphic \nin every model of the calculus Al ~rpr+ if and only if they can be shown equal in the equational theory \nThjT of Table 2. 2,2 Second order isomorphic types These results can be extended to second order typed \nA-calculus, as in [BL85], where Bruce and Longo char\u00ad acterized the valid isomorphism for the pure second \norder A-calculus A2,bq via the equational theory Th2 of Table 2. This result is not powerful enough, \nthough, to treat ML-style systems, as we miss the product and the unit type constructors, so we need \nto look at [D C91], where a finite, decidable axiomatisation of the isomorphisms holding in the models \nof second order lambda calculus with subjective pairing and t ermimd object A2~rprx is provided. The \nMain Theorem of that paper shows that two types A and B can be constructively proved to be isomorphic, \nby programs which act one as the inverse of the other, if and only if !l h~~ f A = B, where Th~T is the \nset of axioms in Table 2. This last theory of vaHd isomorphisms contains all the previous theories and \nis as far as we can go by now.  3 Isomorphisms of types in ML-style languages In [Rlt89] and [Rlt90a], \nRittri uses the theory Th~T to develop a library search system for strongly typed functional languages \nin the ML family. Languages of the ML family are equipped with the so-called implicit type polymorphism \n, a brand of type poly\u00admorphism that essentially allows to give the user the safety of a strongly typed \nworld without the burden of mandatory type declarations: the user writes type\u00adfree programs and the compiler \ninfers a type for it by filling in all the type information. The inference problem is easily decidable \nin the case of monomorphic languages, like the simpIy typed A\u00adcalculus, (see [Hin69], [Mi178]), while \nwe do not know how to deal with it for calculi with the full power of second order quantification over \ntypes, Iike second or\u00adder typed A-calculus. It is a common idea (but we will shortly see how it is not \na very correct one) that ML-style languages lie somewhere in between these two extremes, as any user-defined \nfunction is give:n a type that can be more than monomorphic, but not fully second order poly\u00admorphic. \nThese types are either monomorphic types (known as monotypes) (denoted by ~ below) or the so-called type-schemas \n(denoted by a below): Definition 3.1 ML types are the closed types gener\u00adated by the following grammar \n(At is a collection of atomic types) type-schemas u ::= r I VX.a (if X is free in ~) monotypes T ::= \nAtl X [r~~17X~ Type schemas are essentially types where every type variable is bound by a quantifier \nthat can appear only as an outermost constructor of the type (and not inside 4, x or other type constructors). \nIf we follow the common intuition that ML is some\u00adwhere in between simple typed A-calculus and second \norder A-calculus, it is easy to conjecture that the valid isomorphisms of type-schemas are axiomatized \nby a theory Th ML that includes Th\\T and is included in Th:T. Then, noticing that Axioms 10, 11 and 12 \ninvolve second order types that are not type-schemas, it seems reasonable that Th~L be just Th<T less \nthese three axioms. So the naive ~pproach to deci<lng equality of type-schemas al = VX.71 and U2 = VY.r2 \n, would be to check if there is a way of substituting in some order the variables ~ with ~ in 1-1 such \nthat for the result\u00ading type Tj the theory Th\\T proves r; = T2. We say naive, because in principle the \nrestriction of Th~T to ML types is not necessarily axiomatised by the restric\u00adtion to ML types of the \naxiomatic presentation Th~~ we have chosen for this equality relation. Even worse, the techniques used \nto show completeness for Th~~ on second order types rely in an essential way on the fact that the language \nconsidered there is explicitly typed, while ML-style languages are type assignment systems equipped with \na let construct whose typing rules have no immediate counterpart in the explicitly typed calculi. So \nwe could expect to find some isomor\u00adphism that is not axiomatised even in the full theory Th;T. Rlttri \ns system (see [Rit89]), based on the well known soundness of 5! h~T for monomorphic lan\u00adguages, implements \nthe lprocedure sketched above, and is sound for isomorphisms in ML, but to handle the completeness problem \nin ML we have to face the prob\u00adlem of valid type-schelma isomorphisms in its own right. It turns out \nthat we are in for some surprises, here, but first of all, let s set up the right formalism for type-assignment \nsystems. 3.1 A formal setting for valid isomor\u00ad phisms in ML-like languages Let s first briefly recall \nthe basic typing rules for ML\u00ad like languages: Definition 3.2 (Type assignment ) We write II-M : A if \nM can be assigned type A in the type assignment system given in Table 3. Remark 3.3 Notice that the (LET) \nrule gets priority on the ordinay (APP) rule: we do not introduce here the usual syntactic sugar let \nx = e in e for (Ax.e)e . In this type-assignment framework, the Defini\u00adtion 1.1 used to introduce the \nnotion of valid isomor\u00adphism is no longer appropriate: the programs we work with are assigned not only \none, but several types, and we must take this fact into account. We proceed as follows. Definition 3.4 \nWe say that A and B are isomorphic w.r. t. the context 1? (II-A !% B) via M, M-l iff vp,r~p : A + r~(fwq \n: B and I I-M-l(MP) = P: A (VAR) H-z: A[r~/X;] if z:A = VX, . . . Xn.r is in I and the ri are monotypes \nr,z:A1-iw:B H-M:A-B 17i-N:A (ABS) (APP) H-kc.lf : A ~ B r+(iwiv) : B I I-M :Al II-N :A2 I I-M :Al XA2 \n(PROJ) (-PAIR) r~ < M, N >: Al xA2 ll-piM : Ai 11-N:A r,x:VX1... XrAlAM:B:B (LET) where {X,... X } is \nFV(A) -FV(17) I E(>x.M)N : B Table 3: Type inference rules for an ML-like functional language. VQ, I+Q \n: B s ll-(M-lQ) : A s.t. II-N : VX.A x B, we can derive, using as a and I t-M(M-lQ) = Q : B key tool \nthe let polymorphic type inference rule, that I t-(kc. < PIX, P2X >)N : VX.VY.A x (B[Y/X]). Fur-We say \nthat A and B are isomorphic (A ~ B) via thermore, it is clear that (Az.z)((XZ. < pl~, pzx >)N) M, M-l \nifl VI ,1 t-A z B via M, M-l. can be assigned type VX.A x B. The It is an easy consequence of this definition \nthe fact other direction of the isomorphism is obvious, since that M and M l are invertible, that is \nto say, MoM-l VX.A x B is an instance of VX.VY.A x (13[Y/X]). 0 = Ax.x and vice-versa, so it is not \nnecessary to require this property explicitly. Well, if you really don t believe it, just run your fa- \nNow we can easily verify that Axiom 12 is in a sense vorite typed functional language and try the followingstill \nvalid. example (syntax of CAML): Remark 3.5 Let A be VX.OJ where u as isomorphic Example 3.7 to T via \nM, M l. Then it is easy to check that CAML (sdps) (V 2-6.1) by INRIA Fri Nov 24 1989 ill, M-l provide \nan ML-isomorphism between YX.O and T also. #let join = let pair x = (x,x) inlet id x=x in pair id; ; \nSo we must already add to our tentative definition Value join = (<fun> , <fun>) : (( a -> a) * ( a -> \na))of the Th~L theory the following new Axiom (unit), that is essentially Axiom 12 of Th~T restricted \nto ML #let f = join in (fst f, snd f);; (<fun> , <fun>) : ((Ja -> a) * ( b -> b)) types. This fact supports \nour original idea that ThML u is more than just Th~T less Axioms 10, 11 and 12. Remark 3.8 The isomorphism \n(split) is not deriv\u00ad (unit ) VX.A = T if A is isomorphic to T able in Th~T. But the real surprise is \nthat we also get a new isomor-Indeed, (split) allows to change the number of free phism, not derivable \nin Th~T, that comes out of the type variables even in types that are not isomorphic peculiar typing rule \nused to obtain the traditional let to the unit type T, while all the axioms in Th~T pre\u00ad polymorphism \nin ML-style languages. serve that number for such types. This fact is partic\u00ad ularly unexpected, as it \nshows that type-assignment Proposition 3.6 In ML-1ike languages, the following systems allow to prove \nconstructively equivalent some isomorphism hold proofs that are not so in the second order logic cor\u00ad(split) \nVX.A x B ~ VX.VY.A x (B[Y/X]) responding to the second order A-calculus (for a dis\u00adcussion of the notion \nof constructive equivalence, and Proof. It suffices to provide M and M-l s.t. its connections with the \nisomorphisms of types, see Vr, H-A ~ B via M, M l. [DCL89]). So the original commonplace idea that ML \nLet M be Ax. < plx, p2x > and M-l be Ax.x. is just a limited version of second order A-calculus is Since \nthese are closed terms, the context 17 poses now deeply shaken: in (core) ML we cannot do every\u00adno problem \nand it is easy to check that, given N thing we can do in explicitly polymorphic calculi, as it is well \nknown, but it is also surprisingly true that we can do in (core) ML something that cannot be done in \nsecond order J-calculus.  4 Completeness and conserva\u00adtivity results Are there any more unexpected isomorphisms \ncoming out of the let construct? What about the Axioms 10 and 11 of Th~T we were forced to leave out? \nDo they induce some derived isomorphisms on ML types? These are the questions we address in the present \nSec\u00adtion. 4.1 Completeness By adapting to the type assignment framework the techniques introduced in \n[13DCL90] and [DC91], we can prove the following fundamental result. Theorem 4.1 The theory Th~T less \nAxioms 10, 11 and 12 plus (unit) and (split) is complete for ML isomorphisms. Proof. See Appendix. 0 \n This result gives us the safe definition of the theory Th~L of type isomorphisms for (core) ML: Definition \n4.2 ThML is the theory of equality de\u00adfined by Th<T less Axioms .10, 11 and 12 plus (unit) and (split \n). 4.2 Conservativity As for the relation between Th~T and ThML, a careful analysis of the invertible \nterms in A2,BTTX allows to show that (split ) and (unit) give us back the jui~ power of Th~T on ML types. \nProposition 4.3 Let A and B be ML types. If Th~T proves A = B, then ThML proves A = B too. Proof. See \nAppendix. l Since (split ) is not derivable in Th{T (Remark 3.8), the theory ThML is strictly more powerful \non ML types, so the previous proposition actually states that ThML is an extension of Th~T on ML types, \nand not the reverse. 4.3 Deciding ML isomorphism The proof of completeness allows to derive an easy \nde\u00ad cision algorithm for valid isomorphisms of ML types based on a variant of the narrowing technique. \nEv\u00ad ery type A is rewritten to a (unique) type normal form n. f.(A) via a strongly normalizing confluent \ntype lThe ~y~tem + is a sub-system of the one used in PC91], see Proposition 3.5 there. rewriting system \nderived from the axioms of ThML. Definition 4.4 (Type rewriting R) Let ~ be the tran\u00ad sitive and substitutive \ntype-reduction relation gener\u00ad ated by: Ax(Bx C) O(AXB)XC Tx A-A (Ax B)+ C+ A+(B+C) A+ T-T A+(Bx C)+(A+B)X(A+C) \nT~AQA AxTti A VX.T -T. Remark 4.5 A type normal form n. f.(A) of a type A is just a type VXI ...Xn.(A1 \nX ... x An), where no product or unit type appear in the A~. We call the Ai the coordinates of A. It \ncan be shown that ThML proves A = B iff n. f.(A) is proven equal to n. f.(B) via (split), associativity \nand commutativity of product, bound variable renaming, quantifier swap and the derived Axiom (swap). \nTo decide this last equality, we can use (split) to rename all the bound variables in such a way that \nin the normal forms the Ai share no common type variable. We will call split-normal-form a type normal \nform with this property. Using again the analysis of the structure of the terms that witness the isomorphism \nused in the proof of Theorem 4.1, it is then easily shown that ThML proves A = B iff the coordinates \nof the split-n.f. of A and B are in the same number and for a permutation a each Ai is equal to some \nBC(i) via variable renaming, and (swap). Since unification up to (swap), which is the left\u00ad commutativity \nof + , is decidable (see [Kir85] ), this last problem is easily sc~lved by looking for a variable renaming \nunifier that does not identifies variables orig\u00adinally distinguished inside split-n.f. (A) or split-n.f. \n(B). A detailed account of the decision procedure will be given in [DC92].  5 Understanding ML polymor\u00ad \nphism: completing the type  checker Actually, there is something special in (split) w.r.t. the other \nisomorphisms: the terms that witness this isomorphism are essentially the identity. The invert\u00ad ible \nterms associated to all the other isomorphisms perform a coding that is simple, but does something to \nthe term, while this is not so in the case of Ax.x and Ax. < plx, pzx ~. Indeed, the only interesting \neffect of the term kc. < PIX} P2x > is to allow tile use of tile let polymorphism necessary to change \nthe type of the original term. This fact suggests that (split) has more to do with the type-checking \nalgorithm than with the notion of cod\u00ading we found at the basis of the equivalences needed in library \nsearches performed on the basis of the type seen as a search key. Now, it is doubtful if the iso\u00admorphisms \nin Th~T ought to be made part of the type-inference algorithm of an ML-style language es\u00adsentially for \ntwo reasons: Correctness: the witnesses of the isomorphisms in Th\\T do change the original program, so \nthat the intended meaning of the program is not neces\u00adsarily preserved when the program type-checks up \nto isomorphisms, but not in the original system. An easy example is the interaction of the com\u00admutativity \nof product on equal types with func\u00adtions that are not commutative, like subtraction on numbers. There \nare ways to recover this case (essentially by ruling out commutativity), but the matter is not clear \nenough to suggest such a mod\u00adification right now. . Complexity: unification up to Th~~ is not known to \nbe decidable (see [NPS89] for recent re\u00adsults), and even equality up to ThML is at least as hard as Graph \nIsomorphism (see [DC91] and [Bas90] for details), so such a modification of the ML type-checker is not \nclearly feasible. But these problems are not there if we consider (split) alone: for correctness, there \nis nothing to prove, as there is no transformation of programs, so the intended meaning is surely preserved. \nWe simply type check more programs, and we will see in a mo\u00adment that the new program we allow to type-check \nshould already type-check. As for complexity, we will propose below a straightforward modification of \nthe type-inference rules that includes (split) at a very reasonable cost. It is time for a working example: \nlet s see the same program in ML that type checks only if written the right way , while wit h (split) \nit would type-check in any case. Since it seemingly cracks the ML type checker, we will call the following \nprogram crack. Example 5.1 CAML (mips) (V 2-6.1) by INRIA Fri Nov 24 1989 #let join = let pair x = (x,x) \ninlet idx=z in pair id; ; Value join = (< fun>, <fun>) : (oa->~a)*(>a->Ja)) #let split = let f x =x in \n(f, f);; Value split = (< fun>, <fun>) : ((~a->~a)* (> b->> b)) #let crack f x y = ((fst f) x, (snd \nf) y);; Value crack = <fun> : (( a-> b)*( c-> d)-> a-> c-> b* d) (* crack on split and different types \n*) #crack split 3 true; ; (3, true) : (num * bool) (* crack on join and diffsrent types *) #crack \njoin 3 true; ; line 1: ill-typed phrase, the constant true of type bool cannot be used uith type instance \nnum in crack join 3 true 1 error in typechecking Typecheck Failed 0 Both functions, join and split, \ndefine a pair of iden\u00ad tity functions, but only the split version survives the test of the context crack \n_ 3 true! We can try to understand better what is going on by getting rid of the let construct via the \nusual translation let x=e in e + (Axe) e . j o in translates to (Apair.(~f.pairf )( Xr.z))(Xz. <x, z>) \n o split translates to (Aj. < ~, ~ >)(kc.z) Now it is easy to see what is going on: join and split translate \nto two terms that are not syntactically equal, but only up to the usual ~ conversion. Actually, join \n,B-reduces to split. Now, let s recall the key idea in let polymorphism: the polymorphic rule allows \nto give a type to an appli\u00adcation if this application is typable in the monomor\u00adphic system afier one \nstep of evaluation. That is to say, to type (Ax.M)N, we change the type-inference al\u00adgorithm, that would \ntry to give a type to (Ax.M) and N separately, and only if it succeeds it tries to type their application. \nInstead, we look forward just one step of reduction, that is to say, we try to give a type to M[N/x]: \nif we succeed, that will be the type the original expression (Ax.M)N will be given. well, crack split \n3 true is two steps from crack join 3 true, so the original form of polymorphic type inference cannot \nget it! Adding (split ) corre\u00adsponds in a sense to moving forward more than one step in the type-inference \nprocess. Remark 5.2 Of course there are lots of terms that are typable in the monomorphic discipline \nonly after some steps of reductions, but the examples that are usually given typically involve a non \ntypable subterm. that is erased during these steps of reduction. For ex\u00adample, (~x.~y.y)fl, where ~ is \na diverging term, as of course not typable, while its reduct Ay. y trivially has a, type. It is important \nto notice that this is not the case of split and join, as no interesting sub term is erased during the \ntwo steps of reductions that separate them. So adding (split) to the type-checker is not just one of \nthe various possible extensions of ML that can be suggested, but in a sense is a necessary completion \nof a language that allows, as it is now, one way of defining a pair of identity functions, while forbidding \nanother that seems as perfectly correct. (split - let) r~Jv:AX~ r,z:vxl... xnyl . .. Ym.A rt-(kkfpv: \nX (BIYI c . .. Yin/Xi. . .. Xin])l_M : C x i, . . . Xim are The set {Xl... X.} is FV(A x the type variables \namong these and Y1 . . . Y~ are fresh type B) FV(I ), that are shared variables. by A and B, Table 4: \nThe rule (split-let). 5.1 A modified t,ype inference al\u00ad gorithm featuring split polymor\u00ad phism. We \ncan easily modify the polymorphic type infer\u00adence algorithm to accommodate (split) in the type\u00adinference \nphase: it is just a matter of taking into ac\u00adcount the renaming of type variables allowed by this axiom \nin the polymorphic t!~pe inference rule. So it is enough to add to the original ML type-inference algo\u00adrithm \nthe rule split-let of Table 4, with priority on the original let one. This type checking algorithm assigns \nto join the same type as split, thus preventing the type error we saw in Example 5.1 above. Adapting \nan existing type-checker to accommodate this further rule is rather easy: the necessity of check\u00ading \nfor shared type variables in product types requires some care in the actual implementation, but there \nis no need for new, complex unification procedures. Conclusions As the discovery of the new isomorphism \n(split) stresses, it is not possible to consider ML-style lan\u00adguages as a particular case of the explicitly \ntyped lan\u00adguages: this paper provides, as far a we know, the first explicit treatment of isomorphic types \nin the frame\u00adwork of type-assignment systems. The main contributions of this work are the char\u00adacterization \nof the class of isomorphic types and the extension of the ML type checker. The first result pro\u00advides \nthe necessary theoretical basis for the design of tools to perform library searches using the type of \na function as a search key. Previous work on the subject originally motivated this research, and finds \nhere its natural completion. The extension to the ML type checker derived from the (split ) isomorphism \nrises on the contrary some new issues. The traditional way of typing let expres\u00adsions corresponds to \ntyping programs that will be ty\u00adpable without let after one step of reduction. The new rule to capture \n(split) seems to correspond to moving forward two steps in the reduction: we believe that the necessity \nof moving two step forward is related in an essential way to the non linearity of the Subjective Pairing \nrule, that is the counterpart of q-equality in the theory of ML with products. It is probably for this \nreason that the ML type checker, originally born without tuple constructors, failed to incorporate e \na rule similar to (split) from the beginning. This is why, as suggested in the title of the paper, the \nnew rule (split\u00adlet) is to be seen more as a completion of the original type inference system than as \nan extension to it. We believe that it is necessary to understand more thoroughly than we do now the \nreal nature of ML poly\u00admorphism, especially in the presence of type construc\u00adtors different from the \narrow: the case of the product we treated here tells us that we can be in for some more surprises. This \ninvestigation will be the argu\u00adment of forthcoming work. Acknowledgements I m greatly endebted to my \nadvisor, Giuseppe Longo, for his continuous encouragement, discussions and in\u00adsights: he strongly motivated \nme to carry on all the work that supports the results presented in this paper. I wish to thank Hubert \nComon and Jean-Pierre Jouannaud, as well as all the working group of the LRI at the University of Orsay, \nfor several invaluable discussions: they helped and pushed me in the essen\u00adtial phases of the development \nof this work. I am grateful to Pierre-Louis Curien for the long and fruitful cooperation on the study \nof A2/3rpr*. Thanks finally to Pierre Cregut and Delia Kesner for several afternoons spent discussing \nall these matters. References [Bar84] Henk Barendregt. The Lambda Calculus; Its syntax and Semantics \n(revised edition). North Holland, 1984. [Bas90] David Basin. Equality of Terms Containing Associative-Commutative \nFunctions and Com\u00admutative Binding Operators is Isomorphism Complete in 10th Int. Conf. on Automated \nDe\u00ad[BDCL90] [BL85] [CDC91] [CH88] [DC91] [DC92] [DCL89] [Dez76] [Hin69] [HS80] [Jay91] [Kir85] [Mar72] \n[Mi178] duction. Lecture Notes in Computer Science, 449, July 1990. Kim Bruce, Roberto Di Cosmo, and \nGiuseppe Longo. Provable isomorphisms of types. Tech\u00adnical Report 90-14, LIENS -Ecole Normale Sup&#38;ieure, \n1990. To appear in Proc. of Sympo\u00adsium on Symbolic Comput at ion, ETH, Zurich, March 1990: MSCS. Kim \nBruce and Giuseppe Longo. Provable iso\u00admorphisms and domain equations in models of typed languages. ACM \nSymposium on Theory of Computing (STOC 85), May 1985. Pierre-Louis Curien and Roberto Di Cosmo. A confluent \nreduction system for the J-calculus with subjective pairing and terminal object. In Leach, Monien, and \nArtalejo, editors, ICALP, pages 291-302, Springer-Verlag, 1991. Guy Cousineau and Gerard Huet. The CAML \nprimer. Technical Report, LIENS -Ecole Nor\u00ad male Sup&#38;ieure, 1988. Roberto Di Cosmo. Invertibility \nof terms and valid isomorphisms. A proof theoretic study on second order A-calculus with subjective pairing \nand terminal object. Technical Report 91-10, LIENS -Ecole Normale Sup6rieure, 1991. Roberto Di Cosmo. \nDeciding Type iso\u00admorphisms in a type assignment framework. Technical Report, LIENS -Ecole Normale Sup6rieure, \n1992. To appear. Roberto Di Cosmo and Giuseppe Longo. Con\u00adstructively equivalent propositions and isomor\u00adphisms \nof objects (or terms as natural trans\u00adformations). Workshop on Logic for Computer Science -MSRI, Berkeley, \nNovember 1989. Mariangiola Dezani-Ciancaglini. Characteriza\u00adtion of normal forms possessing an inverse \nin the Apq calculus. Theoretical Computer Sci\u00adence, 2:323 .337, 1976. R. Hindley. The principal type-scheme \nof a an object in combinatory logic. Transactions of the American Mathematical Society, 146, 1969. Roger \nHindley and Jonathan P. Seldin. Intro\u00adduction to Combinators and A-calculus. Lon\u00addon Mathematical Society, \n1980. C. Barry Jay. Strong normalisation for simply-typed lambda-calculus as in lambek\u00adscott. February \n1991. LFCS, University of Ed\u00adimburgh. Claude Kirchner. Methodes et utiles de con\u00adception systematique \nd algoritmes d unification clans les theories equationnelles. PhD thesis, Universit&#38; de Nancy, 1985. \nC.F. Martin. Axiomatic bases for equational theories of natural numbers. Notices of the Am. Math. Sot., \n19(7):778, 1972. Robin Milner. A theory of type polymorphism in programming. Journal of Computer and \nSystem Science, 17(3):348-375, 1978. [NPS89] Paliath Narendran, Frank Pfenning, and Rick Statman. On \nthe unification problem for carte\u00adsian closed categories. Hardware Verification Workshop, September 1989. \n[Rit89] Mikael Rittri. Using types as search keys in function libraries. Journal of Functional Pro\u00adgramming, \nl(l), 1989. [Rit90a] Mikael Rittri. Retrieving library identifiers by equational matching of types in \n10th Int. Conf. on Automated Deduction. Lecture Notes in Computer Science, 449, July 1990. [Rit90b] Mikael \nRittri. Searching program libraries by type and proving compiler correctness by bisim\u00adulation. PhD thesis, \nChalmers University of Technology, Goteborg, Sweden, 1990. [RT89] Colin Runcyman and Ian Toyn. Retrieving \nre-usable software components by polymorphic type. Fourth Int. Conf. on Functional Pro\u00adgramming Languages \nand Computer Architec\u00adture, 1989. [S0183] Serjey V. Soloviev. The category of finite sets and cart esian \nclosed categories. Journal of So\u00adviet Mathematics, 22(3):1387 1400, 1983. A Technical proofs. This Appendix \nis meant to provide a sketch of the proofs of Theorems 4.1 and Proposition 4.3, and it is mainly here \nwith the aim to give a taste of the proof techniques that were developed, not to provide the full details. \nThe interested reader ought to refer to [DC91] and [DC92]. In particular, we will use in what follows \nmany no\u00adtion whose definition can be best found in the refer\u00adences. For the notion of finite-hereditary \n-permutations (f.h.p. s) and B6hm tree (BT(M)) of a term M, see [Bar84], [BDCL90]. For second order finite-hereditary\u00ad \npermutations (2-f. h.p. s), see [BL85] and especially [DC91].  A.1 Completeness To show completeness \nof ThML, we first notice that each type reduction rule in * (see Definition 4.4) de\u00adrives from a valid \nisomorphism. So to each such type reduction is associated an isomorphism, and then, since isomorphisms \ncompose, any isomorphism M can be decomposed as in Figure 1, where F and G, with their inverses F l and \nG-l, are the isomorphisms as\u00adsociated to the rules used to rewrite the types A and B to their split-normal-form. \nIt is evident from the diagram that two types A and B are isomorphic iff their split normal forms are. \nNow, reduction to split normal form is done accordingly to some axioms of Th~L, so that to prove completeness \nF A z V~.(A1 X ... X A.) A ~ M \\ M = GOMOF-l t I , i B V?.(BI x . . . x l?.) G Figure 1: Decomposition \nof an ML isomorphism. of this theory it suffices to prove completeness for iso\u00admorphisms between types \nin split-noTmal-form. In or\u00adder to do this, we study thle structure of a generic invertible term providing \nan isomorphisms between such types. We follow the techniques introduced in [BDCL90] and [DC91] for the \ncase of explicitly typed languages, that we adapt here to the type assignment framework. Since to deal \nwith the strucure of terms we need to work on normal form representatives of terms, we first need to \nprovide a suitable notion of reduction that preserves (or at least does not decrease) the set of types \nthat can be assigned to a term. This is not a concern in the case of explicitly typed languages, but \nin this type assignment framework it requires some care, as the following remark shows. Remark A.1 The \nTeductzon rule foT Subjective Pair\u00ading (SP) (PIM,P,M) Teduces to M strictly decreases the set of types \nthat can be assigned to a term by the type-in ferernce algorithm of Defini\u00ad tion 3.1. Indeed, the program \nsplit in Example 5.1 haa the type ( ( Ya-> a)x( b-> b)), but its reductum w.r.t. (SP) can only have types \nthat are instances of((}a > a) *(>a->Ja)). If we orient (SP) the other way round, though, to get a Subjective \nPairing Expansion as suggested for example in [Jay91], it is easy to show that we still get a strongly \nnormalizing calculus for which the reductum of a term M can be given at least all the types that are \nlegal for M. Theorem A.2 (Subject reduction) Let M reduce to M w.r. t. the usual notion of Teduction, \nbut with SP Expansion. If Ml-A, then MI-A. Proof. Essentially the same as in [HS801, Theo\u00ad . rem 15.17. \n0 Now we can carry on our analysis of invertible terms. Lemma 2.6 and Prol?osition 3.4 in [BDCL90] go \nthrough essentizdly unchanged in the type assign\u00adment case, and they tell us that isomorphic types in \nsplit-normal-forms have the same number of co\u00adordinates, so that, in Figure 1, n = m. Further\u00admore, for \nany given isonnorphisms M between split\u00adnormal-forms there exist a permutation ~ : n d n such that M \ncan be split into componentwise iso\u00admorphkms Mi between Ai and B.(i). Such Mi are then finite-hereditary-permutations, \nwhose structure is known from [Dez76], and. the following Completeness Theorem can be shown by induction \non the depth of the Bohm tree of M, exactly as in [BDCL90]. Theorem A.3 The theory Th~T less Axioms 10, \n11 and 12 plus (unit) and (split) is complete for ML isomorphisms. Proof. Proceed as in [13DCL90], Theorem \n3.5, with Axiom 8 and 9 on top of Axiom (swap) to take care of the additional cases arising from type \nassignment. For example, let s do the base case. depth(BT(M)) = 1. Then M is Ax.x, and can prove the \nisomorphism~ A % A2 for any type, or, for any renaming o, VX.A ~ VY.A[Ya(i) /Ari], due to the fact that \nin ML types the order and the names of the generic type variables are not rel\u00adevant. In any case, ThML \nproves these equali\u00adties: the first one trivially as ThML is a theory of equality; the second one by \nAxioms 8 and 9.  A.2 Conservativity Lemma A.4 Let M:A -~ B be a 2-f.h.p. (in normal form). If A and \nB are types not containing quantijlem, them M is a term of ~l~q (the simple typed A-calculus) and Axiom \n(swap) sufices to prove A = B. Proof. By an easy induction on the Bohm tree of M. See [DC92] for details. \n0 Theorem A.5 Let V%A and V ~.B be second order types such that A and B do not contain quanti$ers, pToducts \nand the unit type. If Th~Tt-V~.A = V ?.B, then Th~L1-V~.A = Vfh3. Proof. Suppose that the given types \nare equal in Th;T. They are already in normal form w.r.t. the rewriting system R of [DC91], Definition \n3.4, so by Theorem 3.32 of [DC911] their isomorphism is wit\u00adnessed by an invertible term M that is actually \na 2\u00ad f.h.p. (a term of A2/3q). NOW, Th~T does not allow to change the number of quantifiers in a type \nunless there is at least an occur\u00adrence of the unit type in their scope, and this is for\u00adbidden by our \nhypotheses, ~o we know that the length n of ~ is equal to that of Y. Knowing all this, let s study the \nterm M. It is a 2-f.h.p., so (see [DC91], Definition 3.29) In a 2-f.h.p., all the abstracted type variables \nmust appear once and only once at the level immediately below that where they are abstracted, so, due \nto the type of z and the fact that A does not contain quanti\u00adfiers, the first n Pi s must be exactly \nthe type variables ~ in some order. This means that, for the permuta\u00adtion o : n + k + n + k associated \nto the 2-f.h.p. M, we have that Axi .Pa(i) are 2-f.h.p.7s whose types do not contain quantifiers (or \notherwise, due to the fact that A does not contain quantifiers, M would not type\u00adcheck). Hence the real \nstructure of M is M = AZ : (V~.A).AYl . . . Ynkn+l . . . $n+k. ZIYO(l) . . . Yr(n)]Pn+l . . . Pn+k, \nwhere we know by Lemma A.4, that the 2-f.h.p. s Xci.Pa(i) (and hence the Pn+i s), are simple typed terms \nof Al @q. Now, by a simple induction on the depth of the Bohm tree of M it is easy to show that V~.A \n= b?.B can be proved using only (swap) and Axioms 8 and 9, that are all derivable in Z hML. 0 Corollary \nA.6 Let V~.A and V ?.B be second order types as above in Theorem A. 5. Let V~ .A and V ? .B be the ML \ntypes obtained from them by erasing all quantifications on type variables no: occurring in A and B respectively. \nThen Th~T1-VX.A = V ~.B ~ ThML1-V~ ,A = V? .B Proof. Suppose Th\\~l-V~.A = &#38;.B. The terms Pm+i s and \nthe variables xi s in Theo\u00adrem A.5 contain as free type variables only the Y7j s, as only these variables \noccur in the type B, so we can build the term kf = ~W : (Vfi,A).A@.X-cn+l . . . Zn+k. @q~n+l . . . Prl+k \n Where Y; is what is left of YC(I).. . Y@(n) after erasing the type variables not occurring in B, The \nterm M type checks2, and proves (in Th\\~) W? .A = W .B, so we can apply ~nce mor~ Theo\u00adrem A.5 and finally \nget Th~L1-VX .A = VY .B, as required. 0 Theorem A.7 (ThML subsumes Th~T on ML types) Let C and D be any \nML types. If Th~~ 1-C = D, then ThML F-C = D. 2Notice that @ and X have the same length, since the rules \nin ~h~~ do not change the number of bound variables to prove V~.A = V~.B Proof. Let C = v%A, and C = \nV$!.B be ML types equated in Th~T. Take their normal forms n.f. (C) and n.f. (D) w.r.t. the type rewriting \nsystem R of [DC91]. We know that, since they are equal in Th~~, there is an n s.t. n.f.(C) = (Cl x ... \nx C .) and n.f.(D) = (Dl x... x Dn), where no product or unit type ap\u00adpears in the C i s and the Di s. \nMoreover, the rewrit\u00ading rules in R do not push any V inside * or x , and we start with ML-style types \n(that have V only as the outermost type constructors), so we know that the C i and the Di are still ML-style \ntypes. More than that, we know that for some types Ai and Bi not containing quantifiers Ci ~V~.Ai and \nDi =V?.Bi. Now, Theo\u00adrem 3.32 in [DC91] says that there exist a permuta\u00ad tion a : n ~ n s.t. for all \ni Th~,l-V~.Ai = V~.Ba(i). Let s call ~; and ~ the type variables free in the Ai s and the Bi s respectively. \nNow Corollary A.6 states that ThMLl_Vji.Ai = VYc~i) .Br(i) Since we can re\u00adname bound type variables \nin Th L, these equalities can be turned into ThMLt_VX+ i.A i = VY ~(i). B O(i) where all the type variables \nhave been renamed in such a way that no two A i s or B m(i) s share any type vari\u00adable, If M i s are \nthe ML terms associated to these ML then we can build the ML temlequalities in Th , Aw.(Jrl(p@)zu), (....J~ \nn(Pa(n)w)) +. . ) that proves ThML i-VX71 ...X7n. (A l X ... X A .) = VY71Y7n.(B l X ,,. . .. X B n) \nThese two last types are in normal form w.r.t the type rewriting system Q, that is a subsystem of R in \n[DC91], and moreover all the coordinates have disjoint type variables: they are actually split-normal-forms \nof C and D. Now, ThML proves that any ML type is equal to any of its split-normal-forms (see again Figure \n1), so, by transitivity, Th L1-C = D, as required. 0 Remark A.8 Notice that the proof relies in an essen\u00adtial \nway on the equivalence between an ML type and its split-normal-form, that is due to Axiom (split). Actually, \nwithout it, the previous theorem is false, as the following example shows. Example A.9 Let A and B be \ndifferent types. Then it is easily seen that Th~T ~ VXY.(X+(X+Y)+A) X( Y-( Y+ X)-B) = VZW.(Z+(Z+W)+B) \nX( Z+(Z+W)+A), But Th~L without Axiom (split) cannot prove it: these types are already in normal form \nw.r.t. w, and there is no way to equate them with only variable re\u00adnaming, permutation or swapping of \npremisses. 0  \n\t\t\t", "proc_id": "143165", "abstract": "<p>This paper contains a full treatment of isomorphic types for languages equipped with an ML style polymorphic type inference mechanism. Surprisingly enough the results obtained contradict the common-place feeling that (the core of) ML is a subset of second order &#955;-calculus: we can provide an isomorphism of types that holds in the core ML language, but not in second order &#955;-calculus. This new isomorphism not only allows to provide a complete (and decidable) axiomatisation of all the type isomorphic in ML style languages, a relevant issue for the <italic>type as specifications</italic> paradigm in library searches, but also suggest a natural extension that in a sense completes the type-inference mechanism in ML. This extension is easy to implement and allows to get a further insight in the nature of the <italic>let</italic> polymorphic construct.</p>", "authors": [{"name": "Robero Di Cosmo", "author_profile_id": "81332494764", "affiliation": "", "person_id": "P243954", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143208", "year": "1992", "article_id": "143208", "conference": "POPL", "title": "Type isomorphisms in a type-assignment framework", "url": "http://dl.acm.org/citation.cfm?id=143208"}