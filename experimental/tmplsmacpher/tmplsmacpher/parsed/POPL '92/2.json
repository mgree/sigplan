{"article_publication_date": "02-01-1992", "fulltext": "\n Linear Continuations * Andrzej Filinski School of Computer Science Carnegie Mellon University Pittsburgh, \nPA 15213 andrzej +@cs. cmu. edu Abstract strengthened even further: assumptions must be used ezactly \nonce. However, a modal construct is also added We present a functional interpretation of classical lin-for \nrepresenting hypotheses that may be used without ear logic based on the concept of linear continuations. \nrestrictions. A striking consequence of this (resource-Unlike their non-linear counterparts, such continuations \nconsciousness is that the otherwise problematic nega\u00adlead to a model of control that does not inherently \nim-tion can be made an involution, i.e., not not A and pose any particular evaluation strategy. Instead, \nsuch A can be identified, without loss of constructivity. additional structure is expressed by admitting \nclosely The advantages of making linearity explicit in func\u00adcontrolled copying and discarding of continuations. \nWe tional languages have been convincingly argued before also emphasize the importance of classicality \nin obtain\u00ad [Laf88a, H0188, Wad90]. The primary benefits cited are ing computationally appealing categorical \nmodels of lin\u00ad that a linear framewcmk can naturally express single\u00adear logic and propose a simple coreflective \nsubcate\u00ad threadedness (hence transparent destructive updates), gory interpretation of the modality ! \n. and reduce or even eliminate the need for garbage col\u00adlection. This stands in contrast to deducing \nsuch in\u00adformation after the fact by program analysis techniques Introduction such as abstract interpretation. \nInstead, the program can explicitly state that a piece of data will always be In recent years, there \nhas been considerable interest accessible through a single reference, and that attempts in applications \nof Girard s Linear Logic (LL) [Gir87] to copy or discard it should be considered type errors. to programming \nlanguage design and implementation. Apart from making the intent clearer, such an approach Over time, \nvarious more or less mutated versions of the enhances modularity and simplifies some issues of sepa\u00ad \noriginal system have been proposed, but they all share rate compilation: linearity can be made part of \nthe visi\u00ad the same basic premise: that assumptions made in the ble interface instead of being deduced \nfrom the (possibly course of a formal proof can not necessarily be used an still non-existent ) implement \nat ion. arbitrary number of times including zero -in deriving Notably, however, such applications exploit \nonly the the conclusion. This idea in itself is not new; numer\u00adintuit ionistic or negation-less fragment \nof LL. They es\u00adous formalizations of relevant implication are known, sentially formalize a notion of \nlinear data, which is used and even Church s original M-calculus required the ab\u00adexactly once unless \notherwise specified. Yet there re\u00adstracted variable to occur free at least once in the body mains a potentially \neven more significant application of of an abstraction. In (canonical) LL this restriction is keeping \ncloser track of resources: linear control, where the process of evaluation itself is made explicit and \nsub\u00ad *This research was sponsored in part by National Science Foun\u00ad dation Grant CCR-8922109 and in part \nby the Avionics Lab, Wright ject to linearity constraints. As we will see, classical Research and Development \nCenter, Aeronautical Systems Division (AFSC), U.S. Air Force, Wright-Patterson AFB, OH 45433-6543 un\u00ad \nlinear logic permits the control flow of a language (in\u00ad der Contract F33615.90-C.1465, ARPA Order No. \n7597. The views cluding the evaluation strategy) to be modeled natu\u00ad and conclusions contained in this \ndocument are those of the author rally using the same basic concepts as those used for and should not \nbe interpreted as representing the official policies, either expressed or implied, of the U.S. Government. \nexpressing its data flow. In fact, the fundamental idea is precisely to reflect the domain of control \ninto the world of linear data using the tool of first-class linear Permission to copy without fee all \nor part of this matertial is granted continuations. provided that the copies are not made or distributed \nfor direct Again, this approach complements implementationcommercial advantage, the ACM copyright notice \nand the titfe of tie techniques such as strictness analysis: instead of treat\u00ad publication and its date \nappear, and notice is given that the copying is by permission of the Association for Computing Machinery. \nTo copy other\u00ad ing sites of exactly-once evaluation as isolated islands wise, or to republish, requires \na f= andlor specific permission. @ 1992 ACM 089791-453-8/92/0001/0027 $1.50 of linearity in a fundamentally \nnon-linear language, a theory of linear control views linear constructs as the very skeleton around which \nnon-linear features are built. Perhaps somewhat paradoxically, a purely linear evalua\u00adtion framework \ndoes not limit parallelism or overspecify an evaluation strategy even in the presence of first\u00adclass \ncontinuations! Only when non-linear constructs must be accommodated (for example, when pieces of residual \ncomputation must be discardable without any linowledge of their internal structure) does the model impose \na definite evaluation order. Since the proper formalization of linearity -especially for control -is \nnot always intuitively obvious, we will rely on category theory as an organizational tool and guiding \nlight. In particular, we will be formalizing lin\u00adear control in the setting of linear categories, a close \nrelative of the ubiquitous cartesian closed categories (CCCS) permeating most work on categorical semantics \nof programming languages; essentially, linear categories are to (classical) LL what CCCS are to intuitionistic \nlogic. At all times, however, we will try to support the categorical definitions and results by computational \nin\u00adtuition. The paper is organized as follows: section 2 presents linear continuations in a categorical \nsetting and outlines their role in tying together formally dual constructs, Section 3 considers categorical \ninterpretations of the modal operators of LL and the significance of classical\u00adity in obtaining simple \nmodels. Section 4 outlines how classical LL can be used to faithfully represent the data types and evaluation \nstrategies of functional languages by varying the interpretation of negation. Finally, sec\u00adtion 5 discusses \nconnections with related work, and sec\u00adtion 6 summarizes the main ideaa and suggests some promising areas \nfor further investigation. 2 Linear Categories This section reviews the by now common interpretation \nof modality-free classical linear logic as a linear category and introduces the concept of first-class \nlinear contin\u00aduations as a paradigm for reasoning about functional interpretations of such categories. \nThe reader unfamil\u00adiar with category theory should probably consult the appendix for an introduction \nto the terminology used. 2.1 Tensor products and linear expo\u00adnential The usual categorical presentations \nof typed A-calculi build on the concept of cartesian closure [LS86], often supplemented with rich additional \nstructure to express refinements like polymorphism or dependent types. But at the very core of all such \nsystems remains the in\u00adtuitionistic principle that all available data at a given point can be used any \nnumber of times, and possibly not at all. This is a reasonable assumption in many cases, but it excludes \na number of otherwise very useful cate\u00adgorical models which possess only the weaker property of symmetric \nmonoidal closure, corresponding to linear A-calculi. As a first step towards defining such cate\u00adgories \nand calculi, we formalize the fundamental con\u00adcept of aggregating single-use data: Definition 1 A symmetric \nmonoidal category is a cat\u00adegory C equipped with a distinguished object 1 ( unit ], a bifunctor @ : \nC x C + C ( tensor product ), and natural isomorphisms dekA:A@l-+A asslA,B,C : A@ (1?@ C) + (A@ B) @ \nC exchA,B:A@~-+~ @#! satisfying the Mac Lane-Kelly coherence conditions [Mac71]. (The coherence conditions \nformalize the expected rela\u00adtions among the structural isomorphisms above. For example, the identity \nexch~, A o exchA)B = idA@B does not follow automatically from naturality of exch, but is guaranteed by \ncoherence.) In particular, any cartesian category is symmetric monoidal, with the terminal object as \nunit and the cat\u00adegorical product as tensor product. But often the nat\u00adural product in a category is \nonly a tensor product, not a categorical one. For example, consider the cat\u00adegory SetP of sets and partial \nfunctions with a desig\u00adnated one element-set as unit and the cartesian product of two sets as their tensor \nproduct; the tensor prod\u00aduct of two partial functions ~ and g is the function ~ @ g = (a, b) R (~(a), \ng(b)), defined iff $(u) and g(b) are both defined. Such products are different from the categorical products \nin SetP, where, e.g., the empty set is terminal. Even though tensor products lack the projections and \npairings characterizing their categorical counterparts, we can still define exponential in the usual \nway by ex\u00adploiting the functoriality of B: Definition 2 A symmetric monoidal category is tailed closed \nif the functor @ B has a rigltt adjoint B -+ ( linear exponential ) for every object B. We wi[l ofien \nuse the abbreviation SMCC for such a cafegory. We write the counit of the adjunction as ap ( applica\u00adtion \n) and the factorize as cur( ) ( currying ), giving the two adjunction equations: apB,C o (cur(f) @idB) \n= f : A@B + C cur(ap~,c o (9@idE)) = g : A -+ B-+C (Following the conventions for ordinary products and \nexponentials, the operator B binds tighter than ~.) For example, SetP with the tensor product mentioned \nabove is symmetric monoidal closed. It is not cartesian closed, however the categorical product in Setp \ndoes not have a right adjoint. Analogously to cartesian closed categories (CCCS) and A-calculi, we can \nexpress SMCC morphisms using a more concise lambda-syntax extended with a tuple notation for tensor products. \nThe crucial property of such a linear A-calculus is that data must be used ex\u00adactly once, leading naturally \nto variable patterns in }\u00adabstractions [Laf88aj. For example, the linear A-term with a free variable \na : A  A(bB,fA@B-c). f (a, b) represents a categorical morphism with source A: Cur(apA@B,C o f2XChA@B,A@B+C \no WdA,B,A@jB-eC) :A-+BL8(A8B4C)4C The adjunction equations correspond to the usual /3q\u00adequivalence bet \nween terms, just as for ordinary A-calculi and cartesian closure. We can also note that the product-free \nfragment of the linear ~-calculus corresponds to a combinatory logic in which the usual basic combinators \nS = A,fgz. jz(gx), K = Xzy. z (and 1 = k. z = S1{1<) are replaced by the linear combinators B = ~~gx. \n~(gz), C = ~~xy. ~yx, and I = Ax. z. These do indeed use each abstracted variable exactly once, unlike \nboth S (which uses z twice) and 1< (which discards y). 2.2 Duality and negation As outlined above, the \ncategorical interpretation of in\u00adtuitionistic LL as an SMCC provides a semantical ba\u00adsis for higher-order \nfunctions over linear data. We will now see how the negation operator of classical LL can be interpreted \nas extending the internal language of the category with a construct for reasoning about control as data. \nTo this end, we will consider the very natu\u00adral categorical characterization of classicality in terms \nof dualizing objects, due to Marti-Oliet and Meseguer [MOM90, MOM91]. Despite its apparent simplicity, \nit is actually slightly stronger than the interpretation based on *-autonomous categories [Bar79] outlined \nby Seely [See89]. For any object C in an SMCC, there exists a natu\u00adral (in A) transformation A + (A -o \nC) 4 (7; we can think of it as the function AaA. AkA4c. k a. When this function is invertible for every \nA, we have: Definition 3 An object 1 in an SMCC is called a du\u00adalizing object if the natural transformation \nc+aPA,~ o exdlA,A+~) : A + (A-ol.)-ol is a (natur a/) isomor\u00adphism. An S.MCC with a dualizing object \nwill be called classical. We Will write the required inverse morphism as evalA : (A -0 -L) -01 -+ A, \ngiving the pair of equations edA o cur(apA,&#38; O eXChA,A--.al ) = idA CUr(aPA,~ 0 eXChA,A4~) 0 evalA \n= id(A-o~)-~ We note in particular that 1-01 % (1 --0 -L) -0 J-E 1. The combination A-o 1 is usually \nabbreviated Al, the linear negation of A. (Syntactically, .1 binds tighter than any prefix or infix operator; \nthe notation symbolizes A orthogonal , not a function space.) It would have been very convenient to have \nsuch a negation in a cartesian closed category, Unfortunately, it is fairly easy to show (e. g., [LS86, \np. 67]; the obser\u00advation is usually credited to Joyal) that a CCC can\u00ad not have a dualizing object unless \nit is a preorder, i.e., contains at most one morphism between any two ob\u00adjects. We thus really need the \nadditional restrictions im\u00adposed by linearity to obtain non-degenerate categories with dualizing objects. \nFor example, the category Cohl of coherent spaces and linear maps [Gir87] (which has independent semantic \ninterest) is actually a classical SMCC [See89, MOM90]. We can introduce the counterpart of eval (no relation \nto the Lisp construct of the same name) in the linear J-calculus as a special operator D with typing \nrule I I-E:(A+L)-OL 171-DE:A The categorical isornorphism equations then correspond directly to the \nfollowing two identities between linear ~\u00ad terms: D(~kA4L. kE) = E:A ,MA4L. k(DE) = E:(A4L) -01 What \nis the computi~tional intuition behind these equal\u00adities? If we think of a value of type 1 -o A as repre\u00adsenting \na function with no input, a value of the dual type A -01 would logically represent a function with no \noutput; we will call such a black hole function a (linear) A-accepting continuation. With this view, \nD becomes a construct for adding jirst-class (z. e., usable with the same generality as other values) \ncontinuations to the language: V calls its ar\u00adgument E with the current continuation represented as a \nnon-returning function. Because of linearity con\u00adstraints, E must eventually apply this continuation \nto some A-typed value:L, and computation resumes as if D had just returned. that value. In other words, \nD al\u00adlows us to reify an otherwise intangible evaluation con\u00adtext into a piece of data. 1We assume here \nthat the initial continuation is itself linear, i. e., that the final result returned by the program \nwill actually be used up . fn particular, if the result contains functional compo\u00adnents, each of those \nwill also be applied exactly once to a value of the appropriate type. The first equation above can now \nbe paraphrased as capturing the current continuation k and imme\u00ad diately applying it to E (i. e., abstracting \nthe current context, then evaluating E in that context) is redun\u00ad dant . The second, which can be equivalently \nstated aa k (D E) = E k, tells us that when a continuation k is applied to D E (i. e., when D E is evaluated \nin a context represented by k), that continuation will be captured by D and passed to E as an argument \n. Seen in this way, D closely resembles Scheme s call/cc [RC86], the C-operator of [FFKD87], or the version \nof C considered in [Gri90] (where the idea of double-negation elimination as a control operator was first \npresented, but in a non-linear setting). In particu\u00ad lar, D satisfies equations E (D E) = V (~k. k(E \n( D E))) = D (Ak. [Ja. k (E a)] (DE)) = D (Ak. E (~a. k (E a))) (DE) E = V (Ak. k ((D E) E )) = D (Ak. \n[Af. k (fE )] (DE)) = V (Ak. E (Af. k (j E ))) analogous to Felleisen s rules for the C-operator, which \nallow us to (bubble ) Ds up towards the root of a term. But the properties of a dualizing object have \nwider\u00adranging consequences than might be expected. Essen\u00adtially, linear continuations commute, ensuring \na kind of coherence among linear A-terms that is not guaranteed by the SMCC axioms alone. For example, \ngiven two linear request-acceptors El :A~A and E2:BLL, we can obtain a value of type A @ B in two different \nways depending on which expression we query first, but we easily check that ~k, El (Au. E2 (M. k (a, \nb))) = Ak. Ez (Ah. El (As. k (a, 6))) = Ak. k(DE1, DE2) In other words, linear continuation-passing style \ndoes not inherently pick an arbitrary evaluation order among tuple or application components; such an \norder is only imposed when the continuations can be discarded or invoked multiple times. This property \nmay even provide a link between true parallelism and continuation-based multiprogramming [Wan80]. In \nthe latter, a call/cc-like operator is es\u00adsentially used to implement a corouiine facility, where captured \ncontinuations are never applied twice. Each thread of control makes independent progress with\u00adout backtracking, \nand first-class continuations are used only to multiplex them onto a single processor. This lin\u00adear use \nof continuations is especially significant for pre\u00ademptive (timer-based) scheduling, where continuations \ncan be captured and switched asynchronously during execution of what would otherwise appear as ordinary, \nsequent ial code. Moreover, if we take only negation (suitably axiom\u00ad atized) and tensor products as \nprimitives, we can de\u00ad fine the linear exponential A + B as (A B BL)l, In the computational interpretation, \nwe can thus think of a functional value as a continuation accepting a pair ( application context ) consisting \nof an A-typed argu\u00ad ment and a B-typed return continuation. Linearity en\u00ad sures that the ret urn continuation \nis eventually invoked, so all linear functions do return to their place of call. This view of functions \nas continuations will be particu\u00ad larly useful later, when we replace linear negation with call-by-value \nnegation to get a traditional Scheme-like language where functions need not return exactly once.  2.3 \nAdditives Linear logic also defines a set of additive connective which correspond to categorical products \nand coprod\u00aducts. In the intuitionistic subset they must be axioma\u00adtized separately, but it is easily \nshown that if a classical SMCC has a terminal object T and binary products A &#38; B, it also has an \ninitial object O and binary co\u00adproducts A@ B, and vice versa; such a category is called linear. Computationally, \na value of type A &#38; B repre\u00adsents a pair of which either the A-typed or the B-typed component must \nbe used in the computation, but the choice can be made at the point of use. Conversely, a value of type \nA @ B is a value either of type A or of type B, the choice being made at the point of creation. For reasons \nwhich will become apparent in the next section, we choose to treat the coproducts as fundamen\u00adtal and \ndejine A&#38;B as (A1 @ B1)l. It is instructive to note how this equivalence is explained very naturally \nin terms of continuations: a product of A and B is inter\u00adpreted as a continuation accepting tagged requests \nfor either an A or a B. This is reflected by the projection and pairing morphisms: fst(p) = 2? (JkAL \n.p(inl(k))) snd(p) = D (~k~ . p (inr(k))) . (case r of inl(kl) ~ kl (f(c)) 1 (f~9)(C) = h Ai@B~ inr(k2) \n~ k2 (g(c))) The product equations follow directly from the ones for the coproduct and negation, Similarly, \nwe let T = 01, an object from which no information can be extracted.  3 Modal Operators The fragment \nof linear logic presented so far is not very expressive. For general computation, we need a way to express \nnon-linear uses of data, such as Girard s modal operators ! and ? , Unfortunately, their semantic properties \nare not nearly as well understood as the pure linear fragment; in particular, the proposed categorical \ninterpretation of ! [Laf88a] is often considered some\u00ad what controversial (e.g., [See89]). One reason \nfor these problems may be that in the in\u00ad tuitionistic fragment of LL, ! is forced to perform two rather \nunrelated functions: expressing copyabil\u00ad ity/discardability of data and suspending potentially non-terminating \ncomputations. In this section, we will see how the additional expressive power provided by full (z. e,, \nclassical) linear logic and the modality ? allows us to properly separate these concepts. More precisely, \nwe will consider a class of particularly simple categorical models which may not be adequate to model \ncomputa\u00adtion in the intuitionistic case, but which look viable for classical LL. 3.1 Copying and discarding \ndata In a purely linear language, every datum must be used exactly once. For example, a term like Az. \n(~z, gz) would be illegal because z appears twice in the body of the A-abstraction. However, even in \nthe pure frame\u00adwork we can actually copy and discard data of certain types without violating linearity. \nFor example, if we define the type bool as 1 @1, we can in effect duplicate a truth value using the function \nAz:booi. if s then ($ true, g true) else (~ false, g false) where true and false abbreviate inl () and \ninr (), respec\u00adtively, and the if-construct denotes the coproduct casing morphism. We note that with \nthis encoding, the func\u00adtion argument will still be evaluated exactly once, re\u00adgardless of the global \nevaluation strategy. Of course, an analogous expression can be used to discard a boolean value. But most \nimportantly, in the case where the boolean argument is in fact used exactly once, adding the explicit \nconditional does not change the meaning of the expression because of the identity if bthen E true else \nE false = Eb (which is just the A-syntax counterpart of the coproduct uniqueness equation [j o inl, \n~ o inr] = $). Thus, the linear case integrates smoothly with the extension. In general, we can copy/discard \nfinite tensor products (component-wise) and categorical coproducts (case\u00adwise) of already copyable/discardable \nobjects. With re\u00adcursively defined types, such as IV ~ 1 @ N and some form of primitive recursion, we \ncan similarly copy and discard natural numbers (if they are not already in\u00adcluded as primitive types \nwith associated copy/discard functions), as well as lists, trees, etc. of such types. However, there \nis no general way to copy even very (small function spaces such as bool -o bool or cate\u00adgorical products \nlike bool &#38; bool because their internal structure is inaccessible. To formalize this distinction, \nwe must first make pre\u00adcise what it means to copy or discard a value. As usual, category theory provides \na tool in the form of comonoids. The details can be found in [Mac71] or [Laf88a]; here, we will just \nstate the key concepts: Definition 4 A (cc~-)commutative comonoid in a sym\u00ad metric monoidal category \nC consists of an object A and two morphisms d : A+landc: A+ A@ Asatis. fying the following equations \n(written out in applicative notation with a : A): let (al, az)=c(a) in = let ()=d(az) in al a  let (al, \na2)=c(a) in let (al, az)=c(a) in let (a21, a22)=c(a2) in = let (all, alz)=c(al) in (al, a21, a22) (all,a12,a2) \nlet (al, CJ2)=C(O:) in let (al, a2)=c(a) in (az,a~) = (a~, a2) These equations ensure [Mac71] that for \na given co\u00ad monoid (A,d,c), there exists a unique structural mor\u00ad phism (i. e., one built out of c s, \nd s, and the isomor\u00ad phisms of definition 1) A + A (= A CZJ.!. @ A) for every n>O. A morphism of comonoids \nf : (A, d~, c*) + (B, dB, CB) is a C-morphism f : A + 1? that respects comonoidal structure, Z.e., satisfies \ndB(f(a)) = let () = d~(a) in () c~(f(a)) = let (al, U2) = cA(U) in (f (al), f(az)) Not every value can \nbe copied or discarded, but if it can, it seems natllrd to require that there be a unique way of doing \nso. A simple, if not very subtle, way of ensuring this is provided by the following: Definition 5 A symmetric \nmonoidal category C will be called pre-cartesian if the forgetful functor from the cat\u00adegory of commutative \ncomonoids in C to C is a full em\u00adbedding, i.e., if it determines a full subcategory Core(C) Oft. We will \ngenerally use the letters S and T for objects in this subcategory. In effect, the definition associates \nto every object of the core a unique way to copy and discard values of that type. For every such object \nS, we thus have a unique comonoid (S, drops : S + 1, copy~ : S + SOS), and all morphisms between such \nobjects are morphisms of comonoids. Coupled with the properties of the tensor products, this gives us \nthe easily (if somewhat tediously) checked Proposition 1 In a pre-cartesian symmetric monoidai category \nC, the subcategory Core(C) is in fact cariesian, with 1 as a terminal object and the tensor product S@T \nas a categorical product of S and T in 6 ore(C). Motivated by this result, we will refer to objects in \nthe subcategory as Cartesian objects or types. For such objects we do have the usual projections and \npairing associated with categorical products. Moreover, 0 is cartesian, and if S and T are, so is SOT. \nSince there is only one waytocopy or discard data, we could simply extend the linear A-syntax to al\u00adlow \nmultiple occurrences of cartesian-typed variables without semantic ambiguity. However, such a syntax \nwould be slightly deceptive, because conversions such as (Az. (z, z)) E = (E, E) are only valid when \nall the free variables of E are of cartesian type (the morphism corresponding to E must be a morphism \nof comonoids to commute with copying). Instead, we will use the no\u00adtation ,l z. E with z occurring multiple \ntimes in E as a conceptual abbreviation for the purely linear A-term with all copying and discarding \nmade explicit as out\u00adlined in the beginning of this section. This does not mean that it has to be implemented \nthat way, only that its semantic properties are defined by the expansion. In the case where x is actually \nused exactly once in E, we do have A*x. E = Ax. E. 3,2 The modality of course Armed with a categorical \ncharacterization of copying and discarding, let us now consider a (completion of the framework to arbitrary \ntypes, based on the concept of representations in a subcategory. For examplej the category of sets and \n(total) functions is clearly a proper sub category of sets and binary relations, but every re\u00adlation \nA + B can be uniquely encoded as a function A + P(B) (i. e., from A to the powerset of B). Anal~ gously, \nwe have: Definition 6 A pre-cartesian category C witi be called canonical if its core is corejlective \nin C, i.e., if the in\u00adclusion functor i : Core(C) w C has a right adjoint ! : C + C ore(C). More explicitly, \nthe adjunction assigns to every ob\u00adject A of C an object !A ( of course A ) of C ore(C) (i. e., with \nassociated morphisms drop!A : !A + 1 and copyIA : !A -+ !A @ !A) together with a morphism readA : !A \n-+ A, such that for every object S of Gore (C) and morphism ~ : S -+ A, there exists a unique morphism \ncode(f) : S -+ !A satisfying readA ocode(f) = f :S + A Uniqueness is expressed by the matching equation \ncode(readA o g) = g : S --+ !A, which again is equiva\u00adlent (given the equation above) to the following, \nmore intuitively appealing pair (where h : T + S is any core morphism): As expected from the computational \ninterpretation of the products and (! , we have !(A &#38; B) ~ !A @ !B and !T % 1. The quickest (if somewhat \nobscure) way to verify this is to note that the functor ! has a left ad\u00adjoint (namely the inclusion), \nhence preserves limits. In particular, it maps categorical products in the large cat\u00adegory to categorical \nproducts in the subcategory. For\u00adtunately, we can also easily construct the required iso\u00admorphisms explicitly. \nMoreover, for any object S of the core, there is an isomorphism !S = S; in particular, !!A = !A for every \nobject A, so we do not have to deal with multiple (degrees of copyability. A computational interpretation \nof !A in this frame\u00adwork is as a pair consisting of a (copyable and discard\u00adable) value of a representation \ntype S and an access function (a code pointer, not a closure) of type S + A. We copy or discard a value \nof type !A by copying or dis\u00adcarding the S-typed value representing it. Of course, the actual representation \nis completely invisible from within the category. The following analogy may be useful: we can implement \nhigher-order functions using simpler constructs to build and manipulate explicit clo\u00adsures, but at the \nprice of extensionality: two closures may represent the same function even if their internal structure \nis completely different. Similarly, the cate\u00adgorical equations governing !A permit us to change the represent \nat ion of an !A-typed value at any time, as long as it reads to the same value. In particular, if A is \nitself a cartesian type, we can change the representation type to just A and the ac\u00adcess function to \nidA whenever convenient an obvious choice being immediately after the first read of !A. In other words, \nthe usual technique of memorization ap\u00adplies, even in the presence of first-class continuations. In the \nlinear A-calculus, we can represent code( ) as the term E : !A, where all the free variables in E : A \nhave cartesian (but not necessarily ! -) type. Con\u00adversely, we add a new abstraction pattern x : !A, \nwith every use of x : A in the body representing a readA.2 Unlike A , which was only a definitional extension, \nthe -notation represents additional categorical structure; in particular, A*z:!A. E := A a:!A. E[ a/z]. \nTaken together with the pre-cartesian structure of C, the three adjunction equations for code( ) and \nread correspond (though not quite 1-1) to the following three equalities between linear A-terms: (A z. \nEl) E2 = El[E2/x] A x. E x = E (~ @ FV(E)) (A %. El) E, = (EI [E2/z]) 2The syntactic similarity with \nthe Lisp/Scheme quote COn\u00adstrnct is, of course, purely coincidental. We use instead of ! on purpose; \nto maintain a simple correspondence between ,\\-terms of code(readA) = idfA : !A + !A functional type \nand categorical morphisms, the operator ! must code(f) o h = code(f o h) : T --+ !A be reserved for functorial \naction on morphisms: !j = A z. (fz). The first two of these allow us to extend pattern-@q equivalence \nto -patterns. The third verifies correctness of substitution under ; we need the A* here, because even \nif z only occurs once in El, it will be embedded in a value that can be used multiple times. Again, it \nis worth pointing out that though the above discussion does not explicitly mention classical features \nof the category, the whole model is only reasonable be\u00adcause we still have an ace left for expressing \npotentially non-terminating computations: discardable continua\u00adtions. 3.3 The modality (why not Finally, \nlet us consider how we can introduce partiality in a linear category: Definition 7 We w~ite ?A ( why \nnot A ) for (! AL)L. Computationally, we interpret the isomorphism ALL s A as a continuation taccepting \nan A-accepting continuation k must eventually apply k to some A-typed value a . But ?A represents a continuation \nt that ac\u00adcepts a continuation k which it may freely discard or copy. Thus, evaluation of a ?A-typed \nterm may never return, or it may return multiple times to the same point with different values. At least \nthe non-returning aspect is common to all programming languages with the possibility of infinite loops, \neven (intuitionistic linear ones like Lafont s LIVE [Laf88b]: a linear function which loops forever has \nin a sense broken its promise to apply the return continuation it is passed. We can say that such func\u00adtions \nare not linear in their output, even if their input is only used once. on the other hand, a type system \nbased on classical linear logic allows us to express that a function always produces exactly one result \n(essentially a totaiity condition) using the same mechanisms as for expressing that the input is consumed \nexactly once (a refinement of strictness).  4 Representing Evaluation Strategies This section sketches \nan application of classical linear logic as a semantic basis for traditional functional lan\u00adguages. In \nparticular, we focus on how compound data types and evaluation strategies are represented by con\u00adstructs \nin the (subcategory models of classical lin\u00adear logic presented in the previous section. We will consider \ncall-by-value (CBV) and call-by-name (CBN) evaluation of a simple language with product, coprod\u00aduct, \nexponential and co-exponential types (the last\u00admentioned seem to arise naturally in categorical models \nof first-class continuations [Fi189a] ). In a linear frame\u00adwork, these two strategies can be seen as \nessentially dual, a relation usuadly obscured by the asymmetries of intuitionistic logic. 4.1 Call-by-value \nA fairly convincing case can be made that a CBV func\u00adtional language should have some representation \nof first\u00adclass continuations for completeness, much as a product type falls out naturally from the correspondence \nbe\u00ad tween ordinary lambda-calculi and CCCS. Modulo syn\u00adtactic differences, languages of this kind include \n(the functional subsets of) Scheme [RC86] and recent ver\u00adsions of Standard ML of New Jersey [DHM91]. \nSince CBV continuations are first-class (hence copy\u00adable and discardable), it is convenient to introduce \nthe following abbreviation for call-by-value negation: 7A := !Al We note in particular that =0 % 1 and \n=(A@B) R ~A@ --IB, i.e., a CBV continuation expecting a coproduct\u00adtyped value is equivident to a pair \nof continuations, one for each case. Building on this concept of negation, we interpret a CBV term E \nwith a free variable x as a linear morphism [z :A 1-E:B] : [A] + ?[Bj (or, equivalently: [A] @ -[B] + \n-L), where the meaning of CBV types is given by: [P] = !JP (Pa base type) [1] =1 [AX B] = [A]8[B] [0] \n= u [A+ B] = [A]@ [B] [[A + B]] = -I([A] 8 =[B]) E !([A] + ?[B]) [[A + B]] = -I~A] @[B] S !([A] + 1) \n@[B] ([A -B] is a coexponential type, see below.) For exam\u00adple, we find [[A +0]] = 7[A] and [[1 +A]] \nG --i[A] ~ !?[A]. We note that all expressible types are carte\u00adsian (in particular, for any type T of \nthe CBV language, [~ ~ ![T]). This means that a CBV term can have multlple free variables, each of which \nit may use any number of times, as usual. The actual translation on CBV A-terms is essen\u00adtially a typed \nand uncurried version the well-known continuation-passing transform (e. g., [PI075]), but the key observation \nhere is that the resulting terms are lin\u00ad ear! In particular, we can simply use An-s in the trans\u00adlation \nto express multiple uses of data in the original terms because all the values involved are cartesian \n(1, representing the type of final answers, is not cartesian but never appears as a function argument \neither). This suggests that, continuation-passing style is much more than an ad-hoc syntactic restriction \non non-linear terms; rather, it is in a sense the real meaning of CBV terms, and thus a very natural \nintermediate represen\u00ad tation for compilation [Ste78, AJ89], semantic analy\u00adsis [Shi91], or partial evaluation \n[CD91]. The linear framework can easily encompass trivial functions (i. e., functions that always terminate \nand do not escape) as values of type =(A @ BL ). Also, CBV continuations are necessarily strict by virtue \nof their types. Furthermore, we observe that O is in fact a categorical initial object in the category \nof CBV types and terms, and A + B is a categorical coproduct. We even have co\u00adcartesian closure: the \ncoproduct has a left adjoint (the coexponential) and functions that return a coproduct\u00adtyped result can \nbe co-curried by distinguishing one of the cases as the explicit return and the other as an implicit \nreturn corresponding to a non-local exit. On the other hand, the type denoted by A x B is not a categorical \nproduct: fst (El, E2) # El when E2 is not total. We can, however, define an alternative lazy product \nwithin the language: AIIB := [1-+ A]x[l-+B] with interpretation [A II B] s !?[A] @ !?[B] G !(?[A] &#38; \n?[B]) This is not a categorical product either (we have exis\u00adtence but not uniqueness of mediating morphisms), \nbut it has an interesting parallel in CBN coproducts, as we will see in the next subsection.  4.2 Call-by-name \nSimilarly to CBV, we will consider models of full CBN languages; the properties of coexponential types \nin CBN turn out not to interfere significantly with the rest of the language, but still provide a notion \nof first-class continuations appropriate to this strategy. Let us first consider the pure CBN language \n[Fi189b], obtained as the exact mirror image of CBV. Here, an expression E : B with free variable x : \nA is represented by a linear morphism ! [A] -[B] (or ! [A] @ [B] ~ --+ L), Thus, CBN terms can also use \ntheir free variables any number of times, but for a slightly different reason than in CBV. We also have \na CBN negation: -A ;= ?AL and the following interpretation of types: [P] = ?P (P a base type) [1] =T \n[AX B] = [A]&#38; [B] [0] =J_ [A+ B] = [A] T[B] [[A ~ B]] = -[A] T[B] = ![A] = [B] [[A - B]] = -([A]% \n-[B]) ~ ?([A]L B ![B]) Following Girard s notation, we use A % B to denote (AL @ BL)L. We note that all \ntypes are now co\u00adcartesian, i.e., for any type expression T, [T] 9 ?[~. This means that all variables \nrepresent potentially non\u00ad terminating residual computations. Of course, since the connective used for \nCBN can be expressed (but at the cost of obscuring the symmetry) in terms of the CBV connective and linear \nnegation, the above translation on types can likewise be used as the basis of a CPS\u00ad based implementation. \nIt is easily checked that the CBN category is in fact cartesian closed, with 1 as terminal object, A \nx B as product and [A -+ B] as exponential. However, the be\u00adhavior of A + B is not what we would expect \n-it is too lazy. In fact, there is no way to add proper coprod\u00aducts to a language where every function \nhas a fixpoint [HP90], but just as for lazy products in CBV, we can define the more conventional eager \ncoproducts AI.IB := [O~A]+[O+B] with the interpretation [ALI B] s ?![A] ~?![B] S ?(![A]6 ![B]) which \nmake it possible to evaluate a coproduct-typed datum until its injection tag is known but without forc\u00ading \nevaluation of the actual inject. Except for the ? (which accounts for possible non-termination), this \nis identical to the usual encoding of intuitionistic or in LL [GL87]. In particular, we have so booleans \nare definable as expected.  5 Comparison with Related Work Naturally, this paper builds on Girard s \nfundamental work on Linear Logic [Gir87]. The question/answer symmetry mentioned there is interpreted \nhere as a du\u00adality between values and continuations, seen as the two extreme cases of linear functions. \nThe interpretation of modality-free classical LL as a linear category [See89, MOM90] appears to be com\u00ad \nmonly accepted. However, the proposed categorical view of ! -types as cofree coalgebras [GL87] seems \nori\u00adented towards the intuitionistic subset of LL only. The additional structure of classical LL, notably \nthe avail\u00adability of ? -types for representing terms that do not necessarily evaluate to proper values \nshould allow for conceptually, as well as computationally, simpler mod\u00adels. Both categorical and more \npragmatic computational interpretations of linear logic as a functional program\u00adming language, e.g., \n[H0188] have focused on the intu\u00aditionistic subset, with tlhe understanding that the clas\u00adsical version \nwas intimately linked with parallelism and communication; more recent work [Abr90] reinforces this dichotomy. \nHowever, while its potential for paral\u00adlel evaluation is indeed exciting, it seems that classical LL \ncan also give us a better understanding of control flow in traditional, sequential languages than either \nin\u00ad tuitionistic or intuitionistic linear logic. From another direction, syntactic theories such as the \ncontinuation calculi of [FFKD87] have been pro\u00adposed as a tool for formal reasoning about call/cc\u00adlike \ncontrol operators, The striking connection between such operators and classical logic was later pointed \nout by Griffin [Gri90], and very convincingly related to Friedman s A-transli~tion and CPS transformations \nby Murthy [Mur91]. There is hope that an analysis in terms of (classical) linearity will also make it \npossible to derive such results semantically, supplementing the cur\u00adrent understanding of CPS-translation \nas an essentially syntactic concept. A recent paper [Nis91] notes a connection between classical LL and \nScheme-like languages, and presents a somewhat involved translation from typed A-terms with tail/cc to \nGirard s proof nets for LL. It too, however, takes a strongly syntax-based approach and does not consider \nthe semantic implications of linear control. (In fact, the translation looks conceptually similar to \nsim\u00adply a Griffin-Murthy C13V CPS-translation from claasi\u00adcal to intuitionistic logic, followed by Girard \ns transla\u00adtion from intuitionistic to linear logic). Finally, some work independently motivated by the \nsymmetry between values and continuations is reported in [Fi189a, Fi189b]. In retrospect, the kind of \ndual\u00ad it y considered there mirrors the CBV/CBN negations of section 4, rather than the underlying pure \nlinear negation, leading to a somewhat ad-hoc axiomatiza\u00ad t ion. Nevertheless, the results obtained there \nformed the principal motivation for the present investigation. Conclusion and Issues We have presented \na view of linear negation as rep\u00ad resenting first-class continuations in linear lambda\u00ad calculi. In particular, \nthe dualizing construct in cate\u00ad gorical models of classical linear logic can be interpreted as a call/cc-like \ncontrol operator. Building on this, we have shown how the modality ! , when applied to con\u00ad tinuation \ntypes, lets us delineate the class of possibly non-returning computations as those which potentially \ndiscard their return continuations. This allows us to decouple delayed evaluation from ! -types and leads \nto a simpler (coreflective subcategory interpret ation of the latter. Finally, we have sketched how the \naddi\u00ad tional expressive power of classical linear logic allows us to accurately represent data types \nand control flow in traditional functional programming languages. Clearly, much work remains in formalizing \nwhat has been outlined in this paper. However, a full understand\u00ading of linear continuations will probably \nalso involve resolution of two closely related issues: Polymorphism. The striking similarity between \nthe isomorphisms (A -O -L) -O J_ s A in linear cat\u00adegories and VC. (A + C) + C = A in parametric models \nof the second-order polymorphic A-calculus [Rey83] seems to be more than a coincidence; a formal connection \nwould be an important result.  The general CPS transform. By chang\u00ading the codomain of cent inuations \nfrom 1 to an information-carrying type, it seems possible to rep\u00adresent a wide variety of additional \ncomputational structure, such as side effects and backtracking, in a way complementary to the computational \nmon\u00adads of [Mog89].  Some preliminary results in this direction are reported in [DF90], but the topic \nis far from explored. Acknowledgments I wish to thank Olivier Danvy, Timothy Griffin, Robert Harper, \nNarciso Marti-Oliet, Chetan Murthy, Benjamin Pierce, and John Reynolds for their insightful comments \nand helpful suggestion on various drafts of this paper. References [Abr90] Samson Abramsky. Computational \ninterpre\u00adtations of linear logic. Imperial College Re\u00adsearch Report DOC 90/20, Department of Com\u00adputing, \nImperial College of Science, Technology and Medicine, London, UK, 1990. [AJ89] Andrew W. Al?pel and Trevor \nJim. Continua\u00adtion-passing, closure-passing style. In Proceedings of the Sixteenth Annual ACM Symposium \non Prin\u00adciples of Programming Languages, pages 293 302, Austin, Texas, January 1989. [Bar79] Michael \nBarr. *-Autonomous C aiegories. Num\u00adber 752 in Lecture Notes in Mathematics. Springer-Verlag, 1979. [CD91] \nCharles Consel and Olivier Danvy. For a bet\u00adter support of stakic data flow. In Proceedings of the 1991 \nConference on Functional Programming and C omput er Architecture, number 523 in Lec\u00adture Notes in Computer \nScience, pages 496-519, Cambridge, Massachusetts, August 1991. 35 [DF90] Olivier Danvy and Andrzej Filinski. \nAbstract\u00ad ing control. In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, \npages 151 160, Nice, France, June 1990. [DHM91] Bruce F. Duba, Robert Harper, and David MacQueen. Typing \nfirst-class continuations in ML, In Proceedings of the Eighteenth Annual ACM Symposium on Principles \nof Programming Lan\u00adguages, pages 163 173, Orlando, Florida, January 1991. [FFKD87] Matthiaa Felleisen, \nDaniel P. Friedman, Eu\u00adgene Kohlbecker, and Bruce Duba. A syntactic theory of sequential control. Theoretical \nComputer Science, 52(3):205-237, 1987. [Fi189a] Andrzej Filinski. Declarative continuations: An investigation \nof duality in programming lan\u00adguage semantics. In David H. Pitt et al., editors, Category Theory and \nComputer Science, number 389 in Lecture Notes in Computer Science, pages 224-249, Manchester, UK, September \n1989. [Fi189b] Andrzej Filinski. Declarative continuations and categorical duality, Master s thesis, \nComputer Science Department, University of Copenhagen, August 1989. DIKU Report 89/11. [Gir87] Jean-Yves \nGirard. Linear logic. Theoretical Computer Science, 50:1-102, 1987. [GL87] Jean-Yves Girard and Yves \nLafont. Linear logic and lazy computation. In Proceedings of TAP-SOFT 87, number 250 in Lecture Notes \nin Com\u00adputer Science, pages 52 66, Piss, Italy, March 1987. [Gri90] Timothy G. Griffin. A formulae-as-types \nnotion of control. In Proceedings of the Seventeenth An\u00adnual ACM Symposium on Principles of Program\u00adming \nLanguages, pages 47 58, San Francisco, Cal\u00adifornia, January 1990. [H0188] Soren Holmstrom. A linear functional \nlanguage. In Thomas Johnsson, Simon Peyton Jones, and Kent Karlsson, editors, Proceedings of the Work\u00ad \nshop on Implementation of Lazy Functional Lan\u00ad guages, pages 13 32, Aspenas, Sweden, September 1988. \nChalmers University PMG Report 53. [HP90] Hagen Huwig and Axel Poign6. A note on inconsistencies caused \nby fixpoints in a cartesian closed category. Theoretical Computer Science, 73:101-112, 1990. [Laf88a] \nYves Lafont. The linear abstract machine, Theoretical Computer Science, 59:157-180, 1988. [Laf88b] Yves \nLafont. Logiques, Categories et Ma\u00adchines. PhD thesis, University de Paris VII, Paris, France, January \n1988. [LS86] Joachim Lambek and Philip J. Scott. Introduc\u00adtion to Higher Order Categorical Logic, volume \n7 of Cambridge Studies in Advanced Mathematics. Cambridge University Press, 1986. [Mac71] Saunders Mac \nLane. Categories for the Work\u00ading Mathematician, volume 5 of Graduate Texts in Mathematics. Springer-Verlag, \n1971. [Mog89] Eugenio Moggi. Computational lambda\u00adcalculus and monads. In Proceedings of the Fourth Annual \nSymposium on Logic in Computer Science, pages 14-23, Pacific Grove, California, June 1989. IEEE. [MOM90] \nNarciso Marti-Oliet and Jos&#38; Meseguer. Du\u00adality in closed and linear categories. Technical Report \nSRI-CSL-90-01, SRI International, Menlo Park, California, February 1990. [MOM91] Narciso Marti-Oliet \nand JOS6 Meseguer. From Petri nets to linear logic. Mathematical Structures in Computer Science, 1, 1991. \n[Mur91] Chetan R. Murthy. An evaluation semantics for classical proofs. In Proceedings of the Sizth An\u00adnual \nIEEE Symposium on Logic in Computer Sci\u00adence, Amsterdam, The Netherlands, July 1991. [Nis91] Shin-ya \nNishizaki. Programs with continua\u00adtions and linear logic. In International Conference on Theoretical \nAspects of Computer Science, pages 513-531, Sendai, Japan, September 1991. [P1075] Gordon D. Plotkin. \nCall-by-name, call-by-value and the A-calculus. Theoretical Computer Science, 1:125-159, 1975. [RC86] \nJonathan Rees and William Clinger (editors). Revised3 report on the algorithmic language Scheme. SIGPLAN \nNotices, 21(12):37-79, Decem\u00ad ber 1986. [Rey83] John C. Reynolds. Types, abstraction and parametric \npolymorphism. In R, E. A, Mason, editor, Information Processing 83, pages 5 13 523. IFIP, 1983. [See89] \nRobert A. G. Seely. Linear logic, *-autonomous categories and cofree coalgebras. In John W. Gray and \nAndre Scedrov, editors, Proceedings of the AMS-IMS-SIAM Joint Conference on Categories in Computer Science \nand Logic, volume 92 of Con\u00adtemporary Mathematics, pages 371 382, Boulder, Colorado, 1989. American Mathematical \nSociety. [Shi91] Olin Shivers. The semantics of Scheme control\u00adflow analysis. In Proceedings of the Symposium \non Partial Evaluation and Semantics-Based Program Manipulation, pages 190 198, New Haven, Con\u00adnecticut, \nJune 1991. SIGPLAN Notices, Vol. 26, No. 9. [Ste78] Guy L. Steele Jr. Rabbit: A compiler for Scheme. \nTechnical Report AI-TR-474, Artficial Intelligence Laboratory, Massachusetts Institute of Technology, \nCambridge, Massachusetts, May 1978. [Wad90] Philip Wadler. Linear types can change the world! In Proceedings \nof IFIP TC2 Working Con\u00adference on Programming Concepts and Methods, pages 546-566, Sea Galilee, Israel, \nApril 1990. [Wan80] Mitchell Wand. Continuation-based multipro\u00ad cessing. In Conference Record of the \n1980 LISP Conference, pages 19 28, Stanford, California, Au\u00ad gust 1980.  A A quick review of some cate\u00adgorical \nterminology Please note: this appendix contains no original material and is included only to help readers \nunfamiliar with cat\u00adegory theory follow the technical contents of the paper. The definitions presented \nhere are necessarily terse and not completely rigorous; the interested reader should consult a proper \nintroduction to category theory for the full story. A category consists of a collection of objects and \nmor\u00adphisms (or arrows) between them, such that (1) any pair of morphisms ~ :A*Bandg:B*C can be composed \ninto g o f : A ~ C, (2) morphism com\u00adposition is associative ((h o g) o f = h o (g o f)), and (3) for \nevery object A, there exists an identity mor\u00adphism idA : A-Asuchthatforf: A-B, id~of=f=fo idA. An important \nclass of such structures are the concrete categories, where objects are sets with some structure and \nmorphisms are structure\u00adpreserving maps. Examples include the categories Set of sets and (total) functions, \nSetP of sets and partial functions, Grp of groups and group homomorphisms, Dom of (Scott) domains and \ncontinuous functions, etc. Similarly, the types of a functional language L (e.g., ML) and computable \nfunctions between them form a category TypL. An isomorphism is a morphism f : A -B with a two-sided inverse \nf 1 : B a A (i. e., f-l o f = idA and f o f-l = idB); in this case we say that A and B are isomorphic, \nwritten A E B. In most contexts, isomorphic objects can be treated as identical because they have the \nsame categorical properties. A subcate\u00adgory S of a category C is a subset of C s objects and morphisms \nwhich is itself a category; for example, Set is a subcategory of SetP. A full subcategory contains all \nmorphisms of the original category whose source and target objects are in the subcategory; the category \nSetf ofjinite sets and (total) functions between them is a full sub category of Set. A key observation \nof category theory is that many important concepts can be defined without ever refer\u00ad ring to he internal \nstructure of objects, only to the morphisms between them. For example, a categorical product of two objects \nA and B is given by an object A x B together with projections fst : A x B ~ A and snd : A x B ~ E, such \nthat for any object C and morphisms f :C * A and g :C * B, there ex\u00ad ists a unique pairing morphism (f, \ng) : C ~ A x B satisfying fst o (f, 91) = f and snd o (f, g) = g. The uniqueness condition can be expressed \nequationally as (fst oh,sndo h) = h for all h :C + A x B. A terminal object 1 has the property that for \nany object A, there exists a unique morphism ( )A : A ~ 1, We can think of a terminal object aa a nullary \nproduct; in particular, A x 1 % A for any object A. In Set, the categori\u00ad cal product of two objects \nis actually their cartesian product with the obvious projections and pairing; any one-element set is \nterminal. As often happens, we can dualize these definitions by reversing the direction of all arrows. \nThus, a coproduct of A and B consists (of an object A+B and two injections inl:A-A +Bamdinr:B+A +B, such \nthat for any object C and morphisms f :A * C and g :B ~ C there exists a unique casin~ morphism [f, g] \n: A+ B --i C satisfying [f, g]oinl = f and [f, g]oinr = g. Again, we can express uniqueness as the equation \n[hoinl, hoinr] = h for all h : A + B -~ C. An object is initial if for every object A, there exists a \nunique morphism []A :0-A; an initial object is a degenerate coproduct: A + O Z A. In Set, the disjoint \n(i. e., tagged) union of two sets is their coproduct; the empty set is the only initial object. Category \ntheory also provides a natural abstraction of higher-order functions: an exponential of two objects B \nand C consists of an object B ~ C and an appli\u00adcation morphism ap : (B 3 C) x B * C such that any morphism \nf : A x B h C has a unique curried form cur(f) : A -+ B ~ C with the property that ap o (cur( f ) ofst, \nsnd) = f. Here, the uniqueness equa\u00adtion is cur(apo (gofst, snd)) = g for all g : A ~ B+-C. In Set, A \n> B is the function space B A together with the expected interpretations of application and curry\u00ading. \nA category which has all finite products is called carte sian. If it also has all exponentials, it is \ncalled cartesian closed, commonly abbreviated to CCC. A functor F : C * D from a category C to a cat\u00adegory \nD is a mapping from C-objects A to D-objects F(A) and C-morphisms f : A a B to D-morphisms F(f) : F(A) \n~ F(B), respecting identity and composi\u00adtion (i. e., F(idA) = idF(AJ and F(fog) = Fob). For example, \nthe functor list : Typ + Typ maps a type A to the type iist(A) and a function f : A -B to the function \nrnaplist( f ) : list(A) j iist(l?). The definition generalizes easily to functors of several argu\u00adments; \nin particular, a functor of two variables is often called a bifunctor. The binary products and coproducts \ndefined above can be viewed as bifunctors if we define their actions on morphisms as f x g = (f o fst, \ng o snd), and f +g = [inlo f, inrog]. The exponential is also a bi\u00adfunctor, but is contravariant (reverses \narrow direction) in its first argument. A natural transformation ~ : F ~ G between two functors F, G \n: C ~ D is a collection, indexed by C\u00adobjects X, of D-morphisms qX : F(X) ~ G(X) such that for any c-morphism \nf : A -B, q~ o F(f) = G(f) O qA : F(A) ~ G(B). To a first approxima\u00adtion, we can think of natural transformations \nin a programming language setting as polymorphic func\u00adtions. For example, consider the type-indexed collec\u00adtion \nof functions ~iattenA : tree(A) ~ list(A). If .zerop : int -+ bool, is a function, naturality ensures \nthat fiattenbool o rnaptree(zerop) = rnaplist(zerop) o f Zatt enint : tree (int) ~ list(bool). (Unfortunately, \nthis analogy does not extend directly to higher-order func\u00adtions. ) A natural isomorphism is a natural \ntransforma\u00adt ion, all of whose components are isomorphisms. Finally, a functor F : C -+ D has a right \nadjoint G : D -C (or, equivalently, G has a lefl adjoint F) if there exists a natural transformation \nex : F(G(X)) -+ X (the counit of the adjunction) such that for every D-morphism f : F(A) -t B, there \nexists a unique C\u00admorphism f* : A -+ G(B) satisfying s~ o F(f*) = f. For example, for a given object \nC, the functor F(X) = X x C has the right adjoint G(Y) = C ~ Y. &#38;B is the morphism ap : (C + B) x \nC e B, and for any func\u00adtion f : A x C -+ B, there exists a unique morphism f* = cur(f) : A ~ C*B satisfying \napo(fl xidC) = f. Many of the other categorical definitions above (prod\u00aducts, coproducts, initial and \nterminal objects) are also examples of adjoint situations.  \n\t\t\t", "proc_id": "143165", "abstract": "<p>We present a functional interpretation of classical linear logic based on the concept of <italic>linear continuations</italic>. Unlike their non-linear counterparts, such continuations lead to a model of control that does not inherently impose any particular evaluation strategy. Instead, such additional structure is expressed by admitting closely controlled copying and discarding of continuations. We also emphasize the importance of classicality in obtaining computationally appealing categorical models of linear logic and propose a simple &#8220;coreflective subcategory&#8221; interpretation of the modality &#8220;!&#8221;.</p>", "authors": [{"name": "Andrzej Filinski", "author_profile_id": "81100252096", "affiliation": "", "person_id": "PP39071753", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143174", "year": "1992", "article_id": "143174", "conference": "POPL", "title": "Linear continuations", "url": "http://dl.acm.org/citation.cfm?id=143174"}