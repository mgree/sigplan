{"article_publication_date": "02-01-1992", "fulltext": "\n Bounded Quantification is Undecidable Benjamin C. Pierce School of Computer Science Carnegie Mellon \nUniversity Pittsburgh, PA 15213-3890, USA bcp@cs. cmu. edu Abstract F< is a typed ~-calculus with subtyping \nand bounded se~ond-order polymorphism. First proposed by Cardelli and Wegner, it has been widely studied \nas a core calcu\u00adlus for type systems with subtyping. Curien and Ghelli proved the partial correctness \nof a recursive procedure for computing minimal types of F< terms and showed that the termination of this \nproc~\u00addure is equivalent to the termination of its major com\u00adponent, a procedure for checking the subtype \nrelation between F< types. This procedure was thought to ter\u00adminate on ~11 inputs, but the discovery \nof a subtle bug in a purported proof of this claim recently reopened the question of the decidability \nof subtyping, and hence of typechecking. This question is settled here in the negative, using a reduction \nfrom the halting problem for two-counter Turing machines to show that the subtype relation of F< is undecidable. \n 1 Introduction The notion of bounded quantification was introduced by Cardelli and Wegner [16] in the \nlanguage Fun. Based on informal ideas by Cardelli and formalized using tech\u00adniques developed by Mitchell \n[11, 30], Fun integrated Girard-Reynolds polymorphism [25, 33] and Cardelli s first-order calculus of \nsubtyping [7, 8]. Fun and its relatives have been studied extensively by programming language theorists \nand designers. Cardelli and Wegner s survey paper gives the first programming examples using bounded \nquantification; more are de\u00adveloped in Cardelli s study of power kinds [9]. Curieu Permission to copy \nwithout fee all or part of tils material is granted provided thnt the copies are not mule or distributed \nfor direet commercial advantage, the ACM copyright notice nnd the title of the publication and its date \nappear, and notice is given that copying is by permission of the Association for Computing Machinery. \nTo copy other\u00adwise, or to republish, requires a fee and/or specific permission. @ 1992 ACM 089791453-81921000110305 \n$1.50 305 and Ghelli [20, 23] address a number of syntactic prop\u00ad erties of F<. Semantic aspects of \nclosely related sys\u00ad tems have been studied by Bruce and Longo [3], Mar\u00ad tini [29], Breazu-Tannen, Coquand, \nGunter, and Sce\u00ad drov [1], Cardone [17], Cardelli and Longo [13], Cardelli, Martini, Mitchell, and Scedrov \n[14], and Curien and Ghelli [20, 21]. F< has been extended to include record types and richer notions \nof inheritance by Cardelli and Mitchell [15], Bruce [2], Cardelli [12], and Canning, Cook, Hill, Olthoff, \nand Mitchell [5]; an extension with intersection types [19, 34] is the subject of the present author \ns Ph.D. thesis [32]. Bounded quantifi\u00adcation also plays a key role in Cardelli s programing language \nQuest [10, 13] and in the Abel language devel\u00adoped at HP Labs [4, 5, 6, 18]. The original Fun was simplified \nby Bruce and Longo [3], and again by Curien and Ghelli [20]. Curien and Ghelli s formulation, called \nminimal Bounded Fun or F< ( F sub ), is the one considered here.  Like other second-order A-calculi, \nthe terms of F< in\u00adclude variables, abstractions, applications, type abs~rac\u00adtions, and type applications, \nwith the refinement that each type abstraction gives a bound for the type variable it introduces and \neach type application must satisfy the constraint that the argument type is a subtype of the bound of \nthe polymorphic function being applied. The well-typed terms of F< are defined by means of a col\u00adlection \nof rules (sum~arized in Figure 1) for inferring statements of the form 17 t-e ~ r ( e has type T in context \nI ). Variables, abstractions, and applications have the rules familiar from other )-calculi (rules VAR, \nABS, and APP). Type abstractions (rule TABs) declare a bound, with respect to the subtype relation, for \nthe variable they introduce; they are checked by moving this assumption into the context and checking \nthe body of the abstraction under the enriched set of assumptions. Type applications (rule TAPP) check \nthat the type be\u00ading passed as a parameter is indeed a subtype of the bound of the polymorphic value \nin the function posi\u00adtion. Finally, like other ~-calculi with subtyping, F< rtz~r(z) (VAR) r:r<r (REFL) \nI , a501-ecr (TABs) r 1-Aase. e E QcY50. T I i-eeu rkU<T (SUB) I Eeer Figure 1: Typing rules includes \na rule of subsumption, which allows the type of a term to be promoted to any supert ype (rule SUB). The \nrules TAPP and SUB rely on a separately ax\u00adiomatized subtype relation 1? 1-a < ~ ( a is a sub\u00adtype of \n~ under assumptions I ). This relation, which forms our main object of study, is summarized in Fig\u00adure \n2. Subtyping is both reflexive and transitive (rules REFL and TRANS). Every type is a subtype of a max\u00adimal \ntype called Top (rule TOP). Type variables are subtypes of their bounds (rule TVAR). The subtype relation \nbetween arrow types is contravariant in their left-hand sides and covariant in their right-hand sides \n(rule ARROW). Similarly, subtyping of quantified types is contravariant in their bounds and covariant \nin their bodies (rule ALL). The last rule deserves a closer look, since it is the pri\u00admary cause of the \ndifficulties we will be discussing for the rest of the paper. Intuitively, it reads as follows. A type \n~ ~ VaS~l. r2 describes a collection of poly\u00admorphic values (functions from types to values), each mapping \nsubtypes of ~1 to instances of T2. If ~1 is a subtype of al, then the domain of r is smaller than that \nof u ~ VCY<al, CT2, so r is a weaker constraint and describes a larger collection of polymorphic values. \nMoreover, if, for each type 6 that is an acceptable argu\u00adment to the functions in both collections (i. \ne., one that satisfies the more stringent requirement 0 < ~1), the 19\u00adinstance of ~2 is a subtype of \nthe O-instance of T2, then r is a pointwise weaker constraint and again describes a larger collection \nof polymorphic values. Though semantically appealing, this rule creates seri\u00adous problems for reasoning \nabout the subtype relation. In a quantified type Vcr5u1. 1.72,instances of a in 02 are rku <Top (ToP) \nrt-a <r(a) (TVAR) Figure 2: Subtyping rules naturally thought of as being bounded by their lexically \ndeclared bound al. But this connection is destroyed by the second premise of the quantifier subtyping \nrule: when dcr<ul. U2 is compared to ViYST1. T2, instances of ~ in both U2 and T2 are bounded by T1 in \nthe premise I , a< T1 E U2 < T2. As we shall see, this re-bounding behavior is powerful enough to allow \nundecidable prob\u00adlems to be encoded as subtyping statements. Cardelli and Wegner s definition of Fun \n[16] used a weaker quantifier subtyping rule in which VCY5U1. V2 is a subtype of VCY5T1. T2 only when \nal and rl are identi\u00adcal. (This variant can easily be shown to be decidable.) Later authors, including \nCardelli, have chosen to work with the more powerful formulation given here. Curien and Ghelli used a \nproof-normalization argu\u00adment to show that F< typechecking is coherent that is, that all derivation= \nof a statement J7 F e ~ r have the same meaning, under certain assumptions about the se\u00admantic interpretation \nfunction. One corollary of their proof is the soundness and completeness of a natural syntax-directed \nprocedure for computing minimal typ\u00adings of F< terms, with a subroutine for checking the subtype r~lation; \nthe same procedure had been devel\u00adoped by the group at Penn and by Cardelli for use in his Quest typechecker \n[26]. The termination of Curien and Ghelli s typechecking procedure is equivalent to the termination \nof the subtyping algorithm. Ghelli, in his Ph.D. thesis [23], gave a proof of termination; unfortu\u00adnately, \nthis proof was later discovered by Curien and Reynolds, independently to contain a subtle mistake (see \n[31]). In fact, Ghelli soon realized that there are inputs for which the subtyping algorithm does not \nter\u00adminate [24]. Worse yet, these cases are not amenable to any simple form of cycle detection: when \npresented with one of them, the algorithm would generate an in\u00adfinite sequence of recursive calls with \nlarger and larger contexts. This discovery reopened the question of the decidability of ~<. The undecidab~lity \nresult presented here began as an attempt to formulate a more refined algorithm capa\u00adble of detecting \nthe kinds of divergence that could be induced in the simpler one. A series of partial results about decidable \nsubsystems eventually led to the discov\u00adery of a class of input problems for which increasing the size \nthe input by a constant factor would increase the search depth of a succeeding execution of the algorithm \nbyanexponential factor. Besides dispelling previous in\u00adtuitions about why the problem ought to be decidable, \nthis construction suggested a trick for encoding natural numbers, from which it was a short step to an \nencoding of two-counter Turing machines. After formally defining the F< subtype relation (Sec\u00adtion 2), \nreviewing Curien and ~helli s subtyping algo\u00adrithm (Section 3), and presenting an example where the algorithm \nfails to terminate (Section 4), we identify a fragment of F< that forms a convenient target for the re\u00adductions \nto follow (Sections 5 and 6). The main result is then presented in two steps. We first define an interme\u00addiate \nabstraction, called rowing machines (Section 7); these bridge the gap between F< subtyping problems and \ntwo-counter machines by reiaining the notions of bound variables and substitution from F< while intro\u00adducing \na computational abstraction with a finite col\u00adlection of registers and an evaluation regime based on \nstate transformation. An encoding of rowing machines as F< subt yping statements is given and proven \ncorrect, in the sense that a rowing machine R halts iff its trans\u00adlation Y (R) is a derivable statement \nin F< (Section 8). We then review the definition of two-counter machines (Section 9) and show how a two-counter \nmachine T may be encoded as a rowing machine R(T) such that T halts iff 7?(T) does (Section 10). Section \n11 shows that the undecidability of subtyping implies the undecidability of typechecking. Section 12 \nbriefly discusses the prag\u00admatic import of our results. Full proofs, omitted here to save space, may \nbe found in an accompanying technical report [31]. In all cases, they proceed either by structural induction \non deriva\u00adtions or by straightforward calculation from the defini\u00adt ions. 2 The Subtype Relation We \nbegin the detailed development of the undecidability of F< by establishing some notational conventions \nand defin~ng the subtype relation formally. 2.1. Notation: We write X = Y, where X and Y are types, contexts, \nstatements, etc., to indicate that X has the form Y . If Y contains free metavariables, then X = Y denotes \npattern matching; for example If ~ = da<~l. rz, then . .. means If ~ has the form VCiST1. 72 for some \na, rl, and T2, then . . . 2.2. Definition: The types of F< are defined by the following abstract grammar: \n.. T .. a I T1+72 I VaS~l. 72 I Top 2.3. Definition: Typing contexts in F< are lists of type variables \nand associated bounds, r ::= {} I r, Q5T with all variables distinct. (To deal formally with the F< \ntyping relation, we would also need bindings of the fo~m z :~.) The comma operator is used to denote \nboth extension (r, aS ~) and concatenation (1 1, 1 2 ) of con\u00adtexts. The set of variables bound by a \ncontext I is written dom(I ). When r ~ I?l, a<r, I z, we call T the bound of a in 17 and write T = r(a). \n2.4. Definition: A subtyping statement is a phrase of the form r F u < r. The portion of a statement \nto the right of the turnstile is called the body. 2.5. Definition: The set of free type variables in \na type r is written FTV(r). A type r is closed with respect to a context r if FTV(~) c dom(17). A context \nI is closed if r s {}, or r ~ rl, a<~, with 171 closed and ~ closed with respect to 171. A statement \n1 F u < r is closed if 17 is closed and a and r are closed with respect to r. In the following, we assume \nthat all statements under discussion are closed. In particular, we allow only closed statements in instances \nof inference rules. 2.6. Convention: The metavariables O, r, L9, and d range over types; a, ,L?,and y \nrange over type variables; I ranges over contexts; J ranges over (closed) state\u00adments. 2.7. Definition: \nF< is the least three-place relation closed under the subtyping rules in Figure 2. 2.8. Convention: Types, \ncontexts, and statements that differ only in the names of bound variables are con\u00adsidered to be identical. \n(In a statement 1 1, o@, rz 1\u00ada < ~, the variable a is bound in l?2, a, and r.) 2.9. Definition: The \ncapture-avoiding substitution of u for a in ~ is written {a/a}r. Substitution is extended pointwise to \ncontexts: {~i~}r. 2.10. Definition: The positive and negative occur\u00adrences in a statement 17 F u < r \nare defined as fol\u00adlows. The type u and the bounds in 17 are negative occurrences; T is a positive occurrence. \nIf rl +Tz k a positive (resp. negative) occurrence, then TI is a nega\u00ad tive (positive) occurrence and \nrz is a positive (negative) occurrence. If Va< rl. TZ is a positive (resp. negative) occurrence, then \nT1 is a negative (positive) occurrence and TZ is a positive (negative) occurrence. 2.11. Fact: The rules \ndefining F< preserve the signs of occurrences: wherever a metavar~able ~ appears in a premise of one \nof the rules, it has the same sign as the corresponding occurrence of T in the conclusion. 2.12. Definition: \nIn the examples below, it will be convenient to rely on a few abbreviations: dCY. T % Va< Top. ~ Qa15~l..cYn5#n. \nT % vcx151#J1. .. Van<lpn. T 2 v a<~. (-J -7- The salient property of the last of these is that it allows \nthe right-and left-hand sides of subtyping state\u00adments to be swapped: 2.13. Fact: r 1---m < w is derivable \niff r t-r < a is.   3 A Subtyping Algorithm The rules defining F< do not constitute an algorithm for \nchecking the sub~ype relation, since they are not syntax-directed. In particular, the rule TRANS cannot \neffectively be applied backwards, since this would in\u00advolve guessing an appropriate intermediate type \nr2. Curien and Ghelli (as well as Cardelli and others) use the following reformulation: 3.1. Definition: \nF? (N for normal form) is the least relation closed under-the following rules: rko <Top (NToP) (NVAR) \nThe reflexivity rule here is restricted to type variables. Transitivity is eliminated, except for instances \nof the following form, which are hidden in instances of the new rule NVAR: r~a<r(a) rFr(a)<~ rtcx~r 3.2. \nLemma: [Curien and Ghelli] The relations F< and F? coincide: r 1-a < ~ is derivable in F< iff it is \nderivable in F?. 3.3. Definiti~n: The rules defining F$ may be read as an algorithm (i.e., a recursively \ndefine~ procedure, not necessarily always terminating) for checking the subtype relation. We write F? \nto refer either to the algorithm or to the inference sy~tem, depending on context. The algorithm F? maybe \nthought of as incrementally attempting to build a normal form derivation of a state\u00adment J, starting \nfrom the root and recursively building subderivations for the premises. By Lemma 3.2, if there is any \nderivation whatsoever of a statement J, there is one in normal form; the algorithm is guaranteed to re\u00adcapitulate \nthis derivation and halt in finite time. 4 Nontermination of the Algo\u00adrithm Ghelli recently dispelled \nthe widely held belief that the algorithm F: terminates on all inputs, by discovering the followin~ example. \n4.1. Example: Let O = Va. =(V@Sa. 7P). Then executing the algorithm F~ on the input problem CYOa!-0!0 \n< (Val% o. --ml) leads to the following infinite sequence of recursive calls: Cyo<o 1-@o < Vcll<cro. \n~al ~Og 1-Val. m(vazsal. -l@z) < valscxo. -ml al)<o, alsao h -l(vcrz<al. -laz) < -la~ al)so, C21<flo \nE al < VCY25(21. YY2 0!()<0, CYl<ao t-CYo < vcrz<a!~. -w-Y etc. (The a-conversion steps necessary to \nmaintain the well-formedness of the context when new variables are added are performed tacitly here, \nchoosing new names so as to clarify the pattern of infinite regress.)  5 A Deterministic Fragment The \npattern of recursion in Ghelli s example is an in\u00adstance of a more general scheme one so general, in \nfact, that it can be used to encode termination prob\u00adlems for two-counter Turing machines. We now turn \nto demonstrating this fact. 5.1. Fact: The rules defining F< preserve the signs of occurrences: wherever \na met ava~iable r appears in a premise of one of the rules, it has the same sign as the corresponding \noccurrence of r in the conclusion. In what follows, it will be convenient to work with a fragment of \nF: with somewhat simpler behavior: we drop the + typ; constructor and its subtyping rule; we int reduce \na negation operator explicitly into the syn\u00adtax and include a rule for comparing negated expres\u00adsions; \nwe drop the left-hand premise from the rule for comparing quantifiers, requiring instead that when two \nquantified types are compared, the bound of the one on the left must be Top; and we consider only statements \nwhere no variable occurs positively, allowing us to drop the NREFL rule. Since the F? rules preserve \npositive and negative occurrences, we-may redefine the set of types so that positive and negative types \n(i.e. those that appear in positive and negative positions) are separate syntactic categories. At the \nsame time, we simplify each category appropriately. 5.2. Definition: The sets of positive types r+ and \nnegative types r-are defined by the following abstract grammar: A negative context 17\u00adis one whose bounds \nare all neg\u00ad ative types. 5.3. Definition: F< (P for polarized) is the least relation closed under t%e \nfollowing rules: r\u00ad k T\u00ad ~ TOp (PToP) F: is almost the system we need, but it still lacks one imp~rt \nant property: F< is not a conservative extension of F+. For example, tie non-derivable F: statement k \n~Top < Va<Top. a corresponds, under the abbreviation for m, to the deriv\u00adable F< statement To achieve \nconservativity, we restrict the form of F: statements even further so that negated types can neve>. be \ncompared with quantified types. 5.4. Definition: Let n be a fixed nonnegative number. The sets of n-positive \nand n-negative types are defined by the following abstract grammar: ~+ ;:= Top I VaOSro-.. anST; . -T-T \n::=(Y I Va 1) ..a n. W+ We stipulate, moreover, that an n-positive type VC%)STO-.. %srn- r is closed \nonly if no ai appears free in any r~. An n-negative context is one whose bounds are all m negative types. \n5.5. Convention: To reduce clutter, we drop the su\u00adperscripts + and and leave n implicit in what follows. \n5.6. Definition: F: (D for deterministic) is the least relation closed unde~ the following rules: rl-T~Top \n(DToP) r ~ v~o.. CIn. 7(7 < VO!O<TO.. O!n<Tn. ?T (DALLNEG) Using the earlier abbreviations for negation, \nmultiple quantification, and unbounded quantification, we may read every F? statement as an F: statement. \nUnder this interpretation, the two subt y~e relations coincide for statements in their common domain: \n5.7. Lemma: F? is a conservative extension of F<: if J is an F~ stateriient, then J is derivable in F; \niff-it is derivable~n F~. These simplifications justify a useful change of per\u00adspective. Since the only \nrule in F&#38; with two premises has been replaced by a rule with ~ne premise, deriva\u00adtions in this fragment \nare linear (each node has at most one sub derivation). The syntax-directed construction of such a derivation \nmay be viewed as a deterministic state transformation process, where the subt yping st ate\u00adment being \nverified is the current state and the single premise that must be recursively verified (if any) is the \nnext state. In other words, a subtyping statement is thought of as an instantaneous description of a \nkind of automaton. From now on we use terminology that makes the in\u00adtuition of (subtyping as state transformation \nmore ex\u00adplicit. Analogous terminology and notation will be used to describe the execution behavior of \nthe other calculi introduced below. 5.8. Definition: The one-step elaboration function for F<-statements \nis the partial mapping defined by: J if J is the conclusion of an in\u00adstance of DVAR or DALLNEG E(J) = \nand J! is the corresponding premise undef. if J is an instance of DToP.  [ J is an immediate subproblem \nof J in Ff, written J *D J , if J = S(J). J is a subprobl;m of J in F~, written J 2D J , if either J \ns J or J -D J1  and J1 2D J1. The elaboration of a statement J is the sequence of subproblems encountered \nby the subtyping algorithm given J as input.  6 Eager Substitution To make a smooth transition between \nthe subtyping statements of F< and the rowing machine abstraction to be introduced i; Section 7, we need \none more variation in the definition of subtyping, where, instead of main\u00adtaining a context with the \nbounds of free variables, the quantifier rule immediately substitutes the bounds into the body of the \nstatement. 6.1. Definition: The simultaneous, capture-avoiding substitution of do through @n, respectively, \nfor a. through am in ~, is written {@O/aO . @n/an} ~. 6.2. Definition: F< (F for flattened) is the least \nrelation closed u-rider the following rules: I-r <Top (FToP) ~ {40/Q o..471/%}~ s {f#o/@o ..&#38;/G} \nfJ b v CYo- la < ..ansq5n. ..o!n. ~ T  VCYoq)o (FALLNEG) 6.3. Remark: Of course, an analogous reformulation \nof full F < would not be correct. For exalnple, in the non-derivable statement substituting Top for a \nin the bodies of the quantifiers yields the derivable statement h Top < Top. But having restricted our \nattention to statements where variables appear only negatively, we are guaranteed that the only position \nwhere the elaboration of a statement can cause a variable to appear by itself in the body of a subprob\u00adlem \nis on the left-hand side, where it will immediately be replaced by its bound. We are therefore safe in \nmaking the substitution eagerly. 6.4. Lemma: F? k a conservative extension of F<.  7 Rowing Machines \nThe reduction from two-counter Turing machines to F< subtyping statements is easiest to understand in \nterms of an intermediate abstraction called a rowing machine that makes more stylized use of bound variables. \nA rowing machine is a tuple of registers (Pl Pn), where the contents of each register is a row. By conven\u00adtion, \nthe first register is the machine s program couwter (or PC). To move to the next state, the PC is used \nas a template to construct the new contents of each of the registers from the current contents of all \nof the registers (including the PC). 7.1. Definition: The set of rows (of width n) is defined by the \nfollowing abstract grammar: .._ .. forl<m~n j ;:..an](pl ,,pn) I HALT P The variables al. .crn in [al. \nan] (pl. .pn ) are binding oc\u00adcurrences whose scope is the rows pl through pn. We regard rows that differ \nonly in the names of bound vari\u00adables as identical. 7.2. Definition: A rowing machine (of width n) is \na tuple (pl. .pn ), where each pi is a row of width n with no free variables. 7.3. Definition: The one-step \nelaboration function E for rowing machines of width n is the partial mapping ({Pi/W ~~Pn/%}pll . . {p,/@l \n~~pn/%}Pln) if pl = [aI..CYn](pI1..pln) undefined if pl = HALT. ~((P1..Pn)) = I (Since rowing machines \nconsist only of closed rows, we need not define the evaluation function for the case where the PC is \na variable. Also, since all the pn are closed, the substitution is trivially capture-avoiding. ) 7.4. \nNotational conventions: When the symbol L{_>> appears as the ith component of a compound row [Q1..an](pl \n..pn), it stands for the variable CYi, To avoid a proliferation of variable names in the ex\u00adamples and \ndefinitions below, we sometimes use numeri\u00adcal indices (like deBruijn indices [22]) rather than names \nfor variables: the variable #n refers to the nth bound variable of the row in which it appears; ##n refers \nto the ~th bound variable of the row enclosing the one in which it appears; and so on. For example, the \nrow [al @3](~1, [@l .93](@1, 91, 83), al) would be abbrevi\u00ad ated ( , (##1, #l, ), #l). 7.5. Definition: \nA rowing machine R baits if there is a machine R such that R _%R R and the PC of R is the instruction \nHALT. 7.6. Example: The machine (LOOP, A, B), where LOOP a ( , #3, #2) A= an arbitrary row B an arbitrary \nrow executes an infinite loop where the contents of the sec\u00adond and third register are exchanged at \nsuccessive steps: (LOOP, A, B) -R (LOOP, B, A) -R (LOOP, A, B) R ... 7.7. Example: The row BR1 ~ (#2, \n) encodes an indirect branch to the contents of register 2 at the moment when BRI is executed. The machine \n(BRI, (BRI, (BRI, HALT))) elaborates as follows: {BRI, (BRI, (BRI, HALT))) -R ((BRI, (BRI, HALTI)), \n(EHu,(BRI,HALT)}) ---+R (BRI, (BRI, HALT)) ---+R ((BRI, HALT), (BRI, HALT)) -+R @RI) HALT) -+R (HALT, \nHALT).  8 Encoding Rowing Machines as Subtyping Problems We now show how a rowing machine R can be \nencoded as a subtyping problem Y(R) such that R halts iff $(R) is derivable in F<. The idea of th~ translation \nis that a rowing machine R = (pl. .pn ) becomes a subtyping statement such that if pl = HALT, the elaboration \nof 7(R) halts (by reaching a subproblem where Top appears on the right-hand side);  if pl = [al.. an] \n(pll..pln)) the elaboration of F(R)  reaches a subproblem that encodes the rowing ma\u00adchine ({Pi/W .. \nPm/@n} pll .. {pl/o!l ..pn/%}Pln). In more detail, if R = ([ CY1..Crn](pll ..plm) ..pn), then F(R) is \nessentially the following: t- Vyl ..-y~ . ++yjsyl . . y:syn. \\ .. < V-ii s+) ..-(nqf%). + al..an. + \no!jqp,,) . . cl~<f (p,n). -r(p,,))). The elaboration of this statement proceeds as follows: 1. The current \ncontents of the registers pl. p,, are tem\u00adporarily saved by matching the quantifiers on the right with \nthe ones on the left; this has the effect of substituting the bounds F(pl ) Y(pn ) for free occurrences \nof the variables 71. .~n on the left-hand side. The right-and left-hand sides are also swapped (by the \n-constructor on both sides), so that what now appears on the left is a sequence of variable bind\u00ad ings \nfor the free variables al. .ctn of pl. 2. The saved contents of the original registers now appear on \nthe right-hand side. When these are matched with the quantifiers on the left, the result is that the \nold values of the registers are substi\u00adtuted for the variables al . . an in the body of the left-hand \nside. Swapping right-and left-hand sides again yields a statement of the same form as the original, where \nthe appropriate instances of .F(pl 1) . . F(pln ) ap\u00adpear as the bounds of the outer quantifiers on the \nright: . .._ %ls{Y-(pi)/cYl . . f-(Pn)/%} fwl). ~~~{f(PI)/@l . 7(f%2)/&#38;} $(P1l) ~. . t-< (v-h s{qPl)/w \n. . qpn)/%} qpll) . . To be able to get back to a statement of the same form as the original, one piece \nof additional mechanism is required: besides the n variables used to store the old state of the registers, \na variable y. is used to hold the original value of the entire left-hand side of X(R). This variable \nis used at the end of a cycle to set up the left hand side of the statement encoding the next state of \nthe rowing machine. 8.1. Definition: Let p be a row of width n. The F<\u00adtranslation of p, written F(p), \nis the n-negative type\u00ad 3(a~) = ~i 7( HALT) =VYO, CY1 .. fin. 7TOP F([q.. an]{pl.. pn)) = v-fi), al \n. . an. --l (vy{<yo, Cijsx(fq) . . a~qpn). +)) where -yO, y~, and a; through a; are fresh variables. \n8.2. Fact: The free variables of F(R) coincide with those of R. 8.3. Definition: Let R = (pl ..pn) be \na rowing ma\u00adchine. The F< -translation of R, written X(R), is the F: statement\u00adt a < Vyosa,-y~sqp~) ,. \n~nsqpn). lF(p~), where ~ = V-fo, -) l..-fn. -+dy~syo, -(; s71 . . y~<yn. 170). 8.4. Lemma: If R -R R \n, then F(R) ~~ F(R ). Pl oofi By the definition of the elaboration function for rowing machines, R s \n(pl. .p~ ), where pl = [W..% I(P11..P172), and R ~ ({pi/CYI ..pn/C!n}pll . . {~1/@l ..~n/@n}~l~). Calculate \nas follows: F(R) El-u < Vyosa, Ylsqpl) . . l nsqPn). -@l) = E V-fo, -fl.. yn. ~(v7(Js70, 7;91 . YA%. \n70) < Vyosa, 71 S(P1) . . %2=(h). +%1) -~ 1-{(7/~Ll, F(pl )/yl . . Y (p. )/-) n} F(pl) < {0/70, ml )/71 \n. $ (Pn)/% } (vy~<yo, y{s~l . . yj$yn. =yll) = t-qpl) < V.f:so, y{<qpl) . . y~<~(pn). ~a = E-V-ye, al..an. \n+wls70j ~j=(pll) ~~~isf-(pin). +%1)) < vy~sa, -f; s$(pl) . . y~<z(pn). 1(7  F V-fo, Crl..an. -l(vj \nj<yo, a;< F(pl,) . . a~sz(p,n). +(pll)) < V-yosa, Q!lsqpl) . . CIni?-(pn). -la h {L7/-yo, F(pl)/al . \n. 7(pn)/cxn} a < {c7/yo, 7(p~)/cq 7(pn)/cMn} (w~ ) o> C4=(P11) ~~~;,~f (h) +@l)) F EU < vy;~u, 4 s \n({~(Pl)/% ~~qPn)/%}f_(Pll)) ~~ a: s ({ f_(fh)/w fG%A)/%}~(Pl n)). =({7(pl)/@ ~~F(Pn)/%} ~(fhl)) . . \n. to < v ycl~u, m s ({ fxPl)/w . ~(Pn)/%}HPll)) ~~ 7n < ({$(Pl)/% ~~~(Pn)/%} ~bhn)) l({qPl)/@ ~~$(Pn)/%} \nqpll)) = f(l? ). = 8.5. Lemma: If R E (HALT, p2..pn), then X(R) is derivable in F:. Proofi Simi~ar. \n= 8.6. Corollary: The rowing machine R halts iff 7(R) is derivable in F:.   Two-counter Machines \nThis section reviews the definition of two-counter Turing machines; see, e.g., Hopcroft and Unman [27] \nfor more details. 9.1. Definition: A two-counter machine is a tuple (PC, A, 1?, II ..IW ), where A and \n~ are nonnegative numbers and PC and 11 through IW are instructions of one of the forms: INCA~m INCB+m \nTSTA+m/n TSTB+m/n HALT. 9.2. Definition: The eiaboraticm function E for two\u00adcounter machines is the \npartial function mapping T = (PC, A, B, ll..IW) to (1~, A+l, B, ll..IW) if PC= INCA=WZ (Imj A, 13+1, \nll..lW) if PCE INCB=%Z (1~, A, B, ll.JW) if PC z mm+rn[n and A=O (in, A-l, B, ll..IW) if PC G TSTA~m/n \nS(T) = < and A>O (1~, A, B, ll..IW) if PCs TSTB=Wn/n and B=O (In, A, B-1, ll..IW) if PC G TSTB+m/n and \nB>O undefined if PC= HALT. \\  9.3. Definition: A two-counter machine T halts if T ~~ T for some machine \nT ~ (HALT, A , B , ll..L). 9.4. Fact: The halting problem for two-counter ma\u00ad chines is undecidable. \nProof sketch: Hopcroft and U1lman [27, pp. 171-173] show that a similar formulation of two-counter machines \nis Turing-equivalent. (Their two-counter machines have test instructions that do not change the contents \nof the register being tested and separate decrement instruc\u00adtions. It is easy to check that this formulation \nand the one used here are inter-encodable. ) = 10 Encoding Two-counter Ma\u00adchines as Rowing Machines We \ncan now finish the proof of the undecidability of F< subtyping by showing that any two-counter machine \nT can be encoded as a rowing machine R(T) such that T halts iff R(T) does. The main trick of the encoding \nlies in the represen\u00adtation of natural numbers as rows. Each number n is encoded as a program (i.e., \na row) that, when exe\u00adcuted, branches indirectly through one of two registers whose contents have been \nset beforehand to appropri\u00adate destinations for the zero and nonzero cases of a test; in other words, \nn encapsulates the behavior of the test instruction on a register containing n. The increment operation \nsimply builds a new program of this sort from an existing one. The new program saves a pointer to the \npresent contents of the register in a local variable so that it can restore the old value (i.e., one \nless than its own value) before executing the branch. The encoding 7?(T) of a two-counter machine T E \n(PC, A, B, II. .IW ) comprises the following registers: #1 7? (P(7) #2 I?;(A) #3 R&#38;(B) #4 address \nregister for zero branches #5 address register for nonzero branches #6 I? (II) #6+w-1 7V (1W). We use \nfour translation functions for the various com\u00adponents: 7?(T) is the encoding of a the two-counter ma\u00adchine \nT as a rowing machine of width w + 5; %?W(Q is the encoding of a two-counter instruction I as a row of \nwidth w + 5; R~ (n) is the encoding of the natural numb er n, when it appears as the contents of register \nA, as a row of width w + 5; X?fi(n) is the encoding of the natural number n, when it appears as the contents \nof register B, as a row of width w + 5. 10.1. Definition: The row-encoding (for w instruc\u00adtions) of a \nnatural number n in register A, written 7i?~ (n), is defined as follows: %?:(0) = (#4, , , HALT, HALT, \n~ ; ,) w times ~~(n+l) = (#5, ~~(n), , HALT, HALT, . ~ ,) w times The row-encoding (for w instructions) \nof a natural num\u00adber n in register B, written X3% (n), is defined as follows: n%(o) = (#4, , , HALT, \nHALT, ~ ~ /) w times ~~(n+l) = (#5, , %?&#38;(n), HALT, HALT, . ~ ,) w times 10.2. Definition: The row-encoding \n(for w instruc\u00adtions) of an instruction 1, written 7ZW(1), is defined as follows: 72 (INcA*rn) = (#m+5, \n(#5, ##2, , HALT, HALT, . . --), --, HALT, HALT, . . ) 7? (INCB*m) = (#m+5, , (#5, , ##3, HALT, HALT, \n . . ), HALT, HALT, . . ) 7?w(TSTA>m/n) = (#2, , , #m+5, #n+5, . . ) %?W(TsTB+m/n) = (#3, , , #m+5, \n#n+5, .. ) 7ZW(HALT) = (HALT, , , HALT, HALT, . . ). 10.3. Definition: Let T s (PC, A, B, ll..IW) \nbe a. two-counter machine. The row-encoding of T, written X?(T), is the rowing machine of width w+5 defined \nas follows: 7?(T) = (7?W(PC), 7Z~(A), Rfi(B), HALT, HALT, XW(]I) .. ~w(~w)) 10.4. Lemma: IfT +~ T , then \nR(T) ~R 7Z(7 ). Proofi Straightforward. 1 10.5. Lemma: If T = (HALT, A, B, ll..IW), then 7?(T) halts. \nProofi Immediate. = 10.6. Corollary: T halts iff 7?(T) does. 10.7. Theorem: The F< subtyping relation \nis unde\u00ad  cidable. Proof: Assume, for a contradiction, that we had a total-recursive procedure for testing \nthe derivability of subtyping statements in F<. Then to decide whether a two-counter machine T halts, \nwe could use this pro\u00adcedure to test whether 7(7?(T)) is derivable, since T halts iff 7?(T) halts (by \nCorollary 10.6), iff 7(7?(T)) is derivable in F: (by Corollary 8.6), iff F(7?(T)) is deriv\u00adable in F? \n(bj Lemma 6.4) iff Y(7?(T)) is derivable in F: (by L~mma 5.7), iff 7(7?(T)) is derivable in F< (by L=mma \n3.2). =  11 Typechecking From the undecidability of F< subtyping, the undecid\u00adability of typechecking \nfollo&#38; immediately: we need only show how to write down a term that is well typed iff a given subtyping \nstatement 1-a < ~ is derivable. One such term is ~~:~~ Top. Aa:m. f a. 12 Conclusions The undecidability \nof F< will perhaps surprise many of those who have studied~extended, and applied it since its introduction \nin 1985. But it may turn out that lan\u00adguage designs and implementations based on F< will not be greatly \naffected by this discovery, since the algo\u00adrithm has been used for several years now without any sign \nof misbehavior in any situation arising in practice. Indeed, constructing even the simplest nonterminating \nexample requires a contortion that is difficult to imagine anyone performing by accident. Moreover, a \nnumber of useful fragments of F< are easily shown to be decidable. For example: \u00ad The prenex fragment, \nwhere all quantifiers appear at the outside and quantifiers are instantiated only at monotypes.  A predicative \nfragment where types are stratified into universes and the bound of a quantified type lives in a lower \nuniverse than the quantified type itself,  Cardelli and Wegner s original formulation where the bounds \nof two quantified types must be identi\u00adcal in order for one to be a subtype of the other.  Acknowledgements \n1 am grateful for productive discussions with John Reynolds, Robert Harper, Luca Cardelli, Giorgio Ghelli, \nDaniel Sleator, and Tim Freeman. References [1]Val Breazu-Tannen, Thierry Coquand, Carl Gunter, and \nAndre Scedrov. Inheritance as implicit coercion. Information and Computation, 93:172 221, 1991. [2] Kim \nB. Bruce. The equivalence of two semantic definitions for inheritance in object-oriented lan\u00adguages. \nIn Proceedings of Mathematical Founda\u00adtions of Programming Semantics, Pittsburgh, PA, March 1991. To \nappear. [3] Kim Bruce and Giuseppe Longo. A modest model of records, inheritance, and bounded quantifica\u00adtion. \nIn Proceedings of the IEEE Symposium on Logic in Computer Science, pages 38-50, 1988. [4] Peter Canning, \nWilliam Cook, Walt Hill, and Walt\u00ader Olthoff. Interfaces for strongly-typed object\u00adoriented programming. \nIn Object Oriented Pro\u00adgraming: Systems, Languages, and Applications (Conference Proceedings), [5] Peter \nCanning, William Olthoff, and John Mitchell. tion for object-oriented International Conference ming Languages \nand Computer Architecture, 273-280, September 1989. [6] Peter Canning, Walt Hill, and Walter A kernel \nlanguage for object-oriented ming. Technical Report Packard Labs, 1988. [7] Luca Cardelli. A semantics \n[n G. Kahn, D. MacQueen, Semantics of Data Types, Notes in Computer Science, Verlagl 1984. [8] Luca Cardelli. \nA semantics Information and Computation, [9] Luca Cardelli. Structural pages 457-467, f989. Cook, Walter \nF-bounded programming. on Functional STL-88-21, of multiple inheritance, and G. Plotkin, editors, volume \n173 of Lecture pages 51 67. Springer\u00ad of multiple inheritance. 76:138 164, 1988. subtyping tion of power \ntype. In Proceedings ACM Symposium on Principles of Languages, pages 70 79, San Diego, 1988. [10] Luca \nCardelli. Typeful programming. port 45, Digit al Equipment Corporation, Research Center, Palo Alto, California, \n1989. Hill, Walter quantifica-In Fourth Progranl,\u00adpages Olthoff. program-Hewlett\u00ad and the no\u00adof the 15th \nProgramming CA, January Research Re-Systems February [11] [12] [13] [14] [15] [16] [17] [18] [19] [20] \n[21] [22] Luca Cardelli, 1991. Personal Communication. Luca Cardelli. Extensible records in a pure calculus \nof subtyping. To appear, 1991. Luca Cardelli and Giuseppe Longo. A semantic basis for Quest: (Extended \nabstract). In ACM Conference on Lisp and Functional Programming, pages 30 43, Nice, France, June 1990. \nExtended version available as DEC SRC Research Report 55, Feb. 1990. Luca Cardelli, Simone Martini, John \nC. Mitchell, and Andre Scedrov. An extension of system F with subt yping. In Ito and Meyer [28], pages \n750 770. Luca Cardelli and John Mitchell, Operations on records (summary). In M. Main, A. Melton, M. \nMislove, and D. Schmidt, editors, Proceedings of Fifth International Conference on Mathemati\u00adcal Foundations \nof Programming Language Seman\u00adtics, volume 442 of Lecture Notes in Computer Sci\u00adence] pages 22 52, Tulane \nUniversity, New Orleans, March 1989. Springer Verlag. To appear in Mathe\u00admatical Structures in Computer \nScience; also avail\u00adable as DEC Systems Research Center Research Report #48, August, 1989. Luca Cardelli \nand Peter Wegner. On understanding types, data abstraction, and polymorphism. Com\u00adputing Surveys, 17(4), \nDecember 1985. Felice Cardone. Relational semantics for recursive types and bounded quantification. In \nProceedings of the Sixteenth International Colloquium on Au\u00adtomata, Languages, and Programming, volume \n372 of Lecture Notes in Computer Science, pages 164 178, Stress, Italy, July 1989, Springer-Verlag. William \nR. Cook, Walter L. Hill, and Peter S. Canning. Inheritance is not subtyping. In Sev\u00adenteenth Annual ACM \nSymposium on Principles of Programming Languages, pages 125 135, San Fran\u00adcisco, CA, January 1990. M. \nCoppo, M. Dezani-Ciancaglini, and B. Ven\u00adneri. Principal type schemes and lambda calculus semantics. \nIn To H. B. Curry: Essays on Com\u00adbinatory Logic, Lambda Calculus, and Forma iism, pages 535 560, New \nYork, 1980. Academic Press. Pierre-Louis Curien and Giorgio Ghelli. Coherence of subsumption. Mathematical \nStructures in Com\u00adputer Science, 1991. To appear. Pierre-Louis Curien and Giorgio Ghelli. Subtyping + \nextensionality: Confluence of ~rpreductions in F<. In Ito and Meyer [28], pages 731-749. Nicolas G. de \nBruijn. Lambda-calculus notation with nameless dummies: a tool for automatic for\u00admula manipulation with \napplication to the Church-Rosser theorem. lndag. Math., 34(5):381-392, 1972. [23] Giorgio Ghelli. Proof \nTheoretic Studies about a Minimal Type System Integrating Inclusion and Parametric Polymorphism. PhD \nthesis, Universit~ di Piss, March 1990. Technical report TD-6/90, Dipartimento di Informatica, University \ndi Piss. [24] Giorgio Ghelli, 1991. Personal Communication. [25] Jean-Yves Girard. Interpr.itata on fonetioneile \net elimination des coupures de 1 arithmdique d ordre suptirieur. PhD thesis, Universit&#38; Paris VII, \n1972. [26] Carl Gunter, 1990. Personal Communication. [27] John E. Hopcroft and Jeffrey D. Unman. Introduc\u00adtion \nto Automata Theory, Languages, and Compu\u00adtation. Addison-Wesley, 1979. [28] T. Ito and A. R. Meyer, editors. \nTheoretical As\u00adpects of Computer Sofiware (Sendai, Japan), num\u00adber 526 in Lecture Notes in Computer Science. \nSpringer-Verlag, September 1991. [29] Simone Martini. Bounded quantifiers have interval models. In Proceedings \nof the A CIW Conference on Lisp and Functional Programming, pages 174-183, Snowbird, Utah, July 1988. \nACM. [30] John C. Mitchell. Polymorphic type inference and containment. Information and Computation, \n76:211-249, 1988. [31] Benjamin C. Pierce. Bounded quantification is undecidable. Technical Report CMU-CS-91-161, \nCarnegie Mellon University, July 1991. [32] Benjamin C. Pierce. Programming with intersec\u00adtion types \nand bounded polymorphism. Ph.D. the\u00adsis (in progress), 1991. [33] John Reynolds. Towards a theory of \ntype struc\u00adture. In Proc. Colloque sur la Progran~mationj pages 408 425, New York, 1974, Springer-Verlag \nLNCS 19. [34] John C. Reynolds. Preliminary design of the pro\u00adgramming language Forsythe. Technical Report \nCMU-CS-88-159, Carnegie Mellon University, June 1988. \n\t\t\t", "proc_id": "143165", "abstract": "<p><italic>F</italic>&#8804; is a typed &#955;-calculus with subtyping and bounded second-order polymorphism. First proposed by Cardelli and Wegner, it has been widely studied as a core calculus for type systems with subtyping.</p><p>Curien and Ghelli proved the partial correctness of a recursive procedure for computing minimal types of <italic>F</italic>&#8804; terms and showed that the termination of this procedure is equivalent to the termination of this procedure is equivalent to the termination of its major component, a procedure for checking the subtype relation between <italic>F</italic>&#8804; types. This procedure was thought to terminate on all inputs, but the discovery of a subtle bug in a purported proof of this claim recently reopened the question of the decidability of  subtyping, and hence of typechecking.</p><p>This question is settled here in the negative, using a reduction from the halting problem for two-counter Turing machines to show that the subtype relation of <italic>F</italic>&#8804; is undecidable.</p>", "authors": [{"name": "Benjamin C. Pierce", "author_profile_id": "81100303310", "affiliation": "", "person_id": "PP14111353", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143228", "year": "1992", "article_id": "143228", "conference": "POPL", "title": "Bounded quantification is undecidable", "url": "http://dl.acm.org/citation.cfm?id=143228"}