{"article_publication_date": "02-01-1992", "fulltext": "\n A Compilation Method for ML-Style Polymorphic Record Calculi Atsushi Ohori Oki Electric Industry, Kansai \nLaboratory Crystal Tower, 1-2-27 Shiromi Chuo-ku, Osaka 540 Japan email: ohori@okilab.oki. co.jp Abstract \nPolymorphic record calculi have recently attracted much attention as a typed foundation for object\u00adoriented \nprogramming. This is based on the fact that a function that selects a field 1 of a record can be given \na polymorphic type that enables it to be applied to var\u00adious records containing a field 1. Recent studies \nhave established techniques to develop an ML-style type in\u00adference algorithm for such a polymorphic type \nsystem. There seems to be, however, no established method to compile an ML-style polymorphic record calculus \ninto efficient code. The purpose of this paper is to present one such method. We define a polymorphic \nrecord calculus as an extension of Damas and Milner s proof system for ML. For this calculus, we define \nan im\u00adplementation calculus where records are represented as arrays of (references to) values and field \nselection is performed by direct indexing. To represent poly\u00admorphic field selection, the implementation \ncalculus contains an abstraction mechanism over indexes. We then develop an algorithm to translate the \npolymor\u00adphic record calculus into the implementation calculus by refining a type inference algorithm; \nit simultane\u00adously computes a principal type scheme in the poly\u00admorphic record calculus and a correct \nimplementation term in the implementation calculus. The type infer\u00adence is shown to be sound and complete \nin the sense of Dama.s.-Milner s algorithm for ML. Moreover, the polymorphic type system is shown to \nbe sound with respect to an operational semantics of the translated terms in the implementation calculus. \nPermission to copy without fee all or part of this material is granted provided that the copies are not \nmade or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication \nand its date appear, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy other\u00adwise, or to republish, requires a fee and/or specific permission. 1 Introduction \nThe investigation of a polymorphic type discipline for labeled records was initiated by Cardelli [Car88], \nwho defined a typed functional calculus with records and showed that certain aspects of method inhem \ntance can be represented in a static type system. This is based on the observation that a subtype relation \ncan be used to capture the polymorphic nature of functions involv\u00ading field selection such as function \nwealthy(x : {Name : string, Salary: int}) = x. Salarg >100000 where x. Salary selects the Salary field \nfrom a record. This function can be applied to all the subtypes of {Name : string, Salary : int}, i.e. \nthose record types that may contain more fields, [CW85] extended this calculus to a second-order type \nsystem by combining the subtyping and the type system of the second-order lambda calculus [Gir71, Rey74]. \nA similar idea was presented in [Mit84]. More powerful second-order cal\u00adculi for records were proposed \nin [CM89, HP91]. Wand [Wan87, Wan88] observed that the above form of method inheritance can properly \nbe repre\u00adsented in an ML style polymorphic type system when it is extended to records (and variants). \nThis idea was further developed in a number of type inference systems [Sta88, JM88, 0B88, R6m89, Wan89, \nR6m90] that include a combination of type inference and data abstraction wit h multiple inheritance [O \nB89]. In these type systems, a most general polymorphic type scheme is inferred for any typable untyped \nterm containing operations on records. By appropriate instantiation of the inferred type scheme, an untyped \nterm can safely be used as values of various types. This approach not only captures the polymorphic nature \nof functions on records but also integrates a record calculus and ML-style type inference, which relieves \nthe program\u00admer from complicated type declarations required in explicit second-order calculi. We therefore \nhope that this approach will provide a basis for designing prac\u00adtical programming languages for object-oriented \npro\u00adgramming and other data intensive applications, such @ 1992 ACM 089791-453-8/92/0001/0154 $1.50 \nas database programming [AB87], for which records are an essential data structure. To implement a practicaJ \nprogramming language embodying such a polymorphic type inference system, we need to develop a method \nto compile (typable) un\u00adtyped polymorphic expressions involving operations on records into efficient \ncode. In this paper, we at\u00adtempt to provide one such method. As a first step, we only consider field \nselection and field modification (up\u00addate) as operations on records. They are the basis of all record \ncalculi so far proposed, and are also the oper\u00adations commonly found in conventional programming languages. \nWe hope that the method presented here can be extended to various other operations on records such as \nthose to extend a record with an additional field [Wan87, JM88, R6m89, CM89, R6m90], various forms of \nrecord concatenation [Wan89, HP91, R6m91] and join [OB88]. We will ca~mment on this issue in Section \n6. For a language with a simple type system, com\u00adpiling field selection into efficient code is a standard \npractice that is routinely carried out by a compiler. This is due to the fact that exact type information \non parameters is available when compiling a function operating on records. In a polymorphic type system, \nhowever, generating efficient code for field selection is far from trivial. Since types of actual parameters \nmay differ, the position (or offset) of a field within a record passed as a parameter cannot be statically \ncomputed when compiling the body of a function op\u00aderating on records. One naive approach is to imple\u00adment \ndirectly the intended semantics of field selection and field modification by dynamically searching for \nthe required label in a record represented as an assoc\u00adiation list of labels and values. An obvious drawback \nto such an approach is inefficiency in run-time exe\u00adcution. Since field selection its a basic operation \nthat is frequently invoked, such a method is unacceptable for serious practical applications. Another \napproach might be to predetermine the offsets of all the possi\u00adble labels and to represent a record as \na potentially very large structure with many empty slots. A recent work by Cardelli [Car91] used this \napproach to rep\u00adresent records in a pure calculus of subtyping. While this approach is useful for studying \nformal properties of record polymorphism, it is unrealktic in practice. For a polymorphic record calculus \nto become a basis of practiczd programming languages, we must develop a compilation method that aclhieves \nboth compactness in representation of records and efficiency in execu\u00adtion of field selection and fiel~d \nmodification. Connar, Deale, Morrisoan and Brown [CDMB89] considered this problem in the context of an \nexplicitly typed lan\u00adguage with subtyping and suggested a solution. How\u00adever, they did not establish \na systematic method to deal with arbitrary expressions, nor did they consider a type inference system. \nTo the author s knowledge, there has been no proposal that establishes a method to compile an ML-style \nimplicitly typed polymorphic language with records into efficient code. The purpose of this paper is \nto present such a compilation method and to establish that the compilation achieves the in\u00adtended operational \nbehavior of a polymorphic record calculus. This requires a formulation of type infer\u00adence for records \nwith MI, s let binding and a precise definition of efficient implementation for a record calculus. Our \nstrategy is to translate a polymorphic record calculus into an implementation calculus, where a record \nis represented as an array of (references to) val\u00adues and field selection and field modification are \nper\u00adformed by direct indexing. To deal with polymorphic field selection, the implementation calculus \ncontains index variables and indez abstraction. For example, from the untyped term of the form let wealthy \n= Ax. x. Salary >100000 in ... (wealthy R) ... end the translation algorithm produces the following im\u00adplementation \ncode: let wealthy = MAx. x[l] >100000 in ... ((wealthy Z) R) ... end where I is an index variable, M. \nM is index abstrac\u00adtion, z[l] is an index expression and (wealthy Z) is index application with an appropriate \nindex value Z. This method was suggested in [CDMB89]. The major technical contribution of the present \npaper is to estab\u00adlish an inference algorithm that always constructs a correct implementation term for \nany type correct raw term of a polymorphic record calculus and to prove that the polymorphic type discipline \nis sound with re\u00adspect to the translation. We achieve this by refining a polymorphic type inference algorithm \nfor a record calculus. In Section 2 we define a polymorphic record calculus A1et with field selection \nand field modification oper\u00adations. Here we refine the mechanism of conditional type schemes that we \nproposed in [OB88] as kinded type schemes. This refinement allows us to extend a number of known formal \nproperties of ML polymor\u00adphism to record structures. Examples include Damaa and Milner s formal account \n[DM82] for let polymor\u00adphism and Mitchell and Harper s analysis [MH88] on ML polymorphism. Section 3 \ndefines an implementa\u00adtion calculus ~~et t 1. In order to establish the sound\u00adness of the compilation \nalgorithm, we present the cal\u00adculus as a typed functional calculus and prove the soundness of the type \nsystem with respect to an op\u00aderational semantics. In Section 4 we simultaneously develop a type inference \nalgorithm for Al tI and a com\u00adpilation algorithm from ,\\~etI to J~etJl. We then es\u00adtablish that the compilation \nalgorithm preserves typ\u00ad ings. This result, together with the soundness of the type system of J et,[ \nI establishes the soundness of the polymorphic type sy~tem of A1etV with respect to the semantics achieved \nby the compilation. In our calculus, the polymorphic nature of field se\u00adlection is obtained not by subtyping \nbut by polymor\u00adphic instantiation of type schemes. Since the same problem arises in compiling a language \nwith subtyp\u00ading, it would be nice if we could also develop a simi\u00adlar compilation algorithm for record \ncalculi based on subtyping. However, there exists some difficulty that seems to be inherent in calculi \nwith subtyping. We will discuss this issue in Section 5.  2 The Record Calculus ~~et The set of raw \nterms (ranged over by e) of Azet is given by the syntax: e ::=cT[z [Az. e\\ee\\{/=e,... ,l =e} I e.1 [ \nrnodify(e, l,e) I let z = e in e end where C7 stands for constants of type -r. For the sim\u00adplicity of \npresentation we assume that T in CT is a ground type not containing any type variables. It is not hard \nto extend our formal development to con\u00adstants having a polymorphic type. {11 = el, . . ., In = en} is \nthe syntax for labeled records where II, . . . , in are pairwise distinct labels and the order of their \nap\u00adpearance is insignificant. eel is field selection and modify (el, 1, ez ) is field modification, which \ncreates a new record from el by changing the value of the 1 field to e2. let x = e in e end is ML s let \nconstruct. Following Damas and Milner s formal account [DM82] for let polymorphism, the set of types \nis di\u00advided into the set of monotypes and the set of poly\u00adtypes. The set of monotypes (ranged over by \n~) is given by the syntax where tstands for type variables and b for base types. To represent polymorphic \nfield selection, we need to refine type quantification in Damas-Milner polytypes. Instead of using row \nvariables [Wan87], we use kinded type quantification of the form Vt :: k. r, which de\u00adnotes quantification \nover the subset of monotypes rep\u00adresented by the kind k. This is a refinement of condi\u00adtional type schemes \nwe proposed in [OB88], and is also similar to bounded quantification [CW85]. It should be noted, however, \nthat we do not use any notion of sub\u00adtyping. The set of polytypes (ranged over by a) and the set of kinds \n(ranged over by k) are given as: CT::= rlvt::k.u k::= u[(l:T,...,l:T) U denotes the set of all monotypes \nand (11 : T1,... , in : rn) is a record kind intuitively denoting the subset of monotypes that are record \ntypes containing the fields ll:Tl,... ,ln: Tn. In our calculus, every type variable must be kinded by \na kind assignment K, which is a function from a finite set of type variables to kinds. A monotype T has \na kind k under a kind assignment K, denoted by K+T :: k, if it is derivable by the following set of klnding \nrules: K1-r::U forall-r K1-t::(ll:Tl,...n:7n)n) if tE dom(K), K(t)= (11 :rl, . . ..ln : ~n, ...) Kt-{ll: \nTl,...,ln: Tn}::(} l: Tl, :Tl,... ,1 : 7 ) Let T be a type assignment, which is a function from a finite \nset of variables to polytypes. Typing judgments in our calculus are formulae of the form K, T 1-e : a \nsuch that all free type variables in T and u are contained in the domain of K. For a function f, we write \nf{x ++ v} for the function ? such that dom(f ) = dom(f) U {s}, f (z)= v and f (y) = f(y) for all y E \ndom(f), y # x. We also write a[~/t]for the type obtained from u by substituting all the free occurrences \nof twith ~. Figure 1 gives the set of typ\u00ading rules for Atet . Note that klndings in rules DOT and MODIFY \nrepresent the exact conditions on record types. This allows us to integrate these rules with those for \nlet construct (rules GEN and INST). Since let construct is the source of ML polymorphism, this formal \ntreatment is essentiaJ to develop a systematic compilation method. 2.1 Properties Of ~Zet The above \ntreatment of let binding in our proof sys\u00adtem allows us to analyze various formal properties of let polymorphism \nwith records. Indeed, most of the known results of ML polymorphism seems to ex\u00adtend to our calculus. \nExamples include Mitchell and Harper s analysis [MH88] of Damas and Milner s proof system for ML through \na limited form of explicit ca&#38; CUIUS called XML. The explicit calculus corresponding to our calculus \nis defined by changing the term e in the conclusion of the rules ABS, GEN, INST and LET to ~x:rl. el, \n~t::k. e, eT and let x:u=el in e2 end, respectively. Let E be an explicitly typed term and erase(E) be \nthe raw term obtained from E by erasing type specification, type abstraction and type applica\u00adtion. We \ncan show the following property, which is an extension of a result shown in [MH88]. Proposition 1 If \nK, 71-E : c is a typing in the explicit calculus, then K, T 1-erase(E) : u is a typing in A[et . Conversely, \nif K, T E e : u is a typing in CONST VAR K, TI-X:U if x 6 dom(T), T(x) = u ABS K,7{zt+q}i-e~ : r~ K, \nT!- Ax. el : TI+T2 APP ~,7kel:rl+r2 K,, T1-e2:r1 &#38;T1-el e2 : 7-2 RECORD K,T1-e~:~~ (l~i~n) X, T1-{ll= \nel,...,ln= en} : {I:q ,..., /n: Tn}- DOT K,71-e:rl K1-TI::(/:T2) K, T1-ed : T2 MODIFY &#38;T1-el : T1 \n&#38;7-1\u00ad e2:T~ KFTl::(l:T2)\u00ad K,71\u00ad modzfy(el, i,ez) : TI GEN K{~=k},71-e:a t not free in T X, T1-e : \nW::lc. u INST LET &#38;T1-el:v K,T{xt+a}Eez : ~ K, T1-letx =e1ine2end:r Figure 1: Typing rules of the \npolymorphic record calculus ~let,., then there is an explicitly typed term E such that erase(E) =eandK,Ti-E \n:nisatyping inthe explicit calculus. 1 This result allows us to transfer various analyses pre\u00adsented \nin [MH88] to our calculus. R6my s recent work [R6m9C~ also provide a formal treatment of let and unbounded \nlabeled records. It seems to be fairly obvious thlat other proposals for type inference systems of (unbounded) \nlabeled records [Wan87, Sta88, JM88, Wan89] can deal with let bind\u00ading by properly renaming types and \nrow variables. It is, however, not immediately obvious that various for\u00admal properties underlying let \npolymorphism such as above can be extended to those proposals. 2.2 An alternative proof system of ~ze~ \nThe existence of polytypes in the presentation of Azet! , however, complicates the presentation of a \ntype infer\u00adence algorithm and a compilation algorithm we shall develop below. Fortunately there is a \nsimpler proof system that is equivalent to )~~et> . This is based on simpler accounts for let polymorphism \npresented in [Oho89a, Mit90]. The simpler proof system is ob\u00adtained by (1) restricting the set of types \nto be mono\u00adtypes, (2) removing the rules GEN and INST, and (3) replacing the rule LET with the following \nrule: K, T1-el : -rI K, T 1-ez[el/x] : rz LET K, Tl-letx=el inez end : T2 where rl may be any monotype \nand the notation e2 [el /x] denotes the term obtained from e2 by sub\u00adstituting all the free occurrences \nof x in e2 by el with necessary bound variable renaming. Since e2 [el /z] in the albove rule is not a \nsubterm of let x = el in e2 end, some care must be taken in proving various properties of this proof \nsystem. In particular, we cannot use induction on the size of raw terms. We can, however, define a complexity \nmeasure of raw terms in such a way that, in any rule in this proof system, the complexity of the raw \nterm in the conclusion is strictly greater than those of the raw terms in its premises. Based on this, \nwe can prove properties of this proof system by usual case analysis in terms of the structure of raw \nterms. Here we omit a rather lengthy definition of the complexity measure of raw terms. One definition \ncan be found in [Oho89b]. For closed raw terms, this proof system is equivalent to the original one. \nProposition 2 Let e be a closed raw term. It has a typing in Azet if and only if it has a typing in \nthe simpler proof system. I Another advantage of this simpler proof system is that it has a simple denotational \nsemantics as exploited in [Oho89a]. We use this alternative proof system in what follows.  3 The Implementation \nCalcu\u00ad1~~ )@[] This section defines a calculus A ~et [ 1 where field se\u00adlection and field modification \nare executed efficiently. In order to establish the correctness of the compila\u00adtion algorithm given in \nSection 4, we define ~~ t[l as a typed functional calculus and show the soundness of the type system \nin terms of an operational semantics. We assume that there is a linear order s on the set of labels and \nthat a labeled record {?l = VI, . . . . in = v.} is represented as an array of values such that the field \nii = vi is the jth entry of the array where j is the size of the set {ilz E {11,,,. , in}, 1 < Zi}. Select\u00ading \nthe li field can then be performed by the simple indexing operation {11 = vl, . . . 1 )n= Vn }[j]. In \nan actual implementation, records may be presented by references (or pointers ) to values and field selection \nis implemented by indexing followed by de-referencing. In examples below, we use lexicographical ordering \non strings for <. For example, Age < Name and the record {Name = Joe , Age = 21} is represented by an \narray of two entries whose first entry is Age = 21 and whose second entry is Name = Joe . Selecting Name \nfield from this record is performed by the index expression {Name = Joe , Age = 21} [2]. Since the required \nindex values are not always avail\u00adable when compiling field selection, we introduce index variables (ranged \nover by I) and an abstraction mech\u00adanism over indexes (ranged over by Z). An index is either a natural \nnumber or an index variable. The set of raw terms (ranged over by M) of the implementa\u00adtion calculus \nis given as: M::= C [XIAZOMIMM l{z=M,...,l =M}l M[z]1mod2fi(M,z, M) lM. MI MZlletx=M in Mend In order \nto assign a type to raw terms involving in\u00addex variables, we introduce index types of the form index \n(1, r) denoting the index value corresponding to field 1 in type T. The set of types of the implementa\u00ad \ntion calculus is given by the syntax: where index (1, T) + r is a type of terms that are ab\u00adstracted \nover indexes. The set of kinds and the kinding rules are the same as before. In order for index types \nof the form index (1, ~) to be meaningful, we require T to have an appropriate record kind: an index \ntype index (1, T) k well formed under a kind assignment ~ if X E T :: (/, T ) for some T . This condition \nguarantees that an index type denotes a position of a field in a record type. In particular, a well formed \nground index type (under any kind assignment) must be of the form indez(li, {11 : ~l,. . . 1Tn}), < . \n..n}n} it >n: /i {/l, and denotes the natural number equal to the size of the set {ill C {11,. . . ,in},l \n~ /;}. Typings are presented relative to an index assign\u00adment (ranged over by ,C), which is a function \nfrom a finite set of index variables to index types. An in\u00addex assignment L is well formed under a kind \nassign\u00adment K if all the index types appearing in L are well formed under X. An index value X has an \nindex type index (/, T) under an index assignment L, denoted by ~ 1-~ : indez(l, r), if either ~ = 1, \n~(~) = indez(l, T) or Z is the natural number denoted by index (1, T). Typing judgments in A Ze~J1 are \nformulae of the form &#38; T, L 1-M : T such that L is well formed under X. Figure 2 gives the typing \nrules of A~etJ1. 3.1 Operational semantics and the soundness of the type system To show the soundness \nof the type system, we de\u00adfine an operational semantics of ~let~[l in the style of [Tof88] by giving \na set of rules of the form E, LtM~u where v is a canonical value defined below, E is a vari\u00adable environment, \nwhich is a function from a finite set of variables to values, and L is an index environment, which is \na function from a finite set of index variables to natural numbers. The set of canonical values is given \nby the syntax: v ::= CT I {/1 = VI ,..., im=vn}l ~tm(E, L,x, M) I Jab(E, L, 1, M) I wrong where {11 \n= Vl, . ...1. = Vn } stands for canonical val\u00adues for record expressions. For the purpose of pure evaluation, \nit is not necessary to keep record labels in canonical values of record expressions; however, they should \nbe useful, for example, for a printing utility. fun(E, L, x, M) stands for function closures, lab(E, \nL, I, M) for closures corresponding to index ab\u00adstraction and wrong represents run-time error. Fig\u00adure \n3 gives the set of reduction rules. Note that al\u00adthough the above rules suggest associative lookup for \nlambda variables and index variables, standard tech\u00adniques for compiling programming languages can be \nused to determine the actual address (e.g. the offset to an activation record) of each variable. A value \nu has a ground type T, denoted by ~ u : T, if it is derivable from the following set of rules: E+cT:7-for \nany CT. &#38;7,~i_kfI : T1+T2 K, T, L1-ikf2 : T1 APP &#38;7,~!_kfl M2 : T2 ~,~,c~h!fj:Tj (l<i <n)RECORD \nK, T, LF{ll=M1,...,ln =Mn} : {/: TI,... n:Tn~n~ K, T, L1-M : TI KI-TI::(Z:T2) L 1-Z : indez(l, ~1) INDEX \nK, T, Lt-M[~ : TZ K, T, LI-MI : rI &#38;7,Ll_M2 : TZ Kl_rl::(l:Tz) Cl-Z: index(l, T1) MODIFY K, T i-modify \n(M1, Z, M2) : TI K, r, L{I H indez(i, Tl)} 1-M : T2 IABS K,T, LkM. M :index(i, q) + T2 K,T, L 1-M : indez(l, \nT1) a T2 ~ } ~ : indez(i,Tl) IAPP K,7,L~M1 : T.2 K, T, LI-M1 : rl &#38;T, Z t-Mz[M1/x] :7-2 LET K, T, \nLi-letx=M1 inM2 end : T2 Figure 2: The typing rules of the implementation calculu[s E, L1-c*~cT E, Lkx~v \nif x E dom(E) and v = E(x) E, L t-Ax. M ~ ft~n(E, L, x,M) E1, L1 1-Ml ~ fun(E2, L2, x,M2) E1, L1 1-MB \n~ VI E2{x w Vi},.L2 t-M2 ~ V2 E1, L1 I-MI M3 &#38;v2 E, L1-Mi~vi(l<i <n) E, L1-{il=M1 ,...,ln =Mn}~{ll \n=vl, in=vn}=vn} E, Lt-M1~.[ll=vl ,..., =V =}.} E, Lt-M2+v if~=ior~= 1, L(I) = i E, L1-modify(M1, Z, \nM2)~{11= vi,... ,li=v,ln=vn}=vn} E, L 1-M. M =+-lab(E, L, I, M) E1, L1 1-Ml ~ lab(E2, L2,1, M2) E2, L2{IH \ni} 1-M2 ~ V2 if Z=ior Z=l, L(l)=i El, Lit-Ml T*v2 E1, L1 l_Ml ~Vl EI{XI+V1}, L1 I-M2 =+?4 E1,L1 l-let \nx=M1 in M2 end =&#38;wvg Cases yielding wTong are omitted. Figure 3: Operational Semantics of the Implementation \nCalculus 159 +{1, =VI,... ,ln=vn} : {11: 71,... ,L:n}n} if+v~: TifOralll~i~n. + fun(E, L,x, M) : T, + \nq if dv,v if+v : ~land E{z++v}, Li-lf~ v then 1= v : T2.  + lab(E, L,I,M) :a+ i\u00adif Vvif E,.L{lt-+i}l-lkf~ \nvthen+v:~ where i is the natural number denoted by a.   In the last rule, since a is a well formed \nground in\u00addex type, it always denotes a natural number. A substitution S is a function from type variables \nto types. We write [tl I+ -rl,... ,~n I+ Tn] for the substitution S such that S(ti) = ~i (1 < i < ~), \ns(t) = t(t+ {tl,....tn}). A substitution extends to monotypes and other structures containing mono\u00adtypes. \nWe identify a substitution and its extension. The composition S1 o S2 of two substitutions S l and S2 \nis defined as S1 o S2 (t) = S l (S2 (t)). A substitution is ground if its range does not contain type \nvariables. A ground substitution S respects a kind assignment K if, for all t ~ dom(K), 01-S(t) :: S(K(t)) \nis a derivable kinding. A variable environment E respects a ground type assignment T if dorn(T) = dorn(-E) \nand for all z E cZom(E), ~ E(x) : T(z). An index environment respects a ground index assignment L if \ndorn(~) = dom(L) and for all 16 ctom(~), L(I) is the natural number denoted by .C(I). We then have the \nfollowing soundness theorem for ~~et[l. Theorem 1 If K, T, L 1-M : T, then for any ground substitution \nS, if S respects X, E respects S(T)j L respects S(Z) and E, L t-M ~ v, then ~ v :r. I Proofi It is easily \nchecked that typings in AZetJl are preserved by kind respecting ground substitu\u00adtions, i.e. if K, T, \nL I-M : T is a typing in ~1 t,[l and S is a ground substitution that respects K, then 0, S(7), S(JC) \nt-M : S(r) is also a typing. It is then enough to prove the property: if O,T, L 1-M : T is a ground typing, \nE respects T, L respects L and E, L 1-M ~ v,then+v:~ To prove this property by induction, we use the \nop\u00aderational semantics obtained from the one defined in Figure 3 by replacing the last rule for let expressions \nwith the following rule: E1, L1 t_Ml ~Vl E1, L1 hMzIM1/z]~v2 E1, L1 l-let X=M1 in M2 end~v2  It can \nbe shown that the resulting operational seman\u00adtics is equivalent to the original one. The desired prop\u00aderty \nis then proved by induction on the complexity of raw terms we mentioned earlier. Proof proceeds by cases. \nThe case for LET follows from the induction hy\u00adpothesis. Cases other than MIZl, M. M and M 1 are similar \nto the corresponding proof in [Tof88]. Here we only give the cases for M. M and leave the cases for M[~ \nand M 1 to the reader. Suppose 0,T, &#38; F M. M : index (l, Tl) ~ T2, E respects T, L respects L and \nE, L 1-M. M ~ lab(E, L, I, M). By the definitions of typing rules, we must have 0, T, .L{l ~ index (i, \n~1)} t-M : r2. Since index (l, T1) is a well formed ground index type, this de\u00adnotes a natural number. \nLet this number be i. Then L{.1 R i} respects Z{l w index (1, T1)}. By induction hypothesis, for any \nv, if E, L{ I H i} i-M ~ v, then ~ v : T2. By the definition of the typing rule for lab(E, L, 1, M), \nwe have + lab(E, L, 1, M) : indez(l, 71) +-72. I Later we use this result to establish the soundness \nof our compilation.  4 Type Inference and Compila\u00adt ion In order to compile Alet into Alet>[ 1, we \nneed to main\u00adtain information about type instantiation and to in\u00adsert appropriate code for index abstraction \nand index application. We use the technique of type inference to achieve this. For this purpose, we first \nrefine a unifi\u00adcation algorithm to kinded unification. 4.1 Kinded unification A kinded substitution \nis a pair consisting of a kind assignment and a substitution. A kinded substitu\u00adtion (Kl, S) respects \na kind assignment K2 if, for all tG dom(K2), K1 1-S(t) :: S(K2(t)) is a derivable kinding. A klnded substitution \n(Kl, SI ) is more gen\u00ad eral than (K2, S2 ) if S2 = S3 o S1 for some S3 such that (K2, S3 ) respects K1. \nA kinded set of equations is a pair consisting of a kind assignment and a set of pairs of types. A kinded \nsubstitution (Kl, S) is a uni\u00adfier of a kinded set of equations (K2, E) if it respects K2 and S(T1) = \nS(T2) for all (~1, 72) c E. Theorem 2 There is an algorithm U which, given any kinded set of equations, \ncomputes a most general uni$er if one ex&#38;ts and reports failure otherwise. Proofi We define the algorithm \nU in the style of [GS89] by a set of transformation rules on triples (K, E, S) consisting of a kind assignment \nK, a set E of type equations and a set S of solved type equations of the form (t,-r)such that t< F TV(~). \nLet F range over functions from a finite set of labels to types. We write {F} and (F) to denote the record \ntype identified by F and the record kind identified by F, respectively. Figure 4 gives the set of transformation \nrules. Let (K, E) be a given kinded set of equations. The algo\u00adrithm U first transforms (K, ,lJ, 0) to \n(K , E , S ) until no more rules can apply. It then returns (K , S ) if E is empty; otherwise it reports \nfailure. The correct\u00adness of the algorithm is proved by showing that each transformation rule preserves \nthe following property: U-I (&#38;~U {(T, T)}, i$) * (K, E,S) U-H (~U {t w ~},~U {(t, r)}, s) ~ (&#38;[t \nH T](J??), {(~, T)} U [t - T](S)) if t@ FTV(r) U-III (Ku {t, (z u {tz where F ++ (F ,),t,* (F,)}, EU \n{(t,, t,)}, s) * ~ (~)}, [tl ~ tz](~ u {(~l(i),~z(i))ll c dom(~l) n do~(@}), = {(1, Tj)ll G dom(F1) U \ndorn(F2), q = F1 (/) if 1 c ciorn(F1) .((tl, otherwise tz)} u [tl = T1 = ~-z(i)} ~21(S)) u-Iv (Ku {tl \n-(F,)}, Eu {(tI, {Fz})}, S) + (L [t, I+ {F2}](E u {(F1(~),F2(/))1~ = dom(~~) if rlom(I 1) G dom(Fz) and \nt @ l?l V({FZ}) n ~oT74J 2)}), {(h, {F2})li u [tl H {Fz}l(s) u-v (K,~U {(~j + ~;,Tj + 7:)}, S) =+\u00ad (K,~U \n{(~;,~j),(~;,Ti)},S) U-VI (K,~ U {({F1}, {$ 2})}, S) = (K, ~ U {(F1(~),F2(i))ll 6 dom(Fl)}, S) if dom(Fl) \n= dom(F2) Figure 4: Transformation Rules for Unification If (KI, El, S1) a (X2, E2, S2) then a kinded \nsubstitution is a unifier of (Kl, El US1 ) if and only if it is a unifier of (,Kz, Ez U S2). Cases other \nthan U-111 and u-w are same as in [GS89]. Here we show the case of the rule U-HI. The rule U-IV is simpler. \nSuppose (K, a) is a unifier of (K tzI+ U {t~i+(1 1),(F2)}, E U {(tl, t2)}, S). Then K 1-a(tl)::CT((FI)), \nK 1-a(t2) :: a((F2)), and u(tl)cr(t2).the def\u00ad = By inition of kindings, we have a(F1 (/)) = a(F2(l)) \nfor all ~ c dom(F1) rl dorn(F2). Therefore K 1-o(t2):: u((F)). Since o(tl)= c7(t2),a([tlI-+t2](E)) = \ncr(E) and u([tlI-+t2](S)) == a(S). Thus (.K, a) is also a unifier of (K U {t2 1+ (F)}, [tl I+ tz](E U \n{(F1(l), F2(1))11 c dorn(FI) [1 dom(F2)}), {(tl, tz)} U [tlI+ t2](S)). Conversely, suppose (K, a) is \na unifier of(K U {t2H (F)}, [tl ++ t:l](E U {( F1(l), F2(1))11 C dom(F1) n dom(F2)}), {(tl, tj!)} U [tl \nH t2](S)). Then K t-U(tz) :: a((F)), a([tl I--+ t2](F1(l))) = (r([tl H t2](F2(l))) for all 1 c dorn(F1) \nn dorn(F2), and a(tl) = U(tz). By the definition of klndings, this implies that K 1-a(tl) :: C((F1)) \nK 1-a(t2) :: a((Fz)). Since o(tl)= a(h),a([tl+ tz](E)) = u(E) and a([tlI-+t2](S)) = a(S). Thus (K, a) \nis also a uni\u00adfier of (KU {tl * (Fl),t2I+ (F2)}, EU {(tl, t2)}, S). The termination can be proved by \nshowing that each transformation rule decresses the termination measure of the lexicographical pair consisting \nof the number of type variables in E and the total size of E. If the transformation terminates with (K, \n0, S), then it is obvious that (K, S) is a most general unifier of (K, 0, S). It is also easily checked \nthat if the transfor\u00admation terminates with non empty E then E haa no unifier. I 4.2 The algorithm for \ncompilation and type inference We now give an algorithm that simultaneously com\u00adputes a principal type \nscheme and a compiled imple\u00admentation term. A typing K1, TI 1-e : T1 is more general than Kz,T. 1-e : \nrz if dom(7_) ~ o?om(72), dom(tl) ~ dom(L2) and there is a substitution S such that the kinded substitution \n(K2, S) respects KI, T2(t) = S(%(t)) for all tE dom(fi), &#38;(I) = S(L1 (1)) for aU 1 E dom(Ll), and \nTZ = ~(Tl). A typing K,T F e : r is principal if it is more general than all the derivable typings for \ne. We then have the following theorem. Theorem 3 There is an algorithm C which takes a raw term and returns \neiiher (~, T, L, M, T) or failure such that if it returns (K, 7, L, M, T), then K, 71-e : r is a principal \ntyping in Aiet** and X,7, L 1-M : r as a tYPin9 in ~~e~Jl; oihemuise e has no typing in ~~et~ . Proofi \nWe follow [Mit90] and present C as C(e) = Comp(e, 0) where Cornp is an algorithm which takes a raw term \nand an environment A which maps a finite set of vari\u00adables to tuples of the form (K, T, r). The purpose \nof the environment A is to maintain a principal typing of let bound variables. A complete definition \nof C omp is given in Figure 5. Since the treatment of let bound variables through an auxiliary parameter \nA to C omp is the same as the proof of the corresponding theorem in [Mit90], the cor\u00adrectness of the \ntreatment of let expressions is shown similarly. It is therefore enough to show that (1) the cases other \nthan let bound variables and let expres\u00adsions preserve the principal typing property of e, and (2) each \ncase yields a provable typing of M in Aze [l. Here we sketch below the proof of the property (1) for \nthe case of e l. The case for modzfy(el, 1, ez) is similar and all the other cases are essentially the \nsame as in [Mit90]. By the definition of typing rules of Al t , el -l haa a typing of the form K, T 1-el.1 \n: r iff el has a typing of the form K, T 1-el : # and K 1-T :: (1 : r). By induction hypothesis, el has \na typing K, T h el : r ifi(K1, T1, L1, ~1, ~l) =C omp(el, A)and Klj71 Fe : T1 is a more general than \nK, T t-el : -r . Under the fact that K F r :: (1 : T), the later proposition of the previous sentence \nimplies that (Kl U {tl ++ U, tz w (1 : tl ) }, { (Tl, ~2) }) (~1, ~z fresh) has a unifier. The desired \nproperty then follows from that of U. The property of (2) can be shown by cases. The cases of let and \nlet bound variables can be shown by using the following two properties of AZeiJl: (1) K, r, L{l R indez(i, \nT1)} h M : rz is a derivable typ\u00ad ing in )~etJl iff so is K, T, L t-M. ill : indez(l, 71) + T2, and (2) \nK,T,L{~ I+ indez(~, ~l)} b M ~ : ~2 is A le~,[l iff so is K,T, C F M : a derivable typing in index (1, \nT1) + T2. Other cases can be show by simple inductive reasoning. I Since we have shown the soundness \nof the type sys\u00adtem of ~zet[l, the above theorem implies the following soundness property of the type \nsystem of Azet with respect to the evaluation through the compilation. Corollary 1 If C(e) = (K, ?_, \nL, M, T), E is a value environment respecting T and L is an index envi\u00adronment respecting L, and E, L \n1-M =+ v, then +V:r. n We end this section by showing some examples of the compilation. C(AX. Zd) =({t, \n~ U,t2 ++ (1 : tl)},o,{~ t-+ indez(l, t2)}, k. X[l], tz + t*) C(let name = Ax. x.Name in name {Name = \nJoe , Age = 21} end) = (0,0,0, let name= M. Ax. zII] in (name 2) {Name= .Joe , Age = 21} end, string) \nThe following shows an examples of compiling an ML-style type inference session. We write let x = e; \nfor let x = e in x end and the subsequent expressions of the form e ; are regarded as shorthand for let \nx = e in e . For the following type inference session: (*to move a point-shape object horizontally*) \nlet inc~ = Ap, modi~y(p, -X, P X + 1); 4 :Vt::(x : int). t ~ t let salary = Ax. x Salary; + : Vtl ::U. \nVtz::(Salary : t~). tz + tl salary {Name = Susan , Age = 21, Salary = 34000};  + : int let wealthy \n= Xr. (saiary z) > 100000; + : Vt:: (Salary : int). t --i bool  wealthy {Name = Susan , Age = 21, Salary \n= 34000}; + : bool the compilation algorithm produces the following code: let inc_X = MAp. modify (p, \nI,p[I] + 1); + :Vt :: (X: in~). indez(X, t) +-t + t let sala~y = Mkr. x[I]; + :Vt~:: UVtz :: (Salary \n: t,). indez(Salary, t2) ~ t2 + tl (salary 3) {Name= Susan , Age= 21, Salary = 34000}; ~ : int let \nweaithy = M. k. ((salary 1) z) > 100000; + :Vt:: (Salary : int). index (Salary, t) + t + bool (wealthy \n3){Name = Susan , Age= 21, Salavy = 34000}; + : bool  5 Calculi with Subtyping One might want to develop \na similar compilation algo\u00adrithm for a polymorphic record calculus with subtyp\u00ading. As we mentioned in \nthe introduction, however, some difficulty seems to be inherent in any record cal\u00adculus containing the \nfamiliar subsumption rule of the Comp(x, A) = if x c dom(A) then let (Kl, 71, ~1 ) = A(x) (with all \ntype variables renamed with fresh names) (a, +... ~ an -r{) = ~1 (O < n and ~{ does not contain a) Zi \n= (if (xi= index(l, t) then Ii (fresh) else the integer denoted by ~i) L1 = {Ii w ~i [ for new Ii introduced \nabove}, in (K1, T1, L1, ((... (Z Z1O). O) Zn), T{) else ({t* U}, {z H t}, O,x, t) COW(C , A) = (0,0,0, \nC , T) COrnp(k. el, A) = let in (Kl, if x else 71L, Cl, Ml, ~1) = C omp(el, A) G dom(T1) then (Kl, Tlt \ndarn\\{.}, (Kl{ti+U}, 71, .C1, kc. Ml, t + 71) xl, (t Ax. Ml, fresh) 71 (z) + ~1) Comp(el e2, A) = let \n(Kl, Tl, Cl, MI, (KZ,72,LZ,MZ,TZ) (G, S)= U(K1 in (K3, S(71 U 72), Tl) = Comp(el, A) = Comp(ez, A) U \nG U {t -U}, {(Z(Z), S(L1 U Lz), All &#38;fz, S(t)) Z(Z))IX G dom(fi) n dom(fi)} U {(T2 + t,~l)}) (t fresh) \nComp({ll = el,... ,ln=en}, A)= let (Ki,~,ZijiWi,~i) = Comp(ei, A) (1 < i ~ n) q =z{xl+ +tl,..., xnl+tn} \nwhere {xl, . . . ,xn] = (Ulg<n ~oTTJ(%)) \\ dOTTZ(Z) and {tl,... (K,s)=u(x,u... UK. U {ti I+ U[l S i < \nn}, {(z (x), z~l(x))lx in (K, S(71), S(Zl U.-. ULn),{il =Ml,... ,ln J fn}, S ({~1 :~1,...,~n ,%} are \nall E ~fJ~(Z )jl :~n})) fresh S i S n - 1}) Comp(eld, A) = let in (xl, Zi, ,Cl, itfl, ~1) = Comp(el, \nA) (K, S) =U(k2 U {tl -U,t2 H (1: tl)}, {(71, t2)}) if S(tz) =: {11 : 7/,...,1 : T:} then (K, S(Z), S(Ll),~U],S(tl)) \nwhere j = Size({ll else (K, S(71), S(L1) U {1 i+ indez(l, S(t2))}, MII], (tl,tz fresh) E {11,... ,L},i \nS(tl)) ~ Ii}) Comp(modi.fy(el, 1, ez), A) = let (Xl, 71, Cl, itfl, rl ) = C omp(el, A) (K2,72,.CZ, MZ,72) \n= Comp(e2, A) (K3,S) = U(K, UK, u {t, ~ u,t2 = (1 : t,)}, {(fi(x), fi(z))[z E ~o~(fi) n dom(fi)} U {(n, \nh), (Tl, h)}) (h,h fresh) in if S(t2) = {/1 : r}, . . ..l~. : ~~} then (K3, S(Z UZ),S(L1 U&#38;), modi~g(Ml,j, \nMz), S(tz)) where j = Size({i[l c {11,... else (X3, S(T1 U 72), S(L1 U L2) U {1 = index (l, S (t2))},~Wd~l, \n~,J f2),s(t3)) ,Jn},l S ~i}) Comp(let x = el in ez end, A) = let (KI,71, L1, M1, T1) = cow(el, A) {1~1-+cq,... \n,lnt+cYn,, I; F+cl!~,... , 1A F-+CIA} A =A{a H(Kl, Tl, al+... ++r l)})} (K2, %, C2, M2, T2) = Comp(e2, \nA ) (LS) = U(G U G, {(Z(Z),Z(X))[X G dom( A) M{ be the term obtained from Ml by replacing in (K, s(~ \nU~), S(Z,), Z.t z = ~ll. ... J1 . A41 in = L1 (~i not n dom(%)}) occurrences of M, end,s(~,)) ground, \nI; with a; the groumd) natural number denoted by a: Figure 5: The Compilation Algorithm 163 form: I-e:rl \nT1 < 7-2 SUB te:T 2 To see the difficulty, consider the expression: e = if el then {A = abc , B = true} \nelse {B = true, C = abc } With the existence of the subsumption rule, this ex\u00adpression has the type \n{B : booi}. However, the ac\u00adtual set of labels of the wdue denoted by e depends on the value denoted \nby el and therefore the offset of the label B can not be statically determined. It is therefore impossible \nto compile an expression such as (kc. z*B) e into the implementation calculus. A sim\u00adilar problem arises \nin combination of bulk data types such as list or set types. This observation shows that in a record \ncalculus with the subsumption rule, it is in general impossible to statically compute offsets of labels. \nThis property is related to loss of type infor\u00admation the phenomenon first observed in [CW85]. With \nthe subsumption rule, a typing judgment of the form 1-e : {1, : ~~,. . . . /n : Tn} no longer implies \nthat e denotes a record value having the exact type {/~:T~,...~:T~}~}. As we have discussed in [BTB089], \nthis property is also problematic in dzahng with operations such as equality and database join, which \nrequire the exact type information of their parameters. It remains to be investigated whether there is \nsome interesting subset of a polymorphic record calculus with subtyping that does not suffer from this \nproblem and allow efficient compilation. Another possibility of overcoming this difficulty would be to \nenrich a calculus with a new form of judgments for exact typing.  Conclusions We have established a \ncompilation method for a poly\u00admorphic type inference system with labeled records. The method always yields \ncode that deals with field selection and field modification by a few machine instructions. The polymorphic \ntype discipline for records is shown to be sound with respect to the com\u00adpilation. The presented algorithm \ncan readily be incorpo\u00ad rated in existing ML-style polymorphic programming languages with records. For \nexample, Standard ML [MTH90] contains records and monomorphic field se\u00ad lection. By refining its type \nsystem to incorporate kinded abstraction and incorporating its compiler with our compilation algorithm, \nthe language can be refined to support polymorphic field selection and its efficient execution without \naltering its language syntax. As we mentioned in the introduction, one important extension to the work \npresented here is to include more powerful operations on records such as concatenation and join. To represent \nthese operations, the polymor\u00adphic type system must be extended. One approach is to introduce constraints \non instantiation of type vari\u00adables of the form t = 7-1*72 which denotes the requirement that the instantiation \noft is restricted to those S(t) such that S(t) is a record type equal to S(~l )*S(72 ), where * is an \nappropri\u00adate operator on record types representing join or con\u00adcatenation. Typing mechanism incorporating \nthis idea have been developed in [OB88, Wan89] for type infer\u00adence systems and in [CM89, HP91] for second-order \ntype systems. However, eliminating time consuming run-time scan of the fields of two records seems to \nre\u00adquire a substantial extension of the implementation calculus and the compilation strategy.  References \n[AB87] M.P. Atkinson and O.P. Buneman. Types and persistence in database programming languages. ACM Computing \nSumeys, 1987. [BTB089] V. Br~azu-Tannen, P. Buneman, and A. Ohori. Can object-oriented databases be statically \ntyped? In Proc. .% d Intern\u00adational Workshop on Database Program\u00adming Languages, pages 226 237, 1989. \nMorgan Kaufmann Publishers. [Car88] L. Cardelli. A semantics of multiple in\u00adheritance. Information and \nComputation, 76: 138 164, 1988. (Special issue devoted to Symp. on Semantics of Data Types, 1984). [Car91] \nL. Cardelli. Extensible records in a pure calculus of subtyping. Technical report, DEC Systems Research \nCenter, 1991. [CDMB89] R. Connor, A. Dearle, R. Morrison, and F. Brown. An object addressing mecha\u00adnism \nfor statically typed languages with multiple inheritance. In Proc. ACM OOP-SLA Conference, pages 279-285, \n1989, [CM89] L. Cardelli and J. Mitchell. Operations on records. In Proc. Masematical Founda\u00adtion of \nProgramming Semantics, Lecture Notes in Computer Science 442, pages 22\u00ad52, 1989. [CW85] L. Cardelli and \nP. Wegner. On un\u00adderstanding types, data abstraction, and polymorphism. Computing Surverys, 17(4):471-522, \n1985. [DM82] [Gir71] [GS89] [HP91] [JM88] [MH88] [Mit84] [Mit90] [hfTH90] [OB88] [OB89] L. Damas and \nR. Milner. Principal [Oho89a] A. Ohori. A simple semantics for ML type-schemes for functional programs. \nIn polymorphism. In Proc. A CM/IFIP Con-Proc. ACM Symposium on Principles of ference on F~rnctional Programming \nLan-Programming Languages, pages 207-212, guages and Computer Architecture, pages 1982. 281-292, 198!1. \nJ.-Y. [Oho89b] A. Ohori. A Study of Types, Semantics Girard. IJne extension de l interpretation and Languagss \nfor Databases and Object\u00adde godel k l analyse, et son application k oriented Programming. PhD thesis, \nUni\u00ad l 61imination des coupures clans l analyse versity of Pennsylvania, 1989. et th~orie des types. \nIn Second Scandi\u00ad[R6m89] D. R6my. Typechecklng records and vari\u00ad navian Logic Symposium. North-Holland, \nants in a natural extension of ML. In ACM 1971. Conference on Principles of Programming J. Gallier and \nW. Snyder. Complete sets of Languages, pages 242-249, 1989. transformations for generzd E-unification. \n[R6m90] D. R6my. Typechecking records in a nat- Theoretical Computer Science, 67(2):203\u00adural extension \nof ML. Technical report, 260, 1989. INRIA Rocquencourt, Le Chesnay Cedex, R. Harper and B. Pierce. A \nrecord calcu- France, 1990. lus based on symmetric concatenation. In PTOC. ACM Symp. on Principles of \nPro-[R6m91] D. R6my. Typing record concate\u00ad nation for free. Technical report, INREA-Rocquencourt, Le \nChesnay Cedex, gramming Languages, 1991. L. A. Jategaonkar and J.C. Mitchell. ML France., 1991. with \nextended pattern matching and sub\u00adtypes. In Proc. ACM Conference on LISP [Rey74] J.C. Reynolds. Towards \na theory of and Functional Programming, pages 198 type structure. In Paris Colloq. on 211, 1988. Programming, \npages 408 425. Springer-Verlag, 1974. J. C. Mitchell andl R. Harper. The essence of ML. In Proc. 15th \nACM Symposium [Sta88] R. Stansifer. Type inference with sub\u00adon Principles of Programming Languages, types. \nIn Proc. ACM Symposium on Prin\u00adpages 28-46, 1988. ciples of Programming Language9, pages 88-97, 1988. \n J.C. Mitchell. Coercion and type infer\u00adence. In Proc. ACM Symposium on Prin-[Tof88] M. Tofte. Operational \nSemantics and ciples of Programming Languages, pages Polymorphic Type Inference. PhD thesis, 175-185, \n1984. Department of Computer Science, Univer\u00ad sity of Edinburgh, 1988.  J.C. Mitchell. Type systems \nfor program\u00adming languages. In J. van Leeuwen, ed-[Wan87] M. Wand. Complete type inference for itor, \nHandbook of Theoretical Computer simple objects. In Proc. IEEE Symposium Science, chapter 8, pages 365-458. \nMIT on Logic in Computer Science, pages 37  Press/Elsevier, 1990. 44, 1987. R. Milner, M. Tofte, and \nR. Harper. The [Wan88] M. Wand. Corrigendum : Complete type Definition of Standard ML. The MIT inference \nfor simple object. In Proc. IEEE Press, 1990. Symposium on Logic in Computer Science, 1988. A. Ohori \nand P. Buneman. Type infer\u00adence in a database programming language. [Wan89] M. Wand. Type inference \nfor records con-In Proc. ACM Conference on LISP and catenation and simple objects. In Proc. Functional \nProgramming, pages 174-183, IEEE Symposim on Logic in Computer 1988. Science, pages 92-97, 1989. A. Ohori \nand P. Eluneman. Static type in\u00adference for parametric classes. In Proc. ACM 00PSLA Conference, pages \n445\u00ad456, 1989.  \n\t\t\t", "proc_id": "143165", "abstract": "<p>Polymorphic record calculi have recently attracted much attention as a typed foundation for object-oriented programming. This is based on the fact that a function that selects a field <italic>l</italic> of a record can be given a polymorphic type that enables it to be applied to various records containing a field <italic>l</italic>. Recent studies have established techniques to develop an ML-style type inference algorithm for such a polymorphic type system. There seems to be, however, no established method to compile an ML-style polymorphic record calculus into efficient code. The purpose of this paper is to present one such method. We define a polymorphic record calculus as an extension of Damas and Miler's proof system for ML. For this calculus, we define an implementation calculus  where records are represented as arrays of (references to) values and field selection is performed by direct indexing. To represent polymorphic field selection, the implementation calculus contains an abstraction mechanism over indexes. We then develop an algorithm to translate the polymorphic record calculus into the implementation calculus by refining a type inference algorithm; it simultaneously computes a principal type scheme in the polymorphic record calculus and a correct implementation term in the implementation calculus. The type inference is shown to be sound and complete in the sense of Damas-Milner's algorithm for ML. Moreover, the polymorphic type system is shown to be sound with respect to an operational semantics of the translated terms in the implementation calculus.</p>", "authors": [{"name": "Atsushi Ohori", "author_profile_id": "81100168829", "affiliation": "", "person_id": "PP39076764", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143200", "year": "1992", "article_id": "143200", "conference": "POPL", "title": "A compilation method for ML-style polymorphic record calculi", "url": "http://dl.acm.org/citation.cfm?id=143200"}