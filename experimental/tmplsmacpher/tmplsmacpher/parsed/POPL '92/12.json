{"article_publication_date": "02-01-1992", "fulltext": "\n A Comprehensive Study of the Complexity of Multiparty (Extended Yuh-Jzer Joung jourt@lcs.sunysb. edu \nDepartment of SUNY at Stony Brook, Abstract We present a taxonomy of languages for multiparty in\u00adteraction, \nwhich covers all proposals of which we are aware. Based on this taxonomy, we present a com\u00adprehensive \nanalysis of the computational complexity of the multiparty interaction implementation problem, the problem \nof scheduling multiparty interactions in a given execution environment. 1 Introduction A multiparty interaction \nis a set of 1/0 actions exe\u00adcuted jointly by a number of processes, each of which must be ready to execute \nits own action for any of the actions in the set to occur. An attempt to partici\u00adpate in an interaction \ndelays a process until all other participants are available. After the actions are exe\u00adcuted, the participating \nprocesses continue their local computation. Although a relatively new concept, the multiparty interaction \nhas found its way into a number of distributed programming languages (e.g., CSPS [27], PPSAS [25], Raddle \n[7], Script [10], Compact [6], Ac\u00adtion Systems (1], 1P [8, 9], and Hybrid CSP [15]) and algebraic models \nof concurrency (e.g., SCCS [22], CIR- CAL [21], MEIJE [29], LOTOS [3], and Eztended LO- TOS [4]). *Research \nsupported by the National Science Foundation un. der Grant CCR.-87O43O9. Permission to copy without fee \nalf or part of thk material is grarrtcd provided that tbe copies are not made or distributed for direct \ncommercial advantage, the ACM copyright notice and the title of the publication and its date appear, \nand notice is given that copying is by permission of the Association for Computing Machinery. To copy \nother\u00adwise, or to republish, requires a fee and/or specific permission. @ 1992 ACM 089791-453-8/92/0001/0142 \n$1.50  Interaction Abstract) Scott A. Smolka sas@cs.s~nysb. edu Computer Science Stony Brook NY 11794-4400 \nThere are a number of choices to be made in the de\u00adsign of language constructs for multiparty interaction, \nincluding the following: Bi-party vs. multiparty (i.e., of arbitrary arity) in\u00adteraction. Primitive vs. \nabstract interaction, where in the for\u00admer the participants of an interaction are fixed, while in the \nlatter the participants are variable. Conjunctive vs. disjunctive parallelism. Conjunc\u00adtive parallelism \nallows a set of interactions to be ex\u00adecuted simultaneously as an atomic unit, while dis\u00adjunctive parallelism \nchooses, nondeterministically, one interaction to be executed from a set of possible interactions. As \nwe shall see, conjunctive and dis\u00adjunctive parallelism can be profitably used in tan\u00addem. Synchronous \nvs. asynchronous execution in the un\u00adderlying system. In this paper, we first present a taxonomy of lan\u00adguagei \nfor mtdtiparty interaction based on the above design issues, which covers all proposals of which we are \naware. Based on thk taxonomy, we then present a comprehensive analysis of the complexity of the muTtz\u00adparty \ninteraction implementation problem, the problem of scheduling multiparty interactions in a given execu\u00adtion \nenvironment. For intuition, consider an asynchronous system in which interactions are primitive and multipartied. \nDis\u00adjunctive parallelism is permitted by allowing interac\u00adtions to serve as guards in an alternative \ncommand. The implementation problem in this setting has been elegantly characterized by Chundy and Misra \nas one of committee coordination [5]: ea~ch professor in a univer\u00adsity serves on one or more committees, \nthe members of which are fixed; furthermore, a committee cannot convene until all its members are present. \nThe prob\u00adlem then is to schedule committee meetings such that no two committees with a com~mon member \nconvene si\u00admultaneously. Summary of Technical Results In designing a language for multiparty interaction, \none must negotiate a tradeoff between the implementation efficiency of the language versus its expressive \npower. For example, allowing both conjunctive and disjunctive parallelism provides maximum expressive \npower, while disallowing any parallelism assures a trivial solution to the implementation problem. In \nfact, most algebraic models of concurrency, e.g., SCCS, MEIJE, CIRCAL, and Extended LOTOS, are biased \nin favor of maximum expressive power; implementation of these models is not a major concern. Conversely, \nmost languages for mul\u00adtiparty interaction support only disjunctive parallelism (e.g. PPSAS, Action Systems, \nRaddle, and 1P), or no parallelism at all (e.g. Script and Compact). These lan\u00adguages can be implemented \nefficiently. Our goal was to determine, for each language in our taxonomy, the most general way in which \nconjunctive and disjunctive parallelism can be combined such that the implementation problem is still \nsolvable in polyno\u00admial time. Our results can be summarized as follows: For synchronous systems with \neither primitive or abstract interactions, we prove NP-completeness for the combination of multipartiness \nand disjunc\u00adtive parallelism. For asynchronous systems with either hi-party or multiparty interactions, \nwe prove NP-completeness for the combination of abstraction and conjunctive parallelism. For synchronous \nsystems with bl-party interac\u00adtions, we exhibit polynomial-time algorithms when conjunctive and disjunctive \nparallelism are used in isolation. However, their joint use once again yields NP-completeness. For asynchronous \nsystems with primitive interac\u00adtions, we exhibit polynomial-time algorithms for a restricted combination \nof conjunctive and disjunc\u00ad tive parallelism. We believe our results shed some light on existing languages \nfor multiparty interaction, and also provide a point of reference for developing new distributed lan\u00adguages \nfor multiparty interaction. For example, lan\u00adguages like PPSAS, Action Systems, Raddle, and 1P, which \nonly allow disjunctive parallelism, can be ex\u00adtended to allow some form of conjunctive parallelism in \ncombination with disjunctive parallelism without sac\u00adrificing tractability. Similarly, Script and Compact, \nin which no parallelism is permitted, can be extended to allow disjunctive parallelism (but nothing more!). \nFur\u00adthermore, if we wish to design a synchronous language that uses SCCS-like interaction, then we may \nallow con\u00adjunctive and dkjunctive parallelism to be used in isola\u00adtion. Related Work A number of distributed \nalgorithms have been proposed for various instances of the multiparty interaction imple\u00admentation problem \n(e.g. [26, 5, 2, 11, 24, 19, 15, 16, 17]), but, to our knowledge, we are the first to present a comprehensive \nanalysis of the complexity of multiparty interaction. The algorithms of [26, 5, 2, 11, 24, 19] con\u00adcern \nprimitive interactions in the presence of disjunctive parallelism, such as those found in Action Systems, \n1P, LOTOS, PPSAS, and Raddle. The algorithm of [15] concerns primitive interactions in Hybrid CSP where \nconjunctive and disjunctive parallelism are used in isola\u00adtion. An improved version of this algorithm \nthat allows both parallelisms to be combined in a fairly general way appears in [16]. Finally, the algorithm \nof [17] concerns abstract interactions (such as that supported by 1P and Script) where only disjunctive \nparallelism is permitted. The rest of this paper is organized as follows. Sec\u00adtion 2 presents our taxonomy, \nSection 3 gives the prob\u00adlem definitions, and Section 4 the results of our com\u00adplexity analysis. We conclude \nin Section 5. 2 A Taxonomy of Languages for Multiparty Interaction In this section we present a taxonomy \nof lan~ua~es for multiparty interaction. We begin by identifying four ba\u00ad sic interaction constructs. \nBy additionally considering the issues of conjunctive vs. disjunctive parallelism, and abstraction A \nI port ~ multi-port I (team) I .......................... I channel \\ multi-channel I (gate) 1 multipartiness \nFigure 1: Basic interaction constructs. Figure 2: A system of three processes PI, P2 and P3 and two channels \nC12 and C13. P1 can interact with P2 at channel c1 z, or with P3 at channel CI 3. synchronous vs. asynchronous \nsystem execution, we ob\u00adtain a taxonomy that covers all proposed languages for multiparty interaction \nof which we are aware. 2.1 Basic Interaction Constructs As depicted in Figure 1, we can identify four \nbasic in\u00adteraction constructs based on their support (or lack thereof) of multipartiness and abstraction: \nchannels, ports, gates, and teams. Consider first channels, a well\u00adknown primitive for hi-party communication. \nA channel cij defines a bidirectional link between a unique pair of processes pi and Pj. For example, \nFigure 2 shows a sys\u00adtem of three processes PI, P2, and P3, that int eract over channels C12 and C13. \nInteractions in CSP [13], Hybrid CSP, and Occam [14] are of this type. A port a is an abstraction mechanism \nthat defines an activity between two roles. Roles serve as formal process parameters. Two processes can \nestablish an in\u00ad stance of a if and when both are ready to fill the roles of a. If two or more processes \nare trying to fill the same role, then one of them will participate in an instance of the interaction, \nand the choice is arbitrary. For exam\u00ad ple, Figure 3 depicts a system of two reader processes, RI and \nRz, and two writers, W1 and Wz. Port a has an out in Figure 3: A system with two readers and two writers. \nRI and R2 can assume the input role of port a, while W1 and W2 can assume the output role . output role \n, which can be assumed by WI or W2, and an input role , which can be assumed by RI or RZ. By filling \nthe roles of a, a reader process can obtain a new value from a writer. Interactions in Ada [28], CCS \n[23], MEIJE, and SCCS are of the port variety.1 Channel-based and port-based interactions involve exactly \ntwo processes. The extension to multipartiness of arbitrary arit y leads to the notions of multi-channels \nand multi-ports. A multi-channel is more commonly re\u00adferred to in the literature as a gate, and a multi-port \nas a team; so it shall be here. A gate defines an interaction among a fixed set of pro\u00adcesses. In the \ndining philosophers problem, for exam\u00adple, we may define a gate involving the ith philosopher and its \ntwo neighboring forks. Thus, when the interac\u00adtion is established, all three processes are synchronized; \ni.e., the d h philosopher eats only when it possesses its neighboring forks. Many recently proposed languages \nand models for multiparty interaction use gate-like con\u00adstructs, e.g., Raddle, CSPS, Action Systems, \nPPSAS, 1P, CIRCAL, LOTOS, and Extended LOTOS. Like a port, a team has a fixed set of roles. A set of \nprocesses together can establish an instance of the team by filling all the roles. For example, we may \ndefine a team with three roles, a transmitter and two recipients, as follows: team bi-casi :: [ role \ntransmitter(.z: in) :: skip role recipient (z: out ) :: z ;= z role recipient (y out) :: y := z ] Any \nthree processes can use this hi-cast team to com\u00ad municate. Languages such as Script, Raddle, Compact, \nand 1P support this type of interaction. 2 1In Ada, only one process can assume the input role of a port, \nbut more than one process can potentially assume the out\u00ad put role . 2 As in Ada, a team-based construct \nin Compact contains a role which only one process can pot entially assume.  2.2 Disjunctive versus Conjunctive \nPar\u00adallelism An interaction command is a programming language statement used to establish an interaction \namong two or more processes. As in CSP, interaction commands can serve as guards in an alijernative/repetitive \ncom\u00admand. An interaction command appearing as a guard can be executed only if all the participants agree \nto establish the interaction. For example, consider the fol\u00adlowing gate-based program: PI :: * [g-... \n] P2 :: * [g+... 0 h+... 1  P~::*[g-... 0 h--+.,. 1 Here g is a command to establish an interaction \nat a gate shared by PI, P2, and P3. As such, PI can execute g if and when P2 and P3 agree to execute \ntheir own g actions. A compound command allc)ws a process to engage in one or more interactions simultaneously \nas an atomic unit. A compound command is of the form <al, ..., cm>, where the Ui s a,re interaction commands \nof the same type (i.e. channel, port, gate, or team). We call a compound command simple if it consists \nof only one interaction command. For notational convenience, we sometimes omit the angle brackets around \nsimple commands. To illustrate compound commands, consider the sys\u00adtem shown in Figure 2. If P:L wishes \nto multicast to P2 and P3, PI can execute the compound command < CIZ, CM>. The execution of this compound \ncommand places PI in two concurrent sub-interactions, one with P2, and the other with P3. The two hi-party \ninteractions together constitute a multicast involving PI, P2, and P3. Thus, compound commands provide \nanothe~ source of muh%partiness. Languages like CIRCAL, CSPS, Ex\u00adtended LOTOS, Hybrid CSP, MEIJE, and \nSCCS all al\u00adlow compound commands. We refer to the execution pattern of interactions al\u00adlowed by a compound \ncommand as conjunctive paral\u00adlelism, and by an alternative command as disjunctive parallelism. A combination \nof the two yields an alter\u00adnative command in disjunctive normal form: <Ull, . . ..uln. > 0 ... 0 <Uml, \n. . ..umnm> Execution of an alternative command in disjunctive nor\u00admal form involves the selection of \na compound command <U~l,...,Ui~i > such that all participants of each inter\u00adaction CM in < u~l, . . . \n. o~ni > agree to establish U;k. The execution of these ~ih then proceeds simultane\u00adously. 2.3 Synchrony \nversus Asynchrony lh a synchronous system, processes proceed in lock-step. l[n each step all processes \nare required to make a move. In an asynchronous system no fixed progress rate can be assumed. Interestingly, \nthe same program may have different outcomes in different systems. For example, consider the following \nprogram: PI:: w:=0; [ P2!w + skip ] ; [ P,?w -skip]; P.J:: x := 1; [ PI?Z ---+ skip]; [ P3!z + skip \n] ; P3 :: y:= 2; [ Pz?y ---i skip ; 0PA!y -skip ]; [ P2?y + skip; 0I.P4!y -skip ] ; P4:: z:= 3; [ P3?z \n_ skip ] ; [ Pl!z + skip ]; The not ation we use is based on CSP: Q? v is a com\u00admand that inputs a \nvalue from process Q into variable v, and R! e outputs the value of expression e to pro\u00adcess R. An input \ncommand Q? v of R is executed iff a complementary output command R! e of Q is executed, If processes \nproceed asynchronously, there is a possi\u00adble execution in which P1 and P2 interact, then P2 and P3, then \nP3 and P4, and then P4 and PI, terminating theprogram with w=z=y=z=O.But thesame execution is not possible \nwhen processes proceed syn\u00adchronously. Instead, in a given time unit PI and P2, and P3 and P4 may interact; \nthen, P2 and P3, and P1 and P4 may interact, terminating the program with z = y = O, W=Z=2. port t earn \nr asynchronous rnultipartiness . Script, Compact: 1 k = e Raddle, 1P: D E A. abstraction abstraction \nchannel gate asynchronous asynchronous Hybrid CSP: COD Action Systems, multipartiness PPSAS, LOTOS: \nD CSPS, CIRCAL, Extended LOTOS: DNF I Figure 4: A taxonomy of languages for multiparty interaction. \n2.4 Taxonomy part y interactions such as Ada, CCS, CSP, and Occam. Our taxonomy of languages for multiparty \ninteraction 3 Definitions is given in Figure 4. There is a separate category for each of the four basic \ninteraction constructs. Each of In this section, we define the multiparty interaction im\u00adthese is further \ndivided into two categories: synchronous plementation problem for both synchronous and asyn\u00adand asynchronous. \nFurthermore, for each language, we chronous systems. We also present a lattice of alter\u00adexplicitly list \nthe type of conjunctive and disjunctive native command formats, in which the bottom element parallelism \nit supports: 1 means that no parallelism disallows any parallelism (thereby assuring a trivial so\u00adis \nallowed; C denotes conjunctive parallelism; D de\u00ad lution to the implementation problem), while the top \nnotes disjunctive parallelism; and DNF indicates the element allows conjunctive and disjunctive parallelism \ncombination of conjunctive and disjunctive parallelism to be combined in disjunctive normal form (thereby \npro\u00adin disjunctive normal form. Also, C@D means that con\u00adviding maximum expressive power). In between \nthe bot\u00adjunctive and disjunctive parallelism can be used only in tom and the top, we define a number \nof formats that re\u00adisolation (see Section 3 for more details). For example, strict the use of conjunctive \nand disjunctive parallelism the language 1P supports team-based interaction and in various ways. disjunctive \nparallelism in asynchronous systems. There-As in CSP, the scheduling of multiparty interactions fore, \nin Figure 4 we place 1P: D in the asynchronous depends on a notion of syntactic compatibility among category \nfor team. interaction commands, We first define compatibility for Note that only port-based constructs \nhave been pro\u00ad interaction commands based on channels, ports, gates, posed for synchronous systems. \nAlso, we have not in\u00ad and teams as follows: cluded in Figure 4 languages that strictly support bi\u00ad Definition \n1 (compatibility of basic interaction commands) channel: Let cij denote the channel shared exclusively \nby processes Pi and Pj, where Pi executes the inter\u00adaction command c~j to establish an interaction at \ncij, and Pj executes the command ~j. Then, the set of commands {c~j, <~} is compatible. port: Let a, \nb, . . . denote ports, where any process Pi can ezecute the interaction command ai to assume the input \nrole at a, and $ to assume the out\u00adput role . Then, for all i, j, the set of commands {a;, d} is compatible. \ngate: Let gi,...i, denote the gate shared exclusively by processes Pil, . . . . Pik, where each Pii, \n1 ~ j ~ k, ezecutes the interaction command g~,..ib to estab\u00adlish an interaction at gil...i,. Then, the \nset of com\u00admands {g~...ik [ 1 ~ j < k], is compatible. team: Let x, y, . . . denote teams, where any \nprocess Pi can execute the interaction command r@zi to as\u00adsume role T of team x. Let rl, ....rk be the \nroles of team x. Then, foT all il, ,. ... i~, the set of com\u00admands {Tj (lzi~ 11 ~ j < k} is compatible. \nFurthermore, no other sets o;f basic interaction com\u00admands are compatible. We now lift the notion of \ncompatibility from basic interaction commands to compound commands. To do so, we treat a compound command \nas a set of basic interaction commands. Set operations on com\u00adpound commands therefore folllow, e.g., \n<al, . . . . ak > (J <Uj,..., u;> = {(Tl, . . .. Uk. U\\, U\\}, U\\}. All our re\u00adsults also hold when a \ncompound command may con\u00adtain duplicate commands; i.e.,, a compound command is treated as a multi-set. \nDefinition 2 (compatibility of compound commands) Aset C={crl,.. ., CYm} of conapotmd commands, where \nai is specijied by Pi, 1 ~ i ~ m, is compatible if the following conditions hold: (1) There is a partition \nof {,r I m c U a;} such that each block is a compatible set of basic interaction commands. (2) C is \nminimal, i.e., no proper subset of C satisjies condition (1).  A multiparty interaction based on a compatible \nset {a,,...lam } consists of a set of simultaneous sub\u00adinteractions, one for each block in the partition \nof the constituent basic interaction commands. For exam\u00adple, the set of channel-based commands {< C;2, \nc~a >, C;2, C:3} is compatible; the partition is {c~z, C;2} and {C:3, c~a}. Note that according to condition \n(2), the set C4 } is not compatible; it defines two inde\u00adpendent interactions, one involving P1 and P2, \nand the other P3 and P4. Also, the set of port-based commands {<al, bl, C1 >, <Z2, ~2 >, <i#, &#38; >, \na4} is compatible, but {<al, bl, C1 >, <ii2, ~2 >, <ii3, # >} is not because of condition (1). We now \ndefine the multiparty interaction implemen\u00adtation problem for asynchronous systems. The defini\u00adtion is \nsimplified by viewing an alternative command S in disjunctive normal form as a set of compound com\u00admands, \ni.e. the alternatives of S. {cl,, c!,, &#38;> 34 Asynchronous Multiparty Interaction Given a set {S1,. \n. . . Snj of alternative com\u00admands, where Si is specified by process Pi) 1 ~ i ~ n, is there a compatible \nsubset of (J Si ? For synchronous systems, we first need the following definition. Definition 3 An exact \ncover of a set S = {SI,..., Sw} of alternative commands, where Si is specijied by process Pi, 1< i< n, \nis a .$et{cl,..., Ck} such that each Cj, :1< j s k, is a compatible subset of U Si, and for each Si G \nS, U Cj contains ezactly one command of S;. For example, consider the following alternative com\u00admands: \nS1= {< C;2,C; 3>, Cjz, c&#38;} S2= {C:z, cg4j Ss= {C:3, cj4, C:5} S4 = {c:+, C:4, c~5} S5 = {<C:5, C:5 \n>, C:5} he% { { C;21 c~2}7 { cj5, c~5, < c~5,c]5 > } } is an ex\u00adact cover of {S1, ..., S5}. The multiparty \ninteraction implementation problem for synchronous systems is given by: Synchronous Multiparty Interaction \nGiven a set S = {S1,..., S~J of alternative commands, where Si is specijied by process Pi, 1~ i ~ n, \nis there an ezact cover of S? DNF: <ull, !.., cmnl> H . . . 0 <Uml, . . ..amnm> DNF t DNF2: <ql,. ... \nuln,> 0 <Uzl, . . ..uzn. > 0 <(73> 1 ... 0 <Um> D:F2 DNFl: <ql,. ... qn, > 1 <q> 0 ... 0 <Um> t DNFl \n o C@D: <ul, . . ..am> or <al> 0 ... D <&#38;m> t  D: <al> 0 ... 0 <am>  c: <cq, ....am> c D \\/  \n L: <r>  Figure 5: A lattice of alternative command formats. The left side illustrates the various \nformats. The partial order relation among these formats is shown on the right, where S + R means that \nformat S is strictly more restrictive than format R. Finally, we define a lattice of alternative command \nyields NP-completeness. Thus, our complexity results formats that incorporate both conjunctive and disjunc-are \ntight in this sense. tive parallelism in a partially-ordered manner. In Fig-For example, we show that \nfor asynchronous port\u00ad ure 5, format 1 disallows any parallelism, Format C based systems where only disjunctive \nparallelism is per\u00ad permits only conjunctive parallelism, while format D mitted, the implementation problem \nis polynomial-time permits only disjunctive parallelism. C@D allows con-solvable. However, the problem \nbecomes NP-complete junctive and disjunctive parallelism to be used in iso-in the presence of conjunctive \nparallelism, and hence lation. DNF~ is a restricted version of DNF where at for any combination of conjunctive \nand disjunctive par\u00admost i compound commands of size greater than one allelism. can appear in an alternative \ncommand. In the following we present in detail two of our results which we believ~ are representative, \nnamely, the NP\u00adcompleteness result for format DNF 1 in synchronous  4 Complexity Analysis channel-based \nsystems, and a polynomial-time algo\u00adrithm for format C@D in synchronous port-based sys-We now study the \ncomplexity of the multiparty interac\u00adtems. The other results can be found in the full pa\u00ad tion implementation \nproblem. Based on our taxonomy per [18]. First, we give the problem definitions of we have obtained sixteen \nresults that, in a comprehen-Monotone One-In-Three 3SAT and Maximum Match\u00ad sive fashion, characterize \nthe complexity of the imple\u00ading, which will be used in our proofs. mentation problem. Our results are \nsummarized in Ta\u00adble 1. In this table, a format appearing in a row labeled Monotone One-In-Three 3SJkT \n[12] NPC means that the implementation problem for this format is NP-complete. Similarly, P means polynomial-Instance: \nSet U of variables, collection C of clauses time solvable. over U such that each clause c E C has [cl \n= 3, and no There are four columns of results, one for each type c E C contains a negated literal. of \nbasic interaction construct we have identified in Sec-Question: Is there a truth assignment for U such \nthat tion 2. Within each column, we consider two cases: each clause in C has exactly one true literal? \nsynchronous versus asynchronous. Within each of these Maximum Mat thing [20]subcases, we identify a format \nS from the lattice of Fig\u00ad ure 5 such that the multiparty interaction implemen-Given an undirected graph \nG = (V, E), find a mazimum tation problem is polynomial-time solvable, and that matching M of G. A matching \nM of G is a subset of E every format unrelated to or above S in the lattice such that no two edges of \nM share the same node. It is channel port multi-channel multi-port (gate) (team) synchronous: NPC DNFl \nDNF1 D D P C@DC@D c c asynchronous: NPC DNF2 c DNF2 c P DNFl D DNFl D Tablel: Summary of thecompletity \nanalysis ofmultiparty interactions. naazimum if lM / ~ IMI for any other matching M of Let Ni ~ V be \nthe subset of the nodes of G cor- G. Furthermore, Miscomplete iflit41=[lV1/2~. responding to the compound \ncommands of S;, i.e., Ni = {o I g(v) E Si}, 1 ~ i < n. Then, a constrained subgraph of G is a graph (V \n, E ) such that: Theorem 1 The Synchronous Multiparty Interaction problem for format DNFl in channel-based \nsystems is 1. V ~ Vand E ={(qv) lu, vEV and(u, v) E EJ. NP-complete. 2. Vi, IV fl Nil ~ 1, i.e., for \neach S i, V contains at Proof: Let S = {S1,..., S=} be the given set of most one node that corresponds \nto a command of channel-based alternative commands. W.1.o.g. we as-Si. sume that for each Si 6 S, i%a \ncommand a G Si con\u00adtains C~j, then there exists a command/3 c Sj such that 3.If%,ucV and ucNit then for \neach Nj such that 3 E Nj, (u, V) E E, exactly one node of Nj is~j E /3. The communication graph of S \nis the undi\u00adin V . rected graph (V, E), where tlhere is a bijection g from the set of nodes V to the \nset of compound commands The constrained subgraph is minimal if (V, l?) does U Si, and the set of edges \nis E = {(u, W) 13 c~j, ~j, c~j E not have a constrained subgraph (V , E ) such that g(~) and dj c g(~)}. \nV > V . It is total if di, \\V nN,l = 1. For example, the following alternative commands For example, \nthe above communication graph has the following two minimal constrained subgraphs:  S1= {<42>, <c;2, \nc;a,>} S2.= {<42>, <C?z> CL >1  <CL, C:3 > S3 = {<c;3, cf3>} are represented by the graph: L <CL > \n< CL, C;s> < C:2, C:3 > < C;3, C:3 > Also, the right one is total. A minimal constrained sub\u00adgraph represents \na compatible subset of U Si, and a totally constrained subgraph represents an exact cover Of{sl, . . \n..sn}. Note that in G a node representing a compound com-It is easy to see that the Synchronous Multiparty \nIn\u00admand of size greater than one (i.e. a compound node) teraction problem for format DNFl in channel-based \nhas adjacent nodes that are from two or more alterna-systems is in NP: whether a set of compound commands \ntive commands. A node representing a simple command is an exact cover of a set of alternative commands \ncan (i.e. a simple node) has adjacent nodes from one alterna- be determined in polynomial time. We now \npresent a tive command. Also, an important property of G is that polynomial-time transformation from \nMonotone One\u00adIn-Three 3SAT to the problem. Let U == {VI,..., Vlul } if g(~), g(~) c Si, g(~), g(z) c; \nSj and (u, w), (v, S) c E then (u, a), (v, w) e E. be the set of variables and C = {cl,..., CICI} be \nthe set of clauses in a given instance of Monotone One-In-Three 3SAT. We construct a communication graph \nG such that C is satisfiable iff G has a totally constrained subgraph. The graph G has 21 ICI edges and \n281CI nodes. The nodes are partitioned into 141CI blocks, each of which corresponds to an alternative \ncommand. Furthermore, each of these blocks contains at most one compound node. Thus, the corresponding \nalternative commands of G satisfy the restrictions imposed by for\u00admat DNF1. The blocks of nodes in G \nare given as follows. For each clause Ci c C, we have a block ai of one compound node, a block Ti of \nthree simple nodes, and blocks ti,l and fj,l, 1 ~ 1 < 3, each of which contains a compound and a simple \nnode. For each variable vj c U, we have blocks ~j,lj Xi,2 . . . . ~j,mj and yj,l, yj,2 . . . . yj,mj \n, each of which has two simple nodes, where mj is the number of occurrences of vj in the clauses of C. \nThe edges of G are Ul<i<, Cl Ei, where Ei = Ei,l U Ei,2 U Ei,3 such that:  .Q,l = {(U,V)l Ue~~, V &#38;( \nU t~,tu (J f~,~)}. 1<1<3 1<1<3 Let the three simple nodes of Ti be T), r?, and T:, where the ordering \nk arbitrary. Also, let the com\u00adpound node of ti,lt~,l. be Then, %2 = U { (t;,~>T:) }. 1<1<3 Let the two \nsimple nodes of zj,k be x~,k and z~,k (in arbitrary order), 1 s ~ ~ IUI, 1 ~ k ~ mj. Similarly, y~,k \nand y~,h denote the two simple nodes of Yj,k. Further, let the 1th variable in clause ci be vi,, and \nlet this be the hi,l th occurrence of Vi,, starting from clause c1. Then, Ei,3 = U Ei,3,2, where 1<1<3 \n Let ~ be the set of nodes that are covered by the edges in Ei, i.e., Vi = {U I=v, (u, V) c Ei V (v, \nU) c Ei}. We then have that G = (U ~, U Ei). For example, the communication graph for the set of clauses \n{ c1 = (UI, V2, V3), C2 = (V2, V3, VA) } is given in Figure 6. Note that the set of 141CI alternative \ncommands cor\u00adresponding to the nodes of G can be obtained as follows: Let u be a node corresponding to \na compound command a of an alternative command Sj. Then, ~;~ E a iff 3 v, (u, V) c U Ei and node v corresponds \nto a compound command of sk. To complete the proof, we now show that G has a totally constrained subgraph \nif C is satisfiable. For the only-if direction, we observe that G has ICI disconnected components G1 \n= (Vi, E1), . . ., GICI = (~cl, Elcl). A totally constrained subgraph H of G also has ICI com\u00ad ponents \nHI,. . . . HICI, where Hi is a subgraph of Gi, 1 ~ i ~ ICI. Since Gi contains all three simple nodes \n~~, ~~, and ~~ of ~i, Hi must contain exactly one of them. We define a satisfying truth assignment for \nC as follows: Let r: be the node of T; in Hi; then, the 1 th variable of clause ci is set true, and the \nother two variables are set false. Note that the edges in Ei,3 ensure that the assignment of a truth \nvalue to each variable vj is consis\u00adtent with the first occurrence of vj. Therefore, a totally constrained \nsubgraph of G implies a satisfying truth as\u00adsignment for C. For the if-direction of the proof, given \na truth as\u00adsignment that satisfies C, we can extract a totally con\u00adstrained subgraph H from G as follows: \nFor each clause ci, if the 1 th variable in ci is set true, then H contains T:. By the construction, \nit can be seen that the other nodes and edges in H are then determined. For example, the totally constrained \nsubgraph (repre\u00adsented by the thick edges and their covered nodes) of the communication graph for clauses \nc1 = (VI, V2, V3), and C2 = (V2, V3, V4) in Figure 6 corresponds to the satisfy\u00ading truth assignment \nT such that I-(vI ), 7(v3), T(v4) = false, T(vz) = true. 0 The statement of our second theorem makes \nuse of the following notation. Let S = {al,..,, ak} represent an alternative command. Then ] ISI I is \nthe total number of basic interaction commands appearing in S, i.e., I ISI I = ~l<j<k bile or e-de, II{< \nU1, U2>I Us}ll= s. Theorem 2 The Synchr o?aous Multiparty Interaction problem for format C@D in port-based \nsystems can be solved in O((~l<i<n llS~ I l):) time. Figure 6: The communication graph constructed for \nclauses Note that a node in block s is labeled by s. The thick edges subgraph. Proof: Given S = {S1, \n. . . . S%,}, we construct an rect ed graph G = (V, E) such that S has an exact iff G has a complete \nmatching, A complete matching G can be found in time O(fl~. ]EI) [20]. The set V of nodes is now given; \ndefine a mapping g, to be used later, how the nodes of G are derived from S, if S; consists of simple \ncommands there isanode v;in V and g(vi)= 1 s h < q. Nothing else is in V. The set of edges is E = {(u, \nand ii] e g(v)}. Note that IV1 (z Ilsill)z. Recall that a complete matching a subset of E with the following \ntwo edges of M share a common node in V, M has an edge incident a complete matching M of G, we ~ ~ M \ntwo node, at show concomitantly, that remembers S. For each Si ~ U1, ....OP, then Si. If Si of a single \ncompound command < U1, . . . . u~ there are nodes Vi,l, . . . . Vi,g i:m V and g(vi,k) v) 13 ai, d , \nai Undi. cover of we consists >, then = {Uk}, ~ g(u) llSill, and IEI < of G=(V,E) is properties: (i) \nno and (ii) for each the node. Given how to derive an exact cover of S from M as follows. First, we \ndefine an equivalence relation s on M such that: If (vi,~, u) 6 M and (vi,z, u ) e M, then (v~,~, u) \ns (v~,~, ?/). Let {Ml,..., Mm} be the partition induced on M by =. For each block itfh, 1 ~ h ,< m, \nwe obtain a set ch of commands from U Si as follows: ~ (vi, Vj ) E Mk, then ch consists of a simple com\u00admand \nof Si, and a simple command of Sj such that the two simple commands are compatible. n X2,2 24,1 114,1 \n?/3 ,2 c1 = (VI, Vz, V3) and Cz = (vz, V3, V4) in Theorem 1. and their covered nodes constitute a totally \nconstrained If (V;,~, Vj) E Mh, then command of Si, and a is compatible with the . If (vijh, Vj,l) E \nMh, tlhen ch contains the compound simple command of Sj that simple command of g(v~,&#38; ). C~ contains \nthe compound commands of Si andl Sj. Nothing else is in Ck. Then, it can be seen that {Cl,..., Cm} is \nan exact cover of s. Finally, we show how to derive a complete matching M of G = (V, E) from a given \nexact cover C of S. Let c = {cl,... , Cm}. For each ch E C, since ch is a compatible set of{u I+ cCb, \ntwo compatible obtain a set &#38;fh If a simple of commands, u 6 a} such commands. ~ E of edges command \nof there exists a partition r that each block consists of Given the partition r, we as follows: S i and \na simple command of Sj are in the same block, then edge (vi, vi) is in it!th .  If Si= {<al ,.. ., UP>}, \nand UhE <&#38;l, . . ..uP> and a simple command of Sj are in the same block, then edge (v;,h, Vj ) k \nh Mh.  If Si={<ul,..., andcrhc<ul, in the same  Nothing else  Then, no two edges thermore, let Vk \n= V1, ....Vm of nodes u Mh is a complete cP>}and Sj ={<u~, . . ..u~>}. . . . ,uP>andu~C<u~, . . . ,uj> \nare block, then edge (vi,k, ~j,z) is in Mh. is in ~h. of ikfk share {u 1%, (u, v) constitute matching \nof a common node. J?ur\u00adc Mb}; then the sets a partition of V. So, G=(~ E). l  5 Conclusions Future work \nwill focus on two areas of algorithm development: (1) efficient distributed algorithms for We have presented \na taxonomy of all existing languages the tractable cases in synchronous systems; and (2) for multiparty \ninteraction of which we are aware. The probabilistic, completely symmetric algorithms for syn\u00adfoundation \nof the taxonomy are the four basic interac\u00ad chronous and asynchronous systems. tion constructs: channels, \nports, gates, and teams. The taxonomy is further elaborated by considering the is- Acknowledgement We \nthank Ker-I Ko and Wen\u00adsues of conjunctive vs. disjunctive parallelism, and syn- Guey Tzeng for their \nvaluable comments. chronous vs. asynchronous system execution. Then for each category in the taxonomy, \nwe have determined the References most general way in which conjunctive and disjunctive parallelism \ncan be combined such that the multiparty [1] Back, R. J. R. and Kurki-Suonio, R. Distributed interaction \nimplementation problem can still be solved cooperation with action systems, ACM Trans\u00adin polynomial \ntime. actions on Programming Languages and Systems, Recently proposed languages like PPSAS, Action Sys- \nVol. 10, No. 4 (October 1988), pp. 513-544. tems, Raddle, and 1P use gate-based interaction in an [2] \nBagrodia, R. Process synchronization: design and asynchronous setting. They have ruled out conjunctive \nperformance evaluation of distributed algorithms, parallelism, only allowing disjunctive parallelism. \nOur IEEE Transactions on Software Engineering, Vol. positive results indicate that the designers of these \nlan\u00ad 15, No. 9 (September 1989), pp. 1053-1065. guages could have additionally allowed some form of conjunctive \nparallelism without sacrificing tractability. [3] Bolognesi, T. and Brinksma, E. Introduction to Our \ncomplexity results provide a point of reference the 1S0 specification language LOTOS, Computer for developing \nnew distributed languages for multiparty Networks and ISDN Systems, 14 (1987), pp. 25-59. interaction. \nFor example, if we wish to design a syn\u00adchronous language that uses port-like constructs such as [4] \nBrinksma, E. On the design of Extended LOTOS a specification language for open distributed sys\u00adin S CCS, \nthen we may allow conjunctive and disjunctive parallelism to be used in isolation. Also, synchronous \ntems, Ph.D. Dissertation, University of Twente, versions of the asynchronous languages P PSAS, Action \nthe Netherlands (1988). Systems, and Raddle may permit only conjunctive par\u00ad [5] Chandy, K. M and Misra, \nJ. A Foundation of Par\u00ad allelism. allel Program Design, Addison-Wesley (1988). We have exhibited polynomial-time \nsequential algo\u00adrit hms for the tractable cases. Of course, one is ult i-[6] Charlesworth, A. The multiway \nrendezvous, mately concerned with efficient distributed algorithms. ACM Transactions on Programming Languages \nWe have made progress in this direction on two fronts. and Systems, Vol. 9, No. 2 (July 1987), pp. 350-First, \nthe distributed algorithm of [16] efficiently im-366. plements asynchronous channel-based interaction \nwhile [7] Forman, I. R. On the design of large distributed allowing a fairly general disjunctive normal \nform. In systems, Proceedings of the First International particular, compound commands in an alternative \ncom-Conference on Computer Languages (1986), pp. 84\u00admand 95. <Cll, ....clnl> H ... 0 <Cml, . . ..cmnm> \n[8] Francez, N. and Forman, I. R. Interacting Pro\u00adcesses: A language for coordinated distributed pro\u00ad \nare required to be disjoint: Cij # Ckl for i # k. With gramming, ) invited paper for Jerusalem Confer\u00ad \nslight modification, this also solves the gate-based case. ence on Information Technology, Jerusalem \n(Oc- Secondly, in [17] we present a message-efficient dis\u00adtober 1990). tributed algorithm for team-based \ninteraction in com\u00adbination with disjunctive parallelism in asynchronous [9] Francez, N. and Forman, \nI. R. Interacting Pro\u00adsystems. The algorithm of [17] also yields a solution to cesses: A Multiparty Approach \nto Coordinated Dis\u00adthe port-based case, as a port is simply a hi-party team. tributed Programming. Forthcoming \nbook (1991). [10] Francez, N., Hailpern, 13., and Taubenfeld, G. Script: A communication abstraction \nmecha\u00adnism, Science of Computer Programming 6(1) (January 1986), pp. 35-88. [11] Gao, Q. and Bochmann, \nG. V. Distributed im\u00adplementation of LOTOS Multi-Rendezvous Par\u00adticipants Proceedings of the 9th IFIP \nWG 6.1 In\u00adternational Symposium on Protocol Specification, Testing, and Verification, University of Twente, \nthe Netherlands, (E. Brinksma, G. Scollo and C. A. Vksers, eds.) (June 1989). [12] Garey, M. R. and Johnson, \nD. S. Computers and Intractability: A Guide to The Theory of NP\u00adcompletene.w, Freeman, S:kn Francisco \n(1979). [13] Hoare, C. A. R. Communicating sequential pro\u00adcesses, Communication of the ACM 21, 8 (Au\u00adgust \n1978), pp. 666-677. [14] Hoare, C. A. R. Occam programming manual, Prentice Hall (1984). [15] Joung, \nY.-J. and Smolkim, S. A. A completely distributed and message-efficient implementation of synchronous \nmultiprocess communication, Pro\u00adceedings of the 19th International Conference on Parallel Processing \n(August 1990), pp. III: 311-318. [16] Joung, Y.-J. and Smolka, S. A. Efficient, dynam\u00adically structured \nmultiprocess communication, Proceedings of the 28th Annual AUerton Confer\u00adence on Communication, Control, \nand Computing (October 1990). [17] Joung, Y.-J. and Smolka, S. A. Coordinating first\u00adorder multiparty \ninteractions, Proceedings of the 18th Annual ACM Symposium on Principles of Programming Languages (January \n1991), pp. 209\u00ad 220. [18] Joung, Y.-J. and Smolka, S. A. A comprehensive study of the complexity of \nmultiparty interaction, Technical Report 91/20, Department of Computer Science, SUNY at Stony IBrook \n(1991). Submitted for journal publication. [19] Kumar, D. An implementation of N-party syn\u00adchronization \nusing tokens, Proceedings of the 10th International Conference on Distributed Comput\u00ading Systems (1990), \npp. 320-327. [20] Micali, S. and Vazirani, V. V. An O(lVl~ . Ili 1) algorithm for finding maximum matching \nin gen\u00aderal graphs, Proceedings of the .21st Annual IEEE Symposium on Foundations of Computer Science \n(1980), pp. 17-21. [21] Milne, G. J. CIRCAL and the representation of communication, concurrency, and \ntime, A CM Transactions on Programming Languages and Sys\u00adtems, Vol. 7, No. 2 (April 1985), pp. 270-289. \n[22] Milner, R. Calculi for synchrony and asynchrony, Theoretical Computer Science 25 (1983), pp. 267\u00ad \n310. [23] Milner, R. Communication and Concurrency, Prentice Hall (1989). [24] Park, M. H. and Kim, \nM. A distributed synchro\u00adnization scheme for fair multi-process handshakes, Information Processing Letters \n34 (April 1990), pp. 131-138. [25] Ramesh, S. and Mehndiratta, S. L. A new class of high-level programs \nfor distributed computing systems, Proceedings of the Fifth Conference on FST-TCS. Lecture Notes in Computer \nScience 206, Springer-Verlag, Berlin (1985), pp. 42-72. [26] Ramesh, S. A new and efficient implementation \nof multiprocess synchronization , in: Proceedings Conference on PARLE, Lecture Notes in Com\u00adputer Science \n259, Springer-Verlag, Berlin (1987), pp. 387-401. [27] Roman, G.-C. and Day, M. S. Multifaceted dis\u00adtributed \nsystems specification using processes and event synchronizaticm, Proceedings of the lth In\u00adternational \nConference on Software Engineering (March 1984), pp. 44-55. [28] U.S. Department of Defense, Reference \nManual for the Ada Programming Language, ANSI/MIL-STD\u00ad1815A, U.S. Government Printing Office, Washing\u00adton, \nD.C. (1983). [29] de Simone, R. Higher-level synchronizing devices in MEIJE-SCCS,M Theoretical Computer \nScience Vol. 37 (1985), pp. 2!45-267. \n\t\t\t", "proc_id": "143165", "abstract": "<p>We present a taxonomy of languages for multiparty interaction, which covers all proposals of which we are aware. Based on this taxonomy, we present a comprehensive analysis of the computational complexity of the <italic>multiparty interaction implementation problem</italic>, the problem of scheduling multiparty interactions in a given execution environment.</p>", "authors": [{"name": "Yuh-Jzer Joung", "author_profile_id": "81100204016", "affiliation": "", "person_id": "PP39032324", "email_address": "", "orcid_id": ""}, {"name": "Scott A. Smolka", "author_profile_id": "81100533015", "affiliation": "", "person_id": "P261162", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143197", "year": "1992", "article_id": "143197", "conference": "POPL", "title": "A comprehensive study of the complexity of multiparty interaction", "url": "http://dl.acm.org/citation.cfm?id=143197"}