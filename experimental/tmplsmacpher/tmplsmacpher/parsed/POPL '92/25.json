{"article_publication_date": "02-01-1992", "fulltext": "\n Algorithmic ~pects of type Patrick Lincoln * Computer Science Department Stanford University Stanford, \nCIA 94305 lincoln@cs. stanf oral. edu Abstract We study the complexity of type inference for pro\u00adgramming \nlanguages with subtypes. There are three language variations that effect the problem: (i) ba\u00adsic functions \nmay have polymorphic or more limited ~ype%(ii) the subtype hierarchy may be fixed or varY as a result \nof subtype declarations within a program, and (iii) the subtype hierarchy may be an arbitrary partial \norder or may have a more restricted form, such as a tree or lattice. The naive algorithm for infer\u00adring \na most general polymorphic type, under variable subtype hypotheses, requires deterministic expo~en\u00adtial \ntime. If we fix the subtype ordering, this upper bound grows to nondeterministic exponential time. We \nshow that it is Np-hard to decide whether a lambda term has a type with respect to a fixed subtype hier\u00adarchy \n(involving only atomic type names). This lower bound applies to monomorphic or polymorphic lan\u00adguages. \nWe give PSPACE upper bounds for deciding polymorphic typability if the subtype hierarchy has a lattice \nstructure or the subtype hierarchy varies arbi\u00adtrarily. We also give a polynomial time algorithm for \nthe limited case where there are of no function con\u00ad stants and the type hierarchy is either variable \nor any fixed lattice. 1 Introduction Subtyping is a basic feature of typed object-oriented languages, \nsuch as C++ and Eiffel [Str86, Mey88], * Supported in part AT&#38;T Bell Laboratories Doctoral Schol\u00adarship \nand sources listed under t . t supported in part by au NSF PYI Award, matching funds from Digital Equipment \nCorporation, the Powell Foundation, and Xerox corporation; NSF grant ccR-8814921 and the Wal\u00adlace F. \nand Lucille M. Davis Faculty Scholarship. Permission to copy without fee all or part of this materdal \nis granted provided that the copies are not made or distributed for direct commercial advantage, the \nACM copyright notice and the title of the publication and ha date appear, and notice is given that the \ncopying is by permission of the Association for Computing ~achinery. To copy otier\u00adwise, or to republish, \nrequires a fee and/or specific permission. @ 1992 ACM 089791-453-81921000110293 $1.50 inference with \nsubtypes John C. Mitchellt Computer Science Department Stanford University Stanford, CA 94305 mitchell~cs. \nstsnf oral. edu and also occurs in many other languages in limited cases such as the relation between \ninteger and real (or floating-point) numbers. In 1984, the second author described an algorithm for Milner-style \ntype inference with subtyping [Mit84, Mit91]. Given a pure, untyped lambda term, this algorithm finds \na most general typ\u00ading statement that describes the set of possible typings with respect to any subtype \nhierarchy. Various aspects of the algorithm have been studied by other authors, with Fuh and Mishra elaborating \nalgorithmic alter\u00adnatives [FM90] and Wand and O Keefe studying the computational complexity of typability \n[W089]. An extension with polymorphic record operations [JM88] has been implemented by Jategaonkar [Jat89]. \nUnfor\u00adtunately, the straightforward implementation of the type inference algorithm with subtypes requires \nex\u00adponential time, even in the absence of polymorphic let declarations (see [KMM91]). This may be an \nob\u00adstacle to practical type inference for object-oriented languages. It is therefore important to investigate \nthe inherent complexity of type inference and type check\u00ading in the presence of subtypes. The most general \ntyping assertion about a pure lambda term (without constant symbols) may have exponential size, even \nusing concise directed acyclic graph (dag) representations of type expressions. Con\u00adsequently, it is \nnot possible to compute most general types with subtyping in less than deterministic expo\u00adnential time. \nHowever, the related decision problem of determining whether a term has any type might be solved more \nefficiently. By comparison, even though the Curry-type of a pure lambda term without subtyp\u00ading can be \nexponential, when written as a string, there exist linear-size dag representations and linear algo\u00adrithms \nthat decide Curry-typability [KMM9 1]. The decision problem is relevant to practice since an ef\u00adficient \ndecision procedure could verify the absence of type errors at compile time without printing most\u00adgeneral \ntypes. Since this is the only form of typing problem that could be solved in less than exponential time, \nwe focus on decision problems for type inference. There are three language variations that have an effect \non the complexity of typing: The subtype hierarchy may be fixed or vary as a result of subtype declarations \nwithin a program. Term constants may be polymorphic functions or restricted to monomorphic functions \nor atomic data (non-functions). The subtype hierarchy may be an arbitrary par\u00ad tial order or may have \na more restricted form, such as a tree or lattice. If term constants have restricted functionality, this \nmay simplify the type inference problem. Therefore, when possible, we prove lower bounds for restricted \nterm constants and upper bounds for polymorphic types. A subtle issue is the relationship between the \nsub\u00adtype hierarchy at the point of declaration of some iden\u00adtifier and the subtype hierarchy at a possible \npoint of use. For example, consider a function ~ of two argu\u00adments that requires the type of the first \nargument to be a subtype of the type of the second. An implicit assumption in [Mit 84, Mit 9 I.] is that \nthe appropriate typing statement to infer about f is some formaliza\u00adtion of this English description, \nregardless of whether types A and B with A a subtype of B have been declared. The reason is that we may \nwant to call the function f in some scope where two such types have been declared. Therefore, the type \ninference al\u00adgorithm given in [Mit84, Mit91] deduces a most gen\u00aderal typing statement that includes arbitrary \nassump\u00adtions about the relationships between types of func\u00adtion parameters. While this seems reasonable \nfor pure lambda terms without constant symbols, the situation becomes more complicated in a realistic \nprogramming language. This is discussed in Section 3. The main lower bound in this paper is that it is \nNP-hard to decide whether a lambda expression with constants has a type, given a set of subtyping rela\u00adtionships \nbetween ground (atomic) types. This ap\u00adplies to polymorphic and monomorphic languages, and languages \nwithout functional constants. This lower bound improves the main result of [W089], which re\u00adquires a \nconstant with a polymorphic type. We also observe that if type parameters and subtype assump\u00adtions are \ngiven explicitly in the syntax of terms, it fol\u00adlows from the results in [Tiu91] that deciding whether \nan explicitly-typed term has a type is PSPACE hard. We give two algorithms for the decision problem. \nThe more general algorithm applies to terms with ar\u00adbitrary constants, but assumes either that the subtype \nhierarchy may vary arbitrarily or that the fixed sub\u00adtype hierarchy is a lattice. (Either condition makes \nit possible to determine in polynomial space whether an exponential-size set of subtype assumptions is \nsatisfi\u00adable.) In the special case that there are no functional constants and the subtype hierarchy is \neither vary\u00ading or is a fixed lattice, our second algorithm solves the problem in linear time. Since \nthis case is NP-hard for arbitrary partial orders, our results emphasize the value of restricting the \nsubtype relation to obtain prac\u00adtical typing algorithms. Further discussion of the relevant language \nchar\u00adacteristics and their relationship to type inference is given in Section 3, following the preliminary \ndefini\u00adtions in Section 2. The lower bound is presented in Section 4 and the upper bounds in Sections \n5 and 6. For those familiar with [W089], we note that their claim that the decision problem reduces to \nthe par\u00adtial order problem PO-SAT has been retracted [Wan91]. This invalidates both the claimed NP algorithm \nfor the general problem and the claimed polynomial algo\u00adrithm when the subtype hierarchy is a tree. \n 2 Preliminaries We review the essential definitions and results from [Mit84, Mit91]. We study typing \nalgorithms for untyped lambda terms, possibly cent aining constant symbols. Lambda terms are formed according \nto the grammar M::= z/c] MlM2 Ikr. ikf, where z may be any variable, c a constant symbol, lvfliMz is \nthe application of Ml to h4z and Ax.11 is a lambda abstraction defining a function. For simplicity, we \nonly consider function types, writ\u00ad ten using type variables and type constants. Type ex\u00ad pressions have \nthe form T =. . tlo/7-l+T2 where t maybe any type variable, 6 a type constant, and rl --+ rz is the \ntype of functions from ~1 to T2 . A subtype assertion has the form ~ ~ T The stan\u00ad dard meaning of an \nassertion u ~ T M that ~ is a subset of r . An alternative interpretation that we will not discuss in \nany detail is that there is some coercion function fa+T which transforms values of type a into values \nof type ~ . Some discussion of this alternative may be found in [Mit91]. An atomic subtype assertion \nis a statement a ~ b , where a and b are either type variables or type con\u00ad stants. All of our subtyping \nhypotheses will be atomic. Without this assumption, subtyping hypotheses such as the pair b ~ b+b and \nb+b ~ b would ex\u00ad press domain equations, and therefore allow all pure lambda terms (terms without constants) \nto be typed (see [Mit91]). Terms and types will be written over some selected signature. A signature \nX = (B, S, T) is a triple con\u00ad sisting of a set B of type constants, a set S of atomic subtype assertions \nabout type constants in B , and a set T of term constants, each with a specific type built from type \nvariables, type constants from B and + . We say a term constant c: u is polymorphic if u con\u00adtains one \nor more type variables and non-polymorphic otherwise. Intuitively, two type expressions match if they \nhave the same shape. This does not involve any substitu\u00adtions. More specifically, we define matching \nas fol\u00adlows: if u is a type variable or type constant, then u matches T if and only if T is a type variable \nor type constant; if u = al + UT , then u matches r if and only if T= q --+TV and al matches q ,and UP \nmatches Tr . The entailment relation, # , on subtype assertions is defined by the following proof system. \nNote that if C is a set of atomic subtype assertions, and C 1-u ~ r, then u matches T.  c 6 u{(7<T}t_U<T \nR c 1-u~u The C rule allows subtype assumptions to be used in a derivation. The R rule is reflexivity \nof ~ , T is tran\u00ad sitivity, and the Arrow rule gives subtyping for func\u00ad tion types. Note that function \ntypes are antimono\u00ad tonic in the left, or argument position, and monotonic in the right, or result position. \nIf C and C are sets of subtype assertions, we write C h C! to indicate that Cku<Tforeveryu <Tin C . A \ntyping statement is a formula C, A E M: u, where C is a set of atomic subtype assertions, A is a set \nof type assumptions of the form z: a, where z is a term variable, M is an untyped lambda term, and ~ \nis a type expression. The typing statement C, A 1-M : u may be read as, Under the subtype assumptions \nC and assumptions A about the types of variables, the term M has type u . The following proof rules determine \ntypability with respect to any signature X = (B, S, T) . The subtype proof system enters through the \nSub, or subsump\u00ad tion rule. In Const, R may be any substitution of type expressions over E for type variables. \nConst C, A!-C:RU (c:a GT) Var C, AU{ Z:u}\\x:a C, AF-M:u--+T C, AEN:U App C, A1-(MN):r C, AU{ Z:a}EM:~ \nAbs (z@ A) C, A1-(k.M):u-+r C, AkM:cT cUsku~T Sub c,Atiif:T  The Const rule allows a typed constant \nfrom the sig\u00adnature to be given any substitution instance of its specified type. (If c : a is non-polymorphic, \nthen the substitution R will have no effect.) The Var, App, and Abs rules are standard. The Sub rule \nforces a term with one type to belong to every supertype. We say that a typing statement C, A F M : n \nis provable with respect to signature Z = (B, S, T) if all of the term constants in A4 appear in T and \nall uses of Const and Sub in the derivation of the typing stat\u00adment are in accordance with the signature. \nAs stated in [Mit84] and proved in [Mit91], one may normalize proofs of typing statements so that the \nonly uses of the Sub rule are immediately following uses Var and Const. That is, the steps in any proof \nof a typing statement may be permuted so that the Sub rule only appears at the leaves of the proof. This \nprop\u00aderty is important because the other four inference rules of this system are syntax-directed. That \nis, there is at most one normal proof of any type assertion up to uses of Sub. This property is used \nin the typing algorithms in [J M88, Mit91] and in all algorithms discussed in this paper. An alternative \nway of stating this proof nor\u00admalization property is that the rules above are equiva\u00adlent to the proof \nsystem obtained by eliminating Sub and replacing Var and Const by variants that allow a constant or variable \nto be given any supertype of its given type. If R is a substitution of types for type variables, then \nwe say R respects a set C of atomic subiyping assertions if, for every a < b in C , the type expres\u00ad \nsion Ra matches Rb . If R respects atomic C , then there is a set C of atomic subtype assertions such \nthat C FRa ~ Rb for every a< bin C, and if C is another set of atomic subtype assertions with this property, \nthen C E C . We write R. C for any such minimal set of atomic subtype assertions. The set R. C is efficiently \ncomputable from R and C , as outlined in [Mit84, Mit 91]. If A is a set of assump\u00ad tions about the types \nof variables, then RA is the set RA={x:Ro Ix:u GA}. Wesay C , A kiVl:&#38; isan instance of C, A F M: \nu if there is some substitution R of types for type variables such that RC 1-C , RA ~A and R~ =O A typing \nC, A 1-M : IS is a most general typing for M , with respect to some signature, if it is derivable and \nhas every other derivable typing statement for M is an inst ante. Theorem 2.1 [Mit84, Mit91] Jf M is \n-typab/e with respect to some signature, then there is a most gen\u00adera! typing statement for M , computable \nfrom M in exponential time. Although the theorem given in [Mit84, Mit91] is only stated for pure lambda \nterms without constant symbols, the algorithm and proof are easily extended to constants with specified \nvariable-free types. The algorithm may also be extended to terms with poly\u00admorphic constants, as described \nin [JM88, Jat89]. It is possible to decide whether a set of atomic subtype assertions is satisfiable \nin a partial order, in nondeter\u00administic time polynomial in the size of assertion set and the present \nation of the partial order. This gives us the following corollary. Corollary 2.2 There is a nondeterministic \nexponen\u00adtial time algon thm for deciding whether a typing 0, A t-M : u is derivable with respect to a \ngiven sig\u00adnature. Type inference, constants and decision problems While the algorithm given in [Mit84, \nMit91] finds the most general type of any pure term, the application of this algorithm to a specific \nprogramming language is relatively subtle. If M does not cent ain constant symbols, then the most general \ntyping for M will only cent ain t ype variables, and type constants do not enter into the problem. With \nboth type and term constants, there are some questions regarding the set of subtype assumptions that \nmight reasonably appear in a typ\u00ading statement. A simple example that illustrates one of the problems \nwith type constants is the signature with type constants int and real, with ant ~ real, and term constants \n1: int , 2: int , mult : int --+ int --+ int and div : real+ real+ real. In this signature, we can multiply \nintegers 1 and 2 by writing mult 12 since both arguments have type integer, and divide by writ\u00ading div \n12 since by the assumption int ~ real, both integers also have type reai. However, consider the expression, \nmult (div 12) 2. This is not well-typed, given the signature, since the subexpression (div 12) only has \ntype reai and not type int. The typing algorithm in [Mit84, Mit91], when extended to constants in the \nsimplest way, would produce a typing statement for this term, namely, real < int F (mu/i (div 12)2) :int \nIntuitively, this typing statements says that if real is a subtype of int, then the expression denotes \nan integer. This is a correct hypothetical statement, but since the hypothesis is false, it does not \nseem to be a useful output from the type checker. The reason that the algorithm infers a typing statement \nwith additional subtype hypotheses is that, in general, this is the only way to obtain most general types. \nHowever, it is not reasonable to change the relationship between int and real by adding new subtypes \nof existing types. There\u00adfore, as in [FM90, W089], it makes sense to design a type checker that fails \non the example expression above. There are several reasonable restrictions on addi\u00adtional subtype assumptions. \nThe first is to reject any term that requires subtype relations not given by the signature. Given a term \nA4 , we must find some t yp\u00ading statement 0, A \\ M : u with empty subt yping hy\u00adpotheses. We call this \nthe typing problem with jixed subtype ordering since the only subtype relations are those fixed by the \nsignature. A second typing problem is to find a typing statement C, A k M : u such that the only required \nrelationships between type constants are those given by the signature. In other words, we require any \ninferred C to be conservative over the sig\u00adnature. We call this the typing problem with varying subtype \norderingl since it is motivated by considering languages where the subtype ordering varies between different \nparts of the program. Conservativity rules out the typing for mult ( div 12) 2 above, since the signature \ndoes not imply real < int . Both of these typing problems may be solved by computing the most general \ntyping for a given term and then testing the set of subtyping assumptions to see if it can be made empty \nor conservative over the signature by applying a type substitution. For a particular programming lan\u00adguage \nwith subtyping, the appropriate typing prob\u00adlem may lie somewhere between these two extremes: additional \ntype declarations will extend the subtype relation conservatively, but it may not be possible to obtain \nall conservative extensions. The typing problems we consider in this paper are summarized in Table 1. \nWe consider both fixed and varying subtype relations, as indicated along the top of the table. Restrictions \non the signature are listed at the left. We consider arbitrary signatures, signatures in which all term \nconstants have non-polymorphic types, and signatures in which the type of each term constant is a type \nconstant. This gives us a two\u00ad dimensional matrix of typing problems. A third di\u00ad mension is to consider \npossible restrictions on the sub\u00ad type relation. With a variable subtype relation, the relation given \nby the signature has little effect. With a fixed subtype relation, we consider both arbitrary partial \norders and lattices. For each of the problems, the table lists an upper bound on the upper line, and \nlower bound on the lower line, with trivial upper and lower bounds omitted. As the reader will readily \nsee, we do not have matching upper and lower bounds for most of the problems listed. It is easy to show \nthat each problem is reducible to the problem above it in Signature Fixed Subtype Relation Varying Subtype \nRelation Arbitrary Lattice Constants of any type F1 NExP upper bound L1 PSPACE upper bound V1 PsPAcE \nupper bound conservative over F2 conservative over L2 conservative over V2 No polymorphic types F2 reducible \ntoFl L2 reducible toLl V2 reducible toVl conservative over F3 conservative over L3 conservative over \nV3 Atomic types only F3 reducible to F1 L3 linear time V3 linear time NP lower bound linear time linear \ntime Table 1: Summary of problems and results. Lower bounds for F1-3 and upper bounds for L1-3 and Vi-3. \nthe table, and conservative over the problem below it. ture E = (1?, S, T) , where all constants have \nThis is because all are defined using the same proof atomic type, determine whether there exists a rules. \nThe linear upper bound for problem L3 actu-provable typing statement C, A 1-M : u such ally holds for \nany order that is the disjoint union of that for all type constants bl, b2 G B , we have any number of \npartial orders with maximum elements. CUSkb1~b2iff St b1<b2. We state problems F1-3,, and Vi 3 in full \nbelow. An example may help clarify the difference Problems L1-3 are identical to F1 3, respectively, \nex\u00adbetween problems F1 and V1. The term cept that the subtype order must be a lattice. (Av.((b.(v CI))(W \nCa))) is typable in the signature Fl: Given an untyped lambda term M, possibly con-with two constants \nc1 :8= , C2 : 8b and empty subtyp\u00adtaining constant symbols from some signature X , ing relation, according \nto the constraints of V1 but determine whether there exists a provable typing not F 1. The reason is \nthat the variable v must have statement @,A ~ M : u without additional sub\u00ad type u + ~ for some o greater \nthan 8. and db . typing assumptions. A variation we will not consider is to give more in\u00adformation about \na term to be typed. For example,F2: Given an untyped lambda term M , possibly con\u00adwe could give term \nh4 and type u , and ask whether taining constant symbols from some signature E , there is a provable \ntyping statement C, A F M : u . where all constants have variable-free type, deter-This might appear \neasier than the type decision prob\u00admine whether there exists a provable typing state\u00adlem, since the added \ninformation could narrow the ment @,A t M : u without additional subt yping range of possibilities to \nconsider. However, it is easy toassumptions. see that an arbitrary term M has a type iff the term F3: \nGiven an untyped lambda term M , possibly con-Ax. KzM has type T + T , where K is the lambda taining \nconstant symbols from some signature Z , term k. ~y. z . Therefore, it does not help to supply where \nall constants have atomic type, determine a type. whether there exists a provable typing statement 0, \nA h M : u without additional subtyping as\u00ad sumptions. 4 Subtype Inference is NP-Hard Vl: Given an untyped \nlambda term M , possibly con- Wand and O Keefe give an argument for the NP\u00ad taining constant symbols \nfrom some signature hardness of type inference which requires the use of a Z = (B, S, T) , determine \nwhether there exists constant of polymorphic type, specifically, a constant a provable typing statement \nC, A t M : u such T with polymorphic type Va.(a + a + a) [W089], that for all type constants bl, b2 c \nB , we have roughly corresponding to our problem F 1. In this sec\u00ad CUSt-bl ~b2iff St\u00ad bl<b2. tion we \nimprove their lower bound by proving that V2: Given an untyped lambda term M, possibly containing constant \nsymbols from some signa\u00adture Z = (B, S, T) , where all constants have variable-free type, determine whether \nthere exists a provable typing statement C, A 1-M : u such that for all type constants bl, ba ~ B , we \nhave CUSkb1~b2iff Sk bl~b2. the strictly weaker problem F3 is iw-hard. Since F2 and F1 are conservative \nover F3, this lower bound also applies to these problems. We will reduce POL-SAT, stated as follows, \nto F3. Given a partial order (P,<) and a set of inequalities I of the form p < w, w < w , where w and \nw are variables, and p is a constant drawn from P , is there is an assignment from variables to members \nof P that V3: Given an untyped lambda term M , possibly satisfies all the inequalities 1 ? This problem \nis very containing constant symbols from some signa\u00ad similar to PO-SAT, proven NP-complete by Wand and \n Figure 1: poset for O Keefe [W089]. PO-SAT differs from POL.SAT in that it allows inequalities of the \nform w < p, which amount to upper bounds. PO-SAT may also be described as the satisfiability problem \nfor inequations over a poset. Similarly, POL-SAT is also the satisfiability problem for inequations over \na poset with the added restriction that no inequations have the form w < p for variable w and constant \np. We first show that POL-SAT is NP-complete, and then show that POL-SAT reduces to F3. Lemma 4.1 POL-SAT \nis NP-cornpiete. Proof. It is easy to see that this problem is in NP, since one may simply guess an assignment \nof constants to variables, and check that every inequality in I is satisfied. To show that this problem \nis Np-hard, we give a reduction from 3-SAT. We begin with the empty set A , and for each clause Clausei \n= Pil V Pi2 V F ~3, we add the element named C i to A , and further add 7 more elements to A , one for \neach truth as\u00adsignment which sat isfies the clause. For convenience, we name these 7 elements by simply \nconcatenating the names of the clauses with the names of the vari\u00adables they cent ain, using overbars \nto denote negation: C~P~~P~zP~3 , C~P~lPiz~ , CiP~~~Pi~ , etc. For each propositional variable Pj , \nwe add three el\u00adements to A ,named Pj , PJ+ , and Pj._ . In\u00adtuitively, these stand for the j-th proposition \nbeing undecided, true, and false, respectively. With the above set of constants, we define a par\u00adtial \norder relation < on them as follows. We define the relation RP,OP to include, for each proposition pi \n, Pi+ < Pi and Pi ~ Pi . We define the rela\u00adtion RClau~e to include, for each clause Clausei = Pil V \nPi2 V Pi3 occurring in the 3-SAT problem, and each truth assignment which satisfies the clause, Ci < \nc~pil P~2Pi3 . We also define the relation Rtvue to include, for each clause Clause~ = Pil V P~Z V Pis \n, and each proposition in that clause Pij , a relation P+ < CiPil Pi2Pi3 for each of the 3 or 4 clause \nel~ments which correspond to Pij being true, Simi\u00adlarly, we define the relation R~at$e to include, for \neach (P VQ)A(QV=R) clause Clausei = Pil V Pi2 V Pi3 , and each proposi\u00adtion in that clause Pij , a relation \npi; < Ci 1%1Pizl is for each of the 3 or 4 clause types which correspond to Pij being false. The final \npartial order of inter\u00ad est wilI be (A, RProP U Rcl.use U Rtrue U Rjar,e) . The partial order has height \none, and contains 8 ( = 23) el\u00adements for each 3-SAT clause, plus three elements for each proposition. \nFigure 1 displays the partial order produced for the SAT problem (P V Q) A (Q V vR) . Clauses of length \ntwo were used, and the name pq was used in place of Clpq , for example, in Figure 1 to improve readability. \n We use a set of variables, one Wpj and one wuj for each proposition Pj , and one wcj for each clause \nClaUSej . We define a set of inequations IC1aU.e to include, for each-clause Clausei = Pil V Pi2 V Pi3 \n, the inequality Ci < Wci , and for each proposition Pij in that clause, wpij < Wci . We also define \na set of inequations lP~oP to include, for each proposition Pi , wpi ~ wui and Pi ~ wui . Thus there \nare four inequalities in IC1aU~e per 3-SAT clause, and two in\u00adequalities in IPVOP for each proposition. \nContinuing with our simple example, (P V Q) A (Q V -IR) , the inequations Icl.u,, = {Cl ~ WC1, WPP d \nWC1, Wpq S Wcl, C2 < WC2, Wpq < WC2J Wpr < WC2) , and IPTOP = {WPP < WUP,WP, < Wuq, wpr < WU., P < WUP, \nQ 5 Wuq, R < WUr} We claim that the POL-SAT problem given by the partial order (A, R prop U fkause U \n.&#38;rue U Rfatse ) , with the inequalities IP.OP U IC1aU~e has a solution if and only if the original \n3-SAT problem has one. This may be observed by noting that every wci must be assigned some CiPil Pi2Pi3 \n, since wci must be greater than Ci and some propositions. Also, the only CiPi1Pi2Pi3 which exist in \nA correspond to assign\u00adments of propositions which satisfy the clause. Fur\u00adther, wuj must be assigned \nPj , and wpj must be assigned either P}+ or Pj~ . We claim there is a cor\u00ad respondence between a proposition \nPj being assigned true (or false, resp.) in the 3-SAT problem, and Wj being assigned Pj+ ( Pj: , resp.) \nin the PO L-SAT prob\u00ad lem. Thus one may see that a solution to the 3-SAT may be derived from any solution \nto the constructed POL-SAT problem and vice-versa. _ This construction may be simplified somewhat, by \nomitting the inequalities 1pt.op , and the elements Pj (nodes labeled P, Q, and R in the example poset). \nIn this case the correctness of the reduction is more difficult to establish. However, in either case \nthe con\u00adstructed poset has depth one, and both the poset and the set of inequalities have size linear \nin the input 3-SAT problem. Lemma 4.2 POL-SAT reduces to F$. Proof. A POL-SAT problem is given with par\u00ad \ntial order (P, <) , set of variables W, and set of inequalities 1. We define the set of type constants \nB = {13~lpi G P}, and a set of constants and their typings T = {ci : Oi ]Pi 6 P}. That is, for each ele\u00ad \nment of the POL-SAT partial order, we define a type t$ , and a constant of that type c~ . We define S \nto be a set of atomic coercions such that for each pi < pj in the POL-SAT partial order, Oi ~ Oj is in \nS. That is, we simply copy the partial order from the POL-SAT problem into a set of subt ype assertions \nabout corresponding type constants. We then collect the above together into a signature E=(l?,S,T). For \neach variable Wi appearing in any inequality in the POL-SAT problem, we define the notation for two lambda \nterm variables vi and ui . We number the m inequalities I in the POL-SAT problem il, ..., i~ , and define \nthe translation [ij] of inequalities aS follows: = (Vz c,) (.PY 5 %1 [w 5 w,] = (v, (Vc uC))  Finally, \nwe build the term (Au,. $. .(hln.(. . .((AV,. . . .(Avn. ((kc. [i,]) ((kr.[iz]) ~~. ((Ax. [im_,])[im]) \n~. )) (Ar.r))(k.%)) . . .(AZ.Z)) ~~.))) In words, we encode each lower bound on a variable as an application \nof that variable to the corresponding constant, and encode each relation bet ween variables VI and V2 \nas an application of VI to the result of applying vz to uz . The variable U2 only serves as a dummy variable \nto which one can apply V2 . If the partial order has a bottom element, one could replace all uses of \nu variables with a single constant with the type of the bottom element of partial order. We build an \nabstraction over the set of function variables vi , with a body that includes a subterm for each inequal\u00adit \ny, but throws all the results away except the first. We tie the upper and lower bounds on each function \nvariable together by applying each abstraction to the identity function (~a .x) , and finally abstract \nover the u variables. Figure 2: Fixed NP-hard poset We claim without proof that this term is typable \nif and only if the corresponding POL-SAT problem haa a solution. _ Thus we have shown that F3 suffices \nto capture the essential NP-hardness oft ype checking with subtypes. As stated above, Wand and O Keefe \nshow that PO-SAT reduces to F 1 [W089]. However, there also exists a straightforward extension of the \nabove into a reduction from PO-SAT to F2: define the constant c~ to be of type t% -+ Oi, and [w. < Py] \n= (c: (v. u,)). Of course, there are reductions from F3 to F2, and F2 to F1, since the problems strictly \nsubsume each other. Theorem 4.3 F3, F2, and F1 are m-hard. Proof. F3 is NP-hard from the above two lemmas, \nand F2 and F1 are conservative over F3, so the result follows immediately. _ Recent work by Pratt and \nTiuryn [PT91] has shown that PO-SAT remains Np-complete for certain fixed posets. Our construction builds \na different poset and set of inequations for each 3-SAT problem. Pratt s construction builds a different \nset of inequalities over a fixed poset, although it uses inequations of the form w < p. Thus Pratt s \nresult subsumes the m-hardness of PO-SAT. With a simple modification, Pratt s NP\u00adhardness result can \nbe extended to cover the case of restricted inequalities, which corresponds to POL-SAT. Pratt shows that \nPO-SAT is m-complete even over the fixed poset containing only four elements, drawn in Figure 2. The \nfollowing reduction from PO-SAT to POL-SAT, although not sound in general, is correct for this particular \nposet. Thus POL-SAT is also m-hard for this poset. Given a set of inequations, we must translate them \ninto a form where no upper bounds w < p appear for variable w and constant p. We add two new variables, \nW. and Wb , and the new in\u00ad equalities {a < W., b < Wb}. We then translate all upper bounds (which are \ndisallowed in POL-SAT) as: [w<a]={w <w.} [w< b]={w<wb} If c is used as an upper bound on some variable \nw , then simply replace w by c in the entire set of inequa\u00adtions, and similarly for d. Thus even for \nfixed posets with aa few as four elements POL-SAT is NP-complete. Through the reduction stated formally \nin Lemma 4.2, we therefore have the result that I?3 is m-hard even for fixed posets. Theorem 4.4 F3, \nF2, and F1 are rw-hard for a jixed posets with four elements. Note that the above m-hardness results \nfor POL-SAT and PO-SAT make critical use of non-lattice partial orders. In fact, we have the following \nproperties: Proposition 4.5 PO-SAT is solvable in polynomia[ time over a lattice. Proposition 4.6 POI,-SAT \nis sotvable in polynomial time over a lattice. These results lead to a polynomial algorithm for L3, as \nstated later in Proposition 6.2. At an intuitive level problem V3 allows one to complete the given partial \norder into a lattice, leading to a similar polynomial time algorithm for V3 as well. Thus the NP-hardness \nresults of this section apply only to the problems F1-3, and do not directly apply to L1-3 nor to VI-3. \n 5 Subtype Inference in PSPACE In this section we investigate the computational com\u00adplexity of problems \nV1 and L1. We give a PSPACE algorithm for V1 and then show that the same algo\u00adrithm also solves problem \nL1. The algorithms proposed in earlier papers to solve V1 (or Fl) suffer from two sources of inefficiency. \nThe first source of inefficiency is the non-lattice structure of subtype orders in the signature. These \nlend a cer\u00adtain NP flavor to the decision problem. The second source of inefficiency is the MATCH (and \nSIMPLIFY) al\u00adgorithm, which forces subtype relationships between complex types into sets of subtype relationships \nbe\u00adtween atomic types. The expansion of type inequal\u00adities c(to the leaves) causes an exponential blowup \nin the inequalities, and thus causes previous algorithms to use exponential space and time. To overcome \nthis obstacle, we develop a data structure of linear size and associated naming convention for new type \nvariables which allow us to represent the required subtype re\u00adlationships succinctly. Using this approach, \nwe may decide typability in PSPACE. Rather than present a deterministic PSPACE algo\u00adrithm directly, we \ngive a nondeterministic PSPACE algorithm that recognizes untypable terms. Since NPSPACE = PSPACE and \nPSPACE is closed under com\u00adplement, this gives us a PSPACE upper bound. Our algorithm begins by building \na proof up to uses of Sub. As discussed earlier this amounts to a normal form for the type derivation \nproof, except that the proofs above Sub are left incomplete. Next the DAG representation of the Curry-type \nof the term is com\u00adputed, as if the type of each constant and variable were renamed with new type variables \nat each leaf occur\u00adrence. In [Wan87] an algorithm similar to ours up to this point is presented. However, \nin our algorithm, the Sub rule presents a new kind of relation, and we ac\u00adtually solve the equations \ngenerated by the algorithm in [Wan87] with unification, producing a DAG which represents the types of \nall subterms. Note that the unifications performed at this step never fail, due to type renaming, as \nis the case in [Hin89]. At each leaf a constraint u ~ r is generated by the Sub rule, which we encode \nas a dashed arc on the DAG. Note that these inequalities (represented by dashed arcs) may in\u00advolve terms \nsuch as n + /3 containing function types. We will call the arcs forming the original DAG descen\u00ad dent \narcs and dashed arcs due to uses of the Sub rule sub arcs. We say a term Al is Curry-typable over signature \nX = (B, S, T) , if M is typable over the signature X = (1?, S , T) , where S is the complete relation \n(all atomic types are related, and thus all atomic types are interchangeable). Lemma 5.1 Given a term \nM , possibiy containing constant symbols from some signature X = (B, S, T) , then M is Curry-iypable \nover E if and only if there is a provable typing statement C, A 1-M :0 over 22 where C may have any relationship \nto S. Lemma 5.2 Given a Curry-typable untyped lambda term M , possibly containing constant symbols from \nsome signature X = (B, S, T) , then VI is solvable for M if and only if the most general typing statement \nC, A k M : u for M provable with respect to .X is such that Qbl, bz. if CUSt bl < b2 then S t bl ~ b2. \nThus there are two kinds of type failure for V1. The first is failure of Curry-typability, which occurs \nwhen a type variable is required to match its own an\u00adcestor or descendant because of coercions, For ex\u00adample, \nterms with self application, such as h.(z z) , are impossible to type. The second type of failure, implication \nof nonexistent coercion, occurs if there is some chain or sequence of implied coerci~ns 19i < al , al \n~ U2, . . ..un_1 ~ CTn,Un < Oj such that it is not the case that St-Oi ~ (?j . The first type of failure \nis relatively easy to detect, and may be checked in linear time. If one considers the sub arcs of the \nDAG to be undirected, the first type of failure occurs if and only if the DAG contains a cycle which \ncontains at least one descendent arc. This condition may be checked in linear time by considering the \nthe sub arcs to be equations between parts of the DAG made up of descendent arcs. The DAG and the The \nalgorithm then repeatedly guesses types and (3@--m paths in this way such that for guess i , the relation \nTi _ 1 ~ ri is implied. Finally, the algorithm guesses types such that rn <02 is implied. If this algorithm \nsucceeds in all these steps, the term is not t ypable. That is, the algorithm as described nondeterministi\u00ad \ncally checks nun-typability in PSPACE. As an example of the second type of failure, con\u00ad  @n) Figure4: \nUntypable Self Application s DAG sider the attempted derivation of a type for the resulting unification \nprobiem are of linear size, and unification may be performed in linear time [PW78]. For example, consider \nthe attempted typing of ~x.(x x) shown in Figure 3. This is the unique syntax\u00addirected proof, up to II \nand A , which are left in\u00adcomplete by the algorithm. However, the coercions a ~ /3 -+ cr and a ~ ~ have \na derived inconsistency. That is, ~ must match /3 -n, and thus no sub\u00adstitution of types for type variables \ncan satisfy those inequations. Figure 4 displays the two color DAG our algorithm builds for this term. \nThe DAG which rep\u00adresents the type of all subterms is represented with descendent arcs shown as solid \narcs in Figure 4. The dashed arcs in that figure represent sub arcs. Assuming that the first type of \nfailure does not oc\u00adcur, we must detect the second. One could imagine converting all subtype relations \nbetween non-atomic types into relations between atomic types, and then searching for a solution to that \neasier problem. How\u00adever, an exponential number of atomic subtype rela\u00adtions may be generated by such \na procedure. The algorithm presented below avoids this blowup. For each type variable a , we use the \nnotation al and a, , where their relationship with a is defined by a = al + ay . This is simply notation; \nwe do not explicitly construct all such type variables, and the notation is meaningless if a is of atomic \ntype. We define a path to be a string on the alphabet {1, r} , and we use o as path concatenation. We \ndefine the relation implied by a sub arc from a to c through path p as follows. If p is empty, then the \nsub arc simply signifies that a < a . If p = r op , then the sub arc implies the same relation as the \nsub arc from c+ to CT through path p . If p = 10 p , then the arc implies the same relation as the arc \nfrom al to CYl through path pl . Note that because of the antimonotonic Arrow rule, the sub arc in the \n1 case has changed direction. The algorithm begins by guessing two atomic type constants 61 and 02 which \nare not in the relation 01 <02 in the given signature. Then the algorithm guesses two types c and a and \na path p such that there is a dashed arc from u to a and the relation im\u00adplied by this arc from u to \nCY through p is 01 < T1 . Or the algorithm guesses that ~1 is a type constant Oi such that S t-61< Oi. \nterm (( Av.(odd? (v 5.7))) (kc.x)) in the signature with three types constants, int , real, and bool, \nwith the only subtype assumption enforcing that int~ real , and two constants, odd? : int + bool and \n5.7: real . We give the derivation in parts, leaving the proofs numbered 1.. .4 incomplete, just as our \nalgorithm would do, in Figures 5, 6, and 7. We may now see that this term has no type satis\u00adfying the \nrestrictions of V1. From the required sub\u00adtype relation marked 1 in the above proof display, int --+ \nbool < ct + ~ . From this, by the arrow rule, we must have booi ~ ~ and a < int . Similarly, from the \nrequired subtype relation marked 2 in the above proof display, a --+ -y < r --+ a , which implies y ~ \na and ~ < a . Using these subtype relations, and those from 3and 4, real ~ T and ~~7, wemay build the \nfollowing chain of subtype relations: We now describe how our algorithm would discover this inconsistency \nwith the given partial order. First, it would build the proof up to the applications of Sub, creating \nthe DAG as described above, a fragment of which is represented in Figure 8. The algorithm then guesses \nthat a derived inconsistency lies in the sub\u00adtype relation real ~ int . It then guesses the sub arc from \n~ to real , and the empty path. This implies real ~ r. It then guesses the sub arc from r --+ a to a+ \n~ ,and the path i . This implies r ~ a. The next guess is the sub arc from ~ to u , with the empty path, \nimplying a ~ y . Then the sub arc from ~ + a to o --+ -y is guessed again, this time with path r , implying \n7 ~ a . The last guess is the sub arc from a--+ /3 to int --+ bool , with path r, implying a ~ int . \nThe last step is through a part of the DAG not repre\u00adsented in Figure 8. Thus the algorithm finds a chain \nof types which together imply real ~ int , contradicting the given signature. Theorem 5.3 Problem VI \nis solvable in PSPACEi. Proof. The untypability algorithm described above operates in polynomial space, \nsince the prepro\u00adcessing phases building the DAG may be completed in linear time and space, and the nondeterministic \nsequence of choices can be made with only linearly bounded storage space, since the depth of the curry\u00adtype \nis linearly bounded. Because PSPACE is closed C,{z:a}kx:darckdhu Sub c,{x:a}Fx:av r Cta<p Sub c,{z:cr}F3:@+a \nC,{x:a}t-z:p APp C,{%: a}t(zz):u Abs c, Ol-Ax.(z2):cf-+u Figure 3: Untypable Term s Attempted Derivation \nC,{v:o--+~} t odd? :int+boolco st C,{v:n+y} CUSt l-odd? :~+P 1 int--+booi~ a+/3 sub Figure 5: Partial \nderivation A c,{v:a+~}+v:a+y Var C,{v:a+y}l-v:r+a Cusl-o-+ -(-jr+a 2 c,{v:a+7} SUb C,{v:o+y} E(v5.7):cl \nt_5.7:reaic0nst c,{v:u+7} 3 CUSl_rea/<r l-5.7:7- Sub APp Figure 6: Partial derivation H C,{v:u+-y} A \ntodd?:w+~ C, {V : a+y} C,@ } (~v.(odd? II c,{v:a+7} h(v5.7):ck t\u00ad(odd? (V 5.7)) :~ (V 5.7))): (a+-y) \n+~ C,@ t-(( Av.(odd? (V 5.7))) App Abs (~X.X)) C,{ Z:a}EHvarCu S\\a c,{x:a}Ez: y c, OtAx.x:u+~ : @ 4 \nST Ab, Sub AI Figure 7: Whole derivation Figure 8: Fragment of Untypable Term s DAG under complement, \nthis demonstrates the existence of 6 L3,F3 are Polynomial a PSPACE algorithm. D We now turn our attention \nto problems L1-3. In this section we present a linear time algorithm for L3, the restricted case of problem \nF3 where the given Lemma 5.4 L1 and F1 are solvable for term M over subtype order is a lattice. This \nalgorithm also extends signature 2 if and only if M is Curry typable and to F3 where the order is the \nsum of partial orders, each C, A } M : u, the most general typing statement for with its own top element. \nThat is, partial orders with M, is such that C is satisfiable over X . the property that there is a unique \nleast upper bound of the upper bounds of any element. Also, this al- Proof. Immediate from the problem \ndefinitions and gorithm extends to V3 over any partial order. Since Theorem 2.1. The key here is that \nif C is satisfi\u00adproblem F3 is Iw-hard in general, we see that minor able over E, then there is some substitution \nR and assumptions about the subtype order permit great re\u00ad provable instance 0, RA 1-M : RF. m ductions \nin the computational complexity of the as- The following lemma states that problem L1 is es\u00adsociated \ndecision problems. Also, small amounts of sentially the same as problem VI if the partial order flexibility \nin the subtype order (V3) permit similar re\u00ad is already a lattice. ductions in the computational complexity. \nLemma 5.5 If (B, S) forms a lattice and C is a In [W089], it is claimed that subtype inference may set \nof atomic subtyping assertions, possibly involving be performed in low order polynomial time if the \ngiven constants from B , then C is satisfiable over (B, S) subtype order in the signature happens to \nbe a tree. if and only if for every pair of constants bl , bz from However, we have found examples where \nthe algorithm B,if CUStb1~b2 then St-bl<b2. suggested in [W089] uses exponential space and time. Proof. \nSuppose that for every pair of constants Lemma 6.1 Let X be a signature in which all con\u00ad bl, b2from \nB,if CUSkb1<b2 then Skbl< stants have atomic type. If M is an untyped term b2 . We show C is satisfiable \nby giving a satisfying over X , then in the most general typing for M , all assignment. For each variable \nz in C , let LB(s) be subtype assumptions have the form p < w , w < w , the set of elements b of B such \nthat C US 1-b< x . where w and w are variables, and p is a type con- We assign variable x the least upper \nbound of the stant from E . set .LB(z) . This upper bound exists since (B, S) is a lattice. To show that \nthis assignment satisfies C, we consider three cases: Proposition 6.2 L3 is solvable in linear time. \n For b< z,it is the case that bc LB(z) ,so ~ Proof. Again, we solve the decision problem without is assigned \nan element of B that is greater than producing a most general typing. By Lemma 6.1, the or equal to \nb. only relevant subtyping constraints are lower bounds For z < y, we have by transitivity that LB(z) \nC on the types of terms. Thus one could choose to build LB(y) , so y is assigned an upper bound of all \ntypes of subterms from the topmost type constant. LB(x) , so x is assigned some element of B that Since \nall types are subsumed by the topmost type con\u00adis less than or equal to y. stant this choice will not \nlead to any type errors which are not inevitable. One may view this as collapsing the For x < b , we \nhave to use the hypothesis of the entire poset down to the single topmost point. lemma. By hypothesis, \nb b . b E LB(x) , then Thus our algorithm can be described as follows: C U S 1-b < b and so b ~ b. Therefore \nthe least replace all constants in the given term by a single upper bound of LB(z) 1s less than or equal \nto fixed constant of topmost type and then apply the b. well-known linear algorithm for determining \nCurry\u00ad_ typability. If the resulting term is Curry-typable, then the given term is typable with subtypes. \nIf the modi- Theorem 5.6 Probtems Ll, L2, and L9 are solvable fied term is not Curry-typable, then the \noriginal term in PSPACE. is not typable. _ We now consider a somewhat more general problem. A connected \ncomponent of signature subset Proof. We begin by observing that the only proper\u00ad ties specific to problem \nV1 that are used in the proof is a of the elements of the signature which is connected if the of Theorem \n5.3 are stated in Lemmas 5.1 and 5.2. subtype relation is taken to be bidirectional. Since Lemmas 5,4 \nand 505 characterize problem L1 in exactly the same way, the proof of Theorem 5.3 also shows that L1 \nalso may be solved in PSPACE. By the Proposition 6.3 F3 is solvable in linear time if every obvious conservativity, \nwe have the result for L2 and connected component of the signature has a topmost L3. _ element. Proof. \nSimilar to 6.2. In this case, replace each con\u00adstant of type T with a constant of the topmost type connected \nto r. One may view this as collapsing all connected components into their individual topmost elements. \nThe result is a completely flat partial order, over which Curry-typability works in linear time with \nsmall modification. _ Special cases of this class of (easy signatures in\u00adclude flat partial orders, lattices, \ntrees, forests, etc. Proposition 6.4 V3 is solvable in linear time. Intuitively, V3 allows new elements \nto be added to the signature. Thus we may simply add a top element to the signature, and then check typability \nas above in Proposition 6.2. Thus F3 is NP-hard over certain partial orders, but V3 is solvable in linear \ntime over any partial order. 7 Conclusion We identify and study several variations on the type inference \nproblem for languages with subtypes. We give a single NP lower bound for three of these prob\u00adlems, improving \nthe previous lower bound of [W089]. Since the size of the most general typing of a term may be exponentially \nlarger than the given term, any algorithm which prints the most general typing with subtypes must take \nexponential time. However, we show that it is possible to determine whether a term is typable at all \nusing only PSPACE for VI 3 and L1 3. We do not know whether this algorithm can be im\u00adproved to run in \nNP, and have no useful lower bound on VI 2 or L1 2. The most promising indication for practical appli\u00adcations \nis that typing over special partial orders (such as lattices) and varying subtype relations (as would \narise in languages with subtype declarations) may be far simpler than typing over arbitrary partial orders. \nWe have seen this in the difference between problem F3 and L3 and V3: while L3, over arbitrary partial \norders, is NP-hard, the restriction, L3, to lattices may be solved in linear time and so may the correspond\u00ading \nproblem, V3, for languages with varying subtype relations. These results show that the complexity of \ntype inference is sensitive to the kind of subtype rela\u00adtion that may occur in a given programming language, \nand whether this order may vary. In designing type inference algorithms for languages with type declarations \n(and therefore varying subtype relations), we believe it will be useful to take into ac\u00adcount the ways \nthat the subtype relation may change. To give an concrete example, suppose that in language L subtype \ndeclarations may only add new subtypes, not supertypes of existing types. Then in defining a type checker \nfor language L, we would like to reject any declaration that will only make sense when su\u00adpertypes of \nexisting types are added. In general, we expect to find typing problems that are special cases of both \nour fixed and varying subtype problems, with only certain kinds of subtype relations definable by programs, \nand only certain kinds of variations achiev\u00adable by additional type declarations.  References [FM90] \nY. Fuh and P. Mishra. Type inference with sub\u00adtypes. I%eor. Computer Science, 73, 1990. [Hin89] J.R. \nHindley. BCK-combinators and linear A \u00adterms have types. Theor. Comp. SCZ., 64:97\u00ad105, 1989. [Jat89] \nL. Jategaonkar. ML with extended pattern matching and subtypes. Master s thesis, MIT, 1989. [JM88] L. \nJategaonkar and J.C. Mitchell. ML with ex\u00adtended pattern matching and subtypes. In Proc. ACM Symp. Lisp \nand Functional Programming Languages, pages 198-212, July 1988. [KMM91] P.C. Kanellakis, H,G. Mairson, \nand J.C. Mitchell. Unification and ML type reconstruc\u00adtion. In Computational Logic, essays in honor of \nAlan Robinson, page to appear. MIT Press, 1991. [Mey88] B. Meyer. Object-Oriented Software Construc\u00adtion. \nPrentice-Hall, 1988. [Mit84] J.C. Mitchell. Coercion and type inference (summary). In Proc. Ilth A CM \nSymp. on Pr-in\u00adciples of Programming Languages, pages 175 185, January 1984. [Mit91] J.C. Mitchell. Type \ninference with simple sub\u00adtypes. J. Functional Programming, 1(3):245\u00ad286, 1991. [PT91] V. Pratt and J. \nTiuryn. Satisfiability of inequa\u00adtions in a poset. Manuscript, October 1991. [PW78] M.S. Paterson and \nM.N. Wegman. Linear uni\u00adfication. JCSS, 16:158-167, 1978. [Str86] B. Stroustrop. The C++ Programming \nLan\u00adguage. Addison-Wesley, 1986. [T1U91] J. Tluryn. Solving term inequalities is PSPACE hard. Manuscript, \nOctober 1991. [VJan87] M. Wand. A simple algorithm and proof for type inference. Fundamental Informaticae, \n10:115 122, 1987. [Wan91] M. Wand. Personal communication, 1991. [W089] M. Wand and P. O Keefe. On the \ncomplexity of type inference with coercion. In Proc. ACM Conf. Functional Programming and Computer Architecture, \npages 293-298, 1989.  \n\t\t\t", "proc_id": "143165", "abstract": "<p>We study the complexity of type inference for programming languages with subtypes. There are three language variations that effect the problem: (i) basic functions may have polymorphic or more limited types, (ii) the subtype hierarchy may be fixed or vary as a result of subtype declarations within a program, and (iii) the subtype hierarchy may be an arbitrary partial order or may have a more restricted form, such as a tree or lattice. The naive algorithm for infering a most general polymorphic type, undervariable subtype hypotheses, requires deterministic exponential time. If we fix the subtype ordering, this upper bound grows to nondeterministic exponential time. We show that it is NP-hard to decide whether a lambda term has a type with respect to a fixed subtype hierarchy (involving only atomic type names). This lower bound applies to monomorphic or polymorphic languages. We give PSPACE upper bounds for deciding polymorphic typability if the subtype hierarchy has a lattice structure or the subtype hierarchy varies arbitrarily. We also give a polynomial time algorithm for the limited case where there are of no function constants and the type hierarchy is either variable or any fixed lattice.</p>", "authors": [{"name": "Patrick Lincoln", "author_profile_id": "81409595337", "affiliation": "", "person_id": "PP14149701", "email_address": "", "orcid_id": ""}, {"name": "John C. Mitchell", "author_profile_id": "81338490160", "affiliation": "", "person_id": "PP43125642", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143227", "year": "1992", "article_id": "143227", "conference": "POPL", "title": "Algorithmic aspects of type inference with subtypes", "url": "http://dl.acm.org/citation.cfm?id=143227"}