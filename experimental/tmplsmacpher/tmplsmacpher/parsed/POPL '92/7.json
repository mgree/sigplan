{"article_publication_date": "02-01-1992", "fulltext": "\n Inductive Definitions, Semantics and Abstract Interpretation* Patrick Cousot Radhia Cousot LIENS, Ecole \nNormale Sup4rieure LIX, Ecole Polytechnique 45, rue d Ulm 91128 Palaiseau cedex (France) 75230 Paris \ncedex 05 (France) cousot&#38;hai .ens.fr cousot~polyteclrmique. f r Abstract 1.1 Rule-based inductive \ndefinitions Example 1 (Even numbers) Let the urziuewe U be We introduce and illustrate a specification \nmethod combin\u00ad the set N of natural numbers. The subset 2Jf/ of even ing rule-based inductive definitions, \nwell-founded induc\u00adnumbers can be defined by the following axiom and tion principles, fixed-point theory \nand abstract interpre\u00adtation for general use in computer science. Finite as well nG2!N rule schema: \n0E2JV (1) as infinite objects can be specified, at various levels of de\u00ad mi-am tails related by abstraction. \nGeneral proof principles are Instead of considering a formal lan~uage for writing applicable to prove \nproperties of the specified objects. such rules and axiomts schemata, we reason upon a set The specification \nmethod is illustrated by introducing @ of rules instances where axioms have empty premis- G-SOS, a structured \noperational semantics generalizing nEN es: ~= ~\\, u {n} Plotkin s [28] structured operational semantics \n(SOS) so (2) { Oj { n+2 } as to describe the finite, as well as the infinite behav- The induced operator \nis: iors of programs in a uniform way and by con:)tructively 3(X) ={ O] U{n+21{n} <X} (3) denotational, \npredicate transformers, . . . ) semantics from Let the basis be 1 = UIand the join be U which induces \nGrn SOS by abstract interpretation. the ordering ~. The ~-smallest set IO! greater than 1 which satisfies \nthe rules @ is the least fixpoint of ~ that is 2Af = ? = (Jn>o&#38; where @+ = 1 = @and -+1 deriving \ninductive presentations of the other (relational, 1 Inductive definitions @ =3( F)={ O:12,..., 2nj. The \nclosure ordinal of = is the first infinite limit ordinal w. o We now give a genera,l set-theoretic definition \nof such Inductive definitions which are widely used in math\u00adematical logic to define sets inductively \ngenerated by inductive definitions. ?Ve write P(S) for the powerset of the set S and S * S (respectively \nS s S ) for the closure conditions, have popularized in computer sci\u00adset of total (respectively partial) \nmaps from S into the ence over the past few years. Classical or positive set S. inductive definitions, \nco-inductive, kernel or negative definitions [1] as well as bl-inductive definitions mixing Definition \n2 (Inductive definition) An induc\u00ad these two kinds of definitions are first captured by a tive definition \n~ is a quadruple (U, 0, J-, I-I) such general definition of the notion of rule-based inductive that: \ndefinition which is then generalized to systems of it\u00ad . The uniwerse U is a set, erated inductive definitions \nso as to define inductively . @ is a set of rules instances ~ where P ~ U and cartesian products of sets \nof finite and infinite objects CEU,indexed by a welLfounded ordering. Examples show . 1 c 17 is the basis,that \nmany concepts related to programming come out . U c p(gr(i7)) % PI(V) k the join and the induced of such \ninductive definitions. ordering is x ~ y ~f x U y ==y k a partial order on *This work was supported in \npart by Esprit BRA 3124 p(u). S&#38;mantique and Greco CNRS C3. o Permission to copy without fee all \nor part of this material is granted Definition 3 (Operator induced by an induc\u00ad provided that the copies \nare not made or distributed for direct tive definition) The operator ~ induced by 5 = conunercisl sdvantsge, \nthe ACM copyright notice and the title of the (U, q, -L, U) is ~ c p(?l) ++ gJ(U) such thatl: publication \nsnd its date appear, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy other\u00ad 1 More generality can be obtained when replacing ~ by en wise, or to republish, \nrequires a fee and/or specific permission. erbltrary relation. @ 1992 ACM 089791-453-8/92/0001/0083 $1.50 \nF(X)= {C GU13PZX: +) (4) o Definition 4 (Iteration of an operator) The zter\u00adaiion of F ES++S for u 6 \nP(S) ~ S is the Partial operator Fu c S w S such that FUW(x) = Fe where: .F =x, . F~ ==F(Ua<~ Fa) if \nO< A~Ord, F~ =Fe if}>e. cl;; (F) ~f c is called the closure ordinal of F for X. o A complete partial \norder L (~, J_, U) (cpo for short) is a set partially ordered by ~ such that all increasing chains C \nhave least upper bounds Uc and 1 E L (~ is usually the infimum of L). It is a complete lattice if and \nonly if all subsets X have least upper bounds UX and therefore greatest lower bounds nx (in which case \nwe usually write J-= n~ and T = uL). F c L H L is monotonic (written F E L ~~ L) if and only ifVx,yGL:zPya \nF(z) EF(g). It is eztensive (written F G L ~ L) if and only if VZ G L : z ~ F(%)). It is a complete I.J-morphism \n(written F E L w L) if for all families of sets Xi ~ L such that UiXi exists in -L, we have U~F(Xi) = \nF(u~X~). The propositions below immediately follow from the constructive proof of Tarski s fixpoint theorem \n[9]: Proposition 5 If S (~, 1, U) is a CPO and F s S E-+S is monotonic or extensive then Fu~ c pre (F) \n++ S where pre(F) = {z c S I z ~ l (z)} (so that Fum is totally defined for pre-fixpoints of F). o Definition \n6 (Well-formed inductive definition) The inductive definition S = (U, Q, 1, U) is well\u00adformed if and \nonly if ~~ (1) exists in which case it is the set lS\\ inductively defined by %. o Definition 7 (Inductive \ndefinitions on a cpo or a complete lattice) Let % = (U, Q, 1, U) be an induct ive definition. S is on \na cpo (respectively on a complete lattice) if and only if p(~) (~, 1, U) is a cpo (respectively p(17) \n(~, 1, T, U, n) is a complete lattice). o Definition 8 (Monotonic and extensive induc\u00adtive definitions) \nThe inductive definition % = (U, @, ~LU) is monotonic (respectively extensive) when\u00adever @ is monotonic \nand 1 ~ ~(1.) (respectively ~ is extensive). o Corollary 9 A monotonic or extensive inductive def\u00adinition \non a cpo is well-formed. o VVhen it exists, we write lfp~ F for the least fixpoint of F greater than \nor equal to x : F(lfpj F) = lfp~ F, *~lfp~F and Vy:[F(y)=y A cc<y]~[lfpjF< y]. The same way, gfp~ F is \nthe greatest fixpoint of F less than or equal to Z. Proposition 10 If S (c, 1, U) is a CPO ancl F ~ S \nAC S then FUm G pre(F) w S is an upper clo\u00ad sure operator, for all X ~ pre (F), Fuw (X) is the least \nfixpoint lfp~ F of F greater than or equal to X. o Corollary 11 If % = (U, 0, 1, U)_i~ a monotonic inductive \ndefinition on a CPO then @u is an upper closure operator, ~~ (X) is the least fixpoint ~fp~ T of ~ greater \nthan or equal to X ~ pre(~) for the ordering ~ induced by U and lS/ = ~~(1) = ~p~ ~. I Definition 12 \n(Rule satisfaction) The set S ~ U is said to sa<isfy the rules @ if and only if satci (S) = (~ C S) A \n(@(S) Q S) holds. o Proposition 13 If S = (U, Q, 1, U) is a monotonic inductive definition on a complete \nlattice then ]Sl = n{S c U \\ saiG(S)} is the least set (for ~) which satisfies the rules. o 1.2 Positive \ninductive definitions Definition 14 (Positive inductive definition) A positive inductive definition S \n= (U, Q) is S+ = (U, 0, 0, u). o Proposition 15 A positive inductive definition %+ = (U, Q)+ is well-formed \nand IS+ I = ~~(0) = lfp~ = n{S z U I sai~+(S)} is the least (for ~) closed set, that is which satisfies \nthe rules: closed+(S) 2* sat~+(S) = ~~ 6 @: (.P ~ S) S (c~ S)]. o Example 16 (Logic programs) Using the \nnota\u00adtions of [2], let P be a logic program (containing at least one constant ), Bp be its Herbrand universe \nand ground (P) be the set of all ground instances of clauses in P. The inductive definition corresponding \nto P is ~+ = (BP, @)+ where: +={ A B-I A+l?,,...,l?n 6 gnwui(P)} (5) The operator ~ induced by S+ is \nthe immediate conse\u00ad quence operator Tp. Then proposition (15) implies the characterization theorem of \nvan Emden and Kowalski [30]: A closed set 1 ~ Bp (such that Tp (1) ~ 1) is a model of P, the least model \nZi4p being the least fix\u00ad point TP~ (0) of TP. Lassez and Maher [20] observed that Tp ~ is a closure \noperator. o Example 17 (Maximal finite execution traces) Following [21], let T = (S, Act, {A I a c Act}, \nInit) be a labeiled transition system where S is a set of s\u00adtates, Act is a set of actions, each --% \nC S x S is the transition relation for action a E Act and Init ~ S is the set of initial states. We write \ns -% s for (s, s ) G -~, s~s for (s, s ) @ -<, s --+ s for 3a~Act: s-%s ands+for VaE Act: Vs ES: S>s \n. Z<W is the universe of finite traces IJ = @o .8?.. B1 ... Fl _18:.Y+, Ff such that Z= /crl 1where \n[al is the length of a, 1 ~ Ial <w, Fi SforO~i~l,r?j GAci! for O ~ j <1 and u .U.~ d is the concatenation \nof c and &#38; through action a, also written n ~+ a when 5pl -1 % To. 2Y is the universe of infinite \ntraces v = El) .8?..b ZFl . . . Tn .*.~..D?Fn+l . . . such that Icrl = w, <Wd~f E<:u ~~ is i7n ESand$n \nEActforn~0. Z the universe of traces. The set T<w of mazimal finite ezecution traces of this transition \nsystem T is defined by the following schemata (where free variables a G A et, s <; S and a c Z<u are \nuniversally quantified): s+ s -To AncT : (6) s E T~w SZOET@ which stands for the set @ of rule instances: \n0 {*] +x<. +~<. (7) s S _%o for all sc S such that s+ and s c S, a <~Act and cr e YY such that s ~ \n&#38;o. The rules are decorat\u00aded by the + sign to indicate that 1 = I?Jand u = U followed by the universe \nU = E<W. One or lboth indi\u00adcations can be left out when clear from the context. The monotone operator \n&#38; G p(%< ) ~$ p(~< ) induced by this inductive definition is: 3(X) = {s ]s+} u (8) {s-<als-5Fo AaCX} \n Let us define To+ ~f 0 and the set T + ~f { a E Z< I Icrl = n A di < Ial-1 :5, ~~ @i+ I A6n-1++} of \nexecution traces of T of length n > 0. Observe, by induction on n, that the ~erates of the operator ~ \nare &#38; = U~=oTi+ so that @ = Un~oT + = T< . Moreover &#38;+l = @ so that the closure ordinal of ~ \nis u. Finally, we have defined ? = lfp~ ~ = T<w = {a~~<w ]vi<\\al-l:~,~25,+,A6 \\+,+} o  1.3 Negative \nor co-inductive defini\u00adtions Definition 18 (Negative co-inductive defini\u00adtion) A negative inductive definition \nS = (U, @) is S-= (U, d?,u,n). o Proposition 19 A negative inductive definition %-~ (U, 0)-is well-formed \nand 1%-1 = 3~(u) = gfi @ = U{S ~ U I sat%-(S)} is the greatest (for ~) dense set, i.e. satisfying the \nrules: dense*(S) ~f sat~-(S) =~c ES:3P~S:~ G@]. O The definition of observation equivalence in [21] and \nof static typing in [22] are examples of negative co\u00adnductive definitions. Example 20 (Infinite execution \ntraces) The set T of infinite execution traces of a transition system T = (S, Act, {J% I (YE Act}, Init) \nis defined by the following schema (where free variables CYE Act, s E S and a E Y are universally quantified): \nS-3i70ACr El U (9) s-%cr ETLLI \u00adwhich stands for the set @ of rule instances: (lo) for all sGS, QE \nACI!and c GW such that s--E+5.. The monotone operator ~ c .@ ) AC P(Z ) induced by this inductive definition \nis: Let us define Tom Zf E and the set FW ~f { u E Y lVi<n:F~~%F~+~ } of infinite traces starting with \nn z 1 transitions. C)bserve, by induction on n, that the iterates of the operator ~ are &#38; = np=o~m \nso W+l CXJ= p. Moreover @ that &#38; = n.>oT = &#38; so that the closu;e ordinal of ~ is w. Finally, \nwe have defined ~=gfp~. i$=T ={u E E lVn~O: 6.:2 &#38;n+, }0 o Example 21 (Maximal execution traces I) \nThe set T w ~f T< u L! v of execution traces of a transi\u00ad tion system T = (S, Act, {-~ I CYc Act}, hit) \ncan be characterized by a negative inductive definition %\u00ad = (U, @-, U, n) where U = E@ and@-is specified \nby the following rule schemata: The monotone operator ~ c p(E@) ~c p(~~ ) induced by this inductive definition \nis: F, fl~ Fa+l } to be th,e set of finite traces of length m starting with n transitions. Observe! by \ninduction on n, and using the notations of examples 17 and 20 that the iterates of the operator ~ are \n@--= (U~=o@) u (Um>n~ ) U (~%o~m). For all m, n ~ O, if a EF t% cE~-sinceeither n>mand uE Tm G@ orn<mand \n~EY ~~, Also a E T implies a c ~~ for all i ~ O. Reciprocally c @ T< has either F. %Fn+l for some n \nsuch that O< n< Ial 1,inwhich casea ~ @- 1 or lal= 1and 3s E S :Zf_l _ s no that again u ~ ~f+l. It \nfollows that: ~ := nn20~ = n.zo[(up=ofi ) u (um,.!r~) u (n~=o!Pm)] = (u.20~;) u (n~=ofi~)  = J < u T \n= T~ . Moreover @-= ~ so that the closure ordinal of= is w. Finally, we have defined ~ = gfp~~u ~ = T< \n. However this definition is not quite satisfactory because of the term Um>~Tnm in @ which disappears \nwhen passing to the limit - (since n.20 Um>n T = 0). A definition of T@ such that ~ is a conservative \nextension of the @ is proposed in example 28. o If F c B w B is an operator on a complete boolean lattice \nB (~, 1, T, U,n, T), its dual is ~ GB w B is defined by Vx E B : ~(z) = lF(-Kc). If F is monotonic, so \nis F. By duality, a negative inductive definition can always be given an indirect equivalent positive \ndefinition. However, as shown by the above examples, most of the time, using a direct co-inductive definition \nis much more clear. Proposition 22 (Duality of positive and nega\u00adtive inductive definitions) If % = (U, \nQ) is an inductive definition then sat=+ (S) = sat~-(1 S), IS+ I = Zfp~ = qgfp=, IS-I = g$p~ = nlfp~ \nand 1%+1 = 7/$-1. u  1.4 Bi-inductive definitions Assume the universe U is covered by two subsets U+ \nand U , that is U = U+ U U . For example U+ may be the set of finite objects of U while U-is the set \nof infinite objects of U. To define a subset ISI of U, we could define separately the finite objects \nISI n U+ using a positive inductive definition and the infinite objects 1%1n U using a negative inductive \ndefinition. In practice, this must often be done simultaneously. For example in denotational semantics \nthe terminat. ing and non-terminating behaviors of programs are de\u00adfined at the same time using a single \nfixpoint opera\u00adtor. Since, for clarity, we insist upon using rule-based inductive definitions (preferred \nto fixpoint definition\u00ads [5]), we propose a method for combining inductive and co-inductive definitions \nwhich allows for the si\u00admultaneous use of positive and negative axioms and induction rules. We then give \nequivalent (but maybe less intuitive) fixpoint characterizations. Definition 23 (Bi-inductive definition) \nA hi-in\u00adductive definition % = (U, T+, ~-, 0), where m+, x E P(U) * P(U) is @ = (U*/ ~+, O*, 1*, I_@) \nwith, for all S, T, Si < U: u+ ~f T+(u) u T-(u), o We often use hi-inductive definitions to simultaneously \ndefine subsets of the universe which are separated in the following sense: Definition 24 (Separated hi-inductive \ndefini\u00adtion) A hi-inductive definition S = (U, m+, z , 0) is separated if and only if ~+ and ~ are monotonic \nfor G, idempotent and satisfy the separation property: VP g 7r+(u) : VM g 7r-(u) : T+(P UM) = 7r+(P) \nand ~-( Puikf) = m-(if). o Proposition 25 Let S = (U, ~+, ~-, 0) be a sepa\u00adrated hi-inductive definition. \nLet us define, for all S, T, St GU: . s C* T Sf [T+(S) s T+(T)] A [T-(S) Z Z_-(T)], . T;d~f T+(U) and \nn~si ~f ni ~+(si) u (JZT-(si). T hen: 1) Q(U)/E* (Q*, 1*, T+, u*, n*) is a complete lattice, 2) @ is \nmonotonic for C*, 3) S* is well-formed. o Disjoined hi-inductive definitions are used to simulta\u00ad neously \ndefine subsets of disjoined universes: Definition 26 (Disjoined hi-inductive defini. tion) A disjoined \nhi-inductive definition 9 = (U+, u-, O) where U+ fl U-= 0is S* = (U+ UU-, m+, T > Q) with T+(X) = X nU+ \nand T-(X) = X n  u-. o Proposition 27 A disjoined hi-inductive definition ~+ = (U+, U , Q)* is separated, \nhence well-formed and such that =+ is equality and 1%+ I = lfpz+ @ = Is+l up-t = ~p~w ugfi~F. 1 Example \n28 (Maximal execution traces 11) The set T5W ~f T<W U TW of execution traces of a transi\u00adtion system \nT = (S, Act, {-% I CYE Act}, Init) can be defined by a disjoined hi-inductive definition %* = (U+, U-, \nO )* where U + = Z<W is the set of finite traces, U-= Y is the set of infinite traces over S and Act \nand @* is specified by the following rule schemata: (15) For simplicity we write u G T~U instead of o \nG r+ (T<W ) (that is a c T<w ) in positive rule schemata and the same way T~W stands for r (T~W ) that \nis Tw in the negative ones. For short, the rule schemata (14) and (15) can be written as follows: The \nmonotone operator @* E p(~~ ) M* p(~~ ) induced by this inductive definition is: m(x) = {Scsls-+}u (17) \n{s-<als.~60Aa~X} Observe, by induction on n, and using the notations of examples 17 and 20 that the iterates \nof the operator @ are -= (u;=oTi+) u (np=ofim) so that @ = (un20V ) u (n.2iJWm) = T< u T = T~ . Moreover \n@* 1 = @ so that the closure ordinal of @ is u. Finally, we have defined ~ = lfp~~ ~ = T<@. o Our approach \nfor defining program behaviors, and more generally a subset of a space with finite and in\u00adfinite computable \nobjects, is characterized by the fol\u00adlowing remarks: 1. The finite objects are constructed from their \nfinite components using positive rules;  2. The infinite objects are not obtained as limits of finite \nones (this may be done once for all in the do\u00admain theoretical definition of the universe U) but selected \namong all possible ones by successive in\u00adspections of finite parts using negative rules; 3. By combining \nthe two methods, one can define oth\u00ader fixpoints, in addition to the usual least (for ~) and greatest \nfixpoints.  The usefulness of such non-extremal fixpoints is illus\u00ad trated by the example below: Example \n29 (Infinitary languages) Let A = {a, b,c} be an alphabet, U = U+ UU-where U+ = A* and U-= AU are respectively \nthe sets of finite and infinite words written on A. The in finitary language L = (a U b)* c U b is defined \nby the following axioms and rule schemata (which are disjoined since U+ n U-=@): The operator associated \nwith the instances of rules schemata (18) is @ = {c} U {am Ia E X nA*} U {bu I a 6 X}. It is a monotone \noperator on p(U)(~,* 1*, T*, L!*, m+) and ZfpG == (a Ub)*c u b = L. Observe however that L is neither \nthe least fixpoint (a U b) c nor the greatest fixpoint (a U b)*c U (a U b) of the context-free grammar \nX ::= c I aX I bX (these fixpoints being extremal for ~). o 1.5 Proof methlods It is interesting to \nnotice that numerous mathematical tools come of such inductive definitions. In particular, methods for \nproving lproperties of fixpoints (such as Park s fixpoint induction) can be transcribed to prove properties \nof inductively defined sets. Proposition 30 (Fixpoint induction) Let L (~, 1, U)beacpo and FEL ~c L. \nThen [lfp~ F~Y] %[3Z~L:lgZAF(Z)gZ AZ~Y]. Ifnis well-defined then [X n lfi$ F ~ Y] ~ [32 E L : J_ ~ ZAF(Z)GZAXTIZ~Y]O \nCorollary 31 If $3 =: (U, 0, -L, U) is a monotonic inductive definition on a cpo then 1$11~ S if and \nonly if 3S ~ U : (S ~ S) /\\ satG(S ). o Moreoverz -+ yd~f ~a,flE Or d:a</?Az E~ AyE &#38; =a is a strict \nwell-founded partial ordering so that transfinite induction can be used to prove the inverse inequality: \nDefinition 32 (Well-foundedness) A relation + on a class W is well-founded if and only if WellFounded(W, \n<) =: dE ~ W : [E =#0 ~ 3y G E : (T~ZE E :Z < y)] holds. l Proposition 33 (Iteration induction) Let L \n(~, 1, l-l) be a cpo with iinfimum 1 = uO, F GL AC L and QEL. We have: [Q~lfp F] ~ [3W:3 +< W xW :WeM \nounded(W, +) A31EW H L:(Vx E W : l(z) ~ F(UZ, ~= I(z ))) A (Q ~ UCEW I(z))] o Another useful method for \nproving properties of fix\u00adpoints is computational induction. We let @d be the class of ordinals and Limit \n= {~ G Ord I Ua = a #O} be the class of limit ordinals. Proposition 34 (Computational induction) Let \nL(~, 1, U)beacpo,,FcL ~~ Land PGp(L). We have: (lfp~ F EP) @ (31 E Or dt--iL :[1 E1(0)] A~a E Ord :VX \n<;I(a) :F(X) EI(a + 1)]A [Va E Limit :VX Ga ~< L : [VP < a :X(/3) c l(~)] = [UP<. X(P) l(a)]] A ~X \nOrd ~< L :(Va c Ord : X(a) c I(a)) + (&#38;GOrd X(a) E P)]) o An interesting particular case (which amounts \nto Scott induction when the function is upper continuous and the property is admissible) consists in \nchoosing the invariant I(a) as P, but this is not a semantically complete proof method. Proposition 35 \n( Stepwise computational in\u00ad duction) Let L (~, J.., U) be a cpo, F c L &#38;c L and P GP(L). We have: \n([1 E F ] A ~X c P :F(X) GP] A[Vcze Limit: VXCam&#38;<L:(V~<a :X(~)CP) + (Up<ax(p) P)]) + (Vlf F EP). \no A last example is the inductive definitions of functions fElsl HD: Proposition 36 (Inductive function \ndefinition) Let S = (U, @, 1, U) be a well-formed inductive defini\u00adtion, Dbeaset and~i~p(Pi xD) wDforall~ \nE0. There exists a unique total function f E IS[ % 5 such that for all ~ E * : ~(ci) = 7~({(z, f(z)) \nI z E Pi}). o When specialized to positive inductive definitions, propositions (30) and (33) amount \nto (for short, simi\u00ad lar corollaries holding for the other varieties of induc\u00ad tive definitions are not \nstated): Corollary 37 (Fixpoint induction for positive inductive definitions) Let S+ = (U, 0)+ be a posi\u00adtive \ninductive definition and R ~ U. Then [\\$3+ I n Q ~ R]@[31e UUQH{it, fi}:(V~E @:~ze P: I(z)] ~ I(c)) A \n(Viz c Q :I(x) a z E R)]. o Corollary 38 (Iteration induction for positive inductive definitions) Let \n%+ = (U, @)+ be a pos\u00aditive inductive definition and Q ~ U. We have: [Q ~ ]S+l] @ [3W :3< ~ W x W : WellFounded(W \n, <) A~Ic WHO(U) :[vu EQ:3z6W :uC~(z))]A [VZEVV: VCEI(Z) :3; EO:VC CP:3Z <z: c E 1(2 )]]. o Example \n39 (Well-founded part of a relation) Let S be a set of states and t < SxS be a relation on S. We write \ns -b s for (s, s ) E t. The well-founded part Wf(t)oft is the set of a. c S such that there is .. no \nmfimte sequence a. t+ al L 02 *L . . . that is: wf(t)={s 6s\\1(3aew Hs: s = aoAvz G w : ai -~ ai+l)} (19) \nThe well-founded part Wf(t) of t is specified by the inductive definition S+ = (S, 0)+ where @ consists \nof the rules instances [1]: {s es]s-L s } (20) s for all sES. To show that IS+ I Q W (t), we use proposition \n37 ~ith l(x) = [z c Wf(t)] sothat (VZ E S :1(z) + z E Wf(t))]is obvious. We must also show that Vs E \nS : ~s c S : s -2 s =+ 1(s )] ~ 1(s) which holds since y~(s)=[% su~s:s=a~ AVi CW:aj ~a:+l] implies [~s \nCS:s Ls A (~ae WWS:S =ao A Vi Ew:cr~-~ a~+~)] = [% CS :S-> S A 7~(S )] by choosing S = a. = a; and ai \n= a~+l for all i~w. . To show that Wf(t) ~ 1%+1, we use proposition 38 with W = Wf(t) and s < s = s -L \ns so that obvious\u00adly WellFounded(W, <) holds and l(z) = {z} so that ~u ~ Wj(t) : 3Z c W : u c I(a))] \nis true when choos\u00ading z = u. Moreover s -~ s implies s < s so that ~zew:vc EI(z):3; E@:vc GP:3z <a, \nC 6 l(z )] holds. o Example 40 (Floyd s partial correctness and termination proof methods) Let T = (S, \nAt-t, {-~ I a E Act}, hit) be a labelled transition system spec\u00adified by a program P. Let ~ E SxSi-+{tt, \nff] be an input-output specification of program P. P is partial\u00adly correct with respect to JY if and \nonly if Vs, s E S : s ~ s ~ W (s, s ) (where ~ is the reflexive transi\u00adtive closure of ~). According \nto proposition 37, the partial correctness proof can be done by discovering an invariant I ~ U = S x \nS satisfying the following verification conditions (as given in [1 l]): VS6S:(S, S)EI (21) VS,S ,S ES \n:Vcr EAct : [(s, S ) ~ ~ A S -=+S ] + (S,S ) c ~ (22) Vs,s Es:[(s, s )Eq + W(s,s ) (23) Let c E S = {tt, \nH} be a specification of the initial states of program P. Program P terminates if and only if there is \nno infinite execution trace cro * al * g~-+... , such that e(ao). According to example 39, we must show \nthat: Vs c S : c(s) + s E W~(--+). By proposition 38 applied to the rule-based inductive definition: \n{S ES IS+ S } VSES (24) s of Wf(=), this can be done by finding a well-founded set (W, <) and an invariant \n1 c W = P(S) satisfying the following verification conditions (as given in [12]): VVEW:Vs EI~:Vs ES: \n[s+s ]* [3(+q:s E If] (25) vsGs:e(s) *[3qcw:s GI~] (26) o 1.6 Well-founded system of inductive definitions \nTo get more expressive power, we introduce system\u00ads of inductive definitions in order to define subsets \nof a cartesian product ~~eA U [z] of sets U [z], i c A. We mix this notion with transfinitely iterated \ndefi\u00adnitions by induction on a well-founded set (W, +). Such well-founded (also called iterated) inductive \ndef\u00adinitions were first introduced by G, Kreisel and then further developed by S. Fefermann [15]. Definition \n41 (Well-founded system of induc\u00adtive definitions) A well-founded system of inductive definitions % is \na tuple (W, +, A, U, 0, _L, U) such that: . < is a well-founded binary relation on the set W, . The index \nA is such that for all w c W, A[w] is a set, . For all w e W and all i c A[w], the universe U [w] [i] \nis a set, . The set l[X] of infinite words with infinitely many occurrences of each x E X is defined \nby: . . 1 Definition 42 (Operator induced by a well\u00adfounded system of inductive definitions) For each \nw c W, the opem~or ~[w] induced by % = (W, 4, A, U, @, ~, u) is @lW] e H~@[W] @(U[w][i]) \u00ad ~;~A[w] $@[w][i]) \nUch hat ~~@X) = ~ieA[w] {c~ WUl[il I3P S x : ~T < {(w , S) I w -+w A S ~ \\%l[w ]} : 3V ~ {(w , S) ] w \n-+w A S ~ ISIIW ]} : &#38;@} where Vi E A[w ] : I%l[w ] [i] ~f ~[W ]fl[W,l(.LIW ] )[Z]. o Definition \n43 (Well-formed well-founded sys\u00adtem of inductive definitions) The welll-founded system of inductive \ndefinitions $3 = (W, <, A, U, @, J_, U) is well-formed if and only if ~[w]fi,W1 (-L[w]) exists for all \nw E W, in which case it is the carte\u00adsian product I%l[w] of rank w of sets 1%1[w] [i] of index i c A[w] \ninductively defined by %. l If each P(V[W] [i]) (c [w] [i], l[w] [i], LIIW] [i]) is a CPO (or a complete \nlattice) then propositions 9, 11, 13 and the above proof methods are easily extendeci to well\u00adfounded \nsystems of inductive definitions by camponen\u00adtwise induction on the well-founded relation (W, ~). When \ndefining subsets of a cartesian produtct of sets, the well-founded set (W, +) can be omitted since it \nis reduced to a singleton. This would be the case for example when understanding a context-free grammar \nas a system of inductive definitions. The next example is a well-founded inductive definition (the index \nset A being omitted since it is reduced to a singleton). Example 44 (Weak fairness) Let A be an alpha\u00adbet \nand X be a finite subset of A. The set F[X] of finite words containing at least one occurrence of each \nz c X is defined by: YEA ZEX (27) y e F [o] + x G I [{z}] + yC AA Ygx A @G &#38; [Y] + (28) ya c F[Y] \nZCX A YgX A IYGFIY] + (29) am E F[Y U{z}] This is a very simple example with W = {F[Y] I Y ~ X} u {IIX]}, \nF[Y] -< F[Z] when Y c Z ~ X and F[Y] --+ l[X] when Y ~ X. o Negation can be usecl in the premises of \nthe rules of iterated definitions: a set X[)] can be inductively de\u00adfined in terms of X[A] as well as \nX[a] and =X[a] for CY-+ J. In particular this generalizes J. Groote s transition system specifications \nwith negative premis\u00ades [16] without resorting to 3-valued minimal model or stable model approaches [6] \noriginating from log\u00adic programming, for which the logical meaning is not always simple and clear [19]. \nCombining systems and well-founded inductive def\u00adinitions, we get well-founded systems of inductive def\u00adinitions \nas illustrated by the following example: Example 45 (Maximal execution traces III) Let T = (S, Act, {$ \n[ a c Act}, Init) be a labelled transition system. The set T[}] (T[<A] and Z [<A]), ~ ~ w, of maxi\u00admal \nexecution traces of length A (respectively strictly less than A and less than or equal to ~] can be defined \nas follows (s, s , s C S, O~ ; < w, ~ ~ w): s+ (31) s <; T[.O.][S, s] + SZSJ A a c T[m.] [s , s ] (32) \ns --+ a <; T[m + 1.][s, S ] + s + St A 0 E T[.w][s ] A @o= $ (33) s 4 0 E !7 [.LLI][s] s c Init A \na c T[,n.] [s, s ] + (34) a E T[n] (35) (36) (37)  The partial ordering --+ such that for all O ~ \nn < A ~ w,.n. +.n+l., -n. +n, .w +w, n+< A, A--+ s~, <~ --+ <~, is well-founded. o Such iterated inductive \ndefinitions are very powerful since they have an expressive power greater than D. Park s p-calculus [26] \nor E. Emerson s CTL* [14]. These iterated inductive definitions are used in GmSOS to define the semantics \nof programming lan\u00adguages by induction OIT the syntax of programs. In this case, W is the set of all \nprogram components while ---+ means (is a sub-component of . 2 Abstract interpretation of in\u00adductive \ndefinitions The quest for a unique general-purpose semantics for programming languages has failed. A \nbetter approach is to establish correspondences between various se\u00admantics at different levels of abstraction. \nAs noticed by E. Astesiano [4] and G. Reggio [29], rule-based in\u00adductive definitions should form a unifying \nframework for expressing these semantics. A first step toward this goal is to describe finite and infinite \nprogram be\u00adhaviors in the same way. A second step consists in adopting an abstract interpretation approach \n[8] [10] in order to relate inductive definitions. Abstract in\u00adterpretation can be used, as follows, \nto justify and even to formally construct abstract rules in terms of a concrete ground (named static \nin [8] and renamed collecting in [24]) semantics (which could involve e.g. execution traces as it is \nthe case in our examples): Definition 46 (Operator abstraction) < standing either for = or ~ , we write: \n[S (~, 1, u), l?] U [S (~ , 1 , u ), I? ] (38) to mean that: . S(Z, l-, U) is a cpo such that 1 c S, \n. S (~ , -L , u ) is a partial order such that J- E S , . l ES m&#38;ES,FJESIm&#38; S? 9 . aES+S and \n. VA < clo~(F) : cY(F~) + F a (iteration from F = L and F = 1 ). o The above condition VA ~ clo~(F) \n: a(F~) < F a is implied by the following ones: . a(l) + -L , . VA s clo~(F) : CYOF(Fa) + F oa(FJ) and \n. for all limit ordinals ~ s Limit such that ~ g clo~(F), we have CY(U6<AF4) + U\\< Aa(F6). and by the \nstrongest ones: . cl!(l) + 1- , . CYOF+FIOa and . ~(uj<XZb) ~ U~<~a(ZJ) for all increasing chains {z \nI 6< clo~(F)}. This last condition is implied by the fact that a is a complete join morphism, which is \nthe case when it is the upper adjoint of a Galois connection: Definition 47 ( Galois connection) We write \n1 (S) ~ Q (5) to mean that: P (s) and Q (~) are posets, . CYEPWQ, . ~EQ~Pand  VzEF :Vy CQ:[cY(z)~y]U[z \n<y(y)].  o In this case, we write [S (~, 1, U), F] &#38; [S (~ , 1 , u ), F ]. Proposition 48 If [S \n(~, 1, u), F] ~ [S (~ , 1 , U ), F ] then a( lfp~ F) < lfp~~ F where < stands ei\u00adther for = or ~ . o \nAbstractions are usually specified by successive com\u00adpositions: Proposition 49 If [S (~, 1, U), F] ~][S \n(~ , J_ , u,), F,] ~~@/ u ), F ] and [S (E , 1 (~ , 1 , U ), F ] then [S ~, 1, U), F]a2%[+21[S (~ , 1 \n, u ), F ] where <1 (respectively <2) stands either for = (resp. =) or Q (resp. ~ ). o Definition 50 \n(Inductive definition abstrac\u00ad tion) If %= (U, ~, 1, U) and S = (U , ~ , 1 , u ) then we write S 3 % \nfor [P(V) (~, L, U), ~] ~ [F@ ) (g, 1/, Lf ), @] where L and ~ are the partial orderings respectively \ninduced by U and U and < stands either for = or E . If moreover P(U) (Q) ~ p(U ) (~ ) then we write LY[<lSy% \n.n Corollary 51 If 9 3 S then a(l%l) < IS I where < stands either for = or L . o Example 52 (Disjoined \nhi-inductive definition) e+ = (~+, ~+)+ anda A positive inductive definition ~ negative one %-= (U-, \n@ )-such that U+ n U-= 0 can be combined into a system of inductive definitions 9= (A, U, Q,1, U)whereA={1,2},U=U+ \nx u-,@. @#%l+ u @&#38;: e@-,J_. {}{ } (0, U-) and U;e,S~Xi, U) = (UiE,SX2, nzc~x). They can also be combined \ninto a disjoined hi-inductive def\u00adinition S+ = (U+, ?7-, @-U O+). The bijection is established by a((X, \nY)) = X U Y and 7(X) = (X n U+, X n U-), so that by propositions 27 and 51, we have IQ+I u 1%-1 = IS+I \n= CY(ISI) o A simple way to abstract inductive definitions is to use an abstraction of subsets of the \nuniverse: Proposition 53 Let % = (U, Q, 1, U) be a mono\u00adtonic inductive definition on a cpo p(V) (Q, \n1, u), p(U )(~ , U ) be a partial order and a E P(U) H p(17 ) be a complete U-morphism (for all sets \n{@ I 6< ~}, ~ E O@ and a complete U-morphism such that: v:5@:yx gu:cz(P)gcY(x)* (39) 3% @ : P ~ X A \nCY({C}) ~ CY({C }) Define ~ ~f ~ ~ E @ A c Ga({c})} and 1 ~f { CY(J-). Then S =f (a(u), W, 1 , U ) \nis a well formed inductive definition such that S 2 % , If moreov~~ ~(U)(G, 1, T, U, fl) is a complete \nlattice then S ~ % where ~Ep(17 ) E+p(~) isY(Y) = u{X EUI a!(x) g Y}. o This notion of abstraction can \nbe used to show the equivalence of inductive definitions. Example 54 (Maximal execution traces IV) In \nexample 21 we have characterized the execution traces T~W of a transition system T = (S, Act, {~ I a \nE Act}, Id) by a negative inductive definition %-= (X5W, o-, ~~w, n) where sF-is specified by schema \n(12) and p(E~W) (~, Z~W, n) is the induced cpo. In example 28 we have characterized T~w by a disjoined \ninductive definition %* = (2<U, D , @*)* where @* is specified by schemata (14) and (15) and p(~~w) (~+, \n1+, U+) is the induced cpo. In order to relate them, we observe that they are abstractions of a common \nground semantics: [x@ x(w+ 1)(~, 1, u), ~] (40) such that (X, J) ~ (X , l ) ~f (X ~+ X ) A (J < J ), \n1 Sf (1+, O), Ui(Xi, Ai) Sf (U~Xi, mazj~i) where the set w of natural numbers is the supremum of the \nset w+ 1 = wU{W} and #((X, ~)) = (=(X), 1+2) with l+u=w. We have [~~ x (w + 1) (~, -L, u), ~] $? [E~ \n(C*, 1*, u*), ~] where CY ((X, A)) = X and Y* (X) = (X, U). By proposition 48, it follows that CY+(lf \nf 4) = VP:; p = IS*I. We also have the correspondence [Z~W x (u + 1) (~, 1, U), ~] az=] [Z@ (~, Xsw, \nn), c#-] where a-((X, ~)) = XU(Um>ATAm) and Um>~Tam has been defined at example 21 for A < w and is equal \nto 0 when ~ = w. By proposition 48, a-(lfp~ ~) = lfp~<m ~-= 1%-I. o Abstraction can also be used to relate \ndefinitions of the semantics of languages described at different levels of details. Example 55 (Erratic, \ndemoniac and angelic re\u00adlational semantics of transition systems) . The erratic relational semantics \nis obtained by ab\u00adstraction of T@ as characterized by the disjoined in\u00ad ductive definition $3+ = (E<w, \n% , **)* of fXiUIIPk 28, where @i is specified by schemata (14) and (15) and p(Z7) (G*, J-*, U*) (where \nU = Z@) is the in\u00adduced cpo. The finite traces are approximated by the pair of their initial and final \nstates and the infinite ones by their initial state together with 1 denoting non-termination. Let us \ndefine lJb+ Sf S x S, U~- ~f S x {J-} where -1 @ S and Ub %f U~+ U@-. By propositions 25.1 and 27, p(Uh) \n(@, 1~, T~, uh, fib) is a complete lattice, where: #+ (T) Sf Tn(s XS) (41) $#-(? ) Af r n (S x {J_}) \n(42) t@ r %f [mh+(t)~ T~+(r)]A (43) [7r~-(q ~ 7r~-(r)] -Lh gf sx {1} (44) u~ri Sf UiT~+(71i) u nid-(ri) \n(45) The approximation can be formalized by the erratic abstraction ah c P(U) (E*) w p(iYh ) (@) such \nthat: ~h(x) = {(50, =Ial-1 )Iaexnm } (46) u{(?70,1)la6Xn21 } Let @ = (Uh, @~,i~, L!h) be the inductive \ndefinition such that the abstract rules instances @ are given by the following schemata (where s, s G \nS and z c s u {L}): S- +S A (S , X)~Tb * (47) (s, :;G T~+ (s, z) cT~ Then proposition 53 implies %+ \n~ $.1~ since d(U$X~) = UjCYQ(X~), cY~(U~Xj) = U~ah(X~), prop\u00aderty (39) holds, a~(l:k) = -Lb and CY6(U) \n= U~. . The angelic relational semantics is obtained by ab\u00adstraction of finite traces by the pair of \ntheir initial and final states while infinite ones are simply ignored. This can be formalized by Ub = \nS x S and the angelic abstraction: (48) such that: P(@) (!;h) + P(~b) (z) CYb(X) = Xnt7b (49) # (x) = \nx (50) Let Sb = (Ub, @b, 0, U) be the inductive definition such that the abstract rules instances @b \nare given by the following schemata (where s, s , s G S): s -<S A (S , S ) E Tb + ~51) (s, :;G Tb + \n(s, s ) ETb Then proposition 53 implies %~ ~ Sb since a is a complete U-morphism., property (3~) holds, \nCXb(iY~) = Ub and crb(lb) = -lb = 0. By proposition 49, we con-CYb O~b[=] c=.b elude $3* ~~ < . +07 \n. The demoniac relational semantics is obtained by abstraction of T~w as characterized by the negative \ninductive definition $?-= (X- u, @-, %w, n) of ex\u00adample 21 where 0-is specified by schema (12) and p(~~w \n) (~, Z~W, n) is the induced cpo. Finite traces are approximated by the pair of their initial and fi\u00adnal \nstates and the infinite ones by their initial state together with 1 denoting non-termination as well \nas any state so as to represent demoniac termination. Let us define the demoniac abstraction at G p(~~ \n) (~) + p(~t) (2) where ~~ = S x (S U {1}) such that: d(x) = {(60, ~pl_l) I~ c x n ~<u} u {(Fe, z)la \nExnx Aaesu{L}} (52) Let $?! = (U!, @~, Uj, n) be the negative inductive definition such that the abstract \nrules instances @~ are given by the following schemata (where s, s , s E S and z E SU {l}): Then proposition \n53 implies S- ~] @. Then rule schema (54) can be simplified into: (55) By further abstractions one can \nderive powerdomains based state transformation semantics [3].  GmSOS We now introduce G~ SOS, a generalization \nof SOS (G. Plotkin s structured operational semantics [28]) using the above rule-based systems of transfinitely \nit\u00aderated inductive definitions. GWSOS enables us to describe the finite, as well as the infinite executions \nof programs. The nature of the finitary or infinitary objects representing terminating and non-terminating \nprogram executions is not fixed and depends upon the considered language. For example we have defined \nthe Gw SOS semantics of ~-calculi [27] using judgments p t E -v (expression E evaluates to v in environ\u00adment \np) and p t-E + 1 (evaluation of expression E does not terminate in environment p); K. Apt and G. Plotkin \ns nondeterministic language [3] using maxi\u00admal finite and infinite execution traces and R. Milner s CCS \nusing infinite synchronization trees [21] and par\u00adtial orders [13] with infinite chainsz.  Example 56 \n(Trace semantics of while loops) In order to define the operational trace semantics of an imperative \nlanguage, let p E 17 be an environment (recording the values of identifiers), c c C be a com\u00admand, sQS \n= (I xC)ur beastate written p1-cor p, U+ = Zz be the set of finite traces, U-= Zti be the set of infinite \ntraces and U = X@ = X<u U V be the set of traces over states S and actions C . For short as\u00adsume that \nthe evaluation of a boolean expression b G B in environment p always terminates without error and yields \na boolean value B[b]p. If a c 2SW and c c C, define a~cbyp~c =pl-c, (pl-c)~c =pl-(c; c ) and (a % a \n) Q c = (u@ c) % (a @ c). The trace 2These examples, as others, are omitted for lack of space. semantics \nof the while loop w -while b do c is the set T[wJ] [p] ~ Z~ defined by the following rule schemata: . \nExecution of the while loop w terminates immedi\u00adately when the test b evaluates to false: (56) . A terminating \nor non-terminating execution of the while loop starts with a first step p !-w b+ p R c; w to evaluate \nthe test b to true followed by an execution p t-c -u+ o :: p of the loop body c (where control states \nmemorize the fact that further iterations of w may be necessary: (p F c $ a :: p ) Q w) followed by the \nremaining iterations p E w u CT : .B[b]p A P ~ C -% 0:: /2 6 ~[c][p] A P f W :: d G ~[wj[p ] * pt-w->p \nl-c; w- +(a~w)=: p tw::d ~[~1 [P] (57) Execution of the while loop may also not terminate when the test \nb is true and execution of the body c never terminates: Observe that we proceed by syntactic induction \non the well-founded ordering c + c iff c is a syntactic component of c . For example in rule schema (57), \nc + w s while b do c. In the instances of rule (57) corresponding to finite execution traces, we use \ninduction on the length of execution traces: execution of w in environment p takes strictly less steps \nthan its execution in environment p. This can also be un\u00adderstood as action induction [21], an induction \nupon the depth of the inference by which p t w A p t\u00adC;w + (aQw) :: p k w EL d isinferred. It is a sound \nprinciple just because lengths of finite execu\u00adtions ordered by < are well-founded. This argument is \nno longer valid in the instance of rule (57) for infinite execution traces since non-terminating executions \nof w in environments p and p both take infinitely many steps. This shows that negative rules are useful \nto provide a direct description of non-termination. o Denotational semantics [23] has several important \nad\u00ad vantages over traditional operational semantics: (1) The semantics of programs is given in terms \nof mathematical models (domain theory [17]); (2) Denotations are defined by induction on the ab\u00adstract \nsyntax of programs; (3) Finite and infinite program behaviors are handled  in the same way (using fixpoints). \nSOS copes with point (2) but not (3). One can define a big-steps SOS semantics where only error-free, \nt er\u00adminating behaviors of programs are described. Alter\u00adnatively} one can define a small-steps semantics \nwhere non-terminating executions have to be described us\u00ading another formalism such as execution traces \n(see [3]). Both approaches areincomplete since the first describes the good cases and leaves out the \nbad ones while the second provides a microscopic view of a macroscopic process. Using both approaches \nsimul\u00adtaneously implies a lot of work to relate them, and this has to be done again and again for eaclh \nlanguage [4]. GmSOS can cope with terminating and non\u00adterminating executions whence the prefix (GW added \nto SOS indicating the generalization to i:nfinite be\u00adhaviors. The correct handling of non-termination \nis necessary, for example to define fair executions of par\u00adallel processes or to serve as a ground semantics \nfor the inference of liveness properties of programs by ab\u00adstract interpretation such as strictness analysis. \nThis abstraction process can also be used to define more abstract semantics as shown by the following: \nExample 57 (Relational semantics of while loops) To obtain the big-step semantics of lcommand- S, we \ndefine an abstraction a c p(Z@) ~ p(I x 1 1) by cr({ai [ i c A}) ~f {CY(ai) I i c A} where 1 1 ~f I U{l}, \naE2~ t+ 1 xr4 is given bya(pt-cs~a~ p ) Sf (p, p ) for finite traces and by a(p F c =: a) def = (P, -L) \nfor infinite traces. The relational semmtzu of c c C is then 7Z[C] = a({T[cJj[p] I p E I }). We write \np 1-c -p for (p, p ) E 7? [c]. The natural se\u00admantics [18] of commands is 72 [c] n E<w since it only \ndeals with terminating executions. By proposition 53 applied to (56), (57), (58), it is defined for the \nwhile loop w = while b do c by the following rule schemata B[b]p A -J3[b]p pt_c-Ap Ap kw-i# + + (59) \npt-w--+p pkwm-ipJj Using G~ SOS, non-termination can be expressed di\u00adrectly: B[b]p A f3[b]p A pFc-.+l \npt-c-.+ p Ap t-w--L.L -(60) pi-w-l -pl-w-.+l 0 Example 58 (Gm SOS semantics of the nonde\u00adterministic \nchoice) To illustrate fairness, IIet us con\u00adsider the simple case of the nondeterministic choice operator \n[cl Dcz]. . With Plotkin s erratic semantics, termination or non-termination of [cl ~ C2] is possible \nwhenever that of c1 or C2 is possible: Pk cl-p Qkc2 *p + (61) pF[c1Qc2] -..++ + p F [cl EC2] -# pt-cl+l \npl-cz+-l --(62) p}[cl~c2]+L-pk [C1BC2]--+ .1 . With Hoare s fair angelic semantics, termination is possible \nwhen execution of c1 or that of C2 may termi\u00adnate whereas non-termination of [cl ~ C2] requires that \nboth c1 and C2 cannot terminate: pt-cl+p ptczwp + (63) pl-[clgc2] .--i # + pl-[cl~cz]+fi pbcl--+l ApFclw+p \nApl-c2-Q _LApt-c2nLip (64) p t-[clgc4 + 1-\u00ad (As pointed out by M. Broy, ifp b c1 --+ 1, p 1-c1 * l., \nphc2+2and pEclxl then pF[cl~c2] -+1, p \\ [cl IZJC2] -2 but p E [cl ~c2] -1 is not true, a miracle since \n[cl@ C2] must be able to avoid non\u00adtermination in the erratic behavior of both c1 and C2!) . With McCarthy \ns fair parallel semantics, non\u00adtermination is possible when both executions of c1 and cz may not terminate: \npFcl+p + pl-cz%+p + (65) pt-[c~~c2]+p pl-[cl~c2]+# p~cl+~ A phc2-x-+~ pb[cl~cz]- +l \u00ad  With Smyth s \nunfair demoniac semantics, termina\u00adtion of [cl ~c2] is possible only when both that of c1 and C2 are \nguaranteed whereas non-termination is pos\u00adsible whenever that of c1 or C2 is possible: p+cl-p Apbcl+l \nApl-c2 *1+ (66)p F [c~~cz] + # ptcz++/i Ap~cl-f+~Apt-C2-++1 -I-(67) p F [c~~cz] + # pl-cl+.l pl-cz-.l \n-(68) pl-[CIDC2] + 1 -pl-[c~~cz] -L . With the unfair, &#38; la Prolog, left to right semantics, termination \nof [cl ~cz] is possible when that of c1 is possible or when c1 cannot diverge and C2 may ter\u00adminate. \nNon-termination of [cl ~ C2] is possible when that of c1 is possible or when c1 cannot diverge but C2 \ncan: pl-cl-.-+p + pkc1++1Apbc2 -+ + p 1-[c~~cz] + # p } [cl BC2] + pll (69) pl-cl+l pHcl--+~Ap Fc2--+_L \n pF[cl Qc2] +4-pt-[clgcz]-.-il \u00ad (70) In rule schemata (63) to (70), the use of negations is sound since \nc1 -+ [cl D C2] and C2 + [cl Dcz]. o This last example illustrates the semantical composi\u00adtionality property: \nwe can change the semantics of the nondeterministic choice command without hav\u00ading to change the semantics \nof other (while, if, . ..) (sub) commands. In denotational semantics, one will have touse Plotkin, Hoare, \nSmyth, . ..powerdomains [17] to describe the behavior of the choice command. By doing so one will have \nto change the ordering used for computing fixpoints, hence potentially the seman\u00adtics of other commands \n(such as while loops or re\u00adcursion). More generally, semantical compositionalit y requires that the specification \nof the whole should be done without interfering with the specification of the components. As a last abstraction, \nlet us consider predicate trans\u00adformers: Example 59 (Predicate transformers) The pred\u00adicate transformer \nof command c c C is wp [c] = CX(X?[C]) where the abstraction a E p(I x 1 1 ) w $(r) ~ p(r)) is defined \nby Q(I?) = ~P.{p I (3p c :(P, /) G~)A(V#:(P, /) ER *p G P) A ((p, ~) @~)}. Since ~[c] #0, proposition \n53 applied to (59) and (60) yields the following definition of wp [w] where w s while bdo c: t3[b]p \nA L?[b]p A p e uJp[c](Q) p c pEP wp[uJ](P) - A Q P ~ ~ ~ Wp[W](~) Pu~l(p) - (71) o Further abstractions \nwould perfect the lattice of ab\u00adstract interpretations considered in [10]. Abstract in\u00adterpretation was \nfirst introduced using transition sys\u00adtems [7] that is an operational semantics. Mycroft [24], followed \nby Nielson [25], advocated using denotational instead of operational base semantics. We think that Gm \nSOS is better suited for designing ground seman\u00adtics from which other, more abstract or approximate, \nsemantics can be derived. In particular denotational semant its, which are abstract interpretations of \noper\u00adational behaviors, can be understood as intermediate steps in the approximation process. Acknowledgements \nWe would like to thank the members of IFIP WG 2.3 present at Santa Catalina and Pouill y en Auxois meetings \nfor discussions. References [1] P. Aczel. An introduction to inductive definitions. In J. Barwise, ed., \nHandbook of Mathematical Logic, Elsevier, 739 782, 1977. [2] K.R. Apt, Logic programming. In [31], 493-574. \n[3] K.R. Apt &#38; G.D. Plotkin. Countable nondeterminism and random assignment, .lA CM 33(4):724 767, \n1986. [4] E. Ast.siano. Inductive semantics. In E.J. Neuhold &#38; M. Paul, eds., Formal Description \nof Progmmming Concepts, Springer, 1990. [5] J. Barwise. Mixed fixed points. In vol. 17 of CSLI lecture \nnotes, 285-287, CSLI/Stanford, 1989. [6] R.N. Bol &#38; J.F. Groote. The meaning of negative premis. \nes in transition system specification. LiVCS 510, 481-494, Springer, 1991. [7] P. Cousot. Semantic foundations \nof program analysis. In S.S. Muchnick &#38; N.D. Jones, eds., PTogram Flow Analysis: Theory and Applications, \n303-342, Prentice-Hall, 1981. [8] P. Cousot &#38; R. Cousot. Abstract interpretation: a unified lattice \nmodel for static analysis of programs by construc\u00adtion or approximation of fixpoints. In ~th POPL, 238 \n252, 1977. [9] P. Cousot &#38; R. Cousot. Constructive versions of Tars\u00adki s fixed point theorems. Pacific \nJ. of Math., 82(1):43-57, 1979. [10] P. Cousot &#38; R. Cousot. Systematic design of program anal\u00adysis \nframeworks. In 6th POPL, 269-282, 1979. [11] P, Cousot &#38; R. Cousot. Induction principles for proving \nin\u00advariance properties of programs, In E. Neel, ed., Took and Notions for Program Construction, 43 119, \nCambridge U\u00adniv. Press, 1982. [12] P. Cousot &#38; R. Cousot. ~ la Floyd induction principles for proving \ninevitability properties of programs. In M. Nivat &#38; J. Reynolds, eds., Algeb7aic methodg in semantics, \n277\u00ad312, Cambridge Univ. Press, 1985. [13] P. Degano, R. de Nicola &#38; U. Montanari. A partial ordering \nsemantics for CCS, TCS 75(3):223-262, 1990. [14] E.A. Emerson. Temporal and modal logic. In [31], 995\u00ad1072. \n[15] S. Feferman. Formal theories for transfinite iterations of genereXzed inductive definitions and \nsome subsystems of analysis, In A. Kino, J. Myhlll &#38; R.E. Vesley, eds., Intu. itionism and Proof \nTheory, 303 326, North Holland, 1970. [16] J.F. Groote. Transition System Specification with Negative \nPremises. LNCS 458, 332 341 1990. [17] C.A. Gunter &#38; D.S. Scott. Semantic domains, In [31], 633\u00ad \n674. [18] G. Kahn. Natural semantics, In K. Futil &#38; M. Nivat, cd.., Programming of Futu~e Generation \nComputers, 237 258, Elsevier, 1988. [19] K. Kunen. Declarative semantics of logic programming. Bull. \nEATCS 44:147-167, 1991. [20] J.-L. Lassen &#38; M.J. Maher. Closure and fairness in the semantics of \nprogramming logic. TCS 29:1 67 1 84, 1984. [21] R. Milner. Operational and algebraic semantics of concur\u00adrent \nprocesses, In [31], 1201 1242. [22] R. Milner &#38; M. Tofte. Co-inducticminrelational semantics, TCS \n87:209 220, 1991. [23] P.D. Mosses. Denotational semantics, In [31], 575-631. [24] A. Mycroft. Abstract \ninterpretation and optimizing tTans. formation. for applicative programs. PhD Thesis, CST-15\u00ad81, Univ. \nof Edinburgh, 1981. [25] F. Nielson. A denotational framework for data flow analy\u00adsis. Acts Inforrnatica, \n18:265 287, 1982. [26] D. Park. On the semantics of fair parallelism. LNCS 86, 504 526, 1980. [27] G \n.D. Plotkin. Call-by-name, call-by-value and the X calculus. 2 CS 1:125 159, 1975. [28] G ,D. Plotkin, \nA structural approach to operational seman\u00adtics. Tech. Rep. DAIMI FN.19, Aarhus Univ., 1981, [29] G. \nReggio, A non-standard inductive semantics, LNC,S 472, 362 372, 1990. [30] M.H. van Emden &#38; R.A. \nKowalski, Th. semantics of pr.d\u00adicate logic as a programming language, JA CM 23(4) ;733 742, 1976. [31] \nJ. van Leeuwen (cd.). Formal Models and Semantics. vol. B of Handbook of Theoretical Cornptiter Science, \nElsevier, 1990. \n\t\t\t", "proc_id": "143165", "abstract": "<p>We introduce and illustrate a <italic>specification method</italic> combining rule-based inductive definitions, well-founded induction principles, fixed-point theory and abstract interpretation for general use in computer science. Finite as well as infinite objects can be specified, at various levels of details related by abstraction. General proof principles are applicable to prove properties of the specified objects.</p><p>The specification method is illustrated by introducing G<supscrpt><inline-equation> <f> &#8734; </f> </inline-equation></supscrpt>SOS, a structured operational semantics generalizing Plotkin's [28] structured operational semantics (SOS) so as to describe the finite, as well as the infinite behaviors of programs in a uniform way and by constructively deriving inductive presentations of the other (relational, denotational, predicate  transformers, &#8230;) semantics from G<supscrpt><inline-equation> <f> &#8734; </f> </inline-equation></supscrpt>SOS by abstract interpretation.</p>", "authors": [{"name": "Patrick Cousot", "author_profile_id": "81100592699", "affiliation": "", "person_id": "PP39049972", "email_address": "", "orcid_id": ""}, {"name": "Radhia Cousot", "author_profile_id": "81100592574", "affiliation": "", "person_id": "PP14204543", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143184", "year": "1992", "article_id": "143184", "conference": "POPL", "title": "Inductive definitions, semantics and abstract interpretations", "url": "http://dl.acm.org/citation.cfm?id=143184"}