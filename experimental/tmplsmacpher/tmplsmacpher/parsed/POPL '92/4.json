{"article_publication_date": "02-01-1992", "fulltext": "\n A Mark-and-Sweep Daniel University of California Santa Cruz, CA 95064 USA danielt2cse. ucsc.edu Abstract \nOur research is concerned with compiler-independent, tag-free garbage collection for the C++ programming \nlanguage. We have previously presented a copying col\u00adlector based on root registration. This paper presents \na mark-and-sweep garbage collector that ameliorates short comings of the previous collector. We describe \nthe two collectors and discuss why the new one is an improvement over the old one. We have tested this \ncollector and a conservative collector in a VLSI CAD application, and this paper discusses the differences. \nCurrently this prototype of the collector imposes too much overhead on our application. We intend to \nsolve that problem, and then use the techniques described in this paper to implement a generational Mark-and- \nSweep collector for C++. 1 Introduction C++ is a modern, object-oriented imperative pro\u00adgramming language \nthat has been steadily gaining in use since the mid-1980s [Str91]. C++ supports mul\u00adtiple inheritance. \nIt is primarily statically typed, but a restricted form of dynamic typing allows data struc\u00adtures and \nfunctions to be polymorphic within an in\u00adheritance hierarchy. C++ has parameterized types (called templates) \nand exception handling. Programming in C++ is no simple task. The com\u00adplexity of its semantics has been \nunfavorably com\u00adpared to that of Ada. The programming task is further complicated by the lack of automatic \nstorage recla\u00admation, or garbage collection (G C). The programmer must pay attention to reclaiming objects, \nwhile at the same time avoiding dangling references. Permission to copy without fee all or part of thk \nmaterial is granted provided that the copies are not made or distributed for direct commercial advantage, \nthe ACM copyright notice and the title of the publication and its date appear, and notice is given that \ncopying is by permission of the Association for Computing Machinery. To copy other\u00adwise, or to republish, \nrequires a fee and/or specific permission. @ 1992 ACM 089791+53-8/92/0001/0051 $1.50 Collector for C++ \nR. Edelson INRIA Project SOR F-78153 Rocquencourt Cedex France edelson Qlsor.inria.fr The absence of \nGC from C++ results from various design goals of C++-. A basic principle of C++ is localized cost (pay \nfor what you use, when you use it). The inclusion of the feature in the language must not impact the \nefficiency of programs that do not use the feature. Many garbage collectors lack this property, particularly \nwhen viewed at the level of the module, rat her than the program. There is already a moderately large \nbody of existing C++ code. A collector that is object-code compati\u00adble with existing code, and that can \nbe distributed in library form, will be most useful. In this respect we seek loose coupling between the \ncollector and compiler [Det90]. Garbage collection is an integral component of lan\u00adguages such as CommonLisp \n[Ste84], ML [Wik87], Smalltalk-80 [GR83], and Self [CUL89]. It is also present in other object-oriented \nimperative languages such as Eiffel [Mey88] and Modula-3 [CDG+ 88]. Var\u00adious garbage collectors have \nbeen proposed or can be used with C++ [EP9 l, Bar89,BDS91,Ken91, Det90]. A primary problem that all these \ncollectors solve is lo\u00adcating pointers (roots) on the stack and in global data. We have previously presented \na copying collector for C++ [EP91]. In this paper we present a new mark\u00adand-sweep collector and explain \nwhy it remedies sev\u00aderal short comings of our previous work. The new col\u00adlector is intended to become \na general, useful option for those C++ programs that can benefit from GC. The rest of this paper is organized \nas follows: Sec\u00adtion 2 gives an overview of the new mark-and-sweep collector. Section 3 briefly presents \nthe previous col\u00adlector, explains its problems, and shows how the new collector solves them. Section \n4 compares the fea\u00ad tures and efficiency of the mark-and-sweep collector to a conservative collector. \nSection 5 examines related work, and section 6 concludes the paper. 51  z A Mark-and-Sweep Collector \nWe have implemented a mark-and-sweep garbage col\u00ad lector for C++. It is currently being tested in a \nVLSI CAD application that performs logic minimiza\u00adtion and optimization. The application makes exten\u00adsive \nuse of dynamic memory, requiring graph data structures that are mutated over time. The collector itself \nconsists of a memory alloca\u00adtor, parameterized type definitions, and parameterized functions. It is implemented \nin a library outside of the compiler. 2.1 Terminology A pointer that the application manipulates is \ncalled a root. This includes pointers in global data, on the run-time stack, and in registers. It does \nnot include pointers contained within objects; those are referred to as internal pointers. Any object \nthat is reachable from some root by following a sequence of references is live. An allo\u00adcated object \nthat is not live is garbage. The job of the garbage collector is to locate and deallocate every garbage \nobject. A collector for a statically typed language is called type-accurate if every value that the collector \ninter\u00adprets as a pointer is statically typed to be a pointer. The opposite of type-accurate is conservative \n[BW88]. Conservative collectors assume that any value that might be a pointer actually is a pointer. \nPartially con\u00adservative collectors such as [Bar89] and [Det90] are conservative in certain regions of \nmemory and type\u00adaccurate in others. This is described in section 5. The collector described in this paper \nis type-accurate. Later in this paper we use the term virtual ~unc\u00adtion. In C++ a virtual function is \na function that is dynamically bound. Our garbage collector accesses objects through virtual functions \nin order to support polymorphic data structures. 2.2 Indirection Tables In order to collect garbage, \nthe collector must be able to locate all the roots. There are several ways of ac\u00adcomplishing this: Conservative \nscanning: Conservative garbage col\u00ad lectors examine every word on the stack, in global data, and in the \nregisters. Any word that might be a pointer is interpreted as a pointer. This tech\u00ad nique is used to \nprovide GC in languages such as C and C++ in which minimal run-time type information is available. Conservative \ncollection generally precludes copying collection because up\u00ad dating an integer that was interpreted \naa a pointer would be incorrect. Tags: Collectors based on tags examine every word on the stack, in global \ndata, and in the registers. Ev\u00adery word has a tag that indicates whether or not it is a pointer. Arithmetic \nefficiency is reduced for tagged integers; this violates the principle of localized cost. This solution \nis generally seen as undesirable for languages such as C and C++. Stack-frame decoding: Garbage collectors \nbased on stack-frame decoding require that the com\u00adpiler place map information in each stack frame. This \nmap indicates what pointers are present as local variables or temporaries in that function in\u00advocation. \nThe collector unwinds the stack, and interprets the map information that it finds in every activation \nrecord. Using this information, it marks the objects reachable from the roots present in that activation \nrecord. This solution permits source-level compatibility with existing code: it generally requires recompilation \nof the libraries. Root registration: Collectors based on root regis\u00adtration record the addresses of \nthe roots in aux\u00adiliary data structures. Collectors based on this technique have the potential for object-level \ncom\u00adpatibility for existing code. However, there are disadvantages with root registration for copying \ncollection in C++ that are discussed later in this paper. Root indirection: Collectors based on root \nindirec\u00adtion permit the application to manipulate only in\u00addirect pointers. Each indirect pointer references \na direct pointer that is located in a root table. Dur\u00ading garbage collection, the collector just needs \nto scan all of the root tables in order to locate the roots. This method, too, has the potential for \nobject-level compatibility y between code that uses garbage collection and code that does not. Its disadvantages \ninclude the level of indirection and the cost of maintaining the tables. The collector presented in this \npaper is based on root indirection. Each root table is an array of cells. A cell currently containing \na direct pointer is called active; a cell that is free is called inactive. The inac\u00ad tive cells are linked \ninto a linked-list. When a cell is required one is taken from this free list. When no free cell is available, \na new root table is allocated. The root tables are linked into a linked list, Figure 1 illustrates a \nsingle table. Figure 2 illustrates the list of tables.  2.3 Marking and Internal Pointers During the \nmark phase of a garbage collection, the collector must traverse all internal pointers and mark  Dynamic \nObjects Dynamic Objects Root Table Reserved - * Free cells -Z> 1 \\ / to Key: + A direct pointer . -> \nLink in list of free cells o Dynamic object Figure 1: An root table contains direct pointers and free \ncells. The free cells are linked into a free list. The first cell of each table is reserved for the list \nof tables. their referents. There are a number of ways that in\u00adternal pointers can be identified. Bartlett \ns collector requires that the internal pointers be located at the beginning of the object, and that a \ncount of the point\u00aders be made available to the collector when the object is allocated [Bar89, Det90]. \nDetlefs collector stores map information in an allocator header located im\u00admediately before the beginning \nof the object; the col\u00adlector interprets this information to locate the inter\u00adnal pointers. Boehm and \nWeiser s collector scans the entire object conservatively: the size of the object is available in the \nallocator header preceding the object [BW88]. Our collector associates a virtual mark function with ever \ny collected type. The mark function is coded or generated specifically for the type and can locate the \ninternal pointers. The collector uses static type in\u00adformation to invoke the mark function on each root\u00adreferenced \nobject. The mark function sets the mark bits of an objects and its descendants. Currently the mark functions \nmust be hand-coded. A future im\u00adplementation of the collector will take the form of a pre-compiler that \nwill generate them automatically. 2.4 The Allocator Our memory allocator is derived from Lea s libg++ \nallo cat or [Lea9 1]. There are lists of blocks whose sizes are powers of two as well as intermediate \nsizes. Io satisfy an allocation request the smallest block size  s y~ ~  i I Ke!y: -A direct pointer \n---~ Link in list of tables Figure 2: The root ta,bles are themselves linked into a list. The first \nword of each table contains its link. that is large enough is used. If no block of the desired size is \navailable, a larger block is broken up, just as in the buddy system [Knu73]. We have modified Lea s allocator \nto support lmark bits and sweeping. The allocator maintains a bitmap with mark bits for all the objects \nthat it can allocate. The mark bits are stored contiguously to improve garbage collection locality. These \nfunctions have been added to the allocator to support collection: mark(p) marks the object referenced \nby p and re\u00adturns the previous value of its mark bit. marked(p) returns the value of p s mark bit. sweepo \niterates over all the objects, deallocating ev\u00adery allocated, unmarked object all mark bits are cleared. \n2.5 Marking and Sweeping Marking the live objects is accomplished in the follow\u00ading way: the collector \nexamines every cell in the indi\u00adrection tables. The status of a cell, active or inactive, is determined \nby the cell s value. For every active cell, the sub-data structure that it references is marked. First \nthe cell s referent is marked. Then, recursively, the referent s descendants are marked. At this point \nthe algorithm is recursive for convenience only. Even\u00ad class anything { tually we intend to replace \nit with a constant-space algorithm such as Detlefs [Det90]. Sweeping isaccomplished with acall to the \nalloca\u00adtor s sweepo routine. That causes every object that is both allocated and unmarked to be deallocated. \nIn the process, all of the mark bits are cleared. In addition, as described in j2.7, a function call \nis performed on each object to jinalize the object immediately before it is deallocated. 2.6 The C++ \nInterface The main interface problem is guaranteeing the in\u00adtegrity of the pointer tables. If the application \nmisuses a direct pointer, the next garbage collection might in\u00adadvertently collect live data. This is \nsolved using class objects that behave like pointers, and that encapsu\u00adlate the actual direct pointers. \nThis has been referred to as a smart pointer scheme [Ede90,Str87]. A smart pointer can be dereferenced \nor compared the same way a standard pointer can. When a smart pointer is cre\u00adated it allocates a direct \npointer cell from an indi\u00adrection table. The smart pointer manipulated by the application is a pointer \nto an indirection table cell. When the smart pointer is destroyed it returns its cell to the free cell \nlist. The creation and destruction se\u00admantics are implemented with C++ constructors and destructors. \nThe smart pointers are implemented as parameterized types derived from the types of objects they reference. \nThey overload the C++ indirection operators * and -> in order to simulate direct point\u00aders. One of the \nmost significant advances of C++ over C is support for polymorphic type hierarchies. A garbage collector \nfor C++ must operate with poly\u00admorphic data structures to be most useful. This col\u00adlector supports polymorphic \ntype hierarchies by using one root type for every type in the hierarchy. The root types support implicit \ntype conversions corresponding to the valid conversions of the raw pointer types. Access to the standard \nmemory allocator is still per\u00ad mitted for objects such as strings and vectors. The C++ free-store operators \n(new and delete) are over\u00adloaded for collected classes to allocate objects from the collector s memory \nallocator. Figure 2.6 shows a sample class declaration of a collected class, This system does not attempt \nto completely prevent the programmer from acquiring raw (direct) point\u00aders. Indeed, as shall be seen, \nthe careful use of direct pointers represents a useful (if dangerous) optimiza\u00adtion. This also provides \nweak pointersl. However, the programmer must take care never to have an object 1A weak pointer is a reference \nthat does not cause an object to be retained during garbage collection. The object will be retained only \nif it is also referenced by a non-weak pointer. ... public: virtual void mark ( ) ; virtual void destroyo \n; void * operator new(size_t) ; void operator delete (voi.d * p) ; static void gco ; 3; Figure 3: A sample \ncollected class. whose only references are direct pointers; the object would be erroneously garbage collected. \n 2.7 Finalization C++ supports initialization and destruction of objects though constructors and destructors. \nA constructor function initializes an object. A destructor is invoked when an object becomes inaccessible \nto free resources associated with the object. Destructors are essentially synchronous: they execute when \nthe object becomes inaccessible. In the case of local variables, for example, this is when the variable \nleaves scope. The use of constructors is perfectly consistent with garbage collection. Destructors, however, \npresent a problem. Precisely when (garbage collected) objects become inaccessible is generally unknown. \nThis ren\u00adders synchronous destruction impossible [Str9 1]. In\u00adstead, we implement finalization [Lam83]. \nFinalization is essentially the equivalent of an asyn\u00adchronous destructor. When an object is garbage \ncol\u00adlected, immediately before its storage is deallocated, the object is finalized. Thus, finalization \nis used to clean-up after an object. For instance, if an object has hardware resources associated with \nit, finalization is used to free those resources when the object is col\u00adlected. In our system the destroy \nmember function is called on every object when it is reclaimed by the collector. In order to avoid this \noverhead, destroy may be defined as a non-virtual (meaning statically bound), null inline function. \n 3 The Previous Copying Col\u00adlector The collector that we describe in [EP91] is a copying collector for \nC++ that is based on root registration. It implements the basic copy collector algorithm as described \nin [FY69]. We have tested several memory allocators with the copy collector. One memory allocator uses \nan ex\u00adplicit bounds-check to determine when it is out of storage. Another allocator uses virtual memory \nwrite\u00adprotection to avoid the explicit test [App87]. The re\u00adsearch that we were duplicating used a programming \nlanguage with comparatively simple initialization se\u00admantics in which every word of a new object is ini\u00ad \n tialized. In C++, on the other hand, the semantics of initialization are almost entirely controlled \nby the ap\u00ad plication programmer. In C++ an allocator that uses virtual memory protection to avoid an \nexplicit bounds\u00ad check is not worth the added complexity [Ede90]. Since this is a copy collector it moves \nobjects and must be able to update roots. This collector tracks the roots with two data structures. Only \none of the two is necessary; the other is present as an optimization. The two data structures are a doubly-linked \nlist of root pointers and a stack of root pointers. Every time a root is created it inserts its address \ninto one of the two lists. Roots that are allocated and destroyed in a LIFO pattern, such as variables \nthat are local to a function, can be tracked with a stack. These roots push their addresses onto the \nroot stack. Other roots, such as pointers cent ained within other dynamically allocated objects, can \nt be tracked with a stack. They insert their addresses into the doubly-linked list. Dur\u00ading a collection, \nevery root s address is in one of the two lists. Therefore, the collector can: (1) find the roots, (2) \ncopy all the reachable objects, and (3) up\u00addate the roots. Stackable roots (roots whose addresses are \ntracked with the stack) are about four times as expensive to create and destroy as plain pointers. Roots \nthat are tracked with a doubly-linked list (termed doubly-linked roots) are about four times as expensive \nas stackable roots. Doubly-linked roots can serve in place of stack\u00ad able roots, but their inefficiency \nmakes that unattrac\u00ad tive. 3.1 Problems with the Copy Collector It turns out that stackable roots are \nvery rarely us\u00ad able. For example, global pointers, function param\u00ad et ers, and pointer-typed expression \ntemporaries all must be doubly-linked roots. This is because the lan\u00ad guage does not require LIFO construction \nand destruc\u00ad tion for those objects. For example, if a global variable and a local variable were both \nstackable roots, the lo\u00ad cal variable could conceivably be constructed before the global. This can easily \noccur if the variables are in separately-compiled files. This can lead to the root\u00ad stack becoming corrupted. \nThe uselessness of stack\u00ad able roots brings the efficiency of the copy collector into question. Another \nproblem involves member functions. In C++, whenever a method (member function) is in\u00ad voked on an object, \na pointer to the object is passed to the method on the stack. This pointer is called the this pointer. \nThrcmgh the this pointer the method can access the object s inst ante data. These point\u00aders are in fact \nroots; as such they must be updated during a collection. This can be accomplished if the addresses of \nthe this pointers are stored in the root doubly-linked list. However, the C++ language defi\u00adnition [X3 \nJ91,Str91] forbids taking the address of this pointers. Thus, the collector can only be implemented in \na customized compiler; it cannot be implemented and distributed in a library, aa is our goal. The final \nproblem with the copy collector involves the use of two kinds of roots: stackable and doubly\u00adlinked. \nA stackable root requires two words, one for the pointer and one for the link. A doubly-linked root requires \nthree words, one for the pointer and two for links. Suppose an object contains a root as instance data. \nWhat kind of root is required? The answer depends on how the object is allocated. For safety s sake doubly-linked \nroots must be used. It turns out that, with an implementation in a li\u00adbrary, stackable roots can only \nbe used for variables that are local to a function. 3.2 Comparing and Copy the Collectors Mark-and-Sweep \nThe main similarity the mark-and-sweep between collector the copy collector is their shared C++ and in\u00ad \n terface. In both cases, the dynamic memory operators new and delete are overloaded so that garbage collected \nobjects are allocated from the collected heap. Smart pointers are used to enable the collector to locate \nthe roots. In the case of the copy collector the smart pointers are direct pointers that register their \naddresses in aux\u00adiliary lists. Both singly-linked and doubly-linked lists are required. In the mark-and-sweep \ncollector the smart point\u00aders are indirect through pointer tables. Allocating a smart pointer, unless \na new table must be allocated, requires only a singly-linked list operation. There are no doubly-linked \nlists. The copy collector requires that this pointers on the stack be updated during each collection. \nThis is illegal if the collector is distributed in a library. Using mark\u00adand-sweep collection the this \npointers need only to be examined, not updated. This removes the need for taking the addresses of this \npointers.  4 Comparison with a Conser\u00advative Collector We have compared our collector to the conservative \ncollector described in [BW88] in a VLSI CAD appli\u00ad cation. The application generates and manipulates \n[ M-and-S ] Conservative graphs of dynamically allocated If-Then-Else gates, called ites. Given a logical \ndescription of a graph, the application creates and optimizes it to minimize the number of gates that \nit cent ains. The ites exist simultaneously in two data structures: a network and a hash table. The network \ncomprises the collected dynamic data structure. The hash table contains a pointer to every ite. However, \nthe hash table entries must be weak pointers. That is, if the only reference to an ite is in the hash \ntable, then the ite is garbage and should be collected. Furthermore, it is desirable to remove the hash \ntable entry when an ite is collected. 4.1 Features The Mark-and-Sweep collector provides all the fea\u00adtures \nneeded by the application. The roots manipu\u00adlated in the application are smart pointers. The hash table \ncontains raw pointers. This prevents hash table entries from retaining ites during collection. Final\u00adization \nis used to remove the hash table entries when objects are collected. The conservative collector does \nnot directly support weak pointers. However, it does not scan memory managed by other dynamic memory \nallocators, includ\u00ading the standard C ma IIoc allocator. Therefore, point\u00aders that are dynamically allocated \nby other memory allocators allocator are weak pointers. We allocate the hash table pointers using malloc \nto make them weak pointers. It is desirable to remove the hash ta\u00adble entries when ites are collected. \nThe conservative collector does not support finalization. The lack of fi\u00adnalization means that garbage \ncollection results in an invalid hash table. Therefore, for these tests, we ran the application for some \ntime with no garbage col\u00adlection, then garbage collected once and exited the application. This methodology \nwas used for both col\u00adlectors,  4.2 Efficiency Our experiments were conducted on a Sun Sparcsta\u00adtion \nIPC (4/40). We ran the application on fixed input data under each of the two collectors. We measured \nthe CPU time spent running the application and the time spent garbage collecting. Small Input Application \nTime 297s 178s Mark Time <0.01s 2.12s Sweep Time 8.13s 0.15s Data Reclaimed 4MB 146KB m Unfortunately, \nrandom values in global data kept the conservative collector from reclaiming the data structure. Therefore, \nwe cannot compare the efficiency of the garbage collection process itself. This should be viewed as an \nunusual case; other results using conser\u00advative collection have shown much better reclamation percentages \n[BDS91]. It is clear from the data that the indirection and overhead of maintaining the root tables in \nthis ver\u00adsion of the mark-and-sweep collector imposes a lot of overhead on the application. Indirect \npointers are only required when a new unique reference may be created. Determining this fact is harder \nthan indiscriminate use, but still easier than manual reclamation. These results reflect considerable \neffort to optimize the ap\u00adplication by often using direct pointers when possible. We believe that by \nfurther limiting the use of indirect pointers we can greatly reduce even this overhead. The benefits \nof this type-accurate collector, finaliza\u00adtion, weak-pointers, and potentially generations, in\u00addicate \nthat it is worthwhile to try and improve the efficiency of the collector.  5 Related Work There is \na significant body of related work, in the gen\u00aderal field of GC, in C++ software tools, and specifi\u00adcally \nin collectors for C++. Several of these collectors have been made publically available, as ours will \nbe in the near future. Boehm et al. have conducted research in conserva\u00ad tive garbage collectors [BDS91,BW88]. \nTheir garbage collectors work without any compiler support in lan\u00ad guages like C and C++. These collectors \nare sequen\u00ad tial and parallel non-generational mark-and-sweep col\u00ad lectors. Russo has adapted these techniques \nfor use in Choices, a C++ object-oriented operating system toolkit [Rus91,RMC90]. Since they are fully \nconser\u00ad vative, during a collection they must examine every word of the stack, of global data, and of \nevery marked object. Bartlett has written the Mostly Copying Collector, a generational garbage collector \nfor Scheme and C++ that uses both conservative and copying techniques [Bar89,Bar88]. This collector divides \nthe heap into logical pages, each of which has a space-identifier. During a collection an object can \nbe promoted from from-space toto-space inone of two ways: it can be physically copied to a to-space page, \nor the space\u00adidentifier of its present page can be advanced. Bartlett s collector conservatively scans \nthe stack and global data seeking pointers. Any word the collec\u00adtor interprets as a pointer (a root) \nmay in fact be either a pointer or some other quantify. The root-referenced objects must not be moved \nbecause the roots can not be modified. Those objects are promoted by having the space identifiers of \ntheir pages advanced. Then the root-referenced objects are (type-accurately) scanned; the objects they \nreference are compactly copied to the new space. This collect or works only with homomor\u00adphic data structures, \nnot polymorphic ones. Detlefs generalizes Bartlett s collector in two ways [Det90]. Bartlett s collector \ncontains two restrictions: 1. Internal pointers must be located at the beginning of objects, and 2. \nheap-allocated objects may not contain unsure pointers.z Detlefs relaxes these by maintaining type-specific \nmap information in a header in front of every object. Dur\u00ading a collection the collector interprets the \nmap infor\u00admation to locate internal pointers. The header can represent information about both sure pointers \nand unsure pointers. The collector treats sure pointers ac\u00ad curately and unsure point ers conservatively. \nDetlefs collector is concurrent and is implemented in the cfront C++ compiler. Kennedy describes a C++ \ntype hierarchy called OATH that uses garbage collection [Ken91]. It s col\u00adlector algorithm uses a combination \nof reference count\u00ading and mark-and-sweep. In OATH objects are ac\u00adcessed exclusively through references \ncalled accessors. An accessor implements reference semantics and ref\u00aderence counting on its referent. \nOATH uses a three\u00adphase mark-and-sweep algorithm. First, OATH scans the objects to eliminate from the \nreference counts all references between objects. After that, all objects with non-zero reference counts \nare root-referenced. The root-referenced objects serve as the root set for a standard mark-and-sweep \ngarbage collection. Goldberg describes tag-free garbage collection for polymorphic statically-typed languages \nusing compile\u00adtime information [G0191] building on work by Appel [App89]. Goldberg s compiler emits functions \nthat know how to collect garbage at various points in the program. Upon a collection, the collector follows \nthe  2An unsure pointer is a quantity that is statically typed to be either a pointer or a non-pointer. \nFor example, in union { int i; node * p; }x; x is an unsure pointer. chain of return addresses up the \nrun-time stack. As each stack frame is visited an associated garbage col\u00adlection function is invoked. \nA function may have more than one garbage ccdlection routine because different variables are live at \ndifferent points in the function. The collectors by IBoehm, Bartlett and Kennedy are implemented in libraries. \nGoldberg s and Detlefs col\u00adlectors must be implemented in a compiler. 6 Conclusions Garbage collection \nfor C++ is a difficult and impor\u00adtant problem. The language philosophy does not per\u00admit traditional techniques \nsuch as tags. There is a wide variety of alternatives that have been proposed or are possible. These \ninclude Bartlett s Mostly Copying collect or, Boehm s conservative collectors, Kennedy s reference counting \ncollector, our copying and mark\u00adand-sweep collectors, and many others. There is not yet a generational \ncollector that supports poly\u00admorphism, nor has any particular collector gained widespread use. In this \npaper we have presented the techniques that support our mark-and-sweep collector for C++. This has been \nimplemented in a library and we are cur\u00adrently testing it in a VLSI CAD application. Our short term goal \nis to improve its efficiency. Our long-term goals include parallelizing it and supporting genera\u00adtions. \nThis promises to yield a C+-t-garbage collector that is consistent with the language and useful in a \nwide variety of applications. 7 Acknowledgements I would like to express my gratitude to Anne Urban \nfor her detailed comments after reading a draft of this paper. I would like to thank Dirk Coldewey for \nvery timely international logistical support. I would like to thank Soeren Soe for help with the ITEM \napplication. References [App87] Andrew W. Appel. Garbage collection can be faster than stack allocation. \nln~or\u00admation Processing Letters, 25(4):275 279, June 1987. [App89] Andrew W. Appel. Runtime tags aren \nt necessary. In Lisp and Symbolic Computa\u00adtion, volume 2, pages 153-162, 1989. [Ass91] Association for \nComputing Machinery. Proceedings of the SIGPLAN 91 Confer\u00ad ence ori! Programming Language Design and \nImplementation. ACM Press, June 1991. [Bar88] Joel F. Bartlett. Compacting garbage col\u00ad [GR83] Adele \nGoldberg and David Robson. lection with ambiguous roots. Technical Smalltalk-80: The Language and Its \nIm- Report 88/2, Digital Equipment Corpora\u00ad plementation. Addison-Wesley Publishing tion, Western Research \nLaboratory, Palo Company, Reading, MA, 1983. Alto, California, February 1988. [Ken91] Brian Kennedy. \nThe features of the object\u00ad [Bar89] Joel F. Bartlett. Mostly copying garbage oriented abstract type hierarchy \n(OATH). collection picks up generations and C++. In Usenix C++ Conference Proceedings Technical Report \nTN-12, DEC WRL, Oc\u00ad [Use91], pages 41-50. tober 1989. [Knu73] Donald E. Knuth. The Art of Computer [BDS91] \nHans-J. Boehm, Alan J. Demers, and Scott Programmingj volume 1. Addison, Wesley, Shenker. Mostly parallel \ngarbage collec- Reading, Mass., 1973. Second ed. tion. In Proceedings of the SIGPLAN 91 Conference on \nProgramming Language De\u00ad [Lam83] Butler W. Lampson. A description of the sign and Implementation [Ass91], \npages Cedar language: A Cedar language refer\u00ad 157-164. ence manual. Technical Report CLS-83\u00ad 15, Xerox \nPARC, 1983. [BW88] Hans-Juergen Boehm and Mark Weiser. Garbage collection in an uncooperative en\u00ad [Lea91] \nDoug Lea. A memory allocator for libg++, vironment. Software-Practice and Expe\u00ad 1991. private communication. \nrience, 18(9):807 820, September 1988. [Mey88] Bertrand Meyer. Object-Oriented Soflware [CDG+88] L. Cardelli, \nJ. Donahue, L. Glassman, Construction. Prentice Hall, 1988. M. Jordan, B. Kalsow, and G. Nelson. Modula-3 \nreport. Technical report, Digi\u00ad [RMC90] Vincent Russo, Peter W. Madany, and tal Systems Research Center \nand Olivetti Roy H. Campbell. C++ and operat- Research Center, Palo Alto, CA, 1988. ing systems performance: \nA case study. In Usenix C++ Conference Proceedings, [CUL89] Craig Chambers, David Ungar, and El\u00ad pages \n103-114, San Francisco, CA, April gin Lee. An efficient implementation of 1990. Usenix Association. SELF \na dynamically-typed object-oriented language based on prototypes. In OOP\u00ad [Rus91] Vincent Russo, 1991. \nUsing the parallel SLA 89 Conference Proceedings, pages Boehm/Weiser/Demers collector in an op\u00ad 49-70. \nAssociation for Computing Machin\u00ad erating system: private communication. ery, ACM Press, October 1989. \n[Ste84] Guy L. Jr. Steele. Common Lisp: The [Det90] David Detlefs. Concurrent garbage collec- Language. \nDigital Press, Burlington, MA, tion for C++. Technical Report CMU-CS\u00ad 1984. 90-119, Carnegie Mellon, \n1990. [Str87] Bjarne Stroustrup. The evolution of C++ [Ede90] Daniel Edelson. Dynamic storage reclama\u00ad \n1985 to 1987. In Useniz C++ Workshop tion in C++. Technical Report UCSC- Proceedings, pages 1-22, Santa \nFe, NM, CRL-90-19, University of California at November 1987. Usenix Association. Santa Cruz, June 1990. \nM.S. Thesis. [Str91] Bjarne Stroustrup. The C++ Reference [EP91] Daniel Edelson and Ira Pohl. A copying \nManua!. Addison-Wesley, 2nd edition, collector for C++. In Usenix C++ Con\u00ad 1991. ference Proceedings \n[Use91], pages 85-102. [Use91) Usenix Association. Useniz C++ Confer\u00ad [FY69] R. Fenichel and J. Yochelson. \nA LISP ence Proceedings, Washington, DC, April garbage-collector for virtual-memory sys\u00ad 1991. tems. \nCommunications of the ACM, 12(11):611-612, November 1969. [Wik87] Ake Wikstrom. Functional programming \nusing standard ML. Prentice Hall, 1987. [G0191] Benjamin Goldberg. Tag-free garbage collection for strongly \ntyped program\u00ad [X3J91] ANSI Committee X3J 16. Draft standard ming languages. In Proceedings of the for \nprogramming language C++, May SIGPLAN 91 Conference on Program\u00ad 1991. ming Language Design and Implementa\u00ad \ntion [Ass91], pages 165 176.  \n\t\t\t", "proc_id": "143165", "abstract": "<p>Our research is concerned with compiler-independent, tag-free garbage collection for the C++ programming language. We have previously presented a copying collector based on root registration. This paper presents a mark-and-sweep garbage collector that ameliorates shortcomings of the previous collector. We describe the two collectors and discuss why the new one is an improvement over the old one. We have tested this collector and a conservative collector in a VLSI CAD application, and this paper discusses the differences. Currently this prototype of the collector imposes too much overhead on our application. We intend to solve that problem, and then use the techniques described in this paper to implement a generational Mark-and-Sweep collector for C++.</p>", "authors": [{"name": "Daniel R. Edelson", "author_profile_id": "81100542588", "affiliation": "", "person_id": "PP31075074", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143178", "year": "1992", "article_id": "143178", "conference": "POPL", "title": "A mark-and-sweep collector C++", "url": "http://dl.acm.org/citation.cfm?id=143178"}