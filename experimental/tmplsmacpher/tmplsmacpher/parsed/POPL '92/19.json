{"article_publication_date": "02-01-1992", "fulltext": "\n Support for Composable Modularity in Attribute Translator Grammars: Design and Implementation D. R. \nFarrow, Declarative Systems, Inc., T. J. Marlowe, Seton Hall University, M. Yell@ IBM T. J. Watson Research \nfarrow@ernie.berkeley. edu marlowe@cs.rutgers. edu Center, dmy@watson.ibm.com Abstract This paper introduces \nComposable Attribute Grammars (CAGS), a formalism that extends classical attribute gram\u00admars to allow \nfor the modular composition of translation specifications and of translators. CAGS bring to com\u00adplex \ntranslator writing systems the same benefits of mod\u00adularity found in modern programming languages, includ\u00ading \ncomprehensibility, reu.abihty, and incremental meta\u00adcompilation. A CAG is built from several smaller \ncomponent A Gs, each of which solves a particular subproblem, such as name analysis or register allocation. \nA component AG is based upon a simplified phrase-structure that reflects the properties of its subproblem \nrather than the phrase\u00adstructure of the source language. Different component phrase-structures for various \nsubproblems are combined by mapping them into a phrase-structure for the source lan\u00adguage. Both input \nand output attributes can be associated with the terminal symbols of a component AG. Output at\u00adtributes \nenable the results of solving a subproblem to be distributed back to anywhere that originally contributed \npart of the subproblem, e.g. tmnsparently distributing the results of global name analysis back to every \nsymbolic ref\u00aderence in the source program. After introducing CAGS by way of an example, we pro\u00advide a \nformal definition of CAGS and their semantics. We describe a subclass of CAGS, called separable CAGS, \nthat have favorable implementation properties. We discuss the novel aspects of CAGS, compare them to \nother proposals for inserting modularity into attribute grammars, and re\u00adlate our experience using CAGS \nin the Linguist translator\u00adwriting system. Introduction Modern programming practice recognizes the impor\u00adtance \nof modularity and composability in the descrip\u00adtion, implementation, and execution of large programs. \nPermission to copy without fee all or part of this material is granted provided that the copies are not \nmade or distribute for direct commercial advantage, dre ACM copyright notice and the title of the publication \nand k+ date appear, and notice is given that copying k by permission of the Association for Computing \nMachinery. TO copy other\u00adwise, or to republish, requires a fee snd/or specific permission. A programming \napplication should be designed and implemented as the combination of several compo\u00adnents, each physically \nand conceptually separate from the others. The conceptual separateness of compo\u00adnents allows most of \nthe information embodied in a component to be hidden behind narrow, precisely\u00addefined interfaces. The \nbenefits of such an organization are well-known and widely discussed in the literature; they include: \n(1) ease of specification, (2) clear de\u00adscription, (3) aid in verification, (4) interchangeabil\u00adity between \ndifferent plug-compatible components, (5) reuse of components across applications, (6) sepa\u00adrate analysis/compilation \nof components, and (7) in\u00adcremental or parallel evaluation. Many programming language constructs have \nbeen introduced to support program components and their conceptual separate\u00adness, including: procedures \nand functions, modules and classes, typed imports and exports, and param\u00adetrized instantiation of components. \nClassic AGs [20] are themselves a modular formal\u00adism: the components are the pr oduciions, the interface \nto a production consists of the symbols incident on the production together with the attributes associated \nwith those, and each production hides from the rest of the AG the semantic rules that define the attributes \nof its interface. This form of modularity is organized around a phrase-structure for the source language \nand it works well for some applications. However, experience [6, 10] suggests that for realistic applications \nit is inadequate. Symptoms of the inadequacy of this form of modular\u00adity include large, complex interfaces \nwhose external de\u00adscription is nearly as complicated aa the internal imple\u00admentation that they are designed \nto abstract. In con\u00adcrete terms, realistic AGs have too many attributes, inter-related in such complicated \nways that one must read the whole AG to understand their relationship. This is a classic indication of \na mismatch between the components of a modularization and the problem at hand. We herein introduce a \nnew approach, Composable AttTibut e GTammaTs (CA Gs), that provides support for modularity in attribute \ngrammars. This makes it easier to use AGs to specify programming languages @ 1992 ACM 089791453 -8/92/0001 \ni0223 $1.50 semantics and to design compilers and other transla\u00adtors. A CAG is built from several smaller \ncomponent A Gs, each of which solves a particular subproblem, such as name analysis, checking type-conformance, \nregister allocation and assignment, etc. A component AG is based upon a simplified phrase-structure that \nreflects the properties of its subproblem rather than the phrase-structure of the source language. Different \ncomponent phrase-structures for various subproblems are combined by mapping them into a phrase-structure \nfor the source language via a mechanism that looks like simple semantic rules attached to productions \nof the source language phrase-structure. Both input and output attributes can be associated with the \nterminal symbols of a component AG. Output attributes are the most significant and novel feature of CAGS. \nThey enable the results of solving a subproblem to be dis\u00adtributed back to anywhere that originally contributed \npart of that subproblem, e.g. the results of global name analysis can be transparently distributed back \nto every symbolic reference in the source program. There have been several other approaches for mod\u00adularizing \nAGs, including extended AGs [21, 26], attribute-coupled grammars (ACGS) [12, 13], higher\u00adorder AGs (H \nOAGS) [25], cascaded evaluation [10], and modular AGs [6]. Each of these provides some modularity, and \nwe have adopted ideas and notation from several of them, but none provides a uniform and general mechanism \nfor attaining the flavor and degree of modularity provided by CAGS. We introduce CAGS through a brief \nand familiar example a simple compiler for Pascal. After the ma\u00adjor features of CAGS have been informally \npresented, we give a formal definition and a simple semantics. We describe two different implementation \ntechniques and define subclasses of CAGS on which those tech\u00adniques can be used. Next we review how CAGS \nsupport modularity and composability, and compare CAGS with other proposals (mentioned above) for support\u00ading \nmodularity in AGs. We have implemented one of our subclasses of CAGS in an AG-based translator\u00adwriting-system, \nand we briefly discuss that implemen\u00adtation and relate our experience so far in designing and implementing \nCAGS. Finally, we present some issues we have not yet resolved and describe opportunities for further \nresearch. 2 An Example 2.1 Component grammars In a compiler, semantic processing often involves sev\u00aderal \nphases, each of which performs a distinct task. For example, consider the phase commonly called ideniijie~ \nresolution. This phase identifies the distinct scopes in a program, builds a symbol table containing \nthe decla\u00adrations of the program, and associates with each iden\u00adtifier reference in the program a symbol \ntable entry. An AG AR.. for identifier resolution in Pascal is given in Figure 1. 1 Certain points are \napparent. Perhaps the most sig\u00adnificant is the simplicity of the underlying CFG and of the AG rules. \nThere are only three sorts of en\u00adtities: declarations, new scopes, and identifier refer\u00adences. This allows \none to use an extremely sparse ab\u00adstract syntax for the grammar. Second, the AG ex\u00adpresses the semantics \nof identifier resolution not just for Pascal, but for a number of different languages. Fi\u00adnally, alternative \nsemantics for identifier resolution, for example, the semantics of Algol or Ada, could be im\u00adplemented \nwith different semantic rules for the same abstract grammar, since it does not obscure the se\u00admantics \nof identifier resolution with the syntactic or other semantic details of a particular language. Another \ndistinct aspect of semantic processing is type checking. Once again, we can isolate the seman\u00adtics of \ntype-checking into a small AG, ATYP,, given in Figure 2. For ease of presentation, and to save space, \nwe provide this grammar only for a very restricted set of Pascal.2 The resulting grammar is comparatively \nsmall, natural to the task at hand, and unobscured by irrelevant syntax/semantics. Moreover, it can be \nextended to handle most Pascal types and operators without losing its clarity or simplicity. It can even \nbe used for any language whose (abstract) type sys\u00adtem and operator type signatures are compatible with \nPascal s since the grammar uses an abstract syntax, the symbols used for operators, and even operator \nas\u00adsociativity and precedence, are immaterial. Given an expression in which the types of the leaves are \nknown, ATYPe will determine the type of the ex\u00adpression, as well as the type of each overloaded opera\u00adtor, \nand generate error messages where appropriate. If a particular type is expected for the expression (for \nex\u00ad 1 The notation is a slight extension of ordinary AG nota\u00ad tion. Productions of a CFG have the (slightly \nmodified) BNF form: <label> : XO : := XI . . . Xk where label is a sym\u00ad bolic name for the production. \nSemantic (attribute grammar) rules are attached to productions in the usual way. Attributes for grsrnmar \nsymbols are declared using the following syntax: <syrsbolnme> : <syrsbol_type> [ : <attribute_decls> \n] where syrsbolaame is a context-free gr ar symbol and swbol-type is either t (terminal) or n (non-terminal). \nEach attribute declaration for a symbol has the form <at t rib_nsme >: <direction> : <type> where attri.bnme \nand type are the name and the type of the symbol s attributes. The direction of non-terminal symbol attribute \nis either inherited (h) or syn\u00adthesized (s); the direction of a t errninal symbol attribute is ei\u00ad ther \nin or out. It is useful to think of the former as input parameters supplied to the grammar and the latter \nas output parameters exported by the grammar. The semsntic rules re\u00adsemble assignment statements that \nmay define more than one target attribute 2Types are real, integer, or boolean. Operators include only \nthe relational operators (<, >, . . .), arithmetic operators (+, -, *, . . .), and the boolean operator. \nAED, OR. -\u00ad grammar symbols envREF envDCL envgoal envitems : : : : t t n; n NAMli:in:tp_NTX, NAME:in:tp_NTX, \nENVin:h: symbol_table, --productions env_goal : envGoal envitems.ENVin env_empty : envitems envi.tems.ENVout \nenv.list : envitems envitemsl.ENVin envitems2.ENVin envi.tems,ENVout --this production env_nest : envitems \nenvitemsl.ENVin envitems.ENVout : := envitems. = emptyENV; ::= . = envitems.ENVin; : := envitemsl = envitems.ENVin, \n= envitemsl,ENVout, = envitems2.ENVout; envitems2 introduces a new scope ::= envitemsl. = envitems.ENVin, \n= envi.tems.ENVin;  OBJ:out:entry, MSGS:out:tp-msgs; OBJ:in:entry; ENVout:s :symbol_table; --this introduces \na variable reference env_ref : envitems : := envREF. envREF.OBJ = envl.ookup(envitems .ENVin, envREF.NAME) \n, envREF.MSGS = if envREF.OBJ = nullObj then else envitems.ENVout --this introduces invalid reference \n fi, = envitems.ENVin; a variable declaration env-dcl : envitems ::= envDCL. envitems.ENVout = envUpdate(envitems \n.ENVin, envDCL.NAME, envDCL.OBJ); Figure 1: Specification of AR,. ample, for the right side of an assignment \nstatement), the expected type is comparedto the actual type, and appropriate error messages generated. \nMany other semantic aspects can be isolated and ex\u00adpressed in concise abstract grammars. These include \noverloaded operator resolution, memory allocation and address assignment, register allocation, instruct \nion se\u00adlection, as well as local optimization and data flow analysis. One could build libraries ofreusable \ncompo\u00adnent AGs ifthere were only a wayto take such gram\u00admars and embed them in the semantic specification \nofa compiler for a particular language. In the next section, we show how this can be done. 2.2 The Glue \nGrammar In the grammars given above: The context-free phrase structures are different, and neither is \nclosely related to (and both are sim\u00adplerthan) the phrase structure for Pascal. Each grammar requires \ninputs and produces out\u00adputs. These outputs maybe needed for other corn\u00adponent grammars. For example, \ninformation from AR., is used in AType. Thus, to be able to use a set of these small corn\u00adponent AGs \nas modules, we need to provide a means to: Buildthephrase structure foreach component AG from the phrase \nstructure in Pascal.  Provide inputsto each component AG , anddirect (and possibly transform) th_eoutputs \nof a compo\u00adnent AG to appropriate destinations, typically to the inputs ofother components.  Instead \nof writing code to handle these require\u00adments, we can embed these actions ina master AG. We call this \nAG the glue, since it pastes together indi\u00advidual component AGsinto aunified semantic specifi\u00adcation. \nAn Example Consider the Pascal production corre\u00adspending to an assignment statement, variable ASGN expression. \nIn A~e$, this involves updating the en\u00advironment with the references in expression plus a reference to \nvariable. In ATyPe, this involves check\u00ading that the result type of expressionis compatible with the \ntype ofvariable retrieved from the environ\u00adment. The glue rules for this production are given in Figure \n3. The semantic rules of the glue production specify parts of the phrase structure for each component, \nas well as values for in attributes of component terminals in this phrase structure. The phrase structure \nfor each --grammar symbols typRESULT: t MSGS:out:tp_msgs, TYPEIN:in:tp-type TYPEOUT:out :tp_type; typoP \n: t MSGS:out:tp_msgs, TYPE:out:tp_type, OP:in:operator_class; typARG :t TYPE: in:tp_type; typegoal : \nn; typexp :n TYPE: s :tp_type; --productions type_check : typgoal ::= typRESULT typexp. --check expected \ntype with computed type typRESULT.TYPEOUT = typexp.TYPE, typRESULT.MSGS = if typRESULT.TYPEIN != typRESULT.TYPEOUT \nand NotCoercible(typRESULT.TYPEOUT, typRESULT.TYPEIN) and typRESULT.TYPEIN != univ_type and typRESULT.TYPEOUT \n!= univ_type then Cannot assign incompatible types else fi; typ_leaf : typexp ::= typARG. -leaf of expression \ntree typexp.TYPE = typARG.TYPE; typ_relop : typexp ::= typexpl typOP typexp2, --operator is relational \n. . . --semantics elided for brevity typ_sign : typexp ::= typOP typexpl. --unary arithmetic operator \n. . . -semantics elided for brevity ; typ_bool : typexp ::= typexpl typOP typexp2. --a boolean binary \noperator . . . --semantics elided for brevity ; typ_arith : typexp ::= typexpl typOP typexp2. -an arithmetic \nbinary operator typexp.TYPE = typOP.TYPE, typOP.MSGS, typOP.TYPE = if TypeIsArithmetic(typexpl .TYPE) \nand TypeIsArithmetic(typexp2.TYPE) then , CoerceToHigherType(typexpl. TYPE, typexp2.TYPE) else operands \nto arithmetic operator must be arithmetic , univ-type fi; Figure 2: Specification Of ATYP, component \nis obtained by identifying attributes in the nonterminal. glue with nonterminals in the component and \npasting The REFterminal symbol used in the envref con\u00adthese syntactic attributes together (with some \nterminal structor is introduced by a local declaration in the glue symbols as well) using production \nconst? ucto? s. that declares REF to be oftype envREF and also de- For instance, the glue nonterminal \nasgn.stmt has fines the only in attribute required for REF, defining attributes envitems and typegoal \ncorresponding to REF,name to have the same value as variable.name. nonterminalsin the resolution and \ntypechecking gramm-Also, inARe8, every envREFterminal produces an out ars, respectively. The constructor \nenv~ist builds attribute OBJ, the symbol table entry for the variable a production in A~e$ whose left-hand \nside (LHS) is referred to by envREF. The value of REF.OBJ is used an envitems nonterminal, and whose \nright-hand side in the glue production to define the input attribute (RHS)is two envitems nonterminals.3 \nSimilarly, the RESULT.TYPEIN in ATYP,. constructor type_check builds a production in AType This illustrates \nsome of the power of GAGs. In whose LHS is the typegoal nonterminal and whose the glue, we need only \nbuild the phrase structure for RHS is atypRESULT terminal followed by a typEXP AR,$ and supply thename \nofeach variable referenced, 3 Note that the fist nont,etind envit ems is produced by and we automatically \nget back symbol table entries aPplying the env~ef const~ctor to an envREF terminsl. for these variables. \nWe can then use these outputs as asgn.stmt : := variable - rules for constructing asgn_stmt. envitems \nREF:envREF = {NAME --rules for constructing asgn_stmt.typegoal RESULT:typRESULT = ASGN expression --Pascal \ngrammar production the phrase structure for i.d-resoluti.on = env_list(env_ref(REF) ,expression.envitems), \n=> variable.name}, the phrase structure for typechecking = type_check(RESULT,expression.typexp) , { TYPEIN \n=> TypeOf(REF.OBJ) }, asgn_st@.MSGS = concat(REF.MSGS, concat(RESULT.MSGS, expression.MSGS)); Figure3: \nComponent Phrase Structures for Assignment Statement inputs to other component grammars. Although AR,. \nand AType interact via input and output attributes of terminals, the grammars do not need to know ofone \nanother, as all their interactions occur via the glue. Hence, we preserve modularity. In\u00addeed, we could \nchange the data structures used bythe identifier resolution grammar, or even its semant its, without \nchanging ATYPe. If the phrase structure and interface of the changed component remain the same, we would \nnot even need to chlange the glue. Thus we could have interchangeable component AGs having the same phrase \nstructure but expressing different identi\u00adfier resolution rules, e.g., those of Pascal versus those ofAlgol. \n3 Composable AGs and Their Semantics 3.1 A formal definition of CAGS A composable attribute grammar consists \nof a set of components, a glue, and an interface between them.4 Component grammars are classical attribute \ngram\u00admars [20] enriched by allowing input and output at\u00adtributes for terminals. (In general, terminals \nin ab\u00adstract grammars will exist only as carriers for input or output attributes.) The glue grammar is \na classical AG enriched with syntactic attributes and production constructors. The interface establishes \nthe correspon\u00addence between the glue and the components. More formally: AComposable Attribute C,rammar \ncomponent con\u00adsists of 1. A context-free grammar given by the 4-tuple Gi = (Ni, Ti, Si, Pi), where each \nproduction has 4There exist many possible denotations for CAGS. For the p~osesofthis paper,interfaces \nmeimplicitwithin thecompo\u00adnent end glue grammars, However, it is likely that implemen\u00ad tations will &#38;d \nit convenient to explicitly declare interfaces, especially in the glue grammar. a unique label. 2. An \nattribute grammar Ai associating a set of in\u00adheritedand/orsynthesized attributes toeach non\u00adterminal, \nand a set of input and/or output at\u00adtributes to each terminal, and a set of attribute\u00ad defining rules \nto each production. Each output attribute, but no input attributes, are defined in Aio The interface \nofacomponent Ci consists of its context-free grammar Gi and its association of typed inputs and outputs \nto terminals. A glue attribute g?ammar for a Composable At\u00ad tribute Grammar is an underlying context-free \nThe glue uses two minaland te?minal. attribute grammar Agl with grammar Gq; , where special sets of types: \nnonteT-IEach terminal type has a set of associated typed input and output parameters. A nonterminal \ntype may also be designated as a TOOt. The attributes of the glue include syntactic at\u00ad tributes, each \nof a particular nonterminal type. Syntactic attributes are defined either by copy rules or by p? oductzon \nconst? uctom, also referred to as syntactic Tules. A production construc\u00adtor takes as parameters nonterminal \nand terminal types and returns a,particular nonterminal type. The actual argument for a nonterminal parameter \nin a production constructor can either be a syntac\u00adtic attribute (ofthe appropriate type) or another \nproduction constructor (returning the appropri\u00adate type). The actual argument supplied for a terminal \nparameter is a constant of that type. If a terminal constant is used in a syntactic rule of a glue production, \nthen it must define the input parameters of that terminal. Other rules of the glue production can reference \nthe output param\u00adeters of that terminal.  Definitions of syntactic attributes must obey the single syntactic \nuse ?equiTement: each instance of  +Q\u00ad L.4 i a syntactic attribute, except those whose nonter\u00adminal \ntype is designated as a root, is used ex\u00adactly once in defining some other syntactic at\u00adtribute [13]. \nA syntactic attribute whose nonter\u00adminal type is designated as a root is not used to define any other \nsyntactic attribute. (Thus the glue constructs parse trees in the components rather than DAGs, and there \nare no dangling trees no trees are rooted at a symbol other than a component root. ) A Composable Attribute \nGrammar consists of a set C of components Ci, and a glue attribute grammar, Agl, with a consistent interface. \nNamely, 1. The glue has an implicit interface for each com\u00adponent it uses, determined by the nonterminal \nand terminal types, the designated root type, the production constructors, and the typed in\u00adput /out \nput parameters associated wit h terminals for that component. 2. For each component, there must be a \n1-1 map\u00adping between nonterminal/terminal types and production constructors in the glue and termi\u00adnals/nonterminals \nand productions in the compo\u00adnent. These mappings must be consistent in the usual way; e.g., if the glue \nproduction constructor p maps to the component production q, then the nonterminal type returned by p \nmust map to the nonterminal on the left-hand side of q. The desig\u00adnated root must map to the start nonterminal \nin the component. 3. Additionally, the input/output parameters for each terminal used in the glue must \nhave the same types as the input/output attributes for the cor\u00adresponding terminal of the component. \n In this paper, the mapping between the glue and com\u00adponent interfaces is made explicit by using the \nsame names for matching items; e.g., production construc\u00adtors in the glue are given the same name as \nproduction labels in the components, and so on.  3.2 The Semantics of CAGS We give a semantics for CAGS \nby defining a transfor\u00admation that turns any CAG into a classical monolithic AG. The semantics of a CAG \nis the semantics of its induced monolithic AG, if the latter is non-circular; if the induced AG is circular, \nthen the CAG has no well-defined semantics. The transformation we use is an extension of a tech\u00adnique \ncalled descriptional composition, first proposed by Giegerich and Ganzinger [12]. In descriptional com\u00adposition, \neach syntactic attribute of the glue corre\u00adsponding to a non-terminal X of a component is re\u00adplaced by \na collection of new induced glue attributes corresponding to the attributes of X in the compo\u00adnent grammar. \nThese new attributes are defined by copy rules, or by semantic rules pulled back from the component, \nor by compositions of such rules, de\u00adpending upon whether the syntactic attribute was de\u00adfined by a copy \nrule, a production constructor, or a composition of production constructors. We extend descriptional \ncomposition so that we pull back the semantics from each component into the glue simulta\u00adneously. Secondly, \nwe include semantic rules for com\u00adputing input/output attributes. We illustrate descrip\u00adtional composition \nin our setting by way of an example. Consider the assignment statement given in the previous section \nfor a glue grammar (Figure 3). In Figure 4 we show what this production would look like after performing \nthe transformation. Since asgn.stmt has an associated syntactic attribute from AR.,, namely envit ems, \nthe transformed grammar in\u00adduces two new attributes for asgn-stmt, namely ENVin and ENVout. The same \nis true of the expression nonterminal of the glue. Similarly, express ion ac\u00adquires the attribute TYPE \nfrom AType. When the se\u00admantic rules for production constructors env~ist, env_ref and type_check are \npulled backed into the transformed grammar, we need to introduce lo\u00adcal variables into the production \nto hold values that, in the untransformed grammar, were held by in\u00adput/output attributes of component \ngrammar ter\u00adminal symbols. Hence the local variables REFname, REFobj, and REFmsgs replace the input/output \nat\u00ad tributes REF. NAME, REF. OBJ, and REF. MSGS. Com\u00ad position of production constructors can also intro\u00ad \n duce local variables for missing attributes associated with implicit nonterminals. Hence the local variables \nenvit emslENVi.n and envit emslENVout replace ARe8 attributes envit ems1. ENVin and envit ems1. ENVout. \nOf course, many of these temporaries can be automat\u00adically opt imized away by the AG met a-compiler. \n 3.3 Modular Analysis and Evaluation One evaluation strategy for CAGS is to transform a CAG into a monolithic \nAG by using descriptional com\u00adposition and then to apply classical AG evaluation techniques [16, 18]. \nHowever, for reasons discussed be\u00adlow, this approach has some drawbacks. Thus the bulk of this section \nis devoted to presenting another evalu\u00adations strategy for CAGS, sepa? aied evaluation, which avoids \ndescriptional composition. This approach can only be used for a restricted class of CAGS, but it permits \na greater degree of modularity when it is ap\u00adplicable. Applying descriptional composition and then build\u00ading \nan AG evaluator does not support the separate analysis and meta-compilation of AG components and glue \nsuch as that supported by separate compila\u00ad asgn_stmt : := variable M3GN expression -Pascal grammar \nproduction envltemslENVin: symbol_table = asgn_stmt.ENVin, envltemslENVout :symbol_table = envi.temslENVin, \nexpression.ENVin = envi.temslENVout, asgn_stmt.ENVout = expression.ENVout, REFname:tp_NTX = variable.name, \n REFobj:entry = envLookup(envitemslENVin, REFname), REFmsgs:MSGS = if REFobj = nullObj then invalid reference \nelse fi, RESULTtypeln:tp_type = TypeOf(REFobj), RESULTtypeout :tp_type = expression.TYPE, RESULTmsgs:MSGS \n= if RESULTtypein != RESULTtypeout and NotCoercible(RESULTtypeout, RESULTtypeln) and RESIJLTtypein != \nuni.v.type and RESULTtypeout != Unlv-type then Cannot assign incompatible types else fi., asgn_stmt.MSGS \n= concat(REFmsgs, concat(RESULTmsgs, expression.MSGS)); Figure 4: An Example of Descriptional Composition \ntionfeatures ofprogramming languages. Furthermore, The definitionof separability depends solely onlocal \none would like to be able to reason about the well-properties of the glue and component AGs. It requires \nformednessofCAGs byreasoning only about thecom-that each component be noncircular and that the glue, \nponents and the glue individually. In general, this is transformed to meet the requirements of the defini\u00adnot \npossible, as stated by the following theorem: tion, also be noncircular. The purpose of this transfor\u00ad \nmation is to guarantee that any circularity that may Theoreml Let Gbea CAG. Even ifeach component arise \nin the induced monolithic AG, when the com\u00adand the glue of G are noncimular, the induced mono\u00ad ponents \nand glue by themselves are noncircular, can lithic A G const?wcted f?om G may still be ci?cular. be detected \nby analyzing the glue alone. The trans\u00adformation forces the glue to assume that all input at- What this \nmeansis that for arbitrary CAGS, analy\u00ad tributes ofacomponent are used to define each output sis and \nmeta-compilation must take into account the attribute ofthat component. Hence any transitive de\u00ad entire \nCAG, since local properties on the component pendences that may arise when instantiating theCAG and glue \nAGs do not translate into global properties with a particular component will have already been on the \nCAG. taken into account in the analysisof the glue. To overcome these problems, we have formulated a \nrestricted class of CAGS, called sepa? abze CAGS. Sep-This glue transformation can be done by replacing \narable CAGS bound the potential indirect interaction each syntactic attribute with a pair of dummy at\u00adamong \ndifferent components so that each particular tributes, one inherited and one synthesized. Thesyn\u00ad component \ninstance can either (indirectly) contribute thesized attributes of these pairs are then made to information \nto another component instance, or (indi-depend on one another, and the inherited attributes rectly) receive \ninformation from that component in\u00ad are made to depend on each other both based on the stance, but not \nboth. The restrictions are stated solely original dependencies of their corresponding syntac\u00adin terms \nofinformation flow in the glue AG,and they tic attributes. The result is to cause every input at\u00ad induce \napartial order on the component instances con-tribute to be a dependency of a dummy attribute structed \nby the glueAG. of the component AG s goal symbol through a chain of dummy synthesized attributes, and \nto cause ev-Definition 1 A CA G G is separable if (1) each com-ery output attribute to depend on this \ngoal symbol s ponent AG is nonci?culaT, and (2) the glue is non- dummy attribute through a chain of dummy \nin\u00ad ciTcula? even uncle? the assumption that every output herited attributes. Thedetails ofthis construction \nare pa?ameier depends upon ever yinpui pa? ameter in any a little more involved than this, but they are \nstraight\u00adcomponent t?ee constructed in the glue. forward; for the sake of brevity they are left to the \nimagination of the reader. In contrast to Theorem l, separable CAGs areguar\u00adinduce a Separable CAGS are \nuseful for detecting circular\u00ad anteed to only well-defined monolithic AG: ity by testing each component \nand glue grammar sep-Theorem2 If Gisasepa?able CAGthen the induced arately. More importantly, if a CAG \nis separable, monolithic AG constructed f?om G is nonciTculaT. we can build a static evaluators modularly, \nbuilding evaluators for each component and for the glue sepa\u00adrately. As we discuss in Section 7, we have \nactually constructed a system for evaluating separable CAGS. One example of a static modular evaluation \nstrat\u00adegy for CAGS is an adaptation of the ordered eval\u00aduation strategy for classical AGs [16]. We say \nthat a C!AG G is orde~ed separable if (1) G is is separa\u00adble, (2) each component grammar is ordered , \nand (3) transform(g~) is ordered, where gi is the glue of the CAG and transform is the glue transformation \nde\u00adscribed above. If a CAG is ordered separable than an ordered evaluator can be built for the glue and \nfor each component separately. An ordered evaluator for an AG associates, at meta\u00adcompilation time, a \nsequence of instructions for each production in the AG. Each instruction is either an EVAL X.b instruction, \nindicating the evaluation of the attribute X.b of the production, or a VISIT k instruction, indicating \na descent into the kth (k > O) child of X or an ascent to the parent of X (k = O). An ordered separable \nevaluator can have one additional instruction: CALL X.root, where root is a syntactic attribute of nonterminal \ntype X representing the root of a component parse tree. This instruction passes the tree rooted at X.root \n(with instantiated input at\u00adtributes) to the evaluator for the component grammar and returns the tree \nwith the instantiated output val\u00adues. 5 One can show that: Theorem 3 If a CA G is ordered separable, \nthen the translation produced by an ordeTed sepaTab~e evaluator (for a syntactically legal input stTing) \nis comect, By correct we mean that the results of the translation the synthesized attributes of the root \nof the semantic tree are the same as specified by the induced monolithic AG. The chief advantage of separable \nevaluation strate\u00ad gies (such as ordered separable) over building an eval\u00ad uator for the monolithic AG \ninduced by the CAG is compi!aiional modu~aTity. Unlike classical AG sys\u00ad tems [8, 17, 22], where a single \nchange can render the entire generated evaluator invalid, in a separa\u00ad ble evaluator, a change to a single \ncomponent or glue AG only renders the evaluator for that component in\u00ad valid. Other advantages to separable \nevaluation are likely as well, such as speedier evaluators (since each component evaluates over a typically \nsmaller tree), more storage-efficient evaluators (since once a com\u00ad ponent evaluator finishes it can \ndiscard its semantic tree), and more flexible evaluators (since each compo\u00ad nent AG evaluator can use \na different evaluation strat\u00ad egy if desired). KRecall that if a GAG is separable, then there is an evaluation \norder that computes all input attributes of a component before any of its output attributes are referenced. \nThus the GALL instruction can be scheduledafter all input attributes havebeen computedbut beforeanyoutput \nattributes arereferenced. We have described two strategies for implementing CAGS: descriptional composition \nand separated evalu\u00adation. Each of these determines a (sub-) class of CAGS: all well-defined CAGS and \nseparable CAGS, respec\u00adtively. These strategies/subclasses can be viewed as the endpoints of a continuum. \nWe believe that there other intermediate points on this continuum which will prove valuable for their \ncombination of descriptional power and efficient implementation. We have infor\u00admally identified one such \nclass, which we call the k\u00adseparable CAGS. These are CAGS whose components can be evaluated in k different \npasses over their structure-trees, where output attributes of one pass can be used to define input attributes \nof a later pass. 4 Properties of CAGS The previous section presented a formal definition of CAGS and \na simple semantics for them, descriptional composition, as well as two implementation strategies, descriptional \ncomposition at meta-compile time and separated evaluation. This section highlights what we consider the \nmost important features and properties of CAGS and discusses how they support modularity and composability \nin AGs. The next section further analyzes features of CAGS in the process of comparing them with other \nproposals for supporting modularity in AGs. Modularity, Abstraction, and Information Hid\u00ading Each component \ngrammar of a CAG describes a separate subproblem and its solution. The component production-constructors \nused in the rules of the glue AG serve to abstract a component subproblem from the original, larger problem \ndescribed by the glue AG. The details of solving this subproblem are hidden be\u00adhind the interface of \nthe component. Its solution can be derived, analyzed, and verified without regard for the particular \ncontext in which the subproblem was originally embedded. Conversely, the glue AG can be designed, understood, \nand verified without having to know how component subproblems are solved. The glue AG is responsible \nonly for abstracting a relevant and well-formed instance of the component subprob\u00adlem, and it can then \ndepend on the accuracy of the solution to that subproblem. Output Attributes The most important and novel \naspect of CAGS is the ability to associate output at\u00adtributes with terminal symbols of a component AG. \nThis feature allows the semantics of the component AG to specify the outputs of a component with the \nsame granularity as inputs were specified to it. Without output attributes, component phrase structure \nis used only for construction of the component tree and ini\u00ad tialization of input attributes; with output \nattributes, it is also used to anticipate outputs. In the sample Pascal front-end of Section 2, the out\u00adput \nattribute envREF. OBJ (of Figure 1) is crucial to the brevity of the component A(2 for identifier resolution, \nas well as to the succinct description of its instantia\u00adtion in the glue AG. Our example Pascal CAG shows \nanother example of the utility of output attributes in the way error mes\u00adsages are generated. The order \nof error messages in Figure 3 agrees with code order, even though the mes\u00adsages are created in the component \nAGs, not the glue AG. If error messages were not returned via output attributes this would be much more \ncomplicated; e.g., if identifier errors and type errors were collected sepa\u00adrately, and then had to be \ninterleaved. The usual alternative to output attributes is to pro\u00adduce a single, complexly-structured \n(root) value as the unique output value of a component and then decom\u00adpose that structured value into \nits constituents via se\u00admant ic rules in the glue AG. This expands the interface between the glue AG \nand a component to include both the structure of the output aggregate and the rules for decomposing it \ninto constituents. It also expands the attribution rules of the glue AG to include appropri\u00adate instances \nof those rules for decomposing the com\u00adponent s output aggregate value. Out put attributes allow us to \nmove this work into the component AG, or just eliminate it altogether, thus substantially nar\u00adrowing \nthe interface between component and the glue AG. Hierarchical Structure We have so far described a CAG \nas a bush : a glue AG and a set of sibling components. However a component AG can itself be a nested \nCAG consisting of a glue AG and a num\u00adber of nested components. Thus, an arbitrarily deep hierarchy of \nCAGS can be assembled in which every component AG except the leaves are glue AGs with their own components. \nSuch interior component AGs would have input and output attributes for communi\u00adcating with their parents \nin the hierarchy, and would define/reference the input/output attributes of their children. For example, \none component of a CAG for Pascal might describe code generation using nested compo\u00adnent AGs that separately \nspecify optimization, storage allocation, register assignment, and instruct ion selec\u00adtion. The optimization \ncomponent could be imple\u00admented by further expanding it into several data-flow analysis components, a \nlocal optimization component, and a global optimization component. Our descriptional composition semantics \n(see Sec\u00adtion 3) for hierarchical CAGS is valid only so long as a CAG may not (even indirectly) instantiate \nanother in\u00adstance of itself. A more sophisticated semantic model is required if we allow such recuntive \nCAGS. Such a model is beyond the scope of this paper; this is an area in which we are continuing research. \nReusability of Components One of the most promising benefits of CAGS is in reusing component grammars \nin several different translators. For in\u00ad stance, a component AG such as ATYPC, if parametri\u00adzed by standard \ntypes and operators and rules for im\u00adplicit coercion, could be instantiated in different glue AGs for \nPascal and C. Such a standard CAG for type-conformance would capture the common traits of the two languages \nthat overloaded operator disam\u00adbiguation and operator/operand conformance is deter\u00admined by examining \nthe actual types of operands and the expected types of operators in a single bottom-up pass over an expression \ntree. Such differences between the two languages as statement syntax, operator prece\u00addence and associativity, \nand visibility rules are irrele\u00advant to type-conformance and would be handled within the separate glue \nAGs or other component AGs. At the end of section 6 we discuss some preliminary expe\u00adrience in this direction \nand propose using hierarchical components to delineate common aspects of transla\u00adtions. This opens the \ndoor to creating libraries of com\u00adponents, both for standard language semantics and for common compiler \ntasks like identifier resolution or overloaded operator identification. We envision com\u00adbining such standard \ncomponents with a specialized glue AG and a few special-purpose components to ob\u00adtain complete translators \nfor a particular language. Li\u00adbraries of components for different language semantics, code generation \nschemes, and optimization strategies would enable a much higher level of ezpeTimental re\u00adsearch in the \ncorresponding fields of programming lan\u00adguage and compiler design. Such libraries could also be powerful \ntools for teaching, e.g., compiler design and comparative programming languages. 5 Related Work There \nhave been a number of prior attempts to intro\u00adduce modularity in attribute grammar specification. Of \nthose, this work is most closely related to Attribute Coupled Grammars [12, 13], Cascaded Evaluation \n[10], Higher-order Attribute Grammars [25], and Modular Attribute Grammars [6]. Attribute Coupled Grammars \ndecompose complex translations into a sequence of steps, each of which (conceptually) constructs parse \ntrees for the next step via syntactic attributes and rules. However, (1) the flow is strictly linear \nand unidirectional, (2) as a con\u00adsequence, flow to non-immediate successors must be passed through a \nsequence of copy rules, or compo\u00adnents must be combined, (3) as another consequence, it is only meaningful \nto construct a single tree in the target, and (4) each component has to know the syntax and interface \nof its successor, severely limiting compo\u00adnent reuse. Cascaded Evaluation also passes syntactic and se\u00admantic \ninformation between grammars: a stream of terminals, with initial attribute values, is produced in one \ngrammar, which, when consumed in the other, pro\u00adduces a parse and a subtranslation. In Cascaded Eval\u00aduation \ninformation is returned only at the root of a subtree. Because only the yield of the parse in the tar\u00adget \ngrammar is produced, Cascaded Evaluation cannot use ambiguous component grammars; also, it is recur\u00adsively \nunsolvable to determine at (meta-)compile-time whether an AG expressed via Cascaded Evaluation is well-formed. \nHigher-order Attribute Grammars [25] allow for con\u00adstruction of multiple instances of component parse \ntrees during evaluation of a global AG. However, there is no descriptional modularity in the syntax: \nthe glue grammar must be enriched with the produc\u00adtions and grammar symbols of each component. Like cascaded \nevaluation, information computed by HOAGS is available only at the root of the component tree. This mechanism \ndoes not support modularity particularly well, and that was not its main goal. With Modular Attribute \nGrammars (MAGs) one can create AGs from a central AG and components, similar to the monolithic AGs built \nby descriptional composition from a glue AG and set of component AGs. However, MAG components are instantiated \nthrough pattern matching and templates rather than explicitly. Multiple instances of a given component \nmay be built at different positions in the original tree. All attributes of matched symbols are available \nto a component instance for reference in or definition by a semantic rule of the component. This mechanism \nal\u00adlows the outputs of a component to be distributed around the tree in a manner similar to the facility \nprovided by CAG output attributes. However, MAGs provide no well-defined separation of components from \nmain grammar; there is no hard interface analogous to the component phrase-structure of a CAG. Thus, \na component only has meaning, and can only be under\u00adstood, as a part of the larger monolithic AG. Other \ngeneral approaches including descriptional modularity [15, 21, 23, 24, 26] and pattern matching [7] are \northogonal to our own and could easily be included in a CAG system. Approaches to decomposition and structured \ncom\u00admunication, some reminiscent of features in CAGS, have been included in ad hoc AG systems for parallel \nor incremental compilers or AG evaluators [1, 2, 11, 19]. Such approaches to parallelization and incrementality \nare mostly orthogonal to CAGS and we expect that they can be used with CAGS without major modifica\u00adt \nion 6 Implementation and Experi\u00adence We have been experimenting with CAGS for several months now and \nhave some preliminary results in two areas: (1) the use of CAGS for design and documenta\u00adtion of particular \nprogramming languages and compil\u00aders for them, and (2) an implementation of separated evaluation and \nits applicability. Although we have not emphasized it in this abstract, CAGS are just as useful in designing \nand documenting programming languages and other translations as they are in implementing compilers and \ntranslators. Re\u00adcently one of the authors faced the problem of making major changes to an AG-based compiler \nfor the hard\u00adware description language VHDL [10], a large and com\u00adplex language that is an extension \nof Ada. In partic\u00adular, the identifier resolution mechanism for this com\u00adpiler was to be changed to make \nit more efficient, but we sought to preserve the correctness of the existing implementation. Our strategy \nwas to write a compo\u00adnent AG for identifier resolution in VHDL and to then modify the existing monolithic \nAG for VHDL to make it a glue AG that instantiates an instance of this com\u00adponent. This strategy worked \nwithout any difficulty and the improved identifier resolution implementation was en\u00adcapsulated entirely \nwithin the component AG. Fur\u00adthermore, the component AG is quite useful as a train\u00ading tool and as documentation \nof how identifiers are resolved in this language. It is much briefer and more precise than the VHDL Language \nReference Man\u00adual [27]. We have implemented separated evaluation of CAGS within the Linguist translator-writing-system \n[4]. We used this separately-evaluating version of Linguist to generate a Pascal compiler out of the \nglue and com\u00adponent AGs that were described in Section 2. This experience taught us several lessons, \nFirst, the component AG for identifier resolution in Pascal is not separable within our Pascal glue AG. \nOn learning this we carefully analyzed the corresponding component for VHDL and found that it was also \nnot separable. Briefly put, the reason for this is that some visible declarations (e.g. a variable) depend \non other visible declarations (e.g. a type). Thus, the result of looking up a type s name, an output \nof the component AG, is used to build the dictionary entry for a vari\u00adable which, because it is the object \nvisible under the variables name, must be an input of the component AG. However, for a separable CAG, \nall inputs must be available before any outputs are available, Our Pascal compiler s other component \nAGs, e.g. for type analysis and PCO.DE generation, were sep\u00adarable and the separately-evaluating Linguist \nsuccess\u00adfully generated a compiler from them. The identifier resolution component had to be evaluated \nvia descrip\u00adt ional composition, which was implemented (some\u00adwhat awkwardly) using macros. Another lesson \nwe have learned is that for a compo\u00adnent AG to be reusable across several different CAGS, its phrase \nstructure must be as general as possible. The instantiation of a component AG via construc\u00adtors used \nin the rules of the glue AG is essentially a mapping of a portion of the glue AG s phrase\u00ad structure \nonto the phrase-structure of the component. If many different phrase-structures are to map easily onto \na given component s phrase-structure, then the latter should impose a milmimum of restrictions. A good \nexample of this is how lists are expanded. We have found that lists of elements should be described through \na tree-structured derivation rather than as left-recursive or right-recursive list derivations. Use L \n::= L L I E.rather than either L ::= E I L Em L :: = E I E L. The example makes strong use of the possible \nambiguity of component phrase structure; this is acceptable because the semantics in the component are \nresolved by the induced phrase structure, and are not derived from a parse by the component AG. We have \nmost recently begun to design components that specify semantic processing for the C and C++ programming \nlanguages. This has given us some in\u00adsight into the reusability of c.>mponent AGs and how to design CAGS \nfor reuse. Our preliminary conclu\u00adsions are that CAGS that are directly instantiated in a glue AG for \nlanguage A typically can not be di\u00adrectly reused in language B unless A and B are closely related. However, \nsubproblems such as name reso\u00adlution, type conformance, and disambiguating over\u00adloaded functions/operators \ndo have very deep similar\u00adities that can be exploited. The trick is to set up a (shallow) hierarchy of \ncom\u00adponent AGs and to reuse the leaves of that hierarchy. Consider name resolution in C and Pascal. If \na single CAG for name resolution were directly instantiated in glue AGs for both languages then either \nthe compo\u00adnent would have to be complicated and contorted, or the semantic rules in the glue AGs would \nhave to spec\u00adify much of the name resolution semantics, or both. Nonetheless the name resolution semantics \nof both languages do have much in common, such as: nested block structure, inheritance of visibilit y \nfrom one block to another nested within it,, the ability to override a global declaration with a local \none, etc. Such broad similarities can be captured. in a single, reusable CAG which can then be instantiated \nin separate CAGS that describe the peculiarities of name resolution in C or Pascal. 7 Conclusions and \nDirections for Further Research We have developed CAGS as an approach to modular\u00adity in attribute grammars. \nCAGS are fully general, al\u00adlow nearly arbitrary combinations of components and exchanges of information, \nand express many standard attribute grammar problems elegantly and concisely. Moreover, CAGS possess \ndescriptional and organiza\u00adtional simplicity: they are easy to understand, and facilitate specification \nand explanation of complicated semantic and translation tasks. Finally, and most im\u00adportantly, CAGS are \nhighly modular, allowing reuse or modification of components, and providing for modu\u00adlar meta-compilation. \nCAGS appear extremely fruitful for further research. Among the issues and opportunities are: Is there \na natural modular way to define CAG semantics? Is there a reasonable way to pro\u00advide a (fixed-point?) \nsemantics for self-referential CAGS?  Are there other useful evaluation strategies for CAGS?  b Instances \nof component AGs whose interface at\u00adtributes do not depend on one another offer clear opportunities for \nparallel evaluation. There is po\u00adtential here for some coarse-grained parallelism among different component \nAG instances as op\u00adposed to the fine-grained parallelism among in\u00addividual semantic rules that AGs have \ntradition\u00adally offered. How can useful opportunities be de\u00adtected? What are the best strategies for exploit\u00ading \nthese opportunities? How much speedup in translation will result? Similarly, CAGS should expose opportuni\u00adties \nfor coarse-grained incremental evaluation that would complement the traditional fine\u00adgrained attribute-by-attribute \nincremental eval\u00aduation strategies. We envision a scheme in which individual instances of component AGs \nare re\u00adevaluated or not depending on whether any of their input attributes have changed.  Can one construct \nlibraries of separately compi\u00adlable component AGs to facilitate the reuse of translator design?  Acknowledgement \nWe thank John Field and Roger Hoover for read\u00ading a preliminary version of this paper and suggesting \nimprovements for its presentation. [17] U. Kastens, B. Hutt, and E. Zimmerman. GAG: A practical compiler \ngenerator. Number 141 in Lecture [1]H. Alblas. Incremental simple multi-pass attribute Notes in Computer \nScience. Springer-Verlag, 1982. [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12] [13] [14] [15] [16] evaluation. \nIn Proceedings of the NGI/SION 1986 [18] K. Kennedy and S. K. Warren. Automatic gener\u00adsymposium, pages \n319-342, 1986. ation of efficient evaluators for attribute grammars. H.-J. Boehm and W. Zwanenpoel. \nParallel attribute In Conference Record of the Third Annual ACM grammar evaluation. Technical Report \nTR-87-55, Rice Symposium on Principles of Programming Languages, University$ Houston, TX, June 1987. \npages 32 49. Association for Computing Machinery SIGPLAN, 1976. B. Courcelle. Attribute grammars: definitions, \nanal\u00ad ysis of dependencies, proof methods, pages 81-102. [19] E. A. Klein. Attribute evaluation in parallel, \nIn 1984. Proceedings of the Workshop of Parallel Compilation, page 8, Kingston, Ontario, May 6 8 1990. \nThe Linguist translator-writing system. User s Man\u00ad ual, Version 6..3, Declarative Systems, Inc. Palo \nAlto, [20] D. Knuth. Semantics of context-free languages. CA, February 1991. Mathematical Systems Theory, \n2(2):127 145, Febru- P. Deransart, M. Jourdan, and B. Lorho, editors. At-ary 1968. Correction, 5 (l), \n95 96, March 1971. tribute Grammars: Definitions, Systems and Bibliog\u00ad [21] 0. L. Madsen. On defining \nsemantics by means of ex\u00adraphy. Number 323 in Lecture Notes in Computer tended attribute grammars, pages \n259 299. Number 94 Science. Springer-Verlag, May 1988. in Lecture Notes in Computer Science. Springer- \n G. D. P. Dueck and G. V. Cormack. Modular attribute Verlag, 1980. grammars. Computer Journal, 33(3): \n164-172, 1990. [22] T. Reps. Generating Language-Based Environments. C. Farnum. Prototypzng optimizing \ncompilers. PhD The MIT Press, Cambridge, MA, 1984. ACM Distin\u00adthesis, Department of Electrical Engineering \nand guished Dissertation Award. Computer Science, University of California at Berke\u00ad [23] T. Reps. and \nT. Teitelbaum The Synthesizer Genera\u00adley, Berkeley, CA, December 1990. tor reference Manual, Third Edition. \nSpringer-Verlag, R. Farrow. LINGUIST-86: Yet another translator New York, NY, 1989. Texts and Monographs \nin Com\u00ad writing system based on attribute grammars. In Pro-puter Science. ceedings of the SIGPLA N 82 \nSymposium on Compiler [24] M. Tieman. Removing redundancy in attribute gram-Construction, June 1982. \nPublished as SIGPLAN No\u00ad mars. Technical Report ACA-239-87, MCC, July tices, 17 (6). 1987. R. Farrow. \nAutomatic generation of fixed-point\u00ad[25] H. H. Vogtj S. D. Swierstra, and M. F. Kuiper. Higher finding \nevaluators for circular, but well-defined, at\u00adorder attribute grammars. In Proceedings of the SIG\u00ad tribute \ngrammars. In Proceedings of the SIGPLAN PLAN 89 Conference on Programming Language De\u00ad 86 Symposium on \nCompiler Construction, pages 85 sign and Implementation, pages 131 145, July 1989. 98, 1986. Published \nas SIGPLAN Notices, 21 (7). Published as SIGPLAN Notices, 24 (7). R. Farrow and A. Stanculescu. A VHDL \ncompiler [26] D. A. Watt and O. L. Madsen. Extended attribute based on attribute grammars. In Proceedings \nof the grammars, Computer Journal, 26(2):142-153, May SIGPLAN 89 Conference on Programming Language 1983. \nDesign and Implementation, pages 120-130, 1989. [27] IEEE Standard VHD.L Reference ManuaL IEEE Std Published \nas SIGPLAN Notices, 24 (7). 1076-1087. The Institute of Electrical and Electronic N. M. Gafter. Parallel \nincremental compilation. Tech-Engineers, Inc. New York, NY, March 31, 1988. nical Report 349, University \nof Rochester, June 1990. H. Ganzinger and R. Giegerich. Attribute coupled grammars. In Proceedings of \nthe SIGPLAN 84 Sym\u00adposium on Compiler Construction, pages 172-184, 1984. Published as SIGPLAN Notices, \n19 (6). R. Giegerich. Composition and evaluation of attribute coupled grammars. Acts Informaticaj 25:355-424, \n1988. L. G. Jones. Efficient evaluation of circular attribute grammars. ACM Transactions on Programming \nLan. guages and Systems, 12(3):429 462, July 1990. R. K. Jullig and F. DeRemer. Regular right-part at\u00adtribute \ngrammars. In Proceedings of the SIGPLAN 8.4 Symposium on Compiler Construction, pages 171-178, June 1984. \nPublished as SIGPLAN Notices, 19 (6). U. Kastens. Ordered attribute grammars. Acts Infor\u00admu,tica, 13(3):229 \n256, 1980.  \n\t\t\t", "proc_id": "143165", "abstract": "<p>This paper introduces Composable Attribute Grammars (CAGs), a formalism that extends classical attribute grammars to allow for the modular composition of translation specifications and of translators. CAGs bring to complex translator writing systems the same benefits of modularity found in modern programming languages, including comprehensibility, reusability, and incremental meta-compilation.</p><p>A CAG is built from several smaller <italic>component AGs</italic>, each of which solves a particular subproblem, such as name analysis or register allocation. A component AG is based upon a simplified phrase-structure that reflects the properties of its subproblem rather than the phrase-structure of the source language. Different component phrase-structures for various subproblems  are combined by mapping them into a phrase-structure for the source language. Both input and <italic>output</italic> attributes can be associated with the terminal symbols of a component AG. Output attributes enable the results of solving a subproblem to be distributed back to anywhere that originally contributed part of the subproblem, e.g. transparently distributing the results of global name analysis back to every symbolic reference in the source program.</p><p>After introducing CAGs by way of an example, we provide a formal definition of CAGs and their semantics. We describe a subclass of CAGs and their semantics. We describe a subclass of CAGs, called separable CAGs, that have favorable implementation properties. We discuss the novel aspects of CAGs, compare them to other  proposals for inserting modularity into attribute grammars, and relate our experience using CAGs in the Linguist translator-writing system.</p>", "authors": [{"name": "R. Farrow", "author_profile_id": "81100184781", "affiliation": "", "person_id": "PP31075630", "email_address": "", "orcid_id": ""}, {"name": "T. J. Marlowe", "author_profile_id": "81100015273", "affiliation": "", "person_id": "PP39075638", "email_address": "", "orcid_id": ""}, {"name": "D. M. Yellin", "author_profile_id": "81407591756", "affiliation": "", "person_id": "PP39085828", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143210", "year": "1992", "article_id": "143210", "conference": "POPL", "title": "Composable attribute grammars: support for modularity in translator design and implementation", "url": "http://dl.acm.org/citation.cfm?id=143210"}