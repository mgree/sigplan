{"article_publication_date": "02-01-1992", "fulltext": "\n Bounded Fixed Point Iteration (Extended Abstract) Hanne Rlis Nielson, Flemming Nielson Computer Science \nDepartment Aarhus University, Ny Munkegade, DK-8000 Aarhus C Denmark tant to solve this recursion such \nthat termi- Abstract nation is ensured. In the context of abstract interpretation we In the denotational \napproach to static anal\u00adstudy the number of times a functional need ysis the problem is addressed as \nfollows. To to be unfolded in order to give the least fixed each program the analysis associates an ele\u00adpoint. \nFor the cases of total or monotone func-ment d of a complete lattice (D, L) of abstract tions we obtain \nan exponential bound and in values. In the case of an iterative or recursive the case of strict and additive \n(or distributive) programming construct the vallue d is deter\u00adfunctions we obtain a quadratic bound. \nThese mined as the least fixed point, FIX H, of a bounds are shown to be tight. Specializing the continuous \nfunctional H : D + D. Formally, case of strict and additive functions to func-the fixed point of H is \ndefined by tional of a form that would correspond to it- FIX H = u{Hil ]i > O} erative programs we show \nthat a linear bound is tight. We demonstrate the relation to sev-where 1 is the least element of D and \nU is eral analyses studied in the literature (includ-the least upper bound operation on D. It is ing \nstrictness analysis). well-known that the iterands IYil form an in\u00ad creasing chain in D and that 1 Introduction \nif Hk-l-= Hk +ll for some k >0 then FIX H = Hk1 We consider the problem of computing fixed points in \nstatic program analysis, The whole So the obvious algorithm for computing purpose of static analysis \nis to get informa-FIX H will be to determine the iterands tion about programs without actually running \nHOl, HIL,  . CNK?after the other while test\u00adthem and it is important that the analyses al-ing for stabilisation, \ni.e. equality with the pre\u00adways terminate. In general, the analysis of a decessor. If D is finite this \nprocess is guaran\u00adrecursive (or iterative) program will itself be teed to terminate, The cost of this \nalgorithm recursively defined and it is therefore imp or-depends on the number k of iterations needed \nbefore Permission to copy without fee all or part of this matertial is granted stabilisation, provided \nthat the copies are not made or distributed for direct commercial advantage, the ACM copyright notice \nand the title of the the cost of comparing two iterands, and publication and ita date appear, and notice \nis given that the copying is by permission of the Association for Computing Machinery. To copy other\u00ad \nthe cost of computing a new iterand. wise, or to republish, requires a fm arrd/or specific permission. \n@ 1992 ACM 089791-453-8/92/0001/0071 $1.50 We shall study how to minimise the cost of the above algorithm \nfor a first-order fram ework of static program analysis. We shall assume that the lattice D has the form \nAP~ B9 where A and B are jinite complete lattices and p and q are positive numbers. Most of our efforts \nare spent on minimizing the number k. Several interesting analyses for first-order functional languages \nfall within this frame\u00adwork, for example forward and backward strictness analyses [7], [13], constant \npropa\u00adgation [9], Iiveness analysis [9] and demand analysis [2]. Also denotational formulations of many \ntraditional analyses for imperative lan\u00adguages [1], [8] can be formulated within the framework. The running \nexample of this pa\u00adper is a variant of the definition-use analysis and it is presented in a denotational \nstyle in Appendix A. The motivation behind the anal\u00adysis and its correctness are described at length \nin [11]. And as we shall see later the restric\u00adtion to first-order is not really necessary. We shall \nconsider three versions of the framework: the general framework where functions of AP -+ B~ only are \nrequired to be total; this is written AP -+t B9, the monotone framework where functions of AP -+ B~ must \nbe monotone; this is written AP --i~ Bg, and the completely additive framework where functions of A~ \n+ B~ must be strict and additive (or distributive); this is written AP --+$. Bq. show that the number \nk of iterations needed to compute the fixed point of an ar\u00adbitrary continuous functional H is at most: \no exponential in the general and the mono\u00adtone frameworks, and e quadratic in the completely additive \nframework. In each of the three cases the bounds are shown to be tight. We shall be more specific about \nthe measure of size in the sections be\u00adlow. The above results hold for arbitrary contin\u00aduous funct ionals \nH. A special case is where H is in iterative form: H is in iterative form if Hh=f U(hog) for strict and \nadditive functions j and g. We then show that the number k of iterations needed to compute the fixed \npoint is at most o linear, and furthermore o the fixed point can be computed point\u00adwise.  Again the \nbound is tight. The immediate applicability of these ap\u00adproaches are illustrated on the example anal\u00adysis \nof Appendix A. We also apply the results to various analyses presented in the literature. In this extended \nabstract we have had to omit all proofs; most of these may be found in [10]. 2 The general and mono\u00adtone \nframeworks We shall first introduce some notation. Let (L, E) be a jinite complete lattice, that is o \n~ is a partial order on L, and each subset Y of L has a least upper bound in L denoted U Y. When d~ \nd Ad# d wesimply write dc d . Next we write C L: for the cardinality of L H L: for the maximal length \nof chains in L Forusachain dOCdl ~... c d~ has length k (and contains k + 1 distinct elements). Fact \n1 C(L ) = (C L)n for n >1. o Fact 2 H(L ) = n.(H L) for n~ 1. o We write 2 for the complete lattice with \ntwo elements O and 1 ordered by O ~ 1. Thus C2=2, and H2=l. 2.1 An upper bound We shall first present \nupper bounds on the heights of chains in the function spaces: Proposition 3 In the general framework \nwe have H(A +, B ) < (C A) . q.(H l?) forp, q >1. o Any monotone function is a total function so Proposition \n3 yields: Corollary 4 In the monotone framework we have H(A +m B ) < (C A) . q.(H B) for p,q >1. 1 We \nshall now apply Proposition 3 to the special chains obtained when computing fixed points: Theorem 5 In \nthe general framework any continuous functional H :(AP +f Bq) + (AP +t W) satisfies FIX H = HkJ-for k=(CA)~. \nq,(HB) This result carries over to the monotone framework as well. 1 Note that by finiteness of A and \nB the con\u00adtinuity of H merely amounts to monotonicity. Example 6 The analysis of Appendix A con\u00adsiders \nthe special case where A and B are the two-point domain 2. In this case Theorem 5 specialises to: H : \n(2P +~ 24 ) -+ (2P +~ 2~) hasFIX H=Hkl for k o: 2P.q. In Appendix A it is shown (Fact 22) that the factorial \nprogram gives rise to a continuous functional H : (23 +~ 23) -+ (23 -+~ 23) so, according to the theorem, \nat most 23. 3 = 24 iterations are needed to determine the fixed point. However, a, simple calculation \nin Ap\u00adpendix A (Examplle 21) shows that the fixed point is obtained already after the jirst itera\u00adtion! \nThus our bound is very pessimistic. o 2.2 The bound is tight Motivated by this example one may wonder \nwhether the bound of Theorem 5 is too pes\u00adsimistic. The following result shows that this need not be \nthe case: Proposition 7 In. the monotone framework we have H(A -+m B :) > (C A) . q . (H 1?) forp, q>l. \no All monotone functions are total functions so Proposition 7 yields: Corollary 8 In the general framework \nwe have H(AP +, B ) > (C A)~ .q .(H 1?) forp, q >1. o Combining these results we get H(AP +~ B) = H(AP \n+~ 13~) meaning that the maximal length of chains of total functions and monotone functions are the \nsame. This :may be slightly surprising since it is well-known that there are more total functions than \nmonotone functions. We then have the optimality of the bound expressed in Theorem 5: 73 Theorem 9 In \nthe general framework, for all finite complete lattices A and 1?, and for all positive numbers p and \nq, there exists a con\u00adtinuous functional such that FIX H # Hk ll for k=(CA) . q.(HB) assuming that k \n> 0. This result carries over to the monotone framework as well. o 2.3 Applicability of results We believe \nthat all interesting analyses will give rise to monotone functions so the real limitations of the results \nof this section are due to the requirement that the lattices must be finite. Therefore it is not surprising \nthat some of the well-known upper bounds on the required number of iterands are direct corol\u00adlaries of \nTheorem 5. As an example [12] states that strictness analysis of a first-order language has an ex\u00adponential \nupper bound. They consider func\u00adtions in domains of the form 2P + 2 and us\u00ading Theorem 5 we immediately \nget that at most 2P iterands will be needed. It is not known whether this is a tight bound but it has \nbeen shown that the exponential upper bound of strictness analysis of the untyped (higher\u00adorder) A-calculus \nis indeed tight [4]. In [5] there is a comparison of the number of iterations needed to compute the fixed \npoint for forward versus backward analyses. The domains of interest for the forward analyses have the \nform AP+A and, using Theorem 5, we get that at most (C A)P . (H A) iterations will be needed. For the \nbackward analyses the domains of interest have the form A+A~ and, using Theorem 5, we get that at most \n(C A) . q . (H A) iterations are needed. These bounds are lower than those stated in [5].  3 The completely \naddi\u00adt ive framework We shall now assume that the functions of in\u00adterest are strict and additive; by \nstrictness of a function h we mean that hl=l and by additivity that h(dl uc&#38;)=(hdl) u(hd2) Since \nthe complete lattices considered are all finite it follows that a strict and additive func\u00adtion h is \nalso completely additive, that is h(UY)=U{hd\\dc Y} for all subsets Y. Following [3] an element d of \na complete lat\u00adtice (L, ~) is join-irreducible if for all dl, dz ~ L: d=dll-l dzimpli esd=dlord=dz and \na complete lattice (L, z) is distributive if for all d,dl, dz G L: dn(dlu d2)=(dnd1)u(dnd2) Clearly \n1 is always join-irreducible but we shall be more interested in the non-trivial join\u00adirreducible elements, \ni.e. those that are not 1. To this end we shall write RJC L : for the number of non\u00adbottom join-irreducible \nele\u00adments of L. We thus have RJC 2 = 1. Fact 10 RJC(L ) = n . (R.JC L) and if L is distributive so is \nLn for n ~ 1. o Corollary 11 [3, p.73] If L is a finite and distributive complete lattice then we have \nRJCL=HL. o 3.1 An upper bound As in the general and the monotone frame\u00adwork we shall first give an upper \nbound on the length of chains in the function spaces: Proposition 12 In the completely additive framework \nwe have H(A +s. B ) < p , (RJC A). q o(H 1?) for p,q ~ 1. 0 We can now apply Proposition 12 to the special \nchains obtained when computing fixed points: Theorem 13 In the completely additive framework any continuous \nfunctional H : (AP +,. IN) + (AP +,. Bg) satisfies FIX H = Hkl for k=p. (RJCA). q.(H B). n The equality \ntest between the iterands HOl, HIL,  o can be simplified in this frame\u00adwork. To see this consider two \nfunctions hl, h2 ~ AP +.. W. Then hl = hz if and only if hl z = h2 x for all non-trivial join\u00ad irreducible \nelements z of Ap. An element z of A~ is a join-irreducible ele\u00adment if it has the form (1, ...,a, ,1) \nwhere a is a join-irreducible element of A. Example 14 In the case where A and B are the two-point domain \n2, Theorem 13 spe\u00adcialises to: H : (2P --+.. 29) + (2P -+,a 29) has FIX H= HkLfork=p q. The analysis \nof Appendix A turns out to be in the completely additive framework (Fact 23). For the factorial program \nwhere p = q = 3 we therefore get that at most 3 .3 = 9 iterands need to be computed. This is a substantial \nimprovement of the bound (24) determined in Example 6 but still the first iterand is equal to the fixed \npoint! 1 3.2 The bound is tight Motivated by this example we shall show that the bound of Propc~sition \n12 is tight when A is distributive. Proposition 15 In the completely additive framework we have H(A +~o \nB~)2p. (H A) q (HB) forp, q 31. o Combining Proposition 12 and 15 and using Corollary 11 we get H(Ap+sa \nBg)=p (HA). q.(HB) provided that A is distributive. One may ask whether the bound of Propo\u00adsition 12 \nis tight when A is not distributive. There is no general answer because there are examples where the \nbound is tight as well as examples where it is not tight. Thus the best optimality result we can es\u00adtablish \nfor the bound expressed in Theorem 13 is the following: Theorem 16 In the completely additive framework, \nfor all finite complete lattices A and B, for all positive numbers p and q, there exists a continuous \nfunctional H : (A~+J?Q)+(AP+s.Bg) such that FIX H # Hk l 1 for k=p. (H A). q.(HB) assuming that k >0. \n 1 3.3 Applicability of results Compared with the development of Section we have considered the additional \nrequirement that the functions of concern must be strict and additive. 75 Furthermore we have seen that \nif the domain of the functions is distributive then the bound on the number of iterations is tight. It \nturns out that there area number of inter\u00adesting analyses that do not satisfy these con\u00additions, but, \nfortunately there are also a large class of analyses that do, as e.g. the analysis of Appendix A. An \nexample of an analysis that does not give rise to strict and additive functions is forward strictness \nanalysis [7]. The abstract meaning of the conditional is often defined by if#($, y,z) = ~n (yu,z) and \nit is easy to show that if# cannot be an additive function. However, there are analy\u00adses of first-order \nfunctional languages that do give rise to strict and additive functions, an example is the liveness analysis \nof [9]. Further\u00admore, all the backward analyses formulated in the concrete (!) context domains of [5] \nusing context functions will also fall within our com\u00adpletely additive framework. The potential restriction \nto finite and dis\u00adtributive complete lattices is more severe. Consider for example an analysis for detec\u00adtion \nof signs. One possibility will be to base it on the complete lattice of Figure 1. However, distributivity \nfails. An alternative would be to use a more refined lattice as that of Figure 2 which is distributive \n(with neg, zero, pos and 1 being the join-irreducible elements). The finite distributive complete lattices \nare characterised in the following lemma where we write 7(D) for the Hoare power domain of the cpo D. \nLemma 17 L is a finite and distributive com\u00ad plete lattice if and only if L = T(E) for some finite cpo \n13. o 4 The iterative frame\u00adwork The upper bounds expressed by Theorems 5 and 13 are obtained without \nany assumptions about the functional H except that it is a con\u00ad tinuous function over the relevant lattices. \nIn this section we shall restrict the form of H. For iterative programs, for example those considered \nin Appendix A, the functional H will typically have the form Hh=fu (hog) where f and g are strict and \nadditive func\u00ad tions. Then the iterands Hil will be strict and additive so we shall restrict our attention \nto the completely additive framework. 4.1 An upper bound The first result is a refinement of Theorem \n13: Theorem 18 In the completely additive framework the fixed point of a functional H : (AP +,. l?~) \n+ (AP +~~ IP) defined by Hh=j U(hog) for ~EAP+S. ENand g~AP+.. APcan be computed pointwise. More precisely, \nif for some zo6A~andk~0 H;J-W = H;+ll W where Ho h = id u (h og), then $ IX H W=~(H;l W) Furthermore, \nit is possible to take k = p . (H A). o Basically this result says that in order to compute FIX H on \na particular value w it is sufficient to determine the values of the iterands Hjl at w and then compare \nthese values. So rather than having to test the ex\u00adtensional equality of two functions on a set of arguments \nwe only need to test the equality of two function values. Furthermore, the the\u00adorem states that this \ntest has to be performed at most a linear number of times. Figure 1: A non-distributive lattice for detection \nof signs analysis non-pos neg Figure 2: A distributive lattice for detection of signs analysis Example \n19 In the case where A and El are form. For the factorial progralm where p = the two-point domain 2, \nTheorem 18 spe\u00ad q = 3 we get that at most 3 iterands need to cialises to: be computed. Again we have \nobtained a sub- In the completely additive framework the fixed stantial improvement compared with Example \npoint of a functional 14 (and Example 6). o H : (2P +.. 2~) + (2P +,a 29) It is disappointing that we \nhad to introduce Ho in order to reason about H. However, one defined by can show that Hh=fu(hog) Hkl \nW = H~+ l_L W impliesfor f < 2P+.. 2Qand g 6 2P+.. 2Pcan be computed pointwise. More precisely, if for \nFIX Hw=H~l-w somew~2$ andk~O provided that H;L W = H;+lJ_ W fx~fy where Ho h = id u (h og), then implies \nFIX H W=f(Hjl W) (x~y)or(f~y=f T) Furthermore, it is possible to take k = p. where T is the largest element \nof the lattice. The functional considered in the analysis of This condition holds for the analysis of \nAp-Appendix A turn out to be of the required pendix A. 4.2 The bound is tight The above example shows \nthat the upper bound given by Theorem 18 is quite close to the number of iterations needed. The fol\u00adlowing \nresult shows that the bound is indeed tight. Theorem 20 In the completely additive framework there exists \na continuous functional H : (AP --+Sa l?~) + (AP +,. B~) of the form Hh=fu(hog) for ~GAP +S. B9 and \ngEAP+$. APand there exists w ~ AP such that at least p. (HA) iterations are needed. More precisely Hk-ll \nW#FIX H W for k = p o(H A) provided that (H B) >0 and (H A) >0. c1 4.3 Applicability of results Compared \nwith the development of the pre\u00ad vious section we now require that the func\u00ad tional H have a very specific \nform. In return Theorem 18 gives a very simple method for determining the fixed point of H. The analysis \nof Appendix A fulfils the con\u00additions of this section but certainly there are many analysis that do not. \nIt is worth observing that Theorem 20 ex\u00adpresses that there are functional that require p . (H A) iterations \nto determine the fixed point. Of course this needs not hold for a par\u00adticular analysis for a particular \nprogramming language because it may be impossible to ex\u00adpress a functional similar to that considered \nin the proof of Theorem 20. However, for the analysis of Appendix A we are very close as may be illustrated \nby considering the program while x~ = x~ do (Xn :=xn_l; . . ..x2 := xl) (The special nature of the flow \nof control property discussed in Appendix A means that we may have to subtract 1 from the lower bound,) \n   5 Conclusion For functional H : (AP + _B~) + (AP + l? ) we have considered ways of bounding the \nsize of the set XW in if HkJ_ v= Hk+ll vfor all v~XW then FIX Hw=Hkl w and ways of bounding the number \nk in FIX Hw=HkJ-w Our results are summarized in Table 1 (where we have not distinguished between H and \nHo). Additionally we have shown that the bounds on k are tight (except that in the completely additive \nframework we must assume that A is distributive). 5.1 Comparison wit h other work The ~rontiem approach \nof [12] describes a method for computing fixed points of func\u00adtional on domains of the form 2P + 2. The \naim of that work is similar to that of ours: to minimise the cost of computing fixed points. One of the \ncentral ideas is to represent a func\u00adtion h : 2P + 2 by the inverse images h-l O and h l 1. Using the \nmonotonicity of h these sets can be reduced so that they do not con\u00adtain redundant elements. The computation \nof the fixed point then proceeds by approximat\u00ading the frontier of the fixed point from above as well \nas below. We expect that our work can be combined with the frontiers approach. In particular we have \nlimited the number of arguments to be iterative scheme { 10} framework total or monotone x. AP k (C A) \n. q . (H B) 3 completely additive { x ~ AP ] x join-irreducible} p.(RiJCA). q.(HB) Table 1: Summary \n considered when comparing functions and this can be used to bound the size of the frontiers to be constructed. \nAs an example the maxi\u00admal size of a frontier constructed in the com\u00adpletely additive framework will \nbe p. This may explain the remark Frontier sets are typically small. Only contrived functions seem to \nhave large frontier sets found in [12]. In our ter\u00adminology, the contrived functions cannot be additive \nones. Another approach to computing fixed points is the minimal function graph approach of [6]. In this \nwork one considers the minimal set YW of (argument, result) pairs that has to be considered in order \nto determine the value of a function h for a given argument w: YW= { (d, h d) [h d must be computed in \norder to compute h w}. The approach can be used to determine the value of the fixed point of H for a \ngiven ar\u00adgument w by determining the sets YW for the various iterands. In the worst case all possible \narguments may have to be considered but on the average fewer arguments will do. We expect that our work \ncan be combined with the minimal function graph approach. In the completely additive framework the sets \nYW can be reduced as it will only be necessary to consider join-irreducible arguments and for all other \narguments the results can be computed using the additivit y of the iterands. 5.2 Further work In our \nfurther work we hope to investigate the relationship between the frontiers approach, p, (HA) 3 of results \nthe minimal function graph approach and that of the present paper, In particular, it would be interesting \nto bridge the fairly large gap between the results obtained in the monotone framework and those obtained \nin the com\u00adpletely additive framework. We also would like to investigate various re\u00adcursive forms of \nfunctional in iUl attempt to generalise the results obtained fcm the iterative forms. To prevent any \nmisconcepticms we should point out that our results, say of Sections 3 and 4, are not limited to a first-order \nframe\u00adwork of program analyses: simply take p = q way and use results like Facts 1., 2 and 10 to work \nout the bounds in the highler-order case. 1,let A and B be built in a compositional  References [1]A. \nV. Aho, R. Sethi, J. D. IJllman: Com\u00adputers -Principles, Techniques and Tools, Addison -Wesley, 1986. \n[2] B. Bjerner, S. Holmstromc A compo\u00adsitional apprc)ach to time analysis of first order lazy functional \nprograms, Functional Programming Languages and Computer Architectures, 1989. [3] G. Gratzer: Lattice \nTheory -First Con\u00adcepts and Distributive Lattices, W. H. Freeman and Company, 1971. [4] P. Hudak, J. \nYoung: Higher-Order Strict\u00adness Analysis in Untyped Lambda Cal\u00ad [5] [6] [7] [8] [9] [10] [11] [12] [13] \nCUIUS, Principles of Programming Lan\u00adguages, 1986. J. Hughes: Backward analysis of func\u00adtional programs, \nin Partial Evalua\u00adtion and Mixed Computation (Eds. D. Bj@rner, A. P. Ershov, N. D. Jones), North-Holland, \n1988. N. D. Jones, A. Mycroft: Dataflow of ap\u00adplicative programs using minimal func\u00adtion graphs, Principles \nof Programming Languages, 1986. A. Mycroft: Abstract interpretation and optimizing transformations for \napplica\u00adtive programs, Ph. D. thesis, University of Edinburgh, 1981. T. J. Marlowe, B. G. Ryder: Proper\u00adties \nof data flow frameworks -A unified model, Acts Informatica vol. 28, 1990. H. R. Nielson, F. Nielson: \nTrans\u00adformations on Higher-Order Functions, Functional Programming Languages and Computer Architectures, \n1989. H. R. Nielson, F. Nielson: Bounded Fixed Point Iteration, Technical report DAIMI PB-359, Computer \nScience Department, Aarhus University, 1991. H. R. Nielson, F. Nielson: Semantics with Applications -A \nFormal Introduction for Computer Science, Wiley (to appear in late 1991 or early 1992). S. Peyton-Jones, \nC. Clack: Finding fix\u00adpoints in abstract interpretations, in: Ab\u00adstract Interpretations of Declarative \nLan\u00adguages (edited by S. Abramsky &#38; C. Han\u00adkin), Ellis Horwood, 1987. P. Wadler, R. J. M. Hughes: \nProjections for Strictness Analysis, Functional Pro\u00adgramming Languages and Computer Ar\u00adchitectures, LNCS \n274, 1987.  A An example analysis To illustrate the practical consequences of the theoretical development \nperformed in this pa\u00adper we shall consider an analysis of a simple imperative language. The language \nhas five synt attic categories: c c Con: constants x E Var: variables xl, X2, . . ., x~ a 6 Aexp: arithmetic \nexpressions a ::=c\\z\\ aI*a2\\a1 az \\ b E Bexp: boolean expressions b::=al=azlmbl S < Stm: statements \n S::=z:=a[sl; sz I if b then S l else S2 ] while b do S The semantics of this language should be in\u00adtuitively \nclear. To describe the analysis we assume that Z G Var is a set of input variables, and 0 &#38; Var is \na set of output variables. The question to be asked of a statement then is whether there is a functional \ndependency between the input and output variables, that is whether the final values of the output vari\u00adables \nonly depend on the initial values of the input variables and not on the initial values of other variables. \nAs an example assume Z={xl}, andO= {x2} and consider the programs fat: X2 := 1; while =(x1 = O) do (X2 \n:=x2*X1; Xl := xl 1) fat : while 7(x1 = O) do (x2 :=x2 *x1; x1 :=X1 1) The final value of xz infac \nwill only depend on the initial value of xl so there is a func\u00adtional dependency between input and output \nvariables. However, the final value of Xz in fat will depend on the initial value of xl but also on the \ninitial value of x2; since x2 is not an input variable we do not have the required functional dependency. \n The analysis will operate on two properties O: meaning that the value definitely only depends on the \nvalues of in\u00adput variables, I: meaning that the value may de\u00adpend on the values of non-input variables. \n We shall write 2 = { O, 1} for this set of prop\u00aderties and equip it with the partial ordering ~ defined \nby O ~ 1. Then (2, C_) is a complete lattice and the least upper bound operation will be written U. The \nanalysis will keep track of the proper\u00adties of the variables. However to get a prov\u00adably correct analysis \nwe also need to keep track of whether or not the flow of control only depends on the initial values of \nthe input variables. Therefore the analysis will associate each statement S with a function 7[s] : 2 \n+1 - + 2 +1 that given properties (pi, . , p~, p~+l) of the variables x1, s , x~ and the flow of \ncontrol holding bejore S will determine the similar in\u00ad formation holding afler S. The definition of \n? uses similar functions T/t[a]: 2 +1 + 2 7Z?[b]: 2 +1 + 2 defined for arithmetic and boolean expressions \nin Table 2. Also it uses the auxiliary function CHECK: (2 +1 + 2) -+ (2n+1 -+ 2n+1) defined by CHECK \nh PS ps ifhps=O = (1,,.., 1) ifhps=l { The definition of T is given in Table 3. The overall algcwithm \nfor testing whether or not there is a functional dependency between the set Z of input variables and \nthe set 0 of output variables for a statement S then pro\u00adceeds as follows: construct the tuple ps = \n(P1, .  , p~, O) where pi = Oif and only if xi E Z,  apply the analysis to get ps = T[S]ps,  let ps \n= (pj,...  , P;) P:+l ) and return YES: if p~+l 1= O and P!= Ofor all xi E0, and No?: otherwise. Example \n21 For the program f ac we can as\u00adsume that Var =: { x1, X2} (i,e. n = 2) and that Z= {xl} and 0 = {X2}. \nWe then get 7[fac](0, 1, O) = (FIX H )(O, O, O) where H h = CHECK (~(P1, P2, P3).P1 u P3) U h o (~(Pl, \nP2>P3). (PI L.JP3,P1 LJP2 UP3,P3)) so that H h (pi, pQ, ps) (0, P2,0) U ~(0, P2,0) ifpl = P3 = O { \n(1,1,1) otherwise It follows that FMH = H1.1 as H2L = H1l.. We then get 7[fac](0, 1,0) = (0,0,0) and \nthe algorithm will give the answer YES. Similarly we get P[fac ](0, 1,0) = (0, 1,0) and the algorithm \nreturns the answer NO? as expected. o Table 2: Analysis of expressions P[x; := a](p~, , p~, , pn+~) \n= (pi, ?qs,;s,] = ?q!s,]o7[s,] P[if b then S l else Sz] = CHECK(PB[b]) ~~while b do S] = FIX H where \nH h = CHECK(PZ?[6]) u  , (ho PAfa](p~,.. u 7[SI] 7[S]) u ,pn+~),. T[SZ] ... pn+~) Table 3: Analysis \nof statements The analysis are referred to fulfils in the certain body of properties the paper: that \nFact 22 The functional H : (2 +1 + 2 +1 ) + defined by (2 + -..+ 2.+1) H h = CHECK(f) U (h og) is a \n2 +1 continuous + 2 and function g :2 +1 ~ for all 2 +1. choices of ~ : !3 Fact 23 ?[S] is a strict for \nall statements S. and additive function o \n\t\t\t", "proc_id": "143165", "abstract": "<p>In the context of abstract interpretation we study the number of times a functional need to be unfolded in order to give the least fixed point. For the cases of the total or monotone functions we obtain an exponential bound and in the case of strict and additive (or distributive) functions we obtain a quadratic bound. These bounds are shown to be tight. Specialising the case of strict and additive functions to functionals of a form that would correspond to iterative programs we show that a linear bound is tight. We demonstrate the relation to several analyses studied in the literature (including strictness analysis).</p>", "authors": [{"name": "Hanne Riis Nielson", "author_profile_id": "81100316576", "affiliation": "", "person_id": "PP43118881", "email_address": "", "orcid_id": ""}, {"name": "Flemming Nielson", "author_profile_id": "81100316685", "affiliation": "", "person_id": "P84491", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143165.143182", "year": "1992", "article_id": "143182", "conference": "POPL", "title": "Bounded fixed point iteration", "url": "http://dl.acm.org/citation.cfm?id=143182"}