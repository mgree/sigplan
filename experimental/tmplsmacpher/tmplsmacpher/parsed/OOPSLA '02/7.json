{"article_publication_date": "11-04-2002", "fulltext": "\n Migrating Legacy Engineering Applications to Java Tom Dickens - Associate Technical Fellow The Boeing \nCompany P. O. Box 3707 MC 67-LF Seattle, WA 98124-2207 425-234-1024 thomas.p.dickens@boeing.com  ABSTRACT \nThe Boeing Company, like many oth er engineering -centric companies, has a large base of legacy applications \nwritten in FORTRAN and C. In today s computing environment, maintaining and evolving these applications \nis becoming difficult. One such Boeing application, the Aero Grid and Paneling System (AGPS), is a 3D \n-geometry surface modeling tool. In the fall of 2001 we completed the migration of the AGPS source code \nfrom 300,000 lines of mixed C and FORTRAN to 150,000 lines of 100% Java. The migration resulted in many \nbenefits; some anticipated and some unexpected. The benefits include widespread portability of AGPS on \nengineering workstations and PC-class machines, allowing AGPS to embrace many modern programming capabilities \nreadily available in Java, greatly improving the maintainability and enhanceability of the AGPS source \ncode, and an increased robustness of the AGPS code. During the migration we also took the opportunity \nto rearchitect major areas of the code using object -oriented techniques, to modernize the graphical \nuser interface, and to implement a significant number of pending enhancements from our backlog. This \npaper looks into the details of the AGPS migration to Java, discussing our observations, lessons learned, \nmigration techniques, and what we see in the future computing environment. Data are presented and discussed \nto substantiate our conclusions that Java is well -suited for compute -intensive engineering applications, \nJava portability is a reality, Java performance is no longer a problem, and that embracing object -oriented \nprogramming techniques produces a much superior product with less effort. Keywords Java, C, FORTRAN, \nconversion, legacy, portability.  Copyright is held by the author/owner(s). Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for profit or commercial advantage and that copies bear this \nnotice and the full citation on the first page. To copy otherwise, or republish, to post on servers or \nto redistribute to lists, requires prior specific permission and/or a fee. OOPSLA 02, November 4-8, 2002, \nSeattle, WA. Copyright 2002 ACM 1-58113-000-0/00/0000 $5.00. 1. INTRODUCTION The Aero Grid and Paneling \nSystem (AGPS) [1,6] is an engineering application which, at its foundation, is a programming language \nwith built-in geometry features. AGPS can be run in an interactive graphics mode with typical mouse -driven \nuser interactions via menus, dialogs, and screen -picking. AGPS can also be run in a non -graphics batch-type \nmode, which allows it to be a geometry workhorse in automated engineering processes. AGPS arose in the \n1980s from requirements in the aerodynamic research arm of Boeing Commercial for tasks such as computational \nfluid dynamics (CFD) pre - and post -processing as seen in Figure 1, and is now used throughout The Boeing \nCompany for a diversity of geometry-related tasks. Figure 1. AGPS modeling a 747 with CFD field grids. \nThe AGPS application deals directly with parametric -based geometry primitives including points, curves, \nsurfaces, and solids; it does not have any specific knowledge of wings, missiles, or space vehicles. \nUsers can easily build domain -specific capabilities (we call them AGPS packages) on top of AGPS to addre \nss specialized geometry tasks related to building Boeing products, while the underlying AGPS program \ncan remain very geometry \u00adneutral. This flexibility has allowed Boeing engineers to very quickly prototype \nand develop task -specific packages to address new geometry problems without requiring enhancements to \nthe underlying core AGPS program. This approach directly explains the longevity as well as the wide-spread \nusefulness of AGPS.  2. AGPS MIGRATION HISTORY To set the stage for the recent Java migration of AGP \nS we will briefly outline the 20-plus year evolution of the program. AGPS originated in the early 1980s, \nfirst prototyped on a PDP -11 and then re -hosted on a then newly -acquired VAX 11 -780. This move took \nAGPS from a 16 -bit overlay -based computer architecture to a 32 -bit virtual-memory architecture. The \noriginal source code was written in three languages: VAX -specific FORTRAN for most of the geometry algorithms, \nPascal for the recursive language parser, and VAX assembly language for pointer manipulation of the in \n-core data structure as well as for speed. The display devices included VT -100 terminals for non \u00adgraphics \nuse, plus Vector General and Tektronix terminals for displaying graphics. A typical compile and link \nof the source code took from one to two hou rs. Running AGPS, while it was interactive, took from seconds \nto minutes for a typical geometry command. During this early stage of AGPS development much of the compute \n-intensive code was hand written in VAX assembly language to increase performance. The aerodynamics engineering \ncommunity started using AGPS heavily since there was no other automated tool available to address their \ngeometry needs. In the late 1980s AGPS was also hosted on a MicroVAX II workstation, which had a maximum \nof 16M of main memory and ran about 2/3 the speed of the VAX 11-780. From its inception, the underlying \narchitecture of AGPS was designed in a very object -oriented manner with the organization of the geometric \nobject types and also in the various geometry commands. Each share d a base commonality that was extended \nfor specific types and or commands. This architecture for the types and commands was carried over and \nembellished in the Java conversion. The internal geometric data structure was able to grow dynamically, \ntaking adva ntage of the then -new virtual memory capability. Within the FORTRAN code, large 1 hard \u00adcoded \narrays in common blocks were used. Over the years, the sizes of these hard -coded arrays were increased \nas computing hardware was available to allow larger and large r cases to be run. In the Java conversion \nwe removed all of the hard -coded limits and made the architecture completely dynamic to take advantage \nof new computer architectures in the future. In the late 1980s, with the emergence of engineering workstations, \nAGPS was converted to be UNIX -portable using the POSIX standards. The VAX -specific FORTRAN, Pascal, \nand assembly \u00adlanguage was converted to ANSI -standard FORTRAN and C. Version 5 of AGPS was the VAX -specific \nbaseline, and version 6 was UNIX -portable. This version had so many problems due to 1 In those days, \nlarge was 50,000 geometric objects, while today we routinely see cases of over a million geometric objects, \nand can imagine cases of tens or hundreds of million objects which cannot be run on today s generation \nof computers. the conversion 2 that it wasn t until version 7 of AGPS was released that the engineering \ncommunity started using it (this was a critical lesson to remember during the Java conversion). Through \nthe 1990s AGPS was fairly e asily migrated to a host of UNIX workstations, enabled primarily due to the \ngroundwork which was laid during the UNIX conversion. This included workstations from Apollo, HP, Sun, \nDEC, and SGI, as well as some mid-range systems including Stellar and Convex. The AGPS development team \nhad learned first-hand the importance of having application code as portable as possible, and we were \namazed that neighboring development groups would embrace a vendor \u00adspecific platform, Apollo workstations \nfor example, only to i ncur a huge migration effort a couple of years later when the engineering community \nmigrated off the Apollo workstations. We have seen continual migrations from one computing platform to \nanother every few years throughout the history of the project. During the 1990s we were tasked with migrating \nAGPS to Cray supercomputers (Y -MP and Triton), which were running UNIX. Even though the code was considered \nportable, the Cray architecture introduced a major new twist. Up to this point, all the platforms targeted \nby AGPS had two key features in common: 32\u00adbit words and memory was byte -addressable3. The Cray architecture \nhad 64 -bit words and it was word -addressable4. The then-current AGPS code used many thousands of hard \n-coded 4s in the source code; some of these sp ecifying the word-size, some of these specifying the word \n-based address -increment, and some that were part of some geometry -related calculation or equation. \nThe challenge with the Cray port was to identify and understand the usage of these 4s in the source code, \nand convert them to either 8s or 1s for word -size or address -stride respectively, or to leave them \nas -is for equations. We ended up using conditionally \u00adcompiled C code to set the global constants. A \nfew years later, with the arrival of 64 -bit byte-addressable workstations, we were positioned to easily \nport to that new architecture, specifying 8/8. On the graphics front, AGPS migrated from the various \ngraphics devices on the VAX 11/780 to X -Windows/Motif on UNIX plus a 3D-GL version on the SGI, while \nstill maintaining a non-graphics mode of operation for batch processing. This was the version of AGPS, \nnow called AGPS -classic, which was the baseline for the Java migration. Periodically the AGPS development \nteam would get requests to port AGPS to the PC. These requests were never taken seriously since the developers \nknew the dependencies of the code required FORTRAN and C compilers, X -Windows/Motif for graphics, and \nPOSIX-standard system calls. 3. NEED FOR BETTER PORTABILITY The trend the AGPS development te am saw \nin the 1990s was increasing requests to take AGPS to additional platforms as different engineering groups \nthroughout Boeing embraced new technology. Due to the increased effort to port AGPS, and to 2 I can be \ncritical about this since I was the primary developer for the UNIX conversion. 3 With byte -addressable \nmemory, incrementing a m emory pointer by 1 will point to the next byte in memory. 4 With word-addressable \nmemory, incrementing a memory pointer by 1 will point to the next word in memory, not the next byte release \nit simultaneously on multiple platforms, th e development team found themselves spending a greater percentage \nof their time working porting issues and less time working much -needed enhancements to the system. The \nbacklog of user -requested enhancements was ever growing; we needed a more efficient way of working. \nIn addition, while the underlying architecture of AGPS was very well designed, there were aspects that \nneeded revamping, which was difficult without a major rearchitectural effort. The team looked at various \noptions at this time, with the goal of revamping AGPS to reduce the effort in porting to new machines \nand in releasing on multiple machines, plus modifying the architecture to facilitate planned improvements, \nthus freeing up the development resources to work the backlog of requested enhancements. Considering \nthe current computing technology, and looking to the future, we develop a prototype using the then \u00adquite-new \nJava language. We also need to consider the larger picture. AGPS is used as one of many tools in various \nengineering processes t hroughout the company. To integrate well within these processes all of the components \nmust easily communicate and share data, and preferably run on the same platform to facilitate easy user \n\u00adinitiated inter-application coordination and automation. In such a n environment, with AGPS being used \nfor many different engineering processes, we cannot dictate which computing platform our users need to \nuse; we provide the most benefit by being able to run on whatever computing platform various engineering \nteams are using. With our diverse usage requirements, being portable to the large number of engineering \nworkstations used by our customers is a key offering of our system. This requirement for application \nportability is not unique to AGPS. We are seeing this need thro ughout the industry as engineering groups \nupgrade their computers, they may switch to another brand, OS, or architecture. Applications and data \nneed to be able to easily follow the hardware, OS, and architecture directions of their target customers. \nWe see Java as a current enabler in this. 4. JAVA PROTOTYPE When first considering Java as the language/platform \nto migrate AGPS to, we had many concerns about Java: its maturity, its performance, its longevity, its \navailability, and its evolution. This was warrant ed since at the time Java was very new. We were impressed \nby Java s underlying design, the simplicity of the language and the richness of the environment, and \nthe focus on object-oriented methodology. We undertook building a prototype as a proof -of-concept to \nprove to ourselves that Java was capable of the task, and to address our immediate concerns of overall \ncapability, GUI offerings, performance, garbage collection, and developer environment. The development \nteam was very impressed by the typical 2:1 Jav a development productivity increase[7,8]. Due to the strict \nJava compiler, many errors were caught at compile -time, allowing the development team to focus more \ntime on the higher-level system design and architecture. AGPS in concept is as a very modular s ystem. \nIn its core infrastructure it has user interaction, a GUI, a language parser, and a geometric-object \ndatabase. Accessible from this core are 30-plus geometric object types and 150 -plus geometric commands. \nFor a reasonable prototype we needed to impl ement pieces of the core language and GUI, but we could \nget by with only a few geometric objects and only a few commands. We wanted this prototype to be representative \nof real work, and to include compute -intensive algorithms. We opted to implement point, curve, and surface \ngeometric objects, and to implement commands to fit cubic curves and surfaces through sets of points, \nplus commands to draw them to the GUI and to evaluate them. The evaluation involves providing the parametric \nlocation on the curve (S) or surface (S,T), and getting back the physical location in space, plus the \nfirst and second derivatives. By implementing this small sub -set of the classic AGPS capabilities, and \ncomparing the evaluation results from both systems, we were able to confirm that the underlying mathematics \nand geometric algorithms were correct. We were also able to run performance tests on the two systems, \nand found the Java version took about twice the time for an operation as the C/FORTRAN version. We decided \nthat this 2:1 t ime was the minimum acceptable for a typical operation since we expected Java performance \nto improve while we were migrating the code, plus we had not looked into performance tuning and were \nconfident that we could re -code problem areas to achieve acceptab le performance (we had 20+ years experience \nin doing this in the C/FORTRAN version of the code). This first Java prototype looked good, so we continued \nexpanding the prototype at a low-level of effort through the end of the 1990s, adding more of the langu \nage capabilities, more geometric object types, and more commands. During this period, the AGPS development \nteam was still primarily focused on the classic version of the code. We looked at the migration to Java \nas a 4 to 5 year effort running in parallel w ith the mainline development, with the level of effort \nincreasing in the last 2 years. By 1999 the prototype was quite functional and the team then started \nplanning and scheduling the work to convert the remaining geometric object types and the remaining c \nommands to Java. We also got our engineering support team heavily involved with extensive testing of \nthe system, prioritizing the remaining work, and in driving new capabilities. One of the most frequent \nrequests I received from our users was to be able t o run AGPS on their desktop PC. We initially thought, \ndespite Java s claim of portability, that we would need to tweak the AGPS Java code to successfully run \non the various platforms. I tested the Java portability claim by placing a copy of our Java class files, \ncompiled on an SGI workstation, on a PC 1. To our utter amazement, AGPS ran fine on the PC! Without any \ncode changes! We ran many validation cases, including a complex TRANAIR-input[9] case as seen in Figure \n2. What had been jokingly talked about in past years, running AGPS on a PC, was achieved for free with \nour Java migration. We could not find any differences in the PC execution and detailed geometric evaluations. \nThe Java portability claims were actually true! In 2000 we released AGPS version 17 from the C/FORTRAN \ncode-base, and decided to make version 18 of AGPS the Java version by the end of 2001. The Java prototype \nwas looking very good, a majority of the commands were successfully converted and tested, and the portabil \nity had proven itself, so the Java development effort was taken from the back burner and was our 1 A \n233MHz PC, 64M memory, running Windows 98. Our current typical PC plat form is a 1GHz PC, 256M memory, \nrunning Windows 2000. team s main thrust. We were convinced that the Java version would provide us the \nexpected benefits to allow the development team to soon focus on much -needed f uture enhancements. We \ninformed our user -community about this change to get their feedback and to start forming expectations. \n 5. ARCHITECTURAL DECISIONS During the prototyp ing phase, and even more during the formal development \nphase of the project, we had the opportunity to make decisions about the architecture of the new AGPS. \nOur goal was to have a system which was highly modular, had no built -in limitations on the size of data \nstructures or other user -perceivable items, and was easily extendable in terms of the language, the \ngeometric objects, and the commands. We also had the requirement that AGPS command files 1 which ran \nin the AGPS classic version would run without modification in the Java version and which would achieve \nthe same results. We also had a performance requirement. All of these items and issues needed to be balanced \nwhen designing the architecture of the system. Java provided many capabilities which were us ed to produce \na highly-modular and extendable architecture. Unlike the classic version of the code, the Java version \ndoes not have hard -coded lists of commands or geometric object types. Instead, the Java application \nqueries the environment for command- and geometric\u00adobject classes, which then become part of the running \nsystem. This resulted in a very simple process for adding commands and geometric object types to the \nsystem; just add the classes in the classpath and the system picked them up an used them . This even \nworked during a running session with a new command added to the mix dynamically. In the old C/FORTRAN \ncode, we would have had to add the new code, plus add entries in various lookup and dispatch tables, \nand recompile and link the application. T he Java solution was much easier and gives more extensibility. \nWe also extensively used object -oriented design techniques and Java coding practices to organize the \ncode. All commands are extended from a base command class, and all geometric objects extend from a base \ngeometric object class. In addition, the class hierarchy of the geometric objects was multi -level, grouping \nsimilar classes of points, curves, surfaces, and solids under appropriate parent classes to share common \nfunctionality, as shown in Figure 3. We also used Java interfaces with the geometric object classes to \nbe able to work in a general sense with non-directly related classes. This allowed us to pass around \nspecific objects in a generic sense, thus making the code very general and not geometric-type specific. \n class Aob (implements java.lang.Cloneable, java.lang.Comparable, java.io.Serializable)  class Cob (Curve \nObject) o class Type14 (Rational B-Spline Curve)  o class Type16  o class Type17  o class Type27 \n   class Pob o class Type23  o class Type33   (Segment Chain Curve) (Polynomial Curve) (Two-View \nCurve) (Point Object) (Lattice) (Point-Matrix) o class Type34 (Unstructured-Surface-Grid)  o class \nType35 (Unstructured-Volume-Grid)  o class Type8 (Array)  o class Type9 (String)   class RSTob (Rotated/Scaled/Translated) \n o class Type10  o class Type11  o class Type12  o class Type22   class Sob  o class SPob  class \nType4  class Type5  class Type6 o class Type13  o class Type15  o class Type18  o class Type19 \n o class Type20  o class Type28  o class Type29  o class Type36  o class Type37  o class Type7 \n  class SRob o class Type3  class Tob o class Type21  o class Type32    (Rotation) (Scaled) \n(Translation) (General Transformation)  (Surface Object) (Surface Patch) (Linear Patch) (Cubic Patch) \n(Quintic Patch) (Rational B-Spline) (Trimmed Surface) (Patch Network) (Surface Of Revolution) (Tube Surface) \n(Conic Cross Section) (Transfinite Interpolant) (Radial Basis Function) (Subdivision Surface) (Grafted \nSurface)  (Subrange Object) (Subrange)  (Text Object) (Text) (Procedural Object)  class Type32... \n(various subtytes) class Type0 (List) class Type1 (Boundary Representation) class Type2 (Composite) \nclass Type30 (Linear Combination)  class Type31 o class Type31...  class Vob o class Type24  o \nclass Type25    (Display-Element) (various subtytes)  (Volume Objects) (Hyper Patch) (Solid) Figure \n3. Annotated class hierarchy for AGPS Objects within 1 An AGPS command file is a text file of AGPS commands \nand the package boeing.agps.types. language constructs. It can be read and executed by AGPS, facilitating \nautomated processing of data. An overall goal with our classes was to keep as much instance data private \nas possible; imp lementing accessor methods to validate and control changes in data values. This has \nproven to be very successful in avoiding the classic common -block data issues seen in large FORTRAN \nprograms, where global data was available to be changed by any part of the code. Another key architectural \nchange was the manner in which the inputs to each of the commands was validated. In the classic version, \neach command validated its keyword input values as it was processing the command. If an error was detected, \nthe command issued an error message and exited, returning to the command parser. We saw similar checks \nbeing done over and over in this code, and error messages which should be the same would be slightly \ndifferent since they were generated from different commands . We desired a central keyword -checking \ncapability in the old code, but this would have been a major architectural undertaking and was never \ndone. In the Java conversion, we designed this into the architecture from the beginning. All command \nclasses are ex tended from the base Cmd class. We designed a convention for each command to detail the \nnumber and types of input arguments (keywords) it had, and implemented classes to support parsing (CmdTokenizer) \nand storing (CmdDefinition) this information. A command object is created for the specific command using \nthe CmdMaker factory method (make), then a checkKeywords method, which is defined once in the parent \nCmd class, is invoked on the command object. If an error is encountered checking any of the keywords \nan exception is thrown, otherwise the exec method is invoked on the command object to execute the command-specific \nlogic. CmdTokenizer t = new CmdTokenizer( cmdStr ); CmdDefinition cDef = getCdef( t ); try { // Make \nCommand Structure Cmd c = CmdMaker.make( t, cDef ); // Check Keywords if ( !c.checkKeywords( cDef ) ) \n{ c.exec(); // Execute Command c.dispose(); // Clean Up } // end if } catch ( ParseEx per ) { ... Figure \n4. Command creation, checking, and execution. This single checkKeywords method will validate the arguments \nfor all commands, and a standard error message is generated in case of errors. The exec method in the \ncommand classes can assume that it will not be invoked unless all keywords are confirmed good. We implemented \nmany types of keyword checks, including: Integer, with optional minimum and maximum range.  Real number, \nwith optional minimum/maximum range.  Text string.  Word from a list of words, with the feature of \naccepting the first few unique characters, i.e. y matches yes if no other words start with y .  Reference \nto a geometric object, with optional specification to the allowed types, dimension, etc.  Color name \nor index.  Filename, either input or output.  When we finished the central keyword c hecker we had \nsuccessfully satisfied dozens of pending software change requests (SCRs) to fix error checking and to \nmake checks in multiple commands work the same. Plus, the code in each of the individual commands was \nnow free from pages of error checking and could just implement the command logic. Other areas in which \nwe were able to implement major architectural improvements were in the graphics driver code, the language \nparser and dispatch, handling numeric variables, and the handling our in -core databas e of geometric \nobjects. These capabilities were developed in black -box classes or packages with very simple interfaces, \nisolating the rest of the code from their internal details. I should mention that there are parts of \nthe Java code which were implemented in a quick and dirty way to get the prototype running, and which \nneeded to be re -worked. This re -working of the code had to be balanced with the push to get the code \ninto production. While the team did have the opportunity to re -work many areas of the code to implement \na much cleaner design, there are known areas which are still waiting for cleanup and re -design. We are \nplanning to work these issues along with user -requested enhancements to the code over the next year \nor two. Through this process we h ave found Java to be a very malleable medium in which to program. We \ncan drastically change one part of the system, and if the interactions with the rest of the system were \nwell designed, there would be minimal (or no) impact on the rest of the system. Oth er changes impacted \nmany areas of the system, requiring global re -design and re -working of the code. These changes told \nus that the system was not well designed in these areas, since a local change required global re-design. \nWorking and re-working aspects of the code like this help to weed out poorly \u00addesigned areas and help \nevolve the code into a much better object\u00adoriented system. Of course there is often resistance within \nthe team to pull the code apart and re -design it, but we have seen time and time aga in the benefits \nin cleaner and easier -to-work-with code by doing this. A significant result we achieved in migrating \nto Java was a 50% reduction in the number of lines of our code. The C/FORTRAN classic version of the \ncode was about 300,000 lines of mixed C and FORTRAN (about 50/50). We worked very hard over the years \nto keep the size of the code small, to keep the system understandable by a small team. The resulting \nJava code with the same capability was only 150,000 lines of code. This included extensive javadoc comments \ndocumenting our design and algorithms (1/3 of the 150,000 lines of code were comments) and also included \nmany enhancements. We account for this reduction in code size as one of the strengths of object -oriented \ndesign and programming; we we re able to work the design more abstractly and at a higher level. I would \nmuch rather have the team maintaining 150,000 lines of code than twice that much.   6. NEW CAPABILITIES \nAlong with the migration to Java, we significantly enhanced the final product, taking advantage of some \nadvanced programming techniques available in Java where it made sense. As mentioned above, the Java program \ndynamically locates command classes and adds information about each command to the system, including \nadding menu selections a nd help references as directed by each command. We did a similar thing to the \ngeometric object types, locating them dynamically and having each class provide describing information. \nThe key to making this work is the Java Reflection capability which allows the program to, on the fly, \ncreate an object from a named class. We kept the constructors for these classes the same we their required \nparents, making the dynamic object creation very simple. We took advantage of a few of the Java extensions \n(javax) to build on. We used JavaHelp to offer a very nice hierarchical, indexed, searchable help system \nwith very little effort. We use the JavaMail capabilities to integrate creating and sending e -mail into \nour system, including attaching images of the generated gra phics to the message. We have not yet implemented \nAGPS I/O in XML, but have experimented with the XML capabilities in Java 1.4, which supports XML very \neasily. We also generate javadocs for the entire system, which are heavily used by the development team. \nIn the classic code we had written our own Postscript driver to generate printer -ready images. The Java \n-provided printing capabilities didn t give us the resolution we needed, so we implemented a simple but \nelegant solution. We wrote our own OfpGraphics c lass which was a sub -class of Graphics that implemented \nthe AWT primitives we used for drawing and rendering, and generated the required Postscript code. We \nthen pass an object of type OfpGraphics to the draw -window s paint method and the Postscript code f \nor printing is generated. We did not have to write specific Postscript rendering logic besides a collection \nof graphics primitives, and the paint method which draws to the window did not have to be changed to \ngenerate printer output. A big improvement is t hat we know the printer output will be exactly the same \nas what we see on the screen since the same scene-generating code is used for both. There were some capabilities \nthe old system did not have for printing since the Postscript-generating code was not k ept entirely \nin sync with the screen-rendering code. Doing these with common code was much simpler and keeps them \nin sync, satisfying more SCRs in our backlog of work to do. Figure 5. External application using the \nAgpsApi and the AGPS jar file. At one time there was an AGPS interface library for other applications \nto use; allowing codes to interactively work directly with AGPS -defined geometry. It required an additional \neffort to develop and maintain this interface, and over t ime this capability was discontinued due to \nlack of resources. With the Java version of AGPS, the resulting jar file containing the AGPS executable \ncode is also, by definition, an application -usable library of Java code. We developed a central class, \nAgpsA pi, as a focal -point for application developers to start with for using AGPS -as-a-library capabilities. \nInstead of looking through and understanding hundreds of classes, they had a place to start which offered \nmost of the capability they needed. As seen in Figure 5, an external application can use this AgpsApi \nclass to access internals of AGPS, and can also drill directly into the AGPS jar file as needed. We are \nseeing other Boeing projects building applications on top of the AGPS jar file, saving them from developing \ntheir own geometry engine, and allowing them to be AGPS compatible. 7. MIGRATION TECHNIQUES The development \nteam used many different development techniques during the prototyping phase and the conversion phase \nof the proj ect. Early on we developed many small prototypes to understand and experience aspects of \nJava which were then new to us. This included explorations in the areas of performance, reflection, graphics, \nclient/server communications, remote procedure calls (RMI ), environment properties, file I/O, and launching \nexternal processes. We also explored in detail Java s variable scoping for static and non -static instance \nvariables to develop standard mechanisms to be used in our command classes and our geometric -object \nclasses. The investigation led to my understanding of instance variables in an hierarchy of extended \nobjects as existing in layers of an onion, where a method defined at a higher (inner) level can only \ndirectly access a variable defined at or above that level, even though the same variable name is used \n(overridden) at a lower extended level. Once this reality of Java was discovered through small prototypes \n(I have not seen details about variable scoping to this level in any text) we were able to use this k \nnowledge and design a very simple and understandable mechanism for accessing command -specific information \nin a general way. The original design of AGPS was quite object -oriented in the layout of the geometric \nobject types, but the C/FORTRAN implementation was not as elegant. Being one of the core concepts of \nthe application, we worked the design of the geometric-object classes fairly early in the prototyping \nphase. A base class was established for the AGPS Objects (Aob) which defined data (name, type, physi \ncal and parametric dimension, list of ancestors, etc.) that was common for all geometric objects, plus \na number of accessor methods and generally -used AGPS object manipulation methods, such as renaming an \nobject, deleting an object, attaching one object to another, and so on. The design of the specific geometric \nobjects evolved into a class hierarchy for different fundamental types (points, curves, surfaces, solids, \nand text objects), as shown in Figure 3, where common data and methods were added, followed by the specific \ngeometric object types, such as a cubic surface patch or a quintic surface patch (differences being the \nnumber of coefficients and equations for evaluation). It was very rewarding to implement the AGPS geometric \nobj ects in an object -oriented syntax since their conceptual design from 20 years prior had laid out \nthese concepts. AGPS command files, written specifically to use the implemented subset of capability \nin the current Java prototype (JAGPS), would also run in t he classic version. This was very beneficial \nin that we could run a command file in AGPS and also in JAGPS, comparing the resulting geometric objects \nin precise mathematical detail to confirm the proper conversion of the equations and the geometric-object \ncreation and manipulation logic. We developed comparison techniques which allowed us to automate much \nof the AGPS to JAGPS evaluation and comparison. Being required to have JAGPS equivalent with AGPS in \nmost respects was both a burden and a blessing. This limited some of our design decisions, but when it \ncame to testing it was very nice being able to compare the two systems side -by-side and to walk through \ninvolved equations to confirm they were correctly implemented. On the subject of converting equations, \nAGPS had some of the math-intensive code in FORTRAN and some in C. There were fewer issues converting \nthese C equations to Java since Java uses a subset of the C syntax and the arithmetic is the same. There \nwere places where C pointers were used, as well as multi-dimensional arrays being passed into C functions \nby address (from C and also FORTRAN). These issues were the only complication in the C equation conversion. \nThe FORTRAN code, besides having a different syntax from C/Java, had some additional conve rsion issues. \nFORTRAN array indexes are 1 -based, not 0 -based as in C/Java. In multi -dimensional arrays, the array \nelements are located sequentially in memory as the first index is incremented in FORTRAN, but as the \nlast index is incremented in C. Multi \u00addimensional arrays in Java are even different; they are not a \nsingle contiguous block of memory, but are implemented as an array of arrays. Thus, a 2-dimensional array \nof 32-bit integers dimensioned 500x500 in C would allocate memory for 250,000 elements (1,000,000 bytes), \nin Java it creates an array of 500 elements, each element being an array of 500 ints, thus creating 501 \nobjects. There is much more overhead in this storage and also in accessing the multi-dimensional array \ndata. Understanding this we decide d to use multi -dimensional arrays in parts of the Java code, but \nin some key areas we re -wrote the algorithms to use single \u00addimensional arrays and used either index \n-offsets or a multi \u00adargument accessor method to simulate the multi -dimensional use of the da ta. This \nwas particularly important for temporary data used in methods called frequently since we did not want \nto pay the garbage -collection penalty. We also used techniques of allocating arrays as static class \nvariables to maintain a single common scrat ch array used within the class, but had to be careful to \ninitialize the array for each use. Speaking of common storage, a typical FORTRAN program uses common \nblocks, which are named shared global collections of data. This is done to share global data in di fferent \nparts of FORTRAN without explicitly passing the data into the subroutine, and was also used historically \nto allow areas of large data storage to be re -used by different parts of a program for different uses \n(the common block would have the same nam e, but the data defined in that area could be of different \ntypes). This programming practice was not very clean and led to many errors when code evolved, but was \nnecessary in the past when memory space was a very limited commodity and operating system support for \nmemory management was also limited. AGPS used many FORTRAN common blocks, which had to be totally re \n-designed in JAGPS. This did cause difficulty in understanding the conventions for passing data in AGPS, \nbut once understood and then converted to J ava the resulting code was much more understandable and maintainable. \nDuring the conversion process the development team coined the term JavaTran to refer to FORTRAN code \nwhich was converted to Java, but which still looked like FORTRAN and did not feel like nice object-oriented \nJava. We did some of this to just quickly prove concepts, but I must admit that some of this JavaTran \ncode still exists in the system. The development team is constantly combing through the code, replacing \nthe JavaTran code when it is located with much better code. One such global effort in the code is the \nuse of a Point objects instead of small arrays of data. In AGPS you can evaluate a geometric object at \na specified location and retrieve information, including the N -dimensional physical data, plus first \nand/or second levels of derivative information which is the curvature and change of curvature information \nabout the underlying object. We developed a hierarchy of Point classes to use for evaluation and subsequent \nequation use which greatly simplifies the resulting code. Given a surface object surf, and a position \nto evaluate s,t, the code evaluates the surface and does a calculation: double[] par = new double[2] \n; double[] phy = new double[12] ; par[0] = t ; par[1] = s ; surf.objEvl( 3, 1, par, phy ) ; sum = Math.sqrt( \nphy[3]*phy[3] + phy[4]*phy[4] + phy[5]*phy[5] ); Figure 6. Original object evaluation scheme. Param2D \npar = new Param2D( s, t ) ; Point3Dd1 phy = new Point3Dd1() ; surf.objEvl( par, phy ) ; sum = Math.sqrt( \nphy.xs*phy.xs + phy.ys*phy.ys + phy.zs*phy.zs ) ; Figure 7. New Point-based object evaluation scheme. \nWe see in this example, Figure 6 and Figure 7, t he new point \u00adbased code is simpler, and is much easier \nto read and understand. With the index references to phy it is not clear what the equation is doing, \nwhile defining phy as a Point object we can easily see that we are calculating the magnitude of the S \n-derivative. Also notice that the curve evaluation call, objEvl, does not require two magic numbers to \ndefine the desired physical and parametric dimensions to use; the types of input arguments indicate these \nparameters. If we needed second derivatives , with the old method we would need to change the number \n12 to a 27 to dimension the needed space for the data, change the 1 to a 2 in the objEvl call to indicate \nto return physical data plus first AND second derivatives, then use the correct indexes to ac cess the \ndata. In the new method we just change the phy variable from Point3Dd1 to Point3Dd2, then after the objEvl \ncall just access the higher derivatives, from xss through zsstt. The resulting equations would read like \na typical text on the subject. The question has been asked quite often if we used automated code conversion \ntechniques. Our goal was to re -implement AGPS in Java for easier maintenance, not just convert it. Even \nthough there were some code -conversion available (and more available today), we did not want a machine \n-generated code which would be as difficult to work with as our classic C/FORTRAN code. We also wanted \nto redesign major parts for ease -of-maintenance and to lay the foundation for known future enhancements; \nconverting the code as-is would not accomplish this higher requirement. However, there was one section \nof code which was converted using a machine -generated technique. There are places in AGPS where output \ncan be formatted using user -provided FORTRAN format syntax1. There is code in the classic AGPS which \nparses and processes the FORTRAN format string, but it is a subset of 1 Alas, sometimes backward compatibility \nf orces one to maintain old (obsolete) ways of doing things. the actual FORTRAN capability due to the \ncomplexity and generality of the format specification. We really wanted to improve our support with FORTRAN \nformatting (there were a few SCRs about this), but the complexity of the code was daunting. A member \nof the development team tried writing a simple FORTRAN subroutine which had a formatted I/O statement, \nand then processed the code through a public -domain FORTRAN to C converter, f2c. The resulting C code \nincluded a general-purpose FORTRAN format processor. We wrapped this resulting C code into a Java class \nand converted a few C structures into private classes, making it 100% Java. The resulting Java file, \nless than 3 000 lines of code, is full of cryptic names and large switch blocks, but it generates very \ngood FORTRAN formatted output. We made all but the highest -level methods in the class private, and mostly \njust stay out of that file. This f2c -generated code does in clude a copyright along with permission \nfor free usage and distribution, which we carry along with the code, plus directions that the company \nnames should NOT appear in any advertising or publicity without their written permission. Thus, in a \nfew hours we had a much -improved FORTRAN formatting capability in our code without the need to design \nand write that code ourselves, and we successfully worked many more SCRs. 8. ACCELERATED RELEASES Historically \nwe released a new version of AGPS every 12 to 24 months. The majority of the time was for the developers \nto work on the code fixing problems, working porting issues for new target platforms or operating systems, \nand also to implement enhancements. The team has an engineering half which handles testing of the code, \ngathering and tracking our software change requests (SCRs), writing the user manual (currently over 1000 \npages) and help pages (with support from technical writers), plus consulting with our users and developing \nAGPS command files for various users. Typic ally their release -related work was concentrated in the \nlast few months before a release. Enhancements were much quicker to implement in the Java version. After \nthe initial Java release, 18.0, in the fall of 2001, we grouped proposed work and planned relea ses every \n2 to 3 months. For the development team this was doable, and we were very excited about this increased \nrate of implement system changes. However, we quickly discovered the bottleneck for achieving a release \nwas now our engineering support side, n ot the developers. They could not address the quick pace of releases \nfor updating the documentation, running extensive validation tests, and writing new validation cases \nfor the new capabilities. As a team we looked at the overall release process and settl ed on a 4 -month \nrelease cycle, which is still significantly better in getting new capability in the hands of our users \nthan the old 1 to 2 year cycle. The engineering team has also worked very hard to streamline many of \ntheir process which support a releas e. We are making more of the validation testing automated, and we \nrun a complete suite of automated tests each night right after the automatic nightly build of the entire \nsystem is complete. This nightly automated smoke test has caught regression errors in the code the morning \nafter they were introduced, rather than waiting weeks or months for them to be found manually. It is \nalso much more efficient to find and fix errors soon after they were introduced in the code rather than \nhaving other code possibly depend on them and the developers forgetting some subtleties of their work. \nWe can now address bugs introduced to the code almost immediately. The rapid release cycle has also caused \nthe team to work some process on a continual basis rather than work them during the last phase of a release, \nthen put the process on the shelf for a year or two. We have experienced many times that after a year \nor two a needed process is misplaced, the person who was the expert has moved on to another job, computers \nhave change d and the process, which required certain programs, is now quite broken, and a host of other \ndifficulties in resurrecting an inactive process. With a 4 -month release cycle we find it easier to \nwork many of these processes in a continual and incremental man ner rather than let work pile up and \nthen try work it just before a release. This is particularly helpful with our documentation processes; \nthe team finds it very nice having documentation continually reflecting the current capabilities of the \nsystem rathe r than reflecting the capabilities available in the previous release. Our users are very \nexcited and appreciative of a 4 -month release cycle. In the past many users would not request enhancements \nto the system since they knew they would not see them until at least the next release, which may be up \nto two years away. They had pressing engineering work to accomplish and would have to find a way to proceed \nwith their work with the system as -is. Looking at the SCR backlog, we have some SCRs which are were \nsubm itted many years ago, and with the classis C/FORTRAN code would never have been worked. Now, with \nthe 4 -month release cycle, users are excited about making enhancement requests and knowing they could \nsee them in the system within a couple of months, or in a Beta version very quickly. We have been combing \nthrough the SCR database backlog with a refreshed point of view and planning which SCRs will be worked \nin which upcoming release. It is very rewarding to be working on enhancements as well as internal archi \ntectural issues rather than spending the majority of our time on porting and OS-upgrade issues. 9. PERFORMANCE \nREVISITED java Virtual Machine (JVM) into CPU -specific machin e code. Our initial testing using Java \n1.1 had a performance ratio of about 2:1 (a process which took 1 minute in the old AGPS took 2 minutes \nin the new JAGPS). This was on the bounds of acceptability to proceed with the Java prototype. We had \nexpectations that from this point we could achieve a 1:1 or better performance ratio based on two assumptions: \n1) better Java compilers and virtual machines being available when we release, and 2) fine -tuning critical \nsections of our code for performance. We saw drama tic improvements before our release, as seen in Figure \n8. The left -most column shows the performance of the baseline C/FORTRAN version of AGPS running on an \nSGI workstation; this is our baseline timing of 1. The second column shows the as-released timing of \nAGPS using Java 1.3.1. In a series of tests it was slightly slower than the baseline, a ratio of 1.1:1. \nEarlier versions of Java showed a 2:1 ratio. The next 5 columns, all run on a 933MHz PC, show two important \nthings. Comparing th e as-released product using 1.3.1 Java we see a 0.3:1 ratio; the PC version is 3 \ntimes faster than the SGI baseline C/FORTRAN version! Secondly, these 5 columns show the changes in performance \n(using the same test case) in the different versions of Java. T here was no improvement from Java 1.1.8 \nto 1.2.2. The move to 1.3.0 saw a vast improvement in performance, and we expected to see this continue \nto improve. Unfortunately the next two versions of Java we tested, 1.3.1. and 1.4b3, lost ground in performance. \nOur hope is that 1.4.x will regain some of the performance improvements seen with 1.3.0. While we have \nnot investigated much in the area of internal code improvements ourselves besides addressing slow file \nI/O and replacing empty Vectors in our Aob geomet ric-object classes with seconds. This is for a complete \ncompile of the entire AGPS system; smart incremental compiles take just a second or two. This vast improvement \nin speed -to-compile has had a direct impact on developer productivity, and has even allowed the developers \nto change their testing and debugging practices. With Java on the PC we can now add a few print statements \nin the Java code, incrementally rebuild, and in a very few seconds be seeing the results. We can try \nthings in the code and see the results in near real time, rather than waiting minutes to see the results \nof a code change. This allows a continuous train of thought in the development process, which greatly \nimproves productivity. After seeing the data on performance I was curious about the historic performance \ntrend of workstations versus PCs. I worked with our UNIX administration support to dig up performance \nand cost data for the past 15 years about the engineering workstations used in our area, as seen in Table \n1 below. Table 1. Cost and performance of workstations. Year Workstation MIPS $ 2000 $ 1986 VaxStation \nII 0.9 $58,922 $92,576 1991 Apollo DN4500 4.0 $20,809 $26,309 1996 SGI 4D35 31.7 $29,325 $32,185 2001 \nSGI Indigo2 624.5 $34,866 $34,866 We also gathered cost and performance data on the current PC for the \nsame years as seen in Table 2. Table 2. Cost and performance of PCs. Figure 10. Relative performance \nof workstations versus PCs. Plotting these data show that PC performance has been increasing at a faster \nrate than workstation performance. Over the same period the cost of workstations has remained abo ut \nthe same, around $35,000 in constant year -2000 dollars, while over the past 10 years the cost of a current \nPC has dropped from over $10,000 to under $1,000. Combining these data in Figure 11 shows in a quantitative \nmanner what many people have been instinctively feeling, that the same unit of work can now be accomplished \non a less-expensive PC in less time. Also realize that the data I used was generated in late 2001 with \na 933 MHz PC. The current common PC in the summer of 2002 is a 2+ GHz system with more memory for even \nless money. Well, of course there is more to the story an these raw numbers. Back 15 years ago, while \nworkstations were fairly robust, the PC lacked the memory, C and FORTRAN compilers, and the stability \nto be used for serious scientific work 1. We currently have PCs with plenty of computer power, plenty \nof cheap memory, and they are getting more stable. Wi th the option to run Linux on desktop PCs, especially \nfor compute -intensive work, the stability issue of the operating system is no longer a problem, while \nwe retain the impressive PC cost and performance advantages. We are starting to see a migration of engineering \nwork and engineering applications from the workstation -class machines to the PC-class machines. We are \nfortunate in two respects: that we have migrated to Java which gives as a PC -port for free, and that \nwe are in Java which allows us to, with a single set of source code, to simultaneously support both workstations \nand PCs as our customer base becomes split between these two very different computing platforms. We don \nt need to recommend one over the other, but can easily deliver our product on w hichever platform our \ncustomers require. 10. ISSUES Here is a list of issues we had during the conversion, plus continuing \nissues as and our organization are facing. 1 I know from first-hand experience working with PCs since \nthen. Legacy FORTRAN code : There is a looming problem quickly heading our way; we have millions of l \nines of legacy FORTRAN code being maintained by an aging workforce (average age is 47), with no one coming \nalong to replace them. FORTRAN is not taught in the colleges anymore. We cannot find software developers \ncoming out of the schools who know, or want to know, FORTRAN. Many of these legacy codes in Boeing must \nbe maintained due to FAA regulations for as long as the airplanes they support are flying, which 20 to \n40 years. What is Boeing, and many other engineering -based companies, to do in the future to support \nthese legacy codes? Java 3D : We decided not to use the Java3D capabilities as we needed to duplicate \nthe existing rendering capabilities which are used to make precise engineering decisions about our products; \nthe Java3D capabilities did not give us the precise rendering control we needed. Java Education : Our \nproject is still one of the few Java development projects in our area in Boeing, but I have seen more \nand more interest over the past year. I have been in touch with other software developers throughout \nthe company, from Seattle to St. Louis, Philadelphia, Witichita, and Long Beach, to share ideas, lessons \nlearned, and best practices. Our focus is to not push Java specifically, but to encourage others to embrace \ncode portability, modern langua ges, modern tools, and modern practices to make their development efforts \nmore productive and longer lived. Java has been very successful in our area, and may also be the right \nfit for other efforts. Java Apprentices: In an effort to spread the working kno wledge of Java in our \norganization, our group started a Java apprentiship program. Apprentices are typically programmers who \nhave taken some Java classes, but in their current job assignment they are not using their Java skills. \nWe bring them into the AGPS development team 1 day a week, teaching them advanced Java techniques and \nthe AGPS architecture. We identify a specific task for them to implement in the code (one or more related \nSCRs) and supervise them working the changes. After 3 to 5 sessions with th e development team an apprentice \nis working on their own and doing productive work for the group, while still learning and reinforcing \ntheir Java skills. A typical apprentice stays with the team from 4 to 6 months, while some have stayed \non longer. This is a win -win-win situation for the AGPS group, the apprentice, and the organization \nas we seed Java experience and concepts of code portability, code modernization, and object -oriented \ndesign throughout the organization. This program has gained very strong management support as we have \nhad over fifteen apprentices through the program, and are expanding it into other development projects \nthat are now working with Java. Java Virtual Machines (JVM) : There has been concern about our decision \nto embrace Java in li ght of the recent reports of Microsoft dropping Java from their operating system. \nWe see this as a non -issue. Our tactic in our PC installation thus far has been to install, locally \nwithin the AGPS installation, the JVM that AGPS counts on. This will not a ffect any currently-installed \nJVM on the PC, and will also run if their machine does not currently have a JVM installed. Thus the JVM \nbecomes just another installed component of the AGPS installation, and AGPS will not break in the future \nif a user updates or removes their global JVM. Just because Microsoft may elect to not install a JVM \nas a default with a future operating system, they cannot prevent an application from installing their \nown local JVM. PC Compatibility : While we have AGPS, the program, runn ing well on the PC platform, \nAGPS, the system, still needs some work. The entire AGPS system includes a larger number of AGPS command \nfiles that launch external jobs using the local operating system and also invoke local executable programs. \nHistorically these OS jobs are UNIX (was VMS long ago) and the executable programs are compiled C or \nFORTRAN. These cause problems on the PC since UNIX commands are not recognized, and compiled external \nprograms need to be ported to the PC. We have taken a number of ste ps to address this. We have identified \nthat most of the UNIX commands used in AGPS command files are to work with files (delete, rename, copy, \ncheck for existence, set permissions, etc.). We wrote a new AGPS command to do these file operations \nthrough Java in an OS -neutral manner. We then change the command file conventions to use the new capability \nto make the command files portable. We are considering using cygwin[10], a UNIX environment for Windows, \nto keep using UNIX convention in the command files and to teach Windows how to properly run them. The \nother issue is the external executable programs used by command files. Even on UNIX system these must \nbe compiled for each target platform, which is not desirable. We are looking at the functionality these \next ernal programs give us, and if we can duplicate the functionality with AGPS, if we can write a simple \nJava program for this, or if we need to maintain platform-specific code. We are looking at this on a \ncase-by-case basis and how to eliminate most, if not all, of these external programs from the system. \nSecurity Concerns: Releasing a Boeing proprietary application in Java raised some security concerns, \nespecially since many of our engineers will be installing AGPS from CD onto PCs. Java class files can \nbe d ecompiled to regenerate the Java source code, and the class files are easily extracted from the \njar files. We have done this, and the resulting code is amazingly similar to the original. We have many \nhundreds of man -years invested in the AGPS source code a nd do not want to give away the source with \nany AGPS installation. To address this concern we have used two available techniques: obfuscation of \nthe class files and encryption of the jar file. Obfuscation involves running a program which takes the \nclass files and re-names all non-public classes, variables, and methods to be non -legal names, from \nthe point of view of the compiler. The Java virtual machine does not care about these illegal names; \nit uses them just fine, but when the class files are decompiled into source, the source cannot be compiled. \nIn addition, these illegal names are typically very cryptic or use reserved words, like if for and int \nfor user -defined names. Thus, the resulting decompiled source code is extremely difficult to read. Not \nimpossible, but it would require a lot of effort to decompile the system and work it into a usable form. \nThe second step we take is to encrypt the jar file. This then requires the correct key to extract the \nclass files in the first place before they can be decompiled. The running Java application can work with \nthe obfuscated and encrypted and obfuscated jar file, but it obstructs attempts to re-generate our source \ncode from the jar file. 11. SUMMARY The AGPS development team s detailed experiences converting a legacy \nC/FORTRAN engineering application to the Java programming language were discussed. It was shown that \nJava is a good fit for engineering applications, that the resulting performance is good, and the advertised \nJava portability works extremely well. The resulting gains in development, maintainability, robustness, \nplus the achieved portability made the migration to Java an extremely good investment for this legacy \nprogram and our engineering customers. 12. ACKNOWLEDGMENTS My many thanks to the AGPS develop ment team; \npast, present, and future, and also to our numerous engineering users who design such prodigious and \nremarkable products using AGPS. 13. REFERENCES [1] AIAA-87-2902, David K. Snepp and Roger C. Pomeroy, \nA Geometry System for Aerodynamic Design. [2] Arvel E. Gentry, Requirements for a Geometry Programming \nLanguage for CFD Applications, from Proceedings, Software Systems for Surface Modeling and Grid Generation \nWorkshop, NASA Langley Research Center, April 28-32, 1992. [3] Fliegel David C., Thomas P. Dickens, and \nAndrew P. Winn , Experience With a Geometry Programming Language for CFD Applications, SAE -AIAA World \nAviation Congress and Exposition, September 28 -30, 1998, Anaheim, California. [4] Dickens, Thomas P. \n, Cooperative Solutions Coupling a Geometry Engine and Adaptive Solver Codes, Surface Modeling, Grid \nGeneration, and Related Issues in Computational Fluid Dynamics (CFD) Solutions , NASA Publication 3291, \nMay 9-11, 1995, Cleveland, Ohio. [5] Dickens, Thomas P., Technique for Using a Geometry and Visualization \nSystem to Monitor and Manipulate Information in Other Codes, Software Systems for Surface Modeling and \nGrid Generation , NASA Publication 3143, April 28 -30, 1992, Hampton, Virginia. [6] AIAA-91-0800, W. \nK. Capron and K. L. Smit, Advanced Aerodynamic Applica tions of an Interactive Geometry and Visualization \nSystem. [7] http://www.sdtimes.com/news/014/special3.htm [8] http://softwaredev.earthweb.com/java/article/0,,12082_6027 \n11,00.html [9] AIAA 87 -0034, S. S. Samant, et al., TRANAIR: A Computer Code for Transonic Analy ses \nof Arbitrary Configurations, AIAA 25th Aerospace Sciences Meeting, Reno, Nevada, January 12-15, 1987. \n[10] http://www.cygwin.com/       FEATURE CI F O3G Version Ja a Conclusionma%wRa 1 a 1 300,000 \n150,000 LRamau Platforms 1 G aIv1Iv rW Workstations d y drWt wh e ocaoc Functionality Baseline B EE n \nWadV Enhancements E FunctionalityLuea alavl t Months t d dtdB anmata a Performance Baseline 1 GSa1 S \nSSaSBtB1 SB ocmau a.ae Expertise Disappearing Growing Leading-aDevelopment r 30       \n\t\t\t", "proc_id": "604251", "abstract": "The Boeing Company, like many other engineering-centric companies, has a large base of legacy applications written in FORTRAN and C. In today's computing environment, maintaining and evolving these applications is becoming difficult. One such Boeing application, the Aero Grid and Paneling System (AGPS), is a 3D-geometry surface modeling tool. In the fall of 2001 we completed the migration of the AGPS source code from 300,000 lines of mixed C and FORTRAN to 150,000 lines of 100% Java. The migration resulted in many benefits; some anticipated and some unexpected. The benefits include widespread portability of AGPS on engineering workstations and PC-class machines, allowing AGPS to embrace many modern programming capabilities readily available in Java, greatly improving the maintainability and enhanceability of the AGPS source code, and an increased robustness of the AGPS code. During the migration we also took the opportunity to rearchitect major areas of the code using object-oriented techniques, to modernize the graphical user interface, and to implement a significant number of pending enhancements from our backlog.This paper looks into the details of the AGPS migration to Java, discussing our observations, lessons learned, migration techniques, and what we see in the future computing environment. Data are presented and discussed to substantiate our conclusions that Java is well-suited for compute-intensive engineering applications, Java portability is a reality, Java performance is no longer a problem, and that embracing object-oriented programming techniques produces a much superior product with less effort.", "authors": [{"name": "Tom Dickens", "author_profile_id": "81100583530", "affiliation": "The Boeing Company, Seattle, WA", "person_id": "P414283", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604251.604260", "year": "2002", "article_id": "604260", "conference": "OOPSLA", "title": "Migrating legacy engineering applications to Java", "url": "http://dl.acm.org/citation.cfm?id=604260"}