{"article_publication_date": "11-04-2002", "fulltext": "\n EXTREME EMBEDDED A REPORT FROM THE FRONT LINE Gary Mueller 195 Garnet Street Broomfield, Colorado 80020 \n303-465-4279 garymueller@qwest.net ABSTRACT Many embedded development environments are stuck somewhere \nin the backwash of software technology. Structured programming practices, with the artifacts of those \nmethodologies liberally scattered about, are the norm in these environments. The world has changed since \nstructured methodologies first emerged, with shorter and shorter market windows and increasingly sophisticated \ncustomers demanding more and more capabilities at lower and lower cost. Embedded system development must \nalso adapt to these market imperatives to stay competitive. This paper describes the challenges, obstacles, \nand successes encountered in applying eXtreme Programming on an embedded legacy product with a team of \nseasoned, veteran C programmers.  Keywords Embedded, eXtreme programming 1. INTRODUCTION Our team consisted \nof nine seasoned C programmers with 10 or more years of experience on a successful embedded legacy product. \nThe group was responsible for the firmware for all versions of the product which had been in production \nfor more than 10 years. Prior to eXtreme, the software development process was structured on the waterfall \ndevelopment model. Code reviews, code walkthroughs, design reviews and process reviews were the norm. \nRequirements were vaguely defined at best and at worst non-existent. The product design was documented \nin a 2000+ page document which was updated irregularly. New product features were added as appendices. \nTo determine what the product actually did required reading 100,000+ lines of 10\u00adyear-old C code. The \ncode had been changed and modified by several dozen different programmers, most of whom were no longer \nwith the product or the company. As requirements changed and new hardware was added, the C compiler construct, \n#ifdefs, was used to handle the change. The prolific use of #ifdefs was taken to whole new art form. \nThe code was fragile, difficult to maintain and understand. Janet Borzuchowski Storage Technology Corporation \n2270 South 88th Street Louisville, Colorado 80028 303-673-8297 janet_borzuchowsk@stortek.com Parallel \ndevelopment which allowed multiple people to change the same file at the same time was used. Copies of \nfiles were merged and conflicts resolved during code builds. Testing software consisted of running and \ndebugging the code in the lab on hardware. System integration testing was done by our group prior to \nsystem testing. No isolated software testing was done. System testing, i.e. hardware and software together \nas one unit, was done by a separate testing group prior to product release. This paper describes the \nexperiences of using eXtreme programming practices in an embedded software project. 2. OUR EXTREME ENVIRONMENT \n--WHAT WE TRIED 2.1 Code Development Following the eXtreme practice of pair programming, two people were \nassigned to a new feature or fix. The pair was responsible for design, code, and test of the feature \nor fix. Stories instead of design reviews were used to describe the design and the group reviewed the \nstories. In our environment, the eXtreme practice of testing before development was strongly encouraged \nbut not mandatory. Unit tests were run on a workstation, not on the hardware. Because of the group s \ndesire to learn objects and Java, Junit, a test harness written in Java, was the test framework. Since \nthe modules under test were written in C or C++, the Java Native Interface (JNI) tied the unit tests \nto the module under test. In our case, any pair could and did refactor code regardless of who the original \nauthors of the code were. Most code changes were not reviewed by the group, but by the pair. However, \nsome code reviews were still held for changes that affected many modules. Because the group had different \nlevels of expertise in different areas of the code, pairs frequently sought out the advice of group members \nwho were more knowledgeable in a particular area. Whenever possible, experienced members were paired \nCopyright is held by the author/owner(s). with inexperienced members in order to propagate product knowledge. \n 2.2 Code Builds Continuous integration and customer driven small releases are key eXtreme practices. \nThe customer prioritizes and drives the requirements which are implemented in simple, small well-tested \nincrements. In order to implement these practices, the code build process must be nimble, fast and light \nweight. EXtreme programming uses metaphors to enhance communication among team members. In order to understand \nand communicate the code build process to the group, we used the metaphor of cooking soup to explain \nthe old and new way of building code. Using compile time constructs (#ifdefs), a single primary code \nbase, the soup or base stock, built the firmware for each version of the product. Runtime constructs \n(case and if statements) also determined the firmware version at runtime. When code was ready for external \ntesting or release, a new product code base was created and cloned (canning the soup) from the primary \nbase code. The one primary code base built the code for all flavors of the product. Initially, all code \nchanges were added to the primary base code first (cooking the base stock), and then, as needed, to the \nproduct code base for a particular product (cooking the version soup). As new versions of the product \nwere added, it became increasingly difficult to first add code changes to the primary base code in a \ntimely manner and then propagate these changes to the necessary product code base. Because the build \ntool was cumbersome, the build process eventually evolved to adding code changes only to the product \ncode bases. Thus, it became necessary to merge or resynchronize each separate product code base with \nthe primary code base. In order to resynchronize the code bases, all changes from each product code base \nwere merged together as quickly as possible (adding more soup ingredients) to create a new primary code \nbase in one massive code merge and build. Complicating matters, a build person, not familiar with the \ncode changes did the code integration and code merge. The build person was responsible for resolving \ncode conflicts and worked with developers if necessary to resolve the conflicts. Because a significant \namount of time had elapsed between builds, the individual product code bases had diverged significantly \nfrom the primary code base. Creating a new soup became a test of will, memory and endurance (the base \nstock boiled over). Resolving this many code conflicts required between one and five days. This new primary \ncode base, as well as the many product code bases, were all created at the same time. This was a far \ncry from adding small incremental changes to the code. You are expecting the external test group for \ndinner at 6pm. You come home at 5pm and put a large pot of water on the stove, add all of the ingredients, \nseasonings and vegetables, to the soup at the same time, and begin cooking the soup. Since you only have \nan hour to prepare the soup, you turn the burner to high. The soup boils over and you have a big mess \non your hands.  This describes our prior build process-- the guests are the external test group who \nexpect to be served code on a specific date. Our group is the cook, dumping and merging all the code \nchanges (the soup ingredients) at the last minute, and at the same time. The code is the soup and the \nboiling over is all the merge conflicts that must be addressed. In order to avoid some of the problems \nwith the old code build process, we modified the process slightly. One primary code base (soup) was still \nused, but all code must be added to this base. Code changes may not be added only to the product code \nbases. They must be added to the primary code base first. Code changes (soup ingredients) are added to \nthe primary base in a controlled manner. Merge conflicts are resolved immediately. The primary and product \ncode bases are no longer allowed to get out of sync. New primary and product code bases are created as \nneeded (canning the soup). Since all code changes are in the soup (primary code base), it is not necessary \nto merge the product code bases. If a new product code base is needed, it is built from the primary code \nbase. Although the product code bases are not merged back into the primary code base, each product code \nbase may be thought of as a different flavor of soup with changes that must be first added to the primary \ncode base. The new way of cooking soup is described in Figure 2. All code changes and bug fixes for each \nproduct are added to the primary code base. Bug fixes for a specific product version are included in \nthat product s code base. The developer now does code integration and merging into the primary code \nbase immediately after unit testing. Bug fixes are still integrated and merged by the build person for \nthe product code bases, although the developer may chose to do the code merging. The developers are responsible \nfor resolving code conflicts. Integration tests are run each day on the primary code base (soup). Again, \nyou are expecting the external test group at 6pm. In the morning of your dinner party, you fill a large \npot with water to cook soup. Through out the day, you add seasonings and vegetables to the simmering \nsoup. The burner is set on Low. Your guests arrive and are served delicious soup, and are quite satisfied. \n The guests are still the external test group, and the cook is our group. The soup is our primary code \nbase, simmering on the stove until it will be canned and become a product code base. Each of the product \ncode bases can also be thought of as soup simmering on a stove.  2.3 Code Schedules Prior to eXtreme, \neach developer was responsible for estimating their work. A master schedule was built from the individual \nschedules and schedules were reviewed and updated weekly. Now, each pair partitions work into small tasks \nof 1 to 5 days. Short meetings are held 3 times a week where the task status and task schedules are updated \non white boards. The schedules are archived weekly by taking pictures of the white boards with a digital \ncamera. The master schedule holds major milestones and is updated weekly or as needed. Recently, new \nprojects are tracked not on a white board but electronically with a spreadsheet and displayed on an overhead. \n3. EXTREME BENEFITS/CHALLENGES --WHAT WORKED AND WHAT DIDN T WORK 3.1 Code turnaround Although we made \nsome improvement in the code integration and build processes (code was built and tested nightly), the \ntool used for source control was complex and cumbersome. Quick turnarounds were difficult. One day was \nrequired to build a new code base and new code bases were generally built every couple of weeks. The \nproblem was that once code was submitted to the code base, it was not available for checkout until a \nnew primary code base was created. This meant that if you made changes to a module and checked it in \nto the primary code base, and then checked out the same module, you would not have the latest version. \nOnce code was submitted to the primary code base, it was not available for checkout until a new primary \ncode base was created. This process was a major deterrent to rapid change and code turnaround. As a result, \nour code was not turned quickly, and many developers, including us, hung on to code longer than eXtreme \nteaches, and returned the code in massive integrations. Because the code merge process was so painful, \nit was delayed as long as possible. In some cases code was not integrated for months and included hundreds \nof files, an obvious violation of the eXtreme practice of simple, small, incremental code changes. Although \nparallel development avoided file access conflicts between developers, it only postponed the resolution \nof code conflicts. Code conflicts remained unresolved until the next primary code build. Parallel development \nin combination with a complex and cumbersome code build tool and process yielded slow code updates. Problems \nmerging and synchronizing the code base, although somewhat diminished, still took a minimum of 1-5 days. \n 3.2 Unit tests Since unit tests were not required most new code was not unit tested. When unit tests \nwere written, they were either written in C, just using Junit as a test harness or were written in Java \ntaking full advantage of Junit s capabilities and strengths. Most pairs did not write any, and just as \nbad, if the existing unit tests broke because of some code changes, most pairs and individuals did not \nfix them! EXtreme supports code refactoring by requiring unit tests to insure the integrity of code changes. \nBecause schedule was paramount and getting the product out the door was a top priority, some pairs and \nindividuals would refactor the code without fixing or writing unit tests. Code was refactored as deemed \nnecessary by the pairs, but unit tests were ignored. Thus, there was nothing to check and balance the \nrefactoring between different pairs and individuals, with code changes ping-ponging back and forth. This \npoor adaptation of eXtreme did not make us a top 10 eXtreme team. Unit tests must be written to protect \nthe code from quick, untested fixes! 3.3 Customer EXtreme emphasizes the need to prioritize work based \non customer input both for clarifying requirements and determining which requirement is most important. \nA customer of an embedded software product is typically not interested in the software alone, but rather \nis interested in the entire product which is a melding of both software and hardware. Product features \nare usually a combination of enhanced hardware and new software to support the hardware. Because our \ncode was one component in a larger product, our customer and their desires was not always clearly defined. \nInstead of focusing on the end user of our product, we focused on the closest user of our software, the \nproduct hardware. We did work closely with hardware groups to define and prioritize hardware/software \nrequirements. We did not have the luxury of asking an external customer to clarify and prioritize requirements. \nThe company culture placed this responsibility in the hands of the product management team who had representatives \nwhich interacted directly with external customers. We had only indirect interaction with real customers. \n 3.4 Scheduling EXtreme programming preaches small incremental code changes. The scheduling or planning \nprocess is the same way. Each task is broken into small increments. The intent is to unit test and complete \nthe increments in the estimated time. Add the code to the base and then rebuild the code base. How often \nthe code base is rebuilt is a function of how quickly unit tests can be written, how quickly the code \ncan be tested and how long it takes to integrate the changes into the code base. How quickly each of \nthese tasks are done is a function of the tools used for unit testing and source code control and the \nprocess in place for building source code. When the tools are burdensome and the process heavy weight, \nadding small reliable code in the way eXtreme preaches is difficult, if not impossible. Unfortunately, \nthere is a downside to small incremental scheduling. Without a schedule tracker, it is very easy to lose \nfocus on the overall schedule and the big picture. It is critical that someone (the tracker) be responsible \nfor tracking the big picture relative to the amount of time each task is taking. It is very easy to get \nvery good at estimating small tasks but to lose track of whether the larger tasks are tracking to the \noverall schedule. Although our team tried to follow the eXtreme practice of estimate, work and estimate \nagain, the culture did not support replanning schedules particularly if the new schedule exceeded the \ninitial schedule. Once a new feature or fix was agreed upon and scheduled, it was very difficult to change \neither the schedule or the functionality. Each pair was expected to meet the initial schedule regardless \nof how accurate it was. Schedules were cast in concrete and required an act of God (the program team) \nto change. Scheduling and the team meetings degenerated into an exercise of explaining your schedule. \nIf your pair was behind schedule, you were asked why. As long as the schedules did not increase, there \nwas no problem. Initially, each pair worked 40 hours on their task, but as the deadline approached the \npair did whatever was necessary to meet the deadline and not look bad. Because the overall schedule was \nnot well tracked and schedule replanning was not allowed or encouraged, the team worked overtime to make \nup a two-month deficit in the project delivery schedule. 3.5 Pair programming Pair programming proved \nto us that two heads are indeed better than one. With one person of the pair acting as a programmer and \nfocusing on the details and the other person acting as a designer and looking at the big picture, many \nmistakes which otherwise would have gone unnoticed until later were found and fixed early in the development \ncycle, thus avoiding the higher cost of problem fixing later in the cycle. Normally a pair is huddled \naround a single workstation to test and write code. We tried a variation with each member of the pair \nco-located in the same office working at separate workstations. With this configuration, many simple \nand repetitive tasks such as adding a method call to many different modules, could be split up and worked \nin parallel. Each member of the team worked together on design and complex coding tasks. Pair programming \nenabled product knowledge to be shared and passed to inexperienced team members. Individual work schedules \nplayed a factor in the productivity of a pair. EXtreme requires pairs to be onsite at the same time to \neffectively produce and test code. Pairs whose members worked different shifts or different hours or \nat home were not as productive. A lot of time was wasted bringing one or the other pair member up to \nspeed on the status of the task. Vacations needed to be coordinated to keep pairs together. Unlike the \neXtreme practice of rotating team members on a regular basis, pairs were kept together until the assigned \ntask was completed. All pairs were not created equal. Personalities and attitudes toward embracing change \ndefinitely played a role in the productivity of a pair. Our pairs ran the gambit. One pair (us) was extremely \nproductive, introducing a new language (C++) and a new methodology (Object design), refactoring a major \npiece of new functionality and producing 55,000+ lines of code in 6 months, including unit tests. On \nthe other extreme were team members who believed that eXtreme programming was a total waste of time and \nresources and could not be convinced otherwise. Because of time pressures, bug fixes were not included \nin the eXtreme programming experiment, even though there was no technical reason not to apply eXtreme \nprogramming practices. It was difficult to work with members of the group who did not embrace change \nand had a hard time adjusting to the new methodology. 3.6 Code Standards EXtreme teams follow a common \ncoding standard, so that all the code in the system looks as if it was written by a single --very competent \n-- individual. The specifics of the standard are not important: what is important is that all the code \nlooks familiar, in support of collective ownership. Coding standards have always been a point of contention. \nWe are sure that many of you have been in meetings where the location of brackets is hotly debated. A \nlot of time is spent defining and documenting coding standards and then enforcing code standards in reviews. \nEXtreme does say it is important to have consistent code, mostly so that different pairs are able to \neasily exchange code and not get bogged down in worrying about where to place brackets. In our environment, \nsince modules need to be merged with other copies of a file, changing tabs to spaces and moving brackets \ncan lead to a nightmare when the file is merged and updated. Unfortunately, some individuals in the group \ninsisted in following their own coding style. They changed the coding style of the modules they were \nmodifying. This resulted in unnecessary code merge conflicts. Simplifying coding standards rather than \nmaking them more complex and detailed seemed to us to be more in the spirit of eXtreme which emphasizes \nsimple, small code changes. We suggested a one-line code standard --Use the coding style of the module \nyou are changing. If you are creating a new module, pick a style from an existing module and use it. \nGranted this may lead to a couple of coding styles in a product, but we believe it is time to get over \nthe pettiness and inflexibility of coding standards and embrace code diversity. 3.7 Resistance to change \nWe championed for changes to the source control tool and in the code build process but were unable to \nsway the very strong opinions against change. Another process which we felt should be changed was parallel \ndevelopment. Parallel development in combination with a slow code build process resulted in code merges \nwhich were problematic and tedious. We suggested doing away with this practice, but again, were met with \nadamant opposition. We championed talking to the other developers, and merging in code as soon as possible, \nwith only one person able to lock a checked out file. Even though there were numerous problems merging \ncode into a module that was changed by multiple developers, the group clung to this out dated and eXtreme \ninhibiting process. 4. EXTREME PROCESS IMPROVEMENTS --HOW THINGS CAN BE BETTER 4.1 Better testing The \nmore testing that can be done early in the development cycle, the better the product will be at the end. \nEXtreme promotes the idea of writing unit tests before code is developed. Writing unit tests actually \nflushes out and clarifies requirements, because the pair is forced to think about the specifics of behavior \nand in particular about error conditions. Unit testing should be required. Without unit tests, there \nis no assurance that the new code works or that the old code isn t broken. 4.2 Simulators In most embedded \nenvironments, hardware is either very scarce or expensive or unstable and in some state of debug. Although \nhardware simulators have an initial up front cost in terms of development and support, a good, reliable, \nrobust simulator will allow embedded software to be tested independently of the hardware and in many \ncases will allow the software to be tested under error conditions difficult or impossible to be created \nin the hardware. Remember a hardware simulator is an internal software product which must be developed \nand maintained just like any other external software product.  4.3 Better tools Tools are always a key \nto the success or failure of any project. Good, easy to maintain and use software tools are priceless. \nA quick, reliable, easy to use software code control tool is critical and a flexible easy to use test \ntool is also a necessity. For eXtreme, these two tools are paramount to the success or failure of a project. \nTools like Junit which are freely available and provide the necessary functionality for writing and running \ntests are indispensable. Avoid tools which require a specialized person to maintain and use. 5. REFLECTIONS \n--WHY THINGS WORKED OR DIDN T WORK 5.1 Comparison of eXtreme in embedded versus non-embedded projects \nHaving worked in both embedded and application software environments, we found nothing intrinsically \nspecial about the embedded environment regarding eXtreme. However, since most embedded software is one \nstep removed from hardware and since hardware changes slowly, the prevailing attitude toward software \nchange was similar, i.e. software should change slowly and in step with hardware changes. Many embedded \nsoftware developers have built hardware or have a strong background in hardware. This is both good and \nbad. Understanding hardware gives you an appreciation of the how hardware is built and the difficulty \nand penalties incurred for hardware mistakes. Unfortunately, this mentality colors the development of \nembedded software. Radical software changes in either process, methodology or technology were viewed \nwith suspicion and doubt. Changes were met with an unhealthy amount of skepticism. 5.2 Personal experiences \nand observations on eXtreme programming Our experience with eXtreme programming was mixed. We learned \nsome critical lessons about the environment, the tools and the people needed to use eXtreme successfully. \nEach of these factors contributed to the success and failure of this methodology for us. 5.2.1 Culture \nMost important is having a culture which encourages, promotes and supports new ideas. Since a company \ns culture is strongly influenced by the people working at the company, both managers and individual contributors, \ntheir attitudes and tolerance for change is key to successful use of new methodologies. Without this, \nintroduction and use of new methodologies is doomed from the start. Initially, our manager supported \nand encouraged the use of eXtreme in our group. It was championed by the senior members of the group \nas well as us. Management outside our group was oblivious to how we did our jobs. In hindsight, this \nwas a problem. As long as we maintained a schedule, no one cared how we did our job. At the beginning \nof every new major development, there is euphoria about how this development will play out. Since the \nend date was far into the future, we were allowed to play and experiment with our process. In the beginning \nmost team members supported eXtreme and were willing to try it. The exception to this was those members \nwho had much sooner deadlines and were not willing to experiment for fear of failing to meet the deadline. \nThis is why bug fixes to products further along the development process were not subject to eXtreme. \nThere was a real fear of missing a deadline and dealing with the consequences of that action. As the \ndevelopment progressed, it became increasingly obvious that we were not well equipped to deal with the \neXtreme process. We had no experienced eXtreme coach to guide us through the process. Although, other \ngroups had used eXtreme and did offer their advice and experience, they were barely one step ahead of \nus. Needless to say, we fell and stumbled and wandered a bit. When we were confronted with a question \nabout the eXtreme process, we would dive into our text books and have a long sometimes heated discussion \nabout the best path. As the end of the development approached, we were still struggling with the eXtreme \nprocess, particularly in allowing the time needed to do unit testing. Because we had not sought or obtained \nhigher management buy in, we could not replan and justify extensions to our schedule. The end date was \nfirm and we had to do what was necessary to meet it. As a result, unit testing was dropped by most pairs. \nThe daily meeting became schedule tracking meetings without much replanning. We felt management support \nwaned for the process. The skeptics in our group emerged and overtime became the norm. 5.2.2 Tools Tools \nare also a key element in determining success or failure, particularly the source control tool. Underlying \nthe use of the tool is a process which determines and controls how source code is built and how releases \nare generated. To be successful in eXtreme, the code building process must be quick, easy and reliable. \nCode builds need to be done daily and sometimes even more often. Each member of the development team \nmust be able to build code if necessary. In order to support small incremental code changes, code must \nbe submitted and tested daily and made available the next day for use by other developers. If you have \na person dedicated to code building, your process and tool are probably not amenable to eXtreme programming. \nEmploying someone whose job requires detailed and specific knowledge about the code build process and \nthe use of the code build tool is a red flag. Testing code as it is developed is fundamental for reliable \ncode builds and avoiding expensive code fixes later in the development cycle. Two aspects of testing \ncode became apparent as we used eXtreme. First and probably most difficult is convincing a developer \nthat unit testing before developing code is beneficial and necessary. Many developers have been trained \nto write code and then let someone else, a tester, test their code. Testing code before it is written \nis sometimes viewed as a waste of time. It has been our experience that even the simplest code can contain \nunforeseen problems, particularly when subjected to error conditions. Many developers write code with \nthe success path in mind and largely ignore error conditions, at least initially. The fact of the matter \nis that most code is written to handle errors. The other key element for unit testing is an easy, well \nunderstood test tool. There are many commercial and non-commercial test harnesses available. Since our \ngroup wanted to use and learn Java in a low risk way, we used Junit, a Java based test harness. A benefit \nof using Junit is that object technology and Java can be introduced and experimented within a project \nin a meaningful but low risk way. Many of the classes created for the unit tests can be reused in an \nobject redesign of a legacy product. The downside of a Java based tool in a predominately C and C++ environment \nis the need to use JNI to connect or glue together the Java unit tests with the C or C++ module under \ntest. With some additional rote work, a library which glues Java to C/C++ can be written to hide the \ndetails of using JNI. If your group has no interest in Java, there are at least two non-commercial alternatives \nto Junit, namely Cunit and CPP.  5.2.3 Final Thoughts EXtreme programming is a less rigorous than most \nsoftware methodologies in practice. This is both good and bad. Since it is lightweight, eXtreme is flexible \nand quick, but it is also more susceptible to abuse by undisciplined users. Although eXtreme does have \nchecks and balances, for example new code must be unit tested before it is submitted; it depends on the \nintegrity of the individual and the pair to follow the rules. Cowboy coders (and you know who you are) \nlove eXtreme because they are no longer bound by code and design reviews. It is up to the individual \npairs to police coding standards and evaluate good or bad designs. EXtreme does not work well with individuals \nwho don t play well with others. There are no checks in eXtreme to make people talk to each other, even \nthough the success or failure of this methodology depends on open communication. Our group was very conservative \nwith respect to change and new ways of doing things. The group had been successful in the past with processes \nand methodologies that eXtreme challenged. Because of this previous success, the attitude If it ain t \nbroke, don t fix it. was prevalent. Resistance to change was very strong and impeded many of the efforts \nto apply eXtreme programming practices. Some individuals and pairs needed more discipline. Unit tests \nand code diversity needed to be embraced by all, and not just a few. Although our group experienced limited \nsuccess with eXtreme based on the reasons and factors we have discussed, we believe that with an open \nattitude toward embracing change and having tools and process which do not burden rapid development, \neXtreme programming can be a productive and valuable methodology in developing software for embedded \napplications.    eXtreme Embedded A Report From The Front Line Gary Mueller Janet Borzuchowski \n10/24/02 Oopsla 2002 1  Project Successful Legacy Firmware Product  C/C++  Experienced C Programmers \n Waterfall Model  Parallel Development  10/24/02 Oopsla 2002 2  Unit Tests Unit testing not required \nand not a priority  Broken tests were not fixed  No assurance that new code worked!  Changing mind \nset to do unit tests has been difficult  Check and balance of unit tests lost, nothing to prevent refactoring \nwars  10/24/02 Oopsla 2002 3  Pair Programming Product knowledge spread across group by pairing experienced \nwith inexperienced members  All pairs were not created equal  Diverse work schedules can make pair \nprogramming difficult  10/24/02 Oopsla 2002 4  Code Standards Point of contention  Changing spaces \nto tabs and moving brackets caused unnecessary merge conflicts  Simplify code standards  Use the coding \nstyle of the module or pick an existing style  Embrace code diversity!  10/24/02 Oopsla 2002 5  Metaphors \n eXtreme programming practice  Enhance communication among team members  Example  Cooking soup is \na metaphor for building code 10/24/02 Oopsla 2002 6  Prior Code Build Process  10/24/02 Oopsla 2002 \n7  eXtreme Code Build Process 10/24/02 Oopsla 2002 9   Code Turnaround Parallel development  Build \nprocess and tool did not facilitate rapid integration and base lining of code  New code not available \nuntil new primary code base was created  Code not returned in a timely manner  Strive to do incremental \ncode changes but we didn t succeed  10/24/02 Oopsla 2002 11  Scheduling Easy to lose sight of the \noverall schedule  Incremental schedule changes not always reflectedin the overall schedule  Difficult \nto get people to break tasks into smallunits and continually update their schedule  No time allotted \nfor unit testing  Master schedule was not flexible  No support from upper management  No replanning \n  10/24/02 Oopsla 2002 12  Customer No end customer to prioritize and clarify requirements  Program \nmanagement group responsibility  Indirect interaction with end customers   Worked closely with hardware \ngroups to define interfaces  10/24/02 Oopsla 2002 13  Reflections Embedded versus Non -Embedded code \nreliability, code delivery, and code availability  Culture which embraces changes  No experienced \neXtreme coach  No support from upper management  10/24/02 Oopsla 2002 14  Reflections More testing \n Unit and integration testing  Automate the testing   Unit testing is fundamental!!!  Convince developers \ntesting is beneficial and necessary  Unit tests provide confidence that refactored code will work  \n 10/24/02 Oopsla 2002 15  Reflections Better Tools SCM and test tool, flexible, easy to use  Simulator \nto test difficult hardware states  Resistance to change  If it ain t broke, don t fix it! 10/24/02 \nOopsla 2002 16  Contact Information Gary Mueller garymueller@qwest.net 303-465-4279 Janet Borzuchowski \njanet_borzuchowsk@stortek.com 303-673-8297 10/24/02 Oopsla 2002 17 \n\t\t\t", "proc_id": "604251", "abstract": "Many embedded development environments are stuck somewhere in the backwash of software technology. Structured programming practices, with the artifacts of those methodologies liberally scattered about, are the norm in these environments. The world has changed since structured methodologies first emerged, with shorter and shorter market windows and increasingly sophisticated customers demanding more and more capabilities at lower and lower cost. Embedded system development must also adapt to these market imperatives to stay competitive. This paper describes the challenges, obstacles, and successes encountered in applying eXtreme Programming on an embedded legacy product with a team of seasoned, veteran C programmers.", "authors": [{"name": "Gary Mueller", "author_profile_id": "81100259894", "affiliation": "Broomfield, Colorado", "person_id": "PP14098752", "email_address": "", "orcid_id": ""}, {"name": "Janet Borzuchowski", "author_profile_id": "81100494743", "affiliation": "Storage Technology Corporation, Louisville, Colorado", "person_id": "P414278", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604251.604257", "year": "2002", "article_id": "604257", "conference": "OOPSLA", "title": "Extreme embedded a report from the front line", "url": "http://dl.acm.org/citation.cfm?id=604257"}