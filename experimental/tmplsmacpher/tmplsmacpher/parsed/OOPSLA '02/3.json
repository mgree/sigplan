{"article_publication_date": "11-04-2002", "fulltext": "\n Agile Techniques to Avoid Firefighting at a Start-Up Joseph A. Blotner Quality Assurance Manager, Sabrix, \nInc. 5665 SW Meadows Rd, Ste 350 Lake Oswego, OR 97035 (503) 924-4857 joe.blotner@sabrix.com ABSTRACT \nThis paper documents the creation and evolution of the (modified) agile methodology implemented at Sabrix, \nInc., a start-up enterprise-class software company. The company was delivering alpha quality software \nto early adopter customers on a weekly basis, using urgency as the primary driver for product development. \nNew features and bug fixes were completed in a manner similar to a soccer game between two teams of five-year-olds, \nwith everyone on the team chasing down the latest emergency. This paper discusses the agile software \ndevelopment discipline that enabled Sabrix to evolve from that chaotic environment to the point where \nthe company was balancing both urgency and importance to drive product direction. This discipline enabled \nthe company to actually deliver a Release , and move forward into a new product architecture. Keywords \nSDLC, Development Process, Agile Methodology, Start-Up Company 1 INTRODUCTION At the start of this new \ndevelopment discipline implementation, Sabrix, Inc., was a start-up software company, producing Tax Transaction \nsoftware. As such, we had the need to move quickly as we continued to define and re-define the product \nbased on input from industry experts, our own sales team, and early adopter customers/evaluators. Our \ndaily conversations with these individuals generated a continuous flow of new product requirements. In \naddition, since tax is a mission-critical component of our customers businesses, we have the additional \nrequirement of being unquestionably accurate. As of April, 2001, early adopters were evaluating the product \non a demo server owned and operated by Sabrix. Once per week, new features and bug fixes were shoe-horned \ninto the product and migrated to the demo server. In the spirit of a start-up company, communication \nmoved very fast, and knowledge was shared verbally. Requests came in from the sales team, for example, \ndirectly to the programmers, who would implement or not, based on internal Engineering discussions. The \nCTO (and co-founder), who was the original programmer when the company was in its infancy, was also bringing \na constant stream of requests to the engineers. Unfortunately, since the best way to implement changes \nis not always perceived as the fastest way, we were forced to make choices that were not optimal design \ndecisions and, consequently, put quality and future robustness at risk. In addition, the constant influx \nof requirements tended to distract the team members, and dilute their focus. New features and bug fixes \nwere completed in a manner similar to a soccer game between two teams of five-year-olds, with everyone \non the team chasing down the latest emergency. Such a situation is common to start-up companies, and \nmany collapse due to the weight of business pressures and the lack of supporting process infrastructure. \nBefore April, 2001, there was no formal software development process was in place at Sabrix. The company \nwas (and still is) composed of hard\u00adworking, talented, driven individuals who wanted nothing more than \nto generate the highest-quality, most feature-rich product that solves our customers tax compliance problems. \nWe were, at that time, getting product updates onto the demo server (and, thus, into the hands of early \nadopter customers) by sheer force of will, long hours and the aforementioned people attributes. Meanwhile, \nthe Business side of the company needed features in the product in order to close sales also incredibly \nimportant to a fledgling company. So, we had the continuing business requirement to keep moving at a \nvery fast pace and impress our Copyright is held by the author/owner(s). customers by exceeding their \nexpectations for feature set and quality, while reducing the stress of every individual in the company. \nReconciling these two imperatives should be easy right? Of course not. If it was easy, anyone could do \nit. It s difficult, so very few organizations can do it. Sabrix is one of those organizations. The solution \nwe developed was a new software development discipline. Note that we created a discipline , rather than \na process . Our company did not need a set of steps to follow; it needed principles on the basis of which \nwe could be guided in making decisions on everyday issues. The discipline combines classic software project \nmanagement techniques and the latest agile methodologies in discussion in the industry. It also has brought \nthe Business and Engineering facets of the company into harmony. The remainder of this paper describes \nhow we did it, and what we learned along the way. 2 The Solution The two keys to the solution we developed \nwere: The discipline is company-wide. The solution we implemented is not only useful for Engineering, \nbut for the Business side of the company, as well. When discussing development methodologies, the term \nEngineering Process is usually used. If one shifts focus and replaces the term Engineering with Product \n, the scope becomes larger and more accurate, and the probability for success becomes much better.  \nEvolution over revolution. Our development discipline is an evolution from the existing state of development. \nWholesale paradigm change simply does not work (think about it would it work for you?). People get lost, \nfrustrated and productivity goes way down, which a start-up company can ill-afford. Small changes, implemented \nover time, with a specific end result in mind, are the best way to go.  In designing and implementing \nour new development discipline at Sabrix, we kept to a single theme all the processes and procedures \nwe put in place had to significantly contribute to answering a single question: \"How does a feature get \ninto the product? . The answers we found to that question not only helped Engineers determine what to \nwork on, but also give Business an understanding of how their needs will be met. Note: References to \nEngineering imply Development, QA and Project Management; references to Business imply Sales, Marketing, \nClient Services and Product Management. 2.1 The List The heart of the entire Sabrix Software Development \nDiscipline is the centralization of a product to-do list, so to speak. We call this list (creatively) \nThe List . The List is owned by the Project Manager (i.e., she is the only one who writes to it; everyone \ncan read it). It includes all major things to be done to the product, including new features, design \nrefactoring and postponed bugs, and is in priority order. Priorities are set by Business, with the help \nof the Project Manager. Other individuals submit items to The List as product feature or bug fix requests. \nThe Project Manager reviews new requests as they are submitted, and places them in The List in priority \norder. This part of the process is done continuously, irrespective of development iterations. Strategically, \nThe List provides two important benefits: Engineering folks know they are always working on the most \nimportant tasks for the product, and  Business folks know that their requests are not falling into a \nblack hole, and where their requests fall in the overall priority list.  Each item in the list contains \na time estimate, provided by the developer, so items can be compared in a weighted fashion and the Project \nManager can make better decisions on prioritization, resource allocation and scheduling. Each item also \ncontains a priority setting, which is a string in the format of N.n. The first step was to give all issues \na gross priority; values ranged from 1 to 4. After that step, the issues in each bucket were ranked against \neach other for relative priority, so one would have 1.1, 1.2, etc. To minimize massive renumbering and \nto keep this process manageable, we allowed any number of decimal places, so 1.15 would be prioritized \nbetween 1.1 and 1.2. For maintaining The List, we used our software defect tracking tool. The specific \ntool we chose was not as important as the ease in which issues could be added, viewed, prioritized and \nexecuted. 2.2 Short, Phased Iterations Prior to implementing the new development discipline, iterations \nwere VERY short one week between releases to the live demo server. And, all code that was checked in \nto source control was released. From my experience in an Extreme Programming environment at a previous \ncompany, I appreciated the short iterations; however, the other supporting activities were not in place \nto ensure quality (unit testing, for example). We were conceiving, designing and implementing large, \ncomplex, data-driven user interface screens and tax processing features in one week, making modifications \nas necessary in subsequent releases (i.e., in the weeks following). Essentially, we were using an iterative \nprocess methodology, releasing a prototype to the live server and making improvements in subsequent releases. \nWhat was clear to me right away was that this team could move fast from conception to design, and the \ndevelopers could code up designs relatively quickly. Also very apparent was the amount of rework required \nto modify the product once it was released. Much time and energy was wasted strategizing how we could \nminimize user impact when needing to change an existing feature so it worked correctly the time spent \non such discussions would clearly be better spent designing the next feature or fixing the next bug. \nIn addition, the quality of the product was unacceptable. With such a short iterations, there was no \nopportunity for sufficiently testing features or bug fixes prior to release, as each one usually took \nthe full week. Therefore, the one-week iterations consisted of just under one week of pure design and \ndevelopment, a couple hours of testing and about 3 hours of migration to the live server (see Automated \nBuild and Installer , below for more details on this astounding process), followed by about a day of \nchecking out the live server and fixing the problems that were out there. With such minimal testing in \nplace, the quality of the software was mediocre at best, and would have been much worse were it not for \nthe talent of the developers. We knew that if we intended to eventually release a product, weekly releases \nwould not be feasible. Customers would certainly not accept weekly product updates, particularly for \nenterprise scale applications. However, we were not at that point yet, and still had to show our early \nadopters that we were responsive to their requests and feedback. On top of all these issues, product \ndevelopment was emergency-driven and, literally, unmanageable. An engineer half-finished with a task \nthat was classified as absolute top priority last week getting pulled onto a new task that was absolute \ntop priority this week was a common occurrence. The desire to always work on what was most important \nto the company compelled the engineers to drop last week s priority and work on the latest must have \n. Now, since the work was not planned, there was no way to track it against plan, and many new features \nlay crippled on the side of the road of new development, half-complete and untested. Untested, that is, \nuntil a sales engineer attempted to demo the feature and found software defects while in front of a customer. \nSo, the evolution we embarked upon was to first lengthen the individual iterations to a block of time \nin which it would be reasonable to accomplish something well, but still appear responsive to our early \nadopters. After that pattern was established, we structured the iterations by adding phases to them, \nessentially making each one a mini-waterfall cycle. 2.2.1 Lengthened Iterations The change we made for \nthe first stage was to stretch our iterations from one to two weeks. To help us keep track of workload \nand build a product road map, each iteration was named after the date on which it began. We used these \ncycle names/dates as a scheduling mechanism, allowing us to schedule work several iterations in advance \nwithout the need for an external project plan that would have needed to be in sync with the bug database. \nThis scheme also helped management track the mount of work actually accomplished in each iteration. The \nchoice of using dates as the naming scheme was simply a matter of not wanting to come up with a new name \nevery two weeks! Later, when we embarked on our new re\u00adarchitecture project, we decided to use colors \nas our iteration naming scheme, which everyone seems to like better. 2.2.2 Each Iteration is a Waterfall \nBecause we were releasing after each iteration (a paradigm we later were able to remove (see Lessons \nLearned )), each iteration needed to be treated as an entire release. However, with such a short time \nbox, we needed the tracking of work to be simple, both for management and the individual engineers. We \nchose to implement each iteration as a small waterfall. We planned the tasks, implemented them and tested \neverything prior to release. The reason we chose this paradigm is that it is the most simplistic way \nto track the development of a new feature. Everyone already understood the waterfall method, and its \nclassic downfalls are minimized to infinitesimal proportions due to the short time frame. Here s how \nit worked: 1. Planning: 1-2 days (prior to start of iteration) 2. Implementation: 7 days 3. Acceptance: \n2 days 4. Migration / Release: 1 day  When first proposed, there was push-back on this restructuring. \nOn the surface, it appears that we are losing development time. After all, across a two\u00adweek period in \nthe old paradigm, there were over nine days of development time, whereas the new plan proposes seven \ndays. However, if one considers how much time was burned during migration and post\u00adrelease re-work, the \nnew discipline actually provides more time for new development. Benefit Description Time Difference across \none new cycle vs. two old cycles Fewer days dedicated to new development each cycle - 3 days Time saved \non migration problems + 1.5 days Time saved on re-work + 2-3 days Total +.5-1.5 days Of course, this \ntype of formula does not even take into account the time lost in re-designing or fixing a feature that \nwas initially developed in haste. 2.2.3 The Planning Phase Before a development cycle starts, the Project \nManager (with Business input) uses the time estimates and priorities in The List to determine the items \nthat will be implemented in the next cycle. The Project Manager brings that list to an iteration planning \nmeeting (no more than 30 min) as early as possible in the cycle (e.g., if the cycle begins on Monday, \nthen 9:00 Monday morning is a good time). In this meeting, Development and QA owners of the various items \nare confirmed. It is important to note that, even when this planning is done for a given iteration, it \nis not set in stone. Items can be removed, added or modified on the fly. For example, if a new, high \npriority requirement needs to be implemented before the end of the current development cycle, it is inserted \ninto development cycle, bumping tasks of equal time estimation out of the cycle. Also, if an engineer \nis done with his/her assigned tasks for a cycle (tasks were overestimated), he/she asks for more from \nthe Project Manager, who works out how best to shift the workload. Similarly, if a given task was underestimated, \nthat fact is brought to the attention of the Project Manager and work is re-shuffled accordingly. 2.2.4 \nImplementation Phase Once the task lists are confirmed, the implementation work begins. Each task is \ntaken individually, and run through to completion, including unit and functional testing of the item. \nFor developers, the tasks are writing and unit testing the code and data. For QA engineers, the tasks \nare developing testcases, writing automated tools as necessary, and executing testcases. Software defects \nfound while the code and data are being built may or may not go into the bug tracking system; individuals \nuse their best judgment. The key here is rapid feedback on quality and minimizing process overhead if \na bug is found in a feature that is part of the current cycle s task list, then reporting the defect \nmay be as simple as an email, or walking over to the developer and showing him/her; if the issue is. \nIf a more complex issue arises, or a found defect will not be resolved in the current iteration, the \nissue is submitted to The List for implementation in a future iteration. Once the code and data for the \nitem is considered acceptance-ready (all functionality written; now in find-and-fix mode), QA executes \nthe first formal run of its tests for the item. Some module-interaction type tests are run here, but \nthe majority of those types of tests are run once the cycle moves into the acceptance phase. Defects \nfound at this point always go into the defect tracking system. A given task is not considered complete \nuntil the tests for it pass. 2.2.5 Acceptance Phase Upon completion of the Implementation Phase of a \ngiven iteration, all new development stops and the developers become testers (and, of course, QA continues \ntesting). Ideally, no developer tests his/her own work, but that ideal is not always achievable. The \ntesting assignments are distributed judiciously and evenly by the Project Manager, with input from the \nQA Manager. In some cases, we had the individuals select their own testing assignments, which met with \nlimited success. Cross-module (a.k.a., integration and system) testing is done in this phase, and a full \nregression test pass is attempted. All defects found at this point are reported in the bug tracking system, \nscrubbed by the Project Manager with input from Engineering and Business, and fixed during the Acceptance \nphase if necessary. When all tests are run on the QA instance and the pass/fail rate is deemed acceptable \nby the Project Manager, the code and data are migrated to the Staging instance, where QA runs the final \ninternal acceptance tests (a subset of the tests run on the QA instance). The source is then labeled \na release candidate in source control. See Development / Test Instance Infrastructure for more details \non the notion of instances . 2.2.6 Release Phase When all tests pass on the Staging instance, the code \nis migrated to the live server, where QA runs its final acceptance tests. Either the same, or a subset \nof the Staging acceptance tests. New defects found during this testing are escalated immediately to the \nProject Manager, who decides if a quick-fix is necessary. If so, a mini-iteration is performed, with \nfixes being done on the development instance, tested on the QA instance, staged and released live. When \nall tests pass on the live server, a version number is assigned, the code and data are labeled as released \nin source control with the version number included. A CD is burned and an announcement is emailed to \nthe company.  2.3 Handling Larger Tasks Of course, there are some features or other tasks that require \nmore than two weeks to design, implement and qualify. In such cases, we simply sketch up a plan for the \nfeature, breaking the work into two-week (or smaller) chunks. We then add one issue per chunk of work \nto the bug database, so we do not lose track of the steps we needed to follow.  3 Additional Keys to \nSuccess A development discipline alone cannot assure success. Even the most process-loving engineers \n(all three of them) will not be able to succeed with only a series of steps to follow. Other factors \nmust be in place to aid them in that success. All of these factors have one common purpose removing \nuncertainty and distractions from the engineers as they do their daily work. 3.1 Unit Tests One of the \nbiggest question marks in our product was the quality of the software. Because we had insufficient time \nto test between development and deployment, and because we had no QA team, the only report I could give \nto the executive team regarding the quality of the software was that we did not know the quality of the \nsoftware. After all, how could we? The best answer was to build a QA team, which we began. However, a \nQA team takes time to build and ramp-up, and we needed to improve quality right away. We decided to have \nthe developers take the time to develop and run unit tests before considering a task complete. Developers \ninclude unit test development into their time estimates for tasks in The List. At the time this development \ndiscipline was enacted, almost the entire TaxBay product was implemented in the PL/SQL language stored \nprocedures that lived inside the database. Developing automated unit tests was impractical at the time, \nso unit tests were manual. Therefore, there was no good way of externally monitoring that unit tests \nwere being built. Given the dedication level of our team, we chose to use the honor system, and made \nimprovements only when necessary, using a failure-driven coaching paradigm. Developers are not mercilessly \nnagged about their unit tests, nor is documentation of these tests required. Instead, if software defects \nare found that should have been caught by unit tests, the developer(s) were required to explain the unit \ntesting methodology used, as well as the tests executed. As we began to migrate more of our code to Java, \nautomated unit tests, via JUnit, were mandated. We also mandated that all tests must pass before code \ncould be checked-in. Most agile methodologies advocate automated unit tests, so there is no need to encore \nthose assertions here. 3.2 Strategic Pair Programming Pair programming is espoused by several agile \nmethodologies to varying degrees. We chose not to do full-time pair programming, but rather to insert \nthis practice at strategic points in the product development cycle. Pair programming is used for: All \ncode changes after the Candidate Build.  Complex portions of the application.  Design of new features. \n Major refactoring tasks.  Except for the first of these situations, for which it is mandated, pair \nprogramming is voluntary on the part of the developer who owns the task. Given these parameters, the \none rule put in place was that each person must respond to a request for pairing. The presumption should \nbe made that a colleague cannot continue with his/her work until the pairing task is done; therefore, \nthe longer you delay, the longer your teammate is at a roadblock. The team, which was resistant to the \nidea of pair programming at first, accepted this plan on a trial basis. At first, pair programming sessions \nwere instigated at the recommendation of the Engineering Manager; but, it has worked so well that pair \nprogramming is a fairly common occurrence, and such prodding from Management is very rare. 3.3 Buffer \nbetween Engineers and Business As stated above, product development was emergency-driven. A given engineer \ncould be working on a hot new feature, fixing three critical bugs, helping Client Services with an implementation \nerror and answering questions about product behavior from the sales force. We needed a way to help filter \nthe demands on Engineering. If an Engineer is asked a question or told of a problem, they immediately \nwant to help out or fix the problem. This eagerness is a terrific quality in an Engineer, and one we \ndid not want to squash, but it can lead them down an unnecessary path and hurt overall product development \nprogress unnecessarily. The List was a huge step in mitigating demands. Since both engineering and non-engineering \nindividuals could submit their requests to The List, knew that The List was being managed by priority \nand received feedback when a request was implemented, the direct requests for features and bug fixes \nslowed somewhat. To further maximize productivity in Engineering, we had all external requests for information \nout of Engineering run through one Engineering representative, who happened to be me, in my new role \nas Engineering Manager. If I needed to bring Engineers into the mix, I did so. This supporting feature \nof the development process was absolutely essential. By filtering the requests into Engineering, priorities \ncould be set before an Engineer needed to get involved, and we avoided the problem of several engineers \nworking the same problem simultaneously. Equally as important as creating this filter is the flexibility \nof it. As in our software design, we had to make sure we did not establish a single point of failure. \nBack-up people were established so issues could still be handled efficiently if the Engineering Manager \nwas unavailable. This filtering of requests into Engineering was quite difficult to get into place. So, \nI sought out the biggest offender and get him on board before putting the policy in place. Fortunately, \nhe already knew that we had to make this change, so the sell was easy. Once I had him on board, I could \nuse him as a reference point for others ( Even Eric is adhering to this policy; if he can do it, so can \nyou. ). Repeated reinforcement and support from the executive team was crucial to success.  4 Evolution \nof the Discipline / Lessons Learned The key to any process working for the long term is that it evolves \nas the organization evolves. The Sabrix Development Discipline as described in Section 3 was our starting \npoint. It worked very well for a few months, which was long enough for us to give ourselves the requisite \nstructure to take a breath and look at how we wanted to improve. 4.1 Evolution of the List The first \narea for improvement was The List. We quickly realized that the Project Manager was not the person who \nshould own it --there were too many low-level issues, and our new environment had her less involved in \nthe day-to-day details of product implementation. She brought in the CTO (who was still very involved \nin the design decisions), but he too was now too removed from day-to-day activities to be able to help \nwell. Basically, they found themselves able to do nothing but manage The List and the relative priorities \nwithin it. As in any start-up company, everyone wore many hats. The Project manager was not only managing \nThe List, but was also demoing the product to customers, developing requirements, researching the domain \nspace, etc. The CTO was also involved in product demos, sales and contract negotiations, requirements \ndevelopment; plus, he was the one with the most domain space and product knowledge, so we needed to consult \nhim on design decisions. Neither of these folks had the requisite time to maintain the prioritization \nof The List. However, we all knew its value. So, as the now Engineering Manager, I took over maintenance \nof The List. I stayed in constant contact with the Project Manager and CTO so I would have a good feel \nfor company priorities for the product and, since I was already managing the daily activities, I was \nintimate with the low-level issues. This changed worked out very well. The Project Manager and CTO were \nmuch more productive in other areas, and appreciated the fact that they were still the ones setting priorities, \nbut did not have to do the grunt work. From an Engineering standpoint, it was a big plus to have someone \nwho knew what was going on in Engineering setting priorities and assigning tasks. As a side benefit, \nthis shift in ownership of The List further reinforced the crucial buffer between Engineering and the \nrest of the company. Eventually, detailed prioritization was not manageable, even by the Engineering \nManager. So, issues were grouped into four buckets bugs were classified as High, Medium or Low priority, \nand Enhancements were kept separate. Prioritization of enhancements was managed via scheduling. The most \nimportant enhancements were scheduled first. The key lesson learned with regard to The List is that human \ninterpretation is indispensable. There is no manageable way to simply have all the necessary information \nin a list of tasks without having the maintenance of that list being a person s full time job. And no \nstart-up company can afford to hire a person for that sole purpose. So, human judgment must be used, \nboth by the person maintaining The List and those using it. Having said that, I cannot stress enough \nhow important having The List was when we started, and still is as we move forward. Being able to objectively \nunderstand the impact of a given feature or bug fix on the rest of the work, using time estimates, made \npotentially emotional conversations ( It s not fair to ask us to shift gears at the last minute! ) into \ncooler, more pragmatic ones ( This task will take 5 hours. What existing five-hour task should we drop \nin order to add this one? ). Even as we move into the next generation of our product architecture, we \nstill maintain The List, estimate tasks as best we can and prioritize each one. The List has enabled \nus to continue to move forward without missing key software changes and ensuring that we are always working \non the most important items for the company. 4.2 Listen to the People Doing the Work Most agile methodologies \nespouse the notion of not forcing individuals to do things they do not want to do. While, you cannot \nallow people to ignore a process, or part of it, just because they don t feel like it, it is important \nto listen to their concerns. Let s face it; a process is simply a structure. In order to be a useful \nstructure, it must be one that allows the individuals who must work within that structure to feel freer \nand be more productive than they are without it. Before even sketching out this development discipline, \nI spoke with everyone in the Engineering organization, asking them what did and did not work well in \nthe current environment, how they liked their workload to be managed and what types of tasks they enjoyed \nmost. These conversations yielded valuable information that helped me determine where to focus the first \nchanges, and where the most change was needed. I found out (not surprisingly) that none of the engineers \nliked the fire drill atmosphere. What I did not expect was that the CTO (who generated most of the fire \ndrills) didn t like it either! So, The List became the central point around which the rest of the discipline \nwas built. I also learned that the engineers didn t particularly like testing, but were also concerned \nabout the lack of testing that gets done each week and the quality of the product they were producing. \nThey wanted to take more pride in their work, even if it meant some less palatable tasks had to be accomplished. \nSo, unit testing was added to the discipline, but the overhead was light and the enforcement failure-driven. \nAnd, I learned that it was important to almost all the engineers that they be involved in requirements \nand spec development, as well as the coding. So, we included design tasks in The List, as well as implementation \ntasks. 4.3 Addition of the QA Team At first, with no QA team in place, the developers had to be testers, \nas well, thus the need for the two\u00adday Acceptance phase in each iteration. As the QA team got up to speed, \nit became clear that our Acceptance phase could shorten, since testing was being done pretty much all \nthe time. We made the Acceptance phase one day in length, with the knowledge that significant code changes \nshould not be made in the last one to two days of each iteration. 4.4 Stick to Your Guns Most development \nprocesses or disciplines work very well when life is running smoothly, and get cast aside when deadlines \nloom large, customer pressure to perform is very high and the Board of Directors is driving the executive \nteam very hard to deliver product and sales. The development discipline we developed at Sabrix was designed \nto scale up or down, and to free the individual engineers to only do what they do best. We all (in Engineering) \nknew it was the correct discipline for us, and we saw how our productivity and quality increased. Therefore, \nwe kept using it, even under the crunchiest of crunch times. About three months into the implementation \nof this paradigm, I received pressure to add a new feature to an iteration, but not drop any existing \nwork. When I pushed back hard on adding this extra work to engineers who were already working long hours, \nreminding the requestor that we built this process for a reason, I was essentially told that with all \nthe pressure we were under at the time, it was not the time to play the process game, I explained to \nhim that now is exactly the time to rely on the processes that have served us so well. The feature was \nadded to the product in the requested iteration, and an equal amount of work was dropped from the iteration \nto accommodate. Contrastingly, after finally getting a real release out the door (see Stringing Together \nIterations to Make a Release below), and continuing to keep a tight reign on workload management through \ntwo patch releases, I decided to lighten up a bit on the engineering team as we threw ourselves into \nthe breach of re-architecting our product into an n-tier framework. Design and prototype tasks were not \nentered into the bug tracking mechanism, The List was only being maintained very loosely, and iterations \nwere not phased as before. Within one month, the status of our re-architecture product was unknown; all \nwe knew was that we felt behind schedule. By how much? We did not know, but we were pretty sure we were \nnot going to deliver a prototype of the new architecture when we hoped we would. How late were we going \nto be? We didn t know that either. We immediately reinstated the process. While we did not deliver our \nprototype on time, we knew a week in advance that we were two weeks away, so we adjusted the company \ns expectations. As of the time of this writing, the release date has slipped one week; but, more importantly, \nwe know the tasks needed to get us from here to there, who is doing them and in which iteration they \nwill be done. As stated earlier, if the process is the right one emphasis placed in the correct areas, \noverhead appropriate for the organization, etc. then it is right for your organization all the time. \n 4.5 Stringing Together Iterations to Make a Release That summer of 2001, Business realized that the \nASP model for selling the product was not the correct one for our customer base, and we shifted to a \ndeployment paradigm, which meant that we would be installing the product at customer sites. The implication \nof this change w.r.t. the development discipline was that we could not release every two weeks customers \nwould simply not accept updates that frequently. We decided that we needed to productize the software, \nand get away from the two\u00adweek release paradigm. We looked at the development discipline and realized \nthat we really did not have to change very much. We stuck with two-week iterations, but did not release \nto the live server after each one. In addition, we inserted some traditional release cycle milestones \ninto the schedule (Functional Implementation Complete, Release to Manufacturing, etc.), and those milestones \nwere set at the end of certain iterations. The iterations themselves took on new overtones, as well. \nThe two remaining iterations in August were still for new development, leading up to the FIC milestone; \nthe next two were bug-fix-only iterations, leading up to the Candidate Build (CB) milestone, and the \nfinal one was 99% testing with only showstopper bugs being fixed, as we approached RTM. The development \ndiscipline scaled just as I had hoped it would. We still maintained The List, using the new nuances of \neach iteration as additional input. We still time-boxed our iterations, though we made one of them three \nweeks long and another one week. We still negotiated changes in priorities and time estimates with Business, \ndiscussing every single bug as we moved closer to the release date. And, we still used the mini-waterfall \nstructure for each iteration.  5 Conclusion There are several development methodologies at play in the \nSabrix Development Discipline classics like the waterfall and iterative, as well as new, agile models, \nlike Extreme Programming. Our discipline is really a hybrid, using the parts of each model that fit our \nparticular organization best. Finding that right fit is not easy, and ours is still not perfect. We are \ncontinuously looking at how our discipline must evolve to handle our changing needs as an Engineering \norganization and as a company. However, we owe it to our engineers, our company and our customers to \nhave this discipline in place, and rely on its assets in easy and difficult times, not allowing ourselves \nto be fooled into thinking that we do not have the need or time for a formal development process. Finally, \nif this report on our experiences at Sabrix or the evolution of the Sabrix Software Development Discipline \nconveys no other point, it should drive home the following two messages. First, implementing a software \ndevelopment process, any process, is important to companies of all sizes and speeds; the trick is finding \nthe right type and amount of process for your organization. Secondly, whatever processes / procedures \n/ disciplines your organization puts into place should be a natural evolution of the current state of \naffairs, and must continue to evolve as the team, product and company evolve.  Setting the Stage April, \n2001  Copyright 2002. Sabrix, Inc. 2 All Rights Reserved. 1  The Solution Guiding Principles Company-Wide \nSolution to a Company Problem  Evolution, not Revolution  Copyright 2002. Sabrix, Inc. 3 All Rights \nReserved.  The Solution -Overview Document and prioritize the work to be done The List  Short (though \nnot ridiculous), scoped cycles  Time estimates  Phase the work within cycles as needed  Unit testing \nand pair programming as warranted  Copyright 2002. Sabrix, Inc. 4 All Rights Reserved. 2  The Solution \n The List The heart of the solution  List of all tasks to be performed, with estimates  Prioritization \nby Product Management  Product Management prioritized, with help from Engineering  Re-prioritization \nconstant  Negotiated scope of each cycle   Dynamic  Everyone knows how to get something into The \nList, and how The List is handled (no black hole )  Copyright 2002. Sabrix, Inc. 5 All Rights Reserved. \n The Solution Short, Phased Cycles Extended from 1 to 2 week cycles (proved productivity improvement) \n Length based on desired scope of next drop, holidays, etc.  Do not go above 3 weeks  All cycles have \ntwo phases  Implementation  Acceptance   Complex tasks are broken across multiple cycles, with deliverables \nat end of each cycle (scalable)  Copyright 2002. Sabrix, Inc. 6 All Rights Reserved. 3  Additional \nKeys Unit Testing No QA team at start  Developers write tests  Only code that was changing (bug fixes, \nnew features, refactoring, etc.) required tests.  PL/SQL  Manual  Documented in spreadsheet or attached \nnote to bug   Java  JUnit  All new code and any refactored code   Took some training / review at \nfirst (now at 126% test:class ratio)  Copyright 2002. Sabrix, Inc. 7 All Rights Reserved.  Additional \nKeys Pair Programming Strategic Use Only  Complex tasks  New feature design  Major refactoring \n All changes after CB milestone   Mostly voluntary  Request for pair is top priority  Took a while \nto be appreciated  Copyright 2002. Sabrix, Inc. 8 All Rights Reserved. 4  Additional Keys Buffering \nEngineering Set up a bottleneck (yes, a bottleneck), with back-up  Must be responsive!  Show people \nhow their issues will be addressed (The List)  Get the biggest offender on board first  Copyright 2002. \nSabrix, Inc. 9 All Rights Reserved.  Evolution of the Discipline Streamlining The List  Product Management \ntoo busy; ownership moved to Engineering Manager (a.k.a., the Bottleneck)  Engineering Manager keeps \nconstant contact w/ Product Management  Changed from detailed to gross prioritization   Built QA Team \n Yes, you still need QA!!!!!  Listen to The Team  Stick to your guns (internally and externally)  \nCopyright 2002. Sabrix, Inc. 10 All Rights Reserved. 5  It Scales! String cycles together to make \ntrue releases  Core of discipline does not change, even as process does  Attached project-based milestones \nto cycle end-dates Adjust focus for cycles based on current milestone  Able to handle issues from existing \ncustomers in stride with long-term project  Copyright 2002. Sabrix, Inc. 11 All Rights Reserved.  Update \n Still a Start-Up  Still responding quickly to customers  Still producing on time, every time  Zero* \nEngineering turnover in last 15 months  Team relies on the discipline  Copyright 2002. Sabrix, Inc. \n12 All Rights Reserved. 6  Questions ? - Copyright 2002. Sabrix, Inc. 13 All Rights Reserved. 7 \n \n\t\t\t", "proc_id": "604251", "abstract": "This paper documents the creation and evolution of the (modified) agile methodology implemented at Sabrix, Inc., a start-up enterprise-class software company. The company was delivering alpha quality software to early adopter customers on a weekly basis, using urgency as the primary driver for product development. New features and bug fixes were completed in a manner similar to a soccer game between two teams of five-year-olds, with everyone on the team chasing down the latest emergency. This paper discusses the agile software development discipline that enabled Sabrix to evolve from that chaotic environment to the point where the company was balancing both urgency and importance to drive product direction. This discipline enabled the company to actually deliver a \"Release\", and move forward into a new product architecture.", "authors": [{"name": "Joseph A. Blotner", "author_profile_id": "81100342813", "affiliation": "Sabrix, Inc., Lake Oswego, OR", "person_id": "P414280", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604251.604253", "year": "2002", "article_id": "604253", "conference": "OOPSLA", "title": "Agile techniques to avoid firefighting at a start-up", "url": "http://dl.acm.org/citation.cfm?id=604253"}