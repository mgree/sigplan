{"article_publication_date": "11-04-2002", "fulltext": "\n Hitting the Target: Adding Interaction Design to Agile Software Development Jeff Patton Development \nTeam Leader Tomax Technologies 224 South 200 West Salt Lake City, UT 84101 USA 1.801.924.6924 jpatton@tomax.com \ndeliver high quality software sooner, and interaction design  ABSTRACT concepts lent us the degree of \nend-user empathy we were Extreme Programming appears to be a solution for discovering missing to help \nincrease confidence that we hit our target of end\u00adand meeting requirements faster (through close customer \nuser satisfaction. All this results in our team being morecollaboration) as well as creating quality \nsoftware. In practice successful today than 2 years earlier. we found XP did deliver high quality software \nquickly, but the resulting product still failed to delight the customer. Although the finished product \nshould have been an exact fit, the actual end-user still ended up slogging through the system to 2. IDENTIFYING \nTHE PROBLEM accomplish necessary day-to-day work. This paper describes 2.1 There Has to Be Better Way. \nusing interaction design in an agile development process to I ve spent years developing software traditionally. \n Basically,resolve this issue. Using interaction design as a day-to-day this consisted of a blend of \nWaterfall Methodology andpractice throughout an iterative development process helps our complete chaos. \nI saw intelligent folks work very hard toteam at Tomax Technologies deliver high quality software, identify \nrequirements, create a thorough definition of scope andwhile feeling confident the resulting software \nwill more likely functional design, approve that, and then finally build it. Moremeet end-user expectations. \nThe method of Interaction Design often than not the resulting software would miss its target. Itfollowed \nhere is based on Constantine and Lockwood s Usage\u00adwas often late. There were problems with quality the \nsoftware Centered Design. Recommendations are provided on how to released with bugs. But even with quality \nissues resolved, thepractice an agile form of U-CD and how to incorporate bits of resulting software \nwas hard to understand and cumbersome to Interaction Design thinking into every day development and use. \nIt didn t seem to be appropriate for the actual work the end\u00adproduct planning decisions. users were \ntrying to accomplish. Requirements were often missed in the design phase, resulting in features necessary \nto automate the business process being left out of the software. Keywords Features originally thought \nimportant during the design phase Agile Methodologies, Interaction Design, Usage-Centered were often \ndiscovered to be unnecessary and went un-used. Design, Extreme Programming, Requirements Gathering. Watching \nthis cycle over and over left coworkers and customers paralyzed with fear. We analyzed and designed longer \nwith the hope we d get it right the next time. Customers reviewed 1. INTRODUCTION designs longer or \ndelayed reviewing them out of fear they dThis experience report discusses my discovery and incorporation \nmiss something and be blamed for inevitable omissions in theof Constantine &#38; Lockwood s Usage-Centered \nDesign [6] into delivered product. We started developing late. We finishedthe day to day work my team \ndoes to deliver high quality even later. software. There had to be a better way. Summarizing observations \nof several projects in Reflective Systems Development [13], Mathaissen observed Systems development methods \nwere seldom, or only partially, followed  3. FINDING THE SOLUTION by experienced practitioners. We \nwere no exception. Our current form of U-CD uses new skills taught by Larry 3.1 Enter Extreme Programming \nConstantine &#38; Lucy Lockwood. In addition we ve made several Extreme Programming [3] surfaced as an \nalternative to this modifications to the process to accommodate time limitations, madness along with \nother new ways of developing software information limitations, and an iterative development now branded \nas Agile [1]. Surely close customer collaboration environment. The result is a situation specific agile \nform of and iterative development would correct customer satisfaction U-CD that fits tightly into our \nteam s local methodology. issues. Surely test-driven programming [16], pair programming, and aggressive \nrefactoring [11] would improve software quality. When incorporated into an agile development process, \nthe interaction design concepts in Usage-Centered Design pack a I stumbled into and spent a valuable \nyear with Evant Solutions, a powerful 1-2 punch: Agile development methods allowed us to company committed \nto XP principles. We built high quality Copyright is held by the author/owner(s). software at an aggressive \nrate. Deliveries were on time and with the expected scope usually intact. However, I still found the \ncompany missing targets. The resulting product seemed to have features the actual end user didn t need \nor care about while lacking features the end user did need. Much time seemed to be spent on features \nthat would go un-used by actual end users. These same actual end users had to devise lengthy procedures \nto force their actual business processes to work with the software that was built. Shouldn t close customer \ncollaboration have mitigated this issue? Ideally an XP customer is an expert end-user employed by the \ncompany actually purchasing the software. In Evant s case they were indeed expert users at one time, \nbut now as product managers working for Evant, they had the responsibility to deliver commercially viable \nsoftware to be competitive with other products in the same marketplace. They had to balance the needs \nof users we currently had with users we hoped to acquire. This was a daunting responsibility requiring \ntough trade-offs. At delivery time, it wasn t always clear where those tradeoffs had been made. Product \nmanagers seemed to be surprised that actual end-user needs had not been met. We moved into a reactive \nmode delivering software that we hoped would address end-user needs, then waiting for the inevitable \nrequests to make changes. An element of empathy with the actual end-users seemed to be missing. We were \nguessing what they needed. Was this just an unavoidable challenge of software development? 3.2 Beauty \nIs Only Skin Deep. At Evant we d always worked hard to make our software look good and be easy to use. \nOur UI specialist did a fabulous job with screen design and the product was consistent and easy to understand. \nHowever we still had the issue with actual business processes being hard to accomplish in the software \nand important parts of business processes being left out completely. Sure it looked good, but apparently \nthere was more to hitting the target than looks. 3.3 We re All Crazy. Years ago I d read Alan Cooper \ns About Face [9]. It contained lots of good information on what not to do when designing the software \ns user interface. But our software seemed to have a good user interface at least it didn t break any \nof the major rules. During the spring of 2001 I was able to hear Cooper speak in Berkeley. His focus \nwas less on bad screen designs and more on software missing its target as a result of not understanding \nits user. He pointed out the necessity of a persona. A persona was a walking, talking, fictitious user \nwith well-developed fictitious needs and concerns. Reading Cooper s The Inmates are Running the Asylum \n[10], I found that as a technologist, I d likely never be able to identify with my user. I, and the folks \nI worked with were the inmates and it would take serious effort to think like the persona we could create. \nKnowing you have a problem is half the battle. I proceeded under the assumption I could find the steps \nto recovery. In an attempt to move forward, I latched onto what looked like a valuable starting point. \nAlan Cooper used the term interaction design to describe the missing role in software development, and \nfurther said \"Almost all interaction design refers to the selection of behavior, function and information \nand their presentation to users.\" [10] Looking back at challenges I d experienced before it seemed that \nwe did a poor job of selecting the appropriate behavior and functions to implement in the software. \n 4. FINDING THE SOLUTION, AGAIN 4.1 It s not Chet s Fault. While lurking in the ExtremeProgramming discussion \ngroup [18], I read Ron Jeffries recommendation of Constantine &#38; Lockwood s Software For Use [6] as \na possible source for good information on user interface design. Although Extreme Programming Installed \n[12] may encourage blaming Chet I ll assign Mr. Jeffries the responsibility for starting me down this \npath. Like Cooper s concerns, Constantine and Lockwood s justifications for effective user interface \ndesign and usability were preaching to the choir. But something different in this book was an actual \ndocumented method for arriving at a usable piece of software including choosing appropriate behavior \nand functions for the people identified as users of the software. However, the process described looked \ncomplicated, time consuming, and not easily adapted to an agile development approach. What s more it \nneeded to happen up front. Adding a time consuming process to the front end of software development sounded \ntoo much like the bad experience I had been running from. 4.2 Ah-Ha! During the summer of 2001, I had \nthe opportunity to learn Usage-Centered Design from Larry &#38; Lucy directly. The book is thick and \nI d wondered how we were going to compress this process into a weeklong class. As exercises between lectures \nwe discussed a business problem, brainstormed ideas onto 3 x 5 cards and saw models emerge almost magically \nby shuffling cards around the table. We did this collaboratively in a group with lots of discussion. \nWe learned an effective way to move from these arranged models of cards on the table to wireframe user \ninterface. We learned how to validate or test our user interface using the information we d put together \nstill on those 3 x 5 cards. The business problem we took on to solve in exercises seemed daunting at \nfirst. But surprisingly, in a short amount of time we arrived at an effective design. And what s more, \nthe whole process was understandable and fun. If this was Usage-Centered Design in practice, I could \neasily see it used as a collaborative approach to generating story cards for use in Extreme Programming \ndevelopment. This would surely result in us delivering software that was high quality and effective at \nmeeting the real business needs of the user. Simultaneously I stumbled onto an assertion on page 122 \nof Cockburn's Agile Software Development [5] that when we look at the scope of concern for Usage-Centered \nDesign and XP that the two sets of practices could indeed inhabit the same project. If past problems \nsprung from sometimes selecting and building the wrong behavior, possibly using U-CD as a method for \ninteraction design would result in selecting correct behavior more often. With XP we could now accurately \nplan, develop, and release a set of features. We could hit the target of on-time delivery and high quality. \nWith more method behind choosing the features to implement, we now hopefully had a target that more likely \nincluded end-user satisfaction.  5. DEFINING THE SOLUTION 5.1 Agile Usage Centered Design Although Usage-Centered \nDesign is thoroughly explained in Software for Use [6], an Agile approach is first documented in Larry \nConstantine s paper: Process Agility and Software Usability: Toward Lightweight Usage-Centered Design \n[8]. The steps given here are an abbreviated overview of the process. This is Constantine and Lockwood \ns process with a few minor variations to match the way my team and I practice it today. 1. Identify participants. \nSequester a diverse mix of people in a room to collaborate on this design. Include domain experts, business \npeople, programmers and test/QA staff. Include a facilitator that knows this process. Figure 1. Collaborative \ndesign sessions include a diverse mix of people. 2. Preconception purge. Let loose. Everyone brain-dump \nabout the software we need to write. Complain about the product you re replacing. Explain the cool features \nyou expect the new product to have. Get everyone s concerns out into the open. Write these concerns down \nin plain sight on whiteboards or poster sized paper hung on the wall. 3. Review the domain. Domain \nexperts and users in the room explain the business process, as it exists today. Who is involved in the \nprocess? What combination of manual processes and computer based tools do current participants engage \nin to meet their goals? 4. Define user roles and role model.  Brainstorm user roles onto 3 x 5 cards. \nWho will be using this software? What are their goals? Prioritize the roles by shuffling the stack of \ncards. Note the most important roles. Label those roles focal roles. Place them in an arrangement on \nthe table that makes sense with similar roles closer to each other. Discuss the relationships these roles \nhave with each other. This is a role model. Figure 2. Fixing role cards to poster paper and annotating \nrelationships allows the role model to be posted for everyday reference. 5. Define tasks and task model. \n Now that we know who will use our software, brainstorm tasks these roles will be doing to accomplish \ntheir goals onto 3 x 5 cards. Shuffle the cards to prioritize them based on importance, then on frequency. \nNote the most important and most frequent. Label those tasks focal tasks. Arrange the cards on the table. \nPlace tasks similar to each other, or dependent on each other, together. Place tasks that have nothing \nto do with each other further apart. Discuss the relationships these tasks have with each other. This \nis a task model. 6. Define interaction contexts. You ll find tasks in the arrangement on the table \nclump up. Grab a clump. This is an interaction context. Give the interaction context an appropriate name. \n 7. Detail user tasks. For each task in your interaction context, write a Task Case directly on the \ncard. The Task Case takes the form of a conversational Use Case similar to that described by Rebecca \nWirfs -Brock in [17]. Alistair Cockburn in Writing Effective Use Cases [4] might classify them as system \nscope, sea -level goal, intention-based, single scenario, Wirfs-Brock use case conversation style. U-CD \nwould encourage you to simplify and generalize these Task Cases. Using a conversational form makes them \neasy to read. Limiting the scope and goal keeps them from being too broad or too detailed. Generalizing \nthem keeps them short and allows deferring user interface details for implementation time. 8. Create \nan Abstract Prototype.  For each interaction context, using the task cases you ve detailed create an \nabstract user interface prototype. This process is best described in [7]. At the end of this process \nyou ll know what components will be on the interaction context. 9. Create wireframe user interface. Using \npencil and paper create a wireframe drawing of the interaction context. Show basic size and placement \nof screen components. 10. Test the interaction contexts. Use role-playing to step through each task case \nused in the interaction context. One participant pretends to be the role that would perform the task, \nanother plays the role of the user-interface. Validate that you can easily and effectively reach your \ngoal using this interaction context.  6. PUTTING IT INTO PRACTICE 6.1 Starting In the Middle. Armed \nwith a year s worth of Extreme Programming development experience, U-CD training, and lots of other bits \nof useful information from books, papers and colleagues, I set out at Tomax, my current employer, to \nprove that U-CD + XP was indeed a potent combination that would lead to on time delivery, high quality \nand ultimately satisfied users. The rest of this paper describes how close we came and how much remains \nto be discovered. While it s exciting to think we could put into place a set of new practices, we never \nquite have a clean slate. In my situation we had legacy practices to deal with. When it came time to \napply Usage-Centered Design it was often a bit too late. There was no shortage of new software to write, \nbut before our company had agreed to write the software, documents had generally been written up and \nagreed-to describing scope, features, and functionality. In many cases if we were to attempt to practice \nU-CD our company would have been accused of re -trenching the same material already discussed by marketing \nand/or project management. Looking at the use of the software often meant asking users to repeat conversations \nthey d already had when drawing up the agreement. In addition the results of such a conversation may \nyield changes in scope. This notion was at best unpopular. 6.2 Some Opportunities and Some Success There \nwere, however, some greenfield opportunities. These were projects where requirement were not yet agreed \nto and where the customers and management were willing to approach things in a slightly different way. \nIn those situations we practiced Agile U-CD as described above with some success. 6.3 What Worked: The \npreconception purge before the process seemed to be the chance to vent everyone was looking for. Giving \nthe group permission to have an unorganized conversation where anything could be said brought to light \nmany concerns and fears we d have not gotten to any other way. This free form conversation supplied everyone \ninvolved with an immense amount of useful background. We left ideas captured during this process on poster \npaper taped to the wall. At the end of this process we were able to double back and make sure we d dealt \nwith the concerns, or found they weren t really concerns any more. Working with 3 x 5 cards struck some \nparticipants as very low tech, but the results were very effective. The discussion took the same form \nas a CRC card session [2] might take. But, instead of classes, responsibilities, and collaborations, \nwe talked about user roles and tasks. We saw lots of card waving and passing cards back and forth. People \nimmediately understood what was important by looking at the position of the card on the table. People \nimmediately knew what ideas were related by their position in relation to each other. An arrangement \nof cards on the table could communicate far more, faster than any paper document or diagram could. We \nfound that taping card arrangements to poster paper, then marking up the taped arrangements resulted \nin a very valuable model. Figure 3. Participants quickly learn to work with 3 x 5 cards. Mapping Task \nCases to Abstract Prototypes was a very simple and effective way to push through from knowing what we \nneeded to do to how it might look on the screen. The Abstract Prototype consisted of post -it notes, \nsignifying abstract components, stuck to poster paper. We could easily rearrange them and push through \nthis paper-prototyping phase to a simple wireframe user interface. 6.4 What Was Bumpy: Folks had problems \nwith User Roles. In U-CD a role isn t a job title but more accurately a high level goal. For example: \nClerk is a job title. CustomerSalesTransactionHandler is a role. The distinction becomes important when \nsomeone looks at a list of roles later and is unable to determine what each does. Or when looking at \na task case like ReturnMerchandise and ask who does it? In this case if you re using job titles, the \nClerk, Assistant Manager and Manager may all have responsibility to perform that task but, we d have \nto know the business rules to be sure. However, we can reasonably assume a CustomerSalesTransactionHandler \nmight have that responsibility. Choosing expressive role names is valuable but is a hard idea to grab \nonto for domain experts. In practice I found it easier to let folks use roles like clerk initially. During \ndiscussion of the role and the goals the role had, we could easily convert the job title to one or more \nrole names that captured the users goals. Attention spans weren t long enough. By the time you reach \nthe tail end of the process when it will really bear fruit, people are exhausted and unable to effectively \ndo a good job building the UI. Reconvening the next day left us with a fair amount of ground to cover \nagain to get everyone back on the same page. The process takes a while and for those who don t do it \noften, it s time consuming and tiring. Folks were accustomed to one person going off to a cubical to \nwrite functional specifications and not this long collaborative process. As anyone who practices pair \nprogramming can tell you, constant collaboration can be exhausting. We found it most effective to split \nthe process at the point we d identified interaction contexts. We could then continue the process at \na later time using a smaller more focused group of people those that were ultimately responsible for \ndelivering the system. The resulting artifacts look funny. In this organization functional design previously \ntook the form of a list of shalls the software shall do this sort of statements along with assumptions, \na very literal screen design, and sometimes a narrative on how it would be used. Roles and a role model \nweren t immediately understandable. Task Cases seemed too general too abstract for so me folks. Wireframe \nUI drawings weren t quite literal enough. These issues impacted acceptance of the functional design. \nOn occasions that we needed to produce functional design, it seemed to work best to document user roles, \nthe names and goals of each user task, and cleaned up versions of wireframe user-interface drawings. \nThese things dropped into a document seemed to look enough like requirements for folks to sign-off on \nthe effort.  7. REFLECTING ON WHAT WE D DISCOVERED 7.1 Were We Gaining Anything? It sure felt that way. \nAlthough close collaboration within a large group was tiring, when we finished the amount of tacit knowledge \nin the group was irreplaceable. Everyone within the team understood who the users were and what their \ngoals were. Those in the team who hadn t been present for the U-CD sessions quickly assimilated the vocabulary \nof those who did. Artifacts, such as role and task models, created during the session were posted in \nthe development area to radiate [5] information throughout the implementation of the software. Our priorities \nbecame clear. We need only find the focal, or most important user roles and their focal task cases to \nfind the best starting point for development. If we became bogged down implementing functionality for \nroles that weren t focal, we could justify choosing a simpler, less elegant, but cheaper and faster approach. \nWas this better than a long, functional design written by one expert? It s not easy to say that the results \nwere definitely better, but it is easy to say that team members understanding and ownership of the software \nwas higher than before. By arriving at this functional design together, all knew how to accomplish this \nprocess and we'd eliminated what was before a single point of failure. This seemed like a definite improvement. \n 7.2 Test-Driven Design For User Interactions Throughout the development process, whenever anyone on \nthe team was unclear on the direction we were going with the software, we d pick up the original task-cases \nand attempt to execute them on the software. They became our working acceptance tests. Knowing user roles \nhelped answer other questions like what the ability level of the user was and what that user s goal \nwas. For example, often in a business process the goal of the user doing the process is much different \nthan a manager who needs to have visibility of what was done. They need to see different information \nat different times. Using user roles, circumstances like this became clearer. Finally, when formal acceptance \nand QA had to occur, task cases could be fleshed out to contain specific references to the actual implemented \nuser interface along with literal test data. Roles would serve as a collection point for acceptance tests. \nWe d focus on validating the software a role at a time essentially wearing the hat of the user role and \nperforming the work they d need to perform with the software. Our confidence in the finished software \nwas higher. The feeling seemed analogous to the feeling you get developing source code using automated \nunit testing and test-driven development. It s not really provable that code developed this way is better \nthan other ways, but after doing it I find my confidence in the code is higher. I also find I m unwilling \nto work any other way as that seems risky or foolish. As with test-driven development, there was no knowing \nif our finished results were indeed better than we could have come up without U-CD, but confidence was \nhigher. Proceeding on a project without knowing what user roles existed for the product and what tasks \nthey needed to perform now feels as risky as writing code without unit tests.  8. WHAT SHOULD I DO TOMORROW? \n8.1 Interaction Design Incorporated Into Day-to-Day Processes of a Mostly Agile Company. At Tomax Technologies, \ncertain agile processes have taken off and work well. Scrum-style [15] daily stand-up meetings are commonplace. \nCockburn s Information Radiators abound [5]. Teams develop iteratively, many of them using schedules \ngenerated by an XP style planning game. Some t eams religiously use unit-testing, pairing, and refactoring. \nOther teams are still a bit suspicious of all these new-fangled ideas. Although we have product managers, \nthey don t have the time to ride shotgun on a project the way an XP customer should. T hey rely on the \nteam to make the detailed decisions about the implementation of features in the product. Acceptance testing \nis up to the team and performed by test/QA staff assigned to the team. Development methodology is a decision \nmade more at the team level than the corporate level. In this sort of environment, how do we incorporate \nsome interaction design into things we do every day? Figure 4. Our development environment at Tomax \nis wallpapered with role models, task models, task cases, and wireframe UI drawings alongside XP-style \niteration schedules. The following is a short list of Interaction-Design-centric guidelines our team \ntries to observe: 1. We always ask who? While we're looking at a piece of development we make an effort \nto understand who will be using it. What is the user role involved? If we don't know, we back up and \ndo a quick user-role brainstorming session. Arrange a few 3 x 5 cards on a table to understand the role \nmodel, and then continue on. When we understand who will be using the application, we make better decisions \nabout what they should see and how sophisticated the interactions can be. 2. We validate user interactions \nwith a task-case. To make sure our user interface is usable, we write a simple task-case giving us the \nstep-by-step intention driven process a particular user role might follow to complete the task. Does \nthe current design of the application do this efficiently? This may be analogous to a manually executed \nXP acceptance test. 3. We strive to understand focal user roles and focal task-cases. Make sure everyone \nin the project understands who it is most important to satisfy and what specific activities need to run \nsmoothest. Focus on those. Spend extra effort to make them right. Allow the less important roles and \ntask\u00adcases to slide. They need to be functional - but fluid and pretty may be a little less important. \nTime is most wisely spent elsewhere. 4. We look for features that don't serve any role or facilitate \nany task.  There's always a temptation to scoop up seemingly easy features. Beware statements like \"It \nwould be cool of the software could...\" -or - \"right here we could show...\" Always ask what user role \nneeds this? What will they be doing when they do need it? Does this user role care about this information? \nWhat information do they care about? 5. We elevate the writing of stories into interaction design. Help \nthe folks who know the business understand user roles and task-cases. Before requirements are created \ndiscuss roles -who's important, who isn't. Discuss task cases what does each role do. Clearly understand \npriority and dependence. This makes planning an iteration easier. This allows us to deliver a truly usable \nproduct sooner by appropriately accommodating all the necessary tasks of a focal role. 6. We revisit \nour requirements often.  In implementing the software thus far, have we learned of a role we didn't \nknow about earlier? Have we found that to accomplish a goal it may take unforeseen tasks or that some \nof our tasks are unnecessary? When we're not sure, we pull out the 3 x 5 cards and reassemble role models \nand task models to evaluate if the design still makes sense.  9. INTERACTION DESIGN AND AIM 9.1 Beck \n&#38; Cooper Face Off. In an interview posted Jan 15th 2001 on Fawcette Technical Publications website \n[14], Kent Beck and Alan Cooper face off on the subject of up-front interaction design vs. agile methods. \nExcerpts from the conversation include the following comments. Cooper: I'm not talking about having \na more robust communication between two constituencies who are not addressing the appropriate problem. \nI'm talking about incorporating a new constituency that focuses exclusively on the behavioral issues. \nAnd the behavioral issues need to be addressed before constru ction begins. Beck: OK, wait. I agreed \nwith you very close to 100 percent, then you just stepped off the rails. I don't see why this new specialist \nhas to do his or her job before construction begins? Cooper: It has to happen first because programming \nis so hellishly expensive There's enormous cost in writing code, but the real cost in writing code is \nthat code never dies. If you can think this stuff through before you start pouring the concrete of code, \nyou get significantly better results. Beck: No. I'm going to be the programming fairy for you, Alan. \nI'm going to give you a process where programming doesn't hurt like that where, in fact, it gives you \ninformation; it can make your job better, and it doesn't hurt like that. Now, is it still true that you \nneed to do all of your work before you start? I hear Cooper asserting that software is too rigid to easily \nchange that we must get interaction design right, all of it, before we develop. I hear Beck saying that \nwe ve eliminated the cost of change curve so we can now get it wrong without incurring great expense. \nIt seems that both Beck and Cooper share the same goal of cost-effectively delivering high quality software \nthat results in end-user satisfaction. They seem to disagree on how this is done. Could they both be \nright to some degree? 9.2 Building Better Aim. If our goal is to deliver high quality software on time \nwhile satisfying end-users, then, that s a good target to aim for. I d interpret Cooper as saying we \nneed to hit our target with one carefully calculated shot, and the interaction designer should be the \none to take aim. I d interpreting Beck saying we can shoot often and cheaply, so keep shooting until \nyou hit your target. Let businesspeople take aim since they re paying for all of this. In my experience, \nI ve seen evidence that we can indeed shoot often and cheaply. But, I ve also seen evidence that businesspeople \ndon t always have the best aim. And, although XP and agile methods do help minimize the cost of developing \nworking software and decrease the cost of changing it, cost is still cost. And businesspeople don t like \npaying unnecessary costs. If this metaphor holds, then a working solution might be to try to improve \nthe aim of the businesspeople by using interaction design concepts to help better define our requirements. \nIf we can dependably and repeatably apply interaction design tactics we should be able to build better \naim. Our experience at Tomax bears this out. The simplicity and repeatability of U-CD allows the actual \ncustomer, business leaders, and developers to all participate in \"designing\" the requirements. During \nthis process we all feel more confident that we understand what the software should do and why. We still \nmiss our target sometimes, however good development practices do indeed allow us to change the design \nquickly. Also important is that when we do get it wrong we now understand a little better why. It's often \nan undiscovered user role, or goal. Using an interaction designer's sensibilities and U-CD as process \nframework, we are all learning to ask better questions which gives us the better aim we ve been looking \nfor 10. ACKNOWLEDGEMENTS Thanks to valued team-members from Tomax Technologies &#38; Evant Solutions \nfor providing a laboratory to learn in. Thanks to Larry Constantine &#38; Lucy Lockwood for being great \nteachers. Thanks to collaborators and advisors: Stacy Patton and Kay Johansen. Special thanks for valuable \nfeedback and advice goes to Alistair Cockburn for help in motivating and revising this paper. Tha nks \nto Lougie Anderson for her advice, and encouragement. Thanks also to the enthusiastic team at Sabrix \nwho allowed themselves to be guinea pigs. 11. REFERENCES [1] Agile Alliance http://www.agilealliance.com \n[2] Beck, K., Cunningham, R., A Laboratory For Teachin g Object Oriented Thinking, (1989) http://c2.com/doc/oopsla89/paper.html \n[3] Beck, K., Extreme Programming Explained, Adison-Wesley (1999) [4] Cockburn, A., Writing Effective \nUse Cases, Addison -Wesley (2000) [5] Cockburn, A., Agile Software Development, Addison-Wesley (2001) \n[6] Constantine L. &#38; Lockwood L., Software For Use, Adison -Wesley, (April 1999) [7] Constantine, \nL., Windl, H., Noble, J., &#38; Lockwood, L. From Abstract to Realization in User Interface Designs: \nAbstract Prototypes Based on Canonical Abstract Components (2000) http://www.foruse.com/Files/Papers/canonical.pdf \n[8] Constantine L., Process Agility and Software Usability (2001) http://www.foruse.com/Files/Papers/agiledesign.pdf \n[9] Cooper, A., About Face, Hungry Mind s Inc. (1995) [10] Cooper, A., The Inmates are Running the Asylum, \nSams (1999) [11] Fowler, M., Refactoring: Improving the Design of Existing Code, Addison -Wesley (1999) \n[12] Jeffries, R., Anderson, A., Hendrickson, C., Extreme Programming Installed, Addison-Wesley (2000) \n[13] Mathaissen [14] Nelson, E., Extreme Programming vs. Interaction Design (2002)http://www.fawcette.com/interviews/beck_cooper/ \n[15] Schwaber, K., Beedle M., Agile Software Development with Scrum, Prentice Hall, (2001) [16] Test \nDriven Programming http://xp.c2.com/TestDrivenProgramming.html [17] Wirfs-Brock, <Which paper did she \nfirst document conversational use cases? Find this.> [18] Extreme Programming Yahoo Group http://groups.yahoo.com/group/extremeprogramming/ \n Hitting the Target: Adding Interaction Design to Agile Software Development    Software Development \n Jeff Patton  Tomax Technologies  Salt Lake City, UT  Jpatton@tomax.com   Usage-Centered Design \nU-CD is an instance of Interaction Design published by Constantine &#38; Lockwood in Software For Use. \nInteraction Design: Almost all interaction design refers to the selection of [software] behavior, function, \nand information and their presentation to users. Alan Cooper, The Inmates are Running the Asylum Interaction \nDesign concepts help us select behavior &#38; function.    and project easy.  \n\t\t\t", "proc_id": "604251", "abstract": "Extreme Programming appears to be a solution for discovering and meeting requirements faster (through close customer collaboration) as well as creating quality software. In practice we found XP did deliver high quality software quickly, but the resulting product still failed to delight the customer. Although the finished product should have been an exact fit, the actual end-user still ended up slogging through the system to accomplish necessary day-to-day work. This paper describes using interaction design in an agile development process to resolve this issue. Using interaction design as a day-to-day practice throughout an iterative development process helps our team at Tomax Technologies deliver high quality software, while feeling confident the resulting software will more likely meet end-user expectations. The method of Interaction Design followed here is based on Constantine and Lockwood's Usage-Centered Design. Recommendations are provided on how to practice an agile form of U-CD and how to incorporate bits of Interaction Design thinking into every day development and product planning decisions.", "authors": [{"name": "Jeff Patton", "author_profile_id": "81342507002", "affiliation": "Tomax Technologies, Salt Lake City, UT", "person_id": "PP14143513", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604251.604255", "year": "2002", "article_id": "604255", "conference": "OOPSLA", "title": "Hitting the target: adding interaction design to agile software development", "url": "http://dl.acm.org/citation.cfm?id=604255"}