{"article_publication_date": "01-25-2012", "fulltext": "\n Free.nement Stephan van Staden Cristiano Calcagno Bertrand Meyer ETH Zurich ETH Zurich, Imperial College \nLondon ETH Zurich Stephan.vanStaden@inf.ethz.ch and Monoidics Ltd Bertrand.Meyer@inf.ethz.ch c.calcagno@imperial.ac.uk \n Abstract Free.nement is an algorithm that constructs a sound re.nement cal\u00adculus from a veri.cation \nsystem under certain conditions. In this paper, a veri.cation system is any formal system for establishing \nwhether an inductively de.ned term, typically a program, satis.es a speci.cation. Examples of veri.cation \nsystems include Hoare log\u00adics and type systems. Free.nement .rst extends the term language to include \nspeci.cation terms, and builds a veri.cation system for the extended language that is a sound and conservative \nextension of the original system. The extended system is then transformed into a sound re.nement calculus. \nThe resulting re.nement calculus can interoperate closely with the veri.cation system it is even possi\u00adble \nto reuse and translate proofs between them. Free.nement gives a semantics to re.nement at an abstract \nlevel: it associates each term of the extended language with a set of terms from the original language, \nand re.nement simply reduces this set. The paper applies free.nement to a simple type system for the \nlambda calculus and also to a Hoare logic. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: \nSoftware/Program Veri.cation; D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory; F.3.1 [Logics \nand Mean\u00adings of Programs]: Specifying and Verifying and Reasoning about Programs General Terms Languages, \nTheory, Veri.cation Keywords Formal Systems, Proof Theory, Re.nement 1. Introduction Many theories in \ncomputer science are presented, or approximated, by compositional veri.cation systems. In this paper, \na veri.cation system is any formal system for establishing whether an inductively de.ned term, typically \na program, satis.es a speci.cation. For ex\u00adample, Hoare logics and type systems can be viewed as veri.ca\u00adtion \nsystems. In the case of Hoare logics, the system proves that a statement satis.es certain speci.cations \ngiven as preconditions and postconditions. In the case of type systems, the system proves that a term \nhas a certain type in a type context. Re.nement systems play a similar role to veri.cation systems, the \nmain difference being that they relate terms to other terms, in\u00adstead of terms and speci.cations. Another \ndifference is that they  Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 12, January 25 27, 2012, Philadelphia, PA, USA. Copyright &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. \n. . $10.00 c typically include so-called speci.cation terms. Intuitively, a term re.nes another if it \nis better , i.e. if it satis.es more speci.cations. Re.nement calculi are formal systems for establishing \nre.nements. For example, the calculus of Morgan [9] derives re.nements be\u00adtween statements based on total \ncorrectness speci.cations. Starting from an appropriate speci.cation statement, one can derive a cor\u00adrect \nalgorithm for computing the factorial of a number by applying Morgan s re.nement rules. This paper originates \nfrom the observation that a Hoare logic and a re.nement calculus for a command language do not have to \nbe independent entities: once the Hoare logic is extended with speci.cation statements, the two systems \ncan be accommodated in a single theory. Moreover, there is a strong relation between the two systems. \nThe paper explains that this relation is not a coincidence: it is possible to analyze the structure of \nthe inference rules de.ning a veri.cation system, and automatically generate a related re.nement calculus. \nFree.nement is an algorithm that implements this transformation. Surprisingly, free.nement is not limited \nto Hoare logics, but can be applied to any veri.cation system whose inference rules satisfy certain conditions. \nSeveral re.nement rules proposed in the literature in different contexts arise in this way. The free.nement \nalgorithm works as follows. Given a term lan\u00adguage and an accompanying veri.cation system V1 that satis.es \ncertain conditions, free.nement extends the term language with speci.cation terms and builds a veri.cation \nsystem V2 for extended terms. The conditions on V1 ensure that it is possible to extend the terms without \nbreaking the inference rules; V2 is consequently a sound and conservative extension of V1. Moreover, \nfree.nement proposes a sound re.nement system R that is in harmony with V2. Harmony means that the two \nformal systems can interoperate smoothly. It entails, for example, that a term satis.es a speci.cation \naccording to V2 if and only if it is possible to re.ne the speci.cation into the term with R. In fact, \nproof translation between V2 and R becomes possible because harmony is demonstrated constructively. Free.nement \ninternally constructs the re.nement calculus by lin\u00adearizing V2 in a series of steps. The conditions \non V1 ensure that successful linearization is possible. According to the presentation below, at most \nsix steps are needed for this re.nement of re.ne\u00adment systems . The situation is summarized as follows: \nSound &#38; Conservative Extension HarmonyV2 R1 \u00b7\u00b7\u00b7 R6 V1 Free.nement requires no human intervention. \nThe conditions it imposes are ful.lled by many program logics and type systems: examples include Hoare \nlogic, separation logic, the simply-typed lambda calculus and System F. Free.nement de.nes the semantics \nof re.nement at an abstract level: it associates each term of the extended language with a set of terms \nfrom the original language, and re.nement simply reduces this set.  With free.nement, tools that are \nbased on veri.cation systems can readily include re.nement as a complementary or alternative development \nstyle. Free.nement provides correctness by construc\u00adtion for free. Outline. Section 2 describes the free.nement \nalgorithm, which is applied in Section 3 to a simple type system for the lambda calculus and also to \nHoare logic. Section 4 concludes with related work. 2. Free.nement 2.1 The Inputs Free.nement requires \nfour things as input: 1. A set of constructors K. The constructors give rise to a term language T, where \nan arbitrary term t of T is de.ned by the grammar: t ::= C(t1,...,tn) where C . K. 2. A set of speci.cations \nS. 3. A binary relation |=V1 Sat between terms and speci.cations. Intuitively, |=V1 t Sat S denotes \nthat term t . T satis.es speci.\u00adcation S . S. 4. A formal system V1(K, S, |= V1 Sat ), which consists \nof a set of inference rules for proving sentences of the form t Sat S. Each rule of V1 must have the \nform A1 or B1:  t1 Sat S1 ... tn Sat Sn A1 C(t1,..., tn) Sat S provided Pred(C, S1,..., Sn,S). t Sat \nS1 ... t Sat Sm B1 t Sat S provided Pred(S1, ..., Sm,S). The t s, S s and C in the rule forms indicate \nwhere the rules of V1 must use metavariables. Thus a rule of form A1 has only the freedom to choose a \nconcrete n and a de.nition for its proviso predicate Pred; the proviso predicate implements the side \ncondition of the rule based on the arguments C, S1, ..., Sn and S. A rule of form B1 is also a pair: \na concrete m and a de.nition of a predicate with arguments S1, ..., Sm and S. Free.nement requires that \nthe rules must be sound with respect to the following semantics: De.nition 1 (Semantics of the Inference \nRules). 1.1 For rules of the form A1: Pred(C, S1,...,Sn,S) . [.t1,...,tn . T \u00b7|= V1 t1 Sat S1 . ... .|= \nV1 tn Sat Sn .|= V1 C(t1,...,tn) Sat S] 1.2 For rules of the form B1: Pred(S1, ..., Sm,S) . [.t . T \u00b7|= \nV1 t Sat S1 . ... . |= V1 t Sat Sm .|= V1 t Sat S] The rule forms stipulate that the rules of V1 must \nbe highly compositional a requirement that free.nement will exploit. For example, rules cannot inspect \nor constrain the t s that appear in premises. This will allow free.nement to reuse the rules after speci.cation \nterms are added to the term language. Consider the following three rules over K = {0, succ, pred} and \nS = {N}, where n is a metavariable: n: N succ(n) : N n: N 3 1 2 pred(n) : N succ(n) : N pred(succ(n)) \n: N provided positive(n). Rule 1 can be written in form A1 with n = 1 by de.ning the proviso Pred(C, \nS1,S)asC=succ . S1 =S= N. Rule 2 is unacceptable, because its premise inspects the term and requires \nit to match succ(n). Rule 3 is also unacceptable, because it constrains the term in its proviso. It will \nbecome clear later that the structural rules of Hoare logic, such as the rule of consequence, are examples \nof rules of form B1. Other rules of Hoare logic, such as the assignment axiom and rule for sequential \ncomposition, have the form A1. Let fV1 t Sat S denote that t Sat S is derivable with V1.The soundness \nof the rules with respect to the semantics of De.nition 1 implies the soundness of V1: Theorem 1 (Soundness \nof V1). fV1 t Sat S .|= V1 t Sat S Proof. By induction on the derivation of t Sat S: A rule of the form \nA1 was last applied. Assume Pred(C, S1, ..., Sn, S) and the induction hypothesis |= V1 t1 Sat S1 . ... \n. |= V1 tn Sat Sn.Then |= V1 C(t1,...,tn) Sat S by De.nition 1.1.  Aruleoftheform B1 was last applied. \nAssume Pred(S1, ..., Sm, S) and also the induction hypothesis |= V1 t Sat S1 . ... . |= V1 t Sat Sm. \nFrom De.nition 1.2 follows |= V1 t Sat S.  Free.nement does not assume the completeness of V1,i.e.itnever \nassumes |= V1 t Sat S .fV1 t Sat S.  2.2 The Extended Language and Formal System This section extends \nthe language T with speci.cation terms that are useful for re.nement. It gives a semantics to the resulting \nlanguage U, and extends V1 in a sound and conservative way to prove sentences of the form u Sat Swhere \nu . U. 2.2.1 The Extended Language U Suppose K and S are disjoint (if they are not, then they can always \n be decorated to become disjoint) and do not contain a symbol . The extended set of constructors K' \n= K . S .{ with arity n | n . N} gives rise to an extended language U, which can also be written as: \n u ::= C(u1, ..., un) | S | (u1, ..., un) A term of the form S is called a spec term, and a term of the \nform (u1, ..., un) is called the join of u1, ..., un. Intuitively, S is a generic term that satis.es \nS, and (u1, ..., un) is a generic term that satis.es any S that any of the u1, ..., un satisfy. Although \nthe details will become clear later, the reasons for adding these terms are simple: the re.nement system \nshould be able to re.ne spec terms into other terms for top-down development, and join terms will be \nimportant for simplifying rules of the form B1 where m> 1. If there are no rules of the form B1 where \nm> 1,then join terms and their consequent treatment can be omitted. A couple of constructs are used for \ngiving a semantics to U. Let X denote a subset of T, and let Y denote a subset of S. Specs(X) is the \nset of all speci.cations that all the terms in X satisfy, and Terms(Y) is the set of terms of T that \nsatisfy all the speci.cations in Y: De.nition 2 (Specs and Terms). def Specs(X) = {S |.t . X\u00b7|= V1 t \nSat S} def Terms(Y) = {t |.S . Y\u00b7|= V1 t Sat S}  An antitone Galois connection1 exists between Specs \nand Terms: Lemma 1. X . Terms(Y) . Y . Specs(X) Proof. X . Terms(Y) . {de.nition of Terms and .} .t . \nX \u00b7.S . Y \u00b7|= V1 t Sat S  . {predicate calculus} .S . Y \u00b7.t . X \u00b7|= V1 t Sat S  . {de.nition of Specs \nand .} Y . Specs(X)   Antitone Galois connections have several well-known proper\u00adties. For instance, \n(Terms . Specs) and (Specs . Terms) are exten\u00adsive, increasing and idempotent and therefore closure operators. \nFree.nement relies on the following properties (their proofs appear in the Appendix): Corollary 1. 1.1 \nX . Terms(Specs(X)) 1.2 Terms(Specs(Terms(Y))) = Terms(Y) 1.3 Specs(X) . Specs(X ' ) . Terms(Specs(X)) \n. Terms(Specs(X ' )) 1.4 Terms(Y . Y ' )=Terms(Y) n Terms(Y ' ) The following auxiliary de.nition provides \na shorthand for the set of all terms of the form C(t1, ..., tn)wheret1 . X1, ..., tn . Xn: def C(X1,..., \nXn) = {C(t1, ..., tn) |ti . Xi} i.1..n For example, it yields a singleton set for nullary constructors: \n {C() |ti . Xi} = {C() | True} = {C()} i.1..0 The semantics of U is given by the function [[ ]] of type \nU . P(T), i.e. every term in U denotes a set of terms from T: De.nition 3 (Semantics of U). def [[C(u1, \n...,un)]] = Terms(Specs(C([[u1]],..., [[un]]))) def [[S]] = Terms({S}) def [[ (u1,..., un)]]=[[ui]] i.1..n \n If the relation |= V1 Sat is well-behaved in a sense that will be made precise later, then [[u]] has \na simple intuitive explanation: it denotes the set of all primitive terms, i.e. terms from T, that re.ne \nu. For a term C(u1, ...,un), .rst consider C([[u1]], ..., [[un]]) theset of terms of the form C(t1, ...,tn)wheret1 \n. [[u1]] (i.e. t1 re.nes u1)and...and tn . [[un]]. All the speci.cations that all these terms implement \nare then collected, and any primitive term that satis.es all such speci.cations re.nes C(u1, ...,un). \nThe primitive terms  that re.ne S are exactly those that satisfy S. Finally, (u1,...,un) is re.ned by \nany primitive term that re.nes all u1,...,un. For all u, the set [[u]] is a .xpoint of Terms . Specs \nand hence a closed element: Lemma 2. Terms(Specs([[u]])) = [[u]] Proof. By induction on the structure \nof u: If u has the form C(u1, ...,un)orS,then [[u]] = Terms(Y) for some Y and the result follows by Corollary \n1.2.  If u has the form (u1,...,un), assume [[ui]] = Terms(Specs([[ui]]))  for all i . 1..n.So [[ (u1, \n..., un)]] =Terms(Specs([[ui]])) i.1..n =Terms( Specs([[ui]])) by Corollary 1.4, and Corol\u00ad i.1..n lary \n1.2 concludes the proof. 1 Also known as an order-reversing or contravariant Galois connection. The \nrest of the paper introduces further properties of the seman\u00adtics as needed.  2.2.2 Extending V1: Preliminaries \nThe next section will extend V1 to obtain a formal system V2 for proving sentences of the form u Sat \nS. The aim is to construct a sound and conservative extension of V1. Informally, a sound extension of \nV1 must have equal or more power: De.nition 4 (Sound Extension). V2(K ' , S ' , |= V2 Sat ) is a sound \nextension of V1(K, S, |= V1 Sat ) if and only if 1. V2 uses richer terms and speci.cations: K . K ' and \nS . S '  2. V2 can prove everything that V1 can prove: .t . T, S . S \u00b7fV1 t Sat S .fV2 t Sat S  3. \nV2 uses a richer semantics: .t . T, S . S \u00b7|=V2 t Sat S .|=V1 t Sat S 4. V2 is sound: .u . U, S ' . \nS ' \u00b7fV2 u Sat S ' .|= V2 u Sat S '  As a consequence, .t . T, S . S \u00b7fV2 t Sat S .|= V1 t Sat S, which \nintuitively means that V2 restricted to K and S is sound with respect to the semantics of V1. In a sound \nand conservative extension, the converse of require\u00adment 2 also holds: De.nition 5 (Sound and Conservative \nExtension). A formal sys\u00adtem V2(K ' , S ' , |= V2 Sat ) is a sound and conservative extension of V1(K, \nS, |= V1 Sat ) if and only if 1. V2 is a sound extension of V1. 2. V1 and V2 restricted to K and S have \nequal derivability: .t . T, S . S \u00b7fV1 t Sat S .fV2 t Sat S  Although a sound and conservative extension \ncannot prove more sentences of the form t Sat S, it is still useful for extend\u00ading the term language \nand installing a richer semantics. It can also extend the speci.cations, but the V2 of the next section \nwill simply use S.  2.2.3 The Extended Formal System V2 The construction of V2 starts with the empty \nset of rules and proceeds in two steps: 1. For each rule of V1, replace t s by u s and add the resulting \nrule. This change of metavariables yields the rule forms A2 and B2 in V2: u1 Sat S1 ... un Sat Sn A2 \nC(u1, ..., un) Sat S provided Pred(C, S1,..., Sn,S). u Sat S1 ... u Sat Sm B2 u Sat S provided Pred(S1, \n..., Sm,S). 2. Add the following rules for spec terms and joins: SPEC S Sat S u Sat S JOIN (..., u,...) \nSat S By induction on the derivation, V1 and V2 are equivalent with respect to derivability on T, i.e. \nfV1 t Sat S .fV2 t Sat S. So for V2 to be a sound and conservative extension of V1, it will suf.ce to \nequip V2 with a richer semantics and to prove it sound. The Sat relation between U and S is de.ned as \nfollows: De.nition 6 (Extended Satisfaction).  def |= V2 u Sat S = .t . [[u]] \u00b7|= V1 t Sat S Furthermore, \nthe U-semantics of t contains t as an element: Lemma 3 (Term Embedding). .t . T \u00b7 t . [[t]] Proof. By \ninduction on the structure of t. Suppose t = C(t1,...,tn) and assume t1 . [[t1]],...,tn . [[tn]].Sot \n. C([[t1]],..., [[tn]]), which is a subset of Terms(Specs(C([[t1]],..., [[tn]]))) by Corollary 1.1. Therefore \n|= V2 t Sat S .|= V1 t Sat S holds, and the soundness proof of V2 establishes that V2 is a sound and \nconservative exten\u00adsion of V1: Theorem 2 (Soundness of V2). fV2 u Sat S .|= V2 u Sat S Proof. By induction \non the structure of the derivation: For each rule of the form A2,assume Pred(C,S1, ..., Sn,S) and assume \n.t1 . [[u1]] \u00b7|= V1 t1 Sat S1 . . . .tn . [[un]] \u00b7|=V1 tn Sat Sn So .t1 . [[u1]],...,tn . [[un]] \u00b7|= \nV1 C(t1,...,tn) Sat S because the corresponding rule of the form A1 in V1 is sound with respect to De.nition \n1.1. So S . Specs(C([[u1]], ..., [[un]])) and hence .t . Terms(Specs(C([[u1]],..., [[un]]))) \u00b7|=V1 t \nSat S. For each rule of the form B2, assume Pred(S1, ..., Sm,S)and assume .t . [[u]] \u00b7|= V1 t Sat S1 \n. ... .|= V1 t Sat Sm. Now .t . [[u]] \u00b7|= V1 t Sat S because the corresponding rule of the form B1 in \nV1 is sound with respect to De.nition 1.2.  SPEC: .t . Terms({S}) \u00b7|= V1 t Sat S by de.nition.  JOIN: \nAssume .t . [[u]] \u00b7|=V1 t Sat S. If t . [[ (..., u,...)]] then t . [[u]] and hence |=V1 t Sat S. Extended \nsatisfaction has an alternative characterization that free.nement will also use: Lemma 4. |= V2 u Sat \nS . S . Specs([[u]]) Proof. |= V2 u Sat S . {de.nition} .t . [[u]] \u00b7|= V1 t Sat S  . {de.nition of Specs} \nS . Specs([[u]])   2.3 System V2 and Re.nement The next section will construct several re.nement systems, \nor cal\u00adculi, that are based on V2. These re.nement systems are formal systems for proving sentences of \nthe form u . u ' . The de.nition of the re.nement relation makes the semantics of re.nement precise: \ndef De.nition 7 (Re.nement). |=u . u ' =[[u]] . [[u ' ]] This de.nition leads to simple proofs, and \nis equivalent to sev\u00aderal other formulations. The following theorem states one such al\u00adternative, and \nits proof mentions others: Lemma 5 (Equivalent Characterization of Re.nement). |=u . u ' ..S \u00b7|= V2 u \nSat S .|= V2 u ' Sat S Proof. [[u]] . [[u ' ]] . {Lemma 2}Terms(Specs([[u]])) . Terms(Specs([[u ' ]])) \n . {Corollary 1.3} Specs([[u]]) . Specs([[u ' ]])  . {de.nition of .}  .S \u00b7 S . Specs([[u]]) . S . \nSpecs([[u ' ]]) .{Lemma 4} .S \u00b7|= V2 u Sat S .|= V2 u ' Sat S If |= V1 Sat is well-behaved, then there \nis also another expla\u00adnation for de.ning |=u . u ' as [[u]] . [[u ' ]]:u ' re.nes u iff every primitive \nterm that re.nes u ' also re.nes u. Put differently, u ' re\u00ad.nes u iff u ' constrains the set of eventual \nprimitive terms that re\u00ad.nement can produce to the same or higher degree compared to u. So u can be seen \nas a placeholder for any of the primitive terms in [[u]], and the role of re.nement is to reduce the \nuncertainty. Many examples of re.nements will follow later, so here is a small one: a join term implements \nthe least upper bound (join) of its immediate subterms with respect to ., hence the name. In particular: \n 1. .i . 1..n \u00b7|=ui . (u1, ..., un) 2. If(.i . 1..n \u00b7|=ui . u), then |= (u1, ..., un) . u. The notation \nu = u ' is a shorthand for [[u]] = [[u ' ]],which is equivalent to |=u . u ' .|=u ' . u. A re.nement \nsystem R will be sound if and only if fR u . u ' implies |=u . u ' . In the next section, free.nement \nwill construct several sound re.nement systems where each system R is related to V2 by the properties \nHarmony 1 and 2 below. Harmony 1. If fV2 u Sat Sand fR u . u ' ,then fV2 u ' Sat S. Intuitively, Harmony \n1 says that V2 contains suf.cient machin\u00adery to prove the same properties about u ' that it could prove \nabout u. In other words, R is not too powerful for V2. Harmony 2. If fV2 u Sat S, then fR S . u. Intuitively, \nHarmony 2 means that the re.nement system R contains suf.cient machinery to re.ne a speci.cation into \nany term that satis.es it according to V2.Inother words, V2 is embedded in R and hence R is not too weak. \nHarmony 1 is stronger than the converse of Harmony 2: Theorem 3. If V2 and a re.nement system R are related \nby Har\u00admony 1, then fR S . u .fV2 u Sat S. Proof. Assume fR S . u. Since fV2 S Sat Sby SPEC,itfollows \nfrom Harmony 1 that fV2 u Sat S. A re.nement system R is called harmonic iff it satis.es Har\u00admony 1 and \n2. Harmonic re.nement systems interoperate nicely with V2. In fact, the proofs of Harmony 1 and 2 in \nthe next sec\u00adtion are constructive in the sense that they enable proof translation. Given a V2-proof \nof u Sat Sand an R-proof of u . u ' ,theydescribe a V2-proof of u ' Sat S. Based on a V2-proof of u Sat \nS, they show how to build an R-proof for S . u. Since Harmony 1 is established constructively, given \nan R-proof of S . u, the proof of Theorem 3 shows how to build a V2-proof for u Sat S. The .nal re.nement \nsystem that free.nement produces will also have a speci.c desired form. This form guarantees that re.nement \nproofs are linear developments where terms can be re.ned in\u00adplace. Formally, a re.nement system has the \ndesired form if the rules with premises describe either the transitivity or the mono\u00adtonicity of re.nement. \nAll the other rules must be axioms, i.e. with\u00adout any premise. 2.4 The Re.nement of Re.nement Systems \nV2 can be linearized in a series of steps to obtain a sound and harmonic re.nement system of the desired \nform. At most six steps are necessary according to this presentation the exact number depends on V1. \nThe steps make it easy to prove and maintain soundness and harmony, which would otherwise be more complex \nto establish for the .nal re.nement calculus.  Many of the steps take a previously constructed re.nement \nsystem and add or remove rules to obtain a new system. If a sound and harmonic re.nement system is extended \nwith a rule that is sound and respects Harmony 1, then the resulting system will be sound and harmonic. \nThere is no need to prove Harmony 2 again, because the new re.nement system can still derive all sentences \nthat the old one could derive. If a rule is removed from a sound and harmonic re.nement system, then \nthe resulting system remains sound and will also be harmonic if it satis.es Harmony 2. A simple way of \nshowing that Harmony 2 still holds is to show that any application of the old rule can be achieved by \na combination of rules that remain in the system. 2.4.1 Getting Started: R1 The .rst re.nement system \nR1 is obtained from V2 by a simple syntactic transformation: each sentence u Sat S becomes S u. R1 has \nrules of the form A3 and B3,a SPEC rule and also a JOIN rule if join terms were needed: S1 e u1 ... Sn \ne un A3 S e C(u1, ..., un) provided Pred(C, S1, ..., Sn,S). S1 e u ... Sm e u B3 S e u provided Pred(S1, \n...,Sm,S). SPEC S e S S e u JOIN S e (..., u,...) V2 and R1 are isomorphic: a proof of u Sat Sin V2 \ncorresponds to a proofofS uin R1 and vice versa, so fV2 u Sat S .fR1 S u. The soundness proof of R1 relies \non the following equivalence: Lemma 6. |= V2 u Sat S .|=Su Proof. |= V2 u Sat S . {Lemma 4} {S}. Specs([[u]]) \n . {Lemma 1} [[u]] . Terms({S})   Theorem 4 (Soundness of R1). fR1 uu ' .|=uu ' Proof. If fR1 uu ' \n,thenuhas theformSand fV2 u ' Sat S. The soundness of V2 implies |= V2 u ' Sat S, and Lemma 6 in turn \nimplies |=Su ' . Theorem 5. R1 is harmonic. Proof. Harmony 2 holds by construction. For Harmony 1, assume \nfR1 uu ' .ThenuhastheformS '' and fV2 u ' Sat S '' by construc- S '' ' tion. That fV2 u Sat S ' (i.e. \nfV2 Sat S ' ) implies fV2 u Sat S ' for all S ' follows by induction on the derivation of S '' Sat S \n' : SPEC:S ' and S '' are the same. Since fV2 u ' Sat S '' , it holds that fV2 u ' Sat S ' .  For each \nrule of the form B2:SandS ' are the same. Assume Pred(S1,...,Sm,S), fV2 u Sat S1,..., fV2 u Sat Sm, and \nby the induction hypothesis also fV2 u ' Sat S1, ..., fV2 u ' Sat Sm.So the rule being considered is \napplicable and fV2 u ' Sat S. Hence fV2 u ' Sat S ' .  Note: if V2 has only rules of the form A2 where \nn =0 and/or rules of the form B2 where m =0,then R1 is a re.nement system of the desired form and free.nement \nstops. 2.4.2 Adding Transitivity: R2 The re.nement system R2 extends R1 with the rule TRANS which states \nthat re.nement is transitive: u1 e u2 u2 e u3 TRANS u1 e u3 TRANS is sound because . is transitive, and \nit maintains Har\u00admony 1 since implication is transitive. So R2 is sound and har\u00admonic. 2.4.3 Simpli.cation: \nR3 The presence of SPEC and TRANS in R2 allows the simpli.cation of rules of the form B3 with m =1: S1 \ne u B3 S e u provided Pred(S1,S). For an arbitrary rule of this form, consider the derivation SPEC S1 \ne S1 B3 S e S1 provided Pred(S1,S). By virtue of having been derived, the new rule B3 S e S1 provided \nPred(S1,S). is sound and maintains Harmony 1, and can therefore be added to R2 to obtain a sound and \nharmonic re.nement system. In fact, it can replace the old version without breaking Harmony 2, since \nremoving the old version will not decrease the derivable set of sen\u00adtences: every application of the \nold B3 can be changed into: B3 S e S1 S1 e u TRANS S e u since Pred(S1, S) is guaranteed. The re.nement \nsystem R3 is the same as R2, except that the rules of the form B3 with m =1 are replaced by their simpli.ed \nversions. R3 is sound and harmonic. Note: if V2 has only rules of the form A2 where n =0 and rules of \nthe form B2 where m = 1,then R3 is a re.nement system of the desired form and free.nement stops. 2.4.4 \nAdding Monotonicity: R4 All the constructors of U are monotone with respect to ,i.e.the following rules \nare sound: ' ui e ui C-i ' C(u1, ..., ui, ..., un) e C(u1,...,u ,...,un) i ' ui e ui JOIN-i (u1,...,ui,..., \nun) e (u1, ..., u ' , ..., un) i Moreover, these rules maintain harmony: Lemma 7. C-i maintains Harmony \n1. Proof. Assume .S ' \u00b7fV2 ui Sat S ' .fV2 ui ' Sat S ' .That .S \u00b7 fV2 C(u1, ..., ui, ..., un) Sat S \n.fV2 C(u1, ..., u i' , ..., un) Sat S follows by induction on the derivation of C(u1, ..., ui, ..., un) \nSat S: A2: Suppose fV2 uj Sat Sj for j . 1..n, and also suppose Pred(C, S1, ..., Sn, S) holds. Since \nfV2 u ' i Sat Si, the same rule A2 can be applied to derive C(u1, ..., u i' ,...,un) Sat S.  B2: Suppose \nfV2 C(u1, ..., ui, ..., un) Sat Sj for j . 1..m, and suppose Pred(S1, ..., Sm, S). The induction hypothesis \nis the assumption fV2 C(u1, ..., u i' , ..., un) Sat Sj for j . 1..m. Since Pred(S1, ..., Sm,S), thesamerule \nB2 is applicable and hence fV2 C(u1, ..., u i' , ..., un) Sat S. Lemma 8. JOIN-i maintains Harmony 1. \nProof. Assume .S ' \u00b7fV2 ui Sat S ' .fV2 u ' Sat S ' .That .S \u00b7 i fV2 (u1,...,ui,...,un) Sat S .fV2 (u1,...,u \ni' ,...,un) Sat  S follows by induction on the derivation of (u1, ..., ui, ..., un) Sat S: JOIN: Suppose \nuj Sat S was the premise for some j . 1..n. If j i, then apply JOIN to the premise uj Sat Stoderive = \n the required (u1, ..., u i' , ..., un) Sat S. If j = i,thenby assumption fV2 ui ' Sat S holds, and the \nresult follows by JOIN. B2: Suppose fV2 (u1, ..., ui, ..., un) Sat Sj for j . 1..m, and suppose Pred(S1, \n..., Sm, S). The induction hypothesis is the assumption fV2 (u1, ..., u i' , ..., un) Sat Sj for j . \n1..m. Since Pred(S1, ..., Sm,S), thesamerule B2 is applicable and hence fV2 (u1, ..., u i' , ..., un) \nSat S. Let the notation v[u] denote a term in U whose parse tree is factored into two parts: a core \ntree v with a hole where the sub\u00adtree for u .ts. The rule MONO packages C-i and JOIN-i in a single convenient \nform: u e u ' MONO v[u] e v[u'] Informally, the rule MONO allows in-place re.nement: if u0 can be factored \nas v[u], and u ' re.nes u, then v[u ' ]re.nesu0. MONO is sound and maintains harmony because C-i and \nJOIN-i are sound and maintain harmony. The re.nement system R4 ex\u00adtends R3 with MONO. It is sound and \nharmonic. 2.4.5 Simpli.cation: R5 The rule MONO makes it possible to simplify: The JOIN rule: S e u JOIN \nS e (..., u,...) Rules of the form A3 with n = 1: S1 e u1 ... Sn e unA3 S e C(u1,..., un) provided Pred(C, \nS1,..., Sn,S). Consider the derivation: SPEC S e S JOIN S e (..., S, ...) By virtue of having been \nderived, the simpli.ed rule JOIN S e (..., S, ...) is sound and respects Harmony 1. It can replace the \nold version of JOIN without decreasing derivability, because any application of the old version can be \nachieved by: S e u JOIN MONO TRANS S e (..., S, ...) (..., S, ...) e S e (..., u, ...) (..., u, ...) \n Likewise, for each rule of the form A3, the derived rule A3 S e C(S1,...,Sn) provided Pred(C, S1, ..., \nSn,S). is sound and respects harmony. It makes the old version redundant, since any application of the \nold rule can be replaced by: A3 S e C(S1,..., Sn) E1 . . . En where Ei is given by: S e C(u1, ..., ui-1,Si, \n..., Sn) Pi TRANS S e C(u1, ..., ui,Si+1, ..., Sn) and Pi is the proof tree: Si e ui MONO C(u1, ..., \nui-1,Si,...,Sn) e C(u1,...,ui,Si+1, ..., Sn) Apart from these simpli.cations, the re.nement system R5 \nis the same as R4. It is sound and harmonic. Note: if V2 does not include rules of the form B2 where \nm> 1, then R5 has the desired form and free.nement stops. 2.4.6 Wrapping Up: R6 It remains to simplify \nrules of the form B3 with m> 1: S1 e u ... Sm e u B3 S e u provided Pred(S1,...,Sm,S). If Pred(S1,..., \nSm,S),then R5 can derive: JOIN JOIN S1 e (S1, ..., Sm) \u00b7\u00b7\u00b7 Sm e (S1,...,Sm) B3 S e (S1, ..., Sm) The \nderived rule B3 S e (S1,...,Sm) provided Pred(S1, ..., Sm,S). is therefore sound and respects Harmony \n1. Together with the rule: UNJOIN (u, ..., u) e u which is trivially sound and respects Harmony 1, it \ncan replace the old B3 because any application of the old rule can be rewritten as: B3 S e (S1, ..., \nSm) F1 . . . Fm G TRANS S e u where G is UNJOIN,Fi is given by: i-1 '' -v S e (u, ..., u, Si, ..., Sm) \nQi TRANS S e (u, ...,u, Si+1,...,Sm) and Qi is the proof tree: Si e u MONO (u, ...,u, Si,...,Sm) e (u,...,u \n,Si+1,...,Sm) ' v-' i R6 is the same as R5, except that it includes UNJOIN and replaces rules of the \nform B3 where m> 1 with their simpli.ed versions. R6 is sound, harmonic and of the desired form.  2.5 \nDiscussion R6 can be made more powerful in several ways. For example, the following generalization of \nJOIN is sound and preserves Har\u00admony 1: JOIN' u e (..., u,...) The same holds for the re.exivity of \nre.nement, which generalizes SPEC, and other rules such as UNNEST: UNNEST (u1,..., un) e (u1, ..., ui-1,u \n' , ..., u ' ,ui+1, ..., un) 1m ' provided 1 = i = n and ui = (u' 1,...,u ). m In speci.c applications \nof free.nement, it might also be useful to add derived rules to R6. Examples of this will follow later. \nFree.nement assumes as little as possible about |= V1 Sat and is consequently very generic. As one might \nexpect, additional as\u00adsumptions can help to construct more powerful re.nement systems. For example, suppose \nplus is a constructor that is commutative in the sense that .t1,t2 . T, S . S \u00b7|=V1 plus(t1,t2) Sat S \n.|=V1 plus(t2,t1) Sat S Then Specs(plus([[u1]], [[u2]])) = Specs(plus([[u2]], [[u1]])) because S . Specs(plus([[u1]], \n[[u2]])) . .t1 . [[u1]],t2 . [[u2]] \u00b7|= V1 plus(t1,t2) Sat S . .t1 . [[u1]],t2 . [[u2]] \u00b7|= V1 plus(t2,t1) \nSat S . S . Specs(plus([[u2]], [[u1]]))  So [[plus(u1,u2)]] = [[plus(u2,u1)]] and therefore the re.nement \nrule plus(u1,u2) = plus(u2,u1) is sound. Depending on the rules of V1, it might also preserve harmony. \nAs mentioned before, the semantic function [[ ]] and the re.ne\u00adment order have nice interpretations when \n|= V1 Sat is well\u00adbehaved. Here is the de.nition: De.nition 8 (Well-behavedness). |= V1 Sat is well-behaved \niff .C. K,t1, ..., tn . T, S . S \u00b7|= V1 C(t1,...,tn) Sat S . .t . C(Terms(Specs({t1})), ..., Terms(Specs({tn}))) \n\u00b7|= V1 t Sat S There is also an alternative characterization of well-behavedness: Lemma 9. |= V1 Sat \nis well-behaved iff .C. K,t1, ..., tn . T \u00b7 Terms(Specs({C(t1,...,tn)})) = Terms(Specs(C(Terms(Specs({t1})), \n..., Terms(Specs({tn}))))) Proof. ti . Terms(Specs({ti})) for i . 1..n by Corollary 1.1, so {C(t1,...,tn)}. \nC(Terms(Specs({t1})), ..., Terms(Specs({tn}))). Hence by Corollary 2.3 in the Appendix, Specs({C(t1,...,tn)}) \n. Specs(C(Terms(Specs({t1})), ..., Terms(Specs({tn})))). Therefore: |= V1 Sat is well-behaved . .C. K,t1, \n..., tn . T, S . S \u00b7|= V1 C(t1,...,tn) Sat S . .t . C(Terms(Specs({t1})), ..., Terms(Specs({tn}))) \u00b7|= \nV1 t Sat S . .C. K,t1, ..., tn . T, S . S \u00b7 S . Specs({C(t1, ..., tn)}) . S . Specs(C(Terms(Specs({t1})), \n..., Terms(Specs({tn})))) . .C. K,t1, ..., tn . T \u00b7 Specs({C(t1, ..., tn)}) . Specs(C(Terms(Specs({t1})), \n..., Terms(Specs({tn})))) .{by the reasoning above}.C. K,t1, ..., tn . T \u00b7 Specs({C(t1, ..., tn)})= Specs(C(Terms(Specs({t1})), \n..., Terms(Specs({tn})))) The result then follows by Corollary 1.3. Free.nement does not require well-behavedness \nof |= V1 Sat , but the next theorem shows that the intuitions behind the de.nitions are simple when |=V1 \nSat is well-behaved. For example, Theo\u00adrem 6.3 says that [[u]] is the set of all primitive terms that \nre.ne u. Theorem 6. If |= V1 Sat is well-behaved, then 6.1 .t . T \u00b7 [[t]] = Terms(Specs({t})) 6.2 .t \n. T, S . S \u00b7|= V1 t Sat S .|= V2 t Sat S 6.3 .t . T, u . U \u00b7 t . [[u]] .|=ut Proof. 6.1 By induction \non the structure of t. Suppose t = C(t1, ..., tn) and assume [[ti]] = Terms(Specs({ti})) for i . 1..n. \nThen: [[t]] = Terms(Specs(C([[t1]],..., [[tn]]))) = {induction hypothesis}Terms(Specs(C(Terms(Specs({t1})), \n..., Terms(Specs({tn}))))) = {Lemma 9}Terms(Specs({C(t1,...,tn)})) = Terms(Specs({t})). 6.2 |= V1 t Sat \nS . {de.nition of Specs} S . Specs({t})  . {Corollary 2.7 in the Appendix}S . Specs(Terms(Specs({t}))) \n . {Theorem 6.1} S . Specs([[t]])  . {Lemma 4} |= V2 t Sat S  6.3 The . proof is trivial since t . \n[[t]].For ., assume {t}.[[u]]. Then Terms(Specs({t})) . Terms(Specs([[u]])) by Corol\u00adlary 2.5 in the \nAppendix, and [[t]] . [[u]] by Theorem 6.1 and Lemma 2. Whether |= V1 Sat is well-behaved depends partly \non the expressivity of speci.cations. For example, suppose K = {x:=e | e is an arithmetic expression}.{ \n9 } i.e. there is a nullary constructor x := e for all arithmetic expres\u00adsions e, and a binary constructor \nfor sequential composition. Sup\u00adpose S = {Even x},and |= V1 t Sat Even x holds iff, if t is executed \nin any state where x is even, then x is even in every resulting state. So |= V1 x:=x+1 9 x:=x+1 Sat Even \nx, but it is not the case that |= V1 x:=x+1 Sat Even x. In fact, x := x + 1 does not satisfy any speci.cation. \nThis implies that Terms(Specs({x:=x+1}))= T, so x:=1 9 x:=1 . Terms(Specs({x:=x+1})) 9Terms(Specs({x:= \nx+1})). But |= V1 x:=1 9 x:=1 Sat Even x does not hold, hence |= V1 Sat is not well-behaved. Even though \n|= V1 Sat is not well-behaved, it is still possi\u00adble to have inference rules that are amenable to free.nement, \nfor example: 1 t Sat Even x t ' Sat Even xx:=e Sat Even x 2 provided e .{..., -2, 0, 2,... }.t 9 t ' \nSat Even x If S is instead a set of speci.cations of the form [P, Q],where P is a precondition and Q \na postcondition, and |= V1 t9 t ' Sat [P, Q] ..R\u00b7|= V1 t Sat [P, R] .|= V1 t ' Sat [R, Q] then it is \neasy to show that this |= V1 Sat is well-behaved. The completeness of V1 is a suf.cient condition for \nthe well\u00adbehavedness of |=V1 Sat : Theorem 7. If V1 is complete, then |= V1 Sat is well-behaved. Proof. \nIf V1 is complete, then |= V1 C(t1, ..., tn) Sat S . fV1 C(t1, ..., tn) Sat S. The well-behavedness of \n|= V1 Sat fol\u00adlows by induction on the derivation of C(t1, ..., tn) Sat S:  For each rule of the form \nA1,assume Pred(C,S1,...,Sn,S)and Si . Specs({ti})forall i . 1..n.So .t ' i . Terms(Specs({ti}))\u00b7 |=V1 \nt ' i Sat Si for all i . 1..n. The rule is sound with respect to De.nition 1.1, hence .t . C(Terms(Specs({t1})), \n..., Terms(Specs({tn})))\u00b7|=V1 t Sat S.  For each rule of the form B1, assume Pred(S1, ..., Sm,S)and \n.t . C(Terms(Specs({t1})), ..., Terms(Specs({tn})))\u00b7|= V1 t Sat Si for all i . 1..m. The rule is sound \nw.r.t. De.nition 1.2, so .t . C(Terms(Specs({t1})), ..., Terms(Specs({tn})))\u00b7|= V1 t Sat S.  3. Applications \n3.1 Lambda Calculus The top left corner of Figure 1 contains a type system .1 for the lambda calculus. \nBy considering pairs of the form (typing context, type) as speci.cations, it is possible to apply free.nement \nand obtain a re.nement calculus for (extended) lambda terms in the spirit of Denney [4]. The inputs to \nfree.nement are as follows: 1. K =Var .{.x. | x . Var}.{ } Note that K de.nes the language T of lambda \nterms: e ::= x | .x. e | ee ' Here and in the following, x ranges over the set of variables Var, and \ne ranges over T. 2. S = {[G; t ] | G . Context . t . Type}, where Context is the set of typing contexts \nand Type is the set of types that contains the type constructor . . The intended representation of a \ntyping context G is a list of variable names paired with types.  Variables may appear more than once \nin G, and variable lookup uses the rightmost occurrence. In the following, s and t range over Type, and \nG ranges over Context. 3. |= V1 Sat is de.ned by:  |= V1 x Sat [G; t] . x : t . G  |= V1 .x. e Sat \n[G; t] .   .1 V1 x : t . G VAR G f x : t G, x : s f e : t ABS G f .x. e : s . t G f e : s . t G f e \n' : sAPP G f ee ' : t VAR x Sat [G; t] provided x : t . G. e Sat [G, x : s; t]ABS .x. e Sat [G; s . t] \ne Sat [G; s . t] e ' Sat [G; s]APP ee ' Sat [G; t] .2 R5 x : t . G VAR G f x : t G, x : s f f : t ABS \nG f .x. f : s . t G f f : s . t G f f' : sAPP G f ff' : t SPEC G f [G; s]: s VAR [G; t] e x provided \nx : t . G. ABS [G; s . t] e .x. [G, x : s; t] APP [G; t] e [G; s . t][G; s] SPEC [G; s] e [G; s] f1 e \nf2 f2 e f3TRANS f1 e f3 f e f' MONO g[f] e g[f'] '' ' .s, t \u00b7 t = s . t .|= V1 e Sat [G, x : s; t ] \n|= V1 ee ' Sat [G; t] . .s \u00b7|= V1 e Sat [G; s . t] .|= V1 e ' Sat [G; s] 4. V1, shown in the top right \ncorner of Figure 1, is obtained from .1 by replacing G f e : t with e Sat [G; t ].The rules VAR,ABS and \nAPP are all of the form A1 with n =0, 1 and 2 respectively. For example, in the case of ABS,Pred(C,S1,S)isde.nedas \n.x, G, s, t \u00b7 C= .x. . S1 = [G, x : s; t ] . S= [G; s . t]. Since V1 does not contain rules of the form \nB1 where m> 1, free.nement does not add join terms to the lambda calculus. The system .2 in Figure 1 \nis V2 where f Sat [G; t ] is written instead as G f f : t . The system R5, shown in the bottom right \nof Figure 1, is the .nal harmonic re.nement calculus that free.nement produces. Here is an example top-down \ntyping derivation with R5: [G; (s . t) . (s . t)] e ABS .x. [G, x : s . t; s . t] e MONO with ABS .x..y. \n[G, x : s . t, y : s; t] e MONO with APP .x..y. ([G, x : s . t, y : s; s . t][G, x : s . t, y : s; s]) \ne Twice MONO with VAR .x..y. (x y) Figure 1. Free.nement and a typed lambda calculus Since R5 is harmonic \nand V2 is a sound and conservative extension of V1, it holds that f.1 G f .x..y. (x y) : (s . t ) . (s \n. t ). One might wish to extend R5 using knowledge particular to lambda calculus typing. It is simple \nto show that V1 is complete, so f.1 G f e : t .fV1 e Sat [G; t ] .|= V1 e Sat [G; t ] Furthermore, by \nTheorems 7 and 6.2, |= V1 e Sat [G; t] .|= V2 e Sat [G; t ] and because V2 is a sound and conservative \nextension of V1, fV1 e Sat [G; t] .fV2 e Sat [G; t ] Consider the property of preservation: def De.nition \n9. A relation . . T \u00d7 T satis.es preservation = .G, t,e,e ' \u00b7 if f.1 G f e : t and e . e ' ,then f.1 \nG f e ' : t. Theorem 8. If . satis.es preservation, then: 8.1 Ife . e ' ,then |=ee ' . 8.2 If fV2 eSat \n[G; t ] and e . e ' ,then fV2 e ' Sat [G; t]. Proof. The proof of 8.2 is trivial. For 8.1: ' '' .G, t,e,e \n\u00b7f.1 G f e : t . e . e .f.1 G f e : t .{predicate logic} '' ' .e, e \u00b7 e . e . (.G, t \u00b7f.1 G f e : t .f.1 \nG f e : t ) . '' ' .e, e \u00b7 e . e . (.S . S \u00b7|= V2 e Sat S .|= V2 e Sat S) .{Lemma 5} '' ' .e, e \u00b7 e . \ne .|=ee  So any relation that satis.es preservation contains only sound re.nements that satisfy Harmony \n1, and can augment R5 to yield a sound and harmonic re.nement system. Examples of relations that satisfy \npreservation include: The a-conversion relation.  The \u00df-reduction relation.  The .-contraction relation. \nSo .x. (e x) e, provided x does not appear free in e.  The relation = on closed terms, where e = e ' \nexactly when e has fewer types than e ' .  Here is a small example that uses the .-contraction extension: \n.x..y..z. ((x y) z) .{MONO with .-contraction}.x..y. (x y) .{MONO with .-contraction}.x. x 3.2 Hoare \nLogic The top left corner of Figure 2 contains system H, a Hoare logic for simple imperative programs. \nP is a precondition, Q a postcondition, and c a command in the Hoare triple {P}c{Q},and |=H{P}c{Q}is \nthe usual partial correctness interpretation of {P}c{Q}.Byinter\u00adpreting a speci.cation as a pre-post \npair, the rules of H do not .t the rule forms A1 and B1, since the proviso of AUXVARELIM inspects the \ncommand c to determine the variables that it writes and reads. However, if speci.cations also keep track \nof written and read vari\u00adables, then it becomes possible to apply free.nement to obtain a re.nement calculus \nin the spirit of Morgan [9]. Here are the inputs: 1. There are constructors for assignments, sequential \ncomposition, conditionals and loops: K = {x:=e | x . Var . e . IntExp}.{ 9 }.{if b then else | b . BoolExp}.{while \nb do | b . BoolExp} 2. A speci.cation consists of two sets of variables and two asser\u00adtions, written \nin a notation resembling Morgan s speci.cation statement [8]:  S =x; y:{P, Q}| x, y .P(Var) . P, Q \n. Assertion 3. In the speci.cation x; y : {P, Q},the xand y are upper bounds on the sets of variables \nwritten and read by the command re\u00adspectively, the P is a precondition and the Q a postcondition: def \n|=V1 c Sat x; y : {P, Q} = writes(c) . x . reads(c) . y . |= H{P}c{Q} 4. V1, shown in the top right corner \nof Figure 2, has the following relationship with H: fV1 c Sat x; y : {P, Q}. writes(c) . x fH{P}c{Q} \n. reads(c) . y . Note that: The non-structural rules of H have counterparts in V1 that embody the de.nitions \nof writes and reads. For example, the conclusion of COND re.ects that def writes(if b then c else c ' \n) = writes(c) . writes(c ' )and def reads(if b then c else c ' ) = reads(c) . reads(c ' ) . FV(b). The \nstructural rules of H that inspect c for its write and/or read sets have counterparts in V1 that consult \nthe speci.ca\u00adtion instead. See for example the proviso of AUXVARELIM.  CONSEQUENCE in V1 allows the \nenlargement of write and read sets. This loosening of the bounds is useful in re.ne\u00adment developments, \nbecause then the resulting code is not forced to write and read all the variables that were originally \navailable for writing and reading.  The V1-counterparts of the structural rules of H are all of the \nform B1. For example, m =1 in the case of CONSTANCY, and m =2 for DISJ. The other rules are of the form \nA1.For example, n =2 in the case of COND,and n =1 for LOOP. The systems V2 and R6 that free.nement produces \nappear at the bottom of Figure 2. R6 yields several derived rules that may be useful in practical re.nement \ndevelopments. For example, the rule: DERIVEDVARASSIGN x; y :{P, Q}e z:=e provided z . xand FV(e) . yandP \n. Q[e/z]. can replace VARASSIGN, and is similar to the assignment law of Morgan (Law 1.3 on p. 8 of [9]). \nLikewise, the derived rule: FOLLOWINGVARASSIGN x; y :{P, Q}e x; y :{P, Q[e/z]} 9 z:=e provided z . xand \nFV(e) . y. is similar to the following assignment law of Morgan (Law 3.5 on p. 32 of [9]). Here is an \nexample showing that R6 can derive a correct facto\u00adrial algorithm starting with its speci.cation: y,z; \nx,y,z :{true, y=x!} e SEQCOMP y,z; \u00d8:{true, y=1 . z=0} 9 y,z; x,y,z :{y=1 . z=0, y=x!} The .rst spec \nstatement is re.ned as follows: y,z; \u00d8:{true, y=1 . z=0} e SEQCOMP y; \u00d8:{true, y=1} 9 z; \u00d8:{y=1, y=1 \n. z=0} e Twice MONO with CONSEQUENCE y; \u00d8:{1=1, y=1} 9 z; \u00d8:{y=1 . 0=0, y=1 . z=0} e Twice MONO with \nVARASSIGN y:=1 9 z:=0 And for the second spec statement: y,z; x,y,z :{y=1 . z=0, y=x!} e CONSEQUENCE \ny,z; x,y,z :{y=z!, y=z! .\u00aczz =x} e LOOP while zz=x do y,z; y,z :{y=z! . zz=x, y=z!} e MONO with SEQCOMP \nwhile zz=x do z; z :{y=z! . zz =x, y\u00b7z=z!} 9 y; y,z :{y\u00b7z=z!, y=z!}  Figure 2. Free.nement and Hoare \nlogic e MONO with VARASSIGN while zzz =x do z; z :{y=z! . z=x, y\u00b7z=z!} 9 y:=y\u00b7z e MONO with CONSEQUENCE \nwhile zz =x do z; z :{y\u00b7(z+1) = (z+1)!, y\u00b7z=z!} 9 y:=y\u00b7z e MONO with VARASSIGN while zz =x do z:=z+1 \n9 y:=y\u00b7z Since fR6 y,z; x,y,z : {true, y=x!}. y:=1 9 z:=0 9 while z=x do z:=z+1 9 y:=y\u00b7z, it is the \ncase that fV1 y:=1 9 z:=0 9 while z=x do z:=z+1 9 y:=y\u00b7z Sat y,z; x,y,z : {true, y=x!} and hence also \nfH{true}y:=1 9 z:=0 9 while z=x do z:=z+1 9 y:=y\u00b7z{y=x!}. Here is another example of using R6; it involves \njoin statements.  The statement (x; y : {P1, Q1},x; y : {P2, Q2}) is the join of the speci.cation statements \nx; y : {P1, Q1} and x; y : {P2, Q2}. Expressing it as a spec statement is simple because (x; y: {P1, \nQ1},x; y:{P2, Q2}) = x; y:{P1,Q1} also {P2,Q2} where the de.nition of {P1,Q1} also {P2,Q2}, taken from \n[11], is: {(P1 . z=1) . (P2 . z=1), (Q1 . z=1) . (Q2 . z=1)} where z is fresh. R6 can derive both directions \nof re.nement. Firstly:  (x; y :{P1, Q1},x; y : {P2, Q2}) C Twice MONO with CONSEQUENCE (x; y :{.z\u00b7 \n(P1.z=1 . P2.z =1) . z=1, .z\u00b7 (Q1.z=1 . Q2.z=1) . z=1}, x; y :{.z\u00b7 (P1.z=1 . P2.z =1) . z=1, .z\u00b7 (Q1.z=1 \n. Q2.z=1) . z=1}) C Twice MONO with AUXVARELIM (x; y :{(P1.z=1 . P2.z =1) . z=1, (Q1.z=1 . Q2.z=1) . \nz=1}, x; y :{(P1.z=1 . P2.z =1) . z=1, (Q1.z=1 . Q2.z=1) . z=1}) C Twice MONO with CONSTANCY (x; y \n:{P1.z=1 . P2.z =1, Q1.z=1 . Q2.z=1}, x; y :{P1.z=1 . P2.z  =1, Q1.z=1 . Q2.z=1}) C UNJOIN x; y : {P1,Q1} \nalso {P2,Q2} Secondly: x; y : {(P1 . z=1) . (P2 . z =1), (Q1 . z=1) . (Q2 . z=1)} C DISJ (x; y :{P1 \n. z=1, Q1 . z=1},x; y : {P2 . z =1, Q2 . z=1}) C Twice MONO with CONSTANCY (x; y :{P1, Q1},x; y : {P2, \nQ2}) Leino and Manohar [7] mention several uses of the join of spec\u00adlike statements. 3.3 Discussion \nThe type system .1 considered above is very simple. Free.nement also applies to System F and other more \nsophisticated type systems. Although .1 had only rules of the form A1, typing rules of the form B1 are \nquite common examples include rules for subtyping and intersection types: G f e : t ' SUB G f e : t \nG f e : t ' G f e : t INTER ' ' G f e : t.t provided t<: t . There is no golden recipe for adapting proof \nsystems to make them amenable to free.nement. However, enriching speci.cations and/or terms might help. \nThe Hoare logic example used enriched speci.cations to keep track of write and read sets. Consider again \nthe two problematic rules from before: succ(n) : N 3 n: N 2 pred(n) : N pred(succ(n)) : N provided positive(n). \nRule 2 can be accommodated by choosing S = { z , s , p }\u00d7{N}. Intuitively, the speci.cation ( s , N) \ntracks the fact that the outer\u00admost constructor is succ . The rule then becomes: n : ( s , N) 2 pred(n) \n: ( p , N) Rule 3 can be accommodated by choosing S = N \u00d7{N}. Then the sentence n : (i, N) tracks the \nfact that term n denotes the natural number i. The adapted rule is of the form A1 with n =1: n:(i, N) \n3 pred(n) : (i - 1, N) provided i> 0. In some cases it might be useful to enrich the term language. For \nexample, consider the rule of concurrent separation logic [3] that removes auxiliary commands (ghost \nassignments): G f{P}c{Q} AUXILIARY G f{P}c\\a{Q} provided a . aux(c) and a n (FV(P) . FV(Q)) = \u00d8. This \nrule is not of the form A1 or B1, because it contains a meta\u00adoperation in the conclusion. However, if \nthe meta-operation is turned into an explicit constructor (and speci.cations track auxil\u00adiaries), then \nthe rule is of the form B1 with m =1 and free.nement can handle it. To get an approximate idea of what \nwill happen when free\u00ad.nement is applied to a separation logic, consider the frame and concurrency rules: \n{P}c{Q} FRAME {P * R}c{Q * R} {P1}c1{Q1}{P2}c2{Q2} CONCURRENCY {P1 * P2}c1||c2{Q1 * Q2} A concrete setting \nand system will typically make syntactic restric\u00adtions on the commands in the triples. So the speci.cation \nstatement {P, Q} might contain more components, but free.nement will yield re.nement versions of the \nrules that look roughly as follows: FRAME {P * R, Q * R}e{P, Q} CONCURRENCY {P1 * P2,Q1 * Q2}e{P1,Q1}||{P2,Q2} \n4. Related Work In his work on re.nement for the lambda calculus, Denney [4] treats types as rudimentary \nspeci.cations and introduces a speci\u00ad.cation construct ?t for each type t . Conceptually, ?t corresponds \nto [G; t ] where the context G is left implicit. For example, con\u00adsider the term .x : s. ?t in the context \nG.The ?t inside the term corresponds to [G, x : s; t ]. Denney also considers richer speci.ca\u00adtions for \nlambda terms in his PhD thesis [5]. This results in a more powerful re.nement calculus in which speci.cation \nconstructs can contain logical assumptions.  The speci.cation statement x :[P, Q] of Morgan [8] is analo\u00adgous \nto x; Var : {P, Q}, since there is no restriction on the variables that the statement may read. However, \nhis speci.cation statement is a total correctness speci.cation, and the accompanying re.nement calculus \n[9] establishes total correctness. Similar re.nement cal\u00adculi for total correctness were proposed by \nBack [1, 2], Morris [10] and Hehner [6]. The books [2, 6, 9] contain many examples of how correct algorithms \ncan be constructed from their speci.cations via re.nement. Leino and Manohar [7] consider the join of \nMorgan s speci.ca\u00adtion statements x :[P1, Q1] and x :[P2, Q2], and mention several of its uses. Free.nement \nadds explicit constructors for joins, and re\u00adlies on the ability to join arbitrary terms from U in order \nto establish harmony. There is a relationship between observational equivalence of terms and the function \nSpecs, because |= V1 Sat gives rise to a notion of observability from the speci.cation point of view. \nIn particular, two terms t and t ' are observationally equivalent in this sense iff t ~ t ' ,where def \nt ~ t ' = Specs({t}) = Specs({t ' }) It is trivial to check that ~ is an equivalence relation. If |= \nV1 Sat is well-behaved, then t ~ t ' . [[t]] = [[t ' ]] (i.e. t ~ t ' . t = t ' )by Corollary 2.9 in \nthe Appendix and Theorem 6.1. Acknowledgments Van Staden was supported by ETH Research Grant ETH-15 10-1. \nCalcagno was partially funded by EPSRC. References [1] R.-J. Back. Correctness preserving program re.nements: \nProof theory and applications. Mathematical Centre Tracts, 131, 1980. [2] R.-J. Back and J. von Wright. \nRe.nement Calculus: A Systematic Introduction. Springer-Verlag, 1998. Graduate Texts in Computer Science. \n[3] S. Brookes. A semantics for concurrent separation logic. Theor. Comput. Sci., 375:227 270, April \n2007. [4] E. Denney. Simply-typed underdeterminism. Journal of Computer Science and Technology, 13:491 \n508, 1998. [5] E. Denney. A theory of program re.nement. Technical Report ECS\u00adLFCS-99-412, University \nof Edinburgh, 1999. [6] E.C.R.Hehner. A practical theory of programming. Springer-Verlag New York, Inc., \nNew York, NY, USA, 1993. [7] K. R. M. Leino and R. Manohar. Joining speci.cation statements. Theor. Comput. \nSci., 216(1-2):375 394, 1999. [8] C. Morgan. The speci.cation statement. ACM Trans. Program. Lang. Syst., \n10:403 419, July 1988. [9] C. Morgan. Programming from speci.cations (2nd ed.). Prentice Hall International \n(UK) Ltd., Hertfordshire, UK, 1994. [10] J. M. Morris. A theoretical basis for stepwise re.nement and \nthe programming calculus. Sci. Comput. Program., 9:287 306, December 1987. [11] M. J. Parkinson and G. \nM. Bierman. Separation logic, abstraction and inheritance. In POPL 08, pages 75 86, New York, NY, USA, \n2008. ACM. A. Antitone Galois Connections Lemma 1 established that an antitone Galois connection exists \nbetween the functions Specs and Terms: X . Terms(Y) . Y . Specs(X) (*) Theorems derived from this equivalence \ncome in pairs because of the symmetry between Specs and Terms. Here are a few well\u00adknown ones together \nwith their proofs: Corollary 2. 2.1 X . Terms(Specs(X)) 2.2 Y . Specs(Terms(Y)) 2.3 X . X ' . Specs(X) \n. Specs(X ' ) 2.4 Y . Y ' . Terms(Y) . Terms(Y ' ) 2.5 X . X ' . Terms(Specs(X)) . Terms(Specs(X ' )) \n2.6 Y . Y ' . Specs(Terms(Y)) . Specs(Terms(Y ' )) 2.7 Specs(Terms(Specs(X))) = Specs(X) 2.8 Terms(Specs(Terms(Y))) \n= Terms(Y) 2.9 Specs(X) . Specs(X ' ) . Terms(Specs(X)) . Terms(Specs(X ' )) 2.10 Terms(Y) . Terms(Y \n' ) . Specs(Terms(Y)) . Specs(Terms(Y ' )) 2.11 Specs(X . X ' ) = Specs(X) n Specs(X ' ) 2.12 Terms(Y \n. Y ' )=Terms(Y) n Terms(Y ' ) Proof. 2.1 In(*), instantiate Y with Specs(X). 2.3 X . Assumption X ' \n. 2.1 Terms(Specs(X ' )). In (*), instantiate Y with Specs(X ' ). 2.5 If X . X ' , then Specs(X) . Specs(X \n' ) holds by 2.3. The result follows from 2.4. 2.7 From 2.1 and 2.3 follows Specs(X) . Specs(Terms(Specs(X))). \nInstantiating Y with Specs(X) in 2.2 yields Specs(X) . Specs(Terms(Specs(X))). 2.9 . holds by 2.4. From \nTerms(Specs(X)) . Terms(Specs(X ' )) and 2.3, Specs(Terms(Specs(X))) . Specs(Terms(Specs(X ' ))). Specs(X) \n. Specs(X ' ) by 2.7. 2.11 Proof by indirect equality. For arbitrary Y: Y . Specs(X . X ' ) . {By (*)} \nX . X ' . Terms(Y)  . {Set theory}X . Terms(Y) . X ' . Terms(Y) . {By (*)}Y . Specs(X) . Y . Specs(X \n' ) . {Set theory}Y . Specs(X) n Specs(X ' )     \n\t\t\t", "proc_id": "2103656", "abstract": "<p>Freefinement is an algorithm that constructs a sound refinement calculus from a verification system under certain conditions. In this paper, a verification system is any formal system for establishing whether an inductively defined term, typically a program, satisfies a specification. Examples of verification systems include Hoare logics and type systems. Freefinement first extends the term language to include specification terms, and builds a verification system for the extended language that is a sound and conservative extension of the original system. The extended system is then transformed into a sound refinement calculus. The resulting refinement calculus can interoperate closely with the verification system - it is even possible to reuse and translate proofs between them. Freefinement gives a semantics to refinement at an abstract level: it associates each term of the extended language with a set of terms from the original language, and refinement simply reduces this set. The paper applies freefinement to a simple type system for the lambda calculus and also to a Hoare logic.</p>", "authors": [{"name": "Stephan van Staden", "author_profile_id": "81470654292", "affiliation": "ETH Zurich, Zurich, Switzerland", "person_id": "P2991326", "email_address": "Stephan.vanStaden@inf.ethz.ch", "orcid_id": ""}, {"name": "Cristiano Calcagno", "author_profile_id": "81100047402", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P2991327", "email_address": "c.calcagno@imperial.ac.uk", "orcid_id": ""}, {"name": "Bertrand Meyer", "author_profile_id": "81100570511", "affiliation": "ETH Zurich, Zurich, Switzerland", "person_id": "P2991328", "email_address": "Bertrand.Meyer@inf.ethz.ch", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103661", "year": "2012", "article_id": "2103661", "conference": "POPL", "title": "Freefinement", "url": "http://dl.acm.org/citation.cfm?id=2103661"}