{"article_publication_date": "01-25-2012", "fulltext": "\n Deciding Choreography Realizability Samik Basu Tev.k Bultan Meriem Ouederni Iowa State University University \nof California, Santa Barbara University of Malaga Email: sbasu@iastate.edu Email: bultan@cs.ucsb.edu \nEmail: meriem@lcc.uma.es Abstract Since software systems are becoming increasingly more concurrent and \ndistributed, modeling and analysis of interactions among their components is a crucial problem. In several \napplication domains, message-based communication is used as the interaction mecha\u00adnism, and the communication \ncontract among the components of the system is speci.ed semantically as a state machine. In the service-oriented \ncomputing domain such communication contracts are called choreography speci.cations. A choreography speci\u00ad.cation \nidenti.es allowable ordering of message exchanges in a distributed system. A fundamental question about \na choreography speci.cation is determining its realizability, i.e., given a choreog\u00adraphy speci.cation, \nis it possible to build a distributed system that communicates exactly as the choreography speci.es? \nChecking re\u00adalizability of choreography speci.cations has been an open prob\u00adlem for several years and \nit was not known if this was a decidable problem. In this paper we give necessary and suf.cient conditions \nfor realizability of choreographies. We implemented the proposed realizability check and our experiments \nshow that it can ef.ciently determine the realizability of 1) web service choreographies, 2) Sin\u00adgularity \nOS channel contracts, and 3) UML collaboration (commu\u00adnication) diagrams. Categories and Subject Descriptors \nD.2.4 [Software/Program Veri.cation]: [Formal Methods] General Terms Veri.cation Keywords Message-based \nInteractions, Choreography, Realiz\u00adability  1. Introduction Most software systems nowadays involve \nconcurrent or distributed behavior or both. They run concurrently on multi-core hardware, interact with \neach other over the network and access data and computational resources distributed over the compute \ncloud. An important concern in construction of concurrent and distributed software systems is the coordination \nof different components that form the whole system. In order to complete a task, components of a software \nsystem have to coordinate their executions by interacting with each other, and speci.cation and analysis \nof such interactions is a challenging problem. Message-based communication is a common interaction mecha\u00adnism \nused in concurrent and distributed systems where components Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation interact with each other by sending and receiving messages. Speci\u00ad.cation and analysis \nof message-based interactions has been an ac\u00adtive research area studied in several application domains \nincluding coordination in service-oriented computing [9, 37], interactions in distributed programs [2] \nand process isolation at the OS level [12]. A crucial problem in all these domains is the choreography \nreal\u00adizability problem. A choreography speci.cation identi.es the set of allowable message exchange sequences \namong the components (peers) of a distributed system. A choreography is realizable if there is a way \nto implement a set of components that conform to the choreography. Many message-passing systems use asynchronous \nmessag\u00ading [4, 23, 24, 28, 30] where components interact with each other by sending and receiving messages \nover unbounded FIFO chan\u00adnels. Even when the behavior of each component is modeled as a .nite state machine, \nif asynchronous communication is used, the state space of the overall system is in.nite. In fact, .nite \nstate systems communicating with unbounded FIFO communication channels are powerful enough to simulate \nTuring machines, and, hence, many veri.cation and analysis problems for them are un\u00addecidable [6]. Determining \nrealizability of choreography speci.ca\u00adtions for asynchronously communicating systems has been an open \nproblem for several years and it was not known if it is decidable. More precisely, the choreography realizability \nproblem is, given a choreography speci.ed as a .nite state machine, is it possible to determine if there \nexists a set of asynchronously communicat\u00ading (.nite) state machines that generate precisely the set \nof mes\u00adsage sequences speci.ed by the choreography speci.cation. Note that, given a set of asynchronously \ncommunicating (.nite) state machines, it is not possible to automatically determine the set of message \nsequences generated by them. However, in this paper we show that the realizability of a choreography \nspeci.cation is decid\u00adable, and we give a necessary and suf.cient condition for determin\u00ading realizability. \nThere have been earlier results in this area that provide suf.cient conditions for choreography realizability \n(e.g., [14, 18, 25]). To the best of our knowledge this is the .rst paper that identi.es a necessary \nand suf.cient condition and demonstrates the decidability of the choreography realizability problem. \nWe have also experimentally evaluated our approach by checking the realiz\u00adability of Singularity channel \ncontracts [12], web service choreogra\u00adphies [37] and collaboration diagrams [7]. Rest of the paper is \norganized as follows. In Section 2, to mo\u00adtivate our work, we discuss how the realizability problem arises \nin different domains. We also give a high level overview of the proposed approach. In Section 3 we formally \nde.ne the realizabil\u00adity problem by formalizing the communication contracts as .nite state conversation \nprotocols and a distributed system as a set of .\u00adnite state peers communicating via messages over FIFO \nmessage queues. In Section 4 we present our main results on realizability. on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute In Section 5 we discuss our implementation \nusing the CADP tool\u00adto lists, requires prior speci.c permission and/or a fee. box [17]. In Section 6 \nwe discuss the related work and in Section 7 POPL 12, January 25 27, 2012, Philadelphia, PA, USA. we \nconclude the paper. cCopyright &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. . . $10.00  ... <interaction \nname=\"SendOffer\" operation=\"offer\" channelVariable=\"tns:R1ToR2C\"> <participate relationshipType=\"tns:Hagglers\" \nfromRoleTypeDef=\"tns:R1\" toRoleType=\"tns:R2/> <exchange name=... action=\"sendOffer\"> <send var=\"cdl:getVar(\"offer\")/> \n</exchange> ... </interaction> Second, modeling and analyzing the global behavior of such dis\u00adtributed \nsystems is challenging since no single party may know the full details of all the components in such \na system. In the absence of detailed models for the distributed components that participate in such a \nsystem, the desired global behaviors have to be speci.ed as constraints on the interactions among different \ncomponents, since the messages exchanged among different components are the only observable global behavior. \nMoreover, for this type of distributed systems, it might be worthwhile to model the interactions among \ndifferent software components before the components are written. This type of top-down design may help \ndifferent organizations to better coordinate their development efforts. Choreography speci.cation languages \ntarget speci.cation of this type of interactions. For example, Web Services Choreogra\u00adphy Description \nLanguage (WS-CDL) [37] is an XML-based lan- R2 R1 o2 guage for describing the interactions among the \npeers participating in a composite web service. A choreography speci.cation in WS\u00ad Counter-Offer CDL \ncorresponds to a global ordering of the message-exchange  Offer  o1R1 R2 events among the peers participating \nin a composite service, i.e., a choreography speci.cation identi.es the set of allowable message a1R1 \nR2: sequences for a composite web service. Figure 1 presents a snap- R2 R1 a2 R1 R2 c1 shot of a WS-CDL \nspeci.cation for two services (behaving as R1, R2 R1 i.e., Role1 and R2, i.e., Role2) participating \nin a haggling process c2 where each service continues sending offers to the other until one of them \naccepts the offer or cancels the process. The speci.cation contains information regarding the roles, \ndescription of every ac\u00adtion in terms of the sender, receiver and the message content and type, and the \nordering (branching and sequencing) of actions. Accept Cancel Figure 1. Part of the WS-CDL choreography \nspeci.cation for a bilateral negotiation protocol [22] and the corresponding state ma\u00adchine.  2. Motivation \nand Overview In this section we motivate our work by describing four application domains where the choreography \nrealizability problem appears and, therefore, the results from this paper are directly applicable. 2.1 \nService Interactions: Choreography Speci.cations Service oriented computing provides technologies that \nenable mul\u00adtiple organizations to integrate their businesses over the Inter\u00adnet [13, 31]. Typical execution \nbehavior in such a distributed sys\u00adtem involves a set of autonomous peers1 interacting with each other \nthrough messages. For instance, consider a group of organizations that wish to integrate their online \nbusinesses. The front end that enables user interaction via web browsers may reside within one organization, \nhowever, in order to serve a user request, this front end may send and receive messages from software \ncomponents that reside in other organizations. The goal of web services standards and technologies is \nto facilitate this type of business to business integration. Modeling and analysis of interactions is \na crucial prob\u00adlem in this domain due to several distinguishing features of such systems. First, organizations \nmay not want to share the internal struc\u00adtures of their software components with other organizations \nthey intend to do business with. This type of decoupling requires stan\u00addardized and rich interface speci.cations \nthat enable integration of software components that may be written using different languages and implementation \nplatforms. In order to achieve such a decou\u00adpling among different components, it is necessary to specify \nthe interactions among different components without referring to the details of their local implementations. \n1 We use peer to denote a process/component/program/service that inter\u00adacts with other processes/components/programs/services. \n 2.2 Interactions Among Concurrent Processes: Singularity Channel Contracts Singularity is a new, experimental, \noperating system developed by Microsoft Research to explore new approaches to OS design [21]. One of \nits main goals is to improve the dependability of software systems by rethinking some design decisions \nthat have largely gov\u00aderned operating system architecture to date. Process isolation is a chief design \nprinciple of the Singularity operating system. To achieve this, certain constraints are enforced to ensure \nprocess in\u00addependence. Among these is the rule that processes cannot share memory with each other or \nthe kernel. All inter-process commu\u00adnication in Singularity, therefore, occurs via message-passing over \nbidirectional conduits, called channels. Channels have two end points referred to as the client and the \nserver. The client and the server processes use the channel to communicate with each other by sending \nand receiving messages. Communication through Singularity channels corresponds to asyn\u00adchronous communication \nvia FIFO queues. In Singularity, each channel is governed by a channel con\u00adtract [12, 33]. A channel \ncontract is basically a state machine that speci.es the allowable ordering of messages between the client \nand the server. Hence, channel contracts serve the same purpose that choreography speci.cations serve \nin service-oriented computing. Singularity processes are written in an extension of C# called Sing#. \nIt provides constructs for writing channel contracts and its compiler statically checks that the processes \ncommunicating over a channel conform to its contract. Figure 2 presents a simpli.ed version of a Sing# \ncontract governing a channel used by Singularity for interacting with a keyboard device. This contract \nde.nes three states (Start, Ready,and Waiting) and the evolution among states (->) correspond to message \nexchanges. Singularity contracts are written from the perspective of the server, where send actions by \nthe server are appended with ! to denote communication from the server to the client and receive actions \nby the server are appended with ? to denote communication from the client to the server. public contract \nKeyboardDeviceContract { state Start: { Success! -> Ready; } state Ready: { GetKey? -> Waiting; PollKey? \n-> (AckKey! or NakKey!) -> Ready; } state Waiting: { AckKey! -> Ready; NakKey! -> Ready; } } Start S \n--> C S --> C  AckKey S --> CSuccess AckKey C --> S C --> SGetKey PolKey Waiting Ready Ready$0  S --> \nC S --> C NakKeyNakKey Figure 2. A simpli.ed channel contract from the Singularity OS for keyboard interaction \nwritten in Sing# [33] and the correspond\u00ading state machine. +NAME(\"IRC SERVER\") ... +STATE start logon() \n=> ok() &#38; active | error() &#38; stop +STATE active ls() => files() &#38; active getFile() => fileSent() \n&#38; active | noFileErr() &#38; stop ... start C S logon S C S error stop C SS files getFile fileSent \n S C nofileErr Figure 3. Part of a communication contract for a distributed Er\u00adlang program written \nin UBF(B) [2] and the corresponding state machine. 2.3 Interactions Among Distributed Components: UBF(B) \nContracts Erlang is a general purpose concurrent programming language that was developed initially at \nEricsson for improving the dependability of telephony applications [3]. In Erlang, processes do not share \nmemory and only interact with each other via exchanging messages asynchronously. UBF(B) is a language \nfor specifying communication contracts in distributed Erlang programs [2]. Figure 3 presents partial \nspec\u00adi.cation of a IRC server interface speci.cation and describes the evolution of the server from one \nstate (start, active, etc.) to an\u00adother in response to external stimuli (logon, ls, etc.). UBF(B) con\u00adtracts \nare based on .nite state machines. Given a state (e.g., start), a transition from that state identi.es \na request-response sequence where, after receiving a message (e.g., logon), the process sends a response \n(e.g., ok) and moves to the destination state (e.g., active). 2.4 Visual Interaction Speci.cations: Collaboration \nDiagrams Collaboration diagrams (called communication diagrams in [36]) provide a convenient visual formalism \nfor specifying the interac\u00adtions among the participants of a distributed system [7, 8]. A col\u00adlaboration \ndiagram is a visual representation of a set of peers, a set of communication links among them, and an \nordering of the mes\u00adsage exchanges among the peers. Unlike MSCs [29], collaboration diagrams specify \nthe global ordering of send events rather than the local ordering of send and receive events. The semantics \nof collabo\u00adration diagrams can be formalized as a state machine characterizing all allowable ordering \nof message exchanges in a distributed system [8]. Hence, for example, collaboration diagrams can be used \nas a vi\u00adsual formalism for representing web service choreographies. 2.5 Overview of the Proposed Approach \nWeb service choreography speci.cations, Singularity channel con\u00adtracts, UBF(B) contracts and collaboration \ndiagrams are all differ\u00adent mechanisms for specifying ordering of messages exchanged among a set of concurrent \nor distributed processes. Analysis of message-based interactions is an essential problem for all these \nlanguages. And, although these languages target different applica\u00adtion domains, the interaction analysis \nproblem remains the same. In short (a) communication contract speci.cations cut across a wide range of \napplication domains (service-oriented computing, new paradigms for OS, embedded systems); (b) communication \ncon\u00adtracts are used to specify message-based interactions among peers (services, client/servers, real-time \nsoftware); and, .nally, (c) one key problem for communication contracts used in each of these application \ndomains is to check whether a given communication contract can be realized. In this paper we present \na necessary and suf.cient condition for realizability and show how it can be applied to multiple domains. \nIn our approach, we .rst translate communication contracts speci.ed in different languages into a conversation \nprotocol which is a .nite state machine that speci.es the allowable sequences of messages (i.e., conversations) \namong a set of peers. For instance, the state ma\u00adchine shown in Figure 1 (oi:offer, ai: acceptance and \nci: cancella\u00adtion sent by Ri) is the conversation protocol for the corresponding WS-CDL choreography \nspeci.cation. We label the transitions of the conversation protocols with Sender . Receiver:Msg, denoting \nthe sending of message Msg from the Sender peer to the Receiver peer. The state machines shown in Figures \n2 and 3 are the conversa\u00adtion protocols for the corresponding Sing# channel contract and the UBF(B) communication \ncontract speci.cations, respectively. In the following section we give a formal de.nition of conversation \npro\u00adtocols. In order to analyze realizability of conversation protocols, we also need a formal model \nof distributed systems that interact with messages. We model such systems as a set of peers, where the \nbe\u00adhavior of each peer is speci.ed as a .nite state machine. We assume that each peer has a FIFO message \nqueue that stores messages sent to it by the other peers. When a peer executes a send transition, the \nsent message is appended to the message queue of the receiving peer. A peer can only execute a receive \ntransition if the transition matches the message at the head of its receive queue. When a peer executes \na receive transition, the message at the head of its receive queue is removed. The behavior of the overall \nsystem is de.ned by interleaving the executions of peers. A conversation protocol is said to be realizable \nif and only if there exists a set of peers whose interactions conform to the con\u00adtract. Note that, by \ninteractions we mean send sequences (i.e., con\u00adversations); the receive actions occur locally when a \npeer consumes a message from its own message-queue. This is in contrast to the earlier work on realizability \nof MSCs (for example in [1, 35]) where both the send and receive actions are considered. The realizability \nproblem MSC-graphs is undecidable. It is not immediately clear if ignoring the receive actions simpli.es \nthe realizability problem, since the basic formal model we are looking at involves peers that are interacting \nin an asynchronous fashion, and each peer is as\u00adsumed to have a receive-queue of unbounded size. As a \nresult, the state space of the global system consisting of multiple peers may be in.nite. The main result \nwe present in this paper is that choreography realizability problem is decidable which has been an open \nproblem for several years. We provide a necessary and suf.cient condition for realizability which states \nthat a choreography speci.cation is realizable if and only if its behavior is language equivalent to \nthe 1-bounded system of asynchronously communicating peers, where each peer behav\u00adior is obtained from \nthe projection of the choreography (on each peer) and where each peer has a message queue of size 1 (equiv\u00adalence \ncondition); and  the 1-bounded system satis.es a speci.c temporal property (well-formedness condition). \n Since the choreography speci.cation and the 1-bounded system both have .nite state spaces, we were \nable to implement an au\u00adtomated choreography realizability checker using existing equiva\u00adlence checking \nand model checking tools.  3. Conversations &#38; Realizability We formalize choreography speci.cations \nusing conversations and conversation protocols (Section 3.1), de.ne distributed systems with asynchronous \ncommunication (Section 3.2), and present dif\u00adferent variations of choreography realizability (Section \n3.3). 3.1 Conversations We use state machines to characterize conversation protocols, peer behaviors \nand distributed systems that consist of asynchronously communicating peers [14]. DEFINITION 1 (Conversation \nProtocol). A conversation protocol C is represented by C =(P,SC ,s0 ,L, .c) where P is a .nite set C \nof peers, SC is a .nite set of states, s0 . C is the initial state, L is a .nite set of message labels \nand, .nally, .c . SC \u00d7P\u00d7 L \u00d7P\u00d7 SC is the transition relation. A transition of the form CC (si ,P, m,P \n',sj ) . .c represents the sending of message m from P to P ' (P, P ' .P). Figures 1, 2 and 3 present \nthe communication contracts from three different domains and the corresponding conversation protocols. \nThe start states are denoted by an incoming arrow without a source state. Each transition is labeled \nwith a message along with the sender and the receiver of the message. We denote the transition P .P I \nlabels as m ,where m is the message being sent by P to P '.  3.2 Systems DEFINITION 2 (Peer Behavior). \nThe behavior B of a peer P is a .nite state machine (M, T, t0,d) where M is the union of input (Min) \nand output (Mout) message sets, T is the .nite set of states, t0 . T is the initial state, and d . T \n\u00d7 (M .{E}) \u00d7 T is the transition relation. A transition t . d can be one of the following three types: \n(1) a send-transition of the form (t1, !m1,t2) which sends out a message m1 . Mout, (2) a receive-transition \nof the form (t1, ?m2,t2) which consumes a message m2 . Min from peer s input queue, and (3) an E-transition \nof the form (t1,E,t2). We write t -a' to . tdenote that (t, a, t') . d. Figure 4 illustrates the behaviors \nof two communicating peers P1 and P2 with send and receive actions a, b and c. DEFINITION 3 (System Behavior). \nGiven a set of peers P = {P1,...,Pn} with Bi =(Mi,Ti,t0i,di) denoting the behavior = Min . Mout of Pi \nand Mii i such that .i : Min n Mout -ii = \u00d8, = j . Min n Min = Mout n Mout -.i, j : i iji j = \u00d8, a \nsystem behavior or simply a system over P is denoted by a state machine (possibly in.nite state) I =(P,S, \ns0,M, .) where 1. M = .iMi 2. S .Q1 \u00d7 T1 \u00d7Q2 \u00d7 T2 ... Qn \u00d7 Tn such that .i . [1..n]: Qi . (Min) *  \ni 3. s0 . S such that s0 =(E, t01,E,t02 ...,E,t0n); and 4. . . S \u00d7 [(P\u00d7 M \u00d7P) .{E}] \u00d7 S, and for s =(Q1,t1,Q2,t2,...Qn,tn) \n. S and  '''' s=(Q1',t1,Q2',t2,...Q',tn) . S n m Pi.Pj n Min (a) s - ----. s' . . if .i, j . [1..n]: \nm . Mi out j , !m ' (i) ti - . ti . di, (ii) Q'j = Qjm, (iii) .k . [1..n]: k = ' j . Qk = Q' k = tk k \nand (iv) .k . [1..n]: k= i . t [send action] ?m' (b) s -' . . if .i . [1..n]: m . Mi in (i) ti - i . \ndi, . s. t (ii) Qi = mQ' = Qk'and i, (iii) .k . [1..n]: k= i . Qk ' (iv) .k . [1..n]: k k = tk= i . t \n[receive action] (c) s -' . . if (i) .i . [1..n]: ti . ti . di, (ii) .k . . s- ' and (iii) .k . [1..n]: \nk= i . t [1..n]: Qk = Q'k k = tk [internal action] The above de.nition states that peers in the system \ncommunicate in an asynchronous fashion. Each peer has an unbounded message queue (Qi) and a message sent \nto a peer gets inserted to the tail of the queue, while a message consumed by a peer is consumed from \nthe head of its message queue. Note that, send actions involve two peers, the peer sending the message \nand the message queue of the receiver peer; on the other hand, the receive action is local and involves \nonly the receiver peer. The behavior of the system depends on the order the send and receive actions \nas well as the size of the message queues associated with each peer participating in the system. In the \nfollowing, we de.ne k-bounded systems, where each participating peer has a message queue of size k. The \nsend actions in such a system is blocked if the receiver peer s message queue is full (i.e., contains \nk pending messages to be consumed). DEFINITION 4 (k-bounded System). A k-bounded system (denoted by Ik) \nis a system where the length of message queue for any peer is at most k. The description of k-bounded \nsystem behavior is, therefore, realized by augmenting condition 4(a) in De.nition 3 to include the condition \n|Qj| <k,where |Qj | denotes the length of the queue for peer j. Figure 4 illustrates the behavior of \nI1 obtained from the two peers P1 and P2 with asynchronous communication. For brevity, we only show the \ntransitions that involve send actions. We also de.ne synchronous behavior of a system where every send \naction by a peer is consumed immediately by a receiver peer, i.e., the peers interact synchronously. \nThis can be viewed as the case where the peers do not have any message queues. DEFINITION 5 (Synchronous \nBehavior). Given a set of peers P = {P1,...,Pn} with Bi =(Mi,Ti,t0i,di) denoting the behavior of = Min \n. Mout Pi and Mii i , such that in n Mout -.i : Mii = \u00d8, n Min = Mout n Mout -.i, j : i = j . Min = \n\u00d8, iji j the synchronous system behavior containing the peers in P is denoted by a state machine I0 =(P,S, \ns0,M, .) where 1. M = .iMi 2. S . T1 \u00d7 T2 \u00d7 ... \u00d7 Tn 3. s0 . S such that s0 =(t01,t02 ...,t0n); and \n 4. . . S\u00d7[(P\u00d7M\u00d7P).{E}]\u00d7S and for s =(t1,t2,...,tn) .  ''' ' S and s =(t1,t2,...,tn) . S m Pi.Pj ' n \nMin (a) s ------. s . . if .i, j . [1..n]: m . Mi out j ,(i) !m?m ti - . t ' i . di, (ii) tj - . t ' \nj . dj , (iii) .k . [1..n]: k = i . k = j . t ' k = tk [synchronous send-receive action] (b) s -s ' . \n. if .i . [1..n] (i) ti . ti ' . di, (ii) .- .k . [1..n]: k = i . tk ' = tk [internal action] The synchronous \ncomposition of behaviors B1 and B2 of peers P1 and P2, respectively, in Figure 4 would have a structure \nthat is iden\u00adtical to B2, with one branch having transitions a P2.P1 , followed by bP1.P2 , followed \nby c P1.P2 ; and the other branch having tran\u00adsitions a P2.P1 , followed by c P1.P2 , followed by bP1.P2 \n. PROPOSITION 1. The synchronous system behavior containing a set of peers P = {P1, ...,Pn} with peer \nbehaviors Bj (1 = j = n) where each peer behavior Bj (1 = j = n) is deterministic, is also deterministic, \ni.e., the labels on any pair of outgoing transi\u00adtions from a state are distinct. Any peer behavior with \n.nite state\u00adspace can be determinized and a system I (resp. Ik, k = 0) ob\u00adtained by determinizing the \npeer behaviors is denoted by DETER(I) (resp. DETER(Ik)). Finally, we de.ne the concept of well-formed \nsystems. DEFINITION 6 (Well-formed System). A system containing a set of peers P = {P1,P2,...,Pn} with \npeer behaviors Bj (1 = j = n) is said to be well-formed if and only if every message sent by any peer \ncan be eventually consumed along some path in the system by the receiver of the message. This can be \nexpressed precisely in temporal logic CTL [10] as AG(|Qi| > 0 . EF(|Qi| =0)) (1) The property states \nthat whenever the size of the receive queue, Qi, of the i-th peer is greater than 0 (i.e., Qi is non-empty), \nthe system can eventually move to a state where Qi is empty. All synchronous systems, I0, are well-formed \nby de.nition. For all k-bounded asynchronous systems, it can be automatically veri.ed (via model checking) \nwhether the system is well-formed or not. Any k-bounded system has .nite state-space; one can model check \nsuch a system against the CTL property (Equation 1). If a system Ik is well-formed, we say that WF(Ik). \nNote that, well-formedness checking for asynchronous systems (where mes\u00adsage queues are unbounded) is \nundecidable in general. 3.3 Realizability We consider two variations of realizability. We refer to these \nvaria\u00adtions as Realizability. and Realizability.. DEFINITION 7 (Realizability). A conversation protocol \nC de.ned over a set of peers P = {P1,P2, ...,Pn} is said to be realizable according to Realizability. \nor Realizability., if and only if there exists some peer behaviors Bj (1 = j = n) and a system I de.ned \nusing these behaviors, such that Realizability.: for all i = 0, C is equivalent to Ii and WF(Ii),or Realizability.: \nC is equivalent to I and WF(I) respectively. Realizability. requires the existence of a system such \nthat its be\u00adhaviors for all possible receive queue sizes are equivalent to C. Realizability. requires \nthe existence of a system such that its be\u00adhavior is equivalent to C when unbounded receive queues are \nused. Note that, the above variations, Realizability. and Realizability., require the equivalence between \nthe conversation C, and the sys\u00adtem(s) Iisand I, respectively. We consider language equivalence, which \nensures that any linear temporal logic property satis.ed by the conversation protocol is also satis.ed \nby the system that realizes the conversation. Earlier work [14, 18] on choreography realizabil\u00adity has \nfocused on language equivalence and Realizability.,where suf.cient conditions for determining Realizability. \nhave been pro\u00advided. It may appear that Realizability. is a stronger notion com\u00adpared to Realizability. \nin the sense that if C is realizable ac\u00adcording to Realizability. then it is also realizable according \nto Realizability.. However, we show in this paper that Realizability. and Realizability. are equivalent. \n3.3.1 Language Equivalence &#38; Preorder Language Equivalence. For a conversation protocol, the alpha- \nP .P I ' bet is S= .{m },where P , P are peers in the conversation P .P I and m is a send action (De.nition \n1). We denote the language of a conversation C as L(C), which contains any sequence over S from the start \nstate. For example, the language of the conversation R1.R2 in Figure 1 includes a sequence where o1 \nis eventually fol-R2.R1 lowed by a2 and in between there are .nite number of subse-R2.R1 R2.R1 quences \nof the form o2 o1 . For a peer behavior, the alphabet is S= Min . Mout,where Min and Mout are receive \nand send actions of the peer respectively (De.nition 2). We denote the language of a behavior B of a \npeer P as L(B). For example, in Figure 4, the behavior B1 of P1 includes the sequence ?a!b!c in its language. \nP .P I For a system, the alphabet is S= .{m },where P , P ' P .P I are peers participating in the system \nand m is a send action in the behavior of peer P (De.nition 3). We denote the language of a system I \n(resp. Ik)as L(I) (resp. L(Ik)). For example, the language of the system I1 in Figure 4 includes the \nsequence P2.P1 bP1.P2 c P1.P2 a . Based on the De.nition 7, language realizability requires that L(C)= \nL(Ii) for all i = 0 for Realizability. and L(C)= L(I) for Realizability.. Ordering. We also require the \nconcept of an ordering between systems, conversations and peers in terms of their language. Order\u00ading \nwith respect to language can be easily obtained using the subset relation.   4. Deciding Realizability \nIn this section, we prove that determining realizability is decidable, present the necessary and suf.cient \ncondition for checking realiz\u00adability of a given conversation protocol and show that this condition can \nbe ef.ciently computed using existing techniques for equiva\u00adlence checking and model checking. We prove \nthat a conversation protocol C is realizable if and only if it is realized by a well-formed system obtained \nfrom peer projections of C. We de.ne the peer pro\u00adjection of a conversation protocol as follows. DEFINITION \n8 (Peer Projection). The projection of a conversation protocol C on one of the peers P , participating \nin the conversation, is denoted by C.P and is obtained from C by performing the follow\u00ading updates to \nthe state machine describing C. P .P I if a transition label is m then replace it with !m, P I.P if a \ntransition label is m then replace it with ?m, otherwise, replace transition label with E. We denote \nthe synchronous, k-bounded asynchronous and un\u00adbounded asynchronous systems obtained from the peer projections \nof C by I0 C , Ik C and IC, respectively. For example, Figure 5 presents a conversation protocol C and \nits projections to peers P1 and P2. Next, we proceed by .rst considering Realizability. (Sec\u00adtion 4.1) \nfollowed by Realizability. (Section 4.2), and .nally sum\u00admarize our .ndings in Section 4.3. 4.1 Deciding \nRealizability. In this section, by realizability, we mean Realizability., unless otherwise mentioned. \nThe following outlines the steps of the proof establishing the decidability of realizability. Outline. \n1. Behavioral Ordering. We prove that if the conversation pro\u00adtocol C is equivalent to DETER(I0 C),then \nDETER(I0 C) is the smallest system with synchronously communicating peers that is language equivalent \nto C. [Theorem 1]. 2. Synchronizability Checking. The conversation protocol C is re\u00adalizable according \nto Realizability. if and only if it is equiva\u00adlent to Ii for all i = 0,and Iis are well-formed (see De.ni\u00adtion \n7). That is, C is equivalent to Ii irrespective of the size i of the receive queues. We use the concept \nof synchronizability of a system. A system is synchronizable if and only if the system behavior (over \nsend actions) remains unaltered for any receive queue size. We show that .i = 0, Iis are equivalent to \nI, i.e., I is synchronizable, if and only if I0 is equivalent to I1.[The\u00adorem 2]. 3. Well-formedness \nChecking. Realizability also requires that the system that realizes the conversation must be well-formed. \nWe present the conditions when the synchronizable systems are well-formed; speci.cally, we prove that \na synchronizable sys\u00adtem I is well-formed if and only if I1 is well-formed [Theo\u00adrem 3]. Finally, we \nshow that deterministic synchronizable sys\u00adtems are always well-formed [Theorem 4]. 4. Realizability. \nChecking. Finally, using the above theorems, we obtain that the conversation C is realizable if and only \nif DETER(IC) is synchronizable and well-formed, and C is equivalent to DETER(IC). This statement holds \nif and only if C is equivalent to DETER(I1 C). (Recall that DETER(IC) denotes the system over peer behaviors \nobtained by determinizing the projection of C over peers). As both, C and I1 C are .nite state systems, \nveri.cation of equivalence can be done effectively. [Theorem 5]  4.1.1 Language-based Ordering For \nthe step 1 noted above, we discuss certain ordering properties of the systems, conversations and peer \nbehaviors, to qualify what we mean by the smallest system with synchronously communicating peers. PROPOSITION \n2. .C : L(C) .L(I0 C) and .i = 0: L(Ii) .L(Ii+1) Proof: The proof follows from the following observations. \nThe peers in I0 C are obtained from projections of C. Therefore, any path (in terms of send actions) \nfrom any state in C is also present in I0 C . Any Ii+1 can replicate the behavior (in terms of send actions) \nof Ii by avoiding the paths that occur due to the usage of message queues of length i +1. D DEFINITION \n9. Let P = {P1,P2,...,Pn} be a set of peers. Let I0 be a synchronous system obtained from the peer-behaviors \nBi, 1 = i = n; and I0 ' be a synchronous system obtained from the peer-behaviors Bi' , 1 = i = n. We \nsay that I0 =L I0 ' if and only if .i = 1,i = n : L(Bi) .L(Bi' ). In the above, we de.ne the ordering \nrelations =L between systems based on the ordering between the behaviors of the corresponding peers that \nconstitute the respective systems. PROPOSITION 3. Let P = {P1,P2,...,Pn} be a set of peers. Let I0, Ik, \nI denote the synchronous, k-bounded asynchronous and unbounded asynchronous systems, where the i-th peer-behavior \nis Bi for 1 = i = n; and I0' , Ik' , I ' denote the corresponding systems, where the i-th peer-behavior \nis Bi ' for 1 = i = n. I0 =L I0 ' ' '' . [L(I0) .L(I0) .L(Ik) .L(Ik) .L(I) .L(I )] Proof: The proof \nfollows from the De.nitions 3, 4, 5 and 9. I0 =L I0 ' implies that the the language of any peer s behavior \nin I0 is a subset of the language of the corresponding peer s behavior in I0 ' (De.nition 9), i.e., any \nsequence of the i-th peer behavior in I0 is also present in the i-th peer behavior in I0' . As a result, \nfrom De.nition 5, L(I0) .L(I0' ). D THEOREM 1. Given a conversation protocol C over a set of peers P, \nthe following holds for all synchronous systems I0 de.ned over a set of peer behaviors for the peers \nin P. L(C)= L(DETER(I0 C)) . [.I0 :(L(C)= L(I0) . DETER(I0 C) =L I0)] Proof: Assume that there exists \nan I0 such that L(C)= L(DETER(I0 C)) = L(I0) and DETER(I0 C) =L I0. Let the be\u00adhaviors of the i-th peer \nin DETER(I0 C) and I0 be Bi and Bi' ,re\u00adspectively. Note that, Bi s are deterministic in DETER(I0 C). \nTherefore, there exists an i such that L(Bi) .L(Bi' ) (De.ni\u00adtion 9). That is, there exists at least \none path in Bi, which is not present in Bi' . Recall that, Bi is C.Pi and is determinized; each path \nin Bi corresponds to at least one path in C (De.nition 8). Therefore, absence of a path in Bi ' implies \nat least one of the paths in C is not realizable using I0. This results in contradiction. D 4.1.2 Synchronizability \nChecking As mentioned in the outline (item 2), a conversation C is realizable according to Realizability. \nif and only if it is equivalent to systems Ii,for all i = 0. The following theorem due to [5] establishes \n  !a ?a !a  !c ?c ?b !c !b?c ?b !b      B1 B2 a P2->P1 a P2->P1 cP1->P2 bP1->P2  P1->P2 cP1->P2 \nP1->P2 b  I1 Figure 4. Two peer behaviors that are language synchronizable. the necessary and suf.cient \ncondition under which the behaviors of .i = 0: Ii are language equivalent. This is referred to as the \nsynchronizability condition. THEOREM 2. I is language synchronizable (i.e., .i = 0: L(Ii)= L(Ii+1)) and \nonly if L(I0)= L(I1). Consider the behaviors B1 and B2 of peers P1 and P2, respec\u00adtively, in Figure 4. \nThe synchronous system I0 obtained from these peers has a behavioral structure similar to that of B2;there \nare two non-deterministic branches along which a is sent from P2 to P1. Along one branch, b is communicated \nbefore c and in the other branch, c is communicated before b.The 1-bounded asynchronous behavior, on \nthe other hand, (see Figure 4) allows all possible or\u00addering for communicating b and c along both the \nnon-deterministic branches. The languages of I0 and I1 are identical. Therefore, the system obtained \nfrom P1 and P2 is language synchronizable.  4.1.3 Language Synchronizability &#38; well-formedness We \npresent the condition under which a language synchroniz\u00adable system is well-formed (see item 3 of outline \nof proof above for Realizability.). We also use this result in the context of Realizability. (see Section \n4.2). THEOREM 3 (Synchronizability &#38; well-formedness). Asynchro\u00adnizable system I is well-formed if \nand only if I1 is well-formed. Proof: It is immediate that I is well-formed implies that .i = 0: Ii is \nwell-formed. For proving the other direction, assume that I is synchronizable, WF(I1) and \u00acWF(I). Therefore, \nthere exists a k> 1 such that \u00acWF(Ik), and there exists a path in Ik over a sequence of states Pi.P I \ni i t0,t1,...,tl,tl+1, with 0 = i = l : tim =. ti+1,and the message ml is never consumed by peer Pl ' \n. Recall that, as I is language synchronizable, any sequence of send actions in Ik is also present in \nI1. From these observations, we iteratively construct a path in I1. 1. We denote the sequence of send \nactions causing violation of Pl.P I well-formedness in Ik as .ml l . Consider the path in the behavior \nof peer Pl ' over the sequence of local states identical to the local states of Pl ' in the sequence \nt0,t1,...,tl in Ik. 2. As I is synchronizable, consider a path over a sequence of '' '' states t0,t1,...,tl,tl+1 \nin I1 that results in the same sequence Pl.P I of send actions .ml l , and where all send actions are \nimmediately consumed by the receiver peer. Such a path is possible as I0, I1 and Ik contain identical \nsequences of send actions. Note that, this path in I1 is well-formed. Consider the path in the behaviors \nof all peers other than Pl ' over the sequence of local states that are identical to their local '' ' \nstates in the sequence t0,t1,...,tl. 3. Construct a path in the system by considering the local states \nof Pl ' (item 1 above), the local states of all other peers (item 2 above), and proceed by sequentially \nmatching the send action Pl.P I sequence .ml l . In this path, if at any point a transition results in \na message sent from a sender peer Ps to a receiver peer Pr whose receive queue contains one message (to \nbe consumed), we delay this transition by moving ahead some transition that occurs after it (shuf.e) \nand does not involve the peers Ps and Pr. Pl.P I (a) Given the sequence .ml l , if the above shuf.e oper\u00adPl.P \nI ation can be performed till the action ml l , then a new path is obtained along which none of the \nreceive queues con\u00adtain more than one pending message to be consumed, i.e., a path in I1 is obtained. \nFurther note that, as we have con\u00adsidered the path of Pl ' , where it does not consume the last message \nml, I1 is not well-formeded. That is, when I is synchronizable, \u00acWF(I) .\u00acWF(I1). (b) Consider that such \nshuf.ing (item 3 above) can be per\u00ad  Pl.P I formed on the pre.x .1 (such that .1 .2 b.3 ml l = Pl.P \nI .ml l ), after which the shuf.e operation of moving b before .2 is not possible, without allowing at \nleast one peer s receive queue to hold more than one message. In the above, .1, .2 and .3 are sequences \nof send actions. Let the shuf.ing of .1 resulted in a new sequence .1' .Observe Pl.P I l that, .1 ' b.2 \n.3 ml is a sequence in Ik and it not well\u00ad formeded. Repeat the above steps starting from item 2 with \nPl.P I l this new sequence .1 ' b.2 .3 ml . Note that in new it\u00aderation we are still considering the \nsame path in peer Pl ' (item 1 above); but considering new paths for all peers other than Pl ' . The \nnew paths will ensure that till .1' , all send ac\u00adtions are immediately received making room for at least \none more send action (i.e., b) to be performed without forcing any peer s receive queue to contain more \nthan 1 message. As I is synchronizable, the above iteration will always ter\u00adminate in Step 3a, proving \nthat when I is synchronizable, \u00acWF(I) .\u00acWF(I1). D THEOREM 4 (Determinism, Synchronizability &#38; well-formedness). \nA synchronizable system I consisting of deterministic peers is well\u00adformed. Proof: A system is synchronizable \nand consists of deterministic peers imply that L(I0)= L(I1) and I1 is deterministic. Assume that, I1 \nis not well-formed. There exists a sequence of send actions . = m0m1 ...m... which leads to a state \nt from where a message m is never consumed. Due to synchronizability, the same sequence of send actions \nis also present in I0 where each message sent is immediately consumed. A similar path is present I1, \nwhere every send action is immediately followed by the corresponding receive action, resulting in the \nsame sequence of send actions .. Recall that, all peers are deterministic. Therefore, I1 cannot contain \ntwo different paths with the same send sequence .; where one path leads to a state from where m is never \nconsumed, and in the other all sent messages are consumed. In other words, a deterministic I1 containing \ndeterministic peers is well-formed. From Theorem 3, the corresponding system I is well\u00adformed, and therefore, \n.i = 0: WF(Ii) also holds. D  4.1.4 Deciding Language Realizability. Based on the above theorems and \npropositions, we now proceed to present the necessary and suf.cient conditions for language realizability \naccording to Realizability.. THEOREM 5. C is language realizable following Realizability.. [L(C)= L(DETER(I1 \nC))] Proof: To prove: C is language realizable according to Realizability. implies L(C)= L(DETER(I1 C)). \nAssume that C is language realizable and L(C)= L(DETER(I1 C)) i.e., L(C) .L(DETER(I1 C)) (Proposition \n2) As C is language realizable according to Realizability., there exists a I such that .i = 0: L(C)= \nL(Ii). Therefore, I is synchroniz\u00adable, i.e., L(C)= L(I0) .L(C)= L(I1) (From Theorem 2). We .rst establish \nthat for C to be realizable, L(C) must be identical to L(DETER(I0 C)) (or L(I0 C); determinizing peers \ndoes not alter the language of the system). Assuming L(C)= L(I0 C), from Proposition 2, we have L(C) \n. L(I0 C). This implies that there exists a speci.c ordering of send actions involving two independent \npairs of peers. In other words, C P1.P2 has a state from where a is followed by bP3.P4 ,and Pi s P1.P2 \nare distinct and the reverse order bP3.P4 followed by a is not allowed from the same state in C. Such \na conversation C cannot be realized by any system as the send actions a and b are independent, and any \nspeci.c ordering required by C cannot be obtained. Therefore, if C is realizable then L(C)= L(I0 C)= \nL(DETER(I0 C)). From Theorem 1, it follows that DETER(I0 C) =L I0.This implies that .i : L(Bi) .L(Bi' \n),where Bi and Bi ' denote the behavior of the i-th peer in DETER(I0 C) and I0, respectively. (Recall \nthat in DETER(IC), the peer behaviors are determinized, i.e., Bi is deterministic.) Proceeding further, \nfrom Proposition 3, we have L(DETER(I1 C)) .L(I1). This leads to a contradiction as we have assumed L(C)= \nL(I1) and L(C) .L(DETER(I1 C)). Therefore, C is realizable according to Realizability. implies L(C)= \nL(I1)= L(DETER(I1 C)), and note that, DETER(I1 C) is well-formed (Theo\u00adrem 4). Next, L(C)= L(DETER(I1 \nC)) .L(C)= L(DETER(I0 C)) = L(DETER(I1 C)) . WF(DETER(I1 C)) (Proposition 2) . .i = 0: L(C)= L(DETER(Ii \nC)) . WF(DETER(Ii C)) (Theorems 2, 3, 4) . C is language realizable according to Realizability. (De.nition \n7)  D P1->P2 aP1->P2 a  P2->P1 cP2->P1 P2->P1 b b  C !a !a ?a ?a   ?c ?b !c !b ?b !b  \nB1 B2  P1->P2  !a ?a a P2->P1 ?c !c P2->P1 c ?b !b b  DETER(B1) DETER(B2) DETER(I) Figure 5. A conversation \nprotocol that is language realizable ac\u00adcording to Realizability.. Consider the conversation speci.cation \nC in Figure 5. The sys\u00adtem behavior DETER(I) (irrespective of the receive queue size) based on peers \ndeterminized behaviors (DETER(B1),DETER(B2)) is language equivalent to C and is WF(DETER(I)). Therefore, \nC is language realizable according to Realizability..  4.2 Deciding Language Realizability. THEOREM \n6. C is language realizable following Realizability.. [L(C)= L(DETER(I1 C))]. Proof: The proof proceeds \nby showing the equivalence between Realizability. and Realizability.. C is language realizable following \nRealizability. . .i = 0: L(C)= L(Ii) . WF(Ii)(De.nition 7) . L(C)= L(DETER(I1 C)) (Theorem 5) . L(C)= \nL(DETER(I1 C)) . WF(DETER(IC))(Theorem 4) . L(C)= L(DETER(IC)) . WF(DETER(IC))(Theorem 2) . .I : L(C)= \nL(I) . WF(I) . C is language realizable following Realizability.  Therefore, from Theorem 5, C is \nlanguage realizable following Realizability.. [L(C)= L(DETER(I1 C))]. D The conversation in Figure 5 \nis realizable as per Realizability.. The peer behaviors, obtained from projection of the conversation \nand determinization, results in a system that is well-formed and language equivalent to the conversation. \n 4.3 Summary of the Results Theorems 5 and 6 lead to a methodology for automatically check\u00ading the realizability \nof a conversation speci.cation C for Realizability. and Realizability.. Deciding realizability was an \nopen problem. We have proved that realizability can be veri.ed by checking the language equiva\u00adlence \nbetween C and 1-bounded system over a set of peers obtained from projection of C on peers and verifying \nthe satis.ability of a temporal property by the 1-bounded system (well-formedness veri\u00ad.cation). Both \nequivalence checking and well-formedness veri.ca\u00adtion can be performed automatically (using existing \ntools) as the 1-bounded system and the conversation representing the choreog\u00adraphy speci.cation both \nhave .nite state-space. Furthermore, we have proved that Realizability. and Realizability. are equivalent \nwhen language equivalence between choreography and system is considered. The complexity for well-formedness \nveri.cation is linear to the size of the 1-bounded system and the size of the CTL formula specifying \nthe well-formed property (complexity for CTL model checking [10]). The complexity for language equivalence \nchecking is PSPACE-complete for language equivalence. The conversation protocols shown in Figures 1, \n2 and 3 are language realizable according to Realizability. and Realizability..  5. Experimental Evaluation \nWe have automated our approach for checking realizability of con\u00adversation protocols leveraging the CADP \ntoolbox [17], which pro\u00advides a wide range of constructs for representing communicating .nite state machines \nand mechanisms for checking equivalences between such state machines. We have implemented a translator, \nwhich takes a conversation protocol speci.cation as input (speci.ed in the conversation proto\u00adcol format \nof the Web Service Analysis Tool [15]) and generates two LOTOS speci.cations (the speci.cation language \nfor CADP): (a) one that corresponds to the conversation protocol itself and (b) another one that corresponds \nto the 1-bounded-asynchronous projection of the protocol. We have developed SVL scripts [16] that automatically \nconstruct state machine representations from the LOTOS speci.cations, and check language realizability \nby deploy\u00ading CADP s Reductor tool, which reduces the state machines and checks equivalence between them \nin an optimized fashion.  5.1 Conversation Protocol to LOTOS Translation In LOTOS, processes are declared \nas process proc[m1, m2, ...]: exit := behavior,where process is a keyword, proc is the pro\u00adcess name, \nm1, m2, ... are the messages that are sent and received by this process, and behavior describes the process \nbehavior. The process behavior speci.es the message exchange order using the LOTOS operators. The sequential \nordering is speci.ed using the operator ; where, e.g., m1;m2 means that message m1 must precede message \nm2. Choices are speci.ed using the operator [] where m1[]m2 means that only one message can be executed. \nLooping be\u00adhavior is encoded as a process with a recursive behavior. Lastly, the internal t action and \nthe system termination are described using the LOTOS messages i and exit, respectively. Consider the \nKeyboardDeviceContract (Figure 2) which de\u00adscribes the interaction between a server and its client. Below \nwe show a portion of the automatically generated LOTOS code for this contract. We use the suf.x SC to \ndenote the messages sent by the server to the client and we use the suf.x CS to de\u00adnote the messages \nsent by the client to the server. The process KEYBOARDDEVICECONTRACT starts with the message Success \nSC which is sent from the server to the client and then the contract makes a transition into a looping \nprocess which starts at the Ready state shown in Figure 2. This looping process describes all possible \nbehaviors starting from the Ready state.     5.2 1-Bounded Asynchronous Projection in LOTOS The \nLOTOS language does not support asynchronous communi\u00adcation directly. In order to generate the 1-bounded \nasynchronous model in LOTOS we create a bounded FIFO queue process (which can store at most one message) \nfor each message queue. Given a conversation protocol, we need to create a message queue for each process \ngenerated from its projection. For instance, the projection of the KeyboardDeviceContract generates two \nprocesses, namely, SERVER and CLIENT. In order to generate the asynchronous version of the server process \nwe compose the SERVER and the queue pro\u00adcess using LOTOS composition operator |[m1, m2, ...]| where both \nprocesses synchronize on shared messages m1, m2, ....This queue is responsible for storing the (at most \none) messages to be consumed by the server. endproc The queue associated with the server synchronizes \nwith the client by receiving the actions sent by the client; it also synchronizes with the server by \nsending the actions that are consumed immediately by the server. The synchronized actions between the \nqueue and the server are hidden during the composition and become t (internal) transitions in LOTOS (i.e., \nE-transition as per our notation). Sim\u00adilarly we generate the asynchronous version of the client process \nby composing the client s receive queue and the CLIENT process. Finally, the overall 1-bounded asynchronous \nmodel is obtained by composing the ASYNC SERVER process with the ASYNC CLIENT pro\u00adcess using the LOTOS \noperator |[...]|. These two processes syn\u00adchronize on the message send events. 5.3 Equivalence Checking \nAfter generating the LOTOS speci.cations for the conversation pro\u00adtocol and 1-bounded asynchronous projection \nmodels, we generate the two corresponding LTSs using the state space generation tools in the CADP toolbox. \nWe check the equivalence of the two LTSs to determine realizability of the protocol. During the equivalence \nchecking, the receive actions are hidden (as internal action t )and the send actions are left visible. \nIn order to check the language realizability in an optimized way, we .rst reduce the resulting LTSs modulo \nweak trace rela\u00adtion which reduces the transition systems without modifying their visible traces. Then \nwe check the equivalence of reduced LTSs for the conversation protocol and its 1-bounded-asynchronous \nprojec\u00adtion using the weak trace equivalence relation. If the two LTSs are equivalent this means that \nsend-traces for the conversation proto\u00adcol and its 1-bounded-asynchronous projection are identical and, \nhence, the conversation protocol is language-realizable. If the two LTSs are not equivalent, then we \nconclude that the conversation protocol is not language-realizable.   Conversation Protocol Size Async. \nModel Size Analysis Time (seconds) |C| |.| |C| |.| Reduction Equivalence Mean 6.70 9.74 3268.83 19133.72 \n11.53 2.18 Min 2 1 2 1 6.50 0.48 Max 31 68 302449 1791867 39.91 3.07 STDV 4.40 9.02 30713.29 181950.70 \n3.12 0.27 Table 1. Protocol and model sizes and analysis time for the experiments on the realizability \nof conversation protocols (|C|: the number of states; |.|: the number of transitions). Conversation Language \nProtocols Realizable Singularity Channels 86 84 Choreographies 9 8 Collaboration Diagrams 9 8 Table \n2. Results of the experiments on language realizability.  5.4 Experiments We applied our approach to \n104 conversation protocols which de\u00adscribe web service choreographies, Singularity OS channel con\u00adtracts, \nand UML collaboration diagrams. All these speci.cations were .rst automatically translated to conversation \nprotocols (in the conversation protocol format of the Web Service Analysis Tool) using the translators \ndescribed in [15], [34], and [7], respectively. Then we used the conversation protocol to LOTOS translator \nwe described above to generate the LOTOS speci.cations for the con\u00adversation protocol and the 1-bounded \nasynchronous projection. We report the cumulative results of our analysis in Table 1 showing the sizes \nof the conversation protocol speci.cations, asyn\u00adchronous models and the execution times for the reduction \nand the equivalence checking steps. The conversation protocol speci.ca\u00adtions are not very large, the \nbiggest one has 31 states and 68 tran\u00adsitions. 1-bounded asynchronous model can be very large in some \ncases, however the reduction techniques we use reduces the sizes of the models signi.cantly. The reductions \ntake about 11 seconds on average and the equivalence check takes about 2 seconds on av\u00aderage. So realizability \nof a conversation protocol can be determined in about 13 seconds on average. According to the results \nof our analysis (see Table 2) all con\u00adversation protocols in our base are language realizable except \nfour. Two of the four that fail the realizability check are Singularity chan\u00adnel contracts which were \ncon.rmed by the Singularity developers to be faulty [34].  6. Related Work The language-based choreography \nrealizability problem for conver\u00adsation protocols was .rst proposed in [14] where suf.cient condi\u00adtions \nfor realizability were given. The work on session types [19, 20] is also related to the realizability \nof conversation protocols and has been used as a formal basis for modeling choreography lan\u00adguages [9]. \nThe restrictions used in session types to guarantee that local implementations follow the global interaction \nprotocol are similar to the suf.cient conditions for realizability given in [14] and they are not necessary \nconditions, i.e., there are realizable choreog\u00adraphy speci.cations which fail the conditions given in \nthese earlier results. In particular, both of these earlier approaches do not allow a protocol containing \na state with an arbitrary initiator [18], i.e., a state where more than one peer could send the next \nmessage and the protocol works .ne for either case. Protocols which are of this type and are realizable \nappear in practice (for example, protocols where one of the peers can cancel the interaction at an arbitrary \npoint) and cannot be shown to be realizable with these earlier approaches. Choreography realizability \nproblem for several different com\u00admunication models have been investigated in [25], however, the pre\u00adsented \ntechniques can only show realizability if the asynchronous projection of the protocol has a .nite state \nspace (which would not be the case if the protocol has a single self loop for exam\u00adple). More recently, \n[27] presented an approach that only allows speci.cation of realizable choreographies but, like the approaches \ndiscussed above, this approach does not allow speci.cation of re\u00adalizable choreographies that have arbitrary \ninitiator states. Finally, [18] proposed a new realizability check that correctly identi.es the realizability \nof many arbitrary initiator protocols, however, like all the earlier results, it still provides a suf.cient \ncondition for realiz\u00adability, and decidability of the realizability problem has remained open. In this \npaper we give a necessary and suf.cient condition for realizability and show that it is a decidable problem. \nInterestingly, the similar realizability problem for the MSC-graphs (which is an extension of MSCs) is \nundecidable [1]. Realizability of collaboration diagrams has been studied [8] and it has been showed \nthat language realizability for collaboration dia\u00adgrams can be checked by checking the equivalence of \nthe choreog\u00adraphy model with the 1-bounded asynchronous model [32]. How\u00adever, the collaboration diagram \nmodel used in [32] is not as expres\u00adsive as the conversation protocols, and cannot model the Singular\u00adity \ncontracts and the web service choreographies we analyzed in our experiments. Realizability of Singularity \nchannel contracts have been .rst studied in [34] using the realizability conditions from [14]. The realizability \ncheck we present in this paper can identify some Sin\u00adgularity channel contracts as realizable for which \nthe realizability check used in [34] gives false positives. Message patterns expressed with Petri nets \nusing synchronous communication are de-synchronized in [11] that is, one is interested in .nding a speci.cation \nthat produces the same pattern of messages when communications become asynchronous. This work, however, \nalready assumes that a conversation is realiz\u00adable and does not provide realizability conditions. The \nwork presented in [26] checks choreography realizability using the controllability concept. Given a choreography \ndescription, a monitor service is computed from that choreography, and is used as a centralized orchestrator \nof the interaction to compute the distributed peers. The choreography is said to be realizable if the \nmonitor service is controllable, that is, there exists a set of peers such that the composition of the \nmonitor service and those peers is deadlock-free. Our approach is different since the distributed peers \nare computed without the centralized orchestrator, i.e., the realizability notion we study in this paper \ndoes not require a monitor service, and our techniques for checking realizability rely on equivalence \nchecking rather than controllability checking.  7. Conclusion In this paper, we prove that the choreography \nrealizability problem is decidable for systems communicating with asynchronous mes\u00adsages using unbounded \nFIFO message queues. We provide a nec\u00adessary and suf.cient condition for realizability which states that, \na choreography speci.cation is realizable for systems with asyn\u00adchronously communicating peers over unbounded \nmessage queues, if and only if, the choreography speci.cation behavior is equivalent to the behavior \nof a well-formed 1-bounded system where each peer behavior is obtained from determinizing the projection \nof the chore\u00adography (on each peer) and where each peer has a message queue of size 1. As the choreography \nspeci.cation and the 1-bounded sys\u00adtem both exhibit .nite state-space, checking language realizability \nof the choreography speci.cation can be automatically performed using existing equivalence checking and \nmodel checking tools. We have also implemented our technique for realizability checking in a prototype \ntool using CADP toolbox and veri.ed the realizability of a wide range of choreography speci.cations that \ndescribe Web ser\u00advice interactions, Singularity OS contracts and UML collaboration diagrams. Acknowledgment \nThe authors thank Gwen Sala\u00a8un for fruitful discussions on the CADP implementation. This work has been \npartially supported by the US National Science Foundation grants CCF1117708, CCF1116836, CCF0702758, \nand project TIN2008-05932 funded by the Spanish Ministry of Innovation and Science and FEDER.  References \n[1] R. Alur, K. Etessami, and M. Yannakakis. Realizability and veri.ca\u00adtion of MSC graphs. In Proc. 28th \nInt. Colloq. on Automata, Lan\u00adguages, and Programming, pages 797 808, 2001. [2] J. Armstrong. Getting \nErlang to Talk to the Outside World. In Proc. ACM SIGPLAN Work. on Erlang, pages 64 72, 2002. [3] J. \nArmstrong. Programming Erlang, Software for a Concurrent World. Pragmatic Bookshelf, 2007. [4] G. Banavar, \nT. Deepak Chandra, R. E. Strom, and D. C. Sturman. A Case for Message Oriented Middleware. In Proceedings \nof the 13th Int. Symp. Distributed Computing, pages 1 18, 1999. [5] S. Basu and T. Bultan. Choreography \nConformance via Synchroniz\u00adability. In Proc. 20th Int. World Wide Web Conf., 2011. [6] D. Brand and P. \nZa.ropulo. On communicating .nite-state machines. Journal of the ACM, 30(2):323 342, 1983. [7] T. Bultan, \nC. Ferguson, and X. Fu. A tool for choreography analysis using collaboration diagrams. In Proc. 7th IEEE \nInt. Conf. Web Services, 2009. [8] T. Bultan and X. Fu. Speci.cation of Realizable service conversations \nusing collaboration diagrams. Service Oriented Computing and Appli\u00adcations, 2(1):27 39, 2008. [9] M. \nCarbone, K. Honda, N. Yoshida, R. Milner, G. Brown, and S. Ross-Talbot. A Theoretical Basis of Communication-Centred \nConcurrent Programming, W3C Note, October 2006. http://www.w3.org/2002/\u00adws/chor/edcopies/theory/note.pdf. \n[10] E.M. Clarke, O. Grumberg, and D. A. Peled. Model Checking.The MIT Press, Cambridge, Massachusetts, \n1999. [11] G. Decker, A. P. Barros, F. M. Kraft, and N. Lohmann. Non\u00addesynchronizable Service Choreographies. \nIn Proc. ICSOC, pages 331 346, 2008. [12] M. F\u00a8ahndrich, M. Aiken, C. Hawblitzel, O. Hodson, G. C. Hunt, \nJ. R. Larus, and S. Levi. Language support for fast and reliable message\u00adbased communication in singularity \nos. In Proc. 2006 EuroSys Conf., pages 177 190, 2006. [13] C. Ferris and J. Farrell. What are web services? \nComm. of the ACM, 46(6):31 31, June 2003. [14] X. Fu, T. Bultan, and J. Su. Conversation protocols: \nA formalism for speci.cation and analysis of reactive electronic services. Theoretical Computer Science, \n328(1-2):19 37, November 2004. [15] X. Fu, T. Bultan, and J. Su. WSAT: A tool for formal analysis of \nweb services. In Proc. 16th Int. Conf. on Computer Aided Veri.cation, pages 510 514, 2004. [16] H. Garavel \nand Fr\u00b4ed\u00b4eric Lang. SVL: A Scripting Language for Com\u00adpositional Veri.cation. In Proc. FORTE, pages \n377 394, 2001. [17] H. Garavel, R. Mateescu, F. Lang, and W. Serwe. CADP 2006: A Toolbox for the Construction \nand Analysis of Distributed Processes. In Proc. 18th Int. Conf. Computer Aided Veri.cation, 2006. [18] \nS. Hall\u00b4e and T. Bultan. Realizability Analysis for Message-Based In\u00adteractions using Shared-State Projections. \nIn Proc. 18th ACM SIG-SOFT Int. Sym. Foundations of Software Engineering, pages 27 36, 2010. [19] K. \nHonda, V. T. Vasconcelos, and M. Kubo. Language primitives and type discipline for structured communication-based \nprogramming. In Proc. 7th European Symp. on Programming Languages and Systems, pages 122 138, 1998. [20] \nK. Honda, N. Yoshida, and M. Carbone. Multiparty Asynchronous Session Types. In Proc. 35th ACM SIGPLAN-SIGACT \nSym. Principles of Programming Languages, pages 273 284, 2008. [21] G. C. Hunt and J. R. Larus. Singularity: \nrethinking the software stack. Operating Systems Review, 41(2):37 49, 2007. [22] Conversation Support \nfor agents, e-business, and component integra\u00adtion. http://www.research.ibm.com/convsupport. [23] Java \nAPI for XML messaging (JAXM). http://java.sun.com/developer/earlyAccess/xml/jaxm/. [24] Java Message \nService. http://java.sun.com/products/jms/. [25] R. Kazhamiakin and M. Pistore. Analysis of Realizability \nConditions for Web Service Choreographies. In Proc. FORTE, pages 61 76, 2006. [26] N. Lohmann and K. \nWolf. Realizability is Controllability. In Proc. 1st Central-European Work. on Services and Their Composition, \npages 61 67, 2009. [27] A. McNeile. Protocol contracts with application to choreographed multiparty collaborations. \nService Oriented Computing and Applica\u00adtions, 4:109 136, 2010. [28] D. A. Menasc\u00b4e. Mom vs. rpc: Communication \nmodels for distributed applications. IEEE Internet Computing, 9(2):90 93, 2005. [29] Message Sequence \nChart (MSC). ITU-T, Geneva Recommendation Z.120, 1996. [30] Microsoft Message Queuing Service. http://www.microsoft.com/windowsserver2003/ \ntechnologies/msmq/default.mspx. [31] E. Newcomer. Understanding Web Services: XML, WSDL, SOAP, and UDDI. \nSpringer, 2004. [32] G. Sala\u00a8un and T. Bultan. Realizability of Choreographies Using Process Algebra \nEncodings. In Proceedings of the 7th International Conference on Integrated Formal Methods, pages 167 \n182, 2009. [33] Singularity design note 5 : Channel contracts. singularity rdk doc\u00adumentation (v1.1). \nhttp://www.codeplex.com/singularity, 2004. [34] Z. Stengel and T. Bultan. Analyzing Singularity Channel \nContracts. In Proceedings of the 18th International Symposium on Software Testing and Analysis, pages \n13 24, 2009. [35] S. Uchitel, J. Kramer, and J. Magee. Incremental elaboration of scenario-based speci.cations \nand behavior models using implied sce\u00adnarios. ACM Transactions on Software Engineering and Methodology, \n13(1):37 85, 2004. [36] OMG uni.ed modeling language superstructure, version 2.1.2. http: //ww.uml.org/, \nOctober 2007. [37] Web Service Choreography Description Language (WS-CDL). http://www.w3.org/TR/ws-cdl-10/, \n2005.  \n\t\t\t", "proc_id": "2103656", "abstract": "<p>Since software systems are becoming increasingly more concurrent and distributed, modeling and analysis of interactions among their components is a crucial problem. In several application domains, message-based communication is used as the interaction mechanism, and the communication contract among the components of the system is specified semantically as a state machine. In the service-oriented computing domain such communication contracts are called \"choreography\" specifications. A choreography specification identifies allowable ordering of message exchanges in a distributed system. A fundamental question about a choreography specification is determining its realizability, i.e., given a choreography specification, is it possible to build a distributed system that communicates exactly as the choreography specifies? Checking realizability of choreography specifications has been an open problem for several years and it was not known if this was a decidable problem. In this paper we give necessary and sufficient conditions for realizability of choreographies. We implemented the proposed realizability check and our experiments show that it can efficiently determine the realizability of 1) web service choreographies, 2) Singularity OS channel contracts, and 3) UML collaboration (communication) diagrams.</p>", "authors": [{"name": "Samik Basu", "author_profile_id": "81100645755", "affiliation": "Iowa State University, Ames, IA, USA", "person_id": "P2991374", "email_address": "sbasu@iastate.edu", "orcid_id": ""}, {"name": "Tevfik Bultan", "author_profile_id": "81100417046", "affiliation": "University of California, Santa Barbara, Santa Barbara, CA, USA", "person_id": "P2991375", "email_address": "bultan@cs.ucsb.edu", "orcid_id": ""}, {"name": "Meriem Ouederni", "author_profile_id": "81435610919", "affiliation": "University of Malaga, Malaga, Spain", "person_id": "P2991376", "email_address": "meriem@lcc.uma.es", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103680", "year": "2012", "article_id": "2103680", "conference": "POPL", "title": "Deciding choreography realizability", "url": "http://dl.acm.org/citation.cfm?id=2103680"}