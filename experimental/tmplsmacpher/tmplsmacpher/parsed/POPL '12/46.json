{"article_publication_date": "01-25-2012", "fulltext": "\n A Type System for Borrowing Permissions Karl Naden Robert Bocchino Jonathan Aldrich Carnegie Mellon \nUniversity, Pittsburgh, PA, USA {kbn,rbocchin,jonathan.aldrich}@cs.cmu.edu Abstract In object-oriented \nprogramming, unique permissions to object ref\u00aderences are useful for checking correctness properties \nsuch as con\u00adsistency of typestate and noninterference of concurrency. To be us\u00adable, unique permissions \nmust be borrowed for example, one must be able to read a unique reference out of a .eld, use it for \nsomething, and put it back. While one can null out the .eld and later reassign it, this paradigm is ungainly \nand requires unneces\u00adsary writes, potentially hurting cache performance. Therefore, in practice borrowing \nmust occur in the type system, without requir\u00ading memory updates. Previous systems support borrowing \nwith external alias analysis and/or explicit programmer management of fractional permissions. While these \napproaches are powerful, they are also awkward and dif.cult for programmers to under\u00adstand. We present \nan integrated language and type system with unique, immutable, and shared permissions, together with \nnew lo\u00adcal permissions that say that a reference may not be stored to the heap. Our system also includes \nchange permissions such as unique>>unique and unique>>none that describe how per\u00admissions .ow in and \nout of method formal parameters. Together, these features support common patterns of borrowing, including \nborrowing multiple local permissions from a unique reference and recovering the unique reference when \nthe local permissions go out of scope, without any explicit management of fractions in the source language. \nAll accounting of fractional permissions is done by the type system under the hood. We present the syntax \nand static and dynamic semantics of a formal core language and state soundness results. We also illustrate \nthe utility and practicality of our design by using it to express several realistic examples. Categories \nand Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory Borrowing; D.3.3 \n[Pro\u00adgramming Languages]: Language Constructs and Features Permissions General Terms Design, Languages, \nTheory, Veri.cation Keywords Types, Permissions, Borrowing, Uniqueness, Immu\u00adtability 1. Introduction \nPermissions are annotations on pointer variables that specify how an object may be aliased, and which \naliases may read or write to the object [9]. For example, unique [20] indicates an unaliased Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 12, January \n25 27, 2012, Philadelphia, PA, USA. Copyright &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. . . $10.00 \nKevin Bierhoff Two Sigma Investments, New York, NY, USA kevin.bierhoff@cs.cmu.edu object, immutable \n[24] indicates an object that can be aliased but cannot be mutated, and shared [3] indicates an object \nthat may be aliased and can be mutated. Permission systems have been proposed to address a diversity \nof software engineering concerns, including encapsulation [24], protocol checking [3, 13], safe con\u00adcurrency \n[6, 8], security [5], and memory management [9, 15]. Recently, new programming languages have incorporated \npermis\u00adsions [28] or related af.ne types [26] as fundamental parts of the type system. In order to leverage \npermissions in practice, programmers must be able to manipulate them effectively. One form of manipulation \nis permission splitting: for example, converting a unique permis\u00adsion into multiple shared permissions, \nor alternatively into multiple immutable permissions. A shared (or immutable) permission can then be \nsplit further into more shared (respectively immutable) per\u00admissions. A second important form of manipulation \nis borrowing: extracting a permission from a variable .eld, using it temporarily, and then returning \nall or part of it to the source. For example, a method may require an immutable permission to the receiver; \nif we have a unique permission to an object, we d like to call the method on that object, and provided \nthe method does not allow an alias to the receiver to escape, we d like to get our unique permission \nback at the end. Crucially, recovering the permission should not require reassigning the original variable \n(which may not even be assignable). Borrowing was originally proposed by [19]; however, good sup\u00adport \nfor this feature has remained an open and dif.cult problem. Prior type-based systems [1, 19, 22] provided \na borrowed annota\u00adtion, but they did not support the immutable references that are an essential part \nof many recent systems [3, 8, 28]. A number of sys\u00adtems supported borrowing via a program analysis [4, \n7], but the pro\u00adgram analysis relies on shape analysis, which is fragile and noto\u00adriously dif.cult for \nprogrammers to understand. Boyland proposed fractional permissions [8] to support splitting and recombining \nper\u00admissions, with borrowing as a special case, but its mathematical fraction abstraction is unnatural \nfor programmers, to such an extent that the automated tools we know of once again hide the fractions \nbehind an (inscrutable) analysis [3, 17]. A good borrowing facility should have a number of properties. \nIt should support a natural programming style (e.g. avoid awkward constructs like replacing .eld write \nwith a primitive swap opera\u00adtion [16], or a requirement to thread a reference explicitly from one call \nto the next by reassigning the reference each time [26]). Rea\u00adsoning abstractions should likewise be \nnatural (not fractions [8]). It should support borrowing from unique, immutable, and shared variables \nand .elds. Rules should be local so the programmer can understand them and predict how they operate (vs. \na non-local anal\u00adysis [3, 7] or constraint-based inference). The contribution of this paper is the .rst \nborrowing approach that meets all of the above properties. We provide a type system for a Java-like language \nwith permissions that are tracked through lo\u00adcal, predictable rules. Our technical approach includes \na number of innovations, including change permissions that show the incoming and outgoing permissions \nto a method parameter, local permissions that modify shared or immutable permissions to denote that they \ncannot escape, an expressive rule for handling borrowing across conditional branches, and a way to safely \nrestore permissions to the variable or .eld from which they were borrowed. We formalize our type system, \nprove it sound, and demonstrate it via a series of examples which can be checked by our prototype implementation.1 \n We describe the features of the language in the next section. Section 3 formalizes our type system \nand gives soundness results. We cover additional related work in section 4, and section 5 con\u00adcludes. \n2. Language Features In this section we informally explain the features of our language; the next section \ngives a more formal treatment. Our language is based on Plaid [28]. For our purposes, Plaid is similar \nto Java, except: Instead of classes, Plaid uses states. This is because Plaid has a .rst-class notion \nof typestate, which can be used to model ob\u00adject state and transitions between states. We don t use typestate \nin this work, but we adhere to the Plaid syntax.  Plaid has a match construct that evaluates an argument \nand then uses its type to pick which of several cases to execute.  Plaid has no null value in the surface \nsyntax or programmer\u00advisible semantics. Instead, every object .eld and variable is initialized to a non-null \nobject.  Plaid has a .rst-class notion of permissions. Supporting types\u00adtate is one important application \nof permissions, including the novel borrowing mechanisms discussed in this work.  In the rest of this \nsection we .rst give an overview of the permissions in our language. Then we explain the mechanisms for \ncreating aliases of variables and .elds with consistent permissions. Then we explain the mechanism of \nchange permissions, which allows modular checking of permission .ow in and out of methods. Finally, we \nexplain local permissions, which provide a way to split a unique permission into several permissions \nand later recombine them to unique, without explicit fractions. 2.1 Access Permissions Permissions are \na well-known way of controlling aliasing in ap\u00adplications such as typestate [3] and concurrency control \n[8]. Our permission system is adapted from the access permissions system of [3]. An access permission \nis a tag on an object reference that says how the reference may be used to access the .elds of the ob\u00adject \nit refers to and how aliases of that reference may be created. In this work, we use the following permissions: \n A unique permission to object reference o says that this is the only usable copy of o: if any alias \nof o exists, then it has permission none. The reference may be used to read and write .elds of the object \nO that it points to.  A none permission says that the reference may not be used to read or write the \nobject it points to.  An immutable permission says that the reference o may be used only for reading, \nand not writing, the .elds of the object O that it points to. Further, all other usable (non-none) references \nto O are guaranteed to be immutable, so no aliased reference can be used to write O either.  1 available \nat http://code.google.com/p/plaid-lang/ A shared permission says that the reference o may be used for \nreading and writing, and there is no restriction on aliases of o (so shared is like an ordinary reference \nin Java).  A local immutable or local shared permission is like an immutable (respectively shared) permission, \nex\u00adcept it can only be passed around in local variables, and can t be assigned to the heap. Local permissions \nare new with this work and are explained further in Section 2.4.  If any alias of a unique reference \nis created, then the unique permission must be consumed (but it can be transferred to the alias). A unique \npermission is therefore like a linear resource [14]. By contrast, immutable and shared references may \nbe freely replicated. While other access permissions are possible, these permissions suf.ce to illustrate \nthe concepts in this paper. Further, these per\u00admissions can express a wide range of computation patterns. \nOther permissions could be added to the system without dif.culty.  2.2 Aliasing Variables and Fields \nIn contrast to a language like Java with unrestricted aliasing, a language with access permissions must \nmaintain careful control over how aliases are created. We now discuss how our language manages permissions \nfor aliases of variables and object .elds. (a) Borrowing Unique from a Variable 1 unique x = new S1; \n// x:unique 2 { 3 unique y = x; // x:none,y:unique 4 } // x:unique (b) Borrowing Unique from One of Two \nVariables 1 unique x = new S1; // x:unique 2 unique y = new S2; // x:unique,y:unique 3 { 4 unique z \n= match(...) { 5 S1=>x; S2=>y; // x:none,y:none,z:unique 6 } 7 } // x:unique,y:unique (c) Taking Unique \nfrom a Variable 1 unique x = new S2; // x:unique 2 unique y = new S1; // x:unique,y:unique 3 { 4 unique \nz = x; // x:none,y:unique,z:unique 5 y.f1 = z; // x:none,y:unique,z:none 6 } // x:none,y:unique Figure \n1. Examples of variable aliasing. Aliasing Variables: In our language the following rules govern aliasing \nof local variables: 1. Our local variables are single-assignment (i.e., they are as\u00adsigned to only in \ntheir declaration) and are declared with ex\u00adplicit permissions, so the needed permission is always available \non the left-hand side of a variable assignment. 2. In typing and assignment, we compute all variables \nand .elds such that the value returned by the right-hand side of the assign\u00adment may be obtained by reading \nthe variable or .eld. Because we can t statically resolve which match case will be taken, there may be \nmore than one. 3. We maintain a typing environment, which we call a context, with the permission associated \nwith each variable. For each pos\u00adsible source variable, we make sure there is enough permission in the \ncontext to extract the needed permission. We use permis\u00adsion splitting rules, given formally in the next \nsection, to com\u00ad   pute the permission remaining in the source variables after the extraction, and \nwe update the context accordingly. 4. At the end of the scope of the assignee variable, we restore whatever \npermission is left in that variable to the source vari\u00adables. For this operation we use permission joining \nrules, which are the reverse of the splitting rules. Figure 1 shows examples, where the de.nitions of \nstates S1 and S2 are as follows: state S1 { unique S1 f1 = new S2; } state S2 case of S1 { unique S1 \nf2 = new S3; } state S3 case of S2 {} Here case of is like extends in Java and denotes subclassing. \nIn Figure 1(a), variable x is declared unique and initialized with a fresh object in line 1. In line \n3, variable y is created and takes the unique permission out of x, leaving none in x. When y goes out \nof scope in line 4, its unique permission .ows back into x. Figure 1(b) is similar, except that in line \n5, we don t know which variable (x or y) will be read from at runtime, so we take permissions out of \nboth, record both as source variables, and restore permissions to both at the end of z s scope in line \n7. The match statement in lines 4 5 says to evaluate the selector expression (represented as ellipses \nhere) to an object reference o, then evaluate the whole expression to x if the type of o matches S1, \nto y if the type of o matches S2, and to halt if there is no match. While this example is simple, in \ngeneral typing match in our language is subtle and requires merging the contexts generated by the different \nmatch cases; the details are given in Section 3.2. Figure 1(c) shows an example where the permission \nread out of x into z is stored into the heap, so it can t be returned to x at the end of z s scope. (a) \nBorrowing Unique from a Field 1 unique x = new S1; // x:unique 2 { 3 unique y = x.f1; // x:(unique,f1:none),y:unique \n4 } // x:unique (b) Borrowing Unique from a Variable or Field 1 unique x = new S1; // x:unique 2 unique \ny = new S1; // x:unique,y:unique 3 { 4 unique z = match(...) { 5 S1=>x; S2=>y.f1; 6 // x:none,y:(unique,f1:none),z:unique \n7 } 8 } // x:unique,y:unique (c) Taking Unique from a Field 1 unique x = new S1; // x:unique 2 unique \ny = new S1; // x:unique,y:unique 3 y.f1 = x.f1; // x:(unique,f1:none),y:unique Figure 2. Examples of \n.eld aliasing. Aliasing Fields: The rules for aliasing of .elds are similar to those for aliasing of \nlocal variables, with two exceptions. First, pulling a permission out of a .eld can cause the residual \npermission to vi\u00adolate the statically declared .eld permission. For example, pulling unique out of a \n.eld declared unique causes the .eld to have permission none. In this case, we say the .eld is unpacked \n[12]. If an object has any unpacked .elds, then we say the object is un\u00adpacked. We must account for the \nactual permissions when access\u00ading the .elds of an unpacked object. Second, since .elds can be assigned \nto, the reference in the .eld at the point of permission restore may not be the same reference that the \npermission came from. In this case, we must be careful not to restore permissions to the wrong reference, \nwhich would violate soundness. Unpacking .elds: To address the .rst issue, we store the current permission \nof each unpacked .eld of each object in the context. Figure 2 shows examples, where S1 and S2 are de.ned \nas before. In Figure 2(a), line 3 shows the context after taking a unique permission out of x.f1. The \nnotation x:(unique,f1:none) means that x has unique permission and points to an unpacked object with \nnone permission for .eld f1. Figure 2(b) shows how to use the same mechanism from Figure 1 to pull a \npermission out of either a variable or a .eld. Figure 2(c) shows an example of taking a unique permission \nfrom a .eld and assigning it to another .eld. To ensure soundness, we place three restrictions on .eld \nun\u00adpacking. First, an object can be unpacked via a variable with unique permission, but not immutable \nor shared permission. This is so out\u00adstanding aliases to the object don t become inconsistent.2 Our lan\u00adguage \nalso allows taking an immutable permission out of a unique .eld v.f given immutable permission to v. \nIn this case our type system does not report v as unpacked in the context; this is sound because once \nan object is seen with immutable permission it can never become unique again. Second, once an object \no stored in variable v is unpacked, permission to o may not be assigned to another variable or the heap \nuntil v is packed again; otherwise we would not be able to track the unpacked state of o through v s \ninformation in the context. For example, the following code is not allowed, because x is unpacked when \nit is assigned to z: 1 unique x = new S1; // x:unique 2 unique y = x.f1; // x:(unique,f1:none),y:unique \n3 unique z = x; // Disallowed because x is not packed Third, a variable v must be packed at the point \nwhere it goes out of scope; in particular method formal parameters must be packed at the end of a method \nbody. That is because the permission stored in v could be .owing back to a different (packed) variable \nthat gave its permission to v when v was declared. In practice, the programmer can comply with the latter \ntwo requriements by carefully managing the scopes of variables that read permissions from unique .elds \nand/or writing fresh objects into the .elds to pack the .elds at appropriate points. While in some cases \nthese writes may not be strictly necessary, the requirements do not seem to be onerous in the examples \nwe have studied. These restrictions could be relaxed at the cost of additional language complexity (for \nexample, stating in method signatures which .elds of an incoming parameter must be packed). Consistent \npermission restore: As an example of the second issue identi.ed above (erroneous permission restore), \nconsider the fol\u00ad lowing code: 1 unique x = new S2; // x:unique 2 { 3 unique y = x.f1; // x:(unique,f1:none),y:unique \n4 x.f1 = new S2; // x:unique,y:unique 5 x.f2 = x.f1; // x:(unique,f1:none),y:unique 6 } // x:(unique,f1:none) \nRestoring a permission to x.f1 at the end of y s scope in line 6 would create an alias between x.f1 and \nx.f2, both with unique permission. The problem is that the reference in .eld x.f1 in line 6 is not the \nsame reference to which permission was taken in line 3, so restoring to it would be wrong. To prevent \nthis from happening, the static typing rules maintain an identi.er that is updated every time a .eld \ngoes from packed to unpacked. The permission restore occurs only if the identi.er at the point of the \n.eld access matches the identi.er at the point of restoration. For example, in the code shown above, \nat line 3 where 2 Local permissions, discussed in Section 2.4, provide an additional way to unpack objects. \n x.f1 is unpacked and its permission read into y, an identi.er i is associated with x.f1 and with y. \nThen in line 5, when x.f1 is unpacked again, x.f1 gets a fresh identi.er i ' . In line 6, when y ' goes \nout of scope, its identi.er i does not match the identi.er i of the source location x.f1, so permission \nis not restored from y into the location. Thus the identi.er mechanism approximates object identity at \nruntime; the approximation is conservative because each assignment is assumed to assign a different object \nreference, even if the same one is actually assigned twice.  2.3 Modular Checking with Change Permissions \nTo support modular checking of permission .ow across method scopes, we introduce a language feature called \na change permis\u00adsion. Change permissions are inspired by, and similar to, change types in Plaid [28]. \nHowever, whereas a change type in Plaid says that an object may transition from one state to another \n(to sup\u00adport typestate), in our language change permissions specify only that a reference permission \nchanges from a stronger to a weaker permission; the object type always persists. Further, while previ\u00adous \nsystems can distinguish borrowed and consumed permissions at method boundaries [7, 11], change permissions \nare more .ex\u00adible, because they can record a change to any weaker permission (not just none). Syntactically, \na change permission looks like p>>p ' , where p and p ' are permissions. Change permissions appear on \nmethod formal parameters, including the implicit parameter this. For ' example, a formal parameter can \nbe declared p>>p sx, where s is a state name. This declaration says the caller must ensure that on entry \nto the method permission p is available for the reference o stored in x, while the callee must ensure \nthat on exit from the ' method permission p is available for o. The bare permission p can also function \nas a change permission; it is shorthand for p>>p. Change permissions naturally support both borrowing \nand non\u00adborrowing uses of unique permissions. For example, a change permission unique>>unique says that \nthe permission in the parameter value must be unique on entry to the method, and the unique permission \nwill be restored at the end of the method; whereas unique>>none says that a unique permission is taken \nand not returned (for example, because it is stored on the heap). 1 state Cell {} 2 state Cons case \nof Cell { 3 immutable Data data; 4 unique Cell next; 5 } 6 state List { 7 unique Cell head = new Cell; \n8 void prepend(immutable Data elt) unique { 9 unique Cons newHead = new Cons with { 10 this.data = elt; \n11 this.next = this.head; // this:(unique,head:none) 12 } 13 this.head = newHead; // this:unique 14 } \n15 } 16 17 unique List list = new List; // list:unique 18 list.prepend(new Data); // list:unique Figure \n3. List prepend example. Figure 3 shows an example using unique>>unique (written in shorthand form as \nunique) to update a list with unique links. Line 1 de.nes a Cell state representing an empty list cell. \nLines 2 5 de.ne a Cons cell which is a substate of Cell; it has a data .eld with immutable permission \nand a next .eld with unique permission. Lines 6 and following de.ne the actual list. It has a unique \nCell for its head and a method prepend that (1) accepts an immutable permission in elt and a unique permission \nin this (unique in line 8 represents the change permission associated with this); (2) leaves a unique \npermission in this on exit; and (3) returns nothing. The comments in lines 11 and 13 show what happens \nwhen checking the method body. In line 11, this is unpacked when the unique permission is taken out of \nthis.head and assigned into newHead. In line 14, this is packed back up when newHead is assigned into \nthis.head. Lines 17 18 show how things look from the point of view of a caller of prepend. In line 17, \nlist gets a fresh reference with unique permission. This unique permission is passed into prepend in \nline 18. However, because of the change permission unique>>unique, the permission is restored on return \nfrom the method, and list still has unique permission at the end of line 18. Note that we could also \nhave restored the permission by returning a reference from prepend and assigning it back into list but \nthis is awkward and would require assignment into local variables. 1 state Data { 2 immutable Data publish() \nunique>>immutable { 3 // Add timestamp 4 this; 5 } 6 ... 7 } 8 9 unique List list = new List; 10 unique \nData data = new Data; // data:unique 11 data.publish(); // data:immutable 12 list.prepend(data); // data:immutable \nFigure 4. Publication example. Figure 4 shows another example, this time using a change per\u00admission unique>>immutable. \nIn this example, the Data class has a publish method that (1) requires a unique permission to this; (2) \nuses the unique permission to write a time stamp to the object; then (3) freezes the object in an immutable \nstate so it can only be read and never written by the rest of the pro\u00adgram. Lines 9 12 show how this \nstate might be used. Line 10 cre\u00adates a fresh Data object with unique permission. Line 11 calls publish \non Data, changing its permission to immutable. Line 12 puts the immutable permission into a list. Notice \nthat since publish also returns an immutable permission to this, we could also have written list.prepend(data.publish()); \nbut using the change permission on variable data makes clear in the client code that the same object \nis going into publish and into prepend.  2.4 Local Permissions An important pattern for access permissions \nis to divide a unique permission up into several weaker permissions, use the weaker permissions for a \nwhile, and then put all the permissions back together to reform the original unique. Doing this requires \ncareful accounting to ensure there are no outstanding permissions to the reference (other than none) \nat the point where the unique is recreated. One way to do this accounting is to use fractions [8]. However, \nwhile powerful, fractions are also dif.cult to use and suffer from modularity problems [17]. Instead, \nwe observe the following: The complexity of fraction-based solutions arises in large part because they \nallow permissions to be stored into the heap, then taken out of the heap and recombined into unique. \n A common use of permissions split off from unique is to pass them into methods, where they are used \nin local variables and then returned, i.e., they never go into the heap.  Motivated by these observations, \nwe introduce a new kind of permission called a local permission. A local permission is des\u00adignated with \nthe keyword local, which may modify a shared or immutable permission. A local permission annotates a \nlocal variable; it says that any aliases of the variable created during its lifetime exist only in local \nvariables and are never stored to the heap. (Local permissions are not necessary for unique or none, \nbecause the permission itself already contains all the information about aliasing to the heap: a unique \nlocal variable says there is no alias on the heap or anywhere else, and a none local variable says it \ndoesn t matter.) Since local permissions exist only in local variables, when all the variables that borrowed \nlocal permissions go out of scope, we can reform the original unique permission. Borrowing Local Permissions \nfrom Variables: A local permis\u00adsion may be borrowed from a variable with unique permission, leaving a \nspecial borrow permission in the context. The borrow permission is used internally for accounting purposes, \nbut never appears in the programmer-visible language syntax. For example, borrowing local immutable from \na unique variable leaves borrow(unique,immutable,1) in the context for that vari\u00adable. This entry says \nwe are borrowing local immutable per\u00admissions from a unique permission, and one alias is outstanding. \nBorrowing again from the same variable increments the counter, while joining decrements the counter. \nThus the counter tracks the number of outstanding local aliases to the original unique per\u00admission; when \nthe counter is 1, joining the last local permission recreates unique. Note that we do this counting only \nwhen creat\u00ading local permissions, because in this language immutable or shared permissions are never \njoined to unique.  (a) Rejoining Local Permissions to Unique 1 unique x = new S; // x:unique 2 { 3 \nlocal immutable y = x; 4 // x:borrow(unique,immutable,1),y:local immutable 5 { 6 local immutable z = \nx; 7 /* x:borrow(unique,immutable,2), 8 y:local immutable,z:local immutable */ 9 } 10 // x:borrow(unique,immutable,1),y:local \nimmutable 11 } 12 // x:unique (b) This Example Does Not Type Check 1 local immutable S escape(unique \nS x) none { 2 // x:unique 3 local immutable y = x; 4 // x:borrow(unique,immutable,1),y:local immutable \n5 y; // Local immutable permission taken here 6 /* x:borrow(unique,immutable,1), 7 y:borrow(local immutable,immutable,1) \n*/ 8 } Figure 5. Borrowing local permissions from variables. Figure 5(a) shows an example. The counter \nfor x becomes 1 in line 4 when y borrows from it, and 2 in line 7 when z borrows from it. When z goes \nout of scope, the counter goes back down to 1, and when y goes out of scope, x becomes unique again. \nWhen the counter exceeds one (as in line 7), we don t rejoin to unique yet because there are still aliases \noutstanding. Notice how the counters in the borrow permissions effectively account for fractions of permissions, \nby counting outstanding aliases. However, these fractions are hidden in the typing and never seen or \nmanipulated by the programmer. We must carefully account for local permissions that might es\u00adcape the \ncurrent scope; otherwise we could not soundly reason that all local permissions are out of scope when \nthe local vari\u00adables holding them are out of scope. Figure 5(b) shows how we do this. In line 3, y takes \na local immutable permission from x, and line 5 attempts to return the local immutable permission to \nthe caller, while retaining the unique permission in x (as shown in the signature in line 1 remember \nthat unique x is short\u00adhand for unique>>unique x). Of course this should not be al\u00adlowed. This example \ndoesn t type check, because when y goes out of scope at the end of the method, two borrow permissions \nwould have to be joined, and our typing rules don t allow this. Only a local permission can be joined \nwith a borrow permission. More gener\u00adally, all aliases borrowed from a local permission must be rejoined \nbefore the local permission can be rejoined to unique. However, if the method signature in line 1 said \nunique>>none S x, then the example would type check, because now x wouldn t have to be rejoined to unique \nto satisfy the parameter s change permission. 1 state Cell { int size() none {0;} } 2 state Cons case \nof Cell { 3 immutable Data data; 4 unique Cell next; 5 int size() local immutable { 1 + this.next.size(); \n} 6 } 7 state List { 8 unique Cell head = new Cell; 9 int size() local immutable { this.head.size(); \n} 10 ... 11 } 12 13 unique List list = new List; // list:unique 14 list.prepend(new Data); // list:unique \n15 int size = list.size(); // list:unique Figure 6. List size example. Borrowing Local Permissions from \nFields: Our language also al\u00adlows borrowing local permissions from unique .elds. This is par\u00adticularly \nuseful when the permission to the object is local. Other\u00adwise, we would need unique permission to the \nobject even to read a unique .eld of the object, and it is well known that this requirement is very restrictive \n(essentially, any access to a linear reference must be through a chain of linear references) [13]. Figure \n6 shows how this works for a simple example that com\u00adputes the size of a list with unique references, \nrequiring read-only access to the list. In line 15, size requires local immutable permission to the list \n(line 11), so local immutable permission is borrowed from list as discussed above, then put back to reform \nunique at the end of the method call. Inside the size method of List, in line 9, this has local immutable \npermission at the start of the method. At the call of this.head.size(), local im\u00admutable permission is \nborrowed from this.head. At that point, the context entry for this is this:(local immutable,head:borrow(unique,immutable,1)) \nsaying that this has local immutable permission and points to an unpacked object with one local immutable \nreference borrowed from its head .eld. On return from this.head.size(), the permissions are put back \ntogether to repack the object. The same thing happens in Cell.size (line 5). Notice that the ability \nto borrow local permissions is very useful here: without it, we would either have to permanently convert \nthe unique to immutable, thereby destroying the unique permission to the list to compute its size, or \nwe would have to require unique permission to the list for the size computation, which is too restrictive. \nOne subtlety of this mechanism is that it allows multiple local variables that point to the same object \nto have different information about whether the object is packed. For example, consider an object O with \na unique .eld f and two aliases of O, x and y, where y was created as an alias of x by pulling a local \ns from the unique permission in x. This leaves x with the permission local s as well, which allows us \nto pull a local s from x.f, unpacking  x. Since the type system does not explicitly track what variables \nare aliases y remains packed. This is .ne because the splitting rules prevent anything other than a local \ns from being pulled out through y.f. Furthermore, by the time y leaves scope and x becomes unique again, \nall local aliases to the .eld f of O must have been returned leaving it unique as well. Thus, it will \nbe safe to pull a unique permission from x.f as allowed by the static rules. At runtime, we will know \nthat x and y are in fact aliases and do the proper accounting for the permission in .eld f even when \npermission are pulled from the .eld through different aliases. More details on this mechanism are given \nin Section 3. 3. Formal Language In this section we formalize the ideas developed in the previous section. \nWe give a syntax, static semantics, and dynamic semantics for a core language. Then we state the key \nsoundness results, which are proved in our companion technical report [23]. 3.1 Syntax Figure 7 gives \nthe syntax for the core language. A program consists of a number of state declarations S and an expression \ne to evaluate. A state consists of a state name s, a parent state s ' (possibly itself), and .eld and \nmethod declarations. Fields F and methods M are declared in the usual way, except that .eld types specify \npermissions p, and method parameters specify change permissions p>>p ' . Fields have initializer expressions. \nThe change permission appearing in the method declaration before the method body is the change permission \nassociated with the implicit parameter this. The rest of the language features are standard for an expression\u00adbased \nobject-oriented language. The match expression evaluates e to an object reference and compares its runtime \nstate s ' to the ' states s named in the cases. It executes the .rst case for which s is a subtype of \ns, with a runtime error if there is no match. v.f=e updates the object in the .eld v.f to the value of \ne, which it also returns as the result of the expression. new s creates an object of state s and initializes \nits .elds by running the initializer expressions given in the state de.nition. The sequence expression \nevaluates each of its subexpressions in order and returns the result of the last one as the value of \nthe whole expression. * Programs P Se ** States S state s case of s { FM }Fields F Tf=e; Methods M Tm(p>>psx) \np>>p { e }Permissions p unique none s local s s immutable shared Types T ps Expressions e let px=e in \ne e.m(e) v v.f v.f=e match(e){(s=>e;)+} new s {(e;)+}Variables v this x Figure 7. Core language syntax. \ns, f, m, and x are identi.ers.  3.2 Static Semantics We introduce our static semantics by formalizing \nthe notions of states and permissions. We then de.ne the ways that permissions are manipulated and show \nhow the .ow of permissions is integrated into the type system. States: States take the place of standard \ntypes in our system. Fig\u00adure 8 gives the judgments and rules relating to states. P .s says a state is \nvalid if it is declared in P . P .s . s ' says that s is a sub\u00adstate of s ' . Substate relations are \nde.ned by the case of relation from the state de.nitions, re.exivity, and transitivity. TYPE-STATE ' \n** state s case of s { FM } .P P .s P .s SUBSTATE ' ** state s case of s { FM } .P ' P .s .s ' P .s .s \nSUBSTATE-TRANSITIVE ' ''' SUBTYPE-REFLEXIVE P .s .sP .s .s P .s .s '' P .s .s Figure 8. Valid states \nand substates. SPLIT-UNIQUE-LOCAL ' '' unique .local s .borrow(unique, s, 1) p .p .p SPLIT-LOCAL local \ns .local s .borrow(local s, s, 0) SPLIT-LOCAL-INCREMENT SPLIT-NONE borrow(p, s, n).local s .borrow(p, \ns, n +1) p .none .p SPLIT-UNIQUE-SYMMETRIC SPLIT-SYMMETRIC unique .s .ss .s .s SPLIT-SYMMETRIC-LOCAL \nSPLIT-UNIQUE s .local s .s unique .unique .none Figure 9. Splitting variable permissions. Permissions: \nTo the set of source permissions we add an additional form needed to track local permissions so they \ncan be joined back to unique: p ::= .. . borrow(p, s, n), where n is a natural number. The borrow permission \nappears only in the context for a local variable or .eld that has had local permis\u00adsions split from it. \nInside borrow, p represents the original permis\u00adsion before the .rst split (unique or local s), s represents \nthe kind of local permission borrowed (immutable or shared), and n counts the number of borrowings. Splitting \nvariable permissions: The judgment p . p ' .p '' says that if variable v has permission p, then p ' can \nbe taken out of v leaving p '' in v. Figure 9 gives the rules for this judgment. No\u00adtice that SPLIT-UNIQUE-SYMMETRIC \npermanently splits unique into symmetric permissions, making it impossible to ever regain the unique \npermission. In contrast, the SPLIT-LOCAL-* rules pull a local permission and leave behind a borrow permission \nwhich will be turned back into the original permission when all the local permissions are returned. In \nthese rules, the count is set to re.ect the net gain in local permissions: splitting a local from a unique \ngenerates a new local, so the count starts at 1 (SPLIT-UNIQUE-LOCAL); pulling from an existing local \nre\u00adplaces the original local with a borrow, resulting in no net gain in local permissions, so the count \nstarts at 0 (SPLIT-LOCAL); taking a local from an existing borrow creates a new local and thus increments \nthe count (SPLIT-LOCAL-INCREMENT). Also, SPLIT-SYMMETRIC-LOCAL says we may pull local s out of s. However, \nwe can t get a non-local permission out of a local, so (in conjunction with the FIELD typing rule) we \ncan t store local permissions to the heap.  p1.p2 .p3 .p4 SPLIT-FIELD-UNIQUE p .p ' .p '' unique.p .p \n' .p '' SPLIT-FIELD-PRESERVE p .none p ' .p '' .p ' p.p ' .p '' .p ' SPLIT-FIELD-UNIQUE-SYMMETRIC s.unique \n.s .unique SPLIT-FIELD-LOCAL p .local s .p ' local s.p .local s .p ' SPLIT-FIELD-BORROW p ' .local s \n.p '' borrow(p, s, n).p ' .local s .p '' Figure 10. Splitting .eld permissions. JOIN-NOT-UNIQUE  '' \n''' p .unique p .p .p ' '' p .p .p ' '' p .p .p JOIN-NOT-SYMMETRIC ' ''' \u00ac.s.(p = s .p = s) p .p .p ' \n'' p .p .p Figure 11. Joining permissions. Splitting .eld permissions: The judgment p1.p2 . p3 .p4 says \nthat if variable v has permission p1, and .eld v.f has permission p2, then permission p3 can be taken \nout of f, leaving p4 behind. Figure 10 gives the rules. If the variable permission is unique, we can \nsplit permissions from the .eld as if it were a variable (SPLIT-FIELD-UNIQUE), possibly unpacking the \n.eld. Otherwise, we allow splitting in three cases. First, if the variable permission is not none, then \nwe can do any splitting allowed for variables that preserves the original .eld permission (SPLIT-FIELD-PRESERVE). \nSecond, if the variable permission is s, then we can take permission s out of a unique .eld v.f without \nunpacking the object (SPLIT-FIELD-UNIQUE-SYMMETRIC). This issound because allother ref\u00aderences to the \nobject must have permission s for the remainder of program execution, and so all other accesses will \nconsistently see the .eld with permission s. Third, if the variable permission is local or borrow, then \nwe can take a matching local permis\u00adsion out of a .eld with unique or borrow permission (SPLIT-FIELD-LOCAL, \nSPLIT-FIELD-BORROW). This is sound because all local permissions to the object and to the .eld must go \nout of scope before a unique permission to the object can be regained. In the mean time, all references \nto the object and to the .eld have compatible local or borrow permissions. Joining permissions: The judgment \np .p ' .p '' says that permis\u00adsions p and p ' may be joined to form permission p '' . The joining rules, \ngiven in Figure 11, are very simple: we just reverse all the variable splitting rules, except for SPLIT-UNIQUE-SYMMETRIC, \nwhich can t be undone. Linear Context: To track permission .ow, our typing rules use a linear context. \nIt is similar to a standard typing environment, except that it maps variables to types that include a \npermission that may change over the course of typing. The linear context . is de.ned as follows, where \ni is chosen from an arbitrary set of identi.ers: . ::= \u00d8 v :(T ;.), .. ::= \u00d8 f :(p, i), . For each variable \nv in scope, . stores a type T = ps and a set . containing the unpacked state f :(p ' ,i) of the .elds \nf in the state s. A .eld f :(p ' ,i).. records two pieces of information. First, p ' indicates the current \npermission in the .eld. f will only appear in RESTORE-EMPTY ' P ; .; p .:.P ; .; p .\u00a3 * :. RESTORE-VAR \nRESTORE-VAR-ABSENT ' ' ''' .= v :(ps;.), . p .p .p \u00ac.T, ..(v :(T ;.)..) ''''' ' P ; v :(ps;.), .; p .\u00a3 \n* :. P ; .; p .\u00a3 * :. *'' *' P ; .; p .\u00a3 ,v :. P ; .; p .\u00a3 ,v :. RESTORE-FIELD-PACKED ' v :(T ;.).. packed(f, \n.) P ; .; p .\u00a3 * :. *' P ; .; p .\u00a3, (v.f,i):. RESTORE-FIELD-STALE '' ' v :(T ;.,f :(p ,j)).. i .jP ; \n.; p .\u00a3 * :. *' P ; .; p .\u00a3, (v.f,i):. RESTORE-FIELD-UNPACKED ' '' .= v :(ps;.,f :(p2,i)), . .eld-type(P, \ns, f) = ps ' ''' p1 .p2 .p3 p3 .pP ; v :(ps;.,f :(p3,i)), .; p1 .\u00a3 * :. * '' P ; .; p1 .\u00a3, (v.f,i):. \nRESTORE-FIELD-PACK '' .= v :(ps;.,f :(p2,i)), . .eld-type(P, s, f) = p3 s ' '' p1 .p2 .p3 P ; v :(ps;.), \n.; p1 .\u00a3 * :. * '' P ; .; p1 .\u00a3, (v.f,i):. Figure 12. Restoring permissions. The predicate packed(f, \n.) is true if no binding for f appears in .. .eld-type(P, s, f) = T says that .eld f is de.ned in state \ns with type T in the program P . ' the unpacked state of v if p is distinct from the declared permission \nof the .eld f in the state of v. Second, the object identi.er i is used to prevent the restoration of \npermissions from one object to another object. For any v :(T ;.). . and .eld f declared in the state \nof v, if there exists f :(p, i). ., then we say the .eld f of v is unpacked ; otherwise we say the .eld \nf of v is packed. By extension, if .= \u00d8, then we say the object pointed to by v (or just v) is packed; \notherwise it is unpacked. Restoring Permissions: At certain points in the typing, permis\u00adsions .ow back \ninto the linear context, such as when a let-bound variable goes out of scope. We restore permissions \nto a source lo\u00adcation list consisting of zero or more elements e: \u00a3 ::= v (v.f,i). Each element e stores \na location to restore to (either a variable v or a .eld v.f ). For .elds v.f, the identi.ers i ensure \nthat we restore permissions only to .elds that have not been assigned to since the permission was taken \nout. We use a list because match expressions may report different source locations for each case. However, \nwe do not allow duplicates in the list. The judgment for restoring permissions is P ; .; p .e * :. ' \n. It says that if we start with context . and join permission p with the permission in each location \nin e * , then we get a new context . ' . Figure 12 gives the rules for this judgment. If the next element \nin the source location list is a variable appearing in the context, then we restore the permission to \nit (RESTORE-VAR). Because we do not check that all of the locations in a source location list remain \nvalid when passed outside of a let scope, it is possible that the variable may not be in the context \nto return to, in which case we do nothing (RESTORE-VAR-ABSENT). When restoring to a .eld, there are several \ncases to consider. If the .eld is already packed, this means that pulling the per\u00admission did not unpack \nthe .eld (left it unchanged) or the .eld was reassigned since the permission was pulled, so we do noth\u00ading \n(RESTORE-FIELD-PACKED). If the .eld is unpacked, and the  MERGE-PACKED MERGE-ONE-UNPACKED p1 .p3 .p2 \n.p2 = none . .\u00d8 p1 .p3 .p2 .p2 = none .3 = merge(.1, .2) v :(p2 s; \u00d8) = merge(v :(p1 s; \u00d8),v :(p2 s; \n\u00d8)) v :(p2 s, .) = merge(v :(p1 s; \u00d8),v :(p2 s;.)) MERGE-UNPACKED-EQUAL v :(p1 s, .3) = merge(v :(p1 \ns;.1),v :(p1 s;.2)) p1.p2 .p4 .p3 .p3 = none v :(p1 s;.3,f :(p3,i)) = merge(v :(p1 s;.1,f :(p2,i)),v \n:(p1 s;.2,f :(p3,i)) MERGE-UNPACKED-UNEQUAL v :(p1 s, .3) = merge(v :(p1 s;.1),v :(p1 s;.2)) p1.p2 .p4 \n.p3 .p3 = none i1 .i2 fresh(i3) v :(p1 s;.3,f :(p3,i3)) = merge(v :(p1 s;.1,f :(p2,i1)),v :(p1 s;.2,f \n:(p3,i2)) Figure 13. Merging contexts in typing match (selected rules). identi.ers in the context and \nthe source location don t match, then we also do nothing (RESTORE-FIELD-STALE). This occurs when an expression \nin an inner scope assigns to the .eld and then later unpacks it again, meaning the returned permission \nrepresents a per\u00admission to a different object than is in the .eld. If f is unpacked, and the identi.ers \nmatch, then there are two cases. First, if restoring the permission doesn t leave a permission equal \nto the declared permission for f , then we update the unpacked state (RESTORE-FIELD-UNPACKED). Otherwise \nwe pack up the .eld (RESTORE-FIELD-PACK) by removing it from .. Notice we don t consider the case where \nv.f appears in the location list but v doesn t appear in the context. Why not? There are two ways this \ncould happen: either v.f is returned as the value of the let expression that declares v, or v.f is returned \nas the value of a method body, where v is this or the method formal parameter. In either case v must \nbe packed after the evaluation of v.f (rules METHOD in Figure 15 and LET in Figure 14). Therefore, v.f \ncan not appear in the source location list (see rule FIELD-ACCESS-PACKED in Figure 14). Merging Contexts: \nEach case in a match expression may up\u00addate the permissions in the context in a different way. The merge \njudgment from Figure 13 de.nes how to combine two contexts into a more general context that can be soundly \nused to type subsequent expressions regardless of which case is actually executed. We pro\u00advide only the \nimportant rules for merging contexts .1 and .2; the rest of the rules are about pulling apart the contexts \nand comparing elements. In summary we use the following rules for merging the two context entries for \na variable v: 1. If v is packed in both .1 and .2 (MERGE-PACKED), then we choose the weaker permission. \nWe de.ne p1 to be weaker than p2 if p1 is none or there exists p such that p2 . p .p1. If neither permission \nis weaker than the other, then the contexts are inconsistent and typing fails. 2. If v is unpacked in \nboth contexts, then we require it to have the same permission in both, and we use the .eld splitting \nrules to .nd the weaker of the two .eld permissions. If the identi.er i associated with the unpacked \n.eld is the same in both contexts, then we pass it through (MERGE-UNPACKED-EQUAL), but if it is different \nwe generate a fresh identi.er (MERGE-UNPACKED-UNEQUAL). This is correct but conservative because it guaran\u00adtees \nthat no permission restore will occur to the location.  3. If v isunpackedinonlyonecontext (MERGE-ONE-UNPACKED), \nthen we use the unpacked element, but we check that the un\u00adpacked permission for v is weaker than the \npacked one. Other\u00adwise, we would have to pull a permission out of an unpacked object, which is not allowed \nin this language.  Expressions: Permissions are pulled out of the linear context by typing expressions. \nThe judgment P ; .; p . e : s;. ' ; e * takes the starting context ., a needed permission p, and an expression \ne that speci.es where p could be pulled from. It produces the state s of the expression, an updated context \n. ' , and a source location list e * that contains all the possible locations in the context that the \npermission p may have been pulled from. The exact location is not statically known because which branch \nof a match expression is executed is determined at runtime. Figure 14 gives the rules for typing expressions \nwhich we now summarize. Let: We use the permission p ' declared for x to type e, obtaining state s, a \ncontext . ' , and a source location list e * . Then we use the needed permission p of the whole expression \nto type e ' in the context . ' augmented by the type binding for x. This produces an updated context \n. '' where x is left with permission p '' , and '* a source location list e . We require that x be packed \nbecause it is going out of scope. We restore p '' to e * , the locations that the permission for x may \nhave been pulled from, which generates a .nal context . ''' that is returned along with the state and \nsource locations from the body. Match: For a single-case match, we type e with a needed permis\u00adsion none \nyielding some state s and an updated context . ' . We disregard the source location lists since returning \nnone is a no-op. We ensure that the state s has a common superstate with the state sc named in the case. \nThis ensures that sc is a potentially valid state ' of e. Using . and the needed permission for the entire \nexpression, we type e ' to get the state s ' and source location list e * which are reported as the result \nof the case. For a multiple-case match, we recursively check the match with all but the .rst case. Then \nwe check the match with the remaining case in isolation using the original context. Finally, we return \nthe the least upper bound of the resulting states, the merged contexts, and the union of the source location \nlists from the .rst case and the remaining cases. Method invocation: We type e in the input context with \nneeded permission p1 yielding a state s1 and a context .2.3 Next we look up the method named m in state \ns1. This gives us the permission p2 required for the argument. We use p2 to type e ' in the context ' \n.2, which yields a state s2 and a context .3. Now we check that ' s2 conforms to the method parameter \nstate s2. Then we check that needed permission p can be extracted from the permission p3 returned by \nthe method. We generate the output context .5 by restoring the output permissions speci.ed for the argument \nand receiver in the method signature to their respective source location lists. The outgoing source location \nlist is empty because our system does not track what locations the permissions returned from method calls \ncan come from. Variables: We require that v is packed, because its value may be assigned to another variable \nor stored on the heap. We also check that the existing permission can be split to give the needed permis\u00ad \n3 p1 is the needed permission for the receiver as determined by the signature of the method m in the \nstate s1 of the expression e. This permission can be determined by a pre-pass that ignores permissions \nand just gathers state information for all variables.  LET ' '* ' ' '''' '' '* '''' ''' P ; .; p .e \n:s;. ; \u00a3P ;. ,x :(ps; \u00d8); p .e :s ;. ,x :(ps; \u00d8); \u00a3P ;. ; p .\u00a3 * :. '* ' ' ' ''''* P ; .; p .e :s;. ; \n\u00a3 P ; .; p .let px = e in e :s ;. ; \u00a3 MATCH-SINGLE '* P ; .; none .e :s;. ; \u00a3 ' ' ' '''* .sl.P .sl = \nlub(s, sc) P ;. ; p .e :s ;. ; \u00a3 ' ' '''* P ; .; p .match(e){sc=>e ;} :s ;. ; \u00a3 INVOKE * P ;.1; p1 .e \n:s1;.2; \u00a3 ' ''' method(P, s1,m) = p3 s3 m(p2>>p2 s2 x) p1>>p { e } P ;.2; p2 .e :s2;.3; \u00a3 1 ''' ' P \n.s .s2 p3 .p .pP ;.3; p .\u00a3 '* :.4 P ;.4; p .\u00a3 * :.5 2 21 ' P ;.1; p .e.m(e ) :s3;.5; \u00d8 FIELD-ACCESS-PACKED \n' v :(ps;.).. packed(f, .) ''' ''' '' .eld-type(P, s, f) = ps p .p .p .p ' P ; .; p .v.f :s ; .; \u00d8 FIELD-ACCESS-UNPACKED \n' FIELD-ACCESS-UNPACK ' .=. ,v :(p1 s;.,f :(p2,i)) .eld-type(P, s, f) = p3 s '' ' p1.p2 .p4 .p5 . =. \n,v :(p1 s;.,f :(p5,i)) ' '' P ; .; p4 .v.f :s ;. ; (v.f,i) FIELD-ASSIGN-UNPACKED v :(p1 s1;.).. .eld-type(P, \ns1,f) = p2 s2 ' .1 =.2,v :(p3 s1;. ,f :(p4,i)) assignable(p3) P .s3 .s2 SEQUENCE-SINGLE '* P ; .; p .e \n:s;. ; \u00a3 '* P ; .; p .{e;} :s;. ; \u00a3 Figure 14. Typing expressions. P .s = lub(s ' MATCH-MULTIPLE * P \n; .; p .match(e){(sc=>e1;)+} :s1;.1; \u00a31 '* P ; .; p .match(e){s =>e2;} :s2;.2; \u00a32 c * ** P .s3 = lub(s1,s2) \n.3 = merge(.1, .2) \u00a3 = \u00a3 .\u00a3 3 12 '* P ; .; p .match(e){(sc=>e1;)+ s =>e2;} :s3;.3; \u00a3 .=. ,v :(p1 s;.) \npacked(f, .) .eld-type(P, s, f) = p2 s '' ' p1.p2 .p3 .p4 p2 .p4 fresh(i) . =. ,v :(p1 s;.,f :(p4,i)) \n' '' P ; .; p3 .v.f :s ;. ; (v.f,i) FIELD-ASSIGN-PACKED ' '' '* c 3 VAR '' .=. ,v :(ps; \u00d8) ' '' ''' \n'' p .p .p . =. ,v :(ps; \u00d8) '' P ; .; p .v :s;. ; v ' v :(p1 s1;.).. .eld-type(P, s1,f) = p2 s2 '* ' \n P ; .; p2 .e :s3;. ; \u00a3v :(p3 s1;. ').. assignable(p3) ''' '' packed(f, . ') P .s3 .s2 p2 .p .p2 . =. \n,v :(p3 s1;. ') ''' P ; .; p .v.f=e :s3;. ; \u00d8 * P ; .; p2 .e :s3;.1; \u00a3 p2 .p .p2 .3 =.2,v :(p3 s1;. \n') NEW P . s P ; .; p .v.f=e :s3;.3; \u00d8 P ; .; p .new s :s; .; \u00d8 SEQUENCE-MULTIPLE '* ' '''''* P ; \n.; none .{(e;)+} :s;. ; \u00a3P ;. ; p .{e ;} :s ;. ; \u00a3 ' ' '''* P ; .; p .{(e;)+ e ;} :s ;. ; \u00a3 ,s '') means \ns is the least state that is a superstate of both s ' and s '' . method(P, s, m) = M means that M is \nthe method named m de.ned in state s for program P , and .eld-type(P, s, f) = T similarly produces the \ntype T of .eld f from s in P . The predicate assignable(p) holds if p is not none, immutable, local immutable, \nor borrow(local immutable, immutable,n). packed(f, .) means \u00ac.(p, i).(f :(p, i)..). sion, and we leave \nthe residue in the type reported in the outgoing context. The source expression list contains only the \nvariable itself. Field access: We start by .nding the type of v in the context and then get the de.ned \ntype of .eld f in its state s. Since we are only accessing the .eld of v, we do not update the permission \nof v. However, we may need to update the unpacked state of f in v. If f starts packed in v s type, then \nthere are two cases to handle. First, if we can take the required permission out of the .eld and leave \nthe same permission behind, then we leave the object packed (FIELD-ACCESS-PACKED). The source expression \nlist is empty because no permission needs to be restored to a .eld that is packed. Second, if we need \nto leave a different residual permission, then we unpack the .eld, leaving the residual permission behind \n(FIELD-ACCESS-UNPACK). We also generate a fresh identi.er i and report (v.f,i)as the source location \nlist. If f is already unpacked in v, then we split the needed permission from the current .eld permission, \nand replace the current permission in the unpacked .eld state with the residual permission (FIELD-ACCESS-UNPACKED). \nWe report (v.f,i) as the source location, using the existing identi.er i. Field assignment: If v.f is \npacked, then to assign e to it we (1) look in the context to get the permission we need for the .eld; \n(2) type e; (3) check that we have writable permission to v in the resulting context; and (4) check that \nthe states match (FIELD-ASSIGN-PACKED). We also ensure that the permission we need can be split off from \nthe permission needed by the .eld, while retaining the .eld permission. If v.f is unpacked, then we do \nthe same thing, but we pack up f at the end (FIELD-ASSIGN-UNPACKED). In both cases, we do not need to \nreturn permissions to the source locations of e because what s left after assigning to v.f must be none \nor symmetric and returning either is a no-op. For the same reason, the returned source location list \nis empty. Object creation and expression sequence: These rules are straight\u00adforward. In SEQUENCE-MULTIPLE, \nnotice that we pull the needed permission only for the last element in the sequence, whose value is returned \nby evaluating the expression; we pull none from the rest of the expressions in the sequence. For example, \nif x is unique, it is legal to request a unique permission from the expression {x;x;x;}, because unique \nis only pulled from the last x. Since returning a none permission is a no-op, we can safely discard the \nsource location lists for these expressions. Top-Level Program Structure: Figure 15 gives the rules for \ntyp\u00ading programs, states, .elds, and methods. In rule PROGRAM we type the main expression with a needed \npermission none, because no permission to the result is needed after program execution is complete. In \nrule FIELD we type the initializer expression in the empty environment to ensure that this isn t stored \nto the heap by a new expression. Also, we require that user-declared .eld types cannot be declared with \nlocal permissions (borrow permissions are also excluded because they cannot appear in the source). This \nrestriction ensures that a local permission is never assigned to the  P .F PROGRAM STATE * * ' '''*'* \nP = Se .S .S.(P .S) state s case of s { FM } .P * ** P ; \u00d8; none .e :s; \u00d8; \u00a3 .F .F.(P .F ).M .M.(P, s \n.M) ' * * .P .P P .S P .state s case of s { FM } METHOD P .sP . FIELD s2 ' '* T = ps P .s \u00ac.s.(p = \nlocal s) .= this :(p1 s1; \u00d8),x :(p2 s2; \u00d8) P ; .; p .e :s, .; \u00a3 '*' ' ''' P ; \u00d8; p .e :s ; \u00d8; \u00a3P .s .s \nthis :(ps1; \u00d8),x :(ps2; \u00d8).. P .s .s 12 '' P .Tf=e; P, s .M P, s1 .ps m(p2>>ps2 x) p1>>p { e } 21 Figure \n15. Programs, states, .elds, and methods. heap. In rule METHOD we check that the return type and parame\u00adters \nare valid. We check that the method body types in the context created by binding the method receiver \nand parameter to their types and that the resulting state is a substate of the return state. We re\u00adquire \nthat the parameter and receiver be packed in the the output ' ' context . and also that their permissions \nin . agree with the out\u00adput permissions given by their change types. For simplicity, we implicitly disallow \noverriding, shadowing, and/or overloading of .elds and methods. We also disallow cycles in the inheritance \nhierarchy and treat the set of states as a forest of trees, where a state s is a root if it has itself \nas a parent.  3.3 Dynamic Semantics An execution state H; e includes a heap H and an expression e. Heap: \nOur model of the heap H is a partial function from object references to object identi.ers and from object \nidenti.ers to ob\u00adjects. The addition of object references provide an additional level of indirection \nthat allows us to explicitly track and reason about dif\u00adferent aliases to a single object as in [28]. \nThese serve a formal pur\u00adpose only and are not necessary in an implementation. Consistent with this indirection, \nthe .elds of an object dF * map .eld names to object references. Every object reference in dom(H) maps \nto an object identi.er except the special reference null, which is used during object initialization. \nH ::= null o .O,H O .s{dF *},H dF ::= f .o Expressions: We enhance our expression language to support \npartially-executed programs. We add object references o as well as the new form alias(o) as expressions. \nalias(o) gives com\u00adputational meaning to splitting a permission of o by creating a new alias to hold \nthe split permission. As alias expressions will be substituted for bound variables in let bodies, we \nallow them to ap\u00adpear wherever variables can. Finally, we add a partial let form that keeps track of \nthe scope in which an object reference o is bound. e ::= ... o alias(o) alias(o).f alias(o).f = e let \no in e Reduction Rules: We formalize program execution using a small step operational semantics. Given \na program P , the reduction rules shown in Figure 16 take one execution state to another. Congruence: \nWe specify reduction of subexpressions using an eval\u00aduation context E de.ned below: E ::= . let px=E \nin e let o in E match(E){(s=>e;)+} E.m(e) o.m(E) alias(o).f=E {E; (e;)* } As usual, .is a hole that is \n.lled in with the subexpression under evaluation to construct the entire expression being evaluated. \nAlias: Reducing an alias(o) expression creates a fresh object reference that points to the same object \nidenti.er as the original object reference. Let: Once the bound expression is reduced to an object reference \no we substitute alias(o) for all occurrences of the bound variable x in the body. Thus, any use of x \nin the body must create a fresh alias. We also keep track of the scope of o by reducing to the partial \nlet form. Once the body of a partial let has been evaluated to an object reference we remove the scoping \nannotation. Match: Once the selector expression becomes an object reference o, we select the .rst match \ncase, if any, that is a superstate of the state of o. If there is no match, then execution gets stuck. \nMethod invocation: Once we have object references for the receiver and argument of the method, we substitute \nthe method body sur\u00adrounded by let expressions binding the receiver and argument. This allows let reduction \nto handle the substitution and scoping. Object creation: We create a new object identi.er O and give \nits .elds the reference null, which will be replaced by the proper values after running the initializer \nexpressions. We reduce to a sequence expression which initializes each .eld of the object in turn through \na fresh object reference o. The .nal expression in the sequence returns o. Field access and assignment: \nA .eld access evaluates to a fresh alias to the object reference the heap associates with the .eld. Field \nassignment replaces the object reference in the .eld with object reference from evaluating the right-hand \nside. It returns a fresh alias of this same reference. Since we do not use the target of the .eld read \nor assignment except to access its .eld, we do not need a new alias to it, so we leave the alias(o) in \nthe target unevaluated. Sequence: Each expression in the sequence is evaluated in order until there are \nno further expressions at which point the sequence is reduced to the object reference resulting from \nthe reduction of the .nal expression.  3.4 Soundness Results In this section, we present the main soundness \nresults and support\u00ading de.nitions for our system. Our technical report [23] contains the full de.nitions \nand proofs. Typing of Dynamic Expressions: We state and prove soundness in terms of a standard dynamic \ntyping. To do this, we need rules for typing object references, alias expressions, and partial lets. \nFirst, we enhance the de.nition of the linear context to map object references to types. We also add \nentries of the form e .o to the context which indicate that o returns its permission to the source location \ne when it leaves scope. We will also want to be able to return permissions to object references, so we \nextend the de.nition of source locations to include them. . ::= ... o :(p s, .), . \u00a3 .o, . \u00a3 ::= ... \no (o.f,i)  E-CONGRUENCE E-ALIAS '' '' ''' P .H; e .H ; eH = H ,o .Oo ./ dom(H) H = H, o .O '' ' ''' \n P .H; e .H ; e P .H; E[e].H ; E[e '] P .H; alias(o) .H ; o E-LET-BODY ' ' '' E-LET-BINDING H = H ,o \n.O P .H; let px = o in e .H; let o in e[x .alias(o)] P .H; let o in o .H ; o E-MATCH E-INVOKE '' H = \nH ,o .OH = H ,o .O, O .s{dF *} ' ''' O .s{dF *}.HP .s .sj \u00ac.k .[1,j -1].(P .s .sk) method(P, s, m) = \np3 sm(p2>>p sx) p1>>p { e } 21 '' ' P .H; match o {(si .ei)i.[1,n]}.H ; ej P .H; o.m(o ) .H; let p1 \nthis=o in let p2 x=o in e E-FIELD E-ASSIGN ' '' ''''''' *'''} H = H ,o .O, O .s{dF, f .o '},o .OH; alias(o \n) .H ; oH = H ,o .O, O .s{dF ,f .o '' '' ''' ''''' * o ./ dom(H) H = H, o .OH = H ,o .O, O .s{dF ,f .o \n'} '''' ' ''''' P .H; alias(o).f .H ; oP .H; alias(o).f=o .H ; o E-NEW '* state s case of s { (pi si \nfi =ei)i.[1,n] M } .P E-SEQUENCE-MULTIPLE '' o, O /.dom(H) H = H, o .O, O .s{(fi .null)i.[1,n]} E-SEQUENCE-SINGLE \nH = H ,o .O '' P .H; new s .H ; {(alias(o).fi = ei;)i.[1,n] o;} P .H; {o;} .H; oP .H; {o; (e;)+} .H ; \n{(e;)+} Figure 16. Reduction rules. ALIAS OBJECT-REF '' ' ''''''' '' ' ''''' .=. ,o :(ps; \u00d8) p .p .p \n. =. ,o :(ps; \u00d8) .=. ,o :(ps; \u00d8),\u00a3 .op .p .p . =. ,\u00a3 .o '' '' P ; .; p .alias(o):s;. ; oP ; .; p .o :s;. \n; \u00a3 ALIAS-FIELD-ACCESS ALIAS-FIELD-ASSIGN '' ''''); \u00a3 * '' ' '''''); \u00d8 x /.dom(.) P ;.,x :(p s, . '); \np .x.f :s;.,x :(p s, . x ./ dom(.) P ;.,x :(p s, . '); p .x.f = e :s;. ,x :(p s, . '' ''''); \u00a3 *[x .'' \n' '''''); \u00d8 P ;.,o :(p s, . '); p .alias(o).f :s;.,o :(p s, . o] P ;.,o :(p s, . '); p .alias(o).f = \ne :s;. ,o :(p s, . LET-PARTIAL ' '' '' ''' * '''' ''' .=. ,o :(p s, . '),\u00a3 .oP ; .; p .e :ps;. ,o :(p \ns, \u00d8),\u00a3 .o; \u00a3P ;. ,p .\u00a3 :. ''' * P ; .; p .let o in e :s;. ; \u00a3 Figure 17. Intermediate typing rules. \nThe rules for typing partial expressions are found in Figure 17. The ALIAS rule says that typing alias(o) \nproceeds by typing o like a variable. In particular, the source location is o. A raw object reference \no is typed using rule OBJECT-REF which is also similar to the VAR rule with two important exceptions. \nFirst, we look in the context to .nd the return location speci.ed for o. This is because we need to maintain \nthe typing after an alias expression steps ' to an object reference. In particular, after alias(o) steps \nto o , typing o ' should still return o as the source location. Second, the binding for the type of o \nis removed from the outgoing context to ensure that o is not used later in the program which would break \nour model of execution where each variable and .eld is tracked as a separate object reference. To type \na .eld read or assignment after an alias has been substituted for the target variable ALIAS-FIELD* undoes \nthe substitution with a fresh variable x that replaces alias(o). We give x the type of o from the context \nwhen typing the updated expression and then return the resulting outputs with o put back for x in the \ncontext and source location list. LET-PARTIAL assumes the scoped object reference o is already in the \ncontext along with a return location for it. After the body is typed, the remaining permission to o is \nrestored to its return location. Soundness Judgments: Figure 18 shows the soundness judgments for the \nsystem. P ; .; p . H; e : ps; * is the top-level judg\u00ad .; e ment and says that the runtime environment \nH; e is well-typed with respect to a a program P , a context ., and a permission p. The premises of this \njudgment are as follows. First, the context and the heap must map the same set of object references. \nSecond, the incoming context must be able to be partitioned into two distinct parts: .e to type the expression \n(which produces the outputs of the judgment), and .f which contains all of the object references stored \nin .elds f in H. Third, three invariants must hold for the context and the heap: (1) consistent object \npermissions, (2) consis\u00adtent object references, and (3) distinct .elds. Consistent object permissions: \nThe key soundness condition of our system is that for each O, the set of references o that point to it \nmust have consistent permissions in .. This condition captures the meaning of the permissions in our \nsystem. Figure 19 de.nes this consistency condition. The judgment perms(., H, O) = [p *]forms the list \nof all the permissions p given to object references o that point to O in H. The judgment [p *] consistent \nplaces three requirements on this list: (1) if unique appears in the list, then it appears only once, \nand all other permissions are none; (2) if a borrow(unique, s, n) permission appears in the list, then \nthe number of local s permissions must match the sum of the counts of all borrow permissions in the list; \nand (3) no list may contain both shared and immutable permissions (including the local and borrow versions). \nConsistent object references: Object references must also be inter\u00adnally consistent. We say that P ; \n.; H .o ok if the representation of the object reference o in H is consistent with the type of o in \n  ENV-OK * {oo .dom(H)} = {oo .dom(.)} .=.e, .f P ;.e; p .e :ps; .f .H distinct .elds .; \u00a3 .o .dom(H). \n(P ; .; H .o ok).O .dom(H). (perms(., H, O) consistent) * P ; .; p .H; e :ps; .; \u00a3 P ; .; H .o ok * P \n; .; p .H; e :ps; .; \u00a3 OBJ-REF-OK ' o :(p s, .).. o .O, O .s '{dF *}.HP .s .s '' f .of .dF * . pf sf \n= dyn-.eld-type(P, s, f, .). of :(pf sf , .f ).. . .f ..elds(P, s). ( '' ' ) P .s .sf . pf ,p .validFieldPerms \n. p p.pf ff f P ; .; H .o ok FIELD-FULFILLED '' .p .{ps .pr.po.pf .ps .pr}..p .p .p .p p po.pf DISTINCT-FIELDS \n * ' '*' '' O .s{dF ,f .o}.H .O .s '{dF ,f .o}.H . o .dom(.).O = O .f == f . .H distinct .elds p po.pf \n. .H distinct .elds Figure 18. Soundness judgments. dyn-.eld-type(P, s, f, .) reports the permission \nfor f in . if it is recorded there, otherwise the declared permission of f in state s. The set validFieldPerms \nexcludes permissions of the form local s and borrow(local s, s, n). PERMS-NO-MATCH \u00ac.o .dom(H).o .O .H \nperms(., H, O) = [p *] perms(., H, O) = [] PERMS-MATCH ' ''*] H = o .O,H o :(p s, .).. perms(.,H ,O) \n= [p perms(., H, O) = [p]++[p '*] C-UNIQUE [p *] consistent [(none)*]++unique consistent C-BORROWUNIQUE \nL = [(local s)*] m ' B = [(borrow(local s, s, ni))i.[1,m]] m =0 n +. ni = L i=1 [(none)*]++L ++B ++[borrow(unique, \ns, n ')] consistent C-GENERAL L = [(local s)*] B = [(borrow(local s, s, n))*] [(none)*]++L ++[(s)*]++B \nconsistent Figure 19. Permission lists and consistent permissions. The nota\u00adtion L = [p *] means that \nL is a list of permissions (with duplicates allowed). The symbol ++denotes list concatenation. .. For \nthe representation to be valid we .rst need the actual states of the object and its .elds to be substates \nof the states given by the type of o. Second, we do not allow a permission local s or borrow(local s, \ns, n) to appear as the permission in a .eld or as the permission to an object reference that represents \na .eld. This maintains our invariant that local permissions never appear in the heap. Finally, we require \nthat any permission that can be pulled from a .eld f of the state s through o can also be pulled from \nthe permission of the object reference that represents the .eld in H. Given the .eld type po.pf of f \nin o, we say that pr ful.lls po.pf (represented by pr b po.pf ) if any permission that can be split from \npo.pf can also be split from pr. Both judgments are formal\u00adized in Figure 18. Distinct .elds: In order \nto carry out the typing of a partially eval\u00aduated expression we must ensure that no object reference \no ever appears (1) both in a .eld and in the expression being typed or (2) in two different .elds in \nH. Otherwise, typing one location could P ..1 ..2 CTX-WEAKER P ..1 ..2@p . .p :(p s, .)..2. () .f ..elds(P, \ns).P ..1 ..2@p.f P ..1 ..2 P ..1 ..2@p CTX-WEAKER-VAR p :(p1 s1;.1)..1 p :(p2 s2;.2)..2 p1 .p2 P .s1 \n.s2 P ..1 ..2@p P ..1 ..2@p.f CTX-WEAKER-FIELD p :(p1 s1;.1)..1 p :(p2 s2;.2)..2 '' '' dyn-.eld-type(P, \ns1, f, .1) = p dyn-.eld-type(P, s2, f, .2) = p 1 s12 s2 '' '' p .pP .s .s 12 12 P ..1 ..2@p.f PERM-WEAKER-NONE \np .p p .none PERM-WEAKER .p.p 1 .p .p2 PERM-WEAKER-BORROW p1 .p2 unique .borrow(unique, s, n) Figure \n20. Weaker contexts. Meta-variable p consists of v or o and .elds(P, s) lists the names of the .elds \nin state s. have a non-local impact on the permission in the other location that would be dif.cult to \ntrack. This invariant is captured formally by the judgment . .H distinct .elds in Figure 18. Weaker Contexts: \nAs an expression is evaluated, speci.c paths of execution are chosen, reducing the number of possible \nfuture ex\u00adecution states. Consequently, the context produced by typing the updated expression gives a \nmore precise view of the states and per\u00admissions of locations in the program when compared to the context \nproduced by typing the original expression. For instance, if step\u00ad ' ping from e to e reduces away a \nmatch expression, then there may be locations that have permissions pulled from them when typing e but \nnot when typing e ' . This leaves more permissions in the result\u00ading context. We introduce the weaker \nrelationship between contexts to account for this increase in permissions.  The judgment P . .1 . .2 \nshown in Figure 20 states that .2 is weaker than .1. The judgment holds if we can transform .1 into .2 \nby making speci.c changes to the state and permission at each location (variable or .eld) appearing in \nboth .1 and .2. We allow the type of a location in .1 to be replaced in .2 with a type containing a superstate \nand a weaker permission (p . p). none is weaker than any permission (PERM-WEAKER-NONE). Otherwise, for \npermission p2 to be weaker than p1, there must exist a single permission p that can be pulled from p1 \nsuch that the residue is p2 (PERM-WEAKER). We also admit the special case where p1 is unique and p2 is \na borrow permission (PERM-WEAKER-BORROW). This can occur, for instance, if a .eld with a borrow permission \nis reassigned in the chosen brach of a match. Progress and Preservation: We use these de.nitions to state \nthe soundness of our system via standard progress and preservation theorems. s; e = o or P . H; e . H \n' ; e ' or execution is stuck at a match statement where the matched expression has been evaluated to \nan object, but there is no matching case. Theorem 3.1 (Progress). If P ; .; p .H; e : .; e * , then either \ns; P .H; e .H ' ; e ' , then there exists . ' such that Theorem 3.2 (Preservation). If P ; .; p . H; \ne : .; e * , and ' '''' ' ' 1. P ;. ; p .H ; e :s ;. ; e '* with P .. .. and P .s .s 2. P ; * \\e :. \nr where P .. .. r .; p .(e '*) ' The .rst condition of preservation requires that the new envi\u00adronment \nafter reduction is still well-formed, with the extra restric\u00adtion that the context . generated by typing \nthe old expression e must be weaker than the context . ' produced by typing the up\u00addated expression e \n' . However, this is not strong enough because it does not account for the permissions that were pulled \nout as a part of typechecking which may be returned to the context later. The second condition provides \nthe extra power we need. Consider the source location list e * \\ e '* representing all the source locations \nfrom which the needed permission p was pulled when typing e but that were not used to get p when typing \ne ' . There is potentially ' more permission at these locations in . than in . because p was not split \nfrom them during the typing of e ' . However, are we guar\u00adanteed that if we restore the pulled permission \nto these locations in . using the judgment de.ned in Figure 12, the resulting context .r is still weaker \nthan . ' ? The second condition of preservation says, Yes. This fact is necessary to prove the weakening \ncondi\u00adtion on . ' from the .rst condition in some cases such as when E-CONGRUENCE is used to reduce a \nlet expression. This and other details of the proof of safety are discussed in our accompanying technical \nreport [23]. 4. Related Work Wadler .rst introduced the concept of temporarily converting a linear (unique) \nreference into a non-linear reference using the let! construct [27]. Other early uniqueness type systems \nbuilt on his work and added support for borrowing as a special anno\u00adtation, such as borrowed or lent \n[1, 19, 22]. While convenient, these systems did not support borrowing immutable pointers, and generally \nprovided weak guarantees: multiple borrowed pointers could co-exist and interfere with one another. Boyland \ndevised alias burying to address this issue, using shape analysis to ensure that whenever a unique variable \nwas read, all aliases to it were dead (or buried ) [7]. While this approach works well in an analysis \ntool, it is inappropriate for a type system: programmers would have to understand a shape analysis to \ncomprehend and .x a type er\u00adror message. The authors of Plural [3], which also uses analysis to support \nborrowing, have observed this to be a problem in practice. In contrast, our system provides a more natural \nabstraction for rea\u00adsoning by modeling the .ow of permissions through locations in the source. Boyland \nproposed fractional permissions as a generalization of borrowing that does not require a stack discipline \nfor creating and destroying borrowed aliases [8]. Although fractions have received a lot of attention \nin the veri.cation community, we know of no prac\u00adtical tool support that leverages fractions possibly \nbecause pro\u00adgrammers .nd fractions an unintuitive abstraction. Instead, tools like Plural [3], Chalice \n[17], and VeriFast [21] provide abstractions (including borrowing) that hide fractions from users, but \nthe use of program analysis and theorem provers makes these systems less predictable and more dif.cult \nto understand than the type system presented here. Boyland and Retert later developed a type system that \nallows borrowing unique permissions [10]. Like our system, their system tracks permissions taken out \nof individual .elds using a technique they call carving. However, where they use a sub\u00adstructural logic \nfor tracking permissions, we use a more predictable linear context to type individual variables. One \nof the authors previously observed the importance of bor\u00adrowing for tracking permissions and presented \nthe .rst fraction\u00adfree permission type system we are aware of that supports borrow\u00ading unique and immutable \npermissions [2]. While the technical de\u00adtails are somewhat different, the system presented in [2], similar \nto this system, avoids fractions by counting split-off permissions in variable types. We propose local \npermissions to distinguish borrowed permissions syntactically, as well as none permissions, both of which \nremain implicit in [2]. Our system additionally sup\u00adports share permissions, match expressions and sequences, \nand our system tracks permissions taken out of individual .elds. Unlike [2], we provide a dynamic semantics \nand prove our system sound. Other programming languages have incorporated the ideas of uniqueness and \nborrowing into their type systems but use less .exible or more complicated mechanisms. The Clean programming \nlanguage [25] is a functional language with support for unique references. However, since the language \nis functional, there is no concept of returning permissions to a location as in our system. The Vault \nprogramming language [13] allows linear (unique) references to be split into guarded (immutable) types \nthat are valid in the scope of a key. Their use of type-level keys adds nota\u00adtional and algorithmic complexity \nto the scoping of borrowed per\u00admissions that we avoid by using our simpler local permissions. On the \nother hand, Vault supports adoption whereby a linear permis\u00adsion stored in a .eld of a non-linear object \ncan be treated linearly. Vault also includes annotations on methods that consume permis\u00adsions similar \nto our change permissions. However ours are strictly more .exible because in our richer set of permissions \nwe can spec\u00adify a partial return of a permission (e.g. unique>>immutable). The Cyclone language [18] \nhas a feature similar to Vault s keys. Cyclone also includes explicit support for borrowing through ref\u00aderence \ncounting that is similar to the mechanism that underlies our local permissions. However, unlike our approach, \nit is exposed to the programmer in the syntax. Also, Cyclone allows borrowing only for permissions stored \nin local variables; .eld accesses occur via swap, which is awkward. In contrast, we have designed a .eld \nunpacking mechanism that supports direct .eld access. Other recent work on the Plaid type system [28] \nintegrates permissions with typestate and uses change types, providing some of the expressiveness of \nour system. While this other work can express the publication example from Figure 4, it has very limited \nsupport for borrowing, and can only change .eld values with a swap operation, which is unnatural for \nprogrammers.  An alternative to borrowing is explicitly threading references from one call to another, \nas supported in Alms [26]. In this ap\u00adproach, the permission is tied to the reference; it is given up \nper\u00admanently when the reference is passed to a function, but the func\u00adtion may return the reference again \nalong with a permission. This approach is very clear and explicit, but it is quite awkward and fur\u00adthermore \nresults in additional writes when the result reference is re-assigned to the reference variable. Overall, \nthe system presented in this paper is distinguished by supporting natural programming and reasoning abstractions \ntogether with a broad set of permissions including immutable, unique, and shared. As a type system de.ned \nby local rules, it is easy for programmers to follow, and separating permission .ow from references makes \nit more succinct than systems in which ref\u00aderences must be threaded explicitly. We hope it will serve \nas a robust foundation for making permission-based programming lan\u00adguages such as Plaid practical enough \nfor widespread use. 5. Conclusion and Future Work We have described a new type system for .exible borrowing \nof unique, shared, and immutable permissions without explicit frac\u00adtions. As future work, we would like \nto integrate our borrowing mechanism with Plaid s typestate features, and gain experience us\u00ading the \ntype system on larger codebases. Acknowledgements This material is based upon work supported by the National \nScience Foundation under grant #CCF-1116907, Foundations of Permission-Based Object-Oriented Languages, \ngrant #CCF\u00ad0811592, Practical Typestate Veri.cation with Assume-Guarantee Reasoning, and grant #1019343 \nto the Computing Research As\u00adsociation for the CIFellows Project. We thank the anonymous re\u00adviewers for \ntheir helpful feedback. References [1] J. Aldrich, V. Kostadinov, and C. Chambers. Alias Annotations \nfor Program Understanding. In OOPSLA, 2002. [2] K. Bierhoff. Automated program veri.cation made SYMPLAR: \nSYMbolic Permissions for Lightweight Automated Reasoning. In On\u00adward!, 2011. [3] K. Bierhoff and J. Aldrich. \nModular typestate checking of aliased objects. In OOPSLA, 2007. [4] K. Bierhoff, N. E. Beckman, and J. \nAldrich. Practical API protocol checking with access permissions. In OOPSLA, 2009. [5] B. Bokowski and \nJ. Vitek. Con.ned types. In OOPSLA, 1999. [6] C. Boyapati, R. Lee, and M. Rinard. Ownership types for \nsafe pro\u00adgramming: preventing data races and deadlocks. In OOPSLA, 2002. [7] J. Boyland. Alias Burying: \nUnique Variables without Destructive Reads. Software Practice and Experience, 6(31):533 553, 2001. [8] \nJ. Boyland. Checking interference with fractional permissions. In Static Analysis Symposium, 2003. [9] \nJ. Boyland, J. Noble, and W. Retert. Capabilities for sharing: A generalisation of uniqueness and read-only. \nIn ECOOP, 2001. [10] J. T. Boyland and W. Retert. Connecting Effects and Uniqueness With Adoption. In \nPOPL, 2005. [11] R. DeLine and M. F\u00a8ahndrich. Enforcing high-level protocols in low\u00adlevel software. In \nPLDI, 2001. [12] R. DeLine and M. Fahndrich.\u00a8Typestates for objects. In ECOOP, 2004. [13] M. F\u00a8ahndrich \nand R. DeLine. Adoption and focus: Practical linear types for imperative programming. In PLDI, 2002. \n[14] J.-Y. Girard. Linear logic. Theoretical Comp. Sci., 50(1):1 102, 1987. [15] D. Grossman, G. Morrisett, \nT. Jim, M. Hicks, Y. Wang, and J. Cheney. Region-based memory management in cyclone. In PLDI, 2002. [16] \nD. Harms and B. Weide. Copying and Swapping: In.uences on the design of reusable software components. \nTrans. Software Engineering, 17(5):424 435, May 1991. [17] S. Heule, R. Leino, P. M\u00a8uller, and A. Summers. \nFractional permissions without the fractions. In FTfFP, 2011. [18] M. Hicks, G. Morrisett, D. Grossman, \nand T. Jim. Experience with safe manual memory-management in cyclone. In ISMM, 2004. [19] J. Hogg. Islands: \nAliasing Protection in Object-Oriented Languages. In OOPSLA, 1991. [20] R. C. Holt, P. A. Matthews, J. \nA. Rosselet, and J. R. Cordy. The Turing Language: Design and De.nition. Prentice-Hall, 1988. [21] B. \nJacobs, J. Smans, P. Philippaerts, F. Vogels, W. Penninckx, and F. Piessens. VeriFast: A Powerful, Sound, \nPredictable, Fast Veri.er for C and Java. In NASA Formal Methods, 2011. [22] N. H. Minsky. Towards alias-free \npointers. In ECOOP, 1996. [23] K. Naden, R. Bocchino, J. Aldrich, and K. Bierhoff. A type sys\u00adtem for \nborrowing permissions. Technical Report CMU-CS-11-142, Computer Science Department, Carnegie Mellon University, \nDecem\u00adber 2011. [24] J. Noble, J. Vitek, and J. Potter. Flexible alias protection. In ECOOP. Springer, \n1998. [25] S. Smetsers, E. Barendsen, M. van Eekelen, and R. Plasmeijer. Guar\u00adanteeing safe destructive \nupdates through a type system with unique\u00adness information for graphs. In Dagstuhl Seminar on Graph Transfor\u00admations \nin Comp. Sci., volume 776 of LNCS. Springer, 1994. [26] J. A. Tov and R. Pucella. Practical af.ne types. \nIn POPL, 2011. [27] P. Wadler. Linear types can change the world! In Working Conf. on Programming Concepts \nand Methods, 1990. \u00b4 ECOOP, 2011. [28] R. Wolff, R. Garcia, Eric Tanter, and J. Aldrich. Gradual typestate. \nIn   \n\t\t\t", "proc_id": "2103656", "abstract": "<p>In object-oriented programming, unique permissions to object references are useful for checking correctness properties such as consistency of typestate and noninterference of concurrency. To be usable, unique permissions must be <i>borrowed</i> --- for example, one must be able to read a unique reference out of a field, use it for something, and put it back. While one can null out the field and later reassign it, this paradigm is ungainly and requires unnecessary writes, potentially hurting cache performance. Therefore, in practice borrowing must occur in the type system, without requiring memory updates. Previous systems support borrowing with external alias analysis and/or explicit programmer management of <i>fractional permissions</i>. While these approaches are powerful, they are also awkward and difficult for programmers to understand. We present an integrated language and type system with unique, immutable, and shared permissions, together with new <i>local permissions</i> that say that a reference may not be stored to the heap. Our system also includes <i>change permissions</i> such as unique&#62;&#62;unique and unique&#62;&#62;none that describe how permissions flow in and out of method formal parameters. Together, these features support common patterns of borrowing, including borrowing multiple local permissions from a unique reference and recovering the unique reference when the local permissions go out of scope, without any explicit management of fractions in the source language. All accounting of fractional permissions is done by the type system \"under the hood.\" We present the syntax and static and dynamic semantics of a formal core language and state soundness results. We also illustrate the utility and practicality of our design by using it to express several realistic examples.</p>", "authors": [{"name": "Karl Naden", "author_profile_id": "81479661703", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2991309", "email_address": "kbn@cs.cmu.edu", "orcid_id": ""}, {"name": "Robert Bocchino", "author_profile_id": "81323487933", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2991310", "email_address": "rbocchin@cs.cmu.edu", "orcid_id": ""}, {"name": "Jonathan Aldrich", "author_profile_id": "81100454133", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2991311", "email_address": "jonathan.aldrich@cs.cmu.edu", "orcid_id": ""}, {"name": "Kevin Bierhoff", "author_profile_id": "81100267548", "affiliation": "Two Sigma Investments, New York, NY, USA", "person_id": "P2991312", "email_address": "kevin.bierhoff@cs.cmu.edu", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103722", "year": "2012", "article_id": "2103722", "conference": "POPL", "title": "A type system for borrowing permissions", "url": "http://dl.acm.org/citation.cfm?id=2103722"}