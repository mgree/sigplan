{"article_publication_date": "01-25-2012", "fulltext": "\n The Marriage of Bisimulations and Kripke Logical Relations Chung-Kil Hur Derek Dreyer Georg Neis Viktor \nVafeiadis Max Planck Institute for Software Systems (MPI-SWS) {gil,dreyer,neis,viktor}@mpi-sws.org Abstract \nThere has been great progress in recent years on developing ef\u00adfective techniques for reasoning about \nprogram equivalence in ML-like languages that is, languages that combine features like higher-order functions, \nrecursive types, abstract types, and general mutable references. Two of the most prominent types of techniques \nto have emerged are bisimulations and Kripke logical relations (KLRs). While both approaches are powerful, \ntheir complementary advantages have led us and other researchers to wonder whether there is an essential \ntradeoff between them. Furthermore, both ap\u00adproaches seem to suffer from fundamental limitations if one \nis interested in scaling them to inter-language reasoning. In this paper, we propose relation transition \nsystems (RTSs), which marry together some of the most appealing aspects of KLRs and bisimulations. In \nparticular, RTSs show how bisimulations support for reasoning about recursive features via coinduction \ncan be synthesized with KLRs support for reasoning about local state via state transition systems. Moreover, \nwe have designed RTSs to avoid the limitations of KLRs and bisimulations that preclude their generalization \nto inter-language reasoning. Notably, unlike KLRs, RTSs are transitively composable. Categories and Subject \nDescriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory; D.3.3 [Programming Languages]: \nLanguage Constructs and Features; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and \nRea\u00adsoning about Programs General Terms Languages, Theory, Veri.cation Keywords Kripke logical relations, \nbisimulations, relation transi\u00adtion systems, contextual equivalence, higher-order state, recursive types, \nabstract types, transitivity, global vs. local knowledge 1. Introduction One of the grand challenges \nin programming language semantics is to .nd scalable techniques for reasoning about the observational \nequivalence of programs. Even when the intuitive principles of local reasoning suggest that a change \nto some program module should not be observable to any client, it can be .endishly dif.cult to establish \nthat formally. Denotational semantics offers a tractable way of proving equivalence of programs by showing \nthat they mean the same thing in some adequate model of their language. How\u00adever, traditional denotational \nmethods do not scale well to general- Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 12, January 25 27, 2012, Philadelphia, PA, USA. Copyright c &#38;#169; \n2012 ACM 978-1-4503-1083-3/12/01. . . $10.00 purpose languages like ML that combine support for functional, \nvalue-oriented programming (e.g., higher-order functions, poly\u00admorphism, abstract data types, recursive \ntypes) with support for imperative, effect-oriented programming (e.g., mutable state and control effects, \namong other things). Fortunately, in recent years, there has been a groundswell of interest in the problem \nof developing effective methods for reason\u00ading about program equivalence in ML-like languages. A variety \nof promising techniques have emerged [29, 36, 19, 20, 34, 33, 23, 5, 35, 12, 25], and while some of these \nmethods are denotational, most support direct reasoning about the operational semantics of programs. \nIn particular, there has been a healthy rivalry between techniques based on Kripke logical relations \n(KLRs) [29, 5, 26, 13, 12, 17, 37] and bisimulations [36, 19, 34, 33, 23, 35]. This paper is motivated \nby two high-level concerns: (1) KLRs and bisimulations offer complementary advantages, which we would \nlike to synthesize in a single proof method. (2) There is a speci.c sense in which both KLRs and bisimulations \nappear to be fundamentally limited, and some fresh idea seems necessary to circumvent this limitation. \n Concerning motivation (1): The latest KLR techniques [5, 12] use state transition systems to provide \nmore .exible principles for reasoning about local state than bisimulations do. However, in or\u00adder to \naccount for the presence of recursive features, such as re\u00adcursive types and higher-order state, KLRs \nrequire tedious manip\u00adulation of tricky step-indexed constructions [6, 2].1 In contrast, bisimulation \ntechniques use coinduction to model such recursive features very elegantly, but their support for reasoning \nabout local state is weaker than KLRs (see Section 9). These complementary strengths have led us and \nother researchers to wonder whether there is some fundamental tradeoff between KLRs and bisimulations. \nConcerning motivation (2): We are interested in scaling equa\u00adtional reasoning techniques to the setting \nof inter-language reason\u00ading, i.e., reasoning about equivalences between programs in dif\u00adferent languages. \nInter-language reasoning is essential to the de\u00advelopment of compositional certi.ed compilers [7, 17], \nand may also have applications to the veri.cation of multi-language (inter\u00adoperating) programs [4]. Unfortunately, \nboth KLR and bisimulation methods rely on technical devices that prevent them (it seems) from scaling \nto the inter-language setting. Speci.cally, in order to deal with higher-order functions, bisimulation \nmethods employ various syntactic devices that restrict the applicability of the methods to single-language \nreasoning (see Section 3 for details). KLRs, in contrast, have been shown to generalize to inter-language \nreason\u00ading [17], but there remains a key problem: KLR proofs are in gen\u00aderal not transitively composable, \nat least in part due to the use of step-indexed constructions as mentioned above. In order to prove compositional \ncorrectness of multi-phase compilers for ML-like 1 This has led to a series of papers some written by \nauthors of the present paper on how to hide the ugliness of step-indices [11, 13, 8].  languages, it \nis crucial to be able to prove the correctness of each phase individually and then compose them transitively, \nso KLRs lack of transitivity is a showstopper for that application. 1.1 Contributions In this paper, \nwe present a new technique for reasoning about program equivalence, called Relation Transition Systems \n(RTSs). RTSs marry together some of the most appealing features of KLRs and bisimulations, while circumventing \ntheir limitations. In particular, RTSs show how the use of state transition systems (from KLRs) can be \nsynthesized with the coinductive, step-index\u00adfree style of reasoning (from bisimulations), thereby enabling \nclean and elegant proofs about local state and recursive features simul\u00adtaneously. Thus, concerning the \nlong-standing open question of whether there is a fundamental tradeoff between KLRs and bisim\u00adulations, \nwe provide a de.nitive answer: no, there is not. We explore RTSs here in the setting of F\u00b5! a CBV .-calculus \nwith general recursive types, products, sums, universals, existen\u00adtials, and general references [5] as \nthis provides a clear point of comparison with recent work on both KLRs [12] and bisimula\u00adtions [35]. \nWith one notable exception (see Section 9), we believe RTSs are capable of reasoning effectively about \nall the challeng\u00ading F\u00b5! equivalences studied in the aforementioned papers, and we demonstrate RTSs effectiveness \non several such equivalences. Although we do not study inter-language reasoning in this pa\u00adper, we have \ndesigned RTSs so as to avoid the use of any techni\u00adcal devices that would preclude a future generalization \nto the inter\u00adlanguage setting. To achieve this goal, we had to come up with a novel way of accounting \nfor higher-order functions in the context of a coinductive bisimulation-like proof method, without relying \non the syntactic devices that previous bisimulation methods use. Our solution a new technique we call \nglobal vs. local knowledge is one of the major contributions of this paper. Relying heavily on this new \ntechnique, we have proven that RTS equivalence proofs are transitively composable, which suggests they \nmay serve as a superior foundation to KLRs for inter-language reasoning. The remainder of this paper \nis structured as follows. In Sec\u00adtion 2, we de.ne F\u00b5!, the language under consideration. In Sec\u00adtion \n3, we motivate our key novel technical idea of global vs. lo\u00adcal knowledge. We then present the formal \ndevelopment of RTSs. For pedagogical reasons, we begin in Section 4 with the presen\u00adtation of a relational \nmodel for .\u00b5 (a pure subset of F\u00b5! with re\u00adcursive types), and then proceed in Sections 5 and 6 to extend \nthat model to handle the full language F\u00b5!. In Section 7, we demonstrate the expressive power of our \nmethod by proving several challenging equivalences from the literature. In Section 8, we brie.y sketch \nour proof of transitivity for the .\u00b5 model. (The transitivity proof for full F\u00b5! is complex and sophisticated, \nmeriting a detailed discus\u00adsion that is beyond the scope of the present paper. We will present it in \na follow-on paper.) Finally, in Sections 9 and 10, we discuss related and future work, and conclude. \nOur online appendix provides detailed proofs of the metatheory of RTSs, both on paper and machine-checked \nin Coq.  2. The Language F\u00b5! In Figure 1, we present the syntax and the operational semantics of F\u00b5!, \na completely standard PCF-like language extended with prod\u00aducts, sums, universals, existentials, general \nrecursive types, and general reference types. Formally, we distinguish between static programs p, which \nare explicitly typed and do not include memory locations f (since the programmer cannot write them), \nand dy\u00adnamic expressions (or terms) e, which include memory locations and in which all type information \nis erased. The static semantics of F\u00b5! (see the online appendix) de.nes the program typing judgment .; \nG f p : t,wherein . ::= \u00b7| .,a and G ::= \u00b7| G,x : t, while tbase ::= unit | int | bool t . Typ ::= a \n| tbase | t1 \u00d7 t2 | t1 + t2 | t1 . t2 | \u00b5a. t |.a. t |.a. t | ref t p . Prog ::= x |()| n | tt | . | \nif p0 then p1 else p2 |(p1,p2)| p.1 | p.2 | inj1 t p | inj2 t p |(case p of inj1 x . p1 | inj2 x . p2) \n| rollt p |unroll p | .x f(x:t1):t2.p | p1 p2 | .a. p | p[t] |pack (t, p) as .a. t' | unpack p1 as (a, \nx) in p2 |ref p | !p | p1 := p2 | p1 == p2 v . Val ::= x |()| n | tt | . |(v1,v2)| inj1 v | inj2 v | \nroll v |.x f(x).e | ..e | pack v | \u00a3 e . Exp ::= v | if e0 then e1 else e2 |(e1,e2)| e.1 | e.2 | inj1 \ne | inj2 e |(case e of inj1 x . e1 | inj2 x . e2) | roll e | unroll e |e1 e2 | e[] | pack e | unpack \ne1 as x in e2 |ref e | !e | e1 := e2 | e1 == e2 K . Cont ::= | if K then e1 else e2 |(K, e)|(v, K)| K.1 \n| K.2 |inj1 K | inj2 K | case K of[inji x . ei] |roll K | unroll K | Ke | vK | K[] |pack K | unpack K \nas x in e |ref K | !K | K := e | v := K | K == e | v == K .n h . Heap ::= Loc t CVal Loc = {\u00a31,\u00a32,...} \nh, if tt then e1 else e2 '. h, e1 h, if . then e1 else e2 '. h, e2 h, (v1,v2).i '. h, vi h, case injj \nv of[inji x . ei] '. h, ej [v/x] h, (.x f(x).e) v'. h, e[(.x f(x).e)/f, v/x] h, (..e)[] '. h, e h, unpack \n(pack v) as x in e'. h, e[v/x] h, unroll (roll v) '. h, v h, ref v'. h I [\u00a3 .v],\u00a3 where \u00a3/. dom(h) h \nI [\u00a3 .v], !\u00a3'. h I [\u00a3 .v],v h I [\u00a3 .v],\u00a3 := v' '. h I [\u00a3 .v'], () h, \u00a3 == \u00a3'. h, tt h, \u00a3 == \u00a3' '. h, \n. where \u00a3= \u00a3' '] ' h, K[e] '. h',K[ewhere h,e '. h',e Figure 1. The syntax and semantics of F\u00b5! . the \ndynamic semantics says how to execute expressions e.There is a straightforward erasure of programs p \ninto expressions, writ\u00adten |p|; and when discussing equivalence informally, we will often gloss over \nthe program/expression distinction. Using evaluation contexts (aka continuations) K,wede.nethe small-step \nreduction relation, Y ., between con.gurations consist\u00ading of a heap and an expression. The reduction \nrules shown in Fig\u00adure 1 are deterministic except for the rule for allocating reference cells, which \nis completely non-deterministic. For technical reasons, we .nd it convenient to assume that allocation \nis in fact determinis\u00adtic, but we do not care which deterministic allocator is used. Thus, we will assume \nthat Y . is some unknown determinization of the rules shown in the .gure, and our model will be parametric \nw.r.t. that determinization. It is easy to show that if two F\u00b5! programs are contextually equivalent \nunder all deterministic allocators, then they are contextually equivalent under a non-deterministic allocator, \nso nothing is lost by this assumption. In the following, we write Yfor the re.exive, transitive clo\u00ad \n. * sure of YWe also say that a con.guration diverges, denoted .. h, e., if it can perform an in.nite \nsequence of Y.-reductions. Two programs are contextually equivalent if, under any well\u00adtyped closing \ncontext C (as de.ned in the appendix), they either both terminate or both diverge. De.nition 1 (Contextual \nequivalence). Let .; G f p1 : t and .; G f p2 : t . Then: def .; G f p1 ~ctx p2 : t = .C, h, t'. f C \n:(.; G; t ) r (\u00b7; \u00b7; t')=. (h, |C[p1]|. .. h, |C[p2]|.)   3. Global vs. Local Knowledge Our new method \nof relation transition systems (RTSs) is essentially coinductive, following the style of existing bisimulation \ntechniques in many respects. As explained in the introduction, coinductive reasoning makes it easy to \ndeal with recursive features (such as recursive types and higher-order state) without requiring the use \nof step-indexed constructions. The two main ways in which RTSs differ from existing bisimu\u00adlation techniques \nare in their treatment of: Local state. From recent work on KLRs [5, 12], we borrow the idea of using \nstate transition systems (STSs) to establish invari\u00adants on how a module s local state may evolve over \ntime. STSs enable one to encode more .exible state invariants than are ex\u00adpressible using environmental \nbisimulations [33, 35]. Higher-order functions. In order to reason about higher-order functions in a \ncoinductive style, but without con.ning ourselves to single-language reasoning, we employ a novel technical \nidea: global vs. local knowledge. The treatment of local state using state transition systems follows \nprior work very closely, so we postpone further discussion of that idea until Section 5 and focus attention \nhere instead on motivating our new idea of global vs. local knowledge. Coinductive Reasoning One way \nof formulating contextual equivalence is as the largest adequate congruence relation [28]. Being adequate \nmeans that if two terms of base type are related, then either they both diverge (run forever) or they \nboth evaluate to thesamevalue (e.g., if one term evaluates to 3, then the other must evaluate to 3 as \nwell). Being a congruence means the relation is closed under all the constructs of the language (e.g., \nif f1 and f2 are related at t ' . t,and e1 and e2 are related at t ' ,then f1 e1 and f2 e2 are related \nat t). To prove using coinduction that two terms e1 and e2 are con\u00adtextually equivalent at type t, one \nmust exhibit a (type-indexed) term relation L that contains (t, e1,e2) and then prove that L is an adequate \ncongruence. The relation L serves as a generalized coinduction hypothesis , by which one proves equivalence \nfor all pairs of terms related by L simultaneously. However, while it is possible for one to employ this \nkind of brute-force coinductive proof, it is typically not very pleasant, because proving a relation \nto be a congruence directly can be incredibly tedious. Bisimulation techniques help make coinductive \nproofs manage\u00adable by lightening the congruence proof burden. Typically, this is achieved by only requiring \none to show that L is closed under type\u00addirected uses (i.e., evaluation or deconstruction) of the terms \nit re\u00adlates. This results in proof obligations that look like the following: (1) If (t, e1,e2) . L, \nthen either e1 . and e2 ., or .v1,v2.e1 Y. * v1 and e2 Y. * v2 and (t, v1,v2) . L. (2) If (int,v1,v2) \n. L,then .n. v1 = v2 = n.  ' '' ' ''' '' ''' (3) If (t \u00d7 t ,v1,v2) . L,then .v1,v1 ,v2,v2 .vi = (vi,vin \n'' ' '''''' and (t ,v1,v2) . L and (t ,v1 ,v2 ) . L. '' ' (4) If (\u00b5a.t,v1,v2) . L,then .v1,v2.vi = roll \nvi and (t [\u00b5a. t/a],v1' ,v2' ) . L. The most problematic proof obligation is the one for function values. \nIt usually looks something like this (simplifying .x to .): (5) If (t ' . t, v1,v2) . L,then .x, e1,e2.vi \n= .x.ei and '' ''' .v1,v2. (t ,v1,v2) . G . (t, e1[v1' /x],e2[v2' /x]) . L. In other words, if L relates \nfunction values v1 and v2, then applying them to any equivalent arguments v1 ' and v2 ' should produce \nresults that are also related by L. The big question is: what is this relation G from which the arguments \nv1 ' and v2 ' are drawn? Global vs. Local Knowledge First, some (non-standard) termi\u00adnology: There are \nmany equivalent terms in the world, but when we do a bisimulation proof, we only make a claim about some \nof them. So let us make a distinction between local and global knowl\u00adedge about term equivalence. The \nrelation L describes our local knowledge: these are the terms whose equivalence we aim to vali\u00addate in \nour proof. The relation G, on the other hand, embodies the global knowledge about all terms that are \nequivalent in the world. In proof obligation (5), we draw equivalent function arguments from G (rather \nthan L) since they might indeed originate from some\u00adwhere else in the program (some unknown client code), \nand thus our local knowledge L may not be suf.cient to justify their equiv\u00adalence. This leaves us with \nthe question of how to de.ne G. Whence Global Knowledge? Coming up with a sound (and prac\u00adtically usable) \nchoice for G is far from obvious, and existing bisim\u00adulation methods make a variety of different choices. \nFor example: Applicative bisimulations [1] de.ne G to be the syntactic iden\u00adtity relation on closed values. \nThis is a nice, simple choice, which works well for pure .-calculus. Unfortunately, for higher-order \nstateful languages like F\u00b5!,itis unsound [18], so more advanced approaches are needed: Environmental \nbisimulations [36, 19, 33, 35] take G to be the context closure of L, i.e., the relation that extends \nthe syntac\u00adtic identity relation on closed values by including closures of open values v with pairs of \nvalues (w1,w2) that are related by L (formally: {(s, v[w1/y],v[w2/y]) |{(s' ,w1,w2)}. L}).2  Normal \nform (or open) bisimulations [21, 34, 22, 23] sidestep the whole question by choosing a fresh variable \nname x and representing equivalent arguments by the same x. As a result, these bisimulations are built \nover open terms, and proof obli\u00adgation (1) above must be updated to account for the possibility that \nthe evaluations of e1 and e2 get stuck trying to deconstruct thesamefreevariable x (more about that below). \n All of these methods de.ne global knowledge in a very syntactic way that is well suited to proving \ncontextual equivalences. How\u00adever, as explained in the introduction, we wish to develop a method that \nwill be capable of generalizing to the setting of inter-language reasoning, where G may relate different \nlanguages. We therefore seek an account of global knowledge that is more semantic . Parameterizing Over \nGlobal Knowledge The essential dif.culty in choosing G has to do with higher-order functions: if the \nargu\u00adment type t ' is (or contains) a function type, then equivalence at ' t is very hard to characterize \ndirectly.3 Our solution is simple: we don t try to de.ne the global knowledge at all; instead, we take \nG to be a parameter of our model! Our key observation is that it is not necessary to pin down exactly \nwhat G is, so long as we make our coinductive proof for L as parametric as possible with respect to it. \n(We will clarify what as parametric as possible means in Section 4.) This parametricity makes our proofs \nquite robust by allowing G to be instantiated in a variety of different ways. In particular, we make \nno assumptions whatsoever about the values that G relates at function type. For all we know, G might \neven include garbage like (int . int, 4, tt). Our approach can be viewed as a more semantic account of \nthe idea behind normal form bisimulations (see above), which is 2 We are glossing over a lot of details \nhere. To be precise, environmental bisimulations are actually sets of L s. For more details, see Section \n9. 3 Conversely, if t ' were arrow-free (e.g., in a .rst-order language), it would be easy to characterize \nequivalence at t ' directly. 4 The ability to instantiate G with a trashy relation is surprisingly useful. \nWe will make critical use of it in our transitivity proof in Section 8.  to model equivalent arguments \nas black boxes about which noth\u00ading is known. Consequently, just as for normal form bisimulations, we \nneed to adapt proof obligation (1) above to account for the pos\u00adsibility that e1 and e2 get stuck. For \nnormal form bisimulations, e1 and e2 may get stuck if they try to deconstruct a free variable x,and so \nnormal form bisimulations loosen proof obligation (1) to allow e1 and e2 to reduce to terms of the form \nK1[xv1] and K2[xv2], where K1 and K2 are equivalent continuations and v1 and v2 are equivalent values. \nIn our case, e1 and e2 may get stuck if they try to apply some bogus functions that are equivalent according \nto the global knowledge but that turn out (like 4 and tt) to not even be functions. Hence, we will allow \ne1 and e2 to reduce to terms of the form K1[f1 v1] and K2[f2 v2],where K1 and K2 are equivalent continuations, \nand where {(t ' . t, f1,f2), (t ' ,v1,v2)}. G.In this way, the parameter G serves as a semantic analogue \nof free variables in normal form bisimulations. Intuitively, although the idea of parameterizing over \nthe global knowledge may seem surprising at .rst, we .nd it to be comfort\u00adingly reminiscent of Girard \ns method for modeling System F [14]. In Girard s method, a potential cycle in the de.nition of the log\u00adical \nrelation for impredicative universal types .a.t is avoided by parameterizing over an arbitrary relational \ninterpretation of the ab\u00adstract type a. In our scenario, the problem of how to de.ne the global knowledge \nis avoided by parameterizing over an arbitrary relational interpretation of function types. In essence, \nwe are treat\u00ading a function type t1 . t2 as an unusual kind of abstract type: the coinductive proofs \nabout different modules in a program all treat the global interpretation of t1 . t2 abstractly, while \nsimulta\u00adneously they each contribute to de.ning it. Parameterizing over the global knowledge turns out \nto be very useful. First and foremost, it makes it easy to soundly compose our coinductive proofs for \ndifferent modules together (and hence prove soundness of our method w.r.t. contextual equivalence). Sec\u00adond, \nit enables us to reason about open terms (Section 4) and higher-order state invariants (Section 6), replacing \nthe use of con\u00adtext closure or free variables for those purposes in environmental and normal form bisimulations, \nrespectively. Finally, it is the key to establishing transitivity for our proof method (Section 8). \n 4. Warmup: A Relational Model for .\u00b5 To ease the presentation of relation transition systems (RTSs), \nwe begin in this section by using the idea of global vs. local knowledge, motivated in the previous section, \nto de.ne a relational model for .\u00b5, a sub-language of F\u00b5! containing base, function, product, sum, and \nrecursive types, but not universal, existential, or reference types. This model cannot properly be called \nan RTS model, since it does not include any transition systems! The transition systems will come into \nplay when dealing with state in Sections 5 and 6. However, by ignoring the transition-systems aspect \nof RTSs for the time being, we can focus attention on other aspects of the model. Figure 2 lists the \nvarious semantic domains we will be using. Here, Type denotes the types of .\u00b5,and CType denotes closed \ntypes (i.e., types with no free type variables a). The next four are standard: relations on closed values, \nclosed expressions, closed continuations, and heaps, indexed by the relevant types (in case of KRel, \ninput and output types). Next, we de.ne what we call the .exible types, CTypeF, along with the .exible \nrelations, VRelF, which are just relations on closed values indexed by such .exible types. Whereas bisimulation \nmethods typically allow terms of arbitrary type to be included in the bisimulation, we .nd it useful \nto restrict local and global knowledges to relate only values of .exible types. Intuitively, these are \nthe types at which value equivalence may depend on module-speci.c knowledge. In F\u00b5!, there will be several \nkinds of .exible types, but in .\u00b5, the only .exible types are function types. t . Type ::= a | tbase \n| t1 . t2 | t1 \u00d7 t2 | t1 + t2 | \u00b5a. t VRel := CType . P(CVal \u00d7 CVal) ERel := CType . P(CExp \u00d7 CExp) KRel \n:= CType \u00d7 CType . P(CCont \u00d7 CCont) HRel := P(Heap \u00d7 Heap) CTypeF := { (t1 . t2) . CType } VRelF := CTypeF \n. P(CVal \u00d7 CVal) Figure 2. Semantic domains for .\u00b5 . R(t ) := R(t) if t . CTypeF R(tbase) := IDtbase \nR(t1 \u00d7 t2):= { ((v1,v1' ), (v2,v 2' )) |(v1,v2) . R(t1) . (v1' ,v2' ) . R(t2) }R(t1 + t2):= { (inj1 v1, \ninj1 v2) | (v1,v2) . R(t1) }.{ (inj2 v1, inj2 v2) | (v1,v2) . R(t2) }R(\u00b5a. t ) := { (roll v1, roll v2) \n| (v1,v2) . R(t [\u00b5a. t/a]) } Figure 3. Value closure for .\u00b5 (if R . VRelF,then R . VRel). e ' if eY. \ne ' beta(e):= undef otherwise FunVal := { f . CVal |.v. beta(fv) de.ned }R ' . R := .t. R ' (t ) . R(t) \nLK := { L . VRelF .VRelF | L is monotone w.r.t. .. .G. .(f1,f2) .L(G)(t1 .t2).f1,f2 . FunVal }GK(L):= \n{ G . VRelF | G . L(G) } Figure 4. De.nition of local and global knowledge for .\u00b5 . In contrast, value \nequivalence at the remaining types base, product, sum, and recursive types, which we call rigid is .xed \nand agreed upon by all modules once the meaning of the .exible types is de.ned. This is achieved by a \nclosure operation that takes a relation R . VRelF and returns its closure R . VRel.Itisde.ned as the \nleast .xed-point of the set of equations in Figure 3. Note that R only occurs covariantly, so R is inductively \nwell de.ned, even though the type gets bigger on the r.h.s. in the case of \u00b5a. t. Local and Global Knowledge \nIn .\u00b5, a local knowledge L . LK is essentially a .exible relation, except that, as shown in Figure 4, \nthis relation is actually parameterized by the global knowledge, G. In effect, L(G) describes the values \nthat we wish to prove are equivalent, assuming that G correctly represents the global knowledge. This \nparameterization is necessary in order to reason about open terms, and we will see its utility below \nin the proof of compatibility for .x. We require that L is monotone w.r.t. G: intuitively, passing in \na larger global knowledge should never result in fewer terms being related by L. We also require that \nthe values related by the local knowledge at function type are indeed functions, in the sense that their \nappli\u00adcation to an arbitrary value should not be a stuck con.guration, but should reduce at least for \none step. This is a technical requirement that is used in our transitivity proof in Section 8. We want \nto restrict attention to global knowledges that are closed w.r.t. the local knowledge in question: For \na particular L,we de.ne GK(L) to be the set of .exible relations G s.t. G . L(G). This requirement makes \nsense since the global knowledge must by de.nition be a superset of any local knowledge. Observe, however, \nthat we do not restrict what other values G relates. Indeed, G may relate values at function type that \nare not actually functions, or that are obviously inequivalent (e.g., 4 and tt, cf. Section 3). Relating \nExpressions and Continuations Figure 5 shows how equivalence is de.ned for expressions, e, and continuations, \nK.  E(G)(t ) := { (e1,e2) | (e1.. e2.) . (.v1,v2.e1 Y. * v1 . e2 Y. * v2 . (v1,v2) . G(t )) ' '' ' ''' \n. (.t ,K1,K2,e1,e2.e1 Y. * K1[e1] . e2 Y. * K2[e2] . (e1,e2) . S(G, G)(t ' ) . (K1,K2) . K(G)(t ' ,t \n)) } K(G)(t1,t2) := { (K1,K2) |.(v1,v2) . G(t1). (K1[v1],K2[v2]) . E(G)(t2) } '' ' S(Rf ,Rv)(t ) := { \n(f1 v1,f2 v2) |.t. (f1,f2) . Rf (t . t ) . (v1,v2) . Rv(t ) }consistent(L) := .G . GK(L). .(e1,e2) . \nS(L(G),G)(t). (beta(e1), beta(e2)) . E(G)(t ) G f e1 ~L e2 : t := consistent(L) ..G . GK(L). ..1,.2 . \ndom(G) . CVal. (.x:t ' . G. (.1(x),.2(x)) . G(t ' )) =. (.1e1,.2e2) . E(G)(t) G f e1 ~ e2 : t := .L. \nG f e1 ~L e2 : t Figure 5. Mutually coinductive de.nitions of (closed) expression equivalence, E . VRelF \n. ERel, and continuation equivalence, K . VRelF . KRel, and de.nitions of consistency and program equivalence \nfor .\u00b5 . Speci.cally, we introduce two new relations, E . VRelF . ERel and K . VRelF . KRel, which are \nde.ned coinductively. Given a type t, a local knowledge L . LK, and a global knowledge G . GK(L), we \nsay that two expressions are locally equivalent, written (e1,e2) . E(G)(t), if they either both diverge \nor both terminate producing related values. Along the way, how\u00adever, they may make calls to external \nfunctions, that is, functions that are related by G, but not necessarily by the local knowledge L(G). \nMore precisely, we say two closed expressions are equiva\u00adlent if and only if one of the following three \ncases holds: 1. Both expressions diverge (run forever). 2. Both expressions run successfully to completion, \nproducing related values. 3. Both expressions reduce after some number of steps to some expressions \nof the form Ki[fi vi], where both the fi and vi are related by the global knowledge G at the appropriate \ntypes, and the continuations, K1 and K2, are equivalent. We say that two continuations are equivalent \nif instantiating them with equivalent values (according to the global knowledge G) yields equivalent \nexpressions.  As E and K are de.ned mutually dependent over a complete lattice and all operations involved \nare monotone, we can take the meaning of these de.nitions to be either the least or the greatest .xed-point. \nWe choose the greatest .xed-point, corresponding to coinduction, because this can in principle relate \nmore terms and is somewhat easier to work with.5 Consistency and Program Equivalence We say that a local \nknowledge L is consistent (in Figure 5) if and only if any two functions that it declares equivalent \ndo in fact beta-reduce to equiv\u00adalent expressions when applied to equivalent arguments. In the formal \nde.nition, we parameterize over an arbitrary global knowl\u00adedge G . GK(L); the functions being tested \nfor equivalence are drawn from the local knowledge, L(G), while the arguments to which they are applied \nare drawn from the global knowledge, G. We say that two expressions are equivalent at type t in the context \nG, written G f e1 ~ e2 : t , if and only if there exists a consistent local knowledge, L, that shows \nthat .1e1 and .2e2 are equivalent at type t for arbitrary value substitutions .1 and .2 that are related \nat G by an arbitrary global knowledge G extending L. Two programs are equivalent simply if their type-erased \nver\u00adsions are equivalent expressions: G f|p1|~|p2| : t. 4.1 Properties of Program Equivalence and Soundness \nWe move on to some properties of our constructions. 5 In particular, were we to extend the language with \nother forms of recursion (such as while loops or primitive recursion), the coinductive interpretation \nwould be essential for proving congruence of expression equivalence. G,f:t ' . t, x:t ' f e1 ~ e2 : t \nFIX G f .x f(x).e1 ~ .x f(x).e2 : t ' . t ' ''' G f e1 ~ e2 : t . t G f e1 ~ e2 : t APP G f e1 e1 ' ~ \ne2 e2 ' : t G f p : t G f e2 ~ e1 : t REFL SYMM G f|p|~|p| : t G f e1 ~ e2 : t G f e1 ~ e2 : t f C :(G; \nt) r (G ' ; t ' ) CONG G '' f C[e1] ~ C[e2]: t G,x:t ' f e1 ~ e2 : t G f v1 ~ v2 : t ' SUBST G f e1[v1/x] \n~ e2[v2/x]: t G f e1 ' ~ e2 ' : t ... .e1 Y. * .e ' 1 ... .e2 Y. * .e ' 2 EXPAND G f e1 ~ e2 : t G,x:t \n' f e1 ~ e2 : t G f v1 ~ v2 : t ' BETA G f (.x. e1) v1 ~ e2[v2/x]: t Figure 6. Some basic properties \nof our equational model. The following lemma states that consistency of local knowl\u00adedges is preserved \nunder (pointwise) union. This is important for ensuring that equivalence proofs for different subterms, \nwhich rely on different local knowledges, can be soundly composed.  Lemma 1. If consistent(L) and consistent(L \n' ),then consistent(L . L ' ). Figure 6 shows some of the basic properties of our program equivalence \nrelation. First, we have a set of rules stating that equiv\u00adalence is compatible with all the language \nconstructs. These rules state that if two terms start with the same term constructor and their immediate \nsubterms are component-wise equivalent, then so are the composite terms. For brevity, we just present \nthe rules for recursive function de.nition (FIX) and function application (APP), whose proofs are the \nmost interesting. We brie.y sketch the proof of the FIX rule. From the premise, there exists L such that \nG,f:t ' . t, x:t ' f e1 ~L e2 : t . De.ne L ' (G):= { (t ' . t, .1.x f(x).e1,.2.x f(x).e2) |.i . dom(G) \n. CVal . '' '' .y:t . G. (.1(y),.2(y)) . G(t ) }. Note here how the parameterization of L ' over G provides \nit with a source from which to draw the closing substitutions .1 and .2. The goal now is to prove G f \n.x f(x).e1 ~ .x f(x).e2 : t ' . t. Showing that L ' (and thus L . L ' ) relates any appropriately closed \ninstances of these two values is simply a matter of unfolding def\u00adinitions. It therefore remains to establish \nconsistent(L . L ' ).By Lemma 1, this boils down to showing  (.1' e1,.2' e2) . E(G)(t ) for any G . \nGK(L . L ' ),where .i . dom(G) . CVal,  .y:t ' . G. (.1(y),.2(y)) . G(t ' ),  (v1,v2) . G(t ' ), \n .i ' = .i,f .(.i.x f (x).ei),x .vi.  Finally, as (.1.x f(x).e1,.2.x f(x).e2) . L ' (G)(t ' . t ) . \n' '' G(t . t), we can instantiate G,f:t . t, x:t f e1 ~L e2 : t with .i ' and are done. The proof of \nrule APP relies on Lemma 1 as well, in order to show that the consistent local knowledges for its two \npremises com\u00adbine to form a consistent local knowledge for the conclusion. In addition, the proof relies \non the following lemma about plugging equivalent expressions or continuations into equivalent continua\u00adtions, \nproved by mutual coinduction and case analysis. Lemma 2. If (K1,K2) . K(G)(t ' ,t ), then: 1. (e1,e2) \n. E(G)(t ' ) =. (K1[e1],K2[e2]) . E(G)(t ). ' ' ''' 2. (K1,K2) . K(G)(t ,t ) '' '' =. (K1[K1],K2[K2]) \n. K(G)(t ,t ). To prove APP, we apply the .rst case of this lemma with ei := .i ei and Ki := .iei' , \nwhich leaves us to prove K1 and K2 to be equivalent according to K. Unfolding the de.nition of K, we \nhave to show that for arbitrary equivalent values v1 and v2, (v1 .1e ' 1,v2 .2e ' 2) is in E, for which \nwe apply Lemma 2 again with ei := .i ei ' and Ki := vi . Then we are left to prove v1 and v2 equivalent, \ni.e., that (v1 v1' ,v2 v2' ) is in E for arbitrary equivalent values v1 ' and v2' , which follows from \nthe third disjunct of the E de.nition. As a consequence of these compatibility rules, by a straight\u00adforward \ninduction on the typing derivation, we can show that equiv\u00adalence is re.exive on well-typed programs \n(rule REFL). This cor\u00adresponds to the fundamental property of logical relations. Equiv\u00adalence is also \nsymmetric: this follows trivially from the symmet\u00adric nature of our de.nition. Likewise, by induction \non the typing derivation of contexts, we can show that our equivalence is a con\u00adgruence: if two equivalent \nterms are placed in the same contexts, the resulting compositions are equivalent. Next, we have a substitutivity \nproperty for values, an expansion law for pure execution steps, and .nally a direct corollary of these \ntwo, namely \u00df-equivalence (on value arguments). We move to a key lemma about E. Given a consistent local \nknowledge L, if the global knowledge extends L with some ad\u00additional external knowledge R, then the third \ncase in the de.nition of E can be restricted so that it applies only to external function calls (i.e., \ncalls to functions related by R, not by L). Lemma 3 (External call). For any consistent(L),any G . GK(L) \nand R . VRelF,wehave: G = L(G) . R =. E(G)= ER(G) where the de.nition of ER is the same as E except that, \nin the third disjunct, S(G, G) is replaced by S(R,G). The . follows directly from the observation that \nR . G.To prove the other direction, we essentially have to eliminate all uses of the third disjunct of \nE where the functions being invoked are related by G \\ R. Since all such functions are by de.nition in \nL(G), and since we know consistent(L), we can in fact always inline the equivalence proofs for all such \nfunction calls. A corollary of Lemma 3 (for G = \u00b5R.L(R) and R = \u00d8) is adequacy, which says that equivalent \nclosed terms either both diverge or both terminate returning proper values. In particular, they never \nget stuck during evaluation. Lemma 4 (Adequacy). If f e1 ~ e2 : t, then: (e1 .. e2 .) . (.v1,v2.e1 Y. \n* v1 . e2 Y. * v2) Finally, combining adequacy and congruence, we show our main soundness theorem: for \nwell-typed programs, our equivalence relation is included in contextual equivalence. Theorem 5 (Soundness). \nLet G f p1 : t and G f p2 : t . If G f|p1|~|p2| : t,then G f p1 ~ctx p2 : t .  4.2 Example Consider \nthe following example concerning streams as functions (taken from Sumii and Pierce [36]): t := \u00b5a. unit \n. int \u00d7 a ones : unit . int \u00d7 t := .x f(x). (1, roll fn twos : unit . int \u00d7 t := .x f(x). (2, roll fn \nsucc : t . t := .x f(s). let (n, s ' n = unroll s (n in roll .x. (n+1,f s ' n The goal is to show f roll \ntwos ~ succ (roll ones): t. Constructing a Suitable Local Knowledge Note that we have succ (roll ones) \nY. * roll twos ' for twos ' := .x. (1+1, succ (roll ones)n.Wede.nealocal knowledge L that relates exactly \ntwos and twos ' : L(G):= { (unit . int \u00d7 t, twos, twos ' ) } Proving Its Consistency For G . GK(L) we \nmust show: ((2, roll twosn, (1+1, succ (roll ones)n) . E(G)(int \u00d7 t) Using the second case in E and the \nde.nition of G, this reduces to showing (2, 2) . G(int) and (roll twos, roll twos ' ) . G(t ). The former \nis trivial. The latter is equivalent to (twos, twos ' ) . G(unit . int \u00d7 t ), which holds by construction \nbecause G ex\u00adtends L(G). Showing the Programs Related By It It remains to show: .G . GK(L). (roll twos, \nsucc (roll ones)) . E(G)(t ) Again using the second case in E weenduphavingtoshow (roll twos, roll twos \n' ) . G(t ), which we have already done above.  5. Local State Transition Systems: A Review In the \nnext section, we will extend our model to account for abstract types and state. The key extension there \nwill be to incorporate sup\u00adport for state transition systems (STSs) in the style of Dreyer et al. s recent \nwork on KLRs [5, 12]. We use this section to review the ba\u00adsic idea behind that work by means of a concrete \nexample. Perhaps the simplest example that demonstrates the utility of STSs for reasoning about local \nstate is the well-bracketed state change example, due originally to Jacob Thamsborg (which is itself \na variant of Pitts and Stark s awkward example) [5, 29]: t := (unit . unit) . int v1 := .f. (f (n; f \n(n;1) e2 := let x = ref 0 in .f. (x := 0; f (n; x := 1; f (n;!x) (Here and in later examples we write \n.x. e for .x f(x).e when f is not free in e.) The goal is to show that v1 and e2 are contextually equivalent \n(at the type t). To see intuitively why they are equiv\u00adalent, observe that e2 allocates a fresh (local) \nlocation x,which initially points to 0, and then returns a function value call it v2. When v1 and v2 \nare applied (at any point in the future) to some call\u00adback function f, they both call f twice. Before \nthe .rst and second calls, v2 will set x to 0 and 1, respectively. Thus, even if the second call to f \ninternally applies v2 again, the last thing x will get set to (before it is dereferenced) is always 1. \nNote that this reasoning as\u00adsumes that control .ow in the language is well-bracketed in the sense that \nthe call to f cannot escape its current continuation and also that the language lacks exceptions (both \nare true for F\u00b5!).  In order to prove this example, we need to be able to establish an invariant concerning \nthe local state of v2. However, we really need more than just a simple .xed invariant because the only \nsuch invariant that holds here is the one stating that x points to either 0 or 1, and that is not strong \nenough. This is where STSs come in. Dreyer et al. [12] prove this example using the following STS: public \n( ) ( ) x . 01 : x . 11 private The states of this STS represent the possible abstract states in which \nthe functions we are proving equivalent may .nd themselves, and associated with each abstract state is \na physical relation on heaps. In the left state, the heap of the second program must contain [x . 0], \nand in the right state, it must contain [x . 1].(No restrictions are placed on the heap of the .rst program, \nsince v1 does not manipulate any local state.) The accessibility relation between these abstract states \nis gov\u00aderned by two transition relations (preorders on the state space): a private and a public one. \nThe rough intuition is that the private (or full ) transition relation includes all legal state transitions, \nwhile the smaller, public transition relation governs the legal transitions that function calls can make \n(when their behavior is viewed exten\u00adsionally). For proving equivalence of v1 and v2, we require transi\u00adtions \nof some kind from each of these states to the other because repeated applications of v2 will indeed result \nin x .ip-.opping back and forth between 0 and 1. However, the transition from x . 1 to x . 0 may be considered \nprivate, not public, because when the behavior of v1 is viewed end-to-end, it will never start with x \n. 1 and end with x . 0. Moreover, restricting the public transition re\u00adlation in this way is essential \nto making the proof go through: since the second call to f starts with x . 1 and is required (by de.ni\u00adtion) \nto make a public transition, we know that, when it returns, x must still point to 1, and thus !x will \nevaluate to 1. What we have described here is the high-level idea of the equiv\u00adalence proof of v1 and \ne2, which is essentially the same when us\u00ading our RTSs as it is when using STS-indexed KLRs. One differ\u00adence \nis that, with KLRs, the proof is driven by the need to show that (v1,e2) and thus also (v1,v2) are in \nthe logical relation at the type t . With RTSs, there is no logical relation de.ning what it means for \nfunctions to be related at type t . Instead, in typical coin\u00adductive style, we need to enter v1 and v2 \ninto the local knowledge of our RTS, which in turn generates a proof obligation to show that these function \nvalues do in fact behave equivalently when passed arguments that are related by the global knowledge. \nFundamentally, this ends up being only a minor change to the structure of the proof. (We will see the \nformal RTS proof of this example in Section 7.1.)  6. Relation Transition Systems for F\u00b5! In this section, \nwe present our full-blown relation transition system (RTS) model for F\u00b5!. This RTS model generalizes \nthe model from Section 4 in a super.cially very simple way: whereas previously t . Type ::= ... |.a. \nt |.a. t | ref t | n CTypeF := ... .{ (.a. t ) . CType }.{ ref t . CType }.{ n . TypeName } Figure 7. \nSemantic domains for F\u00b5! . R(t ) := R(t ) if t . CTypeF . . . R(.a. t ):= { (pack v1, pack v2) |.t ' \n. (v1,v2) . R(t[t ' /a]) } Figure 8. Value closure for F\u00b5! (if R . VRelF,then R . VRel). DepWorld(P ):= \n{ (S, L, Lpub, N, L, H) . Set \u00d7 P(S \u00d7 S) \u00d7 P(S \u00d7 S) \u00d7 P(TypeName) \u00d7 (SP .S.VRelF .VRelF) \u00d7 (SP .S.VRelF \n.HRel) | L, Lpub are preorders .Lpub is a subset of L. L monotone in 1st arg w.r.t. LP , in 2nd w.r.t. \nL,in3rd w.r.t. .. H monotone in 3rd arg w.r.t. .. .sP,s,G. (.n ./N. L(sP)(s)(G)(n)= \u00d8) . (.t1,t2. .(f1,f2) \n.L(sP)(s)(G)(t1 .t2).f1,f2 .FunVal) . (.a, t. .(v1,v2) .L(sP)(s)(G)(.a. t).v1,v2 .TyFunVal) } where FunVal \n:= { f . CVal |.v. beta(fv) de.ned } TyFunVal := { v . CVal | beta(v[]) de.ned } e ' if .h.h,e Y. h, \ne ' beta(e) := undef otherwise World := { W . DepWorld({*}, {(*, *)}) }LWorld := { w . DepWorld(Wref \n.S,Wref . L) | .sref ,s,G,t. w.L(sref )(s)(G)(ref t )= \u00d8} Figure 9. De.nition of worlds (relation transition \nsystems) and auxiliary RTS de.nitions. we proved two terms equivalent by exhibiting a consistent local \nknowledge L, we now do so by exhibiting a consistent world W . Worlds Worlds are state transition systems \n(equipped with pub\u00adlic and private transitions, just as described in Section 5) that control how the \nlocal knowledge of a module and the properties of its local state may evolve over time. Formally (Figure \n9), a world consists of: the transition system s (possibly in.nite) state space (S); the private (or \nfull) transition relation (L) and a smaller pub\u00adlic transition relation (Lpub), both preorders; a set \nof type names that are used to represent abstract types (N); a mapping from states to local knowledges \n(L); and a mapping from states to heap rela\u00adtions (H). For now, ignore the distinction between different \nkinds of worlds as well as the SP , sP ,and LP objects in that .gure. As before, the local knowledge \n(at each state) is parameterized by and must be monotone in the global knowledge G. The same applies \nto the heap relation, which describes pairs of subheaps that are owned by the RTS. The parameter G here \nprovides a way of referring to the global equivalence on values when establishing invariants on the contents \nof local heaps; this is especially critical in dealing with higher-order state. While the local knowledge \nmap\u00adping must be monotone in its state index (w.r.t. L), the heap relation mapping need not be. Indeed, \nsince a module s local state is hidden from the environment, there is no reason to require that heaps \nre\u00adlated in one state will continue to be related in future states (e.g., in the example in Section 5, \nx . 0 or x . 1 but not both). We have seen in the previous section section how a local knowl\u00adedge and \nits closure relate values at .\u00b5 types. This carries over to the full setting. But how do we deal with \nthe additional types of F\u00b5! , i.e., with universal, existential, and reference types?  Wref .S := { \nsref . P.n(CType \u00d7 Loc \u00d7 Loc) | .(t, f1,f2) . sref . .(t ' ,f ' 1,f2' ) . sref . (f1 = f ' 1 =. t = t \n' . f2 = f ' 2) . (f2 = f ' 2 =. t = t ' . f1 = f ' 1) } Wref . L := . Wref . Lpub := . Wref .N := \u00d8 \nWref .L(sref )(G)(ref t):= { (f1,f2) | (t, f1,f2) . sref }Wref .H(sref )(G) := { (h1,h2) | dom(h1)= { \nf1 |.t, f2. (t, f1,f2) . sref }. dom(h2)= { f2 |.t, f1. (t, f1,f2) . sref }..(t, f1,f2) . sref . (h1(f1),h2(f2)) \n. G(t ) } Figure 10. Wref provides the meaning of reference types. Treatment of Universal and Existential \nTypes Universal types, like function types, are considered .exible. That is, the local knowl\u00adedge can \nrelate any values at any closed type .a. t, as long as, when instantiated, those values can run for at \nleast one step. Existential types, like product types, are considered rigid, and thus their interpretation \nis given by the value closure (Figure 8). Note that the witness of related packages must be the same \ntype t ' . How, then, do we support reasoning about parametricity? The key is that the witness type t \n' may be an abstract type name. We extend the syntax of types in our RTS model with type names n (Figure \n7), and the local knowledge of a world can pick a subset of these names and interpret them however it \nwants. To avoid con.icts with other worlds, the choice of names must be recorded in the N component of \nthe world (no other names may be interpreted). Treatment of Reference Types Reference types are considered \n.exible, but they really are a special case. Intuitively, the collec\u00adtion of all reference types can \nbe seen as a separate module that is used by all other modules. Consequently, we construct a designated \nworld Wref (explained below) that interprets ref t , and bar ordinary worlds from relating anything at \nsuch types. We therefore distin\u00adguish between two kinds of worlds: local worlds and full worlds. For \nconciseness, both are de.ned in terms of the same underlying structure of dependent worlds. A dependent \nworld is a world as described above, except that it is parameterized by a preorder P =(SP , LP ) that \nits local knowl\u00adedge and heap relation may depend on (via the sP . SP argument of L and H in Figure 9). \nIntuitively, P is the state transition system of some other world and sP is that world s current state. \nThus, a full world W . World is simply a world depending on nothing (a singleton set). In contrast, a \nlocal world w . LWorld is a world that depends on will later be linked with Wref and does not itself \nrelate any values at reference types. As a matter of notational convenience: if W . World and s . W.S, \nthen we will often just write W.L(s) for W.L(*)(s),and similarly for the H component. (We use the dot \nnotation to project components out of a world.) The World for Reference Types Figure 10 de.nes Wref .World, \nthe world that provides the meaning of reference types. Its states are .nite ternary relations (between \na type t and two locations f1,f2) that are functional in the location arguments. They associate each \nallocated location on the left with the corresponding one on the right and the type of values stored. \nThe relations are .nite because only a .nite number of locations can ever be allocated. And, as dictated \nby the language, they can only grow over time. Its local knowledge Wref .L(sref ) relates precisely the \nlocations related by the current state sref , at the corresponding reference types. The heap relation \nWref .H(sref ) relates heaps that contain exactly the locations related by the current state sref and \nthat store (globally) related values at those locations. Note the critical use of the global knowledge \nparameter G in de.ning Wref .H. H1.H2 := {(h1lh ' 1,h2lh ' 2) | (h1,h2) . H1 . (h1' ,h ' 2) . H2} w..S \n:= Wref .S \u00d7 w.S '' ' w.. L := { (p, p ) | p.1 L p.1 . p.2 L p.2 } '' ' w.. Lpub := { (p, p ) | p.1 Lpub \np.1 . p.2 Lpub p.2 } w..N := w.N w..L(sref ,s)(G):= Wref .L(sref )(G) . w.L(sref )(s)(G) w..H(sref ,s)(G):= \nWref .H(sref )(G) . w.H(sref )(s)(G) (w1 . w2).S := w1.S \u00d7 w2.S '' ' (w1 . w2). L := { (p, p ) | p.1 \nL p.1 . p.2 L p.2 } '' ' (w1 . w2). Lpub := { (p, p ) | p.1 Lpub p.1 . p.2 Lpub p.2 } (w1 . w2).N := \nw1.N l w2.N (w1 . w2).L(sref )(s1,s2)(G):= w1.L(sref )(s1)(G) . w2.L(sref )(s2)(G) (w1 . w2).H(sref \n)(s1,s2)(G):= w1.H(sref )(s1)(G) . w2.H(sref )(s2)(G) Figure 11. Lifting (.. LWorld . World) and separating \nconjunction (.. LWorld \u00d7 LWorld . LWorld)ofworlds. Lifting and Separating Conjunction of Local Worlds \nNow, if we have a local world w . LWorld, then we can link it with Wref , thereby lifting it to a full \nworld w.. World. This operation is de.ned in Figure 11. The full world s transition system is the synchronous \nproduct of Wref s and w s. Its local knowledge relates values iff they are related by either component \ns local knowledge, and its heap relation relates heaps iff they can be split into disjoint parts that \nare related by Wref .H and w.H, respectively. Note how the state sref of the reference world Wref is \npassed to w.L and w.H along with the state of w itself. Similarly, given two local worlds w1,w2 . LWorld \nthat own disjoint sets of abstract types (i.e., w1.N n w2.N = \u00d8), we can construct their separating conjunction \nw1 . w2 . LWorld.The de.nition is given in Figure 11. Note how the same shared state sref is passed to \nthe L and H components of both w1 and w2. Separating conjunction of worlds is a generalization of the \nunion operation on local knowledges, which we have seen in Section 4 to be critical for composing proofs \n(cf. Lemma 1). Program Equivalence With these constructions in hand, we can now describe the de.nition \nof program equivalence in Figure 12. We say that two expressions are equivalent (~) iff there exists \na local world w that (1) does not depend on a particular choice of names to represent its abstract types; \n(2) is stable; and (3) when lifted, relates the expressions. Stability means that the local world s heap \nrelation in some sense tolerates environmental changes: whenever the shared world Wref is advanced to \na future state, sref ' , then w should be able to respond to that change by moving to a public future \nstate, s ' , such that any local heaps that were related previously by w.H are still related at s ' . \nThis is a very technical condition that is required for soundness but is satis.ed trivially in the common \ncase that w.H does not actually depend on its sref parameter. See the end of this section for further \ndiscussion. Aworld W (such as w.) relates two expressions (~W )iff (3a) it is inhabited; (3b) it is consistent; \nand (3c) the expressions, when closed using related substitutions, are related by the expression re\u00adlation \n(see below). Inhabitance says there exists a state at which W.H relates the empty heaps. Consistency \nis essentially the same as for .\u00b5, but extended straightforwardly to universal types. In all these de.nitions, \nthe global knowledge G is drawn from GK(W ). As before, this enforces that G must contain the local knowledge. \nAt reference types, and at abstract type names owned by W ,how\u00adever, GK(W ) also enforces that G must \nnot extend the local knowl\u00adedge. Intuitively, this is because W should completely control the meaning \nof those types. Furthermore, since G is state-indexed, it must, like the local knowledge of W , be monotone \nw.r.t. L.  R ' =N := R ' . R ..t. R ' (ref t )= R(ref t) ..n .N .R ' (n)= R(n) ref R GK(W ) := { G . \nW.S . VRelF | G is monotone w.r.t. L..s. G(s) =W.N W.L(s)(G(s)) } ref EW (G)(s0,s)(t ) := { (e1,e2) \n|.(h1,h2) . W.H(s)(G(s)). .hF2 .h1 l hF1 de.ned . h2 l hF2 de.ned . 1 ,hF =((h1 l hF1 ,e1) .. (h2 l hF2 \n,e2) .) . (.h ' 1,h ' 2,v1,v2. (h1 l h1F ,e1) Y. * (h1 ' l hF1 ,v1) . (h2 l h2F ,e2) Y. * (h2 ' l hF2 \n,v2) . ''' ' .s.s ; s . s ;pub s0. (h ' 1,h2' ) . W.H(s ' )(G(s )) . (v1,v2) . G(s ')(t)) ' '' . (.h \n' 1,h ' 2,t ,K1,K2,e1,e2. (h1 l hF1 ,e1) Y. * (h ' 1 ,K1[e1' ]) . (h2 l hF (h ' 2 ,K2[e2' ]) . 1 l hF2 \n,e2) Y. * 2 l hF ' '' '' ''' .s ; s. (h ' 1,h2' ) . W.H(s )(G(s )) . (e1,e2) . S(G(s ),G(s ))(t ) . ''' \n''' .s ;pub s. .G ' . G. (K1,K2) . KW (G ' )(s0,s )(t ,t )) } KW (G)(s0,s)(t1,t2):= { (K1,K2) |.(v1,v2) \n. G(s)(t1). (K1[v1],K2[v2]) . EW (G)(s0,s)(t2) } '' ' S(Rf ,Rv)(t) := { (f1 v1,f2 v2) |.t. (f1,f2) . \nRf (t . t) . (v1,v2) . Rv(t ) }.{ (f1[],f2[]) |.t1,t2.t = t1[t2/a] . (f1,f2) . Rf (.a. t1) } inhabited(W \n) := .G . GK(W ). .s0. (\u00d8, \u00d8) . W.H(s0)(G(s0)) consistent(W ) := .G . GK(W ). .s. .t. .(e1,e2) . S(W.L(s)(G(s)),G(s))(t \n). (beta(e1), beta(e2)) . EW (G)(s, s)(t ) stable(w) := .G . GK(w.). .sref ,s. .(h1,h2) . w.H(sref )(s)(G(sref \n,s)). ' '' .sref ; sref . .(h1 ref ) . Wref .H(s ref l h1 de.ned . h2 = ref ,h2 ref )(G(sref ,s)).h1 \nref l h2 de.ned . ' '' '' .s ;pub s. (h1,h2) . w.H(sref )(s )(G(sref ,s )) .; G f e1 ~W e2 : t := inhabited(W \n) . consistent(W ) ..G . GK(W ). .s. .d . . . CType. ..1,.2 . dom(G) . CVal. (.x:t ' . G. (.1(x),.2(x)) \n. G(s)(dt ' )) =. (dt, .1e1,.2e2) . EW (G)(s, s) .; G f e1 ~ e2 : t := .N . P(TypeName). N countably \nin.nite =..w. w.N .N. stable(w) . .; G f e1 ~w. e2 : t Figure 12. Mutually coinductive de.nitions of \nexpression equivalence, EW . GK(W ) . W.S \u00d7 W.S . ERel, and continuation equivalence, KW . GK(W ) . W.S \n\u00d7 W.S . KRel, and de.nitions of world consistency and program equivalence for F\u00b5! . Expression and Continuation \nEquivalence The new de.nitions of E and K are also given in Figure 12. Notice that they are now de.ned \nrelative to a world W (as EW and KW ) and that their types have changed to GK(W ) . W.S \u00d7 W.S . ERel \nand GK(W ) . W.S \u00d7 W.S . KRel, respectively: they take both an initial state, s0, and a current state, \ns, as arguments. Given a world W , a global knowledge G . GK(W ), states s0,s . W.S, and a type t , we \nsay that two expressions are locally equivalent, written (e1,e2) . EW (G)(s0,s)(t ),iff, when executed \nstarting in heaps that satisfy the heap relation of W at the current state s, then (as before) one of \nthree cases holds: 1. Both expressions diverge (run forever). 2. Both expressions run successfully to \ncompletion, producing related values. In this case, the values need not be related in the current state \ns, but rather in some future state, s ' ; s, which, however, must also be a public future state of the \ninitial state of the expression: s ' ;pub s0. Moreover, this future state must be consistent with the \nresulting heaps: (h ' 1,h ' 2) . W.H(s ' )(G(s ' )). 3. Both expressions reduce after some number of \nsteps to some expressions of the form Ki[ei' ],where ei ' are either both ap\u00adplications or both instantiations \nthat are related at some future state s ' ; s. This state must be consistent with the correspond\u00ading \nheaps. Finally, the continuations, K1 and K2, are equivalent under any public future state, s '' ;pub \ns ' , and any (pointwise) larger global knowledge, G ' . G.  We restrict s '' to be a public future \nstate of s ' rather than an arbitrary future state because the end-to-end effect of a function call (or \nuniversal instantiation) is assumed to always be a public transition. For this assumption to be sound, \nin return we will have to ensure that the end-to-end behaviors of equivalent function bodies indeed change \nthe state only into public future states. This is why we thread the s0 argument through the coinduction \nand check that the .nal RTS state in the previous case (2) is a public future state of s0. The intuitive \nreason for quantifying over a larger global knowl\u00adedge G ' is this: At the point when the continuations \nare run, not only might W s state s ' have changed to a future state s '' ,but also the states of all \nother modules , which is re.ected by the growth of the global knowledge. In all three cases, the de.nition \nquanti.es over frame heaps, h1F and h2F: the execution of e1 and e2 should not update any disjoint part \nof the heap that they do not own according to the heap relation of the current state. This framing aspect \nof our de.nition is a semantic version of the frame rule of separation logic and allows us to concentrate \nthe reasoning about the heaps only on the parts of the heaps accessed by the program. (Baking the frame \nrule into the semantic model is quite common in more recent models of separation logic [9, 39], essentially \nbecause it allows one to avoid proving any safety monotonicity or frame properties of the operational \nsemantics itself.) Properties of Program Equivalence and Soundness The prop\u00aderties presented in Section \n4 for .\u00b5, as well as the corresponding soundness proofs, extend naturally to the full model, but we omit \nfurther details here due to space considerations. We plan to present them in an expanded version of this \npaper. Meanwhile, we refer the reader to our online appendix (see the link at the end of the paper). \nA Word on Dependency In the examples in the next section, we will not actually rely on the ability of \nlocal knowledges and heap relations to depend on the state of the reference world Wref . Con\u00adsequently, \nthe stability property in the de.nition of program equiv\u00adalence will be trivially satis.ed (by choosing \ns ' := s). However, dependent worlds are of critical importance in the RTS transitivity proof for full \nF\u00b5!. We will report on this issue in a future paper.  7. Examples In this section, we present several \nexample RTS equivalence proofs. For convenience, we drop the sref argument from the L and H components \nof local worlds since we do not use it in our examples.  7.1 Well-Bracketed State Change Recall the \nexample from Section 5 and its high-level proof-sketch using an STS. We will now show in some formal \ndetail how this proof is done using our method. Concretely, we prove f v1 ~ e2 : t,where: t := (unit \n. unit) . int v1 := .f. (f (n; f (n;1) v2 := .f. (x := 0; f (n; x := 1; f (n;!x) e2 := let x = ref 0 \nin v2 Constructing a Suitable RTS We construct an RTS w that we will then show to be consistent and to \nrelate v1 and e2. Since the programs don t involve abstract types, we can de.ne w.N to be empty. The \nSTS that we build into w is essentially the one from Section 5. A state s . w.S is to be understood as \nfollows: for each running instance of e2, identi.ed by the location f that that instance initially allocated, \ns(f) says whether it is in the (pictorially) left state (f points to 0) or in the right one (f points \nto 1). Accordingly, the heap relation w.H at state s is just {(\u00d8,s)}. Finally, the local knowledge w.L \nat state s relates v1 with v2[f/x] for any location f belonging to an instance. .n w.S := Loc . {0, 1}. \nHeap w. L := {(s, s ' ) | dom(s) . dom(s ' )}  w. Lpub := {(s, s ' ) . w. L|.(f, 1) . s. (f, 1) . s \n' } w.N := \u00d8 w.L(s)(G)(t ):= {(v1,v2[f/x]) | f . dom(s)} w.H(s)(G) := {(\u00d8,s)} It is easy to see that \nw . LWorld. In particular, w.L and w.H are monotone as required. Note that stable(w) (the dependency \nis vacuous) and that inhabited(w.) for s0 =(\u00d8, \u00d8).Toshow f v1 ~w. e2 : t, two parts remain. Proving Its \nConsistency Establishing consistent(w.) is the real meat of the proof. Consider two functions related \nby w..L at a state (s 1ref ,s1). Clearly, one is v1 and the other is v2[f/x] for some f . dom(s1). Now \nsuppose we are given related arguments '' 1 (v1,v2) . G1(sref ,s1)(unit . unit). We need to show: '' \n'' ((v1 (n; v1 (n;1), (f := 0; v2 (n; f := 1; v2 (n;!f)) . Ew.(G1)((s 1 ref1 ,s1))(int) ref ,s1), (s \nNote that for (h1,h2) . w.H(s1)(G(sref1 ,s1)) we know by con\u00adstruction that h1 = \u00d8 and h2 = s1. Consequently, \nfor any frame heaps hF1 ,hF2 ,wehave h2 l hF2 , (f := 0; v2 ' (n; f := 1; v2 ' (n;!f) Y. * (s1 \\f) l \n[f.0] l hF2 , (v2 ' (n; f := 1; v2 ' (n;!f) where s1\\f denotes the restriction of s1 to domain dom(s1) \n\\{f}. '' '' h1 l hFSince h1 l hF1 , (v (n; v (n;1) Y. * 1 , (v (n; v (n;1), 11 11 it suf.ces, by the \nthird disjunct in the de.nition of Ew.,to.nd s1 ' ; s1 such that: ' 1 ' 1. (\u00d8, (s1 \\f) l [f.0]) . w.H(s1)(G1(sref \n,s1)) 21 '  2. .(sref ,s2) ;pub (sref ,s1)..G2 . G1. (( ; v1 ' (n;1), ( ; f := 1; v2 ' (n;!f)) . Kw.(G2)((sref1 \n,s1), (sref2 ,s2))(unit, int)  Naturally, we pick s1 ' =(s1 \\f) l [f.0] ; s1. Then (1) holds by construction \nof w and it remains to show (2). After repeating the whole procedure one more time, we arrive at the \ngoal of .nding s2 ' ; s2 such that: ' 2 ' 3. (\u00d8, (s2 \\f) l [f.1]) . w.H(s2)(G2(sref ,s2)) 32 ' 4. .(sref \n,s3) ;pub (s 2)..G3 . G2. ref ,s (( ;1), ( ;!f)) . Kw.(G3)((sref1 ,s1), (sref3 ,s3))(unit, int) Naturally, \nwe pick s2 ' =(s2 \\f) l [f.1] ; s2. Then (3) holds by construction of w and it remains to show (4). We \nobserve that, for any s3 ;pub s2' , it must be that s3(f)=1 since s2' (f)=1. Hence for (h ' 1,h2' ) . \nw.H(s3)(G(sref3 ,s3)) we know by construction h ' 2(f)=1. Consequently, for any frame heaps hF1 ' 2 ' \n,hF ,wehave: ' F ' F h2 l h2 ' , ((n;!f) Y. * h2 l h2 ' , 1 Since of course h ' 1 l hF1 ' , ((n;1) Y. \n* h1 ' l hF1 ' , 1 and (1, 1) . G3(sref3 ,s3)(int) by de.nition, we are done if we can show (s 3 ref1 \n,s1). Indeed, this is easy to verify. ref ,s3) ;pub (s Showing the Programs Related By It Given how we \nconstructed our RTS, this .nal goal is fairly easy to accomplish. Formally, we must show (v1,e2) . Ew.(G)((sref \n,s), (sref ,s))(t ) for any G, sref ,s. Note that if (h1,h2) . w.H(s)(G(sref ,s)),then for some fresh \nf we have h2,e2 Y. h2 l [f.0],v2[f/x] and, of course, h1,v1 Y. * h1,v1. It therefore suf.ces to .nd s \n' ;pub s such that the following hold: 5. (h1,h2 l [f.0]) . w.H(s ' )(G(sref ,s ' )) 6. (v1,v2[f/x]) \n. G(sref ,s ')(t)  We pick s ' = s l [f.0]. Note that s ' is well-de.ned because f is fresh (so f/. \ndom(s)), and that s ' ;pub s as required. To show (6), it suf.ces by de.nition of GK to show (v1,v2[f/x]) \n. '' ' w.L(s )(G(sref ,s ))(t). This holds by construction of w and s , and so does (5).  7.2 A Free \nTheorem The next example demonstrates the treatment of universal types, and the fact that our method \nmay be used to prove at least some simple so-called free theorems [40]. Suppose f p : .a. a and |p| = \nv. We want to prove that h, v[] . for any h. We start by applying REFL to obtain f v ~ v : .a. a.This \ngives us w with f v ~w. v : .a. a and w.N . TypeName\\{n}for some arbitrary n of our choosing. We now \ninstantiate G . GK(w.) to be the least solution of .s. G(s)= w..L(s)(G(s)). From f v ~w. v : .a. a we \nthen get (v, v) . Ew.(G)(s0,s0)(.a. a) where s0 is the state witnessing inhabited(w.). Consequently, \nwe get s ;pub s0 such that: 1. (v, v) . G(s)(.a. a)= G(s)(.a. a) 2. (\u00d8, \u00d8) . (w.).H(s)(G(s))  From \n(1), the construction of G,and consistent(w.),wederive (beta(v[]), beta(v[])) . Ew.(G)(s, s)(t) for any \nt. So, in particular, we have (beta(v[]), beta(v[])) . Ew.(G)(s, s)(n). In fact, due to the construction \nof G, Lemma 3 tells us R (beta(v[]), beta(v[])) . Ew.(G)(s, s)(n) for R = .s.\u00d8. Together with (2), this \nallows only two cases for any heap h: either h, beta(v[]) diverges (then we are done), or it terminates \nand the resulting values are related by G(s ' )(n) for some s ' ;pub s. However, because Wref .N = \u00d8 \nand w.N . TypeName\\{n}, we know G(s ')(n)= w..L(s ')(G(s '))(n)= \u00d8, which rules out that second case. \n  7.3 Twin Abstraction This .nal example (originally due to Ahmed et al. [5]) demon\u00adstrates the interaction \nof local state with abstract types. t := .a. .\u00df. (unit . a) \u00d7 (unit . \u00df) \u00d7 (a \u00d7 \u00df . bool) e1 := let x \n= ref 0 in pack (int, pack (int,. .x := !x +1;!x, . .x := !x +1;!x, .p. p.1= p.2nn e2 := let x = ref \n0 in pack (int, pack (int,. .x := !x +1;!x, . .x := !x +1;!x, .p. .nn Both e1 and e2 return a name generator \nADT consisting of two abstract types a and \u00df, together with a function for generating a fresh name of \ntype a, a function for generating a fresh name of type \u00df, and a function for comparing an a name and \na \u00df name for equality. Both implementations represent names as integers, and in e1, the comparison operation \nreally tests the names for equality. In e2, however, the comparison just always returns false right away. \nNevertheless, the two programs are contextually equivalent because the a names and the \u00df names are generated \nby the same underlying integer counter, and thus no value can be both an a name and a \u00df name at the same \ntime. We now show the construction of an RTS w that can be used to prove f e1 ~ e2 : t. Let a countably \nin.nite N. P(TypeName) be given. Since Loc is also countably in.nite, we can think of N a\u00df as being split \ninto {ne | f . Loc}l{ne | f . Loc}.Wede.ne w as follows: .n w.S := {s . Loc \u00d7 Loc . P(N>0) \u00d7 P(N>0) |dom(s) \npartial bijection . .(f1,f2,S1,S2) . s. S1 n S2 = \u00d8} w. L := w. Lpub w. Lpub := {(s, s ' ) . w.S \u00d7 w.S \n|.(f1,f2,S1,S2) . s. .S1 ' . S1,S2 ' . S2. (f1,f2,S1' ,S2' ) . s ' }  w.N := N w.L(s)(G):= a {(ne1 ,n,n) \n|.f2,S1,S2. (f1,f2,S1,S2) . s . n . S1} l{(n \u00dfe1 ,n,n) |.f2,S1,S2. (f1,f2,S1,S2) . s . n . S2} a l{((unit \n. ne1 ), ++f1, ++f2) | (f1,f2) . dom(s)} l{((unit . ne\u00df1 ), ++f1, ++f2) | (f1,f2) . dom(s)} a\u00df l{((ne1 \n\u00d7 ne1 . bool), (.p. p.1= p.2), (.p. .)) |.f2. (f1,f2) . dom(s)}w.H(s)(G):= {(h1,h2) | dom(h1)=.1(dom(s)) \n. dom(h2)=.2(dom(s)) . .(f1,f2,S1,S2) . s. h1(f1)= h2(f2)=max({0}l S1 l S2)} Here, ++f is short for . \n.f := !f+1; !f;and .i : P(Loc\u00d7Loc) . P(Loc) for the appropriate projection function. Similar to the world \nconstruction in Section 7.1, states s . w.S are functions de.ned for those locations (f1,f2) that, intuitively, \nwere allocated in an instance of e1 and e2, respectively. They are mapped to sets S1 and S2 of positive \nintegers, representing6 the current inhabitants of the abstract types a and \u00df, respectively, for that \ninstance. The crucial invariant here is that S1 and S2 are always disjoint. The local knowledge w.L declares \ne1 s functions equivalent to those of e2; it also de.nes the meaning of type n a e1 as the identity relation \nrestricted to those numbers that inhabit a in the instance pair identi.ed by f1 (and similarly for n \n\u00dfand \u00df). e1 6 To keep the de.nitions as simple as possible, the state space includes some states that \nactual program behaviour cannot result in (but that nevertheless are consistent with the property we \nwant to prove). According to this interpretation, the transition relation only allows S1 and S2 to grow \n(the distinction between public and private transitions is not needed for this example). Finally, w.H \nsays that the related heaps at state s are any (h1,h2) where hi contains exactly those locations allocated \nin instances of ei,and each such location stores the largest value handed out so far (no matter if at \na or \u00df). This latter condition is critical to ensure that S1 and S2 stay disjoint in each instance. Using \nthis world, it is straightforward to .nish the proof. Details can be found in the online appendix. 7.4 \nWorld Generators As one may observe from the examples in Sections 7.1 and 7.3, worlds must often describe \nn-ary state spaces, where each state consists of n copies of states drawn from some simpler state space, \none copy for each dynamic instance of the object or ADT. Thus, it would be convenient if one were able \nto reason about program equivalence under the degenerate case of a single copy (i.e., n =1). Fortunately, \nit is not hard to (i) de.ne a world generator that, given a single-instance world, automatically performs \nthe multiplexing; and (ii) show that program equivalence in a single-instance world implies equivalence \nin the automatically multiplexed world. For space reasons, we do not present the details here but refer \nthe interested reader to our online appendix, where the proofs of the examples from Sections 7.1 and \n7.3 are simpli.ed greatly with the help of such a world generator.  8. Transitivity In this section, \nwe brie.y sketch our proof of transitivity of RTS equivalence in the pure, simpli.ed setting of .\u00b5 (as \nde.ned in Section 4). Transitivity also holds for the full RTS model described in Section 6, but the \nproof of that result is much more complex (involving a notion of weak isomorphism between worlds), so \nwe leave its presentation to a future paper. The main lemma we would like to prove is the following: \nLemma 6. If G f e1 ~L1 e2 : t and G f e2 ~L2 e3 : t ,then there exists L such that G f e1 ~L e3 : t. \nNaturally, we can expect L to be some sort of composition of the given local knowledges L1 and L2. De.ning \nthis composition is, however, quite subtle. The problem is that the local knowledge takes the global \nknowledge G as a parameter, but then what global knowledges GL1 and GL2 should be passed on to L1 and \nL2 in constructing L? Assuming we somehow pick GL1 and GL2 appropriately, L can be de.ned as follows: \nL(G)(t ):= L1(GL1 )(t ) . L2(GL2 )(t ) where . stands for ordinary relation composition. The key part \nof the proof is showing transitivity of E: .G . GK(L). (e1' ,e2' ) . E(GL1 )(t ) . '' '' (e2,e3) . E(GL2 \n)(t )=. (e1,e3) . E(G)(t ) In order to prove this, we want the disjunct of E by which e1 ' and e2 ' are \nrelated to match the disjunct of E by which e2 ' and e3 ' are related (recall the three disjuncts in \nthe de.nition of E). To illustrate, say e1 ' and e2 ' are related because they reduce to related values \n(second disjunct). Now consider the three cases regarding e2 ' and e3' : (1) They both diverge. Fortunately, \nthis contradicts our assumption about e2' , so this case cannot arise. (2) They are related for the \nsame reason as e ' 1 and e ' 2 are i.e., e ' 2 and e ' 3 reduce to related values. This is the good case. \nRelying on determinacy of reduction, we are done if we can show transitivity of the value relation. Formally, \nwe need to show that GL1 (t ) . GL2 (t ) . G(t).  (3) They reduce to related function calls with related \ncontinuations. It is unclear how to make sense of this situation, so we want to rule it out! In order \nto make case (2) straightforward to show, while simultane\u00adously ruling out case (3) from consideration, \nwe will need to de.ne GL1 and GL2 carefully. The key idea is as follows: for each pair of function values \n(f1,f3) . G, come up with a value, v2, that (1) uniquely identi.es f1 and f3, and that (2) is not a normal \nfunction, but rather a bad value that gets stuck when applied to an argument. The .rst requirement allows \nus to ensure GL1 (t) . GL2 (t)= G(t ),as needed in proving transitivity of the value relation, by relating \n(f1,v2) . GL1 and (v2,f3) . GL2 . The second requirement, together with Lemma 3, rules out the bad case \n(3) above. Formally, since Type and CVal are countable sets, there exists an injective function I . Type \n\u00d7 Type \u00d7 CVal \u00d7 CVal . N. Using this function, one can decompose G . VRelF as follows: G(1)(t1.t2):= \n{ (f1, I(t1,t2,f1,f3)) | (f1,f3) . G(t1.t2) }G(2)(t1.t2):= { (I(t1,t2,f1,f3),f3) | (f1,f3) . G(t1.t2) \n} Taking GL1 to be G(1) is, however, incorrect because if L1 relates any values at function type, then \nthe global knowledge will not be closed w.r.t. it (i.e., G(1) ./GK(L1)). To address this problem, we \nsimply close G(1) accordingly, i.e., we take GL1 to be the least solution to the .xed-point equation \nGL1 = L1(GL1 ) . G(1) (and similarly for GL2 ). With these de.nitions, we can show GL1 (t) . GL2 (t )= \nG(t ) (if G . GK(L)). Moreover, if we are in case (3) above, then Lemma 3 tells us that the functions \nbeing called say, (f1,f2) are really external, meaning that they are related by G(2). But by construction, \nthis means that f2 is an integer and thus e2 ' gets stuck, contradicting the prior assumption that e1 \n' and e2 ' reduce to values. For further details, we refer the interested reader to our online appendix. \n9. Related Work and Discussion Our method of relation transition systems builds closely on ideas from \nseveral prior techniques. We compare here only to the most immediately related work. Kripke Logical Relations \nThe method of logical relations is an old and fundamentally important technique for proving a variety \nof deep properties in higher-typed languages, such as strong normal\u00adization [14] and parametricity [31]. \nAlthough they were originally geared toward reasoning about pure .-calculi, logical relations have been \nsuccessfully generalized to reason about state. In Pitts and Stark s seminal work on Kripke logical relations \n(KLRs) [29], logical relations are indexed by possible worlds, which characterize the runtime environment \n(e.g., the assumptions about heaps) under which two programs are considered to be equivalent. In the \nmost recent work on KLRs, Dreyer et al. [5, 12] showed how to generalize Pitts and Stark s technique \nto reason about (1) modules whose correctness proofs require .ne-grained control over how local state \nevolves over time, and (2) ML-like languages with higher-order state. W.r.t. point (1), they model possible \nworlds as state transition systems (STSs), as we have described in Section 5. RTSs adopt Dreyer et al. \ns STS technique directly, and thus it is relatively straightforward to port all the F\u00b5! equivalence proofs \ngiven in their papers from using KLRs to using RTSs. W.r.t. point (2), the challenge of supporting higher-order \nstate in Kripke logical relations is that a naive attempt to construct a model of general reference types \nleads to a circularity. Intuitively, f1 and f2 are related at ref t under a possible world W iff W encodes \nthe invariant that the heaps of the two programs map f1 and f2 to values v1 and v2 that are logically \nrelated at type t . But how can the logical relation be indexed by a possible world W , which itself \nis de.ned in terms of the logical relation? If t is restricted to base type (e.g., int), there s no issue \nbecause the logical relation at int is simply the identity relation, but at higher type we have a problem. \nDreyer et al. handle higher-order state by means of Appel, McAllester, and Ahmed s technique of step-indexed \nlogical rela\u00adtions (SILRs) [6, 2]. That is, they cut the aforementioned semantic circularity by indexing \nthe model by a natural number ( step in\u00addex ) k, which represents the number of steps left on the clock \nand which gets decremented every time around the cycle between logical relations and possible worlds. \nWhile step-indexing is a powerful weapon, it can be somewhat annoying to work with, due to the tedious \nthreading of step count\u00ading throughout proofs [11]. More importantly, it seems fundamen\u00adtally dif.cult \nto compose SILR proofs transitively. Ahmed stud\u00adied the transitivity problem in her .rst paper on binary \nSILRs [3]. There, she observed a serious problem in naively proving that Ap\u00adpel and McAllester s original \nbinary SILRs formed a PER. She pro\u00adposed a way of regaining transitivity of SILRs for a pure language \nwith recursive types [3], but her approach relies on baking syntactic typing assumptions into the model. \nSuch an approach is unlikely to scale to reasoning about the intermediate and low-level languages of \na certi.ed compiler (one of our ultimate goals), which in gen\u00aderal may be untyped. Moreover, we are not \naware of any successful attempts to generalize her technique to SILRs for richer languages. RTSs employ \nthe idea of global knowledge in order to avoid the need for step-indexing in modeling higher-order state. \nSpecif\u00adically, by parameterizing the heap relations in our worlds over the global knowledge G, we give \nheap invariants a way of referring to the global value equivalence, which is essentially what the step\u00adindexed \nstrati.cation of Kripke worlds is trying to achieve as well. In contrast to SILRs, we already have a \nproof that RTS equivalence for F\u00b5! is transitive, and our method does not bake in any syntac\u00adtic typing \nassumptions. In fact, our transitivity proof depends on instantiating global knowledge parameters with \ntrashy (syntacti\u00adcally ill-typed) relations. Bisimulations Aside from their general coinductive .avor, \nRTSs are closely related to two different bisimulation techniques. From normal form (or open) bisimulations \n[32, 21, 34, 22, 23], we take the idea of treating unknown equivalent functions as black boxes. In particular, \nour expression equivalence relation E,which deals explicitly with the possibility (in its third disjunct) \nthat re\u00adlated terms may get stuck by calling unknown functions, is highly reminiscent of the formulation \nof normal form bisimulations. The main difference is that we express the notion of stuckness se\u00admantically, \nvia the global knowledge parameter G, whereas nor\u00admal form bisimulations express it syntactically by \nrequiring related stuck terms to share a common head variable. Normal form bisimulations draw much inspiration \nfrom game\u00adsemantics models [25], and our distinction between global and local knowledge has a seemingly \ngamey .avor as well. We leave a deeper study of the connection to game semantics to future work. Sumii \net al. s environmental bisimulations (aka relation-sets bisimulations ) are perhaps the most powerful \nform of bisimula\u00adtion yet developed for ML-like languages [27, 36, 19, 33, 35]. As the latter name suggests, \nthese bisimulations are not term relations, but sets X whose elements are themselves term relations R \n(possi\u00adbly paired with some additional environmental information, such as knowledge about the state of \nthe heap). In essence, each R .X de\u00ad.nes some piece of local knowledge (following our terminology) about \nprogram equivalence. In order to show X to be a bisimula\u00adtion, one must check that for all R .X , uses \nof terms related by R will never result in observably different outcomes and will always produce values \nthat are related by some R ' .X s.t. R ' . R.  Viewed in terms of RTSs, one can understand an environmental \nbisimulation X as effectively de.ning an abstract state space, with each R .X as a distinct state. However, \nthe accessibility (transi\u00adtion) relation between these states is essentially baked in: roughly speaking, \na term relation R ' is (publicly) accessible from another term relation R if R ' . R. Thus, environmental \nbisimulations pro\u00advide less control over the structure of the transition system than RTSs do, and they \ndo not support anything directly analogous to the distinction between public and private transitions. \nAs a consequence, environmental bisimulations are most effec\u00adtive at proving equivalences that require \ntransition systems with only public transitions (e.g., the twin abstraction example), and their proofs \nfor examples where private transitions are required (e.g., the well-bracketed state change example) are \ncomparatively brute-force . It is an open question whether environmental bisim\u00adulations can be generalized \nto support the full power of RTSs with both public and private transitions. Our approach to reasoning \nabout parametricity of ADTs, by populating the local knowledge of a world with relations at abstract \ntype names, is inspired directly by Sumii and Pierce [36]. Large vs. Small Worlds While RTSs build very \nclosely on the state transition systems in Dreyer et al. s KLRs [5, 12], there is a big difference between \nthem, which we like to think of in terms of large vs. small worlds. Under Dreyer et al. s approach, in \norder to demonstrate the equivalence of functions f1 and f2 under a possible world W , one proves that \nthey behave the same when passed arguments that are related under any future world W ' of W , which may \ncontain arbitrary new invariants concerning the local state of other modules in the program. One can \nreally think of the future world relation (i.e., the Kripke structure) as de.ning its own transition \nsystem (or large world), with the possible worlds W as its states. In contrast, our RTSs rely only on \nsmall worlds. For us, worlds W are static entities that contain only the local invariants relevant to \nthe module we are reasoning about, and nothing about any invariants for other parts of the program. In \nproving equivalence of functions f1 and f2 under W , we never quantify over any future worlds that extend \nW . Of course, in order to support compositional reasoning i.e., in order to show that consistency of \nworlds is preserved under separating conjunction we must show that f1 and f2 behave the same when applied \nto arguments drawn from some larger relation than just W s local knowledge; but for that purpose we quantify \nover the global knowledge G, which is not a world, but rather an arbitrary extension of W s local knowledge. \nThese different accounts of worlds are strongly reminiscent of the different techniques that have been \nproposed for modeling re\u00adsource invariants in logics of storable locks. Gotsman et al. [15] and Hobor \net al. [16] presented, roughly contemporaneously, two different models of a concurrent separation logic \nfor local reason\u00ading about programs that dynamically allocate locks and store them in the heap. The central \nchallenge in developing such a model is in dealing with the semantic circularity that arises when accounting \nfor locks whose resource invariants are essentially recursive. Gotsman et al. deal with this circularity \nsyntactically, by as\u00adsuming a static set of named sorts of resource invariants, which includes not all \npossible invariants, but only those needed for rea\u00adsoning about a particular program. In contrast, Hobor \net al. (and more recently, Buisse et al. [10]) deal with the circularity head-on, de.ning once and for \nall what recursive resource invariants mean using step-indexing. The latter is analogous to Dreyer et \nal. s large worlds approach, which de.nes the space of all possible heap in\u00advariants, while the former \nis analogous to our small world ap\u00adproach of de.ning only the heap invariants needed within the mod\u00adule \nwe are reasoning about. Which is better? It is hard to say. Our small-world relations seem easier to \ncompose transitively, precisely because we make no assumption whatsoever about the relatedness of functions \nde\u00ad.ned outside of whatever module we are reasoning about. That is, the global knowledge G that we quantify \nover (e.g., when proving world consistency) could include complete garbage, and the tran\u00adsitivity proof \nsketched in Section 8 relies in a fundamental way on the surgical insertion of contentful garbage into \nthe global knowl\u00adedge. On the other hand, it is also possible that this approach is what leads our model \nnot to validate .-equivalence. The Trouble with .-Equivalence One limitation of RTSs is that they do \nnot validate the .-equivalence rules for function and uni\u00adversal types. To see why, suppose the . rule \nfor functions were true (a similar argument applies to universals): f : t1 . t2 f f ~ .x.f x : t1 . t2 \nThen, by de.nition, there would exist a consistent world W s.t. for all G . GK(W ), and for all functions \nf1 and f2 related by G,we would have f1 and .x. f2 x related by G as well. (We re glossing over the role \nof states and transitions here because they re orthogo\u00adnal.) The problem is that it is easy to construct \nan uncivilized G that contains (f1,f2) but not (f1,.x. f2 x). Ironically, the same uncivilized G s that \nmake our proof of transitivity (Section 8) pos\u00adsible also cause . to fail. As a result, there are certain \nexamples that have appeared in the literature on relational reasoning for ML-like languages [36, 22, \n11], which our method cannot handle, precisely because they depend fundamentally on .-equivalence. The \nbest-known one is the syntactic minimal invariance example [30], which demonstrates that the in.nite \n.-expansion at a general recursive type (e.g., \u00b5a.unit +(a . a)) is equivalent to the identity function. \nThe lack of . in our model makes a lot of sense because our proofs make no assumptions about whether \nunknown functions are even .-expressions, let alone whether they obey ..Inthisre\u00adspect, RTSs are again \nsimilar to normal form bisimulations [21, 34], which are sometimes easier to prove congruent in their \nnon-.\u00adsupporting formulations. There are known ways to close normal form bisimulations over .-equivalence \nby complicating the de.\u00adnition of consistency, and it is possible that we could adapt such techniques \nto work for RTSs. However, our concern, based at this point solely on intuition, is that there may be \na fundamental tradeoff between supporting . and supporting transitive composition of RTS equivalence \nproofs. In that case, we would consider transitivity a more important desider\u00adatum, at least in the context \nof reasoning about multi-phase com\u00adpiler correctness. Moreover, our lack of support for . may in fact \nrender our method applicable to reasoning about higher-order lan\u00adguages with more restricted equational \ntheories (e.g., OCaml with its equality tests on function pointers). We leave this matter to be explored \nfurther in future work. 10. Conclusion and Future Work We have developed a novel method relation transition \nsystems for proving equivalence of ML-like programs, combining some of the best aspects of Kripke logical \nrelations, environmental bisimu\u00adlations, and normal form bisimulations. In addition to providing a useful \nsynthesis of the complementary advantages of its ancestors, our method shows promise as a way of reasoning \nabout equiva\u00adlences between different languages, thanks to (1) our avoidance of syntactic devices that \nwould preclude inter-language reasoning, and (2) the transitive composability of RTS equivalence proofs. \nWe have brie.y sketched the proof of transitivity here in a simpli.ed setting, and we intend to report \non the full transitivity result in a forthcoming paper. We have mechanized the metatheory of RTSs in \nCoq and made the proofs available at the link below.  There are several exciting directions for future \nwork. First and foremost, we aim to concretely demonstrate the suitability of RTSs for inter-language \nreasoning. For example, we would like to take Hur and Dreyer s recent work on Kripke logical relations \nbetween ML and assembly [17], replace the logical relations with RTSs, and then apply the technique to \nreasoning about compositional correctness of multi-phase compilation. Second, following Dreyer et al. \ns work on Kripke logical rela\u00adtions [12], we would like to explore how well our account of RTSs can be \nadapted to handle the introduction of control effects (call/cc, exceptions) into the language and/or \nthe restriction of the language to .rst-order state. In principle, we believe it should be possible to \nemploy techniques similar to theirs, but we have not yet tried. Lastly, we have recently discovered what \nappears to be a deep connection between our technique of global vs. local knowledge and Mendler-style \nrecursion [24, 38], in particular the notion of a robustly post.xed-point (rpofp). L is de.ned to be \na rpofp of an endofunction F if .G = L. L = F (G). This bears a striking resemblance to our de.nition \nof consistency for local knowledges L, at least in the pure setting of Section 4. One interesting feature \nof rpofps is that they enjoy a robust version of Tarski s .xed\u00adpoint theorem, which applies even when \nthe endofunction F is not monotone. Indeed, in our scenario, F is not monotone, due to the quanti.cation \nover related function arguments, and this is precisely what motivated our parameterization over G. We \nintend to explore this connection further in future work.   Online Appendix Details of the RTS metatheory \n(in PDF and Coq) are available at: http://www.mpi-sws.org/~dreyer/papers/marriage Acknowledgments We \nthank Deepak Garg, Eijiro Sumii, and the anonymous reviewers for very helpful feedback on the paper, \nas well as Andrew Pitts for alerting us to the connection with Mendler-style recursion.  References \n[1] S. Abramsky. The lazy lambda calculus. In D. A. Turner, editor, Research Topics in Functional Programming, \npages 65 117. 1990. [2] A. Ahmed. Semantics of Types for Mutable State. PhD thesis, Princeton University, \n2004. [3] A. Ahmed. Step-indexed syntactic logical relations for recursive and quanti.ed types. In ESOP, \n2006. [4] A. Ahmed and M. Blume. An equivalence-preserving CPS translation via multi-language semantics. \nIn ICFP, 2011. [5] A. Ahmed, D. Dreyer, and A. Rossberg. State-dependent representa\u00adtion independence. \nIn POPL, 2009. [6] A. Appel and D. McAllester. An indexed model of recursive types for foundational proof-carrying \ncode. TOPLAS, 23(5):657 683, 2001. [7] N. Benton and C.-K. Hur. Biorthogonality, step-indexing and com\u00adpiler \ncorrectness. In ICFP, 2009. [8] L. Birkedal, R. E. M\u00f8gelberg, J. Schwinghammer, and K. St\u00f8vring. First \nsteps in synthetic guarded domain theory: step-indexing in the topos of trees. In LICS, 2011. [9] L. \nBirkedal, N. Torp-Smith, and H. Yang. Semantics of separation\u00adlogic typing and higher-order frame rules \nfor Algol-like languages. LMCS, 2(5:1), 2006. [10] A. Buisse, L. Birkedal, and K. St\u00f8vring. A step-indexed \nKripke model of separation logic for storable locks. In MFPS, 2011. [11] D. Dreyer, A. Ahmed, and L. \nBirkedal. Logical step-indexed logical relations. LMCS, 7(2:16):1 37, June 2011. [12] D. Dreyer, G. Neis, \nand L. Birkedal. The impact of higher-order state and control effects on local relational reasoning. \nIn ICFP, 2010. [13] D. Dreyer, G. Neis, A. Rossberg, and L. Birkedal. A relational modal logic for higher-order \nstateful ADTs. In POPL, 2010. [14] J.-Y. Girard, Y. Lafont, and P. Taylor. Proofs and Types, volume 7 \nof Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 1989. [15] A. Gotsman, \nJ. Berdine, B. Cook, N. Rinetzky, and M. Sagiv. Local reasoning about storable locks and threads. In \nAPLAS, 2007. [16] A. Hobor, A. Appel, and F. Zappa Nardelli. Oracle semantics for concurrent separation \nlogic. In ESOP, 2008. [17] C.-K. Hur and D. Dreyer. A Kripke logical relation between ML and assembly. \nIn POPL, 2011. [18] V. Koutavas, P. B. Levy, and E. Sumii. From applicative to environ\u00admental bisimulation. \nIn MFPS, 2011. [19] V. Koutavas and M. Wand. Small bisimulations for reasoning about higher-order imperative \nprograms. In POPL, 2006. [20] J. Laird. A fully abstract trace semantics for general references. In ICALP, \n2007. [21] S. Lassen. Eager normal form bisimulation. In LICS, 2005. [22] S. B. Lassen and P. B. Levy. \nTyped normal form bisimulation. In CSL, 2007. [23] S. B. Lassen and P. B. Levy. Typed normal form bisimulation \nfor parametric polymorphism. In LICS, 2008. [24] N. P. Mendler. Inductive types and type constraints \nin the second\u00adorder lambda-calculus. Annals of Pure and Applied Logic, 51(1 2):159 172, 1991. [25] A. \nS. Murawski and N. Tzevelekos. Game semantics for good general references. In LICS, 2011. [26] G. Neis, \nD. Dreyer, and A. Rossberg. Non-parametric parametricity. JFP, 21(4&#38;5):497 562, 2011. [27] B. C. \nPierce and D. Sangiorgi. Behavioral equivalence in the poly\u00admorphic pi-calculus. Journal of the ACM, \n47(3):531 586, 2000. [28] A. Pitts. Typed operational reasoning. In B. C. Pierce, editor, Advanced Topics \nin Types and Programming Languages, chapter 7. MIT Press, 2005. [29] A. Pitts and I. Stark. Operational \nreasoning for functions with local state. In HOOTS, 1998. [30] A. M. Pitts. Relational properties of \ndomains. Information and Computation, 127:66 90, 1996. [31] J. C. Reynolds. Types, abstraction and parametric \npolymorphism. In Information Processing, 1983. [32] D. Sangiorgi. The lazy lambda calculus in a concurrency \nscenario. Information and Computation, 111(1):120 153, 1994. [33] D. Sangiorgi, N. Kobayashi, and E. \nSumii. Environmental bisimula\u00adtions for higher-order languages. In LICS, 2007. [34] K. St\u00f8vring and S. \nLassen. A complete, co-inductive syntactic theory of sequential control and state. In POPL, 2007. [35] \nE. Sumii. A complete characterization of observational equivalence in polymorphic .-calculus with general \nreferences. In CSL, 2009. [36] E. Sumii and B. Pierce. A bisimulation for type abstraction and recursion. \nJournal of the ACM, 54(5):1 43, 2007. [37] J. Thamsborg and L. Birkedal. A Kripke logical relation for \neffect\u00adbased program transformations. In ICFP, 2011. [38] T. Uustalu and V. Vene. Mendler-style inductive \ntypes, categorically. Nordic Journal of Computing, 6(3):343 361, 1999. [39] V. Vafeiadis. Concurrent \nseparation logic and operational semantics. In MFPS, 2011. [40] P. Wadler. Theorems for free! In FPCA, \n1989.  \n\t\t\t", "proc_id": "2103656", "abstract": "<p>There has been great progress in recent years on developing effective techniques for reasoning about program equivalence in ML-like languages---that is, languages that combine features like higher-order functions, recursive types, abstract types, and general mutable references. Two of the most prominent types of techniques to have emerged are *bisimulations* and *Kripke logical relations (KLRs)*. While both approaches are powerful, their complementary advantages have led us and other researchers to wonder whether there is an essential tradeoff between them. Furthermore, both approaches seem to suffer from fundamental limitations if one is interested in scaling them to inter-language reasoning. In this paper, we propose *relation transition systems (RTSs)*, which marry together some of the most appealing aspects of KLRs and bisimulations. In particular, RTSs show how bisimulations' support for reasoning about recursive features via *coinduction* can be synthesized with KLRs' support for reasoning about local state via *state transition systems*. Moreover, we have designed RTSs to avoid the limitations of KLRs and bisimulations that preclude their generalization to inter-language reasoning. Notably, unlike KLRs, RTSs are transitively composable.</p>", "authors": [{"name": "Chung-Kil Hur", "author_profile_id": "81436594089", "affiliation": "MPI-SWS, Saarbruecken, Germany", "person_id": "P2991339", "email_address": "gil@mpi-sws.org", "orcid_id": ""}, {"name": "Derek Dreyer", "author_profile_id": "81100381796", "affiliation": "MPI-SWS, Saarbruecken, Germany", "person_id": "P2991340", "email_address": "dreyer@mpi-sws.org", "orcid_id": ""}, {"name": "Georg Neis", "author_profile_id": "81442619526", "affiliation": "MPI-SWS, Saarbruecken, Germany", "person_id": "P2991341", "email_address": "neis@mpi-sws.org", "orcid_id": ""}, {"name": "Viktor Vafeiadis", "author_profile_id": "81100493655", "affiliation": "MPI-SWS, Kaiserslautern, Germany", "person_id": "P2991342", "email_address": "viktor@mpi-sws.org", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103666", "year": "2012", "article_id": "2103666", "conference": "POPL", "title": "The marriage of bisimulations and Kripke logical relations", "url": "http://dl.acm.org/citation.cfm?id=2103666"}