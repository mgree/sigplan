{"article_publication_date": "01-25-2012", "fulltext": "\n On the Power of Coercion Abstraction Julien Cretin Didier R\u00e9my INRIA {julien.cretin,didier.remy}@inria.fr \nAbstract Erasable coercions in System F., also known as retyping functions, are well-typed .-expansions \nof the identity. They may change the type of terms without changing their behavior and can thus be erased \nbefore reduction. Coercions in F. can model subtyping of known types and some displacement of quanti.ers, \nbut not sub\u00adtyping assumptions nor certain forms of delayed type instantiation. We generalize F. by allowing \nabstraction over retyping functions. We follow a general approach where computing with coercions can \nbe seen as computing in the .-calculus but keeping track of which parts of terms are coercions. We obtain \na language where coercions do not contribute to the reduction but may block it and are thus not erasable. \nWe recover erasable coercions by choosing a weak reduc\u00adtion strategy and restricting coercion abstraction \nto value-forms or by restricting abstraction to coercions that are polymorphic in their domain or codomain. \nThe latter variant subsumes F., F<:, and MLF in a uni.ed framework. Categories and Subject Descriptors \nD.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory General Terms Design, Languages, Theory \nKeywords Type, System F, F-eta, Polymorphism, Coercion, Con\u00adversion, Retyping functions, Type containment, \nSubtyping, Bounded Polymorphism. 1. Introduction Parametric polymorphism and subtyping polymorphism are \nthe two most popular means of increasing expressiveness of type systems: although .rst studied independently, \nthey can be advantageously combined together. Each mechanism alone is relatively simple to understand \nand has a more or less canonical presentation. However, their combination is more complex. The most popular \ncombination is the language F<: [Cardelli 1993]. However, this is just one (relatively easy) spot in \nthe design space. In fact, much work in the 90 s has been devoted to improving the combination of parametric \nand subtyping polymorphism, motivated by its application to the typechecking of object-oriented features. \nContravariance, the key ingredient of subtyping polymorphism, is already modeled in the language F. proposed \nby Mitchell [1988]. One way to de.ne F. is as the closure of Curry-style System F by .-conversion. We \nwrite C[M] for .lling a context C with a term M. Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 12, January 25 27, 2012, Philadelphia, PA, USA. Copyright \nc &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. . . $10.00 A retyping context from t to s is a closed \none-hole context C such that .x.C(x) is an .-expansion of the identity, also called a retyping function, \nand has type t . s in System F. If C is a retyping context from t to s and M is a term of type t , then \nC[M] is a term of type s in System F. In System F., the type-containment rule allows M itself to be claimed \nof type s. Moving to Church-style System F, we may keep type-containment, i.e. .lling of retyping contexts \nexplicit. We write G(M) for the application of retyping context (i.e. a coercion) G to the term M. We \nwrite .t for the empty (retyping) context of type t . Contravariance is induced by .-expansion as follows: \nif G1 and G2 are retyping contexts from t1 to t1{and from t2 to t2{, then .(x : t1) G2(.t1{.t2 (G1(x))) \nis a retyping context from type t1{. t2 to t1 . t2{. Besides contravariance, .-expansion also introduces \nopportu\u00adnities for inserting type abstractions and type applications, which may change polymorphism a \nposteriori. For instance, from the type .a. t . s, we can .nd a retyping context to any type of the form \n\u00af (.a. t) . (. \u00af\u00df does not appear free in \u00df. s[a . .]) provided .a. s; this context is .(x : .a. t ) \n.\u00df\u00af..a. t.s . (x.). Such re\u00adtypings are not supported in F<: where polymorphism can only be introduced \nand eliminated explicitly at the topmost part of terms. Conversely, F<: allows reasoning under subtyping \nassump\u00adtions, which F. does not support. Indeed, bounded quanti.cation .(a<: t ) M of F<: introduces \na type variable a that stands for any subtype of t inside M. In particular, a covariant occurrence of \na in M can be converted to type t by subtyping. Therefore F. and F<: are incomparable: is there a language \nthat supersedes both? Before we tackle this question, let us .rst consider another form of retyping assumptions \nthat have been introduced in MLF [Le Botlan and R\u00e9my 2009]: instance-bounded polymor\u00ad phism .(a = t ) \nM introduces a type variable a that stands for any instance of t inside M. That is, an occurrence of \ntype a within M in an instantiable position can be converted to any instance of t. Instance-bounded quanti.cation \ndelays the choice of whether a polymorphic expression should be instantiated immediately or kept polymorphic. \nThis mechanism enables expressions to have more general types and has been introduced in MLFto enable \npartial type inference in the presence of .rst-class second-order polymorphism and some type annotations. \nNotice that bounded type instantiation allows for deep type in\u00adstantiation of binders, as F. does, but \nusing a quite different mech\u00adanism. Bounded type instantiation has similarities with bounded quanti.cation \nof F<:, but the two also differ signi.cantly, since for instance, type conversion is not congruent on \narrow types in MLF. Surprisingly, among the three languages F., F<:, and MLF, any combination of two \nhave features in common that the other one lacks! Hence, the challenge becomes whether all their features \ncan be combined together. This question has in fact already been raised in previous work on MLF [R\u00e9my \nand Yakobowski 2010]. Our contributions We answer positively by introducing a lan\u00adguage F.p that extends \nF. with abstraction over retyping functions, combining all features simultaneously in a uni.ed framework \n(\u00a75). The language F.p subsumes F., F<:, and MLF (\u00a76); it also .xes and extends a previous language of \ncoercions designed for model\u00ading MLF alone [Manzonetto and Tranquilli 2010]. Our subset of F.p that coincides \nwith MLFis well-behaved: it satis.es the subject reduction and progress lemmas and strongly normalizes. \nIt also has an untyped semantics. Actually, the extension of F. with abstraction over coercion functions \nleads to a larger language F. of which F.p is a restriction (\u00a72). The language F. is well-behaved. We \nshow that F. can be simulated into System F. Hence, reduction rules in F. are just particular instances \nof \u00df-reduction (\u00a74). F. can also be simulated into the untyped .-calculus, by dropping coercions, which \nshows that coercions do not contribute to the computation. Unfortunately, they may block it, and are \nthus not erasable (\u00a73). Erasability can be recovered by choosing a weak reduction strategy (\u00a77), but \nthis is not entirely satisfactory. So, other restrictions or extensions of F. with erasable coercions \nare still to be found. Nevertheless, we believe that F. is a solid ground for understanding erasable \ncoercions (\u00a79). System F All languages we consider are second order calculi whose origin is System F. \nSystem Fcomes in two .avors: in Curry\u00adstyle, terms do not carry type information and are thus a subset \nof the untyped .-calculus, while in Church-style, terms carry explicit type information, namely type \nabstractions, type applications, and annotations of function parameters. Of course, both presentations \nare closely related, since there is a bisimulation between the reduction of terms in Church-style and \nterms in Curry-style via type erasure, where the reduction of type application between terms in Church-style \nis re.ected as an equality on terms in Curry-style. That is, calling . the reduction of type applications \nand \u00df the reduction of term applications, the type erasures of two explicitly-typed terms related by \n\u00df-reduction (resp. .-reduction) are related by \u00df-reduction (resp. equality); conversely, if the erasure \nof a term M\u00df-reduces to a term M{, then M also reduces by a sequence of .-reductions followed by a single \n\u00df\u00adreduction to a term whose erasure is M{. Both views are equally useful: we prefer source expressions \nto be explicitly typed, so that type checking is a trivial process and types can be easily maintained \nduring program transformations; we also wish types to be erasable after compilation for ef.ciency of \nprogram execution. Moreover, a source language with an untyped semantics is generally simpler to understand, \nreason about, and use. We may argue that even if the source language has intentional polymorphism, it \nshould .rst be compiled in a type-dependent way to an intermediate language with an untyped semantics \n[Crary et al. 2002]. From types to type conversions Our approach to coercions is sim\u00adilar to polymorphism \nin System F because we focus here on retyp\u00ading functions that are erasable. In some circumstances, one \nmay use other forms of coercions that may have some computational content, e.g. change the representation \nof values, and thus not be erasable. Then, we should compile source expressions into an inter\u00admediate \nlanguage where remaining coercions, if any, are erasable; this is then the language we wish to study \nhere. Erasability also means that the dynamic semantics of our lan\u00adguage is ultimately that of the underlying \n.-calculus possibly en\u00adriched with more constructs. Therefore the semantics only depends on the reduction \nstrategy we choose and not on the typechecking details nor on the coercions we may use. Types are useful \nfor pro\u00adgrammers to understand their programs. It is also useful for pro\u00adgrammers that types do not determine \nthe semantics of their pro\u00adgrams. At least, we should provide an intermediate representation in which \nthis is true. Coercions may also be introduced a posteriori to make type con\u00adversions explicit inside \nsource terms. Coercions usually simplify the meta-theoretical study of the language by providing a concrete \nsyntax to manipulate typing derivations. Proofs such as subject re\u00adduction become computation on concrete \nterms instead of reason\u00ading on derivations. While in practice programming languages use weak evaluation \nstrategies, strong evaluation strategies provide more insight into the calculus by also modeling reduction \nof open terms. Since our fo\u00adcus is on understanding the essence of coercions, and the meta\u00adtheoretical \nproperties, we prefer strong reduction strategies. Impos\u00ading a weak reduction strategy on a well-behaved \nstrong calculus af\u00adterward is usually easy even if all properties do not automatically transfer. Conversely, \nproperties for weak reduction strategies do not say much about strong reduction strategies. The two faces \nof F. Let us .rst return to the de.nition of F., which in Mitchell s original presentation is given in \nCurry-style. It is de.ned by adding to System F a type containment rule that allows to convert a term \nM of type t to one of type s whenever there exists a retyping context from type t to s, which we write \nf tCs. This judgment, called type containment, is equivalent to the existence of a (closed) retyping \nfunction M{ of System F such that fM{ : t . s, i.e. a function that is an .-expansion of the identity. \nInterestingly, Mitchell gave another characterization of type containment, exhibiting a proof system \nfor the judgment f tC s, which can be read back as the introduction of a language of coer\u00adcions whose \nexpressions G witness type containment derivations. Then, we write f G : tC s where G fully determines \nthe typ\u00ading derivation much as a Church-style System-F term M fully determines its typing derivation. \nFor example, G1 . G2 is a co\u00adercion that, given a function M, returns a function that coerces its argument \nwith G1, passes it to M, and coerces the result with G2 hence the contravariance of type containment. \n(A full presentation of coercions appears in \u00a72 where F. is described as a subset of F..) The interpretation \nof coercions as .-terms is more intuitive than coercions as proof witnesses. Unfortunately, its formal \npresentation F.., which is equivalent to F., is technically more involved for rea\u00adsons explained in \u00a74. \nHence, we prefer to present F. .rst in \u00a72 and only introduce F.. informally in \u00a74. Interestingly, the \nrei.cation of F. into System F given in \u00a73.3 already reveals this intuitive inter\u00ad pretation of coercions \nwithout the technicalities and we refer to it when describing the typing rules and reduction rules of \nF.. In Church-style System F, the use of a coercion G around a term M is witnessed explicitly as G(M). \n(We may continue seeing a coercion G as a retyping context and reading this as .lling the hole of G or, \nequivalently, see G as a retyping function and read this as an application of a coercion to a term.) \nReduction rules are added to reduce such applications when both G and M have been suf.ciently evaluated \nin a way depending on the form of both so that a coercion G is never stuck in the middle of a (well-typed) \nredex as in (G(.(x : t ) M)) N . The type system ensures that G is of a certain shape for which a reduction \nexists. In the above s example, G may be G1 . G2 and then G(.(x : t ) M) can be reduced to .(x : s) \nG2(M[x . G1(x)]). The genesis of F. To abstract over coercion functions, we intro\u00adduce a new form .(c \n: tC s) M in F., where the parameter c stands for a coercion function that can be used inside M to convert \nan expression of type t to one of type s. This abstraction can be typed as (tCs) . . where . is the type \nof M. Correspondingly, we need a new application form M{G} to pass a coercion G to a coercion abstraction, \ni.e. a term M of type (tC s) . .. By typing constraints, coercion abstractions can only be instan\u00adtiated \nwith coercions, which by construction are erasable. Thus, x, y variables M ::= x | .x.M | MM terms C \n::= .x.[] | [] M|M [] reduction contexts REDCONTEXT M . M{ REDBETA (.x.M) M{ . M[x .M{] C[M] . C[M{] \nFigure 1. .-calculus: syntax and semantics intuitively, coercions do not really contribute to the computation. \nIs this enough to erase them? Formally, we can exhibit a forward simulation between reduction of terms \nin F. and of their erasure in the untyped .-calculus. Moreover, F. has the subject reduc\u00adtion property \nand is strongly normalizing. Still, coercions cannot be erased in F., since although they do not create \nnew evalua\u00adtion paths, they may block existing evaluation paths: a subterm may be stuck while its erasure \ncould proceed. Since coercions are erasable in F., this can only be due to the use of a coercion vari\u00adable. \nIndeed, a coercion variable c may appear in the middle of a \u00df-redex as in (c(.(x : t ) M)) N. This is \nirreducible because reduction of coercion applications G(M) depends simultaneously on the shapes of G \nand M so that no rule .res when G is un\u00adknown. More generally, we call a wedge an irreducible term of \nthe form (G(.(x : t ) M)) N. Notice that the erasure of a wedge (.(x : t) LMJ) LNJ can be reduced, immediately. \nHence, the existence of wedges in reduction contexts prevents erasability. Taming coercions in F.p An \nobvious solution to recover erasabil\u00adity is to make wedge con.gurations ill-typed so that they never \nappear during the reduction of well-typed programs. One interest\u00ading restriction, called F.p (read Parametric \nF.), is to request that co\u00adercion parameters be polymorphic in either their domain or their codomain. \nThis allows coercion variables to appear either applied to a function or inside an application, but not \nboth simultaneously. Another solution is to change the semantics: choosing a weak reduction strategy \nfor coercion abstractions and restricting them to appear only in front of value forms, coercion variables, \nhence wedges, cannot occur in a reduction context any more. This variant is called F.w (read Weak F.). \nAlthough our main goal combining F., F<:, and MLF in a same language is reached, both F.p and F.w are \nrestrictions of F.. We may thus wonder whether other yet more interesting solutions exist. We further \ndiscuss some of the issues in \u00a79, argue about some of the dif.culties in the general case, and suggest \nother restrictions worth exploring. We defer a discussion of related works to \u00a78. 2. The language F. \nThe language F. generalizes F. with abstraction over coercions. We recall the de.nition of the (untyped) \n.-calculus on Figure 1. We normally include pairs and projections both to have non trivial errors (otherwise, \neven untyped terms cannot be stuck) and to have more interesting forms of subtyping. However, we omit \nthem in this summary for conciseness of exposition. We occasionally refer to them informally to explain \nhow the de.nitions generalize to pairs. We assume an enumerable collection of term variables, ranged \nover by letters x and y. Untyped terms, written M, include variables, abstractions .x.M, and applications \nMM{. The semantics of untyped .-terms is given by a small-step strong reduction relation. Reduction contexts \nof the .-calculus are all one-hole contexts, written C. We now write C[M] for the term obtained by .lling \nthe hole of C with M and M[x .M{] for the capture avoiding substitution of M{ for x in M. Expressions \nare considered equal up to the renaming of bound variables, which are de.ned in the t, s ::= a | t . \nt |.a.t |T Types | . . t coercion abstraction . ::= t Ct coercion type M, N ::= x | .(x : t) M | MM Terms \n| .a M | Mt type abs &#38; app | G(M) term coercion | .(c : .) M | M{G} coercion abs &#38; app | .tt \nG ::= c | Topt | G . G Coercions | Dist.a. | Dist.. distributivity t.tt.t | .a G | Gt type abs &#38; \napp | G(G) coercion coercion | .(c : .) G | G{G} coercion abs &#38; app G ::= \u00d8| G,a | G,x : t | G,c \n: . Typing environments Figure 2. Syntax of F.. usual way. This convention applies to the .-calculus, \nas well as to all typed languages presented below. 2.1 Syntax of F. The language F. is explicitly typed. \nTypes are described on Fig\u00adure 2. We assume given an enumerable set of type variables, ranged over by \na and \u00df. Types are type variables, arrow types t . t , polymorphic types .a. t, the top type T, or coercion \nabstractions . . t where the coercion type . is of the form t Ct . Coercions are not .rst class, hence \na coercion type . is not itself a type. The language of expressions is split into terms and coercions. \nWe reuse the term variables of the .-calculus. In addition, we assume an enumerable set of coercion variables \nwritten c. Terms are an extension of Church-style System F. Hence, they include type variables x, abstractions \n.(x : t ) M, applications MM, type abstractions .a M, and type applications Mt . A construct already \npresent in F. is the use of the application G(M) of a coercion G to a term M. There are two new constructs \nspeci.c to F. and not present in F.: coercion abstraction .(c : .) M which is annotated with the coercion \ntype .; and coercion application M{G} that passes a coercion G to a term M and should not be confused \nwith the earlier construct G(M) of F. that places a coercion G around a term M. Since the main purpose \nof coercions is to change types, we could postpone the description of coercion constructs together with \ntheir typing rules and their associated reduction rules that justify the typing rules. Still, each coercion \nexpression can be understood as a one-hole retyping context witnessing some type-containment rule. So \nwe introduce each construct with the retyping context it stands for, also preparing for the rei.cation \nof coercions as System-F terms given in \u00a73.3. A coercion variable c stands for the coercion it will be \nbound to. The opaque coercion Topt is a downgraded version of existential types (we currently do not \nhandle existential types for reasons explained in \u00a79): it turns a term of any type into an opaque term \nof type T that can only be used abstractly. The empty coercion .t stands for the empty retyping context \nand witnesses re.exivity t of type containment. The arrow coercion G1 . G2 stands for .(x : t ) G2([] \n(G1(x))) and witnesses contravariance of the arrow type constructor. The distributivity coercion Dist.a. \nt.s stands for .(x : t) .a [] ax and permutes a type abstraction with a term abstraction: assuming the \nhole has type .a. t . s where a does not appear free in t, it returns a term of type t ..a. s. For instance, \nthe coercion of a polymorphic function .a .(y : t ) N LxJ = x L.a MJ = LMt J = LMJ L.(x : t) MJ = .x.LMJLG(M)J \n= LMJ LMNJ = LMJLNJL.(c : .) MJ = LM{G}J = LMJ Figure 3. Coercion erasure makes it appear as if it had \nbeen de.ned as .(y : t ) .a N which is actually what it will reduce to once coerced. The other distributivity \ncoercion Dist.. t.s, which stands for .(x : t ) .(c : .) ([]{c} x), is similar but permutes a coercion \nabstraction with a term abstraction. We may need more distributivity coercions when extending the language \nof terms. Hence, the notation Distab.c uses the following mnemonic: the superscript a and the subscript \nb . c indicate the kind of the .rst and second type constructs, respectively. They can be combined into \na(b . c) to form the type of the hole, or recombined into b . ac to form the type of the coerced term. \nFor example, Dist.ta. .s is a coercion from .a. (t . s) to t . (.a. s), while Dist.. t.s is a coercion \nfrom . . (t . s) to t . (. . s). The remaining coercions are the lifting of all term constructs without \ncomputational content to coercions: type abstraction .a G and type application Gt; coercion of a coercion \nG{(G) which intu\u00aditively stands for G{(G([])) and witnesses transitivity of coercions: it has type .Cs \nif G{ and G have coercion types t Cs and .Ct , respectively; .nally, coercion abstraction .(c : .) G \nand coercion application G{{G}. All these coercions are of the form P [G] where P is one of the contexts \n.a [], [] t , G{([]), .(c : .) [], or []{G{}, where the hole is .lled with G. It is convenient to overload \nthe no\u00adtation P when the hole holds a term instead of a coercion, although this is formally another syntactic \nnode. We recover the syntax of System F. by removing coercion types from types and coercion variables, \ncoercion abstractions and applications from both terms and coercions. We recover the syntax of System \nF by further removing the top type, term coercions, and all coercion forms, which become vacuous. The \ncoercion erasure, written L\u00b7J, de.ned on Figure 3, is as expected: type annotations on function parameters \nand coercions are erased, while other constructs are projected on their equivalent constructs in the \nuntyped .-calculus.  2.2 Typing rules Typing environments, written G, are lists of bindings where bind\u00adings \nare either type variables a, coercion variables along with their coercion type c : ., or term variables \nalong with their type x : t (Figure 2). We write G f M : t if term M has type t under G and G f G : . \nif coercion G has coercion type . under G. The two typing judgments are recursively de.ned on .gures \n4 and 5. They use auxiliary well-formedness judgments for types and typing contexts: we write G f ok \nto mean that typing environment G is well-formed and G f t or G f . to mean that type t or coercion type \n. is well-formed in G. As usual, we require that typing contexts do not bind twice the same variable, \nwhich is not restrictive as all expressions are considered equal up to renaming of bound variables (details \ncan be found in the extended version). Typing rules for terms are described in Figure 4. Rules TERM-VAR, \nTERMTERMLAM, TERMTERMAPP, TERMTYPELAM, and TERM-TYPEAPP are exactly the typing rules of System F. Rule \nTERMCOER is similar to rule TERMTERMAPP, except that a coercion G of coer\u00adcion type t Cs is used instead \nof a function M of type t . s. Rule TERMCOERLAM is similar to TERMTERMLAM, except that the parameter \nc stands for a coercion of coercion type . instead of a term of type s: the result is a coercion abstraction \nof type . . t . p ::= x | pv | pt | p{G}| c(v) Prevalues | Dist.a. t.t (.a p)| (G t t.t (p)| Dist.a. \n. G)(p)| Dist.. t.t (.(c : .) p) t.t (p)| Dist.. v ::= p | .(x : t ) v | .a v | .(c : .) v | Topt (v) \nValues C ::= .(x : t) [] | [] M | M [] | P Reduction contexts P ::= .a [] | [] t | G([])| .(c : .) [] \n| []{G}Retyping contexts Figure 6. System F.: values and reduction contexts Consistently, TERMCOERAPP \napplies a term that is a coercion ab\u00adstraction of type . . t to a coercion G of coercion type .. Typing \nrules for coercions are described in Figure 5. They are all straightforward when read with the retyping \ncontext that the co\u00adercion stands for in mind. Rule COERVAR reads the coercion type of a coercion variable \nfrom its typing context. The empty coercion has type tCt provided t is well-formed in the current context. \nAs all basic coercions, it contains just enough type information so that its typing rule is syntax-directed. \nThe top coercion Topt converts an expression of type t to the top type, provided t is well-formed. t1 \n The arrow coercion G1 . G2 turns an arrow type t1{. t2 into an arrow type t1 . t2{, provided Gi coerces \ntype ti into ti{for i in {1, 2}. The distributivity coercion Dist.a. turns an expres\u00ad t.s sion of type \n.a. t . s into one of type t ..a. s provided t is well-formed in the current environment, which prevents \na from ap\u00adpearing free in t, and s is well-formed in the current environment extended with a. Finally, \nRule COERDISTCOERARROW is similar to COERDISTTYPEARROW, but swaps a coercion abstraction and a term abstraction. \nThe remaining rules COERTYPELAM, COERTYPEAPP, COER-COER, COERCOERLAM, and COERCOERAPP are similar to \ntheir counterpart for terms, but where the term M of type t has been replaced by a coercion (i.e. a one-hole \ncontext) G of coercion type t1 Ct2, where t1 is the type of the hole and t2 the type of the body. Rule \nCOERTYPELAM for typing .a G introduces a variable a that is bound in G and can be used in the type of \nthe body of G but not in the type of its hole, which is enforced by the .rst premise. In particular, \n.a G builds a coercion to a polymorphic type tC .a. s and not a polymorphic coercion .a.t Cs. Accord\u00adingly, \nonly the codomain of the type of the conclusion is polymor\u00adphic. Rule COERCOERLAM is typed in a similar \nway: .(c : .) G has type t1 C (. . t2) and not . . (t1 Ct2) as one could naively expect which would be \nill-formed. Type and coercion applica\u00adtions are typed accordingly (COERTYPEAPP and COERCOERAPP). The \ntyping rules for F. are obtained by removing TERMCOER-LAM and TERMCOERAPP for terms and their counter \nparts COERCO-ERLAM and COERCOERAPP for coercions as well as Rule COERVAR forcoercionvariablesandRule \nCOERDISTCOERARROW fordistribu\u00adtivity of coercion abstraction. The type superscripts that appear in re.exivity, \ndistributivity, and top coercions make type checking syntax directed. The type superscript in arrow coercions \nis not needed for typechecking but to keep reduction a local rewriting rule. (We may leave superscripts \nimplicit when they are unimportant or can be unambiguously re\u00adconstructed from the context.) Our presentation \nof F. is in Church-style. Curry-style F. is the image of F. by coercion erasure. That is, it is the subset \nof terms of the untyped .-calculus that are the erasure of a term of Church\u00adstyle System F.. We write \nG fM : t to mean that there exists M such that G f M : t and LMJ is M. TERMVAR G f ok x : t . G G f \nx : t G f .(x : t ) M : t . s G f M N : s TERMTYPEAPP TERMCOER TERMCOERLAM G f M : .a. t G f s G f G \n: t C s G f M : t G, c : . f M : t G f Ms : t [a . s] COERDOT COERFORGET G f t G f t G f .t : t Ct G \nf Topt : tC T COERDISTCOERARROW TERMTERMLAM G,x : t f M : s G f G(M) : s TERMTERMAPP G f M : t . s G \nf N : t G f .(c : .) M : . . t Figure 4. System F.: term typings COERARROW {{ G f G1 : t1 Ct 1 G f G2 \n: t2 Ct 2 t1{{ G f G1 . G2 :(t1 . t2) C (t1 . t2) G f t G f . G f s G f Dist.. t.s :(. . (t . s)) C (t \n. (. . s)) COERCOER COERCOERLAM { G f G : t Cs G f G: .Ct G,c : . f G : t Cs COERTYPELAM G f t G,a f \nG : t Cs G f .a G : tC .a. s COERCOERAPP { G f G: tC (. . s) TERMTYPELAM G,a f M : t G f .a M : .a. t \n TERMCOERAPP G f M : . . t G f G : . G f M{G} : t COERDISTTYPEARROW G f t G,a f s G f Dist.a. t.s : .a. \n(t . s) Ct ..a. s COERTYPEAPP { G f G : tC .a. s G f t { G f Gt : tCs[a . t ] COERVAR G f G : . G f ok \nc : . . G G f G(G{) : .Cs G f .(c : .) G : tC (. . s)G f G{{G} : t Cs G f c : . Figure 5. System F.: \ncoercion typings REDCONTEXTBETA M C[M] \u00df N \u00df C[N] REDTERM (.(x : t ) M) N \u00df M[x . N] REDCOER (.(c : \n.) M){G} REDCOERARROW t REDCONTEXTIOTA M . N C[M] . C[N] REDTYPE (.a M) t . M[a . t ] . M[c . G] (G1 \n. G2)(.(x : s) M) . .(x : t) G2(M[x . G1(x)]) REDCOERDISTTYPEARROW Dist.a. . .(x : t ) .a M t{.s{ (.a \n.(x : t ) M) REDCOERDISTCOERARROW Dist.{. . .(x : t ) .(c : .) M t{.s{ (.(c : .) .(x : t ) M) REDCOERDOT \nREDCOERFILL .t (M) . M (P [G])(M) . P [G(M)] Figure 7. Reduction rules for F.  2.3 Dynamic semantics \nThe dynamic semantics of System F. is given by a standard small\u00adstep strong reduction relation. The syntax \nof values and reduction contexts is recalled on Figure 6. A value is an abstraction of a value, an opaque \nvalue Topt (v), or a prevalue. A prevalue is a variable, a prevalue applied to a value, type, or coercion, \na value coerced by a coercion variable, or a partial application of a distributivity coercion. Reduction \ncontexts C are all one-hole term contexts. For convenience, we have distinguished a subset of reduction \ncontexts P , called retyping reduction contexts: a term M placed in a retyping reduction context is just \na retyping of M, i.e. a term that behaves as M but possibly with another type. Reduction rules are de.ned \non Figure 7. We have indexed the reduction rules so as to distinguish between \u00df-steps with compu\u00adtational \ncontent (REDTERM), that are preserved after erasure, and .-steps (REDTYPE) that become equalities after \nerasure. We write \u00df. for the union of \u00df and .. Hence, Rule REDCONTEXT is split into two rules, so as \nto pre\u00adserve the index of the premise. The only \u00df-redex is REDTERM; all other reductions are .-reductions. \nRule REDTYPE is type reduction (a .-reduction). The .rst four rules cover System F. Notice that REDCONTEXT \nallows all possible contexts. Hence, there is no par\u00adticular reduction strategy and a call-by-value evaluation \nwould be a particular case of reduction. Rule REDCOER is the counterpart of \u00df-reduction for coercion \napplication M{G}. It only reduces a term applied to a coercion; a coercion applied to a coercion is a \ncoercion and is not reduced directly, but only when it is applied to a term so that rule REDCO-ERCOERAPP \neventually applies. All other rules reduce the application G(M) of a coercion G to a term M, which plays \nthe role of a destructor: both G and M must be suf.ciently evaluated before it reduces except when G \nis the opaque coercion or a variable since Topt (v) and c(v) are values. Other coercion nodes are all \nconstructors. We thus have one rule for each possible shape of G. The most interesting rules are: t \nWhen G is an arrow coercion G1 . G2 and M is a function .(x : s) M , Rule REDCOERARROW reduces the application \nby pushing G1 on all occurrences of x in M and G2 outside of M. This changes the type of the parameter \nx from s to t, hence the need for the annotation t on arrow coercions.  When G is a distributivity coercion \nDist.a. t{.s{ and M is a poly\u00admorphic function .a .(x : t) M, Rule REDCOERDISTTY-PEARROW reduces the \napplication to .(x : t ) .a M by ex\u00adchanging the type and value parameters; this is sound since a cannot \nbe free in t .  When G is a distributivity coercion Dist.{.  t{.s{ and M is a coer\u00adcion abstraction \nfollowed by a value abstraction .(c : .) .(x : t ) M , Rule REDCOERDISTCOERARROW reduces the application \nto .(x : t ) .(c : .) M by exchanging the parameters. The remaining cases for G can be factored as P \n[G{]. Rule REDCO-ERFILL .lls G{ with M, transforming P [G{](M) into P [G{(M)]. Notice that the two occurrences \nof P are different abstract nodes on each side of the rule a coercion on the left-hand side and a term \non the right-hand side. Rule REDCOERFILL is actually a meta\u00adrule that could be expanded into, and should \nbe understood as, the following .ve different rules: (.a G)(M) . .a (G(M)) REDCOERTYPELAM (Gt)(M) . \n(G(M)) t REDCOERTYPEAPP (G2(G1))(M) . G2(G1(M)) REDCOERCOER (.(c : .) G)(M) . .(c : .)(G(M)) REDCOERCOERLAM \n(G1{G2})(M) . (G1(M)){G2} REDCOERCOERAPP The use of the meta-rule emphasizes the similarity between all \n.ve cases; it is also more concise. For example, the application G1{G2} of a coercion abstraction G1 \nto a coercion G2 is only reduced when it is further applied to a term M (as other complex coercions), \nby .rst wrapping elements of G around M (two .rst steps below) so that Rule REDCOER can .nally .re (last \nstep): ((.(c : t Cs) G){G{})(M) . ((.(c : t Cs) G)(M)){G{}. (.(c : t Cs)(G(M))){G{}. (G(M))[c . G{] The \nreduction rules for System F. are obtained by removing rules REDCOER, REDCOERCOERLAM, REDCOERCOERAPP, \nand RED-COERDISTCOERARROW. Optional reduction rules Our presentation of F. could be ex\u00adtended with additional \nreduction rules for arrow and distributivity t coercions such as ((G1 . G2)(M)) N . G2(M (G1(N))). However, \nthis narrows the set of values and reestablishing progress would require binding coercions, as for F.. \ndescribed in \u00a74, which are technically more involved. For sake of simplicity, the current presentation \nhas fewer, but suf.ciently many, reduction paths.  2.4 Examples Let us .rst see examples in the F. subset. \nRetyping functions in F. allow for the commutation of quanti.ers and removal of useless quanti.ers. They \nalso let terms have more principal types. For example, in System F, the S-combinator .x..y..z.x z (yz) \ncan be given the two incomparable types: .a. .\u00df. ... (a . \u00df . .) . (a . \u00df) . a . . (.a. a . a) . (.a. \na . a) . (.a. a . a) . (.a. a . a) However, the former type is more general as it can be coerced to the \nlatter (already in F.), using three .-expansions. This example does not use distributivity, but the following \nexample, still in F., does. (In the examples, we use type constructors List and D, which we assume to \nbe covariant.) The map function has type: .a. .\u00df. (a . \u00df) . List a . List \u00df (1) It can also be given \nthe type (.a. a . Da) ..a. List (Da) . List (D(Da)) (2) for some type constructor D, using the following \ncoercion, which is already typable in F.: (. . .a . (Da))(Dist.)(.a (. a . .)(. a (Da))) Indeed, applying \nthe coercion .a (. a . .)(. a (Da)) turns a term of type (1) into one of type: .a. (.a. a . Da) . List \n(a) . List (Da)) (3) which in turn (. . .a . (Da))(Dist.) coerces to type (2). This example also illustrates \nthe low-level nature of the language of coercions, to which we will come back in \u00a74. The last two examples \nillustrate coercion abstraction. We de.ne a function .rst, inspired from F<:, that implements the .rst \nprojec\u00adtion for non-empty tuples of arbitrary length. Tuples are encoded as chained pairs ending with \nT. (We assume pairs have been added to F. and write proj1 and proj2 for the projections.) The function \n.rst .\u00df .a.(c : aC (\u00df *T)) .(x : a) proj1 (c(x)) of type .\u00df. .a. (aC (\u00df *T)) . a . \u00df abstracts over \na coercion c from arbitrary tuples to the singleton tuple. It can be applied to any non-zero tuple by \npassing the appropriate coercion. (In this example, subtyping could be encoded with just polymorphism \ninstead of coercion abstration, but this is not true in general.) The other example of coercion abstraction, \ninspired from MLF, delays the instantiation of a call to the polymorphic function choose of type ... \n. . . . ., say sch, when given itself as an argument. Let chchbe .. .(c : sch C.) choose . (c(choose)) \nof type ... (sch C.) . . . .. We may then pass chch the function plusof type int . int . int, say splus. \nThis application is written (chch splus){.sch int} plus and has type splus. 3. Properties of F. In this \nsection, we show that F. is well-behaved; moreover, there is a forward simulation between terms of F. \nand their coercion erasure. Hence, coercions do not really contribute to the reduction. However, coercions \nare not erasable as they may sometimes appear in wedges and block the reduction. 3.1 Soundness Type soundness \nof F. follows as usual from the subject reduction and progress lemmas. The proof of subject reduction \nuses substi\u00adtution lemmas for terms, types, and coercions, which in turn use weakening. The proof is \neasy because coercions are explicit. So the reduction rules actually are the proof. Proposition 1 (Subject \nReduction). If G f M : t and M \u00df. N hold, then G f N : t holds. Proposition 2 (Progress). If G f M : \nt holds, then either M is a value or M reduces. 3.2 Termination of reduction The termination of reduction \nfor F. can be piggybacked on the termination of reduction in System F: following Manzonetto and Tranquilli \n[2010], we show a forward simulation between F. and System F, by translating F. into System F so that \nevery reduction step in F. is simulated by at least one reduction step in System F. 3.3 Rei.cation of \nF. in System F There is indeed a natural translation of F. into System F obtained by reifying coercions \nas actual computation steps: even though we ultimately erase .-steps, we do not actually need to do so, \nand on the contrary, we may see them as computation steps in System F. Rei.cation is described on Figure \n8. We write IMl for the rei.cation of M. Coercions of coercion type t Cs are rei.ed as functions of type \nt . s. Hence, a coercion abstraction .(c : tCs) M is rei.ed as a higher-order function .(xc : It l. Isl) \nIMl. A coercion variable c is rei.ed as a term variable xc (we assume an injective mapping of coercion \nvariables to reserved term variables). Thus, the type (tCs) . . of a term abstracted over a coercion \nis translated into the type (It l.Isl) . I.l of a higher-order function. Other type expressions are rei.ed \nhomomorphically. The application of a coercion to a term and the application of a term to a coercion \nare both rei.ed as applications. The remaining cases are the translation of coercions G, which are all \ndone in two steps: we .rst translate G into some F.-term performing .-expansions to transform a coercion \nfrom t to s into a function from t to s. For atomic coercions (variables, identity, or distributivity), \nthe result of this step is in the System-F subset Ial = a Ixl = x I.a Ml = .a IMl I\u00d8l = \u00d8 It . sl = \nItl.IslI.(x : t ) Ml = .(x : Itl) IMlIMtl = IMlItlIG,Bl = IGl, IBl I.a. tl = .a. ItlIMNl = IMlINlIG(M)l \n= IGlIMlIal = a I. . tl = I.l.It lI.(c : .) Ml = .(xc : I.l) IMlI(x : t)l =(x : Itl) ITl = .a. (.\u00df. \u00df \n. a) . a IM{G}l = IMlIGlI(c : .)l =(xc : I.l) It Csl = Itl.Isl tt IG1 . G2l = I.(y : dom(G1 . G2)) .(x \n: t ) G2(y (G1(x)))lIDist.a. t.s)) .(x : t) .a ya xl t.sl = I.(y : dom(Dist.a. Icl = Ixcl I.t l = I.(x \n: t ) xl IDist.. t.s)) .(x : t) .(c : .) y{c} xl t.sl = I.(y : dom(Dist.. ITopt l = I.(y : t ) .a .(x \n: .\u00df. \u00df . a) xt ylIP [G]l = I.(x : dom(G)) P [G(x)]l Figure 8. Rei.cation of F. into System F of F.. \nHowever, for complex coercions, the result still contains inner 2. If M . N , then LMJ = LNJ. coercions. \nHence, in the second step, we recursively translate the Unfortunately, the backward simulation fails. \nThe wedge .(c :result of the .rst step. This translates types and residual coercions. Notice that the \n.rst step may introduce applications of coercions to t . tCt . t) .(y : t ) c(.(x : t ) x) y is a well-typed \nclosed value in F. while its erasure .y.(.x.x) y\u00df-reduces to .y.y. terms, which are then turned into \napplications of terms to terms. To recover bisimulation, the de.nition of the language must be The translation \nof P [G] covers .ve subcases, one for each form adjusted so that wedge con.gurations cannot appear in \na reduction of P . Here as in the reduction rules, the two occurrences of P are context. This observation \nleads to two opposite solutions, which we different abstract nodes since P is a coercion on the left-hand \nside present in \u00a75 and \u00a77. and a term on the right-hand side. The translation uses an auxiliary predicate \ndom that computes the domain of a coercion: the domain of a coercion G in environ\u00adment G is the unique \ntype t such that G f G : t Cs for some type 4. Coercions as retyping functions: F.. s. This cannot be \ncomputed locally. Hence, we assume that terms While the rei.cation of F. into System F carries good intuitions \nof F. have been previously typechecked and all coercions have been about what coercions really are, it \nlacks the ability to distinguish annotated with their domain type. Alternatively, we can de.ne the coercions \nfrom expressions with computational content. There is rei.cation as a translation of typing derivations. \nWe actually use an alternative presentation of F., called F.. and described in the such a translation \nto show that rei.cation preserves well-typedness extended version, that maintains the distinction between \ncoercions (easy but lengthy details can be found in the extended version). and expressions while remaining \ncloser to the rei.ed form of co- Proposition 3 (Well-typedness of rei.cation). If G f M : t then ercions: \nF.. is mainly a coercion decoration of System F. In this sense, it can be seen as an explicit version \n(with coercion abstrac- IMl is well-de.ned and IGlfIMl : Itl. tion) of Mitchell s presentation of F. \nas System F with retyping It is easy to verify that reduction in F. can be simulated in the functions. \ntranslation, which implies the termination of reduction in F.. The rei.cation of F. into System F can \nbe rede.ned as the com\u00adposition of a translation from F. to F. that keeps the distinction be- Lemma 4 \n(Forward simulation). If G f M : t holds, then: . tween coercions and terms and the .nal erasing of this \ndifference. 1. If M \u00df N, then IMlINl; The .rst part, along with its inverse, de.ne translations between \n 2. If M . N, then IMl + INl. F. and F.. that preserves well-typedness and coercion erasure. Al\u00adthough \nwe have not proved it, F. and F.. should be the same up to  Corollary 5 (Termination). Reduction in \nF. is terminating. their representation of coercions. 3.4 Con.uence Unfortunately, typechecking in F.. \nis more involved than in F., as we need to typecheck coercions as binding expressions. Reduction in F. \nis allowed in any term-context. Since coercions do The reason is that coercions are not exactly .-expressions. \nHav\u00adnot contain terms and coercions are never reduced alone, we may ing coercions as .-expressions would \nrequire an even more elab\u00adequivalently allow reduction in all coercion contexts, since no rule orated \ntype system, as it would have to ensure that coercions are will ever apply. Hence, reduction in F. is \na rewriting system. .-expansions, which means maintaining a stack of the currently .-An analysis of \nreduction rules in F. shows that there are no criti\u00adexpanded variables to remember closing them. For \nexample, con\u00adcal pairs. Hence, the reduction is weakly con.uent. Since reduction sider typechecking the \nretyping context .(x : t ) .a [] ax thatis also terminating, it is con.uent. In fact, the relation . \nalone is permutes term abstraction and type abstraction (known as distribu\u00ad con.uent. Moreover, the \nreduction \u00df and. commute. tivity): when typechecking the subterm .a [] ax, we must verify Corollary \n6 (Con.uence). Reduction in F. is con.uent. that it is the body of an .-expansion with the variable x. \nWe ini\u00adtially followed this approach and it was cumbersome; moreover, it Lemma 7. If M \u00df M1 and M . M2 \nhold, then there is a did not scale to products as the type system must also ensure that term N such \nthat M1. N and M2 \u00df N. two sub-derivation trees have the same coercion erasure. Instead, we make the \n.-expansion of a term M an atomic con\u00ad 3.5 Forward simulation struct, namely .(f1 : t ) G2 {f2 . MG1} \nwhere f s stand for Coercion erasure sends terms of F. into the (untyped) .-calculus. It hole variables. \nThis can be interpreted as .(x : t ) G{2[MG1{[x]] also induces a simulation from the reduction in F. \nby the reduction which is the .-expansion of M (i.e. .x.M x) using coercion G1 in the .-calculus, where \n.-steps becomes equalities. (interpreted as G{1) around the argument and coercion G2 (inter\u00adpreted as \nG{2) around the result. Here G2 may bind coercion or Lemma 8 (Forward simulation). If G f M : t holds, \nthen: hole variables that are used inside M and G1. Hence, the type sys\u00ad 1. If M \u00df N, then LMJLNJ. tem \nmust keep track of those variables with their types when type\u00ad <C t ::= ::= < | C . . . | . . t | .(a \n<C t) . t bounds types M ::= . . . | .(c : .) M | .(a <C c : t ) M | M{G} | M{t <C G} expressions G ::= \n. . . | Dist.. t.t | Dist.ar.t. t.t | .(c : .) G | .(a <C c : t ) G | G{G} | G{t <C G} coercions G ::= \n. . . | G, c : . | G, a <C c : t environments Figure 11. Parametric F.: changes in values wrt F.  Figure \n9. Parametric F.: syntax restriction wrt F. checking G2 and extend the typing environment accordingly \nwhen typechecking M and G1. We presented F. rather than its more intuitive version F.. to avoid the additional \ncomplexity in the type system; moreover, it is not obvious how to extend F.. with projectors, as discussed \nin \u00a79. 5. Parametric F. Parametric F., written F.p, restricts the language so as to rule out wedge con.gurations \nby means of typechecking. The restriction is on the type . of coercion abstractions .(c : .) M, i.e. \non the type of coercion variables. Observe that a coercion variable appearing in a wedge position c(.(x \n: t) M) N has a coercion type sC. where s and . are both arrow types. To prevent this situation from \nhappening in F.p, we require that either the domain or the codomain of the type of a coercion parameter \nbe a variable. Hence, we only allow .(c : aC.) M or .(c : sCa) M. In order to preserve this invariant \nby reduction, we must request the type variable to be introduced simultaneously. So, we may write .a \n.(c : aCt ) M but not .(c : aCt ) M alone. This is a form of parametricity since either the domain or \nthe codomain of c must be treated abstractly (and thus not as an arrow type) in M. To enforce this restriction \nwe stick a type abstraction to every coercion abstraction and see .a .(c : aCt ) M as a single syntactic \nnode, which we write .(aCc : t ) M to avoid confusion. Although, we modify the syntax of source terms, \nF.p can still be understood as a syntactic restriction of F.. 5.1 Syntax changes The syntax of Parametric \nF. is de.ned on Figure 9 as a patch to the syntax of F. (we write | for removal of a previous grammar \nform). We replace coercion abstraction .(c : t Cs) M of F. by two new constructs .(aCc : t) M and .(a< \nc : t ) M to mean .a .(c : aCt) M and .a .(c : t Ca) M but atomically. For conciseness, we introduce \na mode <C that ranges over C and <. Hence, we write .(a <Cc : t ) M for either .(aCc : t ) M or .(a< \nc : t ) M. Note that the type variable a is bounded in both t and M. As a mnemonic device, we can read \nthe type of the coercion variable by moving c : in front, i.e. aCc : t becomes c : aCt while a< c : t \nbecomes c : a< t which can also be read c : tCa. The reason to keep the type variable a before the coercion \nvariable is to preserve the order of the abstractions in F.. We say that .(aCc : t ) M and .(a< c : t \n) M are negative and positive coercion abstractions, respectively. The positive form is parametric on \nthe codomain of the coercion and implements a lower bounded quanti.cation tCa, as in xMLF. The negative \nform is parametric on the domain of the coercion and implements an upper bounded quanti.cation aCt , \nas in F<:. Continuing with the de.nition of F.p, we replace coercion appli\u00adcation M{G} by M{t <CG} to \nperform type and coercion appli\u00adcations (Mt){G} atomically. Both positive and negative versions p ::= \n... | p{G}| p{t <CG} prevalues | Dist.. (p) t.t (p)| Dist.ar.t. t.t t.t (.(c : .) p)| Dist.ar.t. | Dist.. \nt.t (.(a <C c : t ) p) v ::= ... | .(c : .) v | .(a <C c : t) v values P ::= ... | .(c : .) [] | .(a \n<Cc : t) [] retyping contexts | []{G}| []{t <CG} have the same meaning, but different typing rules. Type \nt appears before G to remind that the type application is performed before the coercion application in \nthe expanded form. As a mnemonic device, the <C is oriented towards the side of the variable it instantiates \nin the coercion type of M. Hence, if M is .(aCc : s) N, we must write M{t CG}. We must change types accordingly, \nreplacing coercion types . . t by .(a<Ct) . s, which factors the two forms .(aCt) . s and .(a< t ) . \ns whose expansions in F. are .a. (aCt ) . s and .a. (tCa) . s, respectively. Typing environments are \nmodi.ed accordingly. Notice that G,a <Cc : t stands for G, a, c : a <Ct (c : a< t should be read as c \n: t Ca) and therefore a may appear free in t as for coercion abstractions: this allows the encoding of \nrecursively de.ned bounds discussed below. In the syntax of coercions, we replace coercion abstractions \nand coercion applications as we did for expressions. We also change the distributivity coercion that \nexchanges term abstraction with coercion abstraction to re.ect the change in coercion types: it must \nsimultaneously permute the term abstraction with the type abstraction and coercion abstraction that are \nstuck together. 5.2 Adjustments to the semantics The syntactic changes imply corresponding adjustments \nto the se\u00admantics of the language. Notice that all restrictions are captured syntactically, so no further \nrestriction of typing rules is necessary. Typing rules Consistently with the change of syntax, we re\u00adplace \nthe typing rules TERMCOERLAM and TERMCOERAPP by rules TERMTCOERLAM and TERMTCOERAPP given on Figure 10. \nThe corresponding typing rules COERCOERLAM and COERCOERAPP for coercions are changed similarly. We also \nreplace COERVAR by TCOERVAR. Finally, the modi.ed distributivity coercion is typed as described by Rule \nCOERDISTTCOERARROW. Notice that <C is a meta-variable as M or t and different occurrences of the same \nmeta-variable can only be instantiated simultaneously all by C or all by <. (We use different meta-variables \n<C1 and <C2 when we mean to instantiate them independently.) The new typing rules for F.p are derived \nfrom the typing rules of the corresponding nodes in F.. For example, TERMTCOERLAM is the combination \nof rules TERMCOERLAM and TERMTYPELAM in F.. Well-formedness judgments are adjusted in the obvious way \n(details can be found in the extended version). Operational semantics The operational semantics is modi.ed \nin the obvious way. The syntax of values for F.p is de.ned on Fig\u00adure 11 as a modi.cation of the syntax \nof F.. The adjustments in the reduction rules are the replacement of REDCOER by REDT-COER, REDCOERDISTCOERARROW \nby REDCOERDISTTCOERARROW, and the change of retyping contexts that induces a change in RED-COERFILL as \ndescribed in Figure 11. 5.3 Properties Since F.p can be seen as a restriction of F. where coercion abstrac\u00adtion \nis always preceded by a type abstraction, some properties of TERMTCOERLAM TERMTCOERAPP TCOERVAR G,a \n<C c : t f M : s G f M : .(a <C t) . t { G f G : s <Ct[a . s]G f ok a<Cc : t . G G f .(a <C c : t) M \n: .(a <C t ) . s G f M{s <CG} : t{[a . s]G f c : a <C t COERTCOERAPP COERTCOERLAM COERDISTTCOERARROW \n{ {{ G,a <C c : t f G : sCsG f s G f G: .C .(a <C t ) . tG f t G,a f . G,a f s { G f G : s <C t [a . \ns] G f .(a <C c : t ) G : sC .(a <C t ) . sG f Dist.ar ... :(.(a <C .) . t . s) G f G{{s <C G} : .Ct{[a \n. s] t.s C (t ..(a <C .) . s) Figure 10. Parametric F.: typing rules wrt F. REDTCOER (.(a <C c : t ) \nM){s <C G} . M[a . s][c . G] REDCOERDISTTCOERARROW Dist.ar .s1.(.(a <C c : t ) .(x : s) M) . s2.s3 .(x \n: s) .(a <C c : t ) M Figure 12. Parametric F.: new reduction rules wrt F. F.p can be derived from those \nof F.. In particular, normalization and subject reduction properties are preserved, just by observing \nthat F.p is syntactically closed by reduction. Proposition 9 (Preservation). If G f M : t and M \u00df. N \nhold, then G f N : t holds. Con.uence and progress must still be veri.ed. For con.uence, we observe that \nthere are still no critical pairs (although this does not follow from the absence of critical pairs in \nF.), so weak con.u\u00adence is still preserved and con.uence comes as a corollary. Progress is a proof on \nits own, but it is similar to the one in F.. Proposition 10 (Progress). If G f M : t holds, then either \nM is a value or M reduces. As expected, coercions are erasable in F.p. Because the new reduction rules \nare a combination of two .-rules, and are themselves .-rules, the forward simulation follows from forward \nsimulation in F.. It remains to check the backward simulation. Proposition 11 (Backward simulation). \nIf G f M : t and LMJ M, then M .\u00df N such that LNJ = M. The proof schema is not original [Manzonetto and \nTranquilli 2010]. We assume that LMJ reduces to M and show that the .\u00adnormal-form of M\u00df-reduces to N \nwith LNJ equal to M. Since F. strongly normalizes, we may assume, without lost of generality, that M \nis already in .-normal form. Because LMJ reduces, we can use the reduction derivation to show that it \nmust be of the form C[(.x.M1) M2]. By inversion of the coercion-erasure function, we show that M is of \nthe form C[Q[.(x : t) M1] M2] where C is a reduction context and Q a retyping context of arbitrary depth, \nsuch that C, M1, and M2 erase to C, M1, and M2, respectively. We show that if a .-normal term of the \nform Q[.(x : t) M] has an arrow type, then Q is empty. Hence, M is of the form C[(.(x : t ) M1) M2] and \n\u00df-reduces to C[M1[x . M2]] whose erasure is C[M1[x .M2]]. 6. Expressiveness of Parametric F. Although \nit is bridled by-design, F.p is already an interesting spot in the design space, as it subsumes in a \nuni.ed framework three known languages: F., xMLF, and F<: (in fact, its more expressive version with \nF-bounded polymorphism [Canning et al. 1989]). By construction, F. is included (and simulated) in Parametric \nF.. In the rest of this section, we show that xMLF and F<: are also subsumed by F.p. In each case, we \nexhibit a translation of typing judgments from the source language to typing judgments of F.p so that \nthe coercion erasure of the translation of a source term is equal to the type erasure of this term, and \ntherefore the translation is semantics preserving. To avoid confusion between source and target terms, \nwe write T or S for terms, A or B for types, and S for typing environ\u00adments in the source language. Formally, \nwe exhibit a translation of judgments S f T : A G f M : t that is well-de.ned, type preserving, and semantics \npreserving. That is, if S f T : A then S f T : A G f M : t holds for some G, M, and t such that G f M \n: t and LT J = LMJ. As a consequence, reduction in the source language terminates, since it is simulated \nin F.p. Bounded polymorphism. F<: is a well-known extension of Sys\u00adtem F with subtyping. There are several \nvariations on F<:, all shar\u00ading the same features, but with different expressiveness due to the way they \ndeal with subtyping of bounded quanti.cation. Bounded quanti.cation .(a<: A) B restricts types A{ that \na ranges over to be subtypes of the bound A. The differences lie in when the sub\u00adtyping judgment S f.(a<: \nA) B<: .(a<: A{) B{ holds. Different versions of the corresponding subtyping rule are given on Figure \n13. In Kernel F<:, the bounds A and A{ must be equal, whereas Full F<: only requires the bound A{ to \nbe a subtype of the bound A. Moreover, a cannot appear free in the bounds A or A{ in Kernel or Full F<:, \nwhile F\u00b5<: allows this form of recur\u00adsion, called F-bounded polymorphism. The most general assump\u00adtion, \nS,a <: A{ f a<: A, is that of F\u00b5<:. Perhaps surprisingly, this is a slightly more general rule [Baldan \net al. 1999] than the more intuitive one S,a <: A{ f A{ <: A. In summary, we have Kernel F<: . Full F<: \n. F\u00b5<: where all inclusions are strict. We show that the most expressive version F\u00b5<: is included into \nF.p. The translation of typing judgments uses auxiliary translations of subtyping judgments S f A<: B \nG f G : t Cs and well\u00adformedness judgments. Bounded polymorphism .(a<: A) B is translated into a negative \ncoercion abstraction .(aCt ) . s which encodes upper bounds. (Positive coercion abstraction .(a<t) . \ns encodes lower bounds and are never needed in the translation of F\u00b5<:.) Translation of expressions is \neasy. For example, the translation of a type application is a coercion application, as follows: {{ S \nf T : .(a<: B) BG f M : .(aCs) . s S f A<: B[a . A]G f G : t Cs[a . t] S f TA : B{[a . A]G f M{t CG} \n: s{[a . t ]  The most involved part in the translation is for subtyping judgments in particular, for \nthe bounded-quanti.cation case: {{ S,a<: Af a<: A G,aCc : tf G : aCt (1) S,a <: A{ f B<: B{ G,aCc : t{ \nf G{ : sCs{ (2) {{ S f.(a<: A) B<: .(a<: A) BG f .(aCc : t{) G{(.{aCG}) : .(aCt ) . sC .(aCt {) . s{ \n Let us check that the judgment returned by the conclusion holds under the assumptions returned by the \npremises (1) and (2). The KERNEL-FSUB FULL-FSUB F-BOUNDED S, a <: A f B <: B{ S f A{ <: A S, a <: A{ \nf B <: B{ S, a <: A{ f a <: A S, a <: A{ f B <: B{ S f .(a <: A) B <: .(a <: A) B{ S f .(a <: A) B <: \n.(a <: A{) B{ S f .(a <: A) B <: .(a <: A{) B{ Figure 13. Bounded polymorphism: variants on the subtyping \nrule implicit superscript of the hole in the conclusion is the domain of the coercion .(aCt) . s, say \n.. In environment G,a C c : t{, the coercion .{aCG} has type .Cs by rule COERTCOERAPP and, since G{ coerces \ns to s{, the coercion G{(.{aCG}) has type .Cs{. Hence, by rule COERTCOERLAM, the coercion of the conclusion \nhas type .C .(aCt {) . s{, as expected. Notice that F\u00b5<: is missing type abstraction and type application \nin coercions, as well as distributivity of the universal on the arrow as in F.. Indeed, F\u00b5<: only allows \ninstantiation of quanti.ers at the root of types, as in System F and contrary to F.. Hence, the inclusion \nF\u00b5<: . F.p is strict. It is remarkable that F.p naturally matches the most expressive version F\u00b5<:. This \nencourages following a systematic approach and viewing type conversions as erasable coercions as in F.p \nrather then a limited subtyping relation. Additionally, F.p may simplify the proof of type soundness \nfor F\u00b5<:, as coercions are explicit. Instance-bounded polymorphism. The language xMLF [R\u00e9my and Yakobowski \n2010] is the internal language of MLF which is itself an extension of System F with instance-bounded \npolymor\u00adphism. Instance-bounded polymorphism is a mechanism to delay type instantiation of System F; \nit is a key to performing type infer\u00adence in MLF and keeping principal types given optional type an\u00adnotations \nof function parameters. As our current concern is not type inference but expressiveness, we use xMLF \nrather than MLF for comparison with F.p. By lack of space, we cannot formally present xMLF. Instead, \nwe identify a subset Fx. of F.p and explains how it closely relates to xMLF without giving all the details \nof xMLF, which can be found in the extended version. We .rst de.ne the subset F.\u00b5x of F.p by removing \nnegative coer\u00adcion abstractions (in types, terms, and coercions), arrow coercions t G . G, and distributivity \ncoercions from the syntax of terms. Of course, we remove typing rules and reduction rules for these con\u00adstructs, \naccordingly. We then de.ne Fx. as the restriction of F.\u00b5x where a type variable cannot appear in its \ninstance bound, i.e. a is not free in t in .(a<t ) . s. Both restrictions are closed by reduction, so \nthey preserve the properties of F.p. We claim that xMLF is equivalent to Fx. . Unsurprisingly, the translation \nof instance-bounded polymorphism .(a = A).B is a positive coercion abstraction .(a<t ) . s where t and \ns are the translation of A and B. The translation of expressions and type instantiations is then routine \n(see the extended version). The proof for the direct inclusion is similar to one by Manzonetto and Tranquilli \n[2010]. The proof for the reverse inclusion is new but not much more dif.cult. . F\u00b5x In summary, we have \nxMLF Fx. . . F.p. It is inter\u00adesting that the natural restriction of F. that resembles xMLF al\u00adlows \nvariables to appear in their instance bounds, much as with F\u00adbounded polymorphism. This suggests an extension \nto xMLF with recursively de.ned bounds. However, we do not know whether this extension could still permit \npartial type inference in MLF. Moreover, reduction in xMLF is simulated in Fx. . This implies termination \nof reduction in xMLF(a result already proved by Man\u00ad zonetto and Tranquilli [2010]). Summary Features \nof F.p and its variants are summed up on Fig\u00adure 14. The expressiveness of F., xMLF, and F<: can be compared \nby checking which feature is present in one language and not in the others. Deep instantiation corresponds \nto the .a G and Gt con-structs, allowed in F. and xMLF, but not in F<:. Upper bounds are used in F<: \nand lower bounds are used xMLF. They correspond to coercion abstraction .(a<Cc : t ) G and G{t <CG} when \n<C is C or Extension of System F F. F<: xMLF Fp . Deep instantiation v - v v Arrow congruence v v - v \nPermutation of . and . v - - v Upper bounds - v - v Lower bounds - - v v Figure 14. Language and feature \ncomparison  t <, respectively. F. allows neither. Arrow congruence is the G . G construct, allowed \nin F. and F<:. Distributivity Dist.a. t.s is used in F.. The other form Dist.ar ... is only used in Fp \nsince it involves t.s. coercion abstraction. Notice that xMLF and F<: only have coercion abstraction \nin common, but with opposite polarities. Each of them share a dif\u00adferent feature with F.. None of them \nuses distributivity as it only makes sense when deep instantiation and arrow congruence are available \nsimultaneously. All examples of \u00a72.4 are actually typable in F.p with some syn\u00adtactic adjustment of course. \nFor instance, the last example becomes .(.<c : sch) choose {.< (c{choose})} of type .(.<sch) . . . .. \nFor instance, it can be coerced to the type .(.<splus) . . . .. This uses the coercion .(.<c : splus) \n.{.<c(.sch int)}. 7. Weak F. Another solution to recover erasability is to prevent wedges from appearing \nin a reduction context. At .rst, it seems to suf.ce to use weak reduction on coercion abstraction. Indeed, \nif a coercion variable cannot appear under a reduction context, it cannot appear in a wedging con.guration. \nHowever, since .(c : .) M is irreducible, its erasure LMJ should also be irreducible, i.e. a value. If \nwe choose strong reduction for term abstraction, we must also choose strong reduction in the .\u00adcalculus \nused as the target, hence LMJ must be a value for strong reduction. That is, .(c : .) M would only be \nallowed when M is fully evaluated, which would considerably limit the interest of abstracting over c. \nTherefore, we choose a weak strategy for both coercions and terms. Keeping strong reduction on types \nis optional and independent. The syntax of Weak F., written F.w, is de.ned on Figure 15 as a restriction \nof the syntax of F.. We replace .(c : .) M in terms by .(c : .) u where u is a value form. A value form \nis a term that erases to a value, i.e. a value or an application of a coercion G to a value form. A value \nis any form of abstraction whose subterm is an arbitrary term for a term abstraction, a value for a type \nabstraction (because we may evaluate under type abstractions), or a value form for a coercion abstraction. \nThe static semantics of F.w and F. are the same. The reduction relation of F.w is a subrelation of the \nreduction relation of F. that prevents evaluation under term and coercion abstractions and pre\u00adserves \nthe value restriction. Reduction contexts are modi.ed ac\u00adcordingly: .(x : t ) [] and .(c : .) [] are \nremoved. Rule RED-COERCOERLAM (the coercion abstraction part of REDCOERFILL) is M ::= ... | .(c : .) \nM | .(c : .) u expressions G ::= ... | Dist.. coercions v ::= .(x : t ) M | .a v | .(c : .) u | Topt \n(v) values u ::= v | G(u) value forms t.s C ::= [] M | M [] | .a [] | [] t | G([])| []{G} reduction ctx \nw REDCOERCOERLAM (.(c : .) G)(u) . .(c : .) G(u) Figure 15. Weak F.: syntax and semantics wrt F. restricted \nto make it call-by-value. Indeed, keeping the F. rule: (.(c : .) G)(M) . .(c : .) G(M) would place the \narbitrary term M under a coercion abstraction. It is routine to check that F.w is well-behaved and that \ncoercions are erasable. We refer the reader to the extended version. 8. Related work Although many type \nsystems could be explained using coercions, since for instance they use a form of subtyping, very few \nhave followed this path and made the connection with coercions explicit. We have already widely discussed \nF., F<:, and xMLF. Parts of Fx. is closely related to the work of Manzonetto and Tranquilli [2010] who \nproposed the .rst encoding of xMLF in a calculus of coercions, but for the main purpose of proving the \ntermination of xMLF. They exhibit a type and semantics preserving encoding of xMLF into (their version \nof) Fx. and show a simulation of compu\u00adtation between their Fx. and System F. Unfortunately, subject \nre\u00adduction and other properties that depend on it do not hold in their system. Our version of Fx. can \nbe seen as a .x to their de.nition. Hence, there are many resemblances between their development of Fx. \nand our development of F. but the typing rules differ. We omitted the proof of inclusion from xMLFinto \nFx. by lack of space, but also because it resembles theirs. In fact, their translation of xMLF into Fx. \nhas itself been inspired by the translation of MLF into System F by Leijen and L\u00f6h [2005] and Leijen \n[2007]. How\u00ad ever, Manzonetto and Tranquilli restrict their study to the termi\u00adnation of xMLF without \nany interest in F. or F<:, while our main interest is not in Fx. , but in F.p and F., i.e. a general \ntreatment of abstraction over coercion functions that extends F., and as a side result a possible enhancement \nof xMLF. Although F. subsumes core F<:, we have not included records in F., which are often the .rst \napplication of F<:. Our formalization in the extended version includes tuples, and therefore models tuple \ninclusion. We claim that F. can model record subtyping as well. However, our treatment of records in \nF. would be similar to their treatment in F<: and require an expressive runtime system so that subtyping \nis erasable. Record subtyping in F<: may also be compiled away into records without subtyping in plain \nSystem F by inserting coer\u00adcions with computational content [Breazu-Tannen et al. 1991] that change the \nrepresentation of records whenever subtyping is used. Since these coercions are not erasable and can \nbe inserted in differ\u00adent ways, the soundness of the approach depends on a coherence result to show that \nthe semantics of the translation does not actually depend on the places where coercions are inserted. \nAnother method for eliminating subtyping has been used by Crary [2000]: bounded polymorphism .(a = t \n).s is compiled away into an intersection type .a. s[a . ant ] while intersection types are themselves \nencoded with explicit erasable coercions. This directly relates to our work by their canonization, which \nis similar to our .-reduction, and their use of bisimulation up to canoniza\u00adtion to show erasability \nof coercions. Of course, the languages are different, as we do not consider intersection types while \nthey do have neither coercion abstraction nor distributivity and only con\u00adsider call-by-value reduction. \nTheir work could serve as a reference to extend F. with recursive types. Languages with dependent types \noften split terms with and without computational content using kinds so that parts of terms that contribute \nonly to the static semantics can be dropped at run\u00adtime. This is more powerful than our notion of coercions; \nfor in\u00adstance, it could allow to build coercions by computation a feature that we would like to have. \nHowever, we do not know whether this approach could be applied and bene.t to our extension of F.. Coercions \nintroduced in FC2 [Weirich et al. 2011], the inter\u00ad nal language of Haskell, are interesting because \nthey use coercion projections and cannot be expressed in F... Although FC2 uses a weak evaluation strategy, \nit can declare abstract coercions at the toplevel, which amount to a form of coercion abstraction hence \nthey need coercion projections to regain erasability. However, co\u00adercions in FC2 are non-oriented, do \nnot have distributivity nor deep instantiation of quanti.ers and are thus structural, which allows for \nan easier setting and a simple criteria to be used for consis\u00adtency checking. A new version of FC2 [Vytiniotis \nand Jones 2011] makes coercions .rst-class values in an otherwise comparable set\u00adting. Coercions can \nbe abstracted over as in F. and also stored in data-structures. However, as a result of being .rst-class, \ncoercions may change the termination (hence the semantics) of programs and are not erasable in our terminology. \nThe two languages F. and FC2 follow orthogonal approaches and are thus not easily comparable; combining \nthe features of both would be an interesting challenge. Adding coercion projections to F. and taking \ndistributivity away, we could obtain a version much closer to FC2 but where coercions are oriented. Surprisingly \nfew works have consider dis\u00adtributivity and include the power of F., apart from theoretical pa\u00adpers on \nF. itself. Retyping functions can also be seen as a way of rearranging typing derivations. Abstraction \nover coercions is then abstraction over type derivation transformations. There might be interesting connections \nto establish with expansion variables for .-quanti.ers introduced by Lenglet and Wells [2010]. 9. Discussion \nand future work The language F. extends F. with abstraction over coercion func\u00adtions in a general way \nwhere coercions are retyping functions, i.e. certain terms of the .-calculus that do not contribute but \nmay block the evaluation. In order to solve this problem and make coercions erasable, we have proposed \ntwo restrictions of F.. Weak F. restricts the reduction relation by choosing a weak eval\u00aduation strategy \nfor both coercions and terms and restrict coercion abstraction to value forms. The main advantage of \nthis solution is its simplicity and its generality. Still, the restriction of coercion ab\u00adstractions \nto value forms, which is analogous to value-only poly\u00admorphism in languages with side effects, is signi.cant. \nMoreover, it allows the abstraction over coercions of uninhabited coercion types, which are never applicable, \nthus leaving the possibility of non-sensible code hidden under coercion abstraction undetected or at \nleast delaying its detection. Instead, F.p restricts the types of coercion parameters and forces them \nto be polymorphic in either their domain or codomain. The advantage of F.p is to retain a strong reduction \nrelation, which shows that the calculus is really well-behaved. Although restrictive, it already subsumes \nF., xMLF, and F<:. We believe it is an inter\u00adesting point in the design space. It also shows that an \nextension of xMLF with subtyping would be possible and bene.cial, even if the question of designing the \nsurface language to make type inference possible remains open. Still, as both solutions are signi.cant \nand orthogonal restrictions to F., we may explore other possibilities. Relaxing F.p Relaxing F.p so that \nit could type more expressions but still prevent wedges from being typable is probably the easiest extension \nto this work. An obvious but minor generalization is to let .(a <C c\u00af: \u00aft ) M abstract over several coercions \nsimultaneously, but all with the same polarity. Allowing multiple polarities cannot come without further \nrestrictions, as transitivity could then be used to build an abstract coercion between arrow types. A \nmore ambitious generalization is to replace the local con\u00adstraint on the type of coercions by a global \nconstraint de.ned by some auxiliary consistency judgment. We could allow abstractions of the form .(\u00afa, \nc\u00af: \u00aft C s\u00af) M using a side condition on the typing rule to ensure that the combination of coercions \nin context still pre\u00advents the creation of wedges. However, .nding a suitable notion of consistency in \nthe presence of distributivity is challenging. Beyond F. So far, we have explored restrictions of F. \nto prevent wedges from appearing in a reduction context. Instead, we could perhaps extend the calculus \nto allow breaking them apart. Observe that when a coercion variable appears in a wedge, it is always \na coercion between arrow types and that any actual coercion that will t be passed at runtime will start \nwith an arrow coercion G1 . G2 that can be decomposed into G1 and G2 and pushed out of the way. So, we \ncould decompose the abstract coercion as well, by introducing coercion projections Left G and Right G \nthat behaves t as G1 and G2 whenever G is G1 . G2. While this idea is intuitively simple, it is actually \nquite involved as new dif.culties appear one after the other when solving them, due to the presence of \ndistributivity. Projectors require both bind\u00ading coercions as in F.. and, independently, a notion of \nstructural equivalence to treat coercions up to some rearrangements; unfor\u00adtunately, the combination \nof both breaks con.uence; a .x to con\u00ad.uence is to reduce coercions themselves, which introduces further \nproblems! (See the extended version for more details.) Moreover, even assuming that such a calculus can \nbe set up, there will re\u00admain to solve a typechecking problem quite similar to (although more .exible \nthan) the one for relaxing F.p with non-local consis\u00adtency. Indeed, decomposing nonsensical coercions \ncannot ensure erasability, .-reduction may either get stuck, being unsound, or loop forever. We leave \nthis exploration for future work. Leaving F. and freezing quanti.ers We have added coercion ab\u00adstraction \nto the language F. as it is the reference in the absence of abstraction. However, many of the dif.culties \nin F. come from the distributivity rules, which allow coercions to move quanti.ers inside types, or more \nprecisely, from the combination of distributiv\u00adity with contravariance of the arrow constructor which \nis already the source of dif.culties in F., including undecidability of type\u00adcontainment. This suggests \nexploring a restriction of F. that does not have distributivity, nor type abstraction and type application \nof coercions, that would not extend F., but have a much simpler metatheory. Language extensions Several \nfeatures of programming lan\u00adguages have also been left out of F.. Although products are not included \nin this short presentation, we have already veri.ed that they can easily be added. Labeled products should \nwork as well. We do not expect dif.culties with tagged unions or iso-recursive types, e.g. following \nCrary [2000] although details are subtle and still need to be checked. We don t foresee any dif.culties \nfor adding .x points to the source language. Some care is needed for existential types, which already \nraise a problem in System F as they do not have an erasing semantics with a strong evaluation strategy. \nTherefore, we left them out of F. and replaced them by a top type. This is, however, an orthogonal issue. \n An interesting extension is to make coercion .rst-class objects which raises another challenge for erasability: \nsince coercions can then be built by computation, should a computation that just builds coercions be \nerasable as well? Coercion types are monomorphic in F. but between possibly polymorphic types. We do \nnot expect dif\u00ad.culties to have polymorphic coercion types. First-class coercions would naturally bring \npolymorphic coercion types. We have studied coercions for second-order polymorphism. We should not expect \ndif.culties with higher-order polymorphism. However, adding coercions to a language with dependent types \nmay be more challenging. References P. Baldan, G. Ghelli, and A. Raffaet\u00e0. Basic theory of F-bounded \nquan\u00adti.cation. Inf. Comput., 153:173 237, September 1999. URL http: //portal.acm.org/citation.cfm?id=320278.320285. \nV. Breazu-Tannen, T. Coquand, C. Gunter, and A. Scedrov. Inheritance as implicit coercion. Information \nand Computation, 93:172 221, 1991. P. Canning, W. Cook, W. Hill, W. Olthoff, and J. C. Mitchell. F-bounded \npolymorphism for object-oriented programming. In FPCA, 1989. URL http://doi.acm.org/10.1145/99370.99392. \nL. Cardelli. An implementation of FSub. Research Report 97, Digital Equipment Corporation Systems Research \nCenter, 1993. URL http:// research.microsoft.com/Users/luca/Papers/SRC-097.pdf. K. Crary. Typed compilation \nof inclusive subtyping. In ICFP, 2000. URL http://doi.acm.org/10.1145/351240.351247. K. Crary, S. Weirich, \nand J. G. Morrisett. Intensional polymorphism in type\u00aderasure semantics. Journal of Functional Programming, \n12(6):567 600, 2002. URL http://dx.doi.org/10.1017/S0956796801004282. D. Le Botlan and D. R\u00e9my. Recasting \nMLF. Information and Computation, 207(6), 2009. URL http://dx.doi.org/10.1016/j.ic.2008.12. 006. D. \nLeijen. A type directed translation of MLF to System F. In ICFP, Oct. 2007. URL http://research.microsoft.com/users/daan/ \ndownload/papers/mlftof.pdf. D. Leijen and A. L\u00f6h. Quali.ed types for MLF. In ICFP, Sept. 2005. URL http://murl.microsoft.com/users/daan/ \ndownload/papers/qmlf.pdf. S. Lenglet and J. B. Wells. Expansion for forall-quanti.ers. Available elec\u00adtronically, \n2010. URL http://sardes.inrialpes.fr/~slenglet/ papers/systemFs.pdf. G. Manzonetto and P. Tranquilli. \nHarnessing MLF with the Power of System F. In MFCS, volume 6281, 2010. doi: http://dx.doi.org/10.1007/ \n978-3-642-15155-2_46. J. C. Mitchell. Polymorphic type inference and containment. Information and Computation, \n2/3(76), 1988. D. R\u00e9my and B. Yakobowski. A Church-Style Intermediate Language for MLF. In FLOPS, volume \n6009, pages 24 39. 2010. URL http: //dx.doi.org/10.1007/978-3-642-12251-4_4. D. Vytiniotis and S. P. \nJones. Practical aspects of evidence-based compilation in system FC. Available electronically, 2011. \nURL http://research.microsoft.com/en-us/um/people/simonpj/ papers/ext-f/. S. Weirich, D. Vytiniotis, \nS. Peyton Jones, and S. Zdancewic. Generative type abstraction and type-level computation. In POPL, 2011. \nURL http://doi.acm.org/10.1145/1926385.1926411.   \n\t\t\t", "proc_id": "2103656", "abstract": "<p>Erasable coercions in System F-eta, also known as retyping functions, are well-typed eta-expansions of the identity. They may change the type of terms without changing their behavior and can thus be erased before reduction. Coercions in F-eta can model subtyping of known types and some displacement of quantifiers, but not subtyping assumptions nor certain forms of delayed type instantiation. We generalize F-eta by allowing abstraction over retyping functions. We follow a general approach where computing with coercions can be seen as computing in the lambda-calculus but keeping track of which parts of terms are coercions. We obtain a language where coercions do not contribute to the reduction but may block it and are thus not erasable. We recover erasable coercions by choosing a weak reduction strategy and restricting coercion abstraction to value-forms or by restricting abstraction to coercions that are polymorphic in their domain or codomain. The latter variant subsumes F-eta, F-sub, and MLF in a unified framework.</p>", "authors": [{"name": "Julien Cretin", "author_profile_id": "81470655088", "affiliation": "INRIA, Rocquencourt, France", "person_id": "P2991420", "email_address": "julien.cretin@inria.fr", "orcid_id": ""}, {"name": "Didier R&#233;my", "author_profile_id": "81100311096", "affiliation": "INRIA, Rocquencourt, France", "person_id": "P2991421", "email_address": "didier.remy@inria.fr", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103699", "year": "2012", "article_id": "2103699", "conference": "POPL", "title": "On the power of coercion abstraction", "url": "http://dl.acm.org/citation.cfm?id=2103699"}