{"article_publication_date": "01-25-2012", "fulltext": "\n Canonicity for 2-Dimensional Type Theory Daniel R. Licata* Robert Harper * Carnegie Mellon University \n {drl,rwh}@cs.cmu.edu Abstract Higher-dimensional dependent type theory enriches conventional one-dimensional \ndependent type theory with additional structure expressing equivalence of elements of a type. This structure \nmay be employed in a variety of ways to capture rather coarse identi\u00ad.cations of elements, such as a \nuniverse of sets considered mod\u00adulo isomorphism. Equivalence must be respected by all families of types \nand terms, as witnessed computationally by a type-generic program. Higher-dimensional type theory has \napplications to code reuse for dependently typed programming, and to the formalization of mathematics. \nIn this paper, we develop a novel judgemental for\u00admulation of a two-dimensional type theory, which enjoys \na canon\u00adicity property: a closed term of boolean type is de.nitionally equal to true or false. Canonicity \nis a necessary condition for a compu\u00adtational interpretation of type theory as a programming language, \nand does not hold for existing axiomatic presentations of higher\u00addimensional type theory. The method \nof proof is a generalization of the NuPRL semantics, interpreting types as syntactic groupoids rather \nthan equivalence relations. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal \nDe.nitions and Theory; F.3.2 [Logics and Mean\u00adings of Programs]: Semantics of Programming Languages General \nTerms Languages, Theory 1. Introduction A growing body of work [4, 8, 9, 12, 14, 15, 22 24] on intensional \ndependent type theory [11, 16, 18] elucidates the latent higher\u00addimensional structure given by the Martin-L\u00f6f \nintensional identity type. The identity type, IdA MN, is the type of evidence for equiv\u00adalence of the \nobjects M and N of type A. The elimination rule for the identity type ensures that type families indexed \nby A re\u00adspect equivalence at A: if F is an A-indexed family of types, and a : IdA MN, then F [M] and \nF [N] are isomorphic types. Sim\u00adilarly, families of objects indexed by A must respect equivalence * This \nresearch was sponsored in part by the National Science Foundation under grant number CCF-0702381 and \nCCF-1116703 and by the Microsoft-Carnegie Mellon Center for Computational Thinking. The views and con\u00adclusions \ncontained in this document are those of the author and should not be interpreted as representing the \nof.cial policies, either expressed or im\u00adplied, of any sponsoring institution, the U.S. government or \nany other entity. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 12, January 25 27, 2012, Philadelphia, PA, USA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. \n. . $10.00 at A: mappings are functional in their domain, in that application to equivalent elements \nyields equivalent results. Objects of iden\u00adtity type are themselves subject to higher equivalences inhabiting \nthe iterated identity type IdIdA MN a\u00df, and so on, inde.nitely. This higher-dimensional structure is \nthe key to establishing sur\u00adprisingly close connections between type theory, category theory (interpreting \ntypes as higher-dimensional groupoids, and equiva\u00adlences as morphisms), and homotopy theory (interpreting \ntypes as topological spaces, and equivalences as paths). The interplay be\u00adtween these viewpoints is a \nsource of much current investigation. However, experience with intensional type theory, both as a programming \nformalism and as a language for formalizing math\u00adematics, suggests that the general principles of equivalence \norig\u00adinally proposed by Martin-L\u00f6f are too restrictive. For example, equivalence at function types amounts \nto de.nitional equality, whereas in mathematical practice one tends to identify functions extensionally \ntwo functions are equal iff they take equal argu\u00adments to equal results. Equivalence of types themselves \nis similarly restrictive. Formally, this is typically considered as equivalence for members of a universe, \nwhich is a type whose elements themselves determine types. The standard account of equivalence for universes \namounts to equivalence of presentations: two types are equivalent if they are written the same way. However, \nit is common mathe\u00admatical practice to identify isomorphic sets to treat two sets as interchangable when \nthere are functions back and forth that com\u00adpose to the identity. This motivates extensions of intensional \ntype theory with coarser notions of equivalence: Altenkirch [2], Altenkirch et al. [3], Hofmann [10] \ninvestigate functional extensionality. Voevod\u00adsky s univalence axiom [23] goes further by treating elements \nof universes as equivalent whenever the spaces they determine are weakly equivalent in the sense of homotopy \ntheory. A particular case of univalence, considered here, arises when considering the universe set of \nextensional sets: two sets are deemed equivalent iff they are isomorphic. This amounts to introducing \na new canoni\u00adcal form, iso(f, g, a, \u00df), of the identity type Idset AB, given by functions f : A . B and \ng : B . A and evidence a and \u00df witnessing their inverse relationship to one another. However, this represents \na more signi.cant departure from the traditional view of equivalence than might at .rst be apparent. \nSince two sets can be isomorphic in many ways, isomorphism must be treated as a com\u00adputationally relevant \nstructure imposed on two sets, rather than as a computationally irrelevant property of them. For example, \nthe set 2 of booleans is isomorphic to itself both by the identity function and by the negation function, \nwhich swaps the two booleans. Thus, the type Idset 22 is not a proof-irrelevant proposition, but has \nreal computational content. A higher-dimensional type is one, such as set, whose identity type has computational \ncontent. Higher-dimensional type theory has several applications in pro\u00adgramming and formal mathematics. \nIn programming, postulating that equivalence of sets is isomorphism has the consequence that all families \nof types respect isomorphism. For example, consider the family of types Mon[A], where A : set, representing \nmonoids on A: Mon[A]= S m : A . A . A. S u : A. S assoc : (.x, y, z : A.Id (m (mxy) z)(mx (myz))). S \nunitl : (.x : A.Id (mux) x). S unitr : (.x : A.Id (mxu) x).1 A monoid consists of a multiplication operation \nm, a unit oper\u00adation u, together with proofs that these satisfy the monoid laws. Monoid structures are \nuseful for a parallel reduce operator, which schedules computation in an arbitrary way while producing \na de\u00adterministic result. In current dependent type theories, a program\u00admer must show that each individual \ntype family, such as Mon, re\u00ad ~~ spects isomorphism that A = B entails Mon[A]= Mon[B]. This is particularly \nlaborious for dependently typed program\u00adming, where isomorphisms arise frequently from type re.nements; \ne.g. if the type vec[n : N] classi.es vectors of length n, then S n:N. vec[n] is isomorphic to the unre.ned \ntype list. More\u00adover, it is unnecessary, as there is in fact no way to de.ne a family that does not respect \nisomorphism. In contrast, in higher\u00addimensional type theory, the elimination rule for the identity type \ninduces a monoid structure on B from a monoid structure on A, and shows that these structures are isomorphic: \nusing substitutiv\u00adity of Id-types substC : IdA MN . C [M ] . C [N ], given any iso(f , g, a, \u00df): Idset \nAB, the term substMon(iso(f, g, a, \u00df)) : Mon[A] . Mon[B] induces an isomorphism between monoid structures. \nThe same idea also has applications to the formalization of mathematics: a proof assistant based on higher-dimensional \ntype theory supports the common informal mathematical practice of identifying isomorphic sets. Another \napplication is to the formal\u00adization of homotopy theory in type theory [1] in which types are interpreted \nas topological spaces, and equivalences as paths in the space [4]. Under this correspondence a space \nmay be inductively de.ned by giving generators for its points and for its paths. For ex\u00adample, the interval, \nI, may be speci.ed by the endpoints 0, 1: I and the path seg : IdI 01 between them. Similarly, the circle \nS1 may be speci.ed as having, say, two points, 0, 1: S1, and two paths a : IdS1 01 and b : IdS1 10. The \nhigher-dimensional struc\u00adture of type theory ensures, for example, that a family of types in\u00addexed by \na space induces an action that transports objects along paths in the space. These de.nitions have already \nbeen used to for\u00admalize some basic results in algebraic topology [1] all higher ho\u00admotopy groups are \nabelian; the fundamental group of the circle is isomorphic to Z and suggest a new, type-theoretic approach \nto\u00adwards more sophisticated problems, like determining the homotopy groups of the spheres. A fundamental \nquestion that arises in higher-dimensional type theory concerns the computational behavior of identity \nelimination. For example, when we use substMon(iso(f, g, a, \u00df)) to construct a function Mon[A] . Mon[B], \nwhat function does it construct? The answer lies in the functorial action of the dependent type constructors, \nas expressed by Hofmann and Streicher [12]. In this example, the action of Mon sends the unit to to its \nimage under f, wraps multiplication with f and g to transfer back and forth between the two algebras, \nand uses the cancellation of inverses to validate the laws. Thus, from a programming standpoint, the \nmain bene.t of higher-dimensional type theory is to equip every type and term in the language with their \nfunctorial actions, as a generic program. This allows programmers to work up to isomorphism and other \nsuch structures, facilitating code reuse for dependently typed programs. Topologically, these programs \nwitness the process of transporting points along paths in spaces. However, this computational behavior \nis latent in current pre\u00adsentations of higher-dimensional type theory, which extend the canonical members \nof the identity type, without extending the com\u00adputation rules for its elimination form. The standard \ncomputation rule for subst says that substC(re.) reduces to the identity func\u00adtion. Higher dimensional \ntypes add new canonical forms of equiva\u00adlence, such as iso(f, g, a, \u00df), but, in current presentations, \nno new computation rules. This runs afoul of the computational interpre\u00adtation of type theory, which \ndemands that the elimination forms for a type be post-inverse to the introductory forms. For example, \nthe term substMon(iso(f, g, a, \u00df)) gets stuck , even though it is well-typed! In logical terms, the property \nof canonicity [10] of ob\u00adservable types fails: there are closed terms of, say, boolean type that are \nneither equal to true nor equal to false. A weaker notion of canonicity-up-to-equivalence has been conjectured, \nbut not yet proved [23]. In this paper, we de.ne a two-dimensional univalent type the\u00adory (2TT), and \nprove that it does enjoy canonicity. 2TT is based on a judgemental, rather than propositional, account \nof its higher\u00addimensional structure. The key innovation is to consider a judge\u00adment of the form G f a \n: M .A N stating that a is evidence for the equivalence of M and N as objects of type A. The computa\u00adtional \ncontent of such equivalences is made explicit by judgemen\u00adtal operations that ensure that families of \ntypes and objects respect equivalence. Function extensionality and univalence are naturally accommodated \nas rules of equivalence, and the induced action ac\u00adcounts for the computational content of the equivalence \nproofs. As we show in Section 4, the identity type is reformulated simply as an internalization of the \nequivalence judgement (that is, as a hom\u00adtype). The Martin-L\u00f6f elimination rule is derivable from this \ninter\u00adpretation using the judgemental apparatus for equivalence. The judgemental formulation, described \nin Section 2, is adapted from earlier work [14] on the directed (non-symmetric) case. We require that \nthe forms of evidence include identity (re.M : M .A M), composition (if a : M .A N and \u00df : N .A P then \n\u00df . a : M .A P ), and inverse (if a : M .A N then a-1 : N .A M), corresponding to the re.exivity, symmetry, \nand transitivity properties of an equivalence relation. Moreover, these operations must satisfy the unit, \nassociativity, and inverse laws (on the nose, in the two-dimensional case) for a groupoid [12], a category \nin which all maps are invertible. Preservation of equivalence amounts to the requirement that families \nof types be functorial in their indices: if a : M .A N, and F is an A-indexed family of types, then mapa \n: F [M] . F [N] is the action of F on evidence x:A.F for the equivalence of indices. This action must \npreserve identities (the null action) and composition (the composite action), and hence inverses (the \nreverse action). 2TT has a simple interpretation in the category of groupoids: each type is interpreted \nas a groupoid, with objects modeling terms, and maps modeling equivalences in essence, 2TT constructs \na type-theoretic syntax out of the groupoid interpretation of type the\u00adory [12]. To justify that 2TT \nsolves the aforementioned problems with the computational interpretation of higher-dimensional type theory, \nwe prove canonicity in Section 3, showing that a closed term of boolean type is de.nitionally equal to \neither true or false. The proof may be seen as a generalization of the semantics of the NuPRL type theory \n[5] (in turn based on Tait s reducibility method): in our proof, types are interpreted as groupoids [12], \nrather than as equivalence relations. 2. Syntax Judgemental Framework As discussed above, we achieve \ncanon\u00adicity in 2TT using a judgemental presentation of equivalence. First, this means that, starting \nfrom the usual judgement forms of con\u00adtexts G ctx, dependent types G f A type (where G ctx), and terms \n Identity and composition for G f . :. G . .G2 f .2 :G3 G1 f .1 :G2 G f . :. G0 f d : .1 G .2 G f idG \n:. G1 f .2 [.1]:G3 G0 f .[d]: .[.1] . .[.2] . Identity, Inverses, and Composition for G f d : . . .' \n.0 [.[.']] = .0 [.][.'] 1-subst assoc/unit .0 [idG] = .0 idG[.] = . G .[d[d']] = .[d][d'] 1-resp assoc \n.[re..' ] = re..[.'] 1-resp preserves re.. .[.'][d] = .[.'[d]] 1-resp for 1-subst G f d1 : .1 . .2 G \nf d : . . .' G f d : .1 . .2 G0 f d0 : .0 G .' G f d2 : .2 . .30 G f re.. : . . . G f d-1 : .2 . .1 G \nf d2 . d1 : .1 . .3 G0 f d[d0]: .[.0] . .'[.'] . (d3 . d2) . d1 = d3 . (d2 . d1) trans assoc/unit (d \n. re.) = d (re. . d) = d (d . d-1) = re. inverse (d-1 . d) = re. Composition for G f A type 0 '] d0 \n[re.id] = d0 re.[d] = d d0 [d[d']] = d0 [d][d2-resp assoc/unit idG G (d1 . d2 )[d3 . d4] = d1 [d3] . \nd2 [d4] interchange re..[d] = .[d] delegate G f . :. . f A type . ctx . f C type G f d : .1 . .2 G f \nM : C [.1 ] G f A[.] type G f map..C d M : C [.2 ] A[.[.']] = A[.][.'] 0-subst assoc/unit A[idG] = A \nmap..C re.. M = M 0-resp functoriality map..C (d2 . d1) M = map..C d2 (map..C d1 M) (map..C d M )[.0] \n= map..C d[re..0 ] M [.0] 1-subst for map (mapC (d : .1 .2 ) M )[d' : .' .'] = resp (x.mapC (d[re..']) \nx)(M [d']) 1-resp for map 12 2 map..C[. :.'] dM = map.'.C re..[d] M def. map for A[.] Composition for \nG f M : A M [.[.']] = M [.][.'] 1-subst assoc/unit G f . :. . f M : A . f M : A G f d : .1 . .2 M [idG] \n= M G f M [.]: A[.]G f M [d]:(map..A d (M [.1])) A[.2] M [.2] M [d[d']] = M [d][d'] 1-resp assoc/unit \nM [re..] = re.M[.] 1-resp preserves re.. M [.][d] = M [.[d]] 1-resp for 1-subst Identity, Inverses, and \nComposition for G f a : M A N G f a1 : M1 A M2 G0 f d0 : .0 G .' 0 G f a : M1 A M2 G f a2 : M2 A M3 \nG f a : M A N G f re.A : M A M G f a-1 : M2 A M1 G f a2 . a1 : M1 A M3 G0 f a[d0]:(mapG.A d0 (M [.0])) \nA[.0' ] N [.' ] M 0 (a3 . a2) . a1 = a3 . (a2 . a1) trans assoc/unit (a . re.) = a (re. . a) = a (a . \na-1) = re. inverse (a-1 . a) = re. a[d[d']] = a[d][d'] 2-resp assoc/unit a[re.id] = a (a1 . a2 )[d3 . \nd4] = a1 [d3] . resp (x.map d3 x)(a2 [d4]) interchange re.M [d] = M [d] delegate Omitted Rules: All judgements \nrespect equality; all equality judgements are congruences. resp (x.F ) a means (x.F)[re.id, a/x] Derived \nforms: 1 mapaM means mapG,x:A.B (re.id, a/x) M x:A.B Figure 1. Judgemental Presentation of Equivalence \n Empty context: . : \u00b7= id\u00b7 1-. \u00b7 ctx (id\u00b7 is the only canonical substitution)(re.id\u00b7 is the only canonical \nequivalence) d : . \u00b7 . ' = re.\u00b7 2-. Term variables: G f d : . . . ' G ctx G f A type x:A . GG f . :. \nG f M : A[.]G f a :(map..A dM) A[. ' ] N G , x:A ctx G f x : A G f ., M/x :., x : A G f (d, a/x):(., \nM/x) .,x:A (. ' , N/x) G,x:A id[., M/x] = . 1-\u00df G x[., M/x] = M 1-\u00df . : (G , x:A) = idG[.], x[.]/x 1-. \nG,x:A id[d, a/x] = d 2-\u00df G x[d, a/x] = a 2-\u00df d : . (G,x:A) . ' = idG[d], x[d]/x 2-. idG,x:A = idG, x/x \n1-id (., M /x)[.0] = .[.0], M [.0]/x 1-subst (., M /x)[d0] = .[d0], M [d0]/x 1-resp re..,M/x = re.., \nre.M /x re. (d, a/x)-1 = (d-1 , (resp (x.map..A d-1 x) a-1)/x) sym (d2,a2/x) . (d1,a1/x) = (d2 . d1), \n(a2 . resp (x.map..A d2 x) a1)/x trans (d, a/x)[d0] = d[d0],a[d0]/x 2-resp Figure 2. Contexts G f A type \nG f M1 :. x:A. B G , x:A f B type G , x:A f M : B G f M2 : A G , x:A f a :(Mx) B (Nx)G f a : M . x:A. \nB N G f \u00df : M1 A N1 1 G f . x:A. B type G f . x. M :. x:A. B G f M1 M2 : B[M2 /x]G f . x.a : M G f a\u00df \n: map\u00df (MM1) B[N1/x] (NN1) . x:A. B N B (. x. M ) N = M[N/x] 1-\u00df M :. x:A. B = . x. Mx 1-. (. x.a1 ) \na2 = a1 [re.,a2/x] 2-\u00df a : M . x:A. B N = . x.a (re.x ) 2-. (. x:A. B)[.0] = . x:A[.0 ]. B[.0 , x/x] \n0-subst map... x:A. B dM = 0-resp . x. map.,x:A.B (d, re./x)(M (map..A d-1 x)) (. x. M )[.0] = . x . \nM [(.0 , x/x)] 1-subst (M1 M2 )[.0] = (M1 [.0 ]) (M2 [.0 ]) 1-subst (. x. M )[d] = . x . M [d, re./x] \n1-resp (MN )[d] = M [d] N [d] 1-resp re.M = . x . re.Mx re. (. x.a)-1 = . x .a-1 sym (. x.a2 ) . (. x.a1 \n) = . x .a2 . a1 trans (. x:A.a)[d0] = . x :A[. ' ].a[d0 , re./x] 2-resp 0 (a1 a2 )[d0] = (a1 [d0 ]) \n(a2 [d0 ]) 2-resp Figure 3. .-Types G f M : 2 G f M : 2 G , x:2 f C type G , x:2 f C type G , x:2 f M1 \n, M2 : C G f M1 : C [true/x ]G f a1 : M1[true/x] C[true/x] M2[true/x] G f M2 : C [false/x]G f a2 : M1[false/x] \nC[false/x] M2[false/x] G f 2 type G f true : 2 G f false : 2 G f ifx.C (M , M1 , M2 ): C [M /x]G f ifx.C \n(M ,a1 ,a2 ): M1[M/x] C[M/x] M2[M/x] G f a : M 2 N G f a : M 2 N G f a : true 2 false re.ection uip (where \nJ is any judgement) (re.true and re.false are canonical)G f M = N G f a = re.M G fJ if (true, M1 , M2 \n) = M1 1-\u00df if (false, M1 , M2 ) = M2 1-\u00df M[(N : El(2 ))/x] = if (N , M [true/x], M [false/x]) 1-. ifx.C \n(true,a1 ,a2 ) = a1 12-\u00df ifx.C (false,a1 ,a2 ) = a2 12-\u00df a[(re.M : 2 )/x] = if (M ,a[re.true/x],a[re.false/x]) \n12-. 2[.] = 2 0-subst map..2 dM = M 0-resp true[.] = true 1-subst false[.] = false 1-subst ifx : 2.C \n(M , M1 , M2 )[.] = 1-subst ifx : 2.C[.,x/x](M [.], M1 [.], M2 [.]) true[d] = re.true 1-resp false[d] \n= re.false 1-resp ifx : 2.C (M , M1 , M2 )[d : .1 .2] = 1-resp ifx : 2.C[.2,x/x](M [.2 ], M1 [d], M2 \n[d]) re. is canonical --1 ,-.- trivial by uip if (M ,a1 ,a2 )[d : .1 .2] = if (M [.2 ],a1 [d],a2 [d]) \n2-resp Figure 4. Booleans (as an Extensional Set) G f S : set G f set type G f El(S) type G f a : M \nEl(S) N G f a : M El(S) N G f M = N G f a = re.M set[.0] = set 0-subst (El(S))[.0] = El(S[.0]) map..set \ndM = M 0-resp --1 , -.- for set groupoid laws plus below re.M : El(S) is canonical --1 ,-.-, 2-resp for \nEl(S) trivial by uip G f M : 2 G f M : El(bool) G f bool : set (re.bool is canonical) G f not : bool \nset bool G f in M : El(bool)G f out M : 2 out (in M) = M 1-\u00df in (out M) = M 1-. map..El(S) d true = false \nif S[d] = not 0-resp map..El(S) d false = true if S[d] = not 0-resp bool[.] = bool 1-subst (in M )[.] \n= in M [.] 1-subst (out M )[.] = out M [.] 1-subst bool[d] = re.bool 1-resp not-1 = not sym not[d] = \nnot 2-resp Figure 5. Universe G f M : A (where G ctx and G f A type), we add a judge\u00adment of term equivalences \nG f a : M A M ' (where G ctx and G f A type and G f M , M ' : A). Second, this equivalence judgement \nis de.ned by rules speci.c to each type A, including equations explaining the meaning of identity (re.), \ninverses (a-1), and composition (a2 . a1) at each type. Third, all families of types and terms respect \nequivalence, as expressed by the following oper\u00adations: G, x:A f B type G f a : M1 A M2 G f M : B[M1 \n/x] G f map1 a M : B[M2 /x] x:A.B G f a : M A N G , x:A f F : B G f resp (x.F ) a : F [M/x] B F [N/x] \nmap expresses that a family of types indexed by A respects equiv\u00adalence at A: Given equivalent terms \nM1 and M2, map determines a function from B[M1/x] to B[M2/x]. As we discuss below, this 1 a-1 function \nhas an inverse given by map , so B[M1/x] and x:A.B B[M2/x] are isomorphic. Similarly, resp (x.F ) a expresses \nthat a family of terms of type B (where x is not free in B) with a free vari\u00adable x:A respects equivalence \nat A. map 1 aM computes on x:A.B the structure of the family B, while resp (x.F ) a computes on the structure \nof the family F . There is an additional resp-like operation which expresses that equivalences themselves \nrespect equivalence. To de.ne these operations, it is helpful to consider n-ary fami\u00adlies such as x1 \n:A1 , x2 :A2 ,..., xn :An .B. To this end, we present 2TT as an explicit substitution calculus, with \nadditional judgements for substitutions G f . :. (where G ctx and . ctx) and equiva\u00adlences between them \nG f d : . . . ' (where G ctx and . ctx and G f ., . ' :.). The treatment of dependent types in Pitts \n[20] s sur\u00advey article provides an introduction to this style of syntax, with an explicit substitution \njudgement and internalized composition prin\u00adciples. In full generality, map and resp express respect \nfor equiv\u00adalence between substitutions for a whole context, and are written map..C dM and M [d] respectively. \nAn analogous operation a[d] expresses that equivalence itself respects equivalence, while .[d] and d[d \n' ] extend these resp-principles to substitutions for an entire context, and equivalences between them. \nThe rules for this judgemental framework are presented in Fig\u00adure 1. We present the de.nitional equality \nrules as equations (e.g. . = . '), as a notational shorthand for inference rules de.ning typed equality \njudgements (e.g. G f . = . ' : .). By convention, each equation implicitly has premises asserting that \neach of the meta\u00advariables occuring in the equation are well-typed, and maintains the invariant that \nthe subjects of the equation are well-typed given these assumptions. Showing that the two sides of the \nequation have the same type sometimes involves de.nitional equality reasoning, but the equation being \nde.ned is never necessary for showing that its subjects have the same type. The .rst three rules de.ne \nidentity and composition for sub\u00adstitutions. To improve readability, we make weakening admissible (rather \nthan using de Bruijn form), so the identity substitution id is really the composition of the identity \nsubstitution with projec\u00adtions that forget any number of variables. We write G . . to mean that . is \nobtained from G by dropping some number of variables. All judgements of the form G f J are weakenable: \nIf G f J and G ' . G then G ' f J. Composition of substitutions .2 [.2], which we refer to as 1-substitution, \nis standard in explicit substi\u00adtution calculi. The additional composition operation, .[d], forces substitutions \nto respect equivalence, analogously to resp for terms above: substitution instances by equivalent substitutions \nare equiv\u00adalent. For this reason, we refer to it as 1-resp. The .rst three equa\u00adtions say that 1-substitution \nis associative and unital. In the second equation, idG can in fact be a weakening, in which case . is \ntacitly weakened in the right-hand side. The third equation only makes sense when G f id :G, which we \nnotate by idG G. The next two rules say that 1-resp associates with 2-resp (d[d ' ]), which is the anal\u00adogous \noperation for equivalences (de.ned below), and preserves identities re.(de.ned below). The next four \nrules de.ne identity, inverses, and composition for equivalences. Equivalences are always re.exive (re.), \nsym\u00admetric (d-1), and transitive (d2 . d1). Additionally, equivalences themselves respect equivalence \n(d[d0]), which we call 2-resp. The equations say that: Transitivity is associative, with unit re., and \ninverses given by --1 . 2-resp is also associative and unital, with unit G f re.idG : idGG idG (by above, \n.[idG] equals .). The in\u00ad G terchange law relates 2-resp and transitivity: transitivity followed by \n2-resp is the same as 2-resp followed by transitivity. This is a coherence requirement between the two \nforms of composition in a 2-category; we discuss some special cases in the extended version of this article \n[13]. The rule delegate delegates 2-resp at re.exivity to 1-resp. We do not de.ne 2-subst, d[.], directly, \nas this composition is de.nable as d[re..]. Next, we de.ne the corresponding operations for dependent \ntypes, terms, and term equivalences. A dependent type A can be pre-composed with a substitution, written \nA[.]; and has a functorial action map..A dM, which expresses that families of types respect equivalence. \nWe refer to these as 0-subst and 0-resp. The equations say: Substitution into types (0-subst) is associative \nwith unit re.. map is functorial, preserving re.exivity and transitivity. The next two rules de.ne 1-subst \nand 1-resp for map, which reassociate the 1-subst/1-resp with the 0-resp. The next rule de.nes map for \na composition, again by reassociating. Like all contextual judgements, terms are closed under substi\u00adtution \n(M [.]) and respect equivalence (M [d]). Because terms are dependent on the context, the latter requires \nadjusting M [.1] by d so that it lives in the same type as M [.2]. The equality rules are analogous to \nthose for substitutions: 1-subst is associative and uni\u00adtal, and 1-resp is associative and preserves \nre.exivities. The rules for term equivalences are analogous to the rules for equivalences, specifying \nre.exivity, transitivity, and 2-resp. The equations say that transitivity is associative, invertible, \nand unital, that 2-resp is associative and unital, and that the order of trans and 2-resp can be interchanged. \nThe interchange rule uses the derived form resp, described above. Contexts The general methodology for \nde.ning a context is to specify (1) A formation rule for G. (2) A substitution rule . :G, and a hypothesis \nrule for one of the other judgements (e.g. the term rule for x for the context former G , x:A). These \nfunction as the introduction and elimination rules for the context, which are products of some sort, \neliminated by .rst projections (which are implicit in id) and variables (representing projections). (3) \nAn equivalence rule for d : . G . ' (4) Equations de.ning 1-\u00df. (\u00df. for .), 2-\u00df. (\u00df. for d), identity \nidG, 1-subst .[. ' ], 1-resp .[d ' ], re.exivity re.., symmetry d-1 , transitivity d . d ', and 2-resp \nd[d ' ]. In general, re. and d-1 and d . d ' are de.ned in a type-directed manner, while the subst/resp \nprinciples are de.ned in a syntax\u00addirected manner, giving one rule for each syntactic construct. In Figure \n2 we carry out this methodology for the basic contexts: The empty context has a trivial substitution \ninto it, and a trivial equivalence from this substitution to itself. For the equations, it suf.ces to \nstipulate that these are unique. For context extension, if A is a type well-formed in G, then G can be \nextended with a variable of type A. A variable can be used as a term; the typing rule checks that the \nvariable is in the context. The substitution into an extended context . , x:A is a pair of a sub\u00adstitution \n. into . and a term of type A, adjusted by . (this is anal\u00adogous to the usual introduction rule for a \nS-type). An equivalence between such substitutions is a pair of equivalences, one between the substitutions, \nand the other between the terms (adjusted by the .rst component). As these substitutions and equivalences \nare pairs, the .rst set of rules gives the expected \u00df. rules, for the projections given by id and variables. \nThe next rules de.ne the identity, com\u00adposition, and inverse operations componentwise. .-types In general, \na type is speci.ed by (1) A formation rule for A. (2) Introduction and elimination rules for terms, de.ning \nM : A. (3) Introduction and elimination rules for equivalences, de.ning a : M A M '. (4) Equations de.ning \n1-\u00df. (\u00df. for M ), 2-\u00df. (\u00df. for a), 0-substitution A[.], 0-resp mapA dM, 1-substitution M [.], 1-resp \nM [d], re.exivity re.M , transitivity a . a ', and 2-resp a[d]. In Figure 3, we give the rules for dependent \nfunction types. The formation and term rules are standard. The equivalence introduc\u00adtion rule says that \nan equivalence at . can be introduced by giv\u00ading a family of equivalences that work for each element \nthe func\u00adtion extensionality rule. An equivalence is eliminated by applying to equivalent arguments, \nyielding an equivalence between the re\u00adsults. These rules have been considered in categorically-motivated \naccounts of functionally extensional propositional equality [9]. The \u00df.-rules are the expected rules \nfor functions, both at the term and equivalence levels. We write M[N/x] to abbreviate M [id, N/x]. Substitution \ninto a .-type proceeds compositionally. map. x:A. B is given by pre-and post-composition. 1-subst and \n1-resp are both de.ned compositionally, as is 2-resp. The rule for re. de.nes the identity at function \ntype in terms of the component\u00adwise identity. The rules for dependent pairs, which are analogous to \nthe rules for G , x:A, are presented in the extended version [13]. Booleans In Figure 4, we give rules \nfor a base type of booleans, including the usual true, false, and if-then-else constructs. We ad\u00additionally \ninclude an if-then-else that eliminates towards equiva\u00adlences, permitting equivalences to be de.ned by \ncase distinction. For simplicity, we specify booleans as an extensional set, corre\u00adsponding semantically \nto the discrete groupoid with two objects. This means that (1) equivalent booleans are de.nitionally \nequal (re.ection) and (2) any equivalence is equal to re.exivity (uip). Finally, we include a rule stipulating \nthat true and false are not equivalent, which would otherwise require large eliminations to prove. These \nrules illustrate that 2TT is compatible with treat\u00ading discrete types as in extensional type theory, \nthough a more intensional treatment of booleans is also possible. The \u00df.-rules are standard for sum types; \n0-resp is trivial because 2 is a con\u00adstant family; the 0/1-subst rules are standard. The 1-resp rule \nfor if uses the equivalence-level if-then-else, and is well-typed because of re.ection; the 2-resp rule \nfor if-then-else is analogous. No speci.c equations need to be given for --1 and -.- because of uip. \nSets and elements Finally, we need to seed the type theory with a base type with non-trivial equivalences, \nand a family of types dependent on it, to ensure that we have an example where map really has computational \ncontent. A simple example is to consider a universe set that contains discrete types. That is, each term \nS : set will determine a type El(S) whose elements have no non-identity equivalences between them. However, \nset itself is not a discrete type, because equivalence between sets S and T may be given by an isomorphism \nbetween El(S) and El(T ): f : S . T a : . x. f (g(x)) . x. x g : T . S \u00df : . x. g(f (x)) . x. x  iso(f, \ng, a, \u00df): S set T Then map 1 (iso(f, g, a, \u00df)) asserts that all families of types a:set.C respect isomorphism \nof sets. In Figure 5, we de.ne a simple universe of sets. We make two simpli.cations: .rst, the universe \ncontains a code for exactly one set, booleans; second, equivalences are given explicitly by the two automorphisms \non 2, re. (the identity function) and not. The approach readily scales to a richer universe closed under \n. and S, following our previous work [14], and to programmer-de.ned isomorphisms given by iso(f, g, a, \n\u00df), as we show in the extended version of this article [13]. The .rst four rules de.ne the type set and \nthe family El(-), and give re.ection and uip for El(-), expressing discreteness of sets in the universe. \nThe equations for 0-subst are compositional; 0-resp for set is trivial because it is a constant family. \nFor M : El(S), 1-resp generates an equation mapEl(S) d M [.1] = M [.2] by re.ection, so no equations \nfor M [d] are necessary. The next four inference rules specify the type 2: El(bool) is isomorphic to \n2 by in and out and their \u00df. rules. The two equiv\u00adalences bool set bool are re.bool (identity) and not \n(negation); map not is computationally relevant, as it interchanges true and false. The symmetry rule \nsays that not is involutive. 3. Properties 3.1 Consistency To show that the calculus is consistent, we \ncan adapt Hofmann and Streicher s groupoid interpretation [12] to our formulation of 2TT. We have given \na proof for a similar formalism for directed type the\u00adory in previous work [14]. We interpret each judgement \nas follows: [[G]] is a category. [[G f . : .]] is a functor [ .] : [[G]] -. [[.]]. [[G f d : .1. .2] \nis a natural transformation [ d] : [ .1] [ .2] : [[G]] -. [[.]]. [ A] is a functor [ A] : [[G]] -. GPD, \nwhere GPD is the (large) category of groupoids and functors. Terms and term equivalences are interpreted \nas dependent functors and natural transformations. Because the details of this proof have been covered \nin previous work, we do not review them here. As a corollary of the interpretation, we get various consistency \nresults: [ 2] is the discrete category on two objects, so the interpretation shows that it is not the \ncase that \u00b7f true = false : 2, or that \u00b7f a : true 2 false. Moreover, if the calculus is extended with \nan empty type 0 interpreted as the empty category, the interpre\u00adtation implies that not all types are \ninhabited. We do not attempt a proof-theoretic proof of consistency of de.nitional equality, e.g. using \nreduction or normalization-by-evaluation [7]. Proving con\u00adsistency using these approaches typically involves \ngiving a decision procedure for de.nitional equality, and equality for 2-dimensional type theory is not \ndecidable, due to the equality re.ection rules for identity types discussed in in Section 4. Given this, \nwe also exploit equality re.ection for 2 and El(S), though these types could be treated in a more intensional \nway instead.  3.2 Canonicity Our main new result in this paper is to check a kind of complete\u00adness, \nverifying that we have not omitted any necessary de.nitional equations for map, resp, etc. Speci.cally, \nwe show that the equa\u00adtions of 2TT are suf.cient to equate a closed term of type 2 to a value: THEOREM \n3.1: CANONICITY. If \u00b7f M : 2 then either \u00b7f M = true : 2 or \u00b7f M = false : 2. This result fails for higher-dimensional \ntype theory based on the univalence axiom [23], due to stuck applications of Id-elimination, as illustrated \nin the introduction though it is currently conjectured that every closed term of boolean type may be \nequivalent to a value. In our setting, we prove the stronger result that canonicity holds for de.nitional \nequality. The proof is organized as follows: First, we de.ne the seman\u00adtic domains into which we interpret, \nwhich consist of syntactically presented groupoids and functors. Using the usual terminology of logical \nrelations, we say that an expression is reducible iff it is a member of these semantic domains. In a \nsimple logical relations ar\u00adgument, open terms are reducible iff they take reducible arguments to reducible \nresults. For 2-dimensional type theory, this general\u00adizes to both (1) taking reducible terms to reducible \nterms and (2) taking reducible equivalences to reducible equivalences i.e. func\u00adtoriality. Analogous \nde.nitions are necessary for dependent types, dependently typed terms, and equivalences. Next, we show \nthat the semantic domains are closed under the type formers, and prove the fundamental theorem, which \nsays that all well-typed expressions are reducible. Finally, we obtain canonicity as a corollary. 3.2.1 \nTheorem Statement Syntactically presented groupoids and functors DEFINITION 3.2. A groupoid G is presented \nby G (where G ctx) iff 1. The set of objects of G, written Ob G, is a subset of the equiv\u00adalence classes \nof substitutions \u00b7f . :G modulo de.nitional equality. Due to the preponderance of brackets in the syntax \nof 2TT, we write \u00ab.\u00bb for the equivalence class of .. 2. The set of morphisms \u00ab.1\u00bb -.G \u00ab.2\u00bb is a subset \nof the equivalence classes of equivalences \u00b7f d : .1G .2 modulo de.nitional equality. 3. identity at \n\u00ab.\u00bb is given by \u00abre..\u00bb, composition of \u00abd2\u00bb and  \u00abd1\u00bb is given by \u00abd2 . d1\u00bb, and the inverse of \u00abd\u00bb \nis given by \u00abd-1 \u00bb. Note that we choose representatives of equivalence classes at vari\u00adous points in \nthis de.nition; these uses are well-de.ned by the con\u00adgruence laws for de.nitional equality. We write \n(G) to mean some groupoid that is presented by G, and use the analogous notation for the other syntactic \npresentations de.ned below. Analogously, we de.ne what it means for a groupoid to be presented by a \nclosed type: DEFINITION 3.3. A groupoid G is presented by A (where \u00b7f A type) iff 1. Ob G is a subset \nof the equivalence classes of terms \u00b7f M : A modulo de.nitional equality.  2. The set of morphisms \u00abM1\u00bb \n-.G \u00abM2\u00bb is a subset of the equivalence classes of equivalences \u00b7f a : M1G M2 modulo de.nitional equality. \n 3. identity at \u00abM\u00bb is given by \u00abre.M \u00bb, composition of \u00aba2\u00bb and  \u00aba1\u00bb is given by \u00aba2 . a1\u00bb, and the \ninverse of \u00aba\u00bb is given by \u00aba-1 \u00bb. A functor may be presented by a term with one free variable: DEFINITION \n3.4. A functor F : (A) -. (B) is presented by M (where x : A f M : B) iff 1. Forall\u00abN\u00bb . Ob (A), F (\u00abN\u00bb)= \n\u00abM [N/x]\u00bb. 2. Forall\u00aba\u00bb : \u00abN1\u00bb -.(A) \u00abN2\u00bb, F (\u00aba\u00bb)= \u00abM [a/x]\u00bb.  Let GPD be the category of groupoids \nand functors between them. A functor into GPD may be presented by a type: DEFINITION 3.5. A functor \nF : (G) -. GPD is presented by A, where G f A type iff 1. Forall\u00ab.1\u00bb . Ob (G), F (\u00ab.1\u00bb) is presented \nby A[.1]. 2.For all \u00abd\u00bb : \u00ab.1\u00bb -.(G) \u00ab.2\u00bb, F (\u00abd\u00bb) is presented by x : A[.1 ].mapA dx. We write (A) \nfor a functor presented by A. Observe that all of these de.nitions respect de.nitional equality. For \nexample, if G is presented by G, and G = G ', then G is also presented by G ' . Reducible expressions \nGiven these de.nitions, we can de.ne the invariants about each syntactic category that are demanded by \nthe proof: DEFINITION 3.6. Given groupoids (G) and (.), de.ne the set RedSubst (G)(.) (reducible substitutions) \nto be those substitu\u00adtions G f . :. such that 1. Forall\u00ab.1\u00bb . Ob (G),\u00ab.[.1]\u00bb . Ob (.) 2. For all \u00abd\u00bb \n: \u00ab.1\u00bb -.(G) \u00ab.2\u00bb, \u00ab.[d]\u00bb : \u00ab.[.1]\u00bb -.(.) \u00ab.[.2]\u00bb  . necessarily preserves identity and composition, \nby the corre\u00adsponding rules of de.nitional equality. Thus, if . . RedSubst(G)(.), then we can de.ne a \nfunctor . * : (G) -. (.) using the given ac\u00adtions on objects and arrows. DEFINITION 3.7. Given (G) and \n(.) and .1,.2 . RedSubst(G)(.), (G) de.ne the set RedEquiv(.) .1 .2 (reducible equivalences) to con\u00ad \ntain those G f d : .1. .2 such that for all \u00abd ' \u00bb : \u00ab.1' \u00bb -.(G) \u00ab.2' \u00bb, \u00abd[d ' ]\u00bb : \u00ab.1 [.1' ]\u00bb -.(.) \n\u00ab.2 [.2' ]\u00bb As a special case, this means that for any . . Ob (G),\u00abd[re..]\u00bb : \u00ab.1 [.]\u00bb -.(.) \u00ab.2 [.]\u00bb. \nThis family of morphisms is natural (a consequence of the interchange law rule of de.nitional equality). \nConsequently, if d is reducible, then it determines a natural isomor\u00adphism d * : (.1)(.2) : (G) -. (.). \nWe write RedEquiv .1 .2 (G) for RedEquiv(.) .1 .2 when the contexts are unambiguous. DEFINITION 3.8. \nGiven a groupoid (G) and a functor (A) : (G) -. GPD, de.ne the set RedT m(G) (A) (reducible terms) to \nbe those terms G f M : A such that 1. Forall\u00ab.1\u00bb . Ob (G),\u00abM [.1]\u00bb . Ob (A)(\u00ab.1\u00bb) 2. Forall\u00abd\u00bb : \u00ab.1\u00bb \n-.(G) \u00ab.2\u00bb, \u00abM [d]\u00bb : \u00abmapA d M [.1]\u00bb -.(A)(\u00ab.2\u00bb) \u00abM [.2]\u00bb  We write RedT m (A) for RedT m(G) (A) when \nthe context is unambiguous. DEFINITION 3.9. Given M, N . RedT m(G) (A), de.ne the set RedEquiv M N (reducible \nequivalences) to contain those G f a : M A N such that for all \u00abd\u00bb : \u00ab.1\u00bb -.(G) \u00ab.2\u00bb, \u00aba[d]\u00bb : \u00abmapA \nd M [.1]\u00bb -.(A)(\u00ab.2\u00bb) \u00abN [.2]\u00bb Theorem Statement Using these de.nitions, we are in a position to state \nthe fundamental theorem. In the remainder of this section, we will de.ne partial functions [[G]] and \n[ A] such that: THEOREM 3.10: FUNDAMENTAL THEOREM. 1. If G ctx then [[G]] is a groupoid presented by \nG. 2. If G = G ' then [[G]] = [[G ' ] . 3. If G f . :. then . . RedSubst [[G]] [[.]]  [[G]] 4. If \nG f d : .1. .2 then d . RedEquiv.1 .2. [[.]] 5. If G f A type then [ A] is a functor [[G]] -. GPD presented \nby A. 6. If G f A = A ' type then [ A] = [ A ' ] .  7. If G f M : A then M . RedT m[[G]] [ A] [[G]] \n 8. If G f a : M A N then a . RedEquiv[ A] MN The proof is by mutual induction on the given derivations. \nAs usual, the interpretation is de.ned compositionally, in terms of semantic counterparts of each type \nconstructor: [ \u00b7] = \u00b7 R [[G, x : A] = [ A] [[G]] [[. x:A. B] = .[ A] [ B] [ 2] = const(2) [ set] = \nconst(set) [ El(M)]] = El[M * ] [ A[.]]] = [ A]][. * ] These should be understood as partial functions, \ndue to the typing constraints on the semantic type formers, as described below. The fundamental theorem \nstates that they are de.ned on all well-typed expressions.  3.2.2 De.nitions of Semantic Contexts and \nTypes First, we give the inductive steps of the interpretation of contexts and types, describing the \nsemantic analogue of each context and type constructor. For each context, we de.ne a groupoid, and for \neach type, we de.ne a functor (G) -. GPD. Moreover, we prove that these constructions are presented by \nthe appropriate contexts and types. The type-directed de.nitional equalities for re., --1 , and -.-, \nas well as the equations de.ning mapA , are used in these veri.cations. Contexts Corresponding to the \nempty context, let \u00b7 be the groupoid with one object, \u00abid\u00b7\u00bb, and one identity arrow, \u00abre.id\u00b7 \u00bb, and all \ncompositions and inverses de.ned to be \u00abre.id\u00b7 \u00bb. Observe that this is presented by \u00b7: the objects are \nclasses of closed substitutions; the morphisms of closed equivalences; identity is \u00abre.\u00bb; \u00abd\u00bb-1 is \u00abd-1\u00bb=\u00abre.\u00bb \nby 2.; and similarly for composition. For context extension, given (G) and (A) : (G) -. GPD, the Grothendieck \nconstruction constructs a .bration from the total cat- R egory (G)R(A) to (G) given by a projection \nfunctor p. Concretely, we de.ne (G)(A) so that it is presented by G, x : A: 1. An object \u00ab(., M/x)\u00bb is \nthe equivalence class of a pair, where \u00ab.\u00bb . Ob (G) and \u00abM \u00bb . Ob (A)(\u00ab.\u00bb). 2. A morphism \u00ab(d, a/x)\u00bb \n: \u00ab(.1,M1/x)\u00bb -.R (G)(A) \u00ab(.2,M2/x)\u00bb is the equivalence class of a pair, where \u00abd\u00bb : \u00ab.1\u00bb -.(G)\u00ab.2\u00bb \nand \u00aba\u00bb : \u00abmapA dM1\u00bb -.(A)(\u00ab.2\u00bb) \u00abM2\u00bb  3. Identity is de.ned to be  \u00abre.(.,M/x)\u00bb : \u00ab(., M/x)\u00bb -.R (G)(A) \n\u00ab(., M/x)\u00bb To verify that this is a morphism, we must show that it is the equivalence class of a pair \nof morphisms, each in the ap\u00adpropriate category. By de.nitional equality, \u00abre.(.,M/x)\u00bb = \u00ab(re.., re.M \n/x)\u00bb, so it remains to show that \u00abre..\u00bb : \u00ab.\u00bb -.(G) \u00ab.\u00bb \u00abre.M \u00bb : \u00abmapA re.. M\u00bb -.(A)(\u00ab.\u00bb) \u00abM\u00bb. For the \n.rst, because (G) is presented, \u00abre..\u00bb is a mor\u00adphism in (G) (and is in fact the identity). For the second, \n\u00abmapA re.. M\u00bb=\u00abM\u00bb by de.nitional equality, and because (A) is presented, (A)(.) is presented by A[.], \nand therefore \u00abre.M \u00bb is a morphism (and moreover is the identity). The veri.cation of the de.nition \nof symmetry by \u00abd\u00bb-1 = \u00abd-1\u00bb and composition by \u00abd1\u00bb . \u00abd1\u00bb=\u00abd2 . d1\u00bb is similar. The groupoid equations \nhold because they hold for de.nitional equality. RR Observe that (G)(A) is presented by G, x : A. Because \n(G)(A)is only de.ned when the base is presented by a context G, and (A) : (G) -. GPD, the equation for \n[[G , x:A] has tacit side conditions that [[G]] is presented by G, and that [ A] : [[G]] -. GPD. In the \nproof of the fundamental theorem, we show that these are satis.ed for well-formed syntax. Types We de.ne \n[ 2] to be the constant functor returning the groupoid 2, the discrete groupoid with two objects, \u00abtrue\u00bb \nand \u00abfalse\u00bb, and only identity arrows \u00abre.true\u00bb and \u00abre.false\u00bb. A priori, it is not necessarily the case \nthat all terms of type 2 are objects of this groupoid only the ones that are equal to true or false but \nthe fundamental theorem will show that, in fact, they all are. To see that this is presented by 2, we \nmust show: (1) that for any ., 2 is presented by 2[.]. Because presented by respects de.nitional equality, \nand 2[.] = 2, it suf.ces to show that it is presented by 2, which it is the conditions on inverses and \ncomposition follow from uip. (2) That for any d, the identity functor (which is the action of a constant \nfunctor) is presented by x.map2 dx. Again using respect for equality, by the de.nition of map for 2, \nit suf.ces to show that the identity functor is presented by x.x which it is, using the \u00df rules for x[.] \nand x[d]. Similarly, we de.ne [ set] to be the constant functor deliver\u00ading the groupoid set with one \nobject, \u00abbool\u00bb, and two arrows, \u00abre.bool\u00bb and \u00abnot\u00bb, such that \u00abre.bool\u00bb is the identity and \u00abnot\u00bb-1 \n=\u00abnot\u00bb (the de.nitions of the remaining compositions are forced by the groupoid laws). The veri.cation \nthat it is presented by set is analogous to the above for 2. For El, .rst observe that because const(set) \nis a constant functor, an M . RedT m(G) const(set) determines a func\u00adtor M * : (G) -. set. Thus, it suf.ces \nto de.ne a functor El : set -. GPD and interpret El(M) by composition. For our simple universe, El is \nde.ned as follows: On objects, take El(\u00abbool\u00bb) to be the discrete groupoid with two objects, \u00abin true\u00bb \nand \u00abin false\u00bb. For a richer universe, with more type construc\u00adtors, this de.nition would be extended \nto analyze the other pos\u00adsible codes for types. A functor between discrete groupoids is de\u00adtermined by \na function between their sets of objects, so for mor\u00adphisms, take El(\u00abre.bool\u00bb) to be the identity function, \nand El(not) to be the function that interchanges \u00abin true\u00bb and \u00abin false\u00bb. This is well-de.ned because, \nby the semantic consistency argument, true = false and re.bool = not, so we can map these equiva\u00adlence \nclasses to different results. It is simple to verify that this obeys the functor laws. It remains to \ncheck that El[\u00abM\u00bb] is presented by El(M). We have two obligations: 1. Forall\u00ab.\u00bb . Ob (G), El[\u00abM\u00bb](.) \nis presented by El(M )[.]. Because M is reducible, \u00abM [.]\u00bb is an object of set, and there\u00adfore equals \n\u00abbool\u00bb. This means that M [.] = bool, so in the syntax we can derive that El(M )[.] = El(bool) by pushing \nthe substitution inside, and then using congruence and transitiv\u00adity. The veri.cation that El(\u00abbool\u00bb) \nis presented by El(bool) is analogous to the above. 2. For all \u00abd\u00bb : \u00ab.1\u00bb -. \u00ab.2\u00bb, El[\u00abM\u00bb](\u00abd\u00bb) is presented \nby x.mapEl(M) dx. Due to discreteness/uip, the morphism part is trivial, so we show the objects, which \namounts to: assuming \u00abN\u00bb . Ob El[\u00abM\u00bb](.1), we must show that \u00abmapEl(M) dN\u00bb . Ob El[\u00abM\u00bb](.2). As in the \n.rst part, we know that El[\u00abM\u00bb](.1) and El[\u00abM\u00bb](.2) are both El(\u00abbool\u00bb), and that El(M )[.1] = El(M )[.2] \n= El(bool). More\u00adover, because M is reducible, \u00abM [d]\u00bb is a morphism in set, which means that it is either \n\u00abre.bool\u00bb or \u00abnot\u00bb. In the .rst case, (x.mapEl(M) dx) = (x.mapEl(M) re. x) = x.x by 0-resp functoriality. \nIn the second, (x.mapEl(M) x) agrees with the semantic negation function on \u00abin true\u00bb and \u00abin false\u00bb \nby 0-resp for El(-).  To interpret A[.], we overload F [G] to mean functor compo\u00adsition. We verify that, \nwhen (A) : (.) -. GPD and . . RedSubst (G)(.), (A)[. * ] is presented by A[.]. 1. First, for an object \n\u00ab. ' \u00bb .(G), we must show that (A)(. * (\u00ab. ' \u00bb)) is presented by (A[.])[. ' ]. By respect for equality, \nit suf\u00ad.ces to show presentation by A[.[. ' ]]. By de.nition of . * , . * (\u00ab. ' \u00bb)= \u00ab.[. ' ]\u00bb . Ob (.). \nThus, by de.nition of (A), (A)(\u00ab.[. ' ]\u00bb) is presented by A[(.[. ' ])], as we needed to show. 2. Second, \nfor a morphism \u00abd\u00bb : \u00ab.1\u00bb -.(G) \u00ab.2\u00bb, we must show that (A)[. * ](\u00abd\u00bb) is presented by x.mapA[.] dx. \nThis follows from the equation for map for composition, equating it to x.mapA (re..[d]) x.  Finally, \nwe come to .A B. First we interpret closed .-types: given a groupoid (A) and a functor (B) : (x : A) \n-. GPD, we construct a groupoid p(A) (B), which is the dependent analogue of the functor category (B)(A): \n1. An object is an equivalence class \u00ab. x. M \u00bb, where M . RedT m (x : A)(B). 2. A morphism \u00ab. x. M \u00bb \n-.(p(A) (B)) \u00ab. x. N \u00bb is \u00ab. x.a\u00bb, where a . RedEquiv M N. 3. Identity at \u00ab. x. M \u00bb is \u00abre.. x. M \u00bb. \nTo see that this is a mor\u00adphism, we have to show that it is the equivalence class of a func\u00adtion, whose \nbody is reducible. But \u00abre.. x. M \u00bb=\u00ab. x. re.M \u00bb, so it suf.ces to show that re.M . RedEquiv M M. By \ndef\u00adinition, this means that for any d : .1 -.(x : A) .2,\u00abM [d]\u00bb : \u00abmapB d M [.1]\u00bb -. \u00abM [.2]\u00bb. But this \nfollows immediately from M . RedTm B, which is necessary for \u00ab. x. M \u00bb to be an object. The de.nitions \nof inverse and composition are analogous; the groupoid equations hold because they hold for de.nitional \nequality.  Observe that p(A) (B) is presented by . x:A. B. Next, for a functor (B) : (G , x:A) -. GPD, \nits restriction to \u00ab.\u00bb . Ob G, is the functor (B)|\u00ab.\u00bb : (x : A(\u00ab.\u00bb)) -. GPD de.ned by (B)|\u00ab.\u00bb\u00ab(M/x)\u00bb \n= (B)\u00ab(., M/x)\u00bb (B)|\u00ab.\u00bb\u00ab(a/x)\u00bb = (B)\u00ab(re.., a/x)\u00bb Observe that (B)|\u00ab.\u00bb is presented by B[., x/x]. The \nrestriction thus corresponds to holding the G part of the functor .xed at a particular object. Now we \ncan de.ne the functor .(A) (B) : (G) -. GPD, given (A) : (G) -. GPD and (B) : (G , x:A) -. GPD: .(A) \n(B)(\u00ab.\u00bb)= p(A)(\u00ab.\u00bb) (B)|\u00ab.\u00bb .(A) (B)(\u00abd\u00bb : \u00ab.1\u00bb -.(G) \u00ab.2\u00bb)= (x.map. x:A. B dx) First, observe that \nfor each \u00ab.\u00bb, .A B(\u00ab.\u00bb) is presented by . x:A. B[.] = . x:A[.]. B[., x/x]. Second, we must verify that \nx.map. x:A. B dx is reducible for any d, so that it extends to a func\u00adtor. Observe that the converse \nholds: If the action on morphisms of a functor (C) is presented by mapC , then for any d, x.mapC dx is \nreducible. Thus, by the assumptions about (A) and (B), mapA and mapB are reducible for any d. By the \nde.nition of map for ., we have that mapG.. x:A. B df = . x. mapG,x:A.B (d, re.)(f (mapG.A d-1 x)) By \nrespect for equality, it suf.ces to show that the RHS is reducible. This follows from the de.nition of \np and the reducibility of mapA and mapB . Using these de.nitions, it is simple to check the cases of \nthe fundamental theorem for parts 1, 2, 5, and 6. For parts 1 and 5, in each case the inductive hypotheses \nsatisfy the pre-conditions of the designated semantic construction, and we have already veri.ed that \nthese constructions de.ne groupoids that are appropriately syn\u00adtactically presented. For parts 2 and \n6: the congruence rules hold because the interpretation is de.ned compositionally; the equiv\u00adalence relation \nrules hold because equality in the meta-language is an equivalence relation. The only non-trivial equations \nbetween types are the rules that commute substitution with type formers (e.g. . x:A. B[.] = . x:A[.]. \nB[., x/x]), which are simple to verify for the above de.nitions. Observe that the proof does not descend \ninto equations between terms, because the only source of dependency is El(M), where [ El(M )]] = El[M \n* ], and M * auto\u00admatically respects equality in M. 3.2.3 Reducibility of Substitutions/Terms and Equivalences \nFinally, we must show that each ., M, d and a is reducible. In general: To show that an introduction \nforms is reducible, we will argue that [ -] is de.ned to be intro forms whose subterms are reducible \n, and that the subterms will be reducible by the induc\u00adtive hypotheses. To show that an elimination form \nis reducible, we will argue that [ -] tells you that it suf.ces to check the \u00df-redices, that the result \nof reduction is reducible by induction, and that the elim. form is reducible because de.nitional equality \ncontains re\u00adduction. To show that the judgemental operations are reducible, we will observe that syntactic \npresentation of [ -] ensures that all closed instances of these operations exist, and that, using associa\u00adtivity \nlaws, the de.nition of reducibility reduces to checking closed instances. We show some representative \ncases for d, M, and a; the other cases, including those for ., are available in the extended ver\u00adsion \n[13]. Equivalences between Substitutions The case for re. follows from . . RedSubst [[G]] [[.]] and delegate. \nThe case for d-1 re\u00adduces to symmetry of morphisms of [[G]] and [[.]] using the equa\u00ad tion d-1 [d ' ] \n= d[d '-1] -1, which is derivable from interchange. The case for d . d ' is similar, using interchange \nto push the com\u00adpositions inward. The case for .[d] uses 1-resp assoc to associate, while the case for \nd[d ' ] uses 2-resp assoc to associate. The case for (d, a/x) uses the de.nition of 2-resp for such pairs. \n Terms Case for mapA dM: On objects, we must show that \u00ab(mapA d M )[.]\u00bb . Ob [ A[.2]]](\u00ab.\u00bb)= Ob [ A[.2 \n[.]]]]. By 1-subst for map, it suf.ces to show that \u00abmapA d[re..] M [.]\u00bb is. This follows from the inductive \nhypotheses for M and d, which show that their instances by . are a morphism and object of the appropriate \ncategories, and from syntactic presentation of [ A] , which shows that mapA is functorial, and therefore \nreducible. The argument for morphisms is similar, using 1-resp for map. Case for . x. M : On objects, \nwe must show that \u00ab. x. M [.]\u00bb . Ob [[. x:A. B]](\u00ab.\u00bb)= Ob p[ A[.]]] [ B[., x/x]]]. By def. subst, this \nequals \u00ab. x. M [., x/x]\u00bb. So it suf.ces to show that x.M . RedT m[ x : A[.]]] [ B[., x/x]]]. The obligations \nfor both objects and morphisms follow from the IH M . RedT m[[G,x : A] [ B] , holding the G part .xed \nat .. The action on morphisms is similar, using \u00ab(. x. M )[d]\u00bb=\u00ab. x. M [d, re.x /x]\u00bb. Case for M1 M2 \n: On objects, we must show that \u00abM1 M2 [.]\u00bb = \u00abM1 [.] M2 [.]\u00bb . Ob [ B[M2/x]]](\u00ab.\u00bb)= Ob [ B[., M2 [./x]]]]. \nBy the inductive hypothesis, we know that \u00abM1 [.]\u00bb=\u00ab. x . M1 ' \u00bb where M1 ' is reducible, and that \u00abM2 \n[.]\u00bb is an appropriate object. Thus, \u00abM1' [M2 [.]/x]\u00bb=\u00ab(. x. M1 ' ) M2 [.]\u00bb=\u00abM1 [.] M2 [.]\u00bb is an object \nof the result. The morphism part is analogous, because M1 M2 [d]= M1 [d] M2 [d]. We omit the cases for \nM [.], x, bool, true, false, if, in, and out. Equivalences between Terms The cases for the judgemental \nframework operations (re., a-1 , a . a ' , M [d], a[d]) are analo\u00adgous to those for substitutions above. \nCase for . x.a: Given d,\u00ab(. x.a)[d]\u00bb=\u00ab. x.a[d, re.x /x]\u00bb, so it suf.ces to show that a[d, re.x/x] is \nreducible. Picking a sub\u00adstitution \u00ab\u00df/x\u00bb, the obligation is to show that \u00aba[d, re.x /x][\u00df/x]\u00bb is a morphism. \nThis holds by reassociating the substitution, and then using the IH that a is reducible. Case for a\u00df: \nPick \u00abd\u00bb : \u00ab.1\u00bb -.[[G]] \u00ab.2\u00bb. To show: \u00aba\u00df[d]\u00bb : mapB[M2/x] d (M1 M2 )[.1] -.[ B[N1 /x][.2]]] (NN1 )[.2] \nBy equality, this is\u00ab(a[d]) (\u00df[d])\u00bb. The IH gives that a,\u00df are re\u00adducible, so a[d]: \u00abmap. x:A. B d M \n[.1]\u00bb -.[[. x:A. B]](\u00ab. ' \u00bb) \u00abN [.2]\u00bb \u00df[d]: \u00abmapA d M1 [.1]\u00bb -.[ A] \u00abN1 [.2]\u00bb To complete the case, we \n(1) show that if \u00aba '\u00bb is a morphism of p(X) (Y ) and \u00ab\u00df '\u00bb is a morphism of (X), then \u00aba ' \u00df '\u00bb is a \nmorphism of (Y ) the argument uses 2-\u00df-expansion, analogously to the case for application above. (2) \ndeduce that (map. x:A. B d (M [.1 ])) (mapA d (M1 [.1 ])) = mapB[M2/x] d (M1 M2 )[.1] the proof uses \nthe de.nition of map for ., functoriality of map, cancellation of inverses, and the def. map for A[.]. \nThis shows that \u00ab(a[d]) (\u00df[d])\u00bb is a morphism of the appropriate type. We omit the cases for if and not. \n 3.2.4 Canonicity Here, we check that Theorem 3.1 is a corollary of the fundamental theorem. Assume \n\u00b7f M : 2. Then M . RedT m[ \u00b7] [ 2] , so M . RedT m \u00b7 const(2). By de.nition, \u00abid\u00b7\u00bb . Ob \u00b7, so \u00abM [id\u00b7]\u00bb \n. Ob (const(2)(\u00abid\u00b7\u00bb)). But M [id\u00b7] = M and const(2)(\u00abid\u00b7\u00bb)= 2, so \u00abM\u00bb . Ob 2. By de.nition of 2, this \nmeans \u00abM\u00bb=\u00abtrue\u00bb or \u00abM \u00bb=\u00abfalse\u00bb, which means that M = true or M = false. 4. Identity Types In this section, \nwe show how to internalize the judgemental notion of equivalence as an identity type IdA MN, satisfying \nthe usual rules. The rules for the identity type are presented in Figure 6. in, out, and the \u00df. rules \nfor them state that the inhabitants of the iden\u00adtity type IdA MN are exactly the equivalences M A N. \nThe re.ection and uip rules express two-dimensionality: equivalences themselves are equivalent only if \nthey are equal, and all equiva\u00adlences between equivalences are the identity. These rules express strict \n2-dimensionality, and are an inherent source of undecidabil\u00adity for a strictly 2-dimensional theory; \nGarner [9] discusses this point further. The 0-resp rule expresses the action of the Hom\u00adfunctor, given \nby pre-and post-composition. out M determines a 2-cell from a one-cell, and is the .rst mechanism in \nour calculus for introducing variable equivalences. Because 2-resp is determined by the structure of \nthe equivalence being substituted into, (out M )[d] is stuck until M is determined. Canonicity remains \ntrue in the pres\u00adence of the identity type, interpreting [ IdA MN] as the Hom\u00adfunctor. Surprisingly, \nwe can derive the standard J elimination rule for the identity type. In traditional presentations of \nMLTT, map (which is usually called subst) does not entail J. In 2TT, it does, because of the following \nproperties of the judgemental presentation of equiva\u00adlence: 1. It axiomatizes the 2-cell structure of \ntypes using the operations re., --1 , -.- M [d], and mapC . Our derivation of J uses unit law equations \nfor these operations: re.-1 = re. M [re..] = re.M [.] re. . a = a mapC re. M = M 2. It interprets the \nidentity type as the Hom-functor. Our deriva\u00adtion of J exploits the Hom-functor s action, which de.nes \nmapG.IdA MN in terms of pre-and post-composition.  3. It axiomatizes the 2-cell structure of S-types \nas context ex\u00adtension G , x:A. The derivation of J uses the pairing intro\u00adduction rule for G,x:A, and \nthe de.nition of re..,M/x = (re.., re.M /x).  In traditional type theory, this 2-cell structure is \ninstead derived from the identity type, which requires taking J as a primitive rule. We state J in the \nPaulin-Mohring form [19]: G f A type G f M : A G, x : A, p : IdA Mx f C type G f b : C [idG , M /x, re.M \n/p] G f N : A G f P : IdA MN G f JC (b, P): C [idG , N /x, P/p] JC (b, in re.M ) = b and de.ne it by \nJC (b, in re.M ) := mapG,x:A,p:IdAMx.C (re.idG , out P/x, in (re.P )/p) b As Awodey has observed,1 J \ncan be de.ned in terms of map, given, for any A, M, N, P as in the premises of J, an equivalence (M/x, \nre.M /p) (x : A,p : IdAMx) (N/x, P/p) Homotopically, this says that any path from M with a free endpoint, \nrepresented by the pair (N, P ), is homotopic to the pair (M, re.) of M itself and the trivial path. \nGeometrically, (M, re.) can be expanded to (N, P ) by dragging M along P . Here, we observe that this \nequivalence is in fact provable, by (out P/x, in (re.P )/p), using the rules described above. Because \nwe work with total substitutions, we show that (re.idG , out P/x, in (re.P )/p): (idG, M/x, re.M /p) \n(G,x : A,p : IdAMx) (idG, N/x, P/p) so that mapC coerces the b to the appropriate type. Unpacking the \npairing introduction rule for equivalence at G , x:A, our .rst goal 1 Personal communication. G f A \ntype G f{M , N } : A G f a : M A N G f M : IdA MN G f a : P IdA MN Q G f a : P IdA MN Q G f IdA MN type \nG f in a : IdA MN G f out M : M A N (re.in a is canonical if a is) G f P = Q G f a = re.P out (in a) \n= a 1-\u00df in (out M) = M 1-. (IdA MN )[.] = IdA[.] M [.] N [.] 0-subst map..IdA MN dP = 0-resp in (N [d] \n. (resp (x.mapA dx)(out P )) . M [d]-1) (in a)[.] = in (a[re..]) 1-subst (in a)[d] = in (a[d]) 1-resp \nre. is canonical --1 ,-.- trivial by extensionality (out M )[d] stuck until M reduces (neutral) 2-resp \nFigure 6. Identity Types is to show that re.idG : idGG idG, which it clearly does. Next, the second component \nof the pair must have type M A N (the adjustment mapG.A re.idG M cancels by the unit law for map), which \nout P does. Our .nal goal is to prove mapG,x:A.IdA Mx (re.idG , out P/x)(in re.) P In fact, the left-hand-side \nis de.nitionally equal to the right-hand, so re.P gives the result. This follows from the fact that mapG,x:A.IdA \nMx (re.idG , a/x) Q = in (a . out (Q)) I.e. map at this type is post-composition with a (the derivation \nis in the extended version [13]). The computation rule holds because JC (b, re.) := mapC (re.idG , out \n(in re.)/x, in (re.P )/p) b which, by 1-\u00df for Id and the de.nition of re. for G , x:A, is mapC re. b, \nwhich is b by the unit law for map. Conversely, the type-generic operations on equivalence that we have \ntaken as primitive here (map, M [d], re., --1 -.-, a[d]) can be de.ned in traditional Martin-L\u00f6f type \ntheory using the identity type IdA MN in place of the equivalence judgement M A N, as consequences of \nJ . However, many of the equations on these operations hold only as higher-dimensional equivalences, \nrather than as de.nitional equalities, which breaks de.nitional canonicity. A resolution of the conjecture \nthat univalent intensional type theory satis.es canonicity up to equivalence [23] is an important area \nof future work. 5. Related Work Higher-dimensional type theory is based on a type-directed de.\u00adnition \nof equivalence, including extensional equality for functions and universes. The idea of de.ning equality \nin a type directed man\u00adner is central to Martin-L\u00f6f type theory Martin-L\u00f6f [17], especially as presented \nin NuPRL [5]. Relative to NuPRL, the main bene.t of a 2-dimensional theory is that all types respect \ncomputationally\u00adrelevant notions of equivalence, such as isomorphism of sets; this generalizes NuPRL, \nwhere equality is computationally irrelevant. A similar contrast applies to OTT [3]: In OTT, equality \nis a com\u00adputationally irrelevant proposition, so all types are sets OTT is 1-dimensional. In contrast, \n2TT accounts for computationally rel\u00adevant notions of equivalence 2-dimensional structure. For exam\u00adple, \nin OTT, coercing any term by any equality proof gives a result that is equal to the original term. This \nis not true in 2TT, because, for example, not exchanges true and false, which are not equal. Hofmann \nand Streicher [12] give intensional type theory a se\u00admantics in groupoids. 2TT can be seen as an effort \nto read this semantics back into the syntax, enriching the type theory with a number of new equations, \nsuch as the computation rules for map and resp and the type-directed rules for equivalences. They use \nthe groupoid interpretation to justify an axiomatic account of a universe of types modulo isomorphism, \nbut this extension does not seem to enjoy canonicity. Hofmann [10] justi.es various extensional concepts, \nsuch as functional extensionality and quotient types, by a semantics con\u00adstructed in intensional type \ntheory; Altenkirch [2] adapts this con\u00adstruction to coexist better with other type-theoretic features, \nsuch as large eliminations. Canonicity is achieved by de.ning de.nitional equality as equality of denotations. \nHofmann [10] does not take this approach for the groupoid model, because the groupoid model cannot be \nde.ned in intensional type theory without functional ex\u00adtensionality. An alternative to our current work \nwould be to parallel this approach, and de.ne a groupoid interpretation into extensional type theory, \nand thereby inherit equality from the meta-language. The bene.t of the approach we take here is that \nit provides a more direct description of the equational theory, presenting it directly in terms of the \nsource language. Garner [9] studies a two-dimensional theory ML2, and shows it sound and complete for \na class of 2-categories. ML2 introduced the two-dimensional identity types, with re.ection and uip for \nidentity types only, which we adopted in Section 4. It addition\u00adally included some new computation rules \nfor .-types, which in our notation would be written re.M :. x:A. B = . x. re.Mx and (. x.a : M . x:A. \nB N ) re.M0 = a[M0/x]. However, it did not include, e.g., the type-directed rules for map and thus would \nnot enjoy canonicity in the presence of something like univalence. In future work, we may consider identifying \na class of two-categories that is sound and complete for 2TT. Voevodsky s univalence axiom [23] equips \nintensional type the\u00adory with full homotopy equivalence, which includes isomorphism for sets, equivalence \nfor categories, and so on. However, the ax\u00adiomatic account does not satisfy canonicity for de.nitional \nequal\u00adity. Voevodsky conjectures that every closed term of type nat is equivalent (using univalence) \nto one that does not use the univa\u00adlence axiom (and therefore to a numeral, by canonicity for the base \ntheory). However, this conjecture has not yet been proved, and our work suggests an approach to it, as \nwe discuss below. Moreover, Voevodsky conjectures that this numeral can be computed, which is not something \nwe have yet established here. Our presentation here is based on our previous work on 2DTT [14], a 2-dimensional \ndirected type theory, which generalizes equiva\u00adlence to an asymmetric notion of transformation. Our presentation \nhere avoids some of the complexities of 2DTT, like the need to account for variances of type constructors, \nbut on the other hand shows that the presentational style can account for symmetry. The proof of canonicity \nand the derivation of identity types are novel to the present work; we conjecture that our proof of canonicity \ncould be applied to 2DTT as well. In concurrent work, de Queiroz and de Oliveira [6] have also developed \na type theory with a judgemental notion of equivalence, which has explicit evidence with a groupoid structure, \nand which is internalized by the identity type. Their type theory is weaker (in the category-theoretic \nsense), in that every equation is part of equivalence including \u00df.-like rules, which we treat as equalities. \nHowever, there is no account of a higher-dimensional base type, nor a claim of canonicity. A number of \nequations on equivalences are oriented as rewrite rules, which are proved terminating and con.uent, but \nit is unclear what equational theory this decides. Interestingly, FC [21], the calculus used as an intermediate \nlan\u00adguage in the Haskell compiler GHC, has some similarities to 2TT. While there are no higher-dimensional \ntypes in FC , type equali\u00adties are witnessed by explicit coercions, written in programs using a construct \nsimilar to map, and the class of coercions is closed un\u00adder the 2-category operations considered here, \nsuch as re., -.-, --1, and -[-]. Moreover, GHC includes a coercion simpli.cation algorithm, whose purpose \nis to reduce the size of coercion terms, which exploits many of the equations on these 2-category opera\u00adtions. \nAn interesting application of 2TT would be to analyze this coercion simpli.cation algorithm by translating \nits reductions into 2TT equations, which might suggest some additional coercion re\u00adductions, Other related \nwork concerns categorical or homotopy-theoretic semantics of pure intensional type theory. On the homotopy\u00adtheoretic \nside, Awodey and Warren [4], Warren [24] show how to interpret intensional type theory into abstract \nhomotopy theory (i.e. Quillen model categories). Lumsdaine [15] and van den Berg and Garner [22] show \nthat the syntax of intensional type theory forms a weak .-category, and Gambino and Garner [8] shows \nthat identity types admit a weak factorization system. 6. Conclusion We have presented a novel formulation \nof 2-dimensional type the\u00adory, 2TT, based on a judgemental account of higher-dimensional structure. This \njudgemental account rei.es the groupoid structure of types and the functorial actions of families. 2TT \nenjoys a canon\u00adicity property for closed terms of observable type, which we have proved by a logical-relations \nstyle argument in which types are interpreted as groupoids rather than as equivalence relations. The \nidentity type can be de.ned by internalizing this judgemental no\u00adtion of equivalence, and the judgemental \napparatus suf.ces to de\u00adrive its standard elimination rule. One direction for future work is to sharpen \nthe canonicity the\u00adorem to state that \u00b7f M : bool evaluates to true or to false using a deterministic \noperational semantics. The result given here leaves open the possibility that the derivation of M = true \nor M = false proceeds by a non-operational rule, such as the various . princi\u00adples, or an instance of \nequality re.ection. The consistency of the equational theory suggests that such a maneuver cannot be \nessen\u00adtial, and hence only the \u00df-like rules, including those for map and resp, are relevant to canonicity. \nA possible route to this result would be to de.ne the groupoid interpretation in extensional type theory, \nand then prove a Plotkin-style computational adequacy theorem for this interpretation to obtain the sharper \nresult. Another direction for future work is to investigate canonicity for the many possible variations \non 2TT: For example, we may ex\u00adtend 2TT with standard features in current proof assistants, such as inductive \ntypes. Another possible extension is an impredicative universe. A third possibility is to consider directed \ntype theory [14], which has applications to generic programming with abstract syn\u00adtax and directed homotopy \ntheory. More ambitiously, we may con\u00adsider an extension to a fully higher-dimensional univalent depen\u00addent \ntype theory, for which canonicity remains an open problem. By analogy with our judgemental formulation, \nwhich rei.es the groupoid structure of a type, we would present the syntax in such a way that it rei.es \nthe weak .-groupoid structure of a type. How\u00adever, an obstacle to this generalization is the complexity \nof the pro\u00adposed de.nitions of weak .-groupoid and their adaptation to the type-theoretic setting. Acknowledgments \nWe thank Thorsten Altenkirch, Jeremy Avi\u00adgad, Steve Awodey, Caylee Hogg, Chris Kapulkin, Peter Lums\u00addaine, \nGordon Plotkin, Mike Shulman, Kristina Sojakova, and the anonymous reviewers for helpful conversations \nabout this work and feedback on this article. References [1] Homotopy type theory Web site. www.homotopytypetheory.org, \n2011. [2] T. Altenkirch. Extensional equality in intensional type theory. In IEEE Symposium on Logic \nin Computer Science, 1999. [3] T. Altenkirch, C. McBride, and W. Swierstra. Observational equality, \nnow! In Programming Languages meets Program Veri.cation Work\u00adshop, 2007. [4] S. Awodey and M. Warren. \nHomotopy theoretic models of identity types. Mathematical Proceedings of the Cambridge Philosophical \nSociety, 2009. [5] R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F. Cremer, R. W. \nHarper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. F. Smith. Implementing \nMathemat\u00adics with the NuPRL Proof Development System. Prentice Hall, 1986. [6] R. J. G. B. de Queiroz \nand A. G. de Oliveira. Propositional equality, identity types, and direct computational paths. ArXiv \ne-prints, July 2011. [7] P. Dybjer and A. Filinski. Normalization and partial evaluation. In Applied \nSemantics: International Summer School, APPSEM 2000, volume 2395 of Lecture Notes in Computer Science, \npages 137 192. Springer-Verlag, September 2000. [8] N. Gambino and R. Garner. The identity type weak \nfactorisation system. Theoretical Computer Science, 409(3):94 109, 2008. [9] R. Garner. Two-dimensional \nmodels of type theory. Mathematical. Structures in Computer Science, 19(4):687 736, 2009.  [10] M. Hofmann. \nExtensional Concepts in Intensional Type Theory. PhD thesis, University of Edinburgh, 1995. [11] M. Hofmann. \nSyntax and semantics of dependent types. In Semantics and Logics of Computation, pages 79 130. Cambridge \nUniversity Press, 1997. [12] M. Hofmann and T. Streicher. The groupoid interpretation of type theory. \nIn Twenty-.ve years of constructive type theory. Oxford Uni\u00adversity Press, 1998. [13] D. R. Licata and \nR. Haprer. Canonicity for 2-dimensional type theory (extended version). Technical Report CMU-CS-11-143, \nCarnegie Mellon University, 2011. [14] D. R. Licata and R. Harper. 2-dimensional directed type theory. \nIn Mathematical Foundations of Programming Semantics (MFPS), 2011. [15] P. L. Lumsdaine. Weak .-categories \nfrom intensional type theory. In International Conference on Typed Lambda Calculi and Applications, 2009. \n[16] P. Martin-L\u00f6f. An intuitionistic theory of types: Predicative part. In H. Rose and J. Shepherdson, \neditors, Logic Colloquium 73, Proceed\u00adings of the Logic Colloquium, volume 80 of Studies in Logic and \nthe Foundations of Mathematics, pages 73 118. Elsevier, 1975. [17] P. Martin-L\u00f6f. Constructive mathematics \nand computer programming. Philosophical Transactions of the Royal Society of London. Series A, Mathematical \nand Physical Sciences, 312(1522):501 518, 1984. [18] B. Nordstr\u00f6m, K. Peterson, and J. Smith. Programming \nin Martin\u00adL\u00f6f s Type Theory, an Introduction. Clarendon Press, 1990. [19] C. Paulin-Mohring. Extraction \nde programmes dans le Calcul des Constructions. PhD thesis, Universit\u00e9 Paris 7, 1989. [20] A. M. Pitts. \nCategorical logic. In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, Handbook of Logic in \nComputer Science, Volume 5. Algebraic and Logical Structures, chapter 2, pages 39 128. Oxford University \nPress, 2000. [21] M. Sulzmann, M. M. T. Chakravarty, S. P. Jones, and K. Don\u00adnell. System f with type \nequality coercions. In ACM Workshop on Types in Language Design and Implementaion, 2007. Appendix at \nhttp://research.microsoft.com/ simonpj/papers/ext-f/. [22] B. van den Berg and R. Garner. Types are weak \n.-groupoids. Available from http://www.dpmms.cam.ac.uk/ rhgg2/Typesom/Typesom.html, 2010. [23] V. Voevodsky. \nUnivalent foundations of mathematics. Invited talk at WoLLIC 2011 18th Workshop on Logic, Language, Information \nand Computation, 2011. [24] M. A. Warren. Homotopy theoretic aspects of constructive type theory. PhD \nthesis, Carnegie Mellon University, 2008.  \n\t\t\t", "proc_id": "2103656", "abstract": "<p>Higher-dimensional dependent type theory enriches conventional one-dimensional dependent type theory with additional structure expressing equivalence of elements of a type. This structure may be employed in a variety of ways to capture rather coarse identifications of elements, such as a universe of sets considered modulo isomorphism. Equivalence must be respected by all families of types and terms, as witnessed computationally by a type-generic program. Higher-dimensional type theory has applications to code reuse for dependently typed programming, and to the formalization of mathematics. In this paper, we develop a novel judgemental formulation of a two-dimensional type theory, which enjoys a canonicity property: a closed term of boolean type is definitionally equal to true or false. Canonicity is a necessary condition for a computational interpretation of type theory as a programming language, and does not hold for existing axiomatic presentations of higher-dimensional type theory. The method of proof is a generalization of the NuPRL semantics, interpreting types as syntactic groupoids rather than equivalence relations.</p>", "authors": [{"name": "Daniel R. Licata", "author_profile_id": "81100639330", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2991416", "email_address": "drl@cs.cmu.edu", "orcid_id": ""}, {"name": "Robert Harper", "author_profile_id": "81100140064", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2991417", "email_address": "rwh@cs.cmu.edu", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103697", "year": "2012", "article_id": "2103697", "conference": "POPL", "title": "Canonicity for 2-dimensional type theory", "url": "http://dl.acm.org/citation.cfm?id=2103697"}