{"article_publication_date": "01-25-2012", "fulltext": "\n Towards Nominal Computation Mikolaj Boja\u00b4nczyk * Laurent Braud Bartek Klin Slawomir Lasota University \nofWarsaw {bojan,klin,sl}@mimuw.edu.pl, laurent.braud@labri.fr Abstract Nominal sets are a different \nkind of set theory, with a more relaxed notion of .niteness. Theyoffer an elegant formalism for describing \n.-terms modulo a-conversion, or automata on data words. This paper is an attempt at de.ning computation \nin nominal sets.We presenta rudimentary programming language, calledN.. The key idea is that it includes \na native type for .nite sets in the nominal sense. To illustrate the power of our language, we write \nshort programs that process automata on data words. Categories and Subject Descriptors D.3.3 [Programming \nLan\u00adguages]: Language Constructs and Features; F.3.2 [Logic and Meanings of Programs]: Semantics of Programming \nLanguages GeneralTerms Theory Keywords .-calculus, nominal sets, automata on data words 1. Introduction \nThe theory of nominal sets originates from the work of Fraenkel in 1922, further developed by Mostowski \nin the 1930s. At that time, nominal sets were used to prove independence of the axiom of choice and other \naxioms. In Computer Science, they have been rediscovered by Gabbay and Pitts in [11], as an elegant formalism \nfor modeling name binding. Since then, nominal sets have become a lively topic in semantics. They were \nalso independently redis\u00adcovered by the concurrency community, as a basis for syntax-free models of name-passing \nprocess calculi, see [14, 16]; and used in automata theory as a framework for describing automata on \ndata words, see [3]. From the point of view of this paper, the most appealing feature of nominal sets \nis that their natural notion of .niteness, called orbit\u00ad.niteness, is more relaxed than in classical \nset theory.For instance, in one variant of nominal sets (the notion of variant is formalized * Partially \nsupported by ERC Starting Grant Sosna. Partially supported by the ESF Games for Design andVeri.cation \nex\u00adchange grant nr 3070, and by the FET grant FOX, number FP7-ICT-233599. Partially supported by the \nPolish Ministry of Science grant nr N N206 567840. Permission to make digital or hard copies of all or \npart of this work for personal or classroomuseisgrantedwithout feeprovidedthat copies arenot madeordistributed \nforpro.torcommercialadvantage andthatcopiesbearthisnoticeandthefullcitation onthe .rstpage.To copy otherwise,to \nrepublish,topostonserversorto redistribute tolists, requirespriorspeci.cpermission and/ora fee. POPL \n12, January25 27,2012, Philadelphia,PA,USA. Copyright c . 2012ACM978-1-4503-1083-3/12/01. . .$10.00 later \nin the paper as a data symmetry), the set of rational numbers is orbit-.nite. Using orbit-.niteness, \none can de.ne morepowerfulvariantsof automata or other computing devices. As an example, take the stan\u00addard \nde.nition of a nondeterministic .nite automaton: it consists of .nite sets Qand Afor the states and alphabet, \nas well as three rela\u00adtions d . Q\u00d7A\u00d7Qand I,F . Q. Suppose that we read this def\u00adinition using orbit-.nite \nsets instead. As proved in [3], the resulting objects have the same expressive power as well-known automata \nfor data words, namely Finite Memory Automata of Francez and Kaminski [10]. The same idea can be applied \nto other computation models such as monoids [2], deterministic automata [3], two-way automata, pebble \nautomata, or pushdown automata. Each time, the nominal model corresponds to a natural device for data \nwords. The examples above concerned restricted machine models, with the most expressive being pushdown \nautomata. In this paper, we are interested in general nominal computation, and we attempt to understanditby \nde.ninga basic programming language calledN., designed so that it can directly process orbit-.nite nominal \nsets. Thekeyideais thatit includesa native type Fna, which represents orbit-.nite sets of elements of \ntype a. Structure of the paper. The paper has three parts. In Part I, we discuss our design objectives \nand related work, and show some example problems that our language can help solve. In Part II, we de.ne \nthe syntax and operational semantics ofN.. The language is parametrized by a data symmetry subject to \nsome conditions. We also show how to represent programs of N. so that they can be interpreted on a normal \nmachine. Finally, in Part III, we present a substantial case study: the emptiness problem for alternating \nautomata on data words. Acknowledgment. We are grateful to Andrew Pitts, Dan Ghica, Pawel Urzyczyn and \nthe anonymous referees, whose constructive comments lead to a great improvement of the presentation of \nthis paper.  Part I: Motivation 2. Design objectiveforN.: avoid coding Suppose, informally, that we \nwant to design an algorithm that processes possibly in.nite, but orbit-.nite data structures. As a typical \nexample, let I be the set of nondeterministic .nite automata in the nominal sense. In such an automaton \nall components (states, alphabet, transitions, initial and .nal states) are orbit-.nite, but perhaps \nin.nite in the classical sense. Then consider the function f : I .{.,.} that checks if an automaton accepts \nsome word.  Onewayto compute sucha functionisto encode orbit-.nite sets as .nite data structures (and, \nimplicitly, bit strings). In [3, 16], one can essentially .nd such representations. Applying such a coding \nto the problem domain, one can reduce a nominal computational problem to a classical one. The resulting \nnotion of computability depends on the coding scheme, but the schemes implicit in the literature are \nessentially the same, and the small differences can be correctedbyTuring machines. This approach has \nbeen implicitly used in the literature when giving decidability results for decision problems in nominal \nsets. One example is an algorithm [7] for deciding bisimulation equiva\u00adlence of orbit-.nite transitions \nsystems. Some algorithms for prob\u00adlems from automata theory can be found in [3], including the above \nexample of nondeterministic automata. Another example is the al\u00adgorithm from [2] for deciding if the \nlanguage recognized by a given data monoid is .rst-order de.nable. An advantage of this approach is that \nit does not introduce any new concepts; it just treats nominal sets as syntactic sugar for normal sets. \nIn particular, there is no new Nominal Church-Turing Thesis . The very same thing can be seen as a disadvantage: \nit is a clumsy way of doing computation, and it defeats the purpose of using nominal sets as an attractive \nsyntax. N. is a rudimentary functional programming language that ab\u00adstracts away from the clumsy details. \nThe design goal for N. can be summed up in two words: avoid coding. The abstract semantics of the language \nis de.ned in terms of nominal sets, and does not re\u00adfer to anycoding scheme. In particular, this means \nthat correctness proofs for programs in N. are simpler and more convincing. The language comes with a \nmore concrete semantics which implements a coding, thereforeanyfunctionexpressedinN.is effectively com\u00adputable. \nHowever, the coding has to be done only once, as it is done in this paper. Once it has been implemented \nand proved correct, the programmer can simply use the language without thinking about how nominal objects \nare represented. Related work. A closely related language is Fresh O Caml [17, 18], a functional programming \nlanguage based on nominal sets, aimed at de.ning and manipulating data structures with binding, such \nas .-terms up to a-conversion. It is similar toN.in that both can be seen as typed .-calculi with some \nadditional type and term constructors. However, these extensions are substantially different. Acrucial \ningredient of Fresh O Caml is a binary type construc\u00adtor <<a>>\u00df, whose values, intuitively, are values \nof type \u00df with values of type a (typically basic data values, called names in this context) abstracted \n, or bound. These abstraction types, together withafew other primitives, allowa particularly elegant \ntreatmentof a-conversion and capture-avoiding substitution in data structures. N. does not have abstraction \ntypes; instead, it has a type con\u00adstructor Fn to represent .nitary collections. In Section 15, we show \nthat N. also offers a way to treat binding in data structures, al\u00adbeit in a slightly less direct and \nappealing way than Fresh O Caml. However, binding in data structures is just one of the many things that \nwe can do using our language. Also, our language works not just in standard nominal sets, but also in \nthe more general setting of Fra\u00a8iss\u00b4 e nominal sets [3]. Another difference with Fresh O Caml is that \nthe latter is a fully grown programming language, with a working compiler and extensive documentation. \nOn the other hand, N. is a rudimentary core language, and a work in progress. We have tried to keep the \nprimitives as simple as possible, while still covering a wide range of examples. We make no claim on \nuniversality of the language, and it is likely to evolve. However, it seems that our current version \nof N.is a rather expressive formalism. In Section 4, we survey some functions that can be expressed in \nit. First, however, we formally de.ne nominal sets and related notions. 3. Nominal sets We now recall \nthe basics of nominal sets as studied by Gabbay and Pitts [11]. Then, in Section 3.1, we generalize the \nde.nitions along the lines of [3]. Data values. Fix a countably in.nite set D of data values. In the \nexamples below, we assume D = N, and write 1,2,3 for elements of D. However, no structure of the data \nvalues is used except for equality1. A permutation of D is any bijection D . D. The group of all permutations \nwill be denoted by G. Nominal sets. A right action of G ona set X is a function \u00b7 : X \u00d7 G . X subject \nto the following associativity axioms (we use in.x notation, writing x \u00b7 p instead of \u00b7(x,p)): x \u00b7 (ps)=(x \n\u00b7 p)\u00b7 sx \u00b7 1= x, where psrefers to multiplication in Gand 1is the unit of G, which is the identity function \non D. Every subset of data values C . D de.nes a subgroup of G, GC = {p . G : p|C = idC}. A nominal set \nisa set X equipped with a right action of G, such that for every x . X, there is a .nite set C . D such \nthat x = x \u00b7 p for every p . GC. The set C is then called a support of x. In words, every element of \na nominal set has a .nite support. For example, consider the set of in.nite words over the D. alphabet \nof data values. Under the coordinatewise action (d1,d2,...)\u00b7 p =(p(d1),p(d2),...). every word w is supported \nby the set C of all letters that appear in w. The set D. is not nominal,but the subsetofwords that contain \nonly .nitely many different data values is. Also the smaller set D * of .nite words is nominal. def Orbit-.nite \nsets. The orbit of an element x is the set x \u00b7 G = {x \u00b7 p : p . G}.A nominal set is called orbit-.nite \nif it is a .nite union of orbits, i.e. it has a decomposition n X = i=1 xi \u00b7 G for some x1,...,xn . \nX. For example, the set D is orbit-.nite (with one orbit). The set D2 has two orbits, namely the diagonal \n{(d,d): d . D}and the rest. Nominal subsets. A subset Y of a nominal set X is called a nominal subset \nof X if it has a .nite support as an element of the powerset of X.Formally, a .nite set C . D is a support \nof Y if def Y = Y \u00b7 p = {y\u00b7 p : y . Y} for every p . GC. For example, nominal subsets of D are its .nite \nor co.nite subsets. Example1 For a .xedd . D, the set {(d,e): e . D}is a nominal subset of D2 . Finitary \nsubsets. A nominal subset Y of X is called .nitary if it intersects .nitely many orbits of X. In particular, \nif X is orbit\u00ad.nite (for instance D or D2)then all its nominal subsets are .nitary. As anotherexample,thesetofwordsoflengthatmost7wherethe \ndata value 6appears at least twice is a .nitary subset of D * . Finitary subsets are the foundation of \nour programming lan\u00adguage.We write FnX forthefamilyof .nitary subsetsofa nominal set X. In a nutshell, \nN. is simply typed .-calculus with a type constructor for .nitary subsets. 1We will add structure to \ndata values in Section 3.1.  3.1 Generalized nominal sets The centerpiece example of our paper is an \nalgorithm for deciding emptiness of alternating automata in the nominal world. In its full generality, \nthis example may exploit some nontrivial structure (e.g. an order relation) on the set D. This motivates \nus to work in the framework of generalized nominal sets, introduced in [3]. The idea there was to add \nmore structure to the data values D, such as a total or partial order.For automata, this corresponds \nto moreexpressive tests on input letters. To de.ne generalized nominal sets, one begins with a data symmetry \n(called nominal signature in [3]), i.e., a set D of data values together with a group Gof permutations \nof D. It is important that G need not contain all permutations. Some examples of data symmetries include: \n The classical symmetry, where D is empty, and Gcontains only the empty bijection. This symmetry yields \nclassical sets.  The equality symmetry, where D is a countably in.nite set, and Gcontains all bijections. \nThis symmetry yields nominal sets as studied by Gabbay and Pitts.  The total order symmetry, where D \nis the set of rational num\u00adbers, and G contains all order-preserving bijections of rational numbers. \n Later on we will de.ne further data symmetries. Importantly, all examples in this paper are so-called \nFra\u00a8iss\u00b4e symmetries; this notion follows [3] and will be explained in Section 7. Given a data symmetry \n(D,G), one de.nes (D,G)-nominal sets exactly as in Section 3, except with the group Gand the data values \nD substituted in place of the equality symmetry. Similarly one de.nes the related notions, like nominal \nand .nitary subsets. From now on, the notion of a nominal set will always be parametrized by a data symmetry. \n 3.2 Example: subsets of D2 Wenowshowexamplesof .nitary subsetsinthe total order symme\u00adtry. All examples \ngiven here will be subsets of D2, which is shown in the following picture, with the .rst coordinate on \nthe horizontal axis and the second coordinate on the vertical axis2. The picture also shows the three \norbits of D2 under the action of G: above the diagonal, the diagonal, and below the diagonal. Because \nD2 is orbit-.nite, any nominal subset will be .nitary. Consider a support C = {0.3}. Under the action \nof GC, the set D2 breaks up into thirteen orbits.A subset X . has support C if and only if D2 it is a \nunion of some of these orbits. The partition of D2 into orbits under GC and a subset X are illustrated \nbelow. X = 2The reader might recognize some similarity to the region construction from timed automata. \nConsider now a bigger support than C, say D = {0.3,27.6}. The partition of D2 into orbits under GD is \nmore re.ned (there are thirty one orbits), as GD is a subgroup of GC. In particular, there are more subsets \nwith support D. The partition and an example subset Y are illustrated below. The reader can easily see \nthat as the support grows, so does the number of subsets with the support. Also observe that it does \nnot make sense to count the number of elements in a .nitary set, because the number of elements depends \non the choice of support. Even if we choose the least support when counting the number of elements, there \nis still some room for confusion. Observe that the example set Y has least support D, but it can be decomposed \ninto one orbit under GC and one orbit under GD. 4. N. as an algorithmic toolkit Equipped with the basic \nnotions of nominal sets, we discuss some functions that can be programmed in N.. In all examples except \nSection 4.3, we work with the equality symmetry only. 4.1 Transitive closure of a binary relation. Consider \nthe following binary relation on D R = {(5,2)}.{(2,d): d =5}.D2 . The set R has support {2,5}. The set \nD2 has two orbits, namely the diagonal and the rest. It follows that R, like anynominal subset of D2, \nis a .nitary subset of D2, and therefore can be input and processedby programsofN.. A typical thing one \nmight want to do with a binary relation is compute its transitive closure. In this particular example, \nthe transitive closure is R * = {(c,d): c .{2,5},d 5}. = Note that R * is a .nitary subset of D2;one \ncan prove that this holds whenever R is .nitary. Also, we may write a recursive program in N. that inputs \na .nitary binary relation R over some type a and outputs its transitive closure. In our example the type \na is D, but the program works also for types that are not orbit-.nite, such as lists of D. The only condition \nis that ais an equality type, admitting an equality predicate eqa.  4.2 Data monoids. A data monoid, \nas de.ned in [2], is a monoid where the carrier is a nominal set, and the monoid operation is equivariant. \nThe main result of [2] was a theorem that related .rst-order logic with aperiodic data monoids. However, \nnowhere in the paper was it said how one can represent a data monoid in a computer, or test if it is \naperiodic.N.can help with this. For example, consider the data monoid M where the carrier is {o}.D2 , \nthe identity is o, and the monoid operation is de.ned by o\u00b7 m = m \u00b7 o = m for all m . M and '' ' (d,e)\u00b7 \n(d,e )=(d,e ) for all d,e,d ' ,e ' . D This is the syntactic monoid of the language {d1 \u00b7\u00b7\u00b7 dn . D+ : \nd1 = dn}.  The carrier of this monoid can be seen as the .nitary subset of D list that contains lists \nof sizes zero or two. This set can be represented in N. by a short piece of code. The identity of the \nmonoid M is the empty list, while the monoid operation can be easily implemented, using pattern matching, \nas a function f : D list \u00d7 D list . D list. (As far as the example monoid is concerned, it is not important \nwhat f does for lists of lengths other than zero or two.) UsingN.we can test some properties of monoids \nrepresented in thisfashion.For instance, we can writea polymorphic function that inputs a .nitary set \nM of values of type a and a binary operation f on a, and checks whether f is idempotent when restricted \nto M (in our example, a = D list). In the same spirit, we can write functions that test if a data monoid \nis aperiodic, commutative, etc.  4.3 Alternating automata with one register In the literature on data \nwords, there are many automata models, often of incomparable expressive power. One of the maximally expressive \nautomaton models that still has decidable emptiness is an alternating automaton with one register.Roughly \nspeaking, this is an alternating automaton which can store a single data value in a register. Emptiness \nis decidable for this automaton model, with a proof based on well quasi-orders [6]. In Part III of this \npaper, we encode the emptiness test for alter\u00adnating automata with one register intoN..To do this, we \nprovide an abstract de.nitionof alternating automata with one register,a de.\u00adnition that only uses the \nconcepts of nominal sets. Then we write a program inN.which tests a given automaton for emptiness. An \nimportant advantage of our abstract de.nition of automata is that it is meaningful for any data symmetry. \nIf the de.nition is interpreted in the equality symmetry (the usual symmetry for nominal sets), the resulting \nmodel is equivalent to the automata from [6, 10]. However, the de.nition can also be interpreted in the \nclassical symmetry, in which case we get standard alternating automata without data values [4, 5]. Finally, \nthe de.nition can also be interpreted in the total order symmetry, in which case we get alternating automata \non ordered data values, a model that has been studied in [8] and closely related to one-clock timed automata \n[12, 13, 15]. In all these cases (equality, classical, total order), the same program inN.decides emptiness \nfor alternating automata with one register; the program only needs to be fed into different interpreters \n(each symmetry de.nes a different interpreter). The proof that the emptiness-testing program terminates \nde\u00adpends on the chosen data symmetry. We give an example where the termination proof fails, and indeed \nthe emptiness problem is undecidable. 4.4 Terms of.-calculus modulo a-conversion. Nominal sets were \noriginally motivated [11] as an elegant alge\u00adbraic approach to name binding in syntax, and in particular \nas a way to represent .-terms up to a-conversion in a way that admits natural inductive reasoning, using \nthe so-called abstraction types that have a-equivalence classes of terms as values. This idea has been \nimplemented in the nominal programming language Fresh O Caml [17, 18]. Although N. does not have abstraction \ntypes, one may repre\u00adsent in it a-equivalence classes of .-terms directly, as .nitary sets of terms. \nSuch a representation is less appealing than the one used in Fresh O Caml, as it contains many values \nthat do not correspond to a-equivalence classes. However, it still lets us write functions that manipulate \nterms (such as capture-avoiding substitution). We can also writeaN. program that tests whether a set \nof terms is an a-equivalence class. We elaborate a little on this example in Section 15.   Part II:N. \n In this part of the paper we introduce N., a rudimentary language for programming in nominal sets over \nan arbitrary data symmetry of a certain form. The essential idea is to extend simply typed .\u00adcalculus \nwith a collection type that represents .nitary sets of values. We presentN. in three stages. First, in \nSection 5, we present a version for the classical symmetry, where no data values or group actions are \ninvolved. This is to accustom the reader to our syntax inafamiliar setting. Notably, to store intermediate \nvalues duringa computation according to our operational semantics, we introduce a syntactic construct \nthat collects a .nite set of terms. In a practical implementation, these sets would be represented as \nlists of terms. Then, after some semantic considerations in Sections 6-7, we generalize the language \nto arbitrary data symmetries in Sections 8\u00ad 9. The main conceptual difference, apart from a few new primi\u00adtives, \nis that now .nitary,but potentially in.nite,families of terms are considered in intermediate values. \nThis may be seen as prob\u00adlematic, and indeed one may wonder if our semantics is really op\u00aderational , \ngiven that it directly manipulates in.nite structures. Therefore, in Section 10, we replace in.nite collections \nof terms with a .nitary syntactic construct, in a step analogous to replacing .nite sets of terms with \nlists. The result is an entirely .nitely pre\u00adsentable language, with a clearly computable reduction semantics, \namenable to direct implementation. The semantics of Sections 8 and 10 are equivalent (formally, bisimilar). \nThe latter may be seen as a reference de.nition for implementation purposes. The former is more abstract, \nbetter suited for reasoning, and more closely related to the simple language of Section 5. 5. Asimply \ntyped calculus with .nite subsets In this section, we show how N. works in the classical symmetry, where \nnominal sets are simply sets, and where orbit-.nite sets are simply .nite sets. The core language is \npresented in Fig. 1. The types are as in a simply typed .-calculus (where b comes from some set of base \ntypes), extended with a type constructor F to represent .nite collections. The idea is that 1 represents \na singleton set, and Fa represents .nite sets of elements from a. In terms, c comes from some set of \nterm constants with .xed types. In particular, we assume (polymorphic families of) special constants; \nnote that F1 takes the role of a boolean type. The typing rules of basic terms are standard and omitted \nfrom Fig. 1. To simplify the operational semantics, we extend the language with an additional construct \nset(X) of a more semantic .avor, with an intuitive typing rule. With these as intermediate values, the \nreduction relation .\u00df on closed terms is de.ned as expected. We do not commit to any particular evaluation \nstrategy, admitting reduction of arbitrary subterms. We refrain from showing a formal denotational semantics \nfor the language,but our intention shouldbe clear: types are interpreted as sets, with 1 as a singleton \ntype, .as function space, and F as the .nite powerset monad, with the obvious interpretation of constants \nfrom Fig 1. We may now de.ne other typical constants (operations), such as the Haskell bind (written \nin.x as usual): >>= : Fa . (a . F\u00df). F\u00df a >>= f = sum(map f a), singleton and set union: just : a . Fa \njust a = add \u00d8 a union : Fa . Fa . Fa union a b = a >>= (add b).  Types: a ::= b |1 |a . a |Fa Basic \nterms: M ::= c |x |.x.M |MM Intermediate terms: (X ranges over .nite sets of terms) G . M : a for all \nM . X M ::= \u00b7 \u00b7 \u00b7 |set(X) G . set(X): Fa Special constants: * : 1 \u00d8 : Fa add : Fa . a . Fa map :(a . \n\u00df). Fa . F\u00df sum : FFa . Fa if : F1 . a . a . a Redexes: (.x.M )N .\u00df M[N/x] \u00d8 .\u00df set(\u00d8) add set(X)M .\u00df \nset(X .{M}) map M set(X).\u00df set({MN |N . X})  sum set({set(Xi)|i . I}).\u00df set( i.I Xi) if set(X)MN .\u00df \nM if X = \u00d8 if set(\u00d8)MN .\u00df N Set reduction: M . XM .\u00df N set(X).\u00df set(X \\{M}.{N}) Figure 1. N.without \ndata Writing bool instead of F1 we de.ne boolean constants and oper\u00ad ations: true : bool false : bool \nor : bool . bool . bool not : bool . bool true false or not a = = = = just * \u00d8 union if a false true, \nquanti.ers and predicate .ltering: exists, forall : Fa . (a . bool). bool filter : Fa . (a . bool). \nFa exists = >>= forall X f = not(exists X .x.not(fx)) filter X f = X >>= .x.if (fx)(just x)\u00d8. If a type \nacomes equipped with an equality predicate: eqa : a . a . bool we may lift it to an equality predicate \nfor Fa by de.ning member\u00adship and subset predicates: member : Fa . a . bool subset : Fa . Fa . bool member \nX x = exists X (eqa x) subset X Y = forall X (member Y) Finally, equality eqFa is de.ned as subset in \nboth directions. This core language can be routinely extended with further stan\u00addard features, e.g. product \ntypes: a ::= \u00b7 \u00b7\u00b7 |a\u00d7 aM ::= \u00b7 \u00b7 \u00b7 |(M,M)|p1M |p2M p1(M,N).\u00df Mp2(M,N).\u00df N Then one can write programs \nsuch as binary relation composition comp, using an auxiliary function comp0: comp0 :(a\u00d7 \u00df). (\u00df \u00d7 .). \nF(a\u00d7 .) comp : F(a\u00d7 \u00df). F(\u00df \u00d7 .). F(a\u00d7 .) comp0 p q = if (eq\u00df(p2p)(p1q)) just(p1p,p2q) \u00d8 comp RS = R \n>>= .p.(S >>= comp0 p) where \u00df is assumed to be an equality type. Similarly we could add recursive types \nsuch as lists (that we used in Section 4.2), etc. Note that in a typical programming language .nite collections \nare modeled by lists. In presence of recursive types, one could view the constants \u00d8 and add as constructors \nand de.ne other operations by pattern matching and recursion; with this in mind, our set() construct \nmight look like an unnecessary complication. However, intheworldof nominalsetsthesimplelist representationfails,and \n.nding a good representation of .nitary subsets of nominal sets is one of the technical challenges we \nshallface. Our semantic term construct set()is introduced in anticipation of a world where it is easier \nto say what a .nitary collection is than how to write it down. 6. Nominal types: semantic considerations \nWe now wish to extend the calculus of Section 5 to deal with nominal sets for a data symmetry (D,G). \nThe general idea is clear: given (D,G), we interpret types as nominal sets. Function type. Categories \nof nominal sets are Cartesian closed, and it is natural to interpret function types as nominal function \nspaces. There, for nominal sets X and Y, the action of G on a function f : X . Y is de.ned by (f \u00b7 p)(x)=(f(x \n\u00b7 p-1 )) \u00b7 p. The nominal function space X .fs Y is the set of functions from X to Y, equipped with the \naction above, restricted to those functions that have .nite support; we call such functions nominal. \nNote that not all nominal functions are equivariant [11]; in fact, a function is equivariant if and only \nif it has empty support. Write f : X .fs Y to say that f : X . Y is nominal. Example2 Consider the equality \nsymmetry. A function f : D . D is nominal if and only if there is a co.nite set Z . D such that f|Z is \neither the identity or a constant function. Collection type. It remains to interpret the collection type \ncon\u00adstructor in the nominal world. This will be of use already in the de.nition of syntax: we intend \nto view .nitary nominal collections of terms as terms, so we need to de.ne what they are. The powerset \nof a nominal set X is easy to de.ne: P(X)= X .fs 2 where 2 is a two-element set with a trivial G-action. \nEquivalently, P(X)is the set of subsets Y . X with an action de.ned by Y \u00b7 p = {y\u00b7 p |y . Y} restricted \nto those subsets that have .nite support; these are the nominal subsets as de.ned in Section 3. Example3 \nThe powerset of an orbit-.nite set need not be orbit\u00ad.nite. For instance, for every data symmetry (D,G), \nthe powerset of D contains all .nite subsets of D, because every .nite subset has a .nite support (itself). \nTwo .nite subsets of D cannot be in the same orbit if they have different cardinalities. Therefore, there \nare in.nitely manyorbits in P(D)if D is in.nite.  Observe that a nominal subset Y of a nominal set X \nis nota (D,G)-nominal set in general, as Y need not be preserved by all permutations from G. However, \nif C . D supports Y then Y is a (D,GC)-nominal set. We now introduce our intended nominal interpretation \nof the collection type: the .nitary powerset. Recall from Section 3 that a nominal subset Y . P(X)is \ncalled .nitary if Y intersects .nitely many orbits of X. If C supports Y then Y is .nitary if and only \nif Y is orbit-.nite asa (D,GC)-nominal set. By FnX we denote the set of all .nitary subsets of X. If \nX is orbit-.nite then all nominal subsets are .nitary, i.e. P(X)= FnX. It follows that FnX need not be \norbit-.nite even if X is. Actually, the only case when FnX is orbit-.nite is when X is .nite. Note that \nour FnX is not the free semi-lattice over X;the latter contains only .nite subsets of X. Although we \ndo not yet have a clear categorical understanding of FnX, we choose it for pragmatic reasons: it is a \nrich collection of subsets of X that we are able to represent in a .nite way (see Section 10). 7. Fra\u00a8e \nsymmetries iss\u00b4 From now on we restrict attention to a special case of data symme\u00adtries, called Fra\u00a8iss\u00b4e \nsymmetries, de.ned in [3] (and called Fra\u00a8iss\u00b4e signature there).A Fra\u00a8iss\u00b4e symmetry is induced bya \nclass K of .nite relational structures, which needs to be closed under isomor\u00adphism, substructures and \namalgamation. Given such a class, the construction from [3] uses the Fra\u00a8iss\u00b4e limit [9] to produce a \ndata symmetry (D,G), which is well behaved. All three examples listed in Section 3.1 are Fra\u00a8iss\u00b4e symmetries: \n The classical symmetry arises from the empty class K.  The equality symmetry arises from the class \nKof .nite sets, i.e. .nite structures over the empty vocabulary.  The total order symmetry arises from \nthe class K of all .nite total orders, over a vocabulary with a binary relation.  Other examples include \nthe class K of .nite partial orders or .nite graphs.We will see other Fra\u00a8iss\u00b4 e symmetries in Section \n14. From now on we consider a .xed data symmetry (D,G)and assume that it satis.es the following conditions: \n Fra\u00a8iss\u00b4e symmetry: the symmetry is induced by a class K.  Least supports:anyelement x of a nominal \nset has the least sup\u00adport with respect to inclusion, which we will denote supp(x).  Under these assumptions, \nthe following basic results hold that will be extensively used in the following: Lemma1 D is orbit-.nite \nunder the action of G. Lemma2 Orbit-.nite sets are closed under Cartesian products. Lemma3 (orbitre.nement) \nLet x . X for some nominal set X. For any.nite setsC . Dof data values, there exists a .nite subset {z1,...,zn}.X \nsuch that n x \u00b7 GC = i=1 zi \u00b7 GD. 8. A calculus with .nitary nominal subsets An extension of the language \nof Section 5 to nominal sets over a Fra\u00a8iss\u00b4 e symmetry (D,G), is summarized in Fig. 2. We write supp(X)for \nthe least support of X. Types: a ::= b |1 |a . a |D |Fa |Fna Basic terms: as in Fig. 1, Intermediate \nterms: asin Fig.1,but X ranges over .nitary sets in set(X): Fna Special constants: to Fig. 1, add: d \n: D (for each d . D) eq: D . D . bool hull : FD . a . Fna D Fn Redexes: to Fig. 1, add: eqD dd .\u00df set({*}) \neqD de .\u00df set(\u00d8)(if d = e)  hull set(C)set(X).\u00df set( x.X x \u00b7 GC)(C ..n D) Set reduction: M . XM .\u00df N \nsupp(X)= C set(X).\u00df set(X \\(M \u00b7 GC).(N \u00b7 GC)) Figure 2. N.with data: abstract terms First, a new type \nD of data values is introduced, together with a constant for each data value and an equality predicate \non D. Second, instead of one type constructor F we now have two, written F and Fn. The type Fa represents \nall .nite subsets of a, as in Section 5, while Fna represents all .nitary nominal subsets of a. Both \ntype constructors are equipped with constants listed in Fig. 1, and further operations for Fn (such as \nforall, eqFna etc.) are de.ned as in Section 5 for F. The name clash between constants should not lead \nto confusion and will always be resolved by context. In particular, the are two constructs set(X): Fa \nand set(X): Fna, where in the latter case X ranges over .nitary and not .nite sets of terms (we explain \nbelow how to regard the set of all terms as a nominal set). To avoid confusion, the latter set() construct \nwe call nominal. Finally, the new constant hull can be used to construct .nitary nominal sets, just as \nadd could be used to construct .nite sets in Section 5. It inputs a .nite set C of data values and a \n.nitary set X, and closes X under the action of GC. For instance in the equality symmetry, the following \npiece of code hull \u00d8 {2} represents the whole set D, and the following two calls: hull \u00d8 {(2,2)} hull \n\u00d8 {(2,3)} create the two orbits of D2. The relation Rfrom Section 4.1 can be generated by R = hull {2,5}{(5,2), \n(2,2), (2,3)}. (We use some syntactic sugar here; for example, {2,5}would have to be written as add2(add \n5 \u00d8) in our core language.) Terms of N. remain as in Fig. 1, but in the nominal set(X) construct, X ranges \nover .nitary, rather than .nite sets of terms. Herewe must proceedwith caretoavoida circular de.nition \nwhere the existence of a term set(X)depends on all terms understood as a nominal set.Formally, this canbe \ndoneby introducinganexplicit rank to terms, where the rank of a term is the maximal degree of nesting \nof set()in it. Then the group action of Gon terms of rank n is de.ned by induction, and every term of \nrank n has a .nite support. In other words, the set of terms of each rank n is a nominal set and we may \nmeaningfully speak of its .nitary subsets used in the set()construct.  Example4 In the total order symmetry, \nwe have a term that repre\u00adsents the set of all data values bigger than 7: set({d |d> 7}). This term has \nrank 1 and type FnD. We also have a term that represents a set of constant functions: set({.x.d |d> 7}). \nWe couldalso writea termforthe unionofthetwo setsabove,but this would not have a type.We cannot, however, \nwrite a term for all data values that are integers, as Z is not a nominal subset of D: set({i : i . Z})is \nnot a valid term. The \u00df-reduction relation .\u00df is de.ned as in Section 5, with new redexes for eqD and \nhull. Note that for the reduction of hull to happen, C must be fully evaluated to a .nite set of data \nvalue constants. Finally, the set reduction rule given in Fig. 1 is unsatisfactory for the nominal set(X)construct, \nas X may have in.nitely many elements, causing potentially in.nite reductions. We .x this prob\u00adlem by \ninsisting that all elements of X that are in the same orbit of GC (where C is the least support of X)reduce \nin parallel and in a uniformway.In otherwords, the last rulein Fig.1is replaced with the last rule of \nFig. 2. Our semantics satis.es the basic properties expected from a typed .-calculus: Proposition4 The \n\u00df-reduction is well-de.ned, i.e., if M .\u00df N then N is a valid term. In addition, types are preserved \nand so are supports: if C supports M then it also supports N. Proof For the .rst part, we must check \nthat the reduct N only contains .nitary sets of terms under the set()construct. The proof goes by induction \non the structure of terms. In some cases we make use of thefact that in Fra\u00a8iss\u00b4e symmetries, Cartesian \nproducts of orbit\u00ad.nite sets are orbit-.nite. D Proofs of other desirable properties are routine using \nstandard methods: Proposition5 The reduction relation .\u00df has the Church-Rosser property and is weakly \nnormalising. 9. Recursion and examples The treatment of recursion is standard: we extend the language \nwith a new constant fix for anytype a, with the type fix :(a . a). a and the reduction rule fix M .\u00df \nM (fix M). Using this we may de.ne recursive functions, via the following syntactic sugar: def Fx= M \n= fix .F.(.x.M) where F may appear in M. As usual with recursion, one can write nonterminating pro\u00adgrams, \nso weak normalisation fails. However, the Church-Rosser property holds, and types and supports are still \npreserved by .\u00df. We now show some simple examples of recursive programs. Example5 Recall Section 4.1 \nand the problem of computing the transitive closureofa .nitary relation.Wmay writea function trans : \nFn(a\u00d7 a). Fn(a\u00d7 a) that inputs a .nitary binary relation over some equality type aand outputs its transitive \nclosure: step : Fn(a\u00d7 a). Fn(a\u00d7 a) step R = union R (comp R R) trans R = if (eq(step R) R) R (trans(step \nR)) Fn (a\u00d7a) where union and comp calculate the union and composition of given relations, as de.ned in \nSection 5. Example6 Recall Section 4.2 and the problem of checking prop\u00aderties of monoids. Carriers of \ndata monoids can be represented in N. as .nitary subsets of some equality type a, with the monoid structure \ngiven by an element of a (the unit) and a function of the type a\u00d7 a . a(the multiplication). Assuming \nthe presence of list types, the carrier of the monoid of Section 4.2 can be represented by taking a = \nD list and (again, with some syntactic sugar): M = hull \u00d8 {[],[1,1],[1,2]}, and the monoid operation \nf : D list \u00d7 D list . D list. is easily de.ned by pattern matching. Suppose that we want to know if a \nmonoid is idempotent. This can be accomplished by a polymorphic function idempotent : Fn a . (a\u00d7 a . \na). bool which inputs a set of arguments and a binary operation on any equality type a. The code of the \nfunction is: idempotent M f = forall M (.x.eqa (fx x)x). If we execute the idempotent function on our \nexample monoid, the expression: idempotent M f will evaluate to true in .nite time. The above two examples \ndo not involve data values directly, and the polymorphic programs trans and idempotent could be just \nas well interpreted in the simple language of Section 5. The next example uses data explicitly. Example7 \nOne could wonder why there is no primitive in the language that returns a support of a given argument. \nSomewhat surprisingly, with primitives listed so far we can de.ne a function that computes the least \nsupport for equality types. The function will simply exhaustively enumerate all candidates (in.nitely \nmany of them!).We stress,however, that this search canbe implementedby a .nite computation, as we explain \nin Section 10. We start by writing a function supports : a . FD . bool that checks if an element x of \nan equality type a is supported by a .nite set of data values C. It returns true if the orbit of x with \nrespect to GC is a singleton: supports x C = singleton (hull C (just x)) singleton X = exists X .x.(forall \nX (eqa x)) Having the function supports we de.ne supp : a . FnFD search : a . FnFD . FnFD. The result \ntype of supp is FnFD and not just FD, but the function will always return just a single support. It is \nimplemented by an exhaustive search:  supp x = search x (just \u00d8) search x X = if (exists X (supports \nx)) (filter X (supports x)) (search x (enlarge X)) The search starts with the family X containing \njust one set of data values: the empty one. If this set is not a support, in the .rst recursive call \nthe family X contains all singletons. In general, at recursive depth n, X contains all nonempty subsets \nof data of cardinality at most n. An auxiliary function enlarge : FnFD . FnFD increases this cardinality \nbound by one: enlarge X = X >>= .x.(D >>= .d.just(add x d)) Observe that the search surely terminates, \nas every element of type a has a .nite support, and always computes the least support with respect to \ninclusion. Finally note that we allow ourselves to use the set of data values D as an object of type \nFnD, since D can be easily represented as discussed in Section 8. 10. Term representation The language \nde.ned so far is a bit abstract in that is uses a semantic construct set()in its terms.For practical \nuse, we need to represent the terms in a .nite way, so that they can be input by users and manipulated \nby algorithms, for example by an interpreter that chooses a speci.c evaluation strategy. Such a representation \nis possible underthe assumptionthatweworkinaFra\u00a8iss\u00b4e symmetry. The cornerstone of our approach is Lemma \n3 from Section 7, which provides a .nite representation of .nitary subsets: Lemma6 For every .nitary \nsubset Y of X there are elements y1,...,yk and a .nite set D . D such that k Y = i=1 yi \u00b7 GD. Proof Take \nas D any support of Y, and as x1 ,...xk any representatives of those G-orbits of X that are intersected \nby Y. Apply Lemma 3 to each xi with C = \u00d8;take the union of the results and choose as yi those z s that \nare elements of Y. D Note that the representation is not unique. Consider, for in\u00adstance, the total order \nsymmetry, where D is the rational numbers. Let Y be the .nitary subset of D that contains data values \nin the open interval (1;7). Here are some representations of Y: 2\u00b7 G{1,7};6\u00b7 G{1,7};2\u00b7G{1,3,7} .3\u00b7G{1,3,7} \n.6\u00b7 G{1,3,7}. As the last one suggests, one can make the set D of data values grow, which entails a growing \nset of representatives {y1,...,yk}. Thanks to Lemma 6, for a .nitely presented language we may replace \nthe nominal set()construct from Fig.2 witha construct (M1,...,Mk){d1 ...dn } of .nite arity (cf. Fig. \n3). Intuitively, its purpose is to mimic hull {d1 ...dn}{M1,...,Mk}; we prefer however a separate construct \nfor technical convenience. We shall call terms built with the new construct concrete, as op\u00adposed to \nabstract termsbuilt using the nominal set()construct. To de.ne a reduction relation on concrete terms, \na few notions and results are needed. First, there is an obvious function M . [M]from concrete to abstract \nterms, de.ned by induction with the only nontrivial case: k [(M1,...,Mk)C]= set( \u00b7 GC). i=1[Mi] Types: \nas in Fig. 2. Basic terms: as in Fig. 1-2. Intermediate terms: (C ranges over .nite subsets of D) G \n. Mi : a for i =1..k M ::= \u00b7 \u00b7 \u00b7 |(M1 ,...,Mk)C G .(M1 ,...,Mk)C : Fna Special constants: as in Fig. \n2. Redexes: (.x.M )N . M[N/x] \u00d8 . ()\u00d8 fix M . M (fix M) \u00df \u00df\u00df D = supp([M]) (K1,...,Kn)= refC.D((M1,...,Mk)C) \nadd (M1,...,Mk)C M .\u00df (M,K1,...,Kn)C.D D = supp([M]) (K1,...,Kn)= refC.D((M1,...,Mk)C) map M (M1,...,Mk)C \n.\u00df (MK1,. . .,MKn)C.D Mi = (Mi1,...,Mini)Ci for i =1...k E = C1 .\u00b7\u00b7\u00b7 .Ck (Ki1,...,Kili)= refE((Mi1,...,Mini)Ci \n)for i =1...k sum(M1,...,Mk)C .\u00df (K11,...,K1l1 ,...,Kk1,...,Kklk )E if (M1,...,Mk)C MN .\u00df M if ()C MN \n.\u00df N (K1,...,Kn)= refC.D((M1,...,Mk)C) hull set(D)(M1,...,Mk)C .\u00df (K1,...,Kn)C.D Set reduction: (N1,...,Nn)D \nis a short form of (M1,...,Mk)C Ni .\u00df K (M1,...,Mk)C .\u00df (N1,...,Ni-1,K,Ni+1,...,Nn)D , Figure 3. N.with \ndata: concrete terms Lemma 6 implies that the mapping M . [M]is surjective (al\u00adthough, as we explained \nabove, not injective). It also obviously pre\u00adserves types. Lemma7 The following operations can be computed: \n1. Given concrete terms M,N, decide if [M]=[N]; 2. Given a concrete term M, .nd supp([M]); 3. Given \nconcrete terms M,N, and a .nite set C of data values, decide if [M]\u00b7 GC =[N]\u00b7 GC.  Proof By simultaneous \ninduction on the size of terms. D The followingisa computationalversionofthe orbit re.nement lemma (Lemma \n3): Lemma8 Given concrete terms M1 ,...,Mk and C . E, one can compute concrete terms K1,...,Kn such that \n[(M1,...,Mk)C]=[(K1,...,Kn)E]. We then denote refE((M1,...,Mk)C)= (K1 ,...,Kn). We may now formulate \nreduction rules for basic redexes of the languageasinFig.3.For instance,to reducea concrete term add \n(M1,...,Mk)C M, one .rst computes the least support of M using Lemma 7(2), then uses Lemma8to re.ne (M1,...,Mk)C, \nand .nally adds M to the resulting list of terms. Other redexes are similar.  For the set reduction \nrule, it is tempting to write simply: Mi .\u00df N . (M1,...,Mn)C .\u00df (M1,...,Mi-1,N,Mi+1,...,Mn)C However, \nthis leads into problems: note that if [M1] \u00b7 GC = [M2]\u00b7 GC then [(M1,M2)C]=[(M1)C],but the above rule \nmay let (M1,M2 )C and (M1)C reduce differently. To avoid this, we convert concrete terms to a canonical \nform before they can reduce. Speci.cally, we say that a concrete term M = (M1,...,Mk)C is in short form \nif: C = supp([M]), and  [Mi]\u00b7 GC =[Mj]\u00b7 GC for i = j.  An arbitrary concrete term is in short form \nif all its subterms (M1 ,...,Mk)C are in short form. Lemma9 For each concrete term M, a concrete term \nN in short form such that [M]=[N]exists and can be computed.(N is then called a short form of M). Proof \nBy induction on M, using Lemma 7. D 3. Apartition of states Q= Q. .Q. into two nominal subsets. 4. Atransition \nfunction, that is a nominal function  d : Q\u00d7 A .fs FQ. 5. An initial state qI . Q. 6. The .nal states \nF, a nominal subset of Q.  An alternating automaton is used to accept or reject a word w . A * . The \nsemantics is de.ned as follows. A con.guration of the automaton is a .nite set of states. We write X,Y,Z \nfor con.gurations. The initial con.guration is {qI}.A con.guration is called .nal if it is a subset of \nF. We now de.ne a one step transition relation which says how to go from one con.guration to another \nby reading an input letter. Suppose that X,Y are con.gurations and a . A is an input letter. a Then we \nwrite X Y if the following hold for every q . X: If q . Q., then Y contains some state from d(q,a). \n If q . Q., then Y contains all states from d(q,a).  We say the automaton accepts an input word a1 \n\u00b7\u00b7\u00b7 an . A * if there are con.gurations X0,...,Xn such that X0 is the initial con.guration, Xn is .nal, \nand Using short forms, the set reduction rule is de.ned as in Fig. 3. a X0 X1 All these complications \nare rewarded by a close correspondence of reduction semantics of concrete and abstract terms: Proposition \n10 The reduction .\u00df is bisimilar to .\u00df, i.e.: if M .\u00df N then [M].\u00df [N], and  if [M] .\u00df K then there \nexists a concrete term N such that M .\u00df N and K =[N].  Proof By structural induction on concrete terms. \nD  Part III: Case studies In this part, we demonstrate the potential ofN.as a basis of an expressive \nprogramming language. So far we have ignored many useful features typically found in functional languages, \nsuch as recursive datatypes (e.g. lists) and pattern matching, the let construct etc.We believe that \nadding this kind of features to N. is an issue orthogonal to our concerns and may be done along standard \nlines. In the examples to follow we feel free to use recursive types and let as if they were in the language. \n11. Alternating automata As a non-trivial example of nominal programming, in the remain\u00ading sections \nwe consider the emptiness problem for alternating au\u00adtomata. We deliberately choose a borderline problem: \nit is decid\u00adable only under some restrictions on the state space of the automa\u00adton, and only for certain \ndata symmetries. Moreover, even in known decidable cases the problem is extremely complex (non-primitive \nrecursive, except for the classical symmetry, where it is PSPACE\u00adcomplete). De.nition of alternating \nautomaton Given a data symmetry (D,G), an alternating automaton is given by: 1. An input alphabet A, \nan orbit-.nite nominal set. 2. A set of states Q, an orbit-.nite nominal set.  aaan Xn. 3tomatonthatrecognizesthelanguage \n2 1 X2 \u00b7\u00b7\u00b7 a We say X can reach Y in one step if X Y holds for some a . A, and we write this X Y. We \ndenote the re.exive transitive closure of by *. When X * Y holds, we say that X can reach Y. The automaton \naccepts some word if and only if the initial con.guration can reach some .nal con.guration. From now \non, we are interested in the emptiness problem: given an alternating automaton, decide if it accepts \nsome word. Example8 Consider the equality symmetry. We construct an au\u00ad {d1 \u00b7\u00b7\u00b7 dn : n . N and di = dj \nfor all i = j}. The state space is Q= D .{.,.}, where the states .and .are in their own orbits. The initial \nstate is ., and all states except .are .nal. All states belong to Q. and Q. is empty. The automaton scans \nthe word in state ., and every time it sees a data value d, it spawns a new thread with state d. This \ncorresponds to the transition d(.,d)= {.,d} for d . D. When a thread with state d sees a letter e, then \nit ignores it and keeps on scanning the word if e = d, otherwise it enters the error state, because dhas \nappeared twice: {d} if d = e d(d,e)=for d,e . D {.} otherwise Finally, it is impossible to recover from \nthe error: d(.,d)= {.} for d . D. One-dimensional alternating automata Let k . N. A nominal set is called \nk-dimensional if every element is supported by a set C . D of cardinality k. Clearly, an orbit-.nite \nset is k-dimensional iff each of its orbits is so. Example9 Up to isomorphism, there is only one zero-dimensional \none-orbit set. Examples of one-dimensional sets are D and the set {d}\u00d7 D for any d . D (with the action \nof G not changing the .rst coordinate). Examples of two-dimensional sets are D2 or the (1)  set of all \ntwo-element subsets of D. Every k-dimensional set is also l-dimensional for l>k. In most data symmetries, \nwith the exception of the classical symmetry, the set D2 is not one-dimensional. An alternating automaton \nis k-dimensional if its state space is (the alphabet is not taken into account). For instance, the automaton \nin Example8is one-dimensional. From now on we consider only one\u00addimensional automata. Fact 11 A single-orbit \nset is k-dimensional if and only if it is an image, under some equivariant function, of an orbit of the \nset Dk . Our de.nition of alternating automaton can be instantiated to various data symmetries. In the \nclassical symmetry, the notion of dimension is irrelevant, since every nominal set is already zero-dimensional. \nWhen in\u00adstantiated to the classical symmetry, our de.nition is equivalent to ordinary alternating automata. \n When instantiated to the equality symmetry, our k-dimensional alternating automata are equivalent to \nalternating k-register au\u00adtomata of Demri and Lazi \u00b4 c [6]. Emptiness is known to be unde\u00adcidable for \nk = 2, and decidable for k =1. In the latter case, the complexity of the problem is very high: it is \nnot bounded by anyprimitive recursive function [1, 12].  When instantiated to the total order symmetry, \nk-dimensional alternating automata are equivalent to the model of k-register automata studied by Figueira, \nHofman and Lasota in [8]. These automata are very closely related (some details have to be adjusted) \nto alternating k-clock timed automata. Emptiness of those is known to be undecidable for k = 2, and decidable \nfor k =1 (with a similar lower complexity bound as above). The decidability result was obtained independently \nby Lasota and Walukiewicz [12, 13], as well as Ouaknine andWorrell [15].  In the remaining sections \nwe will prove the following result: Theorem 12 There exists a single program in N., which decides emptiness \nof alternating one-dimensional automata for: the classical symmetry,  the equality symmetry, and  \nthe total order symmetry.  12. Well-quasi order Well-quasi orders (WQOs) are the key technical tool \nin the algo\u00adrithm and its proof of correctness. According to a classical de.ni\u00adtion, a quasi order (X,=)is \na WQO, if for every in.nite sequence x1,x2,... . X there exist indexes i <j such that xi = xj. It is \nwell known that =is a WQO iffit is well-founded and every antichain is .nite. We extend this de.nition \nto the nominal setting. A nominal quasi order is a nominal set X together with a quasi order =which is \na nominal subset of X \u00d7 X. Let C be the least support of =.A nominal quasi order is called a nominal \nWQO if for every in.nite sequence x1,x2,... . X there exist indexes i <j and a permutation p . GC such \nthat xi \u00b7 p = xj. (As C supports the order = relation, one could equivalently require xi = xj \u00b7 p for \nsome p . GC.) The following lemmagives an equivalent and maybe cleaner de.nition. Lemma 13 A nominal \nquasi order X is a nominal WQO iff it is well founded and every antichain is a .nitary subset of X. For \nexample, any orbit-.nite set X, with the discrete partial order (all different elements are incomparable) \nis a nominal WQO. Theorem 14 For all data symmetries mentioned in Theorem 12, if Qis an orbit-.nite one-dimensional \nnominal set then FQ, ordered by inclusion, is a nominal WQO. Proof The proof depends heavily on the data \nsymmetry involved and used deep combinatoric results such as Dickson s Lemma (for the equality symmetry) \nor Higman s Lemma (for the total order symmetry). D Example 10 The assumption on Q being one-dimensional \nis im\u00adportant. As an illustrating example consider the equality symmetry and the two-dimensional set \nQ= . Thefamily of .nite sets, for D2 all n . N, of the following form Xn = {(d1,d2),(d2,d3),..., (dn,d1)}, \nwhere d1,...,dn are distinct data values, forms an orbit-in.nite antichain in FQ. Indeed, if n = m then \nthere is no bijection psuch that Xn \u00b7 p . Xm. Thus Qis not a nominal WQO. 13. Decision procedurefor emptiness \nWe now use the results of the previous section to give an emptiness algorithm for one-dimensional alternating \nautomata. The algorithm works in the total order symmetry and in the equality symmetry, thus reproving \nthe results of [6, 8]. The algorithm also works in the classical symmetry,but in this case it has suboptimal \ncomplex\u00adity. One of our contributions is that we make the similarities be\u00adtween [6, 8] explicit: we produce \none piece of code in N., which solves the emptiness problem for one-dimensional alternating au\u00adtomata \nfor all these data symmetries3. Also, because the code is generic, it only focusses on the essence of \nthe problem, and needs not to talk about technical details. In addition, the same code solves the emptiness \nproblem for any data symmetry which satis.es the condition of Theorem 14: If Qis an orbit-.nite one-dimensional \nnominal set then (2) FQ, ordered by inclusion, is a nominal WQO. As an illustrating example, in Section \n14 we describe a new data symmetry, called the forest symmetry, that has property (2). We also show that \nthe partial order symmetry does not have prop\u00aderty (2), so the code does not work (i.e. may not terminate) \nfor that symmetry. In fact, the emptiness of one-dimensional alternat\u00ading automata is undecidable there. \nIn short, although our program works in many Fra\u00a8iss\u00b4 e symme\u00adtries, the decidability (and also complexity) \nlandscape depends on the choice of symmetry. 13.1 High-level overview of the algorithm The algorithm \nfor checking emptiness of alternating automata runs two semidecision procedures in parallel. The .rst \nprocedure termi\u00adnates if and only if the automaton is nonempty, the second proce\u00addure terminates if and \nonly if the automaton is empty4. 3Our code makes syntactic sense for two-and higher dimensional automata \nas well. When executed for such inputs, the program may not terminate. 4Formally speaking, our language \ndoes not allow running two procedures in parallel. However, it is not dif.cult to combine the two procedures \ninto a single one.  The nonemptiness semidecision procedure. This procedure sim\u00adply doesa breadth-.rst \nsearch through all reachable con.gurations. De.ne Xn to be the set of con.gurations that can be reached \nfrom the initial con.guration in n steps, def def '' X0 = {{qI}} Xn+1 = {X : XX for some X .Xn}. The \nalgorithm calculates the sets X0,X1,X2,... and searches each one fora .nal con.guration. The procedure \nterminatesif and only if the automaton is non-empty. The only question is: how can we represent Xn? The \nfollowing fact implies that each Xn can be storedbya programofN.. Fact 15 If Xn is .nitary, then so is \nXn+1. The nonemptiness semidecision procedure is very straightforward, and it requires almost no assumptions \nto work. In particular, it works for all Fra\u00a8iss\u00b4e symmetries, not just those satisfying (2), and it \nworks also for automata of arbitrary dimension, not just one. The emptiness semidecision procedure. The \nwhole weight of the algorithm is in the emptiness semidecision procedure, which searches for a .nitary \nwitness of emptiness. Unlike the nonempti\u00adness semidecision procedure, its proof of termination requires \nthe automaton to be one-dimensional and the data symmetry to sat\u00adisfy (2). For a set X of con.gurations, \nde.ne X. = {X ' : X ' is a con.guration that includes some X .X}. Proposition 16 The automaton is empty \nif and only if there is a .nitary subset X of con.gurations such that: X.contains the initial con.guration. \n X.contains no .nal con.gurations.  Whenever X .X and XX ' then X ' .X..  The emptiness semidecision \nprocedure searches through all .nitary subsets of con.gurations, and terminates if it .nds one that satis.es \nthe conditions in Proposition 16.  13.2 Implementing the algorithm inN. We begin by typing the program. \nThe input to the program is an alternating automaton. Its alphabet is thus a parameter of type Fna for \nsome type a. Similarly, the set of states of the automaton is of type Fn\u00df, for some type \u00df. We assume \nthat a and \u00df are equality types. An automaton is thus given by a tuple of type: Fna\u00d7 Fn\u00df \u00d7 Fn\u00df \u00d7 (\u00df \u00d7 \na . F\u00df)\u00d7 \u00df \u00d7 Fn\u00df, where the six coordinates correspond to A, Q., Q., d, qI and F, respectively. Call \nthe type above aut(a,\u00df). Therefore, our emptiness algorithm will have the following type aut(a,\u00df). bool. \n(3) We now code the algorithm described in Section 13.1. The program consists of two semidecision procedures, \nnonempty and empty, both of type (3). The simpler nonemptiness procedure is described below; the more \ncomplex emptiness procedure is omitted due to lack of space. We start with a wrong solution to nonempty, \nto motivate the correct one. At .rst sight, the problem could be solved by comput\u00ading the transitive \nclosure of the relation, for instance using the program trans de.ned in Example 5. However, we cannot \napply trans to , as is not .nitary! Instead, we systematically compute con.gurations reachable from {qI} \nin k steps, for k =0,1,.... We focus only on the nominal aspects of the program and skip those fragments \nthat do not process in.nite nominal sets. For instance, we assume for simplicity that we have a function \nconf-input-succ : F\u00df . a . Fn(F\u00df) that computes, foragiven con.guration X and an input letter a, the \n.nite set of all successor con.gurations of X via a. This function uses functions add and d. Then we \nmay easily de.ne conf-succ : F\u00df . Fn(F\u00df) that computes, for a given con.guration X, the .nitary set {X \n' : XX ' }: conf-succ x = A >>= (conf-input-succ x) Similarly, conf-succ may be lifted to .nitary sets \nof con.gura\u00adtions: X >>= conf-succ The above term inputs a .nitary set X of con.gurations, and outputs \nthe set of its successors. Therefore, this term realizes the mapping Xn .Xn+1 discussed in Section 13.1. \nThe last two auxiliary functions needed to de.ne nonempty are: final : F\u00df . bool final-reach : Fn(F\u00df). \nbool final x = forall x (member F) final-reach X = if (exists X final) true (final-reach (X >>= conf-succ)) \nFor a set X of con.gurations, the function final-reach checks if a con.guration containing only .nal \nstates is reachable from any con.guration in X, by recursively computing successors. Finally: nonempty \nAQ. Q. dqI F = final-reach (just [qI]) Note that all auxiliary functions above must be de.ned in an en\u00advironment \nthat contains all ingredients of an automaton, that is A, Q., Q., d, qI and F. 14. Decidability border \nIn this section we discuss what happens to our program for data symmetries other than those mentioned \nin Theorem 12.We provide a negative example and a positive one. This demonstrates that decidability of \nthe emptiness problem in dimension 1 is a delicate issue and it strongly depends on a data symmetry. \nPositive example: forest orders. Consider a forest symmetry, which corresponds to the Fra\u00a8iss\u00b4e class \nof forests.A partial order is called a forest if for every element x, the elements smaller than x are \nlinearly ordered. The class of .nite forests has amalgama\u00adtion, so there is a universal structure, and \nwe can study N. in the resulting data symmetry. One can show that the forest symmetry satis.es condition \n(2) from Section 13. The proof is the same as in Theorem 14, ex\u00adcept that we use Kruskal s Tree Theorem \ninstead of Dickson s or Higman s Lemma. Because condition (2) is satis.ed, our empti\u00adness algorithm works, \nand therefore emptiness is decidable for one\u00addimensional alternating automata for the forest symmetry. \nThis is a new decidability result, unknown in the automata literature. Negative example: partial orders. \nConsider the partial order symmetry, arising from the Fra\u00a8iss\u00b4 e class of .nite partial orders. Fact \n17 Condition (2)fails in the partial order symmetry. In fact, emptiness is undecidable for one-dimensional \nalternating automata in the partial order symmetry.  15. Name binding As another case study, we use \nN. to capture name binding on the example of untyped lambda calculus, up to a-conversion. Our objective \nis to de.ne a datatype to implement lambda terms, such that two a-equivalent terms are represented by \nthe same object of that datatype. In this section we work with the equality symmetry. Our basic idea \nis that a term, in particular a lambda abstraction modulo a-conversion, is represented as a .nitary set \nof terms. For instance, the following two terms: m1 = .d.dd m2 = .d..e.d, will be represented, intuitively, \nby the following two sets: {.d.dd}d.D {.d.{.e.d}e.D\\{d}}d.D. The lambda terms that we want to implement \nare built out of variables using application and lambda abstraction. To store them, we use a recursive \ndatatype term: term = VAR(D)|APP(term \u00d7 term)|ABS(Fn(D \u00d7 term)) In particular, we use data values to \nstand for variables. We will explain the idea using m1 and m2. The term m1 is represented by t1 = ABS(hull \n\u00d8 (just (d, APP(VAR(d), VAR(d))))) Thus binding of a variable, say d above, in a term t, is obtained \nby considering the orbit of (d,t). The term m ' = .e.d will be 2 represented by t2 = ABS(hull (just \nd) (just (e, VAR(d)))) that is by the orbit of (e, VAR(d)) with respect to G{d}. Intu\u00aditively, a difference \nbetween free and bound variables is that a free variable of a term is an element of its least support \nwhile the bound variable is not. Finally m2 is represented by: t2 = ABS(hull \u00d8 (just (d, t2 ))) The set \nof free variables of a term can be computed as the least support of that term, cf. Section 9. We have \ndecided to model lambda abstraction as a suitable one\u00adorbit set of type Fn(D\u00d7term). Note that this type \ncontains elements that do not correspond to well-formed terms. However, one can de.ne a function abstr \n: D \u00d7 term . term, that constructs a well-formed lambda abstraction up to a-conversion: abstrd t= ABS( \n(supp t) >>= . fvars. let C = minus fvars (just d) in hull C (just (d, t)) ) where supp : term . Fn(FD) \nis de.ned as in Section 9. For instance, the terms t1 and t2 could be de.ned as: t1 = abstr d APP(VAR(d), \nVAR(d)) t2 = abstr d (abstr e VAR(d)) for arbitrary d = e. For simplicity we assume from now on that \nall terms are well-formed, i.e., de.ned using only VAR(), APP() and abstr asexempli.ed above (infact,a \nwell-formedness check may be easily programmed). Now we will write a capture-avoiding substitution function: \nsubst : term . D . term . term with the meaning that subst t d u substitutes the term t for every free \noccurrence of d in term u. It can be de.ned recursively: subst t d VAR(e) = if (eqD ed) t VAR(e) subst \nt d APP(t1,t2)= APP((subst t d t1), (substtdt2)) subst t d ABS(X) = let C= fvarstin let X = filter (.(e, \nu).not(member C e)) X in ABS(map (.(e, u).(e, subst t d u)) X ) Before term t is substituted inside a \nlambda abstraction ABS(X), we .lter out from X all pairs (e, u) such that e occurs free in t. Thus the \nfree variables of t are not captured and remain free. We should note that the code of the basic programs \nabove is rather unpleasant, especially when compared to the neat treatment of a-conversion in Fresh O \nCaml [17, 18]. Also the fact that the property of being a well-formed lambda term is not captured by \nthe type system of N., is a de.ciency. We see this case study as evidence of the limitations of N., just \nas the automata-theoretic examples of the preceding sections are evidence of its strength. A detailed \nstudy of relations betweenN. and Fresh O Caml, as well as an attempt to combine their strong points, \nis left for future work. References [1] P. Aziz Abdulla,J. Deneux,J. Ouaknine, andJ.Worrell. Decidability \nand complexity results for timed automata via channel machines. In ICALP, pages 1089 1101, 2005. [2] \nM. Boja\u00b4nczyk. Data monoids. In STACS, 2011. [3] M. Boja \u00b4nczyk, B. Klin, and S. Lasota. Languages with \ngroup actions. In LICS, 2011. [4] J. A. Brzozowski and E. L. Leiss. On equations for regular languages, \n.nite automata, and sequential networks. Theor. Comput. Sci., 10:19 35, 1980. [5] A. K. Chandra, D.Kozen, \nand L.J. Stockmeyer. Alternation. J.ACM, 28(1):114 133, 1981. [6] S. Demri and R. Lazic. LTL with the \nfreeze quanti.er and register automata. ACMTrans. Comput. Log., 10(3), 2009. [7] G. L. Ferrari, U. Montanari, \nand M. Pistore. Minimizing transition systems for name passing calculi: A co-algebraic formulation. In \nFoSSaCS, volume 2303 of LNCS, pages 129 158, 2002. [8] D. Figueira, P. Hofman, and S. Lasota. Relating \ntimed and register automata. In Proc. EXPRESS 10, volume 41 of EPTCS, pages 61 75, 2010. [9] R. Fra\u00a8isse.\u00b4Theoryof \nrelations. North-Holland, 1953. [10] N. Francez and M. Kaminski. Finite-memory automata. Theor. Comput. \nSci., 134(2):329 363, 1994. [11] M. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable \nbinding. Formal Asp. Comput., 13(3-5):341 363, 2002. [12] S. Lasota and I. Walukiewicz. Alternating timed \nautomata. In FoS-SaCS, pages 250 265, 2005. [13] S. Lasota and I. Walukiewicz. Alternating timed automata. \nACM Trans. Comput. Log., 9(2), 2008. [14] U. Montanari and M. Pistore. History-dependent automata: An \nintro\u00adduction. In SFM, pages 1 28, 2005. [15] J. Ouaknine and J. Worrell. On the decidability of metric \ntemporal logic. In LICS, pages 188 197, 2005. [16] M. Pistore. History Dependent Automata. PhD thesis, \nUniversity of Pisa, 1999. [17] M. R. Shinwell. The Fresh Approach: functional programming with names \nand binders. Technical Report UCAM-CL-TR-618, University of Cambridge, Computer Laboratory, February \n2005. [18] M. R. Shinwell and A. M. Pitts. Fresh Objective Caml user manual. Technical Report UCAM-CL-TR-621, \nUniversity of Cambridge Com\u00adputer Laboratory, February 2005.  \n\t\t\t", "proc_id": "2103656", "abstract": "<p>Nominal sets are a different kind of set theory, with a more relaxed notion of finiteness. They offer an elegant formalism for describing lambda-terms modulo alpha-conversion, or automata on data words. This paper is an attempt at defining computation in nominal sets. We present a rudimentary programming language, called Nlambda. The key idea is that it includes a native type for finite sets in the nominal sense. To illustrate the power of our language, we write short programs that process automata on data words.</p>", "authors": [{"name": "Mikolaj Bojanczyk", "author_profile_id": "81100362437", "affiliation": "University of Warsaw, Warsaw, Poland", "person_id": "P2991433", "email_address": "bojan@mimuw.edu.pl", "orcid_id": ""}, {"name": "Laurent Braud", "author_profile_id": "81430597054", "affiliation": "University of Warsaw, Warsaw, Poland", "person_id": "P2991434", "email_address": "laurent.braud@labri.fr", "orcid_id": ""}, {"name": "Bartek Klin", "author_profile_id": "81100608292", "affiliation": "University of Warsaw, Warsaw, Poland", "person_id": "P2991435", "email_address": "klin@mimuw.edu.pl", "orcid_id": ""}, {"name": "Slawomir Lasota", "author_profile_id": "81100583372", "affiliation": "University of Warsaw, Warsaw, Poland", "person_id": "P2991436", "email_address": "sl@mimuw.edu.pl", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103704", "year": "2012", "article_id": "2103704", "conference": "POPL", "title": "Towards nominal computation", "url": "http://dl.acm.org/citation.cfm?id=2103704"}