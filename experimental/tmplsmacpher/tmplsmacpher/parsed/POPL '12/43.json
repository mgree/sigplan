{"article_publication_date": "01-25-2012", "fulltext": "\n A Mechanized Semantics for C++ Object Construction and Destruction, with Applications to Resource Management \n Tahina Ramananandro Gabriel Dos Reis * Xavier Leroy INRIA Paris-Rocquencourt Texas A&#38;M University \nINRIA Paris-Rocquencourt tahina.ramananandro@inria.fr gdr@cs.tamu.edu xavier.leroy@inria.fr Abstract \nWe present a formal operational semantics and its Coq mechaniza\u00adtion for the C++ object model, featuring \nobject construction and destruction, shared and repeated multiple inheritance, and virtual function call \ndispatch. These are key C++ language features for high-level system programming, in particular for predictable \nand reliable resource management. This paper is the .rst to present a formal mechanized account of the \nmetatheory of construction and destruction in C++, and applications to popular programming tech\u00adniques \nsuch as resource acquisition is initialization. We also re\u00adport on irregularities and apparent contradictions \nin the ISO C++03 and C++11 standards. Categories and Subject Descriptors D.1.5 [Programming techniques]: \nObject-oriented Programming; D.2.0 [Software Engineering]: General Standards; D.2.2 [Software Engineer\u00ading]: \nDesign Tools and Techniques Object-oriented design methods; D.2.4 [Software Engineering]: Software/Program \nVeri.cation Correctness proofs; D.3.3 [Programming Languages]: Language Constructs and Features Classes \nand objects, Inheritance; F.3.3 [Logics and meanings of programs]: Studies of program constructs Object-oriented \nconstructs General Terms Languages, Veri.cation 1. Introduction One of the earliest decisions for C++ \n(in 1979) was to provide lan\u00adguage support for the construction and destruction of objects [15]: programmer-supplied \ncode fragments called constructors are au\u00adtomatically executed when a new object is created and before \nit is made available to the rest of the program; these constructors can execute arbitrary code sequences \nand are intended to estab\u00adlish the execution environment for operations by initializing .elds and maintaining \nclass-level invariants. Symmetrically, the language also supports destructors, which are executed before \nan object is destroyed at precisely-de.ned times. Such general constructors are now available in most \nprogramming languages supporting object\u00ad * Partially supported by NSF grants CCF-1035058 and OISE-1043084. \nPartially supported by ANR grants Arp`ege U3CAT and INS Verasco. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 12, January 25 27, 2012, Philadelphia, \nPA, USA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. . . $10.00 oriented programming. Many \nlanguages also provides some sup\u00adport for clean-up of objects at the end of their lifetime, e.g. .naliz\u00aders \nexecuted asynchronously at loosely-speci.ed times or dispose statements allowing a programmer to explicitly \nrequest clean-up. Because it is enforced by the programming language itself and not by coding conventions, \nthe object construction and destruction protocol provides strong guarantees that can be leveraged by \ngood programming practices. This is the case for Resource Acquisition Is Initialization (RAII), a popular \nC++ programming idiom for safely managing system resources such as .le descriptors. With RAII, resource \nacquisition is always performed in constructors, and re\u00adsource release in the corresponding destructors. \nSince C++ guar\u00adantees that every execution of a constructor is eventually matched by an execution of \na destructor, RAII minimizes the risk of leaking resources. As practically useful as they are, constructors \nand destructors raise delicate issues for the programmers, for static analysis tools, and even for language \ndesigners. While an object is being con\u00adstructed or destructed, it is not in a fully operational state. \nThis raises the question of what operations constructor/destructor code should be allowed to perform \non this object, and what semantics to give to these operations. A typical example of this dilemma is \nvir\u00adtual method dispatch: in Java and C#, unrestricted virtual method calls are allowed in constructors, \nwith the same semantics as on fully constructed objects; in contrast, C++ takes object construc\u00adtion \nstates into account when resolving virtual function calls, in a way that provides stronger soundness \nguarantees but complicates semantics and compilation. Section 2 reviews the main features of C++ object \nconstruction and destruction. This paper reports on a formal, mechanized semantics for con\u00adstruction \nand destruction in the C++ object model. This model is especially rich: it features multiple inheritance \n(both shared and re\u00adpeated), .elds of structure and structure array types, as well as sub\u00adtle interactions \nbetween construction states, virtual function calls, and dynamic casts. Our semantics, fully mechanized \nin the Coq proof assistant, is, to the best of our knowledge, the .rst to cap\u00adture faithfully these interactions \nas intended by the C++ standard. This semantics, described in section 3, is the .rst contribution of \nthe paper. The second contribution, in section 4, is the speci.cation and formal veri.cation of several \nexpected properties of the construc\u00adtion/destruction protocol, ranging from common-sense properties such \nas any subobject is constructed, or destroyed, at most once to the .rst precise characterization of the \nproperties that make the RAII programming idiom work in practice. We also study the evo\u00adlutions of the \ndynamic types of objects throughout their life cycle and formally justify the program points where compilers \nmust gen\u00aderate code to update dynamic types (v-tables). As a third contribution, this work exposes some \nirregularities and apparent contradictions in the ISO C++03 and C++11 stan\u00addards, summarized in section \n5. These have been reported to the ISO C++ committee; some were resolved in C++11, others will be in \nfuture revisions. We .nish the paper with a few words about ver\u00adi.ed compilation (\u00a76), a discussion of \nrelated work (\u00a77) and future work (\u00a78), and concluding remarks (\u00a79). All results presented in this paper \nwere mechanized using the Coq proof assistant [1]. The Coq development is available at http://gallium.inria.fr/ \ntramanan/cxx/. By lack of space, some aspects of the semantics are only sketched in this paper. A full \ndescription can be found in the .rst author s Ph.D. thesis [12, part 2]. 2. Object construction and destruction \nin C++ A constructor is a special function that turns raw memory into an object. Its purpose is to create \nan environment where class in\u00advariants hold, and where the class s member functions will operate [2, \n15, 16]. Conversely, at the end of the useful life of an object, an\u00ad other special function called destructor \n releases any acquired resources and turns the object back to mere raw memory. The time span between \nthe completion of a constructor and the start of a de\u00adstructor is the lifetime of the constructed object. \nThe C++ language rules were designed to guarantee that class invariants set up by a constructor hold \nthrough the entire lifetime of an object. For exam\u00adple, a complete object s dynamic type does not change \nduring its lifetime. C++ s object construction and destruction mechanism is rooted in a few design principles: \nI. Every object and each of its subobjects (if any) is constructed exactly once. II. No object construction \nshould rely on parts yet to be con\u00adstructed, and no object destruction should rely on parts already destroyed. \nIII. Every object is destroyed in the exact reverse order it was constructed. These principles, independently \nof implementation considerations, enable support for reliable, modular, large-scale software develop\u00adment. \nPrinciple I supports the idea that a resource acquired by an object (say a .le lock) is predictably acquired \nexactly once. Principle II embodies a notion of locality and scoping. While the constructor is creating \nthe computation environment for member functions, very few class guarantees can be made. It is desirable \nto localize the complexity and/or convolution needed to correctly call a function in a few speci.c places \nbefore an object begins its lifetime. Furthermore, the author of a class should not have to worry about \nwhich data members of possible derived classes are correctly initialized during the execution of a constructor. \nOn the other hand, she should be able to rely on base-class invariants. Consider the following example: \nstruct Locus { Locus(int a, int b) : x(a), y(b) { show(); } virtual void show() const { cout << x<< \n<< y<< endl; } protected : int x; int y; }; struct FeaturedLocus : Locus { FeaturedLocus(int a, int b, \nconst vector&#38; v) : Locus(a, b), features(v) { } void show () const { cout << x<< << y <<  << features \n<< endl; } private : vector features; }; Construction of a FeaturedLocus object entails constructing \nits Locus base-class subobject, followed by copy-initialization of its features .eld from the v parameter. \nIf, in the Locus constructor, the call to the virtual function show resolved to the .nal overrider FeaturedLocus::show \n(as in Java or C#), it would access the yet\u00adto-be-constructed .eld FeaturedLocus::features an undesirable \nand unpleasant outcome. Consequently, Principle II argues for re\u00adsolving the call (in the constructor) \nto an overrider not from a de\u00adrived class; here it is Locus::show. Finally, Principle III supports predictability \nand reliability. For instance, if an object acquires N resources through the construction of its subobjects, \nin general one would want to release them in the reverse order of acquisition, or else a deadlock might \nensue. Turning these general principles (and their implications) into executable speci.cation in the \nface of object-oriented language fea\u00adtures such as multiple inheritance (both repeated and shared), late \nbinding function dispatch (virtual function calls), type queries, etc. is an interesting challenge. On \nthe other hand, their ful.llment leads to interesting soundness results and, more importantly, reli\u00adable \nsoftware development techniques for the programmer. Initialization versus assignment There is a difference \nbetween initialization and declaration followed by a .rst-time assignment . And it is not a stylistic \ndistinction. Base-class subobjects and non\u00adstatic data members are constructed before the proper body \nof the constructor is executed. Initializers for subobjects are speci\u00ad.ed in a comma-separated list before \nthe opening brace of a con\u00adstructor body (see the de.nition of the constructors for Locus and FeaturedLocus \nin the previous example.) In particular, there is no other way to initialize base-class subobjects, const \nor reference nonstatic data members. A base-class subobject, or a nonstatic data member, not mentioned \nin the member-initializer list is implicitly initialized with a default constructor, i.e. a constructor \nthat can be called with no argument. Consequently, the language rules imply that all subobjects are constructed \nby the time the .rst statement of the constructor body (if not empty) is executed. The constructor for \nFeaturedLocus could have been written as FeaturedLocus(int a, int b, const vector&#38; v) : Locus(a,b) \n{ features = v; } In this variation, the Locus base-class subobject is initialized; the nonstatic data \nmember features is default constructed, and .nally the constructor body assigns the value of v to features. \nIn C++, assignments of objects of class types are generally implemented by user-de.ned functions. These \nfunctions must assume that the left hand side of the assignment is an object already constructed and \nin a valid state. In particular, vector s assignment function must carefully check for self-assignment \nto avoid premature memory re\u00adlease; it must properly release the resources the object was manag\u00ading before \ntaking hold on the new ones. By contrast, during copy\u00adconstruction, the object being constructed has \nnot acquired any re\u00adsources yet; so the implementation code of the copy-constructor is usually far simpler \nthan that for assignment. Initialization order Principle III has an interesting implication on the construction \norder of the constituents of an object. Observe that there is exactly one destructor per class, and that \nthere can be as many constructors (per class) as deemed necessary by the program\u00admer. Therefore, for \na given class, subobjects in all constructors must be initialized in the same order for that order must \nbe the reverse destruction order of the (unique) destructor. Any well-de.ned order can do. However, for \nsimplicity, a natural choice is the declaration complete object or most-derived subobject inheritance \nsubobject  Figure 1. A recursive tree representation of the subobjects of a class, such that a depth-.rst \nleft-to-right traversal yields the subob\u00adject construction order. order: initialization of all base-class \nsubobjects in the (left-to-right) order of declaration in the class de.nition; followed by initializa\u00adtion \nof all nonstatic data members in their order of declarations in the class de.nition. This construction \norder is simple, predictable, and re.ects the compositional aspect of class growth . However, shared \ninheri\u00adtance (virtual base classes) poses a problem for the principle of base before derived and strict \norder of declaration construction . Indeed, consider the following hierarchy of IO stream classes: struct \nistream : virtual basic_ios { ... }; struct ostream : virtual basic_ios { ... }; struct iostream : istream \n, ostream { ... }; where the class basic_ios maintains states and implements opera\u00adtions common to both \ninput and output streams; the classes istream and ostream implement input and output stream functionalities. \nThe class iostream combines both input and output facilities. If an iostream object was to be constructed \naccording to the declaration order outlined above, the corresponding basic_ios base-class sub\u00adobject \nwould be constructed twice: once when the istream base\u00adclass subobject is constructed, and a second time \nwhen the ostream base-class subobject is constructed. This problem is resolved by ex\u00adecuting constructors \nfor virtual bases (in declaration order) before all other constructors. More generally, C++ retains the \nfollowing almost-declaration order construction for a complete object, also depicted on Figure 1: 1. \nvirtual base-class subobjects are constructed in a depth-.rst left-to-right traversal of the inheritance \ngraph; 2. direct non-virtual base-class subobjects are constructed in dec\u00adlaration order; 3. nonstatic \ndata members are constructed in declaration order.  Builtin object types The C++ programming language \nwas de\u00adsigned with two competing ideals: a sound high-level object model with equal support for user-de.ned \ntypes and builtin types, and a near-total compatibility with C for system programming. The re\u00adsulting \ntension has made the general model of object construction and destruction grow barnacles. Indeed, C lacks \nthe notion of object construction so central to C++ s object model. But, in reality, both languages agree \non the semantics of programs that read from unini\u00adtialized objects: unde.ned behavior, except in very \nlimited cases where a read access is done as raw memory . In C, object initial\u00adization is usually expressed \nin terms of storage acquisition followed by assignment; C++ distinguishes assignment from construction. \nTo achieve the same ultimate semantics and to support generic pro\u00adgramming, C++ extended the notion of \nconstructor (and destructor) to builtin types. A builtin data member can be explicitly initialized with \ndefault value using the default construction syntax: struct Locus { Locus() : x(), y() { } }; Here, the \ndefault constructor Locus explicitly constructs the data members x and y with a default value (zero) \nso that in the com\u00adplete object declaration Locus origin; , the origin object has its coordinates initialized \nto zero. Would the semantics be the same were x and y not explicitly listed in the member-initializer \nlist? The answer is no: objects of builtin type with no explicit initializers are constructed but, left \nwith indeterminate values. This irregular\u00adity was introduced as a way to satisfy the widespread practice \nin C where objects are given .rst-time values long after their declara\u00adtions. This irregularity, and \nothers related to destructors for builtin types, surely complicate the C++ semantics rules as well as \nformal\u00adization. However, they are not fundamental to the object model. In fact, the C++ standards committee \nis considering unifying initial\u00adization and lifetime rules in a post-C++11 standard. We hope this work \nwill help in that endeavor. 3. Formal operational semantics 3.1 Syntax of the core language We focus \non a core language of objects that features the main as\u00adpects of the C++ object model: construction and \ndestruction; multi\u00adple inheritance (both virtual and non-virtual), virtual functions, and nonstatic data \nmembers (a.k.a. .elds ) of scalar, array or complete non-abstract object types. To simplify the presentation, \nwe formal\u00adize only .elds that are arrays of object types, viewing a .eld of object type T as a one-element \narray of type T [1] . The core language is a language of statements operating over variables in 3-address \nstyle. We assume that typechecking was performed, static overloading was resolved, and expressions were \ndecomposed into elementary statements. The syntax of statements follows. op,... : Op Builtin operations \nvar,... : Var Variables B, C, . . . : Class Classes fname : Field Field names mname : Method Method names \nStmt ::= skip Do nothing | var' := op(var * ) Builtin operation | var' := var->C fname Field read | var->C \nfname := var' Scalar .eld write | var' := &#38;var[varindex]C Array cell access | var' := dynamic cast(B)C \n(var) Dynamic cast | var'->C mname(var * ) Virtual function call | Stmt1; Stmt2 Statement sequence | \nreturn Function return |{C var[varcount]= Block-scoped object {ObjInit * }; Stmt} The Coq formalization \nalso features simple control structures (if/then/else, in.nite loops with early exits), as well as static \ncasts. We leave these extra features out in this paper to concentrate on the essential features of the \nlanguage: accesses to .elds; virtual function calls; dynamic casts; and block-scoped objects. The statement \n{Cx[N]= {ObjInit * }; Stmt} allocates an array of N objects of type C, constructs each of its elements \naccording to the list of initializers ObjInit *, binds the array to variable x, executes the block body \nStmt, destructs each element of the array x, and .nally deallocates the whole array. Initializers are \nsyntactically presented in C++ as constructor calls with expressions as arguments. Since our language \nlacks ex\u00adpressions, we model initializers as a statement (which evaluates the expression arguments into \ntemporary variables) followed by an in\u00advocation of a constructor for object .elds or the initialization \nof a scalar .eld.  ObjInit ::= Stmt; C(var * ) Class object initializer FieldInit ::= (Stmt; fname(var)) \nScalar .eld initializer | fname{ObjInit * } Structure .eld initializers (one for each array cell) Init \n::= ObjInit | FieldInit Arguments to functions and constructors can be scalar values, i.e. integers, \nor .oating point data, or pointers to objects. We do not model passing objects by value: this raises \ndelicate issues with the construction and destruction of temporary objects, discussed in \u00a78. Constr ::= \nC(var * ): Init * {Stmt} Constructor Destr ::= ~ C(){Stmt} Destructor MethodDef ::= virtual void Virtual \nfunction mname(var * ){Stmt} (method) FieldDef ::= scalar fname; Data member | struct C[size] fname; \n(.eld) Base ::= B | virtual B ClassDef ::= struct C : Base * {FieldDef * MethodDef * Constr * Destr} \nClass de.nition Program ::= ClassDef * ; main(){Stmt} Program A complete program consists of a hierarchy \nof classes. Each class de.nition contains a list of virtual and non-virtual base classes, a list of data \nmembers (a.k.a. .elds), de.nitions for virtual functions (a.k.a. methods), one or several constructors, \nand one destructor. Each constructor consists of a parameter list, a sequence of ini\u00adtializers (for direct \nnon-virtual bases, .elds, and direct or indirect virtual bases), and a constructor body (an arbitrary \nstatement). De\u00adstructors take no parameters and consist only of a body.  3.2 Designating subobjects \nA crucial issue in formalizing the C++ object model is to capture the fact that each object of a class \nC contains subobjects, one for each base and each .eld of C. Subobjects can be arbitrarily nested, but \ncan also be shared along several inheritance paths, owing to virtual inheritance. For this reason, a \nsubobject cannot be identi.ed by a store locations e; instead, it is described by a pair of the location \ne of the array of complete objects containing it, and a path from this array to the desired subobject. \nIntuitively, a path is a sequence of selection operations of the form select a base class or select a \n.eld or select an element of an array . This path-based approach was introduced by Rossie and Friedman \n[14], later mechanized in Isabelle/HOL by Wasserrab et al. [18], and further extended with structure \narray .elds and mechanized in Coq by Ramananandro et al. [13]. We now brie.y recall this path-based formalization, \nreferring the reader to [13, 18] for full details. An inheritance path s is a pair (h, l) of an inheritance \nkind h ::= Repeated | Shared and a list of class names l. Such a path designates a base-class subobject \nof some type A of an object of type C. If h = Repeated, it is a path through the repeated, or non\u00advirtual, \ninheritance graph. Each path from C to A corresponds to a distinct copy of A within C. If h = Shared, \nit is a path from a virtual base B of C to A, regardless of how the virtual base B is reached. Not all \npaths are valid with respect to the class hierarchy. The I following inference rules de.ne the relation \nC -((h, l)). A, meaning that (h, l) is a valid inheritance path from C to a base\u00adclass subobject of C \nof static type A. I C -((Repeated,C :: E)). C I B direct non-virtual base of CB -((Repeated,l)). A I \nC -((Repeated,C :: l)). A I B virtual base of CB -((h, l)). A I C -((Shared,l)). A An object is said \nto be a most-derived object if, and only if, it is not a base-class subobject of any other object. A \nmost-derived object of type C is designated by the trivial inheritance path (Repeated,C :: E). I Inheritance \npaths compose naturally: if C -((h, l)). B and II B -((h ' ,l ' )). A, we have C -((h, l)@(h ' ,l ' )). \nA. Here, @ is the cast to base operator, de.ned as follows: for a cast through non-virtual inheritance, \n(h, l)@(Repeated,B :: l ' )= -l ' ); whereas through virtual (h, l+inheritance, we have (h, l)@(Shared,l \n' )=(Shared,l ' ). (We write + - for list concatenation.) In the presence of .elds that are structures \nor arrays of struc\u00adtures, the notions of paths and subobjects must be extended to al\u00adlow selecting elements \nof arrays of structures. Ramananandro et al. [13] de.ne array paths as lists of (i, s, F ) triples, where \ni is an array index, s an inheritance path, and F the name of a struc\u00adture array .eld. An array path \ngoes from an array of n structures of type C to an array of n ' structures of type C ', which we write \nA C[n] -(a). C ' [n ' ] and de.ne by the inference rules below. An CI auxiliary predicate C[n] -(i, s). \nA captures the selection of the i-th element of an array followed by the extraction of a base-class subobject \ns of type A. I' 0 = i<n C -(s). A 0 = n = n CIA' C[n] -(i, s). AC[n] -(E). C[n ] F =(f, D, m) is a structure \n.eld de.ned in A CIA'' C[n] -(i, s). AD[m] -(a). C [n ] A'' C[n] -((i, s, F ) :: a). C [n ] In the core \nlanguage of \u00a73.1, a complete object (bound to a variable x by a block statement) is always an array of \nstructures, with type C[n].A subobject of type A of such a complete object is. therefore, a triple (a, \ni, s) where a is an array path from C[n] to ''' '' some C [n ] and i . [0,n ) is an index in the array \nof type C [n ] and s is the inheritance path for a base-class subobject of C ' of type A. We write C[n] \n-((a, i, s)). A to mean that (a, i, s) designates a valid subobject of type A of the array C[n]. This \nrelation is de.ned by: A'' CI C[n] -(a). C [n ] -(i, s). A C[n] -((a, i, s)). A Then, a subobject of \na complete C object is a most-derived C ' object if, and only if, it can be written as (a, i, (Repeated,C \n' :: E)) I where C[n] -(a). C ' [n ' ] and 0 = i<n '. In practice, this means that a most-derived object \ncorresponds to a cell of a structure array, the array being either the complete C object itself (a = \nE) or some structure .eld of a subobject of the complete object. Our operational semantics uses these \nnotions to unambiguously identify complete objects by locations e in the store, subobjects by pairs (e, \n(a, i, s)) of a location and a subobject, and .elds by triples (e, (a, i, s),f) of a subobject of some \ntype A and a name f of a .eld declared in A. 3.3 Construction states In the C++ language, the behaviors \nof operations over objects depend on the construction state of these objects. For example, it is not \npossible to invoke a virtual function of a class C if the base classes of C have not been constructed \nyet, or are undergoing destruction. Likewise, as described in \u00a72, virtual method dispatch behaves differently \nwhen a most-derived object is fully constructed and when it is undergoing construction or destruction. \n Our operational semantics therefore associates a construction state to every subobject and every .eld, \nand updates these states during construction and destruction steps. A given subobject can be in one of \n7 construction states, whose meanings differ slightly depending on whether the subobject is a most-derived \nsubobject (e.g. an element of a structure array) or a base-class subobject. For a most-derived object, \nthe construction states and their meanings are: 1. Unconstructed: Construction has not started yet. \n2. StartedConstructing: The construction of base-class subob\u00adjects has started, but not the .elds. 3. \nBasesConstructed: The base-class subobjects are completely constructed. Now constructing the .elds or \nexecuting the con\u00adstructor body. 4. Constructed: The constructor body has returned, and destruc\u00adtion \nhas not started yet. 5. StartedDestructing: The body of the destructor is executing or the .elds are \nundergoing destruction. 6. DestructingBases: The .elds have been completely destructed. Bases are undergoing \ndestruction. 7. Destructed: All bases and .elds have been destructed.  For a base-class subobject, \nwe need to exclude virtual bases from the meaning of its construction state. Indeed, as discussed in \n\u00a72 and shown in Figure 1, virtual bases are morally attached to the enclos\u00ad ing most-derived object, \nnot to the base-class subobject. Therefore, for those base class subobjects that are not most-derived \nobjects, we reinterpret four of the construction states as follows: 1. Unconstructed: Construction of \nthe non-virtual part has not started yet. However, virtual bases may have been already con\u00adstructed. \n 2. StartedConstructing: The construction of non-virtual base\u00adclass subobjects has started, but not the \n.elds  6. DestructingBases: The .elds have been completely destructed. Non-virtual bases are undergoing \ndestruction. 7. Destructed: All .elds and non-virtual bases have been destruc\u00adted.  Then, the lifetime \nof a subobject s can be de.ned as the set of execution states where its construction state is exactly \nCon\u00adstructed. Construction states are naturally ordered by chronology. We write c<c ' to say that state \nc occurs earlier than state c ' in the enumeration above, and S(c) to denote the state immediately following \nc, if it exists. Finally, .elds also carry a construction state: one among Unconstructed, StartedConstructing, \nConstructed, StartedDe\u00adstructing, and Destructed, with similar meaning as for subobjects. As an example \nof use, writing to a scalar .eld is possible only if it is in state Constructed, therefore preventing \naccesses to an unconstructed or already destructed .eld. 3.4 Operational semantics The semantics of \nthe core language is stated in terms of evolutions of a global state G, which contains four partial maps: \n LocType: maps locations e of complete objects to pairs (C, n) representing the types C[n] of the complete \nobjects.  FieldValue: associates values to pairs (p, f) of a subobject p and a scalar .eld f.  ConstrState: \nassociates construction states to subobjects p.  ConstrStateF : associates construction states to .elds \n(p, f).  We write e.g. G.LocType(e)=(C, n) to denote a lookup in a component of the state, and G[LocType(e) \n. (C, n)] to denote an update. The main challenge in this semantics is to formalize the object construction \nand destruction protocol. (Other aspects of our lan\u00adguage, such as accesses to .elds, dynamic casts and \nvirtual func\u00adtion dispatch, are semantically well understood from the work of Wasserrab et al. [18].) \nAt a high level of abstraction, construc\u00ad tion of a complete object corresponds to enumerating its subobjects \naccording to a depth-.rst, left-to-right traversal of the construc\u00adtion tree depicted in Figure 1. The \ninitializers encountered during this traversal are then executed to determine the arguments to the constructors, \nfollowed by invocations of the designated construc\u00adtors (for bases and elements of structure array .elds) \nor .eld as\u00adsignments (for scalar .elds). Construction states of subobjects and .elds are updated along \nthe way. Destruction is similar, but pro\u00adceeds in the exact reverse order: depth-last, right-to-left \ntraversal of the construction tree. The description above strongly suggests a big-step operational semantics \nor, equivalently, a de.nitional interpreter, since the recur\u00adsive structure of these semantics matches \nwell the recursive nature of the construction tree. However, there are two reasons why we want a small-step \ntransition semantics instead. First, statements, constructors and initializers may fail to terminate, \nand we would like to account both for terminating and diverging executions. Sec\u00adond and more importantly, \nwe need our semantics to materialize the context in which a constructor or destructor executes, or in \nother terms the continuation of all pending constructor/destructor invoca\u00adtions which will be restarted \nwhen the current constructor/destruc\u00adtor .nishes. Being able to reason on this explicit context/continua\u00adtion \nis necessary in order to prove most of the high-level semantic properties of \u00a74. The operational semantics, \ntherefore, is presented in small-step style as a transition relation (P, K, G) . (P ' , K ' , G ' ) operating \nover triples of a control point P, a continuation K and a global state G. We distinguish 5 kinds of control \npoints P: Codepoint(Stmt1, Stmt * , Env, Block * ): about to execute statement Stmt1 followed by the \nlist of statements Stmt * , under variable environment Env. Block * is the list of all blocks enclosing \nthe current statement, where a block is a pair (e, Stmt * ) of a complete object e to destruct at block \nexit and the remaining statements to execute after exiting from the block.  Constr(p, ItemKind, ., L, \nEnv): about to construct the list L of the bases or .elds of the subobject p. Initializers are to be \nlooked for using constructor ., and they operate on the variable environment Env to pass arguments to \ntheir constructors. ItemKind is one of Bases(DirectNonVirtual) or Bases(Virtual) or Fields, to request \nthe construction of, respectively, direct non-virtual bases or virtual bases or .elds of p.  ConstrArray(e, \na, n, i, C, ObjInit * , Env): about to construct cells i to n - 1 of type C, of the array a from the \ncomplete object e, using the initializers ObjInit * to initialize the cells, and Env as variable environment \nto execute the initializers.  Destr(p, ItemKind,L): about to destruct the list L of bases or .elds of \nthe subobject p.  DestrArray(e, a, i, C): about to destruct cells i down to 0 of type C, of the array \na from the complete object e.  We omit the grammar of continuations K, which can be found in [12, chapter \n9]. The operational semantics is composed of 56 inference rules de.ning the transition relation (P, K, \nG) . (P ' , K ' , G ' ), for a to\u00adtal of about 900 lines of Coq de.nitions. We show some represen\u00adtative \nrules to give the general .avor, and refer the reader to the .rst author s thesis [12, chapter 9] for \na full listing.  Field accesses Reading from a scalar .eld is modeled as follows: Env(var)= p Gf p : \nCf =(.d, (Sc,t)) .F(C) G.FieldValue(p, f)= res Env ' = Env[var ' . res] (Codepoint(var ' := var->C f \n,L, Env, B), K, G) . (Codepoint(skip , L, Env ' , B), K, G) Likewise, for an assignment to a scalar .eld, \nwe have: Env(var)= p Gf p : Cf =(.d, (Sc,t)) .F(C) G.ConstrStateF (p, f)= Constructed Env(var ' )= res \nG ' = G[FieldValue(p, f) . res] (Codepoint(var->C f := var ' , L, Env, B), K, G) . (Codepoint(skip , \nL, Env, B), K, G ' ) Note the side condition preventing assignment to a scalar .eld that is not Constructed. \nFor reads, this conditions is not necessary: Theorem 4 below shows that if a .eld has a value, then it \nis Constructed. Dynamic types Virtual function calls and dynamic casts both involve the notion of dynamic \ntype of a subobject, which the C++ standard de.nes as its most-derived object during the lifetime of \nthe latter. However, the standard also permits virtual function calls and dynamic casts during the execution \nof the constructor body, or .eld initializers, or destructor body corresponding to the subobject. To \nunify these two cases, we introduce the notion of generalized dynamic type. We de.ne the predicate gDynType(e, \na, i, s, B, s ' ,s '' ), meaning that the base-class subobject s ' of static type B is the generalized \ndynamic type of the subobject (e, (a, i, s)) with s = s ' @s '' . ACI G.LocType(e)=(D, n) D[n] -(a). \nC[m] -((i, s)). B G.ConstrState(e, (a, i, (Repeated,C :: E))) = Constructed Gf gDynType(e, a, i, s, C, \n(Repeated,C :: E),s) G.LocType(e)=(D, n) ACI D[n] -(a). C[m] -((i, s.)). C. G.ConstrState(e, (a, i, \ns.)) = c c = BasesConstructed . c = StartedDestructing 'I' C. -(s ). Bs = s.@s Gf gDynType(e, a, i, \ns, C.,s.,s ' ) The semantics of virtual function calls is similar to that given by Wasserrab et al. [18], \nexcept that we use the generalized dynamic type instead of the most-derived object. If C. is the generalized \ndynamic type of subobject s ' , the predicate : B '' VFDispatch(C.,s ' , f, B '' ,s '' ) determines the \nsubobject s '' of C. containing the de.nition of virtual function f that must be invoked, following the \nsame algorithm as in [18]: 1. Determine the static resolving subobject sf declaring f. 2. Choose the \n.nal overrider for the method. The .nal overrider is the inheritance subobject s '' between C. and sf \n, nearest to C., and declaring f.  The transition rule for a virtual function call is, then, Env(var)=(e, \n(a, i, s)) Gf gDynType(e, a, i, s, C.,s.,s ' ) ' '' '' VFDispatch(C.,s ,f,B ,s ) B '' .f = f(varg1,..., \nvarg){body}.j, Env(varj )= vj n Env ' = \u00d8[varg1 . v1] ... [vargn . vn][this . (e, (a, i, s.@s '' ))] \n(Codepoint(var->B f(var1 ... varn), L, Env, B), K, G) . (Codepoint(body, E, Env ' ,E), Kretcall(var, \nL, Env, B) :: K, G) Similarly, dynamic casts are handled as in Wasserrab et al. [18], using the generalized \ndynamic type instead of the most derived object. The transition rule is omitted for brevity, but can \nbe found in [12, chapter 9]. Destruction We now give the .avor of the object construction and destruction \nprotocol, starting with the simpler of the two, namely destruction. Destruction starts when the body \nof a block has re\u00adduced to skip or return: (st = skip . L = E) . st = return G.LocType(e)=(C, n) (Codepoint(st, \nL, Env, (e, L ' ) :: B), K, G) . (DestrArray(e, L, n - 1,C), Kcontinue(st, Env,L ' , B) :: K, G) The \nDestrArray execution state requests the destruction of all ele\u00adments of the structure array C[n] at e, \nstarting with the last element (n - 1). Eventually, we reach a state where no more elements re\u00admain to \nbe destructed, in which case we effectively exit from the block. (DestrArray(e, a, -1,C), Kcontinue(st, \nEnv, L, B) :: K, G) . (Codepoint(st, L, Env, B), K, G) When the destruction of a most-derived object \n(i.e. a structure array cell) is requested, we .rst enter the body of the associated destructor in a \nvariable environment that binds this to the object. 0 = i ~ C(){stmt} p =(e, (a, i, (Repeated,C :: E))) \nEnv = \u00d8[this . p] G ' = G[ConstrState(p) . StartedDestructing] (DestrArray(e, a, i, C), K, G) . (Codepoint(stmt, \nE, Env,E), Kdestr(p) :: Kdestrcell(e, a, i, C) :: K, G ' ) When the destructor body returns, the .elds \nof the subobject have to be destructed, in reverse declaration order. p =(e, (a, i, (h, l))) last(l)= \nCL = rev(F(C)) (Codepoint(return, Stmt * , Env,E), Kdestr(p) :: K, G) . (Destr(p, Fields,L), K, G) Destructing \na scalar .eld erases its value and changes its construc\u00adtion state to Destructed, before proceeding with \nthe remaining .elds. f =(.d, (Sc,t)) G ' = G[FieldValue(p, f ) ..][ConstrStateF (p, f) . Destructed] \n(Destr(p, Fields,f :: L), K, G) . (Destr(p, Fields,L), K, G ' ) Destructing a structure array .eld changes \nits construction state to StartedDestructing, then requests the destruction of the array, starting from \nits last cell, and remembering the remaining .elds through Kdestrother in the continuation. p =(e, (a, \ni, s)) f =(.d, (St, (C, n))) a ' = a-+(i, s, f) :: E G ' = G[ConstrStateF (p, f) . StartedDestructing] \n (Destr(p, Fields,f :: L), K, G) . (DestrArray(e, a ' ,n - 1,C), Kdestrother(p, Fields, f, L) :: K, G \n' ) Then, once all cells have been destructed, the .eld enters the De\u00adstructed state, and we proceed \nwith the destruction of the remain\u00ading .elds.  Destructed, and we proceed with the destruction of the \npreceding ' structure array cells. G = G[ConstrStateF (p, f) . Destructed] (DestrArray(e ' ,a ' , -1,C), \nKdestrother(p, Fields, f, L) :: K, G) . (Destr(p, Fields,L), K, G ' ) Eventually, all .elds have been \ndestructed. The subobject then changes its construction state to DestructingBases. At this point, no \nvirtual function call nor dynamic casts may be used on this subobject. The destruction of the direct \nnon-virtual bases starts, in reverse declaration order. p =(e, (a, i, (h, l))) last(l)= CL = rev(DN V(C)) \nG ' = G[ConstrState(p) . DestructingBases] (Destr(p, Fields,E), K, G) . (Destr(p, Bases(DirectNonVirtual),L), \nK, G ' ) Destructing a (virtual or direct non-virtual) base B of p enters its destructor, remembering \nthe other bases through Kdestrother. ~ B(){stmt} p ' = AddBase(p, \u00df, B) Env = \u00d8[this . p ' ] G ' = G[ConstrState(p \n' ) . StartedDestructing] (Destr(p, Bases(\u00df),B :: L), K, G) . (Codepoint(stmt, E, Env,E), Kdestr(p ' \n) :: Kdestrother(p, Bases(\u00df), B, L) :: K, G ' ) Eventually, we reach a state where all direct non-virtual \nbases of p have been destructed. There are two cases to consider, depending on the top of the continuation \nstack. In the .rst case, the continu\u00adation stack starts with a Kdestrother(p ' , Bases(\u00df), B, L), indicat\u00ading \nthat p is not a most-derived object. In this case, there is no need to destruct the virtual part of p \n(this will be done later by the en\u00adclosing most-derived object) and we are done with the subobject p: \nits construction state becomes Destructed, and we proceed with the destruction of the remaining bases \nof p ' . G ' = G[ConstrState(p) . Destructed] (Destr(p, Bases(DirectNonVirtual),E), Kdestrother(p ' , \nBases(\u00df), B, L) :: K, G) . (Destr(p ' , Bases(\u00df),L), K, G ' ) The second case is when the continuation \nstack starts with a Kde\u00adstrcell. Then, p must be a most-derived object, and its direct and indirect virtual \nbases need to be destructed. According to the C++ standard, virtual bases must be destructed in reverse \ninheritance graph order. Consider the following recursive function: VO list({Repeated, Shared}\u00d7C) . list(C) \nVO(E)= E VO((Repeated,B) :: q)= VO(D(B))-+' VO(q) VO((Shared,B) :: q)= VO(D(B))-+' (B :: VO(q)) where \nD(B) is the list of direct bases of B, in declaration order, tagged with Repeated(for non-virtual bases) \nor Shared(for virtual bases), and -+' is list concatenation with elimination of duplicates (l1-+' l2 \n=def l1-+(l2 \\ l1)). It is easy to see that the list L = VO(D(C)) contains all the direct and indirect \nvirtual bases of C, exactly once each, and contains no other classes. Moreover, the order in which virtual \nbases appear in list L is consistent with the inheritance graph order. In particular, if A and B are \nvirtual bases of C such that A is a virtual base of B, then A appears before B in L. L ' = rev(VO(D(C))) \n(Destr(p, Bases(DirectNonVirtual),E), Kdestrcell(e, a, i, C) :: K, G) . (Destr(p, Bases(Virtual),L ' \n), K, G) Finally, when all virtual bases have been destructed, the subobject under consideration (necessarily \na most-derived object) becomes p =(e, (a, i, (h, l))) last(l)= C G ' = G[ConstrState(p) . Destructed] \n(Destr(p, Bases(Virtual),E), K, G) . (DestrArray(e, a, i - 1,C), K, G ' ) Construction To execute a block \nstatement, we allocate memory for the structure array declared in the block, then start the construc\u00adtion \nprotocol by requesting the construction of the .rst element of this array: G ' e . dom(G.LocType)= G[LocType(e) \n. (C, n)] Env ' = Env[c . Ptr(e, E, (Repeated,C :: E))] (Codepoint({Cc[n]= {.}; st}, St, Env, Bl), K, \nG) . (ConstrArray(e, E, n, 0, C, ., Env ' ), Kcontinue(st, Env ' , St, Bl) :: K, G ' ) The construction \nprotocol implements the necessary traversal of all subobjects of c using the same small-stepping style, \nbased on continuations, that was illustrated above in the case of destruction. There are two main differences. \nFirst, the construction order is the exact opposite of the destruction order: instead of enumerating \narray cells by decreasing indices, .elds and non-virtual bases in reverse declaration order and virtual \nbases in reverse VO order, we enumerate array cells by increasing indices, .elds and non\u00advirtual bases \nin declaration order and virtual bases in VO order. Second and more importantly, we need to execute the \ninitializers that compute initial values for scalar .elds and the arguments to be passed to constructors, \nadding a number of transition rules. We refer the reader to [12, chapter 9] for full details. 4. Properties \nof construction and destruction In this section, we state (and sometimes outline the proofs of) sev\u00aderal \nsemantic properties of interest for construction and destruction. Some are technical consequences of \nthe de.nition of our semantics, but others capture higher-level properties that C++ programmers often \nrely on, such as the RAII principle. 4.1 Run-time invariant Our transition rules and grammars for execution \nstates are lax in that they put very few constraints on the general shapes of states. However, in transition \nsequences starting from the initial state, the reachable states are a small subset of all possible states \nand enjoy many low-level properties that are essential to prove the high-level theorems in this section. \nWe gathered about 20 such properties in one invariant INV and proved that this invariant is satis.ed \nby the initial state and preserved by the transition rules. This is the largest part of the Coq mechanization, \ntotaling about 15000 lines of Coq and taking about 2 hours to re-check the proof. A detailed explanation \nof the invariant is given in [12, sec\u00ad tion 10.1]. Here, we just show the two most interesting conse\u00adquences \nof the invariant, which relate the construction states of cer\u00adtain subobjects. Let p, p ' be two subobjects \nof the same complete object. We say that p is a direct subobject of p ' if, either, (1) p is a direct \nnon\u00advirtual base of p '; (2) or p ' is a most-derived object and p is a virtual base of p '; (3) or p \nis a .eld subobject of p ' (that is, p is a cell of a structure array .eld of p '). Lemma 1 (Vertical \nrelations on construction states). Assume that p is a direct subobject of p '. The construction states \nof p and p ' in any execution state satisfying INV are related as follows:  If p ' is... Then p is. \n. . Unconstructed Unconstructed StartedConstructing Unconstructed if p is .eld subobject of p ' BasesConstructed \nConstructed if p is a base subobject of p ' Constructed Constructed StartedDestructing Constructed if \np is a base subobject of p ' DestructingBases Destructed if p is a .eld subobject of p ' Destructed Destructed \n' Let p be a subobject of static type C, and p1,p2 be two direct subobjects of p '. We say that p1 occurs \nbefore p2 if, either, (1) p ' is a most-derived object and p1,p2 are two virtual bases of p ' in inheritance \ngraph order; (2) p1 and p2 are two direct non-virtual bases of p in declaration order; (3) p1 and p2 \nare two cells of the same array .eld, in the order of their indexes within the array; (4) p1 and p2 are \ntwo cells of two different .elds in declaration order; (5) p ' is a most-derived object and p1 is a virtual \nbase, and p2 is a direct non-virtual base of p ' or a cell of an array .eld; (6) p1 is a direct non-virtual \nbase of p ' and p2 is a cell of an array .eld. Lemma 2 (Horizontal relations on construction states). \nAssume that p1 occurs before p2. The construction states of p1 and p2 in any execution state satisfying \nINV are related as follows: If p1 is... Then p2 is. . . Unconstructed StartedConstructing Unconstructed \nBasesConstructed Constructed in an arbitrary state StartedDestructing DestructingBases Destructed Destructed \nIn the remainder of this section, we only consider execution states that can be reached from the initial \nstate and therefore satisfy the invariant INV .  4.2 Progress To check that our transition rules make \nsense and that no rule is missing, we prove a progress property of construction and destruction: once \nconstruction of a complete object starts, it always eventually reaches a point where the object is fully \nconstructed, without getting stuck in the middle; and likewise for destruction. This result is false \nin general: since constructors, initializers and destructors can perform arbitrary computation, they \ncan get stuck on e.g. an attempt to assign an unconstructed scalar .eld. However, we can prove the expected \nresult if we restrict ourselves to nearly trivial constructors and trivial destructors. We say that a \nclass C has a nearly trivial constructor if (1) C has a default constructor with no arguments and return \nas its body; (2) initializers for bases and .elds just call the default constructors, without any other \ncomputations; (3) scalar .elds are initialized with constants; (4) for each structure array .eld f of \nC, if f has type B, then B has a nearly trivial constructor. This notion extends the concept of trivial \nconstructor from the C++ standard, e.g. by allowing virtual bases and virtual functions. Theorem 3 (Construction \nprogress). Let (P, K, G) be an execution state where P = Codepoint({Cc[n]; st} = ., . . .), i.e. we are \nabout to execute a block statement. Assume that C is a class having a nearly trivial constructor and \nthat the initializer list . calls the default constructor for every array cell. Then, there exists a \nstate (P ' , K ' , G ' ) such that * (P, K, G) . (P ' , K ' , G ' )  P ' = Codepoint(st,...), i.e. \nconstruction has terminated and the block body is about to be executed;  in state G ', all cells of \nthe array c are in the Constructed state.  A similar theorem holds for destruction. Here, we use unchanged \nthe notion of trivial destructor from the C++ standard: a class C has a trivial destructor if (1) its \ndestructor is just return; (2) all virtual bases and direct non-virtual bases of C have trivial destructors; \n(3) for each structure array .eld f of C, if f has type B, then B has a trivial destructor. 4.3 Safety \nof .eld accesses and virtual function calls The rule for reading the contents of a scalar .eld puts no \nprecondi\u00adtion on the initialization state of the .eld. We can, however, show that this rule gets stuck \nwhenever the .eld is not in the Constructed state. Theorem 4. A scalar .eld has a well-de.ned value only \nif it is Constructed. Proof. Follows from INV and the fact that setting the value of a scalar .eld only \noccurs in two cases: either on an ordinary scalar .eld, which is forbidden if the .eld is not Constructed, \nor on scalar .eld initialization, which turns the .eld construction state to Constructed. Moreover, our \nsemantics erases the value of the scalar .eld when destructing it. Like C++ itself, our semantics allows \n.elds to have no initializ\u00aders and therefore remain without a de.ned value after construction. However, \nwe also proved that if we remove the transition rule al\u00adlowing .elds without initializers to proceed, \na scalar .eld has a well-de.ned value if and only if it is Constructed. Virtual functions have no initialization \nstate per se. However, the C++ semantics for virtual function calls provides a very useful guarantee \nconcerning the construction state of the this subobject: Theorem 5. Whenever a virtual function is called, \nthe subob\u00adject bound to its this parameter is in state BasesConstructed or Constructed or StartedDestructing, \nand all its base-class subob\u00adjects are in state Constructed. Proof. Consider a call to a virtual function \nf on a subobject (e, p). Since this call does not go wrong, the generalized dynamic type po of this subobject \nis de.ned. By de.nition of generalized dy\u00adnamic types, (e, po) is in state BasesConstructed or Constructed \nor StartedDestructing. Invariant INV then guarantees that all base-class subobjects of (e, po) are Constructed \n(from Lemma 1). The .nal overrider for function f being either (e, po) or one of its base-class subobjects, \nthe result follows. In other words, a virtual function can always safely assume that bases have been \nproperly constructed. It cannot, however, assume that .elds of its de.ning class are in the constructed \nstate, since initializers for these .elds can call the virtual function. As discussed in \u00a72 and by Qi \nand Myers [11], Java does not provide a similar guarantee; through inheritance and method overriding, \nit is possible for a method to be invoked before its super classes have completed their initialization. \n 4.4 Evolution of construction states Lemma 6. If s . s ' is a transition step of our small-step op\u00aderational \nsemantics, and if the construction state of the subobject (e, p) is c in s and c ' = c in s ', then c \n' = S(c) and any other subobject (e ' ,p ' )=(e, p) keeps its construction state unchanged. Proof. By \ncase analysis on the transition rules, with the help of invariant INV . Corollary 7. Any subobject is \nnever constructed or destructed more than once.  In particular, any virtual base subobject is constructed \nor de\u00adstructed at most once, despite being potentially reachable through several inheritance paths. Also, \nif an object goes from one construc\u00adtion state to another, then it must go through all construction states \nin between: Proof. At state s2, p1 is Constructed but p2 is not. Hence, the lifetime of p1 cannot be \nincluded in that of p2. By theorem 9, the lifetime of p2 is therefore included in that of p1. Since p1 \nis no longer Constructed at state s5, so is p2 at state s5. Since at most one subobject changes construction \nstate during a given transition (Lemma 6), p1 = p2 and p2 is no longer Constructed at state s4. ', then, \nfor any * Theorem 8 (Intermediate values theorem). If s . s The result then follows from the the intermediate \nvalues theorem subobject (e, p) and for any construction state c such that: (Theorem 8). ConstrStates(e, \np) = c< S(c) = ConstrStatesl (e, p) Subobjects of different complete objects In the full C++ lan\u00ad '* \n* there exist changing states s1,s2 such that s . s1 . s2 . s guage, including dynamic allocation, the \nlifetimes of two subob\u00ad and ConstrStates1 (e, p)= c and ConstrStates2 (e, p)= S(c). (Here, for a state \ns =(P, K, G), we write ConstrStates(p) for jects of different complete objects are, in general, unrelated: \nnew and delete operations can be interleaved arbitrarily. In our core language, complete objects can \nonly be created by block statements G.ConstrState(p).) and therefore follow a stack discipline.  4.5 \nObject lifetimes An important design principle of C++ is that destruction is per\u00adformed in the exact \nreverse order of construction. We now for\u00admalize and prove this property, along with more general properties \nabout the relative lifetimes of two subobjects. Two subobjects of the same complete object Let e be a \ncomplete object of type C[n]. Theorem 14. The lifetimes of two subobjects (e1,p1) and (e2,p2) of different \ncomplete objects e1 = e2 are either disjoint or included in one another. This result follows from Theorem \n9 and the stronger property below, which shows that throughout the execution of a block, the construction \nstates of subobjects of already-allocated complete ob\u00adjects do not change: * Theorem 9. If p1 and p2 \nare two subobjects of the complete Lemma 15. Let s1 . s2 . s3 . s4 be the execution of a object e, either \nthe lifetime of p1 is included in that of p2, or the block: the transition s1 . s2 enters the block and \nallocates a lifetime of p2 is included in that of p1. fresh complete object e; the transition s3 . s4 \nexits this block. For all complete objects e ' already allocated in state s1, the allocation To prove \nthis theorem, we need to characterize the construction order between subobjects. We write p1 .C[n] p2 \nto say that p1 states of its subobjects (e '' ) are identical in s1 and s4. ,p occurs before p2 in the \ndepth-.rst, left-to-right traversal of the construction tree in Figure 1. (See [12, chapter 10] for a \nformal de.nition in terms of the direct subobject and occurs before relations of \u00a74.1.) The two crucial \nproperties of this construction order are the following: Lemma 10 (The construction order is total). \nIf C[n] -(p1). B1 and C[n] -(p2). B2, then either p1 .C[n] p2 or p2 .C[n] p1. Lemma 11 (Construction \norder and lifetimes). For any reach\u00adable execution state s and any complete object e of type C[n], if \np1 .C[n] p2 and ConstrStates(e, p2)= Constructed, then ConstrStates(e, p1)= Constructed. In other words, \nif p1 .C[n] p2, then the lifetime of p2 is included in the lifetime of p1.  4.6 RAII: Resource Acquisition \nIs Initialization RAII is a programming discipline where precious program re\u00adsources (such as .le descriptors) \nare systematically encapsulated in classes, all acquisitions of such resources are performed within constructors \nof the corresponding class, and all releases of such resources are performed within destructors of the \ncorresponding class. We cannot prove a general result guaranteeing the proper encapsulation of resources \nin classes: this is a matter of program veri.cation. We can, however, prove that in a terminating program \nevery construction of a subobject is correctly matched by a destruc\u00adtion. Theorem 16 (RAII). Consider \na partial program execution * Theorem 9 then follows directly from the two lemmas above. Using Lemma \n11 and the de.nition of .C[n], we have the follow\u00ading stronger special case: Theorem 12. If p2 is a subobject \nof p1, then the lifetime of p1 is included in that of p2. As a corollary of Theorem 9, it follows that \nif p1 is constructed before p2, then p2 is destructed before p1. Theorem 13 (Destruction in reverse order \nof construction). Let e be a complete object of type C[n] and p1,p2 be two subobjects of e. Consider \nthe reduction sequence below where p1 is constructed before p2, then later p1 is destructed: * * sinit \n. s1 . s2 where the transition s1 . s2 marks the end of a block statement that allocated the complete \nobject e. Then, between the initial state sinit and s1, the following events occurred, in this order: \n Every subobject of e was constructed exactly once.  Every subobject of e was destructed exactly once, \nin reverse order of construction.  Proof. The invariant INV implies that, at state s1, all cells of \nthe structure array e are Destructed, and so are all of their subobjects. Consider a subobject (e, p). \nIts state is Unconstructed in the initial state and Destructed in s1. Therefore, by the intermediate \nvalue theorem (Theorem 8), it must have entered state Constructed at s0 . s1 . s2 . s3 . s4 . s5 some \npoint, then left state Constructed at some later point, mean\u00ad(\u00acc1)(c1)(\u00acc2)(c2)(c1)(\u00acc1) ing that (e, \np) has been initialized once, then destructed once. The claim on construction and destruction order follows \nfrom Theo\u00ad (We write ci below a state s to denote that pi is Constructed in rem 13. state s, and \u00acci \nto mean that pi is not Constructed.) Then, there ex\u00ad ' 3,s 4 such that p2 stops being Constructed  \n4.7 Generalized dynamic types ' ist intermediate states s between these two states: We .nish this section \nwith interesting properties of generalized *' '* * s0 . s1 . s2 . s3 . s3 . s4 . s4 . s5 (\u00acc1)(c1)(\u00acc2)(c2)(c2)(\u00acc2)(c1)(\u00acc1) \ndynamic types, which were introduced in \u00a73.4 to give semantics to virtual function calls and dynamic \ncasts.  A B1B2 C B2B1 A A:    BC CS SD DB B1 C B1 B1: BCCS SDDB B2 C B2 B2:  BCCS SDDB C C: StartedConstructing \nBC CS SD DB Destructed BC = BasesConstructed; CS = Constructed; SD = StartedDestructing; DB = DestructingBases \n Figure 2. Evolution of the dynamic types of an instance of C and of its subobjects in the example of \n\u00a74.7. Dynamic types are unde.ned at points where the signal is low, and de.ned and equal to the indicated \ntype when the signal is high. Thick vertical transitions denote points where a compiled implementation \nmust update pointers to v-tables. Theorem 17. The generalized dynamic type of a subobject, if de.ned, \nis unique. Proof. The result is trivial if the most-derived object is Constructed, since it is then equal \nto the generalized dynamic type. Otherwise, we observe that the most-derived object can have at most \none base class subobject in state BasesConstructed or StartedDestructing (as a consequence of invariant \nINV ), and conclude. A subtle aspect of generalized dynamic types is that they do not continuously exist: \nas the construction or destruction of a most\u00adderived object proceeds, the generalized dynamic type of \none of its base-class subobjects alternates between de.ned and unde.ned. Consider the following program: \nstruc t A { virt u al void f ();}; struc t B1 : v i rtu a l A {}; struc t B2 : v i rtu a l A { virt u \nal void f ();}; struc t C : B1 , B2 {} Figure 2 shows the evolution of the dynamic type of an instance \nof C and of its subobjects while this instance undergoes construction then destruction. For example, \nduring the construction of base B2, the subobject B1 is already Constructed, but its generalized dynamic \ntype is unde.ned (the constructor of B1 has returned but C is not yet constructed), and calling f on \nB1 has unde.ned behavior. Theorem 18. Let (e, (a, i, s)) be a subobject and (e, (a, i, s.)) be its most \nderived object (i.e. s. =(Repeated,C :: E)). Consider a transition s . s ' where the construction state \nof (e, (a, i, s)) changes. Then, the generalized dynamic types for all subobjects in the program evolve \nas shown in Table 1. In a compiled implementation, dynamic types are materialized as extra .elds in the \nin-memory representations of objects, these .elds containing (in general) pointers to v-tables. When \nthe gen\u00aderalized dynamic type of a subobject is unde.ned, its dynamic type .eld can contain any value. \nHowever, when the generalized dynamic type is de.ned, the dynamic type .eld must contain a pointer to \nthe corresponding v-table. Theorem 18, therefore, pin\u00ad points exactly the program points where the compiled \ncode must update dynamic type .elds: when all bases of a subobject are con\u00adstructed, and just before \nthe construction of .elds begins, dynamic type .elds must be updated for the subobject in question and \nall of its bases; likewise, when the subobject undergoes destruction, at the point where the destructor \nis entered. 5. Impact on the C++ language speci.cation The development of the formal semantics reported \nin this paper uncovered several issues with the C++03 standard. They were re\u00adported to the ISO C++ committee. \nSome of them were .xed in time for the C++11 standards; others will be addressed in future revi\u00adsions. \nVirtual functions calls during object construction and destruction The formulation of ISO C++03 [6] of \nthe behavior of the abstract machine when a virtual function is called during construction (or destruction) \nwas unclear and did not clearly support the original intent (correctly modeled in this paper). This was \nreported to the ISO C++ committee as CWG issue number 1202. The formulation was clari.ed in time for \nadoption in C++11. Con.icting description of end of object lifetime Although the language formally de.ned \nin this paper does not allow explicit management of object lifetime, coming up with a simple, coherent, \nuni.ed, and faithful description of object lifetime led us to discover con.icts and unintended semantics \nin the ISO C++ documents (both C++03 and C++11.) The C++11 standard [7] has a con.icting description \nof the effect of calling a destructor. Two paragraphs (3.8p1 and 3.8p4) claim that an object s lifetime \nends when a call to a non-trivial destructor occurs or its storage is reused or released. However, another \nparagraph (14.2p4) claims that once a destructor is invoked (its triviality notwithstanding), the object \nno longer exists . This issue will be resolved after C++11 is published. We expect that for consistency, \nthe resolution will not consider triviality of the destructor to determine when an object s lifetime \nends. Effect of calling destructor for builtin types C++ allows an ex\u00adpression of the form p-> T() where \nT is a non-class type name and p is an expression that points to a T object. This form was introduced \nto support function templates explicitly managing object lifetime without forcing the author to distinguish \nbetween builtin types and class types. It was also intended to bring uniformity. However, the formulation \nof the behavior of the abstract machine appears to indi\u00adcate that the following program fragment has \na well-de.ned mean\u00ading, for any scalar type T. T f(T x) { T t = x; t. T(); return t; } This is in a clear \ncon.ict with the case where T is a class type. Indeed, for every class type T, that function leads to \nan unde.ned behavior, as it attempts to destroy the local variable t twice: once explicitly through the \ncall to the destructor and a second time im\u00adplicitly when the function exits. Finally, it appears that \nthe program is ill-formed (and a diagnostic is required) when T is an array type. Lifetime of array objects \nThe C++ standards explicitly indicate that the lifetime of an array object starts as soon as storage \nfor it has been allocated, regardless of when the lifetime of its elements starts. In general, a complete \nobject s lifetime starts after all its subobjects have been constructed. This irregularity appears to \nbe a hand-over from C in its formulation. It will be reconsidered after publication of C++11 along with \na more uni.ed treatment of the lifetime of objects of builtin types. 6. Application to veri.ed compilation \nTo strengthen con.dence in the semantics presented here and stress its usability, the .rst author developed \nand proved correct a simple compiler that translates the core language presented in this paper  When \nthe subobject goes from to then the gen. dynamic type of goes from to (e, (a, i, s)) Unconstructed StartedConstructing \n(e, (a, i, s ' )) Undef. Undef. (e, (a, i, s)) StartedConstructing BasesConstructed (e, (a, i, s@s '' \n)) (e, (a, i, s ' )) not a base of s Undef. Undef. s Undef. (e, (a, i, s)) with s = s. BasesConstructed \nConstructed (e, (a, i, s@s '' )) (e, (a, i, s ' )) not a base of s s Undef. Undef. Undef. (e, (a, i, \ns.)) BasesConstructed Constructed (e, (a, i, s ' )) s. s. (e, (a, i, s.)) Constructed StartedDestructing \n(e, (a, i, s ' )) s. s. (e, (a, i, s)) with s = s. Constructed StartedDestructing (e, (a, i, s@s '' )) \n(e, (a, i, s ' )) not a base of s Undef. Undef. s Undef. (e, a, i, s) StartedDestructing DestructingBases \n(e, (a, i, s@s '' )) (e, (a, i, s ' )) not a base of s s Undef. Undef. Undef. (e, (a, i, s)) DestructingBases \nDestructed (e, (a, i, s ' )) Undef. Undef. (e, (a, i, s)) Any Any (e' , (a ' , i ' , s ' )) with (e, \na, i) = (e' , a ' , i ' ) Does not change Table 1. Evolutions of generalized dynamic types when the \nstate of a subobject (e, (a, i, s)), of most-derived object s., changes. to a simple, non-object-oriented \nintermediate language similar to CompCert s Cminor [8]. This veri.cation is described in [12, chap\u00ad ter \n11]. The compiler proceeds in two passes, using as intermediate language the CoreC++ language of Wasserrab \net al. [18] extended with a setDynType operation that explicitly modi.es the dynamic type of an object. \nThe .rst translation pass is broadly similar to that outlined in Wasserrab s thesis [17], turning constructors, \ninitializers and de\u00ad structors into non-virtual function calls. However, setDynType op\u00aderations are inserted \nat the program points characterized by Theo\u00adrem 18 to implement the proper semantics for virtual function \ncalls and dynamic casts. Following a popular optimization, two versions of every constructor are generated, \none for the most derived case, the other for the inheritance subobject case. The second transla\u00adtion \npass extends our earlier work on object layout [13]. The proofs of semantic preservation are standard \narguments by forward simulation diagrams [8, \u00a73.7]. The proofs are rather big (about 8000 lines of Coq \nfor each pass) because there are many cases to consider, along with complex invariants relating execution \nstates, but present no major conceptual dif.culties. 7. Related work Formal semantics for C++ Norrish \n[10] describes a formal se\u00ad mantics for C++ that was mechanized in HOL. His semantics de\u00adscribes a much \nlarger subset of C++ than ours, including in partic\u00adular expressions with side effects and partially-speci.ed \nevaluation order, exceptions, free store (new and delete), and temporary ob\u00adjects. Construction and destruction \nare modeled by dynamic trans\u00adlation : the reduction rule for the construction of an object produces on \nthe .y a statement containing the necessary invocations of initializers and constructors for .elds and \nbases; this statement is, then, reduced normally. As a way to state the semantics, Norrish s approach \nis arguably simpler than our small-stepping of the con\u00adstruction/destruction protocol. However, we suspect \nthat Norrish s approach would make it more dif.cult to prove meta-properties about construction states \nand lifetimes, in the style of \u00a74. Addition\u00ad ally, we suspect that Norrish s semantics does not correctly \ncapture the interaction between construction, destruction, and virtual func\u00adtion calls. Consider: struct \nB { B* b; virtual int f() { return 18; } B() : b(this) { } }; struct D : B { virtual int f() { return \n42; } }; int main () { D d; return d.b->f(); }; In B s constructor, the initialization b(this) saves \nin b a pointer whose dynamic type is B (correctly, at that time). However, after completion of D s constructor, \nthe dynamic type of *b is not updated to D, causing the wrong f virtual function to be dispatched in \nmain. The CoreC++ semantics of Wasserrab, Nipkow, Snelting and Tip [18] is a major starting point for \nour work. It does not cover ob\u00ad ject construction and destruction. Wasserrab s Ph.D. thesis [17] de\u00ad \nscribes this semantics and its Isabelle/HOL formalization in greater details, as well as a static, unveri.ed \ntranslation of construction and destruction into non-virtual function calls. This translation fails to \ncorrectly implement C++ s semantics for virtual function calls: in the translated program, the dynamic \ntype of a subobject is always its most derived object, regardless of construction state. We are not aware \nof any other formal semantics for C++ that addresses construction and destruction. Type systems for safe \nobject initialization Several research projects develop type systems for object-oriented languages that \nenforce safety guarantees about object initialization, such as the fact that well-typed programs never \nread .elds of an uninitialized object. F\u00a8ahndrich and Xia [3] introduce a type system to remove useless \n.eld initializations to null while still ensuring safe object initialization. Qi and Myers [11] introduce \na more general type system to precisely and statically determine, at each program point, which .elds \nmay be read or not. Hubert et al. [5] formalize a type system for safe Java object initialization using \nthe Coq proof assistant. Their type system shares with our operational semantics the use of construction \nstates for objects, but in their case, construction states are lifted to the type level and maintained \nat compile-time. This enables their system to statically check contracts over methods that constrain \nthe construction states of some of the arguments, for instance. Our work makes no attempt at providing \nstatic typing safety properties beyond the few offered by C++. Instead, we aim at a precise description \nof the dynamic semantics of construction and destruction in the presence of multiple inheritance. The \ntype systems mentioned above are based on the Java and C# single\u00adinheritance object models. Moreover, \nthey only deal with object initialization, without object destruction or .nalization. Indeed, in Java, \nobject .nalization is weakly speci.ed: although the Java language speci.cation [4] requires objects to \nbe .nalized, it does not describe more precisely when object .nalization should occur. C# offers a destruction \nmechanism, namely object disposal, but it must be called explicitly by the programmer.  8. Extending \nthe semantics Our semantics presents the core features of C++ object construc\u00adtion and destruction as \nfaithfully as possible towards the Standard. However, it can be extended in a number of directions. Manual \nmemory management We anticipate no dif.culties with supporting free store objects, i.e. the new and delete \noperators. Only slight modi.cations to the operational semantics appear nec\u00adessary. Of course, Theorem \n14 would be invalidated, since objects no longer follow a stack discipline. However, it appears very \ndif\u00ad.cult to formalize more general manual memory management, al\u00adlowing for instance explicit destructor \ncalls and the use of place\u00adment operators such as new(p) C to construct an object at a given memory location. \nTemporary objects of class types Expression evaluation, passing arguments by value to functions, or returning \nresults by value en\u00adtail construction and destruction of temporary objects. While the lifetime of these \nobjects are well-de.ned by the C++ standard (and they follow a .rst-constructed-last-destroyed discipline), \ntheir storage durations are not speci.ed. In fact, we found inconsisten\u00adcies between the de.nitions of \nstorage duration as speci.ed by the C++11 standards and the C99 standards. Accounting for temporary objects \nbeyond scalar values returned by functions or passed as ar\u00adguments will require nontrivial extensions \nto our semantics. Copy constructor elision More challenging is to give semantics to functions that return \nvalues of class types. They are objects constructed in the callee but destroyed in the caller at the \nend of the full expression containing the call. For decades, C++ has allowed elision of copy constructors \n(even if they have observable behavior) that would normally copy a local object to the (temporary) return \nvalue, provided certain non-aliasing conditions (easy to check) are met. These program transformations \nare necessary in practice to obtain good performance but are not semantics-preserving in the traditional \nsense. The same caveat applies for the C++11 notion of move constructors . Exceptions It is easy to capture \na key aspect of C++ exceptions in our semantics: block-scoped objects are properly destroyed when an \nexception is thrown. Exception objects are temporary objects with lifetime dynamically controlled by \nexception handlers acting much like function invocations with the exception object as argu\u00adment. C++ \nallows catching exceptions by value, so our observations for function call argument by value apply here. \nFurthermore, the se\u00admantics of constructors need to be altered to invoke destructors for completely constructed \nsubobjects in presence of exception. Sim\u00adilarly, the semantics for destructors should be altered to include \nprogram abortion if a subobject destructor raises an exception. Fi\u00adnally, interaction between construction \nof dynamic objects and ex\u00adceptions (both of which re.ect related design decisions) should be investigated. \nThese features are at the basis of generalized RAII techniques for dynamically controlled resources; \npopular examples include smart pointers such as unique_ptr and smart_ptr. 9. Concluding remarks We hope \nthat this work sheds light on the precise semantics of con\u00adstruction and destruction in C++ and what \nthey actually guaran\u00adtee to the working programmer. Several features remain to be ad\u00addressed, but the \nsubset that was formalized is already quite realistic and similar to recommended subsets for critical \nembedded systems [9]. The semantics implements a pattern for small-stepping a tree traversal which could \nperhaps be generalized and abstracted over. Finally, it would be interesting to exploit this semantics \nin the con\u00adtext of type systems and other static analyses that verify stronger safety properties about \ninitialization. References [1] The Coq proof assistant, 1999 2012. URL http://coq.inria.fr. [2] M. A. \nEllis and B. Stroustrup. The Annotated C++ Reference Manual. Addison-Wesley, 1990. [3] M. F\u00a8ahndrich \nand S. Xia. Establishing object invariants with delayed types. In 22nd conf. on Object-Oriented Programming \nSystems and Applications (OOPSLA 07), pages 337 350. ACM, 2007. [4] J. Gosling, B. Joy, G. Steele, and \nG. Bracha. The Java Language Speci.cation. Addison Wesley, 3rd edition edition, 2005. [5] L. Hubert, \nT. Jensen, V. Monfort, and D. Pichardie. Enforcing secure object initialization in Java. In Computer \nSecurity ESORICS 2010, volume 6345 of Lecture Notes in Computer Science, pages 101 115. Springer, 2010. \n[6] International Standard ISO/IEC 14882:2003. Programming Lan\u00adguages C++. International Organization \nfor Standards, 2003. [7] International Standard ISO/IEC 14882:2011. Programming Lan\u00adguages C++. International \nOrganization for Standards, 2011. [8] X. Leroy. A formally veri.ed compiler back-end. Journal of Auto\u00admated \nReasoning, 43(4):363 446, 2009. [9] Lockheed Martin. Joint Strike Fighter Air Vehicle C++ Coding Stan\u00addards \nfor the System Development and Demonstration Program, 2005. URL http://www.research.att.com/ bs/JSF-AV-rules.pdf. \n[10] M. Norrish. A formal semantics for C++. Technical report, NICTA, 2008. [11] X. Qi and A. C. Myers. \nMasked types for sound object initialization. In 36th symp. Principles of Programming Languages (POPL \n09), pages 53 65. ACM, 2009. [12] T. Ramananandro. Mechanized Formal Semantics and Veri.ed Com\u00adpilation \nfor C++ Objects. PhD thesis, Universit\u00b4 e Paris Diderot, Jan. 2012. [13] T. Ramananandro, G. Dos Reis, \nand X. Leroy. Formal veri.cation of object layout for C++ multiple inheritance. In 38th symp. Principles \nof Programming Languages (POPL 11), pages 67 80. ACM, 2011. [14] J. G. Rossie and D. P. Friedman. An \nalgebraic semantics of subobjects. In 10th conf. on Object-Oriented Programming, Systems, Languages, \nand Applications (OOPSLA 95), pages 187 199. ACM, 1995. [15] B. Stroustrup. Classes: An abstract data \ntype facility for the C lan\u00adguage. SIGPLAN Not., 17:42 51, January 1982. [16] B. Stroustrup. The design \nand evolution of C++. ACM Press/Addison-Wesley Publishing Co., New York, NY, USA, 1994. [17] D. Wasserrab. \nFrom Formal Semantics to Veri.ed Slicing A Modular Framework with Applications in Language Based Security. \nPhD thesis, Karlsruher Institut f\u00a8ur Technologie, Fakult\u00a8at f\u00a8ur Informatik, Oct. 2010. [18] D. Wasserrab, \nT. Nipkow, G. Snelting, and F. Tip. An operational semantics and type safety proof for multiple inheritance \nin C++. In 21st conf. on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 06), \npages 345 362. ACM, 2006.  \n\t\t\t", "proc_id": "2103656", "abstract": "<p>We present a formal operational semantics and its Coq mechanization for the C++ object model, featuring object construction and destruction, shared and repeated multiple inheritance, and virtual function call dispatch. These are key C++ language features for high-level system programming, in particular for predictable and reliable resource management. This paper is the first to present a formal mechanized account of the metatheory of construction and destruction in C++, and applications to popular programming techniques such as \"resource acquisition is initialization\". We also report on irregularities and apparent contradictions in the ISO C++03 and C++11 standards.</p>", "authors": [{"name": "Tahina Ramananandro", "author_profile_id": "81350579834", "affiliation": "INRIA Paris-Rocquencourt, Le Chesnay, France", "person_id": "P2991299", "email_address": "tahina.ramananandro@inria.fr", "orcid_id": ""}, {"name": "Gabriel Dos Reis", "author_profile_id": "81309496659", "affiliation": "Texas A&#38;M University, College Station, TX, USA", "person_id": "P2991300", "email_address": "gdr@cs.tamu.edu", "orcid_id": ""}, {"name": "Xavier Leroy", "author_profile_id": "81100078576", "affiliation": "INRIA Paris-Rocquencourt, Le Chesnay, France", "person_id": "P2991301", "email_address": "xavier.leroy@inria.fr", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103718", "year": "2012", "article_id": "2103718", "conference": "POPL", "title": "A mechanized semantics for C++ object construction and destruction, with applications to resource management", "url": "http://dl.acm.org/citation.cfm?id=2103718"}