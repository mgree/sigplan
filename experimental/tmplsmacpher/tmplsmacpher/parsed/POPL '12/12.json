{"article_publication_date": "01-25-2012", "fulltext": "\n Symbolic Finite State Transducers: Algorithms and Applications Margus Veanes Pieter Hooimeijer * Benjamin \nLivshits Microsoft Research University of Virginia Microsoft Research margus@microsoft.com pieter@cs.virginia.edu \nlivshits@microsoft.com David Molnar Nikolaj Bj\u00f8rner Microsoft Research Microsoft Research dmolnar@microsoft.com \nnbjorner@microsoft.com Abstract Finite automata and .nite transducers are used in a wide range of applications \nin software engineering, from regu\u00adlar expressions to speci.cation languages. We extend these classic \nobjects with symbolic alphabets represented aspara\u00admetric theories. Admitting potentially in.nite alphabets \nmakesthis representation strictly moregeneral and succinct than classical .nite transducers and automata \nover strings. Despite this, the main operations, including composition, checking that a transducer is \nsingle-valued, and equivalence checking for single-valued symbolic .nite transducers are e.ective given \na decision procedure for the background the\u00adory. We provide novel algorithms for these operations and \nextend composition to symbolic transducers augmented with registers. Our base algorithms are unusual \nin that they are nonconstructive, therefore, we also supply a separate model generation algorithm that \ncan quickly .nd counterexam\u00adples in the case two symbolic .nite transducers are not equivalent. The algorithms \ngive rise to a complete decidable algebra of symbolic transducers. Unlike previous work, we do not need \nany syntactic restriction of the formulas on the transitions, only a decision procedure. In practice \nwe lever\u00adage recent advances in satis.ability modulo theory (SMT) solvers. We demonstrate our techniques \non four case stud\u00adies, covering a wide range of applications. Our techniques can synthesize string pre-images \nin excess of 8, 000 bytes in roughly a minute, and we .nd that our new encodings signi.cantly outperform \nprevious techniques in succinctness and speed of analysis. Categories and Subject Descriptors D.2.4 [Software \nEngineering]:Software/ProgramVeri.cation; F.4.1[Math\u00adematical Logic and Formal Languages]: Mathematical \nLogic * Work done while the author visited Microsoft Research. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made ordistributedforpro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. POPL 12, January 25 27, 2012, Philadelphia, PA, \nUSA. Copyright c . 2012ACM978-1-4503-1083-3/12/01. ..$10.00 General Terms Algorithms, Theory, Veri.cation \nKeywords Automata, Composition, Equivalence, SMT 1. Introduction Finite automata are used in a wide range \nof applications in software engineering, from regular expressions to spec\u00adi.cation languages. Nearly \nevery programmer has used a regular expression at one point or another to parse logs or manipulate text. \nFinite transducers are an extension of .\u00adniteautomatato modelfunctions onlists of elements,which in turn \nhave uses in .elds as diverse as computational lin\u00adguistics and model-based testing. While this formalism \nis of immense practical use, it su.ers from certain drawbacks: in thepresenceoflargealphabets,they can \nblowup inthe number of transitions, as each transition can encode only one choice of element from the \nalphabet. Furthermore, the most common forms cannot handle in.nite alphabets. Symbolic .nite transducers \n(SFTs) are an extension of traditional transducers that attempt to solve theseproblems byallowing transitionstobelabeled \nwith arbitraryformulas in a speci.ed theory. While the concept is straightforward, traditional algorithmsfordeciding \ncomposition, equivalence, and other properties of .nite transducers do not immedi\u00adately generalize to \nthe symbolic case. In particular, previ\u00adous work on symbolic .nite transducers have needed to im\u00adpose \nrestrictions on character theories to achieve decidable analysis [1, 38]. Our work breaks this barrier \nand allows for arbitraryformulasfrom any decidable background theory. In practice, we leverage the recent \nprogress in satis.ability modulotheory(SMT) solverstoprovidethisdecisionpro\u00adcedure.We .nd that ouralgorithms \narefast when used with Z3, a state of the art SMT solver. The restriction we do make on SFTs is a semantic \none: that the SFT is single-valued. This restriction is needed be\u00adcause equivalence is undecidable even \nfor standard .nite transducers.The single-valuednessproperty isdecidablefor symbolic .nite transducers. \nThis gives us a way to check transducers arising from practical applications before ap\u00adplying our algorithms. \nWhile it was previously known that equivalence was de\u00adcidable for single-valued .nite transducers, again \nit does not immediately follow that equivalence should be decidable for single-valued symbolic .nite \ntransducers because typically  E.ective closure Equivalence Alphabet under composition Finite State \nTransducers closed undecidable in general [23], decidable for .nite set of elements, com\u00ad single-valued \ncase [43] and .nite-valued parable with equality case [12, 50] Streaming Transducers [1] closed(for \n.nite alphabets) decidable total orders(in.nite) Symbolic Finite Transducers closed(Proposition1) decidable \nfor single-valued case (Theo-any decidable theory rem 2) Symbolic Transducers closed undecidable (alreadyfor \nthe single-valued any decidable theory (extension of Proposition 1) case, throughdirect encodingof 2-counter \nmachines) Figure 1. Summary of decidability results. The bottom two rows summarize our contributions. \nCase study Section Feature HTMLDecode 4.1 ST representation compact\u00adness, integer-linear arith\u00admetic \nMalware .ngerprinting 4.2 SFT composition for pro\u00adgram analysis Image blurring 4.3 non-string module \ntheory Location privacy 4.4 stream manipulating pro\u00adgrams Figure 2. Summary of case studies. even very \nrestricted extensions of .nite automata and .nite transducersleadto undecidability of thecoredecisionprob\u00adlems. \nIn fact, our proof requires a delicate separation be\u00adtweenthe automatatheoretic partsof ouralgorithmsand \nthe use of the decision procedure. Unusually, our algorithm for deciding equivalence is nonconstructive: \nwhile we can determine that two symbolic .nite automata are not equiv\u00adalent, our proof does not provide \na way to .nd a counterex\u00adample. Fortunately, we provide a separate model generation semi-decisionprocedurethatcan \n.nd counterexamplesonce it is known that two automata are not equivalent. Figure 1 summarizes known results \nabout .nite state transducers(oversequences) and extensionsthereof,focus\u00ading on thekeyproperties studiedin \nthispaper, namelyfunc\u00adtional compositionality, decidability of equivalence, and the role of the alphabet, \nin order to place our contributions in a clear context.InSection3.2we compare our main techniques to \nclosely related techniques used for streaming transduc\u00aders [1]. Section 5 describes further related work, \nincluding work on extending automata to trees. 1.1 Applications Section 4 presents four comprehensive \ncase studies in dif\u00adferent areas. Our .rst case study extends previous work in using symbolic .nite transducers \nto model web sanitization functions [4]. Our techniques allow the addition of regis\u00adter variables, which \nenable encoding a sanitizer that could not be handled e.ciently by previous symbolic approaches. Our \nsecond case study shows an application to analysis of Javascript malwarefound ontheWeb.Ourthird andfourth \ncase studies showcase additional theories beyond strings. Figure 2 summarizes how each case study re.ects \na novel feature of our work. In addition to these case studies, .\u00adnite transducers have been employed \nin other areas such as analysis of web sanitization frameworks, host-based intru\u00adsion detection, and \nnatural language processing. Our work immediately applies to these application domains. 1.2 Contributions \nOur contributions are the following: We present novel algorithms for composition and equiv\u00adalence checking \nof symbolic .nite transducers. Our al\u00adgorithms, unlike previous work, make no restrictions on the formulae \nused in the transducers: we require only a decision procedure for the background theory.  We showthatthe \nsingle-valuednessproperty of symbolic transducers is decidable. This gives rise to a decidable complete \nalgebra of symbolic transducers. The impact is that single-valued symbolic transducers can now be .rst \nclass objects for constructing program analyses.  We present four case studies that demonstrate how \nour new algorithms enable new applications.Wedemonstrate experimentally that our algorithms not only \nterminate, but that they run quickly in practice for problem in\u00adstances of interest.   1.3 Paper Organization \nThe restofthispaperis structuredasfollows.InSection2we provideanintroductiontosymbolic .nitestatetransducers. \nSection 3 describes the core transducer-based algorithms. Section 4 provides four detailed case studies \nof transducer use.Finally,wediscussclosely related workinSection5 and conclude in Section 6. 2. Symbolic \nFinite Transducers Wenowformally de.nesymbolic .nitetransducers,wegive examples of how these objects \nmodel program behavior, and we de.ne analyses that may be conducted on such transducers. We assume a \nbackground structure that has an e.ectively enumerable(countable)multi-typedcarrier set or background \nuniverse U, and is equipped with a language of function and relation symbols with .xed interpretations. \nWe use t , s and . to denote types, and we write Ut for the corresponding sub-universe of elements of \ntype t . As a convention, we abbreviate Us byS and U. by G, because these symbols are usedfrequently.TheBoolean \ntype is B, with UB = {t, f} and the integer type is Z. Terms and formulas are de.ned by induction over \nthe background language and are assumed to be well-typed. The type t of a term t is indicated by t :t \n. Terms of type B, or Boolean terms, are treated as formulas, i.e., no distinction is made between formulas \nand Boolean terms. All elements in U are also assumed to have corresponding constants in the background \nlanguage and we use elements in U also as constants. The set of free variables in a term t is denoted \nby FV(t), t is closed when FV(t)= \u00d8, and closed terms t have Tarski semantics [ t] over the background \nstructure.  Substitution of a variable x :t in t by a term u :t is denoted by t[x/u]. A .-term f is \nan expression of the form .x.t, where x :s is a variable, and t :. is a term such that FV(t).{x}; the \ntype of f is s . .;[ f ] denotes the function that maps a . S to[ t[x/a]] . G. As a convention, we use \nf and g to stand for .-terms. A .-term of type s . B is called a s-predicate. We write . and . for s-predicates \nand, for a . S, we write a . [ .] for [ .] (a)= t. We often treat [ .] as a subset of S. Given a .-term \nf =(.x.t):s . . and a term u :s, f (u) stands for t[x/u] (i.e., we assume implicit \u00df-reduction). A predicate \n. is unsatis.able when [ .] = \u00d8; satis.able, otherwise. The following is a key notion in the paper. Two \n.\u00adterms f, g :s . . are equivalent relative to a s-predicate ., denoted f =. g, when f =. g is unsatis.able, \nwhere def f =. g = .x..(x).f (x) g(x) = is called the di.erence predicate of f and g relative to .. De.nition1: \nAlabel theory for s . . is associated withan e.ectively enumerable set of .-terms of type s . . and an \ne.ectively enumerable set of s-predicates that is e.ectively closed under Boolean operations and relative \ndi.erence. E.ective closure underBoolean operationsinDe.nition1 means that [ . . .] =[ .] n [ .] and \n[ \u00ac.] =S \\ [ .] . An important and direct consequence is the following: [ \u00ac(f =. g)] =[ .x.\u00ac(.(x).f (x) \ng(x))] . = Inparticular,itis notpossible to express relative equivalence of .-terms directly, other than \nthrough unsatis.ability of a di.erence predicate. This is important in order to maintain our decidability \nresults while making minimal assumptions about the label theory. In our use of label theories below, \ndi.erencepredicatesplay acentral roleand arealwaysused in apositive context(i.e., not negated as above). \nA label theory . is decidable when satis.ability for . . ., IsSat(.), is decidable. We assume an e.ective \nwitness function for a s-predicate . such that, if IsSat(.) then witness(.). [ .] . Example 1: As an \nexample of a decidable label theory for (Z \u00d7 Z) . Z, consider the combined theory of pairs and quanti.er-free \ninteger linear arithmetic. Suppose p1 and p2 are the projection functions from pairs. Let f be .x.(2* \np1(x)), let g be .x.(p1(x)+ p2(x)), and let . be .x.(p1(x)= p2(x)). Thenf and g are equivalent relative \nto ., because f =. g is unsatis.able, i.e., .x.(p1(x)= p2(x).2* p1(x) = p1(x)+p2(x)) is unsatis.able. \nGiven a set X, we write X * for the Kleene closure of X. Similarly, t * is the type of sequences over \nt . A sequence of length k = 0 is denoted either by [x0,...,xk-1] or x with xi as the i th element of \nx for 0 = i< |x|. Next, we describe an extension of .nite state transducers through a symbolic representation \nof labels. The advantage of theextensionis succinctness and modularity with respect to any given label \ntheory. It naturally separates the .nite state transition graph from the label theory. De.nition 2: A \nSymbolic Finite Transducer (SFT) over s . . is a tuple(Q, q0, F, R), where Q is a .nite set of states, \nq 0 . Q is the initial state, F . Q is the set of .nal states, and R is a set of rules (p, ., f ,q), \nwherep, q . Q, . is a s-predicate and, f , is a a sequence of .-terms, over a given label theory for \ns . .. ./f We use the more intuitive notation p --.A q for a rule (p, ., f ,q). RA and call . its guard. \nWe omit the index A when A is clear from the context. We treat f :(s . .) * as a function .x . [f 0(x),..., \nf k(x)] where k = |f |- 1. We lift the de.nition of relative equivalence of .-terms to sequences f and \ng of .-terms: f =. g i. |f |= |g| and for all i,0 = i< |f |, f i =. gi. We use the notation of rules \nto also denote concrete transitions when the intension is clear. For p, q . QA, a . S and b . G * : a/b \n./f p --.A q if for some p --.A q . R: a . [ .] , b =[ f ] (a) a/b i.e., the transition p --. q is an \ninstance of a rule. Concate\u00adnation of two sequences seq1 and seq2 is denoted seq1 \u00b7 seq2. a/b De.nition \n3: For a . S * and b . G * , p --. A q denotes the reachability relation: there exists a path of transitions \nfrom p to q in A with input sequence a and output sequence b: let n = |a|-1, when there exist subsequences \nbi, such that b = \u00b7 \u00b7\u00b7\u00b7 bn and b0 b1 01 a0 /ba1 /ban/bn p = p0 - --. p1 - --. p2 \u00b7\u00b7\u00b7 pn ----. pn+1 = \nq 0/0 We let p - . A p for all p . QA. De.nition 4: The transduction of A, denoted TA, is the following \nfunction from S * to 2G * : def * 0 a/b TA(a)= {b . G |.q . FA (qA --. q)}. Equivalently, TA is viewed \nas the binary relation, or subset of S * \u00d7G * , such that TA(a, b)i. b . TA(a). Thedomain of def S * \n| A is D(A)= {a . TA(a)= \u00d8}. The following subclass of SFTs captures transductions that behave as partial \nfunctions from S * to G * . De.nition 5: A is single-valued when |TA(a)|= 1 for all a . S * . A su.cient \ncondition for single-valuedness is determin\u00adism. ./f De.nition 6: A is deterministic when, for all p \n--.A q ./g and p --.A r, if IsSat(. ..)then q = r and f =... g. In terms of concrete transitions, determinism \nof A means ! a/b a/b that if p --.A q and p - -.A q I then (b,q) =(bI ,q I). It a/b follows by induction \nover |a| for a . S * that, if p --. A q then(b,q)is uniquefor thegivenp anda,inparticular when 0 p = \nqA andq . FA, andthus A is single-valued.Determinism is, however, not a necessary condition for single-valuedness, \nas is illustrated below. In the following examples, all SFTs are single-valued. The .rst example illustrates \na few simple functional list transformations, expressed as deterministic SFTs that illustrate how global \nproperties of SFTs depend on the theory of labels. Example 2: Let the input type and the output type \nbe Z. All SFTs have a single state here. Predicates and terms are terms in integer linear arithmetic. \nNegate multiplies all ele\u00adments by -1. Increment adds 1 to each element. DeleteZeros deletes all zeros \nfrom the input. .x.t/[.x.(-x)] RNegate = {p ---------. p} .x.t/[.x.(1+x)] RIncrement = {q - --------. \nq} .x.(x=0)/[].x.(x =0)/[.x.x] RDeleteZeros = {r -------. r, r ----------. r}  Properties such as commutativity \nand idempotence of SFTs dependon the theory oflabels.For example, whether Negate and DeleteZeros commute \nor whether DeleteZeros is idem\u00adpotentdependonproperties ofinteger addition and multipli-cation.Noneof \ntheexamplescanbeexpressed astraditional .nite state transducers over a .nite alphabet. Our results about \ncomposition and equivalence checking, discussed be\u00adlow, allow us to e.ectively establish such properties \nmodulo decidability of a given label theory. Thefollowing exampleillustrates a commonstring trans\u00adformation \nwhere the use of nondeterministic SFTs is essen\u00adtial. Example 3: Suppose that the following C# code is \nin\u00adtended to implement a function GetTags that extracts from agiveninput stream of characters all substreams \nof theform [ < , x, > ], where x = < . For example GetTags(\"<<s><<>><f><t\")= \"<s><>><f>\" 1: int q = 0; \nchar c = (char)0; 2: foreach (char x in input) { 3: if (q == 0){ if (x == < ) q=1; else q=0;} 4: else \nif (q == 1) {if (x == < ) q=1; else q=2;} 5: else if (q == 2) { if (x == > ) { yield return < ; yield \nreturn c; 7: yield return > ;} 8: q=0; } 9: c=x; } Note that the variable q keeps track of the relative \npo\u00adsition in the pattern [ < , x, > ] and c records the previous character. The corresponding single-valued \nSFT is:1 (x= > )/[x] GetTags is nondeterministicbecause there are two rulesfrom q1 to q2 and q3, respectively, \nyielding di.erent outputs for thesameinput.If thecharactersare represented asintegers, then a deterministic \nversion of GetTags does not exists, and if the characters are represented as 16-bit bitvectors (that \ncorresponds precisely to the standard UTF-16 encoding of characters in C#) then the size of the equivalent \ndetermin\u00adisticSFTis216 timeslarger.(Example7below explainshow GetTags is constructed from the C# code.) \n3. SFT Algorithms In this section we study algorithms for composition and equivalence of SFTs. First, \nwe show that SFTs are e.ec\u00adtively closed under composition. Next, we provide an e.\u00adcient algorithm for \nsingle-valued equality of SFTs modulo a decidable theory of labels. Finally we introduce an algebra of \nSFTs that enables a variety of practically useful decision problems, such as deciding single-valuedness, \nand deciding commutativity and idempotence of single-valued SFTs. 1 We omit . s in .gures for a more \ncompact view. 3.1 Composition of SFTs Given two transductions T1 and T2, T1 . T2 denotes the following \nfunction: def T1 .T2 = . b. T2(a). a.T1 (b) Thisde.nitionfollows the conventionin[21].Notice that . \napplies .rst T1, then T2, contrary to how . is used for stan\u00addard function composition. Note also that \nsingle-valuedness is trivially preserved by composition. We say that label theories for s . t and t . \n. are composable if there is a label theory . for s . . such that if f :s . t and g :t . . are a .-terms \nthen .x.g(f (x)) is a valid .-term in ..  if . is a t -predicate and f :s . t is a .-term, then .x..(f \n(x))is a valid s-predicate in ..  Proposition 1: Let A and B be SFTs over composable label theories. \nThen there exists an SFT A . B that is obtained e.ectivelyfrom A and B such that TA.B = TA .TB . The \nalgorithm for A .B can be implemented with a DFS procedure that,byassuming decidability of thelabel theory, \neliminatesincrementally all composed rules thathave unsat\u00adis.able guards and .nally eliminates all deadends \n(deadlock states: states from which no .nal state is reachable).  3.2 Equivalence of SFTs Weintroduce \nan algorithmfordecidingequivalence of single\u00advalued SFTs.Whilegeneral equivalenceof .nitestatetrans\u00adducers \nis undecidable [23] the undecidability is caused by allowing unboundedly many di.erent outputs for a \ngiven input. Single-valued transducers, furthermore, correspond closely to functional transformations \nover lists computed by concrete programs. As illustrated above, this does not (in general) rule out nondeterministic \nSFTs. SFTs A and B are equivalent, A = B, when TA = TB . Deciding A = B reduces to two independent tasks: \nDomain equivalence : D(A)= D(B). Partial equivalence :(.a . D(A)nD(B))TA(a)=TB (a) A symbolic .nite automaton \nor SFA is an SFT all of whose outputs are empty. Let d(A)denote theSFAobtained from theSFT A by replacing \nall outputsby E.Then D(A)= D(B) i. d(A) = d(B). Equivalence of SFAs is decidable over decidable label \ntheories [48]. The decidability of SFA equivalencedepends on the assumption that thelabel theory is closed \nunder complementation, this assumption is not needed for partial equivalence. For developing a decision \nprocedure for partial equiva\u00adlence of single-valued SFTs we use the following weak form of partial equivalence. \n1 Single-valued equality(or1-equality A = B) : .abc ((b . TA(a).c . TB (a)). b = c) 1 Proposition 2: \nA is single-valued i. A = A. If A and B 1 are single-valued then A = B i. A and B are partially equivalent. \nSingle-valued equality of two SFTs A and B may fail for two reasons.Thereis aninput a . D(A)nD(B)and \noutputs b . TA(b)and c . TB (a)such that: 1. A has a length-con.ict with B: |b|= |c|.  2. A has a position-con.ict \nwith B: |b|= |c|and, for some position i,0 = i< |b|, bi = ci. We introduce the following basic product \nconstruction of SFTs as ageneralization oftheproduct ofSFAs[48]. The product construction is most e.ectively \nrealized by using a DFS procedure. Note that the product of SFTs is a 2\u00adoutput-SFT (SFTs are not closed \nunder product). De.nition 7: The product of SFTs A and B, denoted A \u00d7 B, is de.ned as the least .xpoint \nof pair states Q . QA \u00d7 QB and rules under the following conditions: 00 (qA,qB ). Q, ./f ./g if(p1,p2). \nQ, p1 --.A q1, and p2 --.B q2, then (q1,q2). Q and .../(f ,g)  (p1,p2)- -----.A\u00d7B (q1,q2), provided \nthat IsSat(. ..). All deadends, noninitial states from which FA \u00d7 FB is not reachable, are eliminated \nfrom A \u00d7 B. Example 4: Consider the SFT GetTags in Example 3. ./(f ,f ) Then theproductGetTags\u00d7GetTagshas \nrules(p, p)- ---. ./f (q, q)for all rules p --.GetTags q and no other rules due to elimination of deadends, \ne.g., (q3,q2) is a deadend because theguard of(the onlypossible rule) .x.(x= > .x= > )/([.x.x],0) (q3,q2)-----------------. \n(q0,q0) from(q3,q2)is unsatis.able. Let D(A \u00d7B)denote the set of inputs that are accepted by the product. \nIt follows from the product construction that: D(A \u00d7 B)= D(A)nD(B). (1) The reachability relation is \nlifted to A \u00d7B and thefollowing holds for p =(p1,p2),q =(q1,q2). QA\u00d7B : a/(b,c)a/ba/c p - ---. A\u00d7B q \n. p1 --. A q1 .p2 --. B q2. (2) We omit the index A \u00d7B when it is clear from the context. For q . QA\u00d7B \n, and k = 0, de.ne the o.set relation, def 0 a/(b,c) q /k = .abc (qA\u00d7B - ---. q .k = |b|-|c|) (3) The \nintuition behind q / k is that, for some common input a, there exists an output b from A thatis eitherahead \nof an output c from B with k-positions at product state q when k> 0, or behind when k< 0. The following \nlemma is used to detect length-con.icts. Lemma 1: If there exists q . QA\u00d7B and m = n such that q / m \nand q / n then A has a length-con.ict with B. Moreover, A has a length-con.ict with B i. there exists \nq . FA\u00d7B and m =0 such that q /m. Lemma 1 suggests an e.cient DFS algorithm to detect if a length-con.ict \nexists and otherwise computes the .xed o.set o.s(p) such that p / o.s(p). In order to decide if a position-con.ict \nexists between A and B, we .rst assume that A and B have no length-con.icts and assume that o.s(p)is \nde.nedand o.s(p)=0for p . FA\u00d7B . We say that (a, \u00df). G * \u00d7 G * is a promise of a product state p . QA\u00d7B \nwhen the following holds: a/(b\u00b7a,c\u00b7\u00df) 0 (a = E .\u00df = E)..abc (|b|= |c|.qA\u00d7B -------. p) It follows that \n{ (o.s(p), 0), if o.s(p)= 0; (|a|, |\u00df|)= (0, -o.s(p)), otherwise. 1 Lemma 2: If A = B then each product \nstate in QA\u00d7B has a .xed promise. 1 Proof. Assume A = B. Suppose, by way of contradiction, that there \nexists p . QA\u00d7B with two distinct promises (a, \u00df) and (aI,\u00dfI). By Lemma 1 we know that |a| = |aI| and \n|\u00df| = |\u00dfI| and either a = E or \u00df = E. Suppose \u00df = E (the case a = E is symmetrical). Thus a = (or else \nthe aI promises areidentical).By de.nition ofpromisesthereexist I , bI |c|, |bI|I|, a, b, c, a , c I \nsuch that, |b|== |c a/(b\u00b7a,c) a !/(b! \u00b7a! ,c !) q 0 ------. p, q 0 --------. p. A\u00d7BA\u00d7B II , bII II f \nSince p is not a deadend, there exist a , c and q . FA\u00d7B such that !!/(b!! !!) a ,c p -------. q f . \n1 It follows from A = B that bII . TA(b \u00b7 bII} b \u00b7 a \u00b7 ) bII II II . TB (a \u00b7 II) . b \u00b7 a \u00b7 = c \u00b7 c c \n\u00b7 ca bI \u00b7 aI \u00b7 bII . TA(a I \u00b7 a II) }bII III I II . I II) . bI \u00b7 aI \u00b7 = c \u00b7 c c \u00b7 c TB (a \u00b7 a and, since \n|b|= |c|and |bI|= |c I|, it follows that a \u00b7 bII = c II bII II and aI \u00b7 = c , contradicting that a = \naI . Lemma 2 can be used to check for non-1-equality as follows: In a depth-.rst manner compute for every \nstate in the product QA\u00d7B the current promise (a, \u00df). If the state 1 gets revisited with a di.erent promise, \nthen A = B. Example 5: Theproduct GetTags\u00d7GetTags inExample 4 has trivially nolength-con.ictsbecause \no.sets of allproduct states are0 and thuspromises of allproduct states are(E, E). Finally, assuming A \n\u00d7B has no length-con.icts and each product state p . QA\u00d7B has a .xed promise prom(p)= ./(f ,g) (a, \u00df), \nthenp is con.ict-free, when, for all rules p - ---. q, the maximalpre.xes of a \u00b7 f and \u00df \u00b7 g are equivalent \nrelative to ..(Note, when concatenating a . G * with a sequence f of .-terms of type s . . we assume \nan implicit conversion of a to .x.a.)Let k = min(|a \u00b7 f |, |\u00df \u00b7 g|)-1, k 1 (.a(a . [ .] . [ (a \u00b7 f )j \n] (a)=[ (\u00df \u00b7 g)j ] (a))). (4) j=0 We say that p is a con.ict-state if p is not con.ict-free. Verifying \nabsence of con.ict-states is a linear search over rules in A \u00d7 B thatveri.esthecondition(4)foreach rule. \nLemma 3: If A \u00d7 B has .xed promises and no length\u00ad 1 con.icts then A = B . QA\u00d7B contains a con.ict-state. \nProof. Assume that A \u00d7B is as stated. (.): existence ofa con.ict-state p implies, by de.nition, that \nthere exists aposition-con.ict, since p isbothreachable and not a deadend. 1 (.):AssumeA = B.We show \nthatthere exists a con.ict\u00adstate. Since A and B have no length-con.icts there exist a, b, c such that \nb . TA(a), c . TB (a), |b| = |c|, and there exists a position i,0 = i< |b|, such that bi = ci. Fix i \nto be the smallest such position. So there exists a 1 , a, b1 , b2 , c 2, a, \u00df, p,q such that a 1 \u00b7 a \nis a pre.x of a, b1 \u00b7 a \u00b7 b2 is a pre.x of b, b1 \u00b7 \u00df \u00b7 c 2 is a pre.x of c, and 11 2 0 a 1 /(b\u00b7a,b\u00b7\u00df)a/(b,c \n2 ) qA\u00d7B - --------. p - ----. q  where prom(p) =(a, \u00df) and (a \u00b7 b2)j =(\u00df \u00b7 c 2)j with ./(f ,g) j = \ni -|b1|. So there exists a rule p - ---. q such that a . [ .] but[ (a \u00b7 f )j ] (a)=[ (\u00df \u00b7 g)j ] (a). \nThus,p is a con.ict\u00adstatebecause(4)does nothold. The following theorem describes precisely the assump\u00adtions \nunder which 1-equality of SFTs is decidable. Theorem 1 (SFT-1-equality): If A and B are SFTs over a 1 \ndecidable label theory then A = B is decidable. Moreover, if the complexity of the label theory for instances \nof size m 1 is f (m)then the complexity of A = B is O(n 2 \u00b7 f (m))where n is the number of rules and \nm the size of the rules. Proof. ByusingLemmas1,2 and3.Decidingsatis.ability of . is neededinthe construction \nof A \u00d7B.Deciding f =. g is neededfordeciding validity of theformula(4).In Lemma2, we need to decide if \nf is constant relative to a satis.able formula .: decide if f =. [ f ] (witness(.)). Lemmas 1, 2 and \n3 are combined into a single DFS algorithm, shown in Figure 3, that decides 1-equality of SFTs over a \ndecidable label theory. Line 6 corresponds def Decide1equality(A,B)= 1 C := A\u00d7 B; Q:= {q0 . (E,E)}; S \n:= stack(q0 ); CC 2 while S = \u00d8 3 p := pop(S);(a,\u00df):= Q(p); 4 foreach (p,.,(f ,g),q). RC (p) 5 (u,v):= \n(a\u00b7 f ,\u00df \u00b7 g); 6 if q . FC .|u|= |v|return f; 7 if |u|=|v| .|v|-1 8 if i=0 ui =. vi return f; 9 w := \n[u|v|,...,u|u|-1];c := [ w] (witness(.)); 10 if w =. c .(q . Dom(Q).Q(q)= (c,E))return f; 11 if q/. Dom(Q)push(q,S);Q(q):= \n(c,E); 12 if |u|< |v|... (symmetrical to the case|u|=|v|) 13 return t; Figure 3. 1-equality algorithm \nfor SFTs. to detection of a .nal state with non-zero o.set by using Lemma 1. Line 8 corresponds to use \nof Lemma 3(.). Line 10 corresponds to use of Lemma 2. Line 13 corresponds to use of contraposition of \nLemma 3(.). The number of iterations of the loop as well as in the product construction is bounded by \n|RA|\u00b7|RB |. The algo\u00adrithm uses satis.ability checks during product construction inline1, andin theloopinlines8 \nand10.Inline8 the num\u00adber of checksislinearin thelength of the output sequence v: decideifthere existsi,0 \n= i< |v|, and.(x).ui(x)= vi(x)is satis.able. Similarly for line 10. The complexity follows. Theorem 1 \nshows that complexity of 1-equality of SFTs depends on the complexity of the label theory. For example, \nif we uselinear arithmetic with onefree variable asthelabel theory, and guards are represented in normalized \nform as conjunctions of linearinequalities, then theFourier-Motzkin eliminationprocedure[14] implies \napolynomial worst-case complexity of 1-equality. The algorithm for partial-equivalence of classical single\u00advalued.nitetransducers,hascomplexityO((|T \n|+|Q|)2)[16], where T is the set of transitions. With a symbolic encod\u00ading we can replace |T | by the \ndecision complexity for the alphabet theory. Symbolic encodings also make expressing dependencies between \ninput-output characters succinct. To s, t, . ::= types sfas ::= explicit dfn of an SFA over s sfts/. \n::= explicit dfn of an SFT over s . . Bs/. .A. As ::= sfas |As -As |As \u00d7 As | Bs/. sfts/. |Bs/t .Bt /. \n|Bs/. IAs ::= 1 As . As |Bs/. Bs/. |F .F | F ::= = \u00acF Figure 4. Algebra of SFTs; A is a valid SFA expression; \nB is a validSFT expression;F is a validformula; label theories are assumed composable. give the .avor, \nin a UTF-16 to UTF-8 encoder, we use tran\u00adsitions of the form .x.0xD800=x=0xDBFF/[.x.enc1 (x),.x.enc2 \n(x),.x.enc3 (x)] p - ----------------------------------. q. It succinctly represents 1024 transitions \nrequired by explicit .nite transducer representations.Overall, thefullSFT(over 16-bit bit-vector arithmetic) \nfor the encoder uses 5 states and 16 rules, compared to 216 concrete transitions required byanequivalent \nclassical .nitetransducer.Wealsoevaluate thebene.ts ofSFAsin[24].SFA equivalenceis requiredfor the domain \nequivalence check of SFTs. Relation to One-Counter Automata. In closely related work, Alur et.al. [1] \npresent streaming transducers, an ex\u00adtension of classical .nite state transducers that is largely orthogonal \nto SFTs presented here. For example, streaming transducers allow reversing the input, which is not possible \nwith SFTs, but require the character theory to be a total order, so that equivalence remains decidable. \nThe authors prove the decidability of equivalence of streaming transduc\u00aders by reducing it to reachability \nof one-counter automata. At a high level, the automaton is constructed so that it sim\u00adulates the execution \nof the two given transducers in paral\u00adlel, synchronized on the input tape, while using the counter to \nrepresent the length o.set between outputs. If the one\u00adcounter automaton can reach a .nal state on a \nzero count, then the simulated transducers must have di.erent output on some input. While our main algorithm \n(1-equality algorithm in Fig\u00adure 3)is similar in spirit, we do not make explicit use of the one-counter \nautomaton construction. To do so would im\u00adpose two restrictions on our approach:(1) the one-counter automaton \nconstruction would require satis.ability checking of conjunctions of formulae in the background theory; \nand (2) it would require special handling to deal with the fact that we allow elements in output sequences \nto be functions of the input symbols. While we are con.dent that the .rst requirement(1) canbe readily \naccommodated, we are un\u00adaware of any way to circumvent the second restriction (2) without imposing additional \nlimitations on the types of al\u00adlowable output functions, and by adding a symbolic compo\u00adnent to the one-counter \nautomaton itself. Instead, we focus on a more ad-hoc construction that does not impose addi\u00adtionalrestrictions.Withrespect \nto the algorithminFigure3, (2) is re.ected in the use of witness or model generation modulo the input \ncondition and the output transformation functions,(2)isessentially theimplementationof Lemma2.   3.3 \nAlgebra of SFTs Weintroduceanalgebra ofSFTs,inFigure4,that allows us to express several useful decision \nproblems involving SFTs and SFAs. Note that B .A of an SFT B with an SFA A is again anSFAbecause all \nthe outputs of B .A are empty.We call B .A the inverse image of B under A. The de.nition  of B I A in \nour algebra is as follows. De.nition8: Let B be anSFTand A anSFA.The domain restriction of B for A, denoted \nB I A, is the SFT obtained from B \u00d7 A by eliminating the second output component E from all the rules. \nThefollowingpropertyfollowsfrom(1)and(2). { TB (b), if b . D(A); TB,A(b)= (5) \u00d8, otherwise. We say that \nthe SFT algebra in Figure 4 is decidable if validity of all the formulas F in the algebra is decidable. \nTheorem 2 (SFT-algebra): The algebra of SFTs is decid\u00adable if the label theories are decidable. Proof. \nTheSFAoperations are e.ectivelyclosed underinter\u00adsection an complement and equivalence is decidable if \nsat\u00adis.ability oftheguardsisdecidable[48].Decidability of1\u00adequality of SFTs is Theorem 1. Closure under \ncomposition isProposition1.Domain restrictionisgivenin(5). The following corollary identi.es a collection \nof practi\u00adcallyrelevantdecisionproblems thatfollowfromTheorem2. Subsumption of SFTs, A .B, is the problem \nof deciding if TA(b). TB (b)for all b. Reachability istheproblem of exis\u00adtence of an input that is transformed \nto an output accepted by an SFA. Corollary 1: The following decision problems over single\u00advalued SFTs \nover a decidable label theory are decidable: Subsumption; Equivalence; Idempotence; Commutativity; Reachability. \nProof. Assume A and B are single-valued SFTs and recall 1 Proposition 2. Subsumption, A .B, is d(A). \nd(B).A = B. Equivalence, A = B, is A .B .B .A. Idempotence is A = A .A. Commutativity is A .B = B .A. \nReachability of a given output SFA D is A .D = \u00d8. Thefollowingexampleillustrates a use oftheSFTalgebra \nfor reachability analysis of SFTs. The example is a digest behind security analysis of string sanitizers \nwith respect to known XSS attack vectors. Example 6: Consider the SFT B = GetTags from Exam\u00adple 3. Is \nitpossible that B does not detect all tags? In other words, does there exist an input b that matches \nthe regex P = \".*<[^<]>.*\" but TB (b)= {E}? Let A0 and A\u00d8 be the SFAs such that D(A0)= {E} and D(A\u00d8)= \n\u00d8. Let AP be the SFA that accepts all strings that match the regex P . Thequestionis equivalenttodeciding \nif(6)fails, (B I AP ).A0 = A\u00d8 (6) D because, for b . S * , b . D(D) ..a (TB,AP (b)= {a}.a . D(A0)) . \nTB,AP (b)= {E} . TB (b)= {E}.b . D(AP )  It turns out that D (when minimized) is an SFA with 8 states, \ne.g., \"<a<a>\" . D(D). (What is remarkable is that D canbe e.ectivelyconvertedback to a regex thatdescribes \nall inputs where tags are not detected.)By considering the witness, it can easily be traced back to the \nmissing case in the GetTags program: line 8 of the C# code should be q=(x == < ?1 :0);. By verifying \n(6) for the SFT corresponding to the .xed code, we can verify the new code indeed detects all tags. It \nalso follows from Theorem 1 and Proposition 2, that we can decide single-valuedness of SFTs. This is \na practically valuable result thatlifts theburden of the semantic assump\u00adtion of single-valuedness in \ndecision problems that assume single-valuedness. Corollary 2: Single-valuedness of SFTs over a decidable \nlabel theory is decidable.  3.4 Extension with Registers We extend SFTs to symbolic transducers or STs \nby allow\u00ading the use of registers. This will provide a more succinct representation, and enable more \ne.cient symbolic analysis methods to be used, by taking advantage of recent advances isSMT technology[15].AnST \nuses a set of variables called registers as a symbolic representation of states. The rules of an ST are \nguarded commands with a symbolic input and output component. Since the .nite state component of an SFT \ncan be represented with a particular register of .nite type, the explicit state component is omitted \nfrom STs. Moreover, by using Cartesian product types, we represent multiple registers with a single(compound)register. \nDe.nition 9: A Symbolic Transducer or ST with input type s, outputtype . andregister type t is a tuple(q \n0, ., R), where q 0 .Ut is the initial state, . is a t -predicate called the .nal state condition, andR \nis a .nite setofrules (., f ,g) where . is a(s\u00d7t )-predicate,f is a sequence of .-terms of type(s\u00d7t ). \n., and g is a .-term oftype(s\u00d7t ). t . We write As/.;t to indicate the input/output element type s/. \nand the register type t of anST A. When we write As/. , we assume t tobeimplicit.Arule(., f ,g). RA denotes \nthe following set of concrete transitions: def a/[ f ] (a,q) [ (., f ,g)] = {q - -----. [ g] (a, q)|(a, \nq). [ .] } Although the formal de.nition omits .nite states, it is often useful to explicitly include \na separate .nite state com\u00adponent, we do this in the examples below. Moreover, it is technically convenient \nto extend .nal states with .nal out\u00adputs by extending . to be a .nite set of .nal output rules (., g) \nwhere . is a t -predicate and g is a sequence of .\u00adterms of type t . ..Intuitively,a .nal outputistheoutput \nproduced whenthe end of theinputhasbeen reached, often thisis E,butit need notbe.Whenall .naloutputsare \nE then . is equivalent to being a t -predicate as in De.nition 9, i.e., /0 q . [ .A] then means that \nq -.A. Final outputs correspond to a restricted use of input-epsilon rules as used in classical .nite \ntransducers. a/b The reachability relation p --. A q for a . S * , b . G * , and p, q .Ut is de.ned analogously \nto SFTs. The de.nition of TA is lifted similarly, for a . S * : def a/b /c 0 TA(a)= {b \u00b7 c |.q (qA --. \nA q .q -.A)} Example 7: Consider the C# code in Example 3. There is a direct mapping of the code to an \nST A that uses the compound register (q, c). The initial state of A is (0, 0), the .nal state condition \nis t andthe rules are(we omit . s):  (q=0 .x= < , E, (1,x)), (q=0 .x= < , E, (0,x)), (q=1 .x= < , E, \n(1,x)), (q=1 .x= < , E, (2,x)), (q=2 .x= > , [ < , c, > ], (0,x)), (q=2 .x= > , E, (0,x)) The register \nupdate (rq ,rc) of a rule corresponds to the assignments q := rq and c := rc. Since all assignments to \nc have the form c := x, c corresponds to the previous input character. A can be automatically transformed \nto the equivalent GetTags SFT;the registerc is eliminatedbyusing a new state and nondeterminism. One \ncan e.ectively construct a well-founded axiomatic theory Th(A)of anST As/. over abackground of lists, \nsim\u00adilarly to symbolic automatain[47]. Th(A)de.nes a symbol TA that provides a sound and complete axiomatization \nof T A TA, i.e., for any model A |=U Th(A),A = TA. Moreover, Th(A)can be directly asserted as an auxiliary \ntheory of any state-of-the-artSMT solver that supportslists. By deploying Th(A)in this way, we obtain \nan integrated de\u00adcision procedure for satis.ability and model generation for quanti.erfreeformulasthatmay \narbitrarily combineformu\u00adlas over the background U with transduction atoms TA(u, v) where u : L(s)and \nv : L(.)are arbitrary list terms.A direct application, outlined in Figure 5, is a semi-decision proce\u00ad \ndef Witness1disequality(As/. ,Bs/. )= 1 assert Th(A).Th(B); 2 (u,v,w):= (nil,NewVariable(L...), NewVariable(L...)); \n3 while t AA 4 if .A (A |=U T(u,v).T(u,w).v=w)return (u,v,wA); AB 5 else u := cons(NewVariable(s),u); \n1 Figure 5. Given STs A = B,generates a witness(a, b, c) such that b . TA(a),c . TB (a), andb = c. durefor1-disequality \nofSTs, where the auxiliary theories are asserted to the solverinline1, and successivelylongerinput\u00adlists \nare used to invoke the solver to decide 1-disequality of theinstanceinline4.The semi-decisionprocedure \ncomputes a shortest-input witness of 1-disequality. 4. Case Studies We present four case studies for \napplications of SFTs. The .rst case study focuses on sophisticated string manipula\u00adtion, that goes beyond \nour .rst case study of sanitizer anal\u00adysis with Bek [4] (that is discussed further in Section 5), we \nwant to emphasize that the utility of SFTs goes well be\u00adyond reasoning about string sanitizer processing. \nFigure 2 summarizes the essential features of each case study. 4.1 Representing HTMLDecode Topreventinjection \nattacks suchas cross-site scripting(XSS) and SQL injection, Web applications employ sanitizers, which \nare string manipulation routines that remove or en\u00adcode dangerous input characters. Many applications \nin\u00adclude their own sanitizer implementations. Recent work by Hooimeijer et al. [4] examines several such \nsanitizers, demonstrating that a subset of popular sanitizers can be modeled using transducers. Furthermore, \nthey show that safety properties of Web sanitizers can be checked using transducer analyses. We focus \non the sanitizer HTMLDecode to evaluate the practical utility of theST representation.Figure6 outlines \na public String HTMLDecode( String input ) { StringBuffer sb = new StringBuffer(); PushbackString pbs \n= new PushbackString( input ); while ( pbs.hasNext() ) { Character c = decodeCharacter( pbs ); if ( \nc != null ) { sb.append( c ); } else { sb.append( pbs.next() ); } } return sb.toString(); } public \nCharacter decodeCharacter( PushbackString input ) { input.mark(); Character first = input.next(); if \n( first == null ) { input.reset(); return null; } if ( first.charValue() != &#38; ) { input.reset(); \nreturn null; } Character second = input.next(); if ( second == null ) { input.reset(); return null; } \n if ( second.charValue() == # ) { Character c = getNumericEntity( input ); if ( c != null ) return c; \n} else if ( Character.isLetter( second.charValue() ) ) { input.pushback( second ); Character c = getNamedEntity( \ninput ); if ( c != null ) return c; } input.reset(); return null; } private Character getNumericEntity( \nPushbackString input ) { ... return parseNumber( input ); } private Character parseNumber( PushbackString \ninput ) { StringBuffer sb = new StringBuffer(); while( input.hasNext() ) { Character c = input.peek(); \n if ( Character.isDigit( c.charValue() ) ) { sb.append( c ); input.next(); } else if ( c.charValue() \n== ; ) { input.next(); break; } else break; } try { int i = Integer.parseInt(sb.toString()); return \nnew Character( (char)i ); } catch( NumberFormatException e ) return null; } Figure 6. Excerpt HTMLDecode \nin Java (from OWASP 1.4.0).The code shown converts named entities(e.g., &#38;lt; to <)and numeric entities(e.g., \n&#38;#52; to 4).The numeric en\u00adtity conversionisdi.culttomodel e.ciently usingprevious approaches. real-world \nimplementation, taken from the OWASP library. HTMLDecode transforms HTML entities back to the symbol \nthey represent.Entities canbe named(e.g., &#38;lt; maps to <), or numeric in decimal or hexadecimal representation \n(e.g., decimal entity &#38;#48; maps to symbol 0). For simplicity, we will restrict our attention to \ndecimal entities. Intuitively, HTMLDecode is di.cult to cast as a transducer because it requires lookahead: \na single output symbol may depend on a speci.c sequence of several characters. The full Unicode set consists \nof more than one million symbols. To decode a decimal entity, therefore, we need to inspect up to six \ndigits. While that is possible using either SFTs or traditional transducers, it requires a large state \nspace. In contrast, the corresponding ST is quite succinct. Fig\u00adure 7 shows a ST DecodeZ/Z;Q\u00d7(Z\u00d7Z), that \nuses two registers tohandle numeric entities with exactly twodigits. The com\u00adpound register is (q, (y, \nz))We illustrate explicitly the .nite  (x= ; . x= &#38; )/[ &#38; , # ,y,z,x] (x= &#38; )/[x] # ,y,z] \n (x= &#38; .\u00ac( 0 =x= 9 ))/[ &#38; , # ,y,x] Figure7. STrepresentation of the HTMLdecode codeinFigure6, \nrestricted todecimal numeric entities of theform &#38;#[0-9][0\u00ad9];. This ST uses two registers to remember \none digit each, and uses integer-linear arithmetic to compute the corresponding codepoint.The .-termsareimplicitinthelabels, \ne.g.,theoutput10(y -48)+z -48 is shortfor .(x, (y, z)).10(y -48)+z -48, where x istheinput and(y, z)the \nregister. state component(thatisthe value of q). Finaloutputs, un-out of memory, while TO marks cases \nthat hit the 2-hour less they are E, are shownbylabels on outgoing .arcs from timeout. .nal states. Characters \ncorrespond to their Unicode code These results show that STs, in particular using the lazy points, e.g., \n0 = 48. The actual decoding happens in representation, are signi.cantly more scalable for this task the \nrule from state q4 to q0 with guard x = ; ,wherethe thanSFTs.TheSFT representationeitherexhaustsmemory \noutput 10 \u00b7 (y - 48) + z - 48 corresponds to invocation of or passes the timeout in the majority of cases. \nThe eager parseInt in Figure 6. The states qi roughly correspond to ST representation outperforms the \nlazy representation only the control .ow of the code in Figure 6. for the smallest two testcases. For \nlarger runs (i.e., more compositions and more digits), the lazy SFT representation scales much morereliably, \nranging from1 to20 secondsover Evaluation: We compare the ST representation to the the 2-composition \nrange (compared to several minutes for equivalent SFTs, in terms of size and analysis speed. Let the \neager representation). DecodeSTn denote an ST that models HTMLDecode for en\u00adtities of the form &#38;#[0-9]{1,n}; \n(i.e., up to n decimals, inclusive). For each i . [2;6], we compute anSFTthatis 4.2 Malware Fingerprinting \nCode equivalent to DecodeSTi by concretizing the possible regis- Millions of web pages today contain \nmalicious JavaScript ter values at each state. Figure 8(a) shows the number of that attempts to take \nover a victim s webbrowser.An active both states and edges on the y-axis, for both representa\u00adresearchliteraturehasproposed \nstatic anddynamic methods tions; the x-axis denotes the number of digits modeled. The for detecting these \nattacks [9, 11, 13, 41]. A key .nding most prominent take-away is that the ST representation is of this \nwork is that malware authors use .ngerprinting drastically smaller. For example, for the 6-digit encoding, \ntechniques [17, 36] to decide which malware to deliver to the SFT encoding has over 10, 000\u00d7 as many \nstates, and the victim user. 135, 000\u00d7 as many edges, as the equivalent ST encoding. Figure 9 shows an \nexample of client-side browser .nger-We consider the speed of two algorithms: composition 2printing.Thecodeiteratesoverthelistofpluginsinstalled \nand equivalence checking. The experimental task is to .nd in the browser and queries their version numbers. \nIn some a witness (i.e., an input string) w that demonstrates that cases, version numbers are padded \nby optionally adding DecodeSTi(w)= DecodeSTi(DecodeSTi(w)), for some num\u00ad leading 0s to them.Finally, \nvariables quicktime plugin and ber of self-compositions. We consider three di.erent algo\u00adadobe plugin \narecombinedtoproducethe .nal fingerprint rithms for performing this task: ST.E uses an in-memory value. \nThis .ngerprint value is then used to select a speci.c representation and conducts an eager search(computing \nen\u00adattack to run against the user. tire transducers); ST.L uses a lazy approachby encoding the Figure12list \nseveral concrete .ngerprint valuesfromreal entire ST into the underlying SMT solver; and SFT repre\u00adbrowser \nsetups.NotethatQuickTime7.6.6has atleast one sents an eager SFT-based approach. known vulnerability, \nand may thus be of special interest to Figure 8(b) shows the speed results. Compositions repre\u00adan attacker. \nsents the number of times we compose each class of trans-We consider a scenario in which we have acquired \nthese ducer with itself. Composition refers to the time taken to .ngerprints(e.g.,through network sni.ng), \nand wantto .nd perform the composition; for the lazy ST.L this time is neg\u00adout the corresponding plugin \nnames. At a higher level, the ligible(sincethe compositionis simplyasserted to the under\u00adquestion is: \nCan we .nd out interesting properties by com\u00ad lying solver). IdempotenceChecking refers to the time \ntaken to .nd the actual witness, after the composition. Each col\u00adumn represents a single experimental \nrun; we employed a 2 This code is simpli.ed for illustrative purposes: the original 2-hour timeout per \nrun. The label OM marks runs that ran considers more plugin types, including Flash, etc.  (a) Initial \ntransducer sizes. (b) Running times. Figure 8. HTMLDecode results. The task is to prove that HTMLDecode \ndoes not commute with itself, and to provide a witness that demonstrates this for a given number of Compositions. \nWe evaluate three representations: ST.E (ea\u00adger ST composition), ST.L (lazy STcomposition using Z3), \nand SFT (SFTcomposition).Weconsider .vedistinctmod\u00adels(indicatedby Decimals,based onhow manydigits theST \nor SFT can handle. puting string-related pre-conditions based on a postcondi\u00adtion? Our techniques can \nanswer this question in the a.rma\u00adtive by modeling the code of Figure 9 using multiple SFTs. The key \nidea is conditional assignment translates into non\u00addeterministic case splits inside the SFT. At a high \nlevel, each transducer corresponds to a split or a merge in the control .ow of the .ngerprinting code, \nrelative to a sin\u00adgle variable of interest. This is illustrated in Figure 10, which shows the transducer \nQuicktimeSplitter together with the path predicates modeled by each of its three main branches.The transducer \nreadsbothquicktime_plugin and plugin_name, separated by a special # symbol. Its output is guaranteed \nto start with # if and only if the branch if(quicktimep lugin == 0&#38;&#38;... was taken. For the sake \nof brevity, we do not display the remaining SFTs.Figure11lists thefull set ofSFTs and their statistics. \nQuicktimeMerger takes the output of QuicktimeSplitter and models the control .ow join at the end of the \n.rst if statement. QuickTimePadder models the .nal while loop in Figure9. The manipulation of variable \nadobe_plugin is analogous. var quicktime_plugin = \"0\", adobe_plugin = \"00\"; for(var i = 0; i < navigator.plugins.length; \ni++) { var plugin_name = navigator.plugins[i].name; if (quicktime_plugin == 0 &#38;&#38; plugin_name.indexOf(\"QuickTime\") \n!= -1) { var helper = parseInt(plugin_name.replace(/\\D/g,\"\")); if (helper > 0) // not base 16 quicktime_plugin \n= helper.toString(10) } if (adobe_plugin == \"00\" &#38;&#38; plugin_name.indexOf(\"Adobe Acrobat\") != \n-1) { plugin_name = navigator.plugins[i].description; if(plugin_name.indexOf(\" 5\") != -1) adobe_plugin \n= \"05\"; else if(plugin_name.indexOf(\" 6\") != -1) adobe_plugin = \"06\"; else if(plugin_name.indexOf(\" 7\") \n!= -1) adobe_plugin = \"07\"; else adobe_plugin = \"01\" } else { // flash, java... } } while(quicktime_plugin.length \n< 8) quicktime_plugin = \"0\" + quicktime_plugin; var fingerprint = \"Q\" + quicktime_plugin + \"8\" + adobe_plugin; \n// ... fetch_exploit(fingerprint); Figure 9. Browser and plugin .ngerprinting code found in JavaScript \nmalware. Evaluation: We computethepre-image of the composition transducers discussed above as follows. \nFor each .ngerprint w, we construct an SFA that accepts {w} and corresponds to the postcondition fingerprint \n== w. The pre-images of QuicktimeComposed and AdobeComp correspond toprecon\u00additions for a single iteration \nof the for loop in Figure 9. For example, for w = Q00000769801, we .nd a precon\u00addition that relates values \nof quicktime_plugin to values of plugin_name, as follows: (1) quicktime_plugin already had value 769, \npossibly padded with up to .ve zeroes, or (2)quicktime_plugin consisted entirely of zeroes and plu\u00ad gin_name \ncontained the substring Q uicktime together with digits 7, 6, and 9 inthatrelative order.Condition(1) \nrep\u00adresents the case where quicktime_plugin had a previously\u00adassigned version number, while condition(2)representsthe \ncaseinwhich a version numberwas extractedinsidethe for loop. For all real .ngerprints we tried, our analysis \ntook less than one second per .ngerprint. Next, we evaluate whether inverse image generation, as used \nabove, scales to relatively large output values. Unlike most previous string constraint solvers [26, \n30, 42], SFT\u00ad  SFT States Edges Quicktime (variable quicktime plugin) QuicktimeSplitter 25 60 QuicktimeMerger \n6 9 QuicktimePadder 37 37 Composed 534 1,425 Adobe (variable adobe plugin) AdobeSplitter 36 81 AdobeMerger \n21 40 Composed 203 797 Figure 11. SFTs used for the malware .ngerprinting ex\u00adample.Statisticsfor theQuicktime \nandAdobe components are shown. The composition SFTs take approximately one second to compute. Browser/plugin \ncombination Fingerprint FF: Acrobat 9.4.5.236; no quicktime Q00000000801 FF: Acrobat 9.4.5.236; Quicktime \n7.6.9 Q00000769801 IE: no plugins of interest installed Q00000000800 FF: Acrobat 9.4.5.236; Quicktime \n7.5.5 Q00000755801 FF: Acrobat 9.4.5.236; Quicktime 7.6.6 Q00000766801  Figure 13. Inverse image generation \ntime in seconds for .ngerprint outputs up to 8192 bytes. The outputs were randomly generated from the \nlanguage Q[0-9]{n}801 over 16 bit characters. based analysisdoes notimposelengthboundsonthestrings under \nconsideration. This is only bene.cial if the approach actually scales to large strings. We show the approach \ndoes scale by generating random .ngerprints of the form Q[0\u00ad9]{n}801, and measuring the time it takes \nto compute the inverse images for both the QuickTime and Adobe variables. Figure 13 shows encouraging \nresults: in general, our approach takes less than half a minute to generate pre\u00adimages for up to eight \nkilobytes worth of output.Incontrast, the Hampi solver was limited to .nding pre-images up to .fty bytes \nworth of output. Our malware case study demonstrates several important points. First, SFTs are well-suited \nfor describing code by making use of non-determinism.The transducers needed can belarge(onthe order ofhundreds \nof states and edges),but we can constructthemfrom much smallertransducers(tens of states and edges) through \ncomposition. The pre-image computation reveals interesting relations among mutually dependent variables. \nFinally, the pre-image computation is e.cient: it can generate valid string inputs for outputs that measure \nseveral kilobytes in size, while we are unaware of any previous string constraint solver that can handle \nthis order of magnitude. Takeaways: From our .rst two case studies, we have the following key takeaways \n STscanbe radically moresuccinctinrepresentationthan SFTs: we saw in our HTMLDecode example that our \nST representationhad10, 000timesfewer states and150, 000 times fewer edges than our SFT representation. \n Lazy ST encoding scales best for our HTMLDecode exam\u00adple, taking between 1 to 20 seconds for six characters \nand two compositions. Eager ST encoding is slower, and eager SFT encoding times out above two characters. \n SFTs can accurately model real examples of malicious Javascript .ngerprinting code. Our analysis requires \nless than one second to recover plug-in versions from real examples of .ngerprints generated by malicious \ncode found in the wild.  Previousworkinstring constraint solvinghasfocused al\u00admost exclusively on constraints \nthat require fewer than 50 bytes; for example, the majority of Hampi experi\u00adments were conducted with \nlength bounds of 15 bytes orfewer[30].Incontrast, ourtechniquescan synthesize pre-images in excess of \n8, 000 bytes in roughly a minute.   4.3 Image Blurring Toillustratethegenerality ofSFTs, welook atimagetrans\u00adformations. \nA clear advantage of representing image trans\u00adformations in the form of transducers is the ability to \ndo composition on transducers it gives us. In fact, image edi\u00adtors such as Google Picasa represent image \ncontents as the original image as well as a series of image transformations, such as blurring, sharpening, \nblack and white conversion, contrast enhancement, and the like. In many cases, of course, editing a large-scale \nimage that includes millions of32-bitpixesbeforehigh-qualityprinting might involve a dozen of such transformations. \nApplying them one after another, in a sequence is often too time\u00adconsuming to be practical. A better \nalternative consists of composing the transformations together and applying them to the input image only \na single time. We focus on image blurring, which is a prototypical textbook image transformation[40]. \nFigure14illustrates the two transducers for horizontal and vertical blurring of an image. Measuring \nprivacy via entropy: A fascinating feature of our analysis is that we can estimate a privacy metric for \nimage blurring using our techniques. Our starting point is the observation that if an image has a unique \npre-image given blurring, then the blurring does not hide the original image at all. Just consider a \nblack square: no matter how many times we might attempt to blur it, the image will remain unchanged.Onthe \notherhand, afterblurring aface, there may be multiple original images that yield the same blurred face. \nPut another way, a blurred face image de.nes a set of potential candidate original images. If we assume \nthat all candidate original images are equally likely, then we can de.ne the entropy H of the original \nface after a blurring transformation \u00df as follows: H = -log(|\u00df(\u00df-1)|), in other words, we use the reverse \nmapping \u00df-1 given to us by the inverse transducer, and take the negated logarithm of the size of its \npreimage. For the entirely black image example, H =0because thereis only one elementin thepreimage.To \nincrease privacy, our goal is to maximize the entropy. Note that given for images of a given rectangular \nsize, we can always exhaustively check if two images result in the same image after blurring. Our techniques \nallow us to write down a SMT formula where the number of solutions is equal to the number of preimages \nof \u00df on a speci.c image. This is the .rst connec\u00adtion to our knowledge between SMT techniques and proba\u00adbilisticde.nitionsofprivacy.Of \ncourse computing theexact number of solutions is #P -complete, but we can employ ap\u00adproximation techniques \nto estimate this quantity. Then we canprogrammatically comparedi.erent methods ofblurring by the entropy \ninduced. We leave exploration of the impact of di.erent approximation techniques as future work.  4.4 \nLocation Privacy GPS sensorslocated in most mobiledevices constantly track our location [2, 32]. While \nthe popularity of applications such as Foursquares, Gowalla, and Facebook check-ins show user demand \nfor sharing this information, this also raises privacy concerns. As a reaction to privacy concerns, Google \ns Latitude location sharingservice started allowing users to only release the city they arein, not theirpreciselocation, \nso that a trace of a user s day might look like Menlo Park, CA; Palo Alto, CA; Los Gatos, CA; Mountain \nView, CA; Los Gatos, CA. Clearly,giventhe sizes of these cities,tracking the userpre\u00adcisely might present \nsome di.culty. To generalize, one ap\u00adproach that has emerged is context sensitive choice of gran\u00adularity; \nintuitively, if I am located in a densely-populated location such as midtown Manhattan, block-level location \nis .ne to reveal. If I am in a sparsely-populated area such as the Death Valley, we should only reveal \na coarse location approximation. This can be encoded with a transducer that works on a stream of recorded \nlocation measurements. To summarize, given GPS coordinates (latitude/longitude): 1. Use a lookup list \nof world cities and their latitude and longitude values and nearset point calculation to com\u00adpute the \nnearest city to the current location; 2. Determine the city population via a lookup table; 3. Mapthepopulation \nto ahigh orlowdensity area(H or L).  4. Based on the last .ve GPS readings, enter a high\u00ador low-density \noutput state. Depending on that, the (latitude,longitude) pair is approximated with di.erent precision. \nThis can be captured by a transducer with di.erent out\u00adputactions depending on the current state.Forinstance,for \nhigh-density areas, we can drop GPS location seconds, and for low-density areas we can drop GPS location \nminutes. Krumm et al consider additional trace obfuscation tech\u00adniques such as adding noise or quantizing \ntraces, which can alsobe represented using ourSFTframework[8]. 5. Related Work In an appliedsetting[27] \nweintroduced and appliedSFTs to analysis of security sanitizers in the Bek project. This work relied \non semi-decision procedures for SFT analysis and did not state or prove any algorithmic results on SFT \ndecision procedures. In comparison, the current paper provides the missing formal foundation for Bek \nprogram analysis. It furtherdevelops new and moregeneral algorithms,including the more general 1-equality \nalgorithm that factors out the decisionproblemfor single-valuedness.The new supportfor registers enable \nnew,previouslyinfeasible, application areas. These include HtmlDecode, even Example 7 and most of the \ncase study section. Furthermore, the new support for nondeterminism allows elimination of registers, \nasillustrated in Example 7, without violating single-valuedness. General equivalenceof .nitestatetransducersisundecid\u00adable[23], \nand already sofor very restrictedfragments[28]. Equivalence ofdecidabilityof single-valuedGSMs was shown \nin[43], and extended tothe .nite-valued case(thereexists k such that,for all v, |TA(v)|=k)in[12, 50]. \nThe decidability of equivalence of the .nite-valued case does not follow from the single-valued case. \nCorresponding decidability result of equivalenceof .nite-valuedSFTsisshownin[6].Unlikefor the single-valued \ncase that has a practical algorithm (Fig\u00adure 3), the .nite-valued case is substantially harder, the 1\u00adequality \nalgorithm does not generalize to this case because the satis.ability checks cannot be made locally: Lemma \n2 does not imply violation of partial-equivalence in the .nite\u00advalued case. In recentyears therehasbeen \nconsiderableinterestin au\u00adtomata overin.nitelanguages[44], starting with the work on .nite memory automata \n[29], also called register automata. Finite words over an in.nite alphabet are often called data words \nin the literature. Other automata models over data words are pebble automata [37]and data automata [7]. \nSev\u00aderal characterizations oflogics with respect todi.erent mod\u00adels of data word automata are studied \nin [5]. This line of work focuses on fundamental questions about de.nability, decidability, complexity, \nand expressiveness on classes of au\u00adtomata on one hand and fragments of logic on the other hand. A di.erent \nline of work on automata with in.nite al\u00adphabetsintroduces lattice automata [22]that are .nite state \nautomata whose transitions are labeled by elements of an atomic lattice with motivation coming from veri.cation \nof symbolic communicating machines. Streaming transducers [1] provide another recent sym\u00adbolicextensionof \n.nitetransducerswherethelabel theories are restricted to be total orders, in order to maintain de\u00adcidability \nof equivalence, e.g., full linear arithmetic is not allowed. Finite state automata with arbitrary predicates \nover la\u00adbels, called predicate-augmented .nite state recognizers, or symbolic .nite automata (SFAs)in \nthe current paper, were .rst studied in the context of natural language process\u00ading[38].While the work[38] \nviews symbolic automata as a fairly trivial extension, the fundamental algorithmic ques\u00adtions are far \nfrom trivial. For example, it is shown in [24] that symbolic complementation by a combinatorial opti\u00admization \nproblem called minterm generation leads to sig\u00adni.cant speedups compared to state-of-the-art automata \nal\u00adgorithmimplementations.The workin[38] introduces adif\u00adferent symbolic extension to .nite state transducers \ncalled predicate-augmented .nite state transducers. This extension is not expressive enough for describing \nSFTs. Besides iden\u00adtities, it is not possible to establish functional dependencies from input to output \nthat are needed for example to encode transformations such as HtmlEncode.  We use the SMT solver Z3 \n[15] for solving label con\u00adstraints that arise during composition and equivalence checking algorithms, \nas well as for witness search by model generation using auxiliary SFT axioms. Finite state transducers \nhave been used for dynamic and static analysis to validate sanitization functions in web ap\u00adplications \nin [3], by an over-approximation of the strings accepted by the sanitizer using static analysis of exist\u00ading \nPHP code. Other security analysis of PHP code, e.g., SQL injection attacks, use string analyzers to obtain \nover\u00adapproximations (in form of context free grammars) of the HTML outputby a server[35,49].Yu et al. \nshowhow mul\u00adtiple automata canbe composed to modellooping code[51]. Our work is complementary to previous \ne.orts in using SMT solvers to solve problems related to list transforma\u00adtions. The tools HAMPI [30] \nand Kaluza [42] extend the STP solver to handle equations over strings and equations with multiple variables.The \nworkin[25] showshowto solve subset constraints on regularlanguages.In contrast, we show how to combine \nany of these solvers with SFTs whose edges can take symbolic values in the theories understood by the \nsolver. Top-down tree transducers [21]provide another extension of .nite state transducers: a .nite state \ntransducer is a top\u00addown tree transducer over a monadic ranked alphabet. Sim\u00adilar to .nite state transducers, \ndecidability of equivalence of top-down tree transducers is known for the single-valued case [18, 20], \nincluding a specialized method for the deter\u00administic case [10], and also for the .nite-valued case [45]. \nSeveral non-symbolic extensions of top-down tree transduc\u00adershavebeen studied, e.g.,[19,21,31,33,34,39].Symbolic \ntop-down tree transducers are studiedin[46] wherepartial equivalence is shown to be decidable for the \nlinear single\u00advalued case. 6. Conclusion We introduced a symbolic extension of the theory of clas\u00adsical \n.nite transducers, where transitions are represented by terms modulo a given background theory. Our approach \nenables a range of analyses in combination with state-of\u00adthe-art constraint solving techniques. The core \nalgorithms we presented are composition and equivalence checking of single-valued symbolic .nite transducers, \nand we showed how to decide whether arbitrary symbolic transducers have the single-valuedness property. \nWe demonstrated how our work directly applies to analysis of web string sanitizers, malware detection, \nimage manipulation, and location pri\u00advacy, and we expect more applications to follow. Our tech\u00adniques \ncan synthesize string pre-images in excess of 8, 000 bytesin roughlya minute, ourST representationhad10, \n000 times fewer states than previous approaches, and we found lazy ST encoding for our HTMLDecode example \ntook at most 20 seconds evenin the most extreme cases.These algorithms make it possible to work with \nsymbolic representations of transducers,just astraditionallydonewith.nitestatetrans\u00adducers, as .rst class \ncitizens in designing new analyses and program transformation techniquesbyleveragingthe contin\u00aduous advances \nand improvements in constraint solvers and satis.ability modulo theories solvers. References [1] R. Alur \nand P. Cern\u00b4y. Streaming transducers for algorith\u00admic veri.cation of single-pass list-processing programs. \nIn POPL 11, pages 599 610. ACM, 2011. [2] D. E. Bakke, R. Parameswaran, D. M. Blough, A. A. Franz, and \nT. J. Palmer. Data obfuscation: Anonymity and desen\u00adsitization of usable data sets. IEEE Security and \nPrivacy, Apr. 2004. [3] D. Balzarotti, M. Cova, V. Felmetsger, N. Jovanovic, E.Kirda,C.Kruegel, andG.Vigna. \nSaner:Composing static and dynamic analysis to validate sanitization in web appli\u00adcations. In IEEE Oakland \nSecurity and Privacy, 2008. [4] Bek. http://research.microsoft.com/bek. [5] M. Benedikt, C. Ley, and \nG. Puppis. Automata vs. logics on data words. In CSL, volume 6247 of LNCS, pages 110 124. Springer, 2010. \n[6] N. Bj\u00f8rner and M. Veanes. Symbolic transducers. Technical Report MSR-TR-2011-3, Microsoft Research, \nJanuary 2011. [7] M. Boja\u00b4nczyk, A. Muscholl, T. Schwentick, L. Segou.n, and C. David. Two-variable logic \non words with data. In LICS, pages 7 16. IEEE, 06. [8] A. Brush, J. Krumm, and J. Scott. Exploring end \nuser preferences for location obfuscation, location-based services, and the value of location. In UbiComp, \nSeptember 2010. [9] K. Z. Chen, G. Gu, J. Nazario, X. Han, and J. Zhuge. WebPatrol: Automated collection \nand replay of web-based malware scenarios. In ASIACCS, March 2011. [10] B. Courcelle and P. Franchi-Zannettacchi. \nAttribute gram\u00admars and recursive program schemes. Theoretical Computer Science, 17:163 191, 1982. [11] \nM. Cova, C. Kruegel, and G. Vigna. Detection and analysis of drive-by-download attacks and malicious \nJavaScript code. In WWW Conference, Raleigh, NC, April 2010. [12] K. Culic and J. Karhum\u00a8 aki. The equivalence \nof .nite-valued transducers(on HDTOLlanguages) isdecidable. Theoretical Computer Science, 47:71 84, 1986. \n[13] C. Curtsinger, B. Livshits, B. Zorn, and C. Seifert. Zozzle: Low-overhead mostly staticjavascript \nmalwaredetection. In Proceedings of the Usenix Security Symposium, Aug. 2011. [14] G. B. Dantzig and \nB. C. Eaves. Fourier-Motzkin elimination and its dual. Journal of Combinatorial Theory (A), 14:288 297, \n1973. [15] L. de Moura and N. Bj\u00f8rner. Z3: An E.cient SMT Solver. In TACAS 08, LNCS, 2008. [16] A.J.Demers,C.Keleman, \nandB.Reusch.On somedecidable properties of .nite state translations. Acta Informatica, 17: 349 364, 1982. \n[17] P. Eckersley. How unique is your web browser? In Privacy Enhancing Technologies, pages 1 18, 2010. \n[18] J. Engelfriet. Some open questions and recent results on tree transducers and tree languages. In \nR. V. Book, editor, Formal Language Theory, pages 241 286. Academic Press, 1980.  [19] J. EngelfrietandS. \nManeth. Acomparisonofpebbletree [35] Y.Minamide.Staticapproximationofdynamicallygenerated transducers \nwith macro tree transducers. Acta Informatica, 39:2003, 2003. [20] Z. Esik. Decidability results concerning \ntree transducers. Acta Cybernetica, 5:1 20, 1980. [21] Z. F\u00a8op and H. Vogler. Syntax-Directed Semantics: \nFormal ul\u00a8Models Based on Tree Transducers. EATCS. Springer, 1998. [22] T. L. Gall and B. Jeannet. Lattice \nautomata: A represen\u00adtation for languages on in.nite alphabets, and some appli\u00adcations to veri.cation. \nIn SAS 2007, volume 4634 of LNCS, pages 52 68, 2007. [23] T.Gri.ths.Theunsolvability of the equivalenceproblemfor \n.-free nondeterministic generalized machines. J. ACM, 15: 409 413, 1968. [24] P. Hooimeijer and M. Veanes. \nAn evaluation of automata al\u00adgorithms for string analysis. In VMCAI 11, LNCS. Springer, 2011. [25] P. \nHooimeijer and W. Weimer. A decision procedure for subset constraints over regular languages. In Proceedings \nof the Conference on Programming Language Design and Implementation, pages 188 198, New York, NY, USA, \n2009. ACM. ISBN 978-1-60558-392-1. [26] P. Hooimeijer and W. Weimer. Solving string constraints lazily. \nIn ASE, 2010. [27] P. Hooimeijer, B. Livshits, D. Molnar, P. Saxena, and M. Veanes. Fast and precise \nsanitizer analysis with bek. In Proceedings of the USENIX Security Symposium, August 2011. [28] O. Ibarra. \nThe unsolvability of the equivalence problem for Efree NGSM s with unary input (output) alphabet and \napplications. SIAM Journal on Computing,4:524 532, 1978. [29] M. Kaminski and N. Francez. Finite-memory \nautomata. In 31st Annual Symposium on Foundations of Computer Science (FOCS 1990), volume2,pages683 688.IEEE,1990. \n[30] A. Kiezun, V. Ganesh, P. J. Guo, P. Hooimeijer, and M. D. Ernst. HAMPI: a solver for string constraints. \nIn ISSTA, 2009. [31] N.Kobayashi,N.Tabuchi, and H.Unno. Higher-order multi\u00adparameter tree transducers \nand recursion schemes for pro\u00adgram veri.cation. In POPL, pages 495 508. ACM, 2010. [32] J. Krumm. A survey \nof computational location privacy. Personal Ubiquitous Comput., 13:391 399, August 2009. [33] A.Maletti,J.Graehl,M.Hopkins, \nandK.Knight. Thepower of extended top-down tree transducers. SIAM J. Comput., 39:410 430, June 2009. \n[34] T. Milo, D. Suciu, and V. Vianu. Typechecking for XML transformers. In Proc. 19th ACM Symposium \non Princi\u00adples of Database Systems (PODS 2000), pages 11 22. ACM, 2000. web pages. In WWW 05: Proceedings \nof the 14th Interna\u00adtional Conference on the World Wide Web, pages 432 441, 2005. ISBN 1-59593-046-9. \n[36] K. Mowery, D. Bogenreif, S. Yilek, and H. Shacham. Fin\u00adgerprinting information in javascript implementations. \nIn Proceedings of Web 2.0 Security and Privacy 2011 (W2SP), May 2011. [37] F.Neven,T.Schwentick,andV.Vianu.Finitestatemachines \nfor strings over in.nite alphabets. ACM Trans. CL, 5:403 435, 2004. [38] G. V. Noord and D. Gerdemann. \nFinite state transducers with predicates and identities. Grammars, 4:263 286, 2001. [39] C.-H. L. Ong \nand S. J. Ramsay. Verifying higher-order functional programs with pattern-matching algebraic data types. \nIn POPL 11, pages 587 598. ACM, 2011. [40] J.R.Parker. Algorithms for Image Processing and Computer Vision. \nWiley and Sons, 2006. [41] P. Ratanaworabhan, B. Livshits, and B. Zorn. Nozzle: A defense against heap-spraying \ncode injection attacks. In Proceedings of the Usenix Security Symposium, Aug. 2009. [42] P.Saxena,D.Akhawe,S.Hanna,S.McCamant, \nF.Mao,and D.Song. A symbolic executionframeworkforjavascript. In IEEE Security and Privacy, 2010. [43] \nM. P. Sch\u00a8Sur les relations rationnelles. utzenberger. In GI Conference on Automata Theory and Formal \nLanguages, volume 33 of LNCS, pages 209 213, 1975. [44] L. Segou.n. Automata and logics for words and \ntrees over an in.nite alphabet. In Z. Esik, editor, CSL, volume 4207 of \u00b4 LNCS, pages 41 57, 2006. [45] \nH. Seidl. Equivalence of .nite-valued tree transducers is decidable. Math. Systems Theory, 27:285 346, \n1994. [46] M. Veanes and N. Bj\u00f8rner. Symbolic tree transducers. In Perspectives of System Informatics \n(PSI 11), 2011. [47] M.Veanes,N.Bj\u00f8rner, andL.deMoura. Symbolic automata constraint solving.InC.Ferm\u00a8 \nullerandA.Voronkov, editors, LPAR-17, volume 6397 of LNCS, pages 640 654, 2010. [48] M. Veanes, P. de \nHalleux, and N. Tillmann. Rex: Symbolic Regular Expression Explorer. In ICST 10. IEEE, 2010. [49] G. \nWassermann, D. Yu, A. Chander, D. Dhurjati, H. Ina\u00admura, and Z. Su. Dynamic test input generation for \nweb applications. In ISSTA, 2008. [50] A.Weber. Decomposing .nite-valued transducersanddecid\u00ading their \nequivalence. SIAM Journal on Computing, 22(1): 175 202, February 1993. [51] F. Yu, T. Bultan, and O. \nH. Ibarra. Relational string veri.cation using multi-track automata. In Proceedings of the 15th international \nconference on Implementation and application of automata, CIAA 10, pages 290 299, 2011.   \n\t\t\t", "proc_id": "2103656", "abstract": "<p>Finite automata and finite transducers are used in a wide range of applications in software engineering, from regular expressions to specification languages. We extend these classic objects with symbolic alphabets represented as parametric theories. Admitting potentially infinite alphabets makes this representation strictly more general and succinct than classical finite transducers and automata over strings. Despite this, the main operations, including composition, checking that a transducer is single-valued, and equivalence checking for single-valued symbolic finite transducers are effective given a decision procedure for the background theory. We provide novel algorithms for these operations and extend composition to symbolic transducers augmented with registers. Our base algorithms are unusual in that they are nonconstructive, therefore, we also supply a separate model generation algorithm that can quickly find counterexamples in the case two symbolic finite transducers are not equivalent. The algorithms give rise to a complete decidable algebra of symbolic transducers. Unlike previous work, we do not need any syntactic restriction of the formulas on the transitions, only a decision procedure. In practice we leverage recent advances in satisfiability modulo theory (SMT) solvers. We demonstrate our techniques on four case studies, covering a wide range of applications. Our techniques can synthesize string pre-images in excess of 8,000 bytes in roughly a minute, and we find that our new encodings significantly outperform previous techniques in succinctness and speed of analysis.</p>", "authors": [{"name": "Margus Veanes", "author_profile_id": "81100266422", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2991360", "email_address": "margus@microsoft.com", "orcid_id": ""}, {"name": "Pieter Hooimeijer", "author_profile_id": "81375612581", "affiliation": "University of Virginia, Charlottesville, VA, USA", "person_id": "P2991361", "email_address": "pieter@cs.virginia.edu", "orcid_id": ""}, {"name": "Benjamin Livshits", "author_profile_id": "81100637280", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2991362", "email_address": "livshits@microsoft.com", "orcid_id": ""}, {"name": "David Molnar", "author_profile_id": "81100444889", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2991363", "email_address": "dmolnar@microsoft.com", "orcid_id": ""}, {"name": "Nikolaj Bjorner", "author_profile_id": "81100064073", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2991364", "email_address": "nbjorner@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103674", "year": "2012", "article_id": "2103674", "conference": "POPL", "title": "Symbolic finite state transducers: algorithms and applications", "url": "http://dl.acm.org/citation.cfm?id=2103674"}