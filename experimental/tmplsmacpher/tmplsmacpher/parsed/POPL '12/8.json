{"article_publication_date": "01-25-2012", "fulltext": "\n A Language for Automatically Enforcing Privacy Policies Jean Yang Kuat Yessenov Armando Solar-Lezama \nMIT CSAIL {jeanyang, kuat, asolar} @csail.mit.edu Abstract It is becoming increasingly important for \napplications to protect sensitive data. With current techniques, the programmer bears the burden of ensuring \nthat the application s behavior adheres to poli\u00adcies about where sensitive values may .ow. Unfortunately, \nprivacy policies are dif.cult to manage because their global nature requires coordinated reasoning and \nenforcement. To address this problem, we describe a programming model that makes the system respon\u00adsible \nfor ensuring adherence to privacy policies. The programming model has two components: 1) core programs \ndescribing functional\u00adity independent of privacy concerns and 2) declarative, decentralized policies \ncontrolling how sensitive values are disclosed. Each sen\u00adsitive value encapsulates multiple views; policies \ndescribe which views are allowed based on the output context. The system is respon\u00adsible for automatically \nensuring that outputs are consistent with the policies. We have implemented this programming model in \na new functional constraint language named Jeeves. In Jeeves, sensitive values are introduced as symbolic \nvariables and policies correspond to constraints that are resolved at output channels. We have imple\u00admented \nJeeves as a Scala library using an SMT solver as a model .nder. In this paper we describe the dynamic \nand static semantics of Jeeves and the properties about policy enforcement that the se\u00admantics guarantees. \nWe also describe our experience implementing a conference management system and a social network. Categories \nand Subject Descriptors D.3.3 [PROGRAMMING LANGUAGES]: Language Constructs and Features General Terms \nLanguages, security Keywords Language design, run-time system, privacy, security 1. Introduction As users \nshare more personal data online, it becomes increasingly important for applications to protect con.dentiality. \nThis places the burden on programmers to ensure compliance even when both the application and the policies \nmay be evolving rapidly. This work was funded in part by the U.S. Government under the DARPA UHPC and \nNSF Graduate Research Fellowship programs. The views and conclusions contained herein are those of the \nauthors and should not be interpreted as representing the of.cial policies, either expressed or implied, \nof the U.S. Government. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 12, January 25 27, 2012, Philadelphia, PA, USA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. \n. . $10.00 Ensuring compliance with privacy policies requires reasoning globally about both the .ow of \ninformation and the interaction of different policies affecting this information. A number of tools have \nbeen developed to check code against privacy policies statically [4, 19] and dynamically [27]. While \nthese checking tools can help avoid data leaks, the programmer is still responsible for implementing \napplications that display enough information to satisfy the user s needs without violating privacy policies. \nThe programming model that we propose goes beyond checking to simplify the process of writing the code \nthat preserves con.dentiality. The main contribution of this paper is a new programming model that makes \nthe system responsible for automatically producing out\u00adputs consistent with programmer-speci.ed policies. \nThis automation makes it easier for programmers to enforce policies specifying how each sensitive value \nshould be displayed in a given context. The pro\u00adgramming model has two components: a core program representing \npolicy-agnostic functionality and privacy policies controlling the disclosure of sensitive values. This \nseparation of policies from core functionality allows the programmer to express policies explicitly in \nassociation with sensitive data rather than implicitly across the code base. The declarative nature of \npolicies allows the system to ensure compliance even when these policies interact in non-trivial ways. \nWe have implemented this programming model in a new func\u00adtional constraint language named Jeeves. Jeeves \nintroduces three main concepts: sensitive values, policies, and contexts. Sensitive values are introduced \nas pairs (v.|vT)e, where v. is the low\u00adcon.dentiality value, vT is the high-con.dentiality value, and \ne is a level variable that can take on the values { ., T } and determines which view of the value should \nbe shown. Policies correspond to constraints on the values of level variables. The language of policies \nis a decidable logic of quanti.er-free arithmetic constraints, boolean constraints, and equality constraints \nover records and record .elds. A policy may refer to a context value characterizing the output channel \nand containing relevant information about how the data is viewed. For example, in a small social networking \napplication we imple\u00admented as a case study, we included a policy that allows users to restrict the disclosure \nof their location to users in their geographic vicinity. Because the location is a sensitive value, a \nfunction such as print that tries to output a value derived from a location will need to be passed a \ncontext containing the location of the user to whom this value is about to be displayed. Using this context, \nthe runtime system can then derive an output that is consistent with the policy. We formally specify \nJeeves to show that the high-con.dentiality component of a sensitive value can only affect program output \nif the policies allow it. We de.ne Jeeves in terms of .J, a constraint functional language that describes \nthe propagation and enforcement of policies in Jeeves. .J is different from existing constraint func\u00adtional \nlanguages [9, 10, 15, 18, 25] in the restrictions it places on the logical model and its use of default \nlogic to provide determin\u00adism in program behavior. These restrictions make it possible for .J to have \nan ef.cient execution model without sacri.cing too much expressiveness. There is a straightforward translation \nfrom Jeeves  Level ::= . | T levels Exp ::= . | Exp1 (op) Exp2 expressions | if Exp1 then Expt else \nExpf | Exp1 Exp2 | (Exp. | ExpT)(e) | level e in Exp | policy e: Expp then Level in Exp Stmt ::= let \nx : t = Exp | print {Expc} Exp Figure 1: Jeeves syntax. to .J: Jeeves level variables for sensitive \nvalues are logic variables, policies are assertions, and all values depending on logic variables are \nevaluated symbolically. The symbolic evaluation and constraint propagation in .J allow Jeeves to automatically \nenforce policies about information .ow. We implemented Jeeves as a domain-speci.c language embed\u00added \nin Scala [20] using the Z3 SMT solver [17] to resolve constraints as a way to demonstrate the feasibility \nof the Jeeves programming model. To evaluate the expressiveness of Jeeves, we have used our Scala embedding \nto implement a small conference management sys\u00adtem and a small social network. The case studies show \nthat Jeeves allows the separate implementation of functionality and policies. For example, in the conference \nmanagement example the code makes no attempt to differentiate between users, or even the general public, \nyet the policies ensure that the system displays the right level of information to each user through \nevery phase of the review process. In summary, we make the following contributions in this paper: We \npresent a programming model and language, Jeeves, that allows programmers to separate privacy concerns \nfrom core program functionality.  We formalize the dynamic and static semantics of Jeeves in terms of \na .J, a new constraint functional language. We prove that Jeeves executions satisfy a non-interference \nproperty between low and high components of sensitive values.  We describe the implementation of Jeeves \nas an embedded domain-speci.c language in Scala using the Z3 SMT solver.  We describe small case studies \nthat show that Jeeves supports the desired policies and allows the programmer to separately develop core \nfunctionality and policies.  2. Delegating Privacy to Jeeves Jeeves allows the programmer to specify \npolicies explicitly and upon data creation rather than implicitly across the code base. The Jeeves system \ntrusts the programmer to correctly specify policies describing high-and low-con.dentiality views of sensitive \nvalues and to correctly provide context values characterizing output channels. The runtime system is \nresponsible for producing outputs consistent with the policies given the contexts. Jeeves guarantees \nthat the system will not leak information about a high-con.dentiality value unless the policies allow \nthis value to be shown. In this section, we introduce a simple conference management example to explain \nthe main ideas in Jeeves: introducing sensitive values, writing policies, providing contexts, and implementing \nthe core program logic. Conference management systems have simple information .ow policies that are dif.cult \nto implement given the interaction of features. Being able to separately specify the policies allows \nthe core functionality to be quite concise. In fact, we can write a single program that allows all viewers \nto access the list of papers directly for searching and viewing. The program relies on the Jeeves runtime \nsystem to display the appropriately anonymized information for reviewers vs. the general public. For \nthe sake of brevity, we present Jeeves using an ML-like concrete syntax, shown in Figure 1. 2.1 Introduction \nto Jeeves We .rst describe how to introduce sensitive values, use them to compute result values, and \ndisplay the results in different output contexts. Suppose we have the policy that a sensitive value name \nshould be seen as \"Alice\" by users with a high con.dentiality level and as \"Anonymous\" by anybody else. \nA Jeeves program can use the name value as follows: let msg = \"Author is \" + name print { alice } msg \n(* Output: \"Author is Alice\" *) print { bob } msg (* Output: \"Author is Anonymous\" *) To achieve the \ndifferent outputs for alice and bob, we associate a policy with name by declaring it through the following \nJeeves code: let name = level a in policy a: ! (context = alice) then . in <\"Anonymous\" | \"Alice\">(a) \nThis code introduces a level variable a and associates with it a policy that if the context value is \nnot alice , then the value is .. The context value represents a viewer in the output chan\u00adnel. The code \nthen attaches this policy to the sensitive value <\"Anonymous\" | \"Alice\">(a), which de.nes the low-con.dentiality \nview as the string \"Anonymous\" and the high-con.dentiality view as \"Alice\". When this code is executed, \nthe Jeeves runtime ensures that only the user alice can see her name appearing as the author in the string \nmsg. User bob sees the string \"Author is Anonymous\". Each sensitive value de.nes a low-con.dentiality \nand high\u00adcon.dentiality view for a value. The Jeeves programmer de.nes sensitive values by introducing \na tuple (v.|vT)e where v. is the low\u00adcon.dentiality value, vT is the high con.dentiality value, and e \nis a level variable associated with a set of policies determining which of the two values to show. An \nexpression containing n sensitive values can evaluate to one of 2n possible views. Level variables provide \nthe means of abstraction to specify policies incrementally and independently of the sensitive value declaration. \nLevel variables can be constrained directly (by explicitly passing around a level variable) or indirectly \n(by constraining another level variable when there is a dependency). It is possible to encode more than \ntwo privacy levels, but for the sake of simplicity the paper assumes only two. Policies, introduced through \npolicy expressions, provide declar\u00adative rules describing when to set a level variable to T or .. Notice \nthat the policy above forces a to be . when the user is not alice ; other policies could further restrict \nthe level variable to be . even for alice , but no amount of policy interactions can allow a different \nuser to see the vT value in contradiction with the policy. Policies may mention variables in scope and \nalso the context variable, which corresponds to an implicit parameter characterizing the output chan\u00adnel. \nThe context construct relieves the programmer of the burden of structuring code to propagate values from \nthe output context to the policies. Statements such as print that release information to the viewer require \na context parameter. The Jeeves runtime system propagates policies associated with sensitive values so \nthat when a value is about to be displayed though an output channel, the right context can be inserted \ninto the policy and the appropriate result can be produced. In addition to print shown above, other output \nchannels include sending e-mail and writing to .le.  2.2 Declarative and Decentralized Policies We now \ndescribe how to write policies in Jeeves using fragments of our conference management example. The paper \nrecord is de.ned below; it assumes single author papers to simplify the presentation.  type paper { \ntitle : string ; author: user ; reviews: review list ; accepted: bool option } The idiomatic way of attaching \npolicies to values is to create sensitive values for each .eld and then attach policies: let mkPaper \n( title : string) (author: string) (reviews: review list ) (accepted: bool option): paper = level tp, \nauthp, rp, accp in let p = { title = < \"\" | title >(tp) ; author = < \"Anonymized\" | author>(authp) ; \nreviews = < [] | reviews>(rp) ; accepted = < none | some accepted >(accp) } in addTitlePolicy p tp; addAuthorPolicy \np authp; addReviewsPolicy p rp; addAcceptedPolicy p accp; p This function introduces level variables \nfor each of the .elds, creates sensitive values for each of the .elds, attaches policies to the level \nvariables, and returns the resulting paper record. The Jeeves programmer associates policies with sensitive \nvalues by introducing level variables, attaching policies to them, and using them to create sensitive \nvalues. Consider the policy that the title of a paper should be visible to the authors of the paper, \nreviewers, and PC members and only visible to the general public after it is public that the paper has \nbeen accepted. We can de.ne addTitlePolicy as follows: let addTitlePolicy (p: paper) (a: level ): unit \n= policy a: ! (context.viewer = p.author || context.viewer.role =Reviewer || context.viewer.role =PC \n|| (context.stage = Public &#38;&#38; isAccepted p)) then . This function attaches to level variable \na a policy that sets the level to . unless the viewer has a right to see the paper title. Policies may \nrefer to values corresponding to the output channel through the context variable. The condition for the \npolicy in function addTitlePolicy uses the viewer and stage .elds of the context variable, which have \ntypes confView and confStage types, respectively: type confView { viewer: user; stage: confStage } type \nconfStage = Submission | Review | Decision | Public A context value of type confView must be produced \nin order for an output channel to access a sensitive value produced by the addTitlePolicy function. With \ntype inference, it is not necessary for the programmer to provide the context type annotation. In the \nScala implementation, the programmer does not need to provide context annotations. 2.2.1 Policy Interactions \nThe Jeeves model helps prevent the programmer from inadvertently leaking information about one value \nthrough the enforcement of a policy for another value. We show how Jeeves can prevent the programmer \nfrom writing code where the policy for paper titles leaks information about a paper record s accepted \n.eld. Consider the following situation in which the policy for one sen\u00adsitive .eld (paper titles) depends \non another sensitive .eld (whether the paper has been accepted). In the addTitlePolicy function, the \npredicate isAccepted p depends on the accepted .eld of the paper p, which is some accepted if a decision \nhas been made (and the decision is known) or none otherwise. The accepted .eld needs its own policy to \nprevent its status from being leaked early. The following function adds the appropriate policy: let addAcceptedPolicy \n(p: paper) (a: level ): unit = policy a: ! (context.viewer.role =Reviewer || context.viewer.role =PC \n|| context.stage = Public) then . This policy allows reviewers and program committee members to always \nsee whether a paper has been accepted and for others to see this .eld only if the stage is Public. With \nthis policy in place, the title .eld cannot leak information about the accepted tag. Even if the policy \nfor paper titles were to drop the context.stage = Public requirement, the policy for accepted would prevent \nthe titles of accepted papers from being leaked before the Public stage.  2.2.2 Circular Dependencies \nand Defaults The Jeeves system can also enforce policies when there are circular dependencies between \nsensitive values, as could happen when a context value depends on a sensitive value. Consider the following \nfunction that associates a policy with the authors of a paper: let addAuthorPolicy (p: paper)(n: level \n): unit = policy n: !(isAuthor p context.user ||(context.stage = Public &#38;&#38; isAccepted p)) then \n. This policy says that to see the author of a paper, the user must be an author or the paper must be \na publicly accepted paper. Now consider functionality that sends messages to authors of papers: let sendMsg \n(author: user) = let msg = \"Dear \" + author.name + ... in sendmail { user = author; stage = Review } \nmsg The policy for level variable n depends on context.user. Here, context.user is a sensitive value, \nas the value of the author variable depends on the viewer. This leads to a circular dependency that makes \nthe solution underconstrained: the value of the message recipient on the context value, which contains \nthe message recipient. Either sending mail to the empty user or sending mail to the author is correct \nunder the policy. The latter behavior is preferred, as it ensures that user a can communicate with user \nb without knowing private information about user b. The Jeeves runtime ensures this maximally functional \nbehavior by setting level variables to T by default: if the policies allow a level variable to be T or \n., the value will be T. 3. The .J Language and Semantics To more formally describe the guarantees, we \nde.ne the semantics of Jeeves in two steps; .rst, we introduce .J, a simple constraint functional language \nbased on the .-calculus, and then we show how to translate Jeeves to .J. .J differs from existing constraint \nfunc\u00adtional languages [9, 10, 15, 25] in two key ways: 1) .J restricts its constraint language to quanti.er-free \nconstraints involving boolean and arithmetic expressions over primitive values and records and 2) .J \nsupports default values for logic variables to facilitate reasoning about nondeterminism. .J s restrictions \non the constraint language allow execution to rely on an off-the-shelf SMT solver. In this section, we \nintroduce the .J language, the dynamic semantics, the static semantics, and the translation from Jeeves. \nThe .J language extends the .-calculus with defer and assert for introducing and constraining logic variables, \nas well as a concretize construct to produce concrete values from them. The dynamic semantics describe \nthe lazy evaluation of expressions with logic variables and the interaction with the constraint environment. \nThe static semantics describe how the system guarantees evaluation progress and enforces restrictions \non symbolic values and recursion. The translation from Jeeves to .J illustrates how Jeeves uses .J s \nlazy evaluation and constraint propagation, combined with Jeeves restrictions on how logic variables \nare used, to provide privacy guarantees.  c ::= n | b | .x : t.e | record x7: . | error | () concrete \nprimitives s ::= x | context t symbolic values | c1 (op) s2 | s1 (op) c2 | s1 (op) s2 | if s then .t \nelse .f . ::= c | s values e ::= . | e1 (op) e2 expressions | if e1 then et else ef | e1 e2 | let x : \nt = e1 in e2 | let rec f : t = e1 in e2 | defer x : t {e} default .d | assert e | concretize e with .c \nFigure 2: The .J abstract syntax. 3.1 The .J Language .J is the .-calculus extended with logic variables. \nFigure 2 shows the abstract syntax of .J. Expressions (e) include the standard . expressions extended \nwith the defer construct for introducing logic variables, the assert construct for introducing constraints, \nand the concretize construct for producing concrete values consistent with the constraints. .J evaluation \nproduces irreducible values (.), which are either concrete (c) or symbolic (s). Concrete values are what \none would expect from .-calculus, while symbolic values are values that cannot be reduced further due \nto the presence of logic variables. Symbolic values also include the context construct which allows constraints \nto refer to a value supplied at concretization time. The context variable is an implicit parameter [14] \nprovided in the concretize expression. In the semantics we model the behavior of the context variable \nas a symbolic value that is constrained during evaluation of concretize. .J contains a let rec construct \nthat handles recursive functions in the standard way using .x. A novel feature of .J is that logic variables \nare also associated with a default value that serves as a default assumption: this is the assigned value \nfor the logic variable unless it is inconsistent with the constraints. The purpose of default values \nis to provide some determinism when logic variables are underconstrained.  3.2 Dynamic Semantics The \n.J evaluation rules extend .-calculus evaluation with constraint propagation and symbolic evaluation \nof logic variables. Evaluation involves keeping track of constraints which are required to be true (hard \nconstraints) and the set of constraints we use for guidance if consistent with our hard constraints (default \nassumptions). To correctly evaluate conditionals with symbolic conditions, we also need to keep track \nof the (possibly symbolic) path condition. Evalu\u00adation happens in the context of a path condition G, \nan environment S = 0/ |{s}| S . S' storing the current set of constraints, and an environment . = 0/ \n|{s}| . . .' storing the set of constraints on default values for logic variables. Evaluation rules take \nthe form G f(S,.,e).(S',.',e'). ' Evaluation produces a tuple (S',.',e') of a resulting expression ealong \nwith modi.ed constraint and default environments. In Figure 3 we show the small-step dynamic .J semantics. \n3.2.1 Evaluation with Logic Variables .J has the expected semantics for function application and arithmetic \nandbooleanoperations.The E-APP1,E-APP2,and E-APPLAMBDA rules describe a call-by-value semantics. The \nE-OP1 and E-OP2 rules for operations show that the arguments are evaluated to irre\u00adducible expressions \nand then, if both arguments become concrete, the E-OP rule can be applied to produce a concrete result. \nConditionals whose conditions evaluate to concrete values eval\u00aduate according to the E-CONDTRUE, and \nE-CONDFALSE rules as one would expect. When the condition evaluates to a symbolic value, the whole conditional \nevaluates to a symbolic if-then-else value by evaluating both branches as described by the E-CONDSYMT \nand E-CONDSYMF rules. Note that .J expressions are pure (effects are only in Jeeves statements) so side \neffects cannot occur in conditional branches. Evaluating under symbolic conditions is potentially dangerous \nbecause evaluation of such conditionals with a recursive function application in a branch could lead \nto in.nite recursion when the condition is symbolic. Our system prevents this anomalous behavior by using \nthe type system to enforce that recursive calls are not made under symbolic conditions (Section 3.3). \n 3.2.2 Introduction and Elimination of Logic Variables In .J, logic variables are introduced through \nthe defer keyword. To illustrate the semantics of defer consider the example below. let x: int = defer \nx : int {x >0} default 42 As we show in the E-DEFER evaluation rule, the right-hand side of the assignment \nevaluates to an a-renamed version of the logic variable x . Evaluation adds the constraint G . x >0 to \nthe constraint environment and the constraint G . x =42 to the default constraint environment. The constraint \nG . x >0 is a hard constraint that must hold for all derived outputs, while G . x =42 is a constraint \nthat is only used if it is consistent with the resulting logical environment. Hard constraints are introduced \nwithin the braces ({}) of defer expressions and through assert expressions; soft constraints are introduced \nthrough the default clause of defer expressions. In addition to the constraints in defer, the program \ncan intro\u00adduce constraints on logic variables through assert expressions. The E-ASSERT rule describes \nhow the constraint is added to the con\u00adstraint environment, taking into account the path condition G. \nFor instance, consider the following code: if (x >0) then assert (x =42) else assert (x = -42). Evaluation \nadds to the constraint environment the constraints x>0 . x =42 and \u00ac(x >0) . x= -42. Symbolic expressions \ncan be made concrete through the concretize construct. Evaluation of concretize expressions either produces \na concrete value or an error. A concretize expression includes the expression to concretize and a context: \n let result : int = concretize x with 42. As we describe in the E-CONCRETIZESAT rule, concretization \nadds the constraint context = 42 to the constraint environment and .nds an assignment to x consistent \nwith the constraint and default environments. An important observation is that the context itself may \nbe symbolic, in which case the system will also be .nding a concrete context consistent with the hard \nconstraints. The MODEL function takes the constraint and default environments, computes a satisfying \nassignment to free variables, and produces a substitution M : . . c that is used to produce a concrete \nvalue, as shown in the E-CONCRETIZESAT rule. The CONCRETIZE-UNSAT rule describes what happens if there \nis no satis.able expression consistent with the constraint environ\u00adment. In this case, evaluation of \nthe concretize expression produces the error value.  3.2.3 Interaction with the Constraint Environment \nValid constraint expressions consist of .J expressions that do not contain .-expressions. This constraint \nlanguage corresponds to constraints that can be solved by off-the-shelf SMT solvers. The  G f(S,., e).(S' \n, .' ,e ') G f(S,.,e1).(S' ,.' , e1') G f(S,.,e2).(S' ,.' ,e2') E-APP1 E-APP2 '' G f(S,.,e1 e2).(S' \n,.' , e1 e2) G f(S, .,. e2).(S' ,.' ,. e2) ' c = c1 (op) c2 E-APPLAMBDA E-OP G f(S, .,.x.e .).(S, .,e[x \n. .]) G f(S,.,c1 (op) c2).(S,., c ')G f(S,.,e1).(S' ,.' , e1') G f(S, .,e2).(S' ,.' ,e2') E-OP1 E-OP2 \n G f(S,., e1 (op) e2).(S' ,.' , e1 ' (op) e2) G f(S,., . (op) e2).(S' ,.' ,. (op) e ' 2)G f(S,., ec).(S' \n,.' ,e ') c E-COND G f(S,., if ec then et else ef ).(S' ,.' , if e ' then et else ef ) c G f(S,., et \n).(S' , .' ,et ') G f(S,., ef ).(S' ,.' , e ' f ) E-CONDTRUE E-CONDFALSE G f(S, ., if true then et else \nef ).(S' ,.' , et ') G f(S, ., if false then et else ef ).(S' ,.' ,e ' f ) s . G f(S,., et ).(S' , .' \n,et ') E-CONDSYMT G f(S,., if s then et else ef ).(S' ,.' , if s then e ' else ef ) t \u00acs . G f(S, .,ef \n).(S' , .' ,e ' f ) E-CONDSYMF  G f(S,., if s then .t else ef ).(S' ,.' , if s then .t else e ' f ) \nG f(S,., e).(S' , .' ,e ') E-DEFERCONSTRAINT G f(S,., defer x : t {e} default .d ).(S' , .' , defer \nx : t {e '} default .d )fresh x ' E-DEFER ' G f(S,., defer x : t {.c} default .d ).(S .{G . .c[x . x \n' ]},. .{G . x = .d },x ')G f(S,., e).(S' , .' ,e ') E-ASSERTCONSTRAINT E-ASSERT G f(S, ., assert e).(S' \n, .' , assert e ') G f(S, ., assert .).(S .{G . .},., ())G f(S,.,e).(S' ,.' , e ') E-CONCRETIZEEXP G \nf(S, .,concretize e with .c).(S' ,.' , concretize e ' with .c) MODEL(.,S .{G . context = .c})= M c = \nM [[.v]] E-CONCRETIZESAT  G f(S, .,concretize .v with .c).(S,.,c) MODEL(.,S .{G . context = .c})= UNSAT \nE-CONCRETIZEUNSAT G f(S,., concretize .v with .c).(S,., error) Figure 3: Dynamic semantics for .J. MODEL \nprocedure in the E-CONCRETIZE rule is the model .nding procedure for default logic [1]. The default environment \n. and constraint environment S specify a supernormal default theory (.,S) where each default judgement \ns . . has the form true : s s . The MODEL procedure produces either a model M for the theory if it is \nconsistent, or UNSAT. We use a .xed-point algorithm for MODEL that uses classical SMT model-generating \ndecision pro\u00adcedures and iteratively saturates the logical context with default judgements in a non-deterministic \norder.   3.3 .J Static Semantics The .J static semantics ensures that evaluation produces either a \nconcrete expression or a well-formed symbolic expression. Recall that symbolic expressions must be valid \nconstraints, which include arithmetic, boolean, and conditional expressions but not functions. (In the \n.J semantics we do not explicitly address data structures such as lists. Data structures are also required \nto be concrete but may have symbolic elements.) Thus the static semantics guarantee that 1) concrete \nvalues are supplied when concrete values are expected, 2) symbolic values are well-formed, 3) evaluation \nunder symbolic conditions does not cause unexpected in.nite recursion, and 4) d ::= concrete | sym determinism \ntag \u00df ::= intc | boolc | unit base type | int | bool nr t ::= \u00df | t1 . t2 | t1 . t2 type Figure 4: .J \ntypes. context values have the appropriate types. The type system therefore ensures that the logical \nstate will always be well formed, although it cannot guarantee that it will be logically consistent. \nTo guarantee properties 1-3, the .J type system tracks the .ow of symbolic values, ruling out symbolic \nfunctions and reentrant applications under symbolic conditions. Reentrant applications are function applications \nthat may recursively call the current function; we prevent such applications under symbolic conditions \nto prevent non-termination that may arise from evaluating both sides of a conditional branch with a symbolic \ncondition. Property 4, on the other hand, is enforced by ensuring that the type of the context used at \nconcretization is an upper bound for the types of contexts required by all the relevant policies. We \nshow the .J types in Figure 4 and the subtyping, type well-formedness, and typing rules in Figure 5. \nBase types \u00df are the standard .-calculus types extended with the intc and boolc types to indicate values \nthat are necessarily concrete. (Expressions  of function type are not permitted to be symbolic.) There \nare two function types: nr . for functions whose application cannot be reentrant and . for functions \nwhose application can be reentrant. We will use the term reentrant function to refer to a function whose \napplication can be reentrant. Typing judgments have the form G;. f e : t. A judgment says that in the \ntype environment G under a path of type . (sym or concrete), the expression e has type t. G is de.ned \nG ::= \u00b7| x : t | G,G' . The typing rules keep track of whether a value may be symbolic (int or bool type) \nor must be concrete (intc, boolc, and functions). This information is used to determine the value of \nthe . tag in the T-CONDC and T-CONDSYM rules. Information about whether the condition is symbolic is \nused in 1) ruling out symbolic functions and 2) ruling out self-calls under symbolic branches. Symbolicfunctionsarepreventedbythe \nT-DEFER and T-CONDSYM rules, which restrict the production of symbolic functions. The T-DEFER rule restricts \nthe explicit introduction of symbolic val\u00adues to have base type \u00df, while the T-CONDSYM rule restricts \nthe implicit introduction of symbolic values to base type \u00df. The T-LETREC rule shows that recursive functions \nmust be considered reentrant (have . type) within their own de.nitions, since applying the function will \ncause a recursive call to the current function. Outside their declaration, on the other hand, they can \nhave nr . type. A second restriction on reentrant functions is imposed by the type well-formedness predicate \nrep, which requires that functions taking arguments that may be reentrant (.) be themselves labeled as \nreentrant. This prevents high-order functions from being used to circumvent the restrictions on reentrant \ncalls. According to the rules, a reentrant call cannot occur under a symbolic condition. The T-CONDSYM \nrule sets . = sym when the condition is symbolic. The T-APPCURREC rule allows applications of recursive \nfunctions only under concrete paths. This implies that canonical recursive functions such as factorial \ncan only type-check if they require a concrete argument. This restriction does not pre\u00advent recursive \nsort or other recursive structure-traversing functions because data structures are necessarily concrete, \nso conditions in\u00advolving their structure are also concrete. The subtyping relationship <: allows values \nthat are necessarily concrete to be used as potentially symbolic values. This way, functions that require \nconcrete values can only be applied when concrete arguments are supplied, but a concrete value can be \nused as a symbolic value (for instance, intc as int). The subtyping rules allow non-reentrant functions \n( nr .) to be used as reentrant functions (.). 3.3.1 Contexts We also have typing rules (not shown in \nFigure 5) ensuring that contexts of the appropriate type are provided in concretize expres\u00adsions. In \nthe T-CONCRETIZE rule, the context typing judgment fc enforces that the context type supplied is the \ncontext type expected. The context typing judgement is G fcx : tc, where tc is the context type of an \nexpression. The rules propagate the context type, enforce that matching contexts are provided for sub-expressions, \nand enforce that the correct context type is supplied at concretization. We de.ne a lattice describing \nwhen different context types may be combined. The bottom of the lattice is . and for all types t, we \nhave the relationship . <:c t. Contexts support width subtyping on record types: record 7m <:c record \n7n,.ni.(.mi|mi = ni). A record with .elds 7m can be used as a context whenever a record with .elds 7n \nexpected as long as the labelled .elds of mi are a superset of the labelled .elds of 7n.  3.4 Translation \nfrom Jeeves There is a straightforward translation from Jeeves to .J. Sensitive values and level variables \nin Jeeves correspond to .J logic variables, level policies correspond to .J assertions, and contextual \nenforce\u00adment corresponds to producing concrete values consistent with the logical environment. Default \nvalues provide determinism in handling policy dependencies. We show the translation of levels and sensitive \nvalues from Jeeves to .J in Figure 6. We have the Exp Y . e rule to describe how a Jeeves expression \ntranslates to a .J expression e. The translation has the following properties: 1) level variables are \nthe only logic variables, 2) expressions containing sensitive values yield symbolic results, 3) only \nJeeves policies introduce assertions, and 4) the concretize construct can only appear at the outermost \nlevel and is associated with an effectful computation. 3.4.1 Sensitive Values A Jeeves sensitive value \n<v1 | v2>(a) is translated to a symbolic value equal to either v1 or v2 depending on the value of level \nvariable a. Because sensitive values are symbolic, all expressions computed from this sensitive value \nare subject to policies depending on the value of level variable a. 3.4.2 Level Variables Jeeves level \nvariables are translated to .J expressions binding a new logic variable of level type equal to either \n. or T. The default value of level variables is T: the constraint solving oracle .rst resolves the constraint \nenvironment with the assumption that each level is T and only adjusts this belief if the variable must \nbe equal to .. This provides the programmer with some guarantees about program behavior when level variables \nare underconstrained. Underconstraint can arise, for instance, if values in the context depend on sensitive \nvalues. Besides being useful in handling circular dependencies, having the default value of level variables \nas T prevents the programmer from leaking a value as a result of an underspeci.ed value. If a level variable \nis underconstrained, policies on a subsequent variable can affect the value it can take: 1 let x= level \na in <0 | 1>(a) 2 let y= level b in 3 policy b: true then T in 4 policy b: x=1 then . in 5 <0 | 1>(b) \n If the value of x were .xed, this would yield a contradiction, but instead these policies indirectly \n.x the value of x and a: true . (1) b = T (line 3) . (2) x= 1 (line 4) . (3) x = 0 (line 1) . (4) a = \n. (line 1) Making underconstrained level variables T by default forces pro\u00adgrammers to explicitly introduce \npolicies setting level variables to .. For this reason, underspeci.cation will only cause level variables \nto be setto . instead of T.  3.4.3 Declarative Constraint Policies As we show in Table 6, level policies \nare translated to .J assert expressions. Level policies can be introduced on any logic variables in scope \nand are added to the environment based on possible path assumptions made up to that point. The policy \nthat a Jeeves expression (Exp) enforces consists of the constraint environment produced when evaluating \nExp as a .J expression. More speci.cally, we are talking about S' ,.' where Exp Yf(0/,0/ , e) .* . e \nand (S' ,.' ,.). This policy contains constraints determining whether level variables can be . or T. \n t1 <: t2 t' 1 <: t1 t2 <: t' 2 nrS-RECFUN S-FUN S-REFLEXIVE t <: t intc <: int S-INT boolc <: bool \nS-BOOL t1 . t2 <: t1 . t2 t1 . t2 <: t1 '. t' 2 rep t rep t' t' <: t rep t2 OK-SUBTYPE OK-BASETYPE OK-BASEFUNCTION \n rep t rep \u00df rep \u00df1 . t2 nr rep (t1 . t' ) rep t2 rep t1 . t2 rep t1 . t2 rep t1 '. t' nrnrOK-RECFUNCTIONBASE \n2 OK-RECFUNCTION OK-HOFUNCTION rep (t1 . t' ) . t2 rep (t1 . t2) . \u00df rep (t1 . t2) . (t' 1 . t' 2) G;. \nf e : (t, d) x . G rep t T-VAR T-INT T-BOOL T-CONTEXT G;. f x : G(x) G;. f n : intc G; . f b : boolc \nG;. f () : unit T-UNIT G; . f context t : t G;. f e1: t1 G;. f e2: t2 t1,t2 <: t rep tG;. f e : boolc \nG;. f et : t1 G; . f ef : t2 t1,t2 <: t rep t T-CONDC G;. f e1 (op) e2: t T-OP G; . f if e then et else \nef : t G;. f e : bool G;sym f et : \u00df1 G;sym f ef : \u00df2 \u00df1, \u00df2 <: \u00dfc rep \u00dfc T-CONDSYM G;. f if e then et \nelse ef : \u00dfc nr G, x : td ; . f e : t' rep t rep t' G; . f e1: t1 . t2 G;. f e2: t' t1 ' <: t1 rep t1 \nrep t2 1 T-LAMBDA T-APP G;. f (.x : td .e) : td . t' G;. f (e1 e2) : t2 nr G, f : t1 . t2; . f e1: t1 \n. t2 G, f : t1 . t2;. f e2: t2 rep t rep t2 T-LETREC nr G; . f let rec f : t1 . t2 = e1 in e2: t2 . \n= concrete G; . f e1: t1 . t2 G;. f e2: t' t1 ' <: t1 rep t1 rep t2 1 T-APPCURREC G; . f (e1 e2) : t2 \n G, x : \u00df; . f ec : bool G; . f . : \u00dfG;. f ec : bool T-DEFER G;. f (defer x : \u00df{ ec} default .) : \u00dfG; \n. f (assert ec) : unit T-ASSERT G;. f e1: \u00dfG;. fce1: \u00df' G;. f . : \u00df' T-CONCRETIZE  G; . f (concretize \ne1 with .) : \u00dfc Figure 5: Static semantics for .J describing simple type-checking and enforcing restrictions \non scope of nondeterminism and recursion. Recall that \u00df refers to base (non-function) types. Expl Y. \nel Exph Y. eh TR-SVALUE . Y. false T Y. true (Expl | Exph)(e) Y. if e then eh else el Exp Y. e TR-LEVEL \n level e in Exp Y. let e = defer e ' : bool default true in e Expp Y. ep Exp Y. e Lvl Y. b TR-POLICY \n policy e : Expp then Lvl in Exp Y. assert (ep . (e = b)) in e Expc Y. ec Exp Y. e TR-PRINT  print {Expc} \nExp Y. print (concretize e with ec) . Figure 6: Translation from Jeeves to .J  3.4.4 Contextual Enforcement \nat Output Channels Effectful computations such as print in Jeeves require contexts corresponding to the \nviewer to whom the result is displayed. As we show by the TR-PRINT rule, concretize is inserted in the \ntranslation. Because sensitive values can only produce concrete values consistent with the policies, \nthis ensures enforcement of policies at output channels. 4. Properties We describe more formally the \nguarantees that Jeeves provides. We prove progress and preservation properties for .J. We show that the \nonly way the value for the high component of a sensitive value to affect the output of the computation \nis if the policies permit it. 4.1 Progress and Preservation We .rst show the correctness of evaluation. \nWe can prove progress and preservation properties for .J: evaluation of an expression e always results \nin a value . and preserves the type of e, including the internal nondeterminism tag d. There are two \ninteresting parts to the proof: showing that all function applications can be reduced and showing that \nall defer and assert expressions can be evaluated to produce appropriate constraint expressions. We can \n.rst show that the .J type system guarantees that all functions are concrete. Lemma 1 (Concrete Functions). \nIf . is a value of type t1 . t2, then . = .x : t1.e, where e has type t2. Theorem 4.1 (Progress). Suppose \ne is a closed, well-typed ex\u00ad ' pression. Then e is either a value . or there is some e such that f(0/,0/ \n, e).(S' ,.' ,e '). Proof. The proof mostly involves induction on the typing deriva\u00adtions. One interesting \ncase is ensuring that MODEL will either re\u00adturn a valid model M or UNSAT for the E-CONCRETIZESAT and \nE-CONCRETIZEUNSAT rules. Since the .J type system rules out symbolic functions, only well-formed constraints \ncan be added. The other interesting case is function applications e = e1 e2, where e1 and e2 are well-typed \nwith types t1 . t2 and t1. We can rule out the cases when e1 and e2 are not values by applying the induction \nhypothesis. For the case when e1 and e2 are both values, we can apply the Concrete Functions Lemma to \ndeduce that e1 must have the form .x : t1: e, where e : t1. In this case, we can apply the E-APPABS rule. \nWe can also prove a preservation theorem that evaluation does not change the type of a .J expression. \nTheorem 4.2 (Preservation). If G f e : td and e . e ', then G f e ' : td. Proof. We can show the preservation \nof both t and d by induction on the typing derivation. The d value for all evaluation rules except for \nthe E-CONCRETIZE rules is the same for both sides.  4.2 Con.dentiality Theorem We show that level variables \nenforce the con.dentiality of values: once the policy sets a level variable e = ., where we have some \n(Expl |Exph)e, the output will be derived as if Exph was not involved in evaluation at all. Because we \nhave e = . if and only if we have policies that require e = ., Jeeves programmers can rely on policies \nto enforce con.dentiality. We .rst prove that the high-con.dentiality views of the sensitive values are \nprotected by level variables. We can show that for a sensitive value v = (Expl |Exph)e, the only way \nthe value for the high component Exph may affect the output of the computation is when e = T is consistent \nwith the policies. It is impossible ' for an observer to distinguish between v = (Expl |Exph) and v = \n(Expl |Exp' h) if the policy requires e = .. Theorem 4.3 (View Non-Interference). Consider a sensitive \nvalue V = (El |H)e in a Jeeves expression E. Assume: E[H . Eh] Y. e f(0/,0/,e). * (S,.,s)' E[H . Eh' \n] Y. e f(0/,0/,e '). * (S' ,.' ,s') For any context value v, if S .{context = v}f e = . S'.{context = \nv}f e = . then {c | f(S,., concretize s with v).(S0,.0,c)} = {c '| f(S' ,.' ,concretize s' with v).(S' \n0,.' 0,c ')} Proof. From the rules of Jeeves translation, V maps to an irreducible symbolic expression \nif e then eh else el in e where El Y. el and ' Eh Y. eh. Thus, we can say that e is e with the expression \neh '' replaced by eh where Eh ' Y. eh. In addition, we also know that both ' e and e are .J expressions \nwith no concretize sub-expressions. ' This makes evaluation of e and e deterministic and allows us to \nput their derivation trees in correspondence. There are two ' places where evaluation differs: (1) reduction \nof eh and eh (rule E-CONDSYMT) and (2) substitution of the reduced sensitive value (rule E-APPLAMBDA.) \nLet us understand how they affect the logical environment and the resulting symbolic value. The values \ns and s' may differ only in the subexpressions eh and ' eh reduce to. These subexpressions are guarded \nby the level variable e. Since the logical environments entail that e = . under context v, any model \nchosen at concretization sets e to .. Therefore, under such models s and s' evaluate to the same value. \nThen to show that the set of concrete values is the same, it suf.ces to show the models of (.,S) are \nmodels of (.' , S' ) and vice versa. The dynamic semantics populates S and S' with the same con\u00adstraints \n(modulo substitution of the sensitive variable) except during ' reduction of eh and eh. The constraints \nadded at rule E-CONDSYMT are all guarded by the level variable e. Since S and S' both entail \u00ace, and \nthese guarded constraints are implied by \u00ace, we can safely eliminate them from both S and S'. That leaves \nus with the same set of hard constraints introduced through defer and assert expressions. The default \njudgements in Jeeves all have the form e0 = true. Therefore, for the shared level variables . and .' \nuse the same default value true. The remaining level variables do not affect evaluation of s and s' . \nOur non-interference theorem allows programmers rely on poli\u00adcies to enforce con.dentiality. In Jeeves, \npolicies have the form f . (e = T) or f . (e = .). By the theorem, once the policy set\u00adting e to . is \nguaranteed to be added to the constraint environment, the output is going to be the same as if the high \nview component of the sensitive value was not involved in evaluation at all. If policies permit both \n. and T levels, then the default logic model .nder will guide evaluation to a model maximizing levels \nset to T. Note that if policies are contradictory and the set of constraints is unsatis.able, the evaluation \nhalts with an error and no value is exposed. The theorem still holds and this behavior is safe. 5. Scala \nEmbedding We have implemented Jeeves as an embedded domain-speci.c language in Scala programming language \n[20]. Scala s overloading capabilities offer us the necessary .exibility in designing a domain speci.c \nlanguage for .J with the bene.t of interoperability with existing Java technology.  In this section \nwe discuss our Scala embedding of .J and our implementation of the Jeeves library on top of that. We \ndescribe how we used features of Scala to implement .J s lazy evaluation of symbolic expressions, how \nwe collect constraints, and how we interact with the Z3 SMT solver. On top of the functional model we \nhave presented, we also handle objects and mutation.1 5.1 ScalaSMT: Scala Embedding of .J Every kind \nof symbolic expression in .J has a corresponding Scala case class, for instance IntExpr corresponding \nto symbolic integer expressions. Arithmetic and boolean operators are de.ned as methods constructing \nnew expressions. We use implicit type conversions to lift concrete Scala values to symbolic constants. \nScala s type inference resolves x+1 to x.+(Constant(1)) which in turn evaluates to Plus(x, Constant(1)), \nwhere x is a symbolic integer variable. Implicit type conversion allows us to use concrete expressions \nin place of symbolic ones but requires type annotations where a symbolic expression is expected to be \nused. The three core language extensions defer, assert, and concretize are implemented as library calls. \nWe implement the library as a Scala trait that maintains the logical and default constraint environments \nas lists of symbolic boolean expressions. Calls to concretize invoke an off-the-shelf SMT solver [17] \nfor the satis.ability query MODEL. We translate .J constraints to the QF_LIA logic of SMT-LIB2 [2] and \nuse incremental scripting to implement the default logic decision procedure. Concretization in ScalaSMT \ndiffers from .J in two ways. First, concretize accepts an arbitrary boolean expression rather than a \ncontext equality predicate. Second, concretize is not allowed to be a part of a symbolic expression in \nScalaSMT. Since concretiza\u00adtion generally happens as part of print routine, this restriction does not \naffect our case studies. In addition to boolean and linear integer constraints, the Scala embedding supports \nsymbolic expressions for objects corresponding to .J records with equality theory. Objects are modeled \nas a .nite algebraic data type in Z3 [17]. The set of available objects is maintained by ScalaSMT using \nregistration of instances of a special trait Atom. Object .elds are modeled as total functions interpreted \nat the time of concretization. Fields are (sort-)typed with values that are arbitrary ScalaSMT expressions \nand constants. ScalaSMT does not check types of symbolic object expressions: we rely on Scala s support \nfor dynamic invocaton to resolve .eld dereferences. We use special zero values ( null, 0, or false ) \nto represent unde.ned .elds in SMT. ScalaSMT does not support symbolic collections. Instead, we use implicit \ntype conversions to extend the standard Scala collection library with .lter and has methods that take \nsymbolic arguments. The argument to .lter is a function f from an element to a symbolic boolean. It maps \nevery element o to conditional expression IF (f(o)) o ELSE NULL. Method has takes a symbolic object o \nand produces a disjunction of equalities between elements of the collection and o.  5.2 Jeeves as a \nLibrary in Scala We have implemented Jeeves as a library on top of ScalaSMT. Our library has function \ncalls corresponding to Jeeves s sensitive values, level construct, policy construct, and contextual output \nfunctions (see Figure 7.) Levels are introduced using mkLevel method that returns a logical level variable \nwhich can be either T or .. Sensitive values are created with mkSensitive methods that take a level variable \ntogether with high and low values. Context is a logical object variable CONTEXT. To introduce a level \npolicy, the programmer 1 The code is publicly available at http://code.google.com/p/scalasmt/. trait \nJeevesLib extends ScalaSMT { trait JeevesRecord extends Atom {register( this )} val CONTEXT: Symbolic \n// Context variable. def mkLevel(): LevelVar def policy(lvar: LevelVar, f: . Formula, l: Level) def \nmkSensitiveInt(lvar: LevelVar, high: IntExpr, low: IntExpr): IntExpr def mkSensitive(lvar: LevelVar, \nhigh: Symbolic, low: Symbolic): Symbolic def concretize[T](ctx: Symbolic, e: Expr[T]): T } Figure 7: \nJeeves library in Scala calls policy method and supplies a level variable, the desired level, and a boolean \ncondition. The boolean condition is passed by name to delay its evaluation until concretization. This \nway policies that refer to mutable parts of the heap will produce correct constraints for the snapshot \nof the system at concretization. The Jeeves library supports mutation in variables and ob\u00adject .elds \nby treating the mutable state as part of the context in concretize call to ScalaSMT. Mutable .elds are \ninterpreted at the time of concretize. Policies that depend on mutable state are evaluated to boolean \nconditions during concretization. The set of allocated JeevesRecords is supplied at concretization. These \ncon\u00additions together with the equality predicate CONTEXT = ctx are used to concretize expressions in \nScalaSMT. 6. Experience We have implemented a conference management system and a social network. Our \nexperience suggests that Jeeves allows the programmer to separate the core, non-privacy-related functionality \nfrom the privacy policies, allowing the programmer to separately test policies and functionality. 6.1 \nConference Management System We have implemented a simple conference management system backend, JConf, \nto demonstrate how a well-known system with privacy concerns looks in Jeeves. This system is similar \nto the ex\u00adample we described in Section 2. Our implementation demonstrates that Jeeves allows us to implement \nall JConf functionality, including search and display over .nal paper versions, with a core functionality \nthat is separate from the policies. JConf supports the following subset of the functionality men\u00adtioned \non the website for the HotCRP conference management sys\u00adtem [12]: smart paper search (by ID, by reviewer, \netc.), paper tagging (for instance, Accepted and Reviewed by: . . . ) and search by tags, managing reviews \n(assigning, collecting responses, and display\u00ading), and managing .nal paper versions. JConf does not \nimplement functionality for which con.dentiality is less key: for instance, the process of bidding for \npapers. All JConf core functionality adheres to the privacy policies. JConf implements the following \ninformation .ow policies: Paper titles are visible to the authors of the paper, reviewers, and PC members \nduring all stages. Paper titles are visible to everyone during the public stage.  Author names are visible \nto the authors on the paper during all stages, to reviewers and PC members during and after the rebuttal \nstage, and to everyone during the public stage if the paper has been accepted.   File Total LOC Policy \nLOC ConfUser.scala PaperRecord.scala PaperReview.scala ConfContext.scala 11 103 21 6 0 37 6 0 JConfBackend.scala \n56 0 Total 195 42 Table 1. Breakdown of lines of code across the JConf source. class PaperReview(id: \nInt , reviewerV: ConfUser, var body: String, var score: Int) extends JeevesRecord{ val reviewer = { val \nlevel = mkLevel(); val vrole = CONTEXT.viewer.role; val isInternal = (vrole == ReviewerStatus) || (vrole \n== PCStatus) policy(level, isInternal, T); policy(level, !isInternal, .); mkSensitive[ConfUser](level, \nreviewerV, NULL) }} Figure 8: Reviewer identities are revealed only to PC members.  Reviews and scores \nare revealed to authors of the paper, review\u00aders, and PC members after the review phase. During the review \nphase, reviewers must have submitted a review for a paper p before they can see p s reviews.  Our JConf \nimplementation allows us to separate the declara\u00adtion of policies and code: we show the breakdown of \ncode and policies in Table 1. The policies are concentrated in the data classes PaperRecord.scala and \nPaperReview.scala, which describe the attributes and policies associated with maintaining data asso\u00adciate \nwith papers and paper reviews. The other .les, including JConfBackend.scala, do not contain policies. \nThis allows the core functionality to be concise: the implementation of our back-end functionality as \nspeci.ed is only 56 lines. The implementation of the core functionality of JConf is agnostic to the policies. \nThe JConf back end stores a list of PaperRecord objects and supports adding papers, updating components \nof papers, and searching over papers by ID, name, and tags. We show the function to search papers by \ntag below: def searchByTag(tag: PaperTag) =papers. .lter (_.getTags().has(tag)) This function produces \na list of symbolic PaperRecord objects which are equal to objects containing paper data if the paper \ntag tag is present and null otherwise. The core program can be concise because it does not have to be \nconcerned with policies. We implement policies speci.ed in terms of program variables such as a paper \ns list of tags and values from the output context. To provide an example of a data class de.nition, we \nshow the de.nition of the PaperReview class in Figure 8. A PaperReview object has the .elds reviewer, \nbody, and score. The PaperReview class de.nes a policy that the identity of the reviewer as stored in \nthe reviewer .eld is visible only to other reviewers and PC members. The code introduces a new level \nvariable level , adds a policy that the context viewer must be a reviewer or PC member to see the object. \nThe policies on allowed contexts for seeing the entire PaperReview object are de.ned in the PaperRecord \nclass representing data associated with papers. Localizing the policies with respect to data facilitates \npolicy updates. To change at what stage of the conference when reviewers are allowed to see names of \nauthors, we can simply change the few lines of code corresponding to the author list policy. The programmer \ndoes not have to make coordinated changes across the code base to update policies.  6.2 Social Network \nFor social networks it is important to rapidly develop code that implements information .ow policies. \nPrivacy issues have put the social network website Facebook under the scrutiny of the American Federal \nTrade Commission [26], making it crucial that they do not leak sensitive data. On the other side, one \nof Facebook s key values is to move fast: rapidly develop innovative features [28]. Separation of policies \nand core program functionality can help developers rapidly develop privacy-aware features. To investigate \nthis hypothesis, we have implemented Jeeves So\u00adcial Net, a toy social network that uses Jeeves policies \nto control con.dentiality of user-shared data. Jeeves Social Net core function\u00adality involves storing \nand allowing queries over user attributes such as names, e-mails, and networks, a friendship relation \nbetween users, and dynamically changing properties such as user location. Jeeves Social Net allows a \nuser u to de.ne policies about who can see which versions of these attributes based on the relationship \nof the viewer to the u. The system allows the user to de.ne different versions of their information to \nbe shown to viewers given which level they satisfy. These policies are stateful: for instance, a policy \non the visibility of user u s location refers to the location of u and the location of output viewer \nv. Jeeves allows the programmer to develop policies and core func\u00adtionality separately. In our source, \nall policies reside in UserRecord class representing a user, while the query code in SocialNetBackend \nis left intact. The programmer can extend the SocialNetBackend arbitrarily and rely on the Jeeves system \nto enforce information poli\u00adcies. The programmer can also easily change the policies enforced across \nthe program by changing the policy code in UserRecord. In the rest of this section, we walk through how \nwe implement interesting policies in Jeeves Social Net: support for user-de.ned policies that may depend \non the friendship relation, stateful location\u00addata policies, and policies that have mutual dependencies \nas a result of a symbolic context. De.ning Viewer Levels. Each sensitive .eld in a UserRecord object \nis de.ned in terms of the level of the output viewer. We use Jeeves level variables to de.ne three levels: \nAnyone is most permissive and allows public access, Friends allows access only to friends, and Self is \nmost restrictive and disallows access to everyone except the user herself. The following function creates \nlevel variables associated with user-de.ned viewer levels: def level(ul: UserLevel) ={ val a = mkLevel(); \nval me = CONTEXT == this; ul match { case Anyone . case Self . policy(l, ! me, .) case Friends . policy(l, \n! (me|| friends.has(CONTEXT)), .); }; a } The CONTEXT variable refers to the user at the other end of \nthe output channel. The mutable set of friends is encapsulated in a private .eld friends of UserRecord. \nWe use this function to create sensitive values for user .elds based on user-speci.ed viewer levels. \nThe constructor for the UserRecord class takes parameters nameL: UserLevel and friendL : UserLevel to \nspecify who can see the name and friends .elds. To create a sensitive property for the name of a user, \npassed to the constructor as nameV: string, we declare an observer .eld:  val name = mkSensitive(level(nameL), \nnameV, NULL) We can create a friends list that is visible based on the friends level friendsL as follows: \ndef getFriends() = { val l = level(friendsL); friends .map(mkSensitive(l, _)) } When these .elds are \naccessed, the results will only be displayed to viewers who have an appropriate level of access. Policies \nbecome implicitly combined when different sensitive values interact. To get names of friends of a user, \nwe simply call: user. getFriends().map(_.name) Although the code looks the same as if without Jeeves, \nthe context user here must simultaneously be able to access the list of friends and the name property \nto see the name of a friend. Location Policy. The location mash-up website PleaseRobMe [3] demonstrates \nthat if disclosure of geographic location information is not carefully managed, people can easily use \nthis information for harm, for instance in determining candidates for apartment robberies. Jeeves allows \nprogrammers to easily express policies protecting location data based on not just friend relationships, \nbut also on policies involving dynamically-changing user locations. A user may choose to share her location \nwith friends, with users nearby, or only to friends who are nearby. To write the policy that only a nearby \nuser can see the location, we create sensitive values for coordinates in the setter method guarded by \nDISTANCE policy: 1 var X: IntExpr = 1000 2 var Y: IntExpr = 1000 3 4 def setLocation(x: BigInt, y: BigInt) \n{ 5 val l = mkLevel(); 6 policy(l, DISTANCE(CONTEXT, this) = 10, .); 7 this.X=mkSensitiveInt(l, x, 1000); \n8 this.Y=mkSensitiveInt(l, y, 1000); 9 } 10 11 def DISTANCE(a: Symbolic, b: Symbolic) = 12 ABS(a.X - \nb.X) + ABS(a.Y - b.Y) The policy uses sensitive values for X and Y to guard the values themselves. We \ncan do this because whenever there are such circular dependencies, the Jeeves runtime will choose a safe \nbut locally\u00admaximal assignment to levels. For example, if all users in the net\u00adwork are nearby, it is \nsafe to return low values for everyone. How\u00adever, Jeeves would output the actual values, since that maximizes \nthe number of T levels without sacri.cing safety. Since policies and query code are separated, to change \nthe location policy, we only need to modify the setter. A stronger policy that permits only friends nearby \nto see the location requires one change to line 5 to replace mkLevel() with level (Friends). Symbolic \nContext. Jeeves also allows the context to contain sensitive values. As an example, consider the following \nfunction, which sends a user s name to her friends: def announceName(u: UserRecord) = for (f . u.getFriends()) \nyield email(f, u.name) The email function sends to f a concretizated version of u.name with CONTEXT \n= f. Since the friends list is symbolic, f is symbolic as well. This means that f will take high value \nonly if the corresponding friend of u is allowed to see the list of friends of u. The name of u is revealed \nonly if its policies permit f to see. Because Jeeves handles circular dependencies by .nding a safe but \nlocally-maximal assignment, the Jeeves runtime system will send the name to each friend if the friend \nis permitted to see the name. Such reasoning about symbolic contexts is hard to simulate in runtime systems \nsuch as Resin [27] that do not use symbolic constraints.  6.3 Jeeves Limitations Jeeves currently provides \nonly a limited amount of static checking. The implementation of Jeeves as a domain-speci.c embedded library \nin Scala relies on Scala type-checking to enforce static properties. At present, Jeeves does not provide \nstatic feedback about more complex program properties. For instance, neither the Jeeves design nor the \nimplementation provide support for statically determining whether policies are consistent or total. We \nanticipate being able to detect properties such as underspeci.cation and inconsistency using enhanced \nstatic analysis that we can implement as a Scala compiler extension. There are many open questions regarding \nthe usability of Jeeves. Symbolic evaluation and SMT are technologies that have been im\u00adproving in performance, \nbut it is not clear they can handle the de\u00admands of real-world applications. One direction for future \nexplo\u00adration includes scalability of Jeeves programs, how to ef.ciently handle data persistence, and \ndevelopment of lighter-weight execu\u00adtion models. Another direction for exploration involves the ease \nof programming and testability of Jeeves programs. 7. Related Work Jeeves privacy policies yield comparable \nexpressiveness to state\u00adof-the-art languages for verifying system security such as Jif [19], Fine [4], \nand Ur/Web [5]. These are static approaches that have no dynamic overhead. Rather than providing support \nfor verifying properties, the Jeeves execution model handles policy enforcement, guaranteeing that programs \nadhere to the desired properties by construction, but with dynamic overhead. The Jeeves runtime is similar \nto the system-level data .ow framework Resin [27], which allows the programmer to insert checking code \nto be executed at output channels. Jeeves s declarative policies allow the programmer to specify policies \nat a higher level and allow automatic handling of dependencies between policies. There are also parallels \nwith dynamic approaches to security. Devriese and Piessens s secure multi-execution approach executes \nmultiple copies of the program, providing defaults to copies that should not get access to secret inputs \n[7]. Jeeves s symbolic eval\u00aduation obviates the need to execute multiple program copies and Jeeves allows \nmore complex policies, for instance ones that may depend on sensitive values. In this space is also Kashyap \net al. s scheduling-based dynamic approach, which partitions a program into sub-programs for each security \nlevel for ensuring timing and termination non-interference. The focus of this is different from our work, \nwhich does not address timing or termination. Jeeves can also be compared to aspect-oriented programming \n(AOP) [11]. Existing frameworks for AOP provide hooks for explicit annotations at join points. Jeeves \ndiffers from AOP because Jeeves s constraint-based execution model supports more a more powerful interaction \nwith the core program. The most similar work in AOP is Smith s logical invariants [24] and method for \ngenerating aspect code for behavior such as error logging automatically [23]. Smith s method is static \nand involves reconstructing values such as the runtime call stack in order to insert the correct code \nat .xed control .ow points. Jeeves allows policies to affect control .ow decisions. The way Jeeves handles \nprivacy is inspired by angelic nondeter\u00adminism [8]. Jeeves most directly borrows from CFLP-L, a constraint \nfunctional programming calculus presented by M\u00fcck et al. [18]; similar functional logic models have also \nbeen implemented in lan\u00adguages such as Mercury [25], Escher [15], and Curry [9, 10]. Our system differs \nin the restrictions we place on nondeterminism and the execution model. .J leaves functions and the theory \nof lists out of the logical model. .J execution also supports default logic [1] to facilitate reasoning \nwhen programming with constraints.  Our work is also related to work in executing speci.cations and \ndynamic synthesis. Jeeves differs from existing work in executing speci.cations [16, 21] in our goal \nof propagating nondeterminism alongside the core program rather than executing isolated nondeter\u00administic \nsub-procedures. Program repair approaches such as Dem\u00adsky s data structure repair [6], the Plan B [22] \nsystem for dynamic contract checking, and Kuncak et al. s synthesis approach [13] also target local program \nexpressions. 8. Conclusions Our main contribution is a programming model that allows program\u00admers to \nseparate privacy concerns from core program functionality. We present the Jeeves programming language, \nformally de.ne the underlying constraint functional language .J, and prove that Jeeves executions satisfy \na non-interference property between low and high components of sensitive values. We describe our implementation \nas an embedded domain-speci.c language in Scala. We also describe our case studies, which illustrate \nhow the programmer can separately develop core functionality and privacy policies while relying on the \nsystem to produce outputs consistent with the policies. Acknowledgments We would like to thank Saman \nAmarasinghe, Arvind, Michael Carbin, Gregory Malecha, Sasa Misailovic, Andrew Myers, Joseph Near, Martin \nRinard, and Joe Zimmerman for their input and feed\u00adback. References [1] G. Antoniou. A tutorial on default \nlogics. ACM Computing Surveys (CSUR), 31(4):337 359, 1999. [2] C. Barrett, A. Stump, and C. Tinelli. \nThe smt-lib standard: Version 2.0. In SMT Workshop, 2010. [3] B. Borsboom, B. v. Amstel, and F. Groeneveld. \nPleaseRobMe. http: //pleaserobme.com, July 2011. [4] J. Chen, R. Chugh, and N. Swamy. Type-preserving \ncompilation of end-to-end veri.cation of security enforcement. SIGPLAN Not., 45 (6):412 423, 2010. ISSN \n0362-1340. doi: http://doi.acm.org/10.1145/ 1809028.1806643. [5] A. Chlipala. Static checking of dynamically-varying \nsecurity policies in database-backed applications. In Proceedings of the 9th USENIX conference on Operating \nsystems design and implementation, OSDI 10, pages 1 , Berkeley, CA, USA, 2010. USENIX Association. URL \nhttp://portal.acm.org/citation.cfm?id=1924943.1924951. [6] B. Demsky and M. Rinard. Data structure repair \nusing goal-directed reasoning. In ICSE 05: Proceedings of the 27th international confer\u00adence on Software \nengineering, pages 176 185, New York, NY, USA, 2005. ACM. ISBN 1-59593-963-2. doi: http://doi.acm.org/10.1145/ \n1062455.1062499. [7] D. Devriese and F. Piessens. Noninterference through secure multi\u00adexecution. Security \nand Privacy, IEEE Symposium on, 0:109 124, 2010. ISSN 1081-6011. doi: http://doi.ieeecomputersociety.org/10.1109/SP. \n2010.15. [8] R. W. Floyd. Nondeterministic algorithms. J. ACM, 14:636 644, Octo\u00adber 1967. ISSN 0004-5411. \ndoi: http://doi.acm.org/10.1145/321420. 321422. URL http://doi.acm.org/10.1145/321420.321422. [9] M. \nHanus. Improving control of logic programs by using functional logic languages. In Proc. of the 4th International \nSymposium on Programming Language Implementation and Logic Programming, pages 1 23. Springer LNCS 631, \n1992. [10] M. Hanus, H. Kuchen, J. J. Moreno-Navarro, R. Aachen, and I. Ii. Curry: A truly functional \nlogic language, 1995. [11] G. Kiczales, J. Lamping, A. Mendhekar, C. Maeda, C. V. Lopes, J.-M. Loingtier, \nand J. Irwin. Aspect-Oriented Programming. In ECOOP, pages 220 242, 1997. [12] E. Kohler. HotCRP. http://www.cs.ucla.edu/~kohler/hotcrp/. \n[13] V. Kuncak, M. Mayer, R. Piskac, and P. Suter. Complete functional synthesis. In PLDI, pages 316 \n329, 2010. [14] J. R. Lewis, J. Launchbury, E. Meijer, and M. B. Shields. Implicit pa\u00adrameters: dynamic \nscoping with static types. In Proceedings of the 27th ACM SIGPLAN-SIGACT symposium on Principles of programming \nlan\u00adguages, POPL 00, pages 108 118, New York, NY, USA, 2000. ACM. ISBN 1-58113-125-9. doi: http://doi.acm.org/10.1145/325694.325708. \nURL http://doi.acm.org/10.1145/325694.325708. [15] J. W. Lloyd. Programming in an integrated functional \nand logic language. Journal of Functional and Logic Programming, 3, 1999. [16] C. Morgan. The speci.cation \nstatement. ACM Trans. Program. Lang. Syst., 10(3):403 419, 1988. ISSN 0164-0925. doi: http: //doi.acm.org/10.1145/44501.44503. \n[17] L. D. Moura and N. Bj\u00f6rner. Z3: An ef.cient SMT solver. In In Conference on Tools and Algorithms \nfor the Construction and Analysis of Systems (TACAS), 2008. [18] A. M\u00fcck and T. Streicher. A tiny constraint \nfunctional logic language and its continuation semantics. In ESOP 94: Proceedings of the 5th European \nSymposium on Programming, pages 439 453, London, UK, 1994. Springer-Verlag. ISBN 3-540-57880-3. [19] \nA. C. Myers. JFlow: Practical mostly-static information .ow control. In In Proc. 26th ACM Symp. on Principles \nof Programming Languages (POPL), pages 228 241, 1999. [20] M. Odersky, P. Altherr, V. Cremet, B. Emir, \nS. Maneth, S. Micheloud, N. Mihaylov, M. Schinz, E. Stenman, and M. Zenger. An overview of the scala \nprogramming language. Technical report, Citeseer, 2004. [21] D. Rayside, A. Milicevic, K. Yessenov, G. \nDennis, and D. Jackson. Agile speci.cations. In OOPSLA Companion, pages 999 1006, 2009. [22] H. Samimi, \nE. D. Aung, and T. D. Millstein. Falling back on executable speci.cations. In ECOOP, pages 552 576, 2010. \n[23] D. R. Smith. A generative approach to aspect-oriented programming. In G. Karsai and E. Visser, editors, \nGPCE, volume 3286 of Lecture Notes in Computer Science, pages 39 54. Springer, 2004. ISBN 3-540\u00ad23580-9. \n[24] D. R. Smith. Aspects as invariants. In O. Danvy, H. Mairson, F. Hen\u00adglein, and A. Pettorossi, editors, \nAutomatic Program Development: A Tribute to Robert Paige, pages 270 286, 2008. [25] Z. Somogyi, F. J. \nHenderson, and T. C. Conway. Mercury, an ef.cient purely declarative logic programming language. In In \nProceedings of the Australian Computer Science Conference, pages 499 512, 1995. [26] J. E. Vascellaro. \nFacebook grapples with privacy issues. In The Wall Street Journal. May 19 2010. [27] A. Yip, X. Wang, \nN. Zeldovich, and M. F. Kaashoek. Improving application security with data .ow assertions. In Proceedings \nof the 22th ACM Symposium on Operating Systems Principles (SOSP 09), Big Sky, Montana, October 2009. \n[28] H. Zhao. Hiphop for PHP: Move fast. http://developers. facebook.com/blog/post/358/, February 2010. \n     \n\t\t\t", "proc_id": "2103656", "abstract": "<p>It is becoming increasingly important for applications to protect sensitive data. With current techniques, the programmer bears the burden of ensuring that the application's behavior adheres to policies about where sensitive values may flow. Unfortunately, privacy policies are difficult to manage because their global nature requires coordinated reasoning and enforcement. To address this problem, we describe a programming model that makes the system responsible for ensuring adherence to privacy policies. The programming model has two components: 1) core programs describing functionality independent of privacy concerns and 2) declarative, decentralized policies controlling how sensitive values are disclosed. Each sensitive value encapsulates multiple views; policies describe which views are allowed based on the output context. The system is responsible for automatically ensuring that outputs are consistent with the policies. We have implemented this programming model in a new functional constraint language named Jeeves. In Jeeves, sensitive values are introduced as symbolic variables and policies correspond to constraints that are resolved at output channels. We have implemented Jeeves as a Scala library using an SMT solver as a model finder. In this paper we describe the dynamic and static semantics of Jeeves and the properties about policy enforcement that the semantics guarantees. We also describe our experience implementing a conference management system and a social network.</p>", "authors": [{"name": "Jean Yang", "author_profile_id": "81464641126", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P2991346", "email_address": "jeanyang@csail.mit.edu", "orcid_id": ""}, {"name": "Kuat Yessenov", "author_profile_id": "81384615851", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P2991347", "email_address": "kuat@csail.mit.edu", "orcid_id": ""}, {"name": "Armando Solar-Lezama", "author_profile_id": "81100173160", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA, USA", "person_id": "P2991348", "email_address": "asolar@csail.mit.edu", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103669", "year": "2012", "article_id": "2103669", "conference": "POPL", "title": "A language for automatically enforcing privacy policies", "url": "http://dl.acm.org/citation.cfm?id=2103669"}