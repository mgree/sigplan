{"article_publication_date": "01-25-2012", "fulltext": "\n De.ning Code-injection Attacks Donald Ray Jay Ligatti Department of Computer Science and Engineering \nUniversity of South Florida {dray3,ligatti}@cse.usf.edu Abstract This paper shows that existing de.nitions \nof code-injection attacks (e.g., SQL-injection attacks) are .awed. The .aws make it possible for attackers \nto circumvent existing mechanisms, by supplying code-injecting inputs that are not recognized as such. \nThe .aws also make it possible for benign inputs to be treated as attacks. After describing these .aws \nin conventional de.nitions of code-injection attacks, this paper proposes a new de.nition, which is based \non whether the symbols input to an application get used as (normal\u00adform) values in the application s \noutput. Because values are already fully evaluated, they cannot be considered code when injected. This \nsimple new de.nition of code-injection attacks avoids the problems of existing de.nitions, improves our \nunderstanding of how and when such attacks occur, and enables us to evaluate the effectiveness of mechanisms \nfor mitigating such attacks. Categories and Subject Descriptors C.2.0 [Computer Communi\u00adcation Networks]: \nGeneral Security and protection; D.3.1 [Pro\u00adgramming Languages]: Formal De.nitions and Theory Syntax \nGeneral Terms Security, languages, algorithms 1. Introduction As the popularity of web applications has \nincreased, so have reports of attacks against them [20 22]. The most commonly reported type of attack \ninvolves injecting code into a program output by an application, as in SQL-injection attacks [22]. Standard \nexamples of code-injection attacks include an attacker entering the following strings as input to an \napplication: OR 1=1 --, to make the application output the program SELECT balance FROM acct WHERE password= \n OR 1=1 -- (underlined symbols are those the attacker has in\u00adjected into the output program). This SQL \nprogram always re\u00adturns the balance(s) from the acct table, even though an empty\u00adstring password is supplied, \nbecause: (1) the 1=1 subexpression is true, making the entire WHERE clause true, and (2) the -\u00adcommand \ncomments out the .nal apostrophe to make the pro\u00adgram syntactically valid. In this case, the attacker \nhas injected the code symbols OR, =, and --into the output program.  exit(), to make the application \noutput the program SELECT balance FROM acct WHERE pin=exit(). In this case, the attacker has injected \nthe code symbols exit() into the output  Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 12, January 25 27, 2012, Philadelphia, PA, USA. Copyright c &#38;#169; \n2012 ACM 978-1-4503-1083-3/12/01. . . $10.00 program to mount a denial-of-service attack against the \nremote database. These attacks are commonly referred to as code-injection at\u00adtacks or command-injection \nattacks (CIAs, or just IAs), but here we use the more speci.c term code-injection attacks on outputs \n(CIAOs) to distinguish these attacks, which require code to be in\u00adjected into an application s output, \nfrom more general notions of CIAs, which require code to be injected only into memory used by an application \n(e.g., [39]). Much research has focused on mechanisms for mitigating CIAOs, and a few efforts have been \nmade to de.ne CIAOs rig\u00adorously [3, 34, 37]. However, as Section 2 discusses, existing de.\u00adnitions are \nbased on the .awed belief that CIAOs occur whenever an application s input alters the syntactic structure \nof its output program. Incorrectly con.ating CIAOs with changes to syntactic structures causes existing \nde.nitions to be neither sound nor com\u00adplete: some CIAOs are not recognized as CIAOs (false negatives), \nand some non-CIAOs are recognized as CIAOs (false positives). The false negatives allow attackers to \ncircumvent existing mecha\u00adnisms for preventing CIAOs. Without a satisfactory de.nition of CIAOs, we can \nt effectively develop or analyze mechanisms for mitigating them; preventing CIAOs in general requires \nunderstanding exactly how and when they succeed. As Sun Tzu s The Art of War famously expresses it, If \nyou know yourself but not the enemy, for every victory gained you will also suffer a defeat [36]. This \nis a paper about knowing the enemy ; it de.nes precise circumstances under which CIAOs can be said to \noccur. De.ning CIAOs requires two subde.nitions: .rst we must de.ne which sym\u00adbols in applications output \nprograms constitute code; second we must de.ne when symbols have been injected into output programs. \nThe primary contribution and novelty of this paper lies in the .rst of these subde.nitions; the second \nsubde.nition can be approached with well-known (but dif.cult-to-implement) techniques of taint tracking. \nFor the .rst subde.nition, this paper de.nes code sig\u00adni.cantly differently from previous work instead \nof code being parse-tree-changing symbols, code here refers to symbols that do not form values (i.e., \nfully evaluated terms). This paper argues that CIAOs occur when at least one symbol injected into an \noutput pro\u00adgram is used outside of a value. To keep the de.nitions general, this paper tries to abstract \nas much as possible from underlying languages, programs, and sys\u00adtem architectures. Although the de.nitions \nwill require a few tech\u00adnical assumptions about the languages of applications output pro\u00adgrams (such \nas that they have a well-de.ned set of normal-form values), this paper s de.nitions are not limited to \nSQL or other pop\u00adular programming languages; the new de.nition of CIAOs applies equally well to other \ncode-injection attacks (e.g., LDAP-injection, HTML/script-injection (XSS), and shell-injection attacks). \nSimi\u00adlarly, the only assumption we make of applications is that tainted inputs can be correctly tracked \nthrough them, so we know which symbols in their outputs have been injected. 1.1 Summary of Contributions \nand Roadmap This paper demonstrates problems in the conventional de.nition of CIAOs (in Section 2). The \nproblems make existing CIAO\u00admitigating mechanisms neither sound nor complete some CIAOs are considered \nbenign, while some non-CIAOs are considered at\u00adtacks. After discussing previous work, the paper presents \n(in Sec\u00adtions 3 4) a new de.nition of CIAOs that avoids these problems. Ultimately, a de.nition of CIAOs \nhas two important high-level uses. First, a de.nition of CIAOs enables us to precisely determine whether \napplications exhibit CIAOs. We put the new de.nition to this .rst use by illustrating the new de.nition \ns improved ability to determine whether applications exhibit CIAOs (primarily in Sec\u00adtion 3.3). Second, \na de.nition of CIAOs enables us to analyze the effectiveness of mechanisms at mitigating CIAOs. We put \nthe new de.nition to this second use by analyzing the effectiveness of sev\u00aderal classes of mechanisms \nfor detecting CIAOs (in Section 5). More speci.cally, several properties of CIAOs become apparent by \nconsidering the new de.nitions: De.ning CIAOs as occurring when nonvalue symbols get in\u00adjected into \noutput programs improves our ability to recognize attacks. We illustrate the improvements in an idealized \nversion of SQL called SQL., SQL Diminished (Sections 3 4.1).  CIAOs can be classi.ed as copy-based or \ndata-dependency\u00adbased, depending on how applications propagate untrusted (tainted) inputs into output \nprograms (Section 4.2.1).  A class of attacks related to CIAOs exists, which we call code\u00adinterference \nattacks. The de.nition of these attacks takes into account control dependencies ignored by taint-tracking \nmecha\u00adnisms (Section 4.2.2).  Surprisingly, every application that always copies some un\u00adtrusted input \nverbatim into an (SQL.) output program is vul\u00adnerable to CIAOs (Section 5.1). This result implies that \nsound static mechanisms for detecting CIAOs must disallow all such applications, conservatively ruling \nout a large class of applica\u00adtions in practice. The proof of this result (in Section 5.1) is con\u00adstructive; \nthe proof de.nes inputs that will successfully attack any application that verbatim copies some untrusted \ninput into the output program. Although the proof is tailored to SQL., the proof techniques are general \nand applicable to other languages.  Similarly, applications that always copy some untrusted input verbatim \ninto an (SQL.) output program are vulnerable to code\u00adinterference attacks (Section 5.1).  Neither static \nnor black-box analysis of applications can pre\u00adcisely detect CIAOs. (Section 5.2)  Precisely detecting \nCIAOs requires white-box, runtime-monitor\u00ading mechanisms. Under reasonable assumptions, such mecha\u00adnisms \ncan detect CIAOs in output programs of size n in O(n) time and space. However, there are obstacles that \nmake it dif.\u00adcult to implement such mechanisms in practice. (Sections 5.3 5.4).  After presenting these \nresults in Sections 2 5, Section 6 con\u00adcludes. 2. Related Work Conventionally, CIAOs are considered to \noccur whenever an ap\u00adplication s input alters the intended syntactic structure of its out\u00adput program. \nBisht, Madhusudan, and Venkatakrishnan call this a well-agreed principle in other works on detecting \nSQL injec\u00adtion [3]. Indeed, this de.nition has appeared in many documents: [2 5, 9, 10, 13, 17, 27, 31, \n34, 37]. Although a few papers de.ne CIAOs in other ways (e.g., CIAOs occur exactly when keywords or \noperators get injected, including apostrophes used to form string values in SQL [8, 25], or when injected \nstrings span multiple to\u00adkens [38]), the conventional de.nition dominates the literature. However, the \nconventional de.nition of CIAOs has inherent problems: some CIAOs do not alter the syntactic structures \nof output programs, while some non-CIAOs do. To illustrate these problems, Sections 2.1 and 2.2 discuss \nthe conventional de.nitions of CIAOs used by SQLCHECK [34, 37] and CANDID [2, 3]. As far as we re aware, \nthese are the only existing formal de.nitions of CIAOs. 2.1 CIAOs in SqlCheck SQLCHECK considers the \nintended syntactic structure of an output program to be any parse tree in which each injected input is \nthe complete derivation of one terminal or nonterminal. For example, parsing the output program SELECT \nbalance FROM acct WHERE password= OR 1=1 -- produces a parse tree in which the injected symbols OR \n1=1 --are not the complete sequence of leaves for a single terminal or nonterminal ancestor; SQLCHECK \ntherefore recognizes this CIAO. However, some of what SQLCHECK considers intended (i.e., non-attack) \nstructures are actually attacks. For example, pars\u00ading the output program SELECT balance FROM acct WHERE \npin=exit() produces a tree in which the input symbols exit() are the complete sequence of leaves for \na single nonterminal (function-call1) ancestor. Hence, SQLCHECK does not recognize this CIAO as an attack. \nSimilarly, an output program of the form ...WHERE flag=1000>GLOBAL wouldn t be recognized as an at\u00adtack, \ndespite the injection of a greater-than operator (which may allow an attacker to ef.ciently extract the \nvalue of the GLOBAL variable, by performing a binary search over its range). Although SQLCHECK allows \npolicy engineers to specify a set of terminal and nonterminal ancestors that inputs may derive from so \nengi\u00adneers could disallow inputs derived as function-call and compari\u00adson expressions it s unclear how \nan engineer would know exactly which ancestors to allow derivations from. Moreover, engineers may wish \nto sometimes allow, and sometimes disallow, inputs to derive from particular terminals and nonterminals \n(as illustrated in Section 3.3), which is impossible in SQLCHECK. Conversely, some of what SQLCHECK considers \nunintended (i.e., attack) structures are actually not attacks. For example, an application might input \ntwo strings, a .le name f and a .le exten\u00adsion e, and concatenate them to generate the program SELECT \n* FROM properties WHERE filename= f.e . Although the user has injected no code, SQLCHECK .ags this output \nas a CIAO be\u00adcause the user s inputs are not complete sequences of leaves for a single terminal or nonterminal \nancestor. In this case, the immediate ancestor of the user s inputs would (assuming a typical grammar) \nbe a string literal, but neither of the user s inputs form a complete string literal they re missing \nthe dot and single-quote symbols. The CANDID papers describe other, lower-level problems with SQLCHECK \ns de.nitions [2, 3]. 2.2 CIAOs in Candid CANDID considers the intended syntactic structure of an output \nprogram, generated by running application A on input I, to be whatever syntactic structure is present \nin the output of A on input VR(I). Here VR is a (valid representation) function that converts any input \nI into an input I' known to (1) be valid (i.e., non-CIAO\u00adinducing) and (2) cause A to follow the same \ncontrol-.ow path as it would on input I. CANDID begins by assuming this VR function exists, while acknowledging \nthat it does not; in this basic case, 1 All major SQL implementations we are familiar with allow statements \nto call functions, including administrator-de.ned functions [19, 28, 29]. CANDID de.nes a CIAO to occur \nwhen A s output on input I has a different syntactic structure from A s output on input VR(I). Besides \nthe nonexistence of function VR, there are some prob\u00adlems with this de.nition of CIAOs. First, the de.nition \nis circular; CIAOs are de.ned in terms of VR, which itself is assumed to out\u00adput non-CIAO-inducing inputs \n(i.e., the de.nition of CIAOs relies on the de.nition of VR, which relies on the de.nition of CIAOs). \nSecond, the de.nition assumes that multiple valid syntactic struc\u00adtures cannot exist. For example, suppose \nVR( , )=aaa and appli\u00adcation A on input , outputs SELECT * FROM t WHERE name IN ( a , b ), while A on \ninput aaa executes in the same way to output SELECT * FROM t WHERE name IN ( aaaab ). Both of these outputs \nare valid SQL programs, yet the programs have different syntactic structures (a two-element list versus \na single\u00adelement list), and neither exhibits a CIAO (in no case has code been injected; only values, \nwhich take no steps dynamically, have been injected). CANDID would classify the non-CIAO input of , as \nan attack in this case. To deal with the nonexistence of function VR, CANDID attempts to approximate \nVR by de.ning VR(I) to be 1 when I is an integer and a|I| when I is a string (where a|I| is a sequence \nof a s hav\u00ading the same length as I). Supplying a concrete de.nition of VR resolves the circularity problem \nin CANDID s basic de.nition of CIAOs, but it doesn t resolve the second problem described in the previous \nparagraph (that multiple valid syntactic structures may ex\u00adist). Moreover, CANDID s approximation of \nVR creates new prob\u00adlems: The approximation incorrectly assumes a string of a s or a 1 could never be \nattack inputs. An application could inject an in\u00adput a or 1 into an output program as part of a function \ncall, .eld selection, or even keyword (e.g., and), all of which could be CIAOs. For example, suppose \nan application outputs a con\u00adstant string, echoes its input, and then outputs parentheses; on input exit \nit outputs the program ...pin=exit(). CANDID would not recognize this CIAO because the application outputs \n...pin=aaaa() on input aaaa, which has the same syntactic structure as the ...pin=exit() output. The \nproblem here is that aaaa is actually an attack input for this application.  The approximation may also \ncause benign inputs to be detected as attacks. For example, suppose an application outputs SELECT * \nFROM t WHERE flag=TRUE on input TRUE, and follows the same control-.ow path to output SELECT * FROM t \nWHERE flag=aaaa on input VR(TRUE)=aaaa. Because these two out\u00adput programs have different syntactic structures \n(a boolean lit\u00aderal versus a variable identi.er), CANDID would .ag the input TRUE as an attack, even \nthough the user has injected no code.  The approximation can also break applications, as discussed in \n[3]. To illustrate this problem, let s consider the application  if(input<2) then restart() else output(1/(input\u00ad1)). \nCANDID cannot in general operate on this application be\u00adcause it evaluates applications on both actual \n(I) and candidate (VR(I)) inputs, while following the control-.ow path required to evaluate the actual \ninput. In this case, whenever the appli\u00adcation s actual input is greater than one, CANDID will try to \nevaluate 1/(input-1) on the candidate input 1, which causes the application to halt with a divide-by-zero \nerror, despite there being no errors in CANDID s absence. It could be argued that the example applications \nin the bullets above would be uncommon in practice. But limiting the de.ni\u00adtion of CIAOs to common applications \nobligates us to de.ne what makes an application common, so we can test whether a given ap\u00adplication is \ncommon enough for the de.nition of CIAOs to apply. Even then, one couldn t say anything about CIAOs in \nuncommon applications. Related-work Summary CIAOs cannot be said to occur when an application s output \nprogram has an altered syntactic structure. CIAOs can occur without altering the syntactic structure \nof output programs (e.g., by injecting exit() or 1000>GLOBAL in SQLCHECK, or exit in CANDID).  Non-CIAOs \ncan occur while altering the syntactic structure of output programs (e.g., by injecting .le name f and \nextension e in SQLCHECK, or TRUE in CANDID).  3. Partitioning Program Symbols into Code and Noncode \nThis section begins building a new de.nition of CIAOs. Because CIAOs occur when code symbols get injected \ninto output programs, the question of which output-program symbols constitute code is key to de.ning \nCIAOs. This section addresses that question and de.nes how to separate code from noncode. (The discussion \nis limited to the context of CIAOs; in other contexts it makes sense to consider entire output programs \nas code .) 3.1 Overview of Partitioning Technique Let s begin by de.ning what is not code, rather than \nwhat is. This paper considers noncode to be the closed values in a programming language. Values are valid \nbut operationally irreducible terms (i.e., normal forms) [16, 32]. Values can be thought of as the fully \neval\u00aduated computations in a programming language, typically includ\u00ading standalone string and integer \nliterals, pointers, objects, lists and tuples of other values, etc. Values are closed when they contain \nno free variables; open values have free variables (e.g., a tuple value like (4,x) and standalone variables \nare open values). Closed values are fully evaluated, dynamically passive con\u00adstructs, which by themselves \ncause no dynamic computation to oc\u00adcur. On the other hand, because nonvalues and open values are not \npart of these passive terms, they are used to help specify dynami\u00adcally active computation and therefore \nconstitute code (in the case of open values, the dynamic activity speci.ed by a free variable is a substitution \noperation, which substitutes a term for the free variable at runtime). Injecting symbols that only form \nclosed values into an output program therefore cannot be considered a CIAO only irre\u00adducible, dynamically \npassive terms (i.e., noncode ) will have been introduced. CIAOs occur when untrusted inputs get used \noutside of closed values in output programs. 3.2 Formal Assumptions and De.nitions An application vulnerable \nto CIAOs outputs programs in some language L (e.g., SQL) having .nite concrete-syntax alphabet SL (e.g., \nthe set of printable ASCII characters). An output program, which we call an L-program, is a .nite sequence \nof SL symbols that form an element of L. De.nition 1. For all languages L with alphabet SL (i.e., L . \nS * L), an L-program is an element of L. Additional de.nitions will rely on the following assumptions \nand notational conventions: The length of program p is denoted as |p| (so when p = s1s2..sn, where each \ns is a program symbol in SL, we have |p| = n).  The ith symbol in program p is denoted as p[i].  Well-de.ned \nfunctions exist for computing free variables in all output-program languages under consideration. Function \n  FV L(p, l, h) takes an L-program p = s1s2..sn, a low symbol number l .{1..n}, and a high symbol number \nh .{l..n} and returns the set of variables that are free in the shortest term in p that contains all \nof the symbols sl..sh. Well-de.ned functions also exist for testing whether terms are values in all output-program \nlanguages under consideration. Predicate V alL(p, l, h) is true iff the shortest term that contains the \nlth to hth symbols in L-program p is a value. When the output language L is clear from context, we ll \nomit it as a subscript on FV L and V alL functions. We now formalize Section 3.1 s intuition of noncode \nprogram symbols. We use the predicate NCV to indicate whether symbols in an L-program form a noncode \nvalue. NCV is true for an L\u00adprogram p and low and high program-symbol numbers l and h iff the shortest \nterm containing the lth to hth symbols in p is a closed value. De.nition 2. For all languages L, predicate \nNCV (p, l, h) over L \u00d7{1..|p|}\u00d7{l..|p|} is true iff FV (p, l, h)= \u00d8 and V al(p, l, h). Code symbols are \nthose that cannot possibly be part of any noncode value. When p[i] is code (where p is an output program), \nwe write Code(p, i). De.nition 3. For all L-programs p = s1s2..sn and position num\u00adbers i .{1..|p|}, \nCode(p, i) is true iff for all low and high symbol\u00adposition numbers l .{1..i} and h .{i..|p|}, \u00acNCV (p, \nl, h). 3.3 Example Separation of Code from Noncode The remainder of this section illustrates De.nition \n3 in the con\u00adtext of SQL. (SQL Diminished), an idealized SQL-style language inspired by the MSDN SQL \nMinimum Grammar [18]. Figure 1 presents SQL. s syntax, which makes several assumptions: Full SQL. programs \nare valid statements.  Operators in SQL. have standard precedence and associativity.  A set of (administrator-de.ned \nand/or standard-library) param\u00adeterless functions exists, and SQL. expressions (i.e., exprs) can invoke \nthese functions with the ID() syntax (where ID is an identi.er, in this case a function name). Such function \ncalls are possible in typical SQL implementations [14, 19, 28, 29].  Similarly, a set of (administrator-de.ned \nand/or standard) vari\u00adables exists, and variable identi.ers are valid SQL. expressions.  Comments in \nSQL. begin with --and continue to the .rst newline.  String literals in SQL. have the same escape sequence \nas string literals in full SQL (i.e., a double apostrophe represents a single apostrophe). Also as in \nfull SQL, apostrophe directions are irrelevant in SQL., though we use directed apostrophes in this paper \nfor clarity.  Values in SQL. are the last six terms listed in Figure 1 for cate\u00adgory expr (i.e., from \nINT LITERAL to NULL). Intuitively, the values in a typed programming language are normally all the fully \nevalu\u00adated terms of each type in the language. SQL. has types for integers (INT), strings having a given \nsize (CHAR(INT LITERAL)), booleans (BOOL), and .oats having a given precision (FLOAT(INT LITERAL)), so \nits values are the fully evaluated terms of each of these types including integer literals, string literals, \nthe true and false key\u00adwords, and .oating-point literals. Finally, NULL is a fully evaluated term of \nany type, also a value. Given that values in SQL. are exactly the last six terms listed as exprs in Figure \n1, De.nitions 2 and 3 imply that Code(p, i) holds iff, after parsing program p, p[i] is not part of a \nnonterminal categorized as one of these six kinds of exprs. Noncode symbols statement ::= CREATE TABLE \nID ( id type list ) | DELETE FROM ID w option | DROP TABLE ID | INSERT INTO ID vals | SELECT s list FROM \nID w option id type list ::= ID type | id type list , ID type type ::= INT | CHAR ( INT LITERAL ) | \nBOOL | FLOAT ( INT LITERAL ) w option ::= e | WHERE expr expr ::= expr op expr | NOT expr | ( expr ) \n| expr IS NULL | ID | ID () | INT LITERAL | STR LITERAL | TRUE | FALSE | FLOAT LITERAL | NULL op ::= \nOR | AND | < | > | = | + |* vals ::= VALUES ( e list ) | SELECT s list FROM ID w option e list ::= expr \n| e list , expr s list ::= *| i list i list ::= ID | i list , ID Figure 1. Syntax of SQL. . are those \nin closed values; all others are code. This de.nition also works when partitioning whitespace and comment \nsymbols: no symbol involved in whitespace or comments can possibly be within a value (all values in SQL. \nare single tokens), so whitespace and comment symbols are code.2 A few observations about this de.nition \nof code in SQL.: Parsing is necessary to determine whether a symbol is code. For example, an integer \nliteral is code when used in a type speci.cation, but noncode when used as an expression.  Conventional \nde.nitions of CIAOs are incompatible with the de.nition of code in SQL.. For example, there exists no \nset of terminals and nonterminals in Figure 1 that exactly de\u00adrive noncode symbols (exprs may contain \ncode, and even INT LITERALs may be code depending on the context); hence, our de.nition of code is inexpressible \nwith SQLCHECK [34].  Code and noncode can t be partitioned by considering noncode to be literals. Some \nliterals are code (e.g., an integer in a type) and other are not (e.g., an integer expression). Although \nall non\u00adliterals (e.g., a CREATE keyword) are code in SQL., languages with more sophisticated values \n(e.g., lists) may have nonlit\u00aderal, noncode symbols (e.g., commas between elements of a list value). \n Code and noncode also can t be partitioned by considering code to be keywords and operators. Some keywords \nare code (e.g., CREATE) and others are not (e.g., TRUE). Some symbols that are neither keywords nor operators \nare code (e.g., function-name IDs) and others are not (e.g., literals).  Next, let s consider several \nexample output programs, beginning with the examples from Sections 2.1 and 2.2, to see how the new de.nitions \npartition injected symbols. 2 It may also be reasonable to partition lexer-removed symbols (typically \nwhitespace and comments) into code and noncode in other ways. For ex\u00adample, one might consider lexer-removed \nsymbols code iff their existence affects the sequence of tokens in the output program. 1 2 3 4 5 6 7 \n8 9 10 11 This paper Yes Yes Yes No Yes Yes No Yes Yes Yes No SQLCHECK [34] Yes No No Yes No No No No \nNo No No CANDID [3] Yes Yes Yes No No No Yes No No No Yes WASP [8] and Nguyen-Tuong et. al. [25] Yes \nYes Yes No No No No No No No Yes Xu et. al. [38] Yes Yes Yes No No No No No No No No Figure 2. A comparison \nof de.nitions for partitioning code and noncode. Column numbers refer to the example output programs \nenumerated in Section 3.3, row names indicate partitioning techniques, and cells specify whether any \nof the underlined symbols are considered code. 1. SELECT balance FROM acct WHERE password= OR 1=1 -- \nThe injected OR, =, and --(and spaces) are code, so a CIAO has occurred. 2. SELECT balance FROM acct \nWHERE pin= exit() All the injected symbols are code, so a CIAO has occurred. 3. ...WHERE flag=1000>GLOBAL \nThe injected > is code, so a CIAO has occurred. 4. SELECT * FROM properties WHERE filename= f.e No in\u00adjected \nsymbols are code, so a CIAO has not occurred. 5. ...pin=exit() All the injected symbols are code, so \na CIAO has occurred. 6. ...pin=aaaa() Again, all the injected symbols are code, so a CIAO has occurred. \n 7. SELECT * FROM t WHERE flag=TRUE No injected sym\u00adbols are code, so a CIAO has not occurred. 8. SELECT \n* FROM t WHERE flag=aaaa An open expres\u00adsion (which causes a substitution operation to be performed at \nruntime) was injected, so a CIAO has occurred. 9. SELECT * FROM t WHERE password=password Again, an \nopen expression (which causes a substitution operation to be performed at runtime) was injected, so a \nCIAO has occurred.  10. CREATE TABLE t (name CHAR(40)) All the injected sym\u00adbols are code, so a CIAO \nhas occurred. 11. SELECT * FROM t WHERE name= x No injected symbols are code, so a CIAO has not occurred. \n In all of these cases, the partitioning avoids the problems with con\u00ad ventional CIAO de.nitions described \nin Section 2 and matches our intuition about which program symbols are code (and consequently cause a \nCIAO if injected). Figure 2 compares this paper s partitioning of the example out\u00ad put programs enumerated \nabove with the partitionings used in pre\u00ad vious work. The only scenarios in which we believe previous \nde.\u00ad nitions would be favored over this paper s de.nitions are when the assumptions made by this paper \ns de.nitions cannot be satis.ed easily, that is, when it s dif.cult to de.ne the set of closed values \nin the output-program language. 4. De.nition of CIAOs De.ning CIAOs requires subde.nitions of code and \ninjection. At this point code has been de.ned; it is time to consider what it means for an attacker to \ninject symbols into an output program. Intuitively, injected symbols are the ones that propagate unmodi.ed \nfrom an untrusted input source to the output program. A CIAO occurs when at least one untrusted input \nsymbol propagates into, and gets used as code in, an output program. To know when input symbols have \npropagated, possibly through copy operations, to output programs, one could taint all untrusted inputs \nto applications and have those applications transparently propagate taints through copy operations (Section \n4.2 will consider propagating taints through other operations as well). Then output programs could be \ntested to determine whether any of their tainted symbols are used as code. Tracking taints to determine \nwhich output-program symbols derive from untrusted inputs is a well\u00adstudied technique (e.g., [6, 8, 25, \n31, 38]). 4.1 Formal Assumptions and De.nitions As in earlier sections, underlines will represent tainted \nsymbols (i.e., those injected from untrusted sources). As a technicality, if some element of S is already \nunderlined then all underlines in this paper may need to be replaced with some other annotation not present \non any S symbol. Then, for all languages L with alphabet S, let L denote the same language but with alphabet \nS, where S contains tainted and untainted versions of every symbol in S. Thus, the tainted output language \nL contains exactly those programs in L, except that programs in L can have symbols tainted in any way. \nThe following three de.nitions formalize these ideas. De.nition 4. For all alphabets S, the tainted-symbol \nalphabet S is: {s | s . S . (.s ' . S: s = s ' )}. De.nition 5. For all alphabets S and symbols s . S, \nthe predi\u00adcate tainted(s) is true iff s . S. De.nition 6. For all languages L with alphabet S, the tainted \noutput language L with alphabet S is: {s1..sn |.s ' ni . si=si' )} 1..s ' . L : .i .{1..n} :(si=s ' \nGiven a regular, non-taint-tracking application, which out\u00adputs L-programs, a taint-tracking application, \nwhich outputs L\u00adprograms, is constructed by ensuring all the following. 1. All symbols input to the application \nfrom untrusted sources are marked tainted. 2. Taints propagate through all operations that copy or output \nsymbols. 3. Besides inputting symbols from untrusted sources and copying and outputting already tainted \nsymbols, there are no other ways to introduce tainted symbols. 4. Taints are invisible to the application; \nthey have no effect on its execution.  The only assumption this paper makes of applications is that \nthey can be reasoned about as taint-tracking applications obeying these four rules. At last, CIAOs can \nbe de.ned as occurring whenever an injected (i.e., tainted) symbol in an application s output is used \nas code. De.nition 7. A CIAO occurs exactly when a taint-tracking appli\u00adcation outputs L-program p = \ns1..sn such that .i .{1..n} : (tainted(si) . Code(p, i)). 4.2 Discussion of the CIAO De.nition There \nare several points of discussion related to De.nition 7. Syntactic versus Semantic Analysis Contrary \nto previous work [3, 34], De.nition 7 does not limit CIAO detection to syn\u00adtactic analysis. Although \ntesting whether sequences of program symbols denote closed values typically requires only syntactic analysis \n(e.g., values are de.ned syntactically for SQL. in Sec\u00adtion 3.3), such testing could conceivably require \nstronger-than\u00adsyntactic analysis. For example, semantic analysis may be required to determine whether \nthe output programs date:=1/1/11 and balance:=1/1/11 exhibit CIAOs in output-program languages with slashes \nused in both date-literal and integer-division expres\u00adsions. Expected (Nonmalicious) CIAOs Although CIAOs \noften consti\u00adtute malicious use of an application, some application programmers expect CIAOs to occur \nand don t consider them malicious. For ex\u00adample: A translator between programming languages may input \nan expression like x+y and output a program containing the same expression or some code like r1:=r1+r2, \nwith the nonvalue + symbol having been injected. This is not a problem, and authors of programming-language \ntranslators would typically not consider CIAOs on their translators harmful.  Tools like phpMyAdmin \nprovide interfaces for remote users to enter MySQL programs and then have those programs output for other \nsystems to execute [30].  Applications may check inputs before injecting them as code in output programs, \nsuch as the application if(input= safeFunction ) then output(input+ () ) else raise badNameExn, or the \napplication if(input.matches ( Math.* )) then output(input+ () ) else raise badNameExn. Programmers of \nthese applications may not con\u00adsider CIAOs of checked inputs to be malicious (though it may nonetheless \nbe desirable to detect CIAOs in such programs, for example, to prevent the latter application from outputing \nMath.pi+exit()).  We believe that whether an act is malicious or an attack or against a programmer \ns expectations or intentions is subjec\u00adtive. The only artifact we can examine is the programmer s code, \nbut that code may not capture the programmer s intentions. De.\u00adnition 7 therefore does not depend on \nsubjective factors like pro\u00adgrammers intentions; CIAOs are de.ned as occurring whenever an application \ninjects untrusted input into the code of an output program, regardless of whether the application programmer \nwould consider the CIAOs malicious. To make an analogy to memory safety, there are mechanisms to prevent \nmemory-safety violations, e.g., type checkers. However, some memory-safety violations are not harmful \nand may be fully intended by programmers. For example, a programmer with knowl\u00adedge of how integers and \n.oats are encoded may .nd that writing an arbitrary .oat value to integer-type memory does exactly what \ns/he wants very ef.ciently. As another example, one of the dif.culties encountered by Safe C projects \nis that some memory-safety vio\u00adlations are actually intentional and clever optimizations [7, 11, 23]. \nDe.nitions of memory-safety violations don t (as far as we re aware) take into account programmer intentions; \nmechanisms for preventing memory-safety violations disregard programmer in\u00adtentions and prevent all memory-safety \nviolations, regardless of whether a programmer considers some particular violation mali\u00adcious. Analogously, \nDe.nition 7, unlike the conventional de.ni\u00adtions of CIAOs used by previous work, sidesteps the subjective \nquestions of whether output programs are intended or malicious. De.nition 7 just focuses on detecting \nwhether code has been in\u00adjected into output programs. Non-CIAO injection attacks Some injection attacks \non output programs are not code-injection attacks on output programs. For instance, consider the output \nprogram SELECT balance FROM acct WHERE password = TRUE. Here, a type error will occur (assuming that \npassword is not of boolean type), potentially caus\u00ading unexpected failures. Although this output program \ncontains symbols that may have been injected with malicious intent, those symbols are part of a closed \nvalue and are therefore not used as code. Because code has not been injected, the output program does \nnot exhibit a CIAO according to De.nition 7. Function values Functions are .rst-class values in many \nlan\u00adguages, and it may seem strange to allow arbitrary closed func\u00adtion values to be injected into output \nprograms. However, a func\u00adtion value is dynamically passive; a function value only activates when operated \nupon, by applying the function. Hence, injecting a function value does not constitute a CIAO, but injecting \na function application does (assuming the injected application is not within some other closed value, \nsuch as an outer lambda term). Alternate-encoding and second-order attacks De.nition 7 has no problem \nwith alternate-encoding attacks . Alternate encod\u00adings allow attackers to mask injected code, for example, \nby in\u00adputting exec(char(0x73687574646f776e)) instead of a direct SHUTDOWN command [8]. De.nition 7 detects \nsuch attacks because the injected function calls are recognized as code. De.nition 7 also detects second-order \ninjection attacks (where an attacker stores some code in a database that an application later retrieves \nand in\u00adjects into its output [1, 26]), as long as the database input to the application is considered \nuntrusted (or, as a more precise alterna\u00adtive, the database could store .ags indicating which of its \nentries symbols are tainted). De.ning injection Finally, De.nition 7 interprets injection as meaning \nthat symbols have been directly copied from input to output. For example, loading a tainted symbol from \nmemory into a register would taint that register s value, but adding two tainted integers involves no \ndirect copying and therefore produces an un\u00adtainted result. Thus, De.nition 7 does not consider CIAOs \nto occur when applications output programs whose code symbols are mas\u00adsaged versions of untrusted inputs \nthe massaging (i.e., noncopy manipulation) prevents the input symbols from being considered injected. \nIntuitively, an application like output(input()+1) may input a 1 from an untrusted user and then output \nthe program 2. In this case it seems inaccurate to say that the user injected the 2, given that the user \nnever entered a 2, and the application produced the 2 by actively transforming its input. If anything, \nthe application and user have collaborated to produce the 2 that got output. One could consider this \nexample demonstrative of a more general class of attacks: data-dependency-based CIAOs. 4.2.1 Data-dependency-based \nCIAOs Following this train of thought leads us to de.ne data-dependency\u00adbased CIAOs in exactly the same \nway as regular CIAOs (which henceforth will also be called copy-based CIAOs), except that for data-dependency-based \nCIAOs we broaden taint propagation to occur on all data operations, not just copies and outputs. That \nis, for any data dependency in which the value of a symbol s de\u00adpends on the value of at least one tainted \nsymbol, s must also be tainted. In the example above, we would taint the 2 produced by adding a tainted \n1 with an untainted 1. As a better example, con\u00adsider the application output(toUpper(input())+ () ), \nwhich outputs EXIT() after inputting exit. De.nition 7 does not con\u00adsider this exit input to be a copy-based \nCIAO because with copy-based tainting, the output is just EXIT(), with no symbols tainted/underlined. \nHowever, the exit input is a data-dependency\u00adbased CIAO because with data-dependency-based tainting, \nthe out\u00adput is EXIT(). Note that every copy-based CIAO is also a data\u00addependency-based CIAO. In many \ncases, such as the all-caps-function-name application above, it may be helpful to detect and prevent \ndata-dependency\u00adbased CIAOs. In other cases, data-dependency-based-CIAOs may be expected, so system administrators \nmay not .nd it helpful for them to be caught and .agged (similar to expected copy-based CIAOs, discussed \nabove). For example, an application for man\u00adaging online courses might hash an input student number to \nob\u00adtain a discussion-group number g and then output a program like SELECT numPosts FROM group g where \nthreadNum=4. As\u00adsuming g is obtained through noncopy operations on the untrusted student-number input, \nthis application exhibits a non-copy-based, data-dependency-based CIAO. But the application programmers \nand system administrators would likely not consider this data\u00addependency-based CIAO malicious. 4.2.2 \nCode-interference Attacks Broadening taint propagation further, one might consider taints to propagate \neven through control dependencies. To illustrate, let s consider the following application, which is \nsemantically equiva\u00adlent to the input-echoing application output(input()) and per\u00adforms what [3] calls \na conditional copy . while(there are more input symbols) { switch(next input symbol) { case a : output( \na ); break; case b : output( b ); break; ... } } This switch-based application is invulnerable to (copy-based \nand data-dependency-based) CIAOs because there are no data depen\u00addencies between input and output symbols \nevery symbol output is a constant hardcoded into the application source code. On the other hand, the \nsemantically equivalent input-echoing application is vulnerable to (copy-based and data-dependency-based) \nCIAOs because it directly copies input symbols into the output. These are reasonable consequences of \nonly dealing with code-injection at\u00adtacks; CIAOs only occur when code symbols in output programs directly \ndepend on untrusted input. Still, it may be desirable to prevent applications from behav\u00ading as the switch-based \napplication above does, and more gener\u00adally, to prevent untrusted inputs from interfering at all (even \nin\u00addirectly, through control dependencies) with the code symbols an application outputs. To do so, we \npropose studying CIntAOs code-interference attacks on outputs. The switch-based application above is \nvulnerable to CIntAOs because its input can interfere with the code symbols that get output. An application \nis vulnerable to CIntAOs whenever inputs dif\u00adfering in untrusted symbols can cause the application to \noutput programs differing in code symbols. In other words, applications invulnerable to CIntAOs must, \nwhen given the same trusted inputs, always output programs containing the same code symbols. De.nition \n8. A CIntAO occurs exactly when: 1. Application A, on trusted and untrusted input sequences T .S * and \nU.S * , outputs L-program p. 2. There exists another untrusted input sequence U ' .S * such that: (a) \nOn T and U ' , A outputs L-program p ' . (b) The subsequence of code symbols in p is not equal to the \nsubsequence of code symbols in p ' .   The switch-based application above is invulnerable to CIAOs \nbut vulnerable to CIntAOs. It also is possible for applications to be invulnerable to CIntAOs but vulnerable \nto CIAOs. For example, the application if input= 1+1 then output(input) else output( 1+1 ) exhibits a \nCIAO on input 1+1 but cannot ex\u00adhibit a CIntAO because there is no way to change the subsequence of code \nsymbols in the output program by changing the untrusted input. Although it may sometimes be desirable \nto detect CIntAOs, the strictness with which they re de.ned causes many reasonable appli\u00adcations, which \nare free of CIAOs, to exhibit CIntAOs. For example, an application could accept some untrusted input \nindicating which currency to output an account balance in; if the desired currency is not the default, \nthe application might output some code to multiply the fetched balance by a conversion rate. This application \nexhibits neither data-dependency-based nor copy-based CIAOs because the code symbols it outputs (e.g., \nthe multiplication symbol) are not data-dependent on the input currency. However, this application does \nexhibit CIntAOs because the input currency affects (through a control dependency) the code that gets \noutput (i.e., whether or not a multiplication gets included in the output program). Hence, this example \napplication illustrates that CIntAOs, like copy-and data-dependency-based CIAOs, may be expected and \nnot consid\u00adered malicious for some applications. 5. Implications of the De.nition of CIAOs Analyzing \nthe previous sections de.nitions provides insight into the pervasiveness of CIAO and CIntAO vulnerabilities, \nas well as various mechanisms effectiveness at mitigating CIAOs. 5.1 Pervasiveness of CIAO and CIntAO \nVulnerabilities We ve been surprised to .nd that any application that always blindly copies some untrusted \ninput verbatim into its SQL. output is vulnerable to a (copy-based) CIAO at runtime. Theorem 9 for\u00admalizes \nthis result; it states that if an application always includes an untrusted input (im) verbatim in its \noutput (without even inspecting that input), and the same application has some input (v1, .., vn) for \nwhich it outputs a valid SQL. program, then there exists a way to construct the untrusted input (am) \nsuch that the application s output will contain an injected code symbol. The proof is construc\u00adtive; \nit shows how to inject code into any such application using a detailed case analysis of the kind of value \nthe untrusted input (vm) gets injected into. Although the proof is tailored to SQL., the proof techniques \nare general. Theorem 9. For all n-ary functions A and (n-1)-ary A '' functions A ' and ,if .i1, .., \nin : A(i1, .., in)= A ' (i1, .., im-1,im+1, .., in)imA '' (i1, .., im-1,im+1, .., in), where 1 = m = \nn and .v1, .., vn :(vm . S+ . A(v1, .., vn) . SQL. SQL.), then .a1, .., an : A(a1, .., an) . SQL. and \nA(a1, .., an) exhibits a (copy-based) CIAO. Proof. By assumption, .v1, .., vn : A(v1, .., vn) . SQL.. \nFirst, if A(v1, .., vn) exhibits a CIAO, then simply set a1, .., an to v1, .., vn. On the other hand, \nif A(v1, .., vn) does not exhibit a CIAO, then, by the de.nition of CIAOs, vm must be a substring of \na value, because vm is not empty and appears verbatim in the output of A(v1, .., vn). Note that changing \nthe untrusted vm input to am, without changing any of the other n-1 inputs, will cause A to out\u00adput A \n' (v1, .., vm-1,vm+1, .., vn)amA '' (v1, .., vm-1,vm+1, .., vn), that is, the same output program but \nwith am instead of vm. We will show that no matter the type of the value that vm is a substring of, there \nexists an am that will cause A(v1, .., vm-1,am,vm+1, .., vn) to exhibit a (copy-based) CIAO but still \nremain valid. Case STR LITERAL: am = if (the .rst character of vm is not an apostrophe or is the .rst \napostrophe of a double\u00adapostrophe escape sequence) then + GLOBAL + vm else  + GLOBAL + vm  Examples: \nfname becomes f + GLOBAL + name . becomes + GLOBAL +  . fname becomes  + GLOBAL + fname . Let sm \ndenote the string literal that vm is a substring of. If vm does not start sm (which could happen if vm \nbegins with the .rst apostrophe of a double-apostrophe escape se\u00adquence), then the string literal must \nhave been started earlier, as A(v1, .., vn) . SQL.. In this case, our construction of am terminates the \nstring literal that has been started, inserts a code symbol (the concatenation operator), a global variable, \nanother code symbol, and then begins a second string literal. If vm ter\u00adminated sm, then this new string \nliteral will also be terminated by vm. If vm did not terminate sm, then it must have been terminated \nlater, again because A(v1, .., vn) . SQL.. Asa result, this second string literal will also be terminated \nlater. On the other hand, if vm did start sm (or is the second apostrophe of a double-apostrophe escape \nsequence), then our construction creates an empty string literal (or .nishes the escape sequence and \nterminates the literal) and concatenates a global variable and then concatenates another second string \nliteral started by vm. Again, we know that this second string literal will be ter\u00adminated, either by \nvm or the characters following it, for the same reasons as earlier. Thus, our construction of am causes \nsm, when am has been substituted for vm, to be parsed as ' ''''' s + GLOBAL + s , where s and s are both \nvalid string literals. Note that expr OP expr is a valid expr, and as long as GLOBAL is of type string, \ns ' + GLOBAL + s '' will be of the same type as sm. As any expr can by replaced by another expr of the \nsame type, the program will remain valid after the substitution of am for vm. As am contains a code symbol \n(i.e. 2 concatenation operators, as well as whitespace), a CIAO is exhibited. Case INT LITERAL, FLOAT \nLITERAL: am = vm1*exit()*2 Examples: -100 becomes -1 * exit() * 2100. 11E34 becomes 11E1 * exit() *234. \nThis construction works for similar reasons as the STRING LITERAL case above; In addition to the 2 multipli\u00adcation \ncode symbols, this construction also has a function call. Case TRUE, FALSE, NULL: Let IDm denote the \nkeyword that vm is a substring of; hence IDm can be written as IDm-vmIDm+ (where IDm- are in S * and \nIDm+ SQL. ). If IDm has a boolean type, then let OP be OR and let SUB be 1000 > GLOBAL. Otherwise, let \nOP be +, and let SUB be exit() if IDm has an integer or .oat type, or GLOBAL oth\u00aderwise. Then let am \n= vmIDm+ OP SUBOP IDm-vm. Examples: FALSE becomes FALSE OR 1000> GLOBAL OR FALSE. NULL + 3 becomes NULL \n+ exit() + NULL + 3. By assumption, vm is a substring of a keyword IDm. We as\u00adsumed earlier that A(v1, \n.., vn) . SQL., so IDm must be a valid keyword. We also know that in A(v1, .., vn), vm is preceded by \nIDm- and followed by IDm+. We construct am such that it .nishes the identi.er or keyword started by the \nexisting IDm-, inserts a code symbol depending on the type of IDm, conducts an attack, then inserts another \ncode symbol, and begins a new identi.er or keyword to be .n\u00adished by the existing IDm+. As a result, \nwhere originally the program used IDm as an expr, the modi.ed program uses IDm OP SUBOP IDm. Furthermore, \nthe type of the expr remains unchanged, as if IDm has a boolean type, then OP will be OR, and a boolean \nOR d with a boolean is a boolean. If IDm has a .oat or integer type, then OP will be the arithmetic operator \n+, which will return either a .oat or an integer type. If IDm has a string type, then the + operator \ndenotes concatena\u00ad tion, and two stings concatenated with each other form a string. Note that the only \nkeyword that is a value and can have a type of int, .oat, or string is NULL, as it can assume any type. \nNote that a CIAO has already occurred when NULL is used in expr IS NULL, because NULL is only a value \nwhen parsed as an entire expr. Furthermore, any application that verbatim copies untrusted in\u00adput into \nthe (SQL.) output program is either vulnerable to CIntAOs or can be made to output an invalid program. \nAgain, the proof is constructive; it shows how to create an untrusted input that changes the sequence \nof code symbols in, or invalidates, the output program. Theorem 10. For all n-ary functions A and (n-1)-ary \nA '' functions A ' and ,if .i1, .., in : A(i1, .., in)= A ' (i1, .., im-1,im+1, .., in)imA '' (i1, .., \nim-1,im+1, .., in), where 1 = m = n and .v1, .., vn :(vm . S+ . A(v1, .., vn) . SQL. SQL.), then A either \nexhibits a CIntAO or can be made to pro\u00adduce an invalid SQL. program. Proof. Observe that every symbol \nin an SQL. program is either part of a value or not. If vm contains a symbol recognized as part of a \nvalue, then the input can be modi.ed in the manner described in the proof of Theorem 9, and the sequence \nof code symbols will be modi.ed; by de.nition, A exhibits a CIntAO. On the other hand, if vm contains \na code symbol, then a different symbol can be provided. If the SQL. program is still valid, then a CIntAO \nhas occurred, as the sequence of code symbols has changed. If changing the code symbol made the program \ninvalid then the second condition of the implication is satis.ed. Given that (program-outputting) applications \ncommonly copy some untrusted input verbatim into the output, Theorems 9 10 show that vulnerabilities \nto CIAOs and CIntAOs are pervasive. 5.2 Limitations of Static and Black-box Mechanisms to Detect CIAOs \nDetermining whether an application is vulnerable to CIAOs re\u00adquires knowing which input symbols propagate \nto the output pro\u00adgram. This makes it undecidable to precisely detect (both copy\u00adbased and data-dependency-based) \nCIAOs using static code analy\u00adsis or black-box analysis. Theorem 11. There exists an application A, which \ninputs a string of symbols over alphabet S and outputs L-programs, such that it is undecidable, when \ngiven only an input string s . S * and a (e.g., Turing-machine) encoding of A, to determine whether A \nexhibits a (copy-based or data-dependency-based) CIAO on s. Proof. Let A be an application that inputs \na string s, executes subprogram p, and then outputs s if s equals 1+1 but otherwise outputs just 1 . \nThis A outputs programs in any language having integers and addition. Also, A exhibits a (copy-based \nand data\u00addependency-based) CIAO iff its subprogram p halts and its input s is 1+1 . Statically determining \nwhether A exhibits a CIAO on input 1+1 therefore reduces to the halting problem. Theorem 12. There exists \nan application A, which inputs a string of symbols over alphabet S and outputs L-programs, such that \nit is impossible, when given only an input string s . S * and the  Figure 3. Overview of a CIAO-Preventing \nMechanism. Trusted components are shaded. ability (i.e., an oracle) to predict the output of A on any \ninput, to determine whether A exhibits a (copy-based or data-dependency\u00adbased) CIAO on s. In other words, \nthere exist observationally equivalent applications A and A ' and a string s such that A(s) exhibits \na CIAO but A ' (s) does not exhibit a CIAO. Proof. Let A be the input-echoing application output(input) \nand A ' the conditional-copy application from Section 4.2.2. Recall from Section 4.2.2 that A and A ' \nare observationally equivalent, A is vulnerable to CIAOs (e.g., on an input like 1+1), and A ' is invulnerable \nto CIAOs. Theorems 11 12 are interesting because they rule out certain classes of mechanisms from being \nable to precisely detect CIAOs. Some of the mechanisms ruled out were previously thought to precisely \ndetect CIAOs; an example is SQLCHECK s black-box, bracket -based tainting mechanism (in which untrusted \ninputs get surrounded by special characters, and output symbols are consid\u00adered tainted iff they re surrounded \nby those characters) [34]. Al\u00adthough previous work showed that SQLCHECK s tainting mecha\u00adnism is .awed \n[3], Theorems 11 12 are more general, in that they rule out entire classes of mechanisms from being able \nto precisely detect CIAOs. Of course, Theorems 11 12 don t rule out static analysis and black-box mechanisms \nas being useful for mitigating CIAOs. Al\u00adthough such mechanisms can t detect CIAOs precisely, they can \ndetect CIAOs conservatively (i.e., soundly but not completely) with no/low runtime overhead, while avoiding \nthe many practical obsta\u00adcles to monitoring taints dynamically (some of which are described in Section \n5.4). However, sound static mechanisms for detecting CIAOs must be so conservative as to reject a large \nclass of common applications, which may limit their appeal. Recall that Theorem 9 showed that all applications \nthat copy some untrusted input verbatim into an output program can be made to exhibit a CIAO at runtime. \nHence, sound static mechanisms for detecting CIAOs must reject all of this large class of common applications. \n(Similarly, Theorem 10 implies that sound CIntAO-detecting static mechanisms must reject all such ap\u00adplications \nas well.) Related work on static-analysis techniques for detecting CIAOs [12, 35, 40] appear to be consistent \nwith this re\u00adsult; none seem to allow applications to copy untrusted input ver\u00adbatim into output programs. \nHaving a formal de.nition of CIAOs makes it possible to prove that this characteristic is mandatory for \nall sound, static, CIAO-detecting mechanisms. 5.3 Design of Mechanisms for Precisely Detecting and Preventing \nCIAOs Theorems 11 12 prove that precisely detecting CIAOs requires a dynamic white-box mechanism. A high-level \ndesign of such a mechanism follows straightforwardly from the de.nitions in Sec\u00adtions 3 4. A dynamic \nwhite-box mechanism can precisely detect and pre\u00advent CIAOs by: tainting all symbols input to an application \nA from untrusted sources,  transparently tracking one taint bit per symbol,  propagating taints through \nexactly A s copy and output opera\u00adtions (for copy-based CIAOs) or all data operations (for data\u00addependency-based \nCIAOs),  intercepting A s output programs, and  forbidding execution of output programs that contain \nat least one tainted symbol used outside a value (i.e., as code).  Figure 3 illustrates such a mechanism. \nTheorem 13. Assuming a mechanism M performs these opera\u00adtions on an application that outputs programs \nin a language with decidable free-variable (FV ) and value (V al) functions, it is de\u00adcidable for M to \nprecisely detect and prevent CIAOs. Proof. Immediate by De.nition 7 and the de.nitions of data\u00addependency \nCIAOs and mechanism M given above. Algorithm 1 directly implements this generic design of dynamic white-box \nmechanisms for preventing CIAOs. The algorithm relies on auxiliary functions for (1) adding taint tracking \nto applications, (2) signaling that untrusted inputs are tainted, (3) calculating the set of free variables \nin a sequence of program symbols, and (4) decid\u00ading whether program symbols constitute a value. Each \nof the three nested for loops in Algorithm 1 executes O(n) times, where n denotes the size of the output \nprogram. Hence, if we ignore the complexities of the FV and V al functions (which are dependent on the \noutput-program language), the top-level for loop of Algorithm 1 runs in O(n 3) time. Assuming that the \nFV and V al functions run in time linear in their input size, then, the top-level for loop of Algorithm \n1 runs in O(n 4) time. The space required by the top-level for loop of Algorithm 1 consists of the i, \nlow, and high counters (each of size O(lg n)), the IsCiao .ag (of size O(1)), and whatever space is required \nto invoke and execute the FV and V al functions. Assuming that invoking and executing the FV and V al \nfunctions uses space linear in their input size, then, the top-level for loop of Algorithm 1 uses O(n) \nspace. Optimized CIAO-Preventing Mechanism Algorithm 1 can be optimized to run in O(n) time and space, \nunder the assumption that the output-program language has an LR(k) grammar in which every closed value \nmatches some syntactic category (e.g., in SQL. every Algorithm 1: Basic CIAO-Preventing Mechanism Input: \nApplication A and inputs T , U (trusted, untrusted) Ensure: A s output is executed iff it doesn t exhibit \na CIAO A ' . AddTaintTracking(A) Output . A ' (T , Taint(U)) for i . 1 to |Output| do if tainted(Output[i]) \nthen IsCiao . true for low . 1 to i do for high . i to |Output| do if FV(Output, low, high) = \u00d8 and \nVal(Output, low, high) then IsCiao . false end if end for end for if IsCiao then throw CiaoException \nend if end if end for Execute(Output) closed value matches the expr category). When output-program \nlanguages satisfy this assumption, Algorithm 1 s top-level for loop can be replaced with a shift-reduce \nparse of the application s output program. When reducing a closed-value right-side R of a produc\u00adtion \nto a nonterminal N, the parser sets an isVal attribute for N and erases taints on all output-program \nsymbols represented by R (except for any symbols represented by nonterminals in R for which isVal has \nbeen set such symbols have already had their taints erased). After running this taint-erasing parser, \nall output\u00adprogram taints in closed values will have been erased, so a CIAO is detected if and only if \nsome tainted symbol remains in the output program. Algorithm 2 presents pseudocode for this optimized \nCIAO\u00adpreventing mechanism. The algorithm relies on auxiliary functions for (1) adding taint tracking \nto applications, (2) signaling that untrusted inputs are tainted, (3) tokenizing output programs, and \n(4) shift-reduce parsing output programs. Theorem 14. The let-in block of Algorithm 2 runs in O(n) time \nand space. Proof. The tokenization portion of Algorithm 2 runs in O(n) time and space (where again n \nis the size of the application s output pro\u00adgram). A standard shift-reduce parse of the output program, \nwithout the additional actions performed on reductions, runs in O(n) time and space; the total number \nof right-hand-side-production sym\u00adbols reduced to nonterminals during the parse is O(n) [15]. Be\u00adcause \nthe total number of right-hand-side-production symbols re\u00adduced to nonterminals during the parse is O(n), \nall the non-taint\u00adclearing reduction actions in Algorithm 2 (i.e., N.isVal.true, N.begin . s1.begin, \netc.) occur in O(n) total time and space. The for loop in Algorithm 2 s in block also runs in O(n) time \nand space, so Algorithm 2 s entire in block uses linear time and space, in ad\u00addition to the time and \nspace used to clear taints. To determine the total time and space used by taint-clearing operations, \nobserve that clearTaints is always initially invoked, in Algorithm 2 s in block, on symbols matching \na nonterminal N such that N.isVal=true. During execution, clearTaints may call itself recursively only \non parse-tree-descendent nonterminals with false isVal attributes. Because parsing is bottom-up, then, \npointers to Algorithm 2: Optimized CIAO-Preventing Mechanism (for appli\u00adcations whose output-program \nlanguage has an LR(k) grammar in which every closed value matches some syntactic category) Input: Application \nA and inputs T , U (trusted, untrusted) Ensure: A s output is executed iff it doesn t exhibit a CIAO \nA ' . AddTaintTracking(A) Output . A ' (T , Taint(U)) let function clearTaints (p1,...,pn)= for i . \n1 to n do Current . dereference(pi) if Current is a terminal then for j . Current.begin to Current.end \ndo Output[j].Tainted = false end for else if Current.isVal=false then clearTaints(Current.children) end \nif if i<n then // clear tainted whitespace, if any Next . dereference(pi+1) for j . Current.end to Next.begin \ndo Output[j].Tainted = false end for end if end for end function end let in tokens . run tokenize (Output) \non recognition of token t do t.begin . position of .rst symbol of t in Output t.end . position of last \nsymbol of t in Output end on end run run shift-reduce-parse (tokens) on reducing by production N ::= \ns1 s2 ... sn, where s1..sn is a closed value do N.isVal . true clearTaints(list of pointers to s1,...,sn) \nN.begin . s1.begin N.end . sn.end end on on reducing by production N ::= s1 s2 ... sn, where s1..sn is \nnot a closed value do N.isVal . false N.children . list of pointers to s1..sn N.begin . s1.begin N.end \n. sn.end end on end run for i . 1 to |Output| do if tainted(Output[i]) then throw CiaoException end \nif end for end in Execute(Output) the same syntax-tree symbol may never be passed as arguments to clearTaints \nmore than once, and every output-program taint may be cleared at most once (technically this result also \nrelies on the facts that isVal attributes are constant once set, taints can only be cleared by clearTaints, \nand clearTaints, when called on pointers to symbols s1..sn, can only clear taints at output-program positions \ns1.begin to sn.end). Also observe that, ignoring recursive clearTaints calls, each run of clearTaints \nexecutes in time proportional to the number of pointers to nonterminals passed as arguments plus the \nnumber of taints cleared. Then because (1) pointers to the same syntax\u00adtree symbol may never be passed \nas arguments to clearTaints more than once, (2) the total number of nonterminals in the parse tree is \nO(n) [15], (3) every output-program taint may be cleared at most once, and (4) each run of clearTaints \nexecutes in time proportional to the number of pointers to nonterminals passed as arguments plus the \nnumber of taints cleared, we have that the total time (and therefore space) used by all clearTaints operations \nis O(n). Hence, Algorithm 2 s entire let-in block uses O(n) time and space, as required. 5.4 Obstacles \nto Monitoring Taints in Practice Many taint-monitoring mechanisms and frameworks exist for mit\u00adigating \nCIAOs (e.g., [6, 8, 25, 31, 38]). None separate code from noncode the way this paper has, but one framework, \nDytan [6], which has not yet been publicly released, implements (for x86 ap\u00adplications) the taint-tracking \nfunctionality our de.nitions require. Hence, it appears possible to use Dytan to precisely detect (copy\u00adbased \nand data-dependency-based) CIAOs in x86 applications (by ensuring that all operations in Section 5.3 \ns bulleted list are per\u00adformed). Even with powerful taint-monitoring frameworks like Dytan, there are \nseveral obstacles to ensuring that taint-monitoring mech\u00adanisms obey the four tainting constraints listed \nin Section 4.1. This subsection brie.y summarizes these obstacles, most of which are discussed in greater \nlength elsewhere (e.g., [6, 8, 24, 31, 33]). The .rst of the four tainting constraints in Section 4.1 \nrequires all symbols input to the application from untrusted sources to be tainted. Untrusted inputs \nmay come from many sources (e.g., HTTP GET and POST requests, cookies, server variables, or a database), \nand enumerating all these untrusted sources may be dif.cult and error prone. Hence, following Halfond, \nOrso, and Manolios, one might instead use positive tainting [8] (i.e., tracking which output\u00adprogram \nsymbols derive from trusted sources, often just the string literals hardcoded in an application). It \nwould be straightforward to adjust this paper s de.nition of CIAOs to use positive (rather than negative) \ntainting: CIAOs would occur when some code symbol in an output program is not positively tainted. The \nsecond and third of the four tainting constraints require that taints propagate through exactly copy \nand output operations (for copy-based CIAOs), or all data operations (for data-dependency\u00adbased CIAOs). \nBecause a taint bit must be tracked for every input symbol, the tainting mechanism must operate with \n.ne granularity, which previous work has found to induce high runtime overhead (e.g., many thousands \nof percent of overhead) [6, 24, 38]. In addi\u00adtion, monitoring taints typically requires executing applications \nin modi.ed runtime environments, which limits portability [9]. And propagating taints through output \noperations, so output programs can be caught and checked prior to being executed, may be dif.\u00adcult; it \nmay be hard to enumerate all the ways an application can output programs (e.g., to .les, remote hosts, \nor standard output). If an application s outputs can circumvent a CIAO-mitigating mecha\u00adnism, the mechanism \nis unsound. Applications might also circum\u00advent taint-monitoring mechanisms by executing external (e.g., \nna\u00adtive) code [8]. The last of the four tainting constraints requires taints to be transparent. This \ntransparency ensures that taint tracking does not affect application behaviors; CIAO-preventing mechanisms \nshould only modify application behaviors when attacks are detected (in which case the behavior must be \nmodi.ed to prevent injected code from being output). To be transparent, tainting mechanisms have to isolate \ntaints from applications. Hence, CIAO-mitigating mecha\u00adnisms cannot use bracketing techniques to track \ntaints (e.g., [34]) the brackets are visible to applications [3]. Another important ob\u00adstacle to ensuring \ntransparency in practice is that runtime mecha\u00adnisms generally induce overhead on application performance, \nand this overhead may make time-sensitive applications behave differ\u00adently. Perfect transparency may \ntherefore be dif.cult or impossible to achieve for time-sensitive applications in practice. 6. Summary \nThis paper has de.ned code-injection attacks on outputs. The de.\u00adnition simply considers CIAOs to occur \nwhen untrusted inputs get used as nonvalues (or open values) in output programs. This de.\u00adnition avoids \nproblems with conventional CIAO de.nitions, which sometimes consider CIAOs to be non-CIAOs and vice versa. \nThe new de.nition of CIAOs has been used to: Distinguish between copy-based CIAOs, data-dependency\u00adbased \nCIAOs, and CIntAOs based on whether taints propagate through copy, data, or all (data and control) dependencies. \n Prove that a large class of applications (i.e., those that always blindly copy some untrusted input \nto the output program) are inherently vulnerable to CIAOs and CIntAOs, so sound static mechanisms must \ndisallow these applications from executing.  Prove that precisely detecting CIAOs requires dynamic white\u00adbox \nmechanisms. The generic design of such mechanisms fol\u00adlows immediately from the de.nition of CIAOs. Under \nreason\u00adable assumptions these mechanisms can be optimized to detect CIAOs in output programs in O(n) \ntime and space. Nonethe\u00adless, due to their reliance on taint tracking, many obstacles im\u00adpede implementation \nof precise CIAO-mitigating mechanisms in practice.  Hence, the new de.nition of CIAOs has been used \nto analyze precisely when they occur, how they can be mitigated, and how ef.ciently they can be mitigated. \nWe hope these results can serve as a foundation for improving the effectiveness of future CIAO\u00admitigating \nmechanisms. Acknowledgments We are grateful to the anonymous reviewers of this paper, who provided many \nvaluable comments. This research was supported by NSF grants CNS-0716343 and CNS-0742736. References \n[1] C. Anley. Advanced SQL injection in SQL server applications. White paper, Next Generation Security \nSoftware, 2002. [2] S. Bandhakavi, P. Bisht, P. Madhusudan, and V. N. Venkatakrishnan. Candid: preventing \nSQL injection attacks using dynamic candidate evaluations. In Proceedings of the ACM Conference on Computer \nand Communications Security, pages 12 24, 2007. [3] P. Bisht, P. Madhusudan, and V. N. Venkatakrishnan. \nCANDID: Dy\u00adnamic candidate evaluations for automatic prevention of SQL injection attacks. ACM Trans. \nInf. Syst. Secur., 13(2):1 39, Feb. 2010. [4] M. Bravenboer, E. Dolstra, and E. Visser. Preventing injection \nattacks with syntax embeddings. Science of Computer Programming, 75(7): 473 495, July 2010. [5] G. Buehrer, \nB. W. Weide, and P. A. G. Sivilotti. Using parse tree vali\u00addation to prevent sql injection attacks. In \nSEM 05: Proceedings of the 5th international workshop on software engineering and middleware, pages 106 \n113, 2005. [6] J. Clause, W. Li, and A. Orso. Dytan: a generic dynamic taint analysis framework. In Proceedings \nof the ACM International Symposium on Software Testing and Analysis, pages 196 206, 2007.  [7] J. Condit, \nM. Harren, S. McPeak, G. C. Necula, and W. Weimer. Ccured in the real world. SIGPLAN Notices, 38:232 \n244, May 2003. [8] W. Halfond, A. Orso, and P. Manolios. Wasp: Protecting web applica\u00adtions using positive \ntainting and syntax-aware evaluation. IEEE Trans. Softw. Eng., 34(1):65 81, 2008. [9] W. G. Halfond, \nJ. Viegas, and A. Orso. A Classi.cation of SQL-Injection Attacks and Countermeasures. In Proceedings \nof the IEEE International Symposium on Secure Software Engineering, March 2006. [10] R. Hansen and M. \nPatterson. Stopping Injection Attacks with Compu\u00adtational Theory, July 2005. In Black Hat USA. [11] T. \nJim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and Y. Wang. Cyclone: A safe dialect of c. \nIn Proceedings of the General Track of the USENIX Annual Technical Conference, pages 275 288, Berkeley, \nCA, USA, 2002. USENIX Association. [12] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A static analysis \ntool for detecting web application vulnerabilities (short paper). In Proceedings of the IEEE Symposium \non Security and Privacy, pages 258 263, 2006. [13] A. Kie.zun, P. J. Guo, K. Jayaraman, and M. D. Ernst. \nAutomatic cre\u00adation of SQL injection and cross-site scripting attacks. In Proceedings of the International \nConference on Software Engineering, May 2009. [14] K. Kline and D. Kline. SQL in a Nutshell, chapter \n4. O Reilly, 2001. [15] D. E. Knuth. On the translation of languages from left to right. Information \nand Control, 8(6):607 639, 1965. [16] P. J. Landin. The mechanical evaluation of expressions. Computer \nJournal, 6(4):308 320, 1963. [17] Z. Luo, T. Rezk, and M. Serrano. Automated code injection prevention \nfor web applications. In Proceedings of the Conference on Theory of Security and Applications, 2011. \n[18] Microsoft. SQL Minimum Grammar, 2011. http://msdn. microsoft.com/en-us/library/ms711725(VS.85).aspx. \n[19] Microsoft. CREATE FUNCTION (Transact-SQL), 2011. http: //msdn.microsoft.com/en-us/library/ms186755.aspx. \n[20] CWE/SANS Top 25 Most Dangerous Software Errors. The MITRE Corporation, 2009. Document version 1.4, \nhttp://cwe.mitre. org/top25/archive/2009/2009_cwe_sans_top_25.pdf. [21] CWE/SANS Top 25 Most Dangerous \nSoftware Errors. The MITRE Corporation, 2010. Document version 1.08, http://cwe.mitre. org/top25/archive/2010/2010_cwe_sans_top25.pdf. \n[22] CWE/SANS Top 25 Most Dangerous Software Errors. The MITRE Corporation, 2011. Document version 1.0.2, \nhttp://cwe.mitre. org/top25/archive/2011/2011_cwe_sans_top25.pdf. [23] G. C. Necula, J. Condit, M. Harren, \nS. McPeak, and W. Weimer. Ccured: type-safe retro.tting of legacy software. ACM Trans. Pro\u00adgram. Lang. \nSyst., 27:477 526, May 2005. [24] J. Newsome and D. X. Song. Dynamic taint analysis for automatic detection, \nanalysis, and signature generation of exploits on commodity software. In Proceedings of the Network and \nDistributed System Security Symposium, Feb. 2005. [25] A. Nguyen-tuong, S. Guarnieri, D. Greene, J. Shirley, \nand D. Evans. Automatically hardening web applications using precise tainting. In Proceedings of the \nIFIP International Information Security Confer\u00adence, pages 372 382, 2005. [26] G. Ollmann. Second order \ncode injection attacks. Technical report, NGS Software, 2004. [27] Oracle. How to write injection-proof \nPL/SQL. An Oracle White Paper, December 2008. URL http://www.oracle. com/technetwork/database/features/plsql/overview/ \nhow-to-write-injection-proof-plsql-1-129572.pdf. Page 11. [28] Oracle. CREATE FUNCTION Syntax for User-De.ned \nFunc\u00adtions, 2011. http://dev.mysql.com/doc/refman/5.6/en/ create-function-udf.html. [29] Oracle. CREATE \nFUNCTION, 2011. http://download.oracle. com/docs/cd/E11882_01/server.112/e17118/statements_ 5011.htm. \n[30] php. phpMyAdmin. http://www.phpmyadmin.net. [31] T. Pietraszek and C. V. Berghe. Defending against \ninjection attacks through context-sensitive string evaluation. In Proceedings of Recent Advances in Intrusion \nDetection (RAID), 2005. [32] G. D. Plotkin. Call-by-name, call-by-value and the .-calculus. Theo\u00adretical \nComputer Science, 1(2):125 159, 1975. [33] E. J. Schwartz, T. Avgerinos, and D. Brumley. All you ever \nwanted to know about dynamic taint analysis and forward symbolic execution (but might have been afraid \nto ask). In Proceedings of the IEEE Symposium on Security and Privacy, May 2010. [34] Z. Su and G. Wassermann. \nThe essence of command injection attacks in web applications. In Proceedings of the 33rd ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, pages 372 382, 2006. [35] O. Tripp, M. Pistoia, S. \nJ. Fink, M. Sridharan, and O. Weisman. TAJ: effective taint analysis of web applications. In Proceedings \nof the ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 87 97, 2009. [36] \nS. Tzu. The art of war. The Project Gutenberg eBook. Translated by Lionel Giles. http://www.gutenberg.org/cache/epub/17405/ \npg17405.txt. [37] G. Wassermann and Z. Su. Sound and Precise Analysis of Web Ap\u00adplications for Injection \nVulnerabilities. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Imple\u00admentation, \nJune 2007. [38] W. Xu, S. Bhatkar, and R. Sekar. Taint-enhanced policy enforcement: a practical approach \nto defeat a wide range of attacks. In Proceedings of the 15th USENIX Security Symposium, 2006. [39] Y. \nYounan, P. Philippaerts, F. Piessens, W. Joosen, S. Lachmund, and T. Walter. Filter-resistant code injection \non ARM. In Proceedings of the ACM Conference on Computer and Communications Security, pages 11 20, 2009. \n [40] X. Zhang and Z. Wang. A static analysis tool for detecting web application injection vulnerabilities \nfor ASP program. In International Conference on e-Business and Information System Security (EBISS), pages \n1 5, May 2010.    \n\t\t\t", "proc_id": "2103656", "abstract": "<p>This paper shows that existing definitions of code-injection attacks (e.g., SQL-injection attacks) are flawed. The flaws make it possible for attackers to circumvent existing mechanisms, by supplying code-injecting inputs that are not recognized as such. The flaws also make it possible for benign inputs to be treated as attacks. After describing these flaws in conventional definitions of code-injection attacks, this paper proposes a new definition, which is based on whether the symbols input to an application get used as (normal-form) values in the application's output. Because values are already fully evaluated, they cannot be considered \"code\" when injected. This simple new definition of code-injection attacks avoids the problems of existing definitions, improves our understanding of how and when such attacks occur, and enables us to evaluate the effectiveness of mechanisms for mitigating such attacks.</p>", "authors": [{"name": "Donald Ray", "author_profile_id": "81496683811", "affiliation": "University of South Florida, Tampa, FL, USA", "person_id": "P2991371", "email_address": "dray3@cse.usf.edu", "orcid_id": ""}, {"name": "Jay Ligatti", "author_profile_id": "81413595146", "affiliation": "University of South Florida, Tampa, FL, USA", "person_id": "P2991372", "email_address": "ligatti@cse.usf.edu", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103678", "year": "2012", "article_id": "2103678", "conference": "POPL", "title": "Defining code-injection attacks", "url": "http://dl.acm.org/citation.cfm?id=2103678"}