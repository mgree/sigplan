{"article_publication_date": "01-25-2012", "fulltext": "\n Edit Lenses Martin Hofmann Benjamin Pierce Daniel Wagner Ludwig-Maximilians-Universit\u00a8at University \nof Pennsylvania University of Pennsylvania Abstract A lens is a bidirectional transformation between \na pair of connected data structures, capable of translating an edit on one structure into an appropriate \nedit on the other. Many varieties of lenses have been studied, but none, to date, has offered a satisfactory \ntreatment of how edits are represented. Many foundational accounts [5, 7] only consider edits of the \nform overwrite the whole structure, leading to poor behavior in many situations by failing to track the \nassociations between corresponding parts of the structures when elements are inserted and deleted in \nordered lists, for example. Other theories of lenses do maintain these associations, either by annotating \nthe structures themselves with change information [6, 15] or using auxiliary data structures [2, 4], \nbut every extant theory assumes that the entire original source structure is part of the information \npassed to the lens. We offer a general theory of edit lenses, which work with de\u00adscriptions of changes \nto structures, rather than with the structures themselves. We identify a simple notion of editable structure \na set of states plus a monoid of edits with a partial monoid action on the states and construct a semantic \nspace of lenses between such structures, with natural laws governing their behavior. We show how a range \nof constructions from earlier papers on state\u00adbased lenses can be carried out in this space, including \ncomposi\u00adtion, products, sums, list operations, etc. Further, we show how to construct edit lenses for \narbitrary containers in the sense of Abbott, Altenkirch, and Ghani [1]. Finally, we show that edit lenses \nre.ne a well-known formulation of state-based lenses [7], in the sense that every state-based lens gives \nrise to an edit lens over structures with a simple overwrite-only edit language, and conversely every \nedit lens on such structures gives rise to a state-based lens. Categories and Subject Descriptors D.3.2 \n[Programming Lan\u00adguages]: Language Classi.cations Specialized application lan\u00adguages General Terms Design, \nLanguages, Theory Keywords algebra, bidirectional programming, edit, lens, sym\u00admetric 1. Introduction \nRecent years have seen growing interest in bidirectional program\u00adming languages domain-speci.c languages \nwhere a program de\u00adscribes how to maintain a connection between data structures of Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 12, January 25 27, \n2012, Philadelphia, PA, USA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. . . $10.00 two \ndifferent shapes, translating updates to one structure into ap\u00adpropriate updates to the other. The core \nconcepts of bidirectional programming have roots in early work on the database view up\u00addate problem (see \n[5] for a survey); more recently, they have been explored in diverse areas including model-driven software \ndevelop\u00adment [13], data synchronization [5], user interfaces [10], and Unix system con.guration management \n[9]. The meaning of a bidirectional program connecting a set X to a set Y often called a lens from X \nto Y is intuitively a pair of transformations, one mapping X updates to Y updates and the other mapping \nY updates to X updates, subject to some behavioral laws specifying how the two transformations .t together. \nTechni\u00adcally, this intuition can be realized in numerous ways. A naive def\u00adinition is to say that a lens \nfrom X to Y is just a pair of functions, f . X . Y (telling how to map an updated X state to an appro\u00adpriate \nY state) and g . Y . X. But this is too simple: if the lens laws impose the reasonable requirement that \nf and g should round trip, then our bidirectional programs will only denote bijections an important but \nlimited special case. To allow for situations where each structure can contain a mixture of information \nthat is shared with the other and information that is not, something more than just the updated structure \nmust be given as input to the transformations. Different variants of lenses differ as to what this something \nmore should be. We might, for example, give the transformation from X to Y both a new X and an old Y \ni.e., f . X \u00d7 Y . Y with the intention that f should weave together the shared information from the new \nX with the local information from the old Y to produce a new Y . Or instead of a whole Y , we might pass \nf some smaller structure (a complement) representing just the information that is needed to build an \nupdated Y out of an updated X. Or perhaps one of these plus some additional information about the alignment \nof the updated information (e.g., a new element was inserted at the beginning of this list, so the second \nelement in the new X corresponds to the .rst element in the old Y ), either in the form of an auxiliary \ndata structure or perhaps somehow embedded as annotations in the updated X itself. What all these variants \nhave in common is that the inputs to a lens always include the whole updated state. This leaves an un\u00adfortunate \ngap between the theory and practical realizations, which generally represent updates in some simpler, \nmore compact form that only describes what has changed in a possibly large structure. In this paper, \nwe offer the .rst foundational treatment of edit lenses lenses that operate directly on edits, rather \nthan on whole structures. Our theory of edit lenses is built from simple and famil\u00adiar algebraic structures \n(\u00a73). It supports a wide range of fundamen\u00adtal syntactic constructions composition, products, sums, list \noper\u00adations, etc. allowing us to construct lenses for complex data struc\u00adtures together with appropriate \nrepresentations for edits in a compo\u00adsitional fashion (\u00a74). Indeed, the theory includes a general account \nof how to construct mapping lenses for a wide class of container data structures [1] such as lists and \ntrees (\u00a75). This rich set of syn\u00adtax constructors should form a suitable basis for the design of new \n (a) initial replicas (b) a new composer is added to one replica (c) the lens adds the new composer \nto the other replica (d) the curator makes some corrections (f) two different edits with the same effect \non the left   Figure 1. A simple (complement-less) edit lens in action. bidirectional languages, for \nexample in the style of Boomerang [2]. Our theory can support a wide variety of edit languages. We mostly \nconcentrate on the simplest form, where compound edits are freely generated from some set of atomic edits; \n\u00a76 considers the exten\u00adsion to richer languages with additional algebraic laws. Finally, our theory generalizes \nand re.nes the state-based symmetric lenses of Hofmann, Pierce, and Wagner [7] in a precise sense (\u00a77). \nThe paper ends with a discussion of related work (\u00a78) and some remarks on future directions (\u00a79). 2. \nOverview Before diving into technicalities, let s take a brief tour of the main ideas via some examples. \nFigure 1 demonstrates a simple use of edit lenses to synchronize two replicas.1 In part (a), we see the \ninitial replicas, which are in a synchronized state. On the left, the replica is a list of records describing \ncomposers birth and death years; on the right, a list of records describing the same composers countries \nof origin. In part (b), the user interacting with the left-hand replica decides to add a new composer, \nMonteverdi, at the end of the list. This change is described by the edit script ins(3); mod(3, ( Monteverdi \n, 1567-1643 )). The script says to .rst insert a dummy record at index three, then modify this record \nby replacing the left .eld with Monteverdi and replacing the right .eld with 1567-1643 . (One could of \ncourse imagine other edit languages where the insertion would be done in one step. We represent it this \nway because this is closer to how our generic container mapping combinator in \u00a75 will do things.) The \nlens connecting the two replicas now converts this edit script into a corresponding edit script that \nadds Monteverdi to the right-hand replica, shown in part (c): ins(3); mod(3, ( Monteverdi , 1)). Note \nthat the translated mod command overwrites the name component but leaves the country component with its \ndefault value, ?country?. This is the best it can do, since the edit was in the left-hand replica, which \ndoesn t mention countries. Later, an eagle-eyed editor notices the missing country information and .lls \nit in, at the same time correcting a spelling error in Schumann s name, as shown in (d). In part (e), \nwe see that the lens discards the country information when translating the edit from right to left, but \npropagates the spelling correction. Of course, a particular new replica state can potentially be achieved \nby many different edits, and these edits may be trans\u00adlated differently. Consider part (f) of Figure \n1, where the left-hand replica ends up with a row for Monteverdi at the beginning of the list, instead \nof at the end. Two edit scripts that achieve this effect are shown. The upper script deletes the old \nMonteverdi record and inserts a brand new one (which happens to have the same data) at the top; the lower \nscript rearranges the order of the list. The trans\u00adlation of the upper edit leaves Monteverdi with a \ndefault country, while the lower edit is translated to a rearrangement, preserving all the information \nassociated with Monteverdi. We do not address the question of where these edits come from or who decides, \nin cases like part (f), which of several possible edits is intended. As argued in [2], answers to these \nquestions will tend to be intertwined with the speci.cs of particular editing and/or dif.ng tools and \nwill tend to be messy, heuristic, and domain-speci.c unpromising material for a foundational theory. \nRather, our aim is to construct a theory that shows how edits, however generated, can be translated between \nreplicas of different shapes. Abstractly, the lens we are discussing maps between structures of the form \n(X \u00d7 Y ) * and ones of the form (X \u00d7 Z) *, where X is the set of composer names, Y the set of date strings, \nand Z the set of countries. We want to build it compositionally that is, the whole lens should have the \nform e*, where * is a list mapping lens combinator and e is a lens for translating edits to a single \nrecord i.e., e is a lens from X \u00d7 Y to X \u00d7 Z. Moreover, e itself should be built as the product e1 \u00d7 \ne2 of a lens e1 . X . X that translates composer edits verbatim, while e2 is a disconnect lens that maps \nevery edit on either side to a trivial identity edit on the other side. In analogous fashion, the edit \nlanguages for the top-level struc\u00adtures will be constructed compositionally. The set of edits for struc\u00adtures \nof the form (X \u00d7 Y ) *, written .((X \u00d7 Y ) * ), will be de\u00ad.ned together with the list constructor *. \nIts elements will have the form ins(i) where i is a position, del(i), reorder(i1,...,in) where i1,...,in \nis a permutation on positions (compactly rep\u00ad 1 We use the word synchronize informally to mean simply \nmaintain a correspondence between two replicas by propagating edits in both direc\u00adtions. A full-blown \nsynchronization tool would also include, at a minimum, some mechanism for dealing with con.icts between \ndisconnected edits to the two structures, which is outside the scope of this paper.  (a) the initial \nreplicas: a tagged list of composers and authors on the left; a pair of lists on the right; a complement \nstoring just the tags (b) an element is added to one of the partitions (c) the complement tells how \nto translate the index Figure 2. A lens with complement. resented, e.g. as a branching program), and \nmod(p, dv), where dv . .(X \u00d7 Y ) is an edit for X \u00d7 Y structures. Pair edits dv . .(X \u00d7 Y ) have the \nform .X \u00d7 .Y , where .X is the set of edits to composers and .Y is the set of edits to dates. Finally, \nboth .X and .Y are sets of primitive overwrite edits that com\u00adpletely replace one string with another, \ntogether with an identity edit 1 that does nothing at all; so .X can be just {()} + X (with 1 = inl(())) \nand similarly for Y and Z. Our lens e * will consist of two components one for trans\u00adporting edits from \nthe left side to the right, written (e * ).= . .(X \u00d7 Y ) * . .(X \u00d7 Z) * ,2 and another for transporting \nedits from right to left, written (e * ).. .(X \u00d7 Y ) * H . .(X \u00d7 Z) * . We sometimes need lenses to have \na little more structure than this simple example suggests. To see why, consider de.ning a partitioning \nlens p between the sets .((X +Y ) * ) and .(X * \u00d7Y * ). Figure 2 demonstrates the behavior of this lens. \nIn part (a), we show the original replicas: on the left, a single list that intermingles authors and \ncomposers (with inl/inr tags showing which is which), and on the right a pair of homogeneous (untagged) \nlists, one for authors and one for composers. Now consider an edit, as in (b), that inserts a new element \nsomewhere in the author list on the right. It is clear that we should transport this into an insertion \non the left replica, but where, exactly, should we insert it? If the H function is given just an insertion \nedit for the homogeneous author list and nothing else, there is no way it can translate this edit into \na sensible position in the combined list on the left, since it doesn t know how the lists of authors \nand composers are interleaved on the left. 2 The symbol = is pronounced put an edit through the lens \nfrom left to right, or just put right. It is the edit-analog of the putr function of the state-based \nsymmetric lenses in [7] and the put function of the state-based asymmetric lenses in [3, 5]. The solution \nis to store a small list, called a complement, off to the side, recording the tags (inl or inr) from \nthe original, in\u00adtermingled list, and pass this list as an extra argument to trans\u00adlation. We then enrich \nthe types of the edit translation functions to accept a complement and return a new complement, so that \np.= . .((X + Y ) * ) \u00d7 C . .(X * \u00d7 Y * ) \u00d7 C and p.H . .(X * \u00d7 Y * ) \u00d7 C . .((X + Y ) * ) \u00d7 C. Part (c) \ndemonstrates the use (and update) of the complement when translating the insertion. Note that the complement \nstores just the inl/inr tags, not the actual names of the authors and composers in the left-hand list. \nIn general, the information stored in C will be much smaller than the information in the replicas; indeed, \nour earlier example illustrates the common case in which C is the trivial single-element set Unit. The \ntranslation functions manipulate just the complements and the edits, which are also small compared to \nthe size of the replicas. 3. Edit Lenses A key design decision in our formulation of edit lenses is to \nsepa\u00adrate the description of edits from the action of applying an edit to a state. This separation is \ncaptured by the standard mathematical notions of monoid and monoid action. 3.1 De.nition: A monoid is \na triple (M, \u00b7M , 1M ) of a set M, an associative binary operation \u00b7M . M \u00d7 M . M , and a unit element \n1M . M that is, with \u00b7M and 1M such that x \u00b7M (y \u00b7M z)=(x \u00b7M y) \u00b7M z and 1M \u00b7M x = x = x \u00b7M 1M . When \nno confusion results, we use M to denote both the set and the monoid, drop subscripts from \u00b7 and 1, and \nwrite mn for m \u00b7 n. The unit element represents a change nothing edit. Multipli\u00adcation of edits corresponds \nto packaging up multiple edits into a single one representing their combined effects. Modeling edits \nas monoid elements gives us great .exibility in concrete representations. The simplest edit language \nis a free monoid whose elements are just words over some set of primitive edits and whose multiplication \nis concatenation. However, it may be useful to put more structure on edits, either (a) to allow more \ncompact representations or (b) to capture the intuition that edits to different parts of a structure \ndo not interfere with each other and can thus be applied in any order. We will see an example of (b) \nin \u00a76. For a simple example of (a), recall from \u00a72 that, for every set X, we can form an overwrite monoid \nwhere the edits are just the elements of X together with a fresh unit element i.e., edits can be represented \nas elements of the disjoint union Unit + X. Com\u00adbining two edits in this monoid simply drops the second \n(unless the .rst is the unit): inl(()) \u00b7 e = e and inr(x) \u00b7 e = inr(x). These equations allow this edit \nlanguage to represent an arbitrarily long sequence of updates using a single element of X (and, en passant, \nto recover state-based lenses as a special case of edit lenses).The monoid framework can also accommodate \nmore abstract notions of edit. For example, the set of all total functions from a set X to itself forms \na monoid, where the multiplication operation is func\u00adtion composition. This is essentially the form of \nedits considered by Stevens [14]. We mostly focus on the simple case where edit languages are free monoids. \n\u00a76 considers how additional laws can be added to the product and sum lens constructions. 3.2 De.nition: \nGiven a monoid M and a set X,a monoid action on M and X is a partial function 8. M \u00d7 X-X satisfying two \nlaws: 1 8 x = x and (m \u00b7 n) 8 x = m 8 (n 8 x). As with monoid multiplication, we often elide the monoid \naction symbol, writing mx for m 8 x. In standard mathematical terminol\u00adogy, a monoid action in our sense \nmight instead be called a partial monoid action, but since we always work with partial actions we .nd \nit convenient to drop the quali.er. A bit of discussion of partiality is in order. Multiplication of \nedits is a total operation: given two descriptions of edits, we can always .nd a description of the composite \nactions of doing both in sequence. On the other hand, applying an edit to a particular state may sometimes \nfail. This means we need to work with expressions and equations involving partial operations. As usual, \nany term that contains an unde.ned application of an operation to operands is unde.ned there is no way \nof catching unde.nedness. An equa\u00adtion between possibly unde.ned terms (e.g., as in the de.nition above) \nmeans that if either side is de.ned then so is the other, and their values are equal (Kleene equality). \nWhy deal with failure explicitly, rather than keeping edit appli\u00adcation total and simply de.ning our \nmonoid actions so that apply\u00ading an edit in a state where it is not appropriate yields the same state \nagain (or perhaps some other state)? One reason is that it seems natural to directly address the fact \nthat some edits are not appli\u00adcable in some states, and to have a canonical outcome in all such cases. \nA more technical reason is that, when we work with monoids with nontrivial equations, making inapplicable \nedits behave like the identity is actually wrong.3 However, although the framework allows for the possibility \nof edits failing, we still want to know that the edits produced by our lenses will never actually fail \nwhen applied to replica states arising in practice. This requirement, corresponding to the totality property \nof previous presentations of lenses [5], is formalized in Theorem 3.7. In general, we adopt the design \nprinciple that partiality should be kept to a minimum; this simpli.es the de.nitions. It is convenient \nto bundle a particular choice of monoid and monoid action, plus an initial element, into a single structure: \n3.3 De.nition: A module is a tuple (X, initX , .X, 8X ) com\u00adprising a set X, an element initX . X, a \nmonoid .X, and a monoid action 8X of .X on X. If X is a module, we refer to its .rst component by either \n|X| or just X, and to its last component by 8 or simple juxtaposition. We will use modules to represent \nthe structures connected by lenses. Before coming to the de.nition of lenses, however, we need one last \ningredient: the notion of a stateful homomorphism between monoids. As we saw in \u00a72, there are situations \nwhere the information in an edit may be insuf.cient to determine how it should be translated we may need \nto know something more about how the two structures correspond. The exact nature of the extra information \nneeded varies according to the lens. To give lenses a place to store such auxiliary information, we follow \n[7] and allow the edit-transforming components of a lens (the = and H functions) to take a complement \nas an extra input and return an updated complement as an extra output. 3.4 De.nition: Given monoids M \nand N and a complement set C, a stateful monoid homomorphism from M to N over C is a function h . M \u00d7 \nC . N \u00d7 C satisfying two laws: h(1M ,c)=(1N ,c) 3 Here is a slightly contrived example. Suppose that \nthe set of states is natural numbers and that edits have the form (x . y), where the intended interpretation \nis that, if the current state is x, then the edit yields state y. It is reasonable to impose the equation \n(y . z) \u00b7 (x . y)=(x . z), allowing us to represent sequences of edits in a compact form. But now consider \nwhat happens when we apply the edit (5 . 7) \u00b7 (3 . 5) to the state 5. The second monoid action law demands \nthat ((5 . 7) \u00b7 (3 . 5)) 8 5 = (5 . 7) 8 ((3 . 5) 8 5), which, by the equation we imposed, is the same \nas (3 . 7) 8 5 = (5 . 7) 8 ((3 . 5) 8 5). But the left\u00adhand side is equal to 5 (since the edit (3 . 7) \ndoes not apply to the state 5), while the right-hand side is equal to 7 (since the .rst edit, (3 . 5), \nis inapplicable to the state 5, so it behaves like the identity and returns 5 from which (5 . 7) takes \nus to 7), so the action law is violated. '''') h(m, c)=(n, c') h(m,c')=(n,c ' ''' h(m\u00b7M m, c)=(n\u00b7N n, \nc) These are basically just the standard monoid homomorphism laws, except that h is given access to \nsome internal state c . C that it uses (and updates) when mapping from M to N; in the second law, we \nmust thread the state c' produced by the .rst h into the second use of h, and we demand that both the \nresult and the effect on the state ' should be the same whether we send a composite element m\u00b7 m through \nh all at once or in two pieces. The intended usage of an edit lens is as follows. There are two users, \none holding an element of X the other one an element of Y , both referred to hereafter as replicas. Initially, \nthey hold initX and initY , respectively, and the lens is initialized with complement e.init. The users \nthen perform actions and propagate them across the lens. An action consists of producing an edit dx (or \ndy), apply\u00ading it to one s current replica x (resp. y), putting the edit through the lens to obtain an \nedit dy (resp. dx), and asking the user on the other side to apply dy (dx) to their replica. In the process, \nthe inter\u00adnal state c of the lens is updated to re.ect the new correspondence between the two replicas. \nWe further assume there is some consis\u00adtency relation K between X, Y , and C, which describes the syn\u00adchronized \nstates of the replicas and complement. This gives us a natural way to state the totality requirement \ndiscussed above: if we start in a consistent state, make a successful edit (one that does not fail at \nthe initiating side), and put it through the lens, the resulting edit is guaranteed (a) to be applicable \non the receiving side and (b) to lead again to a consistent state. We make no guarantees about edits \nthat fail at the initiating side: these should not be put through the lens. 3.5 De.nition: A symmetric \nedit lens between modules X and Y consists of a complement set C, a distinguished element init . C, two \nstateful monoid homomorphisms = . .X \u00d7 C . .Y \u00d7 C and H . .Y \u00d7 C . .X \u00d7 C, and a ternary consistency \nrelation K .|X|\u00d7 C \u00d7|Y | such that (initX , init, initY ) . K;  if (x, c, y) . K and dxx is de.ned \nand =(dx, c)=(dy, c'),  ' then dyy is also de.ned and (dxx,c, dyy) . K; ' if (x, c, y) . K and dyy \nis de.ned and H(dy, c)=(dx, c), ' then dxx is also de.ned and (dxx,c, dyy) . K. Since symmetric edit \nlenses are the main topic of this paper, we will generally write edit lens or just lens for these, deploying \nadditional adjectives to talk about other variants such as the state\u00adbased symmetric lenses of [7]. The \nintuition about K s role in guaranteeing totality can be formalized as follows. 3.6 De.nition: Let e \n. X . Y be a lens. A dialogue is a sequence of edits a word in (.X + .Y ) *. The partial function e.run \n. (.X + .Y ) * -X \u00d7 e.C \u00d7 Y is de.ned by: e.run(e)=(initX , e.init, initY ) e.run(w)=(x0, c, y0) e.=(dx1,c)=(dy1,c1) \ne.run(inl(dx1)w)=(dx1 x0,c1, dy1 y0) e.run(w)=(x0, c, y0) e.H(dy1,c)=(dx1,c1) e.run(inr(dy1)w)=(dx1 x0,c1, \ndy1 y0) 3.7 Theorem: Let w be a dialogue and suppose that e.run(w)= (x, c, y) in particular, all the \nedits in w succeed. Let dx . .X ' be an edit with dxx de.ned. If (dy, c)= e.=(dx, c) then dyy is also \nde.ned. An analogous statement holds for H. Beyond its role in guaranteeing totality, the consistency \nrelation in a lens plays two important roles. First, it is a sanity check on the behavior of = and H. \nSecond, if we project away the middle component, we can present it to programmers as documentation of \nthe synchronized states of the two replicas i.e., as a partial speci.cation of = and H. One technical \nissue arising from the de.nition of edit lenses is that the hidden complements cause many important laws \nlike as\u00adsociativity of composition to hold only up to behavioral equiva\u00adlence. This phenomenon was also \nobserved in [7, \u00a73] for the case of symmetric state-based lenses, and the appropriate behavioral equiv\u00adalence \nfor edit lenses is a natural re.nement of the one used there (taking the consistency relations into account). \n3.8 De.nition [Lens equivalence]: Two lenses k, e : X . Y are equivalent (written k = e) if, for all \ndialogues w, k.run(w) is de.ned iff e.run(w) is de.ned;  if k.run(w)=(x, c, y) and e.run(w)=(x ' , \nd, y ' ), then x = x ' and y = y '; and  if k.run(w)=(x, c, y) and e.run(w)=(x ' , d, y ' ) and dxx \nis de.ned and e.=(dx, c)=(dy, ) and k.=(dx, d)=(dy ' , ) then dy = dy ', and the analogous property for \nH.  (Note that the second clause is actually implied by the third.) Since the complements of the two \nlenses in question may not even have the same type, it does not make sense to require that they be equal. \nInstead, the equivalence hides the complements, relying on the observable effects of the lens actions. \nHowever, by .nding a relationship between the complements, we can prove lens equivalence with a bisimulation-style \nproof principle: 3.9 Theorem: Lenses k, e : X . Y are equivalent iff there exists a relation S . X \u00d7 \nk.C \u00d7 e.C \u00d7 Y such that (1) (initX , k.init, e.init, initY ) . S; (2) if (x, c, d, y) . S and dxx is \nde.ned, then if (dy1,c ' )= k.=(dx, c) and (dy2,d ' )= e.=(dx, d), then dy1 = dy2 and (dx x,c ' ,d ' \n, dy1 y) . S; and (3) analogously for H. 4. Edit Lens Combinators We have proposed a semantic space of \nedit lenses and justi.ed its design. But the proof of the pudding is in the syntax in whether we can \nactually build primitive lenses and lens combinators that live in this semantic space and that do useful \nthings. Generic Constructions As a .rst baby step, here is an identity lens that connects identical structures \nand maps edits by passing them through unchanged. Here and below, we elide the de.nition of the init \ncomponent when C = Unit = {()}, since it can only be one thing. In lens de.nitions like this one, the \nupper box serves both as a typing rule and as the implicit statement of a theorem saying that the functions \nin the box below it inhabit the appropriate types and satisfy the corresponding lens laws. For lens combinators, \nthe de.nition also makes an implicit statement about compatibility with lens equivalence. For brevity, \nand because they are generally straightforward, we usually elide these theorems. Now for a more interesting \ncase: Given lenses k and e connect\u00ading X to Y and Y to Z, we can build a composite lens k; e that connects \nX directly to Z. Note how the complement of the com\u00adposite lens includes a complement from each of the \ncomponents, and how these complements are threaded through the = and H operations.  As might be expected, \ncomposition of lenses is associative, and the identity lens is a unit for composition. However, as mentioned \nabove, we need to be a little careful: it is not quite the case that (k; e); m = k;(e; m) in particular \nthey have different comple\u00adments. Instead, what we can show is that (k; e); m = k;(e; m). Another simple \nlens combinator is dualization: for each lens e . X . Y , we can construct its dual, eop . Y . X, by \nswapping = and H. For the next de.nition, observe that the set Unit gives rise to a trivial monoid structure \nand, for any given set X and element x . X, a trivial module with initial element x, which we write Unitx.X \n. When context clearly calls for a module, we will abbre\u00adviate Unit().Unit to simply Unit. Now, for each \nmodule X, there is a terminal lens that connects X to the trivial Unit module by throwing away all edits. \n The disconnect lens that we saw in \u00a72 can be built from term. The term lens is also unique (up to equivalence): \nthe implementation of = is forced by the size of its range monoid Unit, and the implementation of H is \nforced by the homomorphism laws. There is a trivial lens between any two isomorphic modules. Formally, \na module homomorphism (f, h) between modules X and Y is a function f . X . Y and a monoid homomorphism \nh . .X . .Y such thatf(initX )= initY and f(dxx)= h(dx) f(x). There is an identity (.x.x, .dx. dx) for \nevery mod\u00adule, and the point-wise composition of module homomorphisms is also a homomorphism, so modules \nform a category. If module ho\u00admomorphisms (e, g) . X . Y and (f, h) . Y . X satisfy (e, g); (f, h)= idX \nand (f, h); (e, g)= idY , then (e, g) is an isomorphism and (f, h) is inverse to (e, g). Now: C = Unit \nK = {(x, (),f(x)) | x . X} =(dx, ())= (h(dx), ()) H(dy, ()) = (h-1(dy), ()) The fact that this always \nde.nes a lens, plus a couple of other easy facts, amounts to saying that there is a functor from the \ncategory of module isomorphisms to the category of edit lenses. Generators for free monoids For writing \npractical lenses, we want not only generic combinators like the ones presented above, but also more speci.c \nlenses for structured data such as products, sums, and lists. We show in the rest of this section how \nto de\u00ad.ne simple versions of these constructors whose associated edit monoids are freely generated. \u00a75 \nshows how to generalize the list mapping lens to other forms of containers, and \u00a76 discusses edit languages \nwith nontrivial laws. Given a set G, we write G * for the set of .nite sequences of elements of G. We \nwrite e for the empty sequence and g to denote both a generator element and the single-element sequence \ncontaining such an element. Sequence concatenation is denoted by juxtaposition; when discussing a sequence \ng1 \u00b7\u00b7\u00b7 gn, we also use g to refer to the entire sequence. The notation |g| means the length of a sequence: \n|g1 \u00b7\u00b7\u00b7 gn| = n. It is easy to show that G * together with sequence concatenation and e forms a monoid. \nIt is often convenient to specify the behavior of a monoid ho\u00admomorphism by giving its output on each \ngenerator. Given a func\u00adtion fg . G . M on generators, the monoid homomorphism f .. M is de.ned by f(e)= \n1 and f(g1 \u00b7\u00b7\u00b7 gn)= G * fg(g1)f(g2 \u00b7\u00b7\u00b7 gn). Similarly, given a stateful function fg . G \u00d7 C . M \u00d7 C, \nwe can de.ne a stateful monoid homomorphism f . G * \u00d7 C . M \u00d7 C by setting f (e, c)=(1,c) and f(g1 \u00b7\u00b7\u00b7 \ngn,c)= let (m ' ,c ' )= f(g2 \u00b7\u00b7\u00b7 gn,c) in '''' ' let (m ,c )= fg(g1,c ) in '' ' '' (m m,c ). Tensor Product \nGiven modules X and Y , a primitive edit to a pair in |X|\u00d7|Y | is either an edit to the X part or an \nedit to the Y part. G. = {left(dx) | dx . .X}.{right(dy) | dy . .Y } X,Y We can turn these generators \ninto a module by giving specifying a monoid action for the free monoid (G. ) * : X,Y left(dx) 8g (x, \ny)=(dx x,y) right(dy) 8g (x, y)=(x, dyy) The full module is then given by X . Y =|X|\u00d7|Y |, (initX , \ninitY ), (G. ) * , 8. X,Y Now we can build a lens that runs two sub-lenses in parallel on the components \nof a product module. The = and H functions are de.ned via stateful monoid homomorphism speci.cations. \n C = k.C \u00d7 e.C init = (k.init, e.init) K = { ((x, z), (ck, ce), (y, w)) | (x, ck, y) . k.K . (z, ce, \nw) . e.K } = g(left(dx), (ck, ce)) = let (dz, c ' k) = k.=(dx, ck) in (left(dz), (c ' k, ce)) ' = g(right(dy), \n(ck,ce)) = let (dw, c e)= e.=(dy, ce) in (right(dw), (ck,c e' )) Hg similarly 4.1 Theorem: k . e is \nindeed a lens.  If k = k ' and e = e ', then k . e = k ' . e ' .  id . id = id.  ' ) = (k; k ''  \n(k . e); (k ' . e ) . (e; e ).  ((k . e) . m); isoassoc = e . (k . m), where assoc is the isomorphism \nbetween (X . Y ) . Z and X . (Y . Z) for all X, Y, Z.  (k . e); isoswap = e . k, where swap is the isomorphism \nbetween X \u00d7 Y and Y \u00d7 X.  Proof: For the .rst statement (being a good lens), .rst note that preservation \nof monoid multiplication is immediate since .(X.Y ) is free. It remains to show that the consistency \nrelation of k . e is preserved and guarantees de.nedness. This is direct from the de.nition and the assumption \nthat k and e are lenses. The remaining statements are direct consequences of the de.\u00adnitions, together \nwith Theorem 3.9; for example, the third equiva\u00adlence can be witnessed by the simulation relation {((x, \ny), ((c, d), (c ' ,d ' )), ((c, c ' ), (d, d ' )), (x '' ,y '' )) | '' ' '''' .(x ,y ). (x, c, x ) . \nk.K . (x ,c ,x ) . k ' .K ' ''' . (y, d, y ' ) . e.K . (y ,d ' ,y ) . e .K}. D As in [7], the tensor \nconstruction is not quite a full categorical product, because duplicating information does not give rise \nto a well-behaved lens there is no lens with type X . X . X that satis.es all the equivalences a lens \nprogrammer would want. However, tensor product does yield various symmetric monoidal categories of edit \nlenses; for lack of space we omit the details. Sum We now present one way (not the only one see footnote \n4) of constructing a sum module and a sum lens. Given sets of edits .X and .Y , we can describe the generators \nfor the free monoid of edits to a sum by: G. = {switchiL(dx) | i .{L, R}, dx . .X} X,Y .{switchiR(dy) \n| i .{L, R}, dy . .Y }.{stayL(dx) | dx . .X}.{stayR(dy) | dy . .Y }.{fail} The idea is that edits to \na sum can either change just the content or change the tag (and therefore necessarily also the content, \nwhich is superseded by the given new content). That is, we want the atoms of the edit language to express \nthe operations of editing content and switching sides. This gives us the switchLR, switchRL, and stay \nedits. For present purposes, we could leave it at this and de.ne the monoid of edits to be the free monoid \nover just these generators. However, in Section 6 we will introduce a more compact represen\u00adtation that \nallows multiple edits to be combined into one, and this  C = k.C + e.C init = inl(k.init) K = {(inl(x), \ninl(c), inl(y)) | (x, c, y) . k.K}.{(inr(z), inr(c), inr(w)) | (z, c, w) . e.K} ck = k.init ce = e.init \n= g(switchLL(dx), inl(c)) = let (dy, c ' )= k.=(dx, ck) in (switchLL(dy), inl(c ' )) = g(switchRL(dx), \ninr(c)) = let (dy, c ' )= k.=(dx, ck) in (switchRL(dy), inl(c ' )) = g(switchLR(dz), inl(c)) = let (dw, \nc ' )= e.=(dz, ce) in (switchLR(dw), inr(c ' )) = g(switchRR(dz), inr(c)) = let (dw, c ' )= e.=(dz, ce) \nin (switchRR(dw), inr(c ' )) = g(stayL(dx), inl(c)) = let (dy, c ' )= k.=(dx, c) in (stayL(dy), inl(c \n' )) = g(stayR(dz), inr(c)) = let (dw, c ' )= e.=(dz, c) in (stayR(dw), inr(c ' )) = g(e, c) =(fail,c) \nin all other cases Hg is analogous Figure 3: The sum lens representation will give rise to the other \ntwo switch operations; for example, switchLL represents a switchLR followed by a switchRL. To avoid having \ntwo similar but subtly different de.nitions, we in\u00adclude these edits here in the basic generators as \nwell. Finally, we introduce an always-failing edit to represent sequences of edits that are internally \ninconsistent e.g., a switch to the left side followed by an attempt to apply an edit which stays on the \nright side. These intuitions are formalized in the application function: switchLL(dx) 8g inl(x)= inl(dx \ninitX ) switchLR(dy) 8g inl(x)= inr(dy initY ) switchRL(dx) 8g inr(y)= inl(dx initX ) switchRR(dy) 8g \ninr(y)= inr(dy initY ) stayL(dx) 8g inl(x)= inl(dxx) stayR(dy) 8g inr(y)= inr(dyy) e 8g v unde.ned in \nall other cases We then de.ne the sum of modules X and Y as X . Y = |X| + |Y |, inl(initX ), (G. ) * \n, 8 . X,Y We now wish to give a lens combinator k . e that runs lens k on the parts of edits that apply \nto inl values and e on the parts of edits that apply to inr values.4 Figure 3 shows the full de.nition. \n4 In [7], there is some discussion regarding forgetful and retentive sum lenses, with the distinction \nrevolving around what to do with the complement when an edit switches between sides of the sum. For state\u00adbased \nlenses, lenses on recursive structures like lists were given in terms of lenses on the non-recursive \nstructure, and the retentive sum lens gave rise to a retentive list mapping lens whereas the forgetful \nsum lens gave rise to a forgetful list mapping lens. The poor alignment strategies given in that paper \nwere mediated somewhat by the retentive map s ability to use complements from previous versions of a \nlist, making retentive sums somewhat more attractive than forgetful ones. In this presentation, however, \n C = e.C * init = e K = {(x, c, y) ||x| = |c| = |y|. .1=p=|x|. (xp,cp,yp) . e.K} = g(mod(p, dx),c)= \nlet (dy, c p' )= e.=(dx, cp) in (mod(p, dy),c[p . c ' p])) when p = n = g(mod(p, dx),c)=(fail,c) when \np>n = g(fail,c) =(fail,c) = g(dx, c) =(dx, dxc) in all other cases H similar Figure 4: The list mapping \nlens  4.2 Theorem: When k and e are lenses, so is k . e. Proof: The homomorphism laws are again trivial. \nWe must show that the consistency relation K is maintained. We have (initX.Z , init, initY .W ) =(inl(initX \n), inl(k.init), inl(initY )) . K, since (initX , k.init, initY ) . k.K. So it remains to show that that \n= and H preserve this relation. We need only con\u00adsider the case where we begin with an arbitrary consistent \ntriple (inl(x), inl(c), inl(y)) . K and dv . X .Z for which dv inl(x) is de.ned. (The cases where the \ntriple is of the form (inr(x), inr(c), inr(y)) . K are similar, swapping k and e in some places; the \ncases where we are considering a dv . Y . W are similar, but use H instead of = everywhere.) Since dv \ninl(x) is de.ned, there are three forms of dv to consider: switchLL(dx), switchLR(dz), and stayL(dx). \nHere is the most interesting case: Case dv = switchLL(dx): We de.ne (dy, c ' )= k.putr(dx, k.init) and \n(x ' ,y ' )=(dx initX , dy initY ). Since k is a lens, we know '' ' (initX , k.init, initY ) . k.K and \ntherefore that (x ,c ,y ) . '' ' k.K. This means (inl(x ), inl(c ), inl(y )) . K. Since (k . e).=(dv, \ninl(c)) = (switchLL(dy), inl(c ' )) and dv inl(x)= inl(x ' ) and switchLL(dy) inl(y)= inl(y ' ), this \nshows that K is preserved in this case. D Like the tensor product, this lens combinator is a bifunctor: \n id . id = id and (k . e); (k ' . e ' ) = (k; k ' ) . (e; e ' ). List module Next, let us consider lists. \nGiven a module X, we de.ne the basic edits for lists over |X| to include in-place modi.\u00adcations, insertions, \ndeletions, and reorderings: Glist X = {mod(p, dx) | p . N+ , dx . .X}.{ins(i) | i . N}.{del(i) | i . \nN}.{reorder(f ) |.i . N.f(i) permutes {1,...,i}}.{fail} For compatibility with the generalization to \narbitrary containers in \u00a75, we slightly change the behavior of these operations from what we saw in \u00a72. \nInsertions and deletions are now always performed at the end of the list; to insert in the middle of \nthe list, you .rst insert at the end, then reorder the list. The argument i to ins(i) and del(i) the \nmapping lens has much better alignment information, so we eschew the more complicated retentive lenses \nin favor of simpler forgetful versions.  Figure 7. A consistent triple for the partition lens. now speci.es \nhow many elements to insert or delete. mod(p, dx) 8g x1 \u00b7\u00b7\u00b7 xn = x1 \u00b7\u00b7\u00b7 xp-1 (dxxp) xp+1 \u00b7\u00b7\u00b7 xn ins(i) \n8g x1 \u00b7\u00b7\u00b7 xn = x1 \u00b7\u00b7\u00b7 xn initX \u00b7\u00b7\u00b7 initX i times del(i) 8g x1 \u00b7\u00b7\u00b7 xn = x1 \u00b7\u00b7\u00b7 xn-i reorder(f) 8g x1 \n\u00b7\u00b7\u00b7 xn = xf(n)(1) \u00b7\u00b7\u00b7 xf(n)(n) fail 8g x1 \u00b7\u00b7\u00b7 xn unde.ned We take mod(p, dx) 8g x to be unde.ned when \np> |x|, and similarly take del(i) 8g x to be unde.ned when i> |x|. The list module is then X * = |X| \n* , e, (Glist) * , 8 . X Mapping lens The list mapping lens e * uses e to translate mod edits from X \nto Y and vice versa (Figure 4). Other kinds of edits (ins, del, and reorder) are carried across unchanged. \nThe notation c[p . c ' p] in the rule for mod edits means the list that is just like c except that the \nelement in position p is replaced by cp' . When translating non-modi.cation edits, we update the complement \nin a way almost identical to the way the two replicas are updated; to re.ect this similarity, we use \nedit application from the Unit * e.init.e.C module to de.ne the new complement. Partition lens Figures \n5 and 6 give the de.nition of a list parti\u00adtioning lens that (as we saw in \u00a72) separates a list of tagged \nele\u00adments into those tagged inl and those tagged inr. We write fail to stand for left(fail)right(fail) \nwhen de.ning = g. Additionally, as with the mapping lens, we consider the complement to belong to a module; \nthis time, to the module Unit * L.{L,R}. These .gures may be a bit intimidating at .rst, but there is \nnoth\u00ading very deep going on just some everyday functional program\u00adming over lists. To illustrate how \nit all works, let s consider a few example invocations of the partition lens. Each of them begins with \nthe consistent triple illustrated in Figure 7. Note that only the middle part the complement is actually \navailable to the partition lens as it runs: its other input is just an edit. As a warm-up, consider a \nsimple edit: changing Dvorak s name to Dvo.r\u00b4ak (with correct diacritics) in the left repository. The \nedit de\u00adscribing this has the form mod(5, stayL(dn)), where dn describes the string edit to the name. \nTo translate this edit, we .rst need to translate the index 5 to an index into the list of composers \nin the right-hand repository (line 5 in Figure 5). We can do this by simply counting how many composers \nappear up to and including Dvorak, that is, how many L values appear in the complement list up to in\u00addex \n5 in this case, 3. We then wrap this index up, along with the dn edit, in a new edit of the form left(mod(3, \ndn)); the comple\u00adment need not change because we have not changed the structure of the lists. This pattern \ncount to translate the index, then re-tag the edit appropriately can be generalized to all modi.cations \nthat stay on the same side of the sum; the count and tag functions de\u00ad.ned in Figure 6 implement these \ntwo steps. The left-to-right translation of other in-place modi.cations, in\u00adsertions, and deletions and \nthe right-to-left translation of in-place modi.cations, insertions, and deletions to either list are \nbuilt from the same primitives, using count to translate indices and re-tagging edits with tag. In a \nfew cases, we use some edit macros : since insertions and deletions always happen at the end of a list, \nwe write del ' and ins ' for edits that do some shuf.ing to ensure that the in\u00adserted or deleted element \nmoves to the appropriate position. Perhaps the most interesting of these is an in-place modi.cation to \nthe left repository that switches sides of a sum (line 4). For example, suppose we want to replace Beethoven \nwith Plato. The edit to do this has the form mod(2, switchLR(dn)) that is, at position 2, switch from \nan inl to an inr. Here, the translated edit must do four things: delete Beethoven from the left list, \ninsert a new element into the right list, re-tag dn so that it changes the new element to Plato, and \n.nally .x up the complement to match the new interleaving. As before, we can use count to translate the \nposition 2 in the interleaved list into a position in the left list in the right replica. But then we \nhit a minor snag: deletions only occur at the end of a list. The solution is to .rst reorder the list, \nso that Beethoven appears at the end, then delete one element. Figure 6 de.nes the cycle function, which \nconstructs permutations to do this reordering. The function cyclep(n) permutes lists of size n by moving \nposition p to the end of the list, and shifting all the other elements after p down one to .ll in the \nresulting hole. For example, cycle2(5) looks like this: p 12345 cycle2(5)(p) 13452 So, we can delete \nposition p by .rst reordering with reorder(cyclep), then deleting one element with del(1). The del ' \n(p) macro encap\u00adsulates this pattern; there is a similar pattern for inserting a new element at position \np encapsulated by ins ' (p). Finally, since posi\u00adtion 2 in the interleaved list corresponds to positions \n2 and 1 in the left and right non-interleaved lists, respectively, the .nal edit can be written as right(mod(1, \ndn)) right(ins ' (1)) left(del ' (2)). To .x up the complement, we can simply set the .ag at position \np to match the new tag: in our case, position 2 is now an inr, so we should set c2 = R. The most delicate \ncases involve translating reorderings. Con\u00adsider an edit to the right repository that swaps Schumann \nand Dvo\u00adrak. One way to write this edit is in terms of a function that swaps indices one and three for \nlists of size at least three (and does nothing on lists of size smaller than three): 4 - pn = 3 . p \n.{1, 3} f(n)(p)= p n< 3 . p/.{1, 3} The edit itself is then left(reorder(f )). Our job is now to com\u00adpute \nsome f ' for which reorder(f ' ) swaps inl(Schumann) and inl(Dvorak) in the left repository (line 14). \nThere is one wrinkle: f and f ' are parameterized by the length of the lists they permute. Translating \nf naively would therefore seem to require a way for f ' to guess the number of composers in lists whose \nlengths do not match that of the complement. Fortunately, f ' need only behave correctly for exactly \nthose lists that are consistent with the current complement, for which our guess about how many composers \nthere are is guaranteed to be accurate. So we need only construct a single permutation (and use, say, \nthe identity permutation for all in\u00adconsistent list lengths). We use the count function to construct \nthis permutation. It is convenient to derive an isomorphism between po\u00adsitions in the left repository \nand positions tagged by which list they are indexing into in the right repository; the iso function shows \nhow to use count to do this. In our example, the resulting isomorphism looks like this: left 123 45 right \ninl(1) inl(2) inr(1) inr(2) inl(3) We can use f(3) as a permutation on the inl elements, de.ning g(inl(p)) \n= inl(f(3)(p)) and g(inr(p)) = inr(p). Then, to .nd out  Figure 5: The partition lens tagof(inl(x)) \n= L mapf (e) = e . . p p < m = n tagof(inr(y)) = R mapf (cw) = f(c) mapf (w) cyclep(n)(m) = . m + 1 m \np = m < n otherwise lefts(e) = e lefts(inl(x)w) = x lefts(w) lefts(inr(y)w) = lefts(w) tag(L, dx) = left(dx) \ntag(R, dy) = right(dy) rights(e) = e rights(inl(x)w) = rights(w) rights(inr(y)w) = y rights(w) out(inl(x)) \n= x out(inr(y)) = y reverse(c1 \u00b7 \u00b7 \u00b7 cn) = cncn-1 \u00b7 \u00b7 \u00b7 c1 del ' (p) = del(1) reorder(cyclep) ins ' (p) \n= reorder(.n. cyclep(n)-1) ins(1) iso(c) = .p. let (nL, nR) = count(p, c) in inl(nL) cp = L count(p, \ne) = (1, 1) count(1, c) = (1, 1) inr(nR) cp = R count(p, c1 \u00b7 \u00b7 \u00b7 cn) = let (nL, nR) = count(p-1, c2 \n\u00b7 \u00b7 \u00b7 cn) in (nL + 1, nR) (nL, nR + 1) c = L c = R Figure 6: Supplementary functions for partition \nwhere position p in the left repository should come from, we can simply translate p into an index into \nthe right repository using iso, apply g to .nd out where that index came from, and translate back into \nthe left repository using iso-1. Expanding the table above with these translations yields: left 1 2 3 \n4 5 iso(left) inl(1) inl(2) inr(1) inr(2) inl(3) g(iso(left)) inl(3) inl(2) inr(1) inr(2) inl(1) iso-1(g(iso(left))) \n5 2 3 4 1 This swaps indices 1 and 5, so our .nal f ' looks like: ' 6 - pn =5 . p .{1, 5} f (n)(p)= \npn =5 . p/.{1, 5} Translating a reordering of the left repository follows a simi\u00adlar path (line 9): restrict \nthe reordering to lists consistent with the current complement, then compose the permutation with isomor\u00adphisms \nbetween the indices in the two repositories. There is one subtlety here: a reordering of the list in \nthe left repository may shuf.e which positions are inl s and which are inr s. As a result, we must take \ncare to construct two separate position isomorphisms: one for before the reordering, and one for after. \n5. Containers The list mapping lens from the previous section can be general\u00adized to a much larger set \nof structures, called containers, that also includes trees, labeled graphs, etc. We will also provide \na gen\u00aderal construction for reorganization lenses between different con\u00adtainer types (over the same type \nof entries). Together with composi\u00adtion and tensor product, this will provide a set of building blocks \nfor constructing many useful lenses. The reorganization lenses also fur\u00adnish further examples of lenses \nwith nontrivial complements. (Only a small part of \u00a76 depends on this material; it can safely be skimmed \non a .rst reading.) Containers were .rst proposed by Abbott, Altenkirch, and Ghani [1]. The idea is that \na container type speci.es a set I of shapes and, for each shape i, a set of positions P (i). A container \nwith entries in X and belonging to such a container type com\u00adprises a shape i and a function f : P (i) \n. X. For example, lists are containers whose shapes are the natural numbers and for which P (i)= {0,...,i-1}, \nwhereas binary trees are containers whose shapes are pre.x-closed subsets of {0, 1} * (access paths) \nand where P (i)= i itself. Even labeled graphs can be modeled using unlabeled graphs as shapes. One can \nfurther generalize the framework to allow the types of entries to depend on their position, but for the \nsake of simplicity we will not do so here. In the present context, containers are useful because they \nallow for the de.nition of a rich edit language, allowing the insertion and deletion of positions, modi.cation \nof particular entries, and reorganizations such as tree rotations. We can then de.ne lenses for containers \nthat propagate these general edit operations. In the case of state-based symmetric lenses [7], it has \nbeen ob\u00adserved that lens iterators akin to fold left for inductive data struc\u00adtures also permit the de.nition \nof powerful (state-based) lenses. In the edit-based framework iterators are less convenient because it \nis unclear how edits in an arbitrary module should be propagated to, say, list edits in such a way that \nthe rich edit structure available for lists is meaningfully exploited. (Of course, it is possible to \nprop\u00adagate everything to a rebuild from scratch edit, thus aping the state-based case.) In the following \nwe slightly deviate from the presentation of containers from [1, 7] in that we do not allow the set of \npositions to vary with the shapes. We rather have a universal set of positions P and a predicate live \nthat delineates a subset of P for each shape i. We can then obtain a container type in the original sense \nby putting P (i)= {p | p . live(i)}. Conversely, given a container type in the sense of [1], we can de.ne \nP = {(i, p) | p . P (i)}and live(i)= {(i, p) | p . P }. Furthermore, as we already did in [7], we require \na partially-ordered set of shapes I and ask that live be monotone. Formulating this in the original setting \nwould require a coherent family of transition functions P (i) . P (i ' ) when i = i ', which is more \ncumbersome. Another advantage of the present formulation of container types is that it lends itself more \neasily to an implementation in a programming language without dependent types. 5.1 De.nition: A container \ntype is a triple (I, P, live) comprising (1) a module I of shapes whose underlying set is partially ordered \n(but whose action need not be monotone); (2) a set P of positions; and (3) a liveness predicate in the \nform of a monotone function live . I .P(P ) which tells for each shape which positions belong to it. \nIf T = (I, P, live) is a container type and X is a set, we can form the set T (X) of containers of type \nT with entries from X by ) setting T (X)= i.I live(i) . X. Thus a container of type T and entries from \nX comprises a shape i and, for every position that is live at i i.e. every element of live(i) an entry \ntaken from X. Our aim is now to explain how the mapping X . T (X) lifts to a functor on the category \nof lenses i.e., for each module X, how to construct a module T (X) whose underlying set of states is \nthe set of containers T (|X|), and for each lens e . X . Y , how to construct a container mapping lens \nT (e) . T (X) . T (Y ). We will see that this mapping is well de.ned on equivalence classes of lenses \nand respect identities and composition. We begin by de.ning a module structure on containers. 5.2 De.nition: \nLet T = (I, P, live) be a container type. An edit di . .I is an insertion if dii = i whenever de.ned. \nIt is a deletion if dii = i whenever de.ned. It is a rearrangement if |live(dii)| = |live(i)| (same cardinality) \nwhenever de.ned. We only employ edits from these three categories as ingredients of con\u00adtainer edits; \nany other edits in the module will remain unused. This division of container edits into pure insertions, \ndeletions, and re\u00adarrangements facilitates the later de.nition of lenses operating on such edits. 5.3 \nDe.nition: If (I, P, live) is a container type, di . .I, and f . I . P . P , then we say f is consistent \nwith di if, whenever dii is de.ned, f(i) restricted to live(i) is a bijection to live(dii). A typical \ninsertion could be the addition of a node to a binary tree, a typical deletion the removal of some node, \nand a typical rearrangement the rotation of a binary tree about some node. 5.4 De.nition [Container edits]: \nGiven container T and module X we de.ne edits for T (|X|) as follows (we give some intuition after De.nition \n5.5): {fail}.{mod(p, dx) | p . P, dx . .X}.{ins(di) | di an insertion}.{del(di) | di a deletion}.{rearr(di, \nf) | f consistent with di} In the last case, often either di will only be de.ned for very few i or f \nwill have a generic de.nition, so the representation of a rearrangement edit does not have to be large. \n5.5 De.nition [Edit application]: The application of an edit to a container (i, f) is de.ned as follows: \n fail (i, f) is always unde.ned mod(p, dx)(i, f)=(i, f[p . dxf (p)]) when p . live(i) ins(di)(i, f )=(di \ni,f ' ) where f ' (p)= if p . live(i) then f(p) else initX del(di)(i, f)=(di i,fllive(dii)) rearr(di, \nf)(i, g)=(di i,g ' ) where g ' (p)= g(f(i)(p)) The mod(p, dx) edit modi.es the contents of position \np according to dx. If that position is absent the edit fails. The shape of the resulting container is \nunchanged. The ins(di) edit alters the shape by di, growing the set of positions in the process (since \ndii = i). The new positions are .lled with initX . The del(di) edit works similarly, but the set of positions \nmay shrink; the contents of deleted positions are discarded. The fail edit never applies and will be \nreturned pro forma by some container lenses if the input edit does not match the current complement. \nThe rearr(di, f) edit, .nally, changes the shape of a container but neither adds nor removes entries. \nAs already mentioned, a typical example is the left-rotation of a binary tree about the root. This rotation \napplies whenever the root has two grandchildren to the left and a child to the right. For this example, \none may worry about the size of f, since it affects many positions; however, it can be serialized to \na small, three line if-then-else. That we do not, at this point, provide edits that copy the contents \nof some position into other positions; their investigation is left for future work. We de.ne the monoid \n.T (X) as the free monoid generated by the basic edits de.ned above. In Section 6 we discuss the possibility \nof imposing equational laws, in particular with a view to compact normal forms of container edits. Setting \ninitT (X) =(initI , .p.initX ) when T = (I, P, live)completes the de.nition of the module T (X). 5.6 \nExample: For any module X we can construe the list module X * as a particular container type (I, P, live) \nwhere I = Nwith .I generated by i . Z with i 8 n = max(i + n, 0). Furthermore, P = Nand live(n)= {0,...,n \n- 1}. Then all list edits arise as speci.c container edits, however, the generic formulation of container \nedits also includes some esoteric edits, such as ins(10\u00b7(-10)) which brings a list to minimum length \n10 by appending default elements if needed. In Figure 8 we de.ne the mapping lens turning T (-) into \nan endofunctor on the category of lenses. We note that this is only the second lens to have a nontrivial \ncomplement (after partition). Given that this de.nition looks complex at .rst we state and prove explicitly \nthat it is indeed a lens. 5.7 Theorem: If T = (I, P, live) is a container and e is a lens so is T (e). \nMoreover, T (-) respects lens equivalence and preserves the identity lens and composition of lenses (up \nto equivalence), and thus de.nes a functor on the category of lenses. We can also de.ne a restructuring \nlens between containers of different container type but with the same type of entries, i.e. between T \n(X) and T ' (X) where T = (I, P, live) and T ' = (I ' ,P ' , live ' ). For this to be possible, we need \na lens e between I and I ' and for any triple (i, c, i ' ) . e.K a bijection fi,c,il . live ' (i ' ) \n. live(i). The complement of this lens consists of those triples (i, c, i ' ), and thus knows at any \ntime which bijection links the positions at either end. One typical instance of this kind of lens is \nlist reversal; another is a lens between trees and lists which ensures that the list entries agree with \nthe tree entries according to some .xed order, e.g. in\u00adorder or breadth .rst. Although the live positions \nof the containers to be synchronized are in bijective correspondence, there is e.g. in the case of list \nreversal no .xed edit that, say, a modify the  Figure 8: Generic container-mapping lens  Figure 9: \nContainer restructuring lens second position edit is mapped to. Indeed, the restructuring lens we are \nabout to construct can be seen as a kind of state-indexed isomorphism, but the full scaffolding of edit \nlenses is needed to make such a notion precise. We also require that e maps insertions to insertions, \ndeletions to deletions, and rearrangements to rearrangements. Note that this is well-de.ned on equivalence \nclasses of lenses. Given these data, we de.ne the restructuring lens in Figure 9, with a few supplementary \nde.nitions below. The families of bijec\u00adtions fi,fd,fr must be chosen in such a way that the container \nedits in which they appear are well-formed (this is possible since di ' is an insertion, deletion, or \nrestructuring as appropriate) and such that the following three constraints are satis.ed: in each case \ni, i ' , etc., refer to the current values from above and p . live ' (di ' i ' ) is an arbitrary position. \n fi(di ' i ' )(p)= f-1 ,dil il (p)) i,c,il (fdi i,cl when fdi i,cl ,dil il (p) . live(i) fd(di ' i ' \n)(p)= f-1 ,dil il (p)) i,c,il (fdi i,cl fr(di ' i ' )(p)= f -1 ,dil il (p))) i,c,il (f(i)(fdi i,cl The \npropagated edits are supposed to be applied to a container of the current shape i ', so these arbitrary \ndecisions do not really matter; nevertheless it would be nice if we could be a bit more uni\u00adform. This \nis indeed possible in the case where e is an isomorphism lens, but we refrain from formulating details. \nThe bijection fi contains a little more choice, namely the be\u00adhavior on the T ' positions in f-1 ,dil \nil (live(dii) \\ live(i)). For\u00ad di i,cl tunately, they all contain initX so that the choice does not affect \nthe resulting state after application of the edit. We illustrate the propagation of an ins(di) edit in \nthe particular case where we are synchronizing a tree with the list formed by its in-order traversal. \nThus, I = N; P = N; live(i)= {p | p<i}and I ' comprises pre.x closed subsets of {0, 1} * ; P ' = {0, \n1} * ; live ' (i ' )= i '. The monoid .I has increment and decrement op\u00aderations; the monoid .I ' has \noperations for adding and removing nodes in leaf positions and also for rotating tree shapes. The lens \ne . I . I ' does not know anything about the in\u00adtended application; it has a triv\u00adial complement Unit \nand merely maintains the constraint that the list shape and the tree shape have the same number of positions. \nIt has some freedom how it translates list edits; e.g., it might add and remove tree nodes at the left. \nThe family of bijections fi,c,il models the in-order correspondence; thus, for exam\u00adple if i =4 and i \n' = {e, 0, 1, 11} the bijection would be as shown above. (For illus\u00adtration we also indicate possi\u00adble \nX-contents of the positions.) Formally, we have fi,c,il = {(0, 0), (1,e), (2, 1), (3, 11)}. Now suppose \nthat dii = i +2 and that di ' (the result of di propagated through e) installs two children at the leftmost \nnode. In our in-order application we then have fdi i,cl ,dil il = {(0, 00), (1, 0), (2, 01), (3,e), (4, \n1), (5, 11)}and after applying both ins(di) and ins(di ' ) we are in the as-yet\u00adinconsistent situation \ndepicted above. To restore consistency we also apply rearr(1,fr) where fr(i ' )= {(00, 0), (0,e), (01, \n1), (e, 11), (1, 00), (11, 01)}. We could also have chosen fr(i ' )= {..., (1, 01), (11, 01)}; this is \nprecisely the additional freedom of choice. Of course fr(i '' ) for i '' = i ' is also completely uncon\u00adstrained. \nAfter applying rearr(1,fr) we end up with the desired consistent state. 6. Adding Monoid Laws The edit \nlanguages accompanying the constructions in the previous two sections were all freely generated. This \nwas a good place to begin as it is relatively easy to understand, but, as discussed in \u00a73, there are \ngood reasons for investigating richer languages. This section takes a .rst step in this direction by \nshowing how to equip the product and sum combinators with more interesting edits. Given modules X and \nY , there is a standard de.nition of mod\u00adule product motivated by the intuition that an edit to an |X|\u00d7|Y \n|value is a pair of an edit to the |X| part and an edit to the |Y | part. The monoid multiplication goes \npointwise, and one can de.ne an edit application that goes pointwise as well. X . Y = (|X|\u00d7|Y |, (initX \n, initY ),.X . .Y, 8X.Y ) 1M.N =(1M , 1N ) '' '' (m, n) \u00b7M.N (m ,n )=(mm ,nn ) (dx, dy) 8X.Y (x, y)=(dx \nx, dyy) One might wonder whether the standard de.nition has any con\u00adnection to the de.nition we give \nearlier. One way to bridge the gap is to add equational laws to the free monoid.5 The equations below \ndemand that left and right be monoid homomorphisms, and that they commute: left(1)= e left(dx)left(dx \n' )= left(dxdx ' ) right(1)= e right(dy)right(dy ' )= right(dydy ' ) left(dx)right(dy)= right(dy)left(dx) \n It is not hard to show that the free monoid subject to the above equations is isomorphic to the natural \nmonoid product. However, it is not obvious that the de.nitions relying on the free monoid product remain \nwell de.ned after imposing the above equations. In particular, we must check that any monoid homomor\u00adphisms \nwe de.ned respect these laws. For homomorphisms f spec\u00adi.ed via speci.cation of fg, it is enough to prove \nthat, for each equational law g = g ', the speci.cation respects the law i.e., f(g)= f(g ' ). For example, \nto check that we can create a well-de.ned tensor product module that includes the above equations, we \nmust show that 8g respects the equations. For the commutativity equation, we must show left(dx)8g right(dy)8g \n(x, y)= right(dy)8g left(dx)g 8g (x, y). Simple calculation shows that both sides are equal to (dx x, \ndy; y), so this law is respected; the rest follow similar lines. Most importantly, we must check that \nthe = and H functions are still monoid homomorphisms; indeed, this check makes these equations interesting \nas a speci.cation: in addition to the usual round-tripping laws we expect of state-based lenses, each \nnon\u00adtrivial equation in a monoid presentation represents a behavioral limitation on lenses operating \non that monoid. Take again the com\u00admutativity law: left(dx) right(dy)= right(dy) left(dx) The force \nof this law is that lenses operating on a monoid including this equation must ignore the interleaving \nof left and right edits: those two edits are treated independently by the lens. 6.1 Lemma: If k and e \nare lenses, then the = g and Hg functions de.ned above for k . e respect all of the above equations. \nAdding the .rst four equations lets us create a projection lens out of smaller parts by observing that \nthere are some new isomor\u00adphisms available. Let f be the isomorphism between X .Unit and 5 To make this \nformal, treat the equations as a relation between words in the free monoid; take the re.exive, symmetric, \ntransitive, congruence closure of this relation; and quotient by the resulting equivalence relation. \n X. Similarly, let g be the obvious isomorphism between Unit . Y and Y . We can then de.ne p1 =(idX . \ntermY ); isof and p2 =(termX . idY ); isog. Thus, p1 .rst throws away any infor\u00admation in the right-hand \npart of a tuple with termY , then collapses the (now degenerate) tuple with f. We conjecture that these \nadditional laws introduce enough isomorphisms that the tensor product gives rise to a symmetric monoidal \ncategory that is, that tuples may be reordered and re\u00adassociated freely, provided the lens program acting \non them is re\u00adordered and reassociated accordingly but we have not explored this possibility fully. We \ncan perform a similar process for sum edits. We add the following equations: switchjk(m) switchij (m \n' )= switchik(m) switchij (m) stayi(m ' )= switchij (m) stayj (m) switchij (m ' )= switchij (mm ' ) stayi(m) \nstayi(m ' )= stayi(mm ' ) dd ' = fail in all other cases This explains why we did not originally choose \nto have just two combinators, switchL and switchR, which would be interpreted as switch to the left (respectively, \nright) side and reinitialize, no matter which side we are currently on. The idea of the above equations \nis that they allow us to collapse any sequence of edits down into a single one; if we only allowed ourselves \nswitchL and switchR forms, this would not be possible. In particular, we need to represent the fact that \na stayL edit followed by a switchi edit fails when applied to a value tagged with inr. As with products, \nwe must check that the remaining de.nitions are well-formed. In particular, it can be shown that, in \nthe module de.ned above for sums, 8g respects the above equations, and that, if k and e are lenses, then \n(k . e).= g and (k . e).Hg respect the above equations. Unfortunately, the partition lens as given does \nnot respect the above equations. It seems possible to enforce them by also imposing equations on list \nedits that coalesce adjacent reorder operations. We leave this to future work. In a similar vein, we \ncan impose equations on container edits indeed, we need them, since we would like lists to form a special \ncase of containers so that, possibly after restructuring, we can partition and reassemble containers, \ntoo. These equations would in particular allow us to coalesce adjacent reorderings and to reorder insertions \nand deletions with other edits so that insertions and deletions always come .rst. This would also give \nrise to a compact normal form of container edits. Again, we leave this to future work. 7. From State-Based \nto Edit Lenses and Back In [7], we introduced a state-based framework for bidirectional transformations \ncalled symmetric lenses. We refer to them here as state-based symmetric lenses. Recall from [7] that \na state-based symmetric lens e between sets X and Y comprises a set of comple\u00adments C, a distinguished \nelement missing . C, and two functions putr . X \u00d7 C . Y \u00d7 C putl . Y \u00d7 C . X \u00d7 C satisfying the following \nround-tripping laws: putr(x, c)=(y, c ' ) (PUTRL) putl(y, c ' )=(x, c ' ) putl(y, c)=(x, c ' ) (PUTLR) \nputr(x, c ' )=(y, c ' ) Equivalence of state-based symmetric lenses is de.ned through the existence \nof a simulating relation between the respective comple\u00adment sets that relates the missing elements and \nis preserved by putl, putr. A characterization in terms of dialogues is also given. State-based symmetric \nlenses modulo equivalence form a category (they compose) and support a variety of constructions, in particular \ntensor product, sum, lists, trees, and container types. Now, for any set X we have the monoid .X whose \nelements (edits) are lists of elements of X modulo the equality xx = x. An action of .X on X is de.ned \nby ex = x and (xw)y = x where x . X, w . X *. Note that this is well de.ned as x(xy)= x = xy. If, in \naddition, we have a distinguished element x . X, we thus obtain a module denoted Xx where |Xx| = X and \ninitX = x and .Xx = .X. Let e be a state-based symmetric lens between X and Y along with elements x . \nX and y . Y satisfying e.putr(x, e.missing)= (y, e.missing). We then de.ne a symmetric edit lens .xye \nbe\u00adtween the modules Xx and Yy as follows: (1) (.xye).C = e.C; (2) (.xye).init = e.missing; (3) (.xye).=(e, \nc)=(e, c); (4) (.xye).=(xw, c)=(yv, c '' ) where (.xye).=(w, c)=(v, c ' ) and e.putr(x, c ' )=(y, c '' \n); (5) analogous de.nitions for H; and (6) K = {(x, c, y) | e.putr(x, c)=(y, c)}. .xye is a symmet\u00adric \nedit lens and the passage from e to .e is compatible with the equivalences on symmetric lenses and symmetric \nedit lenses.  Let X be a module. A differ for X is a binary operation dif . X \u00d7 X . .X satisfying dif \n(x, x ' )x = x ' and dif (x, x)= 1. Thus, a differ .nds, for given states x, x ', an edit operation dx \nsuch that dxx = x ' and dx is reasonable at least in the sense that if x = x ' then the produced edit \nis minimal, namely 1. For example, the module Xx for set X and x . X admits the canonical differ '' ' \n given by dif (x, x )= x if x = x and dif (x, x)= e, otherwise. Given an edit lens e between modules \nX and Y , both equipped with differs, we de.ne a symmetric lens |e| between |X| and |Y | by (1) |e|.C \n= |X|\u00d7 e.C \u00d7|Y |; (2) |e|.init =(initX , e.init, initY ); (3) |e|.putr(x, (x0, c, y0)) = (dyy0, (x, c \n' , dyy0)) where dx = dif (x0,x) and (dy, c ' )= e.=(dx, c); and (4) an analogous de.ni\u00adtion of |e|.putl \nThis de.nes a symmetric lens |e| between |X| and |Y |, and the passage e .|e| is compatible with lens \nequivalence. 7.1 Theorem: Let X, Y be sets with distinguished elements x and y and equip the associated \nmodules Xx and Yy with their canonical differs. The constructions |-| and .xy then establish a one-to-one \ncorrespondence between equivalence classes of edit lenses between Xx and Yy, on the one hand, and state-based \nlenses between X and Y , on the other. We conjecture that this isomorphism between state-based and certain \nedit lenses is also compatible with various lens constructors, in particular tensor product and sum. \n8. Related Work The most closely related attempt at developing a theory of update propagation is [4] \nby Diskin et al. Their starting point is the obser\u00advation (also discussed in [2]) that discovery of edits \nshould be de\u00adcoupled from their propagation. They thus propose a formalism, sd\u00adlenses, for the propagation \nof edits across synchronized data struc\u00adtures, bearing some similarities with our edit lenses. The replicas, \nwhich we model as modules, are there modeled as categories (pre\u00adsented as re.exive graphs). Thus, for \nany two states x, x ' there is a set of edits X(x, x ' ). An sd-lens then comprises two re.exive graphs \nX, Y and for any x . X and y . Y a set C(x, y) of cor\u00adrespondences which roughly correspond to our complements. \nFor\u00adward and backward operations similar to our H and = then com\u00adplete the picture. No concrete examples \nare given of sd-lenses, no composition, no notion of equivalence, and no combinators for con\u00adstructing \nsd-lenses; the focus of the paper is rather on the discovery of suitable axioms, such as invertibility \nand undoability of edits, and a generalization of hippocraticness in the sense of Stevens [13]. They \nalso develop a comparison with the state-based framework (cf. \u00a77 above). In our opinion, the separation \nof edits and corre\u00adspondences according to the states that they apply to or relate has two important \ndisadvantages. First, in our examples, it is often the case that one and the same edit applies to more \nthan one state and can be meaningfully propagated (and more compactly represented) as such. For example, \nwhile many of the container edits tend to only work for a particular shape, they are completely polymorphic \nin the contents of the container. Second, the fact that state sets are already categories suggests that \na category of sd-lenses would be 2-categorical in .avor, entailing extra technical dif.culties such as \ncoherence conditions. Meertens s seminal paper on constraint maintainers [10] dis\u00adcusses a form of containers \nfor lists equipped with a notion of edits similar to our edit language for lists, but does not develop \na general theory of edit-transforming constraint maintainers. A long series of papers from the group \nat the University of Tokyo [6, 8, 11, 12, 15, etc.] deal with the alignment issue us\u00ading an approach \nthat might be characterized as a hybrid of state\u00adbased and edit-based. Lenses work with whole states, \nbut these states are internally annotated with tags showing where edits have been applied e.g., marking \ninserted or deleted elements of lists. Barbosa et al. s matching lenses [2] offer another approach to \ndeal\u00ading with issues of alignment in the framework of pure state-based lenses. 9. Conclusion A prototype \nHaskell implementation of edit lenses is underway, as well as a demo showing how to construct GUIs connected \nby lenses. The main required extension to the theory presented here are extending the above constructions \nfrom algebraic data structures to strings, following Boomerang [3], and identifying good heuristics for \nconverting unstructured string edits into structured edits of the form expected by the lenses above a \nform of parsing and unparsing. Containers offer a convenient abstraction on which to build generic lens \ncombinators, as discussed in \u00a75. To use these com\u00adbinators in practice, we need to show how to instantiate \nthe module of shapes for the kind of container we are interested in, as we did for lists. In the future, \nwe would like to explore several other sorts of shapes; in particular, edit languages for graphs may \nbe useful in model-driven development, while edits for relations are relevant to database applications. \nAcknowledgments We are grateful to Nate Foster and Perdita Stevens for productive discussions of many \npoints, to the members of the Penn PL Club for comments on an early draft, to the organiz\u00aders and participants \nin the January 2011 Dagstuhl seminar on Bidi\u00adrectional Transformations for creating a stimulating environment \nfor work in this area, and to the POPL reviewers for their thoughtful suggestions. Our work has been \nsupported by the National Science Foundation under grants 0534592, Linguistic Foundations for XML View \nUpdate, and 1017212, Algebraic Foundations for Collabora\u00adtive Data Sharing. References [1] Michael Abbott, \nThorsten Altenkirch, and Neil Ghani. Containers: constructing strictly positive types. Theor. Comput. \nSci., 342(1):3 27, 2005. [2] Davi M. J. Barbosa, Julien Cretin, Nate Foster, Michael Greenberg, and Benjamin \nC. Pierce. Matching lenses: Alignment and view up\u00addate. In ACM SIGPLAN International Conference on Functional \nPro\u00adgramming (ICFP), Baltimore, Maryland, September 2010. [3] Aaron Bohannon, J. Nathan Foster, Benjamin \nC. Pierce, Alexandre Pilkiewicz, and Alan Schmitt. Boomerang: Resourceful lenses for string data. In \nACM SIGPLAN SIGACT Symposium on Principles of Programming Languages (POPL), San Francisco, California, \nJanuary 2008. [4] Zinovy Diskin, Yingfei Xiong, Krzysztof Czarnecki, Hartmut Ehrig, Frank Hermann, and \nFernando Orejas. From state-to delta-based bidirectional model transformations: The symmetric case. Technical \nReport GSDLAB-TR 2011-05-03, University of Waterloo, May 2011. [5] J. Nathan Foster, Michael B. Greenwald, \nJonathan T. Moore, Ben\u00adjamin C. Pierce, and Alan Schmitt. Combinators for bi-directional tree transformations: \nA linguistic approach to the view update prob\u00adlem. ACM Transactions on Programming Languages and Systems, \n29 (3):17, 2007. ISSN 0164-0925. Extended abstract presented at Prin\u00adciples of Programming Languages \n(POPL), 2005. [6] S. Hidaka, Z. Hu, K. Inaba, H. Kato, K. Matsuda, and K. Nakano. Bidirectionalizing \ngraph transformations. In ACM SIGPLAN Inter\u00adnational Conference on Functional Programming (ICFP), Baltimore, \nMaryland, September 2010. [7] Martin Hofmann, Benjamin C. Pierce, and Daniel Wagner. Symmetric lenses. \nIn ACM SIGPLAN SIGACT Symposium on Principles of Programming Languages (POPL), Austin, Texas, January \n2011. [8] Zhenjiang Hu, Shin-Cheng Mu, and Masato Takeichi. A pro\u00adgrammable editor for developing structured \ndocuments based on bi\u00addirectional transformations. In Partial Evaluation and Program Ma\u00adnipulation (PEPM), \npages 178 189, 2004. Extended version in Higher Order and Symbolic Computation, Volume 21, Issue 1-2, \nJune 2008. [9] David Lutterkort. Augeas: A Linux con.guration API, February 2007. Available from http://augeas.net/. \n[10] Lambert Meertens. Designing constraint maintainers for user interac\u00adtion, 1998. Manuscript. [11] \nShin-Cheng Mu, Zhenjiang Hu, and Masato Takeichi. An injective language for reversible computation. In \nSeventh International Confer\u00adence on Mathematics of Program Construction (MPC), 2004. [12] Shin-Cheng \nMu, Zhenjiang Hu, and Masato Takeichi. An algebraic approach to bi-directional updating. In ASIAN Symposium \non Pro\u00adgramming Languages and Systems (APLAS), pages 2 20, November 2004. [13] Perdita Stevens. Bidirectional \nmodel transformations in QVT: Seman\u00adtic issues and open questions. In International Conference on Model \nDriven Engineering Languages and Systems (MoDELS), Nashville, TN, volume 4735 of Lecture Notes in Computer \nScience, pages 1 15. Springer-Verlag, 2007. ISBN 978-3-540-75208-0. [14] Perdita Stevens. Towards an \nalgebraic theory of bidirectional transfor\u00admations. In Graph Transformations: 4th International Conference, \nIcgt 2008, Leicester, United Kingdom, September 7-13, 2008, Pro\u00adceedings, page 1. Springer, 2008. [15] \nYingfei Xiong, Dongxi Liu, Zhenjiang Hu, Haiyan Zhao, Masato Takeichi, and Hong Mei. Towards automatic \nmodel synchronization from model transformations. In IEEE/ACM International Conference on Automated Software \nEngineering (ASE), Atlanta, GA, pages 164 173, 2007.  \n\t\t\t", "proc_id": "2103656", "abstract": "<p>A lens is a bidirectional transformation between a pair of connected data structures, capable of translating an edit on one structure into an appropriate edit on the other. Many varieties of lenses have been studied, but none, to date, has offered a satisfactory treatment of how edits are represented. Many foundational accounts only consider edits of the form \"overwrite the whole structure,\" leading to poor behavior in many situations by failing to track the associations between corresponding parts of the structures when elements are inserted and deleted in ordered lists, for example. Other theories of lenses do maintain these associations, either by annotating the structures themselves with change information or using auxiliary data structures, but every extant theory assumes that the entire original source structure is part of the information passed to the lens.</p> <p>We offer a general theory of edit lenses, which work with descriptions of changes to structures, rather than with the structures themselves. We identify a simple notion of \"editable structure\"--a set of states plus a monoid of edits with a partial monoid action on the states--and construct a semantic space of lenses between such structures, with natural laws governing their behavior. We show how a range of constructions from earlier papers on \"state-based\" lenses can be carried out in this space, including composition, products, sums, list operations, etc. Further, we show how to construct edit lenses for arbitrary containers in the sense of Abbott, Altenkirch, and Ghani. Finally, we show that edit lenses refine a well-known formulation of state-based lenses, in the sense that every state-based lens gives rise to an edit lens over structures with a simple overwrite-only edit language, and conversely every edit lens on such structures gives rise to a state-based lens.</p>", "authors": [{"name": "Martin Hofmann", "author_profile_id": "81452607849", "affiliation": "Ludwig-Maximilians-Universit&#228;t M&#252;nchen, M&#252;nchen, Germany", "person_id": "P2991290", "email_address": "hofmann@ifi.lmu.de", "orcid_id": ""}, {"name": "Benjamin Pierce", "author_profile_id": "81100303310", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2991291", "email_address": "bcpierce@cis.upenn.edu", "orcid_id": ""}, {"name": "Daniel Wagner", "author_profile_id": "81458652419", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2991292", "email_address": "wagnerdm@cis.upenn.edu", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103715", "year": "2012", "article_id": "2103715", "conference": "POPL", "title": "Edit lenses", "url": "http://dl.acm.org/citation.cfm?id=2103715"}