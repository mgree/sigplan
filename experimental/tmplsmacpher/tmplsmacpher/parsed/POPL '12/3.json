{"article_publication_date": "01-25-2012", "fulltext": "\n Underspeci.ed Harnesses and Interleaved Bugs Saurabh Joshi Shuvendu K. Lahiri Akash Lal IIT Kanpur, \nKanpur, India Microsoft Research, Redmond, WA, Microsoft Research, Bangalore, India sbjoshi@cse.iitk.ac.in \nUSA akashl@microsoft.com shuvendu@microsoft.com Abstract Static assertion checking of open programs \nrequires setting up a precise harness to capture the environment assumptions. For in\u00adstance, a library \nmay require a .le handle to be properly initialized beforeitispassedintoit.Aharnessisusedtosetuporspecifythe \nappropriate preconditions before invoking methods from the pro\u00adgram.Inthe absenceofa precise harness,eventhe \nmost precise au\u00adtomated static checkers are bound to report numerousfalse alarms. This often limits the \nadoption of static assertion checking in the hands of a user. Inthiswork,weexplorethe possibilityof automatically \n.ltering away (or prioritizing) warnings that result from imprecision in the harness. We limit our attention \nto the scenario when one is interestedin .ndingbugsdueto concurrency.We de.neawarning tobe an interleavedbug \nwhen it manifests on an input for which no sequential interleaving produces a warning. As we argue in \nthe paper, limitinga static analysis to only consider interleavedbugs greatly reducesfalse positives \nduring static concurrencyanalysisin the presence of an imprecise harness. Weformalize interleavedbugs \nasadifferential analysis between the original program and its sequential version and provide various \ntechniques for .nding them. Our implementation CBUGS demon\u00adstrates that the schemeof .nding interleavedbugs \ncan alleviate the need to construct precise harnesses while checking real-life concur\u00adrent programs. \nCategories and Subject Descriptors D.2.4[Software Engineer\u00ading]: Software/ProgramVeri.cation General \nTerms Veri.cation, Reliability Keywords Concurrency veri.cation, differential analysis, static analysis,false \nalarms 1. Introduction Static analysis is concerned with the problem of .ndingbugs (or proving their \nabsence) in code without actually running the code. In this paper, we apply static analysis to open programs \nor libraries (i.e., programs that do not have a main procedure, but instead expose a set of API methods). \nIn such a setting, the user of static analysis has to provide a harness that invokes appropriate methods \nfrom the library. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page.To copyotherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. POPL 12, January 25 27, 2012, Philadelphia,PA, USA. Copyright c . 2012ACM 978-1-4503-1083-3/12/01... \n$10.00 Often times, the exercise of writing a correct harness is dif.cult and error prone when done manually. \nOne reason for this dif.culty is that the libraries usually have undocumented preconditions that mustbe \nsatis.ed beforeinvoking particular methods.For instance, before invoking a read operation on a .le, the \nlibrary may assume that .le handle is properly initialized. If one applies static analysis to such a \nlibrary without the precondition, the read operation can fail,andthe static analysiswill reportabug.However,thisdoesnot \nrevealanybuginthe implementationofthe library; instead,itonly reveals a problem with the harness that \nwas used to invoke the li\u00adbrary. Thus, no matter how precise the static analysis is, it is bound to reportfalse \nalarms while using underspeci.ed harnesses. In our experience,the problemoffalse alarms (including thosedueto \nun\u00adderspeci.ed harness) severely limits the adoption of static analysis tools that aim at checking user-de.ned \nassertions in programs. The problem of spurious warnings due to underspeci.ed har\u00adness does not get better \nwhile checking concurrent programs. How\u00adever, thereisavery natural option for prioritizingfalse alarmsin \norder to look for the more interesting warnings: Find violations to assertions assuming that the sequential \nexecutions of the concurrent program (under a correct har\u00ad ness) do not violate anyassertion. This assumption \nabout the sequential executions being safe may be justi.ed because a program is more likely to be thoroughly \ntested for interesting inputs rather than for different interleavings (as it is beyond the control of \na tester). This assumption immediately leads to pruning of the set of in\u00adputs to the program: if an input \ni fails an assertion in the program in a sequential interleaving, then it has to be an illegal input \n(that shouldhavebeen .lteredbya missing preconditioninthe harness). Hence, we are left to search for \nover the space of inputs for which no sequential execution violates an assertion. If an input in this \nspace violates an assertion, it has to manifest in a complex inter\u00adleaving of threads.We termbugs that \nmanifest on such inputs as interleavedbugs. The static analysis problem then becomes that of .nding interleavedbugs \ninsteadof .nding allbugs. Formally, a concurrent program P has an interleaved bug if some assertion in \nthe programfails for an input i for which no se\u00adquential interleaving of threads in P resultin an assertionfailure.1 \nInterleavedbugsmightstillbe spurious.However,wemakethefol\u00adlowing conjecture based on looking at a large \nnumber of spurious warnings: If an illegal input (due to an underspeci.ed harness) violates an assertion, \nthenit does soinafairly simpleexecution. More precisely, whenever an illegal input leads to an assertionfail\u00adure, \ntherewouldbeasequential interleaving witnessing thisfailure. 1We formally de.ne the notion of sequential \ninterleavings in\u00a74as one in which threads do not interfere with each other.  (It may be possible that \na concurrent execution on an illegal input fails; we are only claiming that in such a case, there would \nalso be somesequentialexecution thatfails.) Under this conjecture, most interleavedbugswould correspondtoreal \nerrors.Ourexperiments (\u00a75)support this conjecture: all interleavedbugs that we found were actualbugsin \nthe program. Although this result might not hold for all programs, it gives us greater con.dence that \nour approach re\u00adtains actual concurrency bugs. Note that our technique does not provide help when oneis \nlooking for sequentialbugs.We are only addressing the scenario when one is interested in .nding concur\u00adrencybugs,but \nstatic analysis resultsin manyfalse alarms. Let us contrast the approach of looking for interleaved bugs \nagainst two other incomparable approaches for .ltering warnings. One possibility is to .nd (a) the set \nS of warning locations (failing asserts) that manifest in sequential executions, and (b) the set C of \nwarning locations that manifest in concurrent executions, and only report the locations in the difference \nof C and S. This approach does not provide any guarantee on the absence ofbugs when the program has been \nsequentially veri.ed (unlike our approach). This is because the presence of a single illegal input that \ncan fail an assertion sequentially suppresses that assert, even when a legal input couldfail the same \nassert. Another approach is to suppress all the sequential traces that vi\u00adolate an assertion, and only \nreport those traces that have interleav\u00ading between threads. This may still report too manyfalse alarms \nit may report trivial interleavings that still transform the shared state in manner similar to some sequential \ninterleaving. An exam\u00adple of such a program is given in \u00a72.2.We believe that interleaved bugs achievesagood \ntrade-offfor suppressingfalse alarmsdueto underspeci.ed environment assumptions while not supressing \ntrue concurrencybugs. Inthis paper,wedevise algorithmsfor .nding interleavedbugs. We formalize the problem \nas a differential analysis of two pro\u00adgrams.For two programs P1 and P2, DIFFERROR(P1,P2) is the problem \nof .nding an input i such that P2 can fail when started with i butP1 cannot. In some sense, P1 acts as \na .lter for P2: run P2 on an input only when P1 doesn tfail on it. Let P be the concurrent program under \ntest. Let Ps be the same as P butexecutions ofPs are restricted to be sequential, i.e., Ps can have multiple \nthreads,butit does not interleave them.We formally describe how to capture Ps as a program in \u00a74. Then, \n.nding inter\u00adleavedbugsisthe sameas solvingDIFFERROR(Ps,P ). Although solving all instances of DIFFERROR \nis infeasible (it is undecid\u00adable), we provide techniques(\u00a73) that allow us to .nd interleaved bugs in \nmanyreal-world programs. We also show that one can choose various interestingunderap\u00adproximations of \nPs for the purpose of proving the absence of inter\u00adleavedbugs; thevarious choiceshave impact on the performance \nof the analysis. One technical complication is that DIFFERROR(P1,P2) is harder when the programs are \nnon-deterministic, i.e., when they have multiple possible executions for a given input. As with any static-analysis \ntool, non-determinism is unavoidable it comes comes from modeling of external calls as well as the thread \nsched\u00aduler.Wegive techniquesto handlethisdif.culty. We have implemented our algorithms for .nding interleaved \nbugsina tool calledCBUGSthat usesPOIROT[17], an SMT-based bug .nder,as the static analysis tool.WeevaluatedCBUGSon \n(real and concurrent)Windowsdevice drivers. Examplesoffalse alarms and realbugsin these drivers canbe \nfoundin \u00a72. This paper makes the following contributions: 1. Wede.ne interleavedbugs for assertion checking \nof concurrent programs(\u00a74), and illustrate its role in reducing false alarms due to underspeci.ed harnesses. \n2. We describe the problem of .nding interleaved bugs as an instance of the D IFFERROR problem for comparing \ntwo non\u00addeterministic programs with respect to a set of assertions, and various techniques for solving \nit(\u00a73). 3. Ourexperiments(\u00a75) show that CBUGS is able to remove all ofthefalse alarmsdueto missing preconditions,and \nretain true concurrencybugs.  The rest of the paper is organized as follows. In \u00a72, we present real-world \nexamples to justify our observation on underspeci.ed harnesses for concurrent programs. In \u00a73, we formalize \nthe more abstract problem DIFFERROR and present algorithms for solving it. In \u00a74, we applyDIFFERROR for \n.nding interleavedbugs, and discuss speci.c .lters and optimizations. In \u00a75, we evaluate our approach \nexperimentally. In \u00a76, we mention related work. 2. Motivation We motivate our work with a few real-world \nexamples of checking properties of concurrent programs, where (a) missing environment assumptions result \nin spurious warnings, (b) the spurious warnings often manifest in sequential traces, and (c) our technique \nonly reports true concurrencybugs without requiring the user to specify environment assumptions. 2.1 \nExample1 Figure 1 illustrates a simpli.ed version of a bug found by the STORM [15] tool in a Microsoft \nWindows device driver usbsamp [22]. This particular bug is an instance of use-after\u00adfree class of bugs \nwhere an object is accessed after it has been destroyed. The method UsbSamp EvtIoRead is a dispatch routine \nthat handles read requests sent to this driver denoted by the Request parameter. Among other things, \nthe method makes a call to WdfRequestMarkCancelable with the request and a cancel method UsbSamp EvtRequestCancel; \none of the side-effects of the call is to set a .eld Request->cancelRoutine to UsbSamp EvtRequestCancel. \nAfter this call, the cancel method may be called asynchronously on Request by the device driver to cancel \nthe request by invoking the Cancel routine. Similarly, the method WdfRequestUnmarkCancelable sets the \nRequest->cancelRoutine to NULL, disabling the cancel routine from being invoked. The request is completed \n(or destroyed) by a call to WdfRequestComplete method. The cancel method UsbSamp EvtRequestCancel accesses \n.elds in the request by a call to GetRequestContext. It is the responsibility of the driver developer \nto ensure that a request is not accessed after being completed. Several guide\u00adlines such as the following \nare provided for driver writers If a driver has called WdfRequestMarkCancelable, and if the driver s \nEvtRequestCancel callback function has not executed and called WdfRequestComplete, the driver must call \nWdfRequestUnmarkCancelable before it calls WdfRequestComplete outside of the EvtRequestCancel callback \nfunction. 2 The use-after-free property canbe modeledby(a) introducinga ghost .eld completed for each \nrequest; it is set to true bya call to WdfRequestComplete, and (b) guarding every access to a request \nRequest by the assertion assert(!completed(Request)). These assertions are implicitly present in this \nprogram be\u00adfore the calls to the methods WdfRequestMarkCancelable, WdfRequestComplete and GetRequestContext \nthat access .elds in Request. The routine Test is the harness (or the test driver); it invokes a set \nof procedure calls (in BODY:). Some of these procedures may 2http://msdn.microsoft.com/en-us/library/ff549983(v=VS.85).aspx \n 1 // Thread T1 1 // Thread T2 1 //Harness 2 VOID UsbSamp_EvtIoRead( 2 VOID UsbSamp_EvtRequestCancel( \n2 VOID Test( 3 ..., 3 WDFREQUEST Request 3 ..., 4 WDFREQUEST Request 4 ) { 4 WDFREQUEST Request 5) { \n5 PREQUEST_CONTEXT rwContext; 5 ) { 6 ... 6 ... 6 INIT: 7 WdfRequestMarkCancelable( 7 rwContext = 7 //assume(!completed(Request)); \n8 Request, 8 GetRequestContext(Request); 8 BODY: 9 UsbSamp_EvtRequestCancel); 9 ... 9 async UsbSamp_EvtIoRead(..., \nRequest); 10 ... 10 } 10 async Cancel(Request); 11 WdfRequestUnmarkCancelable( 11 11 } 12 Request); \n12 VOID Cancel(WDFREQUEST Request) { 13 ... 13 f = Request->cancelRoutine; 14 WdfRequestComplete(Request, \n14 Request->cancelRoutine = NULL; 15 status); 15 if (f) f(Request); 16 ... 16 } 17 } Figure 1. Strippeddownversionofabug \nfoundbySTORM [15]in the usbsamp device driver. The three columns show the two threads and the test driver \n(harness). be executed asynchronously by spawning new threads (using the async keyword). In addition \nto the method calls, the user has to additionally constrain the inputs to the methods. This can be done \nby either constructing objects that are passed on to the methods, or specifying some constraints on the \ninputs. The (commented out) assume statement in the test is one such constraint that has to be manually \nspeci.ed to model the environment assumptions for the open program. Let us understand the need for these \nassume statementsbylookingatthewarnings reportedbyaprecise analysis for this program. We describe an \ninterleaved trace by a sequence of events ...., (tidi, li ),...., where tidi .{1, 2,...} is a thread \nidenti.er and li is the line number of event. We sometimes avoid specify\u00ading all the events in the trace \nand specify only the end points of an uninterrupted context in each thread. 1. The trace .(1, 2), (1, \n7). would cause an assertion failure for the access to Request in WdfRequestMarkCancelable. However, \nthis is a spurious warning because the read routine is called with incomplete requests in anylegal execution. \n 2. The trace .(2, 13), (2, 15), (2, 7). is another spurious warn\u00ading that may happen if Request->cancelRoutine \nis set to UsbSamp EvtRequestCancel, and Request is completed in the input to Test. 3. The trace .(1, \n2), (1, 7), (2, 13), (2, 15), (1, 11), (1, 14), (2, 7). denotes a feasible trace that may cause the de\u00advicedriverto \naccessa completed requestinline7inthe second thread. Thiswas thebug reportedbyS TORM [15] and has been \n.xedin futureversionsof thedevice driver. Note that thebug manifests in a small window the instruction \n(2, 13) has to be executed between (1, 7) and (1, 11).  It is easy to observe the only the third warning \nis an interleaved bug, i.e. it cannot manifest on any sequential interleaving of the threads. On the \nother hand, the .rst two manifest in a sequential interleaving. Our method only reports the third alarm \n(without the needforenvironment assumptioninline7in Test that rules out the .rst two warnings), thereby \nreducing false alarms automatically. On the other hand, if we use a strategy to suppress any error location \nthat can fail sequentially, we will be unable to discover thisbug.  2.2 Example2 Figure2shows anotherexample \nwherefailureto specifyenviron\u00adment assumptions may cause large set of false alarms. The ex\u00adample is a \nsimpli.ed version of the serial device driver [22]. The example consists of two threads running two dispatch \nrou\u00adtines for write(SerialWrite) and read(SerialRead) respec\u00adtively. The PIRP structure denotes a pointer \nto an interrupt re\u00adquest packet (IRP) or a request, and we check a similar use-after\u00adfree property. The \nmain differences in this example are (1) the driver explicitly manipulates nested pointer .elds in the \nIRP (e.g. Tail.Overlay.CurrStckLoc in line 21 of SerialWrite), (2) the completion routine SerialCompleteRequest \nmay destroyall pointers reachable froma PIRP pointer that it completes. Unlikethe usbsamp driver in \u00a72.1, \nthe serial driver (an older driver) does not use much data abstraction mechanisms and often manipulates \ndeeply nested .elds makingit more challengingfor analysis.We have explicitly added the various assertions \nto model the use-after\u00adfree property. Ideally, a tool that analyzes the Test harness should report that \nthere are no assertion violations in this example. This is because for anyconcrete execution, the device \ndriver ensures the following precondition to Test:(a) the pointers reachable from each request are not \ncompleted, and (b) the two requests Irp1 and Irp2 are dis\u00adjoint, i.e., the set of pointers reachable \nfrom Irp1 and Irp2 do not overlap. It is not hard to see that in the absence of such assump\u00adtions, anytool \nwill yieldfalse alarms.Forexample, the sequential warning traces .(1, 9), (1, 14). and .(2, 9),..., (2, \n23). require a precondition that pointers reachable from Irp1 and Irp2 are not completed. Similarly, \nthe trace .(1, 9), (1, 29), (2, 9), (2, 23). requires that two requests have disjoint set of reachable \npointers. One approach taken in practice is to create fresh objects by in\u00advoking constructors; this ensures \nthat the set of pointers in two re\u00adquests are disjoint and not completed. However, this approach is not \nalways desirable for several reasons. First, a freshly created re\u00adquest packet may not represent the \nmostgeneral request packet and thereby provide poor coverage of the code it exercises. Secondly, in our \ncase the routines that createa request residesin thekernel and may not be invoked from the driver. Therefore, \na user of a tool is forced to write the environment assumptions as a non-trivial set of precondition \nconstraints in the INIT block (not shown here). Among the various preconditions, constraining the two \nrequests to be disjoint is quite cumbersome to express. Instead, our tool is able to automatically rule \nout all warn\u00adings because UsbSam EvtIoRead and UsbSam EvtIoWrite do not have any interleaved bugs. An \ninteresting fact about this example is that the false alarms manifest in both sequen\u00adtial orderings of \nthreads: SerialWrite;SerialRead as well as SerialRead;SerialWrite. This observation motivated our def\u00adinitionof \ninterleavedbugsgivenin \u00a74.  1 // Thread T1 1 // Thread T2 1 //Harness 2 VOID 2 VOID 2 VOID Test( 3 SerialWrite( \n3 SerialRead( 3 PDEVICE_OBJECT DO, 4 PDEVICE_OBJECT DO, 4 PDEVICE_OBJECT DO, 4 PIRP Irp1, 5 PIRP Irp \n5 PIRP Irp 5 PIRP Irp2 6) 6) 6) { 7 { 7 { 7 INIT: 888 9 PSERIAL_DEVICE_EXTENSION Extn = 9 PSERIAL_DEVICE_EXTENSION \nExtn = 9 BODY: 10 DO->DevExtn; 10 DO->DevExtn; 10 async SerialWrite(DO,Irp1); 11 struct _IO_STACK_LOCATION \n*csl; 11 struct _IO_STACK_LOCATION *csl; 11 async SerialRead(DO,Irp2); 12 12 12 } 13 ... 13 ... 14 assert(!completed(Irp)); \n14 assert(!completed(Irp)); 15 Irp->IoStatus.Status = 15 Irp->IoStatus.Status = 16 STATUS_SUCCESS; 16 \nSTATUS_SUCCESS; 17 17 18 ... 18 ... 19 assert(!completed(Irp)); 19 assert(!completed(Irp)); 20 csl = \n20 csl= 21 Irp->Tail.Overlay.CurrStckLoc; 21 Irp->Tail.Overlay.CurrStckLoc; 22 22 23 assert(!completed(csl)); \n23 assert(!completed(csl)); 24 if (csl->Parameters.Write.Length){ 24 if (csl->Parameters.Read.Length){ \n25 //put the write into a queue 25 //put the read into a queue 26 } else { 26 } else { 27 ... 27 ... \n28 assert(!completed(Irp)); 28 assert(!completed(Irp)); 29 SerialCompleteRequest(.., Irp, 0); 29 SerialCompleteRequest(.., \nIrp, 0); 30 } 30 } 31 } 31 } Figure 2. Simpli.ed example (from serial device driver) illustrating the \nneed for aliasing preconditions. The reader might argue that we are only looking for buggy traces that \nrequire an interleaving of actions from different threads. However, such a scheme will report numerous \nwarn\u00adings for this example. For instance, the assertion in line 23 can fail on many interleavings between \nthe two threads (e.g. .(1, 9), (2, 9), (2, 14),..., (1, 23).). This example may seem trivial from the \nperspective of concur\u00adrency analysis, but that is because we have omitted the synchro\u00adnization protocol \nthat guardsarequest among different threads.We usethisexampleonlytoshowthedif.cultyof understandingfalse \nalarms and writing preconditions to rule them out manually.  2.3 Non-deterministic .lters As noted earlier, \nwe .nd interleaved bugs using sequential inter\u00adleavings as .lters. However, the program that captures \nthese inter\u00adleavings may be non-deterministic, i.e., it may have multiple be\u00adhaviors for the same input \nstate. There are two main reasons for non-determinism in the .lter programs: Data non-determinism:The \nconcurrent program may havecalls toexternal libraries that are modeled non-deterministically.For example, \nin order to model GetTimeOfDay, one would write a model (or stub)that returnsany non-deterministically \nchosen time (possibly, in an increasing sequence). The sequential pro\u00adgram inherits these sources of \nnon-determinism.  Control non-determinism: As we illustrate in \u00a74, the program representing the sequential \ninterleavings may have a limited amount of non-determinism in scheduling. For example, the .lter used \nin \u00a72.2 has to capture scheduling either of the two threads .rst.  Oneofthemain technical challengesinthisworkistodealwith \nthese non-deterministic .lters. Therefore, we start by considering the problem of comparing two non-deterministic \nprograms in the next section(\u00a73). 3. Differential error checking In this section, we study the more abstract \nproblemDIFFERROR of comparing two (possibly non-deterministic) programs with respect to a set of assertions. \nIn \u00a74, we apply the results of this section towards .nding interleavedbugs. 3.1 Programs We consider \na simpli.ed syntax for imperative programs with shared-memory concurrency. We assume that there is a \nsingle globalvariable g of type T.Weintentionally leave T unde.ned.3We only requirethe presenceof certain \npredicatesover T. Let Failedbe a predicate of type T . Bool. A program is a list of procedure declarations. \nEach procedure takes a single variable of type T as input, returns a single variable of type T as output, \nand hasasingle statement.Aprogram statement st has the syntax: st ::= st; st (Sequence) | if (e) st else \nst (if-then-else) | while (e) do st (loop) | x := e (Assignment) | assume e (Assume) | assert e (Assert) \n| havoc x (Non-deterministic assignment) | call x := foo(e) (Procedure call) | return x (Procedure return) \n| async call foo(e) (Thread spawn) 3One can encode programs with multiple global variables into our syntax \nby simply considering T to be a vector of types.  Here e is an expression over variables in scope, using \nsome operators that we leave unde.ned. Semantics of our language is standard. The havoc x statement assigns \na non-deterministically\u00adchosen value to a variable x. An assume e statement blocks in a state when e \ndoes not hold, and has no effect otherwise. An assert e statementfailsina state when e does not hold, \nin which case the control jumps to the end of the program and the global variable g is modi.ed such that \nFailed(g) holds. (There is no other way for Failed(g) to hold.) An async call foo(e) statement spawns \na new thread that executes procedure foo with argument e. Even though we have de.ned a compact syntax, \nwe will still use C-like syntax for easy writingofexample programs.We will sometimes write x=* in place \nof havoc x Non-determinism in this language arises from two sources: the havoc statement induces data \nnon-determinism, whereas concur\u00adrency (via threads spawned by async statements) induces control non-determinism.Fortherestofthis \nsection,wedonot distinguish between these two sources of non-determinism. We identify a program with \nthe name of its main procedure. At anypoint in a program s execution, we refer to the value of vari\u00adables \nin scope as the program s state. In particular, the input and output state of a program is the value \nof global variable g at begin\u00adning and end of the main procedure of the program, respectively. Givena \nprogram P , let FP be its input-outputrelation:Wesay that (s, t) . FP if there is some execution of the \nprogram from input s that ends in a state t.Aprogram hasabuggyexecution on input s if (s, t) . FP for \nsome t and Failed(t) holds.  3.2 Problemformulation In this section, we describe the problem of differential \nerror (DIFFERROR)in more detail, along with different algorithms to solve it. We aim to solve DIFFERROR \nover two programs that ex\u00adpect the same input. Also, we assume that we are always given programs with \nassertions that capture the property of interest. The DIFFERROR problem can be formally de.ned as follows. \nDEFINITION 3.1 (DIFFERROR). Given two programs P1 and P2, DIFFERROR(P1,P2) holds if there exists an input \nstate s suchthat (1) there is some execution of P2 starting at s that violates an assertion and (2) no \nexecution of P1 on s can violate an assertion. We say thatP1 acts as an input-.lter for P2. Note that \nDIFFERROR is harder than standard veri.cation. Let .(x, y) be a formula in a decidable fragment of logic, \nsay quanti.er-free .rst-order logic with equality. Then we can reduce the satis.ability check of .x..y..(x, \ny) to the DIFFERROR prob\u00adlem as follows. Construct two programs P1 and P2 with a global variable x and \nlocal variable y in P1: P1() {havoc y; assert .(x, y); }P2() {assert false; } Then DIFFERROR(P1,P2) holds \nif and only if .x..y..(x, y) is true. Thus, even though verifying P1 and P2 individually is de\u00adcidable, \nDIFFERROR(P1,P2) is not (because checking the satis\u00ad.ability of quanti.ed .rst-order logic with function \nsymbols and equality is undecidable [3]). The next few subsections describe a few algorithms for solving \nthe DIFFERROR problem. In \u00a73.3, we consider the case when the .lter program is deterministic and terminating. \nIn \u00a73.4, we consider amethod for non-deterministic .lter programs; the method may not terminate for all \nprograms. Both these approaches(\u00a73.3 and \u00a73.4) use quanti.er-free reasoning of theorem provers. 3.3 \nDeterministic .lters When the program P1 is deterministic (i.e., given a .xed input, it has exactly one \nexecution) and terminating (i.e., given any input, the program either terminates orfails an assertionin \n.nite amount of time) then we have an easy way of solving DIFFERROR by re\u00adducing it to standard veri.cation. \nLet P1Assume be a program ob\u00adtained from P1 by replacing all assert e statements with assume e statements. \nConsider the program P ,showninFig.3, thatexecutes P1Assume and P2 on the same input. var g: T; Program \nP() { varg0:= g; call P1Assume(); g := g0; call P2(); } Figure 3. A program P constructed from two programs \nP1 and P2. Because we have replaced asserts by assumes in P1, the pro\u00adgram P1Assume will block on all \ninputs that cause P1 tofail. Con\u00adsequently, an execution of P on that input will not even reach the call \nto P2. Thus, P can onlyfail on some input i provided P1 does notfail on i and P2 fails oni, whichexactly \nsolvesDIFFERROR. THEOREM 3.2. For a deterministic program P1, the following statements are true: (a) \nif the program P inFig.3 fails on some input, then DIFFERROR(P1,P2) holds, and (b) if P1 is also termi\u00adnating \nand P does not fail any assertion, then DIFFERROR(P1,P2) does not hold. This theorem states that checking \nDIFFERROR can be reduced to checking assertions in a program and we can leverage standard veri.cation \ntechniques. Note that the requirement that P1 is deter\u00administic and terminating is important for this \ntheorem as the next example shows. Consider theexamplein Fig.4. P1 and P2 are twoprograms that take a \npointer p as input. The .nal assert in foo canfail because the programmer made a mistake: the operation \nin the else branch shouldbe subtraction, not addition.We assume that both programs have implicit assertions \nfor pointer dereferences, i.e., there is an assert (p != null) before any statement that dereferences \np. The intentionisto .ndabugin P2 that reveals that the assertion in the last line canfail. Static analysisof \nP2 can get distracted and report that the initial dereference p->x canfail when p == null. However, solving \nDIFFERROR(P1,P2) correctly guides us to the desiredbug. P1 will .lter out the input p == null because \nit can fail on that input. Note that Thm. 3.2 doesn t apply for this example because P1 is non-deterministic. \nIf we were to construct the program P as in Fig. 3, then P can still fail on input p == null. A similar \nargument holds when P1 is non-terminating.Forexample, consider a program P1 with a single statement assume \nfalse. This program neverfails, and should not .lter anyinput for P2. However, for the program P of Fig. \n3, it will block all input from reaching P2.  3.4 Non-deterministic Filters We now describe a technique \nfor solving DIFFERROR(P1,P2) that can handle non-deterministic .lter programs. However, the technique \nmayfail to terminate on all programs, even when both P1 and P2 are bounded-length programs. First, note \nthat the constructionof Fig.3is usefuleven when the .lter program P1 is not deterministic(but terminating) \nbecause then P necessarily fails less often than P2. More speci.cally, P does not fail on those inputs \non which P1 deterministically fails (i.e.,everyexecution of P1 fails). Hence, we can always replaceP2 \nby P .  P1 P2 struct ST *p; struct ST *p; void bar() { int t; havoc t; if(t) { p->x = 0; } } void foo() \n{ int x; p->x = 0; if(p->y > p->x) { t = p->y -p->x; } else { t = p->x + p->y; } assert(t >= 0); } Figure \n4. Anon-deterministic .lter program. Algorithm1 Algorithm for solvingD IFFERROR Require: Programs P1 \nand P2 1: loop 2: r1 :=FINDBUG(P2) 3: if r1 =NOBUG then 4: return NOBUG 5: end if 6: LetTRACE(t, i)= \nr1 7: r2 :=FINDBUG(P1, i) 8: if r2 :=NOBUG then 9: return r1 10: end if 11: LetTRACE(t ' ,i)= r2 12: \n. := pre(Determinize(t ' ), true) 13: P2 := assume \u00ac.; P2 14: end loop Our algorithm is shown in Alg. \n1. It uses a static-analysis tool, which we callFINDBUG.We assume thatFINDBUG,givena pro\u00adgram with assertions, \neither returnsNOBUG(meaning that the pro\u00adgram has nobugs) or returnsTRACE(t, i), meaning that the pro\u00adgram \ncan fail on input i and t is the execution trace witnessing thatfailure.A trace consistsofa sequenceof \nprogram statements (inthe orderin whichtheygotexecuted),alongwithvaluesofvari\u00adablesateachpointinthe trace.FINDBUGcanalsobe \nsuppliedwith an input, in which case it only checks the program under that input. Alg.1returnsits outputinthe \nsame formatasFINDBUG:it returns NOBUG if there is no input for which DIFFERROR(P1,P2) holds; or returns \nTRACE(t, i) such that DIFFERROR(P1,P2) holds and t is an execution of P2 thatfails on input i (but P1 \ndoes notfail on input i). The algorithm works by iteratively .ltering away more and more inputs.Ifit \n.ndsabugin P2 (line 2), then it checks to see if P1 hasabug on the same input i (line 7). If P1 doesn \nt, then it returns this input (line 9). If P1 doeshaveabug, then i needs to be .ltered.For this,it usesa \nmodi.cationof the trace t ' itself to create a deterministic .lter f (line 12) that .lters out i as well \nas other inputs that cause P1 tofail along the trace t '. In some sense, f acts asa sub-.lter that .lters \nout some of the input that causes P1 tofail. The procedure Determinize(t ' ) takesa trace t ' and performs \nthe following modi.cation to it it replaces the havoc x statements with x := c, where c is the concrete \nvalue assigned to x in the trace. The predicate transformer pre(t, .) takes a trace t (a sequence of \nstatements) and a formula . and returns a formula representing the path condition in terms of the inputs \nto the trace. It is de.ned inductively on the structure of the trace as follows (note that Determinize \nremoves havoc statements from the trace): pre(skip,.)= . pre(assume ., .)= . . . pre(assert ., .)= \u00ac. \n. . pre(x := e, .)= .[e/x] pre(s; t, .)= pre(s, pre(t, .)) Fig.5(a)showsanexampleofa trace thatfailsthe \nassertion in P1 in Fig. 4.For the statement havoc t, we indicate the value (say, 5)assigned tot in the \ntrace. Fig.5(b) shows the formula . constructed in line 12, which is equivalent to p == null. havoc t; \n// 5 assume t != 0; (5 != 0 &#38;&#38; p == null) assert p != null; (a) (b) Figure 5. (a) A trace through \nP1 from Fig. 4 and (b) the corre\u00adsponding formula. The mostexpensivepartsinAlg.1 sloop arethe callstoFIND-BUG. \nOne can optimize these calls in cases when FINDBUG is in\u00adcremental.Forinstance,thecallsonline2always \ncontainsthesame program pre-pended with an increasing list of assume statements. The calls on line7 are \nto the same programbut with different in\u00adputs. Thus, anyinformation that FINDBUG infers about P1 or P2 \ncan be retained across iterations. THEOREM 3.3. The following statements are true. (a) If Alg. 1 returns \nNOBUG, then DIFFERROR(P1,P2) does not hold, and (b) if Alg.1 returns TRACE(t, i) then DIFFERROR(P1,P2) \nholds and input i and trace t are the witnesses. Alg.1isnot guaranteedto terminate(evenfor bounded-length \nprograms), which is expected because D IFFERROR is undecidable in general. However, it does terminate \nfor bounded-length pro\u00adgrams with bounded non-determinism.Formally, non-determinism in a program is bounded \nif for anynon-deterministic choice value v in the program, v only appears in expressions of the form \nv .c, where . .{=, =,<} and c is a constant. This subsumes the case when v is Boolean, i.e., v .{true, \nfalse}.We did not come across unbounded non-determinism in our experiments. Consider the example in Fig. \n6, where the hashFunc is a procedurewithcomplexoperationstocomputethehashvalueofan input. It is not hard \nto see that DIFFERROR(P1,P2) does not hold for thisexample.However,Alg.1willdivergeby enumeratingall \nthe possiblevaluesofthe non-deterministic choiceof i in P1. (The variable j in P1 is not necessary for \nthe divergence.) Thereareseveralwaystoextendour approachtodealwithsuch cases, at the cost of predictability. \nA natural extension is to set a bound k on the number of times a source of non-deterministic values participates \nin Determinize during the execution of Alg. 1. After this threshold is exceeded, we perform pre(, ) on \nthe trace t ' directly insteadof determinizing it.Weextend pre(, ) for havoc statements: pre(havoc x,.)= \n.x. . This results in quanti.ed .lters in line 13 of Alg. 1.For the above example with k =0, we will \ngenerate the .lter: \u00ac(.i, j :: j . =0 .\u00aca[i] = 0) If FINDBUG is able to reason about such quanti.ers, \nthen we will be abletoprovethatDIFFERROR(P1,P2) does not hold for thisex\u00adample. However, if FINDBUG is \nunable to reason precisely about these quanti.ers, then Alg. 1 may diverge enumerating the same path \nin P1. For example, if FINDBUG is an SMT-based theorem prover, the quanti.ed veri.cation condition generated \nmay not be  void P1(int a[], int b){ int i = *; void P2(int a[], int b){ int j = *; int i = hashFunc(b); \nif (j != 0) assert a[i] >= 0; assert a[i] >= 0; } } Figure 6. Example where Alg.1diverges. amenable \nto the trigger-based schemes for instantiating quanti\u00ad.ers in most SMT solvers [7] there is no good \ntrigger for the bound variable j in the formula above (this is the reason why j is present in P1).The \naboveformulawould need some simpli.cations (e.g. quanti.er elimination) in conjunction with quanti.er \ninstan\u00adtiations.We also presentavariantof this ideain AppendixAthat instead producesaquanti.ed formulato \nprecisely describe whether DIFFERROR(P1,P2) holds for bounded programs, and then hands it offto a theorem \nprover. The main difference is that it pushes the divergence from within Alg.1to within the theorem prover. \n4. Interleavedbugs We now return to the topic of .nding interleaved bugs for con\u00adcurrent programs in \nthe presence of underspeci.ed harnesses.We start by de.ning the problem formally, show how it can be \ncast as aDIFFERRORproblem, and then describeafew optimizations spe\u00adci.c to our setting. Let P be a concurrent \nprogram with dynamic thread creation (using async statements). We de.ne a non-interleaved program execution \ntobe one that hasa single-threadofexecution.Formally, anon-interleavedexecution, whileexecuting threadT1,follows \none of two possibilities at an async statement that spawns thread T2: T1 waits for T2: The spawned thread \nT2 executes immediately and T1 waits until T2 and anythread spawnedby T2 completes. Additionally, while \nT2 is executing, any async call must follow this same option. In some sense, the async call acts like \na synchronous procedure call.  T2 waits for T1: The spawned thread T2 does not execute until T1 .nishes. \nWhen T1 .nishes,anyofthe threadsspawnedbyit can start executing.  Let FP seq beasubsetof FP such that \n(s, t) . FP seq if and only if (s, t) . FP and thereis some non-interleavedexecutionof P from input s \nthat ends in state t. Our intuition is that assertion violations resulting from illegal inputs will often \nmanifest in non-interleaved executions. Thus, theywill be captured in FP seq . DEFINITION 4.1 (Interleavedbug). \nA program P has an inter\u00adleavedbugifthereisapairof states (s, t) . FP suchthatFailed(t) ' ) . F seq ' \nholds and for all (s, t P ,Failed(t ) does not hold. We .nd interleavedbugs usingDIFFERROR. THEOREM 4.2. \nGiven two concurrent programs P and Q the F seq following statements are true. (i) If FQ . P and DIFFERROR(Q, \nP ) does not hold, then P has no interleavedbugs. (ii) If FP seq . FQ and DIFFERROR(Q, P ) holds, then \nP has an interleavedbug. Thm. 4.2 suggests that it suf.ces to work with underapproxi\u00admations of FP seq \nwhile proving the absenceof interleavedbugs and overapproximations of FP seq while proving the presence \nof inter\u00adleavedbugs. In \u00a74.1 and \u00a74.2, we de.ne under-approximate .lters as programs. In \u00a74.3, we de.ne \nthe program that captures F seq pre- P cisely. In each case, we de.ne the .lter using a syntactic program \ntransformation, and the resultant .lter is a sequential program. void AsyncAsEventsOrGeneral(args) { \nEventSet = new MultiSet<Event>(); EventSet.Add(new Event(main, args)); while(!EventSet.empty()) { let \n(f,e) = EventSet.GetAny(); f(e); } } Figure 7. Entry procedure for AsyncAsEvents and AsyncGeneral.  \n 4.1 Filter: AsyncAsSync The .lter program AsyncAsSync always chooses the behavior where the async statement \nis treated as a synchronous procedure call that executes immediately. This corresponds to the .rst option \ninthe de.nitionof non-interleavedexecutions.Theuseofthis .lter is desirableasitcanleadtoadeterministic.lteriftheprogramdoes \nnot make use of data non-determinism (or the non-determinism does not in.uence the assertions). This \n.lter can be obtained from P simplybyreplacing all async calls with normal procedure calls. The program \nshown in Fig. 1 uses this .lter to remove all non-interleavedbugs. 4.2 Filter: AsyncAsEvents The .lter \nprogram AsyncAsEvents explores all behaviors in which spawned threads are delayed until the parent thread \n.nishes. This corresponds to the second option in the de.nition of non\u00adinterleaved executions. We capture \nthis .lter as an event-driven program. Note that an async call, in this case, is like posting an event \nthat has to be processed when the current event .nishes. This behavior is typical of event-driven programs. \nLet main be the entry procedure of P . Let EventSet be a multiset of events, where each event is a function \npointer along with its arguments. The .lter has the entry procedure shown in Fig. 7. It initializes the \nset of events with the main procedure and then executes an arbitrary event from EventSet in a loop. Events \nare added to the set by executing a async statement; the following transformation is applied to each \nasync statement: async foo(e) .. EventSet.Add(new Event(foo, e)) It is easy to see that a spawned thread \ndoes not execute until the parent thread .nishes. There are several existing analyses of event-driven \nprograms. Theworkby Sen andViswanathan [18] discusses the complexity of analyzing such programs. Jhala \nand Majumdar [13] present a software-model-checking approach, and Emmi et al. [10] present an underapproximate \nSMT-based analysis. A real-world example where this .lter is required is described in \u00a75.1.2. In our \nexperi\u00adments, we use a tool based on the approach of Emmi et al. [10]. Remark. When the concurrent program \nP has synchro\u00adnization (e.g., thread join operations) then it is possible that AsyncAsEvents may deadlock. \nThis is acceptable in our setting becausewedonot consider deadlockstobebugs.  4.3 Filter: AsyncGeneral \nThe AsyncGeneral .lter programexplores all non-interleavedex\u00adecutions. Such a program can have strictly \nmore behaviors than bothpreviousoptionsput together.Thisis becauseitallowsanexe\u00adcution to follow the \n.rst option (in the de.nition of non-interleaved executions) in some places and to follow the second \noption in other places.  NTSTATUS IoCreateDevice(..., OUT PDEVICE_OBJECT *DeviceObject) { PDEVICE_OBJECT \ndeviceObject; int x = nondet(); if (x == 0) { // Allocate device deviceObject = (PDEVICE_OBJECT) malloc(sizeof(DEVICE_OBJECT)); \n... *DeviceObject = deviceObject; return STATUS_SUCCESS; }else if(x==1){ // Fail return STATUS_INSUFFICIENT_RESOURCES; \n}else if(x==2){ // Fail return STATUS_OBJECT_NAME_EXISTS; } else ... } Figure 8. Stub for IoCreateDevice. \nLet main be the entry procedure of P . Let EventSet be as de\u00ad.ned in \u00a74.2. The AsyncGeneral .lter has \nthe same entry pro\u00adcedure as AsyncAsEvents. The difference is in the transforma\u00adtion of async statements. \nWe add a Boolean variable First to AsyncGeneral, initialize it to false, and then carry out the fol\u00adlowing \ntransformation: async foo(e) .. if(First) {foo(e); } else if(nondet()) {First = true; foo(e); First = \nfalse; } else {EventSet.Add(new Event(foo, e)); } The variable First is true when we have decided to \nexecute a spawned thread immediately. In this case, anyrecursively spawned thread must also be executed \nimmediately. When First is false, we non-deterministically decide between two options: execute the thread \nimmediately or delay it until the current thread .nishes. 4.4 Non-determinism The .lters de.ned in previous \nsections have multiple sources of non-determinism (which justi.es our interest in non-deterministic .lters). \nThe main source of non-determinism is from the environ\u00adment. As for any static analysis tool, one has \nto close the pro\u00adgram by writing stubs for the environment (such as the opera\u00adtion system). These stubs \nover-approximate the environment and are inherently non-deterministic. For instance, in order to model \nIoCreateDevice system call in Windows4, we used the stub shown in Fig. 8. It can non-deterministically \nchoose to allocate the device objectorfailand return oneofa.xed numberof error codes. These stubs were \ncreated for an earlier study on static analysis; we did not modify them. Another source of non-determinism \nis in modeling the .lters themselves. Both AsyncAsEvents and AsyncGeneral have non\u00addeterminism in the \norder in which they pick events. The .lter AsyncAsSync does not add any extra non-determinism. The stub \nin Fig. 8 and the .lter structure both induce a bounded amount of non-determinism, which is suitable \nfor our 4http://msdn.microsoft.com/en-us/library/ff548397(v=vs.85).aspx int x; void bar(int *p) { void \nmain(int *p) { L1: x = 0; if(nondet()) { async foo(); if(x == 1) x = 2; async bar(p); if(x == 3) } L2: \n*p = 10; void foo() { } else { if(x==0)x=1; L3: *p=5; if(x==2)x=3; } }} Figure 9. Example to show incompleteness \nof the optimization. lazy algorithm (\u00a73.4). However, some stubs have unbounded\u00adnondeterminism.For instance, \nthe stub that we use for malloc is one that can return anyaddress which has not been previously allo\u00adcated. \nHowever, such unboundedness has never been a problem in our experiments. One reason could be that programs \n(and, conse\u00adquently,bugs)do not rely on the actual addressvalues.  4.5 Optimizations For the purpose \nof .nding interleaved bugs, we have a special instance of D IFFERROR(P1,P2), namely one in which FP1 \n. FP2 .Inthis setting,we can optimizeAlg.1byavoidingafew calls toFINDBUG. More concretely, let (t, i) \nbe as de.ned on line 6 of Alg. 1. Then t isa concurrentexecution, possibly with manythreads.We can permute \nstatements in t such that the resulting trace conforms to the .lter in use, and then check the feasibility \nof the resulting trace.Forexample, let t have two threads T1 and T2, and consists of statements executed \nin the following order: t =(a1; a2; a3; b1; b2; a4; a5; b3; b4; a6;) where the ais refer to statements \n.red by T1, and the bis refer to statements .red by T2. Further, let a3 be the statement that spawns \nthread T2. Let t1 and t2 be the following permutations of statements in t: t1 =(a1; a2; a3; b1; b2; b3; \nb4; a4; a5; a6;) t2 =(a1; a2; a3; a4; a5; a6; b1; b2; b3; b4;) Then t1 conforms to AsyncAsSync, t2 conforms \nto AsyncAsEvents, and both conform to AsyncGeneral. Suppose we are using AsyncAsSync as the .lter, and \nt1 happens to be feasible on input i (i.e., i satis.es pre(t1, true)), then we can let r2 be TRACE(t \n' ,i) and jump to line 11, thereby avoiding the call to FINDBUG on line 7. In general, there are many \nways to permute a given concurrent trace to make it correspond to a .lter. In our implementation we try \na few permutations. If any of these work, thenwe canavoidacalltoFINDBUG. Note that this optimization \ndoes not work the other way. Con\u00adsider the example shown in Fig. 9, where every dereference is im\u00adplicitly \nprotected by a null-pointer assertion. It has an execution thatfails on line L2 that requires four context \nswitches and no se\u00adquential permutationofthisexecutionis feasible.However,we can\u00adnot conclude that theexecutionis \nan interleavedbug because there is a sequential execution on the same input (but takes a different pathduetothe \nnon-determinismatL1)thatfailsatlabelL3. 5. Evaluation We implementedAlg.1(mentionedin\u00a73) on concurrent \nprograms inatool calledCBUGS.It.rst usesthe AsyncAsSync .lter. If it does not .ndbugsin the presenceof \nthis .lter, thenit stops. Otherwise, it uses the AsyncGeneral .lter and reports resultingbugs as inter\u00adleavedbugs. \nThe use of AsyncAsSync is an optimization because it is easier to analyze than AsyncGeneral. CBUGS uses \nPOIROT as the tool for .ndingbugsin concurrent programs, i.e.,POIROT acts asFINDBUG inAlg.1.POIROT is \noneofthebug-.nding toolsfor concurrent programs that uses iterative context-bounding to look forbugs[6,15, \n17].  We conducted experiments to evaluate CBUGS on two goals. First, can CBUGS rule out bugs caused \nby illegal input, while retaining the true bugs? Second, we compare CBUGS against a different .ltering \nstrategy, namely one that .lters based on asserts. In this strategy, if a sequential trace leads to an \nassertion violation, then we remove that assertion and repeat until no more warnings are produced. 5.1 \nResults We chose a collection of Windows device drivers from the WinDDK suite [22] for conducting experiments. \nSome of these drivers were manually seeded withbugsby othersin an indepen\u00addent study.To the best of our \nknowledge, these are the onlybugs presentin the code.We suf.x the driver name with bug when ithasa (single) \nseededbug.Thisallowsusto conducta controlled study. None of the drivers have a precise harness. We checked \nthe Cancel property (mentioned in \u00a72) as well as for null-pointer dereferences ( NullDeref ). The results \nare re\u00adported in Fig. 10. Each row of this table has: the name of the driver (Name); the number of non-empty \nnon-assert lines of code exer\u00adcised by tool (LOC) along with the number of assertions shown in parenthesis; \nthe property being checked (Prop.); and the type of bug present in the code (either none or interleaved \nor sequen\u00adtial ). The next column (#LF) is the number of iterations of Alg. 1, i.e., the number of lazy \n.lters generated by CBUGS. The rest of the columns show the number of false positives (#FP) and false \nnegatives (#FN) of the two approaches and the total time taken to generateallthewarnings (barringthe \nmanualeffortof classifyinga warning asa true orfalse positive). WheneverCBUGS used Async-General for \ngenerating a lazy .lter, we mention it in the (#LF) col\u00adumn with AG . For instance, the .rst row is for \nthe daytona driver with the cancel property.Thedriverdoesnothaveanyactualbugs,however, whenwe run static \nanalysis(FINDBUG),it reportsawarning(false positive) because of the imprecise harness. CBUGS, on the \nother hand, suppresses this warning automatically (it generates one lazy .lter). Our experiments show: \n(1) CBUGS does not report any false positives, whereas the assert suppression technique reported 63 false \npositives;(2) CBUGSdidnotmissanyofthe interleavedbugs, whereas assert suppression missed one in mouclass \nbug2;(3) the use of AsyncAsSync is a useful optimization and is enough to rule outfalsewarningsin most \ncases. Asexpected,CBUGS also ends up suppressing true sequentialbugs,however,it demonstratesgood results \nfor catching concurrencybugs. We now explain some of the results in more detail, to illustrate the need \nfor AsyncGeneral and the kinds of preconditions that these drivers required. 5.1.1 Cancel Property on \nndisprot The existing harness for the ndisprot device driver (for the Can\u00adcel property) added two preconditions: \n(1) a particular lock must be initialized, and (2) a doubly-linked list (of requests) is empty. Althoughthe.rstisavalid \nprecondition,the secondoneisthesim\u00adplestwayto establishthe actual preconditions:(a)the incoming re\u00adquest \ndoes not belong to the list, and (b) the list is well-formed dou\u00adbly linked list that respects the relationships \nbetween the forward and the backwards links. Unless the latter is enforced, the pointer manipulations \nperformed to insert or delete an element of the list doesnothavethe desiredeffects.Boththese preconditionsarevery \nhardtoexpressforlow-levelCprograms,evenfor bounded lists. void ReadFn(PIRP irp) { if(irp->b) { void CancelFn(PIRP \nirp) {*irp->ptr = 10; irp->cancel = true;} } if(irp->cancel) { Foo(irp); void Test(PIRP irp) {} async \nReadFn(irp);} async CancelFn(irp);void Foo(PIRP irp) { } *irp->ptr = 10; } Figure 11. Example of null-dereference \nchecking on daytona driver. Every dereference of a pointer has an implicit non-null check preceding it. \nHowever, by limiting the input to contain an empty list, most of the interesting logic related to list \ntraversal in the code does not get exercised. There are three versions of this driver, depending on which \ndispatch routine is chosen(read, write, or ioctl). In the ab\u00adsence of preconditions, we get false alarms \nin each of the three versions, whereas CBUGS does not report any false alarms. For read, CBUGS requires \nthe use of AsyncGeneral .lter.With Asyn\u00adcAsSync alone,it reportsafalse alarm where the input listis not \nwell-formed. This example shows that in the presence of compli\u00adcated preconditions, one needs AsyncGeneral, \nalthough at the ex\u00adpense of more runtime.  5.1.2 Null-Dereference Checking We also checked several drivers \nfor the absence of null\u00addereferences. Each pointer dereference was preceded with a non\u00adnull assertion.AsshowninFig.10,this \nproperty introducedalarge number of assertions in the program. Fig.11showsanexample (motivatedby daytona)that \nrequires the AsyncGeneral .lter to remove thefalse alarms. The harness Test needs the preconditions that \nboth irp and irp->ptr are non-null, to ensure that the concurrent program does notfail any assertions. \nIt is easy to observe that the illegal inputs where irp is nullfailsbyexecuting ReadFn(irp) sequentially, \nand is, thus, .ltered away by AsyncAsSync. Consider the non-null check for the dereference *irp->ptr. \nIf we restricttheexecutionsof Test to only consider AsyncAsSync, the *irp->ptr is dereferenced only when \neither irp->b or irp->cancel is set in the input. This implies that using the AsyncAsSync .lter will \ngenerate failure traces where the body of CancelFn is executed before the test on irp->cancel inside \nReadFn. However, using the AsyncGeneral .lter, we can defer ReadFn to execute after CancelFn has executed, \nthereby failing the assertion on anyinput.Asimilar situation requires the use of AsyncGeneral for the \nexample in \u00a72.2. 6. Related work In this paper, we presented an approach for reducing false alarms due \nto underspeci.ed environments during static assertion checking in concurrent programs, by using the sequential \nbehaviors as an oracle. We position our work in the context of previous work in each of the italicized \nareas in the next few subsections. 6.1 Filtering static analysis alarms Engleretal.[11] proposea methodof \ndiscoveringbugsby observ\u00ading inconsistent behavior in source code. Dillig et al. [9] provide a semantic \nbasis for .nding such inconsistent behaviors by posing the problem as a type-inference problem. Both \nthese approaches have been applied to .nd null dereference errors in large sequential codebases. These \nwork can also be seen as .ltering false alarms if usage is consistent with some (unknown) protocol; e.g., \nif all dereferences of a variable x is not protected by a null-check, the accesses to the variable is \nmost likely safe due to some invariant in the program. One can think of interleavedbugs as discovering \ninconsistencies (with respect to a given set of assertions), where the sequential behaviors describe \nan implicit protocol. On the other hand, unlike these approaches, we do not require a separate analy\u00adsis \nfor different patterns and provide a formal guarantee of relative correctnessif there are no interleavedbugs. \n Name LOC Prop. Buggy? CBUGS Assert Supression (Asserts) #LF #FP #FN Time #FP #FN Time daytona 485 (10) \nCancel No 1 0 0 122 1 0 17 daytona bug1 484 (10) Cancel Seq. 2 0 1 136 1 0 21 daytona bug2 485 (10) Cancel \nInt. 1 0 0 110 1 0 34 daytona bug3 484 (10) Cancel Seq. 2 0 1 161 3 0 41 daytona bug4 485 (10) Cancel \nSeq. 2 0 1 162 1 0 19 daytona bug5 485 (10) Cancel Int. 1 0 0 126 1 0 29 ndisprot read 588 (35) Cancel \nNo 10 (AG) 0 0 2894 3 0 38 ndisprot write 588 (35) Cancel No 4 0 0 217 1 0 15 ndisprot ioctl 588 (35) \nCancel No 7 0 0 424 1 0 32 mouclass bug1 582 (19) Cancel Seq. 10 0 1 905 4 0 131 mouclass bug2 582 (19) \nCancel Int. 10 0 0 944 3 1 186 daytona 485 (223) NullDeref No 13 (AG) 0 0 459 3 0 43 kbdclass read 695 \n(346) NullDeref No 1 0 0 227 11 0 846 kbdclass ioctl 695 (346) NullDeref No 1 0 0 229 10 0 737 mouclass \nread 582 (271) NullDeref No 1 0 0 98 10 0 965 mouclass ioctl 582 (271) NullDeref No 1 0 0 91 9 0 918 \nFigure 10. Results obtained from runningCBUGS onWindowsdevice drivers.Times arein seconds.  Approaches \nfor suppressing or ranking warnings have ranged from statistical techniques (such as Z-ranking [14]) \nto more domain speci.c methods (such as suppressing data-racewarnings [21]). Al\u00adthough these approaches \nare applied to the results of static analyses that scale to large modules, theydo not provide anyformal \nguar\u00adantees of thebugs that are suppressed. Besides, most of these ap\u00adproaches are aimed at combating \nthe imprecision of static analysis, as opposed to the environment problem.  6.2 Sequential .lters The \nidea of using sequential behaviors as oracle for concurrent im\u00adplementations has been studied in the \ncontext of checking lineariz\u00adability [12], whichprovidesanatural speci.cationin manysettings for checking \nconcurrent programs.Various static and dynamic tools have been built to check concurrent behaviors against \nsequential ones. LINEUP is a dynamic analysis tool that .ags a concurrent behavior when it outputs a \nvalue that no sequential execution pro\u00adduced [4]. Burnim et al. [5] provide runtime techniques to check \nparallel implementations against non-deterministic sequential spec\u00adi.cations. Siegel et al. [19] employsymbolic \nexecution along with enumeration of interleavings to check against the sequential behav\u00adiors for numerical \nprograms. Unlike these approaches, we consider thedualproblemwhen speci.cationsare presentinthe programbut \nthe environment is imprecise. Because we check for user-speci.ed assertions, we can apply the technique \nto anyconcurrent program even if it is not linearizable.  6.3 Environment synthesis Generating environments \nfor model checking of open systems is a well-studied problem. Tkachuk et al. [20] generate environment \nmodels from user-speci.ed assumptions and by analyzing envi\u00adronment implementations. Alur et al. [1] \naddress the problem of synthesizing the most liberal environment using a combination of predicate abstraction \nand automata learning. One can view our ap\u00adproach as inferring the most liberal environment that does \nnot in\u00adduce failures on sequential executions, and using it to check the concurrent program. As demonstrated \nin \u00a75, inferring legal envi\u00adronment preconditions may involve inferring complex aliasing re\u00adlationships \non the input data that may not be amenable to .nite\u00adstate approaches. Nonetheless, it would be interesting \nto combine synthesis techniques with our algorithm. 7. Conclusion Inthispaper,we highlighttheproblemoffalsealarmsinstaticanal\u00adysisdueto \nmissingenvironment assumptionsand presentasolution when checking assertionsin concurrent programs.Wede.neaclass \nofwarnings as interleavedbugs when they are retainedbya .lter that attributesallwarningsinthe sequential \ninterleavingstothe un\u00adderspeci.ed harness (or to missing preconditions).We believe this can be an effective \nway to prioritize high quality warnings when looking at warnings generated by a static analyzer for concurrent \nprograms. Our preliminary experience with a simple implementa\u00adtion to .nd interleaved bugs is encouraging, \nalthough we expect more work to deal with unbounded non-determinism in the .lter programs. More generally, \nthe paper makes one of the .rst contributions to the area of using semantic techniques for prioritizing \nalarms from static analysis. Sequential .lters are natural .lters when prioritiz\u00ading alarms for concurrency \nanalysis.We believe that one canex\u00adtend this idea to use artifacts other than sequential executions in \nthe source code to automatically de.ne .lter programs for other domains as well. Acknowledgments WethankTom \nBall, Sriram Rajamani and the anonymous reviewers for theirfeedback on an earlier draft.We thank Madan \nMusuvathi for pointingusto similaritieswithworkonusing sequentialexecu\u00adtions as oracles for concurrent \nmodules. Finally,we thank Zvonimir Rakamaric and Shaz Qadeer who wrote many of the concurrent harnesses \nfor the device drivers, which served as a starting point for our experiments.  References [1]R.Alur,P.Cern\u00b4y,P. \nMadhusudan,andW.Nam. Synthesisof interface speci.cations for java classes. In Principles of Programming \nLan\u00adguages (POPL 05), pages 98 109, 2005. [2] M. Barnett andK.R.M. Leino.Weakest-preconditionof unstructured \nprograms. In Program AnalysisFor SoftwareTools and Engineering (PASTE 05), pages 82 87, 2005. [3] E.B\u00a8adel, \nandY. Gurevich. The Classical Decision Prob\u00ad orger, E. Gr\u00a8 lem. Springer-Verlag, 1997. [4]S. Burckhardt,C.Dern,M. \nMusuvathi,andR.Tan. Line-up:a com\u00adplete and automatic linearizability checker. In Programming Lan\u00adguage \nDesign and Implementation (PLDI 10), pages 330 340, 2010. [5]J.Burnim,T.Elmas,G.C.Necula,andK.Sen.Ndseq: \nruntimecheck\u00ading for nondeterministic sequential speci.cations of parallel correct\u00adness. In Programming \nLanguage Design and Implementation (PLDI 11), pages 401 414, 2011. [6] L. Cordeiro and B. Fischer. Verifying \nmulti-threaded software using smt-based context-bounded model checking. In International Confer\u00adence \non Software Engineering (ICSE 11), pages 331 340, 2011. [7] D. Detlefs, G. Nelson, and J. B. Saxe. Simplify: \na theorem prover for program checking. J.ACM, 52(3):365 473, 2005. [8] E. W. Dijkstra. Guarded commands, \nnondeterminacy and formal derivation of programs. Communications of the ACM, 18:453 457, 1975. [9] I. \nDillig,T. Dillig, and A. Aiken. Static error detection using seman\u00adtic inconsistency inference. In Programming \nLanguage Design and Implementation (PLDI 07), pages 435 445, 2007. [10] M. Emmi, S. Qadeer, and Z. Rakamaric. \nDelay-bounded scheduling. In Principles of Programming Languages, pages 411 422, 2011. [11]D.R.Engler,D.Y.Chen,andA.Chou.Bugsas \ninconsistentbehavior: Ageneral approach to inferring errors in systems code. InSymposium on Operating \nSystems Principles (SOSP 01), pages 57 72, 2001. [12] M. Herlihyand J. M.Wing. Linearizability:Acorrectness \ncondition for concurrent objects. ACMTrans.Program. Lang. Syst., 12(3):463 492, 1990. [13] R. Jhala and \nR. Majumdar. Interprocedural analysis of asynchronous programs. In Principles of Programming Languages, \npages 339 350, 2007. [14] T. Kremenek and D. R. Engler. Z-ranking: Using statistical analysis to counter \nthe impact of static analysis approximations. In Static Analysis Symposium (SAS 03), LNCS 2694, pages \n295 315, 2003. [15] S. Lahiri, S. Qadeer, and Z. Rakamaric. Static and precise detection of concurrency \nerrors in systems code using SMT solvers. In Computer AidedVeri.cation, 2009. [16]K.R.M.Leino,T.D. Millstein,andJ.B.Saxe. \nGenerating error traces from veri.cation-condition counterexamples. Sci. Comput. Program., 55(1-3):209 \n226, 2005. [17] Poirot: The Concurrency Sleuth. http://research.microsoft. com/en-us/projects/poirot/. \n[18]K.SenandM.Viswanathan. Model checking multithreaded programs with asynchronous atomic methods. In \nComputer AidedVeri.cation, pages 300 314, 2006. [19] S. F. Siegel, A. Mironova, G. S. Avrunin, and L. \nA. Clarke. Using model checking with symbolic execution to verify parallel numerical programs. In International \nSymposium on SoftwareTesting and Anal\u00adysis (ISSTA 06), pages 157 168, 2006. [20] O. Tkachuk, M. B. Dwyer, \nand C. S.Pasareanu. Automated environ\u00adment generation for software model checking. In Automated Software \nEngineering (ASE 03), pages 116 129, 2003. [21] J.W.Voung, R. Jhala, and S. Lerner. Relay: static race \ndetection on millions of lines of code. In Symposium onFoundations of Software Engineering (ESEC/SIGSOFT \nFSE 07), pages 205 214, 2007. [22] Microsoft windows driver kit (WDK). http://www.microsoft. com/whdc/devtools/ddk/default.mspx. \nA. Quanti.ed VC generation In this section, we describe a method for generating a (quanti.ed) veri.cation \ncondition (for bounded-length programs) in the pres\u00adence of non-deterministic and possibly non-terminating \n.lter pro\u00adgrams. Recall that the goal of DIFFERROR(P1,P2) is to .lter anyin\u00adput i, such that there is \nsome choice of the non-deterministic val\u00adues in P1 that fails P1. This implies that the non-determinism \nin P1 is angelic (in contrast to the demonic nondeterminism in P2). One option is to extend our language \n(in \u00a73.1) to introduce a statement choose x (in addition to havoc x), to model the an\u00adgelic non-determinism. \nAnd then create a program similar to one described in Fig. 3, where we replace the havoc x statements \nin P1 with choose x statements, in addition to the transformation of the assert e statements. However, \nwe are not aware of any ef.cient veri.cation con\u00addition (VC) generation algorithm in the presence of \nsuch non\u00addeterminism. Let us highlight one of the main dif.culties of ex\u00adtending VC generation algorithms \nwith choose statements. Most ef.cient VC generation algorithms (see [2]) generate a formula whose size \nis at most quadratic in the size of the program. This is achieved by using a variant of static single \nassignment, where auxiliary variables are introduced to hold different incarnations of a program variable \nafter an assignment, a havoc statement, or at merge points. These variables are implicitly universally \nquan\u00adti.ed in the resultant VC (when checking for validity). The pres\u00adence of choose statements introduces \nan existential quanti.er (e.g. wlp(choose x,.)= .x.., whereas wlp(havoc x,.)= .x.., where wlp(., .) refers \nto weakest liberal precondition predicate transformer[8]).This interactsbadlywiththeuseof auxiliaryvari\u00adables \nin the VC, as determining quanti.cation(. vs. .)of a partic\u00adular variable and the nesting can be challenging. \nInstead, we present (in Alg. 2) a VC generation mechanism for DIFFERROR that leverages off-the-shelf \nVC generation along with symbolic execution along error paths, to lazily add the quanti.er alternation. \nThe idea is simple: we enumerate all the program paths in P1 that lead to an assertion violation, and \ncreate an expression (purely in terms of the inputs to P2) that characterizes all the conditions under \nwhich P1 fails.We generateaVC for P2 using anyoff-the-shelf VC generation technique after blocking all \nthese inputs. The formula . represents the set of inputs for which there is a choice of the non-deterministic \nvalues such that an assertion in P1 fails. Similarly, the setA represents a set of paths in P1 that lead \ntoan assertion violation. Thesevariables are initializedto false and {} respectively (line1and line 2). \nThe loop from line3to line 11 enumerates different paths in P1 thatfail an assertion.We use an oracle \nFINDBUG (in line 4) that takes as arguments (i) a program and a (ii) set of paths and .nds an error trace \nthat avoids the set of paths speci.ed, or NOBUG therwise (indicating that there are no bugs). FINDBUG \ncan be implemented by augmenting VC genera\u00adtion to avoid a set of paths while checking assertions [16]. \nOnce all the error paths have been explored, the algorithm computes the VC for P2 after blocking all \nthe inputs in . using assume \u00ac. (line 6). Otherwise, for a given error r, we extract the error trace \nt and the input i and update A and . respecively (line9and line 10). The predicate transformer wlp(., \n.) is extended for havoc state\u00adments: pre(havoc x,.)= .x. . Observe that pre(t, true) is a formula whose \nfree variables are inputs to P1, and can be massaged to a formula of the form .x1,...,xk.. ', where . \n' is a ground formula, after renaming the bound variables introduced due to havoc to avoid variable capture. \n Algorithm2 Algorithm for generatingaVC forDIFFERROR Require: Programs P1 and P2 Ensure: Aformula representing \ntheVC forDIFFERROR(P1,P2) 1: . := false 2: A := {} 3: loop 4: r :=FINDBUG(P1, A) 5: if r =NOBUG then \n6: return VC(assume \u00ac.;P2.body) 7: end if 8: LetTRACE(t, i)= r 9: A := A .{t} 10: . := . . pre(t, true) \n11: end loop THEOREM A.1. Given programs P1 and P2, if . be the formula returnedbyAlg.2, then DIFFERROR(P1,P2) \nholds if and only if . is satis.able. It is interesting to note that the theorem above holds even when \nthe .lter program P1 does not terminate on some inputs this is because we only enumerate paths in P1 \nthat lead to an assertion violation.For instance,ifwe considerthe non-terminatingexample from \u00a73.3, where \nP1 was simplyassume false,then we will not .nd anybugs in P1, and Alg.2will simply return theVCof P2. \nConsider the example in Fig. 6, where the hashFunc is a procedure with complex operations to compute \nthe hash value of an input. It is not hard to see that DIFFERROR(P1,P2) does not holdforthisexample.However,Alg.1willdivergebyenumerating \nall the possible values of the non-deterministic choice of i in P1 . Instead, Alg.2 generates the following \nprecondition to P2 by capturing all the inputs thatfail P1 : \u00ac(.i, j :: j . =0 .\u00aca[i] = 0) which is equivalent \nto .i :: a[i] = 0, and suf.cient to prove the assertion in P2 for anyimplementation of hashFunc. Although \nthe algorithm presented here generates a precise VC for the DIFFERROR problem, the undecidable nature \nof the DIFFERRORproblem precludes anyalgorithm to solveall instances of the problem. The algorithm presented \nhere may not be complete due to the incompleteness of automatic theorem provers to deal with quanti.ersinthe \nresultingVC.Forexample,the quanti.edVC generated may not be amenable to the trigger-based schemes for \nin\u00adstantiating quanti.ers in most SMT solvers [7] there is no good trigger for the bound variable j \nabove. The above formula would need some simpli.cations (e.g. quanti.er elimination) in conjunc\u00adtion \nwith quanti.er instantiations. Nevertheless, by translating the DIFFERROR(P1,P2) to a logical formula, \nwe can hope to leverage advances in automated theorem provers to obtain more precise and ef.cient solution \nforDIFFERROR(P1,P2).    \n\t\t\t", "proc_id": "2103656", "abstract": "<p>Static assertion checking of open programs requires setting up a precise harness to capture the environment assumptions. For instance, a library may require a file handle to be properly initialized before it is passed into it. A harness is used to set up or specify the appropriate preconditions before invoking methods from the program. In the absence of a precise harness, even the most precise automated static checkers are bound to report numerous false alarms. This often limits the adoption of static assertion checking in the hands of a user.</p> <p>In this work, we explore the possibility of automatically filtering away (or prioritizing) warnings that result from imprecision in the harness. We limit our attention to the scenario when one is interested in finding bugs due to concurrency. We define a warning to be an interleaved bug when it manifests on an input for which no sequential interleaving produces a warning. As we argue in the paper, limiting a static analysis to only consider interleaved bugs greatly reduces false positives during static concurrency analysis in the presence of an imprecise harness.</p> <p>We formalize interleaved bugs as a differential analysis between the original program and its sequential version and provide various techniques for finding them. Our implementation CBugs demonstrates that the scheme of finding interleaved bugs can alleviate the need to construct precise harnesses while checking real-life concurrent programs.</p>", "authors": [{"name": "Saurabh Joshi", "author_profile_id": "81543070556", "affiliation": "IIT Kanpur, Kanpur, India", "person_id": "P2991329", "email_address": "sbjoshi@cse.iitk.ac.in", "orcid_id": ""}, {"name": "Shuvendu K. Lahiri", "author_profile_id": "81100338283", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2991330", "email_address": "shuvendu@microsoft.com", "orcid_id": ""}, {"name": "Akash Lal", "author_profile_id": "81384603991", "affiliation": "Microsoft Research, Bangalore, India", "person_id": "P2991331", "email_address": "akashl@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103662", "year": "2012", "article_id": "2103662", "conference": "POPL", "title": "Underspecified harnesses and interleaved bugs", "url": "http://dl.acm.org/citation.cfm?id=2103662"}