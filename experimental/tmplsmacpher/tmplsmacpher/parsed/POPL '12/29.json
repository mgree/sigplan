{"article_publication_date": "01-25-2012", "fulltext": "\n Algebraic Foundations for Effect-Dependent Optimisations Ohad Kammar Gordon D. Plotkin Laboratory forFoundations \nof Computer Science School of Informatics, University of Edinburgh, Scotland ohad.kammar@ed.ac.uk gdp@ed.ac.uk \nAbstract We present a general theory of Gifford-style type and effect anno\u00adtations, where effect annotations \nare sets of effects. Generality is achieved by recourse to the theory of algebraic effects, a develop\u00adment \nof Moggi s monadic theory of computational effects that em\u00adphasises the operations causing the effects \nat hand and their equa\u00adtional theory. Thekey observation is that annotation effects can be identi.ed \nwith operation symbols. Wedevelop an annotatedversionofLevy sCall-by-Push-Value language with a kind \nof computations for every effect set; it can be thought of as a sequential, annotated intermediate language. \nWe develop a range of validated optimisations (i.e., equivalences), generalising many existing ones and \nadding new ones.We classify these optimisations as structural, algebraic, or abstract: structural optimisations \nalways hold; algebraic ones depend on the effect theory at hand; and abstract ones depend on the global \nnature of that theory (we give modularly-checkable suf.cient conditions for their validity). Categories \nand Subject Descriptors D.3.4[Processors]: Compil\u00aders; Optimization; F.3.1[Specifying and Verifying and \nReasoning about Programs]: Logics of programs; F.3.2[Semantics of Pro\u00adgramming Languages]: Algebraic \napproaches to semantics; Deno\u00adtational semantics; Program analysis; F.3.3[Studies of Program Constructs]:Type \nstructure General Terms Languages, Theory. Keywords Call-by-Push-Value, algebraic theory of effects, \ncode transformations, compiler optimisations, computational effects, de\u00adnotational semantics, domain \ntheory, inequational logic, relevant and af.ne monads, sum and tensor, type and effect systems, uni\u00adversal \nalgebra. 1. Introduction In Gifford-style type and effect analysis [27], each term of a pro\u00adgramming \nlanguage is assigned a type and an effect set. The type describes the values the term may evaluate to; \nthe effect set de\u00adscribes the effects the term may cause during its computation, such as memory assignment, \nexception raising, or I/O. For example, consider the following termM: if true then x := 1 else x := deref(y) \nPermission to make digital or hard copies of all or part of this work for personal or classroomuseisgrantedwithout \nfeeprovidedthat copies arenot madeordistributed forpro.torcommercialadvantage andthatcopiesbearthisnoticeandthefullcitation \nonthe .rstpage.To copy otherwise,to republish,topostonserversorto redistribute tolists, requirespriorspeci.cpermission \nand/ora fee. POPL 12, January25 27,2012, Philadelphia,PA,USA. Copyright&#38;#169;2012ACM978-1-4503-1083-3/12/01. \n. .$10.00 It has unit type 1 as its sole purpose is to cause side effects; it has effect set {update, \nlookup}, as it might cause memory updates or look-ups. Type and effect systems commonly convey this information \nvia a type and effect judgement: x : Loc, y : Loc . M : 1 ! {update, lookup} The information gathered \nby such effect analyses can be used to guarantee implementation correctness1, to prove authenticity properties \n[15], to aid resource management [44], or to optimise code using transformations. We focus on the last \nof these. As an example, purely functional code can be executed out of order: x . M1; y . M2; N = y . \nM2; x . M1; N This reordering holds more generally, if the terms M1 and M2 have non-interfering effects. \nSuch transformations are commonly used in optimising compilers. They are traditionally called optimisations, \neven if neither side is always the more optimal. In a sequence of papers, Benton et al. [4 8] prove soundness \nof such optimisations for increasingly complex sets of effects. How\u00adever, anychange in the language requires \na complete reformulation of its semantics and so of the soundness proofs, even though the essential reasons \nfor the validity of the optimisations remain the same. Thus, this approach is not robust, as small language \nchanges cause global theory changes. A possible way to obtain robustness is to study effect systems in \ngeneral. One would hope for a modular approach, seeking to isolate those parts of the theory that change \nunder small language changes, and then recombining them with the unchanging parts. Such a theory may \nnot only be important for compiler optimisations in big, stable languages. It can also be used for effect-dependent \nequational reasoning. This use may be especially helpful in the case of small, domain-speci.c languages, \nas optimising compilers are hardly ever designed for them and their diversity necessitates proceeding \nmodularly. The only available general work on effect systems seems to be that of Marino and Millstein \n[28]. They devise a methodology to derive type and effect frameworks which they apply to a call\u00adby-value \nlanguage with recursion and references; however, their methodology does not account for effect-dependent \noptimisations. Fortunately, Wadler and Thiemann [46, 47] had previously made an important connection \nwith the monadic approach to computational effects. They translated judgements of the form G . M : A \n! e in a region analysis calculus to judgements of the form G ' . M ' : TeA in a multi-monadic calculus. \nThey gave the latter calculus an operational semantics, and conjectured the exis\u00adtence of a corresponding \ngeneral monadic denotational semantics in which Te would denote a monad corresponding to the effects \nin e, and in which the partial order of effect sets and inclusions would 1E. Cooper, S. Lindley, P. Wadler, \nand J. Yallop. Links 0.5, 2009. http://groups.inf.ed.ac.uk/links .  induce a hierarchyof monads and \nmonad morphisms, as follows: Our language arose from a category-theoretic formulation of the semantics, \nspeci.cally as presheaves of adjunctions over partial or\u00ad e4 Te4 ders of sets of effects. In order to \nmaintain an accessible account, // we usea minimumof category theory.We hope this will allow in\u00ad e2 \ne3 =. Te2 Te3 / / . ... . . . .... . formed readers to recognise the inherent categorical structure with\u00ad \noutexcluding readers who are notfamiliar with category theory. The syntax and denotational semantics \nof MAIL are given in Sections 2 and 3. Two classes of semantic models for MAIL are given (Theorems 9 \nand 12), both based on standard algebraic e1 Te1 Hierarchies of monads in this spirit were identi.edby \nbothTol\u00ad mach [45] and Kieburtz [23]. However, neither hierarchy corre\u00adsemantics, settling Wadler and \nThiemann s conjecture (while we sponded fully to their effect set partial order. write in terms of theories \nand their translations, rather than monads Plotkin and Power s algebraic theory of effects [34, 35] provides \nand their morphisms, their relationship is well-known, see, e.g., a semantic foundation for computational \neffects that focuses on [18]). The two classes of models are related to the semantics of the operations \ncausing the effects. These operations form a single-Alg-CBPV, an algebraic variant of Call-by-Push-Value, \njustifying sorted signature with a natural equational theory. Using tools from thevalidityofeffect dependent \noptimisations (Theorems9and12). universal algebra and category theory, one obtains the standard Next, \nSection 4 validates, uni.es, generalises, and classi.es monadic semantics for such computational effects. \nThe shift in fo\u00adeffect dependent optimisations, including new ones (Figure 7). cus from monads to effect \noperations and their equational theories Algebraic conditions for validating these optimisations are \npre\u00ad allows a modular treatment: Hyland et al. [19] show that the the\u00adsented (Figure 7), and algebraic \ntechniques are given to recognise ories of combinations of effects can often be built up from those and \nmodularly combine validity of optimisations (Theorem 13 for individual effects by simple operations such \nas disjoint sum. Proposition 17). To model recursion, the algebraic theory of effects turns to domain \nSection 5 considers an example effectful language with recur\u00ad theory, replacing equational theories by \ninequational theories. sion, memory regions, exceptions (normal and rollback), terminal We argue that \nthe algebraic view of effects provides the miss-I/O and non-determinism, and applies our theory to validate \neffect ing link needed to develop a general theory of type and effect sys\u00addependent optimisations for \nit. Our modular methodology enables tems. With the right choice of signature, effects (i.e., the elements \nusto signi.cantly cutdownonthe amount ofworkinvolved.We of effect sets e) can be identi.ed with the operations. \nThis sug\u00adgests the way to a full and general account of Gifford-style type and effect systems: effect \nsystems and effect reconstruction arise out of the effect signature; denotational semantics arises out \nof the conclude,and discuss relatedand furtherwork,in Sections6and7. 2. Multi-Adjunctive Intermediate \nLanguage (in)equations; and effect-dependent program logic, including opti\u00admisations, arises from this \nsemantics. We concentrate on denotational semantics and optimisations. We present a language, MAIL (Multi-Adjunctive \nIntermediate Lan\u00adguage), which can be thought of as the intermediate language of a compiler. Its terms \nhave both type and effect annotations; these can be thought of as having arisen from a source code syntactic \nanal\u00adysis. The denotational semantics of MAIL provides a foundation for optimisations. An optimisation \nis simply an equation between MAIL terms, and it is valid in a MAIL model if both terms have the same \ndenotation. We see optimisations as falling into three classes: structural, algebraic, and abstract. \nStructural optimisations arise out of the structure of MAIL models, hence hold in all models; ., \u00df and \nse\u00adquencing laws provide typical examples. Algebraic optimisations arise from equations for individual \neffects in the inequational theo\u00adries underlying the semantics; a typical example is (x :=1;x :=0)=(x \n:=0) These are the bread andbutter of effectful program optimisation. Finally, abstract optimisations \narise from global properties of effects. The Discard optimisation x . M; N = N is one such example. Thereisa \nstrong connectiontoF\u00a8uhrmann swork [13].He had previously considered properties of arrows in Kleisli \ncategories and their dependence on the nature of the monad, and it turns out that these give rise to \nseveral abstract optimisations. In particular, as we see below, Discard holds if, and only if, the underlying \nmonad is af.ne. Viewing abstract optimisations algebraically reveals a connec\u00adtionto algebraiclaws.Forexample,the \nunderlying monadisaf.ne if, and only if, the absorption law f(x,..., x)= x holds generally, i.e., for \nevery operation f. Making use of [19], one can then estab\u00adlish the validity of abstract optimisations \nmodularly. For example, if the absorption law holds generally for each of two theories, then it also \nholds for their disjoint sum. MAIL is based on Levy s Call-by-Push-Value (CBPV) [26] and inspired by \nFilinski s M3L (MultiMonadic MetaLanguage) [11], whose latest version draws heavily on CBPV [12]. The \nCBPV paradigm subsumes call-by-name and call-by-value, both syntac\u00adtically and semantically, and hence \nis appealing for a general ac\u00adcount. Also, in CBPV evaluation order is explicit, as in intermediate languages. \nMoreover, expressing our optimisations in CBPV de\u00adcomposes more complicated optimisations into orthogonal \nones (see Section 4). Thus the CBPV paradigm seems well-suited for use in intermediate languages for \neffect-dependent optimisation. We reuse as much of Levy s work as possible, in order to focus on the \nissues inherent to effect systems. MAIL is parameterised by signatures. An auxiliary notion of pre-signatures \nmakes the de.nition of signatures more manageable: De.nition 1. AMAIL pre-signature s is a tuple (Bsc, \n|s|, O, E,.), where: Bsc isa setof basic types, ranged over by K;|s| isa setof effect operation symbols, \nranged over by op with a distinguished element O; E. P (|s|)is a subset of the powerset of |s|, the set \nof effect sets, ranged over by e;and. isa setof built-in constants, ranged over by c. For example, Bsc \nmay include the types: Word for 64-bit words, Loc for memory locations, Str for strings, Char for characters, \nor Exc for exceptions. The effect operation symbol set |s| may be .nite: {O, lookup, update, input, output, \nthrow, choose} or even countably in.nite: {O, thrown | n . N}. In the latter case, we may want to restrict \nE to be a countable set, such as that of all .\u00adnite subsets P.n (|s|), guaranteeing a countable syntax. \nThe distin\u00adguished symbol O represents non-termination. The set . typically includes primitives to manipulate \nbasic values, such as: number constants 0, 1, 2; arithmetic operators +, *, div; boolean operati\u00ad '' \n'' ons =, >=, <;string manipulation primitives abcd123 , + ;and prede.ned exceptions ArithmeticOverflow, \nDivideByZero.  Kinds: K ::= Val | Comp(e) Value Types: A, B, . . . ::= K | 1 | A1 \u00d7 A2 | 0 | A1 + A2 \n| UeB Computation Types: A, B, . . . ::= FeA | B\u00d7 B| A . B GroundValue Types: G ::= K | 1 | G1 \u00d7 G2 | \n0 | G1 + G2 Value 12 A1+A2 Terms: V ::= c | x | . | (V1,V2) | inj V 1 A1+A2 | inj V | thunk M 2 Computation \nTerms: M, N, . . . ::= coercee1.e2M | returneV | M to x:A. N | . {1 . M1, 2 . M2}| 1 M | 2 M | .x : A. \nM | V M | match V as (x1 : A1,x2 : A2).M | match V : 0 as {}B | match V as {injx1 :A1.M1, injx2 :A2.M2} \n12 B | force V | \u00b5x : UeB. M | op M V Figure 1. MAIL Syntax The syntax of MAIL, for a given pre-signature \ns, is displayed in Figure 1. It re.nes the CBPV dichotomy between values and computations. Instead of \none kind of computation, for each effect set e .E, we have e-computations Comp(e)that can cause effects \nin e. We view MAIL as multiple copies of CBPV, one for each e, sharing the same values. One can translate \nbetween these different CBPVs by means of coercion (see below). Our types are a slight variation on CBPV \ntypes. Note that basic types are always value types. The unit, product, zero, and sum value types are \nstandard. We have modi.ed the CBPV thunk type to thunks UeB of e-computations of type B. For each e .E, \nthe returner type FeA is the type of e-computations that return a value of type A. It plays a similar \nr ole to that of the monadic type TA (where T is a monad) in Haskell. Levy s CBPV also has products of \ncomputations, which we include, and functions are computations that depend on a value. The ground value \ntypes G . Gnd are thosevalue types whichdo not include thunks.We call typesof the form FeG ground returner \ntypes. All of the built-in constants of s-MAIL are value terms. The variables, unit value, and pairing \nconstruct are standard. Injections are annotated with their sum type. Computations M are thunked into \nvalues thunk M , just as in ordinary CBPV. Manytype and effect systems contain a sub-effecting rule: \nif M is an e1-computation and e1 . e2 then M is an e2-computation. One implication of such a rule is \nthat well-typed terms can have multiple types, and even multiple type derivations. As a conse\u00adquence, \nthe denotational semantics can no longer be de.ned di\u00adrectly on terms. Instead, it needs to be de.ned \non the proofs that these terms are well-typed, and then coherence results are needed to show that the \ndifferent semantics are compatible with each other. This issue is familiar from languages that support \nsubtyping. One standard way to circumvent it, followed here, is to use ex\u00adplicit coercion between a subtype \nand its supertype [43]. The terms coercee1.e2M explicitly coerce e1-computations to e2\u00adcomputations. \nAs usual in CBPV, we can turn any value into an e-computation by returning it. The M to x : A. N construct \nsequences compu\u00adtations; it is analogous to x . M;N in Haskell. Note the intrinsic typing (a.k.a. Church-style \ntyping). The standard operational semantics of CBPV uses a stack ma\u00adchine. The two . terms pop from the \nstack while the application terms - M push onto it. Thus, . {1 . M1, 2 . M2} pops a tag off the stack \nand executes M1 or M2 accordingly. In turn, 1 M pushes the tag 1 onto the stack and continues to execute \nM. Sim\u00ad .k A1 : Val .k A2 : Val .k K : Val .k 1 : Val .k A1 \u00d7 A2 : Val .k A1 : Val .k A2 : Val .k B : \nComp(e) .k 0 : Val .k A1 + A2 : Val .k UeB : Val .k A : Val .k B: Comp(e) .k B: Comp(e) 12 .k FeA : Comp(e) \n.k B\u00d7 B: Comp(e) 12 .k A : Val .k B : Comp(e) .k A . B : Comp(e) Figure 2. MAIL Kind System ilarly, .x \n: A. M pops a value of type A and binds x to it, while V M pushes V onto the stack. The pattern-matching \nterms eliminating products, zero and sum values are standard. Thunked computations are eliminated by \nforc\u00ading.Recursionisexpressedby least.xed-points,as usual. Importantly, computational effects are caused \nby the op BM V terms. As an example, the following computation consists of a memory lookup operation, \ndereferencing memory location l, fol\u00adlowed by returning the memory word w stored there: e def FeWord \nderef (l)= lookupl (.w : Word. returnew) The effect operation symbol lookup takes as a parameter the \nloca\u00adtion l to be dereferenced, and requires as argument a computation depending on the dereferenced \nmemory word. As another example, consider a non-deterministic choice opera\u00adtor choose, and a computation \nfor non-deterministic coin tossing: e def Fe1+1 toss = choose(.v : 1 + 1. returne v) . In this case the \nparameter is the unit value .. In general, op BM is an effect operation term with parameter V V and argument \nM.Terms of the form e def gen (V )=op FeA (.x : A. returnex) op V are called generic effects. Thus derefe \nand toss e are the generic effects corresponding to lookup and choose respectively. Our combination of \nCBPV syntax, intrinsic typing and explicit coercion leads to a verbose and cumbersome syntax. However, \nconsidering our setting as an intermediate representation used by an optimising compiler, this issue \nbecomes irrelevant, as the syntax is generated automatically, being seen only by the compiler. The kind \nsystem for MAIL, given a pre-signature s, is dis\u00adplayed in Figure 2; it consists of a kind judgement \nrelation .k be\u00adtween types and kinds. We denote by Val the set of well-kinded value types {V |.k V : \nVal}. Similarly, we write Comp(e)for the set of well-kinded e-computation types. A well-kinded context \nG : Dom (G) . Val is a function from a .nite set of variables to Val.We write G,x : A for the extension \nG[x . A]. Given a pre-signature s, an arity assignment ar:|s|. Gnd2 sends elements of |s| to pairs of \nground types such that ar(O) = (0, 1). When ar(op) = (A, P ) we write instead op : A . P . The .rst component \nA is called the arity type and the second component P is called the parameter type. When the parameter \ntype is P = 1 we simply write op : A. When op : 0 we call op an (effect) constant symbol. Thus, Ois a \nconstant symbol. For example, one would have lookup : Word . Loc as lookup has a location parameter and \nits argument expects the cor\u00ad  G(x)= A G .v V1 : A1 G .v V2 : A2 G .v c : Ac G .v . : 1 G .v x : A G \n.v (V1, V2): A1 \u00d7 A2 G .v V : Ai G .e M : B G .v inj A1+A2 i V : A1 + A2 G .v thunk M : UeB G .e1 M : \nFe1A G .v V : A G .e2 coercee1.e2M : Fe2A G .e returneV : FeA G .e M : FeA G,x : A .e N : B G .e M to \nx : A. N : B G .e M1 : BG .e M2 : BG .e M : B\u00d7 B 12 12 G .e . {1 . M1, 2 . M2} : B\u00d7 BG .e i M : B 12 \ni G, x : A .e M : B G .v V : A G .e M : A . B G .e .x : A. M : A . B G .e V M : B G .v V : A1 \u00d7 A2 G, \nx1 : A2, y : A2 .e M : B G .e match V as (x1 : A1,x2 : A2).M : B G .v V : 0 B G .e match V : 0 as {}: \nB G .v V : A1 + A2 G,x1 : A1 .e M1 : B G,x2 : A2 .e M2 : B G .e match V as {injx1 : A1.M1, injx2 : A2.M2} \n: B G .v V : UeB G,x : UeB .e M : B 12 (O. e) G .e force V : B G .e \u00b5x : UeB. M : B G .e V : P G .e M \n: A . B (op :A . P, op . e) B G .e op M : B V Figure 3. MAIL Type System responding memory word. Similarly, \none would have choose : 2 where, 2 = 1 + 1, as choose has a trivial parameter. We say that choose is \na binary operation symbol. Example constant type assignments are: ' a ' : Char, + : U\u00d8((Str \u00d7 Str) . \nF\u00d8Str), def and, for e = {ArithmeticOverflow}: +: Ue(Word \u00d7 Word . FeWord) De.nition 2. A MAIL signature \nis a triple S= (s, ar,A-) where: s is a pre-signature; ar is an arity assignment; and A- : . . Val is \na type assignment for thebuilt-in constant symbols. The type system of MAIL, given a signature S, is \ndisplayed in Figure 3; it is given by type judgement relations G .v V : A and G .e M : B, where G, A, \nB are well-kinded contexts, value types and e-computation kinds, respectively, and where V , M are value \nand computation terms, respectively. Signatures Sdetermine the language of MAIL, meaning its syntax and \nkind and typing relations; when we need to mention this dependence we write S-MAIL.We call closed ground \nreturners .e P : FeG programs. The type system is straightforward, apart from the rules for co\u00adercion, \nrecursion and effect operation symbols. The coercion rule may seem surprising we only allow coercion \nof returners. How\u00adever this restriction, which is semantically natural, allows suf.cient generality. \nFor if e . , then for any B : Comp(e) one can e ' inductively de.ne a type B ' : Comp(e ' ) by: (FeA) \n' = Fe ' A, (B1 \u00d7 B2) ' =(B1) ' \u00d7 (B2) ' , and (A . B) ' = A . B ' ; there is then an evident coercion \nfrom B to B ' . We note too that, from a CBPV perspective, call-by-value types are always translated \ninto returners [26], hence the coercion rule immediatelysuf.cesto subsumeexistingeffect systems.Wedonot \nknow of anycall-by-name effect systems (see also Section 7). Next, the recursion rule only allows recursive \ncalls when the ef\u00adfect set includes possible divergence. Finally, the effect operation rule formalises \nthe informal explanation given earlier. Another way to view this rule is via continuation passing we \npass a contin\u00aduation M that, depending on the effect s result, proceeds after the effect has been caused. \nFor example, the rules for the I/O effects input : Char and output : 1 . Char are, for suitable e s: \nG .e M : Char . B G .v V : Char G .e M : 1 . B M : B G .e input BM : B G .e output B V The latter is \nanalogous to Levy s print statement [26]. For the corresponding generic effects we derive thefamiliar \nget e , put e: G .v V : Char G .e get e : FeChar G .e put e : Fe1 3. Semantics We begin with some preliminary \nmaterial on domain theory in Sec\u00adtion 3.1 concerning .-cpos, and then consider inequational theo\u00adries \nand their models in .-cpos in Section 3.2. We can then de.ne models of MAIL and its denotational semantics \nin Section 3.3. In Section 3.4 we consider the validity of optimisations and construct our two main MAIL \nmodels the conservative and axiomatic re\u00adstriction models. 3.1 .-cpos Domain theory provides the mathematical \nmachinery needed to model recursion; here we review terminology and relevant nota\u00adtion. The simplest \ntype of domains suf.cient for our needs are .-complete partial orders (.-cpos), i.e., partial orders \nW = V (|W |, =) closed under suprema an of increasing .-chains (an).A (Scott) continuous function f : \nW1 . W2 between .-cpos is a monotone function preserving such suprema (i.e., VV f(an)= f(an)for anyincreasing \n.-chain (an)). Adiscrete .-cpo is a set ordered by equality (A, =). The empty .-cpo 0 is (\u00d8, =);we write \n?W : \u00d8.|W | for the empty map. The singleton .-cpo 1 is ({.}, =); we write !W : |W |.{.} for the constantly-. \nmap. The sum W1+W2 of two .-cpos is the evident .-cpo over their disjoint union |W1| +|W2|.We write .i \n: Wi . W1 +W2 for the evident injections. Given two continuous functions fi : Wi . W ' , i =1, 2, the \nmap [f1,f2]: W1 + W2 . W ' , where: def f1(w1) w = .1w1 [f1,f2](w)= f2(w2) w = .2w2 is continuous.We \nwrite n for the discrete domain over n elements, namely 1 + ... + 1. The product W1 \u00d7 W2 of two .-cpos \nis the component\u00adwise partial order over their Cartesian product |W1|\u00d7|W2|. We write pi : W1 \u00d7 W2 . Wi \nfor the evident projections. Given two continuous functions fi : W ' . Wi, i =1, 2, the map (f1,f2) : \nW ' . W1 \u00d7 W2, where: def (f1,f2) (w)= (f1(w),f2(w)) In is continuous. The product i=1 Wi of any .nite \nnumber of .\u00adcpos is de.ned similarly. The function space W2 W1of two .-cpos consists of all contin\u00aduous \nfunctions from W1 to W2, ordered pointwise: f = g iff for all w . W1, f(w)= g(w); its lubs are also given \npointwise. We write eval : W W1 \u00d7 W1 . W2 for the evaluation map given by 2 I (f, d) . f (w). If f : \ni Wi . W is continuous then currying the j-th component (di)i=j . (wj . f (di))yields a continuous  \n()I map curryj f : i=j Wi. W Wj. An .-cpo W is pointed if it has a least element ..Continuous functions \nover pointed .-cpos have least .xed-points and the least .xed-point operation \u00b5 : W W . W is continuous. \n  3.2 Inequational Theories Afull account of Plotkin and Power s algebraic theory of effects re\u00adquires \nthe notion of (discrete) countable .CPO-enriched Lawvere theories [17]. Here we restrict to the simpler, \nand more elementary, (.nitary) inequational theories. An (equational) signature is a pair S= (|S|, arS) \nwhere |S| isa setof operation symbols and the arity function arS as\u00adsigns to each operation f . S a .nite \nset arS(f) called its ar\u00adity. We adopt the notation f : A for A = ar(f). When f : n we say that f is \nn-ary. Nullary operations are also called constants. We will write {f1 : ar(f1),...,fn : ar(fn)} for \nthe signature ({f1,...,fn}, ar). For example, the non-determinism signature, SND, is {. : 2}. It consists \nof exactly one binary operation . : 2. Again, given a .nite set V of storable values, the global V-state \nsignature, SGS(V) is given by a look-up operation lookup : V and V-many unary operations for updating \nthe state updatev : 1 (v . V). Fix a countable set of variables Var ranged over by x, y, etc. Given a \nsignature S, we de.ne the set TermsS of S-terms inductively: a term is either a variable x, or of the \nform f(t)where f : A and t : A . TermsS. When f is n-ary we may use the usual positional notation f(t1,...,tn) \nto write such terms, and, in the binary case, we may use in.x notation. It is routine to de.ne substitutions \n. : Var . Terms, and their applications t. to terms. Recall that a preorder is a re.exive, transitive \nbinary relation. An inequational theory T is a pair (S, =) where S is a signature and = is a preorder \nover terms, which is a substitutive congruence, meaning that it satis.es the following two properties: \nCongruence For all substitutions .1, .2 satisfying, for all x in Var, .1(x)= .2(x), and for all terms \nt, we have t.1 = t.2. Substitution For all terms t1,t2 for which t1 = t2, and for all substitutions ., \nwe have t1. = t2.. We write t = s iff t = s and s = t. Let S be a signature. The free or empty theory \nfor S is given by syntactic equality, (S, =). The inconsistent theory for S is given ( by the full relation \nS, Terms2). Note that all theories (S, =) lie between these two theories, i.e., =.=. Terms2 . Let Ax \n. Terms \u00d7 Terms be any set of axioms. The theory generated from Ax is ThSAx = (S, =) where = is the least \npre\u00adorder over terms that contains Ax and which is a substitutive con\u00adgruence. Note that the empty theory \nis ThS\u00d8 and the inconsistent theory is ThS{x = y} = ThS{x = y}. The lifting theory T. is given by Th{.:0}{. \n= x}.A more interesting example is the the\u00adory of semilattices, which consists of commutativity, associativity \nand absorption equations for the non-determinism signature SND: x . y = y . x, (x . y). z = x . (y . \nz), x . x = x The theory of lower semilattices is obtained by adding the axiom x = x . y;the theory ofupper \nsemilattices is obtained by instead adding x = x.y. As a .nal example, let V be a .nite set of storable \nvalues. The corresponding theory of global state arises out of the following three equations [29, 34] \nover the global state signature SGS(V): lookup (.v : V.updatev(x))= x updatev0(lookup (.v : V.xv)) = \nupdatev0(xv0) update(update(x)) = update(x) v1v2v2 Given a signature S, an .-cpo S-algebra A consists \nof a () pair |A|, .-.Awhere |A| is an .-cpo and .-.A assigns to each operation f : A a continuous function \n.f . : |A|A . |A|. Every .-cpo S-algebra A induces an interpretation function IA .-.- :Terms \u00d7 |A|Var \n. |A|, given for every variable as\u00adsignment d . |A|Var inductively over terms t by: def d(x) t = x IA \n.t.d = .f.A (.a : A..t (a).d)t = f(t ),f : A Let A1, A2 be two such S-algebras. Their product A1 \u00d7A2 \nis () given by |A|1 \u00d7 |A|2, .-.\u00d7, where, for all f : A, .f.\u00d7 (t )is \\) given pointwise by .f.(p1 . t \n), .f.(p2 . t ). Let A be a A1 A2 S-algebra and W an .-cpo. The power algebra AW is given by \\) |A|W \n, .-. , where, for all f : A, .f. (t )is given pointwise by .w..f .A (.a.t(a)(w)). Given an inequational \ntheory T = (S, =), an .-cpo T -model is a S-algebra A such that, for all t1 = t2, and for all d . |A|Var \n, we have .t1.d = .t2.d.For example, the discretely-ordered collection of all non-empty .nite subsets \nof a set with the union operation is a model of the theory of semilattices. As another example, let V \nbe a .nite discrete .-cpo of storable values and let W be any .\u00adcpo. Then (V \u00d7 W )V is the carrier set \nfor a SGS(V)-algebra with the obvious operations. The product of two T -models is again a T -model. If \nA is a T model and W an .-cpo, then AW is also a T -model. Given two S-algebras A1, A2,a S-algebra homomorphism \nh : A1 .A2 is a continuous function h : |A1| . |A2| that sat\u00adis.es, for all f : A and t . |A1|A : h.f.1 \n(t )= .f.2 (h . t ) Homomorphisms between two T -models are S-algebra homomor\u00adphisms between them as \nalgebras. For example, the projections pi : |A1| \u00d7 |A2| . |Ai| are S-algebra homomorphisms from the product \nA1 \u00d7A2, for all S-algebras A1, A2. Let T be a theory and W an .-cpo. The free T -model over W is a T \n-model FT W for which exists a continuous function .T W : W .|FT W |, called the unit of the free model, \nsuch that for all T -models A and continuous functions f : W . |A| there exists a unique T -algebra homomorphism \nfT : FT W .A satisfying f = . .. f For example, the free model of the lifting theory, de.ned by Th{.:0}{O \n= x}, over an .-cpo W is given by |W | + {.} with w = v iff w = . or w =W v. As another example, the \nTGS(V) \u00adalgebra on (V \u00d7 W )V described above is the free model over W [19, 34]. The free model for any \ntheory over any .-cpo always exists, by appeal to Freyd s adjoint functor theorem, cf. Abramsky and Jung \n[1]. However, its structure may be non-trivial [16, 31]. Let S1, S2 be signatures. A translation T :S1 \n. S2 is a (- )f isaninjection,foreach Var .. A:-where x)-(T,-pair x S1-operation f : A, and T (-):S1 \n. TermsS2 such that, for each S1-operation f , all the variables in T (f) are in the im\u00adage of x f I.e., \nfor each a in A there is a distinct variable x f -. a, and the variables in T (f ) may only involve these \nvariables. Each translation T :S1 . S2 induces a translation function T : TermsS1 . TermsS2 where T(x)= \nx and where T(f(t)) is given by substituting T(ta)for xaf in T(f)simultaneously for [fL all a . A, i.e., \nT(f(t )) = T(f)T(ta)/xa. a.A Let T1, T2 be theories. A translation T : T1 .T2 is a transla\u00adtion T :S1 \n. S2 that respects the inequalities: t1 =1 t2 =. T(t1)=2 T(t2)  For example, given a .nite set V, consider \nthe overwrite theory TOW(V) given by the signature {update: 1 | v . V} and the ax\u00ad {v } ioms update(updatex)= \nupdatexv1,v2 . V. The v1v2 v2 map updatev . updatev x. induces a translation from TOW(V) to TGS(V). We \nwill only use such trivial translations, which have the form ((f,a) . xa,f . f(.a.xa)), i.e., they translate \nopera\u00adtion symbols to themselves. They are translations from T1 to T2 iff S1 . S2 and =1 .=2. Let T : \nT1 .T2 be a translation. Every T2-model A induces a T1-model T * (A)as follows. The carrier .-cpo |T \n* (A)| is |A|. For each operationf : A in S1, we have a term T(f). TermsS2 . Recall the interpretation \nfunction IA .-., and set, for all d in - |A|Var : def .f.(d)= IA .T(f). T*(A)d We obtain a continuous \nfunction |T * (A)|A .|T * (A)|. Thus T * (A) is a S1-algebra, and because T preserves T1-inequalities \nand A is a T2-model, T * (A)is a T1-model. Given an .-cpo W , the T2 unit over W isa map .T2 : W .|T \n* (FT2W )|. Therefore, W by the free T1-model de.nition, there exists a (unique) homomor\u00adphism () T def \n* mW = .T2 : FT1W . T (FT2W ) W T1 T such that .T2 = mW . .T1 . Following Filinski s layered mon- WW \nT ads [10], we call the function mW : |FT1W |.|FT2W | the lay\u00adering of FT1W over FT2W along T. Finally, \nwe introduce two common methods to combine theories [19]. Let S1, S2 be signatures. Their sum S1 +S2 \nis given by def def |S1 +S2| = |S1| +|S2| and arS1+S2(.if ) =ari(f). Given a term t in TermsSi, relabelling \nthe operations in t according to the injection .i : |Si|.|S1 +S2| yields a term .it in TermsS1+S2 . We \ncan apply this relabelling to binary relations over Si in the obvious manner. Let T1, T2 be two theories. \nTheir sum T1 + T2 is given by ThS1+S2((.1 =1). (.2 =2)). Their tensor T1 .T2 is given by ThS1+S2((.1 \n=1). (.2 =2). (AxS1.S2)), where AxS1.S2 contains all equations of the form: f1(.a1.f 2(.a2.xa1,a2)) = \nf2(.a2.f1(.a1.xa1,a2)) where f i : Ai in .iSi, and ai . Ai.  3.3 Semantics Given a MAIL signature S,a \nS-MAIL model consists of a quadruple (B.-. , T-, T-, K.-.) which we describe presently. To each basic \ntype K . Bsc, we assign an .-cpo B.K.. This assignment allows us to interpret ground value types G . \nGnd: G.K. def = B.K. G.1. def G.G1 \u00d7 G2. def = 1 = G.G1. \u00d7G.G2. G.0. def G.G1 + G2. def = 0 = G.G1. \n+ G.G2. We impose on B.-. that, for all op : A . P , G.A. isa .\u00adnite discrete .-cpo and G.P . is discrete. \nFor example, we may choose B.Word. and B.Loc. to be 264 in a 64-bit setting, and B.Char. to be 27 for \nASCII characters. As these interpretations are .nite discrete domains, every ground type involving them \nwill denote a .nite discrete .-cpo. The signature S and this assignment induce an equational sig\u00adnature: \nS.|s|. def { } = opp : G.A.op : A . P .|s| ,p .G.P . which, in turn, induces an equational sub-signature, \nfor each e .E: def { } |SUB.e.| = opp .S.|s|.op . e V.K. def I = B.K. CX T .G. def .G(x). = V.1. def \n= 1 x.Dom(G) V.A1 \u00d7 A2. def = .A1. \u00d7 .A2. Ce.FeA. def V.0. def = Fe.A. = 0 . def V.A1 + A2. def Ce.B\u00d7 \nB= .B. \u00d7 .B. = .A1. + .A2. 1212 Ce.A . B. def .B..A. V.UeB. def = = |.B.| Figure 4. Type Interpretation \nThe next component, T-, assigns to each e .E an inequational theory Te = (Se, =e), such that SUB.e. . \nSe as a sub\u00adsignature, and such that if O . e then O =e x. Thus we get, for each e .E and .-cpo W , the \nfree .-cpo Te-algebra, FeW and its corresponding unit .e and bijection - e. The side condition guarantees \nthat if O . e then all Te-models are pointed .-cpos. This assignment allows us to interpret the S-MAIL \ntype system (see Figure 4): value types are interpreted as .-cpos via V.-.; e\u00adcomputations as Te-algebras \nvia Ce.-.;and contextsGas products via CX T .-.. For example, take T\u00d8 to be Th\u00d8\u00d8 the empty theory over \nthe empty signature. In this case, T\u00d8-models are just .-cpos, and F\u00d8W = W . The third component, T-, \nassigns to each pair of subsets e1 .e2 in E a translation Te1.e2 :Te1 .Te2.We require this trans\u00ad op \nlation to be operation-compatible, Te1.e2(op) = op(.a.xa ), for all op . e1, and inclusion-compatible \n(functorial): op Te ' .e '' (Te.e ' (op)) = Te.e '' (op) Te.e(op) = op(.a.xa ) . e '' for every triple \ne . e ' in E and op : A . P in e.For exam\u00adple, if T\u00d8 = Th\u00d8\u00d8, we can choose T\u00d8.e to be the empty trans\u00adlation. \nThese translations induce an inclusion-compatible layering e1.e2 m . The .nal component, K.-., assigns \nto each built-in constant c . . an element K.c. .V.Ac.. It is instructive to interpret the arithmetic \nconstants on 64-bit integers that can cause exceptions as an example. We summarise the de.nitionofaS-MAIL \nmodel: De.nition 3. Let S be a MAIL signature. A S-MAIL model is a quadruple M = (B.-. , T-, T-, K.-.), \nwhere: B.-. assigns to each basic type K an .-cpo such that all |s|-arities are in\u00adterpreted as .nite \ndiscrete domains; T- assigns to each effect set a theory whose signature includes SUB.e., such that if \nO . e then O = x; T- assigns to each inclusion e1 . e2 a translation Te1.e2 : Te1 .Te2 in a compatible \nmanner; and K.-. assigns to eachbuilt-in constant c an element K.c. .V.Ac.. Given a S-MAIL model M, we \ninterpret S-MAIL terms as follows (see Figure 5): value terms G .v V : A are interpreted as continuous \nfunctions VT .V . : CX T .G. .V.A.; and e\u00adcomputation terms G .e M : B are interpreted as continuous \nfunc\u00adtions CT e.M. : CX T .G. . |Ce.B.|. The semantic functions have straightforward de.nitions. The \nonly exception is coercion e1.e2 from e1-returners to e2-returners via the layering m . Also note how \nthe type system and the side condition over Te ensures these semantic functions are well-de.ned.  3.4 \nValidity and Models First, we de.ne the validity of optimisations in MAIL: De.nition 4. Let M be a S-MAIL \nmodel, and G . Pi : X, i =1, 2 be two well-typed S-MAIL terms. We say that the opti\u00admisation G . P1 = \nP2 : X is valid in M if M.P1. = M.P2.. In this case we write M|=G . P1 = P2 : X. When G and X are clear, \nwe simply write M|= P1 = P2.  def def def VT .c. (.)= .c. VT .x. (.)= px(.) VT ... (.)= . def VT .(V1,V2). \n(.)= (.V1. (.), .V2. (.)) A1+A2 def VT .inj V . (.)= .i(.V . (.)) i def CT e2.coercee1.e2M. (.)= m e1.e2(.M. \n(.)) def e CT e.returneV . (.)= .(.V . (.)) def CT e.M to x : A. N. (.) =(.a..N. (. [x . a]))(.M. (.)) \ne def CT e.i M. (.)= pi(.M. (.)) def CT e.V M. (.) =(.M. (.))(.V . (.)) B. def CT e. match V : 0 as {}=?.B. \nCT e. match V as {injx1 : A1.M1, injx2 : A2.M2}. (.) 12 { def .M1. (. [x1 . a1]) .V . (.)= .1a1 = .M2. \n(. [x2 . a2]) .V . (.)= .2a2 def CT e.\u00b5x : UeB. M. (.)= \u00b5.f .|.B.|..M. (. [x . f]) B def CT e.op M. (.)= \n.op.V .(.). (.M. (.)) V .B. Figure 5. Term Interpretation However, we are actually interested in the \nvalidity of optimisa\u00adtions with the effect annotations erased, as that will correspond to the validity \nof optimisations in the source language. So we need a suitable algebraic version of CBPV. We obtain such \na language, def S-Alg-CBPV, by specialising MAIL to signatures with E = {|s|}. Models of S-Alg-CBPV consist \nof interpretations for basic types, a single inequational theory T|s|, and interpretations for the built-in \nconstants. Thus we obtain a syntax and semantics for CBPV with recursion and algebraic effects. De.nition \n5. Asimple MAIL signature is a MAIL signature Ssuch that |s|.E, and for each built-in constant c, the \nonly effect set appearing in Ac is |s|. Let S be a simple signature. Then, by replacing E with {|s|} \nand e s with |s| one obtains an Alg-CBPV signature S.. There is an obvious erasure operation (-). that \nyields, for each syntactic S-MAIL entity, such as type X or term P , a corresponding S.-Alg-CBPV entity, \nsuch as X. or P . respectively. This erasure operation preserves well-kindedness and well-typedness. \nModels for Algebraic CBPV with common combinations of ef\u00adfects, and means to combine and construct them, \nare readily avail\u00adable in the literature [19, 20, 34]. Given a simple signature S and one such S.-Alg-CBPV \nmodel, we now give three corresponding S-MAIL models that can be used for reasoning about S.-Alg-CBPV \nprograms. S. Lemma 6. Let S be a simple MAIL signature. For each - Alg-CBPV model M there exists a S-MAIL \nmodel M. such that Te = T, and Te1.e2 is the identity translation. Further, for all well-typed terms \nG . P : X we have M..X. = M.X.. and M..P . = M.P ... The proof is straightforward, where the notion of \na simple signa\u00adture guarantees our ability to choose interpretations for S-MAIL s constants. (It would \nbe useful to extend our results to non-simple signatures.)We call M. the benchmark model. Lemma6 immedi\u00adately \nyields a connection between S-MAIL and S.-Alg-CBPV va\u00adlidity: Theorem 7. Let M be a S.-Alg-CBPV model. \nFor any two well\u00adtyped S-MAIL programs . Pi : FeG, i =1, 2, we have: M|= P1 . = P2 . .. M. |= P1 = P2 \nThis theorem then allows us to compare other S-MAIL models to a given S.-Alg-CBPV model via logical relations \narguments [11, 30, 41] comparing S-MAIL models with the benchmark model. The benchmark model completely \nignores the effect annota\u00adtions.We next introducea model that takes them into account: De.nition 8. Let \nT = (S, =) be an inequational theory. For any e . S, the conservative restriction of T to e, T|e, is \nthe inequational theory (e, =n Termse \u00d7 Termse). Theorem 9. Let M be an S.-Alg-CBPV model. There exists \na S-MAIL model M. such that Te is T|.e. , and Te1.e2 is the trivial translation. Further, for any two \nwell-typed S-MAIL programs . Pi : FeG, i =1, 2, we have: M|= P1 . = P2 . .. M. |= P1 = P2 We callM. the \nconservative restriction model. Validating optimisations in M. depends on .nding Te explic\u00aditly. This \nis non-trivial, but is easier with simpler theories. One might hope to express restrictions of a combination \nof theories in terms of the restrictions of their components. This hope leads to the following (incomplete) \nconjecture: Conjecture 10. Let T1,T2 be inequational theories, and let e1 + e2 . S1 +S2 be any subset. \nUnder some conditions, the re\u00adstriction (T1 + T2)|is identical to the sum of restrictions e1+e2 T1|+ \nT2|. Similarly, under some conditions, (T1 .T2)| e1 e2e1+e2 is identical to T1|.T2|. e1 e2 To see that \nthe conjecture is not trivial, consider the theory for monoids. The signature is {\u00b7 : 2,e : 0} and the \naxioms are: (x \u00b7 y)\u00b7 z = x \u00b7 (y \u00b7 z) x \u00b7 e = x = e \u00b7 x The non-intuitive, yet elementary, Eckmann-Hilton \nargument [9] shows that the two theories (Monoids . Monoids)|and {\u00b7,e}+\u00d8 Monoids|. Monoids|are different: \nmultiplication is com\u00ad {\u00b7,e}\u00d8 mutative in the former,but not the latter. As an intermediate solution, \nwe give a model based on the presentation of a theory as a collection of axioms. De.nition 11. Let S \nbe a signature and Axa set of axioms over it. For anye . S, the axiomatic restriction of Axto e, Th|e \n(S, Ax), is the inequational theory The(Ax n (Termse \u00d7 Termse)). We then have an analogue of Theorem \n9: Theorem 12. Let Axbe a set of axioms over S, and M a S.-Alg-CBPV model such that T = ThSAx. There \nexists a S-MAIL model M. such that Te is Th|.e. (.S., Ax), and Te1.e2 is the trivial translation. Further, \nfor any two well-typed programs . Pi : X, i =1, 2, we have: M|= P1 . = P2 . .= M. |= P1 = P2 We call \nM. the axiomatic restriction model. Note that by con\u00adstruction M. has an explicit axiomatisation of Te. \nMoreover, if T = T1 + T2 and Ti = Th.Si. Axi, then T = Th(Ax1 +Ax2) and the axiomatic restriction model \nresulting for Ax1 +Ax2 satis\u00ad.es for all ei . Si, i =1, 2: Te1+e2 = Th|(.S1 +S2., (Ax1 +Ax2)) .e1+e2. \n.S1..S2. = ThAx1 +ThAx2 = Te1 + Te2  (' )(' )[] ' \u00df laws: match V,V as x : A, y : A .M = M V/x,V /y \nA1+A2 match inj i V as {inj1x1 :A1.M1, inj2x2 :A2.M2} = Mi [V/xi] force (thunk M)= M (returneV )to x \n: A. M = M [V /x] i . {1 . M1, 2 . M2} = Mi V .x : A. M = M [V /x] . laws: V = . (' ) M [V /z]= match \nV as x : A, y : A .M [(x, y)/z] x, y freshin M B M = match V : 0 as {} { inj1x : A .M [inj1x/z], M [V \n/z]= match V as x, y freshin M inj2y : A ' .M [inj2y/z] V = thunk (force V ) M = M to x : A. returnex \nM = . {1 . 1 M, 2 . 2 M} N = .x : A. x Nx freshin N Sequencing: (' ) ' ''' M to x :A. N to y :A.N =(M \nto x :A. N)to y :A.N x freshin N { 1 . M to x : A. N1, M to x : A. . {1 . N1, 2 . N2} = . 2 . M to x \n: A. N2 '' M to x : A. .y : A .N = .y : A. (M to x : A. N) y freshin M Effects: ()(' ) B ' FeA ' op .x:A. \nM to y :A .N= op .x :A. Mto y :A.N x freshin N VV {{ B1 B1\u00d7B2 1 . M1, 1 . op .x : A. M1, V .x : A. . \n= . VB2 op 2 . M2 2 . op .x : A. M2 V A '.B '' B op .x : A. .y : A .M = .y : A. op .x : A.M x y = VV \nRecursion: \u00b5x : UeB. M = M [thunk \u00b5x : UeB. M/x] () Coercion: coercee2.e3coercee1.e2M= coercee1.e3M () \ncoercee1.e2returne1M= returne2M () coercee.e ' (M to x:A. N)= coercee.e ' Mto x:A. coercee.e ' N () A \n' A ' Fe1Fe2 coercee1.e2op .x : A. M= op .x : A. coercee1.e2M VV Figure 6. Structural Optimisations Similarly, \nif T = T1 .T2, then Te1+e2 = Te1 .Te2 in the ax\u00adiomatic restriction model resulting for Ax1 +Ax2 +(AxS1.S2). \nThus the analogueofConjecture10 holdsby construction for M.. Also note that for our purposes, this theorem \nimplies that valida\u00adtion of optimisations in the modular approximation model is sound. However, it may \nnot be complete some sound optimisations may not be valid in this model. 4. Optimisations We turn to \nvalidating effect-dependent optimisations, formulated as MAIL equations. This is done semantically, using \nTheorems9 or 12 (either one can be used in all cases considered below). We divide optimisations into \nstructural, algebraic, and abstract groups. We validateversionsof almostallthe optimisationsinBentonetal.[4 \n8], and also some others, not previously considered in the semantics literature.Theonly optimisations \nconsideredbyBentonetal. [4 8] that we do not treat deal with exception handlers (see Section 7). Structural \noptimisations re.ect the general structure of our models. Let S be a MAIL signature. Then a S-MAIL structural \noptimisation is one that is valid in all S-MAIL models. Figure 6 shows example schemes for such optimisations. \nThey are all vari\u00adants of the standard \u00df, ., sequencing and similar laws found in the CBPV literature \n[26, 36], together with ones concerning effect coercion. Algebraic optimisations originate locally in \nthe inequational theories Te associated to a given model of S-MAIL. Each equation yields such an optimisation.To \nderive these optimisations from the equations, one follows [36]. We just give an example here. The global \nstate theory includes the axiom update(lookup (.v.xv)) = update(xv0) v0 v0 The corresponding algebraic \noptimisation is update B (lookup M)= update B (V M ) VV Abstract optimisations follow from overall, global \nproperties of the theories. Each appears in two forms, which we call utilitarian and pristine. The utilitarian \nform readily applies to program op\u00adtimisation; the pristine form is shorter and easier to validate, but \nperhaps less useful.Forexample, the utilitarian formof Discardis G .e M : FeA G .e ' N : B (e . e ' ) \nM|= coercee.e ' M to x : A. N = N and its pristine form is G .e M : FeA M|= M to x : A. returne. = returne. \nThe two forms can always be shown equivalent using structural optimisations. Instances of both appear \nin the work of Benton et al. This optimisation is valid if, for example, Te is the environment theory \nTEnv(V), whose signature is {lookup : V} and axioms are: x = lookup(.v.x) lookup (.v1.lookup (.v2.xv1,v2))= \nlookup (.v.xv,v) Note that the optimisation obtained by erasure, M to x :A. N = N is in general not valid. \nLet . P : FeG be a well-typed S-MAIL program. Let P ' be a well-typed S-MAIL program obtained by applying \nthe Discard op\u00adtimisation to P . If Discard is valid in the conservative (axiomatic) restriction model, \nthen Theorem9(respectively, Theorem 12) guar\u00adantees that P . = P '. is valid. This equation is valid, \neven if the erased Discard used is invalid. Thus Theorems 9 and 12 formalise the justi.cation for effect \ndependent optimisation. Discard also supplies a non-example. Taking M to be a thunk in the pristine form \nof the optimisation yields on the right hand side the term .m : UeFeA. force m to x : A. returne ., and \non the left the term .m : UeFeA. returne .. When Discard is valid, these two terms are equal. When the \nerased Discard is invalid, the erased terms are not equal. Note that these are closed term of the non-ground \ntype UeFeA . Fe1. This non-example demonstrates why it is important to restrict to ground returners in \nTheorems 9 and 12. Validating abstract optimisations denotationally reveals an inti\u00admate connection2 \nto Fuhrmann s work on the structure of call-by\u00ad \u00a8value [13, 14]: each has a characterisation in semantic \nterms. For example, the Discard optimisation holds iff Te is an af.ne theory [13, 21, 24], that is, iff \n.1 e : 1 .|Fe1| is an isomorphism. There are also algebraic characterisations of these semantic properties. \nFor example, a theory T is af.ne iff for every term t, t(x,..., x)= x, that is, iff a global absorption \nlaw holds. (Here, and below, we are displaying all the variables of the terms at hand.) Such algebraic \nproperties can be investigated using the equational presentation of the theory. As an example, the theory \nfor environ\u00adments TEnv(V) and the various semilattice theories are af.ne. A summary of the results appears \nin Figure 7; in any row, all the conditions are equivalent in any model of MAIL, taking the condition \nin the .rst column as universally quanti.ed over all e ' such that e ' uhrmann [13, 14]) . e. Benton \net al. [4 8] (F\u00a8considered call-by-value analogues of the optimisations labelled by B(respectively F)in \nFigure 7, albeit for particular combinations of effects (respectively fora .xed monad);F\u00a8 uhrmann also \nshowed the 2Alex Simpson, private communication.  name utilitarian form pristine form abstract side \ncondition algebraic equivalent example basic theories Figure 7. Abstract Optimisations Discard G .e \nM : Fe A G . e ' N : B (coerceM) to x : A. N =N BF G .e M : Fe A M to x : A. returne . =returne . BF \nF Te af.ne:. e1 : 1 . |Fe 1| has a continuous inverse For all e-terms t: t(x, . . . , x) =x read-only \nstate, convex,upper and lowersemilattices Copy G.e M : Fe A G, x : A, y : A . e ' N : B coerceM to x \n: A. coerceM to y : A. N = coerceM to x : A. N [x/y] BF G .e M : Fe A M to x :A. M to y :A. returne (x, \ny) = M to x :A. returne (x, x) BF F Te relevant:.e . d =L e d For all e-terms t: t(t(x11, . . . , x1n), \n. . . , t(xn1 , . . . , xnn)) =t(x11, . . . , xnn) exceptions, lifting,read-only state,write-onlystate \nWeakCopy G.e M : Fe A G, x : A . e ' N : B coerceM to x : A. coerceM to y : A. N = coerceM to x : A. \nN G .e M : Fe A M to x : A. M =M \u00b5 e . str e . d =id For all e-terms t: t(t(x1 , . . . , xn), . . . , \nt(x1 , . . . , xn)) =t(x1 , . . . , xn) any af.ne or relevanttheory: lifting,exceptions, read-onlyand \nwrite-onlystate, allthree semilattice theories Swap G .e 1 M1 : Fe 1 A1 G .e 2 M2 : Fe 2 A2 G, x1 : A1 \n, x2 : A2 . e ' N coerceM1 to x1 :A1 . coerceM2 to x2 :A2 . N = coerceM2 to x2 :A2 . coerceM1 to x1 :A1 \n. N BF G .e 1 M1 : Fe 1 A1 G .e 2 M2 : Fe 2 A2 coerceM1 to x1 :A1 . coerceM2 to x2 :A2 . returne (x1 \n, x2 ) = coerceM2 to x2 :A2 . coerceM1 to x1 :A1 . returne (x1 , x2 ) BF F Te 1 .e , Te 2 .e commute: \n.e . (m e 1 .e \u00d7 m e 2 .e ) = .e . (m e 1 .e \u00d7 m e 2 .e ) Te 1 .e translations commutewithTe 2 .e translations \n(seetensor equations) T1 . T1 . T2 . T2 , e.g., distinct globalmemory cells WeakSwap G .e 1 M1 : Fe 1 \nA1 G .e 2 M2 : Fe 2 A2 G, x1 : A1 . e ' N (same as Swap) G .e 1 M1 : Fe 1 A1 G .e 2 M2 : Fe 2 A2 coerceM1 \nto x1 :A1 . coerceM2 to x2 :A2 . returne x1 = coerceM2 to x2 :A2 . coerceM1 to x1 :A1 . returne x1 .e \n. (m e 1 \u00d7m e 2 ) . (id\u00d7. e 2 1 ) = .e . (m e 1 \u00d7m e 2 ) . (id\u00d7. e 2 1 ) For all e-terms t =T1 (t ' ), \ns =T2 (s ' ): t(s(x1 , . . . , x1 ), . . . , s(xn, . . . , xn )) = s(t(x1 , . . . , xn), . . . , t(x1 \n, . . . , xn)) whenTe 2 is af.ne, e.g.: read-only state andconvex, upper and lowersemilattices. IsolatedSwap \nG .e 1 M1 : Fe 1 A1 G .e 2 M2 : Fe 2 A2 G . e ' N (same as Swap) G .e 1 M1 : Fe 1 A1 G .e 2 M2 : Fe 2 \nA2 coerceM1 to x1 :A1 . coerceM2 to x2 :A2 . returne . = coerceM2 to x2 :A2 . coerceM1 to x1 :A1 . returne \n. .e . (m e 1 \u00d7m e 2 ) . (. e 1 1 \u00d7. e 2 1 ) = .e . (m e 1 \u00d7m e 2 ) . (. e 1 1 \u00d7. e 2 1 ) For all e-terms \nt =T1 (t ' ), s =T2 (s ' ): t(s(x, . . . , x), . . . , s(x, . . . , x)) = s(t(x, . . . , x), . . . , \nt(x, . . . , x)) whenT e 1 is af.ne: read-only state andconvex, upper and lowersemilattices. Unique G \n.e Mi : Fe 0, i =1, 2 M1 =M2 B (same as utilitarian form) Fe 0 =0, 1 Te equates all e-constants all three \nstate theories,all three semilatticetheories, a singleunparameterisedexception, lifting PureHoist G .e \nM : Fe A G, x : A . e ' N : B returne thunk (coerceM to x : A. N) =M to x : A. returne thunk N BF G .e \nM : Fe A returne thunk M = M to x : A. returne thunk returne x BF F L e . eW =. e|Fe W| all e-terms are \nequal tovariables in Te the empty theory,inconsistent theories Hoist G .e M : Fe A G, x : A . e ' N : \nB M to x : A. returne thunk (coerceM to x : A. N) =M to x : A. returne thunk N BF G .e M : Fe A M to \nx : A.thunk returne (x, thunk M) = M to x : A.thunk returne (x, thunk returne x) BF F L e . . e , id \n. =str e .d all e-terms are either avariable or independent oftheir variables via Te all theories containingonly \nconstants: liftingand exceptions equivalence of the two forms and the abstract side condition in his \nsetting. The abstract conditions in Figure 7 use the following standard categorical notions. The diagonal \nfunction dW : W . W \u00d7 W is def given by d(w)= (w, w). Let T be an inequational theory. Given a continuous \nfunction f : V . W , we can lift it to a homomor\u00adphism (. . f) : FV . FW . We denote the underlying map \nby Lf : |FV |.|FW |. The multiplication \u00b5 : |F|FW || . |FW | is the underlying map of the homomorphism \nid : F|FW |. FW . The (left) strength, str : V \u00d7|FW |.|F(V \u00d7 W )|, is given by .(v, w).(curry.) (w)(v). \nSimilarly we de.ne the right strength, str ' : |FV |\u00d7 W .|F(V \u00d7 W )|. The two double strength functions \n., . : |FV |\u00d7|FW |.|F(V \u00d7 W )| are de.ned by . = . . L str ' . str and by . = . . L str . str ' . Note \nhow Copy corresponds to a global idempotency law, and how Swap corresponds to commutativity. Slight variations \non these two laws yield the Weak Copy3, and Weak and Isolated Swap optimisations, which are new in the \nformal methods optimisation literature. Also note the algebraic condition for Pure Hoist. It means that \nTe is either inconsistent, or the operations project one of their arguments without effect. Note too \nthe two hoisting optimisations and compare them to the structural optimisations dealing with effect operations \n(Fig\u00adure 6). The simplicity of the latter over the former suggests that the complications arise from \nthe process of thunking rather than abstracting over variables. This clean separation between thunks \nand abstraction supports our use of CBPV. Most (but, unfortunately, not all) of the optimisations can \nbe validated operation-wise: Theorem 13. For each of the optimisations Discard, Pure Hoist, and Hoist, \nthe algebraic condition holds for a theory T iff for all operations f : A it holds for the term t = f(.a.xa). \nAnalogously, for each of the various Swap optimisations, the memory with associated operations lookupl \nand updatelv ' , the trivial translations of TEnv(V).TND, TND .TOW(V) into the theory with two distinct \nmemory cells and non-determinism, TGS(V) . TND .TGS(V), commute. Note that each algebraic condition for \nDiscard andCopyimplies that of Weak Copy. Similarly, the algebraic condition for Swap implies that ofWeak \nSwap, which implies that of Isolated Swap. The notableexceptionsto Theorem13 aretheCopy,WeakCopy and \nUnique optimisations. For example, in the global state theory TGS(2) both lookup and update are idempotent, \nbut the term lookup(.a.update0xa)is not idempotent. However, in practice, we can use equational reasoning \nto establish them. For example, the write-only state theory is relevant, because any term can be rewritten \nto a single operation updatev x. As these are idempotent, all terms satisfy the idempotencylaw. We can \nuse similar equational arguments to establish these idempotencylaws for theory combinations: Theorem \n16. Let T , T ' be two relevant algebraic theories. If all S operations have arity 0, then T + T ' is \nrelevant.  If all S operations have arity 1, then T .T ' is relevant.  If T is also af.ne, then T .T \n' is relevant.  The same is true replacing relevant by the Weak Copy charac\u00adterisation. In practice, \nthe relevant theories with which one usually tensors are the lifting theory or with the read-only and \nwrite-only state theories, and theyall satisfy the conditions of this theorem. Similarly, we can deduce \nthe condition for the unique optimisa\u00adtion in the following case: Proposition 17. Let T be an inequational \ntheory. If every nullary operation in S commutes with every S-operation, then T satis.es the algebraic \ncondition for the Unique optimisation. T 1- . fi :Si Ai, i =1, 2, it holds for the terms t = f 1(.a1.xa1)and \nf 2 ().s = ax2..a2 2 The theorem is proved by a straightforward induction over e\u00adterms, demonstrating \nthe bene.ts of the algebraic characterisation. 1 The theorem was used to obtain most of the examples \ncolumn in Figure 7. We can also use this it to deduce optimisation validity modularly: Corollary 14. \nFor each algebraic condition for Discard, Pure Hoist, and Hoist, if T 1 ,T 2 satisfy it, then so does \nT 1 + T 2 . Analogously, for each algebraic condition for the various Swap ij TT - .T .- T j T2 .- T1 \nT T2 iff for eachalgebraic condition holds for optimisations, if T1 i , for all i, j =1, 2, satisfy it, \n2 then so does T11 + T12 .T .T21 + T22 . 5. Example Language To demonstrate our results, we consider \na non-trivial language. Assume the memory has been partitioned into a .nite set of dis\u00adjoint regions \n[27] Reg. The set Reg is partitioned into three sub\u00adsets: read-only regions RegRO; write-only regionsRegWO;and \nread-write regions RegRW.We denote by RegR the read-able re\u00adgions RegRO . RegRW, and by RegW the write-able \nregions RegWO . RegRW. The MAIL signature in question S is given as follows. The basic types Bsc are \nChar, Word, Str and Loc. The effect operations |s| and their arities are: O: 0, as required; input : \nChar for terminal input; output : 1 . Char for terminal output; raise : 0 for causing an exception; throw \n: 0 . Str for causing an exception with an error message; rollback : 0 Optimisation validity is inherited \nby super-theories: for causing a rollback exception; abort : 0 . Str for causing a rollback exception \nwith an error message; for all write-able regions Proposition 15. If T satis.es any of the algebraic \nconditions in . . RegR, lookup. : Word . Loc, note that each region Figure 7, and if T ' is any theory \nwith S =S ' and (=) . (= ' ), consists of Loc-many locations; for all read-able regions . in then T \n' satis.es the same condition. . : 1 . Loc \u00d7 Word; and .nally, . : 2 for RegW, update TT2 1 - . T3 .- \nT2 satisfy the algebraic con\u00addition for any of the various Swap optimisations, and if, further, effect \nsubsets P (|s|). Finally, the built-in constants . we choose '' '' Analogously, if T1 non-deterministic \nchoice. The effect sets E are given by all (.nite) T T T1 ' S ' are: c : Char for each ASCII character \nc; i, Ti .Ti ' and for each n for each 64-bit 2.f S(f )Ti,i 1- .- T2 ' are such that Si = .T3 ' '' \n'' number n; s for each character string s;l for each 64-bit memory '' T T T ' i(f), then T1 ' 2 1- \n ( ) algebraic condition. S. The Alg-CBPV signature is (Bsc, |s| , O,.) , ar,A-. For example, the semilattice \ntheories are commutative the The chosen S.-Alg-CBPV model M interprets the basic types as identity translations \ncommute. Thus given two locations l, l ' in follows: .Char. is 28, the usual ASCII encoding; .Word. is \n264 , which we also denote by V; .Str. is .Char.* , the set of 3Paul B. Levy, private communication. \n.nite .Char. sequences; and .Loc. is 264. The theory T is given .- T2 ' satisfy the same = address l. \nThe resulting Sis indeed simple. .T3 '  by [19]: {raise,throw} Th\u00d8 +( @@@ ..RegRO,l ..RegWO,l ..RegRW,l \nT.T .T . Env(V) OW(V) GS(V) {rollback,abort}{input} (Th\u00d8 +Th\u00d8+ {output} Th\u00d8 +(TND .TO))) where the lookup \noperations in the signature in the (., l)-th com\u00ad @ ..RegRO ponent of the folded tensor T are tagged \nwith . and l, Env(V) i.e. lookupl., and similarly for the other folded tensors. Finally, the constants \nare given the obvious interpretations. By Theorem 12, we have an axiomatic restriction model M. for the \nnatural modular axiomatisation of T . Validating optimisations in this model yields valid optimisations \nfor S.-Alg-CBPV. For each optimisation o in {Discard, Pure Hoist, Hoist}, we de.ne a set .o .|s| of the \noperations that satisfy its algebraic condition: Discard def . PureHoist def .= {., lookup | . . RegR} \n.= \u00d8 Hoist def .= {raise, throw, abort, rollback, O} By Theorem 13 we obtain the following condition: \nProposition 18. For each optimisation o in {Discard, Pure Hoist, Hoist}, if e . .o then o is valid in \nthe theory Te of M.. Analogously, for each o in {Swap, Weak Swap (WSwap), iso\u00adlated swap (ISwap)} and \nfor each op .|s| de.ne the set .o(op) of effect operations that o-commute with op. For Weak Swap, op \nre\u00adplaces t in the algebraic condition. Note that because Swap implies Weak Swap, which implies Isolated \nSwap, we have .Swap(op) . .WSwap(op) . .ISwap(op). These sets are given in Figure 8. From Theorem 13 \nwe can deduce the validity of swapping: Proposition 19. Let o be one of the various Swap optimisations. \nn .o Let e1, e2 be two effect sets. If e2 . (op) then the op.e1 optimisation o is valid for Te1 .Te1.e2 \n.Te2. We should note that despite our brute force method of examin\u00ading 200 pairs of effect operations, \nwe are still exponentially better offthan trying to exhaust the space of 220 possible pairs e1, e2. It \nis worthwhile to wonder whether mechanised assistance is possible. It would also be good to be able to \ndecide exactly which of the 220 possible optimisations is valid in the benchmark model. Theorem 20. Let \ne .|s|. If input, update, ../e and for all . in RegRW, {lookup. , update.} r e, then Te validates theCopy \noptimisation. Note that the premise of the theorem and the structure of the axiomatic restriction model \nguarantees that Te is of the form: {raise,throw}{rollback,abort} Th\u00d8+(T @ .T @ .(Th\u00d8+TO)) Env(V)OW(V) \nwhere each of the theories may be omitted. Note that all of them are relevant. Repeated application of \nTheorem 16 shows the com\u00adbination s relevance. The optimisationWeak Copyis treated similarly: Theorem \n21. Let e .|s|. If input, output ./e and for all . in RegRW, {lookup. , update.} r e, then Te validates \nthe Weak Copy optimisation. To conclude our example, we treat the Unique optimisation using Proposition \n17: Theorem 22. Let e .|s|. If e n{O, raise, rollback} = {op} and e . .Swap (op), or if the intersection \nis empty, then Te validates the Unique optimisation. 6. RelatedWork Filinski used M3L [10, 11] to investigate \neffect rei.cation [12]. Its earlier call-by-value versions had a denotational semantics and in\u00adspired \nour CBPV MAIL. Marino and Millstein [28] developed a tech\u00adnique to derive type and effect frameworks \nbased on the notions of redexes and contexts [48]. These frameworks are parameterised by two functions \ncheck and adjust. Theyapplied their technique to a .xed ML-like, call-by-value language with recursion, \nexcep\u00adtions and higher-order dynamic allocation, capturing many existing effect systems, mostly more \ngeneral than the Gifford-style. They gave a mechanically checked soundness proof of their effect sys\u00adtem, \nwith respect to a suitable operational semantics. Atkeyapplied permission-parameterised monads to the \nseman\u00adtics of type and effect systems [2, 3] more general than Gifford\u00adstyle ones. His parameterised \nmonads can be generated by a notion of equational theory in which the signature assigns input and out\u00adput \npermissions to operations, thereby connecting operations and effects (qua permissions). He also established \nrelations to standard monadic semantics analogous to Theorems9and 12. 7. Conclusions and FurtherWork \nWe have given a theory of Gifford-style effect systems, generalis\u00ading and unifying existing work. The \nalgebraic approach provides a valuable general point of view, resulting in: the connection between effect \noperations and effect sets; the conservative and the axiomatic restriction models; the relation between \neffect-annotated semantics and standard algebraic semantics; optimisation classi.cation and discovery \nof new optimisations; criteria for the validity of abstract optimisations; and methods to derive the \nvalidity of optimisations for combinations of effects modularly. Rather than having to pro\u00adceed from \ncase to case by analogy, we hope that the generality of our approach will provide a .rst step on the \nway to obtaining a scienti.cally-based engineering methodology. The use of CBPV enabled a systematic \naccount that highlights the interplay between programming constructs and effects. Cate\u00adgorical language \ngreatly helped the organisation of this work. It was also crucialin seeing the connection withF\u00a8uhrmann \nswork, and unifying it with Benton et al. s. Finally, the example language demonstrated the ease of application \nof the theory to a language equipped with an algebraic semantics. Note too that model con\u00adstructions \nare not ad hoc: they come for free given only the alge\u00adbraic theory of the effects at hand. Further work \nabounds. It would be good to resolve Conjec\u00adture 10, and to establish means to decide the validity of \noptimi\u00adsations in the benchmark model. It is also important to include ef\u00adfect handlers [37, 40] such \nas exception handlers and rollback in the language. Pretnar and Plotkin describe a \u00df rule for handlers, \nand a rule for the interaction of algebraic operations and handlers. These rules have manyconsequences \nin their logic, and will surely be valid in our setting. There may also be useful abstract optimisa\u00adtions \ninvolving handlers, possibly unifying existing accounts [4]. Effect reconstruction is of immediate importance. \nIt should be possible to derive general algorithms for type and effect annotation. Our semantics can \nthen be used to give semantics to such programs. Levy s translations of call-by-value and call-by-name \ninto CBPV could then be used to deduce general effect systems for these paradigms, generalising and unifying \nexisting work. Notions of locality, particularly local state, are very important. It may be possible \nto make use of work on the algebraic treatment of locality, e.g., [29, 34, 42], to obtain a more general \noptimisation theory. This should enable the work of Benton et al. on dynamic allocation [8] to be incorporated. \n(Incorporating higher-order store [6] would require solving recursive domain equations [1, 25].)  op \nO input output raise throw rollback abort lookup.0 update.0 . .Swap O, lookup. , update. , . lookup. \n, update. lookup. , update. lookup. , raise, . lookup. lookup. , update. , rollback, . lookup. , update. \nO, input, output, raise, throw, abort, rollback, abort, lookup. , update..=.0, . O, input, output, rollback, \nabort, lookup..=.0, update..=.0, . O, raise, throw, rollback, abort, lookup. , update. , . .WSwap \\ .Swap \n\u00d8 . . \u00d8 . \u00d8 . \u00d8 lookup.0 \u00d8 .ISwap \\ .WSwap \u00d8 input output \u00d8 \u00d8 \u00d8 \u00d8 update.0 \u00d8 input, output |s| \\ .ISwap \ninput, output, raise, throw, rollback, abort O, output, raise, throw, rollback, abort O, input, raise, \nthrow, rollback, abort O, input, output, throw, rollback, abort, update. O, input, output, raise, throw, \nrollback, abort, update. O, input, output, raise, throw, abort O, input, output, raise, throw, rollback, \nabort \u00d8 raise, throw, update.0 \u00d8 Figure 8. Swap Sets In a different direction, the distributive combination \nof theo\u00adries [17] (used for combining ordinary and probabilistic compu\u00adtation) should be investigated. \nAlso, our theory should be extended to include non-algebraic effects, such as continuations [20]. Our \narities are required to be ground, .nite and discrete. The .niteness and discreteness conditions can \nbe relaxed by using, respectively, in.nitary (in)equational theories [39]; and enriched Lawvere theories \n[38]. Our treatment of the .nite discrete case exploited inequational logic; in the in.nitary, enriched \ncase, cor\u00adresponding proof theories are needed [32]. Generalising arities to non-ground types may involve \nrecursive domain equations, as in thehypothesised treatment of higher-order store. The logic we used \nfor our optimisations is a simple equational logic we have only considered equations between terms. \nIt seems straightforward to devise a richer effect-dependent counter\u00adpart to Plotkin and Pretnar s logic \n[36, 40]. Additional work is needed to distill the general account into methodologies. In particular, \nit is desirable to reproduce the ex\u00adponential improvement in operation-wise validation for the other \noptimisations. Also, machine assistance and model-checking tools could alleviate the repetitiveburdenof \noperation-wise validation. We conjecture that Benton et al. s logical relations method can be related \nto the conservative restriction model. Our approach is de\u00adnotational; it would be interesting to devise \nan operational account [22, 33]. A precise relationship between our theory and Atkey s is in order, particularly \nwith his parameterised monads. Finally it would be good to go beyond Gifford-style, e.g., allowing effect \ntraces, and to account for parallelism, as in Gifford s work [27]. Acknowledgments We thank Robert Atkey, \nAndrej Bauer, Nick Benton, Jeff Egger, Ben Kavanagh, Neelakantan Krishnaswami,Paul Levy, Sam Lind\u00adley, \nMatija Pretnar, Alex Simpson, RossTate, PhilWadler, and the anonymous reviewers for helpful discussions \nand comments. This research was supported by a Scottish Informatics and Computer Science Alliance studentship \nandaRoyal SocietyWolfsonAward. References [1] S. Abramskyand A.Jung. Hand. of Log. in CS, 3:1 168, 1994. \n[2] R. Atkey. Proc. 3rd CALCO, 3 17, 2009. [3] R. Atkey. JFP, 19:335 376, 2009. [4] N. Benton andP. Buchlovsky. \nProc. 3rd TLDI, 15 26, 2007. [5] N. Benton and A.Kennedy. ENTCS, 26:3 20, 1999. [6] N. Benton et al. \nProc. 11th PPDP, 301 312, 2009. [7] N. Benton et al. Proc. 4th APLAS, 114 130, 2006. [8] N. Benton et \nal. Proc. 9th PPDP, 87 96, 2007. [9] B. Eckmann andP.J. Hilton. Math. Ann., 145(3):227 255, 1962. [10] \nA. Filinski. Proc. 26th POPL, 175 188, 1999. [11] A. Filinski. TCS, 375(1-3):41 75, 2007. [12] A. Filinski. \nProc. 37th POPL, 483 494, 2010. [13] C.F\u00a8PhD thesis, University of Edinburgh, 2000. uhrmann. [14] C.F\u00a8uhrmann. \nProc. 5thFoSSaCS, 144 158, 2002. [15] A. D. Gordon and A.Jeffrey. J. Comput. Secur., 12:435 483, 2004. \n[16] M. Hennessyand G. D. Plotkin. Proc. 8th MFCS, 108 120, 1979. [17] M. Hyland andJ. Power. TCS, 366(1-2):144 \n162, 2006. [18] M. Hyland andJ. Power. ENTCS, 172:437 458, 2007. [19] M. Hyland, G. D. Plotkin, andJ. \nPower. TCS, 357(1-3):70 99, 2006. [20] M. Hyland et al. TCS, 375(1-3):20 40, 2007. [21] B.Jacobs. Annals \nof Pure and Applied Logic, 69(1):73 106, 1994. [22] P.Johann et al. Proc. 25th LICS, 209 218, 2010. [23] \nR. B. Kieburtz. Proc. 3rd ICFP, 51 62, 1998. [24] A.Kock. Mathematica Scandinavia, 29:161 174, 1971. \n[25] P. B. Levy. Proc. 16th CSL, 232 246, 2002. [26] P. B. Levy. Call-by-Push-Value, Springer, 2004. \n[27] J. M. Lucassen and D. K. Gifford. Proc. 15th POPL, 47 57, 1988. [28] D. Marino andT. Millstein. \nProc. 4th TLDI, 39 50, 2009. [29] P.-A. Melli` es. Proc. 25th LICS, 150 159, 2010. [30] J. C. Mitchell. \nHand. of TCS, B:365 458, 1990. [31] G. D. Plotkin. SIAMJ. of Computing, 5:452 487, 1976. [32] G. D. Plotkin. \nLNCS, 4060:150 156, 2006. [33] G. D. Plotkin andJ. Power. Proc. 4thFoSSaCS, 1 24, 2001. [34] G. D. Plotkin \nandJ. Power. LNCS, 2303:342 356, 2002. [35] G. D. Plotkin andJ. Power. ENTCS, 73:149 163, 2004. [36] \nG. D. Plotkin and M. Pretnar. Proc. 23rd LICS, 118 129, 2008. [37] G. D. Plotkin and M. Pretnar. Proc. \n19th ESOP, 80 94, 2009. [38] J. Power. Theoryand Applications of Categories, 6:83 93, 2000. [39] J. Power. \nENTCS, 161:59 71, 2006. [40] M. Pretnar. PhD thesis, University of Edinburgh, 2009. [41] J. Reynolds. \nProc. 2nd ICALP, 141 156, 1974. [42] S. Staton. ENTCS, 249:471 490, 2009. [43] T. Coquand et al. Inf. \nComp., 93(1):172 221, 1991. [44] M.Tofte andJ.-P.Talpin. Inf. Comp., 132(2):109 176, 1997. [45] A.P.Tolmach. \nProc. 2nd TIC, 97 115, 1998. [46] P.Wadler. Proc. 3rd ICFP, 63 74, 1998. [47] P.Wadler andP. Thiemann. \nACMTrans. Comp. Log., 4(1):1 32, 2003. [48] A. K. Wright and M. Felleisen. Inf. Comp., 115(1):38 94, \n1994.  \n\t\t\t", "proc_id": "2103656", "abstract": "<p>We present a general theory of Gifford-style type and effect annotations, where effect annotations are sets of effects. Generality is achieved by recourse to the theory of algebraic effects, a development of Moggi's monadic theory of computational effects that emphasises the operations causing the effects at hand and their equational theory. The key observation is that annotation effects can be identified with operation symbols. We develop an annotated version of Levy's Call-by-Push-Value language with a kind of computations for every effect set; it can be thought of as a sequential, annotated intermediate language. We develop a range of validated optimisations (i.e., equivalences), generalising many existing ones and adding new ones. We classify these optimisations as structural, algebraic, or abstract: structural optimisations always hold; algebraic ones depend on the effect theory at hand; and abstract ones depend on the global nature of that theory (we give modularly-checkable sufficient conditions for their validity).</p>", "authors": [{"name": "Ohad Kammar", "author_profile_id": "81488671208", "affiliation": "University of Edinburgh, Edinburgh, Scotland Uk", "person_id": "P2991418", "email_address": "ohad.kammar@ed.ac.uk", "orcid_id": ""}, {"name": "Gordon D. Plotkin", "author_profile_id": "81100235459", "affiliation": "University of Edinburgh, Edinburgh, Scotland Uk", "person_id": "P2991419", "email_address": "gdp@ed.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103698", "year": "2012", "article_id": "2103698", "conference": "POPL", "title": "Algebraic foundations for effect-dependent optimisations", "url": "http://dl.acm.org/citation.cfm?id=2103698"}