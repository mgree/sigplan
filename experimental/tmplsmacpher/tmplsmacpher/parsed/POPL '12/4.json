{"article_publication_date": "01-25-2012", "fulltext": "\n Towards a Program Logic for JavaScript Philippa Gardner Sergio Maffeis Gareth Smith Imperial College \nLondon Imperial College London Imperial College London pg@doc.ic.ac.uk ma.eis@doc.ic.ac.uk gds@doc.ic.ac.uk \n Abstract JavaScript has become the most widely used language for client\u00adside web programming. The dynamic \nnature of JavaScript makes understanding its code notoriously dif.cult, leading to buggy pro\u00adgrams and \na lack of adequate static-analysis tools. We believe that logical reasoning has much to offer JavaScript: \na simple description of program behaviour, a clear understanding of module boundaries, and the ability \nto verify security contracts. We introduce a program logic for reasoning about a broad subset of JavaScript, \nincluding challenging features such as prototype inheritance and with. We adapt ideas from separation \nlogic to provide tractable reasoning about JavaScript code: reasoning about easy programs is easy; reasoning \nabout hard programs is possible. We prove a strong soundness result. All libraries written in our subset \nand proved correct with respect to their speci.cations will be well-behaved, even when called by arbitrary \nJavaScript code. Categories and Subject Descriptors F.3.1 [Theory of Computa\u00adtion]: Logics and Meanings \nof Programs Specifying and Verify\u00ading and Reasoning about Programs General Terms Reliability, Theory, \nVeri.cation Keywords JavaScript, Separation Logic, Web 1. Introduction JavaScript has become the de-facto \nlanguage for client-side web programming. Ajax web applications, used in e.g. Google Docs, are based \non a combination of JavaScript and server-side pro\u00adgramming. JavaScript has become an international standard \ncalled ECMAScript [14]. Adobe Flash, used in e.g. YouTube, features ActionScript, a programming language \nbased on ECMAScript. Even web applications written in e.g. Java, Fr or purpose-designed languages such \nas Flapjax or Milescript are either compiled to JavaScript, or they lack browser integration or cross-platform \ncom\u00adpatibility. JavaScript is currently the assembly language of the Web, and this seems unlikely to \nchange. JavaScript was initially created for small web-programming tasks, which bene.ted from the .exibility \nof the language and tight browser integration. Nowadays, the modern demands placed on JavaScript are \nhuge. Although this .exibility and browser integra\u00adtion are still key advantages, the inherent dynamic \nnature of the language makes current web code based on ECMAScript 3 noto- Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 12, January 25 27, 2012, Philadelphia, \nPA, USA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. . . $10.00 riously dif.cult to write \nand use [12, 18, 28]. The expectation is that ECMAScript 5 and future standards will improve the situation. \nHowever, although the main browsers now support ECMAScript 5, the majority of code being written today \nis in ECMAScript 3. Even if there is a wide acceptance of ECMAScript 5, which is certainly not clear \nfrom the current blogs, it is inevitable that ECMAScript 5 libraries will have to interface properly \nwith ECMAScript 3 code. We therefore believe that there is a growing need for general\u00adpurpose, expressive \nanalysis tools for both ECMAScript 3 and 5, which provide simple, correct descriptions of program behaviour \nand a clear understanding of module boundaries. We introduce a program logic for reasoning about ECMAScript \n3. While it is tempting to ignore the ugly parts of the language, and reason only about well-written \ncode, in practice JavaScript pro\u00adgrams have to interface with arbitrary web code. We therefore use a \nmodel of the language that does not shun the most challenging JavaScript features. For example, the behaviour \nof prototype in\u00adheritance, and the interplay between scoping rules and the with statement, is complex. \nThis means that our basic reasoning rules must also be complex. We overcome this complexity by estab\u00adlishing \nnatural layers of abstraction on top of our basic reasoning. With principled code, we can stay within \nthese layers of abstrac\u00adtion and the reasoning is straightforward. With arbitrary code, we must break \nopen the appropriate abstraction layers until we can re-establish the invariants of the abstraction. \nIn this way, we are able to provide clean speci.cations of a wide variety of JavaScript programs. Our \nreasoning is based on separation logic. Separation logic has proven to be invaluable for reasoning about \nprograms which di\u00adrectly manipulate the heap, such as C and Java programs [2, 3, 8, 20, 36]. A key characteristic \nof JavaScript is that the entire state of the language resides in the object heap, in a structure that \nim\u00adperfectly emulates the variable store of many other programming languages. It is therefore natural \nto investigate the use of separation logic to verify JavaScript programs. In fact, we had to fundamen\u00adtally \nadapt separation logic, both to present an accurate account of JavaScript s emulated variable store (see \nSection 2: Motivating Ex\u00ad amples) and also to establish soundness. For soundness, it is usual to require \nthat all the program commands are local , according to a de.nition .rst given in [20]. Many JavaScript \nstatements are not local by this de.nition: for example, even a simple variable read is non-local because \nits result may depend on the absence of certain .elds in the emulated variable store. We instead prove \nsoundness using a concept of weak locality, recently introduced by Smith [30]. In this paper, we reason \nabout a substantial subset of JavaScript, including prototype inheritance, with, simple functions (no \nrecur\u00adsive or higher-order functions) and simple eval. Our treatment of functions and eval is precisely \nenough to expose fully the com\u00adplexity of the emulated variable store. Building on the work of Charlton \nand Reus [6, 29], we will extend our reasoning to higher\u00ad order functions and complex eval in future. \nWe prove soundness of our reasoning with respect to a faithful subset of the formal  Figure 1. A JavaScript \nemulated variable store operational semantics of Maffeis et al. [18]. Our soundness re\u00ad sult has powerful \nimplications. Library code written in our sub\u00adset and proved correct with respect to their speci.cations \nwill be well-behaved, even when called by arbitrary JavaScript code. Our result is constructed in such \na way that it will be simple to extend to reasoning about higher-order functions and complex eval in \ndue course. 2. Motivating Examples As convincingly argued in [12, 18, 27, 28], there are many reasons \nwhy the behaviour of JavaScript programs is complex. For a start, JavaScript is a dynamically typed, \nprototype-oriented language, which does not have a standard notion of variable store. Instead, JavaScript \nvariables are best regarded as being stored in the heap, in a structure which imperfectly emulates the \nvariable store. This structure consists of an abstract list of scope objects, called the scope chain, \nanalogous to stack frames in other languages. Every scope object has a pointer to a linked list of prototypes, \nproviding prototype-based inheritance. Since scope objects inherit data from their prototypes, the value \nof a variable cannot be resolved by a simple list traversal. Variable resolution is further complicated \nby the fact that JavaScript objects may share a common prototype. JavaScript s behaviour can make apparently \nsimple programs deceptively counter-intuitive. Consider the code C de.ned below: x = null; y = null; \nz = null; f = function(w){x = v; v = 4; var v; y = v;}; v = 5; f(null); z = v; What values should the \nvariables x, y and z store at the end of the program? The correct answer is undefined, 4 and 5 respectively. \nWe explain how this occurs as we walk through our reasoning. In Section 6.2 we prove the following triple \nof this code: . storeLS(x, y, z, f, v|) * l = LSC .L. storeLS(|x : undefined, y :4, z :5, f :L, v : \n5) . * l = LS * true We distinguish a global logical expression l with value LS denoting the scope chain. \nThe store predicate storeLS(x, y, z, f, v|) states that the store-like structure referred to by LS contains \nnone of the program variables mentioned; the variables occur to the left of the bar. The store predicate \nstoreLS(|x : undefined, y :4, z :5, f : L, v : 5) denotes the .nal values for all the variables; the \nvariables occur to the right of the bar with assigned values. To understand the complexity of the heap \nstructures described by store predicates, consider the example heap given in Figure 1. This diagram illustrates \na typical shape of a JavaScript variable store. Each object is denoted by a box. In this example, the \ncur\u00adrent list of scope objects is given by l =[l1,l2,l3,l4,lg], where the li are object addresses and \nlg is a distinguished object con\u00adtaining the global variables which must occur at the end of the current \nlist of scope objects. Each scope object has a pointer to a list of prototypes, with the arrows representing \nprototype relation\u00adships. These prototype lists can be shared, but cannot form cycles. In ECMAScript \n3, prototype lists must either end with the distin\u00adguished object lop or be empty. However, many implementations \n(SpiderMonkey, V8 and WebKit) allow the programmer to directly access and change the prototype pointers, \nallowing incomplete pro\u00adtotype chains ending in null but not allowing the creation of cy\u00adcles. We work \nwith incomplete prototype chains, since we want ECMAScript 3 library code to work well with such implementa\u00adtions. \nTo look up the value of a variable x in our example heap, we check each object for a .eld with name x, \nstarting with l1, checking the prototype list from l1 then moving along the list of scope objects. In \nour example, the x in object l will be found .rst, since the whole prototype chain of l2 will be visited \nbefore l3. When reading the value stored in x, this is all we need to know. If we write to the same variable \nx, the effect will be to create a new .eld x at l2. This new .eld will override the x .eld in object \nl in the usual prototype-oriented way. All of this messy detail is abstracted away by the store pred\u00adicate. \nThe formation of this predicate is subtle and requires some adaptation of separation logic. As well as \nthe separating conjunc\u00adtion * for reasoning about disjoint heaps, we introduce the sepish connective \nW* for reasoning about partially separated heaps. It is used, for example, to account for the sharing \nof prototype lists il\u00adlustrated in Figure 1. We also use the assertion (l, x) . y, which states that \nthe .eld x is not present at object address l. This pred\u00adicate is reminiscent of the out predicate in \n[7] stating that values are not present in a concurrent list. It is necessary to identify the .rst x \nin the structure: in our example, the x at l is the .rst x, since it does not occur in the prototype \nlist of l1 nor in the prototype list of l2 until l. Our store predicate allows us to make simple inferences \nabout variable assignments, without breaking our store abstraction: . storeLS(x, y, z, f, v|) * l = \nLSx = null; storeLS(y, z, f, v|x : null) . * l = LS * true where the assertion true hides potentially \ngarbage-collected proto\u00adtype lists. The evaluation of the function expression function(w) {...}has the \neffect of creating a new function object and returning the address L of that object. The object contains \na number of internal housekeeping .elds, including @body which contains the body of the function and \n@scope which stores the function closure LS. Our inference for the function de.nition is approximately: \n . storeLS(f, v|x : null, y : null, z : null) * l = LSf = function(w) {...} . . . .L. storeLS(v|x : null, \ny : null, z : null, f : L) * . (L, @body) . .w.{... }* (L, @scope) . LS * . . . l = LS * true As well \nas the store predicate, we assert that the state also contains object cells such as (L, @scope) . LS. \nThis assertion means that there is an object with address L in the heap, and it de.nitely contains at \nleast the .eld @scope which has value LS. The assertion says nothing about any other .eld of L. We assert \nthat our function object has .elds @body and @scope. The full speci.cation, given in Section 6.2, is \nactually a little more complicated than this. For now, we hide additional housekeeping .elds in the assertion \ntrue.  We know that this program example is challenging, because the .nal values of the variables are \ncounter-intuitive. All the complex\u00adity of the example occurs within the function call. When JavaScript \ncalls a function, it performs two passes on the body: in the .rst pass, it creates a new scope object \nand initialises local variables to undefined; in the second pass, it runs the code in the newly con\u00adstructed \nlocal scope. Our reasoning re.ects this complexity. The Hoare triple for the function call has the following \nshape: .. .. storeLS(|x : null, y : null, z : null, f :L, v : 5) * (L, @body) . .w.{... }* (L, @scope) \n. LS * obtained using the consequence rule to hide the function object and local scope object behind \nthe assertion true, since they are surplus to requirements, and existentially quantifying function object \nL: .L. storeLS(|x : undefined, y :4, z :5, f :L, v : 5)* . l = LS * true Part of the challenge of understanding \nthis example is knowing the scope of local variable v. In JavaScript, variables can only be declared \nlocal to functions, not other blocks such as if and while. This can lead to undesirable behaviour, especially \nwhen a local variable overloads the name of a global variable. One controversial . . l = LS * true . \ntechnique for solving this problem is to use the with statement f(null); and a literal object to declare \nlocal variable blocks precisely where ??? they are needed. Using with is often considered bad practice, \nand it is deprecated in ECMAScript 5. However, it is widely used in To .nd a suitable postcondition, \nwe must reason about the practice [22, 28] and can certainly be used to improve the program readability. \nWe are able to reason about even extremely confusing uses of with. Consider the program C': a = {b:1}; \nwith (a){f=function(c){return b}}; a = {b:2}; f(null) Armed with an operational understanding of JavaScript \ns emu\u00ad lated variable store, it is not so dif.cult to understand that this pro\u00adfunction body. The precondition \nof the function-body triple given below is constructed from the .rst pass of the function call. As well \nas containing the precondition of the function call, it contains a new scope object L' with .elds given \nby the parameter of the function and the local variables discovered by the .rst pass. For our example, \nit contains the assertions (L', w) . null for the parameter declaration and (L', v) . undefined for the \nlocal variable declaration. The object L' also has a @proto .eld, which points to null since scope objects \ndo not inherit any behaviour, and a @this .eld, which can only be read. We also have the predicate newobj(L', \n@proto, @this, w, v), which asserts the absence from gram returns the value 1, even though the value \nof a.b at the end of the program is 2. It may not be quite so clear that this program can fault. It may \nalso execute arbitrary code from elsewhere in the L' of all the .elds we have not mentioned as parameters. \nKnowing emulated variable store, leading to a possible security violation. this absence of .elds is essential \nif, in the function body, we wish We only understood this example properly by doing the veri.\u00adto write \nto variables, such as the x and y, which do not appear in the local scope object. Finally, the new scope \nobject L' is prepended to the scope list l. Using this precondition, we are now able to give the triple \ncation. In Section 6.2, we prove the triple: {storel(a, f|) W* (lop, f) . y W* (lop, @proto) . null}C' \n. {r =1 * true} obtained by the second pass of the function call: A similar proof is possible for a precondition \nwhere a and f are in the store with arbitrary values. Either precondition ensures the pro\u00ad gram returns \nthe value 1 as expected. The obvious .rst try was to . .. . . . .. . . . .L'. l =L' : LS * storeLS(|x \n: null, y : null, z : null, f :L, v : 5) * have e.g. just storel(a, f|) as the precondition. This does \nnot work as, when reasoning about the assignment to the variable f, we can\u00adnot assert that the variable \nf is not in the local scope. As discussed earlier, we work with incomplete prototype chains in the emulated \n(L, @body) . .w.{... }* (L, @scope) . LS * newobj(L', @proto, @this, w, v)* (L', w) . null * (L', v) \n. undefined * (L', @proto) . null * (L', @this) . L'' * true . . .. . . .. variable store. With some \nweb code, it is possible for programmers to directly access and change the prototype pointers, resulting \nin the distinguished object lop not being a part of the emulated variable store. This means that lop \nmay contain the .eld f without violating x=v; v= 4;varv;y=v; . .L'. l =L' : LS * storeLS(|x : undefined, \ny :4, z : null, f :L, v : 5) * (L, @body) . .w.{... }* (L, @scope) . LS * . . . . . . . . our proposed \nprecondition. The statement a= {b:1} then results in the creation of a new object L, with no .eld f as \nexpected, but with .eld @proto pointing to lop which may contain f: newobj(L' , @proto, @this, w, v)* \n(L', w) . null * (L', v) . 4 * (L', @proto) . null * (L', @this) . L'' * true .. . . .. . . The postcondition \nfollows simply from the three assignments in the function body: .rst, variable x gets the value undefined, \nsince this is the current value of the local v; then the local v is assigned 4; and, .nally, the global \nvariable y is assigned the value of the local variable v. The var v statement has no effect in the second \npass of the function call. The postcondition of the function call is the postcondition of the function \nbody, with local scope object L' popped off the current scope list l: . . . .L'. storeLS(|x : undefined, \ny :4, z : null, f :L, v : 5) * (L, @body) . .w.{... }* (L, @scope) . LS * .L. (L, b) . 1 * (L, f) . y \n* (L, @proto) . lop The with statement makes this new object L the most local cell in our emulated variable \nstore. But because f is an inher\u00adited property of L, the meaning of the assignment to f has now changed \n it has become an overriding assignment of a local variable. We write the new function f into the most \nlocal ob\u00adject L. When the program returns from the with statement, the function call to f(null) will \nfault, since there is no f in scope to call. In many web browsers (including Chrome, Firefox, and Safari), \nthis behaviour can be induced by running the program C' Object.prototype.f = 4 ; window. proto = null \n; . . . newobj(L' , @proto, @this, w, v)* (L', w) . null * (L', v) . 4 * (L' . (L', @this) . L'' * \nl = LS * true , @proto) . null * .. . in the default starting state1. The proto notation allows the \nprogrammer to directly access and change the internal @proto Reasoning about the .nal assignment is \nstraightforward, with z as-1 In web browsers, Object.prototype usually contains a pointer to the signed \nthe value of the global variable v. The .nal postcondition is object lop and window usually contains \na pointer to the object lg. .elds, resulting in a program state which causes the program C ' to fault. \nNon-standard features such as this are widely used in practice, and so it is important that our reasoning \nbe robust to the states they produce. In this example, it is possible to induce a similarly tricky starting \nstate without the use of any non-standard features, which results in the call to f() executing arbitrary \ncode not mentioned in our program. Consider running the program ' C '' Object.prototype.f = function(c) \n{C '' };C where is suspicious code. This could result in a security breach if f is passed sensitive data. \n3. Operational Semantics We de.ne a big-step operational semantics for a large subset of JavaScript that \nrepresents faithfully the inheritance, prototyping and scoping mechanisms described in the ECMAScript \n3 standard. Our semantics follows closely the full small-step JavaScript seman\u00adtics of Maffeis, Mitchell \nand Taly [18], except that we make some simpli.cations as discussed in Section 3.5. We work with a big-step \nsemantics because it connects better to our reasoning. 3.1 Heaps The JavaScript heap is a partial function \nH: R -V that maps references, r .R = L\u00d7X , which are pairs of memory locations and .eld names, to values. \nThis structure emphasises the important role that references play in the semantics of the language. Values \nv .V can be basic values v, locations l and lambda abstractions .x.e. The set of locations L is lifted \nto a set Lnull containing the special location null, analogous to a null-pointer in C, which cannot be \nin the domain of any heap. We denote the empty heap by emp, a heap cell by (l, x) . v, the union of two \ndisjoint heaps by H1 * H2, and a read operation by H(l, x). An object is represented by a set of heap \ncells addressed by the same location but with different .eld names. For ease of notation, we use l .{x1: \nv1,...,xn: vn} as a shorthand for the object (l, x1) . v1 * ... * (l, xn) . vn. As discussed, JavaScript \nhas no variable store. Instead, variables are resolved with respect to a scope object implicitly known \nat run time. Scope objects are just objects whose locations are recorded in the scope chain (we use a \nstandard notation [],e:L, L + L for lists). Each scope object has a pointer to a prototype list (which \nneed not point to lop). A variable x is resolved as the property named x of the .rst object in the scope \nchain whose prototype list de.nes x . Scoping constructs, such as function calls and with, cause sub-expressions \nto be evaluated with respect to a local scope object, by putting the local scope object at the beginning \nof the scope chain and then removing it after the sub-expressions have been evaluated. All user programs \nare evaluated starting from the default scope chain [lg], where lg is the location of the global JavaScript \nobject, described below. The .nal object in any scope chain is always lg, but duplicates in a scope chain \nare allowed. For example, the JavaScript program with(window){C} is perfectly valid, and (usually) results \nin the subprogram C being evaluated in a state in which lg is both the most global and the most local \nobject. The auxiliary scope function s, de.ned below, returns the loca\u00adtion of the .rst object in the \nscope chain to de.ne a given variable. It depends on the prototype function p, which returns the location \nof the .rst object in the prototype chain to de.ne the variable. Scope and prototype resolution: s(H, \nl, x) and p(H, l, x). s(H, [],x) null p(H, l, x) p(H, l, x)= null = null s(H, l:L, x) ls(H, l:L, x) s(H, \nL, x) p(H, null,x) null (l, x) . dom(H)(l, x) . dom(H) H(l, @proto)= l ' p(H, l, x) lp(H, l, x) p(H, \nl ' ,x) The set of variable names X is partitioned in two disjoint sets: the internal variable namesX \nI and the user variable names X U. The internal names X I {@scope, @body, @proto, @this} are not directly \naccessible by user-de.ned ECMAScript 3 code, but are used by the semantics. As noted in Section 2, some \nimple\u00admentations do give programmers direct access to some of these internal variables, but we do not \nmodel those implementation\u00addependant programs. We do model all the program states that such programs \nmight create, and take care not to make strong assump\u00adtions about the types or values of those suspect \ninternal variables. In this way, libraries veri.ed using our techniques are robust in the presence of \nunveri.ed real-world code. User names are denoted by x, y, z .X U and are considered a subset of strings; \nkeywords such as var are not valid variable names. It is worth anticipating at this point a subtlety \nof the JavaScript semantics. The evaluation of a user variable x does not return its value, but rather \nthe refer\u00adence l ' \u00b7x where such value can be found (l ' is obtained using the s predicate). In general, \nthe values r .VR returned by JavaScript expressions can be normal values V or references R. When a user \nvariable x needs to be dereferenced in an expression, the semantics implicitly calls the dereferencing \nfunction ., de.ned below, which returns the value denoted by the reference. Dereferencing values: .(H, \nr). p(H, l, x)= null p(H, l, x)= l ' r = l\u00b7x l l '= null = null .(H, r) r .(H, l\u00b7x) undefined .(H, l\u00b7x) \nH(l ' , x) We introduce the de.nition of a well-formed JavaScript heap. A JavaScript expression can only \nbe evaluated in a sub-heap of a well\u00adformed heap, with respect to a valid scope chain. All JavaScript \nexpressions maintain the well-formedness of heaps. A heap H is well-formed (denoted by H f0) if its objects \nand prototype chains are well-formed (prototype chains must be acyclic, they can end with null rather \nthan lop), and if it contains the global scope object lg and the distinguished objects lop and lfp, which \nwe will see later serve as the default prototypes for new objects and functions. A scope chain L is valid \nwith respect to heap H, denoted by schain(H, L), if all the locations in the chain correspond to objects \nallocated in H, and if it ends with the global object lg. Formal de.nitions are given in [11]. The default \ninitial state H\u00d8 is the smallest well-formed heap that also contains the special function object le (the \neval function) and its prototype lep: obj(lg,lop) * obj(lop, null) H\u00d8 * obj(lfp,lop) * obj(le,lep) \n* obj(lep,lop) where obj(l, l ' ) denotes an object at location l which is empty except for the prototype \nl ' : obj(l, l ' ) (l, @proto) . l ' We conclude this section by de.ning the heap update -[-] operation \nwhich will be used by the semantics. Many JavaScript expressions update a heap cell if it is present, \nor create it if it is not present. We re.ect this form of update in our heap update operation. Update \nH[(l, x) . v]. (l, x) . dom(H) l= null H[(l, x) . v] H * (l, x) . v ' (H * (l, x) . v)[(l, x) . v ' ] \nH * (l, x) . v H[(null, x) . v] H[(lg, x) . v] The last rule says that an update to a non-allocated reference \n(whose location is null) has the effect of allocating and updat\u00ading a new global variable, which mimics \nJavaScript s behaviour of implicitly creating global variables when a variable name is .rst used.  \n3.2 Values and Expressions To aid our presentation, we introduce the syntax of all JavaScript programs, \nstatements and expressions simply as expressions. Our operational semantics will only describe the behaviour \nof well\u00adformed programs, as de.ned by [18]. Syntax of terms: values v and expressions e. v ::= n | m \n| undefined | null e ::= e; e | x | v | if(e){e}{e}| while(e){e}| var x | this | delete e | e . e | e.x \n| e(e) | e=e | function (x){e}| function x(x){e}| new e(e) |{x1 : e1 ... xn : en}| e[e] | with(e){e}where \n..{+, -, *, /, &#38;&#38;, ||, ==,.} A basic value v can be a number n, a string m (including the user \nvariable names), the special constant undefined or the null loca\u00adtion. The operator . denotes a standard \nnumber and boolean opera\u00adtor, or string concatenation. Expressions e include sequential com\u00adposition, \nvariable lookup, literal values, conditional expressions, loops, local variable declaration, this, deletion, \narithmetic and string concatenation, object property lookup, function call and eval, assignment, function \ndeclaration, recursive functions, constructors, literal objects, computed access and the with statement. \n 3.3 Evaluation Rules An expression e is evaluated in a heap H, with respect to a scope 'chain L. If \nit successfully terminates, it returns a modi.ed heap H and a .nal value r. Selected evaluation rules \nare given below and then discussed. See [11] for the full de.nition. Recall that the set of variables \nis a subset of the set of strings, that a heap value v can be a basic value v, a memory location l or \na function closure .x.e, and that a return value r can also be a reference l\u00b7x. ' Operational semantics: \nH, L, e -. H ,r. . ' '' Notation: H, L, e -. H ,v .r.(H, L, e -. H ,r . .(H ,r)= v). (De.nition) ' (Value) \nH, L, e -. H ,v H, L, v -. H, v ' H, L, var e -. H, undefined (Computed Access) (Member Access) . . H, \nL, e1 -. H1,l H, L, e -. H ' ,l l = null l = null . ' H1, L, e2 -. H, x H, L, e.x -. H ' ,l\u00b7x ' H, L, \ne1[e2] -. H ,l\u00b7x (Object) (Variable ) H0 = H * obj(l, lop) o . ' s(H, L, x)= lHi-1, L, ei -. Hi,vi .i \n. 1..n. ' Hi = H [(l, xi) . vi]H, L, x -. H, l\u00b7x i H, L, {x1:e1,..., xn:en} -. Hn,l (Binary Operators) \n(Assignment) . '' H, L, e1 -. H, v1 H, L, e1 -. H1,l\u00b7x .. ' H '' , L, e2 -. H, v2 H1, L, e2 -. H2,v ' \nv1 . v2 = v H = H2[(l, x) . v] ' ' H, L, e1 . e2 -. H, v H, L, e1=e2 -. H ,v (This) s(H, L, @this)= l1 \n(Function) ' p(H, l1, @this)= l2 H = H * obj(l, lop) * fun(l ' , L, x, e,l) H(l2, @this)= l ' H, L, function \n(x){e} -. H ' ,l ' H, L, this -. H, l ' (Function Call) H, L, e1 -. H1,r1 This(H1,r1)= l2 .(H1,r1)= l1 \nl1 = le H1(l1, @body)= .x.e3 H1(l1, @scope)= L ' . H1, L, e2 -. H2,v . '' H3 = H2 * act(l, x, v, e3,l2) \nH3,l:L ' , e3 -. H ,v '' H, L, e1(e2) -. H ,v (Eval) .. H, L, e1 -. H1,le H1, L, e2 -. H2, m . '' parse(m)= \ne H2, L, e -. H ,v '' H, L, e1(e2) -. H ,v (With) . H, L, e1 -. H1,l ' s, p, ., obj de.ned earlier H1,l:L, \ne2 -. H ,r fun, this, act de.ned below ' H, L, with(e1){e2} -. H ,r We brie.y discuss some of the evaluation \nrules that show non\u00adstandard features typical of JavaScript. Rule (De.nition) for var e simply executes \ne and throws away the return value. The var dec\u00adlaration is only used by defs (de.ned below) to identify \nfunction local variables. Rule (Variable) uses s to determine the scope ob\u00adject where a given variable \ncan be found, without de-referencing the variable. Rules (Member/Computed Access) return a reference \nto the object .eld denoted by the corresponding expressions. Rule (Object) uses the obj notation introduced \nin Section 3.1 to introduce a fresh, empty object at location l, and then initialises its .elds ac\u00adcordingly. \nFreshness is ensured by well-formedness of H and dis\u00adjointness of *. Rule (Binary Operators) assumes \nthe existence of a semantic version . for each syntactic operator .. Each . is a partial function, de.ned \nonly on arguments of a basic type (in this case numbers or strings) and returning results of some other \n(possi\u00adbly the same) basic type, corresponding to the intended meaning of the operation. Rule (Assignment) \nis quite subtle. Suppose we have the expression x=4. Now consider Figure 1 of Section 2. If x were de.ned \nas a .eld of the object l1 then x=4 would be an overwrit\u00ading assignment. The value of the .eld x in the \nobject l1 would be overwritten with the value 4. If x were not found anywhere, then it would be created \nas a global variable a .eld of the object lg. Fi\u00adnally, consider the actual case in this .gure: x is \nfound to be a .eld of object l, which is a prototype of l2, which is in the scope chain. In this case, \nx=4 is an overriding assignment, with the effect of cre\u00adating a new .eld x in the object l2 to override \nthe existing x in l. This complexity is handled in two places. Firstly, the variable rule uses the s \nfunction (de.ned in Section 3.1) to return a reference l2\u00b7x. Note that the s function does not return \na reference to l\u00b7x pre\u00adcisely because we wish to model this behaviour. Secondly, the heap update operation \nH2[...] manages the business of either overwriting an existing .eld or, in this case, creating a new \n.eld. Rule (This) re\u00adsolves the this identi.er. As we will see, when executing a method of an object, \nwe use the internal variable @this to store the loca\u00adtion of that object. When executing a function call, \n@this points to the global object lg. The (This) rule uses s and p to retrieve the value of @this which \nis then returned by the this statement. Rule (Function) introduces the notation fun(l ' , L, x, e,l) \nl ' .{@proto: lfp, prototype: l, @scope: L, @body: .x.e} to allocate a fresh function object at location \nl '. The internal pro\u00adtotype of the new function object points to the standard function prototype object \nlfp. The rule also creates a new empty object at l and stores a pointer to it in the prototype .eld of \nthe new func\u00adtion. If the function is ever used as a constructor (using the new keyword) then the object \npointed to by this prototype .eld will serve as the prototype of the newly constructed object. Note that \nthe .eld is mutable, and so may be used by a programmer to emulate a class-like inheritance structure. \n Recall from Section 2 that JavaScript function calls can be surprisingly complex. We now describe rule \n(Function Call), which uses two auxiliary functions This and act. Recall also that the rule (This) uses \ninternal @this .elds to determine the semantics of the this keyword. The values of the @this .elds are \ndetermined by the (Function Call) rule using the auxiliary function This: This(H, l\u00b7x) l [(l, @this) \n. dom(H)] This(H, r) lg [otherwise] To understand This, .rst notice that every newly created local scope \nobject has a @this .eld, while no other objects ever will2. The (Function Call) rule .nds a pointer to \na function in the location l\u00b7x. If l is a regular object (which has no @this .eld), then the function \nmust be a method of that object, and so the @this .eld of our new local scope object should point to \nl. On the other hand, if l is a special local scope object (which has a @this .eld), then the function \nmust be a regular function (and not a method), and so the @this of our new local scope object should \npoint to lg. This unique behaviour precisely captures the behaviour of the ECMAScript 3 this keyword. \nThe auxiliary function act describes the allocation of a new local scope object: act(l, x, v, e,l '' \n) l .{x: v, @this: l '' , @proto: null}* defs(x, l, e) The object is allocated at address l, and contains \na function pa\u00adrameter x with value v, the internal .elds @this, @proto and the local variables declared \nin an expression e. The auxiliary function defs, de.ned in [11], searches the function body e for instances \nof the var keyword, and sets all the appropriate .elds of our new lo\u00adcal scope object to the value undefined, \nas discussed in Section 2. Rule (Eval) looks like an ordinary function call, but the function be\u00ading \ncalled is not an ordinary function object. It is the special built-in object le. It assumes a partial \nfunction parse that parses a string m into a JavaScript expression e, only if there are no syntax errors. \nThe control expressions are mostly standard (see [11]), except for the unusual (With) rule that evaluates \ne2 in a scope-chain starting with the object obtained by evaluating e1.  3.4 Safety An important sanity \nproperty of the evaluation relation is that it preserves well-formedness of the heap, for any valid scope \nchain. Theorem 1 (Well-Formedness). Let H, L be such that H f0 and schain(H, L). If H, L, e -. H ' ,r \nthen H ' f0. Although the theorem is about end-to-end well-formedness, its proof (reported in [11]) shows \nthat starting from a well-formed state and scope chain, all the intermediate states and scope chains \nvisited during the computation are also well-formed, and all the locations occurring in intermediate \nreturn values correspond to objects effectively allocated on the heap.  3.5 JavaScript Subset We work \nwith a subset of JavaScript, in order to limit the size and complexity of our semantics for this paper. \nOur subset is substantial and, despite some minor omissions and simplifying assumptions discussed below, \nfaithful to the ECMAScript 3 standard. A signif\u00adicant property of our semantics is that our programs \nwill run reli\u00adably in states generated by any valid JavaScript program (including those reached by programs \nusing non-standard features that we do not model, such as proto ), or getters and setters. Our reasoning \nof Section 5 will therefore interface well with real-world JavaScript programs. We do not model implicit \ntype-coercion functions. Adding them is straightforward but would add signi.cantly to the length of our \n2 lg has @this in some, not all, implementations; [14] is silent on the issue. presentation. We have \nno boolean type. Instead, where control structures (if and while) require a boolean, we use other types \nwhose behaviour is equivalent to the type conversion that occurs in JavaScript. Values such as 0 and \nnull behave like false and values such as 1 and \"string\" behave like true. For simplicity, we use an \nimplicit return statement for functions. Moreover, our functions take only one parameter, rather than \nthe arbitrary list of parameters usual in JavaScript, and do not have the arguments object or the constructor \nproperty. As mentioned in Section 3.2, we simplify our presentation of JavaScript programs, statements \nand expressions, into a single class of expressions. We also omit several JavaScript constructs such \nas labels, switch and for, as they do not contribute signi.cantly to the problem of program rea\u00adsoning. \nIn this presentation we only consider the core language EC-MAScript 3, and do not model the many standard \nlibraries which browsers make available to programmers. Instead of exceptions, we have a single error \ncondition denoted fault. Our reasoning conser\u00advatively avoids faults. This means that programs which \nare proved using our fault-avoiding local Hoare reasoning will run without throwing exceptions in JavaScript \ninterpreters. 4. Assertion Language Our assertion language follows that of Parkinson and Bierman [4, \n23, 24], in their work on reasoning about Java. They use assertions of the form (l, x) . v to denote \nthat a partial heap contains the ob\u00adject l with .eld x which has value v. Using the separating conjunc\u00adtion \n* [20], the assertion ((l, x) . v) * ((l, y) . w) declares that a heap contains an object l which must \nhave two separate .elds x, y with the appropriate values. The assertion (l, x) . v * (l, x) . w is unsatis.able \nsince it declares two .elds x for l. This style of reasoning is not enough for JavaScript. We must also \nassert negative information about .elds not being in the heap, and extend the structural assertions of \nseparation logic to account for partial separation due to shared prototype chains. Recall the example \nof a JavaScript emulated variable store in Figure 1. To .nd the value of x in the store, we must not \nonly determine that the object l has a .eld x but also determine that no .elds named x occur earlier \nin the emulated store. We use assertions (l, x) . yto declare that a heap contains an object l which \ndoes not have a .eld x. The assertion (l, x) . y * (l, y) . w declares that the heap contains an object \nl which does not have .eld x but does have .eld y. The assertions (l, x) . v * (l, x) . y and (l, x) \n. y * (l, x) . y are unsatis.able. Thus, the assertion (l, x) . y states the full knowledge that .eld \nx is not in object l. Now consider what happens when we want to describe the state of more than one variable \nat a time. In Section 5 we introduce a predicate s which allows us to assert, for example, The variable \nx is found in the store in object l2 : s( , l, x,l2) or The variable y is not in the store : s( , l, \ny, null). Both of these assertions must make use of the @proto .elds in order to navigate the variable \nstore, so we cannot separate them using *. But the .rst assertion does not mention any y .eld, and the \nsecond assertion does not mention any x .eld, so we cannot join them with .. In order to make both assertions \nabout the same variable store, we need a way for them to share their common parts. To do this, we introduce \nthe sepish connective P W* Q which allows partial separation between heaps. We can use W* to describe \nthe state of more than one variable in a given store: s( , l, x,l2) W* s( , l, y, null), and we shall \nsee in Section 5 that it is also invaluable when de.ning the s predicate. An assertion may be satis.ed \nby a triple (h,L, E) consisting of an abstract heap h, a scope chain L, and a logical environment E. \nAn abstract JavaScript heap is a partial function H: R -V.{y} that maps references, r .R = L\u00d7X to values \nv .V or y. Abstract heaps thus declare information about .elds not being present in an object, as well \nas the .elds that are present. We also de.ne an evaluation function Lj which takes an abstract heap to \na concrete heap:  Lhj(l, x) h(l, x) iff (l, x) . dom(h) . h(l, x)= y We use this function in Section \n5 to de.ne the relationship between our reasoning using Hoare triples and our operational semantics. \nWe de.ne a logical environment E, which is a partial function from logical variables X .X L to logical \nvalues VL, which may be a return value r, any expression e, y or a list Ls of logical values. We also \nde.ne logical expressions E, which are different from program expressions in that they can not read or \nalter the heap. Expressions E are evaluated in a logical environment E with respect to a current scope \nchain L. Logical expressions and evaluation: [E]L v .VL ::= e | v | \u00a2 | Ls E : X L VL E ::= X Logical \nvariables | l Scope list | v Logical values | E . E Binary Operators | E:E List cons | E \u00b7E Reference \nconstruction | .E.E Lambda values v . L . E(X) [v]L. [l]L[X]L . :Ls if [E2]L= Ls [E1:E2]L. [E1]L. \u00b7E2]Ll\u00b7x \nif [E1]L= l . [E2]L= x [E1 . .. ' . v . v ' if [E1]L= v . [E2]L= v [E1 . E2]L.. . if [E1]L= x [.E1.E2]L. \n.x.[E2]L. Assertions include the boolean assertions, structural assertions of separation logic and our \nnew sepish connective, basic assertions for describing cells in a JavaScript heap, expression equality, \nset and list assertions, and quanti.cation over logical variables. Assertions. P ::= P . P | P . P |\u00acP \n| true | false Boolean assertions | P * P | P -* P | P I* P Structural assertions | (E, E) . E |0 JavaScript \nheap assertions | E = E Expression equality | E . SET Set membership | E . E List element |.X.P |.X.P \nQuanti.cation Notation: E .E \u00ac(E . E) for ..{=, .} E1 ..E2 E1 . E2 .0 for ..{=, =, .,/.}. The logical \noperators bind in order: \u00ac, I*, *, ., ., -*. The structural assertions * and -* are standard separation \nlogic assertions. The separating conjunction P *Q says that the heap may be split into two disjoint heaps, \none satisfying P and the other Q. The right adjoint P -*Q says that, whenever the heap is extended by \na heap satisfying P , then the resulting heap satis.es Q. It is useful in proving the soundness of some \nof our layers of abstraction in Section 6, as given in [11]. The sepish connective P W* Q is novel. It \nsays that the heap may be split into two heaps, one satisfying P and the other Q, but these two heaps \nneed not be disjoint. They may share zero or more common cells. We shall see in Section 5 that this is \nparticularly useful when reasoning about the emulated variable store. It is possible to de.ne -W* analogously \nwith -*, but since this is not useful for JavaScript reasoning we omit it here. Note that P . Q . P W* \nQ and P * Q . P W* Q, but neither of the reverse implications hold. The assertion (E1, E2) . E3 declares \ninformation about a cell, including the information that .eld E2 does not occur in object E1. Assertion \n0 says that the heap is empty. The notation SET denotes a literal set, or a named set such as X , the \nset of JavaScript .eld names. Note that since there are sets for numbers, strings and locations, we can \nuse set inclusion to assert the type of a particular JavaScript value. The satisfaction relation h, L, \nE |= P is de.ned below. The cases for the boolean assertions are not given as they are standard. Satisfaction \nof assertions: h,L, E |= P . h,L, E |= P * Q .. .h1,h2.h = h1 * h2. (h1,L, E |= P ) . (h2,L, E |= Q) \nh,L, E |= P -* Q .. .h1. (h1,L, E |= P ) . h # h1 =. ((h * h1),L, E |= Q) h,L, E |= P I* Q .. .h1,h2,h3. \nh = h1 * h2 * h3 . (h1 * h3,L, E |= P ) . (h2 * h3,L, E |= Q) h,L, E |=(E1, E2) . E3 .. h = ([E1]L. ) \n. [E3]L . , [E2]L. h,L, E |= 0 .. h = emp h,L, E |= E1 = E2 .. [E1]L= [E2]Lh,L, E |= E . SET . . SET \n.. [E]L h,L, E |= E1 . E2 . is in the list [E2]L .. [E1]L. h,L, E |= .X.P .. .v. h, L, [E|X + v] |= P \nh,L, E |= .X.P .. .v. h, L, [E|X + v] |= P We have given a direct de.nition of the sepish connective. \nWhen logical variables range over heaps, it can be derived: P W* Q . .R. (R -* P ) * (R -* Q) * R. It \nremains to be seen what natural logical properties are satis.ed by this connective. 5. Program Reasoning \nIn the spirit of separation logic, we give small axioms and infer\u00adence rules which precisely capture \nthe behaviour of all JavaScript expressions, except for the usual approximation for while and conservative \napproximations of function call and eval. Reasoning about function call and eval is interesting and complex, \nand will be the focus of future work as outlined in Section 8. Because our reasoning captures the full \ncomplexity of JavaScript semantics, par\u00adticularly with respect to the emulated variable store and the \nwith command, it is possible to prove properties about extremely subtle programs. Unfortunately, proving \nany program at this level of ab\u00adstraction involves a level of detail which most programmers would understandably \nrather avoid. We therefore provide several layers of abstraction which make it possible to reason at \na natural high level about well-behaved JavaScript programs. We discuss these abstrac\u00adtions in Section \n6. Our fault-avoiding Hoare triples take the form: {P }e{Q}, which means if e is executed in a state \nsatisfying P , then it will not fault, and if it terminates it will do so in a state satisfying Q . The \npostcondition Q may refer to the special variable r, which is equal to the return value of e. 5.1 Auxiliary \nPredicates For our reasoning rules, we require predicates that correspond to functions, such as s, p \nand ., used by the operational semantics in Section 3.3. These predicates present us with two distinct \nchal\u00ad lenges: sharing and precision. To consider sharing, recall the scope function s from Section 3.1 \nwhen searching for a variable y in the example emulated store given in Figure 1. Since y is not present \nin the emulated store, s will check the entire structure before return\u00ading null to indicate that y cannot \nbe found. What is of interest to us is the order in which the cells in the store will be checked. Notice \nthat the cell l will be checked twice, and the cell lop will be checked three times. This is because \nthe cells l and lop are shared between the prototype chain of the object l2 and the object l4. In addition, \nlop is shared by these prototype chains and the prototype chain of lg. As we shall see below, we can \ndescribe these partially shared structures using our sepish connective W*. To consider precision, re\u00adcall \nthe function s when this time searching for a variable x either in the emulated store of Figure 1, or \nin the identical store but for the omission of a single object such that the prototype of l2 would be \nl. In each of these stores, the s function will return the same value the location l2. In our program \nreasoning, our s predicate (which will correspond to the s function of the operational seman\u00adtics) must \nbe more precise as we need to distinguish between these two possible cases. With the challenges of sharing \nand precision in mind, we .rst give, then explain, the logical predicates s, p and ..  Logical predicates: \ns, p, .. s([ ], [],, null) 0 . ' s([Ls], L ' : Ls , X , L ' ) .L.p(Ls, L ' , X , L) * L= null ' s((Ls1 \n: Ls2), L ' : Ls , X , L) ' p(Ls1, L ' , X , null) I* s(Ls2, Ls , X , L) p([ ], null,, null) 0 . p([L], \nL, X , L) .V. (L, X ) . V * V= \u00a2 p((L ' : Ls), L ' , X , L) .N. (L ' , X ) . \u00a2 * (L ' , @proto) . N * \np(Ls, N, X , L) . .([ ], Val, Val) Val .R . .(Ls, L\u00b7X , undefined) p(Ls, L, X , null) * L = null .(Ls, \nL1 \u00b7X , Val) . .L2.p(Ls, L1 , X , L2) I* (L2, X ) . Val * Val = \u00a2 These predicates closely follow the \nstructure of the functions de\u00ad.ned in 3.1, using W* to manage the challenge of sharing prototype chains \nmentioned earlier. The predicate s( , L, x,l) holds only for abstract heaps h such that the function \nfrom Section 3.1 gives us s(Lhj, L, x)= l, meaning that the value of the variable x in the emulated variable \nstore given by the list L can be found in the object (or a prototype of the object) at address l. However, \nrecall the challenge of precision mentioned earlier. In order to distin\u00adguish between all the possible \nheaps which satisfy the predicate s( , L, x,l), we work with an additional .rst argument. The pred\u00adicate \ns(Ls, L, x,l) is precise in the sense that, for any abstract heap h, it holds for at most one subheap \nof h. The .rst argument Ls is a list of lists, which speci.es the exact cells which must be visited (and \nthe order in which they must be checked) in order to determine which object in the emulated variable \nstore de.nes the variable x. For example, recall the heap illustrated in Figure 1. If the prototype of \nthe cell l2 has address l ', then the predicate s([[l1], [l2,l ' ,l]], l, x,l2) is satis.ed by the abstract \nheap consist\u00ading of the x and @proto .elds of the four objects in the lower left corner of that diagram. \nNotice that we do not need to visit every object in the variable store in order to discover the location \nof the variable x. In the spirit of the small axioms of separation logic, our predicate holds for the \nsmallest possible heap in which we can be sure of discovering the variable we are interested in. The \npredicates p and . are similar in that they mirror their operational counterparts, with the addition \nof one extra argument to make them precise. In the case of p and ., the .rst argument Ls is simply a \nlist of addresses, rather than a list of lists of addresses, because each predicate only walks down at \nmost one prototype chain. The inference rules also require logical predicates correspond\u00ading to a number \nof other auxiliary functions given in Section 3. Below, we de.ne newobj and fun predicates, which assert \nthe ex\u00adistence of a fresh object and function object, and decls that returns the local variables of an \nexpression. In order to reason about func\u00adtion call, we also use a defs predicate which we de.ne in [11]. \nAuxiliary predicates This(L\u00b7 , L)(L, @this) . \u00a2 where L = lg . This(L\u00b7 ,lg) .V. (L, @this) . V * V= \u00a2 \n.False(E) E . True(E) E .{0, , null, undefined} .{0, , null, undefined}newobj(L, V1,..., Vn) IV .X\\{V1...Vn} \n(L, V ) . \u00a2 fun(F , Env, X , Body, Proto) (F , @scope) . Env * (F , @body) . .X .Body * (F , prototype) \n. Proto * (F, @proto) . lfp decls(X , L, e) x1,..., xn where (L, xi) . dom(defs(X , L, e))  5.2 Inference \nRules We de.ne below some inference rules {P }e{Q} for reasoning about JavaScript expressions. The full \nlist can be found in [11]. Inference rules: {P }e{Q}. (De.nition) {P }e{Q} r . fv(Q) (Value) . . {0}v{r \n= v} {P }var e{Q * r = undefined} (Variable) (Variable Null) P = s(Ls1, l, x, L) I* .(Ls2, L\u00b7x, V ) P \n= s(Ls, l, x, null) .. {P }x{P * r = L\u00b7x} {P }x{P * r = null\u00b7x} (Member Access) . . {P }e{Q * r = V \n} Q = R * .(Ls, V , L) * L = null . {P }e.x{Q * r = L\u00b7x} (Computed Access) . . {P }e1{R * r = V1 } R \n= S1 * .(Ls1, V1, L) * L = null . {R}e2{Q * X .X .U * r = V2} Q = S2 * .(Ls2, V2, X ) . {P }e1[e2]{Q \n* r = L\u00b7X } (Object) . .i . 1..n.Pi = Ri * .(Lsi, Yi , Xi ) {Pi-1}ei{Pi * r = Yi } .. .. newobj(L, @proto, \nx1,..., xn) * Q = .Pn *.L. . (L, x1) . X1 * ... * (L, xn) . Xn * .. . (L, @proto) . lop * r =L x1 = \n\u00b7\u00b7\u00b7 = xn r . fv(Pn) {P0}{x1:e1,..., xn:en}{Q} (Binary Operators) . {P }e1{R * r = V1 } R = S1 * .(Ls1, \nV1 , V3 ) . {R}e2{Q * r = V2 } Q = S2 * .(Ls2, V2 , V4 ) V = V3 . V4 . {P }e1 . e2{Q * r = V } (Assign \nGlobal) . {P }e1{R * r = null\u00b7X } . {R}e2{Q * (lg, X ) . \u00a2 * r = V1 } Q = S * .(Ls, V1 , V2 ) . {P }e1 \n= e2{Q * (lg, X ) . V2 * r = V2 } (Assign Local) . {P }e1{R * r = L\u00b7X } . {R}e2{Q * (L, X ) . V3 * r \n= V1 } Q = S * .(Ls, V1 , V2 ) . {P }e1 = e2{Q * (L, X ) . V2 * r = V2 } (Function) . . .L1, L2. newobj(L1, \n@proto) * (L1, @proto) . lop * Q = . newobj(L2, @proto, prototype, @scope, @body) * . . fun(L2, l, x, \ne, L1) * r =L2 {0}function (x){e}{Q} (While) . {P }e1{S * r = V1 } S = R * .(Ls, V1 , V2 ) {S * True(V2 \n)}e2{P } . Q = S * False(V2 ) * r = undefined r . fv(R) {P }while(e1){e2}{Q} (With) . .. {P * l = L}e1{S \n* l = L * r = V1 } S = R * .(Ls, V1 , L1 ) .. {S * l = L1 :L}e2{Q * l = L1 :L} l . fv(P, Q, R) .. {P \n* l = L}with(e1){e2}{Q * l = L}  (Function Call) . {P }e1{R1 * r = F1 } o S1 I* This(F1 , T ) I* .(Ls1, \nF1 , F2 )* R1 = (F2 , @body) . .X .e3 * (F2 , @scope) . Ls2 .. {R1}e2{R2 * l = Ls3 * r = V1 } R2 = S2 \n* .(Ls4, V1 , V2 ) . .. R2 *.L. l = L:Ls2 * (L, X ) . V2 * . (L, @this) . T * . R3 = .. (L, @proto) \n. null * defs(X , L, e3)* newobj(L, @proto, @this, X , decls(X , L, e3)) . {R3}e3{.L.Q * l = L:Ls2} l \n. fv(Q, R2) . {P }e1(e2){.L.Q * l = Ls3} (Frame) (Consequence) {P }e{Q}{P1}e{Q1} P =. P1 Q1 =. Q {P * \nR}e{Q * R}{P }e{Q} (Elimination) (Disjunction) {P }e{Q}{P1}e{Q1}{P2}e{Q2} {.X.P }e{.X.Q}{P1 . P2}e{Q1 \n. Q2} Although most of the rules correspond closely to their oper\u00adational counterparts, some rules deserve \nfurther comment. Rule (De.nition) shows the use of the reserved variable r to record the result of an \nexpression. Rule (Variable) shows the use of W* to ex\u00adpress the overlapping footprints of predicates \ns and .. Rule (Assign Global) shows the use of y to assert that certain known memory cells are available \nfor allocation. Rule (Function Call) describes JavaScript s dynamic functions but does not support higher \norder reasoning. Rule (Frame) does not have the usual side condition be\u00adcause JavaScript stores all its \nprogram variables on the heap, so any variable modi.ed by an expression is necessarily contained en\u00adtirely \nwithin the footprint of the expression. Rules (Consequence), (Elimination) and (Disjunction) are standard. \n 5.3 Soundness We show that our inference rules are sound with respect to the op\u00aderational semantics \nof Section 3.3. When proving the soundness of any system involving the frame rule, it is usual to .rst \nshow the locality of the programming language, and use that property to show the soundness of the frame \nrule [20]. Unfortunately, many JavaScript statements are not local according to this standard def\u00adinition. \nWe therefore use the recently introduced notion of weak locality from Smith s thesis [30]. De.nition \n2 (Soundness of a Hoare triple). A Hoare triple {P }e{Q}is sound if, for all abstract heaps h, scope \nchains L and environ\u00adments E, it satis.es the following two properties: Fault Avoidance : h, L, (E \\ \nr) |= P =.Lhj, L, e -. fault Safety : .H,r. h,L, (E \\ r) |= P .Lhj, L, e -. H, r =..h ' .H = Lh ' j. \nh ' , L, [E|r < r] |= Q. Theorem 3 (Soundness). All derivable Hoare triples {P }e{Q}are sound according \nto De.nition 2. The proof (reported in [11]) involves showing that the predi\u00ad cates used by the Hoare \nrules correspond to the auxiliary functions used by the semantics, showing that all JavaScript expressions \nare weakly local with respect to their preconditions, and .nally show\u00ading that all our inference rules \nare sound. 6. Layers of Abstraction As mentioned in Section 5, using the rules given so far, reason\u00ad \ning about JavaScript program involves detail that most program\u00admers need never consider. Most of the \ntime, programmers will work at a higher level of abstraction, for example, treating the em\u00adulated variable \nstore as if it were a regular variable store. This is a good practice as long as the abstraction holds. \nHowever, if the program happens to come across a corner case that breaks the ab\u00adstraction, its resulting \nbehaviour can appear almost inexplicable. This may be a particular problem when writing library code, \nsince the programmer has no control over the programming discipline of the client who uses the library. \nIn this section, we introduce sev\u00aderal explicit abstraction formalisms. Many alternatives are possible, \nbut those presented here are enough to demonstrate the concept and reason about some interesting programs. \nWe are able to use these formalisms to reason at a comfortable, high-level way about many well-behaved \nprograms. Crucially, we know exactly what the boundaries of these layers of abstraction are, so we can \nensure that our programs remain safely within the abstraction. If we wish, we can even choose to temporarily \nbreak an abstraction, execute some particularly subtle low-level code, re-establish the abstraction and \nthen continue to work at the high level. 6.1 Layer 1: Exploring the Scope List Central to reasoning \nabout JavaScript variables are the s and p predicates. The .rst abstraction layer consists of alternative \nver\u00adsions of these predicates which make reasoning about certain com\u00admon cases simpler. The s predicate \nunrolls from the end (the most global end) of the scope rather than from the beginning (the local end) \nwhich makes modifying a variable easier to specify. It makes use of s which says that a variable does \nnot exist in a particular par\u00adtial scope. The slg predicate does the same, but excludes lg from its speci.cation, \nin order to make reasoning about global variable instantiation simpler. We give several useful triples \nabout variable assignment. In [11], we prove these triples by using s and showing the equivalence of \ns and s. Layer 1 Predicates. '' s(Ls, Ls , Var, null) s(Ls, Ls , Var, null) ' s(Ls1++(Ls2 : []), Ls , \nVar, L) . ' s(Ls1, Ls , Var, L) *.L2.p(Ls2, L, Var, L2 ) * L2 = null ' s([ ], L ' : Ls ,, L ' ) 0 ' s(Ls2 \n: Ls, L ' : Ls , Var, End) ' p(Ls2, L ' , Var, null) I* s(Ls, Ls , Var, End) ' slg ([ ], L ' : Ls ,, \nL ' ) 0 ' slg (Ls2 : Ls, L ' : Ls , Var, End) ' plg (Ls2, L ' , Var, null) I* slg (Ls, Ls , Var, End) \nplg ([ ], null,, null) 0 plg ([ ],lg,, null) 0 .. plg ([L ' ], L ' , Var, L ' ) .V. (L ' , Var) . V * \nV= \u00a2 * L ' = lg plg ((L ' : Ls), L ' , Var, L) .N. (L ' , Var) . \u00a2 * . (L ' , @proto) . N * plg (Ls, \nN, Var, L) * L ' = lg These predicates give us much more .exibility to reason about JavaScript variables \nfound in various places in the emulated vari\u00adable store. Even at this quite low level, it is possible \nto prove general speci.cations about programs with many corner cases. A good ex\u00adample of this sort of \nreasoning is simple assignment statements. We prove the following general triples about simple assignments. \nThe .rst three triples deal with the assignment of a constant to a vari\u00adable, in the cases of variable \ninitialisation, variable override, and variable overwrite respectively. The fourth triple deals with \nassign\u00ading the value of one variable to another. All four are proved sound in [11]. Simple assignments. \nP = s(L1 ++((lg:L2 ):L3 ), l, x, null) .. .L ' 1, L ' 3, Ls ' , G.slg (L ' 1, l, x,lg)I* Q = . p(L2 , \nG, x, null) I* slg (L ' 3, Ls ' , x, null) * (lg, x) . v* . .. (lg, @proto) . G * l = ++(lg:Ls ' ) * \nr = v {P }x=v{Q}  P = s(L1 ++[L:L2 ]), l, x, L) I* (L, x) . \u00a2 I* .(L:L2 , L\u00b7x, V ) o .L ' .s(L1 , l, \nx, L) * (L, x) . v * (L, @proto) . Pr * Q = . p(L2 , Pr, x, L ' ) I* (L ' , x) . V * r = v {P }x=v{Q} \n. P = s(L1 ++[[L]], l, x, L) I* (L, x) . V * V = \u00a2 . Q = s(L1 , l, x, L) * (L, x) . v * r = v {P }x=v{Q} \no s(Ls1, l, y, Ly) I* .(Ls2, Ly \u00b7y, Vy) I* P = . s(L1 ++[[L]], l, x, L) I* (L, x) . V * V = \u00a2 . Q = s(Ls1, \nl, y, Ly) I* s(L1 , l, x, L) * (L, x) . Vy * r = Vy {P }x=y{Q} Compared to the (Assign Global) and (Assign \nLocal) inference rules, these triples provide an explicit account of the footprint of the assignment, \nand more clearly describe the destructive effects of assignment. Yet, they are still quite complex and \nare dif.cult to compose. It would be useful to ignore some information about the exact structure of the \nvariable store, while retaining the information about the mappings of variable names to values. To do \nthis, we introduce a new store predicate.  6.2 Layer 2: a Simple Abstract Variable Store The predicates \nbelow provide a convenient abstraction for an emu\u00adlated variable store. The store Predicate. '' storeL(X1 \n... Xn |X1 :V1 ... X :Vm ) m ' ''' '' .Ls1 ..., Lsn, Ls1,..., Ls , Ls1 ,..., Ls . thischain(L) I* mm \nI*i.1..n s(Lsi, L, Xi , null) I* (lg, Xi ) . \u00a2 '' ''' I*j.1..m s(Lsj , L, Xj , Lj ) I* k.1..m .(Lsk \n, Lk \u00b7Xk , Vk ) thischain([ ]) 0 thischain(L : Ls ' )(L, @this) .* thischain(Ls ' ) The assertion storeLS(a, \nb|x :1, y : 2) describes a heap emulat\u00ading a variable store given by scope chain LS, in which the variables \na and b are not present and the variables x and y take the values 1 and 2 respectively. The body of the \npredicate uses the s predicate to assert the absence of a and b, and the s and . predicates to as\u00adsert \nthe presence and values of x and y. This information about the exact structure of the emulated store \nand the locations of x and y is hidden from the programmer, since at this level of abstraction it should \nbe of no concern. The thischain part of the body of the pred\u00adicate ensures that the store predicate always \nencompasses enough resource to call any function that is stored in the emulated variable store. The variables \na and b can be re-ordered, as can the variables x and y. To facilitate program reasoning at this level \nof abstraction we provide several inference rules, all of which are derived (using previous levels of \nabstraction) in [11]. We start by giving rules for initialising, overwriting and overriding a variable \nwith a constant and with another variable. Writing to a store. Let Q1 = storel(X1 ... Xn|x:v, X ' :V1 \n... X ' :Vm). 1m Let Q2 = storel(X1 ... Xn|x:V, y:V, X ' :V1 ... X ' :Vm). 1m x =X1 = \u00b7\u00b7\u00b7 =Xn =X ' = \n\u00b7\u00b7\u00b7 =X ' 1 m P = storel(x, X1 ... Xn|X ' :V1 ... X ' :Vm) 1m . {P }x=v{Q1 * true * r = v} x =X1 = \u00b7\u00b7\u00b7 \n=Xn =X ' = \u00b7\u00b7\u00b7 =X ' 1 m P = storel(X1 ... Xn|x:V, X ' :V1 ... X ' :Vm) 1m . {P }x=v{Q1 * true * r = v} \nx = y =X1 = \u00b7\u00b7\u00b7 =Xn =X ' = \u00b7\u00b7\u00b7 =X ' 1 m P = storel(x, X1 ... Xn|y:V, X ' :V1 ... X ' :Vm) 1m . {P }x=y{Q2 \n* true * r =V} x = y =X1 = \u00b7\u00b7\u00b7 =Xn =X ' = \u00b7\u00b7\u00b7 =X ' 1 m P = storel(X1 ... Xn|x:V ' , y:V, X ' :V1 ... \nX ' :Vm) 1m . {P }x=y{Q2 * true * r =V} Notice that each of these rules has a postcondition which in\u00adcludes \ntrue. This is because initialising or overriding a variable may render a portion of the emulated variable \nstore super.uous. For example, consider the overriding assignment x=1 in the store given in Figure 1. \nIn this case the cell (l, x) has become surplus to requirements. In separation logic it is not sound \nto simply forget about these cells, so we hide them in the general assertion true. One limitation of \nthis level of abstraction is that the abstrac\u00adtion only covers a static (and unknown) scope chain. If \nwe call a function which adds a new cell to the scope chain, then the rules above are insuf.cient to \nreason about our program. The following rules allow us to reason at this level of abstraction about a \nprogram which alters a global variable from within a new local scope frame. Writing to a store from a \ndeeper scope. Let Q = storeLS X1,..., Xn|x :V ' , X ' :V 1' ,..., X ' :V ' and 1 mm . S = (L, @proto) \n. null * (L, x) . \u00a2 * (L, y) . V ' * l = L : LS. x = y =X1 = \u00b7\u00b7\u00b7 =Xn =X ' = \u00b7\u00b7\u00b7 =X ' 1 m P11 mm = storeLS \nx, X1,..., Xn|X ' :V 1' ,..., X ' :V ' {P1 * S}x=y{Q * S * true} x = y =X1 = \u00b7\u00b7\u00b7 =Xn =X ' = \u00b7\u00b7\u00b7 =X ' \n1 m 1 mm P2 = storeLS X1,..., Xn|x :V, X ' :V 1' ,..., X ' :V ' {P2 * S}x=y{Q * S * true} Finally, we \nprovide two rules for a more general case of store interaction. In these cases, the value which is to \nbe written to the variable is the result of computing some arbitrary expression. These speci.cations \nare therefore necessarily more complicated, since they must incorporate some features of sequential composition. \nWe insist that whatever the expression does, it must not alter the vari\u00adable store in a way that changes \nthe visible values of the variables. Destructive store Initialisation. x =X1 = \u00b7\u00b7\u00b7 =Xn =X ' = \u00b7\u00b7\u00b7 =X \n' 1 m R = storel(x, X1 ... Xn|X ' :V1 ... X ' :Vm) 1m . {R * P }e{R I* .(LS, V ' , V) * Q * r =V ' } \nr . fv(Q) o storel X1 ... Xn|x:V, X ' :V1 ... X ' :Vm 1m S = . I* .(LS, V ' , V) * Q * true * r =V {R \n* P }x=e{S} x =X1 = \u00b7\u00b7\u00b7 =Xn =X ' = \u00b7\u00b7\u00b7 =X ' 1 m R = storeL:SLS (x, X1 ... Xn|X ' :V1 ... X ' :Vm) I* \ns(Nsls, l, x, L) 1m . {R}e{R I* .(LS, V ' , V) * Q * r =V ' } r . fv(Q) o storeL:SLS X1 ... Xn|x:V, X \n' :V1 ... X ' :Vm I* 1m S = . s(Nsls, l, x, L) I* .(LS, V ' , V) * Q * true * r =V {R * P }x=e{S} It \nmay seem surprising that we only provide derived rules for destructive variable initialisation, and not \nfor destructive variable update. This is because such an update rule would be unsound. The destructive \nexpression might have the side effect of overriding the variable we wish to update. This serves to further \ndemonstrate the need for the low-level reasoning introduced earlier in this paper. We can use high-level \nabstractions such as the store predicate where they are sound, but if we wish to reason about programs \nwith side\u00adeffecting expressions, we will sometimes be forced to reason at a lower level. The scope of \na variable. The store abstraction gives us the tools we need to easily reason about programs with large \nnumbers of variables. For example, consider the program from Section 2:  f [[ .. Let P = (L, b) . 1 \n* (L, @proto) . lop * (lop, f) . J l* (lop, @proto) . null a [a * true storel (x, y, z, f, v|) = null;y \n= null;z = null;  storel (f, v|x : null, y : null, z : null) * true= function(w){x=v storel (a, f|) \nl{b:1};= y=v}; : null, f : L) * ; v=4 ; var v ; : L) l* (lop, f) . J l* .. : null, y : null, z .L. storel(v|x \n.L. storel(f|a (lop, @proto) . null * (L, f) . J * P with . .. . .. ... (L, @body) . .w.{... }* (L, @scope) \n. l * true (a){ . .LS, L. l = L : LS * .. 5; storel(|x : null, y : null, z : null, f :L, v : 5) * storeLS(f|a \n(lop, @proto) . null * (L, f) . J : L) l* (lop, f) . J l* = . * P . .. .. .. (L, @body) . .w.{... }* \n(L, @scope) . l * true f=function(c){b} . .LS, L, F. l = L : LS * . .. f(null); / .L. storel(|x : undefined, \ny :4, z : null, f :L, v : 5) * newobj(L/, @proto, @this, w, v) * (L/ .. storeLS(|a :L, f : F) l* (lop, \nf) . J l* (lop, @proto) . null * (L, f) . J .. .. .. . . . .. . ... * , @proto) . null * (F, @body) \n. .c.{b}* (F, @scope) . L : LS * P . / (L, w) . null * (L/, v) . 4 * true . }; .. . .. [Frame] storel \n(|x : undefined, y :4, z : null, f :L, v : 5)z = v; [[ . .LS, L, F. l = LS * storeLS(|a :L, f : F) l* \n(lop, f) . J l* (lop, @proto) . null * (L, f) . J . * (F, @body) . .c.{b}* (F, @scope) . L : LS * P \nstorel (|x : undefined, y :4, z :5, f :L, v : 5) * true [Frame] .. {b:2}; .LS, L, F, L = a . . . ... \n.. . . . . /. . l = LS * storel(|x : undefined, y :4, z :5, f :L, v : 5) * newobj(L/ / storeLS(|a :L, \nf : F) l* (lop, f) . J l* (lop, @proto) . null * (L, f) . J , @proto, @this, w, v) * (L/, @proto) . null \n* * (L/ / , b) . 2 * (L, f) . J * (L/, @proto) . lop * ... . (L/, w) . null * (L/, v) . 4 * true (F, \n@body) . .c.{b}* (F, @scope) . L : LS * P f(null) . . . [Cons/Var Elim] .L. storel(|x : undefined, y \n:4, z :5, f :L, v : 5) * true [ . . . . .LS, L, F, L/, LOC. l = LS * storeLS(|a :L/, f : F) l* (lop, \nf) . J l* (lop, @proto) . null * / (L, f) . J * (L/, b) . 2 * (L, f) . J * (L/ . . .. . .L/, LS. l \n=L/ : LS * storeLS(|x : null, y : null, z : null, f :L, v : 5) * , @proto) . lop * .. . (F, @body) . \n.c.{b}* (F, @scope) . L : LS * (LOC, b) . J * (LOC, @proto) . null * P * r . =1 . =1 * true} (L, @body) \n. .w.{... }* (L, @scope) . LS * newobj(L/, @proto, @this, w, v) * (L/ , @proto) . null * {r . . . . (L/, \nw) . null * (L/, v) . undefined * (L/, @this) .* true x=v;v=4;var . .L/, LS. l =L/ : LS * storeLS(|x \n: undefined, y :4, z : null, f :L, v : 5) * // newobj(L, @proto, @this, w, v) * (L, @proto) . null * \n/ (L, w) . null * (L/, v) . 4 * true . . . v;y=v; Figure 3. Reasoning about with. . . . ... . . .LS, \nL, F, L ' , LOC. l = LOC : L : LS * storeLS(|a :L ' , f : F) W* (lop, f) . y W* (lop, @proto) . null \n* true * (L, b) . 1 * (L, f) . y * (L, @proto) . lop * (L ' , b) . 2 * (L ' , f) . y * (L ' , @proto) \n. lop * (F, @body) . .c.{b}* (F, @scope) . L : LS * (LOC, b) . y * (LOC, @proto) . null For space reasons, \nwe only give the reasoning for the case in ........ ........ Figure 2. Reasoning about variable scopes. \nx = null; y = null; z = null; f = function(w){x=v;v=4;var v;y=v;}; v = 5; f(null); z = v; With the store \npredicate and the results given above, reasoning about this program is simple. A proof of the main program \nis shown in Figure 2. It relies on a simple proof of the function body summarised here and given in full \nin [11]. Reasoning about with. This level of abstraction also leads itself to reasoning about the notorious \nwith statement. Consider the with example from Section 2 (where f implicitly returns b): a = {b:1}; with \n(a){f=function(c){b}}; a = {b:2}; f(null) This program demonstrates the importance of modelling with \ncor\u00adrectly. Recall that when correctly modelled, the closure of the func\u00adtion f will refer to the object \n{b:1}, which was pointed to by the variable a at the time that f was de.ned. However, even though the \nvariable a is changed to point to a different object before f(null) is called, the closure continues \nto point to the object {b:1}. Thus the program normally returns the value 1, not 2. Recall also that \nwe must be careful with the f .eld of the object lop. We can reason about this program using the store \npredicate. The proof is in Figure 3. This proof relies on a sub-proof for the invocation of the function \nf(null), which culminates with the . judgement {P }b{P * r =1}, where P is which neither a nor f are \nin the variable store. The same techniques in tandem with the disjunction rule can be used to prove the \ngeneral precondition. In both the simple and the general case, we must constrain our precondition with \nthe assertion (lop, f) . y W* (lop, @proto) . null. The requirement for this term may seem surprising. \nConsider running the above program in a state satisfying storel(a, f|) W* (lop, f) . 4. In this case, \nwhen the assignment to f is made, the function pointer will be written to the cell (L, f), rather than \ninto the global variable store. Since the variable store does not contain a function value for the variable \nf, the call to f(null) will cause the program to fault. The problem is potentially even worse if (lop, \nf) contains a function pointer. In this case, the call to f(null) will not fault, but rather will execute \nwhatever code it .nds. This kind of unpredictability could lead to very confusing bugs. In the case of \na system like Facebook which attempts to isolate user-application code from host-page code, it could \neven lead to a security .aw.  6.3 Layer 3: a Recursive Abstract Variable Store While reasoning using \nthe store predicate, it is possible to han\u00addle large numbers of assignments and small numbers of function \ncalls. However, for large numbers of function calls, another ab\u00adstraction is helpful. Consider an abstract \nvariable store as a list of lists of variable-value pairs, with the most local scope frame atthe head \nof the outer list. The list [[x = 4], [y = 5], [x =6,z = 7]] represents a store in which the global scope \ncontains the vari\u00adables x and z, an intermediate scope adds the variable y, and the most local scope \noverrides the variable x. The list elements of  variable-value pairs can be represented in our logical \nexpression data =L, . .. . .[] , . .. , [] . . * checkField = &#38;undefined, recstorel language as lists \ncontaining two elements. For readability, we use i = &#38;undefined the notation x = v above. We de.ne \nthe recursive store predi\u00adcate recstoreL(NoVars, Store) which describes an abstract vari\u00ad .. . .. . (L, \nnumEntries) . N * (L, buttonDisabled) .* (L, 0) . TXT0 * ... * (L, N) . TXTN able store Store, which \ndoes not contain the variables in the list NoVars. The Recursive recstore predicate. ... checkForm ... \n. . . .. . . . .. .L/. recstorel ([ ], [[data =L, checkField =L/ , i = N], [ ]]) * (L, numEntries) . \nN * (L, 0) . TXT0 * ... * (L, N) . TXTN * .. TXT0 = * ... * TXTN= * 0. . . . . . . . recstoreL([x1 \n' , \u00b7\u00b7\u00b7 xm ' ], [[x1 = V1, \u00b7\u00b7\u00b7 , xn = Vn]]) storeL(x1 ' , \u00b7\u00b7\u00b7 xm ' |x1 : V1, \u00b7\u00b7\u00b7 , xn : Vn) .. (L, buttonDisabled) \n. 0 .(L, buttonDisabled) . 1 recstoreL:LS ([x1 ' , \u00b7\u00b7\u00b7 xm ' ], ([x1 = V1, \u00b7\u00b7\u00b7 , xn = Vn]: Ls ' )) . recstoreLS \n([x1 ' , \u00b7\u00b7\u00b7 xm ' ], Ls ' ) * (L, @proto) . null * L = lg * *i.1..m (L, xi ' ) . \u00a2 *j.1..n (L, xj) . \nVj * nonesL([x1, \u00b7\u00b7\u00b7 , xn], Ls ' ) nonesL( , [ ]) 0 nonesL(Ls, ([x1 = V1, \u00b7\u00b7\u00b7 , xn = Vn]: Ls ' )) *i.1..n((xi \n..Ls) . (xi . Ls . (L, xi) . \u00a2)) * nonesL((x1 : \u00b7\u00b7\u00b7 : xn : Ls), Ls ' ) Notice that recstore uses the \nstore predicate to constrain the most global scope frame in the abstract scope list, while being rather \nmore restrictive about more local scope frames. Local scope frames must be emulated by JavaScript objects \nwhich contain .elds for each variable de.ned at that scope level. Furthermore, they must assert the absence \nof .elds which are not in the store (the NoVars), or which would otherwise shadow a variable declared \nin a more global position in the store. This is handled by the nones predicate. Notice that local scope \nframes have a null prototype, and may not be the lg object. These criteria are met by the emulated scope \nframes created by a normal function call, and are not normally met by with calls. This makes this abstraction \nideal for reasoning about programs with many function calls and no internal uses of the with statement. \nNotice, however, that we do not outlaw with calls in the enclosing scope, represented here by a top-level \nuse of the store predicate. This means that this abstraction will facilitate reasoning about libraries \nwhich are written in a principled way, and which may be called by unprincipled clients. We provide several \nrules for reasoning at this level of abstrac\u00adtion in [11], the most interesting of which are destructive \nvariable initialisation and update. Destructive recstore update. R = recstorel((x : EmpVars), (Locals++[Globals])) \n. {R * P }e{R * Q * r = Var} r . fv(Q) S = recstorel((EmpVars), (Locals++[x = Var : Globals])) {R * \nP }x=e{S * Q * true} R = recstorel((Emps), (Ls++((x = Var): Curr)++Globs)) . .. {R * Globs = [] * P }e{R \n* Globs = [] * Q * r = Var ' } r . fv(Q) .LS . Ls. (x =) . LS S = recstorel((Emps), (Ls++((x = Var ' \n): Curr)++Globs)) . .. ' {R * Globs = [] * P }x=e{S * Globs = [] * Q * r = Var } Notice that we may \nnot safely update variables in the global portion of the abstract variable store with the results of \npotentially destructive expressions. This is for the same reason as the corre\u00adsponding restriction on \nthe store predicate in Section 6.2; there is a corner case which would lead to very unexpected behaviour. \nAt this level of abstraction however, we have an advantage. We can be sure that the local abstract scope \nframes were constructed in a more principled way, and so we are able to reason about updating them with \ndestructive expressions using the second rule above. Figure 4. The speci.cation of checkForm. Form validation. \nConsider a web form with a number of manda\u00adtory text .elds and a submit button. If the button is disabled \nwhen the page loads, then an event handler on the form can be used to regularly check if valid data has \nbeen entered in all the .elds be\u00adfore enabling the button. Let us assume that the programmer has separated \nthe concerns of parsing the web page and of validating the data. The data validation function will be \ncalled with a single parameter: an object with one .eld for each text value to check, a count of those \ntext values, and boolean toggle corresponding to whether the submit button should be disabled. An example \nfunction which might perform the validation check is: checkForm = function(data) { data.buttonDisabled \n= 0; var checkField = function(text) { if(text == \"\") {data.buttonDisabled = 1;}} var i=0; while(i < \ndata.numEntries) { checkField(data[i]); i = i+1;}} Notice that this code deals with variables in a principled \nway. It makes use of no global variables, preferring instead to use function parameters and local variables. \nThe repeated work of the loop body is factored into a function which could be expanded to provide extra \nfunctionality or used elsewhere with little cost in readability. Using the recstore abstraction it is \nstraightforward to show that the function body satis.es the speci.cation given in Figure 4. 7. Related \nWork We believe this paper is the .rst to propose a program logic for reasoning about JavaScript. Our \nprogram logic adapts ideas from separation logic, and proves soundness with respect to a big-step operational \nsemantics. In this section, we discuss related work on separation logic and the semantics of JavaScript. \nWe build on the seminal work of O Hearn, Reynolds and Yang [20], who introduced separation logic for \nreasoning about C\u00adprograms, and on the work of Parkinson and Bierman [4, 23, 24], who adapted separation \nlogic to reason about Java. We made sev\u00aderal adaptations to their work in order to reason about JavaScript. \nAs in [4, 23, 24], we use assertions of the form (l, x) . 5 to denote that a .eld x in object l has value \n5. We extend these as\u00adsertions by (l, x) . y, which denotes that the .eld is not in l. This is inspired \nby Dinsdale-Young et al. s use of the out predi\u00adcate to state that values are not present in a concurrent \nset [7]. We introduce the sepish connective W* to account for partially-shared data structures. We have \nnot seen this connective before, which is surprising since shared data structures are common for example \nin Linux. There has been much work on various forms of concurrent separation logic with sharing [9, 21, \n35], but they all seem to take a different approach to our W* connective.  We prove the soundness of \nour frame rule using a new technique developed in Smith s PhD thesis [30]. There are several approaches \nto proving soundness of the separation-logic frame rule, and we list the key developments here. The .rst \nand most commonly used ap\u00adproach by O Hearn, Reynolds and Yang involves .rst proving that the commands \nof the programming language under consideration are local, and then using that property to prove the \nframe rule [20]. Later, Birkedal and Yang devised a method baking in the sound\u00adness of the frame rule \ninto their de.nition of Hoare triples [5]. This made it possible to prove the frame rule without reference \nto lo\u00adcality, but did not extend well to concurrent programs. Vafeiadis solved the concurrency problem \nin [34], where he proves sound\u00ad ness of concurrent separation logic without reference to locality. Smith \ns thesis was written at the same time as [34], and takes a different approach. Rather than removing all \nreference to locality from the soundness proof, Smith uses a generalised weak locality property, which \nallows us to handle some non-local behaviour. We prove our soundness result with respect to a big-step \nop\u00aderational semantics of JavaScript, faithfully following the small\u00adstep semantics of Maffeis et al. \n[18] except where discussed in Section 3.5. Their semantics captures the complete ECMAScript 3 language, \nat the same level of abstraction to where a JavaScript programmer reasons. In contrast,Herman and Flanagan \n[13] pro\u00ad vide a de.nitional interpreter of JavaScript written in ML, which has the advantage of being \ndirectly executable, but includes imple\u00admentation details that obscure the semantic meaning. Elsewhere, \nGuha et al. [12] compile JavaScript to an intermediate Scheme\u00ad like language, in order to provide type-based \nanalyses on the ob\u00adject language. They justify their translation in a novel way, by checking that it \nsatis.es an established test suite of JavaScript pro\u00adgrams. However, the translation is complicated and \nit is not imme\u00addiately apparent that it is sound. In fact, many approaches translate JavaScript programs \nusing troublesome features such as the with construct into programs which do not. For example, Park, \nLee and Ryu show that this is often feasible [22], but do not handle interac\u00ad tions between with and \neval. There are a number of more abstract models of JavaScript, which have proven useful to study selected \nlanguage features [1, 32, 37], but which are not suf.ciently con\u00ad crete for our purpose. Overall, we \nhave chosen the semantics in [18] because it appears to be the most faithful to the actual JavaScript \nsemantics. As Richards et al. argue in [28], all the unusual features of JavaScript are well-used in \nthe wild, and cannot be easily ab\u00adstracted away. 8. Conclusions and Future Work We have de.ned a program \nlogic for reasoning about JavaScript, based on an operational semantics which is essentially faithful \nto ECMAScript 3. We have adapted separation logic to reason about a JavaScript subset, modelling many \ncomplex features such as pro\u00adtotype inheritance and with. We reason about the full dynamic na\u00adture of \nJavaScript s functions, but do not provide higher-order rea\u00adsoning. We also provide only conservative \nreasoning about eval. Full reasoning about these features will be technically challeng\u00ading, although \nwe believe that we can build on the recent work of [6, 10, 29]. We do not currently reason about implicit \ntype coer\u00ad cion. JavaScript allows the programmer to de.ne functions to con\u00advert values between different \ntypes. Adding this feature to our oper\u00adational semantics is simple. The complexity in handling it with \nour program reasoning will be in reasoning about higher-order func\u00adtions, as discussed above. Due to \nour choice of operational semantics, we have been able to prove a strong soundness result. Any library, \nformally speci\u00ad.ed using our reasoning, will behave well, even when called by arbitrary JavaScript code. \nIn Section 2, we illustrated this property by demonstrating that our with example behaves according to \nits speci.cation even when embedded in a program which maliciously uses the non-standard proto feature. \nFinally, our soundness re\u00adsult can be extended compositionally to include more sophisticated reasoning \nabout higher-order functions and eval. We have given several examples of our reasoning, demonstrat\u00ading \nwith small code examples that JavaScript is .endish to under\u00adstand and our reasoning can help. In particular, \nour with exam\u00adple shows a potential bug that could easily go unnoticed for some time, and perhaps lead \nto security holes in sanitised mashup envi\u00adronments. Despite the complexity of the language and the subtlety \nof the bug, reasoning about this and other examples is made sur\u00adprisingly simple by our example abstraction \nlayers. We hope that this work will form the core of a larger body of work on client-side web programming. \nFor example, Thie\u00admann [33] has de.ned a type-safe DOM API, and Smith [30] has developed context-logic \nreasoning about DOM Core Level 1. It would be valuable to integrate these approaches to DOM modelling \nwith the JavaScript reasoning presented here. Maffeis et al. [16, 17, 19] have developed techniques for \nbuild\u00ad ing secure JavaScript mashups out of untrusted code. They prove security properties of their enforcement \nmechanisms, but do not study their functional correctness. Our reasoning makes such an analysis possible. \nWe also intend to develop reasoning for high\u00adlevel libraries such as jQuery, Prototype.js and Slidy [15, \n25, 26]. We will make each of these libraries the focus of its own layer of abstraction, following the \nexamples in Section 6, to make reasoning about idiomatic uses of those libraries very natural. As with \nour ex\u00adisting layers of abstraction, it will be possible to safely break these abstractions where necessary \nin order to code and reason at a lower level. While this paper deals with ECMAScript 3, the newer EC-MAScript \n5 and the ongoing ECMAScript Harmony both provide enticing targets. Taly and others have recently given \na small-step operational semantics of ECMAScript 5 [31]. It would certainly be interesting to reason \nabout ECMAScript 5 code, and to for\u00admalise the connections with our reasoning presented here about ECMAScript \n3. We are particularly interested in understanding the behaviour of libraries written in ECMAScript 5 \nwhen called by code written in ECMAScript 3. To make this program reasoning genuinely useful for JavaScript \nprogrammers, it is essential that we provide tool support. We intend to produce analysis tools capable \nof spotting bugs such as the one described in the with example in Section 6.2, and integrate our tools \nwith IDEs such as Eclipse or Visual Studio. Acknowledgements. Gardner and Smith are supported by EPSRC \ngrant COTFM P21654. Maffeis is supported by EPSRC grant EP/I004246/1. We thank Charlton, Dinsdale-Young, \nNtzik, O Hearn, da Rocha Pinto, Wheelhouse, and Wright for insightful discussions. We especially thank \nDaiva Naudziuniene for her impressive eye for detail. References [1] C. Anderson, P. Giannini, and S. \nDrossopoulou. Towards type infer\u00adence for JavaScript. In Proc. of ECOOP 05, 2005. 7 [2] J. Berdine, C. \nCalcagno, and P. O Hearn. Smallfoot: Modular auto\u00admatic assertion checking with separation logic. In \nFMCO, 2005. 1 [3] J. Berdine, B. Cook, and S. Ishtiaq. Slayer: Memory safety for systems-level code. \nIn CAV, 2011. 1 [4] G.M. Bierman, M.J. Parkinson, and A. M. Pitts. MJ: An imperative core calculus for \njava and java with effects. Technical report, Cam\u00adbridge, 2003. 4, 7 [5] L. Birkedal and H. Yang. Relational \nparametricity and separation logic. In FoSSaCS, pages 93 107, 2007. 7  [6] N. Charlton. Hoare logic \nfor higher order store using simple seman\u00adtics. In Proc. of WOLLIC 2011, 2011. 1, 8 [7] T. Dinsdale-Young, \nM. Dodds, P. Gardner, M. Parkinson, and V. Vafeiadis. Concurrent abstract predicates. ECOOP, 2010. 2, \n7 [8] D. Distefano and M. Parkinson. jStar: towards practical veri.cation for Java. In OOPSLA 08, pages \n213 226. ACM, 2008. 1 [9] M. Dodds, X. Feng, M.J. Parkinson, and V. Vafeiadis. Deny-guarantee reasoning, \n2009. 7 [10] D. Dreyer, G. Neis, and L. Birkedal. The impact of higher-order state and control effects \non local relational reasoning. In ICFP, pages 143 156, 2010. 8 [11] P. Gardner, S. Maffeis, and G. Smith. \nTowards a program logic for JavaScript. Imperial College London Technical Report number DTR11-11, November \n2011. 3.1, 3.3, 3.3, 3.4, 4, 5.1, 5.2, 5.3, 6.1, 6.2, 6.3 [12] A. Guha, C. Saftoiu, and S. Krishnamurthi. \nThe Essence of JavaScript. ECOOP 2010, pages 126 150, 2010. 1, 2, 7 [13] D. Herman and C. Flanagan. Status \nreport: specifying JavaScript with ML. In Proc. of ML 07, pages 47 52, 2007. 7 [14] ECMA International. \nECMAScript language speci.cation. stardard ECMA-262, 3rd Edition, 1999. 1, 2 [15] jQuery: The write less, \ndo more, JavaScript library. http://jquery. com.8 [16] S. Maffeis, J. C. Mitchell, and A. Taly. Isolating \njavascript with .lters, rewriting, and wrappers. In ESORICS, pages 505 522, 2009. 8 [17] S. Maffeis, \nJ. C. Mitchell, and A. Taly. Object capabilities and isola\u00adtion of untrusted web applications. In IEEE \nSymposium on Security and Privacy, pages 125 140, 2010. 8 [18] S. Maffeis, J.C. Mitchell, and A. Taly. \nAn operational semantics for JavaScript. In Proc. of APLAS 08, LNCS, 2008. 1, 2, 3, 3.2, 7 [19] S. Maffeis \nand A. Taly. Language-based isolation of untrusted javascript. In CSF, pages 77 91, 2009. 8 [20] P. O \nHearn, J. C. Reynolds, and H. Yang. Local reasoning about programs that alter data structures. In CSL, \n2001. 1, 4, 5.3, 7 [21] P. W. OHearn. Resources, concurrency, and local reasoning. Theor. Comput. Sci., \n375(1-3):271 307, 2007. 7 [22] Changhee Park, Hongki Lee, and Sukyoung Ryu. An empirical study on the \nrewritability of the with statement in javascript. In FOOL, 2011. [23] M. J. Parkinson and G. M. Bierman. \nSeparation logic, abstraction and inheritance. In POPL, 2008. 2, 7 [24] M. J. Parkinson. Local reasoning \nfor Java. Technical Report 654, Univ. of Cambridge Computer Laboratory, 2005. Ph.D. dissertation. 4, \n7 [25] Prototype Core Team. Prototype JavaScript framework: Easy Ajax and DOM manipulation for dynamic \nweb applications. http://www. prototypejs.org. 4,7 [26] Dave Raggett. W3C Slidy. http://www.w3.org/Talks/Tools/ \nSlidy2/, 2005. 8 [27] G. Richards, C. Hammer, B. Burg, and J. Vitek. The Eval that men do A large-scale \nstudy of the use of Eval in JavaScript applications. Accepted for publication at ECOOP 2011. 8 [28] G. \nRichards, S. Lebresne, B. Burg, and J. Vitek. An analysis of the dynamic behavior of JavaScript programs. \nIn PLDI, 2010. 2 [29] J. Schwinghammer, L. Birkedal, B. Reus, and H. Yang. Nested hoare triples and frame \nrules for higher-order store. In In Proc. of CSL 09, 2009. 1, 2, 2, 7 [30] G. D. Smith. Local reasoning \nabout web programs. PhD Thesis, Dep. of Computing, Imperial College London, 2011. 1, 8 [31] A. Taly, \nU. Erlingsson, M. S. Miller, J. C. Mitchell, and J. Nagra. Automated analysis of security-critical javascript \napis. In Proc. of IEEE Security and Privacy 11. IEEE, 2011. 1, 5.3, 7, 8 [32] P. Thiemann. Towards a \ntype system for analyzing javascript pro\u00adgrams. In Proc. of ESOP 05, volume 3444 of LNCS, 2005. 8 [33] \nP. Thiemann. A type safe DOM API. In Proc. of DBPL, pages 169 183, 2005. 7 [34] V. Vafeiadis. Concurrent \nseparation logic and operational semantics. In MFPS11, 2011. 8 [35] Viktor Vafeiadis and M. Parkinson. \nA marriage of rely/guarantee and separation logic. In IN 18TH CONCUR. Springer, 2007. 7 [36] H. Yang, \nO. Lee, J. Berdine, C. Calcagno, B. Cook, D. Distefano, and P.O Hearn. Scalable shape analysis for systems \ncode. In CAV, 2008. 7 [37] D. Yu, A. Chander, N. Islam, and I. Serikov. JavaScript instrumenta\u00ad tion \nfor browser security. In Proc. of POPL 07, 2007. 1 7   \n\t\t\t", "proc_id": "2103656", "abstract": "<p>JavaScript has become the most widely used language for client-side web programming. The dynamic nature of JavaScript makes understanding its code notoriously difficult, leading to buggy programs and a lack of adequate static-analysis tools. We believe that logical reasoning has much to offer JavaScript: a simple description of program behaviour, a clear understanding of module boundaries, and the ability to verify security contracts. We introduce a program logic for reasoning about a broad subset of JavaScript, including challenging features such as prototype inheritance and \"with\". We adapt ideas from separation logic to provide tractable reasoning about JavaScript code: reasoning about easy programs is easy; reasoning about hard programs is possible. We prove a strong soundness result. All libraries written in our subset and proved correct with respect to their specifications will be well-behaved, even when called by arbitrary JavaScript code.</p>", "authors": [{"name": "Philippa Anne Gardner", "author_profile_id": "81351597297", "affiliation": "Imperial College, London, United Kingdom", "person_id": "P2991332", "email_address": "pg@doc.ic.ac.uk", "orcid_id": ""}, {"name": "Sergio Maffeis", "author_profile_id": "81100507240", "affiliation": "Imperial College, London, United Kingdom", "person_id": "P2991333", "email_address": "maffeis@doc.ic.ac.uk", "orcid_id": ""}, {"name": "Gareth David Smith", "author_profile_id": "81351602806", "affiliation": "Imperial College, London, United Kingdom", "person_id": "P2991334", "email_address": "gds@doc.ic.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103663", "year": "2012", "article_id": "2103663", "conference": "POPL", "title": "Towards a program logic for JavaScript", "url": "http://dl.acm.org/citation.cfm?id=2103663"}