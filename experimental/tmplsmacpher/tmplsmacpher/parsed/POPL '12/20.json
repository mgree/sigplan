{"article_publication_date": "01-25-2012", "fulltext": "\n Nested Re.nements: A Logic for Duck Typing * Ravi Chugh Patrick M. Rondon Ranjit Jhala University of \nCalifornia, San Diego {rchugh, prondon, jhala}@cs.ucsd.edu Abstract Programs written in dynamic languages \nmake heavy use of features run-time type tests, value-indexed dictionaries, polymorphism, and higher-order \nfunctions that are beyond the reach of type sys\u00adtems that employ either purely syntactic or purely semantic \nreason\u00ading. We present a core calculus, System D, that merges these two modes of reasoning into a single \npowerful mechanism of nested re\u00ad.nement types wherein the typing relation is itself a predicate in the \nre.nement logic. System D coordinates SMT-based logical impli\u00adcation and syntactic subtyping to automatically \ntypecheck sophisti\u00adcated dynamic language programs. By coupling nested re.nements with McCarthy s theory \nof .nite maps, System D can precisely rea\u00adson about the interaction of higher-order functions, polymorphism, \nand dictionaries. The addition of type predicates to the re.nement logic creates a circularity that leads \nto unique technical challenges in the metatheory, which we solve with a novel strati.cation ap\u00adproach \nthat we use to prove the soundness of System D. Categories and Subject Descriptors F.3.1 [Logics and \nMeanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams Logics of Programs General \nTerms Languages, Veri.cation Keywords Re.nement Types, Dynamic Languages 1. Introduction So-called dynamic \nlanguages like JavaScript, Python, Racket, and Ruby are popular as they allow developers to quickly put \ntogether scripts without having to appease a static type system. However, these scripts quickly grow \ninto substantial code bases that would be much easier to maintain, refactor, evolve and compile, if only \nthey could be corralled within a suitable static type system. The convenience of dynamic languages comes \nfrom their sup\u00adport of features like run-time type testing, value-indexed .nite maps (i.e. dictionaries), \nand duck typing, a form of polymorphism where functions operate over any dictionary with the appropriate \nkeys. As the empirical study in [18] shows, programs written in dy\u00ad namic languages make heavy use of \nthese features, and their safety relies on invariants which can only be established by sophisticated \n* This work was supported by NSF Grants CCF-0644361, CNS-0964702, and generous gifts from Microsoft Research. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n12, January 25 27, 2012, Philadelphia, PA, USA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. \n. . $10.00 reasoning about the .ow of control, the run-time types of values, and the contents of data \nstructures like dictionaries. The following code snippet, adapted from the popular Dojo Javascript framework \n[36], illustrates common dynamic features: let onto callbacks f obj = if f = null then new List(obj, \ncallbacks) else let cb = if tag f = \"Str\" then obj[f] else f in new List(fun () -> cb obj, callbacks) \nThe function onto is used to register callback functions to be called after the DOM and required library \nmodules have .nished loading. The author of onto went to great pains to make it extremely .exible in \nthe kinds of arguments it takes. If the obj parameter is provided but f is not, then obj is the function \nto be called after loading. Otherwise, both f and obj are provided, and either: (a) f is a string, obj \nis a dictionary, and the (function) value corresponding to key f in obj is called with obj as a parameter \nafter loading; or (b) f is a function which is called with obj as a parameter after loading. To verify \nthe safety of this program, and dynamic code in general, a type system must reason about dynamic type \ntests, control .ow, higher-order functions, and heterogeneous, value-indexed dictionaries. Current automatic \ntype systems are not expressive enough to support the full spectrum of reasoning required for dynamic \nlan\u00adguages.1 Syntactic systems use advanced type-theoretic constructs like structural types [3], row \ntypes [38], intersection types [17], and union types [18, 39] to track invariants of individual values. \nUn\u00ad fortunately, such techniques cannot reason about value-dependent relationships between program variables, \nas is required, for exam\u00adple, to determine the speci.c types of the variables f and obj in onto. Semantic \nsystems like [4, 6, 14, 23, 31, 35] support such rea\u00ad soning by using logical predicates to describe \ninvariants over pro\u00adgram variables. Unfortunately, such systems require a clear (syntac\u00adtic) distinction \nbetween complex values that are typed with arrows, type variables, etc., and base values that are typed \nwith predicates. Hence, they cannot support the interaction of complex values and value-indexed dictionaries \nthat is ubiquitous in dynamic code, for example in onto, which can take as a parameter a dictionary con\u00adtaining \na function value. Our Approach. We present System D, a core calculus that sup\u00adports fully automatic checking \nof dynamic idioms. In System D all values are described uniformly by formulas drawn from a decid\u00adable, \nquanti.er-free re.nement logic. Our .rst key insight is that to reason precisely about complex values \n(e.g. higher-order func\u00adtions) nested deeply inside structures (e.g. dictionaries), we require 1 Full \ndependent type systems like Coq [5] can support the necessary rea\u00ad soning, but are not automatic as the \nprogrammer must provide explicit proofs to discharge type checking obligations.  a single new mechanism \ncalled nested re.nements wherein syntac\u00adtic types (resp. the typing relation) may be nested as special \ntype terms (resp. type predicates) inside the re.nement logic. Formally, the re.nement logic is extended \nwith atomic formulas of the form x :: U where U is a type term, :: (read has type ) is a bi\u00adnary, uninterpreted \npredicate in the re.nement logic, and where the formula states that the value x has the type described \nby the term U. This unifying insight allows to us to express the invariants in idiomatic dynamic code \nlike onto including the interaction between higher-order functions and dictionaries while staying within \nthe boundaries of decidability. Expressiveness. The nested re.nement logic underlying System D can express \ncomplex invariants between base values and richer values. For example, we may disjoin two tag-equality \npredicates {. | tag(.)= Int . tag(.)= Str } to type a value . that is either an integer or a string; \nwe can then track control .ow involving the dynamic type tag-lookup function tag to ensure that the value \nis safely used at either more speci.c type. To describe values like the argument f of the onto function \nwe can combine tag-equality predicates with the type predicate. We can give f the type {. | . = null \n. tag(.)= Str . . :: Top . Top} where Top is an abbreviation for {. | true}, which is a type that describes \nall values. Notice the uniformity the types nested within this re.nement formula are themselves re.nement \ntypes. Our second key insight is that dictionaries are .nite maps, and so we can precisely type dictionaries \nwith re.nement formulas drawn from the (decidable) theory of .nite maps [25]. In particular, McCarthy \ns two operators sel(x, a), which corresponds to the contents of the map x at the address a, and upd(x, \na, v), which corresponds to the new map obtained by updating x at the address a with the value v are \nprecisely what we need to describe reads from and updates to dictionaries. For example, we can write \n{. | tag(.)= Dict . tag(sel(., y)) = Int } to type dictionaries . that have (at least) an integer .eld \ny, where y is a program variable that dynamically stores the key with which to index the dictionary. \nEven better, since we have nested function types into the re.nement logic, we can precisely specify, \nfor the .rst time, combinations of dictionaries and functions. For example, we can write the following \ntype for obj {. | tag(f)= Str . sel(., f) :: Top . Top} to describe the second portion of the onto speci.cation, \nall while staying within a decidable re.nement logic. In a similar manner, we show how nested re.nements \nsupport polymorphism, datatypes, and even a form of bounded quanti.cation. Subtyping. The huge leap in \nexpressiveness yielded by nesting types inside re.nements is accompanied by some unique techni\u00adcal challenges. \nThe .rst challenge is that because we nest complex types (e.g. arrows) as uninterpreted terms in the \nlogic, subtyping (e.g. between arrows) cannot be carried out solely via the usual syn\u00adtactic decomposition \ninto SMT queries [6, 16, 31]. (A higher-order logic (e.g. [5]) would solve this problem, but that would \npreclude algorithmic checking; we choose the uninterpreted route precisely to relieve the SMT solver \nof higher-order reasoning!) We surmount this challenge with a novel decomposition mechanism where sub\u00adtyping \nbetween types, syntactic type terms, and re.nement formu\u00adlas are de.ned inter-dependently, thereby using \nthe logical struc\u00adture of the re.nement formulas to divide the labor of subtyping between the SMT solver \nfor ground predicates (e.g. equality, unin\u00adterpreted functions, arithmetic, maps, etc.) and classical \nsyntactic rules for type terms (e.g. arrows, type variables, datatypes). Soundness. The second challenge \nis that the inter-dependency between the re.nement logic and the type system renders the stan\u00addard proof \ntechniques for (re.nement) type soundness inapplicable. In particular, we illustrate how uninterpreted \ntype predicates break the usual substitution property and how nesting makes it dif.cult to de.ne a type \nsystem that is well-de.ned and enjoys this property. We meet this challenge with a new proof technique: \nwe de.ne an in.nite family of increasingly precise systems and prove soundness of the family, of which \nSystem D is a member, thus establishing the soundness of System D. Contributions. To sum up, we make \nthe following contributions: We show how nested re.nements over the theory of .nite maps encode function, \npolymorphic, dictionary and constructed data types within re.nements and permit dependent structural \nsub\u00adtyping and a form of bounded quanti.cation.  We develop a novel algorithmic subtyping mechanism \nthat uses the structure of the re.nement formulas to decompose subtyping into a collection of SMT and \nsyntactic checks.  We illustrate the technical challenges that nesting poses to the metatheory of System \nD and present a novel strati.cation\u00adbased proof technique to establish soundness.  We de.ne an algorithmic \nversion of the type system with local  type inference that we implement in a prototype checker. Thus, \nby carefully orchestrating the interplay between syntactic\u00adand SMT-based subtyping, the nested re.nement \ntypes of System D enable, for the .rst time, the automatic static checking of features found in idiomatic \ndynamic code. 2. Overview We start with a series of examples that give an overview of our ap\u00adproach. \nFirst, we show how by encoding types using logical re.ne\u00adments, System D can reason about control .ow \nand relationships between program variables. Next, we demonstrate how nested re\u00ad.nements enable precise \nreasoning about values of complex types. After that, we illustrate how System D uses re.nements over \nthe theory of .nite maps to analyze value-indexed dictionaries. We conclude by showing how these features \ncombine to analyze the sophisticated invariants in idiomatic dynamic code. Notation. We use the following \nabbreviations for brevity. Top(x) true Int(x) tag(x) = Int Bool(x) tag(x) = Bool Str(x) tag(x) = \nStr Dict(x) tag(x) = Dict IorB(x) Int(x) . Bool(x) We abuse notation to use the above as abbreviations \nfor re.ne\u00adment types; for each of the unary abbreviations T de.ned above, an occurrence without the parameter \ndenotes the re.nement type {. | T (.)}. For example, we write Int as an abbreviation for {. | tag(.)= \nInt }. Recall that function values are also de\u00adscribed by re.nement formulas (containing type predicates). \nWe often write arrows outside re.nements to abbreviate the following: x:T1 . T2 {. | . :: x :T1 . T2} \nWe write T1 . T2 when the return type T2 does not refer to x. 2.1 Simple Re.nements To warm up, we show \nhow System D describes all types through re.nement formulas, and how, by using an SMT solver to discharge \nthe subtyping (implication) queries, System D makes short work of value-and control .ow-sensitive reasoning \n[18, 39].  Ad-Hoc Unions. Our .rst example illustrates the simplest dy\u00adnamic idiom: programs which operate \non ad-hoc unions. The func\u00adtion negate takes an integer or boolean and returns its negation: let negate \nx = if tag x = \"Int\" then 0 -x else not x In System D we can ascribe to this function the type negate \n:: IorB . IorB which states that the function accepts an integer or boolean argu\u00adment and returns either \nan integer or boolean result. To establish this, System D uses the standard means of reason\u00ading about \ncontrol .ow in re.nement-based systems [31], namely strengthening the environment with the guard predicate \nwhen pro\u00adcessing the then-branch of an if-expression and the negation of the guard predicate for the \nelse-branch. Thus, in the then-branch, the environment contains the assumption that tag(x)= Int , which \nallows System D to verify that the expression 0 - x is well-typed. The return value has the type {. | \ntag(.)= Int . . =0 - x}. This type is a subtype of IorB as the SMT solver can prove that tag(.)= Int \nand . =0 - x implies tag(.)= Int . tag(.)= Bool . Thus, the return value of the then-branch is deduced \nto have type IorB. On the other hand, in the else-branch, the environment contains the assumption \u00ac(tag(x)= \nInt ). By combining this with the assumption about the type of negate s input, tag(x)= Int . tag(x)= \nBool , the SMT solver can determine that tag(x)= Bool . This allows our system to type check the call \nto not :: Bool . Bool, which establishes that the value returned in the else branch has type IorB. Thus, \nour system determines that both branches return a value of type IorB, and thus that negate meets its \nspeci.cation. Dependent Unions. System D s use of re.nements and SMT solvers enable expressive relational \nspeci.cations that go beyond previous techniques [18, 39]. While negate takes and returns ad\u00adhoc unions, \nthere is a relationship between its input and output: the output is an integer (resp. boolean) iff the \ninput is an integer (resp. boolean). We represent this in System D as negate :: x:IorB .{. | tag(.)= \ntag(x)} That is, the re.nement for the output states that its tag is the same as the tag of the input. \nThis function is checked through exactly the same analysis as before; the tag test ensures that the environment \nin the then-(resp. else-) branch implies that x and the returned value are both Int (resp. Bool). That \nis, in both cases, the output value has the same tag as the input.  2.2 Nested Re.nements So far, we \nhave seen how old-fashioned re.nement types (where the predicates re.ne base values [6, 23, 27, 31]) \ncan be used to check ad-hoc unions over base values. However, a type system for dynamic languages must \nbe able to express invariants about values of base and function types with equal ease. We accomplish \nthis in System D by adding types (resp. the typing relation) to the re.nement logic as nested type terms \n(resp. type predicates). However, nesting raises a rather tricky problem: with the typing relation included \nin the re.nement logic, subtyping can no longer be carried out entirely via SMT implication queries [6]. \nWe solve this problem with a new subtyping rule that extracts type terms from re.nements to enable syntactic \nsubtyping for nested types. Consider the function maybeApply which takes an integer x and a value f which \nis either null or a function over integers: let maybeApply x f = iff=nullthenx else fx In System D, we \ncan use a re.nement formula that combines a base predicate and a type predicate to assign maybeApply \nthe type maybeApply :: Int .{. | . = null . . :: Int.Int}. Int Note that we have nested a function type \nas a term in the re.ne\u00adment logic, along with an assertion that a value has this particu\u00adlar function \ntype. However, to keep checking algorithmic, we use a simple .rst-order logic in which type terms and \npredicates are completely uninterpreted; that is, the types can be thought of as constant terms in the \nlogic. Therefore, we need new machinery to check that maybeApply actually enjoys the above type, i.e. \nto check that (a) f is indeed a function when it is applied, (b) it can accept the input x, and (c) it \nwill return an integer. Type Extraction. To accomplish the above goals, we extract the nested function \ntype for f stored in the type environment as follows. Let G be the type environment at the callsite (f \nx). For each type term U occurring in G, we query the SMT solver to determine whether [G] . f :: U holds, \nwhere [G] is the embedding of G into the re.nement logic where type terms and predicates are treated \nin a purely uninterpreted way. If so, we say that U must .ow to (or just, .ows to) the caller expression \nf. Once we have found the type terms that .ow to the caller expression, we map the uninterpreted type \nterms to their corresponding type de.nitions to check the call. Let us see how this works for maybeApply. \nThe then-branch is trivial: the assumption that x is an integer in the environment allows us to deduce \nthat the expression x is well-typed and has type Int. Next, consider the else-branch. Let U1 be the type \nterm Int . Int. Due to the bindings for x and f and the else-condition, the environment G is embedded \nas tag(x)= Int . (f = null . f :: U1).\u00ac(f = null) [G] Hence, the SMT solver is able to prove that G . \nf :: U1. This establishes that f is a function on integers and, since x is known to be an integer, we \ncan verify that the else-branch has type Int and hence check that maybeApply meets its speci.cation. \nNested Subtyping. Next, consider a client of maybeApply: let _ = maybeApply 42 negate At the call to \nmaybeApply we must show that the actuals are subtypes of the formals, i.e. that the two subtyping relationships \nG1 f{. | . = 42}. Int G1 f{. | . = negate}.{. | . = null . . :: U1} (1) hold, where G1 negate :{. | . \n:: U0}, maybeApply : \u00b7\u00b7\u00b7 and U0 = x :IorB .{. | tag(.)= tag(x)}. Alas, while the SMT solver can make \nshort work of the .rst obligation, it cannot be used to discharge the second via implication; the real \ntypes that must be checked for subsumption, namely, U0 and U1, are embedded as totally unrelated terms \nin the re.nement logic! Once again, extraction rides to the rescue. We show that all sub\u00adtyping checks \nof the form G f{. | p}.{. | q} can be reduced to a .nite number of sub-goals of the form: ( type predicate-free \n) [G'] . p' or ( type predicate ) [G'] . x :: U The former kind of goal has no type predicates and can \nbe directly discharged via SMT. For the latter, we use extraction to .nd the .nitely many type terms \nUi that .ow to x. (If there are none, the check fails.) For each Ui we use syntactic subtyping to verify \nthat the corresponding type is subsumed by (the type corresponding to) U under G ' .  In our example, \nthe goal 1 reduces to proving either [G1' ] . . = null or [G1' ] . . :: U1 where G ' 1 G1,. = negate. \nThe former implication contains no type predicates, so we attempt to prove it by querying the SMT solver. \nThe solver tells us that the query is not valid, so we turn to the latter implication. The extraction \nprocedure uses the SMT solver to deduce that, under G ' 1 the type term U0 .ows into .. Thus, all that \nremains is to retrieve the de.nition of U0 and U1 and check G1 ' f x:IorB .{. | tag(.)= tag(x)} Int . \nInt which follows via standard syntactic re.nement subtyping [16], thereby checking the client s call. \nThus, by carefully interleaving SMT implication and syntactic subtyping, System D enables, for the .rst \ntime, the nesting of rich types within re.nements.  2.3 Dictionaries Next, we show how nested re.nements \nallow System D to precisely check programs that manipulate dynamic dictionaries. In essence, we demonstrate \nhow structural subtyping can be done via nested re.nement formulas over the theory of .nite maps [13, \n25]. We introduce two abbreviations for dictionaries. F ld(x, y, Int) Dict(x) . Str(y) . Int(sel(x, y)) \nF ld(x, y, U) Dict(x) . Str(y) . sel(x, y) :: U The second abbreviation states that the type of a .eld \nis a syntactic type term U (e.g. an arrow). Dynamic Lookup. SMT-based structural subtyping allows System \nD to support the common idiom of dynamic .eld lookup and up\u00addate, where the .eld name is a value computed \nat run-time. Con\u00adsider the following function: let getCount t c = if has t c then toInt (t[c]) else 0 \nThe function getCount uses the primitive operation has :: d:Dict . k :Str .{. | Bool(.) . . = true . \nhas(d, k)} to check whether the key c exists in t. The re.nement for the input d expresses the precondition \nthat d is a dictionary, while the re.nement for the key k expresses the precondition that k is a string. \nThe re.nement of the output expresses the postcondition that the result is a boolean value which is true \nif and only if d has a binding for the key k, expressed in our re.nements using has(d, k), a predicate \nin the theory of maps that is true if and only if there is a binding for key k in the map d [13, 25]. \nThe dictionary lookup t[c] is desugared to get t c where the primitive operation get has the type get \n:: d:Dict.k : {. | Str(.) . has(d, k)}.{. | . = sel(d, k)} and sel(d, k) is an operator in the theory \nof maps that returns the binding for key k in the map d. The re.nement for the key k expresses the precondition \nthat it is a string value in the domain of the dictionary d. Similarly, the re.nement for the output \nasserts the postcondition that the value is the same as the contents of the map at the given key. The \nfunction getCount .rst tests that the dictionary t has a binding for the key c; if so, it is read and \nits contents are converted to an integer using the function toInt, of type Top.Int. Note that the if-guard \nstrengthens the environment under which the lookup appears with the fact has(t, c), ensuring the safety \nof the lookup. If t does not contain the key c, the default value 0 is returned. Both branches are thus \nveri.ed to have type Int, so System D veri.es that getCount has the type getCount :: Dict . Str . Int. \nDynamic Update. Dually, to allow dynamic updates, System D includes a primitive set :: d: Dict . k : \nStr . x:Top.{. | . = upd(d, k, x)} that produces a new dictionary, where upd(d, k, x) is an operator \nin the theory of maps that denotes d updated (or extended) with a binding from k to x. The following \nillustrates how the set primitive can be used: let incCount t c = let newcount = 1 + getCount t c in \nlet res = set t c newcount in res We give the function incCount the type d :Dict . c :Str .{. | EqMod(., \nd, {c}) . F ld(., c, Int)} where EqMod(d1,d2,K) abbreviates a predicate that stipulates that d1 is identical \nto d2 at all keys except for those in K. The output type of getCount allows System D to conclude that \nnewcount :: Int. From the type of set, System D deduces res :: {. | EqMod(., t, {c}) . sel(., c)= newcount} \nwhich is a subtype of the output type of incCount. Next, consider let d0= {\"files\" = 42 } let d1 = incCount \nd0 \"dirs\" let _ = d1[\"files\"] + d1[\"dirs\"] System D veri.es that d0 :: {. | F ld(., files , Int)} d1 \n:: {. | F ld(., files , Int) . F ld(., dirs , Int)} and, hence, the .eld lookups return Ints that can \nbe safely added.  2.4 Type Constructors Next, we use nesting and extraction to enrich System D with \ndata structures, thereby allowing for very expressive speci.cations. In general, System D supports arbitrary \nuser-de.ned datatypes, but to keep the current discussion simple, let us consider a single type constructor \nList[T ] for representing unbounded sequences of T \u00advalues. Informally, an expression of type List[T \n] is either a special null value or a dictionary with a hd key of type T and a tl key of type List[T \n]. As for arrows, we use the following notation to write list types outside of re.nements: List[T ] {. \n| . :: List[T ]} Recursive Traversal. Consider a textbook recursive function that takes a list of arbitrary \nvalues and concatenates the strings: let rec concat sep xs = if xs = null then \"\" else let hd = xs[\"hd\"] \nin let tl = xs[\"tl\"] in if tag hd != \"Str\" then concat sep tl else if tl != null then hd ^ sep ^ concat \nsep tl else hd We ascribe the function the type concat :: Str . List[Top] .Str. The null test ensures \nthe safety of the hd and tl accesses and the tag test ensures the safety of the string concatenation \nusing the techniques described above.  Nested Ad-Hoc Unions. We can now de.ne ad-hoc unions over constructed \ntypes by simply nesting List[\u00b7] as a type term in the re.nement logic. The following illustrates a common \nPython idiom when an argument is either a single value or a list of values: let runTest cmd fail_codes \n= let status = syscall cmd in if tag fail_codes = \"Int\" then not (status = fail_codes) else not (listMem \nstatus fail_codes) Here, listMem :: Top.List[Top].Bool and syscall :: Str.Int. The input cmd is a string, \nand fail_codes is either a single inte\u00adger or a list of integer failure codes. Because we nest List[\u00b7] \nas a type term in our logic, we can use the same kind of type extraction reasoning as we did for maybeApply \nto ascribe runTest the type runTest :: Str .{. | Int(.) . . :: List[Int]}. Bool  2.5 Parametric Polymorphism \nSimilarly, we can add parametric polymorphism to System D by simply treating type variables A, B, etc. \nas (uninterpreted) type terms in the logic. As before, we use the following notation to write type variables \noutside of re.nements. A {. | . :: A} Generic Containers. We can compose the type constructors in the \nways we all know and love. Here is list map in System D: letrecmap fxs= if xs = null then null else new \nList(f xs[\"hd\"], map f xs[\"tl\"]) (Of course, pattern matching would improve matters, but we are merely \ntrying to demonstrate how much can be and is! achieved with dictionaries.) By combining extraction \nwith the rea\u00adsoning used for concat, it is easy to check that map :: .A, B. (A.B) . List[A] .List[B] \nNote that type abstractions are automatically inserted where a func\u00adtion is ascribed a polymorphic type. \nPredicate Functions. Consider the list .lter function: let rec filter f xs = if xs = null then null else \nif not (f xs[\"hd\"]) then filter f (xs[\"tl\"]) else new List(xs[\"hd\"], filter f xs[\"tl\"]) In System D, \nwe can ascribe filter the type .A, B. (x : A .{. | . = true . x :: B}) . List[A] . List[B], Note that \nthe return type of the predicate, f, tells us what type is satis.ed by values x for which f returns true, \nand the return type of filter states that the items filter returns all have the type implied by the predicate \nf. Thus, the general mechanism of nested re.nements subsumes the kind of reasoning performed by specialized \ntechniques like latent predicates [39]. Bounded Quanti.cation. Nested re.nements enable a form of bounded \nquanti.cation. Consider the function let dispatch d f = d[f] d The function dispatch works for any dictionary \nd of type A that has a key f bound to a function that maps values of type A to values of type B. We can \nspecify this via the dependent signature .A,B. d:{. | Dict(.) . . :: A}.{. | F ld(d, ., A.B)}. B Note \nthat there is no need for explicit type bounds; all that is required is the conjunction of the appropriate \nnested re.nements.  2.6 All Together Now With the tools we ve developed in this section, System D is \nnow ca\u00adpable of type checking sophisticated code from the wild. The origi\u00adnal source code for the following \ncan be found in a technical report [8]. Unions, Generic Dispatch, and Polymorphism. We now have everything \nwe need to type the motivating example from the in\u00adtroduction, onto, which combined multiple dynamic \nidioms: dy\u00adnamic .elds, tag-tests, and the dependency between nested dictio\u00adnary functions and their \narguments. Nested re.nements let us for\u00admalize the .exible interface for onto given in the introduction: \n.A. callbacks : List[Top . Top] . f :{. | . = null . Str(.) . . :: A . Top} . obj :{. | . :: A . (f = \nnull . . :: Top . Top) . (Str(f) . F ld(., f, A . Top))} . List[Top . Top] Using reasoning similar to \nthat used in the previous examples, System D checks that onto enjoys the above type, where the spec\u00adi.cation \nfor obj is enabled by the kind of bounded quanti.cation described earlier. Re.ection. Finally, to round \noff the overview, we present one last example that shows how all the features presented combine to allow \nSystem D to statically type programs that introspect on the contents of dictionaries. The function toXML \nshown below is adapted from the Python 3.2 standard library s plistlib.py [37]: let rec toXML x = if \ntag x = \"Bool\" then if x then element \"true\" null else element \"false\" null else if tag x = \"Int\" then \nelement \"integer\" (intToStr x) else if tag x = \"Str\" then element \"string\" x else if tag x = \"Dict\" then \nlet ks=keysxin let vs=map {v| Str(v) and has(x,v)} Str (fun k -> element \"key\" k ^ toXML x[k]) ks in \n\"<data>\" ^ concat \"\\n\" vs ^ \"</data>\" else element \"function\" null The function takes an arbitrary value \nand renders it as an XML string, and illustrates several idiomatic uses of dynamic features. If we give \nthe auxiliary function intToStr the type Int . Str and element the type Str .{. | . = null . Str(.)}.Str, \nwe can verify that toXML :: Top . Str Of especial interest is the dynamic .eld lookup x[k] used in the \nfunction passed to map to recursively convert each binding of the dictionary to XML. The primitive operation \nkeys has the type keys :: d : Dict . List[{. | Str(.) . has(d, .)}] that is, it returns a list of string \nkeys that belong to the input dictio\u00adnary. Thus, ks has type List[{. | Str(.) . has(x,.)}], which en\u00adables \nthe call to map to typecheck, since the body of the argument is checked in an environment where k :: \n{. | Str(.) . has(x,.)}, which is the type that A is instantiated with. This binding suf.ces to prove \nthe safety of the dynamic .eld access. The control .ow rea\u00adsoning described previously uses the tag tests \nguarding the other cases to prove each of them safe.  w ::= Values | x variable | c constant | w1 ++ \n{w2 . w3} dictionary extension | .x. e function | .A. e type function | C(w) constructed data e ::= Expressions \n| w value | w1 w2 function application | w [T ] type function application | if w then e1 else e2 if-then-else \n| let x = e1 in e2 let-binding td ::= type C[.A]{f : T } Datatype De.nitions prg ::= td; e Programs lw \n::= Logical Values | w value | F (lw) logical function application p, q, r ::= Re.nement Formulas | P \n(lw) predicate | lw :: U type predicate | p . q | p . q |\u00acp logical connective T ::= {. | p} Re.nement \nTypes U ::= Type Terms | x :T1 . T2 arrow | A type variable | C[T ] constructed type | Null null S ::= \nT |.A. S Type Schemes Figure 1. Syntax of System D 3. Syntax and Semantics We begin with the syntax and \nevaluation semantics of System D. Figure 1 shows the syntax of values, expressions, and types. Values. \nValues w include variables constants, functions, type functions, dictionaries, and records created by \ntype constructors. The set of constants c includes base values like integer, boolean, and string constants, \nthe empty dictionary {}, and null. Logical values lw are all values and applications of primitive function \nsym\u00adbols F , such as addition + and dictionary selection sel, to logical values. The constant tag allows \nintrospection on the type tag of a value at run-time. For example, tag(3) Int tag(true) Bool tag( \njohn ) Str tag(.x. e) Fun tag({}) Dict tag(.A. e) TFun Dictionaries. A dictionary w1 ++ {w2 . \nw3} extends the dictio\u00adnary w1 with the binding from string w2 to value w3. For example, the dictionary \nmapping x to 3 and y to true is written {} ++ { x . 3} ++ { y . true}. The set of constants also includes \noperations for extending dictio\u00adnaries and accessing their .elds. The function get is used to access \ndictionary .elds and is de.ned get (w ++ { x . wx}) x wx get (w ++ { y . wy}) x get w x The function \nhas tests for the presence of a .eld and is de.ned has (w ++ { y . wy}) x has w x has (w ++ { x . wx}) \nx true has {} x false The function set updates the value bound to a key and is de.ned set dkw d ++ {k \n. w} Expressions. The set of expressions e consists of values, function applications, type instantiations, \nif-then-else expressions, and let\u00adbindings. We use an A-normal presentation so that we need only de.ne \nsubstitution of values (not arbitrary expressions) into types. Types. We stratify types into monomorphic \ntypes T and polymor\u00adphic type schemes .A. S. In System D, a type T is a re.nement type of the form {. \n| p}, where p is a re.nement formula, and is read . such that p. The values of this type are all values \nw such that the formula p[w/.] is true. What this means, formally, is core to our approach and will be \nconsidered in detail in section 5. Re.nement Formulas. The language of re.nement formulas in\u00adcludes predicates \nP , such as the equality predicate and dictionary predicates has and sel, and the usual logical connectives. \nFor ex\u00adample, the type of integers is {. | tag(.)= Int }, which we abbreviate to Int. The type of positive \nintegers is {. | tag(.)= Int . .> 0} and the type of dictionaries with an integer .eld f is {. | tag(.)= \nDict . tag(sel(., f )) = Int }. We refer to the binder . in re.nement types as the value variable. Nesting: \nType Predicates and Terms. To express the types of val\u00adues like functions and dictionaries containing \nfunctions, System D permits types to be nested within re.nement formulas. Formally, the language of re.nement \nformulas includes a form, lw :: U, called a type predicate, where U is a type term. The type term x : \nT1 . T2 describes values that have a dependent function type, i.e. functions that accept arguments w \nof type T1 and return values of type T2[w/x], where x is bound in T2. We write T1 . T2 when x does not \nappear in T2. Type terms A, B, etc. correspond to type parameters to polymorphic functions. The type \nterm Null corre\u00adsponds to the type of the constant value null. The type term C[T ] corresponds to records \nconstructed with the C type constructor in\u00adstantiated with the sequence of type arguments T . For example, \nthe type of the (integer) successor function is {. | . :: x:Int .{. | tag(.)= Int . . = x +1}}, dictionaries \nwhere the value at key f maps Int to Int have type {. | tag(.)= Dict . sel(., f ) :: Int . Int}, and \nthe constructed record List(1, null) can be assigned the type {. | . :: List[Int]}. Datatype De.nitions. \nA datatype de.nition of C de.nes a named, possibly recursive type. A datatype de.nition includes a sequence \n.A of type parameters A paired with variance annotations ..A variance annotation is either + (covariant), \n-(contravariant), or = (invariant). The rest of the de.nition speci.es a sequence f :T of .eld names \nand their types. The types of the .elds may refer to the type parameters of the declaration. A well-formedness \ncheck,  Operational Semantics ey. e ' Well-Formed Type Schemes G f S if d(c, w) is de.ned [E-DELTA] \ncw y . d(c, w) (.x. e) wy . e[w/x] [E-APP] let x = w in ey . e[w/x] [E-LET] (.A. e)[T ] y . e [E-TAPP] \nif true then e1 else e2 y . e1 [E-IFTRUE] if false then e1 else e2 y . e2 [E-IFFALSE] . e e1 y1 ' [E-COMPAT] \nlet x = e1 in e2 y1 ' in e2 . let x = e Figure 2. Evaluation semantics of System D which will be described \nin section 4, ensures that occurrences of type parameters in the .eld types respect their declared variance \nannotations. By convention, we will use the subscript i to index into the sequence .A and j for f : T \n. For example, .i refers to the variance annotation of the ith type parameter, and fj refers to the name \nof the jth .eld. Programs. A program is a sequence of datatype de.nitions td followed by an expression \ne. Requiring all datatype de.nitions to appear .rst simpli.es the subsequent presentation. Semantics. \nThe small-step operational semantics of System D is standard for a call-by-value, polymorphic lambda \ncalculus, and is shown in Figure 2. Following standard practice, the semantics is parameterized by a \nfunction d that assigns meaning to primitive functions c, including dictionary operations like has, get, \nand set. Because expressions are A-normalized, there is a single congru\u00adence rule, E-COMPAT. Our implementation \ndesugars more palat\u00adable syntax into A-normal form. 4. Type Checking In this section, we present the \nSystem D type system, comprising several well-formedness relations, an expression typing relation, and, \nat the heart of our approach, a novel subtyping relation which discharges obligations involving nested \nre.nements through a com\u00adbination of syntactic and semantic, SMT-based reasoning. We .rst de.ne environments \nfor type checking. Environments. Type environments G are of the form G ::= \u00d8| G,x:S | G,A | G,p where \nbindings either record the derived type S for a variable x, a type variable A introduced in the scope \nof a type function, or a formula p that is recorded to track the control .ow along branches of an if-expression. \nA type de.nition environment . records the de.nition of each constructor type C. As type de.nitions appear \nat the beginning of a program, we assume for clarity that . is .xed and globally visible, and elide it \nfrom the judgments. In the sequel, we assume that . contains at least the de.nition type List[+A]{ hd \n:{. | . :: A}; tl :{. | . :: List[A]}}. 4.1 Well-formedness Figure 3 de.nes the well-formedness relations. \nx fresh G,x:Top f p[x/.]G,A f S G f{. | p} G f.A. S Well-Formed Formulas G f p G f lw G f U .i. G f lwi \nG f p G f q G f lw :: U G f P (lw)G f p . q Well-Formed Type Terms G f U G f T1 C . Dom(.) G, x:T1 f \nT2 A . G .i. G f Ti G f x : T1 . T2 G f A G f Null G f C[T ] Well-Formed Type Environments f G x/. Dom(G) \nf G f GG f S A/. G f GG f p f\u00d8 f G,x :S f G,A f G,p Well-Formed Type De.nitions .j. A f Tj .i. VarianceOk(Ai,.i,T \n) f type C[.A]{f :T } f td Figure 3. Well-formedness for System D Formulas, Types and Environments. We \nrequire that types be well-formed within the current type environment, which means that formulas used \nin types are boolean propositions and mention only variables that are currently in scope. By convention, \nwe assume that variables used as binders throughout the program are distinct and different from the special \nvalue variable ., which is reserved for types. Therefore, . is never bound in G. When checking the well\u00adformedness \nof a re.nement formula p, we substitute a fresh variable x for . and check that p[x/.] is well-formed \nin the environment ex\u00adtended with x : Top, to the environment, where Top = {. | true}. We use fresh variables \nto prevent duplicate bindings of .. Note that the well-formedness of formulas does not depend on type \nchecking; all that is needed is the ability to syntactically distinguish between terms and propositions. \nChecking that values are well-formed is straightforward; the important point is that a variable x may \nbe used only if it is bound in G. Datatype De.nitions. To check that a datatype de.nition is well\u00adformed, \nwe .rst check that the types of the .elds are well-formed in an environment containing the declared type \nparameters. Then, to enable a sound subtyping rule for constructed types in the se\u00adquel, we check that \nthe declared variance annotations are respected within the type de.nition. For this, we use a procedure \nVarianceOk (de.ned in a technical report [8]) that recursively walks formulas to record whether type \nvariables occur in positive or negative posi\u00adtions within the types of the .elds.  4.2 Expression Typing \nThe expression typing judgment G f e :: S, de.ned in Figure 4, veri.es that expression e has type scheme \nS in environment G. We highlight the important aspects of the typing rules.  Constants. Each primitive \nconstant c has a type, denoted by ty(c),thatisusedby T-CONST.Basicvalueslikeintegers,booleans, etc. are \ngiven singleton types stating that their value equals the cor\u00adresponding constant in the re.nement logic. \nFor example: 1 :: {. | . = 1} true :: {. | . = true} john :: {. | . = john } false :: {. | . = false} \n Arithmetic and boolean operations have types that re.ect their semantics. Equality on base values is \nde.ned in the standard way, while equality on function values is physical equality. + :: x : Int . y \n: Int .{. | Int(.) . . = x + y} not :: x : Bool .{. | Bool(.) . x = true . . = false} = :: x : Top . \ny : Top .{. | Bool(.) . . = true . x = y} fix :: .A. (A . A) . A tag :: x : Top .{. | . = tag(x)} The \nconstant fix is used to encode recursion, and the type for the tag-test operation uses an axiomatized \nfunction in the logic. The operations on dictionaries are given re.nement types over McCarthy s theory \nof arrays extended with a default element, which we write as bot, that is different from all program \nvalues. The extended theory is shown to be decidable in [13]. {} :: {. | . = empty} has :: d : Dict . \nk : Str .{. | Bool(.) . . = true . has(d, k)} get :: d : Dict . k : {. | Str(.) . has(d, .)}.{. | . \n= sel(d, k)} set :: d : Dict . k : Str . x : Top.{. | . = upd(d, k, x)} keys :: d : Dict . List[{. | \nStr(.) . has(d, .)}] The types above use the constant empty to denote the empty dic\u00adtionary, and the \npredicate has(d, k) to abbreviate sel(d, k) = bot. To relate two dictionaries, we use EqMod(d1,d2,K) \nto abbreviate ' ''' .k. (.k.K k = k ) . sel(d1,k )= sel(d2,k ) which states that the dictionaries d1 \nand d2 are identical except at the keys in K. This expansion falls into the array property frag\u00adment, \nshown to be decidable in [7] by reduction to an equisatis.\u00ad able quanti.er-free formula. The EqMod abbreviation \nis particu\u00adlarly useful for dictionary updates where we do not know the ex\u00adact value being stored, but \ndo know some abstraction thereof, e.g. its type. For example, in incCounter (from section 2) we do not \nknow what value is stored in the count .eld c, only that it is an integer. Thus, we say that the new \ndictionary is the same as the old except at c, where the binding is an integer. A more direct approach \nwould be to use an existentially quanti.ed variable to represent the stored value and say that the resulting \ndictionary is the original dictionary updated to contain this quanti.ed value. Unfortunately, that would \ntake the formulas outside the decidable fragment of the logic, thereby precluding SMT-based logical subtyping. \nStandard Rules. We brie.y identify several typing rules that are standard for lambda calculi with dependent \nre.nements. T-VAR and T-VARPOLY assign types to variable expressions x. If x is bound to a (monomorphic) \nre.nement type in G, then T-VAR as\u00adsigns x the singleton type that says that the expression x evaluates \nto the same value as the variable x. T-IF assigns the type scheme S to an if-expression if the condition \nw is a boolean-valued expres\u00adsion, the then-branch expression e1 has type scheme S under the assumption \nthat w evaluates to true, and the else-branch expres\u00adsion e2 has type scheme S under the assumption that \nw evaluates to false. The T-APP rule is standard, but notice that the arrow type of w1 is nested inside \na re.nement type. In T-LET, the type scheme S2 must be well-formed in G, which prevents the variable \nx from Type Checking G f e :: S [T-CONST] G f c :: ty(c) G(x)= T G(x)= .A. S [T-VAR] [T-VARPOLY] G f \nx :: {. | . = x} G f x :: .A. S G f w1 :: Dict G f w2 :: Str G f w3 :: S [T-EXTEND] G f w1 ++ {w2 . \nw3} :: {. | . = w1 ++ {w2 . w3}} G f w :: Bool G,w = true f e1 :: S G,w = false f e2 :: S [T-IF] G f \nif w then e1 else e2 :: S G f T1 G,x:T1 f e :: T2 [T-FUN] G f .x. e :: {. | . = .x. e . . :: x : T1 . \nT2} G f w1 :: {. | . :: x :T11 . T12} G f w2 :: T11 [T-APP] G f w1 w2 :: T12[w2/x] A/. GG,A f e :: S \n[T-TFUN] G f .A. e :: .A. S G f T G f w :: .A. S [T-TAPP] G f w [T ] :: Inst(S, A, T ) .i. G f Ti .(C)=[.A]{f \n: T '} .j. G f wj :: Inst(Tj ' , A, T ) [T-FOLD] G f C(w) :: {. | Fold(C, T , w)} G f e :: {. | . :: \nC[T ]} [T-UNFOLD] G f e :: {. | Unfold(C, T )} G f S1 G f e1 :: S1 G,x : S1 f e2 :: S2 G f S2 [T-LET] \nG f let x = e1 in e2 :: S2 G f e :: S ' G f S ' S G f S [T-SUB] G f e :: S Figure 4. Type checking for \nSystem D escaping its scope. T-SUB allows expression e to be used with type S if e has type S ' and S \n' is a subtype of S. Type Instantiation. The T-TAPP rules uses the procedure Inst to instantiate a type \nvariable with a (monomorphic) type. Inst is de.ned recursively on formulas, type terms, and types, where \nthe only non-trivial case involves type predicates with type variables: Inst(lw :: A, A, {. | p})= p[lw/.] \nInst(lw :: B, A, T )= lw :: B We write Inst(S, A, T ) to mean the result of applying Inst to S with the \ntype variables and type arguments in succession. Fold and Unfold. The T-FOLD rule is used for records \nof data created with the datatype constructor C and type arguments T . The rule succeeds if the argument \nwj provided for each .eld fj has the required type Tj ' after instantiating all type parameters A with \nthe type arguments T . If these conditions are satis.ed, the formula  Subtyping G f S1 S2 x fresh p \n' 1 = p1[x/.] p ' 2 = p2[x/.] Normalize(p2' )= .i(qi = ri) .i. G,p1 ' f qi = ri [S-MONO] G f{. | p1}{. \n| p2} G f S1 S2 [S-POLY] G f.A. S1 .A. S2 Clause Implication G f q = r Valid([G] . q . r) [C-VALID] G \nf q = r .j. Valid([G] . q . lwj :: U)G,q f U<: Uj [C-IMPSYN] G f q = .i lwi :: Ui Syntactic Subtyping \nG f U1 <: U2 G f T21 T11 G,x : T21 f T12 T22 [U-ARROW] G f x : T11 . T12 <: x:T21 . T22 [U-VAR] [U-NULL] \nG f A<: A G f Null <: C[T ] .(C)=[.A]{\u00b7 \u00b7\u00b7} .i. if .i .{+, =} then G f T1i T2i .i. if .i .{-, =} then \nG f T2i T1i [U-DATATYPE] G f C[T1] <: C[T2] Figure 5. Subtyping for System D returned by Fold(C, T , \nw), de.ned as . = null . tag(.)= Dict . . :: C[T ] . (.j sel(., fj )= wj ) records that the value is \nnon-null, that the values stored in the .elds are precisely the values used to construct the record, \nand that the value has a type corresponding to the speci.c constructor used to create the value. T-UNFOLD \nexposes the .elds of non-null constructed data as a dictionary, using Unfold(C, T ), de.ned as . = null \n.(tag(.)= Dict . (.j [Tj '' ](sel(., fj )))) where .(C)=[.A]{f : T '}, [{. | p}](lw) p[lw/.], and for \nall j, T '' = Inst(Tj ' , A, T ). For example, Unfold(List, Int) is j . = null .(tag(.)= Dict . tag(sel(., \nhd )) = Int . sel(., tl ) :: List[Int])  4.3 Subtyping In traditional re.nement type systems, there \nis a two-level hierar\u00adchy between types and re.nements that allows a syntax-directed reduction of subtyping \nobligations to SMT implications [16, 23, 31]. In contrast, System D s re.nements include uninterpreted \ntype predicates that are beyond the scope of (.rst-order) SMT solvers. Let us consider the problem of \nestablishing the subtyping judg\u00adment G f{. | p1}{. | p2}. We cannot use the SMT query (2) [G] . p1 . \np2 as the presence of (uninterpreted) type-predicates may conserva\u00adtively render the implication invalid. \nInstead, our strategy is to mas\u00adsage the re.nements into a normal form that makes it easy to factor the \nimplication in (2) into a collection of subgoals whose conse\u00adquents are either simple (non-type) predicates \nor type predicates. The former can be established via SMT and the latter by recursively invoking syntactic \nsubtyping. Next, we show how this strategy is realized by the rules in Figure 5. Step 1: Split query \ninto subgoals. We start by converting p2 into a normalized conjunction .i(qi = ri). Each conjunct, or \nclause, qi = ri is normalized such that its consequent is a disjunction of type predicates. We use the \nsymbol = instead of the usual implication arrow . to emphasize the normal structure of each clause. By \nsplitting p2 into its normalized clauses, rule S-MONO reduces the goal (2) to the equivalent collection \nof subgoals .i. G,p1 f qi = ri Step 2: Discharge subgoals. The normalization ensures that the consequent \nof each subgoal above is a disjunction of type predi\u00adcates. When the disjunction of a clause is empty, \nthe subgoal is ( type predicate-free ) G,p1 f qi = false which rule C-VALID handles by SMT. Otherwise, \nthe subgoal is ( type predicate ) G,p1 f qi = lwj :: Uj which rule C-IMPSYN handles via type extraction \nfollowed by a use of of syntactic subtyping. In particular, the rule tries to establish one of the disjuncts \nlwj :: Uj , by searching for a type term U that occurs in G that 1) .ows to lwj , i.e. for which we can \ndeduce via SMT that [G] . p1 . qi . lwj :: U is valid and, 2) is a syntactic subtype of Uj in an appropriately \nstrengthened environment (written G,p1,qi f U<: Uj ). The rules U-DATATYPE and U-ARROW establish syntactic \n(re.nement) sub\u00adtyping, by (recursively) establishing that subtyping holds for the matching components \n[6, 16, 31]. Because syntactic subtyping re\u00adcursively refers to subtyping, the S-MONO rule uses fresh \nvariables to avoid duplicate bindings of . in the environment. Formula Normalization. Procedure Normalize \nconverts a for\u00admula p into a conjunction of clauses .i(qi = ri) as described above. The conversion is \ncarried out by translating p to conjunctive normal form (CNF), and then for each CNF clause, rearranging \nlit\u00aderals and adding negations as necessary. For example, Normalize(. = null) \u00ac(. = null) = false Normalize(. \n= null . . :: U) \u00ac(. = null) = . :: U Formula Implication. In each SMT implication query [G].p . q, the \noperator [\u00b7] describes the embedding of environments and types into the logic as follows: [{. | p} p \n[G,x :T G . [T ][x/.] true [G,x :.A. S G [\u00d8 [G,p] [G] . p [G,A] [ G] When embedding values into the \nlogic, we represent each lambda by a distinct uninterpreted constant. Thus, function equality is physical \nequality, so there is no concern about the equivalence of expressions. (Note that lambdas never need \nto appear inside re.nement formulas in source programs, and are included in the grammar of formulas just \nfor the metatheory.) Ensuring Termination. An important concern remains: as we ex\u00adtract type terms from \nthe environment and recursively invoke the subtyping relation on them, we do not have the usual guarantee \nthat subtyping is recursively invoked on strictly syntactically smaller terms. Thus, it is not clear \nwhether subtyping checks will terminate.  Indeed, if we are not careful, they may not! Consider the \nenviron\u00adment G y : Top,x : {. | . = y . . :: U} where Ua:{. | . :: b : {. | . = y}. Top}. Top and suppose \nwe wish to check that G f true = y :: x : {. | . = y}. Top. (3) C-VALID cannot derive this judgment, \nsince the implication [G] . true . y :: x:{. | . = y}. Top is not valid. Thus, we must derive Equation \n3 by C-IMPSYN. Type extraction derives that y :: U in G, so the remaining obligation is G f U<: x:{. \n| . = y}. Top. Because of the contravariance of function subtyping on the left\u00adhand side of the arrow, \nthe following judgment must be derivable: G f{. | . = y}{. | . :: b:{. | . = y}. Top}. After SA-MONO \nsubstitutes a fresh variable, say . ', for . in both types, this reduces to the clause implication obligation \nG,. ' = y f true = . ' :: b : {. | . = y}. Top. Alas, this is essentially Equation 3, so we are stuck \nin an in.nite loop! We will again extract the type U for y (aliased to . ' here) and repeat the process \nad ini.nitum. This situation arises only if we are allowed to invoke the rule C-IMPSYN in.nitely many \ntimes. In this case, C-IMPSYN extracts a single type term from the environment in.nitely often, since \nthere are only .nitely many in the environment. We cut the loop with a modest restriction: along any \nbranch of a subtyping derivation, we allow a type term to be extracted at most once. Since there are \nonly .nitely many type terms in the environment, this is enough to ensure termination. To implement this \nstrategy, we augment the subtyping relations to take a set of already-used type terms as an additional \nparameter, which cannot be extracted by the rule C-IMPSYN. To keep the presentation in this paper simpler, \nwe elide this restriction from the subtyping rules in Figure 5; the full de.nition can be found in a \ntechnical report [8]. The versions with and without this restriction may or may not coincide, but we \nare not particularly concerned with the outcome of this question because in our experience the kind of \nproblematic subtyping obligation discussed in this section is a pathological corner case that does not \narise in practice. Recap. Recall that our goal is to typecheck programs which use value-indexed dictionaries \nwhich may contain functions as values. On the one hand, the theory of .nite maps allows us to use logical \nre.nements to express and verify complex invariants about the contents of dictionaries. On the other, \nwithout resorting to higher\u00adorder logic, such theories cannot express that a dictionary maps a key to \na value of function type. To resolve this tension, we introduced the novel concept of nested re.nements, \nwhere types are nested into the logic as unin\u00adterpreted terms and the typing relation is nested as an \nuninterpreted predicate. The logical validity queries arising in typechecking are discharged by rearranging \nthe formula in question into an impli\u00adcation between a purely logical formula and a disjunction of type \npredicates. This implication is discharged using a novel combina\u00adtion of logical queries, discharged \nby an SMT solver, and syntac\u00adtic subtyping. This approach enables the ef.cient, automatic type checking \nof sophisticated dynamic language programs that manip\u00adulate complex data, including dictionaries which \nmap keys to func\u00adtion values. 5. Soundness At this point in the proceedings, it is customary to make \na claim about the soundness of the type system by asserting that it enjoys the standard preservation \nand progress properties. Unfortunately, the presence of nested re.nements means this route is unavailable \nto us, as the usual substitution property does not hold! Next, we describe why substitution is problematic \nand de.ne a strati.ed system System D* for which we establish the preservation and progress properties. \nThe soundness of System D follows, as it is a special case of the strati.ed System D* . 5.1 The Problems \nThe key insight in System D is that we can use uninterpreted functions to nest types inside re.nements, \nthereby unlocking the door to expressive SMT-based reasoning for dynamic languages. However, this very \nstrength precludes the usual substitution lemma upon which preservation proofs rest. Substitution. The \nstandard substitution property requires that if x : S, G f e :: S ' and f w :: S, then G[w/x] f e[w/x] \n:: S ' [w/x]. The following snippet shows why System D lacks this property: let foo f=0in foo (fun x->x+1) \nSuppose that we ascribe to foo the type foo :: f :(Int . Int) .{. | f :: Int . Int}. The return type \nof the function states that its argument f is a func\u00adtion from integers to integers and does not impose \nany constraints on the return value itself. To check that foo does indeed have this type, by T-FUN, the \nfollowing judgment must be derivable: f :Int . Int f 0 :: {. | f :: Int . Int} (4) By T-CONST, T-SUB, \nS-MONO and C-VALID the judgment re\u00adduces to the implication true . f :: Int . Int . [ty(0)][0/.] . f \n:: Int . Int. which is trivially valid, thereby deriving (4), and showing that foo does indeed have the \nascribed type. Next, consider the call to foo. By T-APP, the result has type {. | (fun x->x+1) :: Int \n. Int}. The expression foo(fun x->x+ 1) evaluates in one step to 0. Thus, if the substitution property \nis to hold, 0 should also have the above type. In other words, System D must be able to derive f 0 :: \n{. | (funx ->x+1) :: Int . Int}. By T-CONST, T-SUB, S-MONO, and C-VALID, the judgment re\u00adduces to the \nimplication true . [ty(0)][0/.] . (funx ->x+1) :: Int . Int (5) which is invalid as type predicates are \nuninterpreted in our re.ne\u00adment logic! Thus, the call to foo and the reduced value do not have the same \ntype in System D, which illustrates the crux of the prob\u00adlem: the C-VALID rule is not closed under substitution. \nCircularity. Thus, it is clear that the substitution lemma will require that we de.ne an interpretation \nfor type predicates. As a .rst attempt, we can de.ne an interpretation I that interprets type predicates \ninvolving arrows as: I|= .x. e :: x :T1 . T2 iff x:T1 f e :: T2. Next, let us replace C-VALID with the \nfollowing rule that restricts the antecedent to the above interpretation: I| = [G] . p . q [C-VALID-INTERPRETED] \nG f p = q  Notice that the new rule requires the implication be valid in the particular interpretation \nI instead of in all interpretations. This al\u00adlows the logic to hook back into the type system to derive \ntypes for closed lambda expressions, thereby discharging the problematic implication query in (5). While \nthe rule solves the problem with substitution, it does not take us safely to the shore it introduces \na circular dependence between the typing judgments and the inter\u00adpretation I. Since our re.nement logic \nincludes negation, the type system corresponding to the set of rules outlined earlier combined with C-VALID-INTERPRETED \nis not necessarily well-de.ned.  5.2 The Solution: Strati.ed System D* Thus, to prove soundness, we \nrequire a well-founded means of interpreting type predicates. We achieve this by stratifying the interpretations \nand type derivations, requiring that type deriva\u00adtions at each level refer to interpretations at the \nsame level, and that interpretations at each level refer to derivations at strictly lower levels. Next, \nwe formalize this intuition and state the im\u00adportant lemmas and theorems. The full proofs may be found \nin a technical report [8]. Formally, we make the following changes. First, we index typ\u00ading judgments \n(fn) and interpretations (In) with a natural number n. We call these the level-n judgments and interpretations, \nrespec\u00adtively. Second, we allow level-n judgments to use the rule In | = [G] . p . q [C-VALID-N] G fn \np = q and the level-n interpretations to use lower-level type derivations: In |= .x. e :: x :T1 . T2 \niff x:T1 fn-1 e :: T2. Finally, we write G f* e :: S iff .n. G fn e :: S. The derivations in System D* \nconsist of the derivations at all levels. The following lifting lemma states that the derivations at \neach level include the derivations at all lower levels: Lemma (Lifting Derivations). 1. If G f e :: S, \nthen G f* e :: S. 2. If G fn e :: S, then G fn+1 e :: S.  The .rst clause holds since the original \nSystem D derivations cannot use the C-VALID-N rule, i.e. G f e :: S exactly when G f0 e :: S. The second \nclause follows from the de.nitions of fn and In. Strati.cation snaps the circularity knot and enables \nthe proof of the following strati.ed substitution lemma: Lemma (Strati.ed Substitution). If x: S, G fn \ne :: S ' and fn w :: S, then G[w/x] fn+1 e[w/x] :: S ' [w/x]. The proof of the above depends on the following \nlemma, which captures the connection between our typing rules and the logical interpretation of formulas \nin our re.nement logic: Lemma (Satis.able Typing). If fn w :: T , then In+1 |= [T ][w/x]. Strati.ed substitution \nenables the following preservation result: Theorem (Strati.ed Preservation). If fn e :: S, and ey. e \n' then fn+1 e ' :: S. From this, and a separate progress result, we establish the type soundness of System \nD* : Theorem (System D* Type Soundness). If f* e :: S, then either e is a value or ey. e ' and f* e ' \n:: S. By coupling this with Lifting, we obtain the soundness of System D as a corollary. 6. Algorithmic \nTyping Having established the expressiveness and soundness of System D, we establish its practicality \nby implementing a type checker and applying it to several interesting examples. The declarative rules \nfor type checking System D programs, shown in section 4, are not syntax-directed and thus unsuitable \nfor implementation. We highlight the problematic rules and sketch an algorithmic version of the type \nsystem that also performs local type inference [29]. Our prototype implementation [8] veri.es all of \nthe examples in this paper and in [39], using Z3 [12] to discharge SMT obligations. A more detailed discussion \nof the algorithmic system may be found in a technical report [8]. 6.1 Algorithmic Subtyping Nearly all \nthe declarative subtyping rules presented in Figure 5 are non-overlapping and directed by the structure \nof the judgment be\u00ading derived. The sole exception is C-IMPSYN, whose .rst premise requires us to synthesize \na type term U such that the SMT solver can prove lwj :: U for some j, where U is used in the second premise. \nWe note that, since type predicates are uninterpreted, the only type terms U that can satisfy this criterion \nmust come from the environment G. Thus, we de.ne a procedure MustFlow(G,T ) that uses the SMT solver \nto compute the set of type terms U ' , out of all possible type terms mentioned in G, such that for all \nvalues x, x:T implies that x :: U '. To implement C-IMPSYN, we call MustFlow(G, {. | . = lwj }) to compute \nthe set U of type terms that might be needed by the second premise. Since the declarative rule cannot \npossibly refer to a type term U not in G, this strategy guarantees that U .U and, thus, does not forfeit \nprecision.  6.2 Bidirectional Type Checking We extend the syntax of System D with optional type annotations \nfor binding constructs and constructed data, and, following work on local type inference [29], we de.ne \na bidirectional type checking algorithm. In the remainder of this section, we highlight the novel aspects \nof our bidirectional type system. Function Applications. To typecheck an application w1 w2, we must synthesize \na type T1 for the function w1 and use type ex\u00adtraction to convert T1 to a syntactic arrow. Since the \nprocedure MustFlow can return an arbitrary number of type terms, we must decide how to proceed in the \nevent that T1 can be extracted to mul\u00adtiple different arrow types. To avoid the need for backtracking \nin the type checker, and to provide a semantics that is simple for the programmer, we synthesize a type \nfor w1 only if there is exactly one syntactic arrow that is applicable to the given argument w2. Remaining \nRules. We will now brie.y summarize some of the other algorithmic rules presented in a technical report \n[8]. Uses of T-SUB can be factored into other typing rules. However, uses of T-UNFOLD cannot, since we \ncannot syntactically predict where it is needed. Since we do not have pattern matching to determine exactly \nwhen to unfold type de.nitions, as in languages like ML, we eagerly unfold type de.nitions to anticipate \nall situations in which unfolding might be required. For let-expressions, to handle the fact that synthesized \ntypes might refer to variables that are about to go out of scope, making them ill-formed, we use several \nsimple heuristics to eliminate occurrences of local variables. In all of the examples we have tested, \nthe annotations provided on top\u00adlevel let-bindings are suf.cient to allow synthesizing well-formed types \nfor all unannotated inner let-expressions. Precise types are synthesized for if-expressions by synthesizing \nthe types of both branches, guarding them by the appropriate branch conditions, and conjoining them. \nFor constructed data expressions, we allow the programmer to provide hints in type de.nitions that help \nthe type checker decide how to infer type parameters that are omitted. For example, suppose the List \nde.nition is updated as follows:  type List[+A]{ hd : {. | . :: A}; tl : {. | . :: List[*A]}} Due to \nthe presence of the marker * in the type of the tl .eld, local type inference will use the type of w2 \nto infer the omitted type parameter in List(w1,w2). Finally, although the techniques in [29] would allow \nus to, for simplicity we do not attempt to synthesize parameters to type functions. Soundness. We write \nG f e < S for the algorithmic type check\u00ading judgment, which veri.es e against the given type S, and \nG f e c S for the algorithmic type synthesis judgment, which pro\u00adduces a type S for expression e. Each \nof the techniques employed in this section are sound with respect to the declarative system, so we can \nshow the following property, where we use a procedure erase to remove type annotations from functions, \nlet-bindings, and constructed data because the syntax of the declarative system does not permit them: \nProposition (Sound Algorithmic Typing). If G f e c S or G f e < S, then G f erase(e) :: S. 7. Related \nWork In this section, we highlight related approaches to statically verify\u00ading features of dynamic languages. \nFor a thorough introduction to contract-based and other hybrid approaches, see [15, 23, 34]. Dynamic \nUnions and Control Flow. Among the earliest attempts at mixing static and dynamic typing was adding the \nspecial type dynamic to a statically-typed language like ML [1]. In this ap\u00ad proach, an arbitrary value \ncan be injected into dynamic, and a typecase construct allows inspecting its precise type at run-time. \nHowever, one cannot guarantee that a particular dynamic value is of one of a subset of types (cf. negate \nfrom section 2). Several researchers have used union types and tag-test sensitive control\u00ad.ow analyses \nto support such idioms. Most recently, .TR [39] and .S [18] feature values of (untagged) union types \nthat can be used at more precise types based on control .ow. In the former, each ex\u00adpression is assigned \ntwo propositional formulas that hold when the expression evaluates to either true or false; these propositions \nare strengthened by recording the guard of an if-expression in the typ\u00ading environment when typing its \nbranches. Typechecking proceeds by solving propositional constraints to compute, for each value at each \nprogram point, the set of tags it may correspond to. The latter shows how a similar strategy can be developed \nin an imperative set\u00adting, by coupling a type system with a data .ow analysis. However, both systems \nare limited to ad-hoc unions over basic and function values. In contrast, System D shows how, by pushing \nall the infor\u00admation about the value (resp. reasoning about .ow) into expressive, but decidable re.nement \npredicates (resp. into SMT solvers), one can statically reason about signi.cantly richer idioms (related \ntags, dynamic dictionaries, polymorphism, etc.). Records and Objects. There is a large body of work on \ntype systems for objects [22, 28]. Several early advances incorporate records into ML [30], but the use \nof records in these systems is un\u00ad fortunately unlikely to be .exible enough for dynamic dictionaries. \nIn particular, record types cannot be joined when they disagree on the type of a common .eld, which is \ncrucially enabled by the use of the theory of .nite maps in our setting. Recent work includes type systems \nfor JavaScript and Ruby. [3] presents a rich type system and inference algorithm for JavaScript, which \nuses row-types and width subtyping to model dictionaries (objects). The system does not support unions, \nand uses .xed .eld names. This issue is ad\u00addressed in [38], which models dictionaries using row types \nlabeled by singletons indexed by string constants, and depth subtyping. A recent proposal [41] incorporates \nan initialization phase during which object types can be updated. However, these systems pre\u00adclude truly \ndynamic dictionaries, which require dependent types, and moreover lack the control .ow analysis required \nto support ad-hoc unions. DRuby [17] is a powerful type system designed to support Ruby code that mixes \nintersections, unions, classes, and parametric polymorphism. DRuby supports duck typing, by con\u00adverting \nfrom nominal to structural types appropriately. However, it does not support ad-hoc unions or dynamic \ndictionary accesses. Dependent Types for First-Order Programs. The observation that ad-hoc unions can \nbe checked via dependent types is not new. [24] develops a dependent type system called guarded types \nthat is used to describe records and ad-hoc unions in legacy Cobol pro\u00adgrams that make extensive use \nof tag-tests, where the tag is sim\u00adply the .rst few bytes of a structure. [21] presents an SMT-based \nsystem for statically inferring dependent types that verify the safety of ad-hoc unions in legacy C programs. \n[10] describes how type\u00ad checking and property veri.cation are two sides of the same coin for C (which \nis essentially uni-typed.) It develops a precise logic\u00adbased type system for C and shows how SMT solvers \ncan be used for type-checking. This system contains a hastype(x,T) which is similar to ours except that \nT ranges over a .xed set of type constants as opposed to arbitrary types. Thus, one cannot use their \nhastype to talk about complex values (e.g. dependent functions, duck-typed records with only some .elds) \nnested within dictionaries in their system. Finally, the system supports function pointers but does not \nfully support higher-order functions. Dminor [6] uses re.nement types to formalize similar ideas in a \n.rst-order functional data de\u00adscription language with .xed-key records and run-time tag-tests. The authors \nshow how unions and intersections can be expressed in re.nements (and even collections, via recursive \nfunctions), and hence how SMT solvers can wholly discharge all subtyping obli\u00adgations. However, the above \ntechniques apply only to .rst-order languages, with static keys and dictionaries over base values. Re.nement \nTypes for Higher-Order Programs. The key novelty of System D is the introduction of nested re.nement \ntypes, which are a generalization of the re.nement types introduced by the long line of work pioneered \nby Xi and Pfenning [40] and further stud\u00ad ied in [4, 11, 14, 23, 31, 35]. The main dif.culty in applying \nthese classical re.nement type systems to dynamic languages is that they require a distinction between \nbase values that are typed with re.ne\u00adment predicates and complex values that are typed with syntactic \nconstructors. In particular, dynamic languages contain dependent dictionaries, which require re.nements \n(over the theory of arrays) to describe keys but syntactic types to describe the values bound to keys. \nThis combination is impossible with earlier re.nement types systems but is enabled by nesting types within \nre.nements. Combining Decision Procedures. Our approach of combining logical reasoning by SMT solvers \nand syntactic reasoning by sub\u00adtyping is reminiscent of work on combining decision procedures [26, 33]. \nHowever, such techniques require the theories being com\u00ad bined to be disjoint; since our logic includes \ntype terms which themselves contain arbitrary terms, our theory of syntactic types cannot be separated \nfrom the other theories in our system, so these techniques cannot be directly applied. 8. Conclusions \nand Future Work We have shown how, by nesting type predicates within re.nement formulas and carefully \ninterleaving syntactic-and SMT-based sub\u00adtyping, System D can statically type check dynamic programs \nthat manipulate dictionaries, polymorphic higher-order functions and containers. Thus, we believe that \nSystem D can be a foundation for two distinct avenues of research: the addition of heterogeneous dictionaries \nto static languages like C#, Java, OCaml and Haskell, or dually, the addition of expressive static typing \nto dynamic lan\u00adguages like Clojure, JavaScript, Racket, and Ruby.  We anticipate several concrete lines \nof work that are needed to realize the above goals. First, we need to add support for references and \nimperative update, features common to most popular dynamic languages. Since every dictionary operation \nin an imperative lan\u00adguage goes through a reference, we will need to extend the type system with .ow-sensitive \nanalyses, as in [32] and [18], to precisely track the values stored in reference cells at each program \npoint. Fur\u00adthermore, to precisely track updates to dictionaries in the impera\u00adtive setting, we will likely \nneed to introduce some .ow-sensitivity to the type system itself, adopting strong update techniques as \nin [19] and [41]. Second, our system treats strings as atomic constants. Instead, it should be possible \nto incorporate modern decision proce\u00addures for strings [20] to support logical operations on keys, which \nwould give even more precise support for re.ective metaprogram\u00adming. Third, we plan to extend our local \ninference techniques to au\u00adtomatically derive polymorphic instantiations [29] and use Liquid Types [31] \nto globally infer re.nement types. Finally, for dynamic languages, it would be useful to incorporate \nsome form of staged analysis to support dynamic code generation [2, 9]. Acknowledgements. The authors \nwish to thank Jeff Foster, Ming Kawaguchi, Sorin Lerner, Todd Millstein, Zachary Tatlock, David Walker, \nand the anonymous reviewers for their detailed feedback on drafts of this paper. References [1] M. Abadi, \nL. Cardelli, B. C. Pierce, and G. Plotkin. Dynamic typing in a statically-typed language. In POPL, 1989. \n[2] J.-h. D. An, A. Chaudhuri, J. S. Foster, and M. Hicks. Dynamic inference of static types for ruby. \nIn POPL, 2011. [3] C. Anderson, S. Drossopoulou, and P. Giannini. Towards Type Infer\u00adence for JavaScript. \nIn ECOOP, pages 428 452, June 2005. [4] J. Bengtson, K. Bhargavan, C. Fournet, A. Gordon, and S. Maffeis. \nRe.nement types for secure implementations. In CSF, 2008. [5] Y. Bertot and P. Cast\u00b4eran. Interactive \ntheorem proving and program development. coq art: The calculus of inductive constructions, 2004. [6] \nG. M. Bierman, A. D. Gordon, C. Hritcu, and D. E. Langworthy. Semantic subtyping with an smt solver. \nIn ICFP, 2010. [7] A. R. Bradley, Z. Manna, and H. B. Sipma. What s decidable about arrays? In VMCAI, \npages 427 442, 2006. [8] R. Chugh, P. M. Rondon, and R. Jhala. Nested re.nements: A logic for duck typing. \nhttp://arxiv.org/abs/1103.5055v2. [9] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner. Staged information \n.ow for javascript. In Proceedings of PLDI 2009, pages 50 62, 2009. [10] J. Condit, B. Hackett, S. K. \nLahiri, and S. Qadeer. Unifying type checking and property checking for low-level code. In POPL, 2009. \n[11] R. Davies. Practical Re.nement-Type Checking. PhD thesis, Carnegie Mellon University, Pittsburgh, \nPA, USA, 2005. [12] L. de Moura and N. Bj\u00f8rner. Z3: An ef.cient SMT solver. In TACAS, 2008. [13] L. de \nMoura and N. Bj\u00f8rner. Generalized, ef.cient array decision procedures. In FMCAD, pages 45 52, 2009. [14] \nJ. Dun.eld. A Uni.ed System of Type Re.nements. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, \nUSA, 2007. [15] R. B. Findler and M. Felleisen. Contracts for higher-order functions. In ICFP, pages \n48 59, 2002. [16] C. Flanagan. Hybrid type checking. In POPL. ACM, 2006. [17] M. Furr, J. hoon (David) \nAn, J. S. Foster, and M. W. Hicks. Static type inference for ruby. In SAC, pages 1859 1866, 2009. [18] \nA. Guha, C. Softoiu, and S. Krishnamurthi. Typing local control and state using .ow analysis. In ESOP, \n2011. [19] P. Heidegger and P. Thiemann. Recency types for analyzing scripting languages. In ECOOP, pages \n200 224, 2010. [20] P. Hooimeijer and M. Veanes. An evaluation of automata algorithms for string analysis. \nIn VMCAI, pages 248 262, 2011. [21] R. Jhala, R. Majumdar, and R.-G. Xu. State of the union: Type inference \nvia craig interpolation. In TACAS, 2007. [22] A. J. Kennedy and B. C. Pierce. On decidability of nominal \nsubtyping with variance. In FOOL-WOOD, 2007. [23] K. Knowles and C. Flanagan. Hybrid type checking. ACM \nTOPLAS, 32(2), 2010. [24] R. Komondoor, G. Ramalingam, S. Chandra, and J. Field. Dependent types for \nprogram understanding. In TACAS, pages 157 173, 2005. [25] J. McCarthy. Towards a mathematical science \nof computation. In In IFIP Congress, pages 21 28. North-Holland, 1962. [26] G. Nelson and D. C. Oppen. \nSimpli.cation by cooperating decision procedures. TOPLAS, 1979. [27] X. Ou, G. Tan, Y. Mandelbaum, and \nD. Walker. Dynamic typing with dependent types. In IFIP TCS, pages 437 450, 2004. [28] J. Palsberg and \nM. I. Schwartzbach. OO Type Systems. Wiley, 1994. [29] B. C. Pierce and D. N. Turner. Local type inference. \nIn POPL, pages 252 265, 1998. [30] D. R\u00b4emy. Type checking records and variants in a natural extension \nof ml. In POPL, 1989. [31] P. Rondon, M. Kawaguchi, and R. Jhala. Liquid types. In PLDI, 2008. [32] P. \nRondon, M. Kawaguchi, and R. Jhala. Low-level liquid types. In POPL, pages 131 144, 2010. [33] R. Shostak. \nDeciding combinations of theories. Journal of the ACM, 31(1):1 12, 1984. [34] J. Siek and W. Taha. Gradual \ntyping for functional languages. In Scheme and Functional Programming Workshop, 2006. [35] N. Swamy, \nJ. Chen, and R. Chugh. Enforcing stateful authorization and information .ow policies in .ne. In ESOP, \n2010. [36] The Dojo Foundation. Dojo toolkit. http://dojotoolkit.org/. [37] The Python Software Foundation. \nPython 3.2 standard library. http: //python.org/. [38] P. Thiemann. Towards a type system for analyzing \njavascript pro\u00adgrams. In ESOP, 2005. [39] S. Tobin-Hochstadt and M. Felleisen. Logical types for untyped \nlanguages. In ICFP, pages 117 128, 2010. [40] H. Xi and F. Pfenning. Dependent types in practical programming. \nIn POPL, 1999. [41] T. Zhao. Type inference for scripting languages with implicit exten\u00adsion. In FOOL, \n2010.    \n\t\t\t", "proc_id": "2103656", "abstract": "<p>Programs written in dynamic languages make heavy use of features --- run-time type tests, value-indexed dictionaries, polymorphism, and higher-order functions --- that are beyond the reach of type systems that employ either purely syntactic or purely semantic reasoning. We present a core calculus, System D, that merges these two modes of reasoning into a single powerful mechanism of nested refinement types wherein the typing relation is itself a predicate in the refinement logic. System D coordinates SMT-based logical implication and syntactic subtyping to automatically typecheck sophisticated dynamic language programs. By coupling nested refinements with McCarthy's theory of finite maps, System D can precisely reason about the interaction of higher-order functions, polymorphism, and dictionaries. The addition of type predicates to the refinement logic creates a circularity that leads to unique technical challenges in the metatheory, which we solve with a novel stratification approach that we use to prove the soundness of System D.</p>", "authors": [{"name": "Ravi Chugh", "author_profile_id": "81435596644", "affiliation": "University of California, San Diego, La Jolla, CA, USA", "person_id": "P2991386", "email_address": "rchugh@cs.ucsd.edu", "orcid_id": ""}, {"name": "Patrick M. Rondon", "author_profile_id": "81435603774", "affiliation": "University of California, San Diego, La Jolla, CA, USA", "person_id": "P2991387", "email_address": "prondon@cs.ucsd.edu", "orcid_id": ""}, {"name": "Ranjit Jhala", "author_profile_id": "81100198278", "affiliation": "University of California, San Diego, La Jolla, CA, USA", "person_id": "P2991388", "email_address": "jhala@cs.ucsd.edu", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103686", "year": "2012", "article_id": "2103686", "conference": "POPL", "title": "Nested refinements: a logic for duck typing", "url": "http://dl.acm.org/citation.cfm?id=2103686"}