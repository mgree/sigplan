{"article_publication_date": "01-25-2012", "fulltext": "\n Recursive Proofs for Inductive Tree Data-Structures P.Madhusudan XiaokangQiu AndreiStefanescu University \nofIllinois atUrbana-Champaign,USA {madhu, qiu2, stefane1}@illinois.edu Abstract We develop logical mechanisms \nand procedures to facilitate the veri.cation of full functional properties of inductive tree data\u00adstructures \nusing recursion that are sound,incomplete,but terminat\u00ading. Our contribution rests in a new extension \nof .rst-order logic with recursive de.nitions called Dryad, a syntactical restriction on pre-and post-conditions \nof recursive imperative programs us\u00ading Dryad, and a systematic methodology for accurately unfold\u00ading \nthe footprint on the heap uncovered by the program that leads to .nding simple recursive proofs using \nformula abstraction and calls to SMT solvers. We evaluate our methodology empirically and showthat several \ncomplextreedata-structure algorithms canbe checked against full functional speci.cations automatically, \ngiven pre-and post-conditions. This results in the .rst automatic termi\u00adnating methodology for proving \na wide variety of annotated algo\u00adrithms on treedata-structures correct,including max-heaps, treaps, red-black \ntrees,AVL trees,binomialheaps, andB-trees. Categories andSubjectDescriptors F.3.1[Logics and Meanings \nof Programs]:Specifyingand Verifying and Reasoning about Pro\u00adgrams: Mechanical veri.cation; D.2.4 [Software \nEngineering]: Software/ProgramVeri.cation:Assertion checkers GeneralTerms Algorithms,Reliability,Theory,Veri.cation \nKeywords heap analysis, recursiveprogram, tree,SMT solver 1. Introduction The area of program veri.cation \nusing theorem provers, utilizing manuallyprovidedproof annotations(pre-andpost-conditionsfor functions, \nloop-invariants, etc.) has been a focus of intense re\u00adsearch in the .eld of programming languages. Automatic \ntheory solvers(SMT solvers) thathandle a variety ofquanti.er-freethe\u00adories including arithmetic, uninterpreted \nfunctions, Boolean logic, etc., serve as e.ective tools that automatically discharge the valid\u00adity checking \nof many veri.cation conditions[7]. Akey area that has eluded the above paradigm of speci.cation and veri.cation \nis heap analysis: the veri.cation of programs that dynamically allocate memory and manipulate them using \npoint\u00aders,maintaining structuralinvariants(e.g. thenodesformatree ), aliasinginvariants, andinvariants \nonthedata storedinthelocations (e.g. thekeysofalist aresorted ).Theclassical examplesofthese are thebasic \ndata-structures taughtin undergraduate computer sci- Permission to make digital or hard copies of all \nor part of this work for personal or classroomuseisgranted withoutfeeprovided that copiesarenot madeordistributed \nforpro.tor commercial advantage andthat copiesbearthis notice andthefull citation onthe .rstpage.Tocopy \notherwise,torepublish,topostonservers ortoredistribute tolists, requiresprior speci.cpermission and/or \nafee. POPL 12, January25 27,2012,Philadelphia,PA,USA. Copyright &#38;#169;c2012ACM978-1-4503-1083-3/12/01. \n. .$10.00 ence courses, andincludelinkedlists,queues,binary search trees, max-heaps, balanced AVL trees, \npartially-balanced tree structures like red-black trees, etc. [10]. Object-oriented programs are rich \nwith heap structures as well, and structures are often found in the formof records orlistsofpointerspointing \ntootherhierarchically arrangeddata-structures. Dynamically allocated heaps are di.cult to reason with \nfor several reasons. First, the speci.cation of proof annotations itself is hard, as the annotation needs \nto talk about several intricate properties ofan unboundedheap, often requiringquanti.cation and reachability \npredicates, and needs to specify aliasing as well as structuralproperties of theheap.Also,in experiences \nwith manual veri.cation,ithasbeen observed thatpre-andpost-conditionsget unduly complex, including large \nformulas that say how the frame of the heap that is not touched by the program remains the same across \nafunction.Separationlogic[19,23]has emerged as a wayto address thisproblem, mainly the frameproblem mentioned \nabove, andgives alogic thatpermits usto compositionally reason withthe footprint touchedby theprogram \nand theframeit residesin. Most research on program logics for functional veri.cation of heap-manipulating \nprograms can be roughly divided into two classes:1 Logicsfor manual/semi-automatic reasoning: The mostpop\u00adular \nof these are the class of separation logics[19,23],butsev\u00aderal others exist(see matching logic [24], \nfor example). Com\u00adplex structural properties of heaps are expressed using induc\u00adtive algebraic de.nitions, \nthelogic combines several other the\u00adories like arithmetic, etc., and uses a special separation opera\u00adtor(*)to \ncompositionallyreason with afootprint andtheframe. The analysisis either manualor semi-automatic,thelatterbeing \nusually sound, incomplete, and non-terminating, and proceeds by heuristically searching forproofs using \naproof system, un\u00adrolling recursivede.nitions arbitrarily.Typically, suchtools can .nd simpleproofs if \nthey exist, but are unpredictable, and can\u00adnot robustlyproduce counter-examples.  Logics for completely \nautomated reasoning: These logics stemfromtheSMT(Satis.abilityModuloTheories) and au\u00adtomata theory literature, \nwhere the goal is to develop fast, ter\u00adminating, sound and complete decision procedures, but where the \nlogics are often constrained heavily on expressivity in or\u00adder to reach these goals. Examples include \nseveral logics that extend .rst-order logic with reachability, the logics Lisbq [14] andCSL[6], andthelogicStranddec \n[16]that combines tree theories with integer theories. The problem with these logics, in general, is \nthat they are often not su.ciently expressive to state complexproperties oftheheap(e.g.thebalancedness \nof  1We do not discuss abstraction-based approaches such as shape analysis here as such approaches are \ngeared towards less complex speci.cations, and often are completely automatic, not even requiring proof \nannotations such asloopinvariants; seeSection6.  an AVL tree, or that the set of keys stored in a heap \ndo not change across aprogram). We prefer an approach that combines the two methodologies above.Wepropose \na strategy that(a) identi.es a class of simple and natural proofs for proving veri.cation conditions \nfor heap\u00adbased programs, founded on how people prove these conditions manually, and(b)buildsterminatingprocedures \nthat e.ciently and thoroughly search this class of proofs. This results in a sound, incomplete, but terminating \nprocedure that .nds natural proofs automatically and e.ciently. Many correct programs have simple proofs \nofcorrectness, and aterminatingprocedure that searchesfor these simpleproofs e.ciently canbe a very useful \ntoolinprogram veri.cation. Incompleteness is, of course, a necessary trade-o. to keep the logics expressive \nwhile having a terminating procedure, and a terminating automatic procedure is useful as it does not \nneed manual help. Furthermore, as we shall seein thispaper, such decision algorithms are particularly \ndesirable when they can be made to work very e.ciently, especially using the fast-growing class of e.cientSMT \nsolversforquanti.er-free theories. The idea of searching for only simple and natural proofs is not new; \nafter all, type systems that prove properties of programs areessentially simple(and oftenscalable)proof \nmechanisms.The class of simple and naturalproofs that we identifyin thispaper is, however,quitedi.erentfrom \nthosefoundby type systems. In thispaper, wedevelop logical mechanisms toidentify a sim\u00adple class of proofs \nbased on a deterministic proof tactic that (a) unfolds recursive terms precisely across thefootprint,(b) \nuses for\u00admula abstractions (thatreplace recursivelyde.nedtermswithunin\u00adterpreted terms)to restate the \nveri.cation conditionin aquanti.er\u00adfreedecidable theory, and(c) checks the resultingformula using an \nautomatic decisionprocedure. Wedeploy this technique for the specializeddomain of imperativeprograms \nmanipulatingtreedata\u00adstructures, developing an extension of .rst-order logic with recur\u00adsion on trees \ncalled Dryad to state properties of programs, and building procedures based on precise unfoldings and \nformula ab\u00adstractions. Motivatingformula abstractions When reasoning withformulas thathave recursivelyde.ned \nterms, which canbe unrolledforever, akeyideaisto use formula abstrac\u00adtion that makes the terms uninterpreted. \nIntuitively, the idea is to replace recursively de.ned predicates, sets, etc. by uninterpreted Boolean \nvalues, uninterpreted sets, etc. The idea of formula abstraction is extremely natural, and uti\u00adlized \nvery often in manual proofs. For instance, let us consider a binarysearchtree(BST) search routine searchingfor \nakey k onthe root node x. The veri.cation condition of a path of this program, typically, would require \nchecking: (bst(x). k . keys(x). k < x.key). (k . keys(x.left)) where bst()is a recursive predicate de.ned \non trees that identi.es binary search trees, and keys() is a recursively de.ned set that collects the \nmultiset ofkeys under a node. Unrolling thede.nition of keys()and bst()givesthefollowingformula(below,i \n< S means that i isless than every elementin S): bst(x.left). bst(x.right). keys(x.left)<x.key. keys(x.right)>x.key. \nk.(keys(x.left).keys(x.right).{x.key}). k<x.key). (k.keys(x.left)) Now,whilethe aboveformulaisquite complex,involving \nrecur\u00adsive de.nitions that can be unrolled ad in.nitum, we can prove its validity soundlyby viewing bst()and \nkeys()as uninterpreted func\u00adtions that map locations to Booleans and sets, respectively. Doing thisgives(modulo \nsome renaming and modulo theory of equality): (b1 . b2 . K1=xkey . K2> xkey . k . (K1 . K2 .{xkey}). \nk<xkey) . (k.K1) Note that the above formula is a quanti.er-free formula over in\u00adtegers and multisets \nof integers, and furthermore is valid (since k<xkey and K2>xkey, k must be in K1). Validityof quanti.er-free \nformulas over sets/multisets of integers with addition is decidable (theycanbetranslatedtoquanti.er-freeformulas \noverintegers and uninterpretedfunctions), and canbe solved usingSMT solvers e.\u00adciently. Consequently, \nwe can prove that the veri.cation condition is valid, completely automatically.Note thatformula abstractionis \nsound butincomplete. This idea has been explored in the literature. For example, Suter et al.[25] haveproposed \nabstraction schemesfor algebraic data-types that soundly(butincompletely) transformlogical valid\u00adity \ninto much simpler decidable problems using formula abstrac\u00adtions,anddeveloped mechanismsforproving functional \nprograms correct. Reasoning with Dryad In order to build the procedures for reasoning with programs ma\u00adnipulating \ntrees, using precise unfolding and abstraction, we de\u00advelop a new recursive extension of .rst-order logic, \ncalled Dryad that allows stating complexproperties ofheaps without recourse to explicit quanti.cation. \nDryad combines quanti.er-free .rst-order logic with recursive de.nitions, and these recursive de.nitions, \nthemselves expressed in Dryad, can capture several interesting properties of trees, including their height, \nthe multiset of keys storedin them, whether they correspond to abinary search tree(or anAVL tree), etc. \nThe main technical contribution of this paper is to show how a Hoare-triple corresponding to a basic \npath in a recursive imper\u00adativeprogram(wedisallow while-loops anddemand all recursion bethrough recursivefunctioncalls) \nwithproof annotations written in Dryad, can be expressed as a pair consisting of a .nite foot\u00adprint and \na Dryad formula. The .nite footprint is a symbolic heap that captures the heap explored by the basic \nblock of the program precisely. The construction of this footprint and formula calls for a careful handling \nof the mutating footprint de.ned by a recursive imperative program, calls for a disciplined approach \nto unrolling recursion, and involves capturing aliasing and separation by ex\u00adploiting the fact that the \nmanipulated structures are trees. In par\u00adticular, the procedure keeps track of locations in the footprint \ncor\u00adresponding to trees and precisely computes the value of recursive terms on the these. Furthermore, \nthe veri.cation condition is ac\u00adcurately described by unfolding the pre-condition so that it is ex\u00adpressed \npurely on the frontier of the footprint, so as to enable ef\u00adfective use of the formula abstraction mechanism. \nIn order to be accurate, weplace several key restrictions on the logical syntax of pre-andpost-conditions \nexpressedforfunctions. We then consider the problem of solving the validity problem for the veri.cation \ncondition expressed as a footprint and a Dryad formula. We .rst show a small syntactic fragment of veri.cation \nconditionsthatis entirelydecidable(withoutformula abstraction) by a reduction to the decidable logic \nStranddec [16]. Although this fragment of Dryad is powerful enough to express certain re\u00adstricted structural \nproperties of simple tree data-structures like bi\u00adnary search trees, max-heaps, and treaps, it is completely \ninade\u00adquatein verifying more complexproperties of the above structures as well as properties of more \ncomplex tree data-structures such as red-black trees,binomialheaps, etc. We turn next to abstraction \nschemes for Dryad, and show how to abstractDryad formulasintoquanti.er-freetheories ofsets/mul\u00adtisets \nof integers; the latter can then be translated into formulas in the standard quanti.er-free theory of \nintegers with uninterpreted functions. The .nal formula s validity can be proved using stan\u00addardSMTsolvers, \nandits validityimplies the validity of theDryad formula.  dir . Dir i* : Loc . Int x . Loc Variables \nS . S(Int)Variables f . DF si* : Loc . S(Int) j. Int Variables MS . MS(Int)Variables p * : Loc . {true, \nfalse} msi* : Loc . MS(Int) q . Boolean Variables c : Int Constant Loc Term: lt, lt1, lt2 ... ::= x \n| nil | lt.dir Int Term: it, it1, it2,... ::= c | j| lt.f | i*(lt)| it1 + it2 | it1 - it2 | ite(., it1, \nit2) S(Int)Term: sit, sit1, sit2,... ::= \u00d8| S |{it}| si*(lt) | sit1 . sit2 | sit1 n sit2 | sit1 \\ sit2 \n| ite(., sit1, sit2) MS(Int)Term: msit, msit1, msit2,... ::= \u00d8m | MS |{it}m | msi *(lt)| msit1 . msit2 \n| msit1 n msit2 | msit1\\msit2 | ite(., msit1, msit2) Formula: ., .1,.2,... ::= true | q | p *(lt)| lt1 \n= lt2 | it1 = it2 | sit1 . sit2 | msit1 . msit2 | sit1 = sit2 | msit1 = msit2 | it . sit | it . msit \n|\u00ac. | .1 . .2 def Recursively-de.ned integer : i*(x) = ite(x = nil, ibase, iind) def Recursively-de.ned \nset-of-integers : si*(x) = ite(x = nil, sibase, siind) def Recursively-de.ned multiset-of-integers : \nmsi*(x) = ite(x = nil, msibase, msiind) def Recursively-de.nedpredicate : p *(x) = ite(x = nil, pbase, \npind) Figure1. Syntax ofDryad Finally, we evaluate ourlogicalmechanisms andprocedures,by writing several \ntree data-structure algorithms using pure recursive imperative programs, annotating them using Dryad \nin order to state their complete functional correctness, derive the veri.cation conditions expressed \nas footprints and Dryad formulae, and prove them valid using the formula abstraction scheme. Much to \nour surprise, all veri.cation conditionsin alltheprograms wereproved valid automatically and e.cientlyby \nourprocedure. We have veri.ed full functional correctness of data-structures ranging from sorted linked \nlists, binary search trees, max-heaps, treaps (which are binary search trees on the .rst key and max\u00adheaps \nonthe second),AVLtrees andred-blacktrees(semi-balanced search trees), B-trees, and binomial heaps. This \nset of bench\u00admarks is an almost exhaustive list of algorithms on tree-based data-structures covered in \na .rst undergraduate course on data\u00adstructures[10].Tothebest of ourknowledge,the workpresented hereisthe \n.rst methodology that canprovesuch awidevariety of algorithms ontreedata-structures writtenin animperativelanguage \nfullyfunctionallycorrect using a sound andterminatingprocedure. 2. The Dryad LogicforHeaps The recursivelogic \novertrees,Dryad,isessentially a quanti.er-free .rst-orderlogic overheaps augmented with recursivede.nitions \nof various types(e.g.,integers, sets/multisets ofintegers, etc.)de.ned for locations that have a tree \nunder them. While .rst-order logic gives the necessarypower to talkprecisely aboutlocations that are \nnear neighbors, the recursive de.nitions allow expressing proper\u00adties that require quanti.ers, including \nreachability, collecting the set/multisetofkeysinatree,andde.ning natural metrics,likethe height of a \ntree, that are typically useful in de.ning properties of trees. Given a .nite set of directions Dir, \nlet us de.ne Dir-trees as .nite trees where every location has either |Dir| children, or is the nil location, \nwhichhas no children(we assumethereis a single nil location).Binary treeshave twodirections: Dir = {l, \nr}. The logic Dryad is parameterized by a .nite set of directions Dir and alsoby a .niteset of data-.elds \nDF.Let us .x these sets. Let Bool = {true, false} stand for the set of Boolean values, Int stand for \nthe set of integers and Loc stand for the universe of locations.For anyset A,let S(A)denote the setof \nsubsets of A, and letMS(A)denote the setof all multisets with elementsin A. The Dryad logic allows four \nkinds of recursively de.ned no\u00adtions for a location that is the root of a Dir-tree: recursively de.ned \ninteger functions (Loc . Int), recursively de.ned set\u00adof-keys/integers functions (Loc .S(Int)), recursively \nde.ned multiset-of-keys/integers functions(Loc . MS(Int)), and recur\u00adsivelyde.nedBooleanpredicates(Loc \n. Bool).Letus .xdisjoint sets of countable names for such functions. We will refer to these recursive \nfunctions as recursively de.ned integers, recursively de\u00ad.ned sets/multisets of integers, and recursively \nde.ned predicates, respectively.Typical examples of theseinclude theheight of a tree ortheheight ofblack-nodesinthetree \nrooted at a node(recursively de.nedintegers),the set/multiset ofkeys stored at aparticulardata\u00ad.eld under \nnodes(recursivelyde.ned set/multiset ofintegers), and theproperty that the tree rooted at a node is abinary \nsearch tree or abalanced tree(recursivelyde.nedpredicates). ADryad formula consists ofapair(Def,.),whereDefis \na setof recursivede.nitions and . is aformula.The syntax ofDryad logic isgiveninFigure1,wherethe syntax \noftheformulasisfollowedby the syntaxfor recursivede.nitions.We require that every recursive function/predicate \nused in the formula . has a unique de.nition in Def.The .guredoesnotde.nethesyntaxofthebaseandinductive \nformulasin recursivede.nitions(e.g. ibase, iind, etc.); we give that in the textbelow. Location terms \nare formed using pointer .elds from location variables, and include a special location called nil. Integer \nterms are obtained from integer constants, data-.elds of locations, and from recursively de.ned integers, \nand combined using basic arith\u00admetic operations of addition and subtraction and conditionals(ite standsforif-then-elseterms \nthat evaluate to the second argumentif the .rst argument evaluates to true and evaluate to the third \nargu\u00adment otherwise). Terms that evaluate to a set/multiset of integers are obtained from recursively \nde.ned sets/multisets of integers corresponding to a location term, and are combined using set/multiset \noperations as well as conditional choices. Formulas are obtained by Boolean combinations of Boolean variables, \nrecursively de.ned predicates on a location term, and using various relations between set and multiset \nterms. The relations on sets and multisets include the subset relation as well as the relation = which \nis interpreted as follows:for two sets(or multisets) ofintegers S1 and S2, S1 = S2 holds whenever for \nevery i . S1, j. S2, i = j. The recursively de.ned functions (or predicates) are de.ned using the syntax: \nf*(x) = ite(x = nil, fbase, find), where fbase and find arethemselvesterms(orformulas) that standfor \nwhat f evaluates to when x = nil (the base-case)and when x * nil (the inductive step), respectively.There \nare several restrictions on these terms/formulas:  fbase has no free variables and hence evaluates \nto a .xed value (forintegers,itisa .xedinteger;forsets/multisets of integers, it is a .xed set; for Boolean \npredicates, it evaluates to true or false).  find only has x as a free variable. Furthermore, the location \nterms in it can only be x and x.dir (further dereferences are disallowed).Moreover,integer terms x.dir.f \naredisallowed.  Intuitively, the above conditions demand that when x is nil, the function evaluates \nto a constant of the appropriate type, and when x * nil, it evaluates to a function that is de.ned recursively \nusing properties of the location x, which may include properties of the children of x, and theseproperties \nmay in turninvolve other recursivelyde.nedfunctions. We assume that the inductive de.nitions are not \ncircular. For\u00admally, let Def be a set of de.nitions and consider a recursive def\u00adinition of a function \nf* in Def. De.ne the sequence .0,.1,... as follows.Set.0 = f*(x).Obtain.i+1 by replacing every occurrence \nof g *(x)in .i by gind(x), whereg is any recursively de.ned func\u00adtionin Def.We require that this sequence \neventually stabilizes(i.e. there is a k such that .k = .k+1). Intuitively, we require that the de.nition \nof f*(x)be rewritable into a formula that does not refer to a recursive de.nition of x (by gettingrewritten \nto properties of its descendants). We require that every de.nition in Def have the aboveproperty. Example: \nRed Black Trees Red black trees are semi-balanced binary search trees with nodes colored red and black, \nwith all the leaves coloredblack, satisfying the condition that theleft and right children of a red node \nareblack, and the condition that the number ofblack nodes onpathsfromtheroottoanyleafisthesame.This ensures \nthat thelongestpathfrom root to aleafis at most twicethe shortestpathfrom root to aleaf, making the tree \nroughlybalanced. We have two directions Dir = {l, r}, and two data .elds, key, and color.Wemodel thecolorof \nnodes using anintegerdata-.eld color, which canbe0(black) or1(red).Wede.nefour recursive functions/predicates: \napredicate black * (x)that checks whether the root of the tree under x is colored black (this is de.ned \nas a recursivepredicatefortechnical reasons),theblackheight of atree, bh * (x),the multisetofkeys storedin \natree, keys * (x),and a recursive predicate thatidenti.es red-black trees, rbt * (x). def black * (x) \n= ite(x = nil, true, x.color = 0) def bh * (x) = ite(x = nil, 1, ite(x.color = 0, 1, 0)+ ite(bh * (x.l)= \nbh * (x.r), bh * (x.l), bh * (x.r)) def keys * (x) = ite(x = nil, \u00d8, {x.key}. keys * (x.l). keys * (x.r)) \ndef rbt * (x) = ite (x = nil, true, rbt * (x.l) . rbt * (x.r). keys * (x.l)={x.key}.{x.key}= keys * (x.r). \n(x.color = 1 . (black * (x.l). black * (x.r))). bh * (x.l)= bh * (x.r)) The bh * (t) function de.nition \nsays that the black height of a treeis1for a nil node(nil nodes are assumed tobe black), and, otherwise, \nthe maximum of the black heights of the left and right subtree if the node x is red, and the maximum \nof theblack heights of the left and right subtree plus one, if x is black. The keys * (t) function says \nthat the multiset of keys stored in a tree is \u00d8 for a nil-node, and the union ofthekey storedinthe node, \nand thekeys oftheleft and right subtrees.Finally,the rbt * (t)holdsif:(1)theleft and rightsubtrees arevalid \nredblack trees;(2) thekeys of theleft subtree are nogreater than thekey in the node, and thekeys of the \nright subtree are noless than the keyin the node;(3)if the node is red, both its children are black; \nand(4) theblackheights of the leftand the right subtrees are equal. We can also express,in ourlogic,variousproperties \nof redblack trees,byincluding the abovede.nitions and aformulalike: (rbt * (t) .\u00acblack * (t) . t.key \n= 20) . 10 f keys * (t.r) and using the procedures outlined in this paper, check the validity of the \nabove statement. Semantics The Dryad logic is interpreted on (concrete) heaps. Let us .x a .nite set \nof program variables PV. Concrete heaps are de.ned as follows(f : A . Bdenotes apartialfunctionfrom A \nto B): De.nition2.1. A concrete heap over a set of directions Dir, a set ofdata-.elds DF, and a set ofprogram \nvariables PVis a tuple (N, nil, pf, df, pv) where: Nisa .niteorin.niteset oflocations;  nil . N is \na speciallocation representing the nullpointer;  pf :(N \\{nil})\u00d7 Dir . N is a function de.ning the direction \n.elds;  df :(N \\{nil})\u00d7 DF . Z is afunction de.ning thedata-.elds;  pv : PV . N . Z is a partial function \nmapping program variables to locations or integers, depending on the type of the variable. D  A concrete \nheap consists of a .nite/in.nite set of locations, with apointer-.eldfunction pf that mapslocations tolocationsfor \neach direction dir. Dir, a data-.eld function df mapping locations to integers for each data-.eld DF, \nalong with a unique constant location representing nil that has no data-.elds or pointer-.elds from it. \nMoreover, the function pv is a partial function that maps program variables tolocations andintegers. \nADryad formula with free variables F is interpreted by inter\u00adpretingtheprogram variablesinF according \nto thefunction pvand the other variablesbeinggiven aninterpretation(hence,for validity, these other variables \nare universally quanti.ed, and for satis.abil\u00adity, they are existentiallyquanti.ed). Each term evaluates \nto either a normal value of the correspond\u00adingtype, ortoundef.Alocationtermis evaluatedbydereferencing \npointers in the heap. If a dereference is unde.ned, the term evalu\u00adates to undef. The set of locations \nthat are roots of Dir-trees are special in that they are the only ones over which recursive de.\u00adnitions \nare properly de.ned. A term of the form i*(lt), si*(lt) or msi*(lt) will evaluate to undef if lt evaluates \nto undef or is not a root of a tree in the heap; otherwise it will be evaluated induc\u00adtively using its \nrecursive de.nition. Other aspects of the logic are interpretedwiththeusual semanticsof.rst-orderlogic,unlessthey \ncontain some subterm evaluating to undef,in which case they also evaluate to undef. Each Dryad formula \nevaluates to either true or false. To evaluate aformula ., we .rst convert . toits negation normalform \n(NNF), and evaluate each atomic formula of the form p *(lt).rst. If lt is not unde.ned, p *(lt) will \nbe evaluated inductively using the recursive de.nition of p *; if lt evaluates to undef, p *(lt)will \nevaluate to false if p *(lt)appears positively, and will evaluate to true otherwise. Intuitively, unde.ned \nrecursive predicates cannot help in making the formula true over a model. Similarly, atomic formulas \ninvolving terms that evaluate to undef are set to false or true depending on whether the atomic formula \noccurs within an even or odd number of negations, respectively. All other relations between integers, \nsets, and multisets are interpreted in the natural way, and we skipde.ning their semantics.  WeassumethattheDryad \nformulas alwaysinclude a recursively de.nedpredicate tree thatisde.ned as: def tree *(x) = (x = nil, \ntrue, true) Notethatsince recursivelyde.nedpredicates canholdonly ontrees and since the above formula \nvacuously holds on any tree, tree *(x) holdsi. x is a root of a Dir-tree. Programs andbasicblocks We \nconsiderimperativeprograms manipulatingheapstructures and the data contained in the heap. In this paper, \nwe assume that pro\u00adgramsdo notcontain while loops andall recursionis captured using recursive function \ncalls. Consequently, proof annotations only in\u00advolvepre-andpost-conditions of functions, and there are \nno loop\u00adinvariants. The imperative programs we analyze will consist of integer operations, heap operations, \nconditionals and recursion. In order to verify programs with appropriate proof annotations, we need to \nverifylinearblocks of code, called basicblocks, whichdo nothave conditionals (conditionals are replaced \nwith assume statements). Basic blocks always start from the beginning of a function and either end at \nan assertionin theprogram(checking anintermediate assertion), or end at a function call to check whether \nthe pre\u00adcondition to calling the function holds, or ends at the end of the programinordertocheck whetherthepost-conditionholds.Basic \nblocks caninvolve recursive and non-recursivefunction calls. We de.ne basic blocks using the following \ngrammar, parame\u00adterizedby a set ofdirections Dir and a set ofdata-.elds DF: bb :- bb ' ; | bb ' ; return \nu; | bb ' ; return j; bb ' :- bb ' ;bb '| u := v | u := nil | u := v.dir | u.dir := v | j:= u. f | u. \nf := j | u := new | j:= aexpr | assume (bexpr) | u := f(v, z1,..., zn) | j:= g(v, z1,..., zn) aexpr :- \nj | aexpr + aexpr | aexpr - aexpr bexpr :- u = v | u = nil | aexpr = aexpr |\u00acbexpr | bexpr. bexpr Since \nwe deal with tree data-structure manipulating programs, which often involve functions that take as input \na tree and return a tree, we make certain crucial assumptions. One crucial restriction we assumeforthetechnical \nexpositionisthat allfunctionstakein at most one locationparameter asinput(the resthave tobeintegers). \nBasic blocks hence have function calls of the form f(v, z1,... zn), where v is the only location parameter. \nThis restriction greatly simpli.es the proofs as it is much easier to track one tree. We can relax this \nassumption, but when several trees are passed as parameters, our decision procedures will implicitly \nassume a pre\u00adcondition that the trees are alldisjoint.Thisis crucial; ourdecision procedures cannot track \ntrees that collide ; they track only equal trees and disjoint trees. This turns out to be a natural property \nof mostdata-structure manipulatingprograms. Pre-andPost-conditions offunctions We place stringent restrictions \non annotations pre-and post\u00adfunctions that we allow in our framework, and these are important for our \ntechnique and is the price we pay for automation. Recall that we allow only twokinds offunctions, one \nreturning alocation f(v, z1,..., zn) and one returning an integer g(v, z1,..., zn)(v is a location parameter, \nz1,..., zn are integer parameters). We require that v is the root of a Dir-tree at the point when the \nfunction is called, and thisis animplicitpre-condition of thefunction called. Each function is annotated \nwith its pre-and post-conditions using annotating formulas. Annotating terms and formulas are Dryad terms \nandformulas thatdo not refer to any child or anydata .eld,do not allow any equalitybetweenlocations anddo \nnot allow ite-expressions. We denote the pre-condition as a pre-annotating formula .(v, z1,..., zn). \nThe post-condition annotation is more complex, as it can talk about properties of the heap at the pre-state \nas well as the post\u00adstate. We allow combining terms and formulas obtained from the pre-heap and the post-heap \nto express the post-condition. Terms andformulas over thepost-heap are obtained usingDryad annotat\u00ading \nterms and formulas that are allowed to refer to a variable old v which points to the location v pointed \nto in the pre-heap. These terms and formulas can also refer to the variable ret loc or ret int to refer \nto thelocation orintegerbeing returned.Terms andformu\u00adlas over the pre-heap are obtained using Dryad \nannotating terms and formulas referring to old v and old zi s, except that all recur\u00adsive de.nitions \nare renamed to have the pre.x old . Then a post\u00adannotating formula combines terms and formulas expressed \nover thepre-heap and thepost-heap(using the standard operations). For a function f(v, z1,... zn)that \nreturns a location, we assume that the returned location always has a Dir-tree underit(andthis is implicitly \nassumed to be part of the post-condition). The post\u00adconditionfor f is either of theform havoc(old v). \n.(old v, old z1,..., old zn, ret loc) or of theform old v#ret loc. .(old v, old z1,..., old zn, ret loc) \nwhere . isapost-annotatingformula.Inthe .rstkind,havoc(old v) means that the function guarantees nothing \nabout the location pointed to in the pre-state by the input parameter v (and nothing about the locations \naccessible from that location) and hence the caller of f cannot assume anything about the location it \npassed to f after the call returns. In that case, we restrict . from referring to r *(oldv), wherer * \nis a recursive predicate/function on the post\u00adheap. In the latter kind old v#ret loc means that f, at \nthe point of return, assures that the location passed as parameter v now points to a Dir-tree and this \ntreeisdisjointfrom the tree rooted at ret loc. In either case,theformula. can relate complexproperties \nofthe returnedlocation and theinputparameter,including recursivede.\u00adnitions onthe oldparameter andthe \nnew ones.For example, apost\u00adcondition of theform havoc(old v). keys* (old v)= keys*(ret loc) saysthatthekeys \nunderthe returnedlocation arepreciselythe same as thekeys under thelocationpassed to thefunction. For \nafunctiongreturning aninteger,thepost-conditionis ofthe form tree(old v). .(old v, old z1,..., old zn, \nret int) or of theform havoc(old v). .(old v, old z1,..., old zn, ret int) Theformer says thatthelocationpassedasinput \ncontinues topoint to a tree, while thelatter says that noproperty is assured about the locationpassed \nasinput(same restriction on . applies). The above restriction that the input tree and the returned tree \neither point to completely disjoint trees or that the input pointer (and nodes accessible from it) are \nentirely havoc-ed and the re\u00adturned node is some tree are the only separation and aliasingprop\u00adertiesthatthepost-condition \ncan assert.Ourlogical mechanismis incapable, for example, of saying the the returned node is a reach\u00adable \nnode from the location passed to the function. We have care\u00adfullychosen such restrictionsin orderto simplifytrackingtree-ness \nand separation in the footprint. In practice, most data-structure al\u00adgorithmsfallintothese categories(for \nexample, aninsert routine would havoc the input tree and return a new tree whose keys are related to \nthe keys of the input tree, while a tree-copying program will return a treedisjointfrom theinput tree). \n 3. DescribingtheVeri.cationConditionin Dryad We nowpresentthe maintechnicalcontribution ofthispaper:given \na set of recursive de.nitions, and a Hoare-triple (.pre, bb,.post), where bb is a basic block, we show \nhow to systematically de.ne the veri.cation condition corresponding to it. Note that since we do nothave \nwhile-loops,basicblocks always startat thebeginning of afunction andgo eithertillthe end of thefunction(spanning \ncalls to other functions) or go up to a function call (in order to check if the pre-condition for that \ncall holds). In the former case, thepost-conditionis apost-condition annotation.In thelatter case, we \nneed anotherform: tree(y). .(\u00afx) where \u00afx isasubsetofprogramvariables.Thepre-condition of the called \nfunction implicitly assumes that the input location is a tree (which is expressed using tree(y) above), \nand the pre-condition itselfis adapted(after substitutingformalparameters with actual termspassed to \nthefunction) and written as theformula .. Thisveri.cationconditionisexpressed asacombinationof(a) quanti.er-free \nformulas that de.ne properties of the footprint the basic block uncovers on the heap, combined with (b) \nrecursive formulas expressed only on thefrontier of thefootprint. This veri.cation condition is formed \nby unrolling recursive de.nitions appropriatelyasthebasicblockincreasesitsfootprint so that recursiveproperties \nare translated toproperties of thefrontier. This allows us to write the (strongest) post-condition of \n.pre on precisely the same nodes as .post refers to, which then allows us to apply formula abstractions \nto prove the veri.cation condition. Also, recursive calls to functions that process the data-structure \nrecursively are naturally called on the frontier of the footprint, which allows us to summarize the call \nto the function on the frontier. Wede.netheveri.cationconditionusing twosteps.Inthe .rst step, we inductively \nde.ne a footprint structure, composed of a symbolic heap and aDryad formula, which captures the state \nof the program that results when the basic block executes from a con.guration satisfying thepre-condition. \nWe thenincorporate the post-condition andderive the veri.cation condition. Asymbolicheapisde.ned asfollows: \nDe.nition3.1. A symbolicheap over asetofdirectionsDir,a set ofdata-.elds DF, and a set ofprogram variables \nPVis a tuple (C, S, I, cnil, pf, df, pv) where: C is a .nite set of concrete nodes;  S is a .nite set \nof symbolic tree nodes withC n S = \u00d8;  I is a set ofinteger variables;  cnil . C is a special concrete \nnode representing nil;  pf :(C \\{cnil})\u00d7 Dir . C . S is a partial function mapping everypair of a concrete \nnode and adirection to nodes(concrete or symbolic);  df :(C\\{cnil})\u00d7 DF . I is apartialfunction mapping \nconcrete nodes and data-.eldspairs tointeger variables;  pv : PV . C . S . I is a partial function mapping \nprogram variablesto nodes orinteger variables(location variables are mapped toC . S and integer variables \nto I). D  Intuitively, a symbolicheap(C, S, I, cnil, pf, df, pv)has two .nite sets of nodes: concrete \nnodes C and symbolic tree nodes S, with the understanding that each s . S stands for a node that may \nhave an arbitrary Dir-tree under it, and furthermore the separation constraint thatfor any two symbolic \ntree nodes s, s '. S, the trees under it would not intersect with each other, nor with the nodes in C. \nThe tree under a symbolic node is not represented in the symbolic heap at all. One of the concrete nodes \n(cnil) represents the nil location. The function pf captures thepointer-.eld dir in theheap thatis withinthefootprint, \nand maps the set of concrete nodes to concrete and symbolic nodes. The pointer .elds of symbolic nodes \nare not modeled, as they are part of the tree below the node that is not represented in the footprint. \nThe functions df and pv capture the data-.elds (mapping to integer variables) and program variables restricted \nto the nodesin the symbolicheap. Asymbolicheaphence representsa(typicallyin.nite) setof concreteheaps, \nnamely thosein whichit canbe embedded.Wede\u00ad.ne thisformally using the notion of correspondence that captures \nwhen a concreteheapis representedby a symbolicheap. De.nition3.2. LetSH = (C, S, I, cnil, pf, df, pv)be \na symbolicheap ' and let CH = (N, nil, pf ' , df ' , pv )be a concrete heap. Then CH is said to correspond \nto SH if there are two function h : C . S . N such that thefollowing conditions hold: h(cnil)= nil; \n'' '  for any n, n . C,if n * n ,thenh(n)* h(n );  for anytwo nodes n . C\\{cnil},n '. C.S,andfor anydir \n. Dir,  ' ifpf(n, dir)= n ' , thenpf ' (h(n), dir))= h(n ); for any s . S,h(s)is the root of a Dir-tree \nin CH, and there is no concrete node c . C \\{cnil} such that h(c)belongs to this tree;  for any s, s \n'. S, s * s ' , the Dir-trees rooted at h(s)and h(s ' ) (inCH)aredisjoint exceptfor the nil node;  for \nany location variable v . PV, if pv(v) is de.ned, then pv ' (v)= h(pv(v)); D  Intuitively, h abovede.nes \narestrictedkind ofhomomorphism between the nodes of the symbolic heap SH and a portion of the concrete \nheap CH. Distinct concrete non-nil nodes are required to map todistinctlocations in the concrete heap. \nSymbolic nodes are requiredto maptotreesthat aredisjoint(savethe nil location);they can maptothe nil \nlocation as well.Thetrees rootedatlocations cor\u00adresponding to symbolic nodes must be disjoint from the \nlocations corresponding to concrete nodes.Note that thereis no requirement on the integer variables I \nand the map pv ' on integer variables and the maps df and df ' .Note also thatfor a concrete node in \nthe sym\u00adbolic heap n, the .elds de.ned from n in the symbolic heap must occur in the concrete heap as \nwell from the corresponding loca\u00adtion h(n);however, the .elds not de.ned for n may or may not be de.ned \non h(n). A footprint is apair(SH;.)where SH is a symbolic heap and . is aDryad formula. The semantics \nof such a footprint is that it represents all concreteheaps thatboth correspondto SHand satisfy .. Tree-ness \nof nodesin symbolicheaps Thekey property of a symbolic heap is that we can determine that certain nodes \nhave Dir-trees rooted under them (i.e. in any con\u00adcrete heap corresponding to the symbolic heap, the \ncorresponding locations willhave a Dir-tree under them). For a symbolic heap SH = (C, S, I, cnil, pf, \ndf, pv), let the set of graph nodes of SH be the smallest set of nodes V . C . S such that: cnil . V \nand S . V  For any node n . C,iffor every dir . Dir, pf(n, dir)isde.ned andbelongs to V, then n . V. \n Now de.ne Graph(SH)to be the directedgraph(V, E), whereV is as above, and E is the set of edges(u, \nv)such that pf(u, dir)= v for some dir . Dir.Note that, by de.nition, there are no edges out of u ifu \n. S,assymbolicnodesdonothaveoutgoing .elds.  We say that a node u in V is the root of a tree in Graph(SH) \nif the set of all nodes reachable from u forms atree(inthe usual graph-theoretic sense). The following \nclaim follows and is the crux of using the sym\u00adbolicheap todetermine tree-ness of nodes: Lemma 3.3. Let \nSH be a symbolic heap and let CH be a corre\u00adsponding concrete heap, de.ned by a function h. If a node \nu is the root of a treeinGraph(SH), thenh(u)also subtends a treeinCH. Aproofgistis asfollows.First,notethatsymbolic \nnodes andthe node cnil are always roots of trees in Graph(SH)and the locations inthe concreteheap corresponding \ntothem subtend trees(infact, disjoint trees save the nil location). Turning to concrete nodes, we need \nto argue thatif c is a concrete nodeinGraph(SH), thenh(c)is the rootof a Dir-treein CH.Thisfollowsbyinduction \nontheheight of the tree under c in Graph(SH), since eachof the Dir children of c in Graph(SH) must either \nbe the cnil node or a summary node or a concrete node that is a the root of a tree of less height. The \ncorresponding locations in CH, by induction hypothesis or by the above observations, have Dir-trees suspended \nfrom them. In fact, by the de.nition of correspondence, these trees are all disjoint except for the nil \nlocation(sincetrees corresponding to summary nodes are all disjoint and disjoint from locations corresponding \nto concrete nodes, and since concrete nodes in the symbolic heap denote). The location corresponding \nto a concrete node in Graph(SH) that does not have all Dir-.elds de.ned in SH may or may not have a Dir-tree \nsubtended from it; this is because the notion of correspondence allows the corresponding location to \nhave more .elds de.ned. In the sequel, when we use symbolic heaps for tracking footprints,such concrete \nnodes withpartiallyde.ned Dir .elds will occur only when processing function calls (where all information \nabout a node may notbeknown). Initialfootprint Let the pre-condition be .pre(u, j1,..., jm), where u \nis the only location program variable, there is a Dir-tree rooted at u, and j1,..., jm areintegerprogram \nvariables. Then wede.ne theinitial symbolicheap: (C0, S0, I0, cnil, pf0, df0, pv0) where C0 = {cnil}, \nS0 = {n0}, I = {i1,... im}, pf0 and df0 are empty functions (i.e. functions with an empty domain), and \npv0 maps u to n0 and j1, ..., jm to i1, ..., im, respectively. The initial formula .0 is obtained from \n.pre(u, j1,..., jm) by replacing u by n0 and j1, ..., jm by i1, ..., im, and by adding the conjunct p \n*(cnil) . pbase or f*(cnil) = fbase for all recursive predicates and functions. Note thattheformulaisde.ned \nover the variables S0. I0.Intuitively, we start at the beginning of the function with a single symbolic \nnode that stands for the input parameter, which is a tree, and a concrete node that stands for nil. All \ninteger parameters are assigned to distinct variablesin I. Expanding thefootprint Abasic operation on \napair,(SH;.), consistingof a symbolicheap, and aformulais expansion.Let SH be (C, S, I, cnil, pf, df, \npv) () and n . C. S be a node.Wede.neexpand(SH;.), n= (SH ' ;. ' ), where SH ' is the tuple (C ' , S \n' , I ' , cnil, pf ' , df ' , pv ' ) asfollows:if n . C (the nodeis alreadyexpanded), thendo nothing \nby setting(SH ' ;. ' )to(SH;.);otherwise: C ' = C .{n}, where n is the nodebeing expanded S ' = S .{ndir \n| dir . Dir}\\{n}, where each ndir is a fresh new nodedi.erentfrom the nodesin C . S  I ' = I .{if | \nf . DF}, where each if is a fresh new integer variable  pf '|C\\{cnil}\u00d7Dir = pf, and pf ' (n, dir)= ndir \nfor alldir . Dir  df ' df, and df ' (n, f)= if for all f . DF  |C\\{cnil}\u00d7DF = pv ' = pv; Theformula \n. ' is obtainedfrom theformula . asfollows: . ' = .[p\u00afn, f\u00af n/p\u00af*(n), f\u00af*(n)] () () .pn . p ind(n).fn \n= f ind(n)pf * * () ' . n * cnil .n * ndir ' n .C '\\{cnil},dir.Dir ( ) .ndir = s . ndir = cnildir.Dir,s.S \n( ) .ndir1 = ndir2 . ndir1 = cnildir1,dir2.Dir,dir1*dir2 where \u00afpn arefreshBoolean variables, f\u00af n arefreshterm(integer, \nset, def ...) variables, p *(x) = ite(x = nil, pbase, pind(x))ranges over all def the recursive predicates, \nand f*(x) = ite(x = nil, fbase, find(x)) rangesoveralltherecursivefunctions.Intuitively,Thevariables \n\u00afpn and f\u00af n capture the values of the predicates and functions for the node n in the current symbolic \nheap. This is possible because the values ofthe recursivepredicates andfunctionsfor concrete non-nil \nnodes aredeterminedby the values of thefunctions andpredicates forsymbolic nodes andthenil node.Theformula \npind(n)isobtained from pind(n), bysubstituting every location term of the form n.dir with ndir for every \ndir . Dir, and substituting everyinteger term of theform n. f with if for every f . DF.The term f ind(n)is \nobtained by the same substitutions. Evolving thefootprint onbasicblocks Given a symbolic heap SH along \nwith a formula ., and a basic block bb. We compute the symbolic execution of bb using the () transformation \nfunction st(SH;.), bb= (SH ' ;. ' ). The transfor\u00admationfunction st is computed transitively;i.e.,if \nbb is oftheform (stmt;bb ' ) where stmt is an atomic statement and bb ' is a basic block, then ()(()) \nst(SH;.), bb= stst(SH;.), stmt, bb ' Therefore, it is enough to de.ne the transformation for the vari\u00adous \natomic statements. Given SH = (C, S, I, cnil, pf, df, pv), . and () an atomic statement stmt, we de.ne \nst(SH;.), stmtas follows by cases of stmt. Unless some assumptions fail (in which case () the transformation \nis unde.ned), we describe st(SH;.), stmtas (SH ' ;. ' ). Asper our convention,function updates aredenotedintheform \nof[arg . new val]. For example,pv[u . n]denotes thefunction pvexceptthat pv(u)mapsto n.Formula substitutions \naredenotedin theform of[new/old]. For example,.[df ' /df]denotes the formula obtainedfrom theformula \n. by substituting every occurrence of df with df ' . Thefollowingde.neshowthefootprint evolves acrossallpos\u00adsible \nstatements except function calls: (a) stmt : u := v Ifpv(v)is unde.ned, thetransformationis unde.ned;otherwise \nSH ' = (C, S, I, cnil, pf, df, pv[u . pv(v)]) . ' = .  (b) stmt : u := nil SH ' = (C, S, I, cnil, pf, \ndf, pv[u . cnil]) . ' = . (c) stmt : u := v.dir If pv(v) is unde.ned, or pv(v) . C and pf(pv(v), dir)is \nunde\u00ad.ned,thetransformationis unde.ned.Otherwise we expandthe symbolicheap: '' , I '' '' () ((C '' , \nS , cnil, pf '' , df '' , pv );. '' )= expand(SH;.), pv(v) Now pv '' (v)mustbein C '' \\{cnil}, and we \nset (C '' '' , I '' '' SH ' = , S , cnil, pf '' , df '' , pv [u . pf '' (pv '' (v), dir)]) . ' . '' \n= (d) stmt : j:= v. f Ifpv(v)is unde.ned, orpv(v). C and pf(pv(v), f)is unde.ned, the transformationis \nunde.ned.Otherwise we expand the sym\u00adbolicheap: '' , I '' '' () ((C '' , S , cnil, pf '' , df '' , pv \n);. '' )= expand(SH;.), pv(v) Now pv '' (v)mustbein C '' \\{cnil}, and we set (C '' '' , I '' , df '' \n'' SH ' = , S .{i}, cnil, pf '' , pv [j. i]) . '' df '' '' . '= . i = (pv (v), f) (e) stmt : u.dir := \nv Ifpv(u)or pv(v)is unde.ned, orpv(u)= cnil,thetransformation is unde.ned. Otherwise we expand the symbolicheap: \n'' , I '' '' () ((C '' , S , cnil, pf '' , df '' , pv );. '' )= expand(SH;.), pv(u) Now pv '' (u)mustbein \nC '' \\{cnil}, and we set (C '' '' , I '' '' SH ' = , S , cnil, pf '' [(pv '' (u), dir). pv '' (v)], df \n'' , pv ) . ' . '' = (f) stmt : u. f := j Ifpv(u)or pv(j)is unde.ned, orpv(u)= cnil,thetransformation \nis unde.ned. Otherwise we expand the symbolicheap: '' , I '' '' () ((C '' , S , cnil, pf '' , df '' , \npv );. '' )= expand(SH;.), pv(u) Now pv '' (u)mustbein C '' \\{cnil}, and we set (C '' '' , I '' '' '' \nSH ' = , S .{i}, cnil, pf '' , df '' [(pv (u), f). i], pv ) . '' '' . '= . i = pv (j) (g) stmt : u := \nnew We assume that, for the new location, every pointer initially points tonil and everydata .eldinitially \nevaluatesto0. SH ' = (C .{n}, S, I .{if | f . DF}, cnil, pf ' , df ' , pv[u . n]) ()() . '' = . .= 0.' \nn * n f.DF if n .C.S where pf ' and df ' arede.ned asfollows: pf '|C\\{cnil}\u00d7Dir = pf, and pf ' (n, dir)= \ncnil for alldir . Dir  df ' df, and df ' (n, f)= if for all f . DF  |C\\{cnil}\u00d7DF = (h) stmt : j:= aexpr(k\u00af) \nIf pv is unde.ned on any variable in k\u00af, then the transformation is unde.ned; otherwise SH ' = (C, S, \nI .{i}, cnil, pf, df, pv[j. i]) . '= . . i = aexpr[pv(k\u00af)/k\u00af] \u00af (i) stmt : assume bexpr(\u00afv, j) If pv \nis unde.ned on any variable in pv(\u00afv)or in pv(\u00afj), then the transformationis unde.ned; otherwise SH ' \n= SH . '= . . bexpr[pv(\u00afv), pv(\u00afj)/v\u00af, \u00afj] (j) stmt : return u Ifpv(u)is unde.ned,thetransformationis \nunde.ned;otherwise SH ' = (C, S, I, cnil, pf, df, pv[ret loc . pv(u)]) . ' = . (k) stmt : return j Ifpv(j)is \nunde.ned, thetransformationis unde.ned;otherwise SH ' = (C, S, I .{i}, cnil, pf, df, pv[ret int . i]) \n. '= . . i = pv(j) We can show thatfor anyatomic statementthatis not afunction call, the above computes \nthe strongestpost of thefootprint: Theorem 3.4. Let (SH;.) be a footprint and let stmt be any statement \nthat is not a function call. Let (SH ' ;. ' )be the footprint obtainedfrom (SH;.)across the statement \nstmt, asde.ned above. Let C denote the set of all concrete heaps that correspond to SH and satisfy ., \nand let C' be the set of all heaps that result from executing stmt from any concreteheapin C.Then C' \nis theprecise set of concrete heaps that correspond toSH ' and satisfy . ' . D Handlingfunction calls \n\u00aff(w, k) be the function prototype and .post its post-condition. If Let us consider the statement u := \nf(v, j)onthepair(SH;.). Let \u00afpv(v) or any element of pv(\u00afj) is unde.ned, the transformation is unde.ned. \nWe also assume that the checking of the pre-condition for f is successful; inparticular, pv(v)and all \nthe nodes reachable fromitare roots of trees. Recall that certain nodes of the symbolic heap can be deter\u00admined \nto point to trees (as discussed earlier). For any node n . C . S, let us de.ne reach nodes(SH, n)to be \nthe subset of C . S thatis reachablefrom n in Graph(SH).Let NC = (reach nodes(SH, pv(v))n C)\\{cnil} NS \n= reach nodes(SH, pv(v))n S Intuitively, NC and NS are the concrete non-nil and the symbolic nodes a.ectedby \nthe call.Let nret loc be the node returnedby f.Let N ' be the set of nodes generated by the call: N ' \n= {nret loc, pv(v)} if .post does not havoc old w, and N ' = {nret loc} otherwise. The ' resulting symbolicheapis(C \n' , S , I ' , cnil, pf ' , df ' , pv ' ), where: C ' = C \\ NC  S ' = (S \\ NS). N '  I ' = I  pf '|D \n= pf |D, and pf ' (n, dir) is unde.ned for all the pairs (n, dir). (C '\\{nil}\u00d7 Dir)\\ D, where D . (C \n'\\{nil})\u00d7 Dir is  ' '' the set ofpairs(n , dir ' )such that pf(n , dir ' ). C '. S df ' = df |C ' \\{cnil}\u00d7DF \npv ' = pv[u . nret loc] Intuitively, the concrete and symbolic nodes a.ected by the call are removed \nfrom the footprint (and get quanti.ed in the Dryad formula), with the possible exception of pv(v) (if \n.post does not havoc old w, pv(v)becomes a symbolic node). The returned node is added to S. The pf and \ndf functions are restricted to the new set of concretenodes, and all thedirectionsandprogramvariables \npointing toquanti.ed nodesbecome unde.ned. Let .post be the post-annotating formula in .post, we de.ne \nthe followingformulas .1 = .[pre call rn /r *(n)] () . pre call rn = r ind(n) * n.NC,r .2 = .post[pv(v)/old \nw][pv(j)/old k ][nret loc/ret loc] [pre call r /old r *(pv(v))] pv(v)  where n ranges over NC . NS, \nr * ranges over all the recursive predicates and functions; pre call rn are fresh logical variables; \nr ind(n)is obtainedfromrind(n)byreplacing n.dir with pf(n, dir)and n. f with df(n, f)for all dir . Dir, \nf . DF, and then by replacing r *(n ' ) with pre call rn ' for all n '. NC . NS; r *(n) is the vector \nof all the recursive predicates and functions on all n . NC . NS . Intuitively, in .1 we add logical \nvariables that capture the values of the recursive predicates and functions for the nodes a.ected by \nthe call.In .2 we replace theprogram variablesinthe .post withthe actual nodes andinteger variables, \nand we replacethe old version of the predicates and functions on old w with the variables capturing those \nvalues.Then the resultingformulais . ' = .1 . .2 \u00af The case of j:= g(v, k)is similar. Example: Search \nin AVL trees To illustrate the above procedure expands the symbolic heap and generates formulas, we present \nit working on the search routine of an AVL tree. Figure 2 shows the find routine, which searches in an \nAVL tree t and returns true if akey v is found. The pre-condition .pre, post-condition .post, and user-de.ned \nrecursive sets and predicates are also shown in Figure 2. In Figure 3, we present graphically how the \nsymbolic heap evolves for a particular execution path of the routine. At each point of the basic block, \nwe also formally show the updated symbolicheap SH and the corresponding formula .. Incorporating thepost-condition \nFinally, after capturing the program state after execution bb by a pair (SH;.), we incorporate the post-condition \n.post, which con\u00adtains the annotating formula ., and generate a veri.cation con\u00addition. We compute the \nset of tree-nodes in the footprint SH and computetherecursively de.nedpredicates andfunctionsonthem. \nLet SH N .vc = = = (C, S, I, cnil, pf, df, pv) (tree nodes(SH)n C)\\ {cnil} . . * (vc rn = rind(n)) n.N,r \nwhere vc rn isfreshlogicalvariables; and rind(n)are obtainedfrom rind(n)byreplacing n.dir with pf(n, \ndir)and n. f with df(n, f)for all dir . Dir, f . DF, and then by replacing r *(n ' )with vc rn ' for \nall n '. N. Intuitively, N are the non-nil concrete nodes that are tree roots, while .vc introduces variables \nthat capture the values of the recursivepredicates andfunctions on non-nil concrete nodes. Let u and \nk\u00afbe the originalprogram variables of bb.Let v and \u00afj be the new program variables appearing in . (onlywhen \nbb ends before a function call). Let N ' be the set of nodes that should be the roots of disjoint trees, \nas required by .post: N ' = {pv(v)} if .post mentions tree(v); N ' = {n0, pv(ret loc)} if .post mentions \nold u#ret loc; N ' = {n0} if .post mentions tree(old u); if .post mentions havoc(old u), N ' = {pv(ret \nloc)} or N ' = \u00d8 depending on the basic block is within a function returning a location or an integer.Let \n.vc = .[pv(v)/v][pv(\u00afj)/ \u00afj][pv(ret loc)/ret loc][pv(ret int)/ret int] [vc rpv(v)/r *(pv(v))][vc rpv(ret \nloc)/r *(pv(ret loc))] [n0/old u][\u00afi/old k][oldest rn0/old r *(n0)][vc rn0/r *(n0)] where r * ranges \nover all the recursive predicates and functions, n0 and \u00afi are the initial node and integer variables, \nand oldest rn0 is the variable capturing the value of r *(n0) in the pre-heap. The substitution of r \n*(n)with vc rn is onlyperformedfor nodesin N. We should verify that: (1) N '. N. S .{cnil},thatis,the \nnodes requiredby .post tobe tree roots areindeed tree roots; (2) reach nodes(SH, n1) n reach nodes(SH, \nn2) .{cnil}, for all n1, n2 . N ' , such that n1 * n2; (3) (SH;.vc) . .vc, that is, the constraints \non the current states imply the constraints requiredby ..  The .rst two are readily checkable. The last \none asserts that any concrete heap that corresponds to the symbolic heap SH and satis.es .vc must also \nsatisfy .vc. Checking the validity of this claimisnon-trivial(undecidable) and weexamineproceduresthat \ncan soundly establish thisin the next section. 4. ProvingtheVeri.cationCondition In this section we consider \nthe problem of checking the veri.ca\u00adtion condition (SH;.vc) . .vc generated in Section 3. We .rst show \na small syntactic fragment of Dryad that is entirely decid\u00adable(withoutformula abstraction) by a reductiontothepowerful \ndecidablelogicStranddec.We then turn to the abstraction schemes for unrestricted veri.cation conditions, \nand show how to soundly reduce veri.cation conditions to a validity problem of quanti.er\u00adfree theories \nof sets/multisets ofintegers, which isdecidable using state-of-the-artSMT solvers. 4.1 ADecidableFragment \nof Dryad Given veri.cation conditions oftheform(SH;.vc) . .vc, where SH is a symbolic heap and .vc and \n.vc are Dryad formulas, the validityproblemisingeneral undecidable.However,decisionpro\u00adcedures for fragments \nare desirable, as when a program does not satisfyitsspeci.cation,thedecisionprocedure would disprove \nthe program, and con.rm it with a counterexample, which helps pro\u00adgrammers debug the code. In this subsection, \nwe identify a small decidablefragment, thatis veryrestricted andpractically usefulfor only a small class \nof speci.cations, called Dryaddec. We omit the proofofdecidability,ininterest of space. Let us .x a set \nof directions Dir and a set of data-.elds DF. Dryaddec does not only restrict the syntax of Dryad, but \nalso re\u00adstricts the recursive integers/sets/multisets/predicates that can be de.ned. We .rst describe \nthe ways allowed in Dryaddec to de.ne recursions asfollows: Recursiveintegers aredisallowed;  Foreachdata \n.eld f . DF, a recursive set ofintegers fs * canbe de.ned as  ( ) fs * (x)= itex = nil, \u00d8, {x. f}. fs \n* (x.dir) dir.Dir Foreachdata .eld f . DF, a recursive multiset ofintegers fms * canbede.ned as ( ) fms \n* (x)= itex = nil, \u00d8m, {x. f}m . fms * (x.dir)dir.Dir Recursivepredicates canbede.nedin theform of () \np * (x)= itex = nil, true,.p(x). p * (x.dir) dir.Dir where .p(x)is a local formula with x as the only \nfree variable. Local formulas are Dryad formulas disallowing set/multiset mi\u00adnus, ite, subset, equality \nbetween locations, positive appearance ofbelongs-to and and negativeappearance of = between sets/mul\u00adtisets.Intuitively, \np *(x)is evaluatedtotrueif and onlyif every node y in the subtree of x satis.es thelocalformula .p(y), \nwhichcanbe determinedby simply accessing thedata .eldsof y and evaluating the recursive sets/multisetsfor \nthe children of y. The exclusion ofrecursiveintegersprevents usfrom expressing heights/cardinalities \n(which are required in many speci.cations).  There are however interesting algorithms on inductive data \nstruc\u00adtures,likebinary heaps,binary search trees and treaps, whose ver\u00adi.cation canbe expressedinDryaddec. \nOn the syntax ofDryad,Dryaddec does not allow to refer to any child oranydata .eld,foranylocation,i.e.,termsoftheform \nlt.dir or lt. f are disallowed. Di.erence operations and subset relations between sets/multisets are \nalsodisallowed. Overall, Dryaddec is the most powerful fragment of Dryad that we could .nd that embeds \ninto a known decidable logic, like Stranddec.However,itis notpowerful enoughfortheheap veri.ca\u00adtionquestions \nthat we would like to solve. This motivates formula abstractions that wedescribein the next section. \n 4.2 Proving Dryad usingformula abstractions In typical data-structure algorithms, a recursive algorithm \nmanip\u00adulates the data-structure for a few bounded number of steps, and then recursively callsitselftoprocess \nthe rest oftheinductivedata\u00adstructure,and .nally.xesthestructurebeforereturning. As arguedinSection1,in \nrecursiveproofs ofsuch algorithms,it is very often su.cient to assume that the recursivelyde.nedpred\u00adicates, \nintegers, sets of keys, etc. are arbitrary, or uninterpreted, .pre int find(node t, int v) .post { if \n(t = NULL) return false; avl * (x) tv := t.value; if (v = tv) return true; avlind(x) else if (v < tv) \n{ w := t.left; r := find(w, v); } keys * (x) else { w := t.right; r := find(w, v); } keysind(x) return \nr; h * (x) } hind(x) = avl * (t) = avl * (t). keys * (t)= keys * (old_t). h * (t)= h * (old_t). ret \nloc * 0 . v . keys * (t) def = ite(x = nil, true, avlind(x)) def = avl * (x.left). avl * (x.right). keys \n* (x.left)={v.value}.{v.value}= keys * (x.right). x.hight = h *(x).-1 = h *(x.left)- h *(x.right). h \n*(x.left)- h *(x.right)= 1 def = ite(x = nil, \u00d8, keysind(x)) def = keys * (x.left).{x.value}. keys * \n(x.right) def = ite(x = nil, 0, hind(x)) def = 1+ max(h * (x.left), h * (x.right)) Figure2. AVL.nd routine(left);pre/post \nconditions and recursivede.nition of avl * , keys * , and h * (right). Graphical representation of SH \nFormal representation of SH Formula . \u00ae C = {cnil}, S = {n0}, I = {i1} dir = \u00d8, df = \u00d8 pv = {t . n0, \nv . i1} avl * (n0) assume (t * nil) \u00ae C = {cnil}, S = {n0}, I = {i1} dir = \u00d8, df = \u00d8 pv = {t . n0, \nv . i1} avl * (n0). n0 * cnil tv := t.value; 5)) t) C = {cnil, n0}, S = {n1, n2}, I = {i1, i2, i3, i4} \ndir = {(n0, left) . n1, (n0, right) . n2} df = {(n0, value) . i2, (n0, height) . i3} pv = {t . n0, v \n. i1, tv . i4} avln0 . n0 * cnil . avln0 . (avl * (n1). avl * (n2). i3 = hn0 . keys * (n1)= {i2}. {i2} \n= keys * (n2). -1 = h * (n1)- h * (n2). h * (n1)- h * (n2)= 1). keysn0 = keys * (n1). {v} . keys * (n2). \nhn0 = 1+ max(h * (n1), h * (n2)). n0 * cnil . n0 * n1 . n0 * n2 . (n1 = n2 . n1 = cnil) . i4 = i2 assume \n(tv * v) assume (tv < v) w := t.left; t) 5)) C = {cnil, n0}, S = {n1, n2}, I = {i1, i2, i3, i4} dir = \n{(n0, left) . n1, (n0, right) . n2} df = {(n0, value) . i2, (n0, height) . i3} pv = {t . n0, v . i1, \ntv . i4, w . n1} avln0 . n0 * cnil . avln0 . (avl * (n1). avl * (n2). i3 = hn0 . keys * (n1)= {i2}. {i2} \n= keys * (n2). -1 = h * (n1)- h * (n2). h * (n1)- h * (n2)= 1). keysn0 = keys * (n1). {v} . keys * (n2). \nhn0 = 1+ max(h * (n1), h * (n2)). n0 * cnil . n0 * n1 . n0 * n2 . (n1 = n2 . n1 = cnil) . i4 = i2 . i4 \n* i1 . i4 < i1 r := find(w, return r; v); t) 5)) C = {cnil, n0}, S = {n1, n2} I = {i1, i2, i3, i4, i5, \ni6} dir = {(n0, left) . n1, (n0, right) . n2} df = {(n0, value) . i2, (n0, height) . i3} pv = {t . n0, \nv . i1, tv . i4, w . n1, r . i5, ret_loc . i6} avln0 . n0 * cnil . avln0 . (pre call avln1 . avl * (n2). \ni3 = hn0. pre call keysn1 = {i2} . {i2} = keys * (n2). -1 = pre call hn1 - h * (n2). pre call hn1 - h \n* (n2)= 1). keysn0 = pre call keysn1 . {v} . keys * (n2). hn0 = 1+ max(pre call hn1, h * (n2)). n0 * \ncnil . n0 * n1 . n0 * n2 . (n1 = n2 . n1 = cnil) . i4 = i2 i4 * i1 . i4 < i1 . avl * (n1) . keys * (n1)= \npre call keysn1 . h * (n1)= pre call hn1 . i5 * 0 . i1 . keys * (n1) . i6 = i5 Figure3. Expanding the \nsymbolicheap andgenerating theformulas when applied to the inductive hypothesis that the algorithm works \ncorrectly on the smaller treethatit callsitself on.Thisis very com\u00admon in manual veri.cation of these \nalgorithms, and the footprint formula obtained in Section 3 rewords the recursive properties ex\u00adpressed \ndirectly in terms of recursive properties on the locations that the program makes recursive calls. Hence, \nin order to .nd a simple proof, we can replace recursive de.nitions on symbolic nodes as uninterpreted \nfunctions that map the symbolic trees to ar\u00adbitrary integers, sets of integers, multisets of integers, \netc., which we callformula abstraction(see[25 27] where such abstractions havebeen used). To prove a \nveri.cation condition (SH;.) . . using formula abstraction, we drop SH, and we replace recursive predicates \non symbolic nodesby uninterpretedBooleanfunctions, replace recur\u00adsiveintegerfunctions as uninterpreted \nfunctions that map nodes to integers, andreplace recursive set/multisetfunctions withfunctions that map \nnodes to arbitrary sets and multisets.Notice that the con\u00adstraints regarding the concrete and symbolic \nnodes in SH were al\u00adready added to .,during the construction of the veri.cation condi\u00adtion.Theformula \nresulting via abstractionis aformula .abs . .abs such that:(1) if .abs . .abs is valid,then sois(SH;.) \n. . (the converse may not necessarilybetrue);(2) checking .abs . .abs is decidable, and in fact can be \nreduced to QF UFLIA, the quanti.er\u00adfree theory of uninterpretedfunctions and arithmetic. The validity \nof the abstracted formula .abs . .abs over the theory of uninterpreted function, linear arithmetic, and \nsets and multisets of integers, is decidable. The fact that the quanti.er free theory of ordered sets \nis decidable is well known. In fact, Kun\u00adcak et al.[13] showedthatthequanti.er-freetheory of sets with \ncardinality constraints is NP-complete. Since we do not need car\u00addinalityconstraints, we use a slightly \nsimpli.eddecisionprocedure that reducesformulas with sets/multisets using uninterpreted func\u00adtions that \ncapture the characteristicfunctions associated with these sets/multisets.We omit thesedetailsin theinterest \nof space. 5. ExperimentalEvaluation In this section, we demonstrate the e.ectiveness and practicality \nof theDryad logic and the veri.cation procedures developed in this paper by verifying standard operations \non several inductive data structures. Each routine was written using recursivefunctions and annotated \nwith apre-condition and apost-condition, specifying a set of partial correctness properties including \nboth structural and data requirements. For each basic block of each routine, we manuallygenerated the \nveri.cation condition(SH;.)followingthe proceduredescribedinSection3.Then we examinedthe validity of \n. usingtheproceduredescribedinSection4.2.We employZ3[11], a state-of-the-art SMT solver, to check validity \nof the generated formula .D formula in the quanti.er-free theory of integers and uninterpreted functions \nQF UFLIA. The experimental results are tabulatedinFigure4. The data-structures, routines, and veri.ed \nproperties: Lists are trees with a singletondirection set. Sortedlistscanbe expressedin Dryad. The routines \ninsert and delete insert and delete a node withkey k in a sorted list, respectively, in a recursive fashion. \nThe routine insertion-sort takes a singly-linked list and sorts it by recursively sorting the tail of \nthe list, and inserting the key of the head into the sorted list by calling insert. We check if all these \nroutines return a sortedlist with the multiset ofkeys as expected. A binary heap is recursivelyde.ned \nas either an empty tree, or a binary tree such that the root is of the greatest key and both its leftand \nright subtrees arebinaryheaps.The routine max-heapify is given a binary tree with both its left and right \ntrees are binary heaps. If the binary-heap property is violated by the root, it swaps the root with its \ngreater child, and then recursively max-heapi.es that subtree. We check if the routine returns a binary \nheap with samekeys as that of theinput tree.  The treap data-structureis a class ofbinary trees with \ntwodata .eldsfor each node: key and priority.We assume that allpriorities aredistinct and allkeys aredistinct.Treaps \ncan alsobe recursively de.nedinDryad. Theremove-root routinedeletesthe root ofthe input treap, andjoins \nthetwo subtreesdescendingfrom theleftand right children of the deleted node into a single treap. If the \nleft or rightsubtree of thenodetobedeletedisempty,thejoinoperation is trivial;otherwise, theleft or right \nchild of thedeleted nodeis se\u00adlected as the new root, and the deletion proceeds recursively. The delete \nroutine simply searches the node tobedeleted recursively, anddeletesitby calling remove-root.The insert \nroutine recur\u00adsively inserts the new node into an appropriate subtree to keep the binary-search-tree \nproperty, then performs rotations to restore the min-heap order property, if necessary. We check if all \nthese rou\u00adtines return a treap with the set of keys and the set of priorities as expected. An AVL tree \nis a binary search tree that is balanced: for each node, the absolutedi.erence between theheight of theleft \nsubtree and the height of the right subtree is at most 1. The main routines forAVL are insert and delete. \nThe insert routine recursively inserts a key into an AVL tree (similar to a binary search tree), and \nas it returns from recursion it checks the balancedness and performs one or two rotations to restore \nbalance. The delete routine recursivelydeletes akeyfrom anAVL tree(again, similar to abinary search tree), \nand asit returnsfrom the recursion ensures that the tree is indeed balanced. For both routines, we prove \nthat theyreturn anAVLtree,thatthe multiset ofkeysis as expected, and thattheheightincreasesby at most1(for \ninsert), can decrease by at most1(for delete), or stays the same. Red-black trees are binary search trees \nthat are more loosely balanced thantheAVL trees,and weredescribedinSection3. We consider the insert and \ndelete routines. The insert routine recursively inserts a key into a red-black subtree, and colors the \nnew node red, possibly violating the red-black tree property. As it returns from recursion, it performs \nseveral rotations to .x the property. If the root of the whole tree is red, it is recolored black, and \nall theproperties are restored.The delete routine recursively deletes akeyfrom a red-blacktree,possiblyviolatingthe \nred-black treeproperty.Asit returnsfrom recursion,it againperforms several rotationsto .xit. Forbothroutines,weprovethatthey \nreturnared\u00adblack tree, that the multiset of keys is as expected, and the black heightincreasesby at most1(for \ninsert),decreases byat most1 (fordelete), ordoes notchange. The B-tree is a data structure thatgeneralizes \nthebinary search tree in that for each non-leaf node the number of children is one more than the number \nof keys stored in that node. The keys are storedinincreasing order, andifthe nodeis not aleaf,thekey \nwith index i is no less than any key stored in the child with index i and no more then all the keys stored \nin the child with index i + 1. For each node except the root, the number of keys is in some range (typically \nbetween T - 1 and 2T - 1). A B-tree is balanced in that for each node, the heights of all the children \nare equal. To describe the B-tree in our logic, we need three mutually recursive predicates: one that \ndescribes a B-subtree, and two that describe a list of keys and children. The b-subtree * (t)states that \nthe number of keys stored in the node is in the required range, and that keys and children list satis.es \neither the key-child-list * (l) predicate (if the node is not a leaf) or the key-list * (l)predicate(ifthe \nnodeis a leaf). The key-child-list * (l)states that either the list has only one element, and the child \nsatis.es the b-subtree * (t) predicate, or the list has at least two elements, the key in the head of \nthe list is no less than all the keys stored in the child and no greater than the keys stored in the \ntail of the list, the child satis.es b-subtree * (t),  Data Structure #Ints #Sets #MSets #Preds Routine \n#BB Max. #Nodes in Footprint Total Time (s) Avg. Time (s) per VC VC proved valid? insert 4 3 0.24 0.06 \nYes Sorted List 0 0 1 1 delete 3 3 0.17 0.06 Yes insertion-sort 3 4 0.11 0.04 Yes Binary Heap 0 0 1 1 \nmax-heapify 5 8 1.89 0.38 Yes insert 7 6 4.06 0.58 Yes Treap 0 2 0 1 delete 6 4 0.81 0.14 Yes remove-root \n7 8 2.96 0.42 Yes AVLTree 1 0 1 1 insert delete 11 18 8 7 1.45 2.13 0.13 0.19 Yes Yes Red-Black Tree \n1 0 1 1 insert delete 19 24 8 7 1.93 3.22 0.11 0.14 Yes Yes B-Tree 2 0 1 2 insert find 12 8 6 3 0.40 \n0.12 0.03 0.02 Yes Yes delete-minimum 3 7 0.29 0.10 Yes Binomial Heap 1 0 1 3 find-minimum 4 6 1.81 0.45 \nYes merge 13 7 17.38 1.37 Yes Total 147 Figure4. Results ofprogram veri.cation(seedetails at http://www.cs.illinois.edu/~madhu/dryad \n) andtheheight ofthechildisequaltotheheight ofthetail(the height of a list is de.ned as the maximum height \nof a child). The predicatekey-list * (l)is similarlyde.ned.We consider thefind and insert routines.The \nfind routineiterates overthelistofkeys, and recursesintotheappropriatechild,untilit .ndsthekey orit arrives \nto a leaf. The insert procedure is more complex, as it assumes that the node it is inserting into is \nnon-full, and prior to recursion it might need to split the child. For both routines, we check that the \ntree after the call is a B-tree, that the multiset of keys has the expected value, and that the height \nof the tree stays the same, or increasesby at most1(for insert). As an advanced data structure, the binomial \nheap is described by a set ofpredicatesde.ned mutually recursively: binomial-tree * , binomial-heap * \nand full-list * . Brie.y, a binomial-heap of order k consists of a binary-tree of order k and a binary-heap \nof order less than k. A binomial-tree of order k is an ordered tree de.ned recursively: the root contains \nthe minimum key, and its children compose a binomial-heap of order k - 1, satisfying the full-list property.Afull-listof \norder kconsists of atree of order kand afull\u00adlist of order k - 1. The left-child, right-sibling scheme \nrepresents each binomial tree within a binomial heap. Each node contains its key;pointers toitsleftmost \nchild and to the siblingimmediately to its right;anditsdegree.The roots of abinomialheapform a singly\u00adlinkedlist(also \nconnectedby the siblingpointer).We access the binomialheapby apointertothe .rst nodeontherootlist. Thefind-minimum \nroutine expects a nonemptybinomialheap, and moves the tree containing the minimum key to the head of \nthe list. It returns the original heap if it is a single tree. Otherwise, it calls find-minimum on its \ntail list, and appends the returned list to the head tree; then if keys of the roots of the .rst two \ntrees areunordered, swapsthetwotrees.Wecheck that find-minimum returns a binomial tree followed by a \nbinomial heap, such that the root of the tree contains the minimum key, and the head of the binomial \nheap is either the .rst or the second root of the original heap. The merge routine merges two binomial \nheaps x and y into one. If one of the two heaps is empty, it simply returns the other one.Otherwise,iftheheads \nofthe twoheaps are ofthe same order, it merges the two head trees into one, merges the two tail lists \nrecursively, and returns the new tree followed by the new heap; if not, say, x.order > y.order, then \nit merges x.sibling and y, concatenates thehead tree of x and the newheap in an appropriate way satisfying \nthe binomial-heap property. We check that merge returns a binomial heap such that the keys are the union \nof the two input binomial heaps, and the order increases up to 1. The delete-minimum routine is non-recursive. \nIt simply moves the minimumtree m totheheadby calling find-minimum, and obtains two binomial heaps: a \nlist of the siblings of m, and a list of the children of m.Finallyit merges the twoheapsby merge.We check \nthat delete-minimum returns abinomialheap withthe multiset of keys as expected. Figure 4 summarizes our \nexperiments, showing the results of verifying 147 basic blocks across these algorithms. For each data \nstructure,we reportthe number ofintegers, sets,multisetsandpred\u00adicates de.ned recursively. For each routine, \nwe report the number ofbasicblocks,the number of nodesinthefootprint,thetimetaken by Z3 to determine \nvalidity of all generated formulas, and the va\u00adlidityresultprovedbyZ3. Notethatonly the .rstthreedata-structures(sortedlist,binary \nheap and treap) .t in the decidable fragment described in Sec\u00adtion 4.1 as they do not require recursively \nde.ned integers. Fur\u00adthermore, sincethedi.erence operationsbetween sets/multisets are disallowed, we \ncan check all functional properties for these data\u00adstructures except checking that the set of keys/priorities \nat the end of the each routineis as expected. We are encouraged by the fact that all these veri.cation \ncon\u00additions that were deterministically generated by the methodology set forth in this paper were proved \nby Z3 e.ciently; this proved all these algorithms correct. To the best of our knowledge, this is the \n.rst terminating automatic mechanism that can prove such a wide variety of data-structure algorithms \nwritten using imperative programmingcorrect(inparticular,binomialheaps and theB-trees presentedherehave \nnotbeenproven automaticallycorrect). The experimental results show that Dryad is a very expressive logic \nthat allows us to express natural and recursive properties of several complexinductivetreedata structures.Moreover, \nour sound procedure tends to be able to prove many complex veri.cation conditions. 6. RelatedWork There \nis a rich literature on program logics for heaps. We discuss the work that is closest to ours. In particular, \nwe omit the rich literature ongeneralinteractive theoremprovers(likeCoq[12]) as well asgeneral software \nveri.cationtools(likeBoogie[2])that are notparticularly adaptedforheap veri.cation. Separationlogic[4,19,23]is \none ofthe mostpopularlogicsfor veri.cation of heap structures. Many dialects of separation logic combine \nseparation logic with inductively de.ned data-structures. While separation logic gives mechanisms to \ncompositionally rea\u00adson with the footprint and the frame it resides in, proof assistants for separationlogic \nare oftenheuristic andincomplete[4],thougha couple of smalldecidablefragments areknown[3,17].A workthat \ncomes very close to oursis apaperbyChin et al.[8], wherethe au\u00adthors allow user-de.ned recursivepredicates(similarto \nours) and build a terminating procedure that reduces the veri.cation condi\u00adtionto standardlogicaltheories.Whiletheirprocedureis \nmoregen\u00aderal than ours(they canhandle structuresbeyond trees), the result\u00ading formulas arequanti.ed, \nand resultinless e.cientprocedures. Bedrock[9]is aCoqlibrarythat aims at mostly automated(but not completely \nautomated)procedures that requires someproof tactics tobegivenby the user toprove veri.cation conditions. \n In manual and semi-automatic approaches to veri.cation of heapmanipulatingprograms[4,23,24],theinductivede.nitions \nof algebraicdata-typesis extremely common, andproof tactics unroll theseinductive de.nitions,do extensive \nuni.cation to try to match terms,and .nd simpleproofs.Ourworkinthispaperisvery much inspired by the kinds \nof manual heap reasoning that we have seen in theliterature. TheworkbyZeeetal.[26,27] isoneofthe .rstattemptsat \nfullfunctionalveri.cation oflinkeddata structures, whichincludes the development of the Jahob system \nthat uses higher-order logics to specify correctnessproperties, andputs together several theorem proversrangingfrom \n.rst-orderprovers,SMTsolvers,andinterac\u00adtivetheoremproverstoproveproperties ofalgorithms manipulating \ndata-structures.While manyproofs required manualguidance, this work showed thatproofs can oftenbederived \nusing simpletactics like unrolling of inductive de.nitions, uni.cation, abstraction, and employing decision \nprocedures for decidable theories. This work was also aninspirationfor our work,but we choseto concentrate \non derivingproofs usingcompletely automatic and terminatingproce\u00addures, where uni.cation, unrolling, \nabstraction, and decidable the\u00adories are systematically exploited. One workthatis very closeto oursisthat \nofSuter et al.[25] where decision procedures for algebraic data-types are presented with abstraction \nas thekey to obtainingproofs.However, this work focuses on sound and completedecisionprocedures, andislimited \ninits abilitytoprove severalcomplexdata structures correct.More\u00adover,the worklimitsitselftofunctionalprogram \ncorrectness;in our opinion,functionalprograms are very similarto algebraicinductive speci.cations,leading \nto much simplerproofprocedures. Thereis arich andgrowing literatureoncompletely automatic sound, complete, \nandterminatingdecisionproceduresfor restricted heap logics. The logic Lisbq [14] o.ers such reasoning \nwith re\u00adstricted reachability predicates and quanti.cation. While the logic has extremelye.cientdecisionprocedures,its \nexpressivityin stat\u00adingproperties ofinductivedata-structures(eventrees)isverylim\u00adited.There are several \notherlogicsin thisgenre,beingless expres\u00adsivebutdecidable[1,5,6,18,20 22].Strand is a recentlogic that \ncan handle some data-structure properties (at least binary search trees) and admitsdecidablefragments[15,16] \nby combiningde\u00adcidable theories of trees with the theory of arithmetic, but is again extremely restrictedin \nexpressiveness.None oftheselogics can ex\u00adpress the veri.cation conditions for full functional veri.cation \nof thedata-structures exploredin thispaper. Acknowledgements This workispartiallyfundedbyNSFCA\u00adREERaward#0747041 \nandNSA contractH98230-10-C-0294. References [1] I. Balaban, A. Pnueli, and L. D. Zuck. Shape analysis \nby predicate abstraction. In VMCAI 05, volume 3385 of LNCS, pages 164 180. Springer,2005. [2] M.Barnett,B.-Y.E.Chang,R.DeLine,B.Jacobs,andK.R.M.Leino. \nBoogie: A modular reusable veri.er for object-oriented programs. In FMCO 05, volume4111 of LNCS,pages364 \n387.Springer,2005. [3] J. Berdine, C. Calcagno, and P. W. O Hearn. A decidable fragment of separation \nlogic. In FSTTCS 04, volume3328 of LNCS,pages97 109.Springer, 2004. [4] J.Berdine,C.Calcagno, andP.W.O \nHearn.Symbolicexecutionwith separation logic. In APLAS 05, volume 3780 of LNCS, pages 52 68. Springer, \n2005. [5] N.Bj\u00f8rnerandJ.Hendrix.Linearfunctional .xed-points.In CAV 09, volume5643 of LNCS,pages124 139.Springer,2009. \n[6] A. Bouajjani, C. Dragoi, C. Enea, and M. Sighireanu. A logic\u00adbased framework for reasoning about \ncomposite data structures. In CONCUR 09, volume5710 of LNCS,pages178 195.Springer,2009. [7] A.R.Bradley \nandZ.Manna. TheCalculus ofComputation. Springer, 2007. [8] W.-N.Chin,C.David,H.H.Nguyen, andS.Qin. Automated \nveri.\u00adcation of shape,sizeandbagproperties viauser-de.nedpredicatesin separation logic. Science ofComputerProgramming,inpress,2010. \n[9] A. Chlipala. Mostly-automated veri.cation of low-level programs in computational separation logic. \nIn PLDI 11, pages 234 245. ACM, 2011. [10] T.H.Cormen,C.E.Leiserson,R.L.Rivest,andC.Stein. Introduction \nto Algorithms. MITPress, third edition, 2009. [11] L. M. de Moura and N. Bj\u00f8rner. Z3: An e.cient SMT \nsolver. In TACAS 08, volume4963 of LNCS,pages337 340.Springer,2008. [12] INRIA.Thecoqproof assistant. \nURLhttp://coq.inria.fr/. [13] V.Kuncak,R.Piskac,andP.Suter.Ordered setsinthecalculusofdata structures. \nIn CSL 10,volume6247 of LNCS,pages34 48. Springer, 2010. [14] S.Lahiri andS.Qadeer.Back tothefuture: \nrevisitingpreciseprogram veri.cation using SMT solvers. In POPL 08,pages 171 182. ACM, 2008. [15] P.MadhusudanandX.Qiu. \nE.cient decision procedures for heaps using STRAND. In SAS 11, volume 6887 of LNCS, pages 43 59. Springer, \n2011. [16] P.Madhusudan,G.Parlato, andX.Qiu. Decidablelogics combining heap structures anddata.In POPL \n11,pages611 622.ACM,2011. [17] S. Magill, M.-H. Tsai, P. Lee, and Y.-K. Tsay. THOR: A tool for reasoning \nabout shape and arithmetic. In CAV 08, volume 5123 of LNCS,pages428 432.Springer,2008. [18] G. Nelson. \nVerifying reachability invariants of linked structures. In POPL 83,pages38 47.ACM,1983. [19] P. W. O \nHearn, J. C. Reynolds, and H. Yang. Local reasoning about programs that alterdata structures. In CSL \n01, volume2142 of LNCS, pages1 19.Springer, 2001. [20] Z.Rakamari\u00b4c,J.D.Bingham, andA.J.Hu. Aninference-rule-based \ndecision procedure for veri.cation of heap-manipulating programs with mutable data and cyclic data structures. \nIn VMCAI 07, volume 4349 of LNCS,pages106 121.Springer, 2007. [21] Z.Rakamari\u00b4c,R.Bruttomesso,A.J.Hu,andA.Cimatti. \nVerifying heap-manipulating programs in an SMT framework. In ATVA 07, volume4762 of LNCS,pages237 252.Springer,2007. \n[22] S. Ranise and C. Zarba. A theory of singly-linked lists and its ex\u00adtensible decision procedure. \nIn SEFM 06, pages 206 215. IEEE-CS, 2006. [23] J. Reynolds. Separation logic: a logic for shared mutable \ndata struc\u00adtures. In LICS 02,pages55 74.IEEE-CS,2002. [24] G. Rosu, C. Ellison, and W. Schulte. Matching \nlogic: An alternative to Hoare/Floyd logic. In AMAST 10, volume 6486 of LNCS, pages 142 162.Springer,2010. \n[25] P.Suter,M.Dotta, andV.Kuncak. Decisionproceduresforalgebraic data types with abstractions. In POPL \n10, pages 199 210. ACM, 2010. [26] K. Zee, V. Kuncak, and M. C. Rinard. Full functional veri.cation of \nlinked data structures. In PLDI 08,pages349 361.ACM,2008. [27] K. Zee, V. Kuncak, and M. C. Rinard. An \nintegrated proof language forimperativeprograms. In PLDI 09,pages338 351.ACM,2009.  \n\t\t\t", "proc_id": "2103656", "abstract": "<p>We develop logical mechanisms and procedures to facilitate the verification of full functional properties of inductive tree data-structures using recursion that are sound, incomplete, but terminating. Our contribution rests in a new extension of first-order logic with recursive definitions called Dryad, a syntactical restriction on pre- and post-conditions of recursive imperative programs using Dryad, and a systematic methodology for accurately unfolding the footprint on the heap uncovered by the program that leads to finding simple recursive proofs using formula abstraction and calls to SMT solvers. We evaluate our methodology empirically and show that several complex tree data-structure algorithms can be checked against full functional specifications automatically, given pre- and post-conditions. This results in the first automatic terminating methodology for proving a wide variety of annotated algorithms on tree data-structures correct, including max-heaps, treaps, red-black trees, AVL trees, binomial heaps, and B-trees.</p>", "authors": [{"name": "Parthasarathy Madhusudan", "author_profile_id": "81100489757", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P2991357", "email_address": "madhu@illinois.edu", "orcid_id": ""}, {"name": "Xiaokang Qiu", "author_profile_id": "81421595944", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P2991358", "email_address": "qiu2@illinois.edu", "orcid_id": ""}, {"name": "Andrei Stefanescu", "author_profile_id": "81485649989", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P2991359", "email_address": "stefane1@illinois.edu", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103673", "year": "2012", "article_id": "2103673", "conference": "POPL", "title": "Recursive proofs for inductive tree data-structures", "url": "http://dl.acm.org/citation.cfm?id=2103673"}