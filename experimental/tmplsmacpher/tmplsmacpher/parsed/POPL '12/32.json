{"article_publication_date": "01-25-2012", "fulltext": "\n Sound Predictive Race Detection in Polynomial Time YannisSmaragdakis JacobM.Evans CaitlinSadowski JaeheonYi \nUniversity ofAthensand University ofMassachusetts,Amherst CormacFlanagan University ofMassachusetts,Amherst \njmevans@cs.umass.edu University ofCalifornia atSantaCruz smaragd@di.uoa.gr Abstract Data races are among \nthe most reliableindicators ofprogramming errors in concurrent software. For at least two decades, Lamport \ns happens-before(HB)relationhas served asthe standardtestforde\u00adtecting races other techniques, such aslockset-based \napproaches, fail to be sound, as they may falsely warn of races. This work in\u00adtroduces a new relation, \ncausally-precedes(CP), whichgeneralizes happens-before to observe more races without sacri.cing sound\u00adness.Intuitively,CP \ntries to capture the concept ofhappens-before ordered events that must occur in the observed order for \nthe pro\u00adgram to observe the same values.WhatdistinguishesCPfrompast predictive race detection approaches(whichalsogeneralize \nan ob\u00adserved execution to detect races in other plausible executions) is thatCP-based racedetectionisboth \nsound and ofpolynomial com\u00adplexity. Wedemonstrate thatthe unique aspects ofCPresultinpractical bene.t. \nApplying CP to real-world programs, we successfully an\u00adalyze server-level applications(e.g.,ApacheFtpServer) \nand show that traces longer than in past predictive race analyses can be an\u00adalyzed in mere seconds to \na few minutes. For these programs, CP race detection uncovers races that are hard to detect by repeated \nexecution and HB race detection: a single run of CP race detec\u00adtionproduces several races notdiscoveredby10 \nseparate rounds of happens-before racedetection. Categories and Subject Descriptors D.1.3 [Concurrent \nPro\u00adgramming]; D.2.4[Software/Program Veri.cation] General Terms Languages,Reliability,Veri.cation 1. \nIntroduction Data races are the most common symptom of a programming error in the increasingly central \n.eld of concurrent programming. Two memory accesses are con.icting if they are performed by di.erent \nthreads, they access the same memory location, and at least one of them is a write. A data race is then \ntypically de.ned as two concurrent (or unordered or not happens-before-ordered) con.icting accesses[7,21,26,36]. \nTypical modern high-performance dynamic race detectors are based on one of two principles: happens-before \n(HB)ordering or lockset computation. Lockset-based race detectors follow an idea popularizedbyEraser[42]and \nattempttodetectinconsistent use of locks for access to the same memory location bydi.erent threads. Permission \nto make digital or hard copies of all or part of this work for personal or classroomuseisgranted withoutfeeprovided \nthat copiesarenot madeordistributed forpro.tor commercial advantage andthat copiesbearthis notice andthefull \ncitation onthe .rstpage.Tocopy otherwise,torepublish,topostonservers ortoredistribute tolists, requiresprior \nspeci.cpermission and/or afee. POPL 12, January25 27,2012,Philadelphia,PA,USA. Copyright &#38;#169; 2012ACM978-1-4503-1083-3/12/01. \n. .$10.00 {supertri,jaeheon,cormac}@cs.ucsc.edu This approach has the advantage of detecting many races, \neven if these are not observed in the execution being monitored. For instance, if the detector records \ntwo write accesses by di.erent threads tothe same memory word withoutholding a commonlock, it will report \na possible race. The drawback of lockset-based race detectors is that they are unsound. The reported \nraces are often spurious since the two suspicious events may be well-ordered via other thread communication \n(e.g., the prior reading of a well\u00adsynchronized .ag indicating that the thread can now freely read shared \ndata without synchronization). Consider, for instance, the example executioninFigure1.(Our visual conventionisthatevents \noccurtop-to-bottominthetotalorder ofthe observed execution.We usethe standard syntax acq(l)/rel(l) forthe \nacquisition/release of lock l, and w(x)/r(x) for the write/read of variable x.) Thread 1 Thread 2 w(y) \nacq(l) w(x) rel(l)  acq(l) r(x) r(y) rel(l) Figure1. Example of no race on variable y. Although the \ntwo accesses to shared variable y do not occur with the samelockheld, they are well-ordered the second \naccess only occurs afterThread2has observed a value writtenbyThread 1. It is quite possible that, if \nthe two critical sections over lock l had been swapped, Thread 2 would not have attempted to read y sinceits \nread of x wouldhaveyielded adi.erent value. In our work, we focus on sound race detection: races are \nex\u00adtremely hard to debug and reporting false positives to the user severely reduces the usability of \na race detection tool. Sound race detectionisahallmarkfeature ofhappens-beforebasedapproaches. HB race \ndetectors attempt to discern when there has been inter\u00adthread communication that e.ectively orders the \ntwo con.icting events. Unordered events are reported as a race, since there is no reason why they could \nnot have occurred at exactly the same in\u00adstance. In its simplest form, happens-before is a partial order \nthat generalizes the observed total order of a multithreaded program s executionby: ordering all events \nby a single thread in the order they were actually observed ordering lock releases and subsequent acquisitions \nof the same lockin the order they were observed.  All events unordered by happens-before are then considered \nto be potentially performed simultaneously. Under the assumption thatthreadscanonly communicateviamechanisms \nrepresentedin the HB order1 this approach is sound. Consider again the above 1 2 execution trace. The \ninter-thread HB edge shown as an arrow, 3 together with the transitivity of the HB partial order, ensure \nthat 4 the two writes to y areHB-ordered,thusnoHB raceisreported. 5 The problem with plain happens-before \nrace detection is that 6 it can miss many races due to accidental HB edges. The original 7 de.nitionofhappens-beforebyLamport[30]wasinthecontext \nof 8 distributed systems,with anHB edgeintroducedforexplicitinter-9 processcommunication.Locksynchronizationdoesnotinducethe \n10 11 same hard ordering as explicit communication, however. A lock\u00ad 12 based critical section can often \nbe reordered with others, as long 13 as lock semantics (mutual exclusion) is preserved. Consider the \n14 code example shown in Figure 2. In this example, the PolarCoord 15 classhastwo .elds, radius and angle,protectedby \ntheobjectlock 16 this.The count .eld tallies the number of accesses to radius and 17 angle, and the main \nmethod forks two concurrent threads. This 18 program has a race condition on count;unfortunately,preciserace \n19 detectors such as FastTrack [21] or djit + [38] fail to detect this 20 21 race condition on94% of \ntest runs. 22 Figure 3(A) illustrates the essence of the problem by showing 23 the trace that theHotSpotJVM \ntypicallygeneratesfor theprogram of Figure 2, with no overlap between the executions of the two threads. \nFor this trace, a happens-before race detector would not .nd a race on count, since the lock release \nby Thread 1 happens\u00adbefore the lock acquire of Thread 2, thereby masking the lack of synchronization \nbetween the accesses to count. In contrast, trace B presents a di.erent scheduling where there is clearly \na race on count. By inspection, we are able to predict from trace A that a race condition could occur \nas in trace B; we say that traceAhas a predictable race. Our work consists ofde.ning a new relation, \ncausally-precedes (CP),byanalogytohappens-before,todetect such races.A race oc\u00adcursiftwo con.icting actions \nare notCP-ordered.Unlikepriorpre\u00adcise racedetectors, aCP-based racedetector candetectpredictable race \nconditions as in Figure 3. The essence of detecting this pre\u00addictable raceis that the criticalsection \nofThread2has received no information that can reveal whether the critical section of Thread 1has already \nexecuted or not.Moreprecisely, reordering events as intraceB(thus exposing anHB race) maintainstheproperty \nthat all read operations return exactly the same values as in the orig\u00adinal execution we call this a \ncorrect reordering of the observed behavior.A correctly reordered executionisjust asfeasible asthe observed \none. Some previous work has addressed the problem of latent races in the context of happens-before race \ndetection [10, 11, 45, 47]. This worktypically comes under thelabel of predictive race analy\u00adsis,andisasubset \nof thegeneral areaofpredictive andgeneraliz\u00ading concurrency analysis[18,20,28,29,48,49,57 59].The main \nidea of this body of work is to consider which of the correct re\u00adorderings of critical sections would \nhave triggered a racein anHB detector.Theproblem with a reorderings-based approachisthatit requires exploring \nall reorderings of critical sections to determine which ones are correct and produce a race. This exploration \nis an expensiveprocess: the space ofpossible reorderingsis exponential and executions with races are \noftenhard todiscover.When applied todynamic(i.e.,run-time) racedetection [the]predictiveruntime analysis \ntechnique can be understood as a hybrid of testing and model checking [9]. 1Although this simplistic \nde.nition only covers locks, other inter-thread communication canbecaptured ashappens-before edges. Figure2:ExampleProgramPolarCoord \nclass PolarCoord { int radius, angle; int count; // counts accesses static PolarCoord pc = new PolarCoord(); \nvoid setRadius(int r) { count++; synchronized(this) { radius = r; } } int getAngle() { int t; synchronized(this) \n{ t = angle; } count++; return t; } public static void main(String[] args){ fork { pc.setRadius(10); \n} fork { pc.getAngle(); } } } Figure3:ExampleTraces for thePolarCoord Program. Thread1 Thread2 r(count) \nw(count) acq(this) w(radius) rel(this) acq(this) r(angle) rel(this) r(count) w(count) Tool Report Happens-Before: \nno race Causally-Precedes: race (A)predictable race condition Thread1 Thread2 acq(this) r(angle) rel(this) \nr(count) w(count) r(count) w(count) acq(this) w(radius) rel(this) Tool Report Happens-Before: race Causally-Precedes: \nrace (B)happens-before race In contrast, our work o.ers the .rst sound yet scalable tech\u00adnique for predictive \nrace detection. Speci.cally, CP weakens the HB order while still maintaining soundness. CP is guaranteed \nto have a polynomial cost of evaluation, and our e.cient implemen\u00adtation allows turning this into a linear \ncost, by limiting the size of the reordering window.CP racedetection results are not complete: examining \nall correct reorderings ofthe originaltrace would neces\u00adsitate an exponential search. Consequently, our \ndetector may miss some races. Nevertheless, it is guaranteed to detect a superset of the observed happens-before \nraces and to only give warnings for trueraces.(More accurately,thesoundnesstheoremweproveis more subtle: \nif our detector issues a warning, there is either a cor\u00adrect reordering of the observed execution that \nexhibits anHB race, or a reordering that exhibits a deadlock. Thus, our race soundness guarantee only \napplies to deadlock-free programs, yet in practice our sound warning of apossibledeadlockisjust as valuable \nas a warning of a race.)  Speci.callyour work makes thefollowing contributions: Wepresentcausally-precedes, \naweaker relationthanhappens\u00adbefore, yet o.ering the same desirable features: CP leads to sound racedetection,and \ncanbeevaluated e.ciently(inpoly\u00adnomial time).Itis worth emphasizing that multiple researchers have fruitlessly \npursued such a weakening of HB in the past. Wedemonstrate with numerous examples whyitisnoteasy to weaken \nHB while remaining sound.(Both the de.nition of CP and ourproof of soundness areresultsof multi-yearcollabora\u00adtive \nwork, with severalintermediatefailed attempts.)  We present an e.cient implementation of CP. Although \nthe relationispolynomial,practical racedetectioncanhardly a.ord even quadratic complexity: an O(n 2) \nalgorithm(with n being the number of observed events) is unscalable in practice, with event counts in \nthe millions. We implement our algorithm in Datalog,fordeclarativelogicalreasoning, and apply successive \noptimizations, .rst to make the algorithm s complexity depend only on synchronization events, and then \nto derive a family of linearalgorithmsby allowing .nitereordering windows.  Our experiments showcase \nthe advantages of CP and our im\u00adplementation. The extra races detected are among the hardest todiscover \nwithplainHB analysis.A singleCP-based racede\u00adtection rundiscovers several new races, unexposed by10inde\u00adpendent \nruns of plain HB race detection. Our implementation avoids past scalability pitfalls. If we examine races \nappearing within a .nite reordering window (e.g., 1,000 non-redundant shared memory events) we can achieve \nlinear runtime costsfor our analysis, evenfor real-worldprograms and workloads.  The rest of the paper \nintroduces our causally-precedes relation (Section 2), illustrates the kind of reasoning it supports \nand its soundness properties (Section 3), describes our implementation (Section4),presents experimentalresults(Section5), \nanddiscusses related work(Section6)before concluding(Section7). 2. Causally-Precedes We next introduce \nour new relation, causally-precedes, and subse\u00adquentlyillustrateitvia examples. 2.1 De.nitions We consider \na standardsingle-observer modelfor assigning seman\u00adtics to a concurrent execution. That is, all events \nare observed in a total order and we de.ne our concepts relative to the observed order. Events have the \nform[t : a]i, where t is the thread perform\u00ading the event, and i is the event s index in the total order. \nThe ac\u00adtion, a performed by an event is of the form w(x),r(x),acq(l)and rel(l).Threadcreationandjoining \ncanbeadded straightforwardly, as explicit causally-precedes edges; for simplicity, we do not dis\u00adcuss \nthese eventsin the examples. De.nition 1(Happens-before). In this framework the happens\u00adbefore(\u00abHB)relationisde.ned \nsimply asthe smallest relationthat satis.esthefollowing(weuseunderscoresasa don t care value): Events \nby the same thread are ordered as they appear. This partial order of events in a trace is also called \nProgram Order (PO). ([t :]i1 \u00abHB [t :]i2 ifi1 = i2)  Releases and acquisitions of the same lock are \nordered as they appear. ([t1: rel(l)]irel \u00abHB [t2: acq(l)]iacq ifirel < iacq)  \u00abHB is closed under composition \nwithitself. (\u00abHB = (\u00abHB .\u00abHB))  We also assume twohelper relations:  the binary relation . (read \ncon.icts). Two events by di.erent threads con.ictiftheyboth access the same variable and one of the actionsis \na write.  the function RL(e) that maps a lock acquisition event to the correspondinglock release.(I.e., \nRL([t1: acq(l)]iacq ) = [t1: rel(l)]irel if thereis no[t1: rel(l)]i ' with iacq < i ' < irel.) In  rel \nthiscase,we saythat[t1: acq(l)]iacq ispairedwith [t1: rel(l)]irel . RL(e)is a one-to-one function for \na well-formedexecution, so we also consideritsinverse, RL-1(e).2 rel De.nition 2 (Causally Precedes). \nCausally precedes (\u00abCP) is then the smallest relation such that: a) \u00abCP has a release-acquire edge between \ncritical sections over the samelock that contain con.icting events. ([t1: rel(l)]irel \u00abCP [t2: acq(l)]jacq \nifthere are [t1: ]k1 . [t2: ]k2 such that iacq < k1 < irel < jacq < k2 < jrel, where RL-1([t1: rel(l)]irel \n)= [t1: acq(l)]iacq and RL([t2: acq(l)]jacq )= [t2: rel(l)]jrel ) b) \u00abCP has a release-acquire edge between \ncritical sections over the same lock that contain CP-ordered events. (These events can be lock acquisition \nor release events, and not necessarily internal eventsin the critical section.) Because ofRule(c),below, \nthis condition turns outtobe equiv\u00ad alent to the seemingly weaker releases and acquisitions of the same \nlock are ordered if the beginning of one critical section isCP-ordered with the end of the other since \nthereis an HB order between the start of a critical section and every internal event, as well as allinternal \nevents andthe end of a critical sec\u00ad tion.([t1: rel(l)]irel \u00abCP [t2: acq(l)]jacq ,if RL-1([t1: rel(l)]irel \n)\u00abCP RL([t2: acq(l)]jacq ) c) CPis closed underleft and right composition withHB. (\u00abCP = (\u00abHB .\u00abCP)= \n(\u00abCP .\u00abHB)) Note that \u00abCP is a subset of the happens-before relation. In\u00adspecting the three cases of \nthe \u00abCP de.nition, we see that all \u00abCP edges produced by the .rst two rules are release-acquire edges \non the samelock and so are also \u00abHB edges.The third rule then states thatCPis closed under composition \nwithHB, which stillproduces a subset of theHB edges, sinceHBis transitively closed.Itis sim\u00adilarlyeasy \nto see thatCPis transitive. De.nition 3(CP-Race). We de.ne a race (orCP-race when we need to distinguish \nfrom happens-before races) to be a pair of con.icting events that are notCP-orderedin eitherdirection. \n 2.2 Illustration There are a few aspects of the de.nition of CP that should be emphasized for clarity. \nProbably most important among them is thatCPis not a re.exive relation.(Ifit were,Rule(c) would make \nCPequal toHB.)Consequently, CPis also not apartial order. RecallthatwewantCPtoretainonlysome oftheHBedges(i.e., \nordering dependencies) in a way that captures which con.icting events could have happened simultaneously \nin a reordered but certain-to-be-feasible execution. Consider again the example of Figure3fromSection1and \nobserve thatthe shownHB edgeis not a CP edge. None of the events shown are CP-ordered i.e., they constitute \naCP-race(and apredictable race).The same occursin the execution ofFigure4. 2Inthissection wetry tostrikeabalancebetweenprecisepresentation \nand avoiding tediousde.nitionsforpre-existing, well-understood concepts.We thustry tobe moreformal whende.ning \nelements uniqueto our approach and otherwise rely on intuition e.g., the preconditions for a well-formed \ntrace (such as pairing of lock acquisitions and releases, well-nesting of critical sections) are omittedherebut \nstatedfullyin ourproof of soundness.  Thread1 Thread2 w(y) acq(l) rel(l) acq(l) rel(l) w(y) Figure4. \nAnother example of a certain race not reportedbyHB. In both cases, the critical sections do not contain \ncon.icting events, which would orderthemperRule(a) of theCPde.nition. In contrast,Figure1inSection1incurs \nno CP race report: theHB release-acquire edgeis also aCP edge(perRule(a)) andRule(c) can thenbe used \ntoCP-order the two operations on variable y. Indeed,Rule(a)oftheCPde.nitionis almostinevitable.To see \nthis consider what constitutes afeasible execution. De.nition 4(Correctly Reorders). We say that an execution \nex ' correctly reorders(CR) another execution ex (also writtenex ' = CR ex)i. ex ' is a totalorder over \na subset of the events of ex that: contains apre.x ofthe events of every threadin ex and respects program \norder, i.e., if an event e in ex appears in ex ' then all eventsby the same threadthatprecede e inex \nalso appearin ex ' andprecede e.  for every read event that appears in ex ' , the most recent write \nevent of the same variablein ex ' is the same as the most recent write event of the same variablein ex. \n The de.nition of CR matches the intuition for feasible alterna\u00adtive executions: if every value read \nis the same as in the observed execution, then the alternativeis certainly alsofeasible.3 Inthislight,Rule(a) \nfromthede.nition ofCPisintuitively clear: as far as later events are concerned, two con.icting events \nhave to occurin the same orderin everycorrectly-reordered execu\u00adtion. Thus, con.icting events induce \na hard ordering dependency, ifitis certainthattheydo not constitute a race(inthis case,be\u00adcause they \nareprotectedby a commonlock).Sincetwo critical sec\u00adtions overthe samelockhavetobe orderedintheir entirety(i.e., \nall eventsof onehavetoprecede all eventsof theother) theorder\u00adingconstraint on con.icting eventsbecomes \nan ordering constraint on the entire critical section containing them. The same reasoning applies toRule(b) \noftheCPde.nition:iftwo eventsinternalto respective critical sections are CP-ordered, then the entire \ncritical sections are alsoCP-ordered. Rule(c)is the mostinteresting aspect of theCPde.nition.The rule \nis both very conservative and surprisingly weak, in di.erent ways.Intuitively,Rule(c)isdirectly responsiblefor \nthe soundness ofCP:once some evidence ofinevitable event orderingisfound, all earlier andlater eventsin \nanHB order automatically maintain their relative order.This conservative aspect of theRuleis necessaryfor \nensuring that a CP race truly indicates that the events could have been concurrent.Atthe sametime,Rule(c)isquite \nweak.Consider three events e1, e2, e3. It could be that e1 \u00abCP e2, e2 \u00abHB e3, and consequently e1 \u00abCP \ne3. This still does not mean that e2 \u00abCP e3, eventhoughtheHB orderbetween e2 and e3is whatallows e1 toCP \ne3.This aspectis whatprevents CPfrom missing thepossibility of predictable races(asin e2-does-not-CP-e3)even \nwhen it assumes conservatively that certain reorderings are notpossible, in order to maintain soundness. \n3This pairing of a read with the most recent write event implicitly intro\u00adduces sequential consistency \nas an assumption. Nevertheless, this is not a constraint: Every HB race is a CP race. In case no HB races \nare observed for an execution, a relaxed memory model yields sequentially consistent behavior, thus our \nassumptionis valid. 3. ComplicationsandSoundness We discuss the subtleties of CP through examples of \nhard-to\u00adreason-about executions.Such examples naturallyleadto the state\u00adment of our soundness theorem \nanditsproof. 3.1 ExampleReasoning For each example, it is interesting for the reader to consider in\u00addependently \nwhether there is a predictable race or not. Reason\u00ading about concurrent executions is quite hard: even \nconcise exam\u00adples require exhaustive examination of a large number of possi\u00adble schedulings or complex \nformal reasoning to establish ordering properties.In thefollowingexamples, we expressed the constraints \nassymbolicinequalitieswithdisjunctions(e.g. thiseventiseither before that or after the other ) andproved \nmanually they were un\u00adsatis.able. Figure 5 contains a .rst example that suggests why sound pre\u00addictive \nrace detection is hard in the presence of many threads and nested locks. We use the shorthand sync(lock) \nfor a sequence of events that induces an inevitable ordering with other identical sync sequences. (E.g., \nsync(n) can be short for acq(n) r(nVar) w(nVar) rel(n).) For ease of reference, CP edges produced by \nRule(a) oftheCPde.nitionareshowninthe .gure,astwinar\u00adrows. Thread1 Thread2 Thread3 acq(m) sync(n) acq(l) \n  sync(n) w(x) rel(l)  sync(n) w(z) rel(m)  acq(m) r(z) w(z) rel(m) acq(l) rel(l) w(x) Figure 5. \nNo race between the two writes to x in any correctly reordered execution. Twin arrows show the hard CP \nconstraints, i.e.,CP orderbecause ofRule(a) oftheCPde.nition. sync(n) canbe thought of as acq(n) r(nVar) \nw(nVar) rel(n). There is no predictable race between the two writes to x in the above example: any correct \nreordering of the execution will have the three sync sequences and the critical sections over lock m \nordered in the way they were observed, resulting in an ordering ofthetwo writes.(Interestingly, the empty \ncritical section over l in Thread 3 is necessary, or there would be a predictable race.) TheCPde.nition \ncapturesthisreasoning accurately. Rule(b) is essential in establishing that the two critical sections \nover lock l areCP-ordered:because of rule(b),the end of the critical section over l in Thread 2 is CP-ordered \nrelative to the (empty) critical section over l inThread3.(SinceCP composes withHB toyield CP, the sync(n) \nevent in Thread 2 is CP-ordered with acq(l) in Thread3, thus triggering rule(b).) For anotherinteresting \nexample, considerFigure6. There is no predictable race on x in this example, but establishing this fact \nrequires case-based reasoning involving both the hard ordering constraints induced by sync sequences \nand the semantics  Thread 1 Thread 2 Thread 3 Thread 4 wr(x) acq(m) sync(o)sync(p)rel(m)      \n      acq(n) sync(q)  sync(o) rel(n)      acq(n) sync(r)   sync(p) rel(n)  acq(m) sync(q) \nsync(r) rel(m) wr(x) Figure6. Trace with nopredictableHB-race on x. andidentity oflocks(e.g.,thefact \nthatthe critical sections on n cannot overlap). CP avoids such reasoning but gives an accurate result. \nThe two critical sections on n are not CP-ordered, and also do notnecessarily occurinthe order shownin \na correctly reordered execution. The two critical sections on m,however, areCP-ordered and also necessarily \nin the order observed. Again, we see the interesting aspects ofRule(c) oftheCPde.nition:eventhough theHB \norderbetween the critical sections on n is what enables the CP order between the critical section on \nm, theformerdoes notget upgraded to aCP order. Figure7presents anotherhard-to-reason-about example. Thread1 \nThread2 Thread3 Thread4 w(x) acq(m) sync(n)sync(n)    acq(l) sync(n) rel(m) sync(r)  sync(o) rel(l) \nacq(m) sync(o)  sync(p) rel(m) w(x) sync(q)  acq(l) sync(p) sync(q) sync(r) rel(l) Figure7. Nopredictable \nracebetween the two writes to x. This executiondoes nothave apredictable race on variablex.Nev\u00adertheless, \nthe reasoning required to establish this fact can be quite complex. Removing events can easily result \nin a racy execution. For instance, removing the sync(r) edge allows a race by moving the entire set of \nactions by Thread 3 and Thread 4 before those of Thread1 andThread2. Detecting predictable races can \noften require complex reorder\u00adings ofevents.The value of apolynomialbut soundpredictive race detector \nis that it avoids exploring all such reorderings. Consider the case of Figure 8. There is a CP-race between \nthe two writes Thread 1 Thread 2 Thread 1 Thread 2 acq(m) acq(n) sync(o) acq(m) w(x) rel(m) acq(n) acq(m) \nrel(n) sync(o) rel(m) w(x) acq(n) w(x) acq(m) sync(o) rel(m) rel(n) w(x) acq(n) sync(o) rel(n) rel(n) \nrel(m) Figure 8. Exposing the HB race on x (execution on the left)re\u00adquires a complex reordering of \nevents(shown on the right). to variable x. There is also a predictable race. It is not possible to expose \nthis,however, without thread scheduling thatbreaks up the outercritical sections,asshownontherightpartof \nthe .gure.CP does not need to reproduce the schedule in order to warn of apos\u00adsible race. At the same \ntime, however, CP often avoids complex nested lock reasoning by not distinguishing between a predictable \nrace and a deadlock. Our soundness theorem has an interesting form: a CP-race is a sound indication of \neither a race or a deadlock in a correctly reordered execution. The deadlock is immediately apparent: \nthere is a cycle in the lock-blocking graph. To see this consider the example ofFigure9. Thread 1 Thread \n2 acq(m) acq(l) rel(l) Thread 1 Thread 2 w(x) acq(m) rel(m) acq(l) acq(l) acq(l) acq(m) acq(m) rel(m) \nw(x) rel(l) Figure9. The observedexecution(left)has aCP-racebetweenthe two writesto x.Thereis nopredictable \nrace,however!Instead,itis easy to reorder events to expose adeadlock(see right). There is a CP-race between \nthe accesses to variable x in this ex\u00adample. Yet there is no predictable HB race: no correctly reordered \nexecution can have the two write events without synchronization between them. The CP soundness theorem \nstates that this is only possible when a reordering can expose a deadlock due to threads acquiring locks \nin a way that introduces a cycle in the acquisition dependencies.  The above examples o.er the reader \na glimpse of the com\u00adplexities of de.ning CP and proving its soundness. The di.culty of reasoning about \nevent order highlights the challenge of de.n\u00ading a relation that weakens the observed ordering much more \nthan happens-before,yet atthesametimeisguaranteed tobesound.A race analysishas to eitherperformheavy \nreasoning or to conserva\u00adtively assume ordering every time events may be ordered. Rule(c) of the CP de.nition \nplays this role but it is still hard to prove that it is conservative enough. The ultimate conservative \nordering is of course HB: all critical sections are assumed to always beprecisely in the order they were \nobserved.  3.2 Soundness We now state morefullyour assumptions on the executionform, as well as our \nsoundness theorem. Our assumptions include the well\u00adnesting oflocks, as well as standardlock semantics. \nDe.nition5(Trace). A trace is a totalorder of events such that 1. Acquisition of a lock is not followed \nby another acquisition of the samelock without aninterveningpairedlock release. 2. Critical sections \nare well-nested. More explicitly, if an acqui\u00adsition of lock l2 is performed after an acquisition of \nlock l1 by the same thread and before l1 s paired release then the paired release of l1 cannot appearbeforethepaired \nreleaseof l2 does.  Our main soundness theoremhas a simple statement: Theorem 1(CP is Sound). Given \na trace tr with a CP-race, we canproduce a tr '' = CR tr with either anHB-race or adeadlock. Thefullproof \ncanbefoundin theAppendix. Note that the statement of the theorem applies only to one CP race.(And, since \n\u00abCP is a subset of \u00abHB, every HB-race is also a CP-race.) That is, the theorem proof establishes that \neither the .rst CP-race of a traceis anHB-racein some correct reordering ofthetrace or we canproduce \na correct reordering with adeadlock. (The idea of stating the soundness guarantee so that it applies \nto the .rst error reported is standard [21, 23].) The .rst race is the one that .nishes earliest in the \ntotal order of the trace, i.e., a CP\u00adrace between events e1 = [t1: u1]i and e2 = [t2: u2]j, with i < \nj, suchthatthatthereis noCP-racebetweentwo eventsboth of which appear before e2, as well as no race between \nevents e3-e2, with e3 appearing after e1 andbefore e2. Although the theorem s guarantee applies to only \none race, we can conservatively maintain soundness when reporting multiple races, at the cost of potentially \nmissing some. Speci.cally, once aCP-race(which maybe merely anHB-race) isdiscovered(and reported), the \nrest of the trace canbe treated asif theCP-race were aCP edge, thushard-ordering the two racy events.This \nmeans that the soundnessguarantee ofthetheoremthen appliestothe next CP\u00adrace reported:any correct reordering \nof arestricted trace(i.e.,one with extra CP edges) is a correct reordering of the original trace. The \ndrawback is that some CP-race nearby another CP race may notbe reporteddue to our conservative treatment. \nThe form of the soundness theorem is quite interesting. Al\u00adthough a CP race implies a predictable race \nonly in deadlock-free programs, this is hardly a disadvantage. Pointing out a potential deadlockis atleastasimportant \naspointing out races.Furthermore, deadlocks are arguablyan easierproblem todynamicallydetect, or statically \neliminate.Therefore we expectCP warnings tobe almost always(correct) race warnings. 4. Implementation \nCP reasoning, based on de.nition 2, is highly recursive. Notably, Rule(c) canfeedintoRule(b), which canfeedbackintoRule(c). \nAs a result, we have not implemented CP using techniques such as vector clocks, nor have we yet discovered \na full CP implemen\u00adtation that only does online reasoning (i.e., never needs to look back in the execution \ntrace); these remain challenging questions for future work. However, CP has an easy polynomial algorithm, \nderived directly from the de.nition. We express this algorithm in the Datalog language. (Datalog programs \nhave guaranteed poly\u00adnomial complexity,andDatalog canexpress anypolynomial algo\u00adrithm.) Consider a trace \nof execution expressed via the input re\u00adlations of Figure 10. We report errors of the form instruction \nX accessed memory location Y in a way that races with instruction Z . TraceNext[e1] = e2. // what is \nthe next event after e1 ThreadForEvent[e] = t. // what is the thread performing e AcqEvent[e] = m. // \ne is a lock acquire for mutex m RelEvent[e] = m. // e is a lock release for mutex m WriteEvent[e] = x. \n// e is a write for variable x ReadEvent[e] = x. // e is a read for variable x Figure10. Input relationsfor \nourDatalog algorithm. (Datalogcodenotation:A relationintheform Relation[arg] = value is afunction; theleft \narrow symbol, <-,istheimplication used for inference, i.e., if the right hand side is true, the left \nhand sidefactisinferred; ; isthelogical or operator.) We can then straightforwardly de.ne concepts such \nas critical sections , matching lock/unlock operations, etc. These are captured by relations InSameCriticalSec(e,eAcq) \n(event e is in the critical section starting at eAcq) and MatchingCriticalSecBoundary[eRel] = eAcq (event \neRel is the lock release paired with lock acquisition eAcq).This allows de.n\u00adingHBand eventuallyCP asinFigure11. \nCP(e1Rel,e2Acq) <\u00adMatchingCriticalSecBoundary[e1Rel] = e1Acq, RelEvent[e1Rel] = AcqEvent[e2Acq], InSameCriticalSec(e1,e1Acq), \nInSameCriticalSec(e2,e2Acq), (WriteEvent[e1] = WriteEvent[e2]; WriteEvent[e1] = ReadEvent[e2]; ReadEvent[e1] \n= WriteEvent[e2]). CP(e1Rel,e2Acq) <\u00adMatchingCriticalSecBoundary[e1Rel] = e1Acq, RelEvent[e1Rel] = AcqEvent[e2Acq], \nInSameCriticalSec(e1,e1Acq), InSameCriticalSec(e2,e2Acq), CP(e1,e2). CP(e1,e2) <-CP(e1,e3), HB(e3,e2). \nCP(e1,e2) <-HB(e1,e3), CP(e3,e2). Figure11. StraightforwardCPlogicinDatalog. Having a polynomial algorithm \nis not su.cient for scalability, however. Realistic executions can have millions of signi.cant shared \nmemory events. (Signi.cant events are those remaining after elimination of events that will not a.ect \nthe reporting of a race e.g., repeat accesses to the same shared memory variableby the same thread without \nintervening synchronization operations.) De.ning relations such as HB or CP on a cross-product of events \nis prohibitive. In our implementation we address this challenge in two ways: We computequadratic relations,such \nasHB orCP, only onlock acquisition and release events.TheHB andCP order on regular memory events is then \ncomputed on-demand based on the HB and CP order of preceding/following synchronization events. Thisis \nalready shownin the code ofFigure11.  WedonotfullycomputeHB orCP,butinstead maintaina .nite window K \nof alloweddistancefor event reorderings(typically 500 or1000 signi.cant shared memory events). HB(e1,e2) \nand CP(e1,e2) are guaranteed to be conservatively computed for endpoints e1 and e2 less than K signi.cant \nevents apart. This windowing strategy e.ectively makes our race detection often be of practically linear \ncomplexity: we only relate every event with at most K others.4 (Our implementation does have some remaining \nO(n 2)orhigher asymptotic complexityparts,butfor relations that are expected to be small. A notable exception \nin practiceislong critical sections,for which wehave to relate all events to all others, thus su.ering \nquadratic complexity.) The windowing strategy also means that our algorithm will only detect and report \nraces between events less than K signi.cant events apart. OurcomputationofCPforonlya .nitewindowisimplemented \nby computing a relation FollowingNearbyEvent and various spe\u00adcializations of it (for nearby events by \nthe same thread, nearby synchronization actions, etc.). These relations are then threaded throughout \ntheimplementationto restrictcomputations that require examination of every pair of events. Importantly, \nthis means that our mainimplementationlogicdi.ersfromthe simpleform ofFig\u00adure11. Inparticular,allrulesneedtobothhavea \n.lter(sothat they trigger accurate computation only when events are within a distance of K)as well as \na conservative closure(sothat a sound overapproximation of CP is computed when there is a possibility \nof missing anorderingduetothe .nitewindow).Thisiswellillus\u00adtratedbylooking attheform ofthe second rule \noftheCPde.nition, which is also the second rule in Figure 11. In the implementation the ruleisbroken \nupin two: // the version for when CP is accurate CP(e1Rel,e2Acq) <\u00adMatchingCriticalSecBoundary[e1Rel] \n= e1Acq, RelEvent[e1Rel] = AcqEvent[e2Acq], InSameCriticalSec(e1,e1Acq), InSameCriticalSec(e2,e2Acq), \nCP(e1,e2), FollowingNearbySynchronizationEvent(e1,e2). // the version for conservative CP when the // \nbase CP information may be inaccurate CP(e1Rel,e2Acq) <\u00ad MatchingCriticalSecBoundary[e1Rel] = e1Acq, \nNearbyCriticalSecOnSameLock(e2Acq,e1Rel), InSameCriticalSec(e1,e1Acq), InSameCriticalSec(e2,e2Acq), SynchronizationEvent(e1), \nSynchronizationEvent(e2), !FollowingNearbySynchronizationEvent(e1,e2). This approach allows us to maintain \nsoundness while achieving scalability.Additional optimizationsin ourimplementationinclude manual indexing \nfor e.cientrelationaljoins,aswell asjoin order optimizations. 5. Experiments Weevaluated theperformance \nandpredictioncapability of ourCP race detector on a collection of multithreaded Java benchmarks, mostlyfromprevious \nstudies[12,17,54]). 4One may argue that even an exponential search algorithm can become linear by limiting \nits search space to a .nite window, but the constants (space and time overhead) would be prohibitive \nin that case. Our limit\u00ading theaccurate-CP-computation windowispractically feasibleexactlybe\u00adcause computing \nCP has a reasonable asymptotic complexity in the .rst place. The most substantial of ourbenchmarks are: \n Jigsaw,W3C s web server[53], coupled with a stresstesthar\u00adness.  FtpServer, a high-performance FTP \nserver implementation from The Apache Foundation [51], coupled with a JMeter workload[52].  StaticBucketMap, \na part of the Apache Commons project, of\u00adfering a thread-safe implementation of the Java Map interface. \nThe code size ofthisbenchmarkis small,butitsdriver exercises it thoroughly, resultingin along trace. \n To perform the CP analysis on the benchmarks, we used the RoadRunner framework[22] to dynamically instrument \nthe byte\u00adcode of each benchmark at load time. The instrumentation code creates a stream of events for \n.eld and array accesses, synchro\u00adnization operations, threadfork/joins, etc. We used thisinfrastructure \ntoperform aninexpensive happens\u00adbeforeraceanalysisand toalsoproduce atracesubsequently used for the CP \nanalysis. The CP analysis was thus explicitly coded to report races if they were not also HB races (since \nthe latter werediscovered and reported already).We conservatively translate accesses to volatile variables \nand thread creation/join events into pseudo-lock accesses. The traces produced are quite sizable even \nthough stack-variable references are .ltered out. The traces are then reduced to only maintain events \nconcerning shared memory locations, and to eliminate re-accesses to the same variable by the same thread \nwithout intervening synchronization. The reduced trace is then imported into a database and analyzed \nusing our Datalogimplementation. The .rst columns of Table 1 show the main metrics for our benchmarks. \nThe benchmark size in LoC is not entirely represen\u00adtative ofits complexityfor our analysis: much of the \ncodein apro\u00adgram s directory is library code, not exercised at all. Conversely, much of the code actually \nexercised is Java library code, never showninthebenchmark size.(Library codeis still valuable to ana\u00adlyze: \nthe code may not contain races,but maybe usedin an unsafe way, exposing a race in client code.) StaticBucketMap \nis the most extreme example:if we were to reportits code size uniformly with the other benchmarks, it \nwould come to 110KLoC. The directory containsthe entireApacheCommonsCollectionsproject,however. ThemainStaticBucketMap \nclassandtestdriver .learejust807 LoC.Neither of the two sizesis representative of the code actually exercised, \nthough the second is closer.Similar caveats apply to the report of thread counts.This metriclists the \ntotal number of thread created, which can be higher than the number of threads active si\u00admultaneously. \nTable 1 collects the results of our experiments. We use a high\u00adperformance commercial Datalog engine \nby LogicBlox Inc., on academiclicense.All analysis wasdone on a machine with aDual Six Core Intel Xeon \nX5650, 2.66GHz Processor and 24GB of RAM.(TheCP analysisimplementationis single-threaded,hence only one \ncore was active at atime.)WeperformedCP analysis with the reordering window K = 500 signi.cant events, \nas described in Section 4. We report the races found in a single HB run, in 10 HB runs, as well as the \nraces found by CP in its single run but never found in the 10 HB detector runs. Races are reported per\u00advariable(i.e.,dynamic \nraceinstances are collapsedbased on which data words they occur on).Still, multiple races may have the \nsame underlying cause(e.g.,a single missing lock/unlock may .x more than one race). Furthermore, recall \nthat our soundness guarantee only applies to the .rst race and ensuring that all race reports are sound \nrequires post-processing (which we currently perform manually and requires multiple re-runs of our analysis). \nFor these reasons, the number of races and running times should be viewed  TraceSize RaceConditions \n(#events) Detected        banking 145 762 522 10 1 1 +0 10s elevator 1.4k 25k 16k 5 0 0 +0 \n38s FtpServer 39k 992k 543k 11 21 27 +7 20m06s hedc 25k 102k 1.4k 6 5 5 +0 9s Jigsaw 49k 1,992k 42k \n77 18 33 +3 17s philo 86 669 382 6 0 0 +0 10s pool1.2 8.4k 692 526 8 0 0 +0 10s pool1.3 24k 841 683 \n8 0 0 +0 12s StaticBucketMap see text 265k 133k 5 7 7 +0 1m35s stringBu.er 1.4k 223 178 8 0 0 +0 9s \ntsp 706 328k 381 4 0 0 +0 9s vector 26k 325 270 15 1 1 +0 9s        Table 1. Benchmark metrics \nand number of races detected by our CP analysis but not found in 10 HB runs, as well as time taken for \nCP analysis.Running times of9sec are e.ectively zero:thisistheoverhead ofinitializingtheDatalog engineandimportingdatafromtext \n.les. only as animperfectproxy of theutility of our approach.Alikely way our analysis wouldbe usedby \naprogrammerinpractice would be not to report all races, but by analyzing a trace, .xing the .rst racein \nthe code, then re-analyzing. The results are representative of the position of our approach relative \nto others.As canbe seeninTable1,8 of thesebenchmarks (i.e., two-out-of-three) produce tiny reduced traces \n(fewer than 2,000 events, with 7 of them having fewer than 1,000). These brief executions o.er little \nopportunity to detect HB races and virtually no opportunity to correctly reorder events: For all of the \ntiny traces, CP does not discover any races that are not HB races. Nevertheless, a lockset-based approach \nwould report races even for these executions, since it is easy to observe when a shared variable is accessed \nby a di.erent thread with a disjoint set of locks held. This illustrates quite well how unsound, lockset-based \nrace detectors tackle a fundamentally di.erent problem. Unsound predictive analyseshighlight possible \nrace conditions, whereas our workfocuses on proving thepresence of race conditions. Elevator is another \nbenchmark thatis mostly uninteresting. Al\u00adthough its trace is longer than the tiny ones, it is still \nfairly short (16kevents), andhas neitherHB norCPraces.ThejPredictor study [12]and theSaid et al. work[40] \nshowed no races on elevator ei\u00adther,despiteusing anunsoundlockset-based analysis and anSMT solver that \nexplores all valid trace reorderings, respectively. The real benchmarks for our approach are the three \nlonger traces:FtpServer,Jigsaw, andStaticBucketMap. Itisinstructive to compare results with HB. Clearly \nHB race detection and CP race detection aredi.erentin nature.The cost of our currentCP analysis is at \nleast one-to-two orders of magnitude higher than the cost of HB race detection. Nevertheless, the goal \nof CP is to perform a deep analysis,implicitly considering event reorderings,and to .nd hard races, which \naplainHB analysis would not normallydetect. For both FtpServer and Jigsaw, CP-based race detection uncovers \nseveral races that were not exposed by any of the 10 happens\u00adbefore race detector runs. This ranges from \n3 to 7, or an average of 17% new races for these two benchmarks, con.rming that CP race detection can \ntarget deeper races than typical HB detectors. Examining the intermediate results of our analysis indicates \nthat CP is a much weaker relation than HB: the number of CP edges computedby ouranalysis(among synchronization \noperations) is typicallyaslow as10%to20% ofthe number ofHBedgesforthese benchmarks. Thus, happens-before \nrace detection often considers events to be ordered when there is no semantic reason why they shouldbe. \nStaticBucketMap is our .nal benchmark. It has a long execu\u00adtion, covering very little code, thus CP only \nreports races also de\u00adtected by HB. This is the inverse problem from that of the tiny traces: CP does \nnot win over HB not because of insu.cient cov\u00aderagebutbecause of too-thorough coverage of thepossibleexecu\u00adtions. \nIt would be interesting in the future to perform a sensitivity analysis and create runs of several sizes,bothforStaticBu.erMap, \nas well as for the 9 programs with smaller traces, to see at what pointCPstartsdetecting more racesthanHB \nand whenHB catches up.This requires extensiveknowledge ofthebenchmarkprograms, however. The table also \nshows that the time required for CP analysis is quite low, although there is certainly room for further \nimprove\u00adment of our CP implementation. For small traces, CP analysis is almost instantaneous. For traces \nwith long critical sections, many threads, and deep lock nesting, the analysis time grows. Still, the \noverall scalability ofCP analysis far exceeds reported numbers for pastsoundpredictive concurrency analysesintheliterature.Forin\u00adstance,Said \net al. sSMT-solver-basedtechnique[40]takes57secto analyze a1.4k eventhedctrace.(Thelongesttrace analyzedbySaid \net al. is much smaller than ours, at 45k events long. Yet even this size may be misleading, since the \ntrace is for tsp, which performs a tiny number of thread-shared events relative to the original trace \nlength.) We are not aware of a sound predictive analysis that can scale to executions at the level of \nour reactive applications Jigsaw andFtpServer with a running timein thelow minutes. 6. RelatedWork Our \napproachisdistinguishedfrom other relatedworkby(1) main\u00adtainingprecisionwhilegeneralizing beyond anobserved \ntraceand (2)guaranteeingpolynomialcomplexity and achieving scalability. Wediscussotherprecisepredictiveand \notherdynamic approaches in some depth, and brie.y overview other race detection tech\u00adniques. 6.1 PredictiveApproaches \nThe most relevant work to our precise race prediction tech\u00adnique[10 12,40,46] wasbrie.ydiscussedinSection1 \nandSec\u00adtion5.Such workis typically ahybrid of testing and model check\u00adinganddoes not achieve thepolynomial \ncomplexity and scalability of causally-precedes racedetection.Forinstance,intherecent work bySaidet al.[40] \nscalability relies on a modernSMT solver and an e.cient encoding oftheproblem.Anotherinterestingideathatpast \nwork[10,11]has explored is sliced causality, which makes use of apriori control-anddata-.owdependence \ninformation to obtain a reduced slice ofthehappens-beforepartial orderingfor aparticular observed trace. \nRace conditions are predicted with sliced causal\u00adity by logging only the relevant operations in a program \ntrace and model-checking all feasible trace permutations in a post-mortem analysisphase.Thesepermutations \nare soundbecause one mayin\u00adfer andignoreirrelevant operations via staticdependence informa\u00adtion; the \nsoundness of the predictions follow from the soundness of the trace permutations generated. Sliced causality \nrequires two static analysisphasesforprediction.This approach candetect races that our approach does \nnot: recall that our correctly-reordered exe\u00adcution always respects intra-thread event order.However, \nour de.\u00adnition of causalityis explicitlygeared towards mechanisms thatdo notperform staticprogram analysis, \nand, thus, cannot tell whether a value read by a thread in.uences subsequent values produced by the same \nthread. Adapting our causally-precedes order to also take suchdependencesinto account(instead of assuming \nthat ev\u00adery value read by a thread a.ects all subsequent thread actions) is orthogonal to the coreproperties \nof thede.nition.  Amongthis work,thejPredictortool[12]isdistinguishedbyex\u00adplicitlyproducing apolynomial \nalgorithmforracedetection.Nev\u00adertheless,in order todo so,jPredictor abandons thegeneral sound\u00adnessguarantees \nof the theory that underliesit.The main soundness theorem ofthejPredictor work(which appliesto morethan \nracede\u00adtection) statesthateveryproduced consistentpermutation corre\u00adspondstoapossibleprogramexecution.Nevertheless, \ngenerating all the consistent permutations of a partial order is a #P-complete problem [12].To avoidan \nexponential search,jPredictor employs two shortcuts for the case of race detection. The .rst is avoiding \na search ofpermutations: events areprocessed following the order of the original execution.Forpredictivepower,jPredictor \nrelies on an unsoundde.nition of what constitutes a race(Def.5 of[12]). Thede.nition adapts(to sliced \ncausality) thelockset criterionfor racedetection:two con.icting, sliced causality-unordered accesses \nthat occur without holding a common lock are considered to race. The examples ofSection3(assumingaprogramtextthat \ncausesthe events in the order shown, under the sliced causality criterion) re\u00adsultinfalseracereports \nunderthisde.nition.Thesecond shortcut is in the implementation, which performs a single slicing traversal \nof the trace, also resultingin unsoundness. Another interesting predictive approach consists of reordering \nmodels that are more permissive than our correctly-reorders rela\u00adtion on executions.Past work[20,27] \nassumes that threads only communicate viaholdinglocks, and notby writing to shared mem\u00adory locations. \nAny trace that holds the same locks in the same or\u00adder of nesting is considered an appropriate generalization \nof the observedbehaviorinthatpredictive model.ThePenelope[49] sys\u00adtem then adds soundness backby trying \nto reproduce thepredicted atomicity violation through changes to the scheduling of a real ex\u00adecution. \nThe published experiment numbers imply that their ap\u00adproachdoes notscaleatornearthelevel ofCP racedetectionand \ncan su.er from high costs in small yet complex executions. Nev\u00adertheless, there cannot be a valid comparison \nsince Penelope is an atomicity violationdetector and not a racedetector(thus addressing an inherently \nharder problem). Combinations of approaches along theselines shouldbeinterestingfuture work.  6.2 DynamicAnalysis \nHappens-Before Approaches Numeroustools arebasedonLam\u00adport s happens-before relation [14, 21, 37, 43]. \nThese tools are more precise than lockset-based race detectors, but are often less e.cient.TRaDE[14] \nuses accordion clocks along withdynamic escape analysistoboostperformance.Banerjee et al.[5] provide \nanalternativealgorithmtothesimplehappens-before analysisthat uses a linear amount of storage. Happens-before \nrace detectors have also been applied to nested fork-join parallelism [32]. The djit + [37]algorithm \nis an e.cient happens-before vector clock al\u00adgorithm that uses the epoch optimization for a 2-3x performance \nimprovement. FastTrack [21] improves upon djit + by using an adaptivelightweight representationfor thehappens-before \nrelation andbyintroducing optimized constant-timefastpaths that account for approximately 96% of operations \nencountered in a trace, and provides a2.3xperformanceimprovementover djit +.Pacer[7]im\u00adproves on the \nperformance further by employing sampling tech\u00adniques. Lockset Approaches A lockset for a shared variable \nis the set of locks that protect access to that variable. Locksets were intro\u00adduced[15] as an alternative \nrepresentation tothehappens-before analysis. Later, locksets were used alone as an e.cient technique \nfordata racedetectioninEraser[42]. Every CP race (and hence every HB race) is also a lockset race, since \nthe absence of a CP edge between con.icting accesses to a location means that there is no consistently \nheld protecting lock for that location. Consequently, a lockset-based race detector would detect all \nraces detected by CP,5 and may also report many additional warnings.Inpractice, many of these extra warnings \nare false alarms thatdo not correspond to actual races. Various re.nements and extensions for Eraser \nhave been pro\u00adposed. Static escape analysis can improve performance [35, 55]. Reasoning about races at \nthe object level instead of the mem\u00adory wordlevel[55] improvesperformancebutleadstomorefalse alarms.Thelocksettechnique \nwas also extended withtiming thread segments [25] to reduce false positives caused by data not being \nprotected by a lock during an initialization phase. Further perfor\u00admance enhancements use whole-program \nstatic analysis to reduce the amount ofinstrumentation necessary[13] orinvolve typein\u00adference[2].Eraser \ns algorithmhas alsobeen extended for theJava MemoryModel[31] andimplemented withAspectJ[6]. Hybrid Techniques \nRecent work on dynamic data race detec\u00adtion focuses on combining locksets and happens-before analy\u00adsis.O \nCallahan andChoi[36] developed atwo-phaselocalization scheme; a .rst pass lockset analysis .lters out \nproblematic .elds for a second pass hybrid analysis. RaceTrack[61] uses a happens\u00adbefore analysisto estimate \nwhetherthreads can concurrentlyaccess a memorylocation so as to reduce falsepositives caused by empty \nlocksets.MultiRace[38] presentsimproved versions ofhappens\u00adbefore andlockset algorithms.Locksets enablehappens-before \nap\u00adproaches to report additional warnings and reduce the number of vector clock comparisons needed in \nthe happens-before analysis. Goldilocks[17] combineslocksets andhappens-beforein an un\u00adusual wayby usinglocksets \nto e.ciently track thehappens-before relation. This precise, complicated analysis is embedded in a Java \nvirtualmachinetoenable continuous monitoring of raceconditions.  6.3 OtherApproaches Several static \napproaches exist to deal with data races. Type sys\u00adtems[1,8,24,41] andlanguages[4]havebeenproposed toprevent \nracesinprograms. Other static approachesincludeWarlock[50] andLocksmith[39]forANSICprograms, scalable \nwhole-program analyses[34,56] anddata.ow-analysis-based approaches[16,19]. Aiken andGay[3]alsoinvestigate \nstatic racedetectionfocusing on SPMDprograms. Scheduler-driven approaches, such asmodel checking[33],in\u00advolve \nrunning thetargetprogram with manydi.erentthread sched\u00adules, either concretely or symbolically.RaceFuzzer[44] \ntakespo\u00adtentially racing access pairs and uses a randomized scheduler to 5Note that the Eraser algorithm, \nwhich incorporates lockset-based reason\u00ading, is also slightly incomplete in how it reasons about thread-local \ndata, and so may miss some realHB orCP races.  drive the execution to exhibit an actual race condition. \nIt would be interesting to try to combine such techniques with our approach, which is explicitly geared \ntowards discovering hard races with\u00adout exploring many complexinterleavings. 7. Conclusions Precise race \ndetectors are important tools for developing reliable multithreaded programs, while avoiding the costs \nassociated with false alarms. We showed how to extend the traditional notion of race detection to also \nsupport race prediction, without sacri.cing scalability or soundness. Our work introduces the novel concept \nof the causally-precedes relation, which signi.cantly weakensHB. We prove that CP race detection is sound \nand demonstrate its practical value. De.ning and proving the soundness of CP was far from trivial: both \ntasks became possible only after several failed attempts and signi.cant collaborative work. We believe \nthat our research can open several avenues for fur\u00adther work.First,itisquitepossible that a more e.cientimplemen\u00adtation \nofCP canbederived, topushperformancefurtherby atleast an order of magnitude and evenbringittolevels comparabletoHB. \nSuchadevelopment may,forinstance,bebased on a novel summa\u00adrization ofCPinformation using vector clocks, \nor on the use ofBi\u00adnary Decision Diagrams to represent Datalog relations.(We could try thebddbddb engine[60] \nforthispurpose.) A secondpossibil\u00adity is that of de.ning other relations that weaken HB in a sound yete.cient \nway.Finally, we suspect the underlying notion of trace prediction, based on the causally-precedes relation, \nmay also pro\u00advide bene.ts when checkingproperties such asdeadlock-freedom, atomicity, anddeterminism. \nAcknowledgments WewouldliketothankAartiGupta and theanonymous reviewers fortheirvaluablecommentsthathelped \nstrengthenthepaper.This work wasfundedby theNationalScienceFoundation undergrants CCF-0917774, CCF-0934631, \nand CCF-1116883. We thank Log\u00adicBloxInc.forproviding theplatform usedfor ourimplementation andfor continuous \nsupport. References [1] M. Abadi, C. Flanagan, and S. N. Freund. Types for safe locking: Static race \ndetection for Java. Transactions on Programming Lan\u00adguages andSystems(TOPLAS),28(2):207 255, 2006. [2] \nR.Agarwal,A.Sasturkar,L.Wang,andS.D.Stoller. Optimized run\u00adtime race detection and atomicity checking \nusing partial discovered types. In International Conference on Automated Software Engineer\u00ading(ASE),2005. \n[3] A.Aiken andD.Gay. Barrierinference. In Symposium onPrinciples ofProgramming Languages(POPL),1998. \n[4] D. F. Bacon, R. E. Strom, and A. Tarafdar. Guava: a dialect of Java without data races. In Object-Oriented \nProgramming, Systems, Languages, andApplications(OOPSLA),2000. [5] U. Banerjee, B. Bliss, Z. Ma, and \nP. Petersen. A theory of data race detection. In Workshop on Parallel and Distributed Systems: Testing, \nAnalysis, andDebugging(PADTAD),2006. [6] E.BoddenandK.Havelund.Racer: e.ective racedetection usingAs\u00adpectJ. \nIn International Symposium on Software Testing and Analysis (ISSTA),2008. [7] M.D.Bond,K.E.Coons,andK.S.McKinley. \nPACER:proportional detection of data races. In Conference on Programming Language Design and Implementation(PLDI),2010. \n[8] C.Boyapati,R.Lee,andM.Rinard.Atypesystemforpreventingdata races anddeadlocksinJavaprograms. In Object-Oriented \nProgram\u00adming,Systems,Languages, andApplications(OOPSLA),2002. [9] F. Chen and G. Ros\u00b8u. Predicting concurrency \nerrors at runtime using sliced causality. Technical Report UIUCDCS-R-2006-2965, Department of Computer \nScience, University of Illinois at Urbana-Champaign, 2006. [10] F. Chen and G. Ros\u00b8u. Parametric and \nSliced Causality. In Computer Aided Veri.cation(CAV),2007. [11] F. Chen, T. F. S\u00b8erb.anut\u00b8.a, and G. \nRos\u00b8u. E.ective predictive runtime analysis using sliced causality and atomicity. Technical Report UIUCDCS-R-2007-2905, \nUniversity of Illinois at Urbana-Champaign, Department ofComputerScience, October 2007. [12] F.Chen,T.F.S\u00b8erb.anut\u00b8.a,andG.Ros\u00b8u. \njPredictor: apredictive run\u00adtime analysis tool for Java. In International Conference on Software Engineering(ICSE),2008. \n[13] J.-D.Choi,K.Lee,A.Loginov,R.O Callahan,V.Sarkar,andM.Srid\u00adhara. E.cient andprecisedataracedetectionfor \nmultithreaded object\u00adoriented programs. In Conference onProgrammingLanguageDesign and Implementation(PLDI),2002. \n[14] M.ChristiaensandK.D.Bosschere.TRaDe:DataRaceDetectionfor Java. In InternationalConference onComputationalScience, \n2001. [15] A.DinningandE.Schonberg.Detecting accessanomaliesinprograms with critical sections. SIGPLANNotices,26(12):85 \n96, 1991. [16] M. B. Dwyer and L. A. Clarke. Data .ow analysis for verifying properties of concurrent \nprograms. In International Symposium on Foundations ofSoftwareEngineering(FSE),1994. [17] T. Elmas, S. \nQadeer, and S. Tasiran. Goldilocks: a race and transaction-aware Java runtime. In Conference onProgramming \nLan\u00adguageDesign andImplementation(PLDI),2007. [18] M.Emmi,S.Qadeer, andZ.Rakamari\u00b4c. Delay-bounded scheduling. \nIn Symposium on Principles of Programming Languages (POPL), 2011. [19] D. R. Engler and K. Ashcraft. \nRacerX: E.ective, static detection of race conditions and deadlocks. In ACM Symposium on Operating Systems \nPrinciples(SOSP),2003. [20] A.Farzan,P.Madhusudan,andF.Sorrentino.Meta-analysisforatom\u00adicity violations \nunder nested locking. In Computer Aided Veri.cation (CAV),2009. [21] C. Flanagan and S. N. Freund. FastTrack: \ne.cient and precise dy\u00adnamic race detection. In Conference on Programming Language De\u00adsign andImplementation(PLDI),2009. \n[22] C. Flanagan and S. N. Freund. The roadrunner dynamic analysis framework for concurrent programs. \nIn PASTE,pages1 8,2010. [23] C. Flanagan, S. N. Freund, and J. Yi. Velodrome: A sound and complete dynamic \natomicity checker for multithreaded programs. In Conference on Programming Language Design and Implementation \n(PLDI),2008. [24] D. Grossman. Type-safe multithreading in Cyclone. In Workshop on TypesinLanguageDesign \nandImplementation(TLDI),2003. [25] J. J. Harrow. Runtime checking of multithreaded applications with \nvisual threads. In InternationalSPINWorkshop onModelChecking of Software,2000. [26] D. P. Helmbold, C. \nE. McDowell, and J. zhong Wang. Detecting data races by analyzing sequential traces. In HICCS-24, Hawaii \nIntl. Conference onSystemSciences(HICCS-24),1990. [27] V.Kahlon,F.Ivan.ci\u00b4c,andA.Gupta. Reasoning aboutthreadscom\u00admunicating \nvialocks.In Computer AidedVeri.cation(CAV),2005. [28] V. Kahlon and C. Wang. Universal causality graphs: \nA precise happens-before model for detecting bugs in concurrent programs. In Computer AidedVeri.cation(CAV),2010. \n[29] S.K.Lahiri,S.Qadeer,andZ.Rakamari\u00b4c.Staticandprecisedetection of concurrency errorsin systems code \nusing smt solvers. In Computer Aided Veri.cation(CAV),2009. [30] L. Lamport. Time, clocks, and the ordering \nof events in a distributed system. Communications of theACM,21:558 565,July1978. [31] J. Manson, W. Pugh, \nand S. V. Adve. The Java memory model. In Conference on Programming Language Design and Implementation \n(PLDI),2005. [32] J. M. Mellor-Crummey. On-the-.y detection of data races for pro\u00adgrams with nestedfork-joinparallelism. \nIn Supercomputing, 1991. [33] M. Musuvathi, S. Qadeer, T. Ball, G. Basler, P. A. Nainar, and I. Neamtiu. \nFinding and reproducing heisenbugs in concurrent pro\u00ad  grams. In Operating Systems Design and Implementation \n(OSDI), 2008. [34] M. Naik, A. Aiken, and J. Whaley. E.ective static race detection for Java. In Conference \non Programming Language Design and Implementation(PLDI),2006. [35] H. Nishiyama. Detecting data races \nusing dynamic escape analysis based on read barrier. In Virtual Machine Research and Technology Symposium(VM),2004. \n[36] R. O Callahan and J.-D. Choi. Hybrid dynamic data race detection. In Symposium on Principles and \nPractice of Parallel Programming (PPoPP),2003. [37] E.PoznianskyandA.Schuster.E.cient on-the-.ydata racedetection \nin multihreaded C++ programs. In Symposium on Principles and Practice ofParallelProgramming(PPoPP),2003. \n[38] E. Pozniansky and A. Schuster. Multirace: e.cient on-the-.y data race detection in multithreaded \nC++ programs. Concurrency and Computation:Practice andExperience, 19(3):327 340, 2007. [39] P.Pratikakis,J.S.Foster,andM.Hicks.Context-sensitive \ncorrelation analysisfordetecting races.In Conference onProgrammingLanguage Design and Implementation(PLDI),2006. \n[40] M. Said, C. Wang, Z. Yang, and K. Sakallah. Generating data race witnesses by an smt-based analysis. \nIn NASA Formal Methods Sym\u00adposium,pages313 327.Springer, 2011. [41] A. Sasturkar, R. Agarwal, L. Wang, \nand S. D. Stoller. Automated type-based analysis of data races and atomicity. In Symposium on Principles \nandPracticeofParallelProgramming(PPoPP),2005. [42] S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, and \nT. Anderson. Eraser: a dynamic data race detector for multi-threaded programs. In ACMSymposium onOperating \nSystemsPrinciples(SOSP),1997. [43] E. Schonberg. On-the-.y detection of access anomalies. In Confer\u00adenceonProgramming \nLanguageDesign andImplementation(PLDI), 1989. [44] K. Sen. Race directed random testing of concurrent \nprograms. In Conference on Programming Language Design and Implementation (PLDI),2008. [45] K. Sen and \nG. Agha. Detecting errors in multithreaded programs by generalized predictive analysis of executions. \nIn IIFIP International Conference on Formal Methods for Open Object-Based Distributed Systems(FMOODS),2005. \n[46] K. Sen, G. Rosu, and G. Agha. Online e.cient predictive safety analysis of multithreadedprograms. \nInternationalJournalonSoftware Technology andToolsTransfer(STTT),8(3):248 260, 2006. [47] T.F.S\u00b8erb.anut\u00b8.a,F.Chen,andG.Ros\u00b8u. \nMaximal causal modelsfor multithreaded systems. Technical Report UIUCDCS-R-2008-3017, University ofIllinois \natUrbana-Champaign, Department ofComputer Science,December 2008. [48] N. Sinha and C. Wang. On interference \nabstractions. In Symposium onPrinciples ofProgrammingLanguages(POPL),2011. [49] F.Sorrentino,A.Farzan, \nandP.Madhusudan. PENELOPE: weaving threads to expose atomicity violations. In International Symposium \non Foundations ofSoftwareEngineering(FSE),2010. [50] N. Sterling. Warlock: A static data race analysis \ntool. In USENIX Winter Technical Conference, 1993. [51] The Apache Software Foundation. Apache FtpServer. \nAvailable at http://mina.apache.org/ftpserver/,2009. [52] The Apache Software Foundation. Apache JMeter. \nAvailable at http://jakarta.apache.org/jmeter/,2009. [53] The World Wide Web Consortium. Jigsaw Web Server. \nAvailable fromhttp://www.w3.org/Jigsaw/,2009. [54] C.vonPraun andT.Gross. Static con.ict analysisformulti-threaded \nobject-oriented programs. In Conference on Programming Language Design and Implementation(PLDI),2003. \n[55] C. von Praun and T. R. Gross. Object race detection. In Object\u00adOrientedProgramming,Systems,Languages, \nandApplications(OOP\u00adSLA),2001. [56] J. W. Voung, R. Jhala, and S. Lerner. Relay: static race detection \non millions oflines of code. In InternationalSymposium onFoundations ofSoftware Engineering(FSE),2007. \n[57] C. Wang, S. Kundu, M. Ganai, and A. Gupta. Symbolic predictive analysis for concurrent programs. \nIn World Congress on Formal Methods(FM),2009. [58] C.Wang,R.Limaye,M.Ganai, andA.Gupta. Trace-based symbolic \nanalysis for atomicity violations. In Tools and Algorithms for the Construction andAnalysis ofSystems(TACAS),2010. \n[59] L.WangandS.D.Stoller.Accurateand e.cient runtimedetection of atomicity errorsinconcurrentprograms. \nIn Symposium onPrinciples and Practice ofParallelProgramming(PPoPP),2006. [60] J. Whaley. Context-Sensitive \nPointer Analysis using Binary Decision Diagrams. PhD thesis,Stanford University,Mar.2007. [61] Y.Yu.RaceTrack:E.cientdetection \nofdataraceconditionsviaadap\u00adtive tracking. In ACM Symposium on Operating Systems Principles (SOSP),2005. \nAppendix:SoundnessProof Theorem(CPisSound). Given a trace tr with aCP-race, we can produce atr '' = CR \ntr with either anHB-race or adeadlock. Proof. Letthe .rstrace oftrace tr bebetween eventse1 and e2,with \ne1 appearing before e2 in the trace. Being the .rst race means that thereisnoCP-racebetweentwo eventsbothof \nwhich appearbefore e2, as well as no racebetween events e3-e2, with e3 appearing after e1 andbefore e2. \nConsider a trace tr ' such that: tr ' = CR tr and tr ' hasthesame .rstCP-raceas tr,i.e.,between events \ne1 = [t1: u1]i and e2 = [t2: u2]j, with i < j.(With i and j theindices of the eventsin trace tr ' .) \n Among traces satisfying the above property, tr ' has minimal distance j - i between events e1 and e2 \nof the .rst CP-race. (Intuitively, this means that all irrelevant events betweene1 and e2 are correctly-reordered \nout of the e1-e2 segmentintrace tr ' .)  Among traces that satisfy the above properties, tr ' is one \nthat also minimizes thedistance between e2 and everybeginning of a critical section containing e1, from \ninnermost to outermost. That is, among tracesthathavethe same(minimal) distancebetween e2 and the innermost \nacquisition event k1 for a critical section containing e1, tr ' minimizes the distance between e2 and \nthe second such lock acquire, among those satisfying all the above tr ' minimizes the distance between \ne2 and the third such lock acquire, k3, and so on, allthe waytothe outermost critical section containing \ne1.  We will refer to the last two requirements as the minimality prop\u00aderty.For such a trace tr ' , \nwegetimportantlemmas: Lemma1. Allevents e between e1 and e2 are such that (a) e1 \u00abHB e and e \u00abHB e2 \n(b) e1 <CP e and e <CP e2. Proof. Weprove each case separately. (a) Assume e <HB e2. Then we can move \ne and all events e ' that occur between e and e2 such that e \u00abHB e ' to the point right after e2.The \nresult ofthe move maintainsprogram order. (Note that threadt2 is not a.ected by the move at all, since \nwe have already assumed that e <HB e2, therefore e cannot happen-before anyprevious eventin t2.)If this \nmove(or any move in later proofs) is not possible it is because of one of two reasons:  It causes the \nresult to not be a trace because the pairing oflock acquisition/releasesbecomesinvalid(i.e., alockis \nacquired whileheld).  The result is a valid trace t but t *CR tr ' because a read now sees adi.erent \nwritten value. Theformer means thatthe movedeventshave a commonlock with some non-moved event(say, f)that \noccurs before e2 an impossibility since in this case e \u00abHB f, hence f would be a moved event. The latter \nreason is also an impossibility since then a moved event would con.ict with a non-moved event, f.If the \ntwo events were CP-ordered, then they would alsobeHB ordered,hence f wouldhave moved.If the events were \nnot CP-ordered then e1-e2 would nothavebeenthe .rst race of tr ' .Hencethemoveispossible,which violatesthe \n.rst minimality property, therefore our assumption was false and e \u00abHB e2. If e1 <HB e, then we can move \ne and all events e ' that occur betweene1 and e such that e '\u00abHB e to rightbefore e1.Again, with similar \nreasoning as above(or asinLemma2,below) we geta contradiction. (b) If either e1 \u00abCP e or e \u00abCP e2, then \nwe would have had e1 \u00abCP e2,perpart(a) andthede.nition ofCP: a contradiction. D Lemma2. Consider anylockacquire \nevent a1 for a criticalsection containing e1. All events e between a1 (inclusive) and e1 have a1 \u00abHB \ne andif e1 \u00abHB e2 then e \u00abHB e2. Proof. Assume a1 <HB e. Let E be the set of operations made up of e \nand all e ' that occurbetween a1 and e such that e '\u00abHB e.Note that set E cannot contain any eventsfrom \nthread t1, or else a1 \u00abHB e.Try to move all operationsin E to rightbefore a1.If the moveis notpossible,itis \neitherbecausethese moved eventshave a common lock with some non-moved event, f (a contradiction, since \nthen f \u00abHB e, and f wouldbe moved) or that the moved events con.ict with anon-moved event(alsoacontradictionsinceit \nwouldimply a racebefore e1-e2 oraCP relation,which violatestheassumption of no-HBbetween a1 and themoved \nevents).Therefore,moving E before a1 is possible, and the result of the move maintains intra\u00adthread order. \nHowever, moving E violates the minimalityproperty of tr ' . The fact that(e \u00abHB e2)follows from similar \nreasoning as in Lemma1,butuses the assumption that e1 \u00abHB e2 to establish that e1is not among the moved \nevents. D Lemma3. Anycon.ictingeventsthatbothoccurbefore e2,or with onebeing e2 and the other occurring \nafter e1 andbefore e2,have to beCP-ordered. Proof. Otherwise wetriviallyhave aCP-race earlierthane1-e2. \nD Lemma4. Consider anylockacquire event a1 for a criticalsection containing e1. If a critical section \nc...c ' starts before event a1 and ends after a1 andbefore e1 then a1 \u00abCP c ' . Proof. Byinduction. Base \ncase: Considerthec...c ' thatendsthe soonest after a1(among all such c...c ' that satisfy the stated \nconditions). Assume that a1 <CP c ' . By the well-nesting of lock operations, such a critical section \nc...c ' cannotbeperformedby thread t1. Let d be the .rst event after a1 in this critical section. We \nwill try to move d...c ' to the point right before a1, respecting intra\u00adthread order.Ifthe moveis successfulit \nviolatesthe minimality of tr ' ,hencethe movemustbeillegalbecauseit violates some property of CR or of \nthe de.nition of a trace. Therefore, the move mustbeillegalfor either of the usual two reasons: 1. It \ncauses the result to not be a trace because the pairing of lock acquisition/releasesbecomesinvalid(i.e., \nalockis acquired whileheld). 2. The resultis a validtrace t butt *CR tr ' because a read now sees adi.erent \nwritten value. Forcase(1),themoved events cannotbeacquiring alockheld bythreadt1 atposition a1, sincethatlock \nwould notbe released before e1. If the lock were held by a thread other than t1, we have a critical section \nwith the stated properties for c...c ' that endsbefore the currently considered c...c ' , whichisimpossible. \nCase(2) meansthatthe moved events con.ict with some non\u00admoved event that occurs after a1.This non-moved \nevent e '' has toCPthe moved eventit con.icts with(byLemma3).Butfrom Lemma2wehave a1 \u00abHB e '' and therefore \na1 \u00abCP c ' . Inductive case: the argument is identical to the base case, except in case (1) when we consider \nthe possibility that a lock that needs to be acquired by the moved events is held by a thread other than \nt1. In this case, we have an earlier critical section g...g ' with the stated properties, and therefore \na1 \u00abCP g ' , by theinductive assumption.But since our c...c ' acquires the same lock, weget thedesireda1 \n\u00abCP c ' . D Lemma5. There cannotbe a criticalsectionby athread otherthan t2 that starts after event e1 \nandbefore e2, and ends after event e2. Proof. Assume that such critical sections exist. Among them pick \nthe c...c ' that starts last, i.e., closest to e2. Let d be the last event before e2 of thiscritical \nsection.Wehavetwocases: 1. If c...d does not contains nested critical sections inside it, we can move \nall events c...d to the point right after e2. The proof is similar to that of Lemma 4. The move respects \nintra-thread ordering. Also the moved events cannot be acquiring a lock held at point e2.(Thereareno \nnestedcritical sectionsinthe moved events, and the lock acquired by event c is still held at e2.) Furthermore, \nthe resulting trace is a correct reordering of the originalbecauseifit were not we wouldthenhave a con.ict \nbetween events whose relative position changes, i.e., between the moved events and non-moved events.Butin \nthat case there would be a CP edge originating in c...d to an event before e2 (by Lemma 3)and since c \nis between e1 and e2 we would get (usingLemma1)e1 \u00abCP e2(a contradiction). 2. Ifc...ddoes contain criticalsections,let \ng...g ' be the one ending lastbeforee2.Consider an event sequenceproduced asfollows: -we drop all events \nstarting from (and including) g of that  thread -wedrop all eventsafter e2 byall other threads. Clearly \nthe resultis apre.x of tr ' .Ifitis alegal trace that cor\u00adrectly reorders tr ' then we are violating \nthe minimality of tr ' . Inthe resultingevent sequence there cannotbe an event acquir\u00ading a lock already \nheld: the only dropped lock release events are either after e2(in whichcase subsequent lock acquisitions \nare also dropped), or are dropped together with their lock ac\u00adquisition event(inthe case of g...g ' events). \nNote that if there is a critical section inside c...c ' that starts before g...g ' , it has to also endbefore \ng, or it would violate the de.nition of either g...g ' or c...c ' . Also, no read can see a di.erent \nwrite, or this wouldimply a con.ictbetween adropped event after gand an\u00adother before e2. In such a case \nwe would have a CP ordering, per Lemma 3 and e1 \u00abCP e2, as before. We conclude that the resulting trace \ncorrectly reorders tr ' and violatesits minimality assumption: a contradiction. D Armed with these lemmas \nabout trace tr ' we can now attempt to prove the soundness theorem. We will show that tr ' either has \nan HBrace(infact, e1 and e2havetobe adjacentinthis minimaltrace) or, if not, the trace exposes a deadlock \nwhich can be caused by a slightly reordered trace.  Clearly,if e1-e2 is an HB race in tr ' then we are \ndone. Assume itis not.We willtrytoCR-reordertr ' so that one of the minimality propertiesisviolated(whichisacontradiction).Considerthe \n.rst event f such that: f isperformedby a thread other than t1  f occurs after e1 andbefore e2.  Such \nan event needs to existif e1-e2 areHB-ordered.Furthermore, by Lemma 1, e1 \u00abHB f, and since f is the .rst \nsuch event in any thread other than t1,it needs tobe alock acquire.Consider then the critical section \nf... f ' .There are two cases: 1. f ' occurs before e2. Let f... f ' be over lock l. We get two subcases: \n(a) l is notheldby t1 during e1. Since e1 \u00abHB f and f is the .rst such event outside t1, there must be \na critical section over l after e1 and before f. Let g be the lock acquire event of that critical section. \ng has to be an event by thread t1, otherwise the de.nition of f wouldbeviolated(therewouldbeanother .rst \nevent). Also,ghastobe aftere1,by our assumptionthat lis notheld during e1.Consider a move of f... f ' \nto rightbeforepoint g. The move respects intra-thread order. Also, if a read sees a di.erent write then \na moved event must con.ict with one of the non-moved events after g,hence(Lemma3) wehave '' '' '' some \ne such that e \u00abCP f ' . But we have e1 \u00abHB e (by Lemma1),e '' \u00abCP f ' , and f '\u00abHB e2(byLemma1),hence \ne1 \u00abCP e2: a contradiction. Finally, the move may cause a lock, m, to be acquired whilebeingheld: this \nmeans a critical section acquiring and releasing that lock is inside f... f ' .(Assume w.l.o.g. that \nm is the .rst such lock.)If m isheld atpoint g by a thread t3, other than t1, then it has to be released \nbefore f, violating thede.nition of f (since thereis adi.erent .rst event after e1 by a thread other \nthan t1). A more interesting case is when lock m is held at point g by thread t1. In that case, lock \nl is nested inside lock m in threadt1(becauselisacquiredatposition gwith m held)and lock m is nested \ninside lock l in thread t2. We can cause a deadlockbymoving apre.x ofthe f... f ' critical section(up \nuntil thelock m acquisition) topoint g.Therefore the move of f... f ' to point g either produces a legal \ntrace t such that t = CR tr ' , or exposes adeadlock. The move can be repeated until there are no more \ncritical sections overlock l between e1 and f... f ' . At that point, we can just move event f to right \nbefore e1. This would produce a correctly reordered trace that violates the minimality of tr ' : a contradiction. \nWe conclude that if Case 1(a) occurs, there is always a deadlockin a correct reordering of trace tr ' \n. (b) l isheldby t1 during e1. Let a2 be the last lock acquisition event of lock l before e1. Consider \na move of f... f ' and all previous events by the same thread after a2 to right before point a2. Let \na ' 2 be the lock release paired with a2. The move respects intra\u00adthread order. Also, if a read sees \na di.erent write then a moved event must con.ict with one of the non-moved events after a2,hence(byLemma3) \nwehave some e '' such that e '' \u00abCP e ' , where e ' is a moved event, and therefore '' ' ' e \u00abCP f (since \nallthe movedeventsprecede f and areby the samethread).But(byLemma2)wehavea2 \u00abHB e '' and therefore a2 \n\u00abCP f ' . Since, however, the critical sections starting at a2 and ending at f ' are over the same lock \nl, we get that a ' 2 \u00abCP f ' , because of the second rule in the CP de.nition.Thisimplies e1 \u00abCP e2(sincee1 \nisbefore a ' 2,by assumption of case 1(b), and f '\u00abHB e2, by Lemma 1): a contradiction. Finally, we consider \nthe case of the move being illegal becauseitcauses alock, m,tobe acquired whilebeingheld. If such an \nm is held by a thread t3, other than t1, at point a2,thenithastobe releasedbefore e1(otherwisethe release \nevent would violate thede.nition of f, sinceit would come beforeit, after e1 andby athread otherthan \nt1).This means that Lemma 4 applies to the critical section of that thread. Hence, we have that a2 \u00abCP \nh ' , where h ' is m s release event in t3. But since h ' happens-before some moved event (since the \nmovedevents acquire lock m), wegete1 \u00abCP f ' (again, allmoved events are program-ordered with f ' )and \nconsequently(viaLemma1) e1 \u00abCP e2: a contradiction. Iflock m isheld atposition a2 by thread t1, then \nl is nested insidem in thread t1, while m is nestedinsidel in the thread performing f... f ' .(Thelock \nacquisition of m by that thread cannot be before f since the lock is released after e1 and f is the .rstevent \nafter e1 by a thread other than t1.Therefore m isacquired and releasedinsidecritical section f... f ' \n.)As before, we can cause a deadlock by moving a pre.x of the f... f ' critical section(and any earlier \nevents after a2 by the same thread) to a2. Therefore,this case againimplies adeadlockina reordering of \ntrace tr ' . 2. f ' occurs after e2. We then have by Lemma 5 that f... f ' has to be performed by thread \nt2. Let f... f ' be over lock l. Lock l cannot be held by t1 during event e1, or e1 \u00abCP e2. Therefore, \nthere must be some criticalsection g...g ' over l,performedbythread t1 after e1,such thatg '\u00abHB f.(Recallthat \nf isthe .rsteventafter e1byathread other than t1.)Assume w.l.o.g.that g...g ' isthelastsuch critical \nsection. Consider an event sequenceproduced asfollows: -wedrop g and all events e ' after g by a thread \nother than t2. -wedrop all eventsafter e2 by all threads. Clearly the result is a pre.x of tr ' . If \nit is a legal trace that correctly reorders tr ' then we are violatingthe minimalityof tr ' . Thereforethe \nresultofthis eventdrophastobeillegal.Thedrop respectsintra-thread order.Also,if a read sees adi.erent \nwrite then adropped event must con.ict with one of the non-dropped eventsbefore e2.ByLemma3 weget aCP \nedgebetween events after e1 andbefore e2 intr ' , andbyLemma1 andCPproperties wehave e1 \u00abCP e2: a contradiction. \nThus, the event sequence cannot be a trace: a lock has to be acquired while held. Such a lock, m, has \nto be acquired before one of the dropped events, with its release among the dropped events.Thelockis \nthen re-acquiredby one of the non-dropped events,i.e.,bythread t2.The acquisition of m hastobeinthread \nt1(otherwise f would not be the .rst event between e1 and e2 by a thread other than t1). In threadt1, \nfor trace tr ' , lock l has tobe nestedinside m (sincedroppingevery event after g, which is an acquisition \nof l, caused thedrop of the releasebut not the acquisition of m).However,lockm isnestedinsidelinthreadt2, \nsince it is acquired after l s acquisition(point f)and before l s release(which occurs after e2).We can \nagain cause a deadlock with an event move(of apre.x of f...e2). This concludes the proof of the theorem: \nany CP race implies either an HB race in the minimal trace tr ' , or a deadlock in a reordered trace. \nD   \n\t\t\t", "proc_id": "2103656", "abstract": "<p>Data races are among the most reliable indicators of programming errors in concurrent software. For at least two decades, Lamport's happens-before (HB) relation has served as the standard test for detecting races--other techniques, such as lockset-based approaches, fail to be sound, as they may falsely warn of races. This work introduces a new relation, causally-precedes (CP), which generalizes happens-before to observe more races without sacrificing soundness. Intuitively, CP tries to capture the concept of happens-before ordered events that must occur in the observed order for the program to observe the same values. What distinguishes CP from past predictive race detection approaches (which also generalize an observed execution to detect races in other plausible executions) is that CP-based race detection is both sound and of polynomial complexity. We demonstrate that the unique aspects of CP result in practical benefit. Applying CP to real-world programs, we successfully analyze server-level applications (e.g., Apache FtpServer) and show that traces longer than in past predictive race analyses can be analyzed in mere seconds to a few minutes. For these programs, CP race detection uncovers races that are hard to detect by repeated execution and HB race detection: a single run of CP race detection produces several races not discovered by 10 separate rounds of happens-before race detection.</p>", "authors": [{"name": "Yannis Smaragdakis", "author_profile_id": "81100614708", "affiliation": "University of Athens and University of Massachusetts, Athens, Greece", "person_id": "P2991427", "email_address": "smaragd@di.uoa.gr", "orcid_id": ""}, {"name": "Jacob Evans", "author_profile_id": "81444595547", "affiliation": "University of Massachusetts, Amherst, MA, USA", "person_id": "P2991428", "email_address": "jmevans@cs.umass.edu", "orcid_id": ""}, {"name": "Caitlin Sadowski", "author_profile_id": "81418599954", "affiliation": "University of California, Santa Cruz, Santa Cruz, CA, USA", "person_id": "P2991429", "email_address": "supertri@cs.ucsc.edu", "orcid_id": ""}, {"name": "Jaeheon Yi", "author_profile_id": "81351599511", "affiliation": "University of California, Santa Cruz, Santa Cruz, CA, USA", "person_id": "P2991430", "email_address": "jaeheon@cs.ucsc.edu", "orcid_id": ""}, {"name": "Cormac Flanagan", "author_profile_id": "81100538763", "affiliation": "University of California, Santa Cruz, Santa Cruz, CA, USA", "person_id": "P2991431", "email_address": "cormac@cs.ucsc.edu", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103702", "year": "2012", "article_id": "2103702", "conference": "POPL", "title": "Sound predictive race detection in polynomial time", "url": "http://dl.acm.org/citation.cfm?id=2103702"}