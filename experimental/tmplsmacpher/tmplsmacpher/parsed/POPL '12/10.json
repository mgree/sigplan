{"article_publication_date": "01-25-2012", "fulltext": "\n Access Permission Contracts for Scripting Languages Phillip Heidegger Annette Bieniusa * Peter Thiemann \nUniversity of Freiburg, Germany INRIA Paris-Rocquencourt and LIP6 University of Freiburg, Germany heidegger@informatik.uni-freiburg.de \nAnnette.Bieniusa@inria.fr thiemann@informatik.uni-freiburg.de Abstract The ideal software contract fully \nspeci.es the behavior of an oper\u00adation. Often, in particular in the context of scripting languages, a \nfull speci.cation may be cumbersome to state and may not even be desired. In such cases, a partial speci.cation, \nwhich describes se\u00adlected aspects of the behavior, may be used to raise the con.dence in an implementation \nof the operation to a reasonable level. We propose a novel kind of contract for object-based languages \nthat speci.es the side effects of an operation with access permis\u00adsions. An access permission contract \nuses sets of access paths to express read and write permissions for the properties of the objects accessible \nfrom the operation. We specify a monitoring semantics for access permission con\u00adtracts and implement \nthis semantics in a contract system for JavaScript. We prove soundness and stability of violation under \nincreasing aliasing for our semantics. Applications of access permission contracts include enforcing \nmodularity, test-driven development, program understanding, and regression testing. With respect to testing \nand understanding, we .nd that adding access permissions to contracts increases the effec\u00adtiveness of \nerror detection through contract monitoring by 6-13%. Categories and Subject Descriptors D.2.4 [SOFTWARE \nEN-GINEERING]: Software/Program Veri.cation: Assertion Check\u00aders, Programming by Contract; D.3.1 [PROGRAMMING \nLAN-GUAGES]: Formal De.nitions and Theory: Semantics General Terms Algorithms, Design, Experimentation, \nLanguages, Reliability, Theory, Veri.cation Keywords scripting languages, contracts, JavaScript 1. Introduction \nDesign by contract is a methodology for software development based on speci.cations (contracts) of operations \n[35, 36]. The cor\u00ad rectness of an implementation with respect to a contract may be statically guaranteed \nby program veri.cation or it may be dynami\u00adcally checked via contract monitoring. As the latter variant \npermits more expressive speci.cations and puts less demands on the theo\u00adrem proving skills of the programmer, \nit is widely used in practice as evidenced by implementations of contract checking in various forms and \nfor many languages [1, 14 17, 25, 27, 29, 45]. * Research was done while at University of Freiburg. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n12, January 25 27, 2012, Philadelphia, PA, USA. Copyright c &#38;#169; 2012 ACM 978-1-4503-1083-3/12/01. \n. . $10.00 Figure 1. Example widget hierarchy. Originally, contracts were meant to provide full speci.cations. \nHowever, contracts for partial speci.cations, which only .x certain aspects of an operation, also have \ntheir uses. For example, in a dynamically-typed language, like Scheme or JavaScript, a contract could \nhave the form of an expressive type signature and impose restrictions similar to a type system [2, 25, \n44]. Contract monitoring for such type contracts detects type errors at operation boundaries. A type \ncontract has one important drawback. It only imposes restrictions on the values passed to an operation \nand returned from it. In an imperative language like Scheme or JavaScript, many operations have an effect \non the heap, which is not captured by a type contract. For those operations, a contract that also speci.es \nthe effect would be more appropriate. In the past, this drawback has driven the evolution of type sys\u00adtems \ntowards effect systems that enable the speci.cation and infer\u00adence of side effects (e.g., [19, 43]). \nIn analogy, we propose to ex\u00ad tend type contracts with a language-dependent notion of effects and to \ncheck them with an application-dependent notion of monitoring. In this paper, we develop a notion of \neffect suitable for scripting languages and for JavaScript in particular. The application scenar\u00adios \nthat we have in mind are enforcing modularity, test-driven de\u00advelopment, program understanding, and regression \ntesting. 1.1 Effects for Scripting Languages Like other scripting languages, JavaScript implements an \nobject as a reference to a map from properties to values where some of the values may be objects again. \nEvery read or write access to the resulting object graph can be described by a base object,a path (a \nsequence of property names), and a classi.er indicating the operation on the last step of the path (read \nor write). This observation has lead us to de.ne effects by access permis\u00adsions that specify a set of \npaths that an operation may read or write relative to some base object in scope. The base object may \nbe this, an argument of the operation, or a global variable. As an example, consider a JavaScript implementation \nof the widget class hierarchy described by the class diagram in Fig. 1. The layout operation computes \nthe screen position of each widget. It ac\u00adcepts a pair of absolute starting coordinates and returns the \nwidth and height of the rendered widget. As a side effect, it stores the bounding box of each subwidget \nin its representation. A program\u00admer working on the code of this operation might like to ascertain that \nthe layout computation only ever changes the bounding box properties of a widget by attaching the following \ncontract to the layout operation:  (int, int) .{w: int, h: int} with [this.*./x|y|w|h/] This contract \nspeci.es an operation that accepts two integers, re\u00adturns an object with two integer properties named \nw and h,and modi.es at most the x, y, w,and h properties of objects reach\u00adable through this. Furthermore, \nthe contract allows the operation to read all properties reachable through this: a write path has to \nmatch the entire access permission, whereas a read path is accepted if it matches a pre.x of the permission. \nMore precisely, this speci.es the base object, . separates the path components, * matches any sequence \nof property names, and /x|y|w|h/ is a regular expression that matches the names of the properties with \nwrite permission. Here are some further conventions for reading access paths. Parameters can be speci.ed \nas base objects for a path by name or using a positional notation $1, $2, .... The symbol ? is short \nfor the regular expression /.*/ that matches any property name. A path ending in @ indicates a read-only \npath.  1.2 Application Scenarios Regarding the application scenarios, contract monitoring for the layout \ncontract is useful during the initial test-driven development of the code because any violation of the \naccess permission triggers an exception as part of a test run. It is also useful for program understanding. \nA programmer who would like to con.rm that the layout operation works in the outlined way would impose \nthe contract and watch for failing test cases. The access permissions also indicate what operations are \nindependent of one another. For example, an operation that marks those widgets which are visible in a \ngiven viewport might have a contract like this: ({vx:int,vy:int,vw:int,vh:int}) . any with [$1.?.@, this./l|r/*./x|y|w|h/.@, \nthis./l|r/*.visible] The path, $1.?.@, grants read access to any property of the .rst parameter, but \nno write permission; only the bounding box of a widget may be read; and only its visible property may \nbe written. Only l and r properties may be traversed recursively along the last twopaths.In regression \ntesting, changes to the code that violate the contract are detected early in a run of a test suite, assuming \nsuf.cient coverage. Last, but not least, modularity: JavaScript programs often rely on a number of libraries \nand freely include third-party code (mash\u00adups) that may change arbitrarily between different program \nruns. Programmers do not want this code to corrupt their global variables or to in.ict arbitrary changes \non their object structures. Wrapping a monitored contract around the third-party code con.nes these effects \nand guarantees the integrity of the program s state. 1.3 Monitoring of Effects There are two approaches \nto de.ning a semantics of monitoring for an access permission. The location-based semantics attaches \npermissions to each object location. It traverses the object graph starting from the base object according \nto the access paths and reg\u00adisters a read or write permission (according to the path s classi\u00ad.cation) \nfor each object property along the path. In contrast, the path-based semantics pairs each object reference \nwith an access path and computes the permission at a read/write access based on the path through which \nthe object has been reached. In the absence of aliasing, the location-based semantics is equiv\u00adalent \nto the path-based semantics. In general, however, the seman\u00adtics differ, which indicates that they serve \ndifferent purposes. The following example highlights the differences. It is further elabo\u00adrated in Sec. \n2.1. Suppose an object is reachable from the base object via two different paths, where one path grants \nwrite permission for prop\u00aderty p, but a second path only grants read permission to p. With the path-based \nsemantics, the path used to access the object deter\u00admines the permission, but which permission should \nbe granted by the location-based semantics? If p gets write permission, then an execution that arrives \nat the object via the read path can write. If p only gets read permission, then an execution that arrives \nat the object via the write path cannot write. To prevent this counterintu\u00aditive behavior in the second \nscenario, the location-based semantics must assign the least restrictive permission of all paths reaching \np. A similar dilemma may arise between no permission and per\u00admission to read. Both location-and path-based \nsemantics are non-trivial to im\u00adplement ef.ciently. With the location-based semantics, the installa\u00adtion \nof a contract requires that the locations of all objects reachable through the contract s access paths \nmust be marked with access rights. This marking cannot be delayed because aliasing may pro\u00advide a shortcut \ninto a data structure on which the contract grants read or write permission. In the worst case, the time \nneeded to install a contract is bounded only by the size of the entire object graph. A read or write \noperation can be implemented in almost con\u00adstant time. In contrast, the path-based semantics requires \ntime linear in the number of installed contracts for each read and write operation, whereas the installation \nof a contract takes constant time. Read operations are a bit tricky because they have to juggle access \npaths in the right way (see Sec. 3.2). This paper explores the path-based semantics because it is the \nsemantics of choice for our intended application scenarios as ex\u00adplained in Sec. 2. The location-based \nsemantics most likely has a role to play in monitoring access control in a security scenario, but it \nis based on a different set of assumptions and a separate investi\u00adgation is required to explore it [24]. \n Contributions 1. Design of a contract framework with access permissions. 2. Speci.cation of a path-based \nformal semantics of access per\u00admissions and their dynamic enforcement. 3. Formal proof that the semantics \nguarantees stability of access violations under addition of aliasing, subject to mild conditions. 4. \nPrototype implementation of access permissions with monitor\u00ading in a contract and testing framework for \nJavaScript based on program transformation. 5. Assessment of the effectiveness of access permission \ncontracts by observing the impact of random code modi.cations on hand\u00adannotated case studies. 6. Practical \nevaluation of the approach on different code bases.  A technical report [24] extends this paper by an \nappendix with further examples, proofs of all theorems, a de.nition of the location-based semantics, \na sketch of its application to the security scenario, and additional information regarding the case studies. \n Outline In Sec.2, we explain the design choices underlying our contract framework with examples and \nexplore some of the alternatives. Section 3 presents a formal framework for reasoning about ac\u00ad cess \npermissions. It presents an operational semantics of contract monitoring and formally de.nes and proves \ntwo properties that are consequences of the design choices. Section 4 explains the basic approach taken \nby the implementation. The evaluation in Sec. 5 explores the effectiveness of access permission for detecting \npro\u00adgramming errors using mutation testing.   2. Design Choices For each programmer, an access permission \nhas an intuitive mean\u00ading that coincides with the intuition of other programmers in the vast majority \nof cases. These intuitions differ when aliasing comes into play, because each programmer has different \napplication sce\u00adnarios in mind, each with its own requirements to the semantics. As already indicated \nin the introduction, our intention is to employ access permissions as partial speci.cations of a program \ns effect. We regard it as a dynamic counterpart to previous work on static effect systems [19, 22]. This \nintention motivates the four major design choices we have taken for the monitoring semantics for access \npermissions. Path-Dependent Access An access permission grants the right to read or modify a property \nof an object depending on the path through which the object has been reached. Dynamic Extent An access \npermission for a function is in force for the duration of a function activation. Pre-State Snapshot An \naccess permission only applies to objects and paths in the heap at the time when the contract is installed. \nSticky Update A property assignment keeps the access paths of the value on its right-hand side. The rest \nof this section explains the choices in depth, gives a critical overview of the alternatives, and thus \nprovides a rationale for the design of our framework. 2.1 Path-Dependent Access An access permission \ngrants the right to read or modify a property of an object depending on the path through which the object \nhas been reached. This choice has two consequences. Reference Attachment Permissions are attached to \nindividual ref\u00aderences, not to heap locations. That is, if two variables or prop\u00aderties hold a reference \nto the same object, then accesses through each variable may have different access rights. Stability of \nViolation An access violation is preserved under in\u00adcreased aliasing. See Sec. 3.5 for a formal statement. \n Section 1.3 already argues in favor of the path-based semantics. Here, we give a concrete example where \nthe location-based seman\u00ad tics behaves different from a static analysis. 1 /*c (obj, obj) . any with \n[x.b,y.a] */ 2 function h(x, y) { 3 y.a = 1; 4 y.b = 2; // violation? 5 } 6 function h1() { 7 var o= \n{ a: -1, b: -2 }; 8 h(o, o); 9 } Any modular attempt to verify h s access permissions statically (for \nexample, using the dynamic frame rule of Smans and coworkers[41]) cannot assume that x=y. Without this \nassumption the analysis would fail because the contract disallows the access to y.b in line 4. The path-based \nsemantics is consistent with such an analysis: Any invocation of h in particular the call from h1 triggers \na contract violation regardless of the aliasing among the arguments. We call this behavior stability \nof violation. With the location-based semantics, h1 would not trigger a vio\u00ad lation. As x and y are aliased, \ntheir underlying location would ob\u00ad tain permission to write properties a and b and the two assignments \nwould go through without violation. Furthermore, the location\u00adbased semantics breaks stability of violation. \nCalling h without aliasing as in h2 detects a violation. 10 function h2() { 11 h({ a: -1, b: -2 }, { \na: -1, b: -2 }); 12 } In a security setting, the location-based semantics appears better suited because \na permission like window./ ((?!location$).)/ seems to rule out any access to the location property of \nthe window object, even if this object has been reached via some alias. However, the following example \ndemonstrates that this appearance is deceptive: 13 /*c(obj,any) . any with [x.?,window./ ((?!location$).)/] \n*/ 14 function k(x, y) { 15 x.location = y; // violation? 16 } 17 function k1() { 18 k(window, http://www.evil.com/ \n); 19 } As x and window are aliases of one another, the permission x.? grants write permission for all \nproperties of window and the per\u00admission window./ ((?!location$).)/ grants write permission for all properties \nof window, except location. Hence, the location-based se\u00admantics permits writing to window.location in \nthe body of k. For the record, the path-based semantics does not trigger a violation, either: for all \nx, any property of x may be read and written; for window, all properties except location may be read \nand written. The body of k does not exceed these permissions, so no violation can happen.  2.2 Dynamic \nExtent An access permission for a function is in force for the duration of a function activation. If \na permission is attached to a function, then each invocation of the function installs an instance of \nthe permission and this same instance is withdrawn at the matching function return. As a consequence, \npermissions get re.ned in a chain of func\u00adtion calls. Because an access permission expresses the promise \nthat the contracted function does not exceed its permissions, each addi\u00adtional function call can only \nrestrict the accessible properties fur\u00adther. For example, consider these functions: 20 /*c(obj) . any \nwith [x.a] */ 21 function d1(x) { 22 return x.a; // violation if called from d2 23 } 24 /*c(obj) . any \nwith [] */ 25 function d2(x) { 26 return d1(x); 27 } The contract of function d2 disallows any access \nto its argument. Invoking d2 with any object triggers a violation of d2 s contract when trying to execute \nline 22, although this line is in d1,which has a more permissive contract. As another consequence, a \nclosure returned from a function is not restricted by the access permission of the function. For example, \nconsider the permission of f in this code fragment: 28 /*c(obj) . (() . any) with [x.b] */ 29 function \nf(x) { 30 return function() { return x.a + +x.b; }; 31 } 32 function f1() { 33 var r=f({ a: secret ,b: \nrevealed }); 34 r(); 35 }  Running the function f1, which is unrestricted (because there is no contract \nassociated with f1), returns secret revealed . It does not violate the contract of f because the access \nto x.a happens outside the dynamic extent of the call to f in line 33. The choice for dynamic extent \nis inspired by the distinction between direct and latent effects in static effect systems. Evaluation \nof the function expression in line 30 does not cause an access to x.a or x.b. For this reason, a static \neffect system categorizes this effect as a latent effect and places it on top of the function arrow in \nits type. When the function is applied, the effect is exercised. However, at that point, there is no \ncontract in force that would restrict the effect. On the other hand, the following variant of the program \nfrag\u00adment leads to a violation. 36 function g(x) { 37 return function() { return x.a + x.b; }; 38 } \n39 /*c(obj) . any with [x.b] */ 40 function g1(x) { 41 var r=g(x); 42 r(); // violation 43 } As the \ninvocation of r() happens in the extent of the invocation of g1, its permission with [x.b] is in force \nand the violation by accessing x.a is detected. In contrast, the function g by itself does not impose \nany restriction on accesses to x, so that a direct call to g does not lead to a violation. An alternative \ndesign would consider access permissions as contagious (having static extent determined by lexical scope) \nand have closures capture the permissions in force at their de.nition site. This design seems more appropriate \nin a security setting and it would report violations for the examples involving functions f and g.  \n2.3 Pre-State Snapshot An access permission only applies to objects and paths in the heap at the time \nwhen the contract is installed. One immediate implication of this choice is that the program can access \nand modify newly allocated objects without restriction. As these objects are not present in the heap \nsnapshot at installation time (the pre-state), the contract does not restrict access to them. This behavior \nis analogous to the treatment of the assignable clause and newly allocated objects in JML [32, 38]. \nWe see two alternatives to this design but consider neither vi\u00ad able: to choose a different reference \nheap or to choose a different interpretation of access paths. The only other reference heap for a contract \nwould be the post\u00adstate of a function, that is, the heap at the time the contract is withdrawn. However, \nthe .nal heap is not a sensible choice because the programmer expects the paths in a contract to refer \nto the situation at the time a function is invoked. The .nal heap may exhibit very different paths. Another \ninterpretation of access paths might consider the per\u00admissions as symbolic paths that may be traversed \nregardless of the changes in the underlying heap. This interpretation violates the pro\u00adgrammer s intuition \nand it is inconsistent with static veri.cation as the following example shows. 44 /*c (obj, obj) . any \nwith [x.a, y.a, y.a.b] */ 45 function b(x, y) { 46 y.a = x.a; 47 y.a.b = 42; // allowed? 48 } Reading \njust the contract, a programmer expects that x.a.b does not change. However, the symbolic interpretation \nof paths would not .ag the assignment in line 47, which changes x.a.b, counter to the expectation of \nthe programmer. In contrast, a static veri.cation of access permissions [41] keeps track that y.a is \nreally x.a in line 47 and rejects the function. The pre-state snapshot interpretation is consistent to \nstatic veri.cation and reports a violation.  2.4 Sticky Update A property assignment keeps the access \npaths of the value on its right-hand side. A property assignment of the form x.p = y,where y refers to \nan object, creates a new path through x.p to the object graph reachable from y. Sticky update means that \nthe access information for y is kept along with the reference so that a subsequent access through x.p \nis considered an access through y. This choice is compliant with the Hoare-calculus rule for assignment: \n{P [y/x.p]} x.p = y {P } For suppose that P [y/x.p] is the predicate location e' is reachable from location \ne via some path . and y= e' . Then a suitable candidate for P is location e' is reachable from location \ne via some path . and x.p= y = e' . Here is an example. 49 /*c(obj) . any with [x.a,x.b.a] */ 50 function \nl(x) { 51 x.a = x.b; 52 x.a.a = 42; 53 } 54 function l1() { 55 var x= { a: {},b: {}}; 56 l(x); 57 } \nIn this code fragment, line 51 is clearly permitted as x.a may be assigned to and x.b may be read. The \nfollowing read access to x.a in line 52 returns the reference to the object that was accessible through \nx.b when the permission was installed. As this object is the one that was reachable via x.b in the pre-state, \nthe access permis\u00adsion for x.b counts so that the assignment to x.a.a is sanctioned by the path x.b.a. \nThus, function l1() runs without violation! Things look different in a slightly modi.ed version of the \nex\u00adample that creates the alias before installing the permission. 58 /*c(obj) . any with [x.a,x.b.a] \n*/ 59 function m(x) { 60 var y=x.a; 61 y.a = 42; // violation 62 } 63 function m1() { 64 var x= { a: \n{},b: {}}; 65 x.a = x.b; 66 m(x); 67 } In this case, running m1() yields a violation. While the .rst \nread access to x.a in line 60 is sanctioned by x.a, the write access to property a of this object is \nnot. Indeed, this behavior is consistent with invoking m on an object without any aliasing, which reports \na violation under any semantics.1   3. Formalization A formal semantics of monitoring for access permissions \nis needed as the basis of an implementation that adheres to the design choices. For that reason, we de.ne \nthe calculus .AP as a call-by-value obj lambda calculus extended with objects and access permissions. \nFor 1 The location-based semantics runs both examples, l1 and m1, without triggering a violation.  variable \nx . Var property name p . Prop access path p . Path = Prop * path language L . PLang = P(Path) expression \ne . Expr ::= x | .x.e | e(e) | new | e.p | e.p := e | permit x : Lr,Lw in e Figure 2. Syntax. this calculus, \nwe specify the semantics, including monitoring, and prove that it adheres to the properties stated in \nSec. 2, in particular, pre-state snapshot and stability of violation. Let s .x some notation before we \nstart. Given sets A and B,we write P(A) for the power set of A, A + B for the disjoint union of A and \nB,and A \u00d7 B for their Cartesian product. A-B denotes the set of .nite (partial) functions from A to B \nwith \u00d8 standing for the empty mapping and if f . A-B,then dom(f) . A denotes the domain of f and f.AI \ndenotes the restriction of f to A ' . A. The updated function f ' = f[a . b] is de.ned by f ' (a)= b \nand f ' (a ' )= f(a ' ),for all a '= a. We also write [a . b]= \u00d8[a . b] for the singleton map with domain \n{a}. If we write f(a) as part of a premise, this use implies the additional premise a . dom(f). 3.1 Syntax \nFigure 2 speci.es the syntax of .AP obj. The calculus extends a call-by\u00advalue lambda calculus with object \nconstruction (new creates a fresh object devoid of properties), reading of an object s property, and \nwriting/de.ning an object s property. The syntax is close to that of existing JavaScript core languages \n[23, 26]. The novel construct of the calculus is the access permission expression permit x : Lr,Lw in \ne that restricts accesses through variable x during evaluation of e governed by the two languages Lr \nand Lw. Both languages specify a set of access paths (sequences of properties) starting from the object \nbound to x (which must be in scope). Read accesses to descendants of x are limited to paths in Lr whereas \nwrite accesses are limited to paths in Lw. Evaluation of e stops if it tries to perform any access that \nis not permitted. The read language Lr should be pre.x closed, because it does not make sense to permit \nreading of x.a.b without permitting to read x.a, too. Similarly, writing to x.a.b is not possible without \nreading x.a, .rst. So, each path in the write language Lw should extend a path in the read language by \none property, that is, Lw . {p.p | p . Lr,p . Prop}. Our implementation restricts Lr and Lw to regular \nlanguages so that the word problem is decidable for them. Furthermore, contracts with access permissions \ncan only be attached to functions and a contract can state multiple permits in one go.  3.2 Semantics \nFigure 3 de.nes the semantic domains and the inference rules for a big-step evaluation judgment of the \nform ., R, Wf H; u; e.. H ' ; u ' ; v This judgment declares that given a variable environment . and \nindexed collections R and W of read and write permissions, the expression e transforms the initial heap \nH to the .nal heap H ' and returns value v. Furthermore, it threads a time stamp u, u ' . Stamp that \nis incremented at each property write operation and at each permit expression. The permission collections \nR and W are indexed by the time stamps of the heaps for which the permissions were granted. The time \nstamp of a permission uniquely identi.es different executions of permit expressions and determines their \nrelative order with respect to heap modi.cations. Semantic domains e . Loc in.nite set of locations u \n. Stamp = Integer H . Heap = Loc -Obj Obj = Prop -(Stamp \u00d7 Val) P, R, W. Stamp -PLang M, N. PMap = Stamp \n-Path (e, M) . Ref = Loc \u00d7 PMap v . Val = Ref +(Env \u00d7 Expr) . . Env = Var -Val Checking permissions CHECK \nPERMISSION .u . dom(P) n dom(M): M(u) .P(u) Pfchk M Evaluation rules VAR ., R, Wf H; u; x.. H; u; .(x) \nLAM ., R, Wf H; u; .x.e .. H; u;(..FV(.x.e),.x.e) APP '' ' ., R, Wf H; u; e0 .; u ,.x.e) . H ;(. '' '''' \n., R, Wf H ; u . H ; v1 ; e1 .; u ' '' '' ''' ''' . [x . v1], R, Wf H ; e.; u ; v ; u . H ''' ''' ., \nR, Wf H; u; e0(e1) .. H ; u ; v NEW e/. dom(H) ., R, Wf H; u; new .. H[e .\u00d8]; u;(e, \u00d8) PUT ., R, Wf H; \nu; e1 .. H ' ; u ' ;(e, M) '' '''' ., R, Wf H ; u . H ; v ; e2 .; u ''''' '' '' Wfchk M.p H = H [e . \nH (e)[p . (u ,v)]] ''' '' ., R, Wf H; u; e1.p := e2 .. H ; u +1; v GET ., R, Wf H; u; e.' ; u ' Rfchk \nM.p . H ;(e, M) '' ' ., R, Wf H; u; e.p .; u (e)(p) . H ; M.p l H PERMIT ' '' ., R[u . Lr] f H; u +1; \ne.; u ; v ], W[u . Lw. H . ' = .[x . .(x) < [u . e]] ., R, Wf H; u; permit x : Lr,Lw in e.' ; u ' . H \n; v Figure 3. Semantics. Avalue v . Val is either a reference or a closure consisting of an environment \nand a lambda expression. The representation of a reference is a pair of a heap address e and a collection \nM of access paths, indexed by time stamps. The collection M records all permitted access paths that have \nbeen traversed during evaluation so far to obtain this reference value. The indexing is again used for \nmarking modi.cations with time stamps. This representation is dictated by the design choice of path dependency \n(see Sec. 2.1). A heap maps a location to an object and an object maps a property name to a pair of \na time stamp and a value. The time stamp indicates the time of the write operation that last assigned \nthe property. It is required to implement the sticky update from Sec. 2.4. The evaluation rules VAR, \nLAM,and APP for variable, lambda ab\u00adstraction, and function application expressions are standard. They \n (e ' , M ' lu N ) if v =(e ' , N ) M ' l (u, v):= v if v/. Ref (M lu N )(u ' ):= . . .N (u ' ) if \nu ' . dom(N ) . . '' ' M(u ) if u . dom(M)\\dom(N ) . u<u .unde.ned if u ' . dom(M)\\dom(N ) . u = u ' \n. . . ' unde.ned if u ./dom(M) . dom(N ) M(u).p if u . dom(M)(M.p)(u):= unde.ned if u/. dom(M) (e, N \n< M) if v =(e, N ) v < M := v if v/. Ref M(u) if u . dom(M)(N < M)(u):= N (u) if u/. dom(M) Figure 4. \nAuxiliary de.nitions. thread the time stamp and propagate the permissions R and W un\u00adchanged to their \nsub-evaluations, if any. The evaluation rule NEW creates a new object in the heap. The new object has \nno properties and its collection of access paths is empty. The latter indicates that the newly created \nobject is com\u00adpletely unrestricted (following Sec. 2.3). Any of its properties may be read or written. \nThe time stamp does not change when allocating a new object because no object in the current heap is \nmodi.ed. The PUT rule speci.es the operation that writes and (if neces\u00adsary) de.nes a property. It .rst \ncomputes the location e and the collection M of access paths of the object and then checks the write \npermission to the object with the premise Wfchk M.p.It overwrites the object s property with the new \nvalue and assigns it a new, incremented time stamp to implement the sticky update (Sec. 2.4). Hence, \nthe time stamp of a property is always the time of its last update. The rule GET de.nes the read operation \nof object properties. It relies on some auxiliary operations de.ned in Figure 4. It .rst expects e to \nevaluate to a reference (e, M), which denotes the base object for the property read. In this reference, \ne is the heap address of the object and M contains a collection of access paths for the object corresponding \nto heap traversals reaching this object, one path for each active access permission. The other premise \nRfchk M.p checks the read permission for these paths extended with property p. This check is speci.ed \nby rule CHECK PERMISSION which requires that, for each active access permission with time stamp u, the \ncurrent access path for u is an element of the set of permitted access paths for u, i.e., P(u). If the \nread operation is permitted, then there are two possibili\u00adties. If the property contains a closure, then \nthis closure is the result of e.p. However, if the property contains an object reference, say (e ' , \nN ), then this read operation has discovered that the paths in M.p are also access paths for object e \n' . The reference value re\u00adturned from the read operation must somehow merge the different ways to reach \ne ' :via N and via M.p. Computing the desired col\u00adlection of access paths depends on the last time u \nwhen the property e.p was updated. This complication is required to adhere to the pre\u00adstate snapshot \nproperty (Sec. 2.3). The operator l in Fig. 4 implements the required merger op\u00ad eration. Its right-hand \nargument comprises the contents of an ob\u00adject s property: (u, v) where u is the time stamp of the last \nup\u00addate and v the stored value. Its left-hand argument is the collection M ' = M.p of newly discovered \npaths to the property. If v is not a reference, then l just returns v as already discussed. Otherwise, \nv =(e ' , N ) in which case it returns the location e ' paired with the collection of paths computed \nby the operator lu applied to the new paths M ' and the old paths N . In an application M lu N , the \n.rst argument M contains the access paths that were detected when checking the read access. The second \nargument N contains the access paths as they are stored in the heap at location e ' . The subscript u \nis the time stamp of the last write to the property. The de.nition in Figure 4 distinguishes three cases \ndepending on when the property has been written last and what access paths were given to the written \nvalue. Let u ' be the time stamp of an execution of a permit expression. 1. The object s property value \nalready has an access path for index u ' (in N ). Thus, the property has been overwritten after the installation \nof u ' . In this case, a potential new access path for u ' in M is ignored. Instead, the existing access \npath is returned according to the pre-state snapshot property (Sec. 2.3) as it re.ects an access path \nat the time when the permission attached to u ' has been installed. 2. The object s property value has \nno access path for index u ' (in N ) and it had been written before the permission with index u ' has \nbeen installed as can be seen from u<u ' . In this case, we attach the new u ' -path to the value. This \npath is realizable in the pre-state snapshot at time u ' because the property has been written at u<u \n' , that is, before u ' . 3. There is no access path for index u ' (in N ) and the property has been \nwritten after the contract with index u ' has been installed (viz. u = u ' ). In this case, no u ' -path \nis attached because this property was not linked to the data structure in the pre-state snapshot at time \nu ' .  The examples in Section 3.3 illustrate these three cases. The rule PERMIT installs an access \npermission contract. Each such permission is bound to the time stamp u of the heap in which the permission \nis installed. It increments the time stamp to avoid clashes with the next permission. Then, evaluation \nproceeds with the body of the permit-expression, but with an updated variable binding for x, which records \nthe time stamp u for the heap reach\u00adable from the object bound to x (if any) by attaching [u . e] to \nit, and updated read and write permissions, which record the stated permission set Lr and Lw for the \nobject network reachable from x. An access permission has dynamic extent (Sec. 2.2) because the access \npermissions are propagated with the .ow of execution and the rule CHECK PERMISSION only considers the \nentry points in the domain of the current access permission P. In particular, access permission contracts \nare not captured by closures created while they are in force: Closure creation (rule LAM) ignores the \naccess permissions and function application (rule APP) continues to use the current permissions with \nthe body of the invoked function. Hence, after evaluation of the body of an access permission is complete, \nthe information associated with its index u could be garbage collected both from the value and from the \nheap.  3.3 Examples The code fragments in Fig. 5 illustrate the different cases of the lu operator. \nThe fragments (a) and (b) correspond to the examples l1 and m1 in Sec. 2.4. They differ only in the placement \nof the permit expression. The code fragment (a) installs the permission before creating an alias with \nthe assignment x.a = x.b whereas version (b) installs the permission afterwards. In both cases, let the \npermit expression be associated with time stamp u ' . In fragment (a), the expression x.b in line 6 returns \nthe location eb paired with the map [u ' . b] (case 2 of lu: u<u ' because it was generated by the preceding \nassignment x.b = new). This value  1 let x = new in 1 let x = new in 2 x.a = new; 2 x.a = new; 3 x.b \n= new; 3 x.b = new; 4 permit x: 4 x.a = x.b; 5 {a,b,b.a},{a,b.a} in 5 permit x: 6 x.a = x.b; 6 {a,b,b.a},{a,b.a} \nin 7 x.a.a = 42 7 x.a.a = 42 (a) Valid access (b) Invalid access 1 let x = new in 2 let y = new in 3 \nx.a = new; 4 permit y: {a}, {a} in 5 permit x: {a}, {a} in 6 x.a = y; 7 x.a.a = 42 (c) Nested permissions \nFigure 5. Exercising the de.nition of l. PERMIT ' ''' f ' . ' = .[x . .(x) < [u . e]] F ' = if .(x)=(e, \nM) then F[u . (e, H)] else F ., R[u . Lr], W[u . Lw], F H; u +1; e . H ; u ; v ., R, W, Ff ' H; u; permit \nx : Lr,Lw in e . H ' ; u ' ; v Figure 6. Gathering foretime information. is written to x.a. The following \naccess to x.a returns (eb, [u ' . b]) according to case 1 of lu which governs that the paths stored in \nthe object take precedence over the actual path taken. For the .nal write access, the extended access \nmap [u ' . b.a] is checked against the set of write permissions and succeeds. In fragment (b), x.a = \nx.b is executed before the permit expres\u00adsion. Hence, x.a contains (eb, \u00d8) and the GET rule makes it \nreturn (eb, [u ' . a]) according to case 2 of lu. For the write operation, the extended access map [u \n' . a.a] is checked against the set of write permissions and fails. The code in Figure 5(c) exercises \ncase 3 of the de.nition of lu. After establishing the two permissions, the environment . is: [x . (ex, \n[u3 . e]),y . (ey, [u2 . e])] where the ui are sorted according to their indexes i. After the assignment \nx.a = y (with time stamp u4) the object in location ex is: {a :(u4, (ey, [u2 . e]))}. In line 7, x.a \nevaluates to [u3 . a] l (u4, (ey, [u2 . e])) =(ey, [u3 . a] lu4 [u2 . e]) =(ey, [u2 . e]) Observe that \ncase 3 of lu applies because u4 = u3. In conse\u00adquence, u3 vanishes from the domain of the map because \nthe ob\u00adject that was reachable via x.a before line 6 has become garbage. With this reasoning the update \nof x.a.a is permitted because it is equivalent to y.a and realizable in the heap after line 5.  3.4 \nPre-state Snapshot Our .rst technical result is a soundness results that underlines that our semantics \nadheres to the pre-state snapshot property (Sec. 2.3). It ensures that any value produced during evaluation \ncontains correct path information with respect to all relevant pre-states in the following sense. Consider \na reference value of the form v =(e, M) where M is a map from time stamps to access paths. For each time \nstamp u . dom(M) there is an access permission installed at time u for heap Hu with base object eu that \naffects the value v. The information contained in M is correct with respect to u if there is a path from \nthe base object eu to e along the properties of M(u) in the pre-state heap Hu. To formally de.ne this \nnotion, suppose the information about the pre-states and the base objects of all contract installations \nis gathered in a time-stamp indexed foretime map F : Stamp \u00ad(Loc \u00d7 Heap). It maps the time stamp u of \nthe installation of an access permission to a pair (eu,Hu),where eu is the location of the base object \nand Hu is the heap snapshot at that time. De.nition 3.1 Let F be a foretime map. A value v is F path \nconsistent if v =(., .x.e) and . is F path consistent or  v =(e, M) and, for all u . dom(M),if F(u)=(eu,Hu), \nthen there is a path from eu to e along M(u) in Hu.  An environment . is F path consistent if, for all \nx . dom(.), .(x) is F path consistent. Aheap H is F path consistent if all values stored in all object \nproperties are F path consistent. That is, for all e . dom(H) and for all p . dom(H(e)),if H(e)(p)=(u, \nv),then v is F path consistent. To gather the foretime map, a suitably extended evaluation judg\u00adment \n., R, W, Ff ' H; u; e . H ' ; u ' ; v is required. It records the base object and the heap snapshot at \neach successful contract installation in the foretime map F. Fig. 6 contains the correspond\u00ad ingly modi.ed \nPERMIT rule. The remaining rules for the extended judgment extend the ones for the original judgment \nin Fig. 3 by passing the foretime map in exactly the same way as R and W. Showing adherence to the pre-state \nsnapshot property amounts to proving that an evaluation that starts on a path consistent heap and environment \nproduces a path consistent heap and value. Theorem 3.1 Suppose that ., R, W, Ff ' H; u; e . H ' ; u ' \n; v. If . and H are F path consistent, then so are H ' and v. There is also an accompanying completeness \nresult that guaran\u00adtees that the M component of a reference value is non-empty if it has been accessed \nvia a pre-state path [24].  3.5 Stability of Violation Stability of violation is a property linked \nto the reference attach\u00adment property (Sec. 2.1). It states that a violation of an access per\u00ad mission \nis preserved (in a precisely de.ned sense) when performing the same computation on a heap with more aliasing. \nLet s .rst .x what we mean with more aliasing. If H1 and H2 are heaps, then H2 has more aliasing if it \nidenti.es locations that are distinct in H1 and merges the contents of the objects in these locations. \nThat is, if o ' and o '' are distinct objects in H1 which are merged to object o in H2,then o has all \nproperties from o ' and o '' . Properties present in o ' and o '' must have suitably related values that \nmap into the same value in H2. We call H1 a re.nement of H2 because it makes more distinctions between \nobjects. De.nition 3.2 Aheap H1 is a .-re.nement of heap H2, written as H1 I. H2,if . : dom(H1) . dom(H2) \nis a surjective mapping between heap locations and .e1 . dom(H1), o1 = H1(e1), o2 = H2(.(e1)): RH1 dom(o1) \n. dom(o2) (objects in the re.ned heap have fewer properties) and RH2 (.p . dom(o1)) o1(p)=(u1,v1).o2(p)=(u2,v2).u1 \n= u2 . v1 I. v2 A value is a .-re.nement of another, v1 I. v2 iff  GET-CRASH2 ., R, Wf H; u; e . H ' \n; u ' ;(e, M) R fchk M.p ., R, Wf H; u; e.p .R GET-CRASH3 ., R, Wf H; u; e . H ' ; u ' ;(e, M) Rfchk \nM.p ., R, Wf H; u; e.p .O PUT-CRASH3 ., R, Wf H; u; e1 . H ' ; u ' ;(e, M) '' '''' ., R, Wf H ; u ; e2 \n. H ; u ; v W fchk M.p ., R, Wf H; u; e1.p := e2 .W Figure 7. Essential crashing rules. RV1 v1 =(e1, \nM1) and v2 =(e2, M2) and e2 = .(e1) and M1 = M2,or RV2 v1 =(.1,e1) and v2 =(.2,e2) and .1 I. .2 and e1 \n= e2. An environment is a .-re.nement of another, .1 I. .2 iff RE1 dom(.1)= dom(.2) and RE2 (.x . dom(.1)) \n.1(x) I. .2(x). The reader might wonder about the implication in RH2.This choice allows the coarser \nheap H2 to contain a value which does not re.ne to all corresponding values in heap H1: for each object \nin H2, there may be any number of .-preimages of this object in H1. RH2 says that such an object need \nnot be consistent with all its preimages. This case can be detected by the condition u1 <u2: the shared \nversion of the object has been updated after one of its unshared preimages. The remaining case u1 >u2 \ncan never arise. We allow such inconsistencies in a heap re.nement because they only in.uence the semantics \nof a program if there is a sub\u00adsequent read operation that observes the inconsistency. In this case, \nthe criterion u1 <u2 detects the inconsistency. Having established the notion of heap re.nement, it remains \nto formalize running the same program on two heaps and compare the outcomes. To this end, it is not suf.cient \nto consider success\u00adful, terminating evaluations, but also evaluations ending in a con\u00adtract violation \nand interrupted evaluations. Figure 7 speci.es the key rules of three judgments of the form ., R, Wf \nH; u; e .i where i .{R, W, O}. Each judgment formalizes an interrupted evaluation. The superscript R \nindicates violation of a read permis\u00adsion (rule GET-CRASH2), superscript W indicates violation of a write \npermission (rule PUT-CRASH3), and superscript O indicates non\u00addeterministically giving up on a read operation \n(rule GET-CRASH3). The remaining rules(see [24]) are straightforward variants of the evaluation rules \nin Fig. 3 that propagate an error condition like an exception. Our theorem says that crashes due to violated \nread or write per\u00admissions are preserved when more aliasing is added. The main complication is that an \ninconsistent read operation (in the sense discussed after De.nition 3.2) in the version with additional \nalias\u00ad ing may lead to arbitrary behavior of the program, including non\u00adtermination. Therefore, the theorem \nconstructs a related execution up to the .rst inconsistent read. Its proof along with auxiliary de.\u00ad \nnitions may be found in our technical report [24]. Theorem 3.2 If H1 I. H2 and .1 I. .2 and .1, R, Wf \nH1; u; e .i (1) (for i .{R, W })then .2, R, Wf H2; u; e .j (2) [ e1[e2] ] = pRead([e1],[e2]) [ e1[e2]= \ne3 ] = pAssign([e1],[e2],[e3]) [ e(e1,...,en) ] = fCall([e],[[e1],...,[en]]) [ e.m(e1,...,en) ] = mCall([e],m,[[e1],...,[en]]) \n[ new e(e1,...,en) ] = cCall([e],[[e1],...,[en]]) [ for (var i in e) {s} ] = var o=[e]; for (var i in \no}) {if (mCall(o, hoP ,[i])) {[s]}}[ function f(x,...) {s} ] = var f = enableWrapper( function (x,...) \n{[s]}) Figure 8. Transformation rules (simpli.ed excerpt). /** (any) . any TESTS.c1 = ... // contract \nwith var f = enableWrapper( [$1.a.b.@] */ function f (x) {function f(x) { var z = pRead(x, a );var z=x.a; \nreturn pRead(z, b ); return z.b; }, [TESTS.c1]); }; Figure 9. Example of a transformation. such that \neither i = j or j = O and the derivation of (2) ends in an inconsistent read operation with respect to \n(1). Informally, the proof constructs a derivation of (2) by induction on a derivation of (1). As H1 \nI. H2, it is either the case that (2) always reads the same values from the heap as (1). In this case, \nthe derivation of (2) is isomorphic to the derivation of (1) and i = j. Otherwise, there is an instance \nof a GET rule in the derivation of (1) such that applying this rule as part of (2) would return a different \nvalue. A suf.cient criterion for this case is to check if u1 <u2 when reading the property as shown in \nRH2. In this case, we give up, emit a GET-CRASH3 rule instead of GET, and complete the derivation with \npropagation rules for .O . The theorem also holds in a language with conditionals as they can be simulated \nin the lambda calculus. If the language were extended with pointer equality, then a condition might turn \nout differently on H2 than on H1. However, Theorem 3.2 would still hold if a rule analogous to GET-CRASH3 \nwere introduced that allowed us to derive a .O judgment in (2) instead of executing an inconsistent pointer \nequality.   4. Implementation The implementation of the framework for monitoring access per\u00admissions \nis available on the Web 2. It consists of two parts. The .rst part is an off-line JavaScript-to-JavaScript \ncompiler written in OCaml. The second part is a JavaScript library that handles the dy\u00adnamic aspects \nof enforcing access permissions. The implementation supports the JavaScript language according to the \nstandard [11] except for prototypes and the with statement. As demonstrated in Sec. 2, contracts can \nbe attached to a function or method in a special kind of comment /*c ... */. The compiler transforms \nthe annotated code such that it mon\u00aditors access permissions at run time. Figure 8 illustrates some of \nthe transformation steps in a simpli.ed form. All operations that involve heap accesses, like reading \nand writing of properties, are redirected to library functions that dynamically manage access per\u00admissions. \nThese library functions introduce wrappers for references that remember the access paths of the wrapped \nreference. 2 http://proglang.informatik.uni-freiburg.de/jscontest/  Figure 9 shows an example of a \ntransformed function de.ni\u00ad tion. The library function enableWrapper creates a wrapper for f that generates \na fresh time stamp each time a function is called and marks the parameters with the corresponding access \npath informa\u00adtion at run time such that pRead can check if it has permission to read $1.a. The library \ncall to pRead returns a wrapper with the ac\u00adcess path $1.a for z. Reading the property b of z uses the \naccess path stored in the wrapper of z, extends it to $1.a.b, and checks if reading this path is permitted. \nThe permission is granted because the access permission attached to f is $1.a.b.@. Calls to native or \nnon-transformed code would fail if wrapped objects were passed. Because it is not possible to statically \ndecide which function is applied at a call site, the framework strips the access meta data from parameter \nobjects before passing them to the function. It stores the meta data on a global stack that is used to \nre\u00adwrap the objects if the callee itself is a transformed function. This approach is compatible with \nuses of eval: code generated by eval can execute, but its read and write operations are not monitored. \nFor interoperability with non-transformed code, it is also nec\u00adessary to remove wrappers when storing \nobject properties. To this end, an additional map ( infos ) is attached to each object. This map stores \nthe wrappers for each of the properties. The function pRead uses this map to reconstruct wrapped objects \nif necessary. As the library stores the access path information in the infos property of the objects, \nthis property must not become accessible to user code. Therefore, we provide a substitute for hasOwnProperty \n(hoP) that masks out the infos property. We also transform the statement for (var i in e) { s } to ensure \nthat internal proper\u00adties used by the implementation do not leak out to the program. Technically, this \nprotection is achieved by changing the body s to if (hoP(o,i)) { s }. The functions pRead and pAssign \nalso safeguard the special property infos . If native code or non-transformed code iterates over all \nproper\u00adties of an object, then it is not possible to hide the infos property. We are not aware of any \nway to reliably hide this property short of modifying the underlying JavaScript engine. However, in the \ncase studies that we performed the special property caused no problem. Some features of JavaScript are \nnot covered by the core calculus from Sec. 3, most notably prototypes and the with statement. In both \ncases, it turns out that write operations are not a problem: a property write never gets propagated to \na prototype object and the with statement only changes the meaning of property reads. A proper semantics \nof property reads in the presence of proto\u00adtypes would .rst check the permission on the original object, \ncheck the presence of the property, and then recursively continue with the prototype object, until the \nproperty is not found or there is no further prototype. Our present implementation does not implement \nthis semantics. It only checks the top-level permissions and relies on the built-in prototype resolution \nto do the actual read operation. Thus, it ignores restrictions imposed on a prototype object. A proper \nsemantics of with statements would have to proceed similarly, but traversing the stack of objects associated \nwith cur\u00adrently open with statements for each access to a local variable. Our implementation does not \nsupport with at all because our case studies do not require it. While an extension of the transformation \nto support prototypes and the with statement is possible, it does not appear sensible be\u00adcause it would \nrequire mimicking yet more details of the under\u00adlying execution engine (possibly introducing mismatches). \nHence, we are working on an implementation inside a JavaScript engine, where it should be simple to overcome \nthe restrictions of our transformation-based implementation with only a moderate impact on performance. \nFor example, hiding the metadata and ensuring that it does not affect program execution is straightforward. \nSimi\u00adlarly, it is possible to monitor property reads and writes of native type type+effect ful.lled contracts \nrejected contracts 1011 18.0 % 4607 82.0 % 711 12.7 % 4907 87.3 % reason for rejection (a mutant may \nbe counted multiple times) type contract failure signaled error browser timeout read violation write \nviolation read/write violation 2020 43.9 % 2034 44.1 % 553 12.0 % -0.0 % -0.0 % -0.0 % 1643 33.5 % 2136 \n43.5 % 243 5.0 % 1018 20.7 % 1606 32.7 % 1842 37.5 % Table 1. Testing random mutations for singly-linked \nlists. functions to fully support prototypes, eval, and dynamically loaded code. Due to the direct access \nto the scope chain the support for with statements is also simple inside a JavaScript engine.  5. Evaluation \nHow effective are access permissions for detecting programming errors? To answer this question, we hand-annotated \nthe code of several libraries and applications with contracts and ran it with monitoring enabled. We \napplied random code modi.cations [7] to check to what extent the enforcement of access permissions detects \nchanges in the program s behavior. 5.1 Case Study: Singly-and Doubly-Linked Lists and Trees The .rst \ncase study examines a collection of libraries implement\u00ading data structures like singly-and doubly-linked \nlists and search trees.3 The code sizes range from 200-400 LOC per library. As the results are similar \nfor all libraries, we discuss the singly-linked list implementation as a representative example. The \nlist interface comprises one constructor for list nodes and six methods to operate on a list: add, remove, \nitem, size, toArray, and toString. For each method we developed contracts with access permissions. Annotating \nthe code and implementing a custom con\u00adtract to drive the input generation took about one hour. The code \nwith all contracts is available on our webpage. From the implementation we derived about 5600 random \nmu\u00adtations and tested each mutant against the original contracts. The mutations affected operators, constants, \nand variable names. Each of the six functions was tested with 1000 randomly generated test cases and \nwas run in two con.gurations: type contracts for integer lists without effects: only violations of the \ntype contracts are detected, type+effect contracts for integer lists with effects: type and access path \nviolations are detected. Table 1 shows the results of the test runs. The ful.lled row counts mutations \nthat are not detected because the mutant ful.lls all six contracts. The rejected row registers mutants \nthat fail at least one contract. These two rows indicate the effectiveness of effect monitoring. Adding \naccess permissions to type contracts improves the detection rate for mutations from 82% to 87.3%, an \nimprovement of 6.4%. The remaining rows break down the reasons for the failure of a mutant. As there \nare multiple functions in a mutant, there are multiple reasons why a single mutant may fail so that the \npercentages do not add to 100%. We manually inspected the cases where the contract system did not detect \na mutation. In many cases the mutated code is seman\u00adtically equivalent to the original version, for instance, \nwhen x.p was changed to x.q, where both properties p and q were always 3 https://github.com/nzakas/computer-science-in-javascript \n  type type + effect ful.lled contracts rejected contracts 1148 38.9% 1807 61.1% 911 30.8% 2044 69.2% \nreason for rejection (a mutant may be counted multiple times) type contract failure signaled error browser \ntimeout read violation write violation read/write violation 872 48.3% 1052 58.2% 28 1.5% 0 0.0% 0 0.0% \n0 0.0% 866 42.4% 1037 50.7% 30 1.5% 202 9.9% 149 7.4% 349 17.1% Table 2. Testing random mutations of \nthe Richards case study. unde.ned. In other cases, the contract was ful.lled by a mutant be\u00adcause the \nmodi.cation did not change any property access or return value from a type perspective, for instance, \nreturn true is changed to return false. While these mutations change the semantics, a type or access \npermission contract cannot detect such changes. We also manually inspected ten randomly selected mutants \nthat timed out. In all cases, the mutation caused an in.nite loop.  5.2 Case Study: Richards and Deltablue \nBenchmarks A second case study was performed on the Richards and Deltablue benchmarks from the Google \nV8 benchmark suite.4 The Richards benchmark simulates the task dispatcher of an operating system. The \ncode comprises 29 functions in 650 LOC. A person without prior knowledge of the code under test provided \nthe contracts and implemented custom generators in about four hours. It took another two hours to develop \nthe access permissions. Table 2 shows the result of testing about 2950 mutated versions. These test runs \nexecuted 50 tests per function for each mutant to test for effect and contract violations. We chose to \nrun a smaller number of tests to reduce the overall run time and to check if a small number of test cases \nis suf.cient to obtain a high detection rate of mutants. Adding access permissions increases the detection \nrate from 61.1% to 69.2%, which amounts to a 13% improvement. This increase is quite surprising as the \npercentages of detected read or write violations are much smaller than in the linked-list case study. \nIn the Deltablue application (59 contracts in 670 LOC), the ac\u00adcess permissions led to an increase in \nerror detection from 75.6% to 84.2%, an improvement by 11.4%. In contrast to the other studies, Deltablue \ndoes not permit unit testing on a per function basis as it relies heavily on global state. Further details \nmay be found in the technical report [24].  5.3 Performance Evaluation All case studies and benchmarks \nwere executed on a Lenovo Thinkpad X61s notebook with a Core 2 Duo processor with 1.60 GHz and 2GB Ram \nrunning the Google-Chrome browser (7.0.517.44) on top of Linux version 2.6.35-23-generic. In this setting, \na test run of a mutant is about four times slower with mon\u00aditoring enabled than without monitoring (in \nboth case studies). To give ballpark numbers, running 1000 tests for each of the six functions of the \nlinked-list test suite takes about 6 seconds with monitoring compared to 1.5 seconds without. For Richards, \nrunning 50 tests for each of the 29 functions takes 1.85 seconds with monitoring compared to 0.5 seconds \nwithout. For the Richards benchmark we timed the original code (with\u00adout mutation) once with monitoring \nand once without to measure the slowdown for code that never violates the effect annotations. This experiment \nmasks out the effects of contract violations, which 4 http://v8.googlecode.com/svn/data/benchmarks/v6/ \n /*c ... with [this. root./left|right/*.value.@, this. root, this. root./left|right/*./left|right/] */ \nBinaryTree.add = function(elem) { ... } Figure 10. Contract of a binary search tree. cause the program \nto stop earlier on faulty mutants than on correct code. However, the slowdown is similar: running 1000 \ntest cases for each of the 29 functions took 32.4 seconds with monitoring en\u00adabled versus 7.4 seconds \nwithout, a slowdown factor of 4.4. 5.4 Example Contracts for Case Studies Figure 10 contains a representative \ncontract for an add method that inserts an element in a binary search tree. The method adds new elements \nby creating a new node object that is inserted into the tree at the appropriate place. Its contract reveals \nthat the method only reads and modi.es objects reachable via this. root and then following left or right \nproperties. It does not change the value property of any node that is already part of the tree, but it \nreads this data to .nd the place for the new node.  6. Related Work Access permissions are closely \nrelated to effect systems. Effect sys\u00adtems have been conceived for functional languages [19] to describe \nand infer the scope of side effects, with the goal of detecting paral\u00adlelizable code fragments and improving \nmemory management. There are too many papers on effect systems to do them all jus\u00adtice here. Greenhouse \nand Boyland [22] introduce effect annota\u00ad tions for Java which closely resemble our contracts. In contrast \nto our system, effects are collected for regions which comprise a set of objects. Their approach aims \nto track data dependencies of soft\u00adware components. The main differences to our work are that most effect \nsystems are integrated in type systems and thus geared to\u00adwards static analysis (whereas ours performs \ndynamic analysis) and that our prime motivation lies in the detection of software defects. The effect \nsystem proposed by Bocchino and coworkers [28] for deterministic parallel Java relies on a very similar \nnotion of effect, based on paths over regions (sets of instance variables). They use the effect system \nto statically prove the absence of data races. Our system might be extended to check this property at \nrun time. The static veri.cation system of Smans and coworkers [41] has a special acc predicate that \nhelps simplifying proof obligations for the frame problem in method calls. The argument to acc is an \naccess path similar to, but more restricted than the notion put forward in our work. A preliminary investigation \nsuggests that their static semantics agrees with our monitoring semantics, but further work is needed \nto work out the exact connection. Similarly related is work on ownership and aliasing control. Again, \nwith the exception of the dynamic ownership system of Boyland and coworkers [6], most ownership systems \nstatically im\u00ad pose tree-like ownership structures on object graphs [3, 10, 39, 46]. The main difference \nto ownership types is that our system is entirely access path-based whereas ownership types are context\u00adbased. \nFurthermore, some ownership systems forbid the mere exis\u00adtence of references, whereas access permissions \nforbid the traversal of certain paths. Effective ownership [33] does not restrict referenc\u00ad ing of objects, \nbut enforces the encapsulation of an object s repre\u00adsentation by con.ning modi.cations to the owner. \nBierhoff and Aldrich [5] de.ne a static checker for access per\u00ad missions in Java. It combines typestate \nand object aliasing infor\u00admation to design and verify protocols for safe object access. They also focus \non the correct usage of single resources. Their access permissions are statically veri.ed.  Deutsch \ns [8] analysis for sharing and aliasing is also entirely based on access paths. It is a static analysis \nphrased as an abstract interpretation of a storeless semantics. Run-time monitoring is an approach to \nproviding safety and se\u00adcurity guarantees. Erlingsson [13] provides an overview of such applications. \nAs a notable difference, security monitoring is mostly geared towards eliminating (sequences of) uses \nof undesired oper\u00adations and can often be implemented by .nite automata, whereas access path monitoring \nrules out undesired accesses and requires more speci.c implementation techniques to deal with aliasing. \nBrowserShield [40] provides run-time monitoring of JavaScript. BrowserShield rewrites code to redirect \ncritical operations accord\u00ading to user-speci.ed policies. The Google Caja project [20] em\u00ad ploys an online \ncompilation process of JavaScript code to a safe subset named Cajita which enforces certain security \npolicies. Maffeis and coworkers [34] combine several isolation tech\u00ad niques for restricting heap accesses \nof third-party code. They disal\u00adlow eval, function,and constructor within untrusted code and also rewrite \nproperty accesses with wrappers to enable run-time checks. These systems operate within the browser during \ninteractive user sessions and provide complete interposition. In contrast, our tool is focused on development \nand testing of applications. Finifter and coworkers [18] design a JavaScript heap analysis framework \nto detect information leaks. To prevent exploits, third\u00adparty code is restricted to a name space by pre.xing \nproperties with a unique identi.er. In contrast, we restrict accesses via path conditions. ConScript \n[37] enforces .ne-grained application-speci.c secu\u00adrity policies at run time by modifying a JavaScript \nexecution en\u00adgine. Compared to our approach, they have different goals and less overhead. Further related \nresearch deals with dynamic contract check\u00ading. Findler and Felleisen [16] develop dynamically checked \ntype contracts for Scheme. In a similar way, JSConTest [25] extends JavaScript with type contracts that \nare monitored dynamically and can be used to automatically generate random test cases for con\u00adtracted \nfunctions. Our paper extends their work with access per\u00admissions to check side effects of a contracted \nfunction. Program speci.cation frameworks like Spec# [4] or Eiffel [12] permit the formulation of access \npermissions as FOL-formulas in Hoare-style pre-and postconditions. Because specialized syntax is missing, \nthe annotation process is rather heavy-weight. Besides, these frameworks are geared towards full speci.cations, \nwhereas we are targeting partial speci.cations. JML [31] features an assignable clause to specify which \nob\u00adject .elds may be modi.ed during a method call, similar to our write permissions (read accesses cannot \nbe restricted). In contrast to our work, JML is mostly geared towards (static) program veri\u00ad.cation. \nOf the approaches that employ JML for run-time checks (that is, contract monitoring) only a few fully \nsupport assignable. Lehner and M\u00a8uller [32] provide such an implementation of run\u00ad time checks. Their \nimplementation relies on code rewriting, but the main contribution of their work is an ef.cient check \nof assignable clauses for dynamic data groups. The semantics of these checks is reminiscent of the location-based \nsemantics discussed in Sec. 1.3. Spoto and Poll [42] de.ne a static analysis for object-local assignable \nspeci.cations. They include alias information in their system by tracking what aliases are introduced \nwhen a .eld is modi.ed. Their analysis also seems to implement the location\u00adbased semantics.  7. Conclusion \nWe proposed a novel extension of software contracts with access permissions that specify the side effects \nof an operation in terms of access paths. We implemented monitoring for access permissions in JavaScript \nby a program transformation and demonstrated that this implementation has an acceptable overhead. As \na theoretical basis for the implementation, we developed a formalization that enabled us to cleanly specify \nthe interaction of monitoring and aliasing, to prove soundness of monitoring, and to prove stability \nof violation. Our case studies showed that the speci.cation of contracts with access permissions on an \nunfamiliar code base takes about 30\u00ad40 minutes per 100 LOC and that in return the number of bugs detected \nby contract monitoring increases between 6% and 13%, which is a remarkable improvement on type contracts. \nIn each case, the access permissions provided valuable insights in the behavior of the program. Hence, \naccess permissions could be a worthwhile extension of testing frameworks. A major design choice was the \nadoption of the path-based se\u00admantics because it behaves consistently with respect to static veri.\u00adcation, \nit guarantees stability of violation, and it is reasonably ef.\u00adcient. Although single read and write \naccesses are more expensive than for the location-based semantics, we believe that the poten\u00adtially unbounded \ntime for installing a location-based permission is not amortized by the subsequent exploration of the \nobject graph: We conjecture that only a small fragment of the objects affected by a contract is actually \nexplored, but we have yet to conduct an em\u00adpirical evaluation with realistic implementations of both \nsemantics. In future work, we want to pursue various directions. We be\u00adlieve that our approach is more \nwidely applicable to any object\u00adbased language, not just to scripting languages, but also to nomi\u00adnally \ntyped languages like Java and C#. In the latter cases, to avoid breaking encapsulation, it is likely \nnecessary to introduce concepts like regions or data groups analogously to other work in this area [22, \n28, 31]. In this context, it would also be interesting to investi\u00ad gate a mix of static checking and \ndynamic enforcement as has been done in work on manifest contracts [21]. Another obvious extension would \nbe a special treatment for effects on the DOM [30]. Because DOM structures are guaranteed to be trees \n(no aliasing!), many of the complications of general object graphs do not arise in the case of DOM structures. \nWe further plan to investigate the location-based variant of the monitoring semantics in the context \nof security and access control. For this application, it appears that many of our design choices have \nto be reverted: for reliable monitoring of access control policies the location-based semantics with \nlexical scoping of permissions along with a notion of path exclusions (negative permissions) seems to \nbe a superior approach. However, the path-based semantics can also be extended to reliably forbid access \nto certain objects, as shown in our technical report [24]. In any case, a browser-based implementation \nof access permission monitoring is required to further validate claims in this direction.  References \n[1] P. Abercrombie and M. Karaorman. jContractor: Design by contract for Java. http://jcontractor.sourceforge.net/, \n2003. [2] A. Ahmed, R. B. Findler, J. G. Siek, and P. Wadler. Blame for all. In Proc. 38th ACM Symp. \nPOPL, pages 201 214, Austin, USA, Jan. 2011. ACM Press. [3] J. Aldrich and C. Chambers. Ownership domains: \nSeparating aliasing policy from mechanism. In M. Odersky, editor, 18th ECOOP, volume 3086 of LNCS, pages \n1 25, Oslo, Norway, June 2004. Springer. [4] M. Barnett, K. R. M. Leino, and W. Schulte. The Spec# Programming \nSystem: An Overview. In CASSIS 2004: Construction and Analysis of Safe, Secure and Interoperable Smart \ndevices, pages 49 69. Springer, 2004. [5] K. Bierhoff and J. Aldrich. Modular typestate checking of aliased \nob\u00adjects. In Proc. 22nd ACM Conf. OOPSLA, pages 301 320, Montreal, QC, CA, 2007. ACM Press, New York. \n [6] J. Boyland, J. Noble, and W. Retert. Capabilities for sharing: A generalisation of uniqueness and \nread-only. In J. L. Knudsen, editor, 15th ECOOP, volume 2072 of LNCS, pages 2 27, Budapest, Hungary, \nJune 2001. Springer. [7] R. A. DeMillo, R. J. Lipton, and F. G. Sayward. Hints on test data selection: \nHelp for the practicing programmer. Computer, 11:34 41, April 1978. [8] A. Deutsch. A storeless model \nof aliasing and its abstractions us\u00ading .nite representations of right-regular equivalence relations. \nIn Proc. IEEE International Conference on Computer Languages 1992, pages 2 13, Oakland, CA, Apr. 1992. \nIEEE. [9] T. D Hondt, editor. 24th ECOOP, volume 6183 of LNCS, Maribor, Slovenia, 2010. Springer. [10] \nW. Dietl and P. M\u00a8uller. Universes: Lightweight ownership for JML. Journal of Object Technology (JOT), \n4(8):5 32, Oct. 2005. [11] ECMAScript Language Speci.cation, Dec. 2009. ECMA Interna\u00adtional, ECMA-262, \n5th edition. [12] Eiffel: Analysis, design and programming language, June 2006. ECMA International, ECMA-367, \n2nd edition. \u00b4policies: A retrospective. In Proceedings of the 1999 New Security Paradigms Workshop, \nCaledon Hills, Ontario, Canada, Sept. 1999. [13] U. Erlingsson and F. B. Schneider. SASI enforcement \nof security [14] M. F\u00a8ahndrich, M. Barnett, and F. Logozzo. Embedded contract lan\u00adguages. In S. Y. Shin, \nS. Ossowski, M. Schumacher, M. J. Palakal, and C.-C. Hung, editors, SAC, pages 2103 2110, Sierre, Switzerland, \n2010. ACM. [15] R. B. Findler and M. Felleisen. Contract soundness for object-oriented languages. In \nProc. 16th ACM Conf. OOPSLA, pages 1 15, Tampa Bay, FL, USA, 2001. ACM Press, New York. [16] R. B. Findler \nand M. Felleisen. Contracts for higher-order functions. In S. Peyton-Jones, editor, Proc. ICFP 2002, \npages 48 59, Pittsburgh, PA, USA, Oct. 2002. ACM Press, New York. [17] R. B. Findler, S. Guo, and A. \nRogers. Lazy contract checking for immutable data structures. In O. Chitil, Z. Horv\u00b4ath, and V. Zs\u00b4ok, \ned\u00aditors, Implementation and Application of Functional Languages, 19th International Workshop, IFL 2007, \nnumber 5083 in Lecture Notes in Computer Science, pages 111 128. Springer, 2008. [18] M. Finifter, J. \nWeinberger, and A. Barth. Preventing Capability Leaks in Secure JavaScript Subsets. In Proceedings of \nNetwork and Dis\u00adtributed System Security Symposium, pages 375 388. Internet Society, 2010. [19] D. Gifford \nand J. Lucassen. Integrating functional and imperative programming. In Proc. 1986 ACM Conf. on Lisp and \nFunctional Programming, pages 28 38, 1986. [20] google-caja: A source-to-source translator for securing \nJavaScript\u00adbased web content. http://code.google.com/p/google-caja/. [21] M. Greenberg, B. C. Pierce, \nand S. Weirich. Contracts made manifest. In J. Palsberg, editor, Proc. 37th ACM Symp. POPL, pages 353 \n364, Madrid, Spain, Jan. 2010. ACM Press. [22] A. Greenhouse and J. Boyland. An object-oriented effects \nsystem. In R. Guerraoui, editor, 13th ECOOP, volume 1628 of LNCS, pages 205 229, Lisbon, Portugal, June \n1999. Springer. [23] A. Guha, C. Saftoiu, and S. Krishnamurthi. The essence of JavaScript. In D Hondt \n[9]. [24] P. Heidegger, A. Bieniusa, and P. Thiemann. Access per\u00admission contracts for scripting languages \n(extended ver\u00adsion). Technical Report 264, Universitat\u00a8Freiburg, July 2011. http://proglang.informatik.uni-freiburg.de/jscontest/. \n [25] P. Heidegger and P. Thiemann. Contract-driven testing of JavaScript code. In Proceedings of the \n48th International Conference on Objects, Models, Components, Patterns, TOOLS 10, pages 154 172, Malaga, \nSpain, June 2010. Springer. [26] P. Heidegger and P. Thiemann. Recency types for analyzing scripting \nlanguages. In D Hondt [9]. [27] R. Hinze, J. Jeuring, and A. L\u00a8oh. Typed contracts for functional programming. \nIn P. Wadler and M. Hagiya, editors, Proceedings of the 8th International Symposium on Functional and \nLogic Program\u00adming FLOPS 2006, pages 208 225, Fuji Susono, Japan, Apr. 2006. Springer. [28] R. L. B. \nJr., V. S. Adve, D. Dig, S. V. Adve, S. Heumann, R. Komu\u00adravelli, J. Overbey, P. Simmons, H. Sung, and \nM. Vakilian. A type and effect system for deterministic parallel Java. In S. Arora and G. T. Leavens, \neditors, Proc. 24th ACM Conf. OOPSLA, pages 97 116, Or\u00adlando, Florida, USA, 2009. ACM Press, New York. \n[29] R. Kramer. iContract the Java design by contract tool. In Proceed\u00adings of the Technology of Object-Oriented \nLanguages and Systems, pages 295 307, Santa Barbara, CA, USA, 1998. [30] P. Le H\u00b4egaret, R. Whitmer, \nand L. Wood. W3C document object model. http://www.w3.org/DOM/, Aug. 2003. [31] G. T. Leavens, A. L. \nBaker, and C. Ruby. JML: A Notation for Detailed Design. In H. Kilov, B. Rumpe, and I. Simmonds, editors, \nBehavioral Speci.cations of Businesses and Systems, pages 175 188. Kluwer, 1999. [32] H. Lehner and P. \nM\u00a8uller. Ef.cient runtime assertion checking of assignable clauses with datagroups. In D. S. Rosenblum \nand G. Taentzer, editors, FASE, volume 6013 of Lecture Notes in Com\u00adputer Science, pages 338 352. Springer, \n2010. [33] Y. Lu and J. Potter. Protecting representation with effect encapsula\u00adtion. In S. Peyton Jones, \neditor, Proc. 33rd ACM Symp. POPL, pages 359 371, New York, NY, USA, Jan. 2006. ACM. [34] S. Maffeis, \nJ. C. Mitchell, and A. Taly. Isolating JavaScript with .lters, rewriting, and wrappers. In ESORICS 09: \nProceedings of the 14th European Conference on Research in Computer Security, pages 505 522, Saint-Malo, \nFrance, 2009. Springer-Verlag. [35] B. Meyer. Applying Design by Contract . IEEE Computer, 25(10):40 \n51, Oct. 1992. [36] B. Meyer. Object-Oriented Software Construction. Prentice-Hall, 2nd edition, 1997. \n[37] L. A. Meyerovich and B. Livshits. ConScript: Specifying and enforc\u00ading .ne-grained security policies \nfor Javascript in the browser. In IEEE Symposium on Security and Privacy, May 2010. [38] P. M\u00a8uller, \nA. Poetzsch-Heffter, and G. T. Leavens. Modular speci.\u00adcation of frame properties in JML. Concurrency \nand Computation: Practice and Experience, 15(2):117 154, 2003. [39] J. Noble, J. Vitek, and J. Potter. \nFlexible alias protection. In E. Jul, editor, ECOOP, volume 1445 of LNCS, pages 158 185, Brussels, Belgium, \nJuly 1998. Springer. [40] C. Reis, J. Dunagan, H. J. Wang, O. Dubrovsky, and S. Esmeir. BrowserShield: \nVulnerability-driven .ltering of dynamic HTML. ACM Trans. Web, 1(3):11, 2007. [41] J. Smans, B. Jacobs, \nand F. Piessens. Implicit dynamic frames: Com\u00adbining dynamic frames and separation logic. In S. Drossopoulou, \ned\u00aditor, 23th ECOOP, volume 5653 of LNCS, pages 148 172, Genova, Italy, 2009. Springer. [42] F. Spoto \nand E. Poll. Static Analysis of JML s assignable Clauses. In\u00adternational Workshop on Foundations of Object-Oriented \nLanguages, Jan. 2003. [43] J.-P. Talpin and P. Jouvelot. The type and effect discipline. Information \nand Computation, 111(2):245 296, 1994. [44] P. Wadler and R. B. Findler. Well-typed programs can t be \nblamed. In G. Castagna, editor, Proc. 18th ESOP, volume 5502 of LNCS, pages 1 16, York, UK, Mar. 2009. \nSpringer-Verlag. [45] D. N. Xu, S. Peyton Jones, and K. Claessen. Static contract checking for Haskell. \nIn B. Pierce, editor, Proc. 36th ACM Symp. POPL, pages 41 52, Savannah, GA, USA, Jan. 2009. ACM Press. \n[46] T. Zhao, J. Palsberg, and J. Vitek. Lightweight con.nement for Featherweight Java. In Proc. 18th \nACM Conf. OOPSLA, pages 135 148, Anaheim, CA, USA, 2003. ACM Press, New York.  \n\t\t\t", "proc_id": "2103656", "abstract": "<p>The ideal software contract fully specifies the behavior of an operation. Often, in particular in the context of scripting languages, a full specification may be cumbersome to state and may not even be desired. In such cases, a partial specification, which describes selected aspects of the behavior, may be used to raise the confidence in an implementation of the operation to a reasonable level.</p> <p>We propose a novel kind of contract for object-based languages that specifies the side effects of an operation with <i>access permissions</i>. An access permission contract uses sets of access paths to express read and write permissions for the properties of the objects accessible from the operation.</p> <p>We specify a monitoring semantics for access permission contracts and implement this semantics in a contract system for JavaScript. We prove soundness and stability of violation under increasing aliasing for our semantics.</p> <p>Applications of access permission contracts include enforcing modularity, test-driven development, program understanding, and regression testing. With respect to testing and understanding, we find that adding access permissions to contracts increases the effectiveness of error detection through contract monitoring by 6-13%.</p>", "authors": [{"name": "Phillip Heidegger", "author_profile_id": "81372593912", "affiliation": "University of Freiburg, Freiburg, Germany", "person_id": "P2991353", "email_address": "heidegger@informatik.uni-freiburg.de", "orcid_id": ""}, {"name": "Annette Bieniusa", "author_profile_id": "81372593203", "affiliation": "INRIA Paris-Rocquencourt and LIP6, Paris, France", "person_id": "P2991354", "email_address": "Annette.Bieniusa@inria.fr", "orcid_id": ""}, {"name": "Peter Thiemann", "author_profile_id": "81100458917", "affiliation": "University of Freiburg, Freiburg, Germany", "person_id": "P2991355", "email_address": "thiemann@acm.org", "orcid_id": ""}], "doi_number": "10.1145/2103656.2103671", "year": "2012", "article_id": "2103671", "conference": "POPL", "title": "Access permission contracts for scripting languages", "url": "http://dl.acm.org/citation.cfm?id=2103671"}