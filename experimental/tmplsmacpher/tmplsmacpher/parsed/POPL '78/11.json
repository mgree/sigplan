{"article_publication_date": "01-01-1978", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1978 ACM 0-12345-678-9 $5.00 Automating Proofs of the Absence of Common Runtime Errors Steven M. German \nAl. Laboratory Stanford University Stanford, Calif. 94305 and Division of Engineering and Applied Physics \nGraduate School of Arts end Sciences Harvard University Cambridge, Ma. 02138 The Runcheck Verifier is \na working system for proving the absence of common runtime errors. The language accepted is Pascal without \nvariant records, side effects in functions, shared variable parameters to procedures, or functional arguments. \nThe errors checked are 1) accessing a variable that has not been assigned a value, 2) array subscripting \nout of range, 3) subrange type error, 4) dereferencing a NIL pointer, 5) arithmetic overflow, and 6) \ndivision by zero. Hoare and Wirth s axiomatic definition of Pascal [61 does not reflect restrictions \non computation that result from certain elements of the computing environment, such as type definitions, \nfunctions with limited domains, and f%tcrs in the implementation of the language. To unify the treatment \nof these restrictions, Huet, Luckham, and Oppen [7] have developed an extended semantics of Pascal. In \nthe extended semantics, preconditions sufficient to guarantee error free execution are required before \neach program statement. The Run check verifier uses semantics based on this approach. The semantics makes \nuse of a special predicate, DEF(v), which intuitively is true if its argument has been assigned an initial \nvalue. To assure that the program does not evaluate an uninitialized variable v, the extended semantics \nrequires the precondition DEF(v) to be proved at every statement that evaluates v. Initialization checking \napplies to all data structures, and permits, for example, verification of programs that operate safely \non partially initialized data structures without accessing uninitialized portions. The user submits programs \nwith ENTRY, EXIT, and possibly INVARIANT assertions. The system automatically applies four different \nmethods for constructing or strengthening invariants, making it unnecessary for the user to supply complete \ninvariants. The methods are 1) analysis of arithmetic reia:ions on numeric variables, 2) programanalysis \nto find loops that initialize arrays, 3) propagation of assertions by the verification condition generator \n(VCGEN) loop and procedure call rules, and 4) strengthening invariants by analysis of unprovable verification \nconditions. Results obtained so far are (overflow not checked in some cases) 1) Programs that can be \nshown free of runtime errors given only ENTRY assertions include QUICKSORT, TREESORT, SHELL SORT, FAST \nLINEAR SEARCH, and BINARY SEARCH. 2) Given simple invariants, the system can verify slightly harder programs \nincluding a SPANNING TREE algorithm and the SCHORR-WAITE [101 list marking algorithm. This research was \nsupported by the Advanced Research Projects Agency of the Department of Defense under contract MDA 903\u00ad76-C-0206 \nand by the National Science Foundation under contract A4C.S 76-000327. 3) Programs such as FIND [51, \nEIGHT QUEENS [1 /], and list reordering and insertion with ROOT AND SENTINEL [181 have been verified, \nwith more complex user supplied invariants. The system always operates fully automatically. The program \nis first passed through the DOCUMENTER, which performs a shallow semantic analysis of each loop to generate \nvalid assertions about the simple numeric variables. Part of the documenter makes use cf VCGEN and the \nsimplifier. The system simplifier is the simplifier component of the Stanford Pascal Verifier. It is \na general purpose verification-oriented theorem prover. Since VCGEN S 100p rules have the effect of propagating \nassertions forward in the program and into loops, invariants provided by the user or generated by the \ndocumenter need not be as detailed as would be required by other verifiers, including the regular version \nof the Stanford verifier. The output of the documenter consists of the original program with added valid \ninvariant, called documenter comments, attached to the loops. After the program has been documented, \nthe verification conditions (VCS) are generated using the extended semantics. Thus all of the error checking \npreconditions are included in the VCS. Then the system attempts to simplify the VCS. If some of the VCS \ncannot be proven, this indicates either that the program is faulty or that the assertions are too weak. \nThe VC ANALYZER strengthens the invariant assertions in an attempt to make the VCS provable. This process \ncontinues until the program is verified or the user decides to stop. In [131, Sites presents techniques \nfor proving termination with absence of ru ntime errors for a class of flow graph programs. His techniques \nhave not been implemented. Suzuki and Ishihata [151 describe a special purpose system for checking that \narray subscripts are in the proper range. Our syslern handles a wider range of runtime errors. In the \ncaseof array subscript errors, our system is considerably more general and can verify man y programs \nthat cannot be handled by the methods of [15]. Inductive assertion generating methods are also discussed \nin [1 249161. ,>, > The documenter and VC analyzer are based on some new methods and some refinements \nof earlier methods. This paper is divided into five sections. Section 1 describes the extended semantic \ndefinition used in VCGEN. In addition to DEF, the predicates INRANGE, DEFRANGE, and MOREDEF, which are \nuseful for expressing error checking preconditions, are defined. The functions INIT and VALID are mappings \nfrom Pascal expressions to logical formulas containing DEF and INRANGE. INIT and VALID are used to define \nthe extended semantic axioms for assignment and WHILE statements. In addition to checking for error free \nexecution, the WHILE rule has special features that facilitate proofs by reducing the level of detail \nneeded in loop INVARIANT statements 1) Invariant assertions are never needed for variables that are not \nchanged on a loop. 2) Assertions about the extent of variable initialization before the loop are automatically \npropagated for variables that are changed. 3) Invariants may refer to the value of variables immediately \nbefore entering the loop, as well as the current value. Thus the input-output specifications of a loop \ncan be expressed con venien d y. 4) Documenter comments are assumed true without proof in the VCS. The \nsoundness of the documenter s analysis methods guarantees validity of these invariants. Section 2 presents \nthe documenter s program analysis methods for forming valid invariants. The documenter processes a program \nin three phases. Phase 1 constructs recurrence relations from symbolic execution of single loops and \nsolves them. Our use of recurrence relations differs from previous work [2,9] in that loops with conditional \nbranching are analyzed to find bounds for variables. (In a report [II that became available just before \nthe completion of this paper, Dershowitz and Manna present rules related to the counter analysis rules \nthat also handle conditional branching,) Use of the initial value feature of the WHILE rule facilitates \nconstruction of invariants in nested loops or with branching before the loop. In cases where the efficient \nbut specialized methods of phase 1 do not produce assertions for a variable, phase 2 tries to form assertions \nby proving that a given set of properties are invariants of a loop. The third phase generates in variants \nfor a special class of loops that initialize arrays. Section 3 describes the VC analyzer. Section 4 \ndiscusses the use of the verifier as a tool for debugging programs with potential runtime errors. Section \n5 contains conclusions. Our invariant generating methods are compared to other methods. O. Notation \n#T reference class [11 ], used to represent the set of values of a dereferenced pointer of type TT. #TcPa \nvalue of the variable P? where P has type tT. POINTERS.TO(.T) set of all pointer values of type TT. \nA.O an identified names with suffix _O, _l etc. are used by the verifier to avoid name conflicts with \nidentifiers appearing in programs. <A, [1], E> value of the array A after assigning the value E in the \nIth position. <R, .F, E> value of R after R.F:=E. <#T, cP3, E> value of #T after P? :=E, where P has \ntype ?T, Functions that have a Pascal type as their value TYPE(E) the type of an expression E. INDEX.TYPE(A) \nvalue is R if A has type ARRAY[R] OF S. RESULT_TYPE(F) function from function identifiers to types. \nPredicates on the type of an expression: IS_SIMPLE(E) true iff E does not have a compound type. ISA RRAY(E) \ntrue iff E has an array type, IS_RECORD(E) true iff E has a record type. ISJ?EFCLASS(E) true iff E is \na reference class. IS_CONSTANT(E) true iff E is a constant. Phrases used in a special sense The phrase \nsimple variable is synonymous with both variable identifier and declared variable. A selected variable \nis a component of a variable identifier (e.g. A [1] is a selected variable.). A Pa$ca/ variabie is either \na variable identifier or a selected variable [8]. When discussing a loop WHILE L DO B, we refer to L \nas the WHILE test, and TL as the condition for exiting the loop. 1. Extended Pascal Semantics The presentation \nin this section is based on che approach to extended semantics of [7]. We begin with an example which \nillustrates the general technique. Consider an assignment statement such as x:=y+ 1 where x and y have \ntype INTEGER. The familiar axiom defines the meaning of this assignment by the formula P$$+l {X:=y+l] \nP. The extended semantics adds a precondition, DEF(y), whicti states that the variable y must have a \nvalue before executing the statemenh DEF(y)APl~+ 1 {x:=y+ 1} P. Certain difficulties arise in extending \nthe semantic definition to properly reflect runtime restrictions related to the type environment of a \nprogram. It will be necessary in stating our semantic axioms to use the function TYPE(x), whose value \ndepends on the name of an expression x (and the declarations) but does not depend on the value of x. \nSimilarly, the values of INIT(<expression>) and VALID(<variable>) are determined by the program expression \nand not by its value. In Hoare-like semantic definitions, it is typical to use the names of variables \nto represent their values. This is often convenient, since it reduces the amount of notation in the definition, \nThere are occasions, however, in which it would be natural to refer to the names of variables as distinct \nfrom values. For various reasons, we have not introduced distinct names in our semantics. When a predicate \nor function symbol, such as TYPE, has the name of an expression as its argument, the symbol will be printed \nin lower case italics. With this convention, we must be careful not to substitute a value expression \nfor a variable appearing within an italicized formula TO prevent such substitutions, we will always immediately \nreplace italicized expressions by the values of the expressions, without itaiics. i Examples illustrating \nthis convention are given in section 1.4. We assume throughout that only programs that meet all the syntactic \nrequirements of Pascal [8] are being considered. In our implementation, the parser performs all of the \nrequired syntactic checking, including the usual compile-time type checks, so that improper programs \nnever reach other parts of the verifier. 1.1 Basic Predicates of Program States INRAN.GE(<expression>, \n<type>/ INRANGE(expression, type)= if type is a subrange [a..b) then a<expressionsb else TRUE DEF(cexrwession>) \nThe following axioms define the class of expressions satisfying 1 A more ~OmpIef~ discussion of the neec! \nfOt ~hk COnvenhI is contained in [7]. DEF. Note that axiom 3 also checks for zero division. Since all \nexpressions that are evaluated must be proven DEF, no other rule for zero division is required in the \nextended semantics. 1) IS_CONSTANT(e) a DEF(e) 2) DEF(a)ADEF(b) = DEF(a op b) where op is an operator \nin {+, -, *, =, *, <, $ AND, OR, NOT] 3) DEF(a)ADEF(b)Ab#O ~ DEF(a/b)ADEF(a DIV b) 4) DEF(a l)A...ADEF(an) \n~ DEF(f(al,...,an)) where f is a function identifier. In making this definition, we assume that functions \nalways terminate and return an initialized value if their arguments are initialized. (Checking of function \nENTRY conditions is performed by the function call rule, see section 1.3). 5a) DEF(a[i]) 3 DEF(i)AINRANGE(i,INDEX_TYPE(a)) \nwhere a is a Pascal variable of an array type, and i is an integer expression. 5b) DEF(*tCp~) ~ DEF(p)Ap#NIL \nwhere p is a pointer type Pascal variable. 6) DEF(e) ~ INRANGE(e,TYPE@?)) where e is an expression Pi:h \na subrange type. 7a) DEF(a) = (Vi DEF(i)tJNRANGE(i,INDEX- I YPE(a)) ~ DEF(a[il)) where a is a Pascal \nvariable of iin a.~ay type. ~b) DEF(r) = DEF(r.fl)A...ADEF(fn)n) where r is a Pascal variable of a record \ntype, and f 1,...,fn are the record field names. 7c) DEF(#t) \" (Vp c POINTERS-TO(*t)) (p#NIL ~ DEF(@p~)) \nDEFRANGE(m,n,a~ DEFRANGE is useful when dealing with partially initialized arrays. DEFRANGE(m,n,a) = \n(Vi mSiSnADEF(t) ~ Ez!?(a[il)). Our use of the predicate DEFRANCE in placed the explicitly quantified \nassertion is dictated by the desire to make the system completely automatic. At the present state of \ndevelopment in verification, one must choose to have either generality in specifying properties of data \nstructures, or automatic simplification of verification conditions. First order logic is convenient for \nspecifying many properties of complex data structures, but the performance of automatic theorem provers \nthat deal with quantified assertions is unsatisfactory for verification. Our choice is to define the \nmost commonly used assertions as special predicates. We provide the simplifier with inference rules that \nit can apply automatically to simplify formulas containing the special predicates. The user can invent \nnew predicates and supply additional inference rules, should they be needed to specify a particular program. \nMOREMEF(a.b) The formula MOREDEF(a,b) means b is at least as fully initialized as a. If a is a compound \nobject, then MOREDEF(a,b) ilmplies that a and b have the same type, The definition of MOREDEF consists \nof a base clause for simple types, and is extended recursively to compound types. MOREDEF(a,b) z (IS_SIMPLE(a)AS_SIMPLE(b) \n~ (DEF(a) = DEF(b))) A (IS_ARRAY(a) o TYPE(a)= TYPE(b) A (Vi lNRANGE(i,INDEX_TYPE(a)) ~ MOREDEF(a[i],b[i]))) \nA (ISRECORD(a) o TYPE(a) =TYPE(b) A MOREDEF(a.fl,b.f l)A...AMOREDEF(fn,b,f n)))) A (ISLREFCLASS(a) > \nTYPE(a) =TYPE(b) A (Vp c POINTERS_TO(a)) (MOREDEF(acp~,bcpn))) MOREDEF is helpful in making assertions \nabout monotonicity of initialization. Since our assignment rule requires the right hand side of every \nassignment statement to yield an initialized value, the extent of variable initialization cannot decrease \nduring program execution without violating the assignment rule, Because we prove at each assignment that \nan initialized value is used, it is safe to assume without further proof that variable initialization \ndoes not decrease over any sequence of statements, Formally, this principle can be stated as a rule of \ninference P {A} TRUE (Lo PAV=V {A] MOREDEF(V ,V) where V is a variable identifier. This rule of inference \nis used implicitly in the formulation of the semantic definitions of loop statements and procedure call. \n 1.2 Basic Functions for Forming Preconditions INIT(<exrxession>j We will say that an initialization \nerror occurs if a variable that hzs not been assigned a value is ew!wated or if an exprmsion involving \na function or Pascal operator is evaluated, and one of the arguments in uninitialized. If a component \nof a compound variable is used in an expression, the component must have been initialized. To assure \nthat a Pascal statement executes without an initialization error, we will require each evaluated expression \ncontained in the statement, including each evaluated subexpression, to have a well defined value. For \na program expression p, the precondition INIT(p) assures that p executes without an initialization error. \nThe formula INIT(p) is a conjunction of instances of DEF: DEF(p), and for each argument t to a function \nor operator in p, DEF(t). For example, if a statement contained the expression a[i][j+ 1], we would require \nthe precondition INIT(a[i][j+ 1]), which is DEF(a[i][j+ 1]) A DEF(i) A DEF(j+ 1) A DEF(j) A DEF(l). Under \nour definition of initialization error, a program expression such as x-x cannot be evaluated unless x \nhas a value. This is because INIT(x-x) = DEF(x)ADEF(x). Had we defined the precondition for absence of \ninitialization error in the program expression x-x to be merely ?2EF(x-x), evaluation of x-x would have \nbeen permitted even if x did not have a vakse. The reason is that in the logical theory underlying the \nsemantics, x stands for the value of the variable x, and x-x is equal to O, which is a constant, Therefore \nDEF(x-x) is always true. But because the fmgratrt exprwion x\u00adx is not the same as the program expression \nO, INIT(x-x) is true only if x has a value. The full initialization precondition tends to be tk$eritious. \nIf a variable is accessed many times on a program path, many instances of DEF will be produced by VCGEN. \nSince it is desirable to keep the verification conditions short, we have implemented a special simplifier \nfor DEF which uses the axioms to eliminate many of the trivial deductions. This simplifier, called DEFSMP, \nis applied to the VC after VC generation is completed but before the full simplifier is called. DEFSMP \neliminates repetition by traversing the VC in preorder and maintaining, at each level of logical implication, \na list of expressions assumed to be DEF. The list of known DEF expressions and the axioms are used whenever \nan assertion involving DEF is encountered. Clauses involving MOREDEF are also simplified. DEFSMP does \nnot attempt to simplify equality, inequality, or other operators, and so the nontrivial parts of the \nprecondition are left for the main simplifier. Here are some examples of DEFSMP inpt and output: DEF(0) \n=> TRUE DEF(j+f(j,3))ADEF(f(j,3))ADEF(j)ADEF(3) => DEF(j) DEF(x)ADEF(y) 2 DEF(x/yJ => EEF(x)ADEFfi) ~ \nyd DEF(v) ~ DEF(v[i+3;)ADZZ(i+ S)ADEF(i)ADEF(3) => DEF(v) 3 ~~~(i)A i Si+3Ai;-3S ~c~ (if v has type ARRAY[l:100] \nOF t) DEF(#t) n DEF(*tcpo)ADEF(p) .> DEF(w) o DEF(p)AP#NIL. VA LID(<variable>) The function VALID, which \noperates on a Pascal variable, is useful in extending the semantic rule for assignment. We will say that \na variable is VALID if it is a legal left hand side for an assignment statement. Any variable identifier \nis VALID. A selected variable is VALID if all of the array indexing and pointer dereferencing needed \nto determine the variable s address can be completed without a runtime error. Each array subscript in \nthe variable must be able to be evaluated (NW?) and the value must be in the proper range. Each poMter \nthat is dereferenced must be able to be evaluated and rntis$ be non null. Some examples of variables \nand their preccmditions to be VALID: (assume the variable a has type A RRAY[l: 1001 of t) a TRUE a[il \nDEF(i)A lsiAiS 100 pT.f DEF(p)Ap+NIL a[il? DEF(i)A l<iAiS 100ADEF(a[i])Aa[i]# NIL Note: The functions \nINIT and VALID can be defined precisely as recursive functions mapping Pascai expressions into logical \nformulas containing DEF and INRANGE. Refer to [7] for these definitions.  1.3 Other Preconditions on \nExpressions Overflow. To assure absence of overflow in an integer valued arithmetic expression a op b, \nVCG EN requires the precondition -MAXINT s a op b s MAXINT. The user must supply an entry assertion stating \nthe value of MAXINT (see example, section 1.5). This approach can be extended to deal with floating arithmetic \noverflow and underflow. Because there are some programs which one would not want to prove overflow free, \noverflow checking can be omitted by the user. For example, in a numerical routine such as matrix. multiplication, \none might choose to permit inputs that could potentially cause overflow, and rely on the computer hardware \nto signal errors at runtime, because the weakest sufficient preconditions on the input matrices are too \nIengthly to be useful. Function and Procedure Parameters. Checking of the range and initialization of \nactual parameters is included in the extended function and procedure call rules. Every value parameter \nmust have a value (DEF) and be in the proper range (INRANGE). Variable parameters must be VALID; they \ndo not have to satisfy DEF. The checking of the body of a function or procedure is performed by the extended \nfunction and procedure declaration rules. For further details of these rules and other aspects of the \nextended semantics, refer to [3,7]. Note: Since function calls are permitted in any expression, the function \ncall rule is incorporated in many of the other rules. For purposes of exposition, we have simplified \nthe rules by removing function call semantics, Thus the actual rules implemented in VCGEN and described \nin [31 are slightly different from the ones presented here. 1.4 Assignment Rule The extended semantic \nrule for assignment to a simple variable is init(e)tJNRANGE(e,ty,Oe( v))A@ {v:=e] Q The conjunct INRANCE(e,ty@(v)) \nis included in case v is a subrange variable. NcIte that as : ccmsequence of type checking performed \nby :k,e parser, the assignment rule can assum,e Lhat e and v either have the same type, or that the types \ndiffer only in that one or both is a numeric .wshrange. Hence the INRANGE check is sufficient at this \nstage to detect any remaining type disagreement. For selected variables, there are three cases. irztt(e)AINRA \nNGE(e,tyfle(a[i]))A~a~id(a[il)@/?a,[i],e> {a[i]=e] Q init(e)AINRANGE(e,ty# e(a.f))A~@~~d(a.f)A~Za,.f,e> \n{a.fi=e} Q Examples TYPE arr=ARRAY[x..y] OF [c..dl VAR i,JINTEGER; VAR s:[m..n]; VAR aarr; Consider an \nassignment to the subrange variable s, trzit(j+ l)dNRANGE(J+ l,tyPe(S))A~S+ I {$=j+ 1) Q The italicized \nexpressions are immec!iately replaced by their equivalents, resulting in DEF(j)ADEF( l)AINRANGE(j+ l,[m..n])@~+ \n1 {S i+ 1] Q After simplification of the precondition by DEFSMP and elimination of lNRANGE, we have DEF(j)Am<j+ \nlAj+ lSnA q +1 {S=j+ 1} Q When assigning to an element of the array a, subranges for both the index and \nthe element types will be checked. irzit(j)dNRANG E(j,t~/w(a[i]))fwdid(a[i])A~~a,[i],J> {a[il=J} Q After \nexpansion of INIT and VALID, this becomes DEF(j)AcSjAj<dADEF( i)AX<iAIS) AQ~a,[l])l> {a[ibJ} Q 1.5 WHILE \nRule The WHILE rule implemented in Runcheck is best introduced by developing it from simpler rules. To \nbegin, we assume the reader is familiar with the basic Hsmre iteration rule PoI,IAL {R) I,IA-L 3Q ----------------------------------( \n1.2) P {INVARIANT I WHL.,1 L DO B] ~ This rule can be extended to the:: tnat tht ezpre~sicn L always \nevaluates without a nsritime error. One approach to forming the extended rule is to require that init?-) \n>e satisfied when the loop is entered initially as well as at !Ee <rid of each iteration. Since this \nrequires init(L) to be an invariant, init(L) can be assumed to hold before each iteration and upon exit \nfrom the !~op. The following rulez adds irsit(L) to the user s invariant, muking it unnecessary for the \nuser to state assertions imptied by inlt(L) in his invariant. P > IAinit(L), (1.3a) IAinit(L)AL {B} IAinit(L), \n(1.3b) IAiTzit(L)A-.5 ~ Q (1.3C) -----------------------------------(1.3) P {INVARIANT I WHILE L DO B] \nQ (1.$d) Ru Ie (1.3) suffers from the familiar frame problem: assertions that hold before the loop cannot \nbe used to prove ( 1.3b) or ( 1.3e) unless they are included in the invariant L TO reduce this problem, \nwe reformulate ( 1,3) using the basic WHILE rule introduced by Suzuki [14,151. Suzuki s basic rule is \nP(x;v) n I(x;v} P(x;v)AI(x;v )AL( x;v ) {B(x;v )] I(x;v ) P(x;v)AI(x;v )A-L( x;v ) ~ ~x;v ) -------------------------------------------------------(1.4) \n P(x;v) {INVARIANT I(x;V) WHILE L(x;v) DO B(x;v)} ~x;v) where x is the set of variables that are not \nchanged by the body B, v is a set of variables whose value may change in B, and v is a set of new unique \nvariables [15]. The final rule is 2 This is essentially the same as the rule presented in [7]. P(x;v) \n2 I(x;v)Atnit(L(x;v)), P(x;v)d(x;v )AD(x;v )Airut(L(x;v )) A?7ZO?WdefJ(V,V )AL(X;V ) {B(x;v )] I(x;v \n)Ainit(L(x;v )), P(x;v)AI(x;v )AD(x; v )Ainit(L(x;v )) Arno7edefs(v,v )A-L( x;v ) = Qjx;v ) -------------------------------------------------------(1.5) \nP(x;v) {INVARIANT I(x;v) DCOMMENT D(x;v) WHILE L(x;v) DO B(x;v)] ~X;V) where D(x;v) is a documenter \ncomment, and moredefs(v,v ) is the conjunction MOREDEF(V l,V l )A...AMOREDEF(Vn,V;) ) for the variable \nidentifiers V lY,.,Vn in v. The documenter comment is assumed true without proof in the VCS, because \nthe documenter guarantees its validity. The moredefs clause is justified by (1,1), In this clause, ( \n1,5) goes further than (1.4) in eliminating the frame problem, by using hmain siepmdenf properties to \npropagate assertions knJWn before ths ioop, even for variables that are changed. Example: The following \nprogram takes an array A of real numbers, uses the variable S to sum the elements of A in the subscript \nrange [1..NI, and then divides S by N. The user has supplied an ENTRY assertion stating thacA, I, and \nN have vahses before executing the program, that F;is ? 1, and tilat N is between 1 and 100. The last \nclause of the ENTRY assertion sets -(N+ 1) to N+ 1 to be the legal range for arithmetic results without \noverflow. The EXIT assertion states that T hm a value. The user s INVARIANT assertion of TRUE contains \nno semantic information; ii is included only to satisfy the syntax requirements of the verifier. The \nprogram suppiied to the Runcheck verifier consists of the utllhhcized lines as shown below. The lines \nin italics represent additions made =ti:omatically by the docurrte:.ter. Throughout this paper, we will \nfollow the coi?ventio-% of sk.cwirig the documenter s ootput in italics. Tile dwmente: has introduced \na new variable, 1 , tostand for the value of I befme entering the loop. Note that although I is a v varid?t \nlz (1.5], 1 is m x variable. The documenter s assertion, 1 <1, states that the vahse of I is increased \nby the loop. Assignment statemm:ts intrw~tzced by the documenter will contain an arrow (+) instead G; \nthe usual assignment operator (:=) to distinguish them from Assignment statements that are part of the \noriginal program: beca~se documenter assignments are present only for specification purposes, they are \nnot checked for runtime errors. PASCAL TYPE ARR=ARRAYII:IOO] OF REAL; VAR MAXINT:INTEGER; VAR I,N:INTEGER; \nVAR S,T,REAL; VAR A:ARR; ENTRY DEF(A)ADEF(I)ADEF(N) A]sIA1<NANsIOOAN+lSMAXINT; EXIT DEF(T); BEGIN \nS:=o; 1 *I; INVARIANT TRUE DCOMMENT 1 s1 WHILE IsN DO BEGIN S:=S+AII1 1:=1+1 END; T:=S/N; END. After \nanalysis by the documenter, the program is p~sed to VCGEN, Shown below is the verification conditkmproduced \nafter DEFSMP. al (DEF(A) A a2 ~~F(l) A a3 DEF(N) A a4 1<1A a5 l<NA a6 N<1OO a7 N+lsMAXINT 8> b9 (I_TAG(G \n1488) A b10 DEF(I_l) A bll DEF(S_l) A b12 IsI_] b!3 1-lsN A b14 T.TAG(G1489) 15 2 c16 lsI_l A C17 I-l~~@A \nc18 1.1+ lsMAXINT A C19 -l* MAXINTsI_l+ 1) A d20 (1-TAG(G 1487) A d21 DEF(I_O) A d22 DEF(S_O) A d23 I<~_O \nA d24 N<I_O A d25 T_TAG(G1490) 26 e27 = DEF(S_O/N))) The lines have been lettered for reference to groups \nof lines, and nulmbered for reference to individual lines. Obse.we that the verification condition has \nthe form (ao((b3c) A(d oe))), Part a is the ENTRY assertion, The implications bnc and doe are the VCS \nfor the path around the loop and the path to the exit, respectively. The atomic formulas involving I_TAG \nand T_TAG are for the VC analyzer and do not concern us here. New variables I_O, S.-O, I_l, and S_l have \nbeen introduced to represent the values of I and S inside and after the loop, The new variables are DEF \nbecause I was initially DEF, and S was assigned the value 0. The assertions at (10-I I, 2 i-22) res~it \nfrom simplification by DEFSMP of instances of MOREDEF (MOREDEF(I,I_O), MOREDEF(o,s-o) ac.) h the WHILE \nrule. The documenter s assertion 1<1 appears with I instantiated to I and I instantiated as either I_O \n(exit path -at 23) or I_] (loop path -at 12). Lines (13, 24) contain the WHILE test. Since I and S are \nDEF on the loop, the only error checks remaining in the VC for the loop path are the array subscript \n(trzit(AIIl)) at ( 16-17) and the overflow check on 1+1 (18-19). The entire VC simplifies to TRUE, wing \npart 3 of the definition of DEF to prove DEF{S.JIN) (27). 2. The Documenter This section of the paper \nis divided into three subsections corresponding to the three phases of the documenter. The input program \nis first processed by the counter analysis phase, then by the second, or Wal invariant, phase, and finaily \nby the array initialization phase. Each phase applies a set of rules for generating valid invariants \nfrom the program and iti entry assertions. The output of die documenter consists of the program and the \nvalid loop comments produced by each phase. 2.1 Counter Analysis Counter analysis attempts to extract \ninformation from the assignments made to a variable on a single loop, wirlmur considering the initial \nconditions of the loop or the conditions controlling branching within the loof.3 The first step in counter \nanalysis is to introduce a new unique variable to act as an iteration index for the loop. The variable \nis initialized to O immediately before the loop and is incremented by 1 at the end of the body. Example: \nirtdexl@O; INVARIANT TRUE DCOMA4ENT indexl>O WHILE isn DO BEGIN IF p(i) THEN BEGIN J=j-l; rn.=2*m END \nELSE BEGIN index2+0 INVARIANT TRUE DCOMMENT index2k0 WHILE q(j) DO BEGIN END; i:=i+k index l+indexl+i; \nEND. The second step in cotsnter aoa~ysis is to construct for each variable a than.ty trector which \nrepresents the effect on the variable of a single iteration M the locp body. The change vector for a \nvariable v cm??a.im expresskns for the possible values of v after a single iteration Cf the body, expressed \nin terms of variabie vahses at the beginning of the iteration. There is one change ezpres:ion in a change \nvector for each path through the body. The paths are Ii*ted in a canonical order determined by the branching \nstructwe of the loop body. In the previous example, the change vector for i is [i+k, i+kl, and the change \nvector for m is [2*m,, r.?j, On the inner loop, the change vector for j is [j-2]. On the cuter loop, \nthe change vector for j is [j-1, j_O] where j_O is A vlriable that represents the value of j upon leavlng \nthe irmer kmp. The final step of counter analysis produces assertions by appO ing a small set of rules \nwhich perm~it vaiid in $ ari~nts to be inferred from the change vectors, The ru?es currently in use have \nthe restriction that they do not apply to a variable v if it is not possible to put all of its change \nexpressions Vi into the form Vi= VOp Ci where op is an arithmetic operation (+, x, /, DIV) which is the \nsame for all Vi, and each ci contains only constants and variables not changed in the loop. In the previous \nexample, this restriction means that counter analysis would not produce assertions for the variable j \non the outer ~oop, but an assertion would be generated for the inner loop. In describing the rules, we \nwill refer to variables v and w, with change vectors V and W, respectively. The change expressions for \nthe iQ path will be Vi and V?i, The variables v and w are 3 But see section 2.la, in which these restrictions \nare removed. the values of v and w immediately before entering the loop. Variables c, Ci, and k stand \nfor expressions whose values do not change on the loop. The variable named -is the loop index for the \nloop under consideration. Each rule consists of a condition that must be satisfied, followed by the invariant \nthat is generated. premiss on ch amze ex rm-essions => documenter comment 1a) for all i, Vi=v+c => v-v \n=c*index. 1b) for all i, Vi=v*c or Vi~v/ct-l => v=v $ctindex. lc) for all i, Vi=v div c => v=v div c?index. \n2a) for all i, Vi=V+Ci => v-v 2Min{ci]*index v-v < Max{ci}*index 2b) for all i, Vi=v*ci and Min{ci]~O \n=> sign(v )*v~v *sign(v )* Min{ci}?index sign(v )xvs v xsign(v )*Max {ci}tindex where sign(x) is defined \nby IF x<O THEN -1 ELSE 1. 2c) [analogous rule for division]. 3) for all i, Vi=v+ci and Wi=w+k*ci => k*(v-v \n)=w-w . 4) If there are paths on which neither v nor w is changed, delete elements from both change vectors, \ncorresponding to the paths on which neither variable is changed. Then introduce a new index to represent \nthe number of iterations on which either v or w is changed, and apply the other rules to form invariants. \nWhen rule 1a is applied to a variable v, the documenter eliminates the index from the program, since \nindex= (v-v )/c, Remark: The current set of rules is not intended to be complete in any sense. In practice, \nthe rules seem to be adequate for runtime error checking. In situations where the rules do not aPPIY, \nthe necessarY invariants are often produced by another phase of the documenter, or by the VC analyzer. \nExample 1: INVARIANT TRUE WHILE i<n DO BEGIN IF p(i) THEN i:=i+ 1 ELSE BEGIN j=j-~ fi=i+2 END; END; Change \nvectors i: [i+ 1, i+21 J [j, j-21 Documenter comments produced: index: index>O i: index <i-i A i-i s2*index \nJ -2*indexsj-j A j-j so To analyze this example, the system introduces an iteration index, forms ;~e \nchange vt?ci~r$ as~ chessapplies ruk? Za to Qocl? i and j. The assertions produced appear to be weak. \nimcause they do not give an upper botmd m i or a !ower 5xmd an ;. However, inside the loop, i<n is true \nbecatxe J the WHILE test.4 This implies an upper bound for index, index si-i AiSn => index< n-i . The \nupper bound on index sets a lower bound on j-j , index<n-i A -2*index<j-j => -2(n-i )sj-j . The documenter \ns assertions constrain the value of j even in the absence of specific initial values for i and j. For \ninstance, suppose the only assertions known true before entering the loop are i>O and jzO, so that j \nwill have a lower bound of -2nsj when i<n. ASSERT i?o A @ INVARIANT TRUE WHILE isn DO BEGIN IF p(i) THEN \ni:=i+ 1 ELSE BEGIN j=j-~ i:=i+2 END; END; The documenter does not attempt to use the assertions known \nbefore the loop to directly express the lower bound on j. Instead, since the documenter comment is an \nassertion expressed in terms of i, i , j, j , and index, and VCGEN identifies occurrences of i and j \npreceding the loop with i and j , the VC for the loop body will contain in its premisses all the information \nneeded to deduce any consequence of the bounds on j. It is easier to construct assertions pertain ing \nto the input-output characteristics of the loop than to form equivalent assertions that do not use i \nand j as variables. Example Z FOR i:= 1TO 100 DO BEGIN IF p(i) THEN $=j+k ELSE BEGIN m:=m+1;n:.2$n END; \nJ=]-l END; Change vectors i: [i+l, i+ll j [j+k-1, j-l] m: [m, m+1] n: [n, 2*nl Documenter comments produced: \ni: O<i-1 A i-1<100 j: min(-1, k-])*(i-1)<j-j A j-j <max(-], k-I)*(i-1) m: O<m-m A m-m si-1 n: n=m *2t(m-m \n) Since the variable i is incremented by 1 on each iteration, the documenter can express the iteration \nindex as i-i . The FOR loop assigns the value 1 to i , so index=i-1. Thus i-1 is substituted where index \nwould have appeared in the documenter comments. The invariants for j and m are produced by rule 2a. Evaluation \nof the terms min(-1, k-1) and max(-1, k-I) is not attempted by the documenter, because the values are \ndetermined completely by the context before the loop and counter analysis is concerned only with input-output \nrelationships. Since m and n are both unchanged on the first path through the body, the documenter uses \nrule 4 to consider the effect of the second path 4 In this example, the second phase of the documenter \nwill propose i<n+2 as a trial invariant. If conditions before entering the loop allow i<n+2 to be proven \ntrue initially, the documenter will have established an upper bound on i for ell paths. alone. The number \nof executions of the second path can be expressed as m-m . This expression is used for the index in rule \nlb to form the invariant for n. An invariant for n can also be derived from rule 2b, but in cases where \npart or .wk i is apphcable, rule 2 is not used. Example: SHELLSORT  This program is a version of SHELLSORT. \nThe user supphes only an ENTRY assertion saying that the array A M fully initialized, the integer N is \ninitialized and z 1, and for overflow checking, MA XINT?N+ 1. The documenter produces assertions sufficient \nto prove absence of subscript and overflow errors. Notice that it is nontrivial to check the array accessesAII] \nand A [I+MI on the innermost loop, because of the need for facts from the outer loops. The range of I \ndepends on J, which depends in turn on K, which depends on N and M, VAR N,MAXINT:INTEGER; TYPE ARR=ARRAY[l:N] \nOF INTEGER; PROCEDURE SHELL(VAR A:ARR~ ENTRY DEF(A)ADEF(N)A lsNAMAXINTzN+ 1; EXIT TRUE; LABEL 1; VAR \nI,J,K,M,W:INTEGER; BEGIN M:=N DIV ~ IN DE X1+O; M *M; INVARIANT TRUE DCOMMENT M=M DW EXP(2,1NDEX1) A \nO<lNDEX1 WHILE M*O DO BEGIN K:=N.M; FOR J:= 1 TO K INVARIANT TRUE DCOMMENT l<J A J<K+l DO BEGIN I:=J; \nIN DEX2+-O; se-l; INVARIANT TRUE DCOMMENT I-I =-1NDEX2*M A 051NDEX2 WHILE Izl DO BEGIN IF AII+M]?AII] \nTHEN GO TO 1; W:= AII]; AII]=AII+MJ AII+M]:=W; 1:=1-M IN DE X2+1 ND EX2+1; END; 1: END; M:=M DIV ~ IN \nDE XR-INDEX1+l; END; END; On the outer loop, the variable M IS divided by 2 on each iteration, so rule \nIC is applied, The upper bound for J of JsK+ 1 on the FOR loop is produced by a phase 2 rule, ,4s in \nall FOR loops, the documenter uses one of the original variables to express the iteration index, The \ninvariant for I on the inner WHILE loop is produced by rule la, With these assertions, the system is \nable to prove absence of subscript and overflow5 errors. 2.la An Extension of Counter Analysis 5 The \niteration index variables are not checked for overflow because they are present for documentation only. \nOne of the Ilmltatlons of counter analysis H that it does not make use of information from the program \ncontext w;Ier. it applies the rules for change expressions. Assertions known to hold before entering \nthe loop, previously known mvariants for the loop, and predicates known to hold on paths within the loop, \nall place constraints on the change expressions which may be useful m applying the rules. For example, \nconsider the effect of the following pair of nested FOR loops, which repeatedly adds y to the variable \nx: x +; FOR 1:=1 TO n INVARIANT TRUE DCOMMENT Isi A isn+l DO BEGIN X +x; FOR j= 1 TO k INVARIANT TRUE \nDCOMMENT x-x = (j-l)*y A Kj A j<k+l DO X:=X+Y END; Since the inner loop increments x by y on each iteration, \nrule la applies. The change expression for the outer loop, however, is simply a new variable x_O, because \nx is changed on the inner loop. On the outer loop, the inner loop invariant and exit test can be combined \nto give a relationship between x and x_O x_@x=(j-l)*y A lsj A J<k+ 1 A -(jSk) => x_O=x+k*y. Once this \nrelationship is known, rule la can be applied to the outer loop, because x+kxy is of the forlm X+C. Rule \nla gives the invariant x-x = (i-l )xkxy. The difficult aspect of automating this use of predicates is \nthat simplification is needed before it is possible to determine which constants will allow the analysis \nrule to apply. A specific goal for the simplifier cannot be stated beforehand. We are currently designing \nan implementatmr of counter analysis which explolts the organization of the Stanford Pascal Verlfler \ns simplifier [ 12]. The simphfier cgeratss in part by fmdmg, in a particular theory, all of the consequences \nof a given set of assertions. Thus It w]lI be possibte to sm!mm% ?mFlication of the analysis rules to \nchange express~ons w~tt. res~ect ~o the context, by first asserting to the slmphfier al! ~f the :redicates \nknown to hold in the program context, and ther. sewchmg the resulting simplifier database of consequences \nto ds~ermme the correct constants. 2.2 Documenter -second phase The second phase of the documenter attempts \nto extend the documentation on each loop by proposing and testing additionril rriat mvarlants for numeric \nvariables. Each trial invariant proposed is tested by generating and proving verification conditions. \nUse of the general theorem prover makes the second phase slower but more thorough than the fust phase. \nTwo types of invariants are proposed during the second phase 1) For each numeric variable that cannot \nbe ar.alyzed by the counter analysis rules, phase two proposes invariarts stating that the value of the \nvariable is weakly increased (i.e. increased or left unchanged) or decreased by the loop. Even in cases \nwlhere the pattern of changes to a variable ]s relatively complicated, 1 may be possible to prove that \nits value on the loop is always larger or DCOMMENT, LOW SLOW A HIGH< HIGH always smaller than the initial \nvalue. The resulting assertions WHILE LOW<HIGH DO are often useful for runtime verification purposes. \nBEGIN 2) Certain other invariants are proposed, depending on the form of the loop exit condition. The \nremainder of this section presents the details of the in vari an ts proposed in each of the two categories. \n 2.2a Increasing or Decreasing variable test To test whether a variable v changed by a WHILE statement \nis increasing or decreasing, the system attempts to prove the formula P {v *v; INVARIANT V R V DCOMMENT \nD WHILE L DO B} TRUE where P is an assertion known to be true before executing the loop. R is a relation \nsign, either s or ?. v represents the value of v before entering the loop. D is a documenter comment \nalready known to be valid. The clause v R v is the trial invariant. If the proof is successful, the trial \ninvariant is added to the documenter comment. This test does not require v to be changed monotonically \non every iteration; it is sufficient for v to remain larger or smaller than v . The proof of a trial \ninvariant is done in a special documenter Pascal semantics that does not check for runtime errors. This \napproach is sound, because the verifier proves absence of runtime errors after the documenter is finished. \nWhenever a trial invariant is proven valid, there is a possibility that other trial invariants that previously \nfailed to verify will be provable with the stronger documenter comment. A new invariant on a loop W may \nassist other invariants either on W or on other loops contained in the body of W, or on loops following \nW in the program. To take advantage of a new invariant, the documenter re-tests some trial invariants \nthat failed previously. Since it is time consuming to test trial invariants, it is crucial to have a \ngood mechanism for deciding which invariant to try next. Refer to [3] for details of our implementation. \nExampla Binary Search In this example, phase two proves that the loop increases the variable LOW and \ndecreases the variable HIGH, so the assertions LOW SLOW, HIGHsHIGH are added to the program. TYPE NARRAY=ARRAY[l:N] \nOF INTEGER; PROCEDURE BINSRCH(A:NARRAY; M,X:INTEGER; VAR Y: INTEGER~ ENTRY 1<NAMAXINT>2*N+1; EXIT DEF(Y} \nVA R LOW,HIGH,MID:INTEGER; BEGIN LOW:=l; HIGH:=N; LOW +LOW; HIGH +-HIGH; INVARIANT TRUE MID:=(LOW + \nHIGH)DIV z IF X<AIMID] THEN LOW:= MID+ 1 E,LSE HIGH:= MID END; IF X= AILOW] THEN Y:= LOW ELSE Y:=O END: \nThese assertions are sufficient to verify the absence of subscripting and overflow errors in the loop, \nbut verification of the IF statement after the loop requires an additional assertion to show LOWSN. We \nwill return to this example in section $ to show how the VC analyzer strengthens the invariant. 2.2b \nExtracting Invariant from Exit Tests We have seen that counter analysis attempts to express the input-output \nrelations of a loop without regard to the conditions under which the loop terminates. Typically, the \noutput of counter analysis contains assertions relating the values of program variables to a loop index \nrepresenting the number of iterations of the loop, with an additional assertion stating that the index \nis ? O. The loop exit heuristics complement the other components of the documenter by attempting to form \ninvariants that are consequences of the termination condition. At present, the documenter has two rules \nfor constructing trial invariants frnm loop exit tests Both are based rsn the simple intuition that if \na loop is caused to terminate by a certain expression s reaching a boundary value, then it may be an \ninvariant of the loop that the expression is always on one side of the boundary. 1) If the condition \nthat causes a loop to be exited contains a numeric equality disjunct e=O, then the trial invariants esO, \ne>O are considered. 2) If the condition that causes a loop to be exited contains an inequality disjunct \ne>O, the documenter tries to find a constant expression c s.t. e<c is invariant. One case in which there \nmay be a c is when all of the change expressions Ei for the expression e are functions of e and constants, \nfor all i, Ei = fi(e, [i), and each fi is monotonically increasing in e. In this case, our choice for \ntrial invariant will be e<Max{ fi(O, ci)). Thelimiting factor in our current implementation of the rule \nis that the system can determine that the Ei are functions of e and constants only in a restricted case. \n Example: QUICKSORT PASCAL TYPE RARRAY=ARRAY [1:1001 OF REAL; PROCEDURE QUICKSORT(VAR A:RARRAY; L,R:INTEGER} \nENTRY DEF(A) A(L<R ~ (1sLAL<1OO A 1sRARs106)); EXIT TRUE; VAR X: REAL; VAR LEFT,RIGHT:INTEGER; BEGIN \nIF L<R THEN BEGIN LEFT:=L; RIGHT:=R; X:=AIL1 LEFT * LEFT; RIGHT * RIGHT; INVARIANT TRUE DCOMMENT LEFT \nsLEFTARIGHTsRIGHT WHILE (LEFT< RIGHT) DO BEGIN RIG HT +RIGHT; INVARIANT TRUE DCOMMENT RIG HTsRIGHT \nALEFTs RIGHT WHILE (A IRIGHT]zX) AND (LEFT< RIGHT) DO RIGHT: =RIGHT-l; AILEFT]=AIRIGHT~ LEFT +-LEFT; \nINVARIANT TRUE DCOMMENT LEFT sLEFTALEFTs R[GHT WHILE (A[LEFT]sX) AND (LEFT< RIGHT) DO LEFT: =LEFT+ 1; \nAIRIGHT]=AILEFT] END; A[LEFT]:=X; QUICKSORT(A,L,LEFT-lk QUICKSORT(A,LEFT+ l,R} END; END. The user supphes \nonly an ENTRY assertion saying that the array A has a value, and that the integer parameters L and R \nare in the proper range if L<R. Since L and R are value parameters, they are assumed to be DEF at the \nbeginning of QUICKSORT, and on each recursive call, the actuals for L and R are proven DEF. The documenter \ncomments RIGHT< RIGHT and LEFT sLEFT on the inner loops are produc~d by counter analysis. Using these \nassertions, the Increasing or decreasing variable test produces the assertions for the outer loop, stating \nthat LEFT is increasing and RIGHT is decreasing. The remaining assertions come from the loop exit test \nheuristic. Because the condition for exiting the first inner WHILE loop contains the disjunct LEFTzRIGHT \n= LEFT-RIGHTaO, and the change expression for LEFT-RIGHT is f(LEFT-RIGHT) = LEFT-(RIGHT-1) = f(e) = e+ \n1, which IS increasing in e, the inequality LEFT-RIGHT<l is tested as a trial Invariant. It is true \ninitially each time the first inner loop is reached, because the WHILE test of the outer loop is LEFT< \nRIGHT. Therefore it is attached to the loop as a valid assertion. On the second inner loop, the same \ntrial invariant is produced m exactly the same way, and It 1s verified initially using the invariant \nof the first inner loop. In thn example, the assertions produced by the documenter are not sufficient \nto verify absence of runtime errors. After an initial, unsuccessful attempt to prove the VCS, the VC \nanalyzer adds the conjunct LEFTs 100 to the outer loop. The program is verified with this additional \ninvariant. 2.3 Documentation for Array Initialization Thus far, o~r presentation of the documenter has \nbeen concerned with generation of assertions for simple numeric varxables. As mentioned earlier, the \ndifficulty in dealing automatically with general assertions about data structures is currently a limiting \nfactor in verification. Since we do not use explicitly quantified assertions, documentation can be generated \nonly for the existing set of special predicates. At present, the documenter has one rule for data structures. \nThe rule generates DEFRANGE assertions for loops that initialize arrays. As new classes of assertions \nabout data structures become standardized with defined predicates, we wdl add corresponding analysis \nrules to the documenter. The DEFRANGE rule attempts to detect assignment statements which alter consecutive \nelements of an array on consecutive iterations of the loop. The particular rule we have implemented applies \nonly in very limited circumstances. Here, as elsewhere in the documenter, more work is needed to develop \ngeneral analysis procedures. Implementation details. The rule considers one loop at a time, and operates \non the assignment statements of the form v[i]:=e within a loop body. The first step is to try to express \nthe subscript i in the left hand side of an assignment in terms of variable values at the beginning of \nthe body. This is done for each assignment statement in the body. The second step is to determme, for \neach Pascal array type variable v whose address is constant with respect to the loop, and for each path \nthrough the body, the set of elements of v that are inihalized on each path. Fin all y, this information \nis tested to see if consecutive elements of a variable are initialized by the loop. Let v be a Pascal \nvariable whose address is a constant with respect to the loop, and i be an integer expression. Let n \nbe the set of paths of the loop which initialize v[i], where i is expressed in terms of variable values \nat the beginning of the path. If(1) i is unchanged over each path around the loop not in n, and (2) for \neach path in n, 1 is either unchanged or incremented by 1, then the assertion DEFRANGE(i , i-1, v), where \ni represents the initial value of i, is a valid invariant. Similarly, if condition (2) is true but the \nexpression i is decremented by 1, then DEFRANGE(i+l, i , v) can be asserted. Example: Merging two arrays \n This program takes as input arrays A and B of length 100 and transfers their contents into the array \nC, which has length 200. The user has supplied only an ENTRY assertion saying that A and B are fully \ninitialized, and an EXIT assertion saying that C is fully initialized. The interesting aspect of this \nexample is that the irutialization of C takes place in two loops. The first loop partially mltlahzes \nC, transferring elements from A and B until either A or B has been completely transferred. Then the mitiahzat]on \nof C continues in either the second loop or the third loop. The first loop is interesting in itself for \nthe handling of conditional branching by the DEFRANGE rule. PASCAL TYPE INARR=ARRAY[1:1OO] OF INTEGER; \nTYPE OUTARR=ARRAY[ 1:2001 OF INTEGER; VAR I,J,N:INTEGER; index *O; VAR A,B:INARR; C:OUTARR; ENTRY DEF(A)ADEF(B~ \nEXIT DEF(C~ BEGIN N:=1OO; I:= 1; J:= 1; S+l; J +j; INVARIANT TRUE DCOMMENT DEFRANGE(l +J -1,1+J-2,C) \n A j <1 A \\sN+j A J <J A J<N+l WHILE (IsN) AND (JsN) DO BEGIN IF AII]sBIJ] THEN BEGIN CII+J-l]=AII]; \n1:=1+1 END ELSE BEGIN CII+J-l]=BIJ} J=J+] END; END; 1 +1; INVARIANT TRUE DCOMh4ENT DE FRANGE(l +N,I+N-l,C) \nA 1 s1 A lsN+l WHILE IsN DO BEGIN CII+N]:=AII]; 1=1+1 END, J +-J; INVARIANT TRUE DCOMMENT DEFRANGE(J \n+N,J+ N-l,C) A J*sJ A JsN+l WHILE JsN DO BEGIN C[J+NJ=B[J] J=J+ 1 END; END  The documenter begins by \ngenerating inequalities for I and J. Applying the array initialization rule on the first loop, the documenter \nnotices assignments to CII+J-1] on both paths. In both cases, the index I+J-l is already in terms of \nvariable values at the beginning of the body. The system computes the change vector for the expression \nI+J-1, and finds that it is increased by 1 on each path. Therefore, the invariant DEFRANGE(I +J -1, \nI+J-2, C) is added to the first loop. The second and third loops also assign to C and receive DEFRANGE \nassertions. Since variables cannot become less initialized during execution, the DEFRANGE assertion from \nthe exit of the first loop will still be true after the second and third loops are finished. Thus at \nthe end of the program, DEF(C) can be proven by combining the effect of the first loop and the second \ntwo. The VC generator will assert in the VC that the array C is more fully initialized on exit from each \nloop than it was on entry to the loop. Thel efore, the VC will contain all the information needed to \nprove DEF(C) on exit. The documenter s assertions are also sufficient to show that the program executes \nsafely.  2.3a A Stronger Axiom for Array Initialization This section presents an approach which is more \ngeneral than the array initialization rule currently implemented in the documenter. We noted-earlier \nthat the extended semantic definition of Pascal allows us to assume that a variable which becomes DEF \nat some point during execution of a program will remain DEF afterwards during execution, even if it is \nassigned new values. This property of DEF can be used as the basis of a general strategy for forming \nassertions about the extent of initialization. The basic idea is that if the body of a loop initializes \na component of a variable on each iteration, we can form a valid invariant expressing the effect of repeated \nexecution of the body if the address of the component initialized on each iteration can be expressed \nas a function of the loop index. Consider a WHILE statement contained in a larger program and Iabelled \nwith an invariant I which is valid in the context in which the WHILE statement appears. INVARIANT I DCOMMENT \nindex?O WHILE L DO BEGIN B; index+ index+J END Assume the formula IAindex20AL {B; index-index+ 1] DEF(#(v,index,c \nl,...,cn)) is true, where v is a variable identifier. #(v,index,cl,,,,,cn) is a Pascal variable which \nis a component of v, and is expressed in such a way that it depends only on V, index, and expressions \nc1,-.,cn that are constant with respectto the loop. Then the assertion Vj 1<j<index ~ DEF(+(v,j,cl,...,cn)) \n(2.1) is a valid invariant of the loop. In special cases, (2.1) can be reduced to an instance of DEFRANGE. \n3. VC Analyzer After the documenter adds assertions, the system calls VCGEN followed by the simplifier. \nIf all of the VCS are proven, the verification is finished. If some of the VCS cannot be proven, it indicates \neither that the program is faulty or that the assertions are too weak. The VC analyzer strengthens the \ninvariant assertions in an attempt to make the VCS provable. Then the system calls VCGEN and the simplifier \nagain. This process repeats until the program is verified or the user decides to stop. Let us return \nto the binary search example TYPE NARRAY=ARRAY[l:N] OF INTEGER; PROCEDURE BINSRCH(A:NARRAY;M,X:INTEGER; \nVAR Y: INTEGER} ENTRY l< NAMAXINT?.2*N+1; EXIT DEF(Y} VAR LOW, HIGH, MID:INTEGER; BEGIN LOW:= 1; HIGH:=N; \nLOW *LOW; HIGH + HIGH; INVARIANT TRUE DCOMMENT LOW SLOW A HIGH< HIGH WHILE LOW<HIGH DO 13EGIN MID:=(LOW \n+ HIGH)DIV 2 IF X< AIMIDI THEN LOW:= MID+ 1 ELSE HIGH:= MID END; IF X= AILOWI THEN Y:= LOW ELSE Y:.O \nEND: On the path that exits the loop, it is necessary to prove 1<LC)WS I of), This is the precondition \nfor the array access A [LOW I. Since the loop exit test is LOW?HIGH and the documenter comment LOW < \nLOW instantiates to lsLOW, the precondition LOW< 100 is unprovable. The VC analyzer examines the simplified \nVCS. From information in the VCS, it can determine the location in the program corresponding to the unprovable \nprecondition. It combines the loop exit test with the precondition to form the implication LOW>HIGH a \nLOWS 100. This implication is conjoined to the INVARIANT of the WHILE loop. Intuitively, the new conjunct \nasserts that LOW is s 100 when the loop N exited. New VCS are generated using the stronger invariant, \nand they simplify to TRUE, BINSRCH with stronger INVARIANT after one pass through the VC analyzer TYPE \nNARRAY=ARRAY[l:NI OF INTEGER; PROCEDURE BINSRCH(A:NARRAY; M, X:INTEGER; VAR Y:INTEGER~ ENTRY 1. NAMAXINT?2*N+1; \nEXIT DEF(Y} VAR LOW, HIGH, MID: INTEGER; BEGIN LOW:= 1; HIGH:=N; LOW (-LOW; HIGH + HIGH; INVARIANT TRUE \nA (LOWZHIGH > LOWSIOO) DCOMMENT LOW SLOW A HIGHsHIGH WHILE LOW<HIGH DO BEGIN MID:=(LOW + HIGH)DIV ~ IF \nX<A [MID] THEN LOW:= MID+ 1 ELSE HIGH:= MID END; IF X=AILOW] THEN Y:= LOW ELSE Y=O END: In general, \nthe VC analyzer attempts to deal with any equality or meq uality precondition which is unprovabie. When \na precondition appears in a VC, it generally appears with variable substitutions resulting from the assignment \nrule. To distinguish the original precondition from the version with substitutions in a VC, we will refer \nto the latter as a goal. The VCS contain special markers, atomic formulas involving the symbols I_TAG \nand T TAG, which allow the VC analyzer to determine the locat]on in the program corresponding to each \ngoal in a VC. The markers define the path that must be taken from the beginning of the program to reach \nthe statement corresponding to each precondition. Every time the path passes a branch in the program, \na T_TAG is added to the VC; an I_TAG is added each time a loop is entered or exited. Information associated \nwith the tag identifies the particular statement involved (see example, section 1,5). When it finds an \nunproven goal, the VC analyzer traces backwards in the program from the point at which the goal was a \nrequired precondition to find the last loop containing a statement that changes the value of one of the \nvariables appearing in the goal. The invariant of this loop must be strengthened if the VC is to be made \nprovable. The VC analyzer adds, as a conjunct of the invariant, the implication PATH.CONDITION 3 $(pRECONDITION). \n(3.1) The PATH_CONDITION is the conjunction of branch tests alon~ the path from the loop to the statement \ncontaining the unprovable precondition. The substitution 6 represents the changes made in the values \nof variables along the path between the loop and the statement with the unprovable precondition. The \nimplication states that PRECONDITION will be true if the path M followed. In the sense of [16], the implication \n(3.1) is the rueartest trial i?wartant for verification of PRECONDITION. If PRECONDITION is true for \nevery execution of the program, the implication must also be true on the loop. The implication (3. 1) \nmay, however, be too weak to be proven invariant without additional assertions on the loop. In other \nwords, assertions produced by the VC analyzer are necessary for proving PRECONDITION, but may not be \nsufficient. If the program is incorrect so that PRECONDITION can be false during an execution, (3. 1) \nwdl be false, and unprovable. The invariants formed by the VC analyzer tend to result m some inefficiency \nwhen VCS are simplified. It N common for one invariant to have many similar implications added because \nseveral preconditions are unprovable on one path, or because one precondition is unprovable on many paths. \nInvariant formed by the VC analyzer are also somewhat redundant because an Implication with a PATH_CONDITION \nas antecedent M a useful assertion only on the one path for wh]ch the PATH_CONDITION holds on other paths, \nit is trivially true. To reduce the inefficiency of invariants from the VC analyzer, VCGEN automatically \napplies two types of propositional transformations to the VCS, The merging transformations eliminate \nrepetition by combining similar assertions. The distribution transformations eliminate assertions from \npaths on which they are useless.6 It M interesting to note that the system is able to verify QUICKSORT \n(section 2.2b) even if the documenter does not ~ produce the assertion LEFTsRIGHT on the inner loops. \nTo verify the assignment statements AILEFT]=AIRIGHT] and AIRIGHT]:=AILEFT] after the inner loops, LEFT \nmust be s 100. In the context after the inner loops, the assertion LEFT< RIGHT imphes LEFT< 100 because \nof the inequalities on RIGHT. If LEFTsRIGHT is missing from the inner loops, the VC analyzer adds LEFT< \n100 to the inner loops and the program is verified. This verification IS slower than the one using the \nexit heuris ic three iterations through the simplifier are required instead of two. Because lt relies \non the general VC analyzer heuristic when the documenter falls, the system can construct sufficient invariants \nin many situations that are too complex for the documenter to analyze. 4. Locating a Runtime Error in \nan Incorrect Program When the verifier falls to prove a program correct, lt returns simplified VCS which \ndn-ect the user s attention to the specific part of the program that cannot be proven. By studying the \nVCS and the corresponding part of the program, the user can decide whether it is the program or its assertions \nthat is at fault. The following example, a version of the Schorr-Waite hst marking algorithm, dlustrates \nwhat happens when the verifier is given an incorrect program as input. This particular example appeared \nm the literature [14] where properties other than runtlme correctness were proven with an automatic program \nverifier. The appearance of this program, which does not meet the runtime requirements of Pascal, M a \nconvincing argument for routinely checking runtime errors as part of any verification. It also demonstrates \nthat the usefulness of the verifier is not hrnlted to proving correct programs. On the contrary, the \nverifier is a very effective debugging tool for programs with potential runtime errors, The user has \nsupplied two invariant assertions with the program. The verifier requires an assertion within each loop \nformed by GOTO, but the assertion need not appear immediately after a label, as it does here. Note that \n*WORD, a reference class name, appears in the user s assertions. The assertion DEF(*WORD) means that \nevery allocated record of type WORD M fully mltialized. Example: SCHORR-WAITE 6 The transformations are \ndefined in [3]. PASCAL LABEL 1,2; TYPE LIST= tWORD; TYPE WORD= RECORD FL: INTEGER; M: INTEGER; HD:LIST; \nTL:LIST END; VAR W,Z,ZO,X:LIST; ENTRY DEF(ZO)ADEF(*WORD). EXIT TRUE; BEGIN Z:=ZO; X:=NIL; 1: ASSERT \nDEF(X)ADEF(Z)ADEF(*WORDY IF (Z=NIL) OR (ZT.M=l) THEN GOTO 2? Z?. M:=l; W:= Z?.HD; ZT.HD:=X; X,=z; Z:=w; \nGOTO 1; 2: ASSERT DEF(X)ADEF(Z)ADEF(*WORD} IF X*NIL THEN IF XT.FL=O THEN BEGIN X T.FL:= 1; W:= XT. HD;X?.HD:=Z;Z:= \nXT.TGXT.TL:=W; GOTO 1 END ELSE BEGIN W:= XT.T~X7.TL:=Z;Z: =X;X:=W; GOTO 2 END END,; The VC generator \nproduces three VCS for this program: one for the path from the entry, and for each of the two ASSERT \nstatements, a single VC for all paths starting from that statement, The VC for paths starting at the \nASSERT at label 1 is the only one that does not simplify to TRUE. SIMPLIFIED VERIFICATION CONDITION: \nMAIN 2 (DEF(*WORD) A DEF(Z) A DEF(X) 2 Z.NIL) At this point, the user interprets the simplified VC to \ndecide whether it is the program or its assertions that is incorrect. In this case, the interpretation \nis straightforward. On paths starting from label 1, the unproven precondition, Z#NIL, is added to the \nVC to ensure correct runtime evaluation of Z T in the secdnd part of the IF test IF (Z=NIL) OR (Zt.M=l) \nTHEN . Pascal s rules of evaluation require both arguments of the operator OR to evaluate safely, even \nwhen the first is TRUE. If the user had not recognized the error, he would have allowed the VC analyzer \nto strengthen the invariants. Observe that requiring Z* NIL at label 1 causes the path from the entry \nto be unprovable. Thus the error in the program would be pushed back to the ENTRY conditions, and continuing \nthe process would require the user to add as ENTRY conditions ZO#NIL, ZOT .HD+NIL, ZOT.HD?.HD*NIL, . \n. . until he realized the error. 5. Discussion 1) The Runcheck verifier is an example of an augmented \nprogram verifier. By an augmented verifier, we mean one that has special facilities for a particular \nclass of proofs (in this case, proofs of the absence of common runtime errors), but which also retains \ngeneral purpose capabilities so that arbitrary user specifications can be verified as well. This notion \ncontrasts with the idea of a special fluYpose verifier, such as the array bound checker of Suzuki and \nIshihata [151, which is built around a domain specific theorem prover. In [15], for example, the simplifier \nis limited to the domain of linear inequalities. Although the legal subscript condition for accessing \nAII] is a pair of inequalities, adsb, the verification conditions needed to prove that asIsb holds at \na point in a program often fall outside of the limited domain. This is typical when lemmas containing \nnonlinear assertions or assertions about complex data structures are needed to establish the value of \na subscript. An augmented verifier retains the general mechanisms needed to generate and simplify verification \nconditions for such lemmas. Two forms of augmentation are present in our system: 1) extended semantics, \nwhich strengthens the user s specifications to assure absence of runtime errors, and 2) the mechanisms \nfor generating inductive assertions. The concept of an augmented verifier can be applied to other areas \nof verification. For other applications, one might also extend the general purpose theorem prover, to \nmake it more powerful in relevant domains. 2) Readers familiar with previous work on generating inductive \nassertions will recognize that while our methods are similar in form to earlier approaches, they are \nsignificantly different in ernph asis. Odr system operates completely automaticcl[y. There are some differences \nbetween the Runcheck verifier and earlier work: LooII Semantics. Invariant generation in the Runcheck \nverifier benefits from being embedded in a logical system containing our WHILE rule. Assertions that \nhold in a program are automatically available at points further into the program. Previous methods required \nassertions to be explicitly propagated forward in all cases. With our WHILE rule, it is possible to introduce \na new variable to stand for the initial value of a variable upon entering a loop. Previous methods encounter \ndifficulty when the initial cannot be easily expressed in terms of other program variables, e.g., if \nconditional branching or another loop affects the initial value of a variable. By forming assertions \nthat express input output relations of a loop, the documenter avoids some of the difficulties of expressing \ninvariants directly. Trial Invariant. Because a general purpose theorem prover must be used to test trial \ninvariant, rules that propose trial invariants are very expensive. An earlier comment is worth repeating \nin this contexc Even if trial assertions are always in a Iim ited domain, such as linear inequalities, \na general purpose theorem prover is needed to check the verification conditions. Our system forms trial \ninvariants sparingly. We do not have generalization heuristics which try to prove a assertion on a loop \nby guessing a more general assertion. These heuristics are one of the chief sources of trial invariants \nin previous approaches [1;9,15,16]. In [151, in variants are formed by generalizing the assertion to \nbe proven. There are many instances in which the necessary invariants are not among the trial invariants \nformed by the generalization heuristic used. In some such cases, the documenter does form the necessary \ninvariants during its routine analysis of the program. VC Analvzer. The VC analyzer represents the approach \nof forming invariants by working backwards from the assertion to be proven without generalization. We \nhave started to 9. Katz, S.M. and Z. Manna, Logical Analysis of Programs, Comm. investigate techniques \nby which this general method can be applied efficiently. Specialization of Data Structure Documentation. \nBecause our system is designed to assist in a specific type of proof, we can identify commonly needed \nclasses of assertions about data structures and develop specialized program analysis techniques (e.g, \nDEFRANGE documenter rule). Absence of Infeasible Methods. Some methods for generating inductive assertions \nare more suitable for hand simulation than automation, because they rely on operations that are either \ndifficult to implement (e.g. clever symbolic manipulation of conditional recurrence relations) or prohibitively \nslow when performed automatically with adequate generality (e.g. theorem proving in a nontrivial first \norder theory with full quantification). We have avoided such infeasible methods. 2) TO what extent is \nit practical to prove absence of runtime errors? First of all, the verifier is an effective tool for \ndebuggin~ its usefulness is not limited to programs that are already correct. On the other hand, the \ninherent requirement that the user give specifications, even if only an ENTRY assertion, means that using \na verifier can never be as easy as, for instance, using a compiler. In our view, the primary limitation \non the practicality of runtime verification is the amount of user effort needed to specify a new program. \nAs the examples in this paper illustrate, the effort is often minimal. In other examples handled by the \nsystem but not shown here, the specifications are more difficult to write, e.g. because complex data \nstructures must be described. Due to the augmented capabilities of the Runcheck verifier, and the possibility \nof at least developing standard approaches to aspects of the proving process thar are not fully automated, \nverifying runtime properties is considerably easier in practice than verifying arbitrary properties of \nprograms. Acknowledgment The author is thankful for the advice and constructive criticism of Dave Luckham. \nReferences 1. Dershowitz, N., and Z. Manna, Inference Rules for Program Annotation, Al. Memo AIM 303, \nStanford University, October 1977.  2. Elspas, B., The Semiautomatic Generation of Inductive Assertions \nfor Proving Program Correctness, Stanford Research Institute, Stanford, Calif., SRI Project 2686, July \n1974. 3. German, S.M., A System for Automatically Proving the Absence of Common Runtime Errors, Stanford \nA.}. Memo, in preparation. 4. German, S.M. and B. Wegbreit, A Synthesizer of Inductive Assertions, IEEE \nTrans. on Software Engineering, SE-1, 1 (March 1975), pp.68-75. 5. Hoare, C.A.R., Proof of a Program: \nFIND, Comm. ACM 14, 1 (Jan, 1971), pp.39-45. 6. Hoare, C.A.R. and N. Wirth, An Axiomatic Definition \nof the Programming Language Pascal, Acts Informatica, Vol. 2, 1973, pp.335-355. 7. Huet, G., D. Luckham, \nand D. Oppen, Extended Pascal Semantics for Proving the Absence of Common Runtime Errors, Stanford Al. \nMemo, forthcoming. 8. Jensen, K. and N. Wirth, Pascal User Manual and Report, second edition, Springer-Verlag, \nNew York, 1975.  ACM 19, 4 (April 1976), PP. 188-206. 10. Knuth, D.C., The Art of Computer Programming, \nVol. I -Fundamental Algorithms, Addison Wesley, Reading Mass., 1968, pp.417. 11. Luckham, D. and N. \nSuzuki, Automatic Program Verification V: Verification Oriented Proof Rules for Arraysj Records, and \nPointers, Stanford Al. Memo AIM-278, March 1976. 12. Nelson, C.G., and D. Oppen, A Simplifier Based \non Efficient Decision Algorithms, these proceedings. 13. Sites, R.L., Proving that Computer Programs \nTerminate Cleanly, Computer Science Department Report CS 418, Stanford University, May 1974. 14. Suzuki, \nN., Automatic Verification of Programs with Complex Data Structures, Ph.D. dissertation, Dept. of Computer \nScience, Stanford University, 1976. 15. Suzuki, N. and K. Ishihata, Implementation of an Array Bound \nChecker, Proc. Fourth ACM Symposium on Principles of Programming Languages, January 1977, pp.132-143. \n 16. Wegbreit, B., The Synthesis of Loop Predicates, Comm. ACM 17, 2 (Feb. 1974), pp. 102-112. 17. Wirth, \nN., Program Development by Stepwise Refinement, Comm. ACM 14, 4 (April 1971), PP.221-227. 18. Wirth, \nN., (the ROOT and SENTINEL program was suggested by  N. Wirth). \n\t\t\t", "proc_id": "512760", "abstract": "The Runcheck Verifier is a working system for proving the absence of common runtime errors. The language accepted is Pascal without variant records, side effects in functions, shared variable parameters to procedures, or functional arguments. The errors checked are: 1) accessing a variable that has not been assigned a value, 2) array subscripting out of range, 3) subrange type error, 4) dereferencing a NIL pointer, 5) arithmetic overflow, and 6) division by zero.", "authors": [{"name": "Steven M. German", "author_profile_id": "81342495156", "affiliation": "Stanford University, Stanford, Calif. and Harvard University, Cambridge, Ma.", "person_id": "PP43128823", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512760.512772", "year": "1978", "article_id": "512772", "conference": "POPL", "title": "Automating proofs of the absence of common runtime errors", "url": "http://dl.acm.org/citation.cfm?id=512772"}