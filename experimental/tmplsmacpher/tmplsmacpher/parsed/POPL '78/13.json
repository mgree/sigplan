{"article_publication_date": "01-01-1978", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1978 ACM 0-12345-678-9 $5.00 COIIferenCe Record of the Fifth Annual ACM Symposium on Principles of Programming \nLanguages Unrestricted Procedure Calls in Hoarefs Logic-i_ Robert Cartwright Computer Science Department \nCornell University, Ithaca, N.Y. 14853 Derek Oppen Computer Science Department Stanford University, Stanford, \nCa. 94305 Abstract by a procedure be accessible at the point of every call. This paper presents a new \nversion of Hoare s logic including generalized procedure call and Another disturbing aspect of current \nversions assignment rules which correctly handle aliased of Hoare s logic is that most of the proposed \nvariables. Formal justifications are given for rules have never been formally justified. Perhaps the \nnew rules. as a result, many of the rules have counter\u00adexamples. The few sets of rules that have been \nproved sound apply only to idealized programming 1. Introduction languages [Cook 75] [Gorelick 751 [oppen \n75] [Donahue 76]. The proof rule systems proposed for Despite the widespread acceptance of Hoare s practical \nprogramming languages such as PASCAL logic as the most suitable formalism for verifying [Hoare and Wirth \n731 and EUCLID [London, et al. programs written in procedural languages, the 77] have never been formally \njustified, and all logic still suffers from several shortcomings. contain serious errors and omissions. \nIn our view, the two most significant problems are: As a step toward solving these problems, we 1. The \nlimitation on programing language will concentrate on devising and rigorously justi\u00ad constructs, particularly \nprocedures, fying rules for procedure calls in PASCAL - imposed by commonly accepted rules of including \ncalls involving aliasing. First, we will the logic. develop a simple procedure call rule (patterned after \n[Hoare 71] along the same lines as the EUCLID 2. The absence of formal justifications rule [Guttag, et \nal. 77]) for calls where no al\u00ad for most of these rules. iasing is present. Next, we will propose general \nized assignment and procedure call rules for con Of the sets of Hoare proof rules proposed in texts where \naliasing is permitted. Both general the literature [Hoare 69] [Hoare and Wirth 73] ized rules collapse \nto the corresponding simple [London, et al. 77] [Igarashi, London and rules if no aliasing is present. \nLuckham 75] [Donahue 76] [Cook 75] [Gorelick 75], none is sound for all programs in any reasonably We \nwill sketch soundness and relative com\u00ad complicated procedural language such as PASCAL. pleteness proofs \nfor all of our new rules. In the In particular, all of the rules place significant process, we will propose \na new mathematical defi\u00ad restrictions on procedures and procedure calls. nition for the meaning of statements \nin Hoare s Even the most comprehensive procedure call rule logic which seems sufficiently comprehensive \nto proposed to date (for EUCLID by [Guttag, et al. handle most procedural languages, yet is intui\u00ad 77]) \nmust: tively tractable. 1. Prohibit aliasing in procedure calls. 2. Mathematical Foundations 2. Disallow \npassing procedures and functions as parameters. Before we can formulate and justify our proof rules, \nwe must establish the mathematical founda\u00ad 3. Require that value parameters be read only tions for our \nversion of Hoare s logic. We intro (i.e. constant parameters). duce three sets of definitions. 4. Prohibit \ndeclaring a procedure within a 2.1 State Vectors and Access Sequences procedure of the same name. From \nan informal Viewpointr a state vector is 5. Require that the global variables accessed a sequence of \nbindings of program v=l= data values,and procedure names to procedure bod\u00ad ? This research has been partially \nsupported by ies (e.g. a LISP association liSt) . An access National Science Foundation Grants MCS76-14293 \nseauence is a canonical name for an entry in a and MCS76-000327. state vector. For example, the access \nsequence for the variable x is < x> (since x typically means array access and update functions defined \nby the value of the variable x, we use the notation [McCarthy 631. Value maps a state vector s and an \nx to refer to the variable itself). The access access sequence u into the binding of a in s. up\u00adsequence \nfor the array element a[ll is < a,l>. date maps a state vector s, an access sequence a, and a value d \ninto the state vector s where s is More formally, we let D denote the set of data identical to s except \nthat the entry within s values that program variables may assume, and let I specified by a has the new \nvalue d. and I denote the set of program identifiers a,b, c,. ..,and quoted program identifiers a, b, \nc,..., In more formal terms, Value is a mapping from respectively. We let B denote the set of procedure \nSXA into DuB and Update is a mapping from SXAX(BUD) bodies. A variable-specifier is any legal left into \nS satisfying the following axioms: hand side of an assignment statement. A simple variable is a variable-specifier \nconsisting of a 1. Value (Update (s,a,e),a)=e for arbitrary state single identifier. For example, a[x] \nand x are vector s, access sequence a, and value e, both variable specifiers; x is a simple variable, \nprovided the entry specified by a exists but a[xl is not. in s. 2. Value(Update (s,a1,e),a2) = Value(s~a2) \nf For the sake of simplicity, we limit our at\u00adtention to a subset of PASCAL restricting the set al, \nand a2 are disjoint access sequences of variable-specifiers to simple variables and and the entries specified \nby al and Q.2 ex singly subscripted array references. Similarly, we assume the data value domain for \nour PASCAL di-ist in s. alect has the form [j:JDjl u [j,&#38; (Dj+Dk)] where 3. Let Select be the standard \narray access the sets D,, jcJ, are disjoint sets of primitive function mapping (Di+Dj) x Di into Dj for \n1 data objects (e.g. integers, characters, booleans) all i,j. Then Value (Update(s,< v>,d) ,< v,e>) . \nand (Dj+Dk) denotes the set of mappings (arrays) = Select(d,e) for arbitrary state vector s, id~er v, \narray value d, and data value from D. into Dk. We call each set D. and (Dj+Dk) 1 1 e, provided e is in \nthe domain of d. a ~. These restrictions are made only for ex\u00ad 4. Let Store be the standard array update \nfun\u00adplanatory purposes. All of our results generalize tion mapping (Di+Dj) x Di X D. into (Di+Dj) to \narbitrary PASCAL data domains. 3 for all i,j. Then Value (Update(s,< v,e>, . We define the access sequence \ncorresponding d), < v>) = Store (Value(s,< v>),e,d) for to the simple variable v as the singleton sequence \narbitrary state vector s, identifier v, and <Iv>. For a variable-specifier of the form a[e] data values \nd and e, provided e and d belong (where a is an array and e is an expression), the to the domain and \nrange of Value (s,< v>) access sequence is < a,eO> where e. E D is the respectively. value of e. We define \ntwo access sequences to be r., . We extend Value and Update to apply to se\u00ad disjoint if and only if \nneither is an initial seg\u00adquences of disjoint access sequences as follows: ment of the other. 1. Value* \n(s,<al, . . ..Un>) = <Value(s,ul), ..., Let H be a finite set of variable declara\u00ad Value(s,an)> for arbitrary \nstate vector s tions v : Tv(where v is a program identifier and Tv is atype) and procedure declarations \nand access sequences al, . . ..an. provided the procedure P(uP); Bp (where pj is a program entries specified \nby al, . . ..un exist in s. identifier ,a is a sequence of var and value P 2. Update* (s,<al, . . ..an>. \n<all, . . ..dn>) = L@ parameter declarations and Bp is the remainder d.a.he(. . .=(sfal~dl)..-~an~dn) \nfor arbi\u00adof the procedure body) . We call H a declaration trary access sequences al,... ,un and values \nset. A state vector s consistent with H is a mapping from I (identifiers) into D (data values) all, ..., \ndn provided the specified updates u B (procedure bodies) such that each variable v are well-defined. \ndeclared in H is bound to a data value of type Tv and each procedure is bound to the body 3. Let al,..., \nan be disjoint access sequences procedure p(ap); Bp. such that a. ,a. ,...,u. have the form 11 12 lk \nTypically, we are only interested in only a < v,eg>,!L=l,2,.. ., k, where v is an identi\u00adfinite restriction \nof S --specifically the bindings fier; and e is a data value. Letof the variables and procedure names \ndeclared in 1 H. In this case, we can think of s as a finite be the remaining access aj ~ ,aj2 ,... ,ajn_k \nsequence of ordered pairs (x,d) where X is a pro\u00adgram identifier declared in H and d is its binding. \nsequences, and let d denote Value(s,< v>) . Then Update* (s,<al, . . ..an>.<dl ,.. .,dn>) = We let A \nand S denote the set of access se\u00ad Update*(s,<a,a, ,u, ,...,a, quences and the set of state vectors respectively. \n31 32 ]n-k> <Store ( . ..Store(d.e ,d. )... ,ek,d. =k) ,d. 1 ]~ 11 2.2 Value and Update Functions >) \nprovided the specified updates~.~ $~~i~d fined We introduce two functions Value and Update The finaf \nax~om a%ove m~rely collects updates to to access and modify states, analogous to the various elements \nof the same array and combines them into a single update of the entire array. We struction in our proof \nrules. can use this axiom to convert an arbitrary se\u00adquence of disjoint updates to an equivalent set \n2.3.2 Extended Terms and Formulas of simple updates (i.e. updates of simple vari\u00adables rather than array \nelements) . For example, For the sake of clarity, we prohibit formulas Update* (s,<< a,l>,< b>,< a,4>,< \nc>>,<l,2,3r4>) = of L from using program identifiers as bound (quantified) variables. In addition, to \nconven- Update* (s,<< a>,< b>,< c>>, +tore(Store(Value . iently handle updates to the state vector, we \nex\u00ad(< a>,s),l,l) ,4,3),2,4>. tend the logical language L to include updated formulas and terms. We define \nan extended for-We denote the set of sequences of access se-mula (term) of L as follows. An extended \nfor\u00adquences by A*. mula (term) has a recursive definition identical to that of an ordinary formula (term) \n[Enderton 2.3 Definition of Truth 72] except that there is an additional mechanism (called an update) \nfor building new formulas and In this section, we define the syntax and terms from existing ones. Given \nan extended for\u00admeaning of statements in our version of Hoare s mula (term) a, the form [[ ; + ~ ]]a \nis also an loqic. extended formula (term) , where ~ is a sequence of disjoint variable-specifiers and \n~ is a cor 2.3.1 The Base Logic resDondinq sequence of ordinary (not updated) We assume we are given \na base first order terms in L. We will call[+~ ] a simultaneous theory (L,M) (for the program data domain), \ncon update. Henceforth, we will simply use the term sisting of a logical language L with equality and \nformula (term) to refer to an extended formula a mode. M for L, with the following properties: (extended \nterm). 1. The domain of the model M includes D (data values), I (quoted identifiers), A(access 2.3.3 \nHoare Assertions and Statements sequences) , A*(sequences over A) , and B  (procedure bodies). Let Q \nbe an arbitrary formula in L and let xl, . . ..xn be the program identifiers which 2. The variables \nof L include two disjoint sets: I(programming language identifiers) occur in Q. Let H be a declaration \nset including and V, a set of logical variables which declarations for Xlr. ..,xn. A Hoare assertion \nmay not appear within programs. has the form 3. The logic includes the binary function @ HIQ. and the \nunary function ~. The 0 operator concatenates two sequences, i.e.<ul, . ..r~> Let A be a program segment \nand P and Q be  @l <VI, ..., Vn> = <IJ l) . ..f%~vlr. ..rvn>. formulas in L. Let H be a declaration \nset in\u00adcluding declarations for all the free program ~maps a data object d (specifically variables and \nprocedure names in A,P, and Q. A a quoted identifier, a data value, or an Hoare statement has the form \n access sequence) into the singleton se\u00adquence <d>. With the functions @ and ~, H\\P{A}Q we can construct \narbitrary members of A We define the meaning of Hoare assertions and A*. and statements as follows. \nLet HIQ be an arbi\u00ad 4. The logic includes all the primitive func-trary Hoare assertion. The definition \nof truth tions of programming language including for HIQ is identical to the standard first-order array \naccess and update functions (Select definition of truth for Q [Enderton 721 except: and Store) . We let \na[e], where a is an iden~r and e is a term, abbreviate the 1. HIQ is vacuously true for states inconsis\u00adterm \nSelect (are). tent with H. 5. The logic includes a characteristic pred-2. The meaning of the updated \nformula (term) icate PT for each data type T in D. We [ ~ + ~ ] u for state s is the meaning of will \nuse the familiar notation x : T to the formula (term) a for state abbreviate PT(x) . Update*(s,;*,;) \nwhere ;*denotes the sequence of access sequences corresponding to V. 6. The logic includes the predicates \nDisjoint and Pair-disjoint with domains A* and A*xA*  Let HIP{A)Q be an arbitrary Hoare state\u00adrespectively. \nDisjoint (@l, . . ..CIn>) ment and let Eval be an interpreter (a partialis true if and only if access \nsequences function) mapping states x program segments into ai and a j are disjoint for all i,j such states. \nThen HIP{A}Q is true if and only if for that i+j, Pair disjoint (<al, . . ..am>. all states s either \nal,..., Rn>)is true if and only if ~i and 1. HIP is false for s. ~j are disjoint for all i,]. 2. ~(s,A) \nis undefined. 3. Q is true for Eval(s,A). Given an arbitrary variable specifier v, we can construct \na term v* in L such that the mean\u00ad 2.3.4 Standard Proof Rules ing of V* is the accese sequence for v. \nIf v is a simple variable x, then v* is simply Seq( x). The standard simple Hoare proof rules have If \nv is an array element a[e]r then v* is Seq( a) obvious analogs in our version of the logic. Ox(e). We \nwill frequently employ this con\u00adThe most fundamental rules --consequences, compo\u00adsition, and substitution \n--have the following form: 1. Consequence HIP ~ Q, H Q{A]R, HIR~S HIP {A}S 2. Composition ~ 3. Substitution \nH P{A]Q H P(t/x ) {A}Q(t/x )  t-\u00ad where x is a logical variable and Q(t/x ) denotes Q with every free \noccurrence of x replaced by t (renaming bound variables) . The other standard rules which we will take \nas given are: 4. Declaration H(; /~,~ /~) u {x:T,P:B} 1 P(= /~){A]Q(= /~) HIP {begin x:T; p:B; A end}Q \nwhere x:T and p:B are sequences of variable and procedure declarations, and % and ~ are sequences of \nfresh program variables and procedure names corresponding to ~ and G. 5. Simultaneous Assignment H Disjoint(~*) \n Hl[+~lI?{+~}P where ~~ is a disjoint assignment and where G* is the sequence of access sequence terms \nin L corresponding to ~.  2.3.5 Reasoning about Updated Formulas In order to prove Hoare assertions \ninvolving updated formulas, we need special axioms about updates. For disjoint updates modifying entire \nformulas, the following axioms Lderived from the corresponding axioms for Update*) are sufficient: 1. \n[ = + ~ IQ ~ Q(~/=) where = is a sequence of distinct simple variables, and Q is a formula containing \nno updates. 2. Letvl, .-., Vn be disjoint variable speci\u00ad  fiers where vii,...,vik have the form a[e~]r \nL=l, ..., k, where a is a particular array identifier. Let v ll --- kln k be the remaining variable-specifiers. \nLet ~ denote the sequence of variable-specifiers and let ~ denote the se\u00ad vjl .. . vjn_k quence of terms<Store(. \n. . Store(a,el,til) . . ..f?k.t.i~),tjl, . . . ,tjn_k>. Then [ ;+ ~] QEu;1 +~1 IQ. Given an arbitrary \ndisjoint simultaneous up\u00addate ~ + ~, we can eliminate the update [;+=] from a formula of the form [~ \n+ ~ IQ where Q is up\u00addate free by using axiom 2 to eliminate all assign\u00adments to array elements and then \napplying axiom 1. We ban similarly eliminate all updates from a form\u00ad ula of the form [ . ..]1 [V +~lQ \nwhere Q is update\u00adfree by repeatedly applying the same simplification procedure. 3, Simple Procedure \nCall Rule In this section we assume that our PASCAL subset: 1. Prohibits aliasing in procedure calls. \n 2. Disallows passing procedures and functions as parameters. 3. Requires that the global variables \naccessed by a procedure be explicitly declared at the head of the procedure and that these variables \nbe accessible at the point of every call.  Under these assumptions, it is straightfor\u00adward to formulate \na procedure call rule by treat\u00ading procedure calls as simultaneous assignments to the variables passed \nto the procedure. The assigned values are any values consistent with the input-output assertions for \nthe procedure. Let p be declared as procedure p(var X:TX; value y:T17) ; global ~; B in the declaration \nset H. B may not access any global variables other than ?. Let H be H augmented by the declarations X:TX \nand y:Ty (prior declarations of % and ~ are replaced). Let P and Q be formulas containing no free program \nvariables other than ~,~,~ and ?,? respectively. Let ~ be the free logical variables of P and Q, and \nlet ~ and ~ be fresh logical variables correspond\u00ading to ? and ~. Then the (non-recursive) simple procedure \ncall rule has the following form: H I Disjoint(~*@Z*), Htl P{B}Q Hlti[P(~/~,~/~)=JQ(= /~,~ /;) ]=[R~[6,~+i \n,= nS] It is important to note that the free logical variables ~ and ~ in the second premise are im plicitly \nuniversally quantified. The rule forces R> [=,; + ~ ,~ IS to be true for arbitrary ~ and = consistent \nwith fi[P(~/=,~/~)~Q(~ /~,~ /=) 1. In contrast, the EUCLID procedure call rule explic\u00aditly omits the \ncorresponding quantifier -\u00ad permitting false deductions. 3.1 Soundness If Eval is properly defined, it \nis easy to . prove the soundness of the simple procedure call rule. Let s be an arbitrary state, consistent \nwith H such that HIR is true for s and Eval(s, P(~;F)) is defined. We must show S is true for ~(s,p(~;~)). \nLet s be [~ ,= + ~OL~O ]s where XOLZQ are the Output values of ~ and z in t_he call p(a;b) (i.e. the \nvalues of ~ and ~ in the state Eval( [~,~ + ~,~ ]s,B)). Since s satisfies both _ ---_ yrv[P(a/x,b/y)~Q(~ \n/~,= /~) ] and R in the second premise, s must also satisfy [S,E + Z rZ 1S. By the definition of Eval, \nEval (s,p(~,~)) = u~,~ + ~o,~o ]S = [s,;+; ,; ]s1. Hence Eval (s,p(=,~)) satisfies S. Q.E.D. Although \nthe soundness of the procedure call rule does not depend on the third assumption listed above (the accessibility \nof the procedure globals at the point of every call) , the assumption is 134 necessary to prove that \nEval obeys static scope rules. The natural definition of Eval (which we used in the soundness proof) \nemploys dynamic scope rules. If the third assumption holds then static and dynamic scope rules are semantically \nequivalent.  3.2 Relative Completeness It is also reasonably straightforward to prove that the simple \nprocedure call rule is rel\u00adatively complete for non-recursive programs in the sense of [Cook 75]. We \nassume that the as sertion language L is expressive, i.e. that given an arbitrary assertion P in L and \na program seg\u00adment A the strongest post condition Q of A given pre-assertion P is definable in L. To \nshow that the rule is complete relative to the completeness of the other proof rules and the axiomatization \nof the extended base logic, it suffices to show that for any program segment A and post-assert\u00adion Q, \nthe weakest liberal pre-condition P is provable. The proof proceeds by contradiction. Assume p (~!;~ \n) is a procedure call for which the rule is not complete. Let p(=;~)be the deepest procedure call in \nthe evaluation of p (~ ; ~ ) for which the simple procedure call is not complete. Let H be the declaration \nset at the point of the call, and let p be declared as procedure p(var ~;value y:Ty); global 2; B in \nH. Let S be an arbitrary post-assertion for P(:;G) . We define Q as the strongest post\u00ad \u00adcondition for \nB given the pre-assertion X,yrz = - By assumption H IP{B} Q is provable. We i,Yi,zi\u00ad define Q to be \nE~ Q (~l/~). By the rule of conse\u00adquence, HIP{B}Qmust be provable. In addition, R E W~ r~ [Q(~/~it~/~i,~/~ir~ \n/~,~ /~) ~ US,z + ; ,Z ]s] is clearly a provable pre-condition of the rule. Assume R is not the weakest \nliberal precon\u00addition. Then there exists a state s consistent with H such that R is false and either \nEval(s, p(=;~))is undefined or S is true for Eval(s,p(~;~)). Let s be u~r~ + ~,6Jls. Either Eval(s,B) \nis un\u00addefined or Q is true for Eval(s ,B). In the for\u00admer case,Q(~/~i,~/~i,z/zi,xt/xr zt/~) must be false \nfor all ~ ,~ since Q(~/~irg/~iR~/~i) is false for all ;, ~. Hence R is true, generating a contra\u00addiction. \nIn the other case, Q(~/ ~in~/?j.L~/~l , ; /~,i /;) is true only for states with x and z equal to the \nvalues of ~ and ~ in Eval(s ,B). But for such ~ and ~ ,~(~,p(:;ij m,; + x ,= Ils. Consequently, Ua,z \n+-Z ,= DS is true for all states satisfying Q(~/~i,~/~i,~/~i,~ /~, z /z) implying R is true. Again, we \nhave a con tradition. Q.E.D. 3.3 A Sample Proof Let s consider a simple example which less sophisticated \nprocedure call rules handle incor\u00adrectly. Let swap be a standard inteqer variable swap proceduredefined \nas follows: procedure p(var x,y : integer) ; begin ~ X=Xi A y.yi; X Y + Yrxi pOSt y=Xi A X=yi end;  \nBy the simultaneous assignment rule, we must show x,Y:inte9er lx=x1Ay=yi Q Kx,y + y,x lly=Xi A x.yi to \nestablish the declared pre and post-assertions for swap. By the [ [ substitution axiom (axiom 1 in 2.3.5), \n[x/y ~ Y,x] Y=X1 A x=yi 5 x=xi A y=yi which is precisely the pre assertion.Q.E.D. Now let us consider \na sample application of the procedure call rule. Assume we want to prove: a:array integer ~ integer, \ni:integerl a[i]=ao A i=io{p(a[i] ,i) }a[io]=io A i=ao. Let H denote {a:array integer of integer, i:inte\u00adger}; \nP denote the substitute~pre-condition a[i]=~i A i=yi; Q denote the substituted post\u00adcondition y =xl A \nxl=yl; R denote a[i]=ao A i=io; and S denote a[io]=io A i=ao. By the simple pro cedure call rule, we \nmust show 1. HIDisjoint(< a,i>, < i>). 2. The correctness of the input-output asser\u00adtions for the procedure \nbody.  3. [P 3Q ] > [R> [a[i],i+x!,yt ]s].  HIYXOJYO Since 1) is trivial, and we have already proved \n2), it suffices to prove 3). First we trans\u00adform [a[i],i = x ,y ]S into [a,i + Store(a,i,x ), Y IS E \nStore(a,i,x ) [io]=io A y =ao. Since i=io by hypothesis in R, S = Store(a,io,x )[io] = i. A y =ao G x~=i \n o A y =ao. By applying the equality hypotheses in R, we trans form x =io A y =ao into x =i A y =a[i] \n--which an immediate consequence of P zQ when Xl,yi are instantiated as a[i] and i respectively. Q.E.D. \n 3.4 Handling Recursion Our simple rule can be extended to handle mutually recursive procedures by generalizing \nHoare s original approach to the problem [Hoare 71]. However, we must impose the following additional \nrestriction on our PASCAL subset to ensure the soundness of the rule: No procedure named p may be declared \nwithin the scope of another procedure named p. Our rule is not unique in this respect. Every other proposed \nprocedure call rule+ requires an equivalent restriction. The restriction is necessary because the input-output \nspecifications for a procedure p may be assumed for any procedure call within a procedure declared in \nthe scope of p. Let procedure pi (var xi:Txi; value yi:Tyi;  global ~i; Bi, i=l,2, . ..rn be a sequence \nof pro\u00adcedure declarations at the head of some block. Let Pi and Qi i=l, ..., n be assertions containing \nno free program variables other than ~,~i,~i and Let ~i be the free logical i~;i respectively. variables \nin Piand Qi. Let H be a declaration set containing the declarations of Pl, . . ..pk and let H denote \nH with these declarations + An exception is a rule currently under develop\u00adment by DeBakker, but his \nrule requires exten\u00adsive rewriting of the program text. 135 replaced by forward procedure declarations \nwhich only specify the the procedures formal parameters. Let H i denote H augmented by the declarations \nX:TX, y:Ty (prior declarations of x and y are re placed). For i=l, . . ..n we define the recursion hypothesis \nIi as the rule: where 81,82,~,~, and H are arbitrary. Then the recursive version of the rule has the \nform: where 11,12, . . ..In F H~lPj{Bj}Qj means we may use the special rules Ii to prove H~lPj{Bj ] Qj. \nUnlike Hoare s original rule and the EUCLID rule, our recursive rule is relatively complete, even for \nthe programs utilizing mutual recursion. Of the rules previously proposed in the literature, our rule \nmost closely resembles that of [Gorelick 75] . Gorelick uses a more complex set of potent\u00ad ially mutually \nrecursive procedures instead of PI r . . ..Pn and divides the procedure call rule into two parts: a rule \nof modification and a rule of invariance. We originally formulated our pro\u00ad cedure call rules in two \npart form, but abandoned the approach after we failed to devise a complete two-part rule. Gorelick achieves \nrelative com\u00ad pleteness by restricting actual var parameters to simple variables. We can prove that \nthe recursive version of the simple procedure call rule is sound by gener\u00adalizing the argument we used \nfor the non-recursive rule. Fi~st, we construct the sequences of pro\u00adcedures p 1. ilP =l. ..,pk; i=l;i=l \n,...,n as follows. We let poi be a non-terminating procedure with parameters identical to pi. For k=l,2r \n..., we .~et Pk be defined by the procedure pk(~ ~i:Txi; k 1 .( /~j ,j=l, . . ..n). XZIK yi:TYi) ; glObal \ni; 1 Pj i.e. by the same declaration as pi except each call pj(~;~) within the body of pi is replaced \nby the call pk-lj(~;~). Clearly, if the evalua\u00adtion of an arbitrary call pi(~t~) requires less than k \nlevels of nested calls on pl,p2, . . ..pn. then the call pki(=,~) is equivalent to pi(~,~). (Note that \nthis statement does not hold if the restriction on procedure names is violated.) By the ~~~ndne~= of \nthe ~on xecur~ive rule and ~Lm\u00adple induction on k, we know that the recursive rule is sound if we interpret \np. in the pre 1. mises by Pk lj, j=l, ..., n and pi ~n the conclusion by pki. Without loss of generality \nwe may assume Pi(~,~) terminates; otherwise, the rule is vacu\u00adously true. Let k be any integer greater \nthan the maximum recursion calling depth on plr. ..rpn in the evaluation of pi(~;~). By assumption, the \npremises are true for any interpretation Of pj, j=l, . . .,n consistent with H . Hence they must hold \nfor pj interpreted as pk-1 implying the 3 ~ conclusion of the rule holds for_p i(~,~) . Since pki(~,~) \nis equivalent to pi(;,~), the conclusion of the rule must be true. Q.E.D. The relative completeness of \nthe recursive rule can be established by a similar inductive generalization of the proof for the non-recursive \nrule. We assume L is expressive. The proof pro\u00adceeds by induction on the structure of a program. Let \nPI, . . ..Pn be a sequence of procedures declared at the head of a block such that the rule is com plete \nfor the procedures declared within PI r . . ..Pn. Assume we are given recursion hypoth\u00adeses for all of \nthe procedures containing the pro\u00ad cedurespl, . . ..pn. We want to show that the weakest liberal pre-condition \nis provable for any procedure call in the block body given an arbitrary post\u00adassertion. For each procedure \npi, we let P1 be let Q i be the asser\u00adxi,yi,zi = ~ i~~ol,~oi and tion defining the strongest post condition \nof Bi given pre condition P1. As before, we let Qi be  ZIj iQ i(j i/ji). Let q(~;~)be an arbitrary \ncall in Bi such that q is either pj for some j or a procedure con\u00adtaining the procedures pl, . . ..pn. \nBy the same argument we used in the non-recursive case, the weakest pre-condition of q(=;~) , given an \narbitrary post-assertion S, is provable. Hence, since the remaining rules of the logic are complete by \nassumption, Pi{Bi} Qi,i=lr. ..,n is provable. By aPPlYin9 the same ar9ument again, we conclude that the \nweakest pre-condition of any call on a pro\u00adcedure q in the block body is provable. By induction on the \nstructure of a program, we can repeatedly apply the previous argument to derive that the procedure call \nrule is complete for calls in the body of the program. Q.E.D. 4. Rules for Programs with Aliasing We \nnow extend our version of Hoare s logic to handle aliasing. The modifications required are surprisingly \nminor. Hoare s original assignment axiom has the form: P(e/x){x+ e}P where x is a simple variable, e \nis an expression (term in the logical language L) and P is a formula. This axiom is invalid if x is a \nreference para\u00ad meter or an array reference, since there may be syntactically distinct variables in P \nwith access sequences identical to x. While Hoare s substi tution style axiom can be patched to handle \narray assignment (by viewing the assignment a[el] + e2 as an abbreviation for the simple assignment a \n+ store(a,e1,e2)), it completely breaks down in the case of aliasing. In contrast, our assignment call \nrule does not rely on the concept of substitution (although it collapses to that form in trivial cases) \n. As a result, our rule is able to handle array assign\u00adment and aliasing without any modification. 4.1 \nReference Parameters In a programming language with unrestricted reference parameters like PASCAL, we \ninterpret 136 procedure calls as passing the access sequences (i.e. abstract addresses) of the actual \nreference parameters to the procedure. In other words, the interpreter (Eval) binds a formal reference \npara meter to the access sequence of the corresponding actual parameter. For example, if p is a pro\u00adcedure \nwith the single reference parameter x, then the procedure call p(a), where a is a variable specifier, \nbinds x to the access sequence for a and evaluates the procedure body. In a language like PASCAL, every \nreference to a formal refer\u00adence parameter is automatically dereferenced. If x is a formal reference \nparameter bound to an actual parameter a, an assignment to x in the procedure body changes the binding \nof a (the variable to which x is bound); it does not change the binding of x. The binding of the formal \nref erence parameter x is unchanged for the duration of the call. Consequently, we consider PASCAL s \nnotation for referring to formal reference parameters mis leading. To remedy the situation in our PASCAL \ndialect, we require that every reference to a for\u00admal reference parameter x in the body of the pro\u00adcedure \nhave the form X+ instead of x. (We have taken the f operator from Pascal, where it serves a dereferencing \noperator for pointers.) For in stance, if x is a reference parameter, then the standard Pascal statement \nx + x + 1 is written as x+ + X+ + 1 in our dialeet. we also require formal reference parameter declarations \nto have the form xi:% Ti instead of xi:Ti. To accommodate aliasing within our logic, we must extend the \nset of Hoare assertions to in\u00adclude terms of the form x f where x is declared in the declaration set \nH as x:ref T for some type T. We prohibit the dereferencing operator from appear\u00ading in other contexts. \nThe meaning of x+, given state s consistent with H,is Value (s,Value(s,< x2 ). The access sequence for \nx+ is the value of x. Consequentlyr the access sequence term for X+ is simply x. Our proof rule for assignments \nto derefer\u00adenced formal reference parameters is identical to our ordinary assignment rule: Kx4-+e OP \n{xt+elP where we extend the definition of the simultan\u00adeous update u; + ~ 1 a as follows. Let tibea term \nor formula in L; ~ be a sequence of variable specifiers possibly including derefer\u00adenced formal reference \nparameters; and ~ be a corresponding sequence of terms (not containing updates) . The meaning of u; + \n~ 1 0. for s is the meanin9 of a for Update*(s,~*,~) where Update* is extended to overlapping access \nsequences. Update* is defined by exactly the same axioms as before, except axiom 2) (Section 2.2) no \nlonger requires the access sequences <al, . . ..an> to be disjoint. Informally, a simultaneous update \n~ + ~ with over\u00adlapping variable-specifiers is performed in left\u00adto-right order. The soundness and relative \ncompleteness of the assignment rule stated above are an irmnediate consequence of the fact that Eval(s,x~+e) \n= Update(s,x,e). In order to reason about updated formulas containing updates to dereferenced variables, \nwe need the following axioms about updates. Let P and Q be arbitrary formulas, u , . . . ,Uk be arbi\u00ad \n1 trary terms, and ~ + ~ be an arbitrary simultan\u00ad eous update. Then: 1. K~+=ll(PAQ): [~+~llPA ll~+~lQ,. \n 2. U~+=l(PvQ)= K~+~lPv [~+~lQ. 3. [[~+~](P=Q)= [[~+~]Pa K~+~]]Q,\u00ad 4. [;+E]]?P Z-IK;+E llP,. 5. l-r;+= \n]VZP ~ v= u=+= ]P where ~ not free in ~., [;+E ]3ZP in T., 6. -&#38; [~+ ~ 1P where ~ not free 7. \n~~+~ ] pi(l-l~, . . ..uk) ~  Pi(K~* =]Ul,...,[[~+ E]]Uk) for every predicate symbol Pi (including equality) \n. 8. [~~~ ] fi(Ul, . . ..Uk) = fi(u ;+ FIIUIJ . . ..[[~+ t]]Uk) for every function symbol fi. These \naxioms enable us to move updates inside a formula to the point where they apply only to variable specifiers \nand logical variables. We also need axioms for updates to logical variables and variable specifiers. \nLetvl, ..., Vn be variable specifiers and tl,..., tn be corresponding terms. Let [ . . . ]Ivl, . . ..vn+ \ntl, . . ..tnlia be an arbitrary updated variable specifier. Then: 1. [[... n(vn*=!3*)3 [ . ..] F+:la \n=t . 2. [[ . . . l(vn*6~(d)=a*) =[... 11[=+= la :  u . . . ]Iselect(tl,d) . 3. [[ . . . l(vn ~ o~(d)) \n01... 11[~+~ b = [[ . . . llKvl, . . ..vn_l+ tl, . . ..tJIStore(a.d,tn). 4. [[ . . . ]Disjoint(~(vn*)@~(a*) \n) n  ]][;+: ]cl =[[ ... u . . . l[vl, . .. 7vn_l+tl. tn.ltn-l 1 a. Since updates do not affect loqical \nvariables, the followi~g axiom holds for arbi&#38;ary updated logical variable [...]]: : 5. [... ]Xl \n=xl . The soundness of all the axioms for updates is an immediate consequence of the definition of truth \nfor updated formulas. We can use the axioms for updates to convert an arbitrary formula to update free \nform. To accomplish this transformation, we repeatedly apply the follow\u00ading procedure. First, we push \nall updates inside the formula so that they apply only to variable specifiers and logical variables. \nWe eliminate all updates to loaical variables by applying axiom 5) above. Then for each updated variable \nspecifier K . ...1 [[~+ ~lla, we perform a case split on the relationship ... between K Ivn* and a* \nand apply the appropriate reduction (axioms 1), 2), 3), or 4) above) to each case, reducing the complexity \nof the updates involved. 137 While the update elimination procedure is of evaluating the procedure body. \nAfter evaluating dubious practical value (since it can exponentially the procedure body, Eval performs \nthe appropriate increase the size of a formula) , it demonstrates simultaneous assignme~. that our axioms \nfor updates are complete relative to the unextended base theory. 4.3.2 A Sample Proof Involving Aliasing \n 4.2 Generalized Simultaneous Assignment Rule Given the generalized concept of update de\u00adscribed in \nthe previous section, we can general\u00adize the simultaneous assignment axiom to permit overlapping variables \non the left-hand side of the statement. The new simultaneous assignment axiom is identical to the old \none except that the disjointness premise is omitted. Let % t be a simultaneous assignment statement; \nP be a formula; and E be a declaration set declaring all the program variables appearing in P, ~, or \n~. Then the generalized assignment rule states The soundness and completeness of the rule are an immediate \nconse quence of the fact that Eval(s,~+ ~) = ~ ~ Ells and definition of truth for statements in the logic. \n 4.3 Generalized Procedure Call Rule Assume our PASCAL subset satisfies the restric\u00adtions listed in \nSection 3. Our generalized proce\u00addure call rule is nearly identical to the simple rule. Let p be declared \nas procedure p(var x:ref Tx; value y:Ty); global ~; B in the declaration set H; let P and Q be formulas \ncontaining no free program variables other than ~,~+,~,~ and ~r~+,~ respective\u00adly; let ~ be the free \nlogical variables in P and Q; let ~ and ~ be fresh logical variables correspond\u00ading to ~ and ~; let R \nand S be formulas; and let H denote H augmented by x:reJ Tx, y: Ty, and Pair disjoint (~,~*@~*) (where \nprior declarations of ~ and ~ are replaced). Then: The disjointness hypothesis in H asserts that the \nacess sequences for the formal parame\u00adters are disjoint from the passed actual refer\u00adence parameter access \nsequences. From this hy pothesis we can deduce that the dereferenced for\u00admal reference parameters do \nnot any of the formal parameters as aliases. We must add an analogous hypothesis to the declarion rule \ngiven in Section 2.3.4. 4.3.1 Soundness and Relative Completeness The soundness and relative completeness \nproofs for the generalized procedure call rule differ only in trivial details from the corresponding \nproofs for the simple rule. The only complication concerns the definition of ~. We must not let Eval \nbe confused by formal parameter names which match actual reference parameter names. The simplest solution \nis to force Eval to rename the actual parameters con\u00adflicting with formal parameter names before Let \nswap be the standard integer swap procedure defined by procedure swap(var x,y ref integer); begin ~ \nX+=Xi A Y~=yi; X+,y+ +y+rx+; post y+=xi A x+=yi end; .  First we prove the correctness of the pre and \npost assertions. Let H be a declaration set including the declaration of swap. Let H be H augmented by \nthe formal parameter declarations of swap and the disjointness hypothesis. By the simultaneous assignment \nrule, proving the pre and post assertions for swap reduces to proving the verification condi\u00adtion; H \nI X+=xi A y+=yl ~ [X~,y~~y~JX+](y~=X1 A X~=yi). Moving the update inside generates the equivalent assertion: \nH I Xt=Xi Ay+=yio [X~,y~+y~,x~ly~=Xi A Kx+,Y t +Y+,X+DX+=yi which immediately reduces to: H I X+=Xi A \nY +- yi~ X+=xi. A [X+,y++y+rx+lx+=yi Since x and y are both ref integers we know that H I X=y v Disjoint(Seq(x)&#38;3eq \n(y) ) .  In the former case (x=y), Kx+,y&#38;y+,x4]x+=x+ reducing the verification condition to H ] \nxf=xi~yf=yi~.x~=xiAXf=yi which is true since x=y. In the other case (x and y disjoint), [[X+,y++y+rX+JXf=Y+, \nreducing the veri\u00adfication condition to H I xf=xiAy+=yi~xf=XiAy~=yi which is an obvious tautology. Q.E.D. \nNow let us examine a sample application of the generalized procedure call rule involving aliasing. Let \nH include the declarations a:array integer of integer, i:integer, j:integer. Assume we want ~ prove: \nH I a[i]=al A a[j]=a2{swap(a[i],a[j] )} a[j]=al A a[i]=a2 . By the generalized procedure call ruler we \nmust show H I b xOyO[a[i]=xO A a[j]=yO ~ y =xO A X =yo] o [a[i]=al A a[j]=a2 ~ [[a[i],a[j]+x ,y ](a[j]=alA \na[il=a2)l. Let S denote the consequent of the final implica\u00adtion. Moving the updates within S, further \ninside yields [a[i],a[j]ti ,y ]a[jl=al A K a[il,a[jl+x ,y la[i]=a2  which reduces to y =al A [[a[illa[jl+x \n,y JJa [il=a2. tie instantiate the logical variables XO,YO in the major hypothesis as al and a2 respectively, \ngiving us the hypothesis a[i]=al Aa[j]=a2 ~ y =al A x =a2 . 138 Since the premise of this hypothesis \nis identical to the minor hypothesis, we deduce the new hypothesis y =al A x =a~ . If i#j then S reduces \nprecisely to this formula. On the other hand, if i=j then S reduces to y =al A y =a2 which is a simple \nconsequence of the hypotheses i=j, a[i]=alAa[j]=a2r and y =alAx =a2. Q.E.D. 4.3.3 Handling Recursion \n The recursive form of the generalized procedure call rule is completely analogous to the recursive generalization \nof the simple procedure call rule. The soundness and relative completeness proofs are also nearly identical \nto those for the simple rule. 5. Reducing the Complexity of Proofs Involving  Aliasing Although our \nrules for procedures with alias\u00ading are relatively simple and easy to understand, they are rather cumbersome \nto use in practice, because they force all variable parameters to be passed by reference. Many procedures \nexploiting aliasing are designed to work only for a small subset of the possible aliasing configurations. \nIf all variable parameters .are passed by reference, the pre and post assertions for such a procedure \nmust include a long list of disjointness assumptions. We believe that a procedural programming language \nshould provide two distinct classes of formal variable parameters: those which can have aliases and those \nwhich cannot. The explicit syntactic differentiation between these two classes greatly reduces the number \nof possible aliasing con\u00adfigurations, simplifying reasoning about updates. To incorporate this modification \ninto our PASCAL dialect, we establish the following new syntax for procedures: procedure p(var w:re.f \nTw, X:TX; value Y:TY ; . aliased global Zl; global Z2; B n Section 4.1), ~ are variable parameters which \nhave no aliases within the procedure, ~ are standard value parameters, ~1 are global variab~es which \nmay have aliases in the procedure and 22 are global variables which may not. where ~ are reference parameters \n(as described Within the procedure code block B, an assign\u00adment to any parameter v other than a reference \nparam\u00adeter has the standard form: V+e. In contrast, all references to a reference parameter must be \nexplicitly dereferenced. Hence, an assign\u00adment to a reference parameter w has the form: wk.. The generalized \nprocedure call rule (without recursion) for this extension of PASCAL has the following form. Let p be \ndeclared as shown above in a declaration set H; let P and Q be formulas in L containing no program variables \nother than ---.-. ----\u00adW,W+,Xry,Zl,Z2 and w,wf,x,z1,z2 respectively; let ~ be the free logical variables \nin P and Q; let w ,~ ,;l ,~2 be logical variables corresponding to ;+,%;1,;2 respectively; let R and \nS be arbitrary formulas; and let H be H augmented by w: ref fW X:TX, y:Ty, and Pair-disjoint(;,~*fB~*@*@~~ \n(with prior declarations of ~r~,~ deleted). Then H I p{B}Q, H I v[P(~*/fi,s~fi+,b/x,a/1) Q(W /fi+LX \n~~t~I /~lr~,~2)2) 1 [R [~,5,zl,z2+ ~ ,= ,zl ,z2 ]S]  H j R{p(~,b,~) }Q The soundness and relative completeness \nproofs for the modified rule are essentially unchanged from before. 6. Eliminating the Remaining Restrictions \nOur most general procedure call rules still require the following restrictions: 1. No,.parameters or \nfunctions may be passed as parameters. 2. Every global variable accessed in a procedure must be accessible \nat the point of every call. 3. No procedure named p may be declared within the scope of a procedure \np.  AS [Donahue 76] has pointed out, restriction 2) can be eliminated by making the declaration rule \nrename new variables within program text. A similar strat\u00adegy can be used to eliminate restriction 3) \n. In essence, this approach makes the rules rename pro gram identifiers so that restrictions 2) and 3) \nhold after the renaming. We dislike the idea, how\u00adever, because it modifies the text of a program (and \nany embedded assertions) in the course of a proof. Fortunately, neither of these restrictions handicaps \nthe programmer in anY waY. They simply force him tounambiguously name his variables and procedures. For \nthis reason, we believe these two restrictions are a reasonable part of a practical programming language \ndefinition. In constrast, the remaining restriction--the prohibition of procedures and functions as param\u00adeters- \nprevents the progrannner from using an impor\u00adtant language construct. In some application areas (such \nas numerical analysis), procedures and func\u00adtione as parameters are nearly indispensable. We intend to \nextend Hoare s logic to handle this language construct in a subsequent paper. 7. Acknowledgments We \nare grateful to Ralph London for discover\u00ading several errors in an earlier draft of *his pa per. References \n[Apt and DeBakker 77] Apt, lZ. R. and J. W. DeBakker. Semantics and Proof Theory of PASCAL Proceduresr \nTech. Rpt.r Stichting Mathematisch Centrumr Amsterdam, ]977. [Cook 75] Cook , S. Axiomatic and Interpretive \nSemantics for an Algol Fragment, Tech. Rpt. 79, Dept. of Cornp . Sci., Univ. of Torontor Feb.r 1975. \n[Donahue 761 Donahue, J. E. Complementary Definitions of Programming Language Semanticsr Springer- Verlag, \nBerlin, 1976. [Enderton 72] Enderton, H. A Mathematical Introduction to Logicr Academ~c Press, New York, \n1972. [Gorelick 75] Gorelick, G. A. A Complete Axiomatic System for Proving Assertions about Recursive \nand Non-recursive Programs, Tech. Rpt. 75, Dept. of Comp. Sci., Univ. of Toronto, Jan., ~975. [Guttag \n77] Guttag, J. V., J. J. Horning, and R. L. London. A Proof Rule for EUCLID Proceduresr Tech. Rpt., Xerox \nPARC, Palo Alto, Ca., 1977. [Igarashi, London, and Luckham 75] Automatic Program Verification I: A Logical \nBasis and Its Implementationr Acts Informatica ~ (1975), pp. 145-182. [Hoare 69] Hoare, C. A. R. An Axiomatic \nApproach to Computer Programming, CACM 12, 10 (Oct., 1969), PP. 322-329. [Hoare 71] Hoare, C. A. R. Procedures \nand Parameters: An Axiomatic Approach, Symp. on Semantics . of Algorithmic Languages, E. Engler (cd.) \n, ~ringer-Verlag, Berlin, 1971, pp. 102-116. [Hoare and Wirth 73] Hoare, C. A. R. and N. Wirth. An Axiomatic \nDefinition of the Programming Language PASCAL, Acts Informatica 1 (1971) . [London 77] Londonr R. L., \net al. Proof Rules for the Programming Language EUCLID, Tech. Rpt., Xerox PARC, Palo Alto, Ca., 1977. \n[Oppen 75] Oppen, D. C. On Logic and Program Verification, Tech. Rpt. 82, Dept. of Comp. Sci., Univ. \nof Toronto, 1975.  \n\t\t\t", "proc_id": "512760", "abstract": "This paper presents a new version of Hoare's logic including generalized procedure call and assignment rules which correctly handle aliased variables. Formal justifications are given for the new rules.", "authors": [{"name": "Robert Cartwright", "author_profile_id": "81406592800", "affiliation": "Cornell University, Ithaca, N.Y.", "person_id": "PP79023695", "email_address": "", "orcid_id": ""}, {"name": "Derek Oppen", "author_profile_id": "81332519577", "affiliation": "Stanford University, Stanford, Ca.", "person_id": "PP42050080", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512760.512774", "year": "1978", "article_id": "512774", "conference": "POPL", "title": "Unrestricted procedure calls in Hoare's logic", "url": "http://dl.acm.org/citation.cfm?id=512774"}