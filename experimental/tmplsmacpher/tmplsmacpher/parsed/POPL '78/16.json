{"article_publication_date": "01-01-1978", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1978 ACM 0-12345-678-9 $5.00 COIIfierenCfi? Record of the Fifth AnnUal ACM Symposium on Principles of \nProgramming Languages OFF-LINE AND ON-LINE ALGORITHMS FOR DEDUCING EQUALITIES + Peter Downey The Pennsylvania \nState University, University Park, Pennsylvania 16802 Hanan Samet University of Maryland, College Park, \nMaryland 20742 Ravi Sethi Bell Laboratories, Murray Hill, New Jersey 07974 Abstract In this paper we \nsuppose we are given certain pairs of expressions e. =e l<i<m, 11 i2 The classical common subexpression \nproblem in called axioms or equalities, and ask whether program optimization is the detection of identical \nthese axioms together imply g=h, where g and subexpressions. Suppose we have some extra infor h are some \nexpressions. Also of interest is the mation and are given pairs of expressions e. =e. 11 12 case when \nwe are given inequalities f. zf. ~1 J2 which must have the same value, and expressions l<j <n, and ask \nwhether ei1=ei2 for all i, 31 j2 f, Zf which must have different values. We ask and f. #f for all j \n, together imply either if as a result, This has been ~1 j2 %=h2 r %zh2 g=h (the equality problem), \nor g zh (thecalled the uniform word problem for finitely pre inequality problem). sented algebras, and \nhas applicaticm in theorem proving and code optimizat~on. We show that such The above problems arose \nduring investigationquestions can be answered in O(nlogn) time, by Downey and Sethi [DS1 of opt~mization \nof where n is the number of nodes in a graph programa that manipulate data structures. For representation \nof all relevant expressions. A example, consider the following simple program: linear time algorithm \nfor detecting common sub\u00adexpressions is derived. Algorithms which process A[i]:=i+j; equalities, inequalities \nand deductions on-line A[k-!l,]: =k-l+j; are discussed. m: =A[i]; The value assigned to m is given by \nthe condi 1. Introduction tional if i=k-~ then k f,+j else i+j. The ass~nment to m can safely be replaced \nbySome compilers will recognize that b xc m: = i+j; demonstrating this involves showing is a subexpression \nof both (a+b)/(b Xc) and i=k j,, that whenever it follows thatbxc-d. Such common subexpressions tend \nto k-f,+j=i+j. Both equalities and inequalitiesarise when address computations are made ex\u00admust be considered \nwhile simplifying the nested plicit in commands like A[i,j]: =B[i,j] C[i,j]. conditionals which occur \nwith more complicatedIn the context of array references, another programs, or with multiple subscripts: \ninteresting phenomenon occurs; this time at the source level. Instead of looking for identical A[el,fl]: \n=gl; subexpressions, we need to find expressions that A[e2,f2]: =g2; are equivalent subject to some conditions. \nh: A[el,fl]; For example, whenever as it is a=b;a, Here h is assigned if ~=e2Af1=f2 ~ g2 when a=2; b=4 \nor a=-5; b=25, then it fol\u00adlows that axc=(b:a) Xc. A less direct ~ gl, which simplifies to gl if we can \nshow implication is a =b + (b :a). Iterating that assuming e ~ .e ~ and f1=f2, it follows further, a=b:(b+(b: \na)), and soon. that g2=g1. In inferring and ~X~=(b+~)X~ a=b+(b;a), we do not use any properties of Samet \n[Sal] considers the equivalence of division or subtraction. For that matter, Lisp based programs where \nall predicates are whenever i=$(j,i), then +(k,$(j,i)) =~(k,i), tests for equality. Showing that two \nprograms where @ and $ can be any two functions. are equivalent again reduces to showing that two nested \nconditionals (with equality tests) are + equivalent, thereby involving the equality and The work of this \nauthor was partially supported inequality problems. Shostak [%] considers a by the National Science Foundation \nunder Grant deductive system for solving these problems as a Number MCS75-22557. necessary component \nof a program verification system. The interactive deductive systems [Go] and the symbolic execution systems \n[Ki] used in pro\u00adgram verification require efficient methods for deducing equality or inequality between \nexpression instances. These applications require that a data base of known equalities be maintained to \nde\u00adtermine whether a new equality or inequality is consistent with, or deducible from, the current data \nbase [NOl, N02]- Our object is to give time efficient algo rithms for deducing equalities or inequalities \nof expressions from axioms. we stress that the expressions considered are free of variables, and involve \nonly constant symbols. The following examples suggest the scope of the problems. X=y, it is immediate \nExample 1: Given that that sin(x) =sin(y). However, given sin(m) = = sin(3w), we cannot climb down and \ninfer T= 3% Similarly, given that a*b ~ a, we cannot climb and infer aX c z (b+ a) Xc since c may UP \nbeO. Butgiven axc#(b+a) XC,it follows that a#b+a. Using tests by contradiction, we can turn inequality \nquestions into equality questions. Suppose for example we are given ixk z * (j + i) xk, and are asked \nif as a result, i#j+i? For a test by contradiction, suppose that i=j+i. i#j+i is false i.e. in fact \nIt is i=j+i immediate from that ixk=(j+i)Xk, which contradicts the given statement iXk#(j:i)Xk. Consequently, \nour supposition i=j+i must be false i.e. i#j+i is true. II As in Example 1, we show (Appendix A) that \nthe inequality problem reduces to the equality problem. Furthermore, the given inequalities f. Zf. play \na very minor role, so the equality -jl 32 problem reduces to the uniform word problem de\u00adfined by: given \naxioms ei1=ei2, l~i~m, does .!. it follow that g=h? Example 2: Conceptually, the basic technique for \ntesting equality is substitution of expres sions. Given the following set of axioms, suppose we are asked \nwhether cxd=(b:a-d)xd: c=(c+b-a):a-d b=c:b-(d:c-b) a=d:~-b Substituting a for d+c-b in the second ~vi;~awe \ninfer b=c+b -a. Substituting b fOr in the first axiom yields c=b +a-d. One final substitution of c for \nb:a-d in the ex\u00adpression (b+a-d) xd yields cxd, thereby answering c xd= (b ;a d) xd? in the affirma\u00adtive. \nn The implementation of substitution raises a number of algorithmic issues, since we wi+l employ + The \nprecise term is uniform word problem for finitely presented algebras. some bookkeeping device to keep \ntrack of equiva\u00ad lent expressions rather than performing actual substitutions. The nature of the bookkeeping \ndevice depends critically on the representation of expressions. Before discussing the merits of various \nrepresentations, let us review what is known about the uniform word problem. The problem has long been \nobserved to be decidable; Ackermann [A] gave an exponential decision algorithm. Kozen [KO1] shows that \nthe uniform word problem is logspace complete for P , the class of polynomial time recognizable languages,and \ngives a polynomial time algorithm. Kozen [K02] also shows that the problem requires O(n/logn) space in \none natural proof system. Nelson and Oppen [NO1] have in\u00addependently discovered an O(n e) time algorithm \nusing the methods of Section 5 below, have dis\u00adcussed the connection of the pzoblem with theories of \nLISP-like data structures,and have implemented a simple polynomial-time algorithm for program verification \nstudies. In this paper, our object is to give improved time efficient algorithms for the uniform word \nproblem. In designing an algorithm there are three choices that need to be made: the representation of \nexpressions, the representation of equality information between expressions, and the mechanism for deciding \nwhen an expression f can be derived from an expression e by substituting for a subexpression. In Example \n2, in order to infer c xd= (b +a-d) xd, we need to establish the equality of the subexpressions c and \nb+a-d, as well as b and c~b-a. In general, even though we may be interested in testing the equality of \nexpressions g and h only, it will be necessary to examine all subexpressions of g, h and the axioms. \nA tree representation makes it easy to refer to subexpressions. Each leaf in the tree represents an input \nname, and each non\u00adleaf node represents an operator. The representation of expressions we will actually \nuse is a generalization of a tree called a directed acyclic graph (dag). Dags are formed from trees by \ncollapsing identical subtrees. Figure 1 gives an example of a dag. In the con\u00adtext of dags we will refer \nto nodes rather than to expressions. Both nodes u and x represent the subexpression b+a. b a b a c Figure \n1: Collapsing directed acyclic graph be collapsed further. identical (dag). subtrees The above yields \na dag can The dag representation of expressions arises naturally in the translation of sequences of \nassignments [AU, Cu]. A dag is also a much more economical representation --there are dags with n nodes \nwhose equivalent trees have 2n nodes. Consider thedag in Figurel. The two leaves representing b necessarily \nhave the same value, as do the two leaves representing a. One way of recording these facts is to assign \na number, called a value number, to each node. Nodes wirh the same valuewillhave the samevalue number. \nAn axiom like ~ =b ta ~anbe recorded by forcing the nodes repre senting a and b: a to have the same value \nnumber. Since nodes u and x have the same operator, and their respective sons have the same value number, \nit follows that nodes u and x must have the same value. If nodes u and x initially had different value \nnumbers, we must now change the value number of u to that of x (or vice versa). But there may be a set \nof nodes with the same value number as u and a set of nodes with the same value number as x, so we need \nto merge sets of equivalent nodes. The UNION-FIND algorithm of McIlroy, Morris and Tritter, shown by \nTarjan [Tarj2] to have a practically linear running time, can be used for the purpose. The final issue \nwe must confront is the tech nique used to locate nodes like u and x in figure 1 which have the same \noperator and whose corresponding sons are equivalent. Suppose leaves labelled b, a, c, in Figure 1 have \nvalue numbers 1, 2, 3, respectively. We can form a string for each node using the operator for the node \nand the value numbers of the sons of the node. Thus the strings for u and x will be +12 and the string \nfor z will be x23. The problem now becomes one of locating identical strings. Cocke and Schwartz [CS] \nusehashingof strings which takes linear expected time, but quadratic worst case time. If the strings \nto be checked for equality are all available at the same time, then the lexicographic string sorting \nalgorithms of [AHU] are guaranteed to take linear time, but hashing may be more attractive in practice. \nMethods which do not explicitly set up the strings to be sorted, but rely on controlled edge traversals \nare also available, The data structures needed are similar to those in Sethi [Se2] where an algo rithm \nin the context of processor scheduling is given. Our objective in this paper is to show how the solution \nof the uniform word problem reduces to these two issues: the maintenance of equivalence relations, and \nthe detection of nodes like u and x which have the same operator and equivalent sons. With operators \nlike + and x there is a constant bound on the number of operands. For this case, the uniform word problem \ncan be solved in O(nlogn) time, where n is the number of nodes in a dag representation of the expressions \nto be tested. An algorithm is given in section 4. A linear algorithm is given to detect identical subexpressions \nin section 5. Design of algorithms to handle processing of equalities on-line involves some different \ndesign choices which are discussed in section 6. Section7 places the uniform word problem in perspective \nby relating it to results on other problems. 2. The Problem An expression will be viewed as a tree, where \neach leaf is labelled with an input name chosen from a finite set S , and each nonleaf node is labelled \nwith an operator chosen from a finite set 0. As usual, the number of operands of each operator ~ in~ \nis given by an integer r>l called the rank of @ , and all nodes la~elled with ~ have exactly r sons. \nThe order in which the sons of a node appear is significant. The semantics of expressions are also stan\u00addard. \nExpressions denote elements of a set V of values. We define the value of an expression in terms of an \ninterpretation i that maps each name to an element of V and ope~ator @ of rank c to a function from Vr \nto V. Definition 1: The value under i of an expression e , denoted by q(e), is ~iven by 1. ~(a) =:(a) \nif a is in S, 2. ~(+el ... er) = (:V)(~el, .... ger) if  are expressions. 1 - r An equality is a \nstring of the form e=f , where e and f are expressions. The equality is satisfied under i provided g(e) \n= ~(f) under i. Given a set of e~ualities A , interpretation ; is said to satisfy A if every equality \nin A Is satisfied under i. With these definitions we can formulate the uniform word problemf mentioned \nin the introduc t ion. UNIFORM WORD PROBLEM (for a single equality): Let A={e. ~h ;:+i::;;~:er and the \nequality g=h be given. e g=h is satisfied for all ~ satisfying A? U Since the other problems mentioned \nin the introduction (equality, consistency, inequality) reduce to instances of the uniform word problem, \nwe have chosen to defer a discussion of them to Appendix A. There exist several ways of describing the \nuw problem, dependiug on one s point of view and favorite field. It can be phrased as: the problem of \nassigning identical value numbers to the nodes of a dag that are equivalent under a set of equalities; \nthe problem of deri~ing all valid implications from a set of axioms [Kol]; the problem of calculating \nthe smallest congruence generated by a set of axioms; or the decision . We use the phrase uniform word \nproblem as an abbreviation of the phrase uniform word problem for finitely presented algebras . Finitely \npre sented comes about because A isafinite setof equalities between variable-free expressions. The adjective \n uniform stresses that A is a parameter to the problem. The further abbreviated phrase UW problem will \nsometimes beused for uniformword problem . problem for the quantifier free theory of equality with uninterpreted \nfunction symbols [A, NO1]. The formulation we will actually use facilitates proving the correctness and \nanalyzing the com\u00adplexity of algorithms for the problem. Sincewe will represent expressions by dags, \nthen nodes represent subexpressions. With each node x of a dag is associated a unique expres\u00adsion (tree) \nTx. The value ~(x) of a node under i is ~(Tx) . Let A be a given set of equalit~es. If node x has expression \ng , and g if node Xh has expression h , then testing whether g=h follows from A, reduces to testing if \nq(xg) =~(xh) under all ~ satis\u00adfying A. A is empty in the classic common subexpres sion problem, and \nwe are interested not so much in determining if g =h , as in finding all redundant computations. The \nrelated statement ~terms of dags is that we want to partition the nodes of a dag representing the relevant \nexpressions so that two nodes u and x are in the same class if and only if y(u) =m(x) under all i satisfying \nA. Such a partitio~ defines an equi~alence re\u00adlation on nodes. All equalities between expression will \nbe translated to relations between nodes. A given set of equalities between expressions A={ei1=ei211~i~m} \nwill be represented as a symmetric binary relation on the nodes of a dag. We agree to call this relation \nA also. Inter\u00adpretation i is said to satisfy A if ~(u) = = g(x) when~ver UAX . We can now restate the \nuw problem in the setting of dags. UNIFORM WORD PROBLEM (full version): Given a dag D and a binary relation \nA on the nodes ofD, find a relation R such that URX if and only i~ g(u) =~(x) under all _isatisfying \nA. D At this time, we will not pursue the dis tinction between the full version of the uw problem which \ndetermines a partition on the nodes of a dag, and the single equality version which checks two given \nnodes for equality. A similar distinction applies to finite automata, where the best known algorithms \nfor the two versions have different time complexities: Hopcroft and Karp [HK] give a practically linear \nalgorithm for determining equivalence of two finite automata, and Hopcroft [H] gives an O(nlogn) algorithms \nfor partitioning the states of a finite automaton into equivalence classes. 3. Basic Lemmas Given a=b \nand b=c it immediately follows that a=c since equivalence is transitive. Equally obvious is that we can \nalways substitute equals for equals within an expression. These two observations form the basis of two \ntrans\u00ad formations -t (transitive) and SC (collapsing or congruence) . We will show in this section that \n+ t and d are exactly what is needed to solve c the uw problem; efficiently computing the closur~ of \nthese transformations then becomes our goal. Consider the dag in Figure 1. The two leaves representing \nb necessarily have the same value, as do the two leaves representing a. Once leaves representing the \nsame name have been related, we can infer that nodes u and x must have the same value under all interpretations, \nThese ob servations lead to the following collapsing transformation + c Definition 2: Let R be a binary \nrelation on the nodes of dag D. R transforms to R U{(U,X)(X,U)} under +C if and only if URX is false, \nand 1. u and x are leaves representing the same name a, or 2. u and x representing the same operator \n+, have sons W13WZ9 . . . . dr and Y1, Y2, . . ..Yti  respectively, and for all j, 1 <j <r , wjRyj , \n orw.= n J j We also need a transitive transformation. Definition 3: Let R be abinary relationon thenodesofadag \nD. R transforms to R U{(U,X), (x,u)} under -t if and only if URX is false, and for some node z, URZ and \nZRX are both true. D Since we will apply both~c and at we use + to denote+c_J+ t i.e. P dR ifand only \nif P~cR or P*tR. By definition, anapplication of * adds a Pair Of nodes to a relation, so starting with \nany relation P , scan only be applied a fini~e number of times in succession. We say P is irreducible \nunder a if and only if for all R, P SR is false. +*R and R is irredu-We write P *-R. when p cible under \n+ .T A major advantage of not fixing the order of application of *C and + is that the t correctness of \nany algorithm that applies *C and + in any order, until no longer possible, fol\u00ad t lows from Theorem \n1. The price to be paid for this advantage ia a modest one: we have to verify that the order in which \nthe transformation * adds pairs does not matter. More precisely, from the properties of +C and at , we \ncan verify that if P +*R and P +*S by adding different pairs to P, then there exists T such that R *%T \nand S **T. Thus if P +-T1 and P *-T2, we can ? P +OR if and only if R is P. For i>O, P + lR if and only \nif P * P and pr ~i-lR. We write P S*R if P *iR for some i>O. show that must be the same as A system 1 \n2 such as the one we are working with in which each object transforms to a unique irreducible element \nis said to have the finite Church Rosser property (See Sethi [Sel] for details). Since irreduc~ble elements \nare unique under ~,we will write P for the irreducible relation that P transforms to under * . The rest \nof this section shows (Theorem 1) that starting with a given relation A , the solution to the full version \nof thg uniform word problem is given by the relation A. LEPD4A 1: For all nodes u and x , &#38; implies \nthat ~(u) = ~(x) under all ~ satisfying A. Proof: Let AO be A , and let o Al  % be some sequence of \nsymmetric re~ations such that for i>O, Ai_l >Ai , and Ak=A. We prove the le~a by inductfon on the least \n~ such that UAiX. basis, i=O: Then UAOX , so by definition, m(u) =m(x) unde.rail ~ satisfying A. . inductive \nsteD, i >0: If A 3A then i 1 ti there exists z such tihat uAi_lz and XA i-lz From the inductive hypothesis, \n~(u) =m(z) =m(x) under all i satisfying A. If Ai_la cAi , then u and x either represent the same input \nname, or they represent the same operator, and (from the inductive hypothesis) son of u j has the same \nvalue as son of x, for all j. j The lemma follows. O The interesting part is showing that the con verse \nof the above lemma is true. In other words, if u and x have the same value unde$ all interpretations \nsatisfying A , then u.&#38;. Some insight can be gained by considering the case where no two nodes are \nassumed equal so A is the empty relation. Then we can use a free interpretation that assigns the expression \nof node u as the meaning of u , so that u and x have the same value exactly when they have identical \nexpressions. Since the transformation + collapses identical subexpressions, the last statement translates \nto . . exactly when uk . A similar idea works with any A. We will pro\u00adceed by defining a particular interpretation \n&#38; satisfying A , under which nodes u and x will have the same value exactly when u gnd x are in the \nsame equivalence class under A. Definition 4: Given a relation A let ~ partition the nodes of D into \ni equivalence classes. Assign an integer from 1 through i to each equivalence class: let rI(x) give the \nnumber of the equivalence class for node x. Define as follows: A 1. If some leaf x represents name a \n, then let &#38;A(a) = ~(x). 2. If some node x represents operator + , and  has sons function Yl, Y2, \n.... Yr, let the LA@ map (~yl, TlY2, . . . . ~Yr) to rl(x) n Before we use the above defin: tion, we \nmust verify that A is a function. A. LEMMA 2: A is an interpret: tion satisfying Proof: By definition, \nall leaves representing the same name are in the same equivalence class, so for any name a, Q(a) is unique. \nSuppose that there are two nodes u and representing the same operator $ ,with sons w~? W29 .... Wr and \nYl, Y2, .... Yr, respectively, such that rIw j=nYj. Since A is irreducible under =5 it follows that rIu=rlx. \nc Thus is a function. &#38;A~ Sigce A is a subset of A ,if UAX , we have UAX , so vu=nx. Therefore satisfies \n4A A. n THEOREM 1 (Completeness of +): For all nodes u and x in D, UAX if and only if ~(u) =m(x) under \nall : satisfying A. Proof: One direction is Lemma 1. Conversely, suppose g(u) =y(x) under all ~ satisfying \nA. Then ~(u) =~(x) under By the definition of h it is clear that ~(z) =~(z) under for %4 2A all z. Thus \nrI(u) =rI(x) and ~x. Cl Relation ~ which is formed from A by taking the closure under s c and + is the \nt minimal congruence relation on expressions which satisfies A [Kol, NOI.]. In an independent development \nShostak [Sh] gives a result similar to Theorem 1, using a least binary relation closed under conditions \nsimilar to * c and +t . The interpretation of Definition 4 corresponds to % the Herbrand model given \nby Shostak. Our use of transformations makes it easy to connect Theoreml with algorithms. 4. An O(nlogn) \nAlgorithm From Theorem 1, the uniform word problem can be solved by starting with a given set of equal\u00adities \nA and applying transformations ac and + in any order, until no longer possible, to t\u00adyield A. For then \ntw~ nodes are in the same equivalence class of A if and only if they have the same value subject to the \nequalities of A. If we can find a sequence of ever coarser equivalence relations that starts with A and \nconverges to A , then we can give an easy upper bound on the length of the sequence. Given a symmetric \nrelation A , let A. be the equivalence relation formed by taking the reflexive, transi\u00adtive closure of \nA. Consider a sequence of equivalence relations O 1  k n he nodes of D such that Aj >* A and j~l k \ns irreducible. Then Ak must be A. Clearly, A is formed by merging equivalence classes of j +1 .j , Aj+l \n A ,. If for each has at least one less 3 equivalence class than A. , then we are assured J that k<n \n, where n is the number of nodes of D. For operators like + and x there is a constant bound (two) on \nthe number of operands. For simplicity of exposition we will give the algorithm and its analysis assuming \nall operators have rank two. Algorithm Atilde in Figure 2 starts by par titioning the nodes into equivalence \nclasses based on the reflexive, transitive closure of the o given equalities A. All nodes in a particular \nequivalence class are given a common value number, represented by the array VW indexed by nodes. The \nnodes are then processed in some topologically sorted order. As a new node u is encountered, a string \nU consisting of the operator of u followed by the current value numbers of the sons of u , is constructed. \nFor the purposes of this discussion, the strings are hashed into a table ACL (for Available Computations \nList). If D is in the table, then there must be some other node x with the same string u , so the equivalence \nclasses for u and x have to be merged by procedure Merge. When value numbers are changed to put u and \nx in the same class, the strings for the fathers may have changed, so procedure Merge examines the fathers. \nLet D be a dag with n vertices and e edges. Let A be a set of node pairs, and let IAI give the number \nof elements of A. LEMMA 3: Algorithm Atilde correctly computes L. Proof: The value numbers in the array \nVN define an equivalence relation on nodes. Let Ri be the equivalence relation defined by VN just before \nthe i + 1st call to Merge. It is clearly the case that Ri_l ~*Ri , so that uRix only if u~. Conversely, \nlet tix. Let A. be the re\u00ad flexive closure of A and let O l --. Akbe some sequence of relations such \nthat Ai_l *Ai and Ak = A. We prove by induction on i that: for all i there is some r such that UAix \nimplies uRr X . Suppose uAix. basis, i=O: Here r =0 suffices. inductive step, i>O: If Ai_l @tAi then \nthere exists z such that uA. z and zA. X. 1 1 1.-1 From the induction hypothesis, there is a r such that \nu~z and z~x , so that UR XX . If Ai_l +cAi then u and x have the same label and their corresponding sons \nare re\u00adlated by Ai_l. From the induction hypothesis, cor responding sons are related by Rr, for some \nleast integer, r , i.e., they have the same value number just before the r + 1st call to Merge. Consider \nthe rth call to Merge. From the choice of r , a pair of corresponding sons of u and x get placed in the \nsame equivalence class by being assigned the same value number. If both u and x have been marked by Atilde, \nthen there is an appropriate string for each of u and x on ACL. When all nodes on FATHERS(j) are con\u00adsidered \nin Merge, u and x will be placed in the same equivalence class. Alternately, if u and x have not both \nbeen marked by Atilde, then when the last of u and x to be marked is sub sequently processed by Atilde, \nit will be placed in the same equivalence class as the other node. The above induction establishes that \nif &#38; then uRrx for some r , and at termination u and x have the same value number. U THEOREM 2: Given \na dag D and a set of equalities A , let D have n nodes. Assume each nonleaf-node has two sons. Algorithm \nAtilde determines A in O(lA\\ + nlogn) time. Proof; From Lemma 3, Algorithm Atilde de\u00adtermines A , so \nwe just need to verify the time bound. Step 1 requires O(n+\\Al) time since each equality must be looked \nat, and the components of an undirected graph can be found in linear time [Tarjl]. Aside from the time \ntaken to check entries on ACL and the time spent in Merge, the time taken in the while loop is proportional \nto the number of nodes. In order to ensure that an entry can be added or retrieved from ACL in constant \ntime, organize the ACL as a trie [Kn]-Each node in the trie will be an array of length n , with each \nelement of the array being a pointer to the appropriate son of the node. Since there is a constant bound \n2 on the number of sons of a node, the lengthof each string is bounded by 2. Given strings of length \n2 the space required by the trie is O(n2). We avoid initialization costs using a pointer stack as in \n[AHU, exercise 2.12]. Thus the overti time taken in procedure Atilde is linear. Consider the calls to \nprocedure Merge. Calls of the form Merge (k,k) talce constant time and can be charged to the point at \nwhich the call occurs. If lFATHERS(k)l <lFATHERS(j)l, then in constant time the call Merge (k,j) is converted \nto Merge (j,k). Since the value numbers define an equivalence class on nodes, there may be at most n \ncalls in which value numbers are changed. So all we have to verify is that the total time spent over \nthese n calls is O(nlogn). When two classes are merged, we are careful to merge the class with fewer \nfathers into the other class. Thus , every time a father x is reprocessed because of son y , the FAT.HERS \nlist for the class of y doubles in size. Since there are a linear number of edges in the dag, and the \nnumber of entries on a FATHERS list is limited by the number of edges, node x is reprocessed at most \nO(logn) times because of y. Since there are at worst two sons of x , node x is repro\u00adcessed at most O(logn) \ntimes. It follows that the total time charged to Merge is O(nlogn). Summing the time taken by Atilde \nand Merge, we get O(IAI +nlogn). o /~~Input: A dag D and a set A of node pairs that are given to have \nthe same value. The nodes of D are assumed to have been given numeric identifiers in the range 1 to n,so \nthat they can be bucketed efficiently. Since lexical analyzers normally assign internal names to variables, \nthis assumption is not felt to be unreasonable. output : Equivalence ~ where ~y if and only if VW(x) \n=VN(y), i.e. x and y have the same value under all interpretations satisfying A. Structures: VN(l:n) \nmaintains the value numbers of nodes. Each element ofarrays FATHERS (l:n) and NODES(l:n) isa linked list \nofnodes. ACL, the available computations list, contains pairs (o, m), where o is a string, and m is a \nvalue number. The two operations performed on ACL are the insertion of a new entry on AC~ and the retrieval \nof an entry for a string G. G(l:n) is the adjacency structure for an un directed graph. NX(D) enumerates \nthe nodes of D in topological order, starting with the leaves. It returns ~ when there are no more nodes. \n*I procedure Atilde (D,A) /*initialize A. fc/ 1. for each pair (x,y)&#38;A do add edge (x,y) to G end \nLocate the connected components of G using depth first search. Set the VN of each node in the first component \nto 1, in the second component to 2, etc. 2. x:=NX(D);  while x # null do Mark ~ Let !,, r be the sons \nof x, left to right. Add x to the list.FATHERS(VN(j?,)) and FATHERS (vN(r))/* if x is a leaf, do nothing*/ \nif the ACL has an entry for O= OP(x)VN(J?,)VN(r) then Merge (VN(x),m), where m is the value number entered \nfor D else insert (0, VN(x)) on ACL and add x to the list NODES(VN(X)). x:=NX(D) end end Atilde; procedure \nMerge (k,j): if k=j then return ~seif \\ FATHERS(k) < I FATHERS(j) I then Merge(j,k) else for all y on \nNODES(j) do VN(y):=k@; for all x on FATHERS(j) d= Let x have sons ,L, r-left to right. if the ACL has \nan entry for o=OP(x)VN(L)VN(r) then Merge (VN(x),m), where m is the value number entered for 0. end Append \nlist NODES(j) to NODES(k). Append list FATHERS(j) to FATHERS(k). end Merge; Figure 2: Algorithm for the \nuniform word problem In practice, ACL might well be implemented as a hash table, not as a trie. But then \nonly the expected time to search the ACL is constant, not the worst case time. To extend the above algorithm \nto the case of dags D with other than binary operators, we use an observation due to Tarjan [Tarj3]. \nReplace each node x with label $ and r sons by a chain of binary nodes and dummy operator symbols, as \nsuggested in Figure 3. The resulting dag D can be processed by Algorithm Atilde. Since every r-ary node \nof D gives rise to r 1 binary nodes in D , then D has no more vertices than D has edges. This yields \nan O(e loge+ IAI) time overall. D D Figure 3: Transforming r-ary to binary nodes. Suppose that the operators \n(3 are assumed to be commutative, i.e., the ordering on the sons at each node is immaterial. We can readily \nex\u00adtend Algorithm Atilde to cover this case. COROLLARY 1: When operators are commutative, ~ can be computed \nfrom A without affecting the time bound. Proof: Instead of constructing string o= OP(x)VN(J?,)VN(r) \nin procedures Atilde and Merge, sort VN(!L), VN(r) to get string in decreasing order. Use string Ivz \n0P(X)V1V2 instead of o when checking strings against ACL. The time bound does not change. U Algorithm \nrequires O(n+ Zi(ni+ei)) = = O(n+e) time total. O 5. A Linear Alporithm for the Common Subexpression \nProblem For particular cases of the uniform word prob problem, more efficient algorithms can b~ written \nIf the set A of pairs is empty then xAy if and only if the trees rooted at x and y are iden\u00adtical. Such \nnodes are called strongly equivalent. The problem of computing ~ has been called common subexpression \ndetection . Cocke and Schwartz [CS] use hash table searching to solve this problem in expected linear \ntime, and worst case time 0(n2). Here we give an algorithm, Partition, with linear performance in worst \ncase. Let the height of a node x in D be the length of the longest path from x to a leaf. Any two strongly \nequivalent nodes of D must be at the same height. Thus Algorithm Partition needs to discriminate only \nnodes of a given height. Each node is assigned a value number which never changes. To assign value numbers \nto nodes at height i , the algorithm needs to lexicograph ically sort only the height i nodes, and needs \nto use only as many buckets as these nodes have sons. The algorithm is given in Figure 4. Algorithm Partition \ngeneralizes the algorithm from Aho et. al. [AHU, p. 84] for determining whether two labelled, unordered \ntrees are iao morphic. Algorithm Partition solves the subdag isomorphism problem for labelled, ordered \ndags (and for trees as a special case). THEOREM 3: Let A be an empty relation on the nodes of dag D , \nwith n nodes and e edges. Algorithm Partition correctly determines ~ in time O(n + e). Proof: (correctness). \nAny two strongly equivalent nodes must be at the same hieght. On the first iteration, the leaves are \ncorrectly identified. Assuming Partition has identified strongly equivalent nodes at height i , it is \neasy to see that the strongly equivalent nodes at height i+l are correctly identified. (analysis). Let \nni be the number of nodes of height i. Let ei be the total number of edges from nodes of height i to \ntheir sons. Clearly Eni = n and Ze. = e. 1 Consider the loop body. Step 2 takes time O(ni + ei) on iteration \ni. The size of the LIST built is \\LISTl .~n. + e.. Step 3 adds to QUEUE strings with total~leng~h ni+e. \nin time 1 O(ni+ei). Thus Step 4 sorts strings of total length ni+ei using ILISTI buckets. This takes \nO(ni + ~i + ILISTI) = O(ni + ei) time. Step 5 can clearly be done in O(ni+ei) , and Step 6 is bounded \nby O(lLISTl). The loop body takea O(ni+ei) overall. Since Step 1 takea O(n), the /*Input: A dag D with \nn nodes. The leaves of D have labels from a set S of names, and the nonleaves have labels from a set \n8. For convenience assume each element ~ of G US haa been assigned an integer NR(~) between 1 and n. \noutput : An array VN(l:n) where x is strongly equivalent toy if and only if VN(x) =VN(y). Structures: \nBUCKET(l:n) and QUEUE are needed for lexicographic sorting. BBIT(l:n) is an array of bits. LIST is a \nlinked list of bucket indices. */ procedure Partition(D) 1. Find the height of all nodes in D. Let h \n= maximum height of any node. i:=O COUNT:=l LIST:=null Set al~CKETS to ~ Set all BBITS to falSe QUEUE:=\u00ad \nwhile i<h ~ 2. Scan the nodes at height i , collecting in LIST the value numbers of sons of these nodes. \nSet BBIT(i) each time value number i is encountered and add i to LIST only the first time, Add NR(V) \nto LIST for each distinct element ~ of O US encountered. 3. For each node x at height i with label @ \nand sons yl, . . . . yr, add string  NR($)VN(Y1) . . . VN(yr) to QUEUE. (Note r=O for leaves.) Call \nthis the string of x. 4. Lexicographically sort the strings on QUEUE , using only the BUCKETS with indices \non LIST. 5. Scan the QUEUE , assigning distinct suc\u00adcessive value numbers to those nodes with distinct \nstrings on QUEUE. Increment COUNT accordingly. 6. for each i on LIST do  unset BBIT(i) BUCKET(i):=~ \nend LIST : =~ i:=i+l end return (VN) &#38; Partition Figure 4: Algorithm for Common Subexpresaion Detection \nAlgorithm Partition can beused asa subroutine to provide an algorithm for theuniform word problem, that \ndoesnot require hashing or triesas inthe proof of Theorem2. Nelsonand Oppen [NO1] have independent\u00adly \ndiscovered an algorithmwith the same time bound. COROLLARY 2: Given a dag D with n nodes and e edges, \nand a set of equalities A , the uniform word problem can be solved in O(n.e+ IAI) time. Proof : See Nelson \nand Oppen [NO1]. O In the special case of the uniform word problem in which there is given a single equality \ne=f between expressions, linear time suffices. This problem arises in Downey and Sethi [DS] where a restricted \nclass of programs with array assign\u00adments is studied. COROLLARY 3: Let A Sontain a single pairof nodes \nA= {(U,V)}. Then A can be determined in time O(n+e). Proof: Let D and Dv be the subdags of u D rooted \nat u and v respectively. If neither of u and v is an ancestor of the other, then redirect all edges coming \ninto u or v to a new node x and run Partition on the resulting modified dag. Suppose that v isan ancestor \nof u in D. Then Du is a subdag of Dv. Call two nodes x and y equivalen~ if ~y. A node equivalent to v \nwill be called a v node. For each node x in D define the v-height of x to be the eight of node x above \nits closest v node descendant. Nodes with no descendant v-nodes have v height ~ . Nodes u and v have \nv-height zero. Let x be anode in D of height i and v-height j. It is easy to see that if x is equivalent \nto any node of height less than i , then x is equivalent to some node y of the same v height j in Dv. \nGiven D , we can run Partition on D and collapse strongly equivalent nodes. So assume that D is given \nwith distinct nodes having dis\u00adtinct expressions. Run Partition on subdag Dv , assigning value numbers. \nAssign the same value number to u and v. Next modify Partition to proceed to consider nodes in order \nof v-height above v. Steps 2 and 3 are modified to scan nodes of v height i in Dv and queue up the appropri~te \nstrings at this v-height . After all nodes with v-height less than co have heen processed, the remaining \nnodes are pro cessed by Partition in order of increasing height. To maintain the v-height of each node \nabove v an array VHT(l:n) is maintained. The v height of a node is calculated using the v-height of its \nsons, and is set to zero when ever the count reaches the v height of v. O 6. An On-Line Algorithm The \nabove algorithms for the uniform word problem all assume that the given equalities (and inequalities) \nbetween expressions are known before any deductions need to be drawn, and that expres\u00adsions are presented \nin the form of dags. Thus the algorithms are off-line. These assumptions are realistic in contexts involving \ncode opti mization; however, for interactive applications such as theorem proving and symbolic execution, \nequalities, inequalities and requests to perform deductions may arrive in any order. Algorithms are needed \nwhich are on-line and lend themselves to a dynamically changing environment of known equalities and inequalities. \nThis is especially true in symbolic execution systems [Ki] where alternating program paths are explored: \nin one path an equality is assumed true and in another path it is assumed false. For example, we would \nlike to be able to process the following transaction stream on-line: example: 1. f(a) =c 2. f(b) =d \n3. a=b  C=d? 4. deduce: 5. g(a,b) *g(b,d) 6. h(c) zh(d) 7. deduce: b%d? The order in which the equalities \nare en countered <? important: if a=b were encountered before f(a) =C and f(b) =d then the equality c \n=d would be quite easy to prove. An algorithm for the above example is on-line if each equalj.ty, inequality \nor deduction request is completely processed before the next is read. Thus before input 5 is read, the \nalgorithm must answer whether or not is deducible from the C=d information in 1, 2 and 3. Similarly before \ninput 7 is read, the algorithm must respond that inequality 6 is inconsistent with the information in \n1to 5. The basic problem is that of creating and updating a data base for equalities so that a simple \ndecision algorithm can be used to determine if two expressions are indeed equal. Me will use the notion \nof equivalence classes to keep track of all expressions known to be equal. An equiva lence class is constructed \nfor each expression which has been encountered while processing equalities. A class is represented by \na value numb er, Moreover, the subexpressions of each expression are represented in terms of their value \nnumbers. For example, when the equality f(a) =C is processed an equivalence class is created for a (say \n~) , for f(a) (say ~ whose member is f(0)), and for c (say ~). An lvailable Compu\u00adta~ion List (ACL) is \nmaintained with the definitions (a,~)(f(~),~)(c,~), which is accessed by hashing on the lefthand element. \nThe equality of f(a) =C is processed by merging the two equivalence classes ~ and ~, and all subsequent \nreferences to f(a) or c are by use of the lowest numbered equivalence class which was merged --i.e., \n~ in our example. This would result in an ACL altered to (a,~)(f(~),~)(c,~>. The process of adding an \nequality to the data base consists of: (1) For each half of the equality determine the equivalence class \nin which it is contained (create one if it is not contained in any equivalence class). This is done by \nparsing each expression bottom up, using the ACL to assign value numbers to subexpressions. This is done \nby routine Parse in figure 5. (2) Merge the two equivalence classes (by routine Propagate in figure \n5.  (3) Update all references to the merged equivalence classes to point to the new equivalence class. \n (4) Merge all equivalence classes whose equivalence is a direct consequenceof 2 (by virtue of the collapsing \ntransformation -c). This may re\u00ad  sult in the merge routine Propagate being called recursively. As a \nclarification of (4) consider the case .. when a=b, and f(a) and f(b) appear in separate equivalence \nclasses, labelled P and with ~<g. Then (2) implies that f(a) and f(b) are to be uniquely represented \nas f(n)(y is the name of the equivalence class contai~ing a and b), and thus the two classes containing \nf(a) and f(b) are merged into one class ~. All ACL references to q are altered to ~. The process of determining \nthe equivalence class (value number) of an expression mav be thoughtof as a form of simple precedence \nparsing against the reductions available in the ACL. The algorithm for adding an equality to the data \nbase is given in Figure 5. The data base consists of an indexed table ACL , one entry for each node processed \nto date. (We will persist in referring to nodes instead of expressions and subexpressions) . An entry \nACL[j] is of the form (a,m) where o is a string $V1V2 . . . Vr consisting of an operator symbol and son \nvalue numbers; m is the value number of the associated node. ACL is accessed by hashing on the strings \n0. All references to a member of an equivalence class are in terms of its value number. Pro\u00adcedure Propagate \ninsures that the value number of any class equals the smallest index of any node in the class. Steps \n1 and 2 correspond to the merging of equivalence classes due to transitivity: al 1 references to the \nmerged value numbers rein, max are replaced by the minimum value number. Step 3 enforces the propagation \nof equality by the collapsing transformation: when two ACL entries (a,i) and (o,k) with identical strings \nare found, the classes i and k are merged by recursively calling Propagate. There are no more than IACLI \ncalls of Propagate for each call to Update. MODS is a list of ACL indexes of entries (a,m) which mention \nmax or min in 0; thus it is a list of father nodes affected by the merge of max and min. MODS is maintained \nin ascending sort to simplify the search for a string match in Step 3. Step 3 need only be applied to \nentries on MODS. Note that duplicate ACL entries caused by merging of value numbers are deleted (Since \nACL is hashed, we do not actually remove these duplicates, but only mark them as deleted).. The process \nof determining the equivalence of two expressions is quite simple from a computa\u00adtional standpoint. Specifically, \nin parsing an expression there are exactly as many probes of the ACL to be made as there are input names \nand operator symbols in the expressions. The process of updating the ACL can be speeded up significantly \nby the maintenance of linked lists NODES[l:n] and FATHERS[l:n]. NODES[i], which links all members of \nequivalence class i , obviates, in part, the need for Step 2. FATHERS[iJ, which links all equivalence \nclasses having the son i , obviates the need for Step 3 and the preparatory Steps 1 and 2. Inequalities \ncan also be handled. This is accomplished by maintaining a table NEQL of pairs of equivalence classes \n(value numbers) which are known to be unequal. The algorithm for proving equalities needs only a slight \nmodification to be able to cope with inequality queries such as bzd? in the above example. In such a \ncase, the inequality does not appear explicitly in the data base. Instead, we derive it by contradiction. \nWe assume that b=d and (temporarily) add this relationship to our data base. If b zd is true, then a \ncontradiction will occur. This contra\u00addiction is detected at the occurrence of an attempted merge of \ntwo equivalence classes which are known to be unequal(those of g(a,b) and g(b,d) in the above example). \nEach entry in NEQL is a pair of value numbers. Therefore, whenever a merge of two equivalence classes \noccurs, this table must also be updated. NEQL is updated just before Step 1 of F-ropagate as follows: \nfor each pair (x,y) in NEQL do replace each occurrence of max by min ~ (x,Y); if x=y then contradiction \n; end Note that the inequality algorithm modifies the data base ACL. Should a contradiction be detected, \nwe would like to undo the updating that has occurred. This is not a problem if the algorithm operates \nin a recursive environment. where dynamic storage allocation and garbage collection are available (e.g., \nLISP). 7. RelatedResules Paterson and Wegman [PW] consider unification, which can be described informally \nas follows: given two expressions g and h containing variable symbols, substitute subexpressions for \nthe ~ariables in such a way as to make g and h identical. In the uniform word problem, we start with \na given set of equalities A and ask if g and h are equivalent. The unification problemis to start with \nexpressions g and h and ask if there exists a (suitably constrained) set of equtilities A subject to \nwhich g and h are equivalent. The two problems are quite different. While an O(n) algorithm exists for \nunification, O(nlogn) is the best comparable result for the uw problem. And while assuming operator commuta \ntivity does not affect the uw problem complexity, it can be shown that unification with commutative operators \nis NP-hard. where e,f are variable-free expressions. procedure Update (e,f) /* e,f are expressions; e=f \nis the axiom to be added to the data base*/ L:=Parse(e) /* obtain the value numbers r:=Parse(f) /* of \ne,f from the ACL&#38;/ Propagate (!,, r,null) /* propagate effect of new equivalence through the data \nbase*/ end Update; procedure Propagate (rein, max, MODS) ifmin >max then swap min and max /* ~in <a/ \n/* rein, ma; are the value numbers of the equivalence classes being merged. MODS is a listof ACL indices, \nin ascending sort, of entries which mention max or rein*/ 1. for non-deleted j , min+l~j~IACLl do Let \nACL[j]= (O,m) if min occurs in o then insert j in MODS end 2. for non-deleted j , max~j~\\ACLl ~ /*replaceall \ninstances of max bY rein* / Let ACL[j]= (O,m} if m=max then replace m by min T lf max occurs in O then \nReplace all occurrences of max in oby min Rehash (0) Insert j in MODS I* rehashing needed since string \no has changed*/ end 3. while MODS znull do /*step through the list of affected nodes looking for matching \nstrings and propagate merge*/ Let h be the smallest index on MODS Delete h from MODS Let ACL[h]= {o,i) \nfor each j on MODS do Let ACL[j]= (T=) if 0=T then /*matching string~~/ Delete j from MODS Mark ACL[j] \ndeleted from ACL /*Classes i,k must be merged*/ %op~g~~e~k, MODS) end end end Propagate; Figure 5: Algorithm \nto Process an Equality The axioms given in the uniform word problem are equalities between expressions \nnot involving any variables. But a law like the commutative law x+y=y+ x is really a scheme for inferring \nmany instances of axioms of the form e+f= f-te Let X= {x,y, . ..} be a set of variables. Equalities between \nexpressions over Qusux are called axiom schemata. We review the effect on the complexity of the uniform \nword problem which results from admitting schemata. As wehave seen, introducing only the commutative \naxiom schema for operators does nonmaterially affect the decision procedure for equality. If A is a set \nof axioms over S U{.}, then A lJ{x. (yoz)= = (Xoy) z} generates a finitely presented semi\u00adgroup. The \nuniform word problem for semigroups is well known to be undecidable [Tars]. Indeed there exists a fixed \nset of axioms A for which the word problem is undecidable. What happens when both associativity and commutativity \nof operator . are admitted? If A is a finite set of axioms, A U{XO(y.Z) = = (x.y).z , x.y=y.x} generates \na finitely pre\u00adsented commutative semigroup. The uniform word problem for such commutative semigroups \nis decidable; however, a recent result shows that this problem is complete in exponential space [CLM]. \nIt follows that for infinitely many A, deciding equality of expressions requires ex ponential time. Kozen \n[KO1] has shown that inferring schemata from a set of variable-free axioms is a hard problem. Knuth and \nBendix [KB] and Lankford [L] give algorithms which work to decide word problems for some sets of schemata. \n Appendix A: Inequalities and the Uniform Word Problem Let A= {ei1=ei2\\l<i <m} and B={f be sets of equalities \nand jl 2fj211~j~n}  inequalities, respectively. We shall also use A and B for the conjunctions A= Ai(ei1=ei2) \nand B= flj (fjl*fj 2). Formulas are built up from equalities using the usual logical connective vsA91 \nand >. Formulas of the type _ g=h will be abbreviated gzh. The meaning function m can readily be extended \nto formulas. A form~la F is satisfied under ~ provided g(F) is true. A formula is consistent if it is \nsatisfied by some i. A formula is valid if it is satisfied by ~11 i. Consider the following four problems. \nGiven sets A and B as above, and expressions g and h: (a) EQUALITY PROBLEM: Determine whether g=h is \nsatisfied for all i satisfying AAB. This is the same as determining whether A A B a(g=h) is valid. (b) \nCONSISTENCY PROBLEM: Determine whether there exists i satisfying AAB. This is the same as ~etermining \nwhether ~ (AA B) is invalid. (c) Inequality pROBLEM: Determine whether g #h is satisfied for all i satisfying \nAAB. This is the same as determin%gwhether AAB3(g #h) is valid. (d) UNIFORM WORD PROBLEM: Determine \nwhether g.h is satisfied for all ~ satisfying just the equalities A. Thisis the same as determining \n whether Aa(g=h) is valid. All four problems reduce to instances of the [CLM] E. Cardoza, R. Lipton and \nA. R. Meyer, uniform word problem, as may be seen from the Exponential space complete problems for following \nlemmas. Petri nets and commutative semigroups, Proc. 8th Ann. ACM Symp. on Theory of LEW Al: Given A \n= Ai(ei1=ei2), and Computing, Hershey, PA (May 1976) 50-54. B = Aj(fj1#fj2 ), and expressions g and h: \n[Cs] John Cocke and J. T. Schwartz, Programming Languages and Their Compilers Preliminary (a) AA B a(g=h) \nisvalid if and only if, Notes, Second Revised Version, Courant A~Vj(fj1=fj2) V(g=h) is valid. Institute \nof Mathematical Sciences, New (b) y (AA B) is invalid if and only if York, NY (April 1970). A3Vj(fjl=fj2) \nis invalid. [Cu] Karel Culik, Combinatorial problems in the (c) AA B =(g*h) is valid if and only if \ntheory of complexity of algorithmic nets AL (g=h)a Vj(fjl=fj2) is valid. without cycles for simple computers, \n  Aplikace Matematiky 16 (1971) 188-202. Proof: Part (a) follows from the logical [DS] P. J. Downey \nand Ravi Sethi, Assignmentequivalence of AA B o (g=h) and Aa7Bv (g=h). commands and array structures, \nProc. 17th The other parts are similar. O Ann. Symp osium on Foundations of Computer Science, (October \n1976) 57-66. LEW A2: Let A be a conjunction of equali\u00ad [Go] D. I. Good, R. L. London and W. W. Bledsoqties. \n! (g.=hj) is valid if and only if at An interactive program verification syste% least o~e31f=1 A>(g. \n=hj) is valid, for l<j <n. IEEE Trans. Software Engineering SE-1 J on 3 (March 1975) 59-67. Proof: \nSsume hat =v~=l(gj hj)isvalidy [Hj J. E. Hopcroft, An nlogn algorithm for and suppose that all of A o \n(gj =hj) are invalid. minimizing states in a finite automaton, in Z. Kohavi and A. Paz (cd.) Theory of \nThen there exist over value domains %  % Machines and Computations, Academic Press, satisfies AA (gj \n#hj). New York, NY (1971) 189-196. 1  n Uch hat j Consider ~ over VI x . . . xVn, defined by [HK] \nJ. E. Hopcroft and R. M. Karp, An algorithm for testing equivalence of m(e) =Nl(e)x . . . x%(e) , where \ngj(e) is the value finite automata, TR-71-114, Dept. of of e under . . For this ~ , the formula Computer \nScience, Cornell Univ. (1971); % see description in Aho et. al. (1974) AA (glzhl)A . ..A(gn#hn) is satisfied. \nBut then 143-145. A>Vj(gj =hj) is not valid a contradiction. [Ki] J. C. King, Symbolic execution and \nprogram testing, C. ACM 19 (July 1976) 385-394. The other direction of the lemma is immediate. D [Kn] \nD. E. Knuth, The Art of Computer Program\u00adming: Volume 3, Sorting and Searching, The above lemmas show \nthat all the problems Addison Wesley, Reading, MA (1973). (a), (b), (c) reduce to deciding the validity \nof [KB] D. E. Knuth and P. B. Bendix, Simple word formulas of the form A>(g=h), where A is a problems \nin universal algebras. In conjunction of equalities. Thus a solution to the J. Leech, Ed., Computational \nProblems in uniform word problem solves all the problems. Abstract Algebra, Pergamon Press, (1970). Acknowledgement \nKol ] D. Kozen, Complexity of finitely pre\u00adsented algebras, Proc. 9th Ann. ACM Symp. We wish to thank \nAl Aho, John Bruno, on Theory of Computing, Boulder, Co. Don Johnson, Jeff Unman, Mike Garey and (May \n1977) 164-177. Dave Johnson for helpful discussions. K02] D. Kozen, Lower bounds for natural proof systems, \nProc. 18th Ann. Symp. on Found References ations of Computer Science, (Oct. 1977), 254-266. [A] W. Ackermann, \nSolvable Cases of the Decision Problem, North-Holland, [L] D. S. Lankford, Canonical algebraic Amsterdam \n(1954). simplification in computational logic, Department of Mathematics report, [AHu ] A. V. Aho, J. \nE. Hopcroft, J. D. Unman, Southwestern University, Georgetown, TX The Design and Analysis of Computer \n(1975) . Algorithms, Addison Wesley, Reading, Mass., (1974). [NO1] G. Nelson and D, Oppen, Fast decision \nalgorithms based on union and find, Proc. [AU] A. V. Aho and J. D. Unman, Optimization 18th Ann. Symp \n. on Foundations of Computerof straight line programs, SIAM J. Com Science, (Oct. 1977), 114-119. ~uting \n1, 1 (March 1972) 1-19. LN02] G. Nelson and D. oppen, A simplifier for [B] M. S. Breuer, Generation of \noptimal code program manipulation, this proceedings. for expressions via factorization, CACM ~, 6 (June \n1969) 333-340. [PW] M. S. Paterson and M. N. Wegman, Linear unification, Proc. 8th Ann. ACM Symp . on \nTheory of Computing, Hershey, PA (May 1976) 181-186. [Sal] H. Samet, A normal form for compiler test\u00ading \nProc. Symp. on Artificial Intelligence and Programming Languages, Rochester, NY (August 1977). [Sa2] \nH. Samet, Proving the correctness of heuristically optimized code, Communi cations of the ACM, to appear. \n [Sel] Ravi Sethi, Testing for the Church Rosser property, .TACM 21, 4 (October 1974) 671\u00ad679; errata \nJACM 22, 3(July 1975) 424. [Se2] Ravi Sethi, Scheduling graphs on two pro\u00adcessors, SIAM J. Computing \n5, 1 (March 1976) 73-82. [Sh] R. E. Shostak, An algorithm for reas$ning about equality, Proc. of the \nSw p. on AI and programming Languages, SIGPLAN Notices 12 (Aug. 1977), 155-162. [Tarjl] R. E. Tarjan, \nDepth first search and linear graph algorithms, SIAM J. Computing 1, 2 (June 1972) 146-160. [Tarj21 R. \nE. Tarjan, On the efficiency Of a good but not linear set merging algorithm, JACM 22, 2 (April 1975) \n215-225. [Tarj3] R. E. Tarjan, private communication. [Tars] A. Tarski, A. Mostowski and R. M. Robinso~ \nUndecidable theories, North Holland Publishing Co., Amsterdam (1953).\n\t\t\t", "proc_id": "512760", "abstract": "The classical common subexpression problem in program optimization is the detection of identical subexpressions. Suppose we have some extra information and are given pairs of expressions e<inf>i1</inf>=e<inf>i2</inf> which must have the same value, and expressions f<inf>j1</inf>&#8800;f<inf>j2</inf> which must have different values. We ask if as a result, h<inf>1</inf>=h<inf>2</inf>, or h<inf>1</inf>&#8800;h<inf>2</inf>. This has been called the uniform word problem for finitely presented algebras, and has application in theorem-proving and code optimization. We show that such questions can be answered in O(nlogn) time, where n is the number of nodes in a graph representation of all relevant expressions. A linear time algorithm for detecting common subexpressions is derived. Algorithms which process equalities, inequalities and deductions on-line are discussed.", "authors": [{"name": "Peter Downey", "author_profile_id": "81100228257", "affiliation": "The Pennsylvania State University, University Park, Pennsylvania", "person_id": "P348411", "email_address": "", "orcid_id": ""}, {"name": "Hanan Samet", "author_profile_id": "81100139629", "affiliation": "University of Maryland, College Park, Maryland", "person_id": "PP40024153", "email_address": "", "orcid_id": ""}, {"name": "Ravi Sethi", "author_profile_id": "81100354362", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP39039094", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512760.512777", "year": "1978", "article_id": "512777", "conference": "POPL", "title": "Off-line and on-line algorithms for deducing equalities", "url": "http://dl.acm.org/citation.cfm?id=512777"}