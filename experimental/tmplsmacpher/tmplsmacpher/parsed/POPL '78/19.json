{"article_publication_date": "01-01-1978", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1978 ACM 0-12345-678-9 $5.00 Conference Record of the Fifth Annual ACM Symposium on Principles of Programming \nLZUg.EKJeS COMPLEXITY OF EXPRESSIONS ALLOWING CONCURRENCY W. F. Ogdenl Case Western Reserve University \nW. E. Riddlez University of Colorado W. C. Rounds3 University of Michigan o SUMMARY We study some \nconsequences of the formal lan-currency. We give an example of this use by pro\u00adguage approach to modelling \nsoftware system behav-viding a language-theoretic semantics for simple ior for the case of asynchronous, \nconcurrent sub-structured parallel programs. We then study the systems. We use the formal language shuffle \nopera-recognition problem for languages defined by such tion to give an algebraic definition of seman-expressions. \nOur conclusion is, in brief, that tics for a simple (structured) concurrent program-shuffling is complex. \nming language and prove that the use of this opera-This paper has two main sections. The first tion is \nnecessary. Having established this neces-part, after preliminary definitions, illustrates sity, we investigate \nother types of behavioral ex-the use of shuffling in giving semantics for con\u00adpressions which use the \noperation and show that current programs. Many authors, of course, have the analysis problem for these \nexpressions is given such semantics: among them are Horning and either undecidable or intractable, The \nresults Randell [7], Owicki [10], and Lipton [8], for provide some limitations, for example, on thee \nexample. Our approach differs from these authors expression method of system behavior analysis. by using \nalgebraic expressions with explicit con-Our lower bound proofs involve the use of syn-currency. We separate \ncontrol from data in the chronization symbols, which seem to be a formal manner of program schemata, \nso that a program ex-Ianguage analogue of semaphores. pression defines a certain set of abstract execu\u00ad \ntion sequences. These sequences of operations are ~. INTRODUCTION then interpreted over a state space. \nThe (I-O) The parbegin -parend and fork-join control behavior of such a program is given by choosing \nan structures express concurrent program behavior. interpretation and picking off pairs of states They \nimplicitly contain the idea of interleaving associated with the beginnings and ends of all le\u00ador shu.fflinq \nstreams of operations from component gitimate execution sequences, thus obtaining a processes. This interleaving \nis also implicit in binary relation on the state space. In contrast, the path expression formalisms (Campbell \nand Pratt [12] views a program as being defined by Habermann [2]) and event expressions (Riddle [14]) \nsuch a relation. We show, that for expressing and, of course, the various Petri net schemes concurrency, \nthe execution sequence approach is (Peterson [11]). This paper is concerned with somehow necessary, \nbecause the I-O behavior of the algebraic expressions which explicitly use the resuIt of shuffling two \nprograms cannot be defined shuffle operation [4, p. 108] to express con\u00ad from the I-O behavior of the \ncomponents using the standard relational operators (Codd [3]). Our result uses a theorem of Banci.lhon \n[1] on rela\u00adtional definability which is itself a form of Beth s definability theorem [15, page 81]. \n. Department of Computer G Information Science, Case Western Reserve University, Cleveland, Ohio 44106 \n2 Department of Computer Science, University of Colorado, Boulder, .Colorado 80309 3 Department of Computer \nG Communication Sciences, University of Michigan, Ann Arbor, Michigan 48109 The second part of this \npaper deals with the complexity of the recognition problem for lan\u00adguages defined by expressions with \nconcurrency. Riddle [14] defines event expressions, which de\u00adnote behavior of programs written in a software \ndescription language. Similarly, Campbell and Habermann [2] use @ expressions as definitions of desired \nprogram behavior. Riddle s scheme is intended for off-line analysis of global system behavior, while \nthe path expressions are to be compiled into code which checks allowable activity during execution. In \nboth cases, however, it is natural to ask whether or not a string of symbols is in the set denoted by \nthe expression. We prove that event expressions in their full generality can denote any recursively enumerable \nset, and thus are not amenable to algorithmic analysis. We then show that extensions of path expressions \nto the context-free case (standard path expressions denote regular sets) will have to be defined with \nsome care, because there exist (deterministic) con\u00adtext-free languages whose shuffle is NP-complete. \nOur intractability results use the technique of Syn chronization symbols, introduced by Riddle in event \nexpressions. These symbols are a formal language analogue of semaphores. We use them to force concurrent \nsystems to simulate Turing ma\u00adchine behavior. The technique is reminiscent of one used by Lipton [9] \nto show an exponential space lower bound on the vector addition reachability problem and, for the NP \nresult, an extension of the methods used by Greibach [6] to exhibit NP-complete quasi-realtime languages. \nThere appear to be many different ways to use these symbols in such proofs. 2 SHUFFLING Let L1 and L2 \nbe subsets of Z . Then LlLL2={X1Y1...XnYn lXXn C.Xn C L1; yl...YL2}2} where the xi s or yi s can be null. \n(An early ref\u00ad erence to this operation is Ginsburg and Spanier [5].) It is easy to show that regular \nsets are closed under shuffle and that the shuffle of a regular set and a CFL is a CFL. The CFL S are \nnot closed under shuffle. (Theorem 3 shows how bad things can get.) We also consider the unary dagger \noperation on languages. Dagger is the Kleene closure of shuffle: L(n) Lt= ~ n>G whe??e L(n) =LfiA1...AL \n(ntimes). The regular sets are not closed under dagger. Structured parallel programs We give an application \nof shuffling to program\u00adming language semantics. We consider a language for which expressions with shuffling \nform a concise way of defining meanings. Figure O is an example. sem:=l; result:=null; parbegin writer: \nrepeat-indefinitely if sem=O then  if result # null then  begin buffer:=resul t; write (buffer) ; sem:=l \nend end writer; read G process: repeat-indefinitely if sem=l then  begin read(buffer) ; sem:=O; <code \nto compute result> end end read 6 process -Fig. O This code represents overlapped execution of printing \nwith processing, using a shared buffer, with a semaphore to enforce mutual exclusion of reading and writing. \nWe are not concerned with efficiency or even correctness here, however; only with giving a meaning to \nthe statements, The atomic operations in this program are the assignments, reads, and writes; the atomic \ntests are the conditions mentioned in the if-then statements. We assign to each atomic operation > a \nunique symbol from an alphabet z and each test a symbol from an alphabet B (these alphabets need / sem:=l \nnot be finite). The control structures (if-then, \\ sequencing, repeat, etc.) are then regarded as ; \noperators on sets of strings of symbols and so / give rise to program expressions. A program ex. res \n:=A pression thus denotes a certain language (set of strings of operation and test symbols). By inter\u00ad\\ \n preting each symbol, and hence string, as a real parbegin-parend operator or test, we then get the meaning \nof the program. This is of course the method of program /\\ rpt-indef rpt-indefschemata for a class of \nprograms involving con- I currency. I if-then if-then Formally, the class of program expressions over \nz and B is given by a recursive definition: / s em=O (i) each element of z is a program expression; \n / 1 (ii) if T1 and r2 are program expressions, if-then s em= 1 and b s B, then the following are ; \nprogram expressions: II / Tl; ~2 res#A read(buf) if bthen n 1 , ifb thenTelse7 \\ 1 2 I ; while bdo \nT 1 /\\ buff:=res 1 ~T2 /> repeat-indefinitely (Tl) sem: =0 ~arbegin r ~; 72 j?arend / \\ write(buf) sem:=l \nTo illustrate, let us give the tree structure of code our example program regarded as a program expres\u00adsion \n(Fig. 1), This tree emphasizes the role of control structures as operators (on the results of subtrees) \n. Fig. 1 . The first stage in computing the meaning of a program expression is to define its associated \nlanguage; the second is to interpret this lan\u00adguage over a data space. Thus the language of an expression \nT is defined, following the recursive definition of w. (i) ifrcEthenL(r) =n; Comments: (1) ~ is a single \nsymbol denoting the (ii) if L(T1), L(m2) are defined, ~d b s B, then  negation of the predicate b; \n(2) the use of b in the L(W1;T2) = L(T1).L(T2); definition of if-then reflects the desire to do the L(~bthenrl) \n=b L(r2)u{~); null operation when b is false; (3) we do not employ L(if b =Tl else n2) . . infinite sequences \nof operations -thus Ilrepeat. t$cL(ml) tio~*L(w2); indefinitely!! is not the same as ho-forevertr or \nL(while b~nl) = (b.L(nl))*.~; twhile true do!l. L(T; ~r2) = L(nl) UL(n2); For the second stage, we define \nthe input-output L(~eat-indefinitely(nl)) = L(T1)*; L(parb~in m1jn2parend = L(nl) A L(IT2). We are relations \ndenoted by a program expression. given a set D of states; for each operation s~bol o in~a relation R(o) \n~ D x D; and for each b c B a subset S(b) of D. Then for each x s (Z UB)* we define a relation I(x): \nI(o) = R(cr) for u s Z; I(b) = jdD ~s(b) forb E B; I(xy) = I(x) o I(y) otherwise where o is relational \ncomposition, and ~ is restriction of a relation to a set. Finally, I(m) U{ I(X)IXE L(T)). so that I(r) \nis a binary relation on D, the I-O relation of n. Pratt [12], among obhers, regards this rela\u00adtion as \nthe definition of a program. He can then build up compound programs using relational opera\u00adtors; for \nexample, relational composition for se\u00adquencing, and relexive transitive closure for in\u00ad definite iteration. \nIntuitively, however, there is no fixed combination of standard relational opera\u00adtors (union, composition, \nprojection, etc.) which corresponds to shuffling. Our task in the next section is to prove this. Undefinability \nof shuffle Let D be a set and Rl ,...,Rm given relations on D. The arity of these can be arbitrary. A \nrelation R is definable from R1,. ..Rm if it can be written as a relational expression over RI,. ..,Rm \nusing the following operations: union complement projection expansion permutation where the last three \noperators are defined as follows: Let RC Dn then Proji R(dl d. ,d ,.. .,dn) ~ 1-1 i+l 3( di; R(dl, \n. . ..di. dn),dn) Expi R(dl, . . . d .,. ..dn) ~ ~:~ R(dl, . . . d~-l,di+l,. ..,dn) Perma R(dl, . . \n..dn)~=..~R(d d u(l)  u(n)) where u is a permutation of {1, . . ..n~. Theorem ~. There exist two programs \nnl and r2 and an interpretation I such that I(IT1Am2) is not definable from I(nl), I(T2) and the identity \nrela\u00adtion. Proof. Let Z = a,b,c,d and,consider the pro\u00adgrams lT1 = a;b and n = c;d. The interpretation \nI is defined over D= {:,1]. We set I(a)= /(0,0), (1,0)} I(b)= {(1,1)} I(c)= {(0,1), (1,1)~ I(d)= {(0,1)~ \nClearly I(a;b) = I(c;d) = @. and it is easy to check that I(a;b c;d) is the constant function K= {(0,1), \n(1,1)}. Our problem is to show that K is not de\u00adfinable from fl and id, the identity relation on {0,1}. \nWeadopt anapproach from logic. Let ,...,Rm be given relations on D, and let 1 ~(Rl,. . . ,Rm) be the \nset of bisections of D leaving these relations invariant; i.e., f:D +D is in r iff for each Ri Ri(dl, \n..., dn )~Ri(f(dl) ~.. .~f(dn)). Bancilhon [1] shows that a relation R is definable from RI,.. .,Rm if \nand only if each f in I (R1, . . ..RJ leaves R invariant. (In fact, we need only the easy direction of \nhis result.] There are only two bisections of {0,1} and both leave @ and id invari\u00adant. But the function \nf interchanging O and 1 does not leave K invariant, and so K is not definable. This proves our theorem. \n3. LOWER BOUND RESULTS We turn to the analysis of expressions involv\u00ading shuffle. Theorem 2 shows that \nthe class of event expressions [14] denotes the full CISS of r.e. sets. Event expressions, introduced \nin [13] and there called message transfer expressions, were in\u00adtended as a behavioral characterization \nof the sys\u00adtem description language PPML. That language was able to define Petri-net types of behavior. \nTheorem 2, however, shows that event expressions are consid\u00aderably more general. Theorem 3 asserts the \nexistence of determin\u00adistic context-free languages L1 and L2 such that L1 A L2 is NP-complete. Thus, \nunless P=NP, there is no polynomial time algorithm for decoding possible shuffled strings from general \nCFL S. This means that one should be careful when extending path\u00adexpression definitions [2] to cases \nwhere component processes exhibit recursive or stack-like behaviors. Event expressions Event expressions \ndenote formal languages in the manner of regular expressions, except that an extra denotational process \nexcludes some strings from the language. The idea is to use special synchronization symbols to control \nconcurrent combinations. Execution sequences not having a specified pattern of synchronization symbols \nare excluded from the language. Let A and S be two finite disjoint alpha\u00adbets (terminal and synchronization \nalphabets respectively). We assume S = A ~where A is a finite set and ~ ={=la c A}, the set of in\u00adverses \nof symbols in A. Then the class , EXP(Z,S) of event expressions is given by: Z l_JS~EXP(Z,S); {~,a} ~ \nEXp(~,S); if el, e2 cEXP(Z,S), then e2, e~, el A e2, e;elu e2, el are all members of EXP(X,S). Language \ndefinition from an EE is a two-phase process; the first is similar to that for regular expressions; the \nsecond is the intersection pro\u00adcess mentioned above. l%us we define an intermedi ate language LO: LO(U) \n=~u~foruc ZU SU{A}; LO(0) = 9 LO(elu e2) = LO(el) U LO(e2); LO (el e2) = LO(el) LO(e2); LO(el*) = LO(el)*; \nLO(el A e2) = LO(el) A LO(e2); LO(elt) = LO(el)*. For the second phase, define the cancellation gramarll \nG with productions la=+A,~a-+XlacA\\ Then L(e) ={w c Z* I ( y c LO(e))(y =+ *W) G1 Let Z ={a,b}, A= {a,(l~. \nThen the lan\u00ad &#38;i!!@?\u00adguage anbn is L(e) where e is the expression ((aa)* (bB)*) A (~~)t In this example, \nthe dagger operation intro\u00adduces ~ and G symbols in equal numbers; the lan\u00ad guage ;n~n is a subset of \n \u00ad .(aL3) Shuffling (a~)+ into (aa)* (b6)* and canceling in effect e~iminates all strings except those \nof the form anbn. Similarly, the language ambn$bnam is generated by the expression ((aix)*(bf3) *#(by \n)*(a6)*)A (~~)+ A (~~)+. Notice that the B and y symbols control the match\u00ading of b s, while the a and \n6 symbols control the matching of a s. h easy fact about cancellation is given by Lemma 1. Let Ui e Z \nand Wi c S*. If the string cancels (to u u .Un) then each Wi l lwlu2  onwn+l 1 2 cancels to 1. Proof. \nObserve that the cancellation grammar cannot re\u00admove symbols in Z; thus cancellation sequences must be \nindependently applied to each Wi. Theorem 2. For any r.e. subset L of X*, we can find an . event expression \ne such that L=L(e). Proof. We show that an EE can be constructed in such a way that the cancellation \nactivity simulates the computa\u00adtion of a two-counter automaton. We equip the automaton with output instructions \nand let the terminal symbols of the EE correspond to the output symbols of the 2CM; the only trace of \nthe computation is then the successive out\u00adput symbols of the machine. Minsky s theorem states that for \nany r.e. set L, there is a 2 CM M such that the out\u00adput language of M is just L; this gives us the result. \nThe main difficulty with the proof is ensuring that every cancellation sequence which occurs represents \na computation of the machine. This is one of the reasons for Lemma 1: output symbols do not cancel, so \nthe can\u00adcellations can be localized to the Wi. By itself, however, Lemma 1 will not suffice because each \nWi will be composed of a string over S* essentially of the form yl,... ,y P where each yj is an instantaneous \nconfiguration of the 2CM followed by the inverse of the next configuration. Cancellation of these y s \nis supposed to represent compu\u00adtation of the 2CM between output steps, In order to con\u00adtrol cancellation \nwithin each string yl . . ..yp we intro\u00adduce auxiliary cancellation symbols [ and ] , insert\u00ading them \ninto the expression in such a way that if each [ cancels a ], then the whole string yl . . . . . yp will \ncol\u00adlapse to A and correctly represent a computation in doing so , The two counters of our machine contain \na string of als and a string of bts respectively; thus a configura\u00ad tion has the form amq, bn -1 where \nqi is a state of the machine. We make up an expres\u00ad sion for each qi so that (if the a,b,q symbols are \nre\u00ad garded as terminal for the moment) the associated language would be where m and n are the new contents \nof the a and b coun\u00ad ters of the machine, and q.is the correct new state. J 189 This expression can easily \nbe constructed using the idea in the example preceding Lemma 1. We then union together expressions for \neach qi and star the result, thus obtaining our expression for the whole language. We now give the construction \nprocess in some detail. First we describe two-counter machines, then give the associated EE s, and finally \nshow language equality. Two-counter machines The 2CM is a finite set M of instructions having one of \nthe following forms: qi: if counter-A counter-B _-Ogo to qj else go to qk qi : write (6); go to q.J qi \n: counter-A+count counter-&#38;counter-B er-A *1; go to qj qi: HALT One instruction, say qo, is designated \nas the start instruction; the machine may start with counter-A = p, counter-B = r for any natural numbers \np and r, A configuration of a 2CM is just a triple (k,L,qi) where k and !.L are natural numbers and qi \nis a state (output is ignored here). In the usual way we define a computation sequence of m to be a sequence \nof configurations each correctly follow\u00ading from its predecessor according to machine in\u00adstructions, \nstarting with (p,r,qo) for some p and r, and ending with some (k,t,q) where q is a HALT instruction. \nThe output string W(Z) is the string of symbols obtained by concatenating left to right all oztput symbols \nproduced during the sequence, and then L(M)={w(~) Igis a computation sequence of M. \\ For technical reasons, \nwe will modify M s finite control as follows: the state set is partitioned into two disjoint subsets \nQ(odd) and Q(even); and transitions always go from odd to even or from even to odd states. MY 2CM can \nbe modified this way without changing the language generated. Construction of an EE from a 2CM . . We \nlet z be the output alphabet of M; then z is also the terminal alphabet of e(M). We now give the auxiliary \nalphabet S. The positive part A of S has several components: G(even) = {ae,f3e,Ye,0e} G(odd) = {ae,13e,Ye,ue \n} T={a,b} Q. j q, ,...,c$} (the state set of M) P= Then we have A= G(even) UG(odd) wTUQuP and S = AU \n~ where ~ consists of all inverses of symbols in A. We write the inverse of [ as ] . Corresponding to \neach state of M we give an EE . Our understanding is that any Greek letter auxiliary symbols in the EE \nare taken from G(even) or G(odd) depending on whether the state is in Q(even) or Q(odd). We will thus \ndrop subscripts on Greek auxiliaries, Case 1. qi : cA+cA+l; gotoq. J e i: (~o)*. ~i(~f3) *.[. (by)* \n.qj. a.(a6)* A (6y)tA (a&#38;)+ To understand this expression, momentarily regard all symbols except \nthe Greek letters as terminal symbols . The dagger introduces ~ and ~ in equal numbers, and ~ and ~ in \nequal numbers. These barred symbols migrate to the left and cancel their in\u00adverses, thus imposing a correspondence \nbetween a s and ~ts, and between b s and ~ts. After canceling Greek symbols we are left with strings \nof the form ~m~i~n. [. bnqj am+l which represent successive configurations of the 2CM Now similarly we \nhave an expression for each state of the 2CM. Case 2. qi:CA+CA-1; goto qj e i: (=a)*~~i (~6)*. [.(by)*qj \n(ad)* A (~~)+A(&#38;~)+ Case 3. qi : WRITE(u); go to qj ei: (=a)*~i(~@)**] *.u. (by)*qj (ad)* A (E~)+A(;6)t \nCase 4. qi: if C =Ago to qj else qk A ei: ((qi(bf3) * [0(by)*qj) A (~;) u (=a)*=qi(~!3)*. [.(by)*qk(a6*) \n*a) A (E~)+A(@+ Similar expressions are constructed for the instruc\u00adtions involving counter-B. Define \nSTART = b qoa HALT = =*qhb* . ]* , where h is the HALT state. For the program M define e(M) = START o \n(Ue~* HALT 1 i+h We would like to show L(e(M) = L(M), The diffi\u00ad cult part of this result is showing \nthat L(e(M))~ L(M). In the expression e(M) there are many ways to shuffle strings and therefore many \npossibilities for cancellation. We must show that every cancellation to terminals corresponds to a correct \ncomputation of the machine. The brackets control the order of cancellations, as do the re\u00adstrictions \non M and the fact that no cancellations can cross terminal symbols. The function of the brackets is given \npre\u00adcisely by the next lemma. Lemma 2. Given a string of the form . . [. ZP]P+T w = UZ1. [.Z2. [Z3..., \nwhere o and T are in Z, Zi s (Au ~)* all bracket\u00adfree; if w cancels (to IJT) then each Zi cancels to \ni. The proof is by induction on p, and is omitted. Assertion. L(e(M)) = L(M). We will show only that \nL(e(M)) cL(M), as explained above. Consider a string in Lo(e(r) which cancels to terminals. From the \nform of e(M) this string will have an internal structure . . . Xx. ..x... 01 P where X. and x are strings \nintroduced by expres-P sions e and e representing two consecutive oP !Iwrite!! statements, and x >. . \n. >x come from ex\u00ad 1 p-1 pressions representing non-writing statements. l%us X. has the form Xok]juxor; \neach xi has the form xii. [.xir and x has the form P ]k. T.Xpr Xpl where u,T E E, and E (~a)*~(@)* A \n~,~ * ik x.c (by)*Q(a6)* A ~,~ * . lr We can write the string [*x1 rx21... X ]kT Xo 1! x(p-l)rpL in the \nform UZ1[Z2. . . [Zp]kT . By Lemma 1, this string must cancel to UT and so by Lemma 2 each Zi must cancel. \nBut, Zi = x. x lr (i+l)$ which thus must cancel for each i, and so computa\u00adtions can be simulated for \nmore than one step. As an example, suppose that xi is generated by an expression representing instruction \nCA+ CA +1; go to q. qi : 3 and x. is generated by an expression representing 1+1 CA+- CA-l; go to q! \n. qk : Then (ignoring the ;,~,~,~ symbols) t x. = (;a)m~i(~c)n [(by) s qj-(ad 1 x.,+1= (&#38;&#38; :k(b13)n \n:[.(b )s . qL(a )t>. The string z.1 = (b) qj (aa) o(iia.)m-Qk t (G6)n .. s.n J Also, there must be exactly \ns ~ symbols in Zi t 6 symbols, s &#38; symbols, and t ~ symbols. ~ and ~ symbols in Zi must have been \ninserted in the ex\u00adpression for qi, and any ~ and F symbols in Zi by the expression for q. since qi and \nqj have differ\u00ad-J ent tparityff. The a and F bymbols introduced for qi must thus cancel the a and @ symbols \nin the left part of xi and the ~ and ~ symbols introduced for qj must cancel they and &#38; symbols in \nthe right half of x. Thusm+l=t, n=s ,m =t +l, must cancel. Hence q. = qk, , and t = m . 1+1 n = s , and \nthe computation is advanced two steps. By induction, the strings xl,. ..,x thus represent P a correct \ncomputation of the machine between two output steps, and again inductively, the whole string represents \na correct computation of the machine. The example just above represents a typi\u00adcal inductive step of \nthe proof. Theorem 2 follows because the trace left upon making all cancellations is just the sequence \nof output symbols produced by the machine. We remark that without the daggering opera\u00adtion, Theorem 2 \ndoes not hold; only regular sets can be generated [14]. The dagger thus introduces all the Counting!! \nability into our expressions. The complexity of pure shuffle Our final theorem shows that even when \nre\u00adstricted to the class of context-free languages, shuffling is a complex operation. We find deter\u00administic \nCFL S L1 and L2 such that L A L2 is 1 NP-complete. This means that a general efficient algorithm which \nrecognizes scrambled message sequences from parallel sources with context-free behavior will probably \nnot exist (unless P = NP). It is possible, however, to design such an algo\u00adrithm in case the message \nsources give finite\u00adstate behavior. Thus an interleaved sequence of messages coming from sources whose \nbehavior satis\u00adfies a regular path expression will be recognizable efficiently, because regular sets \nare closed under shuffling. The intended use of path expressions does not even raise this issue; each \nprocess simply checks whether the subsequence of the shuffled mess\u00adage stream consisting only of the \nletters mentioned in its path expression in fact is in.the language denoted by the expression. Our result \nimplies only that in extending path-expression analysis to sys\u00adtems with non-regular behavior, some care \nshould be taken with semantics of the expressions. A language L~ Z* is in NP iff there is a non\u00addeterministic \nTM accepting L within p(n) time, where p is a polynomial. L is NP-complete iff L E NP and for each L \nE NP, L ~L; i.e. there is a polyno\u00admial-time computable function8: Z* + 2* such that for all x, x c L \niff~(x) s L. Theorem 3. There exist deterministic context-free languages L1 and L2 such that L1 A L2 \nis NP-complete. Proof. We show that for all L c NP, Ihere exist L1 and L2 (depending on L) such that \nLqL1 A L2. By choosing L to be a known NP-complete language, we get a specific L1 AL2 which is NP-complete. \n(Note: trivially L1 A L2 E NP.) Our proof is another Turing machine simulation argument. Let L E NP and \nlet M be a Turing machine accepting L within p(n) time. We may assume that M has a single tape and that \nthe input head of M has a predictable head motion (consisting of, for example, successive sweeps across \nthe entire tape), A configuration of M is a string in E*QI* where Q s the state set and z is the tape \nalphabet of M, (we will take Z = tO,l} for convenience.) In the usual way, if x and x are configurations \nof M, we write x+ x to indicate that x follows from x by means of Mts program. Define the following languages: \nK1 {X$(X )R$ I X+X } where (z) R is the reversal of z, and $ is a new symbol . L1 = gl(K1*) where gl \nis a string homomorphism that replaces each O by [0 and each 1 by [1, leaving any other symbols unchanged. \nK2 { I$ZI$ZR I Z E (zuQ)*} L2 = g2(K2*) where g2 is a string homomorphism replacing O by O] and 1 by \n1]. Ll and L2 are deterministic CFL S; we claim that L1 A L2 is the required language. To show that this \nis the case, we introduce some temporary notation. Let Q = {qo, ,,.,~}be the state set of M. For a string \nxi E X*QE*, de\u00adfine the.complement C(xi) to be the homorphic image of xi given by c(o) = 1; c(1) = o; \nC(qi) = qoql. ..qlqi+l+~. ..~. Let w = x1$(x#$x2$(x;)R$. ..XRXR ~R$ be a string in Kl, and let RR R \nv = zl$zl*z24z2 $zk$zk be a string in K2. We say that v is the shifted complement of w just in case \nRR = C(x;)p , zl = c(x2), . . ..zk = C(x{) . 1 Notice that if w s K1 has a shifted complement in K2 \nthen w represents a complete computational history of m starting from the configuration xl, because X2 \n= xi, X3 = xi, etc. Our idea is to shuffle together gl(w) with g2(v) to produce a very uniform-looking \nstring and to use this form as the definition of the reducing function @which shows that L~L1 A L2. The \nbrackets and markers are used to show that if $(x) c LIA L2, then the only way to unshuffle @(x) will \nbe to have $:(x)E gl(w) A g2(v) where w and v are shifted complements, and w represents an accepting \ncomputation of x. It is useful to regard all configurations as having the same length, so if x e x*, \n1x1 =n, let I(x) be x followed by p(n) -n zeros. All computa\u00adtions last for p(n) steps, and an accepting \ncon\u00adfiguration consists of tape entirely zero and head at the end of the tape, in state q Let h(t) be \nf the position of the head at step t of the computa\u00adtion, By our assumption h can be calculated very \neasily. Set 2p(n) p(n) ~ (x) = gl(qo I(x)) ot~l y(t) $+g2(l qf where y(t) = $+[Ol]h(t) .Q(t). [Ol]p(n)-h(t) \n. ..~t even Q(t) = {qo ~... qo t odd. Thus @is an encoding of the initial configu\u00adration, followed by \na large number of strings of the form $$[oll[oll . ..[ol]q~[ ol][ol][[ol].. [ol] all of which have the \nsame length, and then the final string which is the complement of the final configuration. Observe that \nif $ is a shuffle of strings from L1 and L2, then each portion of @ between any $4...$4 markers must \nconsist of a contribution from L1 shuffled with a complementary contribution from because left brackets \noccur in L ~ (right 2 brackets occur in L2) before (after) each O or 1. The position of the $ and + markers \nin + guarantee that the first L2 configuration matches the second L1 and so forth. We thus have the fact \nthat @ (x) s ql(w) A g2(v), and v is the shifted complement of w. But by our remarks above, and the \nfact that w starts with an initial configuration and ends with a final one, this means that w represents \nan accepting computation on x. Hence x E L+==++(x) c L1 A L2, proving theorem 3. 4 CONCLUSION The \nresults above represent a small venture into possible methods for expressing concurrent be\u00adhavior. By \nappropriately restricting allowable synchronization patterns, it seems that many types of synchronized \nconcurrent behavior are definable, Various forms of Petri-net languages can be des\u00adcribed by introducing \nsymbols representing the opera. tions of adding 1 and subtracting 1 from a given place, and insisting \nthat in any string the number of add 1 symbols up to any point exceeds the number of subtract 1 symbols. \nWe have not dealt with the class of expressions formed by adding shuffle and dagger to ordinary regular \nexpressions. Adding just shuffle does not increase denotational power, although the generalized membership \nproblem: given e and X, is x E L(e)?!! becomes NP-hard. (This can be proved by a reduction from the \nexact cover problem.) Finally, we have no results on the possible complexity of the languages formed \nfrom regular languages by closing under the dagger operation, REFERENCES [1] Bancilhon, F., !!Data Structures: \nSpecifica\u00adtion and Realization , Ph.D. Thesis, Univer\u00adsity of Michigan, 1976. 2] Campbell, R. A,, and \nHabermann, N., The Specifications of Process Synchronization by Path Expressions , Lecture Notes in Computer \nScience Vol. 16, Springer-Verlag, 1974. 3] Codd, E. F., A Relational Model for Large Shared Data Banks \n, CACM 13, #6 pp. 377-387, 1970. 14] Ginsburg, S., ~ Mathematical Theory of Context-Free Languages, \nMcGraw Hill, N= York, 1966. [5] Ginsburg, S., and Spanier, E. H., Mappings of Languages by Two-Tape Devicestr, \nm, 12 pp. 423-434, 1965. I!The Hardest Context-Free [6] Greibach, S., Language , SIAM J. Compt. 2, pp \n304-310, 1973. [7] Horning, J. J., and Randell, B., Process Structuring , Computing Surveys, 5 #l pp. \n5-30, 1975. [8] Lipton, R. J., Reduction: A Method of Proving Properties of Parallel Prozramstt, CACM, \ni8, $i2 pp. 717-721, 1975. \u00ad [9] Lipton, R. J., The Reachability Problem Requires Exponential Space , \nTech. Report, Department of Comvuter Science. Yale Univer\u00ad . sity, 197.5, to appear in Theoretical Computer \nScience. IIA Consistent &#38; Complete Deduc\u00ad [10] Owicki, S. tive System for the Verification of Parallel \nPrograms , Proceedings of 8th Annual ACM Symp osium on Theory of ~m~ing, May, 1976), pp. 73-86,  [11] \nPeterson, J., Petri Nets , Computing Surveys 9, #3, pp 223-252, 1977. I!Semantical Consideration on \n[12] Pratt, V. R., Floyd-Hoare LogicTT, Proceedings of the 17th ~ on Foundations of Comp~e~c~e, (;ctober, \n1=6), pp. 109-lfi. l!Model ling and .baly.sis of [13] Riddle, W. E., Supervisory Stanford Systems , \nUniversity, Ph.D. 1972. Thesis, [14] Riddle, W. E., I?Software System Modelling and Analysis , RSSM/25, \nTech. Report, Department of Computer and Communication Sciences, University of Michigan, July 1976. [15] \nShoenfield, Addison-Wesley, J. R., Mathematical Reading, Mass,, Logic, 1967.  \n\t\t\t", "proc_id": "512760", "abstract": "We study some consequences of the formal language approach to modelling software system behavior for the case of asynchronous, concurrent subsystems. We use the formal language shuffle operation to give an \"algebraic\" definition of semantics for a simple (structured) concurrent programming language and prove that the use of this operation is necessary. Having established this necessity, we investigate other types of behavioral expressions which use the operation and show that the analysis problem for these expressions is either undecidable or intractable. The results provide some limitations, for example, on the path expression method of system behavior analysis. Our lower bound proofs involve the use of synchronization symbols, which seem to be a formal language analogue of semaphores.", "authors": [{"name": "W. F. Ogden", "author_profile_id": "81547266156", "affiliation": "Case Western Reserve University, Cleveland, Ohio", "person_id": "PP39045948", "email_address": "", "orcid_id": ""}, {"name": "W. E. Riddle", "author_profile_id": "81100207937", "affiliation": "University of Colorado, Boulder, Colorado", "person_id": "PP39032530", "email_address": "", "orcid_id": ""}, {"name": "W. C. Round", "author_profile_id": "81100590362", "affiliation": "University of Michigan, Ann Arbor, Michigan", "person_id": "P348413", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512760.512780", "year": "1978", "article_id": "512780", "conference": "POPL", "title": "Complexity of expressions allowing concurrency", "url": "http://dl.acm.org/citation.cfm?id=512780"}