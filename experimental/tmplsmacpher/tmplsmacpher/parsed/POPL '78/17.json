{"article_publication_date": "01-01-1978", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1978 ACM 0-12345-678-9 $5.00 COIIfe?X?IICt3 Record of the Fifth Annual ACM Symposium on Principles of \nProgramming Languages VERIFICATION AND DESIGN ASPECTS OF TRUE CONCURRENCY David Mizell Computer Science \nDepartment University of Southern California Los Angeles, California 90007 1. Introduction Most abstract \nmodels ofa set of parallel pro\u00adcesses define a computation of the model to be a sequence. It is either \na sequence of actions taken by the system [Lip] or a sequence of states of the system existing between \nactions [Kel, Lau, Ash]. Parallelsim is represented only by the fact that following a given action or \nstate, the next action or state is not necessarily unique. That is, par\u00adallesim is represented by nondeterminism. \nA. W. Holt has called this representation approach ser\u00adializable concurrency as opposed to true concur\u00adrency \n[Hoi]. He, among others, has questioned the appropriateness of implying a tota L ordering between events \nthat are onLy known to be partially ordered. In this paper, a definition of an algebraic model of a set \nof concurrently-executing sequential pro\u00adcesses is presented. The computations of this model are directed \nacyclic graphs. The nodes of each computation graph represent computer opera\u00adtions and the edges represent \nthe partial ordering of operations with respect to time. Examples demonstrate that these directed acyc\u00adlic \ngraphs aid in focusing a programmer/verifier s attention on the most important features of a com\u00adputation. \nThe model suggests the following verifi\u00adcation paradigm: since systems often execute a certain sequence \nof actions to achieve a certain goal, verification procedures should identify these sequences, whether \nor not each is performed with\u00adin a single process. A key notion in the abstract model is the treat\u00adment \nof synchronization mechanisms as fulL-fledged processes. A programming language syntax called path programe \nwhich is suggested by this notion is presented. Path programs are a generalization of the path expressions \nof Campbell and Habermann [CamHab]. The programming notation is based on the assumption that a processor \ncan be dedicated to each shared data structure in the system. The duty of this processor is to control \nthe synchronization of operations on the data structure. 2* The Mathematical Model Definition 1: A muLtimachine \nschema (abbreviated mms) is a triple M(V, A, P). Here V= [vl, . . . . v f] is a finite alphabet of variable \nletters (or variab e names, or informally, just variables). -4 = [al,..., an ) is a finite alphabet of \naction or operation let\u00adters. Each operation in A=e of three types: active, passive, or unsynchronized. \nThe subset of active and passive operations is further parti \u00adtioned into subsets called ~ynchronization \nclasses. Each class contains one or more passive opera\u00adtions and one or more active operations. Each \nactive operation in a synchronization cLass is said to correspond to each of the passive operations in \nthe cLass, and vice versa. Every non-passive a in A has two subsets of V associated with it. Their names \nare ref~ and mod~. refa is called the set of variables referenced by a and mods is called the set of \nvariables modified by a. inva = refa I..l mods is called the set of variables invo Lved in a. Those operations \nfor which mods = ~ are called decisions. All decisions are unsynchronized. Operations for which mods \n# @ are called assignments. Every as\u00adsignment operation has a function letter fa associ\u00adated with it. \nP= fpl, . . ..pn] is a finite set of ~ cesses. Each is a quadruple for 1 s i s n, Et c A is the set of \nactions that E1 cannot contain both active and Pi= (E~*S~, rl, L~). pl can executee passive operations \nfrom the same synchronization class. If Ei contains one passive operation from a synchronization class, \nthen it must contain all the passive operations in the class. For 1 s i,j 5 n, i # j impliee Et n Ej \n= d. Si E El is a designated starting action for pi. ri C El XEi is a prece\u00addence relation on the actions \nof p,, i. e. , it is p~s flowchart. Lg= ~ inv, is the set of variables agE1 pi can access. Formation \nrules for the relations r, are as follows: (1) An assignment action can be related to: (1. 1) a single \nactive or unsynchronized op\u00aderation, or (1. 2) a set of passive operations. It cannot be related to both. \n (2) A decision action has two sets of operations it can be related to. These sets are called the true \nbranch and the false branch, respectively. Each can be: (2. 1) a single active or unsynchronized op\u00aderation, \nor (2. 2) a set of passive operations. Neither branch can be a combination of both active and passive \noperations. We folLow the definitionof the mms model itself in a stepwise manner. First, a disconnected \ncom\u00adputation is defined to be, essentially a set of se\u00adquences. Each of these sequencee is generated \nby one of the processes in 1? as if it were alone in the world. Next, a pairing is de~lned to be an \n order-preserving bijection that pairs the active instance of b. Then the computation formed from and \npassive operations of a disconnected computa\u00ad the above disconnected computation and choice of tion. \nFinally a computation is constructed from a p is the following graph: disconnected computation and a \npairing by consid\u00ad ering each pair to be a single action. Definition 2: Given an mms M = (V, A, P) a \ndis\u00adconnected computation for M is a directed a-c graph that has the form of a collection of chains, \nthat is, linked sequences of nodes. Associated with each node of the graph is its name, which is an element \nof A. A node which has name a E A is called an instance of a. For each process pt in P, there is at most \none chain of instances from Ei in the disconnected computation. A chain associated with process p! must \nbegin with a node labeled s~, where s{ is p~s designated start action. There can be a branch from a node \nlabeled aj to a node labeled a~ only if (aj, ak) 6 ri. Definition 3: Given an mms M = (V, A, P) and a \ndisconnected computation Cd, a &#38;ng p is a to\u00adtal bijection from the instances of active opera\u00ad tions \nin Cd to the instances of passive operations in Cd. p must satisfy two properties: (1) for every node \nb which is an instance of an active operation a, p(b) must be an instance of the passive operation that \ncorresponds to a. (2) p must be order-preserving in the following sense: if there is a path of directed \narcs from node bl to bz, then there cannot be a path of direc\u00adted arcs from p(bB) to p(bl).  Definition \n4: Given an mms M = (V, A, p), a dis\u00adconnected computation Cd and a pairing p for Cd, a computation C \nis a directed acyclic graph formed from Cd by removing every instance of passive operations. For every \nnode b which is re\u00admoved, the arc leading into b is redirected into p-l(b) and the arc leading out of \nb is changed to lead out of p-l(b). If Cd contains no active or pas\u00adsive instances then Cd itself is \na computation. The folLowing flowcharts represent a simple multimachine schema containing three processes. \nUnsynchronized operations are represented by single-line boxes, active operating by double-line boxes, \nand passive operations by broken-line boxes. pl: P2: P3: A possible disconnected computation of this \nmms is represented by the following graph: a c bl b2 xX Suppose b is a passive operation which corresponds \nto bl and b2. Let p be the bijection which associ\u00adates the node marked bl with the upper node marked \nb and associates the node marked b2 with the lower ac bl b2 u The instances of a and c in the above computation \nare unrelated with respect to the ordering imposed by the graphis edges. According to the terminol\u00adthis \nmakes them concur\u00ad ogy of the mms rnode~, rent With one another. That is, practically speak\u00ad- mg, any \ntemporal relationship between them is un\u00ad known and furthermore irrelevant (given that they involve no \ncommon variables). Arbiters and other synchronization mechanisms are represented in a multimachine schema \nas pro\u00adcesses which execute passive operations. Such a representation is advantageous when the life his\u00adtory \nof a shared variable is an important part of a computation. An example of such a computation is provided \nby the x gets 2 program [Kel, Owi]. This pro\u00adgram s defined by the fo lowing code: cobegin x := X+l / \nx := X+l coend Some unspecified arbitration on the incrementa \u00adtions of tie shared var iable x is assumed. \nThe verification task is to show that if x = O at the start of the program, then x = 2 when the program \nter\u00adminates. Owicki found it necessary to introduce additional variables into the program before per\u00adforming \nthe verification. These auxiliary vari\u00adables were essentially abstract representations of program counters, \nas were Keller s quite similar place variables. The multimachine schema version of this pro\u00adgram is graphically \nrepresented as follows, where active operations are shown as doub Le-line boxes and passive operations \nas broken-line boxes. -l-J I Process pa represents the synchronization mech\u00ad anism which keeps the \nincrementations of x from overlapping in time. Because this a~bite~ is ex\u00adplicitly represented in the \nform of a sequential program, it can play a part in the verification. If x = O and p~s loop is executed \ntwice, x = 2. This partial correctness result is obtainable with\u00adout resorting to additional variab~es. \nMultimachine schemas are also useful for rep\u00adresenting sets of processes which are exchanging messages. \nA simple example is the following pair of processes which communicate via a buffer. The producer process \nreads a value from the input stream and places the value in the buffer. The consumer process removes \nthe value from the buffer and appends it to the output stream. cedures which take into account these \nacross\u00ad - er: consumer: process sequences are ward than those which more deal direct directly and only \nless with awk\u00adin\u00ad dividual processes. x := input EZl output := y m B a Suppose the buffer being used \nhas room fora single value. Then, whatever synchronization mechanism is actually employed, its intent \nwiU be to insure that placements into the buffer and removals from the buffer strictly alternate. Therefore \nthe syn. chronization mechanism can be represented by the following process: buff e r: r The computations \nof the mms consisting of the above three processes will be of the foLLowing form: x := input Q buf :=X \nh Such computations explicitly trace the life his \u00adtory of each of the values as it is read in, placed \nin the buffer, removed from the buffer, and writ\u00adten out. In both the above examples, a key feature of \nthe computations appeared as a totalLy-ordered sub\u00adgraph. A sequence of operations was executed in order \nto accomplish a certain goal or subgoal. In neither example was each operation in the sequence executed \nin the same process. Verification pro- Verification techniques based on the mu Ltima \u00adchine schema model \nare proposed in the authorls dissertation [MIz]. Space limitations preclude their discussion here. Besides, \nobservance of these across-process sequences is not dependent on any particular verification technique. \nMany verification methods are capable of taking into ac\u00adcount the fact that not only can the life history \nof a process be of primary interest, but also the life history of a variable or a value. 3. Path Programs \nIn a multimachine schema representation of a computer system, the arbiter of operations on a shared variable \nis considered to be one of the pro\u00adcesses in the system. This notion can be trans\u00adlated into a design \napproach. In this approach the designer assumes that every shared data structure in the system has a \nprocessor permanently assigned to it. This is similar to the assumption, commonly made in concurrent \nprogramming, that every process has a processor dedicated to it. As processing units grow smaller and \ncheaper, and as multiprocessor networks continue to prolifer\u00adate, both of these assumptions become more \nreal\u00adistic. The programming notion presented here amounts to a modi~lcation of the monitor concept of \nBrinch Hansen and Hoare [BH, H~A monitor declara\u00adtion typicatly contains a small program segment which \nis to be executed as an initialization step at creation time. The modification proposed here is to replace \nthat program segment with a program which executes throughout the life of the monitor. This program, \ncalled a path program, is respon\u00ad sible not only for the initialization of the monitor variables, but \nalso for the synchronization of op\u00ad erations on the monitor s shared variables. The concept is a direct \ngeneralization of the ath ex\u00adpress ion idea of Campbell and Habermann %ab]. They propose that a data \ntype include in its defin\u00adition a path expression, that is, a regular expres\u00adsion formed from the names \nof the operations. This regular expression specifies the order in which the operations could occur. A \npath program also specifies the ordering of operations. In ad\u00addition, it can make decisions based on \nthe values of the monitor variables. Furthermore, it can compute new values and assign them to monitor \nvariables. Monitors as originally developed used sema\u00adphores or conditional critical regions for synchro\u00adnization, \nwith the appropriate synchronization p primitives occurring within the monitor operations. Data types \nwith path expressions relegate all syn\u00adchronization responsibility to a finite-state con\u00adtroller. This \ncontroller is defined by the path ex\u00adpression. Monitors with path programs give this controller full \nTuring machine power. Monitors with path programs involve the fol\u00adlowing programming language constructs: \n(1) monitor . . . endmonitor bracket each mon\u00aditor declaration. (2) ~ (short for operation) prefaces \neach of the definitions of the monitor procedures. S2A?2Q 1! bracket the definition Of (3) E2Q the path \nprogram. (4) allow opname, where opname is the name of one of the monitor operations, can occur within \nthe path program. Semantically, it signi\u00adfies that the monitor s processor will permit some outside process \nto execute the operation named opname, and wait until this operation has been completed before executing \nthe statement following the allow statement. (5) The allowchoice construct syntactically resembles a \nPascal case statement. It appears in a path program at a point where any one of a set of monitor operations \ncan be allowed:  allowchoice opnamel; statement or ~namea; etatementa or  . . or ~namen; statement \n endchoice Semantically, the construct signifies that the path program should halt until an external \nprocess per\u00adforme an exec statement on an operation from the set {op~el, opnamea, . . . . opnamen]. Sup\u00adpose \nopnamet is requested. The monitor s con\u00adtroller process should permit the execution of this operation. \nNext, the controller process should ex\u00adecute statement (which might be compound). Next, control should \npass to the statement following endchoice. (6) exec opname occurs in the code of a pro\u00adcess external \nto the monitor. Semantically the exec parallels the allow construct of the path program: the process \nstops when this statement is reached and waits until the path program reach\u00ades a statement (either an \nallow or an allowchoice) which enables the executio~operation iopnameif The external process is then \npermitted by the monitor to execute the operation. If more than one process is waiting to execute the \noperation, then one of them is aLlowed by the path program to pro\u00adceed, while the rest must continue \nto wait. Some fair queueing policy must be included in the im\u00adplementation of the exec/allow constructs. \n. The x gets 2 program serves ae a simple example of the use of the notation. PI: begin exec increment \nend P2: begin exec increment end xarbiter: monitor var x: integer; ~lncrement; =x+ ~ end L!22P allow \nincrement; EE!SZL endpath endmonitor Observe how the path program contains both the initialization and \nsynchronization mechanisms for the shared variable. The next example is based on the bounded buf\u00adfer \nmonitor presented by Hoare [Hoa]. His moni\u00adtor is here rewritten as a monitor with a path pro\u00adgram. @ \nand @ are addition and subtraction mod-U1O n, respectively. llmesgll denotes the message data type, not \nspecified here. bounded buffer: monitor (n:integer) var buf:array [-of mesg; count:O. . n; lastpointer: \n00. n-1; ~ get (~ parm:mesg) parm := buf [1.astpointer Q count]; og put (parm:mesg) buf [Iastpointer] \n:= parm; ~ count := O; lastpointer := O; .kQ ~ while (O< count< n); allowchoice get; count := count-1 \nor Et; count := count+l; last pointer := lastpointer O 1 endchoice 22%L2SQ ~ count = O then allow put; \ncount := count+l;  . Lastpointer := lastpointe r @ 1 else allow get; count := count-1 fi a e ndpa \nth It is easy to verify that count> O before each get and that count < n before each put. Inductive \nassertions can be used just as they are for se\u00adquential programs. This example demonstrates how a path \npro\u00adgram describes the history of a shared variable. It describes the activity of the shared variable \nfrom the point of view of the shared variable ra\u00adther than the point of view of the external process\u00ades. \nThis point-of-viewT concept extends to other parts of the monitor as well. The get and put operations \nare programmed from the point of view of the external process calling the monitor. These operation definitions \nare only concerned with what the caller expects to happen to his parameters. Synchronization is dealt \nwith exclusively in the path program. The multimachine schema model is intended to be able to represent \nany system of parallel pro\u00adcesses, not just those which synchronize bymeans of monitors with path programs. \nThe active/pas\u00adsive pairs formalize the synchronization activities of a system being modeled by an mms. \nThe ab\u00adstractness of the active/passive pairs symbolizes an assumption made in every conceptual model \nof parallel processes. Whatever the level of detail under discussion, the existence of a lower, more \n primitive synchronization mechanism is always assumed. For example, discussions of monitors using conditional \ncritical regions typically will detail the implementation of the conditional criti \u00adcaL regions but leave \ncompletely unspeciflled the mechanism which prevents more than one monitor process call at a time. It \nis in this sense meaningful to discuss imple\u00admenting the path program primitives in terms of path program \nprimitives. The author s disserta\u00adtion contains details of how the exec and allow primitives can be implemented \n~alls to lower\u00adlevel monitors with path programs whose primi\u00adtives are in turn implemented in hardware. \nAs hardware costs decrease and as automated hardware-design systems continue to be devel\u00adoped, a new \nsystems design paradigm becomes feasible. It will no longer be necessary to design software systems to \nfit existing hardware. Instead a two-step design process could be instituted. As the First step, all \nparts of the system could be de\u00adsigned in a low-level algorithmic language. As the second step, parts \nof this speci~lcation would be chosen to be implemented in hardware while other parts are implemented \nas software. The key aspect of such a design techniqae will the the algorithmic language. It must be \nsimpLe enough to act ae a hardware design language yet powerful enough to be appropriate for specifying \nsoftware. The possibility of multilevel implemen\u00adtation mentioned above gives credibility to the can\u00addidacy \nfor such a design language of a Pascal-1ike syntax using monitors with path programs. References [Ash] \nAshcroft, E. A. Proving assertions a about parallel programs. JCSS 10, 1 (Jan. 1975), 110-135. [BH] Brinch \nHansen, P. Operatiilg Systems Principles, Prentice-Hall, 1973. [CamHab] Campbell, R. and Habermann, A. \nThe specification of process synchronization us\u00ading path expressions. Lecture Notes in Com\u00adputer Science \n16, Spring er-Verlag, Berlin, 1974. [Hoa] Hoare, C.A. R. Monitors: an operating system structuring concept. \nCACM 17, 10 (Oct. 1974), 549-557. [Hoi] Holt, A. W. Lecture given at the MIT Conference on Petri Nets \nand Related Meth\u00adods, July 1975. [Kel] Keller, R. M. Formal verification of parallel programs. CACM 19, \n7 (July 1976), 371-384. [Lau] Lauer, H. C. Correctness in operating systems. Ph. D. Thesis, Carnegie-Mellon \nUniversity, Sept. 1972. [Lip] Lipton, R. On synchronization primi\u00adtive systems. Ph. D. Thesis, Carnegie-Mellon \nUniversity, 1974. [Miz] Mlzell, D. W. A true concurrency approach to paraltel process modeling, verification \nand design. Ph. D. Thesis, University of Southern California, Oct. 1977. [Owi] Owicki, S. S. Axiomatic \nproof tech\u00adniques for parallel programs. Ph. D. Thesis, Cornell University, July 1975.  \n\t\t\t", "proc_id": "512760", "abstract": "Most abstract models of a set of parallel processes define a computation of the model to be a sequence. It is either a sequence of actions taken by the system [Lip] or a sequence of states of the system existing between actions [Kel, Lau, Ash]. Parallelsim is represented only by the fact that following a given action or state, the \"next\" action or state is not necessarily unique. That is, parallesim is represented by nondeterminism. A. W. Holt has called this representation approach \"serializable concurrency\" as opposed to \"true concurrency\" [Hol]. He, among others, has questioned the appropriateness of implying a total ordering between events that are only known to be partially ordered.In this paper, a definition of an algebraic model of a set of concurrently-executing sequential processes is presented. The \"computations\" of this model are directed acyclic graphs. The nodes of each computation graph represent computer operations and the edges represent the partial ordering of operations with respect to time.Examples demonstrate that these directed acyclic graphs aid in focusing a programmer/verifier's attention on the most important features of a computation. The model suggests the following verification paradigm: since systems often execute a certain sequence of actions to achieve a certain goal, verification procedures should identify these sequences, whether or not each is performed within a single process.A key notion in the abstract model is the treatment of synchronization mechanisms as full-fledged processes. A programming language syntax called \"path programs\" which is suggested by this notion is presented. Path programs are a generalization of the path expressions of Campbell and Habermann [CamHab]. The programming notation is based on the assumption that a processor can be dedicated to each shared data structure in the system. The duty of this processor is to control the synchronization of operations on the data structure.", "authors": [{"name": "David Mizell", "author_profile_id": "81536702956", "affiliation": "University of Southern California, Los Angeles, California", "person_id": "PP309798700", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512760.512778", "year": "1978", "article_id": "512778", "conference": "POPL", "title": "Verification and design aspects of true concurrency", "url": "http://dl.acm.org/citation.cfm?id=512778"}