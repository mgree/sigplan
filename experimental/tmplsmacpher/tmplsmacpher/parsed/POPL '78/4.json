{"article_publication_date": "01-01-1978", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1978 ACM 0-12345-678-9 $5.00 Conference Record of the Fifth Annual ACM Symposium on principles of Programming \nLanguages TYPE DEFINITIONS WITH PARAMETERS* (Extended Abstract) Marvin Solomon university of Wisconsin \n--Madison Introduction It has long been known that recursively defined types in a highly typed language \nsuch as Algol 68 or Pascal may be tested for structural equivalence by the same algorithm that compares \nfinite automata [5,11] . Several authors (for example, [3,8,9,16]) have proposed that classes of types \nbe simultaneously defined by the use of parametrized type defini\u00ad tions, such as ~ list(x) = record \nval:x; next: +_list(x) end . This paper shows that unless the use of such parameterized definitions is \nrestricted, new (unparameterized) types may be defined which more closely resemble deterministic context-free \nlanguages. In fact, the equivalence problem for such types becomes as hard as the (currently unsolved) \ndeterministic pushdown automaton equivalence problem. Several restrictions on type definitions are considered \nwhich allow known equivalence algorithms to be applied. Equivalence and compatibility The type of a value \nlimits which operations may be performed on it. For example, character strings and integers have different \ntypes; only strings may be concatenated and only integers may be added. Moreoverr the type of a value \nalso dictates the type of the result obtained when a legal operator is applied to it. For example, a \npointer value may be subjected to the operation deref, which retrieves the value to which it points. \nBut a pointer to an integer should be distinguished from a pointer to a string, since the results of \napplying the deref operator to them have different types. In other words, the sequence <deref, add> is \napplicable to a pointer-to-integer valuer but not to a pointer\u00adto-string. Informally, Behavior(t) is \nthe collection of all information about which operations are applicable to t. Clearly, types with distinct \nbehaviors are not equivalent. Whether *A much more detailed version of these results may be found in \n[12] . 31 the converse is true is largely a matter of taste. The Algol 68 definition [15] takes the viewpoint \nthat types that have identical behaviors are equivalent. Pascal implementa\u00adtions, largely for reasons \nof convenience, generally take a more restrictive view and re\u00adquire that equivalent types be declared \nin the same way. Those who prefer the latter viewpoint may prefer to use the term compatibility rather \nthan equivalence. We will, however, identify a type with its behavior. The behavior of a type may be \nconveniently represented by a tree. For example, the type declared ~ rec = record i:integer; ip:+real \n@ (1) might be represented thus: .#coQ\\ip Behavior(rec) = (2) integer poi~~er r e-a 1 Leaves are labelled \nby built-in-t= ( integer and real in this example) , inter\u00adnal nodes are labelled by ~ constructors ( \nrecord and pointer ), and arcs are la\u00adbelled by selectors ( i , rip , and 4 ) . (From the point of view \nof type checking, a pointer is like a record with one field called ~ or deref ). For technical reasons, \nit is helpful to assume that each constructor has a unique number of arguments. This is the . reason \nfor the subscript 2 on record. Certain types are amenable to arbitrarily long se\u00adquences of operations \nand so have behaviors represented by infinite trees. For example, ~ intlist = record val:integer; next:tintlist \nend (3) val~cor~next Behavior(intlist) = integer (4) [ier i;:;[co%e t ~ier . . Behavior trees can be \ncompletely specified by sets of strings as follows. Each node in a tree t has an address which is the \n(unique) sequence of selectors leading from the root to the given node. For each built-in type or constructor \ns, let Address(s,t) be the set of addresses of nodes in t labelled by s. Regular and context free types \n. In [11] , we proved the following: Theorem 1. (See also Kral [5]) \\ A tree t is the behavior of a type \ndefined by a type definition such as (1) or (3) if and only if Address(s,t) is a regular set for each \ns appearing in t. M 32 Example If t = Behavior (intlist) then Address (record2,t) = (next 4)* Address \n(integerrt) = (next 4)* val (5) Address (pointerrt) = (next +)* next . N Type definitions in languages \nlike Algol 68, Pascal, or PL\\I are constructed from built-in types, built-in type constructors, and defined \ntypes. It has been suggested [3,8,9,16 that it would be useful to include, in addition, defined type \nconstructors, to allow definitions such as ~ list(x) = record val:x; next:+list(x) ~; intlist = list(lnteger); \n(6) reallist = list(real); intlistlist = list (list(integer)); etc. Unfortunately, with the addition \nof defined type constructors (called medals in [31 and [8]) , Theorem 1 no longer holds. For example \n!222 cf(x) = record val:x; next:cf(~x) end; (7) cfg = cf(integer) ; is superficially similar to (3) or \n(6). However, it defines this behavior: record i;:g ~:::, t = Behavior(cfg) = - (8) PoiX~~ ~nextre?ord2 \n ~ r integer val/ q~: \\ next : int!~er and Address (integer,t) = {nextn val ~n I n ~ 0}, which is not \na regular set. FOr this reason, we will call types defined in this way context-free types. Nonetheless, \nthe situation is not hopeless. The address sets of context-free types are no more complicated than deterministic \ncontext-free languages. Theorem 2 If t is the behavior of a context-free type, then for each built-in \ntype or construc\u00ad tor s appearing in t, Address(s,t) is deterministic context-free. Proof (Sketch). Consider \nthe definition ~ t(x~,xz) = record a:t(record record b:xl;C:X2 end . a:integer; a:integer; b:xl; b:real; \nc:real C:X2 @r end) ; (9) The right-hand side of this definition is more clearly represented as a tree: \n (10) in Behavior(t) is the infinite tree that results from repeatedly expanding (10) by re\u00adplacing a \nnode labelled t with the definition of t (viz., the tree (10)). When a node is replaced, a copy of its \nleft subtree is substituted for each occurrence of xl in (lQ) , and a copy of its right subtree is substituted \nfor each X2. The process is formalized in various ways in [2,7,10,11,12]. Consider an occurrence of integer \nin Behavior(t) . Either it is one of the two top-level occurrences explicitly shown in (10), or it is \nan embedded occurrence resulting from the expansion of the shown occurrence of t. A path from the root \nto an oc\u00adcurrence of integer is thus of one of the three forms au, ava, or awa, where u is a (shorter) \npath to an occurrence of integer , v is a path to an occurrence of X1 , and w is a path to an occurrence \nof X2 . From this we see that Address (integerrt) is generated by the context-free grammar <integer> \n::= a <integer> [ a <t-xl> a I a <t-X2> a <t-xl> ::= b I a <t-xl> b (11) <t-x2> ::= c I a <t x2> c where \n<t-xl> generates the set of paths from the root of partially expanded versions of t to an occurrence \nof xl . Thus Address (integer,t) = {ambnalm~n~l} ~ {amcna I m ~ n~ 1]. More generally, a mutually recursive \nset of declarations can be modelled by such a grammar. To show that this language is deterministic, we \nconstruct a deterministic pushdown automaton P. The states of P are nodes of the tree on the right-hand \nside of (10). Stack symbol s are those nodes that are labelled by defined types and type constructors. \n(There is only one stack symbol in this example) . Final states are nodes labelled by integer . The action \nof P in state n is as follows: If n is labelled by a built-in constructor or type, then n heads a subtree \nof the form s(a:e1;b:e2;c:e3). Then P reads the next input symbol and goes to the root of el, e2, or \ne3 according to whether the input was a, b, or c. If n is labelled by the defined type or type constructor \nt, then P stacks its current state and goes to the state which is the root of the tree defining t. The \ninput is not examined. If n is labelled by the symbol xi , then P pops the top symbol off the stack. \nThis symbol will be the root of a subtree of the form t(e~,. ..,ek). P goes to the state that is the \nroot of ei. (If the stack is empty or k < i, then P rejects. ) The input is not examined. In contrast \nto Theorem 1, we have only a partial converse to Theorem 2. Lemma If L is a deterministic context-free \nlanguage with the prefix property (i.e., if xf3L then no proper prefix ofxisinL), then there exists a \ncontext-free type with behavior t constructed from the built-in constructors struct and integer such \nthat Address (integerrt) = L Address(struct,t) = {y I no prefix of y is in L}. Proof (Sketch) By the \nconstruction in [1, p. 691], we may assume that L is recognized by a pushdown automaton P in normal form \n. Roughlyr this means that the states of P are partitioned into scan states Qs, which read input without \nmodifying or examining the stack, write states Qw and erase states Qe, which manipulate the stack without \nexamining the input, and a unique final state qf from which no moves are possible. Also, an erase state \nis never the immediate successor of a write state. It is not hard to show that P may be further restricted \nso that the symbol pushed on the stack by a write state is the write state itself. NOW construct a definition \nas follows: Let {al,. ..an } be the alphabet of L,, let Qe = {Pi,...,Pm}, and let 6 be the transition \nfunction of P. Introduce an m-argument de\u00adfined type constructor tq for each q @ Qe. lf q ~ Qs, then \nfor each air there is a state qi such that 6(q,airY) = (qi,y) for any stack symbol Y. Include the declaration \ntq(xl,...xm) = record al:el; a2:e2; . . . . an:en end ifqi = ??j ~Qe j where ei = { tqi(xl,. ..,xm) if \nqi @ Qe If q ~ Qw, then there is a state q @ Qe such that for any stack symbol Y, 6(q,c,Y) = (q ,qY). \nInclude the declaration tq(xl,...,xm) = tql(el,. ..,em) if 6(Pi,c,q) = (Pj,c); Pj ~ Qe j where ei = { \ntq l (xl,. . . ,Xm) if ~(pirc,q) = (q ,c), q $? Qe Finally, for the final state qf, add the declaration \n= integer. %f Theorem 3 The equivalence problem for context-free types is solvable if and only if the \nequivalence problem for deterministic context-free languages is solvable. Proof By Theorem 2, equivalence \nof types reduces to equivalence of deterministic languages. To prove the converse, let Ll and L2 be deterministic \nlanguages and let $ be a new symbol. Construct type definitions corresponding to Ll$ and L2$ as in the \nlemma. Then L1 = L2 if and only if the defined types are equ. va ent. Ml Restrictions Since a good deal \nof effort has been expended on unsuccessful attempts to solve the deterministic language equivalence \nproblem, it may be a good idea to restrict the range of definable types to keep the corresponding behaviors \nwithin some class that has a known equivalence algorithm. We know of no example of a non-regular type \nthat is of practical use for programming. The idea of allowing definitions like (6) was to facilitate \nthe de\u00adfinition of regular types, not to allow new types, so it might be reasonable to prohibit non-regular \ntypes. Proposition 1 It is decidable whether a context-free type is regular. Proof Theorem 2 give an \neffective procedure for constructing a deterministic pushdown auto\u00admaton (dpda) from a def nition. It \nis decidable whether a dpda accepts a regular set [131 . M The decision procedure of [13] is rather complex. \nIt involves testing an m-state dpda over an n symbol alphabet for equivalence with all finite automata \nhaving fewer than mm nm states. In practice, one would probably like to restrict the allowable definitions \nstill further, so that definable types are obviously regular. For example Proposition ~ If all applications \nof defined type constructors in a definition have the form t(e~?. ..,ek) where each ei is either a built-in \ntype or then all types defined ome j are regular. (Note that the definition (6) satisfies this restriction. \n) Proof Under these restrictions, the grammars constructed in (11) of the proof of theorem 2 are all \nright linear. N In spite of the above remarks, it is of some theoretical interest to see how far we can \nextend the range of definable types and still have an equivalence algorithm. =_ 2 Under the restriction \nthat no defined type constructor is applied to an expression containing a defined type constructor or \ntype, equivalence of types is decidable. Proof The restriction ensures that the push<own automata constructed \nas in the proof of theorem 2 are linear (i.e., all push moves precede any pop moves on each input) . \n[14] contains a proof that equivalence is decidable for linear dpda, All examples presented in this paper \nare linear. References [1] Aho , A. Volume V. and II: Unman, Compiling. J. D. The Theory Prentice Hall, \nof Parsingr Englewood Cliffs, Translation N.J., 1973. and Compiling, [2] Goguen, J. Switching A. and \nand Thatcher, Automata J. Theory, W. Initial v. 15, algebra 1974, 63-77. semant Cs. IEEE Symposium on \n[3] IFIP Working transport--modals, 1971) . Group 2.1. with Report application of the to subcommittee \nsorting. W on data-processing ulletin AB 37.4.3 and (MaY [4] Jensen, K. Science, and v. Wirth, 18. N. \nSpringer Pascal User Verl ag, Manual Belin, and 1974. Report. Lecture Notes in Computer [5] Krkl, J. \nBulletin The equivalence AB 35.4.5 of (March modes 1973) and . the equivalence of finite automata. Algol \n[6] Lampson, ~, 2 B. W., (February, et al. Report 1977). on the programming language Euclid. SIGPLAN \nNotices [7] Lewis, on C. H. Principles and Rosen, B. K. of Programming Recursively Languages, defined \nBostonr datatypes, Mass. , 1973. part I. ACM Symposium 3-? [8] Lindsey, C. H. Medals. AlgOl Bulletin \nAB 37.4.3 (1974). [9] Liskov, B., et al. Abstraction Mechanisms in CLU. M.I.T. Computation Structures \n Group Memo 144-1. Januaryr 1977. [10] Rosen, B. K. and Lewis, C. H. Recursively defined datatypes, \npart 11. Report RC 4713, IBM T. J. Watson Research Center, Yorktown Heights, N. Y., 1974. [11] Solomon, \nM. Modes, values and expressions. Second ACM Symposium on Principles of Programming Languages, Palo Alto, \nCalif., 1975, 149-159. (Also available as Tech. Rept. TR 74-219, Computer Science Dept., Cornell University, \nIthaca, N. Y., 1974). [12] Solomon, M. On type definitions with parameters. DAIMI Publication PB-54. \nAarhus University, Aarhus, Denmark, November, 1975. (Also available as chapter I of Theoretical issues \nin the implementation of programming languages. Ph. D. Thesis. Tech. Rept. 300, Computer Sciences Department, \nuniversity of Wisconsin, Madison, WI . June 1977.) [131 Stearns, R. E. A regularity test for pushdown \nmachines. Inf. and Control U, 3 . (September, 1967), 323-340. [14] Valient, L. B. The equivalence problem \nfor deterministic finite-turn pushdown auto\u00admata. Inf. and Control ~, 2 (Juner 1974), 123-133. [15] \nWijngaarden, A. van et al. Revised report on the algorithmic langua9e ALGOL 68. Acts Informatica ~ (1975), \n1-236. [16] wulf, w. A., London, R. L., and Shaw, M. Abstraction and verification in Alphard: introduction \nto language and methodology. Technical report, Carnegie-Mellon University, June 14, 1976.\n\t\t\t", "proc_id": "512760", "abstract": "It has long been known that recursively defined types in a highly typed language such as Algol 68 or Pascal may be tested for structural equivalence by the same algorithm that compares finite automata [5,11]. Several authors (for example, [3,8,9,16]) have proposed that classes of types be simultaneously defined by the use of parameterized type definitions, such asType list(x) = record val:x; next:&uarr;list(x) end .This paper shows that unless the use of such parameterized definitions is restricted, new (unparameterized) types may be defined which more closely resemble deterministic context-free languages. In fact, the equivalence problem for such types becomes as hard as the (currently unsolved) deterministic pushdown automaton equivalence problem. Several restrictions on type definitions are considered which allow known equivalence algorithms to be applied.", "authors": [{"name": "Marvin Solomon", "author_profile_id": "81452606415", "affiliation": "University of Wisconsin -- Madison", "person_id": "PP309815500", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512760.512765", "year": "1978", "article_id": "512765", "conference": "POPL", "title": "Type definitions with parameters", "url": "http://dl.acm.org/citation.cfm?id=512765"}