{"article_publication_date": "01-01-1978", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1978 ACM 0-12345-678-9 $5.00 COtIfeIX3nCe Record of the Fifth Annual ACM Symposium on Principles of Programming \nLanguages AStraightforward Denotational Semantics for Non-Determinate Data Flow Programs Paul R. Kosinski \nIBM Thomas J. Watson Research Center P.O. Box 218, Yorktown Heights, New York 10598 &#38; Laboratory \nfor Computer Science Massachusetts Institute of Technology Cambridge, Massachusetts 02139 Keywords \nData Flow Programming Denotational Semantics Non-determinacy Abstract Data flow programming languages \nare especially amenable to mathematization of their semantics in the denotational style of Scott and \nStrachey. However, many real world programming problems, such as operat\u00ading systems and data base inquiry \nsystems, require a programming language capable of non-determinacy because of the non-determinate behavior \nof their physi\u00adcal environment. To date, there has been no satisfactory denotational semantics of programming \nlanguages with non-determinacy. This paper presents a straightforward denotational treatment of non-determinate \ndata flow programs as functions from sets of tagged sequences to sets of tagged sequences. A simple complete \npartial order on such sets exists, in which the data flow primi\u00adtives are continuous functions, so that \nany data flow program computes a well defined function. Introduction In recent years a new class of programming \nlanguages, called data flow languages, has evolved [1,2]. Unlike most programs, the execution of data \nflow programs is governed solely by the availability of data, both input and computed, rather than by \nthe movement of one or more abstract lotuses of control. One of the virtues of data flow programming \nis that it allows parallelism to be expressed in a natural fash\u00adion. Furthermore, the parallelism can \nbe guaranteed deter\u00adminate, if desired. The expression of parallelism is one of the early reasons researchers \nwere attracted to data flow. However, data flow is now known to have other advantages as well. The two \nmost important are locality of effect and applicative behavior. Applicative behavior means that data \nflow operators can be characterized as mathematical func\u00adtions. Locality of effect means that the mathematical \nequa\u00adtions for a data flow program can be derived simply by con\u00adjoining the equations for the various \nparts of the program in an additive manner. Therefore, data flow languages cau be analyzed mathematically \nalmost as easily as toy appli\u00adcative languages (eg. pure LISP) but are more powerful in that they provide \nparallelism and memory. Concurrent with the rise of data flow programming has been the development of \nmathematical approaches to the semantics of programs. The success of syntax theory in making precise \nthe syntax of programs led investigators to attempt to describe the semantic behavior programs with equal \nprecision. There are three main approaches to precise semantics: the operational, the axiomatic, and \nthe denota\u00adtional or functional semantics. The operational approach, based on the notion of an abstract \ninterpreter, is the most intuitive of the three. The denotational approach of Scott and Strachey [3,4] \ntreats the semantic behavior of a program as a function from inputs to outputs, a well known kind of \nmathematical object. The axiomatic approach of Floyd [5] and Hoare [6], views a program as relating (in \nthe mathe\u00admatical sense) the before state of the abstract machine to its after state. In the denotational \napproach, each primitive operation in the language is described by associating with it a semantic function \nwhich it computes. Thus, a sequence of operations computes the function which is the composition of the \ncomponent operations functions. If the operations are performed repeatedly, as in a WHILE loop, the compos\u00adite \nfunction is not so easily determined. Such equations can be solved in certain circumstances by means \nof the Y, or fixed-point, operator. Scott s contribution has been to show that there exist lattices called \nreflexive domains in which the Y operator can always apply to give the unique minimal fixed-point solution \nof such equations, and that such do\u00admains characterize programming languages reasonably well. This approach \ncan be used on applicative languages with relative ease since such languages are based on the ideas of \nfunctions and their composition. A program is said to be non-determinate if it does not always yield \nthe same output when given the same input. Non-determinate program behavior is necessary in order to \ndeal with certain real world situations. This classic example of this is the airline reservations system. \nThe last seat on a given flight may be given to different persons, depending on the arrival time of the \nreservation requests and not merely on the data representing those requests, which is the same whether \nor not person A gets the seat. Non-determinate programs are difficult to mathematize in the denotational \nframework. This is because one must deal with sets of program states rather than the individual states, \nwhich adequately characterize determinate programs, and it is difficult to construct a domain whose elements \nare such sets. Past attempts [7,8] at constructing domains for non-determinate programs have been rather \nunsatisfactory due to their complexity. Overview of Data Flow Programming Languages DFPL, a Data Flow \nProgramming Language [1,9], has the basic mathematical simplicity of applicative languages without most \nof their drawbacks. Operators in DFPL func\u00adtionally transform their inputs to their outputs without ever \naffecting the state of the rest of the program. Since there is no control flow, there is no GOTO; in \nspite of this, iteration may be programmed as well as recursion. Most significant though, is the fact \nthat unlike ordinary applicative languages, programs may exhibit memory behavior, that is, the current \noutput may depend on past inputs as well as the current input. Memory in DFPL is not primitive but is \nprogrammed like other nonprimitive operators. Its effects are local like those of other operators and \nit does not permeate the se\u00admantics of programs. A DFPL program is a directed graph whose nodes are operators \nand whose arcs are data paths. Data in DFPL are pure values, either simple like numbers or compound like \narrays or records. An operator fires when its required inputs are available on its incoming paths. After \na unspeci\u00adfied amount of time, it sends its outputs on its outgoing paths. It is not necessary that all \ninputs be present before an operator fires, it depends on the particular operator. Similarly, not all \noutputs may be produced by a given firing. Many operators fire only when all their inputs are present, \nand produce their outputs all at once, they are analogous to subroutines. Some operators produce a time \nsequence of output values from one input value or conversely, they are analogous to coroutines. The operators \nin a DFPL program thus operate in parallel with one another subject only to the availability of data \non the paths. An operator may either be primitive or defined. An operator is defined as network of other \noperators which are connected by data paths such that certain paths are connect\u00aded on one end only. These \npaths are the parameters of the defined operator. A defined operator operates as if its node were replaced \nby the network which defines it and the par\u00adameter paths spficed to the paths which were connected to \nthat node. Recursive operators may be defined. A defined operator for adding complex numbers is given \nin the appen\u00addix. There are three classes of operators in DFPL: Simple operators, including the usual \narithmetic, logical and aggre\u00ad gate operators (eg. construct and select); Stream operators, including \nthe primitive Switch operators (for conditionals and other data routing) and primitive Hold operator \n(for memory and iteration); and Non-determinate operators, including the primitive Arbiter (for coping \nwith the non\u00addeterminate physical world). Simple operators all have the property that they demand ail \ntheir inputs to fire, whereupon they produce all their outputs. Furthermore, each firing is independent \nof any past hktory, that is, the operator is a function from current input to current output. Stream \noperators sometimes do not accept/produce all their inputs/outputs, or their current output may depend \non past inputs. Thus we can not describe their functional be\u00adhavior as simply as before (not producing \nan output is not the same as producing a null output). But we can describe their behavior if we view \nthem as functions from streams (sequences over time) of inputs to streams of outputs. Not all computable \nfunctions from sequences to sequences de\u00adscribe Stream operators however; the function must be cau\u00adsal, \nthat is, the operator may never retract some output upon receiving further input. Non-determinate operators \nproduce any one of a set of output values (according to whim, or in a real implementa\u00adtion, timing considerations) \nwhen presented with specified input values. The primitive Arbiter operator, upon which other Non-determinate \noperators may be based, takes as input two or more streams and produces as output a stream which is the \nresult of merging the input streams in some arbitrary way. Non-determinate operators may be viewed as \nrelations from sequences to sequences, or more profitably, as we shall soon see, as functions from sets \nof sequences to sets of sequences. Another approach to the denotational semantics of non-determinate \ndata flow programs, involving partially ordered events instead of sets of sequences (where an event is \neither the production or consumption of a datum), has beeri reported by Keller [10]. However, this report \ndoes not provide a complete semantics. A Brief Mathematical Background A partially ordered set (poset) \nis a set with a relation which is reflexive (A E A), transitive (A c B &#38; B L C implies AL C) and \nantisymmetric (ALB &#38; BLA implies A= B). The relation may not be total, that is, neither A E B nor \nB G A may hold. A quasi-ordered set is the same as a poset with\u00adout antisymmetry. A chain is a subset \nof a poset on which the relation is total, that is, either ALB or BLA. An upper bound of a subset is \nan element (in the poset, not necessarily in the subset) which every element of the subset is E to. A \nleast upper bound (Sup) is an upper bound which is c all other upper bounds. A chain complete poset (cpo) \nis one in which each chain has a Sup. Since the empty set is a trivial chain, its Sup (called ~ or bottom \n) must exist in a cpo and is z all elements of the poset. A function F on a poset is called isotone (or \nless pre\u00adcisely, monotone) iff for all X and Y, XZY implies F(X) LF(Y). A function F on a cpo is chain \ncontinuous (henceforth simply continuous) iff for all chains C in the poset, F(Sup C) = Sup F(C). It \nmay be shown that any continuous function is also isotone. The theorem which results from all this is: \nany continuous function on a cpo has a minimal fixed-point, that is, there exists an X such that F(X)=X \nand for all Y such that F(Y)=Y, XLY; Further\u00admore, X can be found by taking Sup {1, F(l), F(F(L)), F(F(F(l))), \n...] which isa chain because .Lc F(L) bydefini\u00adtion, and F is isotone since it is continuous. A Partial \nOrder Suitable f or Data Flow Since determinate operators are adequately character\u00adized as functions \nfrom sequences to sequences, the well known partial order on sequences, namely the prefix rela\u00adtion is \nrelevant. If the infinite sequences are included, the poset characterized by the prefix relation is chain \ncomplete. All the determinate operators of DFPL, if viewed as func\u00adtions from sequences to sequences, \nare continuous and there\u00adfore isotone in this poset. Therefore, the fixed-point equa\u00adtions resulting \nfrom a determinate data flow program can be solved in the cpo of sequences (where L is the empty se\u00adquence) \n[11 ]. In operational terms, an operator is isotone iff it is causal, and an operator is continuous iff \nit never waits for an infinite sequence of input data before it starts produc\u00ading output. the fixed-point \nequations can only be solved to yield a con\u00adgruence class of sets of sequences. For DFPL at least, such \ncongruence classes have the counter-intuitive property that one class contains two sets which are totally \ndisjoint. This means that certain fixed-point equations can be solved only to the point of saying you \neither get this set or that set, and they have no elements in common ! It is possible to obtain a straightforward \npartial order by considering sets of tagged sequences of data. Each datum in each sequence in the set \nhas associated with it zero or more tags, each of which identifies the sequence of arbitrary deci\u00adsions \nmade by a non-determinate operator which contributed to the existence of that datum in that sequence. \nA tag is a sequence of art Arbiter name followed by numbers which denote the decisions made by that Arbiter. \nSets of tagged sequences are constrained in the following two ways. First, the tag set of a later datum \nin a given sequence must be an extension of a tag set of an earlier datum in that sequence, where a tag \nset Tz is said to extend TI if there is a injection from T, to T2 such that each sequence in T1 is a \nprefix of its image. This says that a later datum may never be the result of fewer non-determinate decisions \nthan an earlier datum. Second, no tagged sequence in the set may be a prefix of another in that set (where \nthe prefix demands equality of corresponding tag sets as well as data). This says that no sequence is \nmerely an approximation to another. Two sets are compared by matching each sequence in the first set \nwith a sequence in the second set such that the first sequence is a prefix of the second sequence. This \nrela\u00adtion, denoted L , may be shown to be a true partial order\u00ading of sets of tagged sequences, and \nthe resulting poset is chain complete if infinite sequences and sets are admitted. To prove that E is \na partial order on Tagged\u00adsequence-sets, we must prove that it is reflexive, transitive and antis ymmetric. \nReflexivity is obvious: take the identity map as the injection of TSS1 to TSS1. Since any Tagged\u00adsequence \nis a prefix of itself, we have Tssl E Tssl. Transitivity is almost as simple. Given an injective map \nMl from Tssl to TSS2, and an injective map Mz from Tssz to TSS3, we know that the composition M2 o Ml \nis an injection from TSS1 to TSS3. Then, since the prefix relation is trans\u00ad itive, we know that every \nelement in Tssl is a prefix of its image (under Mz o Ml) in TSS3. Thus E is transitive. Unfortunately, \nnon-determinate operators are best viewed as functions from sets of sequences to sets of se\u00adquences. \nThis demands that determinate operators be treat\u00ad ed the same so that the domains and codomains of all \nopera\u00ad tors are compatible. Imposing a partial order on sets of sequences has been a frustrating task. \nFor example, Milner s ordering [7] is really only a quasi-order, which means that Antisymmetry is the \nmost difficult property to prove; it is the property which the alleged partial orders discussed earlier \nlack. Let Ml be an injection from Tssl to Tssl and Mz be an injection from Tssz to Tssl, We can immediately \nconclude that Tssl and TSS2 have the same cardinality and that Mz o Ml is a bijection from Tssl to itself. \nEach element of TSS1 must be a prefix of its image in Tssl under M2 o Ml, but due to the constraint on \nTagged-sequence-sets, no ele\u00adment can be a prefix of another. Hence the image must be the element itself \nso Mz o Ml must be the identity. Now we observe that each element of Tssl is a prefix of its image in \nTssz under Ml, and that element in TSS2 is a prefix of its image in Tssl under M2. But the image under \nMz is the original element in Tssl, so the element in Tssz is equal to the element in TSSI by antisymmetry \nof the prefix relation. Therefore, TSS2 is equal to Tssl, and E is antisymmetric. To show that the partial \norder Q is (countable) chain complete, we must show that any countable chain has a Sup. Let Tssl c Tssz \nL TSS3 L ... be such a countable chain, and let Ml, Mz ... be the associated sequence of injective maps \nwhich specify the relations (Ml: TSS1 + TSS2, Mz: Tssz + TSS3, ...). Let S be an element of Tss~, then \nthe set {S, MN(S), [MN. M~+l](S), ...} forms a chain under the prefix order and since sequences are chain \ncomplete, this set has a Sup which we call Ssup. Call the set of all such Sup s Tss\u00adsup. Since all the \nM s are injective, each element S of a Tss belongs to exactly one such chain. For each Tss~, define Msup~ \nto map each element S into Ssup, the Sup of its chain. Then we have that Msup~: Tss~ + Tss-sup is an \ninjective map which establishes that Tss~ c Tss-sup. But N was arbitrary, so Tss-sup is an upper bound \nfor the chain of Tss s. If there were another upper bound, call it Tss-ub, for the chain of Tss s which \nwas strictly less than Tss-sup, then there would be an element S-ub in Tss-ub which was a strict prefix \nof an element S-sup of Tss-sup, or there would be an element in Tss-sup which had no prefix in Tss-ub. \nIn the first case, S-ub would be an upper bound of some chain, but then S-ub is a strict prefix of S-sup, \ncontradicting the fact that S-sup was the Sup of that chain. In the second case, there would be a chain \nof elements from the Tss s which had no Sup in Tss-ub, hence Tss-ub could not even be an upper bound. \nTherefore, we may conclude that Tss-sup is indeed the Sup of the Tss s. 0 It remains to be shown that \nTss-sup satisfies the extra conditions on Tagged-sequence-sets: namely, that no Tagged-sequence is a \nstrict prefix of another, and that within an Tagged-sequence, the Tag-set on a later item in the Tagged-sequence \nmust extend the Tag-set on an earlier item. We prove these additional properties by contradiction. If \none Tagged-sequence, Tsl, were a strict prefix of another, TS2, then all the elements of the chain of \nwhich Ts 1 was the Sup would be in the chain of Tsz, hence Tsl could not be their Sup. 0 If the Tag-set \nextension property were not obeyed, then there would exist a Tagged-sequence Ts-sup in Tss-sup such that \nTag-set(Ts-sup~) did not extend Tag-set(Ts-supj), where J<K. But, since Tss-sup is the Sup of its chain \nof Tss s, there would exist some Tss ~ which contained a Tagged-sequence Ts a prefix of Ts-sup such that \nTSJ = TS-SUPJ and Ts~ = Ts-sup~ contradicting the Tag-set exten\u00adsion property assumed for the Tss s. \n0 Therefore the Tss-sup is a proper Tagged-sequence-set and is the Sup of the Tss s, which means that \nthe set of Tagged-sequence-sets is a complete poset. Behavior of Determinate Operators Any determinate \noperator, whose functional behavior on simple data sequences is known, may be extended to a function \non sets of tagged sequences, but not in the obvious way of applying the operator to all possible tuples \nof se\u00adquences in the Cartesian product of the input sets and prod\u00aducing an ouput set whose size is that \nof that Cartesian prod\u00aduct. The problem with this obvious approach is that the operator may be applied \nto data which could never coexist during actual execution because they were the result of con\u00adtradictory \ndecisions of the same Arbiter. The proper extension is as follows: execute the oper\u00adator on each tuple \nof input sequences in the Cartesian prod\u00aduct of the input sets, letting it consume an input datum whenever \nit wishes and produce an output datum whenever it wishes. However, while doing this, join the tag set \nassoci\u00adated with the input datum with an accumulating tag set (initially the empty .@), where joining \ntwo tag sets is done by taking their union and deleting any tags which are prefix\u00ades of other tags. Furthermore, \nwhenever an output datum is produced, it is tagged with the current value of the accumu\u00adlating tag set. \nThe execution of the operator is stopped, before producing any further output, whenever an inconsis\u00adtent \ntag set is accumulated. An inconsistent tag set is one which has two tags with the same Arbiter name \nbut with contradictory decisions. This rule assures that the operator s function is never applied to \ninput data which could never co-exist because they arose from different decision se\u00adquences of some non-determinate \noperator. After each tuple is processed in this way, the output sequence is put into the output set, \nand prefixes eliminated. Behavior of Non-determinate Operators The only primitive non-determinate operator \nis the Arbiter which, viewed as a function from sequences to sets of sequences, produces the set of all \npossible ways of merg\u00ading the input sequences such that each datum is tagged by the unique name of the \nArbiter (which just tells which Arbi\u00adter in the program it is) and the sequence of decisions made so \nfar. For example, if the input sequences (A ,B ) and ( C,D ) were merged by the Arbiter named a , the \noutput set would be: { (~a,>~a,,>ca,o,)~a,,,,)> (Aa,!ca,,>Bao,o? Dao,o,), (~ao>cao,,~ao,,>~ao,,o), (ca,,~aio,~aloo,~alool), \n(cal~alo~alol~alolo), (cal,~all,~a,lo! ~alloo) ~ Viewed as a function from sets of tagged sequences to \nsets of tagged sequences, the Arbiter is extended like any determinate operator, except that the accumulating \ntag set always has a generated tag in it which tells the sequence of decisions made so far by the Arbiter \n(it is initially just the Arbiter s name), and all possible merges are generated in parallel. Proof of \nContinuity To prove that the extended determinate operators are isotone, we first prove a lemma concerning \nsuch extensions in general. Let F be a function which maps Tagged\u00adsequences x Tagged-sequences * Tagged-sequences, \nand call its extension F*. Then define F* as follows (where TSSI is a Tagged-sequence-set, and TsaI and \nTsbI are Tagged\u00adsequences): F*(Tss1,Tss:,...) = {F(Tsal,Tsaz,... )rra-prefjxj@F( Tsbf,Tsb,,,)...) I Tsal,Tsbl~Tssl \n&#38;Tsaz,Tsb2~Tss2&#38;... } We now show that if TSSIETSSXI, then F*(TssI,Tss2,... ) c F*(TssxI.Tss2,...). \nPick an arbitrary TS<F*(TSS,,TSS2,...), then there exist TSICTSSI and TSZCTSS2 such that TS = F(Ts1,Ts2,...). \nSince Tssl E Tssxl, there exists Tsxle Tssx1 such that TS1 is a prefix of TSX1, which implies that Ts \nis a prefix of F(TsxI,Ts2,...) since F is isotone. But either F(TSX1,TS2,...) <F*(TSSXI,TSS2) ...) or \nF(Tsx1,Ts2,...) was dis\u00adcarded by the not-a-prefix-of . and there exists TSXCF (TSSX1,TSS,,...) such \nthat F(Tsxl,Ts,,...) isa prefix of Tsx. Therefore Ts is a prefix of Tsx, but Ts was arbitrary, so for \nall TSCF*(TSSI,TSSZ,... ) there exists TSXCF*(TSSXI,TSS2,...) such that Ts is a prefix of Tsx, and hence \n(since the sets are prefix-reduced) F*(TssI,TssZ,...) L F*(TssxI>TssZ>...). l Now we may prove that such \nisotone extensions are also continuous. Let Tss~ be a chain whose SUP is TSS. Let F be a function on \nTagged-sequences which is continuous and thus isotone. Consider the sequence of image sets F(Tss1), F(Tss2), \n... T(Tss); note that this is not the exten\u00ad sion of F as above, just the normal application of a function \nto a set of arguments. If X~,X~+l, ... X (where X1e TssI) is a chain with Sup X, then F(X~), F(X~+l), \nF(X) is a chain whose Sup is F(X). But, although F(X1) .sF(TssI), it is not necessarily the case that \nF(XT) c F*(TssI). However, if F(X~)c F*(TssJ), then F(XJ+I)CF*(TSS,+I) because F(XJ) 6 F*(Tss,) means \nthat for all F(YJ) .cF*(TssJ): F(XJ) is not a prefix of F(YJ) and vice versa, and also that: XJ is a \nprefix of X,+l and Y1 is a prefix of Y,+l imply that F(X.J) is a prefix of F(XJ+I) and that F(YJ) is \na prefix of F(YJ+l). Thus F(XJ+l) is not a prefix of F(Yj+l) nor vice versa, by the properties of the \nposet of sequences. Therefore, every chain of F(XI) (an element of F(TssI) ) has a closed-above sub\u00adchain \nF(XI>J) (an element of F*(TssIZJ)), so F*(Tss1), F*(Tss2), ...-F*(Tss) is a chain and F*(Tss) is its \nSup. 0 The detailed proofs of the isotonicity of the determinate operators on Tagged-sequences are too \nlong to be included here. Furthermore, the proof of isotonicity and continuity of the Arbiter requires \na somewhat different approach, since it is not merely an extension of a determinate operator: in fact, \nit is a different recursion schema. The appendix con\u00adtains the recursive definition of the Arbiter, and \nalso a rep\u00adresentative determinate operator, the Outbound Switch (Oswitch). The other definitions and \nthe complete proofs are presented in [12]. Results Since the determinate operators are isotone and contin\u00aduous \nin the poset of data sequences, they are isotone and continuous in the poset of sets of tagged data sequences. \nSimilarly, the Arbiter is isotone and continuous in the poset of tagged sequences. Therefore, any recursive \nsystem of equations involving these operators has a unique minimal (first order) fixed-point in that \nposet. This means that any DFPL program, with or without iteration (cycles in the di\u00adrected graph), but \nwithout recursion, corresponds to a well defined function from sets of tagged sequences to same, and \nall such functions are themselves isotone and continuous. Furthermore, since the set of continuous functions \nfrom complete posets to same, is itself a complete poset, and since composition and the first order fixed-point \nfinding functional are continuous in this poset, any system of recursive func\u00adtional equations has a \nunique minimal (second order) fixed\u00adpoint which is a first order continuous function. This means that \nDFPL programs with recursive operators correspond to well defined functions from sets of tagged sequences \nto same. Hence, all DFPL programs correspond to well defined functions. Conclusions Data flow programming \nlanguages have cleaner mathe\u00admatical semantics than ordinary programing languages. This is because they \nare basically applicative in nature and local in effect so the functions act solely on the data without \nstates, continuations or other complications. The tags asso\u00adciated with the data sequences do complicate \nmatters of course, but this complexity is for the purpose of dealing with non-determinacy, which is not \naddressed by states, continua\u00adtions etc. Furthermore, the tags serve double duty. First, they allow the \nconstruction of a straightforward partial or\u00adder. Second, they are necessary to the specification of \nhow operators functionally transform input sets of sequences to output ones. Hence they are less onerous \nthan they might seem at first. It seems reasonable to assume that the approach out\u00ad lined above, namely \nthe use of tagged sets of objects, is applicable to the mathematization of the semantics of non\u00addeterminate \nprograms in conventional languages. However, the details remain to be worked out. References 1. J.B. \nDennis, First Version of a Data Flow Procedure Language . MIT Project MAC, Computation Structures Group, \nMemo 93 (1973). 2. P.R. Kosinski, A Data Flow Programming Language . IBM Research Report RC-4264 (March \n1973). 3. D. Scott, Outline of a Mathematical Theory of Computation . Proceedings of the Fourth Annual \nPrinceton Conference on Information Sciences and Sys\u00adtems, pp 169-176 (1970). 4. R.D. Tennent, The Denotational \nSemantics of Program\u00adming Languages . Communications of the A Ckf, Vol. 19, No. 8 (August 1976) pp 437-ff. \n 5. R.W. Floyd, Assigning Meanings to Programs . Pro\u00adceedings of Symposium in Applied Mathematics, Ameri\u00adcan \nMathematical Society, vol. XIX (1967 ) pp 19-32. 6. C.A.R. Hoare, An Axiomatic Basis for Computer Programming \n. Communications of the ACM, Vol. 12, No. 10 (October 1969) PP 576-583. 7. G.D. Plotkin, A Power-domain \nConstruction . SIAM Journal on Computing, Vol. 5, No. 3 (September 1976). 8. M.B. Smyth, Power Domains \n. Conference on Mathe\u00admatical Foundations of Compnter Science, Gdansk, Po\u00adland (September 1976).  9. \nP.R. Kosinski, Mathematical Semantics and Data Flow Programming . ACM Third Symposium on Principles of \nProgramming Languages (January 1976). 10. R.M. Keller, Denotational Models With Indeterminate Operators \n. IFIP Working Conference on Formal De\u00adscription of Programming Concepts (August 1977). 11. G. Kahn, \nA Preliminary Theory for Parallel Programs . IRIA Laboratory Report 6 (January 1973). 12. P.R. Kosinski, \nDenotational Semantics of Determinate and Non-Determinate Data Flow Programs . PhD The\u00adsis, MIT Laboratory \nfor Computer Science (in prepara\u00adtion).  Appendix Notation Subscripts select members of sets, function \narguments etc. Superscripts are only used to select elements from sequences. Angle brackets, ( and ) \n, build a sequence, like LISP List. The operator x attaches an element to the beginning of a sequence, \nlike LISP Cons. The operator A deletes the first element of a sequence, like LISP Cdr. The operator @ \njoins two sequences together, like LISP Append. The operators < , < , and ~ test the obvious variants \nof the pre~ix-o~ relation. Outbound Switch Oswitch*(Port; Tssc,Tssd) = {Oswitch(Port; Tsca,Tsda) d Oswitch(Port;Tscb, \nTsdb) I Tsca,Tscb< Tssc A Tsda,Tsdb e Tssd} Oswitch(Port; Tsc,Tsd) = Z~Tsc=O VTsd=OTherzo If Datum(Tscl) \n= Port A Consistent-tags( Tag-set(Tscl), Tag-set(Tsdl)) Then (Do,tum(Tsdl), iWe~ge-tags(Tag-set (Tscl),Tag-set( \nTsdl)) ) x Oswitch(Port;ATsc, ATsd) If Datum(Tscl) # Port A Consistent-tags (Tag-set( Tscl),Tag-set(Tsdl)) \nThen Oswitch(Port;ATsc, ATsd) Otherwise ( ) Arbiter Arbiter(Arbname; TSSO,..., TSSN) = {TSZE TSS I VTSYC \nTSS: TSX ~ TSY} where Tss = U {Arbmerge({(Arbname, ( )) I, TSO,..., TSN) I VI<N: TSIC TSSII Arbmerge(Tgs,Tso, \n....TsN) = U1<N Arbmergel(Tgs, Tso,..., TsN) Arbmergel(Tgs, Tso,...,TsN) = If TS1 = () Then {()] If Consistent-tags( \nExtend-tag(Arbname,I. Tgs),Tag-set(Ts11)) Then { (Datum( TS1f). Tgsx) * TS I Ts E Arbmerge(Tgsx, Tso,...,ATslTsN \n).TsN) A Tgsz = Merge-tags(Eztend-tag( Arbname,I, Tgs), Tag-set(Ts11)) 1 Otherwise {()} Auxiliary Functions \nConsistent-tags( Tag-setl,..., TasetN)N) = VTg1,Tg9c U1<NTag-setl: Arbiter-name(Tgl) = Arbiter-name( \nTgJ +. Choice-seq~ence (Tgl) < Choice-sequence( TgJ V Choice-sequence (Tgl) 2 Choice-seguence (Tgz) Merge-tags(Tag-setl,..., \nTasetN)N) = { Tgle U1<NTag-setl I VTg$e U1<NTag-setl : Arbite~-name(Tgl) = Arbite~-name(TgJ +. Choice-sequence( \nTgl) d Choice-sequence( TgJ ] Extend-tag(Arbname, Choice, Tgs) = { Tg GTgs I Arbiter-name(Tg) # Arbname \n} U {(Admame, Choice-sequence (Tg) @ (Choice)) I Tg c Tgs A Arbiter-name (7 g) = Arbname] Datum(Ts) = \nTS1 Tag-set(Ts) = Tsz Arbiter-name(Tag) = Tagl Choice-sequence( Tag) = Tagz 220 r --1 1 COMPLEX 1 MULTIPLYL \n +   z t RE-IM 1 . , l t RE-!M 1 I I I I I I x * * * * u I I + I I I 1\u00ad .  COMPLEX I 1Z*W  ! . \n I I I  I I I I I I I \n\t\t\t", "proc_id": "512760", "abstract": "Data flow programming languages are especially amenable to mathematization of their semantics in the denotational style of Scott and Strachey. However, many real world programming problems, such as operating systems and data base inquiry systems, require a programming language capable of non-determinacy because of the non-determinate behavior of their physical environment. To date, there has been no satisfactory denotational semantics of programming languages with non-determinacy. This paper presents a straightforward denotational treatment of non-determinate data flow programs as functions from sets of tagged sequences to sets of tagged sequences. A simple complete partial order on such sets exists, in which the data flow primitives are continuous functions, so that any data flow program computes a well defined function.", "authors": [{"name": "Paul R. Kosinski", "author_profile_id": "81100626960", "affiliation": "IBM Thomas J. Watson Research Center, Yorktown Heights, New York and Massachusetts Institute of Technology, Cambridge, Massachusetts", "person_id": "PP40029187", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512760.512783", "year": "1978", "article_id": "512783", "conference": "POPL", "title": "A straightforward denotational semantics for non-determinate data flow programs", "url": "http://dl.acm.org/citation.cfm?id=512783"}