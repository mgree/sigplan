{"article_publication_date": "01-01-2000", "fulltext": "\n Component Migration with Enterprise JavaBeans Michael Richmond Information and Communication Sciences \nMacquarie University Sydney, Australia +61 2 9850 6346 mar@ics.mq.edu.au 1. INTRODUCTION Currently available \ncomponent infrastructure frameworks such as CORBA[3], DCOM[6] and Enterprise JavaBeans[7] support dis\u00adtributed \napplications by providing a transparent communication mechanism between components across hosts. Existing \ndistribu\u00adtion support implicitly prevents a component s re-distribution after binding: these frameworks \nprevent a component from being moved once the application has started running. Distributed applications \noften have a relatively long execution time so they need to adapt to changing application loads and usage \npat\u00adterns. Such applications require the ability to move components at any time during the application \ns execution. 2. DISTRIBUTION SUPPORT Without dynamic support for these changes it is necessary to restart \nthe application when structural changes are made. We have developed the following taxonomy[4] to consider \nthe possible alternatives in specifying the location of components in an applica\u00adtion: Static configuration \nIn a statically configured system, each component's location is specified before the system begins running. \nFor example, the location of DCOM components are defined by entries in the Windows system registry. \nDynamic configuration Dynamically configured distributed applications rely on the underlying framework \nto determine each component s location. In DCOM and CORBA, this type of distribution is achieved through \nthe use of trader services. A trader accepts requests for component instances, servicing the requests \nwith references to existing components, or by creating new components in the sys\u00adtem. Once bound, the \ncomponent cannot be moved without halt\u00ading the system. Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for profit or commercial advantage and that copies bear this notice and the full \ncitation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior specific permission and/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota \n&#38;#169; Copyright ACM 2000 1-58113-307-3/00/10...$5.00  Dynamic relocation Unlike the previous alternatives, \ndynamic relocation allows components to be moved at any time without halting the system. This allows \nthe system to be restructured to take advantage of changing system loads and adapt to varying user requirements. \nThe initial configuration of a system using dynamic relocation is specified by either of the preceding \nmethods, or a combination of both. Each of these options requires an increasing level of support from \nthe underlying component framework. Statically configured appli\u00adcations require support to instantiate \ncomponents on remote hosts according to a specified application topology. For dynamically configured \napplications the framework must support some way of algorithmically determining the best location for \neach component. Typically, this is based on the load of individual hosts in the sys\u00adtem, known behaviour \nof the application from previous executions and the existence of other instances of the required component \nalready in the system. Dynamic relocation, the third category in our classification, requires the component \ninfrastructure to support some form of component migration.  3. COMPONENT MIGRATION We define component \nmigration as the movement of a component instance from one host to another in a distributed system. Compo\u00adnent \nmigration can be used to improve the performance and flexi\u00adbility of an application in a number of areas. \nFor example: Application load balancing In a distributed application the transaction load on given compo\u00adnents \nand hosts often vary significantly. In such cases a compo\u00adnent can be migrated from a host with a relatively \nhigh load to one under a lower load to improve the application s performance. In this way, we can improve \nthe overall system performance. Application restructuring A distributed application s usage pattern \nand processing load are likely to change over the lifetime of an execution. For many dis\u00adtributed applications, \nit may be preferable to restructure the application to reflect these changes without halting its execu\u00adtion. \nPossible changes to a distributed application s structure, which will benefit from component migration, \ninclude those resulting from consolidation of processing nodes in the system, re-inte\u00ad gration of stand-alone \ndistributed components, and introducing component replicas to the system. Component survivability At \ntimes a host s impending shutdown or removal from a distrib\u00aduted application s pool is known in advance \n(such as for periodic maintenance, or host s allocation to other tasks). In these cases, a component \ncan be migrated to another host to ensure that the component survives the shutdown or removal of its \ncurrent host from the application.  Reducing network costs In some situations it is preferable to relocate \na relatively small component to the site of 1) a resource which cannot be moved (such as a particular \ndevice), or 2) a resource whose movement would cause more traffic than migrating the component (such \nas a large database). When the component no longer requires the resource it can be migrated back to the \noriginal host. This is similar to data collec\u00adtion agents[2] in effect, with the exception that control \nof the component's movement is maintained outside of the mobile entity. Decisions such as when to migrate \na particular component and to which host are system policy decisions that are outside the scope of our \nwork. We need to establish an understanding of how compo\u00adnent migration is used in practice before these \npolicy issues can be addressed. Through the study and use of component migration in real applications \nwe plan to determine which of these policy deci\u00adsions are best automated and which are better left under \nuser con\u00adtrol. Several concepts used in component frameworks, such as transpar\u00adent remote method calls, \nglobal name spaces, and group-wise com\u00admunication, originate from distributed operating system research. \nThis community also investigated the idea of moving an executing processing entity from one host to another. \nTheir goal, with process migration, was to migrate a process from one host to another. Process migration[1][5] \nhas been criticised as being a solution looking for a problem. The requirement for process level location \ntransparency is one of the main hindrances to wider acceptance of process migration in general purpose \nsystems. Component frame\u00adworks, however, have been designed to support location transpar\u00adency from very \nearly in the design process. The lower cost/benefit ratio associated with introducing migration to component \nbased systems may mean that component relocation is the problem that process migration techniques have \nbeen looking for.  4. CONCLUSION Component technology promises to simplify the design and imple\u00admentation \nof distributed applications by encapsulating dependen\u00adcies within components and furnishing programmers \nwith distribution support. In current component frameworks, this sup\u00adport takes the form of making component \ncommunication and dis\u00adtribution mechanisms transparently available across multiple hosts. We have presented \na distribution support classification which introduces component migration to support the restructuring \nof a system without halting its execution. In this way, high system avail\u00adability can be maintained while \nproviding the flexibility adapt to changing requirements. Our ongoing work involves extending the Enterprise \nJavaBeans component framework to support component migration. We expect our work to address the following \nopen issues: What changes to the EJB container and API does migration require?  What levels of programmer \ncontrol and use of migration are desirable?  Does EJB need versioning at the class or Bean level?  \nIs deep component migration necessary?  How can the Java RMI API be extended to support relocating objects? \n  5. REFERENCES [1] Douglis, F. &#38; Osterhout, J., Transparent Process Migration Design Alternatives \nand the Sprite Implementation , Software - Practice and Experience, 21(8), pp. 757-786, August, 1991. \n [2] Harrison, C., Chess, D. &#38; Kershenbaum A., Mobile Agents: Are they a good idea? , Technical Report, \nIBM T.J. Watson, 1995. [3] Object Management Group. The Common Object Request Broker: Architecture and \nSpecification. Revision 2.2. , Mas\u00adsachusetts, February 1998. [4] Richmond, M. Support for Dynamic Distribution \nin Compo\u00adnent Systems , Workshop on Component-Oriented Software Engineering '98, Adelaide, Nov. 1998. \n[5] Richmond, M. &#38; Hitchens, M., A New Process Migration Algorithm , Operating Systems Review, vol. \n31, no. 1, January 1997, pp. 31-42. [6] Roy, M. &#38; Ewald, A., Inside DCOM , DBMS, April 1997, pp. \n27-34. [7] Sun Microsystems, Enterprise JavaBeans Specification v1.1 , Sun Microsystems, Palo Alto, California, \nMarch, 2000. \n\t\t\t", "proc_id": "367845", "abstract": "", "authors": [{"name": "Michael Richmond", "author_profile_id": "81100562252", "affiliation": "Information and Communication Sciences, Macquarie University, Sydney, Australia", "person_id": "P198578", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367956", "year": "2000", "article_id": "367956", "conference": "OOPSLA", "title": "Component migration with enterprise JavaBeans (poster session)", "url": "http://dl.acm.org/citation.cfm?id=367956"}