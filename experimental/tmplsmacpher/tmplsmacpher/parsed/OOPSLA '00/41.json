{"article_publication_date": "01-01-2000", "fulltext": "\n Optimization of Distributed, Object-Oriented Systems William J. Ray SPAWAR Systems Center 53560 Hull \nSt., Code D44207 San Diego, CA 92152-5001 1 (619) 553-4150 ray@spawar.navy.mil ABSTRACT Object-Oriented \n(OO) computing is fast becoming the de-facto standard for software development. Currently, many OO systems \nconsist of a single, large object server and multiple client applications. Optimizations can be accomplished \nif these large monolithic servers are decomposed into numerous smaller object servers and spread across \nthe network. Matching object servers to network assets isn t a trivial task. The more criteria one considers \nin determining an optimal assignment, the more complex the processing becomes. Complicating matters is \nthe fact that many of these criteria are not fixed. Optimal deployment strategies for object servers \ncan change given deviations in object servers, client applications, operational missions, hardware modifications, \nand various other changes to the environment. Once distributed object servers become more prevalent, \nthere will be a need to optimize the deployment of object servers to best serve the end user s changing \nneeds. Having the ability to generate object server deployment strategies would allow users to take full \nadvantage of their network of computers. State of the art load balancing techniques consists of scheduling \na given number of independent tasks to a set of machines. Object servers do not have independent tasks. \nAll methods in an object are related. Also, the number of times a method is called is usually dependent \non the interaction with the end user. Object servers, client applications, user inputs, and network resources \ncan be profiled. A system of non-linear equations can be derived from these profiles. Solving this system \nof equations can produce more optimal deployment strategies for the object servers. Keywords Optimization, \ndistributed, object, load balancing. Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advantage and that copies bear this notice and the full citation on the first \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspecific permission and/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota (c) Copyright ACM 2000 \n1-58113-307-3/00/10...$5.00 1.1 Introduction The future of computing is heading for a universe of distributed \nobject servers. The evolution of object servers to distributed object servers will parallel the evolution \nof the relational databases. Over time, object servers will provide functionality to more client applications \nthan their original applications, just as relational databases were used by more applications than the \noriginal application. In both cases, systems optimized for the original application may not perform well \nfor the new applications. Tools that allow a programmer to model an object and create object servers \nwith all the necessary infrastructure code needed to work as a distributed object server will soon be \navailable. This will lead to an explosion in the number of object servers available to client applications. \nA user s network of computers will be in a constantly changing state. Object servers, applications, hardware \nand user preferences will be in a constant state of flux. No static deployment strategy can adequately \ntake advantage of the assets accessible on the network in such a frequently changing environment. No \nsystem can accurately predict user interaction with a system. Two separate users performing the same \njob will interact with a system differently. The same user may interact differently while performing \nthe same job. For these reason and combinatorial explosion problems, a software engineering approach \nmust be taken instead of a computer science approach. The alternative to the real world programmer is \na deployment strategy that is dictated by the system engineer s view of how the system will be utilized. \nOf course, the system engineer doesn t revisit this strategy every time hardware, software or user interactions \nchange. The goal is to make better deployment choices without the need for a system engineer, since many \nof these changes will take place without the knowledge of a system engineer or the budget to employ one.1 \n 1.2 Previous Work There has been little work on deployment strategies for distributed object servers. \nThe closest relevant research is in the fields of load balancing and client/server performance. State \nof the art load balancing techniques address scheduling of given independent tasks on a set of given \nmachines. Figure 1 depicts the processing that current load balancing research covers. Object servers \ndo not have independent tasks. All methods in an object are related because they reference data of the \nsame type. It is often useful to manage all the objects of a given type with a single object manager. \nFigure 2 represents this fact. Also, the 1 number of times a method is called is usually dependent on \nthe interaction with end users, very much like the situation in client/server performance research. We \npropose a system that enable optimization of object server deployment to meet changing needs.  Figure \n2. Load balancing object servers  1.3 Current Practices Because of the difficulty in producing the \ninfrastructure code necessary to support distributed object computing, many developers produce huge monolithic \nobject servers as seen in Figure 3. A powerful machine is usually needed to adequately handle this server \nand successful applications that experience large increases in the number of users may outgrow the capabilities \nof the fastest available single machine. With automated code-generation tools, these servers will be \nmuch easier to produce and reconfigure. This will allow servers to be partitioned according to the logical \nmodel as Figure 4 illustrates. This allows servers to be decomposed by partitioning unrelated or loosely \nrelated objects into different physical servers that can be deployed across the network to take advantage \nof the available assets. By taking advantage of all the assets on the network, faster response times \ncan be achieved. Many networks of computers are installed with a single purpose in mind. Over time, these \nnetworks support an evolving set of tasks. Even though the original role the network played can change \ndramatically, rarely does a single system engineer revisit the deployment strategy. What a user ends \nup with is usually the product of multiple system engineers choices made from his additional changes \nwithout regard to the system and its roles as a whole. It is infeasible, because of cost, to hire a system \nengineer to assess the whole system every time a change occurs. In the end, the user is left with a system \nthat s deployment strategy boarders on randomness.  Figure 4. Distributed object servers  1.4 Conclusion \nAlthough the current version of this system is rather simplistic, the approach seems to have merit. The \nsystem responds in a reasonable way with changes is the environment, constraints placed on the system, \nand different roles that a user might want. Since all of these changes take place on a given network \nof computers, static deployment strategies will never utilize the assets available to better support \nthe end user. Predicting exactly how a user will interact with a system that supports multiple roles \nwill always be an inexact science. This system is a software engineering approach to a real world problem \nthat currently exists without a better solution. No solution can be exact because of the limitations \ninherent in modeling users, software, hardware, etc. 2  \n\t\t\t", "proc_id": "367845", "abstract": "<p>Object-Oriented (OO) computing is fast becoming the de-facto standard for software development. Currently, many OO systems consist of a single, large object server and multiple client applications. Optimizations can be accomplished if these large monolithic servers are decomposed into numerous smaller object servers and spread across the network.</p><p>Matching object servers to network assets isn't a trivial task. The more criteria one considers in determining an optimal assignment, the more complex the processing becomes. Complicating matters is the fact that many of these criteria are not fixed.</p><p>Optimal deployment strategies for object servers can change given deviations in object servers, client applications, operational missions, hardware modifications, and various other changes to the environment.</p><p>Once distributed object servers become more prevalent, there will be a need to optimize the deployment of object servers to best serve the end user's changing needs. Having the ability to generate object server deployment strategies would allow users to take full advantage of their network of computers.</p><p>State of the art load balancing techniques consists of scheduling a given number of independent tasks to a set of machines. Object servers do not have independent tasks. All methods in an object are related. Also, the number of times a method is called is usually dependent on the interaction with the end user.</p><p>Object servers, client applications, user inputs, and network resources can be profiled. A system of non-linear equations can be derived from these profiles. Solving this system of equations can produce more optimal deployment strategies for the object servers.</p>", "authors": [{"name": "William J. Ray", "author_profile_id": "81100552135", "affiliation": "SPAWAR Systems Center, 53560 Hull St., Code D44207, San Diego, CA", "person_id": "PP14191732", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367971", "year": "2000", "article_id": "367971", "conference": "OOPSLA", "title": "Optimization of distributed, object-oriented systems (poster session)", "url": "http://dl.acm.org/citation.cfm?id=367971"}