{"article_publication_date": "01-01-2000", "fulltext": "\n Towards a Graphical Notation to Express the C++ Template Instantiation Process Arturo J. S\u00e1nchez CIS \nDept, University of North Florida 4567 St. Johns Bluff Road, South Jacksonville, FL 32224-2645 Ph. +1-904-620-2985 \n ASanchez@unf.edu ABSTRACT C++ programmers who make intensive use of templates for developing applications \nget poor support from the compilers they use. Typical error reporting associated with template analysis \nranges from long, nested, and therefore complex expressions, to short but cryptic messages. This poster \nintroduces a graphical notation that can be used as an intermediate abstract medium on which the result \nof template analysis can be expressed. The motivation of our approach is to make template analysis and \nerror reporting two orthogonal activities. If compiler implementors adopt a standard notation to express \nthe result of template analysis, tools to help programmers visualize/understand errors can be independently \ndeveloped, and used as compiler \"plug-ins\", which will hopefully have a positive impact on issues such \nas programmer s productivity and product quality. We have used this notation to manually parse examples \ntaken from the STL, and less known powerful uses of templates, such as expression templates, and template \nmeta-programming. The preliminary stage we are reporting on has helped us to (a) identify elements that \nare needed in the notation, (b) identify limitations that are due to the instantiation model inherently \nassociated with the language, and (d) have a sense of how useful the notation can be to pinpoint errors \nassociated with the analysis of non-trivial cases such as expression templates. Categories and Subject \nDescriptors D.3.3 [Programming Languages]: Language Contructs and Features Templates, Error Reporting. \n General Terms Programming Languages, Theory. Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for profit or commercial advantage and that copies bear this notice and the full citation \non the first page. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires \nprior specific permission and/or a fee. OOPSLA 2000 Companion, Minneapolis, Minnesota. &#38;#169; Copyright \nACM 2000 1-58113-307-3/00/10 $5.00. Jia Dei-Wei CIS Department, UMass-Dartmouth 285 Old Westport Road \nNorth Dartmouth, MA 02747 Ph. +1-508-999-8265  JDWei@hotmail.com Keywords C++ Template analysis. Error \nreporting. C++ compilers. STL. Expression Templates. Template meta-programming. 1. THE NOTATION AND \nITS USE Generic algorithm sort, from STL [1], in its simplest version, takes two iterators that define \na range within a container (lower bound, and one past the upper bound), and sorts in-place the given \nrange. Suppose then that we want to sort a range within a list of integers, which is an STL container. \nThe code to do this is very simple (we abuse C++ in the includeto save space!) #include <iostream>, <list>, \n<algorithm> using namespace std; int main(void) { list<int> c; //code to put stuff into c sort(c.begin(), \nc.end();} The code looks very natural, but after compiling it with GNU 2.95.2, Code Warrior Pro 5.0, \nand Borland C++ 5.5, the compilers reply with nested complex error messages, the longest one being 5,534 \ncharacters long, counting spaces! The fact that template error reporting ranges from very short and cryptic \nmessages (e.g. illegal operand ), to very long and cumbersome like the ones the example refers to, is \nsomething with which C++ programmers are very familiar. How can template error reporting be improved? \nIn this poster we propose a graphical notation to be used as an abstract medium on which the result of \ntemplate analysis can be expressed. The ultimate goal is to propose a standard intermediate language \nthat can be adopted by compiler vendors, so that template analysis becomes orthogonal with respect to \nother processes that are aimed at understanding how the template instantiation takes place. Examples \nof these are error reporting (textual and graphical), template visualization and navigation, and template \ndebugging. One of the advantages of this separation is the possibility of independent development of \ntools to support this processes that can be plugged-in as used with any compiler that abides to the standard. \nWe will illustrate the notation by means of an example. Then, we give a summary of the results of our \nexperience. We finish with a proposal of various activities to continue this research. 2. THE NOTATION \nAND ITS USE The notation we propose extends the idea of using a tree to synthesize the parsing of an \nexpression in a context-free language. It has various shapes for template classes, template functions, \nplain classes and functions, types that are not classes, variables and constants. Flow of information \nis expressed by means of different arrows. We have identified four types of arrows to express the focus \nof the analysis. Function Return Type Template Function Function Function Arguments Template Args (A \n= ?) Template Class Class Variable Constant Data Type go through Argument Object go through function \nobject We discovered the need to use these elements after manually parsing various examples taken from \nSTL [1], expression templates, and template meta-programming. They can be downloaded from http://www.unf.edu/~asanchez. \nThe examples on expression template and template meta-programming, some of which we had to modify just \nslightly, were taken from http://extreme.indiana.edu/~tveldhui/papers/Expression\u00adTemplates/exprtmpl.html. \nThe modifications are commented on the code. We apply the notation in two steps, naturally referred to \nas top\u00addown and bottom-up. The former shows the syntactic connections between nodes in the diagram. The \nlatter shows semantic information associated with the nodes. The top-down view of an expression template \nparsing (file dexper.cpp) is shown in the second diagram, while the bottom-up view is shown in the first. \n 3. SUMMARY AND FUTURE WORK We seem to have all the elements needed to graphically render the template \nanalysis associated with the examples we have studied. After we analyzed syntactically correct programs, \nwe then used the notation to determine how syntactic errors (due to template misuses) were depicted. \nIn this case, we found that the notation could be useful to pinpoint the source of the error. For instance, \nconsider the previous example, modified so that the expression to be evaluated is evaluate(x*(1.0+x), \n0.0, 0.0), where operator * has not been defined. The bottom-up view will clearly shows what is missing \nand all possible error messages associated with this. Not all compilers reported the same error in this \ncase. Since expression templates and template meta-programming use the compiler as a partial evaluator, \nerrors may occur at this level. For instance, a template meta-program to compute the factorial function \ncould fail if the result cannot be represented at compile time. Our notation does not capture this. Also, \nsince the C++ compiler does not check for properties of actual classes bound to formal class parameters, \nthe real nature of the error cannot be reported. We are currently working on producing a prototype intermediate \nlanguage for template analysis and building a graphical error reporting and navigational tool. evaluate(x/(1.0+x),0.0,1.0) \n 0.0 1.0 operator/ x operator+ 1.0 x   4. REFERENCES [1] D. R. Musser, and A. Saini. STL Tutorial \nand Reference Guide. Addison-Wesley, 1996.  \n\t\t\t", "proc_id": "367845", "abstract": "<p>C++ programmers who make intensive use of templates for developing applications get poor support from the compilers they use. Typical error reporting associated with template analysis ranges from long, nested, and therefore complex expressions, to short but cryptic messages. This poster introduces a graphical notation that can be used as an intermediate abstract medium on which the result of template analysis can be expressed. The motivation of our approach is to make template analysis and error reporting two orthogonal activities. If compiler implementors adopt a standard notation to express the result of template analysis, tools to help programmers visualize/understand errors can be independently developed, and used as compiler &#8220;plug-ins&#8221;, which will hopefully have a positive impact on issues such as programmer's productivity and product quality. We have used this notation to manually parse examples taken from the STL, and less known powerful uses of templates, such as expression templates, and template meta-programming. The preliminary stage we are reporting on has helped us to (a) identify elements that are needed in the notation, (b) identify limitations that are due to the instantiation model inherently associated with the language, and (d) have a sense of how useful the notation can be to pinpoint errors associated with the analysis of non-trivial cases such as expression templates.</p>", "authors": [{"name": "Arturo J. S&#225;nchez", "author_profile_id": "81100532381", "affiliation": "CIS Dept, University of North Florida, 4567 St. Johns Bluff Road, South Jacksonville, FL", "person_id": "P22247", "email_address": "", "orcid_id": ""}, {"name": "Jia Dei-Wei", "author_profile_id": "81332495738", "affiliation": "CIS Department, UMass-Dartmouth, 285 Old Westport Road, North Dartmouth, MA", "person_id": "P139562", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.368015", "year": "2000", "article_id": "368015", "conference": "OOPSLA", "title": "Towards a graphical notation to express the C++ template instantiation process (poster session)", "url": "http://dl.acm.org/citation.cfm?id=368015"}