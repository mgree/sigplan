{"article_publication_date": "01-01-2000", "fulltext": "\n Building a Large-Scale Generic Object Model: Applying the CYC Upper Ontology to Object Database Development \nin Java Stephen Strom FGM, Inc. 45245 Business Court, Suite 400 Dulles VA 20166 strom@acm.org ABSTRACT \nCan the bene.ts of re-use and patterns that are so well known in software design and implementation be \ncarried over into analysis and database design? The .edgling .eld of Analysis Patterns has provided only \na partial a.rmative answer. We have instead attempted to import the CYC upper ontology (an AI-derived \nmodel of everything ) into an object model expressed in Java. The result is an object model that is extremely \nresilient to change and should be extensible to practically any domain. We describe the dif\u00ad.culties \ninvolved and some of the most important lessons learned. 1. INTRODUCTION Object-oriented analysis has \ngenerally lagged behind design and implementation in the following ways: Tool support is still very weak; \nand each system has concentrated on build\u00ading an analysis model that addresses its current require\u00adments. \nThese analysis models are usually codi.ed into a more-or-less formal domain model : a set of classes \nthat is incorporated into the .nal product, including the system database. As a result, analysis models \nfor the system do not evolve gracefully. They are fragile and must usually be re-developed for each new \nproject. Database schemas cannot be grace\u00adfully extended, even in object databases which are generally \nmore friendly to schema evolution. Additionally, it is di.\u00adcult for disparate systems to communicate. \nThe success of patterns in the area of software design has led to an attempt to apply the same concepts \nin analysis and has spawned the .eld of analysis patterns . We have previously attempted to apply the \nconcepts of analysis patterns to our Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota &#38;#169; Copyright ACM \n2000 1-58113-307-3/00/10...$5.00 current project (Tracker 1) with mixed results. We initially used Fowler \ns analysis patterns [1] to successfully design a fairly generic domain model. Over time, however, it \nhas been necessary to continue to tweak these models in ways that are not always backward compatible. \nBoth Hay [4] and Silverston et al [7] have produced generic object models similar to Fowler s, but it \nseemed clear that these would su.er from the same long-term problems. In the AI world, Douglas Lenat \nproposed in the early 1980s that it was possible to build a general ontology which has the following \ncharacteristics (as stated by Russell and Norvig in their textbook on AI [6, p. 227]): It must be applica\u00adble \nin more-or-less any special-purpose domain (with the addition of domain speci.c axioms) , and di.erent \nareas of knowledge must be uni.ed. The result of this proposal was the CYC project. A good introduction \nhas been writ\u00adten by Lenat [5].The CYC (short for enCYClopedia) project was initially part of MCC but \nis now its own company. (See www.cycorp.com.) The CYC project has released the CYC upper ontology for \ngeneral use.2 While just a tiny subset of the entire CYC database, the CYC upper ontology neverthe\u00adless \ndwarfs systems such as Fowler s and seemed to promise the long-term completeness and robustness we were \nlooking for. 1The Tracker project is being developed by FGM for the Nonproliferation and Disarmament \nFund (NDF) of the US Government. Tracker is an automated export control sys\u00adtem that permits countries \nto track in real-time exports of proliferation concern, and to consult electronically (through an international \nnetwork) with other government ministries and foreign governments. Tracker is being implemented us\u00ading \nSwing; Java Enterprise Edition technologies, including Enterprise Java Beans (EJB), Java Server Pages \n(JSP), and Java Messaging Service (JMS); all atop an object database (Versant). 2Cycorp is providing \nthis material from the Cyc(tm) Upper Ontology at no charge, for everyone to use, including com\u00admercial \nservice use and incorporation into products. How\u00adever, it is not Public Domain. Please acknowledge Cycorp, \n3721 Executive Center Dr., Austin, TX 78731 in any use or citation of this material, and request that \neach further user include a full copy of this notice as well, in any use or citation they make of the \nmaterial. All these terms equally apply to renamings and other logically equivalent reformulations of \nthe material in any natural or formal language. Cycorp in\u00adtends to amend and expand the material from \ntime to time; the latest version is available at http://www.cyc.com Is it similarly possible to build \nan object model with a domain that spans all everyday objects and actions ? A model that is applicable \nin more-or-less any special-purpose domain (with the addition of domain speci.c classes) ? In particular, \ncould the CYC upper ontology be translated into a standard object-oriented language such as Java? 2. \nTECHNICAL APPROACH The CYC ontology is represented as a set of facts in .rst\u00adorder logic. It is written \nin CYC s own knowledge repre\u00adsentation language, CycL, which is an embedded language within Lisp. For \nreasons of portability and free access, we chose instead to represent the ontology using CLIPS3 ,a forward-chaining \nexpert system tool (developed at Johnson Space Center) and its port to Java, the Java Expert System Shell \n(JESS)4. The initial step in our process was therefore to convert the CYC upper ontology from CycL to \nCLIPS. Since both are based on Lisp syntax, this was a relatively straightforward thing to do. (We performed \nthe conversion in Macintosh Common Lisp using Lisp reader macros.) The lower-level database system was \nbuilt using an object database and the standard Object Query Language (OQL) and its Java bindings. Java \ncode generation is performed in CLIPS by rules which pattern-match on ontological facts from the CYC \nupper ontology. Also, rather than directly generating Java code, we generate an intermediate language \nde.ned using the m4 macro language and then process that output using m4 to produce the .nal Java output \n 3. CODE GENERATION ISSUES We were immediately confronted with the following issues regarding code \ngeneration: multiple inheritance, higher-order classes, and varying multiplicity of predicate arguments. \nThese issues are due to the impedence mismatch between Java s object model and the more general classifcation \nmechanisms in CYC. We initially handled multiple inheritance by generating Java interfaces. We intended \nto provide a set of default imple\u00admentations for each class (similar to Swing adapter classes for event \nlisteners). There would be null implementations of each interface, and a developer could choose to imple\u00adment \nwhichever parts of the interface were desired. To put it bluntly: This did not work. When we processed \nthe en\u00adtire set of facts, this resulted in 1768 Java interface de.ni\u00adtions, each containing zero or more \nattributes This number of classes and attributes was simply overwhelming. Instead, it was necessary to \nprune the CYC ontology to cover only the problem at hand. While this may at .rst sound like a retreat \nfrom our original goals, we know that as new classes from the CYC ontology are needed they can be added \nwith\u00adout breaking the existing classes. (Versant can handle this kind of schema evolution without even \ntaking the database o.ine.) The existence of higher-order classes (what Fowler calls the knowledge level \n) can be dealt with in either of two ways: Plant a link in an object to a separate class de.ning its \ntype (this is Fowler s recommended approach [1, pp. 26\u00ad28], or utilize the Prototype design pattern [2, \npp. 117-126]. We chose the .rst alternative for now but are continuing to explore the second. 3CLIPS \nexecutables can be downloaded from http://www.ghg.net/clips/download/executables/. The source code can \nbe downloaded from http://www.ghg.net/clips/download/source/. 4Available from Sandia Labs, see http://herzberg.ca.sandia.gov/jess) \n At .rst, we handled the problem of variable multiplicity by simply having each accessor return an array, \nthus treat\u00ading each relationship as intrinsically 1-to-many or many-to\u00admany, regardless of the fact that \nthe true representation of the relationship might be 1-to-1 or many-to-1. This has proven too confusing \nand we have altered the accessors to return only a single value where appropriate.  4. CONCLUSIONS It \nis possible to take a domain model expressed in .rst-order logic and (largely) automatically generate \nJava code from it. The CYC upper ontology is an acceptable system to use as the basis for such a domain \nmodel. The correction of certain shortcomings of the Java program\u00adming language would greatly ease these \ntask. The set of extensions we would recommend include: Multiple inheri\u00adtance of classes; multiple return \nvalues from functions; rela\u00adtionships as .rst-class objects; generics; macros; and higher\u00adorder classes \n(not metaclasses). Additional information, including an extended version of this paper, a diagram of \nthe parts of the CYC upper on\u00adtology that we used, and code examples, is available at the author s web \nsite: http://home.att.net/ stephenstrom. 5. REFERENCES [1] M. Fowler. Analysis Patterns: Reusable Object \nModels. Addison-Wesley, 1997. [2] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: Elements \nof Reusable Object-Oriented Software. Addison-Wesley, 1995. [3] J. Guy L. Steele. Common Lisp: The Language. \nDigital Press, second edition, 1990. [4] D. C. Hay. Data Model Patterns: Conventions of Thought. Dorset \nHouse, 1996. [5] D. B. Lenat. Cyc: A large-scale investment in knowledge infrastructure. COMMUNICATIONS \nOF THE ACM, 38(11), November 1995. [6] S. Russell and P. Norvig. Arti.cial Intelligence: A Modern Approach. \nPrentice Hall, 1995. [7] L. Silverston, W. H. Inmon, and K. Graziano. The Data Model Resource Book: A \nLibrary of Logical Data Models and Data Warehouse Designs. Wiley, 1997.  \n\t\t\t", "proc_id": "367845", "abstract": "<p>Can the benefits of re-use and patterns that are so well known in software design and implementation be carried over into analysis and database design? The fledgling field of Analysis Patterns has provided only a partial affirmative answer. We have instead attempted to import the CYC upper ontology (an AI-derived &#8220;model of everything&#8221;) into an object model expressed in Java. The result is an object model that is extremely resilient to change and should be extensible to practically any domain. We describe the difficulties involved and some of the most important lessons learned.</p>", "authors": [{"name": "Stephen Strom", "author_profile_id": "81100300686", "affiliation": "FGM, Inc., 45245 Business Court, Suite 400, Dulles, VA", "person_id": "P268901", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367918", "year": "2000", "article_id": "367918", "conference": "OOPSLA", "title": "Building a large-scale generic object model: applying the CYC upper ontology to object database development in Java", "url": "http://dl.acm.org/citation.cfm?id=367918"}