{"article_publication_date": "01-01-2000", "fulltext": "\n Extreme Programming in Practice James Newkirk Object Mentor, Inc. 565 Lakeview Parkway, Suite 135 Vernon \nHills, IL 60061 800 338-6716  newkirk@objectmentor.com Robert C. Martin Object Mentor, Inc. 565 Lakeview \nParkway, Suite 135 Vernon Hills, IL 60061 800 338-6716 rmartin@objectmentor.com  ABSTRACT Follow along \nthe implementation of an actual web-based applica\u00adtion developed using Extreme Programming (XP). The \napplication implements the user area for a commercial web site, using Java Servlets and JDBC. This report \nhighlights the practices of XP that worked well on the project as well as those that could be improved. \n Keywords Extreme Programming, Java, Servlets, JDBC. 1. INTRODUCTION This report details the use of Extreme \nProgramming on a small web-based application. The team consisted of experienced software engineers and \ncustomers who had not previously used XP in it s entirety. The report details how the team learns to \ndevelop software using XP. 2. The Registration System The project consisted of the redesign of a Registration \nSystem for a commercial web-site. The Registration System allowed users to register on our web-site, \nlogin, and then access selected information (i.e. papers, software, etc.) 3. The Existing Solution Prior \nto the use of XP to develop the Registration System there was an initial attempt to develop a similar \nsolution. This solution was cobbled together using Active Server Pages, a Microstate Access database, \nand an HTML editor. The solution worked well initially. Over a period of time we started making changes \nto our server. Strangely enough our solution eventually stopped working in a way that blocked access \nto our most valuable resources. The solution was poorly designed and did not handle error conditions \nvery well. Our thought was to scrap it in favor of a new approach. 4. What Went Wrong? The development \nepisode described in the previous section is an example of hacking gone bad. We were in a hurry, we threw \nsome code together, and we got it working. The project was so simple that we didn t think about employing \na process. We were lucky. The failure we experienced had no appreciable effect on our business. But it \nmight have been worse. Once the program failed, we realized that simply fixing it was not the best option. \nThere was a lot at stake, and future failures could significantly harm our business. We realized we needed \nto employ a process for making changes to our web-site. In hindsight, big Permission to make digital \nor hard copies of all or part of this work for per\u00ad sonal or classroom use is granted without fee provided \nthat copies are not made or distributed for profit or commercial advantage and that copies bear this \nnotice and the full citation on the first page. To copy otherwise, to republish, to post on servers or \nto redistribute to lists, requires prior spe\u00ad cific permission and/or a fee. OOPSLA 2000 Companion Minneapolis, \nMinnesota &#38;#169; Copyright ACM 2000 1-58113-307-3/00/10...$5.00 surprise. We have, for years, been \nopposed to using big heavyweight processes. We have worked for companies that have used them, and have \nconsulted for many others, and have never found the experience to be healthy. However, we clearly needed \nsomething to guide us in the creation of the redesigned version of the Registration System. 5. Playing \nTo Win If we must use a development process, we want it to be one that is lightweight, aggressive, and \npragmatic. We want it to help us understand the requirements, and produce software that meets those requirements. \nWe want it to impose no delays, and to help us to go as fast as we can without sacrificing quality. When \nproblems occur, we want the process to help us repair them instead of helping us to assign blame. We \nwant to play to win. 5.1 Extreme Programming (XP) For many years, we had been using an ad hoc set of \ndevelopment practices that were iterative, lightweight, and aggressive. We valued human communication \nover paper, valued good code over good diagrams, valued quick iterations with customer feedback, and \nvalued up front software design to manage dependencies. We d had a lot of success with these values; \nbut they were far from a written process definition. In 1998 we heard about Kent Beck s work with XP, \nand studied it carefully. XP resonated with many of our values, but challenged some others. XP values \nhuman communications over paper, values good code over diagrams, values quick iterations with customer \nfeedback, but does not value up front software design. Instead, XP allows a good design to evolve as \nrequirements evolve. The similarity in values was very compelling to us, and we wanted to try it. But \nthe up-front design dilemma was disturbing. One way to confront this dilemma might have been to accept \nsome of the XP practices and dismiss others. We could have tried to merge up front design with XP. However, \nwe had quite a bit of experience with evolving designs, and had also had some failures involving up-front \ndesign [1]. So it was not hard for us to suspend our disbelief regarding up-front design and simply try \nXP. So, we decided to employ XP as the process for developing the Registration System for our web-site. \n 6. The Registration System Using XP An XP project begins with a period of exploration, which continues \nthroughout the life of the project. It s purpose is to identify, prioritize, and estimate requirements. \nOnce enough requirements have been identified to provide the smallest system that will yield value to \nthe customer, the first release is planned. Within a release several iterations are planned during which \nthe programmers write the software. 6.1 Exploration Exploration takes the place of a written requirements \ndocument. Programmers and customers assemble together and discuss the customer s needs. The customer \nwrites stories describing these needs. In discussion with the customer, the programmers remove ambiguity \nfrom the stories by making sure that they are testable and estimable. Customers make sure that stories \nare meaningful by ordering them in terms of their business value. As part of the task the programmers \nprovides estimates on stories so the customer knows the cost of a particular story. These estimates are \nstated to be in ideal engineering days (i.e. days without interruptions. meetings, vacations, etc.) The \nexploration discussions for the Registration System took place over two days and did not occur in any \norder. In fact the stories were produced in a random way by discussions that led to other discussions \nand back again. This was a topic that we, as the programmers and the customer, were very familiar with; \nso much of the context of the conversations remained unspoken between us. In fact a fly on the wall would \nhave heard a group of people speaking in broken sentences, grunts and moans each finishing each others \nthought. 6.2 Release Planning A release usually takes 1-3 months. The shorter the release, the quicker \neveryone gets feedback. However, a release must also provide value to the business; and the business \nmust be able to absorb the value. In the end the customer decides how long a release will be. In the \nRegistration System the customer decided that a release would be 3 weeks. Given the amount of time in \na release (3 weeks) and the estimates from the stories we were almost ready to figure out which stories \nwere to be included in the first release. The last piece needed was how much could actually be accomplished. \nAn XP project calls this velocity. The simple rule is that you cannot commit to going faster than you \ndid in the previous release. However, we did not have any previous history. Therefore we decided to be \nconservative and say that the 2 programmers on the project could accomplish 1 ideal engineering day per \nday of calendar time. This meant that the customer could pick 15 days of stories for the first release. \nSince the total of the estimates exceeded the 15 days the customer was faced with a decision on what \nto leave in and what could wait for future releases. In order to do this the customer sorted the stories \ninto 3 piles; Immediate, Short-term wait, Long-term wait. In our case adding up all the stories in the \nImmediate and Short\u00adterm wait columns even exceeded 15 days. Therefore, in order to fit into 15 days \nthe customer had to remove a a story from the release. The customer initially asked that the release \nbe extended for the 16th day but we as a group wanted to stay true to the practices and not start extending \nimmediately. 6.3 Iteration Planning A release is broken up into a number of 1-3 week iterations, in \nthis case 1 week iterations. Once again the customer chooses the stories that will be completely implemented \nin the iteration and agrees not to change or add to them until the iteration is complete. The customer \nalso has the responsibility of specifying the completion criteria in the form of acceptance tests. These \ntests further remove any ambiguity that may be present in the stories. The programmers responsibility \nin Iteration Planning is to break down the stories into tasks and determine the order in which they are \nto be implemented. Tasks should be no longer than a day or two in duration. Once the tasks are defined \nthe programmers sign up for the individual tasks and estimate them based on their own personal experience. \nThese estimates are summed and compared to the duration of the iteration. If there is too much to do \nthe customer decides what to defer and if there is not enough, a problem that did not occur too often, \nthe customer provides additional stories. In this first iteration plan for the Registration System the \nprogrammers broke down the stories into individual tasks. They each signed up for the tasks and began \nestimating. The estimates once completed added up to 50 hours, 10 more hours than the story estimates. \nThe programmers should have immediately gone back to the customer and asked them to remove some functionality. \nHowever, they did not. Why? The programmers were concerned that the customer would not trust their story \nestimates in the future and they also did not believe in their estimate of velocity. Therefore, the programmers \nhid behind the story estimates, a mistake which they will not make in the future. 6.4 The First Iteration \nOnce the planning was completed the programmers embarked upon the implementation. The order of the stories \nwas decided and then a task was begun. Two practices that were essential to the success of the iteration \nwere Test-First Programming and Pair Programming. 6.4.1 Test-First Programming This is the act of writing \ntests before writing production code. The programmers work backwards by making assertions about what \nthe code ought to do. They wrap those assertions in executable test cases and then write the code that \npasses them. This was a remarkably different way of programming for us, and yeilded many benefits. 6.4.2 \nPair Programming All the tasks for this iteration were done in pairs. This way of programming yields \na result which is superior to one in which the individuals perform the tasks. Pair programming increases \nthe number of people that are familiar with the source code. The code itself has less bugs and it is \neasier to understand because there are 2 people reading the code at all times.  7. Conclusion The first \niteration ended up taking the 50 hours that we said it would. During the demonstration of the system \nwith the customer there was only 1 bug that was found. The customer upon seeing the actual implementation \nproceeded to create 11 additional stories. A fact not uncommon in software projects. Once the customers \nuse a piece of software the requirements change. XP with it s ability to let the customer change direction \naffords them a great deal of flexibility. 8. REFERENCES [1] A Case Study of OOD and Reuse in C++, Robert \nC. Martin, James W. Newkirk, Object Magazine, 1996, ROAD 1995.  \n\t\t\t", "proc_id": "367845", "abstract": "<p>Follow along the implementation of an actual web-based application developed using Extreme Programming (XP). The application implements the user area for a commercial web site, using Java Servlets and JDBC. This report highlights the practices of XP that worked well on the project as well as those that could be improved.</p>", "authors": [{"name": "James Newkirk", "author_profile_id": "81100431185", "affiliation": "Object Mentor, Inc., 565 Lakeview Parkway, Suite 135, Vernon Hills, IL", "person_id": "PP14152036", "email_address": "", "orcid_id": ""}, {"name": "Robert C. Martin", "author_profile_id": "81100426864", "affiliation": "Object Mentor, Inc., 565 Lakeview Parkway, Suite 135, Vernon Hills, IL", "person_id": "PP14150414", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367909", "year": "2000", "article_id": "367909", "conference": "OOPSLA", "title": "Extreme programming in practice", "url": "http://dl.acm.org/citation.cfm?id=367909"}