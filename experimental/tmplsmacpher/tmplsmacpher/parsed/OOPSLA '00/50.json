{"article_publication_date": "01-01-2000", "fulltext": "\n JML: notations and tools supporting detailed design in Java * Gary T. Leavens K. Rustan M. Leino Erik \nPoll Clyde Ruby Compaq Systems Research Bart Jacobs Iowa State University Center University of Nijmegen \nAmes, Iowa, USA Palo Alto, California, USA Nijmegen, The Netherlands {leavens,ruby}@cs.iastate.edu rustan.leino@compaq.com \n{erikpoll,bart}@cs.kun.nl ABSTRACT JML is a notation for specifying the detailed design of Java classes \nand interfaces. JML s assertions are stated using a slight extension of Java s expression syntax. This \nshould make it easy to use. Tools for JML aid in static analysis, veri.cation, and run-time debugging \nof Java code. Keywords Behavioral interface speci.cation language, detailed design notation, Java language, \nJML language, ESC/Java, LOOP. 1. INTRODUCTION JML [8, 7], which stands for Java Modeling Language, is \nuseful for specifying the detailed design of Java classes and interfaces. It can be used to specify the \ndetails of the interface and behavior of such Java modules including pre\u00adand postconditions for methods \nand class invariants. JML is a cooperative, open e.ort. The notation and tools are currently being developed \nat Compaq Systems Research Center, the University of Nijmegen, and Iowa State Uni\u00adversity. However, we \nwelcome participation by others who wish, for example, to extend it for new uses, perform case studies, \ndevelop tools, or work on semantic issues. 2. EXTENDED STATIC CHECKER At Compaq Systems Research Center, \nthe Extended Static Checker (ESC) project [9] uses a subset of JML as an anno\u00adtation language for its \nESC/Java tool. This tool can auto\u00admatically check for certain kinds of common errors in Java code, such \nas dereferencing null or indexing an array outside * The work of both Ruby and Leavens was supported \nin part by the US National Science Foundation under grant CCR\u00ad9803843. Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota \n. Copyright ACM 2000 1-58113-307-3/00/10...$5.00 its bounds. These checks are done statically and automati\u00adcally; \nthe checking is done without running the code and the user does not intervene other than to supply annotations \nin the code. ESC/Java takes the provided annotations into account to suppress spurious warning messages. \nFor example, in the following, the lightweight JML anno\u00adtation that starts with //@ contains a single \nprecondition. This precondition says that the formal parameter, descript, may not be the null reference. \n//@ requires descript != null; public String deleteAtAfterNl(String descript) { /* ... */ } The annotations \nprovided also cause ESC/Java to perform additional checks. For example, ESC/Java would warn if an actual \nparameter to the above method could be null. Thus adding JML annotations helps give better quality warnings, \nuse of ESC/Java fosters more annotations, and in turn these annotations help the tool do a better job \nof checking code for potential errors. 3. JML CHECKER At Iowa State University, tools are being developed \nthat use JML annotations in generating HTML documentation [12], and that use JML annotations for run-time \ndebugging [1]. The HTML pages generated from JML annotated speci.ca\u00adtions are similar to those produced \nby Javadoc [3]. However, the documents also contain information from JML annota\u00adtions, including method \nspeci.cations, class invariants, etc. The prototype tool that uses JML annotations for run-time debugging \ncan automatically check preconditions of meth\u00adods. It can also automatically check whether a class in\u00advariant \nholds at run-time. It does this by generating Java source code that contains the additional checks at \nthe begin\u00adning of each method body. As in Ei.el [10], this capability helps in debugging code. Unlike \nEi.el, the tool cannot yet check postconditions. However, the JML checker can han\u00addle annotations in \nJava interfaces (where no code can be directly added) and JML s model (speci.cation-only) .elds. Model \n.elds are important for the speci.cation of Java in\u00adterfaces, and also allow more complete speci.cation \nof col\u00adlection classes than is easy to do in Ei.el. Both of these tools handle JML s speci.cation inheritance \n[2]. That is, they combine speci.cations from superclasses and superinterfaces and use those to form \na complete spec\u00adi.cation of a class [13]. 4. LOOP TOOL The University of Nijmegen s LOOP tool [5] translates \nJML annotations into proof obligations. These proof obligations are used in an interactive theorem prover \n(PVS or Isabelle) to verify the correctness of a Java implementation. The translation from JML to formal \nproof obligations has re\u00adquired the Nijmegen group to formalize many details of Java and JML s semantics. \nInteractive theorem proving is labor\u00adintensive, but allows veri.cation of more complicated prop\u00aderties \nthan can be handled by static checking. The two ap\u00adproaches (static and semantic checking) are complementary. \nAs a serious case study, the Nijmegen group is applying JML and the LOOP tool to Java smart cards [11]. \nThe Java Card language is a good target for this study, because it is a simple subset of Java that does \nnot contain complex features as threads and dynamic loading. 5. THE JML NOTATION JML is also interesting \nas a speci.cation language. JML blends the Ei.el [10] and Larch [4] traditions (and oth\u00aders which space \nprecludes mentioning). Because JML sup\u00adports model (speci.cation-only) .elds in classes, speci.ca\u00adtions \ncan be more precise and complete than those typically given in Ei.el. However, because, like Ei.el, it \nuses Java s expression syntax in assertions, JML s notation is easier for programmers to learn than one \nbased on the Larch Shared Language (LSL). On the other hand, to allow speci.cations to use mathematical \ntheories like those that would be spec\u00adi.ed in LSL, JML includes several such theories, such as sets \nand sequences, but hides them behind a facade of Java classes. This allows these theories to be used \nin assertions as if they were a set of Java classes. As in the Larch family, JML method speci.cations \nhave a frame axiom (the modifiable clause), which says what .elds a method may assign to. JML also allows \nvarious forms of redundancy in method speci.cations, including the state\u00adment of properties that are \nimplied by the speci.cation and examples that illustrate how a method can be used [4, 6, 14]. These can \nbe used to call the reader s attention to various properties. A theorem prover could also use them as \nproof obligations, which could help debug the speci.cation. The examples can also be used as method test \ncases. 6. REFERENCES [1] A. Bhorkar. A run-time assertion checker for Java using JML. Technical Report \n00-08, Department of Computer Science, Iowa State University, 226 Atanaso. Hall, Ames, Iowa 50011, May \n2000. Available by anonymous ftp from ftp.cs.iastate.edu or by e-mail from almanac@cs.iastate.edu. [2] \nK. K. Dhara and G. T. Leavens. Forcing behavioral subtyping through speci.cation inheritance. In Proceedings \nof the 18th International Conference on Software Engineering, Berlin, Germany, pages 258 267. IEEE Computer \nSociety Press, Mar. 1996. [3] L. Friendly. Design of Javadoc. International Workshop on Hypermedia Design \n95, 1995. [4] J. V. Guttag, J. J. Horning, et al. Larch: Languages and Tools for Formal Speci.cation. \nSpringer-Verlag, New York, NY, 1993. [5] B. Jacobs, J. van den Berg, M. Huisman, M. van Berkum, U. Hensel, \nand H. Tews. Reasoning about Java classes (preliminary report). In OOPSLA 98 Conference Proceedings, \nvolume 33(10) of ACM SIGPLAN Notices, pages 329 340. ACM, Oct. 1998. [6] G. T. Leavens and A. L. Baker. \nEnhancing the pre\u00adand postcondition technique for more expressive speci.cations. In J. M. Wing et al., \neditors, FM 99 Formal Methods: World Congress on Formal Methods in the Development of Computing Systems, \nToulouse, France, volume 1709 of Lecture Notes in Computer Science, pages 1087 1106. Springer-Verlag, \n1999. [7] G. T. Leavens, A. L. Baker, and C. Ruby. JML: A notation for detailed design. In H. Kilov, \nB. Rumpe, and I. Simmonds, editors, Behavioral Speci.cations of Businesses and Systems, pages 175 188. \nKluwer Academic Publishers, Boston, 1999. [8] G. T. Leavens, A. L. Baker, and C. Ruby. Preliminary design \nof JML: A behavioral interface speci.cation language for Java. Technical Report 98-06i, Iowa State University, \nDepartment of Computer Science, Feb. 2000. See www.cs.iastate.edu/~leavens/JML.html. [9] K. R. M. Leino \net al. Extended static checking. At http://research.compaq.com/SRC/esc/Esc.html, 2000. [10] B. Meyer. \nObject-oriented Software Construction. Prentice Hall, New York, NY, second edition, 1997. [11] E. Poll, \nJ. van den Berg, and B. Jacobs. Speci.cation of the JavaCard API in JML. In Fourth Smart Card Research \nand Advanced Application Confernce (CARDIS). Kluwer Academic Publishers, 2000. [12] A. D. Raghavan. Design \nof a JML documentation generator. Technical Report 00-12, Iowa State University, Department of Computer \nScience, July 2000. [13] A. D. Raghavan and G. T. Leavens. Desugaring JML method speci.cations. Technical \nReport 00-03a, Iowa State University, Department of Computer Science, July 2000. [14] Y. M. Tan. Formal \nSpeci.cation Techniques for Engineering Modular C Programs, volume 1 of Kluwer International Series in \nSoftware Engineering. Kluwer Academic Publishers, Boston, 1995.  \n\t\t\t", "proc_id": "367845", "abstract": "<p>JML is a notation for specifying the detailed design of Java classes and interfaces. JML's assertions are stated using a slight extension of Java's expression syntax. This should make it easy to use. Tools for JML aid in static analysis, verification, and run-time debugging of Java code.</p>", "authors": [{"name": "Gary T. Leavens", "author_profile_id": "81452614743", "affiliation": "Iowa State University, Ames, Iowa", "person_id": "P94154", "email_address": "", "orcid_id": ""}, {"name": "Clyde Ruby", "author_profile_id": "81332524801", "affiliation": "Iowa State University, Ames, Iowa", "person_id": "PP35046128", "email_address": "", "orcid_id": ""}, {"name": "K. Rustan M. Leino", "author_profile_id": "81100225265", "affiliation": "Compaq Systems Research, Center, Palo Alto, California", "person_id": "PP31094946", "email_address": "", "orcid_id": ""}, {"name": "Erik Poll", "author_profile_id": "81460642572", "affiliation": "University of Nijmegen, Nijmegen, The Netherlands", "person_id": "P4256684", "email_address": "", "orcid_id": ""}, {"name": "Bart Jacobs", "author_profile_id": "81100093342", "affiliation": "University of Nijmegen, Nijmegen, The Netherlands", "person_id": "PP126029006", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367996", "year": "2000", "article_id": "367996", "conference": "OOPSLA", "title": "JML (poster session): notations and tools supporting detailed design in Java", "url": "http://dl.acm.org/citation.cfm?id=367996"}