{"article_publication_date": "01-01-2000", "fulltext": "\n R-RIO: Reflective-Reconfigurable Interconnectable Objects Alexandre Sztajnberg DICC/IME/UERJ Rio de \nJaneiro, RJ, Brazil alexszt@uerj.br ABSTRACT Separation of concerns is a key goal in achieving software \nreusability. Meta-Level Programming approaches pave the way to separation of concerns by handling functional \nand non-functional aspects in different levels, but provide little help for software composition, verification \nand evolution activities. Approaches based on Software Architecture Description Languages can overcome \nthese deficiencies and additionally may discipline, and make explicit, the deployment of meta-level programming. \nR-RIO combines both approaches providing a useful framework to develop, implement and maintain applications. \n1 Introduction Modern computer applications must be developed rapidly in order to meet market demands. \nVariants of a basic functional system have to be delivered in a short time, and comply with specific \nfunctional and non-functional requirements. Successful software development for those applications would \nbenefit from some common guide-lines: modularity is a prime to collect a functional component set and \nselectively add to it non-functional features, modularity will help reusability if carefully applied; \n components can be independently designed, may be implemented using different programming languages, \nand run on different operating platforms;  applications may have to change their component makeup during \ntheirs life-cycle; software architectures have to be flexible to evolve dynamically;  verification of \nformal properties should assure the quality of the delivered software.  In this context, methodologies, \ndevelopment systems and supporting environments that can integrate these guide-lines into systematic \nsoftware-engineering practice, are necessary. Compositional development and separation of concerns, with \nwhich different requirements can be tackled separately are key concepts to attain this goal. Meta-Level \nProgramming (MLP) approaches allow arranging software elements in different levels of concerns. Using \nreflection-like techniques, the designer can isolate non-functional requirement code in a meta-level \nand have the base level Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advantage and that copies bear this notice and the full citation on the first page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission \nand/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota &#38;#169; Copyright ACM 2000 1-58113-307-3/00/10...$5.00 \n Orlando Loques CAA/IC/UFF Niter\u00f3i, RJ, Brazil loques@ic.uff.br computation reified to that meta-level \nwhenever necessary. However, MLP is usually associated with specific object-oriented languages, were \ncomposition is achieved using inheritance mechanisms, that hide the actual structure of the software \ninside the objects. The resulting software structure opacity makes verification and dynamic evolution \nactivities fairly difficult. Component-Based (CB) approaches allow composing applications from heterogeneously-built \ncomponents, providing reusability and interoperability. Some CB development environments provide mechanisms \nfor non-functional requirement programming (e.g., CORBA interceptors), but they lack adequate concepts \nand mechanisms to describe, configure (non-functional aspects included), and perform formal verification \nof applications in a systematic way. 2 Project Goal Our goal is to demonstrate that the combination \nof the abstraction, configuration description, and analysis capabilities of Software Architecture/Configuration \nProgramming (SA/CP) approaches, and the reification flexibility provided by MLP (including its intrinsic \nseparation of concerns support capability) can provide a sound framework to develop the intended class \nof applications. SA/CP goes some steps further from CB, allowing the description of software systems \nin an abstract level, and explicitly separating concerns regarding functional components from their interaction \nschemes. This makes it easier for the designer to understand the system overall architecture and to configure \napplications to fulfill specific non-functional requirements. SA/CP are described with Architecture Description \nLanguages (ADL), which are suitable for property and architectural conformance checking due to the explicit \nmodule composition exposition. This also helps achieving a natural mapping from the described SA to the \nactual system software structure, and can in a later stage facilitate dynamic reconfiguration activities. \nMLP techniques, such as reflection, by their turn, allow us to design applications in separate levels: \na base level, were basic functional computation is performed and a meta-level, were non\u00adfunctional (including \noperational) computation can be handled. In addition to encapsulating non-functional concerns in a meta-level, \nreflection allows applications to reason about themselves and possibly make adaptations in their software \ncomposition, e.g., in order to adapt to operational status changes. Despite of presenting some appropriate \nfeatures for application development, when taken separately, the use of SA/CP and MLP have some drawbacks. \nMLP tools and reflection run-time support environments do not provide direct support for reconfigurations \nactivities. In this case, reconfigurations are usually programmed in ad-hoc manner and rely mostly on \nthe programmer s skills, hindering reuse. Property verification is also more difficult because the software \nstructure is not exposed. The explicit description of non-functional aspects in SA/CP proposals is not \na common practice. Most contemporary proposals only consider specific non-functional aspects, such as \nremote communication. Combining MLP and SA/CP, by handling component interconnection and interaction \n(non-functional) concerns in a meta-level can provide a framework that encompasses the advantages of \nboth approaches. In this way, SA/CP can discipline the use of reflection by providing a simple mechanism \nto reify interactions. In addition, dynamic changes in the application, triggered from a meta-level, \ncan now be handled in a systematic way. 3 R-RIO R-RIO (Reflective-Reconfigurable Interconnectable Objects) \nintegrates in single framework key concepts of Software Architecture / Architecture Description Languages \n(SA/ADL) and Meta-Level (MLP) Programming approaches [1]. This integration helps to achieve separation \nof concerns and improve software reuse. In addition, the capability of supporting dynamic configuration \nand flexibility on component programming language choice are potentially improved. In the following, \nthe main elements of R-RIO are presented. A component model based on the concepts of SA/CP: (a) modules, \napplication components that basically encapsulate functional concerns; (b) connectors, used at the architecture \nlevel to define module s interaction relationships. At the operating level, connectors encapsulate, mediate \nand handle module interaction-domain concerns; (c) ports, identify access points (through which modules \nand connectors provide or require services) and are also used to link explicitly modules and connectors. \n A software development methodology that stimulates the designers to comply with a simple meta-level \nprogramming discipline, were functional concerns are concentrated in the modules (base level) and non-functional \nconcerns are encapsulated in connectors (meta-level) [2].  A configuration model that allows for the \ndynamic creation, connection, deletion and reconfiguration of components of an application architecture. \n CBabel, an ADL used to describe: (i) application's components and interaction structure; (ii) contracts \nspecifying non-functional concerns (such as coordination, distribution, QoS, and special interaction \npatterns); and (iii) planned reconfigurations.  A reflective middleware that provides configuration \nmanagement and executive services, used to make and control running images from a software architecture. \nThrough architecture-level reflection, an application can collect meta-level information, kept by the \nmiddleware, and reason about its own architecture in order to perform reconfigurations [2]. This middleware \nalso facilitates implementing dynamic adaptation and software evolution activities.  The mapping of \nmodules, ports and connectors to an implementation depends on the particular environment. In our prototype \nenvironment, primitive module types are defined by Java classes, and composite modules can be composed \nby arbitrary configurations of primitive modules (it is also possible to compose modules using Java's \ninheritance features, but this would imply in loosing the capability of reconfiguring the individual \ncomposing modules). Ports are associated to Java methods declarations (signatures) at the configuration \nlevel and to method invocations at the code level. It is important to note that only the methods explicitly \nassociated with ports are configurable through connectors and directly visible at the configuration level; \nthe remaining methods use normal Java referencing and binding mechanisms. Connectors types are currently \ndefined and composed as modules, but they have a special implementation and are specially treated by \nthe configuration management. Module and connector types (mapped to Java classes) are associated to module \nand connector instances through R-RIO s ADL declarations. At configuration time, module and connector \ninstances are created as Java objects. 4 Conclusions The R-RIO s component and configuration models \nare quite stable. We also developed a prototype for the reflective middleware. One of its features, that \nimproves the flexibility of our approach, is the support of context-reflective adaptation, i.e., generic \nconnectors, encapsulating specific concern-related code and off-the-shelf communication mechanisms, can \nbe automatically and dynamically adapted to any component interface signature [1]. A prototype GUI to \naccess the R-RIO s features was also developed. With the GUI, one can graphically design and run software \narchitectures. We are validating our research in two ways: (i) developing examples upon a prototype of \nthe reflective middleware, and (ii) showing that CBabel descriptions are suitable to formal proofing \nof properties. Currently, we are working on CBabel s QoS contracts. The idea is to have an open mechanism \nto allow the addition of QoS aspects and also define their implementation mapping on the R-RIO's configuration \nmodel [3]. Examples with QoS aspects are under development. A preliminary version of R-RIO is available \nfor research use; see http://www.ic.uff.br/~rrio for details.  Acknowledgments This work has been partially \nsupported by the following Brazilian research funding agencies CNPq, CAPES, Finep and Faperj. References \n[1] Loques, O., Sztajnberg, A., Leite, J. and Lobosco, M., \"On the Integration of Meta-Level Programming \nand Configuration Programming\", In Reflection and Software Engineering, Lecture Notes in Computer Science, \nV. 1826, pp.191-210, Springer-Verlag, June, 2000. [2] Sztajnberg, A. and Loques, O., \"Reflection in the \nR-RIO Environment\", In Proceedings of the Middleware 2000 Workshop on Reflective Middleware, Palisades, \nNY, EUA, April, 2000. [3] Sztajnberg, A. and Loques, O., \"Bringing QoS to the Architectural Level\", accepted \nfor presentation, ECOOP 2000 Workshop on QoS on Distributed Object Systems, Cannes, France, June, 2000. \n \n\t\t\t", "proc_id": "367845", "abstract": "<p>Separation of concerns is a key goal in achieving software reusability. Meta-Level Programming approaches pave the way to separation of concerns by handling functional and non-functional aspects in different levels, but provide little help for software composition, verification and evolution activities. Approaches based on Software Architecture Description Languages can overcome these deficiencies and additionally may discipline, and make explicit, the deployment of meta-level programming. R-RIO combines both approaches providing a useful framework to develop, implement and maintain applications.</p>", "authors": [{"name": "Alexandre Sztajnberg", "author_profile_id": "81100420925", "affiliation": "DICC/IME/UERJ, Rio de Janeiro, RJ, Brazil", "person_id": "P14471", "email_address": "", "orcid_id": ""}, {"name": "Orlando Loques", "author_profile_id": "81100559677", "affiliation": "CAA/IC/UFF, Niter&#243;i, RJ, Brazil", "person_id": "P212281", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367960", "year": "2000", "article_id": "367960", "conference": "OOPSLA", "title": "R-Rio (poster session): reflective-reconfigurable interconnectable objects", "url": "http://dl.acm.org/citation.cfm?id=367960"}