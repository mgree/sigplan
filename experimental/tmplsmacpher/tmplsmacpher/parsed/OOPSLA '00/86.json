{"article_publication_date": "01-01-2000", "fulltext": "\n Customer Context Server TM Application Enabling Customer-focused E-Commerce Bert Barabas miosoft Corporation \nbert@miosoft.com Abstract Fragmentation of customer data across internal product based systems is preventing \na meaningful customer dialog across channels. This problem is compounded further by the addition of new \nIntemet and customer-facing applications from multiple vendors. The typical clicks and mortar company \nhas dozens of e-commerce and product-based systems containing millions of records with customer information \nwithout the ability to consolidate the data into a common customer view. Maintaining profitable customer \nrelationships in such an environment requires a new approach. The Customer Context Server application \nuses a set of frameworks and subsystems operating on an object database to assemble and deliver, within \na second, a continuously updated Customer Context to all customer touchpoints even in extremely high \nvolume situations. The Customer Context Server application enables customer conversations to continue \nwhere they letI off in a multi-vendor environment. The heart of the Customer Context Server application \nis the scalable Update Stream Processor i (USP), which performs asynchronous contention-free updates \non hundreds of processors concurrently. Several of the subsystems will be demonstrated including the \nactive modeling and mapping systems used to refine the customer-relationship object model and assemble \nobjects from record-based input data. 1 Ambiguous Customer Data The typical environment for the Customer \nContext Server application includes customer data for which there is no single reliable identifier for \nall the data for one customer across or even within existing systems. The only means for determining \nif two customer records belong to the same person is to perform a matching algorithm where fields such \nas name, address, birth date, account number etc., are compared between records to see if they likely \nbelong to the same person. Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \nprofit or commercial advantage and that copies bear this notice and the full citation on the first page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific \npermission and/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota &#38;#169; Copyright ACM 2000 1-58113-307-3/00/10...$5.00 \n  Mark van Gulik miosoft Corporation mark@miosoft.com To present the best overview of a customer, the \nattributes from a11 matched records axe merged using a form of selection rules that pick the best values \nfrom the source information. 2 Caching Customer Contexts The prevalent method among vendors today for \nintegrating data from disparate systems in real-time involves dynamic searches on an as needed basis. \nWhile this has the advantage of avoiding data replication, there are four main reasons why a design that \ncaches customer information was chosen for the Customer Context Server application. o Maintaining Customer \nIdentity in the presence of ambiguous customer data on a massive scale requires sophisticated data structures \nin a parallel processing environment. Running the match and merge algorithms across dozens of different \nlegacy and customer-facing systems is not feasible. o Signals indicating changes to customer data can \nbe generated out of sequence due to the intricacies of legacy systems. (For example, a shipping notice \ncould be sent before the order confirmation). Without caching, these signals cannot be attributed to \nthe same event (the order). o Legacy systems have not been designed for the performance requirements \nof e-commerce and cannot handle the real-time requests generated by millions of customers simultaneously \nvisiting a website. Relevant customer data (i.e. the customer context) needs to be cached. o To keep \na customer conversation flowing across channels or touchpoints supported by different vendors, some status \nor context information about an ongoing conversation needs to be stored. The customer cache is the ideal \nplace for that since the customer data model can easily be extended.  3 Customer Context CachJ M Database \nThe Customer Context Server application employs a Customer Context Cache Database built on an Object \nDatabase System (ODS) to enable the straightforward implementation of complex customer models. Additionally \nthe choice of ODS was influenced by the extensive number of to-many relationships that required an explicit \ninstance level clustering facility to enable the quick retrieval of the large set of objects related \nto a customer. Fast retrieval of all of a customer's information is required to display a detailed profile \nto a large volume of interactive web users and the personalization processes that operate on additional \nhistorical data that may not be required for display. 4 Performance Goals wi~i:n a second. TeAs ensnares \nweb surf?rs won\"t click aw<ay wN.le waiting for a response. Fo: up~tes we require tha~t an acknowled~en~ \nbe returned ~vi~.hia a second ~hat g~mvxnr~ees ~.ihe update will be a~aitable to the system a~ large \nwi~Nn a minute. This allows Gne user to imraedia~ely and confidently move on to his nex~ mk and make \nthe change effective in a re~onable time. ~e clus~efJr~g of person inforrc~afion discussed gbove combined \nwith contentions-free reads pro,Aded by ~e ODS ~ a mNti- processor sfi~em easily enables tlne re~ of \na context in the allmted time because nil required ~m is located ~,dthin one or ~wo disk pages. The C~s~omer \nComsrt :Se~..,erapplication's Up.re Stream Prcx:essof (USP) is re@onsible ~hr accepting update requests, \naIIocadng them to processors, N~r~rfing that their execution will take place even in the event of system \nf~ilure and processing ~he updates in parailel '<thorn contenfioo. To quickly N~ntcm ~at an Update will \ntake place, an update job is irrunaediately persisted. Jobs are deleted in the same transaction that \nthey are exeoated in, rand restm~ logic exists to deterrrfine which jobs ~ed m be re-executed in the \nevent of rystem failure. To handle Ne volurne of uty3ates, the USP distributes the update .jobs aumong \nin such a way that no job executing on one pr~vegsor for the ~me datffbase resources as a job running \non another processor.  5 The QuickDeploy h~terface TM Screens A high-level GUI has been created ~br \neach of the Customer Context Ser~,er application's inte#Nce ~nts. An oNect-modeling tool ~dlows an a&#38;ministrator \nto refine a terKDlate customer model or define a new one from scraJ.ch, The modeling tool uses ~L tNe \nswnbols but incIudes extensions for pardtic~ni~ag caching information across relafionsN N, and indexing \nobjects. It also scales for larger systems by providing versioning reasonable aut~xnafic placement, filtering \n~ransparen~i, and other features. Patent pending \"tCne mapping toot allows r sa~.~ t~rmats to be mapped \nto the newly defined object model The tooI includes visual Nerarchic~A decorrgxosifion of a %rraat into \nfields where sample da~a can be \",dewed as the fhm~at is being defined. Fields from the format are then \nassociated to atmbutes in the object model~ A ~m source is defined in the C~L~tomer Context Sere, or \nqvplicafion and associated to a pre~dously created record/message ~bm~at. The Customer Cbntext Sere,or \napplication is capable of computing what changes occwcred in a data source if tlhe data source is only \ncapable of dumping its entire contents and is not capable of genenmng new, update, and delete events, \nRules for the match process are defined imeractively by navigating over the c-current oNect model and \nassociating comparison functions to classes defined by the object-modeling tool Because they are associated \nm the classes in the object rncxtel, the rules are const~mt over all data sotkrces and fhmmts. 6 Migration \n'To avoid the high cos~ of implementing changes in traditional systems, the Custome~~ Comext Sen'or application \nautomatically migates formats ~d mappin~ to best-fit changes m the active object model Then the interactive \ntools can be used to map to elements that are new to the object model or to change mappings m meet cypher \nse:maaatic c~ges. 7 Conclusion Companies' inability to s'~chroni~ customer inforraafion across disparate \nsystems has prevented them from fully realizing the promAsed benefits of CRM and e-core~merce~ ~e companies \nhave beech thwarted in their efforts due to the complexity of consolidating ambiguous data from multiple \n~.aems in an extremely hid volume environment, ]\"he Customer Context Server application enables this \ns;mchxonizafion by allowing companies to specify their customer model and legacy systems to the Customer \nContext Server application and then operating on the infbrmation in a parallel compmatior~al environment~ \n  \n\t\t\t", "proc_id": "367845", "abstract": "<p>Fragmentation of customer data across internal product based systems is preventing a meaningful customer dialog across channels. This problem is compounded further by the addition of new Internet and customer-facing applications from multiple vendors.</p><p>The typical clicks and mortar company has dozens of e-commerce and product-based systems containing millions of records with customer information without the ability to consolidate the data into a common customer view. Maintaining profitable customer relationships in such an environment requires a new approach.</p><p>The <i>Customer Context Server</i> application uses a set of frameworks and subsystems operating on an object database to assemble and deliver, within a second, a continuously updated Customer Context to all customer touchpoints even in extremely high volume situations.</p><p>The <i>Customer Context Server</i> application enables customer conversations to continue where they left off in a multi-vendor environment. The heart of the <i>Customer Context Server</i> application is the scalable Update Stream Processor<sup>i</sup> (USP), which performs asynchronous contention-free updates on hundreds of processors concurrently. Several of the subsystems will be demonstrated including the active modeling and mapping systems used to refine the customer-relationship object mode] and assemble objects from record-based input data.</p>", "authors": [{"name": "Bert Barabas", "author_profile_id": "81100659664", "affiliation": "Microsoft Corporation", "person_id": "P29774", "email_address": "", "orcid_id": ""}, {"name": "Mark van Gulik", "author_profile_id": "81100185551", "affiliation": "Microsoft Corporation", "person_id": "P191366", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.368092", "year": "2000", "article_id": "368092", "conference": "OOPSLA", "title": "Customer context server application enabling customer-focused e-commerce", "url": "http://dl.acm.org/citation.cfm?id=368092"}