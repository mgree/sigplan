{"article_publication_date": "01-01-2000", "fulltext": "\n On the Predictability of Java Byte Codes (abstract) Karel Driesen, Patrick Lam, Jerome Miecznikowski, \nFeng Qian, Derek Rayside. School of Computer Science, McGill University Montreal, Quebec, Canada www.cs.mcgill.ca/acl \nkarel@cs.mcgill.ca Abstract Java byte codes are platform-independent. That means that any characterization \nof Java applications at the byte code execution level will reveal characteristics that any Java Virtual \nMachine will have to deal with, no matter whether this JVM is a Just-In-Time native code optimizing compiler \nrunning on a state-of-the-art high-performance worksta\u00adtion, or a byte code interpreter running in a \nwatch. We believe that predictability profiles are particularly well\u00adsuited to capture and visualize \nprogram behavior, at a vari\u00adable level of detail, as required by a systems architect inter\u00adested in control \nflow, data flow, or automatic memory man\u00adagment. We present predictability profiles for 6 SPECJVM98 pro\u00adgrams, \nfor three byte code sub traces. Subtrace: Invoke (polymorphic call target prediction) Load (load effective \naddress prediction) New (new effective type prediction) For example, for Invoke byte codes, we measured \nthe pre\u00addiction rate achieved by invoke target predictors within every 20000 bytecodes of the first 2 \nmillion bytecodes exe\u00adcuted using an unlimited, fully accurate BTB, and of Two\u00adlevel predictors of path \nlengths 1,2,4,8, and 16. Prediction profiles for all these predictors are generally close together, but \nusually a BTB performs best in variable program phases. Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota (c) \nCopyright ACM 2000 1-58113-307-3/00/10...$5.00   1. Methodology The data in this study was collected \nin an graduate course on adaptivity in computational systems at McGill. We customized the Kaffe virtual \nmachine, version 1.0.5. to produce trace .les for the .rst 2M byte codes of the SPECJVM98 benchmarks \nshown in Table 1: Name Description  compress Lempel-Ziv compression 123 462 8575 db Data base 128 508 \n8991 jack Java parser generator 104 361 8996 javac Java compiler 198 791 13334 mtrt Multi-thread ray \ntracing 413 841 10040 raytrace Single-thread ray tracing 145 528 9819 Table 1. The number of different \nclasses, methods and byte codes touched in the .rst 2M of six SPECJVM98 benchmarks  Invoke target prediction \nrates on traces were measured using the Plumber 2.3 framework developed in the Adaptive Computation Lab \nat McGill (www.cs.mcgill.ca/acl).  2. Predictor pro.les Figure 1 shows most of the poster data, greatly \nreduced in size, which highlights the common characteristics of these benchmarks in the startup phase \nbetween 0 and ~350K byte codes, across the three different sub traces measured. De.nitions in Figure \n1: Y-axis: always goes from 0% 100% X-axis: always goes from 0 to 2,000,000 total byte codes executed, \nin chunks of 20,000. The poster will include some panels which explain the prediction techniques and \nwill also show the dynamic foot\u00adprints of methods called (hot spot), addresses loaded (data cache footprint), \nand new object types constructed. InvokeTarget Load address New type (no pc) COMPRESS COMPRESS load address \nprediction profile for EA...EAt-1PC->EA (p=0,1,2,4,8,16) new type prediction profile for ET...ETt-1->ET \n(p=0,1,2,4,8,16) t-ptt COMPRESS invoke target prediction profile for EA...EAt-1.PC->EA (p=0,1,2,4,8,16) \nt-ptt t-pt @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 100% 100% @@@@ @ @@ @ 100% @@ @ @@@@ @ @ 0 0 @ @@ @@@@@@@@@@@@@ \n0 @@@@ @@@@ @@@ 11 @@ @ 90% 90% @ @ 1 @ 90% 2 2 @ @@ @@@ @@@ 2 @ @@@ @ 4 80% 480% 80%4 @ 8 8 8 70% \n@ 16 70% @ 16 @ @ 1670% @ @@ @@ @@ @ Compress @ @@@@@ @ 60% 60% @@@ @ 60% @ @ @@@ @@ @ @ @@ @@@@ \n@ @@ @@@ @@@ @ 50% @@@ @ 50% @ @@ @ 50% @ @@@ @ @ @ @@ @@@ 40%40% @ @ 40% 30% 30% @ @ @@ @@ 30% \n@ @ 20%20% @@ @ @ 20% @@ @ 10% 10% @ 10% @ @@ @@ @@@ @ @@@@@ @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n 0% 0% 0% @@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 200000 400000 600000 800000 100000012000001400000160000018000002000000 \n200000 400000 600000 800000 100000012000001400000160000018000002000000 200000 400000 600000 800000 100000012000001400000160000018000002000000 \nBytecodes executed since start of program Bytecodes executed since start of program Bytecodes executed \nsince start of program DB DB load address prediction profile for EA...EAPC->EA (p=0,1,2,4,8,16) new \ntype prediction profile for ET...ET->ET (p=0,1,2,4,8,16) t-pt-1tt DB invoke target prediction profile \nfor EA...EA.PC->EA (p=0,1,2,4,8,16) t-pt-1tt t-pt-1t 100% 100% @@@@@@ 100% @@ @@ @@ @ @@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n0 0 @ @ @@ @ 0 @@ 11 @@ 90% 90% @ 1 @@ 90% 2 2 @@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n@@ 2 @ 4 80% @ 480% 80% @ 4 @ @ 8 8 @@ 8 @ @ @ 1670% @ 16 70% @ @ @ 16 Db 70% @@ @ @ 60% @@@@@ @ \n@ 60% @ 60% @ @@ @@ @ @ @ 50% 50% @ 50% @ @ @ @ @ 40%40% @ @ @ 40% @ 30% @ 30% @ @ 30% @ @@ @@ \n20%20% @@ @ 20% @ @ @ @@ 10% 10% @ 10% @ @@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n@@@@@@ @@@@ @@@ @ 0% 0% @@ 0% @@ 200000 400000 600000 800000 100000012000001400000160000018000002000000 \n200000 400000 600000 800000 100000012000001400000160000018000002000000 200000 400000 600000 800000 100000012000001400000160000018000002000000 \nBytecodes executed since start of program Bytecodes executed since start of programBytecodes executed \nsince start of program JACK JACK load address prediction profile for EA...EAPC->EA (p=0,1,2,4,8,16) \nnew type prediction profile for ET...ET->ET (p=0,1,2,4,8,16) t-1t JACK invoke target prediction profile \nfor EA...EA.PC->EA (p=0,1,2,4,8,16) t-pt-1tt t-pt-1t t-pt100% 100% @@@@@@@ @ 100% @ @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n0 0 @ 0 @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@ @ @@@@ @@ 11 \n@ @ 90% 90%1 @ 90% @@@@@@@@@@@@@ @@@@@@@@@@@@@ @@@@@@@@ @@@@@@@ @@@@@@ @@@@@ @@@@@ @@@@@@@@@@@@@@@ \n@ @@ 2 2 @@@ @ 2 @ 4 80% 4 @ 80% 80%4 @ @ 8 8 @ @ 8 @ @@@@@ @ @ 16 70% 70% @ 16 70% @ @ @ @ 16 @@ \n60% 60% @ 60%  Jack @ @ 50% 50% 50% @ @ @@ @ 40%40% 40% @ @ 30% 30% @ @ 30% @ @ @@ @@ 20%20% \n 20% @ 10% 10% @ 10% 0% 0% @@ @ 0% 200000 400000 600000 800000 100000012000001400000160000018000002000000 \n200000 400000 600000 800000 100000012000001400000160000018000002000000 200000 400000 600000 800000 100000012000001400000160000018000002000000 \nBytecodes executed since start of program Bytecodes executed since start of programBytecodes executed \nsince start of program JAVAC JAVAC load address prediction profile for EA...EAt-1PC->EA (p=0,1,2,4,8,16) \nnew type prediction profile for ET...ETt-1->ET (p=0,1,2,4,8,16) JAVAC invoke target prediction profile \nfor EAt-p...EAt-1.PCt->EA (p=0,1,2,4,8,16) t-ptt t-pt t 100% 100% @@@@@@ 0 0100% @ @@@@@@@@@@@@@@@@ \n@ @@@@@ @ @@@@ @@@@@@ @@ @@@@ @@@@@@ @ @ @@ 0 @ @ @@ @@ @@@ @@ @ @@ 1 @ 1 @ 90% 90% @ @ @ @ 1 @ @ \n@@ @@@ 90% @ @ @@ @@ 2 2 @ @@ @ @ @ @@@ 2 @ @ @@ @@ @ @ @ 4 80% 4 80%80% @ @@@@ @@ 4 @ @ @@ @ \n@ @@ 8 8 @ @ @@ @@ 8 @ @@ @@ @ 16 @ 16 @ 70% @ 16 70% @ @ @ 70% @ @ @@ @@@@ @ @@ @ 60%60% @ @@@ @ \n60% @@ @ @ @ Javac @ @ @@ @ @ @@ 50%50% @ 50% @@ @ @ @@@@@ @@@@@@@@@@@ @@@@ @@@ @@ @@ @@ @@@ @ 40% \n@ 40% @ @@@@ 40% @@ @@ @ @@@ @ @ @ @ 30% 30% @ @ @@ 30% @ @@ @ @@@@ 20%20% @@@ 20% @@ @@ @@ @@ 10%10% \n @@ @ @ 10% @@ 0% 0% @@ @@ @@@ @ @@@@@@ @ @@@@@@@@@ @@@@@@@@@@@@@@@@ @@@@@@ 0% @@ 200000 400000 600000 \n800000 100000012000001400000160000018000002000000 200000 400000 600000 800000 100000012000001400000160000018000002000000 \n200000 400000 600000 800000 100000012000001400000160000018000002000000 Bytecodes executed since start \nof program Bytecodes executed since start of program Bytecodes executed since start of program MTRT \nMTRT load address prediction profile for EA...EAPC->EA (p=0,1,2,4,8,16) new type prediction profile for \nET...ET->ET (p=0,1,2,4,8,16) t-1t MTRT invoke target prediction profile for EA...EA.PC->EA (p=0,1,2,4,8,16) \nt-pt-1tt t-pt-1t t-pt100% 100% @@@@ @@ 100% @@ @ @@ @@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n0 0 @ @ @ @@@ @ 0 @@@ @@@ @@@ 11 @ 90% @ @ @ 90%1 @ 90% @ 2 2 @ @ @@@@ 2 @ 4 80% 4 @ 80% 80%4 @ @ \n8 8 @ 8 @ 16 70% 70% @ 16 70% @ 16 @ @ @ @@@ @ @@ 60% 60% @@@ @@ @ @ @ 50% 50% Mtrt 60% @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n50% @@ @@ @ @ @@ @ 40% 40% @ @ 40% @ @ @@ @@ @ @ @@@@ 30% 30% @ @ @ @ @ @ @ @@ @ @ @ @@ 30% @@ @@@ \n@@@@ @@@@@@@@@@ @@ @ @@ @ 20%20% 20% @@ @ @ @ @ 10% 10% 10% @@@@@@@ @@ @ 0% 0% @@ @@@@@@ @@ @ @@@@@@ \n@ @@@@@@@@@@@@@@@ 0% @@ 200000 400000 600000 800000 100000012000001400000160000018000002000000 200000 \n400000 600000 800000 100000012000001400000160000018000002000000 200000 400000 600000 800000 100000012000001400000160000018000002000000 \nBytecodes executed since start of program Bytecodes executed since start of program Bytecodes executed \nsince start of program RAYTRACE RAYTRACE load address prediction profile for EA...EAt-1PC->EA (p=0,1,2,4,8,16) \nnew type prediction profile for ET...ETt-1->ET (p=0,1,2,4,8,16) t-ptt RAYTRACE invoke target prediction \nprofile for EA...EAt-1.PC->EA (p=0,1,2,4,8,16) t-ptt t-pt 100% 100% @@@@@ 100% @@ @ @@ @@@ @@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n0 0 @@@@ @ 0 @@ @@@ @@@ @@ 1 @@ 190% 90% @@ @ @ 1 @ 90% @ 2 2 @ @@@ @ 2 4 80% @ @ 4 @@ 80% 80%4 @ \n8 8 @ 8 70% @ 16 70% @ 16 @ 1670% @ @@ @@@@ @ @@ @ @ 60% 60% @ 60% @ @ @ @ @ @@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n50% 50% @@@@@@@@@@@@@@ @@@@@@@@@@@@@ @ 50% @ @ @@  Raytrace @ @ @@@@ @ 40%40% @ 40% @ @ @@ @ @ @ @ \n @ @@@@ 30% 30% @ @ @ @ @ @@ @@ @@ @ @ @ @ @ 30% @ @@@@@@@@@@@@ @ @@ @ @@ @@ @ 20%20% 20% @ @ @@@ \n@ @ 10% 10% 10% @@@@@@ @ @@ @ @@ @@ @@@@@@ @@ @ @@@@@@ @ @@@ @ @@@@@@@@@ 0% 0% 0% @@ 200000 400000 \n600000 800000 100000012000001400000160000018000002000000 200000 400000 600000 800000 100000012000001400000160000018000002000000 \n200000 400000 600000 800000 100000012000001400000160000018000002000000 Bytecodes executed since start \nof program Bytecodes executed since start of program Bytecodes executed since start of program Figure \n1. Prediction pro.les for .rst 2M byte codes of 6 SPECJVM98 benchmarks: invoke, load and new byte codes. \nextract from OOPSLA 2000 poster On the Predictability of Java Byte Codes Karel Driesen, Patrick Lam, \nJerome Miecznikowski, Feng Qian, Derek Rayside.  \n\t\t\t", "proc_id": "367845", "abstract": "<p><i>Java byte codes are platform-independent. That means that any characterization of Java applications at the byte code execution level will reveal characteristics that any Java Virtual Machine will have to deal with, no matter whether this JVM is a Just-In-Time native code optimizing compiler running on a state-of-the-art high-performance workstation, or a byte code interpreter running in a watch.</i></p><p><i>We believe that predictability profiles are particularly well-suited to capture and visualize program behavior, at a variable level of detail, as required by a systems architect interested in control flow, data flow, or automatic memory managment.</i></p><p><i>We present predictability profiles for 6 SPECJVM98 programs, for three byte code sub traces.</i></p><p><i>Subtrace</i>:</p><p><i>Invoke (polymorphic call target prediction)</i></p><p><i>Load (load effective address prediction)</i></p><p><i>New (new effective type prediction)</i></p><p><i>For example, for Invoke byte codes, we measured the prediction rate achieved by invoke target predictors within every 20000 bytecodes of the first 2 million bytecodes executed using an unlimited, fully accurate BTB, and of Two-level predictors of path lengths 1,2,4,8, and 16. Prediction profiles for all these predictors are generally close together, but usually a BTB performs best in variable program phases.</i></p>", "authors": [{"name": "Karel Driesen", "author_profile_id": "81317492564", "affiliation": "School of Computer Science, McGill University, Montreal, Quebec, Canada", "person_id": "PP309870700", "email_address": "", "orcid_id": ""}, {"name": "Patrick Lam", "author_profile_id": "81100237205", "affiliation": "School of Computer Science, McGill University, Montreal, Quebec, Canada", "person_id": "PP31033410", "email_address": "", "orcid_id": ""}, {"name": "Jerome Miecznikowski", "author_profile_id": "81100552078", "affiliation": "School of Computer Science, McGill University, Montreal, Quebec, Canada", "person_id": "P138905", "email_address": "", "orcid_id": ""}, {"name": "Feng Qian", "author_profile_id": "81100414440", "affiliation": "School of Computer Science, McGill University, Montreal, Quebec, Canada", "person_id": "PP43132660", "email_address": "", "orcid_id": ""}, {"name": "Derek Rayside", "author_profile_id": "81100031447", "affiliation": "School of Computer Science, McGill University, Montreal, Quebec, Canada", "person_id": "P66128", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.368026", "year": "2000", "article_id": "368026", "conference": "OOPSLA", "title": "On the predictability of Java byte codes (abstract) (poster session)", "url": "http://dl.acm.org/citation.cfm?id=368026"}