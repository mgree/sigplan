{"article_publication_date": "01-01-2000", "fulltext": "\n GLORP: Generic Lightweight Object-Relational Persistence Alan Knight Gincom Systems, Inc. knight@acm.org \n While object databases are technologically better adapted to storing object data, most of the world's \ninformation is still in relational databases.\" This makes it critical for object-oriented applications \nto be able to access data in relational databases. Unfortunately, this is a harder problem than it might \ninitially seem, and one that is a major risk for projects. Simple approaches can be used for basic mapping \n--assigning a class for each table and an instance variable for each column, managing relationships manually \n--but these do not scale well as complexity and performance requirements increase. A particular difficulty \nis that object applications must often deal with pre- existing relational schemas designed for other \npurposes. Mapping these schemas into objects may require a great deal of flexibility. will demonstrate \nGLORP (Generic Lightweight Object-Relational Persistence), a simple but powerful object-relational mapping \nlayer. GLORP is an open-source project, implemented in Smalltalk, and adaptable to almost any relational \ndata store. While still in the very early stages of development, it already offers many sophisticated \nfeatures. GLORP is intended not just to serve a mapping layer, but to illustrate the principles and patterns \nthat be applied to this problem space. We briefly outline what we feel are the important areas. Mapping \ncan divide the sophistication of storage strategies into various layers. The simplest relational storage \nstrategy is simply to embed SQL into code whenever an object is read or written. This quickly leads to \nduplication and maintenance difficulties and so it is often generalized to a broker that stores SQL statements \nfor reading and writing each class of object. This is workable, but tends to limit operations that are \npossible, since each additional query or special form of write requires at least a new SQL statement, \nif not extension to the broker protocol. Relationships between objects may not be modeled, forcing object \ndevelopers to take foreign keys into account, e.g. findOrdersWithCustomerID: aCustomer id. Alternatively, \nrelationships may be modeled with explicit queries (e.g. findOrdersForCustomer :) which must be added \nto the broker layer. Permission to make digital or hard copies of all or part of this work personal or \nclassroom use is granted without fee provided that copies are not made or distributed for profit or commercial \nadvantage that copies bear this notice and the full citation on the first page. copy otherwise, to republish, \nto post on servers or to redistribute lists, requires prior specific permission and/or a fee. OOPSLA \n2000 Companion Minneapolis, Minnesota Copyright ACM 2000 1-58113-307-3/00/10...$5.00 To go beyond these \nlimitations requires a more explicit and declarative mapping, which is the scheme GLORP uses. Object \ndevelopers do not define SQL statements. Instead, they define a mapping between object and database representations \ndeclaratively in terms of correspondences between fields and instance variables, or between relationships \nand foreign keys. This meta-data is represented as mappingobjects, e.g. OneToOneMapping new attributeName: \n#address; referenceClass: Address; mapingCriteria: (PrimaryKeyExpression from: (prsnTbl fieldNamed: \n'ADDR_ID') to: (addressTable fieldNamed: 'ID'). This lets the mapping layer perform much more detailed \nanalysis of the operations to be performed than is possible if explicit SQL statements are used. The \nframework can support complex and dynamic queries, dynamically modifying meta-data, transparent management \nof relationships, partial reads and writes of objects, and numerous optimizations. 2 Transactions Rather \nthan having explicit writes of individual objects, GLORP bases all writes on its transactional model, \nnoting which objects were touched during the transaction. This is less intrusive into the application \ncode, since it frees developers from having to remember which objects were modified. Since the transactional \nframework can also provide rollback on those objects, this can simplify the application programming model \nsignificantly, even without considering the database aspects. Automatic writes on transaction boundaries \nis also important because it gives us the opportunity to re-order those writes. This can let us optimize \nthe writes, minimize deadlock, and most importantly respect relational integrity constraints. Given such \na scheme, we need to determine which objects were modified in a transaction. There are several possible \nstrategies. The least intrusive would be to inspect all objects in the cache, but this would not be likely \nto perform adequately. We could require the developer to explicitIy register root objects, and examine \nonly those roots and the objects reachable from them. This performs well, but requires some additional \nintrusion into the application code. Finally, we could create a write barrier so that any modification \nof an object could be detected and the transaction in which it occurred would be known. GLORP currently \nuses the second mechanism, but there has been design work done to enable transparent parallel transactions \nwhich would support a write barrier. 3 Non-Intrusiveness A primary design goal of this work is not to \nintrude into either the relational model or the object model. This has several aspects. Firstly, we should \nnot intrude by requiring clhanges to the relational schema. Since these schemas can vary widely, and \nmay not correspond wet] to the desired object model this forces us to be very\" flexible in terms of how \nwe can map this schema into objects. Secondly, we should not inwude into the object model. We shoutd \nminimize the extent of any object model changes, and fiarther we should not force the classes to inherit \nfrom a persistent superclass or to implement special database-related code. We shoutd be able to work \nobjects that were not designed to be persistent wi~.hout di~TicultT. Finalty, we should be non-intrusive \nin the development process, so we should not force developers to go thorough any extra steps during development \n(e.g. code- generation, pro-processing). These goals cannot be achieved one hundred percent. It's not \npossible to map any arbi~ary database schema onto any arbitrary object models If we are to store objects \nin a relational database then we need to be abte m somehow derive a primary key from those instances. \nIf we are to store collections we must recognize that the ordering of an ordered collection cannot be \nautomatically preserved in a relational database. Nevertheless, we try to come as close to the goal of \ncomplete non-intrusiveness as possible. For example, GLORP objects can be stored across multiple tables. \nIt is also possible to store multiple objects within a single row, and objects can be written to different \ntables in different circumstances (e.g. a money oNect might be stored directly with the thing that contains \nit in many dift~rent tables). GLORP does not require that objects in a one-to-many relationship retain \na reference to their parent, and GLORP is currently entirely meta-data and reflection based so that no \ncode is ever generated~ 4 Queries if we are to store objects in a relational database we must be able \nto retrieve them easily and efficiently. GLORP supports queries at the object level, the data level and \nmixtures of the two, as well as direct use of SQL. W%ite most queries will be done purely in terms of \nobjects, this flexibility means that all of GLORP's internal querying can be done with the same mechanisms \nthat are available m the end user. The most common query mechanism is to express them as Smalltalk blocks, \nusing the object-level relationships to define attributes and joins. For example, to read a Person based \non a property of the related Address object we can specify aSession executeQuery: <Query forManyOf: \nPerson where: [:person { person address street = 'Main']. This will examine the query block, determine \nthat it references the class Person and the one-to-one relationship to Address, and the attribute \"street\" \nfrom Address. Based on this information it consults the meta-data, determines which tables are necessary \nand the join criteria between them, then generates the corresponding SQL. Once the rows are retrieved, \nit examines each row, determines if the object is already in cache, and if not builds the new object. \nNote that queries are addressed to a particular Session object, which also controls transactions. By \ntalking explicitly to a session, rather than having an implicit session with queries as class methods \nor addressed to a general factory we can easily support multiple independent sessions within the same \nvirtual machine. 5 Performance Flexibility isn't useful if the application cannot perform adequately. \nGLORP already supports significant performance optimizations, and is architected to permit additional \nimportant optimizations. In a database-centric application, in-memory performance is rarely the dominant \nfactor. It would be possible to micro-optimize some of the GLORP features by imposing a code-generated \nwrite barrier, and using generated code rather than reflective access, but in practice we have not found \nthese to be at all significant. Smalltalk supports very fast reflective access (especially compared to \nJava) and the most powerful optimizations have been in terms of database operations. The most significant \nstep is the introduction of an optimization phase during writes. When writing, we first compute the data \nrepresentation of all changed or new objects, then examine the data to determine exactly what needs to \nbe written, the write order, and any opfimizations that can be applied. An example of such an optimization \nwould be Oracle's array binding feature, which lets us perform many identical statements with different \nparameters as a single call with array-valued parameters. This is not yet implemented in GLORP, but it \ncan easily be supported because of the optimization phase. On read, queries can specify groups of objects \nto be read at the same time, and these can be broken down into groups which can be loaded as joins or \ncomposite reads. This can be specified declaratively, and can vary for different queries against the \nsame objects. For example, when reading for an overview display we can read in minimal information, but \nwhen reading in for editing we can specify that related objects should be retrieved as well. 6 Links \nand Acknowledgements For more information on GLORP, including source code, see http://glorp.sourceforge.net. \nWhile GLORP is intended to be portable between Smalltalk dialects and databases, most of the current \ndevelopment is in VisualWorks 3.0 and 5i against Oracle and PostgreSQL databases. GLORP is a Camp Smalltalk \nproject (http://carnp.smalltalk.org). Many thanks to The Object People (now WebGain) which sponsored \nthe initial development work on GLORP and whose TOPLink family of products has influenced its design. \nThanks as well to everyone who has contributed to this effort, particularly Bruce Badger, Anthony Lander, \nJohn-Reed Maffeo, Mark Schwenk, and David Siegel.   \n\t\t\t", "proc_id": "367845", "abstract": "", "authors": [{"name": "Alan Knight", "author_profile_id": "81100206848", "affiliation": "Cincom System, Inc.", "person_id": "PP14081453", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.368081", "year": "2000", "article_id": "368081", "conference": "OOPSLA", "title": "GLORP: generic lightweight object-relational persistence", "url": "http://dl.acm.org/citation.cfm?id=368081"}