{"article_publication_date": "01-01-2000", "fulltext": "\n Evaluation of Coupling in the Context of Java Interfaces Mohsen D. Ghassemi and Ronald R. Mourant Northeastern \nUniversity 334 Snell Engineering Boston, Mass 02115 gmohsen@coe.neu.edu Abstract Several coupling frameworks \nhave been introduced in the literature to identify and measure the design complexity of object\u00adoriented \nsoftware systems. The coupling metric COF presented by the unified framework considers in\u00adheritance, \npolymorphism, method overriding, and direct methods of invocations to identify possible interactions \nin the system that contribute to the software complexity. We evaluate the COF metric in the context of \nJava interfaces. Interactions are identified, the effectiveness of the model is discussed, and an extension \nof the model is offered for more accurate measurement of complexity. 1. Introduction Because complexity \nrelates directly to increasing cost, managers are continuously striving for better quality soft\u00adware \nsystems. The coupling models presented in the lit\u00aderature show many possible interactions that can occur \nbetween objects in the software systems and offer metrics to measure its design complexity. The notion \nis that high coupling between objects increases complexity and this reflects in increasing design cost. \nTherefore low coupling should be aimed for when designing 00 software. The COF metric offered by the \nunified framework [1, 2] is based on class method invocation and class attribute ref\u00aderencing and provides \na measurement based on the in\u00adteractions of all classes in the system. It considers rela\u00adtionships through \npolymorphism, method overriding, and inheritance. While inheritance introduces more interac\u00adtions among \nclasses in the system and therefore increases complexity, the COF metric does not count coupling re\u00adsulted \nfrom inheritance. This is because inheritance is a good thing, it gives software reusability and that \nthe ben\u00adefits outweighs the cost. This poster presents relation\u00adships between Java interfaces and all \nclasses in the sys\u00adtem. It identifies new interactions resulting from the use of interfaces that impact \nthe coupling measurement. We fur\u00adther justify that interfaces are a good thing and that they should get \nthe same treatment Permission to make digital or hard copies of part or all of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advantage and that copies bear this notice and the full citation on the first page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission \nand/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota (c) Copyright ACM 2000 1-58113-307-3/00/10...$5.00 \n as the inheritance relationships meaning that class con\u00adnections with the interfaces should not be counted \nas cou\u00adpling. Finally, we offers an extension of COF metric to better represent the coupling measurement \nof the soft\u00adware system. 2. Background The coupling factor (COF) metric introduced by the uni\u00adfied framework \n(Figure 1) represents the actual number of client\u00adserver relationships between classes that are not related \nvia inheritance to the maximum possible number of such client\u00adserver relationships. It is normalized \nbe\u00adtween 0 and 1 to allow comparisons between systems of different sizes. To obtain the actual number \nof couplings, the metric goes through each class in the system (con\u00adsidering all its methods and attributes) \nand finds its rela\u00adtionships to all other classes in the system as described by the numerator of the \nmodel. Figure 1: Coupling Factor (COF) Metric Model The decision to whether count the interaction between \ntwo classes as one coupling is based on the uses(c,d) predicate (Figure 2). The predicate requires that \nwhen a method in class c invokes a method in class d, then the implementation of that method has to be \ninside class d and not declared through inheritance. If the relationship is via inheritance, the predicate \nuses(c, d) returns false. If the predicate returns true, the metric counts the rela\u00adtionship as 1 coupling \nmeaning that the class c is coupled to class d through either method invocation or attribute referencing. \n Figure 2: predicate uses(c ,d)  3. Java Interfaces Java interfaces allow only method definitions and \ncon\u00adstant attributes. Methods defined in the interfaces cannot have implementations in the interface. \nClasses can \"imple\u00adment\" the interface by providing bodies for the methods defined in the interface. \nAn interface is a contract between a client class and a server class. It helps to decouple the client \nfrom the server. Any intended change on the meth\u00adods defined in the interface will impact both the client \nand server classes. Possible changes are as follows: 1) chang\u00ading the name of a method, 2) changing the \nsignature of a method, and 3) changing the return type of a method. There are two other possible changes \nthat worth noting. If a new method is added to an interface, this will also im\u00adpact the server and client \nclasses that currently use or implement the interface. 0n the other hand if the imple\u00admentation detail \nof a method inside a server class is changed, this change only effects the client class and not the interface. \nThis specific case is more a code issue than a design issue and therefore it is not a concern in this \nevaluation. To evaluate whether the current COF metric measures the true design complexity of a software \nsystem with inter\u00adface implementations, the predicate uses(c, d) needs to be evaluated. The predicate \nrequires that the client invo\u00adcation of a method or attribute reference to be explicitly implemented \nin the server class. When the predicate re\u00adturns true, it means that there is a connection between class \nc and class d and that the number of possible changes to the software is two, one to the server class \nand one to the client class. When the predicate returns false, it means that there is no connection between \na cli\u00adent class and a server class and therefore no coupling exists between classes c and d. Consider \nthe possible changes in Java interfaces as discussed above. When a designer adds a new method to the \nserver class, or changes the signature or the return type of an existing method, or changes the name \nof the method, all impact the interface. It first needs to make the changes in the interface, then make \nthe required changes to the server class, and finally make the appropriate changes to the client class. \nSo a change with an interface connection requires three changes. Most development organizations have \ndifferent development teams where one team works on the client side and another works on the server side. \nIn fact this is exactly what the interfaces are intended to enable and allow teams to work independently \nusing a defined contract. If either the client or the server class tries to make a change that does not \ncomply with the contract, things will break.  4. Discussions and Conclusions The current C0F metric \nconsiders the connection be\u00adtween a client and a server class as one coupling. In systems with interface \nimplementations, the client/server class relationships have two connections. This means a change in the \nserver class which impacts the interface, will require three software changes, one to the server, one \nto the interface, and one to the client. Two issues are discussed to decide how and why the existing \nmetric should be considered for extension. First, if the metric is ex\u00adtended to count for connections \nwith the interfaces then the metric represents higher coupling among classes, mis\u00adrepresenting the use \nof interfaces as a bad thing because it increases complexity. Where in fact interfaces are de\u00adsigned \nto allow building software based on contracts, and increase extendibility and allow interchangeable compo\u00adnents. \n0n the other hand, if the COF metric stays un\u00adchanged, this could also be flawed in that it misrepresents \nthe true interactions between classes and the use of in\u00adterfaces in the system. Perhaps we can extend \nCOF met\u00adric in such a way that it treats interfaces as it treats inher\u00aditance. We recall that the COF \nmetric does not count cou\u00adpling due to the inheritance because inheritance offers software reusability \neven though it introduces higher cou\u00adpling. The benefits outweighs the costs and that class in\u00adteractions \ndue to the inheritance should not and is not counted for coupling. An alternative solution is offered \nto extend the existing model to not count coupling due to the interactions be\u00adtween classes that have \nconnections with the interfaces. In this case let represent I as a set of all interfaces in the object\u00adoriented \nsystem. Then for ioI the predicate uses (c, d, i) is to find if there is a connection between inter\u00adface \ni and class c class d. If there is a connection, then do not count it as coupling. This may in fact give \na lower and more accurate picture of coupling in the system. The  extended predicate is shown in Figure \n3. Figure3: Extended predicate uses(c ,d, ij  5. References [1] L. Briand, J. Daly, and J. Wust, \"A \nUnified Framework for Coupling Measurement in 0bject\u00ad0riented Systems\", IEEE Transactions on Software \nEngineering, vol. 25, no. 1, Jan./Feb. 1998. [2] L. Briand, J. Daly, and J. Wust, \"An investigation into \ncoupling measures for C++\", In Proceedings of the 19th int'l Conf. on Software Engineering (ICSE'97), \nBoston, USA, pages 412\u00ad421, 1997.  \n\t\t\t", "proc_id": "367845", "abstract": "<p>Several coupling frameworks have been introduced in the literature to identify and measure the design complexity of object-oriented software systems. The coupling metric COF presented by the unified framework considers inheritance, polymorphism, method overriding, and direct methods of invocations to identify possible interactions in the system that contribute to the software complexity. We evaluate the COF metric in the context of Java interfaces. Interactions are identified, the effectiveness of the model is discussed, and an extension of the model is offered for more accurate measurement of complexity.</p>", "authors": [{"name": "Mohsen D. Ghassemi", "author_profile_id": "81414602803", "affiliation": "Northeastern University, 334 Snell Engineering, Boston, Mass", "person_id": "P202545", "email_address": "", "orcid_id": ""}, {"name": "Ronald R. Mourant", "author_profile_id": "81409598369", "affiliation": "Northeastern University, 334 Snell Engineering, Boston, Mass", "person_id": "PP77033013", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367926", "year": "2000", "article_id": "367926", "conference": "OOPSLA", "title": "Evaluation of coupling in the context of Java interfaces (poster session)", "url": "http://dl.acm.org/citation.cfm?id=367926"}