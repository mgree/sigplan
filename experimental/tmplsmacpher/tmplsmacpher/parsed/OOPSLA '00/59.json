{"article_publication_date": "01-01-2000", "fulltext": "\n Kava A Powerful and Portable Reflective Java Ian S. Welch Department of Computing Science University \nof Newcastle upon Tyne United Kingdom +00 44 191 222 6000 I.S.Welch@ncl.ac.uk ABSTRACT Kava is a powerful \nand portable reflective Java that uses byte code rewriting to implement behavioural reflection. In our \nposter we briefly overview the Kava system, give an example of its use, and contrast it with simple byte \ncode rewriting. More details about Kava are available from http://www.cs.ncl.ac.uk/research/dependability/reflection. \n Categories and Subject Descriptors D.3.2 [Programming Languages]: Language Classifications extensible \nlanguages, object-oriented languages.  General Terms Languages. Keywords Byte code rewriting, metaobject \nprotocols, reflection, Java. 1. INTRODUCTION Binary code rewriting has been proposed as an approach to \nadapting independently developed code in a new environment [1]. In the context of Java byte code rewriting \ntoolkits [2-4] have been developed that make this possible. We argue that these are powerful tools but \nthat they do not necessarily work at the right level of abstraction. We propose the use of reflection \nand metaobject protocols as a way of adapting classes in a principled way. We have developed an implementation \nof reflective Java called Kava that allows this. Although other researchers have also developed reflective \nJava implementations, ours is powerful and portable. Kava can capture some behavioural changes more concisely \nthan byte code rewriting toolkits. This implies that Kava should be safer and easier to use. 2. BYTE \nCODE REWRITING Byte code rewriting toolkits provide object-oriented representations of elements of class \nfiles such as methods, types, instructions etc. Java programs can then be written that describe how to \nrewrite class files. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advantage and that copies bear this notice and the full citation on the first page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission \nand/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota. (c) Copyright 2000 ACM 1-58113-307-3/00/10 \n$5.00. Robert J. Stroud Department of Computing Science University of Newcastle upon Tyne United Kingdom \n+00 44 191 222 6000 R.J.Stroud@ncl.ac.uk The main drawback to this approach is it requires the programmer \nto have a good knowledge of byte code and the class file format. What is required is an approach that \nworks at the language level. This would make it easier and safer for programmers to use byte code. We \nsuggest that behavioural reflection provides an appropriate model for the changing program behaviour \nwithout having to rewrite the entire program implementation. Kava introduces behavioural reflection to \nJava. 3. REFLECTION Reflection [5] is the process by which a system can reason about and act upon itself. \nA reflective system is composed of a base level and a meta level. The base level is the system being \nreasoned about, and the meta level has access to representations of the base level. Reification is the \nprocess by which the abstract representations of the base level are generated. A reflective system has \nthe property that the meta level is causally connected to the base level. This means that changes at \nthe meta level cause changes to the behaviour of the base level. Changing the behaviour of the base level \nis behavioural reflection. These notions of reflection have been extended to include the concept of the \nmetaobject protocol [6] where an abstraction of the computation process and the protocols governing the \nexecution of the program are exposed. A metaobject is bound to an object and controls the execution of \nthe object. By changing the implementation of the metaobject, the object's execution can be adjusted \nin a principled way. The protocols are implemented as methods of the metaobject. 4. OVERVIEW OF KAVA \nThe Kava system allows each object or class to be bound to a metaobject. At the meta level runtime behaviours \nsuch as method invocation, method execution, field access, etc. can be redefined by the metaobject implementation. \nThe metaobject implementation is constructed using reified aspects of the runtime object model. For example, \na method is reified as an instance of a Method class. The binding itself is described by a binding specification. \nThis is written using a declarative binding language. Separating the binding information from the metaobjects \nincreases the reusability of metaobjects as the bindings effectively parameterise the metaobjects. For \nexample, a binding specification may bind a metaobject to different fields on different classes. Kava \nis implemented by adding traps into class files that redirect control to the metaobject associated with \nan object. A third party byte code rewriting toolkit is used to implement the traps at the time a class \nis loaded into the Java Virtual Machine (JVM). The Kava system allows principled redefinition of field \naccess, method invocation, method execution, constructor, finaliser and exceptions. There are already \na number of reflective Java implementations available such as MetaXa [7], or OpenJava [8]. However, Kava \ndiffers from them all in that it provides a powerful control over program behaviour without requiring \naccess to source code or modifications to the JVM. 5. SIMPLE EXAMPLE The user of Kava redefines the \nbehaviours by specialising the metaobject associated with the object. An example of redefining object \nbehaviour is shown below. Here we want to trace method execution so we redefine how methods are executed \nby Java. Before a method is executed, the message tracing and the name of the method will be displayed. \nThe metaobject below implements this: public class TracingMetaObject implements MetaObject { public \nExecutionContext beforeExecuteMethod(ExecutionContext context) { System.out.println(\"tracing \" + context.getMethodName()); \n} } The metaobject has to be bound to the class that has the methods that are to be traced. This binding \nspecification below specifies that all methods of the class Test are to be traced: bind { class Test \nmetaclass-is TracingMetaObject { any-method(any-parameters) { execute; } } } An overview of the equivalent \nimplementation using a byte code rewriter such as JavaClass [3] is: public class TraceMethod implements \nConstants { private static Method traceMethod(Method m){ create the byte code to insert find insertion \npoint insert byte code at beginning of method recalculate stack size return modified method } public \nstatic void main(String[] argv) { parse the class get constant pool generate necessary constants \nforeach method: call traceMethod write out modified class } } There are a number of drawbacks to implementing \nthe tracing behaviour using a byte code rewriting toolkit. The programmer must manually generate the \nbyte code to be inserted, and the code to traverse the class file to find the proper insertion point. \nIn addition, the code to be inserted can also only be verified by running the rewriter against a classfile \nand verifying the result. Not only is this tedious and error prone but the resulting code is much longer \n(fourteen lines in Kava, over forty lines in JavaClass). 6. SUMMARY Kava is a powerful and portable \nsystem that adds behavioural reflection to Java. It allows principled adjustment to the behaviour by \nspecifying changes using a metaobject protocol. It allows some changes to program behaviour to be specified \nmore concisely than simply using a byte code rewriting toolkit. We are exploring the application of Kava \nto enforcing security on Java applications. Kava and related presentations and papers are available from \nhttp://www.cs.ncl.ac.uk/research/dependability/reflection. 7. ACKNOWLEDGMENTS This work has been supported \nby the UK Defence Evaluation Research Agency, grant number CSM/547/UA and also the ESPIRIT Long-term \nResearch project MAFTIA. 8. REFERENCES [1] Holzle, U., Integrating Independently-Developed Components \nin Object-Oriented Languages in Proceedings of ECOOP'93, 36 - 56, 1993. [2] Cohen, G.A. and J.S. Chase, \nAutomatic Program Transformation with JOIE in Proceedings of USENIX Annual Technical Symposium, 167-178, \n1998. [3] Dahm, M., Byte Code Engineering with the JavaClass API, Technical Report, Friei Universitat, \nB-98-17, 1998. [4] Chiba, S., Load-time Structural Reflection in Java in Proceedings of ECOOP'2000, 313-336, \n2000. [5] Maes, P., Concepts and Experiments in Computational Reflection in Proceedings of OOPSLA'87, \n147 - 155, 1987. [6] Kiczales, G., J. des Rivieres, and D.G. Bobrow, The Art of the Metaobject Protocol, \nMassachusetts Institute of Technology, 1991. [7] Golm, M. and J. Kleinoder, Jumping to the Meta Level: \nBehavioural Reflection Can Be Fast and Flexible in Proceedings of Meta-Level Architectures and Reflection, \n22-39, 1999. [8] Tatsubori, M. and S. Chiba, Programming Support of Design Patterns with Compile-time \nReflection in Proceedings of OOPSLA'98 Workshop on Reflective Programming in C++ and Java, 56-60, 1998. \n  \n\t\t\t", "proc_id": "367845", "abstract": "<p><i>Kava</i> is a powerful and portable reflective Java that uses byte code rewriting to implement behavioural reflection. In our poster we briefly overview the <i>Kava</i> system, give an example of its use, and contrast it with simple byte code rewriting. More details about Kava are available from <i>http://www.cs.ncl .ac.uk /research/dependability/reflection</i>.</p>", "authors": [{"name": "Ian S. Welch", "author_profile_id": "81100075829", "affiliation": "Department of Computing Science, University of Newcastle upon Tyne, United Kingdom", "person_id": "P115684", "email_address": "", "orcid_id": ""}, {"name": "Robert J. Stroud", "author_profile_id": "81100497536", "affiliation": "Department of Computing Science, University of Newcastle upon Tyne, United Kingdom", "person_id": "P246623", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.368019", "year": "2000", "article_id": "368019", "conference": "OOPSLA", "title": "Kava - a powerful and portable reflective Java (poster session)", "url": "http://dl.acm.org/citation.cfm?id=368019"}