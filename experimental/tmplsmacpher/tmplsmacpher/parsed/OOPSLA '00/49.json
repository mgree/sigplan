{"article_publication_date": "01-01-2000", "fulltext": "\n State Machine Specification Directly in Java and C++ Alexander Sakharov GTE Laboratories 40 Sylvan Road, \nWaltham, MA 02451 asakharov@gte.com, asakharov@aol.com 1 Introduction Finite state machines (FSM) have \nbecome a standard model for representing object behavior. In particular, UML introduces a FSM notation \nthat is an object-oriented variant of hierarchical statecharts [2]. Development of a variety of software \ncan be automated via code generation from FSM specifications. A FSM is defined by the following: a finite \nset of states, a finite set of event categories and transitions mapping some state-event pairs to other \nstates and relevant actions. This article shows that FSM specifications can be expressed directly in \nprocedural object-oriented languages like Java and C++. Code generation is supported within these languages \nas well. Majority of contemporary software is implemented in these two languages. Availability of FSM-related \nautomation directly in these languages may dramatically increase both the scope of usage of FSM specifications \nand the productivity of development of a broad range of software. Inheritance is a primary enabler of \nthis approach that is quite generic and applicable to various specifications. An abstract base class \ndeclares static variables for storing specifications and contains code generation methods. Derivates \nof the base constitute FSM specifications. Execution of a compiled specification class does code generation \nresulting in a class derived from the specification class. The hybrid notation from [3] enhances the \nexpressiveness of FSM specifications. FSM transitions are expanded by adding regular expressions of events \nand by adding unions of states. Use of transitions with regular expressions of events may significantly \nreduce the complexity of FSMs by hiding plenty of states. The use of state unions allows developers to \ncombine multiple transitions in one. In contrast to development of client-side visual components and \nserver-side transactional components, automation of the development of non-visual non-transactional components, \nwhich normally play the role of listeners and which are best modeled by FSMs, has not been much addressed. \nFSMs fill this gap. The components generated from our FSM specifications handle events and may have customizable \nproperties. These components can Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advantage and that copies bear this notice and the full citation on the first \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspecific permission and/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota (c) Copyright ACM 2000 \n1-58113-307-3/00/10...$5.00 serve as containers for other FSMs. Containers may host concurrent sub-components. \nFSM components in Java are beans that can be introspected and serialized. Construction of applications \nout of FSM components is automated as well. We introduce a notation for specification of assembly of \nFSM components in Java and C++. These specifications, in particular, define containment. The same specification \nand generation technique is utilized. Threads are generated from the assembly specifications. They serve \nas event adapters, implement control flow among components and support component data exchange. FSM containers \ncorrespond to composite states in hierarchical statecharts. Overall, relevant UML s capabilities including \nconcurrency regions and SynchStates [2] are made available in Java and C++ with extra power added by \nregular expressions of events. Like UML, we use an object-based variant of FSMs. In contrast to UML, \nwe strongly focus on component technology, that is, the assembly specifications are separated from components, \nand FSMs do not have to be modified when putting applications together. Note also that any foreign components \nand threads can be programmatically combined with FSMs since we are in the realm of Java or C++. A prototype \nimplementation of this approach in Java is available for download from http://members.aol.com/asakharov/fsm.html. \n 2 Hybrid Transition Notation We introduce source and target state expressions. They may refer to unions \nof states. Their respective transition specifications denote multiple transitions. We introduce event \nexpressions as an extension to event signatures. The event expression is a regular expression whose tokens \nare event signatures. Note that transitions may be eventless. Several actions can be given for a transition \ndefined with an event expression. Note also that UML s send clauses are not necessary in Java or C++. \nSee [3] for a detailed description of our transition notation and for transition conflict resolution. \nHere is syntax of the extended transitions: [ <name> : ] <source-state-expression> | <event-expression> \n-> <target-state-expression> [ <guard-condition> ] / <action-expression-list> Transitions with regular \nexpressions of events containing Kleene closure or concatenation [1] are turned into automata, which \ncan be viewed as internal FSMs augmenting their host FSM specified by the developer. The internal FSMs \nadd hidden states to the set of states of the host FSM. The hidden states are pairs composed of an explicitly \ndefined state of the host and an internal automaton state. Execution of an internal FSM can be triggered \nby an event that can be the first token in a string of tokens from the language defined by the respective \nregular expression. Transitions with event expressions containing unions [1] only are unfolded into multiple \nconventional transitions. 3 Component and Assembly Specifications We focus on Java since it has an adequate \nterminology and support for components and threads. Any FSM component is specified as a class derived \nfrom an abstract class called FSM. Class FSM declares static variables for storing a start state name, \nan optional stop state name, and transitions as strings. FSM specification classes define values of the \naforementioned variables. Transition actions are given by the names of methods implementing them in the \nsame FSM specification classes. Argument lists optionally follow the method names. Guards are given by \nvalid Java expressions substantiated in the same FSM specification classes. Assembly of components is \nspecified as a class derived from an abstract class called FSMThread. Class FSMThread declares static \nvariables for storing specifications of the following: containment; FSM component synchronization points; \ndata exchange between containers and sub-components; event sources; an event-processing mode. Values \nof these variables are defined in derived classes. Class FSMThead also dispatches invocation of data \nexchange methods. Events may be delivered synchronously or asynchronously. In the latter case, they may \nbe queued or not. If event queuing is allowed, then the default order of processing events in the queue \nis FIFO, which can be overridden. Containment is specified by an array mapping container FSM states to \nsub-components. Each element of this array consists of a container identifier, a container state, and \na sub-component identifier. If more than one sub-component is given for one container state, then these \nsub-components are run concurrently. Synchronization points of concurrent sub-components are specified \nby an array whose elements consist of two component identifiers, two state or transition names, and an \noptional data exchange method name. These synchronization points have the function of UML s SynchStates. \nEach element of an array specifying data exchange between containers and sub-components consists of two \ncomponent identifiers, two method names, and a flag. The first method passes data from the container \nto the sub\u00adcomponent, whereas the other passes data back. All data exchange methods should be implemented \nin the same assembly specification classes. The flag indicates whether data exchange happens at invocation \nand at reaching a stop state, or at invocation and at every termination of the sub-component. Note that \ncomponents connected through containment may share event sources. Event sources are specified by an array \nwhose elements comprise component and event source identifiers along with mappings of transition events \nto listener interface methods of source listeners. It is assumed that the event sources implement methods \nthat add and remove event listeners. The identifiers are class names optionally followed by dot and an \ninstance name. 4 Application Generation Code generation methods of class FSM build components from their \nspecifications whereas FSMThread s code generation facilities are responsible for building FSM controllers \nfrom assembly specifications. The classes generated from FSM specifications contain implementations of \nmethods named as events in the transitions specified in their super classes. These generated classes \nalso contain guard methods for the aforementioned transition event methods. Additionally, a couple of \nmethods are generated for executing eventless transitions. Each generated FSM component class has an \narray with state names. For the sake of efficiency, transition events and states are represented by integers \nin generated code. Generated transition event methods and their guards have the form of switch statements \nwhose cases are FSM states including pairs with hidden states. Branches in the switch statements of the \nguard methods test guard expressions. Every branch in the switch statements of the transition event methods \ncalls an applicable transition action whose guard condition is satisfied and updates the FSM state. Generation \nof the internal FSMs is done by application of the algorithm from [1] that converts regular expressions \ninto deterministic finite automata. These generated internal FSMs are minimized after that, i.e. they \nare transformed into equivalent FSMs with the minimal number of states by using the minimization algorithm \nfrom [1]. Additionally, if a generated internal FSM has transitions leading to its start state, then \na new start state is created and added to the internal FSM in order to avoid ambiguity in determining \nwhether the internal FSM is active or its host. The controllers generated from assembly specifications \nimplement control flow between containers and their sub\u00adcomponents and play the role of event adapters \nfor all relevant FSM components. The generated controllers implement all listener interface methods for \nspecified event sources. Each generated controller has a static Boolean array employed for fast determination \nof containment and another static array with references to data exchange methods. These controllers construct \ninstances of generated FSM component classes. They construct and fire event sources, and then register \nthemselves as listeners to the event sources. The controllers queue events when so specified. The controllers \ncall counterparts of listener interface methods and eventless methods of the classes generated from FSM \nspecifications. In implementation of control flow among components, we maintain active state configurations \n[2] and follow the UML semantics of composite states including concurrent ones. References [1] A. Aho, \nR. Sethi, J.Ullman Compilers: Principles, Techniques, and Tools. Addison-Wesley, 1985. [2] OMG Unified \nModeling Language Specification. Object Management Group, Inc., Version 1.3, June 1999. [3] A.Sakharov. \nA Hybrid State Machine Notation for Component Specification. SIGPLAN Notices, 35(4):51-56, April 2000. \n \n\t\t\t", "proc_id": "367845", "abstract": "", "authors": [{"name": "Alexander Sakharov", "author_profile_id": "81100062854", "affiliation": "GTE Laboratories, 40 Sylvan Road, Waltham, MA", "person_id": "PP31025396", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367993", "year": "2000", "article_id": "367993", "conference": "OOPSLA", "title": "State machine specification directly in Java and C++ (poster session)", "url": "http://dl.acm.org/citation.cfm?id=367993"}