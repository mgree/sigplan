{"article_publication_date": "01-01-2000", "fulltext": "\n iiii iii i Transparent and Flexible Storage of Application Objects Ill in CORBA Environments Ill Dominik \nKuropka, Mathias Weske I Westf~tische Wilhelms-UniversiNt Miinster Ul Steinfurter StraBe 109, 48149 \nMUnster, Germany {isdoku, weske} @wi.uni-muenster.de III  Introduction The ability to store arbitrarily \nstructured objects in persistent stor- age in a transparent and flexible way with little eftbrt is an \nimpor.- rant requirement fbr middleware in general and for object-oriented middleware in particular [1]. \nThis extended abstract describes the demonstration of a transparent and flexible persistence service \nfor application objects m CORBA environments. Details of the con- ceptual design and the implementation \ncan be found in [3]. The purpose of a persistent storage service is to support appli- cation developers \nin storing object states persistently. In the context of object-oriented applications, a persistent storage \nservice can be represented by appropriate intediice definitions and implementa- tions. Generally speaking, \nat each instance, an object is character- ized by its state and its behavior. While object behavior is \nspecified by methods, the state of an object is represented by the object's current attribute values. \nConsequently, a persistent storage service deals with storing attribute values persistently, with the \naim of en- hancing fault-tolerance. If the representation in volatile storage of a persistent object \nis lost, e.g., due to a server crash, the persistent storage service is responsible for restoring a consistent \nobject state aider the system is restarted. This is done by loading the object's attribute values from \npersistent storage into volatile storage to re- install a consistent object state. Design Goals As a \nbasis for the design of the persistent storage service, the fol- lowing design goals were identified \nas far as the use of the service is concerned: Ease-ofZuse, support for class evolution, data integrity, \nand multi-threading. For etticient software development and maintenance, applica- tion programmers, i.e., \nusers of the service, should concentrate on the business logic, rather than on technical details like \nthe persistent storage of application objects. Incumng considerable additional coding to store application \nobjects is not an attractive feature of a persistent storage service. In particular, it seems inappropriate \nto require application programmers to develop additional interfaces and classes for providing persistence \nfor application objects. In contrast, providing methods for storing object values persistently and for \nloading object values from persistent storage in volatile storage is a more appropriate choice. Given \nthe dynamic nature of todays business environments, the structure of application objects is likely to \nchange due to new re- quirements imposed by the application. For example, objects may Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for profit or commercial advantage and that copies bear \nthis notice and the full citation on the first page. To cop), otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior specific permission and/or a fee. OOPSLA 2000 Companion Minneapolis, \nMinnesota (c) Copyright ACM 2000 1-58113-307-3/00/lO...s5.00 ~llll] require new attributes or given \nattributes are no longer needed. I~  IIIII the former case, the respective attribute values have to \nbe stored persistently m properly represent object states. As a result, it is a,r: IIII important design \ngoal for users of persistent storage service t has evolution of both classes and objects is supported, \nIll In presence of system failures involving the loss of volati:le memory content, the system should \nbe able to recover data from persistent storage, i.e., to load persistent data into object attribuIes \nData integrity and consistency have long been studied in the cot>. text of database systems, where the \ntransaction concept was irm~o-duced. In the context of a persistent storage service, writing ob- llll \njects to persistent storage and loading objects from storage should be performed transactionally, i,e., \neither completely or not at all 1111 Multithreading is used for concurrent activities in applicatio~a \nsystems, Each thread corresponds to a light-weight process, which may be supported by specific functionality \nprovided by the oper.o ating system. Since object-oriented applications typically involve IIII concurrently \nactive objects, a persistent storage service should sup- port multithreading. We mention that multithreading \nis inevitable if 111 asynchronous execution of methods is required by the application, We stress that \nwithin the conceptual design, different im:ple~ Ill mentations are feasible, which may focus on different \naspects~ Im~ port.ant properties of the service in this context are support ~r dif~ III ferent data repositories, \ndistribution and heterogeneity, as well as different storage policies and data granularities. The design \ngoals are discussed in more detail in [3]. General Structure 1111 Based on the design goals mentioned, \nthe general structure of the Ill conceptual design is given by the interfaces and the interplay of the \nrespective objects:  !111 o Interface PersistentObject: Every persistent object i:rtherits from the \nPersistentObject interface; it contains the attributes II and methods to store objects persistently. \nII . Interface Database: The Database interface represents data II!I repositories. In particular, for \neach data repository used, a database object is created. Hence, incorporating new darn repositories amoums \nto creating new objects of this class. We remark that for each type of data repository, there an im-plementation \nof the Database interface is required to capture IIII the specific properties of the system used. II!! \nInterface Transaction: Represents atomic units of work; in particular, accesses to the data repository \nhave to be exe- cuted transactionally. Just as database objects represent data repositories, transaction \nobjects represent database transac- tions. Again, for each type of data repository, there has to be an \nimplementation of the Transaction interface, to capture the specific properties of data access in the \ndata repository tq used.  !!!1 !Ill Figure 1: Loading Object State from Persistent Storage. The f~anctionatity \nof the persistent storage service is explained by two major tasks that service has to fulfill: storing \nobjects in persis- tent storage and loading values from persistent storage. To introduce the loading \nof persistent objects we discuss the steps which are performed to satisfy a request to a persistent ob- \nject. The objects and their relationships involved in satisfying this request are shown in Figure 1. \nThe request is triggered by an ob- ject A calling a public method of persistent object X, marked by (1) \nin Figure 1. First we assume that the requested object is in fact available in volatile storage. In this \ncase, the middleware transfers the request to object X, which processes it and transfers the return values \nto the calling object. (Notice that this default behavior is not shown in the figure, since it does not \ninvolve the persistent storage service.) If, however, persistent object X is not in volatile storage \n(2), the current object state of X has to be loaded from persistent stor- age. Loading object states \nfrom persistent storage is performed by the persistent storage service. In this case, object X is re-initialized \n(3). A loader component provided by the object-oriented middle- ware determines the structure of the \npersistent object by accessing a database object, which returns the structure of the requested ob- ject. \nThis functionality can be provided, for example, by the Persis- tent Object Adaptor [2]. At this moment, \nobject X is in the initial state. Due to the object-oriented approach, object X is responsible for restoring \nits actual state. To do so, X requests a transaction from the database object which is used to store \nX (4). As indicated above, the database object is a representation of the data repository responsible \nfor storing X. In general, for each data repository there is one dedicated database object representing \nthat data repository. Once the database object receives the call from X, it creates a trans- action object \n(5), which is used to retrieve the data from persistent storage. In order to do so, object X sends a \nrequest data message to the transaction object (6), which accesses the data repository to retrieve the \nattribute values of the requested object X from the data repository (7). In the next step, the actual \nvalues are restored in X, the middleware component sends the original method request to the now restored \nobject X (8), which performs the method and returns the values (9) via the middleware to the calling \nobject (I0). Demonstration The demonstration presents and discusses the specification and im- plementation \nof a persistent storage service for the transparent and flexible storage of objects in CORBA environments. \nAn example is prepared to show clearly how the persistent storage service is used and how its works. \nThe example includes a server applica- tion as well as a client application. The server provides persistent \nobjects which can be manipulated by the client using CORBA re- quests. During the demonstration the audience \nwill experience the complete lifecycle of these persistent objects, i.e., creation and ma- nipulation \nof objects by method invocation including the delete() method. The recovery features of the service are \ndemonstrated by a sim- ulated server crash. It will be shown that the objects survive the crash unhurt, \nand each object will be restored to a consistent state on the next access to that object. Finally, a \nlook at the source code of the sample application will show that restoring objects is per- formed completely \ntransparent for the client. A look at the source code of the server will show how the ob- jects are made \npersistent by inheriting from the class Persistent- Object and by defining synchronization points. We \nconcentrate on persistence issues rather than addressing related issues like inter- object transactional \nsupport. However, different implementations of the interfaces are feasible. For instance, different object \nstor- age models can be implemented, and legacy systems can be used as data stores. The system can be \nimplemented in CORBA envi- ronments, using an arbitrary programming language. Our sample implementation \nuses Java and OrbixWeb. We remark that it can be combined with Common Object Services specified by the \nOMG, for example the Relationship Service and the Transaction Service. Conclusions This extended abstract \ndescribes the demonstration of a persistent storage service for object-oriented middleware. The service \nis easy to use, since it suffices to inherit from the PersistentObject class in order to make objects \nof a given class persistent. As explained above, the persistent storage service provides a high degree \nof ex- tensibility and flexibility, since it supports different data reposito- ries and data representations, \neven within a given application. By providing the possibility to store specific attributes of objects, \ni.e., the attributes whose values have changed recently, performance gains can be achieved. While its \nconceptual design is indepen- dent from a specific middleware, a sample implementation uses the C ORBA \nproduct OrbixWeb. Details of the conceptual design of the service and a sample implementation can be \nfound in [3]. REFERENCES [1] Object Management Group: CORBAServices: Common Object Ser- vices Specification. \nOMG Document 98-12-09 1998 [2] OMG:CORBA/IIOP 2.3 Specification. Chapter 11: Portable Object Adaptor. \nOMG Document formal/99-07-15. OMG 1999 [3] Weske, M., Kuropka, D.: Flexible Persistent Storage Service \nfor Object-Oriented Middleware. Fachberieht Angewandte Mathematik und Informatik 5/2000-I, University \nof Muenster, Germany 2000  \n\t\t\t", "proc_id": "367845", "abstract": "", "authors": [{"name": "Dominik Kuropka", "author_profile_id": "81100147869", "affiliation": "Westfalische Wilhelms-Universit&#228;t M&#252;nster, Steinfurter Stra&#946;e 109, 48149 M&#252;nster, Germany", "person_id": "P67844", "email_address": "", "orcid_id": ""}, {"name": "Mathias Weske", "author_profile_id": "81100165441", "affiliation": "Westfalische Wilhelms-Universit&#228;t M&#252;nster, Steinfurter Stra&#946;e 109, 48149 M&#252;nster, Germany", "person_id": "PP31101616", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.368076", "year": "2000", "article_id": "368076", "conference": "OOPSLA", "title": "Transparent and flexible storage of application objects in CORBA environments", "url": "http://dl.acm.org/citation.cfm?id=368076"}