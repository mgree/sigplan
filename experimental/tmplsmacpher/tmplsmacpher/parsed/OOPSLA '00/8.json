{"article_publication_date": "01-01-2000", "fulltext": "\n Remote Access to Clinical Data Andy Schneider BJSS Ltd 1st Floor, Coronet House, Queen Street Leeds \nLS1 4PW, UK as@bjss.co.uk ABSTRACT This practitioner report focuses on a project, named Remote Access \nto Clinical Data (RACD). The report describes the techniques used to clarify the requirements and deliver \nthe project successfully. In addition, it covers the team s experiences in using Sun s JINI to provide \na robust distributed infrastructure for RACD. The presentation will cover these areas in equal depth. \nKeywords Lo-fi, Prototyping, JINI, Lifecycle, Spiral, Requirements 1. Context RACD was to be used within \nthe United Kingdom Nation Health Service (NHS). The RACD project was primarily constrained by cost. For \nRACD to be successful it would have to be available at a low per-user cost and require little administration. \n2. Process 2.1 Inception The project started in September 1999 with a typically (for the software industry) \nvague statement: We would like to provide Internet access to aspects of a patient s clinical data . The \nInternet access would actually be over NHSNet (a private WAN). NHSNet is not as insecure as the Internet \nbut is still considered open to attack. The first step was to select an appropriate process model for \ndevelopment. The spiral lifecycle model was selected for the following reasons: 1. It does not assume \nrequirements are clear. 2. It minimizes risk and uncertainty as the project unfolds. 3. The decision \nabout the final product content is delayed. 4. It provides support for the course corrections that are \nneeded when the product and solution aren t well understood.  We rejected a staged lifecycle because \nit didn t support vague requirements. We also felt the eXtreme Programming model Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for profit or commercial advantage and that copies bear this \nnotice and the full citation on the first page. To copy otherwise, to republish, to post on servers or \nto redistribute to lists, requires prior specific permission and/or a fee. OOPSLA 2000 Companion Minneapolis, \nMinnesota &#38;#169; Copyright ACM 2000 1-58113-307-3/00/10...$5.00 (XP) was inappropriate. The development \nteam was to build the first production release of RACD and then hand it over to another development team \nwithin the organisation. XP relies on a rich oral tradition, we believe a handover requires more formal \ndocumentation than XP should provide. Iterations in the spiral lifecycle must have clear completion criteria. \nWithout these criteria a spiral lifecycle can run out of control and consume resources without ever providing \nthe anticipated output. We specified the iterations as follows: 1. Initial prototyping. Time boxed to \n3 weeks. The success criteria were defined as: Agreed user interface (static and dynamic aspects) and \ncore functionality identified. . 2. Demonstrable prototype. Time boxed to 6 weeks. Produce a working \narchitectural prototype and a static web-site mock up of the user interface. The success criteria were \ndefined as: Architectural prototype meets non functional requirements and supports functional requirements. \nTechnologies proven to be appropriate and web based GUI prototype agreed. Estimate for product development \nagreed. . 3. Working prototype with core functionality. Time boxed to 8 weeks. Produce a working system \nthat exhibits the core functionality and any functionality deemed problematic. The success criteria were \ndefined as: The prototype is considered acceptable from performance and function perspectives, the next \niteration can be executed within the budgetary constraints. . 4. First Candidate Release. Produce the \nworking system for pilot. End date dependent on plan. 5. Final Revision. Integrate feedback into product. \nEnd date dependent on plan.  2.2 Initial prototyping We selected lo-fi prototyping as the mechanism \nfor discovering requirements. Lo-fi prototyping had several advantages: 1. It s portable. An A3 pad and \npencils weighs less than a laptop ;-) 2. Users understand pencil and paper. 3. Computer based tools \ncan get in the way and become the focus, rather than the requirements being the focus. 4. Prototypes \nare easily modified during a discussion.  5. There is no temptation to just ship the prototype it \nworks . 6. Prototypes are easily distributable as scanned images or  photocopies. The initial iteration \nwas exceedingly effective in determining the initial requirement. The iteration came to a close in the \nallotted time period despite large changes in the requirements. 2.3 Second Iteration With the basic \nrequirements agreed (and documented in a sketchpad) we built two systems. We designed a web site that \nwould look and feel like the end system and an architectural prototype to prove our selected technology \nwould perform correctly. The web site was integrated into the company Intranet, so anyone could access \nthe system and provide feedback. 2.4 Third Iteration We enhanced the architectural prototype with core \nfunctionality that the system would have to provide. All the design and code being produced was tested \nto ensure the software performed as expected. From the 2nd iteration onwards we employed the testing \ntechniques embodied in the XP model. Initially we felt unproductive and the generation of the end result \n(code) was far slower than we normally experienced. However, what we were generating was far more reliable. \nThis added reliability improved overall development speed, as less time was spent in debugging. 2.5 \nFourth Iteration Development proceeded in the traditional manner. We continued to use the XP testing \nmodel. The result was an integration and system test that lasted 2 weeks and served to, in the main, \nrubber stamp the product as ready to ship. 2.6 Fifth Iteration We deployed on a test bed and tested \nits use. We observed how staff used the system and logged the performance. From this, we made minor changes \nand the product was then ready to ship. The project was completed on time, despite the new technologies \nused and the vague requirements. 3. The Technology 3.1 Architecture  RACD consisted of: 1. A central \nserver accessible via a web browser that provided authentication services and a way of finding the clinical \ncentre that had a particular patient s records. 2. A server at each clinical centre that enforced access \ncontrol, filtered medical data and provided different views on the clinical data.  3.2 Key Problems \n3.2.1 Access Data had to be encrypted over the wire. Data had to reside at the clinical centre where \nthe clinical records for the patient are held. It could not be cached elsewhere. Control of data access \nhad to be provided at each clinical centre. Patients had to be able to decide what data was to be made \navailable outside the clinic. 3.2.2 Reliability Computer failure at a clinical centre could not affect \nthe rest of RACD. RACD had to be able to provide some form of load balancing and fail over.  3.3 Technology \nSelection We needed middleware that would support LAN and WAN based distribution. EJB couldn t be used \nbecause of the cost implications. Open source EJB servers we looked at weren t mature enough for commercial \ndeployment. Commercial servers had costs associated with them that the RACD budget and licensing price \ncouldn t support. We chose JINI as our distribution middleware. JINI was selected, despite its immaturity, \nbecause it offered a development model that explicitly supported handling of the unreliability associated \nwith network based services 3.4 Experience 3.4.1 JINI and the internet We had significant problems getting \nJINI and RMI working across firewalls. In the end we removed JINI from the WAN side of the architecture \nand replaced it with an HTTP based protocol. 3.4.2 JINI and security We used full strength SSL over \nthe WAN and provided switchable support for SSL for the JINI services. All JINI communities existed behind \nthe firewall. Aside from problems with SUN s HTTP URL connection support, this worked very effectively. \n 3.4.3 JINI and robustness We operated duplicate JINI services to allow fail over in case a JINI service \ncrashed. JINI provided an excellent platform for the provision of robust behaviour in the face of service \nfailure. 4. Summary We found JINI to be an excellent platform for network based applications, providing \nexpectations were limited to LAN based deployment. We found the spiral lifecycle and lo-fi prototyping \nto be very effective. Finally, deploying the testing approach recommended in eXtreme Programming yielded \na system that, ironically, needed less testing than otherwise.  \n\t\t\t", "proc_id": "367845", "abstract": "<p>This practitioner report focuses on a project, named &#8220;Remote Access to Clinical Data&#8221; (RACD). The report describes the techniques used to clarify the requirements and deliver the project successfully. In addition, it covers the team's experiences in using Sun's JINI to provide a robust distributed infrastructure for RACD. The presentation will cover these areas in equal depth.</p>", "authors": [{"name": "Andy Schneider", "author_profile_id": "81100155495", "affiliation": "BJSS Ltd., 1lt;supgt;stlt;/supgt; Floor, Coronet House, Queen Street, Leeds LS1 4PW, UK", "person_id": "P18822", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367902", "year": "2000", "article_id": "367902", "conference": "OOPSLA", "title": "Remote access to clinical data", "url": "http://dl.acm.org/citation.cfm?id=367902"}