{"article_publication_date": "01-01-2000", "fulltext": "\n Towards a Two-dimensional Separation of Concerns Constantinos A. Constantinides Department of Computer \nScience Illinois Institute of Technology, Chicago conscon @ charlie.cns.iit.edu ABSTRACT As the size \nand requirements of software systems increase, their de\u00adsign has reached a complexity that requires software \nengineers to revisit the principle of separation of concerns [5]. Traditional soft\u00adware organization \nhas been performed along some form of functional decomposition. Different paradigms and languages support \nthe im\u00adplementation, and composition of sub-parts into whole systems through the availability of some \nmodular unit of functionality (com\u00adponent). In essence, traditional software decomposition and current \nprogramming languages have been mutually supportive [4]. At the same time, separation of concerns can \nonly be beneficial if the differ\u00adent concerns can be effectively composed to produce the overall sys\u00adtem. \nThe OOP paradigm seems to work well only if the problem to be solved can be described with relatively \nsimple interfaces among ob\u00adjects. Unfortunately, this is not the case when we move from se\u00adquential programming \nto concurrent programming where the compo\u00adnent interaction violates simple object interfaces. One of \nthe reasons behind this is the inherent structure of today s software systems that conceptually does \nnot lead itself to a safe decomposition. As a result, the benefits associated with OOP no longer hold. \nComponent inter\u00adactions limit reuse and make it difficult to validate the design and correctness of software \nsystems. Reengineering of these systems is needed in order to meet future changes in requirements. This \ncom\u00adponent interaction is based on a number of properties that affect the semantics or the performance \nof the system and do not localize well in one modular unit, but tend to cut-across groups of components \nresulting in a code tangling [4]. Example cross-cutting properties (or aspects) include synchronization, \nscheduling, and fault tolerance. This code tangling destroys modularity, making the source code dif\u00adficult \nto develop and difficult to understand. It also limits reuse, making the source code difficult to evolve. \nIt further makes programs more error prone. In essence, it destroys the quality of the software. In [1] \nthe authors refer to these phenomena as composition anoma\u00adlies . This composition anomaly requires a \nshift in the methodolo\u00adgies used to separate concerns. In conjunction with modular compo\u00adsition, adaptability \nand reuse remain major issues to be considered while building complex software systems. Aspect-Oriented \nPro\u00adgramming (AOP) [4] is an emerging methodology that addresses components and aspects at the analysis \nand design phase of the soft\u00adware life-cycle, using mechanisms to compose them at the imple\u00admentation \nlevel with a growing number of different technologies. Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for profit or commercial advan\u00adtage and that copies bear this notice and the full \ncitation on the first page. To copy otherwise, to republish, to post on servers or to redis\u00adtribute to \nlists, requires prior specific permission and/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota \n(c) Copyright ACM 2000 1-58113-307-3/00/10...$5.00 Tzilla Elrad Department of Computer Science Illinois \nInstitute of Technology, Chicago elrad @ iit.edu 1. Introduction to the Aspect Moderator Frame\u00adwork \nOur work concentrates on concurrent programming while focusing on a number of requirements such as separation \nof concerns, adaptabil\u00adity, and reuse. Quality, stability, and productivity are also main con\u00adcerns. \nQuality is guaranteed if we can reuse proven solutions like design patterns. Further, stability is realized \nif we ensure that the resulting software system is adaptable enough to meet future re\u00adquirement and productivity \ncan be improved if we increase the num\u00adber of the deployed design patterns. Another goal is the provision \nof a model that is free of concurrency problems such as the inheritance anomalies and priority inversion. \nThe model must further apply to general-purpose languages. Another goal is to provide an implemen\u00adtation \nthat will be easy to use. Overall performance is also a concern. The speed and memory tradeoff for increased \nflexibility must be minimized. The end result must be useable in a practical setting. In the Aspect Moderator \nframework a concurrent system is composed as a cluster of co-operating classes where components and aspects \nare designed relatively separately from each other. Access to a functional component is controlled by \na proxy object. The creation of aspect objects is done during the initialization phase by deploying the \nFac\u00adtory Method pattern [3] (Fig 1). The intent of the factory method pattern is to define an interface \nfor creating an aspect object, but let the requestor decide which class to instantiate. ComponentProxy \n1 Requests-creation  Figure 1. Creating aspect objects using the Factory Method pattern. Using the organization \nshown, the component proxy acts as a crea\u00adtion requestor for aspect objects. It does so indirectly by \ncalling the createAspect() method of an instance of a factory class that imple\u00adments the AspectFactoryIF \ninterface. It passes some parameters to the createAspect() method that tells that method which class \nthat imple\u00adments the AspectIF interface to instantiate. The AspectFactoryIF is an application-independent \ninterface. It declares the factory method, which returns an object of type AspectIF by taking whatever \nargu\u00adments are needed to deduce the class to instantiate. The AspectFac\u00adtory is an application-specific \nclass. It implements the factory method to return an instance of ConreteAspect. The AspectIF defines \nthe interface of objects the factory method creates. The ConcreteAspect is a concrete class instantiated \nby the objects that participate in the Factory Method pattern. Each aspect is implemented by a set of \nas\u00adsertions, which are defined by the AspectIF interface. As aspect ob\u00adjects are first class abstractions \n(values), they can be stored in an array within the aspect moderator object during the initialization \nphase. Further, they can be referenced (accessed) from the array. Upon creation of the aspect objects, \nthe proxy will call the aspect moderator object to store (register) these aspect objects for reference \nduring the next (method invocation) phase (Fig 2). :Functionality Proxy :Aspect Moderator :Aspect Factory \n* [for all participating methods] (create aspect)  new * [for all aspect objects] (register aspect) \n  :Aspect Figure 2. Sequence diagram of the initialization phase. Every method in the proxy object that \nis associated with an aspect (participating method) is executed within a pre-activation and post\u00adactivation \nphase. The pre- and post-activation phases are defined by the AspectModerator class. Upon a message reception \nthat involves a participating method, the proxy will delegate the responsibility to the aspect moderator \nto evaluate the pre-activation phase (Fig 3). The moderator will, in turn, evaluate all required aspects \n(in some speci\u00adfied order) of the participating method by calling the precondition of all required aspects. \nACTOR :Aspect Moderator :Aspect Functionality event preActivation (event)  precondition(event) [precondition \n== resume] event [precondition == resume] postcondition Figure 3. Sequence diagram of the method invocation \nphase. Upon successful return of the preactivation phase, the proxy will call the participating method \nin the actual component. Once execution is complete, the proxy will initiate the postactivation phase, \nby dele\u00adgating responsibility to the moderator to evaluate the post-activation of the given method. During \nthis phase, the aspect moderator will call the postcondition of the required aspects (also in some specified \nor\u00adder). We stress the fact that the activation order of the aspects is the most important part in order \nto verify the semantics of the system. The UML class diagram of the Aspect Moderator framework is shown \nin Figure 4. This framework manages to retain separation of concerns in all stages of the development. \nThis clean separation allows for maximum reus\u00adability. The framework has been also demonstrated by example \nim\u00adplementations [2] in the Java language, although it remains language\u00adneutral. It has further been \ndemonstrated to provide an adaptable model that allows for an open language. This model can address those \naspects whose relationships with components can be cleanly supported through the use of assertions. \nFigure 4. The class diagram of the Aspect Moderator framework.  REFERENCES [1]Lodewijk Bergmans and \nMehmet Aksit. Composing Software from Multiple Concerns: A Model and Composition Anomalies. Po\u00adsition \npaper to the ICSE 2000 2nd Workshop on Multidimensional Separation of Concerns. Limerick, Ireland. June \n6, 2000. [2] Constantinos A. Constantinides, Atef Bader and Tzilla Elrad. Separation of Concerns in the \nDesign of Concurrent Software Sys\u00adtems. ECOOP 2000 Workshop on Aspects and Dimensions of Con\u00adcerns. [3] \nErich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns; Elements of Reusable Object-Oriented \nSoftware. Addison Wesley Longman, Inc. 1995. [4] Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris \nMaeda, Cristina Lopes, Jean-Marc Loingtier, and John Irving. Aspect Oriented Programming. Proceedings \nof the 11th European Conference on Object-Oriented Programming (ECOOP '97). [5] D. L. Parnas. On the \nCriteria to be used in Decomposing Systems into Modules. In Communications of the ACM. Vol. 15. No. 12. \nPages 1053-1058. December 1972.  \n\t\t\t", "proc_id": "367845", "abstract": "<p>As the size and requirements of software systems increase, their design has reached a complexity that requires software engineers to revisit the principle of separation of concerns [5]. Traditional software organization has been performed along some form of functional decomposition. Different paradigms and languages support the implementation, and composition of sub-parts into whole systems through the availability of some modular unit of functionality (component). In essence, traditional software decomposition and current programming languages have been mutually supportive [4]. At the same time, separation of concerns can only be beneficial if the different concerns can be effectively composed to produce the overall system. The OOP paradigm seems to work well only if the problem to be solved can be described with relatively simple interfaces among objects. Unfortunately, this is not the case when we move from sequential programming to concurrent programming where the component interaction violates simple object interfaces. One of the reasons behind this is the inherent structure of today's software systems that conceptually does not lead itself to a safe decomposition. As a result, the benefits associated with OOP no longer hold. Component interactions limit reuse and make it difficult to validate the design and correctness of software systems. Reengineering of these systems is needed in order to meet future changes in requirements. This component interaction is based on a number of properties that affect the semantics or the performance of the system and do not localize well in one modular unit, but tend to cut-across groups of components resulting in a &#8220;code tangling&#8221; [4]. Example cross-cutting properties (or aspects) include synchronization, scheduling, and fault tolerance. This code tangling destroys modularity, making the source code difficult to develop and difficult to understand. It also limits reuse, making the source code difficult to evolve. It further makes programs more error prone. In essence, it destroys the quality of the software. In [1] the authors refer to these phenomena as &#8220;composition anomalies&#8221;. This composition anomaly requires a shift in the methodologies used to separate concerns. In conjunction with modular composition, adaptability and reuse remain major issues to be considered while building complex software systems. Aspect-Oriented Programming (AOP) [4] is an emerging methodology that addresses components and aspects at the analysis and design phase of the software life-cycle, using mechanisms to compose them at the implementation level with a growing number of different technologies.</p>", "authors": [{"name": "Constantinos A. Constantinides", "author_profile_id": "81100009381", "affiliation": "Department of Computer Science, Illinois Institute of Technology, Chicago", "person_id": "P50008", "email_address": "", "orcid_id": ""}, {"name": "Tzilla Elrad", "author_profile_id": "81100137728", "affiliation": "Department of Computer Science, Illinois Institute of Technology, Chicago", "person_id": "PP14058901", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367938", "year": "2000", "article_id": "367938", "conference": "OOPSLA", "title": "Towards a two-dimensional separation of concerns (poster session)", "url": "http://dl.acm.org/citation.cfm?id=367938"}