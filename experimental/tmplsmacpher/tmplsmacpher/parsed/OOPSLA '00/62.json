{"article_publication_date": "01-01-2000", "fulltext": "\n Pro.le-Driven Pretenuring for Java Stephen M. Blackburn John Cavazos Sharad Singhai Asjad Khan Kathryn \nS. McKinley J. Eliot B. Moss Sara Smolensky Architecture and Language Implementation Laboratory, Department \nof Computer Science University of Massachusetts, Amherst, MA 01003-4610  Overview Pretenuring is a technique \nfor reducing copying costs in garbage collectors. When pretenuring, the allocator places long-lived ob\u00adjects \ninto regions that the garbage collector will rarely, if ever, col\u00adlect. We extend previous work on pro.ling-driven \npretenuring as follows. (1) We develop a collector-neutral approach to obtaining object lifetime pro.le \ninformation. We show that our collection of Java programs exhibits a very high degree of homogeneity \nof object lifetimes at each allocation site. This result is robust with respect to different inputs, \nand is similar to previous work on ML, but is in contrast to C programs, which require dynamic call chain \ncon\u00adtext information to extract homogeneous lifetimes. Call-site homo\u00adgeneity considerably simpli.es \nthe implementation of pretenuring and makes it more ef.cient. (2) Our pretenuring advice is neutral with \nrespect to the collector algorithm, and we use it to improve two quite different garbage collectors: \na traditional generational collector and an older-.rst collector. The system is also novel be\u00adcause it \nclassi.es and allocates objects into 3 categories: we al\u00adlocate immortal objects into a permanent region \nthat the collector will never consider, long-lived objects into a region in which the collector placed \nsurvivors of the most recent collection, and short\u00adlived objects into the nursery, i.e., the default \nregion. (3) We evalu\u00adate pretenuring on Java programs. Our simulation results show that pretenuring signi.cantly \nreduces collector copying for generational and older-.rst collectors. 1. MOTIVATION AND APPROACH Generational \ncopying garbage collection partitions the heap into age-based generations of objects, where age is measured \nin the amount of allocation (the accepted practice in the garbage collec\u00adtion literature). Collection \nconsists of three phases: (1) identifying roots for collection; (2) identifying and copying into a new \nspace any objects identi.ed as live through transitive reachability from those roots; and (3) reclaiming \nthe space vacated by the live ob\u00adjects. Rather than collecting the entire heap and incurring the cost \nof copying all live objects upon each invocation, generational col\u00adlectors collect the youngest objects \nin the heap, the nursery, and include successively older generations only if necessary. This basic approach \nhas two problems. First, the collector may Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota . c Copyright ACM 2000 \n1-58113-307-3/00/10...$5.00 copy long lived objects multiple times (into higher generations). Second, \nthe most recently allocated objects in the nursery have lit\u00adtle time to die, and the collector may copy \nmany of them, even if they have short lifetimes. The main focus of this work is using pre\u00adtenuring to \nsolve the .rst problem, but we also combine pretenuring with a solution to the latter problem that collects \nolder objects be\u00adfore younger ones [Stefanovi\u00b4c et al. 1999]. An ideal pretenuring algorithm would inform \nthe allocator of the exact lifespan of a new object, and then the allocator would select the ideal generation \nin which to place the object. The collector would thus consider an object only after it has suf.cient \ntime to die, avoiding copying it from the nursery and perhaps other gener\u00adations. If an object will die \nbefore the next nursery collection, then the allocator places it in the nursery (the default), whereas \nif the object lives until the termination of the program, then the allocator places the object into a \npermanent region. The use of pretenuring is not limited to generational collectors; any collector that \ndivides the heap into regions and delays or prevents collection of some re\u00adgions will bene.t from such \ninformation. We present simulation results for both generational and older-.rst [Stefanovi\u00b4c et al. 1999] \ncollectors with pretenuring. Without an oracle, pretenuring advice can be gleaned from appli\u00adcation pro.ling \non a per allocation-site [Cheng et al. 1998] or call\u00adchain [Barrett and Zorn 1993; Seidl and Zorn 1998] \nbasis. For our collection of Java programs, we found that allocation-site advice re\u00adsults in accurate \npredictions. These results are robust over different input data. The results are similar to those for \nML programs [Cheng et al. 1998], whereas C programs need the additional context of a call-chain [Barrett \nand Zorn 1993; Seidl and Zorn 1998]. Our pretenuring advice is unique in that it is neutral with respect \nto the collector algorithm, and we use the same advice to improve two collectors. Instead of pretenuring \nbased on whether the objects at a call site survive a nursery collection, as in previous work [Cheng \net al. 1998], we use two object lifetime statistics measured in bytes allocated: age and time of death. \nObject age refers to how long an object lives in bytes of allocation, while time of death refers to the \npoint in the allocation history of the program at which the ob\u00adject becomes unreachable. We then classify \neach object as either immortal the time of death was at the end of the program, short lived it lives \nless than some fraction of the maximum live size of the heap, or long lived everything else. Each call \nsite is given a classi.cation that is representative of the objects allocated at that site. We then modify \nthe allocator statically as follows. For an im\u00admortal site, the allocator places objects into a permanent \nregion that the collector will never consider (previous work scanned but did not copy these objects [Cheng \net al. 1998]). For a long-lived site, objects go into a region into which the collector normally copies \nsurvivors of collections. For short-lived sites, allocation remains the same. 2. ALLOCATION SITE HOMOGENEITY \nWe analyze age and lifetime statistics using an execution pro.le for each application. The pro.le takes \nthe form of an object graph mu\u00adtation trace, which records all object allocations, pointer mutations, \nand object deaths in our JVM. We instrument all allocations, write barriers to track pointer mutations, \nand when the collector frees an object. To obtain the accurate object death information, we trigger a \nnon-generational, full heap collection frequently. We associate pretenuring advice in a tag for each \nallocation site using three discrete classi.cations: short, long, and immortal. We normalize our measures \nof time in terms of the max live size , i.e., maximum amount of live objects, which is equivalent to \nthe minimum heap size in which the application can execute. The following algorithm is used: 2. If an \nobject s age is less than l Ta max live size bytes, then it is classi.ed short. 2. Otherwise, if l an \nobject s time of death is within Td max live size bytes of the end of allocation, then it is classi.ed \nimmortal. 3. In all other cases, an object is classi.ed long. To assess the level of per site homogenity, \nwe classify objects as (short (s), long (l), and immortal (i)) on both a per object and per site basis. \nWe examine the per object (exact) and per site (represen\u00adtative) decisions for each object to establish \nthe level of error in the per site decisions. We classify each decision in terms of the nine decision \npairs that arise from the cross product of the two three\u00ad rrrr way choices ( so, ss), so, ls), so, is \n), lo, ss ), t t ), where ao and as refer to object and site advice respectively. The nine decision pairs \nfall into three categories: neutral, bad, and good with respect to the non-pretenured status quo. Neutral \npre\u00ad rrr tenuring advice ( so ,ss ), lo ,ss ), and io ,ss )) allocates all the ob\u00ad rr jects into the \nnursery. Bad pretenuring advice ( so ,ls), so ,is), and r lo ,is )) leads to space wastage through deferred \ncollection of ob\u00ad rrr jects that die. Good pretenuring advice ( lo ,ls), io ,ls ), and io ,is )) delays \ncollection of long lived objects and completely avoids col\u00adlection of immortal objects. On average 98.2% \nto 99.3% of pretenuring decisions are good or neutral. The majority of pretenuring decisions are neutral, \nand a signi.cant fraction are good. In particular, about 9% of allocations of immortal objects are homogeneous \nenough to pretenure into the permanent space, and we allocate an additional 2% into the long lived space. \nWe identify about 4% as long lived objects. 3. SIMULATION RESULTS We implemented this technique in a \nsimulator using self predic\u00adtion (pro.le information from the same input), and true prediction (pro.le \ninformation from a different program input).1 The simu\u00adlation results show our pretenuring algorithm \nsigni.cantly reduces collector copying for generational and older-.rst collectors, and is robust with \nrespect to different inputs. We used traces of four ap\u00adplications in our simulation, jBYTEmark, javac, \nthe Olden health benchmark, and a bytecode optimization and analysis tool, bloat . When using self predicting \npretenuring advice, we found that for the four applications all showed some reduction in copying cost \nwhen using a conventional generational collector. For javac and health, the improvement was generally \na reduction of 45% to 85%. 1The terms self prediction and true prediction are coined by Barrett and Zorn \n[1993]. For bloat the reduction was from 5% to 15%, and for jBYTEmark the improvement was negligible, \nwith some results marginally bet\u00adter and some marginally worse. Our results for the older .rst col\u00adlector \n[Stefanovi\u00b4c et al. 1999] were very similar, although overall copying costs (with and without pretenuring) \nwere lower and for jBYTEmark pretenuring resulted in a slightly higher copying cost. We ran javac and \nhealth with varying inputs and were thus able to assess the performance of our pretenuring advice using \ntrue pre\u00addiction. Advice was generated on the basis of one execution of each of the benchmarks and then \napplied to executions with differ\u00adent inputs. For health this resulted in major changes to the scale \nof the program execution (number of bytes allocated varied by a factor of about 16), whereas for javac \nwe compiled different pro\u00adgrams and so exercised different areas of the program. Using the generational \ncollector, we saw perfect true prediction for health the pretenuring advice was robust to such large \nchanges in the heap size and volume of allocation. The effectiveness of true prediction was more variable \nfor javac, generally there were improvements from about 5% to 50%, but very occasionally true prediction \nlead to an increase in copying. The results for the older .rst collector were very similar, although \nthe improvements for javac were more modest. 4. CONCLUSIONS Our principal conclusions are as follows. \nJava programs exhibit re\u00admarkable lifetime homogeneity at each allocation site which makes effective \npretenuring easy and cheap to implement. We character\u00adize lifetime in a simple way, largely insensitive \nto parameters or to varying program inputs. This characterization is independent of collection algorithm \nand con.guration, as witnessed by our results for two different collection algorithms. Pretenuring is \noften effec\u00adtive in reducing object copying for Java programs for both gener\u00adational and older-.rst collectors. \nThe result is that pretenuring for Java is quite promising for reducing memory management costs.  Bibliography \n BARRETT, D. A. AND ZORN, B. 1993. Using lifetime predic\u00adtors to improve memory allocation performance. \nIn Proceedings of the ACM SIGPLAN 93 Conference on Programming Lan\u00adguage Design and Implementation (PLDI), \nAlbuquerque, New Mexico, June 23-25, 1993, Volume 28 of SIGPLAN Notices (June 1993), pp. 187 196. ACM. \nCHENG, P., HARPER, R., AND LEE, P. 1998. Generational stack collection and pro.le-driven pretenuring. \nIn Proceedings of the ACM SIGPLAN 98 Conference on Programming Lan\u00adguage Design and Implementation (PLDI), \nMontreal, Canada, 17-19 June 1998, Volume 33 of SIGPLAN Notices (May 1998), pp. 162 173. ACM. SEIDL, \nM. L. AND ZORN, B. G. 1998. Segregating heap ob\u00adjects by reference behavior and lifetime. In ASPLOS-VIII \nPro\u00adceedings of the 8th International Conference on Architectural Support for Programming Languages and \nOperating Systems, San Jose, California, October 3-7, 1998, Volume 33 of SIG-PLAN Notices (Nov. 1998), \npp. 12 23. ACM. STEFANOVI C\u00b4, D., MCKINLEY, K. S., AND MOSS, J. E. B. 1999. Age-based garbage collection. \nIn Proceedings of the 1999 ACM SIGPLAN Conference on Object-Oriented Programming Sys\u00adtems, Languages \n&#38; Applications (OOPSLA 99), Denver, Col\u00adorado, November 1-5, 1999, Volume 33 of SIGPLAN Notices (Nov. \n1999), pp. 379 381. ACM. \n\t\t\t", "proc_id": "367845", "abstract": "", "authors": [{"name": "Stephen M. Blackburn", "author_profile_id": "81100547435", "affiliation": "Architecture and Language Implementation Laboratory, Department of Computer Science, University of Massachusetts, Amherst, MA", "person_id": "P268028", "email_address": "", "orcid_id": ""}, {"name": "John Cavazos", "author_profile_id": "81100096445", "affiliation": "Architecture and Language Implementation Laboratory, Department of Computer Science, University of Massachusetts, Amherst, MA", "person_id": "PP39026940", "email_address": "", "orcid_id": ""}, {"name": "Sharad Singhai", "author_profile_id": "81100424832", "affiliation": "Architecture and Language Implementation Laboratory, Department of Computer Science, University of Massachusetts, Amherst, MA", "person_id": "PP39042175", "email_address": "", "orcid_id": ""}, {"name": "Asjad Khan", "author_profile_id": "81100345181", "affiliation": "Architecture and Language Implementation Laboratory, Department of Computer Science, University of Massachusetts, Amherst, MA", "person_id": "P22641", "email_address": "", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "Architecture and Language Implementation Laboratory, Department of Computer Science, University of Massachusetts, Amherst, MA", "person_id": "P157900", "email_address": "", "orcid_id": ""}, {"name": "J. Eliot B. Moss", "author_profile_id": "81406593781", "affiliation": "Architecture and Language Implementation Laboratory, Department of Computer Science, University of Massachusetts, Amherst, MA", "person_id": "PP39023945", "email_address": "", "orcid_id": ""}, {"name": "Sara Smolensky", "author_profile_id": "81100169449", "affiliation": "Architecture and Language Implementation Laboratory, Department of Computer Science, University of Massachusetts, Amherst, MA", "person_id": "P260151", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.368029", "year": "2000", "article_id": "368029", "conference": "OOPSLA", "title": "Profile-driven pretenuring for Java (poster session)", "url": "http://dl.acm.org/citation.cfm?id=368029"}