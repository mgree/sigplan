{"article_publication_date": "01-01-2000", "fulltext": "\n ESCORT: Lessons from an Integration Project Andrea Savigni Filippo Cunsolo Francesco Tisato DISCO - \nUniversit\u00e0 di Milano-Bicocca Project Automation S.p.A. DISCO - Universit\u00e0 di Milano-Bicocca Via Bicocca \ndegli Arcimboldi 8 Viale Elvezia 42 Via Bicocca degli Arcimboldi 8 20126 Milano, Italy 20052 Monza (MI), \nItaly 20126 Milano, Italy +39.02.6448.7874 +39.039.2806.1 +39.02.6448.7834 savigni@disco.unimib.it filippo.cunsolo@p-a.it \ntisato@disco.unimib.it ABSTRACT We present the key lessons learned from the ESCORT European project. \nESCORT is concerned with integrating diverse applications and devices for traffic control at the intersection \nlevel. The paper emphasises the difficulty of breaking existing, vertical products to build an integration \nplatform, and the role of object technology (and UML in particular) in this context. Keywords UML, integration \nplatforms, object technology. 1. INTRODUCTION ESCORT (European Standard Controller with Advanced Road \nTraffic Sensors) is a European Union-funded project begun in January 1998 and ended in March 2000. ESCORT \ndeals with the development of a new philosophy of traffic control, based on integration of heterogeneous \ndevices and applications for traffic control at intersection level. Thus, contrary to most projects in \nthe traffic control area, the focus of ESCORT is on software engineering, and particularly integration. \nTraffic control at the intersection level is taken care of by a number of devices (traffic lights, local \ntraffic controller(s), inductive loops, cameras) and applications (for intelligent traffic control, incident \ndetection, vehicle enforcement). From a software engineering point of view, the current situation in \nintersection control is archaic. Concepts such as separation of concerns and integration are unknown. \nApplications are vertical and monolithic, and intermix domain-oriented and device-dependent issues. The \nmarket is monopolised by a few vendors who sell complete, vertical, proprietary solutions, from devices \nup to applications. Thus, one cannot, for example, buy cameras from one vendor and applications from \nanother one. This paper describes the AMI (Abstract Model of Intersection), which is the heart of the \nproject. The AMI is a reference platform against which to build new devices and applications. If and \nwhen the AMI becomes an accepted industrial standard, application and Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for profit or commercial advantage and that copies bear this notice \nand the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior specific permission and/or a fee. OOPSLA 2000 Companion Minneapolis, Minnesota \n&#38;#169; Copyright ACM 2000 1-58113-307-3/00/10...$5.00 device vendors will be able to build AMI-compliant \nproducts, which will provide for seamless integration among heterogeneous, multi-vendor devices and applications. \nIn the short term two more layers proved necessary, namely IWA (Interface With Applications) and IWD \n(Interface With Devices), which allow existing devices and applications to interface the AMI without \nbeing changed in any way. The overall outcome of the project (AMI+IWA+IWD) is now a working product and \nis being tested in three actual intersections in Milan, Paris, and Valencia. 2. THE AMI DESIGN The AMI \nmodel was conceived to meet several different requirements, among which: completeness (it must represent, \nat an appropriate abstraction level, all the entities in the underlying physical intersection), extensibility, \nefficiency (as some devices and applications have real-time requirements). The AMI was designed using \nthe UML, and is made up by four packages: Static, Logical, Management, and Control. Figure 1 shows the \noverall relationships between the AMI packages, on the one side, and the interfaces to devices and applications, \non the other side. The dependency relationships are one-way. This means that the AMI is never aware of \nIWA and IWD (in other words, it acts as a server for them). Figure 1. The AMI packages. In the sequel \nwe will briefly describe the contents of the packages. The Static package contains the topological model \nof the intersection. Concepts such as lanes and zones are represented, which are not meant to change \nduring program execution. The Logical package contains the representation of dynamic information, whose \nstate can be observed (e.g., traffic flows) or controlled (e.g., allowed vehicle movements). These abstract \nconcepts allow applications to observe and control the state of the intersection without any knowledge \nabout the physical devices. Thus, this package only contains classes such as ZoneSensor (an abstract \noccupancy meter) or GateSensor (an abstract flow meter), but nothing is said here about the implementation \nof these abstract devices (e.g., via a camera or a set of loops). Classes in the Management package represent \nthe physical counterparts of those in the Logical package. Therefore, this package contains classes such \nas Camera or Loop, which model all the state information related to the functioning (e.g., working/non \nworking) and to the tuning of these concrete devices. Keeping the two representations (logical and physical) \nseparate is essential for the following reasons: separation of concerns. Traffic control applications \nmust not know about abstract devices implementation, which can therefore freely change (e.g., by substituting \nloops with cameras). However, management applications (and human technicians) need to know all the details \nabout the internal workings of applications and devices (e.g., for diagnostic purposes);  cardinality. \nThe same real-world entity can be represented by n logical entities and by m physical ones. For example, \nan instance of a TrafficLightGroup (Logical package) represents a group of traffic lights that are bound \nto always have the same colour, and that are therefore represented as a single object. However, each \nof those traffic lights is modelled as one entity in the Management package because, for instance, traffic \nlight bulbs burn independently of one another.  Finally, the Controlpackage contains highly specialised, \ntraffic control-related concepts, and will thus not be further covered. 3. THE DYNAMIC BEHAVIOUR The \nsystem s dynamic behaviour was conceived with reuse in mind. This led to the adoption of the following \nprinciples: it must be possible for the designers to define the system s dynamic behaviour without changing \nthe AMI static models (class diagrams, package structure, etc.). This is a strict requirement because \neach installation must meet specific constraints; for example, different local controllers can have very \ncontrasting time requirements. Thus:  all entities in the AMI are passive objects, i.e., they have no \nautonomous thread of execution. All time-related functionality is taken care of outside the AMI. The \nlocal controller clock was chosen as the reference clock, and both the AMI and the applications synchronise \non that;  a significant state change of an AMI entity generates an event. The Observer pattern is employed \nfor notifications from the AMI. IWAs and IWDs can register on AMI entities and be notified when something \nrelevant happens.  4. IMPLEMENTATION ISSUES The partners agreed on a C++ implementation using Microsoft \ns COM technology on Windows NT. A component-based technology was chosen due to the strict and clean separation \nbetween the AMI and its clients (potentially unknown in number and technology), that must not know about \nAMI internals. The AMI was implemented as a COM component made up by one executable file (which is little \nmore than a startup utility) and four DLLs (corresponding to the four packages). Clients (IWD and IWA) \ncan follow a simple, standard, extensively-documented procedure to connect to the AMI and use its services. \nThis implementation allows developers in the future to change a package (or even to add new ones) in \na seamless way. 5. LESSONS LEARNED ESCORT was a complex project, for a number of reasons: diversity \nof partners background. In particular, difficulties arose between partners with a strong object technology \nbackground and others strongly focused on optimisation issues and highly experienced in bare metal programming. \nMany of the key design decisions were the result of compromises between the two parties;  integrating \nexisting systems is notoriously harder than building them anew. While the long-term goal of ESCORT is \nto provide a common platform for new systems, its short\u00adterm goal is to integrate existing ones. Thus, \na very hard modelling work was necessary in order to take into account the very diverse existing devices \nand applications;  the initial scheduling was quite tight and actually proved too tight: a three-month \nextension was requested to, and obtained by, the EU. This delay seems frankly quite reasonable for a \ntwo-year project.  Despite the above difficulties, the project was successfully completed. The system \nis fully implemented and is working in all of the three intersections. Two annual reviews were completed \nand received very good ratings by the EU committee. Under many respects, ESCORT taught us many lessons: \n probably there was no need of proving that, but conceptual modelling turned out to be the really key \nissue in the overall project lifecycle. The UML proved precious even in this very technical, specialised \nfield (and not only in business-oriented software, as many people maintain);  the design activity is \ntoo often underestimated, and ESCORT was no exception. After a very careful modelling work, not enough \neffort was spent on design. Instead, implementation started prematurely, based on a model that was not \ndetailed enough, and many key design decisions were left to developers. This, combined with the physical \ndistribution of the partners (coming from five different European countries), led to some divergence \namong the different packages and (inevitably) to integration problems;  object orientation is a very \npopular buzzword but a largely ignored practice. Everybody these days claims to be object\u00adoriented but \nthis project, among others, taught us that actual object-oriented practice is still out of reach of many \nsoftware professionals.  \n\t\t\t", "proc_id": "367845", "abstract": "<p>We present the key lessons learned from the ESCORT European project. ESCORT is concerned with integrating diverse applications and devices for traffic control at the intersection level. The paper emphasises the difficulty of breaking existing, vertical products to build an integration platform, and the role of object technology (and UML in particular) in this context.</p>", "authors": [{"name": "Andrea Savigni", "author_profile_id": "81100015941", "affiliation": "DISCO, Universit&#224; di Milano-Bicocca, Via Bicocca degli Arcimboldi 8, 20126 Milano, Italy", "person_id": "P17197", "email_address": "", "orcid_id": ""}, {"name": "Filippo Cunsolo", "author_profile_id": "81100208892", "affiliation": "Project Automation S.p.A., Viale Elvezia 42, 20052 Monza (MI), Italy", "person_id": "P84385", "email_address": "", "orcid_id": ""}, {"name": "Francesco Tisato", "author_profile_id": "81100418994", "affiliation": "DISCO, Universit&#224; di Milano-Bicocca, Via Bicocca degli Arcimboldi 8, 20126 Milano, Italy", "person_id": "PP39041923", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/367845.367921", "year": "2000", "article_id": "367921", "conference": "OOPSLA", "title": "ESCORT: lessons from an integration project", "url": "http://dl.acm.org/citation.cfm?id=367921"}