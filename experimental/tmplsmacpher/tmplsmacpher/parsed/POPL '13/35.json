{"article_publication_date": "01-23-2013", "fulltext": "\n Hyperstream Processing Systems Nonstandard Modeling of Continuous-Time Signals Kohei Suenaga Hiroyoshi \nSekine Ichiro Hasuo Kyoto University University of Tokyo ksuenaga@kuis.kyoto-u.ac.jp {nue of k,ichiro}@is.s.u-tokyo.ac.jp \n Abstract We exploit the apparent similarity between (discrete-time) stream processing and (continuous-time) \nsignal processing and transfer a deductive veri.cation framework from the former to the latter. Our development \nis based on rigorous semantics that relies on nonstandard analysis (NSA). Speci.cally, we start with \na discrete framework consisting of a Lustre-like stream processing language, its Kahn-style .xed point \nsemantics, and a program logic (in the form of a type system) for partial correctness guarantees. This \nstream framework is trans\u00adferred as it is to one for hyperstreams streams of streams, that typically \narise from sampling (continuous-time) signals with pro\u00adgressively smaller intervals via the logical infrastructure \nof NSA. Under a certain continuity assumption we identify hyperstreams with signals; our .nal outcome \nthus obtained is a deductive veri.\u00adcation framework of signals. In it one veri.es properties of signals \nusing the (conventionally discrete) proof principles, like .xed point induction. Categories and Subject \nDescriptors F.3.1 [Logics and Mean\u00adings of Programs]: Specifying and Verifying and Reasoning about Programs \nLogics of programs; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages Denotational \nsemantics Keywords hybrid system; stream processing; signal processing; type system; nonstandard analysis \n 1. Introduction Signal By signals we mean values that depend on continuous time, that is, functions \ns : R=0 . C. 1 Signals are everywhere in the real world: they are the most straightforward model of physical \nquantities like position, velocity, voltage, etc. Signals have been studied extensively in the theory \nof dynamical systems, or more recently from the engineering viewpoint of control theory. 1The use of \ncomplex numbers C instead of R as the range is due to our use of i (the imaginary unit) in our leading \nexample in \u00a76. This choice is not important: our theory behaves the same for both C ~R2 and R. = Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 13, January \n23 25, 2013, Rome, Italy. Copyright c . 2013 ACM 978-1-4503-1832-7/13/01. . . $15.00 Hybrid system In \nthe mod\u00adern world where more and more physical systems are under the control of comput\u00aders (cars, plants, \npacemakers, etc.), signals that are not en\u00adtirely smooth with discrete jumps caused by digital control \nhave gained their signi.cance. They play an important role in the study of hybrid systems, an aspect \nof the more general topic of cyber\u00adphysical systems. Simulink, an industry-standard tool for modeling \nand simulation of hybrid systems, supports the design of a hybrid system as a signal processing system \ncomposed of interconnected blocks (above right). A signal processing system is one that re\u00adceives, processes \nand outputs signals.  Stream processing Study of formal veri.cation or computer science in general has \ntraditionally been focused on discrete data (this is changing rapidly, though). There stream processing \nsys\u00adtem is a heavily studied notion, together with related notions like data.ow network and reactive \nprogramming [29]. A stream is an in.nite sequence (a0, a1,. . . ) of data; thus it is a time-varying \nvalue s : N . C with a discrete notion of time. It bears an ob\u00advious similarity to the notion of signal. \nMoreover, common graphi\u00adcal presentations of stream processing systems look very much like Simulink block \ndiagrams. This similarity is the starting point of the current work. The dif\u00adference between signals \nand streams is whether the time domain is continuous (R=0)or discrete (N). If one can unify this difference, \nthe discrete techniques for streams that have been accumulated in computer science can be readily applied \nto signals. This is what we do, by the mathematical vehicle of nonstandard analysis (NSA). NSA allows \nus to think of continuous-time .ow dynamics as if it is a succession of discrete-time jumps each of which \nis in.nitely small. Nonstandard Analysis NSA is an alternative formalization of analysis convergence, \ncontinuity, differentiation, etc. that uses the explicit notion of in.nitesimal (i.e. in.nitely small) \nnumber. Leibniz s original formulation of analysis was based on in.nites\u00adimals; but a naive use of such \nimmediately leads to a contradiction. It was Robinson [24] who gave a logically rigorous foundation for \nin.nitesimals using the notion of ultra.lter. In our previous work [13, 30] we used NSA to represent \n.ow dynamics by means of while loops each iteration of a loop changes values in.nitesimally. What is \nremarkable about NSA is its logical infrastructure: its famous result called the transfer prin\u00adciple \nstates that a formula is valid for real numbers if and only if it is valid for hyperreals (i.e. reals \nextended with in.nitesimals). Therefore, reals vs. hyperreals (i.e. discrete vs. continuous, in the setting \nof [13, 30]) are the same from a logical point of view. This allowed us in [13, 30] to transfer a logical \n(i.e. deductive) veri.ca\u00adtion technique for discrete programs as it is to hybrid systems.  In the current \nwork we use the same idea to .ll in the gap be\u00adtween signal processing and stream processing. We similarly \ntrans\u00adfer a deductive veri.cation method, too. In it we employ the for\u00admalism of a (.rst-order functional) \nstream processing language SPROC it is modeled after the widely-accepted language Lus\u00adtre [9] to represent \nstream processing systems. NSA is in fact not only about analysis : its use is found in many branches \nof mathematics, such as general topology [14, Chap. III] and posets [35]. In this paper we present another \ninstance of such, namely domain theory upgraded with NSA (Appendix B, part of which already appeared \nin [3]). We use it in the de.nition of denotational semantics of SP ROCdt . Overview of the technical \ndevelop\u00ad (Conti.) signal |=? safety ment On the right, in (1), is the overview of our development. It \nis  hyperstream sampling centered around two key ideas: hy\u00ad hyperstream |=? safety perstream sampling \nand sectionwise execution.  (1) Deductive veri.cation Hyperstream sampling Typically, SPROCdt + type \nsystem a computer science approach to Sectionwise execution the study of continuous-time signals SPROC \n+ type system starts off with sampling a signal f. A sampling interval d > 0results in ` \u00b4 a stream \n(f(id))i.N = f(0), f (d), f (2d),. . . . Obviously such sampling cannot be exact we cannot know what \nhappens to f dur\u00ading d seconds of the sampling interval. Then a natural idea is to consider in.nitely \nmany sampling intervals that are progressively small, as shown on the right. This results in a ` \u00b4 stream \nof streams f( i ) , that is j+1 i.N j.N 0` \u00b41 f(0), f (1), f (2),... , ` \u00b4 B f(0), f (1), f (1),. . . \n, C B ` 2 \u00b4 C . (2) @ f(0), f (1), f (2),. . . , A 3 3 . . . Roughly a hyperstream is such a stream of \nstreams. This hyperstream sampling still cannot be ex\u00adact for all signals f: after all, there are only \ncountably many sampling points, while R=0 is uncountable. How\u00adever, if f satis.es some continuity assumption, \nwe could recon\u00adstruct the value f(t) for t . R=0 as a certain limit of sampled values. Speci.cally, based \non the .gure below on the right, we ver\u00adtically collect the following values from the sampling result \n(2). .2t. .3t. f(.t.), f (2 ), f (3 ), . . . -. f(t) (3) This construction is called smoothing; here \n. .is rounding up. We will formalize these sampling and smooth\u00ading operations (Smp and Smth)in \u00a75. There \nwe propose a class of functions (i.e. a continuity re\u00adquirement) that makes hyperstream sampling in\u00addeed \nexact, that is, Smth . Smp = id. In this paper in fact we use a re.ned no\u00adtion of hyperstream: it is \nnot simply a stream of streams (described above) but is the *\u00adtransform of the notion of stream. The \nintuition behind this re.ned notion is: a hyperstream is a stream (f(0), f (dt), f (2dt),. . . ) with \nan in\u00ad.nitesimal sampling interval dt. The j-th stream ` \u00b4 f(0), f ( 1 ), f ( 2 ),. . . in (2) then occurs \nj+1 j+1 as its j-th approximation. *-transform is an NSA construction; its bene.t is that we can transfer \na logical theory of streams as it is to that of hyper\u00adstreams, via the celebrated transfer principle \nin NSA. This idea of using an in.nitesimal sampling interval is already presented in [3, \u00a72.3], where \nthey establish Smth . Smp = id for functions f : R=0 . R that are everywhere continuous (they also hint \nan extension to piecewise continuity). Since we aim at hybrid applications, our class of functions (Def. \n5.1) is broader and contains some Zeno examples such as a bouncing ball. Sectionwise execution The second \nkey idea is about integrating NSA into program semantics and transferring the latter from dis\u00adcrete to \ncontinuous/hybrid. For this purpose we use the idea called sectionwise execution; it was .rst used in \nour previous work [13, 30] for a language with while loops. Here we brie.y review the idea as presented \nin [13, 30], adapting it later to the current setting of stream processing. Its very .rst example is \nthe program celapse t := 0 ; on the right. Here dt is a constant that denotes while t = 1 do an in.nitesimal \nvalue; if that is the case the t := t + dt while loop will not terminate within .nitely many steps. Never\u00adtheless \nit is somehow intuitive to imagine the execution of the program to increase tfrom 0to 1, in a smooth \nand continuous man\u00adner. To put this intuition into rigorous program t := 0 ; semantics, we think of the \nfollowing section-while t = 1 do 1 t := t + wise execution. For each natural number i we i+1 consider \nthe i-th section of the program celapse, that is denoted by celapse|i and shown on the right. Concretely, \ncelapse|i is obtained by 1 replacing the in.nitesimal dt in celapse with i+1 . Informally celapse |i \nis the i-th approximation of the original celapse. A section celapse|i does terminate within .nite steps \nand yields 1 1 + as the value of t. Now we collect the outcome of section\u00ad i+1 wise execution and obtain \na sequence 11 1 ( 1 + 1, 1 + , 1 + , . . . , 1 + , . . . ) (4) 2 3 i which is intuitively thought of \nas a progressive approximation of the actual outcome of the original program celapse. Indeed, in the \nlanguage of NSA, the sequence (4) represents a hyperreal number r that is in.nitesimally close to 1. \nIn [30], based on this idea, we presented a framework for mod\u00adeling and veri.cation of hybrid systems. \nIt consists of an imper\u00adative language WHILE and a Hoare-style program logic H OARE, dt dt augmented \nwith a constant dt and called W HILEand H OARE. Exploiting the transfer principle in NSA which roughly \nstates that reals and hyperreals are logically the same we showed that the rules of H OAREdt (precisely \nthe same as those of H OARE)are sound and relatively complete. Underlying is the denotational se\u00admantics \nof programs de.ned in the above sectionwise way. In [13] we applied several static analysis techniques \n(mainly for invariant discovery) to this setting. We also implemented an automated veri\u00ad.cation tool.2 \nIt was speculated in [13, 30] that the use of dt is not only for while programs but is probably a general \nmethodology for transferring a discrete veri.cation framework to continuous/hybrid. Our current work \nis one such example: the framework of a stream processing language and a program logic (in the form of \na type system) is transferred to the one for hyperstream processing. Here sectionwise execution takes \nthe following concrete form. As a hyperstream processing language we introduce SPROCdt ; it is a stream \nprocessing language SPROC, augmented with a constant dt for an in.nitesimal interval. The denotation \n[p] of an SPROCdt dt 2We note that programs in WHILEare not executable in general; this dt is already \nclear in the example of celapse. We rather think of WHILEas a modeling language, on which we can carry \nout static, deductive veri.cation. The same is true of the language SP ROCdt introduced in the current \npaper.  program p say ptakes a hyperstream and returns a hyperstream is de.ned by `\u00b4 `\u00b4 [p] (ai,j )i \nj := [p|j ] (ai,j )i ; (5) j that is, the section p|j (an SPROC program) is applied to the j-th stream \nof the input hyperstream, and their outcome is bundled up. Example 1.1 (The sine curve). Here is a program \npgSine in SPROCdt . node Sine() returns (s) where s = 0fby1 (s + c \u00d7 dt); c = 1fby1 (c -s \u00d7 dt) (6) node \nMain() returns (proj1 Sine()) The third line (declaring Main)is bureaucracy and can be ignored for the \nmoment. The core part is the mutual recursive de.nition of the hyperstreams s and c, whose intuition \nwe now explain. The operator fby1 means delay by one step (i.e. dt seconds): (a0, a1,. . . )fby1 (b0, \nb1,. . . ) = (a0, b0, b1,. . . ) . Therefore the (recursive) equation s = 0 fby1 (s + c \u00d7 dt) means, \nfor each n (that in fact ranges over hypernatural numbers), ( 0 if n = 0, s(n)= s(n -1) + c(n -1) \u00d7 dt \notherwise. This yields the following equations. s(n)-s(n-1) s(0) = 0 = c(n -1) (7) dt The value s(n -1) \nis that of one step before s(n), i.e. dt seconds before s(n). Thus the equations (7) are identi.ed with \nthe differen\u00adtial equation sin ' (t)= cos(t)with the initial value sin(0) = 0. Intuitively, the section\u00ad \n4 wise execution of pgSine 3realizes the sine curve 2as the limit of the ap-1proximations with dt = 0 \n1, 1 2, 1 3,. . . . This is like the graphs on the right. -1 In the current work we -2 employ a more \nadvanced -3 part of NSA than used -4 0 2 4 6 8 10 in [13, 30]. It allows us to transfer statements not \nonly on arith\u00admetic facts but also on set-theoretical ones. More precisely, we can now transfer formulas \nof the .rst-order language LX (Def. 2.5) that has .as a binary predicate. The details of this part of \nNSA is rather complicated but most of them are not needed; in \u00a72.2 we list the minimal set of necessarily \nde.nitions and results. A usage scenario Our technical framework summarized in (1) is supposed to be \nused in the following way. We are given two data: a continuous-time signal f and a safety property P. \nThe goal is to verify that f satis.es P. Towards that goal, one .rst models f by an SPROCdt program pgf \n. Typically we are not given f as a mathematical entity (i.e. a function f : R=0 . C), but we get its \nformal speci.cation written in some formalism like ODEs and Simulink diagrams. In this case, modeling \nof f amounts to translation of a speci.cation (say in ODEs) into an SPROCdt program. This modeling part \nis brie.y discussed in \u00a75.3 but a more extensive treatment is left as future work. The question then \nbecomes whether the SP ROCdt program pgf satis.es the safety property P. For that we can use a type system \nfor SP ROCdt : P is translated into a suitable type .P; and we try to derive a judgment pgf . .P using \nthe typing rules. The typing rules include the well-established proof principle of .xed point induction. \nOnce the derivation is done, by type soundness (Thm. 4.20) it guarantees that the hyperstream [pgf ] \ndenoted by pgf satis.es .P. Finally by Thm. 5.12 it implies that the signal Smth([pgf ]) satis.es P. \nThus we are done, under the condition that the SPROCdt modeling of f is correct (i.e. Smth([pgf ])= f). \nNote that the last paragraph is all about the metatheory. The ac\u00adtual veri.cation task is derivation \nof a type judgment, and this is done in the same deductive style as the veri.cation of (discrete\u00adtime) \nstream processing. In its course the NSA metatheory is com\u00adpletely concealed. Organization of the paper \nIn \u00a72we list the de.nitions and results of NSA that are used later. A prototype stream language SP ROC \nis introduced in \u00a73, together with its Kahn-style denotational se\u00admantics and a type system for safety \nguarantee. It is modeled after Lustre and is nothing novel; but the SP ROC framework is carefully designed \nso that it allows the transfer to SP ROCdt in \u00a74. Finally in \u00a75 we translate signals into hyperstreams, \nand also the safety guarantee for hyperstreams (obtained by the SP ROCdt type sys\u00adtem) to that for signals. \n\u00a76 is devoted to a veri.cation example. Our intention is to use the current framework for hybrid systems \n(as mentioned above) de.nitions like Def. 5.1 are worked out so that it accommodates many common hybrid \ndynamics. Our leading example (Example 1.1, which is used in \u00a76) is however a totally continuous one; \nthis is due to the limited space. In \u00a77we conclude. We defer most of the proofs to the extended version \n[31]. In this paper we sometimes refer to Appendix ; it is found in [31]. Related work The current work \nshares with [4] the observation of the similarity between signal processing and stream process\u00ading. In \n[4] they extend Lustre by ODEs. They go on to a compi\u00adlation framework that separates discrete and continuous \nparts of a program, passing the latter to an external solver to approximate continuous dynamics. For \nthe correctness of the compilation they introduce NSA-based formal semantics [5], which like ours takes \ncontinuous dynamics as a succession of in.nitesimal jumps. They also employ a type system for the separation \nof discrete and con\u00adtinuous parts of a program. Despite these similarities, the current work s objective \nis quite different from theirs we aim to exploit NSA s logical infrastructure to transfer deductive (i.e. \nlogical) ver\u00adi.cation from discrete stream processing to continuous-time signal processing. The extension \nof Lustre by ODEs in [5] is not designed towards this objective. Formal veri.cation of Simulink diagrams \nhas been studied e.g. in [10, 28, 33]. In [28] Simulink diagrams are translated into hy\u00adbrid automata, \nwhich are amenable to model checking. In [33] translation of a discrete fragment of Simulink into Lustre \nis pre\u00adsented. [10] combines symbolic analysis and numerical simulation, towards the goal of enhanced \nsimulation coverage. All these papers agree on one point: Simulink lacks formal semantics. In [7, 10] \nSimulink semantics is de.ned operationally by formalizing the simulation algorithms used in the implementation \nof Simulink. We hope our hyperstream modeling will serve as a basis of denotational semantics of Simulink. \nTurning to the purely discrete world, formal veri.cation of stream processing systems is studied often \nin the abstract interpre\u00adtation community [11]. Application of these results to our current deductive \napproach is an interesting direction of future work. For hybrid systems in general, there have been extensive \nre\u00adsearch efforts from the formal veri.cation community. Unlike the current work where we turn .ow into \njump via dt, most of them feature acute distinction between .ow-and jump-dynamics. These include: model-checking \napproaches based on hybrid automata [2]; deductive approaches, one of the most notable of which is a \nrecent series of work by Platzer and his colleagues (including [21, 23]). Interestingly in [23] it is \nargued that being hybrid imposes no addi\u00adtional burden to deductive veri.cation. This concurs with our \nNSA view that being discrete and being continuous/hybrid are logically the same.  Some veri.cation techniques \nfrom the static analysis commu\u00adnity have been successfully used in hybrid applications (modeled with \nexplicit differential equations) [17, 25 27]. The basic idea of the current work also of our previous \n[13, 30] is to transfer dis\u00adcrete veri.cation techniques as they are to continuous/hybrid set\u00adtings. \nIt is never our intention to champion the superiority of discrete techniques to continuous ones. The \nformal veri.cation community has worked out a stock of discrete techniques; our case is that their application \ndomain can be pushed further to continuous/hybrid. In\u00addeed we see ODEs as an extremely ef.cient formalism \nfor contin\u00aduous dynamics. We plan to incorporate them into our NSA frame\u00adwork. The use of NSA as a foundation \nof hybrid system modeling is not proposed for the .rst time; see e.g. [3, 5, 6]. Compared to this existing \nbody of work, we claim our novelty is the use of NSA s logical infrastructure (especially the transfer \nprinciple) for deductive veri.cation, based on a concrete modeling language. In particular, the basic \nidea of the current paper (namely, stream processing + NSA = signal processing) as well as two important \ntechnical ideas (namely: in.nitesimal sampling intervals and do\u00admain theory in NSA) are already in [3]. \nUnlike the current paper where we introduce a concrete programming (or modeling) lan\u00adguage SP ROCdt , \nin [3] they work with an abstract (graphical) lan\u00adguage of string diagrams for monoidal categories. Notations \nand terminology The syntactic equality is denoted by =. An in.nite stream s = (a0, a1,. . . )over S is \nidenti.ed with a function s : N . S. We write s(i) for its i-th element, i.e. s(i)= ai. For a nonnegative \nreal r . R=0, .r. . N denotes the least natural number that is not smaller than r, that is, r = .r. < \nr + 1. In this paper we use some domain theory, for which our princi\u00adpal reference is [1]. We will be \nusing .-cpo s calling them sim\u00adply cpo s while in [1] most results are formulated in terms of directed \ncpo s. The equivalence between these two cpo s is found in [1, Prop. 2.1.15]. We also assume the least \nelement .in cpo s.  2. A Nonstandard Analysis Primer Here we list the minimal set of necessary de.nitions \nand results in nonstandard analysis (NSA). More details are found e.g. in [12, 14]. 2.1 In.nitesimals \nin NSA First we present an elementary part of NSA. We .x an index set I = N, and an ultra.lter F . P(I)that \nextends the co.nite .lter Fc := {S . I |I \\S is .nite}. Its properties to be noted: 1) for any S . I, \nexactly one of S and I \\ S belongs to F; 2) if S is co.nite (i.e. I \\S is .nite), then S belongs to F. \nDe.nition 2.1 (Hypernumber d . * X). For a base set X (typically it is N, R or C), we de.ne the set * \nX of hypernumbers by * X := XI /~F. It is the set of in.nite sequences on X modulo the fol\u00adlowing equivalence \n~F: we de.ne (a0, a1,. . . )~F (a ' 0, a ' 1,. . . ) by {i . I |ai = ai ' } . F , (8) for which we say \nai = ai ' for almost every i. Therefore, given that two sequences (ai)i and (ai ' )i coincide except \nfor .nitely many indices i, they represent the same hypernumber. The predicates other than = (such as \n<)are de.ned in the same way. A notable consequence is the existence of an in.nitesimal number: a hyperreal \n.-1 := [ (1, 1 2, 1 3,. . . ) ] is positive (0 < .-1) but is smaller than any (standard) positive real \nr = [(r, r, . . . )]. De.nition 2.2 (Shadow). A hyperreal r is limited if it is not in.nite, i.e. if \nthere is a standard positive real K . R such that -K < r < K. It is well-known (see [12, 14]) that a \nlimited hyperreal r has a unique standard real that is in.nitely close to r. This standard real is called \nthe shadow of r and denoted by sh(r). The notion of shadow is a generalization of that of limit: if (ai)i \n` \u00b4 converges then sh [(a0, a1,. . . )] = limi.8 ai. See e.g. [12, 14]. Remark 2.3. It is common in NSA \nto take an index set I that is bigger than N, and an ultra.lter F . P(I)over I. The merit of doing so \nis that the resulting monomorphism * ( ) (\u00a72.2) can be chosen to be an enlargement; see [14, Chap. II]. \nIn this paper, however, we favor concreteness and choose I = N as the index set.  2.2 NSA in Superstructure \nWhat we need from the logical machinery of NSA goes beyond the elementary fragment presented above. It \nemploys a set theory-like formal language LX and a so-called superstructure as a model. The de.nitions \nand results listed below are all well-established and commonly used in NSA. We follow [14, Chap. II], \nin which more details can be found. Superstructure A superstructure is a universe, constructed step by \nstep from a certain base set X. We assume N . X. De.nition 2.4 (Superstructure). A superstructure V(X)over \nX is: S V(X):= n.N Vn(X) , where V0(X):= X and Vn+1(X):= Vn(X). P(Vn(X)) . (Ordered) pairs (a, b) and \ntuples (a1,. . . , am) are de.ned in V(X)as is usually done in set theory, e.g. (a, b):= {{a},{a, b}}. \nThe set V(X)is closed under many set formation operations. For example the function space a . b is thought \nof as a collection of special binary relations (a . b . P(a \u00d7 b)), hence is in V(X). *-Transform We use \nthe following predicate logic LX . De.nition 2.5 (The language LX ). Terms in LX consist of: vari\u00adables \nx, y, x1, x2,. . . ; and a constant a for each entity a . V(X). Formulas in LX are constructed as follows. \n The predicate symbols are = and .; both are binary. The atomic formulas are of the form s = t or s . \nt (where s and t are terms).  Any Boolean combination of formulas is a formula. We use the symbols .,.,\u00ac \nand ..  Given a formula A, a variable x and a term s, the expressions .x . s. A and .x . s. A are formulas. \n Note that quanti.ers always come with a bound s. The language LX depends on the choice of X (it determines \nthe set of con\u00adstants). We shall also use the following syntax sugars in LX , as is common in NSA. Their \ntranslation into proper LX formulas is straightforward. (s, t) pair (s1,. . . , sm) tuple s \u00d7 t direct \nproduct s . t inclusion, short for .x . s. x . t s(t) function application; short for x s.t. (t, x). \ns s . t function composition, (s . t)(x)= s(t(x)) s = t inequality in N; short for (s, t). = where = \n. N2 Remark 2.6. We note that LX resides on a different level from the languages that we introduce later, \nsuch as SPROC, SPROCdt and their assertion languages. LX is used to de.ne the semantics of those object-level \nlanguages, and is a meta language in this sense.  De.nition 2.7 (Semantics of LX ). We interpret LX \nin the super\u00adstructure V(X)in the obvious way. Let Abe a closed formula; we say Ais valid if Ais true \nin V(X). Validity is de.ned only for closed formulas. The so-called ultrapower construction yields a \ncanonical map * ( ) : V(X)-. V( * X) , a -. * a (9) that is called the *-transform. It is a map from \nthe universe V(X) of standard entities to V( * X)of nonstandard entities. We skip the details of its \nconstruction; later in this section we take a closer look. The map * ( ) becomes a monomorphism, a notion \nin NSA. Most notably it satis.es the transfer principle (Lem. 2.9). De.nition 2.8 (*-transform of formulas). \nLet A be a formula in LX . The *-transform of A, denoted by * A, is a formula in L*X obtained by replacing \neach constant a occurring in A with the constant * a that designates the element * a . V( * X). Lemma \n2.9 (The transfer principle). For any closed formula Ain LX , Ais valid (in V(X)) if and only if * Ais \nvalid (in V( * X)). The transfer principle is a powerful result and we will totally rely on it in the \nsemantics of SPROCdt . Here are the .rst examples of its use. Lemma 2.10. 1. For a . V(X)\\X we obtain \nan injective map * * *( ) : a -. a , (b . a) -. (*b . a) (10) as a restriction of * ( )in (9). ~ =* 2. \nIf a is a .nite set, the map (10) is an isomorphism a . a. 3. Let a . b be the set of functions from \na to b. We have  * (a . b). * a . * b. * *** 4. (a1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 am)= a1 \u00d7\u00b7 \u00b7 \u00b7 \u00d7 am; and (a1 .\u00b7 \u00b7 \u00b7 .am)= \n* a1 .\u00b7 \u00b7 \u00b7 . * am. 5. For a binary relation r . a \u00d7 a, we have * r . * a \u00d7 * a. Moreover, r is an order \nif and only if * r is an order. Internal Sets The distinction between internal and external enti\u00adties \nis central in NSA. In this paper however it is much of formality, since all the entities we use are internal. \nHere we present only the relevant de.nitions, leaving their intuitions to [14, \u00a7II.6]. In Ap\u00adpendix B, \nespecially Rem. B.8, we will see that being internal is crucial for transfer. De.nition 2.11 (Internal \nentity). An element b . V( * X)is inter\u00adnal with respect to * ( ): V(X). V( * X)if there is a . V(X) \nsuch that b . * a. It is external if it is not internal. Lemma 2.12. f : * a . * b is internal if and \nonly if f . * (a . b). The ultrapower construction We collect some necessary facts about the ultrapower \nconstruction of the monomorphism * ( ) in (9). Its details are beyond our scope; they are found in [14, \n\u00a7II.4]. The map * ( )in fact factorizes into the following three steps. * ( ) V(X) V(*X) ( ) M (11) S \nn.N ` Vn(X)\\Vn-1(X) \u00b4I [ ] Q0 F V(X) The .rst factor ( )maps a . V(X)to the constant function a such \nthat a(i) = a for each i . I; recall that we have chosen I = N (Rem. 2.3). The second [ ]takes a quotient \nmodulo the ultra.lter F; .nally the third factor M is the so-called Mostowski collapse. For an intuition \nlet us exhibit these maps in the simple set\u00adting of \u00a72.1. The .rst factor ( )corresponds to forming constant \nstreams: a . a = (a, a, . . . ). The second [ ]is quotienting mod\u00adulo ~F of (8). The third map M does \nnothing it is a book-keeping function that is only needed in the extended setting of superstruc\u00adtures. \nThe next result [14, Thm. 4.5] is about starting from the lower\u00adleft corner in (11). It follows from \nthe de.nition of M and is a crucial step in the proof of the transfer principle (Lem. 2.9). It serves \nas an important lemma, too, later for the semantics of SPROCdt . Lemma 2.13 (Lo\u00b4s theorem). Let A be \na formula in LX with its free variables contained in {x1,. . . , xm}; and a1,. . . , am . S` \u00b4I . Then \nn.N Vn(X)\\Vn-1(X) *A M[a1]/x1,. . . , M [am]/xm is valid . \u00af .. i . I | A[a1(i)/x1,. . . , am(i)/xm]is \nvalid . F . As a special case, let S . V(X), then M[a]. *S .. a(i). S for almost every i. Corollary 2.14. \nLet a, b . V(X); and for each i . I, fi . (a . b)and xi . a. Then M[(fi)i.I ]is an internal function \n* a . * b; and M[(xi)i.I ]. * a. Moreover, M[(fi(xi))i.I ]= M[(fi)i.I ] M[(xi)i.I ] .  3. The Stream \nProcessing Language SP ROC In this section we introduce the language SP ROC for stream pro\u00adcessing, together \nwith its denotational semantics and a type sys\u00adtem. The last is much like a Hoare-style program logic \nfor partial correctness. The whole framework is nothing surprising: SPROC is modeled after Lustre [9]; \nits semantics is de.ned as usual, fol\u00adlowing Kahn [15]; and the type system is rudimentary with a lim\u00adited \nexpressive power. The point is their clean logical foundations, which allow us to transfer the whole \nframework via NSA to SPROCdt (\u00a74). 3.1 SPROC: Syntax For an example of an SPROC program, see Example \n1.1. It is an SPROCdt program, but the two languages are very close. De.nition 3.1 (SPROC). We .x a set \nSVar of stream variables and, for each m, n . N, a set NdNamem,n of node names of arity (m, n). These \nsets are assumed to be disjoint. The syntax of SPROC is de.ned in Table 1. Some of its details are in \norder. The set SExpC consists of the C-stream expressions. A con\u00adstant c . C stands for the C-stream \n(c, c, . . . ). The operator . is . b0 b1 for the power: (a0, a1,. . . ) (b0, b1,. . . ) = (a0 , a 1 \n,. . . ). For each j. N we have an operator fbyj ( followed by ). It means (a0, a1,. . . )fbyj (b0, b1,. \n. . ) = (a0,. . . , aj-1, b0, b1,. . . ) . (12) The expression projk f(e1,. . . , em) invokes the node \nwhose name is f (declared elsewhere in the same program), feeds it with the input (e1,. . . , em), and \nreturns the k-th component of its out\u00adput. The set SExpB consists of the expressions for streams in the \nBoolean values B = {tt,ff}. The operators =, isReal and < are the obvious extensions of = : C2 . B, isReal \n: C . B and < : C2 . B. The last is de.ned by ( tt if c1, c2 . R and c1 < c2, c1 < c2 := (13) ff otherwise. \nEach node nd . Nodes comes with a certain arity (m, n) and its name f is chosen from NdNamem,n . It takes \nm-many C-streams as input and returns n-many C-streams as output. In the node nd in Table 1, the variable \nxi is for an input stream; and the local variable yi is used in the (mutually) recursive computation \ninside the node (speci.ed by y1 = e1' ;. . . ;yl = el ' ). These xi s and yi s together constitute the \nset of bound variables in nd. The restriction in Table 1 dictates that only these variables are allowed \nto occur in nd.  Finally, a program of SPROC is a .nite sequence of nodes, with the last one designated \nas the main node. The restriction in Table 1 means that we can invoke a node only if it is declared in \nthe program.  3.2 SPROC: Denotational Semantics We de.ne the semantics of SPROC in the denotational \nstyle, ex\u00adploiting the cpo structure of streams. This approach to the de\u00adnotational semantics of stream \nprocessing systems dates back to Kahn [15]. Speci.cally, our semantic domains are as follows. De.nition \n3.2 (C8 ,B8). By C8 we denote the set of .nite and in.nite streams over C. That is, C8 := C * .CN. We \nalso de.ne B8 for B = {tt,ff}by B8 := B * .BN . Notation 3.3. In what follows it is convenient to regard \na .nite stream as if it is an in.nite stream. Using . ( unde.ned ), we identify (a0, a1,. . . , am)with \nan in.nite stream (a0, a1,. . . , am,.,.,. . . ) . The intuition is: production of the element am+1 never \ntermi\u00adnated; thus the elements henceforth never got produced. Hence C8' in (an)n.N . , if am = .then \nam ' = .for any m = m. The following result underpins Kahn s approach [15]. Lemma 3.4. The pre.x order \n.on C8 makes it a cpo, that is, any F ascending chain s0 . s1 . \u00b7 \u00b7 \u00b7 has a supremum i si. Its least \nelement is the empty stream e. The same holds for B8 too. Based on this observation, we introduce the \nsemantics as fol\u00adlows. De.nition 3.5 (Variable/node environment). A (stream) variable environment is \na function J : SVar . C8 that assigns J(x) . C8 to each stream variable x. A node environment K assigns, \nto each node name f . NdName, a continuous function ` \u00b4 K(f) . (C8)mf .ct (C8)nf . (14) Here (mf , nf \n)is the arity of f; and the set (C8)mf .ct (C8)nf F is that of continuous (i.e. -preserving, but not \nnecessarily .\u00adpreserving) functions from (C8)mf to (C8)nf , with respect to the order .in Lem. 3.4. Therefore \nK is an element of the following set. Q` \u00b4 K . (C8)mf .ct (C8)nf . (15) f.NdName We denote the sets of \n(stream) variable environments and node environments by SVarEnv and NdEnv, respectively. Lemma 3.6. The \nsets SVarEnv and NdEnv are cpo s, with the pointwise extension of the order structure of C8. Speci.cally, \nbetween K, K ' . NdEnv, we have K . K ' if and only if .m, n . N. .f . NdNamem,n . .Ss . (C8)m . `\u00b4` \n\u00b4 .k . [1, n]. pk K(f)(Ss) . pk K ' (f)(Ss) . Here pk is the k-th projection pk : (C8)n . C8. The order \non SVarEnv is similar. Using these environments we de.ne the semantics of SPROC expressions as follows. \nWe go step by step. De.nition 3.7 ([e]J,K and [b]J,K ). In Table 2 we de.ne the denotation [e]J,K . C8 \nof a C-stream expression e . SExpC, under variable and node environments J and K. Here the de.nition \nof [e1 aop e2]J,K simply says that aop is applied elementwise. Recall that a .nite stream (a0 . . . am) \nis identi.ed with (a0,. . . , am,.,.,. . . ); the operator aop. returns . if any of its arguments is \n.. This is the same for if. . . . then . . . else . . . , .., \u00ac ., etc. that appear later in Ta\u00adble 2. \nThe de.nition of [e1 fbyj e2]J,K is the equation (12) put in formal terms. Recall that . means nontermination \n(Nota\u00adtion 3.3). In the de.nition of [projk f(e1,. . . , em)]J,K , recall that pk is the k-th projection \n(see Lem. 3.6); also note the type of K (see (14)). We simultaneously interpret B-stream expressions, \nas in Ta\u00adble 2. Recall our de.nition of < between complex numbers (see (13)). The semantics of intra/inter-node \nrecursion is by least .xed points. De.nition 3.8 ([nd]K ). Let nd be a node \u00bb node f(x1,. . . , xm)returns \n(e1,. . . , en) nd := ' ' (16) where y1 = e1;. . . ;yl = e l of arity (m, n). We de.ne its denotation \n[nd]K : (C8)m -. (C8)n (17) as follows. Given ss = (s1,. . . , sm) . (C8)m as input, .rst we solve the \nfollowing recursive equation, and obtain a variable environment J0 as its least solution. \u00bb x1 . s1, \n. . . , xm . sm, J0 = J0 ' ' (18) y1 . [e ]J0,K , . . . , yl . [e ]J0,K 1l On the right-hand side, [x1 \n. s1,. . . ]means a function update. The variable environment J0 thus obtained is used in: [nd]K (s1,. \n. . , sm) := ([e1]J0,K , . . . , [en]J0 ,K ). (C8)n . De.nition 3.9 ([pg]). Let pg be a program [nd1,. \n. . , ndN ;ndMain ]; f1,. . . , fN and fMain be the names of nd1,. . . , ndN and ndMain ; and (mMain \n, nMain )be the arity of ndMain . We de.ne the denotation )mMain )nMain [pg] : (C8. (C8as follows. We \nde.ne a node environment K0 to be the least solution of the following recursive equation. \u00bb f1 . [nd1]K0 \n, . . . , fN . [ndN ]K0 , K0 = K0 (19) fMain . [ndMain ]K0 The node environment K0 thus obtained is used \nin the following. (Note the type; see (17)) [pg] := [ndMain ]K0 : (C8)mMain . (C8)nMain We need the following \nlemmas for Def. 3.8 3.9 to make sense. These follow from the fact that all the constructs in the denotational \nsemantics are continuous, which is proved in Appendix A. Lemma 3.10. For any node nd and any K . NdEnv, \nthe func\u00adtion [nd]K : (C8)m . (C8)n is continuous. Therefore the function on the right-hand side of (19) \nis indeed a node environ\u00adment. Lemma 3.11. The recursive equations (18 19) have least solu\u00adtions. Proof. \nBy the continuity of the relevant operations, including F : SVarEnv -. SVarEnv , \u00bb x1 . s1, . . . , xm \n. sm, (20) J -. J ' ' , y1 . [e ]J,K , . . . , yl . [e ]J,K 1l and Lem. 3.6.  3.3 SPROC: Type System \nfor Safety Guarantee We now present a program logic for SPROC. SPROC is a .rst\u00adorder functional language; \ntherefore, as usual, our logic takes the form of a type system. There we identify types with predicates. \nOur type system is rather restricted and is aimed (solely) at the partial guarantee of safety, that is, \nit gives no guarantee in the  . SExpC . e ::= x |c |e1 + e2 |e1 \u00d7 e2 |e1 e2 |e1 fbyj e2 |if b then \ne1 else e2 |projk f(e1,. . . , em) where x . SVar;c . C;j. N;b . SExpB;f . NdNamem,n ; and k . [1, n] \nSExpB . b ::= true |false |b1 .b2 |\u00acb |e1 = e2 |isReal(e)|e1 < e2 where e, ei . SExpC \u00bb where f . NdNamem,n \n;xi, yi . SVar;ei, e ' . SExpC; i node f(x1,. . . , xm)returns (e1,. . . , en) Nodes . nd ::= x1,. \n. . , xm, y1,. . . , yn are all distinct; and the variables occurring '' ' where y1 = e ;y2 = e ;. . \n. ;yl = e 12l ' in ei, e i are restricted to xi and yi Programs . pg ::= [nd1,nd2,. . . , ndm;ndMain \n] where ndi,ndMain . Nodes; and the node names occurring in ndi or ndMain are restricted to f1,. . . \n, fm and fMain , the (distinct) names of nd1,. . . , ndm and ndMain Table 1. Syntax of SPROC ` \u00b4 [x]J,K \n:= J(x) [c]J,K := (c, c, . . . ) [e1 aop e2]J,K := [e1]J,K (n)aop. [e2]J,K (n) where aop . {+,\u00d7, .} (n.N \n` \u00b4 [e1]J,K (0),[e1]J,K (1),. . . , [e1]J,K (j-1),[e2]J,K (0),[e2]J,K (1),. . . if the length of [e1]J,K \nis at least j [e1 fbyj e2]J,K := ` \u00b4 [e1]J,K (0),[e1]J,K (1),. . . , [e1]J,K (k-1),.,.. . . if the length \nof [e1]J,K is k and k < j ` \u00b4 [if b then e1 else e2]J,K := if. [b]J,K (n)then [e1]J,K (n)else [e2]J,K \n(n) n.N ` \u00b4 [projk f(e1,. . . , em)]J,K := pk K(f) [e1]J,K ,. . . , [em]J,K ` \u00b4`\u00b4 [true]J,K := (tt,tt,. \n. . ) [false]J,K := (ff ,ff,. . . ) [b1 .b2]J,K := [b1]J,K (n).. [b2]J,K (n) [\u00acb]J,K := \u00ac .[b]J,K (n) \nn .N n.N `\u00b4 `\u00b4 [e1 = e2]J,K := [e1]J,K (n) =. [e2]J,K (n) [isReal(e)]J,K := isReal. [e]J,K (n) n.N \n(n.N [e1]J,K (n)<. [e2]J,K (n) if n = 0or [e1 < e2]J,K (n -1) .= . [e1 < e2]J,K (n):= . if [e1 < e2]J,K \n(n -1) = . Table 2. Denotation [e]J,K , [b]J,K case of nontermination. Our focus on partial safety is \nin.uenced by [18]; and is much like common Hoare-style program logics. We leave as future work veri.cation \nof liveness properties; the latter necessarily involves the analysis of termination (i.e. productivity \nin stream processing). Remark 3.12. For functional stream processing languages, Nakano s type system \n[20] with the modality is well-known. Its concern is for the productivity (i.e. totality, termination) \nof stream computa\u00adtion; this is orthogonal to ours (partial safety). In [16] semantics of stream processing \nsubject to Nakano s types is proposed using ultrametric spaces as an alternative to the Kahn-style cpo \nseman\u00adtics which we have used with its merit being that one can form a semantic domain consisting solely \nof total streams (i.e. CN in\u00adstead of C8). Application of these results to SP ROC, and further to SPROCdt \n, is left as future work. 3.3.1 SPROC: Type Syntax Our type syntax is borrowed from that of dependent \ntype systems. The latter are known for their expressiveness and have been used for veri.cation of higher-order \nprograms (e.g. in [32]). Our type system, as a feasibility study of the methodology, is much more restricted. \nSee Example 3.14. AExp . a ::= Fml . P ::= STypeC . t ::= STypeB . \u00df ::= NdTypem,n . . ::= v |c |a1 + \na2 |a1 \u00d7 a2 |a1 . a2 |.a1. where v . Var and c . C true |false |P1 .P2 |P1 .P2 |\u00acP | a1 = a2 |isReal(a)|a1 \n< a2 |a1 = a2 | .v . N. P | .v . C. P where v . Var and a, ai . SExpC Q v.N{u . C |P} where u, v . Var, \nP . Fml and FV(P). {u, v} Q v.N P where v . Var, P . Fml and FV(P). {v} ' ' (t1,. . . , tm). (t1,. . \n. , t ) n ' where ti, t . STypeC i Table 3. Type Syntax for SPROC De.nition 3.13 (Types for SPROC). The \nsyntax of our type system for SP ROC is shown in Table 3. The set AExp is that of arithmetic expressions, \neach of which denotes a number in C. We assume a countable set Var of vari\u00adables; note that this is different \nfrom the set SVar of stream vari\u00adables. The rounding up operation . . (see \u00a71) is included for a later \nuse. The set Fml is that of assertion formulas; it follows the usual syntax of .rst-order predicate logic. \nQ Atype t . STypeC for C-streams is an expression v.N{u . C |P}. It consists of variables u, v, a formula \nP, and the delimiter Q .N{ . C | }. Its informal meaning is {u . C |P[0/v]} \u00d7 {u . C |P[1/v]} \u00d7 {u . \nC |P[2/v]} \u00d7 \u00b7 \u00b7 \u00b7 ; that is, the set of streams s such that its n-th element u = s(n) and v = n satisfy \nP, for each n . N. A type \u00df . STypeB for Q B-streams is similar: t |= v.N P if t(n)is equivalent to P, \nwith v = n, for each n . N. Anode type . = (t1,. . . , tm). (t1' ,. . . , t n ' ). NdTypem,n represents \nthe set of nodes of arity (m, n) that, when fed with streams satisfying t1,. . . , tm, output streams \nsatisfying t1' ,. . . , t n ' . Q In the expression v.N{u . C |P} . STypeC, the variables u and v are \nbound. We identify types modulo renaming of these Q bound variables. The same is true of v in v.N P . \nSTypeC. Q Example 3.14. The C-stream type v.N{u | v = 3 . u = 1} speci.es that the elements s(3), s(4),. \n. . of a stream s are real and = 1. Our types can thus express rudimentary safety properties. Regarding \nthe limitation of the expressive power, it is straight\u00adforward to extend the type system with stream \ntypes of arity k > 1: Q. .\u00af v.N (u1,. . . , uk).P , where FV(P). {u1,. . . , uk, v}. This extension allows \nus to speak about correlations among distinct streams. So can we about correlations between input and \noutput: we can prepare auxiliary output streams that copy input streams, and compare them with the output. \nFurthermore we can express temporal properties: to see if a stream s is increasing, we can check if the \npair (0 fby1 s, s)satis.es the binary type Qv.N{(u1, u2)| u1 < u2}. In this paper we restrict the presentation \nto unary stream types for the sake of simplicity. This is not to say that the type system is amply expressive. \nFor example, the type judgment .; x : t, y : s . if x = y then y else x : t (whose validity is not hard \nto see) cannot be derived by the typing rules. In its derivation one would need a  Q B-stream type v.N{x(v)= \ny(v)}, which is prohibited due to the free variables x, y in it. Anyway, the syntactic restrictions in \nTable 3 compared to a fully-.edged dependent type system simplify the type system drastically. For example, \nwe do not need the well-formedness con\u00addition of type environments, which is usually needed in dependent \ntype systems (see e.g. [32]). Relaxing these restrictions is future work.  3.3.2 SPROC: Type Semantics \nDe.nition 3.15 (Valuation). Avaluation is either .( unde.ned ) or a function L : Var . C. The set of \nvaluations is denoted by Val, that is, Val = (Var . C). {.}. The function update L[u1 . c1,. . . , um \n. cm], with L . Val, ui . Var and ci . C . {.}, is de.ned by: ( . if any of ci is . L[Su . Sc] := (21) \n(the usual function update) otherwise. Therefore: if the length of s . C8 is not more than n, valuation \nL[u . s(n)] is de.ned to be .. De.nition 3.16 (Semantics of AExp, Fml). The denotation [a]L . C . {.}, \nof an arithmetic expression a . AExp un\u00adder a valuation L . Val, is de.ned in the usual manner. We de.ne \n|= between valuations and formulas in the usual manner, too. For example, def. L |= isReal(a) .. L = \n. or [a]L . R , def. L |= .v . N.P .. L = . or L[v . n]|= P for any n . N , and so on. In particular, \nthe valuation . . Val satis.es any formula. A formula P is valid (|= P) if L |= P for any L . Val. De.nition \n3.17 (Semantics of types). Between a C-stream s . C8 and a C-stream type t . STypeC, s |= t is de.ned \nby Qdef. s |= v.N{u . C |P} .. L[v . n, u . s(n)] |= P for each n . N and L . Val. Note that the valuation \nLin the de.nition is vacuous, because of the restriction that FV(P). {u, v}. Note also that when s(n)= \n., then L[v . n, u . s(n)] is .(Def. 3.15), which satis.es P. This re.ects our focus on partial correctness: \nwhen the computation does not terminate i.e. when the length of s . C8 is l, and its (l + 1)-th element \nnever gets produced it does not matter what the type t speci.es about the (l+ 1)-th and later elements \nof s. Similarly, between a B-stream t . B8 and a B-stream type \u00df . STypeB, the satisfaction relation \nt |= \u00dfis de.ned as follows. Qdef. t |= P .. for each n . N, t(n)= . or v.N ` \u00b4 t(n)= tt . L[v . n]|= \nP for each L . Val That is, t(n)if and only if P[n/v]. Finally, between a continuous function g : (C8)m \n.ct (C8)n and a node type . . NdTypem,n , the satisfaction relation |= is: def. ' ' g |= (t1,. . . , \ntm). (t1,. . . , t ) .. n ' ' .s1,. . . , sm, s 1,. . . , s . C8 . \u00bb n ' ' s1 |= t1 .\u00b7 \u00b7 \u00b7 . sm |= tm \n. (s1,. . . , s )= g(s1,. . . , sm) n '' ' ' =. s |= t .\u00b7 \u00b7 \u00b7 . s |= t 1 1 n n  3.3.3 SPROC: Type Derivation \nIn type judgments we have two kinds of environments. De.nition 3.18 (Type environment). A stream type \nenvironment G = {x1 : t1,. . . , xm : tm}is a .nite set of pairs of a stream variable xi . SVar and a \nC-stream type ti . STypeC. We require x1,. . . , xm to be distinct. Similarly, a node type environment \n. = {f1 : .1,. . . , fm : .m}is a .nite set, where fi . NdName is a node name and . . NdType is a node \ntype with the same arity. We denote the sets of stream and node type environments by STEnv and NdTEnv, \nrespectively. Notation 3.19. We sometimes write G(x). In this case it is assumed that x : t is in Gwith \nsome t; and G(x)denotes this (unique) t. De.nition 3.20 (Type judgment). In our type system for SP ROC \nwe have four classes of type judgments. Here . is a (mere) delim\u00aditer. .; G . e : t, meaning: the C-stream \nexpression e is of the type t if the variables denote the streams conforming to G and the node names \ndenote the nodes conforming to ..  .; G . b : tb, meaning the same, between B-stream expres\u00adsions and \nB-stream types.  . . nd : ., meaning: the node nd is of the node type . if the node names denote the \nnodes that conform to ..  . pg : ., meaning: pg s main node ndMain is of the node type ..  De.nition \n3.21 (Type derivation). The typing rules for SP ROC are as shown in Table 4. We write . J if the type \njudgment J is derivable. 3.3.4 SPROC: Type Soundness De.nition 3.22. Between a stream variable environment \nJ . SVarEnv = (SVar . C8) and a stream type environment G = {x1 : t1,. . . , xm : tm} . STEnv, we de.ne \nJ |= Gby def. J |= G .. J(xi)|= ti for each i . [1, m]. Here the latter |= is as de.ned in Def. 3.17. \nSimilarly, between a node environment K . NdEnv and a node type environment . = {f1 : .1,. . . , fm : \n.m} . NdTEnv, we de.ne K |= . if and only if K(fi) |= .i for each i . [1, m]. Lemma 3.23. The C-stream \n. . C8 (i.e. the empty stream) satis.es any type t, that is, . |= t. The same for . . B8 . Similarly \nwe have . |= G for . . SVarEnv; and . |= . for . . NdEnv. De.nition 3.24 (Validity of type judgments). \nWe say a type judg\u00adment .; G . e : t is valid, and write |= .; G . e : t, if for any J . SVarEnv and \nK . NdEnv, J |= G and K |= . imply [e]J,K |= t. The validity of the other three classes of type judgments \nis de.ned in the same manner. Theorem 3.25 (Type soundness). A derivable type judgment is valid, that \nis, . J implies |= J. Proof. The proof is mostly straightforward by induction. In Ap\u00adpendix D we show \nsome exemplary cases. The cases (NODE)and (PROG) involve the principle of .xed point induction.   4. \nThe Hyperstream Processing Language dt SPROC 4.1 SPROC dt : Syntax dt dt De.nition 4.1 (SPROC). The \nsyntax of SPROCis the same as that of SP ROC (Table 1), except that we have two additional r constructs \ndt and fby dt in the set SExpC. SExpC . e ::= x |c |e1 + e2 |\u00b7 \u00b7 \u00b7 (The same as in Table 1) r |dt |e1 \nfby dt e2 where r . R=0 In SPROCdt we call the elements of SExpC C-hyperstream expres\u00adsions. The same \nfor SExpB, too. Intuitively, the stream expression  (SVAR) Q(CONST) .; G . x : G(x) .; G . c : {u . \nC |u = c} Q v.N .; G . ei : v.N {ui . C |Pi}for i = 1,2 |= .v . N..u1, u2, u . C.(P1 .P2 .u = (u1 aop \nu2) . P) Q(AOP) (aop . {+,\u00d7, .}) .; G . e1 aop e2 : {u . C |P} Qv.N ` \u00b4 .; G . {u . for i = 1,2 |= .v \n. N..u . C. (v < j .P1 . P).(v = j.P2[v -j/v] . P) ei : v.N C |Pi} j) QQ.; G . e1 fbyj e2 : {u . C |P} \nQ (FBY v.N .; G . b : Pb .; G . ei : {u . C |Pi}for i = 1,2 |= .v . N..u . C.(Pb .P1 . P).(Pb .P2 . P) \nv.N v.N Q (IF) .; G . if b then e1 else e2 : v.N {u . C |P} ' ' .; G . ei : ti for i . [1, m] .(f)= \n(t1,. . . , tm). (t1,. . . , t ) n (NDCALL) ' .; G . projk f(e1,. . . , em): t Q k ' .; G . e : {u \n. C |P ' } |= .v . N..u . C. P . P v.N Q (CSTCONSEQ) .; G . e : v.N{u . C |P} Q .; G . bi : v.N Pi \nfor i = 1,2 Q(AND) (TRUE), (FALSE), (NEG)are similar .; G . b1 .b2 : (P1 .P2)for i = 1,2 Qv.N ` \u00b4 .; \nG . ei : v.N{ui . C |Pi}for i = 1,2 |= .v . N..u1, u2 . C. P1 .P2 . (P . u1 = u2) Q (EQUAL) .; G . e1 \n= e2 : P v.N ` \u00b4 Q ' .; G . e : {u . C |P ' } |= .v . N..u . C. P . (P . isReal(u)) v.N Q (ISREAL) \n.; G . isReal(e): P Q ` v.N \u00b4 .; G . ei : v.N{ui . C |Pi}for i = 1,2 |= .v . N..u1, u2 . C. P1 .P2 . \n(P . (isReal(u1).isReal(u2).u1 < u2)) Q (LESS) .; G . e1 < e2 : v.N P Q ' ' .; G . b : v.N P |= .v . \nN. P . P Q(BSTCONSEQ) .; G . b : v.N P ' '' G(xi) = ti for i . [1, m] .; G . ej : G(yj )for j. [1, l] \n.; G . ek : tk for k . [1, n] \u00bb (NODE) node f(x1,. . . , xm)returns (e1,. . . , en) '' '' . . ' ' : \n(t1,. . . , tm). (t1 ,. . . , t ) n where y1 = e1;. . . ;yl = el ' ' . . nd : (t1,. . . , t ). (s1' ,. \n. . , s ' ) m n ' |= .v . N. .u . C. Pi . Pi for i . [1, m] |= .v . N. .u . C. Q j ' . Qj for j. [1, \nn] `QQQ Q\u00b4 ' ' where ti = {u . C |Pi}, t = {u . C |P }, sj = {u . C |Qj }, s ' = {u . C |Q ' } v.N i \nv.N i v.N j v.N j (NDCONSEQ) . . nd : (t1,. . . , tm). (s1,. . . , sn) . . ndi : .(fi)for i . [1, m] \n. . ndMain : . (PROG) (fi is the name of the nodes ndi) . [nd1,. . . , ndm;ndMain ]: . Table 4. Typing \nrules for SPROC dt represents the constant stream (dt,dt,. . . ); each dt therein is thought of as a \npositive in.nitesimal sampling interval. In addi\u00ad r tion to fbyj for the delay by jsteps, we now have \nfby dt for delay by in.nite steps. With dt being the sampling interval, 1/dt is the r sampling frequency. \nTherefore delay by dt steps means delay by r seconds. For the semantics of SPROCdt we use the second \nkey idea of sectionwise execution (see \u00a71). In it an SPROCdt program is .rst split up into its sections; \neach section is an SPROC program and hence is interpreted in a usual manner (\u00a73.2). The outcome of each \nsection is bundled up and constitutes the outcome of the original dt De.nition 4.2 (Section e|i of SPROCexpressions). \nLet p be an SPROC program. In \u00a74.2 we formalize this idea in the NSA terms of \u00a72.2. dt SPROCdt expression. \nFor each i . N, its i-th section p|i is the SPROC expression obtained from p, by replacing 1) the stream \nr 1 .r(i+1). expression dt with i+1 ; 2) the operator fby dt with fby. dt  4.2 SPROC : Semantics We \nrepeat the development of the semantics of SPROC replacing streams with hyperstreams, via *-transform \nand interpret SP ROCdt . Here we rely on domain theory formulated in an NSA setting. Its details are \nfound in Appendix B (part of which already appeared in [3]). De.nition 4.3 (Variable/node environment \nfor SP ROCdt ). The set of (stream) variable environments for SP ROCdt is the *-transform * SVarEnv of \nSVarEnv for SP ROC. Recall that SVarEnv = (SVar . C8); by Lem. 2.12, a variable environment for dt * \n* SPROCis precisely an internal function J : SVar . (C8). Similarly, the set of node environments for \nSP ROCdt is the *\u00adtransform * NdEnv of that for SPROC. We shall .rst de.ne the denotation [e]J,K . * \n(C8) of a hyperstream expression e . SExpC in SPROCdt , under J . * SVarEnv and K . * NdEnv. This is \ndone sectionwise; we proceed exploiting the NSA machinery in \u00a72.2, .nally leading to Def. 4.4. Given \ne . SExpC in SPROCdt , each section e|i (Def. 4.2) is an SPROC expression. Its denotation (Def. 3.7) \nyields a function [e|i] : SVarEnv \u00d7 NdEnv -.ct C8 ; its continuity is proved in Lem. A.3. We collect \n[e|i] for each i; this results, using Lem. 2.13, in the following function. ` \u00b4 M [e|i] . *(SVarEnv \u00d7 \nNdEnv .ct C8) i.N (22) Lem. B.6 &#38; 2.10 = (* SVarEnv \u00d7 * NdEnv .* ct *(C8)) The last denotes the space \nof *-continuous functions (Def. B.5), whose details can safely be skipped for the moment. De.nition 4.4 \n([e],[b]). The denotation [e], of a C-hyperstream expression e . SExpC in SPROCdt , is de.ned as follows \nus\u00ading (22).  ` \u00b4 [e] := M [e|i] : * SVarEnv \u00d7 * NdEnv .* ct *(C8) i.N ** * The denotation [b] : SVarEnv \n\u00d7 NdEnv .* ct (B8) of b . SExpB in SPROCdt is de.ned in the same manner. We now interpret nodes and programs \nin SPROCdt . There are two equivalent ways to do so; here we present the sectionwise de.nition that is \nsimilar to Def. 4.4. This is more convenient for the later use in \u00a74.3; see Rem. 4.6 for the other de.nition. \nDe.nition 4.5 ([nd],[pg]). Given a node nd in SPROCdt of arity (m, n), its denotation [nd] is de.ned \nby ` \u00b4 [nd] := M [nd|i] : i.N ` \u00b4 * NdEnv .* ct *(C8)m .* ct *(C8)n , where [nd|i] : NdEnv .ct ((C8)m \n.ct (C8)n)is as de.ned in Def. 3.8 (its continuity is proved in Lem. A.6). For a program pg in SPROCdt \nof arity (m, n), its denotation [pg] is de.ned similarly by ` \u00b4 : *(C8)mMain *(C8)nMain [pg] := M [pg|i] \ni.N .* ct . Remark 4.6. A drawback of the sectionwise de.nition of [nd] (Def. 4.5) is that the relationship \nbetween [nd] and [e] (for e occurring in nd)is not visible at all. Conceptually this is unnatural. In \nfact, we can de.ne [nd] directly from [e] like we did in \u00a73.2 by solving a hyperdomain equation in the \nhyperdomain * SVarEnv. For the latter we use the technique presented in [3]; see Appendix B, especially \nLem. B.7. The two de.nitions indeed coincide; see Appendix C for details.  4.3 SPROCdt : Type System \nfor Safety Guarantee We introduce a type system for SPROCdt as a *-transform of that for SPROC. It might \nbe hard at this stage to make sense of a hyperstream s satisfying a type t; it will be used in our main \ntheorem (Thm. 5.12). 4.3.1 SPROC dt : Type Syntax AExp . a ::= v |c |a1 + a2 |a1 \u00d7 a2 |a1 . a2 |.a1. \n| dt | 1 where v . Var and c . C dt Fml . P ::= true |false |P1 .P2 |P1 .P2 |\u00acP | a1 = a2 |isReal(a)|a1 \n< a2 |a1 = a2 | .v . * N. P |.v . * C. P where v . Var and a, ai . AExp Q STypeC . t ::= v.*N {u . * \nC |P} where u, v . Var, P . Fml and FV(P). {u, v} Q STypeB . \u00df ::= P where v . Var, v.*N P . Fml and \nFV(P). {v} ' ' NdType. . ::= (t1,. . . ,tm). (t1,. . . ,t ) m,n n ' where ti,ti . STypeC Table 5. Type \nSyntax for SPROCdt dt dt De.nition 4.7 (Types for SPROC). The syntax of the SPROCtype system is in Table \n5. It is almost the same as that for SPROC (Table 3). The differences are: 1) we have dt . AExp that \nrepresents an in.nitesimal sampling interval; 2) quanti.ers in Fml and stream types are taken over hypernumbers \n* N, * C, instead of standard numbers. We de.ne sections of type expressions. This is like Def. 4.2. \nDe.nition 4.8 (Section of type expressions). The i-th section p|i of an SPROCdt type expression pis obtained \nfrom pby: 1) replac\u00ading dt with 1 ; 2) replacing 1 with i + 1; 3) replacing hyper\u00ad i+1 dt quanti.ers \n.v . * D (where D . {N,C})with standard quanti.ers .v . D; and 4) replacing hyperquanti.ers v . * N and \nu . * C in Q* Q the stream types {u . C |P}and P by the corre- v.*N v.*N sponding standard quanti.ers. \nAsection p|i is obviously an SPROC type expression.  4.3.2 SPROC dt : Type Semantics De.nition 4.9 (Valuation \nfor SPROCdt ). The set of valuations for SPROCdt is * Val, the *-transform of the set Val = (Var . C).{.} \nin Def. 3.15. By 2.10, a valuation for SPROCdt is either an internal function L : * Var . * C, or L = \n.. -. . * The function update L[ui . -ci ], with L . Val, ui . Var and ci . * C .{.}, is the *-transform \nof the corresponding oper\u00adation in SPROC (Def. 3.15). Namely, the latter induces a function (by (21)) \n` \u00b4m T : Val \u00d7 Var \u00d7 (C .{.}) . Val, - --. (23) ' (L ' '' ]. ,(u ,c ' )) . L ' [uS . cS Its *-transform \nunder * ( ) in (9) is an internal function * T : ` \u00b4 m * Val \u00d7 * Var \u00d7 ( * C . {.}) . * Val. We precompose \nthe from Lem. 2.10.1, and obtainVar * . . injection Var ` \u00b4 m T ' : * Val \u00d7 Var \u00d7 (* C .{.}) -. * Val \n. - -. We de.ne the function update by L[su . sc]:= T ' (L,(u, c)). De.nition 4.10 (Semantics of AExp, \nFml). The denotation [a]L . * C . {.} of a . AExp under a valuation L . * Val is de.ned as follows. It \nis .when L = .;otherwise * [v]L := L(* v) , [c]L := c , 1 1 [dt]L := M ( 1 = [(1, , ,. . . )] , i+1)i.I \n2 3 * [a1 aop a2]L := [a1]L aop [a2]L where aop . {+,\u00d7, .}. In the .rst line, * ( ): Var . * Var and \n* ( ): C . * C are from Lem. 2.10.1. In the second line recall that I = N (Rem. 2.3); thus [dt]L is in \nfact the in.nitesimal number .-1 exhibited in \u00a72.1. In the last line, * aop : ( * C)2 . * C is the *-transform \nof aop. The satisfaction relation L |= P between L . * Val and P . Fml is de.ned in the usual manner. \nFor example, def. L |= a1 < a2 .. ` \u00b4 L = . or [a1]L,[a2]L . * R . [a1]L * <.[a2]L . Aformula P is valid \n(written |= P)if L |= P for anyL . * Val. We shall characterize this semantics in a sectionwise manner, \nso that we can later apply Lo\u00b4s theorem (Lem. 2.13). For each a . AExp in SPROCdt , its section a|i determines \nby Def. 3.16 a function [a|i] : Val . C .{.}. Thus by Lem. 2.13 we have Lem. 2.10 M ([a|i])i.I . *(Val \n. C .{.}) . (* Val . * C .{.}) . (24) Similarly, a formula P . Fml for SPROCdt determine M ( |= P|i \n)i.I . *(Val . B). (* Val . B) , ~ (25) = M (|= P|i )i.I . * B . B. Lemma 4.11. Between Def. 4.10 and \n(24 25), the following hold. ` \u00b4 [a]L = M[([a|i])i.I ] (L) ` \u00b4 L |= P .. M ( |= P|i )i.I (L)= tt |= \nP .. M (|= P|i )i.I = tt The next de.nition is parallel to Def. 3.17. De.nition 4.12. The satisfaction \nrelation |= between a hyper\u00adstream s . *(C8). (* N . * C .{.}) (where .is due to Lem. B.3) Q* and a C-hyperstream \ntype t = {u . C |P}is de.ned by: v.*N Q def. s |= v.*N {u . * C |P} .. L[v . n, u . s(n)] |= P for each \nn . * N and L . * Val.  In the setting of the previous de.nition, each section t|i = Q v.N{u . C |P|i}determines \na function (by Def. 3.17) `Q\u00b4 |= {u . C |P|i} : C8 -. B ; v.N therefore by Lem. 2.13 we obtain ` Q\u00b4 M \n|= {u . C |P|i} : *(C8)-. B . (26) v.N i.I Lemma 4.13. Between Def. 4.12 and (26), the following holds. \n ` Q\u00b4 s |= t .. M |= {u . C |P|i} (s)= tt v.N i.I Similarly, for B-hyperstream types and node types, \nthe satis\u00adfaction relations |= are de.ned much like in Def. 3.17. See Ap\u00adpendix D.6. They have the following \nsectionwise characterizations, too. Lemma 4.14. Q ` Q\u00b4 t |= P .. M |= P|i (t)= tt ; v.*N v.N i.I ` \n-. -. \u00b4 g |= (St). (tS') .. M |= (t|i). (t ' |i) (g)= tt . i.I  4.3.3 SPROCdt : Type Derivation Typing \nrules in SPROCdt are almost the same as in SPROC. In particular the use of hypernumbers is transparent; \nthis re.ects the NSA idea that standard numbers and hypernumbers are logically the same. De.nition 4.15 \n(Type environment). A stream type environment and a node type environment for SP ROCdt are de.ned in \nthe same way as in SPROC (Def. 3.18): the former is a .nite subset G = {xi : ti} . Var \u00d7 STypeC . We \ndenote the sets of stream and node type environments by STEnv and NdTEnv, respectively. De.nition 4.16 \n(Type derivation). The type judgments and the typing rules for SP ROCdt are the same as for SPROC (Table \n4), except for: Q they are *-transformed, that is, the quanti.ers (v.N{u . C | }, .x . C, etc.) are replaced \nby the corresponding Q hyperquanti.ers (v.*N {u . * C | }, .x . * C, etc.); r we have the following two \nadditional rules. (FBY dt )is similar j r 1 to (FBY); there . .is short for .r \u00d7 .. dt dt Q(dt) .; G \n. dt : v.N{u . C |u = dt} QQ .; G . e1 : {u |P1} .; G . e2 : {u |P2} v ` v r |= .v . * N..u . * C. (v \n< .P1 . P). dt \u00b4 r (v = r .P2[(v - . .)/v] . P) r dt dt r Q(FBY dt ) .; G . e1 fby dt e2 : {u . * C |P} \nv.*N 4.3.4 SPROCdt : Type Soundness De.nition 4.17. The satisfaction relation J |= G between J . * SVarEnv \n(Def. 4.3) and G . STEnv (Def. 4.15) is def. J |= G .. J( * xi)|= G(xi)for each i . [1, m], where * xi \nis the image under * ( ): Var . * Var (Lem. 2.10.1). The satisfaction relation K |= . between K . * NdEnv \nand . . NdTEnv is de.ned in the same way. De.nition 4.18 (Validity of type judgments). We say a type \njudg\u00adment .; G . e : t is valid, and write |= .; G . e : t, if for any J . * SVarEnv and K . * NdEnv, \nJ |= G and K |= . imply [e]J,K |= t. The validity of the other three classes of type judgments is de.ned \nin the same manner. Lemma 4.19. Validity of a judgment is determined sectionwise: |= .; G . e : t .. \nM (|= .|i; G|i . e|i : t|i)i.I = tt . Finally we come to soundness. Its proof is totally modular, exploiting \nthe sectionwise characterizations of |= s. It is notable that the content of rules does not matter, as \nlong as they are sound for SP ROC. Theorem 4.20 (Type soundness of SPROCdt ). A derivable type judgment \nis valid in SPROCdt , that is, . J implies |= J.   5. Signals as Hyperstreams We introduce a translation \nbetween (continuous-time) signals and hyperstreams. This enables SPROCdt to model signals, and its type \nsystem to provide signals safety guarantees. Such signals cannot just be any function f : R=0 . C; we \nintroduce a certain class of functions that makes the translation work (Def. 5.1). The class is closed \nunder common operations like integration and differenti\u00adation, too. The basic idea of a translation between \nsignals and hyper\u00adstreams (\u00a75.2) is already in [3], where they establish the correct\u00adness of their translation \nfor functions f : R=0 . R that are everywhere continuous (they also hint an extension to piecewise continuity). \nSince we aim at hybrid applications, our class of func\u00adtions (Def. 5.1) is broader and contains some \nZeno examples such as a bouncing ball. In \u00a75.1 5.2, for simplicity, we prove results for the R-valued \nsignals and streams. Extension to C-valued ones is straightforward we can separate real and imaginary \nparts and identify C with R2 . 5.1 Signals Functions that are right continuous with left limits everywhere \nplay an important role in the theory of stochastic processes. They are called c`ag; our class of (continuous \nenough) signal is based on adl ` this. De.nition 5.1 (Signal). A function f : R=0 . R is of class C`adl \n`ag n if: 1) it is right differentiable; 2) it has left limits lim f(t) t.t0-0 for each t0 . R>0; and \n3) its right derivative fr is of class C`adl `ag n-1. A function f : R=0 . R is of class C`adl `ag 0 \nif it is right continuous and has left limits everywhere. A function f is of class C `ag 8 adl `n for \nall n . adl `if it is of class C`ag N. A function f : R=0 . R is said to be a signal if it is of class \nC`adl `ag 8 and, for any t . R=0, there is e > 0 such that f is of class C8 in the interval (t, t + e). \nSignals denotes the set of signals. f r Many common hybrid dynamics are f indeed signals in our sense; \nbut not all of them. A bouncing ball a .rst example O t O t of the Zeno behavior is modeled as a signal \n(on the right). However, if we re-( f r)r ((f r )r)r verse time and .ip horizontally, the re\u00adsulting \nis not a signal: the halting point O t t0 has no interval (t0, t0 + e) in which the function is of class \nC8 . Another nonexample arises from the compare-to-constant oper\u00adation in Simulink. The function f(t)= \ne -1 t sin 1 t (if t > 0) ; 0 (if t = 0) oscillates around t = 0 very fast but very small (due to the \nfactor -1 e t ); it is a signal. However, comparison with 0 results in a non\u00adsignal it is clearly not \nright continuous at t = 0. Our notion of signal still has reasonable closure properties. Lemma 5.2. A \nsignal f . Signals is right differentiable and Riemann integrable, resulting again in signals. Remark \n5.3. The notion of c`ag function is used mostly in the adl`context of stochastic systems. This is also \nthe case in the hybrid system literature [8, 22]. Our use of the notion suggests it might also be related \nto the question of samplability (see e.g. [34]), though the details are yet to be worked out.  5.2 \nSignals as Hyperstreams We de.ne the (hyperstream) sam- Signals  Smp *(R8) pling map Smp and the smoothing \n Smth map Smth, and show that they form (R=0 . * R . {.}) faithful translation of signals into hyperstreams, \nthat is roughly, Smth(Smp(f)) = f. Recall that in \u00a75.1 5.2 we are restricting to R-valued hyperstreams. \n De.nition 5.4 (Smp). Smp : Signals . * (R8)is de.ned by h i Smp(f) := M (f( j ))j.N . i+1 i.I This \nis exactly the hyperstream sampling (2) put in the NSA terms. Here (f( j ))j.N is in R8, for each i . \nI = N; hence by i+1 ` \u00b4 * (R8 Lem. 2.13 we have M (f( j ))j.N belong to ). i+1 i.I The converse smoothing \noperation (3) need not yield a signal, or even a function R=0 . R. The stream in (3) need not converge; \n` \u00b4 that is, in the NSA terms, the hyperreal f(.t.), f (.22 t.), . . . can be an in.nite number. This \nresults in the extended output type R=0 . * R . {.} in the following de.nition of Smth. De.nition 5.5 \n(Smth). The mapping Smth : * (R8). (R=0 . * R . {.})is de.ned as follows. Let h . * (R8)and t . R=0; \nthe latter induces a function (.(i + 1)t.)i.I from I = N to N. Lem. 2.13 yields M (.(i+ 1)t.)i.I as \nan element of * N; this is fed to h . * (R8). ( * N . * R . {.})(Lem. B.3) and we de.ne  Smth(h)(t) \n:= h M (.(i+ 1)t.)i.I . Smth . Smp = id is put precise using shadow (Def. 2.2). Theorem 5.6. For each \nf . Signals and t . R=0, the hyperreal ` \u00b4 Smth(Smp(f))(t)is limited and sh Smth(Smp(f))(t) = f(t). \n5.3 Modeling Signals in SP ROC dt From this point on we are back in the C-valued setting. We rely on \nthe de.nitions and results in \u00a75.1 5.2 extended from R to C. Soundness of signal veri.cation via SP ROCdt \nrelies on the cor\u00adrect modeling of a signal f as an SP ROCdt program pgf (cf. the usage scenario in \u00a71). \nIts extensive treatment especially the trans\u00adlation of ODEs and Simulink diagrams into SP ROCdt programs \nwill be presented in another venue. Here we present some basic results. De.nition 5.7 (SPROCdt model). \nLet f . Signals. A hyper\u00adstream expression e . SExpC in SPROCdt is said to be a model of ` \u00b4 f under \nJ, K, if sh Smth([e]J,K )(t) = f(t)for all t . R=0. It is similarly de.ned for an SPROCdt program pg \nto be a model of f. Proposition 5.8. Let e1, e2 be models of signals f1, f2 under J, K. 1. For each c \n. C, the constant symbol c . SExpC is a model of the constant signal c(t)= c. 2. (e1 aop e2)is a model \nof the signal (f1 aop f2)(computed pointwise) under J, K, for aop . {+,\u00d7, .}.  r r sec. 3. (e1 fby dt \ne2)is a model, under J, K, of the signal (f1 fbyf2). The latter is de.ned below; it is easily seen to \nbe a signal. ( ` \u00b4 f1(t) if t < r, f1 fbyr sec. f2 (t):= f2(t -r) if t = r. As to Lem. 5.2, we also have \nSPROCdt programs for right differentiation and Riemann integration. We leave them to another venue. In \nExample 1.1 we have used an SPROCdt model (6) of the sine curve, where the latter is de.ned using an \nODE. Its (intuitively ob\u00advious) correctness can be proved by showing that Smth([pgSine ]) is a solution \nof the ODE de.ning the sine curve. 5.4 Safety Guarantee for Signals In translating safety guarantees \nfrom SPROCdt to signals, the prop- Q erty t = v{u | P} cannot be just anything after all, Smp samples \nonly countably many t . R. A suf.cient condition is given by t s being (topologically) closed. It means \nthat the set {(u, v) | |= P}is closed in C2. The type syntax for signals is restricted accordingly; in \nparticular, adding <, \u00ac or .makes topo\u00adlogical closedness fail. De.nition 5.9 (Type Syntax for Signals). \nAExp . a ::= v |c |a1 aop a2 where v . Var, c . C, aop . {+,\u00d7, .} Fml . P ::= true |false |P1 .P2 |P1 \n.P2 |a1 = a2 | isReal(a)|a1 = a2 |.v . C. P where v . Var, a, ai . AExp Q SgType . t ::= {u . C |P} where \nu, w . Var, w.R=0 P . Fml and FV(P). {u, w} ' ' SgPrType. . ::= (t1,. . . , tm). (t1,. . . , t ) m,n \nn ' where ti, t i . SgType The set SgType is that of signal types. De.nition 5.10 (Semantics of Signal \nTypes). A valuation Lis the same as in Def. 3.15; L |= P with P . Fml is de.ned as usual, too. Between \nf . Signals and t . SgType, f |= t is de.ned by: Qdef. f |= {u . C |P} .. w.R=0 .t . R=0. .L . Val. L[w \n. t, u . f(t)] |= P . As in Def. 3.17, Lin the above is vacuous since FV(P). {u, w}. De.nition 5.11 (Translation \np HS of types). To each type expres\u00adsion pfor signals (Def. 5.9), we assign an SP ROCdt type expression \np HS. It is de.ned by replacing: 1) the signal type Q{u . C | w.R=0 QPHS P}with the hyperstream type \n{u . C | [(v\u00d7dt)/w]}; v.*N 2) quanti.ers .v . C with hyperquanti.ers .v . * C. The idea of p HS is to \nrepresent time w in P by the step number v multiplied by the sampling interval dt. Theorem 5.12 (Soundness). \nLet f . Signals be a signal, and Q t = {u . C |P}. SgType be a signal type. Assume w.R=0 further that \nan SPROCdt program pg is a model of f (Def. 5.7). Then: . pg : () . (tHS) =. f |= t . We expect the opposite \ndirection . of the theorem to fail in general the left-hand side guarantees safety also for a time t \nthat is in.nitely large. We also note that, while the signal type syntax (Def. 5.9) is more restricted \nthan that of SP ROCdt (\u00a74.3), in deriving the left-hand side of the theorem one can safely use the full \nSP ROCdt type system.  6. An Example: The Sine Curve We verify the range of the sine curve. Speci.cally, \nwe show that in Example 1.1 satis.es, for any real constants t0 > 0 and e > 0, pgSine Q [pgSine ] |= \n{u . C |t0 = w .u = 1 + e} . (27) w.R=0 Our intuition of the formula in (27) is w < t0 . u = 1 + e; due \nto the restricted syntax of signal types (Def. 5.9) it is written as in (27). By Thm. 5.12, it suf.ces \nto derive the following type judgment using the typing rules of SPROCdt .  : () . (tgoal) , where . \npgSine Q (28) tgoal := v.*N{u . * C |t0 = v \u00d7 dt .u = 1 + e} . In its derivation, the most signi.cant \nstep (below) uses the principle of .xed point induction to deal with the intra-node recursion (s and \nc) in pgSine . This step is an instance of the (NODE) rule (Table 4): (a) .0;{s : ts-inv, c : tc-inv}. \n0fby1 (s + c \u00d7 dt): ts-inv (b) .0;{s : ts-inv, c : tc-inv}. 1fby1 (c -s \u00d7 dt): tc-inv (c) .0;{s : ts-inv, \nc : tc-inv}. s : ts-inv 2 3 . . node Sine() returns (s) s : ts-inv () . .0; . 4 where s = 0fby1 (s + \nc \u00d7 dt); 5 : c : tc-inv (ts-inv) c = 1fby1 (c -s \u00d7 dt) (29) Here the type environment Ginv := {s : ts-inv, \nc : tc-inv}plays the role of an invariant. The types are concretely as follows. Q * 1 1 ts-inv = {u . \nC |u = i(1 -i\u00b7 dt)v - i(1 + i \u00b7 dt)v} Qv.*N 2 2 * 1 1 tc-inv = {u . C |u = (1 -i\u00b7 dt)v + (1 + i \u00b7 dt)v} \nv.*N 2 2 Here iis the imaginary unit. .0 in (29) is {Sine : () . tgoal}. It is straightforward to derive \nthe assumptions (a c) of (29). The derivation of (a) is in Appendix D.12. (b) is similar; (c) is by (SVAR). \nTherefore we have derived the conclusion of (29). To it we apply the (N DCONSEQ) and (PROG) rules and \nderive our .nal goal : () . (tgoal). The former requires the side condition . pgSine ` 1 |= .v . * N. \n.u . * C. u = i(1 -i\u00b7 dt)v - 1i(1 + i \u00b7 dt)v 2 \u00b4 2 . (t0 = v \u00d7 dt .u = 1 + e) . (30) Its is proved in \na discrete manner, using Lem. 2.13. See Ap\u00adpendix D. As is always with the Hoare-style logics, invariant \ndiscovery is the hardest part in SP ROCdt type derivation. In this example we discovered the invariants \nts-inv, tc-inv by solving the recurrence re\u00adlations derived from the program. This is a totally discrete \nbusiness.  7. Conclusions and Future Work Starting from a familiar framework of a stream processing \nlanguage SPROC, its Kahn-style denotational semantics and a type system as a program logic, we extended \nit with a constant dt and obtained a framework for hyperstreams. Translation of signals into hyper\u00adstreams \nenables us to use deductive veri.cation in SPROCdt for certain safety guarantees of signals. The logical \ninfrastructure of NSA provides the framework with a rigorous mathematical basis. Some directions of future \nwork are mentioned in the related work part of \u00a71; here we add a couple. In this paper we have made one \ndiscretization technique (namely discrete sampling) hyper and thus exact. We are interested in use of \nNSA in other discretiza\u00adtion techniques such as the Fourier transform. Type inference for SPROCdt is \nfuture work. Due to its character as a program logic, the situation would be much like with Hoare\u00adstyle \nlogics: even type checking (i.e. proof search) would be unde\u00adcidable; and the biggest challenge would \nbe in invariant discovery.  Acknowledgments Thanks are due to the participants of NII Shonan Meeting \nHybrid Systems: Theory and Practice, Seriously for useful discussions; in particular to Manuela Luminita \nBujorianu for drawing our attention to c `ag functions. We are also grateful to the anonymous referees \nadl`for their useful suggestions and critical questions; and to Samuel Mimram for letting know of their \nwork [3] (which, to our shame, we were not aware of until the last stage of the paper s preparation). \nK.S. is supported by Grant-in-Aid for Research Activity Start\u00adup No. 24800035, JSPS, and by Hakubi Project, \nKyoto Univesity; H.S. &#38; I.H. are supported by Grants-in-Aid for Young Scientists (A) No. 24680001, \nJSPS, and by Aihara Innovative Mathematical Modelling Project, FIRST Program, JSPS/CSTP.  References \n[1] S. Abramsky and A. Jung. Domain theory. In S. Abramsky, D. M. Gabbai, and T. S. E. Maibaum, editors, \nHandbook of Logic in Com\u00adputer Science, volume 3, pages 1 168. Oxford Univ. Press, 1994. [2] R. Alur, \nC. Courcoubetis, N. Halbwachs, T. A. Henzinger, P.-H. Ho, X. Nicollin, A. Olivero, J. Sifakis, and S. \nYovine. The algorithmic analysis of hybrid systems. Theor. Comp. Sci., 138(1):3 34, 1995. [3] R. Beauxis \nand S. Mimram. A non-standard semantics for Kahn networks in continuous time. In M. Bezem, editor, CSL, \nvolume 12 of LIPIcs, pages 35 50. Schloss Dagstuhl -Leibniz-Zentrum fuer Informatik, 2011. ISBN 978-3-939897-32-3. \n[4] A. Benveniste, T. Bourke, B. Caillaud, and M. Pouzet. Divide and recycle: types and compilation for \na hybrid synchronous language. In J. Vitek and B. D. Sutter, editors, LCTES, pages 61 70. ACM, 2011. \n[5] A. Benveniste, T. Bourke, B. Caillaud, and M. Pouzet. Non-standard semantics of hybrid systems modelers. \nJ. Comput. Syst. Sci., 78(3): 877 910, 2012. [6] S. Bliudze and D. Krob. Modelling of complex systems: \nSystems as data.ow machines. Fundam. Inform., 91(2):251 274, 2009. [7] O. Bouissou and A. Chapoutot. \nAn operational semantics for Simulink s simulation engine. In R. Wilhelm, H. Falk, and W. Yi, edi\u00adtors, \nLCTES, pages 129 138. ACM, 2012. ISBN 978-1-4503-1212-7. [8] M. L. Bujorianu and J. Lygeros. Theoretical \nfoundations of stochastic hybrid systems. In International Symposium on Mathematical Theory of Networks \nand Systems (MTNS 2004), 2004. [9] P. Caspi, D. Pilaud, N. Halbwachs, and J. Plaice. Lustre: A declarative \nlanguage for programming synchronous systems. In POPL, pages 214 227. ACM Press, 1987. ISBN 0-89791-215-2. \n[10] A. Chapoutot and M. Martel. Abstract simulation: A static analysis of simulink models. In T. Chen, \nD. N. Serpanos, and W. Taha, editors, ICESS, pages 83 92. IEEE, 2009. [11] A. Gamati \u00b4e and L. Gonnord. \nStatic analysis of synchronous programs in signal for ef.cient design of multi-clocked embedded systems. \nIn J. Vitek and B. D. Sutter, editors, LCTES, pages 71 80. ACM, 2011. [12] R. Goldblatt. Lectures on \nthe Hyperreals: An Introduction to Nonstan\u00addard Analysis. Springer-Verlag, 1998. [13] I. Hasuo and K. \nSuenaga. Exercises in Nonstandard Static Analysis of hybrid systems. In P. Madhusudan and S. A. Seshia, \neditors, CAV, volume 7358 of Lect. Notes Comp. Sci., pages 462 478. Springer, 2012. [14] A. E. Hurd and \nP. A. Loeb. An Introduction to Nonstandard Real Analysis. Academic Press, 1985. [15] G. Kahn. The semantics \nof simple language for parallel programming. In IFIP Congress, pages 471 475, 1974. [16] N. R. Krishnaswami \nand N. Benton. Ultrametric semantics of reactive programs. In LICS, pages 257 266. IEEE Computer Society, \n2011. ISBN 978-0-7695-4412-0. [17] E. A. Lee and H. Zheng. Operational semantics of hybrid systems. In \nMorari and Thiele [19], pages 25 53. ISBN 3-540-25108-1. [18] Z. Manna and A. Pnueli. Temporal Veri.cation \nof Reactive Systems: Safety. Springer, 1995. ISBN 978-0-387-94459-3. [19] M. Morari and L. Thiele, editors. \nHybrid Systems: Computation and Control, 8th International Workshop, HSCC 2005, Zurich, Switzer\u00adland, \nMarch 9-11, 2005, Proceedings, volume 3414 of Lecture Notes in Computer Science, 2005. Springer. ISBN \n3-540-25108-1. [20] H. Nakano. A modality for recursion. In LICS, pages 255 266. IEEE Computer Society, \n2000. ISBN 0-7695-0725-5. [21] A. Platzer. Logical Analysis of Hybrid Systems Proving Theorems for Complex \nDynamics. Springer, 2010. ISBN 978-3-642-14508-7.  [22] A. Platzer. Stochastic differential dynamic \nlogic for stochastic hybrid programs. In N. Bj\u00f8rner and V. Sofronie-Stokkermans, editors, CADE, volume \n6803 of Lecture Notes in Computer Science, pages 446 460. Springer, 2011. ISBN 978-3-642-22437-9. [23] \nA. Platzer. The complete proof theory of hybrid systems. In LICS, 2012. [24] A. Robinson. Non-standard \nanalysis. Princeton Univ. Press, 1996. [25] E. Rodr\u00b4iguez-Carbonell and A. Tiwari. Generating polynomial \ninvari\u00adants for hybrid systems. In Morari and Thiele [19], pages 590 605. ISBN 3-540-25108-1. [26] S. \nSankaranarayanan. Automatic invariant generation for hybrid sys\u00adtems using ideal .xed points. In K. H. \nJohansson and W. Yi, editors, HSCC, pages 221 230. ACM, 2010. ISBN 978-1-60558-955-8. [27] S. Sankaranarayanan, \nH. B. Sipma, and Z. Manna. Constructing invariants for hybrid systems. Formal Meth. in Sys. Design, 32(1): \n25 55, 2008. [28] P. Schrammel and B. Jeannet. From hybrid data-.ow languages to hybrid automata: a complete \ntranslation. In T. Dang and I. M. Mitchell, editors, HSCC, pages 167 176. ACM, 2012. ISBN 978-1-4503-1220\u00ad \n2. [29] R. Stephens. A survey of stream processing. Acta Inf., 34(7):491 541, 1997. [30] K. Suenaga and \nI. Hasuo. Programming with in.nitesimals: A while\u00adlanguage for hybrid system modeling. In L. Aceto, M. \nHenzinger, and J. Sgall, editors, ICALP (2), volume 6756 of Lect. Notes Comp. Sci., pages 392 403. Springer, \n2011. ISBN 978-3-642-22011-1. [31] K. Suenaga, H. Sekine, and I. Hasuo. Hyperstream processing sys\u00adtems: \nNonstandard modeling of continuous signal processing. Ex\u00adtended version with proofs, 2013. www-mmm.is.s.u-tokyo.ac.jp/~ichiro/papers.html \n. [32] T. Terauchi. Dependent types from counterexamples. In M. V. Hermenegildo and J. Palsberg, editors, \nPOPL, pages 119 130. ACM, 2010. ISBN 978-1-60558-479-9. [33] S. Tripakis, C. Sofronis, P. Caspi, and \nA. Curic. Translating discrete\u00adtime simulink to Lustre. ACM Trans. Embedded Comput. Syst., 4(4): 779 \n818, 2005. [34] Z. Wan and P. Hudak. Functional reactive programming from .rst principles. In M. S. Lam, \neditor, PLDI, pages 242 252. ACM, 2000. ISBN 1-58113-199-2. [35] K. R. Wicks. Nonstandard analysis of \nordered sets. Order, 12:265 293, 1995.   \n\t\t\t", "proc_id": "2429069", "abstract": "<p>We exploit the apparent similarity between (discrete-time) stream processing and (continuous-time) signal processing and transfer a deductive verification framework from the former to the latter. Our development is based on rigorous semantics that relies on nonstandard analysis (NSA).</p> <p>Specifically, we start with a discrete framework consisting of a Lustre-like stream processing language, its Kahn-style fixed point semantics, and a program logic (in the form of a type system) for partial correctness guarantees. This stream framework is transferred as it is to one for hyperstreams---streams of streams, that typically arise from sampling (continuous-time) signals with progressively smaller intervals---via the logical infrastructure of NSA. Under a certain continuity assumption we identify hyperstreams with signals; our final outcome thus obtained is a deductive verification framework of signals. In it one verifies properties of signals using the (conventionally discrete) proof principles, like fixed point induction.</p>", "authors": [{"name": "Kohei Suenaga", "author_profile_id": "81363593440", "affiliation": "Kyoto University, Kyoto, Japan", "person_id": "P3978017", "email_address": "ksuenaga@kuis.kyoto-u.ac.jp", "orcid_id": ""}, {"name": "Hiroyoshi Sekine", "author_profile_id": "81552902056", "affiliation": "University of Tokyo, Tokyo, Japan", "person_id": "P3978018", "email_address": "nue_of_k@is.s.u-tokyo.ac.jp", "orcid_id": ""}, {"name": "Ichiro Hasuo", "author_profile_id": "81436592612", "affiliation": "University of Tokyo, Tokyo, Japan", "person_id": "P3978019", "email_address": "ichiro@is.s.u-tokyo.ac.jp", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429120", "year": "2013", "article_id": "2429120", "conference": "POPL", "title": "Hyperstream processing systems: nonstandard modeling of continuous-time signals", "url": "http://dl.acm.org/citation.cfm?id=2429120"}