{"article_publication_date": "01-23-2013", "fulltext": "\n Views: Compositional Reasoning for Concurrent Programs Thomas Dinsdale-Young Lars Birkedal Philippa \nGardner Imperial College IT University of Copenhagen Imperial College td202@doc.ic.ac.uk birkedal@itu.dk \npg@doc.ic.ac.uk Matthew Parkinson Microsoft Research mattpark@microsoft.com Abstract Compositional \nabstractions underly many reasoning principles for concurrent programs: the concurrent environment is \nabstracted in order to reason about a thread in isolation; and these abstrac\u00adtions are composed to reason \nabout a program consisting of many threads. For instance, separation logic uses formulae that describe \npart of the state, abstracting the rest; when two threads use disjoint state, their speci.cations can \nbe composed with the separating con\u00adjunction. Type systems abstract the state to the types of variables; \nthreads may be composed when they agree on the types of shared variables. In this paper, we present the \nConcurrent Views Framework , a metatheory of concurrent reasoning principles. The theory is pa\u00adrameterised \nby an abstraction of state with a notion of composi\u00adtion, which we call views. The metatheory is remarkably \nsimple, but highly applicable: the rely-guarantee method, concurrent sepa\u00adration logic, concurrent abstract \npredicates, type systems for recur\u00adsive references and for unique pointers, and even an adaptation of \nthe Owicki-Gries method can all be seen as instances of the Con\u00adcurrent Views Framework. Moreover, our \nmetatheory proves each of these systems is sound without requiring induction on the oper\u00adational semantics. \nCategories and Subject Descriptors F.3.1 [Specifying and Verify\u00ading and Reasoning about Programs]: Logics \nof programs General Terms Theory, Veri.cation Keywords concurrency; axiomatic semantics; compositional \nrea\u00adsoning 1. Introduction This paper aims to .nd the core principles underlying compo\u00adsitional reasoning \nsystems for (.rst-order) concurrent programs. Compositional reasoning means that we consider each component \nin isolation without having to know the precise concurrent, or se\u00adquential, context in which it will \nbe placed. This is essential for rea\u00adsoning about incomplete code or libraries: the context is not known. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n13, January 23 25, 2013, Rome, Italy. Copyright c &#38;#169; 2013 ACM 978-1-4503-1832-7/13/01. . . $10.00 \nHongseok Yang University of Oxford hongseok00@gmail.com In a concurrent setting, compositional reasoning \nallows a thread to be considered in isolation, rather than considering all possible in\u00adterleavings of \na program. Type systems and program logics are two common forms of compositional reasoning. They strike \na balance between invari\u00adant properties that must be preserved during the execution of a concurrent program, \nand operations that may be performed. Stan\u00addard type systems and rely-guarantee methods [20] focus on \npre\u00ad serving global properties: for example, the typing of the memory. Such approaches are good at handling \nsharing and interference, but work less well with stateful behaviour. Contrastingly, separa\u00adtion logic \n[18, 27] focuses on local portions of the state, which can be manipulated independently. This approach \nis good at han\u00addling stateful behaviour, but works less well with sharing and in\u00adterference. There have \nbeen forays into the middle ground such as linear types [1, 23, 29] and related capability systems [7], \nwhich allow strong (type-changing) updates to memory, and SAGL [15], RGSep [31], LRG [14] and deny-guarantee \n[9, 13], which combine ideas from rely-guarantee and separation logic to enable reasoning about .ne-grained \nconcurrency in the heap. These developments have led to increasingly elaborate reasoning systems, each \nintro\u00adducing new features to tackle speci.c applications of compositional reasoning and ad-hoc metatheory \nto justify these features. Given the diversity of these approaches, it is not clear that they have signi.cant \ncommon ground. Can the ad-hoc metatheory of each be generalised to give a paradigm in which all can be \nunderstood? We argue that in fact the above reasoning systems employ a common approach to compositionality. \nThey provide thread\u00adspeci.c abstractions of the state, which embody enough informa\u00adtion to prove properties \nabout the behaviour of a thread whilst allowing for the possible behaviours of other threads. We introduce \nthe Concurrent Views Framework ( Views Framework or Views for short), which captures this compo\u00adsitional \nreasoning by introducing the notion of views. Intuitively, a thread s view consists of abstract knowledge \nabout the current state of the machine and the thread s rights to change the state of the machine. The \nknowledge of a thread must be stable under the op\u00aderations of concurrent threads: no other thread may \nhave rights to invalidate the thread s knowledge. Conversely, no thread can have knowledge that another \nthread has the right to invalidate. Views are compositional: knowledge and rights may be distributed \nbetween threads and recombined. To illustrate the Views Framework, .rst consider type systems for an \nimperative concurrent language. In a simple type system, the types of variables are invariant. Each thread \ns view is provided by a typing context, which embodies the knowledge that the values of variables agree \nwith their types, and the rights to change the state such that this typing is preserved. When views are \ncomposed, they must agree on the types of all variables they share. In a type system that permits strong \n(i.e. type-changing) updates, threads again have knowledge that variables agree with their types, but \nmay make updates that change the types of variables. Threads views may be consistently composed only \nif they describe disjoint sets of variables, which each thread can be seen to own. Note that, since heap \nlocations may be aliased by multiple variables, it is not in general permissible to update their types. \nHowever, a type system may include unique reference types, that confer ownership of heap locations, and \nhence allow type-changing updates. In this paper, we show how a simple type system (\u00a72.2), a type system \nwith strong updates, recursive types and subtyping (\u00a77.1), and a type system with unique references (\u00a77.2) \ncan all be formalised in Views.  Now consider program logics for the same concurrent language. With \nconcurrent separation logic, the views are assertions that describe the part of the state owned by a \nthread. These views embody knowledge about the owned part of the state, and confer the exclusive right \nto modify it. Views are composed with the separating conjunction, which enforces disjoint ownership of \nthe state, so that no thread may alter state owned by another thread. More elaborate logics, such as \ndeny-guarantee [13] and concurrent abstract predicates (CAP) [9], allow assertions to describe shared \nstate and ownership of speci.c capabilities to update the shared state. Here, the stability of assertions \nis important: an assertion about the shared state must be invariant under operations for which other \nthreads may have capabilities. In this paper, we represent a wide range of example program logics in \nour Views Framework, including several separation logics (\u00a7\u00a73.1, 3.2, 7.4), the Owicki-Gries [24] (\u00a77.3) \nand rely-guarantee methods [20] (\u00a74) and CAP (\u00a77.5). A fuller description of all our examples can be \nfound in the technical report [11], along with Coq formalisations of many of them. The Views Framework \nembodies the essential ingredients for sound compositional reasoning. Given a set of views with a com\u00adposition \noperator (denoted *), together with an axiomatisation for the atomic commands, Views provides a generic \nprogram logic. For soundness, we require a rei.cation function from views to sets of machine states and \nan axiom soundness property. The rei.ca\u00adtion function relates partial, abstract views to complete, concrete \nmachine states. Axiom soundness ensures that the axioms for the atomic commands are sound with respect \nto the rei.cation, in the context of an arbitrary environment view. This embeds composi\u00adtionality in \nthe meaning of program C updates the view from p to q : for all environment views r, it must update p \n* r to q * r. This approach has previously been used for extending sequential separation logic for higher-order \nlanguages, where it is otherwise dif.cult to characterise locality properties of commands, which are \nsuf.cient for ensuring compositionality [2, 3]. We show that the in\u00ad terpretation also provides a simpler \nand more general metatheory for logics of concurrent programs, identifying simple properties needed to \nprove soundness in contrast with the complex soundness C ::= a skip C; CC + CC I CC . results in the \nliterature. Given the wide range of examples that are instances of our framework, we believe Views embodies \nthe core principles un\u00adderlying compositional reasoning about concurrent programs. Overview. In \u00a72 we \npresent our core contribution the Concur\u00ad rent Views Framework de.ning the parameters and properties \nnecessary to instantiate our general program logic. As a pedagogi\u00adcal example, we show how a simple type \nsystem may be encoded in Views. In \u00a73, we show how separation algebras and interference can be used to \nconstruct instances of the Views Framework, illustrating these constructions with separation logic. In \n\u00a74, we present a novel generalisation of the frame rule for the Views Framework. This rule makes it possible \nto encode contextual rules, which we illustrate by the weakening rule of the rely-guarantee method. We \npresent a gen\u00aderal combination rule in \u00a75, which generalises the rules of disjunc\u00ad tion and conjunction. \nWe give a suf.cient condition for its sound\u00adness and consider the special cases of disjunction and conjunction. \nWe outline the general soundness proof for the framework in \u00a76. In \u00a77, we show the versatility of Views \nthrough .ve further example instances: recursive types, unique types, the Owicki-Gries method, atomic \nconcurrent separation logic, and concurrent abstract predi\u00adcates. Finally, we discuss related work in \n\u00a78 and conclude in \u00a79. We have formalised all of the metatheory of the paper, as well as many of the \nexamples, in Coq (see [11]). 2. Concurrent Views Framework In this section, we present the Concurrent \nViews Framework. In \u00a72.1, we present the programming language and its operational se\u00ad mantics, which \nis parameterised by a notion of state and a set of primitive atomic commands and their semantics as state \ntransform\u00aders. In \u00a72.2, we provide a set of rules for compositional reasoning, which is parameterised \nby an abstraction of the state equipped with a composition operation a views semigroup and an axiomati\u00adsation \nof the atomic commands. In \u00a72.3, we give a general sound\u00ad ness result for the framework with respect \nto the operational seman\u00adtics, which is parameterised by a relationship between the abstract views and \nthe concrete states, and requires each axiom to satisfy a soundness property with respect to the semantics \nof the corre\u00adsponding atomic command. To illustrate the Views Framework, we interleave its de.nition \nwith an example of how to instantiate it for a simple type system for a heap update language. 2.1 Programming \nLanguage and Operational Semantics We de.ne the Views Framework on a simple programming lan\u00adguage that \nis built from standard composite commands, and param\u00adeterised by a set of atomic commands. This enables \nus to consider many examples without having to change the metatheory. Parameter A (Atomic Commands). \nAssume a set of (syntactic) atomic commands Atom, ranged over by a. De.nition 1 (Language Syntax). The \nset of (syntactic) commands,    Comm, ranged over by C, is de.ned by the following grammar: * The \nViews Framework provides a generalised frame rule. This rule is essential for directly encoding the weakening \nrule from rely\u00ad guarantee and rules for manipulating resource invariants in concur\u00adrent separation logic. \nThe new rule allows a function to be applied The operational semantics is parameterised by a model of \nma\u00ad chine states and an interpretation of the atomic commands as state transformers. Parameter B (Machine \nStates). Assume a set of machine states S,  uniformly to the pre-and postcondition of a command. Without \nranged over by s. this rule the encoding of concurrent separation logic, rely-guarantee Parameter C (Interpretation \nof Atomic Commands). Assume a and Owicki-Gries method would require a far more complex rep\u00ad function \n[-] : Atom . S . P (S) that associates each atomic resentation of the high-level reasoning with permissions, \nsuch as command with a non-deterministic state transformer. (Where nec\u00ad deny-guarantee. essary, we lift \nnon-deterministic state transformers to sets of states:  for S . P (S), [a](S) = {[a](s) | s . S}.) \nFor machine state s, the set of states [a](s) is the set of pos\u00adsible outcomes of running the atomic \ncommand a. If the set is empty, then the command blocks. Here, we consider partial cor\u00adrectness, and \nso ignore executions that deadlock that is, reach a state (other than skip) in which every thread is \nblocked. If we wish to guarantee against some exceptional behaviour, it should be modelled with an exception \nstate, rather than by blocking. We de.ne the operational semantics of the language using a labelled transition \nsystem. Transitions are between commands, and are labelled by atomic commands or id. id labels computation \nsteps in which the state is not changed. De.nition 2 (Transition Labels). The set of transition labels, \ndef Label = Atom l {id}, extends the set of atomic commands with a designated identity label, id. Labels \nare ranged over by a. [-] is def extended to Label by de.ning [id] = .s. {s}. The labelled transition \nsystem splits the control-.ow aspect of execution, represented by the transitions between commands, and \nthe state-transforming aspect of execution, represented by the la\u00adbelling of the transitions. This makes \nit easy to reinterpret programs over a more abstract state-space, while preserving the control-.ow structure, \nwhich simpli.es the soundness proof of our logic. De.nition 3 (Labelled Transition System and Operational \nSeman\u00ad - tics). The labelled transition relation - -. - : Comm \u00d7 Label \u00d7 Comm is de.ned by the following \nrules: by: def := y (s) = y . dom(s) C {s[x . s(y )]} [x def [[x ] := v (s) = x , s(x ) . dom(s) C {s[s(x \n) . v]} def [x ] := y (s) = x , y , s(x ) . dom(s) C {s[s(x ) . s(y )]} def [ x := [y ]] (s) = y , s(y \n) . dom(s) C {s[x . s(s(y ))]} def [x := ref y ](s) = y . dom(s) C {s[x . l, l . s(y )] | l . Loc \\ dom(s)} \nwhere b C s = if b then s else !. Here we extend dom to SH by taking dom(!) = \u00d8.  2.2 Views and Program \nLogic Reasoning systems typically do not require the user to reason di\u00adrectly about the state; they provide \nan abstract representation of the state that supports a particular form of reasoning. For example, in \na simple type system the state is abstracted by a type context, G, which maps variables, x , to types, \nt . A type represents a property about the variable, e.g. that it is a pointer to a cell in the heap. \nIn a program logic like separation logic, the state is abstracted by asser\u00adtions, P, Q, that describe \nparts of the memory. Complex assertions may be used to represent interesting structures, such as a lock \nx with an invariant P : Lock(x, P ). Such assertions may not merely describe the state, but also enforce \na protocol that threads must obey for instance, only releasing a lock after establishing its invariant. \n-. C1 i . {1, 2} idid -. C -. C2 -. Ci a a These abstract representations do not precisely describe the \nmem\u00ad ory, just certain properties it satis.es. They also can contain addi\u00ad tional information about \ntyping, ownership and protocols, for C1 C1; C2 ; C2 skip; C2 C1 + C2 1 instance that is not present \nin the underlying state. idididid C* -. C; C* C* -. skip skip C2 -. C2 C1 skip -. C1 These abstractions \nform the key parameter of the framework: the views. We have one basic requirement for views, which is \nthat aa ---. skip -- The multi-step operational transition relation -, - . * -, - : tative semigroup \n(View, *). The variables p, q, r are used to denote (Comm \u00d7 S) \u00d7 (Comm \u00d7 S) is de.ned by the following \nrules: elements of View. aa . C2 a- a C1 . C C2 1 . C 2 they form a commutative semigroup. C1 C2 C2 \nC1 C2 a . C 1 . C1 C 2 Parameter D (View Commutative Semigroup). Assume a commu\u00ad s2 . [a](s1) C2, s2 \n.* C3, s3 If the semigroup has a unit, u, then we call it a view monoid, C1, s1 .* C3, s3 C1 written \n(View, *, u). The unit is not required for the theory, but C, s .* C, s Heap Update Language For our \nexamples, we use a language with simple atomic prim\u00aditives for manipulating a heap. We therefore de.ne \ninstances of Parameters A, B and C accordingly. De.nition 4 (Atomic Heap Commands) : Parameter A. As\u00adsume \na set of variable names Var, ranged over by x and y , and a set of values Val, ranged over by v, of which \na subset Loc . Val represents heap addresses, ranged over by l. The syn\u00adtax of atomic heap commands, \nAtomH, is de.ned by the gram\u00admar: a ::= x := y [x ] := v [x ] := y x := [y ] x := ref y . De.nition 5 \n(Heap States) : Parameter B. Machine states are partial functions from variables and locations to values. \nThere is also an exceptional faulting state, denoted !, which represents the result of an invalid memory \naccess. Formally, def SH = ((Var l Loc) -.n Val) l {!}. De.nition 6 (Heap Command Interpretation) : Parameter \nC. The interpretation of the atomic heap-update commands is given simpli.es its use. Intuitively, views \nare resources that embody knowledge about the state and the protocol threads must obey, and rights to \nmodify the state in accordance with the implied protocol. The semigroup operation * (view composition) \ncombines the knowledge and rights of two views. Since composition is used to combine the views of different \nthreads, it must ensure consistency between these views. For exam\u00adple, to combine two typing contexts, \nthey must agree on the type of any variables they have in common. Since threads only maintain the types \nin their view, if agreement was not enforced then one thread might violate another s expectations. In \nseparation logic, composition (separating conjunction) en\u00adforces that ownership is exclusive: no two \nviews can simultane\u00adously have ownership of a heap cell. In variants that allow asser\u00adtions about shared \nstate, such as deny-guarantee, composition also forces consistency between such assertions. This consistency \nis typically implemented by a special incon\u00adsistent view that is the result of composing two views that \nare not consistent. The inconsistent view is usually a (unique) zero element of the semigroup: when composed \nwith any other view, the result is the inconsistent view. We de.ne a program logic for our programming \nlanguage, in which views provide the pre-and postconditions of the commands.  The program logic is parameterised \nby the set of axioms for atomic commands. Parameter E (Axiomatisation). Assume a set of axioms Axiom \n. View \u00d7 Label \u00d7 View. De.nition 7 (Entailment). The entailment relation F . View \u00d7 View is de.ned by: \ndef p F q .. (p, id, q) . Axiom. De.nition 8 (Program Logic). The program logic s judgements are of the \nform f {p} C {q}, where p, q . View provide the precondition and postcondition of command C . Comm. The \nproof rules for these judgements are as follows: (p, a, q) . Axiom f {p} C {q} f {p} a {q} f {p * r} \nC {q * r} f {p} skip {p} f {p} C1 {q} f {p} C2 {q} f {p} C {p} f {p} C1 + C2 {q} f {p} C* {p} f {p} C1 \n{r} f {r} C2 {q} f {p1} C1 {q1} f {p2} C2 {q2} f {p} C1; C2 {q} f {p1 * p2} C1 C2 {q1 * q2} p F p f {p \n} C {q} f {p} C {q } q F q f {p} C {q} f{p} C {q} The intended semantics of f {p} C {q} is that if the \nprogram C is run to termination from an initial state that is described by the view p, then the resulting \nstate will be described by the view q. This is a partial correctness interpretation: the judgements say \nnothing about non-terminating executions. The proof rules are standard rules from disjoint concurrent \nseparation logic. They include the frame rule, which captures the intuition that a program s view can \nbe extended with a composable view, and the disjoint concurrency rule, which allows the views of two \nthreads to be composed. Note that, although in separation logic the concurrency rule imposes disjointness, \nin Views it does not; it just imposes composability. The last two rules are rules of consequence: they \nallow the precondition to be strengthened or the postcondition weakened with respect to the axiomatically-speci.ed \nrelation F. If F is re.exive, these rules may be combined into a single rule. Simple Type System Consider \na simple type system for our heap update language, where variables and heap cells are typed from the \nset Type, ranged over by t, and de.ned by: t ::= val ref t. The type val indicates that a variable or \nheap cell contains some unspeci.ed value, while the type ref t indicates that it contains the address \nof a heap cell whose contents is typed as t . A typing context G : Var -Type is a partial function which \nassigns types to variables. Within the Views Framework, typing contexts are views. Composition, .., is \nthe union of contexts (as relations), with a special inconsistent typing context, ., used to denote the \ncom\u00ad position of typing contexts that disagree on the type of some variable. De.nition 9 (Simple Type \nViews) : Parameter D. The view monoid for the simple type system is de.ned as: ((Var -Type) l {.} , .., \n\u00d8) Judgements of the type system have the form G f C. We treat this as syntax for f {G} C {G} in the \nViews Framework. It remains to give axioms for the type system. De.nition 10 (Simple Type Axioms) : Parameter \nE. The ax\u00adioms for the simple type system are de.ned schematically as: x : t, y : t f x := y x : ref \nval f [x ] := v x : t , y : ref t f x := [y ] x : ref t, y : t f x := ref y  x : ref t, y : t f [x \n] := y The inference rules of the type system are as follows: G f C1 G f C2 op . {; , +} G f skip G f \nC1 op C2 G1 f C1 G2 f C2 G f C G f C G1, G2 f C1 C2 G f C* G, G f C Each of these rules is justi.ed by \nthe rules of the Views program logic, where we interpret G1, G2 as G1 .. G2. The most interest\u00ading of \nthese is the last, the weakening rule, which is an instance of the frame rule, with the frame G .  2.3 \nRei.cation and Soundness In order to relate the program logic to the operational semantics, it is necessary \nto de.ne a relationship between the abstract views and the concrete machine states. In a type system, \nthis would be given by a judgement G f s asserting that state s is well-typed with respect to the context \nG. In separation logic, it would be given by a Kripke model, where the judgement s |= P asserts that \nformula P holds in state s. In the Views Framework, we model this relationship with a rei.cation function. \nParameter F (Rei.cation). Assume a rei.cation function l-J : View . P (S) which maps views to sets of \nmachine states. Note that the rei.cation function has very few restrictions. The semigroup structure \nof views is not re.ected at the level of machine states: the notion of composition is purely an abstraction. \nThe space of machine states need not be covered completely by the rei.cation; this is useful for giving \nfault-avoiding interpretations to our proof judgements. Furthermore, inconsistent views may be mapped \nto the empty set of machine states. Choosing an appropriate rei.cation function is important. We could, \nfor instance, map all views to the empty set and claim soundness of an arbitrary logic. However, judgements \nin the logic would convey no information about the operational semantics, as they would not describe \nthe execution of a program from any initial state at all. Consequently, soundness is always with respect \nto the choice of rei.cation function. Soundness requires that the axioms concerning atomic com\u00admands \nare satis.ed by the operational interpretation of the com\u00admands. We de.ne an abstract notion of executing \na small step of the program. To be able to make the step from p to q with the action a, we must ensure \nthat the operational interpretation of the action sat\u00adis.es the speci.cation, and moreover it also preserves \nany possible environment view. De.nition 11 (Action Judgement). The action judgement is de\u00ad.ned as: def \na I {p}{q} .. [a] (lpJ) . lqJ . .r . View. [a] (lp * rJ) . lq * rJ. For a view monoid, this de.nition \nsimpli.es to: a I {p}{q} .. .r . View. [a] (lp * rJ) . lq * rJ. (1) Semantic entailment is a special \ncase of the action judgement, for the label id. def De.nition 12 (Semantic Entailment). p : q .. id I \n{p}{q} .  Figure 1. Overview of the Views Framework For each axiom (p, a, q), the interpretation of \na must update view p to q while preserving any environment view. This is cap\u00adtured by the following property: \nProperty G (Axiom Soundness). For every (p, a, q) . Axiom, a I {p}{q} . This property is both necessary \nand suf.cient for the soundness of the program logic. We state the soundness result here, and provide \nmore details in \u00a76. Theorem (Soundness). Assume that f {p} C {q} is derivable in the program logic. Then, \nfor all s . lpJ and s . S, if (C, s) . * (skip, s ) then s . lqJ. Simple Type System: Soundness We reify \ntyping contexts as the set of states which are well\u00ad typed with respect to the context. Consequently, \nwe must de.ne a notion of typing for states. De.nition 13 (State Typing). The state typing judgement \nG; T f s, where G : Var -Type, s . SH and T : Loc -Type ranges over heap typing contexts, is de.ned as \nfollows: def G; T f s .. .x . dom (G) . T f s(x ) : G(x ) . .l . dom (T) . T f s(l) : T(l) def where \nT f v : t .. t = val . t = ref (T(v)). The state typing essentially ensures that every typed variable \nand location has a value consistent with its type. Speci.cally, this means that references must refer \nto addresses that have the appropriate type. Note that it would not be possible to have x and y referencing \nthe same location in the typing context x : ref val, y : ref ref val. This is necessary, since otherwise \nan update to the location via x could invalidate the type of y . De.nition 14 (Simple Type Rei.cation) \n: Parameter F. The simple type rei.cation, l-JTS : ViewMTS . P (SH), is de.ned as follows: def lGJ= {s \n. SH | .T. G; T f s} . TS To establish soundness, we need only show Property G (Ax\u00ad iom Soundness). This \nis straightforward; for further details, con\u00adsult [11]. Importantly, this works because we do not require \nlo\u00ad cality at the low level of the semantics, only at the high level. Thus, standard separation algebra \napproaches [6, 12] would not work for this example.  2.4 Summary The parameters of the Views Framework \nare summarised in Fig\u00adure 1. The language (\u00a72.1) is parameterised by a set of atomic commands, and its \nsemantics is determined by a notion of state and the semantics of the atomic commands as state transformers. \nThe Views program logic (\u00a72.2) is parameterised by a semigroup of views and an axiomatisation of the \natomic commands. The sound\u00adness of the logic (\u00a72.3) is with respect to a rei.cation of views into concrete \nstates, and is established by proving the axiom soundness property. In the following sections, we consider \nnumerous instances of the Views Framework. In doing so, we elaborate the metatheory with common constructions \nand additional proof rules. Remark. The Views Framework is more general than existing ax\u00adiomatisations \nof separation logic [6], in that it does not restrict views to be sets of (machine) states but allows \nthem to be elements in any semigroup. In fact, choosing this views semigroup and an ac\u00adcompanying rei.cation \nfunction well is the most important step of using our framework. A good choice of the views semigroup \nleads to a program logic where a veri.er works on the right level of ab\u00adstraction of machine states. \nAlso, it picks an appropriate scope for the universal quanti.cation in the axiom soundness property, \nand gives an effective set of axioms for atomic commands. This in.u\u00adence of the views semigroup on axiom \nsoundness corresponds to selecting a notion of locality properties for commands, which was usually done \nin a .xed manner in the work on separation logic. 3. Constructing Views We can instantiate of the framework \ndirectly, but instantiations often have common structure which can be used to simplify the process. We \npresent two general approaches to constructing views as sets, whose elements themselves belong to a (partial) \nmonoid. 3.1 Separation Algebras Calcagno et al. [6] introduced the concept of separation algebras to \ngeneralise separation logic. For many examples, we use a gen\u00aderalisation of separation algebras with \nmultiple units [5, 12] (and without the cancellativity requirement) to construct a view monoid. Parameter \nH (Separation Algebra). A separation algebra (M, ,I ) is a partial, commutative monoid with multiple \nunits. Namely, it is a set M equipped with a partial operator : M \u00d7 M -M and a unit set I . M satisfying: \n Commutativity: m1 m2 = m2 m1 when either is de.ned;  Associativity: m1 (m2 m3) = (m1 m2) m3 when \neither is de.ned;  Existence of Unit: for all m . M there exists i . I such that i m = m; and  Minimality \nof Unit: for all m . M and i . I, if i m is de.ned then i m = m.  De.nition 15 (Separation View Monoid) \n: Parameter D. Each separation algebra (M, , I ) induces a separation view monoid def (P(M), *, I ), \nwhere p1 * p2 = {m1 m2 | m1 . p1, m2 . p2}. Separation algebras are typically constructed by adding \ninstru\u00admentation to machine states; this instrumentation determines how states may be composed, typically \nby recording ownership or in\u00advariant properties. While previous work has required cancellativity, we \ndo not. Remark. For Separation View Monoids, it is common to choose entailment (F) to be subset inclusion \n(.).  Disjoint Concurrent Separation Logic To illustrate the separation algebra, we present a simple \nsepara\u00ad tion logic for disjoint concurrency. De.nition 16 (DCSL Separation Algebra) : Parameter H. The \nseparation algebra for disjoint concurrent separation logic is def (MDCSL, l, {\u00d8}), where MDCSL = (Var \nl Loc) -.n Val, l is the union of partial functions with disjoint domains, and the unit, \u00d8, is the partial \nfunction with the empty domain. Elements of MDCSL declare ownership of the variables and heap addresses \nthat belong to their domains, as well as de.ning their values. Signi.cantly, they do not declare information \nabout parts of the state which are not owned. Views p, q . P (MDCSL) are sets of these abstract states. \nThus, p and q describe resources, which hold information about part of the state. Judgements of disjoint \nconcurrent separation logic are, as in the Views Framework, triples of the form f {p} C {q}. The view \nx . v denotes the singleton set of the partial function -mapping variable x to value v, and x -denotes \nthe set of all partial functions that map only variable x to a value. Similarly, the views l . v and \nl . map heap address l to v or any value respectively. The view .v. p(v) is the (in.nite) join of p(v) \nfor all values of v. De.nition 17 (DCSL Axiomatisation) : Parameter E. The axiomatisation for separation \nlogic is given by the schemas: {x . * y . v} x := y {x . v * y . v} {x . l * l . } [x ] := v {x . l * \nl . v} {x . l * l . * y . v} [x ] := y {x . l * l . v * y . v} {y . l * l . v * x . } x := [y ] {y . \nl * l . v * x . v} {x -* y -:= ref y {.l. x . l * l . v * y . v} . .v} x -- For the soundness of a view \nmodel based on separation algebra, we typically provide a rei.cation function for elements of the separation \nalgebra. This is then lifted to give a rei.cation for views. Parameter I (Separation Algebra Rei.cation). \nl-J: M . P (S). De.nition 18 : Parameter F. lpJ = m.p lmJ. Given this construction of a view monoid \nand rei.cation func\u00adtion, Property G has an equivalent formulation that is typically sim\u00ad pler to check. \nProperty J (Axiom Soundness II). For every (p, a, q) . Axiom, and every m . M, [a]lp * {m}J . lq * {m}J. \nRemark. The case where a = id will always hold if p F q implies that p . q, justifying subset inclusion \nas a natural choice for the entailment relation. Disjoint Concurrent Separation Logic: Soundness Since \nseparation-logic views are sets of partial functions from variables and locations to values, they can \nbe seen as sets of heap states. Thus, we can de.ne a simple notion of rei.cation. De.nition 19 (DCSL \nRei.cation) : Parameter I. The DCSL rei.cation, l-JDCSL : MDCSL . P (S), is de.ned as follows: def lsJ= \n{s}. DCSL Our axioms for atomic commands are sound in the sense of Property J. Taking entailment to be \n. gives the standard rule of consequence. Note that the rei.cation function does not cover the machine \nstate space: there is no view p with ! . lpJ. This means that our separation-logic triples do not permit \nmemory faults to occur, in accordance with the standard interpretation.  3.2 Separation Algebras with \nInterference Views model partial, abstracted information about machine states that is stable immune \nto interference from other threads. In logics with .ne-grained permissions such as those used in deny\u00adguarantee \n(DG) [13] and concurrent abstract predicates (CAP) [9], the elements of the separation algebra are not \nstable by construc\u00adtion, but an additional obligation is added to only mention stable sets of elements. \nThis can simply be seen as another way of con\u00adstructing a view monoid from a separation algebra and an \ninterfer\u00adence relation. Parameter K (Interference Relation). An interference relation R . M \u00d7 M on a \nseparation algebra (M, , I ) is a preorder satisfying the properties: for all m1, m2, m, m . M with \nm = m1 m2 and m R m , there exist m1, m2 . M with m1 R m1, m2 R m2 and m = m1 m2; and  for all i . \nI and m . M with i R m, m . I.  De.nition 20 (Stabilised View Monoid) : Parameter D. An in\u00adterference \nrelation R on a separation algebra (M, , I ) generates a stabilised view monoid (R(ViewM), *, I ), where \nR(ViewM) = {p . P (M) | R(p) . p} The notation R(p) means {m . M | .mp . p. mp R m}. The composition \n* is as in De.nition 15. That R(ViewM) is closed under * and includes I follows from the conditions in \nParameter K. Remark. Unlike in CAP [9] and DG [13], we do not need to provide a guarantee relation to \nsay what a thread can do. That is dealt with by axiom soundness. In this setting, Property G has an equivalent \nformulation that is typically simpler to check. Property L (Axiom Soundness III). For every (p, a, q) \n. Axiom, and every m . M then [a](lp * {m}J) . lq * R({m})J. Separation Logic with Ownership We illustrate \nhow interference can be used to construct views, by showing how separation logic can be constructed this \nway. Rather than using the separation algebra introduced in Sec\u00adtion 3.1, we construct a view monoid \nfor disjoint concurrent separation logic by instrumenting machine states (excluding !) with an ownership \nmask, which provides explicit permissions for stating which variables and addresses are owned . De.nition \n21 (MSL Separation Algebra) : Parameter H. The masked-separation-logic separation algebra is (MMSL, MSL, \nIMSL), where def MMSL = (Var l Loc) -.n (Val \u00d7 {0, 1}), def m1 m2 = m .. dom (m1) = dom (m2) = dom (m) \n. .k . dom (m) . m1(k).1 = m2(k).1 = m(k).1 . m1(k).2 + m2(k).2 = m(k).2 def and I = {m . MMSL | .k . \ndom (m) . m(k).2 = 0} . where .i accesses the i-th component of a tuple. For each variable (or address), \nthe .rst component of the partial function represents its value, and the second component indicates whether \nor not the variable (or location) is owned. If a variable, or location, is unde.ned then it is not allocated. \nComposition requires that the state components are the same as that of the composite, and that their \nownership masks sum to give the mask of the composite. This ensures that each variable and location is \nuniquely owned. This composition is well-de.ned,  associative and commutative. If we constructed a view \nmodel based on this separation algebra, the commands we could reason about would be very limited: they \ncould not alter the (machine) state. This is because programs are required to preserve all frames, and \ntherefore all values. However, the intention is that only variables and locations that are owned are \npreserved by other threads. Thus, instead of preserving all frames, we wish only to preserve all stable \nframes for a suitable notion of stability. This can be obtained by de.ning an interference relation: \nDe.nition 22 (MSL Interference Relation) : Parameter K. def m R m .. .k . dom (m) . m(k).2 > 0 =. m (k) \n= m(k) This relation expresses that the environment can do anything that does not alter the variables \nand locations owned by the thread. It is not dif.cult to see that the interference relation satis.es \nthe decomposition property: any change that does not alter the variables or locations owned by either \nthread does not alter the variables or locations owned by each thread individually. If we consider the \nview monoid induced by the separation al\u00ad gebra under this interference relation, R(ViewMSL), we obtain \na notion of view that is speci.c about variables and locations that are owned, but can say nothing at \nall about variables and lo\u00ad cations that are not owned. Thus, threads are at liberty to mutate variables \nand heap locations they own, and allocate locations that are not owned by other threads, since these \noperations preserve stable frames. (Note that composition plays an important role here: it enforces that \nthe environment cannot also own variables and locations that belong to the thread.) We de.ne an operation \n. : R(ViewMSL) . ViewDCSL by: def .m . p. .k, v. .(p) =m . MDCSL m(k) = v .. m (k) = (v, 1) This operation \nin fact de.nes an isomorphism between the two view monoids, so we can really think of the separation \nlogic model as being constructed in this way. This construction of separation logic parallels the approach \nof implicit dynamic frames [28]. There, assertions about the state and about ownership are decoupled. \nAssertions are required to be self framing, a property which corresponds directly to stability. Separation \nlogic with fractional permissions [4] can be de\u00ad .ned by using fractions from the interval [0, 1] instead \nof a bit mask. In \u00a77.5, we discuss how the more complex permissions model of CAP can also be expressed \nusing separation algebras with interference. 4. Generalised Frame Rule When reasoning uses a context, \nit is common to have weakening rules on that context, such as the weakening rule of the type system in \n\u00a72.2. In the views representation, weakening rules become rules that perform the same manipulation on \nthe pre-and postcondition of the speci.cation. In the simple type system, the weakening rule corresponded \nto the frame rule. However, for certain examples the frame rule is not powerful enough to represent the \nrequired context manipulation directly. We therefore introduce a generalised version of the frame rule. \nRely-Guarantee We motivate the need for generalized frame rules by consider\u00ad ing the rely-guarantee method \n[20]. Rely-guarantee judgements take the form R, G f {P } C {Q}. Here, P and Q are assertions (interpreted \nas sets of states). R and G are relations on states rely and guarantee relations that describe how \nthe environ\u00adment and the program C respectively are allowed to update the state. The assertions P and \nQ are required to be stable under R. The atomic step rule takes the following form: . G [a]lP [a](P ) \n. Q R, G f {P } a {Q} (2) def where AlP = {(s, s ) . A | s . P }. The .rst condition ensures that G describes \nthe possible behaviours of the program. The rely-guarantee method is epitomised by the following rule \nfor parallel composition: G1 . R2 R1, G1 f {P1} C1 {Q1} G2 . R1 R2, G2 f {P2} C2 {Q2} R1 n R2, G1 . G2 \nf {P1 n P2} C1IC2 {Q1 n Q2} This rule requires that the behaviours of each thread, abstracted by G1 and \nG2, are contained in the interference expected by the other thread, represented by R2 and R1. The context \nof the composition relies on the environment doing no more than both threads expect, while the guarantee \nmust account for the behaviours of each thread. The above rules suggest encoding rely-guarantee into \nthe Views Framework with views consisting of triples (P, R, G) of assertions and rely and guarantee relations, \nwhere P is stable un\u00adder R. Composition would then follow the parallel rule, resulting in the special \ninconsistent view . when the relies and guarantees do not meet the side-conditions. De.nition 23 (RG \nView Monoid) : Parameter D. The set ViewRG of rely-guarantee views is de.ned as: (P, R, G) . P (S)\u00d7P(S2)\u00d7P(S2) \nR(P ) . Pl {.} . Composition is de.ned as: (P1, R1, G1) * (P2, R2, G2) = (P1nP2, R1nR2, G1.G2) provided \nG1.R2 and G2.R1; with all other cases resulting in .. The unit is (S, S2 , \u00d8). We encode the rules by \nplacing the rely and guarantee both into the pre-and postcondition. def R, G f {P } C {Q} .. f {(P, R, \nG)} C {(Q, R, G)} . For all rely-guarantee judgements we assume the pre-and post\u00adcondition are stable \nwith respect to the rely, and thus (P, R, G) and (Q, R, G) are both valid views. Using this encoding, \nthe structural rules (including parallel) follow trivially from the rules of the Views program logic, \nand the atomic rule (2) can be considered to de.ne a set of atomic axioms (Parameter E). Views are rei.ed \nto the set of states satisfying their assertions. De.nition 24 (RG Rei.cation) : Parameter F. l(P, R, \nG)J = P l.J = \u00d8. Lemma 1 (RG Axiom Soundness) : Property G. If [a]lP . G and [a](P ) . Q then a I {(P, \nR, G)}{(Q, R, G)}. Proof. We must show that, for every (P1, R1, G1) . ViewRG , [a]l(P, R, G) * (P1, R1, \nG1)J . l(Q, R, G) * (P1, R1, G1)J. We can assume composition is de.ned as the unde.ned case is trivial, \nand as rei.cation ignores the rely-guarantee components, we can simplify this to: (G . R1 . G1 . R . \nR(P ) . P . R1(P1) . P1) =. [a](P n P1) . Q n P1.  Showing that the result is in Q follows directly \nfrom the second premise, and that it is in P1 from the .rst premise using routine relational reasoning. \nWhile we have established the soundness of most of the rules, we have not yet considered rely-guarantee \ns weakening rule: R1 . R2 G2 . G1 R2, G2 f {P } C {Q} R1, G1 f {P } C {Q} This rule simply increases \nthe restrictions on the environment: it may do less (R1 . R2) but must tolerate more (G2 . G1). If we \ntry to encode the context weakening rule using the frame rule induced by the composition above, we require: \n? R1 . R2 . G2 . G1 =. .R3, G3. (P, R1, G1) = (P, R2, G2) * (P, R3, G3). However, this does not hold \nwhen R2 r G1. We could use a more elaborate structure to represent the pair of relations such as the \ndeny-guarantee structure [13], which can then be encoded into our framework. However, this loses the \noriginal elegance of rely-guarantee, and does not capture the intuition behind it. Instead, we provide \na new generalisation of the frame rule that can capture this reasoning directly. We introduce a generalised \nframe rule, which applies a func\u00adtion to the pre-and postconditions of a speci.cation. The rule is parameterised \nby a function f : View . View: f {p} C {q} f {f(p)} C {f(q)} By choosing particular functions, f, we \ncan encode a range of reasoning rules, in particular the standard frame rule: for the frame r, pick the \nfunction def f*r = .p. p * r. Now, for the rule to be sound we must prove the following property for \nthe f function and the action judgement used in axiom soundness. Property M (f-step Preservation). .a, \np, q. a I {p}{q} =. a I {f(p)}{f (q)} . This property is suf.cient for the soundness of the generalised \nframe rule. The proof of soundness is essentially the same as for the frame rule, and has been checked \nin Coq [11]. Remark. The generalised frame rule is analogous to the frame rule of context logic [5], \nwhere contexts are applied by a non\u00ad commutative operation to the pre-and postconditions. One could construct \na context algebra by taking views as the data and the functions satisfying Property M as the contexts, \nand thus see the generalised frame rule as an instance of the context logic rule. Con\u00adversely, one could \nview the application of a context as a function satisfying Property M, and hence see the context logic \nframe rule as an instance of the generalised frame rule. Rely-Guarantee: Weakening Returning to our motivating \nexample, we can now show how to encode rely-guarantee weakening rule using the generalised frame rule. \nThe weakening rule can be restated in an equivalent form as: R, G f {P } C {Q} R n R ,G . G f {P } C \n{Q} Thus we justify this instance of the rule using the generalised frame rule choosing f to be the function \nthat restricts the rely by R , and extends the guarantee by G : def f(RI,GI) = ..(P, R, G). (P, R n R \n, G . G ) where (..x. f (x)) v is f(v) if v is not ., and is . otherwise. Thus we are required to show \nthe following. Lemma 2 (f(RI,GI)-step Preservation) : Property M.  a I {(P1, R1, G1)}{(P2, R2, G2)} \n=. a I {(P1, R1 n R , G1 . G )}{(P2, R2 n R , G2 . G )}. This holds because the changes to the rely and \nguarantee only serve to further restrict the set of environment views that we must consider in the action \njudgement, and the assumption ensures R1 . R2 and G1 . G2. 5. Combination Rule The views proof system \nwe have presented so far has omitted two common rules: disjunction and conjunction. One key reason for \nthis is that such rules are not applicable to every instantiation of the framework. For example, the \nsimple type system of \u00a72.2 does not naturally support a disjunction or conjunction rule. Both of these \nrules may be expressed as special cases of a gen\u00aderal rule for combining multiple speci.cations of a \nsingle program. This general rule is parameterised by a notion of view combination (such as disjunction \nor conjunction), which maps indexed families of views into single views. By choosing the index set, I, \nwe can de.ne combination operations at different cardinalities. Parameter N (View I-Combination). Assume \na functionI : (I . View) . View. The combination rule is as follows: .i . I . f {pi} C {qi} fpi Cqi \ni.I i.I This rule is justi.ed sound by the following property: Property O (Primitive Combination). For \nall a . Label, (.i . I . a I {pi}{qi}) =. a Ipiqi . i.I i.I Remark. This combination rule generalises \nthe generalised frame rule from the previous section, which is simply a unary instance of the combination \nrule. Disjunction. In the case of disjunction, there is often a natural operatorthat has the following \nproperties: Property P (Join Distributivity). p *qi =(p * qi). i.I i.I Property Q (Join Morphism).pi= \nlpiJ. i.I i.I Together, these two properties imply Property O. Separation Algebras When views are constructed \nfrom a separation algebra, as in \u00a73.1, the views themselves are sets, and so it is natural to con\u00ad  \nsider set union ( ) as a notion of disjunction. By the de.nition of a separation view monoid (De.nition \n15), it follows that satis.es the join distributivity property (Property P). The join morphism property \n(Property Q) likewise follows directly from the element-wise de.nition of rei.cation (De.nition 18). \nConse\u00ad quently, the obvious rule of disjunction is sound for logics built from separation algebras in \nthis way, such as separation logic. For a stabilised view monoid (De.nition 20), note that the in\u00ad terference \nrelation preserves unions (since it is applied element\u00ad wise). From this, it follows that again satis.es \nthe required properties to provide a rule of disjunction.  Conjunction. It is possible to give properties \nanalogous to Prop\u00ad o a erties P and Q, relating a conjunction with . Such properties are suf.cient to \nestablish Property O, however, it is not often that o an instantiation of Views is equipped with a operator \nwith these properties. For instance, in separation logic, * does not distribute over conjunction. In \ncases, such as separation logic, where a con\u00adjunction rule is sound, Property O can typically used to \ndirectly justify it. It is less common for instantiations to have a conjunction rule than a disjunction \nrule. One explanation for this is that views typ\u00adically add instrumentation that is not present in the \nconcrete state (such as type information). This information can evolve indepen\u00addently of the concrete \nstate, leading to different speci.cations for the same program that make incompatible changes to the \ninstru\u00admentation, which cannot be combined with a conjunction rule. Disjoint Concurrent Separation Logic \nFor disjoint concurrent separation logic, consider the binary con\u00adjunction operation given by set intersection, \nn. We can prove that this gives a sound rule of conjunction by establishing Prop\u00aderty O, using two useful \nfacts. Firstly, for views constructed from separation algebras, the action judgement need only account \nfor singleton environment views: a I {p}{q} .. .m. [a] (lp * {m}J) . lq * {m}J. (This fact justi.es the \nsuf.ciency of axiom soundness II (Prop\u00ad erty J).) Secondly, singleton views are precise: (p1 n p2) * \n{m} = (p1 * {m}) n (p2 * {m}). (Note that this is not a general property of separation algebras, but \ncan be established for separation logic.) Suppose that a I {p1}{q1} and a I {p2}{q2}. Using the above \nfacts, and De.nition I, we can establish that [a] (l(p1 n p2) * {m}J) . [a] (lp1 * {m}J) n [a] (lp2 * \n{m}J) . l(q1 * {m})J n l(q2 * {m})J = l(q1 n q2) * {m}J. This is suf.cient for Property O to hold for \nbinary intersection. This argument extends to in.nitary intersection. Notably, however, it does not apply \nto the nullary case, which would give f {T} C {T} for every program C (where T = MDCSL). This would be \nunsound, since ! / . lTJ, yet there are programs which may fault when run from an arbitrary initial state. \n6. Soundness In this section, we sketch the soundness of the framework. The following results have been \nmachine checked with Coq, and the proof scripts are available [11]. There are two key properties of the \naction judgement. The .rst is that it is closed under the composition of a view, and the second that \nit is closed under the semantic entailment order (De.nition 12). Lemma 3 (Basic Locality). For all p, \nq, r . View, a . Label, if a I {p}{q} then a I {p * r}{q * r}. Lemma 4 (Basic :-closure). For all p, \np , q, q . View, a . Label, if p : p , a I {p }{q } and q : q then a I {p}{q}. To prove the soundness, \nwe use a semantic judgment that en\u00adsures every step of the machine correctly preserves the context us\u00ading \nthe action judgment. The semantic judgement is de.ned coin\u00adductively: it is a greatest .xed point. De.nition \n25 (Semantic Judgement). For command C . Comm and views p, q . View, the semantic judgement I {p} C {q} \nis de.ned to be the maximal relation such that I {p} C {q} holds if and only if the following two conditions \nare satis.ed: a 1. for all a . Label, C . Comm, if C -. C , then there exists p . View such that a I \n{p}{p } and I {p } C {q}; 2. if C = skip then p : q.  We can understand the semantic judgment, I {p} \nC {q}, as creating a trace of views for each possible interleaving of the commands in C, where each trace \nstarts in p, and if it is a .nite trace, then it ends in q. That is, if a1a2 . . . an is a .nite trace \nof C, then there exists a sequence p1 . . . pn+1, such that p = p1, pn+1 : q and ai I {pi}{pi+1}. If \na1a2 . . . is an in.nite trace of C, then there exists a sequence p1p2 . . ., such that p = p1 and ai \nI {pi}{pi+1}. For each of the proof rules there is a corresponding lemma establishing that it holds for \nthe semantic judgement. We present two particularly interesting ones here. Lemma 5 (Soundness of Frame). \nIf I {p} C {q} then I {p * r} C {q * r} . Proof. By coinduction. The case C = skip is trivial. Assume \na that I {p} C {q} and C -. C . By these assumptions, there exists p such that a I {p}{p } and I {p } \nC {q}. It suf.ces to show that a I {p * r}{p * r} and I {p * r} C {q * r}. The .rst follows from Lemma \n3 and the second from the coinductive hypothesis. Remark. The soundness of the generalised frame rule \nand the combination rule are proved by a similar argument to the frame rule. For the combination rule, \nwe require the axiom of choice for the indexing set; this allows us to select a next view (p in the above \nproof) for each index. Lemma 6 (Soundness of Parallel). If I {p1} C1 {q1} and I {p2} C2 {q2} then I {p1 \n* p2} C1 I C2 {q1 * q2}. a Proof. By coinduction. Assume that C1 I C2 -. C . Either one thread takes \na step or one thread has .nished executing. If the latter, C = Ci, Cj = skip and a = id, where {i, j} \n= {1, 2}. It must be that pj : qj , so id I {pi * pj }{pi * qj } by de.nition of :. Furthermore, I {pi \n* qj } Ci {qi * qj } follows from Lemmas 5. a If the former, assume that C = C1 I C2 and C1 -. C1. (The \ncase where C2 reduces is similar.) By assumption, there exists p1 such that a I {p1}{p1} and I {p1} C1 \n{q1}. It suf.ces to show that a I {p1 * p2}{p1 * p2} and I {p1 * p2} C1 I C2 {q1 * q2}. The .rst follows \nfrom Lemma 3 and the second from the coinduc\u00ad tive hypothesis. By similar lemmas for the other proof \nrules, we establish that the proof judgement of the logic implies the semantic judgement. Lemma 7. If \nf {p} C {q} is derivable in the program logic, then I {p} C {q}. To establish soundness, we link the \nsemantic judgement to the multi-step operational semantics. Lemma 8. If I {p} C {q}, then for all s . \nlpJ and s . S , if (C, s) . * (skip, s ) then s . lqJ. This lemma follows from the de.nitions. Soundness \nnow fol\u00adlows immediately from the preceding two lemmas. Theorem (Soundness). Assume that f {p} C {q} \nis derivable in the program logic. Then, for all s . lpJ and s . S, if (C, s) . * (skip, s ) then s . \nlqJ.  7. Further Examples We provide .ve additional instantiations to illustrate the .exibil\u00adity of \nour metatheory: recursive types, unique types, Owicki-Gries method, separation logic with resource invariants, \nand Concurrent Abstract Predicates. The recursive types example demonstrates that Views captures more \nrealistic types. It also illustrates how the rule of consequence can be used for subtyping. The connection \nbetween strong update type systems and separation logic has been an open problem for around ten years; \nthe unique types example makes ten\u00adtative steps towards connecting them using the Views Framework. The \nOwicki-Gries example illustrates that even underlying tradi\u00adtionally non-compositional reasoning is a \ncompositional core. The penultimate example shows how resource invariants can be added to the views formulation \nof separation logic by using the gener\u00adalised frame rule. The .nal example, CAP, illustrates that the \nmeta\u00adtheory scales to recent complex logics. 7.1 Recursive Types In this example, we give a type system \nfor references to pairs and recursive types, which allows us to represent simple lists and trees. The \nsyntax of types is t ::= val null ref t t t ? \u00b5X. t X The type null represents the type inhabited just \nby the value 0. The reference type, ref t1 t2, is a pointer to a pair of locations with types t1 and \nt2 respectively. The nullable type t ? allows null, as well as values of type t . Note that ref cannot \nbe a null pointer Finally, the .xed-point operator and type variables make it possible to represent recursive \ndata types. For example, we can de.ne lists as: def list t = \u00b5X. (ref t X)? As with the simple type system, \nviews consist of type contexts and the inconsistent context. Unlike in that example, however, we compose \ntyping contexts with disjoint union. This allows us to con\u00adsider variables as uniquely owned by threads, \nrather than shared, and consequently reason about strong (type-changing) updates of variables. De.nition \n26 (Recursive Type View Monoid) : Parameter D. The view monoid for recursive types is ((Var -Type)., \nl., \u00d8). We extend the heap-update language introduced in \u00a72.1 to work with pairs instead of single heap \ncells. We assume that values are integers, and locations are positive integers. x := ref y z allocates \na pair of consecutive locations in the heap, initialising them with values y and z . The .rst and second \ncomponents of a pair x may be accessed independently by x .fst and x .snd. To encode case splitting on \na pointer being null we use two commands: ?x =0, which blocks if x is not null, and performs the identity \naction otherwise; and ?x is null, and performs the =0 which blocks if x identity action otherwise. These \nallow us to encode choice as def ifNull x then C1 else C2 = (?x =0; C1) + (?x=0; C2) Since we wish to \nallow type-changing updates, commands are speci.ed with both a pre-and a post-type context: G1 f C -G2. \nIn the Views Framework, we naturally interpret this as syntax for f {G1} C {G2}. In order to introduce \nnullable types, and to fold and unfold recursive types, we introduce a notion of subtyping. The subtyping \nrelation, -, is de.ned as the least pre-order satisfying: t -t ? null -t? \u00b5X. t -t [\u00b5X. t /X ] t[\u00b5X. \nt /X ] -\u00b5X. t De.nition 27 (Context Subtyping). Subtyping is lifted to contexts in the obvious way: \ndef G1 -G2 .. .x : t2 . G2..x : t1 . G1.t1 -t2. De.nition 28 (Recursive Type Axiomatisation) : Parameter \nE. The typing rules for atomic commands include the following: x : t? f ?x =0 -x : null x : t ? f ?x \n: t =0 -x x : ref t1 t2, y : t1 f x .fst := y -x : ref t1 t2, y : t1 x : ref t1 t2, y : f y := x .fst \n-x : ref t1 t2, y : t1  x : , y : t1, z : t2 f x := ref y z -x : ref t1 t2, y : t1, z : t2 Typing rules \nfor the snd component are analogous to those for fst. We give the axioms for entailment as def G1 F G2 \n.. G1 -G2 The challenging aspect of this instantiation is giving the rei.ca\u00adtion, which requires us to \nde.ne a notion of being well-typed. We de.ne a relation T f v : t that expresses that a value v has type \nt in a heap typing T, that maps locations to types. Note that values range over integers. T f v : val \nT f 0 : t ? T f 0 : null T f v : t [\u00b5X.t /X ] T f v : \u00b5X.t T f v : t T f v : t ? T f v : ref T(v) T(v \n+ 1) We can then de.ne rei.cation as the set of states that are well typed with respect to a view. That \nis, those states for which there is a heap typing such that the value of each variable and heap location \nis correctly typed by the view and the heap typing. De.nition 29 (Recursive Type Rei.cation) : Parameter \nF. def s . lGJ \u00b5 .. .T. .x . dom(G . T). T f s(x) : (G . T)(x) To show the type system is sound we simply \nshow axiom sound\u00adness (Property G) for the axioms and subtyping relation.  7.2 Unique Types The previous \nexample used an atomic allocate and instantiate in\u00adstruction, x := ref y z. But this is not realistic \nas this would be done in many operations. In this example we extend the types from the previous section \nto allow us to separate allocation from instan\u00adtiation. We give a new high-level syntax to types, that \nallows us to represent a unique reference at the top-level: t ::= t | uref t t We change G to map to \nthese extended types. We can then give rules for the atomic commands to allocate and update a unique \nreference x : f x := ref -x : uref val val x : uref t2, y : t1 f x.fst := y -x : uref t1 t2, y : t1 These \nrules allow us to alter the type of something in the heap. This is sound as we are currently the only \nthread to have access to the location. We use the subtyping relation to cast away the uniqueness by adding \nthe following to the subtype relation: uref t1 t2 -ref t1 t2  We de.ne a function that forgets the uniqueness \ninformation, so that we can reuse the previous de.nitions: .Gq def = .x. if G x = uref t1 t2 then ref \nt1 t2 else G x Our notion of a memory satisfying a type context is the same as before with an additional \nconstraint that each unique reference can be removed from the memory and the memory is well-typed without \nit in the smaller context. def s . lGJ u\u00b5 = s . l.GqJ \u00b5 . .x : uref . G. sls(x),s(x+1) . l.GlxqJ \u00b5 def \nwhere f lx = .y. if x=y then f y else .. Note this does not mean that the location of a unique reference \ncannot occur in another stack or heap location, but it cannot occur as something potentially considered \nas a reference. Technically, x : uref t1 t2, y : f y := x -x : uref t1 t2, y : val is a sound axiom in \nthis model. We require this kind of property of our model as we only distinguish between integers and \nreferences at the type level. The concrete model does not separate them. Thus, it is possible for the \nallocator to use a location for which the integer is currently in use, but this does not matter. If it \nis being treated as a location, then it would already be allocated and thus the allocator would not double \nallocate it. The axioms and subtyping satisfy the required properties (Prop\u00aderty G).  7.3 Owicki-Gries \nMethod We present a version of the Owicki-Gries method [24] that can be encoded trivially into the Views \nFramework. However, we omit the auxiliary variable rule, and leave this to future work. Normally, the \nOwicki-Gries method has a non-compositional check on parallel composition: each command used by one thread, \nwhen restricted to its precondition, preserves all the assertions used in the proof of other thread. \nWe explicitly account for the assertions used in a proof, and the commands and preconditions as contexts \nto our judgements. Speci.cally, P, A f {P } C {Q} means that executing C in a state satisfying P , if \nit terminates, then the state will satisfy Q, and the proof only uses assertions in P, 1 and its atomic \ncommands are described by A. Thus the rule for an atomic command is P . P Q . P (P, a) . A [a](P ) . \nQ P, A f {P } a {Q} (3) The parallel rule is P1, A1 f {P1} C1 {Q1} .P . P2, (P , a) . A1. a (P .P ) . \nP P2, A2 f {P2} C2 {Q2} .P . P1, (P , a) . A2. [ a] (P .P ) . P P1 . P2, A1 . A2 f {P1.P2} C1 C2 {Q1.Q2} \nThe two side-conditions (right premises) are the standard non\u00adcompositional interference freedom checks. \nAgain, as with rely\u00adguarantee, this parallel rule induces a composition operation that we can use to \nbuild a view model. 1 The precise de.nition actually requires that the proof only uses assertions that \nare intersections of some elements of P. Otherwise, we would require the parallel rule to additionally \nrequire its pre-and postconditions to be in P. This requirement is only evident in the soundness proof, \nand does not alter the reasoning provided by the Owicki Gries method that we present. De.nition 30 (Owicki-Gries \nView Monoid) : Parameter D. The Owicki-Gries view monoid (ViewOG, *, (\u00d8, \u00d8, S)) is de.ned by  def ViewOG \n=(P, A, P ) .P . P. P =Pl {.} with composition given by def (P1, A1, P1) * (P2, A2, P2) = (P1 . P2, A1 \n. A2, P1 n P2) provided .P . P1, (P , a) . A2. a (P . P ) . P .P . P2, (P , a) . A1. [ a] (P . P ) . \nP and otherwise de.ned to be .. The proof rules follow from the Views Framework using the ob\u00advious encoding. \nThe atomic rule (3) determines the atomic axioms (Parameter E). We can provide a weakening rule, that \nallows the context to be enlarged, as a simple application of the generalised frame rule. For soundness, \nwe de.ne rei.cation (Parameter F) as simply taking the assertion component of a view (and \u00d8 in the case \nof .). Axiom soundness (Property G) follows from the premises of (3) by the consistency requirement of \ncomposition. Step preservation (Property M) for weakening follows trivially from axiom sound\u00adness, given \nthat the atomic rule (3) is closed under enlarging the context.  7.4 Atomic CSL We consider a concurrent \nseparation logic with a single resource invariant that must be preserved by each atomic command [25]. \nThis logic has a simple rule for atomic commands: fDCSL {I * P } a {I * Q} I f {P } a {Q} If the atomic \ncommand meets the speci.cation in standard sepa\u00adration logic (\u00a73.1) with the invariant, I, added to both \nthe pre-and postcondition, then it meets the speci.cation in this logic. We inter\u00adpret this in the Views \nFramework by de.ning views to be pairs of shared invariants and local assertions. Composition on these \nviews requires invariants to agree. De.nition 31 (Atomic CSL View Semigroup) : Parameter D. The atomic \nCSL view semigroup is ((ViewDCSL \u00d7 ViewDCSL) l {.}, * ACSL) where (I1, P1) * ACSL (I2, P2) is de.ned \nto be (I1, P1 * DCSL P2) if I1 = I2, and . otherwise. We encode the judgement I f {P } C {Q} as f {(I, \nP )} C {(I, Q)} . There are two rules for manipulating the context (the resource invariant). The .rst \nis a frame rule for the resource invariant, and the second allows local state to be added to the resource \ninvariant: I f {P } C {Q} I * I f {P } C {Q} I * I f {P } C {Q} I f {P * I } C {Q * I } These rules can \nbe interpreted as instances of the generalised frame rule. For the invariant frame rule, the following \nfunction is suitable: def fh(I ) = ..(I, P ). (I * I , P ). For the local invariant rule, a more complicated \nfunction is neces\u00adsary: def fs(I, I ) = ..(I1, P ). if I1 = I * I then (I, P * I ) else .. The function \nensures that the resource invariant in the premise is I * I , if not then the function maps to the inconsistent \nview, thus making the rule and the property vacuous.  For soundness, we de.ne the rei.cation to take \nthe composition mutex, a thread acquires the exclusive capability to unlock it. This of the invariant \nand local-state assertion in the sense of DCSL. guarantees that only one thread can have locked the mutex \nat a time, and only that thread can unlock it. Having locked the mutex De.nition 32 (Atomic CSL Rei.cation) \n: Parameter F. (through an atomic compare-and-swap operation), a thread s view def def l(I , P )J = \nI *DCSL P l.J = \u00d8 may be described by the following assertion: r This is the only example we present \nin the paper that does not .r. [UN L O CK]r * [LO C K]r 1 p * x . 1 (5) I(r) have a unit. However, the \nmodel does have a zero, ., and satis.es Whereas in (4) the thread does not know whether the mutex is \n.x. .u. x * u = x . .y. y * u = y . y * u = .. This property is suf.cient to show the simpli.cation of \na {p}{q} given in (1), provided l.J = \u00d8. Axiom soundness (Property G) can easily be established given \n locked or not, in (5) it knows that it is locked. It can only make such an assertion because it holds \nthe exclusive capability [UN LO C K]r; I 1 without that, the assertion would not be stable. (In separation \nlogic, capabilities are always directly associated with the information they the soundness of DCSL. The \ncontext rules require us to prove Property M. For the .rst, we can appeal to the frame rule of DCSL, \nwith the frame I . For the second, the function fs(I , I ) either renders the judgement trivial or preserves \nthe rei.cation, so Property M holds. Remark. If we wish to establish the conjunction rule for this logic, \nwe can do so if the resource invariant is precise2, given that assume DCSL has a conjunction rule. We \nmust show (for the binary case) a I {(I , P1)}{(I , Q1)} . a I {(I , P2)}{(I , Q2)} =. a I {(I , P1 . \nP2)}{(I , Q1 . Q2)} . Using the DCSL rule of conjunction, we know a IDCSL {(I * P1) . (I * P2)}{(I * \nQ1) . (I * Q2)} . Using the DCSL rule of consequence, we know a IDCSL {I * (P1 . P2)}{(I * Q1) . (I * \nQ2)} . And, moreover, if I is precise, then this implies a IDCSL {I * (P1 . P2)}{I * (Q1 . Q2)} . This \nestablishes primitive combination (Property O), which is suf\u00ad .cient for the conjunction rule to be sound. \n 7.5 Concurrent Abstract Predicates Concurrent Abstract Predicates (CAP) [9] extends separation logic \nwith shared regions that can be mutated by multiple threads through atomic operations. Each shared region \nis associated with some interference environment which stipulates how it may be mutated, by de.ning a \ncollection of actions. Threads can mutate the shared state only by performing actions for which they \nhave a capability resource, which may be exclusive or non-exclusive. An example of a CAP assertion is \nthe following: r  x . 0 * [UN L O CK]r . x . 1 1 .r. [LO CK]r p * pertain to, as in l . 7, whereas in \nCAP they can be separated.) In the rest of this section, we informally describe the parameters for the \nViews Framework. We do not give their formal details, and direct the reader to Dinsdale-Young s thesis \n[8] and our technical report [11] for the full de.nition and explanation. CAP assertions are modelled \nby sets of states instrumented with ownership, capabilities and region information. Each instrumented \nstate consists of three components. The .rst is the thread-local state, which consists of capability \nresources as well as separation\u00adlogic-style heap resources. The second is a mapping that associates region \nidenti.ers with their states. The third is an interference en\u00advironment that associates the action identi.ers \nused in capabilities with their interpretations as actions. Instrumented states form a sep\u00adaration algebra \n(Parameter H): composition of instrumented states is de.ned as requiring equality between the second \nand third com\u00adponents, while combining the resources in the .rst component. For the formal de.nition, \nsee [8, \u00a78.3.1]. To use CAP, we must work with stable assertions views in order to account for possible \ninteractions between threads. These stable assertions are de.ned by closure under an interference relation \n(Parameter K), which allows the environment to update regions in any way for which it can have a suitable \ncapability. The interference relation is constructed as the transitive closure of three relations, which \nmodel region update (in accordance with actions the environment may have capability to perform), region \nconstruction and region destruction. See [8, p319, De.nition 8.14] for the formal de.nition and [8, p337, \nLemma 112] for the proof of the decomposition property. Rei.cation (Parameter I) for CAP is given by \ncombining the heap components of the local and shared states, dropping the ca\u00adpabilities and interference \nenvironment. The atomic rule of CAP effectively establishes axiom soundness (Property L) by means of \na guarantee relation that obliges atomic operations to preserve sta\u00adble frames [8, p345, Lemma 125; p338, \nLemma 114]. (4) Remark. In our MSL example, interference was not essential. I(r) Since the interference \nrelations were equivalences, views were sets This assertion represents a shared mutex in the heap at \naddress x. of equivalence classes, and it was easy to de.ne canonical repre-The boxed part of the assertion \ndescribes the shared region: either sentations of these classes. CAP, on the other hand, is dif.cult \nto the mutex is available (x has value 0) or it is locked (x has value 1). If it is available, the exclusive \ncapability [UN L O CK]r 1 belongs to the region. The thread itself has a non-exclusive capability [LO \nCK]r p, which will permit it to lock the mutex. The actions corresponding to the capabilities are de.ned \nby the interference environment I(r): . .. LO CK : x . 0 * [UN LO C K]r . x . 1, 1 UN LO C K : x . 1 \n. x . 0 * [UN L O CK]r 1 . .. def I(r) = model without considering interference explicitly. One reason \nfor this might be that interference is directional, and not simply an equivalence. Consequently, expressing \nentailments as inclusions between closed sets is likely to be the simplest way of construct\u00ad ing a suitable \nview model. Another reason is that it is convenient to construct views from assertions that are not themselves \nstable, hence it is convenient to have a model in which we can represent both stable and unstable assertions. \nThe interference environment stipulates that a thread holding a LO C K capability may (atomically) update \nx from 0 to 1 in the shared region, simultaneously removing the capability [UN LOC K]r 1; a thread holding \nan UN LO C K capability may update x from 1 to 0 while returning [UN L O C K]r 1 to the shared region. \nBy locking the 2 I is precise, iff .p, q. (I * p) . (I * q) =. I * (p . q). 8. Related Work Our composition \noperator provides a logical notion of separation, which, as we have demonstrated by examples, need not \nbe realized by physical separation in the concrete machine. This idea of .c\u00adtional separation has been \nused in recent work on separation logics for concurrent languages [9, 13, 15, 31]. Similar ideas are \nalso use\u00ad ful in a purely sequential setting to enable modular reasoning about abstract data structures \nimplemented using physical sharing, but for which a logical notion of separation can be de.ned [10, 19, \n21, 22].  The soundness of Pottier s capability system [26] is based on an axiom that is similar to \nour de.nition of interference relation, and the soundness proof of concurrent abstract predicates [9] \nalso uses an equivalent lemma. Our framework does not have an ex\u00adplicit notion of guarantee, so many \nof the other properties required in both Pottier s work and concurrent abstract predicates are not required. \nFeng s LRG [14] also provides conditions such that the stable predicates can be composed. The condition \nrequires fences to delimit the scope of interference, which we do not require. 9. Conclusions We have \nintroduced Views as a general framework in which a wide variety of compositional reasoning approaches \ncan be con\u00adstructed, understood and proved sound. We .nd it surprising and revealing that diverse approaches \nsuch as separation logic, rely\u00adguarantee, the Owicki-Gries method and type systems can be un\u00adderstood \nin an elegant, unifying setting. While the power of the Views Framework is in the variety of systems \nthat it encapsulates, its virtue is in providing a common semantic footing for them: each of the approaches \nwe have studied can be proved sound by appeal to the general soundness result of Views, without recourse \nto in\u00adduction over the operational semantics. We have shown how Views captures a broad selection of exist\u00ading \nreasoning systems. Of course, the true test is whether Views can be used to develop new and interesting \nsystems. We are al\u00adready .nding this to be the case. Concurrent abstract predicates has been extended \nwith higher-order features, using Views extended with step-indexing to prove soundness [30]. The Views \nFramework has been extended to reason about C. with interesting permission annotations to ensure isolation \nbetween threads [17]. Views are also helping in the development of sound logics for local reason\u00ading \nabout intrinsically structured data, such as .le systems [16]; in this setting, decomposing data into \nfragments that record how they are connected is central, and is elegantly justi.ed by the semantic entailment \nof Views. In 2002, Reynolds noted the close relationship between sepa\u00adration logic and type systems and \nwondered whether the divid\u00ading line between types and assertions can be erased [27]. We have shown that, \nat least in the .rst-order case, types and asser\u00adtions are simply different kinds of view. Ultimately, \nwe have identi\u00ad.ed core principles underlying compositional reasoning about con\u00adcurrent programs, and \nformalised them in a unifying framework: Views. Acknowledgments We thank Tony Hoare, Peter O Hearn, Aza\u00adlea \nRaad, John Wickerson, Adam Wright and the anonymous ref\u00aderees of POPL 12, LICS 12, CONCUR 12 and POPL \n13 for help\u00adful feedback and comments on the paper. Dinsdale-Young, Gardner and Yang acknowledge support \nfrom EPSRC. References [1] A. Ahmed, M. Fluet, and G. Morrisett. L3: A linear language with locations. \nFundam. Inform., 77(4):397 449, 2007. [2] L. Birkedal, N. Torp-Smith, and H. Yang. Semantics of separation\u00adlogic \ntyping and higher-order frame rules for Algol-like languages. LMCS, 2(5:1), 2006. [3] L. Birkedal, B. \nReus, J. Schwinghammer, and H. Yang. A simple model of separation logic for higher-order store. In ICALP, \n2008. [4] R. Bornat, C. Calcagno, P. O Hearn, and M. Parkinson. Permission accounting in separation logic. \nIn POPL 05, 2005. [5] C. Calcagno, P. Gardner, and U. Zarfaty. Local reasoning about data update. ENTCS, \n172:133 175, 2007. [6] C. Calcagno, P. W. O Hearn, and H. Yang. Local action and abstract separation \nlogic. In LICS, 2007. [7] A. Chargu \u00b4eraud and F. Pottier. Functional translation of a calculus of capabilities. \nIn ICFP, pages 213 224, 2008. [8] T. Dinsdale-Young. Abstract Data and Local Reasoning. PhD thesis, Imperial \nCollege, Department of Computing, 2010. [9] T. Dinsdale-Young, M. Dodds, P. Gardner, M. J. Parkinson, \nand V. Vafeiadis. Concurrent abstract predicates. In ECOOP, 2010.  [10] T. Dinsdale-Young, P. Gardner, \nand M. Wheelhouse. Abstraction and re.nement for local reasoning. In VSTTE, 2010. [11] T. Dinsdale-Young, \nL. Birkedal, P. Gardner, M. Parkinson, and H. Yang. Views: Compositional reasoning for concurrent programs \n(technical report and addditional material). http://sites.google. com/site/viewsmodel/, 2012.  [12] \nR. Dockins, A. Hobor, and A. W. Appel. A fresh look at separation algebras and share accounting. In APLAS, \n2009. [13] M. Dodds, X. Feng, M. J. Parkinson, and V. Vafeiadis. Deny-guarantee reasoning. In ESOP, pages \n363 377, 2009. [14] X. Feng. Local rely-guarantee reasoning. In POPL, 2009. [15] X. Feng, R. Ferreira, \nand Z. Shao. On the relationship between con\u00adcurrent separation logic and assume-guarantee reasoning. \nIn ESOP, pages 173 188, 2007. [16] P. Gardner, G. Nzik, and A. Wright. Reasoning about POSIX .le systems \nusing structural separation logic. Draft, 2012. [17] C. Gordon, M. Parkinson, J. Parsons, A. Brom.eld, \nand J. Duffy. Uniqueness and reference immutability for safe parallelism. In OOP-SLA, 2012. [18] S. S. \nIshtiaq and P. W. O Hearn. BI as an assertion language for mutable data structures. In POPL, pages 14 \n26, 2001. [19] J. B. Jensen and L. Birkedal. Fictional separation logic. In ESOP, 2012. [20] C. B. Jones. \nTentative steps toward a development method for inter\u00adfering programs. ACM TOPLAS, 5(4):596 619, 1983. \n[21] N. Krishnaswami, L. Birkedal, and J. Aldrich. Verifying event-driven programs using rami.ed frame \nproperties. In TLDI, 2010. [22] N. Krishnaswami, A. Turon, D. Dreyer, and D. Garg. Super.cially substructural \ntypes. In ICFP, 2012. [23] G. Morrisett, D. Walker, K. Crary, and N. Glew. From system F to typed assembly \nlanguage. TOPLAS, 21(3):527 568, 1999. [24] S. Owicki and D. Gries. An axiomatic proof technique for \nparallel programs I. Acta Informatica, 6(4):319 340, 1976. [25] M. J. Parkinson, R. Bornat, and P. O \nHearn. Modular veri.cation of a non-blocking stack. In POPL, 2007. [26] F. Pottier. Syntactic soundness \nproof of a type-and-capability system with hidden state. Technical report, INRIA, 2011. [27] J. C. Reynolds. \nSeparation logic: A logic for shared mutable data structures. In LICS, 2002. [28] J. Smans, B. Jacobs, \nand F. Piessens. Implicit dynamic frames: Com\u00adbining dynamic frames and separation logic. In ECOOP, 2009. \n[29] F. Smith, D. Walker, and J. G. Morrisett. Alias types. In ESOP, 2000. [30] K. Svendsen, L. Birkedal, \nand M. Parkinson. A speci.cation of the joins library in higher-order separation logic. Technical report, \nIT University of Copenhagen, 2012. [31] V. Vafeiadis and M. J. Parkinson. A marriage of rely/guarantee \nand separation logic. In CONCUR, pages 256 271, 2007.   \n\t\t\t", "proc_id": "2429069", "abstract": "<p>Compositional abstractions underly many reasoning principles for concurrent programs: the concurrent environment is abstracted in order to reason about a thread in isolation; and these abstractions are composed to reason about a program consisting of many threads. For instance, separation logic uses formulae that describe part of the state, abstracting the rest; when two threads use disjoint state, their specifications can be composed with the separating conjunction. Type systems abstract the state to the types of variables; threads may be composed when they agree on the types of shared variables.</p> <p>In this paper, we present the \"Concurrent Views Framework\", a metatheory of concurrent reasoning principles. The theory is parameterised by an abstraction of state with a notion of composition, which we call views. The metatheory is remarkably simple, but highly applicable: the rely-guarantee method, concurrent separation logic, concurrent abstract predicates, type systems for recursive references and for unique pointers, and even an adaptation of the Owicki-Gries method can all be seen as instances of the Concurrent Views Framework. Moreover, our metatheory proves each of these systems is sound without requiring induction on the operational semantics.</p>", "authors": [{"name": "Thomas Dinsdale-Young", "author_profile_id": "81458657026", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P3977967", "email_address": "td202@doc.ic.ac.uk", "orcid_id": ""}, {"name": "Lars Birkedal", "author_profile_id": "81100622053", "affiliation": "IT University of Copenhagen, Copenhagen, Denmark", "person_id": "P3977968", "email_address": "birkedal@itu.dk", "orcid_id": ""}, {"name": "Philippa Gardner", "author_profile_id": "81351597297", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P3977969", "email_address": "pg@doc.ic.ac.uk", "orcid_id": ""}, {"name": "Matthew Parkinson", "author_profile_id": "81406598777", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P3977970", "email_address": "mattpark@microsoft.com", "orcid_id": ""}, {"name": "Hongseok Yang", "author_profile_id": "81100355747", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P3977971", "email_address": "hongseok00@gmail.com", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429104", "year": "2013", "article_id": "2429104", "conference": "POPL", "title": "Views: compositional reasoning for concurrent programs", "url": "http://dl.acm.org/citation.cfm?id=2429104"}