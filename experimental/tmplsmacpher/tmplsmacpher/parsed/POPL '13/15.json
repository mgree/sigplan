{"article_publication_date": "01-23-2013", "fulltext": "\n Universal Properties of Impure Programming Languages Sam Staton Paul Blain Levy Computer Laboratory, \nUniversity of Cambridge School of Computer Science, University of Birmingham Abstract We investigate \nimpure, call-by-value programming languages. Our .rst language only has variables and let-binding. Its \nequational theory is a variant of Lambek s theory of multicategories that omits the commutativity axiom. \nWe demonstrate that type constructions for impure languages products, sums and functions can be characterized \nby uni\u00adversal properties in the setting of premulticategories , multicate\u00adgories where the commutativity \nlaw may fail. This leads us to new, universal characterizations of two earlier equational theories of \nim\u00adpure programming languages: the premonoidal categories of Power and Robinson, and the monad-based \nmodels of Moggi. Our analy\u00adsis thus puts these earlier abstract ideas on a canonical foundation, bringing \nthem to a new, syntactic level. Categories and Subject Descriptors F.3.2 [Semantics of Pro\u00adgramming Languages] \nKeywords Multicategories, Premonoidal categories, Monads 1. Introduction In this paper we introduce a \nnew equational account of impure programs. This account is analogous to the \u00df.-equality for the pure \ntyped .-calculus. It provides a simple reasoning tool that is justi.ed both syntactically and semantically, \nby compositional interpretations in a variety of models. It is given a canonical status through universal \nproperties and representability. Let us stress that the \u00df.-equality of the pure .-calculus is not appropriate \nin the impure setting under the call-by-value semantics. For instance, if M has side effects then the \n.-law for products does not hold: M =/ .#1 M, #2 M.. For this reason, the categorical notion of product \ndoes not immediately apply to call-by-value programming languages. 1.1 An equational account of let-binding: \npremulticategories To move to the impure setting, we must reassess the nature of sub\u00adstitution, which \nwe do by introducing the new notion of premulti\u00adcategory (\u00a72). In the \u00df.-equality of a pure .-calculus, \nsubstitution is essential (e.g. (.x.M)N = M[N/x]). In a call-by-value lan\u00adguage, substitution is more \nintricate. The Standard ML expression let val x = N in M end Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 13, January 23 25, 2013, Rome, Italy. \nCopyright &#38;#169; 2013 ACM 978-1-4503-1832-7/13/01. . . $10.00 is (in some sense) equivalent to M[N/x] \nin the pure fragment of ML, whereas in the general it means evaluate N, call the result x, and continue \nas M . This sequencing plays a fundamental role, and it forms the basis of our de.nition of premulticategory. \nOur starting point is a language with at least two typing rules - . .t :A G, x:A, G ' .u :B x:A .x :A \nG, ., G ' .let val x = t in u end :B and satisfying three equations let val x=x in t end = t let val \nx=t in x end = t (x /. fv(t)) let val x = t in let val y = u in v end end =let val y = (let val x = t \nin u end)in v end (x ./ fv(v)). Any reasonable call-by-value programming language will have an analogue \nof let val. Roughly speaking it is the essence of A-Normal Form and Single-Static-Assignment (e.g. [10]). \nIt is often helpful to understand a term in context G .t :A as a generalized function which takes a valuation \nfor the context G and returns a result of type A. If we thus draw a term graphically then we can understand \nlet val as composition of functions, and a single variable is just a wire. The third law says The three \nlaws are thus the laws of identity and associativity for composing multivariate functions. The classical \ntheory of multicat\u00adegories also proposes a commutativity law: let val x = t in let val y = u in v end \nend (x ./ fv(u), =let val y = u in let val x = t in v end end y /. fv(t)) This law does not hold for \nimpure programs: consider the case defdef where t = print \"hello \" and u = print \"world\". Our equa\u00adtional \ntheory of let val is thus a non-commutative variant of mul\u00adticategories, which we call premulticategories \n(\u00a72). (Jeffrey [18] resolves the inaccuracy of the graphical calculus by introducing special control \narrows.)  1.2 First class types via representability We argue that type and term constructions should \nbe de.ned in the context of the simple language with let val, in a canonical and universal way. To this \nend, we give universal properties for products (\u00a73), sums (\u00a74) and call-by-value functions (\u00a76) in impure \nlanguages. One important consequence of universal properties is that although there may be many isomorphic \nimplementations of (say) a product type, there is exactly one isomorphism between any two implementations, \nwhich means that there is a canonical way to translate between them. We focus on product types for now, \nbut we will later deal with sum types and function types. The concept of product is already present in \nthe little language with let val, for we can describe terms G, x:(A \u00d7B) . t : C as terms G, x1:A, x2:B \n. t ' : C. The principle of representability says that this concept determines the product types, if \nthey exist. Concretely, representability requires that there is a term x:A, y:B ..x, y. :A \u00d7B which is \nuniversal in the following sense. The term induces a family of functions between sets: PG,C :{t I G, \nz:A \u00d7B .t :C} .{u I G, x:A, y:B .u :C} (t) def where PG,C = let val z = .x, y.in t end, and this family \nof functions is required to be a natural family of bijections. The bijectivity condition means that each \nPG,C has an inverse, in other words that there is an assignment G, x:A, y:B .u :C G, z:A \u00d7B .P -1 (u) \n:C G,C -1 satisfying some equations. In Standard ML, we can de.ne PG,C by -1 (u) def pattern matching: \nlet PG,C = let val .x, y. = z in u end. The technique of representability is syntactic, in that it suggests \nconstructors and destructors for product types. It is also semantic, because it only determines the types \nup-to unique isomorphism of types. It gives a universal property: there is a unique isomorphism between \nany two implementations. The principle of representability is a fundamental idea in ab\u00adstract mathematics. \nHermida [14] gives an account of representabil\u00adity for multicategories. One of our main technical contributions \nis to develop the theory of representability in the non-commutative setting of premulticategories (\u00a77) \nand to demonstrate its relevance to the principles of programming languages (\u00a73 6).  1.3 Explaining \nmonads and premonoidal categories Two important precursors to this work are Moggi s work on mon\u00adads [29, \n30] and the line of work on premonoidal categories and Freyd categories [12, 33, 34] begun by Power and \nRobinson. This earlier work has been very in.uential in programming languages research. Our criticism \nof it is that its analysis of impure compu\u00adtation is inextricably tied with its treatment of types. Using \npre\u00admonoidal categories, we show that impure computation can be sep\u00adarated from types in these models \n(\u00a78). Moggi s notion of .C -model [29, Def. 2.6] is de.ned in terms of strong monads. It axiomatizes \nin one fell swoop the structure of impure programming languages with product types and function types. \nOne of the contributions of Power and Robinson s work [33] is to decouple the function types from Moggi \ns notion of .C \u00admodel. They do this by directly axiomatizing categorical structures of computations which \nthey call premonoidal categories. This is in contrast to Moggi s development which centres around monads \non a category of values . The notion of premonoidal category ax\u00adiomatizes (again, in one fell swoop) \nthe structure of impure lan\u00adguages with product types. Freyd categories adjoin the distinction between \ncomputations and values to the theory of premonoidal cat\u00adegories. In this paper we isolate the principles \nof impure computation from type structure by introducing the notion of premulticategory and the related \nnotion of Freyd multicategory, a premulticategory with a distinguished class of values. Our main theorems \nrecover the earlier constructions by using universal properties to introduce type structure to this framework: \n A premonoidal category [33] is a premulticategory with prod\u00aducts (Theorem 26);  A Freyd category [33, \n34] is a Freyd multicategory with prod\u00aducts (Proposition 33).  A .C -model [29] is a Freyd multicategory \nwith products and function spaces (\u00a78.3).  Coherence from representability. We now give a more technical \nsummary of the connections between premonoidal categories and premulticategories. In a programming language, \nthe types (A * B)* C and A *(B * C) (1) are not identical but they are isomorphic in a canonical way. \nIn the approach of Power and Robinson, the isomorphism between the two types (1) is given as part of \nthe data for a premonoidal category [33]. This coherence approach has proved extremely successful in \nmany areas of mathematics, but it appears several steps away from programming language syntax. In our \nwork, the isomorphism (1) does not need to be given: instead, it can be derived from the universal property \nof products. This is a non\u00adcommutative version of Hermida s result [14]: to give a monoidal category \nis to give a multicategory with tensor products. The situation is actually more complicated. Power and \nRobin\u00adson require that the given isomorphism (1) is central , which infor\u00admally means that it doesn t \nmatter when it is executed. Although this requirement is reasonable from a pragmatic point of view, it \ndoes not seem to arise from a requirement of higher category the\u00adory: premonoidal categories do not seem \nto be pseudomonoids in a monoidal bicategory. This problem is remedied by our repre\u00adsentability result, \nwhich provides a principled explanation of the centrality requirements in premonoidal categories. In \nsummary, whereas the original de.nition of premonoidal cat\u00adegory is several steps away from programming \nlanguage syntax, our new characterization essentially is programming language syn\u00adtax. This is because \nrather than axiomatizing everything in one fell swoop, we characterize type constructions as universal \nproperties over a basic framework for impure computation. 2. A basic equational account of impure programs: \npremulticategories We begin by analyzing the basic structure of an impure program\u00adming language with \nvariables and let-binding. The equations which we propose are three of the four equations of multicategories. \nRecall that an ordinary category comprises a collection of ob\u00adjects, a collection of morphisms between \nthe objects, a selection of identity morphisms, and an associative composition operation. Roughly speaking, \na premulticategory is similar except that the morphisms do not go from one object to another. Rather, \nthey go from a context G to an object A. This is a natural way to study typed programming languages, \nsince a program in a context G has a type A. At this stage, we do not ask for the objects to be closed \nunder op\u00aderations (product types, unit types) nor for any special morphisms (printing, arithmetic). Nonetheless \nwe certainly do not forbid these things at this stage: a premulticategory can have more content than \nthe basic structural requirements.  As well as the syntactic examples of premulticategories that arise \nfrom programming languages, we have more concrete exam\u00adples coming from set theory, pointed sets, and \nwe explain how a strong monad gives rise to a premulticategory. 2.1 De.nitions: premulticategories and \ncentrality Notational convention. Informally, the language of premulti\u00adcategories can be thought of as \na language for terms in con\u00adtext. Formally, a morphism G . A goes from a list G of ob\u00adjects to an object. \nWe introduce the following informal conven\u00adtion. We will often write a list (A, B, C ) annotated with \nvariables (x :A, y :B, z :C). This allows us to informally index the list us\u00ading variables rather than \nnumbers, e.g. we can write y for the second element of the list. By doing this we can reason about concatenated \nlists without fumbling with arithmetic on indices. In everything we do, the informal variables can be \ntranslated into numbers at the expense of readability. The cornerstone of this paper is the following \nde.nition of pre\u00admulticategory. This is a non-commutative version of multicate\u00adgory , an idea .rst extensively \ninvestigated by Lambek [21]. De.nition 1. A premulticategory is given by the following data. A collection \nof objects, ranged over by A, B etc.  For each list of objects G and each object A a collection of morphisms \nG . A is given. If t : G . A then we write G .t :A.  Identity morphisms: For each object A a morphism \nidA:(A).A must be given. We notate this requirement informally as a rule: x:A .x :A  Composition: Given \na morphism t:. . A and morphism  u:(G, A, G ') . B, if the length of G is i then a morphism (u .i t) \n: (G, ., G ') . B must be given. We notate this requirement informally as a rule: . .t :A G, x:A, G ' \n.u :B G, ., G ' .t .x. u :B The notation (t . x. u) can be understood as shorthand for let val x = t \nin u end: execute t, bind the result to x, and continue as u . The data is subject to the following equations. \nIdentity laws. G, x:A, G ' .t :B G .t :A G, x:A, G ' .x .x. t = t :B G .t .x. x = t :A In case the notation \nis unclear: the .rst law means that for any morphism t:(G, A, G ') .B, the composite of idA with t at \nposition i (where i is the length of G) is equal to t. Associativity law: G3 .t :A G2, x:A, G ' 2 .u \n:B G1, y:B, G ' 1 .v :C G1, G2, G3, G2 ' , G ' .(t .x. u) .y. v = t .x. (u .y. v) :C 1 More formally \nthis law is notated v .i (u .j t) = (v .i u).i+j t, where i is the length of G1 and j is the length of \nG2. Commutativity and centrality. In general, given morphisms t:G1 .A and u:G2 . B, we say that t commutes \nwith u if it doesn t matter which order t and u are executed. To be precise, t commutes with u if the \nfollowing equations hold (for all v): .1, x:A, .2, y:B, .3 .v :C .1, G1, .2, G2, .3 .t .x. u .y. v = \nu .y. t .x. v :C .1, y:B, .2, x:A, .3 .v :C .1, G2, .2, G1, .3 .t .x. u .y. v = u .y. t .x. v :C If t \ncommutes with all u, then we say that t is central. In other words, t is central if it doesn t matter \nwhen it is executed. A premulticategory is a multicategory if all morphisms are central. (Lambek [21] \ncalls this the axiom of commutativity.)  2.2 Examples of premulticategories Multicategories have attracted \nsigni.cant recent interest in category theory, logic and algebra (e.g. [7, 14, 15, 22]), and in the semantics \nof continuation-passing [27] and of state [26, 35]. Premulticate\u00adgories have not been studied before, \nto our knowledge. First simple example: multicategory of sets. We begin by de\u00adscribing the multicategory \nof sets, but let us .rst set up some nota\u00adtion. Given a list G of sets, we write .G for the product of \nthose sets. For instance, .(A, B, C ) = {(a, b, c) I a . A, b . B, c . C}. If we view G as a context, \nthen .G is the set of valuations for that context. In the multicategory of sets, the objects are sets, \nand a mor\u00adphism G . A is a function .G . A. Thus a morphism G . A is something which assigns a result \nin A to every valuation of G. The identity morphisms are the identity functions. Composition is by composition \nof functions: given morphisms t:. . A and u:(G, x:A, G ') . B and given valuations a.. .G, .b . .., c) \ndef c.. .G ' , let (t . x. u)(.a, .b, .= u(.a, t(.b), c.). This is a mul\u00adticategory: all morphisms are \ncentral. Second simple example: multicategory of pointed sets. In the multicategory of pointed sets, \nthe objects are sets A equipped with a distinguished element 1A. A morphism t:G . A is a function t:.G \n.A that is strict in each argument: if a.. .G is such that ai = 1 for some i, then t(a.) = 1A. Identities \nand composition are as in the multicategory of sets; it is easy to check that these yield functions that \nare strict in each argument. All morphisms are central. Third simple example: premulticategory of stateful \nfunctions. Let S be a .xed set, thought of as a set of states. We form a premulticategory whose objects \nare sets and where a morphism G .A is a function (.G)\u00d7S .A\u00d7S. The idea is that a stateful function takes \nas an argument a valuation of its context and also an initial state; it returns a result and also a .nal \nstate. Composition is de.ned as follows. Given t:. . A and u:(G, x:A, G ') .B and given valuations a.. \n.G, .b . .., c.. .G ' and an element s . S, let (t . x. u)(.a, .b, .= c, s) defu(.a, a, .') where (a, \ns t(.b, s). This premulticategory is not c, s ') = a multicategory unless S has at most one element. \nThe central mor\u00adphisms t:G .A are the functions that do not change the state, i.e. for each valuation \na.. .G there is an element t1(.a) of A such that for all states s . S we have t(.a, s) = (t1(.a), s). \nConnection with programming languages. Well-typed terms of a programming language such as Standard ML \nform a premulticat\u00adegory, modulo observational equivalence. Composition (t .x. u) amounts to the ML syntax \nlet val x = t in u end. The identity and associativity laws are simple observational equations under \nthis in\u00adterpretation. Not all morphisms are central. For instance print hello .x. print world .y. (x, \ny) =/ print world .x. print hello .y. (x, y).  Connection with deductive systems. As Lambek observed \n[21], multicategories are closely related to deductive systems such as the sequent calculus. The identity \nmorphisms correspond to the axiom, and composition corresponds to cut. The identity and associativ\u00adity \nlaws provide a starting point for a cut-elimination procedure. However, whereas the commutativity axiom \nplays a natural role in equivalence of proofs, we are rejecting it in the context of program\u00adming languages. \nMoreover, we are not interested in cut elimination, since cut/sequencing plays a crucial role. For instance, \nwe cannot eliminate sequencing from the following program without chang\u00ading its meaning. (print Enter \nyour name: ) .x. readline .y. print Hello ^y Connection with algebra. The words commutativity and cen\u00adtrality \nare used by analogy with algebra. Let (M, \u00b7, e) be a monoid, i.e. a set with an associative binary operation \n\u00b7 and unit e. We can build a premulticategory from M: it has one object * and a mor\u00adphism G .* for each \nelement of M. The identity morphism is e and composition m .x. n is monoid multiplication, m \u00b7n. A morphism \nm in this premulticategory is central if and only if it is central in the usual algebraic sense: .n. \nm \u00b7n = n \u00b7m. The premulticategory is a multicategory if and only if the monoid is commutative: .m, n. \nm \u00b7n = n \u00b7m. This is a simple motivating example. Let S be an alphabet, and let S * be the monoid of \nstrings over the alphabet. The unit is the empty string and multiplication is concatenation. When we \nthink of this as a premulticategory, we can think of the object *as the unit type in ML, and we can think \nof elements s of the monoid S * as commands G .output s : *, with the equation strong monad cannot be \nde.ned without having a product structure and a construction T . We argue that these constructions on \ntypes (\u00d7 and T ) have nothing to do with impure computation. In Sec\u00adtion 8.3 we show that these constructions \n(\u00d7and T ) have universal properties when they exist, so that they need not be speci.ed at all.  2.3 \nStructural laws Our language for premulticategories doesn t have any structural laws. In a composite \nt . x. u, there is a linearity constraint: the variables in t must be distinct from the variables in \nu (except for x). Moreover, the context cannot necessarily be reordered. There are many situations in \nprogramming languages where non-linearity is essential, and so we now explain how to introduce the structural \nlaws into the theory of premulticategories. If G = (A1, . . . , Am) and . = (B1, . . . , Bn) are lists \nof objects then we de.ne a renaming f :G .. to be a function m .n such that Ai = Bf(i) for i = m. Renamings \ncompose as functions. (See also e.g. [9, \u00a7II.1].) De.nition 2. A premulticategory is cartesian when for \nevery morphism t:G1 .A and every renaming f :G1 .G2 a morphism t[f]:G2 .A is given, G1 .t :A (f:G1 .G2) \nG2 .t[f] :A such that t[idG] = t and t[f; g] = (t[f ])[g] when both sides are de.ned, and satisfying \nthe rule .1 .t :A G1, x:A, G1 ' .u :B x. u)[g1If.2, g1:G1 x. u[g1I ' 1 Ig2] = .(G2, G idAIg2] :B . (G2, \nG ' 2 .(t . t[f] . G2, .2, G G .(output s .x. output t) = output (st) : *. ' 2 ' . ) and g2:G g2): (G1, \n., G ' ' ) .(G2, x:A, G ),) for any f:.1 where the renamings (g1and (g1g2):(G1, x:A, G If 1 2 ' Examples \nfrom monads. Moggi proposed monads as models of impure programming languages [30]. Let-binding plays \na key role in his metalanguage. This can be explained by noting that every 1). (G2, .2, G2' ) are de.ned \nin the idAI obvious way. 2 strong monad induces a premulticategory. Examples of monads on the category \nof sets include the state monad (S .((-) \u00d7S)), the continuations monad ((-) .R) .R, and the exceptions \nmonad ((-) .E). All of these computational effects can be accommo\u00ad dated in premulticategories. Special \nkinds of renaming correspond to the classical structural laws. The bijective renamings of the form (G, \nx:A, y:B, G ') .') determine the exchange laws; the injective re\u00ad (G, y:B, x:A, G namings of the form \nwkx : (G, G ') . (G, x:A, G ') determine Recall that a monad on the (ordinary) category of sets is given \nby an assignment of a set T (A) to each set A, a family of func\u00adtions .A:A . T (A) and an assignment \nfrom functions f:A . T (A) to functions f *:T (A) .T (B), all satisfying some axioms. Given a monad T \n, we can de.ne a Kleisli premulticategory of T \u00adfunctions. The objects are sets, and a morphism G .A \nis a func\u00adtion .G .T (A). The identities are de.ned using .. Composition is de.ned as follows: given \nt:. .A and u:(G, x:A, G ') .B and valuations a.. .G, .b . .., c.. .G ' , let .c) def (t .x. u)(.a, b, \n.= u *(str(.a, t(.b), c.)) where str:.(G, T (A), G ') .T (.(G, A, G ')) is a strength which is uniquely \nde.ned for any set-theoretic monad [30, Prop. 3.4]. This construction can be carried out for any strong \nmonad on a symmetric monoidal category. The Kleisli premulticategory induced by a monad is a multicat\u00adegory \nif and only if the monad is commutative in the sense of [19]. Commutative monads have special relevance \nin the study of linear logic (e.g. [4, 16]). Any monoid (M, \u00b7, e) induces a monad M \u00d7(-) on the cate\u00adgory \nof sets. The premulticategory induced by the monoid embeds in the Kleisli premulticategory induced by \nits monad, and the three notions of commutativity for monoids, monads and premulticate\u00adgories coincide \nin this situation. While many notions of computation can be described by mon\u00adads, there is a difference \nbetween premulticategories and monads: a the weakening laws; and the surjective renamings of the form \ny,z ctrctx :(G, y:A, z:A, G ') .(G, x:A, G ') determine the contrac\u00adtion laws. All renamings can be built \nfrom morphisms of these three kinds (e.g. [6, 20]). We can work with a subset of the structural laws \nby focusing on a particular well-behaved class of renamings: De.nition 3 (c.f. [22], Def 2.2.21). A premulticategory \nis symmet\u00adric when for every morphism t:G1 .A and every bijective renam\u00ading f:G1 .G2 a morphism t[f] \n: G2 .A is given such that the rules in De.nition 2 are satis.ed. (We emphasize that symmetric and commutative \nare not syn\u00adonyms.) In a cartesian premulticategory, some morphisms interact par\u00adticularly well with \nthe renaming structure (c.f. [12]). We say that a morphism t:. .A is discardable if, for all u:(G, G \n') .B, G, ., G ' .t .x. (u[wkx]) = u[wk.] :B and t:. .A is copyable if, for all u:(G, y:A, z:A, G ') \n.B, ' y,z .,. G, ., G .t .x. (u[ctrctx ]) = (t.y. t.z. u)[ctrct. ] :B. De.nition 4. A cartesian multicategory \nis a cartesian premulticat\u00adegory in which every morphism is central, discardable and copy\u00adable. (Various \nauthors have investigated general categorical frame\u00adworks that include symmetric multicategories, cartesian \nmulticat\u00adegories, and many more elaborate examples [5, 7, 15, 22], but those frameworks are based on \nsimultaneous substitution and do not seem to work well for premulticategories.)  3. Product types and \ntensor products In the previous section we introduced an equational theory for pro\u00adgrams with let-binding. \nWe did this without making any assump\u00adtions about the type constructions in the language. We now explain \nwhat it means for a language to have prod\u00aduct/record types. We do this by using the universal property \nof ten\u00adsor products, which is well understood for multicategories [14]. This universal property has the \nimmediate consequence that any two implementations of the product type are canonically isomor\u00adphic. In \nthis sense, having products is seen as a property and not additional structure. (We discuss a limitation \nof this view in \u00a75.2.) In this section and in the following two sections on sums and functions we will \ndeal with particular concepts. In Section 7 we provide general notions of representability and show that \nthese particular concepts are instances of the general notions. 3.1 Tensor products: de.nition Consider \na list . = (A1, . . . , An) of objects in a premulticategory. The list . can be thought of as a speci.cation \nfor a product type (A1 * . . . * An). The list is not actually a product type because it is not actually \nan object. A tensor product for . is a single object that represents it. De.nition 5. A tensor product \nfor a list of objects . = (A1, .., An) is an object .. together with a morphism . ..., which we no\u00adtate \nx1:A1, . . . , xn:An ..x1, . . . , xn. : .. together with an operation on morphisms G, x1:A1, . . . , \nxn:An, G ' .t :B (2) G, y: .., G ' .y -.x1 . . . xn.. t :B ' for each pair of lists G, G and each object \nB. The notation y -.x1 . . . xn.. t should be understood as pattern matching a vari\u00adable of product type \ninto its components x1 . . . xn, binding them in t. We require the morphism . . .. to be central (that \nis, .x1..xn. .y. t .z. u = t .z. .x1..xn. .y. u) and we impose the following two conditions: G, x1:A1, \n. . . , xn:An, G ' .t :B G, x1:A1, . . . , xn:An, G ' ..x.. .y. (y -.x... t) = t :B G, y: .., G ' .u \n:B G, y: .., G ' .y -.x1, . . . , xn.. (.x1, . . . , xn. .y. u) = u :B The .rst equation says that if \nwe form a tuple and then extract its elements, nothing happens. The second equation says that if we extract \nthe elements of tuple and then build the tuple again, nothing happens. In Section 7.2.2 we will explain \nhow this de.nition amounts to representability in a more abstract sense. 3.2 Examples of tensors In \nthe multicategory of sets, every list of objects has a tensor product. The tensor product of a list . \nis the product set .., that is, the set of valuations for .. The universal morphism . ... is the identity \nfunction. Essentially the same representation works in the premulticategory of stateful functions and \nthe premulticategory of arising from a monad on the category of sets. Recall that a pointed set is a \nset A equipped with a chosen element 1A . A. In the multicategory of pointed sets, every list . = (A1, \n. . . , An) has a tensor product given by the smash product , which is a quotient of the free pointed \nset on the product of ., .. = ({1..} ...)/~ where ~ is generated by 1.. ~ (a1, . . . , 1Ai , . . . , \nan). Pointed sets are a simple algebraic theory. More generally, one can build a multicategory from any \nalgebraic theory, with algebras as objects and multilinear maps as morphisms. A famous exam\u00adple is the \nof multicategory of vector spaces which also has ten\u00adsor products. A well-known characterization theorem \nsays that, for a given algebraic theory, the multicategory of algebras has tensor products if and only \nthe corresponding free-algebra monad is com\u00admutative (c.f. [25]). Connection with programming languages. \nThe syntax for tensor products is very similar to the syntax in ML. In Standard ML, the object .. would \nbe written (A1 * . . . * An), and the assignment y -.x1, . . . , xn.. t is written as follows: let val \n(x1, . . . , xn) = y in t end. The centrality of the universal morphism and the two equations are straightforward \nobservational equivalences. Thus we can build a premulticategory with all tensor products whose objects \nare types and whose morphisms are terms in context modulo observational equivalence. If the empty list \n() has a tensor product .() then this behaves like the unit type in ML. For instance, the sequencing \nnotation (t ; u) can be understood as shorthand for t .x. x -... u. A convenient programming practice \nis to write tuples with terms in the components. By .xing a left-to-right order of evaluation, we have \nthe following derived typing rule: G1 .t1 :A1 . . . Gn .tn :An (3) . def G1..Gn ..t1..tn = t1 .x1. .. \ntn .xn. .x1..xn. : .. Connection with logic. The rule for matching (2) is the left rule for tensor products \nin the sequent calculus presentation of linear logic. The right rule of the sequent calculus looks like \nthe derived rule (3) although there is nothing canonical about it in the non\u00adcommutative setting: the \norder of evaluation of t1 . . . tn matters unless they are central.  3.3 Basic .rst results We now state \nsome basic results that can be derived from the de.nition of tensor product. They are instances of general \nresults in Section 7.2. Proposition 6. Matching associates and commutes with composi\u00adtion: G1, ., G1 \n' .t :B G2, z:B, G2 ' .u :C G2, G1, y: .., G ' 1, G ' 2 .(y-.x... t).z. u = y-.x... (t.z. u) :C G1 .t \n:B G2, ., z:B, G2 ' .u :C G2, y: .., G1, G ' 2 .y -.x... (t .z. u) = t .z. (y -.x... u) :C Proposition \n7. For any list . = (x1:A1, . . . , xn:An) of objects, any object R and any morphism r:. . R there is \na unique morphism t:(y: ..) .R such that .x1, . . . , xn. .y. t = r. The unique morphism t is central \nif r is central. As a corollary of this result we achieve our main theorem: Theorem 8. Tensor products \nare unique up to unique isomorphism, and the unique mediating isomorphisms are central. In other words, \nthere is a canonical way to translate between any two implementations of product types.  4. Sums and \nlabelled variants In the previous section we demonstrated that products can be given a universal property \nin a model of an impure programming lan\u00adguage. In this section we show that sum types (labelled variants) \ncan also be given a universal property in a similar way. 4.1 De.nitions: constructor contexts and sums \nWe .x an in.nite set of constructors . A constructor context is a .nite partial function from constructors \nto objects of a premulticat\u00adegory. A sum for a constructor context . is an object .. and a family of \nmorphisms {.(c) ...}c.dom(.): (c . dom(.)) x:.(c) .c(x) : .. that is universal in the sense that each \nmorphism is central and there is an operation on morphisms G, xc:.(c), G ' .tc :A (c . dom(.)) G, y: \n.., G ' .match y as (c(xc) .tc)c.dom(.) :A subject to the following equations: G, xc:.(c), G ' .tc :A \n(c . dom(.)) G, xd:.(d), G ' .d(xd).y. match y as (c(xc) .tc)= td :A c G, y: .., G ' .t :A G, y: .., \nG ' .match y as (c(xc) .(c(xc) .y. t))= t :A c  4.2 Examples of sums Sums in set-theoretic premulticategories. \nThe multicategory of sets has sets as objects and multivariate functions as morphisms. Sums of constructor \ncontexts are given by disjoint unions: def .. = {(c, a) I a . .(c)}. The universal maps take a . .(c) \nto (c, a) . ... A similar analysis works for stateful functions and for the premulticategory arising \nfrom a monad on a distributive category. In the multicategory of pointed sets, the objects are sets A \nequipped with an element 1A, and the morphisms are multivariate functions that are strict in each argument. \nThis multicategory also has sums of constructor contexts, given by a coalesced sum: def .. = ({(c, a) \nI a . .(c)}. 1..)/~ where 1.. ~ (c, 1.(c)). Connections with programming languages. In ML-like lan\u00adguages, \nvariant types must be declared. Given a constructor context . = (c1:A1, . . . , cn:An), we would expect \nan ML de.nition datatype .. = c1 :A1 I . . . Icn :An. The universal family of morphisms can be combined \nwith compo\u00adsition to yield the more familiar term formation for constructors: G .t :.(c) (c . dom(.)) \nc(t) def G . = t .x. c(x) :A The equations in the de.nition are straightforward observational equivalences \nin a programming language. 4.2.1 Basic .rst results We state some basic properties that can be derived \nfrom the de.ni\u00adtion of sums. They are instances of general results in Section 7.2. Proposition 9. Matching \nassociates and commutes with composi\u00adtion: G1, xc:.(c), G ' .tc :A (c . dom(.)) G2, z:A, G ' .u :B 1 \n2 G2, G1, y: .., G ' 1, G ' 2 .match y as (c(xc) .(tc .z. u))c = (match y as (c(xc) .tc)c) .z. u :B G1 \n.t :A G2, xc:.(c), z:A, G2 ' .uc :B (c . dom(.)) G2, y: .., G1, G ' 2 .match y as (c(xc) .(t .z. uc))c \n= t .z. (match y as (c(xc) .uc)c) :B Proposition 10. For any constructor context ., any object R and \nany family of morphisms {rc:(x:.(c)) .R}c.dom(.), there is a unique morphism t:(y: ..) .R such that for \nall c . dom(.), x:.(c) .c(x) .y. t = rc :R. The mediating morphism t is central if each rc is central. \nIn consequence, sums are unique up to unique isomorphism, and the unique mediating isomorphisms are central. \n5. On values and Freyd multicategories In impure programming languages it is usually necessary to iden\u00adtify \na class of values among the class of all programs. For instance, in an impure functional programming \nlanguage, the most natural evaluation strategy for function application is call-by-value: expres\u00adsions \nare reduced to values before they are passed as arguments. We have proposed to understand a program as \na morphism in a premulticategory. To accommodate values, we must identify a class of morphisms which \nare the values. We call this structure a Freyd multicategory . The idea of distinguishing between val\u00adues \nand computations is long-established in the categorical study of semantics, stemming from Moggi s distinction \nbetween ordi\u00adnary morphisms and Kleisli morphisms [30], running through the work on premonoidal categories \n(e.g. [18, 32, 33]) and Freyd cat\u00adegories [24, 34]. The distinction between values and computations also \narises in arrows in functional programming [2, 3, 17] and forms the basis of recent syntactic systems \n(e.g. [8, 23, 28]). The idea of identifying a class of values also plays a crucial technical role from \nthe perspective of morphisms between premulticategories with tensor products. 5.1 Morphisms of premulticategories \nIf premulticategories represent programming languages, then a morphism between them is a compositional \ntranslation. De.nition 11. Let C and D be premulticategories. A morphism F :C .Dis given by an assignment \nof an object F A of Dto each object A of C, and an assignment of a morphism F f : F G .F B in D to each \nmorphism f:G . B in C, such that identities and composition are preserved. Our running example concerns \nthe two-element monoid S2 = ({flip, e}, \u00b7, e) where flip \u00b7 flip = e. As explained in Sec\u00adtion 2.2, the \nmonad S2 \u00d7 (-) on the category of sets induces a Kleisli premulticategory Cwhose objects are sets and \nwhere a mor\u00adphism G .B is a function .G .S2 \u00d7B. It can be thought of as a semantics for a simple programming \nlanguage with a command flip that .ips the contents of a bit of memory. We also consider the premulticategory \nD of stateful functions (\u00a72.2) with two states Bool = {True, False}. The objects of D are sets and the \nmorphisms G . B are functions .G \u00d7Bool . B \u00d7Bool . There is a morphism of multicategories F :C .D that \nis iden\u00adtity on objects and takes a morphism f :G .B in C to the stateful function given by (F f )(.= \n') where f(.= '), a, s) (b, s xor s a) (b, s  i.e., interpreting the command flip as an instruction \nthat .ips the state. This can be understood as arising from a monad morphism (S2 \u00d7-) .(-\u00d7Bool)Bool . \n 5.2 Discussion: Preservation of tensors We now investigate what it means for a morphism of premulticat\u00adegories \nto preserve tensor products. Since tensor products have a universal property we would expect preservation \nof tensors to be a property rather than extra structure. Given a list . = (A1, . . . , An) of objects \nof V and a tensor product r:. .R, we say that a morphism F :C .Dpreserves the tensor if F r is also a \ntensor. Proposition 12. Let F :C .D be a morphism between premulti\u00adcategories, where C has tensor products. \nThe following are equiva\u00adlent: 1. F preserves every tensor product. 2. F preserves central isomorphisms, \nand every list of objects in C has a tensor product that is preserved by F .  The issue here is that \nthere may be many different tensors for a given list of objects, all related by canonical central isomorphisms. \nIf F preserves central isomorphisms, e.g. if Dis is a multicategory, then the equivalence of items 1 \nand 2 allows us to check that F preserves all tensor products by checking that one chosen tensor product \nis preserved. To illustrate this, let us return to our example of the Kleisli premulticategory C and \nthe premulticategory D of stateful func\u00adtions. The premulticategory C is actually a multicategory, since \ne and flip commute. The morphism F : C .D does not preserve centrality, because F (flip, id) :() .1 is \nnot central in D. This example also illustrates the complications involved with preservation of tensor \nproducts in the non-commutative setting. In C, every list . has a tensor product given by (e, id):. .... \nThis is a reasonable implementation of the tensor product from the programming language perspective. \nThis tensor product is pre\u00adserved by the morphism F : C .D into the premulticategory of stateful functions. \nHowever, the structure (flip, id):. . .. also happens to be a tensor product of the list . in C. This \nten\u00adsor product is not preserved by the morphism F :C .D, because F (flip, id) is not central in D. In \nthe example, informally, (flip, id) is central in C by acci\u00addent: it would have been better to explicitly \ndesignate (e, id) as a value and (flip, id) as a non-value. We could then require this special class \nof central value morphisms to be used for the rep\u00adresentations for tensors, and we could require this \nclass of value morphisms to be preserved by morphisms of premulticategories. Before we make this formal, \nwe brie.y consider another way to resolve the situation: we could remove the requirement that the representing \nmorphism . . .. be central. This is dif.\u00adcult to motivate from a pragmatic perspective. Moreover from \nthe mathematical perspective it is badly behaved, because the induced family of associativity morphisms \naA,B,C : .(.(A, B), C) . .(A, .(B, C)) is not natural and moreover does not support a co\u00adherence result: \nthe pentagon diagram does not commute (see \u00a78).  5.3 De.nition: Freyd multicategory Informally, a Freyd \nmulticategory is a premulticategory that is equipped with data about which morphisms are values. Formally, \na Freyd multicategory is a morphism return:V .C from a multicategory V to a premulticategory C such that \nV and C have the same objects and return is identity on objects and pre\u00adserves centrality. The idea is \nthat morphisms in V are values, mor\u00adphisms in C are computations, and return(v) is the computation that \nimmediately returns v. We do not require return to be injec\u00adtive on morphisms, although it often will \nbe in practice. We notate Freyd multicategories by introducing a special judge\u00adment G .V v :A of values \n(morphisms in V) and a rule G .V v :A G .return(v) :A describing the morphism return:V . C. The functoriality \nof return is expressed by the following equations: x:A .x = return(x) :A . .V v :A G, x:A, G ' .V w :B \nG, ., G ' .return(v .x. w) = return(v) .x. return(w) :B We also have the two equations stating that values \nare central among all morphisms (\u00a72.1). Because V is a multicategory and V . C preserves centrality then \nwe can understand return(v) .x. t as an explicit substitution of the value v for x in t. In the syntax, \nwe can textually substitute t{v/x} as shorthand for return(v) .x. t. (Note that this implicit substitution \nis only an informal convention, whereas it is genuine syntax in the explicit substitutions of Abadi et \nal. [1].) A morphism of Freyd multicategories ' (F1, F2) : (V return .C) . (V' return. .C') is a pair \nof morphisms between premulticategories (F1:V .V' , F2:C .C' ) such that return ' .F1 = F2 .return. 5.3.1 \nExamples of Freyd multicategories Recall that the premulticategory of stateful functions has sets as \nobjects and stateful functions as morphisms. A stateful function G . A is an ordinary function (.G) \u00d7S \n. A \u00d7S, where S is a .xed set of states. In this context we let our multicategory of values be the multicategory \nof sets and pure (stateless) functions, and return:V . C is the evident inclusion morphism, which is \nfaithful provided S is not empty. Given a monad T , recall that the associated Kleisli premulti\u00adcategory \nhas sets as objects and morphisms G . A are ordinary functions (.G) .T (A). In this context we let our \nmulticategory of values be the category of sets and pure functions. The morphism return:V .C is de.ned \nby the unit of the monad. We can now revisit our morphism C .D from the Kleisli pre\u00admulticategory induced \nby the monad (S2 \u00d7-) to the premulticat\u00adegory of stateful functions (\u00a75.2). In both cases, the value \nmul\u00adticategory is the multicategory of sets and pure functions, and(Id, F ) :C .Dis a morphism of Freyd \nmulticategories.  5.3.2 Tensors and sums in Freyd multicategories We de.ne a Freyd multicategory with \ntensors/sums to be a Freyd multicategory return:V . C in which V has tensors/sums and return preserves \nthem. This makes sense because return preserves centrality. We say that a morphism of Freyd multicategories \n(F1, F2) : (V .C) .(V' .C') preserves tensors (resp. sums) if F1 pre\u00adserves tensors (resp. sums). To \nillustrate, we return to our motivat\u00ading example: the morphism from the Freyd multicategory induced by \nthe monad (S2 \u00d7-) to the Freyd multicategory of stateful func\u00adtions. This does preserves tensors. As \nan aside we remark that, from the syntactic point of view, it is slightly unnatural to ask for V to have \ntensors/sums. For tensors, although it is usual to consider the representing maps .v1, . . . , vn. as \nvalues, it is less common to consider the pattern matching syntax x -.y... v as a value expression. Levy \n[24] coined the phrase complex value for this situation. Our framework provides us with an option for \ndescribing tensors without using complex values, by asking C to have tensors and for the representing \nmaps to come from V, without asking for V to have tensors. Using implicit substitution, we would have \na more familiar grammar for values:  v ::= .v1, . . . , vn. I X[v] I . . . Notice that these maps in \nV are not uniquely determined unless the functor return :V .C is injective on morphisms. Moreover, two \nsuch representations are not necessarily isomorphic in V.  5.3.3 Structural laws We can also speak of \nsymmetric Freyd multicategories, which are Freyd multicategories return :V . C such that V and C are \nsymmetric (Def. 3) and return preserves the renaming structure: G1 .V v :A . (f:G1 .G2) G2 .return (v[f]) \n= (return (v))[f] :A We say that a Freyd multicategory return :V .C is cartesian when V is cartesian \nas a multicategory (Def. 4), C is cartesian as a premulticategory (Def. 2), and return preserves the \nrenaming structure. All the examples in Section 5.3.1 are cartesian. 6. Function spaces We have introduced \nan equational theory for impure programs (\u00a72) and shown that product and sum types can be characterized \nby universal properties (\u00a73, 4). We now characterize call-by-value function types by a universal property. \nWe characterize function types in the context of Freyd multi\u00adcategories (\u00a75.3) by retracing the steps \ntaken by Power and Thi\u00adelecke [34]. The key point is that .rst-class call-by-value functions can delay \ncomputations. For instance, in ML the expression fn x => (print \"testing\" ; 3) does not immediately print: \nit will only print when applied to an argument. We use Freyd multicategories to distinguish between computations, \nwhich can be delayed, and values, which cannot be delayed. In what follows we will assume that our premulticategories \nare symmetric, in the sense of Section 2.3. This means that objects in contexts can be reordered. It \nis clumsy to work with function spaces without this assumption. 6.1 De.nition: function spaces We de.ne \nthe concept of function space in the setting of a sym\u00admetric Freyd multicategory (\u00a75.3): a symmetric \nmulticategory V (values), a symmetric premulticategory C (computations) and an identity-on-objects morphism \nof symmetric premulticategories return :V .C such that each return (v) is central. Let . be a list of \nobjects and let A be an object. We will de.ne what it means for the Freyd multicategory to have a function \nspace(. .A). The idea is that the inhabitants of the function space are functions that take a valuation \nof the context . and return a result of type A, perhaps with some side-effects along the way. When . \nis empty then the object (. .A) behaves like a space of delayed computations, like Moggi s monadic type \nconstructor. We do not have the currying isomorphism in a call-by-value language, and unless the Freyd \nmulticategory has all tensor prod\u00aducts we cannot accurately express n-ary functions in terms of unary \nfunctions. De.nition 13. A symmetric Freyd multicategory return :V . C has function spaces if for every \nlist . = (x1:A1, . . . , xn:An) and every object B there is an object (. .B) and a morphism (. .B, .) \n.B (not necessarily central): f :. .B, x1:A1, . . . , xn:An .f(x.) :B together with an operation on morphisms: \nG, . .t :B (4) G .V .(.)t :(. .B) subject to the following equations: G, . .t :B G, . .return (.(.x)t) \n.f. f (.x) = t :B G .V v :. .B G .V .(x.). (return (v) .f. f (x.)) = v :. .B We work up to a-equivalence \n we consider variables to be informal notation for indices in lists.  6.2 Examples of function spaces \nSet theoretic examples. The Freyd multicategory of sets has V = C as the multicategory with sets as objects \nand multivariate functions as morphisms. The function space (. . B) is the set of functions (..) .B. \nThe representing map is the evaluation function, which takes a function and a valuation and evaluates \nthat function. Recall that the Freyd multicategory of stateful functions has V as the multicategory of \nsets and functions and Cas the premulticat\u00adegory of sets and stateful functions. The function space (. \n.B) is the set of all stateful functions . .B. Notice that, in particular, the function space (() .B) \nis the state monad (S .B \u00d7S). Given a monad T on the category of sets, recall that the corre\u00adsponding \nFreyd multicategory has V as the multicategory of sets and functions and C as a premulticategory of sets \nand Kleisli func\u00adtions. The function space (. . B) is the set of all functions (..) . T (B). In particular, \nthe function space (() . B) is isomorphic to the monad T . Connection to programming languages. The connection \nwith programming languages is hopefully clear. The two equations are variants of the \u00df and . equations \nwhich are straightforward obser\u00advational equivalences in all higher-typed languages. We suggest the following \nsyntactic sugar: let ) def f(t1, . . . , tn = t1 .x1. .. tn .xn. f (x.). (5) In this call-by-value semantics, \nexpressions are reduced before being passed as arguments. We certainly have not captured exactly observational \nequiva\u00adlence. That is not our aim. Our aim is to identify an equational theory that holds in all good \nmodels. Our equations hold in syntac\u00adtic models and also in more semantic models which are not fully \nabstract but which are nonetheless useful. Connections with proof theory. Let us brie.y investigate the \nextent to which the Curry-Howard correspondence is relevant in the call-by-value setting. The rule for \n.-abstraction (4) is essentially the right implication rule of the sequent calculus. The syntactic sugar \n(5) leads to the left rule for implication: G .t1 :A1 . . . G .tn :An G, y:B .u :C G, f :(A1, . . . , \nAn) .B .f(t1, . . . , tn) .y. u :C which is clearly not canonical, because it depends on the order of \nt1, . . . , tn. In fact, the explicit let-binding helps us to distinguish different proofs. For example, \nconsider the following two terms: f:A .B, x:A .return (.(y:C). (f(x))) :C .B f:A .B, x:A .(f(x)) .w. \nreturn (.(y:C). w) :C .B  If (f(x)) is a value, which is an assumption that the language is pure, then \nthese terms are equal. Without this assumption, these are two distinct terms which correspond to two \ndifferent sequent calculus proofs, as .rst observed by Herbelin [13].  7. Representability in general \nThe last two technical sections of this article place our work on a secure abstract foundation. Throughout \nthis article we have spoken of representability and universal properties on the understanding that these \nconcepts lend a canonical status to various constructions. We now provide a general notion of representability \nthat accounts for the constructions that we have introduced: products, sums and function spaces. For \nan ordinary category C there are two notions of repre\u00adsentability that are dual to each other: we can \nspeak of repre\u00adsentability for a covariant functor C . Set and of representabil\u00adity for a contravariant \nfunctor Cop .Set. The covariant notion of representability allows us to describe colimits, and the contravari\u00adant \nnotion allows us to describe limits. The situation is more sophisticated with multicategories, for there \nis no reasonable notion of dual for multicategories. Thus we must treat the two variances differently. \nWe do this by considering representability for left and right modules of (pre)multicategories. Very informally, \nwe may say that a left or right module speci.es a concept a concept like product, sum or function. A \nrepresenta\u00adtion for the module is a .rst class type that represents the concept. Throughout this section \nwe work with symmetric premulticate\u00adgories. This means that we can reorder the contexts, which makes \nthe notation easier. 7.1 Left modules and left representability We introduce a notion of left module \nand of representability for premulticategories. This general notion specializes to our charac\u00adterization \nof function types. 7.1.1 De.nitions and .rst results Given a symmetric premulticategory C we de.ne a \nleft module M to be an assignment of a set M(G)to each list G of objects, together with a family of functions \n\u00b5G,A,.,G ' :C(.; A) \u00d7M(G, A, G ') .M(G, ., G ') satisfying two conditions. We write G .M t when t . M(G), \nand we write . .t :A G, x:A, G ' .M u ' M G, ., G .M t .x. u for \u00b5G,A,.,G '(t, u). The two conditions \nare G, x:A, G ' .M t (LM1) ' M G, x:A, G .M x .x. t = t G3 .t :A G2, x:A, G2 ' .u :B G1, y:B, G1 ' .M \nv ' ' MM G1, G2, G3, G2, G1 t x. (u .y. v) = (t .x. u) M .M . .y. v (LM2) Representations of left modules. \nFor a .xed object R, we can understand C(-; R) as a left module. De.nition 14. Let M be a left module \nfor a symmetric premulti\u00adcategory C. A representation of M is an object R of Ctogether with an isomorphism \nof left modules: {C(G; R) . M(G)}G (An isomorphism of left modules is a family of bijections that respects \nthe left module structure.) A representation is always determined by an object R and an element of M(R). \nTo show this, we use the following variant of the Yoneda lemma. (Technically this can be seen an instance \nof the Yoneda lemma for ordinary categories.) Proposition 15. Let M be a left module for a symmetric \npremulti\u00adcategory C and let R be an object. To give a left module morphism {C(G; R) .M(G)}G is to give \nan element of M(R). In more detail, given an object R and an element r . M(R) we have a family of functions \n(R, r)G : C(G; R) .M(G) given by (t) defM (R, r)G = t .x. r: G .t :R (using x:R .M r). M G .M t .x. r \nConversely, given a left module morphism, i.e. a family of func\u00adtions {fG:C(G; R) .M(G)}G that respects \nthe left module struc\u00adture, we recover an element fR(idR) of M(R). Proposition 15 says that these two \nconstructions are mutually inverse. Corollary 16. Let M be a left module of a symmetric premulticat\u00adegory. \nThe following data are equivalent. A representation for M (Def. 14).  An object R and an element r \n. M(x:R) together with a family of functions .G :M (G) .C(G; R) notated  G .M t G .. t :R satisfying \nthe following conditions: G .M t G .t :R (LR1 2) M G .M (. t) Mx. r = G ..(t x. r) = . t . t :R Uniqueness \nof representations. Proposition 17. If (R, r . M(x:R)) is a representation of M and a . M(y:A) then there \nis a unique morphism t:(y:A) .R such M that y:A .M a = t . x. r. In consequence, representations are \nunique up to unique isomorphism. 7.1.2 Example: function spaces In Section 6 we de.ned a notion of function \nspace for Freyd multicategories return :V .C. Given a context . and an object B, we de.ne a module M \nfor V as follows: M(G) def = C(G, .; B). The module structure \u00b5 is de.ned in terms of the premulticategory \nstructure of C: G2 .V v :A G1, x:A, G ' 1 .M u G1, G2, G1 .M (v . = (return (v) .x. u) ' Mx. u) def The \ntwo conditions LM1 2 are immediately veri.ed. The data for a left representation is exactly the data \nfor a func\u00adtion space (. .B). The axioms LR1 2 are exactly the axioms for function spaces in Section \n6.1.  7.1.3 Centrality in terms of module morphisms We brie.y remark that left modules provide a more \nabstract account of centrality. Recall that a morphism t is central if it commutes with all morphisms: \nfor all u and v, t .x. u .y. v = u .y. t .x. v. This can be explained in a more abstract way as follows. \nEvery morphism t:. .A determines a family of functions between sets of morphisms: (t .x. -) :C(G, x:A; \nB) .C(G, .; B) The domain and codomain have an obvious left module structure, and the morphism t is central \nif and only if this family of functions is a left module morphism for all B.   7.2 Right modules and \nright representability We now provide a notion of right module, which is an account of composing on the \nright. The induced notion of representability accounts for the product and sum types that we introduced \nin Sections 3 and 4. 7.2.1 De.nitions and .rst results Given a symmetric premulticategory Cwe de.ne a \nright module M to be an assignment of a set M(G; A) to each list G and each object A, together with for \neach B the structure of a left module (\u00a77.1.1) \u00b5G,A,.,G ' ;B :C(.; A) \u00d7M(G, A, G ' ; B) .M(G, ., G ' \n; B) and also a family of functions \u00b5\u00afG,.,A,G ' ;B :M(.; A) \u00d7C(G, A, G ' ; B) .M(G, ., G ' ; B) satisfying \nthree conditions. We use the following notation: we write G .M t :A if t . M(G; A), and we write . .t \n:A G, x:A, G ' .M u :B . .M t :A G, x:A, G ' .u :B ' M' M G, ., G .M t .x. u :B G, ., G .M t .x. u :B \nfor \u00b5G,A,.,G ' ;B (t, u)and \u00b5\u00afG,A,.,G ' ;B(t, u)respectively. The three conditions (in addition to LM1 \nand LM2) are G .M t :A (RM1) M G .M t .x. x = t :A G3 .M t :A G2, x:A, G2 ' .u :B G1, y:B, G1 ' .v :C \n' ' MM G1, G2, G3, G2, G1 .M (t .x. u)M.y. v = t .x. (u .y. v) :C (RM2) G3 .t :A G2, x:A, G ' 2 .M u \n:B G1, y:B, G ' 1 .v :C MMM G1, G2, G3, G2 ' , G1 ' .M (t .x. u)M.y. v = t .x. (u .y. v) :C (RM3) The \nlast condition, RM3, speci.es that the left (\u00b5) and right ( \u00b5\u00af) structures associate with each other. \nTechnically, our notion of right module can be seen as an instance of a general concept in locally indexed \ncategory theory and the self construction (see [23, \u00a79.3.4, \u00a79.3.6]). Representations of right modules. \nFor a .xed object R, the as\u00adsignment M (G; A) = C(G, R; A) can be made into a right module in a straightforward \nway. De.nition 18. Let M be a right module for a premulticategory C. A representation of M is an object \nR of C together with an isomor\u00adphism of right modules {C(G, R; A) . M(G; A)}G,A (An isomorphism of right \nmodules is a family of bijections that respects the right module structure that is, both \u00b5 and \u00b5\u00af.) \nA representation is always determined by an object R and an element of M(R). This follows from a new \nvariant of the Yoneda lemma, for which we need the following de.nition. De.nition 19. Let M be a right \nmodule for a premulticategory. An element t . M(G1; A) is central if it satis.es the following equations: \nG2 .u :B .1, x:A, .2, y:B, .3 .v :C MMM .1, G1, .2, G2, .3 .M t .x. (u .y. v) = u .y. (t .x. v) :C G2 \n.u :B .1, y:B, .2, x:A, .3 .v :C MMM .1, G2, .2, G1, .3 .M t .x. (u .y. v) = u .y. (t .x. v) :C Proposition \n20. Let M be a right module of a symmetric premulti\u00adcategory C and let R be an object. To give a right \nmodule mor\u00adphism {C(G, R; A) .M(G; A)}G,A is to give a central element in M((); R). Corollary 21. Let \nM be a right module of a symmetric premulti\u00adcategory. The following data are equivalent. A representation \nfor M (Def. 18).  An object R and a central element r . M((); R) together with a family of functions \n.G,A :M(G; A) .C(G, R; A) notated  G .M t :A G, x:R ..(x, t) :A satisfying the following conditions: \nG .M t :A (RR1) M G .M r .x. .(x, t) = t :A G, x:R .t :A (RR2) M G, x:R ..(x, r .x. t) = t :A Uniqueness \nof representations. Proposition 22. If (R, r . M((), R)) is a representation of M and a . M((); A) then \nthere is a unique morphism t:(x:R) .A M in C such that -.M r .x. t = a :A. If a is central then so is \nt. In consequence, representations are unique up to unique iso\u00admorphism and the unique mediating isomorphism \nis central.  7.2.2 Examples: products and sums Given a list ., de.ne a right module M. by M.(G; A) def \n = C(G, .; A). A representation for M. is a tensor product .. in the sense of Section 3.1. Given a constructor \ncontext . (\u00a74.1), de.ne a right mod\u00adule M. by M.(G; A) def = .c.dom(.) C(G, .(c); A). A repre\u00adsentation \nfor M. is a sum .. in the sense of Section 4.1. 8. Premonoidal categories and monads In Section 2 we \nde.ned premulticategories as a notion of model for an impure programming language with variables and \nlet-binding. We argue that this is the primitive setting for studying call-by-value impure programming \nlanguages. In Sections 3 and 4 we showed that products and sums can be characterized by a universal property, \nwhich means that they are unique up to unique isomorphism. In Section 6 we provided a similar universal \nproperty for function spaces. We now justify our work by showing that it subsumes earlier axiomatizations \nof call-by-value programming languages: the pre\u00admonoidal and Freyd categories of Power and Robinson [33] \nand the monadic models of Moggi [30]. We show that a premonoidal category is essentially the same thing \nas a premulticategory with tensor products.  We show that a Freyd category is essentially the same thing \nas a cartesian Freyd multicategory with tensor products.  We show that a strong monad on a category \nwith .nite products is essentially the same thing as a cartesian Freyd multicategory with tensor products \nand function types with empty domain.  We show that a .C -model is essentially the same thing as a cartesian \nFreyd multicategory with tensor products and all function types.   The last three facts can be deduced \nfrom the .rst one by building on earlier work by Levy, Power and Thielecke [24]. 8.1 Premonoidal categories \nWe now recall the notion of premonoidal category. Before we be\u00adgin, we give some concrete examples. The \ncategory of sets and functions is a premonoidal category, with the product of sets form\u00ading a premonoidal \nstructure. Indeed, any monoidal category is a premonoidal category. But the motivating example is the \nKleisli category for a monad. Let T be a monad on the category of sets. Recall that the Kleisli category \nof T has objects sets and that mor\u00adphisms A . B are functions A . T (B). The product of sets induces \na premonoidal structure on this Kleisli category which is typically not monoidal. In Section 8.2 we will \nshow how to convert a premulticategory to a premonoidal category. This will suggest a premonoidal cate\u00adgory \nbuilt from the syntax of a programming language. Our de.nition of premonoidal category is streamlined \nby tak\u00ading things up a level: we take advantage of a multicategory whose objects are themselves categories. \nWe start by de.ning strict pre\u00admonoidal categories, and move gradually to premonoidal cate\u00adgories. 8.1.1 \nA multicategory of categories We organize the collection of all ordinary categories into a symmet\u00adric \nmulticategory Catm. The objects of the multicategory Catm are themselves ordinary categories, and so \nour contexts G are lists of categories. A morphism F : G . A in Catm is de.ned to be a mapping that is \nfunctorial in each argument. For instance, if G = (B, C) then for each pair of objects B and C, respec\u00adtively \nfrom B and C, an object F (B, C ) of A must be given, and this must extend to families of functors F \n(-, C ) : B . A and F (B, -) :C .A(but not necessarily a functor B\u00d7C .A). This multicategory has tensor \nproducts [11] and this struc\u00adture has been used in various areas, from rewriting theory [36] to bunched \nimplications [31, Ex. 14]. 8.1.2 Strict premonoidal categories Before turning to premonoidal categories \nin general, we de.ne strict premonoidal categories. A strict premonoidal category [33] is a monoid in \nthe multicategory Catm. A monoid in a multicategory is an object Awith morphisms -.i :Aand x:A, y:A.x0y \n:A satisfying the monoid laws: y:A.i .x. x 0y = y :A x:A.i .y. x 0y = x :A (6) x, y, z :A.x 0y .w. w \n0z = y 0z .w. x 0w :A. In Catm, the morphism i :() .Ais the same thing as an object of the category A. \nThe construction 0 : (A, A) .Ais not a functor A\u00d7A.Afrom the product of categories, but rather a construction \nthat is functorial in each argument. 8.1.3 Central morphisms Just as central morphisms play a crucial \nrole in premulticategories, they also play an important role in the theory of premonoidal categories. \nWe begin by recalling that a binoidal category [33] is a category Atogether with a morphism 0 : (A, A) \n.Ain the multicategory Catm. For each object C and each morphism f:A .B we have morphisms (f 0C) :A0C \n.B0C and (C0f) :C0A .C0B. Given morphisms f:A . B, g:C . D in A we thus have two morphisms A 0C .B 0D: \nfC Ag Bg fD A0C . B0C . B 0D A0C . A0D . B 0D If these are equal, we say that f and g commute. A \nmorphism in a binoidal category is central if it commutes with all morphisms. 8.1.4 Premonoidal categories \nIn the multicategory Catm the sets of morphisms (A1 . . . An) .B can themselves be considered as categories. \nGiven morphisms F, G :(A1 . . . An) .B, a 2-cell a:F . G comprises a family of morphisms aA.:F (A.) .G(A.) \nin B indexed by lists of objects (A1 . . . An) from categories A1 . . . An respectively, that is nat\u00adural \nin each argument. With this in mind, we can weaken (6) by replacing the equalities with central natural \nisomorphisms. De.nition 23 ([33]). A premonoidal category is a binoidal cate\u00adgory (A, 0 : (A, A) . A) \nwith an object i and central natural isomorphisms .y :i 0y . y .x :x 0i . x ax,y,z :(x 0y)0z . x 0(y \n0z) that make the following triangle and pentagon laws hold: ai,x,yax,y,i (i 0x) 0y - i 0(x 0y) (x 0y) \n0i - x 0(y 0i)  .xGy .xGy t (.x y) t x .y x 0y x 0y (aw,x,y ) z aw,xGy,z ((wx)y)z (w(xy))z w((xy)z) \nawGx,y,z tw ax,y,z t (wx)(yz) - w(x(yz)) aw,x,yGz Note that while the centrality of ., ., and a is reasonable \nfrom a pragmatic perspective, it is ad hoc in that it does not come from the analysis of Catm as a 2-multicategory. \n 8.1.5 Coherence The de.nition of premonoidal category is not based on universal properties and so, a \npriori, there is nothing canonical about ., . and a. A canonical status is given by the coherence theorem \n(Proposition 25) which characterizes the morphisms that can be built from ., . and a. De.nition 24. Let \nA be a set. An object-string is generated from the grammar S, T ::= i I (S 0T ) I A (A . A). such that \neach element of the set A appears exactly once. An isomorphism-string between object-strings, f : S .T \n, is a string that is built using composition, 0, ., ., a and their inverses, subject to the obvious \nwell-formedness condition. Proposition 25 ([33]). Let S and T be object-strings. All isomor\u00adphism strings \nf, g : S . T are equal when interpreted in any pre\u00admonoidal category. Coherence theorems like this form \nan important part of the cat\u00adegory theory literature. Nonetheless we contend that it is more de\u00adsirable \nthat the structure arises a priori from universal properties, which is the content of our main theorem \n(Theorem 26). For one thing, the universal properties place the structure closer to program\u00adming language \nsyntax.  8.2 Main theorem Our main theorem provides a connection between premulticate\u00adgories with tensor \nproducts and premonoidal categories. It is a vari\u00adation of the established connection between multicategories \nwith tensor products and monoidal categories [14, 22]. Theorem 26. Let Abe a set. The following data \nare equivalent. 1. A premulticategory with tensor products whose objects are A. 2. A premonoidal category \nwhose objects are A.   This section is devoted to the proof of this theorem. We begin with the following \nstraightforward property of tensor products in premulticategories. Proposition 27. A premulticategory \nhas all tensor products if and only if it has tensor products of the empty list and of every two element \nlist. Of course, it is sometime useful to have explicit n-ary product types, but the universal property \ntells us that any two implementa\u00adtions are canonically isomorphic. From a premulticategory to a premonoidal \ncategory. Given a premulticategory C with tensor products, we de.ne a premonoidal category. A morphism \nf :A . B in the premonoidal category is a morphism f :(A) . B in C. Composition and identities are immediately \nderived from the premulticategory too. The unit of the premonoidal structure is .(), and the pre\u00admonoidal \ntensor A 0C is the tensor product .(A, C ) in the pre\u00admulticategory. This can be made into a binoidal \nstructure: given x:A .f :B and y:C .g :D, let def' ' f 0C = z: .(A, C ) .z -.x, y.. f .x . .x , y. : \n.(B, C ) def' A 0g = z: .(A, C ) .z -.x, y.. g .y . .x, y '. : .(A, D) One veri.es that this structure \nis functorial (preserves composition and identities) by some algebraic manipulation using the axioms \nfor premulticategories, which we omit for brevity. Having the binoidal structure in place we can note \nthat the two notions of centrality are related: Proposition 28. A morphism f:(A) . B in a premulticategory \nis central (\u00a72.1) if and only if it is central in the induced binoidal category (\u00a78.1.3). (This is deduced \nby algebraic manipulation.) The coherence isomorphisms in the premonoidal category are de.ned by def \n.B = z:(.(.(), B)) .z -.x, y.. x -... y :B def .A = z:(.(A, .())) .z -.x, y.. y -... x :A def aA,B,C \n= xyz:(.(.(A, B), C )) . xyz-.xy,z.. xy-.x,y...x,.y,z.. :(.(A, .(B, C ))) Again, some algebraic manipulation \nis needed to show that these morphisms are isomorphisms, that they are central, that they are natural, \nand that they satisfy the coherence diagrams. From a premonoidal category to a premulticategory. We begin \nwith some remarks about contexts in a premonoidal category. A list of objects determines an object IGI \nof the premonoidal category: def IA1, A2, A3, . . . , AnI = ((((A1 0A2) 0A3)\u00b7\u00b7\u00b70An) 0I. In particular, \nI\u00d8I = I and IAI = A0I. We often need to concatenate lists. The coherence result (Prop. 25) gives us a \ncanonical central isomorphism between IG, .I and IGI 0I.I. (The objects are typi\u00adcally not identical.) \nGiven a premonoidal category, we de.ne a premulticategory with the same objects. A morphism G .A in the \npremulticategory is a morphism IGI .A in the premonoidal category. The identity morphisms (A) .A in the \npremulticategory are the right identity isomorphisms A0I .A in the premonoidal category. For compo\u00adsition, \ngiven t:I.I .A and u:IG, x:A, G 'I .B we let (t .x. u) be the following composite: ' (.G. t) .G . IG, \n., G 'I . (IGI 0I.I) 0IG 'I .(IGI 0A) 0IG 'I u . IG, A, G 'I .B where the unlabelled isomorphisms are \nthe canonical coherence isomorphisms in the premonoidal category. The identity and associativity laws \nfor premulticategories fol\u00adlow from the centrality and canonicity of the coherence isomor\u00adphisms. Proposition \n29. A morphism t:IGI .A in a premonoidal category is central in the premonoidal category if and only \nif it is central in the induced premulticategory. The tensor product of the premulticategory is straightforward: \ndef for any list ., let .. = I.I. The universal morphism . .I.I is the identity morphism. Given t:IG, \n., G 'I .B we let def''t y -.x... t = IG, y: .., G I . IG, ., G I .B. Again, the unlabelled isomorphism \nis the canonical coherence iso\u00admorphism. The two laws for tensor products follow from the cen\u00adtrality \nand canonicity of the coherence isomorphisms. Equivalence. In the statement of Theorem 26, when we say \nthat the two notions are equivalent, we do not mean that they are ex\u00adactly the same. Rather, we mean \nthat if we begin with a premulti\u00adcategory C, build a premonoidal category, and then recover a pre\u00admulticategory \nfrom the premonoidal category, we recover a pre\u00admulticategory that is canonically isomorphic to C. Conversely, \nif we begin with a premonoidal category C, and then build a pre\u00admulticategory out of it, and then recover \na premonoidal category from the premulticategory, we recover a premonoidal category that is isomorphic \nto C. In this sense, the two notions are equivalent. This concludes our proof of Theorem 26.  8.3 Corollaries \nof the main theorem We conclude this paper by building on the main theorem (Theo\u00adrem 26) to recover new \nuniversal characterizations of various mod\u00adels from the literature. Structural laws. Power and Robinson \n[33] de.ne a symmetric premonoidal category to be a premonoidal category with a cen\u00adtral natural isomorphism \n{sA,B:A 0B .B 0A}A,B satisfying coherence conditions. Proposition 30. To give a symmetric premonoidal \ncategory is to give a symmetric premulticategory (Def. 3) with tensor products. Sums and predistributive \ncategories. Power and Robinson [33] de.ne a predistributive category to be a premonoidal category with \n.nite coproducts in which the functors A 0 (-) and (-) 0 A preserve .nite coproducts for all objects \nA. Proposition 31. To give a predistributive category is to give a premulticategory with all tensor products \nand sums (\u00a74). Multicategories and monoidal categories. We turn to the well\u00adknown representation theorem \nfor multicategories [14, 22]. Recall that a multicategory is a premulticategory in which all morphisms \nare central (\u00a72.1). Similarly, a monoidal category is a premonoidal category (\u00a78.1.4) in which all morphisms \nare central (\u00a78.1.3). Proposition 32 (c.f. [14]). 1. A premulticategory with tensor products is a multicategory \nif and only if the corresponding premonoidal category is a monoidal category. 2. To give a symmetric \nmulticategory (Def. 3) with tensor products is to give a symmetric monoidal category. 3. To give a cartesian \nmulticategory (Def. 4) with tensor products is to give a category with .nite products.   Freyd multicategories \nand Freyd categories. We now connect our analysis of values (\u00a75) with the notion of Freyd category [23, \n24, 34]. A Freyd category is de.ned to be an identity-on-objects premonoidal functor V . C from a category \nV with cartesian products to a premonoidal category C. Proposition 33. To give a Freyd category is to \ngive a cartesian Freyd multicategory (\u00a75.3.3) that has tensor products (\u00a75.3.2). Strong monads and function \nspaces. We now use the known connections between closed Freyd categories and monads [24, 34] to provide \na universal characterization for Moggi s monads in com\u00adputation [30] . Proposition 34. Let V be a symmetric \nmulticategory with all ten\u00adsors. Let Mon(V) be the corresponding symmetric monoidal cate\u00adgory (Proposition \n32). The following data are equivalent: 1. A strong monad on Mon(V). 2. A symmetric Freyd multicategory \nV .C that has function spaces with empty domain (() .A) (\u00a76.1).  Proof outline. From 1 to 2, let C be \nthe Kleisli premulticategory for the monad (\u00a72.2). From 2 to 1, a monad on V is given by the construction \nT (A) def(() .A). = Moggi [29] models a call-by-value functional programming language by a .C -model, \nwhich is a strong monad on a category with products and with certain Kleisli function spaces. We now \ngive this a universal status by exhibiting an equivalent de.nition using premulticategories. Proposition \n35. Let V be a cartesian multicategory with tensor products. Let Mon(V) be the corresponding category \nwith .nite products (Proposition 32). The following data are equivalent. 1. A .C -model structure for \nMon(V). 2. A cartesian Freyd multicategory V . C with tensor products and function spaces.  9. Concluding \nremarks We have given universal properties for type constructions in impure programming languages: products, \nsums, and function spaces. We have done this using the novel notion of premulticategory, which is a basic \nequational account of impure computation. We have shown that monads and premonoidal categories can be \nunderstood from this point of view and hence given a canonical status. Acknowledgments S Staton partly \nsupported by the Isaac Newton Trust and ERC Grant ECSYM. PB Levy supported by EPSRC Advanced Research \nFellowship EP/E056091/1. References [1] M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. L\u00b4evy. Explicit \nsubstitu\u00adtions. J. Funct. Program., 1(4):375 416, 1991. [2] T. Altenkirch, J. Chapman, and T. Uustalu. \nMonads need not be endofunctors. In FOSSACS 10, pages 297 311, 2010. [3] R. Atkey. What is a categorical \nmodel of arrows? In Proc. MSFP 08, pages 19 37, 2011. [4] P. N. Benton and P. Wadler. Linear logic, monads \nand the lambda calculus. In Proc. LICS 96, pages 420 431, 1996. [5] A. Burroni. T-categories (cat\u00b4 egories \ndans un triple). Cahiers Topologie G\u00b4erentielle, 12(3):215 312, 1971. eom. Diff\u00b4 [6] A. Burroni. Higher \ndimensional word problem. In Proc. CTCS 91, pages 94 105, 1991. [7] P.-L. Curien. Operads, clones, and \ndistributive laws. In Operads and Universal Algebra, 2010. [8] J. Egger, R. E. M\u00f8gelberg, and A. Simpson. \nEnriching an effect calculus with linear types. In Proc. CSL 09, pages 240 254, 2009. [9] M. P. Fiore. \nSemantic analysis of normalisation by evaluation for typed lambda calculus. In Proc. PPDP 02, pages 26 \n37, 2002. [10] C. Flanagan, A. Sabry, B. F. Duba, and M. Felleisen. The essence of compiling with continuations. \nIn Proc. PLDI 93, pages 237 247, 1993. [11] F. Foltz, C. Lair, and G. M. Kelly. Algebraic categories \nwith few monoidal biclosed structures or none. J. Pure and Applied Algebra, 17:171 177, 1980. [12] C. \nF \u00a8Direct models of the computational lambda-calculus. uhrmann. In Proc. MFPS XV, pages 147 172, 1999. \n [13] H. Herbelin. A lambda-calculus structure isomorphic to Gentzen-style sequent calculus structure. \nIn Proc. CSL 94, pages 61 75, 1994. [14] C. Hermida. Representable multicategories. Advances in Mathemat\u00adics, \n151:164 225, 2000. [15] M. Hyland. Multicategories in and around algebra and logic. Invited talk, TACL \n09. Slides available from the author s home page, 2009. [16] B. Jacobs. Semantics of weakening and contraction. \nAnnals of Pure and Applied Logic, 69(1):73 106, 1994. [17] B. Jacobs and I. Hasuo. Freyd is Kleisli, \nfor arrows. In Proc. MSFP 06, 2006. [18] A. Jeffrey. Premonoidal categories and a graphical view of programs. \nUnpublished, 1997. [19] A. Kock. Monads on symmetric monoidal closed categories. Archiv der Math., 21:1 \n10, 1970. [20] Y. Lafont. Towards an algebraic theory of Boolean circuits. J. Pure Appl. Algebra, 184(2 \n3):257 310, 2003. [21] J. Lambek. Deductive systems and categories II. In Category theory, homology theory \nand their applications, volume 86 of LNM, pages 76 122. Springer, 1969. [22] T. Leinster. Higher operads, \nhigher categories. CUP, 2004. [23] P. B. Levy. Call-by-push-value. Springer, 2004. [24] P. B. Levy, J. \nPower, and H. Thielecke. Modelling environments in call-by-value programming languages. Inform. Comput., \n2003. [25] F. Linton. Autonomous equational categories. Indiana Univ. Math. J., 15:637 642, 1966. [26] \nG. McCusker. A fully abstract relational model of syntactic control of interference. In Proc. CSL 02, \npages 247 261, 2002. [27] P. Melli `es and N. Tabareau. Linear continuations and duality. hal.archives-ouvertes.fr/hal-00339156, \n2008. [28] R. E. M\u00f8gelberg and S. Staton. Linearly-used state in models of call\u00adby-value. In CALCO 11, \npages 298 313, 2011. [29] E. Moggi. Computational lambda-calculus and monads. In LICS 89, pages 14 23, \n1989. [30] E. Moggi. Notions of computation and monads. Inform. Comput., 93 (1), 1991. [31] P. W. O Hearn. \nOn bunched typing. J. Funct. Program., 13(4):747 796, 2003. [32] J. Power. Premonoidal categories as \ncategories with algebraic struc\u00adture. Theor. Comput. Sci., 278(1 2):303 321, 2002. [33] J. Power and \nE. Robinson. Premonoidal categories and notions of computation. Math. Struct. Comput. Sci., 7(5):453 \n468, 1997. [34] J. Power and H. Thielecke. Closed Freyd-and kappa-categories. In Proc. ICALP 99, 1999. \n[35] U. S. Reddy. Global state considered unnecessary: An introduction to object-based semantics. Lisp \nand Symbolic Computation, 9(1):7 76, 1996. [36] J. G. Stell. Modelling term rewriting systems by sesqui-categories. \nTechnical Report TR94-02, Keele University, 1994.       \n\t\t\t", "proc_id": "2429069", "abstract": "<p>We investigate impure, call-by-value programming languages. Our first language only has variables and let-binding. Its equational theory is a variant of Lambek's theory of multicategories that omits the commutativity axiom.</p> <p>We demonstrate that type constructions for impure languages --- products, sums and functions --- can be characterized by universal properties in the setting of 'premulticategories', multicategories where the commutativity law may fail. This leads us to new, universal characterizations of two earlier equational theories of impure programming languages: the premonoidal categories of Power and Robinson, and the monad-based models of Moggi. Our analysis thus puts these earlier abstract ideas on a canonical foundation, bringing them to a new, syntactic level.</p>", "authors": [{"name": "Sam Staton", "author_profile_id": "81317490422", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P3977944", "email_address": "sam.staton@cl.cam.ac.uk", "orcid_id": ""}, {"name": "Paul Blain Levy", "author_profile_id": "81100154557", "affiliation": "University of Birmingham, Birmingham, United Kingdom", "person_id": "P3977945", "email_address": "p.b.levy@cs.bham.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429091", "year": "2013", "article_id": "2429091", "conference": "POPL", "title": "Universal properties of impure programming languages", "url": "http://dl.acm.org/citation.cfm?id=2429091"}