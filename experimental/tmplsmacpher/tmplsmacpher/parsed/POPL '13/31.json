{"article_publication_date": "01-23-2013", "fulltext": "\n Fully Abstract Compilation to JavaScript Cedric Fournet \u00b4Nikhil Swamy Juan Chen Pierre-Evariste Dagand \nPierre-Yves Strub1 Benjamin Livshits Microsoft Research and MSR-INRIA1 {fournet, nswamy, juanchen, livshits}@microsoft.com \ndagand@cis.strath.ac.uk pierre-yves@strub.nu Abstract Many tools allow programmers to develop applications \nin high\u00adlevel languages and deploy them in web browsers via compilation to JavaScript. While practical \nand widely used, these compilers are ad hoc: no guarantee is provided on their correctness for whole \nprograms, nor their security for programs executed within arbitrary JavaScript contexts. This paper presents \na compiler with such guar\u00adantees. We compile an ML-like language with higher-order func\u00adtions and references \nto JavaScript, while preserving all source pro\u00adgram properties. Relying on type-based invariants and \napplicative bisimilarity, we show full abstraction: two programs are equivalent in all source contexts \nif and only if their wrapped translations are equivalent in all JavaScript contexts. We evaluate our \ncompiler on sample programs, including a series of secure libraries. Categories and Subject Descriptors \nD.2.4 [Software/ Program Veri.cation]: Validation; D.3.4 [Processors]: Compilers; D.4.6 [Operating Systems]: \nSecurity and Protection Veri.cation. Keywords Program equivalence; full abstraction; re.nement types. \n1. Introduction Many tools allow programmers to develop applications in high\u00adlevel languages and deploy \nthem in web browsers via compilation to JavaScript. These include industrial compilers like GWT for Java, \nWebSharper and Pit for F#, and Dart, as well as several academic efforts like Links (Cooper et al. 2006) \nand Hop (Serrano et al. 2006). While practical and, in some cases, widely used, these compilers are ad \nhoc: no guarantee is provided on their correctness for whole programs, nor their security for programs \nexecuted within arbitrary JavaScript contexts. The lack of security against JavaScript contexts is of \nparticular concern, since compiled code is routinely linked with libraries au\u00adthored directly in JavaScript. \nLibraries like jQuery and Prototype are widely used, provide improved support for several core web\u00adprogramming \ntasks, but do so by making use of highly dynamic features of JavaScript, e.g., by rede.ning properties \nof prede.ned objects. Less well-known libraries are also routinely included in pages, often by simply \nincluding a pointer to the code served from a potentially untrustworthy URL. It is also common practice \nto in\u00adclude rich third-party content (e.g., advertisement scripts) in the same context as trusted JavaScript \ncode. In all those cases, link\u00ading with a malicious or buggy script can easily break invariants of Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 13, January \n23 25, 2013, Rome, Italy. Copyright c . 2013 ACM 978-1-4503-1832-7/13/01. . . $15.00 Figure 1. Architecture \ncompiled code, compromise its security, and, in general, render any reasoning principles of the source \nprogramming language inappli\u00adcable to the JavaScript code that is actually executed. This paper presents \na correct and secure compiler from a vari\u00adant of ML with higher-order functions and references to JavaScript. \nOur main result is full abstraction: two programs are equivalent in all source contexts if and only if \ntheir translations are equivalent in all JavaScript contexts. Full abstraction is an ideal compiler prop\u00aderty, \ninasmuch as it enables local reasoning on source code, without the need to understand the details of \nthe compiler or the target plat\u00adform. In our case, programmers can rely on their experience with ML, \nwith static scopes and types, or trust source-level veri.cation tools and largely ignore the rather tricky \nsemantics of JavaScript. Which semantics for JavaScript? Compared to ML, the seman\u00adtics of JavaScript \nis daunting. There are several different ECMA standards and various implementations (mainly by web browsers) \nthat deviate from the standard in idiosyncratic ways. Maffeis et al. (2008) give an operational semantics \nfor the ECMAScript 3 stan\u00addard, which while extremely detailed, is also unwieldy in that it is not easily \namenable to formal proof or to testing. An alternative approach is to give a semantics via translation \nto a simpler lan\u00adguage, and then to test this translation semantics for compliance with browser implementations. \nThis is the approach of Guha et al. (2010), who give a translation of JavaScript into a mostly standard, \ndynamically typed lambda calculus called .JS. The translation se\u00admantics is convenient for our purposes \n(e.g., it is executable) and not necessarily less precise or more complex. So, following .JS, we give \na semantics to JavaScript by elaboration to F. (Swamy et al. 2011), a variant of ML with richer types. \nWe intend this se\u00admantics to capture the main features of the ECMAScript 5 standard, including features \nlike getters and setters that were missing in .JS. Our semantics also includes a number of experimental \n.ndings per\u00adtaining to implementation-speci.c features of JavaScript such as the arguments, caller, and \ncallee properties.  A high-level view of the paper Figure 1 outlines our technical development. On the \nleft, we have f., a subset of F. that includes higher-order functions, mutable references, exceptions, \nand fatal errors, but excludes polymorphism for simplicity. Its semantics is parameterized by a type \nsignature that de.nes the basic constants available to a program. On the right, we have concrete JavaScript. \nOur compiler takes an f. program (src.f*)with an arbitrary signature and emits JavaScript syntax in two \nphases. The .rst phase (the light translation ) is compositional and translates f. constructs to the \ncorresponding ones in JavaScript, e.g., function closures to function closures, yielding src.js. For \ncode meant to be executed in untrusted JavaScript contexts, we supplement the light translation with \ncarefully crafted defensive wrappers (wrap.js) to securely import and export values at every source type \nwhile preserving the translation invariant. To reason formally about our compiler, we re.ect its output \nwithin an arbitrary JavaScript context back into f.. Speci.cally, we employ a variant of the .JS semantics \nto translate JavaScript to js. , an instance of f. with a signature JSExec that provides runtime sup\u00adport \nfor js. programs. Our proof of full abstraction relies on re.ne\u00adment typing to establish several key \ninvariants of the translation. For this typing, we introduce JSVerify, a precise typed model of JSExec \nexpressed using monadic re.nement types in f.. Then, we develop a new eager-normal-form variant of applicative \nbisimilar\u00adity for contextual equivalence in f. and use it to show the main result of the paper, i.e., \nthat two f. programs are equivalent with respect to an arbitrary f. context if, and only if, their defensively \nwrapped light translations are equivalent with respect to an arbi\u00adtrary js. context. We summarize our \nmain contributions below. We describe a compiler from f. (\u00a73) to JavaScript, including de\u00adfensive wrappers \nto safely mediate interactions between trans\u00adlated programs and their context. (\u00a74)  We introduce js., \na model of JavaScript within f. that includes security-relevant features of ECMAScript 5 and popular \nJava-Script implementations. (\u00a75)  We formalize our compiler as a translation from f. to js.. We show \nthat it is a forward simulation that preserves a typing and heap invariant. This yields safety and correctness \nfor transla\u00adtions of closed programs executed in isolation. Additionally, by typing, we show that the \ndefensive wrappers support safely ex\u00adchanging values of various types with an untrusted context. (\u00a76) \n We develop a new co-inductive proof technique for f., with la\u00adbeled bisimulations to capture the interactions \nof con.gurations of related terms with their abstract context, such that bisimilar\u00adity coincides with \ncontextual equivalence. (\u00a77)  We prove our compiler from f. to js. fully abstract. (\u00a78)  We close with \na brief discussion and experimental evaluation of our compiler implementation. (\u00a79)  Disclaimer As usual, \nfull abstraction holds only within our for\u00admal semantics of JavaScript, and various side channels may \nstill exist in JavaScript implementations, based, for instance, on stack or heap exhaustion, or timing \nanalysis. This presentation necessarily omits many details. Additional materials, including a technical \nreport with the full formal devel\u00adopment, an F . implementation with a JavaScript back-end, sample source \nand compiled programs, and an updated F . theory in Coq are available at http://research.microsoft.com/fstar. \nRelated work Programming language abstractions have long been recognized as an essential means for protection \n(Morris 1973); their secure implementations are often speci.ed as full abstraction (Abadi 1998; Abadi \net al. 2002; Abadi and Plotkin 2010; Agten et al. 2012). Conversely, many attacks can be interpreted \nas failures of abstraction, and several counterexamples to full abstraction ex\u00adist. For example, Mitchell \n(1993) notes that Lisp with FEXPR has no abstraction contexts, and Kennedy (2006) points out the lack \nof full abstraction in translations from C# to .NET. Many powerful co-inductive techniques exist for \nprogram equi\u00advalence, with various combinations of types, higher-order func\u00adtions, private mutable state, \nand exceptions (Sumii and Pierce 2005; Lassen 2005). As discussed in \u00a77, ours combines their features \nso that bisimulations precisely capture the invariants of wrapped translation within untrusted JavaScript \ncontexts. Although employ\u00ading logical relations instead of bisimulations, Ahmed and Blume (2008) also \nuse type-directed wrappers to prove that typed closure conversion in the polymorphic .-calculus is fully \nabstract. How\u00adever, unlike us, they do not use the wrappers in the translation itself. There has been \nrecent work on protecting JavaScript programs from malicious contexts. For example, Taly et al. (2011) \napply a data.ow analysis to check that programs in a subset of EC-MAScript 5 s strict mode (lacking getters \nand setters) do not leak private data to an adversary. Using this analysis, the authors were able to \nprove the safety of object-capability idioms used by the Caja (2012) framework that rewrites JavaScript \napplications to con.ne security-critical objects, such as the DOM, behind object capabili\u00adties. This \ncon.nement property is related to the invariant enforced by our wrappers, which we check by typing. Taly \net al., however, do not deal with full abstraction. 2. Challenges in secure JavaScript programming To \nillustrate the dif.culty of writing secure JavaScript code, we naively implement a protection mechanism \naround a trusted, exter\u00adnal function rawSend for posting messages to some target domain (Figure 2). By \ncalling mkSend(rawSend), we should obtain a func\u00adtion that enforce the following policy: Send messages \nonly to whitelisted URLs (to avoid privacy leaks); of at most 5 characters (to bound resource usage); \nthat includes a secret credential (to identify the service users).  Do not leak the rawSend function \nor the secret credential, to prevent bypassing our protection mechanism.  Our implementation calls a \nsanitize function, hypothetically pro\u00advided by some other trusted library. As typical in JavaScript, \nlink\u00ading is performed dynamically through the global name-space. For simplicity, we use our mechanism \nto protect an anonymous function that prints the message and its target on the console. The resulting \nprotected send function is exported to the global name\u00adspace and therefore made available to untrusted \nscripts: send = mkSend(function (target, msg) { console.info(\"Sent \" + msg + \" to \" + target);}); In \nisolation, our code seems to enforce our policy. However, we are going to demonstrate how, by carefully \nmanipulating the con\u00adtext, a malicious script can bypass our protection mechanism. We do not claim any \nnovelty in describing these attacks (Caja 2012; Taly et al. 2011; Meyerovich and Livshits 2010): with \nthese exam\u00adples, we aim at giving our reader a glimpse at the challenges met by security-conscious JavaScript \nprogrammers as well as prepare the ground for our defensive wrappers in \u00a76. Attack 1: Overwriting global \nobjects Importing objects from the global name-space is risky: by de.nition, every script has access \nto this name-space. For instance, a script can maliciously overwrite the sanitize function right before \ncalling the send operation: sanitize = function (s,msg) { return msg; }; send(\"http://www.microsoft.com/owa\", \n\"too long!\"); To prevent this attack, we must run mkSend before any hostile script (.rst-starter privilege) \nand store a private copy of sanitize as well as any other trusted library function it may call.  function \nmkSend(rawSend){ var whiteList = {\"http://www.microsoft.com/mail\":true, \"http://www.microsoft.com/owa\":true}; \nfunction newSend(target, msg){ msg = \"[\" + secret_credential + \"]\" + msg; if (whiteList[target]){ rawSend(target,window.sanitize(5,msg));} \nelse { console.error(\"Rejected.\");}}; return newSend ;} function sanitize(size,msg) { return msg.substring(0,size);} \nFigure 2. Naive implementation of a secure send Attack 2: Dynamic source code inspection Unsurprisingly, \nhid\u00ading secrets in source code is to be avoided. Supposing that we wanted to keep the whiteList secret, \na malicious script can use the toString method on the mkSend function to retrieve its content: var targets \n= mkSend.toString().match(/\\ .*?\\ :true/g) targets = targets.map(function (s) { return s.replace(/\\ (.*?)\\ \n:true/,\"$1\") }); Amere regular expression matching on the resulting string lets us extract the list of \nvalid targets. This is not, as such, a violation of the speci.cation, yet it is a rather unusual feature. \nAttack 3: Rede.ning Object Since JavaScript is a prototype\u00adoriented programming language, one can dynamically \nmodify properties of any object in the system. In particular, one can add a .eld to the prototype of \nthe canonical object, Object, hence ex\u00adtending the white list without even referring to whiteList itself: \nObject.prototype[\"http://www.evil.com\"] = true; send(\"http://www.evil.com\",\"msg\"); To preclude this attack, \nwe must ensure that any given .eld is indeed part of the whiteList object, and not inherited from its \nprototype chain. To this end, we could use a safe private copy (obtained by starting .rst) of the hasOwnProperty \nmethod. Attack 4: Side-effectful implicit coercions Part of the complexity of JavaScript comes from its \ntreatment of coercions: should the need arise, objects are automatically coerced at run-time. Instead \nof a string, one can, for instance, pass an object with a toString method that returns a string in the \nwhiteList on the .rst use and another string as the actual send operation is performed: var count = 0; \nvar target = { toString: function() { return count++ == 0 ? \"http://www.microsoft.com/owa\" : \"http://www.evil.com\" \n}}; send(target, \"msg\"); To tame these implicit coercions, we may explicitly check that the input arguments \nare of the correct type, using the typeof operator. Alternatively, we may force a coercion upon receiving \nthe argu\u00adments and store the result this is the case for msg in Figure 2. Attack 5: Walking the call \nstack Finally, stepping outside ECMA standards, most implementations of the Function object provide a \ncaller property that points to the current caller of the func\u00adtion being executed. Abusing this mechanism, \nany callback (such as an implicit coercion or a getter) grants access to the argu\u00adments of its caller \nnewSend, including msg after concatenation with secret_credential: var c; var target = { toString: function \ntoStr () { c = toStr.caller.arguments[1].match(/\\[(.*?)\\]/)[1]; return \"http://www.microsoft.com/mail\" \n}} send(target, \"msg\"); This code enables one to retrieve the credential by matching the msg argument. \nSimilarly, one could retrieve any secret on the call stack. To guard against this attack, we must explicitly \nclear the caller .eld of our functions before any potential callback. Our proposal The examples above \nshow that local reasoning about code in JavaScript can be compromised through a variety of attacks. Hence, \nwriting secure code in JavaScript is a hard\u00adship: one must take a great deal of attack vectors into account, \nand one ends up maintaining extremely cumbersome programs, which makes them more error-prone. We propose \nthat programmers in\u00adstead use a source language with static types and scopes to write security-sensitive \ncode. A compiler should then securely translate the source language to JavaScript, freeing the programmer \nfrom thinking about the subtle semantics of JavaScript. In this context, ML appears to be a particularly \neffective source language: it has static types and scopes; it is functional, so we can rely on closures \nand higher-order functions also available in JavaScript; and, be\u00ading impure, we can adopt a programming \nstyle that approaches id\u00adiomatic JavaScript. In ML, the example of Figure 2 can be written as shown below, \nwhich clearly meets the stated security goals. let mkSend rawSend = let whiteList = [\"http://www.microsoft.com/mail\"; \n\"http://www.microsoft.com/owa\"]in fun target msg . let msg = \"[\" secret credential \"]\" msg in if mem \ntarget whiteList then rawSend target (sanitize 5msg) else consoleError \"Rejected.\" 3. Syntax and semantics \nof f. In this paper, we use f., a fragment of F. (Swamy et al. 2011) simi\u00adlar to ML, with the syntax \nshown below and a standard, small-step, call-by value semantics (see the full paper). We have extended \nthe original presentation and formal development of F . with excep\u00adtions, fatal errors, and primitive \nsupport for a mutable store. Values range over variables, memory locations, abstraction over terms, and \nn-ary, fully applied data constructors. We add a form of results r, which, in addition to values, includes \nexceptions raise v and fatal error. Expressions are in a partial administrative normal form, with, for \ninstance, function application e v requiring the argument to be a value. We also have pattern matching, \nreference allocation, assignment and dereference, and exception handlers. Syntax of f. v ::= x | l | \n.x:t.e | Dt\u00afv\u00afvalues r ::= v | raise v| error results e ::= r | e v | let x = e in e ' | v1 := v2 | ref \nv| !v | terms try e with x.e | match v with Da\u00afx\u00af. e else e ' t ::= T | ref t | t . t ' types H ::= \u00b7 \n| (l .t v) | H,H' store F[ ] ::= | F v | Ft | let x = F in e exn. ctx E[ ] ::= | E v | E t | let x = \nEin e | try Ewith x.e eval. ctx S ::= \u00b7 | D:t | T::. | S,S' signature G ::= \u00b7 | G,x:t | G,a | G, l:t \n| . . . type env. An f. runtime state, written H|e, is a pair of a store mapping lo\u00adcations to values \nand a program expression. The reduction relation ' has the form H|e .S H' |e where the index Sis a .xed \ninductive signature that de.nes all constructors. This signature includes at least a type exn for exceptions, \ntypes ref t for references, and unit. We also freely use common primitive types like int and bool, and \nexpect these to be in the signature as well. Our syntax does not in\u00adclude a .xpoint form because recursion \ncan be encoded with recur\u00adsive datatypes in the signature. We consider several instantiations of the \nsignature Sin this paper, to de.ne our source language (\u00a74) and to embed dynamically typed JavaScript \nwithin f. (\u00a75). ' Syntactic sugar We write applications e e as abbreviations of ' let x = e in e x, for \nsome fresh x. A similar transformation applies to pattern matching, reference operations, exception raising, \netc. We write if e then e1 else e2 for match e with true . e1 else e2, and e1;e2 for let = e1 in e2. \nAdditionally, in code listings, we rely on the concrete syntax of F., which closely resembles OCaml and \nF#.  Plain types F. includes various dependent typing features, but we ignore this in f., and restrict \nthe types to a monomorphic sub\u00adset of ML including function types t. t ', references, and recursive datatypes. \nNevertheless, we have extended our Coq-based metathe\u00adory of the full F. language to include exceptions, \nstate and errors, and proved subject reduction for the reduction of open terms, i.e., terms that may \ncontain free variables, which is used in \u00a77 and \u00a78. We present a specialized version of this theorem \nbelow, where we use the type judgment for F. runtime states. This is written here as S;G . H|e:t, denoting \nthat in an environment including the signa\u00adture S, free variables G, and the typed domain of H(written \ns(H), including l :t for each l.t v in H), the store H is well-typed and the expression e has type t. \nWhen the signature Sis evident from the context, we simply write G . H|e:t. Theorem 1 (Type soundness \nfor open-term reduction). Given S, G, H, e, and t such that S;G . H|e:t, either (1) e is a result; or \n(2) e is an open redex, i.e., e . {E[x v],E[match x with . . .],E[x := v], E[!x]}; or (3) there exist \nH ' , e ' such that H |e.SH' |e ' and S;G . H' |e ' :t. Contextual equivalence We only observe well-typed \nterms and compare them at the same plain types. Following Theorem 1, we de.ne basic observations on runtime \nstates s: (1) s returns, that is, * s .S H|r, with three kinds of results: any value (written s .); any \nexception (written s . raise); or an error (written s . error); or (2) s diverges (written s .) when \nit has an in.nite sequence of reductions; or (3) (only in case s is open), s reduces to a redex with \na free variable in evaluation context. We de.ne contextual equivalence for closed values and expres\u00adsions, \nconsidering all typed evaluation contexts. (Equivalence be\u00adtween open terms can be re-stated using closed \nfunction values.) De.nition 1 (Contextual Equivalence). Two (closed, typed) run\u00adtime states s and s' \nhave the same behavior, written s s ', when e they either both return the same kind of result, or both \ndiverge. Two (closed, typed) terms are equivalent, written e e e ', when they have the same behavior \nin all evaluation contexts. 4. A compiler from f. to JavaScript We present our compiler from f. to JavaScript, \nusing the f. program below as a running example. let mkLog = let log = ref (Nil :list string)in let add \nx = log := Cons x !log in let iter f = List.iter f !log in (add, iter) Calls to mkLog return an abstract \ninterface to a log, with functions add and iter to extend the log with a string and to operate on its \ncontents, respectively. Reasoning in f., it is clear for instance that the log only contains strings \nand that it grows monotonically. In this section, we illustrate informally how our compiler en\u00adsures \nthat all source invariants are preserved in the translation to JavaScript. In subsequent sections, we \njustify it by formalizing our compiler as a translation from f. to js. and proving it fully abstract. \nThe light translation Our compiler proceeds in two phases. The .rst phase is compositional and purely \nsyntax-directed: the trans\u00adlation function [e], shown in Figure 3, translates f. constructs to their \nJavaScript counterparts. Following standard practice, we as\u00adsume uniqueness of variable names. We also \nuse an auxiliary func\u00adtion, locals(e), that collects the let-and pattern-bound names not enclosed within \nadditional .s of expression e. We translate functions in f. to functions in JavaScript as fol\u00adlows: Local \nvariable declarations in JavaScript always occur at the top of a function body, so we collect the source \nlocals and declare them upfront. When reading a variable x (the second rule), we sim\u00adply lookup the JavaScript \nvariable with the same name x. In the third rule, we translate let-bindings to JavaScript sequence expres\u00ad \n[.x:t.e] . function(x){var y;return[e];} where y\u00af=locals(e) [x] . x [let x = e1 in e2] . (x=[e1], [e2]) \n[e1 v2] . [e1]([v2]) [Dv\u00af] . {\"tag\":str D, str i:[vi]} [ref v] . {\"ref\":[v]} [v1 := v2] . ([v1].ref=[v2],undefined) \n[!v] . [v].ref [error] . alert(\"error\") [match v with Dx\u00af. e1 else e2] . ([v].tag === str D)?(xi=[v][str \ni],[e1]):[e2] Figure 3. Light translation from f. to JavaScript sions (x=e0,e1) in JavaScript, this expression \nevaluates e0, as\u00adsigns the result to x, and then evaluates e1. Function application is straightforward. \nWe translate data values D v0. . . vn-1 to objects with a tag .eld recording the name of the constructor \nas a string, and with .elds \"0\", . . . , str (n- 1) containing the translations of the arguments the \nmeta-function str encodes its argument as a JavaScript string. References have a single .eld \"ref\". When \nassigning a reference, we update the ref .eld and then evaluate to undefined, our representation of the \n():unit value in JavaScript. We model fatal error in JavaScript by calling the alert function, which \npops up a dialog in most browser environments several other possibilities exist for modeling fatal errors. \nFinally, we translate matching to JavaScript conditional expressions,e?e0:e1. Observe that the only statement \nforms we use are within functions, where we use var declarations and return. By relying only on the expression \nforms of JavaScript, we obtain a simple compositional translation. For simplicity, the input of the translation \ndoes not contain ex\u00adceptions and their handlers, but we still study their properties for all f. evaluation \ncontexts (including exceptions). Technically, we also require that f. does not have ref unit and similar \ntypes whose val\u00adues are all contextually equivalent in f. but whose translations may be distinguished \nin JavaScript using untyped equality. Finally, we do not formalize the translation of polymorphic data \nconstructors, although they are supported by our compiler implementation. At top level, our formalization \napplies to the translation of pro\u00adgrams enclosed within a function. Our implementation augments this \nwith simple handling for top-level let-bindings. Running this on the declaration of mkLog, we obtain \nthe following JavaScript, where List.iter refers to the translation of the f. function List.iter. function \nmkLog (u) { var log; var add; var iter; return (log={\"ref\":{\"tag\":\"Nil\"}}, (add=(function(x){ return \n(log.ref={\"tag\":\"Cons\", \"0\":x, \"1\":log.ref}, undefined); }), (iter=(function(f){ return (List.iter(f)(log.ref));}), \n{\"tag\":\"Pair\", \"0\":add, \"1\":iter})));} Type-directed defensive wrappers Providing a JavaScript con\u00adtext \nwith direct access to mkLog is not fully abstract: an adversary could, for example, call mkLog, obtain \niter, and then call it with a function f that (as in attack 5 of \u00a72) walks the stack, accesses log directly \nfrom the arguments of List.iter, and breaks its invariants. To protect our code, we apply type-directed \nwrappers that build a .rewall between the lightly translated f. code and its context. Our wrappers are \nJavaScript functions indexed by source types t. They come in pairs: a down wrapper, written . t, takes \na light translation of a source value v:t and exports it safely to the context; an up wrapper, written \n.t, takes any JavaScript value supplied by the context and attempts to extract from it a value that is \na light translation of some source v:t; this may fail. In addition to ensuring that the translated f. \ncode and its context interact at the expected types, the wrappers seek to enforce a strict heap separation \nbetween the code and the context. Speci.cally, we  function downunit(x) { return x;} function upunit(x) \n{ return undefined;} function downbool(x) { return x;} function upbool(z) { return (z ? true : false);} \nfunction downstring(x) { return x;} function upstring(x) { return (x + \"\");} function downpair(dn_a, \ndn_b) { return function (p) { return {\"tag\":\"Pair\", \"0\":dn_a(p[\"0\"]),\"1\":dn_b(p[\"1\"])};}} function uppair(up_a, \nup_b) { return function(z) { return {\"tag\":\"Pair\", \"0\":up_a(z[\"0\"]),\"1\":up_b(z[\"1\"])};}} function downfun \n(up_a,down_b) { return function (f) { return function (z) { return (down_b (f (up_a(z)))); }}} function \nupfun (down_a,up_b) { return function (f) { return function (x) { var z = down_a x; var y = undefined; \nfunction stub() { arguments.callee.caller = undefined; arguments.callee.arguments = undefined; y = up_b(f(z)); \n} stub(); return y; };};} Figure 4. Selected wrappers in JavaScript ensure that the context never obtains \na direct reference to an object that is used by the light translation; references from f. objects to \nobjects owned by the context (we call such objects untrusted, or un, objects) are also problematic, since \nthe contents of un objects are unreliable, e.g., they may change unexpectedly. So, access to f. objects \nby the attacker, and vice versa, are mediated by wrappers. Figure 4 lists some wrappers used by our compiler. \nFor im\u00admutable base types shared between f. and JavaScript, such as strings, the down wrapper does nothing, \nwhereas the up wrapper forces a coercion. There are various JavaScript idioms that serve to induce coercions \nat particular types, e.g., for Booleans, we use an explicit conditional expression; for numbers, we use \nunary addi\u00adtion; for strings, we concatenate with the empty string, etc. This ensures, for instance, \nthat true and false are indeed the only im\u00adported Boolean values, foiling problems like attack 4 from \n\u00a72. For datatypes such as pairs and lists (and any allocated data), we must ensure that wrapping preserves \nheap separation. Thus, we allocate a fresh representation and recursively wrap their contents. The up \nwrapper is safe even as its code accesses .elds (which may trigger callbacks to the context via implicit \ncoercions or getters) because the imported content is kept as a local value on the up wrapper stack. \nOur code includes wrapper generators; for instance, downpair takes as parameter two down wrappers for \ntypes aand b and returns a down wrapper for pairs containing an a and a b. For functions, the situation \nis more complex, since the up wrapper has no way to check that its argument is the valid repre\u00adsentation \nof a source f. function. Instead, the wrapping is deferred: the function downfun, corresponding to . \n(a . b), exports a func\u00adtion f by wrapping it with another function that .rst imports the argument x, \nthen applies f, and .nally exports the result. In the other direction, one might have expected upfun \n(for . (a . b)) to be strictly dual to . (a . b), i.e., export the argument, apply the function, and \nimport the result. However, this is insuf.cient. As at\u00adtack 5 of \u00a72 illustrates, the JavaScript calling \nconvention provides a function with access to the function object and arguments of its caller. If a trusted \nfunction were to call an untrusted one directly, the latter obtains a reference to the arguments of the \nformer, breaking our heap separation discipline. To this end, following the code of upfun in Figure 4, \nthe wrapper for importing an untrusted function f (purportedly the translation of an a . b value) is \nitself a function, callable from any trusted context, that .rst exports its argument into a local variable \nz, then calls a fresh, single-use stub. The stub makes the call to f on behalf of the trusted code, but \nbefore doing so, it clears its own caller and arguments object. When the call to f proceeds, the context \nobtains a reference to the stub, but cannot walk the stack beyond the stub and compro\u00admise trusted code. \nAfter the untrusted call completes, up_b wraps up the result and stores it in y. (Returning the value \ndirectly is dangerous, since the attacker has a pointer to the stub closure, so, it may be able to call \nthis closure later and receive the protected value.) After the stub completes, the wrapper returns the \ncontents of the local variable y. Thus, to an attacker that attempts to traverse the call stack via the \ncaller/callee proper\u00adties, the stack (growing downward) appears as depicted alongside. Walking upward, \nuntraversable stub objects delimit regions of the stack that transition from un\u00adtrusted to trusted code. \nAdditionally, the up and down wrappers mediate all calls across trust boundaries. Top-level translation \nContinuing with our example, we list below the script that makes mkLog available to an arbitrary JavaScript \ncon\u00adtext after suitable wrapping. Rather than placing mkLog directly into the global name-space (i.e., \nthe window object in a web browser), our compiler generates a function init that takes the window ob\u00adject \nas a parameter, de.nes the lightly translated code of mkLog in a local variable, and exports it to window.mkLog \nafter unfolding and applying the down-wrapper .(unit .(string .unit * (string . unit).unit)). After running \ninit(window), our script overwrites init to prevent any later use (such as init.toString()). function \ninit(w) { function mkLog(u){. . .} // light translation shown above w.mkLog= downfun(upunit, downpair(downfun(upstring, \ndownunit), downfun(upfun(downstring, upunit), downunit)))(mkLog); } init(window); init=undefined; Threats \nand countermeasures We brie.y review potential threats to full abstraction, and informally discuss how \nwe handle them. Modifying Object.prototype can override the default behavior of objects, e.g. when accessing \ntheir properties. As an invariant, translated f. code never triggers a prototype chain traversal, so \nour translation does not depend on Object.prototype.  By changing Function.prototype.apply, an adversary \ncan in\u00adterpose code at function calls. However, ECMAScript 5 states that this interception does not affect \nprimitive function calls.  Function.toString returns the static source of a function clo\u00adsure as a string. \nOur wrappers ensure that, for any function g handed to the adversary, g.toString() always returns the \ntext of its down wrapper, that is, the constant string \"function (z) { return (down_b (f (up_a(z)))); \n}\"  Implicit coercions are pre-empted by systematically forcing coercions in up wrappers.  Stack walks \nvia callee and caller properties are countered by the stub mechanism described above.  Some browsers \nprovide (new Error()).stack, which dumps the current stack as a string. Assuming that our code runs .rst, \nwe disable it in the init function, using the code below.   var oldErr=Error; window.Error=function(){ \nvar x=oldErr(); x.stack=\"\"; return x;}; Are these countermeasures suf.cient? The rest of the paper, \nculminating with the main results of \u00a78, provide a positive answer, at least within our semantics of \nJavaScript. 5. A semantics of JavaScript in f. We begin our formal development with a semantics of JavaScript \nby translation to js., the instance of f. with inductive signature JSExec described below; this allows \nus to carry out our full-abstraction argument entirely within a single language. We base our semantics \non .JS, a dynamically typed language to which Guha et al. (2010) translate JavaScript. We extend .JS \nto include some features of ECMAScript 5 that were missing in the original formulation (which targeted \nECMAScript 3), as well as browser-speci.c features that are relevant for full abstraction. Concurrently, \nPolitz et al. (2012) have extended .JS to cover the strict mode of ECMAScript 5. We focus on a few main \nfeatures of js.: dynamic typing, object properties, function creation, the calling convention, control \noper\u00adators, and eval. We refer to our technical report for a complete presentation, including a formal \ntranslation from .JS to js. . Dynamic typing. In order to type any JavaScript values, JSExec de.nes dyn, \na standard type dynamic , as follows. type dyn = Null :dyn | Undef :dyn | Bool:bool .dyn | Str:string \n.dyn | Num:.oat .dyn | Obj:loc .dyn | Fun:dyn .(dyn .dyn .dyn).dyn and obj = list (string * property) \nand loc = ref obj and property = Data:attrs .dyn .property | Accessor:attrs .(dyn * dyn).property type \nexn = Break:int.dyn.exn | Exn:dyn.exn | Return:dyn.exn The type dyn has a constructor for each JavaScript \nprimitive type. For instance, the JavaScript string literal \"Rome\" is represented as Str \"Rome\":dyn. \nObjects are references to maps from string (prop\u00aderty names) to property, the type of values or accessors \n(getters and setters). Their property attributes attrs specify, for instance, whether they are writable \nor enumerable. (Our translation does not rely on attributes for security.) Getters and setters are treated \nas functions, called to perform property lookups or assignments. Functions in JavaScript are also objects \none may set properties on them, writing, for instance, function foo(){}; foo.x = 17. To handle this, \nwe represent JavaScript functions as js. values Fun o f, constructed from a function object o:dyn and \na closure f. All functions in JavaScript receive an implicit this parameter and, following .JS, a single \nargument object with a .eld for each of their explicit arguments. Thus, the closure f within Fun o f \nhas type dyn .dyn .dyn. We discuss the three kinds of exceptions shortly. Function creation and application \nWhile outside the ECMA-Script speci.cation, most browsers implement a quirk in their call\u00ading convention. \nFunctions f receive their (variable number of) argu\u00adments in single arguments objects. These objects \ninclude a callee .eld that points to the function object of f. Conversely, function objects include an \narguments .eld that points back to the argument object of their last activation, if any, and a caller \n.eld that points back to the function object of their last caller. (This .eld may point to f itself, \nif it makes recursive calls, or be null, for top-level calls.) These .elds are implicitly updated at \nevery call. In particular, all JavaScript functions are recursive through the store, since they are given \naccess to their own object. To model this calling convention, JSExec de.nes several oper\u00adations. First, \na lookup function looks up the property name f in the map of an object (accounting for function values \nas well). let lookup (d:dyn) (f:string)= match d with Obj loc | Fun (Obj loc) .assoc f !loc | .None Similarly, \na modify function updates properties within object maps. In this section, we use shorthands for these \nfunctions: e. f. . match lookup e f with Some(Data x).x | .Undef e1. f. = e2 . modify e1 f e2 To allocate \nfunctions, JSExec de.nes mkFun as follows: let mkFun (s:string) (code:dyn .dyn .dyn .dyn)= let o = alloc \n() in let f = Fun o (code o)in o.\"@code\". = f;o.\"@toString\". = Str s;o.\"prototype\". = ...; ...; f For \ninstance, we formally translate function (x){ return x;} to mkFun \"function(x). . .\" (fun o this args \n.select o args \"0\") where the .rst argument is a string literal that represents the source text of the \nfunction and the second argument is a js. closure that receives three objects: the (soon-to-be-created) \nfunction object o, the this parameter, and the actual arguments. The call to mkFun allocates o, partially \napplies the closure to o, and sets various properties on o before returning f. To call functions, JSExec \nprovides apply, which receives four arguments: caller, the object of the calling function; callee, the \nfunction to be called; a this pointer; and an args object. let apply (caller:dyn) (callee:dyn) (this:dyn) \n(args:dyn) : dyn = match callee with | (Fun o f). let caller0 = o.\"caller\". in let args0 = o.\"arguments\". \nin try o.\"caller\". = caller.\"@code\".;o.\"arguments\". = args; args.\"callee\". = callee;f this args with \nBreak .error | e .raise e .nally (o.\"caller\". = caller0;o.\"arguments\". = args0) | ... Following the code, \napply calls f with argument this and args. First, however, it saves the callee s caller and arguments \n.elds, sets these .elds for the current call, and sets a pointer from args to callee. Conversely, once \nthe call returns, apply restores the callee s .elds to their old value. (The derived f. form try ... \nwith ... .nally, detailed below, ensures that the .elds are restored even if the call raises an exception.) \nExperimentally, this re.ects major browser implementations of JavaScript. Property access In JavaScript, \nproperties of objects are looked up .rst in the object s own property map, then in the object s prototype \n(stored in a special property @proto ), walking the prototype chain as needed. Once found, if the property \nhappens to be a getter, then the getter function is called, otherwise its value is returned. This is \nimplemented by the select function, shown below. Since calling the getter requires passing a caller object, \nwe write select caller l f to select .eld f from object l in the context of the function object caller. \n(Recall that the translation of our example function included a call to select passing its object o as \na parameter.) let rec getProperty (l:dyn) (f:string)= match lookup l f with | Some p .Some p | None .match \nlookup l \"@proto\" with | Some (Data l ) .getProperty l f | None .None let select (caller:dyn) (l:dyn) \n(f:string): dyn = match getProperty l f with | Some(Accessor (g, )) .apply caller g l (mkEmptyArgs()) \n| Some(Data d).d | .Undef A similar function, update caller l f v, sets property f on object l to value \nv. This function traverses the prototype chain looking for a setter for property f. If a setter is found, \nupdate calls it with caller and v; otherwise it calls modify l f v. Exceptions and control operators \nWe model exceptions and the other imperative control operators of JavaScript using f. excep\u00adtions. JavaScript \nhas a return statement to end the current call, and a break l statement to return control to the code \nlocation la\u00adbeled l, which must be de.ned within the same function body. .JS desugars both to a single \nform, which we represent as the excep\u00adtion Break l v. Additionally, we use exceptions Exn v for JavaScript \nexceptions, and Return v to encode .nally clauses, as follows.  try e1 with e2 .nally e3 try (try e1 \nwith e2).nally e3 try e1 .nally e2 try raise (Return e1) with y. match y with | Return r .e2;r | .e2;raise \ny Dynamic evaluation JSExec does not support eval, as this would involve parsing, translating, and loading \njs. code at run time. On the other hand, js. contexts can implement any primitive function eval using \nthe datatypes of JSExec, together with any values they obtain by interacting with our wrapped translation. \nAs such, our full-abstraction result applies also to contexts that use eval. Typability We conclude this \nsection with a simple result: every .JS program translated to js. is well-typed against JSExec. In the \nstatement below, [e] is the translation of a .JS expression to js. . Theorem 2 (Typability of .JS translation). \nFor all .JS programs e with free variables x, we have JSExec;x:dyn . [e] :dyn. Contextual equivalence \nin JavaScript (discussion) After transla\u00adtion to js., we formally compare JavaScript programs using the \ncontextual equivalence of \u00a73 (De.nition 1). This equivalence re\u00adlies on the observation of fatal errors, \nwhich are not primitive in JavaScript, but informally account for any code with an immediate observable \neffect, such as alert(\"error\") or window.location = \"http://error.com\". This equivalence in js. is also \na priori .ner than JavaScript equivalence, inasmuch as it quanti.es over all well\u00adtyped js. contexts, \nnot just those obtained by translating JavaScript contexts. Thus, we err on the safe side: most of our \nresults would apply unchanged for variants and extensions of JSExec (as long as its signature is unchanged), \nfor instance, to model additional features of JavaScript implementations. Conversely, \u00a78 shows that translations \nof JavaScript contexts are complete at least for inter\u00adacting with wrapped translated f. programs. 6. \nA type-preserving simulation from f. to js. Formally, our compiler can be viewed as the translation from \nf. to JavaScript (\u00a74) composed with the embedding of JavaScript into js. (\u00a75). In this light, its correctness \nis far from obvious. For example, even though super.cially we translate f. functions to JavaScript functions, \nseveral corner cases of their semantics lurk beneath the surface syntax. As we have seen, functional \nvalues translate to expressions that allocate several objects, and are subject to a calling convention \nwith side-effects. This section proves several safety properties for the f.-to-js. compiler. In order \nto carry out these proofs, we use an alternative, monadic type system for f. due to Schlesinger and Swamy \n(2012), as well as an application of this type system to JavaScript provided by Swamy et al. (2012). \nSpeci.cally, we use JSVerify, a variant of JSExec with monadically re.ned types that allows us to state \nand prove precise typing and heap invariants of js. programs. Using this machinery, we prove that the \nlight translation preserves types and is a (weak) forward simulation. Additionally, we prove that the \ndefensive wrappers successfully maintain several key invariants, including separating un objects from \nthe others. While useful in their own right for whole programs (e.g., we can prove that when a source \nf. program has no assertion failures, then neither does its translation), these properties serve primarily \nas lemmas that facilitate the main results of \u00a78. Monadic f. The type system of monadic f. is based on \na monad of predicate transformers called the Dijkstra state monad. The type of this monad is written \nDST t wp, and stands for stateful com\u00adputations yielding a t result and with speci.cation described by \nthe weakest pre-condition predicate transformer wp. The trans\u00adformer wp takes a post-condition formula \npost, relating a result of type t and a .nal heap, and returns a pre-condition formula pre, a predicate \non an initial heap. Given a program e :DST t wp and a particular post-condition post to be proven, the \nf. type checker Syntax of types in monadic f. t ::= T | a | t t | x:t{.} | .a::..t | x:t . t | x:t . \nDST t . types . ::= . | . | ... | ... | \u00ac . | . =. .' | .x:t.. | .x:t.. formulas | P| .x:t.. | .a::... \n| . u | . . . ::= . | E| x:t . . | a::. . . kinds u ::= v | t | V v | E v | err | Sel u u | Upd u u u \n| u1+ u2. . . logic term builds a veri.cation condition wp post and uses Z3, an SMT solver (de Moura \nand Bj\u00f8rner 2008), to try to discharge the proof. We give the syntax of monadic f. types above. As in \n\u00a73, the type language is parameterized by a signature Sthat also de.nes a set of type constructors T. \nTypes include variables a, type applica\u00adtions t t ', re.nement types x:t{.}, and polymorphic types .a::..t. \nData constructors are n-ary and are given pure dependent func\u00adtion types .a::..x:t . t '. General function \ntypes have the form x:t . DST t ' ., with a monadic co-domain dependent on the cur\u00adried arguments x:t. \nFormulas . include the usual connectives (implication is writ\u00adten =. , distinguishing it from the kind \nconstructor . discussed below). Predicates P may be interpreted (e.g. equality), although uninterpreted \npredicates can be introduced by the signature S. For\u00admulas also include a strongly normalizing applicative \nlanguage of functions over logical terms and other predicates. We write .x:t.. and .a::... for predicate \nliterals or, in the latter case, for trans\u00adformers from a predicate (or type) a of kind . to .. Formulas \ncan be applied to other formulas or to logical terms u. The type system is parametric in the logic used \nto interpret for\u00admulas. By default, we use a .rst-order logic with uninterpreted functions and theories \nof functional arrays, arithmetic, datatypes, and equality. For example, we use type heap and interpreted \nfunc\u00adtions Sel:heap .ref a.a and Upd:heap .ref a.a.heap from the select/update theory of functional arrays \n(McCarthy 1962) to model the store. Logic terms also include three kinds of result con\u00adstructors: V vis \na result value; E vis an exceptional result; and err is the error value. We de.ne asResult v V v,asResult \n(raise v) E v, and asResult error E. Additionally, we write Result r . as an ab\u00adbreviation asserting \nthat .x is valid when r = V x. We have two base kinds: . is the kind given to value types, while Eis \nthe kind of types that stand for erasable speci.cations, with the sub-kinding relation . = E. We include \ndependent function kinds, both from types to kinds, and from kinds to kinds. In most cases, unless we \nfeel it adds clarity, we omit writing kinds. The main judgments in the monadic type system are S;G .Dv:t \nfor values and S;G .D e : DST t . for expressions. They rely on an auxiliary judgment, S;G |= ., stating \nthat formula . is deriv\u00adable from the logical re.nements of context G. For example, we can type the program \n.x:ref int.x :=!x+ 1as x:ref int . DST unit .post..h:heap.post (V ()) (Upd h x ((Sel h x) + 1)). This \nis the type of a function from integer references x to unit, where the weakest pre-condition for any \npredicate post relating a unit result to the out\u00adput heap is the formula post (V ()) (Upd h ((Sel h x) \n+ 1)), indicating that the function always returns normally with () and updates the input heap h with \nthe contents of location x incremented. The judgments for typing terms extend naturally to a judgment \non runtime states, written S;G .D H|e : DST t .. The soundness theorem for monadic f. is a re.nement \nof Theorem 1; it also applies to open reductions. In its statement below, we rely on a function asH ea \np that interprets a store Has a Sel/Upd value of type heap. Theorem 3 (Monadic soundness). Given S, G, \nH, e, t, . such that S;G .D H|e : DST t ., and a post-condition . such that S;G |= . . (asH ea p H ) \nis derivable; either: (1) e is a result and S;G |= . (asResult e) (asH ea p H ); (2) e is an open redex; \nor ' ' (3) there exist H' , e ,.', such that H |e .S H' |e ', S;G .D H' |e : DST t.' and S;G |= .' . \n(asH ea p H ' ).  We sometimes use a monad iDST, an abbreviation for the DST monad augmented with a \nheap invariant: iDST t wp is the type of a computation that, when run with an input heap h satisfying \nHeapInv h . wp post h, diverges or produces an output heap h and result r:t satisfying HeapInv h . DeltaHeap \nh h . post r h . We de\u00adscribe the heap invariants enforced by iDST below, referring to our online material \nfor the full de.nitions. JSVerify: a precise typed model of JSExec We now present a few key elements \nin JSVerify, an interface for JSExec written using the precise types of monadic f.. We start by showing \nhow we recover the precision of the source type system by re.ning the type dyn introduced in \u00a75. A central \nfeature of this re.nement is JSVerify s model of a partitioned js. heap. We conclude this subsection \nwith a lemma relating JSExec to JSVerify. Dynamic typing We structure our formal development by trans\u00adlating \nthe types of f. into logical formulas. Speci.cally, we use a re.nement of type dynamic developed by Swamy \net al. (2012) to embed the simple type language of f. within the re.nement logic of monadic f.. For example, \nrather than typing Str \"Rome\" simply as dyn, we type it as x:dyn{TypeOf x = string}, where TypeOf is \nan uninterpreted function from values to E-kinded types. We show a few cases in the de.nition of type \ndyn used in JSVerify below. The full listing of JSVerify is available online. type dyn = . . . | Str:string \n.d:dyn{TypeOf d=string} | Obj:l:loc .d:dyn{TypeOf d=TypeOf l} | Fun:.wp. o:dyn{. l. o=Obj l . . . .} \n . (this:dyn .args:dyn .iDST dyn (wp o args this)) . d:dyn{TypeOf d=WP wp}  As in JSExec, an object \nis a value Obj l, for some heap reference l:loc. In addition, the re.nement on the Obj constructor recalls \nthe re.nement on the underlying loc. The Fun constructor takes two value arguments, an object o and a \nfunction closure, as before. In addition, it now takes a speci.cational argument: a predicate transformer \nwp for the function closure. The re.nement on the argument o requires it to be an object (in addition \nto some other properties, which we elide from this presentation). The function closure is itself typed \nwithin the iDST monad with weakest pre\u00adcondition wp. The type of Fun recalls the predicate transformer \nof the closure in its result type, i.e., TypeOf d=WP wp where WP is a type-level coercion from the kind \nof wp to E. Invariants of a partitioned heap Our proof strategy involves en\u00adriching the type of heap \nreferences to keep track of a logical parti\u00adtion of the js. heap into .ve compartments. This partition \nallows us to prove several invariants, e.g., that there are no references from objects in the attacker-controlled \npart of the heap to elsewhere. These .ve heap compartments are as follows: Inv: the invariant heap Let-bound \nvariables, arguments and data are immutable in f. but are held in heap locations in js.. To keep track \nof these locations, we place them in a logical compartment called the Inv heap. A complication that we \nhandle is that these locations are not strictly immutable JavaScript forces us to pre\u00adallocate locals, \nrequiring a mutation after allocation, and the calling convention also involves implicit effects. Still, \nwe prove that, once set, all the relevant .elds of objects in the Inv heap never change. Ref: the heap \nof source references Locations used to represent the translation of f. values of type ref t are placed \nin the Ref heap, where an invariant ensures that the content of a Ref heap cell, once initialized, always \nholds a translation of a t-typed source value. Abs: the abstract heap of function objects Recall that \nevery func\u00adtion in js. is associated with a heap-allocated object whose contents is updated at every \nfunction call. We place these unstable locations in the Abs heap, and ensure that translated source programs \nnever read or write from these locations, i.e., function objects are abstract. Un: the untrusted heap \nThis heap compartment is used to model locations under control of the attacker. Our full-abstraction \nresult relies crucially on a strict heap separation to ensure that locations from the other compartments \nnever leak into the Un heap (with one exception, discussed next). Stub: the heap of declassi.ed function \nobjects Function objects corresponding to stubs in the upfun wrapper are allocated in a com\u00adpartment \nof their own. These objects initially belong to the f. trans\u00adlation, but, once used, they become accessible \nfrom the Un heap. To this end, we implement (and type) a logical declassi.cation proto\u00adcol, allowing \nus to prove that, as their ownership is transferred to the attacker, stub objects do not leak any information. \nTo keep track of these heap compartments, JSVerify enriches the representation of heap allocated objects \nwith (ghost) metadata, outlined below. We have a tag for each compartment. The type tobj, which is a \nwrapper around the type obj, associates it with its tag and a predicate p, an invariant on the contents \nof the object. type tag = Inv:tag | Ref:tag | Abs:tag | Un:tag | Stub:tag type tobj = TO:.p::obj . E. \nt:tag .o:obj{(t=Ref =. \"ref\" . dom o . p o) . t =Inv =. . . .} .v:tobj{TypeOf v=PT p t}type loc = TL:.p::obj \n. E. t:tag .ref (v:tobj{TypeOf v=PT p t}) .v:loc{TypeOf v=PT p t} Values of type tobj are triples TO \np t o. Its third component o is typed as an obj (that is, a map from strings to properties) re.ned with \na formula stating, for example, that if the object is in the Ref heap, then it contains the \"ref\" .eld, \nand that it satis.es the invariant p. A similar, but more complex invariant applies to objects in the \nInv compartment (due to object initialization and implicit effects). The result type of TO records both \nthe invariant p and the tag of the object in the re.nement. The type loc is also a triple, TL p t r, \nwhere r is a reference to a tagged object. We memoize the tag and invariant of the content of r with \nthe reference itself, and the type of TL ensures that the tags of the content and the loc agree. Translation \nof types A source type t in f. is translated to the re.ned js. type [[t]] d:dyn{.t d} where .t is a predicate \non dyn\u00adtyped js. values. We show a few cases below, where SelObj selects an object from the heap, and \nSelProp selects a property. .string = .d.TypeOf d=string = .d.TypeOf d=PT (.o. .t (SelProp o \"ref\")) \nRef .ref t .t.t ' = .d.TypeOf d=WP . a ..p..h..t (SelProp(SelObj h a)\"0\") .. . . . .r h . Result r .t \n' =. p r h The translation for primitive types like string is simple: the re.nement formula .string requires \nthe translated value to be a Str :dyn. The translation of ref t requires an object in the Ref heap, whose \n\"ref\" .eld satis.es predicate .t. The translation of function types .t.t' requires the compiled value \nto be a Fun wp term, where (among other requirements) the predicate transformer wp requires its zeroth \nargument to satisfy .t, and requires proving the post-condition on a result r that satis.es .t' (if it \nis a value). Interface of JSVerify To enforce our invariants, JSVerify exposes a monadic version of the \nJSExec interface. To operate on un values, for instance, it provides aliases to the functions select, \nupdate, and apply of \u00a75. An un value is either a primitive value, or an object (or function) allocated \nin the Un heap, or a declassi.ed Stub object. The function selectUn allows a (non-internal) .eld to be \nselected from an un object. Its pre-condition requires both the caller and the object o to be un-values, \nand requires the post-condition p to be proven for any IsUn result and heap (since, via getters, selecting \na .eld can trigger arbitrary code). The speci.cation for updating an un object is similar. Calling an \nun function requires that the caller be an un value, both this and args be un, and ensures that the result \nis also un. In all cases, the use of the iDST monad requires and ensures the heap invariant as well. \n type IsUn x = TypeOf x=string .. . . . GetTag x = Un . (GetTag x = Stub . Declassi.ed x) type un = \nx:dyn{IsUn x}val selectUn:caller:dyn{GetTag caller = Un} .o:un .f:string{\u00ac IsInternalField f} .iDST dyn \n(.p..h. .r h . Result r IsUn =. p r h ) val updateUn:caller:dyn{GetTag caller = Un}.o:un .f:string{\u00ac \nIsInternalField f} .v:un .iDST dyn (.p..h. .r h . Result r IsUn =. p r h ) val applyUnUn:caller:un .callee:dyn{GetTag \ncallee = Un} . this:un .args:un{GetTag args = Un} . iDST dyn (.p..h. .r h . Result r IsUn =. p r h ) \n Accessing the other heaps imposes stricter requirements but also provides more guarantees. Relating \nJSExec and JSVerify To relate our two interfaces, we prove a lemma that shows that any js. program well-typed \nagainst JSExec is also well-typed against JSVerify, as long as it interacts only with the Un-fragment \nof JSVerify. To state this lemma, and in the rest of the paper, we use the following syntactic shorthands: \nWe write S;G .D e : t for a computation with a trivial pre\u00adcondition returning a t-result, i.e., S;G \n.De:iDST t wp., where S;G |= .h.HeapInv h=. wp.(. h .HeapInv h .DeltaHeap h h )h. S;G .DH|e:tstands for \nS;G .DH|e:iDST t wp, where S;G |= wp (. h .HeapInv h . DeltaHeap h h ) h and h = asH ea p H . GD is \nthe lifting of function types in the context G, where a type t .t is lifted to x:t .iDST t wp.. When \nit is clear from the context, we write types like t .t , leaving the lifting implicit.  tagUn(H|e) is \nthe runtime state obtained by adding Un-tags to each object and loc-typed constant in H|e.  Lemma 2 \n(Universal monadic typability of js.). If JSExec;G . H|e:t, then JSVerify;GD .D tagUn(H|e) :t Henceforth, \nwe write G .D H|e :t for monadic typing, leaving the signature of JSVerify in the context implicit. Formal \nlight translation of f. runtime states We now formalize ' the light translation as a relation G .f H|e \n:t I H' |e for the translation of the f. runtime con.guration H|e of type t into a js. ' con.guration \nI,H' |e ', where His the Ref compartment and I consists of both the Inv and Abs compartments. The subscript \nf is a js. value, representing the object of the function that encloses e; it is Null at the top-level. \nFigure 5 gives .ve representative translation rules, simplifying them by eliding type arguments. The \nrules are to be interpreted as inlining the de.nitions from JSVerify into the translated term, rather \nthan leaving them as free variables. The .rst rule translates a data constructor to an object literal, \nwhich in JSVerify is represented as an Inv location that is allocated and immediately initialized with \nthe contents of the constructor. This is particularly important the alternative of allocating an ob\u00adject \n.rst, and then setting its .elds is not secure, since, in general, this could cause a traversal of the \nprototype chain, triggering at\u00adtacker code in case the attacker has installed a setter on the publicly \navailable Object.prototype. In contrast, the allocation of an object literal never causes a prototype \ntraversal. The second rule translates a let-or .-bound source variable x to a js. expression that selects \nfrom the \"0\" .eld of an object stored in the Inv heap, whose location is bound to a js. variable of the \nsame name. The invariant guarantees that the \"0\" .eld is set in the immediate object, again preventing \nany prototype traversal. .i.G .f vi :ti I ei G .f Dt\u00af.T v\u00af:T I mkInv [(\"tag\",Str (str D)));(str i,ei)] \n G(x) = t G .f x :t I selectInv f x \"0\" G,x:tx .o e :t I e ' xi :ti = locals(e) src any string constant \nG .f .x:tx.e:tx . t I mkFunAbs src .o x.let xi = mkLocInv() in e ' G .f e :t ' . t I e ' G .f v :t ' \nI v ' G .f e v :t I applyAnyAbs f e ' lglobal (mkInv (TO Inv [(\"0\",v )])) vl = Obj (TL Inv l) G .f v \n:t I v ' I(l) = TO Inv [(\"0\",v ')] G .f v :t I selectInv ft f vl \"0\" Figure 5. Light translation from \nf. to js. (selected rules) The third rule translates a closure. Function objects in the light translation \nare always allocated in the Abs heap. So, we use an alias of JSExec.mkFun from JSVerify called mkFunAbs, \nwhich builds the function object. We translate the body of the function using the variable o as the caller \nobject, passed as an argument to applyAbs (an alias of JSExec.apply for calling an Abs function) at every \ncall\u00adsite in the body of e, as shown in the next rule. Again, the arguments are passed as an object literal. \nThe last rule is useful primarily for translating runtime expres\u00adsions, rather than source values. f. \nhas an applicative semantics with a standard \u00df-reduction rule. However, in js., values are passed as \npointers to the Inv (or sometimes Abs) heap. Without this last rule, this mismatch would cause considerable \ntechnical dif.culties in our forward simulation proof. For example, in f. we may have (.x.(x,x)) D.S \n(D,D) for some constructor D. When translating the left-hand side, we may allocate only one Din js., \nwhereas, the translation of the right-hand side would allocate two objects. To re\u00ad.ect both possibilities, \nthe light translation is a non-deterministic relation on runtime states, indexed by the js. heap I, representing \npre-allocated data. So, in the last rule, if we .nd a location l in the I heap which already contains \na value that is a valid translation of the source value v, then, rather than allocate a fresh location, \nwe may simply translate vto the expression that selects from l. As such, our translation relation conveniently \nhides the details of data allocation and aliasing our typed invariant and \u00a78 show that those details \nare not observable anyway. Correctness of the light translation We present our main results for the light \ntranslation, .rst stating that it preserves the typing and heap invariants, then that it is a forward \nsimulation: every f. reduction is matched by one or more js. reductions. Type preservation states that \nif an f. state H|e well-typed at t is translated to a js. state H' |e ' (with Inv and Abs heaps I), then \nthe js. state is well-typed in the iDST monad against JSVerify. The lemma ensures that when h0 (the logical \nvalue corresponding to Iand H') satis.es the heap invariant, the js. state diverges, or produces a result \nr and post-heap h1, where h1 satis.es the heap invariant and DeltaHeap h0 h1; and that Result r .t is \nvalid. As a base case, the heap invariant on the empty heap (produced when translating a source program, \nrather than an intermediate runtime con.guration) is trivially satis.ed. A technical requirement, due \nto JavaScript s hoisting of local variables, is that all the let-bound variables of the translated term \nalready exist in the heap I. ' Lemma 3 (Type preservation). If G .f H|e :t I H' |e then, ' ' for G' = \n[[G]],Glocals(e), there exists . such that G' .D H,I|e : iDST dyn . and, for h0 = asH ea p (I,H' ), if \nHeapInv h0 and LocalsOK locals(e) h0, then G' |= . (.x h1. HeapInv h1 . DeltaHeap h0 h1 . Result x .t)h0 \n Our next lemma ensures that the formal light translation is a forward simulation. That is, every reduction \nstep of an f. program H|eis matched by one or more reductions of its js. translation. We use an auxiliary \nfunction Abs I , standing for the set of objects that may be used as the caller object in js.: Abs I \n= {Null} . {Obj l | l . dom(I) . GetTag l = Abs} Lemma 4 (Forward simulation). For any source reduction \nstep H|e .S H1|e1 and any translation G .f H|e I H' |e ', where ' f . Abs I, there exist reduction steps \nI ,H' |e ' .S+ I,I' , H1 ' |e1, and ' H' a translation G .g H1|e1 I,I' 1|e1, where g . Abs (I,I' ). Defensive \nwrappers We now consider the properties of the second phase of our compiler, i.e., the defensive wrappers. \nFigure 6 lists the js. code of downfun and upfun it is instructive to compare with the JavaScript wrappers \nshown in Figure 4. This code is typed against JSVerify, making use of the heap-partition-aware variants \nof functions in JSExec. This allows us to record the code positions that may trigger callbacks to untrusted \ncode (which leaks the caller s object to the context). Speci.cally, we use the following variants of \nmkFun, apply, select, and update. abs-functions reside in the Abs heap and are created by mkFunAbs. \nThey may be called with any caller using applyAnyAbs.  un-functions are created by mkFunUn with an object \no:un. They are called using applyUnUn, that is, only by callers with an un object (since this object \nis possibly leaked to the callee) and un arguments. Similarly, Un objects are selected using selectUn, \npossibly triggering a callback to the context (due to a getter).  stub-functions speci.cally support \nour upfun wrapper. They are created by mkFunStub with an object in the Stub compart\u00adment. They can be \ncalled at most once by any caller using applyAnyStub, after which they are declassi.ed and released to \nthe context. Prior to the declassi.cation, stub objects are safe they can be updated without triggering \ncallbacks.  Local variables and data constructors are allocated in the Inv heap using mkLocalInv and \nmkInv, respectively. These local variables may be set at most once, using setInv, then selected many \ntimes using selectInv. These calls never trigger callbacks.  Mutable references are allocated using \nmkRef, and accessed us\u00ading selectRef and updateRef. Locations in the Ref compartment are always well-typed, \nand the accesses never trigger callbacks.  For a given source type t, .t is an abs-function that takes \nvalues of type [[t]] and returns values of type un. Conversely, . t is an un-function that takes values \nof type un and (attempts to) return a value of type [[t]]. To facilitate proofs of these typing properties, \nwe instrument the js. wrappers with calls to JSVerify, rather than JSExec, as already noted. Additionally, \nwe require two veri.cation hints in the code of upfun. First, we add a call to a ghost function declassify, \nwhich is used to record in the re.nement logic that the stub object has been released to the attacker \nand should henceforth be typed as un. A pre-condition of declassify u callee is that the all the .elds \nof callee must already by typeable as un. Hence, we clear the contents of its \"caller\" and \"arguments\" \n.elds. However, the callee object also has an internal .eld called \"@code\" containing a reference to \nthe function closure itself, which the adversary can use to call the stub directly, once it has access \nto the stub function object (e.g., by using Function.prototype.apply). JavaScript provides no way to \nclear the \"@code\" .eld directly. To handle this case, we carefully ensure that, after declassi.cation, \nthe function closure can be typed as a function from un to un. Thus, the stub returns its result via \na side-effect to the reference by. Typing this idiom requires one level of indirection: we initialize \nthe reference by to None and, each time the stub is called and successfully imports the translation of \nlet downfun = mkFunAbs \"downfun\" (fun (apair:inv). mkFunAbs \"downfun_a2b\" (fun (af:inv). mkFunUn \"downfun_f\" \n(fun (u:un) ( :un) (az:un). let up a = selectInv u apair \"0\" in let z = selectUn u az \"0\" in let x = \napplyUnUn u up a global (mkArgUn z)in let f = selectInv u af \"0\" in let y = applyAnyAbs u f global (mkArgInv \nx)in let down b = selectInv u apair \"1\" in applyAnyAbs u down b global (mkArgInv y)))) let upfun = mkFunAbs \n\"upfun\" (fun (apair:inv). mkFunUn \"upfun_a2b\" (fun (af:un). mkFunAbs \"upfun_f\" (fun (o:abs) (ax:inv). \nlet az = mkLocalInv() in let by = mkRef (mkInv [(\"tag\", Str \"None\")]) in let down a = selectInv apair \n\"0\" in let x = selectInv o ax \"0\" in setInv o az \"0\" (applyAnyAbs o down a global (mkArgInv x)); let \nstub = mkFunStub \"stub\" (fun (u:stub) ( :un) (a0:stub). let callee = selectStub u a0 \"callee\" in updateStub \nu callee \"caller\" Undef; updateStub u callee \"arguments\" Undef; declassify u callee;(* ghost *) let f \n= selectUn u af \"0\" in let z = selectInv u az \"0\" in let y = applyUnUn u f global (mkArgUn(z)) in let \nup b = selectInv u apair \"1\" in let b = applyUnUn u up b global (mkArgUn y)in let someb = mkInv [(\"tag\", \nStr \"Some\"); (\"0\", b)] in updateRef u by \"ref\" someb) applyAnyStub o stub global (allocStub()); selectInv \no (selectRef o by \"ref\")\"0\"))) Figure 6. Function wrappers in js. (omitting most types) a source value \nv:b, it updates by with the translation of Some v. (In Figure 4, we collapse the option reference into \na single mutable location, which is a simple semantics preserving transformation.) Equipped with these \ntypes, we show that a down-wrapped light translation has type un. Likewise, we show that, if an up-wrapped \nun value returns normally, then it returns a value typed as the translation of its source type. In the \nlemma statement, we write .t e for the application of a down wrapper to e, i.e., applyAnyAbs ( : abs) \n.t ( :un) e; and .t e is applyUnUn ( :un) .t ( :un) e. In conjunction with Lemma 2, this shows that a \nwrapped term can be safely embedded in any JavaScript context. Lemma 5 (Typing of wrapped terms). If \nG .D v:[[t]] then G .D.t v:un; if G .D v:un then G .D.t v:[[t]]. 7. Contextual equivalence by bisimulation \nin f. Contextual equivalence is a precise and intuitive notion of equiva\u00adlence, both in JavaScript and \nin f., but it leads to complicated direct proofs, as one needs to reason about any reduction in any context. \nTo structure our full-abstraction proof, and to analyze interactions between translations of equivalent \nf. expressions and their js. con\u00adtexts, we develop a custom labeled bisimulation proof technique. Although \nformally independent of JavaScript, the design of our bisimulation is guided by its application to source \nf. and js. in \u00a78: Our bisimulation must support f. types, higher order functions, mutable state, exceptions, \ndivergence, and errors.  Functions exported using down wrappers may share private state, so we need \nto jointly relate con.gurations of functions, rather than single functions. (See also Sumii and Pierce \n2005.)  Our wrappers stop at imported and exported functions; thus, to extend wrapping from terms to \ncon.gurations and maintain wrapping as a transition invariant, we use a variant of normal   form bisimulation \n(Lassen 2005): our con.gurations have free variables standing for the functions imported from the context; \nthus, anycallback yields atransition output with acontinuation. Next, we de.ne these bisimulation con.gurations \nand we study their behavior, .rst using concrete context closures, then more abstract labeled transitions. \nThe main result of the section is that labeled bisimilarity coincides with contextual equivalence. We \nuse interfaces to specify how con.gurations may interact with their context. An interface declares some \nexported functions (previously sent to the context), some imported functions (previ\u00adously received from \nthe context), some continuations (for ongoing calls to the context), and some memory (shared with the \ncontext). De.nition 6 (Interface). An interface I = s;G consists of heap types s (for the heap shared \nwith the context) and a type environ\u00adment G that binds variables to function types t,eachannotated with \none of three sorts: z :z t for functions imported from the context;  x :x t for functions exported \nto the context; and  k:k t for continuations of calls to the context.  We let Gz be the projection \nof G on imported functions, and simi\u00adlarly for Gx and Gk. We often elide these annotations, writing for \ninstance y:t . G for any binding of G. When y. dom(G), we write G|yfor the pre.x of G suchthat G is of \nthe form G|y,y:t,G' . Our con.gurations represent pairs of related f. runtime states, both waiting for \ntheir next interaction with the context. We intro\u00adduce notations for pairs of related terms in con.gurations: \nfor any phrase of syntax M, we write M for pairs of Ms, and write MV and Mr for their left and right \nprojections, respectively. Further, we treat propositions f with pairs Mn as f{MVi/Mi} .f{Mri/Mi}. i=1 \nIn this section and \u00a78, we omit the inductive signature S in typing judgments, and write ; instead of \n, to separate references from functions in typing environments. De.nition 7(Con.guration). Given an interface \nI = s;G,awell\u00adformed con.guration C = I|. (written I . C )consists of two heaps I such that s;Gz . I \nand two substitutions . from every y:t . Gx . Gk to values v suchthat s,s(I);(G|y)z . v:t. In the de.nition, \nIis a pair of private heaps, with IV and Ir hav\u00ading possibly different domains, both disjoint from s. \n(The typing judgments imply dom(s) n dom(s(I)) = /0.) The substitutions . map every variable in Gx . \nGk to functions; in particular, continu\u00adations are just functions. The environment (G|y)z let us type \nthem with free variables standing for previously-imported functions. Next, we lift the contextual equivalence \nof \u00a73 from terms to con.gurations, relying on generalized contexts and context closure: De.nition 8 (Con.guration \nContext). Given an interface s;G, a well-formed evaluation context E = O|Z, e:t consists of a heap Osuchthat \ns . s(O) and s(O);Gx . O;  a substitution Z from every z:t . Gz to a value v such that s(O);(G|z)x . \nv:t  a call-stack: a typed expression e:t de.ned byinduction on Gk: when Gk = 0/, the stackis any e \nsuchthat s(O);Gx . e:t; when Gk = k:t1 . t2,G' , the stackis any E[ke1] suchthat  k s(O);(G|k)x,y:t2 \n. E[y] :t and e1 :t1 is a stackfor G' k. De.nition 9 (Context Closure). Given a context O|Z, e : t and \na con.guration I|. with the same interface and disjoint heaps (dom(O) n dom(I) = 0/), we let E [C ] (O,I| \ne){.,Z} be the two runtime states obtained by composing the context with both sides of the con.guration \nand jointly applying the substitutions . and Z in the order recorded in G (substituting .rst the latest \nvariables). These runtime states are closed and well-typed: . E [C ] :t De.nition 10 (Contextual equivalence \nfor Con.gurations). E {I . C suchthat .E , E [C ]V e E [C ]r} Our de.nition generalizes plain contextual \nequivalences: for in\u00adstance, contextual equivalence e on functions of type t coincides with E on con.gurations \nwith signature /0;x :x t. More gener\u00adally,we can reduce contextual equivalence of twoopen expressions \nxi :ti . e:t to the function-value equivalence of . .xi.e :ti . t. Labeled bisimulations To keep the \ncontext implicit, we de.ne interactions between the con.guration and its context as labeled a ;\u00df ' transitions \nof the form I . C - -. I ' . C where a and \u00df range over input and output labels, respectively. The input \nlabel (e.g., a function call with parameters, or returning a result to a previous call) is provided by \nthe context to the con.guration, and the output label is its response (e.g., a returned value or a callback). \nThe transition occurs only if both terms in the con.guration C have matching behaviors (e.g., both return \nthe same result, call the same callback, etc). Thus, the transition relation characterizes pairs of f. \nruntime states that have similar interactions with their context. De.nition 11 (Input Label). Given an \ninterface s;G,an input label a = G' O|yr consists of z a signature G' disjoint from G; z a heap Osuchthat \ns . s(O) and s(O);Gx,G' . O; z a value parameter v suchthat s(O);G' . v:t; z a query q= yr, of one of \nthe three forms below: xr, a call to any x :t . t ' . Gx;or kv, a return with Gk = Gk ' ,k:t . t ' ;or \nk(raise v), an exception with Gk = G' k,k:t ' and t = te. suchthat, moreover, the values within Oand \nv with a function type are pairwise distinct variables in G' . z Intuitively, an input label represents \na minimal, open context that calls a function previously exported by the con.guration, or returns from \na previous call from the con.guration to the context; Orepresents some shared heap, and G' some fresh \nvariables stand\u00ad z ing for any function imported by this input from the context. In combination, we obtain \na pair of well-typed (open) runtime states Gz,G' . O, I | y.v applying the function associated with y \nin . z to v. In the last two forms of query, the condition on Gk ensures that the context returns only \nat the top of the stack (with a value or an exception). The .nal condition ensures that no function values \nare passed directly to the con.guration. In particular, the context cannot directly pass a function x \npreviously received from the con\u00ad.guration. Instead, the context can pass a fresh variable z, and can \nlater call x whenever z is called back. De.nition 12 (Output Label). Given an interface s;G and an input \nlabel G' O|yr :t, an output label is one of the following: z error for failure; . for divergence; G'' \n' O' | v for normal returns, suchthat G'' . O' | v ' :t; x x G'' ' O' | raise v for exceptions, suchthat \nG'' . O' | v ' :te;or x x G'' O' ' : t '' . O' ' : t ' | z v for callbacks, such that G'' | v and x x \nz:t ' . t '' . G' . z In the last three cases, we require that G'' and G' be disjoint; that x O' extend \nOwith the locations reachable from v' and O; and that all values within O' and v' with function types \nbe distinct variables de.ning the domain of G'' . x For convenience, to deal with both kinds of inputs, \nwe write G \\k y for G when y:x . G and for G \\ ywhen Gk = Gk ' ,y: . We ,G'' also let G+ abbreviate G \n\\z y,G' in the interface after the output. z x  ' As with input labels, we require that v in output \nresults do not contain names from Gx,Gz. In combination, compatible inputs and outputs de.ne transitions \nbetween interfaces. Transitions between con.gurations (de.ned shortly) can be seen as their re.nement, \nof the form G' O|qv:t ;G'' O' |z v ' :t '' z x ' s;G . C - ------------. s(O ' );G+ . C Aplain labeled \nsimulation on pair of terms would require that, for every transition on one side, there exists a matching \ntransition on the other side. In our case, since con.gurations already account for both sides, we de.ne \ntransitions as a partial relation between con.gurations: we have a transition only when both sides perform \nmatching outputs. For uniformity, we use two additional terminal con.gurations, error and ., with no \ninput, to represent the outcome of transitions that lead to failure and divergence, respectively. For \na given con.guration I . C , the additional locations in O in the input label may clash with the private \nlocations of I; our transitions implicitly assume that this is not the case, as we can always pick another \ninput label with fresh names, and that the output label is well-formed. De.nition 13 (Transition). Given \ninterface s;G and input label a = G' O|yr :t, con.guration transitions are (partially) de.ned z below, \nwith one rule for eachform of output: O.b,Ib|y.bv . error for b= V, r O.b, Ib|y.bv . for b= V, r s;G \n. I| . a ;error -----. error s;G . I| . a;. - -.. ' * O'.' O.b,Ib|y.bv .S b,I. b|r '.b for b= V, r a \n;G'' O' |r ' x ' s;G . I| . ------. s,s' ;G+ . I' | .,. ' ' O.b,Ib|y.bv .S * O' .b,I.b|Eb[zv ' .b] for \nb= V, r a ;G'' O' |zv ' x s;G . I| . -------. s,s' ;G+ , k:k t . I' | ., k. .r.E[r],.' De.nition 14 (Bisimilarity). \nAbisimulationf is aset of con.gura\u00adtions closed bytransitions: for every I . C . f with input label a, \nthere exists an output label \u00df and I ' . C ' . f suchthat a ;\u00df ' I . C - -. I ' . C Applicative bisimilarity, \nwritten A, is the largest bisimulation. As usual, to prove C . A for a given con.guration C , it suf.ces \nto build some f that includes C and show that it is a bisimulation. (See the full paper for additional \ndiscussion and examples.) We now relate labeled transitions on con.gurations to the re\u00adductions of runtime \nstates obtained by context closure. Lemma 15. Let C . A. The two sides of any context closureE [C] either \nreturn some identical result; or diverge; or reduce to some a ;\u00df ' E ' [C ' ] with C - -. C and C ' . \nA. a ;\u00df Lemma 16. For every transition I - -. I ' ,thereis acontext ET for I suchthat, for any C :I with \ninput a, we have ET[C ] . e if and only if C performs this transition. a ;\u00df ' ' Lemma 17. For every transition \nI . C - -. I . C and context-closure E ' [C ' ], there is a context closure E [C ] such that E [C ] .S \n* E ' [C ' ]. e Theorem 4. E = A. 8. Full abstraction for wrapped translations We are .nally ready to \nprove full abstraction, relating contextual equivalences in f. and js. . Relying on Theorem 4, we use \nlabeled bisimulations rather than contextual equivalences: the main idea is to extend the wrapped translation \nfrom source expressions to source con.gurations, and to systematically relate their source and target \ntransitions. We begin by establishing a corollary of type soundness for reasoning about untrusted callbacks. \nThen, we establish oper\u00adational properties for wrappers, setting up notations for con.gura\u00adtion translations \n(De.nition 21). Untrusted callbacks As we import untrusted values, callbacks triggered by getters are \ninnocuous, since the context can provide arbitrary values anyway. To deal with them in the bisimulation, \nwe use a corollary of open subject reduction, where we use Ito refer to the union of the translation \nof the source Ref heap H, together with the Inv, Abs, and the private locations in the Stub heap. Lemma \n18 (Untrusted Callbacks). For every typed open runtime state s Oun,I|e, where G' .D s :t ' and G' de.nes \nonly functions z z * O' or s .S un,I+ |E[z ( :un) :un]. z :un . un, one of the following holds: s .;or \ns .S un,I+ |r; * O' Properties of wrappers For functional types, the full paper de\u00ad ' .nes .t{x ' },the \njs. open function value obtained byreducing .t x . Similarly,.t{z} is the function obtained by reducing \n.t z this lat\u00adter operation just distributes up and down wrappers around the ar\u00adgument and return of \nz,so the value always exists. In both cases, we remove the Fun constructor, and retain the function closure \nwithin. The main operational property for down wrappers is that, as we ex\u00adport atranslation of asource \nvalue, we obtain afreshly-allocated un value that depends only on the source value not on the choice \nof its translation. Its proof is byinduction on vrelying on monadic typ\u00ading (\u00a76) and is mutually inductive \nwith the proof of Lemma 20, which reasons about importing values from the context. For clarity, we present \nthe two lemmas separately. Lemma 19 (Running down). Let Gx . v :t suchthat .t is de.ned and Gx binds \nthe functions of v. Let G' declare x :un . un . un x and . substitute .t ' {x} for every x:x t ' . Gx. \nThereexist Oun and v' ' such that, for any light translation Gx .f v : t I e , we have I| .t e ' .S * \nOun,I+ |v '. and Gx ' .D Oun,I+ |v '. :un. Intuitively, Oun is the new un memory allocated to copythe \nex\u00adported value, while G' declares the exported wrapped-down trans\u00ad x lations of the function variables \nin v. The next lemma shows that up wrappers return (at most) light translations of a source value that \ndepend only on the untrusted context. Besides, those wrappers may trigger untrusted callbacks in the \nprocess, diverge, fail, or raise an exception. (In addition to divergence in any callbacks that may be \ntriggered, we may get divergence, for instance, as we try to import a circular list.) Lemma 20 (Running \nup). For all values u : un and states s Oun,H,I| .t u, suchthat G' .D s :[[t]], if s returns with .nal \nstate z ' O' un,H' ,I+ |v :[[t]] (after any number of untrusted callbacks) then Gz .f H'' |v :t I+ H' \n|v ' for some source runtime state H'' |v. Candidate bisimulation We de.ne the full translation of source \ncon.gurations. (The full translation of programs is a special case.) As in \u00a74, this translation is non-deterministic; \nit includes consis\u00adtent translations of every piece of the source con.guration. It is designed to be \nclosed by js. transitions. To keeps track of all al\u00adlocated stubs, it also includes the translation of \nHstub, an auxiliary store (not present in the source con.guration) with one option ref\u00aderence for every \nstub. As can be expected of adefensivetranslation, its interface consists entirely of untrusted locations \nand functions. We refer to the full paper for auxiliary de.nitions of the evalua\u00adtion contexts E.t[ ] \nfor frames that transition from untrusted callers to translated callees, F[F' [ ]] for frames that transition \nfrom trans\u00adlated callbacks to untrusted callees, stubs,r for f. stub closures with object s and reference \nr (variable by in Figure 4), and U[ ] that ranges over their continuations after declassi.cation. This \nde.ni\u00adtion also omits partially-applied functions, e.g. .t{x} applied to a this object and waiting for \nits arguments object.  De.nition 21 (Con.guration Translation). A translation of the source con.guration \n/0;G . C = H|. is any con.guration of the ' form s' ;G' . I ' ,H ' |.such that, for b =V,r we have H. \n(1) G . Hb. Hstub Ib b. . . (2) For every x :x t. G, we have G . x.b Ib vb and x .. =.t{vb}. b (3) For \nevery k :k t. t ' . G, we have G . k.b Ib Eb .[ ], using the light translation of expressions with an \nadditional rule trans\u00adlating [ ] to [ ], and k.b . is E.t' [Eb .[F[F' [U[ ]]]]] for some typed continuation \nU [ ] reachable from stubs,r. (4) For every r . v :option t ' . Hstub, .b . also de.nes stubs,r and \nany typed continuations U [ ] reachable from stubs,r.  ' (5) I ' , H ' , and .are obtained from I. , \nH., and .. by replacing every instance of z with .t{z} for every z :z t . G. (6) s' declares un objects \n(including function objects for the ex\u00adported functions x) and the function objects s of the stubs of \n(4). (7) G' declares [[z :z t]] = z :z un . un . un, [[x :x t]] = x :x un . un . un, or [[k:k t]] = \nk:k un . un for every declaration in G and every de.nition of (4),  The lemma statements below account \nfor the non-determinism of our translation: for soundness, [ ] collects all con.guration translations \nde.ned above; for completeness, [ ]' collects all con\u00ad.guration translations without stub callbacks. \nWe obtain our main theorem for programs seen as singleton con.gurations. Lemma 22 (Soundness). If I . \nC . E then [I . C] . E. Lemma 23 (Completeness). If [I . C]' n E .= 0/then I . C . E. Theorem 5 (Full \nabstraction). For all translations . v:t 0/esuch that .t is de.ned, v0 e v1 in f. if and only if .t e0 \ne .t e1 in js. . 9. Preliminary case studies and discussion Although we leave an extensive evaluation \nof our compiler as future work, we have already used it to program several small case studies (available \non the web) we brie.y describe two of these here. Secure subsystems A traditional challenge in JavaScript \nprogram\u00adming involves combining code from multiple, mutually distrusting sources, while maintaining a \ndegree of control over the resulting mash-up. One design towards this objective could be to implement \na subsystem in f. that mediates mash-up interactions, prove it cor\u00adrect using monadic f., and then deploy \nit using our compiler. To illustrate our point, we have implemented an interference\u00adfree local store \non top of the localStorage object in HTML 5, which offers a key-value store per web page. The challenge \nis that this resource is shared between all scripts running in a web page: they can all read, write, \nand even clear the whole storage without any access control. To enable mash-ups to use local storage, \nwe implement a secure API setItem, getItem, and removeItem that multiplexes access to localStorage while \nensuring isolation. Advising JavaScript Meyerovich and Livshits (2010) propose CONSCRIPT, a browser-based \nimplementation of aspect-oriented advice for JavaScript, itself expressed as JavaScript code. In prelim\u00adinary \nexperiments, we have been able to implement 6 C ONSCRIPT policies in f.. Being written in f. makes the \nadvice simpler: we can prove correctness of the advice by contextual equivalence at the source level, \nand, unlike CONSCRIPT, we do not require any browser modi.cations. Performance The bene.ts of running \nsecure JavaScript come at a price, as any interactions with untrusted code are mediated by wrappers. \nThe cost of wrapping, however, is proportionate only to the number of boundary crossings between trusted \nand untrusted code. When executing within f., there is little overhead due to secu\u00adrity protections. \nNevertheless, we expect to improve our translation, with an eye towards performance, along several axes. \nFor example, our current representation of datatypes is na\u00a8ive. We might instead use JavaScript s ArrayBuffer, \nwhich offers a packed data represen\u00adtation. For the wrappers, rather than exporting data by copying, \nwe plan to investigate using Object.freeze, a new feature that dynam\u00adically renders the .elds of an object \nimmutable. We are also consid\u00adering using a lazy semantics for the wrappers that import data (pos\u00adsibly \nusing proxies of the forthcoming ES6 standard). This would necessitate re.ecting the callbacks in the \nsource semantics, as lazy importing may trigger callbacks to the context as imported data is read, but \nthe performance gains may make this a good tradeoff. Conclusions It is increasingly common for compilers \nto target JavaScript, contributing to a growing view of JavaScript as the assembly language of the Web \n. Our work provides a foundation for such compilers, particularly when compiled code must interact with \ncode from other, less trustworthy sources. Relying on full abstraction, developers who program in higher \nlevel languages such as ML can reliably and securely deploy their code, without having to worry about \nthe intricacies of JavaScript. References M. Abadi. Protection in programming-language translations. \nIn ICALP, volume 1443, pages 868 883, 1998. M. Abadi and G. D. Plotkin. On protection by layout randomization. \nIn IEEE CSF, pages 337 351, 2010. M. Abadi, C. Fournet, and G. Gonthier. Secure implementation of channel \nabstractions. Information and Computation, 174(1):37 83, Apr. 2002. P. Agten, R. Strackx, B. Jacobs, \nand F. Piessens. Secure compilation to modern processors. In IEEE CSF, pages 171 185, 2012. A. Ahmed \nand M. Blume. Typed closure conversion preserves observational equivalence. In ICFP, 2008. Caja. Attack \nvectors for privilege escalation, 2012. URL http://code. google.com/p/google-caja/wiki/AttackVectors. \nE. Cooper, S. Lindley, P. Wadler, and J. Yallop. Links: Web programming without tiers. In FMCO, 2006. \nL. de Moura and N. Bj\u00f8rner. Z3: An ef.cient SMT solver. In TACAS, 2008. A. Guha, C. Saftoiu, and S. Krishnamurthi. \nThe essence of JavaScript. In ECOOP, 2010. A. Kennedy. Securing the .NET programming model. TCS, 364(3), \n2006. S. Lassen. Eager normal form bisimulation. LICS, 2005. S. Maffeis, J. C. Mitchell, and A. Taly. \nAn operational semantics for JavaScript. In APLAS, 2008. J. McCarthy. Towards a mathematical science \nof computation. In IFIP Congress, pages 21 28, 1962. L. A. Meyerovich and V. B. Livshits. Conscript: \nSpecifying and enforcing .ne-grained security policies for JavaScript in the browser. In IEEE S&#38;P, \n2010. J. C. Mitchell. On abstraction and the expressive power of programming languages. Science of Computer \nProgramming, 21(2):141 163, 1993. J. H. Morris. Protection in programming languages. In CACM (16), 1973. \nJ. Politz, M. Carroll, B. Lerner, J. Pombrio, and S. Krishnamurthi. A tested semantics for getters, setters, \nand eval in JavaScript. In DLS, 2012. C. Schlesinger and N. Swamy. Veri.cation condition generation with \nthe Dijkstra state monad. Technical Report MSR-TR-2012-45, Mar. 2012. M. Serrano, E. Gallesio, and F. \nLoitsch. Hop: a language for programming the web 2.0. In OOPSLA Companion, pages 975 985, 2006. E. Sumii \nand B. C. Pierce. A bisimulation for type abstraction and recur\u00adsion. In POPL, 2005. N. Swamy, J. Chen, \nC. Fournet, P.-Y. Strub, K. Bhargavan, and J. Yang. Secure distributed programming with value-dependent \ntypes. In ICFP, 2011. N. Swamy, J. Weinberger, C. Schlesinger, J. Chen, and B. Livshits. Towards JavaScript \nveri.cation with the Dijkstra state monad. Technical Report MSR-TR-2012-37, Mar 2012. A. Taly, U. Erlingsson, \nJ. C. Mitchell, M. S. Miller, and J. Nagra. Automated analysis of security-critical JavaScript APIs. \nIn IEEE S&#38;P, 2011.  \n\t\t\t", "proc_id": "2429069", "abstract": "<p>Many tools allow programmers to develop applications in high-level languages and deploy them in web browsers via compilation to JavaScript. While practical and widely used, these compilers are ad hoc: no guarantee is provided on their correctness for whole programs, nor their security for programs executed within arbitrary JavaScript contexts. This paper presents a compiler with such guarantees. We compile an ML-like language with higher-order functions and references to JavaScript, while preserving all source program properties. Relying on type-based invariants and applicative bisimilarity, we show full abstraction: two programs are equivalent in all source contexts if and only if their wrapped translations are equivalent in all JavaScript contexts. We evaluate our compiler on sample programs, including a series of secure libraries.</p>", "authors": [{"name": "Cedric Fournet", "author_profile_id": "81100547450", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P3977999", "email_address": "fournet@microsoft.com", "orcid_id": ""}, {"name": "Nikhil Swamy", "author_profile_id": "81342513197", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P3978000", "email_address": "nswamy@microsoft.com", "orcid_id": ""}, {"name": "Juan Chen", "author_profile_id": "81100119052", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P3978001", "email_address": "juanchen@microsoft.com", "orcid_id": ""}, {"name": "Pierre-Evariste Dagand", "author_profile_id": "81413605432", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P3978002", "email_address": "dagand@cis.strath.ac.uk", "orcid_id": ""}, {"name": "Pierre-Yves Strub", "author_profile_id": "81488661455", "affiliation": "MSR-INRIA, Orsay, France", "person_id": "P3978003", "email_address": "pierre-yves@strub.nu", "orcid_id": ""}, {"name": "Benjamin Livshits", "author_profile_id": "81100637280", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P3978004", "email_address": "livshits@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429114", "year": "2013", "article_id": "2429114", "conference": "POPL", "title": "Fully abstract compilation to JavaScript", "url": "http://dl.acm.org/citation.cfm?id=2429114"}