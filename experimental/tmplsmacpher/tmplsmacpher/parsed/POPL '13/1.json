{"article_publication_date": "01-23-2013", "fulltext": "\n Full Abstraction for Nominal Scott Domains Steffen L\u00a8osch Andrew M. Pitts University of Cambridge \n{ste.en.loesch,andrew.pitts}@cl.cam.ac.uk Abstract We develop a domain theory within nominal sets and \npresent pro\u00adgramming language constructs and results that can be gained from this approach. The development \nis based on the concept of orbit\u00ad.nite subset, that is, a subset of a nominal sets that is both .nitely \nsupported and contained in .nitely many orbits. This concept ap\u00adpears prominently in the recent research \nprogramme of Boja\u00b4nczyk et al. on automata over in.nite languages, and our results establish a connection \nbetween their work and a characterisation of topologi\u00adcal compactness discovered, in a quite different \nsetting, by Winskel and Turner as part of a nominal domain theory for concurrency. We use this connection \nto derive a notion of Scott domain within nomi\u00adnal sets. The functionals for existential quanti.cation \nover names and de.nite description over names turn out to be compact in the sense appropriate for nominal \nScott domains. Adding them, to\u00adgether with parallel-or, to a programming language for recursively de.ned \nhigher-order functions with name abstraction and locally scoped names, we prove a full abstraction result \nfor nominal Scott domains analogous to Plotkin s classic result about PCF and con\u00adventional Scott domains: \ntwo program phrases have the same ob\u00adservable operational behaviour in all contexts if and only if they \ndenote equal elements of the nominal Scott domain model. This is the .rst full abstraction result we \nknow of for higher-order func\u00adtions with local names that uses a domain theory based on ordinary extensional \nfunctions, rather than using the more intensional ap\u00adproach of game semantics. Categories and Subject \nDescriptors F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic Lambda calculus and related \nsystems; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages Denotational semantics \nGeneral Terms Languages, Theory Keywords Denotational Semantics, Domain Theory, Full Ab\u00adstraction, Nominal \nSets, Symmetry 1. Introduction Various forms of symmetry are used in many branches of mathe\u00admatics and \ncomputer science. The results in this paper have to do with using symmetry to extend the reach of computation \ntheory from .nite data structures and algorithms to ones that, although they are in.nite, become .nite \nwhen quotiented by a suitable no- Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 13, January 23 25, 2013, Rome, Italy. Copyright c &#38;#169; 2013 \nACM 978-1-4503-1832-7/13/01. . . $10.00 tion of symmetry. We focus on higher-order functional computa\u00adtion \nwith data that may involve unboundedly many different names and symmetries given by permutations of those \nnames. A simple example of such data is the abstract syntax trees for a language involving binding constructs, \nsuch as the .-calculus with named bound variables: in.nitely many abstract syntax trees represent a particular \n.-term, modulo permuting their bound names. This way of viewing a-equivalence via symmetry was the initial \nstimulus for the development of nominal sets [14] a theory for mathematical structures involving atomic \nnames (that is, names whose only at\u00adtribute is their identity) based on name permutations and the notion \nof .nite support;we review this concept in Section 2. Nominal sets have been used to develop the semantic \nproper\u00adties of binders and locally scoped names, with applications to func\u00adtional and logic programming, \nto equational logic and rewriting, to type theory and to interactive theorem proving; see the bibliogra\u00adphy \n[1]. The work by Montanari et al. [22] on the p-calculus and HD-automata provides a somewhat different \napplication of nom\u00adinal sets (an independent one, since it uses a notion of named set that only subsequently \nwas shown to be equivalent to nominal sets [15, 37]). The use of symmetries of names (of fresh commu\u00adnication \nchannels in this case) to get .nite representations of in\u00ad.nitely many states is at the forefront in \ntheir work. It has recently been subsumed and generalised in a programme of what one might call orbit-.nite \nautomata theory [7, 8, 13, 23, 42]. In this paper we bring together the names and binders and the orbit-.nite \nstate space aspects of nominal sets. We observe that a key concept underlying the automata-theoretic \nresearch programme of Boja\u00b4nczyk et al. [6], that of being an orbit-.nite subset, turns out to subsume \na notion of topological compactness introduced, for quite different purposes, by Winskel and Turner in \ntheir work on nominal domain theory for concurrency [40]. We explain the connection and use it to develop \na version of the classic notion of Scott domain within nominal sets. (Previous work on denotational semantics \nwith nominal sets [34, 39] has focussed on simpler no\u00adtions of domain, analogous either to .-chain complete \nposets, or to algebraic lattices.) A domain element is compact if it stands for a .nite approximation \nof a computation. We de.ne this notion for our setting (in De.nition 5) and show that the functionals \nfor there exists a name such that. . . and the unique name such that. . . are compact. Plotkin [30] \nfamously proves that PCF with parallel-or is fully abstract with respect to conventional Scott domains, \nin the sense that two expressions have equal denotations if and only if they the have the same observable \noperational behaviour in all con\u00adtexts. We obtain an analogous result for nominal Scott domains, through \nadding the above functionals, together with parallel-or, to a programming language for recursively de.ned \nhigher-order func\u00adtions with name-abstractions and locally scoped names. Thus this paper makes the following \ncontributions. We show (Theorem 8) that a .nitely supported subset of a nominal set is compact with respect \nto unions that are uniform\u00addirected in the sense of Winskel and Turner if and only if it is orbit-.nite. \n  We use orbit-.nite subsets to generalise the notion of Scott do\u00admain from ordinary sets to nominal \nsets; we prove that the cat\u00adegory of nominal Scott domains is cartesian closed, has least .xed points \nand is closed under forming domains of name ab\u00adstractions (Sections 5 and 6). Although there are in.nitely \nmany names, the nominal Scott domain of names has some strong .niteness properties. In particular, we \nshow that the functionals for existential quanti.cation over names and de.nite descrip\u00adtion of names \nare uniform-compact elements of their function domains (Examples 14 and 15).  We de.ne a language PNA \n(Programming with Name Abstrac\u00adtions) that extends Plotkin s PCF language with names that can be locally \nscoped, swapped, abstracted and concreted. In order to illustrate these facilities for programming with \nname abstrac\u00adtions, PNA has a nominal algebraic datatype for representing .-terms. PNA s operational \nsemantics is inspired by [19, 27]; in particular, its method for deconstructing name abstractions makes \nuse of Odersky-style, scope-intrusive local names. We give a simple denotational semantics for PNA using \nnominal Scott domains and prove that it is computationally adequate (Theorem 27).  We extend PNA to \na language PNA+ with syntax, operational semantics and denotational semantics for parallel-or, for exis\u00adtentially \nquantifying over names and for de.nite descriptions of names. We prove that the nominal Scott domain \nmodel of PNA+ is fully abstract: any two expressions are contextually equivalent if and only if they \nhave equal denotations in the model (Theorem 30).  There are full abstraction results for higher-order \nfunctions with local names using the intensional approach of game semantics [3, 18, 41], but our Theorem \n30 is the .rst such result we know of that is based on ordinary extensional functions. There is no sim\u00adilar \nresult known for FreshML [35], which uses generative rather than Odersky-style local names to implement \nthe features that PNA provides for programming with name abstractions; and yet PNA (extended with recursive \ntypes) is in principle as expressive as FreshML, in view of L\u00a8osch and Pitts [19]. Our proof of Theo\u00adrem \n30 seems novel compared with other proofs of full abstraction results in the literature. We only sketch \nit here the details will be published elsewhere. On the other hand it gives rise to some open problems \nthat we discuss in Section 10, together with a number of possibilities for future work exploiting the \nuse of orbit-.nite sub\u00adsets within nominal domain theory. 2. Finite support We are interested in the \ndenotational semantics of programs written in languages featuring binding constructs involving names \nthat can be tested for equality. To take symmetry into account, we .x some countably in.nite set A (of \natomic names ) and consider .nite permutations of A, that is, bijections p : A ~A with the property = \nthat pa = a holds for all but .nitely many a . A. Recall that an action of such permutations on a set \nX is a binary operation \u00b7 satisfying id \u00b7 x = x (where id is the identity permutation) and p ' \u00b7 (p \u00b7 \nx)= (p ' .p)\u00b7 x (where . is composition). Actions of .nite permutations of A on sets X and Y can be extended \nto their cartesian product X \u00d7 Y by de.ning for each x . X and y . Y p \u00b7 (x, y) (p \u00b7 x, p \u00b7 y). (1) More \ninterestingly, given actions on X and Y, we get an action on the set of functions YX by de.ning for each \nf . YX p \u00b7 f .x . X -p\u00b7 (f(p-1 \u00b7 x)) (2) where p-1 is the inverse of the permutation p. In particular, \ntaking Y = 2 = {true,false}, a two-element set with trivial action (p \u00b7 true = true, p \u00b7 false = false), \nwe get an action on and 2X hence on subsets of X: for each S . X p \u00b7 S {p \u00b7 x |x . S}. (3) Programs, \nbeing .nite syntactic objects, only involve .nitely many atomic names in their construction; whereas \nthe elements of a set X used to denote program behaviours may well be in.nite mathematical objects. We \nwish to limit our attention to in.nite behaviours that depend only upon .nitely many atomic names, as \ndoing so yields a richer and better behaved theory. We can make precise what it means to only depend \nupon .nitely many atomic names entirely in terms of symmetry, that is, in terms of the permutation action. \nAn element x . X is supported by a set A . A of atomic names if every permutation p satisfying (.a . \nA)pa = a also satis.es p \u00b7 x = x. That is, permutations that preserve Aalso preserve x. We say that a \nset X equipped with an action of .nite permutations of A is a nominal set if each of its elements is \nsupported by some .nite set of atomic names. In this case one can show that for each x . X there is a \nsmallest .nite subset of A supporting x, which we write as supp x [14]. We also write a # x to mean a \n/. supp x. Note that since supp x is a .nite set and A is not, given x we can always .nd some a . A satisfying \na # x. Given a nominal set X, the subsets that possess a .nite support with respect to the action in \n(3) are called .nitely supported subsets of X. Not every subset is .nitely supported. For example, when \nX = A (with action p\u00b7a = pa), the only .nitely supported subsets are those S . A for which either S, \nor A -S is .nite. We write Pfs X for the collection of all .nitely supported subsets of X, and with the \naction in (3) this is a nominal set. Indeed it is the power object (in the sense of topos theory [17]) \nfor a model of higher\u00adorder logic based on nominal sets. The main difference between this model and the \nclassical one is that it fails to satisfy choice principles.1 As we discuss next, this difference causes \nnominal domain theory to be something more than just classical domain theory carried out in the nominal \nmodel of higher-order logic . 3. Uniform-directed joins A key idea behind domain theory [5] is to give \ndenotations to pro\u00adgrams with potentially in.nite behaviour as a limit of approxima\u00adtions. For domain \ntheory based on approximation via a partial order (rather than a metric), limits are joins of chains \n(linearly ordered subsets), or more generally, joins of directed subsets (where every .nite set of elements \nhas an upper bound in the subset). So long as one considers chains of arbitrary (ordinal) length, classically \nthere is no difference between using joins of chains and using directed joins [20]. However, the equivalence \nof the two approaches relies on the Axiom of Choice and, as we noted above, that fails to hold for nominal \nsets. Therefore, in the nominal version of domain the\u00adory, formulating limits in terms of joins of chains \nis more restric\u00adtive than using joins of arbitrary directed subsets. (Of course, both the chains and \nthe directed subsets should be .nitely supported, to make sense nominally.) Winskel and Turner [40] provide \na com\u00adpelling reason for restricting attention to joins of chains. They show that a key notion provided \nby the nominal approach, the operation 1The associated model of set theory goes back to work in the 1930s \nby Fraenkel and Mostowski, who devised it speci.cally to negate the Axiom of Choice [see 12, Remark 2.22]. \n of name abstraction, preserves joins of chains, but does not neces\u00adsarily preserve joins of directed \nsubsets in general. We give below a simpli.ed version of the Winskel-Turner example of the failure of \nname abstraction to preserve joins of all .nitely supported, directed subsets. De.nition 1 (name abstraction). \nA nominal poset is simply a nominal set D equipped with a partial order . that is respected by the action \nof permutations: d . d ' . p\u00b7 d . p\u00b7 d ' . Given such a D, we get a pre-order on A \u00d7 D by de.ning (a, \nd). (a ' , d ' )to '' ' '' d ' hold whenever we have (a a )\u00b7 d . (a a )\u00b7 in D for some '' ' ' (or indeed, \nfor any) a # a, a , d, d ' . (As usual, (a a )denotes the permutation that swaps a and a ' , leaving \nall other atomic names .xed.) We write [A]D for the poset obtained by quotienting A \u00d7D by the equivalence \nrelation associated with this pre-order, and (a)d for the equivalence class of (a, d). De.ning a permutation \naction by p \u00b7 (a)d = (pa)(p \u00b7 d), one can show that [A]D is also a nominal poset, with supp(a)d = (supp \nd)- {a}. An element of [A]D is an abstract form of a-equivalence class for elements of D. It is abstract, \nbecause D itself may not consist of syntactic data we just need to know how name permutations act on \nits elements. Example 2. For any nominal set X, partially ordering the elements of the nominal set Pfs \nX of .nitely supported subsets of X by inclusion, we get a nominal poset. Consider the case when X = \nA. Given a . A, the name abstraction function Pfs A . [A](Pfs A) mapping each S . Pfs A to (a)S does \nnot preserve all joins of .nitely supported, directed subsets. For example, consider the directed subset \nF . Pfs (Pfs A) consisting of all .nite sets of atomic names. F has empty support and its join F is \nequal to A. However, .xing upon a a ' in A, one has (a)A = (a ')A= = (a ')(A - {a}) and one can check \nthat {(a)F | F . F} . (a ')(A - {a}). So (a)( F) {(a)F | = F . F}. Amotivation for using nominal rather \nthan ordinary domains to do denotational semantics is precisely to gain access to this oper\u00adation of \nname abstraction, which can be used to model language features involving binders. So .nding a setting \nin which name ab\u00adstraction preserves limits of approximations is crucial. It turns out that the problem \nwith the directed subset F in the above example is its lack of what Winskel and Turner call uniformity: \neach F . F is a .nite set of atomic names and hence is supported by F itself. Thus, there is no single \n.nite support for all the elements of F. De.nition 3 (udcpos). Given a nominal set X, call a subset S \n. X uniformly supported if there is a .nite set A .f A that supports each x . S. A uniform-directed subset \nof a nominal poset is a subset S that is both uniformly supported and directed. A uniform\u00addirected complete \npartial order (udcpo) is a nominal poset that has joins S for all uniform-directed subsets S. Lemma \n4. In a nominal poset D, every .nitely supported chain C is necessarily uniformly supported. In particular, \neach d . C is supported by supp C. For a proof, see Turner [39, Lemma 3.4.2.1]. As Turner points out, \nusing this lemma, the classic result of Markowsky [20] can be extended to show that a nominal poset is \na udcpo if and only if it has joins for all .nitely supported chains. So in effect udcpos give us a domain \ntheory within the higher-order logic of nominal sets based on chain-completeness. As we will see in Section \n6, they also give us access to the name-abstraction construct. We model potentially in.nite program behaviours \nin languages with names using denotations that are uniform-directed joins of approximations to the behaviour. \nEach approximation should be .nite in a suitable sense. For classical domain theory this amounts to being \ncompact (also known as isolated ) with respect to directed joins. By analogy, we make the following de.nition. \nDe.nition 5 (algebraic udcpo). An element u . D of a udcpo D is uniform-compact if for all uniform-directed \nsubsets S . D, u . S . (.d . S) u . d. We write KD for the set of uniform-compact elements of D. We \nsay that D is an algebraic udcpo if each of its elements is the join of a uniform-directed subset of \nKD. D is .-algebraic if in addition the underlying set of KDis countable. Recall that a subset of a set \nis compact with respect to directed joins (unions) of subsets if and only if it is a .nite set. Here \nwe are restricting attention to a smaller class of joins, the uniform\u00addirected ones. Therefore, we expect \nuniform-compactness to be a more liberal notion of .niteness. We show in the next section that it corresponds \nprecisely to the notion of orbit-.nite subset introduced by Boja\u00b4nczyk et al.2 4. Orbit-.nite subsets \nThe action of .nite permutations of A on the elements of a nominal set X partitions it into orbits: two \nelements x and x ' are in the same orbit if x ' = p \u00b7 x for some .nite permutation p. For example A itself \nhas just one orbit. A \u00d7 A has two, namely {(a, a)|a . A} and {(a, a ' ) . A2 | a = a ' }, and in general \nAn has always .nitely many orbits. In contrast, the nominal set A * of .nite lists of atomic names has \nin.nitely many orbits (since lists of different length cannot be in the same orbit). De.nition 6 (orbit-.nite \nsubsets). A .nitely supported subset S . Pfs X of a nominal set X is said to be orbit-.nite if it is \ncontained in the union of .nitely many orbits of X. Boja\u00b4nczyk et al. investigate orbit-.nite data structures \nand algo\u00adrithms (for a generalised version of nominal sets over any Fra\u00a8iss\u00b4e symmetry ). Note that an \norbit-.nite subset may well have in\u00ad.nitely many different elements. For example, A is an orbit-.nite \nsubset of itself. In order to compute with orbit-.nite subsets one needs an effective presentation of \nthem and their operations. The following notion turns out to give an alternative characterisation of \norbit-.nite subsets that is suitable for calculation. It was introduced independently by Turner [39, \nDe.nition 3.4.3.2], Gabbay [11, Sec\u00adtion 3.3; 12, De.nition 3.1; 13, De.nition 3.1] and Boja\u00b4nczyk et \nal. [6, Section 8], whose hull terminology we adopt here. (See also Ciancia and Montanari [9, De.nition \n6.10], whose closures are hulls of the form hullsupp x-{a}{x}.) De.nition 7 (orbit-.nite hulls). Let \nX be a nominal set. Given .nite subsets A .f A and F .f X, de.ne hullAF {p\u00b7 x |p # A . x . F}, where \np # Ameans that p is a .nite permutation of A that .xes each a . A. It is not hard to see that hullAF \nis supported by Aand contained in a .nite union of orbits of X (namely the orbits of each x . F). What \nis less obvious is that every orbit-.nite subset is of this form. This follows from a key technical property \nof hulls, proved independently by Turner [39, Lemma 3.4.3.5] and Boja\u00b4nczyk et al. [6, Lemma 3]: (.A, \nA ' .f A, F .f X)A . A ' . (.F ' .f X) hullAF = hullA' F ' . (4) This property can be used to prove the \nfollowing theorem that makes the connection between orbit-.nite subsets and the notion of uniform-compactness \nfrom the previous section. Consider the nominal poset Pfs X of .nitely supported subsets of a nominal \nset X, the partial order being subset inclusion. It possesses joins for all 2Boja \u00b4nczyk et al. [6, Section \n3] use the term .nitary subset for what we call an orbit-.nite subset.  .nitely supported subsets, given \nby union, and hence in particular it is a udcpo. Theorem 8. An element of the udcpo Pfs X is uniform-compact \nif and only if it is an orbit-.nite subset of X; and it is an orbit-.nite subset of X if and only if \nit is equal to hullAF for some A .f A and F .f X. Every S . Pfs X is the uniform-directed join of the \norbit-.nite subsets contained in and with the same support as S. Thus Pfs X is an algebraic udcpo in \nthe sense of De.nition 5. So there is the following analogy .nite orbit-.nite sets ~ nominal sets directed \nuniform-directed which we apply next to the classical notion of Scott domain that arose in the denotational \nsemantics of higher-order functional pro\u00adgramming languages [30, Lemma 4.4]. 5. Nominal Scott domains \nA nominal Scott domain D is by de.nition an .-algebraic udcpo with a least element and joins for all \n.nitely supported subsets that have upper bounds (or equivalently, by Theorem 8, joins for all orbit-.nite \nsubsets that have upper bounds). Remark 9 (.at domains). If X is a nominal set, the .at nominal poset \nX. is given by X . {.}, with partial order d . d ' . d ' d = . . d = and permutation action extending \nthat on X by p \u00b7 . = .. It is easily seen to be a nominal Scott domain, with K(X.)= X.. De.nition 10. \nThe category Nsd has nominal Scott domains for its objects and for its morphisms the functions f : D \n. D ' that are both equivariant, that is, f(p\u00b7 d)= p\u00b7 (f d)holds for all .nite permutations p and all \nd . D, and uniform-continuous, that is, monotone and preserving uniform-directed joins. Remark 11 (Winskel-Turner \ndomain theory). The nominal do\u00admain theory for concurrency of Winskel and Turner [40] intro\u00adduces the \nnotion of uniform-directed join and contains a characteri\u00adsation of compact elements in terms of the \nhull construct from De.\u00adnition 7. However, their domains are more speci.c than ours as they are based \non path sets (downwards-closed subsets of preorders), which form prime-algebraic complete lattices. Modulo \ncountabil\u00adity, their category FMCts\u00d8 is a full subcategory of Nsd. Theorem 12. Nsd is cartesian closed. \nProof. The terminal object is given by the trivial .at domain \u00d8.. The product of D1 and D2 is given by \ntheir cartesian product, with permutation action as in (1) and partial order (d1 , d2). (d ' 1 , d ' \n2) d1 . d1 ' . d2 . d ' 2. Exponentials D1 -D2 have an underlying set consisting of all uniform-continuous \nfunctions f : D1 . D2 that are .nitely supported with respect to the usual permutation action for functions \ngiven in (2). The partial order on such functions is also given as usual, argument-wise: f . f ' (.d \n. D1 )f d . f ' d. For ordinary Scott domains, compact elements of the exponential are given by joins \nof .nite, bounded sets of step-functions. Here, given uniform-compact elements ui . KDi (i = 1,2), one \ncan show that the step-function [u1 , u2 ] .d . D1 -if u1 . d then u2 else . (5) is in K(D1 -D2 ); that \na typical element of K(D1 -D2 )is the join of an orbit-.nite, bounded set of such step functions (so \nin view of Theorem 8, K(D1 -D2 )is countable, because KD1 and KD2 are); and that every element of D1 \n-D2 is a uniform-directed join of elements in K(D1 -D2 ). We give some examples of uniform-compact elements \nof expo\u00adnentials in Nsd associated with the .at domain of atomic names, A.. The examples show that although \nA. has a countably in.nite underlying set, it has very different uniform-compactness proper\u00adties from \nthe .at domain of natural numbers, N. (e.g. the permu\u00adtation action on N is discrete: p \u00b7 n n). These \nexamples will be important for the development in Section 7. Example 13 (name equality test). Let 2 = \n{true,false} be a two-element, discrete nominal set. For each atomic name a . A, consider the function \neq a : A. -2. given by . .true if d = a . eq a d false if d . A - {a} (6) . .. if d = . for each d . \nA.. Then using the notation from De.nition 7 and (5), ' one .nds that eq a = hull{a}{[a , true],[a , \nfalse]}, where a ' is any atomic name not equal to a. Thus from the proof of Theorem 12 we have eq a \n. K(A. -2.). Example 14 (exists name). For each f . A. -2. de.ne . .true if (.a . A)f a = true . exists \nAf false if (.a . A)f a = false (7) . . . otherwise. Picking any a . A, one can show that exists A is \nequal to hull\u00d8{[[a , true] , true],[ hull\u00d8{[a , false]}, false]} and hence that exists A . K((A. -2.)-2.). \nExample 15 (de.nite name description). Note that the functions in Example 13 satisfy eq = eq . a = a \n' . Hence for each a a ' f . (A. -2.)we can de.ne a if f = eq for some a . A the A fa (8) . otherwise. \n Then picking any a . A, one has the A = hull\u00d8{[eq a , a]}and hence the A . K((A. -2.)-A.). Remark 16 \n(least .xed points). As for any cartesian closed cate\u00adgory, Theorem 12 allows us to model typed .-calculus \nusing nom\u00adinal Scott domains and equivariant, uniform-continuous functions. Nsd also supports the usual \ninterpretation of recursively de.ned terms via least .xed points: for if D . Nsd and f . (D -D), then \n{., f ., f 2 .,. . .}is a uniform-directed subset of D (each element is supported by supp f)whose join \nis .x f, the least .xed point of f, by the usual Tarskian argument. Indeed for each nomi\u00adnal Scott domain \nD, the function assigning least .xed points gives us a morphism in Nsd .x : (D -D). D. (9) It is probably \nthe case that Nsd has the algebraic compactness properties (enriched over the category of nominal sets) \nneeded to model recursive de.nitions at the level of types; cf. [5, Section 5] and [34, Section 3]. However, \nwe have yet to check the details of this. 6. Abstraction, concretion and restriction The following result \nis the basis for giving denotational semantics using nominal Scott domains to languages with name binding \nop\u00aderations, such as the one considered in Section 7. Theorem 17. If D is a nominal Scott domain, then \nso is the nominal poset [A]D from De.nition 1. The operation of name abstraction (a, d) . (a)dextends \nto a morphism A.\u00d7D . [A]D in Nsd once we de.ne (.)d ..  Proof. If S . Pfs ([A]D)is uniform-directed, \nthen so is {d . D | (a)d . S}. Pfs D, for any a . A. The same holds if S is .nitely supported and bounded \nfrom above. In both cases, picking a # S, one .nds that the join of S in [A]D is (a)( {d . D | (a)d \n. S}). Thus, [A]D has uniform-directed joins and joins of bounded .nitely supported subsets, and its \nleast element is (a). (for any a . A). The above description of uniform-directed joins in [A]D implies \nthat (a)u . K((A)D)if and only if u . KD and (hence) that [A]D is .-algebraic. It also implies that each \n.d . D -(a)d is uniform-continuous. Algorithms that manipulate binders not only construct name abstractions, \nthey also pull them apart. For example, FreshML [35] supports computation with name abstractions via \na convenient form of pattern matching that allows bound entities to be named while guaranteeing invariance \nunder a-equivalence. The mecha\u00adnism underlying this form of deconstruction of name abstractions is most \neasily understood in terms of name concretion , to which FreshML s pattern matching can be translated. \nGiven D . Nsd and e . [A]D, for each a . A with a # e there is a unique element e @a . D satisfying e \n= (a)(e @a), called the concretion of the name abstraction e at the atomic name a [14, Section 5]. Note \nthat this operation is partially de.ned: to form e @a we require a # e, meaning that a not in the support \nof e. For .at domains we will make concretion a total, uniform-continuous function simply by mapping \nthe pairs where concretion is unde.ned to . . D. How\u00adever, for non-.at domains this is not possible, \nbecause in general it does not give a monotone function. For example in [A](Pfs A), a ' . supp(a){a, \na ' }(assuming a = a ' ), but we cannot de.ne the concretion of (a){a, a ' }at a ' to be the least element \n\u00d8 of Pfs A since (a){a} . (a){a, a ' }and ((a){a}) @ a ' = {a ' }= \u00d8. One way to deal with this partiality \nof concretion in a program\u00adming language is to enhance its type system with freshness as\u00adsumptions to \nensure statically that name abstractions are only con\u00adcreted at fresh names. This is the solution adopted \nby the original version of FreshML [28] and is the one chosen by Winskel and Turner in their language \nNominal HOPLA [39, 40]. Later versions of FreshML use a conventional type system and enforce fresh\u00adness \nconditions dynamically via the use of local names in expres\u00adsions [35] at the expense of purity [31]. \nWe do the same with the language introduced in the next section, but achieve purity via the use of Odersky-style \n[24] local names rather than generative ones. These will be modelled by some extra structure on nominal \nScott domains in the form of name restriction operations [27, Section 2.3] that enable us to give morphisms \n[A]D\u00d7A. . D in Nsd for the operation of name concretion. De.nition 18 (uniform-continuous name restriction). \nA uni\u00adform-continuous name restriction operation on a nominal Scott domain D is a morphism r : [A]D . \nD in Nsd satisfying the structural properties: a # d . r(a)d = d and r(a)(r(a ' )d) = r(a ' )(r(a)d)for \nall a, a ' . A and d . D. We usually write r(a)d as a\\d with the particular morphism r understood from \ncontext. Using this morphism, as in Pitts [27, Corollary 2.14] we can extend the partial operation of \nconcretion to a total equivariant function @ : [A]D \u00d7 A. . D satisfying . ((a)d) @ a = d . '' ' ((a)d) \n@ a = a\\(a a )\u00b7 d if a = a (10) . ((a)d) @ . = .. The fact that this is uniform-continuous and hence \ndetermines a morphism in Nsd follows from the description of uniform-directed joins in [A]D in the proof \nof Theorem 17. The following result shows that domains arising in the deno\u00adtational semantics of higher-order \nfunctional programming with name abstractions (Section 7) all carry a uniform-continuous name restriction \noperation. The theorem can be proved by extending the results in Pitts [27, Section 2.3] from nominal \nsets to nominal Scott domains. Theorem 19. Every .at nominal Scott domain X. has a uniform\u00adcontinuous \nname restriction operation satisfying d if a # d a\\d = (11) . if a . supp d for all a . A and d . X.. \nIf D1 , D2 . Nsd have uniform\u00adcontinuous name restriction operations, their product D1 \u00d7D2 has one satisfying \na\\(d1, d2)= (a\\d1, a\\d2 ) (12) for all a . A, d1 . D1 and d2 . D2. If D1 , D2 . Nsd and D2 has a uniform-continuous \nname restriction operation, then whether or not D1 has one as well, the exponential D1 -D2 has such an \noperation, satisfying (a\\f)d = a\\(f d) if a # d (13) for all d . D1 and f . D1 -D2 . Finally, if D . \nNsd has a uniform-continuous name restriction operation, then the name abstraction domain [A]D has one \nsatisfying '' ' a\\((a )d)= (a )(a\\d) if a = a (14) for all a, a ' . A and d . D. Remark 20. In the above \ntheorem, the name restriction operation for exponentials is rather subtle. Property (13) at .rst seems \nlike only a partial speci.cation for the function a\\f, but in fact deter\u00admines it uniquely, since it \nimplies that for all d . D '' ' (a\\f)d = a \\((a a )\u00b7 f)d for any a # (f, d) (15) [see 27, Theorem 2.10]. \nIt is easier to see that (14) uniquely de.nes name restriction for name abstraction domains because given \na . A, we can always choose a representative for the equivalence class (a ' )dwith a = a ' . Theorem \n19 gives operations that adequately model locally scoped names in programming languages. For example, \nin ret\u00adrospect one can see that Shinwell and Pitts [34] use the name re\u00adstriction operation constructed \nas above for continuation domains of the form (D -1.)-1. to adequately model the operational semantics \nof FreshML, which evaluates a local scope by generating a name that is fresh for the current state. In \nthis paper we use Oder\u00adsky s functional theory of local names [24], which is modelled in Nsd rather easily \nin view of the above theorem. The next section introduces a language corresponding to a simply typed \nfragment of FreshML [35], but with this kind of locally scoped name. 7. PNA: programming with name abstractions \nThe programming language PNA (Programming with Name Abs\u00adtractions) is basically Plotkin s PCF [30] with \nnames added. Like PCF, PNA has arithmetic constructs, call-by-name higher-order functions and .xed-point \nrecursion. What distinguishes the two languages is that PNA treats names as .rst-class citizens and has \nconstructs for locally scoping them, swapping them, testing them for equality, and for name abstraction \nand concretion. To exercise the use of name abstraction it also features a representative nomi\u00adnal algebraic \ndatatype , namely a type for a-equivalence classes of .-terms. For example, when subst is the PNA expression \nde.ned below, subst e1 a e2 computes the .-term obtained by capture\u00adavoiding substitution of the .-term \nrepresented by e1 for all free occurrences of the variable named a in the .-term represented by e2. \n t . Typ ::= types bool | nat | t \u00d7 t |t -t | name | term |d t e . Exp ::= expressions x variable (x \n. V) T truth F falsity if e then e else e conditional O number zero S e successor pred e predecessor \nzero e zero test (e , e) pair fst e .rst projection snd e second projection .x : t -e function abstraction \ne e function application fix e .xed-point recursion . . . . . . . . . . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . a atomic name (a . A) .a. e local \nname (e . e)e name swapping e = e name equality test V e variable term A e e application term L e lambda \nterm case e of (V x -e | A x x -e | L x -e) term case aa. e name abstraction e @ e name concretion c \n. Can ::= canonical forms T |F |O |S c |(e , e)|.x : t -e |a |V c |A c c |L c |aa. c Figure 1. Syntax \nof PNA subst .y : term -.x : name \u00adfix (.(f : term -term)-.y ' : term \u00adcase y ' of V x1 -if x1 = x then \ny else y ' | A y2 y2 ' -A (f y2 ) (f y 2 ' ) | L z -L (aa. f(z @ a))). Figure 1 gives the syntax of PNA. \nIn the grammar for ex\u00adpressions, the part below the dotted line is what is added to PCF. There are two \nkinds of identi.er in the language: variables x, y, z, f, . . . . V and atomic names a, b, c, . . . . \nA. The sets V of variables and A of atomic names are disjoint and countably in.nite. Both kinds of identi.er \nmay be bound and the language s binding forms are .x : t - , .a. , case e of (V x - | A x x - | L x - \n)and aa. . We identify expressions up to a-equivalence of bound identi.ers. For any expression e, we \nwrite fn(e)for its .nite set of free atomic names and fv(e)for its .nite set of free variables. The reason \nfor making a syntactic distinction between variables and atomic names is that they behave differently. \nVarious proper\u00adties of PNA, such as its typing judgement, are preserved by the operation of substitution \nof expressions for variables but are only preserved by permutations of atomic names rather than more \ngen\u00aderal forms of substitution for names. The operation of simultaneous substitution of expressions e1,.., \nen for distinct variables x1 ,.., xn in an expression e is written as e[e1 /x1,.., en/xn], where the \nsubstitution avoids capture of both free variables and free atomic names by the language s binding forms. \nThe operation of applying a .nite permutation p = A to an expression e is written p\u00b7 e. It : A ~ (x : \nt). G c = T |F G . x : t G . c : bool G . e1 : bool G . e2 : t G . e3 : t G . if e1 then e2 else e3 \n: t G . O : nat G . G . e : nat S e : nat G . e : nat G . pred e : n at G . G . e : nat zero e : bool \nG . e1 : t1 G . (e1 , e2 ) G . e2 : t2 : t1 \u00d7 t2 G . e : t1 \u00d7t2 G . fst e : t1 ' G . e : t1 \u00d7 t2 G, \nx : t . e : t G . snd e : t2 G . .x : t -e : t -t ' G . e1 : t -t ' G . e2 : t G . e : t -t G . e1 e2 \n: t ' G . fix e : t . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . . . . a . A a . A G . e : t G . a : name G . .a. e : t G . e1 : name \nG . e2 : name G . e1 : name G . e3 : t G . e2 : name G . (e1 . e2)e3 : t G . e1 = e2 : bool G . G . e \n: name V e : term G . e1 : term G . e2 : term G . A e1 e2 : term G . G . e : dterm L e : term G . e \n: term G, x1 : name . e1 : t G, x2 : term, x 2 ' : term . e2 : t G, x3 : dterm . e3 : t G . case e of \n(V x1 -e1 | A x2 x2 ' -e2 | L x3 -e3): t a . A G . e : t G . e1 : d t G . e2 : name G . aa. e : d t G \n. e1 @ e2 : t Figure 2. PNA typing rules is de.ned by recursing into all sub-expressions and applying \np to occurrences of atomic names. This is an action in the sense of Sec\u00adtion 2 and makes the set Exp \nof PNA expressions into a nominal set. Since the elements of Exp are expressions up to a-equivalence, \nsupport in this nominal set is given by the .nite set of free names of each expression. PNA is a simply \ntyped language. The grammar for types (Fig\u00adure 1) extends that for PCF (in a version with products t1 \n\u00d7 t2) with a type name of names, a type term of .-terms modulo a\u00adequivalence, and name abstraction types \nd t. The inductively de\u00ad.ned typing judgement G . e : t (read as in the environment Gthe expression e \nhas type t ) is de.ned in Figure 2 by the usual rules for PCF and, below the dotted line, rules concerning \nnames. The typing environments G = {x1 : t1 ,. . . , xn : tn}are .nite func\u00adtions from variables to types \nthat track occurrences of free variables in e. Note that because there is only one sort of name, we do \nnot bother to add a component to Gtracking occurrences of free atomic names in e. In Figure 3 we extend \nPCF s usual rules for an inductively de\u00ad.ned big-step evaluation relation with the rules below the dotted \n c = T |F |O |(e1 , e2 )|.x : t -e e . c c . c S e . S c e1 . T e2 . c e1 . F e3 . c if e1 then e2 else \ne3 . c if e1 then e2 else e3 . c e . S c e . O e . S c pred e . c zero e . T zero e . F e . (e1 , e2) \ne1 . c e . (e1 , e2) e2 . c fst e . c snd e . c e1 . .x : t -e e[e2/x]. c e(fix e). c e1 e2 . c fix e \n. c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. . . . . . . . . . . e1 . a1 e2 . a2 a . A e . c a\\c := c ' e3 . c a . a .a. e . c ' (e1 . e2)e3 . (a1 \na2 )\u00b7 c e1 . a e2 . a e1 . a e2 . a ' a = a ' e1 = e2 . T e1 = e2 . F e . c e1 . c1 e2 . c2 e . c V e \n. V c A e1 e2 . A c1 c2 L e . L c e . V c e1 [c/x1 ]. c ' case e of (V x1 -e1 | \u00b7 \u00b7 \u00b7 ). c ' ' ' ' '' \ne . A c c e2 [c/x2 , c /x 2 ]. c case e of (\u00b7 \u00b7 \u00b7 | A x2 x2 ' -e2 | \u00b7 \u00b7 \u00b7 ). c '' e . L c e3[c/x3 ]. \nc ' e . c case e of (\u00b7 \u00b7 \u00b7 | L x3 -e3). c ' aa. e . aa. c '' '' e1 . aa. c e2 . a a = a .a. (a a )\u00b7 \nc . c e1 @ e2 . c ' Figure 3. PNA evaluation rules line that concern names. The evaluation rule for local \nnames makes use of the auxiliary de.nition in Figure 4. Thus the relation e . c de.nes when a PNA expression \ne evaluates to canonical form c. See Figure 1 for the grammar of canonical forms. As for PCF, we only \nevaluate expressions that are variable-closed in the sense that fv(e)= \u00d8, though they may contain free \natomic names for evalua\u00adtion. This is because, unlike variables, atomic names are canonical forms. We \nalso choose to evaluate under name abstractions, so that aa. e is in canonical form if and only if e \nis. This permits a rep\u00adresentation of a-equivalence classes of .-terms in PNA that is as simple as PCF \ns representation of numbers: they are in bijection with variable-closed canonical forms of type term. \n(It is certainly possible to give a different operational semantics in which one does not evaluate under \nname abstractions. The corresponding denota\u00adtional semantics would make more use of lifting than does \nthe one in Section 8.) To deconstruct name abstractions, PNA features an operational version of the total \nconcretion operation discussed in Section 6. Its behaviour is given by the last rule in Figure 3 and \ncorresponds to property (10). c = T |F |O |S c ' a\\c := c a\\(e1 , e2):= (.a. e1 , .a. e2 ) ' a = a a\\.x \n: t -e := .x : t -.a. e a\\a ' := a ' ' '' a\\c := c a\\c1 := c1 a\\c2 := c2 ' '' a\\V c := V c a\\A c1 c2 \n:= A c1 c2 ' '' a\\c := c a\\c := c a = a ' ''' a\\L c := L c a\\aa . c := aa . c Figure 4. Partial operation \nof name restriction, a\\c := c ' As for PCF, the PNA evaluation relation is easily seen to be deterministic \n(e . c . e . c ' . c = c ' ) and type-sound (\u00d8 . e : t . e . c . \u00d8 . c : t). It is also equivariant: \ne . c . p \u00b7 e . p \u00b7 c. (16) Remark 21 (Odersky-style local names). Evaluation of locally scoped names \n.a. e makes use of Odersky s functional theory of local names [24], because that way of evaluating them \n.ts the in\u00adtended model of PNA using nominal Scott domains. Scopes intrude in a type-directed fashion, \nas can be seen in the partial operation of name restriction on canonical forms a\\c := c ' de.ned in Figure \n4. This operation is partial because a\\a := c holds for no c. Thus, un\u00adlike in Pitts [27], we choose \nto follow Odersky [24] and make .a. a a stuck expression that does not evaluate to any canonical form \nand whose denotation is .. This has the advantage that there are no ex\u00adotic values (value-closed canonical \nforms) of type term the only values of that type correspond to a-equivalence classes of .-terms. The \nuse of Odersky-style local names means that the operational se\u00admantics of PNA is stateless, unlike the \noperational semantics of the more usual generative version of .a.  used in the .-calculus [29]. At the \nsame time, it is known to be as expressive as that version in as much as there is an adequate translation \nfrom generative into Odersky-style local names [19]. De.nition 22 (contextual equivalence). As usual, \na PNA context C[ ] is an expression with a single sub-expression replaced by the place-holder , and C[e]is \nthe expression that results from replacing  by an expression e (possibly capturing free variables and \natomic names in e). Given well-typed expressions G . e : t  ' ~' and G . e : t, we write G . e =PNA \ne : t and say that e and e ' are contextually equivalent if for all contexts C[ ]for which \u00d8 . C[e] : \nbool and \u00d8 . C[e ' ] : bool hold, it is the case that C[e]. T if and only if C[e ' ]. T. Example 23. \nAlthough PNA contains the expressions of the .\u00adcalculus [29] as a subset, the two languages have different \nseman\u00adtics for local names Odersky-style for PNA versus generative for the .-calculus. This affects properties \nof contextual equivalence in the two languages. For example, if G, x : t . e : t ' , then ~' G . .a. \n.x : t -e =PNA .x : t -.a. e : t -t (17) is valid. However, this is not always the case in the .-calculus \n[29, Example 2]. One can prove (17) by checking that this identity holds in the denotational model developed \nin the next section and then appealing to the computational adequacy result proved there (Theorem 27). \nOn the other hand, analogues of some .-calculus equivalences are also true for PNA, once one takes into \naccount the fact that, like PCF, PNA is call-by-name but the .-calculus is call-by-value. For example, \nhere are call-by-name analogues of equivalences in Pitts and Stark [29, Example 4]  \u00d8 . .a. .x : name \n-(x = a)~ =PNA (18) .x : name -if x = x then F else F : name -bool \u00d8 . .a. .a ' . .(f : name -bool)-eq \n(f a) (f a ' )~ =PNA .(f : name -bool)-.a. if f a then T else T (19) : (name -bool)-bool. Here eq : bool \n-bool -bool is an abbreviation for a boolean-equality test de.ned using conditionals. In contrast to \nthe .-calculus, where it takes some effort to prove equivalences like (18) and (19), for PNA these properties \nare easily seen to hold in the straightforward and computationally adequate denotational semantics that \nwe describe next. 8. Denotational semantics of PNA For each PNA type t, we de.ne a nominal Scott domain \n[t]by recursion on the structure of t as follows. [bool] = 2., the .at domain (cf. Remark 9) on a discrete \nnominal set with two elements, 2 = {true,false}.  [nat] = N., the .at domain on the discrete nominal \nset of natural numbers, N = {0,1,2,. . .}.  [t \u00d7 t ']= [t]\u00d7 [t '], the product of nominal Scott domains. \n [t -t ']= [t]-[t '], the nominal Scott domain of .nitely supported, uniform-continuous functions (Theorem \n12).  [name] = A., the .at domain on the nominal set of atomic names, A = {a, b, c, . . .}.  [term] \n= (.a)., the .at domain on the nominal set of a\u00adequivalence classes of .-terms [14, Theorem 6.2], .a \n{t ::= a |.a.t |t t}/= a (where a . A). (20)  [d t]= [A][t], the domain of name abstractions of the \nnominal Scott domain [t](Theorem 17).  Typing environments are interpreted as .nite cartesian products: \n[{x1 : t1 ,. . . , xn : tn}]= [t1]\u00d7\u00b7 \u00b7 \u00b7\u00d7[tn]. Finite tuples . . [G] can be interpreted as partial functions \nfrom variables to domains such that dom(.) = dom(G) and .(x) . [G(x)]for all x . dom(G). We call such \npartial functions G-environments. If . . [G], x ./dom(G) and d . [t], then we write .[x . d]for the (G, \nx : t)-environment that maps x to dand otherwise acts like .. For each well-typed expression G . e : \nt and G-environment . . [G]we de.ne an element [e]. . [t]satisfying the clauses in Figure 5, by recursion \nover the structure of e. 3 The clauses for syntax constructs from PCF are analogous to the standard denotational \nsemantics of PCF in Scott domains. The functions p1 and p2 in the clauses for fst e and snd e are the \n.rst and second projection functions for pairs. .x in the clause for fix e is the least .xed point function \n(9). The clauses below the dotted line in Figure 5 are for the new syntactic constructs of PNA. In the \nclauses involving expressions of type term, we use [t]a to denote the a-equivalence class of the syntax \ntree t of a .-term. We use the concretion function from (10) in the clause for concretion expressions \ne1 @ e2. The clause for .a. e makes use of the uniform\u00adcontinuous name restriction operation that each \n[t]has by virtue of Theorem 19. Note that the side conditions in the clauses for .a. e and aa. e are \nalways satis.able as we identify expression up to a-equivalence. One can reformulate these clauses without \nside 3Strictly speaking, it is by a-structural recursion [26] since we identify expressions up to a-equivalence \nof bound identi.ers. [x]. = . x [T]. = true [F]. = false . .[e2 ]. if [e1]. = true . [if e1 then e2 \nelse e3]. = [e3 ]. if [e1]. = false . . . otherwise [O]. = 0 n + 1 if [e]. = n . N [S e]. = . otherwise \nn if [e]. = n + 1 . N [pred e]. = . otherwise . .true if [e]. = 0 . N . [zero e]. = false if [e]. = n \n+ 1 . N . . . otherwise [(e1 , e2)]. = ([e1]., [e2].) [fst e]. = p1([e].) [snd e]. = p2([e].) [.x : t \n-e]. = .d . [t]. [e].[x . d] [e1 e2 ]. = [e1].([e2].) [fix e]. = .x([e].) . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . [a]. = \na [.a. e]. = a\\([e].) if a # . [(e1 . e2)e3]. = (a1 a2 )\u00b7 ([e3].) if [ei]. = ai . A (i = 1,2) . otherwise \neq a([e2].) if [e1]. = a . A[e1 = e2]. = . otherwise [a]a if [e]. = a . A [V e]. = . otherwise [t1 t2 \n]a if [ei]. = [ti]a . .a (i = 1,2) [A e1 e2]. = . otherwise [.a.t]a if [e]. = (a)[t]a . [A].a [L e]. \n= . otherwise [case e of (V x1 -e1 | A x2 x ' 2 -e2 | L x3 -e3)]. = . .[e1].[x1 . a] if [e]. = [a]a . \n. . '' ' [e2].[x2 . [t]a, x 2 . [t ]a] if [e]. = [t t ]a .[e3].[x3 . (a)[t]a] if [e]. = [.a.t]a . . . \n. otherwise [aa. e]. = (a)([e].) if a # . [e1 @ e2 ]. = ([e1].) @ ([e2].) Figure 5. PNA denotational \nsemantics  conditions [cf. 27, Figure 4] [.a. e]= a\\(.. . [G]. [e].) (21) [aa. e]= a\\(.. . [G]. (a)([e].)) \n(22) by appealing to the slightly subtle properties of the name restriction operation for exponential \ndomains (Remark 20). Notation 24. For the empty typing environment \u00d8, there is a unique \u00d8-environment, \n.0 . Given a variable-closed expression \u00d8 . e : t, we simply write [e]for [e].0. Using the developments \nfrom Sections 5 and 6 one can prove the following results. Lemma 25. The denotation of any well-typed \nPNA expression G . e : t is a well-de.ned, .nitely supported and uniform\u00adcontinuous function [e]: [G]. \n[t]. Lemma 26 (PNA soundness). If e . c, then [e]= [c]. Proof. The proof is by rule induction for ., \nusing the following properties of the denotational semantics whose proofs we omit. Substitution lemma \nIf G . e : t and G, x : t . e ' : t ' , then G . e ' [e/x] : t ' holds and for all . . [G] we have [e \n' [e/x]]. = [e ' ].[x . [e].].  Equivariance lemma p \u00b7 [e]= [p \u00b7 e].  Restriction lemma If a\\c := c \n' with c and c ' variable-closed canonical forms of type t, then the uniform-continuous name restriction \noperation de.ned on [t]as in Theorem 19 satis.es a\\[c]= [c ' ].  The following result allows one to \nestablish PNA contextual equivalences by proving equality of denotations. Theorem 27 (PNA computational \nadequacy). Given G . e : t ' ' ~' and G . e : t, if [e]= [e ]. [G]-[t], then G . e =PNA e : t. Proof. \nIt is not hard to see that the denotational semantic is com\u00adpositional, in the sense that [e]= [e ' ]. \n[C[e]]= [C[e ' ]]. So in view of Lemma 26 it suf.ces to show that if e is a variable-closed expression \nof type bool, then [e]= true . e . T. (23) We prove this by devising a suitable logical relation d .t \ne (d . [t], \u00d8 . e : t) (24) between the semantics and the syntax of PNA. (See Streicher [38, Chapter \n4] for a good exposition of this method of proving computational adequacy for the Scott domain model \nof PCF.) The de.nition of .t is by recursion on the structure of the type t: d .. e d = . . (.c)e . c \n. [c]= d for . = bool,nat,name,term (d1, d2 ).t1 \u00d7t2 e d1 .t1 fst e . d2 .t2 snd e d .t1 .t2 e (.d1, \ne1)d1 .t1 e1 . d d1 .t2 e e1 d .d t e (a)d@a .t e @ a. is not straightforward, and we omit the details \nhere. Armed with those properties, the fundamental property of the logical relation follows by induction \non the structure of expressions; in particular we get \u00d8 . e : t . [e].t e. This, combined with the de.nition \nof .bool yields (23). Using Theorem 27 we can prove many contextual equivalences in PNA, such as those \nin Example 23, in a straightforward manner via the denotational semantics. For example (18) is proved \nby the following argument. Since we identify expressions up to a\u00adequivalence, for any given a ' . A we \ncan pick a representative expression .a. .x : name -(x = a)such that a = a ' , then [.a. .x : name -(x \n= a)]a ' = (a\\[.x : name -(x = a)])a ' by de.nition in Figure 5 = a\\([.x : name -(x = a)]a ' ) by (13), \nsince a = a ' = a\\false as a = a ' = false = [.x : name -if x = x then F else F]a ' . Similarly [.a. \n.x : name -(x = a)]. = . = [.x : name \u00adif x = x then F else F].. Hence [.a. .x : name -(x = a)]= [.x \n: name -if x = x then F else F]and so (18) holds by Theorem 27. To prove example (19) one can combine \nthe de.nition in Figure 5 with the fact that if a, a ' # f . (A. -2.)-2., then f a = f((a a ' )\u00b7 a ' \n)= (a a ' )\u00b7 (f a ' )= f a ' (since f a ' . 2.). In contrast to the situation here, properties like (18) \nand (19) for the .-calculus, which uses generative rather than Odersky-style local names, can be hard \nto establish whether one uses operational or denotational techniques. See Tzevelekos [43], which focusses \non an equivalence like (19). 9. Full abstraction for PNA+ Plotkin [30] famously proves that the Scott \ndomain model of PCF is computationally adequate, but not fully abstract: equality of de\u00adnotations implies, \nbut is not implied by, PCF contextual equiva\u00adlence. Furthermore, he shows that the Scott model becomes \nfully abstract once one extends PCF with a parallel-or construct. Moving to nominal Scott domains and \nPNA, Plotkin s negative result can certainly be extended to show that the converse of Theo\u00adrem 27 fails \nto hold. We do not yet know what happens if one adds just parallel-or to PNA (see Section 10). However, \nadding not only parallel-or, but also operational versions of the uniform-compact functionals in Examples \n14 and 15, we will show that the nominal Scott domain model is fully abstract for contextual equivalence \nin the extended language. Note that this section does not give a full abstraction result for the more \ncommon generative local names used for example in FreshML or the .-calculus. Generative names can be \nmodelled adequately in Nsd through a continuation monad as described at the end of Section 6, but full \nabstraction fails in this model, because of the results of Stark [36, Page 66]. N The de.nition is standard \nexcept for the last clause, which is for De.nition 28. The language PNA+ is obtained by extending PNA \nname abstraction types. There we use the freshness quanti.er ( a) with expressions for parallel-or, for \nexistentially quantifying over N of nominal logic [25]. Thus d .d t e holds if and only if d@a .t e@ \na holds for some a # (d, e), or equivalently, for any a # (d, e). The proof that this logical relation \nis closed under restriction, abstraction and concretion d .t e . (.a)a\\d .t .a. e (25) d .t e . (.a)(a)d \n.d t aa. e (26) d .d t e . (.a)d@a .t e @ a (27) name ( there exists some x : name such that. . . ) \nand for form\u00ad ing de.nite descriptions over name ( the unique x : name such that. . . ). The syntax, \ntyping and evaluation rules for this extension are given in Figure 6. Contextual equivalence for the \nextended lan\u00adguage G . e ~e ' : t is de.ned in the same way as it is for = PNA+ PNA in De.nition 22. \nRemark 29. The addition of existential quanti.cation and de.nite description is mainly motivated by the \nneed for them in our proof of  e ::= expressions \u00b7 \u00b7 \u00b7 (as for PNA) e por e parallel-or ex x. e existential \nname quanti.cation the x. e de.nite name description G . e1 : bool G . e2 : bool G . e1 por e2 : bool \nG, x : name . e : bool G, x : name . e : bool G . ex x. e : bool G . the x. e : name e1 . T e2 . T e1 \n. F e2 . F por e1 e2 . T e1 por e2 . T e1 por e2 . F e[a/x]. T a ' # e (.b . fn(e). {a ' })e[b/x]. F \nex x. e . T ex x. e . F e[a/x]. T a ' # (e, a) (.b . (fn(e)- {a}). {a ' })e[b/x]. F the x. e . a [e1 \npor e2]. = por ([e1 ].)([e2].) [ex x. e]. = exists A([.x : name -e].) [the x. e]. = the A ([.x : name \n-e].) Figure 6. PNA+ full abstraction (Theorem 30). Existential quanti.cation for num\u00adbers (rather than, \nas here, for names) occurs in Plotkin s original PCF paper [30], and de.nite description has a long history \nin logic, but it is harder to motivate from a programming language perspec\u00adtive. In fact, a de.nite description \nfunctional for numbers rather than for names is not computable. The computability of ex x. e and the \nx. e provide an example of the phenomenon of .nite modulo symmetry mentioned in the Introduction. For \nexample, to prove ex x. e . F, we just have to pick one of the in.nitely many atomic names a ' that do \nnot occur free in e and then show e[a ' /x]. F and e[b/x] . F for each of the .nitely many atomic names \nb that do occur free in e. This works because the equivariance property (16) of evaluation implies that \nif e[a ' /x] . F, then e[a '' /x] . F holds for any a '' not occurring free in e. The denotational semantics \nof PNA+ expressions is given by extending the de.nition in Figure 5 with the clauses at the bottom of \nFigure 6. Here por . K(2. -2. -2.)is the usual parallel-or function satisfying . .true if d = true or \nd ' = true . por d d ' = false if d = false and d ' = false . . . otherwise; exists A . K((A. -2.)-2.)is \nas in Example 14, and the A . K((A. -2.)-A.)is as in Example 15. Theorem 30 (full abstraction for PNA+). \nFor all well-typed expressions G . e : t and G . e ' : t in PNA+, we have [e]= [e ' ]. [G]-[t]. G . e \n~e ' : t. (FAt) = PNA+ The sketch of the proof of this result occupies the rest of this section. The \nextension of Theorem 27 to PNA+ is straightforward and gives us the left-to-right implication in (FAt). \nEstablishing the re\u00adverse implication inevitably leads to an investigation of the de.n\u00adability of elements \nof the nominal Scott domain model by PNA+ expressions. However, our proof of the right-to-left implication \nin (FAt) does not exactly follow any of the proof patterns linking de.nability with full abstraction \nsurveyed by Curien [10]. In par\u00adticular, we only know that the uniform-compact elements of the nominal \nScott domain [t]are de.nable in PNA+ for certain types that avoid the use of function types t1 -t2 in \nwhich the nominal Scott domain [t2]might contain elements with non-empty support. So t2 = nat is OK, \nbut t2 = name is not, for example. This leads us to make the following de.nition. De.nition 31 (simple \ntypes). Let Styp . Typ be the subset of the collection of types (Figure 1) given by the following grammar: \ns ::= nat |name |s\u00d7 s |s -nat. The following lemma is the key to the usefulness of simple types. It is \nwhere the presence of the x. e expressions in PNA+ gets used. Lemma 32. Any type t is a PNA+-de.nable \nretract of a simple type s . Styp, meaning that there are closed PNA+ expressions \u00d8 . i : t -s and \u00d8 \n. r : s -t with [.x : t -r (i x)]= id[t]. Proof. First note that because name abstraction satis.es a \nform of .-expansion ([aa. (e @ a)] = [e], if a ./fn(e)), each d t is a PNA+-de.nable retract of name \n-t (PNA-de.nable, in fact), via i .x : d t -.y : name -x @ y (28) r .(f : name -t)-aa. f a (29) (cf. \n[27, Theorem 2.13]). Secondly, using the x. e expressions, we also have that name itself is a PNA+-de.nable \nretract of name -nat, via i .x : name -.y : name -if x = y then O else S O r .(f : name -nat)-the x. \nzero (f x). Thirdly, again using the x. e expressions, one can also show that term is a PNA+-de.nable \nretract of nat \u00d7 (name -nat) (proof omitted). Finally, it is not hard to see that bool is a PNA+ \u00adde.nable \n(actually PCF-de.nable) retract of nat. Using these four facts, one can proceed by induction on the structure \nof types to show that each t is a PNA+-de.nable retract of some simple type. Lemma 33. If t is a PNA+-de.nable \nretract of s, then full ab\u00adstraction at s implies full abstraction at t, i.e. (FAs). (FAt). Proof. Given \ni and r as in Lemma 32, suppose (FAs)holds and that G . e ~e ' : t, then we have G . i e ~i e ' : s = \nPNA+ = PNA+ by compositionality of ~ = PNA+ . Thus by (FAs), for any . . [G] we have [i]([e].) = [i e]. \n= [i e ' ]. = [i]([e ' ].). We know that [i]is injective since it has a left inverse [r], and hence (.. \n. [G])[e]. = [e ' ].. Thus [e]= [e ' ]. [G]-[t]. Combining these two lemmas, to prove Theorem 30 it suf.ces \nto show that (FAs)holds for all simple types s . Styp. As sur\u00adveyed in Curien [10], this follows from \nde.nability of all uniform\u00adcompact elements of the nominal Scott domains [s]. That is, for all u . K[s]we \nwish to prove that u = [e]for some variable-closed PNA+ expression \u00d8 . e : s. Remark 34 (de.nability \nof uniform-compact elements). Are all the uniform-compact elements of the nominal Scott domain [t] de.nable \nin PNA+, for any type t? We introduced simple types because we did not .nd a way to prove such a de.nability \nresult at all types. We succeed in showing uniform-compact de.nability at simple types essentially because \nthe codomains of simple functions are restricted to nat, which makes life much easier in this setting. \nIf all the de.nable retracts used in our proof of Theorem 30 were actually de.nable embedding-projection \npairs (in the sense that [.x : s -i(r x)] . id[s] holds), then uniform-compact de.n\u00adability at simple \ntypes would immediately imply uniform-compact de.nability at any type.4 Unfortunately for name abstraction \ntypes,  (28) and (29) do not form an embedding-projection pair. There re\u00admains the possibility that \nembedding-projection pairs as above can be used to show uniform-compact de.nability at all types for \na sim\u00adpler language without name abstraction, such as the ..-calculus of Odersky [24] extended with .xed \npoints. The proof of uniform-compact de.nability at simple types in principle follows the structure of \nthe traditional proof by Plotkin [30]. A modern account of this proof can be found in Streicher s book \n[38]. However, in our nominal setting many uses of .nite subsets in the traditional proof are replaced \nby uses of orbit-.nite subsets and their presentation as orbit-.nite hulls (Theorem 8). The de.nition \nof hullAF involves existential quanti.cation over .nite permutations of A, and for the de.nability proof \nwe need to reduce this to existential quanti.cation over elements of A. This is where the presence of \nex x. e expressions in PNA+gets used (along with a traditional use of por) to prove the following two \ncrucial lemmas. Neither is trivial to prove. In particular Lemma 36 works by a subtle case distinction \nover all the different ways the atomic names in the supports of u and u ' can overlap. Lemma 35. hullA{[u \n, true]}is PNA+-de.nable for every s . Styp, u . K[s]and A .f A. Lemma 36. Suppose that s . Styp satis.es \nfor all v, v ' . K[s]that do not have an upper bound in [s], [v , true] .[v ' , false] is PNA+-de.nable. \n Then hullA{[u , true],[u ' , false]}is PNA+-de.nable for any u, u ' . K[s]and A .f A satisfying: for \nall .nite permutations p : A ~A satisfying p # A (see = De.nition 7), it holds that u and p \u00b7 u ' do \nnot have an upper bound in [s]. Using these two lemmas one can show by simultaneous induc\u00adtion on the \nstructure of s . Styp that u and [u , true] are de.nable for all uniform-compact elements u . K[s], \nand  [u , true] .[u ' , false] is de.nable whenever u, u ' . K[s]are uniform-compact elements that do \nnot have an upper bound in [s].  Most of the work lies in the case for functions types, which for simple \ntypes are of the form, s -nat. By Theorem 8 and 12 each uniform-compact element u of [s -nat]can be represented \nby u = hullAF for some A .f A, F = {[u1 , n1 ],.., [uk , nk]}, u1 ,.., uk . K[s]and n1 ,.., nk . N. \nOne has to perform another induction on the size of F and make a case distinction based on the ' ' '' \n'' existence of [u , n ],[u , n ] . F such that for all p # A the compact elements u ' and p\u00b7 u '' have \nno upper bound in [s]. Using Lemmas 35 and 36 the proof goes through following the structure of Streicher \n[38, Theorem 13.9], thereby showing full abstraction for PNA+ . 10. Open problems 1. Failure of full \nabstraction in the nominal Scott domain model. Is Nsd fully abstract for just PNA+por? Is it necessary \nto add 4Thanks to a referee for pointing this out. both ex x. e and the x. e to PNA+por in order to obtain \nfull abstraction? We do not yet have examples of contextually equivalent expres\u00adsions in PNA+por, PNA+por+ex, \nor PNA+por+the that have different denotations in Nsd. Probably the method of log\u00adical relations can \nbe adapted to establish such contextual equiv\u00adalences, but we have yet to pursue this. 2. Is there a \nfully abstract model of PNA based on games in nominal sets? Just as PCF is of more interest from a programming \npoint of view than PCF+por, we regard PNA (suitably extended with recursive types) as a pure version \nof FreshML that is poten\u00adtially useful for functional programming with syntactical data involving binders. \nGame semantics provided an interesting so\u00adlution for the original full abstraction problem for PCF [4, \n16], and its nominal version has provided computationally useful, fully abstract models of generative \nlocal state [3, 18, 23, 41]. Can nominal game semantics provide a similar thing for PNA? 3. Is there \na nominal Scott domain semantics for the form of nominal computation embodied by the N.language [6]? \nWith N., Boja\u00b4nczyk et al. extend the simply-typed .-calculus with a collection type representing orbit-.nite \nsubsets (Sec\u00adtion 2) via a syntax for orbit-.nite hulls (De.nition 7).5 It is natural to consider adding \n.xed point recursion to this language, with a denotational semantics using nominal domains rather than \nnominal sets. The denotational semantics of such an exten\u00adsion of N. will require the development of \norbit-.nite power domains FnD in Nsd, whose uniform-compact elements are orbit-.nite subsets of the uniform-compact \nelements of D. 4. What recursive domain equations can be solved in Nsd? In his thesis, Shinwell [33, \nSection 4.5] shows that the tradi\u00adtional method for constructing minimally invariant solutions for locally \ncontinuous functors of mixed variance can be applied to the simple notion of nominal domain given by \nnominal posets with joins of .nitely supported .-chains. This can be extended to udcpos and we expect \nit can also be used for nominal Scott domains, but we have yet to check the details. An interesting alternative \napproach is to develop a nominal version of Scott s information systems [32] and construct solutions \nfor recursive domain equations via inductively de.ned nominal sets of in\u00adformation tokens. We have begun \nto develop such a theory of nominal Scott information systems in which the role of .nite sets is replaced \nby orbit-.nite nominal sets [unpublished]. From a logical point of view [2], nominal information systems \nare presentations of non-trivial nominal posets with all orbit-.nite meets, rather than just .nite meets. \nWe expect this machinery can be used to good effect for the orbit-.nite power domain construct mentioned \nabove, as well as for a version for nominal Scott domains of Moggi s monad for dynamic allocation [21, \nSection 4.14] featuring a freely generated uniform-continuous name restriction operation [27, Remark \n2.8]. 11. Conclusion The results in this paper provide further evidence for how a seman\u00adtic theory (domain \ntheory in this case) is enhanced by using nom\u00adinal sets: we gain the ability to model constructs involving \nnames and their symmetries while preserving many aspects of the classi\u00adcal theory. The complications \narising from the use of nominal sets 5Their paper [6] is concerned with general Fra\u00a8iss\u00b4e nominal sets \n. Here we restrict our attention to the equality symmetry and nominal sets in the original sense.  are \nfeasible and somehow orthogonal to the other developments. At the same time, their use gives access to \nnew constructs that are far from trivial. This is the case for the notion of orbit-.nite subset, which \nformalizes the important idea of .niteness modulo symme\u00adtry within nominal sets. We agree with Boja\u00b4nczyk \net al. [6] that this is an important notion with many potential applications. Here we have used it to \ndevelop a nominal domain theory that, via our full abstraction result, has a good .t with higher-type \ncomputation involving local names and name abstractions. Acknowledgments L\u00a8osch gratefully acknowledges \nthe support of a Gates Cam\u00adbridge Scholarship. This research was also supported by ERC Advanced Grant \nEvents, Causality and Symmetry (ECSYM). We thank Michael D. Adams and the anonymous referees for their \nhelpful comments. References [1] URL http://www.citeulike.org/group/11951/. [2] S. Abramsky. Domain theory \nin logical form. Annals of Pure and Applied Logic, 51:1 77, 1991. [3] S. Abramsky, D. R. Ghica, A. S. \nMurawski, C.-H. L. Ong, and I. D. B. Stark. Nominal games and full abstraction for the nu-calculus. In \nProc. LICS 2004, pages 150 159. IEEE Computer Society Press, 2004. [4] S. Abramsky, R. Jagadeesan, and \nP. Malacaria. Full abstraction for PCF. Information and Computation, 163(2):409 470, 2000. [5] S. Abramsky \nand A. Jung. Domain theory. In Handbook of Logic in Computer Science, Volume 3. Semantic Structures, \nchapter 1. Oxford University Press, 1994. [6] M. Boja \u00b4nczyk, L. Braud, B. Klin, and S. Lasota. Towards \nnominal computation. In Proc. POPL 2012, pages 401 412. ACM Press, 2012. [7] M. Boja \u00b4nczyk, B. Klin, \nand S. Lasota. Automata with group actions. In Proc. LICS 2011, pages 355 364. IEEE Computer Society \nPress, 2011. [8] M. Boja \u00b4nczyk and S. Lasota. A machine-independent characterization of timed languages. \nIn Proc. ICALP 2012, Part II, volume 7392 of LNCS, pages 92 103. Springer-Verlag, 2012. [9] V. Ciancia \nand U. Montanari. Symmetries, local names and dynamic (de)-allocation of names. Information and Computation, \n208(12): 1349 1367, 2010. [10] P.-L. Curien. De.nability and full abstraction. In Computation, Meaning \nand Logic, Articles dedicated to Gordon Plotkin, volume 172 of ENTCS, pages 301 310. Elsevier, 2007. \n[11] M. J. Gabbay. A study of substitution, using nominal techniques and Fraenkel-Mostowski sets. Theoretical \nComputer Science, 410(12 13): 1159 1189, 2009. [12] M. J. Gabbay. Foundations of nominal techniques: \nLogic and seman\u00adtics of variables in abstract syntax. Bulletin of Symbolic Logic, 17(2): 161 229, 2011. \n[13] M. J. Gabbay and V. Ciancia. Freshness and name-restriction in sets of traces with names. In Proc. \nFOSSACS 2011, volume 6604 of LNCS, pages 365 380. Springer-Verlag, 2011. [14] M. J. Gabbay and A. M. \nPitts. A new approach to abstract syntax with variable binding. Formal Aspects of Computing, 13:341 363, \n2002. [15] F. Gadducci, M. Miculan, and U. Montanari. About permutation alge\u00adbras, (pre)sheaves and named \nsets. Higher-Order Symb. Computation, 19:283 304, 2006. [16] J. M. E. Hyland and C.-H. L. Ong. On full \nabstraction for PCF: I, II and III. Information and Computation, 163(2):285 408, 2000. [17] P. T. Johnstone. \nSketches of an Elephant, A Topos Theory Com\u00adpendium, Volumes 1 and 2. Number 43 44 in Oxford Logic Guides. \nOxford University Press, 2002. [18] J. Laird. A game semantics of names and pointers. Annals of Pure \nand Applied Logic, 151(2):151 169, 2008. [19] S. L\u00a8osch and A. M. Pitts. Relating Two Semantics of Locally \nScoped Names. In Proc. CSL 2011, volume 12 of Leibniz International Proceedings in Informatics (LIPIcs), \npages 396 411, 2011. [20] G. Markowsky. Chain-complete p.o. sets and directed sets with appli\u00adcations. \nAlgebra Universalis, 6:53 68, 1976. [21] E. Moggi. An abstract view of programming languages. Technical \nRe\u00adport ECS-LFCS-90-113, Department of Computer Science, University of Edinburgh, 1989. [22] U. Montanari \nand M. Pistore. p-Calculus, structured coalgebras and minimal HD-automata. In Proc. MFCS 2000, volume \n1893 of LNCS, pages 569 578. Springer-Verlag, 2000. [23] A. S. Murawski and N. Tzevelekos. Algorithmic \ngames for full ground references. In Proc. ICALP 2012, Part II, volume 7392 of LNCS, pages 312 324. Springer-Verlag, \n2012. [24] M. Odersky. A functional theory of local names. In Proc. POPL 1994, pages 48 59. ACM Press, \n1994. [25] A. M. Pitts. Nominal logic, a .rst order theory of names and binding. Information and Computation, \n186:165 193, 2003. [26] A. M. Pitts. Alpha-structural recursion and induction. Journal of the ACM, 53:459 \n506, 2006. [27] A. M. Pitts. Structural recursion with locally scoped names. Journal of Functional Programming, \n21(3):235 286, 2011. [28] A. M. Pitts and M. J. Gabbay. A metalanguage for programming with bound names \nmodulo renaming. In Proc. MPC 2000, volume 1837 of LNCS, pages 230 255. Springer-Verlag, 2000. [29] A. \nM. Pitts and I. D. B. Stark. Observable properties of higher order functions that dynamically create \nlocal names, or: What s new? In Proc. MFCS 1993, volume 711 of LNCS, pages 122 141. Springer-Verlag, \n1993. [30] G. D. Plotkin. LCF considered as a programming language. Theoreti\u00adcal Computer Science, 5:223 \n255, 1977. [31] F. Pottier. Static name control for FreshML. In Proc. LICS 2007, pages 356 365. IEEE \nComputer Society Press, 2007. [32] D. S. Scott. Domains for denotational semantics. In Proc. ICALP 1982, \nvolume 140 of LNCS, pages 577 613. Springer-Verlag, 1982. [33] M. R. Shinwell. The Fresh Approach: Functional \nProgramming with Names and Binders. PhD thesis, University of Cambridge, 2005. [34] M. R. Shinwell and \nA. M. Pitts. On a monadic semantics for freshness. Theoretical Computer Science, 342:28 55, 2005. [35] \nM. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: Program\u00adming with binders made simple. In Proc. \nICFP 2003, pages 263 274. ACM Press, 2003. [36] I. D. B. Stark. Names and Higher-Order Functions. PhD \nthesis, University of Cambridge, Dec. 1994. [37] S. Staton. Name-Passing Process Calculi: Operational \nModels and Structural Operational Semantics. PhD thesis, University of Cam\u00adbridge, 2007. [38] T. Streicher. \nDomain-Theoretic Foundations of Functional Program\u00adming. World Scienti.c, Singapore, 2006. [39] D. C. \nTurner. Nominal Domain Theory for Concurrency. PhD thesis, University of Cambridge, 2009. [40] D. C. \nTurner and G. Winskel. Nominal domain theory for concurrency. In Proc. CSL 2009, volume 5771 of LNCS, \npages 546 560. Springer-Verlag, 2009. [41] N. Tzevelekos. Nominal Game Semantics. PhD thesis, University \nof Oxford, 2008. [42] N. Tzevelekos. Fresh-register automata. In Proc. POPL 2011, pages 295 306. ACM \nPress, 2011. [43] N. Tzevelekos. Program equivalence in a simple language with state. Computer Languages, \nSystems and Structures, 38(2):181 198, 2012.  \n\t\t\t", "proc_id": "2429069", "abstract": "<p>We develop a domain theory within nominal sets and present programming language constructs and results that can be gained from this approach. The development is based on the concept of orbit-finite subset, that is, a subset of a nominal sets that is both finitely supported and contained in finitely many orbits. This concept appears prominently in the recent research programme of Bojanczyk et al. on automata over infinite languages, and our results establish a connection between their work and a characterisation of topological compactness discovered, in a quite different setting, by Winskel and Turner as part of a nominal domain theory for concurrency. We use this connection to derive a notion of Scott domain within nominal sets. The functionals for existential quantification over names and `definite description' over names turn out to be compact in the sense appropriate for nominal Scott domains. Adding them, together with parallel-or, to a programming language for recursively defined higher-order functions with name abstraction and locally scoped names, we prove a full abstraction result for nominal Scott domains analogous to Plotkin's classic result about PCF and conventional Scott domains: two program phrases have the same observable operational behaviour in all contexts if and only if they denote equal elements of the nominal Scott domain model. This is the first full abstraction result we know of for higher-order functions with local names that uses a domain theory based on ordinary extensional functions, rather than using the more intensional approach of game semantics.</p>", "authors": [{"name": "Steffen L&#246;sch", "author_profile_id": "81553054956", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P3977905", "email_address": "steffen.loesch@cl.cam.ac.uk", "orcid_id": ""}, {"name": "Andrew M. Pitts", "author_profile_id": "81100104445", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P3977906", "email_address": "andrew.pitts@cl.cam.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429073", "year": "2013", "article_id": "2429073", "conference": "POPL", "title": "Full abstraction for nominal Scott domains", "url": "http://dl.acm.org/citation.cfm?id=2429073"}