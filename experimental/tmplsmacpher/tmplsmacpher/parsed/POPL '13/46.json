{"article_publication_date": "01-23-2013", "fulltext": "\n Subjective Auxiliary State for Coarse-Grained Concurrency Ruy Ley-Wild Aleksandar Nanevski IMDEA Software \nInstitute {ruy.leywild, aleks.nanevski}@imdea.org Abstract From Owicki-Gries Resource Invariants and \nJones Rely/Guarantee to modern variants based on Separation Logic, axiomatic logics for concurrency require \nauxiliary state to explicitly relate the effect of all threads to the global invariant on the shared \nresource. Un\u00adfortunately, auxiliary state gives the proof of an individual thread access to the auxiliaries \nof all other threads. This makes proofs sensitive to the global context, which prevents local reasoning \nand compositionality. To tame this historical dif.culty of auxiliary state, we propose subjective auxiliary \nstate, whereby each thread is veri.ed using a self view (i.e., the thread s effect on the shared resource) \nand an other view (i.e., the collective effect of all the other threads). Subjectivity generalizes auxiliary \nstate from stacks and heaps to user-chosen partial commutative monoids, which can eliminate the dependence \non the global thread structure. We employ subjectivity to formulate Subjective Concurrent Separation \nLogic as a combination of subjective auxiliary state and Concurrent Separation Logic. The logic yields \nsimple, compo\u00adsitional proofs of coarse-grained concurrent programs that use aux\u00adiliary state, and scales \nto support higher-order recursive procedures that can themselves fork new threads. We prove the soundness \nof the logic with a novel denotational semantics of action trees and a de.nition of safety using rely/guarantee \ntransitions over a large subjective footprint. We have mechanized the denotational seman\u00adtics, logic, \nmetatheory, and a number of examples by a shallow embedding in Coq. Categories and Subject Descriptors \nD.2.4 [Software Engineer\u00ading]: Program Veri.cation Correctness proofs; D.3.3 [Program\u00adming Languages]: \nLanguage Constructs and Features Concurrent programming structures Keywords concurrency, veri.cation, \nlocal reasoning, rely-guarantee thinking, dependent type theory 1. Introduction Auxiliary state (a.k.a. \nghost state) is a necessary evil that compen\u00adsates for the expressive weakness [13] of axiomatic program \nlog\u00adics for concurrency. It is necessary in proofs to partially expose the internal behavior of threads \nin order to relate local program assertions to global invariants, and in the metatheory to establish \ncompleteness [20]. But it is evil because the proof of an individual Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 13, January 23 25, 2013, Rome, Italy. \nCopyright &#38;#169; 2013 ACM 978-1-4503-1832-7/13/01. . . $10.00 {y > a * z> \u00df} {y > a} {z > \u00df }  \n {y > a * .\u00df.I2(a, \u00df )} {z > \u00df * .a.I2(a, \u00df)} x := [x] + 1; y := [y] + 1; x := [x] + 1; z := [z] + 1; \n{y > a+1 * .\u00df.I2(a+1, \u00df)} {z > \u00df+1 * .a.I2(a, \u00df+1)} {y > a+1} {z > \u00df +1} {y > a+1 * z> \u00df+1} Figure 1. \nTwo incr threads in Concurrent Separation Logic with fractional permissions. thread becomes sensitive \nto the global thread structure of the con\u00adtext in which it is used. This prevents local reasoning and \nlimits the compositionality of all logics that use auxiliary state. We illustrate the problem of auxiliary \nstate through the classical concurrent incrementor example of Owicki and Gries. The program incr(n) .(x \n:= = [x] + n) enters a critical section (-) to gain access to the shared state x and increment it by \nn. We want to verify incr with a compositional speci.cation that can be used to deduce the overall effect \non x by several incr s in parallel. For example, if k threads concurrently call incr(1), we should be \nable to deduce that the overall effect is for x to increment by k. In Owicki and Gries Resource Invariants \n(RI) [21], the shared state is speci.ed by a resource invariant I that holds whenever all threads are \noutside the critical section. By mutual exclusion, when a thread enters a critical section it acquires \nexclusive access to the shared state satisfying the invariant. It may mutate the shared state and violate \nthe invariant, but it must restore the invariant before releasing the resource and leaving the critical \nsection. RI is notably useful for coarse-grained concurrency, where interference is con.ned to critical \nsections. Because the invariant abstracts away from having to reason explicitly about concurrent interference, \nRI enables sequential reasoning about individual threads. An invariant that only refers to x, however, \nhas no way to identify each thread s effect on the total value, thus, at best it can show that x increments \nby an unspeci.ed amount. This suf.ces to prove memory safety, but not to deduce a noninvariant property \nsuch as x increments by k. Owicki and Gries solution (and most axiomatic logics follow suit) is for each \nthread to have auxiliary state that exposes its effect on the shared state to the invariant; auxiliaries \nare updated for the sake of veri.cation, but aren t needed for execution. For two parallel incr threads, \nin Concurrent Separation Logic (CSL) [19] with fractional permissions [1] (Figure 1), the binary invariant \nI2(a, \u00df) =.x . a+\u00df *y > a *z> \u00df says that the shared state x contains the sum a+\u00df, auxiliary state y \ncaptures the .rst thread s cumulative effect on (i.e., contribution to) x, and likewise z for the second \nthread.1 Ownership of an auxiliary is split in half 1 We take Separation Logic heaps as our model of \nstate. The separating conjunction p*q means that the heap splits into disjoint subheaps that satisfy \n between the invariant and the owning thread, to ensure that only the owner can update the auxiliary. \nThe program is instrumented with shaded code to update auxiliaries, and with {braced} assertions that \nsay what holds at speci.c program points. The .nal assertion and the invariant imply that x increments \nby 2. However, if instead we wanted to prove the effect of three par\u00adallel increments, we would have \nto use a different ternary invariant I3(a, \u00df, . ) = x . a+\u00df+. *y > a *z > \u00df *w > .. Even though the two-thread \nprogram is a subprogram of the three-thread one, the former s proof is speci.c to the binary invariant \nI2 and cannot be reused in the latter s proof. Thus, in RI and its logical descendants such as CSL, even \na simple program as incrementation lacks a sin\u00adgle proof that can be reused in different contexts. In \nthis sense, axiomatic proofs with auxiliary state have limited compositionality: it is not always possible \nto prove a subprogram and reuse its proof directly in a larger context. The problem is that when an invariant \nmentions auxiliary state, the auxiliaries reveal thread identities (e.g., w in I3 identi.es the new thread). \nThere\u00adfore, when the veri.cation of a thread sees the invariant in the critical section, it becomes dependent \non the global thread struc\u00adture, which breaks local reasoning. Even worse, when threads are forked dynamically \n(e.g., an iterator forks a separate thread to pro\u00adcess each element in a list), the invariant must be \nde.ned in terms of dynamically-allocated auxiliary state that mirrors the forking pat\u00adtern, which makes \nthe invariant even more context speci.c. For .ne-grained concurrency, where interference may occur between \nany two memory operations, Jones Rely/Guarantee (RG) [12] explicitly speci.es thread and environment \ninterference on the shared state. This can reduce and sometimes even eliminate the auxiliary state required \nin RI proofs. However, RG and most of its logical descendants (e.g., RGSep [26], SAGL [9], Deny-Guarantee \n[7]) still require noncompositional auxiliary state for the incrementor. To our knowledge, the only exceptions \nare Concurrent Abstract Predicates (CAP) [6] and HLRG [10], which can verify the incrementor without \nauxiliary state. However, both logics use RG-style speci.cations that impose complex reasoning about \ninter\u00adference explicitly in the proof. We consider this should be avoided for reasoning about any coarse-grained \nalgorithm, because critical sections are used exactly to abstract away from interference. We present \nSubjective Concurrent Separation Logic (SCSL), a prototype logic for a stateful language with higher-order \nrecur\u00adsive procedures, fork-join concurrency, and a lock-protected criti\u00adcal section (Section 4). SCSL \ncombines the classical techniques of Resource Invariants and Separation Logic, and tames the dif.cul\u00adties \nof auxiliary state with a novel subjective perspective. Subjective auxiliary state gives two complementary \nthread\u00adoriented views on auxiliary state: a self view aS of the thread s own auxiliary contribution, \nand an other view aO that agglomerates all other threads contributions. To eliminate the dependency on \nthe number of threads in the environment, subjective auxiliary state generalizes from stack variables \nand heap locations to a user\u00adchosen partial commutative monoid (PCM). For various examples, choosing \nan optimized PCM can blur the global thread structure, in contrast to auxiliary stacks or heaps. Since \nstacks and heaps are PCMs [4], subjective auxiliary state subsumes classical auxiliary state. Thus, when \na suitable auxiliary PCM cannot be found, a proof can always fall back on using an auxiliary stack or \nheap. p and q that are passed to each subthread of a parallel composition; i > v is a half fractional \npermission that allows dereferencing i with contents v; i > v * i > v is equivalent to i . v, which also \nallows updating i. Strictly speaking, the invariant is the unparameterized assertion .a..\u00df.I2(a, \u00df) where \nthe auxiliary contributions a and \u00df are existentially quanti.ed; we concentrate on the parameterized \nI2 to simplify the presentation and omit the details of how fractional permissions relate the free and \nbound variables. Intuitively, subjectivity synthesizes the thread/environment di\u00adchotomy espoused by \nRely/Guarantee and the PCM structure of state elucidated by Separation Logic. In contrast to the temporal \nemphasis of Rely/Guarantee transitions, subjective auxiliary state creates a spatial dichotomy between \nthread and environment aux\u00adiliaries. In contrast to the exclusively local, small footprint, view of state \nin Separation Logic, the aO view of the environment em\u00adbodies non-local information about the run-time \ncontext, but the PCM-agglomeration makes it abstract enough to retain the CSL\u00adstyle local reasoning. \nThe critical point concerns how to combine proofs of two threads into a proof of their parallel composition. \nWhen one thread updates its aS, then it implicitly also updates another thread s aO. How do we ensure \nthat the proof of the other thread remains a valid subproof in the combination, when it sees its aO view \nchange? We resolve this question by proving a CSL-style rule of parallel composition with a novel subjective \nseparating conjunction con\u00adnective \u00ae for splitting auxiliary views. The rule ensures that if the initial \nviews of two threads are coherent at the fork point, then there exists a coherent combination of the \nviews at the join point. This suf.ces to use the proofs of threads as black boxes and establish the combined \nveri.cation of their parallel composition. We also prove a frame rule with \u00ae that surprisingly does not \nrequire cancellativity of the auxiliary PCM. We show that SCSL yields simple, compositional proofs for \na few coarse-grained concurrent programs from the literature (Sec\u00adtions 2 and 3). Although the programs \nare relatively simple, their proofs in existing logics either require auxiliaries which leads to noncompositionality, \nor can avoid auxiliaries but are technically complex. Moreover, we show that SCSL scales to higher-order \nre\u00adcursive procedures which can themselves fork new thread, depend\u00ading on run time values; to our knowledge, \nthis combination is not supported by any existing logic2. Although we focus on RI proofs for coarse-grained \nconcurrency, we believe subjectivity will also synergize well with RG for .ne-grained concurrency. We \ngive SCSL a novel denotational model that represents com\u00adputations as action trees and establish soundness \nof the logic by a de.nition of safety that crucially relies on subjectivity, not only of the user-chosen \nauxiliary PCM, but also of heap and lock own\u00adership (Section 5). We embed SCSL into the higher-order \nlogic Calculus of Inductive Constructions [18], and thus inherit a num\u00adber of features from dependent \ntype theory: abstraction over pro\u00adgrams (i.e., higher-order procedures), types (i.e., polymorphism), \nand predicates (i.e., datatypes, objects, modules). These features are essential for modular programming \nand veri.cation, but, aside from abstract predicates [22, 6], have not been considered in the axiomatic \nconcurrency logic literature. The embedding allowed us to mechanize the semantics, logic, soundness proof, \nand a number of examples in Coq; the Coq sources are available online [16]. 2. SCSL and Proving the Incrementor \n 2.1 Subjective Auxiliary State Subjective Concurrent Separation Logic (SCSL) has a single lock with \nglobal scope which is associated with a user-chosen partial commutative monoid (PCM) (U, ., 0) for auxiliary \nstate and an invariant I* indexed by U. A PCM is a set Uwith an associative and commutative join operation \n. and unit element 0. Intuitively, the unit 0 describes a null effect; the join . combines the effects \nof two parallel threads, which mirrors the associativity and commutativity of parallel composition; and \npartiality indicates inconsistent views (e.g., two threads owning a lock simultaneously). 2 We don t, \nhowever, support higher-order heaps that can store procedures.  By working with an auxiliary PCM, we \ncan take the .-total t . U of all threads combined contributions: if each thread i m contributes si , \nthen t = i si . The single total auxiliary value t serves to de.ne a unary invariant I*(t) that doesn \nt depend on the number of threads, in contrast to CSL proofs where auxiliaries expose all threads in \nthe invariant (e.g., y > a identi.es the left thread and z > \u00df the right thread in the CSL proof from \nSection 1). To preserve locality, however, assertions can t directly refer to the total t , because all \nthreads can interfere on its value. Instead, each thread i has two complementary subjective views of \nt : a self view aS >> si of the thread s own auxiliary contribution, and an m other view aO \"-where .i \n= sj is the .-subtotal of > .i #j=i all other threads contributions.3 Although different threads i and \nj may have different views (aS, aO), all views are mutually coherent in that they yield the same .-total: \nsi ..i = t = sj ..j . We use aS >> si throughout the program to track the thread s contribution as it \nchanges, but only use aO \"- > .i in the critical section to track that the environment s contribution \nremains .xed when it can t access the shared resource (Section 2.4).  2.2 Parallel Composition and Subjective \nSeparation For the incrementor, we choose the PCM (N, +, 0) of natural num\u00adbers under addition and the \nunary invariant I*(t ) = x . t , which hides the identity of threads and thus permits a compositional \nproof of incr. The SCSL speci.cation of incr(n) is: .n:nat.{aS >> s}incr(n) : unit{aS >> s + n} incr \ntakes an argument n and increments the thread s contribution aS from s to s + n, 4 and returns unit. \n5 Since the value of aS is thread-speci.c, the SCSL speci.cation does not expose thread identities (cf. \nhow y identi.ed the left thread in the CSL proof). The environment s contribution aO does not appear \nin the speci\u00ad.cation and is thus unconstrained, but it will show up in the proof of incr. Since incr \nonly mutates shared state, the local heap is implic\u00aditly empty in the pre and post. By framing, incr \nis safe to run in any larger private heap, which remains unchanged upon termination. To prove two parallel \nincrements, we use the SCSL PAR rule: {p1}C1{q1} {p2}C2{q2} PA R {p1 \u00ae p2}C1 I C2{q1 \u00ae q2} The subjective \nseparating conjunction \u00ae connective splits the heap into two disjoint subheaps; the novelty is that \u00ae \nalso splits the contents of aS: aS >> a \u00ae aS >> \u00df is equivalent to aS >> a . \u00df. For comparison, the CSL \nPA R rule uses the separating conjunction * to split the heap and ownership of auxiliaries among parallel \nthreads. The SCSL proof of incr is compositional: we can instantiate s and n in the proof of incr, which \nis otherwise used as a black box, to show that incr(i) I incr(j ) increments x by i+j . {aS >> a+\u00df}{aS \n>> a \u00ae aS >> \u00df}{aS >> a} {aS >> \u00df} incr(i) incr(j ) {aS >> a+i} {aS >> \u00df+j }{aS >> a+i \u00ae aS >> \u00df +j }{aS \n>> (a+i)+(\u00df+j )} The parallel composition starts with a contribution aS >> a+\u00df. When the parent thread \nforks two child threads, the parent s view 3 For the moment, aS >> s and aO > . should be read as asserting \nthe \"- contents of each auxiliary view, but don t directly permit mutation; their formal meaning is explained \nin Section 2.3. 4 We use Greek letters, such as s, for logical variables that scope over the pre-and \npostcondition to relate initial and .nal states. 5 The SCSL judgments include an explicit return type \n(Section 4). Hereafter we omit the return type unless it requires commentary. h; \u00b5; s; . |= aS >> s' \n.. iff (h, \u00b5, s) = (empty,Own, s') ' h; \u00b5; s; . |= mS >> \u00b5' iff (h, \u00b5, s) = (empty, \u00b5, 0) h; \u00b5; s; . \n|= i . v . v],.. iff (h, \u00b5, s) = ([iOwn, 0) h; \u00b5; s; . |= aO \"> .' -iff . = .' h; \u00b5; s; . |= emp .. iff \n(h, \u00b5, s) = (empty,Own, 0) h; \u00b5; s; . |= p1 * p2 iff h1; \u00b51; s1; . |= p1 and h2; \u00b52; s2; . |= p2 where \n(h, \u00b5, s) = (h1 . h2, \u00b51 . \u00b52, s1 . s2) for some hi , \u00b5i , si h; \u00b5; s; . |= p1 \u00ae p2 iff h1; \u00b51; s1; s2 \n. . |= p1 and h2; \u00b52; s2; s1 . . |= p2 where (h, \u00b5, s) = (h1 . h2, \u00b51 . \u00b52, s1 . s2) for some hi , \u00b5i \n, si w |= p1 . p2 iff w |= p1 and w |= p2 [\u00b5, s, .] p abbreviates (mS >> \u00b5 * aS >> . > s * p) . aO \"- \nFigure 2. Semantics of assertions h; \u00b5; s; . |= p (fragment). aS splits between its children, while the \nchildren s aO s are implic\u00aditly induced to preserve coherence (i.e., the left child s environment includes \nthe right child, and vice versa). By coherence, the combi\u00adnation of views is the same irrespective of \nthe viewer.6 viewer: views: combined views: parent . child1 \u00ae child2 self aS (explicit) a+\u00df a \u00df other \naO (implicit) . \u00df+. a+. aS+aO a+\u00df+. The left thread instantiates the incr proof with a and i to show \nthat the overall contribution increments from a to a+i; and analo\u00adgously for the right thread. The soundness \nof parallel composition ensures that, dually, at the join point the children s aS s can be com\u00adbined \nback into the parent s aS: the subthreads aS s are added and the parallel composition ends with aS incremented \nby i+j over the initial value. aO is implicitly unconstrained and unknown in the parent, and thus remains \nso in both child threads. We can directly reuse the two-thread SCSL proof composition\u00adally in a three-thread \nprogram without having to change the invari\u00adant or subproof for the particular context. The three-thread \npro\u00adgram increments the initial contribution a+\u00df+. by i+j +k with a structurally similar proof as the \ntwo-thread program. {aS >> a+\u00df+.}{aS >> a+\u00df \u00ae aS >> . }{aS >> a+\u00df} {aS >> . } incr(i) I incr(j ) incr(k) \n{aS >> (a+i)+(\u00df+j )} {aS >> . +k}{aS >> (a+i)+(\u00df+j ) \u00ae aS >> . +k}{aS >> (a+i)+(\u00df+j )+(.+k)} Here, the \ninitial (aS, aO) views are (a+\u00df+. , .) for some ., which induce views for the three threads: (a, \u00df+.+.), \n(\u00df, a+.+.), and (., a+\u00df+.); all have the coherent total a+\u00df+.+.. Furthermore, we can substitute programs \nwith the same spec\u00adi.cation. For example, the parallel incr(i) I incr(j ) and the se\u00adquential incr(i); \nincr(j ) with a different number of threads can be given the same speci.cation {aS >> a+\u00df} - {aS >> a+\u00df+i+j \n}. Therefore we can use them interchangeably in the three-increment program and the overall proof remains \nthe same. In Section 3.2, we show that this approach scales to prove a concurrent iterator, where the \nnumber of threads depends on a run-time value.  2.3 Assertions In SCSL, an assertion is a predicate \nover a world w of the form h; \u00b5; s; .. h is the thread s private heap (a .nite map from pointers to values), \nwhich is a PCM with the empty heap as unit and disjoint 6 This pattern recurs in the semantics, not only \nfor auxiliaries but also for heaps and lock ownership (Section 5.5).  union l as join (unde.ned if the \nheaps overlap). \u00b5 is an element of the lock ownership PCM mtx, with elements Own (to indicate the viewer \nowns the lock and is thus in a critical section) and .. Own; the join . is de.ned with unit .. Own, but \nOwn . Own is unde.ned because two threads cannot enter a critical section simultaneously. s and . are \nthe thread and environment s respective auxiliary contributions from U. In our subjective terminology, \nthe components h, \u00b5 and s are the self views on the thread s world, as they describe the state of the \nthread itself. On the other hand, . is the other view, as it describes the abstract effect of the thread \ns environment on the shared state. Figure 2 gives the interpretation of assertions.7 The thread s auxiliary \npointer assertion aS >> s ' constrains the s component of the world to be s ', and the h and \u00b5 components \nto be the respec\u00adtive PCM units, but the . component is unconstrained because the environment may enter \nthe critical section and change its contribu\u00adtion in tandem with the shared state. Thus, the aS >> - \nassertions in the speci.cation of incr implicitly mean the private heap is empty and the lock isn t owned. \nThe pointer assertion e . v and lock (a.k.a. mutex) pointer assertion mS >> \u00b5 ' are de.ned analogously. \nThe environment s auxiliary pointer assertion aO \"> . ' -constrains the . component of the world to be \n. ', but is intuitionistic in that it doesn t constrain the h, \u00b5, or s components. The auxiliary pointer \nassertions use a half arrow tip to suggest that they can t be mutated directly (though we don t use permissions). \nThe p1 \u00ae p2 assertion splits the self components h, \u00b5, and s between p1 and p2, and induces the other \ncomponent to maintain coherence (i.e., s2 . . for p1, and dually for p2). The p1 * p2 assertion also \nsplits the self components h, \u00b5, and s, but doesn t change the other component .. The SCSL rules for \nmemory and locking commands typically use the assertion [\u00b5 ' , s ' , . ' ] p, which abbreviates (mS >> \n\u00b5 ' * > s ' * p) . aO -. ' and holds in a world h; \u00b5; s; . if \"> aS > (\u00b5, s, .) = (\u00b5 ' , s ' , . ' ) \nand h satis.es the heap predicate p. The asymmetry between the aS >> - and aO -- assertions stems \"> \nfrom the fact that aS must be tracked throughout the program, in particular when it is split at forking \npoints, but aO is implicitly in\u00adduced to preserve coherence at forking points and is only tracked in \nthe critical section.  2.4 Critical Sections and Local Auxiliary Functions The following proof outline \nof incr is parametric in si and n. In SCSL, we enter and exit critical sections using explicit lock and \nunlock commands, which illustrates how lock ownership works in tandem with auxiliaries. {aS >> si } precondition \n{[..by CO N S E Q Own, si , -] emp} 1 lock; {..i .[Own, si , .i ] I*(si + .i )} by lock 2 tmp . read \nx; {..i .[Own, si , .i ] x . (si + .i ) . tmp = si + .i } by read 3 write x (tmp + n); {..i .[Own, si \n, .i ] x . ((si + .i ) + n)} by write {..i .[Own, si , .i ] I*((si + n) + .i )} by CO N S E Q 4 unlockFn \n{..i .[..by unlock Own, Fn(si ), -] emp}{aS >> si + n} by CO N S E Q First, the precondition aS >> si \nis turned into the equivalent explicit assertion [.. Own, si , -] emp, where - indicates that the environ\u00adment \ns contribution is existentially quanti.ed and thus unknown. 7 We write [i . v] for the singleton heap \nthat maps i to v, [h|i . v] for the heap that maps i to v and behaves like h on other locations, and \nh \\i for the heap h without i. By taking the lock and auxiliary units h;..= p Own; 0; 0 |we recover the \nstandard Separation Logic relation h |=SL p . The lock operation (line 1) uses the SCSL rule: {[.. Own, \nsi , -] emp}lock{..i .[Own, si , .i ] I* (si . .i )} where the PCM operation . is instantiated with +. \nLocking changes the ownership status from .. Own to Own and preserves the thread s contribution si . \nPrior to locking, the environment may enter the critical section and change its contribution in tandem \nwith the shared state, thus aO is unconstrained in the precondition and existentially named .i in the \npostcondition. The thread also acquires the shared state satisfying I*(t ), which is equivalent to I*(si \n. .i ) by the coherence of views. By mutual exclusion, other threads j can t access or change the shared \nresource, so their contributions sj and consequently m aO \"> .i (= =i -j#sj ) remain .xed throughout \nthe critical section. This invariance is explicitly speci.ed by the commands in the critical section. \nFor example, the SCSL read rule: [\u00b5i , si , if \u00b5 = Own then .i else -] {[\u00b5i , si , .i ] x . .}read x \nx . . . res = . includes the standard Separation Logic speci.cation that initial heap contains a pointer \nx with value .; in the postcondition, the heap is preserved and . is bound to the dedicated result variable. \nMoreover, the lock status \u00b5i and thread contribution si may be arbitrary and are preserved across the \nread. However, the environ\u00adment s contribution is subject to a conditional on the lock owner\u00adship: if \nthe thread Owns the lock because it s in a critical section, then aO remains .xed at .i , otherwise aO \nis undetermined in the postcondition. The other memory commands determine the heap as in Separation Logic \nand preserve the auxiliaries just like read. By sequential composition, the read (line 2) binds the contents \nof x (i.e., si + .i by the invariant) to the local variable tmp, and extends the assertion with an equation \nthat describes tmp. The write (line 3) increments x by n, which is re.ected in the assertion about the \ncontents of x. Since the thread Owns the lock, the read and write preserve the auxiliaries as si and \n.i . That the environment s auxiliary aO \"> .i is .xed throughout -the critical section becomes crucial \nat the unlock command when the invariant I*(si ' . .i ) must be restored for some new thread contribution \nsi ' and the same environment contribution .i from the moment of locking. This emulates the Owicki-Gries \ndiscipline that an auxiliary is only updated by its owner in the critical section. Since we generalize \nauxiliary state from heap to PCM U, we must also generalize from stack-and heap-mutating auxiliary code \nto auxiliary functions F on U. The unlock rule: {[Own, si , .i ] I* (F(si ) . .i )}unlockF{[.. Own, F(si \n), -] emp} requires the unlock command to be decorated by a mathemati\u00adcal function F such that the heap \ninitially satis.es the invariant I*(F(si ) . .i ) relative to a new thread contribution F(si ), rather \nthan the former thread contribution si . In the postcondition, lock ownership and the invariant heap \nare released, the thread s auxil\u00adiary is updated from si to si ' = F(si ) (which implicitly changes other \nthreads .j ). The environment s auxiliary again becomes un\u00addetermined, because the thread is no longer \nin the critical section and the environment can change its contribution at will. In the incrementor proof, \nthe auxiliary function on unlock (line 4) is Fn(s) = s+n, which corresponds to the auxiliary up\u00addate \ncode used in Section 1 to increment the auxiliaries y and z. By unlocking, the thread s auxiliary aS \nis updated from si to Fn(si ) = si +n and the invariant subheap is released. Finally, the existential \n.i can be eliminated because it doesn t appear in the assertion, and we return to the more succinct aS \n>> si + n. The structured form of auxiliary update via unlockF has several advantages when compared to \nthe classical auxiliary code from Section 1. First, since F is a pure function, it can t perform side \neffects to leak the contents of auxiliary state into the heap and thus change the program s semantics. \n Second, F doesn t directly name aS. Instead, the proof implic\u00aditly applies F to the aS value of the \nviewing thread. Thus, F can t possibly mutate other threads auxiliary contributions. In this sense, SCSL \ndiffers from a number of related systems [2, 23, 24] which re\u00adquire ownership-tracking permissions to \ncontrol which auxiliaries can be changed by what auxiliary code (e.g., how the left thread updates y \nand the right thread updates z in Section 1). Most importantly, F can update the appropriate aS without \nknowing the viewing thread s identity, whereas the CSL proof up\u00addates speci.c auxiliaries in each thread \n(e.g., y in the left thread, and z in the right thread in Section 1). The independence from the thread \ns identity facilitates reusability: the same invariant, auxil\u00adiary code, and proof of incr can be used \nwithout any change, in con\u00adtexts with two or three concurrent threads (Section 2.2), or with any number \nof threads as we illustrate with the iterator (Section 3.2). To ensure the soundness of parallel composition \nand framing, however, the auxiliary function F must be local in the following formal sense, where valid(a) \nmeans a is a de.ned PCM element. Obviously, the incrementor s Fn is local. De.nition 1. A partial function \nF on a PCM U is local, written F : U >L U, if for all a, \u00df . U, valid (a . \u00df) and valid (F(a)) imply \nF (a . \u00df) = F(a) . \u00df. Intuitively, F can be applied to aS with aO framed on by .\u00adcombination: it will \nact on aS but simply propagate aO without change. This property makes F appropriate for modeling auxiliary \ncode for a thread to modify its auxiliary aS, but is unaffected by and doesn t affect the auxiliary aO \nof other threads running in parallel. 3. More Examples 3.1 Coarse-Grained Set with Disjoint Interference \nWe adapt a coarse-grained set example from Concurrent Abstract Predicates [6] (in Section 6 we compare \nwith this approach). If threads perform logically disjoint operations (i.e., add or remove distinct elements), \nthen we can prove their parallel composition with local reasoning. This is possible even if the operations \nin\u00adterfere physically on the data structure; for example, if the set is implemented with a splay tree, \nthe memory shape will depend on the order of operations. Fortunately, at the level of abstraction of \nset membership, the proof isn t sensitive to the noncommutativity of physical operations. Alternatively, \nwe could specify the logical disjointness using classical auxiliary state, but it leads to the same problems \nas in the incrementor. We assume a set library, whose procedures sadd and sremove are sequential and \ncan be run in a critical section preserving the auxiliaries: {v /. S . [Own, s, .] set(x, S)} {[Own, \ns, .] set(x, S 1 {v})} sadd(x, v) sremove(x, v) {[Own, s, .] set(x, S 1 {v})} {[Own, s, .] set(x, S)} \nHere v is drawn from some universe V of values, and set(x, S) is a spatial predicate that means the .nite \nsubset S . V is represented at pointer x. We can obtain a coarse-grained concurrent library by wrapping \neach procedure in a critical section: cadd(v) .; unlock = lock; sadd(x, v) cremove(v) . = lock; sremove(x, \nv); unlock Although the coarse-grained implementation is inef.cient because threads must contend for \nthe entire data structure, we can choose suitable auxiliaries in(v) and out(v) to specify the procedures \nin a local manner that only depends on the element being manipulated: {aS >> out(v)} cadd(x, v) {aS >> \nin(v)}{aS >> in(v)} cremove(x, v) {aS >> out(v)} We can thus reason locally in each thread to prove the \neffect of concurrently adding or removing three distinct elements: {aS >> (in(a) . out(b) . in(c))} {aS \n>> in(a)} {aS >> out(b)} {aS >> in(c)}cremove(a) cadd(b) cremove(c) {aS >> out(a)} {aS >> in(b)} {aS \n>> out(c)}{aS >> (out(a) . in(b) . out(c))} To verify the concurrent library in SCSL, the auxiliaries \nshould maintain the distributed, partitioned knowledge of which elements are in or out of the data structure. \nWe pick the auxiliary PCM (V - >.n bool, l, \u00d8) of .nite partial maps from V to bool, with the join l \ntaking the union of maps with disjoint domain, and the empty map \u00d8 as unit. Given such a .nite map ., \nthe invariant I* (.) = set(x, .-1[true]) states that the set contains exactly the elements that . maps \nto true. We de.ne in(v), out(v) : V - >.n bool to map v to true and false, respectively, and be unde.ned \nelsewhere. Then we can prove cadd (and cremove similarly) as follows: {aS >> out(v)} precondition {[..by \nCO N S E Q Own, out(v), -] emp} lock; {..O.[..by LO C K Own, out(v), .O] I*(out(v) 1 .O)}sadd(x, v); \n{..O.[..by sadd Own, out(v), .O] I*(in(v) 1 .O)}unlockFv ; {[..by U N L O C K Own, in(v), -] emp}{aS \n>> in(v)} by CO N S E Q When the program locks, the environment s auxiliary .O comes into scope. The \ninitial invariant I*(out(v) l .O) is equivalent to sadd s precondition with S=(out(v) l .O)-1[true]=.-1[true]; \nO sadd s postcondition set(x, .-1[true] l {v}) restores the invariant O I*(in(v)l.O). Unlocking turns \naS into Fv(out(v))=in(v), where . .true u = v and v . dom . Fv(.) ..u. u= v and u, v . dom . = .(u) . \nunde.ned otherwise Fv turns a .nite map . with v . dom . into a . ' that behaves like . on all elements, \nexcept that it maps v to true; if v /. dom ., then Fv(.) is unde.ned. It is straightforward to check \nthat Fv is local.  3.2 Higher-order Iterator We can prove a higher-order iterator that dynamically forks \na procedure f (itself possibly concurrent) to process each element in a list.8 In SCSL, we can prove \nthe iterator with a hypothetical f : .n:A. {aS >> .(n)}f (n):unit{aS >> f(n)}f .ns:list A. {aS >> .(ns)}iter(ns):unit{aS \n>> f(ns)} which assumes f (n) changes the local auxiliary contribution from .(n) to f(n), relative to \nsome ambient type A, PCM (U, ., 0), invariant I*, and functions ., f : A . U. The overall effect of iter \nf ns is to change the local auxiliary contribution from .(ns) m to f(ns), where .(ns) is n.ns .(n) and \nsimilarly for f. By embedding SCSL into the type theory of the Calculus of In\u00adductive Constructions (CiC) \n(Section 5), however, we can explicitly .-abstract over f and give iter the speci.cation (i.e., CiC type): \niter : .f :(.n:A. {|aS >> .(n)|}unit{|aS >> f(n)|}). .ns:list A. {|aS >> .(ns)|}unit{|aS >> f(ns)|} 8 \nWe use pure lists and pattern-matching for clarity, although we can also prove the iterator for heap-allocated \nlists.  The proof outline for iter is: Commands and procedures include memory and locking opera\u00adtions, \na monadic unit ret v that returns v and terminates, a monadic iter = .f . .x loop. ns. . . bind (i.e., \nsequential composition) x . C1; C2 runs C1 then sub\u00ad match ns with stitutes its result v1 for x to run \nC2 (we write C1; C2 when x ./ ....................... ....................... | nil . {aS >> .(nil)} \nret () {aS >> f(nil)} ' ' | n ::ns . . FV(C2)), fork-join parallel composition C1 I C2, a conditional, \na procedure application F (e), a procedure variable f , or a .xed-point .x f .x.C for recursive procedures. \nNote that memory operations and ret are technically procedures because they take arguments. Like in a \nmonadic functional language, such as Haskell, com\u00ad mands return values. This enables avoiding mutable \nvariables (i.e., a stack) in favor of immutable variables, which can be substituted with expressions. \nA stack imposes a number of technical dif.culties in a Hoare-style logic [2, 23, 24], especially for \nsupporting proce\u00ad dures [14], so we prefer to avoid it. In Section 5, we embed SCSL into the Calculus \nof Inductive . {aS >> .(n ' ::ns ' )} ' > (.(n ' ) . .(ns ................. ................. ))} ' ' \n) \u00ae aS >> .(ns {aS >{aS >> .(n {aS >> .(n )}' )} > .(ns ' )} {aS > ' ' f n loop ns {aS >> f(n ' )} {aS \n>> f(ns ' )}> f(n ' ) \u00ae aS >> f(ns ' )} {aS >{aS >> (f(n ' ) . f(ns ' ))} {aS >' )} ' ::ns > f(n ret \n() ' {aS >> f(n ::ns ' )} iter is de.ned recursively by .x with two arguments: loop for recur\u00adsive calls \nand the list ns. The body pattern-matches the list: for nil, it returns unit and the overall effect preserves \nthe local contribution .(nil) = 0 = f(nil); otherwise for n ' ::ns ', it concurrently applies f to the \nhead element n ' and recurses on the tail ns ', then returns unit, so the contribution changes from .(n \n' ::ns ' ) to f(n ' ::ns ' ). De.ning xincr2 to be either the sincr2 = .n.(incr(n); incr(n)) or cincr2 \n= .n.(incr(n) I incr(n)) has the same effect of in\u00adcrementing by twice the argument (Section 2.2), independently \nof whether the program is sequential or concurrent: .n:N.{aS >> 0} xincr2(n) {aS >> 2 \u00d7 n} Then, we can \nshow that iterating xincr2 increments by twice the sum of the list, using .( ) = 0 and f(n) = 2 \u00d7 n: \n .ns:list N.{aS >> 0} iter xincr2 ns {aS >> 2 \u00d7n} n.ns Finally, we can iterate again to add up a list \nof lists of numbers, t using .( ) = 0 and f(ns) = n.ns n for the outer iter: Constructions (CiC), which \nimmediately provides us with a pure language of expressions and speci.cations-level objects such as assertions \nand auxiliary functions. The embedding also gives us access to arbitrary CiC inductive types (e.g., list) \nand constructs for pattern-matching against them. We can also write procedures that abstract over commands \nand procedures (cf. the iterator in Section 3.2). Presenting the full syntax of CiC is beyond the scope \nof this paper, so we only present the fragment relevant to effectful programs and Hoare-style reasoning \nabout them. Speci.cations SCSL is parametrized in the auxiliary PCM Uand a resource invariant I* index \nby U that describes the single, global resource protected by the lock and unlock commands. A command \nC satis.es the Hoare triple {p}C : A{q} if it respects mutual exclusion and is memory-safe when executed \nfrom a world satisfying p, and concurrently with any environment that respects mutual exclusion. Furthermore, \nif C terminates, it returns a value of type A in a world satisfying q. q may use a dedicated variable \nres of type A to name the return result. We use a procedure triple, .x:B. {p}F (x) : A{q}, to specify \na potentially recursive procedure F taking an argument x of type B .nss:list (list N).{aS >> 0} iter \n(iter xincr2) nss {aS >> 2 \u00d7n} n.ns.nss We can also iterate the concurrent set cadd procedure to show \nthat if initially none of the elements of the list are in the set, then afterwards all of the elements \nare in the list, using .(v) = out(v) and f(v) = in(v): .vs:list V .{aS >> out(vs)} iter cadd vs {aS >> \nin(vs)} Although iter has a dynamic forking pattern that depends on the list argument and although f \nmay spawn multiple threads, subjective auxiliary state gives the iterator a robust speci.cation. We can \nuse the same proof of iter for different types of list el\u00adements (e.g., N, list N, and V ), different \nlists (e.g., any number of elements), and procedures with different internal concurrency (e.g., one thread \nin sincr2, two threads in cincr2, and argument\u00addependent in (iter xincr2)). 4. Language and Logic Language \nIn the tradition of axiomatic program logics, the lan\u00adguage of SCSL splits into purely-functional expressions \ne (v when the expression is a value), and commands C with effects of di\u00advergence, state, and concurrency, \nand procedures F for commands with arguments. Expressions are classi.ed by types A, which, for the purposes \nof this section, range over base types unit, nat, bool, and pointers ptr (isomorphic to nat), all with \nthe usual values. The syntax of commands and procedures is: C ::= lock | unlockF | x . C1; C2 | C1 I \nC2 | if e then C1 else C2 | F (e) F ::= f | alloc | dealloc | read | write | ret | .x f .x.C to a result \nof type A. The assertions p and q may depend on x. We use Cartesian products A1 \u00d7 A2 for functions with \nmore than one argument, but curry the function for readability. The SCSL judgments are hypothetical under \na context G that maps program variables x to their type and procedure variables f to their speci.cation. \nEach speci.cation is allowed to depend on the variables declared to the left. G ::= \u00b7 | G, x:A | G, .x:B.{p}f \n(x) : A{q} G does not bind logical variables. In .rst-order Hoare logics, logi\u00adcal variables are implicitly \nuniversally quanti.ed with global scope. In SCSL, we limit their scope to the Hoare triple in which they \nap\u00adpear. This is required for specifying recursive procedures, where a logical variable may be instantiated \ndifferently in each recursive call [14]. We also assume a formation requirement on Hoare triples FLV(p) \n. FLV(q), i.e., that all free logical variables of the post\u00adcondition also appear in the precondition. \nFigure 3 presents the inference rules for the SCSL judgments for Hoare triples G f {p} C : A {q} and \nG f .x : B.{p} F (x) : A{q}. We have discussed the memory and locking commands in Sec\u00adtion 2, so we proceed \nto describe the remaining inference rules. Parallel composition The parallel composition C1 I C2 forks \ninto two children threads for C1 and C2, and when they terminate with return values vi of type Ai , the \nthreads are joined into a single return of the pair (v1, v2) of type A1 \u00d7 A2. The rule reads as fol\u00adlows: \n(1) the parallel composition precondition p1 \u00aep2 can be split into p1 and p2, (2) each thread Ci must \nbe veri.ed separately with precondition pi and postcondition qi , and (3) the postconditions q1 and q2 \ncan be recombined into the parallel composition postcondi\u00ad  G f .x:A. {[\u00b5, s, .] emp} alloc x : ptr \n{[\u00b5, s, if \u00b5 = Own then . else -] res . x} G f .x:ptr. {[\u00b5, s, .] x . -} dealloc x : unit {[\u00b5, s, if \n\u00b5 = Own then . else -] emp} G f .x:ptr. {[\u00b5, s, .] x . .} read x : A {[\u00b5, s, if \u00b5 = Own then . else -] \nx . . . res = .} G f .x:ptr..y:A. {[\u00b5, s, .] x . -} write x y : unit {[\u00b5, s, if \u00b5 = Own then . else -] \nx . y} {[.. G f Own, s, -] emp} lock : unit {...[Own, s, .] I* (s . .)} G f {[Own, s, .] I* (F(s) . \n.)} unlockF : unit Own, F(s), -] emp} {[..G f .x:A. {[\u00b5, s, .] emp} ret x : A {[\u00b5, s, if \u00b5 = Own then \n. else -] emp . res = x} G f {e = true . p}C1 : A{q} G f {e = false . p}C2 : A{q} G f {p1}C : A{q1} G \nf {p2}C : A{q2} G f {p}C : A{q} a /. dom G IF CO N J EX I S T G f {p}if e then C1 else C2 : A{q} G f \n{p1 . p2}C : A{q1 . q2} G f {.a:A.p}C : A{.a:A.q} G f {p1}C : A{q1} G f (p1, q1) (p2, q2) G f {p}C : \nA{q} CO N S E Q FR A M E G f {p2}C : A{q2} G f {p \u00ae r}C : A{q \u00ae r} G f {p}C1 : B{q} G, x:B f {[x/res]q}C2 \n: A{r} x . FV(r) G f {p1}C1 : A1{q1} G f {p2}C2 : A2{q2} SE Q PA R G f {p}x . C1; C2 : A{r} G f {p1 \u00ae \np2}C1 I C2 : A1 \u00d7 A2{[res.1/res]q1 \u00ae [res.2/res]q2} .x:B.{p}f (x) : A{q} . G G, .x:B.{p}f (x) : A{q}, \nx:B f {p}C : A{q} G f .x:B.{p}F (x ) : A{q} G f e : B HY P FI X AP P G f .x:B.{p}f (x) : A{q} G f .x:B.{p}(.x \nf .x.C )(x) : A{q} G f {[e/x]p}F (e) : A{[e/x]q} Figure 3. Subjective CSL rules G f {p}C : A{q} and G \nf .x:B.{p}F(x) : A{q}. tion q1 \u00aeq2, with the projections from the resulting pair substituted for the \ndedicated variable res. The precondition p1 \u00ae p2 expresses that the initial world for the parent thread \nhas the form h1 . h2; \u00b51 . \u00b52; s1 . s2; .. The left child receives the world h1; \u00b51; s1; s2 . . in its \nprecondition p1, and dually for the right child and p2. The splitting of h, \u00b5 and s components re.ects \nthat the children divide the local heap and contribution of the parent thread. The left child s environment \ncontribution s2 . . re.ects that upon forking C2 becomes part of C1 s environment, and a dual remark \napplies to the right child. The parallel composition rule thus states that if a partition sat\u00adisfying \nthe preconditions can be found of the initial world, then a partition satisfying both postconditions \ncan be found of the end\u00ading world. Intuitively, the rule is sound because the required parti\u00adtion of \nthe ending state can be obtained by executing C1, C2, and their common environment in an interleaved \nmanner, while updat\u00ading their respective values of aS and aO. Whenever one thread s > si is updated, \nthe aO -\"> .j s of the other two threads must aS > be updated correspondingly in order to preserve the \ncoherence between views, that is, that every thread i sees the same total t = si . .i . Fixed points \nWe support a combinator .x for general recursion, rather than just while-loops. The iterator (Section \n3.2) requires .x because of its dynamic forking structure; it isn t tail recursive and thus dif.cult \nto write using a while-loop. The inference rule re\u00adquires proving a Hoare triple for the procedure body, \nunder a hy\u00adpothesis that the recursive calls satisfy the same triple. In practice, when writing recursive \nprograms, the assertions p and q have to be supplied by hand (they cannot be inferred automatically), \nand they essentially correspond to a loop invariant. Framing The FR AM E rule allows splitting the world \ninto p \u00ae r, verifying the command with precondition p and postcondition q, then recombining the postcondition \nwith the framed world into q \u00ae r. Note that the rule uses \u00ae which allows auxiliaries to also be framed. \nSomewhat surprisingly, the auxiliary PCM U need not be cancellative. 9 This allows us to prove a concurrent \nmaximum program (not shown) that uses the PCM (N, max, 0) which is not cancellative, yet we can frame \nthe thread s auxiliary contribution. 9 Cancellativity means that if a . \u00df = \u00df . ., then \u00df = .; a property \nthat the heap PCM satis.es and is often associated with the F R A M E rule. Cancellativity for heaps \nis required in the soundness proofs for CSL (and SCSL) in order to uniquely determine the heap trans\u00adfered \nbetween the thread and the shared resource upon locking and unlocking [19, 3]. In SCSL, the auxiliary \nPCM need not be can\u00adcellative, because there is no analogous transfer of auxiliaries. Other Rules The \nprocedure APPlication rule uses the typing judgment for expressions G f e : A, which is the customary \none from a typed .-calculus, so we omit its rules; in Section 5, this judgment will correspond to CiC \ns typing judgment. The CO N SE Q rule uses the judgment G f (p1, q1) . (p2, q2), which generalizes the \ncustomary side conditions p2 . p1 for strengthening the precondition and q1 . q2 for weakening the postcondition, \nto deal with the local scope of logical variables (cf. Section 5.4). The other rules are standard from \nHoare logic. 5. Semantics We de.ne semantic objects of actions for heap mutation and ac\u00adtion trees for \ncontrol .ow, which yield .nite, partial approxima\u00adtions of the behavior of SCSL commands; their operational \nseman\u00adtics gives the low-level execution relative to the full heap (Sec\u00adtion 5.1). We de.ne the high-level \nnotions of coherent con.gu\u00adration to maintain an explicit partition between the shared state heaplet \nand the thread s and environment s private heaplets and auxiliaries, and subjective rely/guarantee transitions \nbetween con\u00ad.gurations for environment and thread interference that respect mu\u00adtual exclusion (Section \n5.2). Both the operational semantics and subjective rely/guarantee transitions use a large footprint, \nalthough SCSL enjoys small footprint speci.cations. We relate the low-level operational semantics to \nthe high-level subjective rely/guarantee transitions by a modal always predicate (Section 5.3) that ensures \na tree is resilient to any amount of sub\u00adjective rely interference, and that all operational steps by \na tree are memory-safe and correspond to subjective guarantee interference. The denotational semantics \n(Section 5.4) interprets judgments by the monadic Hoare type {|p|}A{|q|}, which is a complete lat\u00adtice \nof trees that are always-safe to run from any initial con.gu\u00adration that satis.es precondition p and \nif they terminate produce a .nal con.guration that satis.es postcondition q. The complete lattice structure \nmakes the semantic domain suitable for modeling recursion. A command is denoted by the set of its tree \napproxima\u00adtions, and a procedure is denoted by a function into a set of trees.  i /. domh i . domh h; \nAlloc v a [h|i . v]; i h; Dealloc i a h \\ i; () h(i) = v : A i . domh h; ReadA i a h; v h; Write i v \na [h|i . v]; () h; Idle a h; () h(i) = v1 h(i) = v v = v1 h; CAS i v1 v2 a [h|i . v2]; true h; CAS x \nv1 v2 a h; false ' h; a a h ; v nilnil ' h; Cons a F k t h ; (k v) h; Par (Ret v1) (Ret v2) k t h; k \n(v1, v2) pp '' '' h; t1 t h ; t h; t2 t h ; t 1 2 L::pR::p '' '' h; Par t1 t2 k t h ; Par t1 t2 k h; \nPar t1 t2 k t h ; Par t1 t2 k Figure 4. Action stepping h; a ra h ' ; v (top) and tree stepping p ' ' \nh; t rt h ; t (bottom). The soundness of SCSL (Section 5.5) follows from showing that the denotation \nof memory operations satisfy the appropriate always predicate, and that always satis.es certain closure \nconditions. In Section 6, we discuss the relationship of our denotational seman\u00adtics to existing semantics \nfor CSL. We choose the Calculus of Inductive Constructions (CiC) [18] as our meta logic. This has several \nimportant bene.ts. First, we can de.ne a shallow embedding of SCSL into CiC that allows us to program \nand prove directly with the semantic objects, thus im\u00admediately lifting SCSL to a full-blown programming \nlanguage and veri.cation system with higher-order functions, abstract types, ab\u00adstract predicates, and \na module system. We also gain a powerful dependently-typed .-calculus, which we use to formalize all \nse\u00admantic de.nitions and metatheory, including the de.nition of ac\u00adtion trees by iterated inductive de.nitions \n[17, 18], speci.cation\u00adlevel functions (e.g., auxiliary functions F), and programming\u00adlevel higher-order \nprocedures (e.g., the iterator). Finally, we were able to mechanize the entire semantics and metatheory \n[16] in the Coq proof assistant implementation of CiC. We use set-theoretic and type-theoretic notation \nas appropriate. The reader unconcerned with the .ne points of the type theory, may read a typing judgment \nx:A as a set membership predicate x . A. 5.1 Actions, Trees, and Operational Semantics The type family \naction A of A-returning actions includes construc\u00adtors for the SCSL memory commands, an idle action returning \nunit, and a compare-and-swap CAS used to implement locking: Alloc (v:B) : action ptr ReadA (x:ptr) : \naction A Dealloc (x:ptr) : action unit Write (x:ptr) (v:B) : action unit Idle : action unit CAS (x:ptr) \n(v1:B) (v2:B) : action bool The operational semantics of actions h; a ra h ' ; v (Figure 4, top) steps \nan A-returning action a relative to an initial heap h, and produces an ending heap h ' and result v of \ntype A. The operational semantics of the basic memory operations is standard. The CAS action takes a \npointer e and two values v1 and v2, it atomically checks whether e contains v1 and, if so, replaces it \nwith v2 and returns true; otherwise, it preserves the heap and returns false. The type family tree A \nof A-returning trees is de.ned by an iterated inductive de.nition: Bottom : tree A Ret (v:A) : tree A \nCons (a:action B) (F:U >L U)(k:B . tree A) : tree A Par (t1:tree B1) (t2:tree B2) (k:B1 \u00d7 B2 . tree A) \n: tree A Since trees have .nite depth, they can only approximate divergent computations, thus the Bottom \ntree indicates an incomplete ap\u00adproximation. Ret v is a terminal computation that returns value v : A. \nCons a F k sequentially composes a B-returning action a with a continuation k that takes a s return value \nand generates the rest of the approximation; the tree also carries a local auxil\u00adiary function F:U >L \nUfor mutating auxiliary state (Section 5.2). Par t1 t2 k is the parallel composition of trees t1 and \nt2, and a con\u00adtinuation k that takes the pair of their results when they join. CiC s iterated inductive \nde.nition permits the recursive occurrences of tree to be nonuniform (e.g., tree Bi in Par) and nested \n(e.g., the positive occurrence of tree A in the continuation). Since the CiC function space . includes \ncase-analysis, the continuation may branch upon the argument, which captures the pure computation of \nconditionals. This closely corresponds to the operational intuition and leads to a straightforward denotational \nsemantics. To explicitly quantify over the nondeterminism of concurrent interleaving, we de.ne a schedule \n. to be a list of paths, where a path p is a list of L or R symbols that traverse the Left or Right branches \nof Par trees and select a \u00df-redex (i.e., an action or the parallel composition of two Ret trees). p ' \n' The small-step operational semantics of trees h; t rt h , t (Figure 4, bottom) is de.ned inductively \non p to step tree t from initial heap h to a reduced tree t ' in ending heap h '. Stepping is unde.ned \nfor the Bottom and Ret trees. For the Cons and Par trees, the path p selects a \u00df-redex and performs the \nappropriate reduction. Note that only the heap and action in the tree are needed to de.ne stepping, which \ncaptures the intuition that auxiliary state U and auxiliary functions F have no bearing on the operational \nsemantics. The denotation of SCSL Hoare triples will establish that well\u00adspeci.ed programs don t go wrong \n. We follow a Milner-style approach where only well-typed (i.e., well-speci.ed) programs are given meaning \nand ensure that every action and tree encountered in the operational semantics is memory-safe relative \nto the given heap; thus we can avoid explicit fault states in the operational semantics and de.ning the \nsemantics of unsafe programs. De.nition 2 (Action and auxiliary function at a path). Given a tree t and \npath p, the action a and local auxiliary function F appear in t at path p, written (a, F) = t @ p, iff \np = nil and t = Cons a F k or p = nil and t = Par (Ret ) (Ret ) k and (a, F) = (Idle, id) or p = L::p \n' and t = Par t1 and (a, F) = t1 @ p ' or p = R::p ' and t = Par t2 and (a, F) = t2 @ p ' We write a \n= t @ p instead of (a, -) = t @ p when we are interested only in the action a, and likewise for F. De.nition \n3 (Safety). 1. Action a is safe for the heap h, if there exist h ' and v such that h; a ra h ' , v. 2. \nTree t is safe for a heap h and path p, if a = t@p implies that a is safe for h. 3. Tree t is safe for \na heap h and a schedule . if either (1) . = nil, or (2) if . = p::. ' then t is safe for h and p, and \nt ' is safe for  p '' '' '' h and . for all h and t such that h; t rt h ; t . 4. Tree t is safe for \na heap h, written memsafe h t, if it is safe for h, for any schedule .. Intuitively, t is memory-safe \nfor heap h if no matter which steps one takes through t starting from h, the actions in the tree will \nnot attempt to dereference a non-existent or ill-typed memory cell, or deallocate an unallocated cell. \nBottom and Ret trees are trivially safe because they don t step. A Cons tree is safe if it s head action \nis safe and the continuation is safe. A Par tree is safe if both of it s subtrees are safe, and when \nthey return the continuation is safe.  5.2 Coherent Con.gurations and Subjective Rely/Guarantee The \noperational semantics yields execution over the full heap, but doesn t contain enough information for \nenforcing SCSL speci.ca\u00adtions regarding mutual exclusion for critical sections over the re\u00adsource invariant \nand auxiliaries. We need to extend heaps with ad\u00additional information which is the logical state of SCSL. \nWe de.ne coherent con.gurations (hS; \u00b5S; sS | hR | hO; \u00b5O; sO) consisting of the thread s private heap \nhS, lock ownership status \u00b5S, and auxiliary sS; the shared heap hR containing the dedicated lock location \nlk and the shared resource satisfying the resource invariant I*; and the environment s private state \nhO, \u00b5O, and sO. Subjectiv\u00adity thus appears in the semantics as the logical partition of heaps, lock ownership \nstatus, and auxiliaries from the point of view of the thread being speci.ed. Although environment threads \nhave their own private states, the con.guration con.ates them into a single private state for the environment \nas a whole. Coherent con.gurations are de.ned relative to the user-chosen auxiliary PCM U and resource \ninvariant I* over U and heap such that I* (a) is precise10 for all a . U. As in CSL, precision is re\u00adquired \nto uniquely determine the invariant heaplet to be transferred between the shared and private heaplets. \nMoreover, we assume a reserved location lk for implementing the lock. De.nition 4 (Coherent Con.guration). \nA coherent con.guration is a 7-tuple c = (hS; \u00b5O; sO | hR | hO; \u00b5O; sO) such that: 1. valid (hS . hR \n. hO), valid (\u00b5S . \u00b5O), valid (sS . sO) 2. \u00b5S . \u00b5O = Own . hR |  ..= SL lk . false * I* (sS . sO) 3. \n\u00b5S . \u00b5O = Own . hR |=SL lk . true Intuitively, all components of a con.guration join in a valid way (1). \nMutual exclusion means that (2) when nobody owns lk (\u00b5S . \u00b5O Own), then the shared heap contains the \nlock lk set = .. to false and a heaplet satisfying I*(sS . sO) relative to the total auxiliary; and (3) \nif either the thread or its environment owns lk (\u00b5S . \u00b5O = Own), then the shared heap only contains the \nlock lk set to true because the owner has acquired the invariant heaplet. The large footprint con.guration \nis needed to de.ne the transi\u00adtions and establish the soundness of the logic. However, the opera\u00adtional \nsemantics only uses the full heap hS . hR . hO, and the as\u00adsertions only require the small footprint \nof the world hS; \u00b5S; sS; sO. Recall that the environment s auxiliary sO is needed in the critical section \nto establish its invariance and prove that I* is preserved (cf. the proof of incr in Section 2.4); but \nthe environment s components hO and \u00b5O are omitted from assertions because they are not needed Priv c \n= (hS ; \u00b5S ; sS | hR | dO) c ' = (h ' ; \u00b5S ; sS | hR | dO) S Acq c = (hS Own ; sS | [lk. false] . hinv \n| dO) ;.. ' c = (hS . hinv; Own ; sS | [lk. true] | dO) Rel c = (hS . hinv; Own ; sS | [lk. true] | \ndO) ' c = ;... false] . hinv | dO) (hS Own ; F(sS) | [lk Subjective guarantee transitions correspond \nto the changes that a thread can perform: mutation on the thread s Private heap, Acquiring the resource \nby locking and transferring the invariant heaplet from the shared state to the thread s private heap, \nand du\u00adally Releasing the resource. In the last case, the auxiliary function F uniquely determines how \nto change the thread s view sS. Note that in any case, the environment s private state is preserved. \nThe environment threads make complementary transitions on the shared state and the environment s private \nstate. However, as we will de.ne Hoare triples to abstract over arbitrary environment interference, a \ncoarser view suf.ces to describe mutual exclusion. De.nition 7 (Subjective rely). The subjective rely \ntransition c rR * c ' holds if the con.gurations have the form c = (hS; \u00b5S; sS | ' ' ' ' . hR | hO; \n\u00b5O; sO) and c = (hS; \u00b5S; sS | hR | h O; s ' O; \u00b5 O), and if \u00b5S = Own then s ' = sO. O A subjective rely \ntransition represents arbitrary environment interference that respects mutual exclusion. The environment \ncan mutate its private state and the shared state arbitrarily as long as coherence is preserved. If the \nthread Owns the lock, then the environment s auxiliary must remain .xed. Intuitively, r * R is the re.exive-transitive \nclosure of the transpose of rG, i.e., where mutation is done on the environment s private state instead \nof the thread s private state, and with any possible auxiliary function F. Note that in any case, the \nthread s private state is preserved.  5.3 Modal Predicates We next de.ne a number of modal predicates \nover all possible steps of execution to relate the operational semantics over heaps and the subjective \nrely/guarantee transitions over coherent con.gurations. De.nition 8 (Modal predicates). The predicates \nalways. c t p, always c t P, and after c t Q are de.ned relative to a schedule ., con.guration c, A-returning \ntree t, and predicates P : con.g . tree A . prop and Q : con.g . A . prop: always. c t P = .cR. c rR \n* cR . . memsafe (hp(cR)) t . P cR t . . . = p::. p ''' ' ... ... .p . . hp(cR); t . hG t rt hG; t for \nlocal veri.cation of a thread. .cG F. hp(cG) = hG . F = t @ p . F ' cR rG cG . always.1 cG t P De.nition \n5. A con.guration c = (hS; \u00b5S; sS | hR | hO; \u00b5O; sO) has heap hp(c) = hS .hR .hO and world wd(c) = hS; \n\u00b5S; sS; sO. Given the spatial description of con.gurations, we can de.ne the temporal notions of subjective \nrely/guarantee transitions rR * and F rG for environment and thread interference on a con.guration that \nrespect mutual exclusion and auxiliary updates. De.nition 6 (Subjective guarantee). The subjective guarantee \nF transition c rG c ' holds relative to F : U >L U if the con.g\u00adurations c and c ' have one of the forms \n(where dO = hO; \u00b5O; sO): 10 A heap predicate p is precise if it determines a unique subheap: for every \nheap h with subheaps h1, h2, if h1 |=SL p and h2 |=SL p then h1 = h2. always c t P = .. . always. c t \nP '' '' ' ' after c t Q = always c t (.c t . .v . t = Ret v . Q c ' v ) always c t P expresses the fact \nthat starting from con.guration c, the tree t remains memory-safe and the user-chosen predicate P holds \nof all intermediate con.gurations and trees, for any sched\u00adule . and under any environment interference. \nThe helper predicate always. c t P is de.ned by induction on .: the environment is al\u00adlowed to make arbitrary \nsubjective rely interference from c to cR, the resulting con.guration must have a heap that s memory \nsafe for t and the predicate P cR t holds; moreover, if the schedule is p::. ' and t steps to hG and \nt ', then there must be a subjective guarantee transition from cR to cG whose heap is hG, and the predicate \nre\u00adcurses on . ' , cG, and t '. Mutual exclusion is thus ensured because all transitions conform to subjective \nrely/guarantee transitions. after c t Q encodes that t is memory safe and respects mutual exclusion; \nhowever, Q c ' v ' only holds if t steps completely to Ret v ' in con.guration c ' .  5.4 SCSL Denotational \nSemantics The denotational semantics of SCSL commands and judgments are de.ned simultaneously. The mutual \nrecursion is neccessary because the denotation of judgments depends on the denotation of commands and \nprocedures, while the denotation of a .xed point procedure depends on the denotation of its procedure \ntriple to determine the lattice in which to take the .xed point. We denote SCSL programs as sets T of \ntrees of increasing precision including the Bottom tree, which is the coarsest possible approximation \nof any program: prog A = {T . P(tree A) | Bottom . T }. To model recursion, we construct a complete lattice \nof Hoare types to get .xed points. We use the after predicate to ensure the tree approximations are memory \nsafe, respect mutual exclusion, and satisfy their SCSL speci.cations. De.nition 9 (Hoare types). Fix \nprecondition p : world . prop postcondition q : A . world . prop, with free logical variables FLV(p, \nq). The Hoare type {|p|}A{|q|} is de.ned as follows. {|p|}A{|q|} = {T . prog A | .FLV(p, q) (c :con.g) \n(t . T ). (wd(c) |= p) . after c t (.c ' v ' . wd(c ' ) |= q v ' )} Intuitively, the denotation of a \nSCSL judgment {p}C :A{q} is the set of trees T denoting the command C , together with a proof that for \nany initial con.guration c whose world wd(c) satis.es the precondition p, then after executing any tree \nt . T from c produces some result value v ' and .nal con.guration c ' whose world wd(c ' ) satis.es postcondition \nq. The de.nition quanti.es over the free logical variables of p and q in order to give these variables \nlocal scope, as stipulated in Section 4. SCSL assertions (Section 2.3) are arbitrary CiC predicates of \ntype world . prop over worlds, where world = heap \u00d7 mtx \u00d7 U \u00d7 U. For example, the predicate aS >> s ' \nis de.ned as .w:world. (.h \u00b5 .. w = h; \u00b5; s ' ; .). We retain the w |= p nota\u00adtion for the application \np w. Lemma 1. The type {|p|}A{|q|} is a complete lattice, with set union as the join operator, and {Bottom} \nas the unit element. The type .x:B. {|p|}A{|q|} of functions mapping x : B into {|p|}A{|q|}, where A, \np, q may depend on x, is also a complete lattice, with the join operator on functions de.ned pointwise, \nand the constant {Bottom} function as the unit element. The denotation of judgments [[G f J ] (Figure \n5, top) turns SCSL judgments into CiC typing judgments (fCiC). A command speci.cation {p} - :A{q} is \ndenoted by the CiC type {|p|}A{|q|}, and a procedure speci.cation .x:B. {p}-:A{q} is denoted by the CiC \nmonadic function type .x:B. {|p|}A{|q|}. The (p1, q1) (p2, q2) judgment generalizes the usual side conditions \non the rule of CONSEQuence: (1) p2 . p1 for strength\u00adening the precondition and (2) q1 . q2 for weakening \nthe postcon\u00addition, and adapts them to the local interpretation of logical vari\u00adables. The .rst conjunct \nin the denotation existentially quanti.es the respective logic variables of p2 and of p1 to generalize \n(1); the quanti.cation is existential to match the de.nition of Hoare types, which quantify universally \nover FLV(p, q) and have a negative oc\u00adcurrence of the precondition. The second conjunct generalizes (2) \nby universally quantifying the respective logic variables, taking into account that the logic variables \nof qi are constrained by the precon\u00addition pi . The denotation of commands and procedures (Figure 5, \nbot\u00adtom) is subsidiary to that of judgments because the .xed-point con\u00adstruction is indexed by the argument \nand return types, and the pre\u00adand postconditions. An A-returning command C is denoted by a set of approximating \ntrees in prog A, and an A-returning procedure F with argument B is denoted by a set of trees in B . prog \nA. [ \u00b7] = \u00b7 [[G, x:A] = [[G]], x : A [[G, .x:B. {p} f (x):A {q}] = [[G]], f : .x:B. {|p|}A{|q|} [[G f \n{p} C : A {q}] = [[G]] fCiC [ C ] : {|p|}A{|q|} [[G f .x:B.{p}F (x) : A{q}] = [[G]] fCiC [ F ] : .x:B. \n{|p|}A{|q|} [[G f e : A] = [[G]] fCiC e : A [[G f (p1, q1) (p2, q2)]] = [[G]] fCiC .w w ' :world. (w \n|= (.v\u00af2. p2) . (.v\u00af1. p1)) . ' ' ((.v\u00af1. w |= p1 . w |= q1) . (.v\u00af2. w |= p2 . w |= q2)) where v\u00afi = \nFLV(pi , qi ) [ allocA] (x:A) = {Bottom, Cons (Alloc x) id Ret}[ dealloc] (x:ptr) = {Bottom, Cons (Dealloc \nx) id Ret}[ readA] (x:ptr) = {Bottom, Cons (ReadA x) id Ret} [ writeA] (x:ptr) (y:A) = {Bottom, Cons \n(Write x y) id Ret}[ lock] = {tk | k . N}where t0 = Bottom, tk+1 = Cons (CAS lk false true) id (.x. if \nx then Ret () else tk) [ unlockF] = {Bottom, Cons (Write lk false) F Ret}[ retA] (x:A) = {Bottom, Ret \nx} [ x . C1; C2] = [ C1]]; (.x. [ C2]]) [ C1 I C2] = [ C1] I [ C2] [ if e then C1 else C2] = if e then \n[ C1] else [ C2] [ F (e)]] = [ F ] (e) [ .x f B,A,p,q. x. C ] = lfp.x:B. {|p|}A{|q|} (.f ..x. [ C ]]) \nFigure 5. Denotational semantics of SCSL judgments (top), and commands and procedures (bottom). Each \nSCSL memory command is denoted by a pair of approxi\u00admations: Bottom, and a Cons tree with the appropriate \naction and a Ret continuation. We use the identity function on U as our aux\u00adiliary function (which is \nobviously local) because memory com\u00admands don t change auxiliary state. The lock command is denoted by \nthe set of approximations of a loop around a CAS to atomically change the contents of the ded\u00adicated \nlock lk from false to true, until it succeeds. Intuitively, this is an explicit least .xed point construction. \nThe unlockF command writes false into the dedicated pointer lk and updates the auxiliary state according \nto the user-provided local auxiliary function F. The sequential composition of commands uses the sequential \ncomposition (T1; K2) . prog B of a set of trees T1 . prog A and a function into a set of trees K2 . A \n.prog B, which concatenates t1 N K2 each tree t1 . T1 with a continuation in K2. T1; K2 = {t1 N K2 | \nt1 . T1} where Ret v N K = K v Par t1 t2 k N K = {Par t1 t2 k ' | .x. k ' x . (k x N K )}Cons a F k N \nK = {Cons a F k ' | .x. k ' x . (k x N K )}Bottom N K = {Bottom} The de.nition is well-founded because \nthe continuation k ' approx\u00adimates trees in k x N K for every x, as permitted by the iterated inductive \nde.nition. The parallel composition of commands uses the parallel com\u00adposition T1 I T2 . prog (A1 \u00d7 A2) \nof sets of trees T1 . prog A1 and T2 . prog A2, which includes Bottom and all the pairwise parallel compositions \nof trees in T1 and T2. T1 I T2 = {Bottom} . {Par t1 t2 Ret | t1 . T1 . t2 . T2} Since all SCSL program \nconstructors preserve monotonicity, the .x f .x.C procedure can take the least .xed point lfp of the \nfunction .f . .x. [ C ] by the Knaster-Tarski theorem.  5.5 Modal Lemmas and Soundness Theorem We culminate \nwith the proof of soundness of the interpretation. We have carried all of these proofs in Coq [16], they \nusually proceed by an induction on the schedule .. The Determinacy lemma means subjective guarantee transitions \nfrom a con.guration that result in equal heaps, also result in equal con.gurations (i.e., with equal \nauxiliaries and heap partitions). Thus, stepping a tree in always uniquely determines the auxiliary state, \nwhich is crucial for the soundness of the CONJunction rule. Lemma 2 (Determinacy of Subjective Guarantee \ntransitions). If F F c rG c1, c rG c2, and hp(c1) = hp(c2), then c1 = c2. The Universal lemma states \nthat the modal always commutes with universal quanti.cation, which yields to the soundness of an in.nitary \nCONJunction rule. The assumption always c t (.c ' t ' . True) makes the lemma hold when the quanti.cation \nover x is vacuous. Lemma 3 (Universal). If always c t (.c ' t ' . True), then always commutes with universal \nquanti.cation: '' '' '''' always c t (.c t . .x. P x c t ) iff .x. always c t (.c t . P x c t ). The \nNormality lemma corresponds to weakening the postcondi\u00adtion, which is needed for the proof of the CONSEQ \nrule. Lemma 4 (Normality for after). If after c t Q1 and Q1 c ' v ' . '' '' Q2 c v for all c and v , \nthen after c t Q2. Closure under sequential composition justi.es the SEQ rule: q holds at the end of \na concatenated tree if the .nal con.guration of the pre.x can be used as an initial con.guration for \nthe suf.x to show q holds after. Lemma 5 (Closure under sequential composition). If t12 . t1 N '''' ' \n'' T2 and after c t1 (.c v . .t . t . T2 v . after c t Q), then after c t12 Q. Closure under parallel \ncomposition justi.es the PAR rule. Intu\u00aditively, it holds because when (an approximation t2 of) C2 takes \na step over its private and shared state, it amounts to rR * environ\u00adment interference on (an approximation \nt1 of) C1, and vice versa. Note that the pattern of rearranging subjective thread/environment components \nrecurs at the level of triples d = h; \u00b5; s: the parallel composition uses (d1 . d2, dO) and the left \nand right child threads use (d1, d2 . dO) and (d2, d1 . dO), respectively. Lemma 6 (Closure under parallel \ncomposition). If after (d1 | hR | d2 . dO) t1 Q1 and after (d2 | hR | d1 . dO) t2 Q2, then after (d1 \n. d2 | hR | dO) (Par t1 t2 Ret) (Q1 \u00ae Q2), where '' ''''' ' ''' Q1 \u00ae Q2 = .c v . .d d h dO. c = (d . \nd | h | d ) . 1 2 R 1 2 R O ''' '' Q1 (d | h | d . d ) (v .1) . 1 R 2 O ''' '' Q2 (d | h | d . d ) (v \n.2) 2 R 1 O Finally, the Frame lemma can be viewed as an instance of the Parallel lemma, by taking C2 \nto be the idle thread that does not change the heap or auxiliaries. Lemma 7 (Frame). If after (d1 | hR \n| d2 . dO) t Q, then after (d1 . d2 | hR | dO) t Q ' , where ' '''''' ' '' Q = .c v . .d h d c = (d . \nd2, hR, d ) . 1 R O. 1 O '' ' Q (d | h | d2 . d ) v 1 R O Theorem 1 (Soundness). If G f J , then [[G \nf J ] . Proof. By induction on the derivation of J . Each basic command is sound because the pre-and \npostconditions are stable under en\u00advironment interference, the precondition implies the command is memsafe, \nand the resulting con.guration satis.es the postcondi\u00adtion. The SEQ, PAR and FRAME rules are sound by \nLemmas 5, 6, and 7. The .x rule is sound by the Knaster-Tarski theorem. The CONJ rule is sound by Lemma \n3, and the CONSEQ rule by Lemma 4. The EXISTential rule and IF rules are derivable. Since SCSL procedures \nare interpreted as (monadic) CiC functions. the procedure APPlication and HYPothesis rules are sound \nby the func\u00adtion application and hypothesis rules of CiC. 6. Related Work Owicki and Gries Resource Invariants \n(RI) [21] emphasizes a spatial speci.cation of shared state that usually suf.ces for coarse\u00adgrained concurrency. \nJones Rely/Guarantee (RG) [12] emphasizes a temporal speci.cation of thread and environment interference \non shared state that is appropriate for .ne-grained concurrency and can avoid some of the auxiliary state \nthat appears in RI proofs. The combination of RI or RG with Separation Logic in Concur\u00adrent Separation \nLogic (CSL) [19], RGSep [26], SAGL [9, 8], and Deny-Guarantee [7] has proved fruitful for the compositional \nveri\u00ad.cation of stateful, concurrent programs. However, to prove nonin\u00advariant properties as in the incrementor \nexample, those logics still require auxiliary state to relate local program assertions to global (spatial \nor temporal) invariants. Auxiliary state makes the proof of a single thread sensitive to the global thread \nstructure, which prevents local reasoning and leads to noncompositionality. In SCSL, subjec\u00adtive auxiliary \nstate suf.ces to overcome this noncompositionality and recovers local reasoning in a CSL-style logic. \nOn the other hand, RG speci.cations give .ne-grained descriptions of possible interference, which to \nour knowledge isn t possible with subjective auxiliary state and RI alone. Whereas CSL and existing variants \nuse local speci.cations that only refer to the program s private state, SCSL gains expressivity through \nthe aO view to provide non-local information about the environment s auxiliary contribution, but retains \nCSL-style local reasoning by leveraging the PCM structure of auxiliaries to avoid sensitivity to the \nenvironment s thread structure. Concurrent Abstract Predicates (CAP) [6] by Dinsdale-Young et al. s is \nan axiomatic logic that can prove the incrementor and coarse-grained set without auxiliary state. A CAP \nproof in\u00advolves de.ning a set of actions, which are RG-style transitions on private and shared state, \nwhich includes concrete heap and abstract capabilities that identify enabled actions (thus there is a \nsubtle mutual recursion between an action and the capability to perform the action). Deductions in a \nproof use the actions to move heap and capabilities between the private and shared states. Intermediate \nassertions must be checked to be stable under the environment s action interference, which is standard \nin RG-style proofs. Whereas our prototype SCSL only provides one lock with global scope, CAP provides \nmultiple shared regions each with an associated set of protocols (i.e., RG interference speci.cations). \nAlthough CAP overcomes the need for auxiliary state, in our opinion the corresponding proofs of the incrementor \nand coarse\u00adgrained set are more indirect than the noncompositional RI proofs based on auxiliary state. \nMoreover, we consider the complexity of .ne-grained interference reasoning should be unnecessary for \ncoarse-grained concurrency, where critical sections are meant to abstract away from interference. To \nachieve compositional proofs of the same programs in SCSL, it suf.ces to pick a PCM and resource invariant, \nand to conduct RI-style sequential reasoning in the critical section. Although SCSL assertions go beyond \nprivate state in mentioning the environment s contribution aO, it is only tracked in the critical section \nwhere it is known to remain .xed, so we can avoid reasoning about stability under interference. Since \nSCSL follows the RI tradition, it is best suited for coarse\u00adgrained concurrency; by contrast, CAP is \nmore general because the interference speci.cations yield compositional proofs for both coarse-and .ne-grained \nconcurrency. Moreover, abstract predi\u00adcates enable modularity by giving different library implementa\u00adtions \nthe same speci.cation, thus hiding their internal concurrency. Since the SCSL embedding into CiC gives \nus access to abstraction over predicates (as well as over types and higher-order modules), SCSL already \nsupports this kind of modularity. However, to reach the expressive power of CAP, we have to investigate \nhow to com\u00adbine subjectivity with RG for .ne-grained concurrency.  Jacobs and Piessens .ne-grained concurrency \nspeci.ca\u00adtions [11] provide an alternative means for modularity: a procedure can be veri.ed parametrically \nin the caller s invariant, auxiliary state and code, which are then instantiated by each call site. This \nallows verifying the increment procedure once, but the two-and three-thread programs must use different \ninvariants and each pro\u00adcedure call must use different auxiliary state and update code. In SCSL, we can \nalso parametrize a procedure in the caller s invariant and auxiliaries as illustrated by the iterator. \nMoreover, subjectivity overcomes the need for different invariants and auxiliary state, and local auxiliary \nfunctions can update the auxiliary without sensitiv\u00adity to the thread s identity. To our knowledge, SCSL \nis the .rst axiomatic concurrency logic to support higher-order procedures, which is necessary to prove \nthe iterator where the argument procedure exposes its effects and is general enough to support polymorphic \ninstantiation (e.g., iter (iter xincr2) in Section 3.2). A .rst-order iterator has been proved in CAP \n[5], where the procedure applied to each element is hard-coded and doesn t expose any state or concurrency \neffects. Fu et al. s HLRG logic [10] combines rely/guarantee and tem\u00adporal reasoning over explicit history \ntraces. This eliminates the need for auxiliary state, but, as in CAP, at the expense of more involved \nreasoning than necessary in the case of coarse-grained al\u00adgorithms. HLRG only handles a single top-level \nparallel composi\u00adtion of a .xed number of threads; by contrast, SCSL allows parallel composition in any \ncommand and the number of forked threads can vary dynamically, which is necessary to prove the iterator. \nThe denotational semantics of SCSL is inspired by Brookes domain-theoretic model for CSL [3], but differs \nin several cru\u00adcial respects. Brookes uses store (a.k.a. stack), heap, and resource (a.k.a. lock) actions \nto represent the operation and its result. We use actions to represent heap operations, and only by stepping \nan action do we obtain its result. We can avoid a stack altogether because our commands return values \nwhich are bound to immutable variables (a.k.a. identi.ers). Since we implement the lock with a dedicated \nheap location, we avoid a separate notion of resource actions.  Brookes denotes a command as a set of \naction traces, which are .nite or in.nite sequences of actions including all possible results. For example, \nreading e has the denotation {(Read e, m)}m.Z. We avoid enumerating all possible results by shifting \nto action trees: the Cons tree pairs an action (in our sense) with a continuation that takes the result \nof the operation and generates a tree for the rest of the computation. Since we are concerned with safety \nproperties, it suf.ces to consider .nite tree approximations. Brookes parallel composition is given by \na fairmerge interleav\u00ading of traces. For example, reading e in parallel has the denota\u00adtion {(Read e, \nm) (Read e, n)}m,n.Z, the case m n is a non\u00ad = sequential trace that accounts for the environment mutating \ne be\u00adtween the two reads and is needed for compositionality. We avoid dealing with non-sequential traces \nby including a Parallel tree con\u00adstructor and unfolding the execution in the always predicate. Brookes \nincludes a fault state to account for races (i.e., one thread writes to a location while another thread \nalso reads or writes), accessing a nonexistent location, and unlocking without restoring the resource \ninvariant. We avoid an explicit fault state by ensuring that well-speci.ed programs don t go wrong : \nevery heap operation encountered during an execution is safe to execute. We do not identify races because \nthreads must interfere on the im\u00adplicit lock location, but it is immediate from the interpretation of \nHoare triples that parallel threads can otherwise only mutate their private heaps, which are disjoint. \nBesides Brookes denotational model, Vafeiadis [25] and Feng et al. [9] give operational proofs of CSL \ns soundness. We are sim\u00adilar to those approaches in two ways: (1) the explicit use of RG\u00adstyle speci.cations \nin the semantics to describe interference over the shared resource, and (2) the use of step-indexing \nin the de.ni\u00adtion of safety, although we use tree paths whereas they use natural numbers. Since we interpret \nSCSL Hoare triples as monadic func\u00adtions in CiC, however, operational methods do not suf.ce and we must \nresort to a semantic proof of soundness. Existing approaches to the soundness of CSL use a small foot\u00adprint \nin the sense that their semantic de.nitions of safety only refer to the thread s private state and (in \nsome cases) the shared state. Similarly, the combination of RG and Separation Logic in RGSep [26] and \nSAGL [9, 8] only describe interference over the shared state. By contrast, our subjective rely/guarantee \ntran\u00adsitions use a large footprint, which encompasses the shared state as well as the thread and environment \ns private state of heap, lock ownership, and user-chosen auxiliary state. While our subjective rely/guarantee \ntransitions are hard-coded for RI, we expect that the logic can be generalized to user-chosen RG interference \nand thus we will be able to verify .ne-grained concurrency. The concept of local action appears in Abstract \nSeparation Logic [4] to model stateful, non-deterministic programs. A local action is a function f : \nS . P (S)T where S is a separation algebra (i.e., a cancellative PCM) of states s. The codomain is a \nset of possible next-states to express nondeterminism or an error marker T to indicate that the action \nfaults. The function must satisfy the locality condition: if valid (s1 .s2), then f (s1 .s2) {s1 ' . \ns2 | s1 ' . f (s1)}. By contrast, our local auxiliary functions F are deterministic because there is \nat most one possible next\u00adstate and we implicitly avoid the error marker by using the validity conditions. \nSince auxiliary functions can be noncomputable, we conjecture they will enable more expressive speci.cations \nthan the traditional use of (computable) auxiliary code. Krishnaswami et al. [15] use a PCM to abstractly \nrepresent the states of various program modules in a setting of a sequential higher-order language. Similar \nto our resource invariant, their mod\u00adule invariants are also predicates over the combined abstract states \nof all the modules. 7. Conclusion and Future Work We propose Subjective Concurrent Separation Logic (SCSL) \nas a combination of Resource Invariants and Separation Logic with sub\u00adjective auxiliary state, which \ntames the objective thread structure exposed by classical auxiliary state. The approach is enabled by \ngeneralizing auxiliaries from stack and heap to user-chosen par\u00adtial commutative monoids (PCM), and from \nauxiliary code to local auxiliary functions. Each thread has a subjective perspective that splits auxiliary \nstate into contributions by the self (the thread itself) and the other (its environment). The auxiliary \nPCM crucially per\u00admits agglomerating all environment thread s contributions, which makes proofs insensitive \nto the internal concurrency of the envi\u00adronment. SCSL provides parallel composition and frame rules that \nuse the subjective separating conjunction to split auxiliary contri\u00adbutions in a coherent manner; surprisingly, \nthe rules are sound even if the auxiliary PCM is not cancellative. For an incrementor and a coarse-grained \nset with logically dis\u00adjoint interference, we show that suitable choice of auxiliary PCM yields simple, \ncompositional proofs independent of the number of parallel threads; by contrast, existing logics either \nuse aux\u00adiliary state which makes proofs sensitive to the global thread structure, or achieve compositionality \nat the expense of complex Rely/Guarantee reasoning. We also prove a higher-order iterator with dynamic \nthread creation, whose veri.cation is independent of the internal concurrency of the function applied \nto each element. In future work, we will study how subjective auxiliary state scales to more complex, \nreal-world programs.  We prove the soundness of SCSL by a shallow embedding into the Calculus of Inductive \nConstructions using a novel denota\u00adtional semantics of action trees and a de.nition of safety that uses \nrely/guarantee transitions over a large subjective footprint encom\u00adpassing heaps, lock ownership, and \nuser-chosen auxiliaries. Since SCSL provides a single lock with global scope, a proof is committed to \na single auxiliary PCM and resource invariant. In fu\u00adture work, we will scale the logic to multiple locks \nwith delimited scope and re.nement across auxiliary PCMs and resource invari\u00adants. We will also study \nthe combination of subjective auxiliary state Rely/Guarantee reasoning for .ne-grained programs in the \npresence of richer language constructs such as separate fork and join commands. Acknowledgments This \nresearch has been partially supported by Spanish MICINN Project TIN2010-20639 Paran10; AMAROUT grant \nPCOFUND\u00adGA-2008-229599; and Ramon y Cajal grant RYC-2010-0743. References [1] Richard Bornat, Cristiano \nCalcagno, Peter W. O Hearn, and Matthew J. Parkinson. Permission accounting in separation logic. In POPL, \n2005. [2] Richard Bornat, Cristiano Calcagno, and Hongseok Yang. Variables as resource in separation \nlogic. ENTCS, 155, 2006. [3] Stephen Brookes. A semantics for concurrent separation logic. Theor. Comput. \nSci., 375(1-3), 2007. [4] Cristiano Calcagno, Peter W. O Hearn, and Hongseok Yang. Local action and abstract \nseparation logic. In LICS, 2007. [5] Pedro da Rocha Pinto, Thomas Dinsdale-Young, Mike Dodds, Philippa \nGardner, and Mark J. Wheelhouse. A simple abstraction for complex concurrent indexes. In OOPSLA, 2011. \n[6] Thomas Dinsdale-Young, Mike Dodds, Philippa Gardner, Matthew J. Parkinson, and Viktor Vafeiadis. \nConcurrent abstract predicates. In ECOOP, 2010. [7] Mike Dodds, Xinyu Feng, Matthew J. Parkinson, and \nViktor Vafeiadis. Deny-guarantee reasoning. In ESOP, 2009. [8] Xinyu Feng. Local rely-guarantee reasoning. \nIn POPL, 2009. [9] Xinyu Feng, Rodrigo Ferreira, and Zhong Shao. On the relationship between concurrent \nseparation logic and assume-guarantee reasoning. In ESOP, 2007. [10] Ming Fu, Yong Li, Xinyu Feng, Zhong \nShao, and Yu Zhang. Reason\u00ading about optimistic concurrency using a program logic for history. In CONCUR, \n2010. [11] Bart Jacobs and Frank Piessens. Expressive modular .ne-grained concurrency speci.cation. In \nPOPL, 2011. [12] Cliff B. Jones. Speci.cation and design of (parallel) programs. In IFIP Congress, 1983. \n[13] Cliff B. Jones. The role of auxiliary variables in the formal develop\u00adment of concurrent programs. \nTechnical Report CS-TR-1179, Uni\u00adversity of Newcastle upon Tyne, Computing Science, 2009. [14] Thomas \nKleymann. Hoare logic and auxiliary variables. Formal Aspects of Computing, 11, 1999. [15] Neelakantan \nR. Krishnaswami, Aaron Turon, Derek Dreyer, and Deepak Garg. Super.cially substructural types. In ICFP, \n2012. [16] Ruy Ley-Wild and Aleksandar Nanevski. Supporting Material. https://software.imdea.org/ aleks/scsl/, \nJuly 2012. [17] Per Martin-L \u00a8Haupstatz for the intuitionistic theory of iterated of. inductive de.nitions. \nIn Scandinavian Logic Symposium, 1971. [18] The Coq development team. The Coq proof assistant reference \nman\u00adual. LogiCal Project, 2004. Version 8.0. [19] Peter W. O Hearn. Resources, concurrency, and local \nreasoning. Theor. Comput. Sci., 375(1-3), 2007. [20] Susan S. Owicki. Axiomatic Proof Techniques for \nParallel Programs. PhD thesis, Cornell University, 1975. [21] Susan S. Owicki and David Gries. Verifying \nproperties of parallel programs: An axiomatic approach. Commun. ACM, 19(5), 1976. [22] Matthew J. Parkinson \nand Gavin M. Bierman. Separation logic and abstraction. In POPL, 2005. [23] Matthew J. Parkinson, Richard \nBornat, and Cristiano Calcagno. Vari\u00adables as resource in Hoare logics. In LICS, 2006. [24] Uday S. Reddy \nand John C. Reynolds. Syntactic control of interfer\u00adence for separation logic. In POPL, 2012. [25] Viktor \nVafeiadis. Concurrent separation logic and operational seman\u00adtics. ENTCS, 276, 2011. [26] Viktor Vafeiadis \nand Matthew J. Parkinson. A marriage of rely/guarantee and separation logic. In CONCUR, 2007.   \n\t\t\t", "proc_id": "2429069", "abstract": "<p>From Owicki-Gries' Resource Invariants and Jones' Rely/Guarantee to modern variants based on Separation Logic, axiomatic logics for concurrency require auxiliary state to explicitly relate the effect of all threads to the global invariant on the shared resource. Unfortunately, auxiliary state gives the proof of an individual thread access to the auxiliaries of all other threads. This makes proofs sensitive to the global context, which prevents local reasoning and compositionality.</p> <p>To tame this historical difficulty of auxiliary state, we propose subjective auxiliary state, whereby each thread is verified using a self view (i.e., the thread's effect on the shared resource) and an other view (i.e., the collective effect of all the other threads). Subjectivity generalizes auxiliary state from stacks and heaps to user-chosen partial commutative monoids, which can eliminate the dependence on the global thread structure.</p> <p>We employ subjectivity to formulate Subjective Concurrent Separation Logic as a combination of subjective auxiliary state and Concurrent Separation Logic. The logic yields simple, compositional proofs of coarse-grained concurrent programs that use auxiliary state, and scales to support higher-order recursive procedures that can themselves fork new threads. We prove the soundness of the logic with a novel denotational semantics of action trees and a definition of safety using rely/guarantee transitions over a large subjective footprint. We have mechanized the denotational semantics, logic, metatheory, and a number of examples by a shallow embedding in Coq.</p>", "authors": [{"name": "Ruy Ley-Wild", "author_profile_id": "81351606631", "affiliation": "IMDEA Software Institute, Madrid, Spain", "person_id": "P3978059", "email_address": "ruy.leywild@imdea.org", "orcid_id": ""}, {"name": "Aleksandar Nanevski", "author_profile_id": "81100503327", "affiliation": "IMDEA Software Institute, Madrid, Spain", "person_id": "P3978060", "email_address": "aleks.nanevski@imdea.org", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429134", "year": "2013", "article_id": "2429134", "conference": "POPL", "title": "Subjective auxiliary state for coarse-grained concurrency", "url": "http://dl.acm.org/citation.cfm?id=2429134"}