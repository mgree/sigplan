{"article_publication_date": "01-23-2013", "fulltext": "\n Synthesis of Biological Models from Mutation Experiments Ali Sinan K oksal\u00a81 Yewen Pu1 Saurabh Srivastava1 \nRastislav Bod\u00b4ik1 Jasmin Fisher2 Nir Piterman3 1University of California, Berkeley 2Microsoft Research, \nCambridge 3University of Leicester koksal@cs.berkeley.edu, yewenpu@mit.edu, saurabhs@cs.berkeley.edu, \nbodik@cs.berkeley.edu, jasmin..sher@microsoft.com, nir.piterman@le.ac.uk Abstract Executable biology \npresents new challenges to formal methods. This paper addresses two problems that cell biologists face \nwhen developing formally analyzable models. First, we show how to automatically synthesize a concurrent \nin-silico model for cell development given in-vivo experiments of how particular mutations in.uence the \nexperiment outcome. The problem of synthesis under mutations is unique because mutations may produce \nnon-deterministic outcomes (presumably by introduc\u00ading races between competing signaling pathways in \nthe cells) and the synthesized model must be able to replay all these outcomes in order to faithfully \ndescribe the modeled cellular processes. In contrast, a regular concurrent program is correct if it picks \nany outcome allowed by the non-deterministic speci.cation. We devel\u00adoped synthesis algorithms and synthesized \na model of cell fate de\u00adtermination of the earthworm C. elegans. A version of this model previously took \nsystems biologists months to develop. Second, we address the problem of under-constrained speci.\u00adcations \nthat arise due to incomplete sets of mutation experiments. Under-constrained speci.cations give rise \nto distinct models, each explaining the same phenomenon differently. Addressing the ambi\u00adguity of speci.cations \ncorresponds to analyzing the space of plausi\u00adble models. We develop algorithms for detecting ambiguity \nin spec\u00adi.cations, i.e., whether there exist alternative models that would produce different fates on \nsome unperformed experiment, and for removing redundancy from speci.cations, i.e., computing minimal \nnon-ambiguous speci.cations. Additionally, we develop a modeling language and embed it into Scala. We \ndescribe how this language design and embedding al\u00adlows us to build an ef.cient synthesizer. For our \nC. elegans case study, we infer two observationally equivalent models expressing different biological \nhypotheses through different protein interac\u00adtions. One of these hypotheses was previously unknown to \nbiolo\u00adgists. This work was supported in part by NSF grant 1019343 to the Computing Research Association \nfor the CIFellows Project, and by NSF grant CCF\u00ad1139011. Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. POPL 13, January 23 25, 2013, Rome, Italy. Copyright \nc &#38;#169; 2013 ACM 978-1-4503-1832-7/13/01. . . $10.00 Categories and Subject Descriptors F.3.1 [Logics \nand Meaning of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams Keywords Program Synthesis, \nSpeci.cation Ambiguity Analysis, Executable Biology 1. Introduction Diseases can be caused by perturbed \ngene and protein regulatory networks. For example, disease X may be related to the levels of proteins \nP and R, and P may negatively regulate R. Once the level of P is decreased, high levels of R may cause \ndisease X. To avoid the disease, we may want to increase the level of P. One way to infer protein regulatory \nnetworks is to carry out mutation experiments, in which cells are genetically modi.ed to suppress or \nenhance the activity of a certain protein, leading the cell to exhibit abnormal behavior such as uncontrolled \ncell divisions. If, by suppressing the activity of protein P, the resulting phenotype can be attributed \nto, say, an increased activity of a known protein R, we can infer from this mutation experiment that \nP negatively regulates R. From many such inferences, experimental biologists deduce regulatory networks \nthat describe the causal events leading to speci.c cell fates and other behaviors. Experimental biologists \nare concerned about the correctness of their models that give a dynamic explanation of how the observed \noutcomes are produced. Executable biology [14] addresses this concern by building executable models that \ncan be veri.ed against performed experiments. Treating cells as concurrent agents mod\u00adels the fact that \ncells do not evolve at synchronous rates [19, 20]. Veri.cation ensures that a concurrent model is correct \nfor all vari\u00adations of cell growth rates, by exploring all possible executions of the model [15]. Unfortunately, \nturning informal maps of regulatory networks common in biological literature into executable models is \nlaborious because it involves explicitly de.ning timing delay and strength of how multiple proteins regulate \neach other. In our previous work, some of us developed a model of vulval cell fate speci.cation (i.e., \nhow vulval cells make the decision to develop into a partic\u00adular cell type) in the C. elegans worm [12]. \nThis model correctly predicted an unknown protein-protein interaction, however it took several months \nto tweak the details of the model before it was veri\u00ad.ed against the experimental data. Whenever new \nexperiments are added, or when the model is extended with new components, simi\u00adlar tweaks are required. \nThis paper develops techniques for synthesizing executable models from experimental observations and \nprior biological knowl\u00adedge. Two challenges make this synthesis problem interesting. First, the outcomes \nof some cellular systems, such as fates of stem cells, are non-deterministic. For example, in the C. \nelegans system that we study, some mutations cause the six observed vulval pre\u00adcursor cells (VPCs) to \nacquire one of two alternative fates, presum\u00adably due to races in the communication among cells. The \ndesired executable model must be able to reproduce all the observed be\u00adhavior in order to be correct. \nWe synthesize concurrent cell models such that, for each observable outcome, there exists a schedule \nthat leads the model to produce the outcome. This requirement makes our synthesis task a new problem, \nwhich is more complex than what has been previously addressed. Second, the incomplete set of mutation \nexperiments forms only a partial speci.cation. Because only certain genes are mutated from the total \ncombinatorial set of possible mutations, we cannot be cer\u00adtain that an executable model that veri.es \nagainst these mutations, whether it is synthesized or manually constructed, is the sole expla\u00adnation \nof the cellular regulatory process. This is because there could exist an alternative model that is observationally \nidentical on the current speci.cation but observationally distinct on an additional mutation. Finding \nsuch an additional mutation would uncover am\u00adbiguity in the current speci.cation. To con.rm that we have \nsynthesized a unique model, we go be\u00adyond synthesis and develop methods for the analysis of the space \nof plausible models, i.e., models that agree with the speci.cation. If observationally distinct models \nexist, we suggest a new mutation that differentiates them. If no alternative models exist, we deter\u00admine \nthe smallest set of experiments that is suf.cient to arrive at the unique model. Finding such a minimal \nset is interesting because, should biologists decide to redo the experiments for validation, they only \nneed to perform the experiments that suf.ce to synthesize a unique model. Finally, it is interesting \nto ask whether there are ob\u00adservationally identical but internally different models. Such models present \nregulatory networks where the network function is imple\u00admented via different protein interactions. These \nmodels cannot be distinguished by observing phenotypes; we must, say, instrument proteins with .uorescent \nmarkers (similar to tracing the program) and observe the cell during its development. This is a harder \nexper\u00adiment, but the cost of instrumentation is reduced with the help of formal methods, as we can identify \nwhich genes to mark given the internal differences between the observationally identical models. We have \nbuilt an ef.cient veri.er, synthesizer and speci.cation ambiguity analyzer that implements algorithms \nfor the analyses de\u00adscribed above. Our synthesizer takes as input the mutations, the results observed \nunder mutations and a template structure of the cells, and from them it generates a veri.ed model. The \ntemplate of the cell de.nes the cell components, and a superset of their inter\u00adconnections (inhibition, \nactivation), allowing biologists to formally state existing knowledge on the system being modeled. Addition\u00adally, \nthe granularity of the discretized concentration levels for each component is set a priori. What we synthesize \nis the internal logic and timing of the components, i.e., how their concentration changes in terms of \ntheir incoming signals, and we therefore off-load the most dif.cult task of systems biology modeling \nto a computation search engine. This paper makes the following contributions: 1. We designed SBL, a domain-speci.c \nlanguage for expressing our models using an execution model with restricted asyn\u00adchrony called bounded \nasynchrony [15]. We embed SBL into the Scala programming language [25] and build a lightweight synthesizer, \nwhich is publicly available [21]. We describe how to translate SBL programs into formulas in order to \nsolve syn\u00adthesis and speci.cation analysis problems (Sections 3 and 4). 2. We formulate the veri.cation \nproblem (Section 5.1) and the program synthesis problem (Section 5.2). We observe that un\u00adlike previous \nsynthesis tasks, e.g., concurrent synthesis [28] or synthesis from examples [17] or invariants [30], \nwhich are ex\u00adpressed as formulas with two levels of quanti.cation (2QBF),  this problem is expressed \nas a formula with three levels of quan\u00adti.cation (3QBF), which makes it a new kind of problem. We develop \nef.cient algorithms for solving this problem that re\u00adduce to three communicating SAT solvers. 3. We develop \nmethods for analyzing the speci.cations and the space of plausible models (Section 5.3): We describe \nalgorithms for determining whether internally or externally distinguishable models exist, and for .nding \nminimal non-ambiguous speci.ca\u00adtions. These algorithms build on our 3QBF synthesis procedure, and can \npotentially guide new wet-lab experiments by comput\u00ading mutation experiments that disambiguate alternative \nmodels. 4. We evaluate our framework by describing that it ef.ciently (1) generates valid models for \nthe C. elegans VPCs. The model .xes a bug in previous modeling, an incorrect modeling of a component \ns behavior when it is mutated; (2) shows that no be\u00adhaviorally distinct models exist (even after extending \nthe exper\u00adiment space to consider mutations for each component in the VPCs), but two internally different \nmodels were synthesized, one of which expresses a previously unknown biological hy\u00adpothesis; and (3) \nprunes the speci.cation from forty-eight mu\u00adtation experiments to a minimal set of four experiments (Sec\u00adtion \n6).  2. Technical Overview This section presents an overview of the program synthesis and speci.cation \nanalysis methods we have developed for modeling bi\u00adological systems. We describe how scientists typically \nconduct mu\u00adtation experiments to infer informal genetic regulatory networks, discuss how these models \ncan be formalized, present our program\u00adming language for expressing, verifying and synthesizing formal \nbiological models, and outline our synthesis and speci.cation anal\u00adysis algorithms for programs in this \nlanguage. 2.1 Background on Mutation Experiments. Here we give a brief background on mutation experiments, \nin the context of developmental systems biology. The role of these exper\u00adiments is to understand cellular \ngenetic regulatory networks, in par\u00adticular those that control stem cell differentiation. These regulatory \nnetworks are of interest in part because their failure may trigger disease: Cancer is fundamentally a \ndisease of failure of regulation of tissue growth. In order for a normal cell to transform into a cancer \ncell, the genes which regulate cell growth and differentiation must be altered. (Wikipedia) Hence, to \nunderstand cancer, one needs to understand cell differ\u00adentiation. There are two common mechanisms for \ncell differenti\u00adation: (1) a single cell divides into cells of different types based on the asymmetric \naccumulation of substances inside the cell; and (2) multiple identical cells differentiate by mutually \ncommunicat\u00ading with the goal of arriving at coordinated fates [13]. We focus on the second mechanism, \nand aim to mechanistically explain cell differentiation by modeling intercellular communication. The \nspeci.c goal of developmental biologists is to infer the program that stem cells execute to agree on \ntheir fates. This program executes within one cell division cycle during which a pluripotent cell decides \nits fate, potentially by communicating with other cells. One method for inferring this program is to \nmutate a set of genes in the cell and observe the resulting changes in the cell development. These experiments \nare particularly attractive because phenotype changes resulting from the cell taking a different fate \nare visually observable, avoiding the need for the more expensive tracing of temporal protein levels \nby the means of tagging cell proteins with .uorescent genes. From gene mutation experiments, biologists \ninfer protein inter\u00adactions, namely which proteins are activated or inhibited by the mutated protein. \nFor example, Yoo et al. [32] infers: In this assay, depletion of [genes] lst-2, lst-3, lst-4, or dpy\u00ad23, \nas well as ark-1, caused [a phenotype change, namely] ectopic vulval induction, suggesting that they \nfunction as negative regulators of the EGFR-MAPK [protein] pathway [due to the phenotype change being \nlinked to inhibition of the pathway]. Biologists unify such piecemeal information to create informal \nmodels of cellular programs, such as the one in Figure 1 from [12]. This model shows how .ve cells an \nanchor cell (AC), three vul\u00adval precursor cells (VPC), as well as the hyp7 cell communicate to determine \nthe fate of the VPCs. Each VPC contains the same set of components, which is composed of receptors (let-23 \nand lin12) and proteins (lst, sem-5, let-60 and mpk-1). The edges between these components show the activation \n(.) vs. inhibition (-) re\u00adlationships between them. Figure 1. An informal diagram of cell fate speci.cation \nin a sys\u00adtem of three VPC cells [12]. These cells react to the inductive signal (IS) from the anchor \ncell and communicate among themselves us\u00ading the lateral signal (LS) to decide one of three fates. While \nthese informal models may capture all known interac\u00adtions among cell components, they do not describe \nthe dynamics of the cell, such as what race conditions permit the cells to take non\u00addeterministic fates \nthat have been observed under some mutations. Due to this lack of dynamic information, one cannot be \ncertain that these diagrams accurately describe the cell fate speci.cation mech\u00adanism.  2.2 Executable \nBiology The goal of executable biology [14] is to create executable models that allow the observation \nof the dynamic behavior of biological systems. Furthermore, these models are veri.ed against experimen\u00adtal \nobservations. For concurrent discrete models, veri.cation, say, with model checking, ensures that all \nexecutions of the model agree with the observed outcomes. By verifying the program under the non-deterministic \ninterleaving of cell steps, we ensure that a pro\u00adgram is a faithful model of a cell system where cells \nmay progress at varying rates1 [15, 20]. 1 Another way to model varying cell rates is to use stochasticity. \nIn stochas\u00adtic models [2, 24], this non-determinism takes the form of protein mod- It is challenging \nto create veri.able, concurrent models of com\u00admunication between cells. To transform the informal model \nin Fig\u00adure 1 into an executable model, the designer must model (1) protein levels; (2) timing delay or \nrates at which proteins react with other components; and (3) how a protein behaves when both an activator \nand an inhibitor of the protein are active. We have previously de\u00adveloped a veri.ed model of C. elegans \nVPC cells; that model took several months to develop [12]. This paper develops methods for automatically \nsynthesizing executable models of concurrent cellu\u00adlar systems. Non-deterministic experiment outcomes. \nA mutation experi\u00adment may produce different outcomes when run repeatedly. A cor\u00adrect model must reproduce \nall non-deterministic outcomes of a given mutation experiment. We synthesize concurrent cell models that \nsatisfy this requirement by ensuring that each outcome that must be observed is reproduced by the model \nunder some inter\u00adleaving of cell steps. For biological reasons, we use a restricted model of concur\u00adrency, \nbounded asynchrony [15]. Because neighboring cells always advance at relatively similar rates, rather \nthan at arbitrary speeds, fully asynchronous models are too unconstrainted to reproduce the observation \nin certain mutation experiments. One-bounded asyn\u00adchrony is one way to achieve restricted asynchrony, \nensuring that between two execution steps of a cell, no other cell can take more than two steps. Because \nof the requirement to reproduce all possible outcomes, model synthesis in this setting is a more complex \nsynthesis task than what has been previously addressed. In this paper, we advance the state-of-the-art \nin solving this new synthesis problem. 2.3 Modeling Language We have developed a high-level programming \nmodel, SBL, in\u00adspired by biological diagrams such as the one in Figure 1. SBL in\u00adtroduces programming \nabstractions for cells, cell components, and interaction between components. Programs in SBL (Figure \n2) are composed of cells, which ex\u00adecute according to a schedule s that adheres to the 1-bounded\u00adasynchrony \nconstraint. The schedule is of bounded length; the num\u00adber of steps in the schedule corresponds to the \ndesired discretiza\u00adtion of the cell division cycle. Multiple cells can take simultaneous steps. Cells \nare composed of components, which model proteins or cell receptors. Components communicate with other \ncomponents in the same cell or in other cells; communicating components are connected with directed edges, \nwhich correspond either to activa\u00adtion or inhibition relationships. Components of a cell execute syn\u00adchronously; \nall take one step when the cell is scheduled. Compo\u00adnents have state a discretized concentration usually \nmodeled at 2-5 levels. When the component executes, it updates its next state based on its current state \nand the states of its activators or inhibitors. Each component is modeled with an update function (L, \nLk) . L, where L are levels and k is the number of components activators and inhibitors, combined. Thanks \nto these abstractions, SBL programs are syntactically smaller compared to models expressed in the Reactive \nModules language [1], which was the modeling language used in earlier work [12]. As a result, we are \nable to develop ef.cient synthesis algorithms for programs in SBL. EX A M PL E 1. To illustrate, we consider \nthe problem of designing a simple distributed protocol. Mutations in this setting correspond to els making \nprobabilistic transitions, accounting for variability of protein level change rates in nature. However, \nmoving non-determinism from pro\u00adtein modeling into the scheduler allows protein models to be deterministic, \nwhich in turn enables discrete veri.cation techniques.  Figure 2. Hierarchical organization of programs \nin SBL. The sys\u00adtem is composed of cells, which in turn are composed of compo\u00adnents. At each time step, \ncomponents update their discrete state us\u00ading an update function, in terms of their previous state and \nincom\u00ading signals from other components. Edges between components denote which components can communicate \nbetween them. Cells group together components that always move synchronously, and they adhere to a restricted \nform of concurrency. environment effects on the system being designed, and the speci.\u00adcation consists \nof input-output pairs de.ning the desired behavior for given environments. The goal is to design a weak \nconsensus protocol for a three\u00adnode system. (In a biological system, these nodes would be cells, and \nnode components would be proteins in the cells.) Two nodes (called sensors N1 and N2) are listening to \na signal from a mas\u00adter node (a base station BS). When the base station sends a signal, at least one \nof the sensors must make a decision to take a mea\u00adsurement. When a sensor takes a measurement, it sends \na release message to the other sensor permitting the other sensor not to take a measurement in order \nto save its power. The decision to make a measurement is made on the basis of (1) the strength from the \nbase station; in normal conditions, the sensor that received the stronger signal should take measurement \nas it is closer to the base station; and (2) receiving the release message from the other signal. The \nenvironment may cause the communication between the two sen\u00adsors to be down, sensors must take a measurement \nif no signal was received from their peer. Similar to a system of cells progressing at similar rates, \nwe assume that sensors have bounded skew, i.e., they run under bounded asynchronous schedules. An implementation \nof this protocol is presented in Figure 3. Figure 3(a) presents a hierarchical view of how cell communication \nis organized, and which components each cell contains. On the left is the top-most level with three nodes; \nthe base station node (BS) contains one component, the base node, which emits a constant high (H) or \nlow (L) signal to nodes N1 and N2. These nodes decide to commit or to delegate by communicating with \neach other. Figure 3(b), (c) and (d) show a graphical representation of update functions for three components \nin nodes N1 and N2 (the remaining simpler update functions have been omitted from the .gure).  2.4 Language \nExtensions for Veri.cation To make programs in our language amenable to veri.cation, we now introduce \ncomponent mutations, formalize speci.cations, and de.ne a correctness condition for programs. We model \ncell mutation with an adversary who perturbs the cell program such that a set of adversary-selected cell \ncomponents receive adversary-supplied semantics. Typically, a cell component is mutated either to be \nsuppressed or to stay at a high concentration level throughout the execution of the program, although \nwe also support other mutation types. The set of mutation experiments performed in the lab serve as \nour correctness speci.cation. Let F be the set of possible outcomes of a mutation experiment. For example, \nif a cell can take one of three fates, the outcomes of an experiment with six cells is a six\u00adtuple from \nF = {1, 2, 3}6. Let M be the set of possible mutations that one can apply on a cell; typically, all cells \ninvolved in an experiment are mutated identically. The set of experiments Exp is a subset of M \u00d7 F , \nwhere (m, f ) . Exp if the fate f has been observed on the mutation m. With n cell components and three \npossible mutations per component (e.g., no mutation; suppressed; high level), M is exponential in the \nnumber of components of the cell. As a result, biologists do not carry out all mutations. Having an incomplete \nset of experiments implies that we have to accommodate partial speci.cations. While the set of experiments \nExp is a subset of M \u00d7 F , we assume that once a mutation has been carried out, the lab has observed \nall possible outcomes for this mutation by repeating the experiment a suf.cient number of times. This \nis a reasonable assumption for systems that have been reliably studied by many independent labs, such \nas our case study, vulval fate speci.cation in C. elegans (Section 6). Without this assumption, we would \nhave no upper bound on the speci.cation, as any (m, f ) pair could potentially be observed in experiments \nthat have not been performed so far. The assumption allows us to synthesize with both positive examples \n(outcomes that must be produced by the model for an experiment) and negative ones (outcomes that must \nnever be observed for an experiment). To model such full knowledge for a single mutation, our speci.cation \nis a (partial) map E : M . 2F . The domain of E is the set of performed mutations. If m . dom(E) . f \n. E(m), we assume that mutation m cannot result in fate f; the pair (m, f ) is a negative example. We \nsay that a program P : M . F is a correct model of E if, for each m . dom(E), the execution P (m) may \nproduce each element of E(m) by controlling some aspect of the execution of P , namely the schedule that \ncontrols the concurrent execution of cells in the program. Correctness Condition. To de.ne a correctness \ncondition, we view an SBL program as a function P : (M, S) . F , where M and F are domains of mutations \n(input con.gurations) and fates, while S is the set of schedules adhering to bounded asynchrony. The \nexplicit schedule allows us to formulate a correctness condition correct(P, E) of a program P on a speci.cation \nE : M . 2F , which has two parts: 1. demonic scheduling: A demonic scheduler cannot make the model produce \na fate that is outside the speci.cation, i.e., demonic(P ) = .m . dom(E)..s . S : P (m, s) . E(m). 2. \nangelic scheduling: An angelic scheduler must be able to pro\u00adduce each fate in the speci.cation, i.e., \nangelic(P ) = .m . dom(E)..f . E(m)..s . S : P (m, s) = f. The demonic requirement asks that the model \nis an underapproxi\u00admation of the speci.cation, while the angelic requirement asks that it is an overapproximation. \nAngelic scheduling adds a layer of dif\u00ad.culty that is handled through the construction of a novel veri.er \n(Section 5.1). EX A M PL E 2. The speci.cation for Example 1, expressed as a set of experiments, is shown \nin Figure 4. The left column shows the mutations (environment effects) M, while the right column shows \nthe desired outcomes F . It is interesting to note that we are using the mutations as the environment \nadversary; the mutations describe situations under which the nodes N1 and N2 must operate accord\u00ading \nto the expected outcomes. For example, the last row describes the situation in which the signal arriving \nat N1 is high, while the  (b) Base receiver (c) Lateral receiver   (d) Delay Figure 3. (a) Hierarchical \nview of node connections, and of their components. The top node is the base station, and the bottom nodes \nare distributed sensors which may not communicate with each other due to environment effects. (b), (c), \n(d) Graphical representation of update functions for base receiver, lateral receiver and delay components \nin the distributed sensors. Each state is labeled with its name and the output value that the state maps \nto. Base station trigger Inter-node comm. N1 N2 N1=H, N2=H Y C D D C C C N1=L, N2=L Y C D D C C C N1=H, \nN2=L Y C D N1=L, N2=H Y D C N1=H, N2=H N C C N1=L, N2=L N C C N1=H, N2=L N C C N1=L, N2=H N C C Figure \n4. The speci.cation for the distributed protocol example, giving required outcomes for nodes N1 and N2 \nunder a range of scenarios of base station trigger signals and cases of whether the two nodes can communicate \nbetween themselves (Y) or not (N). C = Commit, D = Delegate. signal arriving at N2 is low, and the communication \nbetween nodes is down. We can think of this mutation as the adversary lowering the signal to N2 and preventing \nthe communication between the two sensor nodes. The outcome C means that a node has committed to taking \na measurement while D means that the measurement was delegated to the peer node.  2.5 Language Extensions \nfor Synthesis In order to allow synthesis of update functions in our programs, we extend our language \nsuch that these can be left unspeci.ed. We describe partial programs in SBL and we de.ne the synthesis \nproblem. The input to the synthesizer is the speci.cation E and a partial program P ? to be completed \nby the synthesizer, if feasible, into a program P h such that the predicate correct(P h, E) holds. A \npartial program is a program template in which certain fragments are parameterized and need to be supplied \nby the synthesizer. Our language allows parameterization of (1) cell component behavior; and (2) how \ncomponents communicate. Because update functions model timing delay and change rates of proteins, we \nfound them to be the hardest part of the model to produce manually. By pa\u00adrameterizing update functions, \nwe can indirectly leave unspeci.ed also the connections between components: for example, if a biolo\u00adgist \nis unsure whether a protein P is inhibited by a protein Q or a protein R, both Q and R can be connected \nto P; if Q turns out not to in.uence P, the synthesizer is able to produce an update func\u00adtion for P \nthat disregards the state of Q. The parameterized update functions are constrained to agree with the \nactivation and inhibition semantics speci.ed in the partial program by restricting their struc\u00adture. \nThis is achieved by stating monotonicity invariants on how a protein s input concentrations can in.uence \nits concentration; these invariants are described in Section 4.2. From the user standpoint, the partial \nprogram P ? encodes bio\u00adlogical assumptions; it de.nes the components in the cells as well as a superset \nof connections between them. It thus (1) conveys the desire to model particular proteins and (2) states \nthe knowledge of which (superset of) pairs of proteins communicate. Partial pro\u00adgrams encoding biological \nassumptions form the basis for the am\u00adbiguity analysis described in Section 2.6. Our synthesis problem \nis to .nd update functions h that yield a correct model: DE FIN I T I ON 2.1 (Synthesis problem). For \na partial program P ? to be completed with hole values h into P h, the synthesis problem is to .nd the \nupdate functions h that yield a correct model: S(h) := .h : demonic(P h) . angelic(P h) A correct model \nmust reproduce all observed experiments, and this is captured in the angelic(P ) correctness condition, \nwhich is a formula with two levels of quanti.cation (2QBF). This makes the synthesis problem a 3QBF problem, \nwhile typical synthesis problems are 2QBF (of the form . hole . input : f). Formulas with more than one \nlevel of quanti.cation cannot be handed off directly to an SMT solver, because the perfor\u00admance of SMT \nsolvers is only reliable for existential (one quan\u00adti.er) formulas. One way to tackle 2QBF problems is \nto develop a counterexample-guided inductive synthesis (CEGIS) algorithm. In the classical CEGIS algorithm, \nan inductive synthesizer produces a program that is correct on a small sample of inputs; a veri.er then \nchecks this candidate program on remaining inputs [29]. To handle the 3QBF synthesis problem S(h), we \ndevelop a novel two-part CEGIS algorithm, where an inductive synthesizer communicates with two veri.ers, \none for each of the two correctness conditions, and collects two kinds of counterexamples, one from each \nveri.er (Section 5.2). EX A M P L E 3. The update functions for Example 1, presented in Figures 3(b), \n(c) and (d) are produced by our synthesizer. These update functions control how these components react \nto signals from the base station and the peer sensor. The synthesizer takes four seconds to generate \nthese update functions. Intuitively, a sensor s protocol is simple: if you receive a weak signal, wait \na little while and wait for the release signal from the other sensor. If it does not arrive, take a measurement. \nStill, even for this simple protocol, designing the update functions manually is not trivial.  2.6 Ambiguity \nAnalysis Assume that a biologist produces an executable model that veri.es against all performed experiments. \nNow imagine that after he pub\u00adlishes his conclusions from this model, another biologist performs a new \nmutation experiment whose outcome invalidates the model as well as the conclusions drawn from it. (Given \na new mutation ex\u00adperiment mn+1, a model P becomes invalid if it cannot reproduce an outcome observed \nfor mn+1, or if it produces an outcome that has never been observed after performing mn+1 suf.ciently \nmany times.) Naturally, we are interested in the question of whether one can ascertain the validity of \na model in the absence of complete experiments. In particular, under what assumptions can a model be \nconsidered the sole explanation of biological phenomena? We view this question as analysis of ambiguity \nin the speci.\u00adcation E, and de.ne an alternative model query that answers the question. We .rst introduce \naggregate outcomes and speci.cation ambiguity. DE FI NI TI O N 2.2 (Aggregate outcome). Let P be a model \nand m a mutation. The aggregate outcome of P on m, denoted P [m], is the set of outcomes produced by \nP mutated with m over the set S of all schedules: P [m] := {P (m, s) | .s . S} A speci.cation E is ambiguous \nfor a partial program P ? (that ex\u00adpresses a set of biological assumptions) if we can .nd two com\u00adpletions \nP h1 and P h2 that disagree on some new experiment. Of course, one of these models would become invalid \ngiven the new experiment. DE FI NI TI O N 2.3 (Speci.cation ambiguity). Given a partial pro\u00adgram P ?, \na speci.cation E is ambiguous, denoted Amb(E, P ?), if .m . M .h1, h2. correct(P h1 , E) . correct(P \nh2 , E ) . P h1 [m] = P h2 [m]. Note that m must be a new experiment, i.e., m . M \\ dom(E), because the \ntwo models must agree with the speci.cation E on all mutations in dom(E). In Section 6, we show that \nthe speci.cation for our case study is unambiguous given provided biological assumptions (i.e., , there \nis no need for more experiments at the desired level of modeling). We also show that removing some historically \nimportant experiments indeed makes the speci.cation ambiguous, permitting alternative explanations for \ncoordination between cells. DE FIN I T I ON 2.4 (Alternative model query). Given a partial pro\u00adgram \nP ? stating biological assumptions and an existing (perhaps previously synthesized) model P (that need \nnot be an instantiation of P ?), the alternative model query .nds a mutation m and a new model P h such \nthat P [m] = P h[m], or shows that no such h and m exist. We develop an algorithm to solve this query \nin Section 5.3.1. EX A M PL E 4. We now ask whether we can .nd alternative mod\u00adels for Example 1 using \nthe alternative model query. Suppose we relaxed the speci.cation and do not care about the outcome on \nthe case N1 = L, N2 = L. We ask our synthesizer to generate models under this relaxed speci.cation such \nthat they differ from the model in Example 1. Our synthesizer generates an alternative model that has \nmuch simpler behavior (as it need not be non-deterministic un\u00adder the row that we ignored). The update \nfunctions are shown in Figure 5. When we ask for a mutation that distinguishes among the models, the \nsynthesizer produces the omitted row. (Note that this last query is a special case of the alternative \nmodel query, such that both input programs are fully speci.ed.) Now consider an experimental scenario \nwhere one wants to val\u00adidate a set of experiments performed in the literature by performing them again. \nIs it possible to identify the smallest set of experiments whose replication is suf.cient to yield a \nnon-ambiguous speci.ca\u00adtion? To answer this question, we de.ne a minimization query that computes such \na minimal set. DE FIN I T I ON 2.5 (Minimization query). Given a non-ambiguous speci.cation E, the minimization \nquery computes a minimal non\u00adambiguous speci.cation Em from E, i.e., \u00acAmb(Em, P ?) . \u00ac.E', E ' . Em . \n\u00acAmb(E', P ?). An algorithm that solves the minimization query is presented in Section 5.3.2. In our \ncase study, we show that, under our assumptions P ?, one needs to replicate about 10% of experiments. \nThis result suggests that computing which experiments to perform might reduce unnec\u00adessary laboratory \nwork. EX A M PL E 5. We explored the minimization query for Example 1. Our synthesizer prunes E down \nto the .rst three rows of Figure 4 as a minimally unambiguous speci.cation. This is somewhat sur\u00adprising \nbut it gives substantial insight into the problem, as the user can now understand that the speci.cation \nof the four cases with lost communication was redundant, while the user may have presumed that it was \nnecessary. 3. Language In this section, we present the formal semantics of our language, by .rst de.ning \nthe language constructs, and then giving operational semantics rules for execution. The basic construct \nin SBL is a component. We denote the set of all components in a program by Comp. Components are con\u00adnected \nvia a set of directed edges, de.ned by the relation Edges . Comp \u00d7 Comp. Edges model channels of communication \nbetween ' cell components. For each component c, we say a component c ' is an input component of c \nif there is an edge (c, c) . Edges. For each c, we de.ne the set of input components Inputas {c' : c \n (c', c) . Edges}. A component c has a state sc that takes val\u00adues from a .nite domain Lc. Each component \nc is also associ\u00adated with an update function, denoted fc, that updates its state sc, given the current \nvalue of its input components. The func\u00adtion fc has domain Lc \u00d7 .c1.Inputc Lc1 and range Lc. The update \n s,Cells,Edges Cells,Edges S = s :: ss s\u00af init --------. s\u00af ' (s\u00af ' , ss) -------. (s\u00af final, [ ]) RUN-PROGRAM \n Cells,Edges (s\u00af init, S) -------. (s\u00af final, [ ]) RUN-PROGRAM-BASE Cells,Edges (s, \u00af [])-.(\u00af ------s, \n[ ]) s,cell,Edges,s(cell) '' ' .cell . Cells s\u00afcell \u00af - ----------. s\u00afcell s\u00af = .cell.Cells{s\u00afcell} \nADVANCE-CELLS s,Cells,Edges s\u00af --------. s\u00af '' c,\u00af s,Edges '' ' .sc . \u00af- ----c s\u00af= .c.cell{sc} s sc \n. s CELL-ENABLED CELL-DISABLED s,\u00af cell,Edges,1 \u00af s,cell,Edges,0 s\u00af--------. s\u00af' s\u00af--------. s\u00afS = {sc1 \n: (c ' , c) . Edges} fc(S, s) = s ' ADVANCE-COMPONENT c, \u00af s,Edges s - ----. s ' Figure 6. Small-step \nsemantics for program execution. RUN-PROGRAM runs a schedule by advancing the cells according to each \nmicro-step in the schedule, with RUN-PROGRAM-BASE as the base case. ADVANCE-CELLS rule updates the states \nof cells, depending on the current micro-step s. If a cell is enabled, it is advanced by applying the \nCELL-ENABLED rule. Conversely, if a cell is disabled, the CELL-DISABLED rule keeps its state unchanged. \nADVANCE-NODE rule updates the state of a component by invoking the update function on the states of all \ninput component states and its own state (a) Base receiver (b) Lateral receiver   (c) Delay Figure \n5. Update functions generated using the alternative query model to differentiate from the model in Example \n1 under ambigu\u00adous speci.cation, obtained by removing row 2 of Figure 4. function for a component is \nchosen from a sequence of functions Fc := [fc,1, . . . , fc,k] that describe possible alternative behaviors \nof that component under different mutations, i.e., the natural and altered behaviors of the component. \nA cell is a set of components. Within a cell, we have a syn\u00adchronous execution model, i.e. all components \nof a cell update their state simultaneously. The state of a cell s\u00afis de.ned as the set of states of \nthe components that the cell contains. We denote the set of all cells in a program by Cells. Cells forms \na partition on all the components in the program. A pair of cells (cell1, cell2) are said to be communicating \nif there exists a pair of components (comp1, comp2) connected by an edge in the respective cells. The \npair (Cells, Edges) constitutes a program. The program state s\u00af is the set of all cell states in the \nprogram. The input to a program is a con.guration (i.e., a mutation). A con.guration is a function from \ncomponents to integers, that expresses for each component c the index of the function in Fc that should \nbe used as the update function fc. The output of a program is de.ned as the state of user-designated \ncomponents in the .nal state reached in an execution. Partial Programs. The sequence Fc of functions \nassociated with component c need not be speci.ed concretely. When at least one component function is \nnot concretely speci.ed, we say the program is partial. Typically, users will only concretely specify \nthe behav\u00adiors under well-understood mutations that would not make sense to rede.ne. For example, a typical \nexample in the biological case is the knock-out mutation which subdues the function of the compo\u00adnent \nand .xes it to the OFF state. Operational semantics Figure 6 shows the small-step semantic rules for \nprogram execution. Here, we assume that the program starts in the initial state s\u00af init, and that it \nhas already been pre\u00adprocessed by .xing a particular update function for each compo\u00adnent according to \nthe input con.guration. The semantics are de\u00ad.ned recursing down the program structure. The RUN-PROGRAM \nrule executes the program by moving all cells in accordance with a schedule S. The ADVANCE-CELLS rule \ncaptures the intuition that each schedule step s partitions the cells into the sets enabled (for which \ns(cell) = 1) and disabled (for which s(cell) = 0). Rules CELL-ENABLED and CELL-DISABLED describe how \ncell states are updated for enabled and disabled cells, respectively. For the disabled cells, the state \nremains unchanged. Enabled cells are advanced by applying the ADVANCE-COMPONENT rule for each component, \nwhich corresponds to updating the component state by reading the state of connected neighbors and using \nthe component s update function. Bounded Asynchrony. The concurrency notion that our execu\u00adtion model \nadmits is bounded asynchrony. This model faithfully represents biological systems where complete synchrony \nis too strict, and complete asynchrony does not accurately model cells that progress at similar but not \nidentical rates. Fisher et al. [15] de.ne bounded asynchrony with schedules consisting of micro-and \nmacro-steps. Each micro-step consists of a subset of the components stepping synchronously. This is what \nwe have been calling a schedule up to this point. Next we block micro-steps together into a macro-step. \nEach k-bounded macro\u00adstep consists of all components taking k steps split across multi\u00adple micro-steps. \nFor example, let us consider three nodes and the schedule 110 (micro-step) indicates the .rst two take \na step while the third waits. Suppose the second schedule is the micro-step 001. Then the two micro-steps \ntogether make a macro-step in which all nodes take one step and which is therefore 1-bounded. Schedules \nover micro-steps are much more expensive to enu\u00admerate than schedules over macro-steps, especially 1-bounded \nmacro-steps. Schedules over 1-bounded macro-steps (where each node necessarily moves once), can be succinctly \nencoded without loss of information as pairwise happens-before between connected nodes. That is, a 1-bounded \nmacro-schedule is an assignment of <, >, or = to each edge in the node topology2. The following lemma \nholds: LEMM A 1 (Fisher et al. [15]). A micro-schedule exists if and only if a realizable macro-schedule \nexists over the node topology. Here a realizable macro-schedule is one that does not cause an in\u00adconsistent \nordering of nodes in a cycle. We use this result critically to ef.ciently encode partial programs as \nformulas (Section 4), and restrict schedules to be 1-bounded. Using macro-steps allows us to de.ne a \ncompact symbolic en\u00adcoding of our programs into formulas, which would have not been possible with micro-steps. \n4. Translating Programs into Formulas We now describe how to translate execution of SBL programs to SMT \nformulas, enabling veri.cation and synthesis. We .rst give rewrite rules that construct a formula corresponding \nto the symbolic execution of a program. We then describe additional constraints that encode biological \ndomain knowledge to be used in synthesis of programs. 4.1 Translation of Program Execution The translation \nof program execution is parameterized by the fol\u00adlowing symbolic variables: For each time step t and \neach pair of connected cells (c1, c2), we de.ne a channel con.guration variable channelt,c1,c2 that must \nhold exactly one of the three values < , > and = . These variables encode the symbolic schedule for program \nex\u00adecution. Variables channelt,c1,c2 and channelt,c2,c1 are as\u00adserted to be consistent in the following \nway: channelt,c1,c2 = > . channelt,c2,c1 = < . channelt,c1,c2 = < . channelt,c2,c1 = > . channelt,c1,c2 \n= = . channelt,c2,c1 = = For each component c, we represent each function fi . Fc as a lookup table \nwith symbolic values for each value in its domain Lc \u00d7.c1.I nputc Lc1 . Entries of the lookup table are \nrepresented by the variables tablevc,vc1 ,...,vcn that take values in Lc.  For each component c, we \nrepresent its mutation symbolically as a variable mc, that encodes the index of the function to use \n 2 Technically, for micro-steps it is the sequence of ordered bell numbers or Fubini numbers [16], while \nfor 1-bounded macro-steps it is 3num edges . among Fc. If mc has value i, then the function fc,i will \nbe used as the update function of component c. For each component c at each execution step, we create \na variable st,c that takes values in the domain of Lc. These variables represent the component state \nsymbolically over the execution of the program. Translation rules for compiling program execution to \nan SMT formula are shown in Figure 7. TRUN is the top-level rule for translating the execution of a pro\u00adgram, \nunrolling the execution for k steps. TRE AD uses the symbolic macro-schedule values to assert the input \nstates that should be read by each component at a given macro-step. If a cell cell runs before or at \nthe same time as another cell cell ' (i.e. the macro-step vari\u00adable between the two cells at a time step \nhas value < , or = ), the components in cell reads their input states from cell ' at the previ\u00adous time \nstep. On the other hand, if cell runs after cell ', it reads its input states from the current time step. \nFinally, TUPDATE asserts that the state of a component is updated in terms of its symbolic mu\u00adtation, \ninput state, own state, and update function. The outermost conjunction enumerates over possible update \nfunctions. For each mutation, the inner conjunction enumerates possible input value tuples of the update \nfunction. The symbolic state is updated given symbolic lookup variables for the chosen mutation. This \ntranslation does not impose any constraints on the param\u00adeterized update functions, and therefore encodes \na very large space of possible update functions. To help with the program synthesis task, we need to \nrestrict this space. This is achieved in Section 4.2 by asserting biologically motivated constraints \non the structure of the parameterized update functions. 4.2 Domain-Speci.c Constraints on Update Functions \nThe translation in Section 4.1 does not impose restrictions on the structure of the update functions \nthat are left unspeci.ed by the user. When modeling biological systems, formulating a hypothesis typically \ninvolves stating high-level invariants about whether a component activates or inhibits another one. In \nthis section, we describe how the space of update functions is restricted using this high-level knowledge. \nWe .rst formalize how the high-level biological invariants are stated by de.ning a partial labeling of \nedges with activation and inhibition semantics. DE FIN I T I ON 4.1 (Edge labeling). Given a partial \nprogram P ? , the partial function label : Edges . {activating, inhibiting}annotates edges in P ? as \neither activating or inhibiting. As a component s state expresses its activation level, we assume the \nexistence of a total order on its possible states. This will allow us to state the properties that restrict \nthe space of update functions. DE FIN I T I ON 4.2 (State ordering). Let c be a component, and Lc the \nset of possible state values for c. The state ordering =c is a total order on Lc. Using the edge labeling \nand the state ordering for each component, we now de.ne a partial order on the combined input values \nfor a component. DE FIN I T I ON 4.3 (Input ordering). Given a component c with up\u00addate function fc : \nLc \u00d7 Lc1 \u00d7 . . . \u00d7 Lcn . Lc, the partial order .c on elements of Lc1 \u00d7 . . . \u00d7 Lcn is de.ned as: (v1, \n. . . , vn) .c (u1, . . . , un) := .i . {1, . . . , n}. (label((ci, c)) = activating . vi =ci ui) . (label((ci, \nc)) = inhibiting . vi =ci ui)   TRUN [Cells, Edges] :=TRE A D [t, c, Edges] . TUPDATE [t, c, Edges] \ncell.Cellsc.cell t.{1,...,k} .. ((channel= < ).(s=s1 )) t,cell1,cell read,t,c,c1 t-1,c . ((channel= \n= ).(s=s1 )) t,cell1,cell read,t,c,c1 t-1,c .... .... TREA D [t, c, Edges] := . ((channel= > ).(s=s \nt,cell1,cell read,t,c,c1 t,c1 )) (c 1 ,c).Edges c 1.cell1 c.cell . . (st-1,c,sread,t,c1,c,...,sread,t,cn,c)=(vc,vc1 \n,...,vcn ) .. TUP DATE[t, c, Edges] :=mc = i . . fi.Fc (vc,vc1 ,...,vcn ).dom(fi) st,c =tablevc,vc1 \n,...,vcn Figure 7. Translation rules for symbolic execution of programs. Intuitively, is a partial order \non the strength of the input values to a component, based on the activation and inhibition annotations. \nWe now describe two kinds of invariants that restrict the space of possible update functions. Input monotonicity \nOur .rst property is motivated by the follow\u00ading observation: If there is an activating edge from component \nc1 to component c2, then an increase in sc1 should not have by it\u00adself the effect of decreasing sc2 . \nConversely, if c1 and c2 are con\u00adnected through an inhibiting edge, then a decrease in the value of sc1 \nshould not result by itself in the decrease of sc2 : .i1, i2 . Lc1 \u00d7 . . . \u00d7 Lcn . .v . Lc. i1 c i2 . \nfc(v, i1) =c fc(v, i2) State monotonicity The second property that we assert imposes a monotonicity constraint \non fc in terms of the value of sc. This property expresses that, for the same input value, a greater \nthe activation level of the component cannot be updated to a smaller value: .i . Lc1 \u00d7 . . . \u00d7 Lcn . \n.v1, v2 . Lc. v1 =c v2 . fc(v1, i) =c fc(v2, i) We found that asserting constraints that encode these \ntwo invari\u00adants based on user annotations on component connections is crucial The properties demonic(P \n) and angelic(P ) are in 1QBF and 2QBF respectively. As a result, the correctness condition correct(P \n) is in 2QBF. We verify correctness conditions demonic(P ) and angelic(P ) separately, using a veri.er \nVd that searches for demonic schedules that lead to the violation of the speci.cation, and a veri.er \nVa that checks whether all non-deterministic outcomes for a given mutation can be reached for some angelic \nschedule. Verifying for demonic schedules. The formula demonic(P ) states that the set E(m) is an upper \nbound for all observed out\u00adcomes of P with input m: demonic(P ) := .m . dom(E). .s . S. P (m, s) . E(m) \n To check this property, we attempt to disprove it by searching for a demonic schedule that produces \nan unobserved outcome for an input in dom(E), the domain of E. Given the observation that there is a \nsmall set of input values in dom(E), we solve this formula by unrolling the existential quanti.cation \nover this set, and by querying symbolically for a demonic schedule. The condition P (m, s) . E(m) is \nexpressed by unrolling over values in E(m), which is also a small set. We thus solve the 1QBF formula: \n .s.P (m, s) = f for ensuring that the structure of update functions agree with exist- m.dom(E) f.E(m) \ning biological knowledge. If this formula is satis.able, P does not satisfy demonic, and 5. Synthesis \nand Querying Spaces of Models In section 4, we described how we translate program execution to formulas. \nIn this section, we present algorithms that leverage this translation for veri.cation and synthesis, \nas well as speci.cation ambiguity analysis. The formula that encodes program execution parameterizes \n(1) update functions (which are the holes in partial programs); (2) schedules; and (3) input con.gurations \n(i.e., mutations). The space for update functions and the space for schedules are typically very large. \nHowever, speci.cations are typically wet-lab experi\u00adments which are sparse and inherently small (of order \n102 exper\u00adiments). Based on this observation, we develop algorithms that unroll quanti.cations for input \ncon.gurations only.  In the following, we refer to the symbolic output parameter of translating the \nexecution of P with input m and schedule s as P (m, s), and we denote by E the speci.cation (given as \na partial function from M to 2F ). 5.1 Verifying Programs The correctness condition presented in Section \n2.4 is de.ned as: correct(P ) := demonic(P ) . angelic(P ) we obtain a concrete counterexample (m, s) \nsuch that running P on input m and schedule s leads to an unobserved fate. If it is unsatis.able, then \nP is correct with respect to demonic. Verifying for angelic schedules. The angelic condition states that \nall outcomes in the set that m maps to must be observable, i.e. appear in some execution of P on m: angelic(P \n) := .m . dom(E), f . E(m). .s. P (m, s) = f This amounts to searching for an angelic schedule for each \nf . E(m). We reduce the 2QBF correctness property to an ef.\u00adciently solvable 1QBF problem by unrolling \nvalues of the domain dom(E), again based on the assumption that this is a small do\u00admain. To unroll angelic(P \n), we construct the following query for each m . dom(E) and for each f . E(m): .s. P (m, s) = f If the \nabove formula is unsatis.able for some m and f, then no angelic schedule can be found for reaching that \noutcome when run\u00adning P , and (m, f ) is a counterexample input/output pair witness\u00ading that angelic(P \n) does not hold. If the formula is satis.able for each m . dom(E) and for each f . E(m), then veri.cation \nfor angelic schedules succeeds.  Figure 8. The synthesizer consists of three communicating solvers. \nThe two veri.ers generate two kinds of counterexamples, and the synthesizer generates models that satisfy \nthe constraints for all counterexamples. A program veri.es against the speci.cation E if it veri.es against \nboth Vd and Va.  5.2 Synthesizing Programs In our language, it is possible to de.ne a partial program \nP ? that admits freedom in the update functions of its components. We now present a synthesis algorithm \nfor .nding update functions in P ? such that the completed program P h is correct with respect to the \ncorrectness condition correct(P ). Our procedure leverages the two veri.ers Vd and Va to check correctness \nproperties demonic and angelic respectively, in order to solve the following synthesis problem: S(h) \n:= .h. demonic(P h) . angelic(P h) This formula is in 3QBF, due to the quanti.er alternation ... resulting \nfrom angelic(P h) being nested within the quanti.cation over h. We solve S(h) by developing a counterexample-guided \ninduc\u00adtive synthesis (CEGIS) algorithm, which decomposes the 3QBF problem into two 1QBF solvers (an inductive \nsynthesizer and the demonic veri.er Vd) and one 2QBF solver (the angelic veri.er Va). The inductive synthesizer \nproduces a candidate model that is cor\u00adrect on all counterexamples and sends this model to both veri.ers. \nIf both approve the model, the synthesis successfully terminates. If either fails, counterexamples are \nproduced, re.ning the correctness constraints placed on the inductive synthesizer, making it eventu\u00adally \nproduce a correct model (or conclude that no model exists in the model space described by P ?). The solver \narchitecture is shown in Figure 8. Precisely, the synthesizer maintains two sets of counterexam\u00adples, \nCE1 . dom(E) \u00d7 S and CE2 . dom(E) \u00d7 F . The .rst set contains pairs of inputs and schedules, and is computed \nwith coun\u00adterexamples given by the veri.er for demonic schedules. The sec\u00adond one is a subset of the \ninput/output speci.cations, and is in turn computed with counterexamples found by the veri.er for angelic \nschedules. Starting with initial sets CE1 and CE2, the synthesizer solves at each step the following \nformula to .nd a candidate model: . . .h. . P h(m, s) . E(m). (m,s).CE1 . . . . .s. P h(m, s) = f. (m,f).CE2 \n If the above formula is unsatis.able, the partial program cannot be completed, i.e. synthesis fails. \nOtherwise, the valuation of h de.nes a candidate model that we attempt to verify using veri.ers Vd and \nVa. If at least one of the veri.ers returns with a counterexample, the synthesizer attempts to .nd a \nnew candidate after updating the sets CE1 and CE2 with the counterexamples returned by either veri.er. \nIf a candidate model is validated by both veri.ers, we obtain the completed program P h that is correct \nwith respect to the speci.cation E. 5.3 Querying for Ambiguity Analysis Given the above procedure for \nsynthesizing programs, we are now interested in querying spaces of possible models. In particular, we \nanalyze ambiguity of speci.cations. If a speci.cation is underspec\u00adi.ed, we aim to reduce ambiguity by \nexpanding it. If, on the other hand, it is overspeci.ed, our goal is to reduce the speci.cation size \nwithout introducing ambiguity. Computing Aggregate Outcome We .rst give an iterative algo\u00adrithm to .nd \naggregate outcome set for a given program p and a given input m. The aggregate outcome set P [m] is the \nset of out\u00adcomes of P on m over all schedules. We approach the task by .rst computing the outcome of \nP on m under an initial schedule s. We then enlarge the set of observed outcomes Obs by searching for \na schedule leading the program to produce a previously unseen out\u00adcome. To .nd such an outcome, we build \na formula that states that the new outcome must differ from each value in the Obs set in\u00adferred so far. \nEach step of the algorithm thus attempts to extend Obs by solving the following formula: .s. P (m, s) \n= f f.Obs If this formula is satis.able, we obtain an outcome that we add to the set Obs, and then attempt \nto solve the formula with the updated set. If it is unsatis.able, we have obtained all outcomes that \ncan be produced by P on input m. 5.3.1 Alternative Models To ascertain that a given hypothesis is the \nsole explanation to a biological phenomenon, a biologist would like to learn whether there exists another \nhypothesis that differs from the .rst on its observable outcome on an unperformed experiment, but is \ncorrect on the known experiments. Given a program P1 that expresses the .rst hypothesis, and a partial \nprogram P2 ? that expresses a space of alternatives for the second, we can state this query formally \nas: .m..h.correct(P2 h) . P2 h[m] = P1[m] If this query is satis.able, then there is an alternative \nprogram P2 h and a new experiment m such that performing the experiment m will invalidate at least one \nof P1 and P2 h. We now describe an algorithm to solve this query. Given the hypothesis that the space \nof mutation experiments M is small, we approach this task by unrolling the existential quanti.cation \nover m. The problem then reduces to synthesizing P2 h for a given mutation m, such that P2 h[m] = P1[m]. \nP2 h[m] can differ from P1[m] in two distinct ways: (1) It can either contain an output value not in \nP1[m]; or (2) it can be a strict subset of P1[m]. We give one algorithm for each case. Case 1. A program \nP2 h that produces an outcome not seen in P1[m] can be found by augmenting the synthesis query described \nin Section 5.2 with a constraint asserting that there exists a schedule that leads P2 h to produce an \noutcome not in P1[m], i.e., P2 h[m] \\ P1[m] = \u00d8. We solve the following formula to answer this query: \n.h. correct(P2 h) . .s.P2 h(m, s) . P [m]  This formula is satis.able if and only if there exists a \ncompletion of program P2 h that produces an outcome not in P [m]. It is 3QBF, and is handled using the \nmechanism of a synthesizer communicat\u00ading with two veri.ers to perform inductive synthesis described \nin Section 5.2. Case 2. Alternatively, P2 h may be found by attempting to syn\u00adthesize a model that always \nproduces outcomes in a strict subset of P1[m]. This is achieved by discarding elements of P1[m] one at \na time, to see if such a model can be found. We do not need consider all subsets of P1[m], as we only \nstate that P1[m] \\ {f} is only an upper bound of the possible outcomes for input m. .h. correct(P2 h) \n. .s. P 2 h(i, s) . P1[m] \\ {f} f.P1[m] This formula is satis.able if and only if there exists a completion \nof program P2 h such that its observable outcome set is a strict subset of observable outcomes of P1 \non input m. Similarly to Case 1, we use the scheme of cooperating solvers described in Section 5.2 to \nsolve this formula.  5.3.2 Minimization In a context where performing experiments is an expensive process, \na researcher may want to obtain a minimal non-ambiguous speci\u00ad.cation that suf.ciently constrains the \nspace of models to validate a hypothesis. Given a partial program P ? that expresses a hypoth\u00adesis, and \na speci.cation E that is non-ambiguous with respect to P ?, the task of .nding a minimal non-ambiguous \nspeci.cation Em is stated as: ? '' ' ? \u00acAmb(Em, P ) . \u00ac.E , E . Em . \u00acAmb(E , P ) We compute a minimal \nspeci.cation Em by iteratively restricting the domain of E for the partial program P ?. This can be done \nby invoking the alternative model query once for each mutation in dom(E). At each step, we check whether \nprogram P ? can be completed to a program P h that decides a set of outputs P h[m] distinct from E(m), \nconsidering as speci.cation the set of currently non\u00adredundant input values. This check is performed \nusing the alterna\u00adtive model query described in Section 5.3.1. If synthesis fails, m is marked as redundant. \nOtherwise, removing m from the speci.\u00adcation leads to ambiguity, and as a result m should be kept in \nthe .nal set of pruned inputs. Upon considering all inputs in the do\u00admain of E, a minimal speci.cation \nis obtained by removing from the domain of E those inputs that are marked as redundant. 6. Case Study: \nC. elegans vulval development We attempt to synthesize a model for the vulval precursor cells (VPCs) \nthat start off identical but through coordination among themselves and with the Anchor Cell (AC) agree \non speci.c fates. From informal descriptions of protein interactions found in bio\u00adlogical literature, \nwe develop our template VP C ?. The template is shown in Figure 9(a) (derived from Figure 1.) From the \ntemplate, we observed that there are nodes with ex\u00adtremely simplistic on-off behavior. These are LS, \nthe downstream nodes of the cascade (sem5, let60, and mpk1) and the fate nodes. While we can introduce \nholes in them (with expected performance degradation, yet not being intractable), biologists have a very \nclear understanding of these nodes, and so expect to see a simple and known behavior in them. Additionally, \nintroducing holes in these nodes leaves too much freedom to the synthesizer, such that gener\u00adated models \ndo not have a biological interpretation. Therefore we run our tool with unknown update functions for \nlin12, let23, and lst. The generated update functions satisfy the speci.cation and template structure \nof the program. On the other hand, lin12, which has a very well understood behavior, colludes with the \nother components to give models that are hard to explain to the biologists. Therefore, we additionally \nallow the user to spec\u00adify the behavior of lin12 concretely and synthesize let23 and lst. Let23 and lst \nare indeed the most complex functions in their timing delays (and have the most complex interconnection \ndependences). Indeed, in our attempts prior to synthesis (when designing the ver\u00adi.er) to write the model \nby hand, we actually failed. Additionally, the models previously written did not maintain the requisite \nlin12 behavior. Therefore, our synthesizer was solving a problem that had been impossible to solve manually, \neven after considerable effort. The speci.cation consists of forty-eight experimental observa\u00adtions \nof the fate outcomes of six VPC cells in sequence. Some of these observation have non-deterministic outcome \nfates. A frag\u00adment of the speci.cation is shown in Figure 9(b). From the template and these experiments, \nour synthesizer gen\u00aderated update function solutions to let23 and lst that were con.rmed by the biologists \nto be plausible behaviors. The output from the synthesizer is shown in Figure 10(a). It is important \nto note that this is a very signi.cant achieve\u00adment. Previously, when we had written down a model for \nVPCs in RM [12] it had the following .aws: (1) The previous model did not satisfy a biological invariant \nrequired on the lin12 component, and all efforts to .x the model failed, (2) RM is too expressive and \ntherefore there were cases where the model read the future which was hard to interpret biologically, \n(3) the model lacked readabil\u00adity prohibiting debugging, extension, and biological interpretation. Our \nsynthesized alternative model solves all these. Our .rst bio\u00adlogically relevant result is therefore that \nthrough synthesis we have revalidated the (experimentally-con.rmed) prediction from previ\u00adous work, without \nthe vagaries of human modeling.  6.0.3 Speci.cation ambiguity for C. elegans VPC models Next, we analyzed \nthe ambiguity in the speci.cation. The important biological unknown is the speci.c node within the cascade \nlet23\u00adsem5-let60-mpk1 that sends out the inhibitory signal to lin12 and lst. We attempted experimenting \nwith all four options under our de.nition of understanding the speci.cation ambiguity: Alternative models \nfor particular input con.guration 44 of the 48 experimental observations are deterministic. We wanted \nto know how many models exist if only the deterministic outcomes are asserted. We found that under this \nrelaxed speci.cation, all four options of inhibition coming from any node of the cascade work. Then using \nthe alternative model query from Section 5.3, we asked for a model including any one of the four remaining \nout\u00adcomes. The synthesizer eliminates two that have inhibition ema\u00adnating from let60 and mpk1. This was \nsigni.cant since it formally con.rmed the biologist s intuition that the inhibition comes from higher \nup in the cascade. Additionally, it showed that sem5 (in addi\u00adtion to let23, which was conjectured earlier) \nwas a valid possibility for the inhibitor. Input con.guration for disambiguating models Next, we at\u00adtempted \nto observationally distinguish these two remaining valid models. Our 48 observations mutate the entire \ncascade (all nodes let23 to mpk1) together. We wanted to infer if a .ner-grained muta\u00adtion exists that \ndistinguishes these two remaining mechanistic hy\u00adpotheses. We expanded the experimental set by enumerating \nall possibilities of the cascade nodes (24 possibilities of expansion for each of the 48 rows) leading \nto 384 experiments. Our synthesizer shows that no other mutations exist that would observationally dis\u00adtinguish \nthese two hypotheses. This saves the biologist signi.cant effort (336 experiments, each of which are \nexpensive and time\u00adconsuming) as they now know that mutation experiments will not Figure 9. (a) The template \nVP C ? we use for our experiments, which is derived as simply the union of connections known to biologists \n[12] as informally shown by Figure 1. The fate nodes are instrumentation nodes to help read out the outcome. \n(b) A small fraction of the speci.cation E (4 rows out of 48), obtained from literature in biology [12]. \nA fate pattern of 1/2 indicates that both 1 and 2 are outcomes observed in experiments.  Exp# AC Mutations \nlin12 lin15 Vul lst P3.p P4.p Fate pattern P5.p P6.p P7.p P8.p 1 Formed wt wt wt wt 3 3 2 1 2 3 5 Formed \nwt ko wt wt 1/2 1/2 2 1 2 1/2 7 Formed wt ko ko wt 3 3 3 3 3 3 13 Formed ko ko wt wt 1 1 1 1 1 1 suf.ce \nto distinguish these explanations and out-of-band experi\u00adments need to be performed. Inferring the minimal \nspeci.cation We run our minimization query from Section 5.3 for each of the VPC queries, with signi.cant \nresults. We infer that, for the space we are searching over, only four experimental observations suf.ce \nto yield a unique model. This set contains all non-deterministic outcomes, and additionally others that \ntogether constrain the system enough to yield the unique model that is explained by the 48 experiments. \nWet-lab predictions Our exploration demonstrated that (1) let23 is not the only possibility for inhibition, \nbut sem5 is as well; (2) let60 and mpk1 cannot play that role; and (3) the models using let23 and sem5 \ncannot be distinguished observationally. These sug\u00adgest a possible inhibition from sem5, that cannot \nbe distinguished through mutation experiments on the components included in our model, therefore other \ntypes of experiments would need to be done. 7. Performance evaluation We implemented our language as \nan embedded DSL in Scala. Our synthesis and analysis framework, also implemented in Scala, uses the Z3 \ntheorem prover [10] as its underlying constraint solver. We interface with Z3 through the ScalaZ3 library \n[22]. Our framework consists of 5K lines of code. We show performance results for the evaluation of our \nsynthesis procedure in Figure 11(a). For each example, we present total execution time, maximum memory \nusage, number of calls to the underlying SMT solver Z3, average call time, the structure of holes in \nthe partial programs, as well as the search space for synthesizing update functions. VPC1, VPC2, VPC3 \nand VPC4 are models of the fate decision in C. elegans vulval precursor cell development that express \neach different biological hypotheses about the cells through their topology. VPC1 and VPC2 are synthesized \nusing a speci.cation E with domain size 48, while VPC3 and VPC4 are synthesized using a speci.cation \nE ' whose domain is restricted to 44 elements. Sensors is the example introduced in Section 2. For each \nexample, we report the total running time for synthesis, the maximum memory usage, number of calls to \nthe underlying SMT solver Z3, the average time Z3 takes to solve these queries, a description of holes \nin the partial program as a sequence of number of states for each unspeci.ed update function, and the \nsize of the search space for synthesizing these functions. In all cases, we .nd that even for a complicated \nsynthesis prob\u00adlem such as the VPCs, our synthesizer is ef.cient. In Figure 11(b), we present performance \nresults for the pruning procedure described in Section 5.3.2. We report the domain size for the result \nof the procedure and the initial domain size in the pruned/total column. As expected, the time for pruning \nis signi.cantly higher than for only synthesis. This is because multiple synthesis and veri.ca\u00adtion queries \nare solved in the process of minimization. However, compared to the amount of time this could potentially \nsave the bi\u00adologists, i.e., months or even years of work in doing redundant ex\u00adperiments, our inference \ntimes are insigni.cant. 8. Related Work Inference of biological models While model checking of (man\u00adually \nwritten) logical biological models has been an active area of research, we are not aware of work that \nsynthesizes these mod\u00adels. In contrast, a growing body of literature exists on inference of non-logical \nmodels. The .rst class of such models uses ordinary differential equations (ODEs). An example of ODE \nmodel infer\u00adence from temporal and spatial data is the work by Aswani et al., who reduce the amount of \nprior knowledge needed to infer an ac\u00adcurate model [3]. Rizk et al. .nd parameters for ODE models by \noptimizing a notion of continuous degree of satisfaction of tempo\u00adral logic formulas [27]. Because ODE \nmodels are continuous, these techniques do not appear directly applicable for inference of logical models \nbased on concurrent systems. Machine learning has also been used to infer biological models. Barker et \nal. use time series data of protein levels to infer whether a protein is an activator or a suppressor \nof another protein [4]. Time series data of concentrations is not available in our setting, so these \napproaches do not apply to the inference of our models.  (a) Figure 10. Synthesized update functions \ngiven two different connection topologies, for let23, and lst. (a) The topology with lst and lin12 inhibited \nby let23. The template allows for three let23 states and three lst states. (b) The topology with lst \nand lin12 inhibited by sem5. The template allows for three let23 states and two lst states. example time \nmem. # calls time # calls holes search space VPC1 96.64 2.34 282 0.09 (3, 3) 2.25 \u00b7 1034 VPC2 87.77 2.33 \n285 0.08 (3, 2) 1.21 \u00b7 1021 VPC3 48.29 0.77 139 0.10 (4, 3) 1.47 \u00b7 1042 VPC4 49.18 1.26 133 0.09 (5, \n3) 7.25 \u00b7 1050 Sensors 4.30 2.40 51 0.01 (3, 2, 2) 2.53 \u00b7 1013 example time mem. # calls time # calls \npruned total VPC1 VPC2 VPC3 VPC4 Sensors 2964.82 1845.94 273.77 316.32 14.46 2.20 1.69 1.31 1.35 0.71 \n3805 3544 491 482 167 0.54 0.31 0.29 0.37 0.04 4/48 3/48 4/44 4/44 3/8  (a) (b) Figure 11. All times \nare in seconds, and memory usage is in gigabytes. (a) Evaluation results for synthesis. The number of \nlevels (i.e., states) for each synthesized update function is shown in the holes column. (b) Evaluation \nresults for speci.cation pruning. We report for each example the size of the pruned speci.cation domain \nand the size of the original speci.cation domain. Stochastic modeling An alternative to modeling biological \nsys\u00adtems using non-deterministic concurrency is to use stochasticity [2, 18, 24]. If we were interested \nin making predictions on the sys\u00adtem s output behavior, i.e., the most likely the behavior of the cell \nfor a given mutation, we might select a model that predicts con\u00adcentrations of proteins under varying \ninitial parameters, including those not yet measured in the lab. Such predictive models are often stochastic. \nIn contrast, we care to only discover a mechanistic explanation for the cellular system (i.e., how proteins \ncommunicate to agree on a particular cell fate). It is appropriate here to rely on a discrete model because \nthe modeling problem is to .nd a program that reproduces each observed outcome on at least one execution \n as opposed to some ratio of all executions. The existence of such a schedule is suf.cient to determine \nthe need to have the crucial protein-protein interaction. Synthesis algorithms for concurrent systems. \nOur synthesis al\u00adgorithm extends the synthesis algorithm for concurrent data struc\u00adtures [28]. That work \nshowed how to extend the CEGIS algo\u00adrithm [29] from the sequential setting into the semantics of concur\u00adrent \nprograms. The resulting algorithm however did not handle the richer speci.cation used in this paper (i.e., \nthe angelic correctness). Indeed, new algorithms had to be developed for the speci.cations of this paper. \nThe Paraglider project developed synthesizers for concurrent data structures by deriving them from high-level \nspec\u00adi.cations [31]. It is not clear how these derivation algorithms can be adapted to synthesis of concurrent \nsystems under input-output examples such as ours. Model checking [5 7, 11, 18] and abstract interpretation \n[9] have been applied to analyze various biological systems. All such efforts to manually construct and \nvalidate models have severely demonstrated the need for a synthesis system. Various other paradigms have \nbeen used to model biological systems, including Petri nets [8], boolean networks [23], and pro\u00adcess \nalgebras [26]. While our techniques are not directly applica\u00adble, our success in synthesis for a model \npreviously expressed in the expressive RM formalism demonstrates potential for synthesis in these other \nformalisms as well. 9. Conclusion We present a language and develop algorithms for synthesizing concurrent \nmodels from experiments that perform mutations on bi\u00adological cells and observe the results of the mutation \non developed cells. We synthesize models that reproduce all non-deterministic outcomes of experiments. \nThis variant of synthesis requires a 3QBF algorithm, which we design by allowing three solvers to commu\u00adnicate \ncounterexamples. We also develop algorithms for analyzing speci.cation ambiguity, ascertaining that a \nmodel is the sole bio\u00adlogical explanation whenever possible under given biological as\u00adsumptions, and \ncomputing minimal non-ambiguous speci.cations. We carried out a signi.cant case study, synthesizing a \nmodel of vulval cell fate speci.cation in the C. elegans earthworm that ex\u00adpresses a previously unknown \nbiological hypothesis. References [1] Rajeev Alur and Thomas A. Henzinger. Reactive modules. Formal Methods \nin System Design, 15(1):7 48, 1999.  [2] A. Arkin, J. Ross, and H. H. McAdams. Stochastic kinetic analysis \nof developmental pathway bifurcation in phage lambda-infected Es\u00adcherichia coli cells. Genetics, 149(4):1633 \n1648, Aug 1998. [3] Anil Aswani, Soile V. E. Ker \u00a8 anen, James Brown, Charless C. Fowlkes, David W. Knowles, \nMark D. Biggin, Peter Bickel, and Claire J. Tom\u00adlin. Nonparametric identi.cation of regulatory interactions \nfrom spa\u00adtial and temporal gene expression data. BMC Bioinformatics, 11:413, 2010. [4] Nathan A. Barker, \nChris J. Myers, and Hiroyuki Kuwahara. Learn\u00ading genetic regulatory network connectivity from time series \ndata. IEEE/ACM Trans. Comput. Biology Bioinform., 8(1):152 165, 2011. [5] Gr\u00b4egory Batt, Calin Belta, \nand Ron Weiss. Temporal logic analysis of gene networks under parameter uncertainty. IEEE Transactions \nof Automatic Control, page 2008. [6] Gr\u00b4egory Batt, Delphine Ropers, Hidde de Jong, Johannes Geiselmann, \nRadu Mateescu, Michel Page, and Dominique Schneider. Analysis and veri.cation of qualitative models of \ngenetic regulatory networks: A model-checking approach. In IJCAI, 2005. [7] Nathalie Chabrier and Franc\u00b8 \nois Fages. Symbolic model checking of biochemical networks. CMSB 03, 2003. [8] C. Chaouiya. Petri net \nmodelling of biological networks. Brief. Bioinformatics, 8(4):210 219, Jul 2007. [9] Vincent Danos, J\u00b4er \nome Feret, Walter Fontana, and Jean Krivine. Ab\u00adstract interpretation of cellular signalling networks. \nVMCAI 08, pages 83 97. [10] Leonardo de Moura and Nikolaj Bj\u00f8rner. Z3: Ef.cient SMT solver. In TACAS \n08: Tools and Algorithms for the Construction and Analysis of Systems, volume 4963/2008 of Lecture Notes \nin Computer Science, pages 337 340, 2008. [11] David L. Dill. Model checking cell biology. In CAV, page \n2, 2012. [12] J. Fisher, N. Piterman, A. Hajnal, and T. A. Henzinger. Predictive modeling of signaling \ncrosstalk during C. elegans vulval development. PLoS Comput. Biol., 3(5):e92, May 2007. [13] Jasmin Fisher, \nDavid Harel, and Thomas A. Henzinger. Biology as reactivity. Commun. ACM, 54(10):72 82, 2011. [14] Jasmin \nFisher and Thomas A. Henzinger. Executable cell biology. Nature Biotechnology, 25(11):1239 1249, November \n2007. [15] Jasmin Fisher, Thomas A. Henzinger, Maria Mateescu, and Nir Piter\u00adman. Bounded asynchrony: \nConcurrency for modeling cell-cell inter\u00adactions. In FMSB, pages 17 32, 2008. [16] https://oeis.org/A000670. \n[17] Sumit Gulwani. Automating string processing in spreadsheets us\u00ading input-output examples. In Proceedings \nof the 38th annual ACM SIGPLAN-SIGACT symposium on Principles of programming lan\u00adguages, POPL 11, pages \n317 330. ACM. [18] J. Heath, M. Kwiatkowska, G. Norman, D. Parker, and O. Tym\u00adchyshyn. Probabilistic \nmodel checking of complex biological path\u00adways. Theoretical Computer Science, 319(3):239 257, 2008. [19] \nNa aman Kam, Irun R. Cohen, and David Harel. The immune system as a reactive system: Modeling t cell \nactivation with statecharts. In HCC, pages 15 22, 2001. [20] Na aman Kam, David Harel, Hillel Kugler, \nRami Marelly, Amir Pnueli, E. Jane Albert Hubbard, and Michael J. Stern. Formal model\u00ading of c. elegans \ndevelopment: A scenario-based approach. In CMSB, pages 4 20, 2003. [21] http://www.cs.berkeley.edu/~koksal/. \n[22] Ali Sinan K \u00a8oksal, Viktor Kuncak, and Philippe Suter. Scala to the Power of Z3: Integrating SMT \nand Programming. In CADE, pages 400 406, 2011. [23] S. Li, S. M. Assmann, and R. Albert. Predicting essential \ncompo\u00adnents of signal transduction networks: a dynamic model of guard cell abscisic acid signaling. PLoS \nBiol., 4(10):e312, Oct 2006. [24] H. H. McAdams and A. Arkin. Stochastic mechanisms in gene ex\u00adpression. \nProc. Natl. Acad. Sci. U.S.A., 94(3):814 819, Feb 1997. [25] Martin Odersky, Lex Spoon, and Bill Venners. \nProgramming in Scala: a comprehensive step-by-step guide. Artima Press, 2008. [26] Aviv Regev and Ehud \nShapiro. The pi-calculus as an abstraction for biomolecular systems. 2004. [27] Aur\u00b4elien Rizk, Gr\u00b4egory \nBatt, Franc\u00b8ois Fages, and Sylvain Soliman. Continuous valuations of temporal logic speci.cations with \napplica\u00adtions to parameter optimization and robustness measures. Theor. Com\u00adput. Sci., 412(26):2827 2839, \n2011. [28] Armando Solar-Lezama, Christopher Grant Jones, and Rastislav Bodik. Sketching concurrent data \nstructures. In Proceedings of the 2008 ACM SIGPLAN conference on Programming language design and implementation, \nPLDI 08, pages 136 148. ACM. [29] Armando Solar-Lezama, Liviu Tancau, Rastislav Bodik, Sanjit Seshia, \nand Vijay Saraswat. Combinatorial sketching for .nite programs. In ASPLOS-XII, pages 404 415, New York, \nNY, USA, 2006. ACM. [30] Saurabh Srivastava, Sumit Gulwani, and Jeffrey S. Foster. From program veri.cation \nto program synthesis. In POPL, 2010. [31] Martin Vechev and Eran Yahav. Deriving linearizable .ne-grained \nconcurrent objects. SIGPLAN Not., 43(6):125 135, June 2008. [32] A. S. Yoo, C. Bais, and I. Greenwald. \nCrosstalk between the EGFR and LIN-12/Notch pathways in C. elegans vulval development. Science, 303(5658):663 \n666, Jan 2004.  \n\t\t\t", "proc_id": "2429069", "abstract": "<p>Executable biology presents new challenges to formal methods. This paper addresses two problems that cell biologists face when developing formally analyzable models.</p> <p>First, we show how to automatically synthesize a concurrent in-silico model for cell development given in-vivo experiments of how particular mutations influence the experiment outcome. The problem of synthesis under mutations is unique because mutations may produce non-deterministic outcomes (presumably by introducing races between competing signaling pathways in the cells) and the synthesized model must be able to replay all these outcomes in order to faithfully describe the modeled cellular processes. In contrast, a \"regular\" concurrent program is correct if it picks any outcome allowed by the non-deterministic specification. We developed synthesis algorithms and synthesized a model of cell fate determination of the earthworm C. elegans. A version of this model previously took systems biologists months to develop.</p> <p>Second, we address the problem of under-constrained specifications that arise due to incomplete sets of mutation experiments. Under-constrained specifications give rise to distinct models, each explaining the same phenomenon differently. Addressing the ambiguity of specifications corresponds to analyzing the space of plausible models. We develop algorithms for detecting ambiguity in specifications, i.e., whether there exist alternative models that would produce different fates on some unperformed experiment, and for removing redundancy from specifications, i.e., computing minimal non-ambiguous specifications.</p> <p>Additionally, we develop a modeling language and embed it into Scala. We describe how this language design and embedding allows us to build an efficient synthesizer. For our C. elegans case study, we infer two observationally equivalent models expressing different biological hypotheses through different protein interactions. One of these hypotheses was previously unknown to biologists.</p>", "authors": [{"name": "Ali Sinan Koksal", "author_profile_id": "81470653567", "affiliation": "University of California, Berkeley, Berkeley, CA, USA", "person_id": "P3978031", "email_address": "koksal@cs.berkeley.edu", "orcid_id": ""}, {"name": "Yewen Pu", "author_profile_id": "81487647091", "affiliation": "University of California, Berkeley, Berkeley, CA, USA", "person_id": "P3978032", "email_address": "yewenpu@mit.edu", "orcid_id": ""}, {"name": "Saurabh Srivastava", "author_profile_id": "81100062128", "affiliation": "University of California, Berkeley, Berkeley, CA, USA", "person_id": "P3978033", "email_address": "saurabhs@cs.berkeley.edu", "orcid_id": ""}, {"name": "Rastislav Bodik", "author_profile_id": "81100033082", "affiliation": "University of California, Berkeley, Berkeley, CA, USA", "person_id": "P3978034", "email_address": "bodik@cs.berkeley.edu", "orcid_id": ""}, {"name": "Jasmin Fisher", "author_profile_id": "81323490339", "affiliation": "Microsoft Research, Cambridge, Cambridge, England UK", "person_id": "P3978035", "email_address": "jasmin.fisher@microsoft.com", "orcid_id": ""}, {"name": "Nir Piterman", "author_profile_id": "81100334753", "affiliation": "University of Leicester, Leicester, England UK", "person_id": "P3978036", "email_address": "nir.piterman@le.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429125", "year": "2013", "article_id": "2429125", "conference": "POPL", "title": "Synthesis of biological models from mutation experiments", "url": "http://dl.acm.org/citation.cfm?id=2429125"}