{"article_publication_date": "01-23-2013", "fulltext": "\n Quantitative Abstraction Re.nement * Pavol .y Arjun Radhakrishna Cern\u00b4Thomas A. Henzinger IST Austria \n Abstract We propose a general framework for abstraction with respect to quantitative properties, such \nas worst-case execution time, or power consumption. Our framework provides a systematic way for counter-example \nguided abstraction re.nement for quantitative properties. The salient aspect of the framework is that \nit allows any\u00adtime veri.cation, that is, veri.cation algorithms that can be stopped at any time (for \nexample, due to exhaustion of memory), and report approximations that improve monotonically when the \nalgorithms are given more time. We instantiate the framework with a number of quantitative ab\u00adstractions \nand re.nement schemes, which differ in terms of how much quantitative information they keep from the \noriginal system. We introduce both state-based and trace-based quantitative abstrac\u00adtions, and we describe \nconditions that de.ne classes of quantitative properties for which the abstractions provide over-approximations. \nWe give algorithms for evaluating the quantitative properties on the abstract systems. We present algorithms \nfor counter-example based re.nements for quantitative properties for both state-based and segment-based \nabstractions. We perform a case study on worst\u00adcase execution time of executables to evaluate the anytime \nveri.ca\u00adtion aspect and the quantitative abstractions we proposed. Categories and Subject Descriptors \nD.2.4 [Software/Program Veri.cation] General Terms Theory, Veri.cation Keywords abstraction, re.nement, \nquantitative analysis 1. Introduction The quantitative analysis of systems is gaining importance due \nto the spread of embedded systems with requirements on re\u00adsource consumption and timeliness of response. \nQuantitative anal\u00adyses have been proposed for properties such as worst-case execu\u00adtion time (see [19] \nfor a survey), power consumption (pioneered in [17]), and prediction of cache behavior for timing analysis \n(see, for example, [9]). Anytime algorithms (see [1]) are algorithms that generate impre\u00adcise answers \nquickly and proceed to construct progressively better * This research was supported in part by the European \nResearch Council (ERC) Advanced Investigator Grant QUAREM and by the Austrian Science Fund (FWF) project \nS11402-N23. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n13, January 23 25, 2013, Rome, Italy. Copyright c &#38;#169; 2013 ACM 978-1-4503-1832-7/13/01. . . $10.00 \n approximate solutions over time, eventually .nding the correct so\u00adlution. Anytime algorithms are useful \nin veri.cation, as they of\u00adfer a way to deal with the state-space explosion problem if the algorithm \nis terminated early, for example due to memory ex\u00adhaustion, it is still able to report an approximation \nof the desired result. The term anytime veri.cation has been proposed [16] re\u00adcently in the context of \nverifying boolean properties, as a way to get (non-quanti.ably) better estimates on whether a property \nholds for a system. The anytime concept, however, is particularly well\u00adsuited in the context of quantitative \nveri.cation. In this context, abstraction gives a quantitative over-approximation of the quantita\u00adtive \nanswer to a veri.cation question, and it is natural to require the anytime property: the more time the \nveri.cation run is given, the (quanti.ably) better the over-approximation of the correct answer should \nbe. We implement this anytime property for quantitative veri.cation through an abstraction re.nement \nscheme that mono\u00adtonically improves the answer. For instance, abstraction re.nement may compute increasingly \nbetter approximations of power con\u00adsumption of a system. We propose a framework for abstraction and abstraction \nre.ne\u00adment for quantitative properties that is suitable for anytime veri.ca\u00adtion. We explain the motivation \nand intuition behind the framework using the following example. Motivating example. Consider the problem \nof a,b,c,i,v: int; input v; estimating the worst-case if (v == 1) execution time (WCET) of for (i=0;i<16;i++) \nread(a); the program in Figure 1. else if(v == 2) We assume an idealized for (i=0;i<16;i++) situation \nwhere the perfor-if (i mod 2 = 0) read(b); mance is affected mostly else by the cache behavior. Let for \n(i=0;i<16;i++) each program statement if (i mod 4 = 0) read(c); have a cost depending on whether it \naccesses only Figure 1: Example 1 the cache (or no memory at all), for a cost of 1, or main memory \nfor a cost of 25. we assume that the program variables i,a,v are mapped to different cache entries, while \nb and c are mapped to the same entry (different from the entries for the other variables). We consider \nabstractions that abstract only the cache (not the program). The cache is abstracted by an abstract cache \nwith a smaller number of entries (accesses to the entries not tracked in the abstract cache are always \nconsidered to be a cache miss). Let us start the analysis with an abstract cache of size 2 which caches \nvariables i and v. In the abstract system (i.e., the original program composed with the abstract cache), \nthe worst-case trace has v equal to 1, and the program accesses the (uncached) variable a 16 times. The \nanalysis then uses this trace to re.ne the abstraction. The re.nement extends the cache to include the \ncache entry for a. The worst-case execution then has v equal to 2, and it has 8 accesses to b. The analysis \nnow re.nes the abstraction by extending the cache with an entry for b. The WCET estimate is thus tightened, \nuntil either the highest-cost trace corresponds to a real execution (and thus the WCET estimate is precise), \nor the analysis runs out of resources and reports the computed over-approximation. Abstraction for quantitative \nproperties. Our model of systems is weighted transition systems. We provide a way of formalizing quantitative \nproperties of systems which capture important proper\u00adties studied in literature, including limit-average, \ndiscounted-sum, and boolean properties such as safety and liveness. The framework makes it possible to \ninvestigate quantitative versions of the boolean properties: for instance, for safety one could ask not \nonly if an er\u00adror state is reached, but also how often it is reached. We focus on properties that admit \na linear trace that maximizes (or minimizes) the value of the quantitative property. Such a trace is \ncalled the ex\u00adtremal trace (ext-trace for short). We present two types of quantitative abstraction schemes. \nThe .rst is state-based, that is, the elements of the abstract domain correspond to sets of states. The \nsecond is segment-based, that is, the elements of the abstract domain correspond to sets of trace segments. \nState-based quantitative abstractions. The abstraction scheme ExistMax is state-based. It is a direct \nextension of predicate abstraction, where each abstract state corresponds to an equiva\u00adlence class of \nconcrete states. In addition, with each abstract state, ExistMax stores the maximum weight of the corresponding \ncon\u00adcrete states. We give conditions for the class of quantitative proper\u00adties for which ExistMax is \na monotonic over-approximation (that is, it provides better estimates as the underlying equivalence rela\u00adtion \non states is re.ned). This class includes all the quantitative properties mentioned above. However, we \nshow that there are nat\u00adurally de.ned properties for which ExistMax is not a monotonic over-approximation. \nThis is in contrast to the abstraction re.ne\u00adment of boolean properties (in the boolean case, we do not \nget less precise invariants if we add more predicates). Segment-based quantitative abstractions. We introduce \na num\u00adber of segment-based abstraction schemes. A segment is a (.nite or in.nite) sequence of states \nthat is a consecutive subsequence of an execution trace. As the quantitative properties we consider ac\u00adcumulate \nquantities along (in.nite) traces, it is natural, and advan\u00adtageous, to consider abstract domains whose \nelements correspond to sets of segments, not sets of states. This is similar to termination and liveness \nanalysis using transition predicates [14], and their gen\u00aderalizations to segment covers [7]. We build \nupon these approaches to develop our quantitative abstractions. The PathBound abstrac\u00adtion scheme stores \nwith each abstract state t (representing a set of segments) (i) minp(t), the length of a shortest .nite \nsegment in t, (ii) maxp(t), the length of the longest .nite segment in t, (iii) hasInfPath(t) a bit that \nis true if t contains a segment of in.\u00adnite length, and (iv) val(t), a summary value of the weights of \nthe states. De.ning val(t) as the maximal weight of a state oc\u00adcurring in one of the segments in t makes \nPathBound a sound over-approximation for a general class of quantitative properties. To get better approximations \nfor particular quantitative properties val(t) can be a different summary of the weights. For instance, \nwe specialized PathBound to limit average by storing not the max\u00adimal occurring value, but the maximal \naverage of values along a segment. In order to compare state-based and segment-based abstrac\u00adtions, let \nus consider the limit-average property applied to a pro\u00adgram with a simple for loop for which the loop \nbound is statically known to be 10. Let us assume that the cost of the operations inside the loop is \nmuch greater than the cost of the operations outside the loop. Now consider the state-based abstraction \nExistMax with an abstract state t that groups together all states whose control loca\u00adtion is in the for \nloop. In the ExistMax abstraction, this abstract state has a self-loop. Analyzing the abstract system \nwould conclude that the highest-cost trace is the one which loops forever in t. This would be a very \nimprecise result, as the concrete traces all leave the loop after 10 iterations. To correct for this, \nthe loop would have to be unrolled 10 times, using 10 counterexample-guided re.ne\u00adment steps. On the \nother hand, consider the PathBound abstrac\u00adtion, with an abstract state t representing all the segments \nin the loop. For t, hasInfPath(t) is false and maxp(t) = 10, allowing immediately for more precise estimates. \n The PathBound abstraction scheme is a sound abstraction in the sense that the quantitative value we \nobtain by analyzing the ab\u00adstract system over-approximates the value for the concrete system. As in ExistMax, \nthis holds for a large class of quantitative proper\u00adties. However, we show that PathBound is not a monotonic \nover\u00adapproximation even for standard quantitative properties such as the limit-average property in the \nsense that after re.nement of the ab\u00adstract states, we may get worse estimates. We therefore present \na hierarchical generalization of PathBound called HPathBound. In PathBound, each abstract state represents \na set of segments, and stores some quantitative characteristics (such as minp, maxp) of that set. In \norder to compute better estimates of these quantitative characteristics, one can perform another level \nof re.nement, within abstract states. This leads to the idea of a hierarchical abstraction. It is particularly \nuseful for software, which already has a hierarchical structure in many cases (e.g., nested loops, function \ncalls). This ap\u00adproach corresponds to the (multi-level) abstract inductive segment cover of [7, Section \n16.1]. Re.nement of state-based abstractions for quantitative proper\u00adties. For the state-based abstraction \nscheme ExistMax, we give an algorithm for counterexample-guided abstraction re.nement (CE-GAR) for quantitative \nproperties. The algorithm is based on the classical CEGAR algorithm [2], which we extend to the quanti\u00adtative \ncase. In the classical CEGAR loop, the counterexample to be examined is chosen using heuristics. For \nquantitative proper\u00adties, it is clear that an extremal counterexample trace (the ext-trace) should be \nchosen for re.nement. The reason is that if the ext-trace does not correspond to a real trace, then a \nre.nement which does not eliminate this trace would have the same value as the previous abstract system. \nRe.nement of segment-based abstractions for quantitative properties. We propose a re.nement algorithm \nfor the segment\u00adbased abstraction HPathBound. We chose HPathBound be\u00adcause, as discussed above, it is \nparticularly suitable for software, and it is a monotonic over-approximation for a large set of quan\u00adtitative \nproperties. An abstract counterexample for HPathBound is a hierarchical trace. Given an extremal abstract \ncounterexample which does not correspond to a concrete counterexample, the ab\u00adstract counterexample is \ntraversed, similarly as in the classical CE-GAR algorithm, until an abstract segment that provides values \nthat are too pessimistic (e.g., maxp and val values which cannot be achieved in the concrete system by \na concretization of the abstract counterexample) is found. This abstract segment is then re.ned. Note \nthat the fact that the counterexample is hierarchic gives free\u00addom to the traversal algorithm at each \nstep, it can decide whether or not to descend one level lower and to .nd a mismatch between a concrete \nand abstract execution there. Experimental results In order to evaluate the proposed abstraction schemes, \nboth state-based and segment-based, we performed a case study on worst-case execution time analysis of \nx86 executables. We focused on one aspect, the cache behavior analysis, and in particular, on estimating \nthe rate of cache misses over the course of the worst-case execution. In order to abstract the cache, \nwe used the abstractions introduced in [9]. To the best of our knowledge, this is the .rst work on automated \nre.nement for these abstractions. We implemented two abstraction schemes: the state-based ExistMax and \nthe segment-based HPathBound. We performed the case study on our own (small) examples, and on some of \nthe benchmarks collected in [11]. The experiments show that we ob\u00adtain more precise quantitative results \nas the abstraction is re.ned, for example, by having a larger abstract cache. Furthermore, we show that \nusing the segment-based abstraction HPathBound en\u00adables scaling up. This is due to the fact that in the \npresence of loops, the HPathBound abstraction can quickly obtain good over\u00adapproximations if it can statically \nover-approximate loop bounds, whereas the ExistMax abstraction would have to unroll the loop many times \nto get comparable results. Similarly to the ExistMax case, the experiments show that we obtain more precise \nquantitative results as the HPathBound abstraction is (hierarchically) re.ned by computing better estimates \nfor loop bounds. The running time of the analysis was under 35 seconds in all cases. Related work. The \ntheory of abstractions for programs was intro\u00adduced in [5]. We build on the transition predicates of \n[14] and seg\u00adment covers of [7] to construct our quantitative abstractions. The CEGAR algorithm was introduced \nin [2] and is widely used. Au\u00adtomated abstraction re.nement for transition predicates was pre\u00adsented \nin [4]. To the best of our knowledge, CEGAR-like algo\u00adrithms for quantitative properties have not yet \nbeen studied. However, quantitative abstractions and re.nements have been introduced for stochastic systems \n[8, 12, 13], where the need for quantitative reasoning arises because of stochasticity. They are mainly \ndirected towards the estimation of expected values, and the algorithms re.ect this fact. The probabilistic \nwork does not aim at handling accumulative properties like the limit-average property. Abstractions (but \nnot CEGAR-like algorithms) have been pro\u00adposed for certain quantitative properties of non-probabilistic \nsys\u00adtems, such as cache abstractions for WCET analysis [9]. WCET analysis using interval abstraction \nwas performed in [15].The power consumption analysis of software based on the costs of sin\u00adgle instructions \nwere presented in [17]. Our WCET analysis of executables based on quantitative abstraction re.nement \ncould be adapted for power consumption analysis using these models. 2. Quantitative properties A weighted \ntransition system (WTS) is de.ned by a tuple S = (Q, d, e, q.), with a (.nite or in.nite) set of states \nQ, a transition set d . Q \u00d7 Q, weight function e : Q . R, and an initial state q. . Q. Let S denote the \nset of all WTSs and let S(Q) . S be the set of all WTSs with a set of states Q such that Q . Q. We ' \n' assume that .q . Q : .q: (q, q) . d. System S1 in Figure 2 is an example of a WTS. A trace of a WTS \nS is an in.nite sequence p = q0q1 . . . with q0 = q., and .i = 0 : (qi, qi+1) . d. The set of all traces \nof S is denoted by .(S). We extend the weight function e to traces as e(q0q1 . . .) = r0r1 . . . . R. \nwhere ri = e(qi), and to sets of traces as e(T ) = {w | .p . T : w = e(p)}. A trace p = q0q1 . . . is \nmemoryless if for all i, j = 0, we have qi = qj . (qi+1 = qj+1). For instance, system S1 in Figure 2 \nhas two memoryless traces, a trace p1 with e(p1) = (1 10 4 3 1 1 1). , and a trace p2 with e(p2) = (1 \n10 4 3 1 1 1 1). . A quantitative property f : S . R is de.ned using two functions: a trace 10 4 value \nfunction ft and a system value 1 3 function fs. The trace value function ft : R. . Rsummarizes a single \ntrace 1 of the system. The system value func\u00ad 1 tions fs : 2R . R summarizes the set 1 1 of ft values \nof all traces of the system. We then have f(S) = fs({ft(r) | .p . Figure 2: System S1 .(S) : e(p) = r}). \nWe extend ft to 2R. by letting ft(T ) = {ft(r) | r . T }. Hence, we have that f(S) = fs(ft(e(.(S)))). \nWe present a number of common quantitative properties below. We also model some classical boolean properties \nin our framework. First, we give examples of trace value functions: Limit-average. The limit-average \ntrace value function measures the maximal long-term average weight over a trace. The func\u00adtion limavg \n: R. . R is de.ned by limavg(r0r1 . . .) = 1 i-1 lim inf i.8 \u00b7rk. For the trace p1 of S1, the value \ni k=0 limavg(e(p1)) = 21 = 3. 7 Discounted-sum. The discounted-sum trace value function accumu\u00adlates \nthe weights over a trace where weights occurring further along the trace are discounted by a factor . \n. (0, 1). Formally, the func\u00ad 8 tion disc.(r0r1 . . .) =i=0 .i \u00b7 ri. Safety and quantitative safety. \nThe classical safety property is de\u00ad.ned by a set of unsafe states U, and a trace is safe if it never \nvisits a state in U. To model a safety property, we assign the weight 1 to each state in U and the weight \n0 to all other states. The safety trace value function is de.ned as safety(r0r1 . . .) = sup ri. Now, \nfor any trace p, we have safety(e(p)) = 0 if and only if p is safe. Note that this modeling of safety \nis still boolean, because the trace value can only be either 0 or 1. In some applications, a more quantitative \nview might be useful. Consider safety. de.ned n-1 .k by safety.(r0r1 . . .) = limn.8k=1 \u00b7 rk (discounted \nsum of the number of 1 s in the run). For a safe trace p, we still have that safety.(e(p)) = 0. However, \nfor an unsafe trace, safety.(e(p)) gives a more .ne-grained picture: it measures how early and often \nthe bad states are visited. Liveness and quantitative liveness. The liveness property is de.ned by a \nset of B \u00a8uchi (live) states L, and a trace is live if it visits states in L in.nitely often. To model \na liveness property, we assign weight 0 to each state in L and weight 1 to all other states. The trace \nvalue function live(r0r1 . . .) = lim inf i.8 ri. This function is faithful to the liveness property, \ni.e, live(e(p)) = 0 if and only if the trace is live. As in the safety case, we can get a .ner view of \nliveness by measuring how often states in L are visited. We do it by letting 1 i-1 live(r0r1 . . .) \n= lim inf i.8 \u00b7ri. i k=0 Second, we give examples of standard system value functions. Supremum and In.mum. \nIntuitively, the supremum and in.mum functions measure the worst-case and best-case traces in the system. \n Threshold. The threshold function checks if any of the values in the given set are above or below given \nthresholds. Formally, threshold u(R) = 1 if .r . R : r = u, and threshold u(R) = 0 otherwise.  Any \ncombination of a trace value function and a system value function de.nes a quantitative property. In \nthis paper, we implicitly assume that the system value function for any quantitative property is sup \nunless otherwise mentioned. A trace p is an extremal counterexample trace (or ext-trace for short) if \nf (S) = fs({ft(e(p))}). We restrict ourselves to a class of quantitative properties that admit memoryless \nextremal counterex\u00adample traces, i.e., every system S has a extremal counterexample trace that is memoryless. \nFormally, f is memoryless if and only if .S . S : .p . .(S) : f(S) = fs({ft(e(p))}). Note that all properties \nmentioned above are memoryless. 3. State-based quantitative abstractions A quantitative abstraction C \n= (SC , f C , aC ) is triple consisting of a set of abstract systems SC , an abstract quantitative property \nfC : SC . R and an abstraction function aC : S . S C . A quantitative abstraction C is an over-approximation \nof f , if for all S . S , f C (aC (S)) = f(S). 3.1 ExistMax abstraction. In this section, we present \na quantitative abstraction technique based on state abstractions. In this case, the abstract system is \na WTS whose states are sets of states of the concrete systems. In par\u00adticular, our abstraction scheme \nExistMax is a direct extension of the classical predicate abstraction. Compared to predicate abstrac\u00adtion, \nExistMax additionally stores, with each abstract state, the maximum weight occurring in the set of corresponding \nconcrete states. The name ExistMax refers to transitions abstracted existen\u00adtially, and that the weights \nabstracted by maxima. ExistMax is a state based abstraction scheme: a family of quan\u00adtitative abstractions \nparameterized by equivalence relations on Q. Given an equivalence relation . Q \u00d7 Q, the quantitative \nab\u00ad (Sem straction ExistMax = , f em , aem ) has (a) Sem = S(2Q ), (i.e., abstract states are set of \nconcrete states), (b) fem = f as the abstract quantitative property, and (c) for a WTS S = (Q, d, e, \nq.) we have that the abstract system aem (S) is a WTS Sem em em = (Qem , dem ,e ,t. ) where: Qem are \nequivalence classes of that contain states from Q; (t1, t2) . dem . .q1 . t1, q2 . t2 : (q1, q2) . \nd;  e(t) = sup{d | .q . t : e(q) = d}; and  em t. is the equivalence class in Qem that contains q.. \nIntuitively, aem (S) is an existential abstraction and e em maps an abstract state to the maximum weight \nof the corresponding concrete state. Example 1. Consider again the system S1 from Figure 2, and the equivalence \nrelation , whose two equivalence classes (indicated by the dashed shapes) are shown in the upper part \nof Figure 3. The aem abstract system Sem = (S1) is in the lower part of Figure 3. (aem (Sem We have \nlimavgem )) = 10, due to a self-loop on the abstract node with weight 10. 3.1.1 Over-approximation \nand monotonicity. We characterize the quantitative prop\u00aderties for which ExistMax is an over\u00ad approximation, \nand for which mono\u00ad tonicity of re.nements holds, i.e., where re.nement of the abstraction leads to tighter \napproximations of the system value. We borrow the classical notion of S1 re.nement for abstractions. \nAn equiv\u00ad alence relation = is a re.nement of an 10 1 aem equivalence relation if and only if (S1) \nevery equivalence class of = is a sub\u00adset of an equivalence class of . Fig. 3: ExistMax abs. We de.ne \nthe following quasi-orders: 11 22 let =p. R. \u00d7 R. be de.ned by: r0r1 . . . =p r0r1 . . . if and only \nif .i : ri 1 = ri 2, and ' ' let .. 2R\u00d72R be de.ned by: for U, U . R, we have U . U iff sup U = sup U \n' . A quantitative property f is (=p, .)-monotonic if .r, r ' . R. : ' '' r =p r =. ft(r) = ft(r ' ) \nand .U, U . 2R : U . U =. fs(U) = fs(U ' ). ExistMax is a monotonic over-approximation for a quantitative \nproperty f, if (a) ExistMax is an over-approximation for f, and (b) if for all S . S(Q), and for all \nequivalence relations = and on Q, such that = is a re.nement of , we have that fem (aem (S)) = fem (aem \n(S)). = Theorem 2. If f is (=p, .)-monotonic quantitative property, then ExistMax is a monotonic over-approximation \nof f . Proof. We .rst prove the monotonicity property of ExistMax. The over-approximation property follows \nnaturally as follows. For any aem system S, we have S = id (S) where id is the identity relation. As \nid is a re.nement of any equivalence relation , by monotonic\u00adity it follows that f(S) = fem (aem (S)). \nid (S)) = fem (aem Let S be a system in S(Q), and let = and be equivalence (Q1 11 relations on Q. \nLet a (S) = , d1 , e , q . ) and a=(S) = (Q2 22 , d2 , e , q . ) be ExistMax abstractions of S, where \n= is a re\u00ad.nement of . Furthermore, let f de.ned by ft and fs be (=p, .)\u00admonotonic. For each equivalence \nclass t of =, let tL be the unique equivalence class of for which t . tL. The class tL is guar\u00adanteed \nto exist as = is a re.nement of . Furthermore, by the de.nition of ExistMax, we have that: (a) e 1(t) \n= e 2(tL), and LL (b) (t1, t2) . d1 =. (t1, t2) . d2. Therefore, for any trace p = LL t0t1 . . . of \na=(S), there exists a trace pL = t0t1 . . . of a (S) such 11 2 L2 L that: e (t0)e (t1) . . . =p e (t0)e \n(t1) . . .. By =p-monotonicity of ft, we get ft(e(p)) = ft(e(pL)). Hence, for each w . ft(e(.(a=(S)))), \nthere exists wL . ft(e(.(a (S)))) with w = wL. This, in turn, gives us ft(e(.(a=(S)))) . ft(e(.(a=(S)))). \nHence, by .-monotonicity of fs, we get fs(ft(e(.(a=(S))))) = fs(ft(e(.(a (S))))), or equivalently, f(a=(S)) \n= f(a (S)). = fem This proves the required theorem. as f . It is easy to show that safety, liveness, \nlimit average, and dis\u00adcounted sum are (=p, .)-monotonic. The following proposition is a direct consequence. \nProposition 3. ExistMax is a monotonic over-approximation for the limit-average, discounted-sum, safety, \nand liveness properties. Example 4. We describe a property for which ExistMax is not a monotonic over-approximation. \nLet f be de.ned by ft(r) = supi,j=0(ri - rj ) and fs(U) = sup U. The property f can be used to measure \nthe variance in resource usage (where the usage in each step is given by the weight) during the execution \nof a program. Consider the system in Figure 4 and the ExistMax abstraction with abstract states given \nby the rectangles (the nodes outside the dotted boxes are each in a separate singleton equivalence classes) \n. Property f has value 2 on the abstract system due to the trace A . B . C having maximal and minimal \nweights as 5 and 3 (under ExistMax abstract state A, B, and C have weights 5, 3, and 3 respectively). \nRe.ning the abstraction by completely splitting state B increases f to 4. Re.ning further by splitting \nboth states A and C decreases f to 3 which is the true value of the concrete system. The sequence of \nre.nements show that for property f, the ExistMax abstraction is neither an over-approximation (as the \n.rst abstract system has value 2 which is less than 3, the value of the concrete system), nor monotonic \n(as the sequence of values 2, 4 and 3 obtained through subsequent re.nements .rst increase and then decrease). \n 3.1.2 Evaluating quantitative properties on ExistMax abstractions. Recall fem = f for ExistMax abstractions. \nTo evaluate fem (and obtain an ext-trace for re.nement), any algorithm for .nd\u00ading ext-traces for the \nquantitative property f suf.ces. Standard al\u00adgorithms exist when f is one of safety, liveness, discounted-sum, \nand limit-average properties. For limit-average, we use the classi\u00adcal Howard s policy iteration. 4. \nSegment-based quantitative abstractions In this section, we present quantitative abstractions where elements \nof the abstract domain correspond to sets of trace segments. Segments. A segment is a .nite or in.nite \nsequence of states in Q. Let Q * be the set of all .nite segments, Q8 the set of all in.nite segments, \nand let Q*8 = Q * . Q8 be the set of all .nite and in.nite segments. Given a segment s, let |s| denote \nthe length of the segment (the range of |.| is thus N. {8}). Given two segments s1 and s2 in Q*8 we write \ns1s2 for their concatenation, with s1s2 = s1, if s1 is in Q8. Also, we the notation last(s1) and .rst(s2) \nto represent the last state of a .nite segment s1 and the .rst state of a segment s2. We dub a nonempty \nset of seg\u00adments a SegmentSet. We de.ne the A B C following operations and relations on SegmentSets and \nsets of SegmentSets. For SegmentSets T1 and T2, we have T1 . T2 if T1 . {w | .x . Q * , .y . Q*8 : xwy \n. T }, that is, all segments from T1 occur as sub-segments of segments in T2.   Fig. 4: Non-mono\u00ad \nFor a set of SegmentSets T , we tonic re.nements de.ne T to be set of segments which can be obtained \nby concatenation of segments con\u00ad tained in SegmentSets in T . Formally, T = {s0s1 . . . sn |.T0, T1 \n. . . Tn : (.i : 0 = i = n =. si . Ti)} . {s0s1 . . . | .T0, T1 . . . : (.i : 0 = i . si . Ti)}. A set \nof SegmentSets T covers a SegmentSet T if and only if for all Ti . T , we have Ti c T , and T . T . \nNote that for a WTS S, the set of all its traces .(S) is a SegmentSet. We call T a segment cover of a \nsystem S if and only if T covers .(S). For example, the two SegmentSets T1 and T2 in Figure 5 form a \nsegment cover of the system in Figure 2. It is easy to see that all traces of S are covered by segments \nin T1 and T2. Our notion of segment cover corresponds to the inductive trace segment cover from [7] with \nheight 1. The notion of the segment cover plays the same role in segment-based abstractions as the equivalence \nrelation on states plays in state-based abstractions. 4.1 PathBound abstraction. PathBound is a segment-based \nabstraction scheme: a family of quantitative abstractions parameterized by sets of SegmentSets on Q. \nGiven a set of SegmentSets T , the quantitative abstraction pb PathBoundT is de.ned by (ST pb, f pb, \naT ). We now de.ne each element of the triple. Abstract systems ST pb. An abstract system in ST pb is \na tuple (R, dR, val, minp, maxp, hasInfPath, R0), where R is T , dR is a transition relation, and R0 \nis the set of initial states. The type of val, minp and maxp functions is R . R and the type of hasInfPath \nis R . B. Their intuitive meaning is given below. The systems in Spb T are called pb-systems. apb apb \nAbstraction The partial abstraction function is de- T . T .ned as follows. For a WTS S, if T is not a \nsegment cover pb of .(S), then the value aT (S) is unde.ned. Otherwise, given pb Spb Spb S = (Q, d, e, \nq.), let aT (S) = . where Spb = (Qpb , dpb , val, minp, maxp, hasInfPath, Qpb 0 ) and Qpb is T (T1, \nT2) . dpb if .s1 . T1, s2 . T2, such that s1 is a .nite segment in Q * , (last(s1), .rst(s2)) . d.  \nval(T ) = max{e(q) | .s . T and q occurs in s}, i.e., val(T ) is the maximal weight of a state occurring \nin one of the segments in T  minp(T ) = min{|s| | s . T is a .nite segment} if T con\u00adtains a .nite segment, \nand is 8 otherwise.  maxp(T ) = max{|s| | s . T is a .nite segment}, if T contains a .nite segment, \nand is 8 otherwise.  hasInfPath(T ) = true iff T n Q8  = \u00d8, i.e., hasInfPath(T ) is true if and only \nif T contains an in.nite segment, T1 T2 val = 10 val = 1 maxp = 4 maxp = 4 minp = 4 minp = 3 hasInfPath \n= false hasInfPath = false Figure 5: PathBound abstraction of S1 Qpb 0 contains a set T in T iff T contains \na segment whose .rst state is q.. As T is a segment cover of S, we have that Qpb 0 is non-empty. A pb-trace \n. of a pb-system Sa is either (a) a .nite sequence . Qpb T0T1 . . . Tn such that T0 0 , hasInfPath(Tn), \nand .i : 0 = i < n : (Ti, Ti+1) . dpb, or (b) an in.nite sequence T0T1 . . . with pb T0 . Q0 , and .i \n= 0 : (Ti, Ti+1) . dpb. The set of all pb-traces of Sa is denoted by .pb(Sa). Example 5. Recall the system \nS1 from Figure 2. Consider a seg\u00adment cover T = {T1, T2} of .(S) depicted in Figure 5. T1 and T2 can \nnow act as abstract states, with the values val,minp,maxp, and hasInfPath given in Figure 5. Abstract \nquantitative property fpb. In order to de.ne the abstract quantitative property f pb, we will need the \nfollowing notions. Let us .x a system S = (Q, d, e, q.). Let us also .x a set T of SegmentSets, such \nthat T is a segment cover for S. Let apb (Qpb (S) = Sa = , dpb , val, minp, maxp, hasInfPath, Qpb) T \n0 be a PathBound abstraction of S for T . We now de.ne a function B that for a given pb-trace . returns \na set of possible sequences of weights that correspond to .. The function B : .(Sa) . 2R. is de.ned as \nfollows. The set B(.) contains a sequence: n0 n1 8 w w . . . w in R. iff . is a .nite pb-trace T0T1T2 \n. . . Tn, 0 1 n such that (a) .i such that 0 = i = n, we have wi = val(Ti), and (b) .i such that 0 = \ni < n, we have minp(Ti) = ni = maxp(Ti) and 0 < ni = 8. n0 n1 w0 w1 . . . in R. iff . is an in.nite pb-trace \nT0T1 . .pb(Sa) such that (a) .i = 0 : wi = val(Ti), and (b) .i = 0 : minp(Ti) = ni = maxp(Ti) . 0 < ni \n= 8. Let f be a quantitative property de.ned by a trace value function ft and a system value function \nfs. We are now able to de.ne the abstract quantitative property fpb by fpb(Sa) =  fs(ft(( ...pb B(.)))). \nExample 6. Recall again the system S1 from Figure 2 and the abstract cover described in Example 5. Consider \nthe abstraction apb T (S1) (the abstract system is depicted in Figure 5). There is only one pb-trace \n. of the abstract system, and we have . = (T1T2). . Let us assume that the quantitative property we are \ninterested in is the limit average quantitative property. We get that B(.) = {(10 10 10 10 1 1 1 1). \n, (10 10 10 10 1 1 1).}. We therefore obtain fpb(apb (S1)) = (10 \u00b7 4 + 1 \u00b7 3)/(4 + 3) = 43 , as the T \n7 maximum value is achieved if the execution stays at the more costly abstract state T1 as much as possible \n(maxp(T1) times), and at the less costly abstract state T2 as little as possible (minp(T2) times). 4.1.1 \nOver-approximation and monotonicity The following theorem states that the abstraction scheme PathBound \nis an over-approximation for a large class of quan\u00adtitative properties. Theorem 7. PathBound abstraction \nscheme is an over\u00adapproximation for a quantitative property f if f is (=p, )\u00admonotonic. val = 1 I \nmaxp = 4 minp = 1 val = 10 hasInfPath = false maxp = 5 I minp = 5 val = 10 hasInfPath = false maxp = \n4 minp = 1 (a) apb (S) T1 hasInfPath = false pb (b) aT2 (S) Figure 7: Abstractions of system S2 A set \nof SegmentSets T1 re.nes a set of SegmentSets T2 iff for all T . T2, there exists a set of SegmentSets \nT , such that T . T1, and T covers T . PathBound is a monotonic over-approximation for a quantita\u00adtive \nproperty f, if (a) PathBound is an over-approximation for f, and (b) if for all S . S(Q), and for all \nsets T1 and T2 of SegmentSets such that (a) T1 covers .(S), (b) T2 covers .(S), and (c) T2 is a re.nement \nof T1, we have that fpb(apb (S)) = T2 fpb(apb T1 (S)). The abstraction PathBound is not a monotonic approxima\u00adtion \nin general even for quantitative properties that are (=p, )\u00admonotonic. We show this by constructing a \ncounterexample (see Example 10) for which the abstraction is not a monotonic approxi\u00admation for the limit-average \nproperty.  4.2 State-equivalence induced segment-based abstraction Given an equivalence relation on \nstates, we can de.ne a set of SegmentSets. Let S = (Q, d, e, q.) be a WTS, and let be an equivalence \nrelation on states in Q. Given 4 an equivalence class I e of , we can de.ne Figure 6: System S2 a corresponding \nSeg\u00admentSet Te as follows. First, let Te ' be the set of (.nite or in.nite) segments s such that all \nstates q that occur in s are in e. Now we de.ne Te as the set of maximal segments in T '. A segment e \ns is maximal in Te iff (a) s is in T '; (b) there is a transition e (qb, .rst(s)) . d such that qb ./e; \nand (c) either s . Q8 or there is a transition (last(s), qf ) . d such that qf ./e. Let T be a set of \nSegmentSets de.ned by {Te | e is an equivalence class of }. Example 8. Consider again the system S1 in \nFigure 2, and the equivalence relation on its states given by the dashed shapes in Figure 3. The SegmentSets \nwe get from the equivalence classes are given by the nodes T1 and T2 in Figure 5. The set of these SegmentSets \nis T . As calculated in Example 6, the value for the abstract system (for the limit-average objective) \ngiven by PathBoundT 7 . Note that this is better (more precise) than is 43 the value given by the ExistMax \nabstraction de.ned by the same equivalence relation . As calculated in Example 1, the value given by \nExistMax is 10. Given an equivalence relation on states, the abstraction PathBoundT gives a better over-approximation \nfor limit-average objective than the ExistMax . Proposition 9. Let f be a (=p, )-monotonic quantitative \nprop\u00aderty. Let be an equivalence relation on Q and consider the (Spb pb two abstraction schemes PathBoundT \n= , f pb, aT ) and ExistMax = (Sem , f em , aem ) parameterized by . Then, for  (S)) = fem (aem all \nS . S (Q), fpb(apb (S)). T We observe that if 2 is a re.nement 1, then T 2 is a re\u00ad.nement T 1 . However, \nwe show an example system where the over-approximation computed using the T 2 abstraction is worse (less \nprecise) than the over-approximation computed using the T 1 . This means that, in general, PathBound \nis not a monotonic over\u00adapproximation for (=p, )-monotonic quantitative properties. Example 10. Consider \nthe system S2 in Figure 6. Consider an equivalence relation on states given by the dotted rectangle \nin the .gure (that is all states except the state I are equivalent to each other). This equivalence relation \nde.nes a set T1 of SegmentSets. The resulting abstract system apb T1 (S) is in Figure 7 (a). Note that \nin Figure 7 (a), the node for which the values of maxp, minp, etc. are given corresponds to the dotted \nrectangle in Figure 6, the other node in the abstract system corresponds to the singleton segment of \nlength one generated from the singleton equivalence class of the node I of system S2. Consider now a \nre.nement of where the equivalence class of the dotted rectangle is split into two equiva\u00adlence classes \ngiven by the dashed rectangles. The new equivalence relation de.nes a set T2 of SegmentSets. The abstract \nsystem in Fig\u00adure 7 (b) results from a re.nement where the equivalence class of the dotted rectangle \nis split into two equivalence classes given by the dashed rectangles. The resulting abstract system apb \nT2 (S) is in Figure 7 (b). Let us now assume that the abstract quantitative objective is pb limavg. \nThe value we get for system aT1 (S) is ((10\u00b75+4 \u00b71)/6) = 9. The value we get for its re.nement apb (S) \nis ((10 \u00b7 4 + 10 \u00b7 4 + T2   4 \u00b7 1)/9) = 84 > 9. This shows that the estimate is worse (less 9 precise) \nfor the re.nement apb (S) than for apb (S). T2 T1 4.3 Specialization of PathBound abstraction for the \nlimit-average quantitative property We presented a general de.nition of the PathBound abstraction which \nis an over-approximation for a large class of quantitative properties. We now specialize the PathBound \nabstraction for the limit-average property by introducing sound optimizations. We de.ne the limit-average \nPathBound-abstraction (de\u00adnoted by PathBoundLA) scheme as (Spba , f pba , apba T ). Spb apb Let S be \na system and let = T (S) = (Qpb, dpb, val, minp, maxp, hasInfPath, Q0 pb) be a PathBound abstraction \nof S. Furthermore, we .x f to be the limit-average property, i.e., ft = limavg and fs = sup for the remainder \nof this subsection. We have that Spba apba (Qpb , valpba = T (S) = , dpb , minp, maxp, hasInfPath) is \na pb-system similar to apb(S). In the PathBoundLA abstraction T scheme, we have the following differences: \n s.s valpba (T ) = max{sups.(T nQ*)Q(s) , sups.(T nQ8) limavg(s)}. Here, we let the value |sof| an abstract \nSegmentSet T be the supremum of the average weight of the segments in T , rather than the maximum weight \noccurring in T . Note that if T . Q8 , we have valpba (T ) = sup(limavg(e(T ))). The abstract quantitative \nproperty fpba is de.ned in the same way as fpb (at the beginning of Section 4), except that the de.nition \nof B : .(Sa) . 2R. we have that: n0 n1 w0 w1 . . . . B(.) if and only if . = T0T1 . . . with wi = valpba \n(Ti) . 0 < ni < 8 . ni . {minp(Ti), maxp(ti)}. n0 n1 8 w w . . . w . B(.) if and only if .0 = i = n : \n0 1 n wi = valpba (Ti) . (i < n =. 0 < ni < 8 . ni . {minp(Ti), maxp(ti)}).  The above differences between \nthe PathBoundLA and PathBound can be summarized as follows: (a) the value summa\u00adrization function for \neach SegmentSet can be average instead of maximum, and (b) more crucially (from a practical point of \nview), the evaluation of the abstract property on a pb-system can be done by considering only the lengths \nof the longest and shortest .nite paths of an SegmentSet, rather than considering all lengths between \nthem. This is because limit-average is a memoryless property. The following theorem states that PathBoundLA \nprovides a better approximations of the limit-average property than PathBound. Theorem 11. Given a system \nS and an segment cover T of .(S) and f being the limit-average property, we have pba pba pb pb f(S) = \nf (aT (S)) = f (aT (S)) Example 12. Consider again the system S1 from Figure 2, and the SegmentSets T1 \nand T2 from Figure 5. In PathBoundLA ab\u00adstraction, we have val(T1) = (10 + 1 + 4 + 3)/4 = 18/4 (while \nthe other values for T1 are as in Figure 5). For val(T2), we have val(T2) = (1 + 1 + 1)/3 = 1. The value \nof the system is fpba (aT (S1)) = (18 + 3)/7 = 3. Recall that for PathBound abstraction, the value fpb \nfor S1 was calculated in Example 6 to be 43 . For PathBoundLA abstraction, we thus get a better approxi\u00ad \n7 mation than in the PathBound abstraction. Evaluating limit-averages on pb-abstract systems. Minimum\u00admean \ncycle algorithms compute the limit-average value for a graph with weights on edges. Therefore, from a \npb-system, we construct a graph which has weights and lengths on edges, rather than nodes. Intuitively, \nwe consider the graph with edges of the pb-system being the nodes. There are two edges between the node \n(T1, T ) and (T, T2): one of weight maxp(T ) \u00d7 val(T ) and length maxp(T ), and another of weight minp(T \n) \u00d7 val(T ) and length minp(T ). The node (T1, T ) has the self-loop of weight val(T ) and length 1, \nif hasInfPath(T ) is true. We denote this graph by S . Howard s policy iteration was extended in [3] \nto compute the limit-average values in graphs where edges have both weight and length, as is the case \nof S . Howard s policy iteration works by picking a policy (that maps states to successors) and improves \nthe policy as long as possible. Each improvement takes linear time, but only an exponential upper-bound \nis known on the number of improvements required. However, a number of reports state that only linear \nnumber of improvements are required for most cases in practice [3]. 5. Generalizations of PathBound abstractions \nIn this section, we present two generalizations of the PathBound abstraction scheme. The .rst one generalizes \nPathBound by con\u00adsidering different summaries of SegmentSets rather than set of properties {minp, maxp, \nval, hasInfPath}. The second one gen\u00aderalizes PathBound by allowing inductive .xed-point style com\u00adputations \nof properties. 5.1 Generalized segment-based abstraction Let S be a WTS, and let T be a segment over \nof .(S). In the PathBoundLA abstraction from Section 4.3, we used the values of maxp, minp, hasInfPath, \nand valpba to abstract SegmentSets in T . The abstract values are in turn used to compute an over\u00adapproximation \nof the limit-average property for S. In this subsec\u00adtion, we provide a generic segment-based abstraction \nscheme for any set of properties. More speci.cally, let us assume that we have a set P of quan\u00adtitative \nproperties, a set T of SegmentSets that is a segment cover of a segment set T . We provide a generic \ntechnique to answer the following question: if we know the values of quantitative proper\u00adties in P on \nall SegmentSets in T , can we compute the values of quantitative properties in P on SegmentSet T ? We \nneed to extend notation in two ways: (a) We will use quan\u00adtitative properties f de.ned by ft and fs for \nboth .nite and in.nite traces. The type of ft will thus be R. . R* . R; and (b) We will evaluate quantitative \nproperties on a SegmentSet T (instead of a WTS) by letting f (T ) = fs({ft(e(p)) | p . T }). Fix an arbitrary \nWTS S = (Q, d, e, q.). Consider an arbitrary set of SegmentSets T = {T0, T1, . . . , Tn}, where all segments \nare sequences of states from Q. We de.ne the set of valid segments d generated by T as T = {s0 . . . \nsn | .j : sj . T ..j < n :  (last(sj ), .rst(sj+1)) . d}.{s0 . . . | .j : sj . T ..j = 0 : (last(sj \n), .rst(sj+1)) . d} where .rst(s) and last(s) denote d the .rst and last states of a segment. Intuitively, \nthe set T is the set of segments generated by T where the transition relation of the system S holds at \nthe sub-segment boundaries. Let T = {T1, . . . , Tn} be a cover of the SegmentSet T (not d necessarily \n.(S)). Note that T can be a proper subset of T , d d i.e., T . T , but T s T . We call the SegmentSet \nT n T the strengthening of the SegmentSet T by T and d. Our question thus becomes: provided that we know \nthe values of quantitative properties in P on all SegmentSets in T , can we compute the values of quantitative \nproperties in P on the strengthening of the d SegmentSet T by T and d, i.e. on T n T ? Abstract SegmentSet \nand property domains. Let (SEG, .) be the set of all SegmentSets partially ordered by the subset rela\u00adtion, \nand let (L, .) be a lattice. The lattice serves as an ab\u00adstract domain for describing SegmentSets. Elements \nof L can be for instance syntactical objects, such as formulas in a logic. Let .SEG (SEG, .) .---- (L, \n.) be a Galois connection (see [6]). We - ---. aSEG call the domain (L, .) the abstract SegmentSet domain \nand each element f . L an abstract SegmentSet. A property set P is a tuple ((f1 l , . . . fl ), (f1 u \n, . . . fu )) where n m (a) all fi l s are quantitative properties where fs = inf; and (b) all fi u \ns are quantitative properties where fs = sup. We de.ne the corresponding property domain DP = ((Rn \u00d7 \nRm), P ) l luu to be the abstract domain where ((a1, . . . , an), (a1 , . . . , an)) ((bl 1, . . . , \nbl 1 , . . . , bu i l = bl i and a u = bu n), (bu n)) if and only if all a i i . We write P(T ) for ((f1 \nl(T ), . . . , fn l (T )), (f1 u(T ), . . . , fn u(T ))). PLA Example 13. The property set = ((minp), \n(maxp, valpba , hasInfPath) is a property set. For example, minp(T ) = inf({|s| | s . T }) and hasInfPath(T \n) = sup({hasInfPath (s) | s . T }) where t hasInfPath (s) is 1 if |s| = 8 and 0 otherwise. t .P .--- \nIt is easy to see that a Galois connection (SEG, .) ---. aP (DP , P ) can be de.ned by letting aP (T \n) = P(T ) and .P (P ) = {T | P(T ) P }. Intuitively, ((l1, . . . , ln), (u1, . . . , un)) . P(T ) represents \nthe largest SegmentSet T that respects the lower and upper bounds placed by P , i.e., fi l(T ) = li .fj \nu(T ) = uj . We call DP the property bound domain and an individual P . DP a property bound. Let (L \u00d7 \nDP , =), where = is .\u00d7 P , be the product of (L, .) and (DP , P ). We call L \u00d7 DP the domain of abstract \nbound pairs and each element (written as f . P ) an abstract bound . --a pair. Let (SEG, .) .-.- (L \n\u00d7 DP , .\u00d7 P ) be a Galois connection naturally de.ned for the product of abstract domains, (aSEG .SEG \n where a(T ) = (T ), aP (T )), and .(f, P ) = (f) n .P (P ). Intuitively, the element f .P represents \na SegmentSet that is contained in f and respects the property bounds P . We identity abstract segments \nf . L with the abstract bound pair in f . T where T = ((-8, . . . , -8), (8, . . . , 8)), i.e., there \nare no bounds on any of the properties in P. Example 14. Let L = SEG, i.e., the abstract SegmentSets \nare the same as concrete SegmentSets. Note that this assumption is to simplify the example. It would \nbe more natural to use syntactical objects (e.g. formulas in some logic) for L. Consider DLA for P the \nproperty bound domain de.ned in Example 13. An example of an element in L \u00d7 DLA is T1 4 , 0)) where T1 \nP . ((4), (4, 18 is from Example 12. Here, ((4), (4, 18 , 0)) represent bounds on 4 values of properties \n((minp), (maxp, valpba , hasInfPath)). Note 18 that T1 . ((4), (4, 4 , 0)) contains exactly the same \ninformation that PathBoundLA stores about a SegmentSet. Evaluating quantitative properties on abstract \nSegmentSets. In what follows, we .x a WTS S, and a segment cover T = {T1, T2, . . . , T|T | } of T = \n.(S). Let K be the interval [1..|T |]. Given an abstract bound pair domain (L \u00d7 DP , \u00d7 P ), where f d \nis a property in P, we can perform the computation of f(T n T ) in the abstract domain. For this computation, \nthe abstract bound pair domain needs to support the following additional operations. Let f . P be an \nabstract bound pair, and F = {f1 . P1, . . . , f|T | . P|T | } be a set of abstract bound pairs. The \nabstract bound pairs domain (L \u00d7 DP , \u00d7 P ) is an inductive domain if it supports the following operations \nin addition to the standard lattice operations. Transition check. This operation checks for two abstract \nSegmentSets, whether a segment from the .rst can be validly followed by a segment from the second. Formally, \nTrCheck f(fi, fj ) is true if and only if there is validly gen\u00aderated segment s, i.e., s . .(f) n d{.(fi) \n| i . K}, where s ' sisj s '' s = such that (a) si . .(fi) . sj . .(fj ), and (b) s ' and s '' are also \nvalidly generated. Reduce Property Bounds. Given an abstract SegmentSet f, compute (an over-approximation) \nof the property bounds on f. Formally, ReduceBound (f) returns f . P * such that .(f . P * ) . .(f). \n Property computation. Given only the bounds Pi on ab\u00adstract SegmentSets fi and the values TrCheck f(fi, \nfj ), PropComp computes (an over-approximation) of the prop\u00aderty bounds on the abstract segment f . P \n. Formally, given dgpb = {(i, j) | TrCheck f(fi, fj ) = true}, and the values Pi for all i, the function \nPropComp (f, dgpb , (P1 . . . P|T | )) outputs f * . P * such that f * . P * = (f . T) . a( d{.(fi . \nPi) | i . K}). Note that we sometimes abuse the notation and write PropComp (f, {f1 . P1, . . . , f|T \n| . P|T | }) instead of PropComp (f, dgpb , (P1 . . . P|T | )i).  Example 15. Continuing from Example \n14, i.e., L = SEG and the system under consideration is S1 from Figure 5. TrCheck .(S)(T1, T2) can be \nas precise as the transi\u00ad dpba tion relation of PathBoundLA, i.e, (T1, T2) . . TrCheck .(S)(T1, T2). \nSuppose s1 . T1 and s2 . T2. We have that s1 can be followed by s2 if and only if (last(s1), .rst(s2)) \n. d. This is the condition that de.nes (T1, T2) . dpb . If we take ReduceBound (T2) to be precise (and \ncomputa\u00adtionally expensive) procedure that concretizes abstract states, it can return T2 . ((3), (4, \n1, 0)), i.e., it computes (an over\u00adapproximation) of the information stored for the particular SegmentSetT2. \n PropComp (.(S), {T1 . P1, T2 . P2}) (where P1 = ((4), (4, 18 , 0)) and P2 = ((3), (4, 1, 0))) computes \nan over\u00ad  4 approximation of P(.(S)) by computing on abstract states. If PropComp is de.ned using the \nsame approach as the B and fpba de.nitions from Section 4.3, it returns ((4), (8, 3, 1)). Here, valpba \n(.(S)) is 3, minp = 4, and maxp and hasInfPath are over-approximated to the largest possible val\u00ad ues. \n Remark 16. Note that in the arguments of PropComp, we do not require Pi to be equal to P(fi). In fact, \neven in the case where Pi is a P -over-approximation of P(fi), the procedure PropComp is required to \nproduce a valid P -over-approximation of the P value of .(f) n d{.(fi) | i . K}. We call an abstract \nbound pair domain effective if: (a) each of the operations ReduceBound , TrCheck , and PropComp can be \ncomputed effectively, i.e., by a terminating procedure; and (b) ReduceBound and PropComp are monotonic, \ni.e., giving more precise inputs produces more precise outputs. Formally, (a) f f ' =. ReduceBound (f) \n= ReduceBound (f ' ); f ' ' (b) (f . .i . K : Pi Pi . fi f ' i) =. PropComp (f, {f1 . P1, . . . , f|T \n| . P|T | }) = ' ' PropComp(f, {f1 . P1, . . . , f|T | . P|T | }); and (c) (f1 1 . P1 1 = f1 . P1) . \n(f2 1 . P1 2 = f1 . P1) =. PropComp (f, {f1 1 . P 1 1 , f2 1 . P1 2, f2 . P2, . . . , f|T | . P|T | }) \n= PropComp (f, {f1 . P1, f2 . P2, . . . , f|T | . P|T | }). We can now generalize PathBound abstraction \nscheme by let\u00adting the summaries of SegmentSets be the set of values of properties from any effectively \ninductive quantitative property set. Intuitively, given a WTS S, and a property set P, the PathBound[L \n\u00d7 DP ] abstraction stores with each SegmentSet T in the cover of .(S) the values aSEG (T ) . P (T ). \nTo compute the value of the abstract system, the procedures ReduceBound , TrCheck , and PropComp are \nused. Formally, PathBound[L \u00d7 DP ]T = (S[L \u00d7 DP ], a[L \u00d7 DP ]T , f [L \u00d7 DP ]) is de.ned as: a[L \u00d7 DP \n]T (S) = (f, (f1, . . . , f|T | ), dgpb ) where (a) f = aSEG aSEG (.(S)); (b) fi = (Ti); and (c) (i, \nj) . dgpb if and only if TrCheck f(fi, fj ) returns true. f[L \u00d7 DP ] is computed as the value of f in \nP * where f * * . P = PropComp (f, dgpb , (ReduceBound (f1), . . . , ReduceBound (f|T | ))) . ReduceBound \n(f). Precise abstractions. In the ExistMax case, if the abstraction function does not lose any information, \ni.e., if the equivalence relation used is the identity relation, the abstract system value is the same \nas the concrete system value. We give the conditions when an segment-based abstraction does not lose \nany information either. Intuitively, we want the property computation for a Seg\u00admentSet T from a cover \nT = {T1, . . . Tn} to be accurate when d T is exactly covered by T , i.e, T = T . An quantitative property \nset is precisely inductive if there ex\u00adists a PropComp procedure which produces the output (f, P(f)) \nwhen the following hold: (a) Pi = P(.(fi)), and (b) .(f) = d{.(fi) | i . K}. Example 17. The limit-average \nproperty is not precisely inductive, i.e., by knowing only the limit-average value of the subsegments \nof a segment, we cannot estimate the limit-average accurately without knowing the length of the subsegments. \nHowever, strengthening it to the property set ((minp), (maxp, limavg, hasInfPath)) makes it precisely \ninductive. 5.2 Hierarchical segment-based abstraction Effective abstract bound pair domains allow computation \nof prop\u00aderty bounds for a whole set of properties on a SegmentSet from the property bounds on each element \nof the cover. For example, if T covers T , the four properties minp, maxp, val, hasInfPath of SegmentSets \nin T are used to compute not only the limavg, but also the maxp, minp, and hasInfPath values of the SegmentSet \nT too. This leads to the possibility of computing these properties hi\u00aderarchically for a multi-level \ntrace segment cover. An inductive trace segment cover [7] C is a .nite rooted-tree where the nodes are \nlabelled with abstract bound pairs such that for every non-leaf node labelled with SegmentSet f . P , \nand f1 . P1, . . . , fn . Pn the set of labels of its children, {.(f1 . P1), . . . , .(fn .Pn)} is a \nsegment cover of .(f.P ). An inductive trace segment cover C inductively covers a SegmentSet T if T . \n.(root (C)). Similarly, C inductively covers a system S if .(S) . .(root(C)). We can now introduce an \nabstraction scheme HPathBound[L \u00d7 DP ]C = (Shpb[L \u00d7 DP ], ahpb[L \u00d7 DP ]C, f hpb[L \u00d7 DP ]) parameterized \nby an abstract bound pair domain L \u00d7 DP , and an abstract inductive trace segment cover C. Intuitively, \nHPathBound stores for each internal node a of C, a PathBound[L \u00d7 DP ]T (a) abstraction (label(a), T (a), \ndgpb ). The abstract trace segment cover T (a) for this abstraction is the labels of the set children \n(a). Abstract hierarchical traces. We .x an abstract bound pair domain L \u00d7 PD. An abstract hierarchical \ntrace . = ((f0 . P0)(f1 .P1) . . . , sub.) consists of (a) a .nite or in.nite sequence of abstract bound \npairs; and (b) a partial function subp from N to hierarchical traces. The concrete traces .(.) corresponding \nto a given abstract trace . = ((f0 .P0)(f1 .P1) . . . , sub.) are de.ned as {s0s1 . . . |.i : si . .(fi \n. Pi) . sub.(i) = . =. si . .(sub.(i))}. Intuitively, a concrete trace of an abstract hierarchical trace \n. is made of segments si from fi . Pi, with the additional condition that si . sub.(i) if sub.(i) is \nde.ned. Given a property set P, an effective abstract bound pair domain, and an inductive trace segment \ncover C of system S, we inductively compute property bounds (and hence, abstract system values) using \nAlgorithm 1. The algorithm is based on the inductive proof method presented in [7]. It can be rewritten \nas a .xed-point computation in Algorithm 1 Inductive Property Computation (InductiveCompute) Input: WTS \nS, Effective abstract bound pair domain L \u00d7 DP , Abstract Inductive Segment Cover C (labelled from L \n\u00d7 DP ), Output: abstract bound pair f * . P * such that (f * . P * ) = P(label(root(C))) 1: (f . P ) \n. label(root(C)) 2: if root(C) has no children then 3: return (f . P ) . (ReduceBound (f . P )) 4: else \n5: subT rees . top level sub-trees of C 6: return (f . P ) . PropComp (f . P, {I nductiveC ompute(C ' \n) | C ' . subT rees}) the lattice C . L \u00d7 DP of maps from nodes (C) to L \u00d7 DP (the lattice ordered point-wise \nby ( , P )). At the .nal line in Algo\u00adrithm 1, the value of C will be the least .xed-point of the function \nwhich replaces each node in C with a best approximation obtained from among the current value of the \nnode, and (a) ReduceBound applied on the node if it is a leaf node, or (b) PropComp applied on the node \nand its children if it is an internal node. Monotonicity. We de.ne re.nements of HPathBound abstrac\u00adtions \nusing re.nement steps. Let C be an inductive trace segment cover and let a be a non-root node in C, b \nbe its parent, C(a) be the sub-tree of C rooted at b, and f . P and fb . P b the labels of a and b. A \none-step re.nement of C is one of the following: Horizontal re.nement. Let f1 and f2 be such that .(f \n. P ) = .(f1 . P1) . .(f2 . P2). Let C(a)[label (a) . f1 . P1] and C(a)[label (a) . f2 . P2] be the tree \nC(a) with f . P replaced by f1 . P1 and f2 . P2, respectively. Let the tree C ' be obtained by detaching \nC(a) from p and then attaching C(a)[label (a) . f1 . P1] and C(a)[label (a) . f2 . P2] to p. Then C ' \nis a one-step horizontal re.nement of C. Vertical splitting re.nement. Suppose {.(f1 .P1), . . . .(fn \n. Pn)} cover f . P and that a does not have any children. Suppose C ' is obtained from C by adding the \nchildren with labels f1 .P1, . . . , fn .Pn to a. Then, C ' is a one-step vertical splitting re.nement \nof C.  Vertical joining re.nement. Suppose that b has no grandchil\u00addren, and let (fb . P b) = PropComp \n(f . P, children (b), d) and .c . children (b) : c) = ReduceBound (c)). If C ' is the tree obtained by \nremoving all the children of b in C, then C ' is a one-step vertical joining re.nement of C.  Downward \nstrengthening re.nement. Sup\u00adpose .(f ' ) . .(f) and fb . P b .  d {.(.) | . . ((children (b) \\ {f . \nP }) . {f ' . P ' })}. Let C ' be the tree obtained by replacing C(a) by f ' ' C(a)[label (a) . . P ]. \nThen, C ' is a one-step down\u00adward strengthening re.nement of C. Upward strengthening re.nement. Suppose \nthat f ' .P ' is such that d{.(.) | . . children (b)} . .(f ' .P ' ) . .(fb.P b). If C ' is obtained \nfrom C by replacing fb .P b with f ' .P ', then C ' is a one-step upward strengthening re.nement of C. \n A Cn is a re.nement of C0 if there exists a sequence C1, C2, . . . , Cn-1 such that Ci is a one-step \nre.nement of Ci-1 for all i such that n = i > 0. HPathBound[L \u00d7 DP ] is monotonic if for all systems \nS and abstract inductive trace segment covers C and C ' of S, if C ' is a re.nement of C, then abstract \nvalue fhpb[L \u00d7 DP ](ahpb[L \u00d7 DP ]CI(S)) = fhpb [L \u00d7 DP ](ahpb[L \u00d7 DP ]C(S)). Theorem 18. If f is a property \nsuch that fs = sup, and the inductive property set P contains f, and L \u00d7 DP is effectively inductive, \nHPathBound[L \u00d7 DP ] is monotonic for f. Intuitively, the theorem holds as every one-step re.nement pre\u00adserves \nthe information about the property-bounds of nodes from the previous iteration. For all one-step re.nements \nother than the ver\u00adtical joining re.nements, the monotonicity follows from the mono\u00adtonicity of PropComp \nand ReduceBound . For vertical splitting one-step re.nements, the monotonicity holds as all the information \nthat can be generated from the deleted children is already present in the parent node. 5.3 HPathBound \nabstractions for control-.ow graphs A control-.ow graph of a program written in a high-level language \nis contains many structures like loops and function calls. The traces of transition systems produced \nfrom such programs are structured. This opens the possibility of using hierarchical segment-based ab\u00adstractions \nto analyze them. Control-.ow graphs and Programs. Following, e.g., [4], we ab\u00adstract away from the syntax \nof a concrete programming language, and model programs as graphs whose nodes correspond to program locations. \nHere we assume simple programs with inlined function calls (this implies that there are no recursive \nfunctions). Let V be a set of variables and let D(V ) be the combined range of variables in V . A control-.ow \ngraph (CFG) is a tuple of (L, V, ., . : . . 2D(V )\u00d7D(V )) where L is a .nite set of control locations, \n. is a transition relation, V is a set of variables, and . is a function from . to assertions over program \nvariables V and their primed versions V '. The primed variables V ' refer to the values of the variables \nafter executing the transition. We assume that V contains a special variable wt ranging over R which \ndenotes the weight of a particular state.  Figure 9: An example CFG Given a CFG C, a corresponding \ntransition system can be gen\u00aderated (with state-space L \u00d7 D(V )) in a standard way. We add the weight \nfunction e(l, d) = w, where w is the value of the special variable wt in d, to turn the transition system \ninto a WTS. We assume the following about the CFG (these assumptions are valid for CFGs generated for \nprograms in most programming languages): (a) Reducibility. In the graph (L, .), every maximal strongly \nconnected component has a single entry and exit point, i.e., if G . L is a maximal strongly connected \ncomponent, there exists a node lG such that (l, l ' ) . . n ((L \\ G) \u00d7 G) =. l ' = lG . (l, l ' ) . . \nn (G \u00d7 (L \\ G)) =. l = lG; (b) Recursive reducibility. Suppose G . L is a maximal strongly connected \ncomponent. The graph (G, . n (G \u00d7 (G \\ {lG})) is also reducible. Intuitively, the above conditions imply \nthat loops in the CFG are single-entry and single-exit, and that they are nested. A hierarchical control-.ow \ngraph (HCFG) is a graph (H, . . H \u00d7 H, hi) while(true) where each node h . H is either a control\u00ad b = \nfalse; .ow location, or a hierarchical control-.ow j = 10; graph. We call the .rst kind of nodes, while \nj > 0 not abstract state nodes and the second kind of b = b; if b costlyOp; nodes subgraph nodes. j--Any \nrecursively reducible CFG C can k = 10; be converted into a HCFG H of a spe\u00ad while (k>0) k--cial form \nusing a standard algorithm on re\u00ad ducible graphs. In this special form, H and Figure 8: Prg all sub-HCFGs \noccurring in H have the fol\u00ad lowing property: either they are acyclic, or they have a single node with \na self-loop on itself. Note that each loop of a program will correspond to such sub-HCFG. In what fol\u00adlows, \nwe assume that all our HCFGs are of this special form. Example 19. Consider the example CFG shown in \nFigure 9 (gen\u00aderated from program in Figure 8). The equivalent HCFG of the special form to this CFG is \nshown in Figure 10. The statements on the transitions in Figure 10 are omitted for the sake of clarity. \nEach of the dotted boxes represent a HCFG. Intuitively, each loop has been separated out into an acyclic \nCFG containing the loop body and a single self-loop CFG. Inductive trace segment covers can be derived \nfrom HCFGs. In particular, every HCFG H represents a unique inductive trace segment cover C(H). Intuitively, \nthe root of the inductive trace segment cover is the set of all traces of H, and the children of the \nroot node are either (a) C(H ' ) if H ' is a subgraph node of H, and (b) {S} if S is a abstract state \nnode of H where {S} is the SegmentSet containing all segments of length 1 with states in S. From now \non, we use HCFGs and abstract inductive trace segment covers interchangeably. Example 20. Consider the \nprogram in Figure 8. Its CFG is in Fig\u00adure 9 and the corresponding HCFG is in Figure 10. We use regular \nexpressions over control locations as our abstract SegmentSet do\u00admain L. The regular expressions have \ntheir intuitive meaning. For example, (a) the expression s1s2 represents all segments q1q2 such that \nthe control location of q1 (resp. q2) is s1 (resp. s2); and (b) the expression (s1s2) * represents the \nset of segments obtained by con\u00adcatenation of segments from s1s2. The HCFG corresponds to the following \ninductive trace seg\u00adment cover C of the traces generated by the CFG. The root of C is the expression \nH = (s1s2s3(s4s5(s6 + s7)s3) * s8s9(s10s9) * ) * . Its only child is F = s1s2s3(s4s5(s6 + s7)s3) * s8s9(s10s9) \n* . The children of F are {CB , L1, CM , L2} where CB = s1s2s3, L1 = (s4s5(s6 + s7)s3) * , CM = s8s9, \nand L2 = (s10s9) *. Of these, only L1 and L2 are non-leaf nodes having one child each CL1 = s4s5(s6 + \ns7)s3 and CL2 = s10s9, respectively. Evaluating limavg for HPathBound abstractions induced by HCFGs. \nLet H be a HCFG of a special form. We compute the values maxp, minp, valpba , and hasInfPath using the \ntechnique of computing loop bounds. We consider a the domain of abstract bound pairs with elements of \nthe form f . P as before. Suppose H is a HCFG with a single node and a self-loop. Fur\u00adthermore, let f.P \nbe the corresponding abstract SegmentSet prop\u00aderty bound in C(H), and let {f1 .P1, . . . , fn .Pn} be \nits children. Let segment s be in .(f.P )n d{.(f1 . P1), . . . , .(fn . Pn)}. Let iters(s) . N where \nn . iters(s) if and only if there ex\u00adist s0, . . . , sn-1 such that .j < n..i : sj . .(fi . Pi). Let \n I ters(H) = iters(s) for all such s. We de.ne the upper loop bound (resp. lower loop bound), denoted \nby ulb(H) (resp. llb(H)) as the value sup I ters(H) (resp. inf I ters(H)). Note that there exists techniques \nto compute loop bounds using for example rela\u00adtional abstractions and ranking functions, see for example \n[10], and references therein. Now, given the values of maxp, minp, valpba , and hasInfPath of subgraphs \nof an HCFG H, we inductively compute the value of the properties for H as follows: If H is a single \nnode with no self-loop, i.e., an abstract state node, we have maxp(H) = minp(H) = 1, valpba (H) = e(H), \nand hasInfPath(H) = f alse.  If H is acyclic, we construct the following graph H as in Sec\u00adtion 4.3, \ni.e., edges of H correspond to nodes of H , and every node of H corresponds to two edges of weights (resp. \nlengths)  '' '' maxp(H ) \u00b7 valpba (H ) and maxp(H ) \u00b7 valpba (H ) (resp. maxp(H ' ) and minp(H ' )). \nNow, maxp(H) and minp(H) are equal to the length of the longest and shortest paths in H . Also, hasInfPath(H) \n= true if and only if there is a node H ' in H with hasInfPath(H ' ) = 1. The value valpba (H) can be \neval\u00aduated using Howard s policy iteration as in Section 4.3. If H is a single node with a self-loop, \nthere is only one subgraph of H (say H '). We have maxp(H) = ulb(H) \u00b7 '' ' maxp(H ), llb(H)\u00b7minp(H ), \nvalpba (H) = valpba (H ), and hasInfPath(H) = hasInfPath(H ' ) . ulb(H) = 8. Thus for such an HCFG, \nwe can evaluate the limit-average value by using the inductive evaluation scheme from Section 5.2, i.e., \nusing the values minp, maxp, valpba and hasInfPath, we can inductively compute the limit-average values \nfor an HCFG. Example 21. Consider the HCFG in Figure 10 and its induc\u00adtive cover C from Example 20. We \nwill illustrate a few steps of the inductive computation of the properties on C. Fix P = ((minp), (maxp, \nvalpba , hasInfPath)). Let us start for the leaves of C, i.e., CB = s1s2s3, CM = s8s9, CL1 = s4s5(s6 \n+ s7)s3, and CL2 = s10s9. Now, we can compute minp and maxp for these as the shortest and longest paths \nin the corresponding HCFGs. Furthermore, the hasInfPath values for each of these is 0 as all of these \nCFGs are acyclic. The valpba of CL2 CB  CM CL1 H L2 F Figure 10: HCFG of a program all the leaves \nexcept CL1 is 0 as the weights of all nodes except s7 are 0. For CL1, the valpba can be computed to be \n10 . Therefore, 4 ReduceBound (CB) = ((3), (3, 0, 0)), ReduceBound (CM ) = 10 ((2), (2, 0, 0)), P1 = \nReduceBound (CL1) = ((4), (4, 4 , 0)), and P2 = ReduceBound (CL2) = ((2), (2, 0, 0)). C * C * Now, the \nnodes L1 = L1 and L2 = L2 have the children {CL1} and {CL2} respectively. The PropComp procedure has \nto now compute the properties P(L1) using PL1. However, note that the domain L does not give methods \nto compute loop-bounds (see Example 22 for a re.nement of the domain L which can compute loop-bounds). \nTherefore, assuming ulb and llb for the loops are 0 and 8 respectively, we get the values P(L1) = PL1 \n= 10 ((0), (8, 4 , 1)) and P(L2) = PL2 = ((0), (8, 0, 1)). Proceeding similarly, we get the estimates \nfor P(F ) = PF = 10 10 ((5), (8, 4 , 1)) and P(H) = PH = ((0), (8, 4 , 1)). Intu\u00aditively, this corresponds \nto a counterexample that ends with an in\u00ad.nite loop in L1 that contains the costly operation. 6. Quantitative \nre.nements In this section, we present quantitative re.nement algorithms for the state-based and segment-based \nabstraction schemes. 6.1 Algorithmic Re.nement of ExistMax abstractions For the state-based abstraction \nscheme ExistMax, we give an algo\u00adrithm for counterexample-guided abstraction re.nement (CEGAR) for quantitative \nproperties. The algorithm is based on the classical CEGAR algorithm [2], which we extend to the quantitative \ncase. Here (as in [2]), we assume that the concrete system is .nite-state, and obtain a sound and complete \nalgorithm. In the in.nite-state case, the algorithm is sound, but incomplete. Let S = (Q, d, ., q.), \nlet f be a (=p, )-monotonic quantita\u00adtive property that admits memoryless extremal counterexamples (as \nstated in Section 2, we restrict ourselves to these properties), and let 1 be an equivalence relation \non Q. Let us further assume that Sa = (Qa, da, .a , q . a) is the result of applying the ExistMax ab\u00adstraction \nparameterized by 1 on S. Let .ext be the memoryless counterexample of Sa which realizes the value f(Sa). \nAlgorithm 2 is a re.nement procedure for ExistMax ab\u00adstractions. Its input consists of the concrete and \nabstract sys\u00adtems, the equivalence relation that parameterizes the abstrac\u00adtion, the quantitative property, \nand the extremal trace .ext . As the extremal counterexample is memoryless, it is of the shape H1 . . \n. Hk(Hk+1 . . . Hn).. The output of the algorithm is either a concrete counterexample (if one corresponding \nto .ext exists), or a re.ned equivalence relation (which can be used to produce a new abstract system). \n Let us consider a set of traces .(.ext ) of the system S that correspond to an abstract memoryless trace \n.ext = H1 . . . Hk(Hk+1 . . . Hn).. The .rst observation is that checking whether a concrete counterexample \nexists, i.e., whether .(.ext ) is non-empty, can be done by checking whether a .nite abstract trace .u \ncorresponds to a concrete trace. The .nite abstract trace .u can be obtained by unwinding the loop part \nof .ext m number of times, where m is the size of the smallest abstract state in the loop part of .ext \n, or formally, m . min{|Hi| | k + 1 = i = n} (line 1). This result can easily be adapted from [2] to \nthe quantitative case. Algorithm 2 Re.nement for ExistMax Input: WTS S = (Q, d, ., q.), quant. prop. \nf , eq. rel. 1, abstract WTS Sa = (Qa, da, .a , q . a), abstract counterexample .ext = H1 . . . Hk(Hk+1 \n. . . Hn). Output: re.ned eq. rel. 2 or a concrete counterex. tecx 1: m . min{|.(Hi)| | k + 1 = i = n} \n2: .u . unwind(.ext , m, k, n) {we have .u = G1 . . . Gk+(n-k)\u00b7m} 3: R1 . .(s1) n {q.} 4: i . 1 5: while \nRi = \u00d8 . i < (k + (n - k) \u00b7 m) do 6: Ri+1 . post(Ri, .a(Gi+1)) n .(Gi+1) 7: i . i + 1 8: if Ri-1 = \u00d8 \nthen 9: return counterEx(R0, . . . , Ri-1) 10: else ' '' 11: U . {s . .(Ri-1) | .s . .(Gi) : dS (s, s \n) . .(s ) = .a (Gi)} 12: return re.ne( 1,Gi-1,U) Lines 3 to 7 traverse the .nite abstract trace .u, \nand at each step maintain the set of states that are reachable form the initial state along a path corresponding \nto .u. (The post operator in line 6 takes as input a set of concrete states L and a weight w, and returns \nall the successors of states in L that have weight w.) If the traversal .nishes because at i-th step \nthe set Ri is empty, then the algorithm re.nes the equivalence relation 1 by splitting the equivalence \nclass given by Gi-1 into U and Gi-1 \\U (line 11). The set U contains those states that have a transition \n(correspond\u00ading to a transition in .u) to a state with weight .a(Gi). The inter\u00adsection U nRi-1 is empty, \nbecause Ri is empty. Thus separating U leads to eliminating the counterexample from the abstract system. \nIf the traversal .nishes a pass over the whole trace .u, it can construct a concrete counterexample using \nsets of states R0, . . . , Ri-1 (line 9). We have thus extended the classical CEGAR algorithm [2] to \nthe quantitative case. The extension is simple, the main difference is in taking into account the weights \nin lines 6 and 11. 6.2 Algorithmic Re.nement of HPathBound abstractions In this subsection, we describe \nan algorithmic technique for re.ne\u00adment of segment-based abstractions. We assume that the abstract bound \npair domain is precisely inductive. We assume that the extremal counter-example from the evalu\u00adation \nof a HPathBound abstraction is returned as a abstract hier\u00adarchical trace . = ((f0 . P0)(f1 . P1) . . \n. (fk . Pk)((fk+1 . Pk+1) . . . (fn . Pn))., sub.). Note that we can assume a lasso\u00adshaped counter-example \ndue to the memoryless property of the quantitative properties we consider. Furthermore, without loss \nof generality we also assume that every leaf in the abstract trace seg\u00adment cover is composed of segments \nof length 1. The basic structure of the re.nement algorithm is same as in ExistMax. However, the main \ndifference is in the post operator. For hierarchical traces, we de.ne a non-deterministic post opera\u00adtor \nin Algorithm 3. Intuitively, the algorithm non-deterministically chooses a level of the hierarchical \ntrace to perform the analysis. First, given a hierarchical trace of length 1, post operator com\u00adputes \n(Lines 3 and 4) the set .(f0 . P0) . d = {qs | s . .(f0 . P0) . (q, .rst(s)) . d}. Then, it computes \nthe top-level post set R * of states reachable from R using the segments from .(f0 . P0) . d. Now, non-deterministically \n(Line 5) it chooses whether to descend into the next level of the hierarchy. If it decides to, the set \nof post states R is computed from the levels below, and then the strengthening of R * by R , i.e., R \n* n R is returned. Assume that the post computation is done at a particular level, i.e., the level below \nis not used. Intuitively, this means that all the segments in f0 . P0 are assumed to be valid segments, \nand the property bounds are assumed to be tight, i.e., the part of the counter\u00adexample corresponding \nto f0 .P0 is considered non-spurious. Note that in the case where the algorithm always descends to the \nlowest level, the set returned is exactly the set of states reachable using segments in .(.) . d. We \nalso remark that nondeterminism in Algorithm 3 can be instantiated in a manner suitable for a particular \ndomain. Algorithm 3 Counterexample analysis for HPathBound Input: Hierarchical trace . = ((f0 . P0) . \n. . (fk . Pk), sub.), Concrete set of states R, Output: Over-approximation of states reachable through \nseg\u00adments in .(.). 1: if n > 1 then 2: return post((f1 . P1) . . . (fn . Pn), sub.), post((f0 . P0, sub.), \nR)) 3: T . .(f0 . P0) . d 4: R * . {q ' | .qsq ' . T : q . R} 5: if * then 6: if sub.(0) = . then 7: \nR . post(sub.(0), R) 8: else 9: R . R * 10: return (R * n R , R * , R ) Let C be the inductive trace \nsegment cover and let . = ((f0 . P0)(f1 .P1) . . . (fk .Pk)((fk+1 .Pk+1) . . . (fn .Pn))., sub.)be the \nextremal abstract trace. The abstraction re.nement proce\u00addure hAbsRe.ne (C, ., R0) proceeds similarly \nto Algorithm 2 as follows: The abstract hierarchical trace . is unwound m number of times, where m = \nmin{|.(fi . Pi)| | i . {k + 1, . . . , n}};  Let R0 be the set of concrete initial states. For each \nabstract SegmentSet property pair fi . Pi in the unwound trace, we compute (Ri+1, R * , R ) = post((fi \n. Pi, sub.), Ri);  If at any step Ri+1 = \u00d8, we re.ne the inductive trace segment cover C using set Ri \nand (fi, sub.) as hRe.ne (Ri, (fi, sub.)) (explained below). Otherwise, return any concrete counter\u00adexample \nconstructed from the set {R0, R1, . . .}. We describe the computation of hRe.ne (Ri, (fi . Pi, sub.)) \n when post((fi, sub.), Ri) = \u00d8: during the computation post((fi, sub.), Ri) (execution of Algorithm \n3) we have at least one of the following cases based on the values of R * and R . First, we de.ne TR \n= {s | .q . R(r, .rst(s)) . d . s . .(fi . Pi)} and T below R = {s | .r . R.(r, .rst(s)) . d . s . .(sub.(i))}. \nIntuitively, TR is the set of concrete segments from R in fi . Pi, and T below R is the set of concrete \nsegments from R generated from the hierarchical levels under fi . Pi. We have one of the following options: \n R * = \u00d8 . R = \u00d8. In this case, the re.nement returned is hAbsRe.ne (C, (sub.(i), sub.), R), i.e., we \nrun the abstrac\u00adtion re.nement procedure on the lower level, starting from the concrete set of states \nR.  R * = \u00d8. In this case, we perform a horizontal re.nement to separate the sets TR and T \\ TR, i.e., \nthe node labelled fi . Pi is split into fA .P A and fB .P B where .(fA .P A)..(fB . P B) = .(fi.Pi) and \nTR . .(fA.P A).TRn.(fB .PB) = \u00d8. Intuitively, we are separating segments in fi . Pi that are from R from \nthose that are not from R.  R * = \u00d8 . R * n R = \u00d8. In this case, we perform multiple simultaneous re.nements. \nThe segment sets which need to be distinguished from each other are T \\ (TR . TR below), TR and  T below \nR . Intuitively, we are trying to separate the segments in .(fi .Pi) that (a) do not start from R (i.e., \nT \\(TR .TR below)), (b) those that start from R and are validly generated from the levels below (i.e., \nTR below); and (c) those that do start from R and are not validly generated from the levels below (i.e., \nTR). Formally, let fA . P A , fB . P B, and fC . P C be such that:  T . .(fA . P A) . .(fB . P B) . \n.(fC . P C ); TR . .(fA . P A) . T below R n .(fA . P A) = \u00d8; T below R . .(fB . P B) . TR n .(fB . P \nB ) = \u00d8; and (TR . T below R ) n .(fC . P C ) = \u00d8. First, we do a horizontal re.nement splitting the \nnode fi . Pi into fA . P A , fB . P B, and fC . P C . Second, in the subtree rooted at fA . P A, the \nlevels below contains the information that TR is infeasible, but the root does not. So, we perform up\u00adward \nstrengthening re.nements till the root contains the same information. Third, in the subtree rooted at \nfB . P B, the root contains the information that TR below is infeasible, but the levels below do not. \nSo, we perform either (a) downward strengthen\u00ading re.nements till the levels below contain the same informa\u00adtion; \nor (b) vertical joining re.nements till there are no levels below. Note that if one of fA . P A , fB \n. P B, or fB . P B is empty, we omit it. Example 22. Consider the HCFG H and the corresponding ab\u00adstract \ntrace segment cover C from Example 21. We now show some examples of hierarchical counter-example guided \nre.nements for computing the limit-average value. We work in a more powerful re.ned domain than in Example \n21, one that allows computation of loop bounds. Let L be the domain of regular expressions over H C F \nG s along with a relation between the values of the variables in the initial and .nal states. For exam\u00adple, \nthe expression ((s4s5(s6 + s7)s3, b ' = \u00acb) represents the set of segments which match s4s5(s6 + s7)s3 \nand have the value of b is the last state is negation of the value of b in the .rst state. Let us .rst \nstart with abstract trace segment cover C from 21. A part of the abstract extremal trace generated from \nC will be (L1, sub) where (a) sub(1) = ((CL1)., sub ' ), where (b) sub ' (i) = s4s5s7s3 for all i = 1. \nWe will illustrate two re\u00ad.nement steps that might occur: Suppose during the re.nement process we are \ncomputing post((L1, sub ' ), R) where R is the set of states at location s3 with j = 0. Now, we can perform \nthe analysis either at the top level or at the lower level: At the top level, we get the post states \nto be R * where the control location of a state is in s3. At the lower level, we get the post states \nto be R = \u00d8 as the transition from s3 to s4 is disabled due to j being 0. Therefore, we need to re.ne \nthe abstract SegmentSet s4s5(s6 + s7)s3. One possible valid re.nement is to strengthen the set s4s5(s6 \n+ s7)s3 to s4s5(s6 + s7)s3, j > 0 . j ' = j - 1. Using this strengthened set, we can compute that the \nupper and lower loop bounds for L1 are 10. This leads to a improvement in the value of the system as \nnow, there is no in.nite path in the high value segment L1. The new value of the system is 20 .  9 Suppose \nduring the re.nement process we are computing post((L1 . P, sub ' ), R) where P bounds the limit-average \n10 of segments in L1 to 4 , R is the set of states at location s3 with b = true. Again, performing the \nanalysis at top level produces R * = {s7}, but the lower level produces R where R = \u00d8. Therefore, we \ncan to re.ne the abstract Seg\u00admentSet s4s5(s6 + s7)s3 and one possible re.nement is a horizontal split \ninto s4s5s6s3, b = true . b ' = f alse and s4s5s7s3, b = f alse . b ' = true. Performing this re.nement \nreduces the value of L1 to 20 and hence, by upward strength\u00ad 9 ening the value of the whole system to \n20 . 9 7. Case study: WCET analysis We present a case study to demonstrate anytime veri.cation, and \nto evaluate ExistMax and hierarchical PathBound abstractions. Worst-case execution time (WCET) estimation \nis an important part of verifying real-time systems. We only study one aspect, i.e., cache behavior prediction. \nIn a processor, clock cycles needed for an in\u00adstruction can vary by factors of 10-100 based on cache \nhits vs misses. Assuming the worst-case for all instructions leads to bad WCET estimates. Abstract domains \nfor cache behavior prediction are well studied (e.g., [9, 18]). However, we know of no work on au\u00adtomated \nre.nement for these abstractions. Note that this case study and the accompanying implementation is not \na complete WCET analysis tool, but a prototype used to illustrate the quantitative ab\u00adstraction re.nement \napproach. Our intention is just to evaluate the anytime aspect of our approach. We estimate WCET using \nthe limit-average property. Intu\u00aditively, we put the whole program in a nonterminating loop. The limit-average \nthen corresponds to the average cost of an instruction in the worst-case execution of a loop. (For a \nterminating program, it is the execution of the arti.cial outer loop.) WCET is estimated by multiplying \nthe limit-average values with (an over-approximation of) the length of the longest trace. We report limit-average \nvalues instead of WCETs. The cache model and the abstract domain used are from [9]. Multiple abstract \ndomains are possible based on the tracked loca\u00adtions. If no set is tracked, every memory access is deemed \na cache\u00admiss; whereas the invariant computation is very expensive in the domain which tracks all cache-sets. \nHere, we start from the empty cache and re.ne by tracking more cache-sets as necessary. 7.1 Implementation \ndetails We implemented a WCET analyzer based on the presented tech\u00adniques in a tool QUART that analyzes \nx86 binaries. Static analysis. We analyze the binary and produce the control .ow graph. Instructions \nin the program may operate on non-constant addresses (for example, array indexing leads to variable offsets \nfrom a .xed address). However, if the exact addresses cannot be computed statically, we perform no further \nanalysis and assume that the memory access is a cache miss. This restriction comes from the cache abstract \ndomain we use from [9]. Worst-case computation. In the resulting graph, we annotate states with invariants \nfrom the current cache abstract domain. From the invariants, we compute costs of each transition (we \nuse costs of 1 and 25 cycles for cache-hits and cache-misses, respectively). We then .nd the worst-case \nusing techniques of Section 3 and Sec\u00adtion 4.3 to .nd a the worst-case limit-average value. Furthermore, \nwe implemented the extension of the algorithm to graphs with both edge weights and edge lengths [3]. \nRe.nement. We analyze worst-case counter-example ext: Feasibility analysis. We .rst check if ext is a \nvalid program ex- Exam\u00adple Step Value Time (ms) Tracked 0 14.14 1240 Basic Example 1 2 3 6.50 4.87 4.75 \n2102 2675 3275 i a b 4 1.27 3864 c 5 1.03 4631 v 0 15.77 908 1 11.15 1130 m 2 8.23 1369 r Binary 3 5.0 \n1707 l search 4 3.76 1895 s 5 3.0 2211 a[ (N-1) 2 ] 6 2.97 2527 a[ (N-3) 4 ] 7 2.85 3071 a[ (3N-1) 4 \n] 0 15.49 524 Poly\u00ad 1 8.13 759 i nomial 2 4.45 1025 val Eval. 3 2.95 1237 x 0 13.76 289 GCD 1 9.47 399 \ninp2 2 6.65 472 inp1 3 6.33 536 temp Table 1: ExistMax abstraction results ecution (ignoring the cache) \nusing a custom symbolic execution computation. If ext is not a valid execution, we re.ne the abstract \ngraph using standard CEGAR techniques. Cache Analysis. If ext is valid, we compute the concrete cache \nstates for it. If the concrete value obtained is the same as that of ext, we return the concrete trace. \nRe.nement heuristic. Otherwise, of all locations accessed in the loop of ext, we .nd the one with most \nabstract cache misses which are concrete cache hits. The current cache abstract domain is re\u00ad.ned by \nadditionally tracking this location. Fall-back re.nement. If all the locations accessed in ext are al\u00adready \nbeing tracked, we use Algorithm 2 and the algorithm given by hAbsRe.ne to do the re.nement. 7.2 Evaluation \nof ExistMax abstraction For evaluating the ExistMax abstrac-while(true) tion and re.nement methods, we \nconsider input(s); binaries for .ve (small) C programs, in-l = 0; r = N -1; cluding the example from \nthe introduc-do { m = l + r / 2; tion (called Basic example in the table). if(s > a[m]) The results \nare in Table 1. For each ex\u00ad l = m + 1; ample program, the table contains lines, with each corresponding \nto a re.nement else r = m -1; step. For each re.nement step we report } while(l <= r the current estimate \nfor the limit-average . a[m] != s) value, the running time for the analy\u00adsis (cumulative; in milliseconds) \nand in Figure 11: Bin. case the re.nement enlarged the abstract Search cache, we also show what new \nmemory locations correspond to the entries in the abstract cache. In each case, the over-approximated \nlimit-average value decreases mono\u00adtonically as the tool is given more time. Binary search. We analyze \na procedure (Figure 11) that repeatedly performs binary search for different inputs on a given array. \nWe start with the empty abstract cache domain and all behaviors have high values (with worst-case value \n15.77). In the ext-trace, variable m, accessed 4 times every iteration of the inner loop, causes most \nspurious cache misses. Using the Re.nement heuristic we heuristically choose the loca\u00adtion of m is additionally \ntracked in the cache abstract domain reduc\u00ading the value to 11.15. Indices l, r and the input s are the \nnext most frequently used, and are added subsequently to the cache abstract domain. More importantly, \nthe most used array elements are added in order. During binary search, the element at position N/2 is \nac\u00adcessed always, and the elements at N/4 and 3N/4 half the times, and so on. The re.nements obtained \nadd these array elements in or\u00adder. This illustrates the anytime aspect: re.nement can be stopped at \nany point to obtain an over-approximation of the value.  7.3 Evaluation of the hierarchical PathBound \nabstraction For evaluating the PathBound abstraction re.nement procedure, we picked 4 benchmarks from \nthe collection of WCET bench\u00admarks in [11]. These benchmarks were larger than the ones for the ExistMax \nevaluation with around 150-400 lines of code each. The benchmarks we picked included a simple program \nwhich scanned a matrix and counted elements, matrix multi\u00adplication, and two versions of discrete-cosine \ntransformations. Bench mark Step Value Time (ms) cnt 0 3 4 8.74 8.64 4.08 1810 6349 8298 matmult 0 2 \n5 6 8.73 8.71 8.71 4.17 4669 15660 30408 35676 fdct 0 1 2 6.88 1.94 1.76 2142 4274 6685 jfdctint 0 1 \n2 3 6.95 3.35 1.89 1.57 3095 5759 8674 11809 We used the hier\u00adarchical PathBound abstraction\u00adre.nement \nalgorithm, i.e., the algorithm given by hRe.ne . We note that we do not perform any cache re.nements. \nNevertheless, the hierarchical as\u00adpect of hierarchical PathBound abstrac\u00adtion was evaluated, as three \nof the bench\u00admarks contained a number of nested loops. The challenge Table 2: PathBound abstraction re\u00adaddressed \nwas tosults obtain good (and monotonically decreasing) estimates on WCET, as the abstraction is re.ned. \nWe summarize the results in Table 2. For each example pro\u00adgram, the table contains a number of lines, \nwith each line corre\u00adsponding to a re.nement step. For each re.nement step we show the current estimate \nfor the limit-average value, and the running time for the analysis (cumulative; in milliseconds). As \nit can be seen, the limit-average values monotonically decrease with longer execution time. It should \nbe noted that for most of these programs, to obtain similar values with the ExistMax approach, one would \nneed to perform a large number (in thousands) of counter-example guided re.nements (as the nested loops \nwould have to be unrolled). 8. Conclusion Summary. This paper makes four main contributions. First, we \npresent a general framework for abstraction and re.nement with respect to quantitative system properties. \nRe.nements for quanti\u00adtative abstractions have not been studied before.Second, we pro\u00adpose both state-based \nand segment-based quantitative abstrac\u00adtion schemes. Quantitative segment-based abstractions are entirely \nnovel, to the best of our knowledge. Third, we present algorithms for the automated re.nement of quantitative \nabstractions, achiev\u00ading the monotonic over-approximation property that enables any\u00adtime veri.cation. \nFourth, we implement re.nement algorithms for WCET analysis of executables, in order to demonstrate the \nanytime veri.cation property of our analysis, and to investigate trade-offs between the proposed abstractions. \nFuture work. There are several directions for future work. The .rst is to perform larger-scale case studies, \nfor instance for worst-case execution time analysis, with more realistic architecture models. Second, \nquantitative abstraction can aid partial-program synthesis, as quantitative reasoning is necessary if \nthe goal is not to synthe\u00adsize any program, but rather the best performing program according to quantitative \nmeasures such as performance or robustness. Fur\u00adthermore, the anytime veri.cation property of the re.nements \nwe proposed can lead to anytime synthesis methods, that is, methods that would synthesize correct programs, \nand re.ne these into more optimized versions if given more time. References [1] M. Boddy. Anytime problem \nsolving using dynamic programming. In AAAI, pages 738 743, 1991. [2] E. Clarke, O. Grumberg, S. Jha, \nY. Lu, and H. Veith. Counterexample\u00adguided abstraction re.nement for symbolic model checking. J. ACM, \n50(5):752 794, 2003. [3] J. Cochet-Terrasson, G. Cohen, S. Gaubert, M. McGettrick, and J.- P. Quadrat. \nNumerical computation of spectral elements in max-plus algebra, 1998. [4] B. Cook, A. Podelski, and A. \nRybalchenko. Abstraction re.nement for termination. In SAS, pages 87 101, 2005. [5] P. Cousot and R. \nCousot. Abstract interpretation: A uni.ed lattice model for static analysis of programs by construction \nor approxima\u00adtion of .xpoints. In POPL, pages 238 252, 1977. [6] P. Cousot and R. Cousot. Systematic \ndesign of program analysis frameworks. In POPL, pages 269 282, 1979. [7] P. Cousot and R. Cousot. An \nabstract interpretation framework for termination. In POPL, pages 245 258, 2012. [8] L. de Alfaro and \nP. Roy. Magnifying-lens abstraction for Markov decision processes. In CAV, pages 325 338, 2007. [9] C. \nFerdinand, F. Martin, R. Wilhelm, and M. Alt. Cache behavior pre\u00addiction by abstract interpretation. \nSci. Comput. Program., 35(2):163 189, 1999. [10] S. Gulwani and F. Zuleger. The reachability-bound problem. \nIn PLDI, pages 292 304, 2010. [11] J. Gustafsson, A. Betts, A. Ermedahl, and B. Lisper. The m \u00a8alardalen \nWCET benchmarks: Past, present and future. In WCET, pages 136 146, 2010. [12] H. Hermanns, B. Wachter, \nand L. Zhang. Probabilistic CEGAR. In CAV, pages 162 175, 2008. [13] M. Kattenbelt, M. Kwiatkowska, G. \nNorman, and D. Parker. Abstrac\u00adtion re.nement for probabilistic software. In VMCAI, pages 182 197, 2009. \n[14] A. Podelski and A. Rybalchenko. Transition predicate abstraction and fair termination. In POPL, \npages 132 144, 2005. [15] A. Prantl, M. Schordan, and J. Knoop. TuBound -a conceptually new tool for \nworst-case execution time analysis. In WCET, 2008. [16] N. Shankar. A tool bus for anytime veri.cation. \nUsable Veri.cation, 2010. [17] V. Tiwari, S. Malik, and A. Wolfe. Power analysis of embedded software: \na .rst step towards software power minimization. In ICCAD, pages 384 390, 1994. [18] R. Wilhelm, S. Altmeyer, \nC. Burgui`ere, D. Grund, J. Herter, J. Reineke, B. Wachter, and S. Wilhelm. Static timing analysis for \nhard real-time systems. In VMCAI, pages 3 22, 2010. [19] R. Wilhelm, J. Engblom, A. Ermedahl, N. Holsti, \nS. Thesing, D. Whal\u00adley, G. Bernat, C. Ferdinand, R. Heckmann, T. Mitra, F. Mueller, I. Puaut, P. Puschner, \nJ. Staschulat, and P. Stenstr \u00a8om. The worst-case execution-time problem -overview of methods and survey \nof tools. ACM Trans. Embedded Comput. Syst., 7(3), 2008.    \n\t\t\t", "proc_id": "2429069", "abstract": "<p>We propose a general framework for abstraction with respect to quantitative properties, such as worst-case execution time, or power consumption. Our framework provides a systematic way for counter-example guided abstraction refinement for quantitative properties. The salient aspect of the framework is that it allows anytime verification, that is, verification algorithms that can be stopped at any time (for example, due to exhaustion of memory), and report approximations that improve monotonically when the algorithms are given more time.</p> <p>We instantiate the framework with a number of quantitative abstractions and refinement schemes, which differ in terms of how much quantitative information they keep from the original system. We introduce both state-based and trace-based quantitative abstractions, and we describe conditions that define classes of quantitative properties for which the abstractions provide over-approximations. We give algorithms for evaluating the quantitative properties on the abstract systems. We present algorithms for counter-example based refinements for quantitative properties for both state-based and segment-based abstractions. We perform a case study on worst-case execution time of executables to evaluate the anytime verification aspect and the quantitative abstractions we proposed.</p>", "authors": [{"name": "Pavol Cerny", "author_profile_id": "81392617758", "affiliation": "IST Austria, Klosterneuburg, Austria", "person_id": "P3977931", "email_address": "pavol.cerny@ist.ac.at", "orcid_id": ""}, {"name": "Thomas A. Henzinger", "author_profile_id": "81100034124", "affiliation": "IST Austria, Klosterneuburg, Austria", "person_id": "P3977932", "email_address": "tah@ist.ac.at", "orcid_id": ""}, {"name": "Arjun Radhakrishna", "author_profile_id": "81472655351", "affiliation": "IST Austria, Klosterneuburg, Austria", "person_id": "P3977933", "email_address": "aradha@ist.ac.at", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429085", "year": "2013", "article_id": "2429085", "conference": "POPL", "title": "Quantitative abstraction refinement", "url": "http://dl.acm.org/citation.cfm?id=2429085"}