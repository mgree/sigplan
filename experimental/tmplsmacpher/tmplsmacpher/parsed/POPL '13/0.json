{"article_publication_date": "01-23-2013", "fulltext": "\n Engineering Mathematics: The Odd Order Theorem Proof Georges Gonthier Microsoft Research Cambridge 7 \nJJ Thomson avenue Camdridge, UK CB3 0FB gonthier@microsoft.com Abstract Even with the assistance of computer \ntools, the formalized de\u00adscription and verification of research-level mathematics remains a daunting \ntask, not least because of the talent with which mathema\u00adticians combine diverse theories to achieve \ntheir ends. By combin\u00ading tools and techniques from type theory, language design, and software engineering \nwe have managed to capture enough of these practices to formalize the proof of the Odd Order theorem, \na landmark result in Group Theory. Categories and Subject Descriptors F.4.1 [MATHEMATICAL LOGIC AND FORMAL \nLANGUAGES]: Mathematical Logic Mechanical theorem proving. J.2 [PHYSICAL SCIENCES AND ENGINEERING] \nMathematics and statistics. Keywords theorem proving; proof engineering; group theory; mathematical components; \nCoq; ssreflect. 1. The Challenge of Computer Mathematics This past year we were reminded that the killer \napp that led Alan Turing to the invention of Computer Science was the com\u00adpletely formal verification \nof mathematical theories and proofs. Yet while computation with mechanical contraptions has found useful \napplications in nearly every human activity, this original goal has remained elusive. Even with the latest \ncomputer proof systems, which have become very good at the verification of code and POPL papers, dealing \nwith the proofs produced by working mathematicians can be most painful. My experience with the formalization \nof the four-color theo\u00adrem in 2001-5 indicated that the problem might not be a lack of automation, as \nis often believed, but a lack of expressiveness of the tools and methods used to describe mathematics. \nEven though the four-color proof uses only the most elementary combinatorics, its formalization had required \nnew ways of organizing and writing theories and proofs but hardly any general-purpose proof\u00adfinding \nautomation. This suggested that language and software engineering tech\u00adniques could perhaps be applied \nsuccessfully to mainstream math\u00adematics. In 2006 I founded the Mathematical Components project at the \nMicrosoft Research Inria Joint Center to test this thesis, by developing a comprehensive formal algebra \nusing the Coq system. The aim was to cover most of a math undergrad syllabus, and the work was to be \ndriven and validated by the formalization of a famously difficult and important result in Group Theory, \nFeit and Thompson s Odd Order theorem. In September 2012, we finally prevailed. Copyright is held by \nthe author/owner(s). POPL 13, January 23 25, 2013, Rome, Italy. ACM 978-1-4503-1832-7/13/01.  2. The \nOdd Order Theorem Feit and Thompson s seminal 1963 paper began with the decep\u00adtively short statement \nTHEOREM. All finite groups of odd order are solvable. The 255 pages that followed exposed the most difficult \nand com\u00adplex group theory proof of its time, drawing on most of elemen\u00adtary results in algebra (including \nmatrices, polynomials, normed vector spaces, modules, algebraic number theory, and Galois theory), and \nadvanced results in group theory (such as the Schur-Zassenhaus and Hall-Higman theorem, or the theory \nof excep\u00adtional characters). The ground-breaking paper introduced several novel techniques that would \nlater play a key role in the full classi\u00adfication of finite simple groups (e.g., Thompson transitivity, \ntame\u00adly imbedded subsets, and signalizer functors). Its result has appli\u00adcations throughout group theory, \nand can be seen as the starting point of the classification itself. Yet it was considered a very difficult \npaper to read, before a revision in 1994 and 2000 simpli\u00adfied and filled several gaps in the exposition. \nAll of this made the Odd Order proof the perfect test for a mathematical formalization project. Even \nthe expanded statement of the theorem is short, because it only involves two definitions: DEFINITION. \nH is a normal subgroup of a group G iff H is the kernel of a homomorphism from G to a factor group G \n/ H: one can compute mod H in G. This is written H . G. DEFINITION. A group G is solvable if there is \na normal series 1 = H0 . H1 . .. Hn = G.such that each factor Hi+1 / Hi is abelian. Indeed, a full formalization \nof the statement from basic logic (including the necessary arithmetic and combinatorics) takes only two \npages. Note that any finite group has a maximal normal series whose factors are all simple groups (this \nis why the classification is so important); for solvable groups these factors will all be prime cyclic \ngroups. Also, solvable groups are tied to the resolu\u00adtion of polynomial equations, the motivating application \nof group theory. The Feit-Thompson proof is just as complex as the Odd Order statement is simple; it \nproceeds by studying a minimal counter\u00adexample G, gradually refining its structure until a contradiction \nis reached. This study consists of three unequal parts: Local Analysis One studies the proper subgroups \nof G, which are all solvable by assumption. Using finite representation theory (matrices with coefficients \nin a finite field) one shows that their intersection has rank at most 2; in turn this implies that most \nof these groups closely resemble Frobenius groups, with two possible exceptions, similar to a finite \nfield with its Galois group.  Character Theory One uses character theory (traces of ma\u00adtrices with complex \ncoefficients) to extract information about G from the description of its subgroups. This is possible \nbecause characters have a Euclidean geometry, and there are isometries mapping certain subgroup characters \nto characters of G. The global norm inequalities imply that subgroups are exactly Froben\u00adius, and that \nthe two Galois exceptions occur exactly as well. Generators and relations Using fiendish explicit calcula\u00adtions \nexploiting the relations between the finite fields embedded in G, one constructs a polynomial of degree \nq with p > q roots in a field of order pq; at last, contradiction! The revised proof of the first part, \nby Bender and Glauber\u00adman, spans the 140 pages of volume 188 of the LMS series; the second part, by Peterflavi, \nspans 100 pages of volume 272, while the last is a mere 8-page appendix in volume 188. The prerequi\u00adsites \nrepresent about twice that amount, from a variety of sources. The Coq formalization of the 1300 lemmas \nof the proof spans 47,000 LOC (out of 170,000 for the full archive).  3. Mathematical Components The \nbasic premise of project was that formalized theories would be more useful if they could be composed \nmore freely, and that this could be achieved by replacing the rigid 19th century first order logic with \nCiC, the more modern dynamic higher-order logic supported by the Coq system. First order logic imposes \nan exact fit, at the symbol level, between the statement of the as\u00adsumptions of a proof step and the \nfacts that fulfil them. In CiC, parts of a statement can be executable, and matching is performed up \nto (functional) evaluation. Thus in principle it is possible to formulate theories so that they behave \nmore like software compo\u00adnents that automatically generate glue code to facilitate interop\u00aderability, \nrather than simple procedures that only work for a fixed data representation. Our challenge was to understand \nhow this could be made useful in practice. We realized early on that this flexibility was even more crucial \nfor stating theorems than for proving them. Mathematical notation is cleverly honed to provide exactly \nthe information needed to determine a mathematical object in a given context. Much of it makes little \nsense in the rigid, context-independent setting of first\u00adorder logic. For instance the factor group G \n/ H we saw earlier depends on the multiplication operator used in G and H. This must be determined by \nthe context, if we are to support the common practice of computing and equating G and H as sets, as in \nthe statement of the isomorphism theorem GH / H . G / (G n H); the other isomorphism theorem (G / K) \n/ (H / K) . G / H, where the / s refer to three different multiplications, shows that context must be \nunderstood locally. The solution to this overloading problem is the familiar ob\u00adject paradigm, specifically \nits functional programming equiva\u00adlent, type classes. In fact in Coq type classes are significantly more \npowerful than in traditional functional programming, be\u00adcause they have an internal representation in \nthe CiC logic as type-containing records. Instance inference is an integral part of type inference; it \namounts to inverting projections of class records during higher-order unification, using a set of canonical \ninstances declared by the user. It can supply both operations an properties, and be based both on types \nand data values. A single expression can exploit several type classes; for example in G / H a finite \ngroup type class is used to determine which multiplication is involved and to ensure that the definition \nis constructive, and a group class is used to ascertain that resulting set is actually a group (as long \nas G is). In addition to supporting the traditional algebraic hierarchy of rings, vector spaces, fields, \nalgebras, etc. our type classes can also recognize groups, sesquilinear functions, AC operators, subfields \nand even direct sums of subspaces. The extended type inference substantially helps the formalization \nprocess: it is not uncommon that a single line of LaTeX-like notation hides two pages of in\u00adferred annotations, \nand when we introduced the group class nearly half of our proof scripts vanished into type inference. \n 4. Big Theories, Big Theorems, Big Proofs Software engineering techniques, albeit more mundane ones, \nare also instrumental in coping with the sheer size of the prerequisite theories. Ensuring that the 4200 \ndefinitions and 15,000 lemmas and theorems remain accessible requires a triple combination of namespace \nmanagement (across modules), rational naming con\u00adventions (within modules), and effective search tools \n(in the IDE). The distribution of formal proof lines is a close fit to a power (Pareto) law. This is \na heavy-tailed distribution, which means that while most lemmas will have a very short proof (two lines \nor less), most proof lines will occur in the proof of large theorems, and that such proofs will get very \nlarge indeed. Thus the formal\u00adization of the Odd Order theorem accounts for 10% of the theo\u00adrems, but \n30% of the script lines, and includes a 1,200 line proof (for Theorem (9.11) in the character theory \nrevised proof). We also observed the need for large theorem statements: it is preferable to have one \nlarge theorem that collects all the facts about a given situation (e.g., the structure of an extremal \np-group), rather than a plethora of factoids whose applicability must be justified separately. Our proof \nscripting language, implemented by the ssreflect Coq plugin, efficiently supports extracting a relevant \nfact subset from such a theorem. In order to handle the big proofs, our scripting language helps enforcing \nexplicit control and data flow. The latter also turned out to be an invaluable tool for mining the logical \nstructure of a proof, uncovering in several cases major simplifications. Finally, we identified several \nformal proof structures that can\u00adnot be expressed easily with the traditional assertion, case analysis \nand induction constructs. A general without loss of generality construct, was invaluable in capturing \nintricate symmetry argu\u00adments. A small library for three-way inequalities proved indispen\u00adsable for formulating \nconcisely circular inequalities.  Acknowledgments The work described here was done in collaboration \nwith the members and visitors of the Mathematical Components project: A. Asperti, J. Avigad, Y. Bertot, \nC. Cohen, F. Garillot, S. Le Roux, S. McLaughlin, A. Mahboubi, S. Ould Biha, R. O Connor, L .Rideau, \nA. Solovyev, E. Tassi, and L. Th\u00e9ry.  \n\t\t\t", "proc_id": "2429069", "abstract": "<p>Even with the assistance of computer tools, the formalized de-scription and verification of research-level mathematics remains a daunting task, not least because of the talent with which mathema-ticians combine diverse theories to achieve their ends. By combin-ing tools and techniques from type theory, language design, and software engineering we have managed to capture enough of these practices to formalize the proof of the Odd Order theorem, a landmark result in Group Theory.</p>", "authors": [{"name": "Georges Gonthier", "author_profile_id": "82658771157", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P3977903", "email_address": "gonthier@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429071", "year": "2013", "article_id": "2429071", "conference": "POPL", "title": "Engineering mathematics: the odd order theorem proof", "url": "http://dl.acm.org/citation.cfm?id=2429071"}