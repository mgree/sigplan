{"article_publication_date": "01-23-2013", "fulltext": "\n On the Linear Ranking Problem for Integer Linear-Constraint Loops Amir M. Ben-Amram Samir Genaim The \nTel-Aviv Academic College Complutense University of Madrid amirben@mta.ac.il samir.genaim@fdi.ucm.es \nAbstract In this paper we study the complexity of the Linear Ranking prob\u00adlem: given a loop, described \nby linear constraints over a .nite set of integer variables, is there a linear ranking function for this \nloop? While existence of such a function implies termination, this prob\u00adlem is not equivalent to termination. \nWhen the variables range over the rationals or reals, the Linear Ranking problem is known to be PTIME \ndecidable. However, when they range over the integers, whether for single-path or multipath loops, the \ncomplexity of the Linear Ranking problem has not yet been determined. We show that it is coNP-complete. \nHowever, we point out some special cases of importance of PTIME complexity. We also present complete \nalgo\u00adrithms for synthesizing linear ranking functions, both for the gen\u00aderal case and the special PTIME \ncases. Categories and Subject Descriptors F.2.0 [Analysis of Algo\u00adrithms and Problem Complexity]: General; \nF.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs General \nTerms Veri.cation, Theory. Keywords Ranking Functions, Termination, Linear Constraints. 1. Introduction \nTermination analysis has received a considerable attention and nowadays several powerful tools for the \nautomatic termination analysis of different programming languages and computational models exist [1, \n21, 27, 43]. Much of the recent development in termination analysis has bene.ted from techniques that \ndeal with one loop at a time, where a loop is speci.ed by a loop guard and a (non-iterative) loop body. \nVery often, these loops are abstracted so that the state of the program during the loop is represented \nby a .nite set of integer variables, the loop guard is a conjunction of linear inequalities, and the \nbody modi.es the variables in an af.ne linear way, as in the following example: while (x2 - x1 = 0, x1 \n+ x2 = 1) do ''(1) x2 = x2 - 2x1 + 1, x1 = x1 where tagged variables represent the values at the completion \nof an iteration. When the variables are modi.ed so that they are not Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 13, January 23 25, 2012, Rome, Italy. \nCopyright c &#38;#169; 2013 ACM 978-1-4503-1832-7/13/01. . . $10.00 af.ne linear functions of the old \nones, the effect is sometimes cap\u00adtured (or approximated) by means of linear constraints. E.g., the C \nlanguage loop while (4*x>=y &#38;&#38; y>=1) do x=(2*x+1)/5; , which involves integer division, can be \nrepresented by linear con\u00adstraints as follows (since 2*x+1 is always positive) while (4x1 = x2, x2 = \n1) do ''' (2) - 2x1 + 5x1 = 1, 2x1 - 5x1 = 3, x 2 = x2 Linear constraints might also be used to model \nchanges to data structures, the variables representing a size abstraction such as length of lists, depth \nof trees, etc. [17, 34, 35, 43]. For a precise de.nition of the loop representations we consider, see \nSec. 2; they also include multipath loops where alternative paths in the loop body are represented. A \nstandard technique to prove the termination of a loop is to .nd a ranking function. Such a function maps \na program state (a valuation of the variables) into an element of some well-founded ordered set, such \nthat the value descends (in the appropriate or\u00adder) whenever the loop completes an iteration. Since descent \nin a well-founded set cannot be in.nite, this proves that the loop must terminate. This de.nition of \nranking function is very general; in practice, researchers have often limited themselves to a convenient \nand tractable form of ranking function, so that an algorithm to .nd the function if there is one might \nbe found. A frequently used class of ranking functions is based on af.ne linear functions. In this case, \nwe seek a function .(x1, . . . , xn) = a1x1 + \u00b7 \u00b7 \u00b7 + anxn + a0, with the rationals as a co-domain, such \nthat (i) .( \u00afx) = 0 for any valuation x\u00afthat satis.es the loop guard; ' and (ii) .( \u00afx) - .( \u00afx) = 1 \nfor any transition that starts in x\u00afand continues in x\u00af'. This automatically induces the piecewise-linear \nranking function: f( \u00afx) = .(\u00afx) + 1 if x\u00afsatis.es the loop guard and 0 otherwise, with the non-negative \nrationals as a co-domain but ordered w.r.t. a : b iff a + 1 = b (which is well-founded). For simplicity, \nwe call . itself a linear ranking function instead of referring to f. An algorithm to .nd a linear ranking \nfunction using linear pro\u00adgramming (LP) was found by multiple researchers in different places and times \nand in some alternative versions [3, 20, 25, 36, 38, 42]. Since LP has a polynomial time complexity, \nmost of these methods yield polynomial-time algorithms. Generally speak\u00ading, they are based on the fact \nthat LP can precisely decide whether a given inequality is implied by a set of other inequalities, and \ncan even be used to generate any implied inequality. After all, condi\u00adtions (i) and (ii) above are inequalities \nthat should be implied by the constraints that de.ne the loop guard and body. This approach can, in a \ncertain sense, be sound and complete Soundness means that it produces a correct linear ranking func\u00adtion, \nif it succeeds; completeness means that if a linear ranking function exists, it will succeed. In other \nwords, there are no false negatives. A completeness claim appears in some of the references, and we found \nit cited several times. In our opinion, it has cre\u00adated a false impression that the Linear Ranking problem \nfor linear\u00adconstraint loops with integer variables was completely solved (and happily classi.ed as polynomial \ntime).  The .y in the ointment is the fact that these solutions are only complete when the variables \nrange over the rationals, which means that the linear ranking function has to ful.ll its requirements \nfor any rational valuation of the variables that satis.es the loop guard. But this may lead to a false \nnegative if the variables are, in fact, integers. The reader may turn to the two loops above and note \nthat both of them do not terminate over the rationals at all (for the .rst, consider x1 = x2 = 1 2 ; \nfor the second, x1 = 1 4 and x2 = 1). But they have linear ranking functions valid for all integer valuations, \nwhich we derive in Sec. 3.4. This observation has led us to investigate the Linear Rank\u00ading problem for \nsingle-path and multipath linear constraint loops. We present several fundamental new results on this \nproblem. We have con.rmed that this problem is indeed harder in the integer setting, proving it to be \ncoNP-complete (as a decision problem), even for loops that only manipulate integers in a .nite range. \nOn a positive note, this shows that there is a complete solution, even if exponential-time. We give such \na solution both to the decision problem and to the synthesis problem. The crux of the coNP\u00adcompleteness \nproof, and the corresponding synthesis algorithm, is that we rely on the generator representation of \nthe transition poly\u00adhedron de.ned by the loop constraints. We provide suf.cient and necessary conditions \nfor the existence of a linear ranking function that use the vertices and rays of this representation. \nAnother positive news for the practically-minded reader is that some special cases of importance do have \na PTIME solution, be\u00adcause they reduce (with no effort, or with a polynomial-time com\u00adputation) to the \nrational case. We present several such cases, which include, among others, loops in which the body is \na sequence of linear af.ne updates with integer coef.cients, as in loop (1) above; and the condition \nis de.ned by either an extended form of differ\u00adence constraints, a restricted form of Two Variables Per \nInequality constraints, or a cone (constraints where the free constant is zero). Some cases in which \nthe body involves linear constraints are also presented. All the algorithms presented in this paper have \nbeen im\u00adplemented, and can be tried out online (see Sec. 5). Our results should be of interest to all \nusers of linear rank\u00ading functions, and in fact their uses go beyond termination proofs. For example, \nthey have been used to provide an upper bound on the number of iterations of a loop in program complexity \nanaly\u00adsis [2, 3] and to automatically parallelize computations [24, 25]. We remark that in termination \nanalysis, the distinction between in\u00adtegers and rationals has already been considered, both regarding \nranking-function generation [13, 22] and the very decidability of the termination problem [9, 16, 45]. \nAll these works left the inte\u00ad ger case open. Interestingly, our results provide an insight on how to \nmake the solution proposed by Bradley et al. [13] complete (see Sec. 6). This paper is organized as follows. \nSec. 2 gives de.nitions and background information regarding linear constraint loops, linear ranking \nfunctions and the mathematical notions involved. Sec. 3 proves that the decision problem, denoted LI \nN RF(Z), is coNP\u00adcomplete, and also presents an exponential-time ranking-function synthesis algorithm. \nSec. 4 discusses PTIME-solvable cases. Sec. 5 describes a prototype implementation. Sec. 6 surveys related \nprevi\u00ad ous work. Sec. 7 concludes. 2. Preliminaries In this section we recall some results on (integer) \npolyhedra on which we will rely, de.ne the kind of loops we are interested in, and formally de.ne the \nlinear ranking function problem. 2.1 Integer polyhedra We recall some useful de.nitions and properties \nwhich can all be found in [41]. A rational convex polyhedron P . Qn (polyhedron for short) is the set \nof solutions of a set of inequalities Ax = b, namely P = {x . Qn | Ax = b}, where A . Qm\u00d7n is a rational \nmatrix of n columns and m rows, x . Qn and b . Qm are column vectors of n and m rational values respectively. \nWe say that P is speci.ed by Ax = b. The set of recession directions of a polyhedron P speci.ed by Ax \n= b is the set RP = {y . Qn | Ay = 0}. For a given polyhedron P . Qn we let I(P) be P n Zn, i.e., the \nset of integer points of P. The integer hull of P, commonly denoted by PI , is de.ned as the convex hull \nof I(P), i.e., every rational point of PI is a convex combination of integer points. It is known that \nPI is also a polyhedron. An integer polyhedron is a polyhedron P such that P = PI . We also say that \nP is integral. Polyhedra also have a generator representation in terms of vertices and rays, written \nas P = convhull{x1, . . . , xm} + cone{y1, . . . , yt} . m t This means that x . P iff x =ai\u00b7xi+bj \u00b7yj \nfor some i=1 j=1 rationals ai, bj = 0, wherem i=1 ai = 1. Note that y1, . . . , yt are the recession \ndirections of P, i.e., y . RP iff y =jt =1 bj \u00b7 yj for some rational bj = 0. When P is integral, there \nis a generator representation in which all xi and yj are integer. Complexity of algorithms on polyhedra \nis measured in this paper by running time, on a conventional computational model (polynomially equivalent \nto a Turing machine), as a function of the bit-size of the input. Following [41, Sec. 2.1], we de.ne \nthe bit-size of an integer x as IxI = 1 + plog(|x| + 1)l; the bit-size of an n-dimensional vector a \nas IaI = n +n i=1 IaiI; and the bit-size of an inequality a \u00b7 x = c as 1 + IcI + IaI. For a polyhedron \nP . Qn de.ned by Ax = b, we let IP Ib be the bit-size of Ax = b, which we can take as the sum of the \nsizes of the inequalities. The facet size, denoted by IP If , is the smallest number f = n such that \nP may be described by some Ax = b where each inequality in Ax = b .ts in f bits. Clearly, IP If = IP \nIb. The vertex size, denoted by IP Iv, is the smallest number . = n such that P has a generator representation \nin which each of xi and yj .ts in . bits (the size of a vector is as above). For integer polyhedra, we \nrestrict the generators to be integer. The following theorems may be found in [41, Th. 10.2, p. 121] \nand [41, Cor. 17.1a,17.1b, p. 238] (citing [32]) respectively. THEOREM 2.1. Let P be a rational polyhedron \nin Qn; then IP Iv = 4n 2IP If and IP If = 4n 2IP Iv. THEOREM 2.2. Let P be a rational polyhedron in Qn; \nthen IPI Iv = 6n 3IP If and IPI If = 24n 5IP If .  2.2 Multipath linear-constraint loops A single-path \nlinear-constraint loop (SLC for short) over n vari\u00adables x1, . . . , xn has the form x while (Bx = b) \ndo A= c (3) x ''' ' )T where x = (x1, . . . , xn)T and x = (x1, . . . , x n are column vectors, and for \nsome p, q > 0, B . Qp\u00d7n , A . Qq\u00d72n , b . Qp, c . Qq. The constraint Bx = b is called the loop condition \n(a.k.a. the loop guard) and the other constraint is called the update. The update is called deterministic \nif, for a given x (satisfying the loop condition) there is at most one x ' satisfying the update constraint. \nThe update is called linear if it can be rewritten as x ' = A ' x + c ' for a matrix A ' and vector c \n' of appropriate dimensions. We say that the loop is a rational loop if x and x ' range over Qn, and \nthat it is an integer loop if they range over Zn .  We say that there is a transition from a state x \n. Qn to a state 3. The general case is coNP-complete x ' . Qn, if x satis.es the condition and x and \nx ' satisfy the update. L F In this section we show that the LIN RF(Z) problem is coNP- A transition \ncan be seen as a point x x . Q2n, where its .rst n components correspond to x and its last n components \nto x '. For L F complete; it is coNP-hard already for SLC loops. We also show that LRFs can be synthesized \nin deterministic exponential time. = ease of notation, we denote such points by x '' x x . The set '' \n. Q2n of all transitions x will be denoted, as a rule, by Q. The transition polyhedron Q is speci.ed \nby A '' '' = c '' where This section is organized as follows: in Sec. 3.1 we show that LI NRF(Z) is coNP-hard; \nin Sec. 3.2 we show that it is in coNP for SLC loops, and in Sec. 3.3 for MLC loops; .nally, in Sec. \n3.4, we x A '' B 0 '' b = c = A c Note that we may assume that Q does not include the origin, for if \nit includes it, the loop is clearly non-terminating (this condition is easy to check). Hence, Q is not \na cone (i.e., m = 1 in the gener\u00adator representation). The polyhedron de.ned by the loop condition Bx \n= b will be denoted by C (the condition polyhedron). A multipath linear-constraint loop (MLC for short) \ndiffers by having alternative loop conditions and updates, which are, in prin\u00adciple, chosen non-deterministically \n(though the constraints may en\u00adforce a deterministic choice): k x loop :i=1 Bix = bi . Ai ' = ci x This \nmeans that the i-th update can be applied if the i-th condi\u00adtion is satis.ed. Following the notation \nof SLC loops, the tran\u00adsitions of an MLC loop are speci.ed by the transition polyhedra '' '' Q1, . . \n. , Qk, where each Qi is speci.ed by A '' i x = ci . The poly\u00adhedron de.ned by the condition Bix = bi \nis denoted by Ci. For simplifying the presentation, often we write loops with ex\u00adplicit equalities and \ninequalities instead of the matrix representa\u00adtion. We also might refer to loops by their corresponding \ntransition polyhedra, or the sets of inequalities that de.ne these polyhedra.  2.3 Linear ranking functions \n. A linear function . : Qn . Q is of the form .(x) = . \u00b7 x + .0 where .. . Qn is a row vector and .0 \n. Q. For ease of notation we sometimes refer to a linear function using the row vector (.0,..) . Qn+1. \nNext we de.ne when a linear function is a linear ranking function (LRF for short) for a given rational \nor integer MLC loop. DEFINITION 2.3. Given an MLC loop with Q1, . . . , Qk as . transition polyhedra, \nand a linear function .(x) = . \u00b7 x + .0. describe an algorithm for synthesizing LRFs. 3.1 coNP-hardness \nWe prove coNP-hardness in a strong form. A number problem (a problem whose instance is a matrix of integers) \nProb is strongly hard for a complexity class, if there are polynomial reductions from all problems in \nthat class to Prob such that the values of all numbers created by the reduction are polynomially bounded \nby the input bit-size. Assuming NP =P, strongly NP-hard (or coNP-hard) problems cannot even have pseudo-polynomial \nalgorithms [26]. THEOREM 3.1. The LI NRF(Z) problem is strongly coNP-hard, even for deterministic SLC \nloops. Proof. The problem of deciding whether a polyhedron given by Bx = b contains no integer point \nis a well-known coNP-hard problem (an easy reduction from SAT may be found in [31]). We reduce this problem \nto LI NRF(Z). Given B . Zm\u00d7n and b . Zm , we construct the following integer SLC loop B -I xb x ' x while \n= do ' = 0 -I z0 z0 where x = (x1, . . . , xn)T , z = (z1, . . . , zm)T are integer vari\u00adables, and I \nis an identity matrix of size m \u00d7 m. Suppose Bx = b has an integer solution x. Then, the loop does not \nterminate when starting from this x and z set to 0, since the guard is satis.ed and the update does not \nchange the values. Thus, it does not have any ranking function, let along a LRF. Next, suppose Bx = b \ndoes not have an integer solution. Then, for any initial state for which the loop guard is enabled it \nmust hold that z1 + \u00b7 \u00b7 \u00b7 + zm > 0, for otherwise z1, . . . , zm must be 0 in which case the constraint \nBx - Iz = b has no integer solution. Since the updated vector z ' is deterministically set to 0, the \nguard will not be enabled in the next state, hence the loop terminates after ' ' one iteration. Clearly \nz1 + \u00b7 F \u00b7 \u00b7 + zm > z 1 + \u00b7 \u00b7 \u00b7 + zm = 0, so we conclude that z1 + \u00b7 \u00b7 \u00b7 + zm is a LRF . We say that \n. is a LRF for Q1, . . . , Qk iff the following hold for L x any rational point x . Qi x x .. \u00b7 x + \n.0 = 0 (4) Note that in the above reduction we rely on the hardness of whether a given polyhedron is \nempty. This problem is coNP-hard . . \u00b7 (x - x ' ) = 1 (5) even for bounded polyhedra (due to the reduction \nfrom SAT in and we say that it is a LRF for I(Q1), . . ., I (Qk) iff (4,5) hold for which variables are \nbounded by 0 and 1). This means that even L F any integer point for loops that only manipulate integers \nin a rather small range, . . I(Qi). the problem is coNP-hard. The parameter responsible for the ' ) = \n1 Intuitively, (4) and (5) requires that .(x) = 0 and .(x)-.(x respectively. For rational loops this \nmust hold for all rational tran\u00ad exponential behavior in this case is the number of variables. sitions, \nand for integer loops it must hold for all integer transitions. Clearly, the existence of a LRF implies \ntermination of the loop. Note that in Def. 2.3 we require . to decrease at least by 1, where in the literature \n[38] this 1 is sometimes replaced by d > 0. It is easy to verify that these de.nitions are equivalent. \nDEFINITION 2.4. The decision problem Existence of a LRF is de.ned by Instance: an MLC loop. Question: \ndoes there exist a LRF for this loop? The decision problem is denoted by LI N RF(Q) and LI NRF(Z) for \nrational and integer loops respectively. It is known that LI N RF(Q) is PTIME-decidable [36, 38]. In \nthis paper, we focus on LI N RF(Z).  3.2 Inclusion in coNP for SLC loops To prove that LI N RF(Z) is \nin coNP, we show that the complement of LI NRF(Z), the problem of nonexistence of a LRF , is in NP, that \nis, has a polynomially-checkable witness. In what follows we assume as input an SLC loop with a transition \npolyhedron Q . Q2n . The input is given as the set of linear inequalities A '' '' '' x = c that de.ne \nQ. The proof follows the following lines: 1. We show that there is no LRF for I(Q) iff there is a witness \nthat consists of two sets of integer points X . I(Q) and Y . I(RQ), such that a certain set of inequalities \n.WS (X ,Y ) has no solution over the rationals; and 2. We show that if there is a witness then there \nis one with bit-size polynomial in the input bit-size.   To make sense of the following de.nitions, \nthink of a vector and inequalities (6,7), for all y '' . Y , has no (rational) solution. (.0, ..) . Qn+1 \nas a candidate LRF that we may want to ver-We denote this set of inequalities by .WS (X ,Y ). Note that \nthe ify (or, in our case, to eliminate). variables in .WS (X ,Y ) are .0, . . . , .n, which range over \nQ, and L F thus, the test that it has no solution can be done in polynomial time DEFINITION 3.2. We say \nthat x '' = x x . I(Q) is a witness since it is an LP problem over the rationals. ..) . Qn+1 against \n(.0, if it fails to satisfy at least one of con-EXAMPLE 3.6. Consider the following integer SLC loop: \n' ' . ditions (4) and (5). The set of (.0,.) witnessed against by x '' is denoted by W (x '' ). while \n(x1 = 0) do x 1 = x1 + x2, x 2 = x2 - 1 DEFINITION 3.3. We say that y '' = L y y F '' '' . I(RQ) is \na Let x1 =(0, 2, 2, 1)T . I(Q) and y1 =(1, -2, -1,-2)T . I(RQ). Then, .WS ({x1 '' },{y1 '' }) is a conjunction \nof the inequalities . homogeneous component of a witness (h-witness) against (.0,.) . Qn+1 if it fails \nto satisfy at least one of . . \u00b7 y = 0 (6) .. \u00b7 (y - y ' ) = 0 (7) The set of (.0, ..) h-witnessed against \nby y '' is denoted by WH (y '' ). The meaning of the witness of Def. 3.2 is quite straightforward. Let \nus intuitively explain the meaning of an h-witness. Suppose that '' '' x is a point in QI , and y is \na ray of QI . Then a LRF . has to satisfy (4) for any integer point of the form x '' + a \u00b7 y '' with \na > 0; letting a grow to in.nity, we see that (4) implies the homogeneous inequality (6). Similarly, \n(5) implies (7). . DEFINITION 3.4. The set of (.0,.) . Qn+1 witnessed and h\u00adwitnessed against respectively \nby X . I(Q) and Y . I(RQ) is de.ned as  '' '' WS(X ,Y ) = W (x ) . WH (y ) . (8) {2.2 + .0 = 0, - 2.1 \n+ .2 = 1, .1 - 2.2 = 0, 2.1 = 0} (9) '' The .rst two inequalities correspond to applying (4,5) to x1 \n, and the other ones to applying (6,7) to y1 ''. It is easy to verify that (9) is '' ''not satis.able, \nthus, WS({x1 },{y1 }) = Q3 and the loop does not have a LRF . This is a classical loop for which there \nis no LRF. Lemma 3.5 provides a suf.cient condition for the nonexistence of LRF, the next lemma shows \nthat this condition is necessary. In particular, it shows that if there is no LRF for I(Q), then the \nvertices and rays of QI serve as X and Y of Lemma 3.5. LEMMA 3.7. Let the integer hull of the transition \npolyhedron Q '' '' '' '' be QI =convhull{x1 , . . . , xm}+cone{y1 , . . . , yt }. If there is no '' '' \n'' '' LRF for I(Q), then WS({x1 , . . . , xm},{y1 , . . . , yt })=Qn+1 . Proof. We prove the contra-positive. \nSuppose that '' '' '' '' WS({x1 , . . . , xm},{y1 , . . . , yt }) = Qn+1 . '' . Then, there is (.0,.) \n. Qn+1 that ful.lls (4,5) for all x and (6,7) x .X y .Y i for all yj ''. We claim that .(x) = . L F LEMMA \n3.5. Let X . I(Q) and Y . I(RQ). If WS(X ,Y ) Qn+1, then there is no LRF for I(Q). = To see this, let \nx '' x x . \u00b7 x + .0 is a LRF for I(Q). be an arbitrary point of I(Q). Then '' for some ai, bj = 0 where \n= '' '' tm bj \u00b7 y j \u00b7 x + i x = ai i=1 j=1 .Qn+1 Proof. Let WS(X ,Y ) = Qn+1. For any (.0,.) . , we '' \nm ai = i=1 1. Now, we show that x and . satisfy (4,5) which . prove that .(x) = .. \u00b7x+ .0 is not a LRF \n. If (.0,.) . W (x '' ) for means that . is a LRF for I(Q): some x '' . X, then the conclusion is clear \nsince conditions (4,5) do mt  .'' '' not hold. Otherwise, suppose that (.0,.) . WH (y ) for y . Y . \n.. \u00b7 x + .0 =.0 + ai \u00b7 (.. \u00b7 xi) + bj \u00b7 (.. \u00b7 yj )Thus, y '' fails to satisfy one of conditions (6,7). \nNext we show that, i=1 j=1 in such case, there must exists z '' . I(Q) that fails either (4) or (5). \nm t = ai \u00b7 (.. \u00b7 xi + .0) + bj \u00b7 (.. \u00b7 yj ) Case 1: Suppose (6) is not satis.ed. That is, .. \u00b7 y < 0. \nL F Choose an arbitrary x '' x x i=1 j=1 . I(Q), and assume that .(x) = 0, since otherwise . fails (4) \nand is not a LRF. Note that = =0 + 0 = 0 '' '' '' for any integer a = 0, the integer point z = x + a \n\u00b7 y is a m t LFL F '' '' ' x +a\u00b7y x +a\u00b7y . . We choose a as . \u00b7 (x - x z z transition in I(Q), and z \n) = ai \u00b7 (.. \u00b7 (xi - xi)) + bj \u00b7 (.. \u00b7 (yj - yj ))= = i=1 j=1 an integer suf.ciently large so that a \n\u00b7(.. \u00b7 y) = -(1 + .(x)). Now, =1 + 0 = 1 .(z) = .. \u00b7 (x + a \u00b7 y) + .0 = .(x) + a \u00b7 (.. \u00b7 y) = .(x) - \n(1 + .(x)) = -1  '' '' '' '' '' m t Note that the solutions of .WS ({x1 , . . . , x },{y1 , . . . , \ny })So . fails (4) on z . I(Q), and thus cannot be a LRF . in Lemma 3.7 de.ne the set of all LRFs for \nI(Q) (see Sec. 3.4). Case 2: Suppose (7) is not satis.ed. That is, .. \u00b7 (y - y ' ) < 0. L F EXAMPLE 3.8. \nConsider again the loop of Ex. 3.6, and recall that Choose an arbitrary x '' x x . I(Q), and assume \nthat ) = 1, since otherwise . fails (5) and is not a LRF . it does not have a LRF . The generator representation \nof QI is = ' .(x) - .(x '' '' '' '' QI = convhull{x1 } + cone{y1 , y2 , y3 } '' '' 2 =(0, 1, 1, 1)T '' \nDe.ne z as above, but now choosing a suf.ciently large to make ' ' '' )). Now, where a \u00b7 (.. \u00b7 (y - \ny )) = -(1 + .(x) - .(x x1 =(0, 1, 1, 0)T , y1 =(0, -1, -1, -1)T , y '' '' '' '' '' ' ' ' and y3 =(1, \n-1, 0, -1)T . Then, .WS ({x1 },{y1 , y2 , y3 }) is a .(z) - .(z ) = .. \u00b7 ((x + a \u00b7 y) - (x + a \u00b7 y )) \nconjunction of the following inequalities = .(x) - .(x ' ) + a \u00b7 (.. \u00b7 (y - y ' )) .2 + .0 = 0 -.2 = \n0 .2 = 0 .1 - .2 = 0 ' ' (10) = .(x) - .(x ) - (1 + .(x) - .(x )) = -1 -.1 + .2 = 1 .1 = 0 -.1 = 0 .1 \n= 0 So . fails (5) on z '' . I(Q), and thus cannot be a LRF . The inequalities in the leftmost column \ncorrespond to applying '' (4,5) to x1 , and those in the other columns to applying (6,7) to Qn+1 '' \n'' '' Note that the condition WS(X ,Y ) = is equivalent to y1 , y2 , and y respectively. It is easy to \nverify that (10) is not 3 '' '' '' '' '' saying that the conjunction of inequalities (4,5), for all \nx . X, satis.able. Thus, WS({x1 },{y1 , y2 , y3 }) = Q3 . COROLLARY 3.9. There is no LRF for I(Q), iff \nthere are two sets X . I(Q) and Y . I(RP ) such that WS(X ,Y ) = Qn+1 . The next lemma concerns the bit-size \nof the witness. LEMMA 3.10. If there exists a witness for the nonexistence of LRF for I(Q), there exists \none with X . I(Q) and Y . I(RQ) such that |X .Y | = n + 1; and the bit-size of X .Y is polynomial in \nthe bit-size of the input. Proof. Recall that by Lemma 3.7, if I(Q) has no LRF , then '' '' '' '' WS({x1 \n, . . . , xm},{y1 , . . . , yt }) = Qn+1 '' '' '' '' or, equivalently, .WS ({x1 , . . . , xm},{y1 , . \n. . , yt }) has no so\u00adlution. A corollary of Farkas Lemma [41, p. 94] states that: if a set of inequalities \nover Qn has no solution, there is a subset of at most n inequalities that has no solution. Since the \nset of '' '' '' '' Qn+1 inequalities .WS ({x1 , . . . , xm},{y1 , . . . , yt }) is over , there is a \nsubset of at most n + 1 inequalities that has no so\u00adlution. This subset involves at most n + 1 integer \npoints out of '' '' '' '' {x1 , . . . , xm} and {y1 , . . . , yt }, because every inequality in '' '' \n'' '' '' .WS ({x1 , . . . , xm},{y1 , . . . , yt }) is de.ned by either one xi or y '' (see eqs. (4 7)). \nLet these points be X.Y , then |X.Y | = n+1 i and .WS (X ,Y ) has no solution, i.e., WS(X ,Y ) = Qn+1 \n. Now we show that X . Y may be chosen to have bit-size polynomial in the size of the input. Recall that \nthe input is the set of inequalities A '' x '' = b that de.ne Q, and its bit-size is IQIb. Recall that \nthe points of X . Y in Lemma 3.7 come from the generator representation, and that there is a generator \nrepresentation in which each vertex/ray can .t in IQI Iv bits. Thus, the bit-size of X . Y may be bounded \nby (n + 1) \u00b7 IQI Iv. By Th. 2.2, since the dimension of Q is 2n, (n + 1) \u00b7 IQI Iv = (n + 1) \u00b7 (6 \u00b7 (2n)3 \n\u00b7 IQIf ) = 96n 4 \u00b7 IQIb which is polynomial in the bit-size of the input. '' '' '' '' EXAMPLE 3.11. Consider \n.WS ({x1 },{y1 , y2 , y3 }) of Ex. 3.8. It is easy to see that the inequalities -.2 = 0, .1 = 0 and -.1 \n+ .2 = 1 are enough for unsatis.ability (n + 1 inequalities, '' '' since n = 2). These inequalities correspond \nto x1 and y1 , and thus, they form a witness for the nonexistence of LRF . THEOREM 3.12. LI N RF(Z) . \ncoNP for SLC loops. Proof. We show that the complement of LI NRF(Z) has a polyno\u00admially checkable witness. \nThe witness is a listing of sets X and Y of at most n + 1 elements and has a polynomial bit-size (specif\u00adically, \na bit-size bounded as in Lemma 3.10). Verifying a witness consists of the following steps: Step 1: Verify \nthat each x '' . X is in I(Q), which can be done by '' '' verifying A '' x = c ''; and that each y . \nY is in I(RQ), which can be done by verifying A '' y '' = 0. This is done in polynomial\u00adtime. Note that \naccording to Lemma 3.5 it is not necessary to check that X and Y come from a particular generator representation. \nQn+1 Step 2: Verify that WS(X ,Y ) = . This can be done by checking that .WS (X ,Y ) has no solutions, \nwhich can be done in polynomial-time since it is an LP problem over Qn+1 .  3.3 Inclusion in coNP for \nMLC loops In this section we consider the inclusion in coNP for MLC loops. For this, we assume an input \nMLC loop with transition polyhedra '' '' Q1, . . . , Qk where each Qi is speci.ed by A '' i x = ci . \nThe proof follows the structure of the SLC case. The main difference is that points of the witness X \n. Y may come from different transition polyhedra. Namely, X = X1 . \u00b7 \u00b7 \u00b7 . Xk and Y = Y1 .\u00b7 \u00b7 \u00b7.Yk where \neach Xi . I(Qi) and Yi . I(RQi ). We rewrite Lemmas 3.5, 3.7, and 3.10, Cor. 3.9, and Th. 3.12 in terms \nof such witnesses (the proofs are the same unless stated otherwise). LEMMA 3.13. Let X = X1 . \u00b7 \u00b7 \u00b7 . \nXk and Y = Y1 . \u00b7 \u00b7 \u00b7 . Yk, Qn+1 where Xi . I(Qi) and Yi . I(RQi ). If WS(X ,Y ) = , then there is no \nLRF for I(Q1), . . . , I (Qk). LEMMA 3.14. For 1 = i = k, let QiI = convhull{Xi} + cone{Yi} be the integer \nhull of Qi, and de.ne X = X1 .\u00b7 \u00b7 \u00b7 . Xk and Y = Y1 . \u00b7 \u00b7 \u00b7 . Yk. If there is no LRF for I(Q1), . . . \n, I (Qk), then WS(X ,Y ) = Qn+1 . . Proof. The proof follows that of Lemma 3.7. We pick (.0,.) . . Qn+1 \n\\ WS(X ,Y ) and show that .(x) = . \u00b7 x + .0 is a LRF for each I(Qi). This is accomplished by performing \nthe same calculation, however referring to Xi and Yi when proving that . is a LRF for I(Qi). COROLLARY \n3.15. There is no LRF for I(Q1), . . . , I (Qk), iff there are two sets X = X1 .\u00b7 \u00b7 \u00b7.Xk and Y = Y1 .\u00b7 \n\u00b7 \u00b7.Yk, where Xi . I(Qi) and Yi . I(RQi ), such that WS(X ,Y ) = Qn+1 . LEMMA 3.16. If there exists a \nwitness for the nonexistence of LRF for I(Q1), . . . , I (Qk), then there exists one, with X = X1 . \u00b7 \n\u00b7 \u00b7 . Xk and Y = Y1 . \u00b7 \u00b7 \u00b7 . Yk, where Xi . I(Qi) and Yi . I(RQi ), such that |X . Y | = n + 1; and \nthe bit-size of X . Y is polynomial in the bit-size of the input. THEOREM 3.17. LI NRF(Z) . coNP. Proof. \nThe difference from that of Th. 3.12 is that the witness is given as X=X1 .\u00b7 \u00b7 \u00b7.Xk and Y =Y1 .\u00b7 \u00b7 \u00b7.Yk. \nThus, the veri.er should use the appropriate set of inequalities to check that each '' '' x . Xi is in \nI(Qi), and that each y . Yi is in I(RQi ). EXAMPLE 3.18. Consider the following integer MLC loop loop \n: x1 = 0, x2 = 0 . x1 ' = x1 - 1 . x1 = 0, x2 = 0 . x2 ' = x2 - 1, x 1 ' = x1 It is a classical MLC loop \nfor which there is no LRF . The integer hull of the corresponding transition polyhedra are '' '' '' '' \n'' Q1I = convhull{x1 } + cone{y1 , y2 , y3 , y4 } '' '' '' Q2I = convhull{x2 } + cone{y5 , y6 } '' '' \n'' where x1 =(0, 0, -1, 0)T , x2 =(0, 0, 0, -1)T , y1 =(0, 0, 0, -1)T , '' '' '' '' y2 = (0, 0, 0, 1)T \n, y3 = (0, 1, 0, 0)T , y4 = (1, 0, 1, 0)T , y5 = (0, 1, 0, 1)T and y6 '' = (1, 0, 1, 0)T. Let us .rst \nconsider each path separately. We get '' '' '' '' .0 = 0, .1 = 1, .WS ({x1 },{y1 , y2 , y3 }) =(11) \n.2 = 0, -.2 = 0 '' '' '' '' .WS ({x2 },{y4 , y5 , y6 }) ={.0 = 0, .2 = 1} (12) Both (11) and (12) are \nsatis.able. In fact, their solutions de.ne the corresponding LRFs for each path when considered separately. \n'' '' '' '' For the MLC loop, we have that .WS ({x1 , x2 },{y1 , . . . , y6 }) is the conjunction of \nthe inequalities in (11) and (12), which is not satis.able. Thus, while each path has a LRF, the MLC \nloop does not. Note that the inequalities .2 = 1 and -.2 = 0 are enough '' '' to get unsatis.ability \nof (11,12), thus, X={x2 } and Y ={y2 } is a witness, and consists of less than n + 1 points (n = 2 in \nthis case).  3.4 Synthesizing a linear ranking function Although the existence of a LRF suf.ces for \nproving termination, generating a complete representation of the LRF is important in some contexts, for \ninstance complexity analysis where a LRF provides an upper bound on the number of iterations that a loop \ncan perform. In this section we give a complete algorithm that generates LRFs for MLC loops given by \ntransition polyhedra Q1, . . . , Qk. The following lemma is directly implied by lemmas 3.13 and 3.14. \n LEMMA 3.19. For 1 = i = k, let the integer hull of Qi be QiI = convhull{Xi}+ cone{Yi}, and de.ne X \n= X1 .\u00b7 \u00b7 \u00b7.Xk . and Y = Y1 . \u00b7 \u00b7 \u00b7 . Yk. Then, .(x) = . \u00b7 x + .0 is a LRF for . I(Q1), . . . , I (Qk), \niff (.0,.) is a solution for .WS (X ,Y ). The following algorithm is clearly implied: (1) Compute the \ngenerator representation for each QiI ; (2) Construct .WS (X ,Y ); . and (3) Use LP to .nd a solution \n(.0,.) for .WS (X ,Y ). EXAMPLE 3.20. Consider again Loop (1) from Sec. 1. The inte\u00ad ger hull of the \ntransition polyhedron is '' '' '' '' QI = convhull{x1 , x2 } + cone{y1 , y2 } '' '' '' where x1 = (1, \n1, 1, 0)T , x2 = (1, 0, 1, -1)T , y1 =(1, 1, 1, -1)T , '' '' '' '' '' and y2 = (1, -1, 1, -3)T . Then, \n.WS ({x1 , x2 },{y1 , y2 }) is the conjunction of the following inequalities (we eliminated clearly redundant \ninequalities) .1 + .2 + .0 = 0, .1 + .0 = 0, (13) .1 + .2 = 0, .1 - .2 = 0, .2 = 1 which is satis.able \nfor .1 = .2 = 1 and .0 = -1, and therefore, f(x1, x2) = x1 + x2 - 1 is a LRF . Recall that this loop \ndoes not terminate when the variables range over Q, e.g., for x1 = 2 1 and x2 = 1 2 (see Fig. 1(A)). \nLet us consider now Loop (2) from Sec. 1. The integer hull of the transition polyhedron is '' '' '' '' \n'' '' '' '' QI = convhull{x1 , x2 , x3 , x4 , x5 , x6 } + cone{y1 , y2 } '' '' '' where x1 = (4, 16, \n1, 16)T , x2 = (1, 4, 0, 4)T , x3 = (2, 8, 1, 8)T , '' '' '' '' x4 = (1, 1, 0, 1)T , x5 = (4, 1, 1, 1)T \n, x6 = (2, 1, 1, 1)T , y1 = (5, 0, 2, 0)T and y2 = (5, 20, 2, 20)T. Then, the set of inequalities '' \n'' '' '' .WS ({x1 , . . . , x6 },{y1 , y2 }) is the conjunction of the following inequalities (we eliminated \nclearly redundant inequalities) . . . .1 = 1, 4.1+.2+.0 = 0, 4.1+16.2+.0 = 0, . 2.1+.2+.0 = 0, .1+4.2+.0 \n= 0, (14) . . 2.1+8.2+.0 = 0, 5.1+20.2 = 0, .1+.2+.0 = 0 which is satis.able for .1 = 1, .2 = 0 and .0 \n= -1, and therefore, f(x1, x2) = x1 - 1 is a LRF . Recall that this loop, too, does not terminate when \nthe variables range over Q, e.g., for x1 = 1 4 and x2 = 1 (see Fig. 1(C)). If we consider both loops \n(1) and (2) as two paths in an MLC loop, then to synthesize LRFs we use the conjunction of the in\u00adequalities \nin (13) and (14). In this case, .1 = .2 = 1 and .0 = -1, is a solution, but .1 = 1, .2 = 0 and .0 = -1 \nis not. Therefore, f(x1, x2) = x1 + x2 - 1 is a LRF for both paths, and thus for the MLC loop, but not \nf(x1, x2) = x1 - 1. Given our hardness results, one cannot expect a polynomial\u00adtime algorithm. Indeed, \nconstructing the generator representation of the integer hull of a polyhedron from the corresponding \nset of '' inequalities A '' i x = ci may require exponential time the number of generators itself may \nbe exponential. Their bit-size, on the other hand, is polynomial by Th. 2.2. This is interesting, since \nit yields: COROLLARY 3.21. Given an MLC loop with transition poly\u00ad '' hedra Q1, . . . , Qk, where each \nQi is speci.ed by A '' i x = ci . If there is a LRF for I(Q1), . . . , I (Qk), there is one whose bit-size \n'' is polynomial in the bit-size of A '' i x = ci , namely in maxi IQiIb. Proof. As in the last section, \nwe bound the bit-size of each of the generators of QiI by IQiI Iv = 6(2n)3 \u00b7 IQiIf = 48n 3 \u00b7 IQiIb for \nan appropriate i. This means that the bit-size of each equation in .WS (X ,Y ), having one of the forms \n(4), (5), (6), or (7) is at most 5 + 48n 3 \u00b7 (maxi IQiIb). Let P be the polyhedron de.ned by .WS (X ,Y \n), then IP If = 5 + 48n 3 \u00b7 (maxi IQiIb). If .WS (X ,Y ) has a solution, then any vertex of P is such \na solution, and yields a LRF . Using Th. 2.1, together with the above bound for IP If and the fact that \nthe dimension of P is n+ 1, we conclude that there is a generator representation for P in which the bit-size \nIP Iv of the vertices is bounded as follows: 2 23 IP Iv = 4\u00b7(n+1)\u00b7IP If = 4\u00b7(n+1)\u00b7(5+48n \u00b7(maxIQiIb)) \ni This also bounds the bit-size of the corresponding LRF . We conclude this section by noting that the \nalgorithm induced by Lemma 3.19 works also for LIN RF(Q), if we consider Qi instead of QiI . This can \nbe easily proven by reworking the proofs of Lemmas 3.13 and 3.14 for the case of Qi instead of QiI . \nWe did not develop this line since the main use of these lemmas is proving the coNP-completeness for \nLIN RF(Z). This, however, has an interesting consequence: LI NRF(Q) is still PTIME even if the input \nloop is given in the generator representations form instead of the constraints form. Practically, implementations \nof polyhedra that use of the double description method, such as the Parma Polyhedra Library [5], in which \nboth the generators and constraint representations are kept at the same time, can use the algorithm of \nLemma 3.19 judiciously when it seems better than algorithms that use the constraints representation [36, \n38]. 4. Special cases in PTIME In this section we discuss cases in which the LI N RF(Z) problem is PTIME-decidable. \nWe start by a basic observation: when the transition polyhedron of an SLC loop is integral, the LI N \nRF(Z) and LI N RF(Q) problems are equivalent (a very similar statement appears in [22, Lemma 3]). LEMMA \n4.1. Let Q be a transition polyhedron of a given SLC loop, and let . be a linear function. If Q is integral, \nthen . is a LRF for Q iff . is a LRF for I(Q). Proof. Let Q be integral. (.) Suppose that . is a LRF \nfor Q, then it is also a LRF for I(Q) since I(Q) . Q. (.) Suppose that . is a LRF for I(Q), it thus satis.es \n(4,5) of Def. 2.3 for any integer point in Q. However, by de.nition of an integer polyhedron, every rational \npoint in Q is a convex combination of integer points from I(Q), this proves that . satis.es conditions \n(4,5) for any rational point as well. To see this, choose an arbitrary rational point x '' = L F x '' \n'' x . Q. It can be written as x = ai \u00b7 x L i : where ai = 0, LF F ai \u00b7xi ai = 1 and xi . I(Q). Thus, \nx = x = : ai , and '' '' x \u00b7xi .(x) =(.. \u00b7 ai \u00b7 xi) + .0 = ai \u00b7 (.. \u00b7 xi + .0) = 0 .(x) - .(x ' ) =(.. \n\u00b7 ai \u00b7 xi) - (.. \u00b7 ai \u00b7 x ' i) .' = ai \u00b7 . \u00b7 (xi - xi) = 1 The above lemma provides an alternative complete \nprocedure for LI N RF(Z), namely, compute a constraint representation of its integer hull QI and solve \nLI NRF(Q). Note that computing the integer hull might require exponential time, and might also result \nin a polyhedron with an exponentially big description. This means that the above procedure is exponential \nin general; but this concern is circumvented if the transition polyhedron is integral to begin with; \nand in special cases where it is known that computing the integer hull is easy. Formally, we call a class \nof polyhedra easy if computing its integer hull can be done in polynomial time.  x2 x1-x2=0 x 1 =1 x2 \nx1-x2=0 x 1 =1 x1 -x1-x2=-1 1 2 1 2 1 0 1 -2x1-1 3 1 3 1 -1 x1 A x2=-1 B x ' 1 4x 1 =1 2x1-5x1=3 -2x1+5x1=1 \n-x1+x1=-1 0 1 2 3 2 - 1 2 3 10 13x1-x1=13 4 5 6 x1 C Figure 1. The polyhedra associated with three of \nour examples, projected to two dimensions. Dashed lines are added when comput\u00ading the integer hull; dotted \nareas represent the integer hull; gray ar\u00adeas are rational points eliminated when computing the integer \nhull. EXAMPLE 4.2. Consider again Loop (2) of Sec. 1. The transition polyhedron is not integral, computing \nits integer hull adds the ' ' 1 inequalities -x1 + x1 = -1 and 3 1 x1 - x1 = 3 (see Fig. 1(C)). Applying \nLI N RF(Q) on this loop does not .nd a LRF since it does not terminate when the variables range over \nQ, however, applying it on the integer hull .nds the LRF f(x1, x2) = x1 - 1. COROLLARY 4.3. The LI N \nRF(Z) problem is PTIME-decidable for SLC loops in which the transition polyhedron Q is guaranteed to \nbe integral. This also applies to any easy class of polyhedra, namely a class where the integer hull \nis PTIME-computable. Proof. Immediate from Lemma 4.1 and the fact that LI N RF(Q) is PTIME-decidable. \nCOROLLARY 4.4. The LI N RF(Z) problem is PTIME-decidable for SLC loops in which the condition polyhedron \nC is guaranteed to be integral, or belongs to an easy class, and the update is linear with integer coef.cients. \nProof. We show that in such case the transition polyhedron Q is, in fact, integral, and thus Cor. 4.3 \napplies. Let C be integral, and the update be x ' = A ' x + c ' where the entries of A ' and c ' are \ninteger. L F '' x ' A ' Let x = . Q, that is, x . C and x = x + c '. Since C is integral, x x is a convex \ncombination of some integer points. I.e, x = ai \u00b7 xi where ai = 0, ai = 1 and xi . I(C). Hence, ' '' \nx = A ' ( ai \u00b7 xi) + c = ai \u00b7 (A ' xi + c ) and '' x ai \u00b7 xi xi x = ' = ' = ai \u00b7 ' x ai \u00b7 (A ' xi + c \n) A ' xi + c L F Now note that xi are integer points from I(Q), which A xi+c implies that x '' is a convex \ncombination of integer points in Q. Hence, Q is integral. Corollaries 4.3 and 4.4 suggest looking for \nclasses of SLC loops where we can easily ascertain that Q is integral, or that its integer hull can be \ncomputed in polynomial time. In what follows we address such cases: Sec. 4.1 discusses special cases \nin which the transition or condition polyhedron is integral by construction; Sec. 4.2 shows that for \ncertain cases of two-variables per inequality constraints the integer hull can be computed in a polynomial \ntime; Sec. 4.3 discusses the case of octagonal relations; Sec. 4.4 shows that for some cases LINRF(Z) \nis even strongly polynomial; and Sec. 4.5 extends the results to MLC loops. 4.1 Loops speci.ed by integer \npolyhedra There are some well-known examples of polyhedra that are known to be integral due to some structural \nproperty. This gives us classes of SLC loops where LI N RF(Z) is in PTIME. The examples below are all \nfrom [41], where the proofs of the lemmas can be found. LEMMA 4.5. For any rational matrix B, the cone \n{x | Bx = 0}is an integer polyhedron. COROLLARY 4.6. The LI N RF(Z) problem is PTIME-decidable for SLC \nloops of the form '' ' while (Bx = 0) do x = A x + c where the entries in A ' and c ' are integer. Recall \nthat a matrix A is totally unimodular if each subdetermi\u00adnant of A is in {0, \u00b11}. In particular, the \nentries of such matrix are from {0, \u00b11}. LEMMA 4.7. For any totally unimodular matrix A and integer vector \nb, the polyhedron P = {x | Ax = b} is integral. For brevity, if a polyhedron P is speci.ed by Ax = b \nin which A is a totally unimodular matrix and b an integer vector, we say that P is totally unimodular. \nCOROLLARY 4.8. The LI N RF(Z) problem is PTIME-decidable for SLC loops in which (1) the transition polyhedron \nQ is totally unimodular; or (2) the condition polyhedron C is totally unimodu\u00adlar and the update is linear \nwith integer coef.cients. As a notable example, difference bound constraints [7, 10, 11] are de.ned by \ntotally unimodular matrices. Such constraints have the form x - y = d with d . Q; constraints of the \nform \u00b1x = d can also be admitted. In the integer case we can always tighten d to LdJ and thus get an \ninteger polyhedron. It might be worth mentioning that checking if a matrix is totally unimodular can \nbe done in polynomial time [41, Th. 20.3, p. 290].  4.2 Two-variable per inequality constraints In this \nsection we consider cases in which the input loop involves two-variable per inequality constraints (TVPI \nfor brevity), i.e., inequalities of the form ax + by = d with a, b, d . Q. Clearly, polyhedra de.ned \nby such inequalities are not guaranteed to be integral. See, for example, Fig. 1(B). Harvey [29] showed \nthat for two-dimensional polyhedra, which are speci.ed by TVPI constraints by de.nition, the integer \nhull can be computed in O(m log Amax) where m is the number of inequalities and Amax is the magnitude \nof the largest coef.cient. DEFINITION 4.9. Let T be a set of TVPI constraints. We say that T is a product \nof independent two-dimensional TVPI constraints (PTVPI for brevity), if it can be partitioned into T1, \n. . . , Tn such that (1) each Ti is two-dimensional, i.e., involves at most two variables; and (2) each \ndistinct Ti and Tj do not share variables. LEMMA 4.10. The integer hull of PTVPI constraints can be computed \nin polynomial time.  Proof. According to [41, Sec. 16.3, p. 231], a polyhedron P is integral iff each \nof its faces has an integer point. A face of P is obtained by turning some inequalities to equalities \nsuch that the resulting polyhedron in not empty (over the rationals). Clearly, if T1 and T2 are two sets \nof inequalities that do not share variables, and their faces have integer points, then all faces of T1 \n.T2 have integer points. Thus, T1 . T2 is integral. Partitioning T into independent T1, . . . , Tn and \nchecking that each is two-dimensional can done in polynomial time. Computing the integer hull of each \nTi can be done in polynomial time using Harvey s method. The above approach can easily be generalized. \nGiven any poly\u00adhedron, we .rst decompose it into independent sets of inequalities, in polynomial time \n(these are the connected components of an ob\u00advious graph), and then check if each set is covered by one \nof the special cases for which the integer hull can be ef.ciently computed. COROLLARY 4.11. The LI N \nRF(Z) problem is PTIME-decidable for SLC loops in which: (1) the transition polyhedron Q is PTVPI ; or \n(2) the condition polyhedron C is PTVPI , and the update is linear with integer coef.cients. EXAMPLE \n4.12. Consider the following SLC loop, as an exam\u00adple for case (1) of Cor. 4.11 while (4x1 = 1, x2 = \n1) do ' '' (15) 2x1 - 5x1 = 3, -2x1 + 5x1 = 1, x 2 = x2 + 1 Applying LI N RF(Q) does not .nd a LRF since \nthe loop does not terminate when the variables range over Q, e.g., for x1 = 1 4 and x2 = 1. The transition \npolyhedron is not integral, however, it is PTVPI since it can be divided into T1 = {4x1 = 1, 2x1 - 5x1 \n' = 3, -2x1 + 5x ' 1 = 1} and T2 = {x2 = 1, x ' 2 = x2 + 1}. It is easy to check that T2 is already integral. \nComputing the integer hull of T1 adds the inequalities -x1 + x1 ' = -1 and 1 3 x1 - x1 ' = 1 3 . See \nFig. 1(C). Now LIN RF(Q) .nds the LRF f(x1, x2) = x1 - 1. EXAMPLE 4.13. Consider the following loop, \nas an example for case (2) of Cor. 4.11 while (-x1 + x2 = 0, -2x1 - x2 = -1, x3 = 1) do '' ' (16) x1 \n= x1, x 2 = x2 - 2x1 + x3, x 3 = x3 Applying LI N RF(Q) does not .nd a LRF since it does not termi\u00adnate \nover Q, e.g., for x1 = x2 = 1 2 and x3 = 1. The condition polyhedron is not integral, but it is PTVPI \nsince the constraints can be divided into T1 = {-x1 + x2 = 0, -2x1 - x2 = -1}and T2 = {x3 = 1}. It is \neasily seen that T2 is already integral; computing the integer hull of T1 adds x1 = 1. See Fig. 1(B). \nNow LI N RF(Q) .nds the LRF f(x1, x2, x3) = 2x1 +x2 -1. Note that the update in this loop involves constraints \nwhich are not TVPI .  4.3 Octagonal relations TVPI constraints in which the coef.cients are from {0, \n\u00b11} have received considerable attention in the area of program analysis. Such constraints are called \noctagonal relations [37]. A particular interest was in developing ef.cient algorithms for checking satis.\u00adability \nof such relations, as well as inferring all implied octagonal inequalities, for variables ranging either \nover Qor over Z. Over Q, this is done by computing the transitive closure of the relation, which basically \nadds inequalities that result from the addition of two existing inequalities, and possibly scaling to \nob\u00adtain coef.cients of \u00b11. E.g., starting from the set of inequalities {-x1 + x2 = 0, -x1 - x2 = -1}, \nwe add -2x1 = -1, or, after scaling, -x1 = - 1 2 . Over Z, this is done by computing the tight closure, \nwhich in addition to transitivity, is closed also under tight\u00adening. This operation replaces ax + by \n= d by ax + by = LdJ. For example, tightening -x1 = - 1 2 yields -x1 = -1. The tight closure can be computed \nin polynomial time [4, 30, 39]. Since the tightening eliminates some non-integer points, it is tempting \nto ex\u00adpect that it actually computes the integer hull. It is easy to show that this is true for two-dimensional \nrelations, but it is false already in three dimensions, as we show in the following example. EXAMPLE \n4.14. Consider the following loop while (x1 + x2 = 2, x1 + x3 = 3, x2 + x3 = 4) do ' ' ' (17) x1 = 1 \n- x1, x 2 = 1 + x1, x 3 = 1 + x2 Note that the transition polyhedron is octagonal, but not integral. \nApplying LINRF(Q) does not .nd a LRF , since the loop does 13 5 not terminate over Q, e.g., for x1 = \n, x2 = , and x3 = . 22 2 Computing the tight closure does not change the transition (or condition) polyhedron, \nand thus, it is of no help in .nding the LRF . In order to obtain the integer hull of the transition \n(or condition) polyhedron we should add x1 + x2 + x3 = 4, which is not an octagonal inequality. Having \ndone so, LI N RF(Q) .nds the LRF f(x1, x2, x3) = -3x1 - 4x2 - 2x3 + 12. Although it is not guaranteed \nthat the tight closure of an octag\u00adonal relation corresponds to its integer hull, in practice, it does \nin many cases. Thus, since it can be computed in polynomial time, we suggest computing it before applying \nLI N RF(Q) on loops that involve such relations. The above example shows that this does not give us a \ncomplete polynomial-time algorithm for LI NRF(Z) over octagonal relations. EXAMPLE 4.15. Consider the \nfollowing SLC loop -x1+x2 = 0, -x1 - x2 = -1, while do x2 - x3 = 0, -x2 - x3 = -1 '' ' x1 = x1, x 2 = \nx2 - x1 - x3 + 1, x 3 = x3 The condition polyhedron is octagonal, but not integral; moreover, it is not \nPTVPI . LI N RF(Q) does not .nd a LRF (indeed the loop fails to terminate for x1 = x2 = x3 = 2 1 ). Computing \nthe tight closure of the condition adds -x1 = -1 and -x3 = 0, which results in the integer hull. Now \nLI N RF(Q) .nds the LRF f(x1, x2, x3) = x1 + x2 - 1. A polynomial-time algorithm for computing the integer \nhull of octagonal relations is, unfortunately, ruled out by examples of such relations whose integer \nhulls have exponentially many facets. THEOREM 4.16. There is no polynomial-time algorithm for com\u00adputing \nthe integer hull of general octagonal relations. Proof. We build an octagonal relation O, such that the \nminimum number of inequalities required to describe its integer hull OI is not polynomial in the number \nof inequalities in O. For a complete graph Kn = (V, E ), we let P be de.ned by the set of inequalities \n{xe = 0 | e . E} . { xe = 1 | v . V }. v.e Here every edge e . E has a corresponding variable xe, and \nthe notation v . e means that v is a vertex of edge e. Note that P is not octagonal. It is well-known \nthat PI , the matching L F n polytope of Kn, has at least 2 + 2n-1 facets [41, Sec. 18.2, p. 251], and \nthus any set of inequalities that de.nes PI must have at least the same number of inequalities. Now let \nO be de.ned by {xe = 0 | e . E} . {xe1 + xe2 = 1 | v . e1, v . e2}, L F which includes n + n \u00b7 n-1 octagonal \ninequalities. It is easy 2 to see that the integer solutions of P and O are the same, and thus PI = OI \n. This means that any set of inequalities that de.ne L F n OI must have at least 2 + 2n-1 inequalities. \nTherefore, any algorithm that computes such a representation must add at least LF LF n n-1 2 + 2n-1 - \nn - n \u00b7 2 inequalities to O, which is super\u00adpolynomial in the size of O. Unsurprisingly, the tight closure \nof O does not yield its integer hull (it only adds xe = 1 for each xe).  Note that the above theorem \ndoes not rule out a polynomial-time algorithm for LI NRF(Z), for SLC loops in which the transition polyhedron \nQ is octagonal, or where the condition polyhedron is octagonal and the update is linear with integer \ncoef.cients. It just rules out an algorithm that is based on computing the integer hull of the polyhedra. \nHowever, the coNP-hardness proof of Sec. 3.1 could be also carried out by a reduction from 3SAT that \nproduces an SLC loop where the condition is octagonal and the update is linear with integer coef.cients \nso at least for this class there is, presumably, no polynomial solution. This reduction can be found \nin the technical report [8].  4.4 Strongly polynomial cases Polynomial-time algorithms for LI N RF(Q) \n[3, 36, 38] inherit their complexity from that of LP. While it is known that LP can be solved by a polynomial-time \nalgorithm, it is an open problem whether it has a strongly polynomial algorithm. Such an algorithm should \nperform a number of elementary arithmetic operations poly\u00adnomial in the dimensions of the input matrix \ninstead of its bit-size (which accounts for the size of the matrix entries), and such oper\u00adations should \nbe performed on numbers of size which is polyno\u00admial to the input bit-size. However, there are some cases \nfor which LP is known to have a strongly polynomial algorithm. We .rst use these cases to de.ne classes \nof SLC loops for which LI N RF(Q) has a strongly polynomial algorithm, which we then use to show that \nLI N RF(Z) has a strongly polynomial algorithm for some cor\u00adresponding classes of SLC loops. Our results \nare based on the fol\u00adlowing result by Tardos [44] (quoted from [41, p. 196]). THEOREM 4.17 (Tardos). \nThere exists an algorithm which solves a given rational LP problem max{c \u00b7 x | Ax = b} with at most P \n(size(A)) elementary arithmetic operations on numbers of size polynomially bounded by size(A, b, c), \nfor some polynomial P . Note that the number of arithmetic operations required by the LP algorithm only \ndepends on the bit-size of A. Clearly, if we restrict the LP problem to cases in which the bit-size of \nthe entries of A is bounded by a constant, then size(A) depends only on its dimensions, and we get a \nstrongly polynomial time algorithm. In particular we can state the following. COROLLARY 4.18. There exists \na strongly polynomial algo\u00adrithm to solve an LP problem max{c \u00b7 x | Ax = b} where the entries of A are \n{0, \u00b11, \u00b12}. We can use this to show that LI N RF(Q) can sometimes be implemented with strongly polynomial \ncomplexity. To do this, we use the Podelski-Rybalchenko formulation of the procedure [38], slightly modi.ed \nto require that the LRF decreases at least by 1 instead of by some d > 0. THEOREM 4.19 (Podelski-Rybalchenko). \nGiven an SLC loop '' '' with a transition polyhedron Q . Q2n, speci.ed by A '' x = c , let A '' = (A \nA ' ) where each A and A ' has n columns and m rows, and let .. be row vectors of different m rational \nvariables each. \u00b5, .A LRF for Q exists iff there is a (rational) solution to the following set of constraints \nT ' T \u00b5, .. \u00b7 (A + A .. = 0, (18a) .) = 0, (18d) ' T '' .\u00b5 \u00b7 A = 0, (18b) ..\u00b7 c = -1 . (18e) (.\u00b5 - ..) \n\u00b7 A = 0T , (18c) THEOREM 4.20. The LIN RF(Q) problem is decidable in strongly polynomial time for SLC \nloops speci.ed by A '' x '' = c '' where the coef.cients of A '' are from {0, \u00b11}. Proof. First observe \nthat, in Th. 4.19, when the matrix A '' has only entries from {0, \u00b11}, then all coef.cients in the constraints \n(18a 18d) are from {0, \u00b11, \u00b12}. Moreover, the number of inequalities and variables in (18a 18d) is polynomial \nin the dimensions of A '' . Now let us modify the Podelski-Rybalchenko procedure such that instead of \ntesting for feasibility of the constraints (18a 18e), we consider the minimization of ..\u00b7 c '' under \nthe other constraints (18a 18d). Clearly, this answers the same question since: (18a 18e) is feasible, \niff the minimization problem is unbounded, or the minimum is negative. This brings the problem to the \nform required by Cor. 4.18 and yields our result. COROLLARY 4.21. The LI N RF(Z) is decidable in strongly \n'' '' polynomial time for SLC loops, speci.ed by A '' x = c , that are covered by any of the special \ncases of secs. 4.1 and 4.2 and the entries of A '' are from {0, \u00b11}. Proof. In the cases of Sec. 4.1, \nthe transition polyhedron is guaran\u00ad teed to be integral. In the PTVPI case of Sec. 4.2: (1) the integer \nhull can be computed using Harvey s procedure, which is strongly polynomial in this case since the entries \nof A are from {0, \u00b11}. This can be done also using the tight closure of 2-dimensional oc\u00adtagons; and \n(2) the TVPI constraints that we add when computing the integer hull have coef.cients from {0, \u00b11}, and \nthe number of such constraints is polynomially bounded by the number of the original inequalities. Thus, \nby Th. 4.20, we can apply a strongly polynomial-time algorithm for LI NRF(Q).  4.5 Multipath loops Recall \nthat a linear function . is a LRF for an MLC loop with tran\u00adsition polyhedra Q1, . . . , Qk, iff it is \na LRF for each Qi. Thus, if we have the set of LRFs for each Qi, we can simply take the intersection \nand obtain the set of LRFs for Q1, . . . , Qk. In the Podelski-Rybalchenko procedure, the set of solutions \nfor the in\u00adequalities (18a 18e) de.nes the set of LRFs for the corresponding SLC loop as follows. LEMMA \n4.22. Given an SLC loop with a transition polyhedron '' '' Q, speci.ed by A '' x = c '', let .(.., A \n'' , c ) be the conjunction \u00b5, .. of (18a 18e). Then, .(x) = . \u00b7 x + .0 is a LRF for Q iff .(.., A '' \n'' ) has a solution such that ..\u00b7A ' and .0 = .'' . \u00b5, ., c . = .\u00b5\u00b7c The following lemma shows how to \ncompute, using the above lemma, the intersection of sets of LRFs for several transition polyhedra, and \nthus obtain the set of LRFs for a given MLC loop. (a very similar statement appears in [22, Lemma 3]). \nLEMMA 4.23. Given an MLC loop with transition polyhedra '' '' '' Q1, . . . , Qk, each speci.ed by A '' \ni x = ci , let .(.i , c i ) \u00b5i, ..i, A '' . be the constraints (18a 18e) for the i-th path, and (.0,.) \nbe n + 1 rational variables. Then, there is a LRF for Q1, . . . , Qk, iff the following is feasible (over \nthe rationals) k k '' '' ' '' .(.\u00b5i, ..i, A i , c i ) . .. = ..i \u00b7 Ai . .0 = \u00b5.i \u00b7 ci (19) i=1 . Moreover, \nthe values of (.0,.) in the solutions of (19) de.ne the set of all LRFs for Q1, . . . , Qk. Proof. Immediate \nby Lemma 4.22, noting that for each i the con\u00ad. straints .(\u00b5.i, .i , c i ) use different ..) are .i, \nA '' '' \u00b5i and ..i, while (.0, the same for all i. COROLLARY 4.24. The LI N RF(Q) problem for MLC loops \nis PTIME-decidable. Proof. The size of the set of inequalities (19) is polynomial in the size of the \ninput MLC loop, and checking if it has a rational solution can be done in polynomial time.  COROLLARY \n4.25. The LI N RF(Z) problem for MLC loops is PTIME-decidable when each path corresponds to one of the \nspecial cases, for SLC loops, discussed in secs. 4.1 and 4.2. Proof. Immediate, since if the transition \npolyhedra are integral, LI N RF(Z) and LINRF(Q) are equivalent. EXAMPLE 4.26. Consider an MLC loop with \nthe following two paths: Loop (1) of Sec. 1; and the loop of Ex. 4.12. Applying LI N RF(Q) (as in Lemma \n4.23) does not .nd a LRF since both paths do not terminate when the variables range over Q. If we .rst \ncompute the integer hull of both paths, LINRF(Q) .nds the LRF f(x1, x2) = 3x1 +x2 -2. Note that the integer \nhull of the .rst path is computable in polynomial-time since the condition is PTVPI and the update is \nlinear with integer coef.cients. That of the second path is also computable in polynomial-time as in \nEx. 4.12. 5. Prototype Implementation The different algorithms presented in this paper, both for the \ngen\u00aderal case and the special PTIME cases, have been implemented. The tool receives as input an MLC loop \nin constraints representa\u00adtion, and allows applying LINRF(Z) or LINRF(Q). It can be tried out via http://www.loopkiller.com/irankfinder, \nwhere all examples of this paper are also available. The implementation in\u00adcludes the algorithms of Lemmas \n3.19 and 4.23. By default it uses the second one since the .rst one requires generating the generator \nrepresentation of the transition polyhedron, which is exponential. Computing the integer hull of a polyhedron, \nin the case of LI N RF(Z), is done by .rst decomposing its set of inequalities into independent sets, \nand then computing the integer hull of each set separately. Each set of inequalities is .rst matched \nagainst one of the PTIME cases of secs. 4.1 and 4.2. If this matching fails, it computes the integer \nhull using Hartmann s algorithm [28] as ex\u00ad plained by Charles et al. [18]. Note that this algorithm \nsupports only bounded polyhedra, the integer hull of an unbounded polyhe\u00addron is computed by considering \na corresponding bounded one [41, Th. 16.1, p. 231]. In addition, for octagonal relations, it gives the \npossibility of computing the tight closure instead of the integer hull. As we have seen in Sec. 4.3, \nwhen this option is used, completeness of LIN RF(Z) is not guaranteed. The Parma Polyhedra Library [5] \nis used for converting between generator and constraints represen\u00adtations, solving (mixed) LP problems, \netc. 6. Related work There are several works [3, 20, 36, 38, 42] that directly address the LI N RF(Q) \nproblem for SLC or MLC loops. In all these works, the underlying techniques allow synthesizing LRFs and \nnot only deciding if one exists. The common observation to all these works is that synthesising LRFs \ncan be done by inferring the implied inequalities of a given polyhedron (the transition polyhedron of \nthe loop), in particular inequalities like conditions (4) and (5) of Def. 2.3 that de.ne a LRF . Regarding \ncompleteness, all these methods are complete for LI N RF(Q) but not for LI NRF(Z). They can also be used \nto approximate LINRF(Z) by relaxing the loop such that its variables range over Q instead of Z, thus \nsacri.cing completeness. All these methods have a corresponding PTIME algorithm. Exceptions in this line \nof research are the work of Bradley et al. [13] and Cook et al. [22] that directly address the LI N RF(Z) \nproblem for MLC loops. Sohn and Van Gelder [42] considered MLC loops with vari\u00adables ranging over N. \nThese are abstractions of loops from logic programs. The loops were, in fact, relaxed from N to Q+ before \nseeking a LRF , however, this is not explicitly mentioned. The main observation is that the duality theorem \nof LP [41, p. 92] can be used to infer inequalities that are implied by the transition poly\u00adhedron. The \nauthors also mention that this was observed before by Lassez [33] in the context of solving CLP(R) queries. \nCom\u00adpleteness was not addressed in this work, and the PTIME com\u00adplexity was mentioned but not formally \naddressed. Later, Mes\u00adnard and Serebrenik [36] formally proved that the techniques of Sohn and Van Gelder \n[42] provide a complete PTIME method for LI NRF(Q), also for the case of MLC loops. They pointed out \nthe incompleteness for LI N RF(Z). Probably the most popular work on the synthesis of LRFs is the one \nof Podelski and Rybalchenko [38]. They also observed the need for deriving inequalities implied by the \ntransition polyhedron, but instead of using the duality theorem of LP they used the af.ne form of Farkas \nlemma [41, p. 93]. Completeness was claimed, and the statement did not make it clear that the method \nis complete for LI NRF(Q) but not for LI N RF(Z). This was clari.ed, however, in the PhD thesis of Rybalchenko \n[40]. Bagnara et al. [6] proved that the methods of Sohn and Van Gelder [36] and Podelski and Rybalchenko \n[38] are actually equiv\u00ad alent, i.e., they compute the same set of LRFs. They also showed that the method \nof Podelski and Rybalchenko can, potentially, be more ef.cient since it requires solving rational constraints \nsystems with fewer variables and constraints. The earliest appearances of a solution based on Farkas \nLemma, that we know of, are by Col \u00b4on and Sipma [20], in the context of ter\u00ad mination analysis, and \nby Feautrier [25], in the context of automatic parallelization of computations. Col \u00b4on and Sipma did \nnot claim that the problem can be solved in polynomial time, and indeed their im\u00adplementation seems to \nhave exponential complexity since they use generators and polars, despite the similarity of the underlying \nthe\u00adory to that of [38]. Completeness was claimed, however it was not explicitly mentioned that the variables \nrange over Qand not Z. Feautrier [25] described scheduling of computations that can be described by recursive \nequations. An abstraction to a form similar to an MLC loop allowed him to compute a so-called schedule, \nwhich is essentially a ranking function, but used backwards, since the computations at the bottom of \nthe recursion tree are to be completed .rst. Cook et al. [22] observed that the Farkas-lemma based solution \nis complete for LIN RF(Z) when the input MLC loop is speci.ed by integer polyhedra. They also mention \nthat any polyhedron can be converted to an integer one, and that this might increase its size exponentially. \nUnlike our work, they do not address PTIME cases or the complexity of LI N RF(Z). In fact, the main issue \nin that work is the synthesis of ranking functions for bit-victors relations. Bradley et al. [13] directly \naddressed the LIN RF(Z) prob\u00adlem for MLC loops, and stated that the methods of Col \u00b4on and Sipma [20] \nand Podelski and Rybalchenko [38] are not complete for LI N RF(Z). Their technique is based on the observation \nthat if there is a LRF , then there exists one in which each coef.cient .i has a value in the interval \n[-1, 1], and moreover with denomi\u00adnators that are power of 2. Using this observation, they recursively \nsearch for the coef.cients starting from a region de.ned by a hyper\u00adrectangle in which each .i is in \nthe interval [-1, 1]. Given a hyper\u00adrectangle, the algorithm .rst checks if one of its corners de.nes \na LRF , in which case it stops. Otherwise, the region is either pruned (if it can be veri.ed that it \ncontains no solution), or divided into smaller regions for recursive search. Testing if a region should \nbe pruned is done by checking the satis.ability of a possibly exponen\u00adtial (in the number of variables) \nnumber of Presburger formulas. The algorithm will .nd a LRF if exists, but it might not terminate if \nno LRF exists. To make it practical, it is parametrized by the search depth, thus sacri.cing completeness. \nIt is interesting to note that the search-depth parameter in their algorithm actually bounds the bit-size \nof the LRF coef.cients. Our Cor. 3.21 shows that it is possible to deterministically bound this depth, \nthat turning their algorithm into a complete one, though still exponential.  Codish et al. [19] studied \nthe synthesis of LRFs for SLC loops with size-change constraints (i.e., of the form xi = xj ' + c where \nc . {0, 1}), and monotonicity constraints (i.e., of the form X = Y + c, where X and Y are variables or \nprimed variables, and c . {0, 1}). In both cases the variables ranged over N. For size\u00adchange constraints, \nthey proved that the loop terminates iff a LRF exists, moreover, such function has the form .i \u00b7 xi with \n.i . {0, 1}. For the case of monotonicity constraints, they proved that the loop terminates iff a LRF \nexists for the balanced version of the loop, and has the form .i \u00b7 xi with .i . {0, \u00b11}. Intuitively, \na balanced loop includes xi ' = xj ' +c iff it includes xi = xj +c. They showed how to balance the loop \nwhile preserving its termination behavior. Recently, Bozga et al. [10] presented similar results for \nSLC loops de.ned by octagonal relations. Bradley et al. [12] extended the work of Col \u00b4 on and Sipma \n[20] and searched lexicographic LRFs. In [14, 15] they considered mul\u00ad tipath loops with polynomial transitions \nand the synthesis of lexico\u00adgraphic polynomial ranking functions, where the notion of ranking functions \nwas also relaxed to functions that eventually decrease. Cousot [23] used Lagrangian relaxation for inferring \npossibly non\u00ad linear ranking functions. In the linear case, Lagrangian relaxation is similar to the af.ne \nform of Farkas lemma. Alias et al. [3] again rediscovered the Farkas-lemma based solu\u00ad tion for LIN RF(Q), \nor rather ported it from the former work by Feautrier, but this time for termination and cost analysis. \nLike [12], they construct lexicographic LRFs, however, they do it for pro\u00adgrams with an arbitrary control-.ow \ngraph, and they prove com\u00adpleteness of their procedure. Their goal was to use these functions to derive \ncost bounds (like a bound on the worst-case number of transitions in terms of the initial state); this \nbound is (when it can be found) a polynomial, whose degree is at most the dimension of the (co-domain \nof the) lexicographic ranking function. Alias et al. s construction produces a function of minimum dimension. \nThey, too, have relaxed the problem from integers to rationals and failed to state that their completeness \nresults depend on this relaxation. Decidability and complexity of termination (in general, not nec\u00adessarily \nwith LRFs) of SLC and MLC loops has been intensively studied for different classes of constraints. For \nSLC loops, Ti\u00adwari [45] proved that the problem is decidable when the update is linear and the variables \nrange over R. Braverman [16] proved that this holds also for Q, and for the homogeneous case it holds \nfor Z. Both considered universal termination. Also, in both cases they allow the use of strict inequalities \nin the condition. Ben-Amram et al. [9] showed that the termination of SLC loops is at least EXPSPACE-hard, \nand that the problem is undecidable for some extensions that introduce a simple form of non-linearity; \nand also for SLC loops in which the use of a single irrational coef.cient is allowed. See these works \nfor references to additional results on the decidability of termination in other types of loops. 7. Concluding \nremarks We have studied the Linear Ranking problem for single-path and multipath linear constraint loops \nand observed the difference be\u00adtween the LINRF(Q) problem, where variables range over the ra\u00adtionals, \nand the LI N RF(Z) problem, where variables only take in\u00adteger values. In practice, the latter is more \ncommon, but the com\u00adplexity of the problem has not been studied before; the common approach has been \nto relax the problem to the rationals, where com\u00adplete, polynomial-time decision procedures have been \nknown. We have con.rmed that LI N RF(Z) is a harder problem, proving it to be coNP-complete. On a positive \nnote, this shows that there is a complete solution, even if exponential-time. We further showed that \nsome special cases of importance do have a PTIME solution. The latter results arise from a proof that \nfor integer polyhedra, LI NRF(Z) and LI N RF(Q) are equivalent. Interestingly, this is not the case for \ntermination in general. For example, the transition polyhedron of the loop while x = 0 do x ' = 10 -2x \nis integral; the loop terminates when the variables range over Z but does not terminate when they range \nover Q, speci.cally for x = 3 3 1 . Note that this loop does not have a LRF over the integers. A more \ngeneral notion of ranking function applies to an arbi\u00adtrary control-.ow graph with transitions speci.ed \nby source and target nodes as well as linear constraints on the values of variables. In this setting, \none seeks to associate a (possibly different) af.ne function .. with each node ., so that on a transition \nfrom . to . ' we have .. (x) > .. (x ' ). Such functions can be found by LP, a procedure complete over \nthe rationals, using a simple extension of the solution for the loops we have discussed [3, 36]. The \nconsider\u00ad ations regarding the complexity of the corresponding problem over integers are essentially \nthe same as those we have presented, and we preferred to use the simpler model for clearer presentation. \nIn all examples that we have discussed in this paper, when a loop has a LRF over Z but not over Q, then \nthe loop did not terminate over Q. This is, however, not the case in general. A counter-example can be \nconstructed by combining (i.e., executing simultaneously) the loop of Ex. 3.6 and Loop (1) of Sec. 1. \nIn the context of complexity (cost) analysis, there is a special interest in LRFs that decrease at least \nby 1 in each iteration, since they bound the number of iterations of a given loop. In order to get tight \nbounds, even if Q has a LRF it might be worthwhile to compute one for I(Q). To see this, let us add 4x1 \n= 3 to the condition of Loop (1) in Sec. 1. Then, both Q and I(Q) have LRFs. For I(Q) the most tight \none (under the requirement to decrease by at least 1) is f1(x1, x2) = x1 + x2 - 1, while for Q it is \nf2(x1, x2) = 2x1 + 2x2 - 2. Hence, a better bound is obtained using I(Q). The same observation applies \nto loop parallelization: the functions value gives the schedule s latency (depth of the computation tree) \nand a lower value is preferable. Acknowledgments We thank Alain Darte for a helpful discussion. The work \nof Samir Genaim was funded in part by the EU project ICT-231620 HATS, and the Spanish projects TIN-2008-05624 \nDOVES and TIN-2012\u00ad38137 VIVAC. References [1] E. Albert, P. Arenas, S. Genaim, G. Puebla, and D. Zanardini. \nCosta: Design and implementation of a cost and termination analyzer for java bytecode. In F. S. de Boer, \nM. M. Bonsangue, S. Graf, and W. P. de Roever, editors, Formal Methods for Components and Objects, FMCO \n07, volume 5382 of LNCS, pages 113 132. Springer, 2007. [2] E. Albert, P. Arenas, S. Genaim, and G. Puebla. \nClosed-form upper bounds in static cost analysis. J. Autom. Reasoning, 46(2):161 203, 2011. [3] C. Alias, \nA. Darte, P. Feautrier, and L. Gonnord. Multi-dimensional rankings, program termination, and complexity \nbounds of .owchart programs. In R. Cousot and M. Martel, editors, Static Analysis Sympo\u00adsium, SAS 10, \nvolume 6337 of LNCS, pages 117 133. Springer, 2010. [4] R. Bagnara, P. M. Hill, and E. Zaffanella. An \nimproved tight closure al\u00adgorithm for integer octagonal constraints. In F. Logozzo, D. Peled, and L. \nD. Zuck, editors, Veri.cation, Model Checking, and Abstract Inter\u00adpretation, VMCAI 08, volume 4905 of \nLNCS, pages 8 21. Springer, 2008. [5] R. Bagnara, P. M. Hill, and E. Zaffanella. The parma polyhedra \nlibrary: Toward a complete set of numerical abstractions for the analysis and veri.cation of hardware \nand software systems. Sci. Comput. Program., 72(1-2):3 21, 2008.  [6] R. Bagnara, F. Mesnard, A. Pescetti, \nand E. Zaffanella. A new look at the automatic synthesis of linear ranking functions. Inf. Comput., 215: \n47 67, 2012. [7] A. M. Ben-Amram. Size-change termination with difference con\u00adstraints. ACM Trans. Program. \nLang. Syst., 30(3), 2008. [8] A. M. Ben-Amram and S. Genaim. On the linear ranking problem for integer \nlinear-constraint loops. CoRR, abs/1208.4041, 2012. [9] A. M. Ben-Amram, S. Genaim, and A. N. Masud. \nOn the termination of integer loops. In V. Kuncak and A. Rybalchenko, editors, Veri.\u00adcation, Model Checking, \nand Abstract Interpretation, VMCAI 12, vol\u00adume 7148 of LNCS, pages 72 87. Springer, 2012. [10] M. Bozga, \nR. Iosif, and F. Konecn \u00b4y. Deciding conditional termination. In C. Flanagan and B. K \u00a8 onig, editors, \nTools and Algorithms for the Construction and Analysis of Systems, TACAS 12, volume 7214 of LNCS, pages \n252 266. Springer, 2012. [11] L. Bozzelli and S. Pinchinat. Veri.cation of gap-order constraint abstractions \nof counter systems. In V. Kuncak and A. Rybalchenko, editors, Veri.cation, Model Checking, and Abstract \nInterpretation, VMCAI 12, volume 7148 of LNCS, pages 88 103. Springer, 2012. [12] A. R. Bradley, Z. Manna, \nand H. B. Sipma. Linear ranking with reachability. In K. Etessami and S. K. Rajamani, editors, Computer \nAided Veri.cation, CAV 05, volume 3576 of LNCS, pages 491 504. Springer, 2005. [13] A. R. Bradley, Z. \nManna, and H. B. Sipma. Termination analysis of integer linear loops. In M. Abadi and L. de Alfaro, editors, \nConcur\u00adrency Theory, CONCUR 2005, volume 3653 of LNCS, pages 488 502. Springer, 2005. [14] A. R. Bradley, \nZ. Manna, and H. B. Sipma. The polyranking prin\u00adciple. In L. Caires, G. F. Italiano, L. Monteiro, C. \nPalamidessi, and M. Yung, editors, International Colloquium on Automata, Languages and Programming, ICALP \n05, volume 3580 of LNCS, pages 1349 1361. Springer, 2005. [15] A. R. Bradley, Z. Manna, and H. B. Sipma. \nTermination of polynomial programs. In R. Cousot, editor, Veri.cation, Model Checking, and Abstract Interpretation, \nVMCAI 05, volume 3385 of LNCS, pages 113 129. Springer, 2005. [16] M. Braverman. Termination of integer \nlinear programs. In T. Ball and R. B. Jones, editors, Computer Aided Veri.cation, CAV 06, volume 4144 \nof LNCS, pages 372 385. Springer, 2006. [17] M. Bruynooghe, M. Codish, J. P. Gallagher, S. Genaim, and \nW. Van\u00adhoof. Termination analysis of logic programs through combination of type-based norms. ACM Trans. \nProgram. Lang. Syst., 29(2), 2007. [18] P. J. Charles, J. M. Howe, and A. King. Integer polyhedra for \nprogram analysis. In A. V. Goldberg and Y. Zhou, editors, Algorithmic Aspects in Information and Management, \nAAIM 09, volume 5564 of LNCS, pages 85 99. Springer, 2009. [19] M. Codish, V. Lagoon, and P. J. Stuckey. \nTesting for termination with monotonicity constraints. In M. Gabbrielli and G. Gupta, editors, International \nConference on Logic Programming, ICLP 05, volume 3668 of LNCS, pages 326 340. Springer, 2005. [20] M. \nCol \u00b4on and H. Sipma. Synthesis of linear ranking functions. In T. Margaria and W. Yi, editors, Tools \nand Algorithms for the Con\u00adstruction and Analysis of Systems, TACAS 01, volume 2031 of LNCS, pages 67 \n81. Springer, 2001. [21] B. Cook, A. Podelski, and A. Rybalchenko. Termination proofs for systems code. \nIn M. I. Schwartzbach and T. Ball, editors, Program\u00adming Language Design and Implementation, PLDI 06, \npages 415 426. ACM, 2006. [22] B. Cook, D. Kroening, P. R \u00a8ummer, and C. M. Wintersteiger. Ranking function \nsynthesis for bit-vector relations. In J. Esparza and R. Majum\u00addar, editors, Tools and Algorithms for \nthe Construction and Analysis of Systems, 16th International Conference, TACAS 10, volume 6015 of LNCS, \npages 236 250. Springer, 2010. [23] P. Cousot. Proving program invariance and termination by parametric \nabstraction, lagrangian relaxation and semide.nite programming. In R. Cousot, editor, Veri.cation, Model \nChecking, and Abstract Inter\u00adpretation, VMCAI 05, volume 3385 of LNCS, pages 1 24, 2005. [24] A. Darte. \nUnderstanding loops: The in.uence of the decomposition of Karp, Miller, and Winograd. In Formal Methods \nand Models for Codesign, MEMOCODE 10, pages 139 148. IEEE Computer Society, 2010. [25] P. Feautrier. \nSome ef.cient solutions to the af.ne scheduling problem. I. one-dimensional time. International Journal \nof Parallel Program\u00adming, 21(5):313 347, 1992. [26] M. R. Garey and D. S. Johnson. Computers and Intractability. \nW.H. Freeman and Co., New York, 1979. [27] J. Giesl, R. Thiemann, P. Schneider-Kamp, and S. Falke. Automated \ntermination proofs with aprove. In V. van Oostrom, editor, Rewriting Techniques and Applications, RTA \n04, volume 3091 of LNCS, pages 210 220. Springer, 2004. [28] M. E. Hartmann. Cutting Planes and the Complexity \nof the Integer Hull. PhD thesis, School of Operations Research and Industrial Engi\u00adneering, Cornell University, \n1988. [29] W. Harvey. Computing two-dimensional integer hulls. SIAM J. Comput., 28(6):2285 2299, 1999. \n[30] W. Harvey and P. J. Stuckey. A unit two variable per inequality integer constraint solver for constraint \nlogic programming. In Australasian Computer Science Conference, ACSC 97, pages 102 111, 1997. [31] R. \nM. Karp. Reducibility among combinatorial problems. In R. E. Miller and J. W. Thatcher, editors, Complexity \nof Computer Computa\u00adtions, pages 85 103. Plenum Press, New York, 1972. [32] R. M. Karp and C. H. Papadimitriou. \nOn linear characterizations of combinatorial optimization problems. In Symp. on Foundations of Computer \nScience, FOCS 80, pages 1 9. IEEE Computer Society, 1980. [33] J.-L. Lassez. Querying constraints. In \nSymposium on Principles of Database Systems, pages 288 298. ACM Press, 1990. [34] C. S. Lee, N. D. Jones, \nand A. M. Ben-Amram. The size-change prin\u00adciple for program termination. In C. Hankin and D. Schmidt, \nedi\u00adtors, Symposium on Principles of Programming Languages, POPL 01, pages 81 92, 2001. [35] N. Lindenstrauss \nand Y. Sagiv. Automatic termination analysis of Prolog programs. In L. Naish, editor, International Conference \non Logic Programming, ICLP 97, pages 64 77. MIT Press, 1997. [36] F. Mesnard and A. Serebrenik. Recurrence \nwith af.ne level mappings is p-time decidable for clp(r). TPLP, 8(1):111 119, 2008. [37] A. Min \u00b4e. The \noctagon abstract domain. Higher-Order and Symbolic Computation, 19(1):31 100, Mar. 2006. [38] A. Podelski \nand A. Rybalchenko. A complete method for the syn\u00adthesis of linear ranking functions. In B. Steffen and \nG. Levi, editors, Veri.cation, Model Checking, and Abstract Interpretation, VMCAI 04, volume 2937 of \nLNCS, pages 239 251. Springer, 2004. [39] P. Z. Revesz. Tightened transitive closure of integer addition \ncon\u00adstraints. In V. Bulitko and J. C. Beck, editors, Symposium on Abstrac\u00adtion, Reformulation, and Approximation, \nSARA 09, 2009. [40] A. Rybalchenko. Temporal Veri.cation with Transition Invariants. PhD thesis, Universit \n\u00a8at des Saarlandes, 2004. [41] A. Schrijver. Theory of Linear and Integer Programming. John Wiley and \nSons, New York, 1986. [42] K. Sohn and A. V. Gelder. Termination detection in logic programs using argument \nsizes. In D. J. Rosenkrantz, editor, Symposium on Principles of Database Systems, pages 216 226. ACM \nPress, 1991. \u00b4bytecode based on path-length. ACM Trans. Program. Lang. Syst., 32 (3), 2010. [43] F. Spoto, \nF. Mesnard, and E. Payet. A termination analyzer for java \u00b4 linear programs. Operations Research, 34:250 \n256, 1986. [44] Eva. Tardos. A strongly polynomial algorithm to solve combinatorial [45] A. Tiwari. \nTermination of linear programs. In R. Alur and D. Peled, editors, Computer Aided Veri.cation, CAV 04, \nvolume 3114 of LNCS, pages 387 390. Springer, 2004.   \n\t\t\t", "proc_id": "2429069", "abstract": "<p>In this paper we study the complexity of the Linear Ranking problem: given a loop, described by linear constraints over a finite set of integer variables, is there a linear ranking function for this loop? While existence of such a function implies termination, this problem is not equivalent to termination. When the variables range over the rationals or reals, the Linear Ranking problem is known to be PTIME decidable. However, when they range over the integers, whether for single-path or multipath loops, the complexity of the Linear Ranking problem has not yet been determined. We show that it is coNP-complete. However, we point out some special cases of importance of PTIME complexity. We also present complete algorithms for synthesizing linear ranking functions, both for the general case and the special PTIME cases.</p>", "authors": [{"name": "Amir M. Ben-Amram", "author_profile_id": "81100295679", "affiliation": "The Tel-Aviv Academic College, Tel Aviv, Israel", "person_id": "P3977915", "email_address": "amirben@mta.ac.il", "orcid_id": ""}, {"name": "Samir Genaim", "author_profile_id": "81100429035", "affiliation": "Complutense University of Madrid, Madrid, Spain", "person_id": "P3977916", "email_address": "samir.genaim@fdi.ucm.es", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429078", "year": "2013", "article_id": "2429078", "conference": "POPL", "title": "On the linear ranking problem for integer linear-constraint loops", "url": "http://dl.acm.org/citation.cfm?id=2429078"}