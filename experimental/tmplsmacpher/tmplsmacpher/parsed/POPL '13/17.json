{"article_publication_date": "01-23-2013", "fulltext": "\n Meta-Theory ` a la Carte Benjamin Delaware Bruno C. d. S. Oliveira Tom Schrijvers University of Texas \nat Austin National University of Singapore Universiteit Gent bendy@cs.utexas.edu oliveira@comp.nus.edu.sg \ntom.schrijvers@ugent.be Abstract Formalizing meta-theory, or proofs about programming languages, in \na proof assistant has many well-known bene.ts. Unfortunately, the considerable effort involved in mechanizing \nproofs has pre\u00advented it from becoming standard practice. This cost can be amor\u00adtized by reusing as much \nof existing mechanized formalizations as possible when building a new language or extending an existing \none. One important challenge in achieving reuse is that the induc\u00adtive de.nitions and proofs used in \nthese formalizations are closed to extension. This forces language designers to cut and paste ex\u00adisting \nde.nitions and proofs in an ad-hoc manner and to expend considerable effort to patch up the results. \nThe key contribution of this paper is the development of an in\u00adduction technique for extensible Church \nencodings using a novel reinterpretation of the universal property of folds. These encodings provide \nthe foundation for a framework, formalized in Coq, which uses type classes to automate the composition \nof proofs from mod\u00adular components. This framework enables a more structured ap\u00adproach to the reuse of \nmeta-theory formalizations through the com\u00adposition of modular inductive de.nitions and proofs. Several \ninteresting language features, including binders and general recursion, illustrate the capabilities of \nour framework. We reuse these features to build fully mechanized de.nitions and proofs for a number of \nlanguages, including a version of mini-ML. Bounded induction enables proofs of properties for non-inductive \nsemantic functions, and mediating type classes enable proof adap\u00adtation for more feature-rich languages. \nCategories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory Semantics \nKeywords Modular Mechanized Meta-Theory, Extensible Church Encodings, Coq 1. Introduction With their \nPO P L MA R K challenge, Aydemir et al. [3] identi.ed rep\u00adresentation of binders, complex inductions, \nexperimentation, and reuse of components as key challenges in mechanizing program\u00adming language meta-theory. \nWhile progress has been made, for ex\u00adample on the representation of binders, it is still dif.cult to \nreuse components, including language de.nitions and proofs. The current approach to reuse still involves \ncopying an exist\u00ading formalization and adapting it manually to incorporate new fea- Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 13, January 23 25, \n2013, Rome, Italy. Copyright c &#38;#169; 2013 ACM 978-1-4503-1832-7/13/01. . . $10.00 tures. An extreme \ncase of this copy-&#38;-adapt approach can be found in Leroy s three person-year veri.ed compiler project \n[22], which consists of eight intermediate languages in addition to the source and target languages, \nmany of which are minor variations of each other. Due to the crosscutting impact of new features, the \nadapta\u00adtion of existing features is unnecessarily labor-intensive. Moreover, from a software/formalization \nmanagement perspective a prolifer\u00adation of copies is obviously a nightmare. Typical formalizations present \ntwo important challenges to providing reuse: 1. Extensibility: Conventional inductive de.nitions and \nproofs are closed to extension and cannot simply be imported and ex\u00adtended with new constructors and \ncases. This is a manifestation of the well-known Expression Problem (EP) [45]. 2. Modular reasoning: \nReasoning with modular de.nitions re\u00adquires reasoning about partial de.nitions and composing partial \nproofs to build a complete proof. However, conventional induc\u00adtion principles which are the fundamental \nreasoning techniques in most theorem provers only work for complete de.nitions.  The lack of reuse in \nformalizations is somewhat surprising, because proof assistants such as Coq and Agda have powerful modularity \nconstructs including modules [26], type classes [17, 42, 46] and expressive forms of dependent types \n[11, 34]. It is reasonable to wonder whether these language constructs can help to achieve better reuse. \nAfter all, there has been a lot of progress in addressing extensibility [14, 30, 32, 43] issues in general-purpose \nlanguages using advanced type system features although not a lot of attention has been paid to modular \nreasoning. This paper presents MTC, a framework for de.ning and reason\u00ading about extensible inductive \ndatatypes. The framework is imple\u00admented as a Coq library which enables modular mechanized meta\u00adtheory \nby allowing language features to be de.ned as reusable com\u00adponents. Using MTC, language developers can \nleverage existing efforts to build new languages by developing new and interesting features and combining \nthem with previously written components. The solution to extensibility in MTC was partly inspired by \nthe popular Data types ` a la Carte (DTC) [43] technique. How\u00adever, DTC fundamentally relies on a type-level \n.xpoint de.nition for building modular data types, which cannot be encoded in Coq. MTC solves this problem \nby using (extensible) Church encodings of data types [30, 34, 35]. These encodings allow DTC-style mod\u00adular \ndata types to be de.ned in the restricted Coq setting. Another difference between DTC and MTC is the \nuse of Mendler-style folds and algebras instead of conventional folds to express modular def\u00adinitions. \nThe advantage of Mendler-style folds [44] and algebras is that they offer explicit control over the evaluation \norder, which is important when modeling semantics of programming languages. MTC employs similar techniques \nto solve extensibility problems in proofs and inductively de.ned predicates. MTC s solution to modular \nreasoning uses a novel reinterpre\u00adtation of the universal property of folds. Because MTC relies on folds, \nthe proof methods used in the initial algebra semantics of data types [16, 27] offer an alternative to \nstructural induction. With some care, universal properties can be exploited to adapt these tech\u00adniques \nto modular Church encodings. In addition to enabling mod\u00adular reasoning about extensible inductive datatypes, \nuniversal prop\u00aderties also overcome some theoretical issues related to Church en\u00adcodings in the Calculus \nof (Inductive) Constructions [34, 35].  MTC also supports ubiquitous higher-order language features \nsuch as binders and general recursion. Binders are modeled with a parametric HOAS [8] representation \n(a .rst-order representation would be possible too). Because these features require general re\u00adcursion, \nthey cannot be de.ned inductively using folds. To support these non-inductive features MTC uses a variation \nof mixins [10]. Mixins are closely related to Mendler-style folds, but they allow uses of general recursion, \nand can be modeled on top of Mendler\u00adstyle Church encodings using a bounded .xpoint combinator. To illustrate \nthe utility of MTC, we present a case study modu\u00adlarizing several orthogonal features of a variant of \nmini-ML [9]. The case study illustrates how various features and partial type soundness proofs can be \nmodularly developed and veri.ed and later composed to assemble complete languages and proofs. 1.1 Contributions \nThe main contribution of our work is a novel approach to de.ning and reasoning about extensible inductive \ndatatypes. MTC is a Coq framework for building reusable components that implements this approach to modular \nmechanized meta-theory. More technically this paper makes the following contributions: Extensibility \nTechniques for Mechanization: The paper pro\u00advides a solution to the EP and an approach to extensible \nmecha\u00adnization of meta-theory in the restricted type-theoretic setting of Coq. This solution offers precise \ncontrol over the evaluation or\u00adder by means of Mendler folds and algebras. Mixins are used to capture \nubiquitous higher-order features, like PHOAS binders and general recursion.  Non-Axiomatic Reasoning \nfor Church Encodings: The paper reinterprets the universal property of folds to recover induction principles \nfor Mendler-style Church encodings. This allows us to avoid the axioms used in earlier approaches and \npreserves Coq s strong normalization.  Modular Reasoning: The paper presents modular reasoning techniques \nfor modular components. It lifts the recovered in\u00adduction principle from individual inductive features \nto compo\u00adsitions, while induction over a bounded step count enables mod\u00adular reasoning about non-inductive \nhigher-order features mod\u00adeled with mixins.  MTC is implemented in the Coq proof assistant and the code \nis available at http://www.cs.utexas.edu/~bendy/MTC. Our implementation minimizes the user s burden for \nadding new fea\u00adtures by automating the boilerplate with type classes and default tactics. Moreover, the \nframework already provides modular com\u00adponents for mini-ML as a starting point for new language formal\u00adizations. \nWe also provide a complimentary Haskell implementation of the computational subset of code used in this \npaper.  1.2 Code and Notational Conventions While all the code underlying this paper has been developed \nin Coq, the paper adopts a terser syntax for its code fragments. For the com\u00adputational parts, this syntax \nexactly coincides with Haskell syntax, while it is an extrapolation of Haskell syntax for proof-related \ncon\u00adcepts. The Coq code requires the impredicative-set option. 2. Extensible Semantics in M TC This section \nshows MTC s approach to extensible and modular se\u00admantic components in the restrictive setting of Coq. \nThe approach is partly inspired by the DTC solution to the Expression Problem in Haskell, in particular \nits composition mechanisms for extensible in\u00adductive de.nitions. MTC differs from DTC in two important \nways. Firstly, it uses Church encodings to avoid the termination issues of DTC s generally recursive \nde.nitions. Secondly, it uses Mendler\u00adstyle folds instead of conventional folds to provide explicit control \nover evaluation order. 2.1 Data Types `a la Carte This subsection reviews the core ideas of DTC. DTC \nrepresents the shape of a particular data type as a functor. That functor uses its type parameter a for \ninductive occurrences of the data type, leaving the data type de.nition open. Arith F is an example functor \nfor a simple arithmetic expression language with literals and addition. data Arith F a = Lit Nat | Add \na a The explicitly recursive de.nition FixDTC f closes the open re\u00adcursion of a functor f . data FixDTC \nf = In (f (FixDTC f )) Applying FixDTC to Arith F builds the data type for arithmetic expressions. type \nArith = FixDTC Arith F Functions over FixDTC f are expressed as folds of f -algebras. type Algebra f \na = f a . a foldDTC :: Functor f . Algebra f a . FixDTC f . a foldDTC alg (In fa ) = alg (fmap (foldDTC \nalg) fa) For example, the evaluation algebra of Arith F is de.ned as: data Value = I Int | B Bool evalArith \n:: Algebra Arith F Value evalArith (Lit n ) = I n evalArith (Add (I v1) (I v2)) = I (v1 + v2) Note that \nthe recursive occurrences in evalArith are of the same type as the result type Value . 1 In essence, \nfolds process the recur\u00adsive occurrences so that algebras only need to specify how to com\u00adbine the values \n(for example v1 and v2) resulting from evaluating the subterms. Finally, the overall evaluation function \nis: [\u00b7] :: FixDTC Arith F . Value [\u00b7] = foldDTC evalArith > [(Add (Lit 1) (Lit 2))] 3 Unfortunately, \nDTC s two uses of general recursion are not permit\u00adted in Coq. Coq does not accept the type-level .xpoint \ncombinator FixDTC f because it is not strictly positive. Coq similarly disal\u00adlows the foldDTC function \nbecause it is not structurally recursive.  2.2 Recursion-Free Church Encodings MTC encodes data types \nand folds with Church encodings [6, 35], which are recursion-free. Church encodings represent (least) \n.xpoints and folds as follows: type Fix f = .a.Algebra f a . a fold :: Algebra f a . Fix f . a fold alg \nfa = fa alg 1 Boolean values are not needed yet, but they are used later in this section.  Both de.nitions \nare non-recursive and can be encoded in Coq (although we need to enable impredicativity for certain de.nitions). \nSince Church encodings represent data types as folds, the de.nition of fold is trivial: it applies the \nfolded Fix f data type to the algebra. Example Church encodings of ArithF s literals and addition are \ngiven by the lit and add functions: lit :: Nat . Fix ArithF lit n = .alg . alg (Lit n) add :: Fix ArithF \n. Fix ArithF . Fix ArithF add e1 e2 = .alg . alg (Add (fold alg e1) (fold alg e2)) The evaluation algebra \nand evaluation function are de.ned as in DTC, and expressions are evaluated in much the same way.  2.3 \nLack of Control over Evaluation Folds are structurally recursive and therefore capture composition\u00adality \nof de.nitions, a desirable property of semantics. A disadvan\u00adtage of the standard fold encoding is that \nit does not provide the implementer of the algebra with explicit control of evaluation. The fold encoding \nreduces all subterms; the only freedom in the algebra is whether or not to use the result. Example: Modeling \nif expressions As a simple example that illustrates the issue of lack of control over evaluation consider \nmodeling if expressions and their corresponding semantics. The big-step semantics of if expressions is: \n[e1] true [e2] v2 [e1] false [e3] v3 [ if e1 e2 e3] v2 [ if e1 e2 e3] v3 Using our framework of Church \nencodings, we could create a modular feature for boolean expressions such as if expressions and boolean \nliterals as follows: data LogicF a = If a a a | BLit Bool --Boolean functor evalLogic :: Algebra LogicF \nValue evalLogic (If v1 v2 v3) = if (v1 = B True) then v2 else v3 evalLogic (BLit b) = B b However, an \nimportant difference with the big-step semantics above is that evalLogic cannot control where evaluation \nhappens. All it has in hand are the values v1, v2 and v3 that result from eval\u00aduation. While this difference \nis not important for simple features like arithmetic expressions, it does matter for if expressions. \nSemantics guides the development of implementations. Accord\u00adingly, we believe that it is important that \na semantic speci.cation does not rely on a particular evaluation strategy (such as laziness). This de.nition \nof evalLogic might be reasonable in a lazy meta\u00adlanguage like Haskell (which is the language used by \nDTC), but it is misleading when used as a basis for an implementation in a strict language like ML. In \na strict language evalLogic is clearly not a desirable de.nition because it evaluates both branches of \nthe if expression. Aside from the obvious performance drawbacks, this is the wrong thing to do if the \nobject language features, for example, non-termination. Furthermore, this approach can be quite brittle: \nin more complex object languages using folds and laziness can lead to subtle semantic issues [4]. 2.4 \nMendler-style Church Encodings To express semantics in a way that allows explicit control over evaluation \nand does not rely on the evaluation semantics of the meta-language, MTC adapts Church encodings to use \nMendler\u00adstyle algebras and folds [44] which make recursive calls explicit. type AlgebraM f a = .r.(r \n. a) . f r . a A Mendler-style algebra differs from a traditional f -algebra in that it takes an additional \nargument (r . a) which corresponds to recursive calls. To ensure that recursive calls can only be applied \nstructurally, the arguments that appear at recursive positions have a polymorphic type r. The use of \nthis polymorphic type r pre\u00advents case analysis, or any other type of inspection, on those ar\u00adguments. \nUsing AlgebraM f a, Mendler-style folds and Mendler\u00adstyle Church encodings are de.ned as follows: type \nFixM f = .a.AlgebraM f a . a foldM :: AlgebraM f a . FixM f . a foldM alg fa = fa alg Mendler-style folds \nallow algebras to state their recursive calls explicitly. As an example, the de.nition of the evaluation \nof if expressions in terms of a Mendler-style algebra is: evalLogic :: AlgebraM LogicF Value evalLogic \n\u00b7 (BLit b) = B b evalLogic [ \u00b7] (If e1 e2 e3) = if ([e1] = B True) then e2 else [ e3] Note that this \nde.nition allows explicit control over the evaluation order just like the big-step semantics de.nition. \nFurthermore, like the fold-de.nition, evalLogic enforces compositionality because all the algebra can \ndo to e1, e2 or e3 is to apply the recursive call [\u00b7].  2.5 A Compositional Framework for Mendler-style \nAlgebras DTC provides a convenient framework for composing conventional fold algebras. MTC provides a \nsimilar framework, but for Mendler\u00adstyle algebras instead of f -algebras. In order to write modular proofs, \nMTC regulates its de.nitions with a number of laws. Modular Functors Individual features can be modularly \nde.ned using functors, like ArithF and LogicF . Functors are composed with the . operator: data (.) f \ng a = Inl (f a) | Inr (g a) FixM (ArithF . LogicF ) represents a data type isomorphic to: data Exp = \nLit Nat | Add Exp Exp | If Exp Exp Exp | BLit Bool Modular Mendler Algebras A type class is de.ned for \nevery semantic function. For example, the evaluation function has the following class: class Eval f where \nevalalg :: AlgebraM f Value In this class evalalg represents the evaluation algebra of a feature f . \nAlgebras for composite functor are built from feature algebras: instance (Eval f , Eval g) . Eval (f \n. g) where evalalg \u00b7 (Inl fexp) = evalalg \u00b7 fexp evalalg [ \u00b7] (Inr gexp) = evalalg [ \u00b7] gexp Overall \nevaluation can then be de.ned as: eval :: Eval f . FixM f . Value eval = foldM evalalg In order to avoid \nthe repeated boilerplate of de.ning a new type class for every semantic function and corresponding instance \nfor ., MTC de.nes a single generic Coq type class, FAlg, that is indexed by the name of the semantic \nfunction. This class de.nition can be found in Figure 3 and subsumes all other algebra classes found \nin this paper. The paper continues to use more speci.c classes to make a gentler progression for the \nreader. Injections and Projections of Functors Figure 1 shows the multi-parameter type class -:. This \nclass provides a means to lift or inject (inj ) (sub)functors f into larger compositions g and project \n(prj ) them out again. The inj prj and prj inj laws relate the  class f -: g where inj :: f a . g a \nprj :: g a . Maybe (f a) inj prj :: prj ga = Just fa . ga = inj fa --law prj inj :: prj . inj = Just \n--law instance (f -: g) . f -: (g . h) where inj fa = Inl (inj fa) prj (Inl ga) = prj ga prj (Inr ha) \n= Nothing instance (f -: h) . f -: (g . h) where inj fa = Inr (inj fa) prj (Inl ga) = Nothing prj (Inr \nha) = prj ha instance f -: f where inj fa = fa prj fa = Just fa Figure 1. Functor subtyping. injection \nand projection methods in the -: class, ensuring that the two are effectively inverses. The idea is to \nuse the type class resolu\u00adtion mechanism to encode (coercive) subtyping between functors. In Coq this \nsubtyping relation can be nicely expressed because Coq type classes [42] perform a backtracking search \nfor match\u00ading instances. Hence, highly overlapping de.nitions like the .rst and second instances are \nallowed. This is a notable difference to Haskell s type classes, which do not support backtracking. Hence, \nDTC s Haskell solution has to provide a biased choice that does not accurately model the expected subtyping \nrelationship. The inf function builds a new term from the application of f to some subterms. inf :: f \n(FixM f ) . FixM f inf fexp = .alg . alg (foldM alg) fexp Smart constructors are built using inf and \ninj as follows: inject :: (g -: f ) . g (FixM f ) . FixM f inject gexp = inf (inj gexp) lit :: (ArithF \n-: f ) . Nat . FixM f lit n = inject (Lit n) blit :: (LogicF -: f ) . Bool . FixM f blit b = inject (BLit \nb) cond :: (LogicF -: f ) . FixM f . FixM f . FixM f . FixM f cond c e1 e2 = inject (If c e1 e2) Expressions \nare built with the smart constructors and used by oper\u00adations like evaluation: exp :: FixM (ArithF . \nLogicF ) exp = cond (blit True) (lit 3) (lit 2) > eval exp The outf function exposes the toplevel functor \nagain: outf :: Functor f . FixM f . f (FixM f ) outf exp = foldM (.rec fr . fmap (inf . rec) fr) exp \nWe can pattern match on particular features using prj and outf : project :: (g -: f , Functor f ) . FixM \nf . Maybe (g (FixM f )) project exp = prj (outf exp) isLit :: (ArithF -: f , Functor f ) . FixM f . Maybe \nNat isLit exp = case project exp of Just (Lit n) . Just n Nothing . Nothing  2.6 Extensible Semantic \nValues In addition to modular language features, it is also desirable to have modular result types for \nsemantic functions. For example, it is much cleaner to separate natural number and boolean values along \nthe same lines as the ArithF and LogicF features. To easily achieve this extensibility, we make use of \nthe same sorts of exten\u00adsional encodings as the expression language itself: data NValF a = I Nat data \nBValF a = B Bool data StuckF a = Stuck vi :: (NValF -: r) . Nat . FixM r vi n = inject (I n) vb :: \n(BValF -: r) . Bool . FixM r vb b = inject (B b) stuck :: (StuckF -: r) . FixM r stuck = inject Stuck \n Besides constructors for integer (vi) and boolean (vb) values, we also include a constructor denoting \nstuck evaluation (stuck). To allow for an extensible return type r for evaluation, we need to parametrize \nthe Eval type class in r: class Eval f r where evalalg :: AlgebraM f (FixM r) Projection is now essential \nfor pattern matching on values: instance (StuckF -: r, NValF -: r, Functor r) . Eval ArithF r where evalalg \n\u00b7 (Lit n) = vi n evalalg [ \u00b7] (Add e1 e2) = case (project [e1], project [e2]) of (Just (I n1), (Just \n(I n2))) . vi (n1 + n2) . stuck This concludes MTC s support for extensible inductive data types and \nfunctions. To cater to meta-theory, MTC must also support reasoning about these modular de.nitions. 3. \nReasoning with Church Encodings While Church encodings are the foundation of extensibility in MTC, Coq \ndoes not provide induction principles for them. It is an open problem to do so without resorting to axioms. \nMTC solves this problem with a novel axiom-free approach based on adapta\u00adtions of two important aspects \nof folds discussed by Hutton [19]. 3.1 The Problem of Church Encodings and Induction Coq s own original \napproach [35] to inductive data types was based on Church encodings. It is well-known that Church encodings \nof inductive data types have problems expressing induction principles such as Aind , the induction principle \nfor arithmetic expressions. Aind :: .P :: (Arith . Prop). .Hl :: (.n.P (Lit n)). .Ha :: (.a b.P a . P \nb . P (Add a b)). .a.P a Aind P Hl Ha e = case e of Lit n . Hl n Add x y . Ha a b (Aind P Hl Ha x) (Aind \nP Hl Ha y)  The original solution to this problem in Coq involved axioms for induction, which endangered \nstrong normalization of the calculus (among other problems). This was the primary motivation for the \ncreation of the calculus of inductive constructions [34] with built-in inductive data types. Why exactly \nare proofs problematic for Church encodings, where inductive functions are not? After all, a Coq proof \nis es\u00adsentially a function that builds a proof term by induction over a data type. Hence, the Church \nencoding should be able to express a proof as a fold with a proof algebra over the data type, in the \nsame way it represents other functions. The problem is that this approach severely restricts the proposi\u00adtions \nthat can be proven. Folds over Church encodings are destruc\u00adtive, so their result type cannot depend \non the term being destructed. For example, it is impossible to express the proof for type sound\u00adness \nbecause it performs induction over the expression e mentioned in the type soundness property. .e.G f \ne : t . G f [e] : t This restriction is a showstopper for the semantics setting of this paper, as it \nrules out proofs for most (if not all) theorems of inter\u00adest. Supporting reasoning about semantic functions \nrequires a new approach that does not suffer from this restriction.  3.2 Type Dependency with Dependent \nProducts Hutton s .rst aspect of folds is that they become substantially more expressive with the help \nof tuples. The dependent products in Coq take this observation one step further. While an f -algebra \ncannot refer to the original term, it can simultaneously build a copy e of the original term and a proof \nthat the property P e holds for the new term. As the latter depends on the former, the result type of \nthe algebra is a dependent product S e.P e . A generic algebra can exploit this expressivity to build \na poor-man s induction principle, e.g., for the Arith F functor: A2 ind :: .P :: (FixM Arith F . Prop \n). .Hl :: (.n.P (lit n )). .Ha :: (.a b .P a . P b . P (add a b )). Algebra Arith F (S e.P e ) A2 ind \nP Hl Ha e = case e of Lit n . . (lit n ) (Hl n) Add x y . . (add (p1 x) (p1 y)) (Ha (p1 x) (p1 y) (p2 \nx) (p2 y)) Provided with the necessary proof cases, A2 can build a speci.c ind proof algebra. The corresponding \nproof is simply a fold over a Church encoding using this proof algebra. Note that since a proof is not \na computational object, it makes more sense to use regular algebras than Mendler algebras. Fortu\u00adnately, \nregular algebras are compatible with Mendler-based Church encodings as the following variant of fold'shows. \nM fold'M :: Functor f . Algebra f a . FixM f . a fold'alg = foldM (.rec . alg . fmap rec) M  3.3 Term \nEquality with the Universal Property Of course, the dependent product approach does not directly prove \na property of the original term. Instead, given a term, it builds a new term and a proof that the property \nholds for the new term. In order to draw conclusions about the original term from the result, the original \nand new term must be equal. Clearly the equivalence does not hold for arbitrary terms that happen to \nmatch the type signatures FixM f for Church encodings and Algebra f (S e.P e) for proof algebras. Statically \nensuring this equivalence requires additional well-formedness conditions on both. These conditions formally \ncapture our notion of Church en\u00adcodings and proofs algebras. 3.3.1 Well-Formed Proof Algebras The .rst \nrequirement, for algebras, states that the new term pro\u00adduced by application of the algebra is equal \nto the original term. .alg :: Algebra f (S e.P e ).p1 . alg = inf . fmap p1 This constraint is encoded \nin the typeclass for proof algebras, PAlg . It is easy to verify that A2 satis.es this property. Other \nproof ind algebras over Arith F can be de.ned by instantiating A2 with ind appropriate cases for Hl and \nHa . In general, well-formedness needs to be proven only once for any data type and induction algebra. \n 3.3.2 Well-Formed Church Encodings Well-formedness of proof algebras is not enough because a proof is \nnot a single application of an algebra, but rather a fold'of it. M So the fold'used to build a proof \nmust be a proper fold'. As the M M Church encodings represent inductive data types as their folds, this \nboils down to ensuring that the Church encodings are well-formed. Hutton s second aspect of folds formally \ncharacterizes the de.\u00adnition of a fold using its universal property: ' h = foldM alg . h . inf = alg \nh In an initial algebra representation of an inductive data type, there is a single implementation of \nfold'that can be checked once M and for all for the universal property. In MTC s Church-encoding approach, \nevery term of type FixM f consists of a separate fold' M implementation that must satisfy the universal \nproperty. Note that this de.nition of the universal property is for a fold'using a tradi- M tional algebra. \nAs the only concern is the behavior of proof algebras (which are traditional algebras) folded over Church \nencodings, this is a suf.cient characterization of well-formedness. Hinze [18] uses the same characterization \nfor deriving Church numerals. Fortunately, the left-to-right implication follows trivially from the de.nitions \nof fold'and inf , independent of the particular term M of type FixM f . Thus, the only hard well-formedness \nrequirement for a Church-encoded term e is that it satis.es the right-to-left implication of the universal \nproperty. type UP f e = .a (alg :: Algebra M f a) (h :: FixM f . a). ' ' (.e .h (inf e ) = alg h e ') \n. h e = fold'alg e M This property is easy to show for any given smart constructor. MTC actually goes \none step further and rede.nes its smart con\u00adstructors in terms of a new inf , that only builds terms \nwith the universal property: in'f :: Functor f . f (S e.UP f e) . S e.UP f e about Church-encoded terms \nbuilt from these smart-er construc\u00adtors, as all of the nice properties of initial algebras hold for these \nterms and, importantly, these properties provide a handle on rea\u00adsoning about these terms. Two known \nconsequences of the universal property are the famous fusion law, which describes the composition of \na fold with another computation, '' h . alg1 = alg2 . fmap h . h . foldM alg1 = foldM alg2 and the lesser \nknown re.ection law, ' foldM inf = id  3.3.3 Soundness of Input-Preserving Folds Armed with the two \nwell-formedness properties, we can prove the key theorem for building inductive proofs over Church encodings: \n Theorem 3.1. Given a functor f , property P, and a well-formed P-proof algebra alg, for any Church-encoded \nf -term e with the universal property, we can conclude that P e holds. Proof. Given that foldM ' alg \ne has type S e ' .P e ', we have that p2 (foldM ' alg e ) is a proof for P (p1 (foldM ' alg e )). From \nthat the lemma is derived as follows: P (p1 (foldM ' alg e )) =. {-well-founded algebra and fusion law \n-} P (fold ' inf e) M .. {-re.ection law -} P e Theorem 3.1 enables the construction of a statically-checked \nproof of correctness as an input-preserving fold of a proof algebra. This provides a means to achieve \nour true goal: modular proofs for extensible Church encodings. 4.Modular Proofs for Extensible Church \nEncodings The aim of modularity in this setting is to .rst write a separate proof for every feature and \nthen compose the individual proofs into an overall proof for the feature composition. These proofs should \nbe independent from one another, so that they can be reused for different combinations of features. Fortunately, \nsince proofs are essentially folds of proof algebras, all of the reuse tools developed in Section 2 apply \nhere. In partic\u00adular, composing proofs is a simple matter of combining proof al\u00adgebras with .. Nevertheless, \nthe transition to modular components does introduce several wrinkles in the reasoning process. 4.1 Algebra \nDelegation Due to injection, propositions range over the abstract (super)functor f of the component composition. \nThe signature of A2 , for exam\u00ad ind ple, becomes: A2 ind :: .f .Arith F -: f . .P :: (FixM f . Prop ). \n.Hl :: (.n.P (lit n )). .Ha :: (.a b .P a . P b . P (add a b )). Algebra Arith F (S e.P e ) Consider \nbuilding a proof of .e.typeof e = Just nat . . m :: nat.eval e = vi m using A2 ind . Then, the .rst proof \nobligation is typeof (lit n ) = Just nat . . m :: nat.eval (lit n ) = vi m While this appears to follow \nimmediately from the de.nition of eval, recall that eval is a fold of an abstract algebra over f and \nis thus opaque. To proceed, we need the additional property that this f -algebra delegates to the Arith \nF -algebra as expected: .r (rec :: r . Nat).evalalg rec . inj = evalalg rec This delegation behavior \nfollows from our approach: the intended structure of f is a .-composition of features, and .-algebras \nare in\u00adtended to delegate to the feature algebras. We can formally capture the delegation behavior in \na type class that serves as a precondition in our modular proofs. class (Eval f , Eval g , f -: g) . \nWF Eval f g where wf eval alg :: .r (rec :: r . Nat) (e :: f r). evalalg rec (inj e :: g r ) = evalalg \nrec e instance (Eval f , Eval g , Eval h , WF Eval f g ) . WF Eval (f -: g . h) instance (Eval f , Eval \ng , Eval h , WF Eval f h ) . WF Eval (f -: g . h) instance (Eval f ) . WF Eval f f Figure 2. WF Eval \ninstances. MTC provides the three instances of this class in Figure 2, one for each instance of -:, allowing \nCoq to automatically build a proof of well-formedness for every composite algebra. 4.1.1 Automating Composition \nA similar approach is used to automatically build the de.nitions and proofs of languages from pieces \nde.ned by individual features. In addition to functor and algebra composition, the framework de\u00adrives \nseveral important reasoning principles as type class instances, similarly to WF Eval. These include the \nDistinctSubFunctor class, which ensures that injections from two different subfunctors are distinct, \nand the WF Functor class that ensures that fmap dis\u00adtributes through injection. Figure 3 provides a summary \nof all the classes de.ned in MTC, noting whether the base instances of a particular class are provided \nby the user or inferred with a default instance. Importantly, in\u00adstances of all these classes for feature \ncompositions are built au\u00adtomatically, analogously to the instances in Figure 2.  4.2 Extensible Inductive \nPredicates Many proofs appeal to rules which de.ne a predicate for an im\u00adportant property. In Coq these \npredicates are expressed as inductive data types of kind Prop. For instance, a soundness proof makes \nuse of a judgment about the well-typing of values. data WTValue :: Value . Type . Prop where WTNat :: \n.n.WTValue (I n ) TNat WTBool :: .b.WTValue (B b ) TBool When dealing with a predicate over extensible \ninductive data types, the set of rules de.ning the predicate must be extensible as well. Extensibility \nof these rules is obtained in much the same way as that of inductive data types: by means of Church encodings. \nThe important difference is that logical relations are indexed data types: e.g., WTValue is indexed by \na value and a type. This requires functors indexed by values x of type i. For example, WTNatF v t is \nthe corresponding indexed functor for the extensible variant of WTNat above. data WTNatF :: v . t . (WTV \n:: (v, t) . Prop ) . (v, t) . Prop where WTNat :: .n.(NVal F -: v, Functor v , NTypF -: t, Functor t \n) . WTNatF v t WTV (vi n , tnat) This index is a pair (v, t) of a value and a type. As object-language \nvalues and types are themselves extensible, the corresponding meta-language types v and t are parameters \nof the WTNat functor. To manipulate extensible logical relations, we need indexed algebras, .xpoints \nand operations: type iAlg i (f :: (i . Prop) . (i . Prop )) a = .x :: i.f ax . a x type iFix i (f :: \n(i . Prop ) . (i . Prop )) (x :: i) = .a :: i . Prop.iAlg f a . a x ... As these indexed variants are \nmeant to construct logical rela\u00adtions, their parameters range over Prop instead of Set. Fortunately, \n Class De.nition Description class Functor f where fmap :: (a . b) . (f a . f b ) fmap id :: fmap id \n= id fmap fusion :: .g h . fmap h . fmap g = fmap (h . g) Functors Supplied by the user class f -: g \nwhere inj :: f a . g a prj :: g a . Maybe (f a) inj prj :: prj ga = Just fa . ga = inj fa prj inj :: \nprj . inj = Just Functor Subtyping Inferred class (Functor f , Functor g , f -: g) . WF Functor f g where \nwf functor :: .a b (h :: a . b). fmap h . inj = inj . fmap h Functor Delegation Inferred class (Functor \nh , f -: h, g -: h) . DistinctSubFunctor f g h where inj discriminate :: .a (fe :: f a) (ge :: g a ).inj \nfe = inj ge Functor Discrimina\u00adtion Inferred class FAlg name t a f where f algebra : Mixin t f a Function \nAlgebras Supplied by the user class (f -: g, FAlg n t a f , FAlg n t a g ) . WF FAlg n t a f g where \nwf algebra :: .rec (fa :: f t ). f algebra rec (inj fa ) = f algebra rec fa Algebra Delegation Inferred \nclass (Functor f , Functor g , f -: g) . PAlg name f g a where p algebra :: Algebra f a proj eq :: .e.p1 \n(p algebra e ) = inf (inj (fmap p1 e)) Proof Algebras Supplied by the User Figure 3. Type classes provided \nby MTC this shift obviates the need for universal properties for iFix-ed values: it does not matter how \na logical relation is built, but sim\u00adply that it exists. Analogues to WF Functor , WF Algebra , and DistinctSubFunctor \nare similarly unnecessary.  4.3 Case Study: Soundness of an Arithmetic Language Here we brie.y illustrate \nmodular reasoning with a case study proving soundness for the Arith F . Logic F language. The previously \nde.ned eval function captures the operational semantics of this language in a modular way and reduces \nan ex\u00adpression to a NVal F . BVal F . StuckF value. Its type system is similarly captured by a modularly \nde.ned type-checking function typeof that maybe returns a TNatF .TBool F type representation: data TNatF \nt = TNat data TBool F t = TBool For this language soundness is formulated as: Theorem soundness :: .e \nt env , typeof e = Just t . WTValue (eval e env ) t The proof of this theorem is a fold of a proof algebra \nover the ex\u00adpression e which delegates the different cases to separate proof al\u00adgebras for the different \nfeatures. A summary of the most notewor\u00adthy aspects of these proofs follows. Sublemmas The modular setting \nrequires every case analysis to be captured in a sublemma. Because the superfunctor is abstract, the \ncases are not known locally and must be handled in a distributed fashion. Hence, modular lemmas built \nfrom proof algebras are not just an important tool for reuse in MTC they are the main method of constructing \nextensible proofs. Universal Properties Everywhere Universal properties are key to reasoning, and should \nthus be pervasively available throughout the framework. MTC has more infrastructure to support this. \nAs an example of their utility when constructing a proof, we may wish to prove a property of the extensible \nreturn value of an extensible function. Consider the LogicF case of the soundness proof: given that typeof \n(If c e1 e2) = Some t1, we wish to show that WTValue (eval (If c e1 e2)) t1. If c evaluates to false, \nwe need to show that WTValue e2 t1. Since If c e1 e2 has type t1, the de.nition of typeof says that e1 \nhas type t1: typeof alg rec (If c e1 e2) = case project (rec c) of Just TBool . case (rec e1, rec e2) \nof (Just t1, Just t2) . if eq type t1 t2 then Just t1 else Nothing . Nothing Nothing . Nothing In addition, \nthe type equality test function, eq type , says that e1 and e2 have the same type: eq = true. We need \nto make use type t1 t2 of a sublemma showing that .t1 t2. eq t2 = true . t1 = type t1 t2. As we have \nseen, in order to do so, the universal property must hold for typeof e1. This is easily accomplished \nby packaging a proof of the universal property alongside t1 in the typeof function. Using universal properties \nis so important to reasoning that this packaging should be the default behavior, even though it is computationally \nirrelevant. Thankfully, packaging becomes trivial with the use of smarter constructors. These constructors \nhave the additional advantage over standard smart constructors of being injective: lit j = lit k . j \n= k, an important property for proving inversion lemmas. The proof of injectivity requires that the subterms \nof the functor have the universal property, established by the use of inf ' . To facilitate this packaging, \nwe provide a type synonym that can be used in lieu of FixM in function signatures: type UPF f = Functor \nf . S e.(UP f e) Furthermore, the universal property should hold for any value sub\u00adject to proof algebras, \nso it is convenient to include the property in all proof algebras. MTC provides a predicate transformer, \nUPP , that captures this and augments induction principles accordingly. UPP :: Functor f . (P :: .e.UP \nf e . Prop) . (e :: FixM f ) . S e.(P e ) Equality and Universal Properties While packaging universal \nproperties with terms enables reasoning, it does obfuscate equality of terms. In particular, two UPF \nterms t and t ' may share the same underlying term (i.e., p1 t = p1 t '), while their universal property \nproof components are different.2 This issue shows up in the de.nition of the typing judgment for values. \nThis judgment needs to range over UPF fv values and UPF ft types (where fv and ft are the value and type \nfunctors), because we need to exploit the injectivity of inject in our inversion lemmas. However, knowing \nWTValue v t and p1 t = p1 t ' no longer necessarily implies WTValue v t ' because t and t ' may have \ndistinct proof components. To solve this, we make use of two auxiliary lemmas W T Vp1,v and W T Vp1,t \nthat establish the implication: 2 Actually, as proofs are opaque, we cannot tell if they are equal. \n Theorem W T Vp1,v (i :: WTValue v t ) = Lam f . closure (f (length env )) env ' ' ' .v .p1 v = p1 v \n. WTValue v t App e1 e2 . Theorem W T Vp1,t (i :: WTValue v t ) = ''' ' .t .p1 t = p1 t . WTValue v \nt Similar lemmas are used for other logical relations. Features which introduce new rules need to also \nprovide proofs showing that they respect this safe projection property. 5. Higher-Order Features Binders \nand general recursion are ubiquitous in programming lan\u00adguages, so MTC must support these sorts of higher-order \nfeatures. The untyped lambda calculus demonstrates the challenges of im\u00adplementing both these features \nwith extensible Church encodings. 5.1 Encoding Binders To encode binders we use a parametric HOAS (PHOAS) \n[8] repre\u00adsentation. PHOAS allows binders to be expressed as functors, while still preserving all the \nconvenient properties of HOAS. Lambda F is a PHOAS-based functor for a feature with func\u00adtion application, \nabstraction and variables. The PHOAS style re\u00adquires Lambda F to be parameterized in the type v of variables, \nin addition to the usual type parameter r for recursive occurrences. data Lambda F v r = Var v | App \nr r | Lam (v . r) As before, smart constructors build extensible expressions: var :: (Lambda F v -: f \n) . v . FixM f var v = inject (Var v ) app :: (Lambda F v -: f ) . FixM f . FixM f . FixM f app e1 e2 \n= inject (App e1 e2) lam :: (Lambda F v -: f ) . (v . FixM f ) . FixM f lam f = inject (Lam f )  5.2 \nDe.ning Non-Inductive Evaluation Algebras De.ning an evaluation algebra for the Lambda F feature presents \nadditional challenges. Evaluation of the untyped lambda-calculus can produce a closure, requiring a richer \nvalue type than before: data Value = Stuck | I Nat | B Bool | Clos (Value . Value ) Unfortunately, Coq \ndoes not allow such a de.nition, as the closure constructor is not strictly positive (recursive occurrences \nof Value occur both at positive and negative positions). Instead, a closure is represented as an expression \nto be evaluated in the context of an environment of variable-value bindings. The environment is a list \nof values indexed by variables represented as natural numbers Nat. type Env v = [ v ] The modular functor \nClosure F integrates closure values into the framework of extensible values introduced in Section 2.6. \ndata Closure F f a = Clos (FixM f ) (Env a ) closure :: (Closure F f -: r) . FixM f . Env (FixM r) . \nFixM r closure mf e = inject (Clos mf e) A .rst attempt at de.ning evaluation is: evalLambda :: (Closure \nF f -: r, StuckF -: r, Functor r ) . Algebra M (Lambda F Nat) (Env (FixM r) . FixM r) evalLambda [\u00b7] \nexp env = case exp of Var index . env !! index case project $ [e1] env of Just (Clos e3 env ' ) . [e3 \n] ([e2] env : env ' ) . stuck The function evalLambda instantiates the type variable v of the Lambda \nF v functor with a natural number Nat, representing an index in the environment. The return type of the \nMendler algebra is now a function that takes an environment as an argument. In the variable case there \nis an index that denotes the position of the variable in the environment, and evalLambda simply looks \nup that index in the environment. In the lambda case evalLambda builds a closure using f and the environment. \nFinally, in the application case, the expression e1 is evaluated and analyzed. If that expression evaluates \nto a closure then the expression e2 is evaluated and added to the closure s environment (env '), and \nthe closure s expression e3 is evaluated under this extended environment. Otherwise e1 does not evaluate \nto a closure, and evaluation is stuck. Unfortunately, this algebra is ill-typed on two accounts. Firstly, \nthe lambda binder function f does not have the required type Nat . FixM f . Instead, its type is Nat \n. r, where r is uni\u00adversally quanti.ed in the de.nition of the Algebra M algebra. Sec\u00adondly, and symmetrically, \nin the App case, the closure expression e3 has type FixM f which does not conform to the type r expected \nby [\u00b7] for the recursive call. Both these symptoms have the same problem at their root. The Mendler algebra \nenforces inductive (structural) recursion by hiding that the type of the subterms is FixM f using universal \nquanti.cation over r. Yet this information is absolutely essential for evaluating the binder: we need \nto give up structural recursion and use general recursion instead. This is unsurprising, as an untyped \nlambda term can be non-terminating.  5.3 Non-Inductive Semantic Functions Mixin algebras re.ne Mendler \nalgebras with a more revealing type signature. type Mixin t f a = (t . a) . f t . a This algebra speci.es \nthe type t of subterms, typically FixM f , the overall expression type. With this mixin algebra, evalLambda \nis now well-typed: evalLambda :: (Closure F e -: v, StuckF -: v) . Mixin (FixM e) (Lambda F Nat) (Env \n(FixM v) . FixM v) Mixin algebras have an analogous implementation to Eval as type classes, enabling \nall of MTC s previous composition techniques. class EvalX f gr where evalxalg :: Mixin (FixM f ) g (Env \n(FixM r) . FixM r) instance (StuckF -: r, Closure F f -: r, Functor r ) . EvalX f (Lambda F Nat) r where \nevalxalg = evalLambda Although the code of evalLambda still appears generally recursive, it is actually \nnot because the recursive calls are abstracted as a parameter (like with Mendler algebras). Accordingly, \nevalLambda does not raise any issues with Coq s termination checker. Mixin algebras resemble the open \nrecursion style which is used to model inheritance and mixins in object-oriented languages [10]. Still, \nMendler encodings only accept Mendler algebras, so using mixin algebras with Mendler-style encodings \nrequires a new form of fold. In order to overcome the problem of general recursion, the open recursion \nof the mixin algebra is replaced with a bounded inductive .xpoint combinator, boundedFix , that returns \na default value if the evaluation does not terminate after n recursion steps.  boundedFix :: .f a.Functor \nf . Nat . a . Mixin (FixM f ) f a . FixM f . a boundedFix n def alg e = case n of 0 . def m . alg (boundedFix \n(m - 1) def alg ) (outf e) The argument e is a Mendler-encoded expression of type FixM f . boundedFix \n.rst uses outf to unfold the expression into a value of type f (FixM f ) and then applies the algebra \nto that value re\u00adcursively. In essence boundedFix can de.ne generally recursive operations by case analysis, \nsince it can inspect values of the recur\u00adsive occurrences. The use of the bound prevents non-termination. \nBounded Evaluation Evaluation can now be modularly de.ned as a bounded .xpoint of the mixin algebra EvalX \n. The de.nition uses a distinguished bottom value, ., that represents a computation which does not .nish \nwithin the given bound. data .F a = Bot .= inject Bot evalX :: (Functor f , .F -: r, EvalX f f r) . Nat \n. FixM f . Env . FixM r evalX n e env = boundedFix n (\\ ..) evalxalg e env  5.4 Backwards compatibility \nThe higher-order PHOAS feature has introduced a twofold change to the algebras used by the evaluation \nfunction: 1. evalX uses mixin algebras instead of Mendler algebras. 2. evalX now expects algebras over \na parameterized functor.  The .rst change is easily accommodated because Mendler al\u00adgebras are compatible \nwith mixin algebras. If a non-binder feature de.nes evaluation in terms of a Mendler algebra, it does \nnot have to de.ne a second mixin algebra to be used alongside binder features. The mendlerToMixin function \nautomatically derives the required mixin algebra from the Mendler algebra. mendlerToMixin :: Algebra \nM f a . Mixin (FixM g) f a mendlerToMixin alg = alg This conversion function can be used to adapt evaluation \nfor the arithmetic feature to a mixin algebra: instance Eval Arith F f . EvalX f Arith F r where evalxalg \n[\u00b7] e env = mendlerToMixin evalAlgebra (.ip [\u00b7] env) e The algebras of binder-free features can be similarly \nadapted to build an algebra over a parametric functor. Figure 4 summarizes the hierarchy of algebra adaptations. \nNon-parameterized Mendler algebras are the most .exible because they can be adapted and reused with both \nmixin algebras and parametric superfunctors. They should be used by default, only resorting to mixin \nalgebras when necessary. 6. Reasoning with Higher-Order Features The switch to a bounded evaluation function \nover parameterized Church encodings requires a new statement of soundness. Theorem soundnessX :: .f ft \nenv t G n. .e1 :: FixM (f (Maybe (FixM ft ))). .e2 :: FixM (f Nat ). Figure 4. Hierarchy of Algebra \nAdaptation G f e1 = e2 . WF Environment G env . typeof e1 = Just t . WTValue (evalX n e2 env) t The proof \nof soundnessX features two substantial changes to the proof of soundness from Section 4.3. 6.1 Proofs \nover Parametric Church Encodings The statement of soundnessX uses two instances of the same PHOAS expression \ne :: .v.FixM (f v). The .rst, e1 , instanti\u00adates v with the appropriate type for the typing algebra, \nwhile e2 instantiates v for the evaluation algebra. In recursive applications of soundnessX , the connection \nbe\u00adtween e1 and e2 is no longer apparent. As they have different types, Coq considers them to be distinct, \nso case analysis on one does not convey information about the other. Chlipala [8] shows how the connection \ncan be retained with the help of an auxiliary equivalence relation G f e1 = e2, which uses the environment \nG to keep track of the current variable bindings. The top-level application, where the common origin \nof e1 and e2 is apparent, can easily supply a proof of this relation. By induction on this proof, recursive \nappli\u00adcations of soundnessX can then analyze e1 and e2 in lockstep. Figure 5 shows the rules for determining \nequivalence of lambda expressions. ' '' (x, x ) . G G f e1 = e1 G f e2 = e2 ' '' G f var x = var x G \nf app e1 e2 = app e1 e2 (EQV-VA R) (EQV-AP P) .xx ' .(x, x ' ), G f f(x) = f ' (x ' ) G f lam f = lam \nf ' (EQV-ABS) Figure 5. Lambda Equivalence Rules  6.2 Proofs for Non-Inductive Semantics Functions \nProofs for semantic functions that use boundedFix proceed by induction on the bound. Hence, the reasoning \nprinciple for mixin\u00adbased bounded functions f is in general: provided a base case .e, P (f 0 e), and \ninductive case .n e, (.e ' , P (f n e ' )) . .e, P (f (n + 1) e) hold, .n e, P (f n e) also holds. In \nthe base case of soundnessX , the bound has been reached and evalX returns .. The proof of this case \nrelies on adding to the WTValue judgment the WF-BOT rule stating that every type is inhabited by .. (WF-BOT) \nf.: T Hence, whenever evaluation returns ., soundness trivially holds. The inductive case is handled \nby a proof algebra whose state\u00adment includes the inductive hypothesis provided by the induction on the \nbound: IH :: .n e, (.e ' , P (f n e ' )) . P (f (n + 1) e). The App e1 e2 case of the soundness theorem \nillustrates the rea\u00adson for including IH in the statement of the proof algebra. After  using the induction \nhypothesis to show that evalX e1 env pro\u00adduces a well-formed closure Clos e3 env ', we must then show \nthat evaluating e3 under the (evalX e2 env) : env ' environment is also well-formed. However, e3 is not \na subterm of App e1 e2, so the conventional induction hypothesis for subterms does not apply. Because \nevalX e3 ((evalX e2 env) : env ' ) is run with a smaller bound, the bounded induction hypothesis IH can \nbe used.  6.3 Proliferation of Proof Algebras In order to incorporate non-parametric inductive features \nin the soundnessX proof, existing proof algebras for those features need to be adapted. To cater to the \nfour possible proof signatures of soundness (one for each de.nition of [\u00b7]), a naive approach re\u00adquires \nfour different proof algebras for an inductive non-parametric feature.3 This is not acceptable, because \nreasoning about a fea\u00adture s soundness should be independent of how a language adapts its evaluation \nalgebra. Hence, MTC allows features to de.ne a sin\u00adgle proof algebra, and provides the means to adapt \nand reuse that proof algebra for the four variants. These proof algebra adaptations rely on mediating \ntype class instances which automatically build an instance of the new proof algebra from the original \nproof algebra. 6.3.1 Adapting Proofs to Parametric Functors Adapting a proof algebra over the expression \nfunctor to one over the indexed functor for the equivalence relation .rst requires a de.nition of equivalence \nfor non-parametric functors. Fortunately, equivalence for any such functor fnp can be de.ned generically: \nG f a = b (EQ V-NP) G f inject(C a) = inject(C b) EQ V-NP states that the same constructor C of fnp, \napplied to equivalent subterms a\u00afand \u00afb, produces equivalent expressions. The mediating type class adapts \nfnp proofs of propositions on two instances of the same PHOAS expression, like soundness, to proof algebras \nover the parametric functor. instance (PAlg N P fnp) . iPAlg N P (EQ V-NP fnp) This instance requires \na small concession: proofs over fnp have to be stated in terms of two expressions with distinct superfunctors \nf and f ' rather than two occurrences of the same expression. Induc\u00adtion over these two expressions requires \na variant of PAlg for pairs of .xpoints.  6.3.2 Adapting Proofs to Non-Inductive Semantic Functions \nTo be usable regardless of whether foldM or boundedFix is used to build the evaluation function, an inductive \nfeature s proof needs to reason over an abstract .xpoint operator and induction principle. This is achieved \nby only considering a single step of the evaluation algebra and leaving the recursive call abstract: \ntype soundness e tp ev = .env t .tp (outf (p1 e)) = Just t . WTValue (ev (out t ' (p1 e)) env) t) type \nsoundnessalg rec t rece (typeof alg :: Mixin (FixM f ) f (Maybe (FixM t)) (evalalg :: Mixin (FixM f \n) f (Env (FixM r) . FixM r)) (e :: FixM f ) (e UP ' :: UP e ) = .IHc :: (.e ' . soundness e ' (typeof \nalg rec t) (evalalg rece) . soundness e ' rec t rece). soundness e (typeof alg rect) (evalalg rece) 3 \nIntroducing type-level binders would further compound the situation with four possible signatures for \nthe typeof algebra. The hypothesis IHc is used to relate calls of rece and rect to applications of evalalg \nand typeof alg. A mediating type class instance again lifts a proof algebra with this signature to one \nthat includes the Induction Hypothesis gener\u00adated by induction on the bound of boundedFix . instance \n(PAlg N P E ) . iPAlg N (IH . P) E 7. Case Study As a demonstration of the MTC framework, we have built \na set of .ve reusable language features and combined them into a mini-ML [9] variant. The study also \nbuilds .ve other languages from these features.4 Figure 6 presents the syntax of the expressions, values, \nand types provided by the features; each line is annotated with the feature that provides that set of \nde.nitions. The Coq .les that implement these features average roughly 1100 LoC and come with a typing \nand evaluation function in ad\u00addition to soundness and continuity proofs. Each language needs on average \nonly 100 LoC to build its semantic functions and soundness proofs from the .les implementing its features. \nThe framework it\u00adself consists of about 2500 LoC. e ::= N | e + e Arith | B | if e then e else e Bool \n| case e of { z . e ; S n . e} NatCase | lam x : T.e | e e | x Lambda | .x x : T.e Recursion V ::= N \nArith T ::= nat Arith | B Bool | bool Bool | closure e V Lambda | T . T Lambda Figure 6. mini-ML expressions, \nvalues, and types The generic soundness proof, reused by each language, relies on a proof algebra to \nhandle the case analysis of the main lemma. Each case is handled by a sub-algebra. These sub-algebras \nhave their own set of proof algebras for case analysis or induction over an abstract superfunctor. The \nwhole set of dependencies of a top\u00adlevel proof algebra forms a proof interface that must be satis.ed \nby any language which uses that algebra. Such proof interfaces introduce the problem of feature interac\u00adtions \n[5], well-known from modular component-based frameworks. In essence, a feature interaction is functionality \n(e.g., a function or a proof) that is only necessary when two features are combined. An example from \nthis study is the inversion lemma which states that values with type nat are natural numbers: f x : nat \n. x :: N. The Bool feature introduces a new typing judgment, WT-BO O L for boolean values. Any language \nwhich includes both these fea\u00adtures must have an instance of this inversion for WT-BOOL. Our modular \napproach supports feature interactions by capturing them in type classes. A missing case, like for WT-BO \nOL, can then be easily added as a new instance of that type class, without affecting or overriding existing \ncode. In the case study, feature interactions consist almost exclusively of inversion principles for \njudgments and the projection principles of Section 4.3. Thankfully, their proofs are relatively straightfor\u00adward \nand can be dispatched by tactics hooked into the type class inference algorithm. These tactics help minimize \nthe number of in\u00adteraction type class instances, which could otherwise easily grow exponentially in the \nnumber of features. 4 Also available at http://www.cs.utexas.edu/~bendy/MTC  8. Related Work This section \ndiscusses related work. Modular Reasoning There is little work on mechanizing mod\u00adular proofs for extensible \ncomponents. An important contribution of our work is how to use universal properties to provide modular \nreasoning techniques for encodings of inductive data types that are compatible with theorem provers like \nCoq. Old versions of Coq, based on the calculus of constructions [11], also use Church en\u00adcodings to \nmodel inductive data types [35]. However, the inductive principles to reason about those encodings had \nto be axiomatized, which endangered strong normalization of the calculus. The calcu\u00adlus of inductive \nconstructions [34] has inductive data types built-in and was introduced to avoid the problems with Church \nencodings. MTC returns to Church encodings to allow extensibility, but does not use standard, closed \ninduction principles. It instead uses a rea\u00adsoning framework based on universal properties which allow \nmod\u00adular reasoning without axioms in Coq. Extensibility Our approach to extensibility combines and extends \nideas from existing solutions to the expression problem. The type class infrastructure for (Mendler-style) \nf -algebras is inspired by DTC [14, 43]. However the type-level .xpoints that are central to DTC cannot \nbe used in Coq because of their use of general recur\u00adsion. To avoid general recursion, MTC encodes least-.xpoints \nwith Church encodings [6, 35]. Church encodings have inspired other solutions to the expression problem \n(especially in object-oriented languages) [30 32]. Those solutions do not use f -algebras: in\u00adstead, \nthey use an isomorphic representation called object alge\u00adbras [31]. Object algebras are a better .t for \nlanguages where records are the main structuring construct (such as OO languages). MTC differs from previous \napproaches by using Mendler-style f \u00adalgebras instead of conventional f -algebras or object algebras. \nUn\u00adlike previous solutions to the expression problem, which focus only on the extensibility aspects of \nimplementations, MTC also deals with modular reasoning and extensibile inductively de.ned predi\u00adcates. \nMechanized Meta-Theory and Reuse Several ad-hoc tool-based approaches provide reuse, but none is based \non a proof assistant s modularity features alone. The Tinkertype project [23] is a frame\u00adwork for modularly \nspecifying formal languages. It was used to format the language variants used in Pierce s Types and Program\u00adming \nLanguages [37], and to compose traditional pen-and-paper proofs. The Ott tool [41] allows users to write \nde.nitions and the\u00adorem statements in an ASCII format designed to mirror pen-and\u00adpaper formalizations. \nThese are then automatically translated to de.nitions in either LATEX or a theorem prover and proofs \nand func\u00adtions are then written using the generated de.nitions. Both Boite [7] and Mulhern [29] consider \nhow to extend exist\u00ading inductive de.nitions and reuse related proofs in the Coq proof assistant. Both \ntheir techniques rely on external tools which are no longer available and have users write extensions \nwith respect to an existing speci.cation. As such, features cannot be checked inde\u00adpendently or easily \nreused with new speci.cations. In contrast, our approach is fully implemented within Coq and allows for \nindepen\u00addent development and veri.cation of features. Delaware et al. [13] applied product-line techniques \nto modu\u00adlarizing mechanized meta-theory proofs. As a case study, they built type safety proofs for a \nfamily of extensions to Featherweight Java from a common base of features. Importantly, composition of \nthese features was entirely manual, as opposed to the automated compo\u00adsition developed here. Concurrently \nwith our development of MTC, Schwaab et al. have been working on modularizing meta-theory in Agda [40]. \nWhile MTC uses Church encodings to encode extensible datatypes, their approach achieves extensibility \nby using universes which can be lifted to the type level. Encodings and their associated proofs can be \nmodi.ed to derive new languages. Transparency One long-standing criticism of mechanized meta\u00adtheory has \nbeen that it interferes with adequacy, i.e. convincing users that the proven theorem is in fact the desired \none [39]. Cer\u00adtainly the use of PHOAS can complicate the transparency of mech\u00adanized de.nitions. The \nsoundnessX theorem, for example, uses a more complicated statement than the pen-and-paper version be\u00adcause \nPHOAS requires induction over the equivalence relation. Modular inductive datatypes have the potential \nfor exacerbating transparency concerns, as the encodings are distributed over dif\u00adferent components. \nCombining a higher-level notation provided by a tool like Ott with the composition mechanisms of MTC \nis an interesting direction for future work. Such a higher-level notation could help with transparency; \nwhile MTC s composition mecha\u00adnisms could help with generating modular code for Ott speci.ca\u00adtions. Binding \nTo minimize the work involved in modeling binders, MTC provides reusable binder components. The problem \nof mod\u00adeling binders has previously received a lot of attention. Some proof assistants and type theories \naddress this problem with better sup\u00adport for names and abstract syntax [36, 38]. In general-purpose \nproof assistants like Coq, however, such support is not available. A popular approach, widely used in \nCoq formalizations, is to use mechanization-friendly .rst-order representations of binders such as the \nlocally nameless approach [1]. This involves developing a number of straightforward, but tedious infrastructure \nlemmas and de.nitions for each new language. Such tedious infrastructure can be automatically generated \n[2] or reused from data type-generic de.nitions [21]. However this typically requires additional tool \nsupport. A higher-order representation like PHOAS [8] avoids most infrastructure de.nitions. While we \nhave developed PHOAS-based binders in MTC, it supports .rst-order representations as well. Semantics \nand Interpreters While the majority of semantics for\u00admalization approaches use inductively de.ned predicates, \nwe pro\u00adpose an approach based on interpreters. Of course, MTC supports standard approaches as well. A \nparticularly prominent line of work based on interpreters is that of using monads to structure semantics. \nMoggi [28] pioneered monads to model computation effects and structure denotation se\u00admantics. Liang et \nal. [25] introduced monad transformers to com\u00adpose multiple monads and build modular interpreters. Jaskelioff \net al. [20] used an approach similar to DTC in combination with monads to provide modular implementation \nof mathematical oper\u00adational semantics. Our work could bene.t from using monads to model more complex \nlanguage features. However, unlike previous work, we also have to consider modular reasoning. Monads \nintro\u00adduce important challenges in terms of modular reasoning. Only very recently have some modular proof \ntechniques for reasoning about monads have been introduced [15, 33]. While these are good starting points, \nit remains to be seen whether these techniques are suf.cient to reason about suitably generalized modular \nstatements like soundness. Mechanization of interpreter-based semantics clearly poses its own challenges. \nYet, it is highly relevant as it bestows the high de\u00adgree of con.dence in correctness directly on the \nexecutable artifact, rather than on an intermediate formulation based on inductively de\u00ad.ned relations. \nThe only similar work in this direction, developed concurrently to our own, is that of Danielsson [12]. \nHe uses the partiality monad, which fairly similar to our bounded .xpoint, to formalize semantic interpreters \nin Agda. He argues that this style is more easily understood and more obviously deterministic and computable \nthan logical relations. Unlike us, Danielsson does not consider modularization of de.nitions and proofs. \n 9. Conclusion Formalizing meta-theory can be very tedious. For larger program\u00adming languages the required \namount of work can be overwhelming. We propose a new approach to formalizing meta-theory that al\u00adlows \nmodular development of language formalizations. By build\u00ading on existing solutions to modularity problems \nin conventional programming languages, MTC allows modular de.nitions of lan\u00adguage components. Furthermore, \nMTC supports modular reason\u00ading about these components. Our approach enables reuse of modu\u00adlar inductive \nde.nitions and proofs that deal with standard language constructs, allowing language designers to focus \non the interesting constructs of a language. This paper addresses many, but obviously not all, of the \nfunda\u00admental issues for providing a formal approach to modular seman\u00adtics. We will investigate further \nextensions of our approach, guided by the formalization of larger and more complex languages on top of \nour modular mini-ML variant. A particularly challenging issue we are currently considering of is the \npervasive impact of new side\u00adeffecting features on existing de.nitions and proofs. We believe that existing \nwork on modular monadic semantics [20, 24, 25] is a good starting point to overcome this hurdle. Acknowledgements \nWe would like to especially thank William Cook for his help in structuring the presentation of this work. \nFur\u00adther thanks to Don Batory, Twan van Laarhoven and the reviewers for their comments and suggestions. \nThis work was supported by the National Science Foundation under Grant CCF 0724979. References [1] B. \nE. Aydemir, A. Chargu \u00b4eraud, B. C. Pierce, R. Pollack, and S. Weirich. Engineering Formal Metatheory. \nIn POPL 08, 2008. [2] B. E. Aydemir and S. Weirich. LNgen: Tool Support for Locally Nameless Representations, \n2009. Unpublished manuscript. [3] B.E. Aydemir et al. Mechanized Metatheory for the Masses: The PoplMark \nChallenge. In TPHOLs 05, 2005. [4] P. Bahr. Evaluation `a la carte: Non-strict evaluation via compositional \ndata types. In Proceedings of the 23rd Nordic Workshop on Program\u00adming Theory, NWPT 11, pages 38 40, \n2011. [5] D. Batory, J. Kim, and P. H \u00a8 ofner. Feature interactions, products, and composition. In GPCE, \n2011. [6] C. B \u00a8ohm and A. Berarducci. Automatic synthesis of typed lambda\u00adprograms on term algebras. \nTheor. Comput. Sci., 39, 1985. [7] O. Boite. Proof reuse with extended inductive types. In Theorem Proving \nin Higher Order Logics, pages 50 65, 2004. [8] A. Chlipala. Parametric higher-order abstract syntax for \nmechanized semantics. In ICFP 08, 2008. [9] D. Cl\u00b4 ement, T. Despeyroux, G. Kahn, and J. Despeyroux. \nA Simple Applicative Language: mini-ML. In LFP 86, 1986. [10] W. R. Cook. A denotational semantics of \ninheritance. PhD thesis, Providence, RI, USA, 1989. AAI9002214. [11] T. Coquand and G\u00b4erard Huet. The \ncalculus of constructions. Technical Report RR-0530, INRIA, May 1986. [12] N. A. Danielsson. Operational \nsemantics using the partiality monad. In ICFP 12, 2012. [13] B. Delaware, W. R. Cook, and D. Batory. \nProduct lines of theorems. In OOPSLA 11, 2011. [14] L. Duponcheel. Using catamorphisms, subtypes and \nmonad transform\u00aders for writing modular functional interpreters., 1995. [15] J. Gibbons and R. Hinze. \nJust do it: simple monadic equational reasoning. In ICFP 11, 2011. [16] J. A. Goguen, J. W. Thatcher, \nE. G. Wagner, and J. B. Wright. Initial algebra semantics and continuous algebras. J. ACM, 24(1), Jan. \n1977. [17] G. Gonthier, B. Ziliani, A. Nanevski, and D. Dreyer. How to make ad hoc proof automation less \nad hoc. In ICFP 11, 2011. [18] R. Hinze. Church numerals, twice! JFP, 15(1):1 13, 2005. [19] G. Hutton. \nA tutorial on the universality and expressiveness of fold. J. Funct. Program., 9(4):355 372, 1999. [20] \nM. Jaskelioff, N. Ghani, and G. Hutton. Modularity and implemen\u00adtation of mathematical operational semantics. \nElectron. Notes Theor. Comput. Sci., 229(5), March 2011. [21] G. Lee, B. C. d. S. Oliveira, S. Cho, and \nK. Yi. Gmeta: A generic formal metatheory framework for .rst-order representations. In ESOP 2012, 2012. \n[22] X. Leroy. Formal veri.cation of a realistic compiler. Communications of the ACM, 52(7), 2009. [23] \nM. Y. Levin and B. C. Pierce. Tinkertype: A language for playing with formal systems. Journal of Functional \nProgramming, 13(2), March 2003. [24] S. Liang and P. Hudak. Modular denotational semantics for compiler \nconstruction. In ESOP 96, 1996. [25] S. Liang, P. Hudak, and M. Jones. Monad transformers and modular \ninterpreters. In POPL 95, 1995. [26] D. MacQueen. Modules for standard ML. In LFP 84, 1984. [27] G. Malcolm. \nAlgebraic Data Types and Program Transformation. PhD thesis, Rijksuniversiteit Groningen, September 1990. \n[28] E. Moggi. Notions of computation and monads. Inf. Comput., 93(1), July 1991. [29] A. Mulhern. Proof \nweaving. In WMM 06, September 2006. [30] B. C. d. S. Oliveira. Modular visitor components. In ECOOP 09, \n2009. [31] B. C. d. S. Oliveira and W. R. Cook. Extensibility for the masses: Practical extensibility \nwith object algebras. In ECOOP 12, 2012. [32] B. C. d. S. Oliveira, R. Hinze, and A. L \u00a8oh. Extensible \nand modular generics for the masses. In Trends in Functional Programming, 2006. [33] B. C. d. S. Oliveira, \nT. Schrijvers, and W. R. Cook. Effectiveadvice: disciplined advice with explicit effects. In AOSD 10, \n2010. [34] C. Paulin-Mohring. Inductive de.nitions in the system Coq -rules and properties. In TLCA 93, \n1993. [35] F. Pfenning and C. Paulin-Mohring. Inductively de.ned types in the calculus of constructions. \nIn MFPS V, 1990. [36] F. Pfenning and C. Sch \u00a8urmann. System description: Twelf -a meta\u00adlogical framework \nfor deductive systems. In CADE 99, 1999. [37] B. C. Pierce. Types and Programming Languages. MIT Press, \n2002. [38] A. M. Pitts. Nominal logic, a .rst order theory of names and binding. Inf. Comput., 186(2):165 \n193, 2003. [39] Robert Pollack. How to believe a machine-checked proof. In Twenty Five Years of Constructive \nType Theory, 1998. [40] Christopher Schwaab and Jeremy G. Siek. Modular type-safety proofs using dependant \ntypes. CoRR, abs/1208.0535, 2012. [41] Peter Sewell et al. Ott: effective tool support for the working \nsemanti\u00adcist. In ICFP 07, 2007. [42] M. Sozeau and N. Oury. First-class type classes. In TPHOLs 08, 2008. \n[43] W. Swierstra. Data types `a la carte. J. Funct. Program., 18(4), 2008. [44] T. Uustalu and V. Vene. \nCoding recursion a la Mendler. In WGP 00, pages 69 85, 2000. [45] P. Wadler. The Expression Problem. \nEmail, November 1998. Discus\u00adsion on the Java Genericity mailing list. [46] P. Wadler and S. Blott. How \nto make ad-hoc polymorphism less ad hoc. In POPL 89, pages 60 76, 1989.      \n\t\t\t", "proc_id": "2429069", "abstract": "<p>Formalizing meta-theory, or proofs about programming languages, in a proof assistant has many well-known benefits. Unfortunately, the considerable effort involved in mechanizing proofs has prevented it from becoming standard practice. This cost can be amortized by reusing as much of existing mechanized formalizations as possible when building a new language or extending an existing one. One important challenge in achieving reuse is that the inductive definitions and proofs used in these formalizations are closed to extension. This forces language designers to cut and paste existing definitions and proofs in an ad-hoc manner and to expend considerable effort to patch up the results.</p> <p>The key contribution of this paper is the development of an induction technique for extensible Church encodings using a novel reinterpretation of the universal property of folds. These encodings provide the foundation for a framework, formalized in Coq, which uses type classes to automate the composition of proofs from modular components. This framework enables a more structured approach to the reuse of meta-theory formalizations through the composition of modular inductive definitions and proofs.</p> <p>Several interesting language features, including binders and general recursion, illustrate the capabilities of our framework. We reuse these features to build fully mechanized definitions and proofs for a number of languages, including a version of mini-ML. Bounded induction enables proofs of properties for non-inductive semantic functions, and mediating type classes enable proof adaptation for more feature-rich languages.</p>", "authors": [{"name": "Benjamin Delaware", "author_profile_id": "81414620111", "affiliation": "University of Texas at Austin, Austin, TX, USA", "person_id": "P3977951", "email_address": "bendy@cs.utexas.edu", "orcid_id": ""}, {"name": "Bruno C. d. S. Oliveira", "author_profile_id": "81310493622", "affiliation": "National University of Singapore, Singapore, Singapore", "person_id": "P3977952", "email_address": "oliveira@comp.nus.edu.sg", "orcid_id": ""}, {"name": "Tom Schrijvers", "author_profile_id": "81100049265", "affiliation": "Universiteit Gent, Ghent, Belgium", "person_id": "P3977953", "email_address": "tom.schrijvers@ugent.be", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429094", "year": "2013", "article_id": "2429094", "conference": "POPL", "title": "Meta-theory &#224; la carte", "url": "http://dl.acm.org/citation.cfm?id=2429094"}