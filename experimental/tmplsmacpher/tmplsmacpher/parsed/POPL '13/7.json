{"article_publication_date": "01-23-2013", "fulltext": "\n Automating Relatively Complete Veri.cation of Higher-Order Functional Programs Hiroshi Unno Tachio \nTerauchi Naoki Kobayashi University of Tsukuba Nagoya University University of Tokyo uhiro@cs.tsukuba.ac.jp \nterauchi@is.nagoya-u.ac.jp koba@is.s.u-tokyo.ac.jp Abstract We present an automated approach to relatively \ncompletely veri\u00adfying safety (i.e., reachability) property of higher-order functional programs. Our contribution \nis two-fold. First, we extend the re.ne\u00adment type system framework employed in the recent work on (in\u00adcomplete) \nautomated higher-order veri.cation by drawing on the classical work on relatively complete Hoare logic \nlike program logic for higher-order procedural languages. Then, by adopting the recently proposed techniques \nfor solving constraints over quanti\u00ad.ed .rst-order logic formulas, we develop an automated type infer\u00adence \nmethod for the type system, thereby realizing an automated relatively complete veri.cation of higher-order \nprograms. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; \nF.3.1 [Logics and Meaning of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams Keywords \nRelative Completeness, Higher-Order Programs, Soft\u00adware Model Checking, Type Inference 1. Introduction \nRecently, motivated by the success of software model checkers [12] for the automated veri.cation of .rst-order \nprograms, researchers have proposed model checkers for the automated veri.cation of higher-order programs \n[13, 18, 23, 26, 27]. Interestingly, they have all been formulated as a form of re.nement type inference.1 \nThe re.nement type systems employed in the automated higher\u00adorder program veri.cation have some important \ndifferences from the ones from the original, non-automated approaches like DML [30], making them more \namenable to automation (such as the lack of implicit . types). But, they follow the non-automated ones \nin that the types embed .rst-order logic (FOL) formulas, called re.nement predicates, over program values \n(as in dependent types) that are used to express and enforce detailed properties of the program. For \nexample, consider the OCaml program shown in Fig\u00adure 1. Here, * denotes a non-deterministic choice. Given \nan in\u00ad 1In fact, the equivalence of model checking and re.nement type inference has been shown for the \n.nite domain base-type data case [16, 17]. Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 13, January 23 25, 2013, Rome, Italy. Copyright c &#38;#169; 2013 \nACM 978-1-4503-1832-7/13/01. . . $10.00 let rec app x f = if * then app (x+1) f else f x in let check \nx y = if x <= y then () else assert false in let main i = app i (check i) Figure 1. Asimple higher-order \nprogram. teger argument i to main, the program recursively calls app non\u00addeterministically to apply \nthe closure check i to i+ jwhere jis the number of times the then branch is taken in app. The program \nis safe in that assert false is unreachable for any argument i. The program is dif.cult to verify via \n.rst-order program veri.cation methods because of the higher-order recursive function app. Recent advances \nin higher-order program veri.cation have en\u00adabled automated veri.cation of such programs via re.nement \ntype inference. For the program above, the following re.nement types may be automatically inferred to \nverify its safety.2 app : x:int . f:({u:int |u = x} . unit). unit check : x:int . y:{u:int |u = x} . \nunit main : i:int . unit The type of app expresses the fact that the function takes an integer argument \nx, and a function-type argument f which takes an integer at least as large as x. The type of check says \nthat it takes integers x and y such that x = y. And, the type of main says that it takes any integer \nargument. The re.nement type systems underlying the veri.ers are sound, that is, they only type safe \nprograms. However, they are incomplete in that there are safe programs that they cannot type. Indeed, \nthe only known positive result is for the class of the .nite domain base-type data programs, which can \nbe veri.ed completely by a re.nement type system augmented with intersection types [16, 17]. The situation \nis in stark contrast to that of automated .rst-order program veri.cation [12] where the underlying program \nlogic, such as the Hoare logic, is relatively complete. For example, none of the re.nement type systems \nproposed for automated higher-order program veri.cation can type and verify the program shown in Figure \n2, even though the program is only a small modi.cation of the one from Figure 1: it simply switches the \norder of app s arguments. Nor, are they able to type and verify the program shown in Figure 3, which \nuses the function succ to successively build closures to pass integers larger than i to check i. The \nprogram is untypable even if we were allowed to change the order of the function arguments. We note that \nthis is an incompleteness at the level of the pro\u00adgram logic (i.e., re.nement type system) and not the \nveri.cation algorithm (i.e., type inference algorithm). That is, there exist no types within the re.nement \ntype system that can type the program, 2The type syntax is borrowed from Augustsson [1]. let rec app \nf x = if * then app f (x+1) else f x in let check x y = if x <= y then () else assert false in let main \ni = app (check i) i Figure 2. Avariant of Figure 1. let rec app3 f g = if * then app3 (succ f) g else \ng f in let app x f = f x in let succ f x = f (x + 1) in let check x y = if x <= y then () else assert \nfalse in let main i = app3 (check i) (app i) Figure 3. Another variant of Figure 1. let alone inferable \nones. While higher-order program veri.cation is in general undecidable, like the .rst-order program veri.cation \nis, it would be desirable to have a relatively complete reasoning frame\u00adwork that would serve as the \nbasis of veri.cation algorithms, as the Hoare logic does for .rst-order programs. To this end, this paper \npresents an automated approach to a relatively complete veri.cation of higher-order programs. First, \nwe present an extension to the re.nement type system such that the resulting re.nement type system is \nrelatively complete. The extension is inspired by the classical work on relatively complete program logic \nfor higher-order procedural languages by German et al. [6, 7] (also, [8]) who showed that relative completeness \nis achievable while avoiding the explicit use of functions as data so as to maintain a Hoare logic like \ncontrol-data separation. However, their proof of relative completeness does use encod\u00ading of functions \nas base-type data, and we rely on the same tech\u00adnique for our relative completeness proof. Moreover, \nto hide the use of functions as data from the program logic, they introduce quan\u00adti.ers that the client \nveri.er must appropriately instantiate. (To the best of our knowledge, no actual veri.er was built based \non their program logic.) Therefore, as our second contribution, we show a type inference method that \nextends the .rst-order logic constraint solving of the previous automated re.nement type inference sys\u00adtems \nto quanti.ed reasoning by leveraging recent advances on a related problem [4, 9, 24]. In summary, the \npaper s contributions are as follows. A re.nement type system that is relatively complete for safety \nveri.cation of higher-order functional programs.  A type inference algorithm for the re.nement type \nsystem.  In the next section, we give an informal overview of the main ideas. On incompleteness of the \ninference: The type inference algo\u00adrithm that we propose is, of course, incomplete in that it is not \nable to decide the typability of all programs. This is expected because safety veri.cation is undecidable \nin general. Instead, our contri\u00adbution is a type system that is complete relative to a hypothetical theorem \nprover complete for .rst-order arithmetic, and a novel in\u00adference algorithm that is able to automatically \nverify a non-trivial subset of the programs that were not possible to verify with the previous automated \napproaches.  2. Informal Overview We informally describe the incompleteness issue by showing how the \nexisting approaches [13, 18, 23, 26, 27] fail to type the programs shown in Figures 2 and 3. First, let \nus try to type Figure 2. Here, the goal is to show that main can be given the type i:int . unit, that \nis, main is safe to be called with any integer i. (For a base type B, we often abbreviate the re.nement \ntype {u:B | .} as B. E.g., int = {u:int | .}.) Therefore, we try to type the body of main under the assumption \nthat the type of i is {u:int | .}. The most precise type for the partial application check i is y:{u:int \n|u = i} . unit (i.e., functions that can take any integer at least as large as i), and the most precise \ntype for i is {u:int |u = i} (i.e., integers equal to i). (Intuitively, {u:B |.}expresses values of the \nbase type B satisfying the re.nement predicate ., and x : t . s expresses functions that return a value \nof the type s[e/x] when given the argument e of the type t.) We show that the type systems fail to give \nthe higher-order function app a suf.ciently precise type to verify the program s safety. The type of \napp must be of the form f:({u:int |.} . unit). x:{u:int |f} . unit where the re.nement predicates . \nand f are FOL formulas in the theory of base-type data.3 In addition, as discussed below, to prevent \ndegenerate types, the re.nement type systems enforce an important well-formedness condition that restricts \nthe variables that can appear free in a re.nement predicate. (Here, . and f are restricted so that fv(.) \n. {u}and fv(f) . {f, u}, where fv(.) denotes the free variables of ..) From the application f x in the \nbody of app, the type system asserts that f . ., that is, f must be safe to be given the argu\u00adment x. \nIn the body of main, app is applied to check i and i, and the type system asserts that the type of check \ni is a sub\u00adtype of {u:int |.} . unit and the type of i is a subtype of {u:int |f}. This leads to the \nconstraints u = i . f and . . u = i, accurately expressing the fact that i is passed as the second argument \nto app and that the .rst argument to app (i.e., check i)expects a value at least as large as i. Asolution \nto the set of constraints is . = u = i and f = u = i, but this is degenerate because main s variable \ni would appear in app s type. (Recall that ., f are re.nement predicates of app s type.) Intuitively, \nit means that the function app could see values from a speci.c context of its use (i.e., main). Indeed, \nas remarked above, the re.nement type systems disallow such degenerate types via the well-formedness \ncondition, and only allow ., f such that fv(.) . {u}and fv(f) . {f, u}. That is, the re.nement predi\u00adcates \nare allowed to only mention the variables in their respective scopes. Consequently, the program is (conservatively) \nrejected as untypable. It is worth noting that the program of Figure 1 does not have this issue as app \ns arguments are conveniently ordered so that app s function-type argument could depend on the base-type \nargu\u00adment to allow the following suf.ciently precise type: x:int . f:({u:int |u = x} . unit). unit Unfortunately, \nas exempli.ed by Figure 3, the incompleteness issue is not just a matter of choosing the right order \nof function arguments. Here, the program is untypable even if we were allowed to change the order of \nthe arguments, and the untypability comes from not being able to give a precise enough type to app3. \nIdeally, we would like to express via app3 s type the fact that g is safe when applied to f (and also \nwhen applied to succj f for any j> 0). But, this requires a type that is parametric in f and g s behavior, \nand that cannot be given because the only parameters of app3 are f and g, and they are both function-type \narguments. Note that re.nement predicates of the form g is safe to be called with f are prohibited as \nthey are required to be FOL formulas over the base-type data. 3We could also give non-. re.nement predicates \nto unit, but it does not affect the example. 2.1 Our Approach Our approach to solving the incompleteness \nissue is inspired by the research on relatively complete program logic for higher-order procedural languages \n[6 8]. The main idea is to add extra dummy base-type parameters that are instantiated appropriately so \nthat the re.nement type of a higher-order function can depend on the parameters. For example, for the \nprogram of Figure 2, we add an extra base\u00adtype parameter a to app and obtain the following program. let \nrec app a f x = if * then app[a] f (x+1) else f x in let check x y = if x <= y then () else assert false \nin let main i = app[i] (check i) i Here, for clarity, the parameter passings for the extra parameters \nare written as quanti.er instantiations, but they may be understood as ordinary function applications \n(e.g., app[a] is app a). With the addition of the extra parameter, it becomes possible for the existing \nre.nement type systems designed for automated veri.cation to type and verify the program. For example, \nthe following types are suf.cient for typing the program. app : a:int . f:(t . unit). x:t . unit check \n: x:int . y:{u:int |u = x} . unit main : i:int . unit where t = {u:int |u = a}. Note that the extra parameter \na is used to parametrize f s behavior in the type of app. There is a simple rule to adding extra parameters \nthat can be shown to be suf.cient for relative completeness: add one just before each function-type argument. \nFollowing the rule, for example, the program of Figure 3 is translated as follows. let rec app3 a f b \ng = if * then (app3[a] (succ[a] f))[a] g else g[a] f in let succ b f x = f (x + 1) in let check x y \n= if x <= y then () else assert false in let app x a f = f x in let main i = (app3[i] (check i))[i] \n(app i) And, it can be shown that the resulting program is typable, for example, by the following types. \napp3 : a:int . f:t1 . b:int . g:t2 . unit app : x:int . a:int . f:({u:int |u = x} . unit). unit succ \n: b:int . f:(s . unit). x:s . unit check : x:int . y:{u:int |u = x} . unit main : i:int . unit where \ns = {u:int |u = b}, t1 = {u:int |u = a} . unit, and t2 = c:int . t1 . unit. However, the rule does not \nanswer how the extra parameters should be instantiated. (In the above, we seem to have magically conjured \nthe appropriate instantiations i and a!) Indeed, an anal\u00adogous rule was .rst discovered by German, Clarke, \nand Halpern [6, 7] in their work on a relatively complete program logic for higher-order procedural languages, \nand their proof of relative com\u00adpleteness relies on the fact that, with an expressive theory of the base-type \ndata domain (such as Peano arithmetic), one can encode each function closure as a base-type data expression \nso that the ex\u00adtra parameters can be instantiated by the base-type data representa\u00adtion of the corresponding \nfunction-type argument. However, explic\u00aditly instantiating the extra parameters by such encoded expressions \nand forcing the client veri.er to reason about them is impractical. d ::= d. {F -. x = e} | \u00d8 e ::= x \n|F |c |let x = e1 in e2 |e x | if * then e1 else e2 Figure 4. The syntax of the simple functional language. \n Therefore, they proposed to leave the instantiations unspeci.ed in the program logic so that the task \nof .nding suf.cient instantiations is left to (the FOL theorem prover of) the client veri.er. Following \nthe idea, for example, the program of Figure 2 is translated as follows by introducing fresh variables \nv1 and v2. let rec app a f x = if * then app[v1] f (x+1) else f x in let check x y = if x <= y then () \nelse assert false in let main i = app[v2] (check i) i Then, the re.nement type inference problem is \nreduced to the prob\u00adlem of .nding appropriate instantiations for v1 and v2 along with the types for the \nprogram. For this, we extend the FOL constraint solving used in the previous work on re.nement type inference \nwith quanti.ed reasoning over template expressions [4, 9, 24]. Con\u00adcretely, in Section 4, we show how \nthe counterexample-guided re\u00ad.nement type inference [18, 26] can be extended in this way to infer appropriate \ninstantiations as well as types. 2.2 Paper Organization The rest of the paper is organized as follows. \nSection 3 presents the re.nement type system along with the target functional lan\u00adguage, and proves its \nrelative completeness under the extra param\u00adeter addition strategy. Section 4 presents the type inference \nalgo\u00adrithm. Section 5 presents the preliminary experience with the type inference algorithm, implemented \nas an extension to the higher\u00adorder software model checker (i.e., re.nement type inference sys\u00adtem) MoCHi \n[18]. Section 6 discusses related work, and Section 7 concludes. The extended report [28] contains the \nomitted materials.  3. Language and Type System We formalize the target programming language. Figure \n4 shows the syntax. The language is essentially the simply-typed lambda calcu\u00adlus with recursion and \nprimitives for integer arithmetic operations. For simplicity the only base-type data in this language \nis integers, but other base types and their operations can be encoded in the standard way: for example, \ntrue = 1and false = 0. - . A program, d, is a .nite set of function de.nitions, F x = e, - . de.ning \na function named F with the formal parameters x and the - . body e. The notation a denotes a possibly \nempty sequence. The functions are mutually recursive in that the body of a function may refer to other \nfunctions, including itself. Each function is closed except for the free function names (i.e., functions \nare lambda lifted [15]). We also assume that d contains a function named main that only takes base-type \n(i.e., integer) arguments. Expressions, e, comprise non-deterministic branches, let ex\u00adpressions, constants \nc, function names F, variables x, and (constant or user-de.ned function) applications e x. Constants \ninclude inte\u00adger constants such as -1,0,1,2, and integer operations such as + and =(recall that we model \nbooleans via integers). We assume that there are unary constant operators named assert and assume. We \nrestrict expressions to be in continuation passing style (CPS) so that they are non-returning, except \nwhen they occur let-bound (i.e., occurs as e1 in let x = e1 in e2). By contrast, let-bound ex\u00adpressions \nare restricted to be non-CPS (i.e., value returning) expres\u00adsions, which are total applications of constant \noperators including the assume and assertion expressions assume x and assert x, and let x = e1 in e2 \n.d e2[e3/x] where e1 . e3 let x = assert 1in e .d e[1/x] let x = assert iin e .d fail where i .= 1 let \nx = assume 1in e .d e[1/x] F e .d e ' [e /x ] where F . d let x = assume iin e .d safe where i .1= if \n* then e1 else e2 .d e1 if * then e1 else e2 .d e2 -. --.. -. ' x = e Figure 5. The reduction rules. \npartial applications (of user-de.ned functions). We restrict constant operator applications to be total. \nCPS/A-normal-form-style is used for simplicity. Direct-style syntax can be supported by CPS conver\u00adsion. \nThe rest of the syntax is straightforward. As usual, applications associate to the left so that e0 e1 \ne2 = (e0 e1) e2. We write -. - . e0 e for the series of applications e0 e1 e2 . . . en where e = e1, \ne2,. . . , en. We write e1;e2 for let x = e1 in e2 such that x ./fv(e2), where fv(e)denotes the free \nvariables of e. Without loss of generality, we assume that bound variables are distinct. Note that, while \nthe language only has non-deterministic branches, a conditional branch if x then e1 else e2 can be encoded \nas if * then assume x;e1 else let y= \u00acx in assume y;e2 which is equivalent for assertion safety. We de.ne \nthe operational semantics of the language as a small\u00adstep reduction relation from states to states. A \nstate is a run-time expression e that extends the source expressions with non-variable arguments at function \napplications, a special failure state fail, and a special safe state safe. (We overload the symbol e \nto range over run-time expressions when it is clear from the context.) The reduction relation .d is de.ned \nby the rules shown in Figure 5. Here, e . e ' denotes the evaluation of the value returning -. - . expression \ne to the value e ' , and is de.ned as F e . F e and -. - . c e . [[c]](e )where [[c]] is the relation \ndenoting the semantics of a non-assume/assert constant c, so that, for example [[+]](i, j) = i + j for \nintegers i and j. (An integer constant is represented by - . a 0-ary constant.) We let partial applications \n(i.e., F e )represent function closures. Formally, a value is either an integer constant or a function \nclosure. The semantics of a program dis de.ned as a series of reductions - . -. - . starting from an \ninitial state emain [i /x ]where main x =emain . d -. - . . and i are integer arguments for main (i.e., \n|i | = |-x |). Note that, because of CPS, reductions only occur at the top level. We write e . * d e \n' for zero or more reductions from e to e ' . We say that a program is (assertion) safe if its evaluation \ndoes not cause an . . assertion failure, that is, if emain [ -i /-x ]..d * fail for any arguments - . \ni of main. We assume that a program is typed under the standard simple type system whose type grammar \nis shown below. s ::= . |int |s . s ' Here, the type . represents the type of a CPS expression. For each \nexpression e in the program, we write sty(e)to denote its simple type. The typability in the simple type \nsystem assures that the pro\u00adgram does not get stuck , for example, by trying to use an inte\u00adger as a \nfunction, but it does not guarantee its safety. Therefore, a program either runs forever safely (due \nto CPS, a program cannot return), stops safely in the state safe by reaching a false assume, or aborts \nwith an assertion failure. The typing rules for the simple type system are standard and are deferred \nto the extended report [28]. t, s ::= . | {u |.} | x:s . t Figure 6. The syntax of re.nement types. sty(x)= \nint sty(.).. Vb Vf G . x : {u |u = x} G . . : G(.) G . e1 : s G, x :s . e2 : . Cst Let G . c : ty(c) \nG . let x = e1 in e2 : . G . e : y:s . t G . x : s App G . e x : t[x/y] G . e1 : . G . e2 : . If G . \nif * then e1 else e2 : . G . e : s G . s = t fv(t). dom(G) Sub G . e : t Figure 7. The typing rules. \n 3.1 Re.nement Type System We present a re.nement type system for the language. First, we present a sound \nbut incomplete re.nement type system without the extra parameter addition, and then introduce the extra \nparameter ad\u00addition as an extension in Section 3.2. The (incomplete) re.nement type system is not signi.cantly \ndifferent from the ones proposed previously for automated veri.cation [13, 18, 23, 26, 27] (e.g., it \ncan be obtained by removing intersection types from [18, 26]4). Figure 6 shows the syntax of re.nement \ntypes. Here, {u |.} is a re.nement base (i.e., integer) type that re.nes an integer by the re.nement \npredicate . which is a FOL arithmetic formula over the base (i.e., integer) type variables.5 We sometimes \nabbreviate {u |.} as int when . is a tautology (e.g., {u | .} = int). Intuitively, {u |.} denotes the \ntype of integers u satisfying the formula .. The type x :s . t is a dependent function type, consisting \nof the argument type s and the return type t. Intuitively, x :s . t denotes the type of a function (or \na constant operation) that returns a value of the type t[y/x]when applied to an argument y of the type \ns. As usual, .associates to the right. The type {x |.}binds x in .. Likewise, x:s . t binds x in t (but \nnot in s). That is, fv({x |.})= fv(.)\\ {x} fv(x:s . t)= fv(s).(fv(t)\\ {x}) We sometimes abbreviate x \n: s . t as s . t when x does not occur free in t. (It actually suf.ces to limit x to occur free in t \nonly if x is a base type argument because re.nement predicates are restricted to be over the base-type \nvariables.) Types are equivalent up to renaming of bound variables. The simple-type shape of s, tshape(s), \nis de.ned as follows: tshape({u |.})= int tshape(.)= . tshape(x:s . t)= tshape(s). tshape(t) 4While \nintersection types are not needed for relative completeness, they compromise neither soundness nor completeness, \nand sometimes aid the veri.cation in practice. The implementation shown in Section 5 supports intersection \ntypes. 5The full theory of Peano arithmetic is needed for relative completeness, but any subset (e.g., \nthe quanti.er-free theory of linear arithmetic) is suf.\u00adcient for soundness. G . s2 = s1 G,x : s2 . \nt1 = t2 Sf G . x:s1 . t1 = x:s2 . t2 u /. fv([[G]]) ([[G]]..1). .2 Sc Sb G . . = . G . {u |.1}= {u |.2} \nFigure 8. The subtyping rules. Figure 7shows the typingrules. The judgements for the expres\u00adsions are \nof the form G . e : t where G is a type environment mapping variables and function names to types. We \ndiscuss each typing rule. Vb types base-type variables. Note that the rule ignores the environment. Expressibility \nis not reduced, however, because the assumption about x in the environ\u00adment gets discharged at subtyping. \nVf types function-type vari\u00adables and function names bylooking up the environment. Here, . denotes the \nset of simple function types. (We use the meta variable .to range over bothvariables andfunction names.)Cst \ntypes con\u00adstants. Here, ty(c)denotes the pre-assigned type of the constant c such that ty(assume)= x:int \n. {u |x = 1.u = 1} ty(assert)= x:{u |u = 1}. {u |u = 1} and ty(c) is the precise type for a non-assume/assert \nconstant c (e.g., ty(+) = x : int . y:int . {u |u = x + y}).6 Let is self-explanatory. App types applications. \nHere, t[x/y]is the usual capture-avoiding substitution. If types branch expressions. Sub is the subsumption \nrule. The subtyping relation is de.ned in Figure 8. In Sb, [[G]]is the FOL formula denoting the assump\u00adtions \nabout the base-type variables in G, and is de.ned as follows. [[G]]=.[x/u] x:{u|.}.G Like the rule of \nconsequence of the Hoare logic [10], Sb asks the client veri.er (i.e., the type inference system)to decide \nthe validity of arbitrary FOL arithmetic formulas. As expected, our complete\u00adness result is relative \nto the hypothetical completeness of deciding this. In veri.cation practice, one may settle for incomplete \ntheo\u00adrem proving or a decidable theory subset to make type checking decidable.7 Subenforces well-formedness \nof the introduced type by assert\u00ading that its free variables appear bound in the environment. As shown \nbelow, the top-level types (i.e., the types of the recursive functions)are required not to contain free \nvariables. DEFINITION 3.1 (Well-formed type). We say that a type is closed if it has no free variables. \nLet . be a top-level type environment mapping function names to types. We say that s is a well-formed \ntype for F if s is closed and tshape(s)= sty(F). We say that .is a well-formed top-level type environment \nif .(F)is well-formed for each F. - . Let us write x:s . t to abbreviate the function type x1:s1 . - \n. \u00b7 \u00b7 \u00b7 . xn :sn . t where x:s = x1 :s1,. . . ,xn :sn. We de.ne the notion of a well-typed program. DEFINITION \n3.2 (Well-typed program). We write . . d if the following conditions hold. (1) .is a well-formed top-level \ntype environment. 6See the extended report [28]for the de.nition of a precise constant type. Also, non-precise \nbut sound constant types, that over-approximate the ac\u00adtual semantics, are suf.cient for soundness. 7Also, \ntype checking being decidable is different from type inference (i.e., typability) being decidable. The \nprevious research has proposed various incomplete inference approaches [13, 18, 23, 26, 27]. -. - . \n(2) For each function F x = e . d, we have .,x:s . e : . where - . .(F)= x:s . .. ---. (3) .(main) is \nof the form x:int . .. (I.e., the re.nement predicates for the arguments of main are all ..) Aprogram \ndis said to be well-typed (equivalently, typable)if there exists .such that . . d. The condition (2) \nsays that . contains .xed-point types for the recursive functions comprising d, and (3)says that main \nis safe to be called with any arguments (recall that main is a function over integer arguments). The \ntype system is sound in that it ensures that a well-typed program does not cause an assertion failure. \nTHEOREM 3.3 (Soundness). If . . dthen dis safe. The theorem follows from the soundness of the re.nement \ntype system extended with extra parameter additions (Theorem 3.6). EXAMPLE 3.4. Let the program d1 consist \nof the following func\u00adtions. app x f = if * then app (x +1)f else f x check x y= if * then assume (x \n= y);check x y else assume \u00ac(x = y);assert 0;check x y main i= app i(check i) The program is the one \nfrom Figure 1 translated into the target language. (We elide A-normalization for readability.)Let .be \nthe followingtype environment. .(app)= x:int . f:({u |u = x}. .). . .(check)= x:int . y:{u |u = x}. . \n.(main)= i:int . . It is routine to check that . . d1. Therefore, d1 is typable and is safe. Next, consider \nd2 shown below. app f x = if * then app f (x + 1)else f x check x y= if * then assume (x = y);check x \ny else assume \u00ac(x = y);assert 0;check x y main i= app (check i)i The program is a translation of the \nprogram from Figure 2. The program is safe but untypable (as remarkedin Section 2, also under the previous \nre.nement type systems [13, 18, 23, 26, 27]). Note that we cannot simply assign app the type .(app)from \nthe above but with the order of x and f reversed so that f:({u |u = x}. .). x:int . . The type is not \nclosed and therefore is not a well-formed top-level type (cf. De.nition 3.1). The well-formedness condition \nforces the re.nement predicates to only refer to the values passed earlier. Well-formedness is not a \nsuper.cial restriction: In the presence of higher-order functions and function closures (i.e., partial \napplica\u00adtions), we cannot generally determine up front in the program logic what willbe passed later \nto a closure. The issue is apparent in the following program d3, which is a translation of Figure 3. \napp3 f g= if * then app3 (succf)gelse gf app x f = f x succ f x = f (x + 1) check x y= if * then assume \n(x = y);check x y else assume \u00ac(x = y);assert 0;check x y main i= app3 (check i)(app i) As remarked \nin Section 2, the program is safe but untypable, even if we were allowed to change the order of the function \narguments. Here, it is not possible to determine what will be passed to the G .. e : .x:s.t G .. o : \ns o . pureExps Inst G .. e : t[o/x] G .. s2 = s1 G,x:s2 .. t1 = t2 S. G .. .x:s1.t1 = .x:s2.t2 Figure \n9. Additional typingrules. closures succj f without some non-trivialprogram reasoning(i.e., i captured \nin g added the number of times app3 s then branch is taken before the else branch is reached). In effect, \nthe idea of the extra parameter addition for relative completeness is to delegate such tasks to the client \nveri.er.  3.2 Extra Parameters for Relative Completeness As shown in Example 3.4(also Section 2), the \nre.nement type sys\u00adtem is incomplete by itself. While a complete checking of safetyis clearly undecidable \nas the language allows arbitraryinteger opera\u00adtions, we would like to make the re.nement type system \nbe com\u00adplete relative to an oracle that could decide the FOL implications discharged at the subtyping \nrule Sb. Rather than formulating the extra parameter addition as a pro\u00adgram translation as done in Section \n2, here, we present it as a type system extension in the form of universally quanti.ed types. This is \nexpositionally convenient, because extra parameters can be rep\u00adresented as universally bound variables \nso that they can be easily distinguished from ordinary parameters. We extend the grammar of re.nement \ntypes with universally quanti.ed types as follows. t,s ::= ... |.x:s.t In .x:s.t, x is a binding occurrence \nand may occur free in t (i.e., fv(.x:s.t) = fv(s).(fv(t)\\{x})). Intuitively, it expresses the function \ntype x:s . t suchthat x is an extra parameter. We de.ne tshape(.x:s.t)= tshape(t). We extend the type \nsystem with the quanti.er instantiation and the subtypingrules shown in Figure 9. Here, pureExps is the \nset of side-effect-free integer-type expressions de.ned bythe grammar - . o ::= x |c o - . where x is \nan integer-type variable andc o is a totalapplication of a non-assume/assert constant.8 Therefore, Inst \nallows instantiation with any in-scope side-effect-free integer-type expression having the requested \ntype. S.is analogous to the subtyping rule for func\u00adtion types (i.e., Sf). To distinguish, we write .. \nfor the type judge\u00adments ofthe extended type system. Allthe rules from Figure 7 and Figure 8are assumedto \nbe includedin .. (with.replacedby..). The well-formedness de.nition is also retained from the pre\u00adextension \n(cf. De.nition 3.1). Therefore, for example, both x:int . ({u |u = 0}. .). . x:int . .y:int.({u |u = \ny}. .). . are well-formedre.nement types for F such that sty(F)= int . (int . .). .. Let . be a disjoint \nunion of variable bindings x:s or universal - . quanti.er bindings .x:s. The type abbreviation . . t \nis de.ned as follows. . - . .t if . = e . -.--- ... . . t = .x:s.t1 if . = .x:s, .1 and .1 . t = t1 . \n. ---... x:s . t1 if . = x:s, .1 and .1 . t = t1 8We extend the typing rules to (non-A-normal-form) side-effect-free \ninteger-type expressions in the obvious way. See the extended report [28]. - . (Note that this subsumes \nthe x:s . t abbreviation introduced .- . earlier.)Let (-. )be the sequence . with each universal quanti.er \nbinding .x : s replaced with the variable binding x : s. That is, --. .. (e)= e, and (x:s, . )= (.x:s, \n. )= x:s,(-. ). We extend the notion of well-typed program to accommodate universal quanti.er bindings. \nDEFINITION 3.5 (Well-typed program Extended). We write . .. dif the following conditions hold. (1) .is \na well-formed top-level type environment. -. . (2) For each function F x = e . d, we have .,(-. ) .. \ne : . - . where .(F)= . . .. ---. (3) .(main)is of the form x:int . .. A program dis said to be well-typed \nif .... .. d. - . Note that the only differences from De.nition 3.2 are . . . and . (-. )in (2)whichallow \nuniversalquanti.ers in the type ofthe func\u00adtions. Also, note that the well-formedness condition now allows \nthe re.nement predicates to refer to the universallyquanti.edvariables in their scope. We state the soundness \nofthe extended re.nement type system. THEOREM 3.6 (Soundness Extended). If . .. dthen dis safe. The \nproof is standard [23, 27, 29]and is deferred to the extended report [28]. As remarked in Section 2, \nfor relative completeness, it suf.ces to limit the position of extra parameters (i.e., universal quanti.ers) \nto one before each function-type parameter. To this end, we de.ne ushape(s) to be a simple type such \nthat, for a function of the simple type ushape(s), s has just the suf.cient extra parameters. Formally, \nushape(s)is de.ned bythe rules below. ushape({u |.})= int ushape(.)= . tshape(s)= int ushape(x:s . t)= \nushape(s). ushape(t) tshape(s ' )= int tshape(s).. ushape(.y:s ' .x:s . t)= ushape(s). ushape(t) Note \nthat ushape(s) is de.ned only for s that has one extra parameter just before a function-type parameter. \nAlso, for s such thatushape(s)is de.ned, we have ushape(s)= tshape(s). We are now ready to state the \nrelative completeness theorem, which says that if a program is safe then it can be typed with extra parameter \nadditions (even when their positions are restricted to the pattern above). THEOREM 3.7 (Relative Completeness). \nIf d is safe, then there exists . such that . .. d and ushape(.(F))= sty(F)for each - . F x = e . d. \nWe defer the proof to the extended report [28]. The proof adopts the ideas from the work on relatively \ncomplete program logics for higher-order procedural languages [6 8] that instantiate the extra parameters \nbythe base-type encodingofthe function closures. It is worth noting that, as a corollary of Theorem 3.7, \nit follows that the re.nement type system is relatively complete for .rst-order programs (i.e., programs \nwithout function-type parameters) even without the extra parameter extension. EXAMPLE 3.8. We show how \n.. types d2 and d3 from Exam\u00adple 3.4. First, we have .2 .. d2 where .2(app)= .a:int.f:({u |u = a}. .). \nx:{u |u = a}. . .2(check)= x:int . y:{u |u = x}. . .2(main)= i:int . .  Note that the types correspond \nto the ones used to type Figure 2 in Section 2.1. Also, note that ushape(.2(app)) = sty(app), ushape(.2(check)) \n= sty(check), and ushape(.2(main)) = sty(main). It is easy to see that check can be given the type .2(check). \nWe show that app can be given the type .2(app). We type the body of app under the type environment .2, \na : int, f : {u |u = a} . ., x : {u |u = a}. Therefore, the application f x type-checks to give the type \n.. To type the other branch, app f (x + 1), we instantiate .2(app)with a at app to give the type f:({u \n|u = a} . .). x:{u |u = a} . . The type is then used to give the application app f the type x : {u |u \n= a} . ., which in turn gives the branch the type .. Finally, main can be given the type .2(main) by \ninstantiating .2(app)with i. Likewise, let .3 be the following type environment. .3(app3)= .a:int.f :t1 \n. .b:int.g :t2 . . .3(app)= x:int . .a:int.f :({u |u = x} . .). . .3(succ)= .b:int.f :(s . .). x:s . \n. .3(check)= x:int . y:{u |u = x} . . .3(main)= i:int . . such that t1 = {u |u = a} . ., t2 = .c : int.t1 \n. ., and s = {u |u = b}. Note that ushape(F)= sty(.3(F)) for each F = app3, app, succ, check, and main. \nWe show that .3 .. d3 by following the same instantiation scheme used to type Figure 3 in Section 2.1. \nWe type the then branch of app3 by instantiating app3 and succ with a, and instantiating the resulting \napp3 (succ f) with a (or with an arbitrary side-effect-free integer-type expression, because bdoes not \nappear free in its scope in .3(app3)). The else branch can be typed by instantiating gwith an arbitrary \nside-effect\u00adfree integer-type expression (because c does not appear free in its scope in .3(app3)). Then, \nto type main, we instantiate app3 with i, and instantiate app3 (check i)with an arbitrary side-effect-free \ninteger-type expression. The examples show that instantiating via simple expressions are often suf.cient \nfor verifying safety, and not all quanti.ers may even be needed. (Contrast this with the instantiation \nvia G\u00a8odel number\u00ading used in the proof of Theorem 3.7.9)We take advantage of the observation in the \ntype inference method described in Section 4.  4. Type Inference The type inference framework is based \non, and extends the recent work on the counterexample-guided approach to re.nement type inference [18, \n26] (but, the idea may be adopted to extend the back\u00adend of other re.nement type inference systems like \n[13, 27]). To al\u00adlow smooth adoption and use the existing type inference algorithms mostly as a blackbox, \nwe implement the extra parameter addition as a program translation as in Section 2, instead of modifying \nthe underlying type system to model it by universally quanti.ed types as in Section 3.2. Figure 10 shows \nthe overview of the type inference process. In Step 1, we translate the given program by adding extra \nparameters as done in Section 2. Here, we maintain and use a parameter substitution for instantiating \nthe extra parameters. We initialize the instantiation expressions to arbitrary constants (e.g., 0), and \nthen perform a counterexample-guided re.nement type inference over the translated program. Following \nthe counterexample-guided abstraction re.nement (CEGAR) scheme popularized in model checking [3, 12], \nin the counterexample-guided re.nement type inference, we maintain a 9This can be seen as a difference \nbetween just checking safety and express\u00ading the precise semantics as weakest preconditions. Input Program \nSafe Unsafe Figure 10. The type inference overview. set of candidate re.nement types (or the re.nement \npredicates that comprise them). Then, we try to .nd a type assignment for the program within the candidates \nvia the standard .xed-point type inference process (Step 2 in Figure 10). The .xed-point type inference \nuses an automated FOL theorem prover, such as a SMT solver, to decide the FOL implications discharged \nat the subtyping rule Sb. We refer interested readers to the previous work [18, 26] for details. A counterexample \nis generated when the candidates are found insuf.cient, and we analyze the reason for the failure to \neither val\u00adidate the counterexample (Step 3), or update the candidate types or the parameter substitution \nto eliminate the spurious counterex\u00adample (Step 4). In the re.nement step, the previous work [18, 26] \nonly generated new candidate types (i.e., the arrow from Step 4 to Step 2). But, because of the incompleteness \nof the underlying type system, some spurious counterexamples are impossible to refute by just adding \nnew candidate types. The key component of our new type inference method is generating new parameter substitutions \nin such a situation (i.e., the arrow from Step 4 to Step 1). Then, the CEGAR process is repeated with \nthe updated candi\u00addate types or the updated parameter substitutions. The former case is identical to \nthe previous work, and in the latter case, we repeat from Step 1 to re-translate the program with the \nupdated parameter instantiations. 4.1 Adding Extra Parameters We add an extra parameter just before each \nfunction-type param\u00adeter. Also, we assign a unique label to each sub-expression of the program where \na parameter instantiation occurs. (Note that such places are syntactically determined.) Let L be the \nset of the labels and bvs(l)denote the base-type variables that can occur free in the scope of the sub-expression \nwith the label l . L. The type inference process maintains the parameter substitution P that maps each \nl to a side-effect-free integer-type expression o such that fv(o) . bvs(l). We use P(l) as the instantiation \nexpression at l. We restrict the range of P, and therefore, the instantiation expressions, to linear \narithmetic expressions. That is, P(l)is restricted to be of the form c0 +c1x1 + \u00b7 \u00b7 \u00b7 + cnxn where bvs(l)= \n{x1,. . . , xn}and c0,. . . , cn are integer constants. This is an important design choice motivated \nboth by the desire to minimize the complexity of the type inference, and also by the ob\u00adservation that \nsuf.cient instantiations tend to be simple expressions in practice (cf. Example 3.8). The parameter \nsubstitution P may be initialized arbitrarily, for example, P(l) = 0 for all l. We translate the input \nprogram by adding the extra parameters to the function de.nitions and replacing each instantiation site \ne with the application eP (l)where lis the label of e. EXAMPLE 4.1. Recall the program d2 in Example \n3.4. We add an extra parameter a just before the function-type parameter f of app. Let l1 and l2 be the \nlabels of the occurrences of app in the body of app and main respectively. We have L = {l1, l2}, bvs(l1)= \n{a, x}, and bvs(l2)= {i}. Suppose that the parameter substitution is P = {l1 . a, l2 . i}. Then, d2 is \ntranslated to the program dP shown below. app a f x = if * then app a f (x + 1) else f x check x y = \nif * then assume (x = y); check x y else assume \u00ac(x = y); assert 0; check x y main i= app i(check i)i \n 4.2 Counterexample-Guided Re.nement In MoCHi [18], a counterexample is a straightline higher-order \nprogram (SHP) that is untypable with the current candidate types. SHP is de.ned to be a recursion-free \nslice of the target program ob\u00adtained by copying functions and removing branches so that it con\u00adtains \nno branches and every function occurrence is linear (i.e., each function is called only once).10 Intuitively, \na counterexample corresponds to the (abstract) program path taken to reach the asser\u00adtion failure. We \ncheck if the counterexample SHP is feasible. This part is identical to the previous work [18] and is \ndone by symbolically evaluating the SHP. If it is feasible, then the program is determined unsafe and \nwe are done. Otherwise, we attempt to infer re.nement types for the SHP. If the SHP is found typable, \nthen the inferred re.nement types (or the re.nement predicates embedded therein) are added to the candidates \nand the CEGAR iteration returns to the .xed-point type inference phase (i.e., Step 2 of Figure 10). We \ninfer types for counterexamples by using the techniques from the previous work [18, 26, 27] that reduce \nthe inference problem to solving constraints over FOL formulas and predicate variables such that the \npredicate variables serve as placeholders of the re.nement predicates to be inferred. We refer to the \nprevious work for details. EXAMPLE 4.2. Given dP from Example 4.1, MoCHi may gener\u00adate the SHP dS shown \nbelow. app1 a f x = app2 a f (x + 1) app2 a f x = f x check x y = assume \u00ac(x = y); assert 0 main i= app1 \ni(check i)i Note that dS is recursion-free and linear. The SHP is typable and MoCHi may infer re.nement \ntypes .such that .(app1)= .(app2)= a:int . f:({u |u = a} . .). x:{u |u = a} . . .(check)= x:int . y:{u \n|u = x} . . .(main)= i:int . . Note that . . dS. As remarked above, because of the incompleteness of \nthe un\u00adderlying type system (i.e., .), sometimes, a counterexample that is detected to be infeasible \nis also found untypable. (The feasibility 10 [26] de.nes a counterexample to be simply a currently-untypable \nrecursion-free program slice (i.e., possibly containing branches and non\u00adlinearity), but uses linear \nintersection types to obtain a similar effect. check is actually relatively complete.) In such a situation, \nwe in\u00adfer a new parameter substitution PR for the SHP so that the SHP with each of its instantiation \nsite l instantiated with PR(l)is ty\u00adpable. Then, we update the parameter substitution with PR, that is, \nwe set P := PR .P|L\\LSHP where LSHP is the labels of the SHP. And, the CEGAR process returns to the parameter \naddition phase to re-translate the program (i.e., Step 1 of Figure 10). The parameter substitution inference \nproceeds as follows. First, we assign labels to the SHP such that every copy of a sub\u00adexpression gets \nthe same label as the one in the original. (Note that because of function copying, the same expression \nin the original program can have multiple copies in the SHP.) Next, we introduce a parameter substitution \ntemplate, PT , that maps each l . LSHP to a linear arithmetic expression template p0 + p1x1 + \u00b7 \u00b7 \u00b7 + \npnxn, where bvs(l) = {x1,. . . , xn} and p0,. . . , pn are fresh integer variables. This, in turn, induces \na SHP template that has PT (l)as the instantiation expression at each l . LSHP. Now, the problem of inferring \nPR is reduced to that of infer\u00adring an appropriate integer substitution for the integer variables - . \np in the template. We reduce the problem to constraint solving -. . by generating a FOL constraint over \np of the form .-x .. (for -. - . some non-linear FOL formula .over the variables p and x ). That is, \nthe SHP is typable with the instantiation expression PT(l). . at each l iff (.-x ..). holds where . \nis a substitution that maps - . p to integer constants. Although the problem of solving quan\u00adti.ed integer \nnon-linear FOL constraints is undecidable in gen\u00aderal, the recently proposed constraint solving techniques \nbased on Farkas lemma [4, 9, 24] have shown effective for our application in many cases. We describe \nthe constraint generation process in Section 4.2.1 and the constraint solving process in Section 4.2.2. \n4.2.1 Constraint Generation The constraint generation algorithm is essentially the same as the ones from \nthe previous work [18, 26, 27] used for candidate type inference. We give a brief review of the algorithm. \nFor each func\u00adtion in the program, we prepare type templates containing predicate variables that serve \nas placeholders of the re.nement predicates to be inferred. Then, we generate constraints over the predicate \nvari\u00adables in the standard way. That is, we apply the typing rules to the SHP but restricting the application \nof the subsumption rule Sub to just the argument position of function applications (cf. Section 3.1). \nThis generates constraints over the type templates, which, in turn, reduce to Horn-clause-like constraints \nover the predicate variables. (See the extended report [28] for the formal de.nition of the con\u00adstraint \ngeneration rules.) Because SHP is recursion-free and linear, the generated Horn clauses are non-recursive, \nand we can obtain an equivalent FOL formula. EXAMPLE 4.3. Consider the SHP d ' shown below, which is \nS equivalent to dS from Example 4.2 except that the extra param\u00adeter of app1 is instantiated by 0instead \nof i. app1 a f x = app2 a f (x + 1) app2 a f x = f x check x y = assume \u00ac(x = y); assert 0 main i= app1 \n0 (check i)i It is easy to see that the counterexample d ' S is infeasible (i.e., is safe), and MoCHi \nis also able to detect the infeasibility. However, d ' S is untypable with the underlying type system \n. because of the inappropriate instantiation expression. To infer a new instantiation expression, we \nprepare the param\u00adeter substitution template PT for the instantiation sites of d ' S, and from it, obtain \nthe SHP template dT shown below.  app1 a f x = app2 (p0 + p1a + p2x)f (x + 1) app2 a f x = f x check \nx y = assume \u00ac(x = y); assert 0 main i= app1 (p3 +p4i) (check i)i where p0,. . . , p4 are free integer \nvariables. Next, we generate the constraints by preparing the type template .such that .(app1)= a:{u \n|P1(u)} . ({u |P2(a, u)} . .). {u |P3(a, u)} . . .(app2)= a:{u |P4(u)} . ({u |P5(a, u)} . .). {u |P6(a, \nu)} . . .(check)= x:{u |P7(u)} . y:{u |P8(x, u)} . . .(main)= i:int . . This generates the following \nnon-recursive set of Horn-clause-like constraints on the predicate variables P1,. . . , P8. .a, x.P1(a).P3(a, \nx). P4(p0 + p1a + p2x) .a, x, u.P1(a).P3(a, x).P5(p0 + p1a + p2x, u). P2(a, u) .a, x.P1(a).P3(a, x). \nP6(p0 + p1a + p2x, x + 1) .a, x, u.P4(a).P6(a, x). P5(a, x) .x, y.P7(x).P8(x, y). x = y .i.. . P1(p3 \n+p4i) .i.. . P7(i) .i, u.P2(p3 + p4i, u). P8(i, u) .i.. . P3(p3 + p4i, i) Systematically simplifying \nthe constraints by computing the least solutions for the predicate variables in a bottom-up manner, we \nobtain an equisatis.able FOL formula on the variables p0,. . . , p4 shown below. .x, y, z. p4x = p4z \n.p1p4x + p2z = (p1p4 + p2)(y-1) . x = y  4.2.2 Constraint Solving The constraint generation process \nabove returns a constraint of the . form .-x .., where . is a quanti.er-free non-linear FOL formula -. \n- . over the variables p and x . (More precisely, . is linear over --p.)11 . . x with coef.cients over \nThe goal of the constraint solving -. . phase is to .nd an assignment .for p satisfying .-x ... We solve \nthe constraints by adopting Gulwani et al. s ap\u00adproach [9]. We give a brief overview of the idea. First, \nwe use Farkas lemma to remove the universal quanti.cations in the con\u00ad . . straint .-x .., and obtain \na constraint of the form .-r .f, where f - . is a quanti.er-free non-linear FOL formula on the variables \np and - . r . Then, we translate the constraint to a SAT formula by mod\u00adeling integer variables as bit-vectors \nand integer operations such as addition, multiplication, and comparison as boolean operations. Finally, \nwe use a state-of-the-art SAT solver to .nd a substitution . -. - . for p and r that satis.es f. We describe \nthe approach in a more detail. Given a univer\u00ad . sally quanti.ed constraint .-x .., we convert . to an \nequiva\u00ad 1 lent formula of the form .i, where each .i is of the form 1i \u00ac(ei,j = 0) such that each ei,j \n= 0 is a linear in\u00ad j=1,...,mi -. - . equality on x with polynomials on p as coef.cients. We translate \neach .i by applying Farkas lemma. THEOREM 4.4 (Farkas lemma). Consider the following system of inequalities \nover real-valued variables x1,. . . , xn. . . c1,0 + c1,1x1 + . . . + c1,n xn = 0 . .. . . . .. . . .. \n. cm,0 + cm,1x1 + . . . + cm,n xn = 0 11 We assume that constant types only embed quanti.er-free linear \narith\u00admetic re.nement predicates. The system is unsatis.able iff there exist non-negative reals r0, \nr1, . . . , rm such that r0 + r1c1,0 + \u00b7 \u00b7 \u00b7 + rmcm0 = -1, and  r1c1,j + \u00b7 \u00b7 \u00b7 +rmcmj = 0for each j= \n1,. . . , n.  Farkas lemma is incomplete for integers because the only if direction does not always \nhold. (Trivially, the if direction holds even for integers.) The incompleteness, however, has not affected \nthe experiments in Section 5. (See Section 4.3 for the list of limitations with our approach.) EXAMPLE \n4.5. Recall the constraints generated from the SHP template dT in Example 4.3. We translate the constraints \nto the equivalent form below. .x, y, z. . p4x -p4z = 0 . . . -p4x +p4z = 0 .. . . p1p4 + p2 +p1p4x \n-(p1p4 + p2)y +p2z = 0 . \u00ac . . . . -p1p4 -p2 -p1p4x +(p1p4 + p2)y -p2z = 0 . -1 +x -y = 0 Applying Farkas \nlemma, the constraint is further translated to the following form. .r0, r1, r2, r3, r4 = 0. r0 + (p1p4 \n+ p2)(r3 -r4)-r5 = -1. p4(r1 -r2) + p1p4(r3 -r4) + r5 = 0. -(p1p4 + p2)(r3 -r4)-r5 = 0. -p4(r1 -r2) + \np2(r3 -r4)= 0 We reduce the constraints to SAT by modeling integers as bit\u00advectors, and apply SAT solving \nto .nd a satisfying assignment. A possible solution is p0 = 0, p1 = 1, p2 = 0, p3 = 0, p4 = 1 r0 = 1, \nr1 = 0, r2 = 0, r3 = 0, r4 = 1, r5 = 1 And from the solution, we obtain the substitution . = {p0 . 0, \np1 . 1, p2 . 0, p3 . 0, p4 . 1} Note that applying the inferred parameter substitution . to dT results \nin the program equivalent to dS from Example 4.2. Finally, we update the parameter substitution P via \nPT. to translate the input program, which results in the program dP from Example 4.1, and is typable \nby the underlying type system. While the example only require a variable as the instantiation expression, \nthis is not the case in general (even when the instantiations are restricted to linear arithmetic expressions). \nSection 5 shows examples needing non-variable instantiation expressions. We use the iterative approach \nof Gulwani et al. [9] to model in\u00adtegers as bit-vectors: we start with a low number of bits, and grad\u00adually \nincrease the number of bits until a solution is found. Because of the incompleteness limitation, it is \npossible that a solution is not found even though the process is given an infeasible SHP. (cf. Sec\u00adtion \n4.3.) Section 5 shows heuristics for coping with the issue. New candidate types with new parameter substitutions \nIt is often desirable to infer new candidate types along with the new parameter substitutions. For instance, \nin Example 4.5, rather than returning to Step 1 of Figure 10 after the updated parameter substitution \nPT .is inferred, it is better to infer candidate types for the translated coun\u00adterexample SHP dT . so \nthat the counterexample is immediately eliminated from the future CEGAR iterations. Inferring parameter \nsubstitution for prior counterexamples For simplicity, we have shown how to infer a parameter substitution \nfor one counterexample SHP. In practice, it is better to record the counterexamples that have been encountered \n(or, the constraints generated from them), so that the inferred parameter substitution is able to also \nrefute the past counterexamples. This can be done by a minor modi.cation to the algorithm because constraints \nfrom multiple counterexamples simply add up as conjunctions. We take this approach in the implementation \ndescribed in Section 5.  4.3 Limitations Our type inference algorithm is incomplete as it is not able \nto decide the typability of all programs. This is expected because the underlying problem (i.e., safety \nveri.cation) is undecidable. Here, we list the source of incompleteness. (1) Like the predicate abstraction \nin .rst-order software model checking [12], we restrict the re.nement predicates to an ef.ciently decidable \n.rst-order theory, such as the quanti.er-free theory of linear arithmetic. Consequently, there are programs, \neven ones that are .rst-order, that we cannot verify. Also, predicate discovery uses various heuristics \nsuch as interpolation, and is in general incomplete even for the theory subset (but, there are approaches \nto make this part complete [14]). (2) As remarked in Section 4.1, we restrict instantiation expres\u00adsions \nto linear arithmetic expressions. While this has been suf.cient for many cases, as we show in Section \n5, there are programs that we cannot verify because of the restriction.12 (But, as we show there, simple \nheuristics can often be used to handle such cases.) (3) The parameter substitution inference is invoked \nonly when the counterexample is untypable with the current substitutions, be\u00adcause otherwise it may simply \ninfer the same substitutions. For some programs, the parameter substitution inference becomes for\u00adever \nblocked because the program generates in.nitely many coun\u00adterexamples each of which can be refuted by \njust updating the can\u00addidate types.13 (See Section 5 for an example.) (4) As remarked in Section 4.2.2, \nFarkas lemma is incomplete for integers.   5. Implementation and Experiments We have implemented a \nprototype of the type inference algorithm as an extension to the higher-order model checker MoCHi [18]. \nIt takes (direct-style and CPS) OCaml programs. We use CVC3 [2] for the SAT-based non-linear constraint \nsolving described in Sec\u00adtion 4.2.2. A web interface of the implementation and the bench\u00admark programs \nfrom the experiments are available online [28]. We ran experiments on small but representative higher-order \nprograms. Table 1 summarizes the results. The column S is the size measured in the number of words in \nthe program. O is the largest order of the functions in the program. (Base-type values are order-0, and \norder-n functions only take arguments of order less . - . than n.) The column |-p|is the total number \nof the variables p that occur in the range of the parameter substitution template PT (cf. Section 4.2). \n#E is the number of extra parameters added before each function-type parameter. (#E > 1 is used in the \nheuristics described below.) #I is the number of CEGAR iterations. The column T is the running time in \nseconds, and P/T is the fraction of the running time spent on the parameter substitution inference. NV \nmarks the programs that required non-variable instantiation expressions. The experiments were conducted \non a machine with Intel Xeon E5620 2.4GHz CPU and 4GB RAM. Note that the programs are higher-order (i.e., \nO > 1). The pro\u00adgrams are safe, but none of them can be veri.ed by the previous 12 The limitation is \nalso linked with (1) above, because allowing more complex instantiations has no bene.t when the underlying \ntheorem prover cannot decide formulas embedding them. 13 This is an instance of a more general issue \nwith the parameter substitution inference not inferring suf.ciently general substitutions. program S \nO |-. p| #E #I T P/T NV d2 40 2 3 1 2 0.43s 40% d3 56 3 10 1 3 1.76s 68% fhnhn 26 2 2 1 1 0.15s 12% repeat-add \n51 2 5 1 3 1.05s 7% app-leq 29 2 2 1 1 0.26s 41% . app-lin-ord2 37 2 2 1 1 0.22s 38% . app-lin-ord3 45 \n3 6 1 1 0.96s 84% . app-succ 50 2 5 1 2 0.36s 37% app-succ0 50 2 5    % a-test-upd 80 2 9 2 7 2.06s \n32% a-checksum 76 2 6 2 8 3.38s 29% a-max 78 2 8 1 4 7.32s 26% l-forall-leq 69 2 8 1 2 2.68s 51% l-len-append \n126 2 22 1 2 0.73s 35% . l-isort 170 2 39    % Table 1. Experiment results. re.nement type systems \nproposed for automated higher-order pro\u00adgram veri.cation [13, 18, 23, 26, 27]. We describe each program. \n d2 and d3 are from Example 3.4.  fhnhn compares the return value of two function arguments:  let f \nx y = assert (x () = y ()) in let h x () = x in let main n = f (h n) (h n) repeat-add makes the closure \nadd n for some n = 0, applies it to 0 for k-times for some k > 0, and asserts that the result is not \nless than n: let add x1 x2 = x1 + x2 in let rec repeat f k x = if k <= 0 then x else f (repeat f (k -1) \nx) in let main n k = if n >= 0 &#38;&#38; k > 0 then assert (repeat (add n) k 0 >= n) app-leq (resp. \napp-lin-ord2) is the program below with e =(a<=b) (resp. e =(4*a+2*b)). let app f x = f x in let check \nx y = assert (x = y) in let main a b = app (check e) e  app-lin-ord3 is app-lin-ord2 lifted one order \nhigher.  app-succ calls check i i for some non-deterministically\u00adchosen i = n:  let succ f x = f (x \n+ 1) in let rec app f x = if * then app (succ f) (x -1) else f x in let check x y = assert (x = y) in \nlet main n = app (check n) n  app-succ0 is app-succ with n in the body of main .xed to 0.  In a-xxx, \nwe model and check array manipulating programs. We model an array as the pair consisting of its size \nand the function that maps indices to the array elements:  let make array n = (n, fun i -> assert let \nupd (n, ar) i x = assert (0 <= i &#38;&#38; i (n, fun j -> if j = (0 <= i &#38;&#38; i < n); 0) < n); \ni then x else ar j)  The array benchmarks extend the ones from the previous work [18] that demonstrate \nthe application of higher-order program veri.cation to the veri.cation of data structure properties. \n a-test-upd tests array updates. It creates an array of size n and updates the i-th element to x for \nsome i . {0,. . . , n -1}. The program then reads the element and checks that the result is equal to \nx as expected: let test (n, ar) i x = assert (ar i = x) in let main n i x = if 0 <= i &#38;&#38; i < \nn then test (upd (make array n) i x) i x Note that the program also checks for array bounds violation. \n a-checksum creates an array of size 2, updates the .rst and the second elements to a and b respectively, \nand asserts that the sum of the two array elements equals a + b: let checksum (n, ar) x = assert ((ar \n0) + (ar 1) = x) in let main a b = checksum (upd (upd (make array 2) 0 a) 1 b) (a + b)  a-max creates \nan array of size n whose elements are from the set {0,. . . , x}where x > 0, computes the maximum element \nm of the array, and asserts that m = x. The programs l-xxx model and check list operations. We model \na list by a pair of its length and a function from a non\u00adnegative integer i to the i-th element. We model \nthe core list operations as follows: let nil = (0, fun i -> assert false) let cons a (len, l) = (len \n+ 1, fun i -> if i=0 then a else l (i-1)) let hd (len, l) = l 0 let tl (len, l) = (len -1, fun i -> l \n(i + 1)) let is_nil (len, l) = len=0  l-forall-leq creates a list of the length n whose i-th ele\u00adment \nis n -i, and asserts that x = n holds for all element x of the list. l-len-append appends two lists \nof the length len1 and len2, computes the length of the resulting list, and asserts that it is not greater \nthan len1 + len2. l-isort creates a list, sorts the list via an insertion sort, and then checks that \nthe result is actually sorted. The implementation was able to successfully verify the pro\u00adgrams by automatically \ninferring appropriate extra parameter sub\u00adstitutions, except for app-succ0 and l-isort. Before we discuss \nthe reason for failure on these two, we describe the heuristic that was needed for verifying a-test-upd \nand a-checksum. Recall that we limit instantiation expressions to linear arith\u00admetic expressions. With \nthis restriction, it can be shown that a-test-upd and a-checksum (and also l-isort) are actually untypable \nwhen we are allowed to add only one extra parame\u00adter before a function-type parameter.14 However, a-test-upd \nand a-checksum can be typed if we are allowed to add two extra pa\u00adrameters before a function-type parameter, \neven with the linear\u00adinstantiation-expression restriction. (Note that #E is 2 for these programs in Table \n1.) For instance, in a-checksum, to show the safety of the call to checksum, we need to infer the property \nthat the second argument 14 Note that the relative completeness theorem (Theorem 3.7) assumes that arbitrary \nside-effect-free integer-type expressions can be used for instantia\u00adtion. equals the sum of the .rst \nand the second elements of the function\u00adencoded array passed as the .rst argument. Because the two ele\u00adments \nof the array are independent (i.e., the arguments a and b of main), it is not possible to express such \na fact via a re.nement type with just one (linearly instantiatable) extra parameter. Nonetheless, the \nproperty can be expressed even under the linear-instantiation\u00adexpression restriction by using two extra \nparameters. For example, the following type is suf.cient: .a:int..b:int. (int \u00d7 (x:int . {u |.})) . {u \n|u = a + b} . . where . = (x = 0 . u = a). (x = 1 . u = b), and \u00d7 is the pair type constructor. We use \na simple heuristic to progressively increase the number of extra parameters that are added before each \nfunction-type parameter: we increment the number by one when the parameter substitution inference fails \nto .nd a solution to the constraints, with some pre-de.ned threshold on the number of bits used in the \nbit-vector modeling (cf. Section 4.2.2). With the heuristic, the implementation was able to verify a-test-upd \nand a-checksum. Note that the increased extra parameter heuristic is sound because the soundness theorem \n(Theorem 3.6) holds for any pattern of extra parameter additions. The program l-isort remains untypable \neven with the heuris\u00adtic. In fact, it can be shown that no .nite number of extra parameter additions \ncan type the program when the instantiation expressions are restricted to be linear. The implementation \nfails to verify app-succ0 for a different reason. To verify the program, we need to infer the following \ntype for app with the extra parameter i. .i:int.f :({u |u = i} . .). x:{u |u = i} . . However, each \ncounterexample SHP generated from app-succ0 is actually typable by assigning (the copies of) app the \ntypes of the following form whose re.nement predicates do not mention the extra parameter: .i:int.f :({u \n|u = c} . .). x:{u |u = c} . . where c is some integer constant. Therefore, the type inference system \ngenerates in.nitely many counterexample SHPs that are refuted by the types of the above form each time, \nand the parameter substitution inference is never invoked to infer the necessary type that uses the extra \nparameter. We leave the issue for future work. 6. Related Work 6.1 Re.nement Type Systems The relatively \ncomplete re.nement type system of this paper can be seen as DML [30] but with quanti.ers (i.e., introduction \nof .types) restricted to one before each function-type parameter. Hence, our result shows that DML is \nactually relatively complete (even when the quanti.cation pattern is restricted). In relation to DML, \nthis paper s contribution is in actually proving relative completeness, and in proposing an automated \ntype inference method. The previous re.nement type systems proposed for automated higher-order program \nveri.cation [13, 18, 23, 26, 27] lack relative completeness, except for the case when the base-type data \ndomain is .nite [16, 17]. We have shown how the type inference systems underlying the veri.ers may be \nextended to attain relative com\u00adpleteness. 6.2 Hoare Logic for Higher-order Languages There is a long \nline of research on relatively complete Hoare logic like proof systems for higher-order functional (or \nprocedural) lan\u00adguages. One way to achieve relative completeness is to have a higher-order logic as the \ninterpretation logic (i.e., the logic for the data part) so that the formulas can directly refer to higher-order \nfunctions as data (see, e.g., [5, 11, 21, 22]). However, such an ap\u00adproach is dif.cult to automate as \nthe client veri.er must rely on a higher-order logic theorem prover. The dilemma is similar to that arising \nfrom explicitly encoding functions as base-type data in the program logic. The approach of using base-type \nencoding of functions to achieve relative completeness was .rst proposed by German et al. [6, 7]. (A \nsimilar approach is taken in [8].) Crucial to their approach is the idea of avoiding the explicit encoding \nin the pro\u00adgram logic via quanti.cation, allowing the client veri.er to choose appropriate quanti.er \ninstantiations. To our knowledge, no actual veri.er was built based on their program logic. The encoding \napproach is also used in a recent work on rela\u00adtively complete dependent (re.nement) type system [19] \nwhere a DML-like type system is extended with linear intersection types, and is shown sound and relatively \ncomplete (for terminating pro\u00adgrams). Their type system is designed for a type-based complexity analysis, \nand the paper does not discuss automated veri.cation.  6.3 Quanti.ed First-order Logic Constraint Solving \nOur type inference method utilizes an algorithm for deciding . . the validity a FOL formula of the form \n.-x ..-y .. where . is a -. - . quanti.er-free arithmetic formula over the variables x and y, and - . \nif valid, .nding appropriate instantiations for x so that the formula . -- .. can be reduced to .-y ..[e \n/x ]. The problem is studied in the context of constraint-based (or, template-based)program veri.cation \n[4, 9, 24] where the existen\u00adtially quanti.ed variables are used to represent the unknowns in the invariant \ntemplate. The technique has found wide applicability, in\u00adcluding hybrid system veri.cation [20] and program \nsynthesis [25]. Our work adds higher-order program veri.cation to the list.  7. Conclusion We have presented \nan automated approach to a relatively com\u00adplete veri.cation of higher-order functional programs. Our \nwork extends the recent research on re.nement type inference for auto\u00admated program veri.cation. We have \nextended the underlying re\u00ad.nement type system by adopting the classical result on relatively complete \nHoare logic like proof systems for higher-order procedu\u00adral languages, which shows that certain extra \nbase-type parameter additions are suf.cient for relative completeness. Then, we have ex\u00adtended the type \ninference system by utilizing the techniques from the recent work on quanti.ed FOL constraint solving \nover template expressions to infer appropriate instantiations for the extra base\u00adtype parameters. Acknowledgments \nWe thank the anonymous reviewers for useful comments. This work is partially supported by Kakenhi 23220001 \nand 23700026.  References [1] L. Augustsson. Cayenne -a language with dependent types. In ICFP, pages \n239 250, 1998. [2] C. Barrett and C. Tinelli. CVC3. In CAV, pages 298 302, 2007. [3] E. M. Clarke, O. \nGrumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided abstraction re.nement. In CAV, pages 154 \n169, 2000. [4] M. Col\u00b4on, S. Sankaranarayanan, and H. Sipma. Linear invariant generation using non-linear \nconstraint solving. In CAV, pages 420 432, 2003. [5] W. Damm and B. Josko. A sound and relatively* complete \nHoare\u00adlogic for a language with higher type procedures. Acta Inf., 20:59 101, 1983. [6] S. M. German, \nE. M. Clarke, and J. Y. Halpern. Reasoning about procedures as parameters. In Logic of Programs, pages \n206 220, 1983. [7] S. M. German, E. M. Clarke, and J. Y. Halpern. Reasoning about procedures as parameters \nin the language L4. Inf. Comput., 83(3):265 359, 1989. [8] A. Goerdt. A Hoare calculus for functions \nde.ned by recursion on higher types. In Logic of Programs, pages 106 117, 1985. [9] S. Gulwani, S. Srivastava, \nand R. Venkatesan. Program analysis as constraint solving. In PLDI, pages 281 292, 2008. [10] C. A. \nR. Hoare. An axiomatic basis for computer programming. Commun. ACM, 12(10):576 580, 1969. [11] K. Honda, \nM. Berger, and N. Yoshida. Descriptive and relative com\u00adpleteness of logics for higher-order functions. \nIn ICALP (2), pages 360 371, 2006. [12] R. Jhala and R. Majumdar. Software model checking. ACM Comput. \nSurv., 41(4), 2009. [13] R. Jhala, R. Majumdar, and A. Rybalchenko. HMC: Verifying func\u00adtional programs \nusing abstract interpreters. In CAV, pages 470 485, 2011. [14] R. Jhala and K. L. McMillan. A practical \nand complete approach to predicate re.nement. In TACAS, pages 459 473, 2006. [15] T. Johnsson. Lambda \nlifting: Transforming programs to recursive equations. In FPCA, pages 190 203, 1985. [16] N. Kobayashi. \nTypes and higher-order recursion schemes for veri.ca\u00adtion of higher-order programs. In POPL, pages 416 \n428, 2009. [17] N. Kobayashi and C.-H. L. Ong. A type system equivalent to the modal mu-calculus model \nchecking of higher-order recursion schemes. In LICS, pages 179 188, 2009. [18] N. Kobayashi, R. Sato, \nand H. Unno. Predicate abstraction and CE-GAR for higher-order model checking. In PLDI, pages 222 233, \n2011. [19] U. D. Lago and M. Gaboardi. Linear dependent types and relative completeness. In LICS, pages \n133 142, 2011. [20] J. Liu, N. Zhan, and H. Zhao. Computing semi-algebraic invariants for polynomial \ndynamical systems. In EMSOFT, pages 97 106, 2011. [21] E.-R. Olderog. Correctness of programs with Pascal-like \nprocedures without global variables. Theor. Comput. Sci., 30:49 90, 1984. [22] B. Reus and T. Streicher. \nRelative completeness for logics of func\u00adtional programs. In CSL, pages 470 480, 2011. [23] P. M. Rondon, \nM. Kawaguchi, and R. Jhala. Liquid types. In PLDI, pages 159 169, 2008. [24] S. Sankaranarayanan, H. \nB. Sipma, and Z. Manna. Constraint-based linear-relations analysis. In SAS, pages 53 68, 2004. [25] S. \nSrivastava, S. Gulwani, and J. S. Foster. From program veri.cation to program synthesis. In POPL, pages \n313 326, 2010. [26] T. Terauchi. Dependent types from counterexamples. In POPL, pages 119 130, 2010. \n[27] H. Unno and N. Kobayashi. Dependent type inference with inter\u00adpolants. In PPDP, pages 277 288, 2009. \n[28] H. Unno, T. Terauchi, and N. Kobayashi. Automating relatively com\u00adplete veri.cation of higher-order \nfunctional programs, 2012. http: //www.kb.is.s.u-tokyo.ac.jp/~ uhiro/relcomp. [29] A. K. Wright and M. \nFelleisen. A syntactic approach to type sound\u00adness. Inf. Comput., 115(1):38 94, 1994. [30] H. Xi and \nF. Pfenning. Dependent types in practical programming. In POPL, pages 214 227, 1999.  \n\t\t\t", "proc_id": "2429069", "abstract": "<p>We present an automated approach to relatively completely verifying safety (i.e., reachability) property of higher-order functional programs. Our contribution is two-fold. First, we extend the refinement type system framework employed in the recent work on (incomplete) automated higher-order verification by drawing on the classical work on relatively complete \"Hoare logic like\" program logic for higher-order procedural languages. Then, by adopting the recently proposed techniques for solving constraints over quantified first-order logic formulas, we develop an automated type inference method for the type system, thereby realizing an automated relatively complete verification of higher-order programs.</p>", "authors": [{"name": "Hiroshi Unno", "author_profile_id": "81553259056", "affiliation": "University of Tsukuba, Tsukuba, Japan", "person_id": "P3977920", "email_address": "uhiro@cs.tsukuba.ac.jp", "orcid_id": ""}, {"name": "Tachio Terauchi", "author_profile_id": "81100563652", "affiliation": "Nagoya University, Nagoya, Japan", "person_id": "P3977921", "email_address": "terauchi@is.nagoya-u.ac.jp", "orcid_id": ""}, {"name": "Naoki Kobayashi", "author_profile_id": "81553240856", "affiliation": "University of Tokyo, Tokyo, Japan", "person_id": "P3977922", "email_address": "koba@is.s.u-tokyo.ac.jp", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429081", "year": "2013", "article_id": "2429081", "conference": "POPL", "title": "Automating relatively complete verification of higher-order functional programs", "url": "http://dl.acm.org/citation.cfm?id=2429081"}