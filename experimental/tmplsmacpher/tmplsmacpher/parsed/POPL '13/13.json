{"article_publication_date": "01-23-2013", "fulltext": "\n The ..\u00af-calculus A dual calculus for unconstrained strategies Alexis Goyet Univ Paris Diderot, Sorbonne \nParis Cit \u00b4e, PPS, UMR 7126, CNRS, F-75205 Paris, France alexis.goyet@pps.univ-paris-diderot.fr Abstract \nWe present a calculus which combines a simple, CCS-like repre\u00ad \u00af sentation of .nite behaviors, with two \ndual binders . and .. In\u00ad.nite behaviors are obtained through a syntactical .xed-point op\u00aderator, which \nis used to give a translation of .-terms. The duality of the calculus makes the roles of a function and \nits environment symmetrical. As usual, the environment is allowed to call a func\u00adtion at any given point, \neach time with a different argument. Dually, the function is allowed to answer any given call, each time \nwith a different behavior. This grants terms in our language the power of functional references. The \ninspiration for this language comes from game semantics. Indeed, its normal forms give a simple concrete \nsyntax for .nite strategies, which are inherently non-innocent. This very direct cor\u00adrespondence allows \nus to describe, in syntactical terms, a num\u00adber of features from game semantics. The .xed-point expansion \nof translated .-terms corresponds to the generation of in.nite plays from the .nite views of an innocent \nstrategy. The syntactical dual\u00adity between terms and co-terms corresponds to the duality between Player \nand Opponent. This duality also gives rise to a B \u00a8 ohm-out lemma. The paper is divided into two parts. \nThe .rst one is purely syntactical, and requires no background in game semantics. The second describes \nthe fully abstract game model. Categories and Subject Descriptors I.1.3 [Languages and Sys\u00adtems] Keywords \nGame semantics, Lambda-calculus 1. Introduction Game semantics has proven to be a very effective tool \nas both a pre\u00adcise and insightful model of languages. It was used to give models for many languages [1, \n2, 14, 15, 19], and has otherwise been the inspiration for many analyses [11, 17, 18]. This sustained \ninterest has also made game semantics a subject of investigation, this time not as a tool, but for itself. \nIn particular, recently, a growing body of work [6, 7, 16] is proposing syntaxes derived from game se\u00admantics. \nBut why reverse the roles, and invent a new language for Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. POPL 13, January 23 25, 2013, Rome, Italy. Copyright \nc &#38;#169; 2013 ACM 978-1-4503-1832-7/13/01. . . $15.00 a semantics? One answer is that an interesting \nmodel has its own coherent structure, which may not be present in the initial object. In the case of \ngame semantics, the model uses a notion of interac\u00adtion history which both the program and its environment \naccess in a symmetrical way. This gives a precision level which was in fact too high for the .rst language \nmodeled: the purely functional PCF [2, 14, 19]. This led to the de.nition of the innocence and visibil\u00adity \nconditions (following the presentation in [14]), which force the strategy to depend only on a subset \nof the interaction history. This restriction introduces an asymmetry between the information avail\u00adable \nto the Player and the Opponent, corresponding to the asym\u00admetry between a function and its argument. \nThus the duality of the unconstrained model is not visible in the language s syntax. Later, it was shown \n[1] that non-innocent, non-visible strategies give a fully abstract model for a functional language extended \nwith higher order references. Additionally, removing the bracketing condition, which is also present \nin [14], yields a language with non-local con\u00adtrol [15]. This correspondence between different restrictions \nin the model and well known language features is remarkable. But the languages presented in the cited \nworks, because they contain the .-calculus as a sub-language, still do not exhibit the duality that we \nseek. In the case of [1] for example, the set of all strategies is built by factorization: a single memory \ncell strategy is added be\u00adside innocent ones. In comparison, our approach does not give a special role \nto innocent strategies; instead, we use .nite strategies, which are inherently non-innocent, as our building \nblocks. The set of .nite strategies is self-dual, and it is compact in the set of all strategies. Syntactically, \nthis leads to a very direct relationship between the model and the terms of our syntax. Indeed, .-long \nnormal forms can be seen as a concrete syntax for .nite strategies. The syntax dualizes that of .-calculus, \nby adding a .\u00afbinder for co-variables. \u00af Together, . and . bindings correspond to the game notion of \njusti.cation, which is itself symmetrical between the Player and the Opponent. In the .-calculus, an \noccurrence of a variable x represents a call to an argument which was received at a previous point in \nthe history; this point being represented by the binder .x. In the ..\u00af-calculus, in addition, an occurrence \nof a co-variable u represents an incoming call to an argument which was passed at a previous point, represented \nby \u00af .u. The calculus is endowed with a con.uent set of reduction rules. The base language, which does \nnot include .xed-point, is strongly normalizing. The model is given in a framework of game seman\u00adtics, \nwhich we take as simple as possible. For this purpose, we choose types built from . and the operators \n\u00d7 and . only; there\u00adfore we do not make the usual distinction between questions and answers moves (which \nare used when modeling base types other than .), and thus no bracketing condition is de.ned. We also \ndo not impose determinism, and include odd-length plays in strategies. The language is fully abstract \nfor this semantics. The expressive power of the language is illustrated by a translation of the .-calculus \n(section 5), and a coding for a memory-cell (section 6.3). An implementation of the language is available \n[10].  We start with a very simple example, which is the translation, in our language, of the identity: \ntr(.y.y) \u00af = .u.u . a..y.y u a . * (\u00afJ) + s .u.u .y.y \u00af Details about this translation, and the syntactical \n.xed-point op\u00aderator . a, are given in section 5. The + operator is a non\u00addeterministic sum; but for \nnow we will focus on the expression on its left-hand side. We can see that the connectors of the initial \n.\u00adterm are still present in this expression. Indeed, here the translation can be seen as a decoration \nof the initial term, with the following meaning: Name u this function. If the environment calls u, it \nwill pass it an argument; name it y, then call y. . All the connectors present in that expression are \nunary, meaning it could be written \u00af .u.(u (.y.(y (\u00afJ)))). The notation , which is automatic after an \noccurrence of a variable y, or of a co-variable u, represents sequen\u00adtiality, in the spirit of the CCS \n(or p-calculus) notation \u00b7 . By itself, the behavior of the expression \u00afJ only approximates that .u.u \n.y.y \u00afof the .-term .y.y. This is because the last constructor, J\u00af, signi.es that the interaction stops. \nA better approximation can be obtained: tr(.y.y) . * (\u00afJ) + sv .u.u .y.y u .y.y \u00af Here the expression \n\u00afJ will react to the environ\u00ad .u.u .y.y u .y.y \u00afment call u not once, but twice in a row, and in the \nsame way (by calling the argument y it just received). This means that it will have the same behavior \nas (the translation of) the .-term .y.y when in\u00adteracting with (the translation of) the environment .x.(x \n(x c)) []; each occurrence of x in the environment corresponding to an occur\u00adrence of u. On the other \nhand, the expression \u00afJ would .u.u .y.y \u00afhave stopped reacting after the .rst call of x. The translation \nof .y.y can be co-inductively expanded to produce interactions of any length, answering the query u as \nmany times as necessary, and al\u00adways with the same behavior. This corresponds, in game semantics, to \nthe condition of innocence for strategies, which essentially stip\u00adulates that any queries must be answered \nas if it was the .rst of its kind. This corresponds to the inability of the program to remember the previous \ncalls, and thus to the absence of references. Terms of the ..\u00af-calculus, on the other hand, do have the \npower of references, as we will see on our next example: new r; r := false; (M N ) where : M = .x..c.(if \nx then (if x then diverge else c) else diverge) N = r := (not !r); !r Note here that the use of references \nin N is necessary for the in\u00adteraction to reach the sub-term c of M. Indeed, a context with an innocent \nbehavior would not be able to separate M from the pro\u00adgram diverge . When M calls x for the .rst time, \nN reacts as the boolean true; M then calls x a second time, and N reacts as the boolean false; .nally \nM calls c. If N had reacted the same way twice (which it would be forced to do if it did not contain \nrefer\u00adences), M would have diverged. We will present in our language an interaction similar to that of \nM and N. This requires a few adap\u00adtations. First, instead of booleans, which are absent in our setting, \nwe will use the type (. \u00d7 .) . . (with the behavior of .x..y.x representing the value true, and .x..y.y \nrepresenting false). Thus, instead of M , we will consider the .-term M1: M1 = .x..c.(x (x O c) O) Additionally, \nthe behaviors of M, M1 and N are in.nite, whereas, as we saw in our .rst example, terms in our syntax \nmore naturally represent .nite behaviors. For example, N reacts as true, then false, then true, etc; \nbut the term we will give will only react to the .rst two queries. We now consider the interpretation \nof M1 as a strategy. The picture below shows a play of this strategy , in the usual graphical representation; \nnote that the labeling (x, x, and c) is not part of the play. (((. \u00d7 .) . .) \u00d7 .) . . .x..c. x x The \nmoves of the play are represented as circles, in chronological order from top to bottom. The .rst move \nis the initial query made by the environment (the Opponent); M1 (the Player) reacts by playing a move \nlabeled by x; the Opponent then plays one of two possible moves in the product . \u00d7 .; M1 plays x again; \nthe Opponent this time chooses the second possibility; M1 .nally plays c. The two possible moves in . \n\u00d7 . correspond to calls to either the .rst or the second argument passed to x by M1 (simulating a value \nof either true or false for x). In the same way, the position of the moves labeled by x or c correspond \nto M1 calling either its .rst argument (x) or its second one (c). In both cases, the move is placed under \nthe occurrence of . corresponding to the return type of x or c. This illustrates how the strategy contains \nall the information of the term. In general, the positions of the moves are not enough, and the justi.cation \npointers are also required; here they are represented as arcs between moves. We now give a more detailed \nlabeling of the play, using syntactic elements from our language: (((. \u00d7 .) . .) \u00d7 .) . . u0 .x..c. x \n.v.\u00af \u00af.w. v v \u00af\u00af x .v..wv. v w c The label for each move consists of a name, followed by zero or more \nbinders. In this representation, all moves are labeled by a name, and all justi.cation pointers correspond \nto the link between a name and its binder (the same could have been done with the .\u00adcalculus syntax, \nbut only for Player moves). When there is more \u00af than one binder (for example, in the label x .v.\u00af .w. \n), they dis\u00adtinguish between available moves which could be justi.ed by the current one (here either \nv or w). This gives a syntactical represen\u00adtation of the position in the arena (with v and w corresponding \nto the simulated value true and false for x). Again, the same could be said when labeling with the .-calculus \nsyntax, but only for Player moves. The syntax is dual; on one hand are variables x, c, which label Player \nmoves, and binders .x, .y; on the other hand, co\u00advariables u0, v, w, which label Opponent moves, and \ntheir binders \u00af\u00af .u0, .v, \u00af .w. This labeling can be obtained in a systematic way, given a choice of \nnames for every moves. Notice that here we chose similar names v, w and v v , w v for moves at the same \nposition in the arena; but they are indeed different moves, distinguished by their  \u00af\u00af justi.er. For \nexample, the move following x .vv ..wv . could have \u00af been justi.ed by x .v.\u00af .w., in which case its \nlabel would be w, re\u00adsulting in a different play. This new syntax can be used to directly represent plays; \nfor example, the above example is denoted by: v \u00af \u00af\u00af s1 = .u0.u0 .x..c.x \u00af.w.v x .vv ..wv .w J .v.\u00afc \n\u00af Note that the alternation between Player and Opponent moves is marked by a , and that the sequence \nends with J\u00af, which denotes the empty Opponent strategy (it has a dual, J). This is a valid co-term in \nthe syntax of the ..\u00af-calculus; its interpretation is the smallest strategy containing the play in question \n(and its pre.xes). In a sense, a strategy such as this one is passive: it waits for the Opponent to make \nthe .rst move. In this work we are also interested in strategies in which the Player acts .rst; these \nPlayer\u00adstarting strategies are used to interpret terms in the ..\u00af-calculus. To illustrate, we modify \ns1 by removing the initial move; this yields the term f1: v \u00af\u00af f1 = .x..c.x \u00af.w.v x .vv ..wv .w J .v.\u00afc \n\u00af We now give an (Opponent-starting) strategy on the arena corre\u00adsponding to the type (. \u00d7 .) . .: \u00af \ns2 = .u.u .y..z.y u .yv..zv .z v J\u00af This co-term approximates, in our setting, the behavior of the program \nN: it reacts to the initial query u by calling y (thus behaving as .y..z.y, which represents true), then \nreacts to the second occurrence of u by calling z v (behaving as .yv..zv .z v , which represents false). \nAs we mentioned before, this is only an approximation, in the sense that a third query u would be met \nwith no reaction (this could be made more obvious by replacing J\u00afin s2 by u J; the obtained co-term being \nobservationally equivalent to s2). Note that s1 was also an approximation of the strategy of M1; this \nis because s1 and s3 represent .nite strategies, whereas any innocent non-empty strategy contains in.nite \nplays. For example, the strategy of M1 will keep reacting to its initial move as many time as necessary; \nwhereas s1 will only react to u0 once. We can now represent the interaction of M and N , as the interaction \nof f1 and s2: v \u00af\u00af f1 = .x..c.x \u00af.w.v x .vv ..wv .w J .v.\u00afc \u00af\u00af s2 = .u. u .y..z .y u .yv..zv .z v J\u00af \n. * . * f1 < s2 .c.c J\u00af.x..c.J < s2 .c.J The interaction operator in ..\u00af-calculus is denoted by <. It \ncon\u00adnects a term and a co-term; the result is a term. As indicated above, f1 < s2 reduces to .c.c J\u00af. \nBefore we give more details about the reduction, notice that f1 and s2 are essentially dual; and that \nthe connectors of f1 which are not mirrored in s2 are precisely those appearing in the result of the \ninteraction. This is a fundamental property of the language: a normal branch and its dual will elim\u00adinate \neach other (without blocking) when interacting. Moreover, because this dual always exists, for any term \nrepresenting a play (as does f1) we immediately have a context which will reach the end of this play \n(here s2). This can be seen as a form of B \u00a8 ohm\u00adout lemma for the language. In this example, we obtain \na separa\u00adtor between f1 and a term of the same type, .x..c.J, which sim\u00adply diverges (in that it plays \nno moves). The reduction rules of the language are given in section 4; additionally, the full reduction \nof f1 < s2 is given in the appendix A. We simply illustrate below two of the main points of the rules: \n(x,u) (.x.f) < (.u.s\u00af) . * L .(f < s) (x,u) (x,u) L .(xs< u f) . * L .(f< s) (x,u) The operator L , which \nis created when the dual binders .x and \u00af .u are eliminated, is called connection. It binds both x and \nu in f < s. This .rst reduction holds for any term f and co-term s (provided that x is not free in s \nand u is not free in f). The sec\u00adond shows how x and u are also eliminated together, once they are connected \nby the operator L. This reduction holds for any term f and co-term s, provided that s can be put in a \ncertain form, for example v fv . The paper is divided into two parts. The .rst part, which does not require \nany background in game semantics, describes the lan\u00adguage from a syntactical point of view: its syntax, \nin section 2, the typing system, in section 3, its reduction rules, in section 4, and its extension by \na .xed-point operator, in section 5. A comparison with other languages, in section 6, and a B \u00a8ohm-out \nlemma, in section 7 are also included. In the second part we describes the game model. We de.ne basic \noperations on games and plays in section 8; we give the semantics of the language in section 9, and list \nits main properties, including full abstraction, in section 10. We expand on the notion of view, and \nits link to history access control, in section 11. Section 12 discusses future works, and in section \n13 we conclude. 2. Syntax We assume two (disjoint) in.nite sets of names: variables, denoted by x, y, \nz,\u00b7 \u00b7 \u00b7 and co-variables, denoted by u, v, w,\u00b7 \u00b7 \u00b7 . L f, . := J | .x.f | x s | f + . | f < t | LS.f \n\u00af s, t := J\u00af| .u.s | u f | s + t | s < t where L is a set of pairs of the form (x, u), called links, \nand S is a stack of co-variables. The .rst line de.nes a syntax of terms, Lthe second a syntax of co-terms; \neach constructor except L S and . < has a dual. We use the notations .-x .f for .x1. \u00b7 \u00b7 \u00b7 .xn.f (and \n-. . dually for .\u00afu ) and -v for the stack v1 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 vn. The construction (xi,ui)i - . L v .f, called \nconnection, binds all the xi, ui and vj in f. The constructors .x and \u00af .u are also binders. We note \nFN(f) the free names of f (and dually for FN(s)). We improperly write x . L when (x, u) . L for some \nu; and dually for u . L. Finally, unary operators take precedence over binary operators. 3. Typing Types \nare of the form T := 1 | . | T \u00d7 T | \u00acT (in the examples of the introduction, we wrote A . . for \u00acA). \nSequents are of two forms: G | f : A f | ., and G | f s : A | .. In both cases, the environment G is \na set of the form (xi : \u00acAi)i (and dually for .). The typing rules are given in .g 1. As mentionned in \nsection 10, the translation from .-calculus preserves types, modulo the equivalence (A \u00d7 B) . C A . \nB . C. In particular the co-term \u00afJ, seen in the introduction, shares the type .u.u .y.y \u00afof the identity \n.y.y, which it approximates: y : . | J\u00af: 1 f |u : . . . y : . | y J\u00af: 1 f |u : . . . | .y.y J\u00af: .f |u \n: . . . | f u .y.y \u00afJ : 1 |u : . . . | f \u00afJ: . . . | .u.u .y.y \u00af 4. Reduction rules We de.ne below an \nequivalence relation = on terms and co-terms, and in Figure 2 we de.ne a base reduction relation. In \nthis .gure,  G | J : A f | . G | f J\u00af: 1 | . G, x : A | f : B f | . G | f s : B | u : A, . G | .x.f \n: A \u00d7 B f | . G | f \u00af .u.s : A \u00d7 B | . G, x : \u00ac(A \u00d7 B) | f s : A | . G | f : A f | u : \u00acA, . G, x : \u00ac(A \n\u00d7 B) | x s : B f | . G | f u f : 1 | u : \u00acA, . G | f : A f | . G | . : A f | . G | f s : A | . G | f \nt : A | . G | f + . : A f | . G | f s + t : A | . G | f : A \u00d7 B f | . G | f s : A | . G | f s : A | . \nG | f t : B | . G | f < s : B f | . G | f s < t : A \u00d7 B | . -.. . - G, x : L | f : S \u00d7 A f | -v : S, \nu : L, . v G | (xiL,ui)i .-.f : A f | . Figure 1. Typing rules. sg, tg denote guarded co-terms, i.e. \nco-terms of the form J\u00afor u f. We then de.ne the relation . as the composition = . .b . =. Moreover, \nby convention, . * will denote the union of = and of the transitive closure of .. The relation = is the \nsmallest context\u00adclosed equivalence relation such that: It includes =a (a-renaming).  It makes the \noperator + commutative and associative, with neutral element J or J\u00af(depending on the polarity).1  It \nmakes all operators distribute over +; for example:  .x.(f + .) = .x.f + .x.. It contains the following \nthree rules: J < s = J LLS.J = J L1L2L1.L2 L S1 S2 . L S2.f = L \u00b7S1.f Note how, in the last rule, the \nstacks S1 and S2 are concatenated with S2, the closest to f, .rst. A term (or co-term) in normal form \nexactly when it does not contain the operators < or L. If additionally it does not contain the operator \n+, it is said to be a normal branch. For example, all the terms and co-terms named in the introduction \nare in normal form; and all are normal branches, except s3, which contains a connector +. The main properties \nof the language are listed in section 10, after its extension with .xed-points in section 5. But already \nwe can note a property which is speci.c to the language without .xed-point: Proposition 1. The ..\u00af-calculus, \nas de.ned in section 2, equipped with the reduction ., is strongly normalizing. Proof. Each rule in Figure \n2 has the effect of reducing the size of a term or co-term to which a connector < or L is applied; thus \npushing those connectors toward the leaves of the syntactic tree. Additionally, consider a non-normal \nterm (or co-term) which contains only one connector < or L, and no connector +. Then there 1 This is \ncorrect in the setting of this work, where a well-typed term of the form s + \u00afE is such that s is of \ntype 1. However, in an untyped setting one should restrict s + \u00afE = s to be true only if s is guarded. \nThis restriction is not necessary for E. . f < .\u00af-u .sg .x.f < sg x s < tg \u00af .u.s < t sg < \u00af .v.t uf<v \n. L Lu\u00b7S ..x.f L L..x.f L\u00af- . LS v \u00b7S .x .v .u f .b L .f L. LS .x .\u00af-v .w f .b J L\u00af- . LS .x .v .J\u00af.b \nJ L-. .. L u \u00af-\u00af-\u00af- L. .x .v .w f .b x .v . .u .w L.f L-. .. u \u00af-\u00af-\u00af- L. .x .v .w f .b x .v . .u .J\u00afL-. \n.. u \u00af-\u00af-\u00af- L. .x .v .J\u00af.b x .v . .u .J\u00af . . b L-u .(f < sg) . b .x.(f < sg) . b x (s < tg)  \u00af . b \n.u.(s < t ) \u00af . b .v.(sg < t ) . b u (f<v .) + v (. < u f)  (x,u),L .b L S.f L .b .x. L.f L- . ui \n./FN(f) x /. FN(sg) u /. FN(t) v /. FN(sg) x /. L, u /. L x /. L (x, u) . L (x, u) . L (x, u) . L x /. \nL, w /. L x /. L, w . L x /. L Figure 2. Reduction rules. is one (and only one) reduction rule which \napplies. Together with the equivalence rules which apply to the operator +, this proves by induction \nthat the reduction only terminates on normal forms. 5. Fixed-point and innocent expansion In game semantics, \nstrategies naturally represent programs with the power of functional references. To obtain the behaviors \nof purely functional programs, this power must be limited, using conditions called innocence and visibility. \nInnocence states that, for a given query of the environment, the program must always react in the same \nway (the formal de.nition is recalled in section 11). In this section, we will see how translated .-terms \ngenerate this in.nite number of identical reaction through .xed-point expansion.  We extend the syntax \nwith additional constructions and an ad\u00additional rule, shown below. The new .xed-point names are ranged \nover by a, \u00df and their variants. They appear in the environment as distinguished variables: G, au : \u00acA \n| f : A f | u : \u00acA, . G | f u .a.f : 1 | u : \u00acA, . G, au : \u00acA | f u a : 1 | u : \u00acA, . . a.f .b f[a\\. \na.f] The new reduction rule extends the base reduction .b de.ned in Figure 2, and thus extends the reduction \nrelation .. The typing ensures that a .xed-point name a is always guarded by the same co-variable u. \nWe now de.ne a syntactical innocent lifting Inn, which takes a term f, and returns co-term \u00af .u.u ., \nin which u f occurs at every possible position in .. \u00af Inn(f) = .u.u .a.Inna,u(f) u, a /. FN(f) Inna,u(\u00afJ) \n= u a Inna,u(v f) = u a < v Inna,u(f) (\u00b7 \u00b7 \u00b7 ) The omitted rules in this de.nition stipulate that Inna,u \npasses through every other operator; for example, Inna,u(.x.f) = .x.Inna,u(f), and Inna,u(s + t) = Inna,u(s) \n+ Inna,u(t ). Note that the operation Inn applies only to terms, while Inna,u (for a given a) applies \nto both terms and co-terms (and preserves polarity). As an example, consider the effect of Inn on the \nterm .x.x: Inn(.x.x \u00afJ) \u00af = .u.u . a.Inna,u(.x.x J\u00af) \u00af = .u.u . a..x.x u a \u00af . .u.u .x.x u . a..x.x u \na . * \u00af .u.u .x.x u .x.x u .x.x u \u00b7 \u00b7 \u00b7 This transforms the .nite behavior of of the ..\u00af-term .x.x \u00afJ \ninto an in.nite behavior, which reacts to the initial query u as many times as needed. Without the .xed-point, \n.nite terms in our syntax could only describe .nite behaviors (with the exception of the in.nite behaviors \ndue to lack of .-expansion). The operation Inn allows us to de.ne a translation tr from the .-calculus \nto the ..\u00af-calculus: tr(M) = Inn([M]) [M N ] =[M] < Inn([N]) [.x.M] = .x.[M] [x] = x J\u00af[O] = J Note the \ninitial innocent lifting, which makes this translations re\u00adturn an Opponent-starting strategy. The correction \nof this translation (with respect to the semantics of the ..\u00af-calculus, and of the .-calculus in a comparable \nsetting) is stated in section 10.4. In particular, this translation preserves the type, modulo the equivalence \n(A \u00d7 B) . C A . B . C (which corresponds to an equality of the corresponding arenas). It does not, however, \nsend normal forms to normal forms. On the con\u00adtrary, the translation of any .-term (except O) has an \nin.nite reduc\u00adtion path (as in the above example). But, if the .-term was normal, this reduction path \nconsists exclusively of .xed-point expansion. As long as the guard condition (imposed by typing) is respected \nfor all occurrences of . a and a, this expansion is well behaved: it will always produce a move u in \none reduction. This prompts the de.\u00adnition of pseudo-normal terms (and co-terms), which may contain any \nconnectors of the extended language, except < and L. We give two examples of the translation s action. \nThe .rst is tr(.x.x), which is simply Inn(.x.x J\u00af), which we have already seen. A more complete example \nis given by the once .-expanded identity: tr(.x..y.xy) = Inn(.x..y.(x \u00afJ))) J < Inn(y \u00af = Inn(.x..y.(x \n\u00af.v.v . \u00df.y v \u00df)) J < \u00af\u00af . Inn(.x..y.(x .v.v . \u00df.y v \u00df)) \u00af\u00af = .u.u . a..x..y.(x .v.(u a < v . \u00df.y (u \na < v \u00df))) . * \u00af .u.u .x..y.x \u00af .v. ((u .x..y.x \u00b7 \u00b7 \u00b7 ) < (v y ((u \u00b7 \u00b7 \u00b7 ) < (v \u00b7 \u00b7 \u00b7 )))) Notice the \nsequence v y u , which illustrates that the co-term is ready to react to u in every branch of the co-term. \nTerms whose strategy correspond to a program without effect can be described directly as a sub-language \nof the ..\u00af-calculus, as described in sec\u00adtion 10.4. 6. Comparison with other languages 6.1 The p-calculus \nand similar languages There are many similarities between the ..\u00af-calculus and the p\u00adcalculus, essentially \nin the behavior of terms without binders . or \u00af .. For example, the following reductions are very similar \n(here s is supposed to be of a certain form, for example v fv): (x,u) (x,u) ..\u00af-calculus: L .(x s < u \nf) . * L .(f < s) . * p-calculus: . x.(x().Q | x\u00af().P ) .x.(Q | P ) In .x.(x().Q | x\u00af().P ), two processes, \nx().Q and x\u00af().P , interact along a shared private channel x, whose scope is restricted by . x. The input \nx() and the output x() must occur before P and Q can interact with the outside world. The same description \napplies to (x,u) L .(x s < u f): the input x and the output u form a private (x,u) channel, restricted \nby L , and the two processes x s and u f interact along this channel. As can been seen on this example, \na lifting by x or u cor\u00adresponds to an action of arity zero (x() or x\u00af()): no information beyond the \naction itself is transmitted. In that sense, the ..\u00af\u00adcalculus seems closer to a simpler language, such \nas CCS. There are other similarities with this language: the notion of recursive def process de.nition \nin CCS (A = P , where P may contain A) is closer to our syntactic .xed-point construction (.a) than to \nthe replication ! of the p-calculus (note that in our language, . a de\u00adnote a syntactical .xed-point, \nand not a restriction as in p-calculus). Additionally, the operator + in CCS is similar to ours. Other \naspects of the ..\u00af-calculus bring it closer to the fusion calculus [21]. This language introduces fusion \nactions which link pairs of names, and shows a complete symmetry between the input and the output; whereas \nthe p-calculus gives a special role to an input of the form x(y).P , which binds y in P (when the output \nx\u00af(y).Q does not bind y in Q). The fusion calculus is more effective at representing shared state between \nprocesses, and strong reduction strategies involving reduction under abstraction; both of which require \nelaborate encoding in the p-calculus. These two strength are also present in the ..\u00af-calculus, which \nrepresent non-innocent strategies (corresponding to programs with shared states), and allows reduction \ninside any context (in particular, this allows reduction under abstraction in the image of a .-term by \nthe translation seen in section 5). But, just as the p-calculus, the expressivity of the fusion cal\u00adculus \ndepends on actions which send and receive channel names; whereas our language relies on its system of \nbinders: ., .\u00afand L.  In particular, this means that we have no extrusion, which makes reasoning on \nscopes much simpler. Additionally, in the fusion cal\u00adculus, the fusions are represented as a global equivalence \nrelation on names, which is independent from the scope operator. In com\u00adparison, our notion of links \nis local and represented with binders.  6.2 The \u00af\u00b5-calculus .. We brie.y mention this language, described \nin [8] as an other ex\u00adample of a syntactic duality between programs and their environ\u00adments, with two \ndual binders: the \u00b5 and \u00b5 . But the similarity is only super.cial. In the \u00af\u00b5-calculus, when a term, starting \nwith a \u00b5, and .\u00b5 an environment, starting with a \u00b5 , interact, the two dual binders do not fusion in \na single symmetric step as would . and .\u00af. Instead, such an interaction is a critical pair, in which \neither the \u00b5 or the \u00b5 may be eliminated; and the choice between those two possibil\u00adity correspond to \neither call-by-value or call-by-name disciplines. In general, the duality in this language is a tool \nto study CBV and CBN, whereas in our language, there are no critical pairs, and the object of study is \nthe power of effects.  6.3 Languages with references val , the value, and k, which is immediately called \n(this gives the hand back to the calling term). If a call to read immediately fol\u00adlows, the memory cell \nreacts by calling val . To show how the strategy answers to a read after two successive writes, we apply \none step of .xed-point expansion to the co-term: \u00af cell . .\u00afwrite..read.write .val..k.k ( read . \u00df.val \nread \u00df + write . a..valv..kv.kv ( write a + read . \u00dfv .valv read \u00dfv)) Here we have also applied a-renaming \nto val, k and \u00df. This shows that, after two consecutive calls to write , the co-term will answer any \ncall to read by calling the new variable valv. Note that the other branch of the co-term, read val \u00df \n, will be discarded as soon as the Opponent makes the second call to write . To show that f3 < cell indeed \nreduces to c2 \u00afJ, we give f3 v , which is the relevant branch of f3 (more precisely, fv 3 is a term in \nnormal branch form, which is a sub-term of some expansion of f3). fv \u00af.v.\u00af 3 = .rwrite..rread.rwrite \n.u.u \u00af\u00af rwrite .vv ..uv .u v rread v v c2 J\u00af There are many differences between the ..\u00af-calculus and \nlanguages with references, in particular the one presented in [1], which is a simply typed .-calculus \nextended with reference types. Our lan\u00adguage allows reduction under any context, and that the reduction \nis con.uent, when the language in [1] uses an abstract machine with a store. Additionally, in this work \nthe power of references is obtained by duality, and not by factorization via a memory-cell strategy. \nThe expressive power of the two languages can be compared by considering their semantics. Aside from \nthe differences in the chosen setting (integer types, and the family construction for call\u00adby-value behavior, \nare not used here), the strategies represented in [1] and in this work are the same, with one distinction. \nThis differ\u00adence concerns strategies which are not single-threaded. These are represented in the ..\u00af-calculus, \nbut not in the language described in [1]. Single-threaded strategies only differ from others in that \ntheir reaction to initial moves must always be the same. This appears clearly in the difference, in the \nintroduction s example, between new r; r := true; (M N ) and f1 < s2. In the .rst case, for N to behave \ndifferently on its second call, a reference r must be de.ned before the application (M N ). If r was \ndeclared inside N, this be\u00adhavior would not be possible, as it is not a single-threaded strategy. On \nthe other hand, this same behavior is directly represented by s2. More directly, a simple memory-cell \nstrategy can be expressed in the ..\u00af-calculus. We start with an example in a language with references: \nnew r; r := c1; r := c2; !r L L where L is: {(rwrite, write), (rread, read), (val, v), (k, u), (valv \n, v v), (kv , u v)} 7. Duality and the B \u00a8ohm-out lemma The most prominent feature of our language is \nthe duality between terms and co-terms. This duality is the syntactical representation of the symmetry \nbetween the Player and the Opponent in game semantics; in particular, it shows that any action taken \nby the Op\u00adponent can be matched by the Player. This allows a (non-innocent) strategy to follow , and \nthus to recognize any possible play; which is why, in game semantics, the existence of a separator between \ntwo different strategies is immediate. Syntactically, this translates to the following, which is a form \nof B \u00a8ohm-out lemma for the ..\u00af-calculus, and will provide us with separators when proving full abstraction \nin section 10. We .rst de.ne the dual of a normal branch, which is obtained by replacing each constructor \nwith its dual, and each variable x or covariable u with a new co-variable or variable, typically denoted \nby x\u00afor u\u00af(respectively). We write f[] or s[] for contexts which are terms or co-terms. Lemma 2. For \nany term of the form f[fv], where f[J] is a closed normal branch, and any co-term of the form s[sv g], \nwhere s[\u00afJ] is the dual of f[J], fv 3 < cell . * .c2 J\u00af. c2 J\u00af LL L setting as the interaction of the \nterm f3, de.ned as the translation of for some set of links L. a .-term, with a co-term cell which represents \nthe memory-cell, Dually, for any co-term of the form s[fv], where s[J] is a closed and will be de.ned \nlater. normal branch, and any term of the form f[sv g], where f[\u00afJ] is the f3 = tr(.rwrite..rread.(rwrite \n(c1) (rwrite (c2) (rread)))) dual of s[J], f3 < cell . * c2 J\u00af L This program behaves as c2. We represent \nthis program in our f[fv] < s[sv g] . * .(fv < sv g) s[fv] < f[sv g] . * .(fv < sv g) Here f3 receives \ntwo variables, rwrite and rread. These correspond to the read and write methods of the reference; both \nare provided by cell . The write method takes two arguments: a value, and a co-term representing the \nrest of the program. Here we can see two successive writes, one with value c1, and one with value c2; \nfollowed by a read. We now give the memory cell co-term: \u00af cell =.\u00afwrite..read.write . a..val..k.k L \nfor some set of links L. To illustrate, consider the following: fv \u00af\u00afv 1 = .x.x \u00af.w.v x ..wv J .v.\u00af.vv \n.w c \u00af \u00af s2 = .u.u .y..z .y u .yv..zv .z v J\u00af L . * fv 1 < s2 .(c \u00afc J\u00afJ < J\u00af) . * L2 (write a + read \n. \u00df.val (read \u00df + write a)) where L v)}; note that to L1.L2 . f needs to v , v v), (z v L {(x, u), (y, \nv), (z, w), (y tioned above. When the write method is called, it takes a variable obtain this form, \nthe equivalence L1 = , w The two co-variables write and read , are the methods men\u00ad . .f =  be used. \nThis example is taken from the introduction (with the modi.cation that c is free in fv 1, whereas f1 \nwas a closed term in the introduction; this makes the application of the lemma more direct). To make \nthe duality obvious, s2 can be rewritten as: v vv s2 =a x.\u00afv.. \u00afv x .\u00af.. \u00af. \u00af\u00af .\u00af\u00afx .\u00afw.\u00af\u00afv wwJ vv vv \n In which case the value of L is {(x, x\u00af), (\u00afw, w), (\u00af, v w , w )}, v, v), ( \u00afv ), ( \u00aflinking each variable \nor co-variable of fv 1 to its dual. 8. Game semantics 8.1 Arenas and strategies The following de.nitions \nare those of the standard Hyland-Ong game semantics [14], but with the following simpli.cations: no distinction \nis made between questions and answers (and therefore there is no bracketing condition); there is no condition \nof determin\u00adism; and we allow odd-length plays in strategies2. These games can be equipped with a structure \nof CCC (Cartesian Closed Category) [14]. An arena A is a triple (MA, .A, fA) where MA is a .nite set \nof moves, called the alphabet of A.  .A : MA . {P, O} is a polarity, or labeling function on MA; P denotes \na Player move, and O an Opponent move.  fA is an enabling relation on MA \u00d7 MA, giving a forest structure \non MA, and satisfying:  a fA b . .A(a) = .A(b) (.b, b fA a) . .A(a) = O In the second case, a is said \nto be initial. The basic arenas 1 and . are the arenas with zero and one move, respectively. Given arenas \nA and B, one can build A \u00d7 B: MA\u00d7B = MA + MB; .A\u00d7B = [.A, .B ] (the co-pairing in Set);  a fA\u00d7B b iff \na fA b or a fB b.  As well as A . B: MA.B = MA + MB; .A.B = [-.A, .B];  b fA.B a iff b fB a, or b \nfA a, or b is initial in B and a is initial in A.  We are now able to give an interpretation [A], in \nthe obvious way, for any type A as de.ned in section 3. For the sake of simplicity, we will in general \nconfuse A and [A]. A legal play s on an arena A is a sequence of moves of A, of alternating polarities, \nequipped with justi.cation pointers: any occurrence b of a move in s must point to an occurrence of a \nmove a earlier in s, with a fA b; with the exceptions of initial moves, which have no pointer. The set \nof legal plays on A is written PA. We will also use the relaxed notion of plays, which imposes no condition \non the justi.cation pointers. A strategy on A is a pre.x-closed set of legal plays on A. A strategy is \n.nite if all its plays are of .nite length.  8.2 Player-starting arenas and strategies The arenas de.ned \nabove may be called Opponent-starting arenas, because of the polarity of initial moves. We de.ne dually \nthe 2 Allowing odd-length plays improves the symmetry between Player and Opponent, and avoids some technicalities. \nThe cost is that two strategies differing only on odd-length plays will be observationally equivalent. \nPlayer-starting arenas, and note (\u00b7) * the operator which reverses polarity. 8.3 Operations on plays \nWe now give basic operators on sets of plays. If s is a Player\u00adstarting play and m is an Opponent move, \nwe de.ne the concatena\u00adtion, or lifting m \u00b7 s as the sequence m \u00b7 s where m justi.es every move which \nwas unjusti.ed in s; and dually if the polarity of m and s are reversed (here we leave arenas implicit \nfor simplicity). A thread of a play s is a sub-sequence of moves of s which are all hereditarily justi.ed \nby the same initial move. In the following def\u00adinitions, f denotes a Player-starting strategy, s and \nt Opponent\u00adstarting strategies, M an alphabet, s a play, and A, B and X1, X2 denote arenas (we use bold \nletters f, \u00b7 \u00b7 \u00b7 for strategies, to distin\u00adguish them from elements of the syntax). Pre.xes: Pre.xes(s) \nis the set of pre.xes of the play s. This extends to sets of plays.  Thread: Thread(s) is the play obtained \nby keeping only the moves of s which are hereditarily justi.ed by the .rst move of s.  Hiding: lA(s) \nis obtained by removing in s any move not in MA; this may leave some moves in s without a pointer.3 \n Interleaving (merging): Merge(f, s) = {s . PA.B | s lA* . f, s lB . s}, where A * is the Player-starting \narena of f, and B is the arena of s. Similarly, Merge(s, t) = {s . PA\u00d7B | s lA . s, s lB . t}, where \nA is the arena of s, and B is the arena of t.  Renaming: RenameA1\\A2 (s) = s[MA1 \\MA2 ], the renaming \nof moves in s, for two isomorphic arenas A1, A2. This extends to strategies (both Player and Opponent-starting). \n Connection: Let f be a Player-starting strategy on the Player\u00adstarting arena ((A \u00d7 C2) . (B \u00d7 C1)) \n*, where C1 and C2 are isomorphic; then ConnectionC2,C1 (f) = Pre.xes({s l(A.B)* | s . f, s lC2 s lC1 \n}). 4  Detach: DetachA(s) is obtained by removing the justi.cation pointers of each move m in s such \nthat m is initial in A. This extends to sets of plays.  9. Semantics The types are interpreted as Opponent-starting \narenas, as seen in section 8.1. The interpretation for an environment G = (xi : \u00acAi)i is that of the \ntype A1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 An; and similarly for a co\u00adenvironment .. A typing of the form G | f s : A | . is interpreted \nas an Opponent-starting strategy [s] on the Opponent\u00adstarting arena G . (A \u00d7 .). A typing of the form \nG | f : A f | . is interpreted as a Player-starting strategy [f], on the Player\u00adstarting arena (. . (G \n\u00d7 A)) *. In the following de.nitions, we use the notations of the typing rule corresponding to each case. \nIn some instances, indices are added to distinguish isomorphic sub\u00adarenas. [u f]: We note ((. \u00d7 (A2 . \n.2)) . (G \u00d7 A)) * the Player\u00adstarting arena of [f] in the following: [u f] = Detach.\u00d7(A2..2)(Pre.xes( \n{q2 \u00b7 s | s . RenameA\\A2 ([f])})) 3 This differs slightly from the usual de.nition of hiding, in which \nsome of the moves which loose their pointer gain a new one (if a move which hereditarily justi.es it \nstill exists). 4 We close by pre.xes here because the condition s lC1 s lC2 rejects odd-length plays. \n where q2 is the only (Opponent) move of .2. The resulting strategy plays on G . (. \u00d7 (A2 . .2)). We \nstarted with this construction, as it is the most representative of the speci.city of the language. The \nstrategy [f] is lifted by an Opponent move q2. But instead of this move being a fresh one, it is the \ninitial move in the arena corresponding to the type of the co-variable u. Recall that this type is necessarily \na negation form, guaranteeing the existence and uniqueness of q2. The moves of A occurring in [f] are \nalso renamed to their counterparts in A2, which is the copy of A, contained in the co\u00adenvironment, and \nspeci.c to u; this hides A from the outside. Intuitively, this means that we build plays on A2 . .2 by \nplaying the .rst move (q2), then by using an existing play on A. We also need to .x the pointer structure, \nwhich otherwise would show the initial moves of . as having a justi.er, itself justi.ed by q2. In fact, \nthe resulting strategy will only play in . if it already played q2 followed by some Player move; but \nthe arrival type is more liberal, and would have allowed moves in . to be played immediately. To re.ect \nthis, we detach the moves which are initial in ., showing that they did not need any justi.cation (the \nsame is done for the initial moves of A2 . .2, i.e. for q2). [x s]: We note (G \u00d7 (A2 \u00d7 B2 . .2)) . (A \n\u00d7 .) the arena of [s] in the following: [x s] = DetachG\u00d7(A2\u00d7B2..2)(Pre.xes( {q2 \u00b7 s . P(..(G\u00d7((A2\u00d7B2)..2)\u00d7B))* \n|. RenameA\\A2 s l(..(G\u00d7(A2\u00d7B2)..2))* ([s]), s lB Thread(q2 \u00b7 s) lB2 })) where q2 is the only (Player) \nmove of the Player-starting arena .2 * . The resulting strategy plays on: (. . (G \u00d7 (A2 \u00d7 B2 . .2) \u00d7 \nB)) * This construction is very similar to the previous one, but must support partial application (note \nthat in u f, the types of u and f must match, whereas in x s, the match is only partial, leav\u00ading B out). \nThis translates to copycat moves between two copies of B: the .rst one (noted B2) was already present \nin the environment as part of the type of x; while a new one (noted simply B) is introduced by the construction. \nThe in\u00adtroduction of this new copy is done when we pick plays in P(..(G\u00d7((A2\u00d7B2)..2)\u00d7B))* , while the \ncopycat behavior is enforced by the condition s lB2 s lB . Only moves in the cur\u00adrent thread, that are \nhereditarily justi.ed by the new occurrence of q2, are copied in this way. Thus, as in the previous construc\u00adtion \nof [u f], we are extending the behavior of the strategy in the arena corresponding to a given variable \n(or co-variable) name, by adding a single new thread, which is initiated with the negation move speci.c \nto that name. [s < t ]: We note G . (A \u00d7 .) the arena of [s], and Gv . (B \u00d7 .v) the arena of [t] in the \nfollowing: [s < t ] = Rename./\\.(RenameG/\\G(Merge([s], [t ]))) Note the identi.cation of the environments \nand co-environments of the two strategies. [f < s]: We note (. . (G \u00d7 A \u00d7 B)) * the Player-starting arena \nof [f], and (Gv . (Av \u00d7 .v) the arena of [s] in the following: [f < s] = Rename./\\.(RenameG/\\G( ConnectionA,A \n / (Merge([f], [s])))) This is similar to the previous construction, but with the addi\u00adtion of the implicit \nconnection between the two strategies (on the shared type A). The remaining constructions are all straight\u00adforward. \nL LS* [ (f)]: We note ((S2 \u00d7 L2 \u00d7 .) . (G \u00d7 L \u00d7 S \u00d7 A)) the Player-starting arena of [f] in the following: \nL LS (f)] = ConnectionS\u00d7L,S2\u00d7L2 ([f]) [ .x.f] = [f]. Here the type changes, but neither its interpre\u00adtation \nnor the strategy. \u00af .u.s] = [s]. f + .] = [f] . [.]. s + t ] = [s] . [t]. J is the empty Player-starting \nstrategy. \u00afJ] is the empty strategy. [ .a.f]: In section 5, we de.ned the syntactical innocent lift\u00ading \nusing the .xed-point. This is coherent with the syntax\u00addriven approach of this work. But in the semantics, \nit is more natural to proceed in the other direction. We will thus de.ne a semantic operation, the innocent \nlifting Innocent(f). It is the set of plays s such that all threads of s, seen as separate plays, are \nin q \u00b7 f, where q is a fresh move; and it can be shown that [Inn(f)] = Innocent([f]). The result is a \nstrategy which sat\u00adis.es a form of weak innocence: it always reacts the same way to the query q (the \ninitial lifting move). This is close to the usual de.nition of single threaded strategies. The difference \nis that single threaded strategies may have more than one initial move; and are weakly innocent for each \nof these.5 We now use Innocent([f]) as the basis for the de.nition of [.a.f]. On one hand, the strategy \nInnocent([f]) reacts to its initial move as many time as asked, by behaving as f; on the other hand, \nit contains moves corresponding to the distinguished variable a. A Connection operation is used to link \nthese two types of moves. Formally, we note (. . (A1 \u00d7 A2 \u00d7 G)) * the Player\u00adstarting arena of [f] in: \n [.a.f] =ConnectionA1..1,A2..2 (Pre.xes( {q2 \u00b7 s . P(((A1..1)\u00d7.).(G\u00d7(A2..2)\u00d7A))* |s l (((A1 . .1) \u00d7 \n.) . (G \u00d7 (A2 . .2))) * . Innocent([f]), s l A Thread(q2 \u00b7 s) l A2} where q2 is the only move in .2 \n* . In addition to the operations Connection and Innocent, this de.nition uses elements of the de.nition \nof [x s], with the move corresponding to a as the lifting move (q2); thus prompting the strategy to start \nacting as f a .rst time. [a]: We do not write the de.nition of [a], which is identical to that of a standard \nvariable call. Lemma 3. These de.nitions are correct, i.e. each of the above constructions de.nes a strategy \nor Player-starting strategy on the appropriate arena or Player-starting arena. 10. Properties We have \nnow seen two versions of the ..\u00af-calculus, and their respective semantics; we will now list their main \nproperties. When a distinction between the two languages is needed, we will refer to the syntax described \nin section 2 as the base language, while the extended language includes the .xed-point. 5 These strategies \nare captured by co-terms of the form Inn(f1) < \u00b7 \u00b7 \u00b7 < Inn(fn), where Inn is a syntactic operation de.ned \nlater in the same section.  10.1 Subject reduction Lemma 4. If f is a term in the extended ..\u00af-calculus \nsuch that G | f : A f | . and f . * ., then G | . : A f | .. The dual also holds. 10.2 Con.uence Theorem \n5. The reduction relation . for the extended ..\u00af\u00adcalculus is con.uent, i.e, for any term f, we have: \n(f . * .1 . f . * .2) . .., .1 . * . . .2 . * . The dual also holds. Proof. The proof follows the pattern \nof a proof of the con.uence of .-calculus as described [4]. We de.ne a new relation =. which corresponds \nto multiple parallel applications of the reduction . inside a term (or co-term). This relation veri.es \nthe Church-Rosser property, and its transitive closure is equal to . * . 10.3 Reduction soundness Proposition \n6. The reduction . for the extended ..\u00af-calculus is sound: f . . and f = . . [f] = [.] . [f] = [.] The \ndual also holds. Proof. As an illustration, we detail the case of the rule: L,(x,u) L,(x,u). S --v \u00b7S \n\u00af. L .x .v .u f . L .f To make the notations more compact, we will write AB for A \u00d7 B, and \u00ac(A1B1) (for \nexample) for (A1B1) . .1; moreover [f] : A * will mean that f plays on A * (and similarly for [s] : A). \nWe start from the right-hand side of the rule: [f] : ((A4S4L4\u00ac(A3S3B3)) . (L\u00ac(A2S2B2)ASB)) * L,(x,u) \n- . L v \u00b7S.f] : B * = [ ConnectionA4S4L4 \u00ac(A3S3B3) , ASL\u00ac(A2S2B2)([f]) . (The type of -v is A, while \nx and u have type \u00ac(ASB)). Consider now the left-hand side: [u f] : (L\u00ac(A2S2B2)) . (A4S4L4\u00ac(A3S3B3)) \n= DetachA4S4L4 \u00ac(A3S3B3)(Pre.xes( {q3 \u00b7 s . RenameASB\\A3S3B3 ([f]))) \u00af- . [x .v .u f] : ((S4L4 \u00ac(A3S3B3)) \n. (L\u00ac(A2S2B2)S5B5)) * = DetachL\u00ac(A2S2B2)(Pre.xes( {q2 \u00b7 s . P((S4L4 \u00ac(A3S3B3)).(L\u00ac(A2S2B2)S5B5))* s l((S4L4\u00ac(A3S3B3)).(L\u00ac(A2S2B2)))* \n. RenameA4\\A2 ([u f]), s lS5B5 Thread(s) lS2B2 })) L,(x,u) S \u00af-* . L .x .v .u f] : B5 = . [ ConnectionS4L4\u00ac(A3S3B3) \n, S5L\u00ac(A2S2B2)([x .\u00af-v .u f]) The semantic constructions on each side of the rule send plays of L,(x,u) \nL,(x,u). S \u00af--v \u00b7S . [f] to sets of plays in either [ L .x .v .u f] or [ L .f]. Let s be a play of [f]; \nwe can assume that its image in the left-hand side is not obtained from any of its strict pre.xes (this \namounts to say that the conditions of the type s v lC1 s v lC2 are respected). The moves of B in s \nare renamed to B3, which must match moves in B2, some of which must match moves in B5, the target arena. \nThe moves of B3 which will in the end be matched in B5 are ex\u00adactly those in the .rst thread of plays \nin [u f], i.e., those justi.ed by the new occurrence of q3 introduced by the lifting. These are exactly \nthose which originated in B (those originally from B3 are justi.ed by a later occurrence of q3, which \nhas been detached ). These transformations preserve relative order and relative justi.\u00adcation. Additionally, \ninitial moves in a copy of B which gain a justi.er (q2 or q3) through lifting are again initial in the \nimage of s, as both q2 and q3 are absent from it. We now compare with the image of s by the syntactic \nconstruction of the right-hand side. This image too contains only moves of B which appeared in s, and \nalso preserves the justi.cation structure and the relative order of these moves. Under our assumption \n(that the image of s in the left-hand side was maximal among its pre.xes), all the moves of B appearing \nin s appear in its left-hand side image. From this it can be deduced that in s, the moves of A and A4, \nS and S4 and L\u00ac(A2S2B2) and L4\u00ac(A3S3B3) match, by tracking the behavior of s in the copies of A, S and \nL as we did for B. Therefore all the moves of B in s also appear in the image of s in the right-hand \nside, and thus the two images coincide. 10.4 Translation from .-calculus Lemma 7. The translation tr \nde.ned in section 5 is correct: given a simply typed .-term M whose type contains only . as base type, \nwe have: [tr(M)] = [M ]. Where [\u00b7]. is, for example, the semantics of M as a PCF term as seen in [14]; \nand all moves in [tr(M)] are taken to be questions. Innocent strategies can also be described directly \nas the co-terms written in the following syntax: f, . := J | .x.f | x s | f + . | f < s s, t := J\u00af| Inn(f) \n| s + t | s < t This intuitively builds strategies which are weakly innocent for every query. Notice \nthat co-variables do not appear explicitly in this syntax. Lemma 8. For any co-term s in the above syntax, \n[s] is innocent. The de.nition of innocence is recalled at the beginning of sec\u00adtion 11. In the above \nlemma we did not mention terms, to stay in the framework of the standard notion of (Opponent-starting) \nstrate\u00adgies. But innocence obviously extends to Player-starting strategies, and the syntax above is one \nway of de.ning such an extension. 10.5 Full abstraction As is the case in other works, including [1], \nde.nability is obtained by compactness: the set of .nite strategies is compact in the set of all strategies, \nfor the order . (the inclusion). In the following, we distinguish A and A = [A]. Lemma 9 (De.nability). \nFor any .nite strategy s on the arena A, there exists a closed normal co-term s of type A such that [s] \n= s. The dual also holds. Proof. The co-term s is obtained using the systematic labeling of plays which \nwe sketched in the introduction. Each maximal-length play of the strategy can be represented in this \nway; the obtained co\u00adterms are in .nite number (arenas in our setting have .nitely many positions, making \nany strategy a .nitely-branching tree), and their sum, by the operator +, represents the full strategy. \nNote that construction does not use .xed-points. The tight con\u00adnection between terms and strategies is \nillustrated by the following proposition: Proposition 10. For any well-typed term f in the extended ..\u00af\u00adcalculus, \nfor any .nite play s, s . [f] . .fb, fv f . * fb + fv . s . [fb] where fb is a normal branch. The dual \nalso holds.  Proof. This is a consequence of the construction f8 used in the proof of full abstraction. \nWe now de.ne the observational equivalence, as well as an equivalence relation on strategies: De.nition \n11. Two terms f and . are said to be observationally equivalent, noted f ~ ., if, for any context C[], \nand any variable c: C[f] . * c J\u00af+ fv . C[.] . * c J\u00af+ .v for some fv and .v . The dual s ~ t is de.ned \nsimilarly. De.nition 12. For two strategies f and ., we write f PE . when their sets of Player-ending \nplays are equal. Theorem 13 (Full abstraction). For any terms f, . of the same type in the extended ..\u00af-calculus, \nf ~ . . [f] PE [.] The dual also holds. Proof. To prove this, we de.ne (potentially) in.nite terms f8 \nand .8, and prove that both f ~ . and [f] PE [.] are equivalent to f8 = .8. We .rst show that, for any \nwell-typed term f, and any n . N, there exists fn with f . * fn, such that fn is in normal form up to \ndepth n , except for non-normal sub\u00adterms whose interpretation is the empty strategy. This is proven \nby induction on terms and co-terms, using properties of normal\u00adbranch contexts (of which Lemma 2 is an \nexample). From fn we build fv , in which sub-terms with empty interpretations have been n replaced by \nJ, then sub-coterms of the form u J have been replaced by J\u00af. The sequence (fv )n has a limit, and f8 \nis de.ned as the .\u00ad n expansion of this limit. This (potentially) in.nite term f8 directly represents \nthe strategy [f] (up to PE), similarly to what was seen in the introduction for .nite strategies. 11. \nHistory access control and the notion of view In game semantics, the condition of innocence restricts \nthe infor\u00admation and actions available to a strategy, by limiting it s access of the history to a speci.c \nsub-sequence called the view. In this sec\u00adtion, we will show how the description of innocence as a .xed-point \nexpansion (seen in section 5) gives a direct syntactic representation of views. This new notion is more \ngeneral, and allows to de.ne a more precise history access control. We start by recalling the standard \nde.nition of the view. Let s be an Opponent-starting play of odd-length in the following: If s is of \nthe form s v \u00b7 a, where a is an initial Opponent move, then view(s) = a.  If s is of the form s v \u00b7 \na \u00b7 s vv \u00b7 b, where b is justi.ed by a, then view(s) = view(s v) \u00b7 a \u00b7 b, where b is justi.ed by a. \n An Opponent-starting strategy s satis.es the visibility condition if, for all plays s \u00b7 a . s where \na is a Player move, the justi.er of a in that play is in view(s). Finally, if s satis.es the visibility \ncondition, it is called innocent if its behavior depends only on the current view, i.e.: if s, s v are \neven-length Opponent-starting plays, s \u00b7 a \u00b7 b . f, s v \u00b7 b . P(A) and view(s \u00b7 a) =view(s v \u00b7 a), then \ns v \u00b7 a \u00b7 b . s (where A is the arena of s). The behavior of an innocent strategy is characterized by \nthe set of its views. The generation of the full strategy from this set is exactly the process of innocent \nexpansion. Taking the simple example of tr(.x.x), the only view of the strategy corresponds to \u00af .u.u \n.x.x. In the case of tr(.x..y.xy), there are two views, \u00af .u.u .x..y.x J\u00afand \u00af.v.v y \u00af .u.u .x..y.x \u00afJ. \nThese can be seen as the states of the program, and the Opponent moves as the tran\u00adsitions between the \nstates. For example, the Opponent move v is a transition from the .rst to the second view of tr(.x..y.xy); \nthis transition leads to a view which extends the previous one. On the other hand, if the Opponent plays \nthe move u from the second view, it forces a transition back to the .rst view. This second case, in which \na transition goes back to a previous state, is exactly repre\u00adsented by the occurrences of u a in the \ntranslated term: \u00af\u00af .u.u . a..x..y.(x .v.. \u00df.(u a < v y (u a < \u00df))) The occurrences of u a can be seen \nas a goto instructions which points back to the binder . a. In the above, there are three such transitions: \nfrom the .rst view to itself, along u, from the second view to itself, along v, and .nally from the second \nview to the .rst, along u. When adding the forward transitions, this equips the co-term with a structure \nresembling an automaton. The difference with an actual automaton is that the alphabet (the set of co\u00advariable \nnames) is in.nite. Syntactically, .xed-points expansion may duplicate binders, increasing the number \nof available names. Additionally, when a transition goes back to a previous state, it opens a new copy \nof the program. A subsequent Opponent move may jump between copies, in addition to jumping backward or \nextending the current view. For example, tr(.x..y.xy) contains the following play: \u00af \u00af .u.u .x..y.x \u00af..yv \nv .vv .v y J\u00af .v.v y u .xv .x Here the second occurrence of v illustrates such a jump. The .rst copy \nhere corresponds to \u00afJ, and the sec\u00ad .u.u .x..y.x v y \u00afond copy, opened by the second occurrence of u, \ncorresponds to \u00af u .xv..yv .x v .vv . Notice that, when the Opponent plays the sec\u00adond occurrence of \nv, this move cannot extend the current view at this point, nor jump back in that view; it has to jump \nto the (still opened) .rst view, where the binder \u00af .v lies. Syntactically, the fact that a backward \njump keeps the old view opened is due to the presence of < (instead of +) in the de.nition of Inn. We \nnow formalize the notion of syntactic view. Let f be a term in the extended ..\u00af-calculus; let fv be the \nterm obtained by removing all . a. and a in f (the occurrences of a a being replaced by J). If fv is \na normal term, then its branches are called the generalized views of f. The generalized views of a co-term \ns are de.ned dually. The set of generalized views of a normal term (or co-term) de\u00adtermines its level \nof access to the history of the interaction. Every transition between views which is due to an occurrence \na prevents the program to follow the transition, and to distinguish this play from a shorter one. In \nthe previous example, this means that the program cannot distinguish between an interaction history contain\u00ading \nonly one move u, or two successive moves u. In this exam\u00adple, the restriction of information corresponds \nto the innocence of tr(.x..y.xy). This is not the case for the co-term cell de.ned in section 6.3. This \nco-term is not innocent (it reacts differently to different calls to the co-variable read), but it is \nimposed a form of history access control; in particular, it cannot distinguish between two occurrences \nof read if a write does not occur between the two. This behavior can be seen as form of conditional innocence \nfor the co-variable read. 12. Future work: toward better static control of effects Section 5 gives a \nblueprint to write static program speci.cations in the ..\u00af-calculus. In this section, we used the .xed-point \n. a to de.ne a construction Inn. We then de.ned a syntax of terms and co-terms, which includes this new \nconstruction, but does not include the covariables u and their binder \u00af  .u. This forces elements of \nthis syntax to conform to a certain discipline, set by the de.nition of Inn. In this example, it was \nmerely to regain the well known behavior of innocent strategies. But this method can be generalized. \nIn the previous section, we saw that the .xed-point allows us to describe history access control in a \n.exible way. We used cell as an example of a strategy obeying a discipline other than innocence. The \nblueprint of section 5 could be used to formalize this notion of conditional innocence , and give a syntax \nof terms which are guaranteed to respect it. This method could also be used to give syntaxes corresponding \nto classes of strategies described in other works. For example, in [11], operators are de.ned on games, \ncorresponding to granting ei\u00adther the Player or the Opponent the right to backtrack in the history. The \ncomposition of these operators builds the innocent strategies. But taken separately each operator describes \na new discipline. Ad\u00additionally, the modular approach of this work may bene.t from a syntactical description. \nAnother example is given by the cellular strategies [12], which were inspired by cellular terms [20], \nused in decidability results. These strategies obey a very speci.c discipline. Their actions (the available \nPlayer moves) are restricted according to a .rst notion of view, which is more strict than in the case \nof in\u00adnocence; but their available information depends on another notion of view, which is more lax than \nfor innocence. These interaction of such strategies exhibits certain properties; in particular, it does \nnot require a referee. Because they are not innocent, they correspond to programs with effects, but with \nimportant restrictions. The examples above come from theoretical works. But we be\u00adlieve that the ability \nto de.ne meaningful constraints on behaviors with effect can have more practical applications; and that \nthis ap\u00adproach could provide syntaxes which allow some of the power of effects, but still guarantee safety \nproperties. 13. Conclusion We have presented a language, which very directly re.ects the structure of \ngame semantics. This has allowed us to give a syn\u00adtactic account of many key concepts of the model. We \nhave shown that the implicit repetitions in innocent strategies could be seen as a .xed-point expansion. \nOn translated .-terms, we have recognized views in the syntactic branches, and seen that the transitions \nbe\u00adtween these views were made explicit by the structure of pointers given by the . a and a (the .xed-point). \nThis immediately gave a generalization of views, as a .exible way to express history access control. \nBeyond innocence, we have seen that the power of effects is obtained by dualization of the .-calculus; \nin other words, that this power corresponds to a symmetric access to the history, for the Player and \nthe Opponent. This naturally leads to the obtention of separators through duality: any normal branch \ncan be matched by its dual, giving a form of B \u00a8ohm-out lemma. Finally, we have argued that our language \ngives an interesting method of constrain\u00ading effects, without forbidding them entirely; which could lead \nto better static control of effects. References [1] S. Abramsky, K. Honda, and G. McCusker. A fully abstract \ngame semantics for general references. In Logic in Computer Science, 1998. Proceedings. Thirteenth Annual \nIEEE Symposium on, pages 334 344. IEEE, 1998. [2] S. Abramsky, R. Jagadeesan, and P. Malacaria. Full \nabstraction for pcf. Information and Computation, 163(2):409 470, 2000. [3] S. Abramsky and G. McCusker. \nLinearity, sharing and state: a fully abstract game semantics for idealized algol with active expressions. \nIn Algol-like languages. Citeseer, 1997. [4] H.P. Barendregt. The lambda calculus: its syntax and semantics, \nvolume 103. North Holland, 1984. [5] M. Basaldella and C. Faggian. Ludics with repetitions (exponentials, \ninteractive types and completeness). In Logic In Computer Science, 2009. LICS 09. 24th Annual IEEE Symposium \non, pages 375 384. IEEE, 2009. [6] M. Churchill and J. Laird. A logic of sequentiality. In Computer Science \nLogic, pages 215 229. Springer, 2010. [7] M. Churchill, J. Laird, and G. McCusker. Imperative programs \nas proofs via game semantics. In Logic in Computer Science (LICS), 2011 26th Annual IEEE Symposium on, \npages 65 74. IEEE, 2011. [8] P.L. Curien and H. Herbelin. The duality of computation. In ACM sigplan \nnotices, volume 35, pages 233 243. ACM, 2000. [9] P.L. Curien and H. Herbelin. Abstract machines for \ndialogue games. Arxiv preprint arXiv:0706.2544, 2007. [10] A. Goyet. The ..\u00af-calculus, implementation \nmanual. http://www. pps.univ-paris-diderot.fr/~agoyet/llbc. [11] R. Harmer, M. Hyland, and P.A. Mellies. \nCategorical combinatorics for innocent strategies. In Logic in Computer Science, 2007. LICS 2007. 22nd \nAnnual IEEE Symposium on, pages 379 388. IEEE, 2007. [12] Russ Harmer. Cellular strategies and innocent \ninteraction. Draft. [13] H. Herbelin. Games and weak-head reduction for classical pcf. Typed Lambda Calculi \nand Applications, pages 214 230, 1997. [14] J.M.E. Hyland and C.H.L. Ong. On full abstraction for pcf: \nI, II, and III. Information and computation, 163(2):285 408, 2000. [15] J. Laird. Full abstraction for \nfunctional languages with control. In Logic in Computer Science, 1997. LICS 97. Proceedings., 12th Annual \nIEEE Symposium on, pages 58 67. IEEE, 1997. [16] J. Longley. Some programming languages suggested by \ngame mod\u00adels. Electronic Notes in Theoretical Computer Science, 249:117 134, 2009. [17] P.A. Mellies. \nAsynchronous games 2: the true concurrency of inno\u00adcence. CONCUR 2004-Concurrency Theory, pages 448 465, \n2004. [18] P.A. Melli `es and N. Tabareau. Resource modalities in tensor logic. Annals of Pure and Applied \nLogic, 161(5):632 653, 2010. [19] H. Nickau. Hereditarily sequential functionals. Logical Foundations \nof Computer Science, pages 253 264, 1994. [20] Vincent Padovani. Decidability of All Minimal Models. \nhttp: //hal.archives-ouvertes.fr/hal-00741219, 2012. [21] J. Parrow and B. Victor. The fusion calculus: \nExpressiveness and symmetry in mobile processes. In Logic in Computer Science, 1998. Proceedings. Thirteenth \nAnnual IEEE Symposium on, pages 176 185. IEEE, 1998. A. A complete reduction example In Figure 3, we \nshow the complete reduction of one of the examples of the introduction: the term f1 < s2. This .gure \nwas obtained as an output of the implementation which is available at [10].  .x..c.x \u00af.v.\u00af.w.v x \u00af.vv \n. \u00af.wv .w v c \u00afJ < \u00af.u.u .y..z.y u .yv..zv .z v \u00afJ . Lu .(.x..c.x \u00af.v.\u00af.w.v x \u00af.vv . \u00af.wv .w v c \u00afJ < \nu .y..z.y u .yv..zv .z v \u00afJ) . Lu ..x.(.c.x \u00af.v.\u00af.w.v x \u00af.vv . \u00af.wv .w v c \u00afJ < u .y..z.y u .yv..zv .z \nv \u00afJ) . (x,u)L .(.c.x \u00af.v.\u00af.w.v x \u00af.vv . \u00af.wv .w v c \u00afJ < u .y..z.y u .yv..zv .z v \u00afJ) . (x,u)L ..c.(x \n\u00af.v.\u00af.w.v x \u00af.vv . \u00af.wv .w v c \u00afJ < u .y..z.y u .yv..zv .z v \u00afJ) . .c. (x,u)L .(x \u00af.v.\u00af.w.v x \u00af.vv . \n\u00af.wv .w v c \u00afJ < u .y..z.y u .yv..zv .z v \u00afJ) . .c. (x,u)L .x (\u00af.v.\u00af.w.v x \u00af.vv . \u00af.wv .w v c \u00afJ < u \n.y..z.y u .yv..zv .z v \u00afJ) . .c. (x,u)L .x \u00af.v.(\u00af.w.v x \u00af.vv . \u00af.wv .w v c \u00afJ < u .y..z.y u .yv..zv .z \nv \u00afJ) . .c. (x,u)L .x \u00af.v.\u00af.w.(v x \u00af.vv . \u00af.wv .w v c \u00afJ < u .y..z.y u .yv..zv .z v \u00afJ) . .c. (x,u)L \n.x \u00af.v.\u00af.w.(v (x \u00af.vv . \u00af.wv .w v c \u00afJ < u .y..z.y u .yv..zv .z v \u00afJ) + u (.y..z.y u .yv..zv .z v \u00afJ \n< v x \u00af.vv . \u00af.wv .w v c \u00afJ)) = .c.( (x,u)L .x \u00af.v.\u00af.w.v (x \u00af.vv . \u00af.wv .w v c \u00afJ < u .y..z.y u .yv..zv \n.z v \u00afJ) + (x,u)L .x \u00af.v.\u00af.w.u (.y..z.y u .yv..zv .z v \u00afJ < v x \u00af.vv . \u00af.wv .w v c \u00afJ)) . .c.(J + (x,u)L \n.x \u00af.v.\u00af.w.u (.y..z.y u .yv..zv .z v \u00afJ < v x \u00af.vv . \u00af.wv .w v c \u00afJ)) = .c. (x,u)L .x \u00af.v.\u00af.w.u (.y..z.y \nu .yv..zv .z v \u00afJ < v x \u00af.vv . \u00af.wv .w v c \u00afJ) . .c. (x,u)L v\u00b7w .(.y..z.y u .yv..zv .z v \u00afJ < v x \u00af.vv \n. \u00af.wv .w v c \u00afJ) . .c. (x,u)L v\u00b7w ..y.(.z.y u .yv..zv .z v \u00afJ < v x \u00af.vv . \u00af.wv .w v c \u00afJ) . .c. (y,v)(x,u)L \nw .(.z.y u .yv..zv .z v \u00afJ < v x \u00af.vv . \u00af.wv .w v c \u00afJ) . .c. (y,v)(x,u)L w ..z.(y u .yv..zv .z v \u00afJ \n< v x \u00af.vv . \u00af.wv .w v c \u00afJ) . .c. (z,w)(y,v)(x,u)L .(y u .yv..zv .z v \u00afJ < v x \u00af.vv . \u00af.wv .w v c \u00afJ) \n. .c. (z,w)(y,v)(x,u)L .y (u .yv..zv .z v \u00afJ < v x \u00af.vv . \u00af.wv .w v c \u00afJ) . .c. (z,w)(y,v)(x,u)L .y (u \n(.yv..zv .z v \u00afJ < v x \u00af.vv . \u00af.wv .w v c \u00afJ) + v (x \u00af.vv . \u00af.wv .w v c \u00afJ < u .yv..zv .z v \u00afJ)) = .c.( \n(z,w)(y,v)(x,u)L .y u (.yv..zv .z v \u00afJ < v x \u00af.vv . \u00af.wv .w v c \u00afJ) + (z,w)(y,v)(x,u)L .y v (x \u00af.vv . \n\u00af.wv .w v c \u00afJ < u .yv..zv .z v \u00afJ)) . .c.(J + (z,w)(y,v)(x,u)L .y v (x \u00af.vv . \u00af.wv .w v c \u00afJ < u .yv..zv \n.z v \u00afJ)) = .c. (z,w)(y,v)(x,u)L .y v (x \u00af.vv . \u00af.wv .w v c \u00afJ < u .yv..zv .z v \u00afJ) . .c. (z,w)(y,v)(x,u)L \n.(x \u00af.vv . \u00af.wv .w v c \u00afJ < u .yv..zv .z v \u00afJ) . .c. (z,w)(y,v)(x,u)L .x (\u00af.vv . \u00af.wv .w v c \u00afJ < u .yv..zv \n.z v \u00afJ) . .c. (z,w)(y,v)(x,u)L .x \u00af.vv .(\u00af.wv .w v c \u00afJ < u .yv..zv .z v \u00afJ) . .c. (z,w)(y,v)(x,u)L \n.x \u00af.vv . \u00af.wv .(w v c \u00afJ < u .yv..zv .z v \u00afJ) . .c. (z,w)(y,v)(x,u)L .x \u00af.vv . \u00af.wv .(w v (c \u00afJ < u \n.yv..zv .z v \u00afJ) + u (.yv..zv .z v \u00afJ < wv c \u00afJ)) = .c.( (z,w)(y,v)(x,u)L .x \u00af.vv . \u00af.wv .w v (c \u00afJ < \nu .yv..zv .z v \u00afJ) + (z,w)(y,v)(x,u)L .x \u00af.vv . \u00af.wv .u (.yv..zv .z v \u00afJ < wv c \u00afJ)) . .c.(J + (z,w)(y,v)(x,u)L \n.x \u00af.vv . \u00af.wv .u (.yv..zv .z v \u00afJ < wv c \u00afJ)) = .c. (z,w)(y,v)(x,u)L .x \u00af.vv . \u00af.wv .u (.yv..zv .z v \n\u00afJ < wv c \u00afJ) . .c. (z,w)(y,v)(x,u)L v/\u00b7w/ .(.yv..zv .z v \u00afJ < wv c \u00afJ) . .c. (z,w)(y,v)(x,u)L v/\u00b7w/ \n..yv .(.zv .z v \u00afJ < wv c \u00afJ) . .c. (y/,v/)(z,w)(y,v)(x,u)L w/ .(.zv .z v \u00afJ < wv c \u00afJ) . .c. (y/,v/)(z,w)(y,v)(x,u)L \nw/ ..zv .(z v \u00afJ < wv c \u00afJ) . .c. (z/,w/)(y/,v/)(z,w)(y,v)(x,u)L .(z v \u00afJ < wv c \u00afJ) . .c. (z/,w/)(y/,v/)(z,w)(y,v)(x,u)L \n.z v (\u00afJ < wv c \u00afJ) = .c. (z/,w/)(y/,v/)(z,w)(y,v)(x,u)L .z v w v c \u00afJ . .c. (z/,w/)(y/,v/)(z,w)(y,v)(x,u)L \n.c \u00afJ . .c.c \u00afJ Figure 3. A complete reduction example.   \n\t\t\t", "proc_id": "2429069", "abstract": "<p>We present a calculus which combines a simple, CCS-like representation of finite behaviors, with two dual binders &#955; and &#955;&#175;. Infinite behaviors are obtained through a syntactical fixed-point operator, which is used to give a translation of &#955;-terms. The duality of the calculus makes the roles of a function and its environment symmetrical. As usual, the environment is allowed to call a function at any given point, each time with a different argument. Dually, the function is allowed to answer any given call, each time with a different behavior. This grants terms in our language the power of functional references.</p> <p>The inspiration for this language comes from game semantics. Indeed, its normal forms give a simple concrete syntax for finite strategies, which are inherently non-innocent. This very direct correspondence allows us to describe, in syntactical terms, a number of features from game semantics. The fixed-point expansion of translated &#955;-terms corresponds to the generation of infinite plays from the finite views of an innocent strategy. The syntactical duality between terms and co-terms corresponds to the duality between Player and Opponent. This duality also gives rise to a B&#246;hm-out lemma.</p> <p>The paper is divided into two parts. The first one is purely syntactical, and requires no background in game semantics. The second describes the fully abstract game model.</p>", "authors": [{"name": "Alexis Goyet", "author_profile_id": "81474699462", "affiliation": "Univ Paris Diderot, Sorbonne Paris Cit&#233;, Paris, France", "person_id": "P3977941", "email_address": "alexis.goyet@pps.univ-paris-diderot.fr", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429089", "year": "2013", "article_id": "2429089", "conference": "POPL", "title": "The Lambda Lambda-Bar calculus: a dual calculus for unconstrained strategies", "url": "http://dl.acm.org/citation.cfm?id=2429089"}