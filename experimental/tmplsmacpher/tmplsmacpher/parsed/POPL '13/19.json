{"article_publication_date": "01-23-2013", "fulltext": "\n From Principles to Programming Languages (and Back) Shriram Krishnamurthi Computer Science Department, \nBrown University sk@cs.brown.edu Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: \nFormal De.nitions and Theory semantics; D.2.4 [Soft\u00adware Engineering]: Software/Program Veri.cation \nKeywords semantics engineering, democracy of languages The Democracy of Programming Languages While budding \nlinguists have always had the freedom to tinker, the Web has revolutionized linguistic experiments in \ntwo key ways. First, the language-neutrality of network abstractions have made it possible for Web-deployed \napplications to be written in any lan\u00adguage at all, allowing new languages to show off their capabilities. \nSecond, the Web has greatly facilitated the dissemination of these experimental languages. As a result, \nnew languages crop up almost daily, lovingly tended by their designers and user communities and vigorously \ndebated on popular forums. This is a far cry from the programming languages world of just over a decade \nago. Most of these languages are not designed and developed in for\u00admal settings. As a result, they lack \nmany of the tools that this con\u00adference s audience takes for granted: static analyses, type systems, \nveri.cation engines, and so on. As we know, these tools not only improve usability, their construction \nserves as a design check: odd spots in the language design usually manifest themselves as dif.\u00adculties \nin building or proving properties about the tool. This leads to a virtuous co-development cycle, or at \nleast forces the language designer to justify the inclusion of such dif.cult elements. A cynic might \nquestion why every language experiment de\u00adserves these tools. Because many of these languages will never \nsee widespread adoption, they may not be worth a signi.cant invest\u00adment of formal effort. To this, there \nare three counter-arguments: 1. A language may be intended for in-house use or only to solve a particularly \nvexing problem in some important system. Thus, the size of its user-base is not a good measure of signi.cance. \n 2. By the time a language becomes popular, it often already has frameworks, applications, or both, and \nhence already needs these tools. 3. Because tools are often vital to convincing users to employ the \nlanguage all the more given the physical distance between designer and user that the Web enables the \nabsence of such tools means promising language design experiments may never see the light of day.  Copyright \nis held by the author/owner(s). POPL 13, January 23 25, 2013, Rome, Italy. ACM 978-1-4503-1832-7/13/01. \nIt is therefore worth considering a research program that simultane\u00adously serves the democracy of languages \nwhile upholding the val\u00adues we hold dear, such as sound tools that are backed by theorems about their \nproperties.  The Challenges of Programming Languages Languages that developers use to write non-trivial \nprograms rarely resemble the elegant cores we formalize. To have direct impact, three semantics engineering \nquestions deserve special attention: 1. Beyond natural language speci.cations and de-facto normative \nimplementations, language designers increasingly provide con\u00adformance test suites. These suites are formal \nobjects (unlike natural language speci.cations), probably thoughtfully decom\u00adposed (unlike many implementations), \nand kept current (unlike many speci.cations). How can we ease the transition from con\u00adformance suites \nto formal semantics that match them? 2. Programs are increasingly a rich mix of code in a base language \nand code written atop frameworks. How can we formulate a semantics for the implicit languages of these \nAPIs? How do we determine the invariants of these languages, to check that base language programs don \nt violate them? 3. In practice, programs in one language often depend on pro\u00adgrams from other languages. \nWhile it is tempting to union the semantics of all these languages to reason about such programs, this \napproach usually leads to an intractable mess of details. Can we de.ne a family of semantics so that \nwe can zoom in to the appropriate level of detail? Can such a family accommodate both sound and tractable \ncross-language reasoning?  Going beyond core languages means also focusing on the needs of the users \nwho employ them. Because programming languages are a developer s primary human-computer interface, the \nhuman writing the programs deserves as much attention as the language. In principle, in a complex system \nwith mutual dependence, the two components must be co-designed; but when one of those compo\u00adnents is \na human, change can usually only be achieved at evolution\u00adary pace. Programming languages, and their \nenvironments, there\u00adfore need to better account for the established cognitive abilities and disabilities \nof their users. The democracy of languages means the future for program\u00adming language research is brighter \nthan ever. Furthermore, linguis\u00adtic thinking applies broadly and is in urgent need. My own group has \nspent the past decade applying a linguistic mindset and gener\u00adating some core results in return not only \nto traditional program\u00adming and speci.cation languages, but also to industrial access\u00adcontrol languages, \nWeb servers, Web browsers, Excel spreadsheets, Internet routers and .rewalls, social networks, and Alice-and-Bob \ncryptographic diagrams. In all these areas, and more, there is a great need for the clarity and focus \non primitives and composition that is characteristic of programming languages thought.  \n\t\t\t", "proc_id": "2429069", "abstract": "", "authors": [{"name": "Shriram Krishnamurthi", "author_profile_id": "81100512233", "affiliation": "Brown University, Providence, RI, USA", "person_id": "P3978025", "email_address": "sk@cs.brown.edu", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429097", "year": "2013", "article_id": "2429097", "conference": "POPL", "title": "From principles to programming languages (and back)", "url": "http://dl.acm.org/citation.cfm?id=2429097"}