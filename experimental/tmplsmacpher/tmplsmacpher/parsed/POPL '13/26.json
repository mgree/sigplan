{"article_publication_date": "01-23-2013", "fulltext": "\n How Languages Can Save Distributed Computing Andrew C. Myers Department of Computer Science Cornell \nUniversity Ithaca, New York, United States andru@cs.cornell.edu 1. Current abstractions are failing \nus Current networked computing platforms make available to users an immense and growing amount of computing \npower and storage. This should be an exciting time for computing, and it is. To users, it might seem \nan in.nitely powerful Internet Computer exists with a manifestation on each of their several computing \ndevices. However, distributed applications are still relatively primitive and unreliable; they are too \ncentralized on clusters provisioned by individual organizations; users .nd it hard to share code or even \ndata without opening themselves up to attacks. The grit in the gears of progress is the dif.culty of \nbuilding applications for the Internet Computer. Our programming mod\u00adels are simply too dif.cult and \nlow-level for programmers to use effectively. We need higher-level programming models and pro\u00adgramming \nlanguages that get us closer to programming the Internet Computer directly. The software stack Industry-standard \nprogramming models in\u00advolve developing the application logic in a programming language such as Java. \n(The situation is not very different in most other pro\u00adgramming languages, except that library and tool \nsupport are typ\u00adically weaker.) This application logic sits atop a large stack of ab\u00adstractions, whose \nabbreviations seem to proliferate: SQL, HTTP, EJB, RMI, XML, AJAX, SOAP, JSON, etc. Because these abstrac\u00adtions \ndon t hide the software layers below, applications must be written in a way that is aware of too much \nof the stack. This struc\u00adture makes the application complex and unreliable, and more likely to have security \nvulnerabilities. Further, as it .lters through these layers, information within the program is transformed \nthrough mul\u00adtiple representations as it migrates from persistent storage to remote clients and back, \ncreating fragility and inef.ciency. Of course, there are reasons why the software stack has evolved to \nthis complex state. Distributed programs must handle distributed code and data securely and ef.ciently. \nThey usually span multiple domains of trust: a user client and a server, at least, though ap- Categories \nand Subject Descriptors D.3.2 [Programming Lan\u00adguages]: Language Classi.cations Concurrent, distributed, \nand parallel languages; D.4.6 [Operating Systems]: Security and Protection inform\u00adation .ow controls \nKeywords security, information .ow, abstractions Copyright is held by the author/owner(s). POPL 13, January \n23 25, 2013, Rome, Italy. ACM 978-1-4503-1832-7/13/01. plications that bring together information and \ncode from multiple domains are becoming more common. If past history is any guide, industry will keep \nincrementally adding new layers to the software stack. On the current trajectory, our computers will \nbecome increasingly dif.cult and unpleasant to program, and less secure. Something better is needed, \nand lan\u00adguages can help. 2. A higher-level abstraction: Fabric In Fabric [1, 6], we have been exploring \na very different approach to building distributed applications, centered around a high-level programming \nlanguage in which code and data can be used in a uni\u00adform and transparent way, regardless of where that \ncode and data is located on the network. Objects at the language level may be per\u00adsisted at remote nodes \nin the network. Analogously to the current use of JavaScript, the code for those objects may be located \nat re\u00admote, untrusted nodes and dynamically loaded by the using node. Dynamic loading is important because \nwe want to (securely) sup\u00adport the kinds of activities already common in the web ecosystem, in which \nprogrammers share and swap code and data freely. There are two challenges in realizing this vision: .rst, \nto de\u00advelop a programming model that in an abstract way exposes to the programmer the underlying systems \nissues: persistence, distribu\u00adtion, failure, and security. Second, to realize this model in an imple\u00admentation \nthat, even in a completely decentralized system, respects the properties that the language-level abstraction \npurports to offer. These properties can easily be in tension with each other. For ex\u00adample, the distributed \nprotocols needed to ensure consistency can easily enable distrusted participants to infer con.dential \ninforma\u00adtion. The language abstraction The Fabric programming language closely resembles Java, but differs \nin some important respects. Similarly to the Jif programming language [7], it adds infor\u00ad mation security \nannotations that specify the con.dentiality and integrity of information manipulated by the program. \nThe secu\u00adrity of the system is enforced both statically and dynamically by using these policies to control \ninformation .ow. Fabric goes beyond Jif by adding annotations that control new attacks on con.dentiality \nand integrity that arise in a distributed setting: covert channels created by requests for remote objects, \nand at\u00adtacks on integrity that might be launched by downloaded mobile code.  All information, including \ndistributed and persistent data and code, is presented to the programmer as language-level objects. The \nsystem automatically takes care of caching, migrating, and persisting these objects to support ef.cient, \nsecure, consistent execution. There is no need to have a relational database as part of the software \nstack.   Distribution is exposed explicitly to the programmer through annotations on constructors \nand method calls that indicate where allocation or computation, respectively, should occur. For example, \na method call o.m@n() transfers control to net\u00adwork node n to run the code.  The consistency and durability \nof computations of these dis\u00adtributed, persistent objects is supported by a language-level transaction \nmechanism. The statement atomic {S} executes statement S as though in isolation from everything else \nhap\u00adpening on the network, even when S contains distributed com\u00adputation.  Implementing the abstraction \nFabric aims to provide this high\u00adlevel programming abstraction, yet with an implementation that runs \ncode securely and ef.ciently on a completely decentralized collection of nodes. The threat model is similar \nto that of the web, so malicious nodes are assumed to be part of Fabric and to be able to join and then \nprovide code and data to other nodes. The Fab\u00adric compiler and run-time system together ensure that information \ndoes .ow to any node that is not trusted to enforce its con.dential\u00adity policy, and that information \ndoes not .ow from any node that is not trusted to enforce its integrity policy. The inherent composition\u00adality \nof information .ow control then ensures that all information .ows across the distributed system respect \nthe information security policies, even though these policies are interpreted and enforced in a decentralized \nway. Cooperation between nodes requires explicit trust, so informa\u00adtion security policies are expressed \nin terms of principals. Nodes are principals in Fabric, and like all other principals, are represented \nby objects that can describe their trust in other principals. Complex trust relationships can thus be \nexpressed, enabling enforcement of complex information security controls. Nodes serve three roles in \nFabric: as workers, which do compu\u00adtation over cached copies of objects persistently stored elsewhere; \nas stores, which record the authoritative versions of persistent ob\u00adjects and ensure durability; and \nas dissemination nodes, which make object data highly available. These different kinds of nodes support \na variety of different distributed architectures, including web-like client server structures, but also \nmore general structures, such as clients that directly interact or clients that use information and code \nfrom multiple servers. Fabric works differently from middleware systems such as RMI or CORBA because \nworker nodes cache copies of remote objects rather than representing remote objects as proxies. This \nimplemen\u00adtation choice is important for security and for performance. Exe\u00adcution stays on the current \nnode unless there is an explicit trans\u00adfer of control through a remote method call. Computing on object \ncopies means that remote nodes do not learn when objects they store are used. A hierarchical two-phase \ncommit protocol ensures consistency while protecting the con.dentiality and integrity of in\u00adformation \nfrom untrusted participants. The prototype implementation of Fabric is publicly avail\u00adable [5]. 3. Conclusions \nThe Fabric project is developing a new language and system to support the kinds of activities now happening \non the web: the free exchange of code and data across a decentralized, distributed system. Fabric eliminates \nmuch of the complexity of the current web-based distributed programming model, by raising the level of \nabstraction at which applications are developed. This makes the resulting system simpler overall, by \neliminating software layers and data conversions that are not essential to application functionality. \nBy exposing security considerations in information .ow policies, it supports secure composition of code \nand data from different trust domains. Fabric is one approach to raising the level of abstraction, and \nclearly could be extended usefully in various ways. There have been several other recent language-based \nattempts to raise the level of abstraction for programming distributed systems, particularly for web \napplications [2 4, 8]. Some of these show that the Fabric ab\u00ad straction is not the only candidate for \nan effective high-level pro\u00adgramming abstraction. For example, abstractions centered around streams are \nlikely to be useful for some applications. If we are to obtain a clean, high-level language-level abstraction \nfor programming future distributed computing systems, it is to be hoped that the programming language \ncommunity will be involved. However, this will require that language researchers confront some traditionally \nsystems issues such as persistence, distribution, and security, and to develop effective abstractions \nfor handling these issues. To program the Internet Computer, programming-language research will need \nto break out of its abstraction layer. References [1] Owen Arden, Michael D. George, Jed Liu, K. Vikram, \nAslan Askarov, and Andrew C. Myers. Sharing mobile code securely with information .ow control. In Proc. \nIEEE Symposium on Security and Privacy, pages 191 205, May 2012. [2] Adam Chlipala. Static checking of \ndynamically-varying security poli\u00adcies in database-backed applications. In Proc. 9th USENIX Symp. on \nOperating Systems Design and Implementation (OSDI), October 2010. [3] Stephen Chong, Jed Liu, Andrew \nC. Myers, Xin Qi, K. Vikram, Lan\u00adtian Zheng, and Xin Zheng. Secure web applications via automatic partitioning. \nIn Proc. 21st ACM Symp. on Operating System Principles (SOSP), October 2007. [4] Ezra Cooper, Sam Lindley, \nPhilip Wadler, and Jeremy Yallop. Links: Web programming without tiers. In Proc. 5th International Symposium \non Formal Methods for Components and Objects, November 2006. [5] Jed Liu, Owen Arden, Michael D. George, \nK. Vikram, and Andrew C. Myers. Fabric 0.2. Software release, http://www.cs.cornell.edu/projects/fabric, \nOctober 2012. [6] Jed Liu, Michael D. George, K. Vikram, Xin Qi, Lucas Waye, and An\u00addrew C. Myers. Fabric: \nA platform for secure distributed computation and storage. In Proc. 22nd ACM Symp. on Operating System \nPrinciples (SOSP), pages 321 334, 2009. [7] Andrew C. Myers, Lantian Zheng, Steve Zdancewic, Stephen \nChong, and Nathaniel Nystrom. Jif 3.0: Java information .ow. Software release, http://www.cs.cornell.edu/jif, \nJuly 2006. [8] M. Serrano, E. Gallesio, and F. Loitsch. HOP, a language for program\u00adming the Web 2.0. \nIn Proc. 1st Dynamic Languages Symposium, pages 975 985, October 2006.  \n\t\t\t", "proc_id": "2429069", "abstract": "", "authors": [{"name": "Andrew C. Myers", "author_profile_id": "81100011022", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P3977975", "email_address": "andru@cs.cornell.edu", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429107", "year": "2013", "article_id": "2429107", "conference": "POPL", "title": "How languages can save distributed computing", "url": "http://dl.acm.org/citation.cfm?id=2429107"}