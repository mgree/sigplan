{"article_publication_date": "01-23-2013", "fulltext": "\n Abstraction and Invariance for Algebraically Indexed Types Robert Atkey Patricia Johann University \nof Strathclyde {Robert.Atkey,Patricia.Johann}@strath.ac.uk Abstract Reynolds relational parametricity \nprovides a powerful way to rea\u00adson about programs in terms of invariance under changes of data representation. \nA dazzling array of applications of Reynolds the\u00adory exists, exploiting invariance to yield free theorems \n, non\u00adinhabitation results, and encodings of algebraic datatypes. Outside computer science, invariance \nis a common theme running through many areas of mathematics and physics. For example, the area of a triangle \nis unaltered by rotation or .ipping. If we scale a trian\u00adgle, then we scale its area, maintaining an \ninvariant relationship be\u00adtween the two. The transformations under which properties are in\u00advariant are \noften organised into groups, with the algebraic structure re.ecting the composability and invertibility \nof transformations. In this paper, we investigate programming languages whose types are indexed by algebraic \nstructures such as groups of ge\u00adometric transformations. Other examples include types indexed by principals \nfor information .ow security and types indexed by distances for analysis of analytic uniform continuity \nproperties. Following Reynolds, we prove a general Abstraction Theorem that covers all these instances. \nConsequences of our Abstraction Theo\u00adrem include free theorems expressing invariance properties of pro\u00adgrams, \ntype isomorphisms based on invariance properties, and non\u00adde.nability results indicating when certain \nalgebraically indexed types are uninhabited or only inhabited by trivial programs. We have fully formalised \nour framework and most examples in Coq. Categories and Subject Descriptors D.1.1 [Programming tech\u00adniques]: \nApplicative (functional) programming; D.2.4 [Software Engineering]: Software/Program Veri.cation; D.3.3 \n[Program\u00adming Languages]: Language Constructs and Features Data types and structures General Terms Languages, \nTheory, Types Keywords parametricity, units of measure, dimensional analy\u00adsis, invariance, computational \ngeometry, information .ow, metric types, uniform continuity 1. Introduction The best way we know of describing \nthe semantics of parametric polymorphism is relational parametricity, whose central result is Reynolds \nAbstraction Theorem [18]. Its striking consequences in\u00ad clude the well-known free theorems for polymorphic \ntypes [22], Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n13, January 23 25, 2013, Rome, Italy. Copyright c &#38;#169; 2013 ACM 978-1-4503-1832-7/13/01. . . $15.00 \nAndrew Kennedy Microsoft Research Cambridge akenn@microsoft.com non-inhabitation results, and precise \ncorrespondences between Sys\u00adtem F encodings and algebraic datatypes [16], abstract data types, and, most \nrecently, higher-order encodings of binder syntax [2]. Relational parametricity is in essence a principle \nof invariance: the behaviour of polymorphic code is invariant under changes of data representation. For \nexample, the type .a.list(a) . list(a) tells us that any transformation applied to elements of the input \nlist will be re.ected by the same transformation applied to elements of the result. Invariance results \nalso abound in mathe\u00admatics and physics. The area of a triangle is invariant with respect to isometries \nof the Euclidean plane; the determinant of a matrix is invariant under changes of basis; and Newton s \nlaws are the same in all inertial frames. Typically, the transformations under which invariants are preserved \nhave interesting structure: for example, translations in the Euclidean plane form an abelian group. Inspired \nby this connection, we study type systems that cap\u00adture rich invariants in types indexed by attributes \nwith algebraic structure. For example, in computational geometry, points in the plane can be indexed \nby attributes representing af.ne transforma\u00adtions; in information-.ow security, computations can be indexed \nby principals; in differential privacy, types can be indexed by dis\u00adtance . Types that are polymorphic \nover such indices induce invari\u00adance properties and abstraction barriers beyond those introduced by their \nunindexed versions, as we shall illustrate. This generalises previous work by the third author on types \nparameterized by units of measure, whose invariance properties relate to changes of units, or scaling \n[13]. Invariance To illustrate type-induced invariance properties, con\u00adsider two-dimensional geometry. \nIn a conventional type system, a function areaTri that computes the area of a triangle might be as\u00adsigned \nthe type: vec \u00d7 vec \u00d7 vec . real. But in our proposed system we can assign it the following more expressive \npolymorphic type: areaTri : .t:T2.vec(t) \u00d7 vec(t) \u00d7 vec(t) . real This type expresses the fact that \nif each of the arguments to areaTri is translated by the same vector, then the result remains the same, \nthat is, it is invariant under translation. Formally, for any vector vt, areaTri (vt + vv1,vt + vv2,vt \n+ vv3) = areaTri (vv1, vv2, vv3) Transformations typically compose in various ways, and the compositions \nsatisfy algebraic laws. For example, we can assign a function that computes the area of a circle given \nits radius the following polymorphic type: areaCircle : .s:GL1.real(s) . real(s \u00b7 s) This captures the \nfact that the area of a circle varies as the square of its radius, i.e., areaCircle(kr) = k2 \u00b7 areaCircle(r) \nfor any k= 0 (the sorts T2 and GL1 will be explained later). Here, s can be interpreted as the units \nof measure of the argument to areaCircle, and \u00b7 composes units using the product. We can also add an \ninverse operation and identity unit of measure 1, and then impose the algebraic laws of abelian groups. \nThis permits identi.cation of, for example, real(s \u00b7s -1) with the type real(1) of dimensionless constants. \n Abstraction In his original paper on parametricity, Reynolds as\u00adserted that type structure is a syntactic \ndiscipline for enforcing lev\u00adels of abstraction. We see something analogous here: if all primitive operations \nare given types that re.ect their behaviour under trans\u00adlation, then there is no way to break this property. \nFor example, there is no way that areaTri can depend on the actual coordinates of its inputs. Furthermore, \nthe distinction between points and vec\u00adtors that is often enforced through abstract data types [7] is \ncap\u00ad tured here by indices instead. For example, the operation that takes two points and computes their \nvector difference can be assigned the type .t:T2.vec(t) \u00d7 vec(t) . vec(0), re.ecting the invariance of \nthe result (a pure vector) under translations of the point arguments. As a result through types alone \nwe can, in essence, derive so-called coordinate-free geometry [15]. The invariance properties discussed \nabove can be seen as free theorems [22], but the abstraction afforded by polymorphic in\u00ad dexed types \ncan also induce interesting type isomorphisms. The type of areaCircle above is in fact isomorphic to \nreal(1). A mo\u00adment s thought reveals why: what possible unary functions can be constructed whose outputs \nscale as the square of the scaling of their inputs? Answer: just those functions of the form .x.kx2 for \nsome constant k. In this case, of course, we expect that k = p. Relational parametricity To derive such \ninvariance and abstrac\u00adtion properties of types, we adopt the techniques of relational para\u00admetricity. \nOver an underlying index-erasure semantics we construct binary relations parameterised by an environment \n. that describes how values of primitive type are related according to their indices. For example, values \nv and w of type real(s) are related when v scales to w according to an interpretation of s (i.e., w = \n.(s)\u00b7v). Values of polymorphic type are related exactly when they are re\u00adlated for all possible interpretations \nof the quanti.ed variable. For example, values v and w of type .t:T2.vec(t) . vec(t) are re\u00adlated when \nthey are related at type vec(t) . vec(t) for all trans\u00adlations vt . T2 associated with t. As it happens, \nthe relational interpretations given above are functional, relating one value uniquely to another. Other \nap\u00adplications make use of primitive relations that are not simple functions. For example, in a type system \nin which the index in real(s) is interpreted not as a unit of measure, but as a mea\u00adsure of closeness, \ntwo values x and y of this type are related if |x - y| < .(s) for a positive real number .(s). Rather \nbeautifully, the standard notion of uniform continuity can then be expressed as .E:R>0 . .d:R>0 . real(d) \n. real(E). Motivations Our motivations for studying algebraically indexed types are threefold. First, \nwe believe that, as with units of mea\u00adsure [14], practical programming language extensions will follow. \nFor example, in computational geometry and graphics, attributes on points, vectors, and other geometric \ntypes could be used to prevent the mixing of different coordinate systems, or frames . Second, type-based \nstatic analyses can be based on indexed types, for ex\u00adample, in effect systems [4], and, more speculatively, \nin continuity analysis [8]. Finally, we believe that expressing algebraic invari\u00ad ants through types \nhas the potential to offer slick proof techniques for mechanized mathematics. Harrison has applied the \ninvariance properties of geometric primitives to create elegant proofs in ge\u00adometry, based on without \nloss of generality principles [10]. The invariance properties are expressed and propagated using ad-hoc \ntactics; our types offer a more principled means of achieving the same end, and the wlog principle itself \nis expressed through type isomorphisms. Algebraic Index-Erasure Relational + + Theory Interpretation \nInterpretation  Free Type Non-de.nability Theorems Isomorphisms Figure 1. Summary of the Paper We \nfollow the mantra semantics .rst, syntax later in studying types with algebraic structure. We have not \nyet built a practical pro\u00adgramming language that supports algebraically indexed types; nor have we designed \ntype checking, type inference, or static analysis algorithms. But when we do so, the semantics will guide \nus. The fact that zero is polymorphic in units of measure (it can be given type .u.real(u)) whereas other \nconstants are dimensionless (hav\u00ading type real(1)) is justi.ed by the invariance properties induced by \nthe types: zero is invariant under scaling, other constants are not. For less trivial constants and operations, \nthe appropriate types are not so apparent, as we shall see, but invariance properties expressed by the \nsemantics guide us in assigning appropriate types. Semantics does not lie! 1.1 Contributions This paper \nmakes the following speci.c contributions: We present a collection of compelling examples of algebraically \nindexed types, including a novel type system for geometry, a re.ned type system for information .ow based \non logic, and a simple type system with distance-indexed types.  We formulate a type system that can \neither be used as a pro\u00adgramming language in its own right, or as the target of type\u00adbased analyses. \nThe type system consists of the usual type con\u00adstructors together with a collection of indexed primitive \ntypes, universal and existential quanti.cation over the indices, and a multi-sorted equational theory \nfor indices.  We describe a relational semantics for the type system and prove an analogue of Reynolds \nAbstraction Theorem, for a given model of index sorts and relational interpretation of prim\u00aditive types. \nWe prove that the semantics soundly approximates contextual equivalence.  For each of our main examples \nwe deduce free theorems that are consequences of our Abstraction Theorem, prove speci.c non\u00adde.nability \nresults, and derive interesting type isomorphisms. For a large class of .rst-order types we give a general \nmethod for constructing suitable models to prove non-de.nability re\u00adsults. Figure 1 illustrates the central \nposition of our analogue of Reynolds Abstraction Theorem (Theorem 1) in these results.  We improve \non the earlier semantics of units of measure [13] in a number of ways. By extending the language of units \nwith an ab\u00adsolute value operation, we can give more precise types and obtain more general invariance \nproperties. The relational interpretation for units is both simpler and more .exible, and we derive slicker \nproofs of non-de.nability, and new results. Our notion of type isomor\u00adphism is stronger than before, \nbeing based on contextual equiva\u00adlence. We have fully formalised our framework and most examples in \nCoq, using strongly-typed term representations throughout [3]. The formalisation is available from https://github.com/bobatkey/algebraically-indexed-types \n  1.2 Structure of paper Our paper is structured as follows. In Section 2 we present an ex\u00adtended case \nstudy of two-dimensional geometry, with semi-formal description of types and results. In Section 3 we \ndescribe fully formally a general framework for algebraically-indexed types, and prove the Abstraction \nTheorem and soundness for semantic equiv\u00adalence. Section 4 presents a number of applications of the theory \nto 2-d geometry, including free theorems, type isomorphisms and non-de.nability. Section 5 develops a \nmore general technique for proving non-de.nability results. Section 6 presents the application of algebraically \nindexed types to information .ow security, and Section 7 applies it to types indexed by distances. Finally, \nSection 8 discusses related work and future plans. 2. Geometry via Algebraically Indexed Types We motivate \nour investigation of algebraically indexed types and their relational interpretations by developing a \nnovel type system for programs that manipulate two-dimensional geometric data. Ge\u00adometry is rich with \noperations that are invariant under transforma\u00adtion: af.ne operations are invariant under change of origin \n(Sec\u00ad tion 2.3), vector space operations are invariant under change of ba\u00adsis, and dot product is invariant \nunder orthogonal changes of basis (Section 2.4). On the other hand, some geometric operations are in\u00adterestingly \nvariant under transformation. For example, cross prod\u00aducts vary with scalings of the plane (Section 2.5). \nWe incorporate (in)variance information about geometric primitives into type sys\u00adtems via algebraically \nindexed types. 2.1 Origin Invariance and Representation Independence The basic data structure used in \nprograms that manipulate geomet\u00adric data is the n-tuple of numbers. In the 2-dimensional case, tuples \nv = (x, y) serve double duty, representing both points offsets from some origin and vectors offsets in \ntheir own right. Despite their common representation, points and vectors are very different, and distinguishing \nbetween them is the key feature of af.ne geom\u00adetry (see, for example, Chapter 2 of Gallier s book [9]). \nNeverthe\u00adless, computational geometry libraries traditionally either leave it to the programmer to maintain \nthe distinction between points and vectors, or else use different abstract types for points and vectors \nto enforce it. In this paper we investigate a more sophisticated ap\u00adproach based on types indexed by \nchange of origin transformations. This approach regards the difference between points and vec\u00adtors as \na change of data representation. For example, if (0, 0) and (10, 20) are two origins, then the tuple \n(1, 1) with respect to (0, 0) and the tuple (11, 21) with respect to (10, 20) represent the same point \nbecause they have the same displacement from these two origins, respectively. This suggests that programs \nthat manipulate points should be invariant with respect to changes of origin. Pro\u00adgrams that manipulate \nvectors, on the other hand, should not be invariant under change of origin. Different vectors represent \ndiffer\u00adent offsets, and the vector (0, 0) always represents the zero offset. Invariance under change \nof representation immediately recalls Reynolds fable about two professors teaching the theory of com\u00adplex \nnumbers [18]. One professor represents complex numbers us\u00ading rectangular coordinates (x+iy), while the \nother represents them using polar coordinates (a cos . + ia sin .). Happily, after learning the basic \noperations on complex numbers in the two representa\u00adtions, the two classes can interact because the theory \nof complex numbers is invariant under the choice of representation. Reynolds formalises the idea of invariance \nunder changes of representation as preservation of relations. For example, if a binary relation R relates \nthe rectangular and polar representations of complex numbers, then a program that manipulates complex \nnumbers at a level of abstrac\u00adtion above their speci.c representation should preserve R. Reynolds relational \napproach can be applied in the geometric setting to show how quantifying over all changes of origin ensures \nthe invariance of programs under any particular choice of origin. For this, we .rst de.ne a family of \nbinary relations on R2 that is indexed by changes of origin. Changes of origin are represented by vectors \nin R2 , and form a group T2 of translations under addition. The T2-indexed family of binary relations \n{Rr. R2 \u00d7 R2}r t t.T2 is then de.ned by Rr= {(v , vv1) | vv1 = v + vt}. We then consider a t function \nf that takes as input two tuples in R2 and returns a single tuple in R2 . We intend that the tuples all \nrepresent points with respect to the same origin, and that f is invariant under the choice of origin. \nReynolds relational approach formalises this intention precisely. For any vt . T2: v1v11v1 .(v 1, v, \n(v 2, v.(f(v 1, v 2), f (vvv)) . Rr(1) 1) . Rrt 2) . Rrt 1, 2 t Unfolding the de.nition of Rrt gives \nthe equivalent formulation, again for all vt . T2: .v 1, v 2. f(v 1 + vt, v 2 + vt) = f(v 1, v 2) + vt. \n(2) Thus, Reynolds preservation of relations, when instantiated with the family of relations {Rr}, yields \nexactly the geometric property t of invariance under change of origin. 2.2 A Type System for Change \nof Origin Invariance Reynolds also showed how a type discipline can be used to estab\u00adlish that (the denotational \ninterpretations of) programs preserve re\u00adlations. For Reynolds, the type discipline of interest was that \nof the polymorphic .-calculus, which supports the construction of new types by universal quanti.cation \nover types. In terms of relations, Reynolds interprets universal quanti.cation over types as quanti.\u00adcation \nover binary relations between denotations of types. By con\u00adtrast, in our statements of geometric invariance \nin Section 2.1 we did not quantify over all relations, but instead quanti.ed over all changes of origin \nand used a speci.c choice of origin to select a relation from the family {Rr}. This suggests introducing \nquanti.\u00ad t cation over changes of origin into the language of types. We use the notation .t:T2.A for \nquanti.cation over all 2-dimensional transla\u00adtions (i.e., choices of origin) t, and refer to T2 as the \nsort of t. Note the difference in fonts used to distinguish the semantic group T2 from the syntactic \nsort T2. We use a similar convention below, too. Since the sort T2 represents an abelian group, we can \ncombine its elements using the usual group operations. We write operations additively, using e1 +e2 for \nthe group operation, -e for inverse and 0 for the unit. We also regard expressions built from variables \nand the group operations up to the abelian group axioms. For example, we regard e1 + (e2 + e3) and (e1 \n+ e2) + e3 as equivalent. Our language of types includes the unit type unit and, for all types A and \nB, the function type A . B, the sum type A + B, and the tuple type A \u00d7 B. We also assume a primitive \ntype real, used to represent scalars. Although tuples of real numbers represent points and vectors in \ngeometric applications, we cannot express this via the type real \u00d7 real. Indeed, two elements of type \nreal are related if and only if they are equal and, by Reynolds interpretation of tuple types, two elements \nof real \u00d7 real are also related if and only if they are equal. But since this does not give the correct \nrelational interpretations for points and vectors, we introduce a new type vec(e), indexed by expressions \ne of sort T2, to represent them. The index e represents the displacement by change of origin of a point \nof this type. Although we have taken pains to distinguish geometric points and vectors, we use the name \nvec for both to recall the computer science notion of vector as a homogeneous sequence of values with \na known length (in this case, 2). As is standard for parametricity, every type has two interpreta\u00adtions: \nan index-erasure interpretation that ignores the indexing ex\u00adpression, and a relational interpretation \nas a binary relation on the index-erasure interpretation. We denote the index-erasure and re\u00adlational \ninterpretations with the notations L\u00b7J and [\u00b7] respectively. To give such interpretations for the types \nvec(e) and .t:T2.A, we assume for now that we can map each expression e of sort T2 to an element [e]. \nof the group T2 using some environment . that interprets e s free variables. The index-erasure and relational \ninter\u00adpretations of vec(e) are: R2 Lvec(e)J = [vec(e)]. = R[e]. = {(v , vv1) | vv1 = v + [e].} The index-erasure \nand relational interpretations of .t:T2.A are: L.t:T2.AJ = LAJ [.t:T2.A]. ={[A](.,vt) | vt . T2} The \nindex-erasure and relational interpretations are given formally in Sections 3.3 and 3.4. At the end of \nSection 2.1 we considered functions f : R2 \u00d7 R2 . R2 that preserve all changes of origin. This property \nof f can be expressed in terms of types by f : .t:T2. vec(t)\u00d7vec(t) . vec(t). Spelling out the relational \ninterpretation of this type using the de.nitions above and the standard relational interpretations for \ntuple and function types, we recover Statement 2 exactly.  2.3 Af.ne and Vector Operations Invariance \nunder change of origin is the key feature of af.ne geom\u00adetry, whose central operation is the af.ne combination \nof points: .1 v 1 + .2 v 2, where .1 + .2 = 1. Geometrically, this can be in\u00adterpreted as describing \nall the points on the unique line through the points represented by v 1 and v 2 (assuming v 1 = v 2). \nWe add af.ne combination of points to our calculus as follows: a.Comb : .t:T2. vec(t) . real . vec(t) \n. vec(t) La.CombJ v 1 r v 2 = (1 - r)v 1 + rv 2 It can be veri.ed by hand that the index-erasure interpretation \nLa.CombJ is invariant under all changes of origin, as dictated by its type. Example 1. The evaluation \nof quadratic B\u00b4ezier curves (B\u00b4ezier curves with two endpoints and a single control point) can be ex\u00adpressed \nusing the af.ne combination primitive as follows: quadB\u00b4ezier : .t:T2. vec(t).vec(t).vec(t).real.vec(t)quadB\u00b4ezier \n[t] p0 p1 p2 s = a.Comb [t] (a.Comb [t] p0 s p1) s (a.Comb [t] p1 s p2) For two endpoints p0 and p2, \na control point p1, and s . [0, 1], an application quadB\u00b4ezier p0 p1 p2 s gives the point on the curve \nat time s. The type of quadB\u00b4ezier immediately tells us that it preserves all changes of origin. The \nobvious type for vector addition is (+) : vec(0) . vec(0) . vec(0). But we can re.ect the fact that (+) \nis not invariant under change of origin by giving it a more precise type that re.ects how it varies with \nchange of origin: (+) : .t1, t2:T2. vec(t1) . vec(t2) . vec(t1 + t2) Intuitively, this type says that \nif the .rst input vector has been displaced by t1 and the second by t2, then their sum is displaced by \nt1 + t2. We can also negate vectors, yielding a vector which points in the opposite direction. Negation \nnegates translation arguments: negate : .t:T2. vec(t) . vec(-t) Finally, with the primitive operations \nof addition and negation of vectors we can de.ne the derived operation of subtraction: (-) : .t1, t2:T2. \nvec(t1) . vec(t2) . vec(t1 - t2) (-) [t1] [t2] p1 p2 = p1 + negate p2 Given two points that are invariant \nwith respect to the same change of origin i.e., two values of type vec(t) we can use subtraction to compute \ntheir offset: o.set : .t:T2. vec(t) . vec(t) . vec(0) o.set [t] p1 p2 = p1 - p2 The result is a vector \nexpressed with respect to the null change of origin: note how the algebraic structure on the indexing \ntheory induces type equalities that can be used to simplify the type of the result of o.set from vec(t-t) \nto vec(0). The type of (+) can also be specialised to the case of moving a point by a vector: moveBy \n: .t:T2. vec(t) . vec(0) . vec(t) moveBy [t] p v = p + v The types we assign to the remaining vector \nspace primitives, namely 0 : vec(0) for the zero vector and (*) : real . vec(0) . vec(0) for multiplication \nby a scalar, do not describe any interest\u00ading effects on translations. Example 2. The vector space operators \nand the properties that fol\u00adlow from their types allow us to establish a useful type isomor\u00adphism. Consider \nfunctions with types following the schema: def tn = .t:T2. vec(t) . ... . vec(t). real n+1 times Just \nby looking at the types tn, we know that their inhabitants will be invariant under change of origin because \nof the quanti.cation over all t in T2. So we may as well choose one of the input points as the origin \nand assume that all the other points are de.ned with respect to it. This formalises the common mathematical \npractice of stating that without loss of generality we can take some point in a description of a problem \nto be the origin provided the problem statement is invariant under translation. Each type tn is isomorphic \nto the corresponding type sn: def sn = vec(0) . ...vec(0). real n times We demonstrate these isomorphisms \nformally in Section 4, in the more general setting of types indexed by abelian groups. Example 3. So \nfar we have emphasised the derivation of prop\u00aderties, or free theorems , of programs from their types. \nBut us\u00ading more re.ned relational interpretations of types we can also show that certain types are uninhabited. \nFor example, the type .t:T2. vec(t + t) . vec(t) has no inhabitants. Intuitively, this is because we \ncannot remove the extra t in vec(t + t) using the vector operations. We formalise this non-de.nability \nresult in Sec\u00ad tion 5 using a specialised relational interpretation. 2.4 Change of Basis Invariance \nAlthough vector addition, negation, and scaling are not invariant under change of origin, they are invariant \nunder change of basis. As with origin invariance, we can express basis invariance as preser\u00advation of \nrelations indexed by changes of basis. Change of basis is achieved by applying an invertible linear map, \nand the collec\u00adtion of all such maps on R2 forms the General Linear group GL2, which we represent in \nour language by a new indexing sort GL2 with (non-abelian) group structure that we will write multiplica\u00adtively. \nWe then extend vec to allow indices of sort GL2, as well as T2, so that vec(B, t) is a vector that varies \nwith change of basis B 0 : .s:GL1. real(s) 1 : real(1)(+) : .s:GL1. real(s) . real(s) . real(s)(-) : \n.s:GL1. real(s) . real(s) . real(s) (*) : .s1, s2:GL1. real(s1) . real(s2) . real(s1s2)(/) : .s1, s2:GL1. \nreal(s1) . real(s2) . real(s1s -1) + unit 2 abs : .s:GL1. real(s) . real(|s|) Figure 2. Operations on \nscaled real numbers and change of origin t. Formally, the index-erasure and relational semantics of vec(B, \nt) are given by: Lvec(eB , et)J = R2 [vec(eB, et)]. = {(v , vv1) | vv1 = ([eB].)v + [et].} Af.ne Geometry \nAn af.ne transformation is an invertible linear map together with a translation. We can assign types \nto all the primitive af.ne and vector space operations indicating how they they behave with respect to \naf.ne transformations: a.Comb : .B:GL2, t:T2. (+) : vec(B, t) . real . vec(B, t) . vec(B, t).B:GL2, t1, \nt2:T2. negate 0 (*) : : : vec(B, t1) . vec(B, t2) . vec(B, t1 + t2).B:GL2, t:T2. vec(B, t) . vec(B, -t).B:GL2. \nvec(B, 0).B:GL2. real . vec(B, 0) . vec(B, 0) Euclidean Geometry Euclidean geometry extends af.ne geome\u00adtry \nwith the dot product, or inner product, operation of two vectors. The dot product is de.ned by (x1, y1)\u00b7(x2, \ny2) = x1x2 +y1y2. To assign it a type we note that, although dot product is not invariant under GL2 or \nT2, it is invariant under the subgroup O2 of GL2 of orthogonal linear transformations, i.e., the subgroup \nof invertible linear maps whose matrix representations transposes are equal to their inverses. We thus \nintroduce a new sort O2 of orthogonal trans\u00adformations, and overload the multiplicative group operations \nfor in\u00adhabitants of O2. Further assuming an injection .O that takes e : O2 to .O(e) : GL2 we assign dot \nproduct this type: (\u00b7) : .O:O2. vec(.OO, 0) . vec(.OO, 0) . real The cross product of two vectors is \nde.ned on coordinate rep\u00adresentations as (x1, y1) \u00d7 (x2, y2) = x1y2 - x2y1. Geometrically, the cross \nproduct is the signed area of the parallelogram described by the pair of input vectors. Under change \nof basis by an invertible linear transformation B, the cross product of two vectors varies with the determinant \nof B. This corresponds to scaling the plane by the change of basis transformation, so we augment our \ncalculus with a new sort GL1 of scale factors (i.e., 1-dimensional invertible linear maps). Semantically, \nGL1 ranges over the non-zero real num\u00adbers and forms an abelian group which we write multiplicatively. \nWe also add two new operations: determinant, det B, which takes an inhabitant of GL2 to its determinant \nin GL1, and absolute value, |e|, which takes scaling factors to scaling factors. We also re.ne the type \nreal of real numbers so that it is indexed by the sort GL1: real(e). The old type real is then just real(1), \nand the full col\u00adlection of operations on real numbers indexed by scaling factors is shown in Figure \n2. We can thus assign cross product the type: (\u00d7) : .B:GL2. vec(B, 0) . vec(B, 0) . real(det B) Since \nthe absolute value of the determinant of an orthogonal trans\u00adformation is always 1, we assume |det(.OO)| \n= 1 to hold for any O . O2. Example 4. We can use the operations of this subsection to com\u00adpute the area \nof a triangle. We have: area : .B:GL2, t:T2. vec(B, t) . vec(B, t) . vec(B, t) . real(|det B|) area [B] \n[t] p1 p2 p3 = 2 1 * abs ((p2 - p1) \u00d7 (p3 - p1)) The calculation is performed in several steps, each \nof which re\u00admoves some of the symmetry described by the type of area. First, the two offset vectors p2 \n- p1 and p3 - p1 are computed. These operations remove the effect of translations on the result in exactly \nthe same way as the type isomorphism in Example 2. Next, we compute the cross product of the two vectors, \nwhich gives the area of the parallelogram described by the sides of the triangle and has type real(det \nB). This removes some of the symmetry due to in\u00advertible linear maps, but the cross product still varies \nwith the sign of the determinant. We remove this symmetry as well using abs. This gives a value of type \nreal(|det B|) which we multiply by 1 2 to recover the area of the triangle rather than that of the whole \nparal\u00adlelogram. If we specialise area to just orthogonal transformations, the assumption | det(.OO)| \n= 1 gives the following type: area : .O:O2, t:T2. vec(.OO, t) . vec(.OO, t) . vec(.OO, t) . real(1) This \ntype shows that the area of a triangle is invariant under or\u00adthogonal transformations and translations. \nCombinations of such transformations are isometries, i.e., distance preserving maps. 2.5 Scale Invariance \nand Dimensional Analysis Indexing types by scaling factors brings us to the original inspira\u00adtion for \nthe current work: Kennedy s interpretation of his units of measure type system via scaling invariance \n[13]. Kennedy shows how interpreting types in terms of scaling invariance brings the techniques of dimensional \nanalysis to bear on programming. The types of the real number arithmetic operations in Figure 2 are ex\u00adactly \nthe types Kennedy assigns in his units of measure system, ex\u00adcept for that of the absolute value operation. \nSemantically, our type indexes by non-zero scaling factors, whereas Kennedy s indexes by strictly positive \nones. In our two-dimensional setting we can add to Kennedy s one\u00addimensional scaling invariance an operation \n.1 that, semantically, takes scale factors in GL1 to invertible linear maps in GL2, i.e., takes numbers \ns to matrices ( 0 s 0 s ). This operation satis.es the equation det(.1s) = s 2 , indicating that scaling \nthe plane by s in both directions scales areas by s 2 . Example 5. Just as we specialised the type of \nthe area function to orthogonal transformations in Example 4, we can also specialise area s type to scaling \ntransformations. This yields the type: area : .s:GL1, t:T2. vec(.1s, t) . vec(.1s, t) . vec(.1s, t) . \nreal(s 2) As expected, the area of a triangle varies with the square of scalings of the plane, and this \nis re.ected in the type. Linear maps of the form ( 0 s 0 s ), as generated by .1, commute with all other \ninvertible linear maps. We thus require (.1s)B = B(.1s) to hold. The scaling maps ( s 0 0 s ) are precisely \nthe elements of GL2 that commute with all others; these form the centre of GL2. If we keep track of scalings, \nthen we can assign the more precise types to scalar multiplication and dot product. These are shown in \nFigure 3, which summarises the most general types of all the vector operations that we have described. \n 0 : .B:GL2. vec(B, 0) (+) : .B:GL2, t1, t2:T2. vec(B, t1) . vec(B, t2) . vec(B, t1 + t2) negate : .B:GL2, \nt:T2. vec(B, t) . vec(B, -t) (*) : .s:GL1, B:GL2. real(s) . vec(B, 0) . vec(.1(s)B, 0) a.Comb : .B:GL2, \nt:T2. vec(B, t) . real(1) . vec(B, t) . vec(B, t) (\u00b7) : .s:GL1, O:O2. vec(.1(s).O(O), 0) . vec(.1(s).O(O), \n0) . real(s 2) (\u00d7) : .B:GL2. vec(B, 0) . vec(B, 0) . real(det B) Figure 3. Operations on vectors Example \n6. With the operations in Figure 2, it is not possible to write a term with the following type that is \nnot constantly zero: .s:GL2. real(s 2) . real(s) This was shown by Kennedy for his units of measure system \n[13]. In particular, it is not possible to write a square root function with the above type. The non-de.nability \nof square root is similar to the uninhabitation of the type in Example 3. In Section 4.3 we revisit Kennedy \ns result and show that even if we add square root as a primitive operation with the type above then it \nis still not possible to construct the cube root function. The non-de.nability of cube root is related \nto the impossibility of trisecting an arbitrary angle by ruler and compass constructions. 3. A General \nFramework We now present our framework for algebraically indexed types and its relational interpretation. \nWe de.ne the syntax of alge\u00adbraically indexed types (Section 3.1) and a syntax for terms in a general \nprogramming language for algebraically indexed types (Section 3.2). We give an index-erasure semantics \nto types and terms (Section 3.3), and based on this semantics de.ne notions of contextual equivalence \nand type isomorphism. We then introduce a relational semantics for types parameterised by an appropriate \nmodel of the algebraic theory (Section 3.4), prove the central Abstraction Theorem and use the relational \nsemantics to de.ne a notion of semantic equivalence that soundly approximates contex\u00adtual equivalence \n(Section 3.5). We will use a type system for af.ne geometry as a running example throughout, so that \nby the end of the section we have prepared enough syntactic and semantic gadgets to let us prove invariance \nand abstraction properties for geometric examples in Section 4. 3.1 Algebraically-Indexed Types The \nindex expressions and types of an instantiation of our general framework are derived from the following \ndata: 1. A collection Sort of index sorts. We use the meta-syntactic variables s, s1, s2, . . . for arbitrary \nsorts taken from Sort. 2. A collection IndexOp of index operations, with a function opArity : IndexOp \n. Sort * \u00d7 Sort. (We use the notation A * to denote the set of lists of elements of some set A.) 3. \nA collection PrimType of primitive types, with a function tyArity : PrimType . Sort *, describing the \nsorts of the arguments of each primitive type.  Example (Geometry: syntax). The two-dimensional geometry \nsystem has a sort for each of the geometric groups mentioned in Section 2, so Sort = {T2, GL2, O2, GL1}. \nWe have additive group structure on T2, multiplicative group structure on GL1, GL2, and O2, injections \nfrom O2 and GL1 into GL2, determi\u00adnant, and absolute value. Thus, IndexOp = {0, +, -, 1G, - \u00b7G -, --1G \n, .O, .1, det, |\u00b7|}, where G . {GL1, GL2, O2}, and opArity(0) =([], T2) opArity(1G) =([], G) opArity(+) \n=([T2, T2], T2) opArity(\u00b7 G) =([G, G], G) opArity(-) =([T2], T2) opArity(-1G )=([G], G) opArity(.O) =([O2], \nGL2) opArity(.1) =([GL1], GL2) opArity(det)=([GL2], GL1) opArity(|\u00b7|) =([GL1], GL1) The intended interpretations \nof the top three pairs of operations are group unit, group combination and group negation, respec\u00adtively. \nWhen we discuss equational theories on index expressions in Section 3.1.2 we will impose the (abelian) \ngroup laws. For this example, we also have PrimType = {vec, real}, with tyArity(vec) = [GL2, T2] and \ntyArity(real) = [GL1]. We assume a countably in.nite collection of index variable names i, i1, i2, etc. \nIndex contexts . = i1:s1, . . . , in:sn are lists of variable/sort pairs such that all the variable names \nare distinct. The rules in Figure 4 generate two judgements: well-sorted index expressions . f e : s \nand well-indexed types . f A type. Since index variables may appear in types, types are judged to be \nwell\u00adindexed with respect to an index context .. The rules for well\u00adsorted index expressions are particularly \nsimple: either an index expression is a variable that appears in the context (rule I VA R), or it is \nan application of an index operation taken from IndexOp to other index expressions (rule IOP). The rules \nfor well-indexed types in\u00adclude the usual ones for the simply-typed .-calculus with unit, sum and tuple \ntypes (rules TYUN I T, TYAR R, TYTU P L E and TYSU M). We use bool as an abbreviation for unit + unit. \nThe rule TYPR I M forms, from a primitive type X and appropriately sorted index ex\u00adpressions e1, . . \n. , en, the well-indexed type X(e1, . . . , en). The rule TYFO R A L L forms universally quanti.ed types, \nwhere the universal quanti.cation ranges over all index expressions of some sort. Exis\u00adtential types, \nformed using the TYEX rule, allow for abstraction by hiding. 3.1.1 Substitution of Index Expressions \nIt is convenient to express substitution of index expressions in terms of simultaneous substitutions. \nGiven a pair of index contexts . and .1 = i1:s1, . . . , in:sn, a (simultaneous) substitution . f s . \n.1 is a sequence of expressions s = (e1, . . . , en) such that . f ej : sj for all 1 = j = n. Given a \nsubstitution . f s = (e1, . . . , en) . .1 and a variable ij :sj in .1, we write s(ij ) for the index \nexpression ej . We write . . .1 for the set of all substitutions s such that . f s . .1. We can think \nof any sequence of sorts as an index context. In particular, we will make use of substitutions of the \nform . f s . tyArity(X), since these are exactly sequences of index arguments suitable for the primitive \ntype X. By further abuse of notation, we write . . tyArity(X) for the set of all substitutions s such \nthat . f s . tyArity(X). For a substitution . f s . .1, where .1 = i1:s1, . . . , in:sn, and a variable/sort \npair i:s such that i does not appear in either . or .1, we can form the lifted substitution ., i:s f \nsi:s = (s(i1), . . . , s(in), i) . .1, i:s. Application of a substitution . f s . .1 to a well-sorted \nindex expression .1 f e : s yields a well-sorted index expression . f s * e : s. The expression s * e \nis def de.ned on variables as s * i = s(i), and on operation symbols as def s * (f(e1, . . . , en)) \n= f(s * e1, . . . , s * en). Given .1 f A type, we have . f s * A type. The key clauses de.ning s * A \nare for Well-sorted index expressions i : s . . f . IndexOp opArity(f) = ([s1, . . . , sn], s) {. f \nej : sj }1=j=n IVA R I OP . f i : s . f f(e1, . . . , en) : s Well-indexed types X . PrimType tyArity(X) \n= [s1, . . . , sn] {. f ej : sj }1=j=n . f A type . f B type TYPR I M TYUN I T TYAR R . f X(e1, . . . \n, en) type . f unit type . f A . B type . f A type . f B type . f A type . f B type ., i:s f A type ., \ni:s f A type TYTU P L E TYSU M TYFO R A L L TYEX . f A \u00d7 B type . f A + B type . f .i:s.A type . f .i:s.A \ntype Figure 4. Index expressions and types primitive types and the universal and existential quanti.ers: \ns * def X(s * (X(e1, . . . , en)) = e1, . . . , s * en) def def s * s * (.i:s.A) = .i:s.s * A (.i:s.A) \n= .i:s.s * A i:s i:s The identity substitution . f id. . . is id. = (i1, . . . , in) where . = i1:s1, \n. . . , in:sn. The composition of two substitutions f s1 11 . f s . .1 and .1 . .11, where s1 = (e1, \n. . . , e n), def is de.ned as . f s1 . s = (s * e1 1 , . . . , s * en 1 ) . .11. Given a context . = \ni1:s1, . . . , in:sn, and a variable/sort pair i:s such that i does not appear in ., we de.ne the projection \nsubstitution ., i:s f pi:s . . as pi:s = (i1, . . . , in).  3.1.2 Index Expression Equality and Type \nEquality Much of the power of indexing types by the expressions of an alge\u00adbraic theory comes from the \nequations of the theory. For example, in Section 2 the types vec(B, t1 +t2) and vec(B, t2 +t1) are con\u00adsidered \nequal by the type system because + is commutative. In the general framework, the equations between types \nare derived from a ax set IndexAx of axioms . f e = e 1 : s that are well-sorted, in the sense that both \n. f e : s and . f e 1 : s hold. Given a set IndexAx of axioms, we generate the equality judg\u00adment between \nindex expressions . f e = e 1 : s by a set of rules. The following rule lets us use substitution instances \nof axioms: 1 ax 1 1 (.f e = e : s) . IndexAx . f s . . * *1 . f s e = s e : s We also assume the standard \ncongruence, re.exivity, symmetry and transitivity rules for the equality judgment. Example (Geometry: \naxioms). In Section 2 we assumed various equational axioms for indexing expressions standing for elements \nof geometric groups. Assuming the abelian group axioms for trans\u00adlations we can formalise this in our \nframework: ax t : T2 f t + 0 = t : T2 ax t1, t2, t3 : T2 f t1 + (t2 + t3) = (t1 + t2) + t3 : T2 ax t \n: T2 f t + (-t) = 0 : T2 ax t1, t2 : T2 f t1 + t2 = t2 + t1 : T2 Similarly, the sort of scale factors \nGL1 forms an abelian group un\u00adder multiplication, and the sorts GL2 and O2 form (non-abelian) multiplicative \ngroups, so we assume the appropriate axioms. We also assume that the operations .O, .1, det and |\u00b7| are \ngroup homo\u00admorphisms, and that expressions of the form .1(s) commute with group multiplication in the \nsort GL2. The absolute value of the de\u00adterminant of an orthgonal transformation is always 1, so we also \nax assume |det(.OO)| = 1. Similarly, scaling maps have a determi\u00ad ax nant expressible in terms of other \noperations: det(.1(s)) = s \u00b7 s. ax We also assume the axiom |s 2| = s 2 . The equality judgment . f \ne = e 1 : s on index expressions generates the equality judgment . f A = B type on types. The basic rule \ngenerating equality judgments on types equates applications of primitive types if their arguments are \nequal: 1 {. f ej = ej : sj }1=j=n . f X(e1, . . . , en) = X(e1 1 , . . . , e 1 ) type n The rest of \nthe rules for equality on types ensure that it is a congru\u00adence relation and an equivalence relation. \nThe substitutions . f s . .1 and . f s1 . .1 are de.ned to be equal, and written . f s = s1 . .1, if \ntheir component expressions are equal in the context .: i.e., if . f ej = ej 1 : sj , for all j.  3.2 \nWell-typed terms We now present the rules for well-typed terms over the collection of types we de.ned \nin Section 3.1. Well-typed terms are de.ned with respect to well-indexed typ\u00ading contexts, which are \nin turn de.ned with respect to an index con\u00adtext. Well-indexed typing contexts with respect to an index \ncontext . are sequences of variable/type pairs with no repeated variable names such that each type is \nwell-indexed with respect to .. For\u00admally, well-indexed typing contexts are given by . f G ctxt . f A \ntype x . G . f E ctxt . f G, x : A ctxt Application of substitutions extends to typing contexts by applying \nthe substitution to each type. Well-typed terms are de.ned with respect to an index context . and a type \ncontext . f G ctxt. The judgment .; G f M : A is de.ned in Figure 5. The equational theory on types is \nincorporated into the type system via the rule TYEQ, which allows a term that has type A to also have \nany equal type B as well. For any particular theory we assume that there is a closed typing context Gops \nthat describes the types of the primitive operations. Example (Geometry: operations). For geometry Gops \nwould col\u00adlect together the types of primitive operations as listed in Figure 2 and Figure 3. 3.3 Index-Erasure \nSemantics Having de.ned the syntax of algebraically indexed types and terms, we turn to their denotational \ninterpretation. We .rst de.ne an index\u00aderasure interpretation of types and terms that interprets every \nwell\u00adindexed type as a set, ignoring the indexing expressions, and which . f G ctxt x : A . G .; G f \nM : A . f A = B type . f G ctxt VA R TYEQ UN I T .; G f x : A .; G f M : B .; G f * : 1 .; G f M : A \n.; G f N : B .; G f M : A \u00d7 B .; G f M : A \u00d7 B .; G f M : A PA I R PRO J 1 PRO J 2 IN L .; G f (M, N \n) : A \u00d7 B .; G f p1M : A .; G f p2M : B .; G f inl M : A + B .; G f M : A + B .; G, x : A f N1 : C .; \nG f M : B .; G, y : B f N2 : C .; G, x : A f M : B IN R CA S E AB S .; G f inr M : A + B .; G f case \nM of inl x.N1; inr y.N2 : C .; G f .x.M : A . B .; G f M : A . B .; G f N : A ., i:s; p * G f M : A .; \nG f M : .i:s.A . f e : s AP P i:s UN I VAB S UN I VAP P .; G f M N : B .; G f .i.M : .i:s.A .; G f M[e] \n: (id., e) * A .; G f M : .i:s.A .; G f M : (id., e) * A . f e : s ., i:s f A type ., i:s; p * G, x : \nA f N : p * B i:s i:s EXPAC K EXUN PAC K .; G f ([e], M ) : .i:s.A .; G f let([i], x) = M in N : B \nFigure 5. Well-typed terms interprets open terms as functions that map environments to .nal values. Interpretation \nof Types. The de.ning feature of the index erasure interpretation is that semantics of a well-indexed \ntype X(e1, . . . , en)is determined solely by the primitive type X and not by the in\u00addex expressions \ne1, . . . , en. We thus assume each primitive type X . PrimType is assigned a set LXJ and extend this \nassignment to well-indexed types by induction on the type structure: def def LA + BJ = LAJ + LBJ LunitJ \n= {*} def def LX(e1, . . . , en)J = LXJ LA \u00d7 BJ = LAJ \u00d7 LBJ def def L.i:s.AJ = LAJ LA . BJ = LAJ . LBJ \ndef L.i:s.AJ = LAJ (We will overload the notation L\u00b7J for all index-erasure interpre\u00adtations, and reserve \nnotation [\u00b7] for the index-observing relational semantics de.ned later.) The index-erasure interpretation \ncompletely ignores index ex\u00adpressions and quanti.ers, and type equality is de.ned as an exten\u00adsion of \nindex equality. Therefore, it is straightforward to prove that equal types have equal denotations when \ninterpreted in the index\u00aderasure semantics, and that substitution of index terms has no effect on the \nindex-erasure interpretation of types: Lemma 1. 1. If . f A = B type then LAJ = LBJ; and 2. If .1 f A \ntype and . f s . .1, then Ls * AJ = LAJ. Interpretation of Terms. We assign an index-erasure semantics \nto any well-indexed typing context . f G ctxt by induction: LEJ = {*} and LG, x : AJ = LGJ \u00d7 LAJ. For \na well-typed term .; G f M : A, we de.ne the erasure interpretation as a function LMJ : LGJ . LAJ that \ncompletely ignores the indexing information. In light of Lemma 1, we do this directly on the syntax of \nwell\u00ad typed terms, rather than on typing derivations. The de.nition of LMJ is completely standard, except \nfor the clauses for universal and existential types: def def L.i. M J . = LMJ . LM [e]J . = LMJ . def \nL([e], M )J . = LMJ . def Llet([i], x) = M in NJ . = LNJ (., LMJ .) For any particular theory we assume \nthat there is an interpreta-Example (Geometry: interpretation). The two-dimensional geom\u00adetry instantiation \nof the general framework uses the assignment LvecJ = R2 and LrealJ = R. We assume that .ops gives the \nusual interpretation to scalar and vector operations from Figure 2 and Figure 3. Contextual Equivalence. \nWe use our index-erasure semantics to de.ne when a pair of terms are contextually equivalent with respect \nto syntactically de.ned contexts, following Hofmann [11]. Given an index context . = i1:s1, ..., in:sn, \nwe write ...A for .i1:s1. . . . .in:sn.A, and similarly for ...M and .G.M. De.nition 1 (Contextual Equivalence). \nTwo terms .; Gops , G f M1, M2 : A are contextually equivalent, written .; G f M1 M2 : A, if for all \ncontexts \u00b7; Gops f C : (...G . A) . bool, it is the case that LC (....G.M1)J .ops = LC (....G.M2)J .ops \n. Type Isomorphism. We say that well-indexed types . f A type and . f B type are isomorphic, and write \n. f A ~B, if there = exist maps between them that are mutually inverse with respect to contextual equivalence, \ni.e., if there are terms . f I : A . B and . f J : B . A such that .; x : A f J(I(x)) x : A and .; y \n: B f I(J(y)) y : B. That ~ = is a congruence with respect to the type formation rules of Figure 4 is \nstraightforward. We can also derive isomorphisms that are independent of the indexing theory, such as \n. f A \u00d7 B ~= = B \u00d7 A, and . f .i:s.(A . B) ~A . .i:s.B for i not free in A. 3.4 The Relational Interpretation \nof Types The relational semantics of the well-indexed type . f A type is a binary relation on the index-erasure \ninterpretation of A. We write Rel(X) for the set of binary relations R . X \u00d7 X on the set X. For the \nunit, tuple, sum and function types we de.ne the re\u00adlational interpretation as a standard logical relation. \nThe relational interpretations of primitive types with index arguments and the uni\u00adversally quanti.ed \ntypes require an interpretation of index contexts. An index environment . assigns to each index variable \ni : s in the context . a value drawn from an interpretation of the sort s that soundly models the equational \ntheory associated with s. We call such an interpretation a model: it assigns to each index operation \nin the equational theory a corresponding operation in the interpretation, so that index expressions can \nbe interpreted by recursion on their structure. For example, the sort T2 of translations can be modelled \nby any tion of the primitive operations .ops . LGops J. abelian group. An obvious candidate here is \nthe additive group over R2 , which we will use to obtain invariance under translation; but we could \nuse the additive group Q, or even a .nite group such as the two-element group Z2. Models. A model assigns \nto each sort s . Sort a carrier set [s], and assigns to each operation f . IndexOp with opArity(f) = \n([s1, . . . , sn], s), a function [f] : [s1] \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 [sn] . [s]. An index context . = (i1:s1, . . . \n, in:sn) is interpreted as def cartesian product, i.e., [.] = [s1] \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 [sn]. For each well\u00adsorted \nindex expression . f e : s, we assign a function [e] : [.] . [s] by recursion on the structure of e: \ndef def [i]. = .(i) [f(e1, . . . , en)]. = [f]([e1]., . . . , [en].) Finally, a model must be sound, \nthat is, for each axiom . f ax 1 1 e = e : s . IndexAx, we have [e] = [e ]. Example (Geometry: af.ne \nmodel). We de.ne the model of the indexing theory for the two-dimensional geometry example as fol\u00adlows. \nEach of the sorts is interpreted just as its semantic counter\u00adpart: [T2] = T2 [GL2] = GL2 [O2] = O2 [GL1] \n= GL1 Each of the index operations (e.g., the group structure and determi\u00adnant) is interpreted by the \nintended semantic operation, and clearly satis.es the axioms in Example 3.1.2. Given . . [.] and a substitution \n. f s . .1 with s = (e1, . . . , en), we can derive the composed index environment . . def s . [.1] as \n. . s = ([e1]., . . . , [en].). Relational interpretation of primitive types. Having .xed a model we \nnext choose a relational interpretation of primitive types: for each each primitive type X, its relational \ninterpretation is pa\u00adrameterised by elements from the model: [X] : [tyArity(X)] . Rel(LXJ). Example (Geometry: \nchange of basis interpretation). Given the model of geometric groups described above, for the relational \nin\u00adterpretation of vec(B, t) and real(s), we use [vec](B,vt) = {(v , Bv + vt) | v . R2} and [real](k) \n= {(x, kx) | x . R}. Relational interpretation of types. We assign a relational inter\u00adpretation to all \nwell-indexed types . f A type by induction on their derivations, parameterised by index environments \n. . [.]: def [unit]. = {(*, *)} def [X(e1 , . . . , en)]. = [X]([e1]., . . . , [en].) [A . B]. def [A]. \n: = . [B]. [A \u00d7 B]. def [A]. \u00d7+[B]. = [A + B]. def [A]. + = + [B]. def [.i:s.A]. ={[A](., m) | m . [s]} \n def [.i:s.A]. = {[A](., m) | m . [s]} In this de.nition, the relational interpretation of an application \nof a primitive type [X(e1, . . . , en)]. is built from the relational interpretation of the primitive \ntype, [X], and the interpretation of the index terms e1, ..., en in the index environment .. Universal \nand existential quanti.cation are interpreted by the set-theoretic intersection and union, respectively, \nover all extensions of the index environment. We have also used the following standard constructions \non bi\u00adnary relations: if R . Rel(X) and S . Rel(Y ), then R : . S . Rel(X . Y ) is {(f1, f2) | .(a1, \na2) . R. (f1a1, f2a2) . S}, and R \u00d7+S . Rel(X \u00d7 Y ) is {((a1, b1), (a2, b2)) | (a1, a2) . R . (b1, b2) \n. S}, and R +1) | + S . Rel(X + Y ) is {(inl x, inl x (x, x 1) . R} . {(inr y, inr y 1) | (y, y 1) . \nS}. The following lemma states that the relational interpretation of types that we have de.ned in this \nsection behaves well: the .rst part of the lemma states that two types that are judgmentally equal are \ngiven equal relational interpretations, and the second part states that substitution of index expressions \nin types can be interpreted by the composition of index environments with substitutions. Lemma 2. 1. \nIf . f A = B type, then [A] = [B]; 2. If .1 f A type then for all . f s . .1 and . . [.], [s * A]. = \n[A](. . s). Note that the equations in both parts of Lemma 2 are well-typed by virtue of the corresponding \nparts of Lemma 1. 3.5 The Abstraction Theorem and Semantic Equivalence Our main result (Theorem 1) is \nthat the index-erasure semantics of every well-typed term is related to itself in the relational interpre\u00adtation \nof its type: this is the Abstraction Theorem for every instan\u00adtiation of our general framework. The Abstraction \nTheorem. We now state the Abstraction Theo\u00adrem for well-typed terms. To state and prove this theorem \nfor open terms, we extend the relational interpretation of types to typing con\u00adtexts. The relational \ninterpretation of contexts is de.ned by: def def [E]. = {(*, *)} [G, x : A]. = [G]. \u00d7+[A]. The relational \ninterpretation of contexts inherits from the rela\u00adtional interpretation of types the property of interpreting \nthe appli\u00adcation of substitutions as composition: Lemma 3. If .1 f G ctxt and . f s . .1 , then for all \n. . [.], we have [s * G]. = [G](. . s). Given a particular choice of model and relational interpretation \nof primitive types, we can then prove the following. Theorem 1 (Abstraction). If .; G f M : A, then for \nall . . [.] and .1, .2 . LGJ such that (.1, .2) . [G]., we have (LMJ .1, LMJ .2) . [A].. Proof. By induction \non the typing derivation, making use of Lemma 2 (part 1) for rule TYEQ, Lemma 2 (part 2) for rules UNIVAPP \nand EXPACK, and Lemma 3 for rules UNIVABS and EXUNPACK. The details can be found in the Coq development. \nSemantic equivalence of terms is de.ned in terms of the re\u00adlational interpretation. As a consequence \nof Theorem 1, semantic equivalence is a sound approximation of contextual equivalence. Let Gops be the \ncontext of primitive operations and .ops its interpretation Fix a model and relational interpretation \nof primitive types so that (.ops , .ops ) . [Gops ]*. De.nition 2 (Semantic equivalence). Two terms .; \nGops , G f M1, M2 : A are semantically equal, written .; G |= M1 ~ M2 : A, if for all . . [.], and all \n(.1, .2) . [G]., we have (LM1J (.ops , .1), LM2J (.ops , .2)) . [A].. Theorem 2 (Soundness). If .; G \n|= M1 ~ M2 : A then .; G f M1 M2 : A. 4. Geometric Consequences of Abstraction We now instantiate our \ngeneral framework with the indexing theory of Section 2, and present more general and formally-justi.ed \nfree theorems, type isomorphisms, and non-de.nability results. For the free theorems and isomorphisms, \nwe use the model and relational interpretation of primitive types described in Section 3.4, namely that \nof af.ne transformations for vectors and scaling for scalars. 4.1 Free Theorems Consider the type of \nthe triangle area function from Example 4: area : .B:GL2, t:T2. vec(B, t) . vec(B, t) . vec(B, t) . real(|det \nB|) By Theorem 1, we can derive the following free theorem. For all B . GL2, vt . T2, and vx, vy, vz \n. R2 , we have |det B|(LareaJ vx vy vz) = LareaJ (Bvx + vt) (Bvy + vt) (Bvz + vt) Thus, directly from \nthe type of the area function, we can see that its index-erasure semantics is (a) invariant under translations, \nand (b) if the inputs are subjected to a linear transformation B, the output varies with the absolute \nvalue of the determinant of B.  4.2 Type Isomorphisms Types indexed by abelian groups induce a particularly \nrich theory of type isomorphisms; previous work on units of measure [13] relates these to Buckingham \ns theorem from dimensional analysis. Here we consider the additive abelian groups of translations and \nthe multiplicative abelian group of scalings. Translations Consider .rst the group T2 of translations \nfrom Section 2.2 and Section 2.3. Example 7 (Geometry: wlog). We prove that ., B:GL2 f (.t:T2.vec(B, \nt) . vec(B, t)) ~ = vec(B, 0). Let X def = .t:T2.vec(B, t) . vec(B, t) I def = .f:X.f [0] (0 [B]) and \nY def = vec(B, 0) def J = .v:Y..t:T2..w:vec(B, t).v + [B, 0, t]w Unfolding de.nitions gives that LI(J(v))J \n(.ops , v ) = v +v0 for any v . R2 . Because v0 is the identity for vector addition it follows that ., \nB:GL2; v:Y f I(J(v)) v : Y . To show ., B:GL2; f:X f J(I(f)) f : X we appeal to Theorem 2 and reason \nusing the relational semantics. It suf.ces to show ., B:GL2; f:X |= J(I(f)) ~ f : X; that is, given . \n. [., B:GL2], for any f and f1 with (f, f1) . [X]., it is the case that (LJ(I(f))J (.ops , f), f1) . \n[X].. Expanding the premise, we have .vt . R2 , .v . R2 , f1(.(B)v + vt) = .(B)(f(v )) + vt (3) Expanding \nthe conclusion, we have to show that for any tv0 . R2 and v 0 . R2 , it is the case that f 1(.(B)v 0 \n+ tv0) = .(B)(v 0 + vv f(0)) + t0. By instantiating Equation 3 with v = 0 and vt = .(B)v 0 + tv0 and \napplying a little algebra we obtain this result. We can generalise this isomorphism substantially, proving \nthat for any quanti.er-free type A, the type .t:T2.vec(B, t) . A is isomorphic to A[0/t], where A[0/t] \ndenotes substitution of the identity translation 0 for index variable t in type A. This isomor\u00adphism \nformalises the equivalence between coordinate-free geome\u00adtry, expressed by a polymorphic type whose .rst \nargument can be thought of as the origin with respect to which A is speci.ed, and a coordinate-based \ngeometry, expressed by the type A[0/t], in which the origin is .xed at (0, 0). It is sometimes said that \nan af.ne space is a vector space that has forgotten its origin; we have captured this in a type isomorphism. \nLemma 4. Suppose that ., B:GL2, t:T2 f A type, A contains no quanti.ers and every occurrence of vec is \nof the form vec(B, ?). Then ., B:GL2 f (.t:T2.vec(B, t) . A) ~ = A[0/t] Proof. Let def def X = .t:T2.vec(B, \nt) . A and Y = A[0/t] def I = .f:X.f [0] (0 [B]) def J = .y:Y..t..v:vec(B, t)..t:v(y) A where terms \n., B:GL2, t:T2; v:vec(B, t) f .t:v : A[0/t] . A A ., B:GL2, t:T2; v:vec(B, t) f .t:v : A . A[0/t] A \n ., B:GL2, t:T2; v:vec(B, t) f .te :v : vec(B, e[0/t]) . vec(B, e) ., B:GL2, t:T2; v:vec(B, t) f .t:v \n: vec(B, e) . vec(B, e[0/t]) e are de.ned by induction over the structure of A and e. For brevity we \nomit types on binders; also note that the omitted cases for .t:v A have de.nition symmetric to .t:v: \nA .t:v .t:v unit = .x.x real(e) = .x.x .t:v A1\u00d7A2 A1 A2 = .p.(.t:v (p1p), .t:v (p2p)) .t:v A1+A2 A1 \nA2 = .x.case x of inl y.inl(.t:v y); inr y.inr(.t:v y) .t:v (f(.t:v A1.A2 = .f..x..tA:v 2 A1 x)) .t:v \n.t:v vec(B,e) = .x..e t:v(x) vec(B,e) = .x..t:v(x) e .t:v .t:v = .w.w = .w.w 0 0 .t:v (.t:v .t:v (.t:v \n= .w..t:v (w)) = .w..t:v (w)) e1+e2 e1 e2 e1+e2 e1 e2 . t:v .t:v -e = .w..e t:v(w) -e = .w..te :v(w) \n . t:v .t:v  t = .w.w + v t = .w.w + (negate v) .t:v 1 .t:v 1 t; = .w.w (t = t) t; = .w.w (t = t) Unfolding \nde.nitions, we deduce that f LI(J(y))J (.ops , y) = .At:v (.ops ,v0)(y) for any y . LA[0/t]J. It s easy \nto prove by induction on A that f .t:v v A(.ops , 0)(y) = y, and so ., B:GL2; y:Y f I(J(y)) y : Y follows. \nFor the opposite direction of the isomorphism, we appeal to Theorem 2 and so it suf.ces to show ., B:GL2; \nf:X |= J(I(f)) ~ f : X; that is, given . . [., B:GL2], for any f and f1 with (f, f1) . [X]., it is the \ncase that (LJ(I(f))J (.ops , f), f 1) . [X].. Expanding the premise, we have .vt . R2 , .v . R2 1 , (f \n(v ), f (.(B)v + vt)) . [A](.,vt) (4) Expanding the conclusion, we have to show for any tv0 . R2 and \nv 0 . R2 , it is the case that (LJ(I(f))J (.ops , f)(v 0), f1(.(B)v 0 + tv0)) . [A](., tv0). Unfolding \nthe de.nitions of J and I and ex\u00adpanding the erasure semantics, this amounts to showing that f .tv0, \nv 0 . R2 , ( .t:v (.ops , v 0)(f v0), f1(.(B)v 0+tv0)) . [A](., tv0). A In order to make progress we \nprove .rst by induction on A that for any v and wv, the meaning of .t:v can be characterized by A f .t:v \n( A(.ops , v )(x), y) . A (., vw) . (x, y) . [ A] (., .(B)v + wv) Thus our goal becomes .tv0, v 0 . \nR2 , (f v0, f 1(.(B)v 0 + tv0)) . [A](., .(B)v 0 + tv0). This is obtained immediately by instantiating \nEquation 4 with v = v 0 and vt = .(B)v 0 + tv0. Example 2 and Example 7 are special cases of this isomorphism. \nAnother instance is the type of vector addition: .B:GL2, t1, t2:T2.vec(B, t1) . vec(B, t2) . vec(B, t1+t2) \n~ = .B:GL2, t1:T2.vec(B, t1) . vec(B, t1) (by Lemma 4) ~ = .B:GL2.vec(B, 0) (by Lemma 4) ~ = unit (by \nTheorem 1) In other words, the vector addition operation is the only inhabitant of its type! Scalings \nFor the group GL1 of scalings we can treat a real-valued argument to a function as a unit of measure \nwith which to scale the result. Although the argument might be zero, and this cannot be used for scaling, \nwe still can obtain the following slightly more complicated isomorphism: ~ .s:GL1.real(s) . A = A[1/s] \n\u00d7 .s:GL1.A (5) The type of areaCircle from the introduction is one instance: .s:GL1.real(s) . real(s \n2)~2 = real(1) \u00d7 (.s:GL1.real(s )) (by Equation 5) ~ = real(1) \u00d7 unit (by Theorem 1) ~ = real(1) (trivially) \n 4.3 Non-de.nability To prove non-de.nability results, the model and relational inter\u00adpretation used \nin the previous two sections are not suf.cient. This is true even for simple scalars with invariance \nunder scaling. Con\u00adsider the type .s:GL1.real(s 2) . real(s). There are many func\u00adtions f : R . R that \nsatisfy its relational interpretation, i.e., for which f(k2 \u00b7 x) = k \u00b7 f (x) for any k = 0. Consider \nv x if x > 0 f(x) = 0 otherwise for instance. Yet this type contains only the constant zero function, \na fact that we can prove using a surprisingly simple model! Example 8. If Gops f f : .s:GL1. real(s 2) \n. real(s) then Lf J = .x.0. To show this, take the model def def def GL1] = {0, 1} = 0 -1 = id def [1] \n] def [ \u00b7] = .(x, y).(x + y) mod 2 [ | - |] = id, in other words, the additive abelian group (Z2, +). \nNow set .R if z = 0 [real](z) = {(0, 0)} if z = 1 It s easy to check that (.ops , .ops ) . [Gops ]*. \nWe think of z as tracking whether or not exponents on scale parameters are divisible by 2: all the primitive \noperations in Fig\u00ad ure 2 produce results with even exponents if their inputs have even exponents. But \nthe type under consideration here does not. By Theorem 1 we have that (f, f) . [.s:GL1. real(s 2) . real(s)]*. \nExpanding the de.nitions, this means that for any z . [GL1] and any (x, y) . [real]((z + z) mod 2), it \nis the case that (f(x), f(y)) . [real](z). Set z = 1. Then we have that if x = y then f(x) = f(y) = 0. \nThe particular model and relational interpretation used here is devised only to rule out the square root \ntype (it does not rule out a cube root type , for instance); nevertheless, it is possible to devise craftier \ninterpretations that serve up both invariance and more general non-de.nability results. For example, \nwe can set def def def [GL1] = GL1 \u00d7 Q [\u00b7] = (\u00b7, +) [1] = (1, 0) -1 (-1 def def [ ] = , -) [| \u00b7 |] = \n(| \u00b7 |, id) and {(x, kx) | x . R} if q . Z [real](k, q) = {(0, 0)} otherwise Example 9. Suppose we \nextend the operations Gops of Figure 2 and corresponding .ops with a square root operation typed by sqrt \n: .s:GL1.real(s 2) . real(s). If Gops f f : .s:GL1. real(s 3) . real(s) then LfJ = .x.0. To show this, \ntake the model def def def def def [GL1] = Q [\u00b7] = + [1] = 0 [ -1 ] = - [| \u00b7 |] = id, in other words, \nthe additive abelian group (Q, +). Now set .R if .n, 2n q . Z [real](q) = {(0, 0)} otherwise It s easy \nto check that (.ops , .ops ) . [Gops ]*. Here, q is tracking the exponents on scale parameters, with \n[real](q) relating only zero to itself unless the denominator of q is a power of two (a so-called dyadic \nnumber). Applying the Abstraction Theorem and expanding, we have that for any q . Q and any (x, y) . \n[real](3q), it is the case that (f(x), f(y)) . [real](q). Set q = 1 . Then we have that if x = y then \nf (x) = 3 f(y) = 0. 5. Non-de.nability for the General Framework The non-de.nability results in the \nprevious section required the use of specially crafted models and relational interpretations. It is reasonable \nto ask whether or not there is a general method for constructing suitable models and relational interpretations \nto prove non-de.nability results. In this section, we show that this is possible for a large class of \n.rst-order types in any instance of our general framework. In Example 8, we showed that the type .s:GL1. \nreal(s 2) . real(s) only has trivial inhabitants. Intuitively, this is because the index of the result \ntype (s) cannot be obtained from the index of the input type (s 2) using the abelian group operations \nand axioms. This observation can be used to give a suf.cient condition for non\u00adinhabitation for types \nof the form: .i1:s1, . . . , im:sm. X(e1) . . . . . X(en) . X(e) Roughly speaking, if this type is inhabited, \nthen it must be the case that the index expression e can be generated from the set of index expressions \n{e1, ..., en}. We assume that we are working with an instantiation of the gen\u00aderal framework from Section \n3 with a closed typing context Gops describing the types of the primitive operations and a chosen index\u00aderasure \nsemantics. We will use a special relational interpretation built from the syntax of the indexing expressions \nto prove our gen\u00aderal non-de.nability result. For simplicity, we assume that there is only one primitive \ntype, X, but the technique we describe here ex\u00adtends to the general case. We also assume that LXJ is \nnon-empty. To state our general non-de.nability condition, we need to de\u00ad.ne the set of index expressions \ngenerated by some .nite set of index expressions. Given a set S of index expressions that are all well-indexed \nin some index context ., we de.ne Gen0(S) to be the set of expressions that are built from the elements \nof S and the primitive index operations. To account for the equations between indexing terms, we close \nunder index expression equivalence to get The conclusion of the theorem now states that either we have \nthe set Gen(S) = {e | .s. .e Now a type is well-generated if it is closed and of the form: 1 . Gen0(S). \n. f e = e 1 : s}. e . Gen({e1, ..., en }) or LMJ is the constant 0 function. This extended theorem can \nnow be used to give an alternative proof for .i1:s1, . . . , im:sm. X(e1) . . . . . X(en) . X(e) and \ne . Gen({e1, ..., en}). Theorem 3. Assume that the members of Gops are all of well\u00adgenerated types. If \nthere exists an M with typing: Gops f M : .i1:s1, ..., im:sm. X(e1) . ... . X(en) . X(e) then e . Gen({e1, \n..., en}). This theorem is usually applied in the contrapositive: if e . Gen({e1, ..., en}) then no such \nM can exist. Note that if Gops con\u00adtains operations corresponding to each of the index-level operations \n(as, for example, in Figure 2), then this theorem yields a characteri\u00ad sation of de.nable terms, since \nthe construction of e from e1, ..., en can be replicated at the term level. Proof. Let . = i1:s1, ..., \nim:sm be the index context constructed from the universally quanti.ed type variables in the type of M. \nTo interpret the index expressions, we use the free model over the variables in . constructed from the \nsyntax. This model assigns to each sort s the set {e | . f e : s}/= of index expressions quotiented by \nindex expression equality. Index operations are in\u00adterpreted by the corresponding syntactic operation \non equivalence classes: [f]([e1], ..., [en]) = [f(e1, ..., en)]. We take the relational interpretation \nof the primitive type X as: [X](e) = {(x, x) | x . LXJ . e . Gen({e1, ..., en})} 1(i.e., elements of \nthe free model over ).:e s, ..., e 11 It is straightforward to check that for any index-erasure inter\u00adpretation \nof the primitive operations .ops . Gops , we have (.ops , .ops ) . [Gops ]* because all members of Gops \nhave well\u00ad 1 generated types. Hence, by Theorem 1, we know that for all terms : :sm m Example 8. As \nthis example illustrates, there may be many different models that can be used to prove a non-de.nability \nresult. Adding Index Operations Theorem 3 also does not directly ap\u00adply in the case of Example 9, again \nbecause assumption that the types of the primitive operations are all well-generated is not sat\u00adis.ed. \nIn this case, the assumed square root operation has type .s:GL1. real(s 2) . real(s), and as we observed \nat the start of this section, s is not in the set generated by s 2. However, to enable the application \nof the theorem, we can assume an additional index operation -1/2, acting like square root at the index \nlevel. Now the free model produced in the proof of the theorem is isomorphic to the dyadic numbers with \naddition and halving, and the generated 3k sub-model consists of the dyadic rationals of the form 2n \n. Again there is a diversity of models that can be used to prove a single non-de.nability result. 6. \nLogical Information Flow We now apply our general framework to types that are indexed by logical propositions. \nBy including a primitive type that represents logical truth, we can recover through a construction due \nto Tse and Zdancewic [21] strong information .ow properties of programs. As a result of our general framework \nbeing parameterised by the choice of equational theory, we can alter the logic that we use for reasoning \nabout type equality, and hence alter the information .ow properties of the system. We .rst recall the \nconcept of information .ow. A function f : A \u00d7 B . C is said to not allow information to .ow from its \nsecond argument to the output if for all b, b1 . B and all a . A, f(a, b) = f(a, b1). If we think of \nthe B argument as representing high-security information, then we have stated that f does not allow the \nhigh-security input to .ow to the low security output. (xn, x 11 1 .(x1, x ), ..., 1, ..., e m Information \n.ow can be seen as a kind of invariance property 1 1 ). n 1, ..., e m of programs, and so our relational \ninterpretation of types is well tailored to proving this kind of property. 111 1 1, ..., e m ) 1) . [X(e1)](e \n) . [X(en)](e (LMJ .ops x1 ... xn, LMJ .ops x 1 ) . [X(e)](e ij , and using an arbitrary element (which \nwe have assumed non-empty), we have, for all k, (x, x) . 1 ... x n As described by Sabelfeld and Sands \n[19], information .ow can By setting e j 1 = x . LXJ be captured semantically by partial equivalence \nrelations (PERs). [X(ek)](i1, ..., im) since each ek is a member of the set we are using to generate \nterms. Now (LMJ .ops x...x, LMJ .ops x...x) . [X](e) and so e . Gen({e1, ..., en}). Application to Example \n3 Theorem 3 can be directly applied to show that the type .t:T2. vec(t + t) . vec(t) has no inhabitants. \nThe free model over the single index variable t is (isomorphic to) the integers, and the sub-model generated \nby the index expression t + t corresponds to the even integers. The result now follows simply because \n1 (i.e., the interpretation of t) is not an even number. Abelian Group Indexed Types Kennedy [13] has \ngiven a general characterisation of de.nability at .rst-order in the case of abelian group indexing in \nterms of integer solutions to a set of linear equations. Specialising Theorem 3 to the case of abelian \ngroup indexing yields Kennedy s characterisation. Polymorphic Constants Theorem 3 does not apply in the \ncase when we have polymorphic constants. This is the case with the polymorphic 0 : .s:GL1. real(s) in \nFigure 2. Theorem 3 does not apply because the index expression s is not generated by the empty set: \n0 s type is not well-generated. Nevertheless, it is easy to adapt the proof of Theorem 3 to handle a \npolymorphic constant like 0 by setting the relational interpretation of X to be: [X](e) = {(x, x) | x \n. LXJ . (x = 0 . e . Gen({e1, ..., en}))} Abadi, Banerjee, Heintze and Riecke [1] built a Core Calculus \nfor Dependency, using a type system based around a security level indexed monad TlA, using PERs to prove \nthe information .ow properties. Tse and Zdancewic [21] translated Abadi et al. s cal\u00adculus into System \nF1 translating the monadic type TlA to al . A for some free type variable al, and using Reynolds Abstraction \nTheorem to prove information .ow properties. For example, if the type variable aH represents high-level \ninformation, then the non\u00adinterference property of the function f could be expressed by the System F \ntype A . (aH . B) . C. If a program cannot gen\u00aderate a value of type aH , then it cannot access the value \nof B, and hence is insensitive to the actual value. Relationships between security levels are captured \nby postulating functions al1 . al2 whenever l1 is a lower security level than l2. Using algebraic indexing, \nwe re.ne Tse and Zdancewic s trans\u00adlation by replacing each type variable al with a primitive type T(fl)of \nrepresentations of the truth of a logical proposition fl that stands for the security level l. The relationships \nbetween security levels are now replaced by logical entailment, so we only have functions of type T(fl1 \n) . T(fl2 ) when fl1 entails fl2 . We instantiate our general relational framework to interpret T(f) \nas the identity rela\u00ad 1 Tse and Zdancewic s translation did not satisfy all the properties that they \nclaimed, as pointed out by Shikuma and Igarashi [20]. However, this problem is not relevant to our discussion \nhere. tion if f is true and the empty relation if f is false. We shall see that this recovers the information \n.ow properties of Abadi et al. and Tse and Zdancewic. Instantiation of the General Framework We assume \na single indexing sort prop and assume the operations and equations of boolean algebra. Thus we have \nconstants T, . and binary operators ., . with the axioms of a bounded lattice, and a unary complemen\u00adtation \noperator \u00ac. We will use f, . to stand for index expressions of sort prop. We use an equational presentation \nof boolean algebras to .t with our general framework, but note that we can de.ne an order on index expressions \nas f = . when f = f . .. We have a single primitive type T, with tyArity(T) = [prop] and index-erasure \nsemantics LXJ = {*}. Thus values of type T(f) have no run-time content; their only meaning is given by \nthe relational semantics. For the model of the indexing theory, we take an arbitrary boolean algebra \nL. The relational interpretation of the truth representation type is [T](x) = {(*, *) | x = T}, where \nT is the top element of the boolean algebra L. The primitive operations GLog re.ect logical consequence: \ntruth : T(T) and : .p, q:prop. T(p) . T(q) . T(p . q) up : .p, q:prop. T(p . q) . T(p) The combination \nof the TYEQ rule and the primitive up operation allow for logical entailment to be re.ected in programs: \nif we have f = . and M : T(f) then up M : T(.). Each of the primitive operations has a trivial interpretation, \ndue to the index-erasure interpretation of T(f) as a one-element set, giving an environment .Log . LGJ. \nLess trivially, we have this lemma: Lemma 5. (.Log , .Log ) . [GLog ]*. Information Flow We think of \nlogical expressions as compos\u00adite principals . That is, propositional variables representing atomic principals \nthat are combined using the logical connectives. We in\u00adterpret truth for principals as stating that a \nprincipal is true when satis.ed with the current state of affairs. Thus a relationship f = . indicates \nthat satisfaction of the composite principal f implies sat\u00adisfaction of the composite principal .. In \nterms of security levels, the ordering is reversed: if a high security principal is satis.ed, then all \nof their subordinates must also be satis.ed. We adapt Tse and Zdancewic s translation of Abadi et al. \ns monadic type to our setting. We de.ne a type abbreviation TfA = T(f) . A, where A is a type and f is \nan expression of sort prop. For every f, we can endow the types Tf- with the structure of a monad. This \nis due to the fact that it is an instance of the environment (or reader ) monad [12]. We read the types \nTfA as data of type A protected by the principal f. As a consequence of the relational interpretation \ngiven above, it follows that if we have an index expression f that is interpreted as some value other \nthan T in an index environment ., then for all x, x 1 . LTfboolJ, we have (x, x 1) . [Tfbool].. Thus \nif a principal is dissatis.ed (i.e., f = T), then data protected by this principal is indistinguishable \nfrom any other data, and a program cannot get access to the exact value. From this observation, and Theorem \n1, we obtain the following information .ow result: Theorem 4. Let f and . be index expressions of sort \nprop in some indexing context ., such that . = f. Then for all terms: .; GLog , G f M : Tfbool . T.bool \nctx and all terms N1, N2 of type Tfbool, M N1 M N2. Thus there is no information .ow from M s input \nto its output. Note that if . = f, then it is always possible to write the iden\u00adtity function with this \ntype, using the up operation. The theorem also holds if we move to logics other than boolean logic. For \nexam\u00adple, if our equational theory models intuitionistic logic by taking the axioms of Heyting algebras, \nthen the same non-.ow property for programs of type Tp.\u00acpbool . TTbool holds, due to the lack of excluded \nmiddle. If we take linear logic, then programs of type Tp.pbool . Tpbool have no information .ow from \ntheir input, due to non-provability of p f p . p. 7. Distance-Indexed Types The type system for geometry \nwe discussed in Section 2 and Sec\u00ad tion 4 made use of a relational interpretation of primitive types \nthat relates pairs of elements by some transformation if applying the transformation to the .rst element \nof a pair yields the second. Thus, the free theorems that we derived directly take the form of invariance \nproperties, where some equation holds between two terms. In this section, we examine another instantiation \nof our gen\u00aderal framework that relates values when they are within a certain distance. The free theorems \nthat we obtain inform us of the effect that programs have on the distances between values. For example, \na program M of type: .E1, E2:R>0 . real(E1) . real(E2) . real(E1 + E2) must satisfy the property that \nfor all E1, E2 > 0 and x, x 1 , y, y 1 . R: if |x - x 1| < E1 and |y - y 1| < E2 then |LMJ .Met x y - \nLMJ .Met x 1 y 1| < E1 + E2 Instantiation of the General Framework We assume a single indexing sort \nR>0 to represent positive, non-zero real numbers. For the index operations, we assume the operations \nmin, max, + and multiplication by constant reals. There is a single primitive type real with tyArity(real) \n= [R>0]. The primitive operations GMet are as follows, where c stands for arbitrary real-valued constants: \nc : .E:R>0 . real(E)(+) : .E1, E2:R>0 . real(E1) . real(E2) . real(E1 + E2)(-) : .E1, E2:R>0 . real(E1) \n. real(E2) . real(E1 + E2) c* : .E:R>0 . real(E) . real(cE) up : .E1, E2:R>0 . real(E1) . real(max(E1, \nE2))  We assume that the index-erasure semantics of the real type is just the set R, so all except the \nlast operation have straightforward interpretations. The up operation is interpreted just as the identity \nfunction. The index-erasure interpretations of the primitive opera\u00adtions are collected together into \nan environment .Met . LGMet J. For the relational intepretation we construct a model of the in\u00addexing \ntheory by interpreting R>0 with strictly positive real num\u00adbers. We set [real](E) = {(x, x 1) | |x - \nx 1| < E}. Lemma 6. (.Met , .Met ) . [GMet ]*. Uniform continuity Using existential types, the standard \nE-d def\u00adinition of uniform continuity can be expressed as .E:R>0 . .d:R>0 . real(d) . real(E). For any \nprogram M of this type, Theorem 1 gives a free theorem that is exactly uniform continuity: 11 1 .E>0..d>0..x, \nx .|x-x |<d . |LMJ .Met x-LMJ .Met x |<E This de.nition differs from the E-d de.nition of (regular) continuity \nby the order of quanti.cation: there, .x comes before .d, so the distance d may depend on x. We suspect \nthat to express standard continuity as a type would require some form of type dependency. Chaudhuri, \nGulwani and Lublinerman [8] have given a program logic based approach to verifying the continuity of \nprograms. Function Sensitivity A type system with a relational interpreta\u00adtion that tracks distances \nbetween values has been investigated by Reed and Pierce [17] in the setting of differential privacy. \nTheir system uses a linear type discipline to ensure that all programs are c-sensitive (i.e., the distance \nbetween the outputs is no greater than c times the distance between the inputs, for some constant c). \nWe can express their central concept of c-sensitivity (for functions on the reals) as an algebraically \nindexed type: .E:R>0 . real(E) . real( 1 E). Investigating the precise connection between their sys\u00adtem \nand ours is left to future work. 8. Discussion We presented a general framework for algebraically indexed \ntypes and instantiated it to yield novel type systems for geometry, log\u00adical information .ow and distance-indexed \ntypes. Our framework further demonstrates the power of relational reasoning about typed programs. From \nTheorem 1, we derived interesting free theorems, type isomorphisms and non-de.nability results. We conclude \nwith some observations and suggestions for further work. Further Applications and Extensions We have \ncovered several applications of algebraically indexed types in this paper, but there are undoubtedly \nmany more. Geometry for dimensions greater than two is an obvious candidate, as are systems that are \ninvariant un\u00adder different geometric groups (e.g., the Poincar\u00b4e group for relativ\u00adity). Mathematical \nPhysics is particularly rich in theories that have some notion of invariance, and it will be exciting \nto pin down the precise connections between these and type systems for which an Abstraction Theorem holds. \nCardelli and Gardner describe a pro\u00adcess calculus that builds in 3D af.ne geometry [6], proving that \nprocess behaviour is invariant under af.ne transformations. Distin\u00adguishing points from vectors provides \nthe appropriate abstraction barrier, and the geometric group is determined by inspecting term syntax. \nIt would be interesting to recast their language in terms of our indexed types to obtain purely type-based \ninvariance theorems. Geometric theorem proving is another application. Harrison [10] comments on the \npervasiveness of invariance properties in this area. Programs in our framework automatically satisfy \ninvariance properties, removing the need for ad hoc proofs of these facts. Type and effect analyses use \ntypes indexed by effect annotations with algebraic structure (e.g., sets of read/write effect labels \nwith an idempotent monoid structure). Benton et al. have used relational interpretations to prove effect-dependent \nequivalences [4]. An ex\u00ad tension of our framework with type-indexed types should be able to express their \neffect-indexed monads and prove their equivalences. Extending our framework with type dependency would \nalso al\u00adlow for further applications. For example, we could consider a type of lists of length n, indexed \nby elements of the permutation group Sn. Bernardy et al. have presented a general framework for rela\u00adtional \nreasoning and an Abstraction Theorem for dependent types [5]. However, they work with pure type systems, \nwhich de.ne type equality via untyped rewriting, so it is not immediately obvious how to integrate arbitrary \nequational theories into their framework. Semantic Equality In general, the semantic equality in De.\u00ad \nnition 2 is not an equivalence relation. If the interpretations of all primitive types are partial equivalence \nrelations then semantic equality is indeed an equivalence relation. However, this excludes the geometry \nand distance-indexed examples. More generally, we can consider relational interpretations that are difunctional. \n(A re\u00adlation is difunctional if whenever (x, y), (x 1 , y 1) and (x, y 1) are in the relation then so \nis (x 1 , y).) Difunctionality is weaker than being a PER, but still suf.ces to prove that semantic equality \nis an equivalence relation. Hofmann [11] has used difunctional relations in the setting of effect analyses. \nDifunctionality covers all our ex\u00adamples except distance-indexed types. Note that for both PERs and difunctional \nrelations we need to close the relational interpretation of existential types under the appropriate property \nto ensure that all types are interpreted as PERs/difunctional relations. For distance\u00adindexed types it \nis possible that a new notion of equivalence based on closeness is required. Acknowledgements The authors \nwould like to thank Nick Benton, Kenneth MacKenzie, John Reppy and Martin Will for illuminating discussions \non geom\u00adetry and types. Atkey and Johann were supported by EPSRC grant EP/G068917/1. References [1] M. \nAbadi, A. Banerjee, N. Heintze, and J. G. Riecke. A Core Calculus of Dependency. Proceedings, POPL, pp.147-160, \n1999. [2] R. Atkey. Syntax for Free: Representing Syntax with Binding Using Parametricity. Proceedings, \nTLCA, pp. 35-49, 2009. [3] N. Benton, C.-K. Hur, A. J. Kennedy, C. McBride. Strongly Typed Term Representations \nin Coq. Journal of Automated Reasoning 49(2), pp. 141-159, 2012. [4] N. Benton, A. Kennedy, M. Hofmann, \nL. Beringer. Reading, Writing and Relations. Proceedings, APLAS, pp. 114-130, 2006. [5] J.-P. Bernardy, \nP. Jansson, R. Paterson. Proofs for Free: Parametricity for Dependent Types. Journal of Functional Programming \n22(2), pp. 107-152, 2012. [6] L. Cardelli, P. Gardner. Processes in Space. Programs, Proofs, Processes: \nProceedings, CiE, pp. 78-87, 2010. [7] Computational Geometry Algorithms Library (CGAL): User and Reference \nManual. Available at http://www.cgal.org. [8] S. Chaudhuri, S. Gulwani, and R. Lublinerman. Continuity \nAnalysis of Programs. Proceedings, POPL, pp. 57-70, 2010. [9] J. Gallier. Geometric Methods and Applications \nFor Computer Science and Engineering. Springer, 2011. [10] J. Harrison. Without Loss of Generality. Proceedings, \nTPHOLs, pp. 43-59, 2009. [11] M. Hofmann. Correctness of Effect-based Program Transformations. Formal \nLogical Methods for System Security and Correctness, pp. 149-173, 2008. [12] M. P. Jones. Functional \nProgramming with Overloading and Higher-Order Polymorphism. Proceedings, AFP, pp. 97-136, 1995. [13] \nA. J. Kennedy. Relational Parametricity and Units of Measure. Proceedings, POPL, pp. 442-455, 1997. [14] \nA. J. Kennedy. Types for Units-of-Measure: Theory and Practice. Central European Functional Programming \nschool (CEFP), pp. 268 305, LNCS vol. 6299, 2010. [15] S. Mann, N. Litke, T. DeRose. A Coordinate Free \nGeometry ADT. Technical Report CS-97-15, University of Waterloo, 1997. [16] A. M. Pitts. Parametric Polymorphism \nand Operational Equivalence. Mathematical Structures in Computer Science 10(3), pp. 321-359, 2000. [17] \nJ. Reed and B. C. Pierce. Distance Makes the Types Grow Stronger. Proceedings, ICFP, pp. 157-169, 2010. \n[18] J. C. Reynolds. Types, Abstraction and Parametric Polymorphism. Information Processing 83, pp. 513-523, \n1983. [19] A. Sabelfeld and D. Sands. A PER Model of Secure Information Flow in Sequential Programs. \nHigher-Order and Symbolic Computation 14 (1), pp. 59-91, 2001. [20] N. Shikuma and A.Igarahsi. Proving \nNoninterference by a Fully Complete Translation to the Simply Typed lambda-calculus. Logical Methods \nin Computer Science 4(3), 2008. [21] S. Tse and S. Zdancewic. Translating Dependency into Parametricity. \nProceedings, ICFP, pp. 115-125, 2004. [22] P. Wadler. Theorems for Free!. Proceedings, FPCA, pp. 347-359, \n1989.   \n\t\t\t", "proc_id": "2429069", "abstract": "<p>Reynolds' relational parametricity provides a powerful way to reason about programs in terms of invariance under changes of data representation. A dazzling array of applications of Reynolds' theory exists, exploiting invariance to yield \"free theorems\", non-inhabitation results, and encodings of algebraic datatypes. Outside computer science, invariance is a common theme running through many areas of mathematics and physics. For example, the area of a triangle is unaltered by rotation or flipping. If we scale a triangle, then we scale its area, maintaining an invariant relationship between the two. The transformations under which properties are invariant are often organised into groups, with the algebraic structure reflecting the composability and invertibility of transformations.</p> <p>In this paper, we investigate programming languages whose types are indexed by algebraic structures such as groups of geometric transformations. Other examples include types indexed by principals--for information flow security--and types indexed by distances--for analysis of analytic uniform continuity properties. Following Reynolds, we prove a general Abstraction Theorem that covers all these instances. Consequences of our Abstraction Theorem include free theorems expressing invariance properties of programs, type isomorphisms based on invariance properties, and non-definability results indicating when certain algebraically indexed types are uninhabited or only inhabited by trivial programs. We have fully formalised our framework and most examples in Coq.</p>", "authors": [{"name": "Robert Atkey", "author_profile_id": "81436601799", "affiliation": "University of Strathclyde, Glasgow, United Kingdom", "person_id": "P3977923", "email_address": "robert.atkey@strath.ac.uk", "orcid_id": ""}, {"name": "Patricia Johann", "author_profile_id": "81100058482", "affiliation": "University of Strathclyde, Glasgow, United Kingdom", "person_id": "P3977924", "email_address": "patricia.johann@strath.ac.uk", "orcid_id": ""}, {"name": "Andrew Kennedy", "author_profile_id": "81100450709", "affiliation": "Microsoft Research Cambridge, Cambridge, United Kingdom", "person_id": "P3977925", "email_address": "akenn@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429082", "year": "2013", "article_id": "2429082", "conference": "POPL", "title": "Abstraction and invariance for algebraically indexed types", "url": "http://dl.acm.org/citation.cfm?id=2429082"}