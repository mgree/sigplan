{"article_publication_date": "01-23-2013", "fulltext": "\n Deadlock-freedom-by-design: Multiparty Asynchronous Global Programming Marco Carbone Fabrizio Montesi \nIT University of Copenhagen {carbonem,fmontesi}@itu.dk Abstract Over the last decade, global descriptions \nhave been successfully employed for the veri.cation and implementation of communi\u00adcating systems, respectively \nas protocol speci.cations and chore\u00adographies. In this work, we bring these two practices together by \nproposing a purely-global programming model. We show a novel interpretation of asynchrony and parallelism \nin a global setting and develop a typing discipline that veri.es choreographies against protocol speci.cations, \nbased on multiparty sessions. Exploiting the nature of global descriptions, our type system de.nes a \nnew class of deadlock-free concurrent systems (deadlock-freedom-by\u00addesign), provides type inference, \nand supports session mobility. We give a notion of Endpoint Projection (EPP) which generates correct \nentity code (as p-calculus terms) from a choreography. Finally, we evaluate our approach by providing \na prototype implementation for a concrete programming language and by applying it to some ex\u00adamples from \nmulticore and service-oriented programming. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: \nFormal De.nitions and Theory; F.3.2 [Semantics of Pro\u00adgramming Languages]: Process Models General Terms \nDesign, Languages, Theory Keywords Concurrency, Choreography, Types, Sessions. 1. Introduction Global \ndescriptions represent a powerful paradigm for designing communicating systems where the programmer gives \na global view of how messages are exchanged during execution, instead of sep\u00adarately de.ning the behaviour \nof each endpoint (entity). Then, the local behaviour of each endpoint can be automatically generated \nby means of EndPoint Projection (EPP). The paradigm has been studied in formal models [10, 15, 22, 26], \nstandards [1, 37], and language implementations [23, 33, 36]. Global descriptions have a great impact \non the quality of software, as they represent formal blueprints of how communicating systems should behave \nand of\u00adfer a concise view of the message .ows enacted by a system. In particular, they (i) lower the \npossibility of introducing program\u00adming errors and (ii) ease the task (both manual and automatic) of \ndetecting them. Global descriptions can be used at different lev- Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 13, January 23 25, 2013, Rome, Italy. \nCopyright &#38;#169; 2013 ACM 978-1-4503-1832-7/13/01. . . $10.00  els of abstraction, ranging from \nabstract descriptions of protocols to descriptions of concrete system implementations, dubbed chore\u00adographies. \nThese different incarnations respectively underpin two recent and successful development methodologies. \nIn the .rst methodology, programmers design abstract protocols using global descriptions [22, 23]. These \nare automatically pro\u00adjected onto abstract endpoint speci.cations which are .nally used for the static \nveri.cation of manually written endpoint code: protocol projection endpoint validation Abstract Endpoint \n- ----------. - ----------. Protocols Endpoints Code The approach above has the bene.t of producing \nvery clear pro\u00adtocol speci.cations. However, it deprives the programmer from a global view of the system \nwhen dealing with its implementation. A major consequence is that programming becomes error-prone when \ndealing with the actual interleaving of different protocol instances. For example, it can easily lead \nto deadlocked systems [7]. The second methodology deals with system implementations using choreographies \n[36, 37]. Programmers can write a choreog\u00adraphy and then automatically project an executable system from \nit: choreography projection Choreography --------------. Endpoint Code Here, the main advantage is the \nprecise view given by chore\u00adographies on the possible system executions. However, choreogra\u00adphies lack \nin abstraction wrt global protocol descriptions and their programming needs to be disciplined with additional \ntools. Cur\u00adrent disciplines for choreography-driven programming are based on writing abstract endpoint \ndescriptions and then using them to check the behaviour of each endpoint, directly on the choreogra\u00adphy \nor its EPP [15, 36]. Hence, in these models, we lose a global view of the system when describing its \nprotocol speci.cations. Inspired by these observations and by private conversations with our industry \ncollaborators [2, 20, 31, 35, 37], we ask: Can we design a uni.ed framework that combines global descriptions \nof protocols and implementations? Clearly, a positive answer would retain the advantages of global de\u00adscriptions \nfor both the writing of protocols and that of implemen\u00adtations. Moreover, a natural following question \nis whether such a uni.ed framework could offer more than just the sum of the parts: are there other advantages \nthat can arise from the combination of global protocol descriptions with choreographies? In order to \nanswer the questions above, we build and analyse a model for a fully global framework. In our model, \ndevelopers de\u00adsign both protocols and implementations from a global viewpoint. Endpoint implementations \ncan then be automatically generated: Protocols global validation -------. Choreography choreography projection \n Endpoint ---------. Code  The challenge of reaching our objective is twofold. First, since we aim at \ndesigning a model where choreographies can instanti\u00adate different protocols multiple times and interleave \ntheir execu\u00adtion, the model should ensure that these interleavings will not lead to bad behaviour. Second, \nit is not clear how common aspects of concurrent systems such as asynchrony (communications are asyn\u00adchronous) \nand parallelism (parallel executions) should in.uence the interpretation of a choreography: choreographies \ndescribe com\u00admunications as atomic actions, making concurrency less explicit. Main contributions. We \nprovide the following contributions: Multiparty Choreographies. We introduce a choreography model with \nmultiparty protocol instances (sessions) as .rst-class elements (\u00a7 3) and provide an EPP that, under \nsimple restrictions, correctly generates endpoint code from a choreography (\u00a7 5). Asynchrony and Parallelism. \nOur framework gives a novel and concise interpretation of asynchrony and parallelism, by inferring the \nimplicit concurrent behaviour speci.ed in a choreography (\u00a7 3). Typing and Type inference. We provide \na type system (\u00a7 4) for checking choreographies against protocol speci.cations given as multiparty session \ntypes [22]. Our type analysis plays a major role in ensuring the correctness of EPP code. Interestingly, \ndue to the global nature of choreographies, our framework can generate cor\u00adrect endpoint code that is \nnot allowed by current multiparty session typings (\u00a7 5, Typing expressiveness). We also give a type inference \ntechnique supporting the opposite methodology, i.e., extracting the protocols implemented in a choreography \n(\u00a7 4, Type inference). Delegation. This is the .rst work to provide a choreography model supporting session \ndelegation, a mobility mechanism for delegating the continuation of a protocol (\u00a7 3). Due to asynchrony \nand paral\u00adlelism, typing delegation (\u00a7 4) is nontrivial since messages prior to and after delegation \nmay be interleaved, making it dif.cult to check that channel ownerships are consistently respected. Deadlock-freedom-by-design. \nOur framework seamlessly guaran\u00adtees deadlock freedom (\u00a7 5, Corollary 1), a notoriously hard prob\u00adlem \nin multiparty sessions types [7]. This feature follows from us\u00ading a choreography as initial design tool. \nImplementation and Evaluation. We provide a prototype imple\u00admentation of our framework (\u00a7 6), featuring \na programming lan\u00adguage (Chor), an IDE, and an EPP that support the development of concurrent systems \nusing our global methodology. We use Chor to evaluate our programming model against examples of different \nnature, from multicore to distributed programming (\u00a7 7). Proofs and full de.nitions can be found in [14]. \n2. Model Preview In this section we give an informal description of our model, whose key elements are \nprotocols and choreographies. A protocol is an In this paper, we introduce a choreography model for \nglobally implementing protocols such as the one above. Its core elements are threads and sessions. A \nthread represents a (logical) processing unit that executes a sequence of instructions. Each thread has \nits own local variables, and can exchange messages with other threads by performing I/O communications. \nThreads can be programmed to be already active or dynamically created at runtime. A session is an instance \nof a protocol and implements communications between some threads. Sessions can be dynamically created \nby threads. Example 2 (Two-buyer choreography). We give a choreography implementing the two-buyer protocol \nin Example 1. 1. b1[B1], b2[B2] start s[S] : a(k); 2. b1[B1].book -> s[S].x1 : k; 3. s[S].quote(x1) \n-> b1[B1].y1 : k; 4. s[S].quote(x1) -> b2[B2].z1 : k; 5. b1[B1].contrib(y1) -> b2[B2].z2 : k; 6. if \n(z1 - z2 = 100)@b2 7. then b2[B2] -> s[S] : k[ok]; 8. b2[B2].addr -> s[S].x2 : k; 9. s[S].ddate -> \nb2[B2].z3 : k 10. else b2[B2] -> s[S] : k[quit]  In Line 1, threads b1, b2 and freshly spawned thread \ns start a session k through public channel a playing roles B1, B2 and S respectively. In Lines 2-5, b1 \nasks s for book book and gets back the quote quote(book) which is also sent to b2. Note that, e.g., b1 \nuses its local variable y1 to receive the evaluation of quote(book) . Then, b1 tells b2 the amount she \nwishes to contribute for the purchase, namely contrib(quote(book)) . In Line 6, b2 evaluates the offer \nreceived by b1 in the guard (z1 - z2 = 100)@b2. If positive, b2 communicates her decision with the selection \nb2[B2] -> s[S] : k[ok], sends her address addr and receives the delivery date ddate (Lines 7-9). Otherwise, \nb2 aborts by selecting quit in Line 10. Observe that the structure of session k in Example 2 is that \nof the protocol given in Example 1. The only differences are that data has become explicit and that we \nintroduced the start primitive. The latter allows threads to synchronise on a public name, e.g., a, and \ncreate new threads and sessions. In Line 1 of Example 2, b1 and b2 are already active threads while s \nis a service thread, i.e., a dynamically spawned thread. Active threads appear on the left-hand side \nof the start keyword, whereas (fresh) service threads appear on its right-hand side. Role annotations, \ne.g., b1[B1], relate each thread to the role it plays in a session. Example 3 (Two-buyer-helper choreography). \nChoreographies can also describe multiple, interleaved instances of multiple proto\u00adcols. Hereafter, we \nextend the two-buyer choreography from Ex\u00adample 2 with two other sessions, k\" and k\"\", that b1 and b2 \nwill respectively use for getting help in the transaction. abstract speci.cation of the structure of \nsome communications in ...as Lines 1-5 in Example 2... a system, whereas a choreography describes a concrete \nsystem 6. b1[B] start h1[H] : b(k\");implementing one or more protocols. We represent protocols with \n7. b1[B].(contrib(y1)/2) -> h1[H].y : k\" . . . . . . . . . . . . . ; global types [22], global descriptions \nwhere entities are abstracted 8. b1[B] -> h1[H] : k\"[done]; as roles that communicate following a given \nconversation structure. 9. b2[B] start h2[H] : b(k\"\"); C1 C2 Example 1 (Two-buyer protocol). In this \nprotocol, two buyers B1 10. b2[B].((z1 - z2)/2) -> h2[H].z : k\"\"; 11. b2[B] -> h2[H] : k\"\"[del]; and \nB2 wish to share the purchase of a product from a seller S: \" : k\"\"; 12. b2[B].z1 -> h2[H].z 1. B1 -> \nS : (string); S -> B1 : (int); S -> B2 : (int); B1 -> B2 : (int); 13. b2[B] -> h2[H] : k\"\"((k[B2])); \n2. B2 -> S : { ok : B2 -> S : (string); S -> B2 : (date), quit : end } 14. if ((z/z\") = 30%)@h2 Above, \nB1, B2 and S are called roles. Buyer B1 sends to a seller S 15. then h2[B2] -> s[S] : k[ok]; a purchase \nrequest of type string. Then, S sends a quote to B1 and another potential buyer B2. Thereafter, B1 tells \nB2 the amount she wishes to contribute with. Afterwards, B2 noti.es S of whether she 16. h2[B2].addr \n-> s[S].x2 : k; C3 \"\" : k 17. s[S].ddate -> h2[B2].z 18. else h2[B2] -> s[S] : k[quit]  has accepted \n(ok or quit). If so, B2 sends to S a string (address) The choreography starts with the .rst 5 lines of \nthat in Example 2. and, .nally, S replies with a delivery date of type date. In block C1, b1 starts a \nnew session with a helper h1, asks it to contribute for half of its part (Line 7), and informs it that \nit does not need to do more (Line 8). On the other hand, in block C2, b2 does the same with another thread \nh2 until Line 11. Differently now, b2 asks h2 to continue session k by taking on its role (Line 11). \nThen, it sends the total price received from s to h2 (Line 12) and delegates the session reference (Line \n13). Finally, in block C3, h2 completes the two-buyer protocol instead of b2, checking that its own contribution \nis less than 30% of the total price. Note that h1 and h2 are started through the same public channel \nb, which acts as a reusable shared channel in multiparty session types [22]. Our model has two features \nthat interestingly in.uence chore\u00adography interpretation in subtly different ways. Firstly, parallelism: \nthread executions may concurrently proceed without any predeter\u00admined ordering unless causal constraints \nare introduced. Secondly, asynchrony: communications are asynchronous, so a thread may send a message \nto another thread and then immediately proceed before the message has actually been delivered by the \nnetwork. For instance, in Example 3, the threads whose behaviour is de\u00adscribed in blocks C1 and C2 are \ndifferent (b1 and h1 for C1, b2 and h2 for C2). Therefore, their executions may interleave due to paral\u00adlelism. \nE.g., b2 and h2 may start session k \"\" before b1 and h1 start session k \". Even more, k \"\" may be completely \nexecuted before k \" is started. Hence, the interpretation of C1; C2 should be equivalent to that of C2; \nC1, and, in general, to that of any interleaving of C1 and C2. Furthermore, in Lines 3 and 4 of Example \n2, where s sends the quote to b1 and then b2, it may happen that b2 (Line 4) receives the quote before \nb1 due to asynchronous messaging. Parallelism and asynchrony are respectively handled by our swapping \nrelation and our asynchronous semantics, both formalised in the next section. In general, we say that \nour relaxed sequential operator lifts the programmer from expressing the degree of concurrency (asyn\u00adchrony \nand parallelism) of a system. Indeed, our framework will automatically infer the latter by looking at \nthe thread identi.ers. We made this choice in favour of design minimality and simplicity. In real tools, \ncombining the sequential operator with explicit prim\u00aditives for, e.g., parallelism, may be preferrable \nfor clarity purposes. We discuss this in \u00a7 9, Sequential and Parallel Operators. 3. Choreographies with \nMultiparty Sessions We introduce the Global Calculus (GC), a choreography model with multiparty asynchronous \nsessions. Syntax. The syntax of our calculus is reported in Figure 1. C ::= .; C (sequence) | if e@t \nthen C1 else C2 (conditional) | 0 (inaction) | rec X(.k, \" in C (recursion) x@t , t) = C | X(ek, (call) \ne@t , t) | (.r) C (restriction) . ::= t1[p].e -> t2[q].x : k (communication) | t1[p] -> t2[q] : k[l] \n(selection) | t1[p] -> t2[q] : k((k \" [p \" ])) (delegation) | t1[p1], ..., tn[pn] start tn+1[pn+1], ..., \ntm[pm] : a(k) (start) Figure 1. Global Calculus with Multiparty Sessions, syntax. C is a choreography, \nt is a thread, and k is a session (identi.er). Interactions between threads are speci.ed by the term \n.; C which reads: the system may execute the interaction . and continue as C. We distinguish four different \nkinds of interaction: (start), (commu\u00adnication), (selection), and (delegation). (start) denotes session \nini\u00adtiation: threads ti (for 1 = i = m) start a new multiparty session through public channel a and tag \nit with a fresh identi.er k, called session channel. The .rst n threads, dubbed the active threads, are \nalready running, while tn+1, . . . , tm, dubbed the service threads, are dynamically created and started. \nWe assume that m = 2 (a ses\u00adsion has at least two participants) and n = 1 (a session is started by at \nleast one running thread). The pi s denote the roles played by the threads in the session. (communication) \ndenotes a communication where thread t1 sends, over session k, the evaluation of a .rst-order expression \ne to thread t2, which binds it to variable x 1. In (selec\u00adtion), t1 communicates to t2 her selection \nof branch l. Through (delegation), t1 delegates to t2 over k her role p \" in session k \" . GC also offers \nother standard programming language con\u00adstructs. In (conditional), expression e is labelled with a thread \nname, indicating where it is evaluated. (recursion) and (call) model standard recursive procedures, where \neach variable in x or expres\u00adsion in e , respectively, is located at a thread in t . In (call), we as\u00adsume \nthat each expression can only be either a variable or a value. (restriction), which is only used at runtime \nand cannot be used in programs, models name restriction. r (for restricted name) can be a thread or a \nsession channel. The term 0 denotes termination. In a term .; C, . can bind session channels, threads \nand variables. When . is a (start), t1, . . . , tn are free while k and tn+1, . . . , tm are bound (since \nthey are freshly created). If . is a (communication), variable x is bound. As usual, r is bound in (.r) \nC. We often omit 0, empty vectors, and irrelevant variables. In the remainder, (.r1, . . . , rn) is a \nshortcut for (.r1) . . . (.rn). Semantics. Above, we stated that the term .; C speci.es a system that \nmay execute the interaction . and then continue as C. Threads, however, are assumed to run in parallel. \nAs a consequence, some actions in C may be performed before .. For example, blocks C1 and C2 from Example \n3 describe the behaviour of different threads. Therefore, as discussed in \u00a7 2, in an actual system run \nof these threads, their executions may interleave due to parallelism. To deal with such cases, we de.ne \nthe swapping congruence relation .C, which allows permutations of this kind of interaction sequences2 \n. .C is de.ned as the smallest congruence satisfying the rules in Figure 2. .C exchanges terms with different \nthreads. The top rule swaps two conditionals: C1 \" and C2 are swapped to preserve the semantics of the \nterm wrt the evaluations of the conditions. The bottom-left rule swaps two interactions . and . \" that \ndo not share any thread names (calculated by thr(.)). The bottom-right rule swaps an interaction . out \nof a conditional if it pre.xes both branches and does not involve the thread that checks the condition. \nAsynchronous messaging can cause situations as the one dis\u00adcussed for Lines 3 and 4 of Example 2 in \u00a7 \n2, where s sends the quote to b1, then to b2, and b2 may receive the quote before b1. Unlike for parallelism, \nwe address this issue directly in the opera\u00adtional semantics. This is because asynchrony is somehow asymmet\u00adric: \neven though the receiving actions may interleave in a different order wrt that in the choreography, the \nsending actions instead will surely happen in the speci.ed order, since the thread performing the outputs \nis the same. This is different from parallelism, where the ordering of both receiving and sending actions \nmay change. It is unsafe to manipulate the syntax of the choreography for simulat\u00ading asynchrony, since \nwhen we will generate the code for the sender thread (cf. \u00a7 5) remembering the order of outputs will \nbe important. Figure 3 contains the rules de.ning the labelled reduction se\u00admantics for GC, whose labels \n. are de.ned as: . ::= . | if@t | (.r) . 1 For clarity, we annotate threads with roles. This is necessary \nonly for (start) since roles can be inferred from session identi.ers in all other terms. 2 Handling parallelism \nwith a congruence simpli.es our development, since swaps in a choreography do not in.uence the behaviour \nof its EPP [14]. \" t = t \"\" \"\" if e@t then ( if e \" @t \" then C1 else C2 ) else ( if e \" @t \" then C \nelse C ) C if e \" @t \" then (if e@t then C1 else C ) else (if e@t then C2 else C ) 12 12 thr(.) n thr(. \n\" ) = \u00d8 t . thr(.) .; . \" C . \" ; . if e@t then (.; C1) else (.; C2) C .; if e@t then C1 else C2 Figure \n2. Global Calculus with Multiparty Sessions, swap relation C. . lC |ACTl . . {(selection), (delegation), \n(start)} . .; C -. (.r ) Cr = bn(.) .[v/e] lC |COMl . = t1[p].e -> t2[q].x : k . .; C - ---. C[v/x@t2] \n(e . v)  ..snd(.) . fn(.) r = bn(.) . = (start) \" lC |ASYNCl r) C \" C -. (. . .; C -. (.r ) .; C rcv(.) \n. fn(.) r . fn(.)if@t lC |IFl if e@t then C1 else C2 ---. Ci (i = 1 if e . true , i = 2 otherwise) .. \n\" lC |CTXl C1 -. C \" . k, -. rec X(x@t, t) = C2 in C rec X(x@t, t) = C2 in C1 k, 1 1 .(.r) . \" lC |RESl \nC -. C \" . (.r) C -----. (.r) C .. \" \" lC |EQl C1 R C C \" -. C \" C R C2 . C1 -. C2 R . { C, =} 11 22 \n Figure 3. Global Calculus with Multiparty Sessions, semantics. A label is either an interaction ., an \ninternal action if@t by thread t (conditional), or another label with restricted name r (when new threads \nor session channels are created). Rule LC |ASYNCl captures the asynchronous behaviour of endpoint systems, \nallowing a thread to send a message and then proceed freely before the intended receiver actually receives \nit. In the rule, the sender of . performs the action . in the continuation C without waiting for the \nmessage in . to be delivered. We check that the receiver of . is not involved in . since otherwise causality \nbetween . and . would be violated. Finally, . is kept for the later observation of the message delivery. \nRule LC |ACTl models interactions that are not (communication). In the reductum, if . is a (start) then \nr contains the freshly created service threads and the session channel. For all other cases, r is empty. \nIn LC |COMl, we substitute variable x with value v (the evaluation of the expression e in a system that \nwe leave unspeci.ed) with the smart substitution C[v/x@t], which substitutes x with v only under the \nfree name t in C, modelling local variables. In rule LC |EQl, the relation R can be either the swapping \nrelation C or structural congruence =. Structural congruence handles name restriction and recursion unfolding. \nWe just mention the rule for unfolding: rec X( @k, = C \" in X(@k, = x@t, t ) v@t , t ) rec X( @k, \" in \nC v/ t ]. All other rules are standard x@t , t ) = C \" [ x@ and can be found in [14]. Choreographies \nenjoy deadlock-freedom since every term but 0 has a corresponding semantic rule that can reduce it. Formally, \nTheorem 1 (Deadlock-Freedom). Let C = 0 and contain no free . variable names. Then, there exist C \" , \n. such that C -. C \" . 4. Typing Choreographies We now present our typing system which allows to specify \nproto\u00adcols in terms of global types [7, 22] and then check whether session behaviours in a choreography \nrespect them. Syntax. Figure 4 contains the syntax of global types. p -> q : (U); G abstracts an interaction \nfrom role p to role q with continua\u00adtion G, where U, referred to as the carrying type, is the type of \nthe exchanged message. U can either be a basic type S or G@p. Com\u00admunicating G@p means that a sender \nrole delegates to another role her role p in protocol G. In p -> q : {li : Gi}i.I , role p can select \none label li and continue as Gi. All other terms are standard. G ::= p -> q : (U); G (communication) \n| p -> q : {li : Gi}i.I (choice) | end (inaction) | rec t; G (recursion) | t (call) U ::= S | G@p (values) \nS ::= bool | int | string | . . . (sort) Figure 4. Global Types, syntax. Semantics. We give a semantics \nfor global types, which expresses a the (abstract) execution of protocols. G -. G \" is the smallest \nrelation on the recursion-unfolding of global types satisfying the rules given in Figure 5. A label a \nshows which interaction is con\u00adsumed. Since our discussion on asynchrony and parallelism applies also \nto protocols, we need to capture these aspects also in their se\u00admantics. Similarly to LC |ASYNCl, LG \n|ASYNC-COMl models asynchrony in global types by allowing a sender role to proceed before the corre\u00adsponding \nreceiver has actually received the message. LG |ASYNC-BRANCHl does the same for branching. Observe that \nsince we are allowing an asynchronous action from inside branch Gj to take place, we re\u00adstrict the branching \nto the choice lj : Gj in order to disable the other branches. In LG |SWAPl, the relation G for global \ntypes models parallelism and is de.ned similarly to C; formally, it is the small\u00adest congruence satisfying \nthe rules in Figure 6. The rules are similar to the ones for C where conditional is now replaced by branching. \nType checking. We now introduce our multiparty session typing, which checks that sessions in a program \n(choreography without re\u00adstrictions) follow the protocol speci.cations given as global types. We use \nthree kinds of typing environments: (Service Env) G ::= G, a( p || q ) : G | G, x@t : S | \u00d8 | G, X : \n(G, T, .) (Thread Env) T ::= T, t : k[p] | \u00d8 (Session Env) . ::= ., k : G | \u00d8  A service environment \nG carries the global type of each public channel, specifying how a session has to be executed after initiali\u00adsation. \nIn a(p || q ), p and q are the roles of the active and service p -> q:(U) p -> q:lj lG |COMl p -> q \n: (U); G -------. G lG |BRANCHl p -> q : {li : Gi}i.I.{j} - ----. Gj aa G[rec t; G/t] - . G \" G1 G G \n\" - . G \" G G2 1 2 lG |RECl lG |SWAPl aa rec t; G - . G \" G1 - . G2 aa. G \" G - . G \" p . roles(a), \nq . roles(a) Gj - j p . roles(a), q . roles(a) lG |ASYNC-COMl lG |ASYNC-BRANCHl aa p -> q : (U); G - \n. p -> q : (U); G \" p -> q : {li : Gi}i.I.{j} - . p -> q : {lj : G \" } j Figure 5. Global Types, semantics. \n\" \" {p, q} n {p , q } = \u00d8 lGS |COM-COMl \"\"\" \"\"\" p -> q : (U); p -> q : (U ) G p -> q : (U ); p -> q \n: (U) \" {p, q} n {p , q \" } = \u00d8 lGS |COM-CHOICEl \"\" \"\" p -> q : {li : p -> q : (U); Gi}i.I G p -> q \n: (U); p -> q : {li : Gi}i.I \" {p, q} n {p , q \" } = \u00d8 lGS |CHOICE-CHOICEl \"\"\" \"\"\" p -> q : {li : p \n-> q : {l : Gij }j.J }i.I G p -> q : {l : p -> q : {li : Gij }i.I }j.J j j Figure 6. Global Types, swap \nrelation G. threads respectively. G also keeps the sort types of variables and all environments necessary \nfor typing recursive procedures. A thread environment T keeps track of which role each thread is playing \nin a session. Finally, a session environment . records the type of each running session k. We assume \nthat we can write G, a : G only if a does not occur in G; the same holds for . wrt sessions k. Further\u00admore, \nwe can write T, t : k[p] only if t is not associated to any other role in the same session k in T. Consequently, \na thread can participate in multiple sessions playing different roles, but it cannot participate in the \nsame session with more than one role. Typing judgements have the shape G; T h C t .. Intuitively, C is \nwell-typed provided that public channels are used according to G, threads play roles according to T, \nand session channels are used according to .. Figure 7 contains the typing rules. Rule LGT |STARTl types \na (start) term by checking that, in the subterm C, session k is used according to the type G of public \nchannel a. Also, each thread ti is checked to play role pi in C when using session k. We require all \nroles pi to occur in G (roles(G)), enforcing that each thread communicates at least once in the session. \nWe abuse nota\u00adtion tn+1, . . . , tm . T for checking that threads tn+1, . . . , tm are not (associated \nto any session) in T, ensuring their freshness. In LGT |COMl we check that, given an interaction between \nt1 and t2 over session channel k, (i) the global type for k in the session en\u00advironment requires a communication \nof type S between role p and role q, (ii) t1 plays role p and t2 plays role q according to T, and (iii) \nexpression e and variable x have type S according to G. Rule LGT |SELl deals with selection and is similar \nto LGT |COMl, although we now check that the chosen label is among the ones allowed by the type. LGT \n|DELl addresses session delegation: it transfers the owner\u00adship of role p \" in session k \" and checks \nthat the carrying type in the session type of k is the type of the continuation of k \" . LGT |RECl types \na recursive procedure and the choreography in which it is used. The recursion body is checked using only \nthe types of its parame\u00adters (stored in G), public channels (Gsrv), and giving the possibility to invoke \nother procedures (Grec). All other rules are standard. For instance, the protocol in Example 1 types \nchannel a in Example 2. Runtime typing. For showing that well-typed programs never go wrong, we need \nto extend our typing to runtime choreographies. In particular, we need to deal with two issues: asynchronous \ndelega\u00adtions and parallelism. Hereby, we give an intuition of these issues and how we deal with them \n(see [14] for details). Asynchronous Delegation. We check runtime choreographies with new judgements \nof the form G; T hS C t .. The extra envi\u00adronment S, the delegation environment, contains information \nabout channels that may have been already delegated by rule LC |ASYNCl. E.g., consider the following \nchoreography: C = t1[p].e -> t2[q].x : k ; t1[p \" ] -> t3[q \" ] : k \" ((k[p])) ; .1 .2 \" t3[p].e -> \nt4[r].y : k .3 By LC |ASYNCl, C may execute .2 before .1 and reduce to .1; .3. When typing .1; .3, we \nneed to remember the delegation .2 in S, since we cannot construct a thread environment T for typing \nboth .1 and .3. Therefore, the choreography .1; .3 would be well\u00adtyped with S = .2 but not with S = \u00d8. \nParallelism can actually make things worse, e.g., .3; .1, a swap of .1; .3, is clearly still safe at \nendpoint, since the output in .1 has already been executed and thus t1 will no longer use k. Our type \nsystem uses S also to gracefully handle these cases. To exemplify how we formalise this mechanism, we \nshow the runtime typing version of rule LGT |COMl: T f t1 : k[p] . delegates(S, t1, k[p]) T f t2 : k[q] \n\u00acdelegated(S, k[q]) G, x@t2 :S; T fS C C k :G, . G f e@t1 : S G; T fS t1[p].e -> t2[q].x : k; C C k : \np -> q : (S); G, . The rule above differs from LGT |COMl in Figure 7 only in the role checks for the \ntwo interacting threads, given in the .rst two lines. In the .rst line, we check that thread t1 plays \nrole p in session k, using T, or that t1 has asynchronously delegated p to another thread, using S through \nthe auxiliary predicate delegates. This covers our example above, where C reduces to .1; .3. In the second \nline, we check that t2 plays role q, as before in rule LGT |COMl for programs. However, now we also need \nto check that t2 has not asynchronously delegated its role to another thread, using another auxiliary \npredicate delegated on S. This condition is necessary for guaranteeing that q is played only by one thread, \nin order to avoid races on the receiving of messages for q in session k. Parallelism. Consider the following \nprotocol: G = p1 -> p2 : (int); p3 -> p4 : (string)  G f a(p1, . . . , pn || pn+1, . . . , pm) : G {p1, \n. . . , pm} = roles(G) G = Gsrv , G1 .1 end only GT |START G; T, t1 : k[p1], . . . , tm :k[pm] f C L \n., k : G tn+1, . . . , tm . T GT |VAR G, X : (G1 , T, .); T f X( k, t ) L ., .1 x@t, G; T f t1[p1], \n..., tn[pn] start tn+1[pn+1], ..., tm[pm] : a(k); C L . G f e@t1 : S T f t1 : k[p], t2 :k[q] G, x@t2 \n: S; T f C L k :G, . . end only GT |COM GT |ZERO G; T f t1[p].e -> t2[q].x : k; C L k : p -> q : (S); \nG, .G; T f 0 L .T f t1 : k[p], t2 :k[q] G; T f C L k :Gj , . j . I G f e@t : bool G; T f C1 L . G; T \nf C2 L . GT |IF GT |SEL G; T f t1[p] -> t2[q]: k[lj ]; C L k : p -> q : {li : Gi}i.I G; T f if e@t then \nC1 else C2 L . 1 : G1 T f t1 : k[p], t2 : k[q] G; T, t2 : k1[p ] f C L k :G, k1 , . GT |DEL 1 1 G; \nT, t1 : k1[p ] f t1[p] -> t2[q]: k((k1[p ])); C L k : p -> q : (G1@p 1); G, k1 : G1 , . C1 G, X : (G| \n , T|t , .| ); T f C L . k Grec, Gsrv , G| ; T|t f L .| k x@t x@t Figure 7. Global Calculus with Multiparty \nSessions, typing rules. GT |REC G; T f rec X( k, in C L . x@t, t) = C1 which can correctly type public \nchannel a in the choreography: t1[p1], t2[p2] start t3[p3], t4[p4] : a(k); C = \" t1[p1].e -> t2[p2].x \n: k; t3[p3].e -> t4[p4].y : k Since {t1, t2} n {t3, t4} = \u00d8, we can swap C with C \" such that: \" t1[p1], \nt2[p2] start t3[p3], t4[p4] : a(k); C = \" t3[p3].e -> t4[p4].y : k; t1[p1].e -> t2[p2].x : k Public channel \na in C \" does not have type G anymore, but C \" is clearly still correct since we can easily follow its \nswap from C in type G using swapping for global types: G G p3 -> q4 : (string); p1 -> p2 : (int) Our \ntype system, however, does not deal with swappings in global types, and would reject C \" . We made this \nchoice so that program\u00admers do not need to think about the swap relations when writing programs, which \ncould make error messages confusing in some cases. However, at runtime, we must consider swaps in order \nto pre\u00adserve well-typedness wrt reductions (Subject Reduction). There\u00adfore, our runtime type system augments \nrules LGT |STARTl and LGT |DELl for typing up to G. Properties. We can now present the expected main \nproperties of k:a our type system. In the sequel, we say that . - -. . \" whenever aG \" k : G is in . \nsuch that G -. and . \" is the result of substituting k : G in . with k : G \" . Also, we write . G . \" \niff dom(.) = dom(. \" ) and .(k) G . \" (k) for all k . dom(.). Theorem 2. Assume G; T hS C t .. Then, \n\" \" . \" (Subject Swap) C C C implies G; T hS C t where . G . \" .  C .  -. C \" implies that there exists \n. \" such that \" t . \" (Subject Reduction) G; T \" hS1 C for some T \" , S \" . (Session Fidelity) if . \nis a communication on session k then k:a . - -. . \" with a and . on the same roles; else, . = . \" . Type \ninference. We exploit the close correspondence between pro\u00adtocols and choreographies to perform type \ninference of public chan\u00adnels. Thus, we can automatically extract protocols from choreogra\u00adphies. First, \nwe de.ne subtyping as set inclusion on branching la\u00adbels, similarly to the covariant typing of rule LGT \n|SELl in Figure 7. Then, we modify our rules to determine the principal type of a choreography. Hereby, \nwe discuss this aspect informally (cf. [14] for the formalisation). We change rule LGT |SELl to require \na sin\u00adgleton branching type for the label of interest. Then, LGT |IFl will have to compute the least \nupper bound (lub) of the session envi\u00adronments .1 and .2 (for C1 and C2 in the branches), by merging \ntheir branching types. Similarly, rule LGT |STARTl will need to update service types in G with the lub \nof all the global types of each session started through the same public channel a. Recursion is handled \nin a standard manner [34]. For example, from b in Example 3, we can infer the type: B -> H : (int); \nB -> H : {done : end, del : B -> H : (int); B -> H : ((. . . as Line 2 in Example 1. . . )@B2)}. 5. Endpoint \nProjection and its Properties We now address endpoint code generation. First, we recall an end\u00adpoint \nmodel that we shall use as a target language. Then, we show how to generate endpoint code for each thread \nin a choreography and, .nally, how to obtain the code for the entire system. Our code generation, the \nEndPoint Projection (EPP), will satisfy the EPP Theorem, which gives a correspondence between the asynchronous \nsemantics of choreographies and the one of endpoint terms. Endpoint model. We model endpoint code with \nthe calculus for multiparty sessions [7], whose syntax includes conditional, par\u00adallel, the inactive \nprocess and recursion plus the following terms, where unboxed terms denote programs: P, Q ||| ::= . . \n. a[p1, . . . , c?p(x); P c!p(e); P pm](k); P | a[p](k); P | c?p((k \" )); P | c!p((c \" )); P | !a[p](k); \nP | c?p &#38; {li : Pi}i.I | c!p . l; P | k : h | (.k) P c ::= k | k[q] h ::= (p, q, w) \u00b7 h | \u00d8 w ::= \nv | l | k[p] The .rst row contains the terms for implementing a session start: request, accept and replicated \naccept respectively. Request and accept are used by active threads, while the latter models a process \nfor spawning service threads. The second row concerns in-session inputs of a value, channel (delegation), \nor label (branching). For c = k, k?p is an input from role p over session k. Dually, the third row has \noutputs, where p in k!p is the role the message is sent to. Example 4. Ps | Pb1 | Pb2 is an endpoint \nimplementation of Ex\u00adample 2 where: 1. n1 = t1, . . . , tn start tn+1, . . . , tm : a and n2 = t -> \nt \" if Ps = !a[S](k); k?B1(x1); k!B1(quote(x1)); k!B2(quote(x1)); ok : k?B2(x2); . . . . t = ti, 1 = \ni = m; or, 2. n1 = t1, . . . , tn start tn+1, . . . , tm : a and n2 = t1 \" , . . . , t \" n n\" +1, . \n. . , t \" : a where t = ti for 1 = i = m and k?B2 &#38; k!B2(ddate), start t m .. quit : 0 t . fn(n2); \nor, 3. n1 = t \" -> t and t . fn(n2). Pb1 = a[B1, B2, S](k); k!S(book); k?S(y1); k!B2(contrib(y1)) a[B2](k); \nk?S(z1); k?B1(z2); if (z1 -z2 =100) n1 -t n2 . C implies that the projection of t for the origi- Pb2 \n= nating node of n2 will not be enabled before that for n1. We use then k!S . ok; k!S(addr); k?S(z3) \nelse k!S . quit dependencies to de.ne linearity: Boxed terms are used only at runtime. A session queue \nk : h is a FIFO queue h for session channel k. A message in h contains the sender and receiver roles, \nand the carried message w (a value v, a label l or a delegated channel k[p]). Messages with different \npairs of roles can be permuted by structural congruence (omitted), simulating a queue per each pair of \nroles [7]. Since messages in a queue have both a receiver and a sender role, in-session inputs and outputs \nare annotated with the executing role at runtime. E.g., the term k[q]!p . l; P is an executing process \nwhich will put the message (q, p, l) in the queue k with sender q and receiver p. Figure 8 contains a \nselection of the rules de.ning the semantics l of terms, where R = !a[pj ](kj ); Qj , I = {1, . . . , \nn} and j.J J = {n + 1, . . . , m}. The .rst rule initiates a session, creating an empty session queue \nk : \u00d8 and substituting every occurrence of session channel k (which will be restricted) with k[pj ] where \npj is the role that must be played by process Pj . Replicated services in R model spawning of new processes. \nThe second rule puts value v, the evaluation of e, in the queue for k. The last rule is about branching: \nit fetches a label lj from the queue and then continues as process Pj . Labels, denoted by \u00b5, annotate \nreductions to make their actions observable. E.g., label !p -> q : k(v) denotes a communication from \nrole p to role q on session channel k carrying v. Similarly, the label for branching starts with a ?, \ndenoting input. Thread projection. We denote with C lt the projection of the behaviour of a thread in \na choreography onto an endpoint term. A selection of the rules de.ning C lt is reported in Figure 9. \nThread projection adds no further ad-hoc communications wrt the originating choreography. In a start, \nwe project the .rst thread to an endpoint request, threads t2, . . . , tn to accepts and threads De.nition \n2 (Linearity). If ni = t1 i , . . . , t i start tni +1, . . . , t i : n m a (i = 1, 2, n = 2) are in \nC and are not in different branches of a (cond), we say C is linear if either .j . {1, . . . , n}..j \n\" . \" {1, . . . , m}. n1 -t1 . . . -t2 n2 or .j . {1, . . . , n}..j . j1 j {1, . . . , m}. n2 -t2 . \n. . -t1 n1. j1 j Linearity checks that, for all start nodes n1 -n2 . C on the same a, each active thread \nin n2 depends on some thread in n1, avoiding races between active threads. This is not necessary for \nservice threads, since they will be merged by our EPP. Linearity is preserved by our semantics and is \ndecidable, since a choreography is linear whenever its one-time unfolding of recursions is linear. Example \n5. In (1), we cannot build any dependency unless, e.g., t1 = t3 and t2 = t4. Instead, the following choreography \nis linear with dependencies between t1 and t3 and between t2 and t4. \" t1[p], t2[q] start : a(k); t1[p1] \n-> t3[p3] : k \" ; t2[p2] -> t2[p4] : k \" ; \" t [p5] -> t4[p6] : k \" ; t3[p], t4[q] start : a(k) 2 EPP. \nSince different service threads may be started on the same public channel and play the same role, we \nuse U for merging their behaviours into a single replicated process. We identify such threads with LCJa \np , the service grouping operator [14]. We can .nally give the complete de.nition of EPP: De.nition 3 \n(Endpoint Projection). Let C = (.t k ) Cf where Cf is restriction-free, i.e., there are no subterms (.r) \nC \" in Cf . Then, the EPP of C is:   tn+1, . . . , tm to replicated accepts. For selection, the sender \nis pro- C l = (. k) Cf lt | k : \u00d8 | jected to an output and the receiver to a branching. Projections \nof t . fn(Cf ) k . fn(Cf ) communication and delegation (omitted) follow the same principle. In a choreography \nconditional, t is projected to a local conditional, (i) (ii) whereas for all other threads we require \ntheir projected behaviours Cf lt to be merged by the merging partial operator U [15]. P U Q is a,p t. \nCf a isomorphic to P and Q up to branching, where all branches of P p or Q with distinct labels are \nalso included. As a full example, the (iii) thread projections of the choreography in Example 2 (Two-buyer \nThe EPP of C is the parallel composition of (i) the projectionschoreography) are the processes reported \nin Example 4. of all active threads; (ii) the queues for all active sessions; and (iii)Linearity. The \nexpressivity of the (start) primitive may introduce the replicated processes obtained by merging the \nprojections ofraces on public channels. For example, the choreography all service threads with same \npublic channel and role. Note how \" t1[p], t2[q] start : a(k); t3[p], t4[q] start : a(k ) (1) features \nfour threads starting two different sessions on the same public channel. If we run their projections \nin parallel, we have a race between t1 and t3 and another between t2 and t4 for synchronising on a. This \nmay result in t1 starting a session with t4 and t2 starting a session with t3, violating the choreography. \nIn the sequel an interaction node, denoted by n, is an abstrac\u00adswapping has no in.uence on EPP, since \nwe now have parallel composition at the endpoint level, i.e., if C C C \" then C l = C \" l. Example 6. \nLet C be the two-buyer-helper choreography from Example 3. Since h1 and h2 are grouped under LCJb H , \nthe EPP of C will merge their behaviour into a single process (say, Ph). I.e., C l= C lb1 | C lb2 | C \nls | Ph where Ph is: tion of a node in a choreography syntax tree. n can either be .. done : 0, t1, \n. . . , tn start tn+1, . . . , tm : a (abstracting a (start) node) or !b[H](k \" ); . . . . \" del : k \n\" ?B(z ); k \" ?B((k)); t1 -> t2 (abstracting a session interaction). We write n1 -n2 . C k \" ?B(z); \nk \" ?B &#38; \" if (z-z =100) whenever n1 precedes n2 in the choreography C. \"\" ) then k!S . ok; k!S(addr); \nk?S(z else k!S . quit . . . . De.nition 1 (Dependency). We write n1 -t n2 . C if n1 -n2 . C and either \n p1,...,pn start pn+1,...,pm:a(k) ----------------------. | | R Pi[k[pi]/ki] | a[p1, . . . , pm](k); \nP i.I a[pi](ki); Pi (.k) P [k[p1]/k] | i.I lP |STARTl j.J Qj [k[pj ]/kj ] | k : \u00d8 | R !p -> q:k(v) lEP \n|SENDl k[p]!q(e); P | k : h --------. P | k : h \u00b7 (p, q, v) (e . v) ?p -> q:k[lj ] lEP |BRANCHl k[q]?p \n&#38; {li : Pi}i.I | k : (q, p, lj ) \u00b7 h --------. Pj | k : h (j . I) Figure 8. Endpoint calculus, selected \nreduction rules. t1[p1], . . . , tn[pn] start tn+1[pn+1], . . . , tm[pm] : a(k); C lti = ( t1[p] -> \nt2[q] : k[l]; C )lt = . .. .. . . . a[p1, . . . , pm](k); (C lti ) if i = 1 a[pi](k); (C lti ) if 2=i \n= n !a[pi](k); (C lti ) if n+1=i=m C lti otherwise k!q . l; (C lt ) if t = t1 k?p &#38; {l : (C lt )}Clt \nif t = t2 otherwise \" if e then (C1 lt1 ) else (C2 lt1 ) if t = t ( if e@t then C1 else C2 )lt1 = (C1 \nlt1 ) (C2 lt1 ) otherwise Figure 9. Thread projection, selected rules. EPP Theorem. We now present our \nEPP Theorem, which for\u00admalises the relationship between the semantics of a well-typed, lin\u00adear choreography \nand the semantics of its EPP. Without loss of gen\u00aderality, we consider only strict reductions, denoted \nby ', i.e. reduc\u00adtions where restricted names not under a pre.x are never renamed. '* denotes the closure \nof '. The entailment . h \u00b5 checks that the endpoint actions \u00b5 implement the global actions . (cf. [14]). \nTheorem 3 (EPP). Let C = (.t k ) Cf be linear and well-typed, with Cf restriction-free. Then, . \" 1. \n(Completeness) C ' C implies there exists P such that (i) \u00b5 \" C l-P and either (ii) C l ' P where . h \n\u00b5 or (iii) \u00b51\u00b52 C l' ' P where . h \u00b51, \u00b52. \u00b5 2. (Soundness) C l '* P implies there exist P \" and C \" \nsuch \u00b5 1 . '* '* \" that (i) P P \" ; (ii) C C . h \u00b5 \" ; and (iii) and \u00b5, C \" l-P \" . Above, the pruning \nrelation P -Q is such that P ~ Q (~ is bisimilarity) and that P has some unused branches and replicated \naccepts. Point 1. states that an EPP can mimic (up to pruning) all the reductions of its originating \nchoreography; on the other hand, point 2. says that an EPP always eventually reduces (up to pruning) \nto the projection of a (possibly reached after multiple reductions) reductum of its originating choreography. \nBoth points ensure that the observables of a choreography and its EPP are correctly related. By Theorems \n1 and 3, we can formalise our deadlock-freedom\u00ad \u00b5 \u00b5 by-design property. Below, -. * is the closure of \n-. . Corollary 1 (Deadlock-freedom-by-design). Let C be linear and \u00b5 well-typed. Then, for any P such \nthat C l -. * P , we have that 1 \u00b5 \" \"\" either P - . P for some P , \u00b5 or 0 -P . Moreover, our EPP code \nenjoys standard communication safety: \u00b5 Corollary 2 (Safety). Let C be linear, well-typed and C l -. \n* P . Then, 1. (Linearity) P has no races on any a or k with same role p; 2. (Error-freedom) if P has \nan enabled input k[p]?q that can consume a message (p, q, w) from a session queue k : h in  P , then \nw is of the same type of the input (value, label, or delegated channel). Typing expressiveness. Previously \nproposed typing disciplines for session types ensure properties similar to ours, but performing type \nanalysis directly on endpoint programs [7, 15, 22]. Our typing dis\u00adcipline subsumes a larger class of \nsafe deadlock-free systems, by exploiting the extra information that we gain from de.ning imple\u00admentations \nwith choreographies. In particular, our typing system allows for two novel features wrt standard multiparty \nsession typ\u00ading: inter-protocol coherence and partial protocol implementation. Let us discuss inter-protocol \ncoherence. Consider the protocol: G = p -> q : {l1 : r -> p : (int), l2 : r -> q : (int)} Above, p communicates \nto q a choice between labels l1 and l2. In the .rst case another role, r, is expected to communicate \nan integer to p. Otherwise, r will communicate an integer to q. A potential use case for G could be that \nr possesses some good, and p decides where the good should be sent to (p itself or q). Previous work \non global types cannot type any system implementing G, since G can\u00adnot be projected onto a correct set \nof endpoint types [38]. Indeed, in the protocol, r is not informed of the choice made by p and thus cannot \nknow whether it should communicate with p or q af\u00adterwards. We refer to this problem by saying that G \nis not coherent for previous type systems based on global types. In our framework, we do not consider \nprotocol coherence because protocols such as G above can easily be implemented by interleaving them with \nother ones. For example, consider the following choreography: 1. t1[p] start t2[q], t3[r] : a(k); t2[p \n\" ], t3[q \" ] start : b(k \" ); 2. if e@t1 then t1[p] -> t2[q] : k[l1 ]; t2[p \" ] -> t3[q \" ] : k \" [l1 \n]; 3. t3[r].some int -> t1[p].x : k 4. else t1[p] -> t2[q] : k[l2 ]; t2[p \" ] -> t3[q \" ] : k \" [l2 \n]; 5. t3[r].some int -> t2[q].y : k  The choreography above can be typed correctly using G as type \nfor a (we omit the typing for b). In order to notify t3, playing role r, of the choice performed by t1, \nplaying role p, we make use of an additional session between t2 and t3. We use this session, k \" , after \nt2 receives the choice from t1. Observe that the choreography is typable and can be correctly projected \nby our EPP. The key aspect of this example is that our framework leaves the task of de.ning a coherent \nsystem to the implementation (the choreography). Hence, protocols can be designed at a higher level of \nabstraction. E.g., in G we do not specify how r is noti.ed of the choice. We call this aspect inter-protocol \ncoherence, since it is the composition of protocols in a choreography that is checked for coherence (by \nchecking whether its EPP is de.ned), and not each protocol by itself. We now discuss partial protocol \nimplementation with the fol\u00adlowing choreography: t[p], t \" [q] start : a(k); t[p] -> t \" [q] : k[l1 ]; \nt[p], t \" [q] start : a(k \" ); if e@t then t[p] -> t \" [q] : k \" [l2 ] else t[p] -> t \" [q] : k \" [l3 \n] The choreography above is typable in our system (a s type is p -> q : {l1 : end, l2 : end, l3 : end}). \nHowever, the endpoint projection for t \" would not be typable with standard contra-variant input typing, \nwhich requires that at least all the branches in the type are implemented. Again, this is a consequence \nof using choreogra\u00adphies: since in the choreography we know exactly which outputs will correspond to \nwhich inputs, we can ensure that the protocol branches that t \" does not implement will never be used. \n6. Implementation Following our model, we have implemented the Chor programming language [16]. Our implementation \nis open source and comes with a complete IDE, developed as an Eclipse [19] plugin. Chor features all \nGC primitives (Figure 1), an implementation of our typing discipline (Figure 7), and an EPP implementation \nfor projecting choreographies onto executable endpoints (from \u00a7 5). Chor also provides some syntax extensions \nfor enhanced usability, e.g., protocols may refer to other protocols and choreographies allow local code \nfor local state manipulation and user interactions. We give an overview of the development methodology \noffered by our framework, and detail some aspects of our implementation. Development methodology. In \nthe development methodology sug\u00adgested by Chor (see Figure 10), developers can .rst use our IDE to write \nprotocol speci.cations and choreographies. The programmer is supported by on-the-.y veri.cation which \ntakes care of check\u00ading (i) the syntactic correctness of program terms and (ii) the type compliance of \nthe choreography wrt the protocol speci.cations, us\u00ading our typing discipline. Program errors are reported \nusing syntax highlighting, allowing for an interactive programming experience. Once the global program \nis completed, developers can automat\u00adically project to an endpoint implementation, given in the Jolie \npro\u00adgramming language (cf. Executable artifacts). Nevertheless, Chor is designed to be extended to multiple \nendpoint languages: poten\u00adtially, each thread in a choreography could be implemented with a different \nendpoint technology. We plan future extensions to support projecting endpoints to e.g., Java, C#, or \nWS-BPEL [30]. Each Jolie endpoint program comes with its own deployment information, given as a term \nseparated from the code implementing the behaviour of the projected thread. This part can be optionally \ncustomised by the programmer, which can be useful for running the programs on some speci.c network or \ncommunication technology. Finally, the Jolie endpoint programs can be executed. As ex\u00adpected, they will \nimplement the originating choreography. Executable artifacts. Our EPP implementation targets Jolie, an \nopen-source service-oriented language [3, 29]. Choosing Jolie has several reasons: (i) Jolie offers constructs \nsimilar to those of our endpoint calculus, e.g., communications and input choices, making part of our \nEPP straightforward; (ii) Jolie has a formal semantics and a reference implementation, which we used \nfor implementing some abstract aspects of our model such as message queues and session channels; and \n(iii) Jolie supports a wide range of compati\u00adbility with other technologies as detailed below. Deployment. \nBy default, our endpoint programs will operate on top of TCP/IP sockets. However, since Jolie also supports \nother communication technologies e.g. local memory IPC and Blue\u00adtooth and data formats e.g. HTTP and \nSOAP [4] programmers may customise deployment information of each endpoint. Hence, some endpoints may \ncommunicate over, e.g., HTTP, while others, e.g., using fast binary data formats. Additionally, different \nend\u00adpoints may be deployed in different machines and/or networks. Notably, customising the deployment \nof an endpoint program does not necessarily require updating the code of the others. Sup\u00adporting this \n.exibility has required a careful implementation of ses\u00adsion starts (rule LEP |STA RTl), which are coordinated \nby special start services . The (endpoint projections of the) active threads willing to start a session \ncontact the appropriate start service. Then, the start service spawns the (projections of the) service \nthreads by call\u00ading the external services that implement them. In every message exchange, each endpoint \ninforms the start service of the binding in\u00adformation (e.g., IP address and data format) on which the \nendpoint can be reached. Finally, the start service informs all participants about all necessary bindings, \nso that each party can dynamically update its references to the others (e.g., socket connections). Another \nkey feature concerning different communication tech\u00adnologies is that our queue implementation is based \non the latest cor\u00adrelation sets implementation in Jolie [28]. Correlation sets allow to program incoming \nmessage queueing by correlating some data val\u00adues inside messages with those inside of a thread local \nstate. Our EPP handles this programming to implement a separate queue for each role in a session as required \nby our model. Afterwards, the programmer can customise correlation for each deployment arti\u00adfact. For \ninstance, some threads may identify sessions using HTTP cookies (as in common web applications), while \nothers may use SOAP headers (as in the WS-Addressing speci.cations [5]). Delegation. Session delegation \nis a nontrivial mechanism at the level of endpoint implementation. The main concern lies in up\u00addating \nchannel references (bindings). For instance, assume that a session k has some thread participants, say \nt and t . Suppose now that t delegates its role on k to another thread t \" through a dif\u00adferent session. \nIn such a situation, all the threads in t need their external references to be updated for reaching t \n\" instead of t when communicating with the session/role pair delegated by t . In our endpoint model this \nnecessity is completely abstracted away by the synchronisations on the centralised message queues (one \nper ses\u00adsion). However, in our implementation, message queues are com\u00adpletely distributed: each thread \nowns a message queue which must be reached explicitly by other threads. [24] presents a survey of possible \nsolutions to this problem in asynchronous scenarios. The main challenge is that t may send messages to \nt before getting noti.ed of the delegation, and t must thus resend these messages to t \", adding extra \ncommunications. In our EPP implementation, each thread in t knows when the delegation will happen using \nthe information from the choreography. Hence, we are always in the optimal case where no messages are \nlost. 7. Examples Choreography-based programming can have several applications, ranging from multicore \nprogramming to distributed Web Services. Below, we present and discuss two possible example applications. \nStreaming-AVP. In this example, we show how to combine two different protocols for implementing a streaming \nservice for movie .les. We start by giving the protocol for streaming: rec t; S -> C : (bytes); S -> \nC :again : t, end : end In the protocol above, S is a streaming server sending byte packets to a client \nC. After each packet, S communicates to C whether there are more bits to be sent or the stream is over \n(choices again and end). The other protocol (AVP, for Audio-Video Processing) is  rec t; F -> A :(bytes); \nF -> V :(bytes); A -> S :(bytes); V -> S :(bytes); !a[S](stream); b[S, F, A, V](avp); F -> A : again \n: A -> V : (bytes); V -> S : (bytes); t, end : end rec AVPStreaming(e, (avp, stream)) = .. avp?A(audiopacket); \navp?V(videopacket); Four roles participate in this protocol: a .lesystem F, an audio decoder A, a video \ndecoder V, and a sink S. The .ow of information in this protocol consists of F sending the raw audio \ninformation to A .... .... . . . . stream!C(audiopacket + videopacket); again : stream!C . again; avp?V \n&#38; AVPStreaming(e, (avp, stream)) end : stream!C . end and the raw video information to V, read from \nthe movie .le. Then .. both A and V send the processed decoded information to the sink S. The goal of \nthis example is to show how to interleave the two protocols so that the information produced by an implementation \nof AVP is forwarded to a client (e.g., a display) as pictured below: in AVPStreaming(e, (avp, stream)) \n OpenID and Logging. We give an example using a variant of OpenID [32], a protocol where a client (called \nuser) authenticates to a server (called relying party) through a third-party identity provider. We de.ne \nthe protocol with the following global type: U -> RP : (string); RP -> IP : (string); U -> IP : (string); \nok : RP -> U : {ok : RP -> U : (G@C); end}, IP -> RP : We implement such a system as follows: fail : \nRP -> U : {fail : end} c[C] start s[S] : a(stream); s[S] start f[F], a[A], v[V] : b(avp); rec AVPStreaming(e, \n(avp, stream), (f, a, v, s, c)) = C in AVPStreaming(e, (avp, stream), (f, a, v, s, c)) The choreography \nabove starts two sessions (on a and b) cor\u00adresponding to the two protocols speci.ed above. Note that \nthe streamer in the .rst protocol and the .le system, the audio decoder and the video decoder in the \nsecond where chosen to be service threads. The core of the choreography is the term C de.ned as: 1. f[F].audioByteC \nhunk -> a[A].audioByteC hunk : avp; 2. f[F].videoByteC hunk -> v[V].videoByteC hunk : avp; 3. a[A].decodeA(audioByteC \nhunk) -> s[S].audioP kt : avp; 4. v[V].decodeV(videoByteC hunk) -> s[S].videoP kt : avp; 5. s[S].(audioP \nkt + videoP kt) -> c[C].pkt : stream; 6. if (more())@f 7. f[F] -> a[A] : avp[again]; a[A] -> v[V] : \navp[again]; 8. v[V] -> s[S] : avp[again]; s[S] -> c[C] : stream[again]; 9. AVPStreaming(e, (avp, stream), \n(f , a, v, s, c))  10. else 11. f[F] -> a[A] : avp[end]; a[A] -> v[V] : avp[end]; 12. v[V] -> s[S] \n: avp[end]; s[S] -> c[C] : stream[end]  Choreography C can be repeated several times. Lines 1-5 describe \nhow the .lesystem sends audio and video information to the threads implementing the audio and video decoders \nrespectively. Then, the audio and video decoder resend the processed information to the thread implementing \nthe sink. The same thread implements the streamer in the other protocol and therefore sends to the client \ndata obtained by composing the audio and video (this is like multiplex\u00ading). Lines 7-9 correspond to \nthe if-branch where the .le server will communicate to the other threads that there is more data to process. \nSimilarly, termination is communicated to the other threads in the else-branch (Lines 11-12). Clearly, \nthe choreography above is well\u00adtyped wrt the two given global types. Above, RP abstracts the relying \nparty, IP the identity provider and U the user. First, U sends her username to RP, which forwards it \nto IP. Then, U sends her password to IP, which will notify RP of whether the username/password credentials \nare valid (ok or fail). Finally, RP forwards the noti.cation to U. If successful, RP also delegates to \nU role C in a session of type G, where G = S -> C : (string). This example interleaves OpenID with another \nprotocol where a client C asks a log server S for either a secret or a public log. Finally, S replies \nwith the corresponding log content. Formally, C -> S : secret : S -> C : (string), public : S -> C : \n(string) Now, we can program our system as follows: 1. rp[RP], u[U] start ip[IP] : publicOpenI D(k); \n 2. u[U].user -> rp.user : k; 3. rp[RP].user -> ip[IP].username : k; 4. u[U].pwd -> ip[IP].password \n: k; 5. if (check(username, password))@ip 6. ip[IP] -> rp[RP] : k[ok]; 7. rp[RP] -> u[U] : k[ok]; \n 8. if (high(username))@rp 9. rp[C] start s[S] : log(k \" );  10. rp[C] -> s[S] : k \" [secret ]; 11. \nrp[RP] -> u[U] : k((k \" [C]));  12. s[S].secret msg -> u[C].logC ontent : k \" 13. else 14. rp[C] start \ns[S] : log(k \" ); 15. rp[C] -> s[S] : k \" [public]; 16. rp[RP] -> u[U] : k((k \" [C])); 17. s[S].public \nmsg -> u[C].logC ontent : k \" 18. else 19. ip[IP] -> rp[RP] : k[fail]; 20. ip[IP] -> u[U] : k[fail] \n  where rp, u, ip, and s are the endpoints of the system. Line 1 describes the initiation of a protocol \ninstance between rp, u and ip, by means of the public name a. In Lines 2-4, u sends its credentials to \nrp and ip (only username to rp). Then, ip checks the data received (Line 5) and communicates the outcome \nto rp (Lines 6 and 19). In both cases, the selection is forwarded to u (Lines 7 and 20). In the if-branch, \nrp checks the user access level. If high, it starts a new session (log) spawning s (Line 9) and asks \nfor a secret log (Line 10). Consequently, rp will delegate its role in session k \" to the user u through \nsession k. Finally, u will get the requested log. The system works similarly in the public log case (Lines \n14-17). We conclude by showing the EPP for service thread s: secret : k \" !C(private msg), !log[S](k \n\" ); k \" ?C &#38; public : k \" !C(public msg) Note how the thread projections of s for the different \nbranches of the choreography (Lines 9-12 and 14-17) would yield different code which is then merged into \nthe one above. Other examples. In the Chor website [16] we provide other exam\u00adples, which can also be \ndirectly tested in the Chor IDE. The exam\u00adples include other applications of OpenID, usage of the choreogra\u00adphy \nlanguage for programming a use case of the Ocean Observato\u00adries Initiative [31], and other web services \napplications. 8. Related Work Global methods for communicating systems occur in different forms, including \nMSC [25], security protocols [8, 9, 12] and au\u00adtomata theory [21]. However, these works are not intended \nas fully\u00ad.edged programming languages since they do not deal with, e.g., different layers of abstraction \nor value passing. This is the .rst work proposing an asynchronous semantics for a choreography language \nbased on sessions. To the best of our knowledge, the notion of delayed input [27] is the most similar \nresult to the asynchrony modelled by our semantics. The closest work to ours is [15], which proposes \na synchronous choreography model without delegation based on binary (endpoint) session types. Our framework \nshows that switching to multiparty asynchronous sessions with delegation introduces more complex\u00adity, \nbut also that such complexity can be elegantly hidden from the programmer. Moreover, [15] has implicit \nthreads and deals with a stronger sequential operator, requiring two syntactic restrictions on choreographies, \ni.e., well-threadedness and connectedness. In con\u00adtrast, our approach needs no such restrictions because \nof explicit threads and a more relaxed sequential operator. Finally, [15] en\u00adsures EPP correctness based \non a type preservation result, while we guarantee the same without the need for an endpoint typing. Multiparty \nsession types have been previously used for check\u00ading endpoint systems [7, 17, 22]. We have shown that \nthey can be adopted for typing choreographies, de.ning a new class of correct well-typed endpoint systems \n(through EPP). Our global types as well as our endpoint model are taken by [7]. Other works have given \nan asynchronous semantics to global types: [22] de.nes a se\u00admantics in terms of that of the projection \nof global types while [18] interprets global types as asynchronous communication automata. Our linearity \nnotion is inspired by [22]. [7] guarantees progress for multiparty sessions by building ad\u00additional restrictions \non top of (endpoint) session typing. Processes satisfying progress do not get stuck provided that they \ncan be run in parallel with other processes that would unlock stuck states. In our work progress, implied \nby deadlock-freedom, is an immediate consequence of our EPP Theorem, yielding a simpler analysis. 9. \nDiscussion and Future Extensions We discuss some aspects of choreography-driven programming and future \nextensions in relation to the work presented in this article. Approach. It may be unclear how the choreography-driven \nap\u00adproach may deal with standard aspects of programming such as choreography composition and endpoint \ncode reuse. Choreography composition is fundamental for supporting dis\u00adtributed (team) development. \nOur framework supports it with (i) service merging and (ii) procedures. (i) Our EPP merges service threads \nstarted on the same public channel and role into a sin\u00adgle process. This allows two choreographies to \nbe composed into a bigger system, whenever their respective service threads are merge\u00adable. Mergeability \ncan be assured by using a design pattern, i.e. en\u00adforcing service threads that need to be merged to start \nwith distinct branches. (ii) Procedures can be written and typed separately, so to create libraries that \ncan be used by other choreographies (code reuse). As future work, we plan to extend Chor with a namespacing \nsystem to fully support this methodology. Endpoint code reuse may be necessary when parts of the system \nbe\u00ading designed are already implemented. For instance, we may want to reuse an existing identity provider \nservice in \u00a7 7, OpenID and Logging. Our model does not currently offer a way of integrating existing \nendpoint code with the EPP of a choreography. We discuss some potential solutions, which we leave as \nfuture work. Using bisimulation techniques, we can verify some existing service code to be bisimilar \nto the code that would be generated by the EPP [10]. Alternatively, we could use a type system, such \nas multiparty session typing [7, 22], for guaranteeing that the existing code has a behaviour compatible \nwith the choreography. Both the techniques mentioned above can be adjusted to al\u00adlow for re.nement, i.e. \nthe legacy code may do extra actions as long as they do not interfere with the good behaviour of the \nchore\u00adography. The resulting system would still guarantee communica\u00adtion safety and session .delity (protocol \ncompliance). Deadlock\u00adfreedom would also still be guaranteed, provided that the legacy code has been \nveri.ed to be deadlock-free. Note that our imple\u00admentation of delegation (\u00a7 6, Delegation) would need \nto fall back to the protocol presented in [24] for those sessions whose behaviour is partly implemented \nby legacy code, since the latter cannot refer to the necessary information provided by the choreography. \nGC features. Based on our conversations with our industry collab\u00ad orators, we discuss some relevant aspects \nand extensions of GC. Sequential and Parallel operators. The relaxed semantics of our se\u00adquential operator \n; allows our framework to express parallelism with a minimal syntax. However, an explicit parallel operator \nmay make choreographies more readable. We discuss here two possible extensions in this sense, based upon \na hypothetical operator C1 | C2 equipped with the classical interleaving semantics of parallel com\u00adposition. \nWe use the following choreography as reference example: \" Cpar = t1[p1].e -> t2[p2].x : k | t3[p3].e \n-> t2[p4].y : k \" Whenever t1, t2, t3, t4 are all different, Cpar can be encoded using our sequential \noperator: Cseq = t1[p1].e -> t2[p2].x : k; t3[p3].e \" -> t2[p4].y : k \" In fact, thanks to our swap \nrelation C, Cpar would behave exactly as Cseq . If the two interactions in Cpar share a thread name, \ne.g., t2 = t4, the parallel operator | would not be syntax sugar anymore, since the projection of t2 \nwould be a parallel composition of two input actions. This also means that t2 would no longer be a simple \nsequential thread, raising the complexity of our framework and going out of the scope of the present \nwork. Public channel passing. We leave the treatment of public channel name passing as future work. The \nmain challenge is to statically establish where such channels can be located in the endpoints. Interactional \nexceptions. Our language does not offer speci.c fea\u00adtures for error/exception recovery. A possible extension \nis to in\u00adclude exceptions in our choreography language in the spirit of what is informally suggested \nby [13] for binary sessions. Dynamic join. We plan to extend our model to allow threads to dynamically \njoin and leave an existing session, similarly to [11, 17]. We conjecture that asynchrony and parallelism \nwill in.uence these extensions in a nontrivial way. Multiple roles. In our model, a thread can play only \none role per session. However, there are cases in which multiple roles in a protocol may be implemented \nby a single thread, which would be useful both for system simpli.cation and resource saving. We plan \nto extend our typing system to allow for this occurrences. [6, 11] follow a similar direction, but using \nendpoint implementations. Global deployment. Chor projects Jolie programs with a default de\u00adployment \ncon.guration that can be edited afterwards for each end\u00adpoint. This may be inconvenient for the programmer, \nsince a chore\u00adography may describe many participants. Therefore, we plan to introduce a global deployment \nlanguage for choreographies, from which the deployment con.guration of each endpoint could be au\u00adtomatically \ngenerated. We envision that this extension could be rel\u00adevant for facilitating checks on the correctness \nof a deployment con.guration of a system, e.g., consistent I/O connections. Security. Global descriptions \nare particularly suitable for the study of security-related aspects in distributed systems [8, 9, 12]. \nOur choreographies give a global view of how sessions are interleaved and how their references are transmitted. \nIt would be interesting to see how this aspect may in.uence the security analysis of a system. Scaffolding. \nSince in our model a protocol and a session behaviour in a choreography have similar structures, we could \nimplement a scaffolding tool in our IDE that, given a protocol, would gener\u00adate a prototype choreography \nwith dummy data that implements it. Then, programmers would re.ne and interleave different proto\u00adtypes \nto obtain the desired behaviour. 10. Conclusions We presented a fully-.edged model for de.ning asynchronous \nsys\u00adtem implementations as global programs. We developed a type sys\u00adtem for checking choreographies against \nmultiparty protocol spec\u00adi.cations. Moreover, through type inference, developers can also use choreographies \nas implementation prototypes to infer new pro\u00adtocol standards. Our EPP generates correct endpoint code, \nensuring nontrivial properties such as deadlock freedom and communica\u00adtion safety. Finally, we provided \na prototype implementation of our framework and applied it to some realistic examples. Acknowledgements. \nWe are grateful to N. Yoshida, J. Bengtson, T. Hilde\u00adbrandt, K.Honda, C. Sch \u00a8 urmannn, V. Vasconcelos, \nand the anonymous re\u00adviewers for their comments. The Danish Agency for Science, Technology and Innovation \nsupported Carbone. References [1] BPMN. http://www.omg.org/spec/BPMN/2.0/. [2] italianaSoftware. http://www.italianasoftware.com/. \n[3] Jolie language. http://www.jolie-lang.org/. [4] SOAP Speci.cations. http://www.w3.org/TR/soap/. [5] \nWS-Addressing. http://www.w3.org/TR/ws-addr-core/. [6] P. Baltazar, L. Caires, V. T. Vasconcelos, and \nH. T. Vieira. A Type System for Flexible Role Assignment in Multiparty Communicating Systems. In Proc. \nof TGC, 2012. To appear. [7] L. Bettini, M. Coppo, L. D Antoni, M. D. Luca, M. Dezani-Ciancaglini, and \nN. Yoshida. Global progress in dynamically inter\u00adleaved multiparty sessions. In CONCUR, volume 5201 of \nLNCS, pages 418 433. Springer, 2008. [8] K. Bhargavan, R. Corin, P.-M. Deni \u00b4elou, C. Fournet, and J. \nJ. Leifer. Cryptographic protocol synthesis and veri.cation for multiparty ses\u00adsions. In Proc. of CSF, \npages 124 140, 2009. [9] S. Briais and U. Nestmann. A formal semantics for protocol narra\u00adtions. Theoretical \nComputer Science, 389(3):484 511, 2007. [10] N. Busi, R. Gorrieri, C. Guidi, R. Lucchi, and G. Zavattaro. \nChoreog\u00adraphy and orchestration conformance for system design. In Proc. of Coordination, volume 4038 \nof LNCS, pages 63 81. Springer-Verlag, 2006. [11] L. Caires and H. T. Vieira. Conversation types. Theoretical \nComputer Science, 411(51-52):4399 4440, 2010. [12] C. Caleiro, L. Vigan `On the semantics of Al\u00ad o, and \nD. A. Basin. ice&#38;Bob speci.cations of security protocols. Theor. Comput. Sci., 367(1-2):88 122, 2006. \n [13] M. Carbone. Session-based choreography with exceptions. In Proc. of PLACES, volume 241, pages 35 \n55. ENTCS, 2008. [14] M. Carbone and F. Montesi. Typed multiparty global program\u00adming. Technical Report \n149, IT University of Copenhagen, 2011. http://www.itu.dk/people/fabr/papers/multichor. [15] M. Carbone, \nK. Honda, and N. Yoshida. Structured communication\u00adcentred programming for web services. In Proc. of \nESOP, volume 4421 of LNCS, pages 2 17. Springer-Verlag, 2007. [16] Chor. Programming Language. http://www.chor-lang.org/. \n[17] P.-M. Deni\u00b4 elou and N. Yoshida. Dynamic multirole session types. In Proc. of POPL, pages 435 446. \nACM, 2011. [18] P.-M. Deni \u00b4elou and N. Yoshida. Multiparty session types meet com\u00admunicating automata. \nIn Proc. of ESOP, LNCS, pages 194 213. Springer-Verlag, 2012. [19] Eclipse. The Eclipse IDE. http://www.eclipse.org/. \n[20] Enea. ENEA: Italian National agency for new technologies, Energy and sustainable economic development. \nhttp://www.enea.it/. [21] X. Fu, T. Bultan, and J. Su. Realizability of conversation protocols with message \ncontents. International Journal on Web Service Res., 2 (4):68 93, 2005. [22] K. Honda, N. Yoshida, and \nM. Carbone. Multiparty asynchronous session types. In Proc. of POPL, volume 43(1), pages 273 284. ACM, \n2008. [23] K. Honda, A. Mukhamedov, G. Brown, T.-C. Chen, and N. Yoshida. Scribbling interactions with \na formal foundation. In Proc. of ICDCIT, volume 6536 of LNCS, pages 55 75. Springer, 2011. [24] R. Hu, \nN. Yoshida, and K. Honda. Session-based distributed program\u00adming in java. In ECOOP, pages 516 541, 2008. \n[25] International Telecommunication Union. Recommendation Z.120: Message Sequence Chart, 1996. [26] \nI. Lanese, C. Guidi, F. Montesi, and G. Zavattaro. Bridging the gap between interaction-and process-oriented \nchoreographies. In Proc. of SEFM, pages 323 332. IEEE, 2008. [27] M. Merro and D. Sangiorgi. On asynchrony \nin name-passing calculi. Mathematical Structures in Computer Science, 14(5):715 767, 2004. [28] F. Montesi \nand M. Carbone. Programming services with correlation sets. In ICSOC, pages 125 141, 2011. [29] F. Montesi, \nC. Guidi, and G. Zavattaro. Composing Services with JOLIE. In Proc. of ECOWS, pages 13 22, 2007. [30] \nOASIS. Web Services Business Process Execution Language. http://docs.oasis-open.org/wsbpel/2.0/wsbpel-v2.0.html. \n[31] OOI. Ocean Observatories. http://www.oceanobservatories.org. [32] OpenID. Speci.cations. http://openid.net/developers/specs/. \n[33] PI4SOA. http://www.pi4soa.org, 2008. [34] B. C. Pierce. Types and Programming Languages. MIT Press, \nMA, USA, 2002. [35] Qualit-E. Funded by Cognizant. http://www.cognizant.com/. [36] Savara. JBoss Community. \nhttp://www.jboss.org/savara/. [37] W3C WS-CDL Working Group. Web services choreography descrip\u00adtion language \nversion 1.0. http://www.w3.org/TR/ws-cdl-10/, 2004. [38] N. Yoshida, P.-M. Deni\u00b4elou, A. Bejleri, and \nR. Hu. Parameterised multiparty session types. In FOSSACS 10, volume 6014 of LNCS, pages 128 145, 2010. \n \n\t\t\t", "proc_id": "2429069", "abstract": "<p>Over the last decade, global descriptions have been successfully employed for the verification and implementation of communicating systems, respectively as protocol specifications and choreographies. In this work, we bring these two practices together by proposing a purely-global programming model. We show a novel interpretation of asynchrony and parallelism in a global setting and develop a typing discipline that verifies choreographies against protocol specifications, based on multiparty sessions. Exploiting the nature of global descriptions, our type system defines a new class of deadlock-free concurrent systems (deadlock-freedom-by-design), provides type inference, and supports session mobility. We give a notion of Endpoint Projection (EPP) which generates correct entity code (as pi-calculus terms) from a choreography. Finally, we evaluate our approach by providing a prototype implementation for a concrete programming language and by applying it to some examples from multicore and service-oriented programming.</p>", "authors": [{"name": "Marco Carbone", "author_profile_id": "81331489911", "affiliation": "IT University of Copenhagen, Copenhagen, Denmark", "person_id": "P3977962", "email_address": "carbonem@itu.dk", "orcid_id": ""}, {"name": "Fabrizio Montesi", "author_profile_id": "81361598958", "affiliation": "IT University of Copenhagen, Copenhagen, Denmark", "person_id": "P3977963", "email_address": "fmontesi@itu.dk", "orcid_id": ""}], "doi_number": "10.1145/2429069.2429101", "year": "2013", "article_id": "2429101", "conference": "POPL", "title": "Deadlock-freedom-by-design: multiparty asynchronous global programming", "url": "http://dl.acm.org/citation.cfm?id=2429101"}