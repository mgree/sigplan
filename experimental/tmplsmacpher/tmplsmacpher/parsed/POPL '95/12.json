{"article_publication_date": "01-25-1995", "fulltext": "\n Applicative functors and fully transparent higher-order modules Xavier Leroy INRIA B.P. 105, Rocquencourt, \n78153 LeChesnay, France. Xavier.Leroy@inria .fr Abstract We present a variant of the Standard ML module \nsystem where parameterized abstract types (i.e. functors returning generative types) map provably equal \narguments to compat\u00adible abstract types, instead of generating distinct types at each application as \nin Standard ML. This extension solves the full transparency problem (how to give syntactic sig\u00adnatures \nfor higher-order functors that express exactly their propagation of type equations), and also provides \nbetter sup\u00adport for non-closed code fragments. 1 Introduction Most modern programming languages provide \nsupport for type abstraction: the important programming technique where a named type t is equipped with \noperations f,g, . . . then theconcrete implementation oft is hidden, leaving an abstract type t that \ncan only be accessed through the operations f, g,. . . Type abstraction provides fundamental typing support \nfor modularity, since it enables a type-checker to catch violations of themodular structure of programs. \nType abstraction is usually implemented through gener\u00ad ative data type declarations: to make atypet abstract, \nthe type-checker generates anew typet incompatible with any other type, including types with the same \nstructure. From this, it is tempting to explain type abstraction in terms of generativity of type declarations \nand say for instance that a type is abstract because it is created each time its defi\u00ad nition is evaluated \n. The Definition of Standard ML [14, 8] formalizes this approach as a calculus over type stamps that \ndefines when new types are generated and when old types are propagated. This approach is adequate for \nspec\u00ad ifying a type-checker, but too low-level and operational in nature to help understanding type abstraction \nand reason about programs using it. Independently, Mitchell and Plotkin [16] have proposed a more abstract, \nless operational account of type abstrac\u00ad tion based on a parallel with existential quantification in \nlogic. Instead of operational intuitions about type generativ\u00ad ity, this approach uses a precise semantic \ncharacterization: representation independence [17, 15], to show that type ab\u00ad straction is enforced. \nThis abstract approach has since been extended to account for the main features of the Standard Permission \nto copy without fee all or part of this material is granted provided that the copies are not made or \ndistributed for direct commercial acfvanta~e, the ACM copyright notice and the title of the publication \nand its date appear, and notice is given that copyin is by permission of the Association of Computing \nMachinery. + o copy otherwise, or to republish, requires a fee andor specific permission. POPL 951/95 \nSan Francisco CA USA 0 1995 ACM O-89791 -692-l f9uOWl ....$3.50 ML module system: the dot notation as \nelimination con\u00adst ruct for abstract types [3, 4] and the notion oft ype sharing and its propagation \nthrough functors [7, 10]. Unfortunately, some features described by operational frameworks remain unaccounted \nfor in the abstract approach, such as structure sharing and the fully transparent behavior of higher-order \nfunctors predicted by the operational approach [13]. Also, even though the abstract approach is syntactic \nin nature and therefore highly compatible with separate compilation [10], code fragments with free functor \nidentifiers could be supported better (see section 2.4 for an example). MacQueen [13, 1] claims that \nthe problem with higher-order functors is serious enough to invalidate the abstract approach and justify \nthe recourse to complicated stamp-based descriptions of higher-order functors and separate compilation \nmechanisms. The work presented in this paper is an attempt to solve two of these problems (fully transparent \nhigher-order func\u00adtors and support for non-closed code fragments) in a syntac\u00adtic framework derived from \n[10]. It relies on a modification of the behavior of functors (parameterized modules). In Standard ML \nand other models based on type generativity, a functor defining an abstract type returns a different \ntype each time it is applied. We say that functors are genera\u00adtive. In this work, we consider functors \nas applicative if the functor is applied twice to provably equal arguments, the two abstract types returned \nremain compatible. Functors therefore map equals to equals, which enables equational reasoning on functor \napplications during type-checking, In turn, this allows more precise signatures for higher-order functors, \nthereby solving the full transparency problem. Applicative functors are also interesting as an exam\u00adple \nof a module system that ensures type abstraction (the representation independence properties still hold) \nwithout respecting strict type generativity (some applications of a given functor may return new types \nwhile others return com\u00adpatible types). In this approach, type abstraction mecha\u00adnisms are considered \nfrom a semantic point of view (how to make programs robust with respect to changes of im\u00adplementations?) \nrather than from an operational point of view (when are two structurally identical types compati\u00adble?). \nThis work illustrates the additional expressiveness and flexibility allowed by this shift of perspective. \nThe remainder of this paper is organized as follows. Sec\u00adtion 2 introduces informally the applicative \nsemantics of functors and the main technical devices that implement it. Section 3 formalizes a calculus \nwith applicative functors. Section 4 shows that the representation independence prop\u00aderty still holds, \nand section 5 that higher-order functors are fully transparent in this calculus. Section 6 discusses \nrelated work and section 7 gives concluding remarks. 142 2 Functor applications in type paths 2.1 Type \npaths and the propagation oftype equalities Module systems such as SML S allow type expressions of the \nform x.t, where z is a structure identifier (the name of a module) and tis the name of a type defined \nin this struc\u00adture. Since structures can be nested, type expressions such as xl. . . . Zn .t are also \nallowed, denoting the t type compo\u00adnent of the xn substructure of . . . the structure z 1. These type \nexpressions are called type paths or long type identijiem. When type bindings are transparent (named \ntypes are compared by structure), type paths play no role in type\u00adchecking, since they can always be \nreplaced by the type ex\u00adpressions to which they are bound. This is not the case with opaque type bindings, \nwhere the definitions of type identifiers are hidden and types are compared by name. Opaque bindings \nare crucial to implement type abstraction and representation hiding. In SML, they are provided by the \nabst ype and dat at ype constructs. Type paths play the role of witnesses of opaque types [5]: although \nthe definition of an opaque type is not available, two occurrences of a type path denoting this opaque \ntype are recognized as compati\u00adble types. In other terms, syntactic equality between type paths implements \nthe name equivalence that characterizes type abstraction and type generativity [4]. Combined with type \ndefinitions in signatures (the abil\u00adity to specify type equalities in module interfaces), type paths \ncan also express how abstract types are propagated and shared across substructures of a structure, and \nacross the argument and result of a functor. Consider for instance the following Set functor that implements \nsets over any type equipped with a total ordering: signature ORD = sig type t; val less: t -> t -> bool \nend functor Set (Elt: ORD): SET = struct type elt = Elt. t dat atype set = Leaf I Node of set * elt * \nset val empty = Leaf . . . (* Familiar ordered binary tree implementation omitted *) end The following \nsignature for the Set functor captures the fact that theelt component of the result isthesametype as \nthe t component of the argument: functor Set(Elt: ORD): SET = sig type elt = Elt. t type set val empty: \nset val member: elt -> set -> bool ... end This combination of type paths and dependent functor types \nhas been used to give complete syntactic accounts of type sharing inthe SML module system [10, 7, 11]. \n 2.2 Restriction ofprojections to paths An obvious generalization of type paths is to allow projec\u00adtions \nof type components from arbitrary structure expres\u00adsions: then, m.t would be a valid type expression \nfor any structure expression m whose result contains at component [12,9]. This extension adds considerable \nexpressive power, but raises delicate issues. First, when aretwotypeexpres\u00adsions m.t and m .tcompatible? \nClearly, we cannot check that m and m reduce to the same structure, since equal\u00adity of structure expressions \nis undecidable. Second, even if we compare structures by mere syntactic equality (m.t and m .t are compatible \nif and only if the structure expressions mandm are syntactically identical), some type abstraction is \nlost. For instance, two occurrences of the type expression (struct abstype t = r with decls end). t \nwould be recognized as compatible, while the two abstract type definitions can come from different parts \nof the pro\u00adgram andshould create two distinct abstract typest. This problem is particularly apparent \nin the syntactic module systems [10, 7], which have a typing rule (the self rule) that transforms abstract \ntypes into types manifestlyequal to themselves : if the structure path p has signature P: sig ... typet; \n... end thenit also has signature : sig ... type t = p.t; ... end P If all structure expressions are \nallowed in paths, the self rule makes abstract types that happen to have the same implementation automatically \ncompatible: structure A = struct abstype t = T with decls end structure B = struct abstype t = r with \ndecls end By application of the self rule, we obtain the following signatures for A andB: A: sig type \nt= (struct abstype t = r with decls end).t; ... end B: sig type t= (struct abstype t = T with decls end).t; \n... end Hence A.t =B.t, which violates type abstraction. To avoid this problem, all module-language \nconstructs whose evaluation can generate new types (by evaluating an abstype or datatype definition) \nmust not occur in type projections. This excludes structure construction (struct, . . end) and functor \napplication as well (the body of the functor can generate new types at each application). The only constructions \nthat remains are access to a structure identifier (z) and access to a substructure (ZI.ZZ), that is, \nthe type paths (p ::= z [ p.x), as in SML. The restriction of type projections to paths is therefore \nequivalent to the strict notion of type generativity found in SML. 2.3 Functor applications in paths \nIn spite of these considerations, there are situations where it would be extremely useful to extend slightly \nthe class of paths (the syntactic class p of structure expressions such that p.t is a legal type expression) \nto include simple cases of functor applications, where the functor and its argument are themselves paths. \nLet us therefore take p::=zlp.z]Pl(p2) and illustrate the consequences of this choice, ontheexpres\u00ad \nsiveness of the language and on the notion of type abstrac\u00ad tion. 2.4 Local applications of functors \nA first situation where this extension proves useful is to sup\u00adport functors that apply other functors \nlocally. Consider the following Diet functor implementing dictionaries: signature DICT = sig type key \ntype a diet val empty: a diet val add: key -> a -> a di.ct -> a diet val find: key -> a diet -> a end \nfunctor Dict(Key: ORD): DICT = struct type key = Key.t datatype a diet = Leaf I Node of a diet * kev \n* a * a diet . . . (* Binary tree irnpieinentation omitted *) end Assumewe need to extend this functor \nwith a domain op\u00aderation that returns the set of keys of a dictionary. To do so, we need a structure \nimplementing sets of keys. The sim\u00adplest approaches to construct this structure inside the Diet functor, \nusing the Set functor: signature DICT = sig ... structure KeySet: SET sharing KeySet.elt = key val domain: \na diet -> KeySet.Set end functor Dict(Key: ORD): DICT = struct ... structure KeySet = Set(Ord) fun domain \ndiet = . . . end Unfortunately, the signature above does not reflect that KeySet has been obtained by \napplying Set to Oral; there\u00adfore, thetype Key Set. set in the result structure of Diet is assumed incompatible \nwith other set types obtained by ap\u00adplying Set elsewhere to the same ordered type. Continuing the example, \nassume we have another functor, say an im\u00adplementationof priority queues, that uses the same trick as \nDiet: signature PRIOQUEUE = s ig type elt type queue val empty: queue val add: elt -> queue -> queue \nval extract: queue -> elt * queue structure EltSet: SET sharing EltSet.elt = elt val contents: queue \n-> EltSet.set end functor PrioQueue(Elt: ORD): PRIOQUEUE = struct ... structure EltSet = Set(Elt) ,,. \nend structure IntOrder = Then, Dictand PrioQueue cannot beusedtogether, because the set types used by \nthe contents and domain functions are not compatible: struct type t = int; fun less x y = (x<y) end \nstructure IntDict = Dict(IntOrder) structure IntPrioQueue = PrioQueue(IntOrder) Thetypes IntDict .KeySet.set \nand IntPri.oQueue.EltSet. set are incompatible, therefore the following expression does not type-check: \nIntDict.domain d = IntPrioQueue. contents q The SML solution to the problem above is to avoid ap\u00adplyinglocallythe \nSet functor and parameterize instead Diet and PrioQueue by the required Set structure: functor Dict( \nstructure Key: ORD structure Set: SET sharing Set.elt = Key.t): DICT = struct . . . structure KeySet \n= Set . . . end functor PrioQueue( structure Elt: ORD structure Set: SET sharing Set.elt = Elt.t): PRIOQUEUE \n= struct ,.. structure EltSet = Set . . . end structure IntSet = Set(IntOrder) structure IntDict = Dict(structure \nElt = IntOrder structure Set = IntSet) structure IntPri.oQueue = PrioQueue(structure Elt = IntOrder structure \nSet = IntSet) By hoisting the application Set(IntOrder) outside ofDict and PrioQueue, we have made explicit \nthat the KeySet and EltSet substructures ofIntDict and IntPrioQueue provide compatible set types. Therefore, \nthe following expression now type-checks: IntDi.ct.domain d = IntPri.oQueue.contents q However, what \nappeared to be an incremental change of the program (add some operations coexisting functors) has required \nmajor changes to the modular structure of the pro\u00adgram: All other uses ofDict and PrioQueue in the program \nmust be modified to provide the extra Set argument, even if they do not use the new operations.  Higher-order \nfunctors that take Diet or PrioQueue as arguments must also be modified.  Hoisting the application Set(IntOrder) \nfrom the points where it is actually used toa common ancestor ofthese pointsin the dependency graphis \nanon-local program transformation, as in MacQueen s diamond import example [12].  144 Introducing functor \napplications in paths enables a much more elegant solution: the functors Diet and PrioQueue can apply \nSet locally, as in the original attempt, and receive the following signatures: functor Dict(Key: ORD): \nsig type key = Key.t type a diet ... val domain: a diet -> Set(Key).set end functor PrioQueue(Elt: ORD): \nsig type elt = Elt.t type queue ... val contents: queue -> Set(Elt).set end Since the signatures show \nexplicitly how the set types are derived from the functor arguments, the structures obtained byapplying \nDiet and PrioQueue to the same ordered type now interact correctly: structure IntDict = Dict(IntOrder) \n(* :sig ,.. val domain: a diet -> Set(IntOrder).set end *) structure IntPrioQueue = PrioQueue(IntOrder) \n(* :sig ... val contents: queue -> Set(IntOrder).set end *) From the signatures above, it follows that \nthe two types IntDict.KeySet.set and IntPrioQueue.EltSet.set are equalto Set(IntOrder).set, and therefore \ncompatible. 2.5 Full transparency in higher-order functors As previously mentioned, the combination \nof dependent functor types and type equalities in signatures makes it possible to give syntactic signatures \nto first-order functors that characterize exactly the input-output behavior of functors: how they propagate \ntype components from their argument structure to their result structure. (See for example the signature \nfor Set in section 2.1.) This property, in turn, enables simple syntactic descriptions of the module \nsystem and simple separate compilation mechanisms [10], with no loss in expressiveness with respect to \nSML [11]. Unfortunately, this result does not extend straightfor\u00adwardly to higher-order functors: some \nhigher-order functors do not possess any syntactic signature that characterizes ex\u00adactly their behavior. \nConsider forinstance the paradigmatic higher-order functor: signature S = sig type t end functor Apply(functor \nF(X:S):S; structure A:S) = F(A) Theexpected behavior for this kind of functors, called the fully transparent \nbehavior in [13] and predicted by the models based on strong sums [12, 9], is that at application\u00adtime \nall type equalities known about its two arguments are combined to deduce the type equality that holds \non the t component of the result. For instance, if the F argument is the identity and the A argument \nhas t = int, then the result also has t = int; if Fis the constant functor returning t =bool, then the \nresult hast=bool. functor Identity(X:S) = X structure Int = struct type t = int end structure B = Apply(Identity \nInt) (* Weget B.t = int *) functor Constant(X:S) = struct type t = bool end structure C = Apply(Constant \nInt) (* We get C.t = bool *) With the standard notion oftype paths ,it is impossible to capture this \nbehavior inasyntactic signature for Apply. The most general signature for Apply, functor Apply(functor \nF(X:S):S; structure A:S): sig type t end does not propagate any type equalities on thet component of \nthe result. Apply can be modified to propagate some equalities in special cases, at the cost of making \nit unappli\u00adcable in other cases. For instance, the correct propagation of equalities in the example Apply(Identity \nInt) can be obtained by defining Apply as functor Apply( functor F(X: S): sig type t=X.t end structure \nA: S) = F(A) The signature for Apply is then functor Apply( functor F(X: S): sig type t=X.t end structure \nA: S) : sig type t=A.t end From this signature, it follows that B = Apply(Identity Int) haaB.t manifestly \nequalto int. But then theappli\u00adcation Apply(Constant Int) is ill-typed, since the functor Constant does \nnot meet the specification of the F argument of Apply. The modified definition of Apply propagates more \ntype equations, but makes thehigher-order functorlessgen\u00aderal. At any rate, full transparency is not \nachieved. The introduction of functor applications in type paths provides a simple, elegant solution \ntothis full transparency problem, allowing functors such as Apply to receive syntac\u00adtic signatures that \ncapture exactly their type propagation behavior. In the case of Apply, this signature is functor Apply(functor \nF(X:S):S; structure A:S): sig type t = F(A).t end This is acorrect signature for Apply: since the functor \nbody F(A) belongs totheextended class ofpaths, it has not only signature S, but also sig type t = F(A).t \nend byapplica\u00adtion of the self typing rule. Moreover, this signature propagates type equalities cor\u00adrectly, \nbecause at application-time F and Ain the result sig\u00adnature are substituted by the actual arguments ~ \nand a to the functor, and all known equalities about the result of f(a) will also hold for the result \nof Apply. For instance, structure B = Apply(Identity Int) (* : sig type t = Identity(Int).t end *)  \n145 and Identity (Int) has signature sig type t = Int. t end, from which it follows B.t = Int.t = int. \nSimilarly, structure C = Apply(Constant Int) (* : sig type t= Constant(Int~.t end *)  and Constant(Int).t \n= bool, hence C.t = bool, as ex\u00adpected. As in the first-order case, the propagation oftype equal\u00adities \nthrough syntactic functor signatures is limited by the fact that only paths are allowed in type expressions, \nnot type projections from arbitrary structures. Consider the follow\u00ading variant of Apply: functor ApplyProd(functor \nF(X:S):S; structure A:S) = F(struct type t = A.t * A.t end)  Its natural signature is: functor ApplyProd(functor \nF(X:S):S; structure A:S): sig type t = F(struct type t = A.t * A.t end).t end  Unfortunately, this is \nnot a well-formed signature, since the argument to F is not a path. We must therefore revert to the less \nprecise signature functor ApplyProd(functor F(X:S):S; structure A:S): sig type t end  which does not \npropagate type equalities as expected. To achieve full transparency, the program must be rewritten so \nthat the argument to F is a path. Since this argument contains A as a free variable, we must actually \nlambda-lift it as follows: functor G(A:S) = struct type t = A.t * A.t end functor ApplyProd(functor F(X:S):S; \nstructure A:S) = F(G(A))  Then, ApplyProd is assigned the fully transparent signature functor ApplyProd(functor \nF(X:S):S; structure A:S): sig type t = F(G(A)).t end  which ensures the proper propagation of type equations. \nThis trick is an instance of a general normalization tech\u00adnique that transforms an arbitrary program \nto eliminate ap\u00adplications of functors tenon-paths, therefore ensuring that type equations are always \npropagated as expected (see sec\u00adtion 5.2). 2.6 Applicative semantics of functor application As recalled \nin section 2.2, the standard notion of paths (P ::= z [ P.Z) istheonly one that guarantees strict type \ngenerativity. Inturn, type generativity guarantees type ab\u00adstraction. The question, then, is: how much \ntype genera\u00adtivity and type abstraction is lost if we allow functor ap\u00adplications in paths? Some generativity, \nbut no abstraction. More precisely, theonly difference is that ifwehaveafunc\u00adtor that returns an abstract \ntype, and we apply it twice to syntactically identical paths, then we obtain two compatible abstract \ntypes, while with the standard notion of paths we would have generated two distinct types. Consider: \nstructure IntSetl = Set(IntOrder) structure IntSet2 = Set(IntOrder) With the standard notion ofpaths, \nwe have IntSetl.set # IntSet2.set. If functor applications are allowed in paths, by applying the self \nrule, we obtain IntSetl: sig . . . type set = Set(IntOrder).set . . . end IntSet2: sig . . . type set \n= Set(IntOrder).set . . . end from which it follows that IntSetl.set =IntSet2.set. In other terms, the \nconsequence of adding functor ap\u00adplacations inpaths isthatfunctors returning abstract types now map equal \nstructure path arguments to equal abstract types. Wecallthis behavior applicative, byopposition to the \nusual generative behavior, where each application of such functors generates anew abstract type, whether \nthe argu\u00adments are identical or not. The applicative behavior appears only ifthefunctor ar\u00adguments are \nsyntactically identical structure paths: in all other cases. the self rule does not armlv and the abstract \n.. . types in the functor results are considered different. For instance, if we define structure IntSet3 \n= Set(IntOrder: ORD) structure IntSet4 = Set(IntOrder: ORD) we obtain IntSet3.set # IntSet4.set, since \n(IntOrder: ORD) is not a path. This may look unnatural, and more refined syntactic criteria could be \nused to determine equality of functor arguments; on the other hand, the line has to be drawn somewhere, \nand equality of structure paths is easily explained and understood. We claim that the applicative semantics \nfor functorap\u00adplacations does not violate type abstraction and does not weaken the robustness of programs. \nFirst, even though the applicative semantics makes some previously incompatible abstract types compatible \n(IntSetl.set and IntSet2.set in the example above), the representations of these abstract types are still \nhidden, and outsiders still cannot forge or in\u00adspect directly values of these types. Section 4 formalizes \nthis argument as a representation independence property. Moreover, several module-level construct still \ngenerate new types predictably, because they still do not belong to the extended class of paths: structure \nconstruction struct. . end and restriction of a structure by a signature (st~exp : sigezp). The programmer \ncan rely on these constructs to obtain new, incompatible types, if desired for added safety. Continuing \nthe example above, the types IntSetl.set and IntSet2.set can be made different by adding a signature \nconstraint: structure IntSetl = (Set(IntOrder): SET) structure IntSet2 = (Set(IntOrder): SET) The oDaaue \ninterpretation of constraints in our module ,, . calculus guarantees that all equalities known about \nthe set component are forgotten. Moreover, (Set(IntOrder): SET) is syntactically not a path, hence the \nself rule cannot be used to derive a type equality between IntSetl.set and IntSet2.set. In other terms, \nfunctor application can no longer be used to force the generation of new types (as is sometimes done \nin SML using functors with no arguments), but other constructs such as signature constraints can be used \nfor the same purposes. 146 2.7 Applicative functors and side-effects Module expressions: In an imperative \nlanguage such as ML, one may wonder whether the hypothesis that functors map equals to equals is sound, \nIn a language with side-effects and modules as first-class values [3, 7], the applicative semantics for \nfunctors is actually unsound: val r = ref false f unctor F( ) : sig type t end = (r := not !r; if !r \nthen struct type t = int end else struct type t = bool end) structure II = F() structure B = F() Semantically, \nA. t is int and B. t is bool, but the applicative semantics for functors assumes A.t = B.t. The problem \nis avoided in a stratified language such as SML: type components of structures cannot depend on values, \nonly on types, and the language of types is purely functional; hence, theapplication ofafunctor totwostruc\u00adtures \nwith identical type components returns two structures with identical type components. The applicative \nsemantics is therefore sound. It is true, however, that value components of afunctor body maydepend on \nthe store. Itwould therefore beincor\u00adrect to generalize the applicativity hypothesis to a functor maps \ntwo structures that share (in SML S structure shar\u00ading sense) to two structures that share . In this \npaper, we only consider sharing between type components of struc\u00adtures. (See [6] foratreatment ofstructure \nsharing in functor signatures.) 3 A calculus with applicative functors In preparation for representation \nindependence and expres\u00adsiveness results, we now define a module calculus with ap\u00adplacative functors, \nderived from [lO, 11]. 3.1 Syntax In the following grammar, v, t, andx are names (for value, type, and \nmodule components of structures, respectively), and vi, t,, andxi are identifiers (for values, types, \nand mod\u00adules). All identifiers (e.g. z~) have aname part (here, z) and a stamp part (i) that distinguishes \nidentifiers with the same name. Bound identifiers can be renamed, but a-conversion must preserve the \nname parts of identifiers and can only change the stamp part. This way, access by name inside structures \nis meaningful, yet a-conversion can still be per\u00adformed to avoid name clashes. Access paths: p ::=xi \nmodule identifier I p.z access to a module component I PI (P2) functor application Value expressions: \ne ::= v% value identifier I p.v value field of a structure . . . base language-dependent Type expressions: \n::= ti type identifier T Ip.t type field of a structure lintl~+~l... base language-dependent m ::= z; \nmodule identifier I p.z module field of a structure ]struct s end construction of a structure I functor(zi \n: M) m functor I ml(mz) functor application l(m:M) restriction by a signature  Structure body: s ::=eld; \ns Structure components: d::=val v,=e value definition ltypet=~ type definition I module z~=m module definition \n Module types: M::=si~ S end signature type I f unctor(z, : Ml )kfz functor type Signature body: s::= \n&#38;lD; s Signature components: D ::= val v, : r value specification I type t, abstract type specification \nI type t, = 7 manifest type specification I module w : M module specification Programs: P ::= prog s \nend We assume given a base language (value expressions e, type expressions ~) that is left mostly unspecified. \nIt can refer to value and type components bound earlier in the same structure through identifiers (vi \nand ti), and to value and type components of other structures through paths (p.v and p.t). At the level \nof the module language (m), we have struc\u00adtures, functor abstractions and functor applications. Struc\u00adtures \nare collection of bindings for values, types and mod\u00adules (either substructures or functors). The correspond\u00ading \nmodule types M are signatures (collections of decla\u00adrations for values, types and modules) and functor \ntypes (dependent function types). Type components in signatures can be declared either abstractly (type \nti)or transparently (type ti = ~). Signatures are treated as opaque for signature matching, meaning that \na transparent type binding (type ti= T)re\u00adstricted by an abstract type specification (type t;)becomes \nabstract: the type equality t,= r is forgotten. SML S gen\u00aderat ive bindings abst ype and dat at ype can \ntherefore be ex\u00adpressed as a transparent type binding followed by a restric\u00adtion by an abstract signature. \nComplete programs P are sequences of definitions s that define an integer-valued field named res, which \nis the ob\u00adservable result of the program execution. 3.2 Typing rules The typing rules for this calculus \nare shown in figure 1. The rules define the following judgments: Ekm:M The module m has module type M. \nEI-M1<:M2 The module type AIl is a subtype of the module type M2. E 1-M modtype The module type M is \nwell-formed. Ei-Pok The program P is well-typed. We write IIV(S) for the set of identifiers bound by \nthe sig\u00adnature S, and similarly for typing environments. We assume ryping of module expressions (II t-m \n: I@, structures (I3 E s : S) and programs (k P ok): E k p : (sig S1; module zi : ill; S2 end) EFs:S \nEt\u00ad ~i : E(z~) (1) Et\u00ad p.z : M{n, -p.n I n, 6 BV(S~)} (2) E + (struct s end) : (sig S end) (3) E K M \nmodtype ~i @ BV(E) E; module xi : M k ~ : M (4) E 1-(functor(r, : Al)m) : (functor(z, : Lf)A1 ) Et\u00ad rnl \n: functor(z, : Lf)kf km2:M (5) E 1-rnl(mz) : M {z, -WL2} E 1-M modtype EFm:M Et-m:M EFM <:M (6) (7) \nEP M (8) Et-E:&#38; (9) EF(m:M):M E1-m:M EFp:MJp Et-e:r v, @ J3V(E) E;valv, :rt-s:S E \\ ~ type t,@ BV(E) \nE;typeticr Fs:S (lo) (11) E 1-(val vi = e; S):(val vi :T; S) E + (type ti n ~; S) :(type ti D T; S) Etm:M \nz, $ BV(E) E;modulex, :Mks:S @ ~ (struct s end) : (sig val res : int end) (12) (13) E F (module x, = \nm; s) : (module ~i : M; S) 1-(prog s end) ok Module subtyping (E t-M <: M ): EI-M2<:M1 E; module z~ \n: M2 F Mj <: M; (14) E E functor(z. : Ml)Mj <: functor(z, : Mz)M~ EI-Tz T EI-M<:M (16) (17) E 1-(val \nv, : T) <: (val v, : ~ ) E ~ (module z~ : M) <: (module zi : M ) Et-(type t, = T) <: (type L) (18) E \nt-(type t,) <: (type t,) (19) E1-rzr E!-t, %r (20) (21) E k (type t, = ~) <: (type ti = ~ ) E + (type \nt,) <: (type t,= 7-) Type equivalence (E t-T x ~ ): Et-p:sig S1; type ti=r; S2 end E,; type t.= T;E2 \nt-t, ~ r (22) (23) E + p.t = ~{n, -p.n I n. 6 BV(S1)} (Rules for congruence, reflexivity, symmetry, transitivity \nand base language-dependent equivalences omitted.) Well-formedness of module types (E k M modtype): rules \nomitted. Figure 1: Typing rules given typing judgments E 1-e : r and E 1-r type for the 3.3 Denotational \nsemantics base language. The self rule mentioned in section 2.2 The dynamic semantics of the module calculus \nis obtained (rule 7) uses a type strengthening operation written M/p, by erasing all type information \nand mapping structures to which enriches the module type M to reflect that its abstract records and functors \nto functions. This is formalized as a type components come from the path p, as follows: standard denot \national semantics shown in figure 2. We as\u00ad sume given a domain B of values for the base language, (sig \nS end)/p = sig S/p end including a constant wrong denoting run-time type errors, (functor(z, : Ml)Mz)/p \n= functor(z, : Ml)(Mz/p(~i)) and a meaning function [.] ~ for expressions of the base lan\u00ad /P =E guage. \nWriting ~n for partial functions with finite domain, (val Vi : T; S)/p z val Vi : 7; S/p the domain \nV of values for the module language is defined (type t%; S)/p == type ti s P.t; S/p as: (type t%= -r; \nS)/p = type t%= p.t; S/p V = ( ValName ~ B) x (ModName ~n V) (module x, : M; S)/p = module x. : M/p.z; \nS/p + (V ~ V) + wrongl 148 Meaning of module expressions and programs: [ai], ~.z]P [struct s end], \n[functor(xi : 114)rn]P [ml (rnz)], [(m : M)]p = = = = = = if z, c Dom(p) then p(x~) else wrong let d \n= ~], in if z E Dom(cl) then d(z) else wrong [s], Ad. if d = wrong then wrong else [rn]P+t., -~} if ~ml], \nc V ~ V then [rnl],([mz],) else wrong [m], [en, [val v, = e; s], [type t = T; s], [module z; = m; s], \n[prog s end] = = = = = {} let d = [e]P in if d = wrong then wrong else let d = [s] P+{ V,xd} in if d \n= wrong then wrong else {v [s], let d = [m]P in if d = wrong then wrong else let d = [s] P+{ Z,_d} in \nif d = wrong then wrong else {z let d = [s]O in if res c Dom(s) then s(res) else wrong w = cl}+ d}+ d \nd Extension of the meaning function on value expressions: &#38;.v]P = let d = ~], in if w c Dom(d) then \nd(v) else wrong Figure 2: Denotational semantics 4 Representation independence functor interpretations \n(functions from interpretations to in\u00ad terpretation;). Interpre~ation environments-r E InterpEnv We now \nshow that applicative functors ensure a suitable map type identifiers to base relations and module identifiers \nnotion of type abstraction. Following Reynolds [17] and to module interpretations. An interpretation \nenvironment 17 Mitchell [15], we use representation independence as the provides a meaning to type paths \nas admissible relations be\u00ad semantic characterization of type abstraction: a language tween base values \nin the obvious way: enforces type abstraction if two implementations of an ab\u00adstract type can be observationally \nequivalent (substituting r(p.t) = (r(p))(t) one by the other in any program does not change the out\u00ad \nr(p.z) = (r(p))(m) come of the program), yet use different representation types r(p1(P2)) = (r(Pl))(r(Pz)) \n to implement this abstract type. The proof is an adaptation of Mitchell s proof for the SOL calculus \n[15], which relies on We first define a family (R:) of logical relations over logical relations. values \nof the base language in the usual way: We first define binary logical relations for the values and type \nexpressions of the module calculus. Logical relations (bl,bz) e RF iff bl and b, are equal integers \nare presented as the judgement r 1= w H v : M ~ T, read: under the type interpretation 17, the values \nv and v are (bl, bz) c R: iff ti E Dom(r ) and (bl, bz) E f (t~) equivalent when observed under type \nM and produce the type interpretation T . The type interpretation 17 assigns (bl, b2) c R~f iff 17(p.t)defined \nand (bl, bz) c is I (p.t) a meaning to the type identifiers and type paths appearing . (bl, bz) c Rr \n+0 iff bl and b, are functions, and for all in M. The T component records the relations we used to base \nvalues (al, az) c R;, we have (bl(al), b,(az)) 6 prove the equivalence of v and v . We need T because \nthe R; elimination construct we use for abstract types (type paths) has open scope, in contrast with \nMitchell s open construct, We then define the judgement r \\ v%v :M + T by which has closed scope. induction \nover M, as follows. Let BaseRel be the set of admissible relation between base values (binary relations \nover B that do not relate wrong 1.r* S1~S2: sig S end ~ T M S1 and S2 are seman\u00adwith wrong). Define tic \nsignatures such that J7 1= S1 = S2 : S * T ModInterp = 2. rpjl~ j, : functor(z~ : M)N a T M jl, f2 and \nT are functions such that for all values V1, V2 and (TypeName 4 BaseRel) x (ModName 3 ModInterp) interpretations \nX satisfying 17 ~ u % V2 : M * X, + (Modlnterp ~ ModInterp) we haveInterpEnv = (TypeIdent ~n BaseRel) \nx (ModIdent ~n ModInterp) f,(v,) : N * T(X) Module interpretations T c ModInterP are either struc\u00adture \ninterpretations (a record mapping type names to base 3. semantic signatures sl relations and module names \nto module interpretations), or 4. r ~ S1%52 :(val v, :~; S) a T iff (s1(7J),s2(v)) E R~andr~slzs2:S+T \n 5. r 1=S1 w 52 : (type t,; S) * T iff there exists an admissible base relation R and an interpretation \nT such that I +{t, wR} #s1~s2:S~T and T={tt-+R}+T 6. 17~slws2: (type tz=T; s)+ Tiffr+ {ti~ R~}~sI%sz: \nS+-T and T={t~R~}+T 7. r 1=S1% 52 :(structure x, :A4: S) a T iff there  exists ~nterp~etations T and \n~ such that 17 + SI (z) x sz(z):A4+ T andr+{ww T }~sIxsz:s~ T and T={zw2 } +T Notice that in the fifth \ncase (declaration of an abstract type t~), we do not require t;to be implemented by the same type expression \nin the two structures denoted by s and s : we can interpret tiby any admissible relation, not only R? \nfor some r, as long as the relation makes the remainder of the two structures related [15], We define \nsimilarly an equivalence relation 17 1= p N p : E + I between evaluation environments p and p viewed \nunder the typing environment E. The 17 component is an extension of r with interpretations for the identifiers \nde\u00adclared in E. The fundamental lemma of logical relations for the mod\u00adule calculus is as follows: Proposition \nlIf Et-m: Mand O~p%p :E+r, then there exists an interpretation T such that 171= [m], H [m],, :M ~ T. \nProof: standard inductive argument on the derivation of EFm:M. 1 As a corollary, we obtain the representation \nindepen\u00addence property: two closed module expressions whose mean\u00adings are related can be substituted \none for the other in any program. The first formulation is as follows: Proposition 2 Let ml and mz be \ntwo closed module ex\u00adpressions such that @ 1-ml : M and @ R m2 : M. Assume 01-[ml]@ % [m2]0 : M ~ T for \nsome T. For all pro\u00adgram contezts C[ ] such that z, : M t-C[z,] ok, we have [C[ml]] = [C [m2]]. Proof: \nLet D[ ] be the structure context such that C[] = prog D[] end. We have [C[ml]] = [D[ml]]O(res) and similarly \nfor mz. Let pl = {~i * [ml]O} and P2 = {Zi w [mz]o} and E = (W : M). By hypothesis onml and mz, wehave \n0l==pl %pz:E+ rwhere r = {Zi w T}. By hypothesis on C, we have E + (struct ll[zi] end) : (sig val res \n: int end). From the fundamental lemma, it follows that r ~ [struct D[z;] end]Pl x [struct D[~i] end]o, \n: (sig val res : int end) a T for some T . It is easy to check that [D[~i]]pl = [Il[ml]]o, and similarly \nfor m2 and p2. Extracting the res integer field from the denotations of D [ml] and Ll[mz], it follows \nthat ([~[ml]]o(res), [~[mz]]a (res)) G R? , which means [C[ml]] = [C[m2]] since R~ k the equality relation \nover integers. 0 Proposition 2 is a relatively weak result, because the assumption Xt : M E C[z,] ok \nrequires the program con\u00adtext C[ ] to be parametric with respect to all possible im\u00adplementations of \nthe signature A/f and prevents C[ ] from taking advantage of more typing hypothesis that could be derived \nabout a particular implementation. The following reformulation of proposition 2 shows that even without \nthe hypothesis z; : M k C[xi] ok, the applicative functor calcu\u00adlus prevents C[ ] from depending too \nclosely on a particular implementation of M. In the following statement, we say that a module type M \nis principal for a module expression m in an environment E if E H m : M and for all types A/l and environments \nE such that 13V(E ) n l?V(E) = 0, if E; E E m : M , then E;E +M <: M . Proposition 3 Let ml and mz be \ntwo closed module expres\u00ad sions and M be a module type. Assume that M as a principal type for ml and \nfor m2 in the empty environment. Then, for all program contexts C[ ], the program C[ml] is well-typed \nif and only if C[m2] is, and if so, [C[ml]] = [C[m2]]. Proofi Assume 0 E C[ml] ok. Using the fact that \nM is principal for ml, we can build a derivation of x, : M + C[z;] ok. Applying proposition 2, it follows \nthat [C[ml]] = ~C [mz]]. 0 Two closed modules ml and m2 that have a common principal type and are equivalent \nat that type are there\u00adfore observationally equivalent. Moreover, this condition does not require that \nthe two modules implement their type components by the same representation types. Consider the typical \nsituation: M = sig type t; val x: t end ml = (struct type t =~1; val x=... end :M) m2 = (Struct type \nt = rz; val x=... end :M) If ml and mz are well-typed, then M is principal for ml and mz. (Since signature \nconstraints are not paths, the (self rule does not apply to ml and m2, and therefore no type smaller \nthan M can be derived. ) Moreover, by definition of logical relations, the denotations of ml and m2 can \nbe related even if ~1 is incompatible with r2. This would not be the case if the class of paths were \nextended further, e.g. by allowing any module expression in paths. Then, the self rule would apply to \nthe definitions of ml and m2, allowing the derivation of the following t ypings: ml : sig type t=ml. \nt; val x: tend m2 : sig type t =m2.t; val x: t end and M would no longer be the principal type of ml \nand m2. The hypothesis that ml and m2 have the same principal type would force ml and m2 to be syntactically \nidentical, hence ~1 and I-Z to be identical as well. This situation cannot happen in the applicative \nfunctor calculus: ml and mz in proposition 3 cannot be paths since they must be closed, while paths p \n::= xi ] p.% I pl (pz) always have at least one free structure identifier. Hence, the self rule does \nnot apply to ml and m2, thus ml and mz can have the same principal type while implementing abstract type \ncomponents differently. This discussion shows that introducing functor applica\u00adtions in paths does not \ncompromise representation indepen\u00addence as characterized by proposition 3, but further exten\u00adsions of \nthe class of paths could. 150 l yping rules: E;xi:M1t-m:M2 EFmI:IIz; :A4. M E + z, : -E(G) (24) Et\u00ad \n(kr; :MI.m): (IIzi:M1. M2) (25) E k ml(mz) : M {zi +m2 M + mz} (26) Ei-m:M Ei-M<:M (27) E1-m:M (28) \nEke:r (29) E t- T type (30) E1-m:M E1-m: M/m E k Lw(e) : V(r) E + L,(T) : Eq(r) E1-ml:ilfl E+(x, =ml, \nE;x%:Ml mz) : (Ex; Fm2:M2 :MI, MZ) (31) EFm:Ex, E1-rl(m):Ml :M1. Mz (32) Et\u00ad Ekm:Ex, rz(m) :M1. : M2{G \n- Mz rl(m)} (33) Subt yping and type equivalence: (rules omitted: congruence, transitivity and symmetry \nfor =, transitivity for <:) EI-M%M E k r type E k m Q(T) (34) (35) (36) E+~t(m)=T EI-M<:M E 1-EtJ(T) \n<: TYPE E1-MI<:M~ E; Z,: MI I-M2<:M; EFM{<:MI E;xi:M~t-M2<:M~ (37) (38) E + (Du :M1. Mz) <: (DDt :M~. \nMj) E + (k :MI. M2) <: (IIq :M~.M~) I ype strengthening: V(7)/m = V(7) TYPE/m = Eq(z, (m)) Eq(7)/m = \nEq(~, (m)) (Zzi : Ml. M2)/m = Iki : (M1/rl(m)). (MZ/n2(m)) (Ib : MI. Mz)/m = IIzt : MI. (Mz/m(zi)) Figure \n3: Typing rules for the manifest sums calculus 5 Full transparency for higher-order functors In this \nsection, we prove that the module calculus with applicative functors has fully transparent higher-order \nfunc\u00ad tors, in the sense of MacQueen and Tofte [13]. One way to prove this result is to take their static \nsemantics for higher\u00adorder functors and show that all correct programs in this semantics are well-typed \nin our calculus. We have not been able to show this result due to the complexity of their formal\u00adism. \nInstead, we will show that the calculus with applica\u00adtive functors can encode a stratified calculus with \nstrong sums similar to MacQueen s DL calculus and Harper and Mitchell s XML calculus [12, 9]. Strong \nsums account for many features of the SML module system, excluding gen\u00aderativity but including transparent \ntype bindings and fully transparent higher-order functors. The existence of a type\u00adpreserving encoding \ninto the calculus with applicative func\u00adtors is therefore a strong hint that the latter ensures full \ntransparency. 5.1 The manifest sums calculus To simplify the encoding, we start from the manifest sums \ncalculus, a variant of the strong sums calculus that differs on the way type equalities are propagated \n(through compile\u00adtime reductions of terms in the strong sums calculus, but through enriched types in \nthe manifest types calculus), but has the same expressive power. All terms well-typed with strong sums \nare also well-typed with manifest sums; we omit the proof, which is along the lines of the proof of proposi\u00adtion \n1 in [10]. The manifest sums calculus has the following syntax: Terms: m ::= z, [ XZX : M.m I ml(mz) \n[ Lu(e) I L,(T) [ (U =ml, m,) I m(m) I 72(m) Types: M ::= V(T) ITYPE IEq(~) I~z~ :Ml. Mz II@ :Ml. M2 \nSimple terms: e ::= ... \\mu(m) Simple types: 7 ::= ... I7r~(m) Structures are built from injections ~v \n(e) of simple terms (values) and Lt (T) of simple types using the dependent pair operator (Xi = ml, mz \n). The corresponding signatures are V(7) for a value of type ~, Ell(~) for a type manifestly equal to \nI-, TYPE for an arbitrary type, and Z-types (dependent pair types). Access inside structures is provided \nby the pro\u00adjections TV for values, ni for types, T1 and 7rz for pair com\u00adponents. Functors are presented \nby A-abstractions and II\u00adtypes (dependent function types). The typing rules for the calculus are shown \nin figure 3. 5.2 Path normalization In preparation for the encoding into the applicative functor calculus, \nwe first show how to rewrite terms to meet the syntactic restrictions imposed by the latter, such as \nthe re\u00adstriction of projections to paths. Paths p in the manifest sums calculus are described by the \ngrammar P ::= ~~ I m(P) I 7n(P) IP1(P2). To express the rewriting more easily, we extend the syn\u00adtax \nof terms and types with a let binding (i.e. explicit sub\u00adstitutions): Terms: m ::=... net cri.nm Types: \nM ::= . ..l Let ain M Substitutions: cr::=&#38;/z, =rn; a For the purposes of type-checking and evaluation, \nlet xl = ml; . . . ; zn = m~ in m is treated as the textual substitu\u00adtion m{zn + inn}... {zl + ml}. The \nfirst group of rewrite rules introduce names for ar\u00adguments to projections that are not paths. In the \nfollowing, m. ranges over terms that are not paths. Over terms: ~V(e[Tv(mc)]) + let Z; = m. in L. (e[7rU(zi)]) \n~t(-r[7rt(riac)]) + let zi = mc in &#38;i(7[7rt(zi)]) 7rl(m=) + let z, = mC in 7rl(z, ) 7T2(m. ) -+ let \nx, = m. in 7rz(z,) m(rnC) + let z, = m. in m(x. ) Over types: V(~[~~(mc)]) + Let z, = m in v(~[mL(z,)]) \nEQ(-r[r~(rn.)]) + Let x, = m in EQ(-r[T~(cEi)]) The let bindings have no equivalent in the applicative \nfunc\u00adtor calculus, unless they occur immediately below a pair construction, in which case they can be \ntranslated as extra bindings in a struct. . . end. The second group of rules lift let bindings upwards \nuntil they hit a pair operator. Over terms: let ainlet a inm + let a;a inm (let a in ml)(rm) + let a \nin ml(mz) kE~:M. letainm + let Xz, : M.c7 in a(m, z,) kc, :(Let a in hf). rrz + let a in ~x, :k!. m Over \ntypes: Let ainLet u inM + Let a;a inM Xx, : (Let a in Ml). ibfz + Let u in xx, :iVfl.MZ Xri :Illl. (Let \no in Mz) + Let Jx, :M1. a in Zzt : M1. C7(M2, X2) Hz, : (Let a in Nfl).~z + Let a in Hz, : M1. kf2 IIx, \n: Ml. (Let a in A4z) + Let kc, : ~1.ff in IIz, : A fl. a(kfz,w) Over substitutions: z;=(let u in m); \n0 + 0; x,=m; u To express the introduction of abstractions and applica\u00adtions when a let-binding crosses \na binder (J, X or H), we have used the following notations: if u is the substitution yl= ml;...; yn = \nm%, we write Ax, : M. c1 for yl=Axi: M.ml; . . ..yn=Ax. :M. mn a(m, Q) for m{yl + YI(XI). . .yn +--yn(xi)} \nIt can be shown that the rewrite rules above preserve typing: if E 1-m :M and m + m , then E 1-m :M. \nMoreover, a term in normal form with respect to the rules above is such that: all projections are applied \nto paths; all functions ar\u00adguments in applications are paths; no Let bindings remain; and let bindings \noccur only in toplevel position or as ar\u00adguments to a pair construction. Assuming without loss of generality \nthat complete programs have a pair in toplevel position, and identifying m with let s in m as needed, \nwe can therefore describe normalized programs by the following grammar: Paths: P ::= x, Im(P) I 72(P) \nI P1(P2) Normalized terms: m::=p I ki:M. m I m(p) I L.(e) [ L,(T) [ (x, = (let a, in ml), let az in m,) \nSimple terms: e ::= . . . I*U(p) Simple types: T ::= . . . I 7rt(p)  5.3 Encoding Normalized terms \nare then encoded as module expressions from the applicative functor calculus by turning injections and \npairs into structures with conventional field names (v for values, t for types, fst and snd for pair \ncomponents). The encoding, written [j, is defined as: lztj = x, [m (p)] = ~] .fSt Lfiz(p)] = ~] .snd \nlAx, : M. m] = functor(x, : [M]) [mj [m(p)j = [m] (~j) [~v (e)~ = struct val v, = Lej end [~t(7)] = struct \ntype t, = [-T] end L(x, = (let ml in ml), let C7Z in mz)J = struct la,] ; module f stj = Lmlj; Lmj {Xt \n+ f St,}; module snd~ = Lmz] {x, + fstj} end The encoding of a substitution is a sequence of module ~in~: \n1x1 = ml; .... X. = mn] is (module XI = . . . ; module Xn = Lm.j ). Types are translated to module types \nand signatures as follows: [V(~)j = sig val v% : 17] end lTYPE] = sig type t, end lEQ(~)] = sig type \nt, = [~] end [Xx, : MI. M2J = sig module f stj : [MI]; module snd~ : 1M2] {x, +-fst~} end [~Xt : Ml . \nM2J = functor(z, : lMI] ) [M2J Finally, for projections inside values and simple types, we take [7rti(p)j \n= ~] .V [7r,(p)J = ~j .t We then show that this encoding is type-preserving: if E # m: M in the manifest \nsums calculus and E, m, M are normalized, then [lZJ % Lmj : [MJ in the applicative functor calculus. \nThis completes the proof that our calculus with applicative functors can express strong sums. 6 Related \nwork Several semantics for fully transparent higher-order functors have been given, first in type-theoretic \nframeworks based on strong sums [12, 9], then as extensions of SML S stamp\u00adbased static semantics [13, \n2]. Only MacQueen and Tofte s formalism [13] handles the full SML module language; both the strong sums-based \nmodels [12, 9] and Biswas s static se\u00admantics based on higher-order variables [2] fail to account for \ngenerative type definitions. Unfortunately, MacQueen and Tofte s description is technically involving, \nin part because it is oriented towards an efficient implementation (functor re-elaboration is minimized), \nThe present paper provides a simpler description of fully transparent higher-order func\u00adtors with both \ngenerative and non-generative type bindings; the main missing SML feature is structure generativity and \nsharing. Among the formalkms mentioned above, ours is the only one that provides complete syntactic \nsignatures for higher\u00adorder functors (syntactic signatures that captures exactly their transparent behavior), \nwhich are required to support Modula-2 style separate compilation. Cr6gut [6] also attacks the problem \nof complete syntactic signatures for higher\u00adorder funct ors. His proposal relies on enriching signatures \nwith equalities between structures (ours uses only equali\u00adties between types), which has the advantages \nof account\u00ading for structure sharing and remaining compatible with the standard generative semantics \nof functor application, and the disadvantage of requiring a rather complex stamp-based formalism. A notion \nof functors with applicative semantics appears in Rouaix s Alcool language [18], which combines Haskell\u00adstyle \ndynamic overloading with a type abstraction mecha\u00adnism. In the presence of dynamic overloading, applicative \nfunctors arise naturally as a generalization of ML s param\u00adetrized type constructors such as list: when \ntypes are equipped with dictionaries of functions implementing over\u00adloaded symbols at that type, parameterized \ntypes become functors from types plus dictionaries to types plus dictionar\u00adies. Since type constructors \nare applicative by definition (the types 71 list and TZ list are equal as soon as n = TZ), these functors \nnaturally have applicative semantics. The ap\u00adplicative semantics of functors might therefore prove useful \nto account for type classes or Alcool-style abstract types by translation to a language with structures \nand functors. 7 Conclusions The applicative semantics of functor applications seems use\u00adful to increase \nthe expressive power of the SML module sys\u00adtem, and has very little impact both on the semantic proper\u00adties \nof the language and on the complexity of its type system. It supports precise syntactic signatures for \nfully transparent higher-order functors, which facilitates separate compilation and provides a simple \nformalization of full transparency. On the negative side, the applicative semantics precludes mod\u00adules \nas first-class values; also, existing stamp-based type\u00adcheckers cannot easily be modified to implement \nit. More practical experience with the applicative semantics is needed to assess its impact on the modular \nprogramming style. References [1] A. W. Appel and D. B. MacQueen. Separate compi\u00adlation for Standard \nML. In Programming Language Design and Implementation 1994, pages 13-23. ACM Press, 1994. [2] S. K. Biswas. \nHigher-order functors with transparent signatures. In 22nd symp. Principles of Progr. Lang. ACM Press, \n1995. [3] L. Cardelli. Typeful programming. In E. J. Neuhold and M. Paul, editors, Formal description \nof program\u00adming concepts, pages 431 507. Springer-Verlag, 1989. [4] L. Cardelli and X. Leroy. Abstract \ntypes and the dot no\u00adt ation. In M. Broy and C. B. Jones, editors, Proceedings IFIP TC2 working conference \non programming concepts and methods, pages 479 504. North-Holland, 1990. [5] L. Cardelli and D. B. MacQueen. \nPersistence and type abstraction. In M. P. Atkinson, P. Buneman, and R. Morrison, editors, Data types \nand persistence. Springer-Verlag, 1988. [6] P. Cr6gut. Compilation s6par6e pour un langage de modules \navec types g6n6ratifs, Sept. 1994. Presentation given at the 1994 meeting of the G .D.R. Programma\u00adtion \n, C. N,R.S. [7] R. Harper and M, Lillibridge. A type-theoretic ap\u00adproach to higher-order modules with \nsharing. In .21st symp. Principles of Progr. Lang., pages 123 137. ACM Press, 1994. [8] R. Harper, R. \nMilner, and M. Tofte. A type discipline for program modules. In TAPSOFT 87, volume 250 of LNCS, pages \n308-319. Springer-Verlag, 1987. [9] R. Harper and J. C. Mitchell. On the type struc\u00adture of Standard \nML. ACM Trans. Prog. Lang. Syst., 15(2):211 252, 1993. [10] X. Leroy. Manifest types, modules, and separate \ncompi\u00adlation. In 21st symp. Principles of Progr. Lang., pages 109-122. ACM Press, 1994. [11] X. Leroy. \nA syntactic approach to type generativity and sharing (extended abstract). In Proc. 1994 Workshop on \nML and its applications, pages 1 12. Research report 2265, INRIA, 1994. [12] D. B. MacQueen. Using dependent \ntypes to express modular structure. In 13th symp. Principles of Progr. Lang., pages 277-286. ACM Press, \n1986. [13] D. B. MacQueen and M. Tofte. A semantics for higher\u00adorder functors. In D. Sannella, editor, \nProgramming languages and systems -ESOP 94, volume 788 of LNCS, pages 409 423. Springer-Verlag, 1994. \n[14] R. Milner, M. Tofte, and R. Harper. The definition of Standard ML. The MIT Press, 1990. [15] J. \nC. Mitchell. On the equivalence of data represen\u00adtat ions. In V. Lifschitz, editor, Artificial intelligence \nand mathematical theory of computation, pages 305 330. Academic Press, 1991. [16] J. C. Mitchell and \nG. D. Plotkin. Abstract types have existential type. ACM Trans. Prog. Lang. Syst., 10(3):470-502, 1988. \n[17] J. C. Reynolds. Types, abstraction and parametric polymorphism. In Information Processing 83, pages \n513 523. North-Holland, 1983. [18] F. Rouaix. The ALCOOL 90 report. INRIA, 1992. Included in the distribution \navailable on f tp. inria. f r.  \n\t\t\t", "proc_id": "199448", "abstract": "<p>we present a variety of the Standard ML module system where parameterized abstract types (i.e. functors returning generative types) map provably equal arguments to compatible abstract types, instead of generating distinct types at each applications as in Standard ML. This extension solves the full transparency problem (how to give syntactic signatures for higher-order functors that express exactly their propagation of type equations), and also provides better support for non-closed code fragments.</p>", "authors": [{"name": "Xavier Leroy", "author_profile_id": "81100078576", "affiliation": "INRIA, B.P. 105, Rocquencourt, 78153 Le Chesnay, France", "person_id": "PP39026141", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199476", "year": "1995", "article_id": "199476", "conference": "POPL", "title": "Applicative functors and fully transparent higher-order modules", "url": "http://dl.acm.org/citation.cfm?id=199476"}