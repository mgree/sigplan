{"article_publication_date": "01-25-1995", "fulltext": "\n A Unified Treatment of Flow Analysis in Higher-Order Languages Suresh Jagannathan Stephen Weekst Abstract \nIn this paper, we present a framework based on an ab\u00ad stract interpretation[6, 5] of an operational semantics, \nSection 2 first defines an untyped, higher-order, call- We describe a framework for flow analysis in \nhigher-order by-value language extended with recursion, condition\u00ad languages. It is both a synthesis \nand extension of earlier als, and references, Section 3 defines an exact semantics work in this area, \nmost notably [20, 22]. that formalizes the notion of flow graph. The semantics The framework makes explicit \nuse of jlow graphs for is similar to a collecting 2nterpretat20n[9] insofar as a flow modeling control \nand data flow properties of untyped graph records the history of a computation; however, a higher-order \nprograms. The framework is parametri-flow graph also contains additional dependence informa\u00adzed, and \ncan express a hierarchy of analyses with dif-tion corresponding to the movement of data values. ferent \ncost/accuracy tradeoffs. The framework is also Section 4 presents a parameterized abstract semantics \namenable to a direct, efficient implementation. that is capable of expressing a range of analyses with \nWe develop several instantiations of the framework, and different cost/accuracy tradeoffs. The abstract \nseman\u00adprove their running-time complexity. In addition, we tics manipulates flow graphs which approximate \nthose use the simplest instantiation to demonstrate the equiv-constructed by the exact semantics. An \napproximation alence of a OCFA style analysis[20] and the set-based is based on a finite partition of \nthe nodes in the exact flow analysis of [8]. graph. Section 5 considers the coarsest possible partition \nand relates it to set-based analysis [8], an analysis that is 1 Introduction also capable of capturing \ncontrol-flow information. Section 6 describes a direct implementation of the ab-The flow analysis problem \nfor higher-order program\u00ad stract semantics. We argue that the representation of ming languages such as \nScheme [4] or ML [13] is con\u00ad the abstract state in terms of a flow graph enables such cerned with tracking \ndata and control flow in the pres\u00ad an implementation to be efficient. We also present an in\u00adence of first-class \n(anonymous) procedures, rich data ab\u00ad formal description of the running-time complexity of any st ractions \n(e. g., lists, records, tuples, et c), and refer\u00ad instantiation of the semantics. Section 7 develops \nseveral ences. In the context of these languages, an effective instantiation and proves their running-time \ncomplexity.control-flow analyzer can enable a number of important We consider a slight modification to \nthe semantics and optimizations such as lifetime and escape analysis [15], a new instantiation in Section \n8. Section 9 discusses re\u00adtype recovery [19], safety analysis[14] efficient closure lated work. analysis \n[17], constant folding, and code hoisting, There is a spectrum of control-flow analyses that can be \n2 Language implemented for these languages. For example, an ex\u00adact control-flow analyzer is simply an \ninterpreter that preserves all information generated during the evalua- The language (see Figure 1) \ncontains simple expressions, tion of a program. It has high accuracy but also a pro-call-by-value function \napplications, primitive operations, hibitively high cost since its running time is proportional constructor \napplications, and case expressions. A sim\u00ad to the running time of the input program. In contrast, a ple \nexpression is either a constant, variable, lambda ex\u00advery inexact interprocedural analysis might combine \nall pression, or recursive function declaration, and is self\u00adresults of a function applied from all its \npotential call evaluating. Applications are evaluated left to right. sites. It has low accuracy since \nit does not disambiguate The primitive operations that we consider manipulate among the set of functions \ncallable from a given call site first class reference objects. The expression box (e) or the set of values \napplied to a given function. However, creates a new reference that contains the value of e, it also has \nrelatively low running time complexity. unbox (e) returns the value stored in the reference de\u00ad Computer \nScience Division, NEC Research Institute, Prince-by (e 1, ez ) replaces the stored noted e, and set-box! \nvalue ton, NJ. suresh@research. nj .nec. corn. in the reference denoted by el with the value of ez. t \nDept. of Computer Science, Carnegie Mellon University, Pittsburgh, PA. sweeks@cs. cmu. edu. Constructor \napplications are of variable arity, where c Permission to copy without fee all or part of this material \nis ranges over a set of constructor names. A case expression granted provided that the copies are not \nmade or distributed for compares the value of its first subexpression against the direct commercial advantage, \nthe ACM copyright notice and the constructor name and arity of the given pattern. If the title of the \npublication and its date appear, and notice is given value matches, then it is destruct ured, each x, \nis bound, that copying is by permission of the Association of Computing Machinery. To copy otherwise, \nor to republish, requires a fee and/or specific permission. POPL 951/95 San Francisco CA USA @ 1995 ACM \n0-89791-692-1/95/0001 ....$3.50 node (x, b(z) ). Variable nodes are introduced whenever e ::= k I z I \nk.e I (ret f kc.e) \\ (e, e2) bindings are constructed, e.g., in function application or I Peel,..., em)lc(el,em),em) \ncase evaluation. [ case(el, c(xl,..., $m) *e2, y+e3) k~ Const ~!Y = Var P~ Primop = {box, unbox, set-box!} \nc E Constructor Fimre 1: Thelanmage and evaluation continues with e,. Otherwise, y is bound to the \nvalue and evaluation continues with e,. We use the usual conventions of free and bound vari\u00adables. Note \nthat a case expression binds xl, . . . ,z~ in e2 and y in es. A program P is an expression with no free \nvariables. We assume that each subexpression oc\u00adcurrence in a program has been assigned a unique label \nldrawnfrom an infinite set Label. Weindicate a labeled expression as either et or [e]l. 3 Exact Semantics \nOur framework is based on an abstract interpretation [6, 5] of an operational semantics. The exact semantics \nof a program P is specified by a set of exact states State and a transition function ---+, both specific \nto P. The semantics works directly over the source language; there is no transformation to an intermediate \nform such as continuation-passing st yle[l]. The semantics explicitly constructs an ezact flow graph. \nFor each expression e that is evaluated, a node is added to the graph to the store the value of e. Each \ntime a value flows from one node to another, a directed edge is added to the graph to indicate the flow. \n3.1 Exact States The definitions of State and its components appears in Figure 2. Ax A and A+ A denote \nthe cartesian product and disjoint union of A and A , respectively. A -+ A denotes the set of partial \nfunctions from A to A . A * de\u00adnotes the set of finite sequences of elements of A. P(A) is the powerset \nof A. Note that State is well defined, since each definition refers only to sets defined below it. An \nexact state contains components that are similar to those that might be found in a more typical abstract \nma\u00adchine (e.g., program counter, environment, stack, heap). The Label component of the state corresponds \nto the pro\u00adgram counter. The BindingEnv component corresponds to the current environment. The Nodes and \nEdges components of State define a graph, where the set of nodes is represented as a par\u00adtial function \nmapping a unique identifier (NodeLabel ) to the value of the node. There are two kinds of nodes that \nappear in the semantics. The expression node (1, b) con\u00adtains the value of et evaluated in environment \nb. The value of free variable z in el can be found in the variable Note that a value in this semantics \nis a pair (1, b) that denotes an expression node in the graph. Since expres\u00adsion nodes are associated \nwith a program expression and a binding environment used in the evaluation of this ex\u00adpression, this \nrepresentation is sufficient to capture all concrete values generated during program evaluation. Informally, \ncontours are used to allocate new dynamic activation frames. In the following, we represent a con\u00adtour \nas a list of call-site labels, w-here ea~h call-site la\u00adbel is the label of an application expression. \nIn contour (1,,... , 1~ ), 11 denotes the most recent call-site and 1~ denotes the least recent. The \nempty contour is (). We write l:(zl, . . . . 1~) to append call-site 1 onto (11, . . . . 1~), yielding \n(1, 11, . . . , 1~ ). Abstractions using call-site infor\u00admation have been proposed elsewhere[lO, 20, \n18]. Our semantics, however, is not closely tied to this particular contour representation; in In Section \n8, we present an alternative and discuss its implications. 3.2 Exact Transit ion Function The definition \nof + for the functional core of the lan\u00adguage appears in Figure 3. The rules for primitives, con\u00adst ruct \nors, and conditionals can be found in Appendix A. The definition relies on the auxiliary syntactic function \nfirst, which maps an expression to the label of its left\u00admost outermost simple subexpression. Definition \n(first) 1. fh-st(e~) = 1 if e is simple. 2. jimt((el e2)) = jimt(el) 3. jirst(p(el, . . . ,em)) = jirst(el) \n 4, first(c(el, . . . , em))= first(el) 5. jirst(case(el, c(rl, . ,zm) * e,, y + e,)) = jimt(el)  The \ninitial state for program P is: so = (first(P), kc. 1, (), Jn. 1, {}). As an explanation of the notation \nused in Figure 3, N(l, b) =1 is true iff the partial function N is not de\u00adfined on node label (1, b). \nSimilarly, N(l, b) = w is true iff N is defined on node label (1, b). We use ~[al ++ a,] to denote the \nfunction which agrees with j on all argu\u00adments except possibly al, which it maps to a,. We use ~[al, \na, ++ a,] to abbreviate ~[al H at][a, ++ as]. The rules CONST, VAR, LAMDBA, and REC define what happens \nwhen the program counter points to an expression that can be immediately evaluated. Each of these rules \nadds a new node to the graph containing the value of the expression. VAR also adds an edge to record \nthe flow of the value from the variable node to the expression node. REC builds a recursive function \nby adding a new variable node (~, cn) to store the function, State Label x BindingEnv x Contour x Nodes \nx Edges Nodes NodeLabel * Value Edges P(Edge) Edge NodeLabel x NodeLabel NodeLabel (Label x BindingEnv) \n+ ( Var x Contour) Value Label x BindingEnv BindingEnv Var ~ Contour Contour Label Figure 2: Exact States \n If [,%1] c P and IV(1, b) =1, then (1, b, cn, N, E) A (1, b, cn, N[(l, b) w (1, b)], E) CONST If [zl] \nG P and then (1, b, cn, N, N(l, E) b) - =1, (1, b, cn, N[(l, b) H N(x, b(r))], E U {(z, b(z))+ (1, b)}) \nVAR If [(kz.e)l] G P and N(J, b) =1, then (1, b, cn, iV, ,?3) + (1, b, crz, N[(l, b) H (1, b)], E) LAMDBA \nIf [(ret ~ (kz.e)l, then (1, b, cn, N, )l] E) G P - and N(l, b) (t, b, cn, N[(l, =-l-, b), (j, cn) H \n(1 , b[f H en])], E) REC If [([el]l ez)~ c P and N(Z, b) = W, then (1, b, cn, N, E) ~ (jh-st(ez), b, \ncn, N, E) ARG If [([el]ll [ez]l,)l~, [(kc. e~,,)l,] = then (12, b, cn, N, E) -(jirst(el,, where b = b \n[z I-+ z:cn] P, N(ll, b) = (Z , b ), and ), b , l:cn, N[(z, l:cn) H N(lz, v], E b) = V, U {(12, b)-+ \n(z, l:cn), (l , b )+ (1, b)}) CALL If [Xz.el] c P, then (1, b, t :cn, (l, b)m N, E) (1 , b ) c E, and \nN(l, b) = v, + (1 , b , cn, N[(l , b ) + v], E) RETURN Figure 3: Exact Transition Rules for Functional \nCore 395 let f=~(z)z g=~(hyz) begin (h y) (h z) end in begin (9f12) end (9f34) Figure 4: A higher-order \nprogram. ((~fg.(begin (94f516 27)3 (99 flo 311 412)8 end),), (XT. Z14)13 (Jhyz.(begin (his yI~)17 (h,, \nZz,),o end),, ),, )0 Figure 5: Labeled version of sample program. and by extending the function s environment \nto point to the new node, The remaining rules define how the machine proceeds af\u00adter finding the value \nof an expression. After evaluating a function, the machine uses ARG to start evaluating the argument. \nCALL describes how to proceed after the argument has been evaluated, assuming that the evalua\u00adtion of \nthe function yielded a closure , i.e., the label of a A-expression paired with a binding environment. \nUn\u00adder this rule, control transfers to the body of the function in an extension of the closure s environment. \nAlso, the edge (1 , b ) + (t, b) is added to allow control to return after the call is complete. The \nRETURN rule follows this edge from the body of the function back to the call sit e. 3.3 Example To illustrate \nthe semantics, consider the program shown in Figure 41 . The labeled version of the same program, aft \ner desugaring, is in Figure 5. The exact flow graph for the program is shown in Figure 6. Variable nodes \nare displayed as rectangles; expression nodes are displayed as ovals. The first line of a node contains \nthe node label, the second line contains its value. For the sake of brevity, variable nodes (e.g., fO, \nxl) are not labeled by a Var x Contour pair. Instead, each in\u00adstance of a variable is assigned a disambiguating \ninteger. The one-to-one correspondence between node labels in the graph and node labels in the semantics \nis shown in Figure 7. To simplify the presentation, a binding environment [x, ++ CW] is displayed as \na list of the variable node labels corresponding to each pair (z,, cni). For example, the environment \n[h w (3, O), y ++ (3, O), z I+ (3, o)] is displayed as [hi, yl, z1]. 1We use a trivial extension of the \nlanguage with sequencing and multiple argument functions Graph Semantics fo . (f) (0)) . go (9, (0)) \n ho (h, (8, O)) hl . [:, [:, :;; yo yl . (Y: (3: 0)) . Zo (z, (8, O)) Z1 . (z, (3, o)) . Xo (z, (20, \n8,0)) xl . (z, (17,8,0)) x2 (z, (20, 3, o)) = x3 (%, (17, 3, o)) I Figure 7: Correspondence between \nnode labels For this example, the value stored in a node corresponds to either an integer or a closure. \nFor [kl] c P, we display the value (1, b) as the integer k. We display closures as they are represented \nin the semantics. For example, the value (15, []) displayed in node (e9, [fO,gO]) denotes the closure \nof Myz.begin (lzy) (h z) end in an empty environment. In this program, the outermost application creates \nthe nodes fO and gO, which receive their values from the anonymous procedures at (el 3, []) and (el 5, \nU) respec\u00ad tively. Function g is called twice in the outermost contour; thus, its value flows into (eg, \n[fO,gO]) and (e4, [fO,gO]). Each call to g receives f as its first argu\u00adment. The first call to g creates \nthe flow of (e5, [fO,gO]) into hl. Note that hi s contour is (3, O); the 3 corre\u00adsponds to the label \nof g s call site. The O corresponds to the label of the outermost application. The return value of this \ncall (2) flows from (e16, [hl,yl,zl]) to (e3, [fO,gO]). 4 Abstract Semantics The abstract semantics [5, \n6] for a program P is given by . a set of abstract states State and an abstract transition function ~ \n: S$e + S%e, both specific to P. The definition of S~e appears in Figure 8. The most notable difference \nfrom the exact semantics is that a node stores a set of abstract values, rather than a single value. \nLike the exact semantics, the abstract semantics explic\u00ad itly manipulates a flow graph. Intuitively, \nan abstract flow graph is constructed by (finitely) partitioning the nodes in the exact graph [22]. The \nvalues stored in the nodes of one partition are represented by the set of ab\u00adstract values in the single \nabstract node corresponding to the partition. As in the exact semantics, a directed edge represents the \nflow of values from one node to an\u00adother. In the abstract semantics, an edge can also be interpreted \nas a subset constraint. A particular abstraction is chosen by specifying the fol\u00adlowing: Contour, a finite \nset of abstract contours. Figure 6: Exact flow graph for a simple higher-order program. ? E S%ie = N=es \nx E~es R G N~es = Nod=abel + P( V%e ) ~ E E~es = P(E~e) nl * %2 E Exe = NodeLabel x Nod~abel ~ G Nod~abel \n= (Label x Bin~~gEnv) + ( Var x Co~our) (1,;) G vz~ = Label x BindingEnv ; c BindingEnv = Var * Co~our \nc% E CoZour Figure 8: Abstract States a((l, b, cn, N, E)) = (Q(N), ~(E)) a(N) = ~R{a(N(n)) [ a(n) =;} \ncr(E) = {c2(nl~n2) I nl-+n2 G E}  a(nl+nz) = ala The definition of R is given in Figure 10. The first \na((l, b)) = (~, cw(b)) two cases create abstract values in nodes correspond\u00ada((z, en)) = (z, ~cn(cn)) \ning to expressions that have become reachable. The for\u00admal definition of reachability is given below. \nInformally, FiKure 9: Abstraction Functions an abstract node (1,~) is reachable if the corresponding \nexact state could be of the form (1, b, cn, N, E), where a~(b) = b. If (1,$) is not reachable, it implies \nthat et is crc~, a contour abstraction function, mapping never evaluated in the exact semantics within \nany exact Contour to CoZour. binding environment approximated by ~; reachability is thus an important \noptimization to reduce the amount of T (written in infix), mapping Label x Co~our to flow generated within \nan abstract graph. Co~ow-. It abstracts the exact function 1 : that appends a label onto a contour. \nIt must satisfy The third case in the definition of N propagates values czcn(l:cn) = 17 acn (en). along \nedges in the graph. The set of values in a node ~ is the union of the sets at all of the nodes that flow \ninto e at., a binding environment abstraction function, %. mapping BindingEnv to BindingEnv. It must \nsat-Definition (Reachability) The following rules define isfy c&#38;n (cur(b)) = c~r(ab (b)), where cur \nmaps a binding environment to the contour of its lexically the predicate reach ~ Nod~abel. deepest variable \nand c~r maps an abstract binding 1.reach (first(~), Az. 1) environment to the abstract contour of its \nIexically deepest variable.  2. For all [([el]ll [e2]12)l] ~ P,  extend, an abstract environment extension \nfunc\u00ad (a) If fi(ll,~) # {}, then reach (j&#38;st(e2),;). tion, written ex=nd (S, z, c>). It must satisfy \n (b) If (l ,&#38;) -fi(ll,$), [(kc. o%(b[z H en]) = ez~nd (Q%(b), z, ac~ (en)). e)l,} G P, and fi(lz, \nb) # {}, The precise relationship between exact states and ab\u00adthen reach (first(e), ez~nd (3, z, 17 \ncar($))). stract states is characterized by a collection of abstrac\u00adtion functions (a) which are homomorphic \nextensions of 3. For all ~([el]ll, . . ., [e~]lm)l] ~ P, the given a.n and O!b. See Figure 9 for details. \nif fi(l~,$) # {}, then reach (l,~). 4. For all [c([el]ll, . . ., [e~]l~)l] E P, 4.1 Abstract Transition \nFunction if ~(1~,%) # {}, then reach (1,%). The abstract transition function builds a dataflow graph. \n5. For all ~case([el]l,, c(zl,. . . ,x~) +-, ez, y + es)] c p Self-evaluating expressions (constants, \nlambdas and re\u00adcursive definitions), create nodes with abstract values (a) For [c(e~,..., e~)~, ] c P, \nthat serve as the source of flow. Edges are added to if there exists a ~ such&#38;t (1 ,fl) c fi(ll ,3), \n the graph in order to direct the flow to new nodes. Fi\u00adthen reach (jirst(e~), extend (~, w, c~r(~))). \nnallY, abstract values are propagated across edges, pOS\u00adsibly causing the creation of new sources of \nflow or new (b) For [c (e~,.. .,e~, )1,] ~ P, edges. if c # c or m # ml, and there exists a~ such that \n(1 ,~) c fi(ll,~), Formally, the abstract transition function ~ maps ab\u00adstract graphs to abstract graphs. \nIt is defined by: then reach (first(es), e~~nd (~, y, c~fl;))). {(l,i-)} if; = (1,;) and r-each (1,;) \nN(R) = {(1 ,8)} if; = (1,$), r-each (1,;), and [(r-cc f (kc.e)z, )l] c P { U{fi(fi ) I fi -+; G ~} otherwise \n Figure 10: Definition of N The definition of E for the functional core appears in Fig\u00adure 11. The remaining \ncases are given in Appendix B. The definition is given as a union of sets of edges. Most of the edges \nare directly derived from the exact seman\u00ad tics. For example, edges of the form (z,~(z)) w (1,;) correspond \nto variable lookup. As another example, for expressions of the form [([el]ll [ez]l, )1], the edge (1z,3)+ \n(a, 1T c%i(~)) corresponds to the flow of a value from the argument to the parameter of the function. \nThe only kind of edges which are not directly derived from the exact semantics are of the form (y,~(y))---+ \n(y,~ (y)). As we discuss in Section 7, these edges have the effect of copying bindings from one environment \nto another. 4.2 Correctness We use ~ to denote the i th composition of ~ with itself. We use ~ for the \ni-step exact transition relation and ~ for the reflexive transitive closure of +, The initial abstract \nstate for a program is .Q = (AR{}, {}). Sets of abstract values are naturally ordered by ~. This order \ncan be extended pointwise and componentwise to construct a partial order ~ on State. Lemma 4.1 (Monotonicity) \nIf; ~ ?, then ?(~) ~ 7(? ) If Co~our is finite, then all sets in the definition of S~e are finite. Also, \nall increasing chains in State are finite. As a consequence, the following definition of least fixed \npoint is well-defined. Definition (Least fixed point) l~p (~ ) = ~, such that ~(~) = Sand %.~(a ) = S. \nFinally, we prove a correctness theorem which relates the abstract and exact semantics, The theorem states \nthat the abstract flow graph which is the least fixed point of the abstract transition function conservatively \nestimates all exact flow graphs that can arise as the result of the execution of the program. Theorem \n4.1 (Correctness) For all s such that so = s, a(s) L Zjp(?) Proof Sketch: We show by induction on i \nthat if so &#38; s, = (l, b,cn, N, E) and ~ (~) = ~. = (~, fi), then 1. a(s,) ~Z 2. If there exists \nan e such that 1 = first(e) then reach (1, a(b)). 3. For all (l , b ) such that N(l , b ) #d_, for \nall x c  dO??@), a(N(z, b (z))) G fi(z, a~(b )(x) ). 5 OCFA and Set Based Analysis 5.1 oCFA In this \nsection, we consider the following instantiation of the semantics: Co=our = {O} cl.. (Cn) = o l?c>=o \n@h(b) = kr.O ez=nd ($, z, c>) = ~y. O This version of the semantics is commonly called OCFA [2 1]. With \nthe above definitions, abstract contours and binding environments convey no information and can be removed \nfrom the abstract semantics. Figure 12 . shows the simplified definition of State. Each subexpres\u00ad sion \nand variable of the program corresponds to a single node in the graph. Similarly, each constant, construc\u00adtor, \nprimop, lambda and recursive function expressio~ gives rise to a single abstract value. The definition \nof E in the abstract transition function also becomes greatly reach(l)} r-each(l)} z.e~,t)l,] C P} The \neffect of the abstraction is to establish an edge from a variable node to each expression node where \nthe vari\u00adable is referenced and, for each abstract closure stored in a function node, to establish an \nedge from the argument node to the parameter of the closure and an edge from the body of the lambda to \nthe call site. Figure 13 shows the flow graph for the program given in Figure 4 under the OCFA instantiation. \nBecause this analysis does not rely on binding environments or con\u00adtours to disambiguate abstract values \nyielded by an ex\u00adpression evaluated in multiple contexts, the graph is sim\u00adpler in structure than the \ngraph produced by the exact semantics. As in the exact graph, integer values are dis\u00adplayed directly. \nBecause there are no environments, clo\u00ad sure values appear as the label of the lambda expression (e.g., \n(13) for Az.z). 1,; Each subexpression below induces a set of edges fil$, for each binding environment \n~, (12,;)-+(X,1: cTr(;)), (1 ,8 ) <N(ll,;), [(Ax. eJ,, )l,] C P [([d, [d~,)ll: fit; = (1 ,7 )-\u00ad+(1,;), \n? = extend (% , x, 1: c~(~)), { (y,~(y))--+ (y,l (y)) y ~ dom($ ) } Figure 11: Definition of E for functional \ncore. S%e = N=es x E~es N~es = Nod%abel -i 7 ( V~e ) E~es = Q(E~e ) E~e = Nod~abel x Nod~abel Nod~abel \n= Label -i-Var V%e = Label Figure 12: OCFA Abstract States. The two calls to g merge the values 2 and \n4 into z and the values 1 and 3 into y. The calls to h further merge these values into x, which has the \nvalue {1, 2,3, 4}. While the graph produced by a OCFA-style analysis is thus rela\u00adtively coarse compared \nto the graph generated by the exact semantics, the abstraction is nonetheless useful. Notice that the \ngraph reveals all possible call sites for all functions; for example, it reveals that ~ occurs in a call \nposition at e21 and e18 and that fis not applied at any other call-site. 5.2 Set-Based Analysis Set-based \nanalysis is a program analysis technique that associates a (possibly infinite) set of values with each \nprogram variable. It is based on ignoring inter-variable dependencies. We summarize the relevant technical \nparts of [8] in the remainder of this section. The set-based analysis of a program P is defined via a \njudgement of the form &#38; E e --+ V where &#38; is a set environment and V is a set of constraint values. \nThe definition appears in Figure 142. Note that for a given E and e, there are potentially many V such \nthat &#38; 1-e -=+ v. Definition (Constraint value) A constraint value cv is either a constant, a lambda \nexpression, or a construc\u00ad 2For simplicity, we do not treat primitive operations or recur\u00ad sive definitions. \ntor application of other constraint values. Cv ::= k / kc.e I c(cvl,. ... cv~ Definition (Set Environment) \nA set env.. onment is \\ , a mapping from the variables of P to sets of constraint values. The set-based \noperational semantics is similar to a stan\u00addard operational semantics, except that constraint val\u00adues \n(closures, in particular) omit an environment com\u00adponent. Instead, all environments are collapsed into \nthe single set environment E, which is used for variable lookup. Safety conditions are imposed on set \nenviron\u00adments in order to ensure that they contain the proper variable bindings. Definition (Safety) \nA set environment C is safe with respect to program P if every derivation &#38; E P + V satisfies the \nfollowing three conditions. 1. In every use of S-APP, V2 ~ t(x). 2. In every use of S-MATCH, if C(cvl, \n. . . . cv~ ) 6 VI, then cvi c &#38;(x~) for all i = 1,...,rrz. 3. In every use of S-ELSE, if cv c VI \nand cv # c(cv1,, . . . cv~), then cv 6 t(y).   Set environments can be partially ordered by the point\u00adwise \nextension of the subset ordering on their ranges: S1 ~ &#38;2 if for all z, El(x) ~ 22(x). We can also \ndefine the greatest lower bound of two set environments in the natural way: (S1 fl~z)(x) = S1 (x) nSz(x). \nThe property of safety is preserved under greatest lower bounds: if S1 and &#38;z are safe with respect \nto P, then S1 n EZ is safe with respect to P. Consequently, for every program P, there is a minimal set \nenvironment ~p~in that is safe with respect to P. This environment is the set-based analysis of P. The \nminimal set environment for the example program {3,4:2,1} Figure 13: OCFA abstraction of the exact flow \ngraph shown in Figure 6. S-VAR &#38;l-z-&#38;(z) S-CONST &#38;Ek%+ {k} S-LAMDBA &#38; 1-kr.e -{Az.e} \nS-APP fkei~Vi i=l,..., m S-CONS tt-c(el,. . . ,em)-{c(cvI,..., cvm) / W C K} &#38;Fel~Vl &#38;Fe2-V2 \n S-MATCH E h case(el, c(zl,. . . ,zm)+e2, y+e3)-+V2 3c(cv1  cvn)cw Skel+Vl &#38;l-es~V3 3CV e vls.t. \ncv# C(cvl,. ... Cvm) S-ELSE &#38; t-case(el, c(m,. . . ,~m)+e2, y=e3) *Vi Figure 14: Set-Based Operational \nSemantics in Figure 4 is given by: Hence, sP7ntn (z) = {1,2,3,4} sPmtn(Y) = {1,3} zPmzn(z) {2,4}= tPmtn(f) \n= {Az.z} :Pmtn(h) = {Az.z} SPm,n(g) = {Myz.begin (by) (h z) end}  As another example, consider the program \nP: let f = Az.c(a) in(j (j 1)) The minimal set environment for this program maps z to the infinite set \n{1, c(l), c(c(l)), c(c(c(l))), . .}. 5.3 Relating OCFA to Set-Based Analysis As shown by the above example, \nthe set-based analy\u00adsis of a program can yield an infinite set. However, [8] proves that it is possible \nto use regular tree grammars to represent the sets defined by set-based analysis. In this section, we \nshow that a similar theorem applies to the states computed by the OCFA instantiation of the ab\u00adstract \nsemantics. In particular, we show that an abstract state implicitly contains a regular tree grammar and \nthat this grammar exactly characterizes the set-based analy\u00adsis of a program. We first show how to construct \na regular tree grammar from a collection of abstract nodes N. The nont erminals will be node labels and \nwill derive constraint values. Definition (Grammar) Gr (R) is a grammar with the following components: \nNonterminals = Nod~abel Productions = {~+ ~ I ; G fi(ti)} u{l+kl~klje P} U {1 -+ Jx.e [ [(~z.e)ln E P} \nu {1 + C(lI ,. ..,lm) I I(c([elltl,.., [emlt,,l))ll~ p}  We use the notation ~ ~~ cu to mean that ~ \nderives cv in G. Because variables are nonterminals, a grammar can be used to define a set environment. \nDefinition (Env ) Env (G) is the set environment which maps a variable z to the set { cv I z ~~ CV}. \nFor example, re-consider the program P shown earlier: let f = kz.(c(z[, ))t, in U(f bl)) We have labeled \nseveral relevant subexpressions of the program. Let (R, @ be the least fixed point of the ab\u00adstract transition \nfunction for P. It is easy to show that fi(z) = fi(ls) = {11, 12}. Consequently, the grammar Gr (R) contains \nthe following productions: x-ill 13 + 11 X-+12 13-12 11--+1 12 --+ C(13) Cv} = {1, C(l), c(c(l)), C(c(c(l))), \n. . .}, {c I ~ =%r(q which is exactly &#38;Pmtn(z) From the perspective of set-based analysis, the OCFA \nab\u00adstract semantics cent ains two kinds of edges, The first kind corresponds to safety constraints. For \nexample, the edge 12-z from an argument node to a variable node corresponds to the first safety constraint, \nV2 Q t(z). The second kind of edge corresponds to constraint value sets which are copied from the antecedent \nto the conse\u00adquent in a set-based rule. For example, the edge 1 --+1 from the body of a lambda to the \ncall-site corresponds to the S-APP rule in Figure 14. The following theorem formalizes the correspondence \nbe\u00ad tween OCFA and set-based analysis. Theorem 5.1 (Equivalence) Let a program P be given. Let ? be \nthe abstract tran.mtion function for P. Let Zfp(?) = (fi, @, ~ = Gr(fi) and Ep.ba = En.(G). Then, ~P~;. \n= t?pab~ . Proof Sketch: We establish &#38;P~,m E &#38;P.~~ by show\u00ading that Epabs is safe with respect \nto P. The proof is by contradiction and requires Lemma 5.1. For the other di\u00ad rection, we establish by \ninduction that Env ( G T (fit)) ~ ~P~,~, where ~ (;o) = (f? , R). The result follows be\u00ad cause for some \nindex i, lfp (~ ) = ~ (~o). 6 Implementation and Complexity By defining the abstract semantics in terms \nof flow graphs, we enable direct and efficient implementations. First, because ~ is monotonic, an implementation \ncan represent the abstract state with a single graph, and make destructive updates when necessary. Furthermore, \nthe definition of 1$ (see Figure 10) makes it clear that is advantageous to represent the edges in the \ngraph using adjacency lists. Given this representation, the abstract values at a node n can be immediately \npropagated in n s successors. In our implementation, we maintain a graph in which each node n stores \nthree things: . R[n], the set of abstract values which have reached n and have been propagated to n s \nsuccessors. . P [n], the set of abstract values which have reached n and have not been propagated to \nn s successors. o S[n], a list of the successors of n. 31n order for this theorem to be true, we must \nmake a slight modification to our semantics which restricts the flow of test val\u00adues in case expressions. \nWe also maintain a set of nodes N = {n I P[n] # {}}. The algorithm propagates values across edges until \nthe fixed point is reached. For each node n, R[n] monotoni\u00adcally increases over the execution of the \nalgorithm. while N # {} remove some n from N for each n in S[n] for each v in P[n] if v @! R[n ] and \nv fv}P[n ] then P[n ]i-P[n ] U if P[n ] # {} then N-N U {n } R[n]t R[n] U P[n] P[n] 4--{} The above pseudocode \nomits the details describing the creation of new nodes and the addition of new edges. Both operations \nare performed when a value is added to a set P[n]. The program is preprocessed to extract the neces~ary \ninformation from the definitions of reachability and E. Preprocessing removes much of the interpreta\u00adtion \noverhead of the analysis and makes the inner loop extremely tight. The running time complexity of the \nalgorithm is gov\u00aderned by the inner loop. For all nodes n and abstract values v, v is added to P [n] \nat most once. Consequently, the inner loop can be executed at most once for each edge and abstract value. \nAssuming the code in the inner loop is O(1), the worst-case running time of the algorithm is the product \nof the number of edges and the number of abstract values. The current implementation is approximately \n1500 lines of Scheme code. It is written in Scheme 48 [12], and makes extensive use of the Scheme 48 \nmodule system. The implementation is parameterized in exactly the same way as the abstract semantics. \nTo construct a com\u00adplete abstract interpreter, one must specify an abstrac\u00adtion module which defines \noperations for manipulating abstract contours and abstract binding environments. In order to simplify \nthe construction of abstraction mod\u00adules, we have created a general tool which characterizes a large \nclass of call-string abstractions including all the ones described in this paper. Instantiation In the \nfollowing, let n be the size of the program. We consider three specializations of the framework. The \nfirst is the OCFA analysis given in Section 5. In OCFA, the number of nodes in the graph is O(n); no \ncontour infor\u00admation is used to disambiguate multiple instantiations of a given procedure. Thus, the \nnumber of edges in the graph is O(n2). Since the number of values is O(n), the worst-case time complexity \nis O(n3) [8, 14]. We can construct a more sophisticated analysis with\u00adout sacrificing polynomial-time \ncomplexity by disam\u00adbiguating distinct calls to a function; we do this by pre\u00adserving only the most recent \ncall-site in the function s binding environment. We call this particular analysis polynomial-time lCFA; \nthe specifics appear below: Co~our = Label CYcn ((1,, . . ..lm))=ll Graph fo go ho hl = = Semantics (f, \n(0)) (9, (0)) (h, (8)) [;, [;jj yo yl 20 Z1 Xo xl (Y: (3)) (z, (8)) (.2, (3)) (x, (20)) (x, (17)) Figure \n15: Polynomial-time lCFA node correspon\u00ad 11~1=11 ax) = k.a.. (cur(b)) extend (;, z, 1) = Ay.1 Bind~gEnv \nis restricted to constant functions that map all variables in an abstract closure to a particular caU\u00adsite, \nand hence its size is O(n). Consequently, there are 0(n2) nodes and hence 0(n4) edges. There are 0(n2) \nvalues that can flow along these edges corresponding to the 0(n2 ) abstract closures that can be constructed. \nThe worst-case complexity of this analysis is thus 0(n6). This analysis uses edges of the form (y, fl(y)) \n+ (y,~(y)) (see Figure 11) to copy bindings from a closure s binding environment to the environment in \nwhich the application is evaluated. This is necessary because under this instan\u00adtiation, function application \nrequires all variables in the function s closure to be mapped to the application s call\u00adsite label. In \nother words, for any given application of a function j, every free variable in ~ s closure is mapped \nto the same contour, regardless of the call-site in which the variable was originally bound. The additional \nedges ensure that binding values are properly propagated from the closure to the activation frame associated \nwith the application. The graph produced by this analysis on the example shown in Figure 4 is given in \nFigure 7. This graph results in less merging than the oCFA instantiation because call site information \nis used to disambiguate multiple calls to the same function. For example, variable node ZO contains z \ns binding value in the second call to 9, and Z1 contains z s value in the first call. However, the two \ncalls to h in g merge values passed in the two calls to g. Consequently, the abstract value of this program \nis the set {2,4}. The correspondence between node labels in the graph and in the semantics is given in \nFigure 7. Notice that a slightly more costly abstraction that pre\u00adserves information about a function \ns two most recent call-sites would produce a flow graph with exact informa\u00adtion. Under such an analysis, \nthe graph for our sample program would associate four contours for z correspond\u00ading to all of ~s possible \ncall hk.tories. e13,[] e15,[] {<13,[]>} [<15,[]>)   @w QQ @@&#38;&#38; @&#38; e2,m3,gol {4,2) eO,[] \n[4,2] 2? Figure 16: Polynomial-time lCFA flow graph. By allowing Bin~in~Env to contain non-constant \nfunc\u00adtions, we derive an exponential-time analysis that is re\u00adlated to the lCFA analysis described in \n[21]. Whereas in polynomial-time lCFA all free variables in an abstract closure are mapped to a single \ncall-site, the exponential\u00adtime lCFA relaxes this constraint and associates a vari\u00adable in an abstract \nclosure with the call-site at which it was bound. The only difference between this analysis and polynomial-time \nlCFA is the treatment of binding environments: clb@J =-ha=. (qz)) eztend (b, z, 1) = b[z w 1] Since Bind~gEnv \nnow contains a full function space from variables to abstract cent ours, there can be an exponen\u00adtial \nnumber of closures constructed and an exponential number of expression nodes. 8 An Alternative Contour \nRepresentation We have represented contours in terms of call-strings. While reasonably expressive, this \nparticular representa\u00adtion has some drawbacks. Most notably, call-string infor\u00admation cannot be used \nto disambiguate distinct calls to a function based on the abstract values of the function s arguments. \nIn other words, the accuracy of any inst an\u00adtiation of this framework is closely tied to the length of \nan abstract contour s call-string, not the abstract values generated by the interpretation. Thus, calls \nto a function made from the same call-site may not be disambiguated if the contour s call-string is not \nlong enough, despite the fact that different calls supply different arguments. The framework presented \nhere is not dependent on rep\u00adresenting cent ours as call-strings. It is straightforward to define alternative \nrepresentations. For example, con\u00adsider a modification in which exact contours contain call\u00adstrings augmented \nwith information that records the ar\u00adgument value bound at each call-site. Contour = ( Value x Label)* \n(Vr,l ):((v,l),...) = ((V ,1 ), (V,l),...) We can define a simde abstraction of this rerxesenta\u00adtion \nthat disregards call-strings and preserves informa\u00adtion about closures that are passed as arguments. \nAb\u00adstract binding environments can be treated as in the ex\u00adponential variant of lCFA. CoXour = {kc.e \n[ [Az.e] E P} + {NoN-LAMBDA} if ~(~z.e)tj C P ~cn(((Lb),l ),...) = Z e NON-LAMBDA otherwise { ((1, b), \nt ) ? c% = +O;-LAMBDA ;t~yw:)~ G p { C@ =-wwcn(b(z)) extend (b, a, c%) = ;[x I-+ c>] Under this abstraction, \ntwo calls to a function f which supply closures created from different A-expressions will be associated \nwith different contours, even if those calls occur from the same call site. Distinct calls to ~ that \nsupply non-functional values are merged. For programs that use higher-order procedures, this choice of \nabstract contours can compute more precise control flow information than is possible with call-string \nabstractions. For example, consider a simple higher\u00adorder recursive function such as Scheme s map that \ntakes a function fand a list L and applies fto each element of L. There are two ways in which a call-string \nbased analysis of map will lose control flow information. First, if sev\u00aderal functions are merged together \nbefore being passed as the functional argument to map, then call-strings will not separate the functions \nat the call. Second, even if all calls to map paas a different function at each call\u00adsite, the recursive \ncall to map (or any other local helper function) inside the body of its definition will eventually cause \nthe functional arguments to be merged. The conditions necessary for the abstract semantics to be correct \nunder this representation strategy are easily derived and are similar to those given in Section 4. We \nleave an investigation of the merits of these various rep\u00adresentation choices for future research. 9 \nConclusions and Related Work Parameterized control-flow analysis via flow graphs not only provides an \nintuitive and customizable analysis framework, but also offers the potential of becoming use\u00adfully integrated \nwithin a realistic compiler. Optimiza\u00adtion such as unboxing, function specialization, type re\u00adcovery, \nsafety and liveness analysis, debugging[2], and global register analysis are all important components \nin an optimizing compiler toolbox and programming en\u00advironment. Many of these analyses require efficient, \nsophisticated and tunable inter-procedural control-flow analyses. We believe that the ideas presented \nhere pro\u00advide exactly this capability. There have been a number of previous efforts that rigor\u00adously \naddress the control-flow analysis problem for high\u00adlevel programming languages (e.g., [3, 7, 10, 9, 11]); \nbe\u00adlow, we compare three relevant approaches with the con\u00adtributions presented here. Shivers[20] presents \na general model for control-flow analysis in Scheme via abstract interpretation of a de\u00adnotational semantics. \nThe analysis must first translate source expressions to CPS terms; this translation affects the results \ncomputed by the analysis [16]. Deriving an ef\u00adficient implementation from the semantics is unintuitive \nand requires deviating from the semantic specification (e.g., the time-stamp approximation [21]). The \nchoice of a denotational semantics makes it difficult in general to understand the complexity of implementations \ndirectly derived from the analysis. Finally, improving the ac\u00adcuracy of a oCFA instantiation of the analysis \nwithout introducing exponential complexity is problematic; our framework offers a more general notion \nof abstraction that permits the expression of a hierarchy of polynomial\u00adtime abstractions which reflect \nprogressively improved accuracy. Set-based analysis [8] refers to an operational semantics which ignores \nall inter-variable dependencies that occur in a program. Because the semantics is tightly tied to this \nnotion, it is not clear how to express a more precise analysis within the framework. We have shown that \nthe OCFA instantiation of our semantics is sufficient for com\u00adputing a representation of the sets defined \nby set-based analysis. Set-based analysis has a simple and intuitive characterization; devising equally \nsimply descriptions of other instantiations of our semantics is a topic for future work. In order to \ndevelop a more precise analysis, [8] describes a polyvariant extension of the algorithm for comput\u00ading \nset-based analysis. The extension uses information from a monovariant prepass in order to duplicate cer\u00adtain \nfunctions. The result of the extended algorithm can be interpreted as a monovariant analysis on a new \nprogram which is @equivalent to the original program. Although ~-substitution can be used to capture \nsome aspects of duplication in contour-based analyses, it can not describe certain kinds of merging which \noccur in the abstract semantics. For example, it can not express the polynomial-lCFA analysis (Section \n7) which copies bind\u00adings from one contour to another. Stefanescu and Zhou[22] present an equational \nframe\u00adwork for the control-flow problem. Their equations have a strong correspondence with the subset \nconstraints of [8] and with the edges of our abstract state. In their work, a program in the source language \nis closure converted [l] before being analyzed. In the context of our analy\u00adsis, this transformation \ncorresponds to the restriction of binding environments to constant functions since there are in effect \nno free variables found within a function after closure conversion. A natural attempt to formu\u00adlate a \nlCFA style analysis in their framework gives a polynomial time approximation[23] similar to the one we \ndescribe in Section 7. It appears impossible to express other analyses in their framework, e.g., the \nexponential lCFA analysis and the analysis of Section 8, which is not call string based. References [1]Andrew \nAppel. Compiling with Continuations. Cam\u00adbridge University Press, 1992. [2] Francois Bourdoncle. Abstract \nDebugging of Higher-Order Imperative Languages. In ACM SIGPLAN 93 Conference on Programming Language \nDesign and Im\u00adplementation, pages 46 55, 1993. [3] Craig Chambers and David Ungar. Iterative Type Analysis \nand Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. In ACM SIGPLAN \n90 Conference on Programming Language Design and Implementation, pages 150 164, June 1990.  [4] William \nClinger and Jonathan Rees, editors. Revised4 Report on the Algorithmic Language Scheme. ACM Lisp Pointers, \n4(3), July 1991. [5] Patrick Cousot. Semantic Foundations of Program Anal\u00adysis. In ProgTam Flow Analysis: \nTheory and Foundation, pages 303 342. Prentice-Hall, 1981. [6] Patrick Cousot and Radhia Cousot. Abstract \nInterpreta\u00adtion: a Unified Lattice Model for Static Analysis of Pro\u00adgrams by Construction of Approximation \nof Fixpoints. In ACM 4th Symposium on Principles of Programming Languages, pages 238-252, January 1977. \n[7] Alain Deutsch. On Determining Lifetime and Aliasing of Dynamically Allocated Data in Higher-Order \nFunctional Specifications. In 1 ?h ACM Symposium on Principles of Programming Languages, pages 157 168, \nJanuary 1990. [8] Nevin Heintze. Set-Based Analysis of ML Programs. In Proceedings of the ACM Symposium \non Lisp and Func\u00adtional Programming, pages 306 317, 1994. [9] Paul Hudak and Jonathan Young. A Collecting \nInter\u00adpretation of Expressions. ACM Transactions on Pro\u00adgramming Languages and Systems, pages 269 290, \nApril 1991. [10] WNiams Ludwell Harrison III. The Interprocedural Analysis and Automatic Parallelization \nof Scheme Pro\u00adgrams. Lisp and Symbolic Computation, 2(3/4):179-396, 1989. [11] Neil Jones and Stephen \nMuchnick. Flow Analysis and Optimization of Lisp-like Structures. In 6 h ACM Sym\u00adposium on Principles \nof PTogTamming Languages, pages 244 256, January 1979. [12] Richard Kelsey and Jonathan Rees. Scheme48 \nProgress Report. Lisp and Symbolic Computation, 1994. [13] Robin Milner, Mads Tofte, and Robert Harper. \nThe Def\u00adinition of Standa? d ML. MIT Press, 1990. [14] Jens Palsberg and Michael Schwartzbach. Safety \nAnal\u00adysis versus Type Inference. Information and Computa\u00adtion, to appear. [15] Young Gil Park and Benjamin \nGoldberg. Escape Analy\u00adsis on Lists. In Proceedings of the SIGPLA N 92 Confer\u00adence on Programming Language \nDesign and Implemen\u00adtation, pages 116 127, June 1992. [16] Amr Sabry and Matthias Felleisen. Is Continuation \nPaes\u00ading Useful for Data Flow Analysis. In ACM SIGPLA N 94 Conference on Programming Language Design \nand Implementation, pages 1 12, June 1994. [17] Zhong Shao and Andrew AppeL Space-Efficient Closure Representations. \nIn Proceedings of the ACM Symposium on Lisp and Functional Programming, pages 150 161, 1994. [18] Micha \nSharir and Amir Pneuli. Two Approaches to Interprocedural Dataj70w Analysis, pages 189 235. Prentice-Hall, \n1981. [19] Olin Shivers. Data-flow Analysis and Type Recovery in Scheme. In Topics in Advanced Language \nImplementa\u00adtion. MIT Press, 1990. [20] olin Shivers. Control-Flow Analysis of Higher-@der Languages or \nTaming Lambda. PhD thesis, School of Computer Science, Carnegie-Mellon University, 1991. [21] Olin Shivers. \nThe Semantics of Scheme Control-Flow Analysis. In Proceedings of the ACM SIGPLAN Sympo\u00adsium on PaTtial \nEvaluation and Semantics-Based PTo \u00adg~am Manipulation, pages 190 198, 1991. [22] Dan Stefanescu and Yuli \nZhou. An Equational Frame\u00adwork for the Flow Analysis of Higher-Order Functional Programs. In PToceedinqs \nof the ACM Svmvosium on Lis~ and Functional PTo~Tam ming, pages 3~8~327 1994. [23] Yuli Zhou, June 1994. \nPersonal Communication. 406 407 A Exact Semantics for Language Extensions. If ~([el]ll,. then for 1 s \n. . , [e~l~m)l~ 1 or [C([ellll,..., [emllm)]Ep, i < m, if N(l,, b) = v, then (1,, b, cm, N, E) --+ (jirst([e,+l]lz+l \n), b, cn, N, E) NEXT If [boz([el]ll)l] then (11, b, cn, G P N, E) and ----+ N(ll, b) = U, (1, b, cn, \nN[(l, b) t+ (1, b)], E) BOX If [unboz then (n, ([el]l, b,cn, )1], [box N, E) - (el,)l,] G P and N(~l, \nb) (l, b,cn, N[(l, b) w N(l , = (Z , b ), b )], E U {(1 , b )+ (l, b)}) UNBOX If [set-boz!([el]ll, then \n(12, b, cn, N, [e~]l, )l], [boz(et,l)l, E) ----+ (1, b, cn, N[(l, ] c b) P, ~ N(ll, b) = Unspecified, \n(1 , b ), and (1 , b ) ~ N(lz, v], E b) = U, U {(12, b)+ (1 , b )}) SETBOX If [c(el, . . . , [em],m)] \nthen (1~, b, cn, N, E) c ~ P and N(l~, b) = (1, b, cn, N[(l, b) v, ~ (1, b)], E) CONS If [case([el]ll \n,c(x1,... ,z~) * [ez]l,,y If ~c([e~]~~,... [e~]p,t)t,] c P and (11, b, cn, N, E) + (first([ez]l,), b \n, cn, N[($t, cn) = where b = b[xl, . . . ,x~ ~ cn] a [es]l.)l] ~ P N(ll, b) = (1 , b ), then N(~~, b \n)], E U {(~1, b )\u00ad (~t, cn) I 1< i < m} U {(lz, b )-\u00ad (~,b)}) MATCH If [c (e\\, (l,, b,cn, where b . \n. . ,e~)l, N, E) ~ = b[y H ] G P, N(ll, (first([es]l,), cn] b) = b , (1 , b ), and c # cn, N[(y, cn) \n* c or m (1 , b )], # E m , then U {(1~, b)+ (Y, en), (k,b )~ (1, b)}) ELSE For i then c {2, 3}, (1~,b, \ncn, if N, N(l,, b) E) ---+ = v and (1, b , cn, (1~, b)\u00adN[(l, b ) (1, b ) c * N(L, E, b)], E) CONT B Definition \nof &#38; for Language Extensions.  \n\t\t\t", "proc_id": "199448", "abstract": "<p>We describe a framework for flow analysis in higher-order languages. It is both a synthesis and extension of earlier work in this area, most notably [20, 22]</p><p>The framework makes explicit use of <italic>flow graphs</italic> for modeling control and data flow properties of untyped higher-order programs. The framework is parameterized, and can express a hierarchy of analyses with different cost/accuracy tradeoffs. The framework is also amenable to a direct, efficient implementation.</p><p>We develop several instantiations of the framework, and prove their running-time complexity. In addition, we use the simplest instantiation to demonstrate the equivalence of a 0CFA style analysis and the set-based analysis of [8].</p>", "authors": [{"name": "Suresh Jagannathan", "author_profile_id": "81100208907", "affiliation": "Computer Science Division, NEC Research Institute, Princeton, NJ", "person_id": "PP39032551", "email_address": "", "orcid_id": ""}, {"name": "Stephen Weeks", "author_profile_id": "81100226831", "affiliation": "Dept. of Computer Science, Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP31100132", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199536", "year": "1995", "article_id": "199536", "conference": "POPL", "title": "A unified treatment of flow analysis in higher-order languages", "url": "http://dl.acm.org/citation.cfm?id=199536"}