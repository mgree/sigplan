{"article_publication_date": "01-25-1995", "fulltext": "\n An Extended Form of Must Alias Analysis For Dynamic Allocation Rita Z. Altucher raltucherQscr.siemens \n.com William wlandi~scr. Landi siemens. com Siemens Corporate Research Abstract. This paper presents \nmethods that we have implemented to improve the quality of the clef-uses reported for dynami\u00adcally allocated \nlocations. The methods presented are based on the Ruggieri/Murtagh naming scheme for dynamically created \nlocations. We expand upon this scheme to name dynamically allocated locations for some user written allo\u00adcation \nroutines. Using this expanded naming scheme, we introduce an inexpensive, non-iterative, and localized \ncalcu\u00adlation of extended must alias analysis to handle dynamically allocated locations, and show how \nthis information can be used to improve clef-use information. This is the first at\u00adtempt to specify must \nalias information for names which represent a set of dynamically allocated locations. Empir\u00adical results \nare presented to illustrate the usefulness of our method. We consider this work a step towards developing \npractical re-engineering tools for C. Introduction. A clef-use occurs when a definition (write) of a \nlocation is subsequently used (read). Def-use analysis is widely used in optimizing and parallelizing \ncompilers [ASU86, WO189] and is increasingly used in software engineering tools [OW91]. The precision \nof the clef-use solution can be improved by removing a reaching definition when it is no longer valid \nso that the definition does not erroneously reach any sub\u00adsequent uses. Def-use reporting for dynamically \nallocated memory locations is more complex than that for non-dynam\u00adically allocated locations. Unlike \nstatically allocated loca\u00adtions (i.e., variables), dynamically allocated locations do not correspond \nto a single name in the program. To track the clef-uses of dynamically allocated names, our technique \nrep\u00adresents all the locations that can be produced at an alloca\u00adtion site with a name particular to the \nsite [RM88]. Tangible references to these names can then be made when reporting clef-uses. This paper \ndiscusses the problems in finding the clef-use solution for dynamically allocated locations and presents \nthe methods that we implemented to improve upon the solution. We expand on the technique in [RIv188] \nto efficiently generate Permission to copy wfthout fee all or part of this materfal is granted provided \nthat the copies are not made or distributed for direct commercial advanta e, the ACM copyright notice \nand the Y title of the publication and ts date appear, and notice is given that copyi is by permission \nof the Association of Computing Machinery.?o copy otherwise, or to republish, requires a fee and/or specific \npermission. POPL 951/95 San Francisco CA USA @ 1995 ACM 0-89791-892-1/95/0001....$3.50 names for dynamically \nallocated values returned from user written allocation routines which build their return values from \nembedded calls to system allocation routines. Using this expanded naming technique, we implemented an \ninex\u00adpensive and localized calculation of must alias analysis with extensions to han dIe heap variables, \nand show how this in\u00adformation can be used to detect when a definition for a dy\u00adnamically allocated location \ncan be killed. Our methods are incorporated into the svstem develoDed .. jointly by Siemens and Rutgers. \nThe original system was presented in detail in [LR92, PLR94]. This system contains a safe approximation \nfor interprocedural may alias in the presence of general pointers and call by value parameter passing. \nWe show how our extended must alias technique uses the may alias solution to efficiently perform a Iocal\u00adized, \nnon-iterative must alias analysis. We developed these techniques for the C programming language, and \nalthough our examples are in C, our techniques can be generalized for other languages. Organization. \nThe second section defines terminology. Since the may alias and clef-use algorithms developed in the \n[LR92, PLR94] dataflow system are used in our research, the third section provides an overview of these \nalgorithms. The fourth section discusses identifying dynamically allo\u00adcated memory locations. The fifth \nsection discusses improv\u00ading the clef-use quality and tracking clef-use pairs for dy\u00adnamic memory. The \nsixth section presents empirical data, and the paper ends with related work and conclusions. 2 Terminology. \nIn this paper, unless otherwise noted, information reported in examples at a labeled statement refers \nto the status after execution of the statement. This is referred to as the on\u00adbottom information [Hec77]. \nOn-top information refers to the status before the execution of the statement. Flow Graph Notation. We \nrepresent a program with an Interprocedural Control Flow Graph, ICFG, as used in [LR92, PLR94] which \nis similar to the supergraphs of Myers [Mye81]. There are call and return nodes associated with each \nprocedure invocation and entry and exit nodes associ\u00adated with each procedure. Procedure calls may be \nrecursive. Each edge in the ICFG represents the potential one-step ex\u00adecution flow of control from one \nnode to another. Example contains an ICFG for a sample program, We use the term loop head node for the \nsingle entry point of a reducible loop [ASU86]. An ICFG can contain irreducible loops, but such loops \ndo not have loop head nodes. A loop tail node is a node that can be the last executed in a reducible \nloop before returning to the head node. Names. A heap variable represents the set of mem\u00adory locations \nthat can be returned from a dynamically allo\u00adcating function. Heap variables are discussed in Section \n4. All other variables are non-heap variables including vari\u00adables we use for function return values \nin our implementa\u00adtion; e.g., the variable m y-rnalloco is used for the return value of rny.rnalloc in \nExample 1. In that example, we con\u00adsider m y-malloc () = malloc(sz) to be two writes; a write of m y-maiioc \n() and an implicit write to the location allocated. An object name is a variable, or a variable with \na se\u00adquence of field accesses, pointer dereferences, and array ac\u00adcesses (e.g., p > r and *p). A fixed \nlocation is an object name that does not contain any pointer dereferences. A statically assigned fixed \nlocation, (e.g., a declared variable name), corresponds to a unique memory location. A fixed location \nfor dynamically allocated memory corresponds to a subset of the heap. Object names such as z, s.f, and \nheap variable names are fixed locations. Object names such as *p and p->f are not because determining \nwhat these object names represent requires the runtime value of some loca\u00adtion. An object name Y derives \nobject name X, if X is the result of a (possibly empty) series of dereferences or field accesses to Y \n(e.g., *p derives p >fl. We represent this by the predicate deriues(Y,X). The predicate clerives.pks(Y,X) \nis similar to derives [Y, X) except that it requires at leaat one dereference. Def-use. A definition \npair, <n] .w>~ reaches a pro\u00adgram point w, if there is an executable path through nl on which m writes \nS, and no points between nl and n2 on the executable path also write m. A clef-use for an object name \nx occurs when a definition, < nl :Z>d reaches n2 which has a use of z. A clef-use is represented by a \nreaching definition, use site pair (e.g., [< nl VZ>&#38;n2]&#38;). In this Paper, clef-uses are reported \nexclusively on fixed locations. Reference. A reference site of a fixed location at a pro\u00adgram point n \nis the location where the memory associated with the fixed location is either read or written. References \nmade to individual array elements are considered as refer\u00adences to the entire arrav. Aliases. Two obje~t \nnames, z and g are aliased to one another at a point n if they refer to the same location at n. If this \nis true for at least one execution, x and y are may aliased at n. If it is true for all executions, x \nand y, are must aliased at n. The notation for may and must aliases are the unordered pairs <x, y> and \n<<x, y>> respectively. The definition of must alias is not applicable to heap vari\u00adables since a heap \nvariable may represent multiple locations even at one point in an execution. A possible extension of \nMust Alias is: At a point in a particular execution, we define loc(heap~l) to be the lsst location represented \nby heap~l generated by the execution. For non-heap variables, 1OC(V) is simply v s memory location in \nthe symbol table. Extending this definition of 10C to all objects names, two object names, x and y, are \nextended must aliased at nl, if on aU executions of nl, ioc(x) = lot(y). For example, if *p and heapnl \nare extended must alias at ru, then when nz is executed, p always points to the last location generated \nby rzl. As for must alias, we use the pair <<x,y>> to represent an extended must alias. Extended must \naliases will be used for killing reaching definitions. Safe. A reported may alias, reaching definition \nor def\u00aduse solution is safe, or conservative, if the exact solution is a subset of the reported solution. \nFor a must alias or extended must alias solution, the exact solution is a superset of a safe solution. \nSince a safe solution may not be precise, it may incorporate information from paths in a program that \nmay not be executed [ASU86]. For reaching definitions, maintaining safety can result in the reporting \nof spurious clef-uses. For instance, in our system, assigning to an array element is equivalent to assigning \nto all elements in the array, but does not kill previous definitions of the array. 3 Overviews of May \nAlias and Def-Use Algorithms. In this section, we mesent high level overviews of the al\u00adgorithms for \nfinding-may alia&#38; and clef-uses presented in [LR92] and [PLR94], respectively. These overviews provide \nthe reader with the necessary context, and are not complete explanations of the algorithms. 3.1 May Alias \nAlgorithm. Realizable Interprocedural Paths. Iterative data flow analysis is a fixed point calculation \nfor recursive equations defined on a graph representing a program, that safely ap\u00adproximates the meet \nover ail paths solution [Hec77] for the graph. For ICFGS, not all paths correspond to real program executions. \nA realizable path is a path on which every pro\u00adcedure returns to the call site which invoked it. Paths \nthat do not meet this requirement are unrealizable, and do not correspond to an actual execution. 1 A \nfundamental problem of interprocedural analysis is how to restrict the propagation of data flow information \nto realizable paths. Jones and Muchnick [JM82] give a general approach for handling this problem. They \nassociate each data flow fact with an abstraction of the run-time stack for paths on which the fact exists. \nThis abstraction is associated with data flow facts in the called procedure, and is used at the procedure \ns exit to determine to which call site(s) the data flow infor\u00admation should be propagated. Our conditional \naliasing ap\u00adproach [LR91, LR92] can be seen as an application of this idea. The data flow fact is a may \nalias pair at a program point n. Our encoding of the run-time stack is the set of reaching aliases (RAs) \nthat exists at invocation of the pro\u00adcedure containing n. Reaching aliases were referred to by the term \nassumed aliases in [LR92]. They can be used to determine to which call sites the aliases at the exit \nof a called procedure should be propagated. [LR92] safely restricts the size of the reaching alias sets \nto one. Pointer-Induced Aliasing. Intraprocedurally, aliases induced by a reaching alias at procedure \nentry are associated with that reaching alias. For example: int *g; maino P() int *p; {{ int x; g=&#38;x; \nnlo: p=g; P(); } } the alias <*p,x> at n10 is associated with the reaching alisa <*g,x> because <*p,x> \nis induced by <*g,x> existing at the entry of P. Alisaes created regardless of any reaching 1 We do not \nallow setjmp or Iongjmp in programs analyzed int num-allots; char *mymalloc(sz) int SZ; { num-allots++; \nreturn mallow; } maino { char *p,*q; num-allocs=O; p=mymalloc(l) q=mymalloc(l *p=)5~; *qx~6~; printf( \n%c ,*p) } n80 oy nloo nllo w20 ; ); n]30 ; n140 n150 n160 aliases, are associated with a special reaching \nalias, q5 (ernp\u00adtyset). This association represents that these aliases exist regardless of which call \nsite invoked the containing proce\u00addure. The intraprocedural propagation of aliases through pointer assignment \nstatements is similar to the single level pointer aliasing algorithm in Chapter 10 of [ASU86] with extensions \nto handle multiple level pointers. Interprocedurally, a call to procedure Q (call~) creates reaching \naliases at the entry of Q. We use ReachingAlms (calin.RA\\ todenote the set ofreachin~ aliases inducedbv \nboth~he p~rameter bindings cmdtheali~ses associated wit~ 12Aattheca11. Thespecial reaching ahas~and aH \nreaching aliases created in the called procedure solely by the parame\u00adter bindings are included in the \nset ReachingAlias(cai~Q, ~). At the exit of Q, aliases associated with some reaching alias RA , arepropagated \ntoanycallsitecatiQ that induces RA at the entry of and, thereafter dure. In this examples where  3.2 \nDef-Use Q (i.e., RA E ReachingA~ias(cailQ, RA)), are associated with RA in the calling proce\u00adpaper, reaching \naliases are only discussed in they add context. Algorithm. Our clef-use algorithm isin two phases. In \nthe first phase, we compute for each node, n, Reaching Defs(n). This is the set of all definitions pairs, \n<n~:p>~, that the second phase, weuse the reaching definition determine clef-uses. ReachingDe@ot(n) after \nnode n executes. erates (DefGera) plus ecutes (ReachingDefstOp) n. represents the definitions These \nare the definitions the definitions that exist that are preserved reach n. In solution to that exist \nthat n gen\u00ad before n ex\u00ad(DefPres) by etm%ymalloc 1 c yrnalloc(l :;~sret%ymalloc 1 q.my-nmlloc *p= 5 \nt *q= 6 + printf( %c ,~) 4 exi~ain ) ) Example] n20 munAlOcs++ n30 my-malloco=malloc( sz) n40 exik malloc \n( DefGen(n)UReachingDefsb~t( n)= Defpre.(n, ReachingDefstOp( n)) ) ReachingDefstOp(n) = u ReachingDefsb&#38;red) \nIn computing reaching realizable path problem. reaching definition with When a reaching definition all \npredecessors (pred) of n definitions, we again We address this by either ~, itself, or at n is associated \nwith #, the def\u00ad encounter the associating each a reaching alias. inition can reach n regardless of \nthe conditions under which the procedure (containing n) is called. When a reaching definition at n is \nassociated with itself, the definition can reach n if it exists when the procedure is called. Finally, \na reaching definition at n associated with a reaching alias <x, y> indicates that the definition can \nreach tog when the procedure was called. The details handling the realizable path important to this \npaper. Thus, we present Pres ignoring these details. An assignment with left-hand-side b, generates a \ndefinition n if z is aliased problem are not DefGen and Def\u00adstatement n, at possibly reflexive, fixed \nlocation alias of lhs. The preserved by n are those definitions of locations necessarily redefined by \nn. The equations for Deffh-es are in Figure 1. Finally, the algorithm for computing clef-uses for every \nnode (n) in the control flow graph for every use x in n for each <nd:p>d G Reaching Defs(n) n for each, \ndefinitions that are not Def Gen and is: if fixed location p is may aliased to x at n report [< T?d:p>d, \nn]du as a clef-use {<n:p>d Ijized location p is may aliased to lhs at n } if n is an assignment DejGen(n) \n= ~ other-wise { {<n~:p>~ l<n~:p>d E S and p is not must aliased to lhs at n } if n is an assignment \nDefPres(n,S) = s otherwise { Figure 1: DefGen and DefPres equations Identifying Dynamically Allocated \nObject Names. Each invocation of a dynamically allocating function returns a memory location that is \ntaken from the heap. These lo\u00ad cations do not correspond to any symbol table entry for the program and \nmust be accessed through pointers. Therefore, we need to statically name these heap locations so that \ntheir clef-uses can be reported. Memory can be created by invoking library allocation routines. These \nare direct allocations. However, it can be an advantage to treat a user written routine as an alloca\u00ad \ntion routine if the routine returns a pointer to dynamically allocated memory. These are embedded allocations. \nDirect Allocations. For functions whose purpose is to handle dynamic memory allocation, we apply the \nRuggieri and Murtagh naming technique. This technique generates a heap variable which is specific to \nthe ICFG node associated with the call node of each direct allocation. This method is less approximate \nthan having one heap variable for all allocations. However, it does not work well when there are embedded \nallocations since it can not dis\u00adtinguish between memory allocated from different calls to a routine \nwit h an embedded allocation. Embedded Allocations. For the program in Example 1, the method discussed \nin [PLR94] would report two spuri\u00adous clef-uses: [< nso :heap~30 >d, n150]du and [< %40 :heap~sO >d, \nnlm]~~. The first clef-use [< rno :heap~so >~, fi150]du represents clef-uses for two locations: one location \nwhen my.mailoco is called at n70 and the other when my.malloco is called at nloo. It is an unnecessary \nclef-use, since the definition of < nso :heap~,, >d represents that two locations are written at nso, \nbut one of these locations is overwritten by nlso and the other is overwritten by n140. The other clef-use, \n[< n140: heapn$o >d, n150]&#38;, is spurious since nlAo WriteS a different location than nl~o reads. \nHowever, this clef-use is reported since *q is may aliased to heap~~o at nlw and *p is may aliaaed to \nheapn,o at n150. To eliminate these spurious clef-uses, we expand our nam\u00ading technique to recognize \nuser written allocation routines by examining the may alias solution at the exit node of user written \nfunctions. If a may alias is found between the func\u00adtion s return value and a heap variable, and the \nassociated reaching alias at the exit node is not ~, then a location rep\u00adresented by the heap variable \nwhich causes the alias, may have been created before this function was invoked. This is the case for \nnot.mm in Example 2. At the exit of not-mm, the alias <*not-mm o,heapn,O > is associated with reaching \nalias <*g, heapnl 0> and we do not want to consider this func\u00adticm an embedded allocation routine. On \nthe other hand, if the special reaching alias, ~, is associated with an alias be\u00adtween a function s return \nvalue and a heap variable, then all locations which cause the alias and are represented by the heap variable, \ndid not exist when the function was in\u00adExample 2 char *g,*p; char *mmo ; char *notmuno; maino { { { nlo: \nreturn malloc(l); return g; g=mmo; } } p=notmmno; } voked, and were created after the function was invoked.2 \nIn Example 2, <*mm O1heapn10 > is associated with $ and so is <*my-malloco, heapn30 > in Example 1. To \ndifferenti\u00adate the locations of heap variables returned from functions which generate them, a new heap \nvariable name is gener\u00adated whose name is derived from the ICFG number of the return node of each call \nsite. Thus, the set of heap variable names ret urned to each calling site remains disjoint. Ex\u00adample \n3 contains the may alias solution for the program in Example 1. All aliases in the example are associated \nwith the reaching alias ~. To maintain safety when reporting clef-uses for heap vari\u00adable names created \nat the return node of a call site, a reach\u00ading definition is created for each renamed heap variable at \nthe direct call site in the called function, If extended must alias information is available for all \nfunctions called by func\u00adtion f, then these extended must aliases can be incorporated into f s extended \nmust alias solution and used to possibly kill reaching definitions within f. Our current implementa\u00adtion \ndoes not do this. To maintain an efficient implementation, we decided to keep the number of heap variable \nnames that are generated linear in the size of the program. Therefore, our solution selects only one \nheap variable per function to be renamed as it is propagated to a return node from a my-malioco exit. \nIf more than one heap variable name is created within a function and returned to its callers, only the \nfirst one de\u00adtected is given a new name at the return node. Definitions for the additional heap variables \nrely on the heap variable name assigned at the direct allocation site. Functions that point global variables \nto dynamically allocated memory but do not pass these locations as return values will not have any heap \nvariables renamed. In this situation, all clef-uses for each heap variable created in the function are \nbased on the name generated at its direct allocation site even if the function is invoked from different \nlocations. Our renaming approach differs from that taken by [CBC93, MLR+ 93]. In their approach, a new \nheap variable name is created for all heap variables that can reach any return node. While their 2 ~hile \nthe ~XPanded ~~~ing technique 1s applicable tO recursive procedures, it is not always as effective as \nfor non-recursive proce\u00addures. However, this loss of precision is rectifiable. ICFG Nodes May Aliases \nDefinitions of Heap Variables I nlo: nz~: n30: entry mv~auoc numallocs++ my-malloco =malloc(sz) Creates: \n<*my\u00ad ma110co,heap~30 > n40: =ikvadtoc Propagates: <*my_ malloco,heap~30 > nso: entryma!n nGO: nUm~Oc.S=O \nn70: callmv-al~oc~l) n80: ret~mv~auoc(l~ ngo: p=mymalloc(l) woo: I=Lvmdbc(l) 11110:ret~mv.mauoc-l) nlzo: \nq=my-rnalloc(l) n130: *p= 5 Transforms: Kills: Creates: Propagates: Transforms: Propagates: Kills: Creates: \nPropagates: Propagates: a <*my. ma110co,heapn80 > <+my-malloco,he apn80 > <* P,heapn,O > <*p, heap~80 \n> <*m Y-malloco,heapn l10 > <*P, heapn,o > <*my. malloco, heap~l10 > <*q, heapnllO> <* P,heapnRn > <*g, \nheapnllO> <*p, heapn80 > m Same as n. Transfo~; Creates: Propagates: <nso :heap~llo >d <n~30 :heap~80 \n>d <n30 :heap~80 >d I 1 n140: *q= 6 Same as n130 <Wo :heap~.so >d I nlso: printf 9=~oc , *p Same as \n72130 Same as n130 < *my-malloco,h eap~30 > at n40 is transformed intO <*my-m ai10co,heap~80 > at n80. \nExample 3 approach is more precise, it is worst case exponential, as they can have one heap variable \nfor every acyclic calling sequence for a procedure with an allocation. Example 3 illustrates our embedded \nnaming technique on the program in Example 1. The variables, h eap~~O and heap~l,O are generated because \nof calls to rny_rnalloco. Be\u00adcause *g at rq40 is never aliased to the same heap variable as *P is at \nn150, no clef-use between these statements is re\u00ad ported. The clef-uses reported involving heap variable \nnames are [< n30 :heap~80 >d, rmo]dti and [<7Z130 .ka~n80 >d, ?M50]dti. The former is spurious. 5 Improving \nDef-Use Quality. Our current goal is to arrive at more precise alias and clef-use solutions for heap \nvariables without introducing significant overhead into our analysis. Before we discuss our techniques \nto improve the aliasing and clef-use solutions for heap vari\u00adables in Section 5.2, we first examine the \ntechnique presented in [CWZ90, PLR94] that improves the clef-use solution for non-heap variables. 5.1 \nMust Alias Calculation for Non-Heap Variables (Strong Update Method). [CWZ90, PLR94] both noted that \nif the target of an assign\u00adment, lhs, is may aliased to only one fixed location, FL, then that alias \ncan be considered a must alias, and any definition of FL that reaches the assignment can be killed (called \nstrong updates in [C WZ90] ). W bile lhs and FL need not necessarily be must aliased, this information \ncan be used to kill reach\u00ad ing definitions because lhs is FL, null, or undefined. In the latter two cases, \nthe program abnormally terminates at the assignment. In the first case, FL s value is overwritten. This \nmethod works interprocedurally.  5.2 Extended Must Alias Calculation for Heap Variables. The limitation \nof the strong update technique is that it can only be applied to names which represent one location on \nany execution. A heap variable created and defined inside a loop cannot be safely killed outside the \nloop at an assign\u00adment because the assignment only writes one location each time it is executed, but \ndefinitions of several allocation in\u00adst antes may reach it. This is not an issue for non-heap variables \nwhich represent a single location. For them, tradi\u00adtional must alias and killing is sufficient. The definitions \nof must alias and extended must fllas are equivalent for non\u00adheap variables. Therefore, extended must \naliases can also be used for non-heap variables. However, killing reaching definitions for heap variables \nrequires some investigation. A reaching definition, <m .%eap~~ >cI, can be ldlled at an assignment nz, \nif and only if for all executions of nz on which rq is the last to write some location represented by \nheap~~, nl was last to write only one location represented by heap~d and nz over-writes that same location. \nWe informally justify this assertion by trying to weaken it. One execution of an assignment can only \nwrite one memory location. Thus, if on some program execution to nQ, more Program Definitions of heapn20 \nthan one location represented by heapna waa last written by i=l; nl, it is not possible for the immediately \nfollowing execution do { of nz to overwrite all those locations. Thus, < nl :heap~~ >d can not be killed \nby n2. Also, if on some execution, the one location represented by heapn, last written by nl was not \nwritten by nz, then there also can be no kill. However, if on all executions, either there are no locations \nrepresented by heapn~ last written by nl, or there is only one location rep\u00ad resented by heapn~ last \nwritten at nl and this is overwritten by n2, then < nl :heap~~ >d can be killed at nz. The preceding \ndefinition is not directly useful for com\u00ad puting kill, but it can be approximated. If all paths through \nnd (the malloc site) from n] to itself overwrite the location written by the first nl, then (A) two distinct \nlocations rep\u00adresented by heapn~ are never both last written by nl on an execution. If the left hand \nside of nl (Uw~l ) is extended must aliased to heapn~ at nl and Jhs~2 is extended must aliased to heapn~ \nat nz, then (B) both nodes write the last location generated by nd. Now assume (C) there is no path from \nn] to n2 through nd on which nl and n2 only appear as the first and last nodes. (B) &#38; (C) imply that \n(D) when nQ executes it writes the same location that n] last wrote or nl never executed, (A) &#38; (D) \nimply the conditions needed to kill < nl :heapna >d. A reaching definition, < nl :heap~~ >cJ, can be \nkdled at a point n2, if 1. lhsnl extended must aliases heap~~ at nl and 2. lhsn2 extended must aliases \nheap~~ at n2 and  3, a!! paths through nd from n] to itself overwrite the location written by the jirst \nnl and 4. there is no path from rq to n2 through nd on which nl and n2 only ~ppear as the jirst aid last \nnodes. Safely approximating (3) is easy. Simply check if < nl: heapn~ >d reaches the top of nl. (4) \ncan be checked in time linear in the size of the program, by removing n2 from the program and determining \nif nd is reachable from nl and (after replacing nz) removing nl and seeing if nz is reach\u00adable from n&#38; \n(4) is true if either of these checks are false. However, we show later how our particular approximation \nof extended must alias allows us to replace both (3) and (4) with a simple post dominator check which \nis usually more efficient. In Example 4, heapn20 represents two locations allocated as a result of calls \nto maiioco in the loop. Since at n30, *s always refers to the last location generated by n20, our definition \nof extended must alias (Section 2) is satisfied for <<*s, heap~20> at 72s0. Thus, the reaching definition \n< n20: heap~,o >d can be killed at n~o because conditions (3) and (4) are obviously satisfied. However, \nit is unsafe to kill < nso .-heap~,o >d outside the loop at nG(J, since the path n30 n~o nlo nzo nso \ndoes not over\u00adwrite the location written at the first n30, which violates condition (3). In our example, \neven though the definition associated with the second memory location is overwritten, the definition \nassociated with the first memory location is not. Since both locations of heap~20 are represented by \none reaching definition (< n30 :heap~20 >d), thedefinitions cannot be killed at nGO because this would \nrepresent overwriting 3Remember, w is considered two writes, A write of s and an imphcit write of heap,. \nd, Both s and heap.d are considered left hand sides of n~. Thus, in our example, condition (1) is also \nmet. nlo: p=s ; propagates: <nso :heapn20 >d n20: s=(int*)malloc(l); Creates: <nzo :heapn20 >d propagates: \n<nso :heapn20 >d n30: *s=i . Kills: <nzo :heapn,. >d nlo: i++; 1 J nso: while (i<=2) ; n~o: *s=i ; propagates: \n<?tao :heapn=o >d n70: printf ( *p= %d\\n , *p) ; Propagates: <neo :heapn20 >d <nso :heapn,. >d Example \n4 both locations. Note that in Example 4, if n20 is replaced by s = tcX, for some variable X, it becomes \nsafe to kill the reaching defini\u00adtion < n o :X>d at nfjo outside the loop. This is because the reaching \ndefinition represents the definition of one location. In this instance, the aliaa between *s and X at \nnGO is both an extended must alias and a must alias. For efficiency, our implementation of extended must \naliae is non-iterative. This decision is based on our intuition that the number of extended must aliases \nfound in most programs is small compared with the number of may aliases and that therefore, an iterative \napproach on the program graph would not yield a significant improvement so as to be cost effective. Further, \nsince extended must alias is not necessary for safety, we decided to impose stringent time/space cost \nrequirements on its implementation. In the future, we would like to study the mecisionlresource tradeoffs. \n~ince we are non-iterative and since we use extended must aliases to determine kill information, kill \ninformation is lost when entering loops because the extended must aliaa information is not propagated \nacross the head node of the loop. While, the concept of extended must aliases works for irreducible graphs, \nrelying on loop head nodes is not possible for irreducible procedures. Since irreducibility y cannot \noccur intraprocedurally in well structured programs, we simplified our implementation by making worst \ncase assumptions for procedures containing irreducible loops. Also for efficiency, we kill extended must \naliases at tail nodes of loops that have two successors. This allows conditions (3) and (4) to be replaced \nwith a post dominator condition. Resetting the extended must alias solution at head and tail nodes implies \nthat if both lhs~l and lhs~2 are extended must aliased to heap~~ at nl and nQ respectively, the innermost \nloops con\u00adtaining each must be the same since all simple paths between nl and n2 do not pass through \na head or tail node. Given this, the condition that n2 post dominates nl, ensures that conditions (3) \nand (4) are met because if heap~~ has an ex\u00adtended must alias at node n, nd must dominate n and both \nnodes have the same innermost containing loop. Local Partition Method. A partition is the largest segment \nof code that is consistent with an intraprocedural and non-iterative extended must alias analysis. Since \nour analysis is intraprocedural, a new partition is crested at an entry node to a procedure and at a \nreturn node of a call site. During analysis, the solution at the entry node is set to 4 because the worst \ncase assumption is that there are no extended must aliases; however, any safe assumption could 3. *rhsn \nto be extended must aliased to *Y if lhsn was extended must aliased to Y before the assignment. Program \nMay Aliases nlo: if (cond~ nzo: u=&#38;w ; Creates: <*U, W>  ====--l <** U,*W> nto: w=&#38;x; PrOpaKates: \n<*ujw> <- IL, *W> <<**U,*W> Creates: <**7L, Z> Creates: <*vJ,z> <*W, Z> Kills: <** U,*W>n40: *u=&#38;Y; \n <**ujz> Propagates: <*u, w> <*W, Z> Creates: <**U, Y> <* W,?J> Example 5 also be used. Also, all extended \nmust aliases that exist at a call node are killed by the call. Further, since our analysis is non-iterative, \nthe solution at the head node of a loop is also ~. Finally, as already discussed, the extended must alias \nsolution at the tail node of a loop is also ~. Loop head and tail nodes start partitions. Equations. \nEach node n in a partition is visited in topo\u00adlogical order. If n does not start a new partition, the \non-top extended must alias solution of n (rnusttop (n)) is the inter\u00adsection of all extended must aliases \nthat reach the bottom of n s predecessors. If n begins a new partition, then its on-top solution is ~. \nMltop (n) consists of the extended must aliases that are not propagated to the top of n. kill op(n) is \nnot computed but is used to clarify our examples. For a non-assignment node n, mUstb@ (n) = mustt p (n). \nWe now consider mu$tbot (n) for an assignment ( tk% = rkk). The set of extended must aliases to be killed \nby an assign\u00adment depends on which locations may be written. This is determined by examining the may \nalias solution4. For each may alias, <lhsm, x>, extended must aliases containing an object that can be \nderived with at least one dereference from z are deleted. Example 5 illustrates the killing of extended \nmust aliases given that: <A, dc> E mustt p(n) and kiiibot (n) = <A, dc> deriues.plu.s(xlA) is true for \nsome x E may.lhs(n) { } where may.lhs(n) = {x ] < lhs~, x> in ma yt p(n)} In Example 5, <*u, w> and \n<**u, *w> are killed during the propagation step to nso and are in kil~ p(nso). The ex\u00adtended must alias \nsolution at the bottom of r140 consists of only <<**u, y>>. <<* Wjx>> is in kitkot (?s10). The motivation \nbehind killing <<*w,z> at n4i3 is that *U is may aliased to w at n.10 which implies that the assignment \nto *u could poten\u00adtially be assigning to w as well as to *u. Therefore, extended must aliases of *w are \nkilled. Next we consider the extended must aliases created by an assignment. In general, lhs~ = rhsn \ncauses: 1. *lhsm and *rhsn to refer to the same location after the assignment. 2. *lhsn to be extended \nmust aliased to X if *rhsn was extended must aliased to X before the assignment.  4We have chosen to \ngather may ahas reformation m a separate phase before extended must alias analys]s, as it simplifies \nalgor]thm design. 4. X to be extended must aliased *Y if, before the assign\u00adment, lhsn was extended must \naliased to Y and * rhsn was extended must aliased to X. However, the above is not necessarily true. \nWe justify this for the first case and the other cases can be justified similarly. The problem arises \nbecause * rhs~ and/or lhs~ may not refer to the same location before the assignment as they do after \nit. For example, the assignment p = p > n does not create an alias between *p and *p > n (assuming p \ninitially points to an acyclic list). To insure that a name, x, refers to the same location before and \nafter an assignment, we verify there is no y may aliased to lhsn that can derive x with at least one \ndereference (i. e., derives_plus( y, z)). Notice, that cases 1-3 above are instantiation of case 4 with \nthe reflexive aliases <<lhsn, lhsn>> and <<* rhsn ,*rhsn>>. This allows us to use the following definition: \n( (must p(n) kiilbo,(rs)) mushj.t (YS) = (lhs-alias(n) x rhs.alias(n ] Y) {1 <lhsn,X> in must p (n) \nwhere ihs-alias(n) = *X and no x in rnayJhs(n) derives-.plus(x,X) J <Y,*rhs~> in mustt p(n) rhs-a[ias(n) \n= Y and no x in may-~hs(n) derwes-p!us(x, Y) {1 J Example 6 illustrates how extended must alias analysis \nin the presence of heap variables can be applied to improve the quality of the clef-use solution. The \nprogram in this ex\u00adample consists of one extended must alias partition, and the local partition method \nreports three fewer clef-uses. <*cI, heapn,o> at nlo and <*c2,heap~,0> at nao are identified during extended \nmust alias analysis and both are true at mo. Since heapn,o is considered a lhs of nlo and * c1 is aliaeed \nto heap~,o at nso and n30 post-dominates nlo, clef-use analysis can conclude that < nlo :heap~10 >d can \nbe killed at nso. A similar argument holds for the killing of < nzo :heap~20 >d at nso. New definitions, \n< nto . heap~,, >d and < nm :heap~,. % are created. The extended must alias <<* cl ,heap~lo>> at the \nassignment n40, assists in determining that < nso .-heap~10 >d can be killed at n40. Thus, < n40 :heap~10 \n>d is the only reach\u00ading definition with a use at nso and < nqo :heap~=o >d is the only reaching definition \nwith a use at neo. Expanded Part ition Method. The expanded parti\u00adtion algorithm improves the extended \nmust alias solution by preserving some aliases across calls. A full interprocedural analysis is not done. \nThe extended must aliases that are preserved consist of object names that cannot be affected by the procedure \ncall. Except at call sites, the algorithm presented for the local partition method is the same. The algorithm \nfor preserving extended must aliases ac\u00ad ross procedure calls relies on the may alias solution that \nexists at a procedure call. If the called function can as\u00adsign to an object name before returning, then \nmust aliases involving that name can not be preserved across the call. Thus, when determining if an extended \nmust alias can be preserved across a call, we do not differentiate between a use of an object name or \na definition of an object name, but only that it is referenced. This is because l=g; *1 = . . . as\u00adsigns \nto *g even though *g is never on the left hand side of an Program Extended Must Aliases Definitions of \nHeap Variables maino I I {I char *CI; char *c2; I nlo : c1 = malloc(l) ; Creates: <*cl, heapn,o> Creates \n: <nlo:heapnlQ>d n20: c2 = malloc(l) ; Creates: <*c2, heap~20 > Creates: < qo :heap~20 >&#38; Propagates: \n<<*cl, heapn, n >> propagates: < n~o :heapnlo >d n30: scanf ( XcXc ,*cl ,*c2) ; propagates: K*cl, heap~,o \n> Kills: <nlo:heapnlo>d <*@he ap.,o> < n2ci :heap~20 >&#38; Creates: <n30 :heap~,. >&#38; I *C I = >a>; \nsame as n30 IK1lls : n40: < n30 :heapnlo >&#38; Creates: <n40 :heap~,. >&#38; I Propagates: <nso :heapn~~ \n>&#38; nso : printf ( xc ,*c I) ; Same as n~o Propagates: <nso :heap~20 >&#38; <%0 :heap~,o >&#38; n60: \nprintf ( %c ,*c2) ; Same as n30 Same as n~o 1I Def-Uses For Heap Variables No Must Alias Local Partition \nMethod <n40:heapn10 >&#38; ,nso &#38; [<n40 :heapnlo >d, n50]dti .<n30 :heapn20 >d, n60 du [<n30 :heapn20 \n>d , n60]du ,<nlo:heapn, o >d, nso. du .< n20 :heapn20 >d, n60. du <n30 :heapnlo >d, nso dti Example \n6 assignment. This eliminates having to detect indirect uses and assignments for objects assigned to \nother objects. We also do not consider the number of times an object name may have been dereferenced. \nTo consider these problems would require a more costly analysis. We have developed two conditions for \nnot propagating an extended must alias across a call. If neither of these conditions is met, the extended \nmust alias is propagated across the procedure call. for each extended must a!ias that reaches the call: \nIf a may alias, <*global, de>, exists at the call node where the variable in global is a global that \ncan be ref\u00aderenced (syntactically appears) in the called procedure or any procedure that can be invoked \nbefore the called procedure returns, extended must aliases containing object names derived from dc and \n*global are not prop\u00adagated to the return node. The motivation behind this is that an assignment to global, \nmay kill extended must aliases cent aining *global. Also, since any assignment to *global is an assignment \nto dc, aliases containing an object name derived from dc must also killed. for each formal (form)/actual \n(act) pair of the call: If a may alias <*act, dc> for an actual parameter ex\u00adists at the call node, extended \nmust aliases containing object names derived from **act and *dc are not prop\u00adagated. In this case, referencing \n*forma/in the called procedure is analogous to referencing *global in the last case. Example 7 presents \nthe extended must aliases using the expanded partition method. Without extended must alias analysis, \nall definitions of heapn20 reach all subsequent uses. If the local partition method is applied, clef-use \nanalysis is able to detect that the definition of heap~zo at nso is killed at n30. This results in the \nkilling of three spurious clef-uses for heap~,o. If the expanded partition method is applied, the call \nto foo at n50 preserves <<*p, heap~20 >> created at ruo since there is no way that p can be assigned \nin foo. Since this extended must alias reaches nTO where heap~20 is redefined, def-use analysis can conclude \nthat the definition of heapn,o at nso can be killed at n70 resulting in one less clef-use to report for \nheapn,o. Note that since our method is not fully int erprocedural, the reaching definition < nlo :heap~20 \n>d is not killed at nTO and the reaching definition < nso .-heap~20 >d is not killed at nlo. This results \nin the reporting of two spu\u00adrious clef-uses, [< nlo :heap~20 >&#38;, nSO]du and [< rzao.%eap~20 >&#38;, \nn60]dti, even when the expanded partition method is applied. 6 Empirical Results. In this section, we \npresent preliminary empirical results for fourteen programs to demonstrate the effectiveness of our re\u00adsearch. \nTo gather statistics, we applied four different meth\u00adods to each each program: Method 1: No must alias \ninformation. c Method 2: Strong update method for non-heap vari\u00adables as discussed in Section 5.1, Method \n3: Extended must alias for heap variables us\u00ading expanded partition method as discussed in Section 5.2. \nMethod 4: Methods 2 and 3 simultaneously.  Table 1 contains some interesting statistics about the programs \nstudied. It lists the number of lines of code (LO(7), Program Extended Must Aliases Definitions of heapn,o \nvoid foo(i) char *i ;  { Propagates: < n30 :heapn,o >d *i, = >5); nlo: Propagates: <w :heapn,O >d Creates: \n<nlo:heap~zn >d } Propagates: <nso :heapn20 >d < mO :heapn,o >d maino { char *p; nzo: p = mal10c(4) \n; Creates: K* P,heap~20B Creates: <n20 :heapn20 >d \u00adn30: Propagates: <*p, heapn20> Kills: <n20 :heapn20 \n>d *P = 2 ; Creates : < n30 :heapnzo >d n40: printf( xc ,*p) ; Same as n30 Propagates: <n30:heap~20 >d \nn50: foo(p) ; Call Bode: Same as n30 Same as n40 Return Mode: Same as n30 Propagates: < n30 :heap~,. \n>d <nlo:heap~~~ >d n60z printf ( Xc ,*P) ; Same as n30 Same as Return Node nso n70: *P = 3 ; Same as \nn30 Kills: < nm :heapnzo >d Creates: < n70 :heapn20 >d Propagates: <nlo:heap~20 >d n.so: printf ( xc \n,*p) ; Same as n30 Propagates : < ni o :heap~=o >d < nlo :heapn20 >d Same as n30 SeMe aS nso } Def-Uses \nFor h eapn No Must Alias Local Partition Method Expanded Partition Method .<nlo :heapn20 >d ,n60 du \n.<nlo:heapn20 >d ,n60. du .<nlo:heapn2 >d, n60. du .< n30 :heapn20 >d, ?uo du .<n30 :heap~20 >d ,nho \n&#38; ,<nso :heapn20 >d, n40. d. <n30 :heapn20 >d, %60 du .<n30 :heapn20 >d, n60 du .< n30 :heapnzo >d, \nn60 du ,<nTo :heap~20 >d ,nao du .<n70 :heapn20 >d, ?W da <n70 :heapn20 >d, n80 d. .<nlo :heapn20 >d, \nn80. d~ .<nlo :heapn20 >d , n80 du <nlo:heapn,o >d, n80 du .<n30 :heapn20 >d, n80 da .<7230 :heap~2. \n>d , n80 du .<n20 :heap~20 >d, n40 du .<n20 :heapnz~ >d ,n60. du < n20 :heapn20 >d, n80 dti Example \n7 Size Heap Vars ICFG nodes (Nodes), and functions (Funcs). The Heap Var-s Name LOC Nodes f?Uncs Dn-hmb \nII column lists information about the number of heap variable II en I 0?.0 I 0119 I . strings L(3 a \nnames used by dataflow. There are separate columns for allroots 2;; 411 ; 1 : heap variables created \nas a result of direct calls (Dir) and for dim 268 635 13 110 heap variables created as a result of embedded \ncalls (Ernb). fixoutput 401 621 5 3 0 Table 2 contains statistics about the Must Alias Prepa-lex315 719 \n1306 16 3 0 ration Time and Def-Use Time for each program analyzed calls 759 1289 17 4 6 on a Sun SPARC1O. \nThe Total Def-Use Time ie in seconds. pokerd 964 1886 29 4 2 This is the time taken to run each program \nwhen Method Clust 1039 1282 41 9 6 1 is applied. The % Changed (i-or -) us (1) Def-Use Time loader 1220 \n1567 29 7 0 is the percent difference in analysis time for the programs compress 1486 1917 16 1 0 cliff \n1694 3950 48 10 16 aPPIJ ing Methods 2-4 versus Method 1. A + indicates tbl 2487 6060 83 2 6 that the \nmethod ran slower than Method 1; a - indicates assembler 2693 3629 51 16 0 it ran faster. This table \nalso lists information about Def-Use simulator 3720 5578 105 4 0 Numbers when the four methods are applied. \nThe first three columns list the clef-uses numbers for all variables, heap vari- Table 1: Characteristics \nof Heap Vars ables and non-heap variables when applying Method 1. The remaining three columns list the \npercent reduction when ap\u00adplying Methods 2-4. When Method 2 is applied, the percent reduction ie for \nall variables. All tests were run using our reduction refers only to the improvement obtained when this \nembedded allocation technique for naming heap variables. method is applied for non-heap variables. When \nMethod Examining Table 2, we observe that: 3 is applied, the percent reduction refers only to the im\u00ade \nIn twelve of the fourteen programs, the preparation provement obtained when this method is applied for \nheap time for Method 3 is greater than for Method 2. How\u00ad variables. When Method 4 is applied the clef-use \npercent ever, both times are negligible compared to the Def\u00ad Use Time. Six programs have a more precise \nclef-use solution when applying Method 2 versus Method 1. Five of these six also produce a more precise \nsolution applying Method 3. Ten of the fourteen programs have a more precise so\u00adlution when applying \nMethod 3 versus Method 1. Of the remaining four, three do not show any improve\u00adment with any method. \nWith the exception of clust, the clef-use cost of Meth\u00ad ods 2-4 is less than 8y0 (14Y0 for c?ust) or \nfavorable (negative). Closer examination of the source of clust reveals an interesting situation. If \nx is a structure with fields ~1, iz, and ~3 then we use < mo :x>d to represent that all fields of z are \nwritten by a structure assignment at n10. Now if ra20 assigns to z.$1, then rZIO was still last to assign \nz.~2 and x.j~ and the reaching defini\u00adtions are < n20 :x. fl >d, < mo :x. f2 >d, and < mo :X.f3 >d. If \nwe did not treat nzo as a kill of the definition z.fl there would only be two reaching definitions: < \nnzo: x,fl >~ and < mO TX>d. In ciust, there are structure as\u00adsignments and the extended must alias calculation \nis validly causing single fields of the structure to be killed. This causes more reaching definitions \nto be created and the def-use calculation is slightly more expensive. If this problem is significant \nin practice, it can be rec\u00adtified by a better implementation. In tbl, the clef-use time is 21% faster \nwhen apply\u00ading Method 2 than when applying Method 1. Since so many reaching definitions and clef-uses \nare eliminated using Met hod 2, our implementation has fewer inter\u00adnzd data structures to maintain. Simulator \nis interesting because it demonstrates a worst case time scenario for applying must alias anal\u00adyses to \na larger program with little improvement in the clef-use solution. However, the time overhead is slightly \nnegative. Since both forms of must alias analysis incur little over\u00adhead and since eleven of the fourteen \nprograms respond either to Method 2 or Method 3, it is probably worth\u00adwhile to use Method 4 to obtain \nthe benefit of any possible improvement. Related Work. One area of related work is schemes for naming \ndynami\u00adcally allocated memory. Our naming scheme is an extension of the Ruggieri and Murtagh technique \n[RM88] (see Sec\u00adtion 4). Choi, Burke, and Carini [CBC93, MLR+ 93] also extend the RM technique (again, \nsee Section 4). Several other techniques use graphs to capture may alias informa\u00adtion. Nodes in the graphs \nrepresent locations, and directed edges represent a points-to relationship. In this case, un\u00adnamed nodes \nrepresent dynamically allocated memory loca\u00adtions [CWZ90, HPR89, JM82]. There are also several tech\u00adniques \nthat do not explicitly name or represent dynamic locations [Deu92, HN90, LH88, LR92]. The main focus \nof this paper is must alias analysis. Landi and Ryder [LR9 I] developed an algorithm for finding must \naliases for single level pointers. In Section 5, we discussed the strong update technique [CWZ90, PLR94] \nin depth. More recently, Emami, Ghiya, and Hendren [EGH94] de\u00adscribed how to maintain must alias information \nwhile com\u00adputing may aliases. Unlike our techniques, all these methods are not applicable to variables \nthat represent more than one location, 8 Conclusions. We have made a first attempt at a localized must \nalias analy\u00adsis and extended the definition of mus t alias to accommodate heap variables. We have shown \ninexpensive methods that improve upon the quality of the clef-use solution in the pres\u00adence of dynamically \nallocating functions. We have shown how a localized calculation of extended must alias analysis for heap \nvariables can be safely implemented. Two local\u00adized methods of our extended must alias analysis were \npre\u00adsented: a local partition method and an expanded partition method. We have given preliminary empirical \nevidence that these methods are cheap and can improve the quality of the clef-use solution. Acknowledgments, \nWe thank Stephen Masticola for his discussion while we were formulating the ideas in this paper. We also \nthank him and Jean Hartmann for their feedback on earlier versions of the paper. References. [ASU86] \nA. V. Aho, R. Sethi, and J. D. Unman. Compd\u00ader-s: Principles, Techniques, and Tools. Addison-Wesley, \n1986. [CBC93] Jong-Deok Choi, Michael Burke, and Paul Ca\u00adrini. Efficient flow-sensitive interprocedural \ncom\u00adputation of pointer-induced aliases and side ef\u00adfects. In Conference Record of the Twentieth An\u00adnual \nACM Symposium on Principles of Program\u00adming Languages, pages 232 245, January 1993. [CWZ90] D. R. Chase, \nM. Wegman, and F. K. Zadeck. Analysis of pointers and structures. In Pro\u00adceedings of the SIGPLA N 90 \nConference on Programming Language Design and Implemen\u00adtation, pages 296-310, June 1990. SIGPLAN Notices, \nVol 25, No 6. [Deu92] A. Deutsch. A storeless model of aliasing and its abstractions using finite representations \nof right\u00adregular equivalence relations. In Proceedings of the IEEE 199.2 Conference on Computer Lan\u00adguages, \npages 2-13, April 1992. [EGH94] M. Emami, R. Ghiya, and L. Hendren. Context\u00adsensitive interprocedural \npoints-to analysis in the presence of function pointers. In Proceed\u00adings of the SIGPLA N 94 Conference \non Pro\u00adgramming Language Design and Implementa\u00adtion, pages 242 257, June 1994. SIGPLAN NO-TICES, Vol. \n29, No. 6. [Hec77] M. S. Hecht. Flow Analysis of Computer Pro\u00adgrams. Elsevier North-Holland, 1977. [HN90] \nL. Hendren and A. Nicolau. Parallelizing pro\u00adgrams with recursive data structures. IEEE Transaction on \nParallel and Distributed Sys\u00adtems, 1990. Must Alias Def-Use Time Def-Use Number Preparation Time Total \nYo Changed (+ or -) vs (1) Total Heap Non-Heap 70 Reduced vs Program (2) (3) (4) (1) (2) (3) (4) (1) \n(1) (1) (2) (3) (4) strings .01 .04 .05 .34 8.82% 14.71% 11.7W0 194 38 156 .Oc% 55.2W0 10.8W0 allroots \n.01 .03 .04 .7 7 + 7.35% 4.41% + .00% 429 120 309 .00% 32.5W0 9.96% dim .01 .06 .07 2.31 6.49% .4~o \n-1.2W0 794 330 464 .Ocr% .Owo .00% fixoutput .01 .06 .07 2.54 + 3.15% + 3.94% + .Oo% 2967 40 2927 .Oo% \n.OIY% .Owo lex31.5 .01 .07 .08 6.17 + 2.76% .65% + 1.7~o 2432 324 2108 .00% .Oo% .Owo calls .18 .36 \n.54 28.17 3.37% + 1.77% + 2.5W0 16838 13038 3800 9.o~o .02% 2.03% pokerd .03 .13 .16 11.89 2.52% + \n7.82% + 4.8W0 2776 307 2469 .Oc% 8.79% .97% Chlst .08 .16 .24 27.98 .75% +10.61% +13.94% 28064 27016 \n1048 5.9~o .07% ,29% loader .03 .19 .22 12.56 9.2W0 8.91% 10.11% 2398 399 1999 9.5C% 11.7~o 9.86% compress \n.02 .11 .13 8.67 + .58% + .4&#38;o .81% 2007 99 1908 1.21% 20.20% 2.14% cliff .08 .38 .46 52.31 + 1.66% \n .21% + .66% 7476 852 6624 .00% 5.05% .57% tbl .77 .63 1.40 137.65 20.98% + .6W0 20.41% 52714 13209 39505 \n80.47% .0(% 60.3W0 assembler .11 .47 .58 65.82 7.6W0 2.lWO lo.3~o 13274 660 12614 13.25% 12.73% 11.75% \nsimulator .24 .07 .31 104.73 -1.OWO -1.75% 3.36% 36501 1237 35264 .Owo 1.2W0 .04% (1) No must alias \ninfo (3) Extended must alias with expanded partitions (2) Strong update method for non-heap variables \n(4) 2 and 3 simultaneously  Table 2: Must Alias Performance [HPR89] S. Horwitz, P. Pfeiffer, and T. \nReps. Depen-[OW91] T. J. Ostrand and E. Weyuker. Data flow dence analysis for pointer variables. In Proceed-based \ntest adequacy analysis for languages with ings of the ACM SIGPLAN Symposium on Com-pointers. In Proceedings \nof the 1991 Symposaum piler Construction, pages 28 40, June 1989. on Software Testing, Analysis and Verification \n(TAV4), October 1991. Victoria, B. C., Canada. [JM82] N. D. Jones and S. S. Muchnick. A flexible ap\u00adproach \nto interprocedural data flow analysis and [PLR94] H. D. Pande, W. Landi, and B. G. Ryder. In\u00adprograms \nwith recursive data structures. In Con-terprocedural clef-use associations for c systems ference Record \nof the Ninth Annual ACM Sympo-with single level pointers. IEEE Transactions on sium on Principles of \nProgramming Languages, Software Engineering, 20(5):385 403, May 1994. pages 66-74, January 1982. [RM88] \nC. Ruggieri and T. Murtagh. Lifetime analysis [LH88] J. R. Larus and P. N. Hilfinger. Detecting of dynamically \nallocated objects. In Conference conflicts between structure accesses. In Pro-Record of the Fifteenth \nAnnual A CM Symposium ceedings of the SIGPLA N 88 Conference on on Principles of Programming Languages, \npages Programming Language Design and Implemen-285-293, January 1988. tation, pages 21-34, July 1988. \nSIGPLAN NO\u00ad [W0189] Michael Wolfe. Optimizing Supercompilers forTICES, Vol. 23, No. 7. Supercomputers. \nThe MIT Press, Cambridge, [LR91] W. Landi and B. G. Ryder. Pointer-induced MA, 1989. aliasing: A problem \nclassification. In Conference Record of the Eighteenth Annual ACM Sympo\u00adsium on Principles of Programming \nLanguages, pages 93 103, January 1991. [LR92] W. Landi and B. G. Ryder. A safe approximation ahzorithm \nfor interrmocedural Dointer aliasimz. In . Proceedings of the SIGPLA N 92 Conferenc~ on Programming Language \nDesign and Implemen\u00adtation, pages 235-248, June 1992.  [MLR+93] T. J. Marlowe, W. A. Landi, B. G. Ryder, \nJ. Choi, M. Burke, and P. Carini. Pointer-induce aliasing: A clarification. ACM SIGPLAN No\u00adtices, 28(9):67-70, \nSeptember 1993.  [Mye81] E. M. Myers. A precise interprocedural data flow algorithm. In Conference Record \nof the Etghth Annual ACM Symposium on Principles of Pro\u00adgramming Languages, pages 219 230, January 1981. \n\t\t\t", "proc_id": "199448", "abstract": "<p>The paper presents methods that we have implemented to improve the quality of the def-uses reported for dynamically allocated locations. The methods presented are based on the Ruggieri/Murtagh naming scheme for dynamically created locations. We expand upon this scheme to name dynamically allocated locations for some user written allocation routines. Using this expanded naming scheme, we introduce an inexpensive, non-iterative, and localized calculation of <italic>extended must alias</italic> analysis to handle dynamically allocated locations, and show how this information can be used to improve def-use information. This is the first attempt to specify must alias information for names which represent a set of dynamically allocated locations. Empirical results are presented to illustrate the usefulness of our method. We consider this work a step towards developing practical re-engineering tools for C.</p>", "authors": [{"name": "Rita Z. Altucher", "author_profile_id": "81100062615", "affiliation": "Siemens Corporate Research", "person_id": "P243695", "email_address": "", "orcid_id": ""}, {"name": "William Landi", "author_profile_id": "81452618010", "affiliation": "Siemens Corporate Research", "person_id": "PP31030929", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199466", "year": "1995", "article_id": "199466", "conference": "POPL", "title": "An extended form of must alias analysis for dynamic allocation", "url": "http://dl.acm.org/citation.cfm?id=199466"}