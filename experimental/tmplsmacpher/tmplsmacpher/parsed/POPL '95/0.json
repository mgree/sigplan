{"article_publication_date": "01-25-1995", "fulltext": "\n Isolating Side Effects h Sequential Languages Jon G. Rlecke R,amesh Viswanathan* AT@T Bell Laboratories \nStanford University 600 Mountain Avenue Department of Computer Science Murray Hill, NJ 07974, USA Stanford, \nCA 94305, USA Email: riecke@research. att. com Email: vramesh@theory. stanford. edu Abstract It is well \nknown that adding side effects to functional lan\u00adguages changes the operational equivalences of the language. \nWe develop a new language construct, encap, that forces imperative pieces of code to behave purely functionally, \ni.e., wit bout any visible side effects. The coercion operator enca p provides a means of extending the \nsimple reasoning prin\u00adciples for equivalences of code in a functional language to a language with side \neffects. In earlier work [36], similar coercion operators were developed, but their correctness re\u00adquired \nthe underlying functional language to include parallel operations. The coercion operators developed here \nare sim\u00adpler and are proven correct for pureiy sequential languages. The sequential setting requires \nthe construction of fully ab\u00adstract models for sequential call-by-value languages and the formulation \nof a weak form of (monad suitable for express\u00ading the semantics of call-by-value languages with side \nef\u00adfects. 1 Introduction Two pieces of code are operationally equivalent if in any program, one can be \nreplaced by the other without affect\u00ading the observable outcome of the program. A good under\u00adstanding \nof operational equivalence can facilitate modular development of programs and make it possible to prove \nthe soundness of various optimiz ations. It is therefore an advan\u00adtage of a pur-eiy functional language, \nsuch as Haskell [13], that it supports some well-understood principles for reason\u00ading about operational \nequivalence. Purely functional lan\u00adguages, however, lack features that make it possible to write more \nefficient programs. For this reason, many functional languages, e.g., Standard ML [22] and Scheme [5], \ninclude control operations and ways of manipulating memory. Such side-effecting feat ures do not come \nwithout cost: simple rea\u00adsoning principles may fail to be sound, as two purely func\u00adtional pieces of \ncode may be equivalent in purely functional cent exts but not in cent exts wit h side effects. * Supported \nin part by NSF Grant CCR-9303099 and the Powell Foundation. Thm work was begun while visiting AT&#38;T \nBell Labora\u00adtories during the summer of 1993. Permission to copy without fee all or part of this material \nis granted provided that the copies are not made or distributed for direct commercial advanta~e, the \nACM copyright notice and the title of the publication and Its date appear, and notice is given that copyin \nis by permission of the Association of Computing Machinery. ? o copy otherwise, or to republish, requires \na fee and/or specific permission. POPL 951/95 San Francisco CA USA 63 1995 ACM 0-89791 -892-1195/0001 \n....$3.50 To illustrate the problem, consider a call-by-value ver\u00adsion of PCF here called VPCF (c~, [9, \n36, 38]) which is formally defined in Section 3.1. VF CF is a purely functional language, but we can \nadd operations ref, !, := for manipulat\u00ading the state to obtain another language called VPCF+S. Briefly, \nret z allocates a new cell initialized to z, (r := z) updates the contents of the cell T to x, and !T \nreturns the current contents of the cell T. (The typing rules and formal operational semantics for VPCF+S \nappear in Section 3.3.) Two terms may be operationally equivalent in VPCF but not in the extended language. \nFor example, consider the expressions Ml = kn m . Afn m+n Jm. Agn n +n m . (f z); (g z) M2 = Ax m. Af-n \nm-n m. Agnun --n m. (f z); (f z); (g z) where ; is the usual sequencing operator (definable by the equation \n(M; N) = ((M. N) &#38;f) fcm d @ FV(ll) in VPCF). JUl and IMz are operationally indistinguishable in \nVPCF. However, in VPCF+S, they can be distinguished by the con\u00adtext C[.] =: (/lr. [.] O (Jd. T := succ \n(! T)) (h!. !r-)) (ref O). CIJfl] returns 1 whereas C[kfz] returns 2. This example, which shows how adding \nassignments fun\u00addament ally changes the character of VPCF, runs counter tc a vague intuition that the \nVPCF is somehow embedded in VP CF+S, and that reasoning principles on the purely functional core extend \neasily to the language with state. In this paper we show how to recover that intuition. More precisely, \nwe show that VPCF is embedded in an extension with side effects, but mediated by the application of an \naddi\u00adtional opemtion encap. The encap operation encapsulates side effects: the application of enca p \nto some part of a pro\u00adgram prevents its side effects from being visible to the rest of the program, and \nconversely, encap prevents any poten\u00adtial side effects of the surrounding program from affecting the \nbehaviour of the code under encap. However, it does not change the functional behaviour of a term; formally, \nif M is a purely functional piece of code, then for any purely functional context C[.], the programs \nC[Af] and C[encap M] yield the same observable behaviour. As a consequence, the encap operation restores \nold operational equivalences, i.e., two terms A4 and N are operationally equivalent in VPCF iff (encap \nM) and (encap N) are operationally equivalent in VPCF+S+encap. Finally, the operation encap forces non\u00adfunctional \ncode to behave purely functionally; we give a the\u00adorem illustrating this in Section 5. We can now give \nsome intuition for the behaviour of encap when applied to a term A4 of VPCF+S+encap. In executing (en \ncap M), the current state of the memory is saved, say on disk, and M is executed with the contents of \nall memory locations flushed. If A4 is of base type, any resulting value is returned. If J4 is of function \ntype, the resulting closure is returned, with its argument and body coerced by enca p. In either case, \nmemory is then restored to the saved state. Thus the execution of (enca p III) does not change the state \nof memory and its result does not depend on the state in which it is executed. The uses of enca p are \ntwofold. First, one may use en cap to enforce certain portions of code to be oblivious to side effects \ncaused by other modules; this would allow a pro\u00ad grammer to aggressively optimize the code under a enca \np later since functional reasoning principles remain valid for purely functional code under an enca p. \nSecond, one may use encap to establish facts about code. If one proves that adding encap to a subterm \nIkf does not change the meaning of the whole term, then any side effects of M are purely lo\u00ad cal and \nso the proof of correctness of the whole term can be carried out using functional reasoning principles. \nSection 6 below outlines an example of proving program correctness usirw encat). ~he id~a of using coercion \noperations to encapsulate side effects is not new; in [36], Riecke adds a similar operation for functional \nlanguages extended by imperative features. In broad outline, the design and proof of correctness of encap \nin [36] relies on a connection between a model of the under\u00adlying functional language and a model of \nits extension with a side-effecting operation. This connection between the two models is easiest to establish \nin a general semantic frame\u00adwork of strict monads over a category, which are monads with additional structure \n(see [23, 43] for a discussion of monads). The proofs in [36] then require that the model of the extension \nmust be definable from a strict monad. More\u00adover, the proofs rely cruciaily on two properties: the model \nof the functional language must be fully abstract, Z.e., op\u00aderational equivalence must match denotational \nequivalence, and the model of the extension must be adequate (cf. [9]). In order to use the most natural \nsemantic models, the full abstraction requirement forces the languages to include a parallel if (cj. \n[9, 31]). This operation, found in no practi\u00adcal programming language, is the main obstacle to applying \nthe results. The main contribution of this paper is the design and proof of correctness of encap for \npurely sequential program\u00adming languages. Our operational semantics for enca p is also simpler than that \nof [36], making reasoning with encap and implementing it much easier. As applications, we describe the \noperational rules for enca p when added to a language with state and to one with continuations. The operational \nrules for isolating other side effects, such as exceptions and non-determinism, can also be immediately \nobtained from our general framework. Adapting the proofs of [36] for the sequential setting is not straightforward. \nThere are three key insights. First, since generaI categories for sequential languages are not well understood, \nit is essential to work over a call-by-vatue model instead of a category. Section 2 develops an appropriate \ndefinition of a call-by-value language and call-by-value model . Second, the naive extension of strict \nmonads to a call-by-value model does not work because a call-by-value model itself arises from a lifting \nmonad over a category C, and the natural monads for side effects defined over C fail to be monads when \nextended to the lifted category. We de\u00ad velop the definition of a call-by-value monad in Section 4; these \ncall-by-value monads are weak enough to express all the side effects of interest; yet, has enough structure \nto entail the desired semantic connections. Third, a close examina\u00ad tion of the proofs in [36] reveals \nthat the fully abstract model for the base language VPCF need only be constructed out of continuous, \nextensional functions; other mathematically attractive properties of the model are simply not needed. \nIn a companion paper [38], we show how to construct using techniques of Milner [2 I] fully abstract models \nof VPCF and FPC (a sequential language with recursive types [9], in which the semantics of VPCF+S can \nbe encoded), called V and S. While our proofs only require the model V to be fully abstract, the intimate \nconnection between V and .S requires that the model S also not contain parallel functions which are missing \nfrom the fully abstract model V (cf. [31]). The existence of continuous, extensional, fully abstract \nmodels of VPCF and FPC is thus crucial. However, because our framework is applicable to any call-by-value \nmodel, the de\u00ad tails of the construction in [38] play no role in the proofs.  2 Call-by-value Languages \n2.1 Syntax and Operational Semantics The type signature of a general functioned language is a set Z that \nis closed under ~, viz., if a, r-G Z, then (a -+ r) E X. A set of typing rules for functional languages \nappears in Table 1; all variables come tagged with types. The typing rules are parameterized by a set \nC of term constructors, which are tuples of the form (~; al, . . . . an a U) where n > Oandul, ..., an, \n~ E ~. We chose term constructors, as opposed to term constants, to allow the possibility of non\u00ad strict \noperators in the cal-by-value language. We use a parameterized rewriting semantics, with two basic relations, \nto specify operational behaviour. The first relation, +, reduces redexes with J4 + M indicating that \nM is a redex reducing directly to Jf . The second relation, -, is the basic one-step evaluation relation \nfor the particular language, which is defined using the notion of an evaluation context to impose an \norder on the evaluation of subexpres\u00adsions [7]. Table 1 specifies a general rewriting framework for call-by-value \nlanguages. The only redex rule common to all call-by-value languages is the ~-reduction rule; here, V \nranges over a set of values expressions that cannot be fur\u00adther evaluated which varies among languages \nbut always includes Xabstractions. The evaluation contexts specify the next redex using a left-to-right \norder of evaluation for ap\u00adplications. To give the semantics of a particular language, one must add rules \nfor w to specify the behaviour of term constructors, and add new productions to the grammar of evaluation \ncent exts to reflect the order of evaluation.  2.2 Call-by-value Models A denotational model for a call-by-value \nlanguage is based on a collection of sets, indexed by type, suitable for giving meaning to terms. The \nfollowing definition is taken from [35] and resembles definitions from [1, 28]. Definition 1 A call-by-value \ntype frame over a type signature Z is a tuple D= ({D I ac~},{la I aG,X}, {App ] r,vc Z}) 2 Table 1: \nTyping and Evaluation Rules for Call-by-Value Functional Languages. ~, (var) x .(7 (conSt) ~a   -77a=%&#38; \nTerms M:r (abs) (app) (Ax . M) :(a+r) ~\u00ad (k. Evaluation E ::= where each D is a poset, 1 G D , and \nAPPT9V : D - x D + D such that l. Foralld ED , .L <d. 2. If either d = J_r+v or e = J_r, then App7)V(d, \ne) = L . 3. ~ <~~+~ g iff (~ # 17- implies g # J-r- ) and for d d <D. e, ApprI (f, d) <D. App U(g, e). \n  We use X(D) to denote the type signature over which the type frame D is defined. As notational conventions, \nwe omit the type superscripts on J-and App when obvious from the context, and writ e (.f z) for App( \nf, x) when clear . Also, we write d T whenever d = L and d j. whenever d # 1. E The type frame D is flat \nat type a c X(D) if for any d,e E D , dJ and d < e implies d=e. E The type frame D is continuous if each \nDo is a CPO, and for any f E D -V and directed set S ~ D , App(f, US) = U{ App(f, e) [ e G S}. The element \n1 is the semantic representation of a divergent computation. The conditions on a call-by-value frame \ncap\u00adture the call-by-value parameter passing mechanism and the fact that non-divergent elements of a \nfunction type behave monotonically and extensionally. Let D be a type frame over X. A D-environment is \na type-respecting map from variables to elements of D, i.e., p(z- ) c D . A call-by-value model for a \nlanguage with types Z and term constructors C is then a type frame V together with functions D[f] : D \n x . . . x Do + D for each (~; al,. ... u~ + a) E C, with enough elements to in\u00adterpret every term of \nthe language, i.e., there is a meaning function D[.] satisfying D[z ]p = ,O(ZU) D[fil fl . . . Mk]p = \n~[f](~[~l]~, . . . . D[M~]p) P[M IV]P = @p(~[M]P, D[JV]P) D[k . M]P = g, where g j and for any d J, App(g, \nd) = D~M]p[z w d] and such that D[M]p c D for any term M of type u and any D-environment p. 3 VPCF \nand its Extensions In this section, we define our basic functional language, VPGF, and two extensions. \nThe operational semantics of each language specifies an interpreter function Eua/L which M) V -+ [V/z]M \n [ ] I(EM) I(VE)I . . . is a partial function from programs, i.e., closed terms of base type n u m to \nnumerals. The evaluation function determines the operational equivalence relation of the language. Definition \nz Two terms M and N in L are operationally equivalent, written M =L N, if in any context c[.] such that \nC[M] and C [N] are programs, EvuIL(CIM]) = n iff Eval~(CIN]) = n. 3.1 VI?CF VPCF is a purely functional \nlanguage with basic arithmetic and a mechanism for recursive function definitions. Its types are given \nby the grammar u ::= num I (c7 +-d) and the term constructors are (n; num) for alln~O (SUCC; num +-num) \n(pred; num + num) (ifOU; num, CT,a *U) {Y.; (u ~ a) ~ u) where a# num. The syntax of VPCF is now completely \ndefined by Table 1. In addition to the redex rule in Table 1, VPCF has the redexes given in Table 2 which \nreflect the behaviour of its term constructors. The additional productions for evalua\u00adtion contexts (beyond \nthose of Table 1) are also given in Table 2, where a value V is a numeral n, a ~-abstraction, or Yo. \nOne can verify that every closed non-value can be written uniquely as E[R] with R a redex. The basic \none-step evaluation relation ~a for closed VPCF terms is defined by E[M] +0 E[M ], if AI -M . Define \nEvalo (M) = n iff M +. n, where -o is the reflexive, transitive closure of ~v. 3.2 VPCF+K Control operations \ncan be added to VPCF by adding the term constructors (abort; n urn + o) for terminating com\u00adputations \nand (callcc; ((a + num) + m) + a) for capturing continuations. The resulting language is called VPCF+K \n(for control ). Table 2 specifies the one-step evaluation relation ~c ancl set of evaluation contexts \nfor VP CF+K. The last two rules for ~c give the formal semantics of the new operations: ca IIcc captures \nthe current evaluation context, makes it into 3 Table 2: Operational Semantics of VPCF, VPCF+K, and VPCF+S \nsucc(n) -\u00ad n + 1 ifO(O, M, N) - M pred(0) - 0 ifO(n + l, M,N) - N VPCF pred(n + 1) - n (Y v) - (v (AZ. \nY v z)) E ::= ] SUCC(E) I pred(E) I ifO(E, M, N) I (YE) / . . . E[M] +. E[M ] if M-M E[callcc(M)] -+C \nE[M (Az. abort(E[z]))] VPCF+K E[abort(n)] ~c n E ::= . . . I abort(E) (E[A4], s) +. (E[w], s) if M--i \nM (E[ref V], s) +, (E[l], s[l + V]) if/@ dom(s) VPCF+S (E[l (E[!l], S) := v], s) +. +, (E[s(l)], S) (Jqv],S[l \nk v]) E ::= . [ref(E)l!(E)l(E := M) /(V := E) a J-abstraction, and passes it to the argument of callcc; \nabort discards the evaluation context. The interpreter function Eva/k is defined as for VPCF.  3.3 VPCF+S \nOne may add Standard ML-style references and assignments to VPCF ( cj [22]). The enhanced language, called \nVPCF+S (for state ), has types generated by the grammar where (ref m) is the type of locations holding \nvalues of type cr. In addition to the VPCF term constructors, VPCF+S has term constructors (/U; (ref \n~)), where 1 is drawn from an infinite set of location constants; (ref ; a ~ (ref m)) for creating references; \n(!; (ref m) +-a) for dereferencing; and (:=; (ref a), a * a) for assignment, written in infix notation. \nThe location constants 1 do not appear in user programs (this would be tantamount to allowing the user \nto pick ad\u00addresses), but help in defining the operational semantics. The evaluation relation -s and the \nadditional evaluation contexts of VPCF+S appear in Table 2. Values in VPCF+S include locations 1 in addition \nto the values of VPCF. The operational rules manipulate a state s in addition to terms; a state is simply \na finite map from a set of locations to values. The operational rules for the assignments and dereferencing \nare standard (cf. [9]), and the evaluation function EvalS is defined as Ewd,(M) = n iff (M, 0) +. (n, \ns ) for some state s , where 0 is the empty map denoting the initial store.  4 Call-by-value Monads \nand Coercions We design and prove the correctness of a coercion operator for an extension of VPCF in \ntwo steps. First, we show that a continuous model D for VPCF can be regarded as a retract of a model \nT for an extension of VPCF. The retractions act as semantic coercion operators, viz., they coerce any \nelement of T into one with the same functional behaviour but which has no side effects. Second, we use \nthe semantic coercions to design the operational rules for the coercion operators encap. The operational \nfacts are proven through model-theoretic facts: if the model D is fully abstract for VPCF, and the model \nT is adequate for the extension of VPCF together with the encap operator, theu the properties of the \nretractions imply the desired operational correctness properties of encap. In this section we define \na general framework in which the semantics of extensions of VPCF can be described using a call-by-value \nmonad and the model that it defines, and prove that any call-by-value model D of VPCF is a retrac\u00adtion \nof the model determined by a call-by-value monad. We defer the application of the results to Section \n5. 4.1 Call-by-value Monads Ideally, monads are built over categories with some abstract structure, \ne,g., the notion of a strict monad over DCPO defined in [36]. Call-by-value monads are, however, defined \nover call-by-value models, not over categories. There is a good reason for this: constructing categories \nsuitable for se\u00ad quential languages like VPCF (see, e.g., [3, 4, 6]) has been open for many years (although \nrecent announcements [2, 15, 26] suggest that a categorical framework can be con\u00adstructed). Moreover, \nby defining call-by-value monads over models, we can state and prove our results independent of the details \nof the construction of any particular model. Our definition of a call-by-value monad is inspired by the \nnotion of a strict monad defined in [36] ( strict monads are monads [23] with some additional structure). \nDefinition 3 Let D be a least fixpoint model, i.e., a continuous call-by-value model with D~a] = U. F;, \nwhere and where D is flat at a type num G Z(D). A call-by-value monad over D is a tuple (T, V, p, ,/3) \nwith T : Z(D) + Z(D) ~ ~H~wY4, ~. :and a family of functions T~,~ : Dr- Da -~~(a) , and pg : DT(T(UJJ \n+ DT~o) for each type u, r, v c Z(D) satisfying the following properties: 4 1 The functions T,,v,qm,Ka \nare interpretable in D. That is, when the meaning function of D is extended to interpret new constructors \n(T.,.; (r+ 2/) * (T(r)+ T(v))), (q.; a * T(a)), and (Pa;~(~(u)) +-~(u)) using the functions, the meaning \nof any term over the new constructors still exists in the model. 2. For any zED and ~6D + , if~J, then \nq,(j z)= ~a,T(.f) (W *). 3. For any x c D~t J,  E If zJ, then ,uo(q~(a) z) = z. E If z~, then ~o(q~(o) \nz) = qa(lu). 4. For any x,y c D , if q~(z) < qo(g), then x < Y. 5. For any x c Dn m, /3(~nu~(x)) = z. \n  If one takes the elements of a call-by-value model as defining the morphisms of a category, then a \ncall-by-value monad differs from a monad over this category in two re\u00adspects. Firstly, we do not require \nthe maps qo and pm to be elements of the model. In particular, they do not have to be strict functions. \nSecondly, the equations that they need to satisfy are weaker forms of the naturality and unit laws of \na monad. Indeed, all the side effects of interest would fail to satisfy the stronger monad laws over \na call-by-value model. For example, in the monads given in Section 5, q is not strict and they only satisfy \nthe modified monad laws expressed in this definition. The weaker properties of call\u00adby-value monads will, \nhowever, be strong enough to prove the semantic connections established in Section 4.3. Monads capture \nthe notion of computations that con\u00adsist of results and side effects [23]. However, unlike cat egor\u00adical \nmonads, the notion of divergence is already represented in results; this is the reason for the departure \nfrom the def\u00adinition of a categorical monad. Thus computations only incorporate the possibility of side \neffects. A call-by-value monad provides basic operations for manipulating compu\u00adtations: the type T(a) \nrepresents the set of computations whose results are of type a; the function Tr,v (j) transforms the \nresult of a comput ation by ~ wit bout changing its side ef\u00adfect ; q maps a result d to a comput ation \nwith no side effect; u composes two computations to give the cumulative com\u00adputation; and ~ extracts \nthe result from a computation of type n u m. The conditions in the definition of a call-by-value monad \nsimply express some natural and general properties of side effects. 4.2 Monadic Semantics A call-by-value \nmonad over a model of VPCF generates a new interpretation of application and the VPCF constructs one \nwhich passes along side effects. The meaning of a VPCF term thus never generates any side effects itself. \nThe type constructor T of the call-by-value monad is used to pro\u00admote the types. More precisely, for \nany VPCF type a, let a , a ~ X(D) be defined by induction on the structure of u as follows. num = num \n(T -~) = (~ + 7 ) m = T(~ ) Let the domains of results and computations in T be given by WI-[o] = D \n and C~[a] = D . We can now give the meaning of VPCF terms. For any VPCF term M of type a, TIIkf]pT is \nan element of C~[a], where pr is a T-environment, i.e., a map from variables tcl D such that pr(z ) c \nR~[a]. The clauses for interpreting the VPCF constructs are given in Table 3, which use the functions \nof the monad and the semantic elements Ap I defined as Apc]7 = ~f E Dfu+ ) ,&#38; ~ Dr . P [T (~ c D(o-r) \n. u ((T g) z)) f] and where Qt. e) is a meta-notation to denote elements of the model. Requirement (1), \nthat the call-by-value monad operations be (interpretable , ensures that these definitions are good definitions. \n 4.3 Semantic Coercions We are now ready to establish the key semantic result the model V is a retract \nof the mode~ T. Let (T, ~, ~, ~) be a, call-by-value monad over the model V. For each VPCF type a, Table \n4 defines elements a: c D - , ~~ ~ D + , and functions a: : D + CZT[a],~~ : CT[U] + D . (Note: The elements \na;, ~~ are thus strict functions.) Intuitively, the function a: embeds elements of .DU into computations \nin CT [o] that have identical functional behaviour but no side effects; the function ~~ extracts the \nresult of the compu\u00adtation and maps it to the element that has the same func\u00adtional behaviour. One can \nshow that (~~ o a:) is the iden\u00adtity function, i.e., D is a retract of C~[aJJ. We thus de\u00adfine the retraction \nfunction b: = (a: o ,&#38;?); the retractions f: coerce a computation into one with identical functional \nbehaviour but no side effects. Add the term constructors (encapc; u * U) for each VPCF type a to VPCF; \nT is a. model of this extended language with 7[encap@ M]P7 = 6~(T[M]pT). The following theorem then captures \nthe be\u00adhaviour of the retractions as semantic coercions. Theorem 4 Suppose M, N w-e closed VPCF terms \nand T is a call-by-value monad over D. Then I. Adequac~: D[M] = B(7[encap.Um M]). 2. Preservation: If \nC[.] is a closed VPCF context of type num, then 7[C[M]] = TIC[encapo M]]. 5 . Full abstraction: T[encapC \nM] = T[encapO N] if and only tf D[M] = D[iV]. We use logical relations to prove Theorem 4. First, de\u00adfine \nthe following family of binary relations that are used to relate elements of D with computations in CT \n[a] whose results have the same functional behaviour. Definition 5 Define the relations R: : Do x %?r[a] \nand R: :D X C~[a] by c d R;um eiffd=e. E d R;- e iff (dt and et), or (dJ and e~) and Vd J, e J .d l?: \ne o (d d ) R: (e e ) EdR; e iff there is an e such that e = (~ e ) and d R; e . 5 Table 3: Semantics \nof VPCF Over a Call-by-value Monad. T[z ]P7 = T[(k . M)]gm = T[(M N)]pT = 7[n]pT = 7[SUCC (M)]pl\u00ad = T[pred \n(M)]PT = TfifO(M, N, P)]pT = T[Y ]/JT = Table 4: Embedding V into T. The relations R: can be shown to \nbe directed complete, which together with the fact that the relations R: are log\u00adical helps establish \nthe following lemma, that relates the meaning of a term in the two models. Lemma 6 Suppose that pv is \na D-environment and Q7 is a T-environment such that pD(Xu) R; pT(x ) for a!! x . Then jor any PCF-terrn \nM : a, D[M]p~ R: 7[M]PT. To prove Theorem 4, we need a few more simple facts: Lemma 7 1. For any x ED \n, ,8: (cY~x) = x. 2. If dR; e then dR: (S: e).  3. IfdR~ (8: e)then a: d= 6:e. The proof, which we \nomit, uses a simple induction on the structure of types. Part 1 of Lemma 7 states the previously mentioned \nproperty that ,BCo cr. is the identity function. An important consequence of this property is that the \nfunctions a: are inject ive. It therefore follows from the last two state\u00adments in Lemma 7 that the inverse \nof the logical relations are injective on the range of the coercions S:. Proof of Theorem 4: 1. By Lemma \n6, D[MJ l?.~ m T[lkf]. Hence, by the sec\u00adond part of Lemma 7, ZJ[&#38;f] Rs m 7[encapnUm M]. Using the \ndefinition of R~ m, this means that T[encapnUm M]= qnum (D[M]) By Property 5 in the definition of a ca~-by-value \nmonad, the adeqnacy statement now follows. 2. By Lemma 6, D[iM] R: T[M] (1) Using the definition of R:, \nthis means that T[M] = (q e) and D[JWJ R; e. Thus, if ZU is a variable that does not appear in the context \nC[.], then the environments pzJ and p7 such that pzJ(z ) = D[kf] and p~(xu) = e satisfy the con\u00additions \nof Lemma 6. It therefore follows from Lemma 6 that DIC[Xo]]pZJ R~ m TIC[x ]]pT and so DIC[lf]] R~ m 7~C[M]]. \nNow, using the definition of l?~ m, T[C[M]] = q(qc[ll f]]) (2) Using the second part of Lemma i on (I), \nD[M] R; 7[encapC M] Then by a similar argument as before, T[C[encapm M]]= q (~[c[~ll) (3) Hence we get \nthe required statement from (2) and (3). 3. By Lemma 6 and the second part of Lemma 7, we have D[kf] \nR: T[encap&#38; M] D[N] R: T[encapa N] Using the third part of Lemma 7, we have a: (D[M]) = T[encapo \nM] cY~ (D[N]) = T[encapm N] It follows that D[kf] = D[N] iff a: (D[lkf]) = a: (P[iv]) iff T[encapm M] \n= T[encapa N] where the first equivalence follows from the infectivity of 0:. This completes the proof \nof the theorem. 6 Syntactic Coercion Operators 1. Adequacy: EvcdL+encap(encal pnUm M) = n if and only \nWe now use the framework of call-by-value monads to in\u00adterpret extensions of VPCF with side effects. \nWe first show how to add coercion operation encap to extensions of VPCF, with the operational rules for \nthe coercion operation deter\u00admined by the monad, and state a correctness theorem for the resulting coercions \ngiven some properties of the monadic se\u00admantics of the extension. We then apply the theorem to our two \nexample extensions, VPCF+K and VPCF+S. 5.1 General extensions Let L be an extension of VPCF and (T, q, \np, ~) be a call\u00adby-value monad over a model D of VPCF. As can be seen from the examples in Section 3, \na general way to specify the syntax of terms in -L is to possibly add type and term construct ors to \nVP CF. A denot ational semantics 7[.], over the monad T, for L is given by extending the definition of \na to the additional types u of L and specifying func\u00adtions T[j] : CT[al] x . . . x CT[an] ~ CTIO] for \neach new term constructor (~; UI, . . . , an +-a) in L, such that T[.f] is interpretable in D. Together \nwith Table 3, the clause T[f(fwl, . . . . JfTI)]PT = T[f](nMI]PT,..., TIM~]pI-) de\u00adfines the meaning \nof all terms of L. We add term con\u00adstructors (encapr; m +-u) for each VPCF type a to L; call the resulting \nlanguage L + enca p. The meaning function T[.] can be extended to L + encap with T[encapo M]pr = 8: (T[M]pT). \nThe following lemma, proved by expanding out the definitions of the retractions 8C, gives us operational \nrules for the encap operators. Lemma 8 Let L be an extension ojcall-by-vaiue PCF whose model 7[.] is \ndefined over a call-by-value monad. Then, for any L + encap term M and T-environment p, E 7_[encapnum \nM]P = q (P (7KMIP)), E If ya is not free in M, then T[encapo+r M]p equals T[encapnUm(M; O); M . encapr(ikf(encapmy) \n)]p. The rewriting operational semantics framework makes it particularly easy to describe the operational \nrules for enca p. The operational semantics of L+encap is obtained by adding the redexes in Table 5 to \nthose of VPCF. Note that the sec\u00adond redex is independent of the language extension or the particular \nmonad. Call the denotational semantics T[.] of L, over the monad T, adequate, if for all programs, s \n.e., closed terms M of type num, EvcdL(M) = n iff /3(7[M]) = T[n], and similarly for L + encap. Using \nLemma 8, we can prove the following lemma which shows that the operational rules for enca p are faithful \nto its denotational semantics. Lemma 9 Let (T, Q, p, /3) be a call-by-value monad over a call-by-value \nmodel D and T[.] be some denotational seman\u00adtics over the monad T that is adequate for L. Then T[.] is \nalso adequate for L + encap. Using Lemma 9 and Theorem 4, we can now prove that under certain conditions \nenca p accurately recovers the oper\u00ad ational behaviour of VPCF: Theorem 10 Let D be a fully abstract, \nleast fixpoint model for VP CF. Let (T, q, p, /3) be a call-by-value monad over D and 7[.] be some denotational \nsemantics over the monad T that is adequate for L. Then, for any closed VP(7F terms M, N of the same \ntype, if llva~u(ikf) = n. 2. Preservation: Let C[.] be any closed VPCF context OJ t~~e num. Then EvcdL+encap(C[kf]) \n= n if and only if EUalL+encap(C[encapo M]) = n. 3, Full abstraction: (encapm M ] =L+encaD (encap~ N) \ni.f andonlyijM~vpcF~ .  - While the above theorem describes the behaviour of enca p on purely functional \nterms, one can also use the semantic theorems to describe the behaviour of enca p on arbitrary terms. \nFor inst ante, one can prove that enca p produces observationally congruent terms from functionally equiv\u00adalent \nterms. Define a closed term M of arbitrary type u to halt iff Eual(M; O) is defined. Then we can define \ntwc) closed terms M and N of type u to be functionally equiva\u00adlent, M ~ju,e N, as follows: E M ~~fi N \niff Evai(M) m Eva/(N) E M =j~~ N if M halts iff AI halts and for all VPCF values V of type r, M V -J,,e \nN V. Intuitively, M and N are functionally equivalent if they have the same Input-output behaviour. \nThen, the following the\u00adorem shows that functionally equivalent pieces of code are interchangeable within \nthe scope of encap. Theorem 11 Let D be a fully abstract, least fixpoint model for VPCF. Let (T, ~, ,a, \n~) be a call-by-value monad over D and 7[.] be some denotational semantics over the monad T that is adequate \nfor L. Suppose M, N are closed L + encap terms of PCF type such that M %P~,~ N. Then (encap M) =~+encap \n(encap N). Since the logical relations establish a bijective correspon\u00addence between the call-by-value \nmodel of VPCF and the range of the retractions, we conjecture that the theory of the call-by-value model \n(when the logic is suitably defined) will be the same as for coerced expressions. 5.2 Adding encap to \nVPCF+K Let V be any least fixpoint model of VPCF. We can define the continuation monad K = (K, ~~, px, \n~c) over V by k (a) = (a ~ num) -+ num K.r,v = A_f c v - . Ax ~ VW ). &#38; cV +n m.z (&#38;Jcv . K(j-v)) \nr?; (z) = Alc G V +n m.Kx ~: = Ax ~ VWWO)). AK c V -n m . z @m~ v~f(m).mtc ) pK = &#38; ~ v~f( rn). z \n(,&#38;) E V rn. y) One may verify that this definition gives a call-by-value monad. We can obtain a \nsemantics K for VPCF+K by K[callcc](f) = &#38;c. f (Am. m ,~ K) K[abort]( f ) = AK ~ Vn m+n m. f (Ax \nc Vn m. X) Since ,8K corresponds to evaluating in the empty context, we thus get the redex defined in \nTable 5 for VPCF+K. Note 7 Table 5: Operational Rules for encap. (encapnum M) * n, if ,B(TIJ1]) = D[n] \nGeneral call-by-value monad (encapa-. ~) -+ encapnum(itf; O) ; ,ly . encapr (M (encapa y)) VPCF+K (encapnum \nM) - n+ if M 4.72 VPCF+S (encapnum M) + n, if (M, 0) ~. (n, s ) that the semantics of encapnum coincides \nwith that of first\u00adclass prompts [8]. The semantics /C[.] corresponds directly to usual cps (continuation-passing \nstyle) transforms [30, 39]. It is thus easy to check that if V is an adequate model for VPCF, then the \nsemantics K[] is adequate for VPCF-I-K. Since any fully abstract model is also adequate, we can apply \nTheorem 10 to the case of VPCF+K, if the model V is fully abstract. Thus, to establish the correctness \nof enca p for VPCF+K, all that remains is the construction of such a model, i.e., prove the following \ntheorem: Theorem 12 There extsts a fully abstract, least jixpoint model V of VP CF. One obvious way \nto construct a fully abstract model of V is to take the term model consisting of equivalence classes \nof all closed terms. Unfortunately the term model for VPCF, while triviafly fully abstract, is not continuous. \nHowever, by a suitable context lemma (cj [JI]), the term model for a purely functional call-by-value \nlanguage is always mono\u00adtone. Thus, if all types in the term model are finite, then it is also continuous. \nWe rely upon this insight to prove The\u00adorem 12. Instead of VPCF, we consider a language FVPCF in which \nall types are finite and which will serve as an ap\u00adproximation to VP CF. FVPCF has base types num,, whose \nelements are {O, . . . . z}, that serve as finite approximations of the infinite type n urn. FVPCF does \nnot have fixed point operators, but includes suitable finite approximations of the other term constructors \nof VPCF modified to operate on the n u m, s. More importantly, FVPCF needs to include constants representing \ndivergence explicitly in its syntax to reflect the call-by-value operational equivalence. The con\u00adtinuous \nterm model of FVPCF contains a lattice of partial types related by embedding-projection maps approximat\u00ading \neach type of VPCF. We obtain a least fixed point model V for VPCF by taking the meaning of each type \nto be the (inverse) limit of its partial type approximations. In fact, each type is an algebraic cpo \nwith its finite elements corre\u00adsponding to the definable terms of FVPCF; definability of the finite elements \nis enough to prove full abstraction. The precise details of the construction appear in [38]. 5.3 Adding \nencap to VPCF+S To give a denotational semantics for VPCF+S, we need to model states. Since states may \nbe circular, the appropri\u00adate representation of states has to be recursive. A suitable framework for \nbuilding states is the language FPC defined in [9], which includes a one-element type unit, product types, \nsum types, and recursive types. We can thus define a store call-by-value monad over 7 as follows. Using \nthe recursive types of FPC, we first define types Loc = (pt. unit+ t) and Store to be the appropriate \nrecursive type given by the equa\u00adtions Store = Loc --T (Res + unit) Res = num + Lot+ (Res -+ Comp) Comp \n= Store -(Res x Store) (cf. [36]). Let i nit be the initial store mapping every location to the right \nportion of the sum, z.e., declaring each cell to be unused . Let the call-by-value monad S = (S, qs, \nps, /?s) be defined by S(a) = Store -+ (a x Store) s.,. = ~f EF - . Ax E Fs( ). ~s. pair(j(fst(z s)), \nsnd(z s)) ~~(.L) =Js. pair(z, s) p: = &#38; E FsfsLU~~.&#38;.fst(z s) snd(z s) ~s = &#38; ~ Fs[num). \nfst(x init) The semantics S of types is determined by setting (ref a) = Lot; the semantics of the additional \nterm constructors in VPCF+S can be written as meanings of the appropriate terms of FPC. Since ~s corresponds \noperationally to eval\u00aduating in the initial store, the operational rule in Table is an implementation \nof /!?s. This breaks the usual single\u00adthreaded property of state; see below for more discussion. One \ncan show that if X is an adequate model for FPC then the resulting semantics S[.] of VPCF+S is also ade\u00adquate. \nMoreover, if the model ~ of FPC is fully abstract, then the submodel of 3 for VPCF obtained by taking \nnum = (Mt.unit + t) is also fully abstract. Thus, by Theorem 10, we can obtain the correctness result \nfor VPCF+S+encap if we can prove Theorem 13 There exists a continuous, juliy abstract model F of FPC. \nWe follow the construction for VPCF; the details also ap\u00adpear in [38]. We define a finite language FFPC \nthat includes an empty base type void, the one-element type unit, prod\u00aducts and sums, but not recursive \ntypes. The main difficulty in constructing the model of FPC from the term model of FFPC is in defining \nthe types of FFPC that serve as ap\u00adproximations to the recursive types of FPC and suitable embedding-projection \nmaps between them. Intuitively, we think of a recursive type pt. a as the limit of its finite un\u00adwindings \np% a, where a= void, p +lt. a = [p t. pot.m/t]a. The partiaJ types approximating a recursive type pt.a \nare those approximating each unwinding pnt.u. 8   6 Example of encap with State Let us consider an \nextended example of how to use enca p for reasoning in a language with state. We use the syntax of Standard \nML [22] instead of VPCF in this example, partly because we will need a richer set of data types, and \npartly to improve readability. The example is unification (also considered as a test case in [40] for \nthe Imperative Lambda Calculus). Ordi\u00adnary (first-order) unification admits two elegant solutions: the \nfirst, Robinson s algorithm using substitutions, can be implemented in a purely functional manner; the \nsecond, us\u00ading directed acyclic graphs (dags), is much more efficient but requires state. The following \nis an encoding of the lat\u00adter algorithm; we leave it to the reader to find the purely functional encoding. \ndatatype term = Mum i Typevar of string I Fnsp of term*term local datatype tag = Unbound I Instance of \ndagterm and dagterm = DMum i DTypevar of string* (ref tag) I DFnsp of dagterm*dagterm fun find (x, []) \n= Ione I find (x, (Y, z): :tl) = if x=y then Some z else find (x ,tl) fun convertToDafw (tl ,t2) = let \nval table = ref [] fun convert Hum = DIJum I convert (Typevar x) = (case find (x, !table) of Some r => \nDTypevar (x, r) I . > let val p = (x, ref Unbound) in table := p::(!table); DTypevar p end) I convert \n(Fnsp(t ,u) ) = DFnsp(convert t ,convert u) in (convert tl, convert t2) end fun occur x DEum = false \nI occur x (DTypevar (y ,r) ) = (case !r of Unbound => (x=y) I Instance t => occur x t) I occur x (DFnsp \n(tl ,t2) ) = (occur x tl) orelse (occur x t2) fun unif yDags (Dllum, DIJum) = true I unifyDags (DTypevar \nVI, DTypevar v2) = if (vI=v2) then true else unifyVs(vl, v2) unifyDags (DTypevar VI, t2) = unifyVT (vI, \nt2) unif yDags (t 1, DTypevar v2) = unif yVT (v2, tl ) unifyDags (DFnsp(ti , t2) ,DFnsp(t3, t4) ) = (unif \nyDags (ti, t3) ) andalsO (unif yDags (t2, t4) ) I unifyDags . = false and unifyVs (vI as (x, r), v2 as \n(x>,r>)) = (case (!r, !r ) of (Instance tyl, -) => unif yVT(v2, tyl) I (-, Instance ty2) => unifyVT(vl, \nty2) I (unbound ,unbound) > (r := (Instance (DTypevar v2) ) ;true) ) and unifyVT (vI as (x, r) , t) n \n(case !r of Unbound => if occur xt then false else (r := Instance t; true) I (Instance t ) => unifyDags(t,t \n)) in fun unify p = unifyDags (convertToDags P) end Terms are encoded by the datatype term and the func \ntion unify returns true if the terms are unifiable and false otherwise. The dat at ype dagt erm changes \nonly the represen-. tation of variables variables can now point to other terms as an (inst ante , w h \nlCh serves to make unification of terms with variables a simple matter. Two auxiliary functions in this \ncode use assignments. The function convertToDags, which converts elements of the dat at ype term into \ndags, uses a reference cell to store type variables that have al\u00adready been assigned references; the \nfunction unif yVT also uses assignment to link a variable to a new instance. We can use the two encodings \nof unify to illustrate a general programming methodology of modular refinement, where a programmer first \nimplements a module purely func\u00adtionally and then refines it using state to produce a more efficient \nversion. In this cent ext, one may hope to use the imperative version of unify in place of the functional \nver\u00adsion in any program since they have the same input-output behaviour. However, as the example in the \nintroduction showed, in the presence of side-effects, such a refinement may not always preserve the beh \naviour of the whole pro\u00adgram. If the language includes encap, we can guarantee the correctness of this \nprocess of modular refinement by wrap ping the code of unif y with encap. By Theorem 11, having the same \ninput-output behaviour is then enough to guaran\u00adtee the correct ness of this refinement, since the refinement \nis within the scope of encap. If we do not wish to include encap in the language, we can still use enca \np as a useful reasoning tool to establish the correctness of replacing the functional version with the \nimperative version directly (i. e., without wrapping it with enca p). First, observe that the code accesses \nno reference cell that is not allocated during a call to unify, and that none of the reference cells \ncan ble accessed after a call to nnif y. Also observe that the declaration yields a value, and that the \narguments to unify cannot themselves con\u00adtain any referen;e cells (due to the limited structure of the \ndat at ype term). From these facts and the denot ational or operational semantics of encap, one may prove \nthat wrap\u00adping enca p around the entire expression yields a term that is operationally equivalent to \nthe expression itself. Similarly, since the functional version of unify also cannot access any reference \ncells from outside, one may show that wrapping enca p around it gives an operationally equivalent expression. \nSince Theorem 11 gives us the operational equivalence of the two pieces of code wrapped with encap, it \nfollows that the two pieces of code are equivalent even without enca p around them. This example and \nthe example in [36] illustrate a com\u00admon technique for proofs of correctness. If one can show that state \nis already encapsulated (by showing that applying en ca p results in an operationally equivalent term), \none can then apply Theorem 11 to deduce that functional reason\u00ading principles are sufficient. This is \nan important reasoning principle and well-supported by programmer s intuition. 7 Related Work This approach \nin this paper is certainly not the first attempt to control side effects in functional languages; there \nis a long tradition of language designs that attempt to control side effects. Such efforts have mainly \nfocused on simplifying the reasoning principles required for proving properties of programs and on automatically \ndetermining opportunities 9 for parallel evaluation. Broadly speaking, two distinct and seemingly unrelated \ncamps have emerged, divided along the traditional call-by-name versus call-by-value line. Most of the \nwork has followed the call-by-name tradi\u00adtion, beginning with Algol 60. Reynolds more contempo\u00adrary work \non syntactic control of interference [32, 34], Ide\u00adalized Algol [33], and Forsythe [34] have carried \nforth this tradition. Each of these languages incorporates restrictions on both types and terms so as \nto force assignments and references to be we~-behaved. For example, in Idealized Algol, the basis for \nthe other two programming language designs, terms that write to the state are grouped into the type of \ncommands; the other two types of basic terms, lo\u00adcations and expressions, may read the state but not \nmodify the state. This greatly simplifies reasoning about programs: with the call-by-name parameter passing, \nprograms of com\u00admand type may be unwound into a simple sequence of im\u00adperative statements in other words, \nuser-defined functions can be completely removed from the program by partial eval\u00aduation [34]. The imperative \nlambda calculus (ILC) of [40] has a similar design philosophy in separating the terms that can modify \nthe state from those that may not. The lazy functional programming community has also been active in \nsearching for new, clean ways of adding state to program\u00adming languages; just a few of these efforts \nare dialogue-based 1/0 in Haskell [13], monads [29, 43], continuation-based mutable abstract datatypes \n[12], and lazy functional state threads [18] (whose type-theoretic encapsulation of state is remarkably \nsimilar to the work in semantics of [27]). In each case, the design preserves some functional character \nof the language the equation (/3) is sound for proving operational equivalences, for example, so terms \nof functional type do not yield side effects when applied. Another language in the call-by-name tradition, \nand pos\u00adsibly the closest design to VPCF+S+enca p, is the language A v., of [25]. Syntactically, J ,C, \nis an extension of the un\u00adtyped A-calculus with assignments and some additional op\u00aderations for encapsulating \nstate. Atic, enjoys a property sim\u00adilar to our main theorem two pieces of code Al, N without assignments \nare operationally equivalent in the full language iff they M, N are operationally equivalent in the language \nwithout assignments; in contrast to our main theorem, no operations are required to coerce &#38;f and \nN. A..r enforces this purity of assignments via two new term constructors, pure and return. Using the \nsyntax of this paper, the opera\u00adtional semantics for the special operations of ~~~, are (pure (return \nn)) ---+ n (pure (return (kc. M))) -.+ k. pure (return kf) As with the semantics of encap, pure applied \nto functional abstractions forces the value returned by the function to be pure; the argument, on the \nother hand, is not forced to be pure (probably because of the call-by-name reduction se\u00admantics). Unlike \nenca p, the operation return is needed in the language to mark which subexpressions may be marked as \nside-effect free. Those expressions that are not returned, e.g., (pure O), are (stuck expressions that \ncannot be re\u00adduced further; the counterpart in VPCF+S+encap is an ex\u00adpression like (enca p i) for some \nlocation 1. The advantage of ~,=, over VPCF+S+encap is that it can be implemented with a single-threaded \nstore; the disadvantage is that it is manifestly based on call-by-name semantics (as with ILC and Idealized \nAlgol), and that the syntax of assignments, pure, and return are somewhat restrictive. Far less attention \nhas been paid to controlling side ef\u00ad fects in the call-by-value realm. Some of the most well\u00ad developed \napproaches are the type and effect systems for assignments [17, 19, 20, 41, 42], continuations [16], \nand ex\u00ad ceptions [10]. In each of these languages, a static system assigns both types and possible effects \nto expressions; the type and effect can then be used in the generation of code for parallel architectures \nand other applications. For exam\u00ad ple, in the type and effect system for state, one envisages memory \nas divided into a set of regtom, or blocks of loca\u00ad tions. The type and effect system calculates a conservative \napproximation of dividing the cells into regions. Consider a simple example, the (gensym function that \nreturns a new integer each time it is called: (AZ ef m. Adn m. (z := succ (!z)); (!z)) (ref O) In the \ntype and effect system, the type is more complicated than (num + num) (the type in VPCF+S). This expression \ncreates a new cell, so the effect is ink(p) for some region p, and when given an argument of type num \nthe expression returns a nu m and reads in writes in region p, so the type is read(P~&#38;write(Pj (num \nnum).  The effects above the + is called a latent effect, since they are effects poised to fire during \na function call but do not occur during the evaluation of the expression. Automatic parallelization of \ncode with side effects is one of the primary uses of effect systems (see, e.g., [14]). In the case of \nstate, for example, if the manifest effects of two subterms of a term occur in different regions, the \ntwo sub\u00adterms may be safely reduced in parallel. The operations enca p may also be used for this purpose, \nalbeit at a much less refined level: for example, the subterms (encap M) and (encap N) may be reduced \nin parallel in evaluating ((encap Jf) (encap N)); the correctness of this paralleliza\u00adtion follows from \nTheorem 10 and a suitable standardization theorem for VPCF (cf. [30]). The type and effect system has \nat least two advantages over the enca p operation in VPCF+S+encap. First, using ideas from type inference, \nthe compiler can determine the type and effect of an expression automatically [42]; the pro\u00adgrammer need \nnot worry about the type and effects of ex\u00adpressions initially. Second, the language can be implemented \nusing a single-threaded state: type and effect annotations give hints to where parallelization can happen \nsafely with\u00adout write-after-read or write-after-write conflicts, Z.e., where parallelization can occur \nwithout violating the sequential, single-threaded semantics; enca p breaks the single-threaded semantics \nof state. The antomatic character of type and effect systems also has drawbacks, primarily because it \nre\u00adquires a kind of conservativity. For inst ante, the expression (ifO Othen 3 else x := O;8) has a \ntype num and effect write(p) if z is bound to a lo\u00adcation in the region p, even though the expression \nhas no effect, Indeed, there may be a way to meld the two ap\u00adproaches together by redefining the semantics \nof VPCF+S to use computations of the form Comp = (Region + Store) + (Res x (Region --+ Store)) so that, \nin effect, the store is divided into regions. Defining ~ in this setting is the only difficult part, \nalong with tying it into a general theorem like Theorem 10. 10 8 Conclusion in Semantics, pages 89 132. \nCambridge Univ. Press, 1985. We have shown how to construct encapsulation operations that force portions \nof a program to behave purely function\u00ad [4] R. Cartwright and M. Felleisen. Observable sequential.. ally. \nThe coercion operations rely on a few deep denota-ity and full abstraction. In Conference Record of the \ntional theorems. The framework developed here, in contrast Nineteenth Annual ACM Symposium on Principles \nof to the framework of [36], encompasses sequential program\u00ad programming Languages, pages 328-342. ACM, \n1992. ming languages, and hence is applicable to a wider variety [5] W. Clinger and J. Rees. The revised4 \nreport on theof practical languages. algorithmic language Scheme. LISP Pointers, 4: 1 55, It is worth \nreexamining the stated design goals of encap 1991. from the introduction. The first design goal, to \nallow the programmer to protect pieces of code, requires an efficient [6] P.-L. Curien. Observable sequential \nalgorithms on con.. implement ation of enca p. This seems to be very unclear in cret e data structures. \nIn Proceedings, Seventh A rznual the case of state. Morrisett [24] has shown how one can im-IEEE Symposium \non Logic in Computer Science, pages plement first-class stores in Standard ML, with operations 432-443, \n1992. for naming the current store and returning back to a previ\u00adously named store. It is not hard to \nimplement enca p at base [7] M. Felleisen. A-V-CS: An extended J-calculus for Scheme. In Proc. of Conf. \nLISP and Functional Pro\u00adgramming, pages 72-85. ACM, July 1988. type: one could name the initial store, \nand when entering a enca p, name the current store and snap-back to the initial store. The higher-t ype \nenca p could be implemented by evac\u00ad [8] M. Felleisen. The theory and practice of first-class uating \nthe term inside the enca p in the initial store, then us\u00ad prompts. In Conference Record of the Fifteenth \nAn\u00ad ing the closure if the evaluation converges to a A-abstraction. nual ACM Symposium on Principles \nof Programming In the case of polymorphic languages, some variant of the Languages, pages 180-190. ACM, \n1988, typeseq operation of [11] is essential in implementing enca p. Without single-threading of state, \nhowever, the efficiency [9] C. A. Gunter. Semantics of Programming Languages: of a language with state \nand enca p may discourage anyone Structures and Techniques. MIT Press, 1992. from using it. There may \nbe similar efficiency issues with [10] J. C. Guzm&#38;n and A. Su&#38;rez. A type system for ex\u00adenca \np in the language with control. ceptions. In Record of the 1994 ACM SIGPLAN Work.. On the other hand, \nwe feel that the second design goal shop on ML and its Applications, pages 127 135, 1994. to encapsulate \nstate for proving properties of programs is Available as INRIA Technical Report 2265. met. We feel that \nthe example of Section 6 is quite convinc\u00ading, and it would be worth pursuing making a formal logic [11] \nR. Harper and G. Morrisett. Compiling polymorphism to reflect the reasoning of the example. using intentional \ntype analysis. In Conference Record of The techniques developed in this paper are useful beyond the Twenty-Second \nAnnual ACM Symposium on Prin\u00ad the context of the particular problem studied here. The ciples of Programming \nLanguages. ACM, 1995. fully abstract models of VPCF and FPC can be used in es\u00adtablishing other general \nresults about sequential languages. [12] P. Hudak. Continuation-based mutable abstract For example, we \ncan use them to prove that translations be-datatypes, or how to have your state and munge it too. tween \nprogramming languages are fully abstract (cj [37]). TechnicaJ Report Research Report YALEU/DCS/RR-More \nimportantly, this work brought out the shortcoming of 914, Yale University, 1992. monads as a framework \nfor expressing the semantics of side [13] P. Hudak, S. L. Peyton Jones, P. L. Wadler, Arvind,effects \nwhen applied to models arising from other monads B. Boutel, J. Fairbairn, J. Fasel, M. Guzman, K. Ham\u00ad(such \nas other side effects). Since the definition of a call-by\u00admond, J. Hughes, T. Johnsson, R. Kieburtz, \nR. S. value monad formulated here had to bypass precisely this Nikhil, W. Part ain, and J. Peterson. \nReport on theproblem, it may prove to be more appropriate, for example, functional programming language \nHaskell, Version 1.2. in analyzing languages with more than one side effecting ACM SIGPLAN Notices, May \n1992. feature. [14] L. F. Huelsbergen. Dynamic Language ParaUelization, Acknowledgements; We thank the \nmembers of the program PhD thesis, University of Wisconsin, 1993. Available committee for useful comments. \nThe unification example is as Computer Sciences Department Technical Report borrowed from an example \ndue to John Reppy. Number 1178. [15] M. Hyland and L. Ong. Dialogue games and innocent References strategies: \nAn approach to intensional full abstraction to PCF (preliminary announcement). Unpublished, [1] S. Abramsky. \nThe lazy lambda calculus. In D. A. 1993. Turner, editor, Research Topics in Functional Program\u00ad [16] \nP. Jouvelot and D. K. Gifford. Reasoning about contin\u00adming, pages 65 1 17. Addison-Wesley, 1990. uations \nwith control effects. In Proceedings of the 1989 [2] S. Abramsky, R. Jagadeesan, and P. MaJacaria. Games \nACM SIGPLAN Conference on Programming Language and full abstraction for PCF: preliminary announce-Design \nand Implementation. ACM, 1989. ment. Unpublished, 1993. [17] P. Jouvelot and D. K. Gifford. Algebraic \nreconstruc\u00ad [3] G. Berry, P.-L. Curien, and J.-J. L&#38;y. Full abstrac-tion of types and effects. In \nConference Record of the tion for sequential languages: the state of the art. In Eighteenth Annual ACM \nSymposium on Principles of M. Nivat and J. Reynolds, editors, Algebraic Methods Programming Languages, \npages 303-310. ACM, 1991. 11 [18] J. Launchbury and S. L. Peyton Jones. Lazy functional state threads. \nIn Proceedings of the 1994 ACM SIG-PLAN Conference on Programming Language Design and Implementation, \npages 24 35. ACM, 1994. [19] J. M. Lucassen. Type-checking Fiuent Languages. PhD thesis, Dept. Electrical \nEngineering &#38; Computer Sci., Massachusetts Institute of Technology, 1987. Available as technical \nreport MIT/LCS/TR-408 (MIT Labora\u00adtory for Computer Science). [20] J. M. Lucassen and D. K. Gifford. \nPolymorphic effect systems. In Conference Record of the F~fteenth Annual ACM Sympos~um on Principles \nof Programm~ng Lan\u00adguages, pages 47 57. ACM, 1988. [21] R. Milner. FuIly abstract models of the typed \nlambda calculus. Theoretical Computer Sci., 4:1 22, 1977. [22] R. Milner, M. Tofte, and R. Harper. The \nDefinition of Standard ML. MIT Press, 1990. [23] E. Moggi. Notions of computation and monads. Infor\u00admation \nand Control, 93:55 92, 1991. [24] G. Morrisett. Generalizing first-class stores. In ACM SIGLPLAN Workshop \non State tn Programming Lan\u00adguages, pages 73 87, 1993. Available as Yale Technical Report YALEU/DCS/RR-968. \n[25] M. Odersky, D. Rabin, and P. Hudak. Call by name, assignment, and the lambda calculus. In Conference \nRecord of the Twentieth Annual ACM Symposium on Principles of Programming Languages, pages 43-56. ACM, \n1993. [26] P. W. O Hearn and J. G. Rlecke. Kripke relations and PCF. Information and Computation, 1995. \nTo appear. [27] P. W. O Hearn and R. D. Tennent. Relational para\u00admetricity and local variables. In Conference \nRecord oj the Twentieth Annual ACM Symposzum on Principles of Programming Languages, pages 171 184. ACM, \n1993. [28] C.-H. L. Ong. The Lazy Lambda Calculus: An Inves\u00adtigation into the Foundations of Functional \nProgram\u00adming. PhD thesis, Imperial College, University of Lon\u00addon, 1988. [29] S. L. Peyton Jones and \nP. Wadler. Imperative func\u00adtional programming. In Conference Record of the Tzuen\u00adtieth Annual ACM Symposium \non Principles of Pro\u00adgramming Languages, pages 71-84. ACM, 1993. [30] G. D. Plotkin. Call-by-name, call-by-value \nand the J\u00adcalculus. Theoretical Computer Sci., 1:125 159, 1975. [31] G. D. Plotkin. LCF considered as \na programming lan\u00adguage, Theoretical Computer Sci., 5:223 257, 1977. [32] J. C. Reynolds. Syntactic control \nof interference. In Conference Record of the Fifth ACM Symposium on Principles of Programming Languages, \npages 39-46. ACM, 1978. [33] J. C. Reynolds. The essence of Algol. In J. W. de Bakker and J. C. van Vliet, \neditors, Algorithmic Languages, pages 345 372. North-Holland, Amsterdam, 1981. [34] J. C. Reynolds. Syntactic \ncontrol of interference, part 2. In G. Ausiello, M. Dezani-Ciancaglini, and S. R. D. Rocca, editors, \nAutomatal Languages and Program\u00adming: 16 h International Colloquium, volume 372 of Lect. Notes in Computer \nSci., pages 704-722. Springer-Verlag, 1989. [35] J. G. Riecke. The Logic and Expressibility of Simply-Typed \nCall-by-Value and Lazy Languages. PhD thesis, Massachusetts Institute of Technology, 1991. Available \nas technical report MIT/LCS/TR-523 (MIT Labora\u00adtory for Computer Science). [36] J. G. Riecke. Delimiting \nthe scope of effects. In Proceed\u00adings of the 1993 Conference on Functional Program\u00adming and Computer \nArchitecture, pages 146 158. ACM, 1993. [37] J. G. Riecke. Fully abstract translations between func\u00adtional \nlanguages. Mathematical Structures in Computer Science, 3:387 415, 1993. Preliminary version appears \nin Conference Record of the Eighteenth Annual ACM Symposzum on Prtnctples of Programming Languages, pages \n245-254, ACM, 1991. [38] J. G. Riecke and R. Viswanathan. Full abstraction for call-by-value sequential \nlanguages. Unpublished manuscript, 1993. [39] D. Sit aram and M. Felleisen. Reasoning with contin\u00aduations \nII: Full abstraction for models of control. In Proceedings of the 1990 ACM Conference on Lisp and Functional \nProgramming, pages 161-175. ACM, 1990. [40] V. Swarup, U. Reddy, and E. Ireland. Assignments for applicative \nlanguages. In J. Hughes, editor, Confer\u00adence Proceedings of the Fifth International Conference on Functional \nProgramming Languages and Computer Architecture, volume 523 of Lect. Notes in Computer Sci., pages 192 \n214. Springer-Verlag, 1991. [41] J.-P. Talpin. Theoretical and Practical Aspects of Type and Etiect \nInference. PhD thesis, University of Paris VI, 1993. [42] J.-P. Talpin and P. Jouvelot. Polymorphic \ntype, region and effect inference. Journal of Functional Program\u00adming, 2:245 271, 1992. [43] P. Wadler. \nThe essence of functional programming. In Conference Record of the Nineteenth Annual ACM Symposium on \nPrinciples of Programming Languages, pages 1-14. ACM, 1992. 12 \n\t\t\t", "proc_id": "199448", "abstract": "<p>It is well known that adding side effects to functional languages changes the operational equivalences of the language. We develop a new language construct, <bold>encap</bold>, that forces imperative pieces of code to behave purely functionally, <italic>i.e.</italic>,without any visible side effects. The coercion operator <bold>encap</bold> provides a means of extending the simple reasoning principles for equivalences of code in a functional language to a language with side effects. In earlier work, similar coercion operators were developed, but their correctness required the underlying functional language to include parallel operations. The coercion operators developed here are simpler and are proven correct for <italic>purely sequential</italic> languages. The sequential setting  requires the construction of fully abstract models for sequential call-by-value languages and the formulation of a weak form of &#8220;monad&#8221; suitable for expressing the semantics of call-by-value languages with side effects.</p>", "authors": [{"name": "Jon G. Riecke", "author_profile_id": "81339524439", "affiliation": "AT&T Bell Laboratories, 600 Mountain Avenue, Murray Hill, NJ", "person_id": "PP39077809", "email_address": "", "orcid_id": ""}, {"name": "Ramesh Viswanathan", "author_profile_id": "81100159127", "affiliation": "Stanford University, Department of Computer Science, Stanford, CA", "person_id": "PP14065568", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199450", "year": "1995", "article_id": "199450", "conference": "POPL", "title": "Isolating side effects in sequential languages", "url": "http://dl.acm.org/citation.cfm?id=199450"}