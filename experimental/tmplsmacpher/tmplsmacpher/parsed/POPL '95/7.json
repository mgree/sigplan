{"article_publication_date": "01-25-1995", "fulltext": "\n Reasoning about Rings* E. Allen Emerson Kedar S. Namjoshi Department of Computer Sciences The University \nof Texas at Austin, U.S.A. Abstract The ring is a useful means of structuring concur\u00ad rent processes. \nProcesses communicate by passing a token in a fixed direction; the process that pos\u00ad sesses the token \nis allowed to make certain moves. Usually, correctness properties are expected to hold irrespective of \nthe size of the ring. We show that the problem of checking many useful correctness prop\u00ad erties for rings \nof cdl sizes can be reduced to check\u00ad ing them on a ring of small size. The results do not depend on \nthe processes being finite state. We illustrate our results on examples. Introduction Among the many \nmethods proposed for structur\u00ad ing systems made up of concurrently executing pro\u00ad cesses, the ring is \none of the most useful. In this model, communication between the processes takes place by means of a \ntoken which is circulated in a fixed direction, say clockwise, among the processes. Well known examples \ninclude protocols for mutu\u00ad ally exclusive access to a resource, leader election, scheduling, and the \ndining philosophers problem. All of these have two features in common : the in\u00ad dividual processes of \nthe ring are isomorphic (i.e the code of one can be transformed into that of an\u00ad other by a simple morphism, \nusually a renaming), and the desired correctness properties are expected to be satisfied by systems of \narbitrary size. The system can thus be considered as being parametri\u00ad zed by the number of processes. \nThe usual method *This work was supported in part by Texas Advanced Technology Program Grant 003658-250 \nand Semiconductor Research Corporation Contract 94-DP-388. The authors can be reached at emerson, kedar@cs. \nutexas. edu Permissionto y without fee all or part of this material is Y granted provided t at the copies \nare not made or distributed for direct commercial advantage, the ACM copyright notice and the title of \nthe publication and its date appear, and notice is given that copyi is by permission of the Association \nof Computing Machinery.Yo oopy otherwise, or to republish, requires a fee and/or specific permission. \nPOPL 951/95 San Francisco CA USA @ 1995 ACM 0-89791-692-1/95/0001....$3.50 of verifying that such a parameterized \nsystem satis\u00adfies a specification is by induction on the number of processes. This is tedious, and has \nto be done over again for each specific system. Our results show that, for any system comprised of many \nisomorphic processes organized in a ring which communicate through a token used as a sig\u00adnal, a property \nholds for an inst ante of the system with a small cutofl number of processes if and only if it holds \nfor every instance with a number of pro\u00adcesses greater than this cutoff. The correctness properties that \nwe consider are ex\u00adpressed by formulae in the branching time logic CTL* without the next-time operator \nX [BCG 88]. Let g; be such a formula in which every proposition is indexed by the variable i, and gij \nbe such a for\u00ad mula in which every proposition is indexed either by the variable i or by the variable \nj. 1 In particu\u00adlar, we consider correctness properties of the form Ai gi (every process satisfies gi) \nand Ai~j gij (every distinct pair of processes satisfies gij). Our specific results are as follows : \n1.Ai gi has a cutoff of 2. 2. Ai gi,i+l has a cutoff of 3. 3. Ai+j Adj, wheredj iS a formula without \npath quantifiers (i.e A or E), has a cutoff of 4. 4. Ai+jEdj, wheredj is a formula without path quantifiers, \nhas a cutoff of 6. 5. If &#38;yj gij is symmetric in a certain sense (de\u00adfined precisely later), then \nthe cutoff is 4.  The rotational symmetry of the ring plays an im\u00adportant role in the proofs of these \nresults. It allows us to reduce the check of a formula such as Ai g~, which ranges over all possible \nindices in an instance of the system, to that of a fixed index go. We then 1Thus the instances gl and \ng2 of the formula gt are iso\u00admorphic up to re-indexing, and similarly for gcj. establish the existence \nof a correspondence between the state transition graphs of an inst ante of the sys\u00adtem with n processes, \nand one with the number of processes equal to the cutoff. The correspondence established is for the projection \nof the state tran\u00adsition graph onto the particular process index, say O; the symmetry then allows us \nto establish the re\u00adquired result. The rest of the paper is organized as follows. Sec\u00adtion 2 defines \nthe notation and constructions we need. Section 3 cent ains proofs of the results. In section 4, we apply \nthese results to two example protocols. Section 5 concludes the paper with a discussion of related work \nand future extensions. 2 System Model Informally, the token passing model requires the fol\u00adlowing : Initially, \na process is chosen nondeterministi\u00adcally and given the token. At any time, only one process has the \ntoken. A process may have enabled transitions which do not depend on possession of the token. In this \ncase, the process is free to make such a transition when scheduled. The process may be blocked because \nall of its enabled transitions require possession of the token. If the process has the token, and has \nan en\u00adabled transition that requires possession of the token, it is free to make that transition. The \nprocess with the token must eventually transmit it in a clockwise direction. A labelled transition graph \n(or LTG) is a structure (Q, E, R, label, L, init) where E Q is a nonempty set of states. E Z is a transition(or \naction) alphabet. e R G Q x X x Q is the transition relation. E label : Q + L is a labelling function \non the states. E L is a nonempty set of labels. E init G Q is the unique start state. Formally, the \nindividual processes of a ring are con\u00adstructed from a template process Temp which is a LTG defined by \n(Local x B, XF U XT U {snd, rev}, R, Id, (Local x B), (start, ~azse)) where Local is a set of local \nstates, B = {true, fake} is the set of boolean values, Id is the identity function, and in\u00adtuitively, \nXF represents the free transitions and XT represents the disjoint token-dependent transitions. Let ZTe~P \n= Z T u EF. The behaviour described above induces certain constraints on R. For every (ql, bl) % (92, \nb2) 6 R, aEp+b1=2 1. b (A free transition cannot change possession.) 2. a E IIT + bl A b2 (A token dependent \ntransition can execute only if the process possesses the token.) 3. a = rcv + ~bl A b2 (A receive estab\u00adlishes \npossession of the token.) 4. a = snd + bl A ~b2 (A send removes possession of the token.)  R is total \nin the first component. (The process is nonterminating) rcv and snd actions alternate continually along \nevery path in Temp. (This is needed to ensure continuous circulation of the token.) 2 We assume that \nif (start, false) ~ (Q, b) E R then a = rcv and b = true. (The only possible initial action is a receive.) \n For an integer m > 0, we will represent the num\u00ad bers {O, ..., m 1} by [m]. An individual process Ki \n(i ~ [n]) in an instance of the system with n pro\u00ad cesses, is defined by K; = Temp[fi], where ~i is the \nrelabeling function fi = {rcv~/rcv, snd~+l /snd} U {~i/U : u G ZTemP}. The instance is defined by Ring~ \n= KO II KI [1 ... [1 Kn_I, where II de\u00ad notes parallel composition. All arithmetic in a ring of size \nn is done modulo n. Let M. denote the global transition graph of Ringn. M. is an LTG (Qn, &#38;, R~, \nId, Q~, init~) where e Q. = ({1} U [n]) x Q~~~P. For a state S = (i\\(go, be), (ql, bl), . . ..(gl. bnb1)))) \nE Qn) let ~irst(s) = i (intuitively, this is the process assigned the token initially), and for k G [n], \nlet Sk = (qk, bk ) be the state of process k in S. e initn = (L, (starto, false),..., (startn_l, $alse)). \n2We can think of the template as the result of the par\u00adallel execution of a lower-level token passing \nprocess and an upper level computational process. This gives rise to the alternation. E al = u {Sal.w}) \n ui~[n](~i E Rn= {initn nd% c t : (startk, false) % tk, first(t) = k, Vi+ k : t~ = (start~, faJse)}U \n{s 3 t : s, 3 t~, a~ C X~, first(s) = first(t), vi#k:si=fi}u {s ndg vk t: Sk 1 ~ t~ 1,Sk ~ tk, first(s) \n= first(t), Vi@ {k l,k} : s~ = t~} The Sndk .rcvk transition is a joint transition of processes k 1 \nand k which results in the synchronous transmission of the token. Let Cm represent the group of rotations \non a ring of size n. Let lvf~ denote the LTG induced on the set {initn} U {s : s G Aln, first(s) = i}. \nIntuitively, this is the set of states reachable from the initial state where process i is given the \ntoken initially. As the individual processes are formed from the same template, M: = T(M4 ), where n \nc C. is the per\u00admutation mapping j to i. We will make use of this symmetry in the proofs that follow. \nSyrn 1 is the full symmetry group on the index set 1 ~ N. For a formula ~ indexed over a set 1,Aut f={nGSym \nI:m(f) sf}. Auto f= Autgoo Autgl . . . nAtdgk, where go, gl, . . . . 9k are the maximal propositional \nsubformulae of f. We write M, s + f to mean that in LTG M, formula f holds at state s, as defined formally \nin the usual way [Em 90]. For an LTG M where the states are indexed by [n], Aut M is the group of permutations \nin Sym [n] that when applied to every state and transition of M, map M to itself. For groups C and D, \nwe write D < C to mean that D is a subgroup of C. 2.1 Projections on the global graph For a nonempty \nset of process indices 1 ~ [n], we de\u00adfine below the projection H of Mn onto 1 (denoted H = Mn 11). Intuitively, \nH focuses attentzon on the moves of processes in 1. This is done by replac\u00ading the actions performed \nby processes outside 1 by special r actions, thus erasing the original informa\u00adtion. His an LTG (QH, \nXH, RH, !abelH, LH, initH) where E QH = Q., and LH = ({1} U [n]) x Q~e.P, E ~H = {T} Uuier~i u {Sndk.rWk \n: kEIvk l EI} {s4t:3i=(i ~lVi-1~1), s n %  tE R.} E /abe~H((i, z)) = (i, zl~), where ZII is the pro\u00adjection \nof x onto the indices in I. E initH = initn If we show that H is bisimilar (up to stuttering of processes \nin 1) to some other projected graph H (formed by projecting onto 1), then the two graphs will satisfy \nthe same CTL* formulae which do not include the next-time operator X [BCG 88]. 2.2 Stuttering equivalence \nIn the projected graph H = Ml], since we erase information about actions of processes not in I, the label \non a state in H may not change during a finite sequence of T actions. Such sequences are called stuttering \nsequences, because there is no observable change during that computation. Formally,3 for an LTG (Q,.X, \nR, ZabeZ, L,init), for a E Xl, and s ~ Q, Stutter(s, a) c Q+. For a sequence of states p = P1, P2, . \n. . . pl of length J ~ 1, p E Stutter(s, a) iff 1. ifa#~, then l>l, 2. pl =s, 3. V i ~ [1,1 1] : label(p;) \n= label(s), 4. Vi E [1,1 2] :pi~p~+l, andp~-l%p~ if 1>1, 5. a # r or Zabel(pl) # Zabel(s) or unchanging, \nwhere unchanging(z) holds iff for every finite path from z, all states on the path have the same label \nas x, and all transitions are r tran\u00adsitions, implying that no further change is ob\u00adservable.  Let \nM and N be two LTG s. Then a relation R ~ M x N is a stuttering bisimulation iff init~ R initjv, and \nfor every pEQM, and qEQN, PR qimplies that 3This definition is similar to one presented in [BCG 88]. \nA related definition appears in [DV 90]. 1. labelM (p) = labelN(q) 2. For every action a G (ZM U ~~ \nU {~}), for ev\u00adery sequenceS c Stutter (p, a), there is a se\u00adquence T ~ Stutter(q, a), a partition S1; \nS2; ... Sk of S and a partition TI; Tz; ... Tk of T such that each Sj and Tj k finite and nonempty, \nand Vj c [l)k] : b s E S j, t ETj : sRt. 3. similar to (2), with roles of p and q exchanged.  Then \nstuttering equivalence is the greatest stutter\u00ading bisimulation. 3 Equivalences between large and small \nsystems 3.1 Properties of the form ~i gi We will need this refinement of a lemma in [ES 93]. Lemma O \nIf M is the global state transition graph of a system with n isomorphic processes, Cn < Aut M and the \nunique start state init~ is symmetric (i.e Aut init&#38; = Sym [n]), then, M, init~ + Ai gi iff M, init}f \n+ go. Proof ?Vf,~?LitM ~ 90 iff ( m is a permutation and the identity E Aut M ) Vi Vn:n SAUt MAn(0)=i: \nT(lvf), r(init~f) + g~to) iff ( 7r(M) = M as 7r G Aut M, ~(initM) = initM, as initfif is symmetric ) \nVi VT: nEAut MA~(0)=i: M,initJ4~9i iff ( predicate calculus ) di(%r: TEAut MA T(0)= i)+ kf, ~ndM ~ gi \niff ( by assumption ) v i : M, initM + gi iff ( by definition ) M, initM ~ Ai gi u Define H. and Hz by \nH. = M. Ifo} and Hz = M21{O} Lemma 1 H. and Hz are stuttering equivalent. Proof Sketch Let @ : [n] 4 \n[2] be a mapping defined so that 4(0) = O, and ~(k) = 1 for k # O. We show that R ~ H. x Hz defined as \n R = lJk~lnl{(p, q) : ZabelH. (P) = labelH. (q), ~(k) pEM; AqEM2 } is a stuttering bisimulation. o Theorem \n1 Let ~ = &#38;g; be a property where gi is a CTL* formula without X that refers only to propositions \nindexed by i. Then, Vn>2: Mn,init.+f iff M2, init2 +f. Proof For any n >2, M., init. 1= f iff ( the initial \nstate is symmetric, lemma O ) M., init. 1= go iff ( as go refers only to propositions indexed by O ) \nH., init. + go iff ( since Hn and Hz are stuttering equivalent by lemma 1, and go does not contain X \n) Hz, init2 ~ go iff ( as go refers only to propositions indexed by O ) M2, initz &#38; go iff ( by lemma \nO) M2, initz + f o  3.2 Properties of the form Ai gi,i+l Let f = Ai gi,i+l, where gi,i+l can refer to \nproposi\u00adtions indexed by i and i + 1. By a proof analogous to that for lemma O, we have Lemma 2 If M \nis the global state transition graph of a system with n isomorphic processes, C. ~ Aut M, and the unique \nstart state init&#38;r is symmetric, then, M, initM ~ Ai g,,i+l iff M, initM ~ go,l. Now we have to take \ninto account the various situa\u00adtions that process 1<0 and K1 can be in. Intuitively, either K. or K1 \ncan be given the token initially, or some other process could be assigned the token. This suggests that \na 3-process system maybe suffi\u00adcient. And in fact we have, Lemma 3 Let H. = M~[io,l] and H3 = M31{0,1}, \nwhere n > 3. Then Hn and H3 are stuttering equiv\u00adalent. Proof Sketch The proof is like that of lemma \n1. Define the map\u00adping ~ :[n] -+ [3] by 4(O) = O, ~(l) = 1, and ~(k) = 2 otherwise. We show that R ~ \nH. x H3 defined by ~) : labelHn (p) = labe/H, (q), Definitions  R= UkE[n]{(P) p G M; Aq C ~$(k)} is \na stuttering bisimulation. 1 Using this lemma, by an argument analogous to that for Theorem 1, we get \nTheorem 2 Let f = ~i gi,i+l be a property where gi,~+l is a CTL* formula without X. Then, dn >3: A4n, \ninit. + f iff M3, init3 1= f. 3.3 properties of the form ~i+j gij These are properties that involve distinct \npairs of processes. Mutual exclusion, for instance, can be written as ~igj AG(l(Crit icalj A Crit icalj \n) ). Lemma 4 Let M be the global state transition graph of a system with n isomorphic processes. If (Vi \nZlr CAut M: n(0) = i), and init~ is sym\u00admetric then, M, initJl ~ Aigj gij iff M, initM ~ Aj$o goj. Proof \nM, initM ~ Aj#o 9oj iff ( n is a permutation and the identity c Aut M ) Vi VT: nCAut MAr(0)=i: 7r(M), \nr(initM) ~ &#38;(j)#r(o) 9~(o)~(.i) iff ( n(M) = M as n E Aut M, ~(initM) = initM, as init~ is symmetric \n) ViVr: rCAut MAr(0)=i: M, initiw 1= A.(j)#i g~~(j) iff ( as n is a permutation ) ViVn: nEAut MAn(0)=i: \nM, initM ~ Ajgi gij iff ( predicate calculus ) Vi(3n :nEAut M AT(O)=i)9 M, initM ~ Ajgi gij iff ( by \nassumption ) Vi : M, initM ~ Aj+i gij iff ( by definition ) M, initM ~ Aigj gij o Note that this lemma \napplies to rings, as Aut M. = Cn, which satisfies the hypothesis. We will describe in detail the case \nin which the formulae are of the form Ai~j Agij, where gij is a formula without path quantifiers in which \nevery proposition is subscripted with either i or j. The same general idea can be used to prove the other \ncase (Ai#j Egij ) which is left to the full paper. Let [i : j]n denote the indices on the clockwise seg\u00adment \nfrom i to j on a ring of size n. Specifically, [i:j]n={i, i+l ,. ... j}, where addition is mod- U1O n. \nWe will usually write [i : j] when n is clear from the context. Also, let [i : j)~ = [i : j]~ {j}, (i: \nj]n = [i :j]~-{i}, and (i :j)~ = [i :j]~-{i, j}. Note that from the definition, (i : i)n = [i : i)~ = \n (i: i]n =0.  To prove the theorem, we will forma mapping ~ be\u00adtween an n process system and a 4 process \nsystem, consider pairs (Ko, Kj ) and (Ko, ~~ d(j) ), and show that their behaviors are similar. We will \nneed the following key lemma : Lemma 5 Let @ be defined by 4(O) = O, ~(l) = 1, ~(n 1) =3, and ~(j) = \n2 for j c [2 : n 2]n. For every n ~4, j C[l, n 1], M~, initn ~ gojKfM], initA ~ god(j).  b, ~.-/ / , \n+: : .... /n-1 [ - I 1 I A nI 2 <-------- 0 v 3 FIG 1: The mapping@: [n] ~ [4] Proof Sketch We form \nthe projections IUS Ilo,j] of M: onto the set of process indices {O, j}, and Ml I{O,@(j)}@ of onto the \nset {O, @(j) }. These projections are the behaviors of the pairs of processes (Ko, ~fj ) and We then \nshow that M; I{o,j] and Ml ]io,o(jll are stuttering equivalent, which implies the statement of the lemma. \nThe appendix contains the details of the proof. (~fO,~~#(j)). o We now state a consequence of Lemma 5: \nLemma 6 Let goj be any branching time formula without X. Then for n ~ 4, M;, init. + Aj+o mj iff J@ , \nin~th 1= Aj$ogo Proof M:, init. 1=Ai+o goj iff ( by definition and Lemma 5 ) i@, init4 1= Ajc[l,~-llmo(~) \nM ( expanding the conjunct, idempotency of A ) M], init4 1= Ajc[l,31 goj iff ( by definition ) A@, init4 \n> Aj+ogoj 1 We can use this lemma for two theorems with dif\u00adferent applicability. Theorem 3 Let f = Aigj \nAgij, where g~j is a CTL* formula without path quantifiers and X. Then, Vn >4: Mn, initn * f iff i vla,initA \n~ f. Proof The idea of the proof is to first show that for any n > 2 and any formula h without path \nquanti\u00adfiers such that Cn < Aut h, M., initn ~ Ah iff itl~, init. ~ Ah. M., initn ~ Ah iff ( by definition \n) 3 afullpath a in &#38;fn : a ~ h iff ( the M: s cover all paths in A4n ) 3k,andafullpath cinM: :n# \nh iff(as Aut Mn=Cn) 3 n c c., afullpath u in M: : a &#38; n(h) iff(as Cn~Auth, r(h)~h) 3 afullpath a \nin M: : a ~ h iff ( by definition ) M~, init. &#38;Ah The rest of the proof follows : (We use the fact \nthat Aj$o@~ E AAj+~gij) Foranyn ? 4, M., init. + Aigl Ag~j iff (by lemma 4 ) M., init. 1= Aj$O 40~ iff \n( by the fact above and the previous argument ) M:, init. 1= Aj#O AgO~ iff (by lemma 6) i@, init4 1= \n&#38;#O AgO~ iff ( by the fact above and the previous argument ) itf4, init4 \\ &#38;#O Ago~ iff (by lemma \n4 ) M4, init4 ~ A,+j&#38;j o As a particular case, the mutual exclusion formula f = Ai#j AG~(CriticaliACriticali \n) can be checked in a 4-process system. Theorem 4 Let f = Aigj g,j be a CTL* formula without X for which \nthere is an equivalent C TL formula f such that C. s Auto f . Then, Vn~ 4: Mn,initn ~ f iff M4, init4 \n\\ f. Proof Sketch From the results in [ES 93, CFJ 93], M., init. ~ f iff Mn/(Aut M. n Auto f ), init. \n~ f . As Aut M. = Cn, and Cn ~ Auto f , Mn/(Aut Mn fl Auto f ) = M:. As f : f , using lemma 5, the theorem \nfollows from the arguments in support of Theorem 3. Note that in this case, we do not require that gij \nhave no path quantifiers in it. o The proof for the case where formulae are of the form Aigj Egij, with \ngij a linear-time formula, is analogous. The difficulty here is that checking just M: is not enough, \nas is shown by the formula Ai+j E(_+okeni U tokenj), which expresses the proP\u00aderty for every pair (i, \nj) of processes, there is a computation where process j gets the token initially before process i . This \nis obviously true in the en\u00adtire graph Mn, but certainly false when we restrict attention to M:, where \nby definition, process O gets the token first. Since we have to check M: for every k, we cannot define \na mapping ~ that is independent of k, as the behaviour of a particular process differs based on which \nprocess starts out with the token. So we must define a set of mappings ~k, and consider a slightly bigger \nsystem, one with 6 processes. We use analogues of lemmas 5 and 6 to show the following theorem : Theorem \n5 Let f = &#38;gj Eg%j be a CTL* formula without path quantifiers and X. Then, Vn>6: Mn, init. &#38;f \niff M6, init6 ~ f. Proof Sketch The mappings used in the proof of Theorem 5 are given below: For k c \n[n], the mapping ~k : [n] -+ [6], and is given by 1. $+k(0) = O, f#k(l) = l,~k(n 1) = 5, for all ke \n[n]. $2. if k c {0,1,2, n 2,n 1} then fbk(2) = 2, 4k(n-2) =4, and4$k(j) =3 forj E[3:n-3] 3. if k @ {0,1,2, \nn 2, n 1} then @k(k) = 3, d~(j) = 2fOr j E [2 :k), and ~k(j) = 4for j<(k:n 2] The proof is analogous \nto that for Theorem 3. De-E Every process performs ai and bi alternately. tails are left to the full \npaper. o Applications To illustrate the use of our results, we look at two protocols, the distributed \nmutual exclusion proto\u00ad col in [WL 89] and (a slight variation on) Milner s scheduler example [Mil 90]. \nBoth are specified by CCS expressions. 4.1 Distributed Mutual Exclusion The protocol in [WL 89] is given \nbelow as a set of process equations. SO= rcv.Sl; S1 = c.S2 + c.S4; S2 = SCS.S3; S3 = ecs.S4; S4 = snd.SO \nInitially, every process is in state SO. Here c is used to indicate a local action. It is easily checked \nthat the process description satisfies the restrictions. So properties like E If a process requests the \ntoken, it will receive it. A; AG(SO~ s AF(Sl~)) E Every trying process eventually enters its crit\u00adical \nsection &#38; AG(SOi a A17(S4i V S2i)) can be checked using a 2-process system by theorem 1. Mutual exclusion, \ni.e Aigj AG-1(5 3i A Szj ) can be checked in a 4-process system by Theorem 3. 4.2 Milner s scheduler \nSO = a.Sl; S1 = snd.S2; S2 = b.S3 + rcv.S4; S3 = rcv.SO; S4 = b.SO. The initial state is S3. The correctness \nproperties are E Along every computation, ao, al . . . an-1 must be performed cyclically, starting with \nwhichever process is enabled first. Introduce an auxiliary variable doing. which is true only for the \ndu\u00adration of action a. Then the following formula implies the cyclic order, and the conjuncts can be \nchecked independently in 3 and 4-process systems by Theorems 2 and 3 respectively. A, AG(doingai * AFdoing~,+,) \nII Ai~j AG(~(doing~, A doingaj)) Introduce auxiliary variables started and stop\u00adped which are mutually \nexclusive for actions a and b. Then the following formula expresses this property and can be checked \nin a 2-process system by Theorem 1. A, AG(starteda, w -wtarted~, U stoppeda,) A AG(stoppeda, ~ ?starteda, \nU startedb,) A AG(startedb, +- Tstarteda, U $toppedb,) A AG(stoppedb, ~ Tstartedb, U started., ) 5 Conclusions \nand related work Among related work, [AK 86, Su 88] show that the problem of automatically checking a \nspecification for every instance of a parameterized system is in general undecidable. Positive results \ninclude those of Clarke, Grumberg and Browne [CG 87], [Br 89], [BCG 89] who develop the idea of projections \non the global state space. Their method requires the construction of a closure process which represents \ncomputations of an arbitrary number of processes. [KM 89] and [WL 89] introduce the related notion of \na process invariant. All these methods rely on human ingenuity to manually construct a suitable process \nclosure or invariant. [GS 92] use automata\u00adtheoretic methods to construct process closures (pro\u00advided \nthat the component processes of a system are exactly identical and finite-state), and use them to establish \nsingle index properties. Multi-index prop\u00aderties can be indirectly catered for, but the com\u00ad plexity \nthen becomes multi-exponential. The closest results are those of Shtadler and Grum\u00adberg [ShG 89], who \nuse a network grammar to spec\u00adify a communication topology, and those of [Lsl 94, LSY 92] which deal \nwith ring networks of Petri nets. [ShG 89] show that if certain sufficient conditions are satisfied, \nevery network generated by the gram\u00admar will satisfy specifications written in linear-time temporal logic. \nHowever, the sufficiency check can require time exponential in the size of an individ\u00adual process. The \npapers [LSY 94, LSY 92] cent ain another (exponential-time) sufficiency test which is used to show that \ncertain parameterized protocols on rings satisfy a single-index linear-time specifica\u00adtion. The advantage \nof our approach is that to check whether, for all n, a ring comprised of n isomorphic processes satisfies \na specification, it is both neces\u00adsary and sufficient to check only the small rings of size less than \nor equal to the cutoff. This result is independent of the actual program executing on each process in \nthe ring, provided that it follows the token-passing discipline. The ring of size equal to the cutoff \nis analogous to a closure process, but is trivial to construct. In addition, the result holds even if \nthe transition graph of the template process is not finite. If it is finite, then an automated tool such \nas the Con\u00adcurrency Workbench [CPS 89, C 93, CH 93] can be used to model check the desired property for \nthe small ring [CE 81]. This check can be done in time polynomial in the size of a process. We are cur\u00adrently \ninvestigating the extension of these results to tokens which carry values, and to systems with to\u00adkens \nand signals [D 85]. The techniques used here are also likely to be applicable to logical star net\u00adworks \nwhich model client-server interactions. The main requirement seems to be that of homogeneity a process \nview is the same wherever it is in the network. Acknowledgements We would like to thank the anonymous \nreferees and the students in the Tempo\u00adral Reasoning seminar at Texas, especially Markus Kaltenbach, \nfor helpful comments on a preliminary draft. A Appendix Lemma 5 Let @ be defined by 4(O) = O, ~(l) = \n1, @(n 1) =3, and ~(j) =2 forj s [2 :n 2]n. For every n~ 4,j c [l)n 1], ~~~, inifJfn ~ gOj iff ~], initJf. \n> gO@(j). Proof When defining a candidate bisimulation, we have to ensure that the position of the token \nat any step is consistent with the definition of ~. To do this, let token(p, g, j) be the conjunction \nof 1.tok(p) = o : tok(q) == o 2. tok(p) E (o:j)n = tok(q) c (o:#(j))4 3. tok(p) = j E tok(q) = +(j) \n 4. tok(p) E (j : O)n= tok(q) E (#(j) : 0)4  where tok(x) is the index of the process which pos\u00adsesses \nthe token in global state x, i.e the unique i G [n] for which z; = (q, true), for some q E Q, and is \nundefined for x = initn. For each j, let Hi = ~~l{o,j}, ~~ = ~~l{o,#(j)}J and define R] s H; xHj by Rj={(p, \nq) : label~i (p) = label~i (q) A token(p, q,j)} U{(initHi, initHi)} We will show that RI is a stuttering \nbisimulation. The lemma then follows. Let C: represent a finite sequence of states of Hi such that for \nevery state c in the sequence, label~i (c) = label~i (p), and tok(c) = i. Let D: represent a finite sequence \nof states of Hi such that for every state d in the sequence, label~i (d) = label~i (q), and tok(d) = \ni. Let pRjq. If (p, q) = (init~i, init~i ), then as the token is always given to process 1<0, and all \nother processes are in the same local state, the next states are in Rj. Otherwise, 1. Suppose there is \na stuttering sequence S from P. If the final transition of S is a local transition a E Z. UZj, then there \nis a sequence T = q; q , where q ~ q which matches S. This is be\u00ad cause as label~, (p) = label~, (q), \nq can be chosen such th~t label~~ (p ) 4= label~i (q ), and the conjunct of token (p, q, j) that is sat\u00ad \nisfied remains true. Otherwise, the transition must be a synchronization. (a) tok(~)= O : AS (P, q) c \nRjj tok(q) = O. K. and Iil synchronize to produce the new state p . So the sequence S can be written \nas C&#38; ; p . If j = 1,then as~(j) = 1,there isa sequence T = q; q where 1<0 and 1<~($) synchronize \nin the 4-system. As (p , q ) is also in RJ, S and T match. If j # 1, then I<j s state is unchanged in \np . As +(j) # 1, there is a matching sequence T = q; q from q where 1<0 syn\u00adchronizes with Jil, I<@(j) \ndoes not change state and (p , q ) 6 Rj. (b) tok(p) E (O : j)n : Then tok(q) ~ (O : #(j))A. So S has \nthe form C~Ok(P); C~Ok[P)+l ; . . . . Cf_l; @ The state change at the end of S is only of process I<j. \nFrom the clockwise movement of the to\u00adken, it follows that there is a matching sequence T of the form \nDq ,Ok(q); %k(q)+,; . . . . Dq~(j) ..l ;q , where the state change in q is of process ~(j). As (p , q \n) E Rj, and the block of C s matches the block of D s, S and T match. (c) tok(p) = j : Then tok(q) = \n~(j). If j = n 1, then K. and I<j synchronize, so S isof theform Cj ;p . As~(n 1)=3, there is a matching \nsequence T from q, where T is of the form q;q . If j # n 1, then only process Kj changes state, by a \nsynchronization with its neighbour, and so S is of the form C;; p , and as ~(j) # 3, there is a matching \nsequence T from q of the form q; q . (d) tok(p) $ (j :O)n : Here S isof the  form C ~ok(P);C~Ok(P)+l; \n. . ,; C~_l; p , and the state change at the end of the se\u00adquence is only of process KO. As (p, g) c \nR~~ tok(9) C (~(j), 0)4. From the clock\u00adwise movement of the token, there is a matching sequence T from \nq of the form D~Ok(g); D~Ok(g)+l; . . .; D:; q , where the state change in q is only of process Ko(o). \nAs (p , q ) E Rj, and the block of C s matches the block of D s, S and T match. 2. Suppose there is \na stuttering sequence T from 9. If the final transition of T is a local transition a E 220 U E+(j), then \nthere is a sequence S = P; P , where p % p which matches T. This is because as label~i (p) = label~i \n(q), p can be chosen such that label~i (p ) = labei~j (q ), and the conjunct of token(p, q, j) that is \nsat\u00ad isfied remains true. Otherwise, the transition must be a synchronization. (a) ~0~(~) = O : AS (P, \nq) G Rj, ~o~(P) = O. KO and K1 synchronize, and change state together. Thus T has the form D;; q . If \n~(j) = 1, then j must be 1, and K. and Kj synchronize in the N-system. As p and q have the same label, \np and q will have the same label, and the sequence S = p; p matches T. If #(j) # 1, then the state of \nK~Ij) re\u00admains unchanged in q . As j # 1, there is a sequence S = p; p which matches T, in which K. synchronizes \nwith Kl, and Kj does not change state. (b) tok(q) E (O : d(j))A : The state change at the end of the \nsequence from q is only of process K@(j). So T must have the form D~Ok(~); . . .; D&#38;j)_l; q , where \nlabel(q ) differs from /abe/(q) only in component Kd(j). Then as (P, q) c Rj, tolc(p) G (O : (c) (d) \n  o References [AK 86] [BCG 88] [BCG 89] [Br 89] j)., and there is a sequence S from p of the form \nC~Ok(P);C~Ok(P)+l;. . . ;C~_l;p , where /abe/(p) and label(p ) differ only in component Kj, and intermediate \nstates are related. tok(q) = d(j) : Then tok(p) = j, If ~(j) = 3, then KO and 1<3 synchronize, so T has \nthe form D:; q , where tok(q ) = O. Asj must ben 1,there isase\u00adquence T = p; p from p which matches S. \nIf ~(j) # 3, then only process K4(j) changes state, by a synchronization with its neighbour. So T has \nthe form D&#38;j) ;q , where tok(q ) = #(j) + 1. Then asj # n 1, there is a sequence S = p; p that matches \nT. tok(q) E (d(j) : 0)4 : The state change at the end of the sequence must be only that of K.. So T must \nhave the form Dfok(q); DjOk(q)+l; . . . . D:; q , where label(q ) differs from label(q) only in com\u00adponent \nKO. As (p, q) E Rj, tok(p) c (j : 0)~. So there is a sequence S of the form ~ C~Ok(p)+l; . . . . C~_l; \np , where c:.k(~) ~ /abe/(p) and label(p ) differ only in com\u00adponent K., and intermediate states are \nrelated. Apt, K., Kozen, D. Limits for auto\u00admatic verification of finite-st ate concur\u00adrent systems. \nIPL 15, pp. 307-309. Browne, M. C., Clarke, E. M., Grum\u00adberg, O. Characterizing Finite Kripke Structures \nin Propositional Temporal Logic, Theor. Comp. Sci., vol. 59, pp. 115-131, 1988. Browne, M. C., Clarke, \nE, M., Grum\u00adberg, O. Reasoning about Networks with Many Identical Finite State Pro\u00adcesses, Information \nand Computation, vol. 81, no. 1, pp. 13 31, April 1989. Browne, M. Automatic Verification of Finite State \nMachines using Tempo\u00adral Logic. PhD thesis, Carnegie-Mellon Univ., CMU-CS-89-117. [c 93] [cc 77] [CE \n81] [CES 86] [CFJ 93] [CG 87] [CH 93] [CPS 89] [D 85] [DV 90] Cleveland, R. Analyzing Concurrent Systems \nusing the Concurrency Work\u00adbench. Functional Programming, Con\u00adcurrency, Simulation, and Automated Reasoning, \nSpringer-Verlag LNCS 693. Cousot, P., Cousot, R. Abstract In\u00adterpretation : a unified lattice model for \nstatic analysis of programs by con\u00adstruction or approximate ion of fixpoints, POPL 1977, pp. 238-252. \nClarke, E. M., Emerson, E. A. Design and Synthesis of Synchronization Skele\u00adtons using Branching Time \nTemporal Logic. in Workshop on Logics of Pro\u00adgrams, Springer-Verlag LNCS 131. Clarke, E. M., Emerson, \nE. A., and Sistla, A. P., Automatic Verification of Finite-State Concurrent Systems us\u00ading Temporal Logic, \nACM Trans. Prog. Lang. and Sys., vol. 8, no. 2, pp. 244\u00ad263, April 1986. Clarke, E. M., Filkorn, T., \nJha, S. Ex\u00adploiting Symmetry in Temporal Logic Model Checking, 5th CAV, Springer-Verlag LNCS 697. Clarke, \nE. M., Grumberg, O. Avoiding the State Explosion Problem in Tempo\u00adral Logic Model Checking Algorithms, \nPODC 1987. Cleaveland, R., Hennessy, M. Testing Equivalence as a Bisimulation Equiv\u00adalence. Formal Aspects \nof Computing, vol. 5, 1993. Cleaveland, R., Parrow, J., Stef\u00adfen, B. The Concurrency Workbench. In J \n.Sifakis (cd), Automatic Verifica\u00ad tion Methods for Finite State Systems, Springer-Verlag, LNCS 407. \nDijkstra, E. W. Invariance and non\u00addeterminacy. in Mathematical Logm and Programming Languagesj Prentice-Hall \nInternational Series in Computer Science. eds. C.A.R Hoare and J.C Shepherdson. De Nicola, R., Vaandrager, \nF. Three logics for Branching Bisimulation, 5th Annual IEEE Symp. on Logic in Com\u00adputer Science, pp. \n118-129, 1990. [Em 90] [ES 93] [GS 92] [KM 89] [LSY 94] [LSY 92] [Mil 90] [ShG 89] [Su 88] [WL 89] \nEmerson, E. A., Temporal and Modal Logic, in Handbook of Theoretical Computer Science, (J. van Leeuwen, \ncd.), Elsevier/North-Holland, 1991. Emerson, E. A., Sistla, A. P. Sym\u00ad metry and Model Checking, 5th \nCAV, Springer-Verlag LNCS 697. German, S. M., Sistla, A. P. Reasoning about Systems with Many Processes. \nJ.ACM, Vol. 39, Number 3, July 1992. Kurshan, R. P., McMillan, K. A Struc\u00ad tural Induction Theorem for \nProcesses, PODC 1989. Li, J., Suzuki, I., Yamashita, M. A New Structural Induction Theorem for Rings \nof Temporal Petri Nets. IEEE Trans. Soft. Engg., vol. 20, No. 2, February 1994. Li, J., Suzuki, I., Yamashita, \nM. Tem\u00adporal Petri Nets and structural induc\u00adt ion for rings of processes. Proceed\u00adings 35th Midwest \nSymp. Circuits Syst. 1992. pp. 377-380. (final version to ap\u00adpear in Theoretical Computer Science) Milner, \nR. Communication and Con\u00adcurrency, Prentice-Hall International Series in Computer Science. ed. C.A.R \nHoare. Shtadler, Z., Grumberg, O. Net\u00adwork Grammars, Communication Be\u00adhaviors and Automatic Verification. \nIn J. Sifakis (cd), Automatic Verifica\u00adtion Methods for Finite State Systems, Springer-Verlag, LNCS 407. \nSuzuki, I. Proving properties of a ring of finite state machines. IPL 28, pp. 213-214. Wolper, P., Lovinfosse, \nV. Verifying Properties of Large Sets of Processes wit h Network Invariants. In J. Sifakis (cd), Automatic \nVerification Methods for Finite State Systems, Springer-Verlag, LNCS 407.  \n\t\t\t", "proc_id": "199448", "abstract": "<p>The ring is a useful means of structuring concurrent processes. Processes communicate by passing a token in a fixed direction; the process that possesses the token is allowed to make certain moves. Usually, correctness properties are expected to hold irrespective of the size of the ring. We show that the problem of checking many useful correctness properties for rings of <italic>all</italic> sizes can be reduced to checking them on a ring of small size. The results do not depend on the processes being finite state. We illustrate our results on examples.</p>", "authors": [{"name": "E. Allen Emerson", "author_profile_id": "81452614401", "affiliation": "Department of Computer Sciences, The University of Texas at Austin", "person_id": "PP39055545", "email_address": "", "orcid_id": ""}, {"name": "Kedar S. Namjoshi", "author_profile_id": "81100258126", "affiliation": "Department of Computer Sciences, The University of Texas at Austin", "person_id": "P158699", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199468", "year": "1995", "article_id": "199468", "conference": "POPL", "title": "Reasoning about rings", "url": "http://dl.acm.org/citation.cfm?id=199468"}