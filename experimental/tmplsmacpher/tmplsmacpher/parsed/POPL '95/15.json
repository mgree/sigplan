{"article_publication_date": "01-25-1995", "fulltext": "\n Lower bounds on type inference with subtypes My Hoang* and John C. Mitchell* Computer Science Department \nStanford University Stanford, CA 94305 {hoang, mitchell}@cs .stanford. edu Abstract We investigate type \ninference for programming languages with subtypes. As described in previous work, there are several type \ninference problems for anygiven expression lan\u00adguage, depending on the form of the subtype partial order \nandtheability todefine newsubtypes in programs. Our first main result is that foranyspecific subtype \npartial order, the problem of determining whether alambda term is typable is algorithmically (polynomial-time) \nequivalent to a form of satisfiability problem over thesame partial order. This gives the first exact \ncharacterization of the problem that is in\u00addependent of the syntax of expressions. In addition, since \nthis form of satisfiability problem is l%p,4CE-hard over cer\u00adtain partial orders, this equivalence strengthens \nthe previous lower bound of iw -hard to pspAcE-hard. Our second main result is a lower bound on the length \nof most general types when the subtype hierarchy may change as a result of addi\u00adtional type declarations \nwithin the program. More specifi\u00adcally, given any input expression, a type inference algorithm tries \nto find a most general (or prtncipal) typing. The prop\u00ad erty of a most general typing is that it has \nall other possible typings as instances. However, there are several sound no\u00ad tions of instance in the \npresence of subtyping. Our lower bound is that no sound definition of instance would allow the set of \nadditional subtyping hypotheses about a term to grow less than linearly in the size of the term. 1 Introduction \n Subtyping is a basic feature of typed object-oriented lan\u00adguages. The main importance of subtyping is \nthat it allows substitutivity: if A is a subtype of B, then elements of type A can be used anywhere that \nan element of type 1? is required. Among the many implications for statically\u00adtyped languages, this allows \ndata structures such as hetero\u00adgeneous lists, where elements of the list come from arbitrary subtypes \nof some given type. This paper studies the prob\u00adlem of type inference in the presence of subtyping. Type \ninference, used in languages such a. ML [GM W79, Mi185], Supported in part by NSF Grant CCR-9303099 and \nthe TRW Foundation. Permission to copy without fee aii or part of this material is granted provided that \nthe cqoiea are not made or distributed for direct commercial advantage, the ACM copyrtght notice and \nthe titie of the publication and its date appear, and notice is given that copyi is by permission of \nthe Association of Computing Machinery. Y o copy othetwise, or to republish, require-s a fee ancUor specific \npermission. POPL 951/95 San Francisco CA USA @ 1995 ACM 0-89791-692-1/95/0001 ....$3.50 Haskell [HF92, \nH+ 92] and Miranda [Tur85], is the process of inferring type information that has been omitted from ex\u00adpressions. \nType inference allows type errors to be detected at compile time, without forcing programmers to include \ntype annotations in programs. Although an algorithm for type inference with subtyping was published in \n1984 [Mit84, Mit91b], this algorithm has seen little if any practical use. Apart from the fact that lan\u00ad \nguages which could take advantage of this algorithm are only now emerging, the main problems seem to \nbe that the algo\u00ad rithm is inefficient and the output, even for relatively simple input expressions, \nappears excessively long and cumbersome to read. Some attempts to make the algorithm more prac\u00adtical \nappear in [FM89, FM90]; some studies of the inherent difficulty of the problem are [W089, LM92, Tiu92, \nBen94]. The previous studies show that some simplifications can be made to the output of the algorithm, \nthe problem is at least i-w-hard in the general case (even assuming that the ba\u00adsic operations that occur \nin programs have relatively sim\u00adple types) but some special cases could be solved more effi\u00adciently. \nOur first main result is the algorithmic equivalence be\u00adtween typability with subtyping and a satisfiability \nproblem over partial orders. In particular, for any subtype partial order, deciding whether an expression \nhes any typing at all is equivalent to determining whether a form of satisfiabil\u00adity problem is solvable \nover this partial order. This gives us a characterization of the decision problem for typing in the presence \nof subtypes that is independent of the syntax of expressions. One reason why this is important is that, \nwhen considering programming languages with particular restrictions on the subtype partial order, we \ncan focus on the satisfiability problem and rest assured that any satisfi\u00adability problem could arise \nin practice. Since this particu\u00adlar satisfiability problem over partial orders has been shown PsF i%cE-hard, \nover partial orders in general or certain fixed partial orders, our equivalence also strengthens the \nbest pre\u00advious lower bound of m-hard to pspACE-hard. As noted in [LM92] the naive upper bound is exponential \ntime. Our equivalence between typability and partial order sat\u00adisfiability holds even with very restricted \nassumptions about the types of basic symbols that appear in program expres\u00adsions. More specifically, \nit is shown in [LM92] that it is iw-hard to decide whether a lambda term hss a type even if all term \nconstants are restricted to having only atomic types. This is done by showing how the satisfaction of \nin\u00adequalities of the form b < t,s < t over a partial order can be represented as typability of terms \nusing constants only of atomic type. (We use b for an element of the partial or\u00adder of types and s and \nt for type variables.) In this paper, we show how arbitrary inequalities of the form s < t+ u and s> \nt+ u also arise in typing lambda terms using only constants of atomic types. Using earlier results on \nthe com\u00adplexity of the satisfaction of subtype inequalities [Tiu92], we can use this equivalence to show \nthat the typability problem is I?3p,4CE-hard, even when all constants in expressions have only atomic \ntypes. Our equivalence clearly implies that the only way to de\u00advise a practical, polynomial-time type \ninference algorithm in the presence of subtyping is to restrict the programming lan\u00adguage so that only \ncertain forms of subtype partial orders are definable. This is in fact reasonable since, for example, \nsin\u00adgle inheritance always results in forests of trees. In [Ben94], it is claimed that the satisfiability \nproblem is solvable in polynomial time for this case. Therefore, if most programs use only single inheritance, \nwe might expect polynomial\u00adtime behavior in practice. However, a practical type infer\u00adence algorithm \nmust print more than a simple yes/no answer in response to an input language expression. This is partic\u00adularly \nimportant when a program may declare additional types and subtypes. Since a function declared at the \ntop of the program may be called in several different lower con\u00adtexts, the initial type-checking of the \nfunction must tell the programmer which uses of the function will be type correct and which will be erroneous. \nOtherwise, it will be very dif\u00adficult to determine, when the type checker rejects a later application \nof this function, whether the problem lies in the function declaration or its use. Unfortunately, an \nefficient satisfiability algorithm for special partial orders still does not help us optimize the output \nof a type inference algo\u00adrithm. Given any input expression, a type inference algorithm tries to find \na most general (or principal) typing. The prop\u00aderty of a most general typing is that it has all other \npossible typings as instances. Without subtyping, instance boils down to substitution instance. A consequence \nis that the most general typing of any given expression is also the syn\u00adtactically shortest, since no \nsubstitution can decrease the size of an expression. However, with subtyping, instance involves both \nsubstitution and entailment of subtyping hy\u00adpotheses. Since substitution can render a set of subtyping \nhypotheses tautologous, a most general typing that involves any subtyping hypotheses about type variables \nwill never be the shortest typing for the expression. Given a fixed notion of instance, there maybe most \ngen\u00aderal typings of different lengths. In [FM89, FM90], an at\u00adtempt is made to optimize the algorithm \nfrom [Mit84] so that the shortest most general typing is produced. How\u00adever, simple examples given in \nSection 5 of the present pa\u00adper show that this is not the best one can do. Specifically, by adopting \na more powerful notion of instance than used in previous studies, we can reduce the length of the shortest \nmost general type. In fact, for some expressions, we can eliminate subtyping hypotheses altogether from \ntheir most general types. If we were able to do this for all expressions, this would dramatically simplify \nthe output of the type infer\u00adence algorithm. However, we show that no sound definition of instance would \nallow the set of additional subtyping hy\u00adpotheses about a term to grow less than linearly in the size \nof the term. The rest of the paper is organized as follows. In Sec\u00adtion 2, we define the type system \nincorporating subtyping. Besides establishing notation, this allows us to define the decision problems \nof typability and subtype inequality sat\u00adis fiability. Section 3 and Section 4 are devoted to proving \nthe polynomial-time equivalence of these two decision prob\u00ad lems. In Section 5, we investigate the size \nof most general typings of terms with respect to any sensible definition of instance. Finally, we end \nwith some directions for future work in Section 6. 2 Preliminaries We study a type system for typing \nuntyped lambda terms, possibly containing constant symbols. The set of untyped lambda-terms are generated \nby the following grammar where x may be any variable and c a constant symbol. The types of lambda terms \nare formed using type vari\u00adables and type constants. Let 1? be a set of base types (id, bool, . ..). \nThen the set of types over 1? is generated by the following grammar u ::=bltla +o where tis a type variable \nand b c B, We let Type~ be the set of types over B with no type variables. These are also called the \nset of ground types over B. Given a set of base types B, a subtype assertion or con\u00adtainment is a formula \nof the form o < ~, where a, ~ are types over B. A subtype assertion u ~ r is said to be atomic if u and \n7 are either type variables or base types. Let <EI be a partial order on B. Intuitively, this order\u00ading \nindicates the subtype ordering on base types in B. Let C be a set of subtype assertions. The following \nproof sys\u00adtem defines the relation C 1-u * r which can be read, o is a subtype of ~ under the ad~ltional \nsubtype assump\u00adtions of C . If C, C are sets of subtype assertions, we use C R Cl to denote that C E \no < r for every subtype assertion u ~ r E C . (asmp) (Wj) CI-U-JO CF015U2 ckff2~U3 (trans) ct-u15u3 CFU25UI \nCFT15T2 (+) ckc71+T15U24T2 Given a partial order (B, <B ) on a set of base types B, we define the partial \norder ~ B on the set of types over B, aso+ 7iff ~+o ~ T. we call therelation ~B the subt ypzng relation \ninduced by <B. This is the subtyping relation without additional subtyping hypotheses. We are now ready \nto define the problem of satisfaction of subtype inequalities. A system of inequalities over a partial \norder B = (B, +) is a finite set of formulas of the form al <02, where al and U2 are types over B, Let \nV be the set of type variables that appear in a system of inequalities, T. We say that Z is satisfiable \nin the partial order B if there is a substitution q: V + TypeB such that P(U1 ) SB y4az) for every inequality \nal < Im in Z. We then have the following decision problems for satisfiability of subtype inequalities \n(abbreviated SS1): The difference between the two problems is that in (SS1), a problem instance is a \npair (B, T), while an instance of ( Z3-SS1) is a set Z of inequalities to be satisfied over the fixed \npartial order B. In other words, there is a problem ( B-SSI) for each partial order B. (SS1) Given a \nfinite partial order B and a system Z of The difference between the two problems is that in (TIS), a \ninequalities, is T satisfiable in B ? problem inst ante is a pair (X, M) , while an instance of (E- TIS) \nis a typability problem over the fixed signature E. In (f3-SSI) Given a system Z of inequalities, is \nZ satisfiable other words, there is a problem ( X -TIS) for each signature in a fixed partial order B \n? E. To be able to type lambda terms, we need to know types for the term constants. And, to incorporate \nsubtyping, we also need to know the subtype ordering on base types. A signature ~ = (~, <B, T) consists \nof a Set ~ of base types, a partial order <B on B, and a set T of pairs of the form (c, u) with c a term \nconstant and u 6 TypeB. A typing ~udgement is a formula C, r D M: u where C is a set of atomic subtype \nassertions and r is a set of assumptions of the form z: a, with x a variable. Intuitively, the context \nr represents the type declarations of the free variables used in a program and the coerczon set C reflects \nthe additional subtyping declarations that may appear in a program. The following proof system is used \nto identify the set of well\u00adtyped terms. (var) C,r DX:u ifz:acr (const) c,r~c:u if (c, a) c T C,r[z:a]DM:7 \n(abs) rD~x.IM:u+T C, I DM:O-+T c,rb N:o (app) Cj17bfkfiV:r C ,17DiVf:o (subtp) if Cku~r C,rDkf:T In \nthe (abs) rule, we use r [z: o] to denote the context given by r[z:a] = (r {%:7}) u {z:o-} if z:~ e \nr, and r [z: a] = r u {z: a}, otherwise. We call the above proof system ST< , for simply-typed J-calculus \nwith subtyping. We use Z ~sT < C, r~ M: CTto denote that the typing judge\u00adment C, r D ~ o is derivable \nover signature X. The reason for including a set C of containment not given by the sig\u00adnature, and allowing \ntype variables, is to represent sets of possible typings. For example, if a signature has int s real \nand char ~ string, then typing s ~ t, 1#1B ~x. x: s -+ twill have both Ax. x: int + real and Ax. x: char \n+ string as in\u00adstances, according to the definition we give in Section 5. We say that a term M is typable \nor well-typed (over a given signature X ) if there exists a context r and type a such that ~ tsT< $, \nr D M: u. As a notational convenience, we often drop t%e coercion set C from typing judgments if it is \nempty, i.e., we use rD&#38;f: a for the judgement +, rDM: a. Just as for SS1, we have the following two \ndecision problems for type inference in the presence of subtyping (abbreviated TIS): (TIS) Given a signature \nZ and a term h , is M typable over the signature Z ? ( X-TIS) Given a term M, is M typable over a fixed \nsig\u00adnature E ? As in [Mit 91 b], we can prove that the type of an expres\u00adsion M only depends on the type \nassumptions about its free variables. We use the not at ion r(z) to denote the unique ~ such that X: \nu E r. Lemma 2.1 Assume that bsT+ C, rD M: u. Suppose r M a context such that for all varhbles x that \nare free in M, r (z) = r(z). Then k.ST+ C, r D M: C7. A useful consequence of restricting the assertions \nin the coercion set of typing judgments to be atomic is the follow\u00ading property which states that one \nmay normalize proofs in ST< so that the only uses of (subtp) rule occur immediately after (var) and (const) \n. Lemma 2.2 For every provable typing statement C, rDIVf: o, there ZS a proof in which rule (subtp) us \nonly used immedi\u00adately after the typing azzoms (var) and (const). 3 Type Inference Reduced to Inequality \nSatisfaction It is well-known that the typability problem for simply-typed J-calculus can be reduced \nto unification [ASU86, Wan87]. In this section we show that the analagous constraint sat\u00adisfaction problem \nfor typability in the presence of subtying is the satisfiability of subtype inequalities. More precisely, \nwe exhibit a polynomial time reduction from TIS to SS1 in which the poset constructed only depends on \nthe signature. This reduction was implicit in [Mit91b] and [Tiu92]. In the rest of the paper we will \nuse formulas of the form o = T, when defining a system of inequalities, as an abbre\u00adviation for the pair \nof inequalities u < r and T ~ o. Since <B is a partial order (as opposed to a preorder) the equation \na = ~ is satisfiable iff ~ < ~ and ~ ~ ~ are satisfiable. If X = (B, <B, l ) is a signature with subtyping, \nthen we define the partial order Pz to be (B, ~~) . Lemma 3.1 Given a signature (with subtyping) X, the \nde\u00adctsion problem for typabdzty over Z as polynomial time re\u00adducible to the sattsfiability problem for \nsubtype inequalities over %, i.e., E -TIS ~~ % -SS1. Proof Let X = (B, <B, T) be a signature. For any \nterm M and a cent ext A such that A(z) is a type variable for every x E Dom (A), we define S1(M , A) \n= (t, Z) by induction on the structure of M as follows, with t a type variable and Z a system of inequalities. \nSI(X, A) = (t, {A(z) s t}) where t is a fresh type variable not in A SI(C, A) = (t, {0 < t}) where (c, \ncr) c C and t is fresh. SI(MJV, A) = let (tl,Zl)= SI(M, A) (t,, Z,) = SI(N, A) in (t,ZlU Z2 U {tl = t, \n+t}), t is fresh. S1(ke. M,A) = let = SI(M, A U {z: s}) (tl,Zl) where s is fresh in (t, z,u{t=s+t,}) \nwhere t is fresh The reduction from Z -TIS to PE -SS1 can then be given as 4.1 SS1 ,,st, reduced to \nTIS .t.~ follows. For any term A4, we produce the set of inequalities Z, where S1(A4, A) = (t, Z) with \nA a context that maps each variable x, free in A4, to a distinct type variable. Using Lemma 2.2 it can \nbe easily seen that this is a reduction. Since each inductive clause in the definition of S1 adds only \ntwo new inequalities (a constant number) IZI ~ c IIZI, and this is a polynomial time reduction. m Corollary \n3.2 The problem of deciding whether a given term is typable over a given signature, with subtyping, is \npolyno\u00admial time reducible to the satisjiability of subtype inequalities problem, i.e., TIS <m SSI. In \nthe next section we will focus attention on systems of inequalities in which all formulas are of the \nform b ~ t, s<t, s<t+u, ort+u<s where s,t, u~V, and bGB. We call the satisfiability problem for this \nrestricted system of inequalities SS1 res~,. If the signature E = (1?, <B, T) is such that all constants \nhave atomic types, z.e., for all (c, a) c T, cr c B, we call the TIS problem for such input signature \nTIS .t.~. Note that Z -TIS atom really restricts the signature Z rather than instances of the problem. \nCorollary 3.3 The decision problem for typability over a signature X in which all constants have atomic \ntypes is polynomial time reducible to the satisfiability problem for restricted systems of subtype inequalities \nover PZ, i.e., Z - TISatom <m PZ -SSIr.st, . Hence, TISatom <~ SSIr~~t~. Proof The inequalities added \nin the inductive cases of S1 when the term is an application or J-abstraction are of the form s= t+ u.When \nthe term is a variable the inequality isofthe form s< t. When the term is a constant the inequality added \nis o < t which is of the form b ~ t when u is atomic. _ 4 Reducing Inequality Satisfaction to Typability \nIn Section 3, we showed how a solution to the type-inference problem in the presence of subtypes can \nbe obtained from a solution to the problem of satisfaction of subtype inequal\u00adities. In this section, \nwe establish the converse reduction, namely, we prove that SS1 is polynomial time reducible to TIS. As \ncorollaries of this reduction, we are able to translate lower-bound results about SS1 to TIS. Together \nwith results in Section 3, this shows the equivalence of the two problems TIS and SS1. When there are \nno subtype assumptions on base types, type-checking for simply-typed lambda calcu\u00adlus with subtyping \nreduces to that of simply-typed lambda calculus. And satisfaction of subtype inequalities over a dis\u00adcrete \npartial order is the same as unification. This gives the well known equivalence between type inference \nfor simply\u00adtyped lambda calculus and unification [Tys88, Mit91a, Wan87] as a consequence of our results. \nAlthough interest in type inference with subtypes gave rise to the earlier studies of satisfaction of \nsubtype inequal\u00adities over partial orders [PT91, Tiu91, Tiu92], the precise connection between the two \nproblems was not previously understood. In fact, comments in [Tiu92] suggest the be\u00adlief that the satisfaction \nof inequalities would turn out to be algorithmically more complex. This suggests some of the subtlety \nof our proof that the two problems are in fact polynomial-time equivalent. We begin by showing how inequalities \nof the restricted form can be simulated by corresponding terms. More precisely, we will exhibit a polynomial \ntime reduction from SS1 restr to TIS .tOm. Before doing that, we state two lemmas that we will need in \nthe proof of correctness of the reduction. Lemma 4.1 Suppose D is a derivation of 17DM: o in ST< . Let \np be any substitution. Define the derivation P(D) to be the one obtained by replacing every line of the \nform I D M : a by p(r )DM : p(a ). Then P(D) is a valid derivation inST4 .  Proof We can prove by induction \non rl that if rl <B TZ then for any substitution p, p(~l ) ~J3 p(~z). The lemma now easily follows by \ninspection of each axiom and inference rule of ST+. _ In partiular by choosing p to be a ground substitution, \ni.e., one that maps all variables to ground types, Lemma 4.1 shows that if any term M is typable then \nit has a typing derivation in which all type occurrences are ground types. Furthermore, by Lemma 2.2 \nwe can assume that the deriva\u00adtion uses (subtp) only after (var) or (const). The following lemma shows \nthat typing an application term forces certain subtype inequalities to be satisfied. This is an easy \nconsequence of Lemma 2.2. Lemma 4.2 Let D = (B, fi~, C) be a signature, suppose Z EST< r D zy:a. Then \nI (z) = PI +71, I (y) = PZ with @ &#38;_jl and 71 ~B CJ. Proof Consider any derivation of r>xy: u of \nthe form given by Lemma 2.2 rDX:&#38;~u rby:c$l rDZg:c7 with r(z) ~B &#38; + o and r(y) <B 61. Then \nr(z) = pl + rl and with 61 5B pl and rl ~B o which gives us the statement of the lemma. _ Let P = (F \n, <p ) be any poset. Define the signature Egt m = (F , +,T) where T = {cP:p I p G P}, i.e., for each \nelement of the partial order, we define a constant of that type. Note that Z$Om assigns atomic types \nto all constants. We axe now ready to establish the converse to Corollary 3.3. Lemma 4.3 The satisjiability \nproblem for restricted sys\u00ad tems of subtype inequalities over a poset P is polynomial time redu~~~~ to \nthe typability problem over the atomic sig\u00adnature &#38; , i.e., P -SSITestr <~ ~$ m -TIS. The reduction \nand the proof of its correctness appear in the AppendIx. Corollary 4.4 The satisfiability problem for \nrestricted sys\u00adtem of inequalities is polynomial time reducible to the prob\u00adlem of deciding whether a \ngiven term is typable over a given signature in which all constants have at omit types, i.e., SSITestv \nsm i ISatom . Corollary 4.5 There exists a signature Z which maps con\u00adstants to atomic types such that \nE -TISatom is wAcE-hard. Hence, the problem TISatom is also psPAcE-hard. Proof By results in [Tiu92], \nthere exists a poset T for which P -SS1 rest. is PsPAcE-hard. Lemma 4.3 translates this result to TIS \natom. _ 4.2 SS1 reduced to TIS We now generalize the reduction described in Section 4.1 to show how satisfiability \nof a set of arbitrary inequalities can be simulated by typability of a term. To simulate in\u00adequalities \nthat are not necessarily of a restricted form, we no longer have the requirement that the signature give \nonly atomic types to constants. Let P = (F , <P) be any poset. We define the sig\u00adnature 2P = (F , <P, \nT) where T = {(c$,~+~) I ~ G P} U {(c;, p) I p G P}. Note that the signature X7 is not atomic. The following \nlemma generalizes the reduction of P-SSI ~e~t~ to X$tom -TIS and shows how arbitrary in\u00adequalities can \nbe simulated by terms in the signature XT using the constants c; s of functional type. Lemma 4.6 (t) \nThe sattsfiabdity problem for subtype inequalities over a poset P is polynom~al time reducible to the \ntypability problem over a signature Xp , i.e., P -SS1 <m X7 -TIS. ( Ii) The satisfiabdity of subtype \ninequalities problem aspoly\u00adnomial time reducible to the typability problem, t. e., SSI <~ TIS. Proof \n(i) For any type o over P, we define a term Mm and a context Cm [ ] with one hole simultaneously by in\u00adduction \nu. Intuitively, MO is defined so that c is a subtype of any type of Mm , and C. [ ] is defined so that \nfor any term N, a typing of Cm [N] constrains the type of N to be asubtype of a. If o isatype over variable \nset V = {t 1,. ... t~ } then Lfo and Cm [ ] have free variables U1, vl, . . . . Un, Vn. Mt* = V,u, Ct, \n[]=v. []  Mp=c~   CPII=+J[l MO+. =AZ. KM7C. [Z] Ca+r[]=CT[[] Ma] where K is the combinator oz. (Ay. \nz)). Given an arbitrary inequality al < CTZ, we can now define the term [al < OZ] as follows: [m < a2] \n= c., [fw,] As in lemma 4.3, for any system 1 of inequalities, we produce the following term M = Jul. \n.. Aun. (Jo, . . . A un. (Ax. [il])((Xz. [22])(. ~~((Az. [Im-l])[im]) . )) ) (Az. z) (Az. z) ~ times \nwhere ~={il, . . ..i~} (ii) The signature Xp can be produced from the partial order T in polynomial time. \n _ From Corollaries 3.2, 3.3, 4.4, and Lemma 4.6, we have the following theorem. Theorem 4.7 (i) The \nsatisfiabiltty problem for restricted system of sub\u00adtype anequalittes (SSIre~tT ) and the typability \nproblem over a signature in whzch all constants have atomzc types (TISatOm ) are polynomial time equivalent. \n(ti) The sattsfiabzltty of subtype inequalities (SSI) and the typability problems (TIS) are polynomial \ntzrne equiva\u00adlent. 5 Most General Typings In this section we investigate a general theory of instances \nand most-general typing judgments for the type system ST< . While the typability problems we considered \nbefore wer% with respect to the given fixed subtype ordering on base types, we will now study most general \ntyings for typ\u00ading judgments with additional subtype assumptions. One reason for allowing additional \nsubtype hypotheses is that, in general, this is the only way to obtain most general types. A second justification \nis that from the most general typ\u00ading for an expression which includes additional subtype as\u00adsumptions, \nit is possible to decide whether the expression is typable with respect to any fixed subtype ordering. \nIntuitively, a most general typing judgement for a term is one which characterizes all possible t ypings \nfor it. In more detail, if C, 17DM: a is a most general typing for M, then all other derivable t ypings \nC , r D M: o can be obtained from it. The precise manner in which C , r D M: a is obtained from the most \ngeneral typing C, I_ ~ M: u is via a definition of instance, a binary relation on typing judgments. Then \na most general typing for a term Al is a derivable typing judgement such that all other derivable typings \nfor M are inst antes of it. Thus, most general typings are crucially related to the notion of instance \nthat one uses. In [Mit91b], the following definition of instance is given: Definition 5.1 A typing statement \nC , I b M: U z. an in\u00adstance of C, I D M: u zf there exists a substitution S such that: (z) C l-scj \n(ii) u =SU,  (in) V.Z E Dom(r),r (z) =s r(z). [Mit91b] also gives an algorithm GA which infers a most \ngeneral typing for any term with respect to the stated defi\u00adnition of instance. Unfortunately, the size \nof the coercion set in the most general typing produced by GA can become ex\u00adponential in the size of \nthe term. Since an important aspect of any type-inference algorithm is the size and readability of its \noutput, there has been previous work on optimizing the type inference algorithm to produce the shortest \nmost gen\u00aderal t ypings [FM89, FM90]. However, there is an intrinsic limit to the shortest most general \ntypings that can be pro\u00adduced if we adhere to Definition 5.1 of instance. To give a relatively simple \nexample, there are typings for terms which cannot be inst antes of any typing with empty coercion set. \n Example 5.2 Let M = Jj. Ax. Jy. K (j Z) (f y) . Using type s for x and type t for y, a derivable typing \nfor M is: {s~u, tfu, v~w}, @P M:(u+v)+s+t+w (1) A typing for the term M wzth empty coercion set is: \nc#, c#DM:(s+t)+s+s+t (2) However, the typing (l?) with empty coercion set cannot have the typing (1) \nas an instance, using Definition 5.1. For, there can be no substitution S such that SO = u , where a=(s+t)+s+s+t \nandcr =(u+v)+s+t+ w. Since the problem in Example 5.2 arises from the defini\u00adtion of instance that one \nhas chosen, a natural object of in\u00adterest is an alternative formulation of the notion of instance which \nwould permit most general typings with succinct set of subtype assumptions. It would be particularly \ngood, if for example, one can obtain most general typings in which the subtype assumption set is always \nempty. The following more general definition of instance allows the typing (1) to be an instance of (2), \nand thus allows a most general typing of M from Example 5.2 with an empty coercion set. Definition 5,3 \nA typing statement C , I P M: u is an in\u00ad stance of C, I D M: u if there exists a substitution S such \nthat: (2) C 1-sc, (u) c 1-su~ u ,  (iii) VZ c Dom(r), c F r (z) < S r(z). We can see that the typing \n(2) has (1) as an instance, by Definition 5.3, using the the substitution S defined by S(s) = u and S(t) \n= v. Unfortunately, even this more pow\u00aderful notion of instance does not allow typings with empty coercion \nsets to be more general than all other derivable typings for arbitrary terms. Example 5.4 Take M = f \n(f x) . Consider any derivable typing for M, @,17 b M: o, with empty coercion set. Then we must haoe \nr(z) = a, I (f) = a + u. We can see that this typing with empty coercion set cannot have the following \ntyping for M as an instance. {s<t, u~v, u~t}, {f:t+u, z:s}bf(fz):u For consider any substitution S. \nBy condition (ii) of Defi\u00adnition 5.3, we must have C! + S(u) ~ v, where C = {s ~ t,u~ v,u ~ t}. By inspection \nof C , this implies that S(a) = u or S(u) = v. In etther case, we cannot satisfy condition (iii) for \nthe variable x, since C! ~ s < u and c ys~v. Investigation of other plausible notions of instance by \nthe authors also failed to allow typings with empty coercion sets to be most general. It was therefore \na natural question whether there could be any definition of instance that would permit such elegant most \ngeneral typings. In this section, we show that this is impossible. The main result of this section is \nthat there is no suitable definition of instance for which there is a bound on the size of the coercion \nset in most general typings of terms. Thus we need to allow arbitrarily many subtype assumptions in giving \nthe most general types of terms, in general. We begin with a formalization of the properties of any suitable \ndefinition of instance. An instance relation , +, is a binary relation on typing judgments. Intuitively, \nC, r D M: u > C, I D M: o means that the typing judgement C, r D M: a is more general than C , I b ill: \nCT . A defi\u00adnition of instance usually does not depend on the term M appearing in the judgments. Further, \na basic property that one requires of any definition of instance, is the closure of derivability under \ninstantiation. These two properties are captured in the following definition. Since all the properties \nin this section are proved for pure A-terms, i.e., without any term constants, we omit mentioning any \nsignature in the following definition and the rest of this section. Definition 5.5 Let > be a definition \nof instance on typing judgments. Then + is a sound definition of instance if: (i) C, I DM:u FC ,1 DM:u \niff C, I DN:u FC , I?D N: u , for all terms N. (ii) If C, I DM:o+C ,1 ~M:o andkST< C, I DM:O then kST< \nc , r DM: u . Given a definition of instance, +, a typing judgement C, rD M: o is a most general typing \nfor term M if The typing judgement C, r > M: o is derivable.  For all derivable typing judgments C, \nI D M: a , we have C, I ~M:~+C,l?~M:&#38;.  We can now show that the term f ( f Z) cannot have a most \ngeneral typing, under any sound definition of instance, in which the coercion set is empty. This is a \nspecial case of a more general theorem that we will prove later, but its proof is illustrative in understanding \nthe proof of the more general theorem. Lemma 5.6 Let M = f (f z) and > be any sound deji\u00adnitzon of instance. \nThen M does not have a most general typing in which the coercion set is empty. Proof Consider any derivable \ntyping +, rDM: a with empty coercion set. Then we must have ~: a, f: u + a E r. We will show that ~, \n17~ M: o cannot be a most general typing for M. Let C ={sft, uSt, u5u}, r ={~:s, f:t+u}, o = v, clearly, \n+ST+ (J , 1? D M: a . Consider the term N = z. Since X:u c 17,-wehave ~ST< 4, r D N: u. But since C ~ \ns f v, we have Y. ST<C , I ; N: a . By property (ii) of a sound definition of iristance, $,r DN:o#C , \nr DN:cr Hence, by property (i) of a sound definition of instance, +,1 bM:of C , r DM:u _ We will now \ngeneralize Lemma 5.6 to show that no bound on the size of the coercion set will suffice to express most \ngeneral typings of all terms. For any atomic coercion set C and set of type variables T, define the coercion \nset C IT to be the set {s ft~Cls~Tort GT} We say that an atomic coercion set C is closed if for any non-trivial \natomic subtyping assertion, s ~ t with s# t, C Ks~ t iff s~ t ~ C. For any atomic coercion set C, define \nits closure as the atomic coercion set defined by clos(c) ={s5tls#t, et-s <t} We use FTV(C ) to denote \nthe type variables appearing in the coercion set C, and use FT V(a), FTV(17) for a type a and context \nP, similarly. We now state without proofs some technical lemmas involving free type variables in coercion \nsets which will be useful in the proof of our main theorem. Lemma 5.7 For any atomic coercion set C, \n(i) C1OS(C) M closed. (ii) Fz v(clos(c)) g JTv(c) .  Lemma 5.8 Let C be an atomzc coercion set. (i) \nIf C1-u~r then Clos(C)t-u <T. (%i) If kST4 C, 17P M: o then ksT5 C1OS(C), r D M: u . Lemma 5.9 Suppose \nC is a closed atomic coercion set. (z) If C1-0 sTand FTV(U) ~T orFTV(7) ~T then +O~T. CIT (ii) If EST+ \nC, rbkf: CT and M has no J -abstractions then ~ c~iTV(I )9 r D * We are now ready to show that we cannot \nbound the size of the coercion set of most general typings. As in Lemma 5.6, we will use terms of the \nform f ( f Z) in proving our result. More precisely, we show that the term M = .2 fl(fl cl)...fk+l(fk+l \nZk+l) cannot have a most general typing which uses at most k subtype assumptions. Roughly, the argument \nis as follows. If there are no subtype assumptions involving the types in one of the subterms f~ ( fi \nZi ) then this subterm has been typed using an empty coercion set and hence by an argument similar to \nLemma 5.6, this typing cannot be most general. Otherwise, a typing which uses at most k subtype assump\u00adtions \nmust relate the types used in two subterms f; ( f, z,) and fj (fj X3). Since this is a constraint that \ndoes not have to be enforced in typing M, such a typing must not be more general than a typing in which \nthe type assumptions used in typing the subterms f, (f, z,) and fj (fj Xj ) are completely unrelated. \nAll this is made more precise, using Lemmas 5.7, 5.8, 5.9, in the proof of the following theorem which \nis given in the Appendix, Theorem 5.10 Let + be any sound definition of instance. For every k there is \na term Mk with [Mk I = O(k) such that the most general typing of Mk requires a coercion set with at least \nk + 1 elements, i. e., the size of the coercion set grows at least linearly in the size of the term. \n6 Conclusion This paper contains two results on type inference with sub\u00adtyping. The first shows that \ntypability of a term in the presence of a fixed subtype ordering is equivalent to satisfia\u00adbility of \nsubtype inequalities over the same subtype ordering. A natural special case of typability arises when \nall program constants only have atomic types. This special case is equiv\u00adalent to satisfiability of a \ncertain restricted form of subtype inequalities. Since this restricted satisfiability problem has been \nshown previously to be psPACE-hard, our equivalence gives a PSPACE lower bound on the algorithmic problem \nof typability with either general or atomic types. The second main result is concerned with most general \ntypings, which are the typical output of a type-inference algorithm. In\u00adstead of working with a particular \nnotion of instance, we have given a general lower bound that is independent of the notion of instance \none may chose. Our lower bound is that for any sound notion of instance, the number of subtype as\u00adsumptions \nin the most general typing grows linearly in the length of the term. One important investigation is a \nprecise characterization of the structural complexity of the problem of typability. The equivalences \nshown here demonstrate the importance of the problem of subtype inequality satisfaction and the importance \nof inequalities of the restricted form. One open problem is to find the complexity-theoretic relationship \nbe\u00adtween satisfiability with arbitrary subtype inequalities and satisfiability with inequalities of the \nrestricted form. An\u00adother problem is to give matching upper bounds and lower bounds for each problem. \nThe lower bounds in this paper suggest the importance of finding more tractable subproblems. This would \nhave important consequences for programming language design. Both the algorithmic complexity of typability \nand the lack of succinct most general typings appear to arise due to par\u00adticuhw partial orders that may \nnot arise in practice. It is therefore important to identify classes of subtype orderings that lead to \nreasonably flexible programming languages and, at the same time, yield tractable type inference problems. \nReferences [ASU86] A.V. Aho, R. Sethi, and J.D. Unman. Com\u00adpders: princ~ples, techniques, tools. Addison-Wesley, \n1986. [Ben94] M. Benke. Efficient type reconstruction in the presence of inheritance. Manuscript, 1994. \n[FM89] Y. Fuh and P. Mishra, Polymorphic subtype in\u00adference: closing the theory-practice gap. In Proc. \nTheory and Practice of Software Development, pages 167 184, March 1989. [FM90] Y. Fuh and P. Mishra. \nType inference with sub\u00adtypes. Theor. Computer Science, 73, 1990. [GMW79] M.J. Gordon, R. Milner, and \nC.P. Wadsworth. Edinburgh LCF. Springer LNCS 78, Berlin, 1979. [H+ 92] P. Hudak et al, Report on the \nprogramming lan\u00adguage Haskell. SIGPLAN Notices, 27(5) :Section R, 1992. [HF92] P. Hudak and J. Fasel. \nA gentle introduction to Haskell. SIGPLAN Notices, 27(5) :Section T, 1992. [LM92] P.D. Lincoln and J.C. \nMitchell. Algorithmic as\u00adpects of type inference with subtypes. In Proc. 19th ACM Symp. on Principles \nof Programming Languages, pages 293-304, January 1992, [Mi185] R. Milner. The Standard ML core language. \nPolymorphism, 2(2), 1985. 28 pages. An earlier version appeared in Proc. 1984 ACM Symp. on Lisp and Functional \nProgramming. [Mit84] J.C. Mitchell. Coercion and type inference (sum\u00admary). In Proc. 1lth ACM Symp. on \nPrinciples of Programming Languages, pages 175 185, Jan\u00aduary 1984. [Mit91a] J.C. Mitchell. A simple reduction \nof unification to typa\u00adbility. Message to types@theory. lcs .mit. edu, June 281991. [Mit91b] J.C. Mitchell. \nType inference with simple sub\u00adtypes. J. Functional Programming, 1(3):245-286, 1991. [PT91] V. Pratt \nand J. Tiuryn. Satisfiability of inequa\u00adtions in a poset. Manuscript, October 1991. [Tiu91] J. Tiuryn. \nSolving term inequalities is PSPACE\u00adhard. Manuscript, October 1991. [Tiu92] J. Tiuryn. Subtype inequalities. \nIn Proc. IEEE Symp. on Logic in Computer Science, pages 308\u00ad315, 1992. [Tur85] D.A. Turner. Miranda: \na non-strict functional language with polymorphic types. In IFIP Int 1 Conf. on Functional Programming \nand Com\u00adputer Architecture, Nancy, Berlin, 1985. Springer LNCS 201. [TYS88] J. Tyszkiewicz. Complexity \nof type inference in finitely typed lambda calculus. Master s thesis, University of Warsaw, 1988. [Wan87] \nM. Wand. A simple algorithm and proof for type inference. Fundamental Informaticae, 10:115 122, 1987. \n[W089] M. Wand and P. O Keefe. On the complexity of type inference with coercion. In Proc. ACM Conf. \nFunctional Programming and Computer Archi\u00adtecture, pages 293 298, 1989. A Appendix Proof of Lemma 4.3 \nSuppose P = (P, <p). Let Z be a restricted system of inequalities over 7, with type variables from a \nfinite set V = {t ~,..., tn}. For any inequality i c Z, we will define a term [i] over @Om with free \nvariables U1, W,. ... %7%. In defining the terms [i], the variables vi should be understood as having \nfunction types u, -+ r, with ui serving as a lower bound on any satisfying substitution for the type \nvariable ti,and Ti serving as an upper bound. Thus, the application of v, to ui yields a term whose type \nhas to be a supertype of the substitution for t;,while the application of v, to a term N, forces the \ntype of N to be a subtype of the substitution of ti.Using these two ideas, the terms [i] are then so \ndefined as to enforce the subtype relations implied by the inequality i. ~<ti] = 7.l~Cp [t% < tj] W$ \n(Vi Ui) [ti < tj +t/f] = Wk ((ViW)(VjUj)) [tj+ tk< ti] = vi(~~.K(vk Uk) (Vj Z)) where K is the combinator \n(Az. (Ay. z)). Finally, we produce the following term M = ~U1...JU~. (Au, ...Aun. (kc. [il])((kz. [iZ])(. \n~. ((AX. [im-l])[im]) . . .)) ) (Az.x) . . . (Az. z) ~ times Abstracting the variables vi and applying \nto the identity functions Az. x forces each variable vi to be of the desired function type that was assumed \nin the construction of the terms [i]. We now prove that A4 is typable iff Z is satisfiable. If Z is satisfiable \nby substitution qr, it can be easily seen that M can be typed by using type ~Z (t])for uj and pz(tj ) \n+ pz(tj ) for Vj. For the converse, assume that M is typable. By our previous comments, consider a derivation \nD of M in which all type occurrences are ground types and in which (subtp) is used only after (var) and \n(const). Note that if EST< r D k. x: T then ~ = ~1+ ~, where ~1 4P T.. By the fillowing derivation fragment \nin which there are no (subtp) occurrences after (app) or (abs) . . . ,v:TD( ):a ...D~v. :T+o D~x. x:7... \n... P (Au. ( ks. z):a ))( it follows by constructing D backwards that D must have a line of the form \nruv D (k. [il])((Az. [iz]).. .):0 where I ~V={ul: pl, . . ..u~. p~, vl:al+~l, ..., V.: C7. +T. } for \nsome types pi,.. .,p~, al, a~, ~l,,,~~.. .,~~ with ai 5P Ti and ~i,ri ETP. Take p to be any substitution \nwith u~ 5P p(z,) 3P r,, such a p exists since ui, Ti G TP . We prove that p is a satisfying substitution \nfor Z. By constructing D backwards we also see that ruu D [it]: O; for some oj. We prove that p as defined \nabove will then satisfy il. We only show two representative cases: Case it -ti <t, +t~ : Then [it] = \n(vk ((vi ui) (~j uj)))t Since 17tiv D [ii]: O;, we must have occurring in D r..DVk:&#38;~U~ (3) ruv D \n((vi Ut)(Vj Uj)):62 (4) from (4) we must have that ru. D(Viu~):61 -+62 (5) ru. D (Vj Uj): &#38; (6) By \nLemma 4.2, ri 3P 61 + 62, Tj 3P 61. Thus Ti = Si +wi and 61 5P si and wi 5P 62. Since r(Vk) = Uk ~ Tk \nit fOllOWS that Uk ~ Tk 5P 62~ O(, i.e., &#38; 5P cr~. Thus r% = S, +wi with Tj <p si and wi 5P Ok , \ni.e., p(t,) <p T,<p rj ~Uk <P ~(tj) +p(tk). He-, ~(ti) <P ~(tj +tk). Case il = tj-+tk< ti:Then [i/] \n= v,N, where N = (Jz. ~(v~ u~) (Vj z)). Then we must have occurring in D F=W,X:CZ DVkUk:61 (7) ru.,x:ff. \nD VI X:62 (8) 17.. D N: O. +63 (9) where 61 5P 153, since if ~ST< r D K: T then T = T1+T( ~ T, With \nT1fp r, . By Lemma 4.2, from (8) we get that cra <p a3 and from (7) we get that Tk 5P 61. Then by similar \nrea\u00adsoning as before since E,ST< r.. D v,N: . . . we get that u. _+c$3 <p CT;, z. e., ~(tj + tk) = p(tj) \n+ ~(t, ) <p GJ +rk ~p u. -+61 ~p 0. +63 5P 0% ~p p(tt) w Proof of Theorem 5.10 Consider any k >0. Take \n~ = Z ~l(fl Zl) . . . .fk+l(.fk+l ~k+l) We will prove that M cannot have a most general typing whose \ncoercion set has at most k elements. Consider any provable typing C, I_ D M: a with ICl < k. We will \nexhibit a provable typing C , 17 B M: o such that C, 17D M: a $ C ,l DM: o . Let pi and p: be the typing \nassumptions for x, and ~Z respectively, in r, i.e., let p, = r(z, ), p: = I (f. ) for i=l ,..., k+l. \nThen, define r, = {~t:pt, ft:p~}, i=l, . . ..k+l S, = FTV(C) nFTV(r,), i = ,k+ 1,...1 Case I: Forsomej, \nl<j<k+l, SJ =+. Take C = U {S <ti,U* <~,~z <vi} I<z<k+l r = {z:v1+v2+ . ..+vk+1+w}u U {~i,s,ft:tt+W} \nl<t<k+l U =w Since >ST< C, rl>kf: a and C is atomic, using Lemma 2.2 there i; a proof D as in Table 1. \nSuppose that S j = q$. From the proof ~, we have that *ST< C, r D fj (.fj zj): aj. Using Lemma 2.1, we \nhave that-~ST< C, 17jD.fj (fj Zj ): aj. By Lemma 5W), EST< Clos(C)~I , > f, (f, z,): a, . By Lemma 5.7(i) \nand Lem-ma 5.9(ii), hsT< C~Os(C) ~FTV(r,)~ rj Dfj(.fjzj):f7j. Now = Ck(cq ~FTv(r, )nFTv(ctOs(c))c~os(c) \ntFTv(r, ) By Lemma 5.7(ii), mw(rj) n = F7 V(G70S(C)) ~. Hence, c~os (c) ~~Tv(r, ) = 4$. Thus, ks~< @,rj \np ~j(.f~ ZJ):a~  Hence, it must be that (lo) PJ=~J> P~=~3+u3 Consider the term N = ~(f, (flzl)) . . \nU-1(. f-l x,-l)) z, . (.fk+l(fk+l~k+l)) From (10), we know that l_sT< C, rD Z3: aj . PhIgging this proof \ninstead of C, 17D fj ~fj XJ): aJ in the deriva\u00adtion D, we get that ~ST< C, r D N: o. But, we can\u00adnot \nhave that t_sT+ C!, r? b N: U since C v SJ d VJ and thus N is not typable under assumptions c , r . Thus, \n~sT4 C , r D ii: u . Since + is s&#38;nd, C,rFN:u~C ,r DN:/ * C,r DM:u#C , r DM:u Case II: SJ #@, for \nj=l,..., k+l. Consider c =q5 r = {z:p1+p2+ ..+ Pk+1+w} u u {Gp,,.ft:pt+pt} I<, <k+l U =w Consider the \nsets C lsl,... Then they cannot Cfsk+l all be pairwise disjoint. For, if they were, we have Ic[s, u \n~~~Uctsk+,l = Ic[sll +  + Iqsk+,l > 1+... +1 (St #@) = k+l Claim A.1 There extst type varvables s,, \nSJ, u such that si G FTV(rz), Sj c F TV(17j) and C 1-S{ ~ U,cksl <u. roof ince c~s. ncrsj #d, lets 5 \nt E cts,nc~s,. Then sort isin S,and sortis inSj. s~S,, t~Sj. Take s,=s, s3=t, u =t. e teS,, se Sj. \nTakesZ= t,s~=s, u=t.  scS,, sESJ. Take s~=s2= U=S. . t~St, tESf. Takes,= s3=u=t.  c,r~z:pz c,r~fl(.flzl):al \nc,rDZ(fl(flZl)):... C,rbfz(.fz.fz):az . C}r D fk+l(fk+l Zk+l): Ok+l Table 1: Derivation D of Theorem \n5.10 The term EQ is defined as which ensures that EQ M N is typable iff M and N can be given the same \ntype. Then we can make the following observations: (i) EST+ C, ru{yl: fi}bF(&#38;): T for some type ~, \ni.e., F (61~ is typable under the assumptions C, r U {Yl:&#38;}. (ii) Suppose that E.ST< C , r D~(&#38;): \nr and 17\u00b0317 . Then r (Y1) = IX ~ Case IIa: One of ~i, oj, @i, ,Bj, vi, Tj k not a type variable. Then \nlet c$l be the one that is not. Con\u00adsider the term From Observations (i) and (ii), we get that Case IIb: \nAH of cw, @, ~1 are type variables. By Claim A.I, we have variables s~, sj, u satisfying the re\u00adquired \nproperties. We also know that s~ = at, @i or forl=iorj and ~ST+ C,rU{yi:si,yj:sj}D~Qyiyj:T From Observations \n(i) and (ii), taking N = K M (Ayi. Jyj. ~w. W ~(Si) F(Sj) (~Qyi ?4j)) we have that Tl Hence, in either \nC,r case PLf:o#C , r Dkf:u Taking see that the term lMk\\ = kfk O(k). = z .fl(.fl zl) . . . ik+l(.fk+l \n~k+l), we m  \n\t\t\t", "proc_id": "199448", "abstract": "<p>We investigate type inference for programming languages with subtypes. As described in previous work, there are several type inference problems for any given expression language, depending on the form of the subtype partial order and the ability to define new subtypes in programs. Our first main result is that for any specific subtype partial order, the problem of determining whether a lambda term is typable is algorithmically (polynomial-time) equivalent to a form of satisfiability problem over the same partial order. This gives the first exact characterization of the problem that is independent of the syntax of expressions. In addition, since this form of satisfiability problem is PSPACE-hard over certain partial orders, this equivalence strengthens the previous lower bound of NP-hard to PSPACE-hard. Our second main result is a lower bound on the length of most general types when the subtype hierarchy may change as a result of additional type declarations within the program. More specifically, given any input expression, a type inference algorithm tries to find a <italic>most general</italic> (or <italic>principal</italic>) typing. The property of a most general typing is that it has all other possible typings as instances. However, there are several sound notions of instance in the presence of subtyping. Our lower bound is that no sound definition of instance would allow the set of additional subtyping hypotheses about a term to grow less than linearly in the size of the term.</p>", "authors": [{"name": "My Hoang", "author_profile_id": "81100513490", "affiliation": "Computer Science Department, Stanford University, Stanford, CA", "person_id": "PP31081697", "email_address": "", "orcid_id": ""}, {"name": "John C. Mitchell", "author_profile_id": "81338490160", "affiliation": "Computer Science Department, Stanford University, Stanford, CA", "person_id": "PP43125642", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199481", "year": "1995", "article_id": "199481", "conference": "POPL", "title": "Lower bounds on type inference with subtypes", "url": "http://dl.acm.org/citation.cfm?id=199481"}