{"article_publication_date": "01-25-1995", "fulltext": "\n A Type System Equivalent to Flow Analysis Jens Palsberg* Patrick O Keefe~ Abstract Flow-based safety \nanalysis of higher-order languages has been studied by Shivers, and Palsberg and Schwartzbach. Open until \nnow is the problem of finding a type system that accepts exactly the same programs as safety anal\u00ad ysis. \nIn this paper we prove that Amadio and Cardelli s type system with subtyping and recursive types accepts \nthe same programs as a certain safety analysis. The proof involves mappings from types to flow information \nand back. As a result, we obtain an inference algorithm for the type system, thereby solving an open \nproblem. 1 Introduction 1.1 Background Many program analyses for higher-order languages are based on \nflow analysis, also known as closure analysis. Examples include various analyses in the Standard ML of \nNew Jersey compiler [3], and the binding-time anal\u00ad yses for Scheme in the partial evaluators Schism \n[6] and Similix [4]. Such analyses have the advantage that they can be applied to untyped languages. \nThis is in contrast to more traditional abstract interpretations which use types when defining the abstract \ndomains. Recently, it has become popular to define program analyses for typed languages by annotating \nthe types with information about program behavior [10, 2]. This has lead to clear specifications of a \nrange of analyses, and often such an analysis can be efficiently computed *Computer Science Department, \nAarhus University, DK-8000 Aarhus C, Denmark. E-mail: palsberg~daimi. aau. dk. t 151 Coolidge Avenue \n#211, Watertown, MA 02172, USA. E-mail: pmo@world. std. corn. Permissionto oopywithout fee allor partofthis \nmaterialis granted provided that the copies are not made or distributed for direct commerdal advanta~e, \nthe ACM copyright notice and the title of the publication and its date appear, and notice is given that \ncopyi is by permission of the Association of Computing Machinery.Y o copy otherwise, or to republish, \nrequires a fee andor specific permission. POPL 951/95 San Francisco CA USA @ 1995 ACM 0-89791-692-1/95/0001....$3.50 \nby a straightforward extension of a known type infer\u00adence algorithm. The precision of a type-based analysis \ndepends on the expressiveness of the underlying type system. Sim\u00adilarly, the precision of a flow-based \nanalysis depends on the expressiveness of the underlying flow analysis. In this paper we address an instance \nof the following fun\u00addamental question: Fundamental question. What type-based analysis computes the same \ninformation as a given flow-based analysis? We consider the case of flow-based safety analysis, that \nis, an analysis which collects type information from for example constants and applications of primitive \nop\u00aderations. Such an analysis was first presented in 1991 by Shivers [16] who called it type recovery. \nLater, Pals\u00adberg and Schwartzbach [13, 12] proved that on the basis of the collected information, one \ncan define a predicate which accepts only programs which cannot go wrong. They called this safety analysis. \nThey also proved that their safety analysis accepts more programs than simple type inference. In this \npaper, we consider the following instance of the above question: Which type system accepts the same pro\u00ad \ngrams as safety analysis? The particular safety analysis we consider is defined in Section 3. Our thesis \nis that the type system that answers this specific question will in many cases also be the answer to \nthe fundamental question. 1.2 Our result We prove that a natural type system with subtyping and recursive \ntypes accepts the same programs as safety analysis. The proof involves mappings from types to flow information \nand back. The type system has been studied by Amadio and Cardelli [1], and an 0(n2 ) algorithm for deciding \nthe subtyping relation has been presented by Kozen, Pals\u00adberg, Schwartzbach, [8]. Open until now is the \nquestion of type inference. As a corollary of our result we get a type inference algorithm which works \nby first doing safety analysis and then mapping the flow information to types. The set of types can \nbe presented by the following grammar: t::=tl+tzllntlvl#v.tlTll The type system contains the following \ncomponents: the binary function type constructor +, the constant type lnt, the possibility for creating \nrecursive types, and two more constant types T, and -1-. Moreover, there is a subtype relation, written \n<. In cent rast, safety analy\u00adsis uses an abstract domain containing sets of syntactic occurrences of \nabstractions and the constant Int. In slogan-form, our result reads: Flow analysis + Safety checks = \nSimple types + Recursive types + T + -L + Subtyping Each component of the type system captures a facet \nof flow analysis: o The function type constructor + corresponds to a set of abstractions. Intuitively, \na function type is less concrete than a set of abstractions. Indeed, the other components of the type \nsystem are es\u00adsential to make it accept the same programs as the safety analysis. The constant Int is \nused for the same purpose in both systems. For simplicity, we do not consider other base types, or product \nand sum constructors, etc. Such constructs can be handled by techniques that are similar to the ones \nwe will present. . Recursive types are needed in order that safety analysis accepts all programs that \ndo not contain constants. o The constant T corresponds to the largest possi\u00adble set of flow information. \nThis type is needed for variables which can hold both a function and a base value. Intuitively, a program \nwith such a variable should be type incorrect. However, the flow-based analysis may detect that this \nvariable is only passed around but never actually used. For the type system to have that capability, \nT is re\u00adquired. o The constant 1 corresponds to the empty set of flow information. This type is needed \nfor vari\u00adables which are used both as a function and as a base value. Intuitively, a program that uses \na vari\u00adable in both these ways should be type incorrect. However, the flow-based analysis may detect \nthat  this part of the program will never be executed. For the type system to have that capability, \n1 is required. * Subtyping is needed to capture flow of in forma\u00adtion. Intuitively, if information flows \nfrom A to B, then the type of A will be a subtype of the type of B.  Palsberg and Schwartzbach [12, \n13] proved that the sys\u00adtem without 1 accepts at most as many programs as safety analysis. In this paper \nwe present the type sys\u00adtem which accepts exactly the same programs as safety analysis. This may be seen \nas a natural culmination of the previous results. 1.3 Examples Our example language is a A-calculus, \ngenerated by the following grammar: E ::=zI kz.El EIE2 lt)lSUCC~ Programs that yield a run-time error \ninclude (O r), SUCC(XZ.Z), and (SUCCO)(Z), because O is not a function, succ cannot be applied to functions, \nand (SUCCO) is not a function. These programs are not t ypable and they are rejelcted by safety analysis. \nSome programs can be typed in the type system without the use of J-and T, for example Ax.Xx :pcl.cl+ci!, \nwhere E : t means E has type t . Some programs require the use of T, for example (Af.(Ax.fI)(fo))I \n:T, where 1 = kc.z. Note that T is the only type of (Aj.(kz..fl)(.fO) ).I. Some programs require the \nuse of 1, for example Xc.x(succ x) : L + t for any t. Both type inference and safety analysis can be \nphrased as solving a system of const raints, derived from the pro\u00adgram text. We will now present the \nconstraint systems for the last of the above examples. For notational conve\u00adnience, we give each of the \ntwo occurrences of x a label so that the A-term reads Ax.xl (SUCCx2). For brevity, let E = XE.Z1 (SUCCx2). \nThe constraint system for type inference looks as follows: [E] [Succ X2] --+ [X, (succ X2)] [x,] [X2] \n[Succ X2] Int 368 Here, the symbols z, [zl], [Z2], &#38;UCC s2], [XI(SUCC s2)1, [E]are type variables. \nSolving this constraint system yields that the possible types for the A-term kz.x(succ z) are T and -1-+ \nt for any type t.Among these, L + J\u00adis a least type. In general, however, such a constraint system need \nnot have a least solution. The constraint system for safety analysis looks as follows: {E} g [E] [z,] \ng {E} ~ G [m] z g [Z2.] {E} g [z,] * [SuccX2] g z {E} g [z,] * [Z,(succ z,)] ~ [Z,(succ z,)]  {Int} \n~ [SUCCz,] [x2] C {Int} If such a constraint system is solvable, then it has a least solution. This \nparticular constraint system is indeed solvable, and the least solution is the mapping p, where P([~n) \n= {~} q([succ ZZ]) = {Int} Mbl(succ ~2)n) = p(~) = P([zl]) = P([X2]) = 0 This example will be treated \nin much further detail in Section 5.1. In the following two sections we present the type system and the \nsafety analysis, and in Section 4 we prove that they accept the same programs. In Section 5 we present \ntwo examples, and in Section 6 we outline directions for further work. The reader is encouraged to refer \nto the examples while reading the other sections.  2 The type system 2.1 Types Definition 1 Let X = \n{+, Int, 1, T} be the ranked al\u00adphabet where + is binary and Int, 1, T are nullary. A type is a regular \ntree over X. A path from the root of such a tree is a string over {O, 1}, where O indicates left subtree \nand 1 indicates right subtree . 1 Definition 2 We represent a type by a term, that is, a partial function \nt:{o,l}*+x with domain D(t)where tmaps each path from the root of the type to the symbol at the end \nof the path. The set of all such terms is denoted Tz. 0 Following [8], we finitely represent a term by \na so\u00adcalled term automaton, as follows. Definition 3 A term automaton over E is a tuple M = (Q, X, go,6,1) \n where: Q is a finite set of states,  qo G Q is the start state,  15: Q x {O, 1} + Q is a partial \nfunction called the transition function, and  / : Q + Z is a (total) labeling function,  such that \nfor any state q E Q, if l(q) G {+} then {i I c$(q,i) is defined} = {O, 1} and if l(q) E {Int, 1, T} \nthen {i I d(q, i) is defined} = O . The partial function 6 extends naturally to a partial function ;: \nQx{O,l}*+Q inductively as follows: F(q,t) = q i(q, ai) = A(i(q, a), i) , for i E {o, 1}. The term represented \nby M is the term t&#38;f = k@(@ ,~)). 0 Intuitively, tM (a) is determined by starting in the start \nstate go and scanning the input a, following t ran\u00adsitions of M as far as possible. If it is not possible \nto scan all of a because some i-transition along the way does not exist, then tM (a) is undefined. If \non the other hand M scans the entire input a and ends up in state q, then t.A,f(~) = ~(q). Types are \nordered by the subtype relation S, as fol\u00adlows. Definition 4 The parity of a G {O, 1}* is the number \nmod 2 of O s in a. The parity of a is denoted ra. A string a is said to be even if ma = Oand odd if za \n= 1. Let <0 be the partial order on X given by 1<0+ and + <0Tand L <0 Int and Int<o T  and let <1 be \nits reverse T<l-i and + <1 1 and T <1 Int and Int<l L  For s,tE Tz, define s < t if s(a) <n~ t(a)for \nall ~ ~ D(s) n D(t). 0 Kozen, Palsberg, and !3chwartzbach [8] showed that the relation s is equivalent \nto the order defined by Ama\u00addio and Cardelli [1]. The relation s is a partial order, andifs+ tss +t , \nthens s sand t<t [1,8]. 2.2 Type rules If E is a A-term, t is a type, and A is a type environment, Z.e. \na partial function assigning types to variables, then the judgement A1-E:t means that E has the type \nt in the environment A. Formally, this holds when the judgement is derivable using the following six \nrules: A1-O:lnt (1) A1-E:lnt A t-succ E : Int (2) A 1-x : t (provided A(z) = t) (3) A[zes]l-E:t AkAx.E:a*t \n(4) A1-E:sbt AI-F:s A!r EF:t (5) AI-E:s s<t AkE:t (6) The first five rules are the usual rules for simple \ntypes and the last rule is the rule of subsumption. The type system has the subject reduction property, \nthat is, if A 1-E : t is derivable and E ,f3-reduces to El, then A 1-E : t is derivable. This is proved \nby straight\u00adforward induction on the structure of the derivation of A1-E:t. Constraints Given a A-term \nE, the type inference problem can be rephrased in terms of solving a system of type con\u00adstraints. Assume \nthat E has been a-converted so that all bound variables are distinct. Let X~ be the set of A-variables \nx occurring in E, and let YE be a set of vari\u00adables disjoint from X~ consisting of one variable [F] for \neach occurrence of a subterm F of E. (The notation [F] is ambiguous because there maybe more than one \noccurrence of F in E. However, it will always be clear from context which occurrence is meant.) We generate \nthe following system of inequalities over X~ U YE: o for every occurrence in E of a subterm of the form \nO, the inequality Int < [0]; e for every occurrence in E of a subterm of the form succ F, the two inequalities \nInt s [SUCCF] [F] < Int; e for every occurrence in E of a subterm of the form Ax.F, the inequality (Z+ \n[$ ])w < [~z.Fl ; e for every occurrence in E of a subterm of the form GH, the inequality [G] < ([H] \n+ [Gll])GH ; 6+ for every occurrence in E of a A-variable x, the inequality X< [z]. The subscripts are \npresent to ease notation in Section 4,1; they have no semantic impact and will be explicitly written \nonly in Section 4.1. Denote by T(E) the system of constraints generated from E in this fashion. The solutions \nof T(E) over Tx correspond to the possible type annotations of E in a sense made precise by Theorem 5. \nLet A be a type environment assigning a type to each A-variable occurring freely in E. If ~ is a function \nassigning a type to each variable in XE U YE, we say that ~ extends A if A and $ agree on the domain \nof A. l?heorern 5 The judgement A h E : t is derivable if and only if there exists a solution 4 of T(E) \nextending A such that @([.E]) = t. In particular, if E is closed, then E is typable with type t if and \nonly if there exists a solution ~ of T(E) such that ~([E] ) = t. Proof. Similar to the proof of Theorem \n2.1 in the journal version of [9], in outline as follows. Given a solution of the constraint system, \nit is straightforward to construct a derivation of A 1-M: t. Conversely, ob\u00adserve that if A 1-M : t is \nderivable, then there exists a derivation of A F M: t such that each use of one of the ordinary rules \nis followed by exactly one use of the subsumption rule. The approach in for example [19, 13] then gives \na set of inequalities of the desired form. 0  3 The safety analysis Following [12, 13], we will use \na flow analysis as a basis for a safety analysis. Given a A-term E, assume that E has been a-converted \nso that all bound variables are distinct. The set Abs(E) is the set of subterms of E of the form XE.F. \nThe set Cl(E) is the powerset of Abs(E) U {Int}. Safety analysis of a hterm E can be phrased as solving \nthe following system of constraints over XE U YE where type variables range over Cl(E). e For every occurrence \nin E of a subterm of the form O, the constraint {Int} ~ [0] ; forevery occurrence in Eof asubtermof \nthe form SUCCF, the two constraints {Int} ~ [SUCCF] [F] ~ {Int} where the latter provides a safety check; \nc forevery occurrence in.Eofa subtermof the form XZ.F, the constraint ({ AX.F})A..F s [A$.ql ; for every \noccurrence in E of a subterm of the form GH, the constraint [G] q (Abs(E))GH ; which provides a safety \ncheck; for every occurrence in E of a A-variable z, the constraint z g [Z];  for every occurrence \nin E of a subterm of the form Ax.F, and for every occurrence in E of a subterm of the form GH, the constraints \n ({kC.F})AZ.F Q [G] + [H] G z ({~z.~})~z.~ G [G] + [F] C UGH] . Again, the subscripts are present to \nease notation in Section 4.1; they have no semantic impact and will be explicitly written only in Section \n4.1. Denote by C(E) the system of constraints generated from E in this fashion. A solution of C (E) assigns \nan element of Cl(E) to each type variable such that all con\u00adstraints are satisfied. Solutions are ordered \nby variable\u00adwise set inclusion. See [12, 15] for a cubic time algo\u00adrithm that given E computes the least \nsolution of C(E) or decides that none exists. See [11] for a proof of the following subject reduction \nproperty. If E ~-reduces to E , and C(E) has solution q, then C(E ) also has solution ~.  4 Equivalence \n 4.1 Deductive Closures We now introduce two auxiliary constraint systems called 6(E) and 7(E). They \nmay be thought of as deductive closures of C(E) and T(E). We then show that they are isomorphic (Theorem \n9). Definition 6 For every ~-term E, define ??(E) to be the smallest set such that: The non-conditional \nconstraints of C(E) are mem\u00adbers of U(E).  If a constrain~c ~ K is in C(E) and c is in C(E), then K \nis in C(E).  Fors6XE UYE, if7 ~sands~t both arein P(E), then r C tis in G(E).  Notice that every constraint \nin 7(E) is of the form W ~ W , where W is of the forms V, {Int}, or ({k.F})~~.F, and where W is of the \nforms V, {Int}, or (Abs(E))G~, fOrV ~XE UYE. c1 Definition 7 For every A-term E, define T(E) to be the \nsmallest set such that: T(E) ~ T(E).  If (s + t)~~,~ < (s + t )GH is in T(E), then s < sand ts t are \nin T(E).  Fors6XEUY_, ifr< sands <t both arein T(E), then r < tis in T(E).  Notice that every constraint \nin T(E) is of the form W < W where W is of the forms V, Int, or (V + V )a~.~, and where W is of the form \nV, Int, or (V + V )GII, for V,V ~ XE UYE. 1 We will now present the definition of two functions Z a~d \n7, one from U(E) to T(E) and one from T(E) to C(E). After the definition we prove that they are well-defined \nand each others inverses. Definition 8 The functions Z : U(E) + T(E) J : ??(E)+ U(E)  are defined as \nfollows. T(w g w ) = (z=(w) < LZ(w )) J(W < w ) = (Z.y(w) c Lfl(w )) where the functions LX and LJ are: \n(w ifWgX~UY~ Int if W = {Int} Zz(w) = (z + [FJ)A..F if W = ({ Az.F})k.17 ([H] + [GH])GII if W = (Abs(E))GH \n{ w ifW~XEUYE {Int} if W = Int 7(W) = ({ AX. F})~z.F if w = (z + [F])Ao (Abs(E))G~ if W = ([H] + [GH])GII \n{ 1 Theorem 9 The sets G(E) and T(E) are isomorphic, and Z and J are bisections and each others inverses. \n PToof. If Z and J are well-defined, then clearly they are i~verses of each other and thus bisections, \nso ~(E) and T(E) are isomorphic. First we show that Z is well-defined. We proceed by induction on the \nconstruction of O(E). In the base case, consider the non-conditional constraints of C(E) and observe \nthat for those we have: C(E) T(E) {Int} C [0] Int < [0] {Int} G [succ F] Int < [succ F] [.F ] C {Int} \n[F] < Int ({ Ax.F})w ~ [~x.F] (X+ [F])~z.F < [~xFl [G] C (Abs(E))G~ [G] s ([:\\~xGH])w $ g [x]  It \nfollows that the lemma holds in the base case. In the induction step, consider first the constraints \n({k.F}),x.~ C [G] * [~] C x ({ Ax. F})Az.F C [G] * IF] C [G~] in C(E) and suppose ({~x.$ })~~.~ g [G] \nis in ~(E). By the induction hypothesis, (% + [~])~~.~ < [G] is in T(E). Moreover, [G] < ([H] + [GH])GH \nis in T(E) and thus also in T(E). Hence, (z + [F])~z.F < ([H] + UGHIl)GiZ $ in T(E), so also [H] < x \nand [F] < [GH_] are in T(E). Consider then r C s and s ~ tinU(E), and suppose s E XE U YE. By the induction \nhypothesis, -CT(T) S ,CI(S) and Lz(s) < Lx(t) are in T(E). fiom~ c XE U YE we get ~z(s) = s, so ~z(T) \n< ~z(t) is in 7 (E). Then we show that J is well-defined. We proceed by induction on the construction \nof T(E). In the base case, consider the constraints of T(E). Using the same table as above we observe \nthat Y is well-defined on all these constraints. In the induction step, consider first (X --+ [~] )~z.F \n< ([H] + [G~])GH in T(E). It is sufficient to prove that ,C7([H]) C .Cf(x) and ,C7([F]) G ,C7([GH]) are \nin G(E), or equivalently, that [If] C x and [J ] Q [G~] are in U(E). In C(E) we have ({~x.~})w s [G] \n+ [~] G z ({~z.F})~z.F ~ [G] * [F] C [GH] . Moreover, ({ Ax. F})~z.F G [G] ~S in C(E). Hence, [H] Q \nz and [F] G [G.H] are in c(~). Consider then T < s and s < tin T(E), and suppose s ~ X~ u YE. By the \ninduction hypothesis, L,y(r) Q ,C7(S) and L2(s) G .Zr(t)are in V(E). From s c XE UYE WE! @ ~y(S) = S, \nSo ~~(~) G ~f(~) k k C(E). 1 4.2 The equivalence proof Definition 10 For every A-term E, let Tmap(E) \nbe the set of total functions from X~ U YE to TZ and let Cmap(E) be the set of total functions from XE \nU YE to Cl(E). 0 The following construction is the key to mapping flow information to types. Definition \n11 For every A-term E, p e Cmap(E), and gO c Cl(E), define the term automaton A(E, p, qo) as follows: \nA(E, p,qo) = (cl(E), ~, go, d> ~) where: 6({ AX1.EI, . . . . ~xm.Em}, O) = n;=l ff(zi) forn>O e f5({kl.El, \n. . . . km.En}, 1) = I_J;=l wUEzl forn>O  J_ ifq=O Int if q = {Int} l(q) = + ifq~Abs(E)Aq#@ T otherwise{ \n0 Lemma 12 Suppose ~ ~ Cmap(.E) and S1, S z c Cl(E). I.f S1 C S2, then t~(~,p,sl) S ~Ap3,v,s,). Proof. \nDefine the orderings GO, S1 on Cl(E) such that Go equals ~ and G1 equals 2. The desired con\u00adclusion follows \nimmediately from the pro~erty that if a ~ ~(t~(E,v,S1)) (1 ~(tdtJJ,W,Sz)), then 6(S1, ~) ~~~ F(S2,CY). \nThis property is proved by straightforward induction on the length of a. 1 We can now prove that the \ntype system and the safety analysis accept the same programs. Theorem 13 FOT every A-term E, the following \nseven conditions are equivalent: 1. C(E) is solvable. 2. T(E) is solvable. 3. T(E) is solvable. ~. \nU(E) is solvable.  5. C(E) does not contain constraints of the forms {Int} G Abs(E) or {Az.F} s {Int}. \n 6. T(E) does not contain constraints of the forms Int<V+ V orV+ V <Int, whereV,V = XEU YE. 7. The function \n ~V.{ k I the constraint {k} ~ V is in C(E) } is the least solution of C(E). Proof. Given a A-term \nE, notice that by the isomor-For a constraint of the form {Int} ~ V, it follows that phism of Theorem \n9, (5) ~ (6). To show the remaining Int < V is in T(E). Since T(E) has solution ~ we get equivalences, \nwe proceed by proving the implications: that (~(V) )(.E) c {Int, T}. Thus, F(V) is either {Int} or Abs(E) \nU {Int}, and hence {Int} ~ V has solution ~. (1)* (2)+ (3)+ (4)+ (5)* (7)* (1) To prove (4) a (5), observe \nthat constraints of the forms {Int} ~ Abs(E) or {/lx.. F }c {Int} are not solv-To prove (1) # (2), suppose \nC(E) has solution P E able. Crnap(E). Let f be the function ~s.tA(E,w,S)define and To prove (5) ~ (7), \nsuppose ~(E) does not contain v E Tmap(E) by@ = ~ op. We will show that Z (E) constraints of the forms \n{Int} ~ Abs(E) or {Ay.F} ~ has solution ~. We consider each of the constraints in {Int}. Define turn. \nThe cases of the constraints generated from sub\u00adterms of the forms O, succ E, ~ are immediate, by us\u00adq \n= jiV.{ k / the constraint {k} ~ V is in ~(.E) } ing Lemma 12. Consider then Az.F and the constraint \nx + [F] < [AZ.F ]. By Lemma 12 we get We proceed in four steps, as follows. 1)(z) + ?)([F]) = f({km}) \n< 7J([kc.F]) . First we show that @ is a solution of G(E). We consider in turn each of the seven possible \nforms Consider then GH and the constraint [G] < [H] + of constraints in U(E). Constraints of the forms \n[GH]. We know that p([G]) ~ Abs(E) so there are {Int} ~ {Int} and {Az..F} ~ Abs(E) have any so\u00adtwo cases. \nSuppose first that y([G]) = 0. We then lution, including p . We are thus left with con\u00ad have ~([G]) = \nJ_ < @([H]) + ~([GH]). Consider straints of the forms {Int} ~ V, V ~ V , V Q then the case where p([G]) \n= {Azl ..El,. . . . kz~.En}, {Int}, {k.F} ~ V, V ~ Abs(E), where V, V E for n >0. We then have that yJ([H]) \n~ ~([zi]) and XE U YE. We will treat just the first three, since P~Et]) Q P([G~l) for i G {1,.. .,n}. \nThus, P([H]) C case four is similar to case one and since case five ~i;,;~~~]) and UL WE]) C P([GHI). \nSO, by is similar to case three. For a constraint of the 7 form {Int} Q V, notice that Int c w (V), so \nthe constraint has solution @. For a constraint oft he 4J([GI) = f(P(UW) form V ~ V , suppose k G p (V). \nThen the con\u00adstraint {k} ~ V is in ??(E)L and hence the con\u00adstraint {k} c V is also in C (E). It follows \nthat ~=i ia k ~ p (V ). For a constraint of the form V ~ {Int}, S f(w([~l)) + f(MIGHl)) suppose it does \nnot have solution @. Hence, there = WWl) -+ +([GW exist k ~ @(V) such that k # Int. It follows that the \nconstraint {k} ~ V is in ~(E)~and hence the To prove (2) a (3), suppose Z (E) has solution @ constraint \n{k} C {Int} is also in C(E), a contra\u00adTmap(E). It is sufficient to show that T(E) has solution dict ion. \n $, and this can be proved by straightforward induction on the construction of T(E). Next we show that@ \nis the least solution of G(E). To prove (3) + (4), suppose T(E) has solution o G To do this, let p be \nany solution of ??(E) and sup\u00adTmap(E). Define ~ G Cmap(E) as follows: pose V E XE U YE. It is sufficient \nto prove that P (V) ~ 9(V). Suppose k c P (V). Then the con\u00ad0 if (@(V))(E) = J_ straint {k} C V is in \nV(E). Since p is a solution {Int} if (*(V))(6) = Int of U(E), k 6 (P(V). P(V) = Abs(E) if (+(V))(6) = \n+ Next we show that @ is a solution of C (E). Con\u00adAbs(E) U {Int} if (~(V))(~) = T { sider first the \nnon-conditional constraints of C(E). We will show that ~(E) has solution F. To see this, let Since these \nconstraints are also members of C(E), they have solution q . Consider then {Az..F} c W C Z be a constraint \nin ~(l?). If it is of the forms {Int} g {Int} or {Az.1 } c Abs(E), then it is solvable V + K in C(E) \nand suppose {Az.F} C V has by all functions, including F. For the remaining cases, solution p . Then \nby the definition of p , we have notice that by Theorem 9, .&#38;-(W) < LZ(Z) is in T(E) that {A%.F} \n~ V is in ~(E), so also K is in V(E), and thus it has solution $. This means that W ~ Z can-and hence \nK has solution p . not be of the forms {Int} C Abs(E) or {A$.F} ~ {Int}. Finally we show that @ is the \nleast solution of Suppose then that W C Z is of one of the remain-C(E). To do this, let p be~ny solution \nof C(E). ing forms, that is, {Int} g V, V ~ V , V < {Int}, Then p is also a solution of C(E), as can \nbe proved {k.F} ~ V, V ~ Abs(E), where V, V E X~ U YE. We by straightforward induction on the construction \nwill treat just the first of them, the others are similar. of C(E). Since @ is the least solution of \n~(l?), @ is smaller than ~. To prove (7) * (l), simply notice that since C(E) has a solution, it is \nsolvable. 0 Corollary 14 The type system accepts the same pro\u00adgrams as the safety analysis. 4.3 Algorithms \nAs corollaries of Theorem 13 we get two cubic time algo\u00adrithm:. Given a A-term E, first observe that \nboth ~(E) and T(E) can be computed in time O(n3 ) where n is the size of E. We can then easily answer \nthe following two questions: o Question (safety): Is E accepted by safety anal\u00adysis? Algorithm: Check \nthat U(E) does not contain con\u00adstraint of the forms {Int} ~ Abs(E) or {Az.F} ~ {Int}. o Question (type \ninference): Is E typable? If so, what is an annotation of it? Algorithm: Use the safety checking algorithm. \nIf E turns out to be typable, we get an annotation by first calculating the two functions  p = AV.{ \nk I the constraint {k} ~ V is in C(E) } and f = ~s.~A(E,v,S) and then forming the composition += fop \n. This function @ is a solution of T(E). The question of type inference has been open until now. In \ncontrast, it is well-known that flow analysis in the style discussed in this paper can be computed in \ntime 0(n3).   5 Examples We will illustrate the proof of equivalence with two ex\u00adamples. The A-terms \nthat will be treated are kc.z(succ z), which was also discussed in Section 1, and (Az.zx)(AY.Y). 5.1 \nkc.z(succ z) As in Section 1, we give each of the two occurrences of x a label so that the A-term reads \nAz.zl (SUCCX2). For brevity, let E = k.zI (SUCCx2). Notice that Abs(E) = {E}. As stated in Section 1, \nC(E) looks as follows: {E} G [E] [z,] G {E} z g [Zl] z G [Z2] {E} ~ [%1] + [SUCC $,] ~ z {E} ~ [xl] + \n[Z,(SUCC X2)] ~ [$,(SUCC X2)] {Int} ~ [succ W] [z,] C {Int} The deductive closure U(E) looks as follows: \n{E} s [E] [z,] ~ {E} ~c [d ~G [~2] {Int} ~ [SUCCz,] [z2] ~ {Int} z C {E} z ~ {Int} Intuitively, this \ndeductive closure is obtained by observ\u00ading that no constraint matches the condition of any of the two \nconditional constraints, and by using the tran\u00adsitivity rule twice. As also stated in Section 1, T(E) \nlooks as follows: z + [sl (SUCCZ2)] < [E] [z,] < [Succ q] + [Z,(succ Z2)] z < [q] ~ 5 [~211 Int < [succ \nz2] [z2] < Int The deductive closure ~(E) looks as follows: z + [Xl (SUCC Z2)] < [E] [z,] < [Succ x,]+ \n[Z,(succ z,)] z < [Zl] x s [Z2] Int ~ [succ W] [32] < Int z < [Succ Z2] + [q (Succ m)] z < Int This \ndeductive closure is obtained by using the transi\u00adtivity rule twice. It can be verified by inspection \nthat Theorem 9 is true for E, that is, U(E) and T(E) are isomorphic. Moreover, ~(lil) does not contain \nconstraints of the forms {Int} c Abs(E) or{kc.~} G {Int}, and~(l?) does not contain constraints of the \nforms Int < V + V or V + V < Int, where V,V G X~ uY~. We are now ready to focus on the equivalence proof. \nWe will go through that proof and illustrate each con\u00adstruction in the case of E. The equivalence proof \nmay be summarized as fol\u00adlows. The proof demonstrates several instances of how to transform a solution \nof one constraint system into a solution of an other constraint system. It may be helpful to think of \na step as transforming the output of the previous step, as follows. The starting point is a solution \np of C(E). This q is then transformed into a solution @ of Z (E). This @ is also a solution of T(E), \nand it is then transformed into a solution ~ of C(E). Having such a solution implies that certain constraints \nare not in ~(E) (condition 5), and also that certain constraints are not in T(E) (condition 6). The function \n~ need not be a solution of C(E), but we can construct the least solution of C(E) from C(E). In one picture, \nthe transformations go as follows: (p --+?)-+ P We will now follow a particular p as it tours this dia\u00adgram. \nAs starting point, we choose the least solution p of C (E) which was also stated in Section 1. It looks \nas follows: P([EI) = {E} p([succ ZZ]) = {lnt} P(uzl (Succ ~2)n) = v(~) = P([31]) = P([Z2]) = 0 To get \nthe solution ~ of T (.E), we need to construct the function ~S.t~(E,9,S) and compose it with q. The automaton \nA(E, p, S) can be illustrated as follows: T Int+e {E} 0 {;, Int} {I:t} Notice that we have not pointed \nto the start state; it is a parameter of the specification, The illustration gives both the name and \nthe label of each state. There are just two transitions, both from the state {E} to the state 0. Observe \nthat 1+1 if S= {E} Int if S = {Int} ~A(E,%s) = 1 ifS=O { We can then obtain the mapping ~: +([-73]) \n= L + J\u00ad @([succ 2zJJ) = Int Wlw(succ Z2)]) = @(z) = +([$1]) = q!4p2.]) = L It can be verified by inspection \nthat $ is a solution of Z (E) and T(E). To get the solution F of G(E), we need to compute (O(v))(c) for \nevery V c XE u YE. For example, (@([El))(~) = (-L+ L)(6) = + Plugging this into the definition of ~ yields: \nP([EI) = {E} p([succ w]) = {Int} F([w(succ $2)]) = P(z) = F(ud) = wl~21) = 0 So, p = ~, andi_t can \nbe verified by inspection that ~ is a solution of C(E). Finally, to construct @ where p = JV.{ k I the \nconstraint {k} G V is in ~(E) } notice that the constraints in U(E) that have the form {k} ~ V where \nV GXE UYE are: {E} ~ [E] {Int} ~ [succ ZZ] So, p = P = q , and hence @ is the least solution of C(E). \nIt is only in special cases that p = F. Next we consider a slightly more complicated example where this \ndoes not occur. 5.2 (Ax.zz)(AY.Y) We give each of the two occurrences of x a label so that the A-term \nreads (Ax.xl Z2 )(}y.y). For brevity, let E = (kE.zI%z)(~y.y). Notice that Abs(E) = {Xz.zlzz, Ay.y}. \nThe constraint system C(E) looks as follows: AX.X1X2 Ay.y E X1X2 xl X2 Y XI X2 and 1X.X1X2 X1X2 and \nAy.y E and AX.X1X2 E and Ay.y  To the left of the constraints, we have indicated from where they arise. \nThe constraint system T(E) looks as follows: From Ax.xl x2 does not contain constraints of the forms \nInt < V + V From Ay.y or V + V < Int, where V,V c .~E UYE. From E As for the previous example, we will \nnow go through From x12h the equivalence proof and illustrate each construction From XI in the case of \nE. From X2 As starting point, we choose the least solution p of From y C(E). It looks as follows: The \ndeductive closures G(E) and ~(E) look as fol-{Ax.xIx2} if V = [Ax.xIx2] w ) = {~y.y} lows. otherwise \n{ To get the solution IJ of T(E), we need to construct the function and compose it with p. ~s.t~(E,9,s)The \nautomaton A(E, p, S) can be illustrated as follows: y -+ [y] < py.y] 0,1 y+[y]<x y --+ [y] < [xl] y \n-+ [y] < [X2] -+ [X1X2] y + [y] < [X2] y+[y]<y {Ax} {Ay} {Ax, Ay} y -+ [y] < [y] y --+ [y] < [X1X2] y \n-+ [y] < [E] 10 Into [Ay.y] < x 0 {Int} [Ay.y] < [x,] [Ay.y] < [X2?] -+ [X,X2] [Ay.y] < [X2] TT T \nu~Y.Yl 5 Y IPY.YI s [Y] {k, Ax} {k, Ay} {Int, fx, Jy} [Ay.y] < [X1X2] As before, notice that we have \nnot pointed to the [Ay.y] < [E] start state; it is a parameter of the specification. Notice also that \nwe have abbreviated the names of some of the states. Observe that t~(~,v,s) = ,ua.a + a, if S is a non-empty \nsubset of {Ax.xl X2, Ay.y}. We can then obtain the mapping ~. It is a constant function: It can be verified \nby inspection that ~ is a solution of [X2] gy T(E) and T(E). [X2] g [y] As an aside, note that although \nV(V) is an infinite [x,] g [x,x,] tree for all V, there are other solutions of T(E) and [X2] g [E] T(E) \nwhere all the involved types are finite. For exam\u00ady g [y] ple, consider the solution @ where y c [m~z \n1 y s [E] #([~z.x1x2]) = (T --+ T) + T [Y] s [X1X21 + ([~Y.Y]) = + (x) = + ([xI]) = T + T IIYI G [El \n[X,X2] g [E] 7+4 ([X2]) = W(Y) = @ ([Y])= #([w~2n) =~ ([E]) = T It can be verified by inspection that \nTheorem 9 is true for E, that is, U(E) and T(E) are isomorphic. To get the solution F of U(E), observe \nthat Moreover, ~(E) does not contain constraints of the forms {Int} ~ Abs(E) or {Ax.F} g {Int}, and T(E) \n Plugging this into the definition of ~ yields that ~ is a constant function: P(V) = Abs(_E) Notice \nthat p #~. It can be verified by inspection that @is a solution of O(E). Finally, to construct @ where \np = AV.{ k I the constraint {k} ~ V is in V(E) } notice that the constraints in V(E) that have the form \n{k} CV where VcX~ UYE are: {kc.i-c,r,} g [Az.z,z,] {Ay.y} g [Ay.y] {Ay.y} g z {Ay.y} g [$,] {Ay.y} G \n[%,] {Ay.y} ~ y {Ag.y} g [g] {Ay.y} g [Z,z,] {Ay.y} g [E]  So, p = p , and hence @ is the least solution \nof C(E).  Conclusion We have described a type system and a flow analysis and proved that the corresponding \ntypability and safety problems are equivalent. We also obtained a cubic time algorithm for typability. \nThis problem has been open since the type system was first presented by Amadio and Cardelli in 1991 [1]. \nFor a given program, the system of type constraints and the system of flow constraints are radically \ndiffer\u00adent. For the particular language studied in this paper, however, we demonstrated that the deductive \nclosures of those systems are isomorphic. This property does not seem to be either a necessary or a sufficient \ncondi\u00adtion for the equivalence result, but in itself it suggests a close relationship between the systems. \nWe expect that various extensions to the type sys\u00adtem and flow analysis will also have equivalent typabil\u00adity \nand safety problems. The addition of polymorphic let, conditionals, products, sums and atomic subtypes \nwith coercions should be straightforward. Dynamic or soA typing systems are also candidates for formulating \nequivalent type and flow analysis systems. A different challenge is to formulate a type system equivalent \nto the safety analysis for object-oriented lan\u00adguages presented in [15]. Yet another challenge is to \nfind two equivalent binding-time analyses, one based on type systems and one based on flow analysis. \nResults in this direction were presented in [14]. Tang and Jouvelot [17] has demonstrated that type analysis \nand flow analysis can be combined in a sin\u00adgle framework. The type system part of their approach is that \nof simple types. A challenge is to extend their framework such that the type system part is that of this \npaper. Wand and Steckler [20] presented a framework for proving correctness of flow-based compiler optimiza\u00adtion. \nA challenge is to investigate if their framework can be simplified when the flow analysis is replaced \nby for example the framework of Tang and Jouvelot [17] or possibly an extended one. An example of an \narea in which a relationship be\u00adtween a typing problem and a flow problem may be helpful is debugging \nand explaining type in ferencing re\u00adsults for end users. A flow analysis point of view might provide \na concrete illustration of why the type infer\u00adence produced a particular type assignment or typing error \n[18]. The two systems considered in this paper use in\u00adequalities, that is, subtyping in the type system \nand set inclusion in the flow analysis. One might consider changing the inequalities to equalities and \nlook for an equivalence result similar to the one on this paper. On the type system side, this would \nresult in a simply-typed lambda-calculus with a type inference algorithm based on unification. On the \nflow analysis side, it would result in an analysis resembling the one of Bondorf and J@r\u00adgensen [5]. \nCurrent work addresses obtaining an equiv\u00adalence between two such systems [7]. In conclusion, we find \nthat a type system and a flow analysis can in some cases be equivalent ways of looking at the same problem. \nAcknowledgements The authors thank Mitchell Wand for encouragement and helpful discussions. The results \nof this paper were obtained while the first author was at Northeastern Uni\u00adversit y, Boston. References \n[1] Roberto M. Amadio and Luca Cardelli. Subtyping recursive types. ACM Transactions on Program\u00adming \nLanguages and Systems, 15(4) :575 631, 1993. Also in Proc. POPL 91. [2] Torben Amtoft. Minimal thunkification. \nIn Proc. WSA 93, pages 218-229, 1993. [3] Andrew W. Appel. Compiling with Continuations. Cambridge University \nPress, 1992. [4] Anders Bondorf. Automatic autoprojection of higher order recursive equations. Science \nof Com\u00adputer Programming, 17(1 3) :3 34, December 1991. [5] Anders Bondorf and Jesper J@rgensen. Efficient \nanalyses for realistic off-line partial evaluation. Journal of Functional Programming, 3(3):315-346, \n1993. [6] Charles Consel. A tour of Schism: A partial evalua\u00adtion system for higher-order applicative \nlanguages. In Proc. PEPM 93J Second ACM SIGPLAN Sym\u00adposium on Partial Evaluation and Semantics-Based \nProgram Manipulation, pages 145-154, 1993. [7] Nevin Heintze. Personal communication. 1994. [8] Dexter \nKozen, Jens Palsberg, and Michael I. Schwartzbach. Efficient recursive subtyping. Math\u00adematical Structures \nin Computer Science. To appear. Also in Proc. POPL 93, Twentieth An\u00adnual SIGPLAN SIGACT Symposium on \nPrinci\u00adples of Programming Languages, pages 419-428, Charleston, South Carolina, January 1993. [9] Dexter \nKozen, Jens Palsberg, and Michael L Schwartzbach. Efficient inference of partial types. Journal of Computer \nand System Sciences, 49(2):306-324, 1994. Also in Proc. FOCS 92, 33rd IEEE Symposium on Foundations of \nComputer Science, pages 363 371, Pittsburgh, Pennsylvania, October 1992. [10] Tsung-Min Kuo and Prateek \nMishra. Strictness analysis: A new perspective based on type infer\u00adence, In Proc. Conference on Functional \nProgram\u00adming Languages and Computer Architecture, pages 260-272, 1989, [11] Jens Palsberg. Closure analysis \nin constraint form. ACM Transactions on Programming Lan\u00adguages and Systems. To appear. Also in Proc. \nCAAP 94, Colloquium on Trees in Algebra and Programming, Springer-Verlag (LNCS 787), pages 276-290, Edinburgh, \nScotland, April 1994, [12] Jens Palsberg and Michael I. Schwartzbach. Safety analysis versus type inference. \nInformation and Computation. To appear. [13] Jens Palsberg and Michael I. Schwartzbach. Safety analysis \nversus type inference for partial types. in\u00adformation Processing Letters, 43:175-180, 1992. [14] Jens \nPalsberg and Michael I. Schwartzbach. Binding-time analysis: Abstract interpretation ver\u00adsus type inference. \nIn Proc. ICCL 94, Fifth IEEE International Conference on Computer Languages, pages 289 298, Toulouse, \nFrance, May 1994. [15] Jens Palsberg and Michael I. Schwartzbach. Object-Oriented Type Systems. John \nWiley &#38; Sons, 1994. [16] Olin Shivers. Data-flow analysis and type recov\u00adery in Scheme. In Peter \nLee, editor, Topics in Advanced Language Implementation, pages 47-87. MIT Press, 1991. [17] Yan Mei Tang \nand Pierre Jouvelot. Separate ab\u00adstract interpretation for control-flow analysis. In Proc. TA CS 94, \nTheoretical Aspects of Computing Sofware, pages 224-243. Springer-Verlag (LNCS 789), 1994. [18] Mitchell \nWand. Finding the source of type er\u00adrors. In Thirteenth Symposium on Principles of Programming Languages, \npages 38-43, 1986. [19] Mitchell Wand. Type inference for record concate\u00adnation and multiple inheritance. \nInformation and Computation, 93(1):1-15, 1991. [20] Mitchell Wand and Paul Steckler. Selective and lightweight \nclosure conversion. In Proc. POPL 94, l?lst Annual Symposium on Principles of Program\u00adming Languages, \npages 434 445, 1994.  \n\t\t\t", "proc_id": "199448", "abstract": "<p>Flow-based safety analysis of higher-order languages has been studied by Shivers, and Palsberg and Schwartzbach. Open until now is the problem of finding a type system that accepts exactly the same programs as safety analysis.</p><p>In this paper we prove that Amadio and Cardelli's type system with subtyping and recursive types accepts the same programs as a certain safety analysis. The proof involves mappings from types to flow information and back. As a result, we obtain an inference algorithm for the type system, thereby solving an open problem.</p>", "authors": [{"name": "Jens Palsberg", "author_profile_id": "81100375570", "affiliation": "Computer Science Department, Aarhus University, DK-8000, Aarhus C, Denmark", "person_id": "PP39040032", "email_address": "", "orcid_id": ""}, {"name": "Patrick O'Keefe", "author_profile_id": "81100336868", "affiliation": "151 Coolidge Avenue #211, Watertown, MA", "person_id": "P220554", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199533", "year": "1995", "article_id": "199533", "conference": "POPL", "title": "A type system equivalent to flow analysis", "url": "http://dl.acm.org/citation.cfm?id=199533"}