{"article_publication_date": "01-25-1995", "fulltext": "\n Extensional Polymorphism Catherine Dubois Frangois Rouaix Pierre lVeis Universit4 Evry Val d Essonne \nand INRIA Rocquencourt Abstract We present the extensional polymorphism, a framework to type check ad \nhoc polymorphic functions. This formalism is compatible with parametric polymorphism, and supports a \nlarge class of functions defined by structural pattern match\u00ad ing on types. KEYWORDS: genericity, polymorphism, \nad-hoc polymorph\u00adism, type checking, debugging, dynamics, ML, Carol, functional language. 1 Introduction \nThe ML type system features parametric polymorphism. Unfortunately this powerful mechanism is not sufficient \nin practice: we need polymorphic functions that do not be\u00adhave uniformly, executing different pieces \nof code according to the type of their arguments (we call this kind of functions the generic functions). \nThis form of polymorphism is often called overloading or ad-hoc polymorphism and is featured in most \nprogramming languages, even those statically type checked: generic functions in Lisp [5, 4] or Scheme \n[16], pre\u00addefine overloaded operators in Pascal[ll], genericity and user-defined overloading in Ada[20], \ntype case in Modula\u00ad3[15], predefine overloading and eq types in SML[14], static overloading in Caml[21], \ntype classes in Haskell[lO], overloading schemes in A1co01[17]. Unlike parametric polymorphism, ad-hoc \npolymorphism has many variations: e Monomorphic generic functions are defined on several different incompatible \nmonomorphic types (e.g. arith\u00admetic routines in SML). Semi-polymorphic generic functions can be defined \non data types with type parameters (e.g. a length func\u00adtion applicable to strings, or lists or arrays \nof values of any monomorphic type).  Fully polymorphic generic functions can also be ap\u00adplied to polymorphic \ntypes, and may be defined for  Author s address: dubois@live. umu-em-y. fT, Univemiti d Em-y Val d Essonme, \n910.25 Ew-y Cedex, Francozs. RouaizOmtia.fr, Paem-e. Weis&#38;nria.fr, INRIA, BP 105, 78155 Le G hesnay \nPermission to copy wfthout fee all or part of this material is granted provided that the copies are not \nmade or distributed for direct commercial advantage, the ACM copyright notice and the titie of the publication \nand its date appear, and notice is given that copying is by permission of the Association of Computing \nMachinery. To copy otherwise, or to republish, requires a fee andor specific permission. POPL 951/95 \nSan Francisco CA USA @ 1995 ACM 0-89791-692-119510001 ....$3.50 all types via a default behavior (the \nprint or equal primitives may fall into this category). To our knowledge, no ML-like system offers fully \npoly\u00admorphic generic primitives (except hard wired equality in SML, or print in Carol V3. 1). This is \nnot even available in systems featuring powerful ad-hoc polymorphism such as Alcool or Haskell, despite \ntheir complex type and class sys\u00adtems. We present the extensional polymorphism framework as a solution \nto provide fully polymorphic generic functions. Since extensional polymorphism is entirely compatible \nwith parametric polymorphism, it can be seen as an extension of ML that gives a clean and practical way \nto handle ad hoc primitives such as equality and input/output functions (in particular, the type system \nsupports a polymorphic printing procedure that prints any value in any context). Moreover, extensional \npolymorphism gives way to a new kind of functions defined inductively on types. As para\u00admetric polymorphic \nfunctions discriminate their argument via structural pat tern mat thing on values, these extension\u00adally \npolymorphic functions discriminate their argument via structural pattern matching on types. These generic \nfunc\u00adtions can be defined via a new syntactic construct by a set of clauses, each clause associating \nan expression to a possible type of the function. This leads to a powerful overloading scheme. We define \na large class of generic functions for which strong typing is decidable: a static verification algorithm \nchecks that every generic function is called on a type for which it is defined. In addition, we prove \nthat this checking problem for unrestricted generic functions is undecidable. The remainder of this paper \nis organized as follows. Sec\u00adtion 2 gives some intuitive ideas about extensional polymor\u00adphism and generic \nfunctions mechanism. Section 3 formally defines the type system for extensional polymorphism, and its \nassociated type reconstruction algorithm is given in sec\u00adtion 4. Section 5 describes how to translate \nML with ex\u00adtensional polymorphism into ML with run-time types. Sec\u00adtion 6 starts the study of user-defined \ngeneric functions: the generic syntactic construct is introduced and its associated typing and translation \nrules are stated. Static checking of generic function calls is then studied in section 7, and the class \nof well-founded programs for which this problem is decidable is defined. Section 8 is devoted to coherence \nof programs: in presence of generic functions, the semantics of programs may depend on the typing derivation \nused to get the principal type (this is related to the problem of over\u00adloading resolution). Section 9 \nbriefly discusses related work, and section 10 gives some concluding remarks. 2 Informal presentation \nPrint: a case study Our framework supports fully polymorphic generic func\u00adtions. Let us give an intuitive \nidea of our method with the print casestudy. Inany MLsystem, there exists ageneral purpose print primitive \nas part of the interactive system: print writes its argument v using a recursive descent in v, guided \nbyarecursive descent inthetypeofv, This manda\u00adtory type parameter is provided by the type checker at \nthe end of each phrase. To provide the same functionality in arbitrary expressions, we just need to provide \nthe type of a value as an extra argument to a function call, when required. Technically, we introduce \nin the type checking algorithm a new kind of type variables called dynamic type variables. In addition \nwe define a translation scheme for expressions with dynamic type variables into ML with run-time representa\u00adtion \nof types. So our generic selection is based on implicit type parameter (no dictionaries as in Haskell, \nno tags as in Lisp, no dynamic values [2, 1] as in Carol [13]). In our framework, the print primitive \nis declared with the type scheme 6 -> unit, universally quantified over the dynamic type variable 6. \nThis means that print is a poly\u00admorphic function, which can be applied to any value of any type, but \nthis type must be available at run-time. Intu\u00aditively, print has two parameters, a value and its type, \nand displays the value according to the type in the same way as the interactive print primitive. The \ntype checker provides static information about dynamic types, which are used by the translator to add \nextra type parameters, and to pass them along when necessary. For instance, when typing the expression \nprint 1, the type checker assigns the type int -> unit to print, and the value <<int >> is provided as \nan extra argument to print. Double brackets are used to de\u00adnote run-time representations of static types: \n<<int >> is the run-time value denoting the static type int. So print 1 is simply translated into print \n<<int>> 1. Now, suppose that the argument of print remains stat\u00adically unknown, as in let Writeln X = \nprint x; print \\n ;; The second occurrence of print receives type string -> unit, but the first one receives \n6 -> unit where 6 is the (un\u00adknown) type of identifier x. Then writ eln receives the type scheme V6.6 \n-> unit. This is analogous to regular ML typ\u00ading wit h regular ML type variables. However, the writ eln \nfunction is translated into a new function, with an extra type argument, namely: function ty x -> print \nty x; print <<string>> \\n This way, the extra type argument passed to writ eln is correctly passed to \nprint. For the type-system, the user\u00addefined writ eln function has the same status as the built-in print \nprimitive. We call writ eln a derived generic. To exercise our new printing capabilities, let us write \na debugging version of map: let rec map-debug f 1 = print map --> ; writeln 1; let res = match 1 with \n[] ->[] lx ::1->fx :: map-debug f 1 in print map ~-- ; uriteln res; res; ; map-debug is assigned the \npolymorphic dynamic type scheme (61 -> fSZ) -> &#38; list -> &#38; list. Although this scheme is different \nfrom the usual one of map, it is not restrictive: map-debug is fully polymorphic and can be used in every \ncontext where map can be used. map-debug is translated into the definition: let rec map-debug ty-1 ty-2 \nf 1 = print <<string>> map --> ; writeln <<ty-1 list>> 1; let res = match 1 with [1-> [1 lx ::1->fx :: \nmap-debug ty-1 ty-2 f 1 in print <<string>> map ~-- ; writeln <<ty-2 list>> res; res; ; Now the expression \nmap.debug succ [1; 2] is translated into map-debug <<int >> <<int >> eucc [1; 2], and argu\u00ad ments and \nresults of map-debug are properly printed. The code of map-debug features some (statically known) type \nreconstruction, since types passed to writ eln are list types built with ty-1 and ty.2. This example \ndemonstrates that types provided at run-time have not to be the type of some parameter: for map-debug, \nneither t y-1 nor t y-2 is the type of f or 1. These types are deduced from the context and in some cases \ntype constraints comes from the type off (consider map-debug SUCC). [n this case, run-time tags are hopeless, \nsince there is no mean to extract these information from the run-time represent ation of succ. Extensional \nand parametric polymorphism smoothly co\u00adexist, even in case of higher-order functionaht y. For in\u00adstance \nin map print [1; 2], print is assigned the type int -> unit, and the expression is translated into map \n(print <int>) [1; 21. User s defined generic functions As shown above, our framework handles predefined \ngeneric primitives, such as print, read, equal, . . . The user can also define a generic function with \na new binding construction using type case. For instance a generic addition is defined as: let generic \nadd = casec$+b~dof int 4 int -+ int => add-int I float ~ float ~ float => add-float; ; The intuitive \nmeaning is that add receives type scheme Vs. 6 * 6 -+ 6, but its value depends on the actual instance \nof the type scheme at a given occurrence in the program: in thie example the case part dynamically performs \na case analysis on the type instance assigned to 6 by the static context and returns the expression corresponding \nto the appropriate clause. add is thus a monomorphic generic function like the built-in + primitive of \nSML, but in contrast with SML, add can be abstracted: the expression f unct ion x -> add x x is typable \nwith type scheme V6. 6 -+ i!i, and can be applied to both int and float values, as intuitively expected. \nPatterns in tvr)e cases mav be as comdex as desired. . For instance, th~ length fu~ction, applicable \nto strings, vectors, and lists is defined as: let generic length = case 6 -+ int of string + int => string-length \nI 7 vect -+ i,nt => vect-length I 7 list + int => list-length; ; The ~ variable will eventually be bound \nto a type at run-Static checking of generic instances time, although here the functions of the right \nhand sides do not use it. This means simply that length works uniformly on any list or vector argument. \nGeneric definitions can also be recursive and perform non-t rivial recursive type case analysis. This \nleads to the definition of functions that could not be expressed in ML. For instance a flat generic function \nthat flattens a list at any depth is defined as: let rec generic flat = case 61 list -f5z list of rl \nlist list -+ 72 list => (function 1 -> flat (flatten 1)) I T list -+ T list => (function 1 -> 1);; The \nsecond clause is the base case which maps lists of depth one to themselves. In the first clause, flat \nflattens the out\u00adermost level of its argument and recursively calls itself on this flattened list, with \na different type, based on ~1 and T2. Amazingly, the control flow of flat is directed by types. Matching \ntype variables in patterns is possible, and is mandatory to write generic functions that handle polymor\u00adphic \nvalues. For instance, consider a generic eq function that tests equality on list values: to test equality \nof lists 11 and 12, eq compare their elements according to the type of these elements. This is tractable \nif this type can be deduced from the context, but what to do when the lists are indeed poly\u00admorphic, \nas in eq ( [1 , [1 ) ? In effect, there is no instance of eq to compare values of type a. However, comparison \nbetween fully polymorphic lists is easy, so eq gets a special case to treat them: let rec generic eq \n= case 6 x 6-+ bool of int x int -+ bool => eq. int ... I a list X a list 4 bool => (function [1 , [1 \n-> true I --> false) I r list X rliSt~bOOl=> . . . ... If we combine functional type patterns and generics \nwe can write functional applicable to curried functions having any number of parameters. For instance \na tautology checker is simply defined as: let rec generic taut = case 6 4 bool of bool -+ bool => (function \nx -> x) I (bool -> T) + bool => (function f -> taut (f true) &#38; taut (f false)); ; Evaluating taut \ntrue proves that true is a tautology, evalu\u00ad ating taut (function p -> not p or p) proves that P * P \nis a valid theorem, and taut (function p q -z p or q = q or p) provides a proof that V is commutative. \nAs a last example, we can define a generic functional that curries functions at any level: for instance, \ncurryn maps a function of type ~1 x (7Z x 73) 4 ~z x ~E ~ -re to a curried function oftype TI + T2 -T3 \n+ r4 + T5+ r6. let rec generic curryn = case 61 -+ 62 of (TIXT2+ t-~)+ 71+ T~=> (function f x -> curryn \n(function y -> f (x,y))) I (T1.+T2) --TI.+T.Z=> (function x -> x) I (rI+ r2) -+71+73=> (function f x \n-> curryn (f x));; Although well-typed programs cannot go wrong (no bus error can occur), partially \ndefined generic functions may fail to evaluate properly, raising a pattern matching fail\u00adure at run-time: \nfor inst ante, the expression add Hello World ! is well-typed, but fails at run-time (what we call a \ntype-failure). This is not satisfactory and we need a static detection of wrong usage of generic functions. \nIn its full gen\u00aderality, this problem is unfortunately undecidable, due to re\u00ad cursive generic definitions. \nWe thus restrict recursive generic definition to well-founded ones, for which static checking is decidable. \nRoughly speaking, a generic is well-founded if the size of types involved in its recursive calls cannot \ngrow for ever. This is a slight restriction in practice: all the examples given above are well-founded. \nOur static checking algorithm, having rejected every non well-founded generic definition, guarantees \nthat usage of ge\u00adneric functions cannot lead to type-failures. We now formalize the ideas above, starting \nwith a lan\u00adguage featuring extensional polymorphism, then adding to it the generic construction. 3 The \ntype system The language Expressions model the core ML language: in addition to the usual A-calculus, \nexpressions can be either integer con\u00adstants, let expressions, or pairs. We assume the existence of primitive \ngeneric functions. exp ::= i I id Ifunction id > exp I ezp ezp I ( exp, ezp) I let id= ezp in exp Types \nand type schemes We use two disjoint sets of type variable names: the set R of regular type variables \n(written a, al, . . .) and the set A of dynamic type variables (written 6, 61, . . . ). To range on any \nkind of type variable we use var, types are written r, Tl, . .. Tn. and type schemes a, m, . ..u~. type \n::= int \\a I6 Itype ~ type Itype X type type scheme ::= V (a)* (6)*. type Definition of type schemes \nis standard but regular type variables are assumed to be listed first. Note that types are considered \nas type schemes quantified over an empty set of variables (intis also denoted by V.int). Note also that, \nin the core language, dynamic variables are only introduced by the type schemes of primitive generic \nfunctions. Admissible substitutions Typing environments (17) and free variables (FV) are de\u00adfined in \nthe usual way. To take care of the two kinds of type variables we restrict substitutions to admissible \nsub\u00adstit ut ions, those which map dynamic type variables to type expressions without regular type variables: \nDefinition 1 Admissible substitutions A substitution S M admissible if and only if V6 < Dorn(S), Vvar \nc FV(S(6)), var G A As usual, we say that r k an instance of Vvarl, . . . . var~. ~ if there exists an \n(admissible) substitution mapping S = {varl = -rl, . . . warn w 7. } , suchthat ST= T . Type generalization \n4 Type inference In our type system, type generalization has to be slightly We consider an adaptation \nto our formalism of the well\u00adrestricted. Consider a generic input polymorphic primitive known Damas-Milner \ntype reconstruction algorithm for ML with type scheme unit A 6, and the program (algorithm W of [6]). \nThe WA algorithm uses the mgu algorithm that com\u00ad let x=input () in x+x;; putes the most general unifier \nof two types. Our mgu is The expected behavior is to read one integer value and to slightly more complicated \nthan the usual one: when unify\u00addouble it. However, if the standard type generalization is ing a dynamic \ntype variable with a type, this type becomes used, the translated program would be dynamic (in order \nto ensure that the substitution returned is admissible). The most general unifier is obtained as the \nlet x = function ty -> input ty () in composition of the regular unifier with a substitution that x <<int>> \n+ x <<int>>; ; maps regular type variables to dynamic ones, and would read two integer values. Thus, \nin the spirit of FX[8], type generalization is restricted to non expansive Algorithm mgu expressions \n: The dynamize algorithm computes the substitution that generalizable(id) = true. maps the regular type \nvariables that appear in a type ex\u00adpression to dynamic type variables.  generalizable(f nnction x -> \ne) == true.  generalizable( (el , e2 ) ) = dgnamize(cr) = {a ~ 6}, where 6 is a fresh dynamic generalizable(el) \n&#38; generalizable(e2).  type variable dynamite ={} . otherwise generalizabte(e) = false. dynamize(int) \n={} Notice that pairs cannot be partially generalized: as soon as one of its components cannot be generalized, \nthe entire pair dynamize(rl -+ T2) = let S1 = dynamize(~l), Sz = is not generalizable, This restriction \nalso provides a simple dynamize(SITz) in SZ 0 S1 and sound way to handle polymorphic mutable values, \nand (and similarly for the X type constructor) Wright [23] has shown it to be acceptable in practice. \n Now we can define the most general unifier of two type expressions, using case analysis on the type \nexpressions: The typing rules mgu(T, 7) = {} The typing rules are very close to Damas-Milner s system. \n mgu(cr, ~) = {a H ~}, if a does not appear in ~  17@ y : u denotes the typing environment that keeps \n mgu(6, T) = S o {6 I+ S(T)}, if 6 does not appear in ~,unchanged the type assumptions found in 17, \nexcept where S = dynamitefor the identifier y which is bound to u. mgu(T, var) = mgu(var, T) Gen(I , \ne, ~) = if not(gerzeralizable( e)) then V.T else Vvl, . . . . v~ .T where the type variables VI, . . \n. . Vn mgu(~l + T2, Ti + T;) = let S1 = mgu(~l, 7;)> S2 = mgu(Sl~z, SITJ) in Sz o S1 (and similarly \nfor the x type constructor) are the elements of the set jv(T) F V(I ). otherwise mgu(~l, 72 ) fails. \n(CST) r 1-i : int The mgu algorithm is proved correct (proof omitted due to space constraints). r(id) \n= a, r is an instance of o Type annotations (ID) rl-id:r The WA algorithm annotates expressions by their \ntype. The annotated language is defined by the following grammar: r@id:71Ee: 7-2 texp ::= i :T (ABs) \n(icZ:c7):7 r t-function id -> e : TI + T2 (function id : a -> teq) : T (tezp tezp) : T r+el:~l+~z, lTt-e2 \n:7-1 (APP)  ( ~ezp , tezp ): T r~el@:T2 (let id : a = tezp in tezp) : T Identifiers in expressions get \ntheir principal type scheme as extra annotation: x is annotated as ((x : a) : T)), r being r~C?l:Tl, \nrk.S2:T2 (pAIR) the instance of a used for this very occurrence of x. Identi\u00ad r 1-(el, ez) :71 x fiers \nin patterns are solely annotated by their type scheme72 (in particular a function parameter gets a type \nscheme with I 1-el :71, a = Gen(17, el, Tl), no quantified type variables). r@id:aEez:~2 As an example \nof such annotations, consider the pro\u00ad (LET) gram let id = function x -> x in id id. If we number successive \noccurrences of the same identifier, we get the fol\u00adlowing static annotations: (idl : v a.a ~ a) ((id, \n: Va.a -+ a) : (,6 -+@ -+ (,6 -+@) ((ids : da.a ~ a) :~ -+@ (xl : V.a) and ((x2 : V.cI) : a) The WA \nalgorithm Let e be a term, 17 be a typing environment. We define WA (r, e) as the pair (e , S), where \ne is the expression e decorated with type in formations, and S a substitution. We extend naturally the \napplication of a substitution S to an\u00adnotated expressions: S(e) is an annotated expression where each \ntype variable war appearing in e has been replaced by S(var). wA(r, i) = (i: kt, {}) wA(r, Z) = let (V \nVI let varl, ~ ~~~~~~~~sh type variables, (var~ being regular or dynamic, according to v,) let S= {v, \n+ var%} in ((z : r(z)) : ST, {}) W.4(r, function X > e) = let a be a regular fresh variable let e , s \n= W.4(r@Z : V.a, e) in ((function x : S(V.CZ)-> e ) : Sa + 7, S) wA(r, 6!I .92) = kt e~:TI, SI =wA(r, \nel) let e~ : 72, s2 = wA(slr, e2) let a be a regular fresh variable let p = rngu(Sz-rl, ~Z ~ a) in (p(e~ \n: 71) ~(ej : T2) : pa, po Sj 0S1) WA(r, (el, ez)) = let e! : 71, sI =WA(r, el) let e~ : 72, SZ = WA(Slr, \ne2) in (( S2(e\\ : Tl), eL : T2) : s2(Tl) X T2, s2 0s1) Theorem 1 The WA algorithm is correct and complete \nwith respect to the typing rules, and infers the most general type of an expression. The proof (omitted \nfrom this paper) is very similar to Damas proof. Translation The translation algorithm maps source expressions \nwith type annotations to expressions in a target language with explicit run-time representation of types. \nWe call this lan\u00adguage MLD. The target language MLD is similar to ML, but manipulates values of a new \ndata type called typ, modelling run-time representations of ML types. To model the type algebra used \nin the source language, the data type typ of MLD has a constant, Int, two bi\u00adnary value constructors \nCross and Arrow with MLD types typ x typ + typ, and one unary constructor @ote with type string + typ \n(the string argument being the name of the type variable, e.g. a in a). It is thus a regular data type \nwhich could be defined as: type typ = Int I Quote of string I Arrow of typ x typ I Cross of typ x typ; \n; To enhance readability, we double-bracket typ values, and denote them with the same syntax as the source \nlanguage type they model. Hence we write <<int -> int>> to stand for Arrow (Int, Int ) and << a>> instead \nof Quote ( a ) 1. Although we can manipulate t yp values in MLD, MLD is not a second order A-calculus. \nFor instance, the MLD function function tl t2 ~ <<tl -> t2>> has a regular MLD type typ + typ + typ: \ngiven two typ values tl and t2, it returns the typ value <<tl -> t2>> (which stands for Arrow (tl, t2)). \nMLD can be easily implemented directly within ML, but we do not confuse the two languages. In effect \ngeneric prim\u00aditives are implemented in MLD not in ML. These generic primitives have a safe dynamic type \nscheme in ML, but their MLD type does not reflect the dependent nature of the dynamic type scheme. For \ninstance print has MLD type Vci. typ + a + unit but must not be applied to unrelated arguments such as \nin print << int >> true. The transla\u00adtion process described below ensures that when evaluating in MLD \nprint ty e (the translated code for print e), ty is the typ value corresponding to the ML (and MLD) type \nof e. In other words, in the type of print, typ and a are dependent: the print second parameter has always \nfor type the value of the first parameter. The translation algorithm The translation algorithm uses assertions \nfor dynamic type variables: (6 : t y) means that during program execution the type instance corresponding \nto the dynamic type vari\u00adable 6 will be the value of the parameter ty (of type typ). The translation \nof the expression eccp with respect to the set of assertions env is denoted by Lezp] env (static type \nannotations of ezp have been omitted when unnecessary). The translation algorithm is also in charge of \ntranslating ML types into run-time representations in MLD, This trans\u00adlation is straightforward except \nfor dynamic type variables: it returns either the identifier bound to the type variable in env, or the \nrun-time representation of a type variable if the dynamic type variable has never been bound to an extra \ntype parameter. Those unconstrained dynamic type variables are consistently translated thanks to the \nglobal environment .E. lijenv=i e lfunction id -> ej erw = function id -> [ej env e Lel ezj env= ([cl \n] env) (Lez ] env) 1 (el, e2)J env = (lel J env, [e2J env) lThis of the Carol V3.1 concrete syntax quotation, \nM reminiscent and of the primitive gtype data type with its associated grammar. Q llet(id:Vq, ..., flm, \n&#38;,..., #)=e~e~ in ezJenv = let id = function tyl ...tym -> 1el j envl in 1ez j env where tyl . . \n. ty~ are new identifiers, and envl = erw~ (8I : tyl)... (&#38; : tyn). l(id:~al, . . . . 0~,61, . . \n. . ~~.~ ):~jenvn id ( LS(61)J env) . . . ( lS(&#38;)j env) where S = rngu(#, ~), and Lintj env = <<int>> \n [~1 ~ T2J env = <<(lTIJ env)->(17_2j env)>> (and similarly for the x type constructor).  . L$j env \n= env(6), if 6 is bound in env, [6j env = E(8), if 6 is bound in e else define a new fresh name a, bind \n6 to << a>> in q and return << a>>. 6 The generic construction Syntax The source language is extended \nwith the generic construc\u00adtion: exp ::= . . . (previous expressions) let [ret] generic id = case a of \n{a =>erp}+ I in exp Type patterns are closed type schemes. In the examples given in the informal presentation, \nwe have used the notation ) a to mean regular type variables (i.e. a), (for instance, >a list means Va.a \nlist since quantifiers are omitted, as usual in ML). Any other type variable is dynamic. On the semantic \npoint of view, type patterns used in generic expressions are not assumed to be linear, the set of clauses \nhas not to be exhaustive, and since type patterns may overlap, implicit disambiguating rule by textual \npre\u00adsentation order is assumed. Typing rules for generics A generic definition is explicitly typed. Its \nheader contains a declared type scheme for the defined identifier. Informally, it suffices to check that \nall the type schemes o; appearing in the type case of the definition are proper instances of the declared \ntype scheme of the generic cr: each cri has to be closed and must be a generic scheme instance of a (the \nformal definition is given below), On the other hand, each expression in the match part of the definition \nmust be correctly typed according to their declared type: each ex\u00adpression can be assigned the type scheme \na;. Definition 2 Scheme a-convertibility A type scheme u = V a~,. ... a~,6j,6~. ,6~. r is cY\u00ad convertible \nto a type scheme u = VaI, . . . . mm, 61, . . . IL. T (denoted u ~ u) if and only if there exists a substitution \nS preserving the kind of type variables such that S(T) = T . Definition 3 Generic scheme instance A type \nscheme u = Va~, . . ..cY~., ~~,...,~~,. r is a generic scheme instance of a type scheme u = vcq, . . \n..am.61,. ... I&#38;. r (denoted IS ~, u) if and only if there exists a substitution S (that can be non-admissible) \ndefined on {61,..., &#38;} such that S(T) ~ T . (GENERIC) r E let Keneric id = case 0 of {Cri -> ei} \nine:r Ui<g U, 17@id:cr F-e~:~i, 17 F let rec generic id = case 0 of {cr~ ->ei}ine:r Type reconstruction \nfor generics The annotated langage and the WA algorithm are extended to take into account generics. tezp \n::= ... let [ret] generic id = case aof {a=>tezp}+ in tezp) :T I wA(r, let rec generic id = case a \no~E{ ai => ei } in e) = if a is not a closed type scheme then WA fails, if ~i such that Ui is not a generic \nscheme instance of a, then WA fails, letr =r@id:a let e! : ~~,sl = wA(r , el) let VCY*,6 .71 = al let \nS{ = rngu(~~, ~~) let V1= S; oS1 let a; = Gen(pll? , el, S; (~~)) if al <> u; then WA fails, ... let \ne ~ : ~;,% = W,4(r , en) let VCK*,6* .7n = on let S~ = mgu(~~, 7.) let p. = S; oSn o~n l let a: = Gen(flJ \n, en, S~ (r:)) if an <>0: then WA fails let e : #, S = W,4(pnr , e) in letp=Sopnin ((let rec generic \nid = case u of {a~ => p(e$ :7/) } in e :7 ) :~ ,p) An important point to note is that right-hand sides \nof clauses u => e are annotated with a type sharing the variables of a, so that during translation, type \nvariables in the patterns will be properly transmitted to generic calls in the expression. Translation \nof generics Translation of generics supposes that pattern matching on typ values is available in MLD \n(using the regular match ezp with matching used for any other data type in ML, extended to non-linear \npatterns). ll;;~ric id = case Vcrl,..., a~, &#38;,&#38;.., &#38;.~ of . . . clil , bil ,. ... 6i~ .Ti=>ei} \nin ej env = let id = function tyl . . . ty% -> match tyI, . . . . ty~ with The domain of abstraction \n{ pat,,,... ,pat,n -> [ei] env, } in Lej env where pat,, = [Si6jJ env,, (S, being the substitution such \nthat S,r = T,) and env, = env@(ti,l : tyl, . ..&#38;~ : tyk,ff,l : zl,...a,~ : z1) (tyt, ,... , ty,~, \nX,l, . . . . Z,l being new fresh identifiers). The translation of type inst antes is defined as follows. \nTo avoid confusion, we directly use constructors of the typ data type, instead of their sugared versions \nwith <<>>. [intj env = Int  [6j env = env(~)  Laj erzv = quote (env(a))  L rl 4 rz~ env = Arrow-type \n( Lrl] env, l~zj env) (and similarly for the product type)  Note that the patterns correspond to the \nvarious 6 vari\u00adables in the generic scheme, so as to match only the variable part of the scheme, and \nto be consistent with the rest of the translation. The translation of the taut function is the following \nMLD function : let rec taut = function ty -> match ty with Bool -> (function x -> x) I Arrow (bool, ty-1) \n-> (function f -> taut ty-1 (f true) &#38; taut ty_l (f false)) ; ; 7 Static checking of generic instances \nAt this stage of type-checking, the application of a generic function to a given type may still produce \na type failure, unless the generic is really polymorphic (e.g. defined with an exhaustive type-case). \nWe propose to detect type failures with a static verifica\u00adtion based on abstract interpretation of programs. \nWe prove that this static verification is undecidable if definitions and usage of generics are unconstrained, \nWe give a practical re\u00adstriction on generic definitions for which static verification is decidable, and \ndescribe the associated algorithm. Abstract interpretation The abstraction of a program is a predicate \non types that captures type abstract ions, type mat thing, and type appli\u00adcations. It is therefore very \nsimilar to its translation into MLD. The function application el e2 is abstracted into the conjunction \nof the abstractions of e~ and e2. The abstrac\u00adtion of a generic is a regular MLD let construction. For \ninstance, the abstraction of the writ eln previous example is: let abs-writeln = function ty -> abs.print \nty &#38; abs_print <<String>>; ; abs.writeln is a function from types to booleans returning true when \nwriteln is defined for type ty. For recursively defined generic functions, the abstraction is also recursive. \nFor example, the abstraction of taut is: let rec abs-taut = function ty -> match ty with Bool -z true \nI Arrow (Bool, ty) -> abs-taut ty &#38; abs_taut ty; ; The domain of abstraction is the following subset \nof MLD: aezp ::= true (boolean constant) aexp &#38; aexp (conjunction) id {t}+ (generic application) \nlet [ret] id= agen in aezp (generic abstraction) agen ::= function tyl . . . tyn -> aezp (derived generics) \nI function tyl ., . tyn -> (generics) match tyl, . . . . tyn with {patl, . . ., patn -> aezp}+ t and \npat% are respectively type expressions and type pat\u00adterns built with constructors of the typ datatype, \nincluding variables (e.g. Arrow (Int, t y), also noted <<int + ty>>). The abstraction algorithm The abstraction \nof ezp with respect to the set of assertions env is denoted by [ezpl env (static type annotations of \neap have been omitted when unnecessary). [i ] env = true e [function id -> el emu = [e] env  [e~e~lenv=[ellenv&#38;[e~lenv \n [(el, e2)lenv =[ellenv&#38;[e21env  [let (id : VC21,. . . . C2m.T ) = e, in e~l env = [ellenv&#38;[e~lenw \n  (let (id: Val,..., a~,61,6m .~6)=el)=e1 in e2,1 env = let id= function tyl ... tyn -> [ el 1 envl \nin [ ez 1 emo where tyl, . . . . tyn are new identifiers, and env~ = env @(8I :tyl) ...(&#38; :ty~) \n [(id: Vcq,..., a#)#) :T1 env =true  [(id: Vcq,..., cz~,61, &#38;.., &#38;./) :~lenv= id (LS(61)J env) \n. . . (lS(6n)J env) where S = mgu(-r , T)  [let generic id= case Val,..., am,61, &#38;.., &#38;.T of \n{Vcli,,..., cw,,til>... >f5tk.-ri=>e, } in el env = let id = function tyl . . . tym ->  match tyl, . \n. . . ty~ with { pat,,,... ,pat,n -> [e,] env~ } in [el env where pat,, =lS,C$,j env;, (S, being the \nsubstitution such that S;T = T,), env~ = env@ (at, sty,,..., c$,k :tyk, cl tl :zz,,..., a~, :Xt, ) (tytl,..., \ntytk, ztl, z,l, z,l being new fresh identifiers) Admissibility Definition 4 Admissibility A typed program \nP is admtsstble if and only if the eval\u00aduation of its abstraction (P10 does not produce an error. This \ndefinition flags some programs as not admissible even if they do not produce run-time errors. However, \na more precise characterization would require some static analysis on the values manipulated by the program \n(conditionals, pattern-mat thing, exceptions,. ). Note also that the eval\u00aduation of an abstraction does \nnot necessarily terminate. Theorem 2 An admissilJe program does not produce run\u00ad time type failures. \nProof: (Sketch) By construction, the only possible errors in the evaluation of abstractions are pattern-matching \nfailures, corresponding to type errors. The abstraction of a program contains every call to generics \nor derived generics in the source program, and the evaluation of the abstraction will check every possible \ngeneric call in the evaluation of the program. 0 Theorem 3 Admissibility of programs is undecidable. \nThe proof (due to Damien Doligez) relies on a simple en\u00adcoding of Turing machines as abstractions of \ngeneric func\u00adtions. Details are given in appendix. The tape and machine position are encoded as a type \nterm. Each state of the ma\u00adchine is the abstraction of a generic function where the type patterns encode \nthe transitions. This encoding ensures that the machine halts for a given input if and only if the generic \nabstraction corresponding to the initial state fails on its type argument (encoding the input). This \nproves undecidability by reduction to the halting problem. Decidable Restriction This section describes \na simple characterization of a class of programs for which admissibility is decidable: the well\u00adfounded \nprograms. Roughly speaking, a program is well-founded if all r-e\u00adcursive calls to generics it contains \nmay not loop. This is formalized by requiring the size of types involved in recursive calls in abstractions \nof programs to decrease, Definition 5 Type size The size of a type or type pattern is defined as a formal \narithmetic expression by: asize(<<int>>) = 1 asize(<< a>>) = 1  asize(id) = id  asize(<<tl + t2>>) \n= 1 + asize(tl) + asi.ze(tz)  asize(<<tl X tz>>) = 1 + asize(tl) + asi.ze(tz)  For instance, asize(<<bool \n+ ty>>) = 2 + ty. Definition 6 Well-founded clauses A clause of a type case pat -> aexp appearing in \nthe abstraction of a generic g is well-founded (resp. strictly well-founded) if and only if, for all \ntype t argument of a recursive call to g in aexp, either asize(t) is a constant, or asize(t) < asize(pat) \n(resp. asize(t) < asize(pat)). Note that these definitions are effective, since given a call to a generic \nusing type tand appearing in the match case pat -> e, a simple algebraic manipulation shows that asize(pat \n) < asize(t) is equivalent to an inequation of the form k;*id, >0, c+~ where c, k, are integer values, \nand idi are type identifiers sizes, ranging on integer values greater than 1. Since this inequality must \nbe verified for all id, greater than 1, we clearly have: . if there exists ki <0 then the inequality \nis not verified. otherwise the formula is equivalent to c + ~i ki > 0, which is trivially checked. \nDefinition 7 Well-founded generics A generic definition is well-founded (resp. strictly well\u00adfounded) \nif and only if it M not recursive.  it is recursive and all the clauses appearing in its abstraction \nare well-founded (resp. strictly well-founded).  The taut generic function is strictly well-founded: \nthe criterion is obviously met for the first clause, for the second we just have to check the size of \nthe recursive call argument, i.e. ty, is lower than the size of the pattern, i.e. 2 + ty. Definition \n8 Well-founded programs A program is well-founded (resp. strictly well-founded) if and only if it only \ncontains well-founded (resp. strictly well-founded) generic definitions. Note that non-recursive generic \ndefinitions are always well-founded. If mutually recursive generics are allowed, the well-foundedness \nrestriction is extended to recursive calls to functions belonging to the same recursive definition. I%eorem \n4 Admissibility is decidable for strictly well-founded programs, and is checked by evaluating the abstraction, \nProof: If a program is strictly well-founded then sizes of type expressions involved in recursive calls \nto generics are strictly decreasing (thus evaluation of the corresponding abstraction either terminates \nor produces a type matching error). 0 Relaxed restriction The previous theorem can be extended to every \nwell-founded program. In this case, it is not possible to directly evalu\u00adate the abstraction, since it \nis not guaranteed to terminate. However there is another evaluation for abstractions that checks admissibility \nfor well-founded programs. The main idea is to memorize the set of already checked instances of generics \nduring the evaluation, in the spirit of memo\u00adfunctions. The full algorithm E is given in appendix. Theorem \n5 If P is a well-founded program then P is ad\u00admissible if and only if E( [PI 0) does not return the value \nwrong. The proof is based on the finiteness of the set of types for which we must check that the generic \nis defined. Static verification of generic definition We now have checked all possible applications of \ngenerics in a complete program, but not their definitions independently of their context. This means, \nin a practical system, that some generics can be defined but cannot be used in any context. One may then \nwish to check that a generic is applica\u00adble at least on one type. Unfortunately, this is undecidable, \neven for well-founded programs (the proof is similar to the proof of undecidability of halting of Turing \nmachines, with an encoding of an hypothetical decidable algorithm as a Tur\u00ading machine and reduction \nto contradiction), However we suggest two simple decidable checks that will reject generic definitions \ncontaining trivially wrong recursive calls. Check ground generic calls inside generic definitions using \nthe previously described algorithm.  For other generic calls -.o t,check that at least one in\u00adstance \nof t can be matched by a pattern in the type case of g.  8 Coherence Semantics of programs is given \nusing type annotations found by principal derivations (from algorithm WA). Among derivations computing \nthe same principal type, some typing derivations may assign different types to generic identifiers. These \nnon-principal derivations would lead to different semantics for the same program. This has been noted \nas the coherence problem in the Haskell community [12], or as the safety criterion in [17]. Intuitively \ncoherence problems occur when type variables introduced during typing appear in annotations, but are \nab\u00adsent from the principal type scheme of the program. This is due to (cuts in typing derivations (for \ninstance in case of application). Consider for example the program print [1: it has principal type unit, \nbut a type variable is left in the annotated expressions print : 6 list -+ unit and [1 : 6 list. Unfortunately, \nother derivations leading to the principal type scheme may have annotated the expres\u00adsions with instances \nof the 6 variable. For instance, the annotation print : int list -+ unit is legal. In this case the translated \ncode would be print <<int list>> [1, while for the principal derivation it is print <<a list>> [1. These \ntwo translated programs being different, there is no way to ensure that they have the same semantics. \nA first approach would be to restrict well typed programs to coherent ones, according to the definition: \nDefinition 9 Strong Coherence A program e is strongly coherent if it as typable (17 1-e :P u) and for \nall derivation d = r 1-e ~du we have Le := u] = [e :d u]. (We assume that typing derivations produce \nanno\u00adtated programs under the same rules used for the WA algo\u00adrithm. We denote e ;d T the expression \nannotated by deriva\u00adtion d and p is the principal derivation corresponding to the application of the \nWA algorithm.) Checking of coherence is easily obtained with the follow\u00ading property: Property 1 A program \ne is coherent if and only if for all generic call g t in Le : UJ, t does not contain Quote sub\u00adterms. \nRejecting incoherent programs may be sensible if generic functions are not fully polymorphic. In this \ncase, incoherent programs are generally not admissible. The very special case where an incoherent program \nis admissible is when the generics involved are actually parametric. For instance, if print were defined \nas let generic print = case 6 + unit of ... 7 list -> unit => function . -> unit ... ;; then print is \nparametric for the list type constructor (al\u00adthough not useful), and print [1 is incoherent but admis\u00adsible. \nThis approach seems to be the Haskell one, where incoherent programs are rejected. We do not consider \nthis approach to be satisfying in prac\u00adtice, since we would like print [1 or the boolean test [1 s [] \nto work as expected. Thus we euggest a second approach, based on a finer definition of coherence. Definition \n10 Refined Coherence A program e is coherent if it is typable (T t e :P u) and there exists some derivation \nd such that (e :d a) is admissible and for all dervvataon d = r ~ e :# o such that (e :,JI o) zs admissible, \nthen [e :d O] = Le :dl a]. This definition considers as acceptable programs for which the principal derivation \nleads to non-admissibility, while some other derivations may produce a unique admissible program. In \nthis case the program is in fact unambiguous, so the compiler might want to find an alternate derivation \nlead\u00ading to the admissible program, as this appears to the pro\u00adgrammer as some form of static overloading \nresolution. For inst ante, if add is defined as: let generic add = case 61* &#38; ~ 63of int ~ int ~ \nint => add_ int I float -+ float + float => add-float I float + int + float => I int -+ float -+ float \n=> ... ;; then the programs add 3.14 (add 1 2), or even add 3.14 1 are unambiguous but the bare type \nsystem will reject them as not admissible. In the first example, the add occurrences are annotated respectively \nwith add : float -+ 6 -+ 61, and add : int ~ int + 6, which are clearly not admissible. Note that the \nstrange type scheme of add is responsible for this behaviour. We have no algorithm yet to solve this \nproblem in its full generality. However, experience gained in previous work on overloading in Alcool \nand Carol V3. 1, suggests practical but incomplete algorithms to find such a derivation (the problem \nis reformulated as a set of Horn-clauses over which one attempts breadth-first resolution bounded to \na given depth). Another example, suggested by an anonymous referee, exhibits an even more complex situation: \nlet f = function 1 -j print (flat 1); ; The interesting annotations are: flat : 61 list -+ 6Z list print \n: &#38; list + unit f: V61. 61 list --+ unit Due to the cut in the application, tiz has disappeared from \nthe principal type. The program is not admissible for its principal derivation, but it could be considered \nas coher\u00adent (in the sense of refined coherence), if one realizes that 62 is actually a function of 61, \nby looking at the recursively\u00addefined domain off lat. This is however out of the scope of the formalism \ndescribed here, since this dependent type is not expressible in the type algebra. 9 Related Work Dynamics \nThe notion of dynamic values provides an elegant way to perform run-time type tests on values [2, 1, \n13]. This mech\u00adanism has two components: a dynamic primitive to build a dynamic value, sticking it to \nits type, and a type case mech\u00adanism to discriminate dynamic values according to their em\u00adbedded type. \nThis would work as a simple scheme to pro\u00advide generic functions, but then dynamics tend to spread all \nover the language, since generic functions manipulate only dynamics (e.g. add has type dyn -> dyn -> \ndyn). This clearly goes against ML type checking paradigm. Extensional polymorphism cannot replace dynamic \nval\u00adues, but it gives the type checking part of dynamic values for free. Creation of dynamic values has \nno more to be a spe\u00adcial syntactic construction, it suffices to declare a primitive function make-dynamic \nwith type scheme 6 -> dyn, simply defined in MLD as the pairing between a value and its type (function \nty x -> (ty ,x)). Then dynamic values fit more smoothly in our framework: extensional polymorphism gives \nto make-dynamic the status of a polymorphic function, and handles properly usually rejected definitions \nsuch as: let make.dyn-pair = function x -> make.dynmic (X, x); ; Tag-free garbage collection for ML Tolmach \nshows in [19] how to realize tag-free garbage col\u00adlection for an ML dialect with regular parametric polymor\u00adphism. \nThe garbage collector uses run-time type informa\u00adtion derived from an explicitly typed second order J-calculus \nrepresentation of the program. If we type check ML pro\u00adgrams using only dynamic variables, we directly \nobtain the augment ed Tolmach s program. For instance, the i.d func\u00adtion in let id = function x -> x \nin (id 3, id true) would have in this context the type V6.6 -b. It is then compiled as let id . function \nty x -> x in (id <<int> 3, id <bool> true) very close to Tolmach s result. Non-parametric polymorphism \nin JML In [9], Harper and Morrisett define the non-parametric poly\u00admorphism. This kind of polymorphism \nis a notion related to our extensional polymorphism: it allows the definition of generic functions that \ndepend upon a type parameter via a special operator typerec, in the second-order A-calculus, JML, to \ninductively define generics to all types. As far as we know, the typerec operator provides primitive \nrecursion over types (whereas our generic construction is not so re\u00adstricted), and is not accessible \nto the programmer. However this framework is unable to provide instances of generic functions for fully \npolymorphic instances, and can\u00adnot provide default behaviour for generic functions, More\u00adover, the formfllzation \ntreats in the same way parametric and non-parametric polymorphisms: every polymorphic ML value is translated \ninto a type abstraction in ~~L. In con\u00adtrast, our system restricts type abstraction to generic func\u00adtions, \nparametric functions remain the same. Haskell and type classes Our approach provides a simple framework \nto understand ad-hoc polymorphism, and in particular type classes: instance declarations correspond to \ngeneric function clauses. Technically, the Haskell restrictions on the form of instances and context \nof instances guarantee that there is no overlap of patterns, as well as the strictly decreasing \\ restriction \nrequired by our static verification algorithm. constraints on type variables during the type inference \nprocess correspond to the static ve~ficat~o~ algorithm (a class may by seen as a type characterization \nof a generic). Classes also have a purpose in programming methodol\u00adogy: structuring programs through \nthe class hierarchy. A significative technical consequence is run-time manipulation of dictionaries which \nis difficult to compile efficiently [3]. Our framework does not impose any programming method\u00adology. \nOur type system handles some interesting examples (taut, curry, flat, or even functions with a variable \nnum\u00adber of arguments), that do not fit naturally in the Haskell methodology. The generic function formalism \nhas more expressive power than the Haskell class system: taut, curry, for example, cannot be written \nin Haskell due to the current rest rictions on inst ante declarations. Moreover, the compilation of generic \nfunctions relies only on pattern-matching, a feature whose efficient compilation has already been studied \nextensively. Thatte [18] has recently proposed a semantics of type classes based on the notion of generic \nfunctions. His paper describes an interpretation of classes as fixed points of sets of types, and gives \na condition for the existence of such fixed points (convergent classes), that is met by Haskell restric\u00adtions \non classes and instances declarations. Our approach, developed independently [7], is more syntactic and \npractical in nature, but can also be used to provide a semantics for type classes in the same spirit. \n10 Conclusion This paper introduces extensional polymorphism, a new ap\u00adproach for type-checking ad-hoc \npolymorphism. The formal\u00adism relies on two simple concepts: dynamic type variables and selection of generic \ninstances by pattern-matching on types. This economical framework is easy to understand and easy to implement \nas it is a conservative extension of ML. The type checker needs few modifications (mainly the adaptation \nof unification for dynamic type variables). No special compilation is required, since the proposed transla\u00adtion \nproduces regular ML abstract syntax trees. A prototype of the type-checker and its associated trans\u00adlator \nis running in Carol V3.1 [21, 22] since 1992. A full integration in the Carol Light system is on the \nway. The applications of the paper are multiple: first, it gives an alternative theoretical account of \nthe Haskell approach to ad-hoc polymorphism. Then, extensional polymorphism subsumes hard-wired solutions \nfor printing, equality and de\u00adbugging functions. Finally, a new form of computation be\u00adcomes available \nin statically typed functional languages, as exemplified by the curryn generic. Complex computations \nmixing types and values are now safely accessible to the programmer. Acknowledgments We thank the whole \nvirtual bat8 community for many use\u00adful discussions, in particular Bernard Lang, Jean-Jacques L&#38;y, \nLuc Maranget, Xavier Leroy, Didier R6my and again Damien Doligez, Turing mechanic extraordinaire. References \n[18] S. R. Thatte. Semantics of type classes revisited. In Lisp and Functional Programming 199~, pages \n208-219. [1]M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. Dy- ACM Press, 1994. namic typing in a \nstatically-typed language. ACM Trans. Prog. Lang. Syst., 13(2):237-268, 1991. [19] A. Tolmach. Tag-free \ngarbage collection using explicit type parameters. In Lisp and Functional Programming [2] M. Abadi, \nL. Cardelli, B. Pierce, and D. R6my. Dy-1994, pages 1 11. ACM Press, 1994. namic typing in polymorphic \nlanguages. In F roceedmgs of the 1992 workshop on ML and ds applications, 1992. [20] U.S. Department \nof Defense. Reference manual for the ADA programming language, 1983. ANSI-MIL-STD [3] L. Augustsson. \nImplementing Haskell overloading. In 1815A. Functional Programming Languages and Computer Ar\u00adchitecture \n1993, pages 65 73. ACM Press, 1993. [21] P. Weis et al. The CAML reference manual, version 2.6.1. Technical \nreport 121, INRIA, 1990. [4] D. G. Bobrow, L. G. DeMichel, R. P. Gabriel, S. E. [22] P. Weis and X. Leroy. \nLe langage Carol. InterEditions,Keene, G. Kiczales, and D. A. Moon. Common Lisp 1993. Object System specification. \nSIGPLAN Notices, 1988. [23] A. K. Wright. Polymorphism for imperative languages [5] J. Chailloux, M. \nDevin, F. Dupont, J.-M. Hullot, without imperative types. Technical report 200, RICE B. Serpette, and \nJ. Vuillemin. Le-Lisp version 15.24, University, 1993. Typing references by value polymor\u00adle manuel de \nr6f6rence. Technical report, INRIA, 1991. phism. [6] L. Damas and R. Milner. Principal type-schemes for \nfunctional programs. In 9th symposium Principles of Appendix A: Undecidability of admissibility Programming \nLanguages, pages 207 212. ACM Press, 1982. We encode Turing machines and their programs into gener\u00ad ics \nabstractions. For simplicity, we define a few new type [7] C. Dubois and P. Weis. Generic polymorphism. \nRe\u00adconstructors, although they can be encoded in the originalsearch report 05-1994, Universit 6 d Evry \nVal d Essonne, type algebra with <<int>> and product x . 1994. type ( a, b) PO=POof a * b [8] D. K. \nGifford and J. M. Lucassen. Integrating func\u00ad and ( a, )b) PI =PI of a * b;; tional and imperative programming. \nIn 13th sympo\u00ad type a BO=BOof a sium Principles of Programming Languages, pages 28 and a B1 = B1 of \nJa; ; 38. ACM Press, 1986. The tape has the form [9] R. Harper and G. Morrisett. Compiling with non\u00adparametric \npolymorphism. Research report CMU-CS-Pz(Bt(. . . (B,(unit))), B*(. . . (l?,(unit)))) 94-122, Carnegie \nMellon University, 1994. P, stands for the tape cell under the machine head, B, for [10] P. Hudak, \nS. P. Jones, and P. Wadler. Report on the other cells (i indicates the content of a cell). unit encodes \nprogramming language Haskell, version 1.2. Technical the end of the known part of the tape, the rest \nbeing O cells. report, Yale University, 1992. A transition rewrites the current cell, moves the head \nto the right or to the left, and switch to another state. For in\u00ad [11] K. Jensen and N. Wirth. PASCAL \nuser manual and stance, for the state Sk with transitions ~+sk : . .. O~... an~... ~... -halt the relevant \npart of en\u00ad report : ISO PASCAL standard. Springer, 1991. [12] M. P. Jones. A theory of qualified types. \nIn Proceedings coding would be: of ESOP 92, pages 287 306, 1992. let rec sk . function ty -> match ty \nwith [13] X. Leroy and M. Mauny. Dynamics in ML. Journal of <<Pl(a, Bl(b))> -> sk <Pl(BO(a) ,b)> Functional \nProgramming, 3(4) :431 463, 1994. I <Pl(a,BO(b))> -j sk <pO(BO(a) ,b)> -> sk> <<PO(BO(a) ,unit)>> [14] \nR. Milner, M. Tofte, and R. Harper. The definition of I <<Pl(a,unit)>> I <<PO(a,b)> -j halt <F o(a,b)>>Standard \nML. The MIT Press, 1990. and halt = function ty -> match ty with unit -> true [15] G. Nelson, L. Cardelli, \nJ. Donahue, L. Glassman, M. Jordan, and B. Kalsow. Modula-3 report (revised).  andsk =.. . Research \nreport 52, DEC Systems Research Center, 1989. The two first clauses encode the cases X = 1 and X = O \nfor the first transition, the third clause the case where the [16] C. Queinnec. Meroon: a small, efficient \nand enhanced end of the known tape is reached. The last clause encode theobject system. Technical report \nLIX.RR.92.14, INRIA\u00adsecond transition. The halting state is defined so that it failsEcole Polytechnique, \n1992. for any type encoding a tape (an initial empty tape would be encoded as PO(unit ,unit ) since \nit requires a position). sium Principles of Programming Languages, pages 355 [17] F. Rouaix. Safe run-time \noverloading. In 17th sympo-Lemma 1 The machine halts for a given input if and only 366. ACM Press, 1990. \nif the generic abstraction corresponding to the initial state fails on zts type argument (encoding th; \ninput). Proof: By construction. The generics for normal states Si have complete patterns for the possible \nvalues of the tape, so the only possible type-error is the (always) failed pat\u00adtern matching of halt. \nThis proves the undecidability of admissibility by reduction to the halting problem. 0 Note that any \nmachine can be obtained as the abstrac\u00adtion of some program, and thk program is easily deduced from the \nmachine definition. For instance the generic defi\u00adnition corresponding to our example would be: let generic \nrec sk = case 6 + unit of PI(T, BI(T )) -unit => (function Pl(a,Bl(b)) -> sk (Pl(BO(a),b))) I P1(T, BO(T \n)) +unit => (function Pl(a,BO(b)) -> sk (PO(BO(a) ,b))) I Pl(T,unit) -+ unit => (function Pl(a, ()) -> \nsk (PO(BO(a), ()))) i PO(T, T )) +unit => (function PO(a,b) -> halt (PO(a,b))) Appendix B: Admissibility \nchecking algorithm with relaxed restrictions We define E as a function from aexp to {true, wrong}. E(aeap) \nis defined as fst(Eval(aezp) (0,0, 0)). In the no\u00adtation 13val(e)(0, A, c), 0 denotes the binding environment \nfor type variables.  A denotes the binding environment for generic abstrac\u00adtion identifiers.  c denotes \nthe execution memo-mechanism: c is a list of pairs (id, ....where id is the name of a generic  (tl,tn)), \n abstraction and ti are types. A pair (id, (tl,. . . . t~)) is added to memory c when a clause of the \ngeneric abstraction id has a pattern proved to match types tl,....tn.  We have separated type environments \nand abstraction envi\u00adronments to simplify the description of the algorithm. Evcd(true)(O, A, c) = true, \nc  Eval(e&#38;e )(0, A, c) = let W, c1 = 13val(e)(6 , ~, c), let WZ,CZ = Eval(e )(t9, J, cl) in vl&#38;vz, \ncz  13val(let id= e in e )(0, A, c) = ,?7val(e )(0, ~ @ id ~< e,t9, A >, c)  Eval(let rec id = e \nin e )(6 , A,c) = Eval(e )(t9, A , c) where A = A @id I+ < e, O,A >  s Eval(id tl . . . tn)(O, A, c) \n= let < function tyl . . . tyn -> e, 0 , J >= A(id) in Eval(e)(O @ tyl * O(tl), . . . tyn I+ O(tn), A \n, c) Eval(id tl . . . t~)(tl, A, c) = let < function tyl . . . tgn -> match tyl, . . . . ty~ with {pat~l,. \n. . ,pat;m->e,}, 0 , ~ >= A(id) and sl, . . ..sn =O(tl),in ....6(tn) if (id, (sl, ..., SW)) is boundz \nin c then true otherwise let m, /3 = matching((tl,. . . , tn)l {pat~l, . . . ,pat$n}) in Eval(e~)(O u \n~, J , c @ (id, (s1,..., s~)) ++ true) 2Equal it y on run-time types is considered modulo renaming of \nfree type variables (<< a>>). The last two rules deal with the two possible forms of functions (with \npattern-matching or not). The proper rule is naturally selected according to the form of the function. \nThe matching function gets a list of types and a list of patterns as arguments and returns the number \nof the first pattern that matches the type, and the substitution of vari\u00adables for types in the pattern \nthat implies the match. If no such pattern exists then the evaluation process terminates wit h the value \nwrong. Lemma 2 Ii P is a well-founded program then E( [Pl O) al\u00adways terminates. Proof: The set of generic \ncalls to be checked is finite, since the set of types of size lower than a given constant is finite. \nThe result follows from the fact that Eval cannot loop for ever via recursive calls with the same (id, \n(tl, . . . . t~)) pair. o Theorem 6 If P is a well-founded program then P is ad\u00ad missible if and only \nij E( rPl 0) does not return the value wrong. Proof: The proof simply follows from the proof that Eval \nreally evaluates abstractions of programs (proof omitted). 0 \n\t\t\t", "proc_id": "199448", "abstract": "<p>We present the extensional polymorphism, a framework to type check ad hoc polymorphic functions. This formalism is compatible with parametric polymorphism, and supports a large class of functions defined by structural pattern matching on types.</p>", "authors": [{"name": "Catherine Dubois", "author_profile_id": "81100177603", "affiliation": "Universit&#233; d'Evry Val d'Essonne, 91025 Evry Cedex and INRIA, BP 105, 78153 Le Chesnay", "person_id": "PP14072168", "email_address": "", "orcid_id": ""}, {"name": "Fran&#231;ois Rouaix", "author_profile_id": "81100620569", "affiliation": "Universit&#233; d'Evry Val d'Essonne, 91025 Evry Cedex and INRIA, BP 105, 78153 Le Chesnay", "person_id": "P84963", "email_address": "", "orcid_id": ""}, {"name": "Pierre Weis", "author_profile_id": "81100380431", "affiliation": "Universit&#233; d'Evry Val d'Essonne, 91025 Evry Cedex and INRIA, BP 105, 78153 Le Chesnay", "person_id": "P227434", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199473", "year": "1995", "article_id": "199473", "conference": "POPL", "title": "Extensional polymorphism", "url": "http://dl.acm.org/citation.cfm?id=199473"}