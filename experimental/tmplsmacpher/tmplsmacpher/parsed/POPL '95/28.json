{"article_publication_date": "01-25-1995", "fulltext": "\n Monad Transformers and Modular Interpreters* Sheng Liang Paul Hudak Mark Jonest Yale University Department \nof Computer Science New Haven, CT 06520-8285 {li-ang, hudak, j ones -mark}@cs. yale. edu Abstract We \nshow howa set of building blocks can be used to construct programming language interpreters, and present \nimplemen\u00adtations of such building blocks capable of supporting many commonly known features, including \nsimple expressions, three different function call mechanisms (call-by-name, call\u00adby-value and lazy evaluation), \nreferences and assignment, nondeterminism, first-class continuations, and program trac\u00ading. The underlying \nmechanism of our system is monad frans\u00adfonners, a simple form of abstraction for introducing a wide range \nof computational behaviors, such as state, 1/0, con\u00adtinuations, and exceptions. Our work is significant \nin the following respects. First, we have succeeded in designing a fully modular interpreter based on \nmonad transformers that includes features miss\u00ading from Steele s, Espinosa s, and Wadler s earlier efforts. \nSecond, we have found new ways to lift monad operations through monad transformers, in particular difficult \ncases not achieved in Moggi s original work. Third, we have demon\u00ad strated that interactions between \nfeatures are reflected in liftings and that semantics can be changed by reordering monad transformers. \nFinally, we have implemented our interpreter in Gofer, whose constructor classes provide just the added \npower over Haskell s type classes to allow precise and convenient expression of our ideas. This implementa\u00adtion \nincludes a method for constructing extensible unions and a form of subtyping that is interesting in its \nown right. 1 Introduction and Related Work This paper discusses how to construct programming lan\u00adguage \ninterpreters out of modular components. We will show how an interpreter for a language with many features \ncan be composed from building blocks, each implementing \u00b7This work was supported by the Advanced ResearchProject \nAgency and the Oi%ce of Naval Research under Arpa Order 8888, Contract NOO014-92-C-0153. TCurrent addresa: \nDepartment of Computer science, uIIiVWSity Of Nottingham, University Park, Nottingham NG7 2RD, England. \nEmail: mpj@cs. nott .ac. uk. Permission to copy without fee all or part of this materfal is granted provided \nthat the copies are not made or distributed for direct commercial advantage, the ACM copyrigM notice \nand the title of the publication and its date appear, and notice is given that oopying is by permission \nof the Association of CompW ng Machinery. To copy otherwise, or to republish, requires a fee and/or specific \npermission. POPL 951/95 San Francisco CA USA 0 1995 ACM 0-89791 -692-1/95/0001 ....$3.50 a specific feature. \nThe interpreter writer is able to specify the set of incorporated features at a very high level. The \nmotivation for building modular interpreters is to isolate the semantics of individual programming language \nfeatures for the purpose of better understanding, simplifying, and implementing the features and their \ninteractions. The lack of separability of traditional denotational semantics [19] has long been recognized. \nAlgebraic approaches such as Mosses action semantics [16], and related efforts by Lee [131, Wand [231, \nAppel &#38; Jim [11, Kelsey &#38; Hudak [111, and others, attempt to solve parts of this problem, but \nfall short in several crucial ways} A ground-b~aking attempt to better solve the overall problem began \nwith Moggi s [151 proposal to use monads to structtue denotational semantics. Wadler [211 popularized \nMoggi s ideas in the functional programming community by showing that many type constructors (such as \nList) were monads and how monads could be used in a variety of settings, many with an imperative feel \n(such as in Peyton Jones &#38; Wadler [17]). Wadler s interpreter design, however, treats the interpreter \nmonad as a monolithic structure which has to be reconstructed every time a new feature is added. More \nrecently Steele [181 proposed pseudomonadesas a way to compose monads and thus build up an interpreter \nfrom smaller parts, but he failed to properly incorporate important features such as an environment and \nstore, and struggled with restrictions in the Haskell [71 type system when trying to implement his ideas. \nIn fact, pseudomonades are really just a special kind of monad transformer, first suggested by Moggi \n[15] as a potential way to leave a hole in a monad for further extension. Returning to Moggi s original \nideas, Espinosa [4] nicely formulated in Scheme a system called Semantic Lego the first modular interpreter \nbased on monad transformers and laid out the issues in lifting. Espinosa s work reminded the programming \nlanguage community (including us) who had become distracted by the use of monads that Moggi himself, \nresponsible in many ways for the interest in monadic programming, had actually focussed more on the importance \nof monad transformers. We begin by realizing the limitations of Moggi s frame\u00adwork and Espinosa s implementation, \nin particular the diffi\u00adculty in dealing with complicated operations such as callcc, and investigate \nhow common programming language fea\u00ad lVery recently, CartWright and Felleisen [31have independently proposed \na modular semantics emphasizing a di?ectsemantics approach, which seems somewhat more complex than ours; \nthe pxecise dationship between the appm=hes is, however, not yet clear. type Term = OR TermA -\u00ad arithmetic \ntype lnterpM ( OR TermF -\u00ad functions ( OR TwmR -\u00ad assignment ( OR TermL -\u00ad lazy evaluation ( OR TermT \n-\u00ad tracing ( OR TermC -\u00ad callcc TermN -\u00ad nondeterminism ))))) type Value = OR Int (OR Fun ()) Figure \n1: A modular tures interact with each other. In so doing we are able to express more modularity and more \nlanguage features than in previous work, solving several open problems that arose not only in Moggi s \nwork, but in Steele s and Espinosa s as well. Our work also shares results with Jones and Duponcheel \ns [101 work on composing monads. Independently Espinosa [51 has continued working on monad transformers, \nand has also recognized the limitations of earlier approaches and proposed a solution quite different \nfrom ours. His new approach relies on a notion of higher\u00adorder monads (called situated monads) to relate \ndifferent layers of monad transformers, and he has investigated the semantic implications of the order \nof monad transformer composition. It is not yet clear how his new approach relates to ours. We use Gofer \n[81 syntax, which is very similar to Haskell s, throughout the paper. We choose Gofer over Haskellbecause \nof its extended type system, and we choose a functional language over mathematical syntax for three reasons: \n(1) it is just about as concise as mathematical syntax,2 (2) it emphasizes the fact that our ideas are \nimplementable (and thus have been debugged!), and (3) it shows how the relatively new idea of constructor \nckzsses [9] can be used to represent some rather complex typing relationships. Of course, monads can \nbe expressed in a variety of other (higher-order) programming languages, in particular SML [141, whose \ntype system is equally capable of expressing some of our ideas. The system could also be expressed in \nScheme, but of course we would then lose the benefits of strong static type-checking. Our Gofer source \ncode is available via anonymous ftp from nebuZa.cs.yaZe.eduin the directory pub/yak-fi/modular-inferpre \nfer. To appreciate the extent of our results, Figure 1 gives the high-level definition of an interpreter, \nwhich is constructed in a modular way, and supports arithmetic, three different kinds of functions (call-by-name, \ncall-by-value, and lazy), references and assignment, nondeterminism, first-class con\u00adtinuations, and \ntracing. The rest of the paper will provide the details of how the type declarations expand into a full \ninterpreter and how each component is built. For now just note that OR is equivalent to the domain sum \noperator, and Term, Value and InterpM denote the source-level terms, run\u00adtime values, and supporting \nfeatures (which can be regarded as the run-time system), respectively. Int and Fun are the semantic domains \nfor integers and functions. TflmA, TermF, etc. are the abstract syntax for arithmetic terms, function \n2Although (for lack of space)we do not include any proofs, all constructs (monads, monad transformers \nand liftinga) expressed as Gofer code have been verified to satisfy the necessarypmpertiee stated in \nthis paper. = StateT Store --memory cells ( EnvT Env --environment ( ConfT Answer --continuations ( StateT \nString J -trace output ( ErrorT List ll~~i~~~~&#38; )))) I interpreter expressions, etc. T~e constructors \nsuch as SfateT and ConfT are monad fransfor m$rs; they add features, and are used to transform the mona \nListinto the monad InterpM used by the interpreter, 1 To see how Term, alue, and InterpM constitute to \nmodular interpreters, in the rext section we will walk through some simple examples. 2 An Example A conventional \ninte preter maps, say a term, environment, and store, to an ansI er. In contrast, a monadic interpreter \nsuch as ours maps t~rms to computations, where the details of the environment, tore, etc. are hidden \n. Specifically: interp :; Term + nferpM Value where hzterpM Vu ue / is the interpreter monad of final \nanswers. What makes ou interpreter modular is that all three 1 components above the term type, the value \ntype, and the monad are config rable. To illustrate, if we initially wish to have an interpret r for \na small arithmetic language, we I can fill in the definitions as follows: type Value = /3RInt () type \nT~m ermA type InterpM z rrorT Id The first line declar i s the answer domain to be the union of integers \nand the ~nit type (used as the base type). The second line defines 4erms as TermA, the abstract syntax \nfor arithmetic operation . The final line defines the interpreter monad as a transfo ation of the identify \nmonad Id. The monad transformer ErrorT accounts for the possibility of errors; in this case, a~ thmetic \nexceptions. At this point the interpreter behaves like a calculator: > ((1+4)*8) 40 > (3/0) ERROR: divide \nby O Now if we wish o add function calls, we can extend the value domain with 1 nction types, add the \nabstract syntax for function calls to the term type, and apply the monad transformer EnvT to introduce \nan environment Env. type Value = L R Int (OR Fun ()) type Term . bR TermF T~mA type InterpM = knvT Env \n(ErrorTId) 3For lack of space,we ~omitthe details of parsing and printing. instance Functor Tree where \n Here is a test run map f (Leaf x) = Leaj (f a) ~ ((\\m(z + 4)) 7) L1 > (2+4) ERROR: unbound variable: \nx By adding other features, we can arrive at (and go beyond) the interpreter in Figure 1. In the process \nof adding new source-level terms, whenever a new value domain (such as Boolean) is needed, we extend \nthe Value type, and to add a new semantic feature (such as a store or continuation), we apply the corresponding \nmonad transformer. Why monads? In a sense, monads are nothing more than a good example of data abstraction. \nBut they just happen to be a particularly good abstraction, and by using them in a disciplined (and appropriate) \nway, we generally obtain well-structured, modular programs. In our application, they are surprisingly \nuseful for individually capturing the essence of a wide range of programming language features, while \nabstracting away from low-level details. Then with monad transformers we can put the individual features \ntogether, piece-by-piece in different orders, to create full-featured interpreters. 3 The Constructor \nClass System For readers not familiar with the Gofer type system (in particular, constructor classes \n[9]), this section provides a motivating example. Constructor classes support abstraction of common fea\u00adtures \namong type constructors. Haskell, for example, pro\u00advides the standard map function to apply a function \nto each element of a given list map :: (a+ b)+ [a] +-[b] Meanwhile, we can define similar functions \nfor a wide range of other datatypes. For example data Tree a = Leaf a I Node (Tree a) (Tree a) mapTree \n:: (a+ b) + Tree a + Tree b rrupTree $ (Leaf z) = Leaf (~ z) mapTree ~ (Node 2 r) = Node (mapTree ~ 1) \n(mapTree ~ r) The mapTree function has similar type and functionality to those of map. With this in \nmind, it seems a shame that we have to use different names for each of these variants. Indeed, Gofer \nallows type variables to stand for type constructors, on which the Haskell type class system has been \nextended to support overloading. To solve the problem with map, we can introduce a new constructor class \nFunctor (in a categorical sense): class Functor f where map:: (a+ b)+ fa+fb Now the standard list (List) \nand the user-defined type con\u00adstructor Tree are both instances of Functon instance Functor List where \n~Pf[l = [1 mflpf(x:xs) = fx:mapfxs mapf (Nodeir) = Node(mapf 1)(mapf r) In building modular interpreters, \nwe will find constructor classes extremely useful for dealing with multiple instances of monads and monad \ntransformers (which are all type constructors). 4 Extensible Union Types We begin with a discussion of \na key idea in our framework how values and terms may be expressed as extensible union types. (This facility \nhas nothing to do with monads.) The disjoint union of two types is captured by the datatype OR. data \nORab = Lal Rb where Land Rare used to perform the conventional injection of a summand type into the union; \nconventional pattern\u00admatching is used for projection. However, such injections and projections only work \nif we know the exact structure of the union; in particular, an extensible union may be arbitrarily nested, \nand we would like a sing.k pair of injection and projection functions to work on all such constructions. \nTo achieve this, we define a type class to capture the summand/union type relationship, which we refer \nto as a subtype relationship: class SubType sub sup where inj :: sub + SUP . -injection prj :: sup + \nMaybe sub --projection data Maybe a = Just a I Nothing The Maybe datatype is used because the projection \nfunction may fail. We can now express the relationships that we desire: instance SubT~e a (OR a b) where \ninj L prj (Lz) ~ Justz prj -= Nothing instance SubT~e a b + SubT~e a (OR c b) where inj = R.inj prj \n(Ra) = prj a prj. = Nothing Now we can see, for example, how the Value domain used in the interpreter \nexample given earlier is actually constructed: type Value = OR Int (OR Fun ()) type Fun = InterpM Value \n+ InterpM Value Whh these definitions the Gofer type system will infer that Int and Function are both \nsubtypes of Value, and the coercion functions inj and prj will be generated automatically.4 (Note that \nthe representation of a function is quite general it maps amputations to computations. As will be seen, \nthis generality allows us to model both call-by-name and call-by\u00advalue semantics.) Awe +~ ld point cm \nhere that most of the typing problems Steele encountered disappear with the use of our extensible union \ntypes; in particular, there is no need for Steele s towers of datetypes. 5 The Interpreter Building \nBlocks As in the example of Section 2, the Term type is also constructed as an extensible union (of subterm \ntypes). We define additionally a class InterpC to characterize the term types that we wish to interpret: \nclass InferpC t where interp :: t -+ lnterpM Value  The behavior of interp on unions of terms is given \nin the obvious way: instance (InterpC tl, InterpC t2) * InterpC (OR tl t2) where inferp (.L t) = irzte~ \nt interp (R t) = interp t The interp function mentioned in the opening example is just the method associated \nwith the top-level type Term. In the remainder of this section we define several repre\u00adsentative interpreter \nbuikling blocks, each an instance of class InterpC and written in a monadic style. We will more for\u00admally \ndefine monads later, but for now we note that the interpreter monad In ferpM comes equipped with two \nbasic operations: unit :: a + InterpM a bind :: InterpM a + (a + In ferpM b) + InterpM b Intuitively \nInferpM a denotes a computation returning a result of type a. Unit f is a null computation that just \nreturns x as result, whereas m bind k runs m and passes the result to the rest of the computation k As \nwill be seen, besides unit and bind, each interpreter building block has several other operations that \nare specific to its purpose. 5.1 The Arithmetic Building Block Our (very tiny) arithmetic sublanguage \nis given by data TermA = Num Int I Add Term Term  whose monadic interpretation is given by: instance \nInterpC TermA where interp (Num z) = unifInj x interp (Add x y) = interp x bindPrj \\i + interp y bindPrj \n\\j + zmitIrzj ((i+ j) :: Int) unitInj = unit . inj m bindPrj k = m bind /a --+ case (p-j a) of Justx \n+ kx Nothing -+ err run-time type error err :: string+ lnterpM a --defined later Note the simple use \nof inj and prj to inject/project the integer result into/out of the Value domain, regardless of how Value \nis eventually defined (unifhzj and bindPrj make this a tad easier, and will be used later as well). Err \nis an operation for reporting errors to be defined later. 5.2 The Function E Our function subk data \nTermF = Vu I La I La I Ap which supports two name, the other for c We assume a ~ variable names witl \nclosure mode of e tions: lookupEnv :: Na exfendEnv :: (M type Name = Sfr In addition, we will rdEnv and \ninEnv, thi perform a computatil rdEnv :: InterpM inEnv :: Env + I The interpretation o given in Figure \n2. The difference b~ is clear: the former r the function body, w application, the func checks if it is \nindee is packaged up wit; closure, which is the realize dynamic SCOF computation of ez ak When applying \na putation which gets the function body. A not correspond to ar however, we expect information or a spef \nwill enable us to opti We note that Stel preter always had an was only used in the environment-related \nrdEnv), we achieve e:  5.3 The References A sublanguage of ref data TermR = R< I De 1 As Given a heap \nof n managing it: allocLoc :: Infe7 lookupLoc :: Loc updafeLoc :: (Lot type Loc = Int we can then give \nan language feattires: ilding Block guage is given by: !Vame 5daN Name Term cbn .\u00ad5daV Name Term cbv \nTerm Term inds of abstractions, one for call-by\u00adl-by-value. Env of environments that associates computations \n(corresponding to the luation [2]), and that has two opera\u00ad ? + Env + Maybe (InferpM Value) W, InterpM \nValue) -+ Env d Env g lefine later two monadic operations, return the current environment and (in a given \nenvironment, respectively: 2 0 erpM a q InterpM a the applicative sublanguage is then veen call-by-value \nand call-by-name lutes the argument before evaluating lreas the latter does not. In a function m itself \nis evaluated first, and bindPrj a function. The computation of ez the current environment to form a passed \nto ~. We could just as easily Lg by passing not the closure, but the e. N-by-value function, we build \na com\u00advaluated immediately upon entering bough semantically correct, this does ?fficient implementation. \nIn practice, at the presence of some kind of type J syntax for call-by-value application tie away this \noverhead. ? felt it unsatisfactory that his inter\u00adnvironment argument, even though it mction building \nblock. By abstracting Oerations as two functions (inEnv and ctly what Steele wished for. md Assignment \nBuilding Block :ences and assignment is given by: Term Term -f !@zTerm Term mory cells and three functions \nfor M LOC , InterpM Value InferpM Value) + InferpM () Appropriate interpretation to the new instance \nIntermC TermF where interp (V&#38;v) = rdEnv bind \\env + case lookupEnv v env of Just val + val Nothing \n+ err ( unbound uartible: ++ v) interp (LambdaNs t) = rdEnv bind \\env + zmithj (\\arg + inEnv (extendEnv \n(s, arg) env) (itzterp t)) interp (LambdaVs t) = rdEnv bind \\env + unitInj (\\arg + arg bind \\v + inEnv \n(extendEnv (s, unit v) env) (interp t)) irzterp (App el e2) = interp el bindPrj \\ f + rdEnv bind \\env \n-+ ~ (inEnv env (interp ez)) Figure 2: The function building block instance InterpC TermR where interp \n(Re~ x) = interp x bind /val -i allocLoc bind \\loc + updateLoc (1oc, unit val) bind \\. + unithj 10C interp \n(Deref x) = interp z bindPrj \\loc -+ lookupLoc 10C interp (Assign lhs rhs) = interp lhs bindPrj \\loc \n+ inte~ rhs bind \\val + updateLoc (1oc, unit val) bind \\-+ unit val 5.4 A Lazy Evaluation Building Block \nUsing this same heap of memory cells for references, we can implement lazy abstractions: data TermL \n= LambdaL Name Term whose operational semantics implies caching of results. instance InterpC TermL where \ninterp (LambdaLs t) = rdEnv bind \\env ~ unitInj (\\arg + allocLoc bind \\loc + let thunk = arg bind \\v \n+ updateLoc (20c, unit v) bind \\.+ unit v in updateLoc (Ioc, thunk) bind \\.+ inEnv (extendEnv (s, 2ookupLoc \nIoc) env) (interp t)) Upon entering a lazy function, the interpreter first allocates a memory cell \nand stores a thunk (updatable closure) in it. When the argument is first evaluated in the function body \nthe interpreter evaluates the thunk and stores the result back into the memory cell, overwriting the \nthunk itself. 5.5 A Program Tracing Building Block Given a function write :: String+ InterpM () which \nwrites a string output and continues the computation, we can define a tracing sublanguage, which attaches \nlabels to expressions which cause a trace record to be invoked whenever that expression is evaluated: \ndata TermT = Tracz String Term instance InterpC TermT where interp (Trace t t) = write ( enter ++ 1) \nbind \\-+ interp t bind \\v + write ( leave ++ l++ with: ++ show v) bind \\.. + unit v Here we see that \nsome of the features in Kishon et al. s system [12] are easily incorporated into our interpreter.  5.6 \nThe Continuation Building Block First-class continuations can be included in our language with data TermC \n= CallCC Using the callcc semantic function (to be defined later): allcc :: ((u + InterpM b) + InterpM \na) + Inte~M u we can give an interpretation for CallCC: instance InterpC TermC where interp Ca21CC = \nunitInj (\\j -+ f bindPrj \\f + udlcc (\\/c + (f (unitInj (\\a +. a bind k))))) CallCC is interpreted as \na (strict) builtin function. Interp in this case does nothing more than inject and project values to \nthe right domains. Feature Function Error handling err:: String +InterpMa Nondeterminism merge:: [htterpMa] \n+hzterpMa Environment rdEnv:: IntervM Env inEnv:: Env + Interph a + InterpM a Store allocLoc:: I nterpM \nInt lookupLoc:: Int + InterpM Value updateLoc:: (Int, InterpM Value) + InterpM Int String output write \n:: String + InterpM () Continuations callcc :: Ka + IntervM b) + IntervM a) + IntervM a Table 1: Monad \noperations used by the interpreter 5.7 The Nondeterminism Building Block Our nondeterministic sublanguage \nis given by: data TermN = Amb [Term] Given a function: merge :: [InterpM a] + InterpM a which merges \na list of computations into a single (nondeter\u00administic) computation, nondeterminism interpretation can \nbe expressed as: instance InterpC TermN where interp (Arnb t) = merge (map interp t)  6 Monads With \nOperations As mentioned earlier, particular monads have other opera\u00adtions besides unit and bind. Indeed, \nfrom the last section, it is clear that operations listed in Table 1 must be supported. If we were building \nan interpreter in the traditional way, now is the time to set up the domains and implement the functions \nlisted in the table. The major drawback of this monolithic approach is that we have to take into account \nall other features when we define an operation for one specific feature. When we define callcc, for example, \nwe have to decide how it interacts with the store and environment etc. And if we later want to add more \nfeatures, the semantic domains and all the functions in the table will have to be updated. Monad transformers, \non the other hand, allow us to individ\u00adually capture the essence of language features. Furthermore, the \nconcept of lifting allows us to account for the interactions between various features. These are the \ntopics of the next two sections. To simplify the set of operations somewhat, we note that both the store \nand output (used by the tracer) have to do with some notion of state. Thus we define allocLoc, lookupLoc, \nupdateLoc, and write in terms of just one function update :: (s+ s) + InterpMs for some suitably chosens. \nWe can read the state by passing update the identity function, and change the state bypassing it a state \ntransformer. For example: write msg = update (\\ sofar + sofar ++ msg) bind \\.+ unit () 7 Monad Transformers \nTo get an intuitive feel for monad transformers, consider the merging of a state monad with an arbitrary \nmonad, an example adapted from Jones s constructor class paper [9]: type StateTsma = s+m(s, a) Note that \nthe type variable m above stands for a type constructor, a fact automatically determined by the Gofer \nkind inference system. It turns out that if rn is a monad, so is StateTs m .5 StateT s is thus a monad \ntransformer. For example, if we substitute the identity monad: typeIda = a for m in the above monad transformer, \nwe arrive at: StateTs Id a = s+ Id (s,a) = s+(s, a) which is the standard state monad found, for example, \nin Wadler s work [21]. The power of monad transformers is two-fold. First, they add operations (i.e. \nintroduce new features) to a monad. The StateT monad transformer above, for example, adds states to the \nmonad it is applied to, and the resulting monad accepts update as a legitimate operation on it. Second, \nmonad transformers compose easily. For exam\u00adple, applying both StateT s and StateT t to the identity \nmonad, we get: StateT t (StateTs Id) a = t + (StateTs Id) (t, a) = t+s+(s, (t, a)) which is the expected \ntype signature for transforming both states s and t. The observant reader will note, however, an immediate \nproblem: in the resulting monad, which state does update act upon? In general, this is the problem of \nlifting monad operations through transformers, and will be addressed in detail later. But first we define \nmonads and monad transformers more formally, and then describe monad transformers covering the features \nlisted in Section 5. We can formally define monads as follows: srnfact.Wat~ T~# is only legal in the \ncurrent version of Gofer if 5 tateT is a datatype rather than a type synonym. This does not limit our \nresults., but does introduce superfluous data constructors that slightly complicate the presentation, \nso we will use type declarations as if they worked as data declarations. class Monad m where unit :: \na+ma bind :: ma+(admb)+mb map :: (a+ b)+ma+mb join :: m(ma)+ma mapfm = m bind \\a ~ unit (f a) join z \n= z bind id The two functions map and join, together with unit provide an equivalent definition of monads, \nbut are easily defined (as default methods) in terms of bind and unit. To be a monad, bind and unit must \nsatisfy the well-known Monad Laws [21]: Left unit (unit a) bind k = k a Right unit: m bind unit = m Associativity: \nm bind \\a -i (k a bind h) = (m bind k) bind h We define a monad transformer as any type constructor \nt such that if m is a monad (based on the above laws), so is tm . We can express this (other than the \nverification of the laws, which is generally undecidable) using the two\u00adparameter constructor class MonadZ \nclass (Monad m, Monad (t m)) + MonadT t m where lij? :: ma+tma  The member function lift embeds a computation \nin monad m into monad t m . Furthermore, we expect a monad transformer to add features, without changing \nthe nature of an existing computation. We introduce Monad Transformer Laws to capture the properties \nof hjl: lip . unitm = unittm lijl (m bind~ k) = lift m bind,~ (lifi . k)  The above laws say that lifting \na null computation results in a null computation, and that lifting a sequence of com\u00adputations is equivalent \nto first lifting them individually and then combining them in the lifted monad. Specific monad transformers \nare described in the remain\u00adder of this section. Some of these (StateT, ContT, and ErrorT) appear in \nan abstract form in Moggi s note [15]. The envi\u00adronment monad is similar to the state reader by Wadler \n[22]. The state and environment monad transformers are related to ideas found in Jones and Duponcheel \ns [9] [10] work. 7.1 State Monad Transformer Recall the definition of state monad transformer StateT: \ntype StateT s m a = s + m (s)a) Using instance declarations, we now wish to declare both that StateTs \nm is a monad (given m is a monad), and that StateT s is a monad transformer (for each of the monad transformers \ndefined in subsequent subsections, we will do exactly the same thing). First, we establish the monad \ndefinition for StateTs m , involving methods for unit and bind instance Monad m $ Monad (StateTs m) where \nunit x = \\s + unit (s,z) m bind k = \\so + m so bind \\(sl, a) + kasl Note that these definitions are not \nrecursive; the constructor class system automatically infers that the bind and unit appearing on the \nright are for monad m. Next, we define StuteT s as a monad transformer instance (Monad m, Monad (StateTs \nm)) + MonadT (StateTs) m where lijl m = \\s + m bind \\x -+ unit (s,x) Note that lift simply runs m in \nthe new context, while preserving the state. Finally as explained earlier, a state monad must support \nthe operation update. To keep things modular, we define a class of state monads: class Monad m + StateMonads \nm where update :: (s+s)+ms In particular, StateT s transforms any monad into a state monad, where update \nf applies f to the state, and returns the old state instance Monad m + StateMonads (StateTs m) where \nupdate f = \\s + unit (fs,s)  7.2 Environment Monad Transformer EnvT/ transforms any monad into an environment \nmonad. The definition of bind tells us that two subsequent compu\u00adtation steps run under the same environment \nr. (Compare this with the state monad, where the second computation is run in the state returned by the \nfirst computation.) Liji just performs a computation which cannot depend on the environment and ignores \nthe environment, InEnv ignores the environment carried inside the monad, and performs the computation \nin a given environment. type EnvTrma = r+ma instance Monad m ~ Monad (EnvT r m) where unita = \\r+unita \nm bind k = \\r+mr bind \\a+kar instance (Monad m, Monad (EnvT r m)) + MonadT (EnvT r) m where lift m = \n\\r+m class Monad m ~ EnvMonad env m where inEnv :: env+ma+ma rdEnv :: m env instance Monad m + EnvMonad \nr (EnvT r m) where inEnv r m = \\.+mr rdEnv = \\r+unitr 7,3 Error Monad Transformer Monad Error completes \na series of computations if all suc\u00adceed, or aborts as soon as an error occurs. The monad transformer \nErrorT transforms a monad into an error monad. data EYYor a = Ok a I Error String. type ErrorT m a = \nm (Ejror a) instance Monad m ~ Monad (ErrorT m) where class Monad m * ListMonad m where unit = unit \n. Ok merge :: [tid]+ma m bind k = instance ListMona dList where m bind /a + merge = cor+zt case a of \n(okx) + kz (Error msg) -+ unit (Error msg) 8 Lifting Operatl Ans instance (Monad m, Monad (ErrorT m)) \nq We have introduced monad transformers that add useful MonadT ErrorT m where operations to a giv An \nmonad, but have not addressed how lift = map unit these operations c~n be carried through other layers \nof monad transforme~s, or equivalently, how a monad trans\u00adclass Monad m ~ ErrMonad m where former lifts \nexisting operations within a monad. err :: String + m a Lifting an oper Ltlon f in monad m through a \nmonad transformer tresul s in an operation whose type signature instance Monad m ~ ErrMonad (ErrorT m) \nwhere can be derived by Isubstituting all occurrences of m in the err = unit . Error type off with t \nm ~. For example, lifting inEnv :: r + m a + m a through t results in an operation with type r+. t m \na~t ma.  7.4 Continuation Monad Transformer Given the types of operations in monad m: We define the \ncontinuation monad transformer as: .._ (type constants) T ; : (type variables) I T + r (function types) \ntype ContTans m a = (a +-mans) + mans instance Monad m + Monad (ContT ans m) where [ (r, r) (product \ntypes) unit x = \\k-+kx 1 mt-(monad types) m bind f = \\k-+m(\\a-+fak) [1, is the mapping ~f types across \nthe monad transformer t ConfT introduces an additional continuation argument (of [Al , =A type a+ mans \n), and by the above definitions of unit and (al, bind, all computations in monad ContT ans m are carried \n(TI -+?21, : YTllt+ [721, out in a continuation passing style. ((?-l , 72)1, = ([i-llt, [7?.1,) Lift \nfor Cent ans m turns out to be the same as bind for [m T1, = tm [-rlt m. (It is easy to see this from \nthe type signature.) Callcc Moggi [15] studied the problem of lifting under a categor\u00adf invokes the computation \nin f, passing it a continuation ical context. The ob~ective was to identify liftable operationsthat once \napplied, throws away the current continuation from their type sig~tures. Unfortunately many useful oper\u00ad(denoted \nas - ) and invokes the captured continuation k. ations such as merge, inEnv and callcc failed to meet \nMoggi s criteria, and were le ft unsolved. instance (Monad m, Monad (ContT ans m)) a We individually \nconsider how to lift these difficult cases. MonadT (ContT ans) m where This allows us to m ake use of \ntheir definitions (rather than just the types), and nd ways to lift them through all monad lift = bind \n k class Monad m + ContMonad m where transformers studiqd so far. This is exactly where monad transformers \nprovide us with an opportunity to study how various programming callcc :: ((a+mb)+ma)+ma language features \ni teract. The easy-to-lift cases correspondinstance Monad m + ContMonad (ConfT ans m) where to features \nthat ar i independent in nature, and the more involved cases reqdke a deeper analysis of monad structures \nin order to clarify t e semantics. CJdrccf = \\k+f(\\a+\\-+ka)k  7.5 The List Monad + An unfortunate consequence \nof our approach is that as we consider more mo~ad transformers, the number of possibleJones and Duponcheel \n[10] have shown that lists compose with special kinds of monads called commutative monads. It Iit%ngs \ngrows quadratically. It seems, however, that there are not too many different kinds of monad transformersis \nnot clear, however, if lists compose with arbitrary monads. (although there m be many instances of the \nsame monad transformer such as StateT). What we introduced so far Since many useful monads (e.g. state, \nerror and continuation J monads) are not commutative, we cannot define a list monad transformer one \nwhich adds the operation merge to any are able to model almost all commonly known features of monad, \nsequential languag~. Even so, not all of them are strictly necessary. The envmonment, for example, can \nbe simulatedFortunately, every other monad transformer we have using a state monarJ:considered in this \npaper takes arbitrary monads. We thus use lists as the base monad, upon which other transformers instance \n(Monad m , StateMonad r m) ~ can be applied. m where EnvMonad r inEnv r m =U palate (\\. + r) bind \\o \n+ instance Monad List where m bind \\u + unitx = [z] &#38;;~ (\\-+ o) bind \\_+ [] bind k = [1 (z: m) \nbind k = k z++ (XS bind k) rdEnv = ~pdate id Also, as is well known, error reporting can be implemented \nusing callcc. 8.1 Correctness Criteria The basic requirement of lifting is that any program which does \nnot use the added features should behave in the same way after a monad transformer is applied. The monad \ntrans\u00adformer laws introduced in Section 6 are meant to guarantee such property for lifting a single computation. \nMost monad operations, however, have more general types. To deal with operations on arbitrary types, \nwe extend Moggi s corre\u00adsponding categorical approach, and define L, as the natural lijlirzg of operations \nof type ~ along the monad transformer t: L. :: -7-+ [Tit LA =id (1) c. =id (2) z., +q = \\f +f ~ ~qch \nthat =,cn. f (3) = \\(a, b) J (G, a, Lq b) (4)~(rlm) L mr = lijt . (nrap z.) (5) Constant types (such \nas Integer) and type variables do not depend on any particular monad. (See cases 1 and 2.) On the other \nhand, we expect a lifted function, when applied to a value lifted from the domain of the original function, \nto return the lifting of the result of applying the original function to the unlifted value. This relationship \nis precisely captured by equation 3, which corresponds to the following commuting diagram L.l I The lifting \nof tuples is straightforward. Finally the Efl operator come with the monad transformer lifts computa\u00adtions \nexpressed in monad types. Note that C* is mapped to the result of the computation, which may involve \nother computations. Note that the above does not provide a Gofer definition for an overloaded lifdng \nfunction .C. The such that clause in the third e uation specifies a constraint, rather than a $ definition \nof f, In practice, we first find out by hand how to lift an operation through a certain (or a class oo \nmonad transformer, and then use the above equations to verify that such a lifting is indeed natural. \nGenerally we require operations to be lifted naturally although as will be seen, certain unnatural liftings \nchange the semantics in intewsting ways. 8.2 Easy Cases Err and update are handled by lij 1, whereas \nmerge benefits from List being the base monad. instance (ErrMonad m, MonadT t m) ~ ErrMonad (t m) where \nerr = lifi . err instance (StateMonad m, MonadT t m) =+- StateMonad (t m) where update = lijl . update \n instance MonadT t List + ListMonad (t List) where merge = join. lifi  8.3 Lifting Callcc The following \nlifting of cdcc through EnvT discards the current environment r upon invoking the captured contin\u00aduation \nk. The execution will continue in the environment r captured when callcc was first invoked. instance \n(MonadT (EravT r) m, ContMonad m) ~ ContMonad (EnvT r m) where callcc :: ((a+r+rn b)+r+ma)+r+ma cdcc \n~ = \\r + cdcc (\\k + ~(\\a -+\\r -+ka)r) The Appendix shows that if we fllp the order of monad transformers \nand apply ContT to EnvT env W in which case no lifting of cdlcc will be necessary the current environment \nwill be passed to the continuation. (We will see how to fix this by carefully recovering the environment \nwhen we lift inEnv in a moment.) In general we can swap the order of some monad trans\u00adformers (such as \nbetween StateT and EYZVT),but doing so to others (such as ConfT) may effect semantics. This is consistent \nwith Filinski s observations [61, and, in practice, provides us an opportunity to fine tune the resulting \nseman\u00adtics. In lifting callcc through StateT s , we have a choice of passing either the current state \nS1 or the captured state so. The former is the usual semantics for cdlcc, and the latter is useful in \nTolmach and Appel s approach to debugging [201. instance (MonadT (StateT s) m, ContMonad m) * ContMonad \n(StateTs m) where -. Callcc :: ((a+s+m (s, b))+s+m(s, a)) +s+rn(s, a) callcc f = \\sll + Callcc (\\k + \nf (\\a + \\sl -+ k (sl, a)) so) The above shows the usual callcc semantics, and can be changed to the \ndebugging version by instead passing (so, a)to k The lifting of inEnv through ErrorT can be found in \nthe Appendix.  8.4 Lifting InEnv We only consider lifting inEnv through CorztT here; the Appendix shows \nhow to lift inEnv through other monad transformers. instance (MonadT (ContT am) m, EnvMonad r m) =% EnvMonad \nr (ConfT ans m) where inEnv r c = \\k ~ rdEnv bind \\o + inEnv r (c (inEnv o. k)) rdEnv = lifi rdEnv We \nrestore the environment before invoking the continu\u00ad ation, sort of like popping arguments off the stack. \nOn the other hand, an interesting (but not natural) way to lift irzEnv is: instance (MonadT (ContT ans) \nm, EnvMonad r m) + [8] Mark P. Jones. Introduction to gofer 2.20. Ftp from EnvMonad r (ContT ans m) \nwhere nebula. cs.yale.e du in the directory pub/haskell/gofer, inEnv rc = \\k + inEnv r(ck) September \n1991 . rdEnv = lijl rdEnv [9] Mark l?. Jones. h system of constructor classes: Over-Here the environment \nis not restored when c invokes k, loading and i 1plicit higher-order polymorphism. In and thus reflects \nthe history of dynamic execution. FPCA 93: Con erence on Functional Programming Lan\u00ad ? guages and Com@ter \nArchitecture, Copenhagen, Denmark, pages 52-61, New York, June 1993. ACM Press. Conclusions [10] Mark \nP. Jones ~nd Luc Duponcheel. Composing mon- We have shown how a modular monadic interpreter can ads. \nResearch Report YALEU/DCS/RR-1004, Yale Uni\u00ad be designed using two key ideas: extensMe union types versity \nDepart~ent of Computer Science, New Haven, and monad transformers, and implemented using constructor \nConnecticut, December 1993. classes. A key technical problem that we had to overcome was the lifdng of \noperations through monads. Our ap-[11] Richard Kelsey and Paul Hudak. Realistic compilation proach also \nhelps to clarify the interactions between various by program tra sformation. In ACM Symposium on Prin\u00ad \nn programming language features. cip.ks of Progran/ming Languages, pages 181 192, January Thk paper \nrealized Moggi s idea of a modular presen-1989. I tation of denotational semantics for complicated languages, \nand is much cleaner than the traditional approach [19]. On [12] Amir Kishon, ~aul Hudak, and Charles \nConsel. Mon\u00aditoring semant~cs: A formal framework for specifying, the practical side, our results provide \nnew insights into implementing ~nd reasoning about execution monitors. designing and implementing programming \nlanguages, in [n Proczediruzs ~f the ACM SIGPLAN 91 Conference on particular, extensible languages, which \nallow the program\u00admer to specify new features on top of existing ones. Programmin~L&#38;guage Design \nand Implementation, pages 338-352, June 191. ? Acknowledgements [131 Peter Lee. Realbtic Compiler Generation. \nFoundations of Computing. NdT Press, 1989. We thank Dan Rabinf Zhong Shao, Rajiv Mirani and anony\u00ad [14] \nRobin Milner, Mads Tofte, and Robert Harper. The mous referees for helpful suggestions. Definition of \nSta ndard ML. MIT Press, 1990. References [151 Eugenio Mogg . An abstract view of programming lan\u00adguages. \nTechni i al Report ECS-LFCS-90-113, Laboratory [1] Andrew W. Appel and Trevor Jim. Continuation-for Foundatio~s \nof Computer Science, University of passing, closure-passing style. In ACM Symposium on Edinburgh, Ed \nburgh, Scotland, 1990. + Principles of Programming Languages, pages 193-302, Jan\u00ad [16] Peter D. Mosses. \nA basic abstract semantic alge\u00ad uary 1989. bra. In Gilles Kahn, David B. MacQueen, and Gor\u00ad [2] Adrienne \nBless, Paul Hudak, and Jonathan Young. don D. Plotkin, editors, Semantics of Data Types: Interna-Code \noptimization for lazy evaluation. Lisp and Symbolic tional Symposiu L , Sophia-Antipolis, France, pages \n87-107. Computation, 1(1):147-164, 1988. Springer-Verla~, June 1984. Lecture Notes in Computer Science \n173. [3] Robert Cartwright and Matthias Felleisen. Extensible denotational semantics. In Proceedings \nof Symposium on [17] Simon Peyton Jones and Philip Wadler. Imperative Theoretiml Aspects of Computer \nSoftware, pages 244-272, functional pro ramming. In Prowedings 20th Symposium J 1994. on Principles \no) Programming Languages, pages 71-84. ACM, January 993. [4] David Espinosa. Modular denotational semantics. \nUn-) published manuscript, December 1993. [18] Guy L. Steele Jr. Building interpreters by composing monads. \nIn Cdnferenw Record of POPL 94: 21st ACM [5] David Espinosa. Building interpreters by transforming SIGPL~-SIG~CT \nSymposium on Principles of Program\u00adstratified monads. Unpublished manuscript, ftp from ming Languages, \nPortland, Oregon, pages 472492, New altdorf.ai.mit.edupub/dae, June 1994. York, January ~994. ACM Press. \n[6] Andrzej Filinski. Representing monads. In Conferenw [191 Joseph Stoy. D notational Semantics: The \nScoft-Strachey Record of POPL 94: 21st ACM SIGPLAN-SIGACT Sym- Approach to Pro gramming Language Theoy. \nMIT Press, posium on Principles of Programming Languages, Portland, 1977. Oregon, pages 446-457, New \nYork, January 1994. ACM Press. [20] Andrew P. Tolrhach and Andrew W. Appel. Debugging standard ML ~thout \nreverse engineering. In Proceed\u00ad [7] Paul Hudak, Simon Peyton Jones, and Philip Wadler. ings of the \n1990 ACM Conference on Lisp and Functional Report on the programming language Haskelh a non- Programming, \nNice, France, June 1990. strict, purely @nctional language, version 1.2. Technical Report YALEU/DCS/RR-777, \nYale University Depart-[21] Philip Wadler. The essence of functional program\u00ad ming. In Conferena Record \nof the Nineteenth Annual SIGPLAN Notices, Vol. 27(5), May 1992. ACM Symposidn on Principles of Programming \nLanguages, Albuquerque, Ntw Mexico, pages 1-14, January 1992. ment of Computer Science, March 1992. Also \nin ACM [22] Philip L. Wadler. Comprehending monads. In Prowed\u00adings of tke 1990 ACM Conferen@ on Lisp \nand Functional Programming, 1990. [23] Mitchell Wand. A semantic prototyping system. SIG-PLAN Notices, \nACM Symposium on Compikr Construction, 19(6):213-221, 1984. A The Ordering of ContT and EnvT It is interesting \nto compare the following two cdcc functions on monad M and N, both composed from ContT ans and EnvT m \n, but in different order. Case 1: type Ma = ContT am (ErwT r m) a = (a4r*mans)4r4mans callccf = \\k+-f(\\u+\\. \n+ka)k (eta convert \\r and \\r ) = \\k+\\r-j f(\\a+\\-+ \\r +kar )kr Case 2: type M a = EnvT r(ContT ans m) \na = r+(a+mans)+ mans Callccf = \\r + WCC(\\k -if (\\a + \\r + ka) r) = \\r+. \\k+(\\k +f(\\a+\\r +k a)r) (\\a+\\-+ka)k \n= \\r+\\k+f (\\a+\\r +\\-+ka)rk From the expansion of type M in case 1, we can see that both result and environment \nare passed to the continuation. When callcc invokes a continuation, it passes the current, rather than \nthe captured continuation. The mllcc function in case 2 works in the opposite way. B lifting CaUcc through \nErrorT instance (MonadT ErrorT m, ContMonad m) ~ ContMonad (ErrorT m) where .-callcc :: ((a+ m (Error \na))+ m (Errors)) + m (Error a) Cullccf = cdcc (\\k + f (\\a + k(Oka))) C Lifting InEnv through EnvT, StateT \nand ErrorT instance (MonadT (EnvT r ) m, EnvMonad r m) e EnvMorwd r (EnvT r m) where inEnv rm = \\r + \ninErzv r (m r ) rdEnv = lifi rdEnv instance (MonadT (StateTs) m, EnvMonad r m) ~ EnvMonad r (StafeTs \nm) where inEnv rm = \\s + inEnv r(m s) rdEnv = lift rdEnv A function of type m a + m a maps m (Error a) \nto m (Error a) , thus inEnv stays the same after being lifted through ErrorT.   \n\t\t\t", "proc_id": "199448", "abstract": "<p>We show how a set of <italic>building blocks</italic> can be used to construct programming language interpreters, and present implementations of such building blocks capable of supporting many commonly known features, including simple expressions, three different function call mechanisms (call-by-name, call-by-value and lazy evaluation), references and assignment, nondeterminism, first-class continuations, and program tracing.</p><p>The underlying mechanism of our system is <italic>monad transformers</italic>, a simple form of abstraction for introducing a wide range of computational behaviors, such as state, I/O, continuations, and exceptions.</p><p>Our work is significant in the following respects. First, we have succeeded in designing a fully modular interpreter based on monad transformers that incudes features missing from Steele's, Espinosa's, and Wadler's earlier efforts. Second, we have found new ways to lift monad operations through monad transformers, in particular difficult cases not achieved in Moggi's original work. Third, we have demonstrated that interactions between features are reflected in liftings and that semantics can be changed by reordering monad transformers. Finally, we have implemented our interpreter in Gofer, whose constructor classes provide just the added power over Haskell's type classes to allow precise and convenient expression of our ideas. This implementation includes a method for constructing extensible unions and a form of subtyping that is interesting in its own right.</p>", "authors": [{"name": "Sheng Liang", "author_profile_id": "81423595431", "affiliation": "Yale University, Department of Computer Science, New Haven, CT", "person_id": "PP39079667", "email_address": "", "orcid_id": ""}, {"name": "Paul Hudak", "author_profile_id": "81100539650", "affiliation": "Yale University, Department of Computer Science, New Haven, CT", "person_id": "PP40028396", "email_address": "", "orcid_id": ""}, {"name": "Mark Jones", "author_profile_id": "81100557950", "affiliation": "Department of Computer science, University of Nottingham, University Park, Nottingham NG7 2RD, England and Yale University, Department of Computer Science, New Haven, CT", "person_id": "PP31083196", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199528", "year": "1995", "article_id": "199528", "conference": "POPL", "title": "Monad transformers and modular interpreters", "url": "http://dl.acm.org/citation.cfm?id=199528"}