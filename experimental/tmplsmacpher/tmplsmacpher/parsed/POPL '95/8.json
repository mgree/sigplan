{"article_publication_date": "01-25-1995", "fulltext": "\n Verifying Infinite State Processes with Sequential and Parallel Composition Ahmed Bouajjani Rachid Echahed \nPeter Habermehl VERIMAG* IMAG-LGI VERIMAG* Miniparc-Zirst, Rue Lavoisier CNRS Miniparc-Zirst, Rue Lavoisier \n38330 Montbonnot St-Martin, F-38041 Grenoble 38330 Montbonnot St-Martin, France France France Ahmed. \nBouaj j ani@imag. f r echahed@imag. fr Peter. Habermehl@imag. f r Abstract We investigate the verification \nproblem of infinite-state processes w.r.t logic-based specifications that express properties which may \nbe nonregular. We consider the process algebra PA which integrates and strictly sub\u00adsumes the algebras \nBPA (basic process algebra) and BPP (basic parallel processes), by allowing both sequen\u00adtial and parallel \ncompositions as well as nondetermin\u00adistic choice and recursion. Many relevant properties of PA processes \nare nonregular, and thus can be expressed neither by classical temporal logics nor by finite-state U\u00adautomata. \nProperties of particular interest are those in\u00advolving constraints on numbers of occurrences of events. \nIn order to express such properties, which are nonreg\u00adular in general, we use the temporal logic PCTL \nwhich combines the branching-time temporal logic CTL with Presburger arithmetics. Then, we tackle the \nverifica\u00adtion problem of guarded PA processes w.r.t. PCTL for\u00admulas. We mainly prove that, while this \nproblem is undecidable for the full PCTL, it is actually decidable for the class of guarded PA processes \n(and thus for the classes of guarded BPA s and guarded BPP s), and a large fragment of PCTL called PCTL+. \n1 Introduction Automatic verification of processes has been extensively studied in the last decade, and \nimportant progress has been made in the case of finite-state processes. For such processes, various verification \nmethods have been devel\u00adoped and successfully applied, as behavioral equiva\u00ad *VERIMAG is a joint laboratory \nof CNRS, INPG, UJF, and VERILOG S.A. Permission to copy without fee all or part of this material is granted \nprovided that the copies are not made or distributed for direct commercial advantaqe, the ACM copyright \nnotice and the title of the publication and Its date appear, and notice is given that copying is by permission \nof the Association of Computing Machinery. To copy otherwise, or to republish, requires a fee ancf/or \nspecific permission. POPL 95 II 95 San Francisco CA USA 0 1995 ACM 0-89791 -692-1/95/0001 ....$3.50 \nlence or preorder testing [Mi180, Par81, KS83, Mi189], and model-checking w.r.t. logic-based specifications \n[QS8Z CES83, VW86, EL86]. Recently, intensive investigations have been conse\u00adcrated to the extension \nof these verification methods to the case of infinite-state processes [Hut91, AJ93, Chr93, EsP93, Jan93, \nCer94]. One of the most important di\u00adrections of these investigations concerns the processes expressible \nin the algebras BPA (basic process algebra) [BBK87] and BPP (basic parallel processes) [Chr93]. The terms \nin BPA are constructed using nondeterminis\u00adtic choice, recursion and sequential composition whereas in \nBPP, the sequential composition is replaced by the prefixing operation and asynchronous parallel composi\u00adtion \n(merge operation). While BPA processes generate context-free languages (sets of finite traces) [BBK87], \nit has been shown that BPP s generate a subclass of context-sensitive languages that is not comparable \nwith the class of context-free languages. Important results have been obtained concerning the comparison \nbetween either BPA processes or BPP s w.r.t. behavioral equivalences and preorders. Mainly, it has been \nshown that (strong) bisimulation is de\u00adcidable for processes in each of these two algebras [CHS92, CHM93a, \nChr93]. Concerning the verification w.r.t. logic-based speci\u00adfications, in general, the (few) existing \nresults consider as specification language the branching-time proposi\u00adtional p-calculus [Koz83], and \nfor this logic, the posi\u00adtive results concern only the BPA s. In fact, it can be deduced from [MS85] \nthat the verification problem for BPA s w.r.t. the p-calculus is decidable. Moreover, a model-checking \nalgorithm is proposed in [BS92] for the alternation-free fragment of the p-calculus. As for BPP processes, \nthe verification problem w.r.t. the ~-calculus has been shown undecidable [Bra92, EsP93]. We can observe \nthat all the existing works consider separately the algebras BPA and BPP, and all the ex\u00adisting decision \nprocedures mentioned above are spe\u00adcific to each class and cannot be applied to processes constructed \nusing both sequential and parallel compo\u00adsitions, namely processes described in the more general algebra \nPA [BK88]. Actually, PA is strictly more ex\u00adpressive than the union of BPA and BPP, i.e., there are PA \nprocesses that are neither BPA s nor BPP s. For instance, parallel (resp. sequential) compositions of \nBPA s (resp. BPP s) are PA s whereas BPA (resp. BPP) is not closed under parallel (resp. sequential) \ncomposition. Another observation is that, when con\u00adsidering parallel composition, the branching-time \np\u00adcalculus is in some sens too powerful to get a decision procedure for the verification problem. On \nthe other hand, since we are interested in infinite-state processes, the ~-calculus has a weakness: it \nallows to express only regular properties whereas a wide class of the relevant properties of infinite-st \nate processes are nonregular, i.e., they can be expressed neither in the usual logics of pro\u00adcesses nor \nby finite-state w-automata. For instance, in the specification of a communication protocol, we may require \nthat 1. between the beginning and the ending of every ses\u00adsion, there are exactly the same numbers of \nrequests and acknowledgements. 2, during every session, the number of acknowledge\u00adments never exceeds \nthe number of requests. Actually, as these examples show, significant proper\u00adties of infinite-state processes \nare essentially temporal properties involving constraints on numbers of occur\u00adrences of some events (or \nnumbers of states satisfying some state property). In [BER94], we have proposed a new temporal logic, \ncalled PCTL (Presburger CTL), allowing to express such properties. In PCTL, we dis\u00adpose of occurrence \nvariables that can be associated with state formulas and then used to express constraints on the number \nof occurrences of states satisfying these for\u00admulas. The constraints are expressed in the language of \nPresburger arithmetics. For inst ante, in the formula [x : m].p, we associate the state formula n with \nthe vari\u00adable Z. Then, x counts the number of occurrences of T along each computation sequence starting \nfrom the current state. Using this notation, the properties infor\u00admally described above can be expressed \nin PCTL by: 1. VU (BEGIN a [z, y : REQ, ACK]. WI (END a (z = y)))  2. VU (BEGIN * [z, y : REQ, ACK]. \n(2 a Y) VLA3ND)  Then, it can be seen that PCTL allows to characterize a large class of nonregular languages. \nThese languages can be context-free as in the examples above, but also non context-free (context-sensitive). \nSo, our aim in this paper is to provide an automatic verification method for PA processes w.r.t. nonregular \ntemporal properties, using P CTL formulas. In [BER94], we have shown that the verification prob\u00adlem is \nundecidable (actually non recursively enumer\u00adable) for the full PCTL, even if we consider only finite\u00adstate \nprocesses (regular processes), but by a slight syn\u00adtactic restriction, we get an important fragment called \nPCTL+ (containing for instance the two properties (1) and (2) above), such that the verification problem \nof context-free (B PA) processes is decidable. As far as we know, this was the first result about automatic \nverifi\u00adcation of nonregular processes w ,r.t. nonregular prop\u00aderties. In this paper, we give a stronger \nresult which establishes the decidability of the verification problem of PA processes with respect to \nformulas in PCTL+. Our proof is based on a reduction of this problem to the validity problem in Presburger \narithmetics. From this result, it follows immediate y that the verification problem of PCTL+ is decidable \nfor BPA s, which co\u00adincides with the result we have given in [BER94], and also for BPP s, which is a \nnew result for this class of processes. The remainder of the paper is organized as follows: In Section \n2, we recall some basic definitions and introduce some not ations. In Section 3 we define the syntax \nand the semantics of the PA processes. The logic PCTL and its fragment PCTL+ are introduced in Section \n4. In Section 5, we give the results we have concerning the decidability of the verification problem \nof PA s w.r.t. PCTL formulas. Concluding remarks are given in Sec\u00adtion 6. The appendix contains a sketch \nof the proof of our main decidabilit y result.  2 Preliminaries We recall in this section some well-known \nnotions and introduce some notations. 2.1 Presburger arithmetics Presburger arithmetics is the first \norder logic of integers with addition, subtraction and the usual ordering. Let us recall briefly the \ndefinition of this logic. Let V be a set of variables. We use Z, y, . . . to range over variables in \nV. Consider the set of terms defined by  t::= olllzlt tlt+t Integer constants (k 6 Z?) and multiplication \nby con\u00adstants (M) can be introduced as abbreviations. The set of Presburger formulas is defined by  \nf::=t<t l-lflfv.flaz..f Classical abbreviations can be used like boolean con\u00adnective as conjunction (A), \nimplication (a) and equiv\u00adalence (a) as well as universal quantification (V). The semantics of these \nformulas is defined in the standard way. Given a formula ~ with free variables xl, ..., G, and a valuation \nE : V + Z, we say that E satisfies j, and write E &#38; f, if the evaluation of ~ under E is true. We \nsay that a formula ~ is valid if every valuation sat\u00ad isfies ~. It is well known that the satisfiability \nproblem for Presburger formulas is decidable, and hence, so is for the validity problem (e.g., see [BJ74] \nfor a decision procedure). 2.2 Sequences Let Z be a finite alphabet. We denote by Z (resp. X? ) the set \nof finite (resp. infinite) sequences over E. Let ~~=x ux . Given a sequence a E Zm, Ia[ = {O, 1,... ,w} \ndenotes the length of a. Let e denotes the empty sequence, i.e., the sequence of length O. Let X+ = E \n {e}. For every a c E, Ia[. is the number of occurrences of a in a. We write a c o to denote the fact \nthat a appears in the sequence 0. For every i E W such that i < Iol, a(i) denotes the ith element of \na. Finally, given E ~ Z, we denote by Olxl the projection of a on the subalphabet z . 2.3 Kripke structures \nA Kripke structure over the alphabet Z (KS for short) is a tuple K = (E, S, II, 1?) where S is a countable \nset of states, II : S + Z is a labelling function and R ~ S x S is a transition relation. We write s \n~E s to denote the fact that (s, s ) c R. We write s ~R when there is no state s such that (s, s ) c \nR. An injinite computation sequence of K from a state s is a sequence S1S2 . . . such that s = S1 and \nVi >1. si ~E si+l. A finite computation sequence of K starting from s is a sequence S1 . . . Sn such \nthat s = S1, , Vi. 1 < i < n. s% *R s~+~, and s. fiR. We denote by C(K, s) the set of finite and infinite \ncomputation se\u00adquences of K starting from s. We say that K is jinite\u00adbranching if for each states c S, \nthe set {s : s ~R s } is finite. Finally, we consider the bisimulation equivalence rela\u00adtion between \nstates of Kripke structures [Par81, Mi189]. We say that two states S1 and S2 are bisimilar if there ex\u00adists \nsome symmetric binary relation w such that S1 -S2 iff II(sl) = II(sz) and ~s; , S1+R S; irnpb ~S;, S2+ \nR S; and S; w S:  3 Process Algebra We present in this section the class of processes for which we consider \nthe verification problem. These pro\u00adcesses are described in the process algebra PA [BK88]. We give the \nsyntax of PA processes and define their op\u00aderational semantics. Then, we introduce the notion of PA processes \nin normal form which is important for our decision technique, and we discuss briefly the expres\u00adsiveness \nof PA. First of all, let us give the syntax and the seman\u00ad tics of the PA processes. Informally, PA \nis the class of processes defined from a set of atomic processes by considering nondeterministic choice, \nsequential compo\u00adsition, parallel (merge) composition, and recursion. Our definition of the operational \nsemantics of PA processes is done in a slightly different style from that usually adopted. Indeed, we \nconsider that an atomic process is characterized by a set of atomic propositions instead of an atomic \naction label and we define an operational semantics of PA s by means of Kripke structures (state\u00adlabelled \ngraphs) instead of labelled transition systems (edge-labelled graphs). We choose this semantics since \nour aim is to consider PA s as models for the tempo\u00adral logic PCTL introduced in the next section which \nis interpreted on KS S. Let Prop be a finite set of atomic propositions and ~ = 2pr0p. We call the elements \nof 22 state labels. We consider a set of process variables Var. We use P, Q,. . . to denote atomic propositions, \nthe letters a, b,... to range over elements of E, and capital letters X, Y, Z,. ., to range over elements \nof Var. Consider the set of terms 7 defined by the following grammar: t::=OlalX\\t+tlt.tltlltlt[t Intuitively, \nO represents the idle process, a is an atomic process, the operator + stands for nondeter\u00administic choice, \nthe operator . is the sequential com\u00adposition, ]1 is the parallel composition (merge opera\u00adtor) and U \nis the left merge operator. In the sequel, we identify the terms O . t, t .0, 0 -tt, t + O, t[O, Ollt, \nand t l!O with t,for any term t.In a,ddition, we identify OUtwith O. Syntactically, a PA process is defined \nby a finite fam\u00adily of recursive equations A = {Xi ~ ti : 1< i< n} where all the X2 s are distinct variables \nand all the vari\u00adables occurring in the terms ti s are in the (finite) set VarA = {Xl,.. ., Xn}. The \nalgebras BPA [BBK87] and BPP [CHM93b, CHM93a, Chr93] are fragments of PA. The BPA s are defined by considering \nonly terms of the form: t::= Olal Xlt+tlt. t whereas the BPP s are obtained by considering terms of \nthe form: t::= OIXla. tlt-t-tltllt A term tc Tis guarded iff every variable occurrence in tis within \nthe scope of an atomic action a E Z. A process in PA A = {Xi Q t, : 1< i < n} isguarded iff every term \ntiis guarded. From now on, we consider only guarded processes. We define the operational semantics of \na process in PA by associating with each family A a Kripke structure KA representing its computation \ngraph. This transition system is given by KA = (~, SA, HA, RA) where SA=E XT, e RA ~ S~ is the smallest \nrelation such that 1. (a, a ) -+~~ (a , O), 2. X Q t E A and (a, t) +R&#38; (a , t ) implies (a, X) \n-+~~ (a , t ), 3. (a, tl) +RA (a , tj) implies  (a,tl+ t,)-+&#38; (a ,t~), 4. (a, tI) +~a (a , t;) \nimplies (a, t2 +tl) -+~~ (a , tj),  5. (a, tl) +-RA (a , tj) implies (a, tl . tz} +RL (ci, t~ t2)< \n 6. (u, tl) +~~ (a , t{) implies (4t1]lt2) ~RA (a ,t!l/~2),  7. (a, tl) -+~~ (a , tj) implies (a,tzlltl) \n-+RA (a , t2\\lt~).  8. (a, tl) +RA (a , tj) implies (a, tl U~2) -+RA (a , ~ill~2).  Clearly, for any \nvariable X ~ VU? Aand any a E Z, the set of reachable states from (a, X) is in general infinite. Furthermore, \nit is easy to see that every guarded process in PA generates a finite-branching kripke structure. Now, \nwe introduce a special syntactical form of PA processes which is a generalization of the well-known Greibach \nnormal form used in formal language theory for context-free languages (see [Har78]). For this, let us \nconsider the set T( Var) of terms that are either O or constructed using only process variables, and \nthe three operators . , U , and II , i.e., terms of the form: We use Greek letters a, /3, ~,.. . to range \nover elements of T(Var). Then, aPA process A = {X, ~ t, : 1< i < n} is in normal ~m-m, if every term \nt2is either O or of the form such that no variable X~ occurring in some r; is defined to be an idle process, \ni.e., xk ~ O ~ A. Notice that for a BPA (resp. BPP) process, the ~~ s are constructed by means of the \noperator . (resp. ]1 ) only. It has been shown that every guarded BPA (resp. BPP) can be transformed \ninto normal form preserv\u00ading bisimilarity (see [BBK87] and [Chr93] respectively). Moreover, we can prove \nthat every guarded PA process can be transformed into normal form preserving bisim\u00adilarity. Proposition \n3.1 Let A be a guarded PA process, and X E VarA. Then, there exists a PA process in normal form A , and \na variable X E VarAl such that, for every a G E, (a, X) is bisimdar to (a, X ). Notice that we consider \nhere bisimulation on Kripke structures instead of bisimulation on labelled transition systems [Mi180, \nPar81], but this is not fundamental and the result above remains true if we adopt a semantics based on \nlabelled transition systems. Finally, let us discuss the expressive power of the classes BPA, BPP and \nPA by considering the classes of languages they generate. First of all, it is clear that both BPA and \nBPP subsume the class of regular processes (RP for short), i.e., finite-state processes. Moreover, it \nis well-known that the BPA processes generate context\u00adfree languages [BBK87], and it has been shown that \nthe BPP s are not comparable with the BPA s [Chr93]. For instance, the language {anbn : n > O}, which \nis defin\u00adable by the BPA: X~a. X. b+a. b cannot be generated by any BPP, and on the other hand, the language \n{a E Z+ : lal~ = [al~ = Ial.}, which is obviously non context-free, can be generated by the BPP: X ~ \na(bllcl[X+bllc)+ b.(allcl/X+a/lc)+ c.(allbllX+allb) Then, PA is strictly more expressive than both BPA \nand BPP. Furthermore, PA is strictly more expressive than the union of BPA and BPP, i.e., PA processes \ncan generate languages that can be generated neither by BPA s nor by BPP s. To see this, consider the \nfollowing language, which can be defined in PA as a parallel com\u00adposition of two BPA s: {o ~ ~+ : ~1{.,b} \nE {anbm : n > O} and o[{C,~} ~ {cndn : n > O}}. Actually, it is easy to see (from the last example for \ninstance) that the class BPA is not closed under the II operator, and it has been also proved (see [Chr93]) \nthat BPP is not closed under the . operator. We can also prove that every PA process can be simulated \nby some linearly bounded automaton, hence the PA processes generate context-sensitive languages (CSL \nS). On the other hand, we can prove that the context-sensitive language {anbncn : n > O} cannot be definable \nby any PA process. Finally, we observe that BPP s can be defined in terms of Petri Nets (PN s) whereas \nthe class of context\u00adfree processes (BPA s) is not comparable with the class of Petri Nets (see [Chr93]), \nand hence, so is for the class of PA processes. Then, we obtain the following picture where edges represent \nstrict inclusions between the classes of lan\u00adguages defined by the considered classes of processes: CSL \nPA BPA wBPP PN /\\/ BPA BPP \\ ,p/  4 Presburger CTL The logic Presburger CTL (PCTL) is an extension \nof the branching-time temporal logic CTL [CES83] where constraints on numbers of occurrences of state \nproper\u00adties can be expressed using Presburger formulas. Recall that Pro is a finite set of atomic propositions \n.? and that Z = 2 p. Recall also that we use letters P, Q,... to range over elements of Prop, letters \nZ, y,.. . to range over variables in V and ~, g,... to range over Presburger formulas. First, consider \nthe set of state formulas given by: 7r::=P(1T17rv7r The set of formulas of PCTL is defined by: We consider \nas abbreviations the usual boolean con\u00adnective as conjunction (A), implication (%-) and equiv\u00adalence \n(~). In addition, we use the universal quan\u00adtification ~x.p = l~x.lp and the following standard abbreviations: \nVOP = trueVUp, 30v = true3Up, Vnp = T30YV and 3UP = +O>p. We write [Xl,..., xn : 7r1, ..., 7rn].q or \n[xi : 7ri]~=l .p for [xl : Tl]. ..$ .[xn : 7rn].q. The operators 34 and VU are the classical CTL until \noperators with existential and universal path quantifi\u00adcation. The Presburger formulas f are used to \nexpress constraints on the numbers of occurrences of states sat\u00adisfying some state formulas. So, we call \nthese formulas occurrence constraints. The operator ~ corresponds to the usual existential quantification \nover integers, We distinguish (even syntactically) between the PCTL op\u00ad erator ~ and the Presburger existential \nquantifier 3 that may be used locally in some occurrence constraint ~. In the formula [Z : n] .~, the \nvariable ~ is associated with the state formula n, and then, starting from the cur\u00adrent state, x represents \nthe number of occurrences of states satisfying m. The variable z can be used in the occurrence constraints \nappearing in p. For instance, the formula [Z : T] .30(P A x < 5) expresses the fact that from the current \nstate, says, there exists some reachable state s where P holds and such that the path relatings to s \ncontains less than 5 states satisfying n. From now on, we refer to the variables x as occurrence variables. \nThe construction [Z : n] in the formula above binds the variable z in the subformula 30(P A x < 5). So, \na variable z may_be bound by either the quantifier 3, or by the quantifier 3, or by the construction \n([x : n] . Then, every variable appearing in some formula is either bound or free. We denote by 7(P) \nthe set of variables occur\u00adring free in p. A formula p is closed if all the variables occurring in it \nare bound (i.e., F(p) = 0), otherwise v is open. We assume without loss of generality that each variable \noccurring in any PCT L formula is bound at most once. The formal semantics of PCTL is defined by a satis\u00adfaction \nrelation between the states of a KS over Z and the formulas. First, let us define a satisfaction relation \nfor state formulas. Let K be a KS over E. The satisfac\u00adtion relation ~ for state formulas is defined \nfor any state s and atomic proposition P by s &#38; P iff P E II(s), and extended straightforwardly to \nboolean combinations of atomic propositions. Now, let us consider the general case. Since the formulas \nmay be open, the satisfaction relation is defined w.r.t. a valuation E of the variables. Along a computation \nsequence, the valuation changes according to the satisfaction, at the visited states, of the state formulas \nassociated with the occurrence variables. We define a state formulas association as a function -I that \nassociates state formulas with variables in V. For any function F from V to some target set T (F stands \nfor either a valuation E or a state formulas asso\u00adciation -y), we denote by D(F) the set of variables \nx such that f (~) is defined. We denote also by l [~ + T] where r E T, the function F such that D(F ) \n= D(F) U {x} and which associates T with x and coincides with F on all the other variables. We denote \nby Z(F) the image ofF, i.e.,Z(F) ={bGT :%cV.F(a) =b}. Given a state formulas association ~ and a valuation \nE, we define, for every sequence u E Xm and every two ranks i, j E JV such that i, j < [al, the valuation \n Now, given a state formulas association -y and a val\u00aduation E, the satisfaction relation ~ for all P \nCTL for\u00admulas is inductively defined for any state s by: iff P C II(s) s I=(E,7)P iff E F ~ where s \n+(%) f E = E[x i-13(z) + ifs 1= ?(z) then 1 else O]zcn(y) s &#38;(E,7) ~ iffs k(~,v) 9 s t=(E,7) yl J \nV2 iffs +(E,7J vh ors +(E,7) 92 iff 3k ~ Z?. s ~(w,T) p where s l=(%) ~~.9 E =E[$ +-k] s K(E,7J [Z : \nT].9 iffs ~(~,,~1) q where E =E[z +-O]and y =~[x e n] s ~(~,~) W v Up2 iff VCTE C(K, S). % c m. I < i \n< Iol. o(i) l=(W(,),T) 92 and Vj c ~. 1< ~ < Z. ~(~) ~(E (j),T) w, where l,k 1] E (k) = E~r,7) s l=(~,v) \nvh3L7Jw2 ifi 30 e C(K, S). ~Z G N. 1 s is 101. a(i) b(EI(i),7) 92 and v j 6 N. 1< j < i. 0(.0 b(E/(j),T) \nW, where E (k) = q;,:;ll The CTL operators 30 (there is some successor state) and V() (all the successors) \ncan be defined in PCTL by: 30p = [Z : true] .30((z = 2) A p) and VOlp = -13@p. Then, clearly PCTL subsumes \nthe logic CTL. More\u00adover, it can express properties that cannot be expressed in the usual propositional \ntemporal logics [GPSS80, W0183, EH83], dynamic logics [FL79, Str82] and fix\u00adpoint calculi [Koz83, Var88]. \nIndeed, these logics can express only regular properties, i.e., properties that can be defined by finite-state \nautomata (on infinite trees or sequences) [VW86, Tho87, Niw88] whereas PCTL can express nonregular properties. \nFor example, we can express the fact that between the beginning and the ending of some communication \nprotocol session, there are exactly the same numbers of requests and acknowledgements. This is done by \nthe formula: vu (BEGIN + [Z, Y : REQ, ACK]. vu (END + (z = y))) (1) We can require in addition that \nduring every such session, the number of acknowledgements never exceeds the number of requests. This \nis done by: Vu (BEGIN + [3, y : REQ, ACK]. (z ~ y) VUEND) (2) The conjunction of the two formulas (1) \nand (2) ex\u00adpresses the fact that, in every computation sequence, the subsequence between any pair of \nconsecutive BE-GIN and END is in the language of well-balanced paren\u00adtheses (semi-Dyck set) with REQ \n(resp. ACK) as a left (resp. right ) parenthesis. Now, we can express the stronger property that every \nsubsequence between two consecutive BEGIN and END is actually in the language {REQ . -4cW : n 2 1}. This \nis done by the formula: Un. do (BEGIN + [z, y,z : REQ, ACK, END]. VU((ACK A(z=n)A(y=1))=+ Vu ((ENDA(2 \n=1))* (z= n) A (y = n)))) (3) Then, as the examples above show, we can charac\u00adterize in PCTL a large \nclass of nonregular languages. These languages can be context-free as in (l), (2) and (3), but also context-sensitive \nusing a conjunction of more than two occurrence constraints concerning dif\u00adferent sets of occurrence \nvariables. For instance, we can consider languages as {n? ~. . n; : nzl}or {7r~ny.7r~.7ry : n,m> l}. \nIn the formulas (1), (2) and (3), the constraints con\u00adcern the numbers of occurrences of some propositions \nin every fixed computation sequence, independently from the other sequences. Actually, we can express \nalso in PCTL properties involving global constraints on the whole set of computation sequences. For inst \nante, con\u00adsider the uniform inevitability property that says: there exists some rank n such that every \ncomputation se\u00adquence (of length greater than n) satisfies some propo\u00adsition P at rank n. This property \nhas been shown in [Eme87] to be non expressible by finite-state infinite\u00adtree automata. We can express \nthis property in PCTL by: %. [z : true]. VU((Z = n) + P) (4) Now, we introduce a fragment of PCTL that \nwe con\u00adsidered in the next section for decidability issue of the verification problem. This fragment \nis called PCTL+ and is obtained by the following definition: The difference between PCTL+ and PCTL is \nthat in the formulas of the form qlVU~Q (resp. P13UPZ), the subformula 92 (resp. P1 ) must be a state \nformula in PCTL+. Despite this syntactical restriction, PCTL+ formulas can still express significant \nnonregular prop\u00aderties. For inst ante, all the formulas (1), (2), (3) and (4) are PCTL+ formulas. Notice \nthat PCTL+ is not a positive fragment, i.e., PCTL+ formulas may involve negations. 100  Verification \nProblem 6 Conclusion In this section, we tackle the decidability of the verifica\u00adtion problem of PA s \nw.r.t. PCTL formulas. We show that the verification problem is undecidable for PCTL even for finite-state \nprocesses. Then, we show that this problem becomes decidable for PA s when we consider the fragment PCTL+. \nWe deduce from this result that the verification problem is decidable for guarded BPA s and BPP s w.r.t. \nPCTL+ formulas. Let us first consider the verification problem for the full PCTL. We have shown in [BER94] \nthat this prob\u00adlem is undecidable. In fact, we can reduce the halting problem of 2-counter machines to \nthe verification prob\u00adlem ,S~(~,~) p, where s is a state of a finite-state kripke structure, and p is \na PCTL formula of the forms fWT or nVU f. Theorem 5.1 Let A be a RP, s a state in ~A, and p a PCTL formula. \nThen, the problem s ~(E,7) p is undecidable. As a straightforward consequence of the result above, the \nverification problem of PCTL is also undecidable for BPA s, BPP s and PA s. Now, by considering the fragment \nPCTL+ where the formulas of the form @?Jx and NUp are forbidden, we have shown in [BER94] that the verification \nproblem becomes decidable for BPA processes (called context\u00adfree processes in [BER94]). Here, we generalize \nthis result to the class of guarded PA s. For that, we use in a first step Proposition 3.1 and the fact \nthat bisim\u00adilar states satisfy the same PCTL formulas in order to concentrate on PA s in normal form. \nThen, in a second step, we reduce the verification problem for PA pro\u00adcesses in normal form w.r.t. PCTL+ \nformulas to the validity problem in Presburger arithmetics, i.e., given a state s of some PA in normal \nform, a valuation E, a state formulas association ~, and a PCTL+ formula q, we construct a Presburber \nformula 0 which is valid if and only if s ~(E,7) p. This construction, which is somewhat complicated, \nis sketched in the appendix. Theorem 5.2 Let A be a guarded PA, s G SA, and p a PCTL+ formula. Then, \nthe problem s ~(E,T) p is decidable. As a consequence of Theorem 5.2 above and since the algebras BRA \nand BPP are fragments of PA, we obtain the following decidability results for the classes of guarded \nBPA s and guarded BPP s. We propose in this paper a decision procedure allowing automatic verification \nof infinite-state processes w.r.t. nonregular properties. We have considered the class of processes definable \nin the algebra PA [BK88] which provides both sequen\u00adtial and parallel (merge) composition, and thus, \nsub\u00adsumes the two algebras BPA and BPP. Processes in PA generate an important subclass of context-sensitive \nlan\u00adguages, including context-free ones. On the other hand, we have considered nonregular properties \nexpressible in the logic PCTL which is a com\u00adbination of the branching-time temporal logic CTL with Presburger \narithmetics. The arithmetical part of the logic allows to express constraints on numbers of occur\u00adrences \nof events (truth of state formulas). Formulas in PCTL can also define a wide class of context-sensitive \nlanguages. Hence, the decidability result we get (The\u00adorem 5.2) is quite surprising since it allows to \ncheck the inclusion between nonregular languages in nontriv\u00adial subclasses of the class of context-sensitive \nlanguages. Our decidability result concern the syntactical frag\u00adment PCTL+ which is obtained by forbidding \nsome kinds of PCTL formulas that make the verification prob\u00adlem undecidable even for regular processes. \nMore pre\u00adcisely, we impose for instance that in every formula of the form p13/p2, the subformula PI must \nbe a state formula. Indeed, if we allow the use of linear con\u00adstraints in the formula PI, we can silmulate \ntests to zero of counters (at each testing location, the numbers of incrementations and decrementations \nof the considered counter must be the same), and then, we can express the halting of any 2-counter machine. \nActually, the syn\u00adtactical restriction we impose in PCTL+ allows also to avoid some very simple regular \nproperties (CTL formu\u00adlas) that cause undecidability for BPP s, and which are of the form PI 3Upz where \npl contains 30 operators (see [EsP93]). Thus, the syntactical restriction adopted in the defi\u00adnition \nof the fragment PCTL+ constitutes a good com\u00adpromise in order to get a decidable verification problem \nfor PA processes w.r.t. nonregular properties. Acknowledgement We would like to thank Hans Huttel for \na helpful indi\u00adcation concerning Proposition 3.1. References [AJ93] P. Abdulla and B. Jonsson. Verifying \nPro- Corollary 5.1 Let A be either a guarded BPA or a grams with Unreliable Channels. In 8th guarded \nBPP, s E SA, and p a PCTL+ formula. Then, Symp. on Logic in Computer Science. IEEE, the problem s +(E,7) \np is decidable. 1993. [BBK87] [BER94] [BJ74] [BK88] [Bra92] [BS92] [Cer94] [CES83] [CHM93a] [CHM93b] \n[Chr93] [CHS92] J.C.M. Baeten, J.A. Bergstra, and J.W. Klop. Decidability of Bisimulation Equiva\u00adlence \nfor Processes Generating Context-Fkee Languages. Tech. Rep. CS-R8632, 1987. CWI. A. Bouajjani, R. Echahed, \nand R. Robbana. Verification of Nonregular Temporal Prop\u00aderties for Context-Free Processes. In CON-CUR \n94. LNCS 836, 1994.  G.S. Boolos and R.C. Jeffrey. Computabil\u00adity and Logic. Cambridge University Press, \n1974. J.A. Bergstra and J.W. Klop. Process Theory based on Bisimulation Semantics. In REX School/Workshop \non Linear Time, Branching Time and Partial Order in Log\u00adics and Models for Concurrency. Springer-Verlag, \n1988. LNCS 354. J.C. Bradfield. Verifying Temporal Proper\u00adties of Systems. Birkhauser, 1992. 0. Burkart \nand B. Steffen. Model Check\u00ading for Context-Free Processes. In CON-CUR 92. Springer-Verlag, 1992. LNCS \n630. K. Cerans. Deciding Properties of Inte\u00adgral Relational Automata. In lCALP 94. Springer-Verlag, 1994. \nLNCS 820. E.M. Clarke, E.A. Emerson, and E. Sistla. Automatic Verification of Finite State Con\u00adcurrent \nSystems using Temporal Logic Spec\u00adifications: A Practical Approach. In 10th ACM Symp. on Principles of \nProgramming Languages. ACM, 1983. Complete version published in ACM TOPLAS, 8(2):244-263, April 1986. \n S. Christensen, Y. Hirshfeld, and F. Moller. Bisimulation Equivalence is Decidable for Basic Parallel \nProcesses. In CONCUR 93, Springer-Verlag, 1993. LNCS 715. S. Christensen, Y. Hirshfeld, and F. Moller. \nDecomposability, Decidability and Axioma\u00adtisability for Bisimulation Equivalence on Basic Parallel Processes. \nIn LICS 93, IEEE, 1993. S. Christensen. Decidability and Decompo\u00adsition in Process Algebra. PhD thesis, \nUni\u00adverist y of Edinburgh, 1993. S. Christensen, H. Hiittel, and C. Stirling. Bisimulation Equivalence \nis Decidable for all Context-Free Processes. In CONCUR 9.2. Springer-Verlag, 1992. LNCS 630.  102 [EH83] \n[EL86] [Eme87] [Esp93] [FL79] [GPSS80] [Har78] [Hut91] [Jan93] [Koz83] [KS83] [Mi180] [Mi189] E.A. Emerson \nand J.Y. Halpern, Some\u00adtimes and Not Never Revisited : On Branching versus Linear Time Logic . In 10th. \nSymp. on Principles of Programming Languages. ACM, 1983. E.A. Emerson and C.L. Lei. Efficient Model-Checking \nin Fragments of the Propositional p-Calculus. In First Symp. on Logic in Com\u00adputer Science, 1986. E.A. \nEmerson. Uniform Inevitability is Tree Automaton Ineffable. Information Process\u00ading Letters, 24, 1987. \n Javier Esparza. On the Decidability of Model-Checking for Several Mu-calculi and Petri Nets. Report \nECS-LFCS-93-274, Dep. of Comp. Sci., University of Edinburgh, 1993. M.J. Fischer and R.E. Ladner. Propositional \nDynamic Logic of Regular Programs. J. Comp. Syst. Sci., 18, 1979. D. Gabbay, A. Pnueli, S. Shelah, and \n J. Stavi. On the Temporal Analysis of Fair\u00adness. In 7th Symp. on Principles of Pro\u00adgramming Languages. \nACM, 1980.  M.A. Harrison. Introduction to Formal Lan\u00adguage Theory. Addison-Wesley Pub. Comp., 1978. \n H. Huttel. Decidability, Behavioral Equiva\u00adlences and Infinite Transition Graphs. PhD thesis, Univeristy \nof Edinburgh, 1991.  Petr Jancar. Decidability Questions for Bisimilarity of Petri Nets and Some Re\u00adlated \nProblems. Report ECS-LFCS-93-261, Dep. of Comp. Sci., University of Edinburgh, 1993. D. Kozen. ,Results \non the Propositional p-Calculus. Theoretical Computer Science, 27:333-354, 1983. P. Kanellakis and S.A. \nSmolka. CCS Ex\u00adpressions, Finite State Processes, and Three Problems of Equivalence. In 2nd Symp. on \nPrinciples of Distributed Computing. ACM, 1983. R. Milner. A Calculus of Communication Systems. Springer-Verlag, \n1980. LNCS 92. R. Milner. Communication and Concur\u00adrency. Prentice-Hall Int., 1989. [MS85] D.E. Mullerand \nP.E. Schupp. The Theory of Ends, Pushdown Automata, and Second-Order Logic. Theoretical Computer Science, \n37:51-75, 1985. [Niw88] D. Niwinski. Fixed Points vs. Infinite Gen\u00aderation. In %h Symp. on Logic in Computer \nScience, 1988. [Par81] D. Park. Concurrency and Automata on Infinite Sequences. In 5th GI-Conference \non Theoretical Computer Science. Springer-Verlag, 1981. LNCS 104. [QS82] J-P. Queille and J. Sifakis. \nSpecification and Verification of Concurrent Systems in CESAR. In International Symposium on Programmingj \nLNCS 137. Springer Verlag, 1982. [Str82] R.S. Streett. Propositional Dynamic Logic of Looping and Converse \nis Elementary De\u00adcidable. Information and Control, 54, 1982. Tho87] W. Thomas. On Chain Logic, Path Logic, \nand First-Order Logic over Infinite Trees. In %d Symp. on Logic in Computer Science, 1987. Var88] M.Y. \nVardi. A Temporal Fixpoint Calcu\u00adlus. In 15th Symposium on Principles of Programming Languages. ACM, \n1988. [VW86] M.Y. Vardi and P. Wolper. An Automata-Theoretic Approach to Automatic Program Verification. \nIn Ist Symp. on Logic in Com\u00adputer Science. IEEE, 1986. [W0183] P. Wolper. Temporal Logic Can Be More \nExpressive. Information and Control, 56, 1983.  Appendix In this appendix, we give the broad outlines \nof the proof of Theorem 5.2. Notations Let A be a PA process in normal form. We define the following \nset of transition rules: p~ = {Xi 4 aj.Tj : Xi~a;.r;+...+arj+j+a~,+a~, .&#38;, EA} {X, +UO:X, =OCA} Given \na transition rule r = X > t 6 pL, we denote by lhs(r) and rhs(r), the left-hand-side and the right\u00adhand-side \nof r, i.e., X and trespectively. Now, we introduce the technical notions of executable variable and executable \nposition in aLterm. Given a term r C 7( VarA ), a position (sometimes called occurrence) p in ~ is a \nstring of naturals that encodes the path from the root of the term ~ to a subterm (subtree) of ~. We \ndefine the set of executable positions in ~ as follows: Ezecp(0) = 0, Ezecp(X) = {A}, where A is the \nempty string, Ezecp(~l . 7-2) = {1 .p:p G ExecP(~l)}, Ezecp(r~ UT2) = {1 .p:p c EzecP(~l)}, Execp(T~ \n[]Tz) = {1p :pg l?zec,(~~)} U {2p :pc EzecP(~~)}. We say that a variable X is executable in the term \nT iff there exists an executable position p in T such that the subterm of r at position p is X. We denote \nby ExecV (~) the set of executable variables in the term T. The notion of executable variables allows \nto define a transition relation between terms of T( VarL ), using transition rules in pA that can be \nseen as rewriting rules. However, the execution (rewriting) in some term r of a variable X which is in \nthe left of one or may be several left-nested U operators, causes the replacement of all these operators \nby II operators. Then, given a term ~ and a position p in this term, let us define the set of positions \nL(p) as the smallest set of positions such that p 6 L(p) and, for every position p , if there exists \nsome position p c ~(p) such that p = p . 1 and the operator at position p is 1, then p c Z(p). Now, let \nT be a term in 7( VarA), X a variable such that X ~ Ezecv (r), p is an executable position of X andarule \nr= X+a. aCpA, then wewrite T~rr where T is the term T where the va,riable X at position p has been replaced \nby the term a, and furthermore, if p = p .1 and the operator at p is 1, then every [ operator at each \nposition in .L(p ) has been replaced by a [1. We generalize straightforwardly this notation to sequences \nof transitions by writing r AR T , where o = al... anC~+ andR~pL, ifT%~1 T1...% ~nTn= r and {rl, ..., \nrn} S R. Clearly, we have (a, ~) +~~ (CJI, TI).. +RA (un,~n) iff ~ %,. 71.0. 3P. Tn. Canonical Form for \nPCTIL+ formulas We define a canonical form for PCTL+ formulas. This form is described by the following \ngrammar: (p ::= We show that this problem is reducible to the valid\u00ad (p ::= it y problem in Presburger \narithmetics, that is, we con\u00ad d .. .. struct a Presburger formula O which is valid if and only [x: T].(FA \n#) where ; ~ {m, mn} [ if (a, X) +(E,V) @. Before giving the details of this con\u00ad ~O(m~U(m A ~)) struction, \nlet us introduce it intuitively. Notice that in the case of a formula [x : n] .(2 A @), the state formula \nZ is either equal to the formula n which is associated with x, or equal to 1x. Moreover, in the case \nof a formula 30( T3Z4(T A @)), we must have the same state formula n in both sides of the 32A operator. \nWe can transform every PCTL+ formula to an equiv\u00adalent formula in canonical form using the standard laws \nfor the boolean connective and the following equiva\u00adlences that can be proved from PCTL semantics: = \n [z: 7T].ip = . 1([% : 7r].(p)  [3: f r].((p, v (0,) [z: T].(T A$o) =  [x: 7r].q =  lpwlr . We \ncan yet improve the canonical form by getting rid of formulas of the form 3Clm. This is possible because \nwe can reduce the satisfaction of a formula SOT to the satis\u00adfaction of other formulas in canonical form \nwithout 3C17r subformulas. For this aim, we need to modify slightly the PA process A by enriching its \natomic propositions. We do not give here the details of this transformation. Reduction of the Verification \nProblem Let A be a PA process in normal form, s = (a, X) a state in SA, and p a PCTL+ formula. Then, \nsup\u00adpose that we are interested in the verification problem s *[ E,T) P for some valuation E and some \nstate fOrmU\u00adlas association ~. We suppose without loss of generality that p is in canonical form and \nthat A is so that p does not involve 30 formulas. Then, let P = Vr=l A~:l (n; A o;). Clearly, solving \nthe problem (a, X) ~(E,v) p reduces to solve the sat\u00adisfaction problem for each subformula &#38;. So, \nlet us consider the problem (a, X) +(E,7) @where @is one of the subformulas q$~of p, Sumose first that \nO contains only one 3U operator, e.g., ~= 30(7r3U(7r A f)). Then, (a; X) +( E,T)-@ holds if there exists \nsome transition sequence such that Vi. l<i<n. ai~ r,and[a. al... an]: ~ ~, where, for every a c X+, [o]? \n: V + lV is the valuation defined for every x c ~(~) nn(~), by [a];(x) = E(x)+ I{2E{1,... >1~1} ~(0 \n+7(X)}I. We show that the existence of a sequence like (5) can be formulated as an integer linear programming \nprob\u00adlem. This is based mainly on the fact that we care about the satisfaction of the formula ~ only \nat the end of the sequence (5), and this depends only on how often each transition rule has been applied \nand not in which or\u00addering these rules have been applied. The fact that n must be continuously satisfied \nimposes simply that only some of the rules can be used, namely those generating states that satisfy n, \ni.e., of the form Y -+ b . I-where b satisfies 7r. Hence, we define a Presburger formula 0 of the form \n3w. @(W) which is valid if and only if (a, X) F(E,7] O holds. Each variable in W represents the number \nof applications of some associated transition rule. Now, let us consider the case where # contains sev\u00aderal \nnested 32../operators, and take as an example $ = qO(n13U(nl A .fI A 30(7rz3U(m2 A ~2)))). In this case, \n(a, X) ~(E,7) # holds if there exists some sequence such that Vi. 1< i ~ Icrll. al(i) ~ ml, Vi. 1< i \n< 1021.a2(z) ~ m,, [a. al]~ 1-fl, and [a. al .a2]~ 1-fz. Roughly speaking, the formula O is constructed \nby nesting the formulas expressing the satisfaction of the nested 324 subformulas of @, that is, the \nformula O is of the form 3V1. (@l (Wl) A XV... Q2(WI, W2)) where the variables in WI and W2 are associated \nwith the tran\u00adsition rules generating the sequences al and U2 respec\u00adtively. The formulas we have considered \nup to now do not contain negations. So, let us consider first a formula @ = -+ with @ = 30(n3U(n A f)). \nIn this case, the Presburger formula Q is simply 13 W. Q(W) where 3W. @(W) is valid iff s ~(~,v) ~. Now, \nif we take for example @ = ao(7r13u(7r~ Afl AT~O(? rZ%/(m2 Af2)))), then the formula O is of the form \n3W1. (IZII (Wl ) A +!W2. %(W1,W2)). Thus, negations introduce alter\u00adnations of existential and universal \nquantifiers in the Presburger formula Q we construct. Finally, let us consider the more general case \nwith conjunctions and negations of W formulas. For in\u00adstance, consider the formula q$l = 30(n13U(n1 A \njl A 42 A @\\)) where 42 = T30(TzJZ4(nz A ~2)) and d; = ~O(T~3U(Tj A .fl)). Then, the Presburger for\u00admula \n!2 we construct is of the form 3W1. (@l (Wl ) A 13472. @2(Wl, W2) A2Wj. @j(WI, W.j)). Now, let us give \nthe formal definition of the formula 0. Let height be the function that associates with each for\u00admula \nlike @its height measured as the number of nested 32Aoperators. Let h = height(~) and H = {1,..., h+l}. \nThen, as we have seen above, we have to reason about several prefixes of computation sequences, each \nof them being associated with the satisfaction of some formula among the nested SW subformulas of ~. \nSo, we have to consider some sequence X -%P~ 71-%P~ T2 ... %PA rh (7) and be able to put constraints \non the numbers of ap\u00adplications of the transition rules generating each of the a~ s. For this, starting \nfrom the set of rules PA, we define a stratified set of transition rules pi. Every se\u00adquence n generated \nin pA, of length greater than h, can be decomposed in h + 1 pieces al,..., CTk+l, the pieces 01,. ... \nah being finite and nonempty, such that each Oi is generated using rules in the t th level of pi. More\u00adover, \nevery sequence a can be generated by merging several subsequences generated by different processes (variables) \ncomposed in parallel (either by u or by l]), each of these subsequences is going through some of the \nh+ 1 levels and is contributing to the generation of some of the pieces a~ s. Then, the variables used \nin the set of rules pi are of the form [Y, 1] where Y is a variable in VU? A and I is a nonempt y subset \nof H. We denote by X the set of all these variables. Intuitively, each variable [Y, {ii, . . . , i~ }] \nrepresents the set of sequences that are generated from the variable Y through levels {i,,... , i~._l \n} and reaching level ik. Initially, since we are interested in sequences such as (7), we take as start\u00ading \nvariable [X, H]. In the sequel, we denote by Z this starting variable. Then, we define pi as the smallest \nset of rules such that: ifY+a.7cpAand~~ Hwithll]~l, then [Y,l]+a.a~p~foreachac~~,  ifY+a.r~pAandI~ \nHwithlIl~2, then [Y, 1] + a .a c pi for each a c r~-i~ n[~)l Gpi,  ifY-+-a~pAand~~H withl<lll<2, then \n[Y,l] +ae pi,  where, for every term r G 7( Var.&#38;), and every set I G H, rI is a finite set of terms \ninductively defined as follows:   Forevery kcH, let ~k = {[Y, 1] EA? : rein(l) = k}, and let R~ = {r \nG p~ : lhs(r) E Xk }. Intuitively, the rules in R~ are those applied at the /cth level, gener\u00adating the \nsequence (Sh. In the sequel we denote by R~k the set of rules U&#38;=l Ri, and we denote simply by R \nthe Set It the tion i?<h . c&#38; be shown that system pA such as sequence in R : for (7), every transition \nit corresponds sequsome ence transi\u00ad in z _%&#38; ci~ % &#38; ~z o . =~, ~h (8) where Vi c {1, ..., \nh}, ai E T(@j+l Xk). Now let us define the sets of variables as well as the constraints involved in fl. \nFor every k 6 {1, . . . . h}, and every b c E, we define a variable u; that stands for the number of \noccurrences of b in the subsequence ok. For every n we define a variable V: standing for the number of \nstate labels (elements of E) in ok which satisfy m. We consider also for every r ~ R a variable w. standing \nfor the number of applications of r. L,et uk be the set of the u~ s, vk the set of the V$ S and W k the \nset of the WV s such that r c Rk. We denote b<yW5k the set of the WT S such that r E R<k. For every k \nE {l,. . .,h} and every b E Z, we denote by ~$k) (Uk, W k) the following Presburger formula that defines \nthe variable u!: (O< u$) A U$ = ~ w, for every r E Rk such that bc rhs(r) and for every n, we denote \nby V$ k) (Uk, Vk ) the follow\u00ading formula that defines the variable v:: (O< v;) A v:=~u! foreverybc Esuch \nthat b&#38; n. Now, we have to define the constraints on the vari\u00adables in W k. These constraints must \nbe satisfiable by some valuation E if and only if this valuation corre\u00adsponds to some transition sequence \n(8). First of all, the constraints on wk must express the fact that any occur\u00adrence of a variable A c \nxk appearing along a sequence (8) must be executed so that ~k contains no variable in xk. Thus, in any \nsequence (8), and for any variable A in xk, the number of the executions of A, i.e., ap\u00adplications of \nsome rules r E Rk such that lhs(r) = A, must equal the number of its introductions, i.e., the number \nof occurrences of A in the right-hand sides of the rules applied during the generation of the sequences \n01>. . ., ak, plus one if A = Z. This fact is expressed by the Presburger formula r~~,Z) (W<~ ) which \nis defined by Some solutions of ~~cx~ r&#38;Z) (WS~ ) (i.e., valua\u00ad tions E such that E 1-~ ~=%k I ~~,z) \n(W<k)), may as\u00adsign to some variable w: a value which is non null while the rule r is not necessarily \ninvolved in some sequence (8). Indeed, consider some valuation E that satisfies ~A6Xk ~R,2T) (W <k) and \nsuppose that it corresponds to some sequence (8). Consider also some variables B in Xk which does not \nappear in the considered sequence. Now, assume that there is some rule r = B + b . B in &#38;. We can \ndefine another valuation E which assigns to WV any strictly positive integer and coincides with E on \nthe other variables. Clearly, the new valuation 1? is also a solution of AAex~ I &#38;Z) (W<~ ). This \nsolution must be discarded since the number of the b s calculated from E using the formula ~~ k) (Uk, \n~~ ) does not cor\u00adrespond necessarily to a value that can be obtained from some possible computation \nof the PA process A. Thus, we must express in addition, the fact that for any variable A E xk, there \nexists some rule r whose left-hand side is A, such that w. >0 if and only if A appears in the sequence \n(8). This is done by the formula &#38;,z) (WS~) In order tO eXPreSS this formula, we need some additional \nnotations and definitions. We say that a sequence of rules 6 E R* is elementary if all its rules apply \nto different variables in X, i.e. Vr ~ R, 161, < 1. Given a term a ~ T(X) and a set of rules R ~ R, we \ndefine 11~~,,a) to be the set of elementary sequences 6 over R such that % E T(X) such that A c Execv \n(a ) anda -%Tl al . . . ~.~ a with~=rl. rz. . . Tn. Notice that the set II~R, ,a) is finite. The formula \n~A -(~,z) (WS$) is defined bY Finally, let ~h = 30(nX4n A @ ) be the subfor\u00admula of @ corresponding \nto the kth (nested) %i oper\u00adator. We must express the fact that the subsequence Ok SatiSfieS continuously \nr, that is to say, for every z c {l, ..., l~k /}, ~~(i) ~ n. we use a new formula CON D~ h) (Wk ) to \nexpress this constraint. Before giv\u00ading this formula, let us int reduce some not at ion. Given a transition \nrule r E R and a state formula n-, we write r~niffr isoftheform A~ b.aandb~n. Then, the formula CON D$ \nk) (W k ) is defined by Now, let E be the valuation Then, we define the formula Q as [@]\\E 7) where \nfor every k~{l, ..., h+ 1},and for every valuation F, and every state formula association q, Notice that \nin the definition above of the function [.]~n), we consider that F is a first order substitution that \nassociates with each variable an expression (actu\u00adally a sum of constants and variables) and not neces\u00adsarily \nan integer value. For instance, in the last case, F = F[x +-V;(z) + F(x)] zc7(@)nD(q) associates with \neach variable in Y(@) IID(q) the expression v~(z) +F(x). In the case of [~]~~), for every variable x \nG F(j), the expression F(x) is substitut ed to each occu rrence of x in f. The detailed proof of the \nequivalence between (a, X) S(E,Y) @ and the validity of the Presburger for\u00admula Q is quite long. It will \nappear in the full paper.  \n\t\t\t", "proc_id": "199448", "abstract": "<p>We investigate the verification problem of infinite-state process w.r.t. logic-based specifications that express properties which may be nonregular. We consider the process algebra PA which integrates and strictly subsumes the algebras BPA (basic process algebra) and BPP (basic parallel processes), by allowing both sequential and parallel compositions as well as nondeterministic choice and recursion. Many relevant properties of PA processes are nonregular, and thus can be expressed neither by classical temporal logics nor by finite state &#969;-automata. Properties of particular interest are those involving constraints on numbers of occurrences of events. In order to express such properties, which are nonregular in general, we use the temporal logic PCTL which combines the  branching-time temporal logic CTL with Presburger arithmetics. Then we tackle the verification problem of guarded PA processes w.r.t. PCTL formulas. We mainly prove that, while this problem is undecidable for the full PCTL, it is actually decidable for the class of guarded PA processes (and thus for the class of guarded BPA's and guarded BPP's), and a large fragment of PCTL called PCTL<supscrpt>+</supscrpt>.</p>", "authors": [{"name": "Ahmed Bouajjani", "author_profile_id": "81100358502", "affiliation": "VERIMAG, Miniparc-Zirst, Rue Lavoisier, 38330 Montbonnot St-Martin, France", "person_id": "PP14128276", "email_address": "", "orcid_id": ""}, {"name": "Rachid Echahed", "author_profile_id": "81100153155", "affiliation": "IMAG-LGI, CNRS, F-38041 Grenoble, France", "person_id": "PP14063346", "email_address": "", "orcid_id": ""}, {"name": "Peter Habermehl", "author_profile_id": "81100567357", "affiliation": "VERIMAG, Miniparc-Zirst, Rue Lavoisier, 38330 Montbonnot St-Martin, France", "person_id": "P224208", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199470", "year": "1995", "article_id": "199470", "conference": "POPL", "title": "Verifying infinite state processes with sequential and parallel composition", "url": "http://dl.acm.org/citation.cfm?id=199470"}