{"article_publication_date": "01-25-1995", "fulltext": "\n A Language with Distributed Scope Luca Cardelli Digital Equipment Corporation, Systems Research Center \n130 Lytton Ave, Palo Alto, CA 94301, USA luca@src.dec.com Abstract Obliq is a lexically-scoped, untyped, \ninterpreted lan\u00adguage that supports distributed object-oriented computa\u00adtion. Obliq objects have state \nand are local to a site. Obliq computations can roam over the network, while main\u00adtaining network connections. \nDistributed lexical scoping is the key mechanism for managing distributed computa\u00adtions. 1. Introduction \nA simple guiding principle separates Obliq from other distributed procedural languages: adherence to \nlexical scoping in a distributed context. This principle has a number of interesting consequences: it \nsupports a natural and consistent semantics of distributed computation, and enables elegant techniques \nfor distributed programming. In lexically scoped languages, the binding location of every identifier \nis determined by simple analysis of the program text surrounding the identifier. Therefore, one can be \nsure of the meaning of program identifiers, and can much more easily reason about the behavior of pro\u00ad \ngrams. In a distributed language like Obliq, lexical scop\u00ad ing assumes a further role. It ensures that \ncomputations have a precise meaning even when they migrate over the network a meaning that is determined \nby the binding lo\u00ad cation and network site of identifiers, and not by execu\u00ad tion sites. Network-wide \nscoping becomes an issue in the pres\u00ad ence of higher-order distributed computation, for exam\u00ad ple when \na site acting as a compute server accepts proce\u00ad dures for execution. The question here is: what happens \nto the free identifiers of network-transmitted procedures? Permission to copy without fee all or part \nof this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyrigM notice and the title of the publication and its date appear, and notice is \ngiven that coping is by permission of the Association of Computing Machinery. To copy otherwise, or to \nrepublish, requires a fee andor specific permission. POPL 951/95 San Francisco CA USA %2 1995 ACM 0-89791 \n-892-1/95/0001 ....$3.50 Obliq takes the view that such identifiers are bound to their original locations, \nas prescribed by lexical scoping, even when these locations belong to different network sites. In the \nrest of this introduction we review the main no\u00adtions. In section 2 we describe Obliq s object model \nand distributed semantics. In section 3 we present a collection of distributed programming techniques, \nenabled by Obliq s unique features. The most illuminating example is the compute server, in section 3.1; \nthe most intriguing one is object migration, in section 3.5. The syntax is summa\u00adrized in the appendix. \n 1.1 Language Overview The principal way of structuring distributed computa\u00adtions in Obliq is through \nthe notion of objects. Network services normally accept a variety of messages; it is then natural to \nsee each service as a network object (or, more neutrally, as a network interface). Obliq supports objects \nin this spirit, relying for its implementation on Modula\u00ad3 s network objects [7]. The Obliq object primitives \nare designed to be simple and powerful, with a coherent relationship between their local and distributed \nsemantics. Obliq objects are collec\u00adtions of named fields, with four basic operations: selec\u00adtion/invocation, \nupdating/overriding, cloning, and aliasing. There are no class hierarchies, nor complex method-lookup \nstrategies. Every object is potentially and transparently a network object. An object may become ac\u00adcessible \nover the network either by the mediation of a name server, or simply by being used as the argument or \nresult of a remote method. In any framework where objects are distributed across sites, it is critical \nto decide what to do about mobility of state. To avoid problems with state duplication, objects in Obliq \nare local to a site and are never automatically moved over the network. In contrast, network references \nto objects can be transmitted from site to site without restric\u00adtions. Atomic object migration can be \ncoded from our primitives, specifically from cloning and aliasing. In addition to the distribution of \ndata, the distribution of computations must also be designed carefully. It is clearly desirable to be \nable to transmit computing agents for remote execution. However, one should not be satis\u00adfied with transmitting \njust the program text of such agents. Program text cannot carry with it live connections to its originating \nsite, nor to any data or service at any other site. Hence the process of transmitting program text over \nthe network implies a complete network disconnect from the current distributed computation. In addition, \nunpredictable dynamic scoping results from transmitting and then running program text containing free \nidentifiers. Obliq computations, in the form of procedures or methods, can be freely transmitted over \nthe network. Ac\u00adtual computations (closures, not source text) are transmit\u00adted; lexically scoped free \nidentifiers retain their bindings to the originating sites. Through these free identifiers, migrating \ncomputations can maintain connections to ob\u00adjects and locations residing at various sites. Discomected \nagents can be represented as procedures with no free identifiers; they do not rely on prolonged network \ncon\u00adnectivity. In order to concentrate on distributed computation is\u00adsues and to reduce complexity, Obliq \nis designed as an untyped language (lacking static typing). This decision leads to simpler and smaller \nlanguage processors that can be easily embedded in applications. Moreover, untyped programs are somewhat \neasier to distribute, avoiding problems of compatibility of types at multiple sites. The Obliq run-time, \nhowever, is stYorzgly typed: erro\u00adneous computations produce clean errors that are cor\u00adrectly propagated \nacross sites. The run-time data space is heterogeneous, meaning that there are different kinds of run-time \nvalues and no provisions to discriminate be\u00adtween them; heterogeneity discourages writing programs that \nwould be difficult to typecheck in typed languages. Because of heterogeneity and lexical scoping, Obliq \nis in principle suitable for static typing. More importantly, Obliq is compatible with the disciplined \napproach to pro\u00adgramming that is inspired by statically typed languages.  1.2 Distributed Semantics \nThe Obliq distributed semantics is based on the no\u00adtions of sites, locations, values, and threads. Sites \n(that is, address spaces) contain locations, and lo\u00adcations contain values. Each location belongs to \na unique site. Sites are not explicit in the syntax but are implicit in the creation of locations: when \na location is created dur\u00ading a computation, it is allocated at the current site. Threads are virtual \nsequential instruction processors. Multiple threads may be executed concurrently, both at the same site \nor at different sites. A given thread may stop executing at a site, and continue executing at another \nsite. That is, threads may jump from site to site while re\u00adtaining their conceptual identity. In the \nObliq syntax, constant ident~iens denote values, while variable identifiers denote locations. A location \ncon\u00adtaining a value may be updated by assignment to the variable denoting the location. Obliq values \ninclude basic values (such as strings and integers), objects, arrays, and closures (the results of evalu\u00adating \nmethods and procedures). A value may contain embedded locations. An array value has embedded locations \nfor its elements, which can be updated. An object value has embedded locations for its fields, which \ncan be updated. A closure value may have embedded locations because of free variables in its pro\u00adgram \ntext that refer to locations in the surrounding lexical scope. Values may be transmitted over the network. \nA value containing no embedded locations is copied on transmis\u00adsion. A value containing embedded locations \nis copied up to the point where those locations appear; local references to locations are replaced by \nnetwork references. Because of transmission, a value may thus contain network refer\u00ad ences to locations \nat different sites. This semantics of value transmission has particular implications for closure values. \nIn general terms, a closure is a pair consisting of a piece of source text and a pointer to an evaluation \nstack. Transmission of a closure, in this view, implies transmis\u00adsion of an entire evaluation stack. \nObliq, however, im\u00adplements each closure as a pair of a source text and a table of values for free identifiers; \nthis technique is well\u00adknown and applicable to lexically-scoped higher-order languages. In our context, \nthis implementation of closures has the effect of reducing network traffic by transmitting only the values \nfrom the evaluation stack that are needed by the closure. A closure that has been transmitted may thus \ncontain program text that, when executed, accesses remote locations (via its table of free identifiers) \nover the network. Every Obliq object consists of a collection of locations spaming a single site; hence \nthe object itself is bound to a unique site, and does not movel. This immobility of ob\u00adjects is not a \nstrong limitation, because objects can be cloned to different sites, and because procedures can be transmitted \nthat allocate objects at different sites. Hence, a collection of interacting objects can be dynamically \nallo\u00adcated throughout the network. If migration is necessary, cloning can be used to provide the needed \nstate duplica\u00adtion, and aliasing can be used to redirect operations to the clones. We have stressed so \nfar how Obliq computations can evolve into webs of network references. However, this is not necessarily \nthe case. For example, a procedure with no free identifiers forms a completely self-contained computing \nagent. The execution of such an agent may be 1 In the implementation, network references are generated \nto ob\u00adjects and arrays, not to each of their embedded locations. However, it is consistent and significantly \nsimpler to carry out our discus\u00adsions in terms of network references to locations. carried out autonomously \nby a remote compute server; the agent may dynamically reconnect to the originating site to report results. \nIntermediate situations are also possible, as with semi-autonomous agents that maintain low-traffic tethers \nto their originating site for status queries.  1.3 Discussion The distributed semantics of Obliq is \ndefined so that data and computations are network-transparent: their meaning does not depend on allocation \nsites or execution sites (of course, computations may receive different ar\u00adguments at different sites). \nAt the same time, Obliq pro\u00adgrams are network-aware: distribution is achieved by explicit acts that give \nfull control on communication pat\u00adterns. Central to network transparent y is the notion of distributed \nlexical scoping. The combination of lexical scoping with strong run\u00adtime typing and interpreted execution \ncan provide net\u00adwork security guarantees. Consider the situation of a server executing incoming foreign \nagents. Because of lexi\u00adcal scoping, these agents have access only to the data and resources that they \ncan reference via free identifiers or that they explicitly receive in the form of procedure pa\u00adrameters. \nHence, foreign agents cannot access data or re\u00adsources at the server site that are not explicitly given \nto them. As a concrete example, operations on files in Obliq require file system handles that are provided \nonly as global lexically-bound identifiers at each site. A foreign agent can use the file system handle \nof its originating site, simply by referring to it as a free identifier. But the file system handle at \nthe server site is outside its lexical scope, and hence unobtainable except with the coopera\u00adtion of \nthe server. Degrees of file protection can be repre\u00adsented by file system handles with special access \nrights. In summary, distributed lexical scoping makes it easy to spread computations over multiple network \nsites, since computations are likely to behave correctly even when they are carried out at the wrong \nplace (by some mea\u00adsure). This flexibility in distribution can, however, result in undesirable network \ntraffic. Obliq relieves some of the burden of distributing data and computations, but care and planning \nare still required to achieve satisfactory dis\u00adtributed performance.  z. Objects Obliq is an object-oriented \nlanguage based on objects, rather than classes. An object is a self-contained exemplar of behavior that \ncan be either constructed directly or cloned from other objects. The Obliq language is therefore prototype-based \n[10], but is not delegation-based [21]. Obliq belongs to a category of prototype-based languages that \nwe may call embedding-based. This name indicates that all the methods of an object, as well as its value \nfields, are embedded in the object itself (at least in principle) rather than being located in other \nobjects or classesz [30]. In spirit, this model is close to Borning s original prototype\u00ad based proposal \n[10], and to recent languages that are not delegation-based [9, 29]. The embedding-based model is straightforward, \nand is well suited to network applications because of the self\u00adcontained nature of the objects. The delegation-based \nmodel, in contrast, maximizes sharing across objects; this is not always desirable in a distributed context. \nFor ex\u00adample, when an Obliq object is cloned over the network it carries with it its embedded methods, \nthus it can work lo\u00adcally and autonomously when it reaches its destination. In a delegation-based model \nit would be more difficult to obtain the complete relocation of an object and its meth\u00adods. Typically, \nthis would require the coordinated migra\u00adtion of the object s parents [32], and would affect other ob\u00adjects \nthat share the same parents. 2.1 Fields An Obliq object is a collection of fields containing methods, \naliases, or other values. A field containing a method is called a method field. A field containing an \nalias is called an alias field. A field containing any other value, including a procedure value, is called \na (proper) ualuefield. Each field is identified by a field name. Syntactically, an object with n fields \nhas the form { xl => al, . . . ,x~=>a~} where n20, and xi are distinct field names. The terms a i are \nsiblings of each other, and the object is their host object. A value field is, for example: x=> 3 A method \nfield has the form x => meth(y, yl, . . . ,Ym) b end The first parameter, Y, denotes seZf the method \ns host ob\u00adject. The other parameters, for m20, are supplied during method invocation. The body of the \nmethod is b, which computes the result of an invocation of x. Methods and procedures are supported as \ndistinct concepts. Procedures start with the keyword proc in\u00adstead of meth and have otherwise the same \nsyntax. The main differences between the two are as follows. Methods can be manipulated as values but \ncan be activated only when contained in objects, since self needs to be bound to the host object. In \ncontrast, procedures can be activated by normal procedure call. Further, a procedure can be in\u00adserted \nin a value field and later recovered, while any at\u00adtempt to extract a method results in its activation. \nAn alias field has the form: 2 The terms concatenation-based and copy-based have also been used. Selection \n(and Invocation) =>alias yof bend Operations on the x field of this object are redirected to the Y field \nof the object b. If that field is another alias, the redirection continues recursively. (However, aliasing \nop\u00aderations are not themselves redirected; see section 2.3.) As we said, Obliq fields (including methods) \nare stored directly in objects, not indirectly in classes or shared prototypes. Therefore, field lookup \nis a one-step process that searches a field by name within a single ob\u00adject: there is no class or delegation \nhierarchy to be searched iteratively. Field lookup is based on a nearly constant-time caching technique \nthat does not penalize large objects. A separate cache is used for each operation instance; the cache \nrecords the position where a field was last found in an object [14]. 2.2 Simple Examples Let us examine \nsome simple examples, just to became familiar with the Obliq syntax and semantics. A full ex\u00adplanation \nof object operations is given in the next section. The following object has a single method that invokes \nitself through self (the s parameter). A let definition binds the object to the identifier o let o = \n{ x => math(s) s.x() end }; An invocation of o. x ( ) results in a divergent computa\u00adtion. Divergence \nis obtained here without any explicit use of recursion the self-application implicit in method invo\u00adcation \nis sufficient. The object below has three components: a value field x, a method inc that increments x \nthrough self and re\u00adturns self, and a method next that invokes inc through self and returns the x component \nof the result. let o= {X=>3, inc => meth(s, y) S.X := S. X+Y; s end, next => math(s) s.inc (l) .x end \n}; Here are some operations that can be performed on o O.x Selecting the x component. O.x := o Setting \nthe x component to zero. o.inc (l) Invoking a method, with parameters. o.nexto Invoking a method with \nno parameters. o. next := meth (s) clone(s) .inc (l) .x end Overriding the next method so that it no \nlonger modifies its host object.  2.3 Operations We now examine the object operations in some detail. \nApart from object creation, there are four basic operations on objects. This operation has two variants \nfor value selection and method invocation a,x a.x(bl, . . . ,b~) The first form selects a value from \na value field x of a and returns it. The second form invokes a method from a method field x of a, supplies \nn20 parameters, and returns the result produced by the method; the object a is bound to the self parameter \nof the method. For convenience, the first form can be used for invocation of methods with zero parameters. \n When a value field of a remote object is selected, its value is transmitted over the network to the \nsite of the selection (see the transmission semantics in section 1.2). When a method of a remote object \nis invoked, the argu\u00adments are transmitted over the network to the remote site, the result is computed \nremotely, and the final value (or error, or exception) is returned to the site of the invo\u00adcation. Updating \n(and Overriding) This operation deals with both value field update and method field override: a.x :=b \nHere the field x of a is updated with a new value b. If x contains a method and b is a method, we have \nmethod override. If x and b denote ordinary values, we have value update. The other two possibilities \nare also allowed: a value field can be turned into a method field, and vice versa. When a field of a \nremote object is updated, a value is transmitted over the network and installed into the re\u00admote object. \nRemote method override involves the trans\u00admission of a method closure. Cloning Our third operation is \nobject cloning, generalized to multiple objects: clone (al, . . . ,an) In the case of a single argument, \na new object is cre\u00adated with the same field names as the argument object; its fields are initialized \nto the similarly named values, meth\u00adods, and aliases of the argument object. In the case of n22 arguments, \na single object is pro\u00adduced that contains the values, methods, and aliases of all the argument objects \n(an error is given in case of field name conflicts). Useful idioms are clone (a, { . . . } ) , to inherit \nthe fields of a and add new fields, and clone ( a 1, a2 ), to rmdtiply inherit from al and az. When a \ncollection of remote or local objects is cloned, the clone is created at the local site. Its contents \n(including method closures) may have to be fetched over the net-rectly on its own self, we say that the \noperation is self-in\u00ad work. jlicted: Aliasing Our final operation is aliasing, which is the replace\u00adment \nof field contents with aliases (section 2.1). The syn\u00adtax is similar to updating, but this is really \na separate op\u00aderation: a.x := alias y of b end Further operations on x of a are redirected to Y of b; \nei\u00adther object may be local or remote. An aliasing operation replaces field contents with aliases regardless \nof whether those fields are already aliased. For a method invocation a. x ( c ), the field x=> alias \nY of b end behaves just like the field x = > meth (s, z ) b. y ( z ) end; that is, an aliased invocation \nbehaves like an indirect method invocation. However, aliasing redi\u00adrects also method override, as well \nas value selection and value update. 3 A special construct can be used to alias all the compo\u00ad nents \nof an object at once: redirect a ~ to as end The effect is to replace every field xi of al (including \nalias fields) with alias xi of a2 end; this is particularly use\u00adful for network redirection. Aliasing \nis implicit in the distributed-systems notion of local surrogate of a remote object: we have simply lifted \nthis mechanism to the language level. By doing this, we are able to put network redirection under flexible \npro\u00adgram control, as shown later in the case of object migra\u00adtion. For method invocation, aliasing redirection \nbehave differently from the redirection typical of delegation\u00adbased languages [21]: in aliasing, self \nis bound to the redi\u00adrection target; in delegation, self is bound to the redirec\u00adtion source. Aliasing \nis more satisfactory than delegation when the redirection target is a remote object: after an initial \naliasing redirection over the network, further ac\u00adcesses to self are local.  2.4 Self-inflicted Operations \nOur four basic object operations can be performed ei\u00adther as external operations on an object, or as \ninternal op\u00aderations through self. This distinction is useful in the contexts of object protection and \nserialization, discussed in the next two sections, which are essential features of distributed objects. \nIn preparation, we discuss the general notion of self-inflicted operations. When a method operates on \nan object other than the method s host object, we say that the operation is external to the object. By \ncontrast, when a method operates di\u00ad 3 Note that, for simplicity, we delayed the discussion of redirection \nin our previous explanation of selection and update. Ifop(o) hastheform o.x, o.x:=b, clone (..., o),..), \nor o. x: =al i as ...end. then op (o) is self-inflicted (on o) iff o is the same object as the self of \nthe current method. . op(o) is external (on o) iff it is not self-inflicted. Here, by the current method \n(if it exists) we mean the last method that was invoked in the current thread of control and that has \nnot yet returned. Therefore, the notion of self for self-inflicted operations is preserved through proce\u00addure \ncalls, but not through external method invocations or thread creation. Whether an operation is self-inflicted \ncan be deter\u00admined by a simple run-time test. Consider, for example the object { p => meth(s) s.q. x \nend, q => ... } Here the operation s . q is self-inflicted, since s is self. But the . x operation in \ns . q. x is self-inflicted depending on whether s . q returns self; in general this can be deter\u00admined \nonly at run-time. 2.5 Protected Objects It is useful to protect objects against certain external operations, \nto safeguard their internal invariants. Protec\u00adtion is particularly important, for example, to prevent \nclients from overriding methods of network services, or from cloning servers. Even protected objects, \nthough, should be allowed to modify their own state and to clone themselves. A protected object is an \nobject that rejects external up\u00addate, cloning, and aliasing operations, but that admits such operations \nwhen they are self-inflicted. The syntax is: { protected, xl => al, ... , x~ => an } Therefore, for example, \nmethods of a protected object can update sibling fields through self, but external operations cannot \nmodify such fields. Note that a protection mechanism based on individual fields would not address protection \nagainst cloning.  2.6 Serialized Objects An Obliq server object can be accessed concurrently by multiple \nremote client threads. Moreover, local concur\u00adrent threads may be created explicitly. To prevent race \nconditions, it must be possible to serialize access to ob\u00adjects and their state. We say that an object \nis serialized when (1) at most one thread at a time can operate on the objector run one of its methods. \nMoreover, we want to ensure that (2) a method can call a sibling through self without deadlock. Note \nthat requirement (2) does not contradict invariant (l). The obvious approach to implementing serialized \nob\u00adjects, adopted by many concurrent languages, is to asso\u00adciate a mutex with each object (for example, \nsee [3]). Such mutexes are acquired when a method of an object is in\u00advoked, and released when the method \nreturns, guarantee\u00ading condition (l). This way, however, we have a deadlock whenever a method calls a \nsibling, violating condition (2). We find this behavior unacceptable because it causes in\u00adnocent programs \nto deadlock without good reason. In particular, an object that works well sequentially may suddenly deadlock \nwhen a mutex is added. Brewer and Waldspurger [11] give an overview of previous solutions to this serialization \nproblem. A way to satisfy conditions (1) and (2) together is to use reentrant mutexes, that is, mutexes \nthat do not dead\u00adlock when re-locked by the same thread (for example, see [16]). On the one hand, reentrant \nmutexes may be too liberal, because they allow a method to call a method of a differ\u00adent object, which \nthen can call back a method of the pre\u00adsent object without deadlocking. This goes well beyond our simple \ndesire that a method should be able to call its siblings; object invariants may be compromised, since \nobjects become vulnerable to unexpected activations of their methods. On the other hand, reentrant mutexes \nmay be too re\u00adstrictive, because the notion of same thread is normally restricted to an address space. \nIf we want to consider control threads as extending across sites, then an imple\u00admentation of reentrant \nmutexes might not behave appro\u00adpriately. We solve the serialization problem by adopting an in\u00adtermediate \nlocking strategy, which we call se~serializa\u00adfion, based on the notion of self-inflicted operations de\u00adscribed \nin section 2.4. Serialized objects have an implicit associated mutex, called the object mutex. An object \nmutex serializes the ex\u00adecution of selection, update, cloning, and aliasing opera\u00adtions on its host object, \naccording to the following rules of acquisition . External operations always acquire the mutex of an \nobject, and release it on completion. . Self-inflicted operations never acquire the mutex of their object. \nNote that a self-inflicted operation can happen only after the activation of an external operation on \nthe object that is executed by the same thread. The external operation has therefore already acquired \nthe mutex. The serialization attribute of an object is specified as follows: { serialized, XI => al, \n. . . ,x~ => an } With self-serialization, a method can modify the state of its host object and can invoke \nsiblings without deadlock\u00ading. A deadlock still occurs if, for example, a method in\u00advokes a method of \na different object that then attempts an operation on the original serialized object. A deadlock oc\u00adcurs \nalso if a method forks an invocation of a sibling and waits on the result. In addition to mutual exclusion, \nObliq provides condi\u00adtional synchronization over implicit object mutexes. Condi\u00adtional synchronization \n(where threads wait on a mutex and a condition) allows multiple threads to be simultane\u00adously present \ninside an object, although at most one thread is active at any time. Producer-consumer behavior can be \nhandled this way [5]. A watch statement is provided to wait on a condition in conjunction with the implicit \nmutex of an object. This statement must be used inside a method of a serialized object; hence, it is \nalways evaluated with the object mutex locked: watch c until guard end The watch statement evaluates \nc to a condition and, if guard evaluates to true, terminates leaving the mutex locked. If the guard is \nf al se, the object mutex is un\u00adlocked (so that other methods of the object can execute) and the thread \nwaits for the condition to be signaled. When the condition is signaled, the object mutex is locked and \nthe boolean guard is evaluated again, repeating the process. The interaction of conditional synchronization \nwith certain object operations requires some attention. Objects with implicit mutexes can be cloned: \na fresh implicit mu\u00adtex is created for the clone. Consider then the case of a thread blocked on a condition \nwithin an object that is be\u00ading cloned: the thread remains blocked within the original object, not the \nclone. Consider now the case of a thread blocked on a condition within a method that is being overridden \nor aliased. When the thread resumes, the blocked method runs to completion with a non-trivially modified \nself. Object protection, when used in conjunc\u00adtion with serialization, alleviates these worries since \nit prevents external cloning and updates. In summary, mutual exclusion, amended for self-@\u00adflicted operations, \nhandles common situations conve\u00adniently, for example for network servers maintaining some internal state. \nIn addition, conditional synchroniza\u00adtion can be used for standard concurrency-control prob\u00adlems. More \ncomplex situations may require sophisticated uses of explicit mutexes; for this, Obliq supports the full \nspectrum of Modula-3 thread primitives [5, 19], Explicit mutexes, conditions, and threads cannot be transmitted, \nsince these values are strongly site-dependent. There is no automatic serialization for variables or \nar\u00adrays. If necessary, their access can be controlled through serialized objects or explicit mutexes. \nEven for objects, serialization is neither compulsory nor a default, since its use is not always desirable. \nIn some cases it maybe suffi\u00ad cient to serialize server objects (the concurrent entry can be exported \nfrom the same site under different points to a site) and leave all other objects unserialized. 2.7 Name \nServers and Execution Engines Obliq values can flow freely from site to site along communication channels. \nSuch channels are initially es\u00adtablished by interaction with a name server. A name server for Obliq programs \nis an external process uniquely identified by an 1P address; it simply maintains a table as\u00adsociating \ntext strings with network references [8]. The connection protocol between two Obliq sites is as follows. \nThe first site registers a local, or remote, object under a certain name with a known name server. The \nsecond site asks the name server for (the network refer\u00adence to) the object registered under that name. \nAt this point the second site acquires a direct network reference to the object living in the first site. \nThe name server is no longer involved in any way, except that it still holds the network reference. Obliq \nvalues and network references can now flow along the direct connection between the two sites, without \nhaving to be registered with a name server. This protocol is coded as follows, using a built-in net module: \nServeYSite: net_export ( obj , Namer, sitelob-j ) ; Client Site: let sitelobj = net_import ( obj \n , Namer) ; sitelObj . OPA (arcJs) ; (remote invocation) site30bj . opB(sitelObj ) ; (re-export to a \nthird site) where ob j is the registration name for the object, sit e 10b j k the object, and Namer \nis a string containing the IT address or name of the machine running the de\u00adsired name server. The object \nis now available through the name server, as long as the site that exports it is alive. Objects are garbage \ncollected at a site when they are no longer referenced, either locally or via the network [6]. We shall \nsee soon that compute servers are definable via simple network objects. However, compute servers are \nso common and useful that we provide them as primitives, calling them execution engines. An execution \nengine accepts Obliq procedures (that is, procedure clo\u00adsures) from the network and executes them at \nthe engine site. An engine can be exported from a site via the primi\u00adtive: Sewer Site: net_exportEngine \n( Engine l@ Sitel , Namer, arg) ; The arg parameter is supplied to all the client procedures received \nby the engine. It may contain local data as well as site-specific procedures (services [28]). Multiple \nengines names. An engine, once imported, behaves like a procedure of one argument. Implementing engines \nas remote proce\u00addures, instead of as remote objects, allows self-inflicted operations to extend across \nsites; this turns out to be im\u00adportant for object migration, as discussed in section 3.5. A client may \nimport an engine and then provide a pro\u00adcedure to be executed remotely. Client Site: let atSitel = net_importEngine \n( Engine l@ Sitel , Namer) ; atSitel (proc (arg) 3+2 end) ; Communication failures produce exceptions \nthat can be trapped. These failures may mean that one of the ma\u00adchines involved has crashed, or that \nan Obliq address space was terminated. There is no automatic recovery from network failures.  3. Distributed \nTechniques In this section we code some distributed programming techniques in Obliq. Each example is \ntypical of a separate class of distributed programs, and illustrates the unique features of Obliq. We \nomit standard examples dealing with threads and mutexes, which are directly expressible. 3.1 Compute \nServers The compute server defined below receives a client procedure p with zero arguments via the rexec \nmethod, and executes the procedure at the server site. This partic\u00adular server cheats on clients by storing \nthe latest client procedure into a global variable replay. Another field, lexec, is defined similarly \nto rexec, but rexec is a method field, while 1 exe c is a value field containing a procedure: the operational \ndifference is discussed below. Updatable variables are declared by var. Server Site: var replay = proc \n( ) end; net_export ( ComputeServer , Namer { rexec => meth (s, p) replay :=p; P() end, lexec => proc \n(p) replay :=p; p( end }); A client may import the compute server and send it a procedure to execute. \nThe procedure may have free vari\u00adables at the client site; in this example it increments a global variable \nx: Client Site: let computeServer = net_import ( Compute Server , Namer) ; var x=o; computeServer .rexec \n(proc ( ) x:=x+1 end) ; (now x =1) When the server executes its rexec method, replay is set to (a closure \nfor) proc ( ) x: =x+1 end at the server site, and then x is set to 1 at the client site, since the free \nx is lexically bound to the client site. Any variable called x at the server site, if it exists, is a \ndifferent variable and is not affected. At the server site we may now invoke replay ( ), setting x to \n2 at the client site. For contrast, consider the execution of the following line at the client site: \nClient Site: (computeServer. lexec) (proc ( ) x :=x+1 end) ; This results in the server returning the \nprocedure proc (p) replay: =p; p ( ) end to the client, by the se\u00admantics of remote field selection, \nwith replay bound at the server site. Then the client procedure Pro c ( ) x:= x+1 end is given as an \nargument. Hence, this time, the client procedure is executed at the client site. Still, the execution \nat the client site causes the client procedure to be transmitted to the server and bound to the rep 1 \nay variable there. The final effect is the same. 3.2 Remote Agents Execution engines (section 2.7) can \nbe used as general object servers; that is, as ways of allocating objects at re\u00admote sites. These objects \ncan then act as agents of the initi\u00adating site, supporting multiple requests. Suppose, for example, that \nwe have an engine ex\u00adported by a database server site. The engine provides the database as an argument \nto client procedures: DataBase Semer Site: net_exportEngine ( DBServer , Namer, dataBase) ; A database \nclient could simply send over procedures per\u00adforming queries on the database (which, for complex queries, \nwould be more efficient than repeatedly query\u00ading the server remotely [18, 28]). However, for added flexibility, \nthe client can instead create an object at the server site that acts as its remote agent DataBase Client \nSite: let atDBServer = net_importEngine ( DBServer , Namer) ; let searchAgent = atDBServer ( proc (dataBase) \n{ state=> . . . . start => meth . . . end, report => meth . . . end, stoP => ~th ... end } end );  The \nexecution of the client procedure causes the alloca\u00adtion of an object at the server site with methods \nstart, report, and stop, and with a state field. The server simply returns a network reference to this \nobject, and is no longer engaged. (Client resources at the server site are released when the client garbage \ncollects the search agent, or when the client site dies [6].) Here is a brief discussion of what the \nclient can now do. The client can start a remote search via s t art from a background thread, and periodically \nrequest a progress report via report. If the search is successful within a given time period, everything \nis fine. If the search takes too long, the remote agent can be aborted via s t op. If an intermediate \nreport proves promising, the client may de\u00adcide to wait for however long it takes for the agent to complete, \nby joining the background thread. This technique for remotely allocating objects can be extended to multiple \nagents searching multiple databases simultaneously, and to agents initiating their own sub\u00ad agents. \n 3.3 Application Partitioning The technique for remotely allocating objects described in section 3.2 \ncan be used for application partitioning. An application can be organized as a collection of procedures \nthat return objects. When the application starts, it can pick a site for each object and send the respective \nproce\u00addure to a remote engine for that site. This way, the appli\u00adcation components can be (initially) \ndistributed according to dynamic criteria. 3.4 Agent Migration In this example we consider the case \nof an untethered agent that moves from site to site carrying along some state [33]. We write the state \nas an object, and the agent as a procedure parameterized on the state and on a site\u00adspecific argument \nlet state={ . . . }; let agent = proc ( state, arg) . . . end; To be completely self-contained, this \nagent should have no free identifiers, and should use the state parameter for all its long-term memory \nneeds. The agent can be sent to a new site as follows, assum\u00ading at Si t el is an available remote engine: \natSitel ( proc (arg) agent ( copy ( state) , arg) end) The COPY operation is explained below, but the \nintent should be clear: the agent is executed at the new site, with a local copy of the state it had \nat the previous site. The agent s state is then accessed locally at the new site. Im\u00adplicitly, we assume \nthat the agent ceases any activity at the old site. The agent can repeat this procedure to move to yet \nanother site. The COPY operation is a primitive that produces local copies of (almost) arbitrary Obliq \nvalues, including values that span several sites. Sharing and circularities are pre\u00adserved, even those \nthat span the network. Not all values can be copied, however, because not all values can be transmitted. \nProtected objects cause exceptions on copy\u00ading, as do site-specific values such as threads. This techniques \nallows autonomous agents to travel between sites, perhaps eventually returning to their original site \nwith results. The original site may go off-line without directly affecting the agent. The main unpleasantness \nis that, because of copying, the state consistency between the old site and the new site must be preserved \nby programming convention (by not using the old state). In the next section we see how to mi\u00adgrate state \nconsistently, for individual objects.  3.5 Object Migration In this example we use a remote execution \nengine to migrate an object between two sites. First we define a procedure that, given an object, the \nname of an engine, and a name server, migrates the object to the engine s site. Migration is achieved \nin two phases: (1) by causing the engine to remotely clone the object, and (2) by aliasing the original \nobject to its remote clone (section 2.3). let migrateProc = proc ( obj , engineName ) let engine = net_import \nEngine ( engineName, Namer) ; let remoteObj = engine (proc (arg) clone ( obj ) end) ; (1) redirect ob \nj to remoteOb j end; (2) remoteObj ; end; After migration, operations on the original object are redirected \nto the remote site, and executed there. It is critical that the two phases of migration be exe\u00adcuted \natomically, to preserve the integrity of the object state. This can be achieved by serializing the migrating \nobject, and by invoking the m i grateproc procedure from a method of that object, where it is applied \nto self let obj1= { serialized, protected, . . . (other fields) migrate => meth (self, engineName ) migrateProc \n( self, engineName) ; end }; let remoteObj 1 = obj 1 migrate ( rEngine l@ Sitel ) Because of serialization, \nthe object state cannot change during a call to mi grat e. The call returns a network ref\u00aderence to the \nremote clone, which can be used in place of ob j 1 (which, anyway, has been aliased to the clone). We \nstill need to explain how migration can work for protected objects, since such objects are protected \nagainst external cloning and aliasing. Note the migrate pro (self, . . . ) call above, where self is \nbound to obj 1. It causes the execution of e n g i n e ( proc (arg) clone ( obj 1 ) end) . Rather subtly, \nthe cloning of oh-j 1 here is self-inflicted (section 2.4), even though it happens at a site different \nfrom the site of the object. According to the general definition, clone (ob j 1 ) is self-inflicted be\u00adcause \nobj 1 is the same as the self of the last active method of the current thread, which is migrate (an en\u00adgine \ncall behaves like a procedure call). The redirection operation is similarly self-inflicted. Therefore, \nthe pro\u00adtected status of oh-j 1 does not inhibit self-initiated migrat\u00adion. Migration permanently modifies \nthe original object, redirecting operations to the remote clone. In particular, if obj 1 is asked to \nmigrate again, the remote clone will properly migrate. We can avoid chains of indirection if the migrating \nobject obj 1 is publicly available through a name server. The migrate method can then register the migrated \nob\u00adject with the name server under the old name: let obj 1 = net_export ( obj 1 , Namer, { serialized, \nprotected, ... migrate => meth (self, engineName ) net_export ( obj 1 , Namer, migrateProc (self, engineName) \n) ; end }; This way, old clients of obj 1 go through aliasing indirec\u00adtion, but new clients acquiring \nob j 1 from the name server operate directly on the migrated object. 3.6 Application Servers Visual \nObliq [4] is an interactive distributed-applica\u00adtion and user-interface generator, based on Obliq. All \ndis\u00adtributed applications built in Visual Obliq follow the same model, which we may call the application \nserver model. In this model, a centralized server supplies inter\u00adested clients, dynamically, with both \nthe client code (as a closure) and the client user interface of a distributed ap\u00adplication. The closure \ntransmitted to each client retains lexical bindings to the server site, allowing it to commu\u00adnicate with \nthe server and with other clients. Each client may have independent local state, and may present an independent \nview of the application to the user. A typical example is a distributed tic-tac-toe game.  4. Conclusions \nObliq addresses a very dynamic form of distributed programming, where objects can redirect their behavior \nover the network, and where computations can roam be\u00adtween network sites. We feel that this kind of program\u00adming \nis still in its infancy, and that not all the fundamen\u00adtal issues can yet be addressed at once. Where \nin doubt, we have given precedence to flexible mechanism over ro\u00adbust methodology, hoping that methodology \nwill develop with experience. In this spirit, for example, Obliq could be used to experiment in the design \nand implementation of agent/place paradigms [33], using the basic techniques of section 3. Related Work \nObliq s features and application domains overlap with programming languages such as ML [23, 27], Modula-3 \n[25], and Self [32]; with scripting languages such as Sun\u00addew [18], Tcl [26], AppleScript [2], VBA [11, \n22], and Tele\u00adscript [33]; and with distributed languages such as Emer\u00adald [20], Orca [3], Fort6 [16], \nand Facile [31]. None of these languages, however, has the same mix of features as Obliq, particularly \nconcerning the distribution aspects. Stamos and Gifford [28] eloquently describe remote execution as \na generalization of remote procedure call, and survey previous work on remote execution mecha\u00adnisms. \nTheir proposal, though, restricts the transmission of higher-order procedures and procedures with free \nidentifiers, inhibiting the techniques of section 3. Our choice of features was largely determined by \nthe idea of a distributed lexically scoped language, by the de\u00adsire for a simple object model that would \nscale up to dis\u00adtributed computation, and by the availability of a sophis\u00adticated network-objects implementation \ntechnology. The Obliq object primitives were designed in parallel with work on the semantics and type \ntheory of objects [1]; dis\u00adtributed scoping and distributed semantics, however, are not treated there. \nInfluence of Modula-3 Network Objects The characteristics of Modula-3 Network Objects (M3NOS) had a major \ninfluence on the Obliq language design and implementation. Thanks to the low overhead involved, all Obliq \nobjects are M3NOS, so there is no arti\u00adficial separation between local objects, and objects that may \nbe remotely accessed. Similarly, all Obliq program variables (declared by var) are M3NOS: this is the \nbasis for distributed lexical scoping. Concerns about space reclamation, especially for resources used \nby remote agents, are relieved by distributed garbage collection of M3NOS. Finally, the M3NOS stub generator \nhandles au\u00adtomatically the transmission of all of Obliq s run-time structures. Moral: a distributed language \nlike Obliq is easy to im\u00adplement on top of a library like Modula-3 Network Ob\u00adjects. Conversely, a network \nobject library should make it easy to implement a language like Obliq, or is falling short of some important \ngoals. Status Obliq has been available at Digital SRC for about a year and a half. In addition to incidental \nprogramming, it has been used extensively as a scripting language for al\u00adgorithm animation [12] and 3D \ngraphics [24], and as the basis of the Visual Obliq distributed-application builder [4]. The Obliq implementation \nprovides access to many popular Modula-3 libraries [19], and to an extensive user interface toolkit [13] \nincluding digital video [17]. Obliq can be used as a stand-alone interactive interpeter. It can also \nbe embedded as a library in Modula-3 applications, allowing them to interact remotely through Obliq scripts \n[15]. The implementation and documentation are avail\u00adable on the World Wide Web at http: / / www. research. \ndigital. com/SRC/home. htrnl. Future Work Issues of authentication, security, authority delegation, and \naccounting are being explored. Acknowledgments The Network Objects project at Digital SRC provided the \ninfrastructure without which Obliq would not have been conceived. Alan Knaff implemented the metaparser \nlayer of the Ohliq parser. Appendix: Syntax Overview (See reference [15] for details.) TOP-LEVEL PHRASES \na; any term or definition ended by ; DEFINITIONS (denoted by d; identifiers are denoted by x, terms are \ndenoted by a) let let var xl=al, rea xl=al, . . . ,xn=an xl=al, . . . ,xn=an . . . ,q=an definition definition \ndefinition of constant of recursive of updatable identifiers procedures identifiers SEQUENCES (denoted \nbys) al; . . ..a~ executes each ai (term or defin,); yields a. (or ok if n=O) TERMS (denoted by a, b, \nc; identifiers are denoted by x, 1; libraries are denoted by m) x / m_x identifiers X:=a assignment ok \nI true I false I a I abc I 3 I 1.5 constants [al, . .. ran] arrays a[b] I a[b]:=c array selection, \narray update a[bl for bz] I a[bl for b~]:=c subarray selection, subarrayupdate opt ion 1 => s end term \nstaggedby 1 proc (xl, . . . ,x~) s end procedures a(bl, . . ..bn) procedure invocation m_x(al, . . .. \nan) invocationof xfromlibrary m abc infix (right-associative) version of b (a, c ) meth(x, xl, . . . \n,x~) s end method with self x {ll=>al, . . . ,l~=>a~} object with fields named ll...l~ {protected, serialized, \n. . .} protected and serialized object {ll=>alias 12 of az end, ...} object with aliased fields a.1 / \na.l (al, . . . . an) field selection/ method invocation a.l:=b field update / method override clone (al, \n. . .J an) object cloning al.ll:=ali.as 12 of a2 end field aliasing redirect al to as end object aliasing \nd definition if SI then s~ elsif s~ then Sal... else Sn end conditional(el sif,else optional) a andif \nb I a orif b conditionalconjunction/disjunction a is b I a isnot b identical/not identical predicates \ncase s of caseoverthe tag liofanoption value ll(X1)=>SI, ..., l.(xn)=>sn else SO end bindingxiinsi(el \nse optional) loop s end loop for i=a to b do s end iteration through successive integers foreach i in \na do s end iteration through an array foreach i, in a map s end yielding an array of the results exit \nexitthe innermost loop, for, foreach exception( excr ) new exception value named exc raise(a) raise anexception \ntry s except al=>sl, . . .,a.=>sn else so end exception capture (else optional) try SI finally s~ end \nfinalization condi~i-ono I signal(a) I broadcast (a) creating and signaling acondition watch SI until \nS2 end waiting for a signal and a boolean guard fork(al,az) I join(a) forkingandjoining athread pause(a) \npausingthecurrent thread mutex ( ) creating a mutex lock SI do Sz end locking a mutex in a scope wait(al,a2) \nwaiting on a mutex for a condition (s) block structure / precedence group References [17] Freeman, S.M.G. \nand M.S. Manasse, Adding digital [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12] [13] [14] [15] [16] \nAbadi, M. and L. Cardelli, A theory of primitive ob\u00adjects: untyped and first-order systems. Proc. Theoret\u00adical \nAspects of Computer Software. Springer-Verlag. 1994. Apple, AppleScript Language Guide. Addison Wesley. \n1993. Bal, H. E., M.F. Kaashoek, and A.S. Tanenbaum, Ore* a language for parallel programming of dis\u00adtributed \nsystems. IEEE Transactions on Software En\u00adgineering 18(3), 190-205.1992. Bharat, K. and M.H. Brown, \nBuilding distributed applications by direct manipulation. l%oc. LHST 94. 1994. Birrell, A. D., An introduction \nto programming with t breads. In Systems Programming with Modula-3, Chapter 4, G. Nelson, ed. Prentice \nHall. 1991. Birrell, A. D., D. Evers, G. Nelson, S. Owicki, and E. Wobber, Distributed garbage collection \nfor net\u00adwork objects. Report 116. Digital Equipment Corpo\u00adration, Systems Research Center. 1993. Birrell, \nA. D., G. Nelson, S. Owicki, and E. Wobber, Network objects. Proc. 14th Symposium on Operating Systems \nPrinciples. 1993. Birrell, A. D., G. Nelson, S. Owicki, and E. Wobber, Network objects. Report 115. \nDigital Equipment Corporation, Systems Research Center. 1994. Blaschek, G., Type-safe OOP with prototypes: \nthe concepts of Omega. Structured Programming 12(12), 1-9.1991. t30rning, A. H., Classes versus prototypes \nin object\u00adoriented languages. Proc, ACM/IEEE Fall Joint Com\u00adputer Conference. 1986. Brockschmidt, K., \nInside OLE2. Microsoft Press. 1994. Brown, M. H., Report on the 1993 SRC algorithm animation festival. \nReport n.126. Digital Equipment Corporation, Systems Research Center. To appear. 1994. Brown, M.H. \nand J.R. Meehan, The FormsVBT Ref\u00aderence Manual. Unpublished. Digital Equipment Corporation, Systems \nResearch Center. 1994. Cardelli, L., The Amber machine. Proc. Combirzators and Functional Programming \nLanguages. Lecture Notes in Computer Science 242. Springer-Verlag. 1986. Cardelli, L., Obliq: A language \nwith distributed scope. Report n.122. Digital Equipment Corporation, Systems Research Center. 1994. Fort6, \nTOOL reference manual. Fort6, Inc. 1994. video to an object-oriented user interface toolkit. Proc. ECOOP \n94. Springer-Verlag. 1994. [18] Gosling, J., Sundew: a distributed and extensible window system. Proc. \nWinter Usenix Technical Con\u00adference. Usenix Association. 1986. [19] Horning, J., B. Kalsow, P. McJones, \nand G. Nelson, Some useful Modula-3 interfaces. Report 113. Digi\u00adtal Equipment Corporation, Systems Research \nCen\u00adter. 1993. [20] Jul, E., H. Levy, N. Hutchinson, and A. Black, Fine\u00adgrained mobility in the Emerald \nsystem. ACM Transactions on Computer Systems 6(l), 109-133.1988. [21] Lieberman, H., Using prototypical \nobjects to im\u00adplement shared behavior in object oriented sys\u00adtems. Proc, 00PSZ,A 86. ACM Press. 1986. \n[22] Mansfield, R., Visual tana Press. 1994. [23] Milner, R., M. Tofte, of Standard ML. MIT [24] Najork, \nM. and M.H. Basic for Applications. Ven\u00ad and R. Harper, The definition Press. 1989. Brown, A library \nfor visualiz\u00ad ing combinatorial structures. Proc, IEEE Visualize \u00adtion 94. 1994. [25] Nelson, G., ed. \nSystems programming with Mod\u00adula-3. Prentice Hall. 1991. [26] Ousterhout, J.K., Tcl and the Tk toolkit. \nAddison-Wesley. 1994. [27] Reppy, A higher-order concurrent language. Proc. SIGPLAN91 Conference on Programming \nLanguage Design and Implementation. ACM Press. 1991. [28] Stamos, J.W. and D.K. Gifford, Remote Evaluation. \nACM Transactions on Programming Languages and Sys\u00adtems 12(4), 537-565.1990. [29] Taivalsaari, A., Kevo, \na prototype-based object-ori\u00adented language based on concatenation and mod\u00adule operations. Report LACIR \n92-02. University of Victoria. 1992. [30] Taivalsaari, A., A critical view of inheritance and reusability \nin object-oriented programming. Jyvaskyla Studies in computer science, economics and statistics No.23, \nA. Salminen ed. University of Jyvaskyla. 1993. [31] Thomsen, B., L. Leth, Kramer, F. Knabe, and Release \nProgramming pean Computer-Industry S. Prasad, T.-M. Kuo, A. A. Giacalone, Facile Antigua Guide. ECRC-93-20. \nEuro- Research Centre. 1993. [32] Ungar, D. and R.B. Smith, Selfi the power of sim\u00adplicity. Lisp and \nSymbolic Computation 4(3). 1991. [33] White, J.E., Telescript technology the foundation for the electronic \nmarketplace. White Paper. Gen\u00aderal Magic, Inc. 1994.  \n\t\t\t", "proc_id": "199448", "abstract": "<p>Obliq is a lexically-scoped, untyped, interpreted language that supports distributed object-oriented computation. Obliq objects have state and are local to a site. Obliq computations can roam over the network, while maintaining network connections. Distributed lexical scoping is the key mechanism for managing distributed computation.</p>", "authors": [{"name": "Luca Cardelli", "author_profile_id": "81100123805", "affiliation": "Digital Equipment Corporation, Systems Research Center, 130 Lytton Ave, Palo Alto, CA", "person_id": "PP39028545", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199516", "year": "1995", "article_id": "199516", "conference": "POPL", "title": "A language with distributed scope", "url": "http://dl.acm.org/citation.cfm?id=199516"}