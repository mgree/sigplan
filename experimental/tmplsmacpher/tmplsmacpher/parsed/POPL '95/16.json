{"article_publication_date": "01-25-1995", "fulltext": "\n Positive Subtyping Martin Hofmann* Benjamin Pierce+ Abstract The statement S < T in a A-calculus with \nsubtyping is traditionally interpreted by a semantic coercion func\u00adtion of type 1S] -+[TI that extracts \nthe T part of an element of S. If the subtyping relation is restricted to covariant positions, this interpretation \nmay be enriched to include both the implicit coercion and an overwrit\u00ading function put[S, T] E [S] -+[T] \n+ [S] that updates the T part of an element of S. JVe give a realizability model and a sound equational \ntheory for a second-order calculus of positive subtyping. Though weaker than familiar calculi of bounded \nquantification, positive subtyping retains sufficient power to model objects, encapsulation, and message \npassing. Moreover, inheritance may be implemented very straightforward] y in this setting, using the \ngrut functions arising from ordinary subtyping of records in place of the sophisticated systems of record \nextension and update often used for this purpose. The equational laws relating the behavior of coercions \nand put functions can be used to prove simple properties of the resulting classes in such a way that \nproofs for superclasses are inherited by subclasses. 1 Introduction The syntactic device of subtyping \nreifies a number of related semantic intuitions. If t ypes are regarded simply as predicates sets of \nvalues then the statement * Department of Computer Science, University of Edinburgh, The King s Buildings, \nEdinburgh, EH9 3JZ, U.K. Electronic mail: mxh@dcs. ed. ac. uk. t University of Cambridge, Computer Laboratory, \nNew Mu\u00adseums Sitej Pembroke Street, Cambridge, CB2 3QG, U.K. Elec\u00adtronic mail: bcp(ldcs. ed. ac. uk. \n Permiaslon to copy withcmf fee all or part of this material is granted provided that the copies are \nnot made or distributed for direct commercial advanta~e, the ACM copyright notice and the title of the \npublication and Its date appear, and notice is given that oopying is by permission of the Association \nof Computing Machinery. To copy otherwise, or to republish, requires a fee ancf/or specific permission. \nPOPL 951/95 San Francko CA USA @ 1995 ACM 0-89791 -692-1/95/0001 ....$3.50 S < T asserts that [S] C [T]: \nthe set denoted by S is a subset of the one denoted by T. From a more refined point of view, we can think \nof S as a more informative or richer type than T. In the standard example, S and T are record types where \nS has all of the fields of T and possibly others. Then viewing a value s E S as an element of T involves \nprojecting out the T part of s. Indeed, we may want the coercion from IS] to [T] to involve literally \nthrowing away the irrelevant parts of s, so that two elements of [S] that differ only on fields not present \nin T will be judged equal as elements of T. It has been noticed that these simple interpretations of \nsubtyping do not offer satisfactory support for pro\u00adgramming with update. Consider a standard problem \nthat arises when a A-calculus with subtyping is used to model a purely functional variant of Smalltalk. \nAn ob\u00adject in such a model is a record of instance variables together with a collection of functions \n(its methods) that can be invoked to perform various transformations and inquiries on the instance variables. \nFor example, the instance variables of a one-dimensional point could be represented by a one-field record \nof type {z:lnt}, whereas a colored point object would use a richer rep\u00adresentation type like {z:Int, \nc: Cob-}. Suppose that both kinds of points have a bump method that in\u00adcrements the x field. In the case \nof ordinary points, this method would have the type {z:lnt} + {x:lnt}; colored points would come with \na bump method of type {x:lnt, c: Color} -+ {z:Int, c: Color}. Now, a character\u00adistic feature of object-oriented \nprogramming languages is the ability to define the common behavior of points and colored points only \nonce: we want to write a class of points, from which point objects may be instantiated, and use this \nclass to build a subclass of colored points where just the behavior for colors is added. In part icu-Iar, \nwe want to write the bump method just once. Since instances of the point and colored point classes have \nbump methods of different types, a single defini\u00adtion of bump must clearly be polymorphic in the type \nof the state, i.e. it should have a type like bump c All(X<{x:lnt}) X-+X, as suggested by Cardelli and \nWegner [II]. Unfortunately, given the standard inter\u00adpretation of subtyping, this type is not inhabited \nby any useful functions. In effect, the constraint X< {z:lnt} is too weak to allow an element e of X \nto be manipu\u00adlated in any nontrivial way, aside from throwing away all the information in e except the \nz field. In partic\u00adular, there is no way to construct a new element of X with an updated z field. (More \nformally, in parametric models, where the behavior of polymorphic functions is independent of the type \nat which they are instanti\u00adated, types like All (X <T) X+X are inhabited only by identity functions. \nWhen an element f of such a type is instantiated at some one-element subset S of T, the resulting function \nfrom S to S must clearly be the iden\u00adtity; but all instances of ~ have the same behavior, so they are \nall identity functions.) This deficiency has led to proposals for enriching the language of types so \nthat in-place modifications of re\u00adcords may be given sound typings [10, 7]. But the complexity of these \nextensions has hindered their wide\u00adspread acceptance. We propose here a more radical ap\u00adproach: modify \nthe semantics of subtyping to include both projection and update, so that the naive poly\u00admorphic typing \nof bump becomes sound. Rather than a simple coercion function from [S] to [1 ], we interpret the statement \nS < T by a pair of functions, [S<T] E [S] + [T] X [S]+ [~]+ [S!, implicit coercion put[S,T] one for \nprojecting out the T part of an element of S and one for overwriting the T part of an existing element \nof S with a new element of T. As usual, we elide uses of the forgetful coercion in the concrete syntax \nof pro\u00adgrams; the second is denoted by a constant put [S, T]. For example, put[{z:.hzt, c: Color}, {x:lnt}] \n{z=5, c=bhe} {z=6} = {z=6, c=blue}. The coercion and update functions are related by three laws: 1. \nUpdating a value s c S by tG T and then project\u00ading out the T part yields exactly t. 2. Updating s with \nthe T part of s itself leaves s un\u00adchanged. 3. Updating s with tl c T and then with t2 E T yields the \nsame result as performing just the second update.  Laws similar to these arise in Oles category of \nstate shapes [22]. This coincidence [pointed out to us by John Reynolds and Bob Tennent] is reassuring, \nsince Oles is also concerned with the semantics of update, though he works in a setting that does not \ninvolve sub\u00ad typing per se. The simple intuition of overwriting records extends naturally to the results \nof functions and polymorphic functions. To overwrite one function by another, for ex\u00adample, we form a \nnew function that applies both of the original functions to its argument and then overwrites one result \nwith the other. However, this construction works only in result positions; in general, it does not make \nsense when subtyping is allowed in contravariant positions. This leads us to the idea of a positive subtyp\u00ading \ncalculus in which subtyping is allowed only in covari\u00adant positions and the refined interpretation of \nsubtyping as coercion plus update always makes sense. Other recent papers show a related tendency to \ntune the definition of subtyping to achieve soundness of vari\u00adous forms of updating constructs. Abadi \nand Cardelli s calculus of primitive objects [1], for example, allows in\u00addividual methods of objects \nto be replaced in running programs. Soundness of this update is achieved by in\u00adterpreting an object type \nby a semantic union over fixed points of all possible extensions of its methods; the cor\u00adresponding subtyping \nrule for object types allows ex\u00adtension of the set of methods but no refinement of the types of existing \nmethods. Bruce [4] allows methods to update instance variables, again restricting subtyp\u00ading to extensions \nof the collection of instance variables. In these systems, the entities subject to update are complex \ndata structures, governed by specially tailored rules. We take a more elementary approach, first study\u00ading \nupdate in a general setting and later applying our treatment to add high-level update to (a second-order \nfragment of) the primitive object model proposed by Pierce and Turner [24]. In Sections 2, 3, and 4, \nwe introduce the syntax, equational theory, and semantics of a positive variant of the calculus F< of \nsecond-order bounded quantific\u00adation [9, 15]. Se;tion 5 presents an example at some length, showing how \nthe equational laws of positive F< can be used to prove nontrivial facts about a small object-oriented \nprogram. This proof is modular, in the same sense that the object-oriented program itself is modular. \nThe program contains two class definitions, the second inheriting some of its behavior from the first. \nAlthough both classes involve recursive self-reference through the pseudo-variable self, the proof can \nbe struc\u00adtured so that properties of the second class can be es\u00adtablished without looking back at the \nimplementation of the first class. Section 6 discusses some limitations imposed by the restriction to \npositive-only subtyping and briefly spec-The subtyping relation 171-S < T is the least relation ulates \non possible extensions. In particular, with only positive subtyping one loses %ubsumption between ob\u00adject \ntypes (though not the ability to write programs that operate polymorphically over objects with differ\u00adent \nsignatures); however, it appears that positive and ordinary subtyping can peacefully coexist, in the \nsense that S < T can be allowed even when its proof in\u00advolves contravariance; the constant put[S, T] \nis simply left undefined in these cases. Moreover, we foresee no barriers to integrating features such \nas higher-order sub\u00adtyping [6, 12, 25] and partial functions, allowing the ex\u00adtension of our simple example \nto a full-scale model of object-oriented programming. Although our development is self-contained, read\u00aders \nmay enjoy comparing our system with standard bounded quantification calculi [15, 9] and semantic mod\u00adels \nof subt yping [5, 3]. In Section 5, familiarity y with the literature on type-theoretic models of object-oriented \nprogramming languages [16, 1, 4, 24, etc.] may be help\u00adful. In this summary, most proofs are elided. \nThey may be found in the full version of the paper [17]. Definitions We begin with the concrete syntax \nand typing rules of F<, extended with a cartesian product type and a family of constants put[S, T] and \nrestricted to positive subtyp\u00ad ing. The sets of terms, types, and contexts are: e .. .. x I ~zm (z:T) \ne I el ez I fun(X<T)e I eT I (e,, e2) \\ e.1 I e.2 I put[Tl, Tz] .. T .. Top I X 1T1+T2 I All (X<T1) \nT2 I T l XT2 .. r .. 0 I r,X<T I r,x:T The judgments of the system are statements of the form r l--S \n< T (subtyping), I_ t-e c T (typing), and 17 t-el = e2 G T (equality) in which the free variables on \nthe right of the turnstile are all bound in r and the free type variables in each binding in r are bound \nto the left; we formally identify statements up to renam\u00ading of variables bound on either the right or \nthe left of the turnstile. In examples, we also use records and base types like Int and Color. Base types \nand constants may be regarded as variables in some standard pervas\u00ad ive context. The full version of \nthe paper shows how records with the usual subtyping rules can be encoded in terms of cartesian products, \nusing a simple version of a trick due to Cardelli [7]. The put constants arising from this encoding can \nbe used to perform in-place up\u00ad date of individual fields. closed under the following rules: (S-ToP) \n(S-TVAR) (S-REFL) (S-TRANS) (S-ARROW) (S-ALL) (S-PROD)171-S1x S2<T1xT2 Except for S-ARROW, these are \nexactly the subtyping rules of F< (more precisely, of the Kernel Fun variant of F< [1 l]; full F< [15, \n9] uses a richer, but problem\u00adatic, version of S-ALL; see [23, 25]). S-TOP asserts that Top is a maximal \nelement of the subtype ordering for every 17; S-TVAR uses an assumption of the form X <T from the context; \nS-REFL and S-TRANS state that the subtype relation is a preorder; S-ARROW, S-ALL, and S-PROD extend the \nrelation to functions, polymorphic functions, and cartesian products. Note that S-ARROW and S-ALL are \nboth non-variant on the left-hand side and covariant on the right. The typing relation r t-e ~ T is exactly \nthe same as in standard F< except for the constants put[S, T ]. It is the least relation closed under \nthe following rules. (T-VAR) (T-ARRow-I) (T-ARRow-E) (T-ALL-I) r t e E All (X<S1) S2 rt-T<s~ (T-ALL-E) \nr t-e T E [T/X]S2 rl-elc Sl 17Fe2~S2 (T-PRoD-I)rt-(cl, ez) e SIXS2 (T-PRoD-El) I t-ee S1x S2 (T-PRoD-E2)171-e..2~S2 \n(T-PuT) r + put[S, T] E S+T+S (T-SUB) The rule T-VAR uses a typing assumption from the con\u00adtext; T-ARRow-I, \nT-ALL-I, T-ARRow-E, and T-ALL-E are the standard rules for introduction and elimina\u00adtion of functional \nand quantified types; T-PRoD-I, T-PROD-E1, and T-P RoD-E2 give pairing and projection; T-PuT allows put[S, \nT] to be used as a function of the appropriate shape whenever S < T; T-SUB is the rule of subsumption \ncharacteristic of A-calculi with subtyping. 3 Equational Theory We present the equational theory of positive \nF< in two steps: first a reduction relation, which may be thought of as an abstract operational semantics, \nthen a full equa\u00adtional theory extending the reduction rules with more general laws for proving equivalences \nbetween programs. Single-step reduction on terms (at a type) is the rela\u00adtion generated by applying one \nof the following rules at any subphrase of a term (strictly speaking: at any node in a typing derivation): \n(R-BETA) (R-BETA2) r E (S1, S2).1 E v (R-PRoD1) r~ (S1,DSI V S2).l C rt-(S1, S2).2E v (R-PRoD2) (R-PuT-ToP) \nr } put[u-hsz, U+T2] f g e v r 1-put[u-+sz, U+T2] f g D fun (u:U) put[S2, T2] (f u) (g u) Gv (R-PuT-ARRow) \n 1?} put[AJl (X<U) S2, Alt (X< U)T2] f g c V I F put[All (X<U) S2, All (X<U) T2] f g D fun (X<U) put[S2, \nT2] (f X) (g X) EL (R-PuT-ALL) r F ~ut[s1xs2,T1XT21s t c v I ~ put[S1x S2, T1xT2] st D (put[Sl, Tl] \ns.1 t.1,wt[S2, T ] S.2t.z) Gv (R-PuT-PRoD) The first four rules are the standard ones for functions, \npolymorphic functions, and projection. The others de\u00adscribe how various instances of put behave: put[S, \nTop] throws away its second argument, since an element of Top is considered to contain no information \nand so the update is trivial; each of the last three pushes an in\u00adstance of put inside of one of the \nother type construct\u00adors. From R-Put-Prod and R-Put-Top we obtain a de\u00adrived rule for record types allowing, \nfor example, the reduction: put[{z:kt, c: CO1OT}, {z:ht}] {x=5, c=blue} {x=7} D {s= 7, C=bz Ut3} Note \nthat what we have defined is a typed notion of reduction: types are not erased at runtime. Indeed, untyped \nreduction does not seem to make sense in this setting. For example, put[{x:lnt, V:lnt}, T] {x = 5, y \n= 3} {Z = 4,y= 2}equalseither {z=4,y =2}or {z= 4, y = 3}, according to whether T is {z:Int, y:hzt} or \n{z:lnt}.The typing information affects the result of the computation, and so may not be sensibly erased. \nThe reduction rules do not fully specify the behavior of put [S, T] when S and T cent ain variables. \nFor reas\u00adoning about programs, the equational theory generated by reduction is thus inadequate: it must \nbe extended so that it embodies the assumption that such indetermin\u00adate instances of put will eventually \nbe instantiated with well-behaved concrete ones. Equality on terms (at a type) is the least reflexive, \ntransitive, and symmetric relation closed under the fol\u00adlowing rules: R-BETA through R-PUT-PROD (replacing \nD by =), a congruence rule for each term constructor, r,x:SFe=e ~T (E-ARRow-I) r 1-fun (z:S) e = fun \n(x:S) e c S+T l_ 1-e1e2=eje~e T (E-ARRow-E) l?, X< SIEe=e GS2 r !-jtm(X<Sl)e = fun (X< Sl)e E All (X<S1) \nSz (E-ALL-I) 17+e=e 6 AU(X<S1)S2 r; Ts 1 (E-ALL-E) rt-e T=e T~[T/X]Sz I l-el=e{e S1 I 1-e2=e~ES2 (E-PRoD-I) \nrt-(cl, ez) = (e~, e!) E S1x S2 I }e=e GS1xS2 (E-PRoD-E)I 1-e.i=e .i E S, fori C {1,2} q-conversion \nfor both term and type applications, q\u00adconversion (subjective pairing) for products, subsump\u00adtion, rl-e=e \ne S rl-s<T (E-SUB) I t-e=e c T identification of all elements of Top, 17hec T0p l?l-e ~ Top (E-ToP) I \nte=e E Top a rule describing the behavior of put on variables, rl-put[x, u]st GT (E-PuT-VAR) r t-putlx, \nU1s t = Pd[xjr(x)]s (put[r(x), u]s t) and three rules characterizing the behavior of put uni\u00adformly at \nall types: 171-put[S, T]st~T (E-PuT1) rEpz4t[s, T]st=te T rhput[s, T]ss6s (E-PuT2) rFput[s, T]ss=s Es \n171-put[S, Tl (put[S, T] s t ) t E S 171-put[S, T] (put[S, T] s t ) t = put[S, T] s t G S (E-PuT3) Of \ncourse, E-PuT-VAR is a special case of E-PuT3; we name it only as a convenience for proofs. A number \nof additional laws for manipulating put may be derived from the equational theory. Realizability Semantics \nIn this section we define a partial equivalence relation model for positive F <. This establishes consistency \nof the equational theory in Section 3 and also lays down the intended semantics of positive F< in terms \nof un\u00adtyped computation. As usual, types ire interpreted as partial equivalence relations (pers) on the \nnatural num\u00adbers and terms are interpreted as numbers denoting partial recursive algorithms. The new \nfeature of our model is the interpretation of subtyping judgments. We define a notion of updatable subper \nextending the usual notion of %ubper = set-inclusion with an extra map satisfying the three put-laws \nfrom Section 3. We prove that a per S is an updatable subper of T iff S admits a decomposition into S \n% T x R for some per R, thus establishing the correspondence of positive F< with the intuitive understanding \nof updating. (Oles [22] establishes an analogous property for his state-space se\u00admantics.) This section \nmay safely be skipped on a first reading. We assume some coding of partial recursive functions as natural \nnumbers. The application of the mth par\u00adtial recursive function to argument n is written m . n. We assume \nsome recursive encoding of pairing, writing (m, n) for pairing and ml, rz for the projections. We also \nmake use of semantic abstraction on recursive functions: if ~ (z) is some description of a partial recursive \nfunction with input x, then we write ~x. f (x) for the correspond\u00ading code. Clearly we have (Az. f(z)) \nm = f(m), but not necessarily Ax. (m . x) = m. A partial equivalence rela\u00adtion (per) is a symmetric and \ntransitive relation on the set w of natural numbers. If A is a per we write m {A} n if m and n are related \nby A. We write dom(A) for the set {n I n {A} n}. One defines morphisms between pers in the usual way \nas equivalence classes of codes that respect the relations. The category thus obtained is cartesian closed \nand the terminal object, products, and exponential can be chosen in such a way that they also satisfy \nthe subtyping laws for Top, product types, and function types (see e.g. [5]. We say that A is a subper \nofB iffA~B quasetsofpairs. We say that A is an updatable subper of B and write A < B, if A is a subper \nof B and there exists a morphism p G A -+ (B+A) satisfying the three put-equations from Section 3. More \nprecisely, A < B if A ~ B and for some code p G w we have: O) Vu, a , b, b . a {A} a + b {B} b +p. a. \nb{ A}p. a . b 1) Va~ dom(A), b~ dom(B). p.a. b{B}b 2) Va~dom(A) .p. a.a{A}a 3) Vu E dom(A), b, b E dom(l?) \n. p.(p. a. b ). b{ A}p. ab We then say that p witnesses A < B, written p 1= A S B. 4.1 Proposition: \nLet A be an updatable subper of l?. Then there exists a per R such that A is isomorphic to B x R. Moreover, \nif p witnesses A < B, then the isomorphism can be chosen in such a way that p arises canonically. This \nmeans that if p : A s B x R is the isomorphism, then ml o q : A+B is an inclusion and the morphism coded \nby p equals Au. M. p-l((b, nz(p(a)))). We have seen that equations E-PuTl to E-PuT3 are complete in \nthe sense that they characterise the canon\u00adical situation where the subtype coercion is a product projection \nand put replaces one product component and leaves the other one unchanged. Nevertheless, the mere fact \nthat A is an updatable subper of B does not uniquely determine a witness. Thus, we must give a proof-relevant \ninterpretation of the subtyping judge\u00adment, specifying the particular witness chosen. Clearly, for the \ntype constructors a canonical witness can be defined according to the equations in Section 3, but for \nvzwiables there is no canonical way to choose such a wit\u00adness; we therefore require that the environment \nsupply a witness for each assumption X< U. A type environment is a finite function from type variables \nto pers. If r is a type environment then for X c dom(r) the per 7(X) is meant to interpret the type X. \nA term environment is a finite function from term and type variables to natural numbers. We use the notation \nr[X H R] for updating a finite function at one point. If q is a term environment and x is a term variable \nin the domain of V, then q(z) is meant to inter\u00adpret the term z, while for a type variable X c dom(v) \nthe code q(X) is meant to interpret the put-function relating the type X to its upper bound. An environ\u00adment \nis a pair (-r, q) of a type environment and a term environment. If T is a type expression and ~ a type \nenvironment with FTV(T) ~ dom(~), then the interpretation of T under r, written [T]., is the per defined \nas follows: Let q be a term environment, 17 a context, and S, T type expressions. The (possibly undefined) \nwitness as\u00adsociated to S and T under 17and q, written putr;~ [S, T], is the number defined as follows: \nPutri~ [S, Top] = As. At. s PUtrJV[X, X] = Ax. Ax . x Putr,T[X, T] = Ax. M q(X) . z. (Putr,n[r(X), T] \n. z. t) (when T #X) Putr;9[V+S, U+T] = As. N. Au. Putr,~[S, T] . (S. U) . (t. U) Putr;7[Sl x S2, T1 x \nT 2] = As. At. (Putr,q[Sl, Tl] ~ml (s) oml (t), Putr,V[Sz, 772] 7T2(s) ~2(t)) Putr,n[All (X<17) S, All \n(X<U) T] = As. M. Ap. Putr,x<u,q[x+p] [S, T] ~(S ~P) ~(t ~P) undefined otherwise. We say that an environment \n(q, r) satisfies a context r, written (q, ~) ~ 17, if (1) q is defined on all term and type variables \noccurring in r; (2) r is defined on all type variables occurring in I ; (3) whenever I_ admits a decomposition \nr = rl, X<T, 1 2, we have (q, r) >171 and q(X) ~ 7(X) < [r(X)]~; and (4) for each x E FV(I ), we have \nq(x) E dom([I (x)]T). 4.2 Theorem [Soundness of subtyping]: If I t-S < T and (q, ~) \\ 17then PutriV[S, \nT] + [S]r < [T]r. Our aim is to give meaning to raw terms rather than typing derivations in order to \navoid coherence consider\u00adations (cf. [3] ). In particular, the interpretation should be independent of \nparticular instances of the subsump\u00adtion rule. But since the interpretation of put [S, T] via the Put \nfunction is context dependent, we do have to make contexts part of the interpretation of terms. Moreover \nin the interpretation of a polymorphic applic\u00adation e S we want to apply the meaning of e to the function \nPutr;n [S, U], where U is the upper bound of the universally quantified type of e. So we need some typing \ninformation on e. Fortunately, our subtyping system is such that the upper bound U is uniquely de\u00adtermined \nby the term e and the context I . 4.3 Lemma: There is a partial function Boundr (e) as\u00adsigning types \nto terms in a given context, with the prop\u00aderty that if 17 1-e 6 All (X<U) S then Boundr (e) = U. Moreover, \nthere is an algorithm that calculates Boundr (e) whenever it is defined. Let v be a term environment, \nI a context, and e a term. The (possibly undefined) interpretation of e un\u00adder r and q is the natural \nnumber given by the following clauses: To keep the discussion simple, we work in the second II+,q = ~(x) \n[e.l]r,T = I([elr;q) [e.2]r,n = ~2(Uelriq) [(cl, e2)JJr,q = (Uellr,q, [ezlriq) [fun (z:T) e]r,n = m. \n[elr,Z:~;nIZ*~l [el e2]r,q = [ellr;q [ezlr;~ [put[s, q]~;v = PUtr,7 [S, 7 ] [.h (x<U) e],,, = @ [elr,x<u;q[x+pl \n[e~lr,. = [e]r,q ~Putr,7[T, Boundr(e)] 4.4 Theorem [Soundness of typing]: Let (q, r) ~ 17and r t-e E \nT. Then [e]rin E dom [7 ]7. 4.5 Theorem [Equational soundness]: Suppose (n, r) ~ r and 171-e = e E T. \nThen [e]r,q {[T]~} [e ]r,q. Since, as we observed, typing information affects the validity of certain \nequations, one may ask whether the system is still parametric, i.e. whether polymorphic functions are \ngiven uniformly for all types. Obviously, the answer is no because, as observed in Section 1, in this \ncase the type All (X< PointR) X-+X would contain only identity functions, which is not what we want (or \nhave). However, we believe that a refined theory of parametricity can be obtained for our calculus based \non a translation into pure system F upon which a quantified type A/l(X<T) . . . would be translated into \na relativised quantification A1l(X)(X-+T) + (X+T+X) + . . . generalizing the Penn translation of F< into \npure sys\u00adtem F [3]. Notice also that the above interpretation gives rise to a compositional translation \nof our calcu\u00adlus into untyped computation, which, however, is not simply given by type erasure. 5 Application \nto Objects and In\u00adheritance Pierce and Turner [24] presented a model of objects, message-passing, and \ninheritance based on the typed A\u00adcalculus F ; [6, 12, 25], an extension of F< with higher\u00ad . order poly \nmorphism. In thk section, we apply our re\u00adfined subtyping mechanism to show how this model of objects \ncan be simplified and extended; we then use the equational theory of Section 3 to prove a simple prop\u00aderty \nof a small class hierarchy. Our account of inherit\u00adance based on positive subtyping extends the treatment \nin [24] in two ways. First, since updating is built in, we obtain a much simpler inheritance operation \nwhich avoids explicit handling of update functions. Second, using the equational theory we can reason \nabout object\u00adoriented programs and structure proofs and specifica\u00adtions along the hierarchy of inheritance. \norder system developed in previous sections; this cal\u00adculus is expressive enough to illustrate the key \npoints of the example, which concern the creation of objects from classes. We would need to introduce \nthe higher\u00adorder polymorphism of F$ in order to write programs that use objects by sendin~ them messages, \nbut this will not concern us here. Naraschewski, in collaboration with Hofmann, has used the LEGO proof \nchecker to experiment with mech\u00adanical verification of object-oriented programs along similar lines [21]. \nThe relationship of these reason\u00ading techniques to the literature on non-type-theoretic object-oriented \nverification (see e.g. [20] ) remains unex\u00adplored. 5.1 Technical Preliminaries Before starting, we need \na little technical machinery. First, we want a logic in which proofs about programs may be phrased a \nmany-sorted, first-order extension of the equational theory given in Section 3. In par\u00adticular, we need \na notation for predicates on programs and a framework for showing that a function preserves a predicate. \nIn this summary, we treat this logic in\u00adformally, introducing a set of first-order formulas P in\u00adcluding \natomic equality formulas and quantification over term and type variables. Sequents in thk logic have \nthe form 17 &#38; @ * +, where @ is a set of formulas and @ is a formula, all well typed in r; derivable \nsequents can be defined by augmenting the equational rules with Gentzen-style rules for the logical connective. \nSecond, to assign a value to self when creating ob\u00adjects, a fixed-point combinator is needed [14, 19]. \nSuch combinators come in several forms, with varying degrees of power and technical complexity. We consider \nthis point in detail. The unrestricted use of self in object-oriented pro\u00adgrams can, in principle, give \nrise to arbitrary patterns of recursion. Such programs can only be interpreted using partial functions \nand general recursion. We see no obstacle to modifying our semantics so as to accom\u00admodate partial functions \n(using, for example, the com\u00adplete, uniform pers of Amadio [2]) and refining our equa\u00adtional theory accordingly, \nto support inequational reas\u00adoning. However, many examples arising from object\u00adoriented practice obey \na more restrained discipline in which self is used as a program structuring technique rather than as \na means of implementing general recurs\u00adive algorithms. In such cases, the recursion implicit in the use \nof self terminates after a fixed number of itera\u00adtions typically just one or two, as in the case of \nthe cpointClass that we define in Section 5.3. In particu\u00adlar, inheritance with self is often used to \nprovide vir\u00adtual methods, like the display method in a generic class of geometric objects, which are \nused to implement the other methods of the generic class and which must be supplied by each concrete \nsubclass. In such situations, the fixed point can be replaced by a bounded fixed point, which may be \ninterpreted in a model providing only total functions, such as our existing per semantics. By relying \nonly on the elementary reasoning principles that apply in this setting, we avoid obscuring the salient \nfea\u00adtures of the present case study the logical reflection of the late binding of methods and the modular \nstructure of proofs following the hierarchy of classes. For each natural number n, let jixn ($, a) stand \nfor the expression ~n (a). This abbreviation satisfies the following derived typing rule: I !-fET-+T \nI t-a ET (T-FIxN) I FJixn(f, a) ET We say that an instance jixn(f, a) is sound if it is well typed in \nthe prevailing context 17and if j m is constant, i.e. we can prove I , z:T, v:T 1-fn(x) = fn(y) 6 T. \nNOW, if fizn(~, a) is sound and 17h b ~ T, then fiz~(f, b) is also sound and I 1-j kn(f, a) = fizn(f, \nb) c T. Moreover, fizn( f, a) is a fixed point of f, i.e. r t\u00adfixn(j, a) = f(fizn(f, a)) E T. This gives \nrise to the following derived rule, which can be seen as a bounded version of the standard fixed-point \ninduction principle: BOUNDED INDUCTION: Let ~(z) be a predic\u00ad ate on a type T in a context I , and let \n@ be a set of formulas well typed in I . Moreover, suppose I t-fizn (f, a) E T is sound. If 1. p is consistent, \ni.e. there is some 17+ tG T such that 17\\ @ ~ p(t);and 2. p is preserved by ~, i.e. 17 + @ =.+  VX:T. \nyY(z) o p(f(z));  5.2 Basic Classes An interface signature is a type M(X) with a distin\u00adguished free \nvariable X. For example, here is the signa\u00adture of the simple point objects described in the intro\u00adduction: \nPointM(X) = {get: X+Int, set: X+ Int+X, bump: X-+X} The idea is that, given a concrete representation \ntype R, an initial state s E R, and a record of methods m G M(R), we can build a value object~(R, s, \nm). The type Object (M) contains all objects constructed in this way; that is, the variable X in M is \na place-holder for an arbitrary representation type. A typical imple\u00admentation of points might use the \nrepresentation type PointR = {x:Int} and these methods: m = {get = fun (s: PointR) S.X, set = fun (s: \nPointR) fun (i:kt) {z = i}, bump = fun (s: PointR) {z = 1 + s.z}}  An object with this representation \nand collection of methods would then be built by applying object to m and an appropriate initial state: \np = objectPo,n,JPointR, {x = O}, m). Object and object can be encoded in pure F< using ex\u00adistential \ntypes [24], but we are more interested here in convenient ways of constructing the record of methods \nm. A class is a data structure that can be used in two ways: it can be instantiated to build the methods \nof new objects, and it can be extended to form subclasses shar\u00ading some of its behavior. A class whose \ninstances have interface M contains code for the methods described by M. Moreover, since a class may \nbe reused in a sub\u00adclass with a different representation type S typically a record type representing \na bigger set of instance vari\u00adables the methods in a class must be defined poly\u00admorphically with respect \nto possible extensions of the representation type. Classes thus have the following type: Class(M, R) \n= All (S<R) M(S). For example, for the signature PointM and the repres\u00adentation type PointR, we may \ndefine simplePointClass = fun (S< PointR) {get = fun (s:S) s.x, set = fun (s:S) fun (i:Int) put[S, PointR] \ns {x= z}, bump = fun (s:S) put[S, PointR] s {x= 1 + s.x}} c Class (PointM, PointR). This class can be \ninstantiated as follows, yielding a point with the same behavior as p: myPoint = object ,o,n,JPointR, \n{x= O}, simplePointClass PointR)  This presentation of classes is significantly cleaner than the one \nin [24], which required that the coercion and update functions connecting R and S be managed explicitly \nby the programmer. More importantly, we can use the equational theory of Section 3 to reason about such \nclasses something that is not just in\u00adconvenient but impossible in low-level models like [24], where \nthe connecting functions are carried by ordin\u00adary variables with no special properties. It is easy to \nshow, here, for example, that, whenever S s PointR and sGS and i G Int, s: PointR, i:Int E (simplePointClass \nS) get (1) ((simplePointClass S).set s i) = i E Int. Continuing with the example, we also want to imple\u00adment \ncolored points, which have a method for querying color information. Their interface signature and inten\u00added \nimplementation type are: CPointM(X) = {get: X+Int, set: X+ Int+X, getC: X+ Color, bump: X+X} CPointR \n= {x:Int, c: Color}. The crux of the example is that we can define a class of colored points by inheriting \nthe behavior of the get, set, and bump methods from simplePointClass. simple CPointClass = fun (S< CPointR) \nlet super = simplePointC lass S in {get = super. get, set = super .set, bump = super. bump, getC = fun \n(s:S) s.c} Notice that, without further proof, 1 holds for simple CPointClass.  5.3 Classes with self \nMost object-oriented languages not only allow the im\u00adplementor of a class to refer to the methods of \nits su\u00adperclass, but also provide, via a pseudo-variable self, re\u00adcursive access to the methods of the \nsubclass from which a running object has actually been instantiated. In the theoretical literature on \nobject-oriented languages, this feature has been modeled by abstracting the methods of classes on a variable \nself, which is supplied at instanti\u00adation time using a fixed-point operator. In the present framework, \nthis extension is accomplished by altering the type of classes as follows: Class (A/l, R) = All (S<R) \nM(S) + M(S). The constructors Object and object need not be changed. To instantiate a class cl c Class(J?, \nR), we first take a (bounded) fixed point of ci(R) and then proceed as before. Using self, we can rewrite \nour earlier class of points so that the bump method is implemented in terms of the get and set methods \ninstead of directly modifying the state: point Class = fun (S< PointR) fun (self :PointM(S)) {get = fun \n(s:S) S.Z, set = fun (s:S) fun (i:Int) put[S, PointR] s {z = i}, bump = fun (s:S) self. set s ((self. \nget s)+ 1)} Now, for the sake of the example, suppose we want cpomtClass to override the set method \nfrom pointClass with a new method that invokes the set method from super and then sets the c field of \nthe result to blue; that is, the set method of cpoint Class has the same behavior as that of pointClass \nas far as the fields in PointR are concerned, but also sets the c field. Since the bump of cpointClass \nis the same as that of pointClass, which is implemented using set, the new behavior of set will be shared \nby bump: sending bump to an instance of cpoint Class will change its color to blue. cpointClass = fun \n(S< CPointR) fun (self: CPointM(S) ) let super = point Class S self in {get = super. get, set = fun (s:S) \nfun (i:Int) put[S, {c: Color}] (super. set s i) {c= blue}, bump = super. bump, getC = fun (s:S) S.C} \n The process by which subclasses are built from su\u00adperclasses might be described more abstractly as fol\u00adlows. \nSuppose U and M are the interfaces of an ex\u00adisting superclass and a desired subclass, and R and R are \nthe representation types, with R < R and S<R k M (S) < M(S). Let superclass E Class(A/l, R) be the superclass, \nand let build E All (S< R ) M (S) + M(S) +-M (S) be an extension function that, given self G M (S) and \nsuper ~ M(S), constructs a record of subclass methods specialized for the representation type S. The \nnew subclass is then given by the expression sub Class = fun (S<R ) fun (self :M (S) ) let super = superClass \nS self in bmld S self super.  5.4 Reasoning about Classes with self The construction of subclasses from \nsuperclasses has an exact analog at the logical level. For each S < R, let ps(m) be a predicate on type \nM(S) i.e. ps(rn) should be well typed in the context S <R, m: M(S). Furthermore, for each S < R , let \np~(m) be a pre-self E CPointM (S) satisfies vs. From the fact that V,S dicate on type M (S) such that \nS< R , rn:itl (S) 1-is preserved by pointClass S, we have that V,S holds for Then in order to show that \n~~(~) * k%(m). subClass preserves V; i.e. that S< R , self: M (S) k super = point Class S self, P \ns(seti) * pk (sub Class S seZf) it suffices to show which immediately gives the first two clauses in \nthat superclass preserves P,S and that: ws( cpointclass Sself), since the get and bump fields of S< R \n, self: M (S), super:M(S) k p s(self) A p.g(super) cpointClass S self are copied directly from super. \nAfter =+ ~ s(budd S self super) expanding the definition of set in cpointClass, the third clause becomes \nThis pattern of reasoning is useful because it allows us Vs~S. Vi~Int. to prove the crucial premise \nof the bounded induction put[S, {c: Color}] (super. set s i) {c= blue} principle stability of a predicate \n in a modular = {x=i} fashion, following the hierarchy of classes. For example, E PointR. suppose we \nbuild a record of colored point methods by (3) taking a fixed point of the methods in cpointClass: Now, \nsince the fields of PointR are disjoint from cpointMeth = J$x2 (cpoint Class CPointR, m) {c: Color}, \nthe left-hand side can be shown to be equal to super. set s i in PointR. Equation (3) follows from the \nthird clause of PS (super). (Here m can be any term of type CPointM(CPointR), To apply bounded induction, \nwe must still show for example the simple implementation that the instance of fix in the definition of \ncpointMeth simple CPointClass ( CPointR). In a more general set-is sound, and that pCpO,.~n is consistent. \nSound\u00adting with partial functions, the bottom element would ness is easily checked by examining the tree \nof play the role of m.) Let us now prove the following fact possible calls through seZf. The consistency \nof about cpointMeth: vcPo,niR is witnessed by the simple implementation simplePointClass ( CPointR). \nBounded induction now t-VSE CPointR. c CPointM ( CPointR) yields qCp.,.,~(cpointMeth). Equation (2) \nis the first cpointMeth.get (cpointMeth. bump s) clause of this formula. (2) = (cpointMeth.get s)+ 1 \n A different reasoning paradigm underlies the proof of G Int the following fact, which highlights the \nlate binding of methods invoked through self: For each S < PointR, let VS be the predicate 1-VSC CPointR. \n(pS(m) ?!?f Vs~S. m.get (m.bump s) = (m.get s) + 1 cpointMeth get C ( cpointMeth. bump s) (4) E Int \n= blue A VSES. m.get s = S.X E Color. E Int A VSG5 . Vi@nt. m.set s i = {x=i} To show (4), we must first \nisolate some property that E PointR describes the way bump calls set in pointClass (and thus cpoint Class). \nLet S be a subtype of PointR. Expanding of type PointM (S) (in the empty context). As usual the definition \nof pointClass, we can prove in inductive proofs, this predicate is somewhat stronger than the property \nwe actually wish to prove. The two Vself~PointM(S). VseS. 3iEInt. auxiliary clauses can be thought of \nas specifying the (pointClass S self ).bump s (5) salient aspects of the behavior of the recursively \ninvoked = self. set s i methods get and set. This q plays the roles of both p e s, and q above. that \nis, the bump method modifies the state by making We first use straightforward equational and logical \n exactly one call to set. reasoning to show that p,s is preserved by pointClass: For any S < CPointR \nand m E CPointM(S), let S< PointR, self :PointM(S) t-ps(self ) = qS(pointClass S (self)). qs(m) ~f VSGS. \nm.getC (m. bump s) = blue G Color We must next show that p.s is preserved by A VSES. ViEInt. m.getC (m.set \ns i) = blue cpoint Class S for each S < CPointR. So suppose that E Color. Our aim is to prove PC,.,.,.( \ncpointMeth) by bounded induction. Begin by observing that the simple imple\u00admentation simple CPoZnt Class \nS may easily be modi\u00adfied to show consistency of ps. Next, suppose that self E CPointM (S) satisfies \nps. We must show $ .S(cPo~ntClass S self). The second clause is immedi\u00adate from the definition of cpoint \nClass using E-PuTl and the derived reduction rule for record projection. On the other hand, after expanding \ndefinitions the first clause becomes VSGS. ((pointClass S self) .bump S).C = blue G Color. Using (5), \nwe can rewrite the right-hand side as (self. set s i).c for some i. This, in turn, equals blue by the \nsecond clause of ps (self). This completes the argument.  Extensions In full F<, where arrows are contravariant \nin their domains, the rule S-P ROD is derivable from the standard impredicative encoding of products: \nS1 x S2 ~f All (X< Top) (S1 -+ S2+X) + X. In posit\u00adive F<, this encoding fails to satisfy S-PROD, which \nis why we included cartesian product as a prim\u00aditive type constructor. Similarly, the impredicat\u00adive \nencoding of existential types, Some (X <S1 )S2 ~f All (Y< Top) (All (X<SI) S2+Y) + Y is non-variant in \nboth S1 and S2. However, even if existential types are added as primitives, the rule for comparing two \nex\u00adistential cannot be covariant in their bodies, since the accompanying put function cannot sensibly \nbe defined in this case. It seems possible to get along without covariance of existential types, both \nin the object-oriented examples of Section 5 and in the more general constructions in [24], at the cost \nof replacing some implicit coercions between object types by polymorphic type applications. However, \nwe may also consider enriching the subtype re\u00adlation so that, instead of providing only positive subtyp\u00ading, \nwe allow positive and ordinary subt yping to exist side by side, defining the constant put [S, T] only \nin the case where S < T can be proved from just the posit\u00adive rules. Distinguishing two kinds of subtyping \nslightly complicates the presentation of the system and requires a more careful analysis of the subtyping \nand typing al\u00adgorithms, but seems to present no serious difficulties. Another useful extension of positive \nF< (or of full F< with a distinguished positive fragment) would al\u00adlow F@-style type operators, as in \n[6, 25, 12]. The subtyping rule for type operators is just the exten\u00adsion of the positive subtype relation \non their codo\u00admains: if F(T) < G(T) for every T, then F < G. This law should give rise to a polymorphic \nput func\u00adtion put[F, G] c All (X) F(X) + G(X) ~ F(X). We expect that our semantics for positive F< can \nbe exten\u00added straightforwardly to this higher-orde~ calculus using the techniques of [8, 13]. A further \nextension would ac\u00adcommodate covariance and functorial strength as in [18], which would provide generic \nfunctions for method invoc\u00adation and also allow automatic insertion of put functions in class definitions. \n Acknowledgements This research was carried out at the University of Ed\u00adinburgh s Lab for Foundations \nof Computer Science. Hofmann was supported by a European Union HCM fellowship. Pierce was supported by \na fellowship from the British Science and Engineering Research Council. We have profited from discussions \nof records and ob\u00adjects with Martin Abadi, Luca Cardelli, Didier R6my, John Reynolds, and Dilip Sequeira. \nAdriana Com\u00adpagnoni, David Turner, and members of the FOOL working group gave us useful feedback on the \npresent system. Kathleen Fisher and three anonymous refer\u00adees made many suggestions for improvement in \na late draft. References [1]Martin Abadi and Luca Cardelli. A theory of primitive objects: Untyped and \nfirst-order systems. In Theor\u00adetical Aspects of Computer Software (TA G S), Sendai, Japan, 1994. [2] \nRoberto M. Amadio. Recursion over realizability struc\u00adtures. Information and Computation, 90(2):55-85, \n1991. [3] Val Breazu-Tannen, Thierry Coquand, Carl Gunter, and Andre Scedrov. Inheritance as implicit \ncoercion. Information and Computation, 93:172 221, 1991. Also in Carl A. Gunter and John C. Mitchell, \neditors, Z heor\u00adettcal Aspects of Object-Or-tented Programming: Types, Semantics, and Language Design \n(MIT Press, 1994). [4] Kim B. Bruce. A paradigmatic object-oriented pro\u00adgramming language: Design, static \ntyping and se\u00admant its. Journal of Functional Programming, 4(2), April 1994. A preliminary version appeared \nin POPL 1993 under the title Safe Type Checking in a Statically Typed Object-Oriented Programming Language \n. [5] Kim B. Bruce and Giuseppe Longo. A modest model of records, inheritance, and bounded quantification. \nIn\u00adformation and Computation, 87:196-240, 1990. Also in Carl A. Gunter and John C. Mitchell, editors, \nTheor\u00adetical Aspects of Ob~ect-Oriented Programming: Types, Semantics, and Language Destgn (MIT Press, \n1994). An earlier version appeared in the proceedings of the IEEE Symposium on Logic in Computer Science, \n1988. [6] Luca Cardelli. Notes about F~:. Unpublished manuscript, October 1990. [7] Luca Cardelli. \nExtensible records in a pure calculus of subtyping. Research report 81, DEC Systems Re\u00adsearch Center, \nJanuary 1992. Also in Carl A. Gunter and John C. Mitchell, editors, Theoretical Aspects of Object-Orient \ned Programming: Types, Semantics, and Language Design (MIT Press, 1994). [8] Luca Cardelli and Giuseppe \nLongo. A semantic basis for Quest. Journal of Functional Programming, 1(4):417\u00ad458, October 1991. Preliminary \nversion in ACM Confer\u00adence on Lisp and Functional Programming, June 1990. Also available as DEC SRC Research \nReport 55, Feb. 1990. [9] Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. An extension \nof system F with sub\u00adtyping. Information and Computation, 109(1 2):4 56, 1994. A preliminary version \nappeared in TACS 91 (Sendai, Japan, pp. 750-770). [10] Luca Cardelli and John Mitchell. Operations on \nre\u00adcords. Mathematical Structures in Computer Science, 1:3 48, 1991. Also in Carl A. Gunter and John \nC. Mitchell, editors, Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Lan\u00adguage \nDesign (MIT Press, 1994); available as DEC Sys\u00adtems Research Center Research Report #48, August, 1989, \nand in the proceedings of MFPS 89, Springer LNCS volume 442. [11] Luca Cardelli and Peter Wegner. On \nunderstanding types, data abstraction, and polymorphism. Computmg Surveys, 17(4), December 1985. [12] \nAdriana B. Compagnoni. Subtyping in F: is decidable. Technical Report ECS-LFCS-94-281, LFCS, University \nof Edinburgh, January 1994. To appear in the proceed\u00adings of Computer Science Logic, September 1994, \nunder the title Decidability of Higher-Order Subtyping with Intersection Types . [13] Adriana B. Compagnoni \nand Benjamin C. Pierce. Mul\u00adtiple inheritance via intersection types. Technical Re\u00adport ECS-LFCS-93-275, \nLFCS, University of Edln\u00adburgh, August 1993. Also available as Catholic Uni\u00adversity Nijmegen computer \nscience technical report 93\u00ad 18. [14] William Cook. A Denotational Semantics of Inherit\u00adance. PhD thesis, \nBrown University, 1989. [15] Pierre-Louis Curien and Giorgio Ghelli. Coherence of subsumption: Minimum \ntyping and type-checking in F<. Mathematical Structures in Computer Sci\u00adence,-2:55 91, 1992. Also in \nCarl A. Gunter and John C. Mitchell, editors, Theoretical Aspects of Object-Oriented Programming: Types, \nSemantics, and Lan\u00adguage Design (MIT Press, 1994). [16] Kathleen Fisher and John Mitchell. Notes on typed \nobject-oriented programming. In Pmceedtngs of Z he\u00adoretical Aspects of Computer Software, Sendai, Japan, \npages 844-885. Springer-Verlag, April 1994. LNCS 789. [17] Martin Hofmann and Benjamin Pierce. Positive \nsubtyp\u00ading. Technical Report ECS-LFCS-94-303, LFCS, Uni\u00adversity of Edinburgh, September 1994. [18] Martin \nHofmann and Benjamin Pierce. A unifying type\u00adtheoretic framework for objects. Journal of Functional Programming, \n1994. To appear. Previous versions ap\u00adpeared in the Symposium on Theoretical Aspects of Computer Science, \n1994, and, under the title An Ab\u00adstract View of Objects and Subtyping (Preliminary Re\u00adport ) , as University \nof Edinburgh, LFCS technical re\u00adport ECS-LFCS-92-226, 1992. [19] Samuel N. Kamin and Uday S. Reddy. Two \nsemantic models of object-oriented languages. In Carl A. Gunter and John C. Mitchell, editors, Theoretical \nAspects of Object-Oriented Programming: Types, Semantics, and Language Design, pages 464 495. The MIT \nPress, 1994. [20] Gary T. Leavens. Inheritance of interface specifications (extended abstract). Technical \nReport TR#93-23, De\u00adpartment of Computer Science, Iowa State University, September 1993. [21] Wolfgang \nNaraschewski. Verijilcation objektorientierter Programme mit LEGO. Studlenarbeit, Universitat Er\u00adlangen, \n1994. To appear. [22] Frank J. 01.s. Type algebras, functor categories, and block structure. In Maurice \nNivat and John C. Reyn\u00adolds, editors, Algebraic Methods in Semantics. Cam\u00adbrige University Press, 1985. \n[23] Benjamin C. Pierce. Bounded quantification is unde\u00adcidable. Information and Computation, 112(1):131 \n165, July 1994. Also in Carl A. Gunter and John C. Mitchell, editors, Theoretical Aspects of Object-Oriented \nPro\u00adgrammmg: Types, Semantics, and Language Design (MIT Press, 1994). A preliminary version appeared \nin POPL 92. [24] Benjamin C. Pierce and David N. Turner. Simple type-theoretic foundations for object-oriented \nprogram\u00adming. Journal of Functional Programming, 4(2):207\u00ad247, April 1994. A preliminary version appeared \nin Principles of Programming Languages, 1993, and as University of Edinburgh technical report ECS-LFCS\u00ad92-225, \nunder the title Object-Oriented Programming Without Recursive Types . [25] Martin Steffen and Benjamin \nPierce. Higher-order sub\u00adtyping. In IFIP Working Conference on Programming Concepts, Methods and Calculi \n(PRO COMET), June 1994. An earlier version appeared as University of Ed\u00adinburgh technical report ECS-LFCS-94-280 \nand Uni\u00adversitat Erlangen-Nurnberg Interner Bericht IMMD7\u00ad01/94, January 1994.  \n\t\t\t", "proc_id": "199448", "abstract": "<p>The statement <italic>S</italic>&#8804;<italic>T</italic> in a &#955;-calculus with subtyping is traditionally interpreted by a semantic coercion function of type [[<italic>S</italic>]]&#8594;[[<italic>T</italic>]] that extracts the &#8220;<italic>T</italic> part&#8221; of an element of <italic>S</italic>. If the subtyping relation is restricted to covariant positions, this interpretation may be enriched to include both the implicit coercion and an overwriting function <italic>put</italic>[<italic>S,T</italic>] <inline-equation> <f>&#8712;</f> <?pub Caret> </inline-equation> [[<italic>S</italic>]]&#8594;[[<italic>T</italic>]]&#8594;[[<italic>S</italic>]] that updates the <italic>T</italic> part of an element of <italic>S</italic>. We give a realizability model and a sound equational theory  for a second-order calculus of positive subtyping.</p><p>Though weaker than familiar calculi of bounded quantification, positive subtyping retains sufficient power to model objects, encapsulation, and message passing. Moreover, inheritance may be implemented very straightforwardly in this setting, using the <italic>put</italic> functions arising from ordinary subtyping of records in place of the sophisticated systems of record extension and update often used for this purpose. The equational laws relating the behavior of coercions and <italic>put</italic> functions can be used to prove simple properties of the resulting classes in such a way that proofs for superclasses are &#8220;inherited&#8221; by subclasses.</p>", "authors": [{"name": "Martin Hofmann", "author_profile_id": "81452607849", "affiliation": "", "person_id": "PP31081598", "email_address": "", "orcid_id": ""}, {"name": "Benjamin Pierce", "author_profile_id": "81100303310", "affiliation": "", "person_id": "P28925", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199482", "year": "1995", "article_id": "199482", "conference": "POPL", "title": "Positive subtyping", "url": "http://dl.acm.org/citation.cfm?id=199482"}