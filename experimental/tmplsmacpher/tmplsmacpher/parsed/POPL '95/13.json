{"article_publication_date": "01-25-1995", "fulltext": "\n Higher-Order Functors with Transparent Signatures Sandip K. Biswas* Department of CIS University of \nPennsylvania Philadelphia, PA 19104 sbiswas@saul .cis.upenn. edu Abstract The programming language Standard \nML provides first\u00adorder functors, i.e modules parametrized by modules. First-order functors in the language \nhave a simple and el\u00adegant static semantics. The type structure of higher-order modules [3], i.e. modules \nparameterized by functors, is well understood. But it is only in the recent past that we have seen an \nimplementation of higher-order functors with a for\u00admally defined static semantics in a dialect of Standard \nML, SML/NJ. Astudyof this static semantics [7] showsit to be much more complicated than the static semantics \nof first\u00adorder functors. This paper investigates whether we can trade some semantic features inthe module \nlanguage toob\u00adtain a simpler static semantics, closer in spirit to that of first-order functors. This \nwork helpsin a conceptual under\u00adstanding of the semantics of higher-order modules. 1 Introduction Modules \nare an essential feature of any language which sup\u00adports the development of large systems. This paper \nad\u00addresses the problem of extending the module system of Stan\u00addard ML. The current module system of Standard \nML pro\u00advides for parameterized modules or functors. Functors in SML are first-order in nature: modules \ncannot be parame\u00adtrized by parameterized modules. Here we remove this re\u00adstriction by providing static \nsemantics for higher-order func\u00adtors. 1.1 Why higher-order modules? IngeneraJ, for any application using \nfirst-order functors, we can always make these functors more general by parametri\u00adzing the parameters \nto the functor. We now present two examples detailing specific uses of higher-order functors. 1. In SML/NJ, \nlibrary routines are implemented as func\u00adtors. For example, a set is a structure parametri\u00adzed by a structure \ncontaining an order relation. The SML/NJ library has multiple set functors depending 'This research was \nsupported by ONR Contract NOOO14-89-J-3155. Permission to copy without fee all or part of thk materfal \nis granted provided that the copies are not made or distributed for direct commercial acfvantaqe, the \nACM copyright notice and the title of the publication and Its date appear, and notice is given that copyi \nis by permission of the Association of Computing Machinery. $ o copy otherwke, or to republish, requires \na fee and/or specific permission. POPL 951/95 San Francisco CA USA @ 1995 ACM 0-89791 -692-1/95/0001 \n....$3.50 on the underlying representation of the set. For exam\u00adple, functor B-inarySet (K: ORDXEY) : \nORD-SET, for sets represented by binary trees, and functor Splay Set (K: ORDXEY) : ORD-.SET, for sets \nrepresented by splay trees, where, signature ORD.KEY = s ig type ord_key val cmpKey : (ord_key * ord.key) \n -> LibBase .relat.ion end signature ORD_SET = s ig type item type set val empty : set val singleton \n: item -> set val union : (set * set) -> set val m.udtems : set -> int .$. end The signature 0RD5ET \ndoes not contain the function closure: (set->set) -> set -> set, which iterates a function on a set till \nthere is no change in cardinality. Butthis may redefined using union, nmdtems. In the absence of higher-order \nfunctors, afunctor with an ex\u00adtended signature containing closure hasto redefined for every set functorin \nthe library. But with higher\u00adorder functors available in the language, the following may be defined, \nfunctor ExtendSet (s : funsig (K:oRD_KEy) ORD_SET) (K : ORD_KEY) = struct structure Set = S(K); open \nSet; funclosuref s=... end This functor ExtendSet may applied to the functors Bi.narySet, Splay Set \nto obtain functors whose result has been extended by the function closure. 2. There may be two independent \nsoftware tools gener\u00adating two functors F and G. A particular application may use the two functors in \na very specific way. The user of this application need not know the structure of the functors, F and \nG, and how they are joined to\u00adgether. A case in point being the parser generator in SML/NJ. A standard \napplication of theparsergener\u00adator uses the provided token structure, and the lexer forlexical analysis. \nSuch anapplication should be able to call a routine which puts together the functors re\u00adturned from the \nparser and the lexer. In the absence of higher-order functors this is not possible. For a calculator \nnamed Calc, ML-Yacc generates a functor CalcLrValsFun. ML-Lex generates a functor named CalcLexFun, To \ncreate a parser the following steps are necessary: structure CalcLrVals = CalcLrValsFun (structure Token \n= LrParser. Token) ; structuxe CalcLex = CalcLexFun (structure Tokens = CalcLrVals.Tokens) ; structure \nCalcPerser = Join (structure ParserData= CalcLrVals.ParserData structure Lex = CalcLex structure LrParser \n= LrPerser); If higher-order functors are allowed in the language we may provide afunctor Join . A user \nusing thk func\u00adtion need not know how the functors returned from the parser andlexer are brought together. \nfunctor Join (CalcLrValsFun,CalcLexFun) = struct structure CalcLrVals = CalcLrValsFun (structure Token \n= LrPaser.Token) ; structure CalcLex = CalcLexFun (structme Tokens = CalcLrVals.Tokens) ; structure CalcParser \n= Join( structure ParserData = CalcLrVals.ParserData structure Lex = CalcLex structure LrParser = LrPsrser); \nend  1.2 Transparent Signatures A key feature of the module system of SML is the presence of trcmsparcmtsignatures. \nThis means that after a structureis constrained by asignature the identities of the components of the \nstructure are not hidden as abstract entities. Simi\u00adlarly, during afunctor application, identities of \nthecompo\u00adnents are propagated. The following example illustrates of the concept, signature ORDER = si.g \ntype t val less :t -> t -> bool end functor Ord.List (K : ORDER) : ORDER = struct type t = K.t list fun \nless [] _ = true I less -[] = false less (al :: restl) (a2 :: rest2) = if (K.less al a2) then (less \nrestl rest2) else false end strut ure int-order : DRDER = struct type t =int fun less (X:t) (y:t) =x \n< y end structure int_list_order = Ord-List(int-order) val _ = int-list-order.less [1,2,31 [2,3,5] The \nabove program statically type checks, even though the functor OrdList constrains int-1.ist.order to have \nthe generic signature ORDER, because i.ntdist.order.t = int list is transparent to the rest of the program. \nTransparency in the higher-order case is more compli\u00adcated. Consider the following program: functor APP \n= functor(F : funsig (X : si.g type t; val x:t end) sig type s; val X:S end) functor(X: sig type t ; \nval x:t end) (F X) functor F = Functor(X : sig type t; val x:t end) struct type s = X.t list val x= [x.x \n] end structure X = struct type t = int; val x = 4 end structure Y = ((APP F) X) val -= car (Y.x) If \nsignatures are completely transparent this program must statically type check. This means that the seman\u00adtic \nrepresentation of APP must indicate that thedependancy between t and s present in the argument F, even \nthough not known statically, has to be propagated. Unimportant question to readdressed is, what are the \nbenefits associated with completely transparent signatures? In [6]it is shown that completely opaque \nsignatures or ab\u00adstract datatypes are not acceptable for expressing modular structure of programs, as \nabstract types have no identity. More importantly no propagation of type information is pos\u00adsible across \nfunction boundaries. This means that elimina\u00adtion constructs associated with abstract types have restric\u00adtions \non type variabIes which can be present in the final expression. In [1], it is shown that it is possible \nto give iden\u00adtities to abstract types but propagation of type information across function boundaries \nis not possible. Translucent signatures as proposedin [5,2] have certain limitations with regard to programming \nwith higher-order modules. As shown in [5], translucent signatures are com\u00adpletely equivalent to transparent \nsignatures in the first-order case. This equivalence fails when we have afunctor takingin a functor as \nan argument because there is no uniform way of propagating information associated with the argument functor \nwithout restricting the set of functors which can be accepted as arguments. This problem of propagating \nin\u00adformation associated with argument functors in translucent signatures has been recently fixed. But \nthere is still a fun\u00addamental problem associated with translucent signatures: programs have to explicitly \nstate the type dependency tobe propagated beyond afunctor boundary. Completely transparent signatures, \nas in SML/NJ, do not require tags in signatures stating type information. Hence the APP functor can be \nwritten the way it has been: with generic signatures. 2 Relation to Existing Work The following is an \nextremely informal presentation of the semantics of first-order functors in SML. A formal version may \nbe found in [9, 10]. A module or structure in SML has a semantic representation which is essentially \na record with fields giving the types associated with the components of the structure. The semantic representation \nassociated with a signature, i.e. specification of the interface of a module, is the same as that of \na structure. with components which are left unspecified being represented by variables which are universally \nquantified. In SML, a functor with a name FF is defined as follows, functor FF (X :signaturel) = structure] \n(1) If ~signaturel ] = dfi. (Xl) then the semantic representa\u00adtion of the functor FF is given by Vfl. \n(Z1, Zh), where ZZ is the result of elaboration of structural in an environment which maps X to XI. If \na functor, with semantic represen\u00adtation d~. (Zl, ZZ), is applied to a structure, with semantic representation \nS1, then the semantic representation of the resulting expression is computed as follows: e Obtain a substitution \n~ with domain fi, such that S1 matches +(Z1 ) as per certain rules. ' Return @(Z2) as the semantic representation \nof the expression. The semantics for higher-order functors in SML/NJ, as presented in [7], is much more \ncomplicated than the first\u00adorder case. In this case, the semantic representation of struc\u00adture and functor \nsignatures is no longer an abstraction of the semantic representation of structures and functors. A func\u00adtor \ndeclaration for FF as in (l), is elaborated as follows: Let Xl be the free 1 structure associated with \nsignature. Let X2 be the result of elaboration of structural in an environ\u00adment which maps X to xl. But \nwhat is returned as the elab\u00adoration of the functor FF is (AX : signature. Algorithml ), where Algorithml \nis a step-by-step description for generat\u00ading 22 from structural. This description is in an interme\u00addiate \nlanguage, wit h a defined operatiomd semantics, and contains references to X and its components. If a \nstructure with representation S1 is applied to FF then the elabora\u00adtion proceeds as follows: First it \nis verified that S1 matches signature. Next, references to the variable .X in Algorithml are substituted \nby S l and the resulting expression is eval\u00aduated, as per the operationrd semantics of the intermediate \nlanguage, to generate the semantic representation of the ap\u00adplication expression. Standard ML has a novel \nfeature, generativity. What this means is that the same structure applied to the same functor returns \nstructures which may differ in certain components, which are generated afresh at each application. The \nques\u00adtion which we would like to address is, if generativity, as a language feature is removed, can we \nobtain a simplifica\u00adtion of the static semantics? If we wish to provide static 1 A free structure associated \nwith (Vfi. X) is [E/@(x), where Z is a fresh set of variables never used before semantics to a higher-order \nmodule system for a strongly\u00adtyped language, which does not have a generativity in its semantics, are \nwe tied to a semantics where functors have a two phase elaboration: one at definition time and the other \nat application time? Can we obtain a semantics similar to that of first-order functors, where the elaboration \nof functor application is merely the application of a substitution tom. puted during the signature matching \nprocess? The rationale behind the semantics in [7] was to propagate dependencies present in functors. \nIn the absence of generativity, when such dependencies are unknown, the obvious strategy is to represent \nthem as universally quantified variables which can be instantiated during the signature matching process. \nTo show that this intuitive strategy works out is non-trivial. This is because these dependency variables \nare going to be functions or simply-typed A-terms and, as shown in [4] for the simply-typed A-calculus \nmost general unifiers do not ex\u00adist and even computing whether a unifier exists is undecid\u00adable. 3 A \nLanguage for Higher-Order Modules 3.1 Syntax of the Language The syntax of the language used, is the \nsame as in [5]. As both structures and functors can be fields of a structure. we use a generic term module \nto refer to both structures and functors. As val expressions do not contribute to any change in the static \nsemantics, the language presented here contains only module and type expressions as fields of struc\u00adtures. \nUnlike SML, structures have no identity in the language to be discussed. Hence. sharirw of structures \nis not allowed. Only sharing of types i s allowe~. As a specification of shar\u00ading, S ML allows equating \narbitrary paths. As discussed in [1 I], this immediately prevents a syntax-directed translation of a \nsynt attic signature into its semantic representation. In\u00adstead, the translation has to be specified \nas a proof system for which it is necessary to prove the property of principal\u00adity. In this paper, we \nwould like to present a new semantic representation for the elaboration of functors. Sharing is at\u00adtained \nin our language by assigning fields in a signature to a path name. Such a specification allows a simple \nsyntax\u00addirected translation of syntactic signatures to their seman\u00adtic counterparts. This restriction \non sharing specifications is merely for the purpose of exposition: it gives a simpler translation, while \nretaining the expressive power of the con\u00adstraints, Accommodating sharing constraints as in SML, is merely \na matter of changing the translation algorithm: an issue really orthogonal to the subject of our presentation. \nAs pointed in [2], having internal a-convertible names for fields is especially convenient, when sharing \nis obtained by explicit assignment. This is overlooked here, as this has no effect on the semantics. \nThe language is defined by the grammar below. It is assumed that the fields in a signature body S , or \na structure body s are all distinct. Type Expressions: ::= int Ibool /T + T Ipath Paths:r path ::= t \n/ z.path Signature Components: SC::= type tItype t = r Imodule x :Sig Signature Body:  s ::= SClsc; \ns Signature: Sig ::= sigsend funsig(x : Sigl Sigz Structure Components: ::= type t= r raodule z = m \nStruct~re Body: .. .. SClsc; s Modu~e Expressions: m ::= x I m.x I m~mz I structs end I functor(f-: SZg) \nm I m : S2g 3.2 Semantic Representation of Signatures The semantic representation of signatures is similar \nto [9], with appropriate extensions for higher-order functors, and appropriate simphfications for the \nabsence of equality be\u00ad tween structures. Mod = StrEnu + Func (TE, M$ g StrEnu ~ TypEnv x ModEnv TE E \nTypEnv z TypId ~ Type  ME c ModEnv E ModId Z Mod Vs(z * 72) E Func B NameSet x Mod x Mod Notation: \nX ~ y, is the set of all partial functions from domain X to co-domain Y, where every function is defined \non a finite subset of X. TypId, ModId, NameSet are domains of the set of iden\u00adtifiers/variables. In \n[9], variables are used in the semantic represent a\u00adtion exclusively for types and stamps: structure \nidentifiers, which are abstracted away at compile-time. When functors are passed as arguments, the argument-to-result \ndependency present in the functor is not known, but needs to be prop\u00adagated. These dependencies are expressed \nby higher-order variables in the semantic representation. Definition: TC Type is defined by the following \ngrammar, Type ::= Typeatom I Typel + Twez Type tom ::= intlbool [xl.f(Hl, . . ..~~) H ::= Type IAx. H \nIH1 H2 where ~, x are variables Type ~tom denotes the set of atomic type expressions. Definition: The \natomic subexpressions of a type T, ASExp(T), is a subset of Type atom defined as fo~ows, {T} if T E Typeatom \nASExp(Tl ) U ASEXP(TZ ) if T = TI + T-J { A syntactic signature Z, as defined by the grammar Sig, is \nrepresented as a semantic object T E Mod. ' X s sig S end, is represented as (TE, ME) c StrEnv, with \nits type components generating an environment TE and its module components generating an environ\u00adment \nME. ' Z s f unsig(x : El) X2, is represented as VS(Z + Z) c Func.  Every signature E has a unique semantic \nrepresentation as defined by a syntax-directed translation function &#38;[]. Notation: ' VarList denotes \nthe set of lists of variables. ' Env is a partial function, with finite domain, from the set of variables \nto values, which are either elements of Type or Mod. ' For any two environments El, Ez E2(x) if Ez (x) \nis defined El u Ez(x) = El(x) if El (x) is defined undefined otherwise { ' 11CNz, is the list formed \nby appending two lists 11 and 12. S[] : Sig ~ Env + VarList ~ Mod x VarList &#38;L~] : S ~ Env + VarList \n+ ( TypEnvx ModEnv)x VarList &#38;c[] : S= ~ Env ~ VarList ~ ( TypEnvx ModEnv)x VarList ~[sig Send] r \nw = :L[S] r w t~[S.] rw = ~c [S.] rw tL[Sc; S]rw = let ((TE1, ME1) , VI) = &#38;[S~] r w ((TE2, MEz) \n, V2) = ~LISl ruTEluMEl ~ in ((TEI u TEz , MEI U ME2) , v1@v2) ~~[type t] r w = ((t w f(W) , 0), {f}) \nwhere j is a completely new variable. &#38;C[typet =r] r w = ((tw ~T_jr, 0) , 0) where [r]r merely replaces \nall free-variables and paths in r by their values in the environment 17. &#38;C[modulex : Z]r vv = let \n(T, Vl) =tlJUJ r w in (( O,x+T), VI) The following example illustrates the concept: ~[funsig(X: sig \ntypet end)sig type s end]O[l = (Va(({t w a}, 0)+-({s* f(a)}, 0)) , [f]) The idea being that, in the synt \nattic signature the depen\u00addency between t and s is not known statically. But the dependency can be abstracted \nby a function variable j. 4 Static Semantics 4.1 Elaboration Rules The rules for elaboration of structure \nexpressions in the lan\u00adguage are presented in Figure 1. The critical set of rules here are the signature \nmatching rules, (4) and (5), because they involve a substitution. In the presence of higher-order variables \na most general substitution does not exist,2 and 2For example, if .f int = int then both .f/(kc. int) \nand f/(Az. c) are valid substitutmns. (1) r} m :(TE, ME) r I-m.x : ME(x) (2) r,f:%l-m:% where (71 , \nV) = &#38;[Z] r [1 (3) r t-functor(f : Z)m : W(Z + %) (4) rl-m :?_ (17 DT, Z, Vu@) where (Z, V)= SID]r[l \n(5)I +(m:Z):@(?i) (6) 17E struct send : T (7) r 1-typet=r : ({t I+[7]r},0) (8) I 1--m:T (9) .rI-ruodulez=m: \n(0, {x++ 7}) Figure 1: Rules for Elaboration there is no decidable algorithm for matching. But we subse-then \na functor of signature quently show that all our terms are in a particular syntactic funsi.g(x : si-g \ntype t end) form for which a most general unifier exists. The terms are (sig type t = X.t end) in the \nformat required for unification in LA, [8]: variables, would do as well. for which substitution is required, \nalways take distinct uni\u00adversally quantified variables as arguments. If the J,l rela- Intuitively, the \nrelation (17 D Z, Tz, V J ~), where ~ istion is defined, by structural induction on terms, then the a \nsubstitution with domain V, is provable when @(Tz ) is entire semantics becomes completely definitional. \nA pro\u00admore general than 71, by criteria to be described. r is a grammer has some intuitive notion of \nwhat subsumptions necessary parameter in the relation U, as @( T2 ) and TI must are valid. In a completely \ndefinitional semantics it is diffi\u00adbe closed wrt the set free variables in range(r). In the formal cult \nto analyse whether the semantics manages to capture definition of the l,!-relation, 17 is replaced by \nA, where A isthese intuitions. So instead we capture these intuitions as the set of free variables in \nrange(r). specifications. Then we go on to show that there is precisely a unique substitution which satisfies \nthese specifications and Definition: A D ~, T2, V JJ @ iffthis unique substitution may be computed by \na simple al\u00adgorithm. ' The domain of ~, I@/ = V, The intuitive notions of subsumption for a programmer \nare: ~nV=O. o Record Polymorphism: If structure Z has an extra e TI , @ are closed wrt A set of fields \nover another structure 72 then 25 is more general than ~, TI <72. o 72 is closed wrt (A U V) and Fu(T2) \n A = V. e The subsumption relation <, as defined in Figure 2, is ' Functorial Polymorphism: This is \na new kind of poly-broken structurally into components <T and <~. <T defines morphism found in higher-order \nfunctors. The concept subsumption on TypEnv and <L defines subsumption on is best illustrated by an example. \nIf a certain context ModEnu. For convenience, environments are assumed to be expects a functor of signature: \nlists sorted by field names. To prevent capture of variables funsig(X : si.g type t= int end) on a substitution, \nby the binding constructs in the language, (sig type t= int end) it is assumed that variables bound by \nV, A are distinct from A D TEI <z-TEZ A D MEI <L M132 (1) A D (TE,, MEI) < (TEZ, MEZ) AD{} +L{} (2) \nA D ME1 <L M132 (3) A D {(z w T), MEI} <L ME2 AD~<LT2 AD ME1<LME2 (4) A D {(x w Z), MEI} <L {($ H ~), \nME2} AD{} <~{} (5) A D TE1 <T T13z (6) A D {(t -T),TE1} <T TE2 A D TEI <T TEz (7) A D {(t+ !I ),li71L} \n<T {(t++ T),TE2} AuVjDL?_~,~ ,V~ U @ AuVjD@ [~ ]<7~ (8) A D VVj(~ s ~) < VVJ(~ * T:) Figure 2: A proof \nsystem for subsumption each other and from the free variables in the environment. type s = bool ; The \nsubsumption relation < captures the intuitive notion of t~~e t = int; subsumption. end Rule 8 is the \nonly non-trivial rule in Figure 2. It cap\u00adtures both functori~ Dolvmor~hism and co~travariance in module \nH = G X functors. To prove V~~ (~ + ~ ) < VV~(T~ ~ T;), it is necessary to prove T < .T~ , where T is \nthe result of the elaboration of the application of a functor of semantic sig-The program given above \ndoes not have modules as com\u00adnature VV~ (T{ + T:) to a module of semantic signature ponents of structures \nanywhere, so for reasons of readabil-T;. ity the empty sets denoting ModEnv are deleted. Hence, a It \nis important to notice that we only have a specifica-structure ({t * int}, 0) is replaced by {t w int}. \ntion of the U relation. This specification does not provide an algorithm to compute the relevant substitution \n~. Any [APP] = Vf( Va({t I+ a} ~ {s ++ f(a)}) substitution @ which satisfies the subsumption rules is \na + Vb({ t w b} * {S f(b)})). w valid substitution. In the section 6, we prove that there is [F] =Va({t \nw a} + {s + (a+ a)}). a unique substitution which satisfies the U relation for any As ( D [F], Va({t \nI+ a} ~ {s * f(a)}), {f} u program which elaborates. {f/As. a + a}), [G]= Vb({t *b} a {S I-+ (b+ b)}). \n 4.2 An Example [X] = {s+ bool, t + int} Consider the following program: As ( D [X], {t i+ b}, {b} I.1 \n{b/int}), [H] = {s + (int + int)} module APP = f unctor (F : funsig (X : sig type t end) sig type s end) \n5 Well-Formedness of Semantic Representations functor(X: sig type t end) (F X) The grammar for the semantic \nrepresentation includes themodule F = f unctor (X : sig type t end) entire simply-t yped ~-calculus. \nHence, as discussed in [4],struct in general the substitution ~, involved in the subsumptiontype s=X.t \n-> X.t process, may not be computable and may not be unique. end But all semantic representations appearing \nin the elabora\u00adtion of a term come from a very restricted subset of themodule G = APP F defining grammar. \nIn thk section we characterise this re\u00ad stricted subset of semantic representations by a predicate. \nmodule X = struct In the next section, we show that for representations be-Well-formedness of a functor \nsignature VV(TI + TZ ) wrt longing to this restricted subset, the substitution ~ in the J,l A, is more \ncomplicated. We require ~(~z, A U V) and also relation is unique and computable. ~(Z, V,[l, A, O). Because \nof the presence of higher-order variables, it is necessary to prove that at no point does normalisation, \naf-Note: ter substitution, fail because an attempt is made to apply 1. It is assumed that free variables \nin p are kinded. If a non-function value to a value. To prove this, we need to V, W, A, p have variables \nin common then they have introduce kinds. It is to be kept in mind that kinds are ar\u00adthe same kind. tifacts \nintroduced to get a simple formulation and proof of the statement: no errors occur during normalisation \nafter 2. Both the predicates are monotone in the A component. a substitution. The changes, mentioned \nin this section, to functions like &#38;, and the elaboration rules, are merely for 3. If S(T, V, W, \nA,pl Upz) then purposes of proof. The actual implementation remains un-S(T, V, W, AU F W(P1), P2) kinded. \nT E Type is considered to be of kind o, the only base kind in the system. From hereon, all variables \nare con-4. If s((TE, ME) , v , w , A , p) then ~at(TE, ME) is sidered kinded. Binding constructs, V and \n~, are assumed given by the following grammar: to bind kinded variables. The translation function for \nsig-TO ::= Tato~ where Tatom of kind o is closed w.r, t natures has the type, A and kind-correct I f(W) \nwhere f = V and f(W) &#38;[] : Sig + Enu ~ VarList -Mod x VarList is kind-correct of kind o It wheret~p \n As mentioned, VarList in the result now needs to be a kinded list of variables. To achieve this, only \none modification is Lemma 5.1 If G(T, A) then T is closed w.r. t A and kind\u00ad required in the definition \nof 8: correct. If S(T, V, W , A , p) s.t p is kind-correct, ~c[typet]r~ = ((twf(W), O), [.f:kl*. ..*kn~ \no]) then G(T, AU ~U~U Fv(p)). where W -[jl : kl, ....j~ : kn] and .f is a completely new Proofi By induction \non the structure of T, applying the variable. observations made in the note above. 0 The inference rules \nfor the static semantics now carry another parameter A, along with r. A is the set of all free Lemma \n5.2 lf Z[Z]r w = (T, V), W ~ Fv(I ) and variables in 17, with their associated kinds. Calls to the .lJ \n~(17, A) then S(T, V, W, A, 0). relation now use A instead of 17. All rules merely propagate A, except \nRule (3), the rule for functor definitions. Proofl The proof is an immediate corollary of the following \nlemma: Au V,(17, f: Z)t-m:Tz where (Z , V) = Z[Z] r [1 If~[Z]r w = (T, V), where W ~ I%(J7) and pr = \nAat(r), A, r K functor(~ : Z)m : VV(Z + 72) then S(T, V, W, 0, pr) and I%(T) l?v(I ) = V. 0 Lemma 5.3 \n(Substitution Lemma)Definition: Aat(lT) defines the set of Accessible atomic type expressions in T E \nMod: 1. If G(T, A U V) and ~ is a well-kznded and closed sub\u00adstitution w.r. t A, s.t. 1~[ = V, then \n~(tj(~), A). 2. If S( .T, V, W, Auci, p), s.tan(V UWUAU  ' Aat(VV(fi a 72)) = 0 ' &#38;t(TE~{tl xT1, \n. . ..tm Tin}.}, Fv(p)) = 0, V n A = 0, and @ is a well-kinded ME={sl~z ,.. .,sn*7n})= and closed substitution \nw.r. t A, st 1~1 = CY, then ~~y AS~wVJ) u LE Aa~(Z) S(@(T), V, W, A, p). To specify the well-formedness \nof semantic representations, 3. If S(T, V, W, A, {.fl(w]),..., ~n(wn)} U P) St. two recursive predicates \n~ and S are defined in Figure 3. W, CA, f,@ VU WuAUFv(0), A nV= il and P(X) for any set X denotes the \npowerset of X. 4 z {f,/~W, t,}, zs a well-kmded and closed substi- A semantic representation T is well-formed \nwrt a set tution w.r. t A, then S(@(T) , V, W, A, p). A, if ~(T, A). A structure T, without functor \ncompo\u00adnents, satisfies the relation G(T, A), if all the type compo- Proofi By induction on the structure \nof T. 0 nents in T are closed and well-kinded wrt A. We can give a precise characterisation of a semantic \nrepresentation T ob-Theorem 5.1 (Well-Formedness Theorem) tained from the translation of a syntactic \nsignature Z, wrt Let C be a proof of A, II 1-m : T, where G(r, A). If every an environment r and a set \nof variables W. The elabora\u00ad occurrence of the J.!-relation in L inuolves a closed and well\u00adtion process \nmerely modifies these semantic representations kinded .mbstztutionj z.e. for everg (Ao D Z, ~2, Vo Jj \n@o) in by instantiating variables bound by universal quantifiers. If L, $, is closed and well-kinded \nwrt Ao, then ~(~, A) S[X]r w = (T, V) then we can always define a predicate such that (T, V, W, r) satisfies \nit. But if r is replaced by its Proofi The proof is by induction on the height of the proof corresponding \nA, i.e. the set of free variables in the range tree. A more general version of the proof is incorporated \ninto of r, then for book-keeping reasons we need to introduce the proof of Theorem 6.3. !3 another parameter \np, a set of atomic type expressions, in the predicate. This is the predicate S defined in Figure 3. ~ \n: Mod - P( Var) ~ Bool S : Mod -+ P( ~r) - VarLZst ~ P( Var) ~ P( l gpeato~) + BOOl ' ~((TE, ME), A) \nif @( TE, A) and GL(ME, A), where L% ( Typld i+n T, A) iff T, of kind o, is closed GL({m*l i, ..., Xn \n+ Tn}, A) iff Vi. ~(~ -c7(VV(Z +-Z), A) iff s(fi, V,[], A,O) and ~(Z, AUV) w .r.t , A). A and kind-correct, \n' s((TE, sT(TE, ME), v,w, V, W, A, A,P) P) and iff sL(ME, V Fv(TE), W, A, pU {~(W) [ ~ c V and ~(W) \nE ASESP( I E)}) where ST( Tgpld +n TO , V, W, A, p) iff TO ::= T where T of kind o is I f(~) wheref EV \nand It wheret Ep lTo~To closed ~(W) w .r .t A and is kind-correct kind-correct of kind o and S~((x+T); \nME , V,W, A ,p)iff S(T, V, W, A,p) and S.(ME , V Fv(T), W, S(VVl(fi +Z), V, W, A,p)iff S(Z, V1,[I, A,P) \nand s(2z, v, A, p U {j(W) WQV1, AU V1 I ~ ,0) E V and ~(W) E Aat( T)}) Figure 3: Well-Formedness Predicate \n~ 6 Uniqueness of Elaboration unfolded to specify a single relation 1, broken down struc\u00ad turally into \nJT and JL. In the J. relation, as defined as Fig-The J)-relation is presented as a specification. Hence \nif we ure 4, the substitution @ is applied only in the leaves of the can prove that there is a unique \ncomputable substitution proof tree: looking at the proof backwards, we may say that satisfying the J.!-relation, \nthen proof of the deterministic na-amlication of the substitution is delayed to the leaves. The ture \nof tie elaboration is complete. This is because the other r~l~tions JJ and < were specified wrt a-single \nenvironment A. rules for elaboration of a term in the language are syntax-For the specification of j, \nA is partitioned into disjoint sets directed, hence completely deterministic. AI, Az. From rule (9) in \nFigure 4, it is seen that only vari\u00adables from Az can be introduced as bound variables in the Lemma 6.1 \nLet (A D ~, Tz, V J,!-$). 1 V is partitioned semantic signature. Again, looking at the proof backwards, \ninto two disjoint sets V1 and V2, st V = VI U V2, @l = VIvl since the application of the substitution \n@ is delayed, while and 42 = @lv2 then (A D 71, $1(72), V2 u 42) we enter scope of bound variables, we \nneed to ensure that the co-domain of @ is disjoint from the bound variables: to Proofi By definition, \nif (A D Z, 72, V U ~) then A avoid capture by binding constructs. Thus such a partition and V are disjoint, \nand @ is closed wrt A. Hence @(T2 ) = of A, into Al and Az, the set of free and bound variables, +2 (dl \n(72)), because the co-domain of the substitution *I is is essential disjoint from the domain of @z. Thus \nA D Z < 42(41 (%)). As mentioned in Section 4.1, the Q relation is specified 0 by a set of conditions \nand a proof system for the < relation to be used after the application of the substitution +. In The \nstrategy for proving the uniqueness of the substitu\u00ad the specification of the J. relation the substitution \nis held tion @ in the .lJ-relation is to do so incrementally. Let back. Hence these side conditions must \nbe true for every (A D Z,%, V U 0). Let V be partitioned into two disjoint tuple (Al, Az D 71, Tz, V \nJ. ~) in a valid proof. sets V1and VzstV= U UV2, @l= @lvl and 42 = ~lvz. We first prove that 4 I v, is \nunique and therefore must nec-Definition: [Valid Proofs] A proof is considered valid if essarily equal \n@l. But by the above lemma, we also have for every tuple (AI, Az D 71, TZ, V J +) in the proof, the (A \nD Z, 41(%), M J.!-42). We next prove that +2 is following holds, unique. Hence we have proved that @ \nis unique. ' 141 = V and ~ is closed wrt Al. 6.1 A modified proof system for subsumption '(AI UAz)n \nV=O. Because of functorial polymorphism, it is seen that the re-' ?i is closed wrt (Al U Az ) and Tz \nis closed wrt (A] U lations U and < are mutually recursive. This recursion is A2u V). Alt Aj D T131,TE2,V1 \n}~ d] AI,Az D ME1,41(ME2), V2 lL @2 (1) AI, A2 D (TE1,ME1),(TE2,ME2),V1 UV2 1 #I U+2 A,, A2 b {}, {},0 \nJL0 (2) AI, A2 D ME1,ME2,V JL @ (3) Al, A2 D {(zI+Z),ME1},ME2,V lL @ AI, A2 D 7i, T2, V1 ~L d] A1,Az \nD ME1,41(ME2),V2 lL 42 (4) AI,AJ D {(z i-i Z), ME1}, {(Z E-+ 7z),ME2},V1 UV2 lL VI UV2 AI, Az D{}, {},@ \n1~ @ (5) T1 = @(T2) (6) A1, A2 D {(t+ Tl)}, {(t+ T2)}, v 1~ @ A,, A2 D T12,,TE2,V ~~ @ (7) Alj Aj D \n{(t*T),T131},TE2,V ~~ @ AI,AZ D {(t w Tl)}, {(t w Tz)} 1~ ~1 A1, A2 D TE1 , @l( ?i 132), V2 1~ 02 (8) \n Al, A2 D {(t I+ Tl), TEl}, {(t~Tz), TEj}, vlu V2 1~ d] U02 A, UA2UVZ,0 D Z ,Z ,V1 1 # AI,Az uV2 D #(~ \n), ~ ,V J @ (9) A1, A2 D VVl(~ + ~),VV2(~ + v), V 1 @ Figure 4: A modified proof system for subsumption \no l%(T2) (Al UA2) = V. By Theorem 6.1, it is also an algorithm for computing @ associated with the .J,l \nrelation. Similar side conditions must hold for, Theorem 6.2 (Unique Substitution Theorem) (A1, A2 D \nhfE1,kfEz,V lL 4) and If ~(Z,Al U Az) , S(TZ, V, AZ, A1 U Az, O) where (Al U (AI,AJ D TE1,TE2,V LT v). \nAz)nv = 0, and (34 A1, Az D Z, T2,V 1. V) then It should be noted that the definition of valid proofs \nis svmmetric wrt Al, A2 except for the fact that the substitu\u00ad (~ !0 [Al, A2 D Z,%, V 1 $], where $ is \nweil-kinded). t~on @ must be ci;sed-wrt Al. Proofi The proof is an elaborate induction on the height \nThese side conditions ensure that the partition of the V of the derivation of (Al, AZ D T, Tz, V J @). \n component, in a valid proof, into VI and Y2 is unique in We incrementally prove the substitution @ to \nbe unique and Rule (l), Rule (4) and Rule (8). well-kinded. Let A = AI U A2, We only discuss Rule (6), \nas this rule defines the substitution, and Rule (4), as this Lemma 6.2 (Ao U A1,Az D ~, T2, V J +), where \n@ zs shows how assumptions propagate: closed wrt A? . has a valid m-oof iff (A,, Ao uA~ D Z, Z,V j $) \nh &#38; a ualidproof. (6) By assumption, 6 2 ({(t w Tl)}, A) and s~({(t ~ TZ)}j V, AZ, A, O). Proofi \nThe proof is by induction on the height of the proof Hence T1 is closed wrt A. By the definition of ST, \nTz tree. 0 is generated by the grammar, TO ::= T where T of kind o, is closed Theorem 6.1 If ~(~,A) , \nS(T2, V,[], A,0) where (A n w.r.t A and kind-correct V) = 0then (A D Z ,T2,V U @) ifl there exists \navalid I f(A2) wheref G V and ~(Az)proo~of(A,@DZ,~,Vl@). is kind-correct, of kind o [ To~To tree and \nan application of Lemma 6.1 and Lemma 6.2. 0 A variable ~ in the domain of the substitution occurs only \nin atomic type expressions f (A2 ) I roofi The proof is by induction on the height of the proof 6.2 A \nproof of unique elaboration ASEzp(T2). The premise of this proof is, T1 = 4(T2 ). Given A1, A2, {(t w \nTl)}, {(t + T2)} and V, if we can The equality is a structural equality on a single in-fix compute a \nsubstitution @ such that T1 = @(Tz) and the binary constructor, +, i.e. the parse trees of T1 and tuple \n(AI, A2, {(t t..-+ Tl)}, {(t w T2)}, v,@) is valid, then ~(Tj ) are identicaL Hence, if T is the type \nsubexpres\u00adtlhe proof system in Figure 4, is essentially an algorithm for sion in T1 that corresponds \nto f (A2 ), at the leaf of the computingthesubstitution associated with the J relation, parse tree of \nT2, then T = ((~ ~) A2 ). Let Az The normal form of +(~) The author conjectures this to be true. But \nin this extended mUSt be~A~) Y ]. . . . Xn. T ). Because of the validity system the order in which fields \nof a structure are matched condition, t(~) is closed wrt Al. Hence T must will be significant. be closed \nwrt Al U {xl,... ,z~}. As Az is a list The presentation in this paper provides a simple static of distinct \nvariables, ((~ ~) AZ) is essentially a re-semantics for higher-order functors, with transparent signa\u00adnaming \nsubstitution, ~zl /yl, . . . . z~/vn}, on T . Thus tures, for languages which do not possess features \nlike gen\u00ad{XIIY1,..., X?2 / WI }(T) = T. Since T does not con-erativity. It is shown that in the absence \nof generativity, the tain variables from A2, ~(f) must be (AAz. T). This semantics of higher-order functors \ncomes very close to the is a kind-correct substitution. semantics of first-order functors in SML. (4) \nBY assumption, g~({(x * Z), ME1}, A) and Acknowledgements SL({(Z-72), ME2}, v, A2, A,0). By the conditions \non a valid proof, VI = lb(%) A The author is grateful for technical and editorial help fromand Vz =V \nV1. Let +1 =@lvl and 42 =41v2. Carl Gunter. By induction, *1 is unique and well-kinded. AS SL(MEZ, Vz, \nAz, A, {.f(A2)l.f E References V2 and f(Az) E Aat(T2)}), by the Substitu\u00adtion Lemma, SL(@l(MEz) , V2 \n, Az , A , 0). Since [1] L. Cardelli and X. Leroy. Abstract types and the dot ~L(MEl, A), by induction, \n42 is a well-kinded sub\u00adnotation. Research Report 56, DEC Systems, Palo Alto,stitution that is unique. \nMarch 1990. u [2] R. Harper and M. Lillibridge. A type-theoretic ap-Theorem 6.3 (Unique Elaboration \nTheorem) proach to higher-order modules with sharing. In H.\u00adI.(r+m: 7), where 3A. G(r, A), then T is \nunique J. Boehm, editor, Conference Record of the Twentgfirst and ~(T, A). Annual ACM SIGPLAN-SIGACT \nSymposium on Prin\u00ad ciples of Programming Languages, ACM, 1994. Proofi The entire proof of (r 1-rn : T) \nis syntax\u00addirected, hence completely deterministic. Hence to prove the [3] R. Harper and J. C. Mitchell. \nOn the type structure uniqueness of T, it is only necessary to show that whenever of Standard ML. ACM \nTransactions on Programming the Q relation is used, the assumptions associated with the Languages and \nSystems, 15:211-252, 1993. Unique Substitution Theorem hold. It is for this reason we [4] G. Huet. A \nunification algorithm for typed A-calculus. prove the clause ~(T, A). The following non-trivial cases \nTheoretical Computer Science, 1:27-57, 1975. are considered here: [5] X. Leroy. Manifest types, modules, \nand separate compi\u00ad(3) We need to prove ~(VV(~ ~ ~), A) i.e lation. In H.-J. Boehm, editor, Cora~erence \nRecord of theS(fi, V,[], A, O)andg(Z, AU V). Twenty first Annual ACM SIGPLAN-SIGA CT Sympo-By Lemma 5.2, \nS(Z , V, [], A, 0). Hence, by sium on Principles of Programming Languages. ACM,Lemma 5.1, G(Z, A U V). \nThe induction hypothesis is 1994. now applicable, hence, 72 is unique and f.7(Tz , A U V). [6] D. B. \nMacQueen. Using dependent types to express(4) By induction, ~(VV(~ + ~) , A) and L7(T, A). modular structure. \nIn C. N. Fischer, editor, SymposiumThus, by definition, S(T1 , V, [], A , 0). We can now on Principles \nof Programming Languages, pages 277 apply the Unique Substitution Theorem to obtain the 286. ACM, 1986. \nunique @ st, (A, O D T, 71, V 1 +). Since t is closed and well-kinded wrt A, by the Substitution [7] \nD. B. MacQueen and M. Tofte. A semantics for Lemma, ~(@(~), A). higher-order functors. In European Symposium \non Pro\u00adgramming. Lecture Notes in Computer Science vol. ??, (5) By induction, G(A, T). Since (Z, V) \n= &#38;~Z]rIl, by Springer, 1994. Lemma 5.2, S(Z , V, [], A, 0). We can now apply the Unique Substitution \nTheorem to obtain the unique [8] D. Miller. A logic programming language. Journal of @ st, (A, 0 D T, \nZ , V ~ +). By the Substitution Logic and Computation, 1:497-536, 1991. Lemma, ~(~(~), A). [9] R. Milner \nand M. Tofte. Commentary on Standard ML. 0 The MIT Press, 1991. [10] R. Milner, M. Tofte, and R. Harper. \nThe Definition of Standard ML. The MIT Press, 1990. There are two important directions for future research \nasso- Conclusion [11] M. Tofte. Principal signatures for higher-order programciated with this approach \nto providing semantics to higher\u00admodules. In A. W. Appel, editor, Conference Record oforder functors. \nThe first one being, by considering gerwym the Nineteenth Annual ACM SIGPLAN-SIGA CT Sym\u00adas a primitive \nfunction and introducing environments, can posium on Principles of Programming Languages, pageswe capture \nsome form of generativity in the language ? The 189-199. ACM, 1992. second concerns parameterized types. \nSML allows declara\u00adtions of parametrized types. The question to be answered here is, can we incorporate \nparameterized types into our system and still retain the principal substitution property?   \n\t\t\t", "proc_id": "199448", "abstract": "<p>The programming language Standard ML provides first-order <italic>functors</italic>, i.e. modules parameterized by modules. First-order functors in the language have a simple and elegant static semantics. The type structure of higher-order modules, i.e. modules parameterized by functors, is well understood. But it is only in the recent past that we have seen an implementation of higher-order functors with a formally defined static semantics in a dialect of Standard ML, SML/NJ. A study of this static semantics shows it to be much more complicated than the static semantics of first-order functors. This paper investigates whether we can trade some semantic features in the module language to obtain a simpler static semantics, closer in spirit to that of first-order functors. This work helps in a conceptual understanding of the semantics of higher-order modules.</p>", "authors": [{"name": "Sandip K. Biswas", "author_profile_id": "81100075444", "affiliation": "Department of CIS, University of Pennsylvania, Philadelphia, PA", "person_id": "PP14036684", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/199448.199478", "year": "1995", "article_id": "199478", "conference": "POPL", "title": "Higher-order functors with transparent signatures", "url": "http://dl.acm.org/citation.cfm?id=199478"}