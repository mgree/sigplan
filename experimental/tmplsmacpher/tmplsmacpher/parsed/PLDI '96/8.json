{"article_publication_date": "05-01-1996", "fulltext": "\n Simple Garbage-CoIIector-Safety HivzPJ Boehrn Xerox PARC boehm@parc, xerox. com Abstract. Accmservative \ngarbage collector can typically be used with conventionally compiled programs written in C or C++. Buttwosafety \nissuesmust reconsidered. First, the source code must not hide pointm horn the garbage collector. This \nprimarily requires stricter adherence to existing restrictions in the language definition. Second. we \nmust ensure that the compiler will not perform transformations that invalidate this requirement. Wearguethatthesametechnique \ncanbeusedtoaddressboth issues. We present an algorithm for annotating source or intermediate code to \neither check the validity of pointer arithmetic in the source, or to guarantee that under minimal, clearly \ndefined assumptionsabout the compiler, the optimizer cannot disguise pointem. We discuss an implementation \nbasedon a prepromsor for the GNU C compiler (gee),and give somemeasurementsof program slowdown. Garbage=Collector=Safety \nAutomatic garbage collection can significantly simplify program development It cart also help to isolate \nprogram erroxstoonemodule byhelping toensurethat nomodulecart invalidate a data structure maintained \nby another. Though it is hard to quantify this bertefi~ most expert guessesseem to place it in the range \nof 30-40%of program development time for programs that manipulate complex linked data structures (cf. \n[Rovner85J). Furthermore, in our experience, garbage collected programs tend to be based on higher level \nabstractions where appropriate, and thus tend to have fewer arbitrary restrictions on functionality (e.g. \ninput size limitations). Permissionto make digitabtwd copy of part or all of this work for pasonal orolassroomuseis \nrantedwithoutfeeprovidedthatcopiesarenotmade I or distributed for pro t or commercial advanta e, the \ncopyright notice, the title of the publication and its date appear, ant notice is given that copyingisbypermissionofACM,Ino,Toeop \notherwise,torepubtish,to ! postonservers,ortoredistribub toIisk, requrespriorspecificpermission andlor \na fee. PLDI 06 W96 PA, USA @ 1990 AcM o-as7el-7e5-Z7e610005...$505o Tracing garbagecollectors identifi \nall accessiblememory by starting at program pointer variables, and traversing all pointers through the \nheap, Conservative garbage collectors (cf. [Bartlett88], [BoehmWeiser88], [Rovner85], ~oehm 95]) can \ndo so even in the presence of incomplete information about pointer identity by treating any bit pattern \nthat might representtheaddressofaheapobjectasapointer. Thismay result in some extra memory retention, \nbut this is rarely significant mhrn93]. This approach enables garbage collectors to operate easily with \nconventional programming languages such as C and C++, and with minimal or no modification to existing \ncompilers. It has been used by many language implementations that use C as an intermediate code (cf. \n~ett89], [AtkinsonEtA189J, [Grnohundro91], [RoseMuller92], [SchelterBallantyne88J) , and it facilitates \ninteroperation between C and higher level programming languages. Although conservative garbage cdlectots \nrequire minimal cooperation from the compiler, they do require some to guarantee correct operation. For \nexample, a conventional C compiler may replace a final reference p[ i -1000] to the heapcharacterpointer \np bythesequence: P=P -1000; ,,. p[i], . . If a garbage collection is triggered between the replacementofp,andthereferencetop[i], \ntheremaybeno recognizable pointer to the object referenced by p. Thus such code is not GG@e. (Here we \nassume the existence of multiple threads of control. Similar examples cart be constructed if the collector \ncan only be invoked at function call sites.) Note that the fidarnental problem is not the way in which \np[ i -1000] is computed, but the fact that the original value of p is overwritten before the computation \nis complete. Thus the problem is to convince the compiler to preserve somevalueslonger than they appearto \nbeneeded,rather than to suppressspecific optirnizations. Similar problems may occur as a result of induction \nvariable optimization, or in the construction of a large constant address displacement on a machine that \nprovides only a small signed displacement field in machine instructions. Other examples can be found \nin [BoehmChase92]. Such problems are in fact extremely rare with existing compilers. Conservative garbagecollection \nis commonly used with conventional unmodified optimizing compilers, and to our knowledge, the above problems \nhave only been observed in examples contrived for the purpose. This is in strong contrast to conventional \noptimization bugs in production compilem Nonetheless we would like to be able to generate GC\u00adsafe code \nto gumantee safety of the approach. We would at least like to be able to point to a practical alternative \nin case such a problem is discovered. And we would like to defend against future clever optimization \nthat may increase the ftequency of such problems. For most compilers, it is possible to guarantee GC-safety \nby generating filly debuggable code. If the values of all logically visible variables are explicitly \nstored for debugging purposes at all program points, then they will also be available for the garbage \ncollector. Unfortunately, performanm considerations make such an approach (and some other solutions, \neg involving frequent uses of v 01 at i 1e variables) unattractive. Unfortunately, GC-safety is likely \nto introduce some runtime overhead, distinct from time spent in allocation and garbage collection routines. \n(See, for example, [OTooleNettles94], [DetlefsDosserZorn93], and [BoehmDemersShenker91] for some measurements \nof conventional collector overhead.) Since the problem is essentially never observed in practice, there \nis some argument that the introduced overhead should be very small with sufficiently good program analysis. \nIn particular all existing programs can theoretically be compiled on existing compilem asthey are now. \nHere we look at the performance of a rather simple, but decidedly imperfect analysis. Source Checking \nA related problem is that of checking that the original sourcecodeissafefor usewith agarbagecollector. \nRecall that the C language allows some arithmetic on pointers. However a value maybe added to a pointer \nonly if the result and the original pointer are addresseswithin the same object. Either may also point \none past the end of the object, which we handle by allocating all heap objects with at least one extra \nbyte at the end. We make some additional assumptions about the input program 1) No integers are converted \nto heap pointers. In fact, wnversion of a pointer to an integer and back, without intervening arithmetic, \nis benign, asis the common practice of converting very small integers to pointers that are never dereferenced. \nDisguised pointer arithmetic is not. Hashing on pointer values is no problem, since we effectively assumea \nnonmoving garbage collector. Our preprocessor issues warnings when nonpointer values are directly converted \nto pointers. It could and should also issue warnings when the same thing is accomplished by a cast between \ndifferent structure pointer types or the like. 2) Pointers are not hidden from the garbage collector \nby writing them to files and reading them back in, or by writing them to collector invisible (or misaligned) \nmemory locations. To our knowledge, this is possible in a strictly conforming ANSI C program only via \npointer input with either a scan f variant and %p format or with f re ad into a pointer\u00adccmtaining type, \nor with a call to memcpy or memmove with arguments whine types don t match, Thus this should be easily \ncheckable, though we currently don t do so. Thus the practical issue in checking the safety of a program \nis to ensure that the ANSI C requirements on pointer arithmetic are satisfied. Our main goals are to \nensure that no objects are prematurely collected, and that garbage collector data structures are unlikely \nto be overwritten. We restrict our attention to heap pointers, since that both ensures the first goal, \nand makes the overwriting of collector data structures much lesslikely. Our garbage collector provides \na facility for checking whether two pointers reference the sameheap object. Hence itsufficestocheckaftereachpointer \narithmetic operationthat the result still points to the original object. We argue below that the program \ncan be annotated with such checking calls in exactly the same manner as annotating it for GC-safety. \nIn fact, the checking calls ensure GC-safety, though not in a performance-optimal fhshion. Admittedly \nthe annotated program will incur a significant performance loss, at least without substantially more \nanalysis than we perform. We expect such checking to be performed only during debugging, by analogy to \nthe current useof systemslike Purify [HastingsJoyce92]. Our checking is not completely accurate, since \nthe garbagecollector rounds up object sizes. But it is sufficient to ensure that on a machine with typical \nRISC alignment restrictions at most unused memory can be accidentally referenced through an incorrectly \ncomputed heap pointer to a primitive type. It is currently still possible to reference or overwrite other \nmemory if C structures are accessedas a whole, e.g. if they are passed as parameters or assigned to other \nstructures. This could be remedied at minimal cost with the insertion of an additional check. Related \nWork We extend, refine and implement the work presented in [BoehmChase92]and [EllisDetlefk93]. Unlike \n[BoehmChase92] we start with the assumption that the garbage collector recognizes all pointers to the \ninterior of an object, not just to the tit byte of the object. Recent experience suggeststhat this is \nthe right framework particularly for typical C++ implementations which implicitly generate pointers to \nthe interior of an object. The techniques of ~oehrn93] can greatly reduce the danger of space leakage \nthat we previously associated with this approach. This new assumption greatly simplifies our task. Unfortunately, \nit also usually invalidate assumption (A) of [BoehmChase92], so our correctness argument has to be different. \nAn approach even more similar to ours here is presented in [EllisDetJefk93],but not in agreatamount of \ndetail. There has been much work on the generation and representation of object and stack layout information \nby the compiler for the garbage collector, Recent examples include [DiwanMossHudson92] [Goldberg91], \nand [Fradet94]. The ideaistogeneratestaticinformation (eithertablesortraversal functions) to communicate \npointer locations to the garbage collector. Thus these techniques also introduce minimal overhead into \nclient code, while producing much more precise information for the garbage collector. (The overhead is \no!ten very similar to that described here, though the details will vary depending on the expressivenessof \nthe layout representation scheme.)The disadvantageaof such an approach are that it is hardtoaccommodatecodewritten \ninlanguagessuchasCor often code compiled by more than one compiler, table size and/or interpretation \noverhead may be a problem, and typically garbage collections must be restricted to only be triggered \nat specific interruption pointa. The last point may introduce other forms of overhead in some multithreaded \nenvironments. To our knowledge, none of this work addreasesthe issue of run-time overhead required to \nkeep pointers accessible, though [DiwanMossHudson92] doesdiscussthe necessityfor such overhead. There \nhave also been many proposals for completely source-level implementation of garbage-collection using \neither the C++ constructor/destructor mechanism or Ada 9X finalization . These typically greatly increase \nthe number of memory references necessary for pointer assignmentsor pointer variable creation. Hence \nthey are not performance competitive with conservative collectom, though the expense may be unavoidable \nin hard real-time environments ~eIson91]. There has been a substantial amount of work on safer C implementations \n(cf. [HastingsJoyce92], [AustinBreachSohi94], [JonesKelly95].) Most of these have concentrated on detecting \nerroneous memory accessea,not erroneous pointer or subscript arithmetic, Though the two are related, \nthe distinction is important. A common bug (sometimesreferred to incorrectly asa technique ) in C code \nistorepresentanarrayasapointer tooneelementbeforethe beginning of the array s memory. This fails in a \ngarbage collected system. It may also result in incorrect pointer comparisonson segmentedmemory machines. \nLike PurifY, but unlike [AustinBreachSohi94], our checked code uses the same data structure layout as \nunchecked code. Hence it is possible, indeed trivial. to use checked code with third party object-code-only \nlibraries, or with faster, unchecked modules. Our checked code is very similar in spirit to recent independent \nwork by Jones and Kelly [JoneaKelly95]. The major differences are that we do not check references to \nstatically allocated and stack memory, we use the garbage collector s data structures to determine whether \ntwo pointers referencethe sameobjecc and we take a different approach to inserting the checking code. \nThe garbage-collector-based check is probably somewhat more efficient, since it relies primarily on mapping \nany address to the beginning of the corresponding object, an operation crucial to the collector s performance, \n(Their fundamental data structure is a splay treeofobjmts, weuseatreeoffixedheight2describingpages of \nuniformly sized objects.) Hence both the allocator and collector are tuned to make such Iookups very \nfast. Since we use existing collector data structures, the checking can be implemented purely in a preprocessor. \nOur approach to inserting checking code is significantly different, in that we essentially treat pointer \noffset calculations as pointer arithmetic. This appears to result in better checking of structure accesses. \nCompiler Safety Problem Statement We are interested in compiling ANSI C [ANS189], minimally restricted \nas defined above, such that the object code resulting from a strictly conforming program is guaranteed \nto operate correctly with a conservative garbage collector, if we replace every call to the malloc, canoe \nand reallot fbnctions by corresponding calls to a collecting allocator, and remove all calls to free. \nWe refer to the machine stack, registers, and statically allocated memory as GC-roots. We assumethat \nthe garbage collector preservesevery object that is reachable by following pointem from a GC-root, and \npossibly through heap resident pointem. We assumethat the garbagecollector recognizesany address corresponding \nto some place inside a heap allocated object as a valid pointer. (Boehm95] satisfies these assumptionsin \nits default configuration.) It follows from our restrictions on C programs that every heap object that \nmay be accessedis accessibleby following a chain of pointers from program variables Some of these pointers \nmay point to the interior of the object they reference. We would like to guarantee that the generated \nobject code satisfies the same property at every program point. That is, there must be a path from the \nGC-roots, possibly through other heap objects, to every potentially accessibleheap object. In particular, \neither program variables or equivalent compiler temporaries, should be explicitly stored, possibly in \na machine register,aslongasheapobjectstheyreferto maybeaccessed. This suffices to ensure the correctness \nof a suitable conservativegarbagecollector. Returning to our original example of compiling the expression \np[ i -1000 ], our goal is to ensure that either the pointer p, or a pointer to someplace inside the array, \nis kept visible to the collector during the evaluation of the expression, even if p is dead after the \nexpression is evaluated. Note that this doesnot necessarilyinhibit any traditional optirnizations. It \nmay require another register to preserve the original value of p, and thus conceivably add register spill \ncode. (On machinea with only two operand instructions, it may also directly add a small amount of additional \ncode.) Our goal is to ensure that this property is satisfied with minimal effect on the quality of compiler \ngenerated code, and in such a way that it can be retrofitted to existing subsequently recomputing it. \nprogramming language implementations. We will describe our algorithm for ensuring garbage-collector-safety \nprimarily as a source-to-source transformation on C code. We use a source-to-source transformation both \nbecause it provides a convenient vehicle for explanation, and becausein the short term it appearsto be \nan interesting implementation strategy. It makes it possible to provide for the GC-safety of some compilers \nwithout altering the compiler at all. Since GC\u00adsafety is usually not an issue for unoptimized code, we \nexpect that our prepass will generally be used only in conjunction with the optimizer, and hence the \ntime required to run the prepassis lessof an issuein this context. We make the following assumptions \nabout the target compiler, in addition to the expectedcorrectnessassumptions: O) Every allocation call \nin the source results in a corresponding call to an allocation function in the object code. Every store \nor load to/from the heap in the object code corresponds to an access of or assignment to the corresponding \nobject in the source. (There may be fewer loadsandstoresin the objectcode.) 1) It must be possible to \ndefine a macro KEEP_LIVE(e,y), with the following semantica: KEEF_LIVl?(gy) evaluates to the value of \nthe pointer expression e, but with the added constraint that the value of the pointer variable y must \nbe visible to the garbage collector (i.e. treated as live) until the expression is completely evaluated, \nthat is until the value of e is visible to the garbage collector. We will augment the source program \nwith KEEPTLIVE expressionsto ensure that relevant pointem are kept wsible by the compiler. The useof \nthe word macro here should not betake too literally. The expansion may depend on the types of the expressionsand \ninvolve additional temporary variables. Since we can generate the expansion explicitly, it does not need \nto beexpressibleasaC macro. 2) The value of a KEEP.LIVE expression must be treated as opaque, in the \nfollowing sense:The value must be explicitly and continuously stored in either a GC-root or the appropriate \nheap object(s), provided the value is used directly (without intervening pointer arithmetic) in a dereference \noperation, or used as the second argument of another KEEP_LIVE expression. It must be visible to the \ncollector at all points between the evaluation of the original KEEP_LIVE and the final use. Thus, if \nwe have p = KEEP_LIVE(...): *q,.,, then the result of the KEEP.LIVE q = P; ... expression must be explicitly \nstored until *q is retrieved. However, the sameis not required for p = KE131_LIVE(...); q.= p + 4; ...* \nq..., since the value of p is not dereferenced dmctly, and the pointer addition might conceivably be \nsubject to optimization. We can force either p or q to be explicitly visible at alI times by writing: \np = KEEP_LIVE(...) ; q = KEEP_LIVE(p + 4, p); ... q .... Informally, KEEP_LIVE has two effects; it causeay \nto be kept live during the evaluation of e,and it causesthe compiler to lose all inforniation about how \nthe resulting value was computed, thus preventing it from discarding the value and One way to implement \nKEEF_LIVE(ey) is asa call to an external function whose implementation is unavailable to the compiler \nfor analysis, but which actually just returns its first argument. In all environments of which we are \naware, this will force the value to be stored explicitly (perhaps in a register), The value will continue \nto be explicitly available through a dereference or another KEEF_LIVE in the presenceof all standard \ncompiler optimization. This implementation of KEEP_LIVE is, of course, terribly ineffkient. More efficient \nimplementations are suggestedin [BoehmChase92],and one is described below. Our problem then is to annotate \nthe original expression by replacing anumber of expressionsewith KEEP_LIVE(e,y) in such a way that the \nabove rules guarantee that every heap object is accessiblevia an interior pointer chain from the time \nof ita allocation until its last access. We will assumethat allocation finctions return a result that \nis (treated as)the value of a KEEP_LIVE expression. In order to simplify the presentation, we will assumethat \nthe following kinds of expressions either return nonpointem or occur as the right side of an assignment \nto a local variable that is not assigned elsewhere in the same expression. In effect we assume that temporaries \nhave already been introduced, so that we can name the results of these subexpressions: 1) Pointer dereferences. \n2) Function calls. 3) Conditional expressions. We will refer to theseasgenerating expressions. Note that \nthe introduction of the appropriate temporaries at source level is slightly more complex than one might \nlike, but it is possible. We will also assume that the only pointer dereferences are in expressions of \nthe form *e, and dereferences occur as late as possible with an explicit * operator. The [ ] and -> operatom \noccur only inside an &#38; operator. Thus the expressions el[ ez]. z ( *e). xz, and e -> x have been \nreplaced by *a(ez[e2] .x), *&#38;(e -> xz) and *&#38;(e > x) respectively. We assume expressions of the \nform &#38;* e have been simplified toe. Again, for the purposes of the presentation, we will ignore some \ncomplexities that must be handled by a source level implementation. For example, we ignore the fact that \nthe C expression e -> x will not actually involve a dereference if the field xhas array type. An Algorithm \nWe inductively define BASl?.(e), for pointer valued expressionse,to bethe pointer variable from which \nthe value of e is computed, or NIL if there is no such pointer variable; that is we define BAS12(e) such \ntiat e and BASE(e) are guaranteedto point to the sameobject whenever epoints to a heap object. This is \nsomewhat complicated by the presence of the &#38; (address of) operator. Thus we simultaneously define \nBASEADDR(e) to be the possible basepointer for &#38;e. BASE(O) = ML BASE(X) = X if x is a variable and \npossible heappointer BASE(X=e)= x if x is a pointer variable BASE(X = e) = BASl?(e) if x is not a pointer \nvariable BASE(el += e2) = BASE!(el) BASJ3(e1-= ez) = BASl?(el) BASIZ(el ++) = BASIS(++ el) = BASF(el) \nBASHel --)= BASE(--el) = BASl?(el) BASE(el + ea = BASl?(el) whereezistheexpressionwith pointer type BASE(el \n-e2)= BAS12(e1) BAS~ei, e2)= BASE(e2) BASl?(&#38;el) = BASEADDR(el) BASEADDR(X) = NIL if x is a variable \nBASEADDR(e1[e2]) = BASE(el) if BASE(el) is not NIL BASEADDR(e1[e2]) = BASlZ(e2) if BASE(ez) is NIL BASEADDR(el \n-> x) = BAS33(ef) Note that BASE is not defined for generating expressions. Generating expressions as \nsubexpressions need not otherwise be considered, since they are assumed to fall into the first assignment \ncase. BASE is also not defined for expressions with [ ] or -> as the outermost operator, since they always \noccur inside &#38;, and hence only BASEADDR is relevant. BASEADDR is again not defined for generating \nexpressions,since they are not l-values, and thus their address may not be taken. (Pointer dereferencesare \nl-values, but have been transformed so they do not occur inside an &#38; operator.) Similarly BASEADDR \nis not defined for other expressions that are not l-values, such as expressions with &#38; as the outermost \noperator. Our algorithm is now simple to state: replace every pointer-valued expressionethat occursasthe \nright sideof an assignment or as the argument of a dereferencing operation, or as a fimction argument \nor resul~ by the expression K13ET_LIV13(e, BASE(e)). C increment and decrement operatorsaretreated asassignments. \nCorrectness This argument is of necessity informal, since a formal argument would need to be based on \nformal semantics of both C and at least some aspects of the target machine language. But we claim that \nit s sufficiently precise that given both of theseit would not behard to formalize. Define an object \nto be sourc~reachable if a pointer to the object can be produced by a sequenceof pointer dereferences, \nand (legal ANSI C) pointer addition operations starting from a program variable. We claim that there \nis no way to aczessa previously allocated object in a strictly conforming ANSI C program meeting our \nrestrictions if it is not source-reachable. We define an object to be GC-mxzchubfeif it can be reached \nby following a chain of addressesstarting with one storedinaGC-root, andsuchthateverysubsequentaddressis \nstored in the heap object referenced by the preceding one. Observe that any pointer value which according \nto the source semanticsshould be stored in a program variable or in the heap is explicitly stored either \nin the GC-roots or in the corresponding heap object until its final access. This follows from the fact \nthat all pointer values are generated by KEEP.LIVE expressions. Assume that at some point before the \nfinal aczessto object P, it becomesGC-unreachable. Consider the path to P along which the last accesstakes \nplace. Consider the first object Q in this path to become GC-unreachable. Since the last accessto Q has \nnot yet taken place, according to the preceding observation, a pointer to Q must be source\u00adreachable. \nHence it must have been generated by a KEEP_LIVE expression, and the result of this KEEF.LIVE expression \nwill be subsequently referenced. Hence it should be explicitly stored in a GC-root or in the preceding \nheap object along the chain. Thus we obtain a contradiction. Hence objects remain GC-accessible until \nthe final access. Since all accessesin the object code correspond to accessesin the source, it follows \nthat the object code cannot accesscollected objects. Optimization The above algorithm is somewhat deficient \nin several respects: 1. It inserts many unnecessaryKEEP_LIVE calls. There is clearlynoreasontoreplacetheassignmentp \n= qbyp = KEEP_LIVE(q, q). This isprimarily aproblem of compilation speedand compactnessof the intermediate \nrepresentation. Itcan be easily avoided by keeping track of whether or not an expressionresult is statically \nknown to be simply a copy of a value Iogimlly stored elsewhere. If it is, then condition (2) from the \ndefinition of KEEP_LIVE guaranteesthat there is no need to add the KEEP_LIVE. 2. Certain C expressionsare \ndifficult to transform at source level. In general, a pointer expression e++ should be transformed to \n( tmp 1 = &#38;(e), tmp2 = tmpl, *tmpl = tmp2 + 1, tmp2) before inserting KEEP.LIVE calls. But this should \nbe optimized to (tmp = (e), (e) = tmp + 1, tmp) if eis asimplevariable that might beregisterallocated,to \navoid forcing eto memory. This problem is very likely to disappear if the transformation is made on intermediate \ncode. 3. The choice of basepointer variables may significantly impact the optimization that can still \nbe performed by the compiler, Consider the canonical string copying loop in C: = P S;q=t; while (*p++ \n= *q++); After the above optimization, we would transform the loop to: while( *(tmpa = p, p = KEEP_ \nLIVE(tmpa+l, tmpa) , tmpa) = *(tmpb = q, q = KEEP_LIVE(tmpb +1, tmpb), tmpb)): This is correct, and really \nspecifiesthe sameoperations as the original, though lessconcisely. But it forces the values of p and \nq to explicitly appear in a register. This prevents the C optimizer from translating the pointer arithmetic \nback to indexed loads basedons and t, which is profitable on some machines that allow a free addition \nin the load instruction (eg. SPARC). A good heuristic appearsto be to replace basepointem in KEEP_LIVE \nexpressionsby equivalent, but lessrapidly varying basepointem, especially if those are likely to be live \ninanycase.With asmallamountofanalysiswecan generatethe following lessconstraining codeinstead: while( \n*(tmpa = p, P = KEEP_ LIVE(tmpa+l, s), tmpa) = *(tmpb = q, q = KEEP_LIVE(tmpb +1, t), tmpb)); 4.Sofar,alltransformations \naresafein amulti-threaded environment, with an asynchronously triggered collector. If weknowthatgarbagecollectionscanbetriggeredonly \nat procedure calls, the number of KEEP_L IVE invocations could often be reduced dramatically. Debugging \nApplications The above annotation scheme inserts a KEEP_LIVE call around every pointer arithmetic expression. \nIn order to check that a pointer never leaves the object to which it points, it suffices to ensure that \nthe expression (the fhst argument to KEEI_LIVE) always points to the same object as the base pointer \n(the second argument to KEEF_LIVE). (If we use a single KEEP.LIVE call around more than one arithmetic \noperation, the intermediate results may not be valid. But the equivalent program with KE~_LIVE callswill \nstill besafein the presenceof a collector.) Thus we can convert our GC-safety preprocessor to a pointer \narithmetic checker by simply replacing the KEEp_LIVE call with a function call that does the appropriate \nchecking. For example, assuming p is a character pointer, the expression p + 1 will be transformed by \nthe debugging mode preprocessor to (char (*)) GC+same+obj ((void *)((p+l)), (void *)(p))) Here GC_same_obj \nis a real fimction which takes the placeof KEEP_LIVE. It checksthat both argumentspoint to thesameobject \nandthereturnsthefirstargument, Sincethe definition of this function is not available to the compiler, \nThe call to GC+Same+ob j will simultaneously have the intended effect of the KEEF.LIVE call. Our pointer \narithmetic checking is not dependent on the exact type of a pointer. If we cast a s t ru ct A * to struct \nB * , accessesto fields of the resulting pointer will be checked to verify that they are within the allocated \nobject. (As mentioned above, the only possible exception at this stageis an accessto an entire substructure \nof B that is only partially within the allocated object. That would need additional checking code,) An \nImplementation We have built a GC-safe compiler for ANSI C (plus some GNU extensions) by writing a C-to-C \npreprocessor that annotates the input program as described in the previous sections. The output for GC-safety \nis initially specific to gee, i.e. the resulting code is safe only when compiled by gee. Gcc dependencies \nare highly localized, so it should be possible to accommodate other compilem in the future. It should \nbe possible to make the output in source-code-checking mode usable with any ANSI C compiler. The preprocessor \ncould conceivably be used directly with aC+ + implementation that first translatesto C. Or asimilar strategy \ncould be applied at the intermediate code level inside a C+ + compiler. We implement the KE EP_L IVE \nprimitive by taking advantage of gee s flexible syntax for inline assembly code, Assembly code can reference \nthe value of a C expression, which may be reque@ed to be available in a register or memory location. \nThus KEEP_LIVE generates an empty assembly code sequence, depending on both arguments,, It requeststhat \nthe first argument be assignedthe samelocation asthe result. Seebelow for details. Only optirnizations \n(1) and (2) from above are implemented. However we do expand certain C constructs, particularly increment \nand decrement operations, in more specialized ways than suggestedabove. For example, if p is a character \npointer, then in debugging mode the expression ++p is expanded to ((char (*)) GC+pre+incr(&#38;(p) , \nsizeof(char) *(+(l))))  Here GC_pre_i n c r is a function performing the equivalent of a pre-increment \noperation which also checks that the result pointa to the original object. Itishighly desirabletorunthispreprocessorbetweenthe \nnormal C preprocessor (macro-expander) and the C compiler. In this way arbitrary macros are handled correctly \nand the preprocessoris not normally visible during debugging. Hence KEEP_L IVE is not generated as a \nmacro call; instead its expansion is generated directly. Our preprocessor maintains a copy of the input \nfile (including the source line information generated by the C preprocessor). It parsesand partially \ntype-checksthe source. In the process it generates a list of insertions and deletions, sorted by character \nposition in the original source string. After paining is complete, the insertions and deletions are applied \nto the original source. The yacc/bhon grammar and scannerwerederived from their gccequivalents. We do \nnot actually transform dereference operators as described above. Instead we defer generating KEEP_LIVEs \nuntil enough of the context has been seen to determine the correct transformation. This again introduces \ncomplexity which is solely the result of the source level implementation, and wouldn t be necessaryif \nthe transformation were done at a lower level. We have not attempted to tune the performance of the preprocessor \nto reduce compile time. But for our purposes that hasn t been a significant issue. (In fact we have yet \nto compile the preprocessor with optimization enabled or assertion checking disabled.) It should be much \nfaster than the rest of the compilation process,and certainly is no slower. Performance We meaaured a \nsmall collection of small-to-medium\u00adsized C programs, mostly drawn from the Zorn benchmark suite[DetlefkDosserZorn93]. \nAll of these programs are very pointer and allocation intensive. Standard C libraries were not preprcxxssed. \nThis is probably not unrealistic since the critical pieces are likely to be either hand assemblycoded, \nor manually checked for GC\u00adsafety or, fhiling that thoroughly tested for GC-safety of the normalJy optimized \nversion. The programs measured were: cordtest: 5 Iterations of the test normally distributed with our \ncord string package. This wasrun with our garbage collector. The string packageand the test program were \nprocessed. No part of the garbagecollector itself was. We uncovered and fixed one benign pointer arithmetic \nbug in the measurement process. (2100 lines, excluding the collector) cfrac: A factoring program. The \nsmallestmember (6000lines) of Ben Zorn s benchmark collection. It wasrun with the secondlargeatinput \nsupplied by Zorn, and linked with the default malloc/ffee implementation. Hence pointer arithmetic checking \nwasnot operational. (The numbers for unoptimized programexecutionarenotincluded,sincethe programmakesuseofexplicit \nfunction inlining inawaythat doesnot appearto beimmediately compatible with unoptimized compilation by \ngcc 2.5.8.) gawk: Version 2.11 of the GNU awk interpreter. This is the secondsmallestmember of the Zorn \nbenchmark suite (8500 lines). It waslinked with the default malloc/free implementation and run with the \nsecondlargestinput suppliedbyZorn. (wealsoranthislinkedagainstour garbagecollector in anattempt to getaanother \ndatapoint for the cost of pointer arithmetic checking. It ran correctly without checking. With checking \nenabled, it immediately and correctly detected a pointer arithmetic error which was alsoanarrayaccesserror. \nAfterfixingthatanduncovering two more abusesof pointer arithmetic wegaveup. Someof theseproblems would \nhave been avoided with a more recent versionofgawk. It didhoweverservetotestthepointer arithmetic checking \ncode.) gs: Ghostacript, asdistributed with the Zorn benchmark suite (29500lines). This waslinked to useour \ngarbagecollector. (In the SPARCstation 2 teats,only the version with pointer arithmetic checking usedthe \ngarbagecollector.) The GhostScriptcustomallocatorwasdisabled. It wasrunwith the secondlargestsupplied \ninput file. No pointer arithmetic errors were found. This is probably due to a combination of an unusually \nclean coding style and the fact that most heap objects have prepended standard headers, Thus a pointer \nto one before the body of the object would not be discovered. It alsocould not confhsethe garbagecollector. \nAll programs were compiled with gcc 2.5.8 and timed on a Weitek-processor SPARCstation 2 running SunOS \n4.1.4, a SPARCStation 10 running Solaris 2.5, and a Pentium 90 running Linux 1.81. (The SPARCStation \n2 tests were run with aslightly olderversionofthepreprocessor,butshouldbe comparable.) We give slowdown \npercentagesrelative to the unpreproceased optimized version for the same code preprocessed for GC-safety, \nthe fully debuggable (and hence probably guaranteed safe) code, and debuggable code preprocessedto insert \npointer arithmetic checks: SPARCstation 2: -O, sqfe -g -g, checked cordtest 9% 54% 514% cfrac 17% @eds \nmodifications due to inlininp gawk 8% 25% <fsw gs 0% 33 % 205%  SPARC10: -02,wfe -g -g, checked cordtest \n9% 56% 529 % cfrac 8 % gawk 896 48% \u00adgs 5% 37% 366% Pentium 90: -02,wfe -g -g, checked cordtest 12% 28% \n510% cfrac 11% gawk 9% 41% \u00adgs 6% 17% 279% Early attempts at measurement suggest that all such timing \nresults are somewhat suspect due to cache effects. At one point while measuring a dynamically linked \nexecutable on a SPARCStation 10, we saw a consistent factor of 2 difference beween two copies of the \nsame executable. We subsequently attempted to minimize such effects. For example, the SPARCStation 10 \nand Pentium 90 numbers refer to an average of several runs of several copies of the executable, with \nthe highest running time discarded. We avoided dynamic libraries on the SPARCStation 10, which seemed \nto add significant variation. The resulting average execution times appear to be reproducible to within \n1 or 2%, though individual execution times still occasionally varied by more than 10%. The measurements \nremained more or less constant through the last several rounds of bug fixes to the preprocessor. To obtain \na more robust, though perhaps less relevant measure, we also measured SPARC object code expansions with \nand without preprocessing. These numbers include only the code that was actually processed, not the standard \nlibraries: -02, safe -g checked co~test 9% ;g% 130% cfrac 6% gawk 15% 68% \u00adgs 19% 73% 160% Note that \nthe first two columns could be expected to be somewhat indicative of execution times outside of libraries. \nThe last column, on the other hand, grossly understates dynamic instruction counts, since additional \nprocedure calls are introduced. Analysis To understand the reasonsfor the performance cost,it is instructive \nto look at a very simple C function: char f(char *x) { return (x[l]) ; } The body is translated by our \npreprocessor to the following code, which is not normally intended for human consumption: return ((*({ \ntypeof(char ) * _result; ; asm( : =r (_result) : O (&#38;(x[l])), rfmi (x)); _result; }))); This \nuses a gcc specific extension to introduce an expression local variable _result, and then inserts an \nempty assembly instruction with the constraint that the address &#38;(x [1] ) must occupy the same location \nas the output operand _res u1t. The assemblyinstruction hasan unused second argument x, which may be \nstored anywhere. Finally _res u1t is dereferenced. The SPARC code generated by gcc -02 for the return \nexpressionis: add %oO,l, %g2 ! empty assembly instruction here ldsb [%g2], %o0 In contrast, the normal \noptimized mde is simply ldsb [%00+1] ,%00 Note that both versions are perfectly safe in the presence \nof a garbage collector. The problem is that the empty assembly instruction introduced an explicit program \npoint at which the pointer addition must have been completed, but the load instruction cannot have been \ncompleted, since the compiler views it as depending on the result of the assembly instruction. Hence \nthere is no way to take advantage of the index arithmetic in the load instruction. Similar problems occur \nwith pure pointer arithmetic. Together these account for a majority of the overhead. This observation \nis consistent with the measurements from the preceding section. If the overhead were primarily due to \nadditional register pressure and hence register spills, one would have expected much more substantial \nperformance degradation on the Intel Pentium machine, which has substantially fewer registersthan the \nSPARC-basedmachines. Thus it is safe to assume that most of the slowdown is caused by our somewhat naive \nimplementation, and is not an inherent cat of garbage-collector-safety. The next section explores the \npossibility of eliminating much of this spurious overhead, and thus getting better bounds on the unavoidable \noverhead. A Postprocessor The above suggeststhat much of the decreasein object code performance could \nbe eliminated with some peephole optirnizations. To test this hypothesis, we built a simple peephole \noptimizer that operatea on the SPARC assembly code level. (The code was derived fmm a simple SPARC 1./2 \ninstruction scheduler [Boehrn94].) It first performs a simple global, intraprocedural analysis that allows \nus to identify possible usesof register values. It subsequently looks for one of the following three \npatterns inside each basic block and transforms thin appropriately: 1) add x,y, z ==> ... ,,, ld [x+y] \nId [z], ,,,  2) mov x,2 ==> ... ... ... x... . . . z. ..  3) add x,y, z ==> ... ,,. add x,y, w mov \nZ,W Not all of the safety constraints are listed here. An important one is that the register z should \nhave no other uses. For this purpose, we arranged for the KEEP.LIVE expansion to introduce a use of the \nsecond argument right after the evaluation of the tl st argument. (It generated a special comment understood \nby the peephole optimizer.) The arguments that thesepreserve GC safety areas follows: 1) If the other \nsafety constraints for this transformation are obeyed, then x and y remain where they were originally \nlive. The transformation could not apply if z were originally mentioned asthe secondargument of a KEEP-LIVE. \nAll other valuesremain live in the samerangesasbefore. Hence we cannot invalidate KEEP.LIVE semantics. \n 2)The samevaluesremain live atall program points, assumingthe already necessarysafety constraint that \nx is not overridden. 3)The sameargumentas(l). We do not reassign registers or reschedule the resulting \ncode. On a SPARC 10, the execution time and code size degra&#38;tions from the filly optimized normally \ncompiled code were reduced to: running time code size cordtest 4% 3% cfrac 2% 3% gawk 1% 7% gs 2%7% Based \non manual inspection of the remaining code, it appearsthat this is still significantly worse than what \ncould be done with a more precise analysis. It appeared that many of the remaining source of overhead \nwere still basically of the above form, but had been transformed suffkiently by the optimizer that they \nwere not as easily recognizable, often becausethat would have required more global analysis. Extensions \nIt is possible to extend this approach to a collector which considem interior pointers as valid only \nif they originate from the stack or registers (another possible operating mode of our collector). This \nrequires asserting that the client program storesonly pointerstothebaseofanobject intheheaporin statically \nallocated variables. It would again be possible to insert dynamic checks to verifi this. This avoids \nsome complications with allocating large objects as discussed in [Boehm93]. However it interacts suboptimally \nwith C++ compilers that use interior pointers as part of their multiple inheritance implementation. Acknowledgements \nSome of this grew out of prior work with David Chase and extensivediscussionwith John Ellis. Rhonda Reesemade \nan earlier version of gcc GC-safe, basedon a much earlier approach. That effort convinced me that a source-level \napproach was intereating, at least in the short-term. Extensive news group discussions,primarily with \nHenry Baker, helped to persuade me to pursue this issue more aggressively. The reviewers provided many \nusefid comments. Much of this would not have been pmsible without the availability of the GNU C compiler. \nReferences [ANS189] Stan&#38;rdX3.lS9-1989, American National Stanaivdfor Information Systems-Programming \nLunguage -C, American National Standards Institute, Inc. [AtkinsonEtA189] Atkinson, Russ,Alan Demers, \nCarl Hauser, Christian Jacobi, Peter Kessler, and Mark Weiser, Experiences Creating a Portable Cedar \n, Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation, SIGPLAN \nNotices 24,7 (July 1989),pp. 322-329. [AustinBreachSohi94] Austin, Todd M., Scott IZ Breach, and Gurindar \nS. Sohi, Efficient Detection of all Pointer and Array AccessErrors , Proceedings of the ACM SIGPLAN 94 \nCot#erence on Programming Language Design and Implementation, SIGPLAN Notices 29,6 (June 1994),pp. 290-301, \n[Bartlett88] Bartlett Joel F. Compacting garbagecollection with ambiguous roots , Lisp Pointers 1,6 (April-June \n1988),pp. 3-12. [Bartlett89] Bartlett Joel F., Scheme --> C a Portable Scherne\u00ad to-C Compiler, WRL ResearchReport \n89/1, Digital Equipment Corporation Western ResearchLaboratory, January 1989. [Boehm93] Boehm, Hans-J., \nSpace Efficient Conservative Garbage Collection , Proceedings of the ACM SIGPLAN 93 Conference on Programming \nLanguage Design and Implementation, SIGPLAN Notices 28,6 (June 1993),pp. 197-206. [Boehm94] The SPARC \nscheduler is available from parcftp.xerox.com: pub/gc/sched.tar.Z. It also operates in a GC-safe mode, \nalong the lines of ~oebmChase92]. [Boehm95] An overview of our conservativegarbagecollector alongwith \nthesourcecodecanbeaccessedfrom ftp://parcftp.xerox.com/pub/gc/gc.html. [BoehmChase92] Boehm, Hans-J., \nand David Chase,A Proposal for GC-Safe C Compilation, The Journal of C Language Twrw!ation 4,2 (December, \n1992),pp. 126-141. Also available (with the publishers permission) from parcftp.xerox.com:pub/gc/boecha.ps.Z. \n[BoehmDemersShenker91] Boehm, H., A. Demers, and S. Shenker, Mostly Parallel Garbage Collection , Proceedings \nof the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation SIGPLANNotices 26,6 \n(June 1991),pp. 157-164. [BoehmWeiser88] Boehm, Hans-J. and Mark Weiser, Garbage collection in an uncooperative \nenvironment , Softwwe Practice&#38; Experience 18,9 (Sept. 1988), pp. 807-820. [DiwanMossHudson92] Diwan, \nAmer, Eliot Moss, Richard Hudson, Compiler Support for Garbage Collection in a Statically Typed Language \n, ACM SIGPLAN 92 Conference on Programming Language Design and Implementation, SIGPLAN Notices 27,7 (July \n1992), pp. 273-282. [DetlefsDosserZorn93] Detlefk, David, Al Dosser, and Benjamin Zorn, Memory Allocation \nCostsin Large C and C+ + Programs , University of Colorado, Boulder Technical Report CU-CS-665-93. Available \nfor ftp from ca.colorado.edu:pub/techreportalzorn/CU\u00adCS-665-93.PS.Z. [Edelson91] Edelson, Daniel, A Mark-and-Sweep \nCollector for C+ + , Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACTSymposium on Principles \nof Programming Languages, Albuquerque, New Mexico, January 1992,pp. 51-58. [EllisDetlef$93] Ellis, John \nR., and David L, Detlef$, Safe Efficient Garbage Collection for C+ + , Xerox PARC Technical Report CSL-93-4, \nSeptember 1993. Also available from parcftp.xerox.com: pub/ellis/gc/gc.ps. [Fradet94] Fradet, Pascal, \nCollecting More Garbage , Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, \npp. 24-33. [Goldberg91] Goldberg, Benjamin, Tag-Free Garbage Collection for Strongly Typed Programming \nLanguages , ACM SIGPLAN 91 Conference on Programming Lunguage Design and Implementation, SIGPLANNotices \n26,6 (June 1991),pp. 165-176. [HastingsJoyce92]Hastings, Reed, and Bob Joyce, Fast Detection of Memory \nLeaks and AccessErrors , Proceedings of the Winter 92 USENIXconference, pp. 125-136. [JonesKelly95] Jones,Richard, \nand Paul Kelly, Bounds Checking for C, http://www\u00adala.doc.ic.ac.uk/-phjk/BoundsChecking.html. [Omohundro91] \nOmohundro, Stephen M., The Sather Language, ICSI, Berkeley, 1991. [OTooleNeties94] OToole, James,and \nScott Nettles, Concurrent Replicating Garbage Collection , Proceedings of the 1994 ACM Conference on \nLisp and Functional Programming, pp. 34-42. [RoseMuller92] Rose,John R., and Hans Muller, Inte~ating \nthe Schemeand C languages , Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, \npp. 247-259. [Rovner85] Rovner, Paul, On Adding Garbage Collection and Runtime Types to a Strongly-Typed \nStatically Checked, Concurrent Language , Technical Report CSL-84-7, Xerox Palo Alto ResearchCenter, \nprdo Alto, CA, July 1985, [SchelterBallantyne88] Schelter, W. F., and M. Ballantine, Kyoto Common Lisp \n, AZ Expert $3 (1988), pp. 75-77. \n\t\t\t", "proc_id": "231379", "abstract": "A conservative garbage collector can typically be used with conventionally compiled programs written in C or C++. But two safety issues must be considered. First, the source code must not hide pointers from the garbage collector. This primarily requires stricter adherence to existing restrictions in the language definition. Second, we must ensure that the compiler will not perform transformations that invalidate this requirement.We argue that the same technique can be used to address both issues. We present an algorithm for annotating source or intermediate code to either check the validity of pointer arithmetic in the source, or to guarantee that under minimal, clearly defined assumptions about the compiler, the optimizer cannot \"disguise\" pointers. We discuss an implementation based on a preprocessor for the GNU C compiler (gcc), and give some measurements of program slow down.", "authors": [{"name": "Hans-J. Boehm", "author_profile_id": "81423595101", "affiliation": "Xerox PARC", "person_id": "PP39051269", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/231379.231394", "year": "1996", "article_id": "231394", "conference": "PLDI", "title": "Simple garbage-collector-safety", "url": "http://dl.acm.org/citation.cfm?id=231394"}