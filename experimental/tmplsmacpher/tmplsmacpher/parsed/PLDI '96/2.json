{"article_publication_date": "05-01-1996", "fulltext": "\n Catching Bugs in the Web of Program Invariants Cormac Flanagan Matthew Flatt Shriram Krishnamurthi Matthias \nFelleisen Stephanie Weirich Department of Computer Science, Rice University, Houston, Texas 77005-1892* \ncormac@cs rice. edu Abstract MrSpidey is a user-friendly, interactive static debugger for Scheme. A \nstatic debugger supplements the stan\u00addard debugger by analyzing the program and pinpoint\u00ading those program \noperations that may cause run-time errors such as dereferencing the null pointer or apply\u00ading non-functions. \nThe program analysis of MrSpildey computes value set descriptions for each term in the program and constructs \na value flow graph connect\u00ading the set descriptions. Using the set descripticms, MrSpidey can identify \nand highlight potentially erro\u00adneous program operations, whose cause the programm\u00ader can then explore \nby selectively exposing portions of the value flow graph. Introduction A reliable program does not mis-apply \nprogram op\u00aderations. Addition always operates on numbers, not strings. Concatenation works with strings, \nnot num\u00adbers. To avoid the abuse of program operations, most languages impose a restrictive type system, \nwhich for\u00adbids the (syntactic) formation of certain faulty program phrases. However, type systems are \ntoo coarse to solve the general problem, which includes array indexing out\u00adside of its proper bounds, \ndivision by zero, dereferencing of null pointers, and jumping to non-function pointers. These problems \nare beyond the capabilities of standard type systems, and different languages deal with sulch run-time \nerrors in different ways. Unsafe languages like C [17] ignore the problem and leave it to the programmer \nto insert checks where ap\u00ad propriate. As a result C programs are notoriously prone to inexplicable crashes \n[20]. In contrast, safe languages *The authors are supported in part by NSF grants CCR 91-2251S and CDA-9414170. \n Permission to make digitablwrd copy of part or all of this work for pwsonal or dasamom use is granted \nwithout fee provided that copies are not made or distributed for profit or commercial advantage, the \ncopyright notice, the titie of the publication and its date appear, and notice is given that copying \nis by permission of ACM, Inc. To copy otherwise, to republish, to post on server=, or W redistribute \nto Ma, requires prior spedfic permission andlor a fee. such aa SML [21] and Scheme [3] equip all program \noper\u00adations with appropriate run-time checks. These checks guarantee that misapplications of program \noperations immediately raise an error signal, instead of returning random bit-patterns. Although this \nsolution ensures that programs don t return random results, it is unsat\u00adisfactory because errors are \nnot signaled until run-time, What is needed instead, is a static analysis tool that assists the programmer \nin verifying the preconditions of program operations. This kind of tool is a static debugger. Recent \nadvances in proof technology have brought static debugging within reach. Methods like abstract interpret \nation [5], control-flow analysis [25, 26, 14] or set-based analysis [11, 10] establish invariants about \nthe sets of values that variables and expressions may assume. Thus, if an array index expression does \nnot as\u00adsume values outside of the appropriate range, an array bound check is superfluous, and an indexing \nerror will never be signaled for this expression. Or, if the value set of a function variable only cent \nains closures, the func\u00adtion application does not need to be checked, and will al\u00adways succeed. Past \nresearch on static debuggers mainly focused on the synthesis of the invariants [2]. However, the presentation \nand, in particular, the explanation of these invariants were neglected. We believe that synthe\u00adsizing \ninvariants is not enough. Instead, a programmer must be able to inspect the invariants and browse their \nunderlying proof. Then, if some set invariant contains an unexpected element, the programmer can determine \nwhether the element results from a flaw in the program or approximations introduced by the proof system. \nWe have developed a static debugger for Scheme, called MrSpidey, which allows the programmer to browse \nprogram invariants and their derivations. We selected set-bssed analysis as the underlying proof technology \nof MrSpidey, for the following three reasons. First, set\u00ad based analysis produces accurate program invariants \nfor Scheme-like languages, even in the presence of complex control-flow and data-flow patterns. Second, \nset-based analysis is intuitive. It interprets program operations as naive set-theoretic operations on \nsets of run-time values, PLDI 96 5/96 PA, USA CI 199S ACM 0-S9791-795-29WO005... $54343 and propagates \nthese sets of values along the program s data-flow paths, in a manner that is easily understood by the \nprogrammer. Third, by appropriately annotat\u00ading the set-based analysis algorithm, we can provide a supporting \nexplanation in the form of a value flow graph for each invariant produced by the analysis. Since MrSpidey \nis to be used aa part of the typical program development cycle, we have integrated it with DrScheme, \nof our program development environment. On demand, MrSpidey marks up the program in the ed\u00aditor without \ndistorting its lexical or synt attic structure. The mark-ups visibly identify those program operations \nthat are not provably safe. Associated hyper-links pro\u00advide: . a value-set invariant for each expression \nand vari\u00ad able, and a graphical explanation for each invariant. The programmer can browse the information \nand thus improve his understanding of the program s execution behavior. The rest of the paper proceeds \naa follows, The fol\u00adlowing section outlines the information computed by MrSpidey. The user interface \nthat presents this infor\u00admation to the programmer is described in the third section, and the fourth section \npresents the results of a preliminary experiment evaluating the usefulness of MrSpidey. Technical details \ninvolved in the implemen\u00adtation are covered in the fifth section, and the sixth section describes related \nwork. The seventh section presents our conclusions and future research directions. 2 Set-Based Analysis \nMrSpidey s underlying set-based analysis algorithm han\u00addles all fundamental constructs of Scheme, including \nconditionals, assignable variables, mutable structures, and first-class continuations. In this section, \nwe outline the information produced by the analysis in terms of a simple functional subset of Scheme. \nFor a full presen\u00adtation of set-based analysis for a realistic language, we refer the interested reader \nto a related report [6]. 2.1 The Source Language The sample language is a simplified, J-calculus-like \nlan\u00adguage: see Figure 1. The language includes the prim\u00aditives cons, car, and cdr for list manipulation, \nwhich will serve to illustrate the treatment of primitive opera\u00adtions, and a number of basic constants. \nThe semantics of the source language can be formulated as a variant of Plotkins ~v-calculus [22]. Each \nterm in the language is labeled, and we assume that all labels in a program are distinct. For clarity, \nlabels are occasionally omitted. 2.2 Set-Based Analysis Set-based analysis computes information about \nthe sets of values that program variables and terms may sssume Figure 1: The Source Language A P E Program \n;:= $efinex M) o.. M,N E A ::= ~ (M M] I (cons M M)f I (car M) I $d. M) V E Value ::= I (Ax. M) I (cons \nV V) c E Const = Num U {nil,...} nENum= {o, 1,2, . ..} x ~ Vars = {Z, y,z, . . .} 1 E Label during execution. \nBecause these sets of values are typ\u00adically infinite, set-based analysis uses a finite number of program-dependent \nabstract values. Each abstract value corresponds to a particular constructor expres\u00adsion in the analyzed \nprogram, and represents the set of run-time values that can be created by that construc\u00adtor expression. \nThe set of abstract values used for the analysis of a program P is: 1 AbsValuep = {(cons /1 /z) ] (cons \nM{ M:) G P} u{(Az. Al) I (k. M) G P} u{c\\c EP} The abstract value (cons 11 /2) represents the set of \nval\u00adues (cons VI V2) that may be returned by the expres\u00ad sion (cons M~l M$ ), where each Vi is a possible \nvalue of the term M::. Similarly, the abstract value (h. M) represents the set of closures that may be \ncreated from the Xexpression (k. M). The set of abstract values also contains all constants occurring \nin the program. Set-based analysis produces a finite table called an abstract store, which maps variables \nand labels to sets of abstract values: S E AbsStore = ( Vars U Label) -+ T(Abs Va/ueP) An abstract store \nis valid if it conservatively approxi\u00admates the sets of values that variables and terms assume during \nan execution. 2.3 Deriving Abstract Stores MrSpidey employs a two stage algorithm to derive a valid \nabstract store for a program. First, it derives con\u00adstraints in a syntax-directed manner from the program \ntext. These constraints conservatively approximate the 1We use the following notations throughout the \npaper: P denotes the power-set constructor; j : A -+ B denotes that j is a total function from A to B; \nand M E P denotes that the term M occurs in the program P. dataflow relationships of the analyzed program. \nSec\u00adond, it determines the minimal (i. e., most accurate) ab\u00adstract store satisfying these constraints. \nThis abstract store is a valid abstract store for the analyzed program. Let us illustrate the syntax-directed \nderivation of constraints for two kinds of sentences: (cons itf~ kf.j)~ The evaluation of this term produces \nthe result (cons U V2), if U and V2 are values of the terms ikf~ and ikf$ respectively. Since all such \nresults are represented by the abstract value (cons /1 /2), the analyzer adds the constraint to the global \nset of program constraints, which en\u00adsures that S(l) represents all possible results of the cons expression. \n (M;l M;)~9 Suppose the value set for the function expression J@ includes the function (kc. N~). Then \nthe vari\u00adable x maybe bound to the result of the argument expression l@. In addition, the result of the \nfunc\u00adtion body N is returned as the result of the appli\u00adcation expression itself. By adding the constraint \nwhere L ranges over the set of labels, the analyzer captures this potential flow of values. Constraints \nfor the remaining classes of terms can be constructed in an analogous manner. Solving the derived constraints \nto produce a valid abstract store is straightforward [11]. 2.4 A Sample Analysis Consider the following \ntoy program: (define sum (A tree. (if (nwnher? tree) tree (+ (sum (car tree~ ) ) (sum (cdr tree)))))) \n(sum (cons (cons nill l~ )z 2Z )Z7) The program defines the function sum, which com\u00adputes the sum of \nall leaves in a binary numeric tree. Such a tree is either a leaf, represented as a number, or an interior \nnode containing two sub-trees, represented as a pair. However, sum is applied to the ill-formed t ree \n(cons (cons nil 1) 2). When executed, the program (Mree. .0 ) G S(sum) (1) (2) (3) (4)  nil E S(/3) \n(5) 1 c s(/4) (6) (cons 13 /4) G S(/5) (7) 2 e S(16) (8) (9) (lo) Figure 2: Simplified Constraints for \nsum raises an error because the primitive operation car is applied to the inappropriate argument nil. \nSince the complete list of set constraints for this pro\u00adgram is quite long, we present only (simplified \nversions of) the set constraints that affect position 11 which rep\u00adresents the potential arguments of \ncar: see Figure 2. Constraints (4) and (10) model the flow of argument values into the formal parameter \nz at two of the appli\u00adcation sites of the function sum. Constraint (3) mod\u00adels the behavior of the operation \ncar. Constraints (1) and (5) through (9) arise from syntactic values in the program. Constraint (2) captures \nthe notion that the possible values of tree in the else part of the condi\u00adtional expression cannot include \nnumbers, because of the number? predicate. To solve these constraints for S(/l ), we derive the implied \ninvariants: No further invariants relating to S(11) are implied by the set constraints. Hence: From (l), \n(10) : S(/7) ~ S(tree) (11) From (9), (11) : (cons 15 /6) E S(tree) (12) From (2), (12) : (cons Z, l,) \nC S(l~) (13) From (3), (13) : s(k) q S(12) (14) From (7), (14) : (cons lS /4) G S(lz) (15) From (l), \n(4) : S(iz) ~ S(tree) (16) From (15), (16) : (cons lS /.) E S(i?ree) (17) From From (2), (17) (3), (18) \n: : (cons lS i,) C S(/1) s(/3)g S(lz) (18) (19) From (5), (19) : nil G S(12) (20) From (16), (20) : nil \n~ S(tree) (21] From (2), (21) : nil E S(/1 ) (22) S(ii) = {(cons lS /4), (cons 15 /6), nil} This information \nprovides a warning that the set of ar\u00adguments of the operation car may include the inappro\u00adpriate value \nnil.  2.5 Identifying Potent ial Run-Time Errors By inspecting the set invariants for the arguments \nof each program operation, MrSpidey can identify those program operations that may cause run-time errors \nand can flag them for inspection by the programmer. For example, in the program sum, since the value \nset at position 11 contains the value nil, the evaluation of (car tree~ ) may raise a run-time error. \nAn inspection of the value flow graph explains why nil may appear at 11. At the moment, MrSpidey checks \nthe uses of Scheme primitives, the function position of applications, and the parameter lists of functions \n(for potential arity con\u00ad flicts). Future extensions are discussed below.  2.6 Value Flow Information \nWhile deriving an abstract store for the analyzed pro\u00adgram, the set-based analysis algorithm also constructs \na jlo w graph [14] from the subset relations. The flow graph models how values flow through a program \ndur\u00ading an execution, and provides an intuitive explanation for each value-set invariant produced by \nthe analysis. Let us illustrate this idea by considering how the value nil flows through the program \nsum. During an execution, the expression nil~s simply returns the value nil, which becomes the first \nelement of the pair created by (cons nil~ li )~ . Since this pair is a result value of the expression \ntree , the value nil is extracted by (car tree~ )~a. This value is then bound to the formal parameter \ntree via the function call (sum (car treeZ1 )1 ), and gets returned as the result of the expression treell. \nThis flow of values is modeled by the subset in\u00advariant produced during set-based analysis. The spe\u00adcific \ninvariant that describe the flow of the value nil through the program, from the constructor expression \nnil~~ to the expression tree 1, are: 3 The User Interface of MrSpidey to the program development cycle. \nFor these reasons, we integrated MrSpidey with DrScheme, our Scheme programming environment. MrSpidey \nuses program mark-ups to characterize a program s run-time behavior in an easily accessible man\u00adner. \nThe mark-ups are simple font and color changes that do not affect the lexical or syntactic structure \nof the program. They represent information about the program s behavior. 13y clicking on one of the marked\u00adup \ntokens or phrases, a programmer can make the in\u00adformation visible. 3.1 Identifying Potential Run-Time \nErrors Program operations that may signal run-time errors during an execution are a natural starting \npoint in the static debugging process. MrSpidey identifies these po\u00adtentially erroneous operations by \nhighlighting them via font and color changes. Any primitive operation that may be applied to inappropriate \narguments, thus rais\u00ading a run-time error, is highlighted in red (or under\u00adlined on monochrome screens). \nA run-time argument check is required at each of these potentially faulty op\u00aderations. Primitive operations \nthat never raise errors are shown in green. These operations do not require run-time checks. Any function \nthat may be applied to an incorrect number of arguments is highlighted by displaying the lambda keyword \nin red (or underlined), and any application expression where the function sub\u00adexpression may return a \nnon-closure is highlighted by displaying the enclosing parentheses in red (or under\u00adlined) . Figure 3 \ncontains examples of these three kinds of potential errors. MrSpidey also presents summary information \ndescrib\u00ading the number and type of potential run-time errors in each top-level definition, together with \na hyperlink to that definition. By following these hyperlinks, the pro\u00adgrammer can directly access the \npotentially erroneous expressions.  3.2 Presenting Value Set Information MrSpidey provides an inferred \nvalue set invariant for each variable and term in the program. Because the value set representation used \nin abstract stores is ver\u00adbose and difficult to read, MrSpidey uses the following set-description language \n(SDL) to describe these sets: T E SDL ::= c ~(Ax. M) ~ [con; r r) Tn ) ~ $eC ([i; T,] . . . [an Tn]) \nT) CYESDV= {a, p,y, . . .} A program invariant browser must fit seamlessly into a The expression (+ \nTI . . . T.) denotes the union of the programmer s work pattern. It must provide the pro\u00ad sets of values \ndescribed by T1 through Tn. The recursive set-description expression (ret ([q Tl] . . . [an Tn]) T) \nApplied No check to on incorrect number? # of arguments Potential and cdr run-time error on car Causes \nArity Invoking error error a on car non-function ~~ wmm@&#38;/ #w-,+Y..%2w.. CHECKS : e vr ;JAL>CHECKS: \n3 1 4 (2 (1 (of prim) ap) 12 . #//////M#///H#*//#///M//H#* (1 lambda] possible checks is .am%%%w/x-Y/M4-P,xw..#/./.wiY.w%w..w%w////m//#w&#38; \n33,0%) Figure 3: Identifying Potential Run-Time Errors binds the set-description variables (SDV) CYl,. \n. . . Ctn, and these bindings are visible within rl, . . . . Tm,T. The meaning of this recursive set-description \nexpression is theset ofvalues described byr, where each ai isbound to Ti. The transformation from an \nabstract store to set\u00addescription expressions is described in Subsection 5.2. MrSpidey computes a closed \nset-description expres\u00adsionfor each variable andterm inthe program from the abstract store produced by \nset-based analysis. It relates each program variable to its set-description expression via a hyperlink \non that variable. It also relates each compound term in the program with a set-description expression \nvia a hyperlink on the opening parenthesis ofthat term. Clicking onahyperlink causes aboxccn\u00adtaining \nthe corresponding set-description expression to reinserted totheright of thephrase inthe buffer. Fig\u00adure4shows \nthe set-description expression displayed by clicking on the variable tree. 3.3 The Value Flow Browser \nDuring the constraint derivation phase of the set-based analysis, MrSpidey constructs a value flow graph \nfrclm subset relations. The value flow graph models the flow of values between various points in the \nprogram. Each edge in this graph is presented as an arrow overlaid on the program text. Because a large \nnumbers of arrows would clutter the program text, these arrows are pre\u00adsented in a demand-driven fashion. \nTo inspect the in\u00adcoming edges for a given program term, the programmer clicks on the value set invariant \nof that term. Figure 5 shows the incoming edges for the parameter tree. Hyperlinks associated with the \nhead and tail of each arrow provide a fast means of navigating through tex\u00adtually distinct but semantically \nrelated parts of the pro\u00adgram, which is especially useful on larger programs. Clicking on one end of \nan arrow moves the focus of the editor buffer to the term at the other end of the arrow, and also causes \nthe value set invariant for that term to be displayed. Using these facilities, a programmer who encounters \na surprising value set invariant can proceed in an iter\u00adative fashion to expose the portions of the value \nflow graph that influence that invariant. To expedite this iterative process, MrSpidey also provides \nan ancestor facility that automatically exposes all portions of the value flow graph that influence a \nparticular invariant, thus providing the programmer with a complete expla\u00adnation for that invariant. \nIn some cases, the number of arrows presented by {define SUNI {lambda (tree} [if (number? tree} tree \n{+ (sum {w lxee  Figure 4: Value Set Information {define sum (lambda (tree{+ (cons (cons nil num] nun] \n) E (if numb ? tree} ree {+ (sum ~ tree)] Ii [sum &#38;treel)l l)) Figure 5: Value the ancestor facility \nis excessive. Since the programmer is typically only interested in a particular class of val\u00adues, MrSpidey \nincorporates afilter facility that allows the programmer to restrict the displayed edges tothose that \naffect the flow of certain kinds of values. This fa\u00adcilit y is extremely useful for quickly understanding \nwhy a primitive operation may be applied to inappropriate argument values.  3.4 A Sample Debugging Session \n To illustrate the effectiveness of MrSpidey as a static program debugger, we describe how this tool \ncan be Source Information used to identify and eliminate the potential run-time error in the program \nsum. When MrSpidey is invoked, the primitive operation car is highlighted, indicating that this operation \nmay raise a run-time error. Inspecting the value set for the operation argument, tree, (see Figure 4) \nshows that this set includes the inappropriate argument nil. By using the ancestor and filter facilities, \nwe can view how this er\u00adroneous value flows through the program: see Figure 6. The displayed information \nmakes it obvious that the error is caused by application of sum to the ill-formed tree (cons (cons nil \n1) 2). Although space restrictions force us to present a triv\u00ad(define SUM cons {cons nil num) num] ) \n[cons nil ream) 3 tree 99(+ (cons .e~e (sum (cons (cons ilnil 1) 2]) L ~1 1 Figure6: ial program, our \ninitial experiences indicate that the same static debugging process scales well to large pro\u00adgrams. 4 \nExperimental Results We evaluated the effectiveness of MrSpidey sexplana\u00adtory mode with an experiment. \nReconstructed atext\u00adbased system, called MrSpidey/textual, that resembles an ML-style type-checker and \nWright and Cartwriglht s soft typer [28]. MrSpidey/textual produces an anno\u00adtated version of the source \nprogram, which identifies those program operations that require run-time checks. Using additional commands, \na programmer may inquire about the value sets of global and local definitions, i~nd the mismatch between \nthe expected arguments and in\u00adferred value sets of program operations. The participating group consisted \nof 15 students tak\u00ading an undergraduate course on programming languages. The students had been introduced \nto the basics of types and type-safety. All students had a working knowledge of Scheme; none had previously \nused either static de\u00adbugger. They were given a 25 minute lecture on set\u00adbased analysis and a 45 minute \ntutorial on the use of the two systems. The participants were split into two groups, with people of comparable \nskill separated based on home\u00adwork assignments. For each test program, the par\u00adticipants in one group \nused MrSpidey/graphical, while those in the other group used MrSpidey/textual, with the groups alternating \nanalysis tools between programs. The participants were not allowed to execute the pro\u00ad (cons nil num} \nnum} ]) Ilow ofnil grams. The participants had thirty minutes to work on each of six programs. The programs \nwere excerpts, ranging from one to four pages in length, of larger projects. Each excerpt contained at \nleast one bug and possibly additional run-time checks inserted due to the approx\u00adimate nature of the \nanalysis. The participants were asked to classify the cause of each run-time check as either: a program \nerror, or e a weakness in the proof system. In the first case, the participants were asked to fix the \nprogram; in the second case, they were asked to explain why this check would never raise an error at \nrun-time. We observed the progress of the participants and their interaction with the tools. The participants \ntypi\u00adcally used most, if not all, of the facilities of MrSpidey. With the graphical version, students \nused both the an\u00adcestor and filter facilities to display portions of the flow\u00adgraph explaining the derivation \nof certain value set in\u00advariant. They mentioned that the ability to track down the origin of values, \nand especially to focus attention on selected classes of values, was particularly useful in un\u00adderstanding \nand eliminating checks and errors. Our observations also suggest that the graphical user interface provides \nmuch easier access to the results of the analysis than the textual interface. The users of MrSpidey/textual \ntypically had to work with three dif\u00adferent sources of information: the source program, the annotated \ncode, and the console window. The users of MrSpidey/graphical could avoid this context switch\u00ading since \nall of these information sources were com\u00adbined into a single window. Indeed, one user of Mr\u00adSpidey/textual \ntried to reconstruct exactly the infor\u00admation provided by MrSpidey/graphical. The student began annotating \nthe printed copy of a test program with value set descriptions and with arrows describing portions of \nthe value flow graph. Our productivity measurements were inconclusive due to what we believe was an overly \nartificial experimental setup. We intend to continue our observations through the rest of the semester \nand to report on them in an expanded version of the paper. 5 The Implementation of MrSpidey MrSpidey \nis a component of DrScheme, a comprehen\u00ad sive Scheme development environment. DrScheme con\u00ad sists of \nseveral components. Its core component is MrEd; the syntax interface is Zodiac. The following subsec\u00ad \ntions describe these components in some details and provide pointers to relevant technical reports. \n5.1 Macro Expansion A useful interface for MrSpidey must present the results of the program analysis \nin terms of the original source program. Hence, the environment requires a front-end for processing source \ntext that can correlate the inter\u00ad nal representation of programs with their source loca\u00ad tion. For Scheme, \nthis correlation task is complicated by the powerful macro systems of typical implementa\u00ad tions because \nmacros permit arbitrary rearrangements of syntax. MrSpidey exploits Zodiac [18] for its front-end. Zo\u00ad \ndiac is a tool-kit for generating language front-ends that are suit able for interactive environments. \nIt includes a hygienic high-level macro system that relates each ex\u00ad pression in the macro-expanded code \nto its source lo\u00ad cation, MrSpidey exploits this information to associate value set invariants with expressions \nin the source pro\u00ad gram and to present portions of the value flow-graph as arrows relating terms in the \nprogram text. 5.2 Converting an Abstract Store to Set- Description Expressions MrSpidey computes a set-description \nexpression for each term kf~ from the abstract store representation as fol\u00adlows: First, it views the \nset environment as a regular\u00adtree grammar with root non-terminal i, and uses a st an\u00addard algorithm to \nsimplify this grammar [9]. Second, it eliminates unnecessary non-terminals from this gram\u00admar, by replacing \nreferences to these non-terminals with the right-hand side of the appropriate production rules. If the \nresulting grammar contains only the single non\u00adterminal 1, it expresses the grammar as a non-recursive \nset-description expression. Otherwise, it expresses the grammar as a recursive set-description expression, \nwhere the remaining non-terminals (other than i) become set\u00addescription variables.  5.3 Identifying \nPotential Run-Time Errors Scheme contains a large number of primitive proce\u00addures. MrSpidey represents \nthe set of appropriate ar\u00adguments for each primitive procedure as a regular-tree grammar (or RTG). Since \nthe value set of each argu\u00adment expression is also represented ss an RTG, decid\u00ading whether a primitive \nis used correctly reduces to the inclusion question between two RTGs. Although the general question is \nPSPACE-complete [9], for our spe\u00adcific application it can be decided in time linear in the size of the \nargument s RTG, because the RTG of the expected arguments is deterministic and small. 5.4 Graphical \nEngine MrSpidey s graphical component is implemented using MrEd [8], a Scheme-based engine for constructing \ngraph\u00adical user interfaces. The core of the engine is am C++\u00adlike object system and a portable graphics \nlibrary. This library defines high-level GUI elements, such as win\u00addows, buttons, and menus, which are \nembedded within Scheme as special primitive classes. MrEd s graphical (,1sss library includes a powerful, \nextensible text editor class. This editor class is used in MrSpidey to display analyzed programs, including \nthe boxes containing value set information and the arrows describing the value flow graph. Value set \nboxes are easily embedded in the program text because an edi\u00adtor buffer can contain other buffers as \npart of its text. The arrows used to present flow information are not part of the editor s standard built-in \nfunctionality, but it was easy to extend the editor class with arrow draw\u00ading capabilities using other \ncomponents of the graphical library. MrEd s object system provides a robust integration between the \nScheme implementation and the underly\u00ad ing graphical class library. The integration of the li\u00ad brary \nthrough the object system is easily understood by GUI programmers. The object system also provides an \nimportant tool for designing and managing the com\u00ad ponents of a graphical interface. Because the imple\u00ad \nment ation of MrSpidey exploits this object system, it can absorb future enhancements to the editor and \nit is easily intergrated into the DrScheme environment. Applications developed with MrEd including Mr- \n Spidey and DrScheme are fully portable across the major windowing systems (X Windows, Microsoft Win\u00ad \ndows, and MacOS). MrEd s portability, its object sys\u00ad tem, and its rich class library enabled MrSpideyi \nim\u00ad plementors to focus on the interesting parts of their application. 6 Related Work A number of interactive \nanalysis tools and static debug\u00adging systems have been developed for other program\u00adming languages. Some \naddress different concerns; none provide an explanation of the derived invariants. Syntox [2] is a static \ndebugger for a subset of Pascal. Like MrSpidey, it associates run-time invariants, i.e., numeric ranges, \nwith statements in the program. Be\u00adcause Syntox does not provide an explanation of these invariants, \nit is difficult for a programmer to decide whether an unexpected invariant is caused by a weak\u00adness in \nthe proof system or a flaw in the program. In addition, the existing system processes only a first-order \nlanguage, though Bourdoncle explains how to extend the analysis [2: Section 5]. Several environments \n[16, 4, 13, 27, 24] have been built for parallel programming languages to expose de\u00adpendencies, thus \nallowing the programmer to tune pro\u00adgrams to minimize these dependencies. In particular, MrSpidey has \nmany similarities to the ParaScope [16, 4] and D editors [13]. Both MrSpidey and the edi\u00adtors provide \ninformation at varying levels of granularity; both retain source correlation through transformations; \nand both depict dependencies graphically, However, unlike MrSpidey, the editors process a language with \nextremely simple control-and data-flow facilities, and therefore do not need to provide a supporting \nexphma\u00adtion for the derived dependencies. 7 Summary and Future Work MrSpidey is an interactive static \ndebugging tool that supports the production of reliable software. It identi\u00adfies the program operations \nthat may signal errors dur\u00ading an execution and describes the sets of erroneous ar\u00adgument values that \nmay cause those errors. Unlike pre\u00advious systems, it also provides an explanation of how those erroneous \nvalues flow through the program, Its graphical user interface presents this information to the programmer \nin a natural and intuitive manner. Exper\u00adimental results support our belief that these this infor\u00admation \nfacilitates static program debugging. MrSpidey also functions as an interactive optimiza\u00ad tion tool, \nUsing MrSpidey, the programmer can tune a program so that its value set invariants accurately characterize \nits execution behavior, thus enabling nu\u00ad merous program optimizations that depend on these in\u00ad variant, \nincluding variant check elimination [6, 15, 28, 1, 12], synchronization optimization [7], partial evalu\u00ad \nation [19], closure analysis [23], dead-code elimination and constant-folding. To investigate this potential, \nwe implemented variant check elimination aa part of Mr- Spidey. Preliminary results indicate that the \nresulting tool expedites the production of efficient programs. We intend to investigate this area in \nmore depth. We adapted set-based analysis for use as the un\u00ad derlying proof technology used in MrSpidey. \nSet-based analysis can be extended to produce accurate informa\u00adtion on numeric ranges [10]. This information \nis useful for eliminating array bounds checks and for array data dependence analysis. Other program analyses \nthat pro\u00adduce information similar to set-based analysis but which provide alternative cost /accuracy \ntradeoffs could also be adapted for use in MrSpidey [14, 15, 12, 1]. Availability DrScheme, including \nMrSpidey, k avad\u00adable at http: ilvvv. cs. rice. edulCS/PLT/packages/ drscheme. Acknowledgments We thank \nCorky Cartwright and Bruce Dubs for discussions concerning the philosophy of soft typing and Nevin Heintze \nfor hints on the im\u00adplementation of set-based analysis. We also gratefully acknowledge the students in \nthe 1996 COMP311 pro\u00adgramming languages course at Rice University for their participation in the experiment. \nReferences [1] AIKEN, A., WIMMERS, E. L., AND LAKSHMAN, T. K. Soft typing with conditional types. In \nPro\u00adceedings of the ACM Sigplan Conference on Prin\u00adciples of Programming Languages (1994), pp. 163 173. \n[2] BOURDONCLE, F. Abstract debugging of higher\u00adorder imperative languages. In Proceedings of the ACM \nSIGPLAN 93 Conference on Programming Language Design afid Implementation (June 1993), pp. 46 55. [3] \nCLINGER, W., AND REES, J. (EDs.). The rev\u00adised4 report on the algorithmic language scheme. ACM Lisp Pointers \n4, 3 (July 1991). [4] COOPER, K. D., HALL, M. W., HOOD, R., KENN~Dy, K., MCK~NLE=, Kc, M~~LOR- CRUMMEY, \nJ., TORCZON, L., AND WARREN, S. The Parascope parallel programming environment. Proceedings of the IEEE \n(February 1993), 244-263. [5] COUSOT, P., AND COUSOT, R. Abstract interpre\u00adtation: A unified lattice \nmodel for static analyses of programs by construction or approximation of fixpoints. In Proceedings of \nthe ACM Sigplan Con\u00adference on Principles of Programming Languages (1977), pp. 238-252. [6] FLANAGAN, \nC., AND FELLEISEN, M. Set-based analysis for full Scheme and its use in soft-typing. Rice University \nComputer Science TR95-253. [7] FLANAGAN, C,, AND FELLEISEN, M. The seman\u00ad tics of future and its use \nin program optimiza\u00adtion, In Proceedings of the ACM Sigplan Con\u00adference on Principles of Programming \nLanguages (1995), pp. 209-220. [8] FLATT, M. Mrliki: An engine for portable graphi\u00ad cal user interfaces. \nRice University Computer Sci\u00ad ence TR-96-258, Rice University. [9] GtiCSEG, F., AND STEINBY, M. Tree \nAutomata. Akad6miai Kiad6, Budapest, 1984.  [10] HEINTZE, N. Set based analysis of arithmetic. Tech. \nRep. CMU-CS-93-221, Carnegie Mellon Uni\u00adversit y, December 1993. [11] HEINTZE, N. Set-based analysis \nof ML programs. [n Proceedings of the ACM Conference on Lisp and Functional Programming (1994), pp. 306-317. \n[12] HENGLEIN, F. Dynamic typing: syntax and proof theory. Science of Computer Programming 22 (1994), \npp. 197-230. [13] HIRANANDAN1, S., KENNEDY, K., TSENG, C.-W., AND WARREN, S. The D editor: A new inter\u00adactive \nparallel programming tool. In Proceedings of Supercomputing (1994). [14] JAGANNATHAN, S., AND WEEKS, \nS. A uni\u00adfied treatment of flow analysis in higher-order lan\u00adguages. In 22nd ACM Symposium on Principles \nof Programming Languages (1995), pp. 393-407. [15] JAGANNATHAN, S., AND WRIGHT, A. K. Ef\u00adfective flow \nanalysis for avoiding run-time checks. In Proc. 2nd International Static Analysis Sym\u00adposium, LNCS 983 \n(September 1995), Springer-Verlag, pp. 207-224. Preliminary version ap\u00adpears as part of Technical Report \nDAIMI-PB 493, ~arhus University, May 1995. [16] KENNEDY, K., MCKINLEY, K., AND TSENG, C.- W. Interactive \nparallel programming using the ParaScope Editor. IEEE Transactions on Paral\u00adlel and Distributed Systems \n2, 3 (July 1991). [17] KERNIGHAN, B. W., AND RITCHIE, D. M. The C Programming Language. Prentice-Hall, \n1988. [18] KRISHNAMURTHI, S. Zodiac: A programming en\u00advironment builder. Rice University Computer Sci\u00adence \nTR-96-259, Rice University. [19] MALMKJmR, K., HEINTZE, N., AND DANVY, O. ML partial evaluation using \nset-based analysis. Tech. Rep. CMU-CS-94-129, Carnegie Mellon Uni\u00adversity, 1994. [20] MILLER, B., KOSKI, \nD., LEE, C. P., MAGANTY, V., MURTHY, P., NATARAJAN, A., AND STEIDL, J. Fnzz revisited: A re-examination \nof the reliabil\u00adity of unix utilities and services. Computer Science Department, University of Wisconsin, \n1995. [21] MILNER, R., TOFTE, M., AND HARPER, R. The Definition of Standard ML. The MIT Press, Cam\u00adbridge, \nMassachusetts and London, England, 1990. [22] PLOTKIN, G. D. Call-by-name, call-by-value, and the A-calculus. \nTheoretics/ Comput. Sci. 1 (1975), 125-159. [23] SHAO, Z., AND APPEL, A. Space-efficient closure represent \nations. In Proceedings of the ACM Sympo\u00adsium on Lisp and Functional Programming (1994), pp. 150-161. \n[24] SHEI, B., AND GANNON, D. Sigmacs: A pro\u00adgrammable programming environment. In Ad\u00advances in Languages \nand Compilers for Parallel Computing. The MIT Press, August 1990. [25] SHIVERS, O. Control-flow Analysis \nof Higher-Order Languages, or Taming Lambda. PhD thesis, Carnegie-Mellon University, 1991. [26] STEFANESCU, \nD., AND ZHOU, Y. An equational framework for the flow analysis of higher order functional programs. In \nProceedings of the ACM Conference on Lisp and Functional Programming (1994), pp. 318-327. [27] WOLFE, \nM. J. The Tiny loop restructuring re\u00adsearch tool. In Proceeding of the 1991 International Conference \non Parallel Processing (August 1991). [28] WRIGHT, A., AND CARTWRIGHT, R. A practical soft type system \nfor scheme. In Proceedings of the ACM Conference on Lisp and Functional Program\u00adming (1994), pp. 250 \n262.  \n\t\t\t", "proc_id": "231379", "abstract": "MrSpidey is a user-friendly, interactive static debugger for Scheme. A static debugger supplements the standard debugger by analyzing the program and pinpointing those program operations that may cause run-time errors such as dereferencing the null pointer or applying non-functions. The program analysis of MrSpidey computes value set descriptions for each term in the program and constructs a value flow graph connecting the set descriptions. Using the set descriptions, MrSpidey can identify and highlight potentially erroneous program operations, whose cause the programmer can then explore by selectively exposing portions of the value flow graph.", "authors": [{"name": "Cormac Flanagan", "author_profile_id": "81100538763", "affiliation": "Department of Computer Science, Rice University, Houston, Texas", "person_id": "PP14187273", "email_address": "", "orcid_id": ""}, {"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "Department of Computer Science, Rice University, Houston, Texas", "person_id": "PP39045354", "email_address": "", "orcid_id": ""}, {"name": "Shriram Krishnamurthi", "author_profile_id": "81100512233", "affiliation": "Department of Computer Science, Rice University, Houston, Texas", "person_id": "PP39074578", "email_address": "", "orcid_id": ""}, {"name": "Stephanie Weirich", "author_profile_id": "81100093135", "affiliation": "Department of Computer Science, Rice University, Houston, Texas", "person_id": "P267927", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Department of Computer Science, Rice University, Houston, Texas", "person_id": "PP39037684", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/231379.231387", "year": "1996", "article_id": "231387", "conference": "PLDI", "title": "Catching bugs in the web of program invariants", "url": "http://dl.acm.org/citation.cfm?id=231387"}