{"article_publication_date": "05-01-1996", "fulltext": "\n Representing (lontrol in the Presence of One-Shot Continuations* Carl Bruggeman Oscar Waddell R. Kent \nDybvig Indiana University Computer Science Department Lindley Hall 215 Bloomington, Indiana 47405 {bruggema,owadde[l, \ndyb) files.indiana. edu Abstract Traditional first-class continuation mechanisms allow a cap\u00adturedcontinuation \nto reinvoked multiple times. Many con\u00adtinuations, however, are invoked only once. This paper in\u00adtroduces \none-shot continuations, shows how they interact with traditional multi-shot continuations, and describes \na stack-based implementation of control that handles both one-shot and multi-shot continuations. The \nimplement ation eliminates the copying overhead for one-shot continuations that is inherent in multi-shot \ncontinuations. 1 Introduction Scheme [5] and some implementations of ML [17] provide continuations as \nfirst-class data objects. Continuations can be used to implement, at the source level, a number of interesting \ncontrol features, such as loops, nonlocal ex\u00adits, nonblind backtracking [22], nondeterministic computa\u00adtions \n[10, 14], and coroutines [7]. Source-level implementa\u00adtions of thread systems [9, 15, 21], especially \nin the area of graphical user interfaces (GUIS) [12, 13, 20, 23], are an im\u00adportant and rapidly growing \napplication area for first-class cent inuations. Continuations represent the remainder of a computation \nfrom a given point in the computation. When a continua\u00adtion is invoked, control returns to the point \nin the program at which the continuation was captured. Traditional con\u00adtinuation mechanisms allow a continuation \nto be invoked multiple times. In our experience, however, most continu\u00adations are, in fact, invoked only \nonce. In particular, this is true for continuations used to implement threads. This observation motivated \nus to develop one-shot continuations, continuations that can be invoked only once, and to inves\u00adtigate \nwhether the copying costs associated with traditional multi-shot continuations could be avoided for one-shot \ncon\u00adtinuations. In this paper, we introduce one-shot continuations and explain how they interact with \ntraditional multi-shot contin\u00aduations. We describe an implementation of one-shot contin\u00aduations that \neliminates the copying overhead associated with *This material is based on work supported in part by \nthe National Science Foundation under grant number CDA-9312614. Permissionto make digitalkrd copy of \npart or all of ttis work for personal or classroom use is ranted without fee provided that copies are \nnot made or distributed for pro 8t or commercial advantage, the copyright notice, the title of the ublication \nand its date appear, and notice is given that oopying is [ y permission of ACM, Inc. To mpy otherwise, \nto republish, to post on servers, or to redistribute to lists, requires prior specific permission andbr \na fee. PLDI 9S 5/96 PA, USA * 01996 ACM 0-39791 -795-2%/0005... $3.50 multi-shot continuations. We present \nperformance measure\u00adments that demonstrate that one-shot continuations are in\u00addeed more efficient than \nmulti-shot continuations for certain applications, such as thread systems. The remainder of this paper \nis organized aa follows. Sections 2 and 3 describe one-shot continuations and the changes required to \nadapt our stack-baaed Scheme imple\u00admentation to support them. Section 4 discusses the perfor\u00admance characteristics \nof our implementation. Finally, Sec\u00adtion 5 summarizes the paper and compares our approach to related \napproaches. 2 One-shot continuations Continuations in Scheme are procedural objects that rep\u00adresent the \nremainder of a computation from a given point in the computation. The procedure call-with-cuwent\u00adcontinuation, \ncommonly abbreviated call/cc, allows a pro\u00adgram to obtain the current continuation. call/cc must be passed \na procedure p of one argument. call/cc obtains the current continuation and paases it to p. The continuation \nitself is represented by a procedure k. Each time k is ap\u00adplied to a value, it returns the value to the \ncontinuation of the caU/cc application. This value is, in essence, the value of the application of call/cc. \nIf p returns without invoking k, the value returned by the procedure is the value of the application \nof caU/cc. If control has not otherwise passed out of the call to call/cc, invoking the continuation \nmerely results in a non\u00adlocal exit with the specified value. If control has already passed out of the \ncall to call/cc, the continuation can still be invoked, but the result is to restart the computation \nat a point from which the system has already returned. The continuation of a procedure call is essentially \nthe control stack of procedure activation records. If con\u00adtinuations were used only for nonlocal exits, \nas for C s set jmpilongjmp, then the essence of a continuation object would be a pointer into the control \nstack. Because continua\u00adtions can outlive the context of their capture, however, con\u00ad tinuation objects \nmust have indefinite extent and a pointer into the stack is not sufficient. If this simple representation \nwere used and control passed out of the context where the continuation was created, the stack might be \noverwritten by other procedure activation records, and the information required upon return to the continuation \nwould be lost. One-shot continuations are obtained with call/lcc and differ from multi-shot continuations \nonly in that it is an er\u00adror to invoke a one-shot continuation more than once. Note 99 that a continuation \ncan be invoked either implicitly, by re\u00adturning from the procedure passed to call/cc or call/1 cc, or \nexplicitly, by invoking the continuation procedure obtained from the call/cc or call/l cc. One-shot continuations \ncan be used in most contexts where multi-shot continuations are currently used, e.g., to implement non-local \nexits, non-blind backtracking [22], and coroutines [7]. One-shot continuations can also be-used to implement \nthread systems in user code. One-shot continuations cannot be used to implement nondeterminism, as in \nProlog [6], in which a continuation is invoked multiple times to yield additional values [10, 14]. In \nthese sorts of applications, multi-shot continuations must still be used. If a language supports both \nmulti-shot and one-shot con\u00adtinuations, it is necessary handle cases in which programs use both varieties \nof continuation. For example, a Prolog interpreter might use multi-shot continuations to support nondeterminism \nwhile employing a thread system baaed on one-shot continuations at a lower level. One-shot continua\u00adtions \nmust be promoted to multi-shot status when they are captured as part of a multi-shot continuation. This \nallows programmers to build abstractions based on one-shot con\u00adtinuations that can be composed with abstractions \nbaaed on multi-shot continuations in a consistent manner. 3 Implementation A detailed description of \nour implementation of multi-shot continuations is described elsewhere [16]. In this section, we review \nthe essential details and discuss the changes neces\u00adsary to implement one-shot continuations.  3.1 Segmented \nstack model In our model, the control stack is represented as a linked list of stack segments. Each stack \nsegment is structured as a true stack of frames (activation records), with one frame for each procedure \ncall. A stack record associated with each stack segment contains information about the segment, including \na pointer to the base of the segment, a pointer to the next stack record, the size of the segment, and \nthe return address associated with the topmost frame of the continuation. (See Figure 1.) Each frame \nconsists of a sequence of machine words. The first word at the base of the frame is the return address \nof the current active procedure. The next n words contain the n actual parameters of the procedural. \nThe remaining words in the frame contain the values of local variables, compiler temporaries, and partial \nframes for procedure calls initiated but not yet completed. A frame pointer register, fp, points to the \nbase of the current frame, which is always in the topmost stack segment. No separate stack pointer is \nmaintained to point to the topmost word on the stack, so there is often a gap between the frame pointer \nand the topmost word. This does not cre\u00adate any difficulties as long as the same stack is not used for \nasynchronous interrupt handling. Using a frame pointer in\u00adstead of a stack pointer simplifies argument \nand local vari\u00adable access and eliminates register increments and decre\u00adments used to support stack (push \nand {pop operations. 10ur compiler actually passes the return address and the first few arguments in \nregisters, where feasible [4]. Although this complicates the implementation only slightly, we assume \na more straightforward model here to simplify our presentation, No explicit links are formed between \nframes on the stack. Some compilers place the current frame pointer into each stack frame before adjusting \nthe frame pointer to point to the new frame. This saved pointer, or dynamic link, is used by the called \nroutine to reset the frame pointer and by vari\u00adous tools, e.g., exception handlers and debuggers, to \nwalk the stack. In our model, the frame pointer is adjusted just prior to a procedure call to point to \nthe new frame and is adjusted after the called routine returns to point back to the old frame. In order \nfor this to work, the frame pointer must still (or again) point to the called routine s frame on return. \nThe compiler generating code for the calling procedure must keep track of the displacement between the \nstart of the call\u00ading procedure s frame and the start of the called procedure s frame in order to adjust \nthe frame pointer both before and after the call. In both cases, the adjustment is performed by a single \ninstruction to add (subtract) the displacement to (from) the frame pointer. Exception handlers, debuggers, \nand other tools that need to walk through the frames on the stack must have some way to get from each \nframe to the preceding frame. Our continuation mechanism also requires this ability in order to find \nan appropriate place at which to split the stack (see Section 3.2). In the place of an explicit dynamic \nlink, the compiler places a word in the code stream that contains the size of the frame. This word is \nplaced immediately before the return point so stack walkers can use the return address to find the size \nof the next stack frame. If the return ad\u00address is always placed in a known frame location, the frame \nsize effectively gives the offset from the return address of the current frame to the return address \nof the preceding frame [16]. 3.2 Continuation operations A large initial stack segment and an associated \ncurrent stack record are created in the heap at the beginning of a pro\u00adgram run. Each time a multi-shot \ncontinuation is captured, the occupied portion of the current stack segment is sealed and the current \nstack record is converted into a continua\u00adtion object. This involves setting the size field to the size \nof the occupied portion, i.e., the relative position of the frame pointer within the segment, and storing \nthe current return address in the return address field. (See Figure 2.) The re\u00adturn address in the current \nframe is replaced by the address of an underflow handler that implicitly invokes the captured continuation. \nA new stack record is allocated to serve as the current stack record. Its base is the address of the \nfirst word above the occupied portion of the old stack segment, its link is the address of the old stack \nrecord (the continuation), and its size is the number of words remaining in the old stack sesrment. The \nstack is thus shortened each time a continuation is captured. Creating a multi-shot continuation, therefore, \ndoes not entail copying the stack, but it does shorten the cur\u00adrent stack segment, which eventually results \nin stack over\u00adflow and the allocation of a new stack segment. The initial stack segment is made large \nto reduce the frequency of stack overflows for programs that create many continuations and for deeply \nrecursive programs. Capturing a one-shot continuation is similar to capturing a multi-shot continuation \nexcept that the entire current seg\u00ad ment is encapsulated in the continuation and a fresh stack segment \nis allocated to replace the current stack segment (see Figure 2). Two size fields are required to record \nboth the total size of the segment and the current size. The cur\u00ad 100 Current Stack Segment Previous \nStack Segment ... 4 ...\u00ad 4 current stack record N2 NI + fP-H ---- - --- ~ underflow ,- Figure 1. Thesegmented \nstwkmodel isasimple generalizationof thetraditional staA model. Alogical stack isrepresentedssa list-of \nstack segments that are linked together using s&#38;krecords. Astackrecord contains apointerto the base \nof a stack segment, a pointer to the stack record for the next segment in the stack, the size of the \nsegment, and the return address that is displaced by the underflow handler address. AlthouKh the picture \nshows a frame containing a return address and arguments, the first several arguments and the return address \nmay actualry be p&#38;sed in registers. rent size is the size of the occupied portion of the stack, i.e., \nthe relative position of the frame pointer within the stack segment. Since the total size of a multi-shot \ncontinuation is pre\u00adcisely the size of the occupied portion, the two size fields are always equal in \nmulti-shot continuations, Our system uses this fact to distinguish between one-shot and multi-shot con\u00adtinuations. \nIf the current stack segment is empty when a continua\u00adtion is captured, no changes are made to the current \nstack record and the link field of the current stack record serves as the new continuation. This is necessary \nto implement tail recursion properly. Invoking continuations is more complex. For multi-shot continuations, \nthe current stack segment is overwritten with the stack segment from the continuation, and the frame \npointer is adjusted to point to the top frame of the copied segment (see Figure 3). If the current stack \nsegment is not large enough, a new one is allocated. Since the size of a saved stack segment can be large, \nthe cost of continuation invocation would be bounded only by thhi large amount, if the whole segment \nwere copied at once. This is prevented by placing an upper bound on the amount copied. If the size of \na saved stack segment is less than or equal to this bound, the entire segment is copied. Otherwise, the \nseg\u00adment is first split into two segments such that the size of the top stack segment is less than the \ncopy bound. Although it would be sufficient to split off a single frame, it is more efficient to split \noff aa much as possible without exceeding the bound because of the overhead of splitting the continu\u00adation \nand initiating the copy. See [16] for additional details on splitting. For one-shot continuations, there \nis no need to copy the saved stack segment since the continuation will be involked only once. Thus, the \ncurrent stack segment is discarded and control is simply returned to the saved stack segment. The base, \nlink, and size fields of the continuation are used to reinitialize the current stack record and to reset \nthe frame pointer. (See Figure 4.) Since the contents of the stack segment are not copied, there is no \nneed to split the segment, regardless of its size. To allow subsequent attempts to invoke the continuation \nto be detected and prevented, it is marked shot by setting the size and current size to 1. A typical \napplication involving one-shot continuations obtains the current continuation using cdl/lee, saves the \ncontinuation, and invokes a previously saved one-shot con\u00adtinuation. In this scenario, a new stack segment \nis allo\u00adcated by call/lcc and almost immediately discarded when the saved one-shot continuation is invoked. \nThis rapid al\u00adlocation and release of stack segments can overtax the stor\u00adage management system. A solution \nto this problem is to use some type of stack segment cache, which can be rep\u00adresented se a simple internally \nlinked free list of stack seg\u00adments. When a one-shot continuation is invoked, the current stack segment \nis added to the cache, and when call/1 cc re\u00adquires a new segment, the stack cache is checked before \na new segment is allocated. The stacks in this cache can be discarded by the storage manager during garbage \ncollection. Without a stack segment cache, we found that many pro\u00adgrams written in terms of call/lcc \nwere unacceptably slow, much slower than the equivalent programs written in terms of call/cc. Stack overflow \ncan be treated as an implicit call/cc [16], although since overflow occurs when the current stack seg\u00adment \nhas insufficient space, a new current segment must be allocated. Improper overflow handling can result \nin bourtc\u00ading, in which a program makes a call that overflows the stack, underflows immediately by returning \nfrom the call, Before capture After capture using call/cc Initial Stack current stack record Initial \nStack Segment current stack record captured multi-shot continuation Segment (split) A BN3 + t FWi N2 \nN2 RA *  flmm t4 underflow After capture using call/lcc Initial current captured Stack one-shot \nstack Segment continuation recordFresh Stack Segment ...... A N4 L F Ww#fIowt p-I tmdetik .. .... . \n Figure 2, Stackrecordsinthenew systemhaveanadditional field that specifieshowmuch of the stacksegmentiscurrently \nin use. For multi-shot continuations the current size is always equal to the size of the segment. For \none-shot continuations they alwa~sdMer. call\\cc creates a multi-shot continuation by seahng off the stack \nsegment at the current frame and using the remainder of the stack as thenew stack segment, call/lcc encapsulates \nthe entire current stack segment in the captured continuation and allocates afresh stack segment. Both \noperations also allocate and initialize anew current stack record. immediately makes another call that \noverflows the stack, tagless G-machine [19] to solve essentially the same prob\u00adand so on. Treating overflow \nas an implicit call/cc avoids lem [18]. We found that, without the hysteresis provided by the bouncing \nproblem since the entire newly allocated stack this mechanism, there was a noticeable performance degra\u00admust \nbe refilled before another overflow can occur. dation in certain programs. With this mechanism in place, \ndeeply recursive programs run faster than with overflow Stack overflow can be treated as an implicit \ncall/lcc in\u00adtreated as an implicit call/cc, due to the decrease in copying. stead. Doing so naively, \nhowever, can cause bouncing, since an immediate underflow switches back to the saved (full) stack, at \nwhich point a call is guaranteed to cause a stack 3.3 Promotion overflow. This problem can be reduced \nby copying up sev\u00aderal frames on overflow from the current stack segment into As discussed in Section \n2, it is necessary to promote one\u00adtlw newly allocated stack segment. The overflow continua-shot continuations \nin the continuation of a call to call/cc to tion thus includes the portion of the stack segment that \nis multi-shot continuations. Promotion of a one-shot contin\u00adnot copied. A similar mechanism is used in \nthe spineless uation is trivial given our representations of one-shot and Invoking multi-shot Before \nreinstatement current continuation  &#38;EUI +\u00ad multi-shot continuation Al innI Figure 3. When a multi-shot \ncontinuation is invoked, the contents continuations After rei~staterr)e~t 4 current continuation tap \nframe 4\u00ad multi-shot continuation of the saved stack segment is copied into the current stack segment. \nIf the size of the saved stack se~ment is meater than the conv-bound. the se~ment is first relit into \ntwo sezments ~161. If the current stack segment is not large enou~h to hold-the contents of the ;aved \nst&#38;k seg;ent, a new sta;k segment is afiocated. 4 multi-shot continuations: promotion simply sets \nthe size of a one-shot continuation equal to its current size. Since the current continuation at any \npoint may include a chain of one-shot continuations, it is necessary to iterate down the chain until \na multi-shot continuation is found, resetting all one-shot continuations along the way. It is not necessnry \n to iterate beyond a multi-shot continuation in the chain be\u00adcause the operation that created the multi-shot \ncontinuation would have reset all one-shot continuations below it in the chain. Although the linear traversal \ninvolved in the pro\u00admotion of one-shot continuations captured by caU/cc means that there is no hard bound \non the speed of call/cc opera\u00adtions, there is no quadratic time complexity problem because a one-shot \ncontinuation can be promoted only once. One solution that would allow call/cc to run in bounded time \n(which we have not implemented) is to share a boxed flag among all one-shot continuations in a chain. \nAll of the one\u00adshot continuations could then be promoted simultaneously by simply setting the shared \nflag. Even if the system did not promote one-shot continu\u00adations created explicitly by the program, it \nwould still be obligated to promote one-shot continuations created implic\u00aditly as the result of a stack \noverflow. 3.4 Stack segment fragmentation Internal fragmentation can result from the inclusion of unoc\u00adcupied \nmemory in the stack segments of one-shot continua\u00adtions. With a default stack size of 16KB, 100 threads \ncreated using call/lcc occupy 1.6MB of memory. Unless each of the threads is deeply recursive, most of \nthis storage is wasted. Multi-shot continuations, in contrast, do not cause fragmen\u00adtation because saved \nsegments contain no unused storage. One way to decrease fragmentation is to use a small de\u00adfault stack \nsize. This would penalize deeply recursive pro\u00adgrams and programs that create many multi-shot continu\u00adations, \nhowever, because they would overflow more often. Another solution, which we are currently using, is to \nlimit the amount of unused memory encapsulated in the stack record of a one-shot continuation by sealing \nthe current stack segment at a fixed displacement above above the occupied portion of the stack. We then \nuse the remaining portion of the stack segment as the new current stack segment rather than allocating \na fresh stack (possibly from the stack cache). 4 Performance We have added one-shot continuations to \nthe implementa\u00adtion of Chez Scheme while maintaining support for call/cc, dynamic-wind [8], and multiple \nreturn values [3]. To determine the benefit of one-shot continuations for programs in which call/cc can \nbe replaced by call/1 cc, we modified the call-intensive talc program [11] so that each call captures \nand invokes a continuation, either with call/cc or with call/l cc. The version using call/1 cc is 13% \nfaster than the version using call/cc and allocates 23% less memory. Invoking one-shot continuations \nBefore reinstatement After reh?staten?ent current continuation .... 4 +.. discarded stack segment N1 \nt + I 1 I one-shot continuation 4 current continuation shot one-shot continuation Dfi + top f%miA...1 \nfrarma N2N3 RA ++ ! -1 -1 ,&#38; Figure 4. Whenaone-shotcontinuationisinvoked,thecurrentstacksegmentisdkcarded,andthecontentsofthestackrecordfor \nthe one-shotcontinuation is usedto update the current stack record. The size and current size of the \none-shot continuation are then set to -1 to indicate that the continuation has been shot. We also compared \nthe performance of three versions of a thread system, one implemented using call/cc, one using call/lee, \nand one using continuation-passing style (CPS). The continuation-passing style version simulates a heap\u00ad \nbased representation of control, although it does not in\u00ad clude the additional overhead for supporting \ndynamic-wind. Figure 5 compares run times for different context-switch frequencies for 10, 100, and \n1000 active threads. The fig\u00adure shows that call/lcc threads are consistently faster than calZ/cc threads, \nalthough the advantage is minimal for low context switch frequencies, as is to be expected. The fig\u00adure \nalso shows that, although the CPS version is faster than either of the other versions for extremely rapid \ncontext switches (more often than once every four procedure calls), it loses its advantage quickly as \nthe number of procedure calls between context switches increases. To determine the benefit derived from \nusing one-shot continuations rather than multi-shot continuations for han\u00addling overflows, we compared \nthe performance of a program that repeatedly recurs deeply (one million calls) while doing very little \nwork between calls. In thk extreme case over\u00adflow handling using one-shot continuations is 300% faster \nand allocates much less. In fact, after the first recursion, the one-shot version always finds fresh \nstack segments in the stack cache and so allocates very little additional mem\u00adory. For real programs \nthe difference is typically much less dramatic. 5 Conclusions In this paper, we have introduced one-shot \ncontinuations, shown how they interact with traditional multi-shot con\u00adtinuations, and described a stack-baaed \nimplementation of control that handles both multi-shot and one-shot contin\u00aduations, includlng the promotion \nof one-shot continuations to multi-shot continuations when captured by a multi-shot continuation. We \nhave described how the copying overhead incurred by multi-shot continuations can be eliminated for one-shot \ncontinuations. Our performance analysis shows that two important classes of applications benefit from \nthe use of one-shot con\u00adtinuations: deeply recursive programs and continuation\u00adintensive applications \nsuch as thread systems with rapid context switching, In other cases, the copying overhead associated \nwith multi-shot continuations appears to be in\u00adsignificant. For example, one-shot continuations are only \na few percent faster than multi-shot continuations in our thread benchmarks when context switches occur \nless fre\u00adquently than once every 128 function calls. Others have proposed using a heap-baaed representation \n fll CPS threads ~ call/cc threads ~ call/lcc threads 16 32 64 128 25624 8 1.0 threads 28160 .l CPSthreads \n~ call/cc threads 24640 El call/lcc threads 21120 17600 14080 10560 Ly.  7040 3520 b %&#38;+ o 1 2 41 \n8 16 32 64 128 256 1100 threads 300560 . CPSthreads call/cc threads 262990 call/lcc threads 225420 \n187850 150280 112710 75140 37570 0 25664 128 16 32 11000 threads 24 81 Figure 5. These graphs show the \nrelative performance of CPS, cali/cc, and call/lcc versions of athreaci system. Each run involved 10, \n100, OrlOOOactive threads each computing the 20th Fibor~acci number using thesimple doubly recursi\\'e \nalgorithm. Context switch frequency isshown varying from once every procedure call through once every \n512 procedure calls. Theperforrnance wes measuredon a 96MB DEC Alpha 3000/600 running OSF/11. Times are \nshown in milliseconds. 105 of control, in which control stacks arerepresented as linked [2] Andrew W. \nAppel and Zhong Shao. An empirical and lists of frames rather than as true stacks. This approaches analytical \nstudy of stack vs. heap cost for languages used by Appel and MacQueen [1] in a compiler for ML [17]. \nwith closures. Technical Report CS-TR-450-94, Prince-Appel and Shao [2] have compared their heap-baaed \nap-ton University, March 1994. Revised version to appear proach to a simulated stack-baaed approach and \nfound them in Journal of Functional Programming. to have approximately the same per-frame overhead (an \nav\u00aderage of 7.5 and 7.4 instructions per frame, respectively) [3] J. Michael Ashley and R. Kent Dybvig. \nAn efficient implementation of multiple return values in scheme. Inwhen potential negative cache effects \nassociated with the Proceedings of the 1994 ACM Conference on Lisp andheap-based approach are factored \nout. They attribute 3.4 Functional Programming, pages 140-149, July 1994. instructions of the 7.4 instruction \nper frame overhead for stack-based implementations to closure creation costs. We [4] Robert G. Burger, \nOscar Waddell, and R. Kent Dyb\u00adhave analyzed a large set of benchmark programs and have vig. Register \nallocation using lazy saves, eager restores,found, however, that the overhead in our system is actu\u00adand \ngreedy shuffling. In Proceedings of the SIGPLANally much lower, on the order of 0.1 instructions per \nframe. 95 Conference on Programming Language Design and In particular, they report a closure creation \ncost overhead Implementation, pages 130-138, June 1995. of 5.75 instructions per frame for the Boyer \nbenchmark, whereas our implementation allocates no closures at all. One [5] William Clinger, Jonathan \nA. Rees, et al The revised possible explanation for this discrepancy is that Appel and report on the \nalgorithmic language Scheme. LISP Shao s simulated stack model uses a CPS-baaed compiler Pointers, 4(3), \n1991. with stack-allocated continuations that inhibits the sharing among frames that derives automatically \nfrom a direct-style [6] William F. Clocksin and Christopher S. Mellish. Pro\u00ad compiler employing a true \nstack-baaed representation of con\u00adgramming in Prolog. Springer-Verlag, second edition, trol. For example, \na variable live across several calls must 1984. be copied into each continuation frame in their model; \nthe same variable in our stack-based implementation can remain [7] Christopher T. Haynes Daniel P. Friedman \nand Mitchell in the same stack location across all calls without incurring Wand. Obtaining coroutines \nwith continuations. Com\u00adany overhead. puter Languages, 11(3/4):143-153, 1986. In spite of the performance \nadvantages of a stack-based approach for most programs, it is tempting to conclude that [8] R. Kent Dybvig. \nThe Scheme Programming Language. a heap-based approach is a better choice for thread sys- Prentice Hall, \nsecond edition, 1996. tems implemented using continuations because of the copy\u00ad [9] R. Kent Dybvig and \nRobert Hieb. Engines from con\u00ading overhead incurred by multi-shot continuations and the tinuations. Computer \nLanguages, 14(2):109 123, 1989. relatively more complex implementation of stack-baaed con\u00adtinuations. \nWe have shown, however, that a simple heap\u00ad[10] Mathias Felleisen. Transliterating Prolog into Scheme. \nbased implementation is superior only if context switches Technical Report 182, Indiana University, October \noccur more frequently than once every eight procedure calls 1985. (about once every four for call/lee). \nWhile various com\u00adpiler optimizations can be introduced to make the heap [11] Richard P. Gabriel. Performance \nand Evaluation of model more competitive, the complexity of these optimiza-LISP Systems. MIT Press, Cambridge, \nMA, 1985. tion more than compensates for the difference in represen\u00adtation complexity without fully eliminating \nthe performance [12] Emden R. Gansner and John H. Reppy. A multi\u00addifferential. threaded higher-order \nuser interface toolkit. In User With stack overflow treated as an implicit call to call/lee, Interface \nSoftware. John Wiley &#38; Sons Ltd, 1993. deeply recursive programs that do not use multi-shot con\u00ad \n[13] Paul Haahr. Montage: Breaking windowing into smalltinuations do not incur any copying overhead on \nstack un\u00adpieces. In USENIX Summer Conference, pages 289\u00adderflow. Since this can result in significant \nsavings, a stack\u00adbased implementation should use one-shot continuations in\u00ad 297, Anaheim, June 1990. \nternally to handle stack overflow, even if the implementation [14] Christopher T. Haynes. Logic continuations. \nLISPdoes not otherwise support calt\\l cc. The same mechanism Pointers, pages 157-176, 1987. is also applicable \nin the context of thread packages for lan\u00adguages such as C and Fortran that do not support first-class \n[15] Christopher T. Haynes and Daniel P. Friedman. Ab\u00adcontinuations. In this context, the segmented stack \npermits stracting timed preemption with engines. Computerthe use of large numbers of threads while supporting \narbi-Languages, 12(2) :109-121, 1987. trary recursion, since it is possible to allocate threads with \nrelatively small stacks that grow on demand. This fact was [16] Robert Hieb, R. Kent Dybvig, and Carl \nBruggeman, observed by Peyton-Jones and %.lkild in the context of the Representing control in the presence \nof first-class con- Spineless Tagless G-machine [19]. tinuations. In Proceedings of the SIGPLAN 90 Con\u00adference \non Programming Language Design and Imple\u00admentation, pages 66 77, June 1990. References [17] Robin Milner, \nMads Tofte, and Robert Harper. The [1] Andrew W. Appel and David B. MacQueen. Standard Definition of \nStandard ML. MIT Press, Cambridge, ML of New Jersey. In Proceedings of the Third Inter\u00ad 1990. national \nSymposium on Programming Language Imple\u00admentation and Logic Programming, pages 1 13, August [18] Simon \nL. Peyton-Jones. private communication, De\u00ad1991. cember 1991. 106 [19] Simon L. Peyton-Jones and Jon \nSalkild. The spine\u00adless tagless G-machine. In Proceedings of the Fourth Conference on Functional Programming \nand Computer Architecture, pages 184-201, September 1989. [20] R. Pike. A concurrent window system. Computing \nSys\u00adtems, 2(2):133-153, 89. [21] John H. Reppy. CML: A higher-order concurrent lan\u00adguage. In Proceedings \nof the SIGPLAN 91 Conference on Programming Language Design and Implementation, pages 293-305, Toronto, \nJune 1991. [22] Gerald J. Sussman and Guy L. Steele Jr, Scheme: An interpreter for extended lambda calculus. \nAI Memo 349, Massachusetts Institute of Technology Artificial Intelli\u00adgence Lab, 1975. [23] Oscar Waddell. \nThe Scheme Widget Library User s Manual. Indiana University, Bloomington, Indiana, 1995!  \n\t\t\t", "proc_id": "231379", "abstract": "Traditional first-class continuation mechanisms allow a captured continuation to be invoked multiple times. Many continuations, however, are invoked only once. This paper introduces <i>one-shot</i> continuations, shows how they interact with traditional multi-shot continuations, and describes a stack-based implementation of control that handles both one-shot and multi-shot continuations. The implementation eliminates the copying overhead for one-shot continuations that is inherent in multi-shot continuations.", "authors": [{"name": "Carl Bruggeman", "author_profile_id": "81100269459", "affiliation": "Indiana University Computer Science Department, Lindley Hall 215, Bloomington, Indiana", "person_id": "P40685", "email_address": "", "orcid_id": ""}, {"name": "Oscar Waddell", "author_profile_id": "81100242452", "affiliation": "Indiana University Computer Science Department, Lindley Hall 215, Bloomington, Indiana", "person_id": "P212431", "email_address": "", "orcid_id": ""}, {"name": "R. Kent Dybvig", "author_profile_id": "81100181541", "affiliation": "Indiana University Computer Science Department, Lindley Hall 215, Bloomington, Indiana", "person_id": "PP14073331", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/231379.231395", "year": "1996", "article_id": "231395", "conference": "PLDI", "title": "Representing control in the presence of one-shot continuations", "url": "http://dl.acm.org/citation.cfm?id=231395"}