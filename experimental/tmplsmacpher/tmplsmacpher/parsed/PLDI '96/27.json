{"article_publication_date": "05-01-1996", "fulltext": "\n A Framework for Generalized Control Dependence Gianfranco Bilardi Keshav Pingali DEI, University di \nPadova, 35131 Padova, Italy Department of Computer Science EECS, University of Illinois, Chicago, IL \n60607 Cornell University, Ithaca, NY 14853 Abstract We generalize the notion of dominance by defining \na generalized dominance relation with respect to a set of paths in the control flow graph G = (V, E). \nThis new definition leads to a generalized notion of control de\u00ad pendence, which includes standard control \ndependence and weak control dependence as special cases. If the set of paths underlying a generalized \ndomi\u00ad nance relation satisfies some natural closure conditions, that dominance relation is tree-structured. \nGiven this tree, the corresponding control dependence relation can be computed optimally by reduction \nto the Roman Chariots Problem, which we have developed previously for computing standard control dependence. \nMore pre\u00ad cisely, given linear preprocessing time and space, we can answer the (generalized version of \nthe) so called cd, conds, and cdequiv queries in time proportional to the output of the query. To illustrate \nthe utility of the framework, we show how weak control dependence can be computed opti\u00ad mally in 0( [El) \npreprocessing space and time. This improves the 0(] V/3) time required by the best previ\u00ad ous algorithm \nfor thh problem. Introduction Control dependence was introduced by Ferrante, Ot\u00ad 1 Gimfr~~~ Bil~di (bilwdi@wt \n.dei.unipd.it) wss supported in part by the ESPRIT III Basic Research Programme of the EC under contract \nNo. 9072 (Project GEPPCOM) and by the Italian Ministry of University and Research. 2Keshav Pingali (pingali@cs.cornell \n.edu) was supported by NSF grants CCR-9008526 and CCR-9503199, ONR grant NOOO1493-1-O1O3, and a grant \nfrom Hewlett-Packard Corpora\u00adtion. Permissiontomakedigitabhardcopy ofpartorallofthiswork for personal \nor olaesroomuse is ranted without fee provided that copies are not made ! or distributed for pm It or \ncommercial advanta e, the copyright notice, the titie of the ublication and its date efmaar, an i notice \nis given that t copying IS y permission of ACM, Inc. To copy otherwise, to republish, to postonservers,orto \nredistributeto lists,requirespriorspecificpermission andlor a fee. PLDI 96 5/96 PA, USA @ 1996 ACM O-69791 \n-795-2/96fOO05...$505O tenstein and Warren [FOW87] to solve a number of problems in program analysis \nand parallelization. In thk paper, we refer to it as classical control depen\u00addence since it was the first \nformalization of the intu\u00aditive idea that the execution of predicate nodes in a program determines how \ncontrol flows through a pro\u00adgram, For some applications, other definitions of con\u00adtrol dependence have \nproved to be useful, For exam\u00adple, Podgurski and Clarke have proposed the notion of weak control dependence \nfor proving total correctness of programs [P C90]. Both classical and weak control dependence are reviewed \nin Section 2. In Section 3, we present a generahzed notion of con\u00adtrol dependence, and show that classical \nand weak con\u00adtrol dependence are special cases of this general defi\u00adnition. We do thhi as follows. First, \nwe define a gen\u00aderalized notion of dominance whzch is parametrized with respect to a set of paths in \nthe control flow graph (CFG). Then, we use this to generalize the notion of control dependence in a natural \nway, and show that classical and weak control dependence are special cases of this general notion of \ncontrol dependence. Appli\u00adcat ions of cent rol dependence usually require answers to queries known as \ncd, conds, and cdequiv in the literature [CFS90]. For classical control dependence, we have developed \nan optimal computational approach based on a reduction to the Roman Chariots Prob\u00adlem [PB95], For generalized \ncontrol dependence, we show that if the set of paths used in the underlying dominance relation satisfies \nsome natural closure prop\u00aderties, the dominance relation is tree-structured; for such control dependence \nrelations, our solution to the Roman Chariots Problem immediately provides an op\u00ad timal computational \napproach. In Sections 4 and 5, we focus on weak control depen\u00addence, and its underlying dominance relation, \nwhich we call loop postdominance, In Section 4, we show that the loop postdominance relation is tree \nstructured, and that its transitive reduction, the loop postdominance forest, is a pruning of the standard \npostdominator tree, This fact was proved earlier by Podgurski in his the\u00adsis [Pod89]. However, we give \na new characterization of the set of edges to be pruned, in terms of a set of nodes called crowng. In \nSection 5, we give an 0( IE I) algo\u00adrithm based on depth-first search for computing the set of crowns, \nCrowns are used to build the loop post dom\u00adinator forest in 0(1231) time, Using this data structure, \nwe exploit our solution to the Roman Chariots Prob\u00adlem to solve the problem of answering cd, conds and \ncdequiv queries on the weak control dependence rela\u00adtion optimally (that is, in 0(1.EI) preprocessing \ntime, and query time proportional to the size of the answer to a query). This improves the 0( IV13) preprocessing \ntime required by Podgurski and Clarke s algorithm for answering cd and conds queries; it also provides \nan optimal algorithm for answering cdequiv queries. 2 Two Control Dependence Re\u00adlations The following \ndefinitions are standard. Definition 1 A control flow graph (CFG) G = (V, E) is a directed graph in which \nnodes represent statement, and an edge u ~ v represents possible jlow of control from u to v. Set V contains \ntwo distinguished nodes: START, with no predecessors and from which ev\u00adery node is reachable; and END, \nwith no successors and reachable from evey node. It is convenient to assume that E contains edges START \n+ END (as in [FOW87]) and END + END. Definition 2 A node w postdominates a node v if every path from \nv to END contains w. If, in addition, w # v, then w is said to strictly postdominate v. It can be shown \nthat postdominance is a transi\u00adtive relation with a tree-structured transitive reduction called the postdominator \ntree, which can be constructed in O(ll?la( IEI)) time by an algorithm due to Tarjan and Lengauer [LT79], \nor in 0( IEI ) time by a rather more complicated algorithm due to Harel [Har85]. Classical control dependence \ncan be defined formally as follows [FOW87]. Definition 3 A node w is control dependent on edge (u --+v) \nc E if 1. w postdominates v, and 2. w does not strictly posidominate u.  Intuitively, this means that \nif control flows from node u to node v along edge u -+ v, it will eventually reach node w; however, control \nmay reach END from u with\u00adout passing through w. Thus, u is a decision-point that influences the execution \nof w. Figure 1 shows a CFG, its postdominator tree and its classical control dependence relation. We \nwill often use the term con\u00adtrol dependence, without any qualifications, to refer to classical cent rol \ndependence. Podgurski and Clarke have introduced weak control dependence [PC90], which is more appropriate \nthan the classical one for proving tot al correctness of pro\u00adgrams. In this paper, we call it loop control \ndepen\u00addence because we give an alternative definition of it based on the concept of loop postdominance, \ngiven be\u00adlow, Figure 1 shows a program in which classical and loop control dependence differ. Consider \nnode k in the CFG. In the classical notion, k is control dependent on g + a. However, to prove that k \nwill be executed, it is necessary to prove that the loop a + b + a terminates, Therefore, in the context \nof proving total correctness of programs, it is more appropriate to make k loop con\u00adtrol dependent on \nthe exit of the loop namely, the edge b + k. In programs without cycles, the classical and loop cent \nrol dependence relations are ident ital. Definition 4 A.wume that END ~ END G E. A node w loop postdominates \na node v if every infinite path starting at v contains w. If, in addition, w # v, then w is said to strictly \nloop postdominate v. In other words, if control reaches a node v, and w loop postdominates v, then control \nwill reach w in a finite number of steps, whether or not the program ter\u00adminates (that is, whether or \nnot control reaches END). Definition 5 A node w is loop control dependent onedge(u+ v)6E if 1. w loop \npostdominates v, and 2. w does not strictly loop postdominate u,  Intuitively, this means that (i) \nif control reaches v, it must reach w in a finite number of steps, and (ii) from u, it is possible for \ncontrol to reach a cycle of nodes (possibly, the self loop at END) without encountering w. It can be \nshown that loop control dependence is equivalent to Podgurski and Clarke s weak control de\u00adpendence. \nIn applications of any control dependence relation, the following queries arise naturally for a given \nedge e or node v [CFS90]: 1. cd(e): whkh nodes are control dependent on e? 2. conds(v): which edges \nis w control dependent on?  3, cdequiv(v): which other nodes are control depen\u00addent on the same set \nof edges as v?  3 The Framework We now discuss a general framework which unifies clas\u00adsical and weak \ncontrol dependence, and supports the design of optimal algorithms for answering queries on such relations. \n ~TART Q? END ENDg Aa cd \\ <~@sTMT k og START e f Ifl b be bef k ii UI h acd ac d ND (a) Control \nFlow Graph POstdominator forest WK?@!!Mator tr~ (c) ~P abcdefghk START -g 0 g-d O 0 g--a 0 D : control \ndependence f--c n 0 e-d D cl  o : loop control de~ndence b da a 0 e -h c1 f--h 0 b+k m 1 (d) \nControl Dependence and Loop control dependence Figure 1: A Program and Two Control Dependence Relations \nBy the standard definition of postdominance, w post-Definition 8 dominates v if every path from v to \nEND contains w. In 1. S: the set of jinite paths starting at START. other words, all terminating executions \nthat reach v S-dominance = predominance (classical domi\u00adeventually reach w. We generalize this notion \nby con\u00ad nance). sidering an arbitrary class of possible executions, mod\u00ad 2. &#38;: the set of finite \npaths ending at END. eled as a set of paths P in the CFG. Different notions &#38;-dominance = postdominance. \nof dominance and, mrrespondlngly, of control depen\u00ad 9. B: the set of jinite paths from START to END. \ndence, arise from different choices for P. B-dominance = predominance OR postdominance. Let 1 be a (possibly \ninfinite) interval on the integer 4. L: the set of left-injinite paths. line. A path of the CFG is a \nsequence of nodes {vi E V : L-dominance = loop predominance. i~ 1} such that ifi, i+l elthen (vi ~vi+l) \ncl?, A 5. R: the set of right-infinite paths. path is finite, of /eng-th n, when 1 = {O, 1,,,., n} and \nI?-dominance = loop postdominance. becomes trivial when n = 0, A path is Tight infinite In the following \ntwo subsections, we study properties when I is the set of positive integers and is left infinite of P \nthat lead to a forest-structured dominance rela\u00ad when I is the set of negative integers. tion and enable \nthe formulation of control dependence Definition 6 Given a set of paths P in a directed queries in terms \nof the Roman Chariots Problem. graph G = (V, E), let PO denote the subset of paths in P that contain \nv c V. We say that v P-dominates 3.1 The P-dominance Relation u, denoted v 1-u, if and only if Pu 2 \nPu. The following properties of a set of paths P are of in- Technically, l-p would be a more appropriate \nnota\u00adterest: tion; we omit the subscript for simplicity. Definition 9 Definition 7 We say that w E V \nis P-control de\u00adpendent upon edge (u -v) c E if Prefix Closure: Any pre$x of a path in P is in P. SuKix \nClosure: Any sufix of a path in P is in P. 6wl-v, and Junction Closure: Whenever xl VIr2 and u] VC72are \n ifu #w, thenw vu, in P, then 7rlvu2 is also in P. Here are some interesting path sets, and the corre-Preaugmentation \nClosure: If (u + v) c E and sponding dominance relations. (VT) c P then (UWT) E P. Postaugmentation Closure: \nIf (u -v) 6 E and (7ru) c P then (7ruv) E P. It is easy to verify that S and C satisfy prefix, postaugmentation, \nand junction closure, $ and R satisfy suffix, preaugment ation, and junction closure, while B satisfies \njunction closure, It is trivial to show that suffix and preaugmentation closure (or symmetric\u00adally, prefix \nand postaugmentation closure) of P imply junction closure of P. Next, we establish sufficient conditions \non P that guarantee that the P-dominance relation is forest\u00adstructured. Theorem 1 Let P be a set of paths \nwith prefix (or sufix) and junction c.logure, such that get Pv s are not empty and are distinct from \neach other. Then, P-dominance ia a partial order (i. e., a reflex\u00ad ive, trarwitive, an d anti~ymmetric \nrelation), and its transitive reduction ia forest-structured (i. e., a node has at most one predecessor \nin the reduction). Proofi Reflexivity and transitivity follow from Defini\u00ad tion 6 and the analogous properties \nof set inclusion. Antisymmetry follows from the distinctness of the P. s. Below, we assume suffix closure, \nthe argument for pre\u00ad fix closure being similar. We begin by claiming that (v E u and w E u) implies \n(v E w or w 1-v). In fact, let T G Pu (exploiting the assumption that Pa is not empty). By definition \nof dom\u00ad inance, ir contains both v and w. BY the suffix property, assume that m starts at u and, w.1.o.g,, \nassume that v occurs before w on T. Then, we can write T = m vm, with ~1 w-free, Let now u = al vuz be \nany path in Pv. By the junction property, T1 voz c Pu, hence it contains w. Since ml is w-free, w must \noccur on uz. Therefore, u c PW, In conclusion, Pw ~ P~, hence w ~ V. Assume that (u, v) and (u, w) are \nrelated by the tran\u00adsitive reduction of P-dominance. We claim that v = w. In fact, by the previous claim, \neither v dominates w or vice versa. Say v 1-w, Then, u 1-w is a transitive conse\u00adquence of u 1-v and \nv 1-w; therefore the pair (u, w) can not be in the transitive reduction, unless w = v. In con\u00adclusion, \nat most one node can immediately P-dominate u, which implies that the P-dominance relation is forest\u00adstructured. \nl Theorem 1 and the observations preceding it imme\u00addiately lead to the following result. Corollary 1 \nThe transitive reductions of the classical dominance relation, clawical poddominance relation, loop predominance \nrelation, and loop postdominance re\u00adlation are all forest-structured, It is useful to represent the transitive \nreduction of a P-dominance relation as a graph, called the D\u00adominance graph. Under the assumptions of \nTheorem 1, this graph is a forest, directed from root to leaves. It is convenient to make this forest \ninto a tree by adding to V a distinguished node m and an edge from it to each node of V with no parent \nin the forest (such as nodes g,b,e and ~ in Figure 1). Node m is not shown in Figure l(c) to avoid cluttering \nthe diagram. The tree just introduced will be referred to as the P-dominator tree, In it, each node v \nE V has a parent called the immediate P-dominator of v, and de\u00adnoted iPdom(v). When P = S, the P-dominator \ntree becomes the classical dominator tree, and iPcZom(v) is the immediate dominator of v. Similarly, \nwhen P = &#38;, the classical postdominator tree is obtained and iPdom(v) is the immediate post dominator \nof v.  3.2 Control Dependence Computations and the Roman Chariots Problem In [PB95], it was shown that \nthe computation of clas\u00adsical control dependence can be reduced to the Ro\u00adman Chariots Problem. Based \non the following result, we extend this reduction to any forest-structured P\u00addominance relation. Theorem \n2 Given a P-dominator tree and a control f?ow edge (u + v) ~ E, let z denote the lead com\u00ad mon ancestor \n(denoted by lea) of v and iPdom(u). Then, the nodes of V that are P-control dependent upon (u -+ v) are \nexactly those in the simple path in the P\u00ad dominator tree from v to z, not including z. Proofi Consider \na node w that is P-control dependent upon (u ~ v). With reference to the two clauses of Definition 6, \nwe have: w must P-dominate v hence, by the tree-structured property, must lie on the path 1% from v \nto the root eo of the P-dominator tree;  if w # U, then w must not P-dominate u hence, by the tree-structured \nproperty, must lie outside the path ~i~dOm(W) from ipdom(u) to the root co of the P-dominator tree. \n Then, w must lie on u. ui~dOm(U). This difference is a path starting at v and going up to, but not \nincluding the first intersection of u. and u~~d~~(~), which is the nearest common ancestor z of v and \niPdorn(ti), For example, in Figure 1, the nodes that are loop control dependent on (g -d) are d and ~. \nThe im\u00admediate loop post dominator of g is m, and the least common ancestor of d and m is m. The nodes \nthat are loop control dependent on (g ~ d) are the nodes on the path from d to oo, excluding cm namely, \nnodes d and f. Given the P-dominator tree, this least common an\u00adcestor computation for all CFG edges \nsimultaneously can be done in 0( 1El) timeusing the well-known algo\u00adrithm of Harel and Tarjan [HT84]. \nWe now recall the formulation of the Roman Chari\u00adots problem. Roman Chariots Problem: The major arteries \nof the Roman road system are organized as a rooted tree in which nodes represent cities, edges represent \nroads and the root represents Rome, Public transportation ia provided by chariota, and the cities on \neach chariot route are totally ordered by the ancestor relation in the tree. Given a rooted tree T =< \nV, F, ROME > and an array A[l.. m] of chariot routes in which each route is specified by its end points, \ndesign a data structure to answer the following queries optimally. 1, cd(e): Enumerate the cities on \nroute e. 2. conds(v): Enumerate the routes that serve city v. 9. cdequiv(v): Enumerate the cities served \nby ex\u00adactly the same routes that serve city v. To make the connection with the control dependence problem, \nlet the P-dominator tree be the rooted tree T. For each edge (u + v) 6 E, insert in array A a cJmr\u00adiot \nroute with endpoints v and lca(v, i~dorn(u)), as described in Theorem 2. Then, a control dependence query \ncan be reformulated immediately as a Roman Chariots query. Therefore, these queries can be pro\u00adcessed \nin time proportional to their output size, using the APT (augmented P-dominator tree) data struc\u00adture \nintroduced in [PB95]. Therefore, given a CFG G = (V, E) and a set of paths P satisfying the assumptions \nof Theorem 1, we can build a data structure to answer P-control depen\u00addence queries optimally, provided \nwe can build the P\u00addominance tree efficiently,  3.3 An Important Special Case For classical control \ndependence, it is well-known that the nodes that are control dependent on a given edge form a simple \npath in the postdominator tree [FOW87]. Indeed, in this special case, a stronger property holds: if (u \n+ v) c l?, then iPdorn(u) is an ancestor of v. Therefore, we see that the least common ancestor of v \nand iPdom(u) is z = iPdorn(u), and this node can be identified without recourse to the Harel and Tarjan \nalgorithm, Although not essential, this property does simplify the reduction to the Roman Chariot Problem, \nand it can be useful in other ways. We show below that suffix and preaugment ation closure are sufficient \nconditions for it. (As these two properties together imply junction closure, Theorem 1 holds, ) Proposition \n1 Let P be a set of paths with M@x and preaugmentation closure. If (u 4 v) E E, then evey VT i.e.7 ~Pdom(u) \nis an ancestor of v. w # u that P-dommatm u aho p.ifom~nafe~ Proofi Let r G Pu. Then, T contains v and \nhence a suf\u00adfix of the form va. Due to suffix closure, (va) E P,. Due to the preaugmentation property, \nwe have that (UVU) G P, As u occurs on this path, any w that P\u00addominates u must also occur on it, in \nparticular (being w # u) w must occur on the portion vu, Since the latter is a suffix of m, we conclude \nthe w occurs on r, and that P.cP.. 1 An analogous proposition holds under prefix and postaugmentation \nclosure. The assumptions of Propo\u00adsition 1 simplify the algorithm considerably, If these assumptions \nare met, then the set of nodes control de\u00adpendent on an edge u + v are simply the nodes on the simple \npath from v to parent(u), excludkg parent(u), The critical step remains the computation of the P-dominator \ntree. Linear time solutions are known [Har85] for P = S and P = &#38;, that is, for the classi\u00adcal dominator \nand postdominator tree. In the rest of the paper, we develop a linear time algorithm for loop postdominance \n(P = 7?).  4 Relating Loop Postdomi\u00adnance to Postdominance We now take a close look at the relation \nbetween 7Z\u00addominance, also called loop postdominance, and ~\u00addominance, i.e., classical postdominance. \nWe shall as\u00adsume that the edge END + END is present in the CFG. Then, the paths in $ (finite paths terminating \nat END) are in a natural correspondence with the right-infinite paths in 77. ~ ?? in which only a finite \nnumber of nodes differ from END, In fact, postdominance could be de\u00adfined by letting P = 77. . It is \na straightforward consequence of Definition 6 that dominance is nondecreasing with the path set P, in \nthe sense that if Q ~ P, then Q-dominance G P\u00addominance. As a corollary (when P = R and Q = 7?), we see \nthat loop postdominance is a subset of postdom\u00adinance. In general, inclusion between two transitive relations \ndoes not imply inclusion between their transitive re\u00adductions. Fortunately, we can show that the loop \npost\u00addominance forest (denoted lpd-fore.d) is obtained by a suitable pruning of the postdominance tree \n(denoted pal--tree). This can be seen in Figure 1 for the running example. First, we introduce some notation. \n v pd u: v postdominates (C-dominates) u;  v lpd u: v loop postdominates (R.-dominates) u;  ipd(a): \ni$dom(a), the immediate postdominator of a;  ilpd(a): i Rdom(a), the immediate loop postdom\u00adinator of \na.  Proposition 2 If ilpd(a) # co then ilpd(a) = ipd(a), Proofi Let b = ilpd(a) G V. By contradiction, \nassume that b # ipd(a). Then, there is a c G V such that b pd c and c pd a. Let z E Ra be a right-infinite \npath starting at a. We distinguish two cases: c END occurs on r. Then, let rl be the smallest prefix \nof r from a to END. Since c pd a, then c occurs on T1, hence it occurs on r and ir c l?.. END does not \noccur on ?r. Since b lpd a, node b must occur on ~. Moreover, since b pd c, there is a c-free path a \nfrom b to END. Let ~1 be the smallest prefix of m from a to b. Then, rl u goes from a to END and, considering \nthat c pd a, it must contain c. Since u is c-free, c must occur on rl, hence it occurs onnand T ~%. In \nboth cases, we see that % C XL, so conclude that c lpd a. By Theorem 1, b and c are ordered by loop postdominance. \nGiven that b = ilpd(a), it must be true that c lpd b which, since loop postdominance im\u00adplies postdominance, \nyields c pd b, in contradiction with b pd c (postdominance is acyclic). From Proposition 2, we see that \nwe can loop postdominance tree by starting with the inator tree, and replacing each edge (ipcZ(v) (m \n-v) for all nodes v for which dpd(v) A computationally convenient characterization nodes (in Figure 1, \nnodes b,e,~,g) is the next necessary concepts are now introduced. El build the postdom\u00ad + v) with # ipd(v). \nof such goal. The Definition 10 With reference to a CFG G = (V, E) and nodes a, w, x E V, we introduce \nthe following ter\u00adminology and notation: w is prereachable from a: ihere is a non trivial path from \na to w not containing ipd(a);  x is a crown: x is prereachable from itself;  K: the set of crowns of \nG;  K*: the set of nodes from which some crown is prereachable.  Clearly, all the nodes of a path from \na to w not con\u00adtaining ipd(a) are strictly postdominated by ipd(a), In Figure 1, e is prereachable from \n~ because the path ~ -+ c + e does not contain ipd(f) = h. Intuitively, this means e is reachable from \nf by a path in whkh all nodes lie within that subtree of the postdominator tree that is rooted at ipd(.f) \n= h. A crown is a node that lies on a cycle that does not cent ain its postdominator. In Figure 1, b \nis a crown since it lies on the cycle a -b + a, and k = ipd(b) does not. Similarly, e and ~ are crowns \nsince they lie on cycle c + e + d + f + c, and h does not, Intuitively, it is clear that if v is a crown, \nthen ilpd(v) and ipd(v) are different nodes because there is an infilte path starting at v that does \nnot contain ipd(v). Note that ipd(g) is distinct from iipd(g) but g is not a crown, However, there is \na path from g to crown ~ (g -+ d -.f) which does not contain ipcl(g). In other words, g 6 K*. We show \nnext that membership in K* identifies all nodes for which ipd(v) is distinct from ilpd(v). Obviously, \nmembership in K is a special case, asK ~ K*. Theorem 3For any a 6 V, if a G K* then ilpd(a) = co else \ni.lpd(a) = ipd(a). Proof: As i.lpd(END) = ipd(END) = cm, the statement is trivially true for a = END. \nHereafter, we assume a # END. Part 1: a E K* ~ ilpd(a) = 00. Consider first the case where there is a \ncrown z prereachable from a. Let C = Z7Z be a cycle containing z but not ipd(z); such a cycle exists \nby Definition 10. Let ax be a path from a to z whose nodes are all strictly postdominated by b = ipd(a); \nsuch a path exists by Definition 10, Clearly, u(z~)* -where * denotes infinite repetition-is a path in \nR. - k?b, showing that T(b lpd a), Therefore, by Proposition 2, ilpd(a) = co, and the then clause is \nestablished. Part 2: ilpd(a) = co ~ a G K . In conjunction with Proposition 2, this establishes the else \nclause. We let b = ipd(a) and assume that -(b lpd a). By definition of loop postdominance, there is a \nb-free right\u00adinfinite path T c X?. starting at a. Since T is infinite, some node must occur repeatedly. \nConsider the shortest prefix ml of ir where a repetition occurs, so that rl has the form uy7y. We claim \nthat all nodes nated by b. Indeed, if some nated by b, the prefix 7r2 of be augmented with a b-free on \nT1 are strictly postdomi\u00adz on rl were not postdomi\u00adml terminating with z could path T to END. The concate\u00ad \nnation T2T would contradicting the Consider now and the nearest tree is not on C, a, hence a 6 K*. To \nsummarize, dominance forest then be a assumption the cycle C ancestor x of Clearly, o is b-free path \nfrom a to END, that b = ipd(a). = YTV, which is part of ml, y whose parent in the pd\u00ada crown prereachable \nfrom 1 the computation of the loop post\u00adhas been reduced to that of set K . In the next section, we shall \nfirst develop an algo\u00adrithm to compute K from G. Then, we show how the well known connection between \nprereachability and conversion of a program to single static assignment form [BJP91, CFR+91, Wei92] can \nbe exploited to compute K* from K.  !5 Optimal Computation of the Loop Postdominance Forest We introduce \na graph called the sibling connectivity graph associated with any CFG, which facilitates the computation \nof crowns. Specifically, while in the CFG a node is a crown if it lies on a cycle that does not contain \nthe immediate postdominator of that node, in the sibling connectivity graph a node is a crown if it simply \nlies on a cycle, 1, Initialize the SCG to (V {END}, 0). 2. For each node v ~ V, create an initially \nempty list L(v). 3. For each edge (x + v), if v # ipd(x) then append (z + v) to list L(v). 4. Create \nan initially empty stack ST.  5. For each node v visited during a depth-first walk over the pd-tree, \ndo: 1. When entering v for the first time, push v on stack ST. For each z + v in L(v), let y be the \nnode pushed immediately on top of ipd(z) in ST, Add edge z+ yto the SCG. 2. When retreating out of v, \npop v from stack ST.   {This computes the SCG.} 6. Determine the set KI of nodes with self loops in \nthe SCG (during its construction), 7. Find the strongly connected components (SCC S)of the SCG. Let \nK2 be the set of nodes contained in SCC Sof two or more nodes. 8. Output K = K1 U K2 as the set of crowns, \n  Figure 2: Computing the Sibling Connectivity Graph and the Set of Crowns g in the SCG. Figure 3 shows \nthe SCG for the running ~TART example; component Gh consists of the set of node; END {e, f} and the edges \nbetween these nodes. a cd k START k ~ STARTi? Proposition 3 The SCG corresponding to a CFG e b @b C~gff \nbef G = (V, E) can be constructed in time O(IVI + [El). k   Q(I! 0 h acd ac do Proofi The procedure \nis shown in Figure 2, steps 1-5. ND A depth-first walk is performed over the postdominator tree, First, \nwe construct a list L of edges at each node v : if x + v is a CFG edge and v is not ipd(x), then this \nedge is entered into list L(v). During the depth-first walk, we (a) Control Flow Graph (b) Postdorninator \ntree (c) Sibling Connectivity Graph Figure 3: The Sibling Connectivity Graph maintain a stack of nodes \nsuch that when the walk is at a node n, the stack consists of the ancestors of n ordered by ancestorship. \nThis is accomplished by pushing a node 5.1 Sibling Connectivity Graph n on the stack when the walk first \nreaches n, and popping it from the stack when retreating out of node n, When In this subsection, we define \nthe sibling connectivity the walk reaches a node v, we examine the list of edges graph and describe a \nlinear time algorithm to compute L(v) : if c + v is an edge in this list, we first locate the it. parent \nof m in the postdominator tree (say p), and then find the node pushed immediately on top ofp in the stack \nDefinition 11 With each node b of CFG G = (V, E), (say y), The SCG has an edge z -+ y, The stack can \nbe we asaociafe a graph Gh = (Vb, Eb) where implemented as a doubly-linked list to support this find \noperation (as well as pushing and popping) in constant time. The correctness of this procedure follows \ntrivially from properties of depth-first search. It is also easy to is the set of children of b in the \npal-tree, and show that the entire procedure takes time proportional to the number of vertices and edges \nin the CFG. l 5.2 Crowns program is called the sibling connectivity graph (SCG). The collection of graphs \nGh fov all nodes b in the In this subsection, we characterize the crowns with re\u00adspect to the SCG and \ndevelop a fast algorithm to com- An intuitive description of the SCG is the following. pute the set K \nof all crowns. Letx+ vbeaCFG edgewith v~ipd(x). Ifyis the sibling of z that is an ancestor of v, the \nSCG has Proposition 4 With the notation of Definition 11, an edge z + y, (a self-loop if y = x), For \nexample, in y C V/b is prereachable from x E Vb in G if and only if Figure 1, edge (g + a) c E, and k \nis the sibling of g y is reachable from x in Gb. that is an ancestor of a; therefore, edge (g + k) occurs \n Proofi Assume first that y is prereachable from z is G, say via path m, Decompose r as UOZ1U17rz...u.-1 \nrrrtr, with U. = x and U7 = y, where UO...W. are those nodes on rr that belong to V~, while the nodes \non ni are descendant of ui in the pal-tree. Such decomposition (possibly, with some of the ir~ s empty) \nis always possible because: 1. by definition of prereachability, all nodes on rr are strictly postdominated \nby b, and 2. if edge u + v is on r, then whenever u and v are descendant of different children of b \nin the pal-tree, then u must be a child of b (by the characterization of CFG edges with respect to the \npd+se).  Now, let w be the node immediately following ui on rr. Then, (ui_l + W) c E implies that (ui_l \n+ u,) 6 Eb. Hence, (z = UO)U1... UP-I (w. = y) is a path from x to y in Gb. For the converse, assume \nnow that y is reachable from x in Gb, say via a path u = UOU1...U,, with uo = x and up = y. Then, for \ni > 0, by Definition 11 of Eb, there is a descendant vi of Wtl in the pal-tree such that (ui + vi) ~ \nE. Clearly, ul+l is reachable (in G) from via a vi path r; entirely postdominated by b (since U;+l pd \nvi). Hence, uom ...7. is a path from uo = z to u. = y. 0 As a corollary of the preceding proposition, \nwe have the following characterization of the crowns. Proposition 5 A node x is a crown if and only if \nit lies on some cycle (possibly, a self loop) of the SCG. Proofi Assume first that x is a crown of cycle \nC, in G, and let (W -+ v) c E be the edge of C emanating from z, If z pd v, then, by Definition 11 of \n~ip~.), Gip~., cent ains the self loop s -+ z as stated. Else, let y (# z) be the sibling of z among \nthe an\u00adcestors of v. It is easy to see that y is also on C, so that z and y are reachable from each other, \nin G. More\u00adover, since all nodes of C are strictly postdominated by ipd(z), z and y are prereachable \nfrom each other, in G, By Proposition 4, z and y are reachable from each other in GiP+~), hence m lies \non a cycle of GiP4a). For the converse, assume that z lies on a cycle C of GiP~*) If C is a self loop \nx -+ z, then, by Definition 11, there is an edge (z + v) c E where z pd v. As there is always a path, \nsay VTX, from a node v to a postdominator of it x, we can construct the cycle C = xrmx in G having x \nas a crown, Else C contains at least a node y # z. Clearly, z and y are reachable from each other in \nGiP~c) so that, by Proposition 4, they a prereachable from each other in G, say, via paths xuy and yrx. \nThen, C = xuyrx is a cycle in G whose nodes are all postdominated by ipd(z) (= ipd(z)), whence z (as \nwell as y) is a crown of C, El Proposition 6 The set K of the crowns of a (7FG G = (V, E) can be computed \nin time O(lV\\ + Il?[). v Q T c sp_ 1 ----R, P c T~ % \\ END Figure 4: Paths in Lemma 1 Proofi The complete \nprocedure is shown in Fig\u00adure 2. Having constructed the SCG (Proposition 3), its strongly connected component \n(see s) are computed in O(IVI + 1111)time by the algorithm of Tarjan [Tar72], (see also [CLR92]), Based \non Proposition 5, the crowns of G can be determined by identifying those nodes of the SCG that lie either \non a self loop or on a cycle (which is equivalent to membership in a scc of size at least two). Both \nconditions are easily checked. 0 5.3 Prereachabilit y to Crowns Finally, we must compute the set K* \nof those nodes from whkh some crown is prereachable. Our approach consists in reducing thk problem to \nthat of finding the single static assignment (SSA) form of a program whose CFG is the reverse of G = \n(V, E), that is, GR = (V, l?~), where 17R= {v + u :(u + v) c l?}. We show that if K represents the set \nof assignments to some dummy variable X, then K* is precisely the set of the so-called join nodes [CFR+91] \nwhere @functions must be int reduced to convert GR to SSA form (with respect to X). We begin by recalling \nthe definition of join nodes [CFR+91], in a form that is convenient for the present developments. Definition \n12 Let S g V. The set JR(S) of join nodes foT S in GR is the set of all nodes z wch that there are in \nG two non trivial paths z $ xl and z ~ X2, with xl, X2 ~ S, intersecting only at z. The following lemma \nis the key step to make the connection between prereachability in G and join nodes in GR. Lemma 1 With \nreference to CFG G, if c is prereach\u00ad able from v, then there exist patha PI = v $ c and P2 = v L ?ZNl \nintersecting only at v. Proof: The proof is an induction on the length of the shortest non trivial path \nP = v ~ c which establishes the prereachability of c from v. Suppose the length of P is 1, i.e., P = \nVC. Since c does not postdominate v, there is a path PZ = v ~ END not cent aining c and hence disjoint \nfrom PI = P, except for node v. Assume the lemma is true for paths of length less than n. LetP=w$ p+ \ncbeapath oflength n. Bythe inductive assumption, there is a path Rz = v ~ END that is disjoint, except \nfor node V, from a path Sp = v $ p. WLOG, assume that Rz is acyclic. Appending the edge p+ cto path Spgives \napath Qfrom vto c. If cdoes not occur on path RZ, or if c = v, the lemma is proved by setting PI = Q, \nand Pz = R2. Otherwise, c occurs on RZ and is distinct from v. Let Rc be the prefix v &#38; c of Rp. \nNote that Q and R. are two paths from v to c that are disjoint except for v and c. Consider an acyclic \npath T = v L END that does not contain c; such a path must exist because c does not strictly postdominate \nv. Let 1 be the last node on T that occurs on either Q or Rc that is, the suffix T, = 1 L END of path \nT is dkjoint (other than node 1) from paths Q and R. (1 must exist because all three paths contain v). \nIfI=v,then letPI=QandPp=T. Otherwise, 1 is distinct from v, and it is contained in exactly one of paths \nRC and Q. Suppose 1 is contained in R.. Path R. can be written a$ v L 1 L c where the prefix v ~ 1 is \ncalled RI. Concatenate Rl and To to get a path Pz = v ~ END which is disjoint from PI = Q. The case when \n1 is contained in Q is identical. n We can now make the connection to WA computa\u00adtion. Theorem 4 Let \nS 6 V with END = STARTR G S. Then, v E JR(S) if and only if there is a c c S thai is prereachable from \nv in G. Proofi (+) By Definition 12 of ~R($, there are two distinct nodes c1 and C2 in S and two non \ntrivial paths v &#38; c1 and v A C2 in G intersecting only at v. At least one of these two paths does \nnot contain ipd(v), thus establishhg the prereachability of its endpoint (cl or C2)from v in G. (+) From \nLemma 1, there are two paths v t END and v ~ c in c that are disjoint except for v. Since c and END are \nboth in S, by Definition 12, v E J(S). n In our running example, the crowns are {b, e, f}; if these \nnodes and END are treated as assignments to some variable in the reverse CFG GR, we need ~-functions \nat nodes {b, e, f, g}. The set of nodes {b, e, f, g} is pre\u00adcisely the set of nodes that in G are not \nloop postdom\u00adinated by their immediate postdominator. It is worth observing that, while in general S \nis not necessarily a subset of JR(S), it is the case that K < JR(K) when K is the set of crowns, This \nis because (i) END is a crown (due to the selfloop END + END) and each crown is prereachable from itself \n(by Definition 10). In conclusion, K* = JR(K), whkh can be computed in 0(1131) time by any of several \nEEA algorithms in the literature [SG95, PB95], such as the one described in our earlier work on APT [PB95]. \n 5.4 Summary The following theorem summarizes the result of our approach to loop controI dependence \ncomput at ions: Theorem 5 Given a CFG G = (V, E) containing the edge END + END, the corresponding Augmented \nIJoop Poddominator Tree can be constructed in linear time and stored in linear space. It can answer 100P \ncon\u00adtrol dependence queries of the cd, conds, and cdequiv typeg in time proportional to the size oj their \nanswers. Proofi Figure 5 summarizes the procedure developed in thk paper. The linear bound follows: for \nStep 1, by [Har85]; for Step 2, by Proposition 6; for Step 3, by the known results on SSA (e.g., [PB95]); \nfor Steps 4 and 5, by straightforward procedures; for Step 6, by the prepro\u00adcessing algorithms for the \nA P T data structure presented in (PB95]. cl  6 Conclusions We have presented a framework, based on \na generalized notion of dominance, that permits a uniform treatment of classical and loop control dependence. \nWe have ap\u00adpIied this framework to compute the weak (or loop) control dependence relation optimally. \nIt would be interesting to include Ballance and Mc\u00adCabe s hierarchical control dependence [BM92] in our \nframework. Unfortunately, tl-h relation has been de\u00adfined by specifying a procedure for computing it. \nThe formulation of this relation in graph-theoretic terms is a prerequisite for fitting it into our framework. \nAcknowledgements: We are obligated to Tom Reps for pointing us to the work of Podgurskl and Clarke. Andy \nPodgurski was kind enough to send us a copy of hls dissertation at short notice. We also thank Ron Cytron, \nJeanne Ferrante, Bjaarne Steensgard and M~ke Wolfe for useful discussions on control dependence. Fi\u00ad \nnally, we would like to mention that we found the PLDI 96 referee reports very useful in revising the \nextended abstract.  References [BJP91] Micah Beck, Richard Johnson, and Keshav Pin\u00adgali. From control \nflow to dataflow. Journal of Pamllel and Distributed Computing, 12:118\u00ad129, 1991, 299 1.Build the postdominator \ntree pal-tree of the given CFG G = (V, E), includlng the distinguished node co as described in Subsection \n3.1. 2. Compute the set of crowns K as shown in Figure 2. 3. In the reverse CFG GR, mark all crowns \n(K) as assignments to some dummy variable X, and perform an SSA computation to obtain the set K* of nodes \nwhere the SSA form will require ~-functions for variable X.  4, For each a E K*, replace pal-tree edge \n(ipd(a) + a) with lpd-tree edge (m + a). 5. For each edge (u + v) c E such that v does not loop postdominate \nu, append to (an initially empty) route array A a chariot route with end points v and ilpd(u). 6. Construct \nthe APT for the Roman Chariot Problem in which the tree is the loop post dominator tree and the route \narray is A.  Figure 5: Computing the Loop Control Dependence Relation [BM92] [CFR+91] [CFS90] [CLR92] \n[FOW87] [Har85] [HT84] [LT79] [PB95] Robert Ballance and Arthur McCabe. Program dependence graphs for \nthe rest of us. Technical Report 92-10, University of New Mexico, Octo\u00adber 1992. R. Cytron, J. Ferrante, \nB. K. Rosen, M, N. Weg\u00adman, and F. K. Zadeck, Efficiently computing static single assignment form and \nthe control de\u00adpendence graph. ACM Transactions on Pro\u00adgramming Languages and Systems, 13(4):451\u00ad490, \nOctober 1991. Ron Cytron, Jeanne Ferrante, and Vkek Sarkar. Compact representations for control depen\u00addence. \nIn Proceedings of the SIGPLAN 90 Con\u00adfewnce on Progrwrwning Language Design and Implementation, pages \n337-351, White Plains, New York, June 20-22, 1990. Thomas Cormen, Charles Leiserson, and Ronald Rlvest. \nIntroduction to Algorithms. The MIT Press, Cambridge, MA, 1992. J. Ferrante, K. J. Ottenstein, and J. \nD. War\u00adren. The program dependency graph and its uses in optimization. ACM Tmnsactions on Programming \nLanguages and Systems, 9(3):319\u00ad349, June 1987. D. Harel. A linear time algorithm for find\u00ading dominators \nin flowgraphs and related prob\u00adlems, In Proceedings of the 17th ACM Sympo\u00adsium on Theory of Computing, \npages 185 194, Providence, Rhode Island, May 6-8, 1985. Dov Harel and Robert Endre Tarjan, Fast algorithms \nfor finding nearest common ances\u00ad tors. Siam Journal of Computing, 13(4):338\u00ad 355, 1984. Thomas Lengauer \nand Robert Endre Tarjan. A fast algorithm for finding dominators in a flowgraph. ACM Transactions on \nPragmm\u00adming Languages and Systems, 1(1):121 141, July 1979. Keshav Pingali and Gianfranco Bilardi. APT: \nA data structure for optimal control dependence computation. In Proceedings of the ference on Progmmming \nLanguage Implementation, June 1995. ACM Design Con\u00adand [PC90] Andy Podgurski and Lori Clarke. A formal \nmodel of program dependence and its implica\u00adtions for software testing, debugging and main\u00adtenance. IEEE \nTransactions on Software Engi\u00adneering, 16(9):965 979, Septmeber 1990. [Pod89] Andrew Podgurski. The significance \nof progmm dependence for softwaw testing, debugging and maintenance. PhD thesis, University of Mas\u00adsachusetts, \nAmherst, 1989. [SG95] Vugranam linear time Conference C. Sreedhar algorithm Record of and Guang for placing \nPOPL 95: R. Gao. A @nodes. In 22nd ACM SIGPLAN-SIGA CT Symposium on Principles of Progmmming Languages, \npages 62-73, San Francisco, California, January 1995. [Tar72] Robert E. Tarjan. Depth graph algorithms. \nSIAM 1(2):146-160, 1972. first search and linear Journal of Computing, [Wei92] Michael Weiss. The transitive \nclosure dependence: The iterated join, ACM Pmgmmming Languages and Systems, 190, June 1992. of control \nLetters on 1(2):178\u00ad 300  \n\t\t\t", "proc_id": "231379", "abstract": "We generalize the notion of <i>dominance</i> by defining a generalized dominance relation with respect to a set of paths in the control flow graph <i>G</i> = (<i>V, E</i>). This new definition leads to a generalized notion of <i>control dependence</i>, which includes <i>standard control dependence</i> and <i>weak control dependence</i> as special cases.If the set of paths underlying a generalized dominance relation satisfies some natural closure conditions, that dominance relation is tree-structured. Given this tree, the corresponding control dependence relation can be computed optimally by reduction to the <i>Roman Chariots Problem</i>, which we have developed previously for computing standard control dependence. More precisely, given linear preprocessing time and space, we can answer the (generalized version of the) so called cd, conds, and cdequiv queries in time proportional to the output of the query.To illustrate the utility of the framework, we show how weak control dependence can be computed optimally in <i>O</i>(|<i>E</i>|) preprocessing space and time. This improves the <i>O</i>(|<i>V</i>|<sup>3</sup>) time required by the best previous algorithm for this problem.", "authors": [{"name": "Gianfranco Bilardi", "author_profile_id": "81100228925", "affiliation": "DEI, Universit&#224; di Padova, 35131 Padova, Italy and EECS, University of Illinois, Chicago, IL", "person_id": "PP40025096", "email_address": "", "orcid_id": ""}, {"name": "Keshav Pingali", "author_profile_id": "81100554731", "affiliation": "Department of Computer Science, Cornell University, Ithaca, NY", "person_id": "PP39048331", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/231379.231435", "year": "1996", "article_id": "231435", "conference": "PLDI", "title": "A framework for generalized control dependence", "url": "http://dl.acm.org/citation.cfm?id=231435"}