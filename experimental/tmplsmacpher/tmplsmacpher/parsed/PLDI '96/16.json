{"article_publication_date": "05-01-1996", "fulltext": "\n Simple objects for Standard ML JohnReppy JonRiecke AT&#38;T Research Bell Laboratories jhr@research. \natt. com riecke@research. att.com ABSTRACT We propose anew approach to adding objects to Standard ML(SML) \nbased on explicit declarations of object types, object constructors, and subtyping relationships, with \na gen\u00aderalization of the SML case statement to a typecase on ob\u00adjecttypes. Thelanguage, called Object \nML(OML), hasa type system that conservatively extends the SML type sys\u00adtern, preserves sound static typing, \nand permits type infer\u00adence. The type system sacrifices some of the expressiveness found in recently \nproposed schemes, but has the virtue of simplicity. We give examples of how features found in other object-oriented \nlanguages can be emulated in OML, discuss the formal properties of OML, and describe some implemen\u00ad tation \nissues. Keywords: Programming language design, object-oriented programming, functional programming, Standard \nML, 1 Introduction A fundamental tension of language design is keeping the language small versus providing \nsupport for common id\u00ad ioms. This fundamental tension can be seen clearly in Standard ML (SML) [MTH90]. \nEven though SML pro\u00ad vides many powerful features, such as higher-order func\u00ad tions, polymorphism and \nparameterized modules, it does not provide primitives for object-oriented programming. In particular, \nthere is no support for subtyping or for working witb heterogeneous collections. Programmers must use \nex\u00adplicit coercions to implement subtyping (for example, see [GR93]), and use tagged unions to implement \nheterogeneous collections. This paper describes a simple extension to SML, called Object h4L (OML), \nthat provides direct support for objects, permission to make digitabhard copy of part or aii of this \nwork for personai or classroom use is ranted without fee provided that copies are @made or distributed \nfor pro I t or eommeroiei advanta e, the copyright notica, the titie of the publication and its date \nappear, an %noti~ is given that copying is by permission of ACM, Inc. To mpy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior speoifw permission andlor a fee. PLDI \n66 5/96 PA, USA 01996 ACM 0-89791 -796-2JWO005... $505O subtyping, andheterogeneous collections. Ourdesignsacri\u00adfices \nexpressiveness for simplicity. To aid type inference (so that programmers need not specify the types \nof variables), OML forces the programmer to declare object types, ob\u00adject constructors, andsubtyping \nrelationships between ob\u00adject types. OML is a conservative extension of SML, i.e., existing SML programs \nhave the same types and semantics in OML, The object constructs in OML also have efficient constant-time \nimplementations; there are no hidden costs, such as dynamic searching for methods. Outside of the theoretical \ncommunity, most statically typed object-oriented languages have only first-order func\u00adtions, e.g., C++ \n[Str94] or Modula-3 [Ne191], Even with this limitation on functions, the type systems often are too inflex\u00adible \nto support the object-oriented idioms found in dynarni\u00adtally typed languages like CLOS [Ste90], Dylan \n[App92], Obliq [Car95], Self [US87], or Smalltalk [GR83]). This inflexibility is overcome by using some \nform of dynami\u00adtally checked type casting. The design of more flexible and safe type systems for languages \nwith objects, subtyping, and higher-order functions is especially challenging, since func\u00adtion subtyping \nintroduces subtle technical problems. Pre\u00advious attempts require substantial type-theoretic machinery \nand complex type systems (see [FM94] for a review of the issues); furthermore, in some cases type checking \nis unde\u00adcidable, and for most others, type inference seems out of the question. The complexity of these \nsystems make them unsatisfac\u00adtory for extending SML with object-oriented features. We avoid the complexities \nof these systems and preserve SML s type inference mechanism, while still providing an expres\u00adsive notation \nfor object-oriented programming. Our ap\u00adpreach is based on adding object type declarations, which provide \nboth an explicitly declared subtyping hierarchy and named object constructors. Just as datatype constructors \nguide type inference in the presence of recursive types, ob\u00ad ject type cons~ctors guide type inference \nin the presence of subtyping. While the system is not as expressive as those discussed above, it is more \nexpressive than the type sys\u00adterns of C++ and Modula-3. In addition to supporting poly\u00admorphism, our \nsystem supports methods that return self, 171 whereas C++ and Modula-3 fix the return types of their \nmeth\u00adods. Furthermore, the system generalizes the SML case statement to be a typecase on object types, \nwhich can be used to recover type information dynamically that the type system cannot determine statically.l \nWe first describe our approach in a simple language with single inheritance of object types, where objects \nare records. We then complete the description of OML by intro\u00adducing methods and self types. Section \n4 discusses the inter\u00adactions between our extensions and the features of SML. In Section 5, we describe \nhow various object-oriented idioms are programmed in OML, followed by a discussion of im\u00adplementation \ninheritance. Section 7 gives an overview of the theoretical foundations of OML. In Section 8, we discuss \ncompile-time and run-time implementation issues. Finally, we discuss related work and present conclusions. \n2 Extending SML with simple objects SML s approach to recursive types guides the design of OML. The SML \ntype system is based on the Damas-Milner type inference system [DM82], which defines a structural view \nof type equivalence (i.e., two types are equal if they have the same structure). One can extend this \nstructural view to recursive types. For example, the type of integer lists tight be defined as intlist \ns rec t.(nil + cons : (int x t)) TWOrecursive types are equivalent if they unfold to the same infinite \ntree. Unfortunately, we encounter problems if we extend this to recursive type constructors (e.g., a \n1 ist ), because there is no known algorithm for determining type equality in such a setting [S0178], \nand type equality is at the core of the Darnas-Milner type inference system. To avoid this problem, SML \nintroduces datatype definitions, where each definition defines a new unique type. For example, a list \ntype constructor can be defined as: datatype a list = Nil I Cons of ( a * a list) This definition introduces \ntwo constructors, Ni 1 and Cons, that serve as syntactic signposts for the type inference algo\u00ad rithm, \nIn patterns, constructors unfold the recursive type, while in expressions they fold the recursive type. \nWith this information, the type inference problem for recursive types is trivial. We adopt the same trick \nto deal with type inference for object subtyping. Our mechanism is based on a new declar\u00adative construcc \nobjtype tyid = conid of [ I labl : tyl , .... labn : tyn This declaration defines a new object type tyid \nwith corre\u00adsponding object constructor conid. The labl ,.. , labn are 1~i~ is our fo~ of dynamically \nch~ked CWirU3 the members of the object type, which must be distinct. It is also possible to define an \nobject type in terms of an existing object type: ob j type tyid is Vid = conid of [ I labn+l : tvn+l \n, ... . Mm : ~Ym II This declaration defines a new object type tyid that ex\u00adtends the object type tyid \nwith the additional members labn+l . . . . labm. In addition to defining a new object type, this form \nspecifies that tyid is a subtype of tyid; the types of the members Jabl, . . . . lab. are the same in \nboth ob\u00adject types. We use C++ terminology, and call tyid a base ob\u00adject type, and tyid a derived object \ntype. These declarative forms provide a mechanism for single inheritance of inter\u00adface types.2 For example, \nthe following declarations define a type hierarchy for points and colored points in W1 and $?2: objtype \npointl = PT1 [ I x : real I ) objtype point2 i.s pointl = PT2 ( I y : real I ) objtype cpointl is pointl \n= CPT1 { I c : color I ] objtype cpoint2 is point2 = CPT2 [ I c : color I ] Note that unlike in most \nrecord subtyping systems, the types cpointl and cpoint2 are not related in this hierarchy, as can be \nseen in Figure 1. Y-\u00ad  @--G@  Figure 1: The type hierarchy of points and color points Subtyping in \nOML is detined inductively. We start with the explicit hierarchy defined by the ob j type definitions, \nand extend it to the various ML type constructors (tuples, la\u00adbeled records and functions types) in the \nstandard way. As is usual, subtyping on function types is contravariant in the negative position (argument \nposition): lJ+l-7- + u T+T ~(7+gt It is this property of subtyping that causes many of the technical \ndifficulties in type systems for object-oriented lan\u00adguages, Objects are created by applying an object \nconstructor to a collection of member definitions, For example, the follow\u00ading expressions create a pointl \nand a cpoint2 object PT1[Ix = 1,01] CPT2(IX = 1.0, y = 1.0, c = red~]  2we se tie mm ,,s~gle inberi~ce \nloosely here, since we are tig about interfaces and not implementations. The member definitions may be \nspecified in any order, but are evaluated left-to-right. Just as pattern matching is used to reconstruct \nrecursive types in SML, we use it to access the members of an object, e.g.y fun xcoord (PT1{Ix I}) = \nx fun color (CPT1[IC, ,, .1}) = c (the . .. notation means ignoretheother members). An object constructor \npattern can match any subtype of the ob\u00adject type: for example, the xCoord function can be applied to \nvalues of type pointl, and any subtype of pointl, such as cpointl. The color function, on the other hand, \ncannot be applied to values of type point 1. To make the notation a bit more object-oriented: we in\u00adtroduce \nthe following derived form for selecting a member:3 O$m -(fn (O(lm, . ..1]) =>m) For example, we can \nwrite a distance function on $?2 points as: fun dist (pi, p2) = let val dx = (PT2$x pl)-(PT2$x p2) val \ndy = (PT2$y pl)-(PT2$y p2) in sqrt (dx*dx + dy*dy) end Most accesses to members in programs use the \nderived form rather than full pattern matching. Pattern matching on object constructors provides a form \nof typecase on objects, similar to that found in Modula-3 [Ne191]. For example consider the following \nexpression: case pt of CPT1[I . . . 1} => print color point\\n I PT1{I. . .1] => print point\\n Ifptisacpointl \n(orsome subtypeof cpointl),then the first case is matched. Otherwise the second case is matched (forexample, \nifptisapoint2), Note thatif the cases were in the other order, the second case (i.e., the CPT 1 case) \nwould be redundant this mistake can be detected by thecompiler andreported as awarding. Aswe show later, \nwe can use object pattern matching to compensate for the weakness of our type system. 3 Objects with \nmethods The examples so far have just used fields, which are the sim\u00adple form of members. OML also provides \nmethods, which are member functions that are implicitly passed the object as a parameter when they are \ninvoked. For example, here is the interface to a point object (in X?) that has three methods: objtype \npoint = PT of [1 x : real, move : meth real -> point, bump : meth unit -> point, dist : meth real -> \nreal II s~i~ is ~i~lm to he I+Zno~tion for record field selection h sm. The move method moves the point \nby its argument, the bump method moves the point by some fixed amount, and the dist method returns the \ndistance between the point and its argument. The following function creates a point from an initial x\u00adcoordinate: \nfun mkPoint XO = PT( I x = Xo, move = meth self dx => mkPoint($x self + dx), bump = meth self () => $move \nself 1.0, dist = meth self x => abs($x self -x ) 1) We shorten the notation PT$x to just $x in the body \nof amethod, where theobject constructor PT is implicit. The methods are curried functions, with their \ntirst arguments be\u00ading the object, and the second being the other arguments. Methods in OML have the \nso-called selj-application seman\u00adtics in which the first argument (i.e., self) becomes bound to the object \nduring method invocation, The move method adds dx to the x component of the ob\u00adject and then calls mkPoint \nto make a new point with new x value; the bump method uses move to move the point by one; and the dis \nt function has the obvious implementation. While the move and bump methods are applicative, it is also \npossible to define stateful objects by defining mutable fields, or by using local reference cells, For \nexample, fun mkPoint XO = VARPT[ I x = ref xO, move = meth self dx => ($x self) := ! ($x self) +dx, \nbump = meth self ( ) => $move self 1.0, dist = meth self x => abs(! ($x self) -x ) II creates a mutable \npoint, which is an implementation of the type objtype varpt = VARPT of ( I x: real ref, move : meth real \n-> unit, bump : meth unit -> unit, dist : meth real -> real 1) While many uses of OML objects will \nbe imperative in prac\u00adtice, we focus on applicative objects because the require\u00adments on the type system \nare more severe (imperative meth\u00adods usually have a unit return type, which makes subtyp\u00ading easier). \nAs before, we can define subtypes of an object type. Here is the type of color points, with a method \nfor changing the object s color, and an implementation of color points: objtype cpoint is point = CPT \nof [1 c : color, shade : meth color -> cpoint II fun mkCPoint (xO, cO) = CPTII x=Xo, c=co, move = meth \nself dx => mkCPoint($x self + dx, $C Self), bump = metb self () -> $move self 1.0, dist = meth self x \n=> abs($x self -x!), shade = meth self c => mkCPoint($x self, c ) II In this example, CPT$move has the \ntype cpoint -> real -> point eventhoughthe valueitretums isacpoint,and soinfor\u00admationis being lost. \nWhile it is possible to recover this in\u00adformationusing pattern matching, asimple modificationto thetype \nsystemallows thisinformationto bepreservedstat\u00adically. We introduce aspecial type constant, selfty, that \ncan be used when specifying the types of object members. When typing an object constructor, we replace \nthe occur\u00adrences of self t y with the constructor s object type. For example, if the point object type \nis defined as: objtype point = PT of [ I x: real, move : meth real -> selfty, bump : meth unit -> selfty, \ndist : meth real -> real 1} objtype cpoint is point = CPT of [1 c: color, shade : metb color -> selfty \nII Then the type of CPT$move is: cpoint -> real -> cpoint Note that because the argument position of \na function type iscontravariant inthesubtyping relation, selfty can only appear in positive positions. \n4 Interactions with SML When adding a new feature to a language, it is important to examine howit interacts \nwith existing features. In general, our object types fit into SML in a natural fashion, For in\u00adstance, \ntype checking and compiling can proceed incremen\u00adtally; itisnot necessary toknowthe subtypes of an object \ntype when compiling uses of the type, and hence interac\u00adtive SML programming and separate compilation \n[AM94] are not affected by the addition of object types, SML allows type definitions, such as datatype \ndeclara\u00adtions, to be parametrized, The 1 i st type definition on page 2 is one example of such a type \nconstmctor, We would like to extend the subtyping relation to instances of such constructors; for example, \nwe would like a list of color points to be a subtype of a list of points. Care must be taken, however, \nto avoid unsound subtyping. For example, datatype a t =Aof unit -> a IBof a -> unit has its argument \nappearing in both positive and negative positions. Thus, a cpt t value is not comparable to a pt t under \nthe subtyping relation. To handle this case, we must analyze the use of type arguments in the definition \nof type constructors, and must treat abstract type construc\u00adtors conservatively. It is also reasonable \nto pararneterize ob j type declara\u00adtions to detine object type constructors. We allow definitions of \nthe form: objtype (i?) tyid is (@) tyid -conid of { I labl : t~l, .... lab~ : tum II where the 6? are \nthe parameters of the object type construc\u00adtor t@ , and the @ are the instantiation of the parameters \nof the base type tyid, At the time of this writing, we have not had much experience with object type \nconstructors, and are not sure of their utility. For object types to work with the SML module system, \nwe must introduce a specification form for object types in signatures. In addition to allowing a full \nobject type defini\u00adtion in signatures, we also provide a partially abstract spec\u00adification objtype ty \nis ty which specifies that the object type t y is a subtype of t y , but hides the representation of \nty (i.e., what extra members it provides). For example, the signature signature SIG -sig objtype a = \nA of [lx : intl) objtype b is a end is matched by the structure structure A : SIG = struct objtype a \n= A of [lx : intl} objtype bis a=Bof [Iy :intl] end When using partially abstract object types in functor \nparam\u00adeters, it is useful to be able to rename the object type, We support this by allowing an ob j type \nspecification in a sig\u00adnature to match a type definition, where the defined type is bound to an object \ntype that matches the specification, For example, the following structure matches the A signature: structure \nA : SIG = struct objtype a = A of (lx : intl) objtype c is a = Cof (IY : intl] type b=c end 5 Object-oriented \nidioms OML supports many of the standard object-oriented idioms found in the literature. Most important, \nit supports subtyp\u00ading, which is the basis for many object-oriented programm\u00ading techniques. In this \nsection, we give examples of how we support some of the other techniques in OML. 5.1 Extensible datatypes \nObject constructor matching provides a form of extensible datatype, in some ways, similar to SML exn \ntype, In OML, we can replace the exn type and associated declarative form with a base type of exception \nobjects. More specific excep\u00adtions can be defined as subtypes. For example, the arithmetic exceptions \nmight be defined in the following way: objtype exn = EXN of { I I] objtype arith_exn is exn = ARITH of \n{ I I ) objtype ovfl_exn is arith_exn = Overflow of {1 1} objtype div_exn is arith_exn = Div of [1 1] \nThis allows anexception handler to catch collections ofre\u00ad latedexceptions, while letting others pass \nthrough. Similar mechanisms can be found in CLOS [Ste90], C++[Str94], and Dykm [ApP92]. The extensible \nnature of object types is also useful for providing open implementations of heterogeneous collec\u00adtions, \nFor example, we can define a base type of items: objtype item = ITEM of [ I I ] and implement operations \nover various collections of items. At any point that we want to put a new type of value into a collection, \nwe can define anew subtype of the item type. 5.2 Binary methods A binary method is a method whose argument \nhas the same type as the object. While OML s type system is not rich enough to support true binary methods, \nbecause self ty cannot appear in the argument position of a method type, it is possible to use the object \npattern matching to imple\u00adment something close to binary methods. For example, here are points and color \npoints with an eq method that tests for equality: objtype point = PT { I x : int, eq : point -> bool \nI] objtype cpoint is point = CPT { I c : color I ] fun mkPt x = PT{I x=x, eq = meth self pt => ($x self \n= PT$X pt) II fun mkCPt (x, c) = CPT{ I X=x, c=c, eq = meth self pt => (case pt Of (CPTI IX, C, . ..1])=> \n(($x self = x) andalso ($c self = c)) 1- > ($x self = PT$x pt) (* end case *)) II fun equal (pi, p2) \n= PT$eq PI p2 Our type system gives equal the type: (point * point) -> bool Note that this technique \ncan also be used to implement multi-methods methods that dispatch on the type of more thanone argument. \nIn fact, thetechnique closely resembles Castagna s encapsulated multi-methods in which the defin\u00aditions \nof multi-methods are local to the object [Cas95]. 5.3 Friend functions Another concept that is related \nto binary methods are C++ j?iend functions, which are functions that have access to the private members \nofanobject[Str94]. Following Pierce and Turner [PT93b], we can use partially abstract object types to \nimplement a form of friend functions. The approach is to define a base object type that contains the \npublic operations, and a derived type that extends the public interface with pri\u00advate members. We group \nthese definitions, along with the friend functions, in a module, and export the derived type as a partially \nabstract object type. For example, we might have the following interface to an implementation of sets \nof inte\u00adgers: structure Set : sig objtype set = SET of [ I add : meth int -> selfty, member : meth : \nint -> bool II objtype set is set val singleton : int -> set val union : (set * set ) -> set end = \nstruct ... end The object type set defines the public interface, which consists of two operations: add \nfor adding elements, and member fortesting membership. The typeset is the rep\u00adresentation type, but its \nadditional members are not visible outside the set module, The functions singleton and union have access \ntotheintemal representation type. The definition of the set typemightbe objtype set is set = SET of {1 \nelems : int list II where elems isthe list of settlements. Therestoftheim\u00adplementation follows from \nthis. 6 Implementation inheritance One important feature of many object-oriented languages is support \nfor inheritance of implementations, ~pically, this is supported either by a delegation mechanism or a \nclass mechanism. Abadi and Cardelli s object calculi support delegation via object cloning and method \noverride opera\u00adtions [AC95a]. We considered adding such operations to OML, but discovered that type safety \nimposes severe restric\u00adtions on their use in our setting, Abadi and Cardelli also show how classes can \nbe en\u00adcoded as stylized objects, consisting of a new operation and pre-methods. We have been exploring \nencodings of classes based on this approach. In OML, we can use objects to en\u00adcode classes, but we can \nalso use the SML module system. The latter seems more in keeping with the notion of a class, and it is \nwhat we present here, In this encoding, a class type is an SML signature, and a class is a structure. \nFor example, recall the point object type defined in Section 3; the corresponding class signature is: \nsignature PT_CLASS = sig val x :real val move : point -> real -> point val bump : point -> unit -> point \nval dist : point -> real -> real val new : unit -> point end The new operation is used to construct \nnew objects, while thepre-methodsare usedtoinheritimplementations. Aclass signature may have multiple \nimplementations (structures). For example, here is an implementation of the PT_CLAS S signature: structure \nPTClass : PT_CLASS = Struct valx=O. O fun mk XO= PT{I x = Xo, move = meth ptSelf arg => move ptSelf \narg, bump = meth ptSelf arg => bump ptSelf arg, dist = meth ptSelf arg => dist ptSelf arg  II and move \npt dx = mk(PT$x pt + dx) and bump pt () = PT$move pt 1,0 and dist pt x = abs(PT$x pt -x ) fun new () \n=mkx end Notethatthe implementation ofthemkfunction isuniforrn, andcouldbeeasily mechanized. Inheritance \nof implementation is achieved by using the pre-methods of some existing class. For example, the cpoint \nobject type from Section 3 has the class signature: signature CPT_CLASS = sig val x :real val move : \ncpoint -> real -> cpoint val bump ; cpoint -> unit -> cpoint val dist : cpoint -> real -> real val c \n: color val shade : cpoint -> color -> cpoint val new : unit -> cpoint end Animplementation OfCPT_CLASSC~ \ninheritfromanim\u00adplementationofPT_cUMs: structure CPTClass : CPT_CLASS = struct val x = PTClass,x val \nc=red funmk (xO, cO) = CPTII x = Xo, move = meth ptSelf arg => move ptself arg, bump = meth ptSelf arg \n=> bump ptself arg, dist = metb ptSelf arg => dist ptSelf arg, c = co, shade = meth ptSelf arg => shade \nptSelf arg II and move cpt dx = mk (CPT$X cpt + dx, CPT$C cpt) and bump pt () = CPT$move pt 1.0 and \ndist cpt x = PTClass.dist cpt x and shade cpt c = mk (CPT$X cpt, c ) fun new () = mk(x, c) end In this \nclass, the definition of x and the implementation of distare inherited fromthe PTClass. Notethatthereis \nno reasonto fix the particular implementationof the point class that the color point class inherits from, \nwe could de\u00adfine thecolorpoint class asafunctor pararneterizedover the point class. This example also \nillustrates a weakness of our type sys\u00adtern. AbadiandCardelli areabletoencode theinheritanceof methodsthatretum \nselfty,such asmoveandbump ,but thisisnotpossible inOML.Amethod thatreturnsself ty does so in oneof two \nways: hcrmreturn itsselfparame\u00adter, orh calls the mk function for the class to implement a functional \nupdate. It is this latter case that causes prob\u00adlemsfor the inheritance ofmethod implementations. The \nobvious approach is to parametrize a class definition by the functionalupdate operation, butthere are \nsomecircularities that wehave notbeen able tosolve ina type correct man\u00adner. We are exploring the additionof \nadeclarativemecha\u00adnism for classes that would relieve the prograrrtmerof the tedious translation from \nobject types to class interfaces and new operations. In addition, it might provide afrarnework for defining \nthe inheritance of methods that return self ty. 7 Theoretical Properties of OML A rigorous formal treatment \nof OML is outside the scope of this paper, but we describe some of the more important the\u00adoretical properties \nwithout proof. We illustrate the formal properties via a language called OML--, a version of OML without \nreals, strings, pairs, lists, and other basic data types, without side effects and recur\u00adsive functions, \nand whose objects involve only methods. The type rules are easier to state in this reduced language, \nand the extension to full OML follows the design of SML [MTH90]. Thetype rules appear in Tablel. ~pes, \ntype schemes, con\u00adstraint sets, and constraints are defined by the grammar S,t ::= al selftyl (s~s) Iobj \nS,T ::= d{al... czn}:s. s c ::= {A1,..., Ak} A ::= (~<Obj)l(Obj<~)l(Obj<Obj ) Table 1: ~ping Rules for \nOML--\u00ad r(z)s V{Q1 ... %} :c . s cl-c [tl/al, ... ,t7Jch] c;D; r 1-x : s[tl/al,..., tan]n] c; D;r*{zl-+s}l-M:t \nC; D;rl-(fn z=> M):(5+t) C; D; I t-M:(s+t) C; D;17t-N:s c; D;rt-(MN):t C; D;17kv:t C; D;r+{z+ Gen(C, \nr , t)} I-N:s C; D; I t-(letx=Vin N):s (ob]type obj=Obj{lll :(SI ~s~),...,l~ : (sn~s~)l}) ~D C1-obj<t \n(Vi C + {obj + a}; D;17 + {self H obj, z I+ s~[a/selfty]} t-kf~ : s~[a/selfty]) a fresh C; D;r FObj{lll \n=methself x=> A41,. ..,ln=meth self x=> M}/} :t C; D; I t-M:s C+s<sn Cks. =leastupper bound of{sl,. ... \nsn} (Vi. s; Dt-Pi:si, r, and C; D; I +ri+M, :t) C; D; I l-(case kfof{Pl=> Ml,..., P~=> kk}):t (objtype \nobj=Obj{lll :tnl})E D :tl,...,ln s;D E Obj {1 11,. ... L 1} : obj, {h * ti[s/selfty] I 1< i < n} where \na ranges over a predefine set of type variables and obj ranges over a class of object type identifiers. \nC denotes a set of subtyping assumptions among type variables and ob\u00adject types; the order of the subtyping \nassumptions A is unim\u00adportant, and we identify type schemes whose bound vari\u00ad ables al . . . an and subtyping \nassumptions C are the same up to reordering. Subtyping in the type system is completely captured by the \nfollowing atomic subtyping rules: C1-A, ifAe C  Ckt+t C1-t +t C!-t+t  We write C 1-C as shorthand for \nC F A for all A c C . We will come back to the relationship between OML and OML--in a moment, and first \nconsider three theoretical properties of OML---The two first technical result shows that complete, well-typed \nOML--programs do not produce run-time type errors. Here, a complete OML--program is a collection of object \ntype declarations followed by a closed expression of any type. By closed we mean that there are no free \nvariables, and any object constructor used in the ex\u00adpression has a corresponding declaration. The first \nproperty, called subject reduction, states that well-typed expressions continue to be well-typed during \nevaluation Theorem 7.1 (Subject Reduction) 1~the term M is closed and has type t, and M reduces to M \n, then M has type t, The second property captures a dual notion if a program is well-typed and has not \nreturned a final answer, then its exe\u00adcution may continue: Theorem 7.2 (Progreaa) Ij the term M is closed \nand has type t, and M is not a value, then M can be reduced. Since a term with a run-time type error \ncannot be reduced under the reduction rules, both properties imply that well\u00adtyped programs do not cause \nrun-time type errors. The third technical result relates the typechecking rules to a type inference algorithm. \nThe algorithm, a modification of the one found in [Mit84], itself relies on a modification of the standard \nunification algorifim: one tinds most general unifiers subject to a set of atomic subtyping constraints. \nThe algorithm finds a principal type (or most general type) for an expression. The second technical result \nis the place where OML and OML--diverge. Any type produced by the algorithm for OML is an instance of \nthe type produced by the algorithm for OML--, but not conversely. We have made a fun\u00addamental tradeoff \nin the design of OML to simplify the type system: the algorithm for OML--deduces types with bounded quantification, \nwhereas the algorithm for OML uses simple subtyping, In fact, a rather old example due to Mitchell [Mit84] \nshows that type inference in OML cannot produce a principal type. Consider the function fn p=>case (p, \nPT$x p) of (x, _) =>x This expression has type V a < pt ,a a a in OML--, and so has both the type pt \n~ pt (which is what OML assigns to it) and the type cpt ~ cpt, Since these types are unrelated by the \nsubtyping relation, neither is more general than the other. In our view, the former type is better than \nthe latter, since it can be applied to a larger set of arguments, and we can use pattern matching to \nrecover the lost type information at run-time when necessary. It is also important to point out that \nwhile the OML typechecker does not produce a princi\u00adpal type (because such types do not exist in all \ncases), it does produce a canonical type. Specifically, it produces an in\u00adstance of the most general \ntype OML--type, where bound type variables are instantiated to their bounds. 8 Implementation issues \nWe have been exploring these language ideas using a sim\u00adple parser and typechecker that supports core-ML \nextended with our object types. This front-end produces a typed ab\u00adstract syntax tree that we can interpret. \nWe have used this implementation to test small examples, such as those found in this paper, and to explore \nthe implementation issues in the OML typechecker. The implementation of a type-checker for OML requires \nfairly simple changes to the standard algo\u00adrithm. The main difference is that the unification algorithm \nmust compute the join or meet of two object types when uni\u00adfying them, There is also some bookkeeping \nrequired to dis\u00adtinguish positive and negative contexts during unification, An important property of \nOML is that it can be im\u00adplemented efficiently without sophisticated compiler tech\u00adniques. The main design \nissues are the representation of ob\u00adjects and the implementation of pattern matching on object constructors. \nWe define the depth of an object type to be the number of supertypes that it has. For each ob j type \ndeclaration, we allocate a static info structure with the following C repre\u00adsentation: typedef struct \nob j inf o { int depth; struct obj info *info [clepth+l] ; ] obj info_t, *obj id_t; where the allocated \nsize of the info array is one greater than the object s depth. We use the address of this structure as \nthe object type s unique ID. Each slot of the info array contains the ID of the object type s supertype \nat the corre\u00adsponding depth. For each object value, we include a pointer to its info structure as its \nfirst word; this gives the following C representation: typetief struct I ob j id_t id; void *members \n[ 1 ] ; ] obj ect_t; If ob j is a pointer to an object, and O is an object con\u00adstructor with unique \nID ID and depth D, then we can match against O as follows: if ( (p->id->depth >= D) &#38;&#38; (p->id->info[D] \n== ID) ) { /* this matches the O object constructor */ 1 For large collections of pattern matches, we \nmaybe able to use analysis of the object type hierarchy to reduce the num\u00adber of comparisons. A pattern \nmatch on an object type is exhaustive if it has a wild card, or specifically matches its argument type. \nIn the case of a singleton exhaustive match, no dynamic checking is required, since the static typing \nensures that the match will always succeed. In particular, the matches defined by the notation O$m are \nalways exhaustive, and thus can be imple\u00admented as direct pointer dereferences, without conditionals. \nOne implementation issue that warrants further study is the space requirements of objects. Because an \nobject type defines an interface that may have multiple implementations, our object representation must \nhave slots for each mem\u00adber. This leads to a much fatter representation than found in class-based languages, \nsuch as C++,where the method func\u00adtions are stored in a single table that is shared by all ob\u00adject instances. \nThis problem is further exacerbated by the fact that functions in SML-like languages are represented \nas heap-allocated closures, and the methods for two different objects created by the same code may have \ndifferent closure objects. One approach may be to adopt a split represen\u00adtation, where object methods \nand fields are stored in sepa\u00adrate pieces of memory. Furthermore, the compiler may need to treat method \nfunctions specially to avoid the problems with the standard closure representation, although recent im\u00adprovements \nin compiler techniques for SML may make this unnecessary [Sha94]. 9 Related work Over the past decade, \nmany researchers have attempted to bridge the gap between the practice of dynamically typed object-oriented \nprograrnmin g and the desire for static type\u00adchecking. This research has followed two different av\u00adenues: \none avenue developed extensions of the A-calculus that can encode objects (e.g., [Car84] and [Pie94]), \nand the other has developed calculi in which objects are a primi\u00adtive notion (e.g., [Bru94] and [AC95a]). \nThe most com\u00adplete object-oriented type systems require resolving a funda\u00admental conflict between subtyping \n(in which an object may be used in a context that expects a supertype of the ob\u00adject) and inheritance \n(in which definitions of objects maybe reused to build new objects). Naive type systems that iden\u00adtify \nthe two concepts may have problems with type sound\u00adness (see [CO089] for an example in early versions \nof Eif\u00adfel [Mey92]), To avoid the problem, typed languages have used substantial type-theoretic machinery: \nhigher-order sub\u00adtyping [AC95b], bounded polymorphism [CW85], higher\u00adorder and F-bounded polymorphism \n[CCH+ 89], existential types [PT93a], and matching [Bru94]. In many of these pro\u00adposed systems, typechecking \nis not decidable, The problems with typechecking magnify in the context of type inference if one keeps \nthe same goals. Mitchell s seminal work on subtyping and type inference describes an algorithm and type \nrules for predeclared, fixed subtyp\u00ading hierarchies [Mit84]; this system forms the basis of our OML-~ \ncalculus. Subsequently, this has been extended to handle object-oriented features. The first extension \nis sim\u00adple record subtyping: a record type with more fields is a subtype of a record type with fewer \nfields. Record subtyp\u00ading requires a rather substantial change to the type inference system (for example, \nsee [JM88], [R6m94], or [Wan87]). But record subtyping alone is not powerful enough to en\u00adcode full objects: \none requires some form of recursive type, since the types of methods should be able to return objects \nof the type itself (possibly through selj). Existing type infer\u00adence engines either solve a recursive \nset of constraints about types [Pa194], or collect a set of recursive constraints about types and report \nthem to the programmer [EST95]. Neither solution is simple: it may require substantial insight on the \npart of the programmer to determine where a type error has occurred, as it is often not obvious when \nthe recursive con\u00adstraints have a solution. Perhaps the closest type system to ours is the encapsulated \nmulti-methods of [Cas95]. In this approach, methods exist locally within an object but can be overloaded. \nOur case construct yields a similar behavior. The main difference be\u00adtween the systems is in the type \nstructure: our system does not have overloaded types. , The dynamic semantics of our objects is influenced \nby Abadi and Cardelli s object calculi [AC95a]. Their system supports delegation via object cloning and \nmethod override operations [AC95a]. While we might have added such op\u00aderations to OML, the associated \ntyping restrictions are com\u00adplicated and it may be the case that our type system is not powerful enough \nto make such operations useful. They have also shown how classes can be encoded as a stylized objects; \nit is this approach that we follow in Section 6. Thorup and Tofte have shown how to encode many object\u00adoriented \nfeatures in SML (including F-bounded quantifica\u00adtion), but their encodings are quite cumbersome [1 T94]. \nIt would be interesting to see if their encodings are more direct in OML. 10 Conclusions and future work \nWe have presented a simple extension to SML that supports object-oriented progr amrning. Our extension \npreserves the good properties of the SML type system type soundness, polymorphism, type inference while \nadding additional flexibility in the form of object subtyping. So far, we have been pleased with the \nexpressiveness of OML; many natu\u00ad ral examples are straightforward to program in the language, but we \nneed more experience to fully evaluate the design. There may well be more facilities that need to be \nadded to the language, such as some direct support for classes or more extensive object primitives, We \nare incorporating these ideas into the design of MOBY, which is a small ML-like language for programming \nembedded systems, This will provide a better testament to the usefulness of our approach. We are also \nexploring the relationship between the simple type system used by OML and the bounded types used by OML---While \nthe latter system has better formal proper\u00adties, it is more complex and is harder to explain to program\u00admers. \nWe hope that studying the OML--system will provide insight to the choices made by the OML type system. \nAcknowledgements We thank Kim Bruce, Kathleen Fisher, Jens Palsberg, Ben\u00adjamin Pierce, Scott Smith, Valery \nTrifmov, and David TUmer for helpful discussions, and Emden Gansner, Lal George, and Anne Rogers for \nreading drafts of this paper. REFERENCES [AC95a] Abadi, M. and L, Cardelli, An imperative object calculus. \nIn TAPSOFT 95: Theory and Prac\u00adtice of So~are Development, number 915 in Lecture Notes in Computer Science. \nSpringer-Verlag, May 1995, pp. 471-485. [AC95b] Abadi, M. and L. Cardelli. On subtyping and matching. \nIn ECOOP 95, 1995. AM94] Appel, A. W. and D. B. MacQueen. Separate compilation for Standard ML. In Conference \nRecord of the 1994 ACM Conference on Pro\u00adgramming Language Design and Implementa\u00adtion, June 1994, pp. \n13 23. App92] Apple Computer, Cambridge, MA. Dylan: An Object-oriented Dynamic Language, 1992. [Bru94] \nBruce, K, B. A paradigmatic object-oriented language: design, static typing, and seman\u00adtics. Journal \nof Functional Programming, 4(2), 1994, pp. 127 206. [Car84] Cardelli, L. A semantics of multiple inheritance, \nIn Semantics of Data ~pes, vol. 173 of Lecture Notes in Computer Science, New York, N.Y., 1984. Springer-Verlag, \npp. 51-67. [car95] Cardelli, L. A language with distributed scope. In Conference Record of the 22th Annual \nACM Symposium on Principles of Programming Lan\u00adguages, January 1995, pp. 286 297. [Cas95] Castagna, G. \nCovariance versus contravariance: Conflict without a cause. ACM lYansactions on Programming Languages \nand Systems, 17(3), May 1995, pp. 431-447. [CCH+89] Canning, P., W. Cook, W. Hill, J. Mitchell, and W. \nOlthoff. F-bounded quantification for object\u00adoriented progr arnming. In Conference Proceed\u00adings of the \nFourth International Conference on Functional Programming Languages and Com\u00adputer Architecture. ACM, \n1989, pp. 273 280. [CO089] [CW85] [DM82] [EST95] [FM94] [GR83] [GR93] [JM88] [Mey92] [Mit84] [MTH90] \n[Ne191] [Pa194] Cook, W. R. A proposal for making Eiffel type-safe. In European Conference on Object-Oriented \nProgramming, 1989, pp. 57 72. Cardelli, L. and P. Wegner, On understand\u00ading types, data abstraction, \nand polymorphism, Computing Surveys, 17(4), 1985, pp. 471-522. Damas, L. and R. Milner. Principal types \nfor functional programs. In Conference Record of the 9th Annual ACM Symposium on Principles of Programming \nLanguages, January 1982, pp. 207-212. Eifrig, J., S. Smith, and V. Trifonov, Sound polymorphic type inference \nfor objects. In 00PSLA 95 Proceedings. ACM, 1995. To ap\u00ad pear. Fisher, K. and J. C. Mitchell. Notes \non typed object-oriented programming. In TACS 94: Theoretical Aspects of Computer Science, num\u00adber 789 \nin Lecture Notes in Computer Science. Springer-Verlag, 1994, pp. 844-885. Goldberg, A. and D. Robson. \nSmalltalk-80: The Language and its Implementation, Addison-Wesley, Reading, Mass., 1983. Gansner, E. \nR. and J. H. Reppy. A Multi\u00ad threaded Higher-order User Interface Toolkit, vol. 1 of Software Trends, \npp. 6 1 80. John Wi\u00ad ley &#38; Sons, 1993. Jategaonkar, L. and J. C. Mitchell. ML with ex\u00adtended pattern \nmatching and subtypes. In Con\u00adference Record of the 1988 ACM Conference on Lisp and Functional Programming, \nJuly 1988, pp. 198-211. Meyer, B. Ei~el: The Language. Prentice Hall, New York, NY, 1992. Mitchell, J. \nC. Coercion and type inference (summary). In Conference Record of the Ilth Annual ACM Symposium on Principles \nof Pro\u00adgramming Languages, January 1984, pp. 175\u00ad 185. Milner, R., M. Tofte, and R. Harper. The Dej inition \nof Standard ML. The MIT Press, Cam\u00adbridge, Mass, 1990. Nelson, G. (cd.). Systems Programming with Modula-3. \nPrentice-Hall, Englewood Cliffs, N.J., 1991. Palsberg, J. Efficient inference of object types. In Proceedings, \nNinth Annual IEEE Symposium on Logic in Computer Science, 1994, pp. 186 195. [Pie94] [PT93a] [PT93b] \n[R6m94] [Sha94] [S0178] [Ste90] [str94] [TT94J [US871 [Wan87] Pierce, B. Bounded quantification is unde\u00adcidable. \nIn C. A. Gunter and J. C. Mitchell (eds.), Theoretical Aspects Of Object-Oriented Programming. Types, \nSemantics and Language Design, pp. 427 459. MIT Press, 1994. Pierce, B. C, and D. N. Timer. Object-oriented \nprogramming without recursive types. In Con\u00adference Record of the 20th Annual ACM Sympo\u00adsium on Principles \nof Programming Languages, January 1993, pp. 299-312. Pierce, B. C. and D. N. Turner. Statically typed \nfriendly functions via partially abstract types. Technical Report ECS-LFCS-93-256, Univer\u00adsity of Edinburgh, \nLFCS, April 1993. Also available as INRIA-Rocquencourt Rapport de Recherche No. 1899. R6my, D. Type inference \nfor records in a natu\u00adral extension of ML, In C. A. Gunter and J. C. Mitchell (eds.), Theoretical Aspects \nOf Object-Oriented Programming. Ijpes, Semantics and Language Design, pp. 67-95. MIT Press, 1994. Also \navailable as Research Report 1431, May 1991, INRIA-Rocquencourt, France. Shao, Z. Compiling Standard \nML for E@cient Execution on Modern Machines. Ph.D. disserta\u00adtion, Princeton University, Department of \nCom\u00adputer Science, November 1994. Solomon, M. Type definitions with parameters. In Conference Record \nof the 5th Annual ACM Symposium on Principles of Programming Lan\u00adguages, January 1978, pp. 3 1 38. Steele, \nJr., G. L. Common Lisp: The Language. Digital Press, 2nd edition, 1990. Stroustrup, B, The Design and \nEvolution of C++. Addison Wesley, Reading, Mass., 1994. Thorup, L. and M. Tofte. Object-oriented pro\u00adgr \namming and Standard ML. In Record of the 1994 ACM SIGPLAN Workshop on ML and its Applications, June 1994, \npp. 41 49. Available as INRIA Research Report No. 2265. Ungar, D. and R. B. Smith. Selfi The power of \nsimplicity. In 00PSLA 87 Proceedings, Octo\u00adber 1987, pp. 227-242. Wand, M. Complete type inference for \nsimple objects. In Proceedings, Symposium on Logic in Computer Science. IEEE, 1987, pp. 37 44. Cor\u00adrigendum \nin Proceedings, Symposium on Logic in Computer Science, page 132. IEEE, 1988,  \n\t\t\t", "proc_id": "231379", "abstract": "We propose a new approach to adding objects to Standard ML (SML) based on explicit declarations of object types, object constructors, and subtyping relationships, with a generalization of the SML case statement to a \"typecase\" on object types. The language, called Object ML (OML), has a type system that conservatively extends the SML type system, preserves sound static typing, and permits type inference. The type system sacrifices some of the expressiveness found in recently proposed schemes, but has the virtue of simplicity. We give examples of how features found in other object-oriented languages can be emulated in OML, discuss the formal properties of OML, and describe some implementation issues.", "authors": [{"name": "John Reppy", "author_profile_id": "81100590527", "affiliation": "AT&T Research", "person_id": "PP17010305", "email_address": "", "orcid_id": ""}, {"name": "Jon Riecke", "author_profile_id": "81339524439", "affiliation": "Bell Laboratories", "person_id": "PP31091594", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/231379.231412", "year": "1996", "article_id": "231412", "conference": "PLDI", "title": "Simple objects for Standard ML", "url": "http://dl.acm.org/citation.cfm?id=231412"}