{"article_publication_date": "05-01-1996", "fulltext": "\n Static Detection of Dynamic Memory Errors David Evans evs@larch. lcs.mit.edu MIT Laboratory for Computer \nScience* Abstract Many important classes of bugs result from invrdid assumptions about the results of \nfunctions and the values of parameters and global variables. Using traditional methods, these bugs cannot \nbe detected efficiently at compile-time, since detailed cross-procedural analyses would be required to \ndetermine the relevant assumptions. In this work, we introduce annotations to make certain assumptions \nexplicit at interface points. An efficient static cheeking tool that ex\u00ad ploits these annotations can \ndeteet a broad class of errors including misuses of null pointers, uses of dead storage, memory leaks, \nand dangerous aliasing. This technique has been used successfully to fix memory management problems in \na large program, Introduction The LCLlnt checking tool [4, 2] has been used effectively in both industry \nand academia to detect errors in programs, facilitate en\u00ad hancements to legacy code, and support a programming \nmethod\u00ad ology based on abstract types and explicit interfaces in C. In this work, we extend LCLint to \ndetect abroad class of important errors including misuses of null pointers, failures to allocate or deallocate \nmemory, uses of undefined or deallocated storage, and dangerous or unexpected aliasing. These errors \nare particularly difficult to detect and correct through testing, since their symptoms are often platform \ndependent and may be far-removed from the actual problem. Since these errors typically involve violations \nof non-local constraints, they cannot be detected efficiently at compile-time by traditional methods. \nConsider the sample code fragment in Figure 1. The function setNanre assigns the formal parameter pnsme \nto the global vsri\u00ad able gname. This code may be a correct implementation of some function, but it depends \non many assumptions not apparent from the implementation: before the call, gname must not be the sole \nreference to allocated storage. Otherwise, the assignment statement on ~s work war supported in pm by \nARPA (NCH31314-92-J.1795),NSF (9115797. CCR), and DEC ERP. Permission to make digitabtmrcf copy of part \nor all of HIS work for personal or classroom usa is ranted without fee provided that copies are not made \nor distributed for pro It or commercial ! advantage, the copyright notice, the title of the publication \nand its date appear, and notice is given that copying is by permission of ACM, Inc. To copy otherwise, \nto republish, to post on sewets, or to redistribute to lists, requires prior specific permission andlor \na fee. PLDI 96 5/96 PA, USA Q 1996 ACM 0-69791 -795-219WO005... $505O Figure 1: sample. c I extern char \n*gname; 2 3 void setName (char *pnerne) { 4 gnarne = pnarne; 5] line 4 loses the last reference to this \nstorage and it can never be deallocated. after the call, the actual parameter and the global gname are \naliased. The caller must not deallocate the storage pointed to by the parameter if any code executed \nlater depends on gname (and vice versa).  after the call, gname may not be dereferenced if the parameter \nwas a null pointer. Fur&#38;er, gname may not be de~eferenced as an rvalue if the parameter did not point \nto defined storage.  As is, we cannot determine if a call to setName will cause the program to crash \nor leak memory without careful analysis of the entire program. This anrdysis would be infeasible for \nall but the most trivial programs. To enable local reasoning, we need more information about the code. \nWe extend the LCL interface specification language [5,9] to provide ways of expressing assumptions about \nmemory allocation, initialization and sharing, and introduce annotations to make it con\u00advenient to express \nthese assumptions using qualifiers on declarations in C programs. There have been many academic and commercial \nprojects aimed at producing tools that deted these kinds of errors at run-time (dmal\u00ad10C [10], mprof \n[1 1], and Purify [Pure, Inc.]). These tools can be effective in localizing the symptom of a bug where \na null pointer is dereferenced or where leaking memory is being allocated. In some cases, this is enough \nto discover the actual bug in the code. In others, however, it may only be the beginning of the search. \nRun-time checking also suffers from the flaw that its effectiveness depends entirely on running the right \ntest cases to reveal the prob\u00adlems. This is especially problematic since these tools are expensive and \nintrusive enough that they are often not used when the code is run in production. In our work, annotations \nare used to make assumptions about func\u00adtion interfaces, variables and types explicit. Constraints necessary \nto satisfy these assumptions are checked at compile-time. Places where the constraints are violated are \nanomalies in the code, which typically indicate bugs in the program or undocumented or incor\u00adrect assumptions. \nSection 2 describes how checking works at a high level, and Section 5 describes the analysis in more \ndetail. Sec\u00adtion 3 describes the storage model and what kinds of uses of storage are irregular. Section \n4 describes some of the annotations that can be added to programs to make certain assumptions explicit, \nand checking associated with each annotation, Section 6 illustrates the process of adding annotations \nand detecting errors using a small ex\u00adample program. Section 7 relates experience using this approach \nto fix memory management problems and replace garbage collection with explicit deallocation in a large \nprogram. Analysis Overview Since LCLint is run frequently and on large programs, it is essen\u00adtial that \nthe checking be efficient and scale approximately linearly with the size of the program. Hence, full \ninterprocedttral analysis is too expensive to be practicrd. Instead, each procedure is checked independently, \nbut using more detailed interface information then is normally available. This information may include \nconstraints on the aliases that may be introduced by a called function, constraints on how storage for \na parameter or global variable must be defined before a call and how it will be defined after a call, \nwhether param\u00adeters and return values may be null or may share storage with other references, and other \nconstraints on what maybe modified or used by a called function and how the result of a function call \nrelates to the values of its parameters. This information is available from annotations added to the \nprogram. When a function body is checked, annotations on its parameters and the global variables it uses \nare assumed to be true when the function is entered. The kutction body is checked using these assumptions. \nAt all return points, the function must satisfy the constraints implied by the annotations on its return \nvalue, parameters, and the global variables it uses. When a function call site is encountered, LCLint \nchecks that the arguments and global variables used by the function satisfy the assumptions made by the \nimplementation of the called function. The result of the function and the states of parameters and global \nvariables after the call are assumed to satisfy the constraints implied by the function declaration. \nBy exploiting extra interface information in checking, a wide range of errors can be detected through \nfairly simple procedural analyses. Dataflow vahres keep track of extra information for variables, as \nwell as references derived from variables (e.g., a field in a structure pointed to by a variable) when \nappropriate. This information in\u00adcludes whether or not the reference is defined or maybe null, what other \nstorage it might alias or be aliased by, and what other refer\u00adences might share its storage. This information \nmay be different on different program paths. Rules are used to combine values at con\u00adfluence points. \nIn cases where values cannot be sensibly combim?d art error is reported (e.g., if storage is deallocated \non only one of the paths through an if statement). Certain simplifying assumptions are used to make compile-time \nanalysis feasible and efficient. The key assumptions are: arty pred\u00adicate expression may be true or false, \nthe effects of any while or for loop are identical to those for executing the loop zero or cme times, \ncompile-time unknown array indexes (or pointer offsets) are either all the same element of the array \nor independent elements (depending on art LCLint flag that maybe set locally). LCLint may produce messagesfor \ncorrect code (e.g., a use-before\u00addefinidon error in a branch that would only be taken if art earlier \nbranch initialized the variable). The alternative would be not report\u00ading many anomalies that are likely \nerrors. Since spurious messages can be suppressed locally by placing stylized comments around the code \nthat produces the message, this unsoundness has rarely been a serious problem in practice. LCLint may \nalso fail to produce messages for certain kinds of incorrect code in some contexts, For example, if art \nalias is not detected because it would be produced only after the second iteration of a loop, LCLint \nwill fail to detect an error involving the use of released storage that is only apparent if the alias \nis detected. It is harder to estimate the costs of undetected errors, since there is no way of knowing \nhow many undetected errors remain. Since our goal is to detect as many real bugs as possible efficiently \nand with no programmer interaction, we are willing to accept art analysis that is neither sound nor complete. \nInstead of using worst\u00adcase assumptions, LCLint uses approximations that follow from likely-case assumptions. \nClearly, this would be unacceptable in a compiler optimizer or a theorem prover. However, for a static \nchecking tool it allows many more ambitious checks to be done and more errors to be detected with only \nthe occasionally annoying spurious message. 3 Storage Model This section describes execution-time concepts \nfor describing the state of storage. Some of these concepts correspond to analysis properties used by \nLCLint. Certain uses of storage are likely to indicate program bugs, and are reported as anomalies. LCL \nassumes a CLU-like object storage model. 1 An object is a typed region of storage, Some objects use a \nfixed amount of storage that is allocated and deallocated automatically by the compiler. Other objects \nuse dynamic storage that must be managed by the program. Storage is undejined if it has not been assigned \na value, and defined after it has been assigned a value. An object is completely de$ined if all storage \nthat may be reached from it is defined. What storage is reachable from an object depends on the type \nand vrdue of the object. For example, if p is a pointer to a structure, p is completely defined if the \nvahte of p is NULL, or if every field of the structure p points to is completely defined. When an expression \nis used as the left side of an assignment ex\u00adpression we say it is used as an lvalue. Its location in \nmemory is used, but not its value. Undefined storage may be used as art lvalue since only its location \nis needed. When storage is used in arty other way, such as on the right side of art assignment, as an \noperand to a primitive operator (including the indirection operator, )? or as a function parameter, we \nsay it is used as an rvalue. It is an anomaly to use undefined storage as art rvalue. A pointer is a \ntyped memory address. A pointer is either live or dead. A live pointer is either NULL or art address \nwithin allocated storage. A pointer that points to an object is an object pointer. A pointer that points \ninside an object (e.g., to the third element of an allocated block) is an oflset pointer. A pointer that \npoints to allocated storage that is not defined is an allocated pointer. The result of dereferencing \nan allocated pointer is undefined storage. Hence, it is art anomaly to use it as an rvalue. A dead (or \ndangling ) pointer does not point to allocated storage. A pointer becomes dead if the storage it points \nto is deallocated (e.g., the pointer is passed to the free library function.) It is an anomaly to use \na dead pointer as art rvalue. There is a special object null corresponding to the NULL pointer in a C \nprogram. A pointer that may have the value NULL is a possibly\u00ad %is issimilartotheLISPstoragenwdel,exceptfiat \nOWCB~ tY@. Excepts i zeo f, which dees not need tie vatue of its argument. null pointer. It is an anomaly \nto use a possibly-null pointer where a non-null pointer is expected (e.g., certain function arguments \nor the indirection operator). To allow descriptions of memory constraints, we view each object as having \nan associatedowners set. The owners set indicates which external references may legitimately refer to \nan object. A reference is a variable or a location derived from a variable (e.g., a field of a structure). \nDifferent references may share the same storage. For example, if s and t are char pointers, and s is \nassigned to t, then the references *s and *t are different ways of referring to the same storage. The \nowners set for the storage *s includes both *s and *t. In a function implementation, an external reference \nis any reference that is visible in the environment of the caller (i.e., a reference to any storage that \ncan be reached from the parameters, global variables, or return value). The size of the owners set is \nless than or equal to the traditional reference count since it includes only external references and \nrefer\u00adences that it is valid to dereference (constraints on memory usage may make it invalid to dereference \nsome references, such as those that have been deallocated). It is an anomaly if the owners set for an \nexplicitly allocated object is empty, since this means there are no valid references and the storage \nassociated with the object cannot be released. Failures to free storage are relevant only when memory \nis explicitly deallocated by the programmer, and could he avoided by using a garbage collector [1]. If \nLCLint is used to check programs designed for use with a garbage collector, flags can be used to adjust \nchecking so only those errors relevant in a garbage-collected environment are reported. Annotations Annotations \nprovide a convenient way of expressing interface as\u00adsumptions. Although many of the same assumptions \nare expressible in LCL function specifications, annotations are easier to write and have the important \nadvantage that they can be used to determine appropriate static checking in a straightforward way. We \ncan use annotations in LCL specifications, or directly in the source code as syntactic comments (/* @[annotation]@ \n*/). For example, nul I in an LCL specification or / *@nul I@* / in a C source file may be used in a \nvariable declaration to indicate the variable is a possibly-null pointer (i.e., it may have the vrdue \nNULL). Annotations may be used in a type declaration to constrain all in\u00adstances of a type, in function \nparameter or return value declarations to constrain the use and vahre of parameters and results, and \nin global and static variable declarations to constrain the value and use of the variable. Annotations \nare syntactically similar to C type qualifiers. More than one annotation may be used with a given declaration, \nalthough certain combinations of annotations are incompatible and will pro\u00adduce static errors. An annotation \napplies only to the outer level of a declaration (e.g., nul 1 char **name means that the char * * referenc~ \nby name is a possibly-null pointer, but the ch= * referenced by *name is unqualified,) A type definition \ncan be used to apply annotations to non-outer level declarations.. The idea of keeping additional state \ninformation on variables is similar to that used by the NIL compiler. The NIL compiler [8] extends type \nchecking to also check typestates. Each type has a set of typestates defined by the programming language \nthat can be determined by the compiler at any point in the code. An object can be in only one typestate \nat a given point in the code, but may change typestates during execution. A subset of all operations \nof a type are permitted on an object in a particular typestate and Figure 2: sample. c with nul 1 annotation. \n1 extern char *gnarae; 2 3 void setName ( / *@null@*/ char *pnarae) 4 { 5 gnarae = pnarae; 6 } operations \nmay be declared to change the typestate of an object. The NIL compiler detects execution sequences that \nviolate typestate constraints at compile time. Some of the memory annotations used by LCLint could be \nemulated using typestates. Annotations used by LCLint are simple since our main focus is detecting errors \nat interface points. ADDS [6] presents an approach for dealing with recursive data structures by constraining \npossible aliasing relationships within datatypes. Better checking of internal aliasing would improve \nLCLint checking, but since our focus here is on detecting errors at interface boundaries, the annotations \nwe use are sufficient to detect a wide range of errors. The remainder of this section describes some \nof the annotations and associated checking done by LCLint. A complete list of the annotations related \nto memory checking is found in Appendix B. Null Pointers A common cause of program failures is when a \nnull pointer is deref\u00aderenced. LCLint detects these errors by distinguishing possibly-null pointers at \ninterface boundaries, and checking that a possibly-null pointer is not dereferenced or used where a non-null \npointer is required. In Figure 2, the null annotation is used to indicate that a possibly\u00adnull pointer \nmay he passed as the parameter pnarne. LCLint will report an error if there is a path leading to a dereference \nof the pointer along which there is no check to ensure the pointer is not null. Code can check that a \npossibly-null pointer is not null by USing a Simple COS31pMkOn(e.g., x ! = NULL) or a function call. \nTo indicate that a function returns true when its argument is null the truenull annotation is used on \nthe return valu% f alsenul I is used to indicate that a function returns true only if the argument is \nnot null. Running LCLint on the version of sample. c in Figure 2 produces the message3: sample.c6: Function \nreturns with non-null global gname referencing null storaga sample.c:5: Storage gname may become null \nThe error is reported at the exit point. It would not be an anomaly to assign gname to NULL in the body \nof setName, aslong asit is re\u00adassigned to a non-null value before the function returns or smother function \nusing the global gname is called. The error can be fixed by removing the null annotation on the parameter \n(which would produce messages elsewhere if setNarne is called with a possibly null value) or adding a \nnul 1 annotation to the de&#38;ration of gname (which would produce messages if gname is dereferenced \nwithout first checking it is not null). Another fix is shown in Figure 3. Here, a truenul I function \nis called to test 3LCLint messagesoften include extra information describing the nnonrsly.detected. In \nthis message, the first pnrt explains the anomaly md where it is detected (line 6). The indented pat \nshows where the value may become null (line 5), extern char *gname; extern /*@truenull@*/ isNull (/*@null@*/ \nchar *x) ; void setName (/*@null@*/ char *pname) { if (!isNull (pname)) { gname = pname; } } Figure3: \nFixing sample.c bycallinga truenull function. whether pname is null, and the assignment is only done \nfor non-null values, A variable of a pointer type with no annotation is interpreted as non\u00adnull, unless \nthe type wasdeclared using null. Inthesecases, the type s null annotation may be overridden for specific \ndeclarations of the type using the notnull annotation. This is particularly useful for parameters to \nhidden (static) operations of abstract types where the null test has already been done before the function \nis called, and for return values that are never null. Anadditionalannotation, relnullmaybeused torelaxnullchock\u00ading. \nArelnull pointer isassumed to benon-null when itis used, but no error is reported if a possibly null \nvalue is assigned to it. This is generally used for structure fields that mayor may not be null depending \nonsome other constraint. Itisupto the program\u00admerto ensure that this constraint is satisfied before the \npointer is dereferenced. Definition There is an implicit constraint that all function parameters and \nglobal vrtriables used by afunction arecompletely defined before a call, and that theretum vahseis completely \ndefined after the call. For example, LCLint will report anerror ifapointer acturd parameter is allocated \nbut the storage it points to is not defined, or if a field in a structure pointed to by the return value \nis not defined. Function implementations are checked assuming all parameters and globat variables are \ncompletely defined at entry to the function. Occasionally, it is desirable to have parameters or return \nvalues that reference undefined or partially definrxt storage. For example, a pointer may be passed as \nan argument that is intended as an address to store a result, or a memory allocator may return allocated \nbut undefined storage. The out qualifier cart be used to denote storage that may be not be completely \ndefined, An actual parameter that corresponds to a formal parameter with an out annotation must be defined \nbut need not be completely defined. That is, the actual parameter is used as an rvalue so it must be \ndefined, but storage reachable from the actual parameter need not be defined. LCLint does not report \nan error when allocated storage is passed as an out parameter. After the call, storage that was passed \nas an out parameter is assumed to be completely defined. Within the implementation of a function, LCLint \nwill assume that an out formal parameter is allocated but that storage reachable from the parameter is \nundefined. Hence, an error is reported if storage derived from it is used as an rvalue before it is defined. \nAn error is reported if the implementation does not define all storage reachable from an out parameter \nbefore returning. An analogous annotation, undef, may be used on a global variable in the globals list \nfor a function to indicate that the global variable may be undefined when the function is called. The \npart ial qualifier can be used to relax checking of structure fields. A structure qualified with partial \nmay have undefintxl fields. LCLint reports no errors when these fields are used. Similar to reh-ml I, \nthe reldef qualifier is provided to relax definition checking, and is sometimes useful in field declarations. \nAllocation There are two kinds of deallocation errors with which we are con\u00adcerned: deallocating storage \nwhen there are other live references to the same storage, or failing to deallocate storage before the \nlast ref\u00aderence to it is lost. To handle these deallocation errors, we introduce a concept of an obligation \nto release storage. Every time storage is allocated, it creates an obligation to release the storage. \nThis obli\u00adgation is attached to the reference to which the storage is assigned. Before the scope of the \nreference is exited or it is assigned to a new value, the storage to which it points must be released. \nAnnotations can he used to indicate that this obligation is transferred through a return vahre, function \nparameter or assignment to an external reference. The only annotation is used to indicate that a reference \nis the only pointer to the objeet it points to. We can view the reference as having an obligation to \nrelease this storage. This obligation is satisfied by transferring it to some other reference in one \nof three ways: 1. pass it as an actual parameter corresponding to a formal pa\u00adrameter declared with an \nonly annotation 2. assign it to an external reference declared with an onl y an\u00adnotation 3. return \nit as a result declared with an only annotation  After the release obligation is transferred, the original \nreference is a dead pointer and the storage it points to may not be used. All obligations to release \nstorage stem from allocation routines (e.g., malloc), and are ultimately satisfied by calls to dealloeators \n(e.g., free). The standard library provides some allocation and deallocation routines, The basic allocator, \nmal 10C, is specified as, null out only void *malloc (size_t size) ; It returns a possibly-null pointer \n(it returns NULL when the requested memory cannot be allocated) that is not completely defined and is \nnot referenced by any reference other than the function return value. The deallocator, free, is specified \nas void free (null out only void *ptr) ; The argument to free is a possibly-null,4 not necessarily com\u00adpletely \ndefined, pointer to unshared storage. Since the parameter is deelared using only, the caller may not \nuse the referenced object after the call, and may not pass in a reference to a shared objcet. There is \nnothing special about malloc and free their behavior can be described entirely in terms of the provided \nannotations.s Other annotations can be used to express different assumptions about memory management. \nThe temp annotation is used on a formal parameter to indicate that the called function may not deal\u00adlocate \nthe storage the parameter refers to or create new external references to this storage. At a call site \nwhere a reference is passed as a temp parameter, the aliases to the storage it references are the same \nbefore and after the call. 4 Ilre ANSI Standard allows a null pninter to be passed to free. Many older \nC implermntat.ions do not suppnrtthis, so it may be desirable to use an akemative specificationwith no \nnul 1 annotation. To check that rdlecated objects are completely destroyed (e.g., aSlunshared objects \ninside a s@nctureare deallocated heforz the structure is deallocated), LCLint checks thatanyparameterpassedasanout \nonly void * driesnot cnntain references to Sive,unshared objects. This makes sense,since such a parameter \ncould not be used sensibly in any way other than deallocating its storage. 1 extern /*@onlYt?*/ char \n*gname; 2 3 void setName (/*@temp@*/ char *pname) 4 { 5 gname = pname; 6 } Figure4 sample .cwithonly \nsndtemp annotations, Figure 4 shows sample. c with inconsistent only and temp anno\u00adtations. LCLhttp rodttcest \nwomessages: sample.c:5: Only storage gname not released befora assignment gnama. pname sample.c:l: Storage \ngname becomes only sample.c:5. Temp storage pname assigned to only gname = pname sample.c:3 Storage pname \nbecomes temp The first message reports a memory leak. Because gname is de\u00adclared using the only annotation, \ngname is the only reference to an object and after the assignment the storage used by thk object can \nnever be reclaimed. The second error warns of an anomaly that could lead to problems, The only reference \ngname now references shared storage. If the caller deallocates the actual parameter, gname will become \na dead pointer. One way to fix the problem would be to assign to gname a copy of the object pointed to \nby pname. Another fix would be to change the declaration of pname from tenrp to only. This would lead \nto other messages reporting places where setName is called with an actttrd parameter that is not an unshared \nreference or where the value of the actual parameter is used after the cdl to setName. In real programs \nit is sometimes necessary to use weaker assump\u00adtions about memory use. The owned annotation denotes a \nrefer\u00adence with an obligation to release storage. Unlike only, however, other external references (marked \nwith dependent annotations) may share this object. It is up to the programmer to ensure that the lifetime \nof a dependent reference is contained within the lifetime of the corresponding owned reference. Additional \nannotations provided for handling reference counted storage, tmfreeable shared storage, and exposure \nfor internrd refer\u00adences are described in [3]. Aliasing Program errors often result when there is unexpected \nsliasing be\u00adtween parameters, return values, and global variables. Since alias\u00ading problems sometimes \nlead to deallocation errors, the annotations provided for detecting allocation anomalies also detect \nmany of the common aliasing anomalies. llvo additional annotations are provided to improve alias analysis \nand to detect other problems involving aliases. The returned qualifier cart be used in a formal parameter \ndecla\u00adration to indicate that the return value may alias this parameter. It may be used in conjunction \nwith the allocation qualifiers, and is commonly used with t emp to indicate that no new aliases for the \nparameter will be created except for the return value. The unique qualifier is similar to on~y except \nit does not transfer the obligation to release storage and does not prevent aliasing that is invisible \nto the called function. I typedef /*@nullG*/ struct _list 2{ 3 /*@only@* / char *this; 4 /*@null C3*//*Cionly@*f \nstruck _list *next; 5} *list; 6 7 extern /*@out2@* / / *@only@* / void * 8 smalloc (size_t) ; 9 It)void \nII list_addh (/*@tempo?*/ list 1, 12 /*~only@* / char e) 13 { 14 if (1 != NULL) 15 { 16 while ( l->next \n!. ~LL) 17 { 18 1 = l->next; 19 ) 20 21 l->next = (list) 22 smalloc (sizeof (*1-> next) ) ; 23 l->next->this \n= e; 24 } 25 } Figure 5: Buggy 1 is t .addh implementation. 5 Analysis The annotations and type definitions \ndetermine the initial dataflow vaiues of variables and constrain the acceptable vahtes ,for parame\u00adters, \nglobal variables, and function results at interface points. Three values are associated with each reference: \nthe definition state (de\u00adfined, partially defined, allocated, etc.), the null state (definitely null, \npossibly null, not null, etc.), and the allocation state (cor\u00adresponding to the allocation annotation, \ne.g., only, t emp). These vahres may change when assignments or function calls occur in the program. \nAn anomaly is reported if values are inconsistent at an interface point, Figure 5 showsabuggy program \nto add anode at the end of a linked list. There are two problems: the case where the parameter I. is \nnull is not handled correctly and the next field of the new node rdlocated on line 21 is never defined. \nFigure 6 shows the control flow graph that corresponds to 1 is taddh. The circled numbers are used to \nrefer to execution points. Point 1 is the function entry point. Here, the dataflow values are set according \nto the annotations and type definitions. For parameter 1, the type definition for 1 is thas a nul 1 artnotation \nso its null state is POSS ibly-nul 1. It has no definition annotation, so it is complet el y-de fined. \nBecause of the temp annotation, its allocation state is temp. Similarly, the parameter e is characterized \nas completely-defined, not-null, and only. Since the function parameter may be assigned to a new vahte \nin the function implementation, we need a way of distinguishing a refer\u00adence that corresponds to the \nactual parameter from the parameter inside the function body. We introduce a local variable 1 to repre\u00adsent \nthe parameter in the function body. In this discussion, we use 1 to refer to the local variable and argl \nto refer to the externally visible parameter. At the function entrance, 1 aliases argl. At point 2, the \nnull state of 1 is not null. Because of the i f statement in line 14, we know at compile-time that 1 \nis non-null if point 2 is Function Entrance 1 ? 14: if (1 != NULL) ~ykf 18: 1 = l->next 6 7 -v / 21: \nl->next = smalloc (...) 8 ?/ 23: l->next->this = e 9 10 % FunctionExit 11 b Figure6: Controlflow graphforlist-addh. \nreached. Conversely, atpoint3 weknowthatl is null. The while loop is treated identically to an if statement \n there is no back edge torepresent normal loop execution. This means the analysis can be done efficiently \nwithout any need to do iteration. Tbkresults in a less accurate approximation fortbe acturd pro\u00adgram \nexecution than would be achieved using an iterative dataflow analysis, but it is good enough for the \nkinds of analyses we do here. f% ebodyofth ewhileloo passignsl-mext tel. Atpoint 6,1 mayalitts argl-~next. \nAtpoint 7,the branches merge. Theonly difference is that on the true branch I aliases argl-mext and on \ntbefalse brrmchl aliases argl. Tbepossible aliases atconfluence points istheunion of thepossible aliases \noneach branch. So, at point 7,1mayalias arglorargl->next. Unreality, lmayalias argl->next for any i >= \nO (i.e., the loop may he executed any number of times). Since LCLint does not model executions over the \nloop back edge, the only aliases of 1 that are detected are argl and argl -Fnext, At line 21, the result \nof a call to smal 10C is assigned to 1 -mext. The return value of smalloc is annotated out and only, \nso after the assignment (point 8) 1 -mext is characterized as allocated, non-nul 1, and only. Since 1 \n-=-next may alias argl ->next (and argl-mext-mext), the state of argl->next is also allocated, non-null, \nand only. The change in definition state propagates to its base reference, I (and argl, because of aliasing). \nBefore the assignment, 1 was completely defined, Now, we have assigned storage derivable from 1 to a \nvahte that is incompletely defined, so I is now characterized as Dartially-def ined. is annotated with \nonly. So, the allocation state of e becomes kept. This means its obligation to release storage has been \nsatisfied, but it can still be safely used. (If it had been passed as an only parameter instead, its \ndefinition state would become dead to indicate that is may not be used.) Since e aliases arg2, the allocation \nstate of arg2 is also set to kept, and the obligation to released storage implied by the only annotation \non the parameter e has been satisfied on this path. After the assignment in line 23, I ->next ->this \nis de f i.ned. As before, this definition propagates to its base storage, and 1 ->next and 1 (which is \nalready partially-defined) are marked partially-clef ined. At point 10, the two branches merge. On the \ntrue branch, the allocation state of e is kept. On the fake branch, it is only, This is a confluence \nerror since there is no sensible way to combine the allocation states one means the storage must be \nreleased, and the other means it must not be released. LCLint reports this as a program anomaly. To prevent \nfurther errors, the allocation state of e is set to a special error marker. Also at point 10, we need \nto merge the dataflow values associ\u00adated with I and arql. On the true branch from point 9, I and l->next \narepartially-def ined, l-znext-zthis is def ined, and 1 -mext->next is undefined. On the false branch, \n1 is completely defined. Definition states are combined using the weakest assumption. Hence, at point \n10, 1 and 1 -mext are part ially-def ined, ~d 1 ->next -mext is undefined. Tire definition states for \nargl and its derived storage are handled simi\u00adlarly. Point 11 is the function exit. LCLlnt checks that \nthe function implementation satisfies the extemrd constraints. One implicit con\u00adstraint is that argl \nmust be completely defined when the call re\u00adturns. Since the definition state of argl is partially-defined, \nLCLint checks that all storage derivable from argl is defined. Since argl -snext -~next is uncle f i.ned, \nLCLint produces an error re\u00adporting an incomplete definition anomaly. 6 Example This section demonstrates \nhow annotations can be added to an existing program, thereby improving its documentation and main\u00adtainability, \nand detecting errors in the process. For this example, we use the toy employee database program (1000 \nlines of source code and 300 lines of interface specifications) described in [5]. In [2], we described \nhow LCLint without dynamic memory checking wasusedontheoriginal databaseprogram, Here,westartwith the \ndatabaseprogram after correcting the errors described there. (For information on obtaining the complete \ncode used in this example, seeAppendix A.) We start with a program with no annotations. LCLint s interpre\u00adtations \nof declarations with no annotations are chosen to make it possible to begin finding errors in an existing \nprogram without hav\u00ading to spend a lot of time adding annotations or being overwhelmed bymessages,Thedefaultinterpretations \ncanbecontrolled byflags, to better suit a particular program. The interpretation of a declaration with \nno null pointer or definition annotation is chosen so that the interpretations when annotations are missing \nplace the strictest constraints on actual parameters and return values they may not be null, and must \nbe completely defined. LCLint checking will alert the programmer to places where this is not the case. \nThese maybe errors in the code or places where a nul I or out annotation should be added. An unqualified \nformal parameter is assumed to be temp storage. Line 23 assigns e to l->next ->this. Before the assignment, \ne This places the weakest constraints on actual arguments, but con\u00ad is defined, not-null, and only. f \nbe assignment transfers the strains how the parameter may be used in the function implementa\u00ad obligation \nto release storage, since the thLs field of the 1 is t type typedef struct _elem { eref val; struct _elem \n*next; } *ercElem; typedef struct { ercElem *vals; int size; ] *erc; ,.. 16erc erc_create (void) { 17 \nerc c = (erc) malloc (sizeof (*c)); 18 19 i.f (c == NULL) { 20 error ( malloc returned null ) ; 21 exit \n(EXIT_FAILURE) ; 22 ) 23 24 C->vals = NULL; 25 C->size = O; 26 return c; 27 } Figure7: erc.create fromerc.c \ntion. Implicitonly annotations canatso beappliedtoretum values, structure fields andglobal variables. \nForthis example, wehave not used any of the implicit onlyrmnotations, sowewill see how the checking leads \nus to make these annotations explicit, Adding annotations is an iterative process. With each iteration, \nLCLint detects some anomaties, annotations are added or discov\u00adered bugs are fixed, and LCLint is run \nagain to propagate the new annotations up the call chain. The rest of this section will show how different \ntypes of checking lead us to add annotations and mskechsngestothecode. Onlyafewannotationsarenecessaryto \ngetusefulchecking, todetectafewreal problems inthecode, and toenhancetheinterface documentation. Null \nPointers One anomaty involving null pointers is reported for the function erc.create (shown in Figure \n7): erc.c:26: Null storage c+vals derivable from return value: c erc.c24 Storage c->vals becomes null \nThe vak field of c was assigned to NULL on line 24. In this case, the code is correct and the reported \nanomaty suggests that a nul 1 annotation is needed on the vals field in the type definition for erc: \ntypedef struct { /*@null@*/ ercElem vals; int size; } erc; Running LCLint after this change detects three \nnew anomalies. One i~ in the macro definition of erc.choose for the parameter c of type erc: erc.h:l \n4: Arrow access from possibly null pointer c+vals: (c+vals)->val Since we have added the nul 1 annotation \nto the vals field of erc, c ->va Is may be a null pointer. So, LCLlnt detects an snomaty when it is dereferenced \nby the arrow operator. The specification for erc.choose includes a requires clauseb constraining the \nsize of the 6A rrquires clause in an LCL specification places constminrs on the caller before dre function \nis cutled. If the requires clause is not satisfied, tbe behavior of the implementation is unconstmined. \nThe requires clause is not interpreted by LCLkrt. collection to be greater than o. From this it follows \nthat the value of c ->vals is not null. An assertion is added to the code to check that c-xals is not \nnull. The other two anomtiles involve similar problems in other func\u00adtions. While none of these indicate \na bug in the code because of the requires clauses, they do draw our attention to places where there are \ndependencies on extemat constraints and the added assertions may be helpful in debugging clients that \ndo not satisfy the requires clauses. The checking has directed us to places where adding assertion cheeks \nwould be good defensive programming practice. Further, the null annotation on the vals field of the type \ndefinition serves as useful documentation. Allocation Next, we look for errors involving deallocation. \nWe are starting with a program with no allocation annotations, but using a standard li\u00adbrary with annotated \nversions of malloc and free. For expository purposes, we run LCLint with a command line flag (-al I imponly) \nthat turns off the implicit only annotations on return values, global variables, and structure fields. \nHence, LCLint will produce a mes\u00adsage everywhere newly allocated storage is returned or external storage \nis deallocated, (It would be impractical to check a rest program without using impticit annotations.) \nSeven anomalies are detected by LCLint, all resulting from missing only annotations. TWO messages concern \nthe return statements in erc-create and erc-sprint. Both functions return a pointer that was the result \nof a call to malloc. Since the function result has no only annotation, the obligation to release this \nstorage is not transferred to the caller and a memory leak is suspected. Hence, only annotations are \nadded to the function return value declarations. Four messages concern assignment of allocated storage \nto fields of a static variable (eref _pool in eref. c). These are fixed by adding only annotations to \ntwo fields of the type declaration. The remaining message concerns the call to free in erc_f inal: erc.c:49: \nImplicitly temp storage c passed as only param: free (c) Since c is an external parameter with no only \nqualifier, an anomaly is detected when it is passed to free since it matches a formal parameter declared \nwith an only annotation. The only annotation needs to be added to the parameter declaration for erc-f \ninal. After the changes, LCLint detects six new anomalies. They result from the only annotations that \nwere added to erc propagating to crdIing functions. They are similar to those we have already seen and \ncan be fixed by adding only annotations to function declarations. As before, the new annotations propagate \nup the call chain to pro\u00adduce more messages. Six memory leaks are detected in the test driver code where \nvariables referencing allocated storage are as\u00adsigned to new values before the old storage is released. \nAfter these are fixed by adding calls to free, no allocation anomrdies are de\u00adtected by LCLint. If we \nhad not used the flag to disable the implicit annotations, these six errors would have been found directly, \nThe onty annotations that would be needed are the annotations on the parameters. Aliasing one aIiasing \nanomaly is reported in employee-setName (shown in Figure 8): employee.cl 3 Parameter 1 (e+name) to function \nstrcpy is declared unique but may be aliased externally by parameter 2 (s) 50 4 bool 5employee_setName \n(employee *e, char *s) 6( .. (checkssize ofs) 13 strcpy(e->narne, s) ; 14 return TRUE; 15 ) Figtrre8: \nemployee.setName fromemployee.c Thespecificationof strcpyinthe strmdard libraryis: char *strcpy (out \nreturned unique char *s1, char *s2); The uni~e qualifier indicates that SI. must refer to storage that \nis not shsredby any other parameter or accessible globaf (in this case, the parameter s2), This is necessary \nsince the behavior of strcpyis undefined if the arguments share storage space. Since theargumentstoemployee.setName \narenotqualified,it impossible that e-xmmeands refer tothe same storage. Weaddaunic~e qualifier to the \nparameter declaration for s to document that the parameter must not reference any external storage reachable \nfrom this function. Since there are no global variables, this means the parameters e and s must not share \nany storage. Now, if a client calls emploYee-setName with dependent parameters, LCLint will report an \nanomaly. Summary A total of 15 annotations were needed to resolve all deteeted artonla\u00adlies one null \nannotation on a structure field, one out annota\u00adtion on a parameter (that was detected through complete \ndefinition checking), and 13 only annotations. Of the 13 only annotations, only 2 would have been necessary \nif we had set command-line flags to use implicit annotations. With minimal effort in adding armota\u00adtions, \na few emors in the code were found and the documentation was improved considerably. Experience Part of \nthe motivation for this work was my own troubles deal\u00ading with memory management in the implementation \nof LCLilot. LCLint is over 100000 lines of source code7 and incorporates code from at least three different \nauthors employing different memory management styles. The original implementation did not attempt to \ndeallocate memory completely, and a garbage collector was used to reclaim storage. Although this was \nsatisfactory as a research vehicle, it had practical disadvantages and limited the number of platforms \nto which LCLint could be easily ported, Several earlier attempts to fix LCLint s memory management by \nmyself and oth\u00aders had failed. One frustrated person who attempted to port LCLint wrote ..its implementation \nwith regard to memory manage\u00adment is horrible. Memory is allocated willy-nilly with\u00adout any way to track \nit or recover it. Malloeed pointers are passed and assigned in a labyrinth of complex in\u00adternal data \nstructures. It becomes impossible to find their true scope, let alone determine when they might be safely \nfreed. [7] We used the annotations and associated checking described in this paper to make substantial \nimprovements to LCLint. Garbage col\u00adlection was replaced by explicit memory deallocation, producing a \nmore portable system with improved performance. Numerous bugs relating to null pointer dereferences, \nincomplete definition (usually forgetting to initialize a structure field), and aliasing were detected. \nMemory artnotations also enabled certain efficiency improvements (such as sharing storage Or US@NULL \nto represent the empty string) that were considered too risky to attempt without them. Further, the resulting \nsystem is clearly documented with checked memory annotations. This allows maintenance changes to be made \neasily, and their extemrd effects to he detected quickly. Annotations were added in an iterative process, \nsimilar to that de\u00adscribed in Section 6, Running LCLint on the code with no armo\u00adtations produced on \nthe order of a thousand messages. Nearly all of these messages, however, were quickly eliminated by adding \nan annotation or making a small change to the code (usually adding a missing free to fix a storage leak). \nOften, adding a single annota\u00adtion on a type declaration or parameter would eliminate dozens of messages. \nSince LCLint was run repeatedly on the code after changing anno\u00adtations, it was important that the checking \nwas efficient, It takes less than four minutes (on a DEC 3000/500) to check the entire program. During \nthe later phases, checking became more modular as I focused on subtle problems in a single file. By using \nlibraries to store interface information, a representative 5000 line module is checked in under 10 seconds. \nIt took a few days (split over severaf weeks) to add all the annotations and fix the detected problems. \nThis compares favorably to more than a week spent previously trying to fix these problems unsuccessfully \nusing run-time methods. For the most part, adding annotations is a fairly methodical process, and I hope \nfuture work will make it possible to automate a large portion of it. In the course of checking, the need \nfor the relaxed checking an\u00adnotations (relnul 1, part ial, and relde f ) became apparent. There were \nsituations where simple annotations were not expressive enough to describe constraints, so checking needed \nto be relaxed to eliminate spurious messages. This eliminates many messages without much effort, but \nit also means less checking is done and more errors may be undetected. Some of the reported messages \nwere considered spurious. There were 75 places where stylized comments were used to suppress messages \nrelating to checks described in this paper. The most common problem was where different branches of an \nif statement used storage inconsistently. Many of these were places where the code was attempting to \nreeover from a failed assertion or handling an error condition (e.g., anew object denoting an error is \nreturned from a function that does not normally return only storage), so LCLint was correct in reporting \nan anomaly but it was not considered a bug that needed to be fixed. The remaining spurious messages resulted \nfrom places where either LCLint s alias analysis is not good enough to handle the code correetly, LCLint \ns execution flow analysis is not good enough to determine that a particular path through the code will \nnever be taken, or where the code violates constraints imposed by the annotations in a way that I believed \nto be safe because of external constraints. The dangers of suppressing messages became clear when testing \nrevealed that one of these suppressed messages indicated a real bug. After checking was complete, I tested \nthe program with explicit LCLint does many checks not described in this paper (snd not related to dynamic \ndeallocation. As expected, not all memory management bugs had memory msnagemcnt). Approximately 7GO0tines \nof code are dircctty related to the checks described here. been detected statically. There were a few \nerrors involving incor\u00ad rectly freeing storage resulting from pointer arithmetic, two errors resulting \nfrom freeing static storage, * two errors resulting from missing annotations in the standard library \nspecification, and one emor involving a complex dependency on a global variable. Then, run-time tools \nwere used to look for remaining memory leaks. Sev\u00aderal were detected, relating to storage reachable from \nglobal and static variables that was not deallocated. Since LCLint does not do interprocedural program \nflow analysis, it cannot detect failures to free global storage before execution terminates,g 8 Conclusion \nIn this paper, we have seen how annotations can be added to make assumptions about memory management \nexplicit at interface points. The annotations improve program documentation, and can be used by a static \nchecker to detect anomalies that typically indicate bugs or incorrect annotations. We were able to use \nthk approach to fix memory relocation problems in a large program where ad hoc and run-time checking \nmethods had failed. Annotations and static checking made it possible to fix memory management problems \nin a systematic, goal-directed manner. The memory annotations were a great help in maintaining and developing \ncode. It is easy to see the effect of a change in memory sharing by changing an annotation and running \nLCLint. Static checking cannot detect all errors, and certainly does not eliminate the need for run-time \nchecking and extensive testing. However, a combination of static checking using annotations and run-time \nchecking and testing can help produce reliable code with less effort than traditional methods. We do \nnot yet have experience using this approach as a new program is developed. I suspect adding annotations \nwhile a new program is being developed would not pose a major overhead. Programmers should consider their \nassumptions about external constraints, and the annotations provide a convenient and precise way of document\u00ading \nsome of these assumptions. Acknowledgements I thank John Guttag for help with this research and writing \nthis paper, Thomas Reps from the program committee for constructive comments well beyond the call of \nduty, Raymie Stata for reviewing a draft of this paper, and Sheryl Risacher for help with the abstract. \nReferences [1] Hans-J. Boehm and Mark Weiser. Garbage collection in an uncooperative environment. Software \nPractice and Experi\u00adence, September 1988. [2] David Evans. Using Specifications to Check Source Code, \nMIT/LCS/TR-628, MIT Laboratory for Computer Science, June 1994. [3] David Evans. LCLint User s Guide, \nVersion 2.0. February 1996. (http:/flarch-w.lcs. mit.edu:8OOlllarcMclinffguide/) [4] David Evans, John \nGuttag, Jim Horning and Yang Meng TarL LCLint: A tool for using specifications to check code. SIGSOIT \nSymposium on the Foundations of Software En\u00adgineering, December 1994. [5] J.V. Guttag and J.J. Homing \nwith S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. Larch: Languages and Tools for Formal Specijlcation, \nSpringer-Verlag, 1993. [6] Laurie Hendren and Joseph Hummel. Abstractions for recur\u00adsive pointer data \nstructures: improving the analysis and trans\u00adformation of imperative programs. SIGPLAN Conference on \nProgramming Language Design and Implementation, 1992. [7] Posting in comp. os. linux, August 1994. [8] \nRobert Strom and Nagui Halim. A new progrdng methodology for long-lived software systems. IBM-RC 9979, \nIBM T. J. Watson Research Center, March 1983. [9] Yang Meng Tan. Formal Speci@cation Techniques for Pro\u00admoting \nSoftware Modulan ~, Enhancing Sojlware Documen\u00adtation, and Testing Speci$cations, MIT/LCS/TR-619, MIT \nLaboratory for Computer Science, June 1994. [10] Gray Watson, Debug Malloc Library, November 1994. (ftp://ftp.lelters.conVsrc/dmalloc/docs/dmalloc.ps) \n [11] Benjamin Zom and Paul Hilfinger. A memory allocation profiler for C and Lisp programs. (ftpi/gatekeeper.dec.com:/pbu/misc/mprof-3.O.tar.Z) \nA Availability The web home page for LCLint is http://larch-www.lcs. mit.edu:8OOl/larcMclint/index.html \nLCLint can be downloaded from http:/llarch-wmv.lcs, mit,edu:8001 /larcMclint/download .html or obtained \nvia anonymous ftp from ftp:/ilarch.lcs. mit,edu/pub/LarcMclinff Several UNIX platforms are supported \nand source code is available. LCLint can also be run remotely using a form at http://larch-www.lcs. mit.edu:8OOl/larcMclint/run.html \nThe example described in Section 6 is found at http:/flarch-www.lcs. mit.edu:8OOl/larcMclint/samplea/db/ \nTo receive announcements of new releases, send a (human-readable) message to lclint-request@ larch.lcs.mit.edu. \nB Memory Management Annotations All annotations may be used in either an LCL specification or in a C \nsource or header file preceded by / *@. Unless excluded explicitly, annotations can be applied to a type \ndefinition, variable declara\u00adtion, parameter declaration, or function return value. At most oue annotation \nin any category can be used on a given declaration. Null Pointers nu 11 May have the value NULL. notnul \n1 Not permitted to have the value NULL. This is implied if there is no annotation, but maybe necessary \nfor some decla\u00adrations to override nul 1 in a type definition. re lnul I Relax null checking. Value assumed \nto be non-rwrLL when it is used, but maybe assigned to NULL. 8LCLint hassincebeenimprovedto detectIi \neeingoffsetpointersandststicstnrage, If the programk nm in an environmentwhereall memory is reclaimed \nwhen execntion exits, this is not a serions prnblem. Definition out Referenced storage need not be defined. \nForpararneters, this means passed memory must be allocated but not necessarily defined. For return values, \nit means the result is allocated but not necessarily defined. in Referenced storage is completely defined, \n(Normally, this is assumed if no other definition annotation is used. Flags can be used to allow the \nout annotation to be assumed for unan\u00adnotated parameters where it would prevent a message.) part ia I. \nReferenced storage is partially defined. No errors are reported when incompletely defined storageis transferred \nasa part ial, and no error is reported when storage derived from a partial is Used. relde f Relax definition \nchecking, Value assumed to be defined when it is used, but need not be assigned to defined storage. Allocation \nonly Refers to unshared storage; confers obligation to release this storage or transfer the obligation. \nkeep Like only, except that the caller may safely use the reference after the call. (Function parameters \nonly.) temp Temporary storage. Function may not deallocate or add new external references to storage. \n(Function parameters only,) owned Refers to storage that may be shared by dependent refer\u00adences. This \nreference is responsible for releasing the storage. dependent Refers to storage that may be shared by \nan owned reference. This reference may not release the storage. shared Refers to arbitrarily shared storage; \nmay not be deallo\u00adcated. (For use with garbage collectors.) Parameter Aliasing unique May not share storage \nwith any other fimction parameter or accessible global. (Function parameters only,) Returned References \nreturned A reference to the parameter may be returned. (Func\u00adtion parameters only.) Exposure observer \nReturned storage must not be modified (this disallows deallocation rdso) by caller. (Return values only.) \nexposed Mutable returned storage from internal abstract type or passedmutable storage assigned to field \nof abstract type. May be modified but not deallocated. (Return values and function parameters only.)\n\t\t\t", "proc_id": "231379", "abstract": "Many important classes of bugs result from invalid assumptions about the results of functions and the values of parameters and global variables. Using traditional methods, these bugs cannot be detected efficiently at compile-time, since detailed cross-procedural analyses would be required to determine the relevant assumptions. In this work, we introduce annotations to make certain assumptions explicit at interface points. An efficient static checking tool that exploits these annotations can detect a broad class of errors including misuses of null pointers, uses of dead storage, memory leaks, and dangerous aliasing. This technique has been used successfully to fix memory management problems in a large program.", "authors": [{"name": "David Evans", "author_profile_id": "81369590694", "affiliation": "MIT Laboratory for Computer Science", "person_id": "PP64022716", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/231379.231389", "year": "1996", "article_id": "231389", "conference": "PLDI", "title": "Static detection of dynamic memory errors", "url": "http://dl.acm.org/citation.cfm?id=231389"}