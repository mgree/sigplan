{"article_publication_date": "09-01-1991", "fulltext": "\n Phoenix, Arizona 6 -11 October f991 Object Management and Tool Integration Mechanisms in Object-Oriented \nProgram Development Environments Organizers: Dmitry Lenkov Hewlett-Packard Mike Monegan Atherton Technology \n 1. Introduction This workshop brought together researchers and practitioners to explore future directions \nin the underlying object management and tool integration mechanisms used in designing and implementing \nObject-Oriented Program Development Environments (OOPDEs). The workshop consisted of seven presentations \nand a number of general discussion periods. The choice of the workshop focus was inspired by the need \nto better understand data integration mechanisms for the highly-interrelated data associated with modern \nprogram development, by the important role the object model plays in data integration, and by the rather \nimmature nature of truly object-oriented PDEs. The perspective of the OOPDE builder was generally encouraged \nover the user s view of the OOPDE. However, consideration of the end-user s needs played a large role \nin evaluating presented approaches and experiences. 1.1 Object Management The object management focus \nwas described to the participants as consisting of: . an object model used to express tools and data \nin the OOPDE, and . the dynamic nature of the environment, including both (1) the storage, migration, \nbehavior, and access privileges associated with the life of an object in an OOPDE and (2) the evolution \nof the type system as behavior and state are added to existing types and new types are added to the environment. \nThe fundamental nature of this application makes this focus highly important to the OOPDE builders. \n 1.2 Tool Integration The tool integration focus of this workshop is linked closely to the issue of the \ndefinition of a tool and the possible trend towards finer-grain tools traditionally considered to be \nonly tool components. The mechanisms for data integration (e.g., modern OODB systems), control integration \n(e.g., message- routing systems), and other types of integration are generally linked with the issues \nof object management.  2. Presentations Mike Monegan, Workshop Organizer There are a number of recent \ntrends that suggest that OOPDE technology is becoming more widespread and better understood. Recent developments \nin OODBMS technology, framework definitions, and tool-oriented architectures are coupled with increased \nuser demand and expanded multi-user and extensibility requirements for OOPDEs. A basic conceptual model \nfollows from these trends and is based on definitions of the terms framework , tool , and tool component \n(which is an autonomous, often active, object maintaining application state and acting on behalf of the \nuser). A basis for defining data integration was given as: an object model, a link model, underlying \ndatabase technology, persistence model, and the distribution/relocation of objects. Danny Lange, Bruel \n&#38; Kjaer Industri A PDE based on a hypertext model and an OODBMS product demonstrates the usefulness \nof hypertext in PDEs and provides practical experience to establish the requirements for an OODBMS for \nPDEs. A formal model for hypertext provides a basis for the implementation of a class library of object-oriented \nabstractions for use in building a PDE. A definition of an OODBMS and practical experience with the ONTOS \nproduct has lead to a qualitative description of the desirable properties of an OODBMS for PDEs. Much \nof the promise of hypertext and commercial OODBMS technologies demonstrates that future work with hypertext \nand an OODBMS may yield much more sophisticated PDE features, such as version management, support for \ncooperative work, and ad-hoc query mechanisms. Harold Ossher, IBM T.J. Watson Research Center RPDE3 is \na framework for building integrated, direct manipulation enviromnents. The structure of an environment \nis modeled as a framework (with such components as an object store, display manager, command handler, \nkeystroke handler, undo manager, and a selection manager), a set of classes, and a set of commands or \nmethods defined on each class. A tool in RPDE3 is seen as a collection of fragments that span classes \nand include various methods. The term extension-by-addition is coined to describe the notion of adding \nfragments and not making code changes that would invalidate existing tools and objects. RPDE3 provides \n(1) a framework, (2) PlusPlus (reported on at last year s OOPDE workshop), an object definition environment \nto support extension-by-addition, and (3) a structured representation of programs to provide language- \nsensitive processing of programs, through extensions to an environment s functional and data domains. \nJose Pereira, INESC Large software projects employing an object- oriented approach must often deal with \nthousands of classes and their interdependencies. Name space pollution is one of the problems associated \nwith this. Another problem is that of imposing some organizational structure on a large set of classes \nwhich provides <an easier way to navigate among these classes and incorporate them into applications. \nIn response to these problems, the following approach was investigated. Interfaces (functionality groups) \nare separated from implementations where implementations can be created in different languages. Interfaces \nform a type hierarchy with multiple inheritance. Contexts present another structuring mechanism over \ninterfaces. The same mame can appear in different contexts. Contexts also [80 1 9-l 1 October form an \ninheritance hierarchy. Only one implementation of a particular interface in a particular context is supported. \nSuch implementations can be created in one of a designated group of languages. Several tools have been \nbuilt to support and assist in manipulating interface and context hierarchies. In particular, the graphical \nbrowser has proved to be very useful. One of major problems currently under investigation is that of \norganization and management of the persistent storage for the interface and context hierarchies. Doug \nLea A design is being formulated for an object-oriented semantic representation system that can serve \nas the basis for various analytic tools for C++ and possibly other object oriented languages. This semantically \noriented representation model requires an abstract object model that supports the definition of a virtual \nmachine for representing the semantics of the base language. The model is based on an extension to Alan \nSnyder s Abstract Object Model . The internal structure of the representation forms a dispatching grid \nwhich contains nearly all necessary semantic information and which can be stored in a persistent database. \nGrid representation provides the base for a flattening operation and class hierarchies. Interfaces are \nseparated from implementations (classes) and form a simple conformance type model. Work is being done \non adopting good data flow algorithms to be used with this model. The goal is to make all interesting \nsemantic information accessible via data flow analyses. While an object oriented semantic model presents \na number of advantages for the semantic analysis of 00 languages (in particular for C++ which has highly \nirregular syntax), one of the major problems for further investigation is development of a translator \nfrom C++ into our representation. A further area of investigatioa is minimizing the impact of an incremental \nchange of a program on the semantic representation of it. Geoff Wyant, Saber SofrnJare Saber-C++ is a \nfull-function program development environment for C++ (and C) that allows for a highly interactive, exploratory \nstyle of incremental development similar to that found in Smalltalk or Lisp. Its major advantages from \nthe user perspective are: access to a complete C++ interpreter (objects can be created interactively \nand their methods executed, expressions are properly resolved and executed, small source additions and \nmodifications do not require a full recompilation), support of incomplete programs and program fragments \n(arbitrary mixtures of source, object, and library files can be loaded and unresolved references are \ntolerated causing a breakpoint to occur during execution), some advanced debugging capabilities (extensive \nrun-time condition checking of memory semantics, type compatibility, casts, etc.), and state-of-the-art \ngraphical browsers. The underlying technologies include a cfrom-based front end producing semantic trees, \na pcode generator (from semantic trees), a pcode interpreter, a semantic garbage collector, type infomration \nmanagement, and an incremental linker handling pcode and object formats as well as incomplete programs. \nExperience with the environment based on the above technologies leads to the following recommendations \nfor a program representation (object model) to be used in a PDE: the representation should be compact \n( cfron t spreads information across too many structures, semantically-related information should be \nclustered together, impure information should be segregated from pure, the object model should include \nrepresentation of run-time semantics. Alan Sloane, Sun Microsystettrs Design choices in PDEs can be arranged \nalong two axes: how to pass control information among the tools, and how to represent programs and program \nstate information shared by the tools. In traditional environments, the tools are all contained within \na single address space. Integration with external tools is weak, usmally limited to synchronous execution \nof a process, and coimnunication through pipes or files. The Objectworks\\C++ system had to address requirements \nof C++ code development and inter- operability with UNIX programming tools. Architecturally, this resulted \nin major components of the system being built and run as external processes and in a strong dependency \nof the system on information maintained externally in the file system. However, the internal object store \nmainmining a network of objects was still the main mechanism of data sharing among the tools. At Sun, \nthe IPE group is working on environments built on top of ToolTalk, a multicast message server similar \nto Field or HP s Softbench. Such an environment has no central database, but rather a number of local \ndatabases each of which belongs to a tool or a group of tools. The overall aim of the architecture is \nto provide integration and extensibility at three levels: user, tool, and tool builder. 3. Issues Several \ndiscussions during the workshop identified the following issues as having no single or obvious solution \nor answer and requiring further investigation: What characteristics of an object model are most important? \nShould an OOPDE provide support for multiple object models (and extensibility through adding new models) \nor a single extensible model? How do the semantic representation approaches compare with the syntacticly- \nbased approaches to program representation. What is a framework in the context of an OOPDE? Is it different \nfrom the OOPDE itself? If so, what role it plays ? What are the features and specifications required \nof an OODBMS for use in an OOPDE?-Many ideas and suggestions were presented, though it seemed implicit \nthat one s ability to assess these directly impacted one s ability to implement a good OOPDE. . How are \nusers expected to use traditional file-based tools?-There seemed to be very little disagreement that, \nuntil such tools were proven to be less useful than more advanced OOPDE-based tools, a file-based view \nmust be attainable through some export facility. Should some sort of link model be incorporated with \nthe traditional features of an object model ?-Differing opinions were not resolved on this issue. Is \nfine-grained integration of tools necessary to build an effective OOPDE or will coarse-grained tool integration \nsuffice? Should objects be split to allow different security access to different parts of an object? \nWhat is the appropriate granularity of objects visible to the underlying OODBMS (persistent objects vs. \nlogical objects)? What does it mean to support a given execution model of programs under development? \nDoes this have any impact on the tool integration services required of an OOPDE?  4. Future Workshop \nTopics It was suggested that future workshops have a broader focus. Recommended topics include: . Visualization \nand presentation issues . Support for complete software lifecycle b Useful collections frameworks of \nclasses-contracts, . Execution models  Contact information: Dmitry Lenkov Hewlett-Packard 11000 Wolfe \nRoad, MS: 42U5 Cupertino, CA 95014-9804 (408) 447-5279 FAX: (408) 447-4924 drnitry@cuy.hp.corn Mike Monegan \nAtlierton Technology 1333 Bordeaux Drive Sunnyvale, CA 94089 (408) 734-9822 x2 15 FAX: (408) 744-1607 \nnunonegan@atherton. con1 \n\t\t\t", "proc_id": "143773", "abstract": "", "authors": [{"name": "Dmitry Lenkov", "author_profile_id": "81100422576", "affiliation": "", "person_id": "P67667", "email_address": "", "orcid_id": ""}, {"name": "Mike Monegan", "author_profile_id": "81332516649", "affiliation": "", "person_id": "PP31087402", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143773.143796", "year": "1991", "article_id": "143796", "conference": "OOPSLA", "title": "Object management and tool integration mechanisms in object-oriented program development environment", "url": "http://dl.acm.org/citation.cfm?id=143796"}