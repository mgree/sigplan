{"article_publication_date": "09-01-1991", "fulltext": "\n PARALLEL  Phoenix, Arizona 6 -77 October 7991 A Structured Approach to Object-Oriented Design Parallel \nUniverses Report: Norman L. Kerth Elite Systems 1 .O Introduction During OOPSLA 91, there was a unique \nactivity called Parallel Universes where several methodology experts were asked to demonstrate their \nproblem solving approaches upon a problem they had never seen, in front of an audience. This paper presents \na partial solution developed by this author as well as a brief tutorial of his methodology. Space limitations \nprohibit a complete discussion of this disciplined approach to object-oriented design. For further information \nabout the approaches used, please contact the author. 2.0 An Overview of the Methodology A great deal \nhas been learned over the past 20 years about Sfrucmred Methods [Demarcol, [McMenamin], [Shlaer], [Ward], \n[Hatley], [Kerth]. While many people debate the usefulness of structured methods when the goal is to \ndevelop an object-oriented program, I have found a very clean answer. An object-oriented program needs \nto be designed and as such, a object-oriented design methodology is required. But before design, we need \nto analyze what the program is to do. The results of this analysis process needs to be in a form to support \nthe object- oriented design methodology, but an analysis methodology need not be object-oriented. In \nfact, bringing object-oriented concepts such as inheritance into the analysis phase, might cause serious \nerrors in ones analysis! I will come back to this point later. Many methodology experts have come to \nthe conclusion that analyzing a problem with only one modeling technique leaves many issues unsaid. As \na group, we have begun to deploy a multiple models analysis approach. In other words, the problem and \nthe solution to that problem is analyzed with a number of complimentary modeling techniques. After the \nanalysis phase, I move into a design phase where objects are identified from the analysis activity, along \nwith their responsibilities, their interactions, their internal structure including inheritance, etc. \nWhile some experts suggest that one can spiral around a project, oscillating between analysis, design \nand code, when put into practice, 1 have witnessed an undisciplined, out-of-control software evolutionary \nactivity. In the past, we called this hacking. The spiral model was developed by Boehm to describe several \ndisciplined stages of analysis and design incorporating rapid prototypes to resolve unknown issues. I \nsupport Boehm s work but not the lack of discipline that many people mistake as his concept. In the next \nsection I focus my attention on the analysis stage and follow that section with a treatment of object-oriented \ndesign. 2.1 An Analysis Approach The purpose of analysis is to clearly understand the problem to be solved \nas well as understand what a solution to that problem is (without discussing how the solution is to be \nimplemented-which belongs to the design stage). To achieve this understanding I have incorporated the \ntine work of several authors, mixing and matching as called for by the problem domain. While I have used \nseveral modeling techniques, I find that I commonly use four: . information modeling to model the static \naspects of entities, attributes and relationships [Shlaer], . finite state machines for modeling the \nchange in knowledge that an entity might have over time or in response to past history of events, . event-partitioned \ndata-flows to model the process flow [McMenamin] , and * 3D-HIP documents to model the behavior and look \nof the human interface [Kerth]. So we use a multiple modeling approach in analysis for several reasons, \nbut the most important is to master more complex problems than our brain can handle at any one time. \nWe focus our attention upon one modeling technique, and for the time being intentionally ignore other \naspects of the system. If one trusts that ultimately all the necessary information will be captured, \nthen one s mind can be nicely focused. This approach is more similar that different to Shlaer &#38; Mellor \ns approach. The differences are primarily on the use of an event-partitioned data-flow model rather than \nan entity specific data flow, and the addition of a focus on human interfaces. The focus on a system \nwide event-partitioned data flow analysis is driven by my need to understand the processing that must \noccur across the entire problem domain. The information modeling activity, in my approach, is focused \nupon understanding the information in the user s problem domain, it is not a statement of what is to \nbe in the solution but is used very heavily to determine this. Given modern programs and workstations, \nthe human interface becomes so complex, and so important (as the image presented to the user), that careful \nanalysis of human-computer interaction becomes a serious issue. We can no longer expect the programmer \nto figure it out on the fly. Thus 3D-HIP combines a model of views, view-flow and stimulus- state-response \ndefinition into a complementary analysis technique. The sub-sections below make the assumption that the \nreader is familiar with the problem statement which is presented earlier in this addendum [Hopkins]. \nWhere these models deviate or elaborate from the problem definition, it was due to interviews of a domain \nexpert, or a person that circulated through the Parallel Universe sessions adding information to the \nproblem to model a real-life situation. 2.1.1 An Example of Information Modeling (IM) The first modeling \ntechnique, information modeling was discussed by [Shlaerl, but I deploy that work differently. Often \ninformation modeling is used to express information that is to be incorporated into a data base. However, \nmany of my clients and I have used this modeling technique to understand the information that exists \nin the problem domain, It is a model that shows how pieces of information are related and how changes \nto some pieces effect other pieces. Many engineers confuse the capture of this information with developing \na solution to some expressed need. At this point in the specification process, we are simply understanding \nwhat the problem is. Early in the life of a project, a great deal can be learned by thinking about the \nobvious. In the OOPSLA Conference problem, we might learn a great deal about a paper by simply asking \nabout all the information that is kept on a paper. While we quickly grab the obvious-title &#38; author-we \nmight get a great deal of insight to discover that a paper has a status and we learn about the details \nof status. Until one understands the information relationships in the problem domain, they do not understand \nthe problem and can not develop, with confidence, a solution to any aspect of the problem. We have heard \nmanagers ask us to build the right product and build the product right . An information model is needed \nto utiderstand what the right product is. When we begin to think about the problem of automating an OOPSLA \nconference, and ask what information is important to conference organizers? We might talk with a few \npeople, look at various records created at previous conferences, and come to the conclusion that information \nabout papers, tutorial, authors and the such are important to understand. The information model shows \nthe information that we discovered: Information Model of an OOPSLA Conference 1istOfCallForPapers = 1 \nPefiO l 1 person = name + address + city + state + zip + phone + fax + eMail collectionOfPapers = bwrl \n paper = title + { author(r) ) + ( referee(r) + reportsubmitted ) + paperstatus + session(r) + IF paperstatus \n= accepted THEN ( finalProofReceived + invitationSent > author = person + paper(r) paperstatus = [intended \nI submitted I outForReview I allEvaluationsReceived I accepted I rejected ] session = chair + { paper(r) \n} chair = person + session(r) 1istOfNormalInvitees = { memberOfSIGOPS I memberOfOtherSIGS I previousAttendees \n} /* past attendees, sigops, ass sigs, authors, speakers, rejected authors and speakers */ 1istOfPriorityInvitees \n= { author I speaker ) collectionOffutorialAttendees = person + ( tutorial(r) ) 1istOfAttendees = ( name \n+ address + city + state + zip ) collectionOfTutorials = ( tutorial ) tutorial = title + ( speaker(r) \n) + ( subCommitteeMember (r) + reportsubmitted } + tutorialStatus + ( attendee(r) } + IF status = accepted \nTHEN ( fmalProofReceived + [morning I afternoon I fullDay ] ) subCommitteeMember = person tutorialStatus \n= [ submitted I outToReviewers I allReviewsIn I accepted I rejected ] reportsubmitted = [truelfalse] \n In this notation, the = sign is pronounced as is composed of , and the + sign is pronounced and . The \n( ) s are pronounced some number of , the [ I l s means one of the following and ( ) s imply optional \ninformation. So we have a paper is composed of a title and references to some number of authors and . \n.. Many novice object-oriented thinkers observe the similarity between the definitions of paper and tutorial \nand begin to plan for inheritance. This is the mistake mentioned in section 2.0. We are still in the \nstage where we are understanding what information is in the user s problem domain-and inheritance is \na powerful tool to use in the solution domain. A premature assumption that two entities have similar \nbehavior because they have similar structure can be disastrous. Instead, I note that this might lead \nto a solution that can take advantage of inheritance, and defer that decision until I have analyzed the \nbehavior of each of these pieces of information within the system to be built. While developing an understanding \nof the This conference problem provides us with a good information, a piece of information will sometimes \nexample of a kind of information that needs to be be found where its content and meaning will change \nmodeled with a FSM. Both paper and tutorial have over time. For these pieces of information, the nature \nsignificant pieces of knowledge that change over of change is as important to understand as is the tune \nas the result of some incident (while not part of circumstances under which the change occurs. For this \nproblem, the change in knowledge due to a this, I use a finite state machine. passing in time is also \nmodeled with a FSM). 2.1.2 An Example of a Finite-State Machine of Information Change (FSW  We can \nnote these characteristics of a paper with the following FSM model: terOflntentArrives/ aperwithou tLetterOflnten \ntArrives//inte ndedPaperArriv /~perwithou ndedPaperArrivr> 11 papelreceived 11 /paperlsMailedOutForReview/ \nIpaper awaiting reviews paper ready for /paperlsRejected/ /paperlsAccepted/ paper is not Ipaper is part \nof part of conference conference cl /finalDt raft:Receiv letter of intent recorded paper received paper \nawaiting reviews paper ready for decision paper is not part of conference paper is part of conference \npaper is ready for print FINITE STATE IMPLICATIONS OF A paper Definition of Information title + ( author(r) \n} + paperstatus = intended title + { author(r) } + paperstatus = submitted title + { author(r) ] + { \nreferee(r) + (reportsubmitted) } + paperstatus = outForReview title + ( author(r) ) + ( referee(r) + \nreportsubmitted } + paperstatus = allEvaluationRecieved title + ( author(r) ) + paperstatus = rejected \ntitle + ( author(r) ) + paperStatus = accepted + session(r) + finalProofReceived = false + invitationSent \ntitle + ( author(r) } + paperstatus = accepted + session(r) + finalProofReceived = true + invitationSent \nOne can see from this FSM Model that a paper can either enter the system when either of two events occur: \n/letterOfIntentArrives/ or /paperWithoutLetterOfIntentArrives/. The double boxes signify either starting \nstates or ending states. Single boxes are interim states. But this model is not complete unless the implications \nfor the entity paper are understood. So we see from the FINITE STATE IMPLICATIONS OF A paper exactly \nwhat data is valid at each state. Now the designer of a real-life conference automation system may object \nto some of the decisions that we have made about how information is captured and stored. For example, \nthere may be cases where accepted papers may be with drawn from the conference, or rejected papers become \naccepted. That makes sense; this is a toy problem. But what is important is that we have developed a \nmodel that can be read, understood and discussed very early in the process of developing a conference \nautomation system. Such a model can be reviewed and commented upon with little effort or misunderstanding. \nAvoiding this model, but making the same decisions increases the amount of rework much later in the process. \nA finite state machine for tutorial is not included here for space limitations but as one looks at the \nfinite state machine, we note differences in behavior of the information. These differences become very \nimportant when deciding how inheritance might be used to implement paper and tutorial objects. 2.1.3 \nAn Example of Event-Partitioned Data-Flow (EP DFD s) Once the information model and the necessary finite \nstate machines have been developed, our attention can focus on the solution domain. For this we use a \nvariation on structured analysis discussed by [McMenamin] called event-partitioned dam flow. In this \nmodel, we identify an activity or goal that a user turns to our system to accomplish. For each of these \nactivities, we identify the information necessary from the user and the information provided to the user. \nThese activities are called events (not to be confused with the Smalltalk or Macintosh events such as \nmouse clicks or keyboard entries). Addendum to the Proceedings OOPSLA 91 The events that we found in \nour conference automation example include: Organization Committee Events 1. show all papers with no authors \n&#38; all tutorials without all speakers registered. 2. produce list of invitees 3. produce list of \npriority invitees 4. register attendee 5. generate final list of attendees 6. generate list of attendees \nper tutorial   We now develop an event-partitioned data flow diagram with supporting data dictionary \nand mini- specifications (see [DeMarco] for details if structured analysis is not known to you). For \nevery event that we have found, we create a process bubble. There are no process bubbles that are not \nevents, The result is a data flow diagram that has processes interacting with users or other external \nentities and data stores. Note that data never flows from bubble Program Committee Events 1. generate \ncall for papers mailing i list register letter register paper of intent 4: distribute papers to referees \n5. register a referee report 6. record a paper accepted or rejected group papers into a session ii: register \ntutorial 9. distribute tutorial 10. register tutorial report 11. record tutorial as accepted or rejected \n12. schedule tutorial 13. send tutorial notification 14. send paper notification to bubble! Each event \nperforms all the work necessary to accomplish the work that the user set out to accomplish, thus there \nis no reason for data to flow to another event. Returning to the conference automation paper, I present \nan event-partitioned data flow for about a third of the system: + Along with the event-partitioned data \nflow, we create a logical data dictionary, mini-specifications and a physical data dictionary. A logical \ndata dictionary describes the actual data structures that flow between entities or that are stored in \na data store. Much of this definition is fed by the work that we did 011 the information model, but there \nis not a one-for-one correlation. Instead, we make decisions in the solution domain based on our deep \nunderstanding of the problem domain. LOGICAL collectonOfPapers = paper = collectionOfAuthors = author \n= collectionOfReferees = referee = reportsubmitted = invitationsent = paperstatus = finalProofReceived \n= collectionOfSessions = session = chairperson = personalDescription = sessionInf0 = paperData = modifiedSessionInfo \n= refereeAssignmentInfo = intendedInfo = modifiedIntendedInfo = submittedInfo = authorsPersonalDescription \n= [2f3 1 DATA DICTIONARY (for one third of the full system) {Paper) gaperId + title + { authorId ) \n+ ( refereeId ) + paperstatus + sessionId + ( finalProofReceived + invitationsent > ( author } authorId \n+ personalDescription + { paperId) { referee ) refereeId + personalDescription + ( paperId + reportsubmitted \n) [ true I false ] [ true I false ] [ intended I submitted I outForReview I allEvaluationsReceived accepted \nI rejected I [ true I false ] ( session ) sessionId + sessionName + chairperson + { paperId } personalDescription \nname + address + city + state + zipCode + phone + faxNumber + eMailAddress session14 + (sessionName) \n+ (&#38;ah-Person) + (1 paperData 1) paperId + title + ( authorName ) sessionId + (sessionName) + (chairperson) \n+ (( paperId }) personalDescription + ( paperId } title + ( authorsPersonalDescription ) (title) + (( \naut.horsPersonalDescrip tion ) ) title + ( authorsPersonalDescription ) personalDescription 9-11 October \n1991 Phoenix, Arizona decision = [ accepted I rejected ] acceptanceLetter = name + address + title + \nsessionId + sessionName + chairperson + acceptanceText rejectLetter = name + address + title + rejectionText \n For each event, we develop a mini-specification. A data is acquired from other entities or data stores \nand mini-specification describes how all the data how that data is transformed, stored and/or acquired \nfrom the user is used, describes what other presented to the user or other entities. MINI-SPECIFICATIONS \n  register letter of intent Get the intendedlnfo from the user; Create a new paper entry in the collectionOfPapers \nfile, assuring that it has a unique paperId; Using the data from intendedInfo, set this new paper s title \nfield; FOR each authorsPersonalDescription described in the intendedInfo DO Check if author already \nexists in the collectionOfAuthors tile IF exists THEN Get the authorId and add it to the new paper entry; \nELSE does not exist SO Create a new author entry in the collectionOfAuthors file, assuring that it has \na unique authorId; Use the name, address and phone from authorsPersonalDescription to fillout the corresponding \nfield in this new author entry; Add the authorId to the new paper s list of authors; FI OD Set the new \npaper s paperStatus to intended ; register paper Get title of paper from user; Check the collectionOfPapers \nfor an entry with the same title IF entry exists THEN I* display the intendedInfo */ FOR each authorId \nDO  Using authorId, look up the name, address and phone number in the collectionOfAuthors; Display the \nauthors name, address and phone number; OD Permit the user to modify any of the data displayed; Accept \nmodifiedIntendedInfo from user and update the corresponding paper and author entries in collectionOfPapers \nand collectionOfAuthors; Set the paper s paperStatus to submitted ; ELSE entry doesn t exist SO Get submittedInfo \nfrom user; Create a new paper entry in the collectionOlPapers file, assuring that it has a unique paperId; \nUsing the data from submittedInfo, set this new paper s title field; Addendum to the Proceedings OOPSLA \n91 129 1 FOR each authorsPersonalDescription described in the submittedrnfo DO Check if author already \nexists in the collectionOfAuthors file IF exists THEN Get the authorld and add it to the new paper entry; \nELSE does not exist SO Create a new author entry in the collectionOfAuthors file, assuring that it has \na unique authorId; Use the name, address and phone from authorsPersonalDescription to fillout the corresponding \nfield in this new author entry; Add the authorld to the new paper s list of authors; FI OD Set the new \npaper s paperstatus to submitted ; FI  distribute papers to referees WHILE user is not done DO Get \nfrom the user another refereeAssignmentInfo; Create a new referee entry in the collectionOfReferees file, \nassuring that it has a unique refereeId; Using refereeAssignmentInfo, fill out the following fields \nin this new referee entry: name, address, phone as well as references to each of the papers assigned \nfor review; For each paper assigned, set referee s reportsubmitted to false ; FOR each paperId in the \nrefereeAssignmentInfo DO Add the refereeId of this new referee entry to the paper stored in the collectionOfPapers; \nAssure that the paper s paperstatus has been set to outForReview ; OD OD  register a referee report \n Get refereeId and paperId from the user; Use refereeId to access the information on this particular \nreferee in the collectionOfReferees; Using paperId, set the corresponding reportsubmitted to true ; \nUsing paper-Id, access the collectionOfPapers to get a list of all the refereeId s; IF all of these referee \ns have reportsubmitted set to true for this paper THEN Set the paper s paperStatus to allEvaluationsReceived \n;  record a paper accepted or rejected Get the paperId and the decision from the user; Using paperId \naccess the paper in the collectionOfPapers; IF the decision is rejected THEN set paper s paperstatus \nto rejected ; ELSE the decision is accepted SO Set the paper s paperstatus to accepted ; Set finalProofReceived \nto false ; Set invitationsent to false ; FI  group papers into sessions WHILE user is not done DO \nGet the sessionId from the user; IF the sessionId does not exist in the collectionOfSessions THEN Create \na new entry in the collectionOfessions using sessionId as the unique identifier; Display a blank set \nof fields so the user can enter the modiliedSessionInfo; ELSE the scssionId exists SO Using sessionId \nget the sessionName, and the chairPerson s name, address and phone and each paperId from the collectionOfSessions; \nFor each paperId, get the paper s title and a list of author s names from the collectionOfPapers and \nthe collectionOfAuthors; Display all this information as sessionInfo to the user and permit editing on \nthe field that make up the modifiedSessiouInfo; FI When the user is done editing this session, save the \nmodifiedSessionInfo in the collectionOfSessions; OD  send notification of paper FOR each paper in the \ncollectionOfPapers DO IF paperstatus is rejected THEN Get the title and a list of authorId s; FOR each \nauthorId DO  Access the author s name and address from the collectionOfAuthors; Construct and print \na rejectLetter using the form rejectanceText; OD ELSEIF paperStatus is accepted THEN Get the title, list \nof authorId s, sessionId; Use the sessionId to get the chairPerson s name, address and phone, the sessionName \nfrom the collectionOfSessions; FOR each authorId DO Access the author s name and address from the collectionOfAuthors; \nConstruct and print an acceptanceletter using the fomi acceptanceText; OD Set the paper s invitationSent \nto true ; ELSE paperstatus is not in a state where a letter cau be sent SO This situation has not been \ndiscussed with the domain expert; Maybe invitationsent is not just for papers that have been accepted \nbut also for rejected papers; Ifthis is the case, then we need to rework the information model, the finite \nstate machine and the logical data dictionary, as well as this mini-spec. OD The physical data dictionary, \ndefines the exact type of each of the lowest level pieces of data. title = name = address = city = state \n= zip&#38;de = sessionName = rejectionText = acceptanceText = phone = faxNumber = eMailAddress= authorId \n= paperId = refereeId = sessionId = PHYSICAL DATA DICTIONARY TEXT, maximum 128 characters TEXT, maximum \n64 characters TEXT, maximum 128 characters TEXT, maximum 64 characters TEXT, maximum 2 characters STRING \nOF DIGITS, maximum 9 digits long TEXT, maximum 32 characters FORM LETTER - maximum 1024 characters with \ninsertion fields for name, address and title FORM LE ITER - maximum 1024 characters with insertion fields \nfor name, address, title, sessionId, sessionName, chariPerson s name, address, and phone STRING OF DIGITS, \nmaximum 14 digits long STRING OF DIGITS, maximum 14 digits long TEXT, maximum 64 characters POINTER POINTER \nPOINTER POINTER Upon completing the event-partitioned data flow, we have said a great deal about information \ncoming from a user, going to a user and how the data gets processed, but we are not yet ready to design \na solution. Sun Microsystem s Bill Joy has argued that as much as 75% of today s application systems \nare devoted to human interface. If one proceeds to the design phase without specifying the human interface, \nthen a great deal has been left unsaid about WHAT the program will do. Again, this will contribute to \nsignificant rework costs and effort in the later stages of the project (less rework but an unsatisfactory \nhuman interface, is another option). 2.1.4 An Example of a Three Dimensional Human-Interface Perspective \n(3D-HIP) To resolve the human interface issues, we use a Three Dimensional Human Interface Perspective \n(3D-HIP)[Kerth]. The three dimensions include: 1) a collection of graphical representations or views \nseen by and manipulated by the user, 2) a view flow or finite state machine that shows which views follow \nfrom a particular view upon receipt of a specific stimulus, and 3) a collection of operational specifications \nthat document the appropriate response for all stimulus in each view. The design of the human interface \nis design, but it is the design of the system not of the software. So from a coding point-of-view, it \ncan still be thought of as analysis-it is still defining what the software is to do, not how. Nevertheless, \nit is design in the sense that several design decisions need to be made-such as what platform this system \nwill be implemented upon. During design, we synthesize from the analysis models, one of many possible \nsolutions for the human interface. During this synthesis process, we need to be sure each of the events \nis supported, but we have the opportunity to combine those events into a single interface if that provides \nan effective human interface view (or separate an event into several views). Given the amount of space \nrequired to represent a human interface, we will present only the parts of the 3D-HIP specification that \nfollow from the models developed earlier in this paper. 9-11 October 1991 Phoenix, Arizona OOPSLA Program \nCommittee Computer Aided Support System Print: Call-for-Papers mailing list Paper notifications 1 Edit: \n View 1.0 In view 1.0, we see the support for the program solutions. For example, we can create a human \ncommittee, a human interface design decision was interface where all paper interactions will be done \nmade to give the organization committee a separate from one view or each event will be supported with \ninterface. This view and the following ones were it s own set of views. The decision is based on many \nderived from the earlier developed models. One can cognitive and cultural issues beyond the scope of \nthis look at the list of events and convince themselves paper but from the methodology point of view, \nit is that each function is supported by this human important that we can trace from the events list \nand interface and every piece of data shown flowing from the event-partitioned data flow into the views. \nor to the user is part of these views. Many of the Below we see the view that supports the editing the \nhuman interface design decisions have several information we have on a paper: [ New Paperj Selected \nPaper Paoers on Filz-l Paper Id: Agrawal Title. ~--....-----------~-----~~ Andreoli  I ----------_--_______----~~ \nBenson I Bergstein I Status: I Chidamber Chambers Author(s): name ____---__-Coleman DeMichiel address---------city-state-Ghelli \nzip code Gibbs Godard phone----- faxNumber _______ Gold Guimaraes eMail----------- Hanson [NewJ(] \nHarvey Hayes, B. Hayes, F. Helm  Session: _________ - By: Proof Received: Yes Lb OPaper Id Invite \nSent: Yes No aAuthor OTitle 1 [Save Changes] [Undo Changesj 1 I I 1 1 Home 1 1 Tutorials 1 1 Sessions \n1 1 Reviewers I --II- View 2.0 In view 2.0 we see several well defined events supported by this view; \nnamely, register a letter of intent, register paper, record a paper accepted or rejected, and register \na referee report. But as we check our work, we find that there are several possible activities in view \n2.0 that are not directly supported by the earlier analysis. For example, accessing the information stored \non a paper by author is not part of our analysis to date. This happens in real life! As an analysis proceeds, \nit is often that one discovers more about what a user needs from a system. At this point, if this was \na real task with real users, I d talk with my domain specialists and determine if my earlier analysis \ndocuments need to be revised, or whether I have succumbed to a creeping-feature [Brooks]. I would either \nrework my analysis or remove the feature-1 would not simply proceed with a new feature since all the \nimplications have not been taken into account. But this paper has it s limitations so I will acknowledge \nthat these unanalyzed features <are very valuable to the user, but will use the common creeping-feature \neradicating phrase we will implement that feature in Phase II. Thus the revised human interface for view \n2.0 is: 9-11 October 1991 Phoenix, Arizona (New] Selected Paper Papers on File Paper Id: 91 .OOl Title: \n_________________ ----- 91.002 m .g;;$$. _______----_-----____ _---- 91.003 91.005 Status: 91.006 h \n91.015 Author(s): name --  91.016 address--------- 91.019 city-state-zip code phone----- faxNumber \n_______ _ eMail - t Session. .____------By: Proof Received: Yes &#38; *Paper Id Invite Sent: Yes lb \nOTitle [SaveChangesl[UndoChangesJ View 2.0 (revised) In 3D-HIP, we need to show all the variations ou \na messages are often left for the programmer to view, such as error messages and the like. The purpose \ndiscover and word-which results in less than is to graphically grasp all the behavior that might desirable \nresults. This leads use to views 2.1 and 2.2: occur. Error conditions and their associated error [ New \nPaper] I Paoers on File 1 Pape 91 .OOl Title 91.002 91.003 91.005 Stati 91.006 91.015 Auth pi nit I: \n I I -I By: . Id Paper OTitle View While these view variations are valuable, they leave one a bit \nconfused about when each of these views are actually presented to the user. To answer this concern, 3D-HIP \nuses a viewflow diagram to show how the system moves between the major views, and Selected Paper I !r \nId..--- IS: or(s): name __--~- address---------city-state-zip code phone_-_-faxNumber _______ I Beck \nCunningham I done I 2.1 uses an operational SpeciJication (Op Spec) for movement among the minor variations \non views. (Note: view flow is a derivative of [WassermanI s work in the 1970 s) 9-11 October 1991 Phoenix, \nArizona [NewPaperl I Selected Paper I Papers on File Paper Id: Title. .____------------------l 91 .OOl \n1 91.002 m . ,.i.. ---------__------_-------~ 91.003 I  91.005 Status: 91.006 91.015 91.016 addres91.019 \ncity-state--zip code phone----- faxNumber ------- nhlsil u [ New Author1 1 Delete Author] Save changes \nbefore 1 displaying to the next paper? By: *Paper Id [Changes)I) OTitle View 2.2 A view flow diagram \nshows all the major views in a example, we see a movement from view 1.Oto view system as well as the \nstimuli and conditions that 2.0 occurs when the Papers button on view 1.Ois cause movement from one view \nto the next. The selected. A more interesting path to consider occurs double circled view is shown to \nbe the start state. when the New Paper button is selected and the The view flow shown below, defines \nonly the previous paper has been edited but not saved. Note movement for the views 1.0,2.0, 2.1 and 2.2. \nAlong how conditions and logic is used to describe when the each arc, we see the stimulus that occurred \nand any path is traveled. conditions that must exist for a path to be taken. For /See Referee Partial \nview In addition to the views and the view flow, we need to describe the appropriate response for every \npossible stimulus for every possible state that might influence such behavior for every view to be displayed. \nThis is done in an operational specification, or op-spec. Usually managers involved with real life projects \nwill get rather nervous about someone specifying every possible response for every possible stimulus \nbecause of the number of possibilities. But we need not specify behavior that is simply standard on.4 \nviewwersl 5.0 9 (/New Paper/ or /Selection of Papers ; on File) and Selected paper has been modified \nbut not saved flow belzmior. Such standard behavior is specified once in a standard library of human \ninterface parts, and the Op Spec only specifies behavior that is non-standard. An example of standard \nbehavior might be dealing with a back-space stimulus on a text field. Non- standard behavior might be \nthe selecting of a save button. An op-spec is quite lengthy. As a result I have include enough of one \nfor the reader to get an idea of the kind of information that we are interested in mastering: Operational \nSpecifications Create a pop-up menu called Status with the (0~ Specs) states: intended , submitted , \nout for review , all evaluation received , View 2 - Edit a Paper accepted , and rejected ; Entry Operations: \nCreate and Author s sub-view by doing the Create New Paper, Home, Tutorials, Sessions following: and \nReviewers buttons; Create editable fields: Name, Address, City, Create a Papers on File sub-view by doing \nthe State, ZipCode, Phone, FaxNumber, and following: eMail; Create a Papers On File list; Create yes/no \nitems: Proof Received and Create a pair of radio buttons called By: , Invite Sent; where the two states \nCreate New Author, Delete Author, See are Paper Id and Title ; Reference Status, Save Changes and Initialize \nBy: s setting to Paper Id; Undo Changes buttons; Load all the PaperId s found in Set all human interface \nparts in the Selected collectionOfPapers into the Papers On File Paper sub-view to disabled . list; Set \nthe Selected Paper sub-view s viewing Set the papers On File sub-view to Active state to Deactive ; Create \na Selected Paper sub-view by doing the Display the view. following: Create editable fields: PaperId, \nTitle, and Session; Commands passed to the Human Interface Component (HIC) Stimulus any key active HIC \nrecognizes it Respons Active HIC executes it according to the human interface parts library. active HIC \ndoesn t recognize it. Beep. <mouse click> mouse click is recognized by the active HIC Active HIC executes \nit according to the human interface parts library. mouse click is not recognized by the active HIC AND \nan inactive HIC in the active sub-view does recognize it. Deactivate the active HIC; Activate the HIC \nthat does recognize it and let it handle the stimulus. mouse click is not recognized by The stimulus \nbecomes a sub-view the active HIC AND none of the recognized stimulus (See below) inactive HIC in the \nactive sub- view recognize it. View and Sub-View Recognized Stimulus: Stimulus &#38;&#38; Response <mouse \nclick in Selected Paper Selected Paper sub-view is not Set the active sub-panel to sub-view> active AND \n(the active sub-panel inactive and set Selected Paper is not the warning message sub-view to active. \nshown in View 2.2, nor the reviewer status window shown Assure that the cursor is in the in View 2.1 \nnot shown). same place that is was when it was last deactivated. Selected Paper sub-view is not F&#38;p. \nactive AND ( either the active sub-panel is the warning message shown in View 2.2, OR the reviewer status \nwindow shown in View 2.1 shown). Selected Paper sub-view is active Do nothing; AND none of the HIC s \nrecognize the stimulus. New Paper button pushed. Selected Paper sub-view is active Set the Selected Paper \nsub-view AND at least one HIC s has been to inactive; modified since (the last Save Changes button was \npushed OR Display the warning message the sub-view was activated). displayed on View 2.2; IF Save changes \nTHEN Execute the appropriate mini-spec: register letter of intent, register paper, record a paper accepted \nor rejected, Clear all the HIC s; ELSE Don t Save SO Clear all the HIC s Remove the warning message; \nSet the Selected Paper sub-view to active: Selected Paper sub-view is active Clear all the HIC s; AND \nnone of the HIC s have been modified since (the last Save Changes button was pushed OR the sub-view was \nactivated). Selected Paper sub-view is not Deactivate the active sub-view; active AND (the active sub-panel \nis not the warning message Set the Selected Paper sub-view shown in View 2.2, nor the to active; reviewer \nstatus window shown in View 2.1 not shown). [40 I 9-11 October 1991 Phoenix, Arizona Selected Paper \nsub-view is not Beep; active AND ( either the active sub-panel is the warning message shown in View 2.2, \nOR the reviewer status window shown in View 2.1 shown). NOTE: uuouse click in Papers On File Stimuli \nnot yet addressed, sub-view>, includes: the following buttons pushed: Home, Tutorials, Sessions, Reviewers, \nSave Changes (in Selected Paper sub-view), Undo Ch anges, New Author, Delete Author, and See Referee \nStatus As one can see, I have tried to leave little unsaid about the behavior of the human interface, \nwhere this behavior extends beyond the standard behavior of the basic human interface components. The \nexercise of developing an Op-Spec causes one to think about situations that are not always obvious. For \nexample, I doubt that I would have anticipated all four responses to the New Paper button push, if I \nwere in the middle of coding. The reader might learn a great deal about the value of op-specs by finishing \nthe op- spec for the stimuli that have not yet been addressed. At this point in our analysis of this \nproblem we understand a great deal about what is to be built. We know the information used in the problem \ndomain through Information Modeling. We understand when and how aspects of that information becomes valid \nand invalid by using Finite State Machines. We have an understanding of the tasks performed by a user \nand how the system will support the processing by using Event-Partitioned Data Flow Diagrams. And we \nhave a solid understanding of the interface to be presented to the user. We have seen how each of these \nmodels build upon the information developed in the earlier models. We are ready to proceed to design \nand find objects. Developing these models seems like a great deal of work. Frankly, it is, but it is \nnot extra work! There is no decision made in any of these models that would not have to be made in the \nmiddle of object- oriented design or implementation. But at that point in time, the designer/programmer \nis dealing with a great many issues related to how objects interact, where and what they inherit, what \nmethods are to be provided, bow objects are created, whether object should be used, not to mention algorithms, \ndata structures and good comments. His/her attention is divided and the potential for introducing defects, \nor simply forgetting about some aspect of the system is increased. Furthermore, while designing/coding, \nthe programmer is dealing with details and can not take the time to develop a broad perspective to support \nconsistency across an application. If this is not addressed before design, we see the results in the \nform of significant rework costs.  2.2 Finding Objects There are two aspects to constructing an effective \nobject-oriented system: knowing your starting place and having a vague idea about your ending place. \nI satisfy the starting place criteria with an understanding of the system-to-be-built as discussed above. \nI address the ending place criteria with two strategies. First, objects play different roles within a \nsystem and to discover objects with different roles, we need to look at the analysis documents from different \npoints of view. Secondly, we use an understanding of a small number of patterns of objects to help us \nadd the operational issues usually assigned to design and not addressed in a technology free analysis. \n 2.2.1 Using Object Structures 81 Patterns This pattern idea is not new, in a sense, the notion of data \nstructures in the 60 s (i.e., data structures can be studied separately from the program that might use \nthem), is the same. A pattern is a small number of objects that exists repeatedly, though requiring tailoring, \nin many programs. I refer to these patterns as object structures. The most widely known object structures \npattern is the Model-View-Controller concept used widely within Smalltalk, though several others have \nbeen found. Objects structures are used in the same way that data structures are used during the design \nstage-we systematically reduce a large problem down to a number of smaller problems that we recognize, \nsimply because we have developed or studied something similar in the past. This concept follows [AlexanderI \ns work with Pattern Languages for the creation of buildings and communities. 2.2.2 Finding Objects Through \nThe Roles Objects Play in a System Objects structures provide a framework in which to construct the specific \nobjects need for the system to The roles that objects play are: be built, but those specific objects \nneed to be identified and understood. As [Bulman] points out, these analysis documents provide a rich \nsource for the discovery of these objects. However, it is not a rote activity, but requires careful thinking \nduring the translation into design. To identify objects from the analysis documents, I have to be mindful \nthat objects play a handful of different roles in an object-oriented system and as a result, I need to \nfmd them in different places in the analysis. [Note: Meilir Page- Jones and Steve Weiss have done similar \nwork in this area; we have had conversations, I know of no reference] System Donuin Objects Application \nDomain Objects Foundation Objects These objects are responsible for interfacing the system-to-be-built \nto the programming environment. They are not strongly discussed in the analysis, but hints of their \nbehavior can be found in a discussion of the control of the human interface. A stronger sense of the \nbehavior of system domain objects, comes from studying object- oriented programs and observing patterns \nin program control across many programs. This pattern is then applied as needed. These objects contain \nthe knowledge of how the system is to respond to particular stimulus. They coordinate systems of objects \nto accomplish a desired objective. The details of these objects are found heavily documented in the human \ninterface specification and in the control structure discussed within the mini-specifications relating \nto particular essential activities. These objects can be thought of as worker objects. They hide information \nabout data structures, external device interface behavior. These are easy to find from the Data flow \ndiagram and the data dictionary. Any data store or and external device is a candidate to become an object \nand may contain objects within them that are easily discovered by analysis of the data dictionary syntax. \nInformational Objects Human-Interface Domain Objects  These objects contain small pieces of information \nand are usually passed from one object to a second as a parameter. They are also easily found from analysis \nof the data dictionary and viewing the dala flow diagram. Any data flowing from or to and external entity \nmay be a migration object. Likewise, information held in a data store as one of a number of similar data \nitems are likely to be migratory objects (especially if this data store is to be designed as some sort \nof collection). These objects are responsible for the interaction with a human. They are a special sub-class \nof foundation objects (that would nomlally take the responsibility of interfacing with an outside device) \nThey are found not by looking at the data flow diagram as with most foundation objects, but rather by \nlooking at the 3D-HIP documents.  3.0 Conclusion My goal for this paper was to completely solve the \nOOPSLA Conference Support problem. But, as the reader has discovered good analysis takes work, time and \npaper. I combined an explanation of my tbhiking processes and modeling techniques along with the solution \nand this added to the length of this paper. And I have not presented a clear line of reasoning on how \nto discover objects. Rather than grab a few objects and leave the rest as an exercise for the reader, \nI have decided that this topic will be covered in Part II of this paper. Contact the author at P. 0. \nBox 2205, Beaverton, OR 97075, to receive the second part when it is completed. References Alexander, \nC., A Pattern Language. Oxford University Press. 1977. Brooks, Fred, Mythical-Man Month. Addison-Wesley. \n1977. DeMarco, Tom, Structured Analysis and System Specification. Yourdon Press, 1978. Bulman, D., Model \nBused Object-Oriented Design, Computer Languages, August, 1989. Kerth, Norman L., How to deliver 20,000 \nLine of Code with only Four Defects for Under $2.00 Per Line of Code. Proceedings of the Pacific Northwest \nSoftware Quality Conference, 1990. pp. 29-49. Kerth, Norman L., MOOD: u Methodology for Structured Object-Oriented \nDesign. Tutorial presented at OOPSLA 88, San Diego 1988. Kerth, Norman L., The Use of Multiple Specification \nMethodologies OIZa Single System. Fourth International Workshop on Software Specification and Design, \nApril 3-4, 1987, Monterey, California, sponsored by the IEEE Computer Society. McMenamin, S. &#38; Palmer \nJ., Essential System Analysis. Yourdon Press, 1984. Shlaer, Sally, and Stephen J. Mellor, Object-Oriented \nSystems Analysis-Modeling the World in Data. Yourdon Press, 1988. Contact information: Norman L. Kerth \nElite Systems P.O. Box 2205 Beaverton, OR 970752205 (503) 297-8677  \n\t\t\t", "proc_id": "143773", "abstract": "", "authors": [{"name": "Norman L. Kerth", "author_profile_id": "81100339993", "affiliation": "", "person_id": "P210257", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143773.143783", "year": "1991", "article_id": "143783", "conference": "OOPSLA", "title": "A structured approach to object-oriented design", "url": "http://dl.acm.org/citation.cfm?id=143783"}