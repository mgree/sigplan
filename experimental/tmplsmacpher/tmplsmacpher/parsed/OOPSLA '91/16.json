{"article_publication_date": "11-01-1991", "fulltext": "\n Communication as Fair Distribution of Knowledge Jean-Marc Andreoli and Remo Pareschi ECRC, Avabellastrasse \n1 7 D-8000 Munich 81, Germany {jeanmarc,remo}@ecrc.de Abstract ?Ve introduce an abstract form of interobject \ncommunication for object-oriented concurrent pro-gramming based on the proof theory of Linear Logic, \na logic introduced to provide a theoret-ical basis for the study of concurrency. Such a form of communication, \nwhich we call forum-based communication, can be seen as a refinement of blackboard-based communication \nin terms of a more local notion of resource consumption. Forum-based communication is introduced as part \nof a new computational model for the object-oriented con- current programming language LO, presented \nat last year OOPSLA/ECOOP (1990), which exploits the proof-theory of Linear Logic also to achieve a powerful \nform of knowledge-sharing. Introduction The programming language LO (for Linear Ob-jects) [G, 4, 31 \n1 ras been designed to supply a 1ogica.l framework for object-oriented concurrent program-ming, with \nthe purpose of rigorously accounting for its various aspects (concurrent communication, knowledge sharing, \nobject creation, object termi-nation etc.) in terms of the proof-theoretic behav- Permission to copy \nwithout fee all or part of this material is granted provided that the copies are not made or distributed \nfor direct commercial advantage, the ACM copyright notice and the title of the publication and its date \nappear, and notice is given that copying is by permission of the Association for Computing Machinery. \nTo copy otherwise, or to republish, requires a fee and/or specific permission. @ 1991 ACM 89791-446.5/91/0010/0212...$1.50 \nior of logical connectives, thus making very sim-ple and completely abstract the operational seman-tics \nof the system; its formal background is given by Linear Logic [ll], a logic introduced by Jean-Yves Girard \nto provide a theoretical basis for the study of concurrency. LO s view of active, concur-rent objects \nas structured entities capable of shar- ing knowledge has on the other hand been illus-trated in [4] \nin terms of a sociological metaphor: objects can be thought of as complex organizations, which inherit \nthe problem solving capabilities of their suborganizations. Procedural knowledge is correspondingly encoded \nby specifying state tran- sitions (methods) of the form Cl 73.. . B C, o- Body. where each Ci is an atomic \nlogical formula. The logical (proof-theoretic) interpretation of methods hinges on the identification \nof objects, and of sys- tems of objects, with proof trees and goes as fol-lows: if, in constructing a \nproof tree in the Lin-ear Logic calculus of sequents, we have reached an open node containing, among \nothers, components Cl . . . Cn, then expand this node into another node obtained by replacing Cr . . \n. C, with the contents specified in Body, and leaving the remain-ing components untouched; this may lead \nto the creation of other nodes, or to a stop in the evo-lution of that branch of the proof, depending \non the logical nature of the information provided by Dody. The sociological interpretation goes instead \nas follows: if an organization contains in its current state a suborganization whose member elements \nOOPSLA 91, pp. 212-229 are Cl . . . C,, then let the given suborganization perform the task specified \nin Body, thus changing its own state and, consequently, that of the whole organization. According to \nboth the logical and the sociological interpretation, objects evolve by explicitly performing actions: \nelements in the cur-rent state of affair may irreversibly disappear, to be replaced by new ones. On the \nsociological side this, and nothing else, could have been expected; but, on the logical side, such a \ncapability to deduc-tively deal with change in open worlds of indepen- dently coexisting entities specifically \nexploits the fact that Linear Logic accounts not just for truth, but also for the complementary notion \nof action, which had been instead neglected in more tradi-tional logical developments. Thus, logic and \nsoci-ology agree to each other, the first one giving us a rigorously defined abstract operational semantics \nfor the language, and the other an anthropomor-phic view of it which fits well within the tradition of \nobject-oriented programming. LO s organizational approach to knowledge shar-ing can be viewed as a form \nof intraol?ject commu-nication, with objects acting as structured entities: for the capability of a subob \nject to handle a certain task is transmitted to the entire object in terms of the operational semantics \nof method triggering. We have argued that this form of inheritance does not suffer from the computational \ndrawbacks of dy- namic approaches to knowledge sharing like dele-gation [HI, since it avoids the proliferation \nof del- ega.te objects, which act as bureaucrats whose only purpose is delivering requests for ta,sks \nsome-one else is going to do; on the other hand, none of the malleability of delegation is lost, as LO \ns ob-jects have a completely flexible structure, where new types of components can be added at run time, \nwhile other ones may altogether disa.ppear; nor does this entail populating our universe with anything \nmore but simple individuals and their aggregations -abstract in its operational seman-tics, LO is quite \nconcrete in its ontology: no notion of class is introduced, and the object-subobject re-lationship suffices \nto achieve inheritance (this can be contrasted with the class-superclass relationship characterizing \nclass-based 1anguages)l. However, another equally crucial and pri-mary form of communication characterizes \nobject-oriented concurrent programming: inter-object com-munica,tion, where separate entities exchange \ninfor-mation, whether they be structured or not. This is the basic ingredient for object-based concurrency, \nparticularly in languages of the Actor family [a], of which LO is an offspring on the side of its logic \nprogramming branch [27]; communication of such kind reduces procedure calls to exchanges of messages \nbetween objects, thus leading to a com-pletely decentralized and truly concurrent model of computation. \nThe computational model for LO present,ed in [6, 4, 31 h as dealt with interobject communication simply \nby importing the technique of shared logical variables directly from concur-rent logic programming languages \nbased on Horn logic, like Concurrent Prolog [26], Parlog [la] and GIIC [29]. However, such a solution \nis to be consid- ered as temporary and not completely satisfactory mainly for the following (strictly \nrelated) reasons: (i) It is committed to a specific implementation choice (the use of unification of \nlogical vari-ables in order to achieve communication) and thus defies LO s effort towards a completely \nabstract operational semantics, which can be supported by different kinds of implementa-tions and architectures. \n (ii) It burdens the programmer with the task of dealing her/himself with problems related to stream-based \ncommunication, like stream-merging in many-to-one communication.  (iii) Although intraobject and interobject \ncommu-nication appear as conceptually dual, they are not so at the operational level: the intraobject \ncase is accounted for in terms of proof con-struction, while unification handles the inter-object case. \nThe situation would become quite Obviously, we view classes and aggregations of individ- uals as quite \ndifferent entities: the former are abstractions on individuals, the other are simply obtained by putting \ntogether simpler individuals to obtain more complex (com-posite) ones. more pleasant by making proof \nconstruction capable of handling both cases; it would also be quite more in the spirit of Linear Logic, \nwhich is based on a system of dualities of log- ical operators. In this paper, we provide a computational \nmodel for LO which refines the one described in the pre-vious papers precisely by making proof construc-tion \nresponsible both for intraobject and interob-ject communication. In such a new model, proof construction \nis going to be seen as a bidirectional process, where, by starting from a partially de-fined initial \nnode, we both go ahead in building the branches of the proof-tree and in further spec-ifying its initial \nnode. Thus, perhaps not surpris-ingly, dual communication concepts can both be accounted for via a fully \nsymmetric approach to proof construction. This is obtained by permitting partially specified nodes to \nbe instantiated upon the triggering of methods, which are now written as Cl 2-3 . . . F?c; B c;+~ B . \n..z C,o-Body. Here, the components A Ci+r, . . . , C, (if any) are added to the unspecified part of \nthe node once the method is triggered, while the components Cl, . . . , C; must be found already there. \nBut the unspecified part of any node gets percolated from the unspecified part of the initial node, and \nis therefore shared by all objects; consequently, when-ever the triggering of a method by an object makes \nnew components to be added to the unspecified part of the node, then these components are prop-agated \nback to the root of the proof tree and can in turn be used by other objects. To stick to the organizational \nmetaphor, we can think of the un-specified part of the initial node as a kind of dis-cussion forum: this \nis a suborganization shared by all organizations, through which they excha.nge in-formation between each \nother. From the point of view of proof construction, whenever information is exchanged, we make progress \nin building the proof tree in the direction of the root; on the other hand, making progress towards the \nleaves along a certain branch of the proof tree has to do with information which is strictly local to \nthe object identified with the given branch, thus accounting for intraobject communication. Now, communication \nin a forum is characterized by two basic kinds of speech acts: a the act of the speaker s addressing \none specific hearer, in front of the remaining part of the audience (specific communication); . the act \nof the speaker s addressing the whole audience (generic communication). In both cases, communication \nis achieved through a shared communication medium, even when it is specific; moreover, generic communication \nis al-ways fair, in the sense that no receiver can limit only to her/himself the use of a message which \nis meant for the whole community. As we shall see, our approach to forum-based interobject com-munication \nwill support both specific and generic communication, and will maintain the fairness of generic communication. \nBut we shall also ensure the safeness and the privacy of specific communi-cation, by providing a clean \nway of generating pri-vate names to be used as mail addresses labeling messages which have to be specifically \naddressed, so that the capability to read one of such mes-sages requires acquaintance of the corresponding \nmail address; alternatively, from the point of view of the speaker/hearer relationship, we can think \nof such private names as interpretation keys , whose acquaintance unlocks the meanings of the messages \nwith which they are associated. Fur-thermore, we shall characterize the relationship be-tween such a \nnovel form of communication and the well-established blackboard-based communication (see for instance \n[lo]): as it will be shown, forum-based communication can both be viewed as a logical version of blackboard-based \ncommunication and also as an operational refinement of it in the sense of being endowed with a more local \nnotion of resource consumption (corresponding to the prop-erty of fairness of generic communication) \nwhich makes it fully adequate for distributed computing. We shall also compare our approach to communi-cation \nwith the one adopted for Concurrent Con-straint Logic Programming (CCLP) languages de-scribed in [24, \n151; indeed, both approaches imple-ment a logic-based form of fair generic communi-cation, and appear \nas complementing each other in the following sense: in the case of forums the items of information can \nbe removed from the visual field of agents (i.e., once accessed they are actu-ally consumed, albeit just \nwithin the local scope of the accessing agent); in the case of CCLP lan-guages, items of information \nare instead perma-nently stored for all agents. The remaining part of this paper is organized as follows: \nSection 2 will give a description of the new computational model of LO leading to forum-based communication, \nand will formally characterize it both in terms of an operational (proof-theoretic) semantics and a model-theoretic \nsemantics; Sec-tion 3 will describe two applications of this new model of computation, the first one \nof which (a graphical application) will be characterized by spe-cific communication, while the other \n(a concurrent chart parser) will be characterized by generic com-munication and will provide us with \nan instance of a highly general methodology for distributed prob-lem solving; Section 4 will compare \nour approach with related work, and Section 5 will give a brief overview of ongoing directions of research. \n 2 Description of the Language LO 2.1 Formulae, Sequents, Proofs The syntax of the language LO uses \nthree connec-tives of Linear Logic: par (written 8), with (written &#38;), and top (written T). We also \nmake use of the Linear implication (written c-) which can be defined in terms of the other connectives \nof Linear Logic. Two classes of Linear formulae, namely goals G and methods M, are built re-cursively \nfrom the class A of atomic formulae (i.e. simple terms possibly containing variables), as fol- lows: \n G=AIGzGITIG&#38;G M=Ao-GIAWU A program is a set of methods and a context is a multiset of grovnd goals \n(i.e. containing no free variables). An LO sequent is a pair written P I-C where P is a program and C \nis a context. 2.1.1 Definition of the Inference Figures for LO A proof is a tree structure whose nodes \nare la-beled with sequents. By convention, a proof tree is graphically represented with its root at the \nbottom and growing upward. Its branches are obtained as instances of the inference figures of the following \nsequent system, which defines LO s operational se-mantics. . Decomposition   P k C,G,G PI PI P P I-C,GI \nBGZ I- C,T P I- C,G1 P t- C,G2 14 P I- C,Gl&#38;G2 0 Propagation P k C,G bl P I- C,Al,...,A, In these \nfigures, P and C denote, respectively, a program and a context. G,Gr, G2 denote ground goals and the \nexpression C,G denotes the context obtained as the multiset union of C and the single-ton G. In the propagation \ninference figure [o-l, we take [P] to be the set of all the ground instances of the methods in P. The \nletters Al,. . . , A, denote ground atoms. Thus, the context in the lower se-quent contains (in the sense \nof multiset inclusion) a submultiset of atoms which matches exactly the head of a ground instance of \na method from the program. The upper sequent is obtained by re-placing in the lower sequent this submultiset \nwith the body of the selected instance of method (i.e. a ground goal). Notice that, by definition, the \nelements of a mul- tiset are not ordered. Therefore, the order of the atoms in the head of a method is \nnot relevant. 2.1.2 Operational Interpretation of the In- ference Figures Read bottom-up, a proof gives \na static representa- tion (a snapshot ) of the overall dynamic evolu-tion of a system of objects viewed \nas active pro-cesses (agents). Each sequent at the node of a proof-tree encodes the state of an object \nat a given time. The branches of the proof-tree represent ob-ject state transitions. Thus, the sequent \nsystem of LO can be inter-preted as a general specification of a set of valid object state transitions: \nthe lower sequent in each inference figure is the input state of a valid tran-sition, whose output states \n(if any) are the upper sequents. . Inference figure [T], which has no upper se-quents, encodes a transition \nwithout output states. In other words, it allows termination of objects. . Inference figure [a] has two \nupper sequents which share a part of their context. Thus, the two output states of this transition can \nbe viewed as clones, that is, as independent enti-ties with a similar structure. In other words, the \nconnective &#38; allows creation of objects by cloning. 0 Inference figure [3] aggregates, within the \nsame object, two different components. It al-lows construction of object states with mul-tiple elements, \nwhich lies at the basis of the object/subobject relationship in LO. 0 Inference figure [o-l allows the \ntransforma.tion of an aggregation of components (a subobject) within an object. Notice that, for each \ntransition, the pr0gra.m (left-hand side of the sequents) never changes while the context (right-hand \nside) is always modified (at least one formula is replaced by another). In other words, the program contains \nthe unrestricted re-sources of the object, that is, those which can be reused as many times as needed, \nwhile any element from the context is a restricted resource, which dis-appears once used. LO proofs are \ncharacterized by two levels of con- currency: AND-concurrency, involving processes evolving on different \nbranches of the proof; and OF&#38;concurrency, involving different subprocesses aggregated within a single \nprocess, evolving on a single branch. These two forms of concurrency correspond to the two forms of communication \nwhich, in the introduction, we have called, re-spectively, interobject and intraob ject communica-tion. \nThe terminology for AND/OR-concurrency has been chosen to make a direct connection with Linear Logic, \nwhere the connective &#38; responsi-ble for AND-concurrency is the (additive) conjunc-tion whereas the \nconnective 6 responsible for OR-concurrency is the (multiplicative) disjunction. 2.2 Computational Model \nIn this paper, we keep the basic computational mechanism already proposed in previous papers, which can \nbe summarized as follows: I Computation = Proof Search I The important novelty here is in the specification \nof the class of proofs to be searched, called the target proofs, associated with a given query. 2.2.1 \nContextual Proof Search A query is a pair consisting of a program P and a ground goal G. Target proofs \nare then defined as follows: Definition 1 A target proof is an LO-proof such that its root is a sequent \nof the form P I-C,G, where C is a context (also called an answer context for the query). In other words, \nproofs are searched in such a way that the context of their root node may prop-erly contain the query \ngoal. This new model of computation can be used within the two different paradigms of transformational \nand reactive pro- gramming [ 131. . In the transformational paradigm, the sys-tems reads an input, processes \nit and produces an output. The input is here the initial query and the output is any possible answer \ncontext C. The elements of C can be viewed as con-straints and thus, a query can be interpreted as find \na set of constraints from which a given formula is derivable . . In the reactive paradigm, several agents \ninteract together by exchanging messages. There is no notion of input and output in this case; the initial \nquery is used only for the pur-pose of bringing into life certain agents. The answer context C acts as \na medium of commu-nication between agents. C is initially unspec-ified but each agent can read and write \nin it during a state transition; each time an agent writes in C, the written formula is automati- cally \npropagated to all the other agents. This kind of communication we call forum-based communication, by \nviewing a sender agent as a speaker talking in front of an audience gath-ered in a forum. In this paper, \nwe focus on the second paradigm, where the answer context is used as a communica- tion medium.  2.2.2 \nExample Consider the following propositional LO program P: pzao-r. qZa Z?bhT.  r Sbc--T. The following \nproof II (where the program P is omitted from the left hand side of the sequents) is a possible target \nproof for the query (P ; p&#38; q). r-i-i - b-1 FT D-1-b-l t-b7r b-1 ,+:, ,  k b,p 7 3 II = [&#38;] \ntb,a, p&#38;q  Thus, the multiset b, a is an answer context for the query above. Let us go into the \ndetails of a possi- ble construction of II. Initially, the search tree is reduced to a single node III-J \n= l-c, p&#38;q where C is a still unspecified context. 1. Inference figure [&#38;I applies to the single \nnode of II0 and expands it to 2. At this point, no inference figure applies with-out making some assumption \non the content of  C. For example, if we assume that C contains a (i.e. C = C ,a), then the first method \nof P applies to the leftmost leaf of II1 (inference figure [o-l), and yields I- C ,r b-1 t- C , a7 q \nk C ,a,P II2 = [&#38;I t-C ,a, P&#38;q 3. To continue, we need further assumptions on C. For example, \nif we assume that C contains b (i.e. C = C , b), then the second method of P applies to the rightmost \nleaf of II2 (inference figures [o-l, and then [T]), and yields t- C , b> r b-l I- P, b, a, p II3 = 14 \nI- P, b, a, p &#38; q 4. Now, the third method of P applies to the left- 5. Finally, II is identified \nas the instance of II4 in which C is the empty multiset.  most leaf of II3, and yields r-d - b-1  \nt- c , T I-P b r PI -t-C T II4 b-1 = [&#38;I t- C , b, 6,; I- C ,b,a, b-3 p&#38;q !- P,b,(I,q Of course \nthis construction is far from being the only possible one. At each step, we have made sev-eral decisions, \nsome of which were arbitrary. Hence the need to define a control strategy. 2.3 Proof Search Control \n2.3.1 The tell marker A large amount of non-determinism in proof search is eliminated by the following \nresult, which identi-fies a complete subset of LO-proofs, so that the search procedure can be restricted \nto proofs in this subset. Theorem 1 A sequent P I- C is derivable in LO if and only if it has a ffocusing \nproof, i.e. one in which the bottom context in each occurrence of the propagation inference fisure [o-l \ncontains only atoms. This result is a special case of a more general theo-rem for full Linear Logic (called \nthe focusing the-orem), stated in [3], and which is in fact stronger: if any of the decomposition inference \nfigures ([T] , [&#38;I or [z]) applies at one node of the proof, then it can deterministically be applied \nimmediately. There-fore, as long as the current context contains a non- atomic goal, the proof search \nprocedure can be made completely deterministic. However, once the context contains only atoms, and it \nis therefore time for the propagation infer-ence figure [o-l to be applied, we are faced with a non-deterministic \nchoice which we would like to control. Here the crucial problem is that of select- ing an appropriate \nmethod from the program. By adopting a blind search strategy, any method could be triggered: for, as \nlong as no restriction is put on the context, it would always be possible to assume that the method s \nhead is entirely contained in the yet unspecified part of the context. We introduce therefore a pragmatic \ntool which gives the user con-trol on such assumptions. Let A be a special sym-bol, called the tell marker, \nwhich can be used to prefix any atom in the head of a method. Thus, the first method of program P of \nSection 2.2.2 could be marked as follows: p;SAao-r This means that, to apply this method, the atom p \n(unmarked) must be found in the already speci- fied part of the context, while the atom a (marked) must \nbe assumed in the still unspecified part of the context. Of course, when triggering the method, both \nthe marked and the unmarked atoms of the head (here p, a) are replaced by the body of the method (here, \nr alone). Thus, the head of each method is split into two groups of atoms: those (unmarked) which are \nasked from the context (i.e. from its already specified part) and those (marked) which are told to the \ncontext (i.e. to its still un-specified part). Now consider the program P of Section 2.2.2 with the following \nmarking: pF? *ao-r. q??a3 b+T.  r Fbo-T. It is easy to check that the proof construction de-scribed \nin Section 2.2.2 is the only possible one with respect to the marking above. The interactions between \nthe two branches cre-ated at step 1 in the search illustrates the com-munication mechanism obtained by \nthis use of the markings in the head of the methods: first the left branch sends a message a to the right \nbranch (step 2); then the right branch receives this message a, sends a message b to the left branch \nand terminates (step 3). Finally, the left branch receives the mes-sage b and terminates (step 4). In \nboth send and receive operations, the message is locally consumed by the concerned agent and disappears \nfrom its scope, but not from the scope of the other agent(s). There lies the fundamental difference between \nour forum-based communication and blackboard-based systems (like Linda [lo], for instance), where, once \nan agent consumes a resource, it takes it away glob-ally also for all the other agents. Similarly, the \nfo-rum based communication mechanism differs from the one available in the CCLP languages described in \n[24, 151, where told constraints are never re-moved from the local visual field of an agent. Clearly, \ncommunication of this kind directly de-pends on the possibility of suspending and resum-ing computation. \nIndeed, notice that after step 1, no method applies to the right branch. However, no failure occurs because \nof this. Instead computa-tion on the right branch gets suspended; resuming it must wait for the transition \non the left branch (step 2) t o p ro d uce the atom (u) needed to trigger a method on the right branch. \nThus, in LO s proof theory, the closed-world notion of failure character-izing traditional logic programming \nlanguages is re- placed by the open-world one of suspension. Dead-locks may follow from the situation \nof suspension of all proof processes. 2.3.2 Information Hiding via Variable In-stantiation It has been \nshown above that the use of the tell marker * provides a form of control on the choice of methods. But, \nonce a method has been se-lected, another kind of choice is required, in de-termining an instantiation \nfor the variables of the selected method (this problem did not appea,r in previous examples since the \nmethods contained no variables). Unification is the traditional solution for this problem; however, we \nopt here for another mechanism, which suits better the proposed com-putational model. It ca.n be summarized \nas follows: . Instantiation of variables occurring in the un-marked atoms of the head is effected by \nsim-ple pattern matching with the corresponding atoms in the context. . All the other variables of the \nmethod are in-stantiated with distinct new constants, that is, constants which do not appear in the por-tion \nof the proof built so far. Assume for instance that we have a branch of the proof where the current context \nis given by where C is the still unspecified part of the context, and we want to apply the following \nmethod2. P(X) s 4 23 4X, Y) o-t(y) This is possible since the unmarked atoms of the head, namely p(X), \n(I, match a submultiset of the 2We follow the convention of starting variable identifiers with an uppercase \nletter. already known part of the context, namely p(a), q. This matching instantiates the variable X \nto a. The (only) other variable, Y, is instantiated with some arbitrary new constant, say c. Now, the \nmethod is fully instantiated and can be triggered by assuming that the atom s(a,c) is in C (since this \natom is prefixed with the tell marker). Thus C = s(u, c),C , and a new node can be added to the proof: \nt-C , r, t(c) b-1 I- C , 4% C),P(4, Q7r This mechanism for variable instantiation provides a clean way \nto generate new unique identifiers. Such identifiers can then be used as mail addresses for messages \nto be sent in the specific mode. The fact that each mail address thus created is bound to be different \nfrom any other previously or subse-quently created ensures the safeness and privacy of specific communication; \ninformation items labeled with a given mail address will be hidden from those potential receivers unacquainted \nwith it3.   2.4 Phase Semantics It has been shown in [3] that LO s sequent system is sound and complete \nwrt Linear Logic. More pre-cisely, Theorem 2 A sequent P k C is derivable in LO if and only if the sequent \nI- ( ! P)- -, C is derivable in Linear Logic, where p is the conjunction (&#38;) of the methods of P \n(universally quantified) and ! is the Linear modality of-course . Notice the use of the modality ! to \nprefix the pro-gram P in its Linear Logic version; this explicitly marks the elements of the program \n(the methods) as unrestricted resources, which can be used as 31dentifiers of this kind are related to \nthe eigenvariables used in proof theory to introduce fresh constants in the proof; eigenvariables have \nbeen recently proposed in [21] as a way of adding information hiding to logic programming. The difference \nis that eigenvariables have just forward and, therefore, local scope on the branch of the proof where \nthey are introduced; by contrast our newly created identifiers are propagated back to the root of the \nproof tree, so they have global scope. many times as needed, whereas the elements of the context C (the \ngoals) are instea,d bounded resources which can be used just once. Theorem 2 above shows in proof-theoretic \nterms that LO is a fragment of Linear Logic. But there is also a model-theoretic characterization of \nthis fact, based on the Phase Semantics proposed in [ll] as an interpreta.tion of Linear Logic; such \na charac- terization applies to the computational model pre-sented here in a particularly perspicuous \nmanner. Take a phase model M to be a given set of phases ; the denotation of a formula F in M, written \n[F]M, is a fact of M, i.e. a subset of the set of phases verifying certain properties4. Intuitively, \nthe phases can be viewed as actions, and the denotation of F is the set of actions which must alternatively \nbe performed so as to make F true. This provides a constructive, dynamic notion of truth, which can be \ncontrasted with the non-constructive, static truth of Boolean semantics. Denotations of formulae in phase \nmodels satisfy two nice properties, shared with Boolean seman-tics: 0 Compositionality: The denotation \nof a complex (non-atomic) for-mula depends solely on the denotations of its components; thus, e.g. [F \n&#38; Gl = [Fl n [G] [FsGl = ([Fllo [Cl*)' where o and 1 are operators of the phase mode15. . Soundness \nand completeness of the proof sys-tem: A formula is provable if and only if it holds in all models; i.e. \nI-F if and only if for all M, M I= F t-is the provability relation of Linear Logic and M I= F means that \nthe empty phase be-longs to the denotation of F in M. *See [ll] for the exact definitions. 5See [ll] \nfor the exact definitions.  However, the Phase Semantics has another pleas-ant feature which does not \nhold in the Boolean case: there is a canonical phase model6 M, in which the following property holds. \nk F if and only if M, I= F Such a canonical model can be directly connected to the computational model \nproposed here, since computing a query Q can be viewed as building its denotation [Q]mo in the canonical \nmodel, by enu-merating the elements (phases) of the set [Q]M~. More precisely, in the canonical model \nM,, the phases are the multisets I? of formulae of Linear Logic, and the denotation of a formula F is \ngiven by ef {I / H ,F} IF1 MO Now, notice that given an LO query (P; G), the computational model proposed \nin the previous sec-tion precisely attempts to enumerate the elements of [( !F) -O G]mM,. Indeed, for \nany answer con-text C to the query, the following three equivalent properties hold: (i) P l- C, G is \nderivable in LO (by Definition 1 of an answer context). (ii) l-( ! P)*, C, G is derivable in Linear \nLogic (from (i), by application of Theorem 2).  (iii,) t C, ( ! F) 4 G and hence C E I( ! P) --o Gl \nM,, (from (ii) by definition of the Linear implica- tion -o and of the canonical denotation). As a matter \nof fact, the proof search procedure described in the previous section can only gener-ate atomic phases \n(i.e. containing only atoms). If the control strategy induced by the use of the tell marker * were ignored, \ni.e. if all the possible mark-ings and all the possible variable instantiations were allowed for all \nthe program methods, then all the atomic phases of [( ! p) --o G] ,u, would be gen- erated by exploring \nall the alternatives at each non-deterministic choice in the procedure (with a back- track mechanism, \nfor instance). This complements 6See [ll] for the exact definitions. the soundness result given by (i) \n-(ii;) above with a completeness result of our operational search pro-cedure with respect to the Phase \nSemantics. From a practical point of view, completeness and compu-tational tractability are however incompatible: \nby imposing one specific marking upon the methods, the programmer enforces the order in which the atomic \nphases of [( !p) -o G]M~ are enumerated, but, at the same time, enables possible situations of deadlock \nwhich preclude some atomic phases ever to be constructed.  3 Applications We illustrate the expressiveness \nof the computa-tional model described above by two simple appli-cations. The first one (Section 3.1) \ngives an exam-ple of specific communication, and the second one (Section 3.2) an example of generic communication. \nFrom now on we replace the logical symbols 8, &#38;, T and o-with, respectively, keyboard typable sym-bols \nQ, &#38;, #t and O-, which are used in the actual implementation of LO. 3.1 Specific Communication: \nComputer Graphics We describe here a simple graphical applica-tion for manipulating geometrical drawings \non a 2-Dimensional display. This example is a modifi-cation of the one given in [4], where it was used \nto illustrate LO s approach to knowledge sharing in terms of intraob ject communication, while streams \nwere used for interobject communication; here, we replace streams with the use of the forum as a com- \nmunication medium, and we stress aspects of inter- object communication. The evolution of the sys-tem \nof agents is modeled by the construction of a proof tree as in Section 2.2.2. There are three kinds of \ncommunicating agents: the user (of the drawings), the drawings and the display device. Hence, the query \nwhich brings into life such agents is given by the goal user &#38; drawings 8 display. together with \na program containing methods exe-cutable by these three agents. The unspecified con-text which is incrementally \nspecified by searching a target proof for the query acts as the forum for communication between agents. \nCommunication here is specific, in that it will involve one agent specifically addressing other agents \nby posting to their mail addresses. We focus here on the behavior of the drawing agents. At the moment \nof its creation, a drawing is represented as a context containing the following components: drawing , \nnoshape , id(S) , center(O) S is an identifier used as a mail address for the drawing for the purpose \nof sending messages to it. 0 is a point of the screen, encoded in the form of a pair of coordinates, \nspecifying the center of the drawing. Initially, we only need one single pro-totype drawing, with mail \naddress proto; such a prototype, located at the center of the screen, is initialized by expanding the \ndrawings agent in the query, and can be later cloned to create new draw-ings. Expansion of the drawings \ntop-level agent is obtained via the following method: drawings <>- drawing Q noshape Q id(proto) Q center(m(O,O)). \nCloning is triggered upon reception of a message dup/2 (with 2 arguments) told to the forum by, say, \nthe user agent: the first argument and the sec-ond argument of this message are, respectively, the mail \naddress of the drawing we clone from and the mail address of the newly cloned drawing. Immedi-ately after \ncloning, the two drawings differ only by their mail addresses; however, from now on, they follow completely \nindependent evolutions. This is achieved by the following cloning method for draw- ings, which exploits \ncrucially the connective &#38;, like all methods dealing with creations of new agents: drawing 0 id(S) \nQ dup(S,Sl) Q ^ack(S) O-drawing Q (id(S) &#38; id(S1)). The sender of the dup/2 message can ensure uniqueness \nof the mail address of the new drawing by using the mechanism for generating new iden-tifiers described \nin Section 2.3.2. Notice also how the atom ack(S) is sent back to the forum as a message acknowledging \nthat the requested creation has taken place. This is because, in this applica-tion, the order in which \nmessages are processed is important: for instance, cloning or printing an ob-ject before or after moving \nit leads to two different results. Acknowledgement messages take a very simple form in this application, \nas we assume that there is only one single sender that needs to be acknowledged (the user); in a situation \nwhere mul-tiple senders need to be acknowledged, such mes-sages should contain not just the address of \nthe ac-knowledging agent, but also the return address of the original sender, to ensure that they are \nprop-erly delivered. Once created by cloning, each drawing agent can be modified. For example, to move \na drawing (by a specified amount D) we have the following method. drawing Q id(S) Q center(O) (D move(S,D) \nQ ^ack(S) O-drawing (P id(S) (D center(O+D). The prototype drawing proto has no specific shape, and, \ntherefore, neither have its clones at the time of their creation. Giving shape to such formless entities \ninvolves using a method like the following one, which constrains a drawing to be a square with sides \nof length A. drawing 0 noshape Q id(S) Q make-square(S,A) Q ^ack(S) <>- drawing (D square 0 id(S) Q side(A). \n Printing a square is done via the following method. square (D side(A) (0 center(O) Q id(S) Q print(S) \n0 -ack(S) Q ^line(Ml,M2) 0 -line(M2,M3) Q -line(M3,M4) (D ^line(M4,Ml) O- square Q side(A) Q center(O) \n(D id(S). The points Ml ,M2 ,M3 ,M4 are the four vertices of the square. They must be computed from \nthe center 0 and side A of the square (for clarity, this compu-tation is omitted here). The four messages \nline/2 sent upon triggering of this method correspond to graphical commands to print the four edges of \nthe square and are meant for the display agent. No-tice that there is no need for the messages to this \nagent to be ordered (we assume here for simplicity sake that the display agent consumes only line/2 messages, \nand the order in which lines are printed is irrelevant). Therefore, a drawing object does not need to \nwait for an acknowledgement to such mes-sages to pursue its activity. The flow of information is represented \nin Fig. 1. Agents are represented in square boxes and mes-sages in round boxes (only their topmost functor \nis displayed). An arrow from an agent to a message (resp. from a message to an agent) means that the \nagent produces (resp. consumes) the message. The example of this section illustrates the syn-chro-nization \nmechanism based on a send/acknowledge protocol between agents sharing a common com-munication medium, \nthe forum. This communi-cation mechanism is more flexible than the usual stream-based one, in that it \nsaves the programmer from the burden involved in stream manipulations (stream merging, explicit interobject \nconnections, etc.).  3.2 Generic Communication: Concur-rent Chart Parsing The example we provide here \nis a particularly in-teresting case of distributed problem solving which illustrates well the use of \nlocal resource consump-tion in generic communication. The problem we address specifically is concurrent \nparsing, a topic which has attracted the interest of several re-searchers in the object-oriented programming \ncom-munity [23, 301; on the other hand the problem-solving technique we employ here can be fruitfully \ngeneralized to more complex examples, like dis-tributed expert systems operating on highly com-plex domains, \nwhere different experts are required to work independently on shared data, feeding back dUP    move \nn  user  Figure 1: The flow of information different outputs which all need to be taken in con-sideration \nfor the final solution of a given problem. The program we describe amounts to a concur-rent implementation \nof the Earley s algorithm for context-free parsing [9] and draws much in the spirit of the active chart \nparsing methodology [16], where incomplete phrasal subtrees are viewed as agents consuming already completed \nelements to produce other (complete or incomplete) subtrees. However, in our case even the rules of the \ngrammar and the entries of the lexicon act as independent units directly partaking in the computation. \nMore-over, as distinct from the usual sequential formula-tions of chart parsing, here no superimposed \nsched-uler is in charge of the task of feeding incomplete subtrees with complete ones; instead, incomplete \nelements behave as truly active decentralized com-putational units which get their information from the \nforum, where finished subtrees are told as soon as they have been found. But we must preserve the fact \nthat, once a subtree is completed, this infor-mation must be broadcast to all the active agents which \ncan make use of it; indeed, in the case of ambiguous grammars, the number of such agents may be greater \nthan one, thus leading to differ-ent parses for the same string. Local consumption neatly deals with \nthis problem. 3.2.1 The Program We view parsing as being performed by four top-level agents, a string \nscanner, a grammar, a dictio- nary and a creator of new subtrees. This is ex-pressed by the following \nmethod, which contains in its head a single literal parsec1 ,S>, where I is the input string and S is \nthe symbol of the grammar defining the set of strings with respect to which we want to test membership \nof I. parseCInput ,Symbol) <>-grammar &#38; dictionary &#38; scarmer(Input,Symbol) &#38; create-tree. \nThe scanner agent, defined in the methods in Fig. 2, performs the two following actions: . It keeps popping \nwords from the input and producing pos (N) and word(W ,N) messages where -a pas(N) message supplies the \ninforma-tion that position N has been reached in the input; -a word(W ,N) message supplies the infor-mation \nthat there is a word W between positions N and N+l in the input. Positions are encoded as integers in \nthe suc-cessor notation. . Upon reaching the end of the input string, it sends a seek(O ,S) message, \nwhere S is the tar-geted grammar symbol, and then reduces itself into an agent whose sole task is that \nof retriev- ing answers. This is simply done by waiting for trees covering the whole input string with \n scanner(I,S) 0- scan(I,O) (D target(S).  scan(CWlIl,N) (D ^pos(N) (Q ^word(W,N) O- scan(I,s(N)). scan(Cl,N) \nQ target(S) 0 ^seek(O,S) C>- wait(N,S). wait(N,S) 0 ctree(O,N,S,T) 0 -answer(T) <>- wait(N,S). Figure \n2:Methods for scanning grammar <>- dictionary <>- s ==> [np,vpl &#38; entry(a,det) &#38; nP ==> [det,n] \nt entry(robot,n) &#38; \"P ==> Cpnl &#38; entry(telescope,n) &#38;  w ==> Cnp ,ppI 8t entry(terry,pn) \nt VP ==> Ctv,npl &#38; entry(saw,tv) &#38;  VP ==> cvp ,ppI $ entry(with,prep). PP ==> Cprep,npl . \n Figure 3: A grammar and a dictionary entry(W,S) 0 word(W,N) Q ^ctree(N,s(N),S,S-W) <>- entry(W,S). \n(S ==> Ss) Q seek(N,S) 0 pas(N) 0 -new(N,N,S,Ss,S) <>- (S ==> Ss). Figure 4: Methods for lexical entries \nand rules create-tree Q new(M,N,S,[],T) 0 ^ctree(M,N,S,T) O- create-tree (P ctree(M,N,S,T). create-tree \n0 new(M,N,S,CSlISsl,T) Q ^seek(N,Sl) c>- create-tree &#38; itree(M,N,S,Si,Ss,T). itree(M,N,S,Sl,Ss,T)0 \nctree(N,P,Sl,Tl) (D -new(M,P,S,Ss,T-Tl) O- itree(M,N,S,Sl,Ss,T). Figure 5: Creation and completion of \ntrees symbol S to appear in the forum; the structure T with which any of such trees has been repre- sented \nis then explicitly added as an answer. The grammar and the dictionary agent expand, respectively, into \na set of grammatical rules and of lexical entries, each originating a different agent; a sample dictionary \nand grammar7 are given in Fig. 3. Notice that the grammar is an ambiguous one. The behavior of lexical \nentries and rule agents is defined in terms of the methods in Fig. 4. Lex-ical entry agents accept as \nmessages words with which they match and send back corresponding complete preterminal trees, labeling \nthe given word with a preterminal symbol. On the other hand, rule agents consume seek(N ,S> messages \ntogether with pas(N) messages, if the sought grammar symbol S corresponds to their own left-hand side \nsymbol; in this case, they issue back a message for the creation of a new agent encoding an incomplete \n(empty) tree. Crucial is here the fact that the consump-tion by rule agents of seek/2 messages must be \nconcomitant with the consumption of matching (in the sense of being characterized by the same integer \nargument) pas/l messages; indeed, this correctly ensures that a rule agent can produce no more than one \nempty incomplete tree for any position of the input string, given that, for any N, it will be able to \nconsume no more than one pos (N) message. In this way, we prevent the possibility of infinite loops of \nthe left-recursive kind deriving from rules like the fourth and the sixth one in the grammar of Fig. \n3; furthermore, we block the possibility of redundant analyses. This will be illustrated in describing \na sample run of the parser further on in this section. Creating and completing new trees is accounted \nfor in terms of the methods in Fig. 5. The top-level create-tree agent consumes messages of the form \nnew (M, N , S, Ss , T) where M and N are, respectively, the two string positions spanned by the new tree \nto be created, S is the root of the tree, Ss is a list of symbols corresponding to the roots of the \ncomplete subtrees which are still needed in order to make this The symbol ==> appearing in the grammar \nrules is not a primitive of LO but simply a convenient infix notation for a binary term constructor. \ntree complete, and T is the representation associ-ated with the tree itself. It then deterministically \nchooses between the following two actions: . in case the list Ss is empty, it sends a mes-sage ctree(M,N,S,T) \nto signal that a com-plete tree with root S and representation T has been found between positions M and \nN; . in case the list Ss is of the form [Sl I Ssll , it sends then form a message creates an itree(M,N,S, \nof the incomplete Sl,Ssl,T). form t seek(N,Sl) ree agent and of the As for incomplete tree agents of \nthe form itree(M,N,S,Sl,Ss,T), they consume complete trees of the form ctree(N,P,Sl,Tl) to produce messages \nof the form new(M,P,S,Ss,T-Tl). Thus, requests for the creation of new trees can come ei-ther from rule \nagents as answers to seek/2 mes-sages, or from incomplete tree agents; in the former case such requests \ncan be thought of as leading to the formulation of further hypotheses which need to be verified in order \nto satisfy a certain initial hypothesis (this is known as step of prediction in the usual formulations \nof the Earley algorithm), while in the second case they follow from having progressed one step in the \nverification of a cer- tain hypothesis (this is known as a step of comple- tion). Fig. 6 shows the flow \nof information among the agents. The convention are the same as in the previous section (Fig. l), except \nthat we also make use of a thicker arrow to explicitly connect the create-tree agent with the agents \nit creates.  3.2.2 A Sample Run Let us now briefly consider a sample run of the parser. Assuming the \ngrammar and the lexicon in Fig. 3, consider the goal ?-parsec [terry,saw,a,robot,with,a,telescopel, s> \nAfter running the parser, the following two an-swers, corresponding to the two parses of the input sentence, \nwill be found in the global context. / \\,, I .L t I r I \\ rule .,  a entry grammar dictionn Figure \n6: The flow of information answer ( s-(np-(pn-terry)) itree(2,2,np,np, Cppl ,np) -(vp-(tv-saw) will \nboth consume the complete tree -(np-(np-(det-a)-(n-robot)) -(pp-(prep-with) ctree(2,4,np,(np-(det-a)-(n-robot))) \n -(np-(det-a) Furthermore, the agents encoded as -(n-telescope)))))). itree(l,4,vp,pp, Cl, (vp-(vp-(tv-saw) \nanswer ( -(np-(det-a) -(n-robot) ) ) ) ) s-(np-(pn-terry)) -(vp-(vp-(tv-saw) itree(2,4,np,pp, Cl, -(np-(det-a)-(n-robot))) \n(np-(np-(det-a)-(n-robot)))) -(pp-(prep-with) -(np-(det-a) will both consume the complete tree -(n-telescope))))). \nctree(4,7,pp, These two answers originate from the fact that the (pp-(prep-with) same complete trees \ncan be consumed by several -(np-(det-a)-(n-telescope)))) agents encoding different incomplete trees; \nspecifi- As a consequence, we end up with two different cally, the agents encoded as analyses for the \nsubstring saw a robot with a tele- itree(l,2,vp,np,n,vp-(tv-saw)) scope. On the other hand, notice that \nthe rules whose left-hand side symbol is np will receive in the course of parsing more than one seek(2,np) \nmessage to create empty trees with root np and starting position 2; however, any of such rules will never \ncreate more than one of such trees, as seek/2 messages must be consumed together with match-ing pas/l \nmessages, and any rule will be able to consume at most one pas(2) message. Thus, both redundant analyses \nand infinite loops deriving from left-recursion are in this way avoided. This a.p-preach to enforcing \nredundancy checking is quite simple and elegant and comes natural in a decen- tralized, object-oriented \nstyle of programming; it can be contrasted with the more usual way of en- forcing it, which is obtained \nby explicitly compar- ing newly created trees with previously existing ones. 3.2.3 Summary We can summarize \nthe salient points of this imple-mentation of a chart parser as follows: . with respect to sequential \nimplementations, we do not need to take care of specifying a scheduler which handles the feeding of incom- \nplete trees with complete ones; . with respect to concurrent, stream-based im-plementations (see for \ninstance [28]) we do not need to bother about the merging of streams of messages coming from different \nproducers; . with respect to what would be possible in stan- dard blackboard-based communication, we \nex- ploit the specific feature of local consump-tion characterizing forum-based communica-tion, which \nallows different agents to feed themselves on the same input to produce dif-ferent outputs. This produces \na concise, conceptual style of programming, with little burden on requirements which do not come from \nthe problem itself, but are instead imposed by particular implementation choices. Since the Earley algorithm \nis an instance of the technique of dynamic programming, this ap-proach can be generalized to other examples \nof dy- namic programming, as shown in [5].  4 Related Work We have seen how forum-based communication, \nwhich lies at the basis of the computational model for LO presented here, provides a refinement of blackboard-based \ncommunication [lo] in terms of local consumption. Proposals for a more local form of blackboard-based \ncommunication were also pre-sented in [19] in a non-logical setting, sharing our same intent of making \nuse of blackboards in the context of object-oriented programming. [7] pro- vides instead a logical version \nof blackboard-based communication in its standard global interpreta-tion. LO can also be seen as an instance \nof Concurrent Constraint Programming [25], the programming paradigm towards which the concurrent branch \nof logic programming languages is naturally evolving. (In a nutshell, we can think of Concurrent Con-straint \nProgramming as what becomes of logic pro-gramming once it is stripped of its obsolete com-mitments to \nClassical Logic, minimal Herbrand models, closed-world assumption etc., and compu-tation is explicitly \nviewed as the interaction of logi- cal agents refining an initial amount of information by incrementally \nadding new chunks of informa-tion, i.e. constraints.) Indeed, LO can be con-sidered as a Concurrent Constraint \nlanguage with agents whose point of view of the outside world changes over time: once an agent has seen \na piece of the outside landscape (the forum) then it will not see it anymore, unless it copies it explicitly \ninto its own local landscape. This can be contrasted with the Concurrent Constraint Logic Program-ming \nlanguages described in [24, 151, where agents never change their point of view with respect to the outside \nworld (the store of constraints). These two ways of implementing concurrent agents clearly complement \neach other, as they cover different as-pects of concurrent problem solving. Merging of the two approaches \nin a Linear Logic setting could be possible by permitting permanent elements to be added to the forum; \nsuch elements would be dis- tinguished from the non-permanent ones in the fact of being marked by Linear \nLogic modalities which give them explicitly the status of unrestricted re-sources. Linear Logic has been \nexploited to account for concurrency also in [l, 171; however, the back-ground there is functional programming, \ninstead of logic programming. [14] exploits the intuitionistic (sequential) version of Linear Logic to \nrefine the control mechanisms of sequential logic programs. [20] describes a general framework for rewriting \nlogics , suitable for accounting for change in a con- current programming context. [22] approaches the \nproblem of locality of interaction among concur-rent subsystems from the point of view of process algebras. \n Open Problems Our main effort is currently in the direction of find- ing an efficient execution model \nfor the language. Indeed, from a practical point of view, LO offers challenging but reasonably solvable \nimplementa-tion issues. We currently have a toy interpreter for the language, written in Prolog (with \ncoroutining facilities to simulate concurrency). Selection and access to the methods is one of the main \nbottle-neck of the interpreter; implementations technique used in production systems are currently being \nex-plored to overcome this problem [S]. We also think of a compilation process, based on a type-inference \nmechanism, which would avoid the accumulation of useless messages in object states (a garba.ge collec-tor \ncould complete the job at runtime). The ulti-mate compiler should be able to detect cases of spe- cific \ncommunication (one-to-one) and implement it as such, that is, without propagating a specifically sent \nmessage to the whole forum in such a case, but sending it directly to the intended receiver. Inter-mediate \ncases between specific and generic commu-nication, for instance when an object addresses a certain group \nof objects, could also be given a spe- cial treatment. Acknowledgement We are grateful to Gerard Comyn \nand Alexander Herold for helpful comments on this paper. We also thank Nabiel Elshiewy for helpful discussions. \n References S. Abramsky. Computational interpretations PI of linear logic. Technical report, DOC, Impe- \nrial College, London, U.K., 1990. G. Agha and C. Hewitt. Actors: a conceptual PI foundation for concurrent \nobject-oriented pro-gramming. In B. Shriver and P. Wegner, ed-itors, Research Directions in Object-Oriented \nProgramming. MIT Press, 1987. J.M. Andreoli. Proposition pour une synthkse PI des paradigmes de la programmation \nlogique et de la programmation par objets, 1990. These d Informatique de l Universit6 de Paris VI (Paris, \nFrance). J.M. Andreoli and R. Pareschi. LO and WI behold! concurrent structured processes. In Proc. \nof OOPSLA/ECOOPW, Ottawa, Canada, 1990. J.M. Andreoli and R. Pareschi. Dynamic pro- PI gramming as multi-agent \nprogramming, 1991. ECOOP 91 workshop on Object-based con-current computing. J.M. Andreoli and R. Pareschi. \nLinear ob- PI jects: Logical processes with built-in inheri-tance. New Generation Computing, To ap-pear, \n1991. (Sp ecial issue, Selected papers from ICLP SO). 171 A. Brogi and P. Ciancarini. The concurrent \nlanguage shared prolog. ACM Transactions on Programming Languages and Systems, To appear, 1991. M. Clemente. \nForthcoming MS Thesis, TU PI Miinchen. [9] J. Earley. An efficient context-free parsing al-gorithm. \nCommunications of the ACM, 13(2), 1970. [lo] D. Gelernter. Generative communication in linda. ACM Transactions \non Programming Languages and Systems, 7, 1985. [l l] J.Y. Girard. Linear logic. Theoretical Com-puter \nScience, 50, 1987. [12] S. Gregory. Parallel Logic Programming in Parlog. Addison-Wesley, 1987. [13] \nD. Hare1 and A. Pnueli. On the development of reactive systems. In K.R. Apt, editor, Logic and Models \nof Concurrent Systems. Springer Verlag, 1985. [14] J.S Hodas and D. Miller. Logic programming in a fragment \nof intuitionistic linear logic. In Proc. of LICS 91, 1991. To appear. [15] K. Kahn and V.A. Saraswat. \nActors as a spe- cial case of concurrent constraint logic pro-gramming. In Proc. of OOPSLA/ECOOP 90, \nOttawa, Canada, 1990. [lG] M. Kay. Algorith m schemata and data struc-ture in syntactic processing. Technical \nreport, Xerox Part, Palo Alto, U.S.A., 19SO. [17] Y. Lafont. Interaction nets, In Proc. of 17th ACM \nSymposium on Principles of Program- ming Languages, San Francisco, U.S.A., 1990. [18] H. Lieberman. Concurrent \nobject oriented programming in ACTl. In A. Yonezawa a,nd M. Tokoro, editors, Object Oriented Concur-rent \nProgramming. MIT Press, 1987. [19] A. Matsuoka and S. Kawai. Using tuple space communication in distributed \nobject ori-ented languages. In Proc. of OOPSLA 6S, San Diego, U.S.A., 1988. [20] J. Meseguer. A logical \ntheory of concurrent ob-jects. In Proc. of OOPSLA/ECOOP 90, 1990. [21] D. Miller. Lexical scoping as \nuniversal quan-tification. In Proc. of the 6th International Conference on Logic Programming, Lisboa, \nPortugal, 1989. [22] L. Monteiro and F.C.N. Pereira. A sheaf-theoretic model of concurrency. Technical \nre-port, CSLI, Menlo Park, U.S.A., 1986. [23] C. Numaoka and M. Tokoro. A decentralized parsing method \nusing communicating multiple concurrent objects. In Proc. of 2nd Interna- tional Conference of Technology \nof Object Ori- ented Languages and Systems, Pa.ris, France, 1990. [24] V.A. Sara.swat. Concurrent Constraint \nPro-gramming Languages. PhD thesis, Carnegie-Mellon University, Pittsburg, U.S.A., 1989. [25] V.A. Saraswat, \nM. R.inard, and P. Panan-gaden. Semantic foundations of concurrent constraint programming. Technical \nreport, Xerox Part, Palo Alto, U.S.A., 1990. [2G] E. Shapiro. A subset of concurrent prolog and its interpreter. \nTechnical report, Insti-tute for New Generation Computer Technol-ogy, Tokyo, Japan, 1983. [27] E. Shapiro. \nThe family of concurrent logic pro-gramming languages. Technical report, The Weizmann Institute of Science, \nRehovot, Is-ra.el, 1989. [28] R. Trehan and P.F. Wilk. A parallel chart-pa,rser for the commited choice \nlogic lan-guages. In Proc. of the 5th International Conference on Logic Programming, Seattle, U.S.A., \n1988. [29] I<. Ueda. G uarded Horn Clauses. PhD thesis, Dept of Information Engineering, University of \nTokyo, Japan, 1986. [30] A. Yonczawa and I. Ohsawa. Object-oriented parallel parsing for context-free \ngramars. In Proc. of COLING SS, Hudapest, Hungary, 1988.  \n\t\t\t", "proc_id": "117954", "abstract": "", "authors": [{"name": "Jean-Marc Andreoli", "author_profile_id": "81100504586", "affiliation": "ECRC, Arabellastrasse 17, D-8000 Munich 81, Germany", "person_id": "P136697", "email_address": "", "orcid_id": ""}, {"name": "Remo Pareschi", "author_profile_id": "81100340102", "affiliation": "ECRC, Arabellastrasse 17, D-8000 Munich 81, Germany", "person_id": "P240620", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/117954.117971", "year": "1991", "article_id": "117971", "conference": "OOPSLA", "title": "Communication as fair distribution of knowledge", "url": "http://dl.acm.org/citation.cfm?id=117971"}