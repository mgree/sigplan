{"article_publication_date": "11-01-1991", "fulltext": "\n The Kala Basket A Semantic Primitive Unifying Object Transactions, Access Control, Versions, and Configurations \n SERGIU S. SIMMEL Samsung Software America, lnc.2 ABSTRACT Kala is an untyped persistent store for practical \nobject-based systems, such as OODBMS, OMS, and object-oriented languages with persistence. Baskets are \ndynamic groupings of immutable data elements managed by Kala. Baskets synthesize transaction, con-figuration \nmanagement, and access control semantics, and thus offer a platform for implementing arbitrary such models. \nIn this article we introduce Kala baskets, their design motivations and goals. We then explain Kala s \nbasket mechanism in some detail. Finally, we offer a few examples of how baskets are used to implement \nfeatures of arbitrary transaction, configura- tion, and access models. 1. INTRODUCTION KaZa [6] [7] is \na low-level untyped storage man- agement system. Kala is positioned below the line marking the decomposition \nof objects into untyped data. It implements the semantics of robust, dis- tributed, secure, changing, \nand shareable persistent data. Layers built upon the Kala platform can implement the semantics of objects \nwith the same properties. Permission to copy without fee all or part of this material is granted provided \nthat the copies are not made or distributed for direct commercial advantage, the ACM copyright notice \nand the title of the publication and its date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or \nspecific permission. c 1991 ACM 89791-446-5/91/0010i0230...s1.50 Kala is a Trademark of Pertobscot Research \nCenter, Inc. z Author presently with Oberon Software, Inc., One Memorial Drive, Cambridge, Author presently \nwith Star Semiconductor, Inc., 25 Independence Drive, Warren, IVAN GODARD Penobsco t Research Center, \nlnc.3 Kala employs baskets, a single unifying mechanism that supports higher-level notions such as transac- \ntions, configurations, versions, access groups, etc. Baskets are non-partitioning groupings of immu- \ntable data elements. Their semantics allows wide versatility of above-Kala concepts while preserving \neconomy of means at Kala s level. In particular, Kala baskets support the implementation of most useful \ntransaction, access, grouping, and change models. They support arbitrary models in these domains, rather \nthan imposing a specific model. Kala manages the storage of and access to data of arbitrary size. It \neffects the transfer of data between main (volatile) and secondary (persistent) memory, and manages the \nstore on a variety of hardware. All access to a stored data elements is done via baskets. Kala incorporates \nfunctionality not ordinarily associated with this low-level architectural compo- nent, without the disadvantages \nof a monolithic architecture or sluggish performance. Kala satisfies all of TI s Open OODB s Transactional \nStore Mod- ule s requirements [lo]. Kala implements many of the Object Services within the O.M.G. Reference \nModel [9].  2. MOTIVATION Object persistence is becoming a desideratum for most practical object-based \nand object-oriented sys-tems. Craig Thompson etal. makes the case for modular object systems [lo] by \nidentifying orthogo- nal design dimensions and associating them with Massachusetts 02142.617-494-0990, \nsimmel@oberon.com New Jersey, 07059,908-647-9400. modules. Support for persistence has been concen- \ntrated in one module of object systems architecture, usually termed persistent store or storage system. \nModularity is one force driving the design pro- cess. Another is the attempt to discover commonality \namong various functions once thought of as belong- ing to distinct dimensions. After identifying the \ncommon features, the once multiple modules col-lapse (at least in part) into a common one. To achieve \nlight-weight, compact, and efficient designs, one must maintain a delicate balance between modu- larity \nand commonality. Kala achieves this balance by providing the bas- ket mechanism as a primitive facility \nfrom which other facilities supporting the conventional notions of Transaction, Configuration, Version, \nand Access Control may be built. Kala baskets do not impose specific models of these facilities, but \nrather allow for a wide range of variation. This represents an application of the general design principle \nof com- posabilify, by which well chosen primitives with minimal interaction may be composed to provide \nmore specialized facilities. Traditional database theory typically defines a Transaction as a single \nexecution of a program sec-tion [ 121. Transactions are viewed as sequences of actions taken during execution4. \nResearch and commercial object oriented systems, including object-oriented DBMSs, maintain this definition, \nregardless of the supported transaction models. As transactions have become central to the database field, \nthe transaction typology has correspondingly grown to accommodate very diverse application requirements. \nFor example, Chung C. Wang lists 11 classification dimensions (parameters) in his survey of transaction \nmodels [ 131. Access control has traditionally been provided for by file systems and DBMSs, as motivated \nby protec- tion and security needs. The traditional comprehen- sive solution to the access specification \nand control problem has employed access control lists (ACLs), such as in the Aegis operating system. \nA simpler but widespread commercial solution is Unix, which has a user - group - world hierarchy. These \nand other 4 The term itself suggests this view: tram-action means across actions . schemes have been \nplagued by scaleability and inflexibility problems. Configurations represent views over a database of \nversioned objects. Configuration supporting mechanisms have both exploratory use (for example, in studying \naggregation mechanisms in object bases, such as worlds [ 141) and practical use (for example, in controlling \nchange in project software bases [4]). They have been studied and implemented mostly in isolated, application \ndomain specific areas, such as software engineering and document management environments. Kala s design \nextracts the following common notions from the above requirement domains, and embodies them in the basket \nmechanism: Sets of Instances. All these concepts are set oriented notions. A transaction can be viewed \nas a set of new class instances created during a single execution of a program section. Controlling access \nto objects can be viewed as allowing an agent to access a certain set of objects. A configu- ration is \nsimply a set of object versions which are combined into an instance of one or more com- posite objects. \nSet Cal cu 1 us. In each of these cases the sets are combined in ways that involve network- and often \ntree-organized set groups. Transactions are often grouped in tree-like fashion (nested). Transaction \noperations such as commit andfail are very com- mon. Access sets are often arranged in tree-like fashion \n(user, group, etc.), and operations such as expose and hide are very useful. Configurations are often \norganized in trees and DAGs to model linear and branching evolution over time. Opera- tions such as merge \nare central. Dynamic Nature. Each concept models a dynamically changing reality. Transactions, including \nlong ones, continuously change as newly created objects are added during the execu- tion of the program \nsection. Protection and secu- rity needs change very often. Configurations are subject to substantial \nchange until frozen for archiving purposes. Visibility Control. Each concept is a solution to a different \nfacet of the visibility problem. Transactions control visibility of change. Access control deals with \nvisibility of objects. Configura- tions control visibility of the state of composite objects. Versions \ncontrol visibility of object history. In addition, in each of the three domains:  . Transience and Persistence. \nAll notions are germane to both transient and persistent objects. Also, transactions, access control \ngroups, and configurations themselves can usefully be either transient or persistent. . Datum Orientation. \nAlthough each notionis pertinent to object-based systems, they are cer- tainly not specific or bound \nto systems designed or implemented within this paradigm. For instance, these notions do also relate to \nlower level raw data. These observations have encouraged us to seek a unique mechanism to model and implement \nthe common features in the context of a low-level stor-age system. Their distillation led to the design \nof Kala s basket mechanism. 3. DESIGN GOALS The following have guided us throughout the design and implementation \nprocess: Commonality. Capture as many of the com- mon traits of all higher-level concepts as can be identified. \nWe believe that an expressive and more general low-level subsystem enhances the likelihood that the entire \nobject-based system will be lighter and more compact. Simplicity. Make Kala s interface with the other \nsubsystems as simple (i.e., the lowest num- ber of interface concepts) as possible. Not only does this \nenhance Kala s usability, but it has a positive effect on its own design and implementa- tion. Feasibility. \nThe design should be imple- mentable in an industrial-strength fashion. There is widespread agreement \nthat compactness, main-tainability, ease of use, and performance are desirable qualities. Primitiveness. \nKeep functions that can be practically derived out of this subsystem. Keeping the abstraction level boundaries \nclean has impor- tant beneficial effects on both Kala s and the entire object system s design and implementation. \nThis requires a crisp, rigorous definition of Kala s level of abstraction, Such a definition makes the \ndecisions about which side of this boundary a cer- tain function belongs consistently possible. Although \nthe design goals above were primary throughout this work, there are two other require- ments which we \nhave always considered central and overriding: Performance. Build Kala to be a highly per- , forming \nmodule, both in space and time. Security. Build Kala to introduce no more secu- rity holes than already \nexist in the host operating system.  4. BRIEF KALA OVERVIEW Kala s data model is simple and largely \nuntyped. Kala manages data elements of arbitrary size con- sisting of bits and embedded references. These \ndata elements are termed monads. Monad references are essentially pointers into other monads. The salient \nfeature here is that monads are immutable. Once cre-ated, a monad can never be deleted or modified. It \nmay become inaccessible5 (if it does Kala will recover its physically allocated resources), but the monads \nidentity is never discarded. Monads are universally and uniquely identified by monad identifiers, or \nmids. A mid is a Kala-sup- plied abstract data type (ADT). Each mid is guaran- teed to be unique at all \ntimes and all places. Mids are never reused, and thus guaranteed to be univer- sally unique if created \nunique. Kala insures unique- ness by using a Kala store (cf. $7) creation time based scheme for generating \nids, thus reducing the risk of inadvertent creation of duplicate ids to negli- gible levels. Monads are \npersistent. Although we casually talk about loading a monad, what we actually mean is that we create \na copy of a monad s value in volatile memory. Informally, the model is that of a persis- tent store from \nwhich we can get copies of values into volatile memory, and within which we can cre- ate new values. \nSince monads are immutable, there 5 A monad can become inaccessible when the last reference to it is \ndropped, and the Kala server (cf. 97) which manages the monad is made aware of this event. is no storing \na monad. We can only create a new monad. Monads are statically grouped into kin. Each monad belongs to \nsome kin, and the membership is assigned at the monad s creation. Kin membership is static; it can never \nbe changed or revoked. Once cre- ated as a member of a certain kin, a monad can never be made a member \nof any other kin. Kin are abstract groupings of monads; there is no represen- tation of a kin held or \nmanaged by Kala. A monad s kin membership is determinable using its mid. Kin are used to group monads \nwhich implement semantically-related higher level entities. However, Kala is totally unaware of any such \nsemantic rela- tion; it only preserves the grouping. For example, kin can be used to group together all \nversions of the same entity. Section 10.1 provides a further details on the uses for the kin mechanism. \nThere are two ways to access monads. One is through references from other monads. A monad can contain \nany number of references. Each reference points into another monad, that is to a monad plus a numeric \noffset measured in bits. References in Kala storage have sophisticated but compact repre- sentations. \nIn main memory, references are repre- sented as ordinary machine pointers. Once in main memory, accessing \na monad through another monad s reference amounts to dereferencing a pointer - no function call required. \nMemory Figure 7: Loading a monad into volatile memory Alternatively, monads can be accessed through handles. \nA handle is a Kala abstraction representing a path to a monad. Handles exist only in groupings termed \nbaskets. A basket is thus a (possibly empty) set of handles. Handles can only be found in baskets. Figure \n1 illustrates these basic concepts with a simple example showing a monad m (in the persis- tent store \non the disk) referenced by a handle h in a basket B. Loading the monad means creating a copy of its data \nin volatile memory. The memory copy can now be used by the application in whatever way it desires, including \nmodifying it. The monad, however, cannot be modified: it is immutable. Memory Basket B monod m monad \nm Figure 2: Creating a new monad When changes to the volatile memory copy need be saved to the persistent \nstore, a new monad M is created. Figure 2 shows the new monad being cre- ated with the changed memory \ndata as its value. A new handle h has also been created in basket B to refer to it. 5. KALA BASKETS \nThe basket is one of Kala s central externalized concepts. It has fairly rich semantics, and it inti- \nmately interacts with Kala s other externalized con-CC!ptS. 5.1. Baskets as a Grouping Device In contrast \nwith kin, which are static and abstract groupings of monads, baskets are dynamic and con- crete groupings. \nThe dynamic nature of baskets means that a basket s composition can be changed at any time. Handles can \nbe explicitly deleted from a basket: void DeleteHandles(handles) removes a specified set of handles in \none or more baskets, and may indeed leave some of the baskets 233 empty. Handles can be explicitly \nmoved from one basket to another: void MoveHandles(handles, baskets) moves a specified set of handles \nfrom several baskets to other baskets. In addition, copies of handles can also be made and placed in \nother baskets: void CopyHandles (handles, baskets) makescopiesofaspeci- fied set of handles, and places \nthem into other baskets. Baskets are concrete in that Kala maintains repre-sentations of them. Baskets \nare identifiable and can be manipulated using Kala s programmatic inter-face. All operations which change \nthe contents of one or more baskets are atomic and (optionally) per-sistent.  5.2. Basket Composition \nA basket contains zero or more handles. Its com- position can be queried: the ResolveHandles operation \ncan be used to query a basket for its han- dles. Baskets may contain any combination of han- dles with \none quintessential constraint, termed Kala s Central Dogma: In any basket at any time there cannot be \nmore than one handle to akin6 monads. This constraint is strictly enforced by Kala. It determines basket \nsemantics, and controls the use of monads, kin, and baskets by other subsystems. The Central Dogma provides \nKala s general usefulness, as should become apparent throughout the remainder of this paper. Handles \nare inserted in baskets during the process of creating a new monad, or moving or copying a handle from \na different basket. One immediate corollary to the Central Dogma is that whenever a new handle must be \ninserted into a basket and an akin handle already exists in that basket, the existing handle must be \nimmediately and atomically dis-carded and replaced with the new one. This process is termed supplanting. \nFigure 3 shows an example of a Kala store con- taining several monads of various kin. All akin mon- ads \nare depicted as rectangles with the same fill pat- Two or more monads are said to be akin if they belong \nto the same kin. The term extends to handles as well. tern. For example, monads m2, m4, m7, and m8 are \nall of the same kin. The example shows a few common situations. Basket 83 is empty, while bas- kets Bl \n, B2, and 84 contain handles. Among the handles shown, there are two pointing to the same monad ml : \none in basket Bl and the other in B4. There are no handles pointing to monads m4 and m7. This example \ncertainly satisfies the Central Dogma. FigweB: Baskets as Groups of Handles to Monads In addition, the \nfigure shows a reference in monad m8 pointing into monad ml 0, that is at some offset within ml O s bits. \n 5.3. Basket Identification At each point during its execution, a Kala applica- tion may be using several \nbaskets to access (e.g., load or create) various monads of interest. Each bas- ket is identified using \na Kala generated and main- tamed identifier. Like all Kala s identifiers (e.g., monad identifiers, kin \nidentifiers), basket identifiers (or bids) are guaranteed to be universally unique.A bid is assigned \nby Kala to each basket upon creation; bid NewBasket(void) creates anew basket, and supplies its identifier \nto the caller. The Kala bid is in fact a Kala-supplied ADT. Instance operations are provided, such as \nthe boo1 EqualBid (bid,bid) testforequality.  5.4. Basket Grouping Monads are accessed by the application \nsoftware via handles in baskets. At any point there may be several baskets used by the application code \nto access the data stored in monads. As a set of han- dles, each basket defines a scope for references \nto the values held in the corresponding monads. Using baskets to define scope leads to the idea of scope \nnesting, similar to that in programming languages or transaction models. Nested scopes are naturally \nrep resented as ordered lists. Going from inner scopes towards outer scopes corresponds to searching \ndown such a list. In Kala, an ordered list of baskets is an extemal- ized object termed the Basket Search \nList (or SSL). Kala currently maintains one BSL for each Kala application client (see $7). Its contents \nis totally under the application code s control; void Bas -ketSearchList (rowBid) updatestheBSL by replacing \nit with the provided ordered list of bas- kets, all identified by their bids. There are five ways to \naffect the contents of the BSL. One is by redefining it, as shown above. Sec- ondly, Kala places the \nbasket created with bid NewBasket (void) into the BSL according to a well defined rule. The third operation \naffecting the BSL permits multiple cooperating Kala-client processes to share baskets; void ProvideBasket(bid, \nkala-Client ) makes an extant basket available to another Kala client (cf. 97). The affected BSL in this \ncase is that of the target Kala client. The basket to be shared is identified by its bid, which is a \nunique identifier and is thus exportable beyond a client s boundaries. The target Kala client is identified \nby whatever the operating environment provides to securely identify other clients. Asexpected,void DeleteBasket(bid) \nremoves a basket from the BSL of the executing application. If no other application is using this basket \nand the basket is not persistent, Kala will recover its resources. Finally, accessing a persistent basket \nor a basket snapshot (cf. $6 ) also inserts it into the BSL. for convenience. 5.5. Addressing Handles \nA handle is fully specified by supplying the bid of a basket containing it and the mid of the monad referred \nto by the handle. This method is precise, but not very convenient. Kala provides the ability to incompletely \nspecify a handle using a set of rules to resolve the specification to zero, one, or many handles. The \nspecification is termed a handle address, and the process resolving an address. Kala provides several \nmethods to express a handle address, called addressing modes. In all modes, each handle address has two \ncomponents: identity and scope. The identity component of a handle address specifies what monad(s) we \nare looking for: a specific monad, of a known mid, monad(s) in a specific kin, of a known kid, monad(s) \nin any kin, every monad with a handle in a specific basket, or monad in a new kin, of which the first \nmonad is to be created. The scope component of a handle address speci- fies where Kala should look for \nthe monad(s): a specific basket, of a known bid, or any of the baskets in the BSL, searched in order. \nIn addition, handle addresses can be either single- valued (their resolution contains zero or one handle) \nor multi-vahed (their resolution contains zero or more handles). For example, the simplest addressing \nmode is {mid, bid}. It specifies a specific monad in a spe- cific basket. If a handle to monad mid exists \nin bas- ket bid, then the address resolves to it. Otherwise, it resolves to no handle. {kid,firstFound} \nspecifies amonadofa given kin to be searched for in the BSL. If a handle to a monad in kin kid is found \nby orderly searching through the baskets currently in the BSL, the address resolves to that handle. Otherwise, \nit resolves to no handle. (everyKid, bid} is a multi-valued address specifying all monads with handles \nin a given bas- ket. Note that the resolution will never contain akin monads, due to Kala s Central Dogma. \nThe resolu- tion however may be an empty set. If basket bid is not anaccessed basketfor the issuing client, \nan exception is raised. Finally, {kid, allFound) is also a multi- valued address specifying all monads \nin a given kin which have handles in any of the baskets currently in the BSL. The address resolves to \nthe unordered set of these handles. If no handle is found, the reso- lution is empty.  6. PERSISTENCE \nSo far, baskets have been introduced with no mention of their lifetime. A basket can be either transient \nor persistent. When newly created, a basket is transient; it will disappear as soon as the creating Kala \nclient disappears. Since Kala identifiers are universally unique, a basket s identifier will never be \nreused. There are two persistence regimes for baskets: basket snapshots and recoverable baskets. 6.1. \nBasket Snapshots As the name suggests, a basket snapshot is the persistent image of a Kala basket object, \ntaken at a certain instance of time. Basket snapshots are not persistent baskets. A basket snapshot just \nholds a basket state persistently. A basket snapshot is held in a monad, and behaves like a regular monad. \nIt is created by mid CreateBasketSnapshot(kid, bidl, bid2) , which creates a snapshot for a basket iden- \ntified by bid2 in a monad of kin kid, and creates a handle to that monad in the basket bidl. The snap- \nshot reflects the state of the bid2 basket at the time the method is executed (Kala servers are conceptu- \nally single-threaded; although operation requests are queued up, the execution of each method is atomic). \nBasket snapshots are used to supply initial values to newly created baskets. bid AccessBas - ket (kid, \nbid) creates a new basket whose ini- tial contents are the handles in the snapshot addressed throughthe \n{kid, bid} handle. This is in contrast with bid NewBas - ket (void) , which creates an empty basket. \n 6.2. Recoverable Baskets Recoverable baskets are truly persistent baskets, in that they outlive the \nKala client that created them. A transient basket can be made recoverable; xnid MakeBasketRecoverable(kid, \nbidl, bid2) makes the basket bid2 recoverable. In order for the basket to be accessible to other or sub- \nsequent applications, a handle to it is created in bas- ket bidl. From now on, the handle looks like \nany other handle to a monad of kin kid. But this is a special kind of monad: upon accessing it with bid \nAccessBasket(kid, bid)itbecomes available to this or any other Kala client at any time. All applications \nthat access this monad share the persistent basket. Any change to a recoverable basket, such as creat- \ning a new handle or moving a handle into the basket, is persistently recorded. The state of a recoverable \nbasket is restored after any unexpected termination of the Kala client or server, short of media damage7. \nThe recovery is done automatically upon Kala server restart.  7. SHARING Kala s execution architecture \nis comprised of an arbitrary number of servers and clients running on a computer network. Each KaZa server \nexecutes the same Kala setver code, and manages a single Kala storing area, termed KaZu store. A server \nand its store form a unit, termed KaZu installation. EachKaZa client executes the application s code, \nlinked with the same KaZa client library code. A Kala client can be attached to one or more Kala servers. \nThere is a default Kala server to which a client attaches upon issuing its first Kala service request. \nEach Kala server may communicate with several other Kala servers. Kala servers can fetch values stored \nin any accessible Kala store on behalf of each of their clients by making requests to the appropriate \nKala server. This maintains the illusion that a client is served by only one single Kala server, while \nin reality many other servers may be involved. The totality of all Kala stores existing at a certain \ntime at any place, whether accessible or not, forms The KaZa Monadbase. There is only one such entity, \nalthough only portions of it may be accessi- ble to a client at any time. The universality and uniqueness \nof all Kala identifiers such as mids and bids supports the universal uniqueness of the Mon- adbase. The \nKala Monadbase is implemented as an ever growing set of Kala stores, each established in a separate Kala \ninstallation. 7 Dealing with recoverablity after media damage is left to the subsystem under Kala, such \nas mirrored disks and disk drivers. 236 Kala clients can share baskets. There are two bas- ket sharing \nregimes: provided baskets and persistent baskets. 7.1. Sharing through Providing Baskets Two or more \nconcurrently executing Kala clients can share a basket by having one client provide the basket to another \nthrough the void Provide- Basket (bid, kalaclient) operation. Once the target Kala client has the basket, \nit can provide it to any other Kala client for which it has a valid identification. Provided baskets \ncan be tran- sient or persistent. The Provide Basket mechanism has a shared memory semantics. The shared \nmemory structure (the shared basket) exists however only in the Kala server s memory, and is accessed \nsoley through Kala s programmatic interface. 7.2. Sharing Persistent Baskets The second way to share \na basket is to have mul- tiple Kala clients access a recoverable basket (cf. $6.2) from the monad which \nholds its state. Since the basket is persistent, it can be shared among Kala clients which don t necessarily \nexecute concurrently. Note that in order to share a recoverable basket, each Kala client must have access \nto a handle to the monad that holds its state. Each client may access the recoverable basket through \nits own private handle, or more likely through the same handle in yet another shared basket. Thus, to \nbe shareable is a transitive relation: if a basket is shareable, all persis- tent baskets which have \nhandles in this basket are shareable, too. When shared among concurrently executing Kala clients, any \nchange performed by any one client is made instantaneously visible to all other clients who had accessed \nthe basket. This is true not only in a single-server configuration, but in the more common multi-server \nconfigurations. Basket objects are maintained on the Kala server side, but they are not distributed objects: \na single basket is represented by a Kala-internal basket object held in one single server at a time. \nThe inter-server communications establish client-server relationships between the server owner of a shared \nbasket and all clients and other servers that share it. 8. LOCKING Since baskets, and hence monads, can \nbe shared among clients, Kala supports the notion of locking as a means to prevent unwanted modifications, \nand to insure serializability. Since monads are immutable entities, locking a monad is a senseless operation. \nHowever, basket contents are mutable, so Kala allows one tofreeze and correspondingly thaw handles. Freezing \na handle in a basket means disallowing any operation concerning that handle: its creation (if the handle \nhas not been created yet), its removal, its replacing with another akin handle, its move into that basket, \netc. A freezer is a Kala maintained object used to tag such handles when they are frozen. Like monads, \nbaskets, and kin, freezers are identified byfreezer identifiers (orfds), which are also universally unique. \nvoid FreezeHandle(mid, bid, f id) freezes the handle of a monad or kin in a bas- ket, and tags it with \nthe freezer. A freezer may tag many frozen handles. Kala supports two freezing/thawing regimes. The first \nregime requires explicit thawing; a handle frozen by FreezeHandle needs be thawed by void ThawHandle(mid, \nbid). AKalaclient can thaw a handle as long as it possesses the freezer the handle was tagged with at \nfreezing time. This regime is used to implement long transac- tions and check-in / check-out strategies \n(cf. 9 10.5). It was designed to support such ownership notions, and thus it is oriented towards longer \nterm cycles, and survives system crashes. In contrast, the second regime was designed with transient \nlock-up in mind. It supports a request/grant freezing strategy. This allows freezing requests to be placed, \nqueued up by Kala, and granted automati- callyas previously granted freezes for the same han- dles either \nexpire thawed. The or are explicitly void FreezeKinInBasket (kid, bid, fid, durationl, duration2) operation \nallows one to request that the handle to a monad of kin kid in basket bidbe eventually frozen, and  \nlabelled with freezer f id. Once granted, the freeze will expire after durationl. The request itself \nwill expire after duration2 . Note that freezing is not associated with a handle to a specific monad, \nbut to any handle to a monad of a specific kin in a basket. Thus, the handle does not even have to exist \nin the specified basket. If it does, then the request is for it to be eventually frozen. If it doesn \nt, then the request refers to this handle placeholder meaning that no handle to a monad of the kin kid \ncan be inserted into that basket until the thaw occurs, either by time-out or explicitly by void ThawKinInBasket(kid, \nbid) . Unlike the first regime, this freezing does not sur- vive system crashes, and is automatically \nthawed during recovery. 9. BASKETS AND TRANSACTIONS Basket is the primitive mechanism for implement- \ning the higher level notion of transaction. In this section we will briefly explore the possible design \nspace of a Kala-using module which implements some transaction model. We will start with a very simple \ntransaction model: the conventional OLTP transactions. We will then briefly explore more modem transaction \nmodels.  9.1. Simple Transactions Let s assume that a portion of the KaIa monad- base represents a database \nof items. Each item e in the database is represented by a kin k. A monad of that kin represents a specific \nstate of that item. For each kin (and item) there is a handle h in a unique, shared-by-all-users basket \nP (for public ). Handle h points to the monad which represents the current public value of that item. \nThus each item e can be accessed by accessing the monad m of its corre- sponding kin k for which there \nexists a handle h in P. A transaction T is represented by a basket B. Starting a new transaction corresponds \nto creating a new, empty, transient basket. Each of T s actions (or schedule, cf. [ 121) creating new \nitems or updating existing ones is represented as an action (a call to a Kala function) which creates \na new handle in B to a new monad. Each application s BSL has either one or two baskets. If the application \nexecutes within a transaction T, its BSL = [B, P}. If the application executes outside any transaction, \nits BSL P {P) . m in k Fiaure 4: Loading an kern initially The application code must call Kala s Load \nopera- tion to attempting to access an item from the database. The handle is addressed using the {kid, \nf irstFound) addressing mode. If this is the first time that item is accessed by this client, the address \nresolves to the handle h in P , for there is no handle to any monad of that kin in B. Figure 4 illustrates \nthis case. m in k m in k Figure 5: Updating the Item within a Transaction After the item is processed \nin memory, its new state must be saved on disk. This corresponds to creating a new Kala monad m akin \nto the original one. But since this update is done within the transac- tion T, the handle h to the new \nmonad is created in B. Since there was no handle to a monad of this kin in B, this handle has nothing \nto supplant. The result is shown in Figure 5. 238 From this point on, within the transaction T, any \nattempt on the part of this Kala client to re-load the item will result in (conceptually) loading the \nmonad to which the handle in B points. On the other hand, any other Kala client that desires to access \nthe item from the database will load m, because B is not shared, and it can only see h. 9.2. Transaction \nCommit, Undo, and Redo After loading and updating several items as part of our transaction T, the Kala \napplication reaches a point where it must decide whether to make all these updates visible to the rest \nof the world or not. In other words, commit T or fail it, thus undoing all the changes. Figure 6: After \na series of creates &#38; updates Let s assume that the application updated two items represented by \nkin kl and k2, and created a new item, represented by kin k3. The state after these modifications of \nthe database is shown in Figure 6. Committing the transaction T represented in this simple model by the \nKala basket B corresponds to moving all the handles in B over to P. To satisfy Kala s Central Dogma (cf. \n$5.2 ), handles hl and hl cannot coexist in P. Thus, hl supplants hl . A similar situation is encountered \nwith h2 and h2 , and h2 supplants h2. h3 however does not encounter any other akin handle, and it is \njust moved to Ip. The situation after transaction commit is shown in Figure 7. In summary, a committing \na transaction results to the following Kala call: MoveHandle(everyKin, tactionBas- ket, publicBasket); \nwhere tactionBasket is the basket representing the transaction. Fiaure 7: After transaction commit Alternatively, \nif the decision is to fail the transac- tion and undo all the modifications to the database, merelyremove \nall the handles in B, thus bringing the state of the database like it was in Figure 48. Kala will soon \ndeallocate the values in the Kala store for which there is no handle in any basket. Redoing a transaction \nis again trivial: remove all the handles in B, and then perform the sequence of actions in the transaction \nonce again. New monads will be generated, and the redone transaction can finally be committed, failed, \nor redone once again. 9.3. Nested and Long Transactions The simple model presented in the previous sec-tions \ncan be extended to a fuIl nested trunsaction model by allowing transaction-representing baskets to be \nplaced in ordered lists, the BSLs. Any Trans- action Module built above Kala baskets imposes a certain \ntransaction model by the manner in which it administers a client s BSL. For example, suppose any time \na new transaction is started, the implement- In reality, failing a transaction is more properly represented \nby moving all the handles to a special basket named the Failed basket. This method allows for a one-level \nundo facility even for transaction failing. ing basket is placed at the beginning of the BSL, and each \ntime a transaction is committed, the han- dles in the basket representing that transaction are moved \nto the basket next on the BSL. Then, the implemented semantics is that of nested transac- tions. Similarly, \nother multiple transaction model can be built with an appropriate structure of baskets. A BSL represents \na path from a transaction to the root of all transactions. Although Kala does not impose any such root, \nit offers a convenient default through the Public Basket, a basket created by default during the process \nof initialization of any Kala installation, and automatically provided to every application which attaches \nto that server. The ability to maintain persistent baskets and freezers offers support for long transactions \nin a straightforward manner. The basket which repre- sents the long transaction is made recoverable (cf. \n$6.2). The transaction will exist as long as there is a handle to a monad containing the state of this \nrecov- erable basket. A new Kala client process can use the transaction by accessing this monad, creating \na basket in its environment, placing it on its BSL, and then using it to place handles pointing to newly \ncre-ated values. The first three steps are all done by Kala s AccessBasket operation. The BSL itself \ncan be made persistent by saving its state into a monad and restoring it back. Thus the transaction nesting \nitself can be preserved across clients executions. Kala provides convenient primi-tives for storing the \nBSL s data structure (a linked list of basket identifiers) in a monad. Further details on Kala s support \nfor modem transaction models are to be found in [S]. 9.4. Check-in / Check-out The presence of long transactions \nin conjunction with handle freezing makes the implementation of check-in / check-out models straightforward. \nLet s assume for simplicity that the object versions sub- ject to check-out are implemented by monads \nwith handles in some shared basket, such as fP in figure 49. A check-out operation on the versioned \nobject represented by kin k corresponds to freezing the handle h in P. The freezing is done with a persistent \nfreezer, so that the handle remains frozen after the freezing process exits. While this and other handles \nare frozen, all updates to the versioned objects are done into an inner transaction, implemented as a \npersistent basket B located in the BSL before P . This strategy makes the updates local . B implements \na long transaction. For example, a new object version for our versioned object is represented by monad \nm with a handle h in B (cf. figure 5). The versioned objects may be checked-in all at once or in arbitrary \ngroups. If the former is pre- ferred,acallsuch asMoveHandles(B, 6') fol- lowed by thawing the handles \nin P is all that is needed. Single check-in (for example, on versioned object represented by kin k) is \nimplemented by doing a MoveHandle (k , B , @) , followed by a ThawHandle(k, &#38;', aFid). 10. BASKETS \nAND CONFIGURATIONS Configurations are software objects used to orga- nize the evolution of complex systems, \nsuch as soft- ware during program development [ 11][3]. In this section, we briefly illustrate Kala s \nsupport for three fundamental organizational aspects supported by software configuration management (SCM), \nand in particular the use of baskets in supporting software composition. Finally, the support for the \ncheck- in/check-out model is also illustrated. Gustavsson [3] distinguishes three organizational dimensions \nSCM systems need to support: evolu- tion, membership, and composition. He argues for their complete orthogonality. \nKala supports all three dimensions in a straightforward manner, and guaran- tees their orthogonality. \n10.1. Evolution Objects are organized along the evolution dimen-sion to record their change over time. \nThe motiva- tion is both referential (we should be able to inspect older versions of an object) and restoration \noriented (we should be able to restore older versions into cur- rent use). Conventional tools like RCS \nor sees implement such organizations. 9 In the more common case, the environment is constructed by \nassembling several shared baskets by placing them in the application s objects will be visible when the \naccess is done using the ikld, BSL. Their order determines which object vesions for each versioned ~U~WOU~~I \naddressing mode. Although Kala does not impose any particular versioning model, it supports versioning \nthrough the kin mechanism. Versioned objects correspond to kin, while an individual object version corresponds \nto a monad of that kin. Version group objects are objects that organize other objects by evolution. A \nversion group object is implemented as a monad containing both references to the monads, all of the same \nkin, representing various object versions, as well as change relation information (e.g., the evolu- tion \ntree or graph, or portions thereof). Version group objects can be versioned, too. The versioned object \n-> version group object map is not a one-to-one relation, due to the distributed and separable nature \nof The Kala Monadbase. Any Kala installation can be easily separated from others (for example, by partitioning \nthe network or by removing the diskette that holds the Kala store), and thus new object versions may \nbe independently gen-erated. The universal uniqueness of Kala s mids guarantees that akin version group \nobjects can indeed be merged without ambiguity. A particular versioning model, implemented through the \nstructure of and operations around ver- sion group objects, is the domain of a software layer above Kala. \nThis reflects the higher level semantic nature of such models. 10.2. Membership Objects are organized \nalong the membership dimension to express semantic relationships among them. This is mainly motivated \nby the complexity of common software repositories. This organization is conventionally supported by file \nsystems (e.g., the Unix directory, the Macintosh Finder s folder) and software environment tools (e.g., \nDSEE s library, NSE s component). Since organization along this dimension reflects higher level semantics, \ndirectory objects are imple- mented by a layer above Kala. The directory facility implements a function \nfrom names to identifiers, mapping human-oriented names of arbitrary syntax (e.g., textual, iconic) to \nsoftware-oriented identifiers (e.g., kids, mids). A directory is implemented as a data structure containing \nreferences into baskets, and it is stored as one or many monads, typically grouped into a single basket \nfor convenience and economy. 10.3. Composition Objects are organized by composition to express compound \nsoftware entities, such as modules and subsystems, and to construct derived objects, such as executables, \nlibraries, formatted help text, and published manuals. This organization is supported by conventional \nsoftware building tools (e.g., Unix make, DSEE s builder). Configuration objects are implemented as Kala \nbaskets containing handles to the monads which rep- resent the object versions. Configurations can be \nstored as recoverable baskets or basket snapshots. The builder tool accesses the needed source frag- \nments exclusively through the configuration (corresponding to accessing a kin via a specific bas- ket), \nguaranteeing that the correct object version will be used. Archival configurations (i.e. configurations \nthat reflect historical states of a released product, which are to be protected against any further change) \nare accomplished by freezing the entire basket and keep- ing the freezer very private (e.g., accessible \nonly by some administrator or by nobody). Alternatively, a single basket can represent the current configura- \ntion, and basket snapshots can be used to represent archival configurations. Floating co@gurations (i.e. \nconfigurations which are fixed as to what versioned objects they contain, but not as to what object versions \nare used) can be represented using baskets with indirect handles. An indirect handlelo is a handle to \nyet another handle whose resolution leads to the desired monad. A static indirect handle is an indirect \nwhere the basket containing its target handle was bound at its creation. To represent a configuration \nto the latest version of some or all of its constituent 10 Indirect and thunk handles are two kinds of \nhandles which enrich Kala s expressive power. Additional kinds of handles are treated in detail in [6]. \n241  objects, or to Bill s version of some or all of its objects, one uses baskets containing static \nindirects for each of the objects the latest version or Bill s version contains. The target baskets of \nthese indi- rects represent the latest or Bill s working context. Computed configurations (i.e. configurations \nwhose version object membership is determined, but where some or all object versions are computed on \nthe fly ) are represented using baskets with thunk handles. A thunk handle is a handle to a monad whose \nvalue can be computed at load time. Both indirects and handles are explained in detail in [6]. 10.4. \nA Simple Example Let s take two versioned objects VOI and V02 (see figure 8). Version Group Object VGOI \nrepre-sents the evolution of VOI , while VG02 represents VO2 s evolution. VGOI is distributed; it is \nrepre- sented as two monads: VGOI a and VGOI b. This means that at a certain point, versions of VOI were \ngenerated from an object version passed to a server that was subsequently disconnected. VG02 is not distributed; \nit contains V02 s entire history. The icons representing the version group objects show possible structuring \nof their versions in trees. VGOlo VGOlb VG02 nnn Figure 8: Simple example of Configuration Representations \n Two configurations are illustrated in the figure: CO1 and CO2. They are both represented by bas- kets. \nCO1 presents the world as containing VOI s third version and V02 s third version. co2 pre-sents the world \nas containing VOI s second version and VO2 s third version. Finally, a section of a dictionary data structure \nshows mappings between the strings module1 .c and module2.c , and the two versioned objects. This mapping \nis done via a basket containing two indirect handles. The figure shows a situation where the indirects \nare all resolved with handles in the CO2 basket. At a later time, the resolution may be changed to use \nCO1 instead. Switching configura- tions presents a different view on the software repos- itory. 11. BASKETS \nAND ACCESS CONTROL Access control is the mechanism used by data and object management systems to prevent \nunauthorized access to the managed data and objects. In this sec- tion, we briefly illustrate Kala s \nsupport for control- ling access to persistent data. 11 .I. Allowing Access Although a monad s value \ncan be proximately accessed either via a handle or via a reference from another monad, its ultimate accessibility \nby a Kala client is determined by the presence or absence of a handle to it in a transitively accessible \nbasket. In other words, a monad is accessible by a client iff the client has at least one basket containing \na handle to that monad or transitively to a monad which refers to it. This accessibility rule leads to \nthe idea of controlling monad accessibility by controlling the baskets accessible to a client. Upon attaching \nto a Kala installation, a client spontaneously receives several baskets in its space. These baskets are \nplaced on its BSL in a certain order. The set of initial baskets are determined in part automatically, \nand in part by the Kala installa- tion administrator. The baskets in the initial accessed basket set \nrep-resent entry points into an accessibility graph. The client can extend its accessed basket set by \ntransi- tively accessing persistent baskets which have handles in the currently accessed baskets. The \ntotal- ity of baskets that can be transitively accessed in this fashion is termed the accessible basket \nset. The Monadbase s persistent baskets can be viewed as organized in a dependency graph. Access control \nis thus realized by partitioning this graph, and offering each client an initial accessed basket set \ncontaining only baskets in permissible partitions. Kala s administrative interface provides operations \nfor associating the operating environment s identifi-cation notions with initial accessible basket sets. \nThere are also default provisions for a small set of baskets to account for very general notions, such \nas the Public Basket (analogous to /tmp in Unix prac- tice), or the User Basket (analogous to -user in \nUnix practice). The accessed basket set is also dynamically aug-mentable through the basket providing \nmechanism (cf. $7.1). This access management method avoids the use of conventional access control lists, \nwhich are known to be cumbersome and inflexible. The general graph nature of basket references permits \narbitrary access control structures with low overhead. 11.2. Preventing Access All Kala managed entities, \nsuch as monads, freez-ers, kin, and baskets, are specified by their identi- fiers, such as mids, fids, \nkids, and bids. The Kala server keeps track of all identifiers known by each of its attached clients. \nA Kala client which supplies a fabricated bit pattern as an identifier can never obtain access of a monad \nor basket which couldn t have been accessible otherwise. Kala identifiers are unforgeable. Consequently, \nunless a client can obtain an identifier through legal means, it can never access a basket or a monad \nl. 12. IMPLEMENTATION Every client access to a monad must go through one or more baskets to determine \nthe monad s iden- tity and to verify its accessibility. Consequently, the basket implementation has an \nextraordinary impact on Kala s performance. The implementation today reflects the evolution of increasingly \nsophisticated data structures and algorithms. In the present Kala 2.0 implementation, basket overhead \nhas been reduced to a trivial part of the i/o and data copy l1 Kala does not attempt to compensate for \nany security loopholes the operating system or the hardware may already have. Thus, forceful and knowledgeable \nintrusions into Kala server process memory can lead to security breaches. costs inherent in any data \nmovement. In effect, the basket mechanism and the functionality it presents are free to the user. 12.1. \nRequirements This zero cost has been achieved by careful exam- ination of and accommodation to the following \ncharacteristics of basket usage: Basket volume varies widely. Most baskets remail empty12, and are discarded \nwithout ever contain- ing any handles. Most of the remaining baskets are used to implement some transaction \nmodel and will hold less than a dozen handles, and will be empty when discarded. The remaining small \nfraction are persistent baskets. They will hold from tens to tens of millions of handles. There is a \nhigh locality of reference to handles, both within and across applications and transac- tions. Most handles \nwill be for monads created by the installation which also holds the basket con- taining the handle, as \nwill the bulk of those mon- ads. Most handles will never be frozen. Many kin have only a single monad \never created of that kin. Lookup within a basket is by kin (cf. Kala s Cen- tral Dogma). However, the \nensuing fetch from disk requires information which is unique to the particular monad, not per kin. In \naddition, handles for the same monad can appear simultaneously in many baskets. Replicating per-monad \ninformation in each handle would be expensive, and present problems for consistency maintenance when \nsome baskets exist as snapshots. While Kala s multi-threading may overlap regular disk and communications \npacket i/o with server processing, it cannot overlap with i/o resulting from page faults. 12.2. Implementation \nOutline The basket implementation collects all per-monad information for every monad resident in a Kala \ninstallation into a single per-server object, termed the KulQ Map. The per-monad Kala Map informa- tion \nincludes reference counts, disk addresses, kin 12Certain baskets are spontaneously generated by the system \nat each application s start, for convenience. Most of them never get used by most executions, and thus \nremain empty.  243 identity -all searchable by mid. The Kala Map implements a mid-to-kid function. Baskets, \non the other hand, implement a kid-to- mid function. The basket handles contain only mid, kid, and freezing \ninformation. The kin membership of a monad is static at creation, and freezing status is per-basket and \ncan change only in accessed and application-referenced baskets. Consequently, no information can change \nin a basket snapshot, and there are thus no consistency maintenance problems. A kin-based request results \nin the examination of one or more baskets. The resulting mid is then applied to the Kala Map to yield \na disk address or other monad attribute. Basket searches by mid first use the Kala Map to get the corresponding \nkid, fol- lowed by normal kid-based basket searches and a check to confirm that the handles found are \nfor the desired mid. Kala s implementation was carried out under the assumption that memory is cheap, \nbut page faults arc expensive. This led to an emphasis on reducing the size of key data structures, particularly \nthe Kala Map and the baskets, Many baskets have their size reduced to the ultimate: they are not there \nat all. Dynamically created transient baskets, such as the process and failed baskets which appear sponta- \nneously when an application attaches to a Kala server, are not physically created until the first handle \nis inserted. While most baskets that actually have contents will have very few handles during their lifetimes, \nmost handles will reside in a small number of very large baskets. This dichotomy is addressed by actu- \nally providing two different implementations of bas- kets: one is optimized for low access overhead to \nsmall baskets, and the other for efficient reference to large baskets. Baskets are first created with \nthe first implementation, and are automatically converted to the second after as they grow in size. Small \nbaskets are organized as linearly linked lists of hash tables, initially quite small (10 entries). When \ninsertions bring the top table to about 70% full, a new larger table is created and linked to the front \nof the list. Search is from the front of the list, probing in each table in turn. If a search locates \na handle in a table not at the front, the handle is pro- moted to the front table. This process, along \nwith deletions, gradually empties the rear tables, which are periodically consolidated with adjacent \ntables to constrain the list length. Due to locality of reference, most handles are found in the front \ntables, which thereby tend to stay in the server s memory working set, and thus page faults are rare. \nLarge baskets are implemented as quasi-balanced n-ary trees of tables. The search is globally recur- \nsive, and binary within a table. Table size and alignment are set to the underlying architecture s memory \npage size and alignment. The expectation is that the root and the first layer of tables will remain resident \nin a server s memory (around 0.5 megabyte for typical page sizes). Thus, a single page fault will return \na desired handle from a basket containing up to 10 million handles. In addition, special tech- niques \ncan commonly determine without actual search that the desired handle cannot be in the bas- ket, making \nit unnecessary to waste page faults in large baskets when more than a single basket is to be checked. \n12.3. Further Optimizations In the general case, a single handle occupies 24 bytes: three &#38;byte identifiers \nfor the monad, kin, and freezer. In reality, the implementation replicates the data structure three times \nat different sizes to exploit regularities in the usage patterns. First, since handles are rarely frozen, \nthe fid field is generally unnecessary. Secondly, since most kin and monads are created by the server \nwhich also maintains the basket, the portions of the mid and kid which identify the creating servers \nare also often not necessary. Lastly, since most kin only get one monad of that kin, Kala gives the first \nmonad in the kin a mid which is bitwise the same as its kin s kid. Thus, it is often unnecessary to record \nboth the kid and the mid. The combination of the three special cases above leads to a tripartite data \nstructure for a basket: one with 24-byte entries, one with &#38;byte entries, and one with 4-byte entries. \nThe remaining possibilities have not appeared to be common enough to warrant complicating the already \ncomplex structure mainte- nance algorithms. 12.4. Results Space limitations of this article prevent \na discus- sion of Kala s space and time performance results; this topic is discussed at length in [2]. \nTiming mea-surements for the large (200,000 parts) Cattell database [l] show that basket operations consume \nless than 5% of total processor time. This and other benchmarks have shown that Kala s time perfor- mance \nis determined entirely by disk and network bandwidths. For the same benchmark database, the basket information \noccupies about 80 kilobytes, compared to the 20 megabytes occupied by the 200,000 parts themselves. 13. \nCONCLUSIONS Baskets have proven to be a very versatile and at the same time economical mechanism. Their \nimplementation within a low-level architectural component offers object-based systems a wide range of \noptions to address transactions, access control, and configuration management in a simple, uniform manner. \nBaskets can also be used to model dynamic multi-level defaulting mechanisms (e.g., for user profiles), \nas well as static and dynamic scoping in programming languages with persistence. BIBLIOGRAPHY [II Cattell, \nR.G.G. and Skeen, J., Engineering Datubuse murk, Sun Microsystems Report, April 1990. Bench- PI Godard, \nIvan and Simmel, Performance, in progress. Sergiu S., K&#38;is Space und Time [31 Gustavsson, Anders. \nSoftware Conjigurufion an lnfegruted Environment, Lund University TR:90-52, Malmo, Sweden. Munugement \nin Report LU-CS- 141 Leblang, D., Chase, R., and McLean, G., The DOMAIN So&#38; ware Engineering Environmentfor \nLarge Scale Development Eflorts, 1st Int l Conference on Computer Workstations, 1985. [51 Moss, J. Eliot \nB., Design Sfore, ACM Transactions of the Mneme Persistent Object on Information Systems, 1990. 161 Simmel, \nSergiu S., Kulu - Muin Concepfs, Samsung Software America, Inc. and Penobscot Research Center, Inc. Report, \nversion 1.00, June 1990. [71 Simmel, Sergiu S., Kulu Interface Reference, Samsung Software America, Inc. \nand Penobscot Research Center, Report, version 1.00, August 1990. Inc. 181 Slmmcl, Scrglll S., and (hdard, \nIvan,Kulu'sSupporffor 7ion.vocrion Model., , in progress. 191 Solcy. Klchard Mark (cd.), Objecf Munugement \nArchifecfure (;uriie, Object Management Group, O.M.G. TC Document 90.9.1, Version 1.0, 1 November, 1990. \nIlO1 Thompson, Craig et.al., Open Archifecfure for Object-ori- ented Dufubuse Systems, Texas Instruments \nIncorporated, Technical Report #89-12-01(2), 1989. 1111 Tichy. Walter, Tools for Sofwure Configuration \nMunuge- menf, Int l Workshop on Software Version and Configuration Control, 1988 Grassau, West Germany. \n[I21 Ullman, Jeffrey D., Principles of Database Systems, Computer Science Press, 1982. 1131 Wang, Chung \nC., A Struwmun Reference Model in Trunwc- fion Processing for an Object Oriented Dotabuse, Texas Instruments \nIncorporated Report, 1990. [I41 Wile, David S. &#38; Dennis G. Allard. Worlds: Aggregutes for Object \nBuses, USC/Infotmation Sciences Institute, 1988. APPENDIX The following is a selection of relevant declara- \ntions from Kala s main ANSI C application pro- grammatic interface (API), given here to illustrate the \nnature of the interface, rather than to specify it. Due to space limitations as well as their implemen- \ntation dependent nature, the typedef declarations were left out. bid AccessBasket(mid, bid); T Causes \nIhe basket monad at <mid, bid> to be loaded and returns its bid 7 rowBid Baskets(bid); P Returns a row \no/a// baskef ids corresponding to the supplied bid, in search order for multi-basket bids. / void BasketSearchList(rowBid); \n / Replaces the default basket search /i.st with the has kets m the row. 1 void CopyHandle (mid, bid, \nbid) ; P Afomicalty copies the hand/e(s) at <mid, bid> to fhe specified basket . / rowMonadSpec CopyBandles(rowMonadSpec, \n rowBid) ; T Afomrcally copies the handles at rowMonadSpec to the corresponding baskets and returns the \nrsolutions of fhe desfmafions. 1 pointer CreateBasketSnapshot(kid, bid, bid); P Creafes the basket named \nbid as a monad and a handle to it at <kid, bid>, and returns the mid. / 245 mid CreateDatum(kid, bid, \ns&#38;Address, rowRefPointer, range); I Creafes a monad and a band/e to /f al <kid, bid> whose value \nIS the confenfs ol memory described by the setAddress, confaming pointers as described by the rowRefPoinfer, \nwhich musf point to other monad values M memory defined by eifher previous Creates or Defines. If there \na/ready is a hand/e al <kid, bid>, that hand/e is rep/aced. 1 void DeleteBasket(bid); I Removes the \nbaskef from a// search lists. */ #define DeleteHandle(mid, bid)\\ MoveHandle(mid, bid, noBasket) P Discards \nKalab know/edge offhe hand/e(s) at <mid, bid>. / #define DeleteHandles(rowMonadSpec)\\ MoveHandles(rowMonadSpec, \nOnly(hnoBasket, bid)) p Discards Kala s know/edge of fhese hand/es. / void FreezeBasket(bid, fid); \n P Freezes the basket(s) from further change of any soIl until explicifly unfrozen, using /id asthe key. \n*/ void FreezeHandle(mid, bid, fid); I freezes the described hand/e-s in their baskets from furlher \nchange of any serf until explicit/y unfrozen, using lid as the key. / rowMonadSpec FreezeHandles(rowMonadSpec, \nrowfid); P Freezes the described hand/es in fheir baskets from fufther change of any sort until exp/icit/y \nunfrozen, using the corresponding fids as keys. / void FreezeKinInBasket(kid, bid, fid, duration, duration); \n T Locks the basket at (kid, bid) from stores by other processes in the indicafed kin. Raises exception \nLockNofGranfed i/the freeze cannof be granted before fhe firsf duration e/apse; Raises excepfion JlmedOufLock \nif ThawHandle for fhe same &#38;id, b/d> is not executed before the second duration e/apses affer the \ngranf. A// heezes granted or pending are removed when the caller exits. / fid FrozenBasket(bid); P \nRefums fhe lid which is the freezing key for fhe bas- ket, or thawed if nof frozen. / fid FrozenHandle(mid, \nbid); P Refums the fid which is fhe freezing key for the described handle, or fhawed if not hozen 7 \nvoid Load(mid, bid, transitivity, allocator); P Copies the value of the monad al cm/d, bid> lo appficafion \nmemory. If fhe monad was origins//y Created from a sing/e contiguous piece of memory then the Loaded \nimage will have the same structure.. 1 monadspec MakeBasketRecoverable(kid, bid, bid); T Nags bid as \nrecoverable, and stores a reference to if at <kid, bid>. returning the new mid 1 void MoveHandle(mid, \nbid, bid); T Performs fhe CopyMonad operation, and a/so in the same atomic operalion removes the hand/e \nhorn its former baskef. 1 rowMonadSpec MoveHandles(rowMonadSpec, rowBid); T Performs the CopyMonads \noperation, and a/so in the same afomicoperation removes the hand/es from their former baskets. / bid \nNewBasket(void); r Creates a basket, enters if on fhe BSL, and returns its id. Does not monadize if \n(see MakeSaskef-Recov-erable) 1 fid NewFreezer(void); / Generates a new unique freezer and adds if to \nthe freezer .... void ProvideBasket(bid, identity); P Adds that baskef to the 5% offhe client using \nthat identify. 7 rowMonadSpec ResolveHandle(mid, bid); T Atomically returns the resolutions of the <mid, \nbid> address7 rowMonadSpec ResolveHandles (rowMonadSpec) ; / Afom/ca//y returns fhe resolufions offhe \nrowMonad-Spec addresses. / #define ThawBasket(rnid, bid)\\ FreezeBasket (mid, bid, thawed) #define ThawHandle(mid, \nbid)\\ FreezeHandle(mid, bid, thawed) #define ThawHandles(rowMonadSpec)\\ FreezeHandles(rowMonadSpec, \nnilRow) void ThawKinInBasket(kid, bid); P Un/ccks a previous/y granfed FreezeKinlnBaskef . /   \n\t\t\t", "proc_id": "117954", "abstract": "", "authors": [{"name": "Sergui S. Simmel", "author_profile_id": "81100016670", "affiliation": "Oberon Software, Inc., One Memorial Drive, Cambridge, Massachusetts and Samsung Software America, Inc.", "person_id": "P262179", "email_address": "", "orcid_id": ""}, {"name": "Ivan Godard", "author_profile_id": "81392592266", "affiliation": "Star Semiconductor, Inc., 25 Independence Drive, Warren, New Jersey and Penobscot Research Center, Inc.", "person_id": "P117421", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/117954.117972", "year": "1991", "article_id": "117972", "conference": "OOPSLA", "title": "The Kala basket: a semantic primitive unifying object transactions, access control, versions, and configurations", "url": "http://dl.acm.org/citation.cfm?id=117972"}