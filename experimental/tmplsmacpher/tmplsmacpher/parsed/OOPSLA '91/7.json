{"article_publication_date": "09-01-1991", "fulltext": "\n WORKSHOP Phoenix, Arizona 6 - ff October 1991  Garbage Collection in Object Oriented Systems Organizers: \nPaul R. Wilson, Dept. of Computer Sciences, University of Texas Barry Hayes, Xerox PARC . . . we have \nthe ability to handle garbage more intelligently, using both emerging technologies and new and improved \nversions of older solutions . . . Mariette DiChristina How we can win the war against garbage Popular \nScience, October 1990, p. 57.  Overview This workshop consisted primarily of IO-minute presentations \nby researchers and software developers, interspersed with a few 20-minute presentations and a panel discussion \non conservative vs. accurate approaches to garbage collection. While the format was partly due to our \nindecisiveness in selecting the best papers for presentation, it also reflected the generally good quality \nof accepted papers and the high standard of background knowledge among the participants. We got several \ncomments to the effect that the lo- minute slots were just right, because nearly all of the attendees \nhad sufficient background that little preparatory explanation was needed-speakers could quickly get to \nthe novel and interesting points of their papers*. Future workshop organizers might want to take the \nsuccess of this format into account. * We also adjusted the ordering of the talks to present related \ntopics together, and many of the presenters conferred to make sure their presentations were not too redundant. \nIn fact, some people thought this made the few 20-minute slots a shade too long. Given the pleasant result \nof this self-organizing anarchy, we present the workshop report in much the same spirit-we are mostly \npresenting the abstracts of the accepted papers and panelists positions. The ordering below is roughly \nthe one in which papers were presented. (A few papers weren t actually presented, but we include their \nabstracts here.) Full versions of most of the presented papers are available in PostScript form via anonymous \ninternet ftp from cs.utexas.edu, in the directory pub/garbage/GCg 1. Papers from the first workshop (organized \nby Eric Jul and Niels-Christian Juul) are in pub/garbage/GCgO. We are also compiling a bibliography which \nwill be made available there. We would like to thank all of the participants in the workshop, including \nour special invited guests David Chase (of Sun) and Andrew Koenig (of AT&#38;T), and our panelists Joel \nBartlett, Hans Boehm, and Eliot Moss.  Morning Session Abstracts On Multi-Threaded List Processing and \nGarbage Collection Wolfgang Kuechlin and Nicholas Nevin Dept of Computer and Information Science The \nOhio State University Columbus, Ohio 43210-1277, U.S.A. {keuchlin,nevin}@cis.ohio-state.edu. We discuss \nthe problem of parallel list-processing based on threads of control, such as Mach s C Threads. Our main \ninsight is that the threads paradigm and the use of a standard threads system suggests a heap memory \nlayout and garbage collection technique which is quite different from existing Lisp and Prolog Systems. \n OOPSLA 91 [331 A High-Performance Architecture for Real-Time Garbage Collection Kelvin Nilsen Dept. \nof Computer Science Iowa State University Ames, IA 50011 (5 15) 294-2259 kelvin@cs.iastate.edu uunet!atanasoflfkelvin \nHardware-assisted garbage collection offers the potential of high average-case allocation rates and memory \nbandwidth, with very low worst-case allocation, fetch, and store times. This paper describes an architecture \nthat allows memory fetch and store operations to execute, on the average, nearly as fast as traditional \nmemory. The architecture is high-performance in that it includes support for caching of garbage-collected \nmemory cells. The architecture is real-time in that the worst- case time required for a memory fetch \nor store is approximately six traditional memory cycles, and the time required to allocate an object \nis bounded by a small constant times the size of the object. A prototype of the proposed architecture \nhas been successfully simulated. Continuing research focuses on measuring the system s performance under \nreal workloads. How Real is Real-Time GC? P. T. Withington Symbolics, Inc. Eight New England Executive \nPark Fast Burlington, MA 01803, U.S.A. ptw@Jasper.SCRC.Symbolics.COM A group at Symbolics is developing \na Lisp runtime kernel, derived from its Genera(R) operating system, to support real-time control applications. \nThe first candidate application has strict response-time requirements (so strict that it does not permit \nthe use of paged virtual memory). Traditionally, Lisp s automatic storage-management mechanism has made \nit unsuitable to real-time systems of this nature. A number of garbage collector designs and implementations \nexist (including the Genera garbage collector) that purport to be real-time , but which actually have \nonly mitigated the impact of garbage collection sufficiently that it usually goes unnoticed by humans. \nUnfortunately, electro-mechanical systems are not so forgiving. This paper examines the limitations of \nexisting real-time garbage collectors and describes the avenues that we are exploring in our work to \ndevelop a CLOS-based garbage collector that can meet the real-time requirements of real real- time systems. \n[64 1 9-11 October Automatic Storage Management for Systems with Real Time Constraints Stephen Engelstad \nmarvl @iexist.att.corn and James E. Vandendorpe AT&#38;T Bell Laboratories Naperville, IL 60566 A garbage \ncollector programmed in C reclaims objects by executing during the allocation of new objects. After a \ndynamically scheduled number of object allocations the application is delayed while lost resources are \nrecovered. The average delay is 6 ms on a Sun3 and 2 ms on a Sun4 with a worst case delay of 10 ms on \nboth. To achieve these results we refined the generational algorithm published by Carl Hewitt and Henry \nLieberman. Our algorithm is implemented within the Calico programming system. Comparing Two Garbage Collectors \nDouglas Johnson Texas Instruments MS 369 P.O. Box 655621 Dallas, Texas 75265 johnson@ti.com Based on \nan experiment comparing two garbage collection algorithms on a large, long-running Lisp program, we find \nthat a simple, two generation stop- and-copy collector is equal or superior to a complex, multigenerational \nincremental collector in every measured area except paging performance in limited physical memory sizes. \nThe major conclusion from this experiment is that it is difficult to justify the cost of complex incremental \ncollectors unless they are used to optimize paging performance via object reordering. However, there \nare interesting classes of programs that can get significant benefit from such optimization. Simple GC-Safe \nCompilation Hans-Juergen Boehm Xerox PARC 3333 Coyote Hill Road Palo Alto, California 94304, USA boehm \n@Xerox. corn We propose that C compilers (and translators from future standard intermediate languages) \noptionally produce code that guarantees safety in the presence of a conservative garbage collector. It \nis argued that this is essential, and that it should have negligible 1991 Phoenix, Arizona impact on \nobject code performance. It is easy to specify what is required of the compiler. The necess<ary ch anges \nto the compiler are independent of the original source language, be it C itself, or another language \nthat is compiled to C. The UMass Language Independent Garbage Collector Toolkit J. Eliot B. Moss Department \nof Computer Science University of Massachusetts Amherst, MA 01003 moss@ cs. amass. edrl At the OOPSLA/ECOOP \n90 workshop on garbage collection Rick Hudson and Amer Diwan presented a scheme for flexible scavenging \nbased on a varying number of fixed size generations. We have since developed a new scheme that we believe \nis even more flexible. The sizes of generations can vary, as well as the number of generations, and we \nprovide very efficient age-based promotion using no age counters or high water mark tests. In addition, \nwe have implemented the scheme in such a way as to separate language specific parts (e.g., details of \nlocating roots for a scavenge) from language independent components. The result is a toolkit that substantially \nreduces the effort in supporting scavenging in new language implementations. Stack Tracing In a Statically \nTyped Language Amer Diwan Object Oriented Systems Laboratory Department of Computer Science University \nof Massachusetts Amherst, MA 01003 (4 13) 545-0256 diwan 0 cs. amass. edu Statically-typed languages \nsuch as Modula-3 provide many opportunities to mitigate the costs of garbage collection. Compiler generated \ntables can assist the collector in locating the root pointers and in updating them when objects are moved. \nThis obviates the need for run-time tags in the stack and offers substantial performance improvements. \nIn this paper, we describe some key issues that need to be addressed before we have an efficient stack \ntracing scheme. We also describe our solutions to these problems in the context of Modula-3. Main Memory \nManagement for Persistence Antony Hosking Object Oriented Systems Laboratory Department of Computer and \nInformation Science University of Massachusetts Amherst MA 01003 hosking @cs. umass. edu Reachability-based \npersistence imposes new requirements for main memory management in general, and garbage collection in \nparticular. After a brief introduction to the characteristics and requirements of reachability-based \npersistence, we present the design of a run-time storage manager for Persistent Smalltalk and Persistent \nModula-3, which allows the reclamation of storage from both temporary objects and buffered persistent \nobjects. Finalization in a Garbage Collected World Richard L. Hudson Research Associate University Computing \nServices University of Massachusetts at Amherst hudson @ cs. umass. edu With the advent of object oriented \ntechnologies, data structures have become more complex and the tradition of relying on programmers to \nexplicitly deallocate objects has become tenuous. To relieve the programmer of the increasingly intractable \nproblem of detecting references that have expired, modem run-time platforms use garbage collection to \nhelp manage memory. However, before an object can be deallocated, it is sometimes necessary to execute \na finalization routine associated with the object. Such a routine might include closing an open file \nor informing the windowing system that a window is no longer needed. In some languages, the only way \nto free storage is to execute finalization routines that explicitly deallocate the object. On the other \nhand, garbage collection algorithms automatically detect when objects are no longer needed. This frees \nthe user from having to deallocate storage explicitly in a finalization routine, but does not address \nthe problem of executing finalization routines that have other responsibilities. In this paper, we propose \nsemantics to extend finalization to include garbage collected objects. Inthe context of a type accurate \ngenerational garbage collector, we describe an implementation strategy that allows finalization to be \nperformed concurrently with the user s threads. Outwitting GC Devils: A Hybrid Incremental Garbage Collector \nDavid Ungar and Frank Jackson ParcPlace Systems, Inc. 1550 Plymouth St. Mountain View, CA 94043 David. \nUngar@sun.com Jackson@parcplace.com No garbage collector is perfect, and it is possible to invest a great \ndeal of effort in a particular design of a collector before the extent of its weaknesses become apparent. \nEven large benchmarks may fail to expose a flaw that can interfere with attaining acceptable performance \nfor other application programs. Designers need to build collectors that exhibit robust behavior in the \nface of a wide variety of application program allocation and reclamation patterns. In order to focus \non this goal, it helps to imagine an adversary who writes application programs with the specific purpose \nof confounding the garbage collector. In fact, in developing a collector for a commercial product, we \nfound that this was more than a conceptual device; users did (unwittingly) construct some programs that \nexhibited peculiar behavior which caused an early version of our collector to fail. As a result, we implemented \na hybrid collector combining Generation Scavenging, with an incremental mark- sweep algorithm. Its design \nwas influenced by the desire to avoid potential pathologies. Users report satisfaction with the new collector. \nWe are waiting to see what its pathologies may be. Garbage-Collection Bugs That I Have Known Frank Jackson \nParcPlace Systems 1550 Plymouth Street Mountain View, CA 94043 (415) 691-6710 jackson@parcplace.com . \n This paper takes a light-hearted look at some of the more unusual bugs that have bedeviled the three \ngenerations of automatic memory managers for the Smalltalk-system. These bugs are worth revisiting for \nthe following reasons: 1. Because it can be instructive to examine the kinds of problems that are uncovered \nwhen a memory manager that seems to work perfectly well in the lab is actually put to the test by real \nusers running real applications; and 2. Because such bugs often occur in precisely those areas where \nthe technology is evolving at the most rapid pace. The specific areas of automatic memory management \nthat are examined in this paper include: weak pointers, finalization, hybrid memory managers, and adaptive \nstorage-reclamation algorithms. Those bugs that are discussed include: the Reincarnation Bug, the Resurrection \nBug, the problem of Premature Finalization, and the Pig-in-a-Python phenomenon. The Myth of High Object \nAllocation Rates Urs Hoelzle Computer Systems Laboratory, CIS 57 Stanford University Stanford CA 94305 \nurs@self:stanford.edu Garbage collector designs are often motivated by the high allocation rates displayed \nby the system for which the collector is intended; this furious object creation rate is accepted as a \ngiven. I argue that a promising way to reduce the GC overhead is to reduce the amount of garbage produced, \ni.e. to lower the allocation rate of the system. Garbage prevention should be an integral part of any \nsystem using garbage collection, and the potential gains of compiler optimizations aimed at reducing \nthe allocation rate could well outweigh the gains achievable by just tuning the garbage collector. Some \nmeasurements of the Self system are used to illustrate this point. Cost of Garbage Collection in the \nSelf System Craig Chambers Department of Computer Science ald Engineering, IX-35 University of Washington \nSeattle, WA 98 195 chambers@cs.washington.edu Differences in the overhead of garbage collection for different \nsystems stem from differences in the language implementation technology and in typical programming style. \nUngar reports remarkably low overheads of 2-3% for Generation Scavenging in Berkeley Smalltalk and SOAR, \nbut these Smalltalk systems had relatively unoptimized language implementations relative to traditional \nlanguages and fostered high object allocation and death rates relative to traditional languages. Self \nprovides a new data point in this matrix: an optimizing language implementation combined with high object \nallocation and death rates. Optimizations in the Self system both dramatically speed up normal program \nexecution compared to Smalltalk systems and reduce the object allocation and death rates by optimizing \naway many closure creations. We measured the overhead of garbage collection in Self on four large benchmarks \nand found overheads ranging from 4% to 27%. Interestingly, store checking consumes a major fraction of \nthis overhead. Panel Discussion: Conservative vs. Accurate Garbage Collection Hans Boehm By conservative \ngarbage collection we mean garbage collection in the presence of values for which it is not known whether \nor not they are pointers. There are various degrees of conservative garbage collection depending on how \nmuch pointer information is known. For example, the layout of heap allocated objects may be known, while \nstack layout may not be known. Garbage collectors that accommodate a high degree of conservatism, i.e. \nthat can operate with minimal pointer location information are currently desirable for two reasons. First, \nnew code that relies on garbage collection should interoperate correctly with traditional C code. Thus \nthe garbage collector must be able to understand references from C data structures. Second, new programming \nlanguage implementations increasingly compile to C to obtain both portability and access to machine dependent \noptimizers that were built with an (often proprietary) understanding of hardware timing. This makes it \ndifficult or impossible to provide data structure layout information to the collector. Even very conservative, \nuonmoving garbage collectors can provide performance that is often better than malloc/free performance, \nand competitive with other kinds of collectors. They may, on rare occasions, retain noticeably more unreachable \ndata than other types of collectors. But essentially no existing garbage collector provides guarantees \non what storage will be reclaimed. Conservative garbage collectors impose some minimal requirements on \ncode optimizers, but these can be easily standardized, and are independent of the original source language. \nJoel Bartlett The terms accurate and conservative are an attempt to put black and white labels on a gray \nscale that measures the amount of information that the garbage collector has to work with. People don \nt build conservative collectors because they re lazy, sloppy, or have loose morals. They build them because \nthey wish to provide garbage collection in inhospitable environments. When faced with the choice of not \nenough information at runtime, or a GC unsafe language, one can abandon the implementation, or use conservative \ntechniques. As I m interested to bringing garbage collection to more users, I do the later. At WRL, we \nhave used mostly-copying garbage collection to build an efficient, portable Scheme-to- C compiler, Scheme-X \nand over 40,000 lines of CAD tools in C++. In spite of the fact that it s easy to demonstrate how conservative \ntechniques can cause memory leaks, our experience is that this is a rare occurrence in production programs. \nChallenges for the future include convincing others that conservative collection is preferable to bare-handed \nallocation and that code generators should preserve the minimal invariants required by conservative collectors. \nEliot Moss Comment: I think it should be pointed out that fully conservative mark-sweep GC s are conservative \nabout pointers between heap objects as well as roots. In order to understand my position on garbage collection \nstrategies, it is useful to see my taxonomy of the strategies. There are ambiguous roots collectors (frequently \ncalled conservative because they must assume a quantity is a pointer unless proven otherwise) and unambiguous \nones. Ambiguous roots collectors are simple in the absence of certain compiler optimizations, but making \nlanguage implementation gc-safe requires additional analysis in the compiler, and will sometimes affect \nthe object code (e.g., to retain base pointers that would otherwise be considered dead). Unambiguous \nroots collectors need at least to know the types of most things, hence they are predicated on type accuracy. \nFor good performance, one can avoid tagging pointers at run-time, at the expense of additional compiler \nwork and space consumed by tables. The compiler s analysis can be increasingly refined, striving towards \nperfect precision (knowing exactly what is garbage and what is not), which is undecidable. My main point \nis that once you go to the effort of enhancing a compiler to make its output gc-safe, you might as well \ngo the extra mile of supporting type accuracy. The improved accuracy avoids the accidental retention \nof space that sometimes happens with ambiguous roots collectors, but more importantly, type accuracy \nallows objects to move, and thus allows a wider range of gc strategies, especially compaction. This is \nimportant in our work on persistent programming languages, but my position is that it is also important \nin the absence of persistence. Thus, I hope that conservative collectors will only be a stop-gap until \nbetter techniques are deployed. (Note: we have indeed developed the necessary compiler technology for \nour Modula-3 implementation.) In my view, these are the issues, whether or not you agree with my position: \nAccuracy: How much garbage does the collector fail to reclaim? Optimization: Which compiler optimizations \nmay cause the collector to fail? Ambiguity: Can objects move? Can the collector and run-time distinguish \npointers from non-pointers? Effort: How much implementation effort is required? The only issue on which \ntype accurate collectors are not strong is implementation effort, and we argued above that the effort \nrequired is only a little more than that needed for gc-safety, so type accuracy should be our goal. David \nChase There is an interaction between optimizing compilers and garbage collectors-good optimizers can \ndo an arbitrarily amazing job of hiding pointers (stored in registers, not in the heap) from the garbage \ncollector. There is no part of the C or Fortran or C++ specifications that tells compilers not to do \nthis, and market pressure encourages compilers to do this. The RS/6000 compilers are known to do this \ntoday, and I observed Sun s F77 compiler do this in 1988. Do understand that these are not interior pointers-these \nare typically encodings of the form p - K (to which K is added to reconstitute the p ) or p2 - pl (to \nwhich ~1 is added to reconstitute p2 ). Bartiett s conservative collector goes a long way in solving \nthis problem, but to be sure, some optimizer support is also required. For languages that interoperate \nwith C, one must also beware of routines in the C library that return derived (interior) pointers based \non their parameters. Side comments: This doesn t really belong here, as part of the conservative vs. \naccurate debate . . . bitt maybe we should have a discussion section that includes-Ungar s comment that \n 168 I 9-11 October conservative mark-sweep is bad because it doesn t compact-My response (that it s \nprobably not as important as you might think because the real problem is deferred reuse of memory, no \nmatter how ~014 slice it) and so on. Chase responded to that, I think . . . I d pointed out that copying \ngc s give you niceEinear allocation, but even that may happen with a good mark-sweep that uses bitmaps \nfor allocation and can usuallyfind significant runs offree memory due to locality in object creations \nand deaths, cf: Hayes 91 . . . On another note, I think that prefetch instructions for some forms of \ncache management (see the i860 pipelined load instructions, or recent papers in ASPLOS) may have interesting \nusesin garbage collectors, and should be investigated. One reason this is a good hardware feature to \nexploit is that it is useful for Fortran, and thus will probably become widely available (as opposed \nto hardware features designed to support less-popular languages).  Afternoon Session Abstracts Standardizing \nMemory Management Descriptions Alan M. Durham and Ralph Johnson Department of Computer Science University \nof Illinois Urbana-Champaign durham@cs.uiuc.edu This position paper describes my research on describing \nmemory management to an optimizing compiler. The goal is to make optimizing compilers for languages like \nSmalltalk easier to retarget to new memory management systems. The Treadmill: Real-Time Garbage Collection \nWithout Motion Sickness Henry G. Baker Nimble Computer Corporation 1623 1 Meadow Ridge Way Encino, CA \n9 1436 (818) 501-4956 (8 18) 986- 1360 FAX A simple real-time garbage collection algorithm is presented \nwhich does not copy, thereby avoiding some of the problems caused by the asynchronous motion of objects. \nThis in-place treadmill garbage collection scheme has approximately the same complexity as other non-moving \ngarbage collectors, thus making it usable in a high-level language implementation where some pointers \ncannot be 1991 Phoenix, Arizona traced. The treadmill is currently being used in a Lisp system built \nin Ada. Garbage Collecting an Object-Oriented Operating System Kernel Vincent F. Russo Department of \nComputer Science Purdue University West Lafayette, IN 47907 rlcsso@cs.prrrdr4e.edu As part of the Renaissance \nproject at Purdue University, we are investigating the feasibility of garbage collecting an actively \nrunning operating system kernel. In this paper, we discuss the algorithm we have adapted to our needs, \nalong with the techniques we use to support garbage collection in C++ (the object-oriented language in \nwhich we have coded our system). Towards User (Application) Language-Level Garbage Collection in Object-Oriented \nConcurrent Languages Masahiro Yasugi and Akinori Yonezawa Department of Information Science University \nof Tokyo yonezawaOis.s.u-tokyo.ac.jp We are implementing object-oriented concurrent languages on highly-parallel \ncomputers without shared memory.Our approach to GC is to translate a user program (which is written in \nan object-oriented concurrent language) into the user program with GC which is also written in the object-oriented \nconcurrent language. In this approach, the runtime routines for GC is not required when we implement \nlanguage systems. We will present an example of GC schemes aimed at user-language-level general GC. To \nillustrate the example, we will also give a general definition of garbage in terms of groups. Parallel \nConservative Garbage Collection with Fast Object Allocation Shinichi Furusou, Satoshi Matsuoka, and Akinori \nYonezawa Department of Information Science The University of Tokyo 7-3-1, Hongo, Bunkyo-ku, Tokyo, 113 \nJAPAN Phone +81-3-3812-2111 ext. 4108 furuso@is.s.u-tokyo.ac.jp matsu@is.s.u-tokyo.ac.jp yonezawa@is.s.u-tokyo.ac.jp \nConservative Garbage Collection (GC) algorithm provides garbage collection independent of programming \nlanguages and applications, but is difficult to extend naively into a concurrent algorithm, where allocation \nspeed of up to one million objects per second per thread is required. Our parallel conservative GC is \na p arallel and real-time conservative GC algorithm, whose allocation and collection can be done almost \ntotally in parallel without the need for synchronization or mutual exclusion. Results derived from proof \nof correctness of the algorithm allows object allocation to be done totally distributed and parallel, \nso that the allocation cost is estimated to be as little as 13-15 instructions per object allocation, \nincluding the overhead of (rare) synchronization. The preliminary version of our algorithm is already \nrunning on a 4- processor LUNA-88K with Mach 2.5. Our algorithm relies on the availability of virtual \nmemory primitives to the user in order to maintain the necessary invariants of the collector. A System \nModel of Memory Management Robert MacLachlan Department of Computer Science Carnegie Mellon University \nRoD.MacLachlan@cs.cr~~~r.ed~r As both memory systems and memory managers become more complex, it is increasingly \nimportant to develop a unified framework for examining the interaction between memory system hardware \nand memory management software. This paper explores one possible connection. Garbage Collection in C++ \nPaul0 Ferreira INESC/IST R. Alves Redo1 1000 Lisboa, PORTUGAL Phone: (351) 1.3155150 FAX: (351) 1.525843 \npjpf@sabrina. inesc.pt This paper describes the problems and solutions found when developing a library \nproviding garbage collection for C++ programs. Not only objects are reclaimed, but also non-object memory \nwhich is usually allocated with the malloc()call. In order to reclaim non-object memory, an incremental \nmark- and-sweep algorithm is provided. The reclamation of objects can be done by the same incremental \nmark and sweep, or a multigenerational copy algorithm which drastically reduces the time of a global \ncollection. Pointers to the interior of objects are fully supported. The programmer only has to use a \nfew simple macros in order to have garbage collection in his program. He can also specify which objects \nare to be garbage-collected on a class-by-class basis. Thus, within an application there might coexist \nobjects that are garbage collected along with others that are not. A preprocessor is being developed \nto release the programmer from using these macros. Generational Garbage Collection for C- Based Object-Oriented \nLanguages Kazushi Kuse and Tsutomu Kamimura IBM Japan Tokyo Research Laboratory 5-19, Sanban-cho, Choyoda-ku, \nTokyo The approach we have taken here is to separate memory management of objects from that of standard \nC data. We provide automatic reclamation of objects, but do not reclaim C data. For this purpose, we \nimpose restrictions on the use of objects, so garbage collection of objects can be performed safely. \nSuch restrictions are basically to make typing of objects strong, to make run-time type information available, \nto disallow a network of pointers in the heap as well as the stack, and to disallow pointers to the middle \nof objects. DGD: Doom, Gloom and Despair-Distributed Garbage Detection made depressing Peter Dickman \nCambridge University and ERCIM currently at INRIA Rocquencourt, BP105 78 153 Le Chesnay Cedex, France \nPeter.Dickrnan@cl.cam.ac.uk The talk is aimed at those who haven t worked with distributed systems, and \nwill introduce some of the main problems that arise in Distributed Garbage Detection. A variety of techniques \nwill be presented, together with the problems that they are intended to solve and those that defeat them. \nThis survey will motivate the use of hybrid mechanisms, for example the one that David will present immediately \nafterwards. Variants on reference counting, the problems with tracing techniques and the use of non- \nconservative aging and refresh schemes will all be discussed. The various ways in which DGD s can be \nanalysed will be mentioned, in particular the various issues in counting messages and analysing space \nrequirements will be presented. Finally, scaling is introduced, with some guidelines on what to look \nfor in a scalable garbage detector. Distributed Garbage Collector as an Operating System Component David \nPlainfoss? and Marc Shapiro INRIA, BP105 78 153 Rocquencourt Cedex, France dp@sor.inria.fr Recent development \nof object-oriented technology has sparked interest in low-level support systems for user-defined objects. \nA number of operating systems and database systems offer such support. Until recently, garbage collection \nhas often been judged to be too language-dependent, too complex, and too costly for general-purpose systems. \nIn contrast, we think that operating systems should be designed and implemented to offer support for \ngarbage collection. Our approach is to provide a generic service for distributed garbage collection, \nbuilding upon existing, language-dependent, local garbage collectors. We have designed an efficient fault-tolerant \ndistributed garbage collection protocol, and we are currently planning to integrate it in the Soul nucleus, \na general-purpose object- oriented system layered above the Chorus micro- kernel. Inthe paper, we focus \non the protocol itself and especially on distribution and reliability aspects. Local and Global Distributed \nGarbage Collection Stephen C. Crawley Defence Science and Technology Organisation, PO Box 1500, Salisbury \n5108, Australia sxcQitd.dsto.oz.au This paper describes three garbage collection algorithms in a distributed \nobject system. The local algorithm collects garbage on a single machine independent of others. The extended \nlocal algorithm runs asynchronously on each machine collecting local and distributed garbage. The global \nalgorithm provides faster collection of all distributed garbage including cycles. All of the algorithms \nwill work when parts of the object system are unavailable.  Contact information: Paul R. Wilson Dept. \nof Computer Sciences University of Texas Taylor Hall 2.124 Austin, Texas 78712-1188 wilson@cs.utexas.edu \nUNIVERSITYOFTEXASATAUSTIN Barry Hayes Xerox PARC Room 2113 CSL 3333 Coyote Hill Road Palo Alto, California \n94304 bhayes@neon.stanford.edu STANFORDUNIVERSITY AND XEROX PARC  \n\t\t\t", "proc_id": "143773", "abstract": "", "authors": [{"name": "Paul R. Wilson", "author_profile_id": "81392595152", "affiliation": "", "person_id": "PP39081147", "email_address": "", "orcid_id": ""}, {"name": "Barry Hayes", "author_profile_id": "81332503329", "affiliation": "", "person_id": "PP31081135", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143773.143792", "year": "1991", "article_id": "143792", "conference": "OOPSLA", "title": "Garbage collection in object oriented systems", "url": "http://dl.acm.org/citation.cfm?id=143792"}