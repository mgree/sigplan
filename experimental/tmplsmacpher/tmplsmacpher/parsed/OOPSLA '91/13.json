{"article_publication_date": "09-01-1991", "fulltext": "\n BOF Phoenix, Arizona 6 -ff October 199J Object-based Visual Programming Languages Organizer: Sergiu \nS. Simmel Oberon Software Inc. Position Statements and Papers to a Birds-Of-A- Feather Session- A Few \nGuiding Questions for the Birds-of-a-Feather Session: the following questions had been mailed in advance \nto all announced participants, and had also been posted at the Conference before the BOF session Should \nOBVPLs be general purpose languages, or are the visual means at their best in the context of a more specialized \nlanguage? Should we think of OBVPLs as complementing other programming tools, or as self-sufficient? \n. What do you expect the visual aspect of OBVPLs buy you and your customers? Easier development? Easier \nto comprehend? Less intimidating? Easier to modify? Easier to debug? . Are the benefits of an OBVPL actual \nresults of a graphical visualization, or did the constraints of such a visualization force the language \ndesigner to keep the concepts simpler, higher level, and generally cleaner? . What is the proper granularity \nof objects in OBVPLs? Is there anything different than the textual languages? Should it be? . Is a class-based \nmodel appropriate for a visual language? Or is a class-less model based on prototypes, cloning, and delegation \ncloser to how we think about and with visual objects? . Assuming that OBVPL means that the PL is OB and \nnot just implemented that way, where are the objects? For example, assuming the language has nodes and \narcs, are the objects the nodes or things that appear on the arcs? Assuming there is something like methods, \nare they the nodes? Do nodes represent objects with all their methods, some of their methods, one of \ntheir methods, the message itself, or what? Should OBVPLs be designed with few but highly combinable \nprimitives (RISC-style), or should they have a larger number of low and high level, convenient facilities \n(CISC- style)? In other words, how complex should the basic visual semantics of an OBVPL be? Most textual \nOBVPLs have a small set of notions (like send a message), out of which they build everything (or which \nthey add to the non-object language of which they are an extension). Similarly, how complex should the \nvisual syntax of an object language be? For example, a simple (too simple?) visual language might have \nonly nodes and arcs, with no directionality, no attachment points, and so on. A complex visual language \nmight have different shapes, different parts of shapes, different colors, different joining rules, significant \nleft-right and top-bottom relationships, significant containment relationships, and so on. To write a \nformal grammar for such a language, one would need to build a lexical vocabulary out of all kinds of \nprimitive attributes and relationships. When is a dataflow model appropriate for an OBVPL? Is a control \nflow model appropriate? Is a communications model appropriate? What examples of lexical and syntactic \nelements in OBVPLs have been found particularly useful and versatile? Addendum to the Proceedings OOPSLA \n91 [ 991 . Which parts of the application development process are easier / harder with OBVPLs than with \ntextual OBLs? Editing, dependency browsing, debugging, . ..? How do the granularity and class / non-class \nissues impact the number of different objects of discourse, and therefore the need for good object identification \nand location tools? Does the visual nature of the system put new demands and/or provide new opportunities \nfor these tools? . Finally, how do various application domains influence or determine the answers to \nall of the above questions?  TaskMaster 1 Card-level Objects and User-Programmable System Brad Cox Information \nAge Consulting 269 Nettleton Hollow Road Washington Depot CT 06793 (203) 868-9182 FAX: -0780 71230.647@compuserve.com \nThis consists of the introductory sections from a much longer document with the same title. The longer \ndocument describes a multitasking executive called TaskMaster and a set of Objective-C syntactic extensions, \naction expressions , that provide source-level support for TaskMaster s exception handling and lightweight \nmultiprocessing extensions .  The companion papers, Planning the Software Industrial Revolution2 and \nThere is a Silver Bullet3 describe the longer-range vision behind this work. These papers characterize \nthe software crisis as an obstacle to moving from the Age of Manufacturing to the Age of Information, \nwhere computers become everyman s personal vehicle into a global information network, the Model T Ford \nof the Information Age. They see the software crisis as being solved as the telephone operator shortage \nwas once solved, by making every computer user a programmer. Of course, programmer will not mean what \nit does today. The word will acquire many different meanings appropriate to the skills and interests \nof diverse classes of users at different levels of a software architecture that is as heterogeneous as \nthe architecture of everyday objects such as computer hardware. For example, consider three programmers \nof entirely different skills and interest sets; Tom, Dick, and Harry: Tom is a programmer in the C++ \nsense of this word. Tom plays the role that silicon fabrication companies play in hardware, fabricating \ngate- and block-level silicon components into chip-level components that others with less specialized \nskills, such as Dick, can use. Gate- and block-level technologies, whether in hardware or software, are \ntightly-coupled activities in which optimization of the product, not their developer, is paramount. Dick \nis an programmer in the Smalltalk or Objective- C sense of the word. Dick plays the role that board vendors \nplay in hardware, assembling chip-level components that Tom produces into card-level components that \nothers with even less specialized skills, such as Harry, can use. Chip-level technologies, whether in \nhardware or software, are loosely-coupled activities in which developer concerns such as pluggability, \ninterchangeability, and reusability are paramount. Chip-level technologies support that crucial demarcation \nbetween tightly coupled fabrication technologies that only highly- skilled specialists use, such as silicon \nfoundries, and the much simpler, loosely-coupled assembly technologies that non-specialists can use, \nsuch as screwdrivers and soldering irons. Harry is an end user, one of the rest of us. Harry is a problem-domain \nexpert with no specialized software expertise at all. The goal of the architecture to be discussed in \nthis paper is to make Harry a card-level programmer in precisely that limited but nonetheless very real \nsense that end- users are card-level hardware designers when they choose which cards they ll buy to customize \na personal computer. Harry might be a clerk in an insurance office, a manager of a bank branch office, \nor in the following example, a homeowner using a personal computer to manage household finances. Today, \nHarry might be using an off-the-shelf personal finance program like ManagingYourMoney (MYM) on the Macintosh4. \nSuch programs let Harry manage his assets, liabilities, income, and expenses to provide an instantaneous \nreading of net personal worth. What today s programs and systems do not do is to help this class of users \nbuild their own custom solutions to their problem-specific needs. The Macintosh does not support end-user \nprogramming. For example, suppose that some of Harry s assets are in stocks, bonds and mutual funds, \nwhose contribution to net worth varies daily. When Harry tires of typing stock prices from the newspaper \nhe might venture into the Information Age by programming his terminal emulator to acquire price [loo \n1 9-11 October 1991 Phoenix, Arizona information from an information service like CompuServe electronically. \nAlthough Harry unlikely to ever program in C or even Smalltalk, he might well reach the point of using \na spreadsheet such as Excel to manage a database of price trends over time, perhaps using Excel s charting \nfacilities to show trends graphically. Today s non-programmable solutions are adequate only so long \nas Harry remains persuaded that all this mousing around to open and close documents, start and stop applications, \nand cut and paste numbers is a major improvement over typing each number manually If Harry should insist \non a way to build his own application to compute, with a single click, a graph of his personal net worth \nas it changes over I Plot Net uorth 4 item 32,2EEH in disk  5tring Itarch time, his desires have exceeded \nwhat the Macintosh in particular, and the software industry as a whole, can deliver today. The solution \nenvisioned in this document is shown in Figure 1. This figure is composed of Macintosh icons and screen \ndumps to imply that each icon behaves individually much as on the Macintosh today. However there are \nsignificant differences. The picture is not a collection of what-you-see-is-all- you-get icons that can \nonly be used manually, and (except for manual cut and paste) individually. The figure is the source listing \nof a program that I - Pbtting Progran  Figure 7: A program as might be created by an end-user, written \nin an iconic non-procedural c&#38;-level object-oriented programming language of the type envisioned \nin this document. build the ones shown in this figure. He purchased Harry has written in an iconic card-level \nobject- them elsewhere, from Dick, who assembled them oriented programming language , whose objects are \nfrom chip-level components fabricated by Tom. based on the lightweight multi-tasking facilities of this \npaper. The tasks are initially inactive, each awaiting input on the incoming arrows. When the Compute \nNet The icons represent lightweight tasks, or card-level Worth button (on another screen not shown here) \nis objects. Harry might save his Compute Net Worth clicked, this produces the signal that the terminal \nprogram as an new card-level component and use it emulator icon is waiting for. This triggers the task \nalongside those shown here. However Harry didn t Addendum to the Proceedings OOPSLA 91 11011 that the \nterminal emulator icon controls, which might be a card-level incarnation of a program like SmartComII, \nto dial the telephone, log into Compuserve, and type commands to download financial information. The \nthree string search icons are Harry s way of dealing with the fact that CompuServe does not provide financial \ninformation in a format that his spreadsheet can accept. He used a stream splitter process (the small \nblack circle) to send the data to three string search processes, and has programmed these to find specific \nstock prices and format them as the three history spreadsheets expect. And so forth- Unix programmers \nwill recognize this as a variation on the pipes and filters scheme of Unix. But there is one big difference \nthat my use of familiar Macintosh programs does not bring out clearly. Unlike Unix pipes that can only \ncarry streams of bytes, the arrows in this figure can carry streams of chip-level objects. Unlike Macintosh \nspreadsheets tliat only accept text, the programs in tliis figure are written to accept data expressed \nas objects. Objects can represent any structured data-type, including pointer-based structures like lists \nand trees. The arrow representing the input stream to the spread sheet icon need not be tab-delimited \nstrings that the spreadsheet must parse and reformat internally. The arrow to the spreadsheet object \ncould carry a stream of objects, instances of class Record, not a tab-delimited character stream as spreadsheets \nrequire today. Multilevel Software Architecture This document will use that fashionable but poorly understood \nbuzzword, object , with precisely the looseness of meaning this word has in hardware. That is, object \nwill carry no technical meaning whatsoever, unless qualified to make the architectural context clear. \nJust as a gate-level hardware object has nothing in common with a chip-, card-, or rack-level hardware \nobject, so it will be with the diverse software objects in the multilevel software architecture. The \narchitecture was motivated by appreciation for the multilevel architectures of hardware engineering, \nwhere high-level hardware objects such as office equipment are built from lower-level objects such as \ncards, card-level objects from lower- level objects such as silicon chips, and chip-level objects from \nlower-level objects such as silicon blocks and gates. It expects that the solution to the software crisis \nwill evolve as it did in hardware, by stratifying users/programmers according to skill levels and interests, \njust as the plumbing supply ilO2 I 9-11 October market is stratified into homeowner, plumbers, retail \noutlets, factories, refineries, and mines. End users, such as Harry, will use simplified modularity/binding \ntechnologies sufficient for limited categories of problems, such as the card-level objects described \nhere. They will acquire the needed objects by subcontracting the work to more specialized lower level \nworkers such as Tom and Dick. Figure 2 shows the five levels of this architecture. Although the objects \nat every level meet the classic definition of objects as inseparable units of state and behavior, the \nmodularity/binding mechanisms by which this is accomplished is totally diverse at the different levels: \nGate- and block-level objects are the expression- and subroutine-level objects of conventional programming \nlanguages like Cobol, Pascal, and C and of tightly-coupled object-oriented languages like Ada and C++. \nWith gate-level modularity (expressions, macros, etc.), the binding between objects is done entirely \nat compile time; by the compiler. Block-level modularity (subroutine libraries), delays binding until \nlink time, where the work occurs in the linker. Chip-level objects are loosely-coupled, dynamically bound, \nobjects as featured in languages like Smalltalk and Objective-C. With chip-level modularity, binding \nis delayed until the last possible moment. Binding is done by the program itself in the interest of loose \ncoupling, reusability, interchangeability, and pluggability. All subsequent layers share this property \nof late binding, although using a diversity of means for accomplishing it. The figure shows that C++, \nunlike Ada, provides limited support for chip-level programming in its virtual function mechanism, a \nform of dynamic binding. C++ s support for loose coupling is limited by its emphasis on tight-coupling, \ninheritance-based compile-time type-checking and static binding. Card-level objects are the task-level \nobjects of lightweight multi-tasking systems like Fabrik, Metaphor, and TaskMaster. They will be the \nprimary focus of this paper. Card-level modularity extend the traditional meaning of encapsulation to \nalso provide each object with it s own thread of control, its own internal clock and sense of 1991 Phoenix, \nArizona  Ptocmaa Fipm Al&#38;3 Slgn0la . . . . . . . . . . . . . . . . . . . . . . . . . . . . mka \nShea-m Exceplorre Figure 2: Object-oriented means different things at different levels of integration. \nPie slices represent the extent to which popular languages support work at each so/Ware history, in addition \nto lower-level objects, which maintain their state and behavior, but not their history. . Rack-level \nobjects are the oldest and most tightly-encapsulated modularity unit of all, the familiar notion of a \nprogram as an independently developed unit of functionality that we choose between when buying software \nat the local software store or when choosing what program to run on a personal or time-shared computer \nsystem. Just as in hardware, what distinguishes chip-level modularity from gate- or block-level modularity \nis loose coupling, dynamic binding, or pluggability. Whereas gate and block-level technologies are fabrication \ntechnologies; ways of fabricating things from first principles, chip- and higher-level technologies are \nassembly technologies; ways of assembling things by plugging together off-the- shelf components from \nlibraries of ready to use parts. None of these levels are panaceas that eliminate the need for other \nlevels. On the scale of any significant system, gate-, block-, and even chip-level objects are extremely \nsmall units of granularity-grains of sand where bricks are needed. But the rack-level modularity of operating \nsystems like Macintosh and Unix go too far in the opposite direction. The Addendum to the Proceedings \nOOPSLA 91 architectural level. rigorous encapsulation that makes rack-level modularity so useful for \npackaging software packages as independent programs, obstructs the free interchange of information between \nthese objects so rigorously that end-user programming is not possible. Card-level modularity provides \na middle ground, intermediate between the tightly encapsulated rack-level objects of operating systems \nlike Unix and the chip-level objects of programming languages like Smalltalk. Two Observations on Visual \nLanguages Sergiu S. Simmel Oberon Software Inc. One Memorial Drive Cambridge, MA 02142 USA 617-494-0990 \nFAX: -0414 simmel@oberon,com This brief position paper outlines two conclusions we have reached in our \nwork on an object-based visual language. The first is concerned with the granularity of entities represented \nby the objects in the language. The second is concerned with the abstraction level provided by the connections \nbetween language objects. [JO31 The field of visual languages is new, and largely unexplored. To date, \nuses for non-textual languages have been tried in various application domains, ranging from general programming \nto simulation to industrial control to systems integration. In our work at Oberon Software, we have come \nto several conclusions regarding the nature and use of visual languages in the current state-of-the- \ncommerce context. The following will briefly expand on two of these conclusions. 1. Granularity Object-based \nVisual Programming Languages best exploit their visual character when the objects are of larger, more \ncomplex grain. With the advent of cheaper graphical terminals and standard windowing and graphical system \nplatfonns, there has been an increase in the temptation to use graphical means to replace previous textual \nexpressions. This has been true with simple command interfaces as well as with more complex programming \nlanguages. Although it is the case that any language semantics can be given a graphics-based syntax, \none needs to ask two important questions: (i) how easy is to use the resulting VPL, and (ii) what is \nthe value added by the graphic treatment. The former question is crucial to the success and utility of \nthe overall software. The latter question is particularly important given the substantial added cost, \nboth in the development and maintenance of these graphic-based systems, as well as in the exploitation \nresources they require. It is our intuition that one of the factors that tends to increase the value \nadded by the visual aspect of the language is the granularity of the objects and operations expressed \nby the language. Objects that encapsulate larger grain entities appear to be better candidates for representation \nby connectable icons in a visual language. Why is that? We can only allude to several potential, and \npossibly controversial, reasons. . Larger grain entities tend to have more communication ports to the \noutside, and the two-dimensional graphic representation provides an edge over the one-dimensional textual \nalternative. . As the level of abstraction goes up, the size and syntactic complexity of useful programs \ntends to go down, for more work is actually done by each component. Since graphical representations can \neasily collapse [lo4 1 9-11 October under their own weight, the abstraction level helps naturally controlling \nthat. . As the represented entities get closer to the kinds of real world entities people would use in \nsolving a problem, iconic representations of the entities become all the more natural and intuitive. \n Our application, SynchroWorks5, is a platform for software and systems integration. Many of the objects \nin our domain of discourse represent larger grain entities, such as databases, classes, devices, spreadsheets, \nstructured documents, etc. We found this level of discourse to be best served by a visual representation, \nwhere the metaphor for integration is connectability. It is certainly not the case that all components \nin a visual language s syntax must be of large grain. Certain small grain components (e.g., a gate or \nan iterator) may still be needed. However, we feel that the bulk of the objects presented as connectable \nblocks must represent objects of larger grain. 2. Abstraction at Connections While blocks encapsulate \nand abstract active agents, connections among thern must correspondingly encapsulate and abstract data \ncommunications. One of the cornerstones of object-based technologies is the object s ability to encapsulate \nand abstract out details of their implementation. Data hiding within objects has been hailed as one of \nthe main sources of benefits that make these technologies so attractive. When it comes to communicating \nwith the rest of the world, however, textual language-based objects often regress to data types and to \ntraditional one-way subroutines calls. The situation is not that much different with many visual languages, \nwhich often use simple dataflow devices to model the communication between their objects. It is our belief \nthat more sophistication and encapsulation is needed in this area of inter-object communication. A communication-based \nparadigm which allows for fully bi-directional, arbitrarily complex dialogues between objects, and which \nalso hides the details of the communication by abstracting it out, is a more appropriate mechanism. SynchroWorks \nuses a service-protocol-role communication mechanism betweeu a visual program s building blocks. Building \nblocks are inter- connected at ports. In their inter-communication across connections, each of the two \nbuilding blocks plays a certain role. The communication is carried out by obeying a certain protocol. \nThe protocol, modeled 1991 Phoenix, Arizona as a state transition diagram, establishes what messages \ncan be exchanged between the two blocks, and in which order. A communication obeying a protocol accomplishes \na service, which is a higher order abstraction. Services are about what gets communicated. Protocols \nare about how the communication is carried out. Roles are about who does what. Connectivity among building \nblocks can be constrained (and therefore type-checked at connect time) by the services and protocols \ndefinitions. While protocols rigorously define communications, it is often the c<ase that the visual \nprogrammer is neither aware nor concerned with them. She can by and large operate at the service level. \nThis abstracting device brings connections and their communications at the s,ame level of abstraction \nas the building blocks (objects) they involve. By raising most objects to higher grain levels, and employing \ncommunication-based abstracting devices at their connections, we believe that an object-based visual \nlanguage can become a much more useful and easy to use tool.   Position Paper Randy Roseler MacDonald \nDettwiler &#38; Assoc. 13800 Commerce Parkway Richmond, BC VW 253 Canada 604-278-3411 FAX: -2936 rdrOmda.ca \n As a research engineer here at MacDonald Dettwiler, I have had the experience to try out many visual \nprogramming environments. Usually, the buzzwords visual programming mean that operational units are connected \ntogether with communication channels. The connects are constructed and destroyed using some type of graphical \ninteraction. Two good examples are aPE, Khoros, and Paragon Pipes. Another type of visual programming \nis screen builders, etc. I do not classify these painting systems as visual programming, though they \nare visually based. Servio s new database 4GL is a new (and fresh) visual programming environment. Programs \nare screens with buttons, the buttons activate pipe-lines as described above. The world is updated through \nside-effects. The reason this side-effect behavior was required is that the pure functional nature of \ncommunication- based program specification does not allow the description of state information. By state, \nI mean the type of state information which humans often assume when they describe a while or do loop. \nHere . is an example: Until 3 PM,or until you have 100 invoices . . . accept invoices from a customer \ncheck &#38; correct the addition and order info phone shipping and the credit company then, add up all \nthe invoices stamp them with the day s stamp transmit the total to the office manager. While I could \ndraw a dataflow for this process, it is less natural than the procedural code I am trying to avoid. More \ncomplicated examples could be constructed for which no pure dataflow (communication) model exists. My \ncontention is that visual programming will not truly enter the mainstream until the full power of a Turing \nmachine can be delivered. Perhaps a visual state machine will provide the missing capabilities. To date, \nhowever, I have not seen any such implementation.  The Cubicon Project Sanford B. Klausner Cubicon Company \n2290 Velerie Court Campbell, California 95008 USA 408-374-1409 FAX: -4502 72.560.10S4@compuserve.cotn \nCubicon is a new, revolutionary visual programming language. The following is a sumtnaty of Cubicon s \nmain characteristics.  Visual Object Comprised Architecture Cubicon uses pure object technology in conjunction \nwith true visual programming to raise programmatic abstraction levels to reduce the expression complexities \nof a software system. This reduction in expression complexity makes it possible for an end- user to express \nobject structure, behavior, and collaborationthrough the use of declarative graphics. Declarative graphics \ntake advantage of our impressive abilities to observe objects as static and Addendum to the Proceedings \nOOPSLA 91 L 1051 dynamic visual input. Programming becomes a task in visual thinking. The Cubicon software \ndevelopment environment provides the mapping between the pictorial notation and the executable code. \nThe Holy Grail of Cubicon is a finite set of atomic operation program icons which are expressed as iconic \nabstractions. This iconic abstraction set represents a virtual computational machine free to bind to \na wide variety of hardware architectures thus providing portability of Cubicon software. Program icons \nare arranged in behavior control-flow schema and replace textual source code. Atomic operation program \nicons are arranged with domain- specific program icons much like mental tinkertoys to describe behavior \nin a highly visible, standard form. Program icons can be applied to a wide dynamic range of computational \nproblems and behavior control-flow schemas become fragments for software reuse. Visual Declarative Style \nCubicon s style is based on a fundamentally opposite approach to graphics-based software development \nwhere the visual realm is the primary abstracting mechanism by which end-user captures concepts. Cubicon \nenables the declaration and manipulation of unconstrained graphics to express abstract and concrete visual \nrepresentations of a problem domain. Unconstrained graphics are used to frame problem domains into pure \nclass structures. Drawing elements are grouped into image program icons. Image program icons are executed \nwithin a constraining behavior control-flow structure. The combination of unconstrained and constrained \ngraphic expressions enable the rapid prototyping of an endless variety of sophisticated user interface \ndomains which meld window and multimedia concepts into one uniform visual paradigm. A Language with \nPersistence Cubicon realizes the tight database-language integration to an extent previously unattained \nby conventioual textual languages. The persistence, sharing, coordinating, access-control, and versioning \nproperties of Cubicon s graphical objects are not an after-thought, but an integral part of their semantics. \nThe model is that of a single omnipresent visual object base with a distributed and partitioned implementation. \nAll manipulation of visual objects take place within this context, thus integrating sessions and configurations \nto a true cooperative work environment. There is no such a thing as a database associated with Cubicon. \nCubicon is the visual object base! Integrated Development Environment The Cubicon software visualization \ntechnology is based upon a system structure cube model that represents six orthogonal views which capture \n100% of the executable specification in color graphical notation. Five of the cube facets represent design \nviews while the cube s interior represents the sixth implementation behavior view. A system s display \noutput is viewed on the cube s remaining face. Each model view is represented by a primary environment \nwindow which are collectively used to browse, build, aud maiutain graphical software systems. The cube \nmodel provides a concrete metaphor for new software developers to quickly grasp the dimensions of the \nCubicon environment. TaskMaster,Objective-C, ICpak, and Software-IC are trademarks of The Stepstone Corporation. \nAll rights reserved. Brad Cox; IEEE Software; November 1990 Brad Cox; Byte magazine; October 1991 I chose \nthis example because of personal experience. Although my programming skills are like Tom s and Dick s \nin other programming environments, I am like Harry on the Macintosh. If the Macintosh provides any solution \nto the example in this section, the solution has proven inaccessible to me, and by extension, to the \nHarrys of this world. SynchroWorks is a trademark of Oberon Software, Inc. All rights reserved. 1106 \n1 Q-11 October 1991 Phoenix, Arizona  \n\t\t\t", "proc_id": "143773", "abstract": "", "authors": [{"name": "Sergiu S. Simmel", "author_profile_id": "81100016670", "affiliation": "Oberon Software Inc.", "person_id": "P262171", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143773.270578", "year": "1991", "article_id": "270578", "conference": "OOPSLA", "title": "Object-based visual programming languages", "url": "http://dl.acm.org/citation.cfm?id=270578"}